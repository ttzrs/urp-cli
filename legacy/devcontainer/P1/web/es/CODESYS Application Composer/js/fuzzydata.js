$(document).ready(function () {indexDict['es'] = [{ "title" : "CODESYS Application Composer ", 
"url" : "_ac_start_page.html", 
"breadcrumbs" : "CODESYS Application Composer \/ CODESYS Application Composer ", 
"snippet" : "CODESYS Application Composer es un software para crear de manera eficiente variantes de aplicaciones que consisten en bloques de funciones recurrentes. Sobre la base de los módulos, se crea una aplicación de máquina y se parametriza. El programa PLC se genera automáticamente Mejora la reutilización ...", 
"body" : "CODESYS Application Composer es un software para crear de manera eficiente variantes de aplicaciones que consisten en bloques de funciones recurrentes. Sobre la base de los módulos, se crea una aplicación de máquina y se parametriza. El programa PLC se genera automáticamente Mejora la reutilización y la calidad de las partes de la aplicación Mayor eficiencia mediante la generación automatizada de aplicaciones a partir de módulos predefinidos Especialmente adecuado para la ingeniería simplificada de proyectos de aplicaciones en los campos de la fábrica digital o la industria 4.0 Las aplicaciones de la fábrica digital o la industria 4.0 se pueden planificar con mayor facilidad Listo para su uso inmediato gracias a los generadores suministrados y al concepto de aplicación Videoclip: Automatización de edificios con el CODESYS Application Composer complemento Proyectos de muestra Puede instalar y actualizar el CODESYS Application Composer complemento en el CODESYS Installer . " }, 
{ "title" : "Descripción general ", 
"url" : "ac_application_composer_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Descripción general ", 
"snippet" : "los CODESYS Application Composer se utiliza para crear aplicaciones mediante el uso de módulos existentes. El usuario compone, parametriza y conecta los módulos necesarios para formar una aplicación completa. Esta configuración no requiere conocimientos de programación de PLC y, por lo tanto, puede ...", 
"body" : "los CODESYS Application Composer se utiliza para crear aplicaciones mediante el uso de módulos existentes. El usuario compone, parametriza y conecta los módulos necesarios para formar una aplicación completa. Esta configuración no requiere conocimientos de programación de PLC y, por lo tanto, puede ser realizada por técnicos sin experiencia en programación. Los generadores internos crean aplicaciones IEC 61131-3 completas y bien estructuradas que incluyen el mapeo y las visualizaciones de E\/S. CODESYS Application Composer consta de dos componentes principales: Editor de módulos, que se puede utilizar para componer los módulos de software desarrollados con el editor de declaración de módulos. Editor de declaración de módulos para desarrollar módulos. Ejemplo de árbol y visualización del módulo CODESYS Application Composer Para obtener más información sobre el editor de módulos, consulte: Editor de módulosPara obtener más información sobre el editor de declaración de módulo, consulte: Editor de declaración de módulo" }, 
{ "title" : "Editor de módulos ", 
"url" : "ac_module_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos ", 
"snippet" : "Usando los editores de Application Composer, las instancias de módulo del árbol de módulos Se puede configurar y parametrizar. Los editores disponibles de la instancia del módulo se abren haciendo doble clic en el objeto o en el Editar objeto comando del menú contextual: Despliegue HMI Parámetros E\/...", 
"body" : "Usando los editores de Application Composer, las instancias de módulo del árbol de módulos Se puede configurar y parametrizar. Los editores disponibles de la instancia del módulo se abren haciendo doble clic en el objeto o en el Editar objeto comando del menú contextual: Despliegue HMI Parámetros E\/S Información Otros editores: Editor del módulo de extensión Editor de secuencia El Comparación de proyectos El comando también se puede utilizar para instancias del módulo Application Composer. " }, 
{ "title" : "Despliegue ", 
"url" : "ac_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Despliegue ", 
"snippet" : "Este cuadro de diálogo solo está disponible para instancias de módulo de nivel superior y proporciona configuraciones de aplicaciones y tareas. Diálogo para configuración de nivel superior Solicitud : Ingresado como objetivo de generación en la instancia del módulo de nivel superior. El El botón se ...", 
"body" : "Este cuadro de diálogo solo está disponible para instancias de módulo de nivel superior y proporciona configuraciones de aplicaciones y tareas. Diálogo para configuración de nivel superior Solicitud : Ingresado como objetivo de generación en la instancia del módulo de nivel superior. El El botón se puede utilizar para seleccionar una aplicación existente o crear una nueva aplicación especificando un nombre. Si la aplicación está asignada al grupo de POU, entonces mapeo de E\/S no es posible. En el caso de módulos desacoplados que tienen un módulo principal, se sugiere la aplicación principal ( [Usar aplicación para padres] ). Tareas estándar En esta sección hay hasta tres tareas predefinidas disponibles: una tarea con prioridad alta, otra con prioridad media y otra con prioridad baja. El nombre y la disponibilidad de las tareas se definen en el propio módulo y no se pueden cambiar (en el cuadro de diálogo de arriba: Tarea de bus de campo y Tarea estándar ). Además de las tareas predefinidas, el usuario puede crear una nueva tarea especificando un nombre si \" CREATE_IF_MISSING \"El indicador se establece en la declaración del módulo. El parámetro de la nueva tarea se puede definir en el Configuración estándar del generador . Tareas específicas del módulo : este campo muestra información sobre tareas específicas del módulo. " }, 
{ "title" : "E\/S ", 
"url" : "ac_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ E\/S ", 
"snippet" : "Este cuadro de diálogo proporciona información sobre las entradas y salidas del módulo. Las entradas y salidas describen la demanda de E\/S de los módulos y se pueden conectar a lo siguiente: Entradas y salidas de dispositivos. Entradas y salidas de otras instancias de módulo. Expresiones o constante...", 
"body" : "Este cuadro de diálogo proporciona información sobre las entradas y salidas del módulo. Las entradas y salidas describen la demanda de E\/S de los módulos y se pueden conectar a lo siguiente: Entradas y salidas de dispositivos. Entradas y salidas de otras instancias de módulo. Expresiones o constantes ST (ejemplo: para fines de simulación, las entradas del módulo booleano se pueden conectar a TRUE ) En modo en línea, el Valor en línea La columna es visible y se muestra el valor actual del controlador. Descripción general de E\/S de la interfaz del módulo Al hacer clic en Cartografía El campo abre el cuadro de diálogo de asignación de E\/S: Diálogo para asignación de E\/S Canal de E\/S : Al hacer clic en … El botón abre otro cuadro de diálogo para asignar la entrada\/salida a una E\/S de dispositivo. Expresión ST : Esta opción permite asignar la entrada\/salida a una expresión ST. Al hacer clic en El botón abre el Asistente de entrada para seleccionar una variable. Conectar al módulo de E\/S : Esta opción se puede utilizar para asignar la entrada\/salida a una E\/S que no tiene ninguna conexión. Al hacer clic en El botón abre el Asistente de entrada para seleccionar un módulo. Sin conexión : No hay mapeo de la entrada\/salida. Esta opción es similar a Conexión faltante , pero no genera el mensaje de advertencia. Conexión faltante : Esta opción es la predeterminada y genera una advertencia en la vista de mensajes al generar el proyecto. Las E\/S que el generador de dispositivos conecta automáticamente se indican mediante (AUTO) en la columna ENTRADA\/SALIDA y están deshabilitados. Si la asignación aún se cambia manualmente, se muestra una advertencia de que esta acción sobrescribirá la asignación automática. Si una conexión generada automáticamente se sobrescribe con una conexión establecida manualmente, este canal de E\/S ya no se considera en las operaciones del generador de dispositivos. " }, 
{ "title" : "HMI ", 
"url" : "ac_hmi.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ HMI ", 
"snippet" : "En este cuadro de diálogo, usted define la plantilla de página y las visualizaciones del módulo que deben integrarse en la visualización de nivel superior. Crear pestaña de nivel superior : Crea una pestaña en el nivel superior de la visualización que conduce directamente a la visualización de esta ...", 
"body" : "En este cuadro de diálogo, usted define la plantilla de página y las visualizaciones del módulo que deben integrarse en la visualización de nivel superior. Crear pestaña de nivel superior : Crea una pestaña en el nivel superior de la visualización que conduce directamente a la visualización de esta instancia del módulo. tecla de acceso rápido : Con el acceso directo configurado aquí, puede cambiar directamente a esta página de visualización. La configuración predeterminada para el acceso directo se define en la declaración del módulo en el std.Visu sección. Plantilla de página : Aquí se puede seleccionar una plantilla para la visualización del módulo que se utilizará como fondo para la visualización. La lista desplegable proporciona una selección de todas las visualizaciones que están definidas en la declaración del módulo. La primera visualización en la declaración del módulo está seleccionada de forma predeterminada. Si No visualización definida, se muestra \"Ninguno\". Insertar visualización : Esta función permite incrustar la visualización de la instancia del módulo en el siguiente módulo superior ( Próximo antepasado ) o en cualquier otra visualización de la instancia del módulo. Si está definido en el módulo, entonces el %PAGE_VISU% Se puede seleccionar un marcador de posición. En este caso, se incrusta la pantalla de visualización creada para la instancia del módulo. Se pueden definir varias entradas. Para obtener información sobre la creación de pantallas de visualización, consulte: Generando pantallas de visualización " }, 
{ "title" : "Parámetro ", 
"url" : "ac_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Parámetro ", 
"snippet" : "Este cuadro de diálogo muestra todos los parámetros disponibles de la instancia del módulo que se pueden parametrizar. las entradas en Parámetro , Tipo , Descripción , mín. , y máx. son sólo para fines informativos. Puede hacer doble clic en Valor campo para editarlo. Diálogo de parámetros de instan...", 
"body" : "Este cuadro de diálogo muestra todos los parámetros disponibles de la instancia del módulo que se pueden parametrizar. las entradas en Parámetro , Tipo , Descripción , mín. , y máx. son sólo para fines informativos. Puede hacer doble clic en Valor campo para editarlo. Diálogo de parámetros de instancias de módulo Los valores de los parámetros se muestran en negrita cuando se han configurado explícitamente; de lo contrario, las fuentes siguen siendo normales. Los parámetros modificados se pueden restablecer a su valor predeterminado mediante el Restablecen a los predeterminados comando en el menú contextual. Los parámetros en fuentes rojas deben ser configurados por el usuario porque, de lo contrario, se mostrará un error al crearlos. En modo en línea, el Valor en línea La columna es visible y se muestra el valor actual. Si cambia el valor del parámetro en el Valor columna, entonces el valor también se cambia en el controlador. Utilizar el Utilice valores en línea comando para copiar el valor en línea actual al Valor columna y, como resultado, utilizarla como valor de parámetro de la instancia del módulo en el árbol del módulo. En general, los valores de los parámetros se muestran y editan en la sintaxis de los literales IEC (ejemplo: valor de parámetro de tipo TIME como t#7s35ms . Después de cambiar un parámetro, el Generar El comando debe ejecutarse para crear el proyecto nuevamente. Si ha cambiado algún valor de parámetro en las instancias del módulo en modo en línea, puede usar el Valores de parámetros diferentes comando para obtener una lista de los parámetros modificados en el Mensajes vista. Al hacer doble clic en este tipo de mensaje se abre el cuadro de diálogo de parámetros para la instancia del módulo afectado donde los valores de parámetros modificados se indican con un marco rojo. " }, 
{ "title" : "Información ", 
"url" : "ac_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Información ", 
"snippet" : "Este cuadro de diálogo de información muestra detalles sobre el Icono , Nombre , Descripción , Fuente , Versión , Proveedor , y Categoría de la instancia del módulo. Como opción, también se pueden mostrar varios enlaces. Al hacer clic en los enlaces se abre la aplicación respectiva. El contenido de ...", 
"body" : "Este cuadro de diálogo de información muestra detalles sobre el Icono , Nombre , Descripción , Fuente , Versión , Proveedor , y Categoría de la instancia del módulo. Como opción, también se pueden mostrar varios enlaces. Al hacer clic en los enlaces se abre la aplicación respectiva. El contenido de la primera URL se muestra en el lado derecho. Para que los enlaces se muestren aquí, deben estar definidos en el MetaData sección de la declaración del módulo. Los dominios y sitios confiables se definen en la Aplicación Opciones de compositor . Si hace clic en una URL que no está definida como \"confiable\", se abre un cuadro de diálogo en la vista derecha. En esta vista, puede agregar la URL a los dominios o sitios confiables. " }, 
{ "title" : "Plantilla de origen ", 
"url" : "ac_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Plantilla de origen ", 
"snippet" : "Este cuadro de diálogo define qué bloques de funciones del grupo de POU se copian en la aplicación cuando se ejecuta el comando Generar. Para copiar bloques de funciones, el Plantilla de origen -el generador tiene que estar habilitado en el Configuración del generador . El cuadro de diálogo muestra ...", 
"body" : "Este cuadro de diálogo define qué bloques de funciones del grupo de POU se copian en la aplicación cuando se ejecuta el comando Generar. Para copiar bloques de funciones, el Plantilla de origen -el generador tiene que estar habilitado en el Configuración del generador . El cuadro de diálogo muestra todos los bloques de funciones definidos en el SourceTemplate sección de la declaración del módulo. Fuente-FB : Identificador de los bloques de funciones a copiar es copiar : VERDADERO\/FALSO: El bloque de funciones se copia o no se copia. Si el IsMandatory parámetro se define como TRUE en la declaración del módulo, entonces el valor no se puede cambiar aquí. Tipo de fuente FB : Nombre del bloque de funciones a copiar " }, 
{ "title" : "Editor: Exportar dispositivos ", 
"url" : "ac_export_devices.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor: Exportar dispositivos ", 
"snippet" : "Con este editor, puede seleccionar un archivo que haya sido generado por una exportación de dispositivo. Este dispositivo se agrega al árbol de dispositivos cuando se genera el proyecto. Este opción de configuración es necesario cuando se agregan dispositivos con propiedades especiales y cuando el g...", 
"body" : "Con este editor, puede seleccionar un archivo que haya sido generado por una exportación de dispositivo. Este dispositivo se agrega al árbol de dispositivos cuando se genera el proyecto. Este opción de configuración es necesario cuando se agregan dispositivos con propiedades especiales y cuando el generador de dispositivos no puede agregarlos. Identificador : Identificador de la declaración del módulo Archivo exportado : Selección de todos los archivos que están definidos en la declaración del módulo. Si solo se define un archivo en la declaración del módulo, entonces este archivo no se muestra aquí. Pueden existir varios ExportDevices para cada dispositivo. Estos se diferencian por sus identificadores de la declaración del módulo y se muestran aquí. " }, 
{ "title" : "Diálogo: Opciones: Compositor ", 
"url" : "ac_options.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Diálogo: Opciones: Compositor ", 
"snippet" : "Este subdiálogo del CODESYS El cuadro de diálogo de opciones proporciona diferentes pestañas para el CODESYS Application Composer ajustes....", 
"body" : "Este subdiálogo del CODESYS El cuadro de diálogo de opciones proporciona diferentes pestañas para el CODESYS Application Composer ajustes. " }, 
{ "title" : "Pestaña: General ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_71025f62d62f3d9cc0a8640e01589d60", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Diálogo: Opciones: Compositor \/ Pestaña: General ", 
"snippet" : "General Mostrar selección de nivel superior antes de la generación : Puede hacer clic Compositor → Generar para abrir un cuadro de diálogo para seleccionar los módulos de nivel superior. Puede reducir el tiempo de generación de la aplicación deseleccionando módulos que ya no cambian. Editores Tipo d...", 
"body" : "General Mostrar selección de nivel superior antes de la generación : Puede hacer clic Compositor → Generar para abrir un cuadro de diálogo para seleccionar los módulos de nivel superior. Puede reducir el tiempo de generación de la aplicación deseleccionando módulos que ya no cambian. Editores Tipo de editor de parámetros visualización de la Parámetros sobre el Parámetros pestaña (editor de módulos). Vista de árbol : Los grupos de parámetros se muestran en el editor como una estructura de árbol. Vista de pestaña : Los grupos de parámetros se muestran en el editor como pestañas individuales. Escanear Escaneo automático (guardado con el proyecto) : Los CODESYS Application Composer busca automáticamente módulos existentes e instancias de módulos cuando se inserta una nueva biblioteca en la vista de POU. : Los CODESYS Application Composer busca módulos existentes e instancias de módulos solo en los siguientes casos: Después de abrir el proyecto. Después de insertar una instancia de módulo en el árbol de módulos si no se realizó una búsqueda Nota: Esta configuración se guarda con el proyecto. Dominios confiables Sitios web confiables Las direcciones URL de esta lista se pueden mostrar en la Información pestaña del editor de módulos. Requisito: La URL está definida en la sección MetaData de la declaración del módulo. " }, 
{ "title" : "Pestaña: Editor de secuencias ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_70cecd07d62f3d9fc0a8640e00b85eda", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Diálogo: Opciones: Compositor \/ Pestaña: Editor de secuencias ", 
"snippet" : "General Mostrar referencias Mostrar parámetros Mostrar asignación de E\/S Mostrar nombres de instancias Mostrar comentario Mostrar variables en línea : El elemento respectivo se muestra en el paso de la editor de secuencias . Mostrar Ancho de paso : ancho del encabezado de la pestaña (en píxeles) Val...", 
"body" : "General Mostrar referencias Mostrar parámetros Mostrar asignación de E\/S Mostrar nombres de instancias Mostrar comentario Mostrar variables en línea : El elemento respectivo se muestra en el paso de la editor de secuencias . Mostrar Ancho de paso : ancho del encabezado de la pestaña (en píxeles) Valores válidos: 25–500. Distancia de paso (vert.) Distancia entre los pasos de la secuencia (en píxeles) Valores válidos: 10–100 Estándar conexión Una conexión conexión B Colores de las líneas de conexión entre los pasos de la secuencia. los colores de Una conexión y conexión B se utilizan después de un paso de bifurcación. Textos Parámetros Referencias canales de E\/S Colores para mostrar texto, parámetros, referencias y canales de E\/S Tipografía del texto El botón abre el cuadro de diálogo predeterminado para configurar la fuente del texto en el editor. fuente de enlace El botón abre el cuadro de diálogo predeterminado para configurar la fuente para etiquetar enlaces. " }, 
{ "title" : "Editor de secuencia ", 
"url" : "ac_sequenceeditor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de secuencia ", 
"snippet" : "El editor de secuencia es un editor gráfico que muestra y edita la árbol de módulos en un diagrama de flujo. Permite agregar y eliminar módulos o modificar sus propiedades. El editor también proporciona un modo en línea, que está destinado a usarse para rastrear los pasos del módulo activo y los pun...", 
"body" : "El editor de secuencia es un editor gráfico que muestra y edita la árbol de módulos en un diagrama de flujo. Permite agregar y eliminar módulos o modificar sus propiedades. El editor también proporciona un modo en línea, que está destinado a usarse para rastrear los pasos del módulo activo y los puntos de interrupción del módulo, de modo que pueda usarse para la depuración. El editor no implementa el flujo de secuencia en sí (ejecución y orden de secuencias). Esto se utiliza únicamente para mostrar y editar el árbol de módulos. Cualquier funcionalidad o lógica de los pasos del módulo debe implementarse en los bloques de funciones de los módulos como IEC ( CODESYS ) código de programa Editor de secuencia El editor está disponible para todos los módulos con la definición Raíz en la sección mse.Sequence de la declaración del módulo. El contenido del editor corresponde al árbol de módulos. Cada modificación en el árbol de módulos cambiará el editor de secuencia y viceversa. Sólo se mostrarán las instancias de módulo que se inserten debajo de \" Root \" instancia. Su contenido mostrado está definido por las definiciones en la sección mse.Sequence de su declaración de módulo. La apariencia de los pasos depende de la definición en la declaración del módulo. Además de la definición Root Existen las siguientes tres definiciones: Paso: Paralelo: Rama: " }, 
{ "title" : "Datos mostrados dentro del cuadro de secuencia ", 
"url" : "ac_sequenceeditor.html#UUID-c7b42e58-c2ec-c00e-5692-55a5d60221bd_d125a077ca9f50ac0a8640e01732ee5_id_ad20551e9b6d77a9c0a865200163ff8b", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de secuencia \/ Datos mostrados dentro del cuadro de secuencia ", 
"snippet" : "Dentro del cuadro de cada paso se mostrará el nombre del tipo de módulo y el nombre de la instancia del módulo (opcional) y el icono definido. Este último corresponde al icono definido en los metadatos del configuración del módulo . También se mostrarán los parámetros y canales de E\/S de la instanci...", 
"body" : "Dentro del cuadro de cada paso se mostrará el nombre del tipo de módulo y el nombre de la instancia del módulo (opcional) y el icono definido. Este último corresponde al icono definido en los metadatos del configuración del módulo . También se mostrarán los parámetros y canales de E\/S de la instancia del módulo, si así se define en la sección mse.Sequence . Lo mismo ocurre con las referencias, aunque se distinguen dos tipos diferentes de referencias: Referencias generales a instancias de módulos. Referencias de salto, que definen un salto dentro de la secuencia. Las instancias del módulo a las que se hace referencia se mostrarán con su ruta relativa en el árbol del módulo (ejemplo: ..\/..\/WaitTime ). lo que ocurre ..\/ están escritos en una notación abreviada (ejemplo: .\/..\/..\/ se convierte 3x[..\/] ). A cada paso se puede añadir un comentario, que se mostrará separado por una línea. Esto se guarda por separado para cada paso (instancia de módulo). Si el texto mostrado de los nombres de los módulos, parámetros, canales IO o referencias no cabe en el espacio dado dentro del paso, el texto se ajustará a una segunda línea. Si es necesario, se cortará el texto. En este caso, un … será añadido. En resumen, se pueden definir hasta un máximo de cuatro listas\/entradas adicionales para un paso de secuencia: Parámetros: nombre del parámetro + valor del parámetro Canales de E\/S: nombre del canal + nombre del objetivo del canal Referencias: icono, ruta y nombre de la instancia del módulo al que se hace referencia Para referencias de salto: >> + icono, ruta y nombre de la instancia del módulo de referencias Comentarios: línea horizontal + comentario Para obtener más información sobre el editor de secuencias, consulte los capítulos de ayuda. Trabajar en el editor de secuencias y Editor de secuencias en modo en línea " }, 
{ "title" : "Trabajar con el editor de secuencias ", 
"url" : "ac_sequenceeditor_edit.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de secuencia \/ Trabajar con el editor de secuencias ", 
"snippet" : "Cuando el puntero del mouse se mueve sobre un paso, se resalta en gris. Cuando el puntero se mueve sobre el extremo vacío de una conexión, se muestra un triángulo gris. Los pasos se pueden seleccionar haciendo clic en cambiar el color del paso seleccionado a rojo. También es posible la selección múl...", 
"body" : "Cuando el puntero del mouse se mueve sobre un paso, se resalta en gris. Cuando el puntero se mueve sobre el extremo vacío de una conexión, se muestra un triángulo gris. Los pasos se pueden seleccionar haciendo clic en cambiar el color del paso seleccionado a rojo. También es posible la selección múltiple de pasos. Los pasos se pueden mover arrastrando y soltando. Cuando el Control También se pulsa la tecla, se copian los pasos. Las posibles posiciones de inserción para pasos movidos o copiados están marcadas con una línea de puntos roja. Mover elementos arrastrando y soltando Cuando el puntero del mouse se mueve sobre un elemento de salto cuyo destino está disponible en la secuencia actual, el campo de texto de la referencia de salto también se conecta con el paso de destino especificado mediante una línea discontinua. El objetivo también está marcado con un círculo discontinuo. Objetivo de salto de una referencia de salto Edición con canales de E\/S Un doble clic en el canal de E\/S abre el cuadro de diálogo de asignación de E\/S, que también se utiliza en el editor de E\/S de instancias de módulo. Para más información, ver: E\/S " }, 
{ "title" : "Comandos del editor de secuencias ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_00bbee939046545bc0a8652000fd02ce", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de secuencia \/ Trabajar con el editor de secuencias \/ Comandos del editor de secuencias ", 
"snippet" : "Un clic derecho en un paso de secuencia o en el triángulo gris (paso paralelo vacío de la rama) proporciona los comandos del menú contextual que están disponibles en esta posición. Además del estándar Corte , Dupdo , y Pegar comandos, el menú proporciona los siguientes comandos: Agregar paso después...", 
"body" : "Un clic derecho en un paso de secuencia o en el triángulo gris (paso paralelo vacío de la rama) proporciona los comandos del menú contextual que están disponibles en esta posición. Además del estándar Corte , Dupdo , y Pegar comandos, el menú proporciona los siguientes comandos: Agregar paso después Cualquier paso posterior se muestra en un comando de lista. Como resultado, sólo se añaden escalones y módulos que serían adecuados en la ranura del módulo en esta ubicación. Agregar paso después de subsecuencias cerradas Este comando se puede utilizar cuando es necesario cerrar subsecuencias de ramas y secuencias paralelas. El paso insertado se agrega después de las subsecuencias y no dentro de ellas. Solo está disponible para posiciones que tienen subsecuencias que se pueden cerrar. Agregar comentario Agrega un comentario al paso seleccionado. Establecer referencia de salto Este comando sólo está disponible en el menú contextual de un elemento de salto. Se puede utilizar el ratón para dibujar una línea roja hasta el paso objetivo. El menú contextual de los elementos de secuencia seleccionados también se puede abrir con el barra espaciadora . Menú contextual de una sucursal Los pasos consecutivos están conectados con flechas. Para el elemento de rama, se pueden definir colores diferentes para las dos ramas. Para más información, ver: mse.Sequence. Los colores están definidos en el CODESYS opciones ( Editor de secuencia ). " }, 
{ "title" : "Cambiar la posición en los pasos de la secuencia. ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_74415e1a90465440c0a865200120cb10", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de secuencia \/ Trabajar con el editor de secuencias \/ Cambiar la posición en los pasos de la secuencia. ", 
"snippet" : "Para cambiar la posición de un elemento de secuencia, el elemento debe seleccionarse y arrastrarse con la tecla central del mouse. También se puede cambiar la disposición de los parámetros dentro del paso. Cambiar la posición de un paso de secuencia Como resultado, solo se puede mover la posición de...", 
"body" : "Para cambiar la posición de un elemento de secuencia, el elemento debe seleccionarse y arrastrarse con la tecla central del mouse. También se puede cambiar la disposición de los parámetros dentro del paso. Cambiar la posición de un paso de secuencia Como resultado, solo se puede mover la posición del elemento en el editor; no es posible cambiar la posición dentro de una secuencia y, por lo tanto, el orden. " }, 
{ "title" : "Cambiar parámetro\/comentarios\/nombre de instancia\/canales de E\/S ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_a585f36190465431c0a8652000ac8cda", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de secuencia \/ Trabajar con el editor de secuencias \/ Cambiar parámetro\/comentarios\/nombre de instancia\/canales de E\/S ", 
"snippet" : "para cambiar un parámetro , hay que hacer doble clic en él. Dependiendo del tipo de datos de la variable, el campo se puede editar o el valor de la variable se puede seleccionar de un cuadro de lista (ejemplo: TRUE o FALSE ). Los comentarios o los nombres de las instancias también se pueden cambiar ...", 
"body" : "para cambiar un parámetro , hay que hacer doble clic en él. Dependiendo del tipo de datos de la variable, el campo se puede editar o el valor de la variable se puede seleccionar de un cuadro de lista (ejemplo: TRUE o FALSE ). Los comentarios o los nombres de las instancias también se pueden cambiar haciendo doble clic. " }, 
{ "title" : "Edición de referencias. ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_939c29699046541bc0a865200038e978", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de secuencia \/ Trabajar con el editor de secuencias \/ Edición de referencias. ", 
"snippet" : "Una referencia se puede editar haciendo clic derecho sobre ella. El menú contextual proporciona una lista de referencias que se pueden insertar en esta ubicación. Establecer referencias En caso de una referencia de salto, el menú contextual proporciona la Establecer referencia de salto dominio. La e...", 
"body" : "Una referencia se puede editar haciendo clic derecho sobre ella. El menú contextual proporciona una lista de referencias que se pueden insertar en esta ubicación. Establecer referencias En caso de una referencia de salto, el menú contextual proporciona la Establecer referencia de salto dominio. La ejecución de este comando permite establecer el objetivo del salto usando el mouse. Se dibuja una línea roja punteada hasta el objetivo, que se puede configurar haciendo clic en ella. Una referencia de salto existente se puede eliminar con el Borrar desde el menú contextual. Establecer referencia de salto " }, 
{ "title" : "Editor de secuencias en modo en línea ", 
"url" : "ac_sequenceeditor_onlinemode.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de secuencia \/ Editor de secuencias en modo en línea ", 
"snippet" : "Después de que la aplicación inicia sesión, el editor de secuencia cambia al modo en línea. La apariencia de los pasos del módulo en el modo en línea es muy similar al modo fuera de línea. Se muestran todos los pasos, pero no se pueden seleccionar ni modificar como en el modo fuera de línea. Este mo...", 
"body" : "Después de que la aplicación inicia sesión, el editor de secuencia cambia al modo en línea. La apariencia de los pasos del módulo en el modo en línea es muy similar al modo fuera de línea. Se muestran todos los pasos, pero no se pueden seleccionar ni modificar como en el modo fuera de línea. Este modo también ofrece la posibilidad de mostrar valores variables dentro de un paso. Comandos en modo online En el modo en línea, el editor de secuencias ofrece dos comandos adicionales en el Compositor menú: Puntos de interrupción activos para el siguiente paso Vista central de puntos de interrupción " }, 
{ "title" : "Paso activo ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e0ed25b7911507a5c0a8640e003e283b", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de secuencia \/ Editor de secuencias en modo en línea \/ Paso activo ", 
"snippet" : "Si se declara adecuadamente en el declaración del módulo , el paso activo se mostrará en amarillo: Modo en línea – Paso activo...", 
"body" : "Si se declara adecuadamente en el declaración del módulo , el paso activo se mostrará en amarillo: Modo en línea – Paso activo " }, 
{ "title" : "Puntos de interrupción ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e06ef3f19ba07a7bc0a8652001bdb8af", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de secuencia \/ Editor de secuencias en modo en línea \/ Puntos de interrupción ", 
"snippet" : "Si se declara correctamente en la declaración del módulo, el editor le permite establecer puntos de interrupción. El punto de interrupción de un paso se puede establecer o restablecer mediante el Punto de interrupción de palanca comando desde el menú contextual del paso. Un punto de interrupción act...", 
"body" : "Si se declara correctamente en la declaración del módulo, el editor le permite establecer puntos de interrupción. El punto de interrupción de un paso se puede establecer o restablecer mediante el Punto de interrupción de palanca comando desde el menú contextual del paso. Un punto de interrupción activado se indica con un borde rojo. Si el punto de interrupción está activo (la secuencia se detiene en el punto de interrupción), el paso se mostrará en rojo. Modo en línea – Puntos de interrupción Para más información, ver: mse.Sequence" }, 
{ "title" : "Editor de módulos de extensión ", 
"url" : "ac_editor_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de módulos de extensión ", 
"snippet" : "El editor de los módulos de extensión sirve para definir extensiones y proporcionar los cuatro Metadatos , Parámetro, E\/S, y HMI pestañas. El editor se puede abrir haciendo doble clic en el bloque de funciones en el POU pool (en el directorio según el nombre de pila de la extensión). Manejo de error...", 
"body" : "El editor de los módulos de extensión sirve para definir extensiones y proporcionar los cuatro Metadatos , Parámetro, E\/S, y HMI pestañas. El editor se puede abrir haciendo doble clic en el bloque de funciones en el POU pool (en el directorio según el nombre de pila de la extensión). Manejo de errores En caso de errores fatales que impidan la visualización de los editores, los mensajes de error se mostrarán en la Metadatos página. Las páginas del editor están deshabilitadas para que no puedan reaccionar a ninguna entrada. Un ejemplo de este tipo de error es que falta un bloque de funciones del módulo. " }, 
{ "title" : "Cambiar eventos ", 
"url" : "ac_editor_extension_module.html#UUID-91f9cff1-6f9e-ea6b-b3cd-d65abac7523b_ef0072b48b6aa7c0a8640e00080c11_id_4681e6c5b4a5a074c0a8640e01e5e429", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de módulos de extensión \/ Cambiar eventos ", 
"snippet" : "El contenido de los editores se actualiza automáticamente si cambia el bloque de funciones, la lista de texto, el conjunto de imágenes o la visualización correspondiente. (Los objetos mencionados se considerarán \"correspondientes\" si se encuentran en la misma carpeta que el módulo de extensión)....", 
"body" : "El contenido de los editores se actualiza automáticamente si cambia el bloque de funciones, la lista de texto, el conjunto de imágenes o la visualización correspondiente. (Los objetos mencionados se considerarán \"correspondientes\" si se encuentran en la misma carpeta que el módulo de extensión). " }, 
{ "title" : "Metadatos ", 
"url" : "ac_metadata_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de módulos de extensión \/ Metadatos ", 
"snippet" : "En esta pestaña del Editor de módulos de extensión , se muestran la descripción y la categoría. Los textos mostrados (excepto la categoría) se leen de una lista de textos. Para ello se utiliza el lenguaje actual del sistema de programación. Si no hay texto disponible en este idioma, se utilizará el ...", 
"body" : "En esta pestaña del Editor de módulos de extensión , se muestran la descripción y la categoría. Los textos mostrados (excepto la categoría) se leen de una lista de textos. Para ello se utiliza el lenguaje actual del sistema de programación. Si no hay texto disponible en este idioma, se utilizará el texto predeterminado. Si no hay ninguna entrada de texto, no se mostrará ningún texto. Al igual que la lista de texto, las imágenes se leen del grupo de imágenes. Diálogo del módulo de extensión Metadatos Los botones a la derecha de los valores mostrados abren la línea correspondiente en la lista de texto o grupo de imágenes y, como resultado, permiten cambiar los textos. Si no hay texto\/imagen con el ID correspondiente se creará un nuevo elemento con este ID. " }, 
{ "title" : "Parámetro ", 
"url" : "ac_parameters_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de módulos de extensión \/ Parámetro ", 
"snippet" : "En la pestaña del editor de módulos de extensión , los parámetros del módulo de extensión se enumeran en una tabla. Diálogo del módulo de extensión: Parámetro El Identificación , Variable , Tipo , y Por defecto Las columnas son de sólo lectura. En el Nombre y Descripción columnas, puede hacer clic e...", 
"body" : "En la pestaña del editor de módulos de extensión , los parámetros del módulo de extensión se enumeran en una tabla. Diálogo del módulo de extensión: Parámetro El Identificación , Variable , Tipo , y Por defecto Las columnas son de sólo lectura. En el Nombre y Descripción columnas, puede hacer clic en la línea correspondiente (cuando ya esté seleccionada) o en barra espaciadora para saltar directamente a la línea correspondiente de la lista de texto respectiva. El texto mostrado se lee de la lista de textos utilizando el idioma actualmente configurado para el sistema de programación. Si este idioma falta en la lista de texto, se utilizará el texto predeterminado para la entrada. en la columna Por defecto Se mostrará el valor de inicialización del parámetro. Esta tabla admite la selección múltiple de entradas y el manejo estándar con mouse y teclado. Todas las acciones que cambian parámetros se pueden deshacer o rehacer mediante el estándar Deshacer y Rehacer comandos. El Cortar , Copiar , y Pegar Las funciones no son compatibles. Puede utilizar los botones de flecha o el Alt. + ↑ y Alt. + ↓ atajos para mover el parámetro seleccionado hacia arriba o hacia abajo para cambiar el orden. Puedes utilizar el botón con el X o el estándar Del comando para eliminar los parámetros seleccionados. Cualquier error o advertencia sobre los parámetros se mostrará en la parte inferior de la lista de mensajes. Si se selecciona un mensaje, el parámetro correspondiente se seleccionará en la lista de parámetros anterior. El botón con el asterisco o el Alt. + norte El acceso directo (si la tabla tiene el foco) se puede utilizar para abrir la Nuevo parámetro diálogo: Diálogo del módulo de extensión: Nuevo parámetro En la parte superior del cuadro de diálogo se muestra una tabla jerárquica con todas las variables compatibles del bloque de funciones. Para activar el DE ACUERDO botón se debe seleccionar una variable y un único Identificación debe ser ingresado. Si el Identificación no es único, se le agrega un signo de exclamación rojo con texto de error. En los campos Nombre y Descripción Se puede introducir el texto estándar que se almacenará en la lista de texto asociada. A continuación hay que añadir los textos de cada idioma a la lista de textos. Una variable se muestra si es una variable de entrada de un módulo de funciones o una variable local de una estructura. Se puede seleccionar una variable si tiene tipo primitivo. " }, 
{ "title" : "E\/S ", 
"url" : "ac_io_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de módulos de extensión \/ E\/S ", 
"snippet" : "Esta pestaña del editor de módulo de extensión y el cuadro de diálogo para crear nuevas E\/S se comporta de manera similar al Parámetros pestaña. En lugar de la columna Por defecto la dirección En fuera Se muestra la entrada\/salida. Diálogo del módulo de extensión: E\/S...", 
"body" : "Esta pestaña del editor de módulo de extensión y el cuadro de diálogo para crear nuevas E\/S se comporta de manera similar al Parámetros pestaña. En lugar de la columna Por defecto la dirección En fuera Se muestra la entrada\/salida. Diálogo del módulo de extensión: E\/S " }, 
{ "title" : "HMI ", 
"url" : "ac_hmi_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Editor de módulos de extensión \/ HMI ", 
"snippet" : "Esta pestaña del editor de módulo de extensión permite definir el visualizaciones de pagina así como el visualizaciones integradas . Ambos campos de texto permiten la definición de múltiples nombres de visualización, separados por comas. Diálogo del módulo de extensión: HMI...", 
"body" : "Esta pestaña del editor de módulo de extensión permite definir el visualizaciones de pagina así como el visualizaciones integradas . Ambos campos de texto permiten la definición de múltiples nombres de visualización, separados por comas. Diálogo del módulo de extensión: HMI " }, 
{ "title" : "Pantallas de visualización ", 
"url" : "f_application_composer_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Pantallas de visualización ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Plantillas de nivel superior ", 
"url" : "ac_toplevel_templates.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Pantallas de visualización \/ Plantillas de nivel superior ", 
"snippet" : "Una plantilla de nivel superior es una plantilla para la página de inicio de la visualización generada. Contiene un marco como marcador de posición para las páginas y pestañas específicas del usuario para cambiar a las diferentes páginas. Opcionalmente, hay botones para navegar a las páginas y una l...", 
"body" : "Una plantilla de nivel superior es una plantilla para la página de inicio de la visualización generada. Contiene un marco como marcador de posición para las páginas y pestañas específicas del usuario para cambiar a las diferentes páginas. Opcionalmente, hay botones para navegar a las páginas y una línea de estado y dirección. La plantilla de nivel superior se puede seleccionar en la configuración del Generador de visualización . los AC_ModuleBase biblioteca que forma parte de la instalación estándar de CODESYS Application Composer contiene tres plantillas de nivel superior: AC.GenVisu_Toplevel_Template , AC.Toplevel_Vertical_Template, y AC.Toplevel_3S_Vertical_Template . Plantillas estándar de nivel superior Plantilla de nivel superior: AC_Toplevel_3S_Vertical_Template Además de las plantillas preparadas, también es posible crear plantillas de nivel superior definidas por el usuario. Elementos de plantillas de nivel superior (1): Navegación: Arriba \/ Atrás \/ Adelante (2): Marco para mostrar páginas (3): Pestaña para navegación directa a páginas de nivel superior (4): línea de estado (5): Línea de dirección: Ruta de la instancia de la instancia del módulo mostrado Los elementos de la plantilla de visualización se identifican por sus nombres de elementos. En la lista siguiente, el nombre de los elementos está escrito entre paréntesis. Elementos obligatorios de la plantilla. [Frame] : Marco principal que muestra las páginas de visualización. Para obtener mejores resultados, el tipo de escala del marco debe establecerse en \"isotrópico\". [Tab_Template_1] , [Tab_Template_2] : Dos elementos que se utilizan para la apariencia y disposición de todas las pestañas. Tab_Template_1 define la posición de la primera pestaña y la apariencia de todas las pestañas. A partir de la posición de Tab_Template_2 se calculará la disposición de las pestañas (horizontal o vertical) y el espacio entre las pestañas. El color de la alarma se establecerá si la jerarquía de la página mostrada está por debajo de la instancia representada por la pestaña. Si el elemento es un botón, también se establecerá la variable de estado del botón. Si el elemento es un marco, no se utilizará el color de la alarma. En lugar de esto, la variable de marco de cambio se establecerá en \"1\", si se selecciona la pestaña (0 predeterminado). Elementos opcionales de la plantilla. [Up] , [Back] , [Forward] : Elementos para la navegación que pueden ser un botón o un marco. El tipo de elemento puede ser un botón o un marco. En caso de ser un marco, el marco debe contener tres visualizaciones las cuales deben estar en el siguiente orden: Neutro, Presionado, Desactivado. [Address] : campo de texto que genera la ruta de la instancia del módulo mostrado. [Status] : campo de texto que muestra el contenido de la variable de cadena global ac.g_stVisuStatusBar de la biblioteca AC_ModuleBase. Esta variable se puede utilizar en implementaciones de módulos propios para mostrar el estado de una variable. Todos los demás elementos no son especialmente manejados por el generador de visualización. Para la generación, la visualización de la plantilla copia y modifica la copia. El original no se modifica. A excepción de los elementos de visualización mencionados anteriormente, el generador de visualización intenta no cambiar ningún elemento que haya sido modificado manualmente. En la primera generación de visualización se copia la plantilla de visualización descrita. Esta copia, siempre que no sea eliminada por el usuario, sólo será modificada en ejecuciones de generaciones futuras y no se volverá a copiar. Esto se hace tratando una visualización de nivel superior de una ejecución anterior del generador como si fuera una nueva plantilla de visualización (la plantilla original nunca se modifica), aunque no se copia. Entonces, si hay pestañas adicionales, estas pestañas se agregarán a las pestañas ya existentes. Todas las demás propiedades y elementos no se tocarán si es posible para que los botones, pestañas, etc., que el usuario haya agregado manualmente mantengan sus posiciones. Al eliminar, por ejemplo, los botones de navegación, se pierden. Para generarlos, el visu de nivel superior debe eliminarse y regenerarse. " }, 
{ "title" : "Alineación de las pestañas ", 
"url" : "ac_toplevel_templates.html#UUID-b04a5efa-11da-0879-903b-e5e3a3f27499_ac_toplevel_templates0", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Pantallas de visualización \/ Plantillas de nivel superior \/ Alineación de las pestañas ", 
"snippet" : "Las pestañas se alinearán horizontalmente de izquierda a derecha o verticalmente de arriba hacia abajo. La posición relativa del elemento de plantilla. Tab_Template_1 y Tab_Template_2 define la alineación: Si la distancia vertical de los elementos es mayor que la distancia horizontal, los elementos ...", 
"body" : "Las pestañas se alinearán horizontalmente de izquierda a derecha o verticalmente de arriba hacia abajo. La posición relativa del elemento de plantilla. Tab_Template_1 y Tab_Template_2 define la alineación: Si la distancia vertical de los elementos es mayor que la distancia horizontal, los elementos se alinearán horizontalmente, en caso contrario verticalmente. En caso de alineación vertical, todas las pestañas tienen el mismo ancho, que es el ancho mínimo en el que se pueden mostrar todos los nombres de las pestañas. En el caso de una alineación horizontal, cada pestaña obtiene el ancho mínimo que puede mostrar su nombre. En ambos casos, la altura de las pestañas se establecerá en la altura de la primera plantilla ( Tab_Template_1 ). Para la ubicación, se copia y adapta la primera plantilla para cada pestaña. La colocación comienza en la posición de la primera plantilla; la distancia entre dos pestañas resulta de la distancia horizontal o vertical entre las dos plantillas. Esta distancia también puede ser negativa, en cuyo caso la siguiente pestaña se superpone a la anterior y pinta sobre ella porque está más adelante. En el caso de la alineación vertical, la generación se cancela con un error si no hay suficiente espacio hacia abajo para acomodar todas las pestañas. No se crea ninguna segunda columna de pestañas. En caso de alineación horizontal, se creará una nueva fila si la siguiente pestaña ya no encaja horizontalmente en la visualización. Si esto sucede con la primera pestaña de una línea, la generación se cancela con un error. Puede suceder que no haya suficiente espacio para la pestaña. En el caso de la alineación horizontal, esto sucede cuando se pasa a una nueva línea. Cuando se alinean verticalmente, sucede cuando el ancho de las pestañas es mayor que el espacio previsto para ellas en la plantilla. En estos casos se intenta crear más espacio. Debido a esta alineación automática de los elementos existen cuatro casos posibles para disponer las pestañas: Alineación horizontal de pestañas: todas las pestañas deben estar completamente por encima del marco. Alineación horizontal de pestañas: todas las pestañas deben estar completamente debajo del marco. Alineación vertical de pestañas: todas las pestañas deben estar completamente en el lado izquierdo del marco. Alineación vertical de pestañas: todas las pestañas deben estar completamente en el lado derecho del marco. Si la alineación de las pestañas no coincide con la restricción anterior, se creará un mensaje de error. Si no hay suficiente espacio para las pestañas, el marco se reduce en consecuencia. Todos los elementos entre pestañas y marco se mueven. La posición de un elemento se interpreta como \"entre pestañas y marco\" si no está completamente fuera del límite exterior de la primera plantilla de pestaña (consulte los ejemplos de disposición horizontal a continuación). La creación de la visualización se cancelará si la modificación del tamaño del marco daría lugar a valores negativos. Ejemplo de elementos entre pestañas y marco. Ejemplo de elementos \"fuera\" de pestañas y marco " }, 
{ "title" : "Generando pantallas de visualización ", 
"url" : "ac_generating_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Pantallas de visualización \/ Generando pantallas de visualización ", 
"snippet" : "Para las pantallas de visualización en Application Composer, todos los elementos de CODESYS V3 así como también se pueden utilizar las pantallas de visualización integradas. Además, se pueden utilizar elementos visu (ejemplo: rectángulo), que están marcados como marcadores de posición especiales: Na...", 
"body" : "Para las pantallas de visualización en Application Composer, todos los elementos de CODESYS V3 así como también se pueden utilizar las pantallas de visualización integradas. Además, se pueden utilizar elementos visu (ejemplo: rectángulo), que están marcados como marcadores de posición especiales: Navegación dentro de la visualización. La navegación dentro de la visualización se puede realizar mediante el uso de las pestañas o el Atrás , Arriba , y Adelante botones de navegacion. Un clic del ratón en los elementos de la pestaña cambia directamente a las pantallas de visualización correspondientes. El Atrás y Adelante Los botones se pueden utilizar para navegar dentro del historial de las pantallas mostradas (similar a la navegación en los navegadores de Internet). El Arriba El botón cambia al siguiente nivel superior. " }, 
{ "title" : "Elementos comodines en imágenes de visualización ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_1d3a1d9285970a30c0a8640e01de1c5b", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Pantallas de visualización \/ Generando pantallas de visualización \/ Elementos comodines en imágenes de visualización ", 
"snippet" : "Los elementos de visualización estándar (ejemplo: rectángulos, imágenes) se pueden utilizar como elementos marcadores de posición. Al generar la visualización, las visualizaciones incrustadas asignadas se organizarán en la posición del marcador de posición (posición y tamaño). Especificación La defi...", 
"body" : "Los elementos de visualización estándar (ejemplo: rectángulos, imágenes) se pueden utilizar como elementos marcadores de posición. Al generar la visualización, las visualizaciones incrustadas asignadas se organizarán en la posición del marcador de posición (posición y tamaño). Especificación La definición de elementos marcadores de posición se realiza mediante el nombre de instancia del elemento. El nombre del elemento debe ser PLACEHOLDER_<SUBPATH> . Sintaxis de <SUBPATH> : <SUBPATH> ::= <SLOTREF> | <SLOTREF>:<SUBPATH> <SLOTREF> ::= <SLOTNAME> | <SLOTNAME>[<idx>] El <SLOTNAME> es el nombre de destino de una ranura (las mayúsculas o minúsculas no son relevantes). <idx> es un índice de base cero que solo se puede utilizar para múltiples ranuras. Define qué instancia de submódulo del multislot se mostrará. Mientras lee la definición del módulo, el sistema verifica si los nombres de los marcadores de posición en las pantallas de visualización son válidos. Si un elemento de la pantalla de visualización comienza con \" PLACEHOLDER_ \" (mayúsculas o minúsculas no son relevantes), el <SUBPATH> debe comenzar con una referencia de ranura válida. Si hay un índice presente, debe ser compatible con la cardinalidad de la ranura. Todos los nombres de ranura de la ruta deben ser identificadores IEC válidos. Si hay varios marcadores de posición, todas las rutas deben ser diferentes. Además, los elementos del marcador de posición no deben tener áreas vacías. Si no existe ninguna instancia de módulo acorde al <SUBPATH> de un elemento comodín, no se asignará ninguna visualización a este elemento. No se creará ningún mensaje de error. Si existe una instancia de módulo acorde al <SUBPATH> de un elemento marcador de posición, este elemento se incrustará si se define como una visualización de pantalla incrustada para la pantalla actual. Las visualizaciones incrustadas mantendrán su relación de aspecto original. El tamaño se adaptará al marcador de posición de la mejor forma posible sin sobresalir del mismo. Ejemplo de elementos de marcador de posición Sólo las instancias de submódulo y sus instancias de submódulo se pueden incrustar utilizando marcadores de posición. No es posible incrustar visualizaciones de otras ramas del árbol de módulos. " }, 
{ "title" : "Comprobando la plantilla de nivel superior ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_335369a685ed9d34c0a8652001ab0576", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Pantallas de visualización \/ Generando pantallas de visualización \/ Comprobando la plantilla de nivel superior ", 
"snippet" : "Se realizan las siguientes comprobaciones en la pantalla de nivel superior: Si la plantilla de visualización no existe o si hay entradas o salidas definidas en su interfaz, se mostrará un error. Si falta algún elemento obligatorio se mostrará un error. Si se define un elemento de una plantilla de ni...", 
"body" : "Se realizan las siguientes comprobaciones en la pantalla de nivel superior: Si la plantilla de visualización no existe o si hay entradas o salidas definidas en su interfaz, se mostrará un error. Si falta algún elemento obligatorio se mostrará un error. Si se define un elemento de una plantilla de nivel superior pero tiene un área vacía o el tipo de elemento incorrecto, se mostrará un error. Si las plantillas de pestañas y el marco se superponen, se mostrará un error. Si la posición de la plantilla de la segunda pestaña es idéntica a la primera plantilla o si su posición está en el lado izquierdo o encima de la primera plantilla, se mostrará un error. En caso de alineación horizontal de las pestañas, se creará un error si las pestañas no están completamente por encima o por debajo del marco. En caso de alineación vertical de las pestañas, se creará un error si las pestañas no están completamente en el lado derecho o izquierdo del marco. " }, 
{ "title" : "Creando las pantallas de visualización. ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_85c3e6868b643da6c0a8640e01a0782b", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Pantallas de visualización \/ Generando pantallas de visualización \/ Creando las pantallas de visualización. ", 
"snippet" : "Todas las pantallas de visualización serán creadas inicialmente por el comando Generar . Con una segunda ejecución del generador, solo se actualizarán los parámetros modificados del árbol de módulos. Una pantalla de visualización creada contiene un marco que define el tamaño de la visualización y qu...", 
"body" : "Todas las pantallas de visualización serán creadas inicialmente por el comando Generar . Con una segunda ejecución del generador, solo se actualizarán los parámetros modificados del árbol de módulos. Una pantalla de visualización creada contiene un marco que define el tamaño de la visualización y que contiene la visualización correspondiente del módulo. Este marco está en segundo plano, todas las visualizaciones incrustadas se organizarán de la siguiente manera: Todos los elementos incrustados se identifican de forma persistente mediante el ID del elemento. Si una pantalla de visualización existente se actualiza mediante una nueva ejecución del generador, el sistema busca el ID correspondiente. Si este elemento (ID) existe, solo se actualizará el parámetro modificado en la configuración del módulo. Por ejemplo, la posición permanece sin cambios y el cambio de visualización\/cuadro y el objeto de visualización utilizado para la visualización pueden cambiar. Las visualizaciones integradas se organizarán en la pantalla de izquierda a derecha y de arriba a abajo. Un elemento marcador de posición coincidente tiene mayor prioridad. Finalmente, ambos mecanismos no se utilizan si el marco con las correspondientes ElementID ya existe durante la generación. En este caso, la posición se mantiene sin cambios. Se eliminarán las pantallas de visualización que se crearon en la última ejecución del generador, pero que no existen en la ejecución actual del generador. " }, 
{ "title" : "Orden de incorporación de elementos de visualización. ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_b67bb7c98bca4d3bc0a8640e01a07a7d", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Pantallas de visualización \/ Generando pantallas de visualización \/ Orden de incorporación de elementos de visualización. ", 
"snippet" : "En el primer paso, todas las visualizaciones que están integradas por next Ancestor será arreglado. Estos elementos se insertarán en el orden previo de las instancias del módulo en el árbol del módulo. (Primero el primer hijo, luego todos sus submódulos, luego el segundo hijo y así sucesivamente) De...", 
"body" : "En el primer paso, todas las visualizaciones que están integradas por next Ancestor será arreglado. Estos elementos se insertarán en el orden previo de las instancias del módulo en el árbol del módulo. (Primero el primer hijo, luego todos sus submódulos, luego el segundo hijo y así sucesivamente) Después de eso, se insertarán todas las visualizaciones incrustadas según la definición de la instancia. Esto también se hará en el pedido anticipado de las instancias del módulo. " }, 
{ "title" : "Gerente de persistencia ", 
"url" : "ac_pm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia ", 
"snippet" : "El Administrador de persistencia es un componente estándar de Application Composer. Se utiliza para gestionar datos remanentes persistentes. Reconoce tales variables por ciertos atributos en la declaración de variables. Entonces es un opción alternativa al mecanismo VAR PERSISTENTE del sistema de pr...", 
"body" : "El Administrador de persistencia es un componente estándar de Application Composer. Se utiliza para gestionar datos remanentes persistentes. Reconoce tales variables por ciertos atributos en la declaración de variables. Entonces es un opción alternativa al mecanismo VAR PERSISTENTE del sistema de programación estándar. que gestiona variables persistentes en una lista especial de variables globales ( Variables persistentes ). Este mecanismo está diseñado para el rendimiento del tiempo y el almacenamiento en un área de memoria remanente. Por el contrario, el Administrador de persistencia almacena valores persistentes en un archivo externo y por lo tanto exige menos recursos de memoria de un controlador. Permite mantener los valores incluso cuando se han modificado las declaraciones y permite la edición externa de los datos. Sin embargo, esta funcionalidad ampliada tiene como coste el rendimiento. Dependiendo del controlador, la lectura y especialmente la escritura de una gran cantidad de variables persistentes puede llevar mucho tiempo y bloquear la tarea respectiva durante mucho tiempo. Por lo tanto, depende del caso de uso qué mecanismo se recomienda para establecer la persistencia de los datos. En determinados casos, incluso el uso de recetas puede ser la mejor solución. Para ayudar a tomar una decisión, consulte: Persistencia El Administrador de persistencia es un módulo de nivel superior y se puede agregar al árbol de módulos mediante el comando Agregar instancia de módulo de nivel superior . Debajo del Administrador de persistencia puede insertar hasta 64 canales. En los canales puedes definir grupos de persistencia y configurar su comportamiento de almacenamiento por parámetros. Cada canal debe tener un submódulo. Data Storage , definiendo el formato en el que se escriben los datos persistentes en un archivo. Aquí se define el formato en el que se almacenan los datos persistentes en un archivo. Este archivo se almacena externamente, de forma predeterminada en el directorio de instalación del controlador. Para las versiones del sistema de tiempo de ejecución >= 3.5.8.0, la ubicación de los archivos comprimidos se define mediante el marcador de posición $ac_persistence$ . Los archivos ya existentes se moverán a esta ubicación, si se encuentran en el directorio definido por el marcador de posición $PLCLogic$ . Este directorio era la ubicación predeterminada en versiones anteriores del sistema de ejecución. Para los archivos ubicados en ambos lugares, se emite una advertencia en el registro del sistema de ejecución. Solo se puede agregar un Administrador de persistencia por aplicación al árbol de módulos. Si el Administrador de persistencia se agrega al POU grupo o si se agrega más de un administrador de persistencia a la aplicación, se creará un mensaje de error. Administrador de persistencia agregado al árbol de módulos Si se ha modificado el árbol del módulo o el parámetro de las instancias del módulo, se debe ejecutar una ejecución del generador. (Dominio: Generar) Diferencias con el mecanismo de \"VAR PERSISTENCE\" Los datos persistentes se almacenan en un archivo externo. Los datos persistentes se pueden intercambiar entre proyectos. Las variables persistentes se pueden eliminar de la aplicación o de la aplicación. agregado a la aplicación sin la pérdida de los datos restantes. Los datos creados por Persistence Manager se pueden modificar con editores externos. (Ejemplo: Bloc de notas). Ver también: Persistencia " }, 
{ "title" : "Módulo Administrador de Persistencia ", 
"url" : "ac_pm_persistencemanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Módulo Administrador de Persistencia ", 
"snippet" : "Un doble clic en el Gerente de persistencia nodo en el árbol de módulos o en el Editar objeto El comando abre los editores asociados. Además de los editores estándar de módulos de nivel superior (ver Descripción general ) el Administrador de persistencia proporciona la Persistencia pestaña. HMI El A...", 
"body" : "Un doble clic en el Gerente de persistencia nodo en el árbol de módulos o en el Editar objeto El comando abre los editores asociados. Además de los editores estándar de módulos de nivel superior (ver Descripción general ) el Administrador de persistencia proporciona la Persistencia pestaña. HMI El Administrador de persistencia proporciona una plantilla de visualización ( VISU_PersistenceManager ) que se puede agregar a la visualización. Diálogo para la configuración de HMI Esta página proporciona información estadística sobre la lectura y escritura de variables: Página de visualización de datos de persistencia " }, 
{ "title" : "Persistencia ", 
"url" : "ac_pm_persistencemanager_module.html#UUID-87fcb435-c65b-2e65-6037-f61974f5b1d7_e4fa0ddccaa0cf0c0a8640e01493625_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Módulo Administrador de Persistencia \/ Persistencia ", 
"snippet" : "Diálogo: Persistencia En el Persistencia En el cuadro de diálogo se pueden excluir uno o más grupos del almacenamiento. Para crear un nuevo grupo se debe ingresar un nombre único y agregarlo con el Agregar botón. El Eliminar El comando permite eliminar grupos existentes. Las variables se pueden excl...", 
"body" : "Diálogo: Persistencia En el Persistencia En el cuadro de diálogo se pueden excluir uno o más grupos del almacenamiento. Para crear un nuevo grupo se debe ingresar un nombre único y agregarlo con el Agregar botón. El Eliminar El comando permite eliminar grupos existentes. Las variables se pueden excluir del almacenamiento mediante el uso del atributo ac_persist_exclude . Para más información, ver: Atributo: ‚ac_persist_exclude' " }, 
{ "title" : "Canal de persistencia ", 
"url" : "ac_pm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Canal de persistencia ", 
"snippet" : "Un canal de persistencia define la configuración de almacenamiento para uno o más grupos de variables persistentes. Se puede agregar a un nodo del Administrador de persistencia mediante el uso del comando Agregar instancia de submódulo . Debajo de un nodo de Persistence Manager, se pueden crear hast...", 
"body" : "Un canal de persistencia define la configuración de almacenamiento para uno o más grupos de variables persistentes. Se puede agregar a un nodo del Administrador de persistencia mediante el uso del comando Agregar instancia de submódulo . Debajo de un nodo de Persistence Manager, se pueden crear hasta 64 canales. HMI, información Para obtener más información sobre estos cuadros de diálogo, consulte lo siguiente: E\/S, HMI y Información. " }, 
{ "title" : "Persistencia ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Canal de persistencia \/ Persistencia ", 
"snippet" : "Grupos persistentes En este diálogo se pueden definir uno o más grupos que son gestionados por este canal. De forma predeterminada, el nombre de la instancia del módulo de canal está disponible en la lista. Para crear un nuevo grupo, se debe ingresar un nombre único y agregarlo con el Agregar botón....", 
"body" : "Grupos persistentes En este diálogo se pueden definir uno o más grupos que son gestionados por este canal. De forma predeterminada, el nombre de la instancia del módulo de canal está disponible en la lista. Para crear un nuevo grupo, se debe ingresar un nombre único y agregarlo con el Agregar botón. Eliminar se puede utilizar para eliminar grupos seleccionados. Se pueden asignar variables a grupos a través del atributo ac_persist . Para más información, ver: Definición de variables persistentes, atributo 'ac.persist' Variables persistentes : esta lista muestra todas las variables persistentes asignadas a uno de los grupos de persistencia enumerados anteriormente. " }, 
{ "title" : "Parámetro ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Canal de persistencia \/ Parámetro ", 
"snippet" : "El Parámetros La pestaña proporciona una lista de opciones relacionadas con el almacenamiento de variables: Parámetros de canales persistentes. tAhorro periódico : Una vez transcurrido este intervalo, se almacenan las variables. Introduciendo el valor t#0s desactivará este ahorro periódico. xGuardar...", 
"body" : "El Parámetros La pestaña proporciona una lista de opciones relacionadas con el almacenamiento de variables: Parámetros de canales persistentes. tAhorro periódico : Una vez transcurrido este intervalo, se almacenan las variables. Introduciendo el valor t#0s desactivará este ahorro periódico. xGuardarAlCambiar : Si se establece en VERDADERO, el valor actual se comparará constantemente con el último valor guardado y, si son diferentes, se almacenará el valor actual. Canales de persistencia, que han establecido xSaveOnChange=FALSE , se almacenará cuando se apague el controlador y cuando se reinicie (caliente, frío, origen). Además, se puede realizar un ahorro periódico. xReadVarsDuranteInit : Si esto está configurado en TRUE , los valores de las variables persistentes se leerán durante la inicialización de la aplicación. En caso contrario, se cargan en el primer ciclo de aplicación. xCompressTags : Si esto está configurado en TRUE , las rutas de instancia de las variables se guardarán en un formato comprimido. Para más información, ver: Formato de almacenamiento, archivos comprimidos . xConsistentCopyInHighPrioTask : Si esto está configurado en TRUE , las variables se copian de la tarea de mayor prioridad y se guardan en la tarea de menor prioridad. Esta opción se utiliza para evitar inconsistencias en los datos cuando se cambian variables en una tarea de alta prioridad. xConvertVarsWithDifferentType : Si esto está configurado en TRUE , el canal de persistencia intentará convertir el valor leído del archivo al tipo de datos de destino (si el tipo de datos del valor es diferente al del destino). Si tiene éxito, se aceptará el valor del archivo; de lo contrario, el valor será rechazado. Esta función admite las siguientes conversiones: Tipo de datos en el archivo Tipo de datos de destino Descripción cualquier integer cualquier integer solo si el valor está en el rango cubierto por el tipo de datos actual cualquier integer Real cualquier integer LReal todos los tipos de datos String Real LReal Real ANY_INT solo si el valor del archivo es un número entero en el rango correcto LReal Real solo si el valor está en el rango cubierto por un REAL LReal ANY_INT solo si el valor del archivo es un número entero en el rango correcto xComprobación de integridad antes de leer : Si esto está configurado en TRUE , se comprueba la integridad de la base de datos. xSeparateArchivePerToplevelInstance : Cuando se establece en TRUE , se crea un archivo independiente para cada instancia de nivel superior. El nombre de dicho archivo es su propio nombre (tal como se configura en DataStorage) seguido del nombre de la instancia de nivel superior: <archive name>_<instance name> o <archive name> para todas las instancias que no estén por debajo de una instancia de módulo de nivel superior (por ejemplo, variables de aplicación). Esta opción está deshabilitada por defecto. Si posteriormente cambia el parámetro ( TRUE <-> FALSE ), los cambios de nombre del archivo y las variables persistentes se pueden perder. xMakeDataCRCConsistencyCheck : Si esto está configurado en TRUE , se calcula un valor CRC al principio y al final de la operación de guardar. Estos dos valores deben ser iguales para completar con éxito la operación de guardar. uiSavingRetriesIfCRCConsistencyCheckFails : Especifica el número de veces que se repetirá el almacenamiento si xMakeDataCRCConsistencyCheckFails se establece en TRUE y los valores de CRC no coinciden. xLogSaveTimeEnabled : Si esto está configurado en TRUE , se registra el tiempo necesario para escribir. eAcciónAutomáticaCambioEnLínea : Comportamiento, si y cómo se almacenan los valores de las variables durante un cambio en línea. Ninguno : Sin almacenamiento Ahorrar : Los valores se guardan. De este modo, también los cambios en la configuración se transfieren a la memoria de persistencia (p. ej., añadir o cambiar el nombre de variables). Carga : Los valores se cargan desde la memoria de persistencia. Por lo tanto, posibles inicializaciones (por ejemplo FB_INIT , IModule.Init y los parámetros del módulo) se sobrescriben con los valores persistentes. Cargar y guardar : Los valores se cargan y se escriben desde la memoria de persistencia. eAcciónAutomáticaPlcStop : Determina si los valores de las variables se almacenan durante un reinicio. Ninguno : Sin almacenamiento Ahorrar : Los valores se guardan. " }, 
{ "title" : "Módulo: Almacenamiento de datos ", 
"url" : "ac_pm_storage_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Módulo: Almacenamiento de datos ", 
"snippet" : "Almacenamiento de datos El submódulo Almacenamiento de datos define el formato de almacenamiento de un canal de persistencia . Elija uno de los siguientes formatos de almacenamiento: ASCIIFileStorage : Guardar los valores en formato ASCII en un archivo. El ASCIIFileStorage El formato permite abrir e...", 
"body" : "Almacenamiento de datos El submódulo Almacenamiento de datos define el formato de almacenamiento de un canal de persistencia . Elija uno de los siguientes formatos de almacenamiento: ASCIIFileStorage : Guardar los valores en formato ASCII en un archivo. El ASCIIFileStorage El formato permite abrir el archivo en un editor de texto y modificar los valores. Se pueden agregar comentarios al archivo de archivos ASCII. Estos serán ignorados cuando se lea el archivo. BinaryFileStorage : Guardar los valores en formato binario en un archivo. BinaryMemoryStorage :Guardar los valores en formato binario en el área \"RETAIN\" del compilador o del dispositivo en cuestión (ejemplo: en la NVRAM de dicho dispositivo). PersistentBinaryMemoryStorage : Guardar los valores en formato binario en el área \"Persistente\" del compilador o del dispositivo en cuestión (ejemplo: en la NVRAM de dicho dispositivo). Debajo del canal de persistencia inserte un Almacenamiento de datos módulo del formato deseado. Si es necesario, modifique la configuración en Parámetro pestaña: Diálogo: Información Para obtener detalles sobre este cuadro de diálogo, consulte: Información . " }, 
{ "title" : "Diálogo: Parámetros ", 
"url" : "ac_pm_storage_module.html#UUID-1d4190f0-4f49-535e-fe96-bf340f625ee5_aa44ae4cccad1068c0a8640e019d97f0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Módulo: Almacenamiento de datos \/ Diálogo: Parámetros ", 
"snippet" : "sNombreArchivo Nombre del archivo comprimido Por defecto, el marcador de posición %CHANNEL_NAME% se define. Este marcador de posición será reemplazado por el nombre de instancia del canal de persistencia superior. El nombre del archivo comprimido debe ser único, porque todos los archivos comprimidos...", 
"body" : "sNombreArchivo Nombre del archivo comprimido Por defecto, el marcador de posición %CHANNEL_NAME% se define. Este marcador de posición será reemplazado por el nombre de instancia del canal de persistencia superior. El nombre del archivo comprimido debe ser único, porque todos los archivos comprimidos se almacenan de forma predeterminada en el directorio de instalación del controlador. Nota: La ubicación de almacenamiento predeterminada para los archivos depende de la versión del sistema de ejecución. Ver: Descripción general del administrador de persistencia xAlmacenamiento Doble Si está activado ( TRUE ), las variables se almacenan alternativamente en dos archivos diferentes ( sArchive1 , sArchive2 ). En caso de un archivo dañado (ejemplo: debido a un apagado del controlador durante el almacenamiento de variables), se utilizará el archivo de respaldo. Cuando se abre el archivo, el Administrador de persistencia verifica la marca de tiempo de ambos archivos. En caso de que no haya daños, se utilizará el archivo más nuevo; en caso contrario, se utilizará el otro. udiTamaño máximo de archivo El tamaño máximo de archivo en bytes. Si 0 está definido, no se establece ni comprueba ningún límite. Entonces, el tamaño del archivo puede alcanzar cualquier tamaño. porSeparador Valor ASCII para separador entre nombre y valor de variable. udiMemDataTamaño Tamaño de la memoria en el área de variables \"RETAIN\", que se crea para el módulo. El valor se compara con el tamaño de los datos a almacenar. Si el valor es definitivamente demasiado pequeño, se crea un error de compilación. Si posiblemente es demasiado pequeño, se muestra una advertencia en la vista de mensajes. LineEnding Carácter que indica el final de la línea del archivo " }, 
{ "title" : "Definición de variables persistentes ", 
"url" : "ac_pm_definition_persistent_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Definición de variables persistentes ", 
"snippet" : "Las variables individuales, así como las instancias de estructura y las instancias de bloques de funciones, se pueden marcar como \"persistentes\" mediante el uso de atributos. Cuando se marca una instancia, todos los miembros de VAR , VAR_INPUT , y VAR_OUTPUT se almacenará de forma persistente. En ca...", 
"body" : "Las variables individuales, así como las instancias de estructura y las instancias de bloques de funciones, se pueden marcar como \"persistentes\" mediante el uso de atributos. Cuando se marca una instancia, todos los miembros de VAR , VAR_INPUT , y VAR_OUTPUT se almacenará de forma persistente. En caso de que las variables en un VAR PERSISTENT sección están marcados como \"persistentes\", se creará una advertencia. Además, existen atributos para definir un grupo de almacenamiento predeterminado, así como para excluir variables particulares del almacenamiento persistente de estructuras o instancias de bloques de funciones. Si se ha modificado la definición de variables persistentes (agregando, eliminando, renombrando, cambiando el tipo de datos) no se debe ejecutar ninguna nueva generación de código compositor (comando Generar). Estos cambios se actualizarán automáticamente en las instancias de Persistent Manager durante la compilación. Para obtener información sobre las posibles conversiones implícitas en caso de una definición de tipo de datos modificada, consulte: Parámetro Atributo: 'ac_persist_exclude' el atributo 'ac_persist_exclude' se utiliza para excluir una variable del almacenamiento persistente, sin importar si los miembros de la estructura o la declaración del bloque de funciones están definidos como \"persistentes\". Si no existen miembros persistentes en la declaración, se creará un error durante la generación del código. Ejemplo de exclusión de variables PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_exclude'}\n fb1 : FB;\nEND_VAR " }, 
{ "title" : "Tipos de datos admitidos ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_beff9eaed151b190c0a8640e01016617", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Definición de variables persistentes \/ Tipos de datos admitidos ", 
"snippet" : "Las instancias con los siguientes tipos de datos no se pueden almacenar de forma persistente: BIT Pointer Interfaces Constantes Matrices de tipos de datos no persistentes Todos los demás tipos de datos son compatibles. Esto incluye enumeraciones, tipos de datos de subrango, matrices de matrices y ma...", 
"body" : "Las instancias con los siguientes tipos de datos no se pueden almacenar de forma persistente: BIT Pointer Interfaces Constantes Matrices de tipos de datos no persistentes Todos los demás tipos de datos son compatibles. Esto incluye enumeraciones, tipos de datos de subrango, matrices de matrices y matrices multidimensionales: ARRAY[0..9] OF ARRAY[5..6, 7..8, 9..10] OF INT Tipo de datos: UNIÓN Para guardar la instancia de una unión de forma persistente, uno de sus campos debe marcarse como \"representante\". Hay tres formas posibles: Exactamente un campo en la declaración de la unión está marcado con el atributo ac_persist_union_representant (sin valor de atributo). Este campo entonces \"representa\" al sindicato. Su valor se guardará y cargará de forma representativa para la unión completa. Exactamente un campo en la declaración de la unión está marcado con el atributo ac_persist – esto define al mismo tiempo al representante. La instancia de la unión está marcada con el atributo. ac_persist_union_set_representant incluido el valor del atributo. El valor del atributo describe el nombre del campo de unión que se utilizará como representante. Este atributo sobrescribe un existente ac_persist_union_representant atributo en la declaración de la unión. Los conjuntos de uniones también se pueden marcar y hacer referencia a los elementos del conjunto. Ejemplos 'ac_persist_union_representant' TYPE UnionWithRep :\nUNION\n di : DINT ;\n {attribute 'ac_persist_union_representant'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 'ac_persist' TYPE UnionWithPersist :\nUNION\n di : DINT ;\n {attribute 'ac_persist' := 'TestUnion'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 'ac_persist_union_set_representante' FUNCTION_BLOCK FBTestUnion\nVAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n u2 : UnionWithoutRep ;\nEND_VAR Array of union VAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aElems ARRAY[0..7] OF SomeUnion ;\n\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aaElems ARRAY[0..7] OF ARRAY[0..1] OF SomeUnion ;\nEND_VAR Para que un representante sea válido debe cumplir las siguientes reglas: El representante debe tener el mismo tamaño que todo el sindicato. De lo contrario no se guardarían los datos completos. El representante tampoco debe tener áreas de relleno (áreas de datos vacías creadas por el compilador para alinear los datos en el almacenamiento). La descomposición del representante en tipos de datos primitivos no debe contener instancias de tipo REAL o LREAL o instancia de tipo STRING o WSTRING . Además, el representante debe constar de tipos compatibles (ver arriba). Por ejemplo el representante puede ser del tipo Structure – sin embargo, la estructura en sí no debe contener un puntero. " }, 
{ "title" : "Atributo: 'ac_persist' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_e844aaa8d151b192c0a8640e01722fe3", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Definición de variables persistentes \/ Atributo: 'ac_persist' ", 
"snippet" : "El atributo ' ac_persist 'puede usarse para variables Instancias de estructuras Instancias de bloques de funciones Miembros de estructuras Miembros de bloques de funciones. {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP es el nombre del grupo de persistencia al que debe asign...", 
"body" : "El atributo ' ac_persist 'puede usarse para variables Instancias de estructuras Instancias de bloques de funciones Miembros de estructuras Miembros de bloques de funciones. {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP es el nombre del grupo de persistencia al que debe asignarse la declaración. Debe ser un identificador IEC válido. Si no se nombra ningún grupo de persistencia aquí, la asignación se realizará según el atributo 'ac_persist_set_default_group' , que en este caso debe definirse. Si una instancia de estructura o una instancia de bloque de funciones está marcada como \"persistente\" y al menos un miembro en la declaración también está marcado como \"persistente\", se creará un mensaje de error. Ejemplo de una instancia persistente La variable t está asignado al grupo de persistencia PROCESS . Todos los miembros se almacenarán de forma persistente. PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist' := 'PROCESS'}\n t : TON;\nEND_VAR Ejemplo de miembros persistentes de un bloque de funciones El miembro iNumIOs está asignado al grupo de persistencia CONFIG . Este miembro se almacenará de forma persistente para todas las instancias del bloque de funciones (si no lo suprime explícitamente el atributo 'ac_persist_exclude' ). FUNCTION_BLOCK FB\nVAR\n {attribute 'ac_persist' := 'CONFIG'}\n iNumIOs : INT := 0;\nEND_VAR " }, 
{ "title" : "Atributo: 'ac_persist_set_default_group' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_4130a661d151b192c0a8640e00b1a163", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Definición de variables persistentes \/ Atributo: 'ac_persist_set_default_group' ", 
"snippet" : "Si el nombre del grupo falta en el atributo 'ac_persist' , a grupo predeterminado debe definirse en una instancia de bloque de funciones o instancia de estructura que contenga directa o indirectamente la variable respectiva. Esto es posible con el atributo 'ac_persist_set_default_group' . El atribut...", 
"body" : "Si el nombre del grupo falta en el atributo 'ac_persist' , a grupo predeterminado debe definirse en una instancia de bloque de funciones o instancia de estructura que contenga directa o indirectamente la variable respectiva. Esto es posible con el atributo 'ac_persist_set_default_group' . El atributo también se puede configurar para un miembro del bloque de funciones. La definición más interna encontrada de 'ac_persist_set_default_group' se utilizará como grupo predeterminado para la variable. No está permitido utilizar 'ac_persist_set_default_group' Juntos con 'ac_persist' o 'ac_persist_exclude' . En este caso, se creará un mensaje de error durante la generación del código. Ejemplo de un grupo predeterminado FUNCTION_BLOCK FB_Util\nVAR\n {attribute 'ac_persist'} \/\/ no group\n \/\/'ac_persist_set_default_group‘ and 'ac_persist_exclude' not allowed here\n i : INT := 0;\nEND_VAR PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_set_default_group' := 'PROCESS'}\n fbu1 : FB_Util;\n\n {attribute 'ac_persist_set_default_group'´ := 'CONFIG'}\n fbu2 : FB_Util;\nEND_VAR " }, 
{ "title" : "Almacenamiento de datos ", 
"url" : "ac_pm_data_storage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Almacenamiento de datos ", 
"snippet" : "El almacenamiento de variables persistentes se puede activar de varias maneras: Cada canal de persistencia proporciona una interfaz de aplicación que puede ser utilizada por la aplicación para activar un almacenamiento (consulte Acceso a los datos ). En los parámetros del canal de persistencia un in...", 
"body" : "El almacenamiento de variables persistentes se puede activar de varias maneras: Cada canal de persistencia proporciona una interfaz de aplicación que puede ser utilizada por la aplicación para activar un almacenamiento (consulte Acceso a los datos ). En los parámetros del canal de persistencia un intervalo de tiempo ( tAhorro periódico ) se puede definir para el almacenamiento automático. El canal de persistencia se puede configurar para almacenar una variable cada vez que cambia su valor. Para esto se compara el valor anterior y el valor actual; si son diferentes se activará el almacenamiento. Las diferentes formas de almacenamiento se pueden utilizar en paralelo y no son excluyentes entre sí. En caso de apagar el controlador o después de \"Reset\" (caliente \/ frío \/ origen), los datos se almacenan automáticamente si el parámetro xGuardarAlCambiar no está configurado. Para obtener más información, consulte también: Módulo: Almacenamiento de datos " }, 
{ "title" : "Formato de almacenamiento ", 
"url" : "ac_pm_storage_format.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Formato de almacenamiento ", 
"snippet" : "Hay dos implementaciones de la interfaz. IDataStorage disponible: ASCIIDataStorage y BinaryDataStorage . En ambos formatos la primera variable que se almacena es la variable reservada. ___xCompressTags de tipo BOOL . Su valor determina si las rutas de instancia se almacenan comprimidas. Si se escrib...", 
"body" : "Hay dos implementaciones de la interfaz. IDataStorage disponible: ASCIIDataStorage y BinaryDataStorage . En ambos formatos la primera variable que se almacena es la variable reservada. ___xCompressTags de tipo BOOL . Su valor determina si las rutas de instancia se almacenan comprimidas. Si se escribe un objeto de integridad, entonces se escribe como la última variable denominada ___Integrity de tipo BOOL con valor TRUE . Todas las variables persistentes, excepto estas variables reservadas, se almacenan en orden y se clasifican según su ruta de instancia completa. No importa si las rutas de la instancia están comprimidas o no. Si el usuario modifica los datos, debe asegurarse de que se mantendrá el orden de clasificación correcto. Archivos comprimidos Los valores de las variables se almacenan con ruta y nombre (en la ruta no está ni la aplicación ni el nombre del dispositivo) en una ortografía compacta para ahorrar recursos y tiempo. En cualquier caso (comprimidas o no), las rutas de instancia deben ordenarse según la ruta de instancia completa. Este orden de clasificación es alfabético, por lo que los índices de la matriz se ordenan numéricamente. Ejemplos Objetos Formato comprimido Fb1.fb2.fb3.a Fb1.fb2.fb3.a Fb1.fb2.fb3.b <b Fb1.fb2.d <<d Fb4 FB4 " }, 
{ "title" : "formato ASCII ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_7b30973fd16738e7c0a8640e01455e29", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Formato de almacenamiento \/ formato ASCII ", 
"snippet" : "ASCIIDataStorage escribe cada ruta de instancia de las variables persistentes (posiblemente en formato comprimido), el tipo de datos y el valor como una cadena en el archivo. El nombre y la fecha están separados por un carácter de tabulación (se puede cambiar por parámetro codbySeparator ). Cuando s...", 
"body" : "ASCIIDataStorage escribe cada ruta de instancia de las variables persistentes (posiblemente en formato comprimido), el tipo de datos y el valor como una cadena en el archivo. El nombre y la fecha están separados por un carácter de tabulación (se puede cambiar por parámetro codbySeparator ). Cuando se lea el archivo, se ejecutará una conversión. Por lo tanto, el archivo se puede modificar externamente. Las líneas deben estar separadas por \"\\r\\n\" (convención de Windows). Las líneas que comiencen con un punto y coma se ignorarán durante la lectura; esta línea no se agregará cuando se escriba el archivo. Formato de un archivo ASCII: {timestamp}\\r\\n\n{instance path}{bySeparator}{Typ}:{value}\\r\\n\n…\n{instance path}{bySeparator}{Typ}:{value}\\r\\n La marca de tiempo determina la hora en que se activó el almacenamiento. Está escrito como literal DATE_AND_TIME (ejemplo: DT#2012-01-11-15:11:09 ) Ejemplo de un archivo ASCII Tratamiento de REAL y LREAL variables: Los valores de las variables se escriben como literales ST. REAL y LREAL Los valores se tratan de manera diferente, porque la implementación de la conversión a y desde fracciones decimales sin pérdida de precisión. Sin embargo, para evitar cualquier pérdida de precisión y mantener la legibilidad y la posibilidad de modificar el archivo ASCII, estos valores se almacenan en formato hexadecimal. La fracción decimal (inexacta) se agrega detrás del valor hexadecimal como comentario. Mientras se lee el archivo, se admiten el formato hexadecimal y el formato decimal ST. Esto permite al usuario modificar la fracción decimal. El formato hexadecimal se define de la siguiente manera: F16#{Mantissa}H{Exp} | F16#NaN | F16#+Inf | F16#-Inf\n{Mantissa} ::= {HexNumeral}\n{Exp} ::= {HexNumeral}\n{HexNumeral} ::= [+-]?[1-9A-F][0-9A-F]* Si m es el valor de la mantisa y e el valor del exponente que el valor del número es m * 16^e . Ejemplo de un valor REAL almacenado lr1 LREAL:F16#F0H-3 0.05859375 " }, 
{ "title" : "formato binario ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_602fd614d22a5f95c0a8640e0110d837", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Formato de almacenamiento \/ formato binario ", 
"snippet" : "BinaryDataStorage guarda los datos en formato binario. La marca de tiempo sigue a eso (escriba DATE_AND_TIME ). Después de eso se enumeran las variables....", 
"body" : "BinaryDataStorage guarda los datos en formato binario. La marca de tiempo sigue a eso (escriba DATE_AND_TIME ). Después de eso se enumeran las variables. " }, 
{ "title" : "Acceso a los datos ", 
"url" : "ac_pm_data_access.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Acceso a los datos ", 
"snippet" : "Persistence Manager proporciona hasta 10 instancias de submódulo de tipo PersistenceChannel. Cada canal de persistencia proporciona una instancia de submódulo de tipo DataStorage que es el responsable del acceso a los datos. Esta instancia implementa la interfaz IDataStorage :...", 
"body" : "Persistence Manager proporciona hasta 10 instancias de submódulo de tipo PersistenceChannel. Cada canal de persistencia proporciona una instancia de submódulo de tipo DataStorage que es el responsable del acceso a los datos. Esta instancia implementa la interfaz IDataStorage : " }, 
{ "title" : "Diagnóstico ", 
"url" : "ac_pm_diagnosis.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Diagnóstico ", 
"snippet" : "Cada canal de persistencia tiene un submódulo que permite el acceso a los datos (interfaz IDataStorage ). Las siguientes salidas proporcionan información de diagnóstico: Producción Tipo de datos Descripción xActionOngoing BOOL TRUE si el Administrador de persistencia lee o escribe datos udiDataMemSi...", 
"body" : "Cada canal de persistencia tiene un submódulo que permite el acceso a los datos (interfaz IDataStorage ). Las siguientes salidas proporcionan información de diagnóstico: Producción Tipo de datos Descripción xActionOngoing BOOL TRUE si el Administrador de persistencia lee o escribe datos udiDataMemSize UDINT Tamaño de los datos persistentes en bytes xReadingDone BOOL Lectura de datos persistentes finalizada. dtLastReading DT Fecha y hora de la última lectura. uiNumberVarsNotOk UINT Número de variables que no se han leído correctamente uiNumberVarsOk UINT Número de variables que se han leído correctamente tTimeForReading TIME Duración del tiempo de lectura. dtLastSaving DT Fecha y hora de la última lectura. tTimeForWriting TIME Duración del tiempo para escribir. uiWritingCycles UINT Número de almacenamientos hasta el inicio de la aplicación. La información sobre el número de variables leídas y sobre el éxito del almacenamiento también se muestran en el registrador del PLC. Registro de PLC¶ " }, 
{ "title" : "Manejo de errores ", 
"url" : "ac_pm_error_handling.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Gerente de persistencia \/ Manejo de errores ", 
"snippet" : "Los números de error y las cadenas correspondientes se llaman o confirman mediante las interfaces del módulo estándar ( ClearErrors , FirstErrorNumber , GetFirstErrorMessage , LastErrorNumber , GetLastErrorMessage ). Numero erroneo Descripción 100 La lista de datos persistentes ha cambiado y no coin...", 
"body" : "Los números de error y las cadenas correspondientes se llaman o confirman mediante las interfaces del módulo estándar ( ClearErrors , FirstErrorNumber , GetFirstErrorMessage , LastErrorNumber , GetLastErrorMessage ). Numero erroneo Descripción 100 La lista de datos persistentes ha cambiado y no coincide con el tamaño inicial 110 No se puede crear memoria (para comparación o copia consistente). <ErrorCode SysMemAllocData> . La función está desactivada. 120 No se puede crear un almacenamiento de datos para el almacenamiento de comparación. La función está desactivada. 130 Almacenamiento de datos no creado para una copia consistente 140 Variable persistente de tipo String tiene un tamaño no válido: <nombre de la variable> 150 La variable persistente no es de tipo admitido: <nombre de la variable> 160 No se puede abrir la base de datos. Lectura cancelada: <descripción detallada del error del objeto de la base de datos> 170 La base de datos no se puede cerrar. Lectura cancelada: <descripción detallada del error del objeto de la base de datos> 190 No se puede crear la base de datos. Guardado cancelado. <descripción detallada del error del objeto de base de datos> 200 No se puede abrir la base de datos. Guardado cancelado. <descripción detallada del error del objeto de base de datos> 210 La base de datos no se puede cerrar. <descripción detallada del error del objeto de base de datos> 220 Error al escribir una entrada: <descripción detallada del error del objeto de la base de datos> 230 Error al leer la hora del sistema " }, 
{ "title" : "Administrador de registro de datos ", 
"url" : "ac_dlm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Administrador de registro de datos ", 
"snippet" : "El DataLog Manager es un componente estándar de Application Composer. Sirve para el almacenamiento cíclico de valores variables en un archivo. Estas variables están marcadas con etiquetas especiales. atributos en la declaración de variables. Para que el módulo esté disponible, debe agregar el AC_Dat...", 
"body" : "El DataLog Manager es un componente estándar de Application Composer. Sirve para el almacenamiento cíclico de valores variables en un archivo. Estas variables están marcadas con etiquetas especiales. atributos en la declaración de variables. Para que el módulo esté disponible, debe agregar el AC_DataLog biblioteca al administrador de la biblioteca. Sólo se puede agregar un DataLog Manager por aplicación al árbol de módulos. El DataLog Manager es un módulo de nivel superior y se puede agregar al árbol de módulos mediante el uso del Agregar instancia de módulo de nivel superior dominio. Debajo de los DataLog Managers puede insertar hasta 64 canales. En los canales se pueden definir grupos y configurar su comportamiento de almacenamiento por parámetros. Cada canal debe tener un submódulo de almacenamiento DataLog. Agregue DataLog Manager al árbol de módulos Si se ha modificado el árbol del módulo o el parámetro de las instancias del módulo, se debe ejecutar una ejecución del generador. (Dominio: Generar ). Para ello se utiliza el DataLog Generator en el Configuración del generador debe ser activado. " }, 
{ "title" : "Módulo: DataLog Manager ", 
"url" : "ac_dlm_datalogmanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Administrador de registro de datos \/ Módulo: DataLog Manager ", 
"snippet" : "DataLog Manager El Administrador de registro de datos Gestiona el registro de datos de variables. Se puede agregar al árbol de módulos debajo del objeto superior. Esto lo hace el Agregar instancia de nivel superior comando y la selección del Administrador de registro de datos módulo. Sólo se puede a...", 
"body" : "DataLog Manager El Administrador de registro de datos Gestiona el registro de datos de variables. Se puede agregar al árbol de módulos debajo del objeto superior. Esto lo hace el Agregar instancia de nivel superior comando y la selección del Administrador de registro de datos módulo. Sólo se puede agregar un DataLog Manager por aplicación. Diálogo: HMI El DataLog Manager proporciona una plantilla de visualización ( VISU_DataLogManager ) que se puede agregar a la visualización. Para más información, ver: HMIEn modo online esta página proporciona información estadística sobre la lectura y escritura de variables. " }, 
{ "title" : "Diálogo: Registro de datos ", 
"url" : "ac_dlm_datalogmanager_module.html#UUID-5158e4eb-39c1-2002-c9f6-d4d4a1d20765_f45d0fbcc9eecefdc0a8646307e5e8bf_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Administrador de registro de datos \/ Módulo: DataLog Manager \/ Diálogo: Registro de datos ", 
"snippet" : "En este cuadro de diálogo se pueden excluir uno o más grupos del almacenamiento. Por defecto el Administrador de registros de datos Se crea el grupo. Agregar Agregar y eliminar grupos que están excluidos del almacenamiento. Eliminar...", 
"body" : "En este cuadro de diálogo se pueden excluir uno o más grupos del almacenamiento. Por defecto el Administrador de registros de datos Se crea el grupo. Agregar Agregar y eliminar grupos que están excluidos del almacenamiento. Eliminar " }, 
{ "title" : "Módulo: Canal de registro de datos ", 
"url" : "ac_dlm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Administrador de registro de datos \/ Módulo: Canal de registro de datos ", 
"snippet" : "Canal de registro de datos El Canal de registro de datos El módulo se utiliza para definir grupos para el almacenamiento de variables. El módulo se puede agregar debajo del Administrador de registro de datos nodo. Esto lo hace el Agregar instancia de submódulo comando y la selección del Canal de reg...", 
"body" : "Canal de registro de datos El Canal de registro de datos El módulo se utiliza para definir grupos para el almacenamiento de variables. El módulo se puede agregar debajo del Administrador de registro de datos nodo. Esto lo hace el Agregar instancia de submódulo comando y la selección del Canal de registro de datos módulo. Se pueden agregar hasta 64 canales DataLog. Diálogo: HMI, Información Para obtener detalles sobre estos cuadros de diálogo, consulte la página de ayuda. IHM , y Información " }, 
{ "title" : "Diálogo: Registro de datos ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Administrador de registro de datos \/ Módulo: Canal de registro de datos \/ Diálogo: Registro de datos ", 
"snippet" : "En este diálogo se pueden definir uno o más grupos que son administrados por este canal. De forma predeterminada, el nombre de la instancia del módulo de canal está disponible en la lista. Grupos registrados en este canal Nuevo Definición de un grupo La entrada se agrega a la lista mediante el uso d...", 
"body" : "En este diálogo se pueden definir uno o más grupos que son administrados por este canal. De forma predeterminada, el nombre de la instancia del módulo de canal está disponible en la lista. Grupos registrados en este canal Nuevo Definición de un grupo La entrada se agrega a la lista mediante el uso de la Agregar mando. Usar rutas de instancias hash : La entrada no se almacena con la ruta completa de la instancia sino con el valor hash de la cadena para ahorrar espacio en la memoria. La asignación entre el hash y la ruta de la instancia se guarda en un archivo separado. Eliminar Elimina el grupo seleccionado de la lista Variables registradas Lista de variables asignadas a las listas Estas variables tienen la {attribute 'ac_datalog' := '<group name>'} atributo. Actualizar Actualiza la lista de variables registradas Nota: La lista solo se puede actualizar si el Generador de registro de datos está activado. Las variables pueden ser asignadas a los grupos por el ac_datalog atributo. los ac_datalog_histéresis El atributo define la histéresis que debe superarse antes de que se registre una variable. Ejemplo VAR\n {attribute 'ac_datalog' := 'DataLogChannel'}\n {attribute 'ac_datalog_hysteresis' := '0.745'}\n rLogVar : REAL;\nEND_VAR " }, 
{ "title" : "Diálogo: Parámetros ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Administrador de registro de datos \/ Módulo: Canal de registro de datos \/ Diálogo: Parámetros ", 
"snippet" : "En este diálogo se definen los parámetros para guardar las variables del DataLog. Activar FALSE : Las variables almacenadas por este canal no se registran. Guardar en el primer ciclo TRUE : Todas las variables de este canal se registrarán en el primer ciclo. Guardar cíclico Tipo de datos TIME : Toda...", 
"body" : "En este diálogo se definen los parámetros para guardar las variables del DataLog. Activar FALSE : Las variables almacenadas por este canal no se registran. Guardar en el primer ciclo TRUE : Todas las variables de este canal se registrarán en el primer ciclo. Guardar cíclico Tipo de datos TIME : Todas las variables de este canal se almacenarán cíclicamente. El valor T#0s desactiva el registro. " }, 
{ "title" : "Módulo: DataLog Storage CSV ", 
"url" : "ac_dlm_storage_csv_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Administrador de registro de datos \/ Módulo: DataLog Storage CSV ", 
"snippet" : "DataLog Storage CSV El submódulo DataLogStorage_csv define el formato de almacenamiento de un canal DataLog como archivo CSV. Se puede agregar debajo de un nodo de canal DataLog Esto lo hace el Agregar instancia de submódulo el comando y la selección del DataLogStorage_CSV  módulo. Cuadro de diálogo...", 
"body" : "DataLog Storage CSV El submódulo DataLogStorage_csv define el formato de almacenamiento de un canal DataLog como archivo CSV. Se puede agregar debajo de un nodo de canal DataLog Esto lo hace el Agregar instancia de submódulo el comando y la selección del DataLogStorage_CSV  módulo. Cuadro de diálogo: Información Para obtener más información sobre estos cuadros de diálogo, consulte la página de ayuda en Información . " }, 
{ "title" : "Cuadro de diálogo: Parámetros ", 
"url" : "ac_dlm_storage_csv_module.html#UUID-77b82c47-16c6-5f2f-5d4f-34b67bccf3d3_d1edd6c9f1f1a7c0a864637755e4ae_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Administrador de registro de datos \/ Módulo: DataLog Storage CSV \/ Cuadro de diálogo: Parámetros ", 
"snippet" : "Nombre de almacenamiento Nombre del archivo de almacenamiento De forma predeterminada, el marcador de posición %CHANNEL_NAME% está definido. Este marcador de posición se reemplazará por el nombre de instancia del canal DataLog superior. El nombre del archivo de almacenamiento debe ser único, ya que ...", 
"body" : "Nombre de almacenamiento Nombre del archivo de almacenamiento De forma predeterminada, el marcador de posición %CHANNEL_NAME% está definido. Este marcador de posición se reemplazará por el nombre de instancia del canal DataLog superior. El nombre del archivo de almacenamiento debe ser único, ya que todos los archivos de almacenamiento se almacenan en el mismo directorio Opcionalmente, un marcador de posición %DATE% se puede agregar para la fecha de almacenamiento. La resolución se define en el parámetro Cadena de formato para reemplazar %DATE% (ver más abajo). Ejemplo: Con la especificación del nombre '%CHANNEL_NAME%_AT_%DATE%' , el siguiente nombre de archivo da como resultado el DataLogChannel_1 canal: Application_DataLogChannel_1_AT_20191211_02-10-30.csv Separador : Valor ASCII para el separador entre el nombre y el valor de la variable. Ejemplo: ',' Tamaño del búfer : Tamaño del búfer interno para el almacenamiento temporal de las entradas. Ejemplo: 2000 Nivel de llenado del búfer Valor en porcentaje. Si el búfer se llena hasta este valor, el contenido del búfer se escribe en el archivo CSV. Especificando 0 desactiva el almacenamiento en búfer. Una entrada del archivo tiene el siguiente formulario (con | como separador): <TimeStamp>|<InstancePath\/Hash>|<Value>[|<TypeClass>] Si el almacenamiento se ejecuta con rutas con hash, el tipo de datos no se almacena con cada entrada, sino solo una vez en un archivo independiente donde se almacena la ruta de la instancia hash ↔ de asignación. La entrada de este archivo tiene el siguiente formato: <InstancePath>|<TypeClass>|<Hash> En caso de un cambio en línea, los archivos no se eliminan. Se adjuntan las nuevas entradas. En el archivo hash, un cambio en línea se marca con una marca de tiempo. Por lo tanto, aún es posible asignar la ruta de instancia de hash ↔ a las entradas antes de cambiarlas en línea Durante la inicialización, después de una descarga (sin cambios en línea), se eliminan los datos y los archivos hash. Caracteres adjuntos Añadir caracteres adjuntos TRUE : Las entradas de cadena se almacenarán junto con los alrededores. Ejemplo: Valor de variable: File1 , entrada de archivo: -File1- . FALSE : las entradas de cadena se almacenan sin incluir caracteres. Caracteres adjuntos Caracteres utilizados para encerrar. Ejemplo: '-' Cadena de formato para reemplazar %DATE% Formato de fecha usado para reemplazar el %DATE% que se puede especificar en el parámetro Nombre de almacenamiento (véase más arriba). Ejemplos: 'yyyyMMdd' , 'yyyyMMdd_hh-mm-ss' LineEnding Carácter que indica el final de la línea del archivo " }, 
{ "title" : "Módulo: DataLog Storage SQLite ", 
"url" : "ac_dlm_storage_sqlite_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Administrador de registro de datos \/ Módulo: DataLog Storage SQLite ", 
"snippet" : "DataLog Storage SQLite El submódulo DataLogStorage_SQLite define el formato de almacenamiento de un Canal de registro de datos para una base de datos SQLite. Se puede agregar debajo de un nodo de canal DataLog. Esto lo hace el Agregar instancia de submódulo comando y la selección del DataLogStorage_...", 
"body" : "DataLog Storage SQLite El submódulo DataLogStorage_SQLite define el formato de almacenamiento de un Canal de registro de datos para una base de datos SQLite. Se puede agregar debajo de un nodo de canal DataLog. Esto lo hace el Agregar instancia de submódulo comando y la selección del DataLogStorage_SQLite módulo. Diálogo: Información Para obtener más información sobre este cuadro de diálogo, consulte: Información . " }, 
{ "title" : "Diálogo: Parámetros ", 
"url" : "ac_dlm_storage_sqlite_module.html#UUID-63e71af3-388f-498c-6553-5ab20ff603a1_accbd5f8d8b6d029c0a86463569e125f_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Administrador de registro de datos \/ Módulo: DataLog Storage SQLite \/ Diálogo: Parámetros ", 
"snippet" : "Nombre de almacenamiento : Nombre del archivo de almacenamiento Por defecto, el marcador de posición %CHANNEL_NAME% se define. Este marcador de posición será reemplazado por el nombre de la instancia del canal DataLog superior. El nombre del archivo comprimido debe ser único, porque todos los archiv...", 
"body" : "Nombre de almacenamiento : Nombre del archivo de almacenamiento Por defecto, el marcador de posición %CHANNEL_NAME% se define. Este marcador de posición será reemplazado por el nombre de la instancia del canal DataLog superior. El nombre del archivo comprimido debe ser único, porque todos los archivos comprimidos se almacenan de manera predeterminada en el directorio de instalación del controlador. Todas las instancias de este módulo de una aplicación comparten este archivo. Este archivo lo crea inicialmente uno de los módulos de almacenamiento. El nombre del archivo es siempre <ApplicationName>_DataLog.sqlite Número máximo de entradas : El número máximo de entradas para la base de datos de esta instancia de módulo. El valor 0 desactiva la función. Si se supera el número máximo, la tabla se comporta como un búfer circular y se sobrescribirán las primeras entradas. " }, 
{ "title" : "Definición de variables de registro ", 
"url" : "ac_dlm_definition_logging_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Administrador de registro de datos \/ Definición de variables de registro ", 
"snippet" : "Las variables se marcan para el registro de datos por atributos. ac_datalog [:= group name] : este atributo asigna la variable a un grupo de registro. Si la variable es una variable estructurada, se registrarán todos los miembros que se puedan registrar y que no se excluyan. Si no se establece un no...", 
"body" : "Las variables se marcan para el registro de datos por atributos. ac_datalog [:= group name] : este atributo asigna la variable a un grupo de registro. Si la variable es una variable estructurada, se registrarán todos los miembros que se puedan registrar y que no se excluyan. Si no se establece un nombre de grupo, cada instancia de la variable estructurada debe marcarse por separado. ac_datalog_set_default_group : establece el grupo de todos los miembros de una instancia de un tipo estructurado que no están asignados explícitamente a un grupo. ac_datalog_exclude : este atributo excluye una variable de un tipo de datos estructurados del registro de datos. ac_datalog_union_representant : este atributo define un representante dentro de UNION, que se utiliza para el registro de datos. ac_datalog_hysteresis := ‘value‘ : Este atributo establece la histéresis. El valor debe superarse para registrar una variable. Este atributo solo se respeta para los tipos de datos numéricos. Si se utiliza para tipos de datos no numéricos, se mostrará una advertencia y se ignorará el valor. Encontrará una descripción adicional y ejemplos en la página de ayuda del Administrador de persistencia atributos " }, 
{ "title" : "Generador de diagnóstico de dispositivos ", 
"url" : "ac_device_diagnose_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Generador de diagnóstico de dispositivos ", 
"snippet" : "El módulo de diagnóstico de dispositivos es un componente estándar de Application Composer, que se incluye en la biblioteca AC_DeviceDiagnosis . El módulo es un módulo de nivel superior y se puede agregar al árbol de módulos mediante el comando Agregar instancia de módulo de nivel superior . Módulo ...", 
"body" : "El módulo de diagnóstico de dispositivos es un componente estándar de Application Composer, que se incluye en la biblioteca AC_DeviceDiagnosis . El módulo es un módulo de nivel superior y se puede agregar al árbol de módulos mediante el comando Agregar instancia de módulo de nivel superior . Módulo de diagnóstico de dispositivos en el árbol de módulos Con la ayuda del módulo de diagnóstico de dispositivos, se crea una página de visualización, basada en la configuración existente del dispositivo, que representa el PLC y los dispositivos de bus de campo conectados en una estructura de árbol. En esta estructura de árbol, se muestra el estado de cada componente. Si es necesario, se puede solicitar información detallada o cambiar el modo de funcionamiento de componentes individuales. Página de visualización generada para el diagnóstico del dispositivo Diagnóstico de dispositivos en modo online En el modo en línea, se muestran el nombre del dispositivo, el estado y el código de error. El estado de los dispositivos se muestra en un esquema de colores: Verde: el dispositivo tiene el estado \"En ejecución\" Rojo: El dispositivo no tiene el estado \"En ejecución\" Diálogo para cambiar el estado Al hacer clic en el dispositivo, se abre una ventana en la que se puede detener el dispositivo, ( Detener ), Reiniciar ( Reiniciar ) o iniciado ( Comienzo) . Cuando se abre el cuadro de diálogo por primera vez, se muestran todas las funciones. Las funciones que no son compatibles con el hardware desaparecerán tras la primera activación. " }, 
{ "title" : "Requisitos ", 
"url" : "ac_device_diagnose_overview.html#UUID-fd01086a-c692-d615-c1cf-d5963632aa4b_ac778b834d585cc0a8640e01a520c3_id_be299b7583c984f0c0a86520016ce88a", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Generador de diagnóstico de dispositivos \/ Requisitos ", 
"snippet" : "Los detalles de diagnóstico que se muestran provienen de los CAA-Device-Diagnose-FB (FB de dispositivo) que fueron creados por los dispositivos. Para generar estos componentes, la opción Activar diagnóstico para dispositivos debe establecerse en la configuración del PLC. Estos FB ofrecen no solo la ...", 
"body" : "Los detalles de diagnóstico que se muestran provienen de los CAA-Device-Diagnose-FB (FB de dispositivo) que fueron creados por los dispositivos. Para generar estos componentes, la opción Activar diagnóstico para dispositivos debe establecerse en la configuración del PLC. Estos FB ofrecen no solo la información de estado normal que se muestra en la vista general (arriba), sino también información detallada, que se muestra en una pantalla adicional. Si la opción Activar diagnóstico para dispositivos no se ha configurado antes de la generación, el proceso de generación se aborta y la opción se configura automáticamente, de modo que la siguiente ejecución de generación crea la visualización deseada. Para generar esta página de visualización, el generador de diagnóstico del dispositivo debe estar activado en el Configuración del generador . " }, 
{ "title" : "Comandos del Compositor de aplicaciones ", 
"url" : "core_applicationcomposer_composer_home.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones ", 
"snippet" : "Los comandos en la categoría de comando \"Compositor\" se proporcionan con el CODESYS Application Composer . Estos comandos sirven principalmente para agregar objetos composer al Árbol de módulos o para modificarlos. Además, hay funciones para asignar las variables a la configuración de E\/S y construi...", 
"body" : "Los comandos en la categoría de comando \"Compositor\" se proporcionan con el CODESYS Application Composer . Estos comandos sirven principalmente para agregar objetos composer al Árbol de módulos o para modificarlos. Además, hay funciones para asignar las variables a la configuración de E\/S y construir un CODESYS solicitud. La disponibilidad de los comandos depende del objeto seleccionado en el árbol de módulos: solo se seleccionarán los comandos que están permitidos en la posición seleccionada actual. " }, 
{ "title" : "Vista dedicada de Application Composer ", 
"url" : "ac_dedicated_view.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Vista dedicada de Application Composer ", 
"snippet" : "Application Composer proporciona una manera lo más fácil posible de crear aplicaciones completas y ejecutarlas. Dedicado a estos aspectos de simplicidad, CODESYS ofrece una vista reducida de la interfaz de usuario. Esta vista se puede iniciar seleccionando el perfil \"CODESYS Composer Dedicated\" o me...", 
"body" : "Application Composer proporciona una manera lo más fácil posible de crear aplicaciones completas y ejecutarlas. Dedicado a estos aspectos de simplicidad, CODESYS ofrece una vista reducida de la interfaz de usuario. Esta vista se puede iniciar seleccionando el perfil \"CODESYS Composer Dedicated\" o mediante el enlace correspondiente en la CODESYS entradas del menú de inicio. Después de eso, una vista reducida de CODESYS , que solo brinda acceso a las ventanas y comandos absolutamente necesarios para crear una aplicación que funcione utilizando el CODESYS Application Composer Se muestra el Compositor de aplicaciones. Vista dedicada de Application Composer Solo hay ventanas para el árbol de módulos, el árbol de dispositivos y los mensajes junto con los comandos para iniciar\/cerrar sesión\/ejecutar\/detener en línea y las operaciones de Composer. Dentro de este último, dos comandos están fuertemente relacionados con la vista \"Application Composer dedicada\": Generar, compilar e iniciar sesión : se utiliza para generar código, compilarlo y, finalmente, iniciar sesión en el dispositivo e iniciar la aplicación en el dispositivo. Agregar biblioteca de módulos al proyecto : se usa para agregar bibliotecas al Administrador de bibliotecas del grupo de POU, que normalmente no está disponible en la vista \"Dedicada al Compositor de aplicaciones\". Cualquier biblioteca agregada que contenga módulos hace que los módulos estén disponibles para agregarse en el árbol de módulos. " }, 
{ "title" : "Árbol de módulos ", 
"url" : "ac_module_tree.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Árbol de módulos ", 
"snippet" : "Además del árbol de dispositivos y el árbol de POU, Application Composer ofrece el árbol de módulos. Este árbol sirve para crear o modificar una aplicación mediante el uso de los módulos predefinidos. Los comandos de Application Composer permiten agregar submódulos al árbol de módulos o modificarlos...", 
"body" : "Además del árbol de dispositivos y el árbol de POU, Application Composer ofrece el árbol de módulos. Este árbol sirve para crear o modificar una aplicación mediante el uso de los módulos predefinidos. Los comandos de Application Composer permiten agregar submódulos al árbol de módulos o modificarlos o eliminarlos. La estructura de árbol se puede contraer o expandir. Ejemplo de un árbol de módulos Dependiendo del objeto seleccionado, se pueden agregar módulos compatibles al árbol. Esto se puede hacer mediante el uso de la comandos en el menú \"Compositor\" o mediante el uso del menú contextual. Los iconos de los elementos se definen en la declaración del módulo. " }, 
{ "title" : "Elementos del árbol de módulos ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_a88610fbb413e565c0a8640e00f61f5a", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Árbol de módulos \/ Elementos del árbol de módulos ", 
"snippet" : "(1): módulos de nivel superior que definen la configuración de aplicaciones y tareas (2): Submódulos (3): Referencias de instancia que hacen referencia a submódulos. Las referencias de instancia no tienen sus propios parámetros o E\/S. (4): Extensiones que se pueden crear sin Application Composer y q...", 
"body" : "(1): módulos de nivel superior que definen la configuración de aplicaciones y tareas (2): Submódulos (3): Referencias de instancia que hacen referencia a submódulos. Las referencias de instancia no tienen sus propios parámetros o E\/S. (4): Extensiones que se pueden crear sin Application Composer y que permiten realizar ajustes en la máquina (5): Slot (slots simples o múltiples) que pueden ser obligatorios u opcionales " }, 
{ "title" : "Visualización de la estructura de árbol ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_8a0710cab44f1a9bc0a8640e00ddf9a1", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Árbol de módulos \/ Visualización de la estructura de árbol ", 
"snippet" : "Los nodos secundarios, que se muestran bajo una instancia de módulo expandido, se mostrarán de acuerdo con las siguientes reglas, según las cuales el orden de todas las ranuras ocupadas y desocupadas siempre corresponde al orden de declaración de la declaración del módulo: En el caso de que solo se ...", 
"body" : "Los nodos secundarios, que se muestran bajo una instancia de módulo expandido, se mostrarán de acuerdo con las siguientes reglas, según las cuales el orden de todas las ranuras ocupadas y desocupadas siempre corresponde al orden de declaración de la declaración del módulo: En el caso de que solo se haga referencia a la instancia del módulo en esta ubicación, no tiene hijos. Se muestran todas las ranuras desocupadas, excepto las ranuras opcionales que están ocultas explícitamente. Para las ranuras, se muestran el nombre del rol y el tipo. Las ranuras ocupadas con cardinalidad 1 no se muestran (en su lugar, se muestran las instancias del submódulo conectado). La instancia del submódulo conectado reemplaza visualmente la ranura. Los submódulos opcionales y obligatorios se muestran en el árbol de módulos en la posición de las ranuras. El nombre de la función se muestra entre corchetes después del nombre de la instancia del módulo. Las instancias de submódulos de una ranura múltiple se muestran debajo de la ranura respectiva. Se muestra el nombre del rol porque está definido en el nodo principal. Las siguientes propiedades de las ranuras se indican con iconos adicionales: Ranuras opcionales Tragamonedas obligatorias Múltiples ranuras Referencias a instancias de submódulos Si se elimina una instancia de módulo, todas las referencias a esta instancia de módulo se marcarán con un icono de error. Si se cambia el tipo de instancia de un módulo, todas las referencias a este módulo con un tipo incorrecto se marcarán con un icono de error. Dependiendo de la posición en el árbol de módulos, el Corte \/ Dupdo \/ Pegar Se pueden utilizar los comandos del menú contextual. Los elementos del árbol de módulos se pueden mover mediante Drag&Drop. Presionando el control durante una operación de arrastrar y soltar, se copiará el elemento. Los elementos del árbol de módulos también se pueden exportar e importar en CODESYS . " }, 
{ "title" : "Diálogo del módulo ", 
"url" : "ac_module_dialog.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Diálogo del módulo ", 
"snippet" : "Mediante el uso de los comandos Agregar instancia de nivel superior , Agregar instancia de submódulo , Instancia de referencia , y Módulo de actualización , se abre un cuadro de diálogo no modal. Dependiendo de la posición en el árbol de módulos se mostrarán todos los módulos compatibles. Con un dob...", 
"body" : "Mediante el uso de los comandos Agregar instancia de nivel superior , Agregar instancia de submódulo , Instancia de referencia , y Módulo de actualización , se abre un cuadro de diálogo no modal. Dependiendo de la posición en el árbol de módulos se mostrarán todos los módulos compatibles. Con un doble clic en el módulo o con el botón Agregar módulo resp. Agregar instancia de submódulo el módulo seleccionado se copiará en el árbol de módulos. El botón Agregar módulo ( o Módulo de referencia ) solo está habilitado si se selecciona un módulo compatible y si la ranura seleccionada en el árbol de módulos no está llena. Además se debe introducir un nombre válido (con un identificador IEC válido). El nombre del objeto solo se puede definir para nuevas instancias de módulo. En el diálogo del Módulo de actualización comando, el nombre no se puede cambiar. Mostrar solo instancias compatibles : Esta opción filtra, cuando está activada, las instancias mostradas, de modo que solo se muestren las instancias compatibles. Si está desactivado se muestran todas las instancias, donde las instancias compatibles están resaltadas en negrita. Solicitud : La instancia del módulo de nivel superior se genera en esta aplicación. Hacer clic para seleccionar una aplicación existente. Diálogo para agregar instancias de módulo El diálogo no es modal. Permite la selección de otros objetos en el árbol sin tener que cerrar el diálogo. Los elementos enumerados en el cuadro de diálogo, así como las posibles acciones, se ajustan automáticamente. El comportamiento de este cuadro de diálogo es idéntico al Añadir dispositivo diálogo. " }, 
{ "title" : "Comando: Generar ", 
"url" : "ac_generate.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Generar ", 
"snippet" : "Generar Símbolo: Este comando (categoría \"Compositor\") inicia un proceso de compilación que genera automáticamente el CODESYS aplicación desde el árbol de módulos y la configuración del Configuración del generador . Los mensajes y errores se mostrarán en la vista de mensajes. Todos los objetos cread...", 
"body" : "Generar Símbolo: Este comando (categoría \"Compositor\") inicia un proceso de compilación que genera automáticamente el CODESYS aplicación desde el árbol de módulos y la configuración del Configuración del generador . Los mensajes y errores se mostrarán en la vista de mensajes. Todos los objetos creados por el generador estándar (excepto los objetos de tareas y las aplicaciones) se almacenarán en la subcarpeta de la aplicación respectivamente. Grupo de POU nombrado AC_Std y AC_FBs . Si ya existe una carpeta con el mismo nombre, se creará un nombre único agregando un sufijo _0 . Bloques de funciones generados Todos los objetos creados por el Generar El comando está marcado con un icono superpuesto de color azul. Si el usuario intenta eliminar, mover o modificar uno de estos objetos, se abrirá un cuadro de diálogo que le indica que esta acción puede causar problemas de compilación. Si el usuario continúa, el color del icono superpuesto cambia a rojo (consulte el bloque de funciones AC_PRG_RMP (PRG) en la captura de pantalla anterior). Si utiliza Application Composer junto con CODESYS SVN : Todos los objetos generados por Composer están marcados con un Ignore on Commit para SVN. Además, SVN se cambia al modo fuera de línea para evitar bloqueos de SVN mientras se ejecuta el comando Construido. Creación de la infraestructura de comunicación. Definición: En la siguiente descripción, la aplicación A1 envía a la aplicación A2 (o A2 recibe de A1) si se cumplen las siguientes condiciones: Una instancia de módulo asignada a la aplicación A1 hace referencia a una instancia de módulo asignada a la aplicación A2 o viceversa. Una salida de una instancia de módulo asignada a A1 se conecta a una instancia de módulo asignada a A2 mediante el uso de una conexión de E\/S de módulo directa. Todos los objetos mencionados a continuación se crearán en la carpeta. AC_RMP para cada aplicación creada por el generador. Se creará una tarea de comunicación. (Tiempo de ciclo y prioridad según los ajustes de la configuración del generador). En esta tarea, se llamarán las instancias de proxy y se leerán las variables FB del proxy del módulo reflejado. escrito. Para cada aplicación que envía a la aplicación actual, se creará una GVL (envío) y se definirán las configuraciones de red. (Protocolo \"UDP\", transmisión cíclica, suma de comprobación, tiempo de ciclo según la configuración, tarea de comunicación). El \"identificador de lista\", que debe ser un valor entero entre 1 y 2^15-1, se determinará aleatoriamente al comienzo de la generación y se incrementará en 1 después de cada envío de GVL. Este valor es al menos 128 y está dentro del rango válido. Si hay referencias de módulos entre las aplicaciones una variable de tipo RMPExchangeData se creará en el GVL. El nombre de la variable contiene el nombre de la aplicación de origen y de destino. Si una instancia de módulo define variables en su definición de proxy para reflejar ( MirrorVar ) y se hace referencia desde otra instancia de módulo, para cada una de estas MirrorVars se creará una variable en el GVL (envío) de la instancia de módulo a la que se hace referencia. Su nombre contiene la ruta de la instancia del módulo y el TargetID de la definición \"MirrorVar\" correspondiente. Para cada aplicación A2, a la que envía la aplicación actual, se creará una NVL (de recepción) y se conectará a la GVL de envío correspondiente de A2 y a la tarea de comunicación. Un bloque de funciones de tipo RMPService será instanciado en el GVL AC_RMP e inicializado en la declaración (con atributo init_on_onlchange ). Dos matrices de tipo RMPConnection Se crearán las cuales hacen referencia a las variables de tipo creadas. RMPExchangeData en los GVL y NVL. Un programa AC_PRG_RMP se creará el cual llama al bloque de funciones de tipo RMPService . Este programa se sumará a la tarea de comunicación. Además, el valor de las variables reflejadas (\"MirrorVars\") se establecerá y leerá en el AC_PRG_RMP programa. Esto significa que el proxy \"MirrorVars\" se asignará a las variables correspondientes del GVL (de recepción). Entonces el Main Se llama al método de la instancia de proxy y finalmente a las variables correspondientes del GVL (remitente) del módulo \"MirrorVars\". Esto sucede según la dirección de envío de las instancias del módulo a los servidores proxy. " }, 
{ "title" : "Creación de instancias de bloques de funciones mediante el generador estándar. ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_65e9c9d2b9a5b65fc0a8640e0003897d", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Generar \/ Creación de instancias de bloques de funciones mediante el generador estándar. ", 
"snippet" : "Para cada instancia de módulo se creará un bloque de funciones (en la carpeta AC_FBs ). Este bloque de funciones deriva del bloque de funciones del módulo. El bloque de funciones contiene variables de entrada Instancias de submódulo Matrices de tamaño configurable Variables de búfer de conexiones de...", 
"body" : "Para cada instancia de módulo se creará un bloque de funciones (en la carpeta AC_FBs ). Este bloque de funciones deriva del bloque de funciones del módulo. El bloque de funciones contiene variables de entrada Instancias de submódulo Matrices de tamaño configurable Variables de búfer de conexiones de E\/S directas Matrices de multislots y referencias de instancias. El nombre de la variable de matriz respectiva se crea mediante el prefijo AC_ARRAY_ seguido del nombre de la variable de puntero respectiva. Para matrices con tamaño de índice variable (VarArrays), el nombre se puede sobrescribir con el parámetro VarArray.InstName . La parte de implementación del bloque de funciones contiene el comando SUPER^(); que llama a la parte de implementación del bloque de funciones del módulo. Ejemplo La instancia del módulo ModuleInstanceA es de tipo ModuleA y bloque de funciones relacionado ModuleA_FB . Esta instancia tiene una instancia de submódulo de tipo ModuleB . La instancia del módulo ModuleInstanceA es de tipo ModuleA y bloque de funciones relacionado ModuleA_FB . Esta instancia tiene una instancia de submódulo de tipo ModuleB . FUNCTION_BLOCK AC_ModuleInstanceA EXTENDS ModuleA_FB\n\nVAR_INPUT\n Inst_Sub1 : AC_ModuleInstanceB ;\nEND_VAR El nombre del bloque de funciones se crea a partir de la ruta de la instancia del módulo y el prefijo AC_ . El nombre de la variable de la instancia del submódulo se crea a partir de un prefijo seguido del nombre de la instancia del submódulo respectivo. Se crea una instancia de cada bloque de funciones una vez, la instancia de FB del módulo de nivel superior directamente en el GVL y el resto en los bloques de funciones correspondientes de las instancias principales. Para cada instancia de módulo referenciada que esté ubicada en otra aplicación, se creará exactamente una instancia de bloque de funciones del FB proxy en una GVL de una instancia de módulo de referencia. El nombre de la instancia de proxy es AC_PROXY_<InstanceName> donde <InstanceName> es el nombre de la instancia de destino en la otra aplicación. Se asignan direcciones únicas a todas las instancias del módulo. Las instancias de FB proxy se asignan mediante las direcciones de las instancias del módulo en la aplicación remota. El método IBaseInstance.Main de las instancias de proxy se llama cíclicamente en la tarea de comunicación. " }, 
{ "title" : "Creación de la aplicación y llamadas de tareas. ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_c88cdc4bba310f0dc0a8640e0094f683", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Generar \/ Creación de la aplicación y llamadas de tareas. ", 
"snippet" : "Si se asigna un módulo a una aplicación que no existe, se creará esta aplicación. Creación de tarea estándar inexistente. TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW La prioridad y el tiempo de ciclo de las tareas se establecen de acuerdo con la configuración del generador. Además, se creará...", 
"body" : "Si se asigna un módulo a una aplicación que no existe, se creará esta aplicación. Creación de tarea estándar inexistente. TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW La prioridad y el tiempo de ciclo de las tareas se establecen de acuerdo con la configuración del generador. Además, se crearán tareas específicas del módulo con la configuración dada. Creación de una lista de variables globales por nivel superior. En esta GVL, se crearán instancias de módulo que se encuentran debajo de las instancias de módulo de nivel superior de la misma aplicación. La lista de variables globales tiene el nombre definido en el módulo, o si no tiene un nombre definido, obtendrá el nombre GVL_MODULE . La GVL se encuentra debajo de la aplicación seleccionada o en el árbol de POU global. Creación de una GVL con el nombre GVL_ MODULE_TREE para cada aplicación. Esta lista contiene variables para gestionar el árbol de módulos. El GVL se creará en la carpeta AC_Std . Creación de un código de inicialización que se llama automáticamente durante la descarga y el cambio en línea: Se creará la estructura de árbol. Se establecerán los valores de los parámetros. Se asignarán referencias e instancias de submódulos. Se completarán las matrices con tamaño variable. Se establecerán referencias de instancia. Al descargar, solo se configurarán los parámetros que no estén configurados en su valor predeterminado. Al realizar el cambio en línea, se configurarán todos los parámetros. Las POU se crearán en la carpeta AC_Std . Para cada punto de entrada definido, un PROGRAM Se creará una POU (lenguaje ST) que contiene las llamadas de los módulos de nivel superior. La llamada de esta nueva POU se agregará debajo de la tarea. En el caso de la tarea estándar, los nombres de las POU son: MODULE_CALL_<TASKNAME>_START MODULE_CALL_<TASKNAME>_END Las POU se crearán en la carpeta AC_Std . Para módulos de nivel superior en el POU pool las llamadas de tarea se crearán en todas las aplicaciones. " }, 
{ "title" : "Creación de la asignación de E\/S ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_bf24656dba310f0fc0a8640e01fdf5a6", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Generar \/ Creación de la asignación de E\/S ", 
"snippet" : "Dependiendo del tipo de asignación de E\/S se realizarán las siguientes acciones: [Canal de E\/S]: En el canal del dispositivo correspondiente se agregará el nombre de la instancia de E\/S de la instancia del módulo. [Expresión ST]: Las asignaciones de las expresiones a las entradas o de las salidas a ...", 
"body" : "Dependiendo del tipo de asignación de E\/S se realizarán las siguientes acciones: [Canal de E\/S]: En el canal del dispositivo correspondiente se agregará el nombre de la instancia de E\/S de la instancia del módulo. [Expresión ST]: Las asignaciones de las expresiones a las entradas o de las salidas a las expresiones serán para todas las instancias de módulo debajo de la misma instancia de nivel superior. Si hay asignaciones correspondientes, para cada instancia de nivel superior una función llamada AC_Io_SetInputs_<instance name> o AC_Io_SetOutputs_<instance name> se creará. La tarea que define entradas y salidas será identificada por la bandera UPDATE-IOS en la descripción del módulo. Esta tarea se denominará \"tarea de E\/S\" en la siguiente descripción. La función para las entradas se llamará en la tarea de E\/S antes de que se llame al método de tarea de la instancia del módulo. (Si la tarea de E\/S es una tarea estándar, antes del método de inicio). La función para las salidas se llamará en la tarea de E\/S después del método de tarea de la instancia del módulo. (Si la tarea de E\/S es una tarea estándar, después del método final). [Conexión directa al módulo de E\/S, local]: Se creará una variable de búfer de tipo compatible en el bloque de funciones de la instancia de la entrada. El nombre de la variable del buffer comienza con el prefijo AC_Io_Buffer_ . Las variables del búfer se inicializarán con los valores actuales de las salidas conectadas durante la inicialización de la aplicación. El generador maneja las asignaciones de entrada y salida como una asignación ST a esta variable de búfer (ver [expresión ST]. [Conexiones directas a E\/S del módulo, remotas]: Para cada salida que se conecta a una entrada de una instancia de módulo de otra aplicación, se creará una variable de búfer con tipo compatible en la red de envío GVL correspondiente. El nombre de la variable del buffer comienza con el prefijo. AC_RemoteIo_Buffer_ y se construirá a partir de la ruta de la instancia y la ruta variable de la salida. Las variables del búfer se inicializarán con la expresión de inicialización de la variable de salida, si existe. Si el valor de esta expresión de inicialización no está contenido en la información de precompilación (porque la expresión usa ejemplos: variables, funciones y constantes), se crea un error. El generador maneja la asignación de salida como una asignación a esta variable de búfer. La asignación de entrada en la otra aplicación se maneja como una asignación de la variable correspondiente en el NVL del receptor (ver [expresión ST]). Nota: La sincronización entre la tarea en la que se actualizará la variable de red y la tarea de E\/S del módulo aún no se ha realizado. Por lo tanto, es posible que los valores se hayan escrito de forma incompleta mientras la tarea de E\/S los lee. " }, 
{ "title" : "Comando: Configuración del generador ", 
"url" : "ac_generator_configuration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Configuración del generador ", 
"snippet" : "Configuración del generador Este comando (categoría \"Compositor\") abre un cuadro de diálogo con todos los generadores disponibles. En este cuadro de diálogo, cada generador se puede habilitar o deshabilitar. Un clic en el icono \"Herramientas\" abre un cuadro de diálogo detallado con configuraciones e...", 
"body" : "Configuración del generador Este comando (categoría \"Compositor\") abre un cuadro de diálogo con todos los generadores disponibles. En este cuadro de diálogo, cada generador se puede habilitar o deshabilitar. Un clic en el icono \"Herramientas\" abre un cuadro de diálogo detallado con configuraciones específicas en el generador actualmente seleccionado y habilitado. " }, 
{ "title" : "Generador de dispositivos ", 
"url" : "ac_generator_configuration.html#UUID-808f4cf5-ae70-df89-d868-14922e672101", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Configuración del generador \/ Generador de dispositivos ", 
"snippet" : "Este generador intenta generar los dispositivos necesarios y, si es posible, los conecta a los módulos IO. En la versión actual del complemento Application Composer, no hay ningún cuadro de diálogo de configuración disponible para el generador de dispositivos....", 
"body" : "Este generador intenta generar los dispositivos necesarios y, si es posible, los conecta a los módulos IO. En la versión actual del complemento Application Composer, no hay ningún cuadro de diálogo de configuración disponible para el generador de dispositivos. " }, 
{ "title" : "Generador de plantillas de origen ", 
"url" : "ac_generator_configuration.html#UUID-dcd74dd8-c2bf-daf3-03d2-c4b54ecf55a8", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Configuración del generador \/ Generador de plantillas de origen ", 
"snippet" : "Este generador copia bloques de funciones existentes del POU pool a la aplicación. Los bloques de funciones copiados se agregan en el AC_SourceTemplate carpeta. En esta carpeta la función adicional AC_SourceTemplateInit también se agrega. Este bloque de funciones se utiliza para inicializar los bloq...", 
"body" : "Este generador copia bloques de funciones existentes del POU pool a la aplicación. Los bloques de funciones copiados se agregan en el AC_SourceTemplate carpeta. En esta carpeta la función adicional AC_SourceTemplateInit también se agrega. Este bloque de funciones se utiliza para inicializar los bloques de funciones copiados. Los bloques de funciones creados se pueden editar y no se sobrescriben con una nueva ejecución del generador. Los bloques de funciones no utilizados se renombran y se mueven a la UnusedSourceTemplate subcarpeta. Entonces la extensión _unused está agregado. Requisito: El generador estándar debe estar activado. " }, 
{ "title" : "Generador estándar ", 
"url" : "ac_generator_configuration.html#UUID-a3c9c7e9-e567-6ffc-3f6c-ae4016d57a70", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Configuración del generador \/ Generador estándar ", 
"snippet" : "Configuraciones de tareas predeterminadas tarea de alta prioridad Definición de Prioridad e Intervalo de las tareas definidas por el usuario Las tareas definidas por el usuario se pueden configurar en el editor de los módulos de nivel superior (ver Implementación). Tarea de prioridad media Tarea de ...", 
"body" : "Configuraciones de tareas predeterminadas tarea de alta prioridad Definición de Prioridad e Intervalo de las tareas definidas por el usuario Las tareas definidas por el usuario se pueden configurar en el editor de los módulos de nivel superior (ver Implementación). Tarea de prioridad media Tarea de baja prioridad Configuración de comunicación Habilitar comunicación RMP : Se crearán los elementos necesarios para la comunicación RMP. Prioridad de tareas Prioridad de la tarea RMP Intervalo de tareas Intervalo de tareas de la tarea RMP Pragmas del compilador GVL Definición de pragmas compiladores Estos pragmas se insertarán antes de los GVL o bloques de función generados. Bloques de funciones Configuración de símbolos Crear configuración de símbolo : El objeto de configuración del símbolo se agregará a la aplicación. " }, 
{ "title" : "generador de persistencia ", 
"url" : "ac_generator_configuration.html#UUID-e4484f57-2155-dad9-990f-264462e75e1e", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Configuración del generador \/ generador de persistencia ", 
"snippet" : "El generador de persistencia lee la configuración de persistencia del árbol de módulos y crea un objeto de configuración de persistencia debajo de cada aplicación que usa persistencia. Para obtener más información, consulte también: Gerente de persistenciaUna aplicación utiliza la función de persist...", 
"body" : "El generador de persistencia lee la configuración de persistencia del árbol de módulos y crea un objeto de configuración de persistencia debajo de cada aplicación que usa persistencia. Para obtener más información, consulte también: Gerente de persistenciaUna aplicación utiliza la función de persistencia del compositor de aplicaciones si una instancia del Administrador de persistencia está asignada a esa aplicación. " }, 
{ "title" : "Generador de registro de datos ", 
"url" : "ac_generator_configuration.html#UUID-0a4d1c9e-c363-489e-e742-4b6d5c1afaa4", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Configuración del generador \/ Generador de registro de datos ", 
"snippet" : "El generador de DataLog crea un objeto de configuración de DataLog a partir de la configuración del árbol de módulos. Este objeto se agregará a la aplicación a la que pertenece la instancia del Administrador de registro de datos está mapeado. En la versión actual del CODESYS Application Composer , n...", 
"body" : "El generador de DataLog crea un objeto de configuración de DataLog a partir de la configuración del árbol de módulos. Este objeto se agregará a la aplicación a la que pertenece la instancia del Administrador de registro de datos está mapeado. En la versión actual del CODESYS Application Composer , no hay diálogo de configuración disponible para el generador de DataLog. " }, 
{ "title" : "Generador de tendencias ", 
"url" : "ac_generator_configuration.html#UUID-b0155d06-1fc0-2914-55ee-2233ae0d22ee", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Configuración del generador \/ Generador de tendencias ", 
"snippet" : "El generador de tendencias lee las definiciones de tendencias de las descripciones de los módulos y crea una configuración de tendencias con visualizaciones asociadas. Estas visualizaciones se incrustarán en las visualizaciones existentes....", 
"body" : "El generador de tendencias lee las definiciones de tendencias de las descripciones de los módulos y crea una configuración de tendencias con visualizaciones asociadas. Estas visualizaciones se incrustarán en las visualizaciones existentes. " }, 
{ "title" : "Generador de alarmas ", 
"url" : "ac_generator_configuration.html#UUID-62c4fd14-9eaa-46b5-f370-4e36a88614fe", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Configuración del generador \/ Generador de alarmas ", 
"snippet" : "El generador de alarmas lee las definiciones de alarma de las descripciones de los módulos y crea o amplía los componentes asociados de la gestión de alarmas. Además, se crea una visualización a partir de una plantilla. En esta visualización se inserta una tabla de alarmas. La visualización se agreg...", 
"body" : "El generador de alarmas lee las definiciones de alarma de las descripciones de los módulos y crea o amplía los componentes asociados de la gestión de alarmas. Además, se crea una visualización a partir de una plantilla. En esta visualización se inserta una tabla de alarmas. La visualización se agregará a las otras plantillas de visualización del generador de visualización como visualización de alto nivel . Plantilla Plantilla para la pantalla de visualización. Nota: Para utilizar una visualización como plantilla debe cumplir las siguientes condiciones: Un rectángulo con el nombre Placeholder_AlarmTable las variables bAckVisible , bAckSel , bHistory , y bFreezeScrlPos de tipo BOOL Plantilla de almacenamiento de alarmas Objetos de tipo AlarmStorageTemplate , que se encuentran en el proyecto actual y en las bibliotecas a las que se hace referencia La plantilla seleccionada se utilizará para todas las configuraciones de alarma generadas. Crear pestaña de nivel superior : Se creará una pestaña de nivel superior para la visualización de alarma creada. El nombre definido se mostrará en la pestaña de nivel superior. " }, 
{ "title" : "Generador de diagnóstico de dispositivos ", 
"url" : "ac_generator_configuration.html#UUID-eacb5fd7-1329-2790-9483-fe45edbe632a", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Configuración del generador \/ Generador de diagnóstico de dispositivos ", 
"snippet" : "Este generador crea pantallas de visualización para el diagnóstico del dispositivo. En los ajustes, el plantillas de visualización y se puede definir el diseño de las pantallas. Configuración del generador de diagnóstico del dispositivo En el cuadro de diálogo, se pueden definir las plantillas para ...", 
"body" : "Este generador crea pantallas de visualización para el diagnóstico del dispositivo. En los ajustes, el plantillas de visualización y se puede definir el diseño de las pantallas. Configuración del generador de diagnóstico del dispositivo En el cuadro de diálogo, se pueden definir las plantillas para visualización base, plantilla de PLC, plantilla de bus, plantilla de pila, plantilla de dispositivo principal y plantilla de dispositivo secundario. Los cuadros combinados enumeran todas las plantillas de visualización disponibles que coinciden con los tipos de plantilla respectivos. En la parte inferior del diálogo, se puede definir el tamaño mínimo de la pantalla de visualización y el espacio entre los elementos de visualización del diagnóstico del dispositivo. " }, 
{ "title" : "Generador de programas CFC ", 
"url" : "ac_generator_configuration.html#UUID-fdaff0f3-814e-b71a-bcac-a2994393c9ed", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Configuración del generador \/ Generador de programas CFC ", 
"snippet" : "El generador CFC se utiliza para crear programas CFC. Regenerar siempre todos los pines CFC : : Application Composer siempre intenta generar todas las E\/S de bloques de función para llamadas de FB de instancia de módulo....", 
"body" : "El generador CFC se utiliza para crear programas CFC. Regenerar siempre todos los pines CFC : : Application Composer siempre intenta generar todas las E\/S de bloques de función para llamadas de FB de instancia de módulo. " }, 
{ "title" : "Generador de visualización ", 
"url" : "ac_generator_configuration.html#UUID-a364420f-f798-9fe6-3c1a-b98bc7c07391", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Configuración del generador \/ Generador de visualización ", 
"snippet" : "Este generador crea pantallas de visualización para el CODESYS Application Composer de las visualizaciones que están disponibles en el CODESYS proyecto. Nombre de nivel superior : Introduzca un nombre simbólico para la visualización plantilla (\"plantilla de nivel superior\"). Plantilla : La lista de ...", 
"body" : "Este generador crea pantallas de visualización para el CODESYS Application Composer de las visualizaciones que están disponibles en el CODESYS proyecto. Nombre de nivel superior : Introduzca un nombre simbólico para la visualización plantilla (\"plantilla de nivel superior\"). Plantilla : La lista de selección ofrece todas las visualizaciones disponibles (en el proyecto y las bibliotecas cargadas) y compatibles. Si selecciona Por defecto , la plantilla predeterminada de la biblioteca AC_Module se utilizará. Si una plantilla configurada aquí en el cuadro de diálogo se elimina más tarde del proyecto o la biblioteca, permanecerá disponible en este cuadro de diálogo. ObjetivoVisu , WebVisu : Active la opción respectiva, si la plantilla de página se debe utilizar para esta variante de visualización. Ancho: Ancho de la visualización generada en píxeles (valor predeterminado: 640, mínimo 100, máximo 10000) Altura: Altura de la visualización generada en píxeles (valor predeterminado: 480, mínimo 100, máximo 10000) Ancho mínimo de ToplevelTab : ancho mínimo para las pestañas de nivel superior generadas en píxeles. Si se ingresa 0 aquí, la configuración no se tiene en cuenta. Ancho máximo de la pestaña de nivel superior : ancho máximo para las pestañas de nivel superior generadas en píxeles. Si se ingresa 0 aquí, la configuración no se tiene en cuenta. Para obtener más información acerca de las plantillas de nivel superior, consulte: Plantillas de nivel superiorNúmero máximo de clientes: Número máximo de clientes que se ejecutan en paralelo (predeterminado 8, mínimo 1, máximo 128). Ignorar visus generado si SVN está disponible : Si el proyecto está almacenado en Subversion, esta opción debe estar activada. : CODESYS se asegura de que las visualizaciones generadas se ignoren en SVN. De lo contrario, podrían surgir problemas. Recrea visus al regenerar : : con cada generación de código, todas las visualizaciones también se regeneran y las visualizaciones existentes se sobrescriben. Esta opción debe seleccionarse si no se desea que el usuario del módulo realice cambios en las visualizaciones generadas después de la generación. Sin embargo, si los cambios en las visualizaciones aún son necesarios después de la generación, la opción debe desactivarse. Luego CODESYS intenta mantener los cambios posteriores también con las regeneraciones. Use el nombre de instancia como predeterminado para las pestañas de nivel superior : : En lugar de la ruta completa de la instancia, solo se muestra el nombre de la instancia en la pestaña del nivel superior. Si hay un error en la configuración, se muestra con un icono de proveedor de errores y el OK el botón está deshabilitado. " }, 
{ "title" : "Comando: escanear ", 
"url" : "ac_scan.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: escanear ", 
"snippet" : "Escanear Símbolo: Este comando (categoría \"Compositor\") escanea todo el proyecto en busca de declaraciones de módulos. Normalmente este comando no es necesario porque CODESYS escanea el sistema automáticamente cuando es necesario (ejemplo: después de instalar una nueva biblioteca)....", 
"body" : "Escanear Símbolo: Este comando (categoría \"Compositor\") escanea todo el proyecto en busca de declaraciones de módulos. Normalmente este comando no es necesario porque CODESYS escanea el sistema automáticamente cuando es necesario (ejemplo: después de instalar una nueva biblioteca). " }, 
{ "title" : "Comando: comprobar y buscar todos los objetos del grupo ", 
"url" : "_ac_cmd_check_and_scan_all_pool_objects.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: comprobar y buscar todos los objetos del grupo ", 
"snippet" : "Verifique y busque todos los objetos del grupo función : Cuando se llama al comando, primero se verifica el código IEC de una biblioteca y luego se buscan declaraciones de módulo. La ejecución de prueba corresponde al comando. LVerificar todos los objetos de la piscina . La búsqueda corresponde al c...", 
"body" : "Verifique y busque todos los objetos del grupo función : Cuando se llama al comando, primero se verifica el código IEC de una biblioteca y luego se buscan declaraciones de módulo. La ejecución de prueba corresponde al comando. LVerificar todos los objetos de la piscina . La búsqueda corresponde al comando. Escanear. llamar : Menú Compositor Requisito : El comando solo es visible cuando hay un proyecto de biblioteca abierto. " }, 
{ "title" : "Comando: Asignar E\/S ", 
"url" : "ac_map_channels_for_ioconfig.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Asignar E\/S ", 
"snippet" : "Asignar E\/S Símbolo: Este comando (categoría \"Compositor\") abre un cuadro de diálogo para definir la asignación entre módulos y E\/S configuración. Diálogo: Mapeo de E\/S En el lado izquierdo del cuadro de diálogo, todas las entradas y salidas de los módulos se muestran en una estructura de árbol segú...", 
"body" : "Asignar E\/S Símbolo: Este comando (categoría \"Compositor\") abre un cuadro de diálogo para definir la asignación entre módulos y E\/S configuración. Diálogo: Mapeo de E\/S En el lado izquierdo del cuadro de diálogo, todas las entradas y salidas de los módulos se muestran en una estructura de árbol según la árbol de módulos . En el lado derecho se encuentra la estructura del árbol de dispositivos. Las conexiones de los módulos de nivel superior a las aplicaciones se dibujan de acuerdo con la configuración de los módulos de nivel superior. Esta conexión no se puede cambiar en este cuadro de diálogo. Las entradas se muestran con una conexión verde y una flecha verde; las salidas se muestran en rojo. Las entradas o salidas abiertas (sin conexión) se muestran con una línea de puntos. En caso de que una expresión ST esté asignada a la entrada resp. salida, la conexión se mostrará con un \"ST\". Las conexiones entre módulos y dispositivos solo son posibles de entrada a entrada o de salida a salida. Además, ambas conexiones deben tener un tipo de datos compatible. Las conexiones entre módulos sólo son posibles de entrada a salidas y viceversa. No es posible realizar conexiones entre dispositivos. Para crear una conexión se debe seleccionar la entrada o salida abierta. Un pin seleccionado se muestra con un fondo azul. Las entradas y salidas se conectan mediante arrastrar y soltar. Un destino de conexión válido o no válido se indica con diferentes punteros del mouse. Las conexiones existentes se eliminarán si la entrada o salida está ocupada. Si un dispositivo o módulo está colapsado, la conexión se dibujará en negro porque posiblemente no se pueda determinar la dirección de los datos. Si se contrae aún más (por ejemplo, el dispositivo superior), las conexiones también se ocultarán. Esto se hace para mejorar la visión general porque el grosor de la línea se puede reducir en el área central. Si se selecciona una conexión en el lado izquierdo o derecho, el dispositivo correspondiente se expandirá si está colapsado. Las flechas muestran la dirección de los datos. Un dispositivo colapsado muestra flechas verdes y rojas si el dispositivo usa entradas y salidas. Si solo hay entradas o salidas, también se muestra la dirección de los datos. En modo online los valores de los parámetros se muestran en el lado izquierdo. Los valores no se pueden cambiar en esta vista. Con un doble clic en un módulo o dispositivo se abre el objeto correspondiente en el editor. ¡Las conexiones también se pueden establecer a través de los límites de la aplicación! Si una instancia de módulo está asignada al grupo de POU, las líneas de conexión aparecen atenuadas. En esta situación, no se pueden crear asignaciones de IO, pero se pueden eliminar las asignaciones existentes. Imprimir : Este comando permite imprimir las asignaciones de E\/S, que están configuradas, en un estilo de descripción general. " }, 
{ "title" : "Comando: Selección comodín ", 
"url" : "ac_wildcard_selection.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Selección comodín ", 
"snippet" : "Asignación de comodines Este comando (categoría \"Compositor\") abre el cuadro de diálogo Asignación de comodines . La parte superior del cuadro de diálogo muestra los comodines configurados actualmente y los tipos de dispositivos asignados. En la parte inferior del cuadro de diálogo se representa el ...", 
"body" : "Asignación de comodines Este comando (categoría \"Compositor\") abre el cuadro de diálogo Asignación de comodines . La parte superior del cuadro de diálogo muestra los comodines configurados actualmente y los tipos de dispositivos asignados. En la parte inferior del cuadro de diálogo se representa el Repositorio de dispositivos, que ofrece dispositivos instalados para su selección. Puede editar las asignaciones dentro del cuadro de diálogo. Para ello, el cuadro de diálogo también aparece durante la generación del dispositivo, cuando los comodines no se pueden asignar automáticamente a los tipos de dispositivos y se necesita una asignación manual. La asignación de los comodines a los tipos de dispositivos se guarda dentro del proyecto. Sin embargo, también puedes usar un archivo XML para guardar las tareas externamente y volver a cargarlas desde allí. El archivo y la ruta de este archivo se muestran en la parte superior del cuadro de diálogo. Diálogo: Asignación de comodines Nuevo : Este comando permite crear un nuevo archivo XML de asignación de comodines (vacío). Defina el nombre del archivo y el directorio de almacenamiento. Ahorrar : este comando guarda explícitamente la asignación del dispositivo comodín actualmente definida en un archivo elegido manualmente. Aparte de esto, las asignaciones se guardarán automáticamente en el archivo especificado actualmente, al cerrar el cuadro de diálogo usando el botón DE ACUERDO botón. Carga : Este comando permite cargar un archivo de asignación de comodines (XML) existente. En la vista de árbol resaltada, el ID del dispositivo (nombre del módulo) La columna muestra los ID de los dispositivos del generador de dispositivos que utilizan comodines. El nombre de la instancia del módulo que trae este dispositivo se muestra entre paréntesis. En el caso de un dispositivo generador de dispositivo insertado estáticamente (definido por la declaración del módulo Identification y no Wildcard \/ FlexibleWildcard ) un nodo estándar Estático Se crea un archivo que contiene todos los dispositivos insertados estáticamente. Los dispositivos estáticos no se pueden modificar. El Relaciones Las columnas muestran la relación entre los dispositivos principales y secundarios del generador de dispositivos. Una línea en negrita indica una relación fija, mientras que una línea discontinua sirve como sugerencia de relación. La sugerencia se basa en la definición de ParentID en el Device sección. Los comodines también se pueden marcar como vacíos simplemente seleccionándolos y presionando el botón Del llave. Por ejemplo, un comodín vacío podría servir para alterar las relaciones propuestas entre padres e hijos. Los comodines asignados se muestran con un color de fondo verde; comodín no asignado con un color de fondo rojo. Solo muestra compatibilidades con la primera generación de posibles dispositivos principales. : Si esta opción está activada, la variedad de dispositivos de la vista del repositorio de dispositivos se restringe aún más a aquellos dispositivos que son hijos compatibles solo del primer dispositivo principal. Esto está definido por el configuración del módulo . Si no está activado, también los dispositivos padres de 2.ª, 3.ª,..., enésima generación se tratan como posibles padres, ampliando la variedad de dispositivos mostrados en la vista del repositorio de dispositivos. Reglas para la asignación de propiedad. Si se selecciona un dispositivo, un canal IO o una instancia de FB en el lado izquierdo, todas las propiedades de este dispositivo, canal IO o instancia de FB que ya estén asignadas se marcarán con una casilla marcada en el lado derecho. Los dispositivos en el lado izquierdo sin propiedades asignadas para sus canales IO o instancias de FB se mostrarán con un fondo rojo, el canal IO o instancia de FB en cuestión se mostrarán con un fondo rojo, respectivamente. Los dispositivos a los que están asignados todos los canales de E\/S y las instancias de FB se resaltan en verde, al igual que los canales de E\/S y las instancias de FB conocidos. La cesión también incluye no ceder una propiedad \"exigente\". Esto último se puede lograr para un dispositivo completo haciendo doble clic en un nodo de dispositivo para todo el dispositivo con todos sus canales de E\/S e instancias de FB. Las propiedades de la derecha se pueden agregar a las propiedades de \"oferta\" del dispositivo, canal de E\/S o instancia de FB seleccionada a la izquierda marcando la casilla. Se puede asignar cualquier cantidad de propiedades o ninguna a un dispositivo, canal de E\/S o instancia de FB. Si a un nodo de dispositivo se le asigna una propiedad de E\/S \"exigente\", esta propiedad se asigna a todos los nodos de canal de E\/S secundarios de este nodo de dispositivo, pero no a las instancias de FB. De manera similar, si a un dispositivo se le asigna una propiedad InstRef \"exigente\", entonces solo se asigna esa propiedad a las instancias de FB secundarias de ese dispositivo. Se pueden seleccionar al mismo tiempo varios dispositivos, canales de E\/S o instancias de FB, a cada uno de los cuales se les asignan, según sea posible, las propiedades seleccionadas. Las propiedades \"exigentes\" en el lado derecho, que al menos un dispositivo ofrece en el lado izquierdo, se mostrarán con un fondo verde. Las propiedades \"demandantes\" que no coincidan con las propiedades de oferta en el lado izquierdo se mostrarán con un fondo rojo. " }, 
{ "title" : "Asignar comodines ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_342a92346a13602cc0a8640e00a6970a", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Selección comodín \/ Asignar comodines ", 
"snippet" : "Hay dos formas de asignar un comodín: En la parte superior del cuadro de diálogo, en la línea del comodín que se asignará, haga clic en el campo de la columna Dispositivos seleccionados . Luego, en el árbol Repositorio de dispositivos en la parte inferior del cuadro de diálogo, haga doble clic en el...", 
"body" : "Hay dos formas de asignar un comodín: En la parte superior del cuadro de diálogo, en la línea del comodín que se asignará, haga clic en el campo de la columna Dispositivos seleccionados . Luego, en el árbol Repositorio de dispositivos en la parte inferior del cuadro de diálogo, haga doble clic en el dispositivo deseado. En el árbol Repositorio de dispositivos en la parte inferior del cuadro de diálogo, seleccione el dispositivo deseado. Luego, en la parte superior del cuadro de diálogo, en la línea del comodín a asignar, haga doble clic en el campo de la columna Dispositivos seleccionados . " }, 
{ "title" : "Asignación de propiedades del dispositivo ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_4703909473b5f037c0a8640e01022fbe", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Selección comodín \/ Asignación de propiedades del dispositivo ", 
"snippet" : "El comando Asignación de propiedades del dispositivo abre el cuadro de diálogo correspondiente, que sirve para asignar ofrecimiento propiedades a los dispositivos. Diálogo: Asignación de propiedades del dispositivo En el lado izquierdo del cuadro de diálogo se enumeran todos los dispositivos generad...", 
"body" : "El comando Asignación de propiedades del dispositivo abre el cuadro de diálogo correspondiente, que sirve para asignar ofrecimiento propiedades a los dispositivos. Diálogo: Asignación de propiedades del dispositivo En el lado izquierdo del cuadro de diálogo se enumeran todos los dispositivos generados utilizados en el proyecto. Los nodos secundarios de estos dispositivos muestran todas las entradas, salidas (no en negrita) y bloques de funciones creados (en negrita) del tipo de dispositivo correspondiente. La pantalla del lado derecho enumera todas las propiedades \"exigentes\", que se definen en las declaraciones de módulo de los módulos utilizados como demandante IO. Los nodos secundarios de estos \"exigencias\" corresponden a todos los módulos IO que requieren exigencias de sus nodos principales. El cuadro de diálogo de asignación de propiedades se utiliza para asignar las propiedades del lado derecho a los dispositivos y sus canales IO. Estas asignaciones se guardarán en un archivo adicional junto a la descripción del dispositivo de los dispositivos, que hace referencia al archivo adicional. El cuadro de diálogo se abre automáticamente durante la generación del código, si no se cumplen todas las propiedades \"exigentes\" del módulo IO con al menos una asignación a un dispositivo que ofrezca estas propiedades. " }, 
{ "title" : "Comando: Eliminar asignaciones de E\/S ", 
"url" : "ac_remove_connections_to_ios.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Eliminar asignaciones de E\/S ", 
"snippet" : "Eliminar asignaciones de E\/S Este comando (categoría \"Compositor\") elimina las asignaciones de E\/S. Se proporcionan los siguientes subcomandos. Todo generado : Elimina las asignaciones generadas automáticamente. Las asignaciones agregadas manualmente permanecen. Todo : Elimina todas las asignaciones...", 
"body" : "Eliminar asignaciones de E\/S Este comando (categoría \"Compositor\") elimina las asignaciones de E\/S. Se proporcionan los siguientes subcomandos. Todo generado : Elimina las asignaciones generadas automáticamente. Las asignaciones agregadas manualmente permanecen. Todo : Elimina todas las asignaciones: asignaciones generadas automáticamente y asignaciones agregadas manualmente. Todo generado de la instancia del módulo. : Si se selecciona una instancia de módulo en el árbol de módulos, se puede ejecutar este comando. El comando elimina las asignaciones generadas automáticamente de esta instancia. Las asignaciones agregadas manualmente permanecen. Toda la instancia del módulo : Si se selecciona una instancia de módulo en el árbol de módulos, se puede ejecutar este comando. El comando elimina todas las asignaciones de esta instancia: asignaciones generadas automáticamente y asignaciones agregadas manualmente. " }, 
{ "title" : "Comando: Agregar instancia de módulo de nivel superior ", 
"url" : "ac_add_toplevel_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Agregar instancia de módulo de nivel superior ", 
"snippet" : "Agregar instancia de módulo de nivel superior Este comando (categoría \"Compositor\") abre la Diálogo del módulo que ofrece todos los módulos de nivel superior que se pueden agregar al árbol de módulos. No hay limitación en la cantidad de módulos de nivel superior que se pueden agregar a una aplicació...", 
"body" : "Agregar instancia de módulo de nivel superior Este comando (categoría \"Compositor\") abre la Diálogo del módulo que ofrece todos los módulos de nivel superior que se pueden agregar al árbol de módulos. No hay limitación en la cantidad de módulos de nivel superior que se pueden agregar a una aplicación. " }, 
{ "title" : "Comando: Agregar instancia de submódulo ", 
"url" : "ac_add_submodule_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Agregar instancia de submódulo ", 
"snippet" : "Agregar instancia de submódulo Este comando (categoría \"Compositor\") abre la Diálogo del módulo que ofrece todos los submódulos que se pueden agregar a la posición seleccionada en el árbol de módulos. Los submódulos que ofrecen espacios de referencia obligatorios permiten llenar automáticamente todo...", 
"body" : "Agregar instancia de submódulo Este comando (categoría \"Compositor\") abre la Diálogo del módulo que ofrece todos los submódulos que se pueden agregar a la posición seleccionada en el árbol de módulos. Los submódulos que ofrecen espacios de referencia obligatorios permiten llenar automáticamente todos los espacios de referencia inequívocos. En esta situación, un cuadro de diálogo pregunta al usuario si se hará referencia a los módulos automáticamente o no. " }, 
{ "title" : "Comando: Instancia del módulo de referencia ", 
"url" : "ac_reference_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Instancia del módulo de referencia ", 
"snippet" : "Instancia de módulo de referencia Este comando (categoría \"Compositor\") abre la Diálogo del módulo que ofrece todos los módulos a los que se puede hacer referencia en la posición seleccionada en el árbol de módulos....", 
"body" : "Instancia de módulo de referencia Este comando (categoría \"Compositor\") abre la Diálogo del módulo que ofrece todos los módulos a los que se puede hacer referencia en la posición seleccionada en el árbol de módulos. " }, 
{ "title" : "Comando: Mostrar vista de referencias de módulo ", 
"url" : "ac_module_references_editor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Mostrar vista de referencias de módulo ", 
"snippet" : "Mostrar vista de referencias del módulo Este comando (categoría \"Compositor\") abre la Referencia del módulo vista y proporciona una descripción general del uso de instancias de módulo en el proyecto. El comando está disponible en el menú contextual si se selecciona una instancia de módulo en el árbo...", 
"body" : "Mostrar vista de referencias del módulo Este comando (categoría \"Compositor\") abre la Referencia del módulo vista y proporciona una descripción general del uso de instancias de módulo en el proyecto. El comando está disponible en el menú contextual si se selecciona una instancia de módulo en el árbol de módulos. La vista se actualiza automáticamente si se selecciona otra instancia de módulo o si cambian las referencias de la instancia actualmente seleccionada. " }, 
{ "title" : "Ver: Referencias de módulos ", 
"url" : "ac_module_references_editor.html#UUID-7a9e7bcf-5b4a-4286-24df-e6cd7795a03a_c2a0935773056bc0a86463423a2ab0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Mostrar vista de referencias de módulo \/ Ver: Referencias de módulos ", 
"snippet" : "Aplicación\/fuente de referencia Las referencias están ordenadas por aplicación. Papel de la referencia en su objetivo Papel de la referencia en su objetivo...", 
"body" : "Aplicación\/fuente de referencia Las referencias están ordenadas por aplicación. Papel de la referencia en su objetivo Papel de la referencia en su objetivo " }, 
{ "title" : "Comando: Actualizar módulo ", 
"url" : "ac_update_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Actualizar módulo ", 
"snippet" : "Módulo de actualización Este comando (categoría \"Compositor\") abre la Diálogo del módulo . El árbol de módulos proporciona todos los módulos que son compatibles con la instancia de módulo seleccionada en el árbol de módulos. El comando permite actualizar una instancia de módulo a un nuevo tipo de mó...", 
"body" : "Módulo de actualización Este comando (categoría \"Compositor\") abre la Diálogo del módulo . El árbol de módulos proporciona todos los módulos que son compatibles con la instancia de módulo seleccionada en el árbol de módulos. El comando permite actualizar una instancia de módulo a un nuevo tipo de módulo. También puede ser una nueva versión del mismo módulo. Al actualizar, se mantendrán en la medida de lo posible los datos configurados de la instancia: Los valores de los parámetros que existen en las nuevas versiones se adoptarán incluso si el valor actual es incompatible con el nuevo tipo de parámetro. Si el valor de un parámetro no se establece explícitamente en la instancia, se utiliza el valor predeterminado del nuevo módulo. Se adoptarán las asignaciones de E\/S que existen en la nueva versión y que tienen la misma dirección (entrada o salida) que la asignación en la instancia. La asignación no tiene que ser del mismo tipo que la nueva E\/S que se va a adoptar. Se adoptarán las asignaciones de tareas que existen en ambas versiones. Las subinstancias o referencias de ranuras que tienen el mismo ID de ranura en el nuevo módulo se mantendrán con todas las subinstancias y referencias. Esto se aplica incluso si el tipo de subinstancias o referencias no coincide con la nueva ranura, o si la cardinalidad de la nueva ranura no permite todas las subinstancias o referencias. Las subinstancias o referencias de slots que no existen en el nuevo módulo se insertan debajo de un nuevo slot denominado \"Instancias huérfanas\" o \"Referencias huérfanas\". Estas ranuras se identifican mediante identificadores especiales que no pueden aparecer en las ranuras normales. Si ya existe un espacio con elementos huérfanos, se utilizará este espacio. Las subinstancias o referencias de slots que existen en el nuevo módulo pero que ahora esperan referencias (en el caso de subinstancias) o subinstancias (en el caso de referencias) se manejarán como subinstancias resp. hace referencia a qué ranura no está disponible en el nuevo módulo. La información de nivel superior que existe en la instancia se eliminará si hay una actualización de un módulo que no es de nivel superior. Si no existe información de nivel superior en la instancia, se creará si el módulo se actualiza a un módulo de nivel superior. Datos de instancia definidos por extensiones: Las respectivas extensiones determinan qué datos se conservarán y cuáles se eliminarán. Debe respetar el principio de obtener la mayor cantidad de datos posible. Si el orden de las ranuras en el nuevo módulo ha cambiado, el orden de las ranuras debajo de la instancia también se ajustará en consecuencia. Si la actualización eliminaría datos (por ejemplo, valores de parámetros, asignaciones de E\/S, ranuras no vacías o datos de instancia extendida), se mostrará un mensaje que describirá qué objetos se eliminarán y permitirá al usuario cancelar la actualización. La actualización de una instancia se puede deshacer con un solo paso de deshacer en el árbol del módulo. " }, 
{ "title" : "Comando: actualizar todas las instancias ", 
"url" : "ac_update_all_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: actualizar todas las instancias ", 
"snippet" : "Actualizar todas las instancias Este comando (categoría \"Compositor\") permite actualizar todas las instancias de módulos a nuevas versiones de los módulos con un solo comando. Este comando no está disponible en el menú contextual. El comportamiento del comando es de acuerdo a la descripción del Módu...", 
"body" : "Actualizar todas las instancias Este comando (categoría \"Compositor\") permite actualizar todas las instancias de módulos a nuevas versiones de los módulos con un solo comando. Este comando no está disponible en el menú contextual. El comportamiento del comando es de acuerdo a la descripción del Módulo de actualización comando, sin embargo, no es posible actualizar a otro módulo. " }, 
{ "title" : "Comando: Ocultar ranuras opcionales vacías: Todas\/Solo seleccionadas ", 
"url" : "ac_hide_empty_optional_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Ocultar ranuras opcionales vacías: Todas\/Solo seleccionadas ", 
"snippet" : "Ocultar ranuras opcionales vacías: Todas\/Solo seleccionadas Con estos comandos (categoría \"Compositor\") puede ocultar las ranuras opcionales vacías en el árbol de módulos. Dependiendo del enfoque actual, esto se refiere a todos los submódulos o solo al submódulo seleccionado actualmente. Los espacio...", 
"body" : "Ocultar ranuras opcionales vacías: Todas\/Solo seleccionadas Con estos comandos (categoría \"Compositor\") puede ocultar las ranuras opcionales vacías en el árbol de módulos. Dependiendo del enfoque actual, esto se refiere a todos los submódulos o solo al submódulo seleccionado actualmente. Los espacios obligatorios no se pueden ocultar. Ejemplo de ranuras opcionales vacías Para mostrar espacios ocultos, utilice el Mostrar espacios ocultos: todos\/solo seleccionados dominio. " }, 
{ "title" : "Comando: Mostrar espacios ocultos: Todos\/Solo seleccionados ", 
"url" : "ac_show_hidden_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Mostrar espacios ocultos: Todos\/Solo seleccionados ", 
"snippet" : "Mostrar ranuras ocultas: Todas\/Solo seleccionadas Con estos comandos (categoría \"Compositor\") en el árbol de módulos puede volver a hacer visibles las ranuras que antes estaban ocultas. Dependiendo del enfoque actual, esto se refiere a todos los submódulos o solo al submódulo seleccionado actualment...", 
"body" : "Mostrar ranuras ocultas: Todas\/Solo seleccionadas Con estos comandos (categoría \"Compositor\") en el árbol de módulos puede volver a hacer visibles las ranuras que antes estaban ocultas. Dependiendo del enfoque actual, esto se refiere a todos los submódulos o solo al submódulo seleccionado actualmente. Para ocultar ranuras, consulte la Ocultar ranuras opcionales vacías: todas\/solo seleccionadas dominio. " }, 
{ "title" : "Comando: Ir al objetivo ", 
"url" : "ac_go_to_target.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Ir al objetivo ", 
"snippet" : "Ir a objetivo Este comando (categoría \"Compositor\") sólo está disponible si se selecciona una referencia de módulo en el árbol de módulos . Si se ejecuta este comando, el destino de la referencia se seleccionará en el árbol del módulo....", 
"body" : "Ir a objetivo Este comando (categoría \"Compositor\") sólo está disponible si se selecciona una referencia de módulo en el árbol de módulos . Si se ejecuta este comando, el destino de la referencia se seleccionará en el árbol del módulo. " }, 
{ "title" : "Comando: Crear módulo de extensión ", 
"url" : "_ac_cmd_create_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Crear módulo de extensión ", 
"snippet" : "Crear módulo de extensión Símbolo: El comando crea un módulo de extensión para una ranura de submódulo. Solo está disponible si se selecciona una ranura de módulo vacía o un submódulo en el árbol de módulos. El comando abre un cuadro de diálogo, donde define si la extensión se creará como un nuevo m...", 
"body" : "Crear módulo de extensión Símbolo: El comando crea un módulo de extensión para una ranura de submódulo. Solo está disponible si se selecciona una ranura de módulo vacía o un submódulo en el árbol de módulos. El comando abre un cuadro de diálogo, donde define si la extensión se creará como un nuevo módulo (\"Sin variación\") o como una variación de un módulo existente o una instancia de módulo. Para ello, todos los módulos adecuados para el slot se ofrecen en una lista desplegable. Hay dos opciones: Derivar variación El módulo de extensión deriva del módulo o instancia de módulo seleccionado en Variación de . El módulo elegido se importa a través de IMPORTS al módulo de extensión y el bloque de funciones del nuevo módulo se deriva del bloque de funciones de la plantilla del módulo. Copiar fuente para Variación Se crea un nuevo módulo de extensión copiando la declaración completa del módulo, incluido el bloque de funciones y las visualizaciones relacionadas del módulo seleccionado en Variación de (incluido el código fuente). Esto es posible sólo si el módulo seleccionado en Variación de está disponible en código fuente y no solo como módulo de una biblioteca compilada. Los módulos de extensión sirven para agregar cualquier modificación o extensión específica del usuario a los módulos o instancias de módulos existentes y predefinidos. Después de cerrar el diálogo con OK se creará una nueva carpeta en el POU pool con el nombre del módulo de extensión. En esta carpeta se crearán los siguientes objetos (donde <nombre> es el nombre del módulo de extensión): Caso estándar: un bloque de función con el nombre <name> , extendiendo la clase \"Módulos\" e implementando la interfaz requerida del tipo de slot. En este bloque de funciones se crearán todos los métodos y propiedades que existen en una interfaz implementada pero que no están implementadas en ninguna clase base. Caso de variación: Al igual que en el caso estándar, se creará un bloque de función correspondiente. Este bloque de funciones se deriva del bloque de funciones de la plantilla del módulo elegido ( Derivar variación ) o es una copia del mismo ( Copiar fuente para Variación ). Un grupo de imágenes y una lista de texto (nombre IP_<name> o TL_<name> ). El grupo de imágenes contiene dos iconos con identificador Icon_16 y Icon_32 . La lista de texto contiene la entrada Desc , que está lleno de un <name> . No hay idiomas en la lista de texto, solo la columna Estándar . Una página de visualización vacía Visu_M_<name> , que implementa la interfaz necesaria. Si Copiar variación de la fuente está seleccionado, las visualizaciones del módulo de origen se copian en su lugar. Se agregará un módulo de extensión al árbol de módulos, que no tiene parámetros ni E\/S. Para los metadatos se utilizarán las imágenes, textos y elementos de visualización creados. La categoría es \"Extensión\". Si se trata de una variación \"derivada\", la declaración de la plantilla del módulo se importa adicionalmente a través de IMPORTS . Si se trata de una variación \"copiada\", la declaración de la plantilla del módulo se copia y adapta de manera que utiliza las listas de texto y los conjuntos de imágenes correspondientes del módulo de extensión. " }, 
{ "title" : "Comando: crear entradas de lista de texto faltantes ", 
"url" : "ac_create_missing_textlist_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: crear entradas de lista de texto faltantes ", 
"snippet" : "Generar entradas de lista de texto faltantes Este comando (categoría \"Compositor\") crea automáticamente todas las listas de texto y entradas de listas de texto a las que hace referencia una declaración de módulo y que no existen. El comando sólo está disponible si un editor de declaración de módulo ...", 
"body" : "Generar entradas de lista de texto faltantes Este comando (categoría \"Compositor\") crea automáticamente todas las listas de texto y entradas de listas de texto a las que hace referencia una declaración de módulo y que no existen. El comando sólo está disponible si un editor de declaración de módulo se abre con el foco puesto en él y el objeto existe en el proyecto principal. La función sólo funciona si no hay ningún error de sintaxis. Las listas de texto se crearán bajo el mismo objeto padre que el objeto en el editor. Con las nuevas entradas creadas solo se completará el texto \"predeterminado\" (con el ID). " }, 
{ "title" : "Comando: generar entradas faltantes en grupos de imágenes ", 
"url" : "ac_create_missing_image_pool_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: generar entradas faltantes en grupos de imágenes ", 
"snippet" : "Generar entradas faltantes en grupos de imágenes El comando genera un grupo de imágenes de entradas que están definidas en una descripción de módulo pero que aún no existen en un grupo de imágenes del proyecto. Si el grupo de imágenes aún no existe, entonces el grupo de imágenes se genera en el POU ...", 
"body" : "Generar entradas faltantes en grupos de imágenes El comando genera un grupo de imágenes de entradas que están definidas en una descripción de módulo pero que aún no existen en un grupo de imágenes del proyecto. Si el grupo de imágenes aún no existe, entonces el grupo de imágenes se genera en el POU ver primero. De forma predeterminada, el comando no está disponible en el Compositor menú. tu usas el Herramientas → Personalizar cuadro de diálogo para agregarlo desde el Compositor categoría de comando a la Compositor menú. El comando es entonces visible en el Compositor menú cuando un módulo está abierto y enfocado en el editor. " }, 
{ "title" : "Comando: subir ", 
"url" : "ac_move_up.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: subir ", 
"snippet" : "Ascender Este comando (categoría \"Compositor\") se puede utilizar para cambiar la posición de los módulos en el árbol de módulos . Este comando solo está disponible para elementos multislot (instancias de módulo y referencias) y si el elemento seleccionado no es el primer elemento del multislot....", 
"body" : "Ascender Este comando (categoría \"Compositor\") se puede utilizar para cambiar la posición de los módulos en el árbol de módulos . Este comando solo está disponible para elementos multislot (instancias de módulo y referencias) y si el elemento seleccionado no es el primer elemento del multislot. " }, 
{ "title" : "Comando: Mover hacia abajo ", 
"url" : "ac_move_down.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Mover hacia abajo ", 
"snippet" : "Mover hacia abajo Este comando (categoría \"Compositor\") se puede utilizar para cambiar la posición de los módulos en el árbol de módulos . Este comando solo está disponible para elementos multislot (instancias de módulo y referencias) y si el elemento seleccionado no es el último elemento del multis...", 
"body" : "Mover hacia abajo Este comando (categoría \"Compositor\") se puede utilizar para cambiar la posición de los módulos en el árbol de módulos . Este comando solo está disponible para elementos multislot (instancias de módulo y referencias) y si el elemento seleccionado no es el último elemento del multislot. " }, 
{ "title" : "Comando: buscar entradas desconocidas ", 
"url" : "ac_check_for_unknown_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: buscar entradas desconocidas ", 
"snippet" : "Comprobar entradas desconocidas Este comando (categoría \"Compositor\") verifica las declaraciones del módulo en busca de definiciones de secciones desconocidas. El subcomando Todo , que siempre está disponible, verifica todas las declaraciones de módulo del proyecto. Si se abre una declaración de mód...", 
"body" : "Comprobar entradas desconocidas Este comando (categoría \"Compositor\") verifica las declaraciones del módulo en busca de definiciones de secciones desconocidas. El subcomando Todo , que siempre está disponible, verifica todas las declaraciones de módulo del proyecto. Si se abre una declaración de módulo en el editor, el subcomando adicional En el editor actual comprueba la declaración del módulo actualmente abierto en busca de definiciones de secciones desconocidas. " }, 
{ "title" : "Comando: generar, compilar e iniciar sesión ", 
"url" : "ac_generate_compile_login.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: generar, compilar e iniciar sesión ", 
"snippet" : "Generar, compilar e iniciar sesión Símbolo: Este comando (categoría \"Compositor\") ejecuta varios comandos con un clic del mouse. Primero se crea y compila el código. Si es posible, la aplicación se inicia sesión en el controlador y se inicia....", 
"body" : "Generar, compilar e iniciar sesión Símbolo: Este comando (categoría \"Compositor\") ejecuta varios comandos con un clic del mouse. Primero se crea y compila el código. Si es posible, la aplicación se inicia sesión en el controlador y se inicia. " }, 
{ "title" : "Comando: Agregar biblioteca de módulos al proyecto ", 
"url" : "ac_add_libraries_to_pou.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Agregar biblioteca de módulos al proyecto ", 
"snippet" : "Agregar biblioteca de módulos al proyecto Símbolo: Este comando (categoría \"Compositor\") abre un cuadro de diálogo con el módulo que contiene bibliotecas. Con el DE ACUERDO Las bibliotecas seleccionadas se agregarán al Administrador de bibliotecas del grupo de POU. Si la biblioteca estándar de Compo...", 
"body" : "Agregar biblioteca de módulos al proyecto Símbolo: Este comando (categoría \"Compositor\") abre un cuadro de diálogo con el módulo que contiene bibliotecas. Con el DE ACUERDO Las bibliotecas seleccionadas se agregarán al Administrador de bibliotecas del grupo de POU. Si la biblioteca estándar de Composer AC_ModlueBase falta, se agrega también automáticamente. Diálogo para agregar bibliotecas de Application Composer El cuadro de diálogo proporciona el botón Abrir administrador de biblioteca POU que permite abrir el Administrador de Biblioteca de la POU piscina también en Composer Dedicated vista. " }, 
{ "title" : "Comando: puntos de interrupción activos para el siguiente paso ", 
"url" : "ac_active_breakpoints_to_next_step.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: puntos de interrupción activos para el siguiente paso ", 
"snippet" : "Puntos de interrupción activos al siguiente paso Este comando (categoría \"Compositor\") sólo está disponible en modo online y si la secuencia se ha detenido en un punto de interrupción. Elimina los puntos de interrupción actualmente activos y agrega uno nuevo a los siguientes pasos....", 
"body" : "Puntos de interrupción activos al siguiente paso Este comando (categoría \"Compositor\") sólo está disponible en modo online y si la secuencia se ha detenido en un punto de interrupción. Elimina los puntos de interrupción actualmente activos y agrega uno nuevo a los siguientes pasos. " }, 
{ "title" : "Comando: Centrar vista en puntos de interrupción ", 
"url" : "ac_center_view_to_breakpoints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Centrar vista en puntos de interrupción ", 
"snippet" : "Vista central de Puntos de interrupción Este comando (categoría \"Compositor\") sólo está disponible en modo online y si la secuencia se ha detenido en un punto de interrupción. Centra la vista del Editor de secuencias en los puntos de interrupción actualmente activos....", 
"body" : "Vista central de Puntos de interrupción Este comando (categoría \"Compositor\") sólo está disponible en modo online y si la secuencia se ha detenido en un punto de interrupción. Centra la vista del Editor de secuencias en los puntos de interrupción actualmente activos. " }, 
{ "title" : "Comando: creación de módulos macro ", 
"url" : "ac_create_macro_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: creación de módulos macro ", 
"snippet" : "Creación de módulos de macros Símbolo: Este comando (en la categoría \"Compositor\") abre un cuadro de diálogo para generar módulos macro. Para utilizar este comando, necesita una licencia válida para crear declaraciones de módulo . El comando está disponible si ha seleccionado un subárbol en el árbol...", 
"body" : "Creación de módulos de macros Símbolo: Este comando (en la categoría \"Compositor\") abre un cuadro de diálogo para generar módulos macro. Para utilizar este comando, necesita una licencia válida para crear declaraciones de módulo . El comando está disponible si ha seleccionado un subárbol en el árbol del módulo. Puede utilizar este comando para generar un módulo macro a partir de los módulos del subárbol. De esta manera se pueden definir qué slots, E\/S y parámetros del submódulo están disponibles en el nuevo módulo macro. Metadatos Nombre Este es el nombre exclusivo del módulo macro. Descripción de macros La descripción se crea como listas de texto. Categoría macro La categoría se utiliza para subdividir los módulos en el cuadro de diálogo de inserción de módulos. Ranuras \/ IO \/ Parámetros Subárbol del módulo macro Vista de árbol de todos los objetos del subárbol. La estructura también muestra todas las ranuras, E\/S y parámetros de la instancia del submódulo respectivo como elementos secundarios (fuente en negrita). Ranuras para módulos macro Esto muestra todas las ranuras, E\/S y parámetros que el tipo de módulo macro debe incluir. Estos elementos provienen directamente de la vista de árbol de la izquierda. E\/S del módulo macro Parámetros del macromódulo Añadir a macro Esto está activo si selecciona una ranura, E\/S o parámetro en la vista de árbol de la izquierda. Los elementos se agregan al módulo de macros haciendo clic en este botón. Quitar de la macro Esto está activo si selecciona ranuras, E\/S o parámetros en la vista de árbol de la derecha. Los elementos del módulo de macros se eliminan haciendo clic en este botón. Cuando cierra el cuadro de diálogo haciendo clic DE ACUERDO , CODESYS Application Composer genera una declaración de módulo, una lista de texto y un grupo de imágenes para este módulo macro. Los objetos se almacenan en una carpeta con el nombre de la macro. Ahora puedes editar los objetos generados sin restricciones e independientemente de la generación. De esta manera, por ejemplo, puede intercambiar el icono de macro en el grupo de imágenes. " }, 
{ "title" : "Comando: firmar todos los módulos ", 
"url" : "ac_sign_all_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: firmar todos los módulos ", 
"snippet" : "Firmar todos los módulos Este comando (categoría \"Compositor\") permite el signo (renovado) de todos los módulos del pool de POU. Este comando se puede utilizar para volver a firmar todos los módulos en el POU piscina. Los módulos desarrollados con una licencia válida se firman automáticamente. Este ...", 
"body" : "Firmar todos los módulos Este comando (categoría \"Compositor\") permite el signo (renovado) de todos los módulos del pool de POU. Este comando se puede utilizar para volver a firmar todos los módulos en el POU piscina. Los módulos desarrollados con una licencia válida se firman automáticamente. Este comando está destinado a asumir módulos existentes sin firmar de versiones anteriores de Application Composer. " }, 
{ "title" : "Comando: Ir al módulo FB ", 
"url" : "ac_goto_modul_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Ir al módulo FB ", 
"snippet" : "Ir al Módulo FB El comando (categoría \"Compositor\") se puede utilizar para abrir el bloque de funciones del módulo o sus métodos en el editor. Debe seleccionar un módulo en el árbol de módulos para que este comando esté disponible. En el modo fuera de línea, la declaración del tipo de bloque de func...", 
"body" : "Ir al Módulo FB El comando (categoría \"Compositor\") se puede utilizar para abrir el bloque de funciones del módulo o sus métodos en el editor. Debe seleccionar un módulo en el árbol de módulos para que este comando esté disponible. En el modo fuera de línea, la declaración del tipo de bloque de funciones o del método del bloque de funciones se abrirá en el editor. En el modo en línea, la instancia del bloque de funciones o el método de la instancia del módulo se abrirá en el editor. " }, 
{ "title" : "Comando: valores de parámetros diferentes ", 
"url" : "ac_differing_parameter_values.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: valores de parámetros diferentes ", 
"snippet" : "Valores de parámetros diferentes Utilice este comando en modo en línea para verificar si algún valor de parámetro de las instancias de módulo utilizadas en el árbol de módulos se ha modificado en el bloque de funciones del módulo. En este caso obtendrá una lista de los modificados. parámetros y de l...", 
"body" : "Valores de parámetros diferentes Utilice este comando en modo en línea para verificar si algún valor de parámetro de las instancias de módulo utilizadas en el árbol de módulos se ha modificado en el bloque de funciones del módulo. En este caso obtendrá una lista de los modificados. parámetros y de las instancias del módulo en cuestión en el Mensajes vista. Un doble clic en un mensaje abrirá el editor de parámetros para la instancia del módulo en cuestión. Allí, todos los parámetros con valores diferentes en el modo en línea y en el modo fuera de línea de la aplicación se indicarán mediante celdas enmarcadas en rojo en las columnas. Valor y Valor en línea . " }, 
{ "title" : "Comando: restablecer el texto de las pestañas de nivel superior ", 
"url" : "ac_reset_text_of_toplevel_tabs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: restablecer el texto de las pestañas de nivel superior ", 
"snippet" : "Restablecer el texto de las pestañas de nivel superior Función : Este comando restablece los textos a la configuración predeterminada para el pestañas de nivel superior que fueron definidos en los editores de módulos en el HMI pestaña. Haciendo clic Compositor → Restablecer texto de pestañas de nive...", 
"body" : "Restablecer el texto de las pestañas de nivel superior Función : Este comando restablece los textos a la configuración predeterminada para el pestañas de nivel superior que fueron definidos en los editores de módulos en el HMI pestaña. Haciendo clic Compositor → Restablecer texto de pestañas de nivel superior → Todo restablece los textos de todas las pestañas de nivel superior. Haciendo clic Compositor → Restablecer texto de pestañas de nivel superior → Solo seleccionado restablece sólo el texto del módulo seleccionado (en el Módulos vista). Hacer clic Compositor → Crear para actualizar la aplicación. Llamar : Compositor menú Requisito : Los módulos con texto configurado especial para las pestañas de nivel superior están presentes en el Módulos vista. Ejemplo de un módulo Los siguientes pasos describen cómo configurar y restablecer el texto de una pestaña de nivel superior. Tu proyecto incluye el Building módulo. Haga doble clic en el Building módulo en el Módulos vista. Se abre el editor de módulos (configurador de módulos). Activa la opción Crear pestaña de nivel superior . Luego aparece un campo de entrada con el texto de nivel superior preestablecido Building . Especificar el texto City hall . Hacer clic Compositor → Crear . Las visualizaciones del módulo y el Toplevel visualización se crean y almacenan en el Dispositivos vista. Haga doble clic en el Toplevel visualización en el Dispositivos vista. → Guarde el proyecto. Haga doble clic en el Building módulo en el Módulos vista. Los comandos de la Compositor menú están disponibles. Selecciona el Building módulo. Hacer clic Compositor → Restablecer texto de pestañas de nivel superior → Solo seleccionados . El texto se restablece a la configuración predeterminada. Building en el editor de módulos en el campo de entrada al lado del Crear pestaña de nivel superior opción. Hacer clic Compositor → Crear . Las visualizaciones del módulo y el Toplevel visualización se actualizan y almacenan en el Dispositivos vista. Abre el Toplevel visualización en el Dispositivos vista. → Ejemplo de un submódulo Los siguientes pasos describen cómo configurar y restablecer el texto de las pestañas de nivel superior dentro de una estructura de módulo de módulos y submódulos. Su proyecto incluye la Building módulo y el Bathroom submódulo. Haga doble clic en el Building módulo en el Módulos vista. Se abre el editor de módulos (configurador de módulos). Activa la opción Crear pestaña de nivel superior . Luego aparece un campo de entrada con el texto de nivel superior preestablecido Building . Especificar el texto City hall . Haga doble clic en el Bathroom módulo en el Módulos vista. Se abre el editor de módulos (configurador de módulos). Activa la opción Crear pestaña de nivel superior . Luego aparece un campo de entrada con el texto de nivel superior preestablecido Building.Bathroom . Especificar el texto WC . Hacer clic Compositor → Crear . Las visualizaciones del módulo y el Toplevel visualización se crean y almacenan en el Dispositivos vista. Haga doble clic en el Toplevel visualización en el Dispositivos vista. → Guarde el proyecto. Haga doble clic en el Building módulo en el Módulos vista. Los comandos de la Compositor menú están disponibles. Selecciona el Building módulo. Hacer clic Compositor → Restablecer texto de pestañas de nivel superior → Todo . Hacer clic Compositor → Crear . Las visualizaciones del módulo y el Toplevel visualización se actualizan y almacenan en el Dispositivos vista. Abre el Toplevel visualización en el Dispositivos vista. → " }, 
{ "title" : "Comando: Crear Módulo desde FB ", 
"url" : "ac_create_module_from_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Crear Módulo desde FB ", 
"snippet" : "Crear módulo desde FB Este comando (categoría \"Compositor\") crea una descripción de módulo a partir de un bloque de funciones. Se crean los siguientes objetos: Descripción del módulo con el nombre <NameOfTheFB> Grupo de imágenes con el nombre IP_<NameOfTheFB> Lista de texto con el nombre TL_<NameOfT...", 
"body" : "Crear módulo desde FB Este comando (categoría \"Compositor\") crea una descripción de módulo a partir de un bloque de funciones. Se crean los siguientes objetos: Descripción del módulo con el nombre <NameOfTheFB> Grupo de imágenes con el nombre IP_<NameOfTheFB> Lista de texto con el nombre TL_<NameOfTheFB> Interfaz con el nombre TL_<NameOfTheFB> I<NombreDelFB>. Esta interfaz se extiende AC.IModule . La descripción del módulo se crea de acuerdo con las siguientes reglas: Todas las variables var_input constant se definen como parámetro del módulo. Allí los atributos parameterCategory , parameterMinValue , y parameterMaxValuehere se puede utilizar para establecer categorías y valores mínimos \/ máximos. Todas las variables numéricas var_output se definen como salidas del módulo. Todas las variables numéricas var_input se definen como entradas de módulo, a menos que estén marcadas como parte de una ranura múltiple. Todas las variables var_input de tipo Interface convertirse en ranuras individuales, si están marcadas con el ac_single_slot atributo. Para crear una ranura múltiple, un par de var_input se requiere, que consta de un Pointer to Interface y una variable entera. Ambos deben estar marcados con el 'ac_multi_slot' := '<ID>' atributo, donde el <ID> de los dos debe coincidir. " }, 
{ "title" : "Comando: Crear administrador de persistencia ", 
"url" : "ac_create_persistence_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Crear administrador de persistencia ", 
"snippet" : "Crear administrador de persistencia Este comando (categoría \"Compositor\") inserta un completo Administrador de persistencia con la configuración predeterminada en el árbol de módulos. Debajo del Administrador de Persistencia un módulo Canal de persistencia y debajo un modulo Almacenamiento de datos ...", 
"body" : "Crear administrador de persistencia Este comando (categoría \"Compositor\") inserta un completo Administrador de persistencia con la configuración predeterminada en el árbol de módulos. Debajo del Administrador de Persistencia un módulo Canal de persistencia y debajo un modulo Almacenamiento de datos se inserta. La estructura creada se puede cambiar y ampliar como se desee. Esto se hace en los parámetros del módulo. canal de persistencia y el modulo almacenamiento de datos . En la instancia del módulo de nivel superior del Módulo Administrador de Persistencia al menos la aplicación de destino debe estar configurada. Antes de cargar la aplicación en el controlador, el comando Generar también debe ejecutarse. El comando agrega además todas las bibliotecas requeridas al administrador de bibliotecas y activa los generadores asociados. " }, 
{ "title" : "Comando: Crear administrador de registro de datos ", 
"url" : "ac_create_datalog_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Crear administrador de registro de datos ", 
"snippet" : "Crear administrador de registro de datos Este comando (categoría \"Compositor\") inserta un completo Administrador de registro de datos con la configuración predeterminada en el árbol de módulos. Debajo del DataLog Manager un módulo Canal de registro de datos y debajo un modulo Almacenamiento de regis...", 
"body" : "Crear administrador de registro de datos Este comando (categoría \"Compositor\") inserta un completo Administrador de registro de datos con la configuración predeterminada en el árbol de módulos. Debajo del DataLog Manager un módulo Canal de registro de datos y debajo un modulo Almacenamiento de registro de datos se inserta. La estructura creada se puede cambiar y ampliar como se desee. Esto se hace en los parámetros de la Módulo 'Canal de registro de datos' y el Módulo 'CSV de almacenamiento de registro de datos' . En la instancia del módulo de nivel superior del Módulo administrador de registro de datos al menos la aplicación de destino debe estar configurada. Antes de cargar la aplicación en el controlador, el comando Generar también debe ejecutarse. El comando agrega además todas las bibliotecas requeridas al administrador de bibliotecas y activa los generadores asociados. " }, 
{ "title" : "Comando: Obtener información de licencia ", 
"url" : "ac_cmd_get_license_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Comandos del Compositor de aplicaciones \/ Comando: Obtener información de licencia ", 
"snippet" : "Obtenga información sobre la licencia Con este comando (categoría «Compositor»), CODESYS obtiene el número de instancias de módulo utilizadas en el árbol de módulos. También se consulta el número máximo permitido de instancias de la licencia actual. El resultado se muestra en el Mensajes ver. Para o...", 
"body" : "Obtenga información sobre la licencia Con este comando (categoría «Compositor»), CODESYS obtiene el número de instancias de módulo utilizadas en el árbol de módulos. También se consulta el número máximo permitido de instancias de la licencia actual. El resultado se muestra en el Mensajes ver. Para obtener más información, consulte ???" }, 
{ "title" : "Tutorial ", 
"url" : "f_application_composer_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Tutorial ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Ejemplos de introducción ", 
"url" : "f_application_composer_first_steps.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Tutorial \/ Ejemplos de introducción ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Ejemplo de compositor de aplicaciones ", 
"url" : "ac_example_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Tutorial \/ Ejemplos de introducción \/ Ejemplo de compositor de aplicaciones ", 
"snippet" : "Basado en un pequeño proyecto, este ejemplo describe cómo crear módulos para Application Composer. Algunas URL de este tutorial enlazan con páginas de ayuda que forman parte de Application Composer. Si no tiene instalado este paquete, estos enlaces no funcionarán. El módulo de ejemplo representa una...", 
"body" : "Basado en un pequeño proyecto, este ejemplo describe cómo crear módulos para Application Composer. Algunas URL de este tutorial enlazan con páginas de ayuda que forman parte de Application Composer. Si no tiene instalado este paquete, estos enlaces no funcionarán. El módulo de ejemplo representa una habitación con una luz y un interruptor. El interruptor se puede utilizar como tapper o dimmer. Al presionarlo más tiempo, se atenuará la luz y al presionarlo brevemente, se alternará. El usuario puede definir la velocidad para la función de atenuación, así como el valor máximo de la luz. Cuando se presiona el interruptor por más tiempo que el especificado, se activa la función de atenuación. La salida de la luz es el brillo. Hay una segunda luz, más sencilla, que solo se puede encender y apagar con un segundo interruptor. proyecto de muestra Paso 0: preliminares " }, 
{ "title" : "Paso 0: preliminares ", 
"url" : "ac_example_s0_preliminaries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Tutorial \/ Ejemplos de introducción \/ Paso 0: preliminares ", 
"snippet" : "En primer lugar, se debe crear un nuevo proyecto. Por lo tanto elige Nuevo proyecto desde el Expediente y guarde el nuevo proyecto. Se debe agregar un administrador de biblioteca en el POU vista. Entonces la biblioteca AC_ModuleBase , que forma parte del CODESYS Application Composer paquete, se pued...", 
"body" : "En primer lugar, se debe crear un nuevo proyecto. Por lo tanto elige Nuevo proyecto desde el Expediente y guarde el nuevo proyecto. Se debe agregar un administrador de biblioteca en el POU vista. Entonces la biblioteca AC_ModuleBase , que forma parte del CODESYS Application Composer paquete, se puede agregar al administrador de la biblioteca. Agregar biblioteca \"AC_ModulBase\" Paso 1: crear una \"sala\" de módulo de nivel superior " }, 
{ "title" : "Paso 1: crear una \"Room\" de módulo de nivel superior ", 
"url" : "ac_example_s1_create_toplevel_room.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Tutorial \/ Ejemplos de introducción \/ Paso 1: crear una \"Room\" de módulo de nivel superior ", 
"snippet" : "Agregue una declaración de módulo y un bloque de funciones al POU piscina. El bloque de funciones se utiliza para la implementación (programa de funciones) del módulo. En este ejemplo, el módulo y el bloque de funciones reciben el nombre Room . Además, el bloque de funciones tiene que extender el ti...", 
"body" : "Agregue una declaración de módulo y un bloque de funciones al POU piscina. El bloque de funciones se utiliza para la implementación (programa de funciones) del módulo. En este ejemplo, el módulo y el bloque de funciones reciben el nombre Room . Además, el bloque de funciones tiene que extender el tipo base. AC.Module , que forma parte del AC_ModuleBase biblioteca y proporciona una amplia gama de propiedades y funcionalidades. Como no queremos cambiar esto último, todas las propiedades y funciones que se crean con el bloque de funciones se pueden eliminar. Agregar bloque de funciones y módulo La declaración comienza con la palabra clave MODULE seguido del nombre del módulo y IMPLEMENTED_BY y el nombre del bloque funcional que implementa el módulo, que es, para el caso que nos ocupa, el bloque funcional Room. En este caso específico, este es el Room bloque de funciones En la mayoría de los casos, la sección MetaData se declara ahora. Para obtener información detallada sobre todos los parámetros de todas las secciones, consulte las páginas de ayuda en Declaración del módulo . Porque Habitación es el módulo de nivel superior en nuestro ejemplo, la siguiente sección declarada es el Toplevel sección. Este último permite definir un nombre para la lista de variables globales ( GVL_name ) incluidas las instancias de los bloques de funciones de nivel superior después de la generación. Después de eso, se debe definir al menos una tarea más en la sección de nivel superior. Esto es Standard_Task en este ejemplo, que se define como un MEDIUM tarea y contiene las banderas CREATE_IF_MISSING y UPDATE_IOS . Declaración de módulo Room Todos los iconos y cadenas, que se utilizan para la descripción y los marcadores de posición de iconos del módulo (parámetros Desc , Icon_16 y Icon_32 ) tienen que ser referenciados desde listas de texto y grupos de imágenes. Habiendo dicho esto, una lista de texto apropiada TL y grupo de imágenes IP , que incluyen todos los iconos y textos referenciados, deben ser creados y agregados al POU piscina. Creación de lista de texto y grupo de imágenes. Paso 2: Crear Submódulo \"Switch\" " }, 
{ "title" : "Paso 2: Crear Submódulo \"Switch\" ", 
"url" : "ac_example_s2_create_sublevel_switch.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Tutorial \/ Ejemplos de introducción \/ Paso 2: Crear Submódulo \"Switch\" ", 
"snippet" : "El siguiente paso es declarar un módulo para el interruptor de la habitación. Nuevamente, se debe crear una declaración de módulo y un bloque de funciones. Aquí, ambos se llaman Switch , donde la declaración debe ser implementada por el bloque de funciones. La declaración del módulo de Switch no nec...", 
"body" : "El siguiente paso es declarar un módulo para el interruptor de la habitación. Nuevamente, se debe crear una declaración de módulo y un bloque de funciones. Aquí, ambos se llaman Switch , donde la declaración debe ser implementada por el bloque de funciones. La declaración del módulo de Switch no necesita una sección de nivel superior, porque se agregará debajo del módulo Light (descrito más adelante) en ninguna posición de alto nivel. Como es obligatorio para todos los módulos que implementan bloques de funciones, el bloque de funciones Switch tiene que extender AC.Module , también. Para el caso que nos ocupa, el bloque de funciones también implementa una interfaz ISwitch , que tiene que ser creado. Esta interfaz en sí debe implementar la interfaz IModule , que es proporcionado por la biblioteca AC_ModuleBase . Sin embargo, la interfaz ISwitch permanece \"vacío\": no se declaran propiedades ni funciones. Además, el interruptor necesita una señal de entrada (probablemente de una fuente externa\/interruptor físico) para indicar cuándo se toca. Esta señal se declara en el IO sección utilizando la variable xIn del bloque de funciones que implementa este módulo. Además, se necesita un tiempo de referencia para distinguir las dos funciones del interruptor: Presionar el interruptor durante el tiempo tTimer inicia la función de atenuación - una pulsación más corta solo enciende o apaga la luz. esta variable tTimer (que también forma parte del módulo que implementa el bloque de funciones) se declarará como un parámetro del módulo (sección Parameters ), que eventualmente se puede editar fácilmente cuando se usa el módulo. Declaración de submódulo Switch Las variables referenciadas xIn y tTimer ambos se definen como entradas del bloque de funciones Switch , donde el parámetro tTimer obtiene un valor predeterminado inicial de 500 ms. Entonces, cuando el usuario presiona el botón Switch más de 500 ms, la luz se atenuará. Declaración en el Switch bloque de funciones Además, las listas de texto y el conjunto de imágenes deben ampliarse para incluir los textos de descripción necesarios de la entrada y el parámetro. Entradas en la lista de texto y el grupo de imágenes Paso 3: crea el submódulo \"Switch Simple\" " }, 
{ "title" : "Paso 3: crea el submódulo \"Switch Simple\" ", 
"url" : "ac_example_s3_create_sublevel_switchsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Tutorial \/ Ejemplos de introducción \/ Paso 3: crea el submódulo \"Switch Simple\" ", 
"snippet" : "El segundo módulo de interruptor, que queremos declarar, es uno simplificado con solo dos estados: encendido y apagado. Por lo tanto, se debe crear una declaración de módulo y un bloque de funciones, que están adaptados del \"Dim-Switch\" anterior. Una nueva interfaz de tipo ISwitchSimple se utiliza p...", 
"body" : "El segundo módulo de interruptor, que queremos declarar, es uno simplificado con solo dos estados: encendido y apagado. Por lo tanto, se debe crear una declaración de módulo y un bloque de funciones, que están adaptados del \"Dim-Switch\" anterior. Una nueva interfaz de tipo ISwitchSimple se utiliza para el bloque de funciones. Otra diferencia es que la variable xIn debe declararse como variable BOOL y sin parámetro tTimer se necesita en absoluto. Paso 4: Crear submódulo \"Light\" " }, 
{ "title" : "Paso 4: Crear submódulo \"Light\" ", 
"url" : "ac_example_s4_create_sublevel_light.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Tutorial \/ Ejemplos de introducción \/ Paso 4: Crear submódulo \"Light\" ", 
"snippet" : "Como se hizo antes para el Switch y el SwitchSimple , para el módulo Light , una declaración de módulo Light , un bloque de funciones Light y una interfaz ILight hay que crear. El módulo será implementado por el bloque de funciones, que a su vez implementará la interfaz ILight . Para poder agregar e...", 
"body" : "Como se hizo antes para el Switch y el SwitchSimple , para el módulo Light , una declaración de módulo Light , un bloque de funciones Light y una interfaz ILight hay que crear. El módulo será implementado por el bloque de funciones, que a su vez implementará la interfaz ILight . Para poder agregar el Light módulo debajo de nuestro Room módulo, la declaración de módulo de Room tiene que ser ampliado con un Slots sección. En esta sección una subsección Slot_Multi tiene que ser creado, lo que se llama Lights y podrá albergar módulos del tipo Light . El número de luces que pueden o deben agregarse a una habitación se define mediante el parámetro Cardinality (en este caso entre 1 y 3 luces). Además se declaran dos variables: Variable ( pLights , que contendrá las instancias del bloque de funciones de los módulos Light agregados a la habitación) y Var_Count ( uiNumberOfLights , que se rellenará con el número de módulos Light añadidos a la habitación). Definición de sección Slots las variables pLights y uiNumberOfLights deben agregarse al bloque de función del módulo \"Luces\", donde uiNumberOfLights es un UINT y pLights de tipo POINTER TO ILight Con esta definición, solo los módulos cuyos bloques de función también implementan el ILight La interfaz se puede agregar a la Lights espacio. Declaración en el Room bloque de funciones El mismo concepto de tragamonedas que se usó para el Room módulos se utiliza ahora para el Light módulo. En consecuencia, la declaración de Light incluye una ranura con un Switch , por lo que esta ranura no es una ranura múltiple, sino una ranura simple. Parámetros adicionales de la Light módulo son la velocidad del atenuador rSpeed y el brillo máximo uiMaxValue . Finalmente, se debe definir una salida que represente el brillo de la luz asociada. Todos los parámetros, ranuras y salidas también deben agregarse como variables al bloque de funciones del Light módulo. Declaración de módulo Light Declaración del bloque de función Light Lista de texto y grupo de imágenes Paso 5: Crear submódulo \"Light simple\" " }, 
{ "title" : "Paso 5: Crear submódulo \"Light simple\" ", 
"url" : "ac_example_s5_create_sublevel_lightsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Tutorial \/ Ejemplos de introducción \/ Paso 5: Crear submódulo \"Light simple\" ", 
"snippet" : "La luz simple, que se crea ahora, funcionará junto con un simple interruptor, pero se puede adaptar de Light arriba, de todos modos. Por lo tanto, una nueva declaración de módulo y bloque de funciones LightSimple hay que crear. Dado que el bloque de funciones simplemente implementa la interfaz ILigh...", 
"body" : "La luz simple, que se crea ahora, funcionará junto con un simple interruptor, pero se puede adaptar de Light arriba, de todos modos. Por lo tanto, una nueva declaración de módulo y bloque de funciones LightSimple hay que crear. Dado que el bloque de funciones simplemente implementa la interfaz ILight , será posible agregar luces de diferentes tipos a una habitación, más adelante. La principal diferencia a Light es, que la variable del slot tiene que ser del tipo ISwitchSimple para evitar que el interruptor incorrecto sea puesto bajo una LightSimple módulo. Además la salida de LightSimple será de tipo BOOL y se nombra xSwitchedOn . Paso 6: Implementación " }, 
{ "title" : "Paso 6: Implementación ", 
"url" : "ac_example_s6_implementation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Tutorial \/ Ejemplos de introducción \/ Paso 6: Implementación ", 
"snippet" : "Cambiar Para la implementación de la funcionalidad del módulo. Switch usamos el método CallPrioMediumStart desde Module anulándolo con nuestra propia implementación. Elegimos esta función, porque el módulo Room declarado un MEDIUM tarea, lo que implica que el método CallPrioMediumStart del bloque de...", 
"body" : "Cambiar Para la implementación de la funcionalidad del módulo. Switch usamos el método CallPrioMediumStart desde Module anulándolo con nuestra propia implementación. Elegimos esta función, porque el módulo Room declarado un MEDIUM tarea, lo que implica que el método CallPrioMediumStart del bloque de funciones Switch se llamará cada ciclo de una tarea mediana. La información detallada se puede ver en el propio proyecto de ejemplo. Sin embargo, la funcionalidad principal del interruptor es diferenciar entre la función de toque y atenuación. Después de presionar el interruptor, un temporizador comenzará con el tiempo dado por el parámetro de usuario. Cuando el temporizador finaliza y el interruptor no se suelta, se utiliza la función de atenuación, indicada por la variable xPushLong . La variable xPush es TRUE , si se toca el interruptor. Para ambos xPushLong y xPush las propiedades se agregan tanto al bloque de funciones Switch y la interfaz ISwitch , para que se puedan utilizar desde el bloque de función de luz principal. Luz Nuevamente, el Light bloque de funciones anula el método CallPrioMediumStart . Dependiendo de las variables de entrada del interruptor subyacente, la luz se atenúa a \"encendido\" o \"apagado\" o solo se alterna. Para el dimmer, el valor de velocidad del parámetro declarado rSpeed se usa Después de alcanzar el valor de atenuación máximo o mínimo, se detiene la atenuación. Si la luz está atenuada y se toca el interruptor, la luz se enciende. (La implementación detallada se proporciona en el proyecto de ejemplo correspondiente). Verifica el código Después de la implementación, las declaraciones deben verificarse mediante el uso del comando Construir . Si no se muestra ningún error, las declaraciones están bien. Paso 7: Componer módulos " }, 
{ "title" : "Paso 7: Componer módulos ", 
"url" : "ac_example_s7_composing_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Tutorial \/ Ejemplos de introducción \/ Paso 7: Componer módulos ", 
"snippet" : "Después de escanear con éxito las declaraciones, todos los módulos están disponibles para su uso posterior, de modo que se puede componer una aplicación de ejemplo. Por lo tanto, los módulos se agregan al árbol de módulos del proyecto. Para esto la vista Módulos debe ser abierto. En el primer paso, ...", 
"body" : "Después de escanear con éxito las declaraciones, todos los módulos están disponibles para su uso posterior, de modo que se puede componer una aplicación de ejemplo. Por lo tanto, los módulos se agregan al árbol de módulos del proyecto. Para esto la vista Módulos debe ser abierto. En el primer paso, el módulo de nivel superior Room tiene que ser añadido al árbol. Agregar módulo de nivel superior al árbol de módulos los Cuadro de diálogo del módulo abre y ofrece todos los módulos de nivel superior disponibles. En este diálogo, se muestran los iconos correspondientes que se definieron en el grupo de imágenes, así como los textos de las listas de texto. Ahora se puede seleccionar el módulo \"Habitación\" y agregarlo al árbol de módulos. Diálogo: \"Agregar módulo\" Ahora el editor del módulo de nivel superior se puede abrir haciendo doble clic Room en el árbol de módulos. Se debe seleccionar una aplicación de destino para la generación de código en la Toplevel pestaña. Las tareas que se han declarado en la declaración del módulo se muestran en el campo Tareas estándar . Configuración del módulo \"Room\" Análogo a los pasos anteriores al submódulo Light se puede agregar al árbol de módulos. Debido a la definición de múltiples ranuras en la declaración de la habitación, se pueden agregar hasta tres luces. Los valores para maxLightValue y Speed se puede parametrizar en el Parameters pestaña del editor de la Light módulo. En el editor de E\/S, la salida Brightness se asigna a una variable local uiBrightness para nuestro ejemplo. Ajustes del módulo \"Light\" Debajo del recién agregado Light , un módulo Switch debe agregarse En el editor de instancias del Switch módulo, todos los parámetros y E\/S, que se definen en la declaración del módulo, están disponibles. Para nuestro ejemplo la variable local xPushSwitch se asigna a la variable de entrada xEn . La salida de la luz simple se asigna a la variable local xSimpleOn . Configuración del módulo \"Switch\" En un último paso de nuestro ejemplo, un LightSimple con un SwitchSimple se agregan al árbol de módulos. La salida de la luz simple se asigna a la variable local xSimpleOn . La entrada del interruptor simple xPushSimpleSwitch se asigna a la variable xPushSimpleSwitch. Ejemplo de árbol de módulos de composición Al final, el proyecto debe generarse mediante el uso del comando Generar . Después de la descarga a un dispositivo, el ejemplo se puede probar cambiando el valor de xPushSwitch . Para atenuar el valor de uiBrillo debe aumentar lentamente y al tocar, su valor se establece directamente en 0 o al máximo. Cambiando xPushSimpleSwitch cambia directamente la salida de la luz correspondiente. Finalmente hay que mencionar, que los últimos pasos, de componer los módulos se pueden hacer en cualquier combinación, sin perder la funcionalidad del código generado. " }, 
{ "title" : "Biblioteca: Mechatronics ", 
"url" : "ac_mechatronics_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de módulos \/ Tutorial \/ Biblioteca: Mechatronics ", 
"snippet" : "los Mechatronics La biblioteca pretende ser un ejemplo de una implementación simple (y no completa) de una unidad mecatrónica con ejecución secuencial. No cumple con todos los requisitos que podría tener una aplicación mecatrónica completa. Más bien, pretende ser un punto de entrada o base para una ...", 
"body" : "los Mechatronics La biblioteca pretende ser un ejemplo de una implementación simple (y no completa) de una unidad mecatrónica con ejecución secuencial. No cumple con todos los requisitos que podría tener una aplicación mecatrónica completa. Más bien, pretende ser un punto de entrada o base para una aplicación de este tipo. El núcleo esencial del modelo de mecatrónica propuesto se basa en la siguiente estructura de módulos: Ejemplo de Compositor de aplicaciones Mechatronics Por lo tanto, se supone que cualquier máquina posiblemente tenga varias subunidades mecatrónicas (ejemplo: cada una representando una pinza). Tal subunidad nuevamente se divide en sus actuadores (equivalente a la propia unidad mecánica, también su implementación funcional o gestión de E\/S) y un administrador de programas. El administrador de programas está destinado a administrar los diferentes estados de una subunidad mecatrónica, por ejemplo, su Idle o Execute estado. Eventualmente, esos estados están representados por secuencias de programas que controlan los actuadores o cualquier otra cosa necesaria para una ejecución adecuada. En este punto, las diversas partes se describirán brevemente en detalle. Al usar la biblioteca, en muchos casos será necesario implementar sus propios actuadores, pasos de flujo o secuencias de programa, que también se explicarán aquí. Actuadores : Todos los módulos que deberían ser actuadores deben implementarse mediante un bloque de funciones que a su vez implemente el IActuator interfaz. Esta interfaz no tiene métodos ni propiedades y se usa solo para la compatibilidad del módulo (ver el IActuator documentación en la biblioteca). No se dan restricciones ni reglas para las implementaciones del actuador, por lo que el movimiento o la activación de dicho actuador debe realizarse por separado. Normalmente, esto se hace mediante la implementación de un módulo de pasos de secuencia, que puede mantener los actuadores adecuados en una ranura de referencia y, por lo tanto, mover estos últimos de la manera deseada (por ejemplo, utilizando interfaces adicionales). Pasos de secuencia Se recomienda enfáticamente que ejecute la implementación de pasos de flujo como clases derivadas del StepBase bloque de funciones Esto proporciona todas las implementaciones básicas necesarias del IProgramSequenceStep interfaz. Ver el IActuator documentación en la biblioteca. Al usar la clase base StepBase , entonces solo es necesario implementar el Execute método. Este último es llamado cíclicamente por el flujo del programa hasta que la variable xDone de la clase base se establece en TRUE . Además, para una correcta funcionalidad, la bandera xActive debe establecerse en TRUE mientras el paso esté activo. Sin embargo, la conexión a los actuadores se puede realizar de cualquier manera, por ejemplo, mediante las ranuras de referencia propuestas (ver 1.). Secuencia de programas y administrador de programas Una secuencia de programa es un submódulo de un administrador de programas, que representa un estado. Estos estados se gestionan en forma de una máquina de estado OMAC. Sus implementaciones nuevamente se basan en un método \"Ejecutar\" (para más detalles, consulte la implementación en la biblioteca). Sin embargo, la implementación de dicho flujo de programa por parte del usuario no es necesaria en la mayoría de los casos. Sin embargo, la forma en que el comportamiento de la máquina de estado se implementa en el administrador de programas y, por lo tanto, ejecuta las secuencias del programa se describirá brevemente aquí: Hay dos tipos de estados: estados de actuación (que terminan en \"ing\") y estados de espera\/dual (el resto). Los estados de espera finalizan mediante comandos externos, mientras que los estados de actuación se ejecutan y finalizan automáticamente. Los comandos disponibles dependen del estado en el que se encuentre el administrador del programa en ese momento. En el diagrama de estado OMAC se proporciona una breve descripción general: diagrama OMAC Módulo: MovableBarrier El módulo MovableBarrier se implementa de la siguiente manera: El bloque de función correspondiente MovableBarrier implementa la interfaz creada IMovableBarrier . La última interfaz define métodos para mover una barrera, mientras que IMovableBarrier en sí mismo implementa la interfaz IActuator , para que el módulo MovableBarrier se puede insertar como actuador en el árbol de módulos debajo de una unidad mecatrónica: Implementación del módulo MovableBarrier Sin embargo, este actuador \"MovableBarrier\" es movido por el módulo de pasos de secuencia MoveBarrierForTime , que a su vez se implementa de la siguiente manera: Implementación del módulo MoveBarrierForTime El módulo que implementa el bloque de funciones MoveBarrierForTime simplemente se deriva del bloque de función base contenido en la biblioteca AC_MEC.StepBase . Por eso el bloque de funciones MoveBarrierForTime ya implementa la interfaz IProgramSequenceStep . En consecuencia, el módulo MoveBarrierForTime se puede insertar como paso de secuencia en una secuencia de programa. La implementación funcional del bloque de funciones. MoveBarrierForTime es el siguiente: definiendo un slot de referencia para el módulo MoveBarrierForTime , que puede contener un actuador que implementa la interfaz IMovableBarrier , uno obtiene una conexión a un actuador \"MovableBarrier\" existente. El movimiento de este actuador se realiza finalmente en el Execute función de la MoveBarrierForTime bloque de función, que simplemente llama al método para (pictóricamente) mover la cubierta protectora. Este método lo proporciona el actuador referenciado, que implementa IMovableBarrier . Además la propiedad Done y la variable xActive están acoplados a un TON, de modo que llama repetidamente a las funciones de movimiento de IMovableBarrier se realizan hasta que transcurre cierto tiempo (TON), después del cual Done se establece en VERDADERO y xActive a FALSO. La propiedad Done es parte de la interfaz IProgramSequenceStep y por lo tanto le dice a la secuencia de programa superior que se ejecutará el siguiente paso de secuencia. Además de su propia implementación de pasos de secuencia, el AC_Mechatronics.library también proporciona algunos pasos pre-implementados, que se pueden usar para operaciones lógicas generales. Por ejemplo, esto significa un paso BranchOnBool se proporciona, que tiene dos subsecuencias \/ ramas de pasos, que se ejecutan en función del valor de una variable BOOL. Estos subpasos se ejecutan según el valor de una variable booleana. Además, la biblioteca AC_Mechatronics.library contiene pasos de flujo para flujos paralelos, saltos condicionales o pasos de espera simples y muchas más tareas. " }, 
{ "title" : "Editor de declaración de módulo ", 
"url" : "ac_module_declaration_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo ", 
"snippet" : "Un módulo normalmente representa un componente mecatrónico, pero también puede ser una función de software pura. Contiene todos los aspectos de ingeniería cubiertos por CODESYS . Un módulo tiene un bloque de función, que implementa la interfaz IModule de la biblioteca AC_ModuleBase . También contien...", 
"body" : "Un módulo normalmente representa un componente mecatrónico, pero también puede ser una función de software pura. Contiene todos los aspectos de ingeniería cubiertos por CODESYS . Un módulo tiene un bloque de función, que implementa la interfaz IModule de la biblioteca AC_ModuleBase . También contiene información sobre submódulos, parametrización, demanda de E\/S, asignación de tareas y visualizaciones. Los módulos constituyen el concepto central de la CODESYS Application Composer . los CODESYS Application Composer también proporciona un proyecto de plantilla, que se puede seleccionar en el Nuevo proyecto diálogo. Esta plantilla crea un proyecto con un dispositivo, una aplicación y un administrador de bibliotecas en el grupo de POU. Este último contiene las bibliotecas. AC_ModuleBase y AC_Persistence . La plantilla, que se basa en el proyecto. ComposerProject.project , se puede modificar si es necesario. Se almacena en la subcarpeta \"Plantillas\" del CODESYS directorio de instalación. Se puede crear un módulo a partir de un bloque de funciones existente automáticamente. De este modo, en la medida de lo posible, las declaraciones existentes se transfieren a la declaración del módulo. Para más detalles ver la descripción del Crear módulo desde FB mando. Ver Declaración del módulo para obtener información detallada sobre cómo desarrollar módulos. Para obtener información sobre el intercambio de datos entre diferentes aplicaciones, consulte Servicio IRMP . " }, 
{ "title" : "Declaración del módulo ", 
"url" : "ac_module_declaration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo ", 
"snippet" : "La declaración de módulos se realiza con un lenguaje de descripción propio similar a la declaración de variables en código de texto estructurado (ST). Secciones de la declaración del módulo. Sección: Metadatos Sección: Nivel superior Sección: IO Sección: Parámetros Sección: Tragamonedas Sección: Vis...", 
"body" : "La declaración de módulos se realiza con un lenguaje de descripción propio similar a la declaración de variables en código de texto estructurado (ST). Secciones de la declaración del módulo. Sección: Metadatos Sección: Nivel superior Sección: IO Sección: Parámetros Sección: Tragamonedas Sección: Visú Sección: Apoderados Sección: VarArrays Sección: Restricciones Sección: Referencias Inst Sección: mse.Secuencia DeviceGeneratoralg.Alarm" }, 
{ "title" : "Formato de la declaración del módulo. ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_48fab9ed86f6686ac0a8640e00dcb86d", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Formato de la declaración del módulo. ", 
"snippet" : "Un encabezado del formulario MODULE<name> Comienza la declaración. A esto le sigue una lista de \"secciones\". Cada sección está introducida por la palabra clave. SEC (para \"sección\") y un nombre único. La palabra clave END_SEC cierra la sección. El contenido de una sección contiene una lista de entra...", 
"body" : "Un encabezado del formulario MODULE<name> Comienza la declaración. A esto le sigue una lista de \"secciones\". Cada sección está introducida por la palabra clave. SEC (para \"sección\") y un nombre único. La palabra clave END_SEC cierra la sección. El contenido de una sección contiene una lista de entradas que se componen de otras secciones o las llamadas definiciones. Una definición consta de un nombre y un valor opcional y termina con un punto y coma. Los comentarios se pueden usar como en el código ST: \"\/\/\"\" para un comentario de una sola línea y \"(*\" y \"*)\" para comentarios de varias líneas. Se pueden usar espacios en blanco (tabulaciones y espacios) y nueva línea\/avance de línea para separar las partes. de una declaración; de lo contrario, se ignorarán durante el procesamiento posterior. Al igual que con el código ST, la distinción entre mayúsculas y minúsculas no hace ninguna diferencia. El siguiente ejemplo explica los elementos de una declaración de módulo. 01 MODULE Persistence IMPLEMENTED_BY PersistenceFB\n02 SEC MetaData\n03 NAME := TL.ChannelName ;\n04 DESC := TL.ChannelDesc ;\n05 COLLECTION CATEGORY := ’Persistence’TL.Collection ;\n06 ICON_16 := IP.Channel16 ;\n07 ICON_32 := IP.Channel32 ;\n08 END_SEC\n09 SEC Toplevel\n10 SEC STANDARD_TASK : LOW\n11 NAME := LOW ;\n12 DESC := TL.TaskLow ;\n13 FLAGS := CREATE_IF_MISSING | READONLY ;\n14 END_SEC\n15 GVL_NAME := 'GVL_%InstanceName%' ;\n16 END_SEC En la línea 01 está la definición del nombre del módulo \"Persistencia\". IMPLEMENTED_BY define el bloque de funciones \"PersitenceFB\" que contiene la lógica del módulo. Este bloque de funciones debe derivar de IModule . En la línea 02 la sección MetaData comienza y termina con la línea 08. Esta sección contiene cinco definiciones. La posibilidad de secciones anidadas se muestra en la sección Toplevel (líneas 09 a 16) que contiene la subsección STANDARD_TASK (línea 10). " }, 
{ "title" : "Sintaxis de la declaración del módulo. ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_819a1c8e627d0b32c0a8640e01623943", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sintaxis de la declaración del módulo. ", 
"snippet" : "En esta sección se explicará la sintaxis y la estructura sintáctica permitida de una declaración de módulo. En el siguiente escáner, los tokens se escribirán en mayúsculas (ejemplo: ID ). Los no terminales de la gramática se escribirán entre llaves (ejemplo: {Entry} ). Análisis léxico (escáner) En e...", 
"body" : "En esta sección se explicará la sintaxis y la estructura sintáctica permitida de una declaración de módulo. En el siguiente escáner, los tokens se escribirán en mayúsculas (ejemplo: ID ). Los no terminales de la gramática se escribirán entre llaves (ejemplo: {Entry} ). Análisis léxico (escáner) En el primer paso se crearán los llamados tokens (o lexemas) a partir de los caracteres de la declaración del módulo (ejemplo: palabras clave, constantes, identificadores). Los espacios en blanco y los caracteres de nueva línea\/avance de línea separan los tokens, pero de lo contrario se ignorarán. Los comentarios también serán ignorados para el tratamiento posterior de la declaración. (Los comentarios se pueden escribir en una sola línea ( \/\/ \") o comentarios de varias líneas ( (* y *) ) como en el lenguaje ST. Los comentarios de varias líneas se pueden anidar. Básicamente, un token siempre tiene una longitud máxima. Por ejemplo a123 se interpretará como un identificador y no como un identificador a seguido de un literal 123 . El orden de los tokens en la lista siguiente muestra su prioridad. Por ejemplo la entrada MODULE se entenderá como palabra clave y no como identificador. Lista de todos los tokens disponibles: Palabras clave: MODULE , SEC , END_SEC , IMPORTS , y IMPLEMENTED_BY OP: una secuencia no vacía de los siguientes caracteres: .:,%()[]{}<>|+-*\/@!?^°=\\~ Nota: Los marcadores de comentarios \/\/ , (* , y *) tienen mayor prioridad que los operadores. No puede haber ningún comentario dentro de un operador, ningún comentario puede ser, ejemplo: +\/\/+ se interpretará, según la regla de la longitud máxima, como un operador y no como + seguido de un comentario. LIT: Un literal IEC, tal como se usa en ST, ejemplo: 1.4 , tod#12:13:14 . Esto incluye los literales booleanos. TRUE y FALSE (Las mayúsculas o minúsculas no son relevantes). Nota: Literales sin tipo con signo negativo ( -1 , -3.2 ) se leerá como dos tokens, es decir, como operador - seguido de un literal sin tipo. Como resultado de estos literales numéricos sin tipo, nunca puede ser negativo. Literales escritos ( INT#-34 ) siempre se interpretará como un token. ID: un identificador IEC válido ( [a-zA-Z_][a-zA-Z0-9_]* ), por lo que no se permiten dos subrayados consecutivos. A diferencia de ST, esto incluye también las palabras clave de ST (es decir: FUNCTION , INT , EXTENDS ,…) PUNTO Y COMA: el personaje ; Sintaxis (analizador) La sintaxis de la declaración del módulo está definida por la siguiente gramática. µ es una secuencia vacía. {MDecl} ::= MODULE {QID} {ImplSpec} {ImportsSpec} {MBody}\n{ImplSpec} ::= IMPLEMENTED_BY {QID} | µ\n{ImportsSpec} ::= IMPORTS {QID} | µ\n{MBody} ::= {SecList}\n{SecList} ::= {Modifiers} {Sec} {SecList} | µ\n{Sec} ::= SEC {QID} {SecTarget} {EntryList} END_SEC\n{SecTarget} ::= OP(\":\") {QID} | µ\n{Modifiers} ::= OP(\"[\") {ModifierList} OP(\"]\") | µ\n{ModifierList} ::= {QID} OP(\",\") {ModifierList} | {QID}\n{EntryList} ::= {Modifiers} {Entry} {EntryList}\n{Entry} ::= {Sec} | {Def}\n{Def} ::= {QID} OP(\":=\") {ValList} SEMICOLON |\n {QID} SEMICOLON\n{ValList} ::= {Val} {ValList} | {Val}\n{Val} ::= ID | LIT | OP\n{QID} ::= ID | ID OP(\".\") {QID} La lista de valores de definición ( {ValList} ) debe completarse con punto y coma. Esto simplifica la gramática y evita ambigüedades, porque el punto y coma no puede ser parte de un valor ( {VAL} ), excepto dentro de una cadena literal. El operador de asignación ( := ) de definiciones ( {Def} ) también sirve para evitar ambigüedades ( {QID} ) de nombres y valores de definiciones. Tipos definidos para definiciones Texto: ID.ID (nombre de la lista de texto e identificador de la lista de texto) - consulte Localización de cadenas de listas de texto. Imagen: ID.ID (nombre del grupo de imágenes e identificador del grupo de imágenes) ID (identificador IEC) QID (Identificador calificado): {QID} ::= ID | ID.ID CategoryPath ::= {StringLiteral} | {CategoryPath} Cardinalidad: [{MIN} .. {MAX}] | [ {MIN} .. INF [ {MIN} , y {MAX} son literales enteros no negativos. Si {MAX} != INF , entonces {MIN} <= {MAX} tiene que aplicar. StringLiteral: un literal de cadena IEC puede contener saltos de línea. Indicadores de tareas estándar ::= {Indicador de tareas estándar} | {StdTaskFlags} StdTaskFlag ::= NONE | CREATE_IF_MISSING | READONLY Literal: cualquier literal IEC o QID (para constantes Enum) DTBoolFlag: µ (secuencia vacía) | TRUE | FALSE Tipo de ranura: SUBMODULE | REFERENCE Pragmas: [ {PragmaList} ] {PragmaList} ::= {Pragma} | {Pragma} , {PragmaList} {Pragma} ::= { ( ID | {StringLiteral} | {OP2} )+ } {OP2} : todos los operadores excepto {, }, [, ] y , . Ruta de instancia: InstancePath ::= {IComp} | {IComp} . {IComp} mit {IComp} ::= ID {ArrayAccess}* y {ArrayAccess} ::= [ {IntList} ] y {IntList} ::= Int | Int , {IntList} TaskRef: Tarea_estándar. ( Low | Medium | High ) | Custom_Task.ID " }, 
{ "title" : "Rutas de instancia ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_e00dd4f26a1882aec0a8652000c0a4ae", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Rutas de instancia ", 
"snippet" : "En algunas posiciones de la declaración del módulo, se pueden definir rutas de instancia para direccionar una variable de un bloque de funciones: para parámetros, ranuras, E\/S, matrices con tamaño variable y referencias de instancia. Una ruta de instancia se define como una secuencia de componentes ...", 
"body" : "En algunas posiciones de la declaración del módulo, se pueden definir rutas de instancia para direccionar una variable de un bloque de funciones: para parámetros, ranuras, E\/S, matrices con tamaño variable y referencias de instancia. Una ruta de instancia se define como una secuencia de componentes no vacía, separados por puntos: C1.C2…CN . Un componente debe ser un identificador IEC o un componente seguido de una expresión de índice [i1, …, iN] , dónde i1 a iN son valores enteros. Las rutas de instancia siempre son relativas al bloque de funciones que implementa la lógica del módulo. El primer componente de la ruta de la instancia es un miembro ( VAR_INPUT o VAR_OUTPUT , dependiendo del caso de uso) del bloque de funciones. En el caso de componentes adicionales en la ruta de la instancia, estos componentes abordan la variable dentro del miembro. De lo contrario, se dirige al propio miembro. Las rutas de instancia se pueden restringir a variables de entrada o salida (ejemplo: para E\/S). Para estructuras estas restricciones no son válidas. Este tipo de rutas de instancia se denominan rutas de instancia de entrada, respectivamente. rutas de instancia de salida. " }, 
{ "title" : "Localización de cadenas de listas de texto. ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_497561d55e22d540c0a8640e01561e3c", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Localización de cadenas de listas de texto. ", 
"snippet" : "Los textos de los módulos (ejemplo: descripción del módulo, nombre, descripción del parámetro) se pueden mostrar en diferentes idiomas. Estos textos se gestionan en listas de textos. Especificación para el nombre del idioma: El nombre del idioma es de formato. <LanguageCode>[-<Country\/Region>] (ejem...", 
"body" : "Los textos de los módulos (ejemplo: descripción del módulo, nombre, descripción del parámetro) se pueden mostrar en diferentes idiomas. Estos textos se gestionan en listas de textos. Especificación para el nombre del idioma: El nombre del idioma es de formato. <LanguageCode>[-<Country\/Region>] (ejemplo: en-US , de-DE ). <LanguageCode> es el nombre del idioma según ISO 639-1 (ejemplo: de o en ). <Country\/Region> es un código de país según ISO 3166. Al recuperar una entrada de la lista de texto, el sistema primero busca el nombre completo del idioma. Si no encuentra nada, busca el <LanguageCode> . Si esta búsqueda también falla, se utilizará el texto predeterminado. Ejemplos de nombres de idiomas en listas de texto Idioma Nombre del idioma Chino zh-CHS Inglés es-US Francés fr-fr Alemán de-DE italiano eso eso japonés ja-JP portugués pt-PT ruso ru-RU Español es-ES " }, 
{ "title" : "Derivando declaraciones de módulo ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_a596cccf5e22d542c0a8640e019ddff8", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Derivando declaraciones de módulo ", 
"snippet" : "De manera análoga a la herencia orientada a objetos de un bloque de funciones A de un bloque de funciones B (\"EXTENDS\"), existe la posibilidad de derivar declaraciones de módulo mediante el uso de IMPORTS palabra clave. Los modificadores UPDATE y HIDE son tratados de manera especial. Se utilizan las...", 
"body" : "De manera análoga a la herencia orientada a objetos de un bloque de funciones A de un bloque de funciones B (\"EXTENDS\"), existe la posibilidad de derivar declaraciones de módulo mediante el uso de IMPORTS palabra clave. Los modificadores UPDATE y HIDE son tratados de manera especial. Se utilizan las siguientes reglas: El nombre del módulo importado debe especificarse con un espacio de nombres si este módulo está definido en una biblioteca diferente. No se permiten importaciones cíclicas; en particular, un módulo no debe importarse a sí mismo. (Ejemplo de una importación cíclica: el módulo M_1 importa el módulo M_2, M_2 importa M_3,…, M_N importa M_1 nuevamente.) Un módulo derivado se puede definir sin el IMPLEMENTED_BY directiva. En este caso se utilizará el bloque de funciones del módulo base. Si un módulo derivado especifica un bloque de funciones (mediante el uso de MPLEMENTED_BY ), este bloque de funciones debe derivar del bloque de funciones del módulo base o debe ser idéntico a él. Un módulo derivado hereda todas las secciones del módulo base. Puede agregar nuevas secciones o modificar secciones existentes. Se puede modificar una sección en el módulo derivado usando el mismo nombre y destino extendido con el modificador UPDATE . En este caso, se modifican sus entradas. Todas las definiciones que falten de la sección en el módulo derivado se tomarán del módulo base. el modificador UPDATE y HIDE sólo se puede utilizar si la sección respectiva (nombre y destino) está definida en el módulo básico. Por el contrario, una sección que está definida en el módulo base sólo puede usarse en el módulo derivado si tiene la HIDE o UPDATE modificador. Si solo existe el HIDE modificador en la sección y no UPDATE , entonces no se permiten definiciones. Algunas entradas deben cambiarse en el módulo derivado (ejemplo: la descripción). Ejemplo: MODULE MBase IMPLEMENTED_BY FBBase\nSEC MetaData\n DESC := TL.Desc_Base ;\nEND_SEC\nSEC Parameters\n SEC Param : paramxIn\n Variable := xIn ;\n Name := TL.Param1_Name ;\n Desc := TL.Param1_Desc ;\n END_SEC\nEND_SEC\n\nMODULE MDerived IMPORTS MBase\n[UPDATE] SEC MetaData\n DESC := TL.Desc_Derived ;\nEND_SEC\n[UPDATE] SEC Parameters\n [UPDATE,HIDE] SEC Param : paramIn\n Variable := xIn ;\n DEFAULT := TRUE ;\n END_SEC\nEND_SEC En el ejemplo anterior el parámetro paramIn del módulo MBase está oculto en el módulo derivado MDerived (mediante el uso del HIDE modificador), y al mismo tiempo un nuevo valor predeterminado ( TRUE ) Está establecido. " }, 
{ "title" : "Notas sobre el orden de las secciones y definiciones. ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_87237560fda311e1967bf6fe1c17b04f", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Notas sobre el orden de las secciones y definiciones. ", 
"snippet" : "El orden de las secciones inmediatamente después del encabezado del módulo es irrelevante. Dentro de las secciones el orden puede ser muy importante. Por ejemplo, el orden de las declaraciones de ranuras define el orden de los módulos en el árbol de módulos. El orden de las definiciones siempre es i...", 
"body" : "El orden de las secciones inmediatamente después del encabezado del módulo es irrelevante. Dentro de las secciones el orden puede ser muy importante. Por ejemplo, el orden de las declaraciones de ranuras define el orden de los módulos en el árbol de módulos. El orden de las definiciones siempre es irrelevante. Reglas para módulos derivados relacionados con el pedido: Las secciones de los módulos base siempre se definen antes que las secciones del propio módulo. Si se cambia una sección del módulo base mediante el uso de UPDATE o HIDE , su orden no se ve afectado. No es posible que un módulo derivado cambie el orden definido en el módulo base. " }, 
{ "title" : "Autocompletar y \"listar componentes\" ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_23e0e10e3a0c71c9c0a8640e0040f55b", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Autocompletar y \"listar componentes\" ", 
"snippet" : "Cuando comience a escribir en el editor de módulos, todas las definiciones de sección disponibles\/posibles se muestran en un menú de \"lista de componentes\". Sólo se muestran secciones y definiciones significativas para la posición actual. Incluso si algunas entradas de subsección tienen el mismo nom...", 
"body" : "Cuando comience a escribir en el editor de módulos, todas las definiciones de sección disponibles\/posibles se muestran en un menú de \"lista de componentes\". Sólo se muestran secciones y definiciones significativas para la posición actual. Incluso si algunas entradas de subsección tienen el mismo nombre que las entradas de subsección de otras secciones, intentará mostrar solo las definiciones de sección coincidentes. Si Devolver se presiona después de completar la primera línea de una sección, entonces la sección se completará con todas las definiciones\/secciones necesarias y el END_SEC . Después de las definiciones de variables, las variables de entrada\/salida se presentan mediante definiciones de \"componentes de lista\". Las banderas o valores predefinidos también se presentan en una selección de \"componentes de lista\", que muestra las posibles banderas\/valores. Después de las definiciones, que utilizan entradas de lista de texto o entradas de grupo de imágenes (ejemplo: la mayoría de las veces Desc := ), se presenta un menú de \"componentes de lista\" que incluye todas las listas de texto o grupos de imágenes disponibles y visibles y sus entradas. Presionando F2 , se puede abrir el soporte de entrada correspondiente. " }, 
{ "title" : "Inicialización de instancias de módulo (cambio en línea) ", 
"url" : "ac_initialization_of_module_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Inicialización de instancias de módulo (cambio en línea) ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Inicialización y reinicialización de instancias de módulo e instancias de proxy (cambio en línea) ", 
"url" : "ac_initialization_of_module_instances.html#UUID-d33dd918-6f7b-5e75-6686-b9d605273b58_index_2", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Inicialización de instancias de módulo (cambio en línea) \/ Inicialización y reinicialización de instancias de módulo e instancias de proxy (cambio en línea) ", 
"snippet" : "El método IBaseInstance.Init(bOnlineChange : BOOL) ) se llama después de una descarga o un cambio en línea para todas las instancias del módulo de nivel superior y para todas las instancias de proxy. Los módulos son responsables de llamar a todas las instancias de módulos administrados, si es necesa...", 
"body" : "El método IBaseInstance.Init(bOnlineChange : BOOL) ) se llama después de una descarga o un cambio en línea para todas las instancias del módulo de nivel superior y para todas las instancias de proxy. Los módulos son responsables de llamar a todas las instancias de módulos administrados, si es necesario. Init se llama tan pronto como se establecen todos los valores de los parámetros, las instancias de módulo administradas y referenciadas y las instancias de módulo se han montado en el árbol de módulos, pero antes de que se inicien o continúen las tareas. La implementación estándar en el bloque de funciones. Module llama a todos los submódulos. Los métodos IBaseInstance.OnBeforeOnlineChange y IBaseInstance.OnAfterOnlineChange se llaman antes y después de que se haya recreado la estructura del árbol de módulos y se hayan cambiado los valores de los parámetros. Además, los métodos se llaman antes y después de que todos los submódulos y módulos a los que se hace referencia hayan sido reasignados, pero antes de que las tareas se (reinicien). En contraste con FB_Init , este método se llama en cada cambio en línea, independientemente de si FB_Exit ha sido llamado en la instancia anterior antes. " }, 
{ "title" : "Sección: Metadatos ", 
"url" : "ac_module_fb_sec_metadata.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: Metadatos ", 
"snippet" : "metadatos La sección MetaData contiene la descripción, categoría e íconos (con tamaño 16x16 píxeles y 32x32 píxeles). SEC MetaData \/\/optional: yes, modifier: [UPDATE]] Desc := <description>; \/\/optional: no, type: text Category := <category name>; \/\/optional: no, type: CategoryPath Icon_16 := <icon16...", 
"body" : "metadatos La sección MetaData contiene la descripción, categoría e íconos (con tamaño 16x16 píxeles y 32x32 píxeles). SEC MetaData \/\/optional: yes, modifier: [UPDATE]]\n Desc := <description>; \/\/optional: no, type: text\n Category := <category name>; \/\/optional: no, type: CategoryPath\n Icon_16 := <icon16 name>; \/\/optional: no, type: image\n Icon_32 := <icon32 name>; \/\/optional: no, type: image\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: IDOrNothing\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Links := ['<link1>','<link2>',...] \/\/optional: Yes, type: UriCollection\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . Especificación: Si la sección MetaData falta, este módulo se utilizará como módulo base del que no se puede crear una instancia. Category define un tema para módulos que pertenecen al mismo tema. El personaje | crea una estructura jerárquica de los elementos en el cuadro de diálogo \"Agregar módulo\". Los caracteres | y newline o carriage return no están permitidos en los nombres de las estructuras. Icon_16 define el nombre del icono con resolución 16 x 16 píxeles. Las imágenes de los iconos deben definirse en un grupo de imágenes. El icono Icon_16 se utiliza para el árbol de módulos y el icono Icon_32 para el diálogo de información. Inst_Prefix define el prefijo predeterminado para los nombres de instancias de FB e instancias de submódulo generadas. Prefijo vacío ( Inst_Prefix := ) también son posibles, lo que sin embargo puede provocar una intersección con otros nombres de variables del bloque de funciones. Este ajuste preestablecido se puede sobrescribir en la sección Slot . Si se deriva de una clase de módulo con IMPORTS , la sección MetaData debe actualizarse si esta sección existe en el módulo base. Para ello se debe declarar la sección con el modificador UPDATE y la descripción debe ser redefinida. Default_Inst_Name se puede utilizar para definir un nombre predeterminado para las instancias de módulo que son hijos de esta ranura. Cada módulo que se agregue obtendrá este nombre de forma predeterminada utilizando la entrada de la lista de texto definida por \"Default_Inst_Name\". Si hay un nombre predeterminado para una ranura principal, se prefiere este nombre al de los metadatos del módulo. Links define una lista de enlaces. Los enlaces se muestran en el editor de módulos en la Información pestaña. El contenido de la primera URL de la lista de enlaces se muestra en el Información pestaña. Ejemplo SEC MetaData\n Desc := TL.Desc_Drives ;\n Category := 'Mechatronics'|'Drives' ;\n Icon_16 := IP.Drive_Icon_16 ;\n Icon_32 := IP.Drive_Icon_32 ;\n Default_Inst_Name := IDrive ;\n Links := ['file:\/\/\/d:\\Document1.pdf', 'https:\/\/www.codesys.com', 'mailto:info@codesys.com'];\nEND_SEC Category := 'Mechatronics'|'Drives crea la siguiente estructura: " }, 
{ "title" : "Sección: Toplevel ", 
"url" : "ac_module_fb_sec_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: Toplevel ", 
"snippet" : "Toplevel Los módulos que se encuentran en el primer nivel del árbol de módulos se denominan módulos de nivel superior. A diferencia de otros módulos, tienen métodos que se pueden llamar directamente desde una o varias tareas. Los módulos de nivel superior contienen la sección Toplevel . SEC Toplevel...", 
"body" : "Toplevel Los módulos que se encuentran en el primer nivel del árbol de módulos se denominan módulos de nivel superior. A diferencia de otros módulos, tienen métodos que se pueden llamar directamente desde una o varias tareas. Los módulos de nivel superior contienen la sección Toplevel . SEC Toplevel \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/(optional: no, type: Text)\n Flags:= <flag>; \/\/(optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . Especificación: GVL_Name define el nombre de la GVL en la que se declarará la instancia del módulo y todas sus subinstancias. El marcador de posición %Instancename% (La ortografía en mayúsculas o minúsculas no es relevante), será reemplazada por el nombre de la instancia del módulo. El parámetro Default_Application define la asignación de la aplicación para todas las instancias de este módulo a una aplicación específica. Si se define una aplicación predeterminada, el uso de Default_POUPool no es posible. El parámetro Default_POUPool define la asignación de la aplicación para todas las instancias de este módulo al grupo de POU. Si se define un grupo de POU predeterminado, el uso de Default_Application no es posible. El parámetro Pragmas contiene una lista de pragmas del compilador, que se insertarán antes de la declaración de las instancias FB del módulo. La sección Standard_Task define las tareas desde las cuales se ejecutarán las llamadas. Para esto están disponibles tres tareas estándar: LOW , MEDIUM , y HIGH . Las definiciones de Standard_Task son: Name : Nombre de tarea predeterminado que se definirá como asignación de tarea después de crear la instancia del módulo. Desc : Identificador de la llamada de tarea. Esto debe ser breve y significativo (ejemplo: I\/O task ). Flags : Los siguientes valores se pueden combinar con el | personaje: CREATE_IF_MISSING : La tarea se creará si no existe. READONLY : La asignación de tareas es de solo lectura y el usuario no puede cambiarla. UPDATE_IOS : La tarea se utiliza para actualizar las E\/S. Cada E\/S puede ser sobrescrita por el UpdateInTask parámetro en el IO sección. NONE : No hay ningún indicador establecido. Ejemplo SEC Standard_Task : MEDIUM\n Name := MainTask ;\n Desc := TL.TaskMedium_Desc ;\n Flags := READONLY | CREATE_IF_MISSING ;\nEND_SEC Mediante el uso de la sección Custom_Task un módulo puede definir una o más tareas personalizadas. El destino de la sección debe ser el nombre de un método del bloque de funciones del módulo. El método no debe tener argumentos (ni INPUT , OUTPUT , ni INOUT ). Priority : Define la prioridad de la tarea. Interval : Define el intervalo de la tarea (constante de tipo de datos \"TIME\" o \"LTIME\"). Flags : Los siguientes valores se pueden combinar con el | personaje: SHARED : Por motivos de compatibilidad, este indicador todavía existe, pero siempre se supone implícitamente que está configurado. Básicamente significaría que si una tarea con las propiedades especificadas en el Custom_Task La sección ya existe, se utilizará esta tarea. Pero debido a que se creará una nueva tarea si no existe ninguna tarea con propiedades coincidentes, esta bandera queda obsoleta. El nombre de la tarea creada es TASK_<ModuleInstanceName>_<MethodName> . UPDATE_IOS : La tarea se utilizará para actualizar las E\/S que están conectadas a expresiones ST o directamente a las E\/S del módulo. NONE : No hay ningún indicador establecido. No existe una implementación predeterminada en la clase de módulo para el método especificado. Ejemplo SEC Custom_Task : Method1\n Priority := 7 ;\n CycleTime := t#14ms ;\n Flags := NONE ;\nEND_SEC Exactamente una tarea estándar o específica debe tener la UPDATE_IOS conjunto de banderas. Aquí se mencionarán algunas reglas básicas sobre cómo se generan las tareas: Si existen tareas estándar que no tienen la CREATE_IF_MISSING conjunto de indicadores, debe existir una tarea con el nombre especificado y las propiedades de la configuración del generador. Si las propiedades no coinciden con la especificada, se muestra un mensaje de advertencia. Si existen tareas estándar, ¿cuál tiene la CREATE_IF_MISSING establecido el indicador, primero se genera una tarea con propiedades específicas. Ahora, cada vez que se cambia la configuración del generador para esta tarea, la tarea se adapta, sin ningún mensaje de advertencia. No se permiten tareas estándar de diferentes tipos que hagan referencia al mismo nombre de tarea. En este caso, no se emite ningún error. Dependiendo del estándar configurado, se llaman los siguientes métodos al principio y al final de la tarea definida para cada instancia de nivel superior: METHOD CallPrioHighStart: BOOL\nMETHOD CallPrioHighEnd: BOOL\nMETHOD CallPrioMediumStart: BOOL\nMETHOD CallPrioMediumEnd: BOOL\nMETHOD CallPrioLowStart: BOOL\nMETHOD CallPrioLowEnd: BOOL Cada módulo es responsable de llamar a sus instancias de submódulo. No se deben llamar referencias de submódulos. La implementación predeterminada en el FB. Module llama a los métodos respectivos de todas las instancias de submódulos en el orden de su posición en el árbol de módulos. El puntero SUPER ofrece acceso a la instancia del bloque de funciones base. Por lo tanto, por ejemplo, la llamada SUPER^.CallPrioHighStart() se puede utilizar para llamar al método Module.CallPrioHighStart() si el bloque de funciones se extiende Module . De esta manera, la implementación en Module se asegurará de que se llamen todos los submódulos. " }, 
{ "title" : "Sección: IO ", 
"url" : "ac_module_fb_sec_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: IO ", 
"snippet" : "IO La definición de entrada y salida se puede realizar en esta sección. Todas las entradas y salidas definidas están disponibles en el Mapa de E\/S . SEC IO \/\/optional: yes, modifier: [UPDATE] SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/option...", 
"body" : "IO La definición de entrada y salida se puede realizar en esta sección. Todas las entradas y salidas definidas están disponibles en el Mapa de E\/S . SEC IO \/\/optional: yes, modifier: [UPDATE]\n SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\n SEC Output : <output identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\nEND_SEC Para obtener detalles sobre la sintaxis de los tipos de definición, consulte: descripción en Sintaxis de la declaración del módulo. . Especificación: El parámetro Variable define la ruta de instancia de una variable de entrada o de salida. Todos los componentes de la ruta de entrada deben ser variables de entrada (o variables locales en estructuras). Todos los componentes de la ruta de salida también deben ser variables de salida (o variables locales en estructuras). La variable debe ser un tipo de datos primitivo o un tipo de datos de enumeración. Una variable puede ser parámetro y entrada\/salida al mismo tiempo. Una variable no debe ser utilizada por dos E\/S diferentes. El objetivo de un input o output La sección debe identificar de forma única la entrada o salida. No se distingue entre mayúsculas y minúsculas. El parámetro UpdateInTask determina la tarea de actualizar las E\/S. Si a este parámetro le falta la tarea con la bandera UPDATE_IOS se utilizará. Para los módulos de nivel superior, se creará un error si la tarea especificada en UpdateInTask no está definido para el módulo. Ejemplo SEC Io\n SEC Input : uiTemperature\n Variable := uiTemperature ;\n Name := TL_WeatherStation.NAME_iTemperature ;\n Desc := TL_WeatherStation.DESC_iTemperature ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\n SEC Output : uiLigh\n Variable := uiLightnessSouth ;\n Name := TL_WeatherStation.NAME_uiLightnessSouth ;\n Desc := TL_WeatherStation.DESC_uiLightnessSouth ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\nEND_S " }, 
{ "title" : "Sección: Parameters ", 
"url" : "ac_module_fb_sec_parameters.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: Parameters ", 
"snippet" : "Parameters En esta sección se pueden definir todos los parámetros que deben estar disponibles para una parametrización en el Parámetros de la instancia del módulo. SEC Parameters \/\/optional: yes, modifier: [UPDATE] SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable :...", 
"body" : "Parameters En esta sección se pueden definir todos los parámetros que deben estar disponibles para una parametrización en el Parámetros de la instancia del módulo. SEC Parameters \/\/optional: yes, modifier: [UPDATE]\n SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: yes, type: InstancePath\n VariableType := <data type> \/\/optional: yes, type: @JG???IEC-Typ\n Name := <parameter name>; \/\/optional: no, type: text\n Desc := <parameter description>; \/\/optional: no, type: text\n Group := <parameter group name> \/\/optional: yes, type: text\n MustBeSet := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n Default := <default value>; \/\/optional: yes, type: LiteralOrConstant\n Max := <max value>; \/\/Optional: yes, type: LiteralOrConstant\n Min := <min value>; \/\/Optional: yes, type: LiteralOrConstant\n END_SEC\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . Especificación: El objetivo de la sección Param debe identificar el parámetro de forma única. La definición Variable es una ruta de instancia de entrada relativa al bloque de funciones del módulo. Esta variable almacenará el valor del parámetro, su tipo define el tipo de parámetro. Si Variable se declara, el parámetro VariableType no es necesario definirlo y se ignorará. El parámetro VariableType define el tipo IEC de la variable. Si VariableType se declara pero no se proporciona ninguna variable FB real existente en el Variable definición, la Default La definición debe existir. Este valor debe coincidir con el VariableType . Los parametros Name y Desc son cadenas y deben definirse en una lista de texto. Los parámetros del módulo pueden ser tipos y enumeraciones básicos, pero no instancias de estructuras y matrices. Las variables de parámetros deben tener Valores de inicialización , que se definen en la declaración del bloque de funciones. El parámetro opcional Default permite sobrescribir el valor de inicialización. Para la expresión de inicialización y para el valor predeterminado se permiten literales y constantes del tipo correcto. Esto incluye los parámetros de la biblioteca. El parámetro opcional Group permite dividir los parámetros en grupos. Luego, cada grupo se muestra como una pestaña separada en el editor de módulos en Parámetros . Con el parámetro opcional MustBeSet se puede obligar al usuario a establecer un parámetro en el editor de módulos. Si el parámetro no está configurado, aparece un mensaje de error. Las definiciones mín. y máx. permite establecer límites para el valor del parámetro. Una comprobación de estos límites sólo es posible para variables de tipo numérico o de tiempos. Todos los demás tipos de variables no están permitidos y producirán un error. Ejemplo SEC Parameters\n SEC Param : InParam1\n Variable := xIn1;\n VariableTyp := BOOL;\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC La variable xIn1 debe definirse en la parte de declaración del bloque de funciones: xIn1 : BOOL := FALSE ; " }, 
{ "title" : "Valores de inicialización ", 
"url" : "ac_module_fb_sec_parameters.html#UUID-1cddf7ea-faa7-0b82-e29a-04e9f27653b0_ac_module_fb_sec_parameters0", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: Parameters \/ Valores de inicialización ", 
"snippet" : "El valor de inicialización es el valor de una variable que se define en la inicialización. En variables simples del FB este valor siempre está en el lado derecho de la declaración de la variable: iVar : INT := 17 ; \/\/ Initialisierungswert: 17 En caso de definición de variables en estructuras la inic...", 
"body" : "El valor de inicialización es el valor de una variable que se define en la inicialización. En variables simples del FB este valor siempre está en el lado derecho de la declaración de la variable: iVar : INT := 17 ; \/\/ Initialisierungswert: 17 En caso de definición de variables en estructuras la inicialización de la estructura es esencial: TYPE s : STRUCT\n i1 : INT := 7 ;\n r1 : REAL := 5 ;\nEND_STRUCT END_TYPE Declaración en el módulo FB: structVar : s := (i1 := 2, r1 := 0.0) ; En este caso el valor de inicialización que define el valor de structVar.i1 es 2 (y no 7 ). En estructuras anidadas se deben tener en cuenta todas las inicializaciones en la ruta desde el módulo FB hasta la variable. La inicialización más externa de la variable determina el valor. " }, 
{ "title" : "Sección: Slots ", 
"url" : "ac_module_fb_sec_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: Slots ", 
"snippet" : "Slots Esta sección define la disponibilidad y el tipo de ranuras de los módulos en el árbol de módulos. Se pueden definir dos tipos diferentes de slots. Slot SEC Slots \/\/optional: yes, modifier: [UPDATE]] SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name...", 
"body" : "Slots Esta sección define la disponibilidad y el tipo de ranuras de los módulos en el árbol de módulos. Se pueden definir dos tipos diferentes de slots. Slot SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Role := <role name>; \/\/optional: no, type: text\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identigier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier> \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . Especificación: La sección Slot define una ranura que permite 0 conexiones o 1 conexión. El objetivo de la sección Slot debe identificar el parámetro de forma única. Como resultado, no debe haber dos ranuras diferentes (ya sea Slot o Slot_Multi ) que tienen el mismo objetivo. (Las mayúsculas\/minúsculas son irrelevantes). La definición Variable es una ruta de instancia de entrada relativa al bloque de funciones del módulo. La ruta de instancia puede hacer referencia en todos sus componentes únicamente a variables de entrada (en instancias de estructura también a variables locales). El tipo de variable direccionada debe ser una interfaz o un tipo de FB. Dos slots diferentes no deben utilizar la misma variable. Role define la descripción del rol de la ranura. Type define el tipo de ranura. El tipo de conexión puede tener los siguientes valores: SUBMODULE : Ranura para instancias de submódulo. REFERENCE : Ranura para instancias de submódulo referenciadas. DECOUPLED : Ranura para instancias de módulo \"desacopladas\". Ver también: Sección: Desacoplados Inst_Prefix es un prefijo que se utiliza para el nombre de la variable FB generada. Prefijo vacío ( Inst_Prefix := ; ) también es posible, pero puede crear conflictos con otros nombres de variables del bloque de funciones. Sólo puede especificarse para SUBMODULE tipo ranuras. Optional define si se permite dejar la ranura abierta o si se debe conectar. Default_Inst_Name se puede utilizar para definir un nombre predeterminado para las instancias de módulo que son hijos de esta ranura. Cada módulo que se agregue obtendrá este nombre de forma predeterminada utilizando la entrada de la lista de texto definida por \"Default_Inst_Name\". Se prefiere el nombre predeterminado de la ranura al de los metadatos del módulo. Pragmas contiene una lista de pragmas del compilador que se insertan antes de las instancias FB de los submódulos. Los pragmas solo se pueden utilizar para espacios administrados. RegularExpressionParameterId define un parámetro de tipo STRING\/WSTRING para esta ranura. El valor de este parámetro se interpreta como una expresión regular y debe coincidir con el nombre del submódulo insertado. las secciones Slot.Default_Allocation y Slot_Multi.Default_Allocation permite definir configuraciones predeterminadas para ranuras con números variables de elementos (Multi_Slots y Slots). Para Slots.Multi_Slot deben ser identificados por objetivos únicos, mientras que Slots.Slot no tiene target y solo puede tener uno Default_Allocation sección. La instancia se agregará dependiendo de su posición dentro de la sección. El nombre del módulo y el nombre de la instancia siguen la definición de Slot.DefaultModule y Slot.DefaultName . Si estas definiciones no están disponibles, la configuración de Default_Allocation.Module_Name y Default_Allocation.Instance_Name se utilizará. Se recomienda utilizar Default_Allocation.* para tragamonedas en lugar de DefaultModule y DefaultName que sólo existe por razones de compatibilidad. La configuración de la instancia del módulo predeterminado se puede definir en las subsecciones de Default_Allocation : Module_Name define el nombre del módulo del cual se creará una instancia automáticamente. Si el módulo proviene de una biblioteca, el nombre del módulo debe estar calificado con un espacio de nombres. El parámetro solo está permitido para ranuras de tipo SUBMODULE . No se permiten llamadas infinitas y crearán un mensaje de error (ejemplo: la declaración del módulo \"A\" contiene el módulo predeterminado \"B\"; la declaración del módulo \"B\" contiene el módulo predeterminado \"A\"). Instance_Name debe especificarse siempre que DefaultModule se especifica, y nunca de otra manera. Debe ser un identificador IEC válido que se utiliza como nombre de la instancia del módulo predeterminado. El nombre no debe comenzar ni terminar con un subrayado ( _ ). Los nombres predeterminados de todas las ranuras de una declaración deben ser únicos. (La distinción entre mayúsculas y minúsculas no hace ninguna diferencia). NotDeletable especifica si el módulo puede ser eliminado por el usuario. Si TRUE , entonces el módulo no se puede eliminar. Se muestra un mensaje de error. Si el parámetro es FALSE o se omite, entonces el módulo se puede eliminar. VisuEmbeddings : Si el Empty El parámetro está configurado en TRUE , luego se crea una lista vacía de visus incrustados para esta instancia de módulo. Si el valor es FALSE , luego se puede generar la lista deseada de visualizaciones integradas para la instancia del módulo a través de la lista de visualizaciones integradas deseadas en el Embedding subsección. Cada Embedding La sección debe definir el nombre. VisuName del visu incorporado deseado para este propósito y puede especificar propiedades adicionales como Target o LinkId de este visu incrustado. PageVisu : En esta sección se puede elegir el PageVisu de la instancia del módulo ( VisuName ). Además, se puede definir si esta visu crea una TopLevelTap . El parámetro TopLevelTap hay que darle los valores TRUE y FALSE . IOMappings : En la subsección Mapping Se pueden definir los canales de E\/S. Los objetivos de las secciones. Mapping describir el canal de E\/S de destino. El valor predeterminado se puede establecer en NoMapping o a un STExpression . Parameters : En la subsección Param el valor Value de cada parámetro que está definido en el objetivo de la sección se puede definir. Ranura_Multi Mediante el uso de la sección Slot_Multi Se puede crear una lista de subinstancias y referencias. SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot_Multi : <slot name> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Role := <name role>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Pragmas := <pragma list>; \/\/optional: yes, type: Pragmalist\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier>; \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC Especificaciones adicionales: Var_Count define la ruta de la instancia de entrada del bloque de funciones del módulo. Esta variable (de tipo Integer) guardará la información sobre la cantidad de instancias conectadas a la ranura. Cardinality Define el número mínimo y máximo de instancias. El Slot_Multi.Default_Allocation La sección se puede utilizar para definir asignaciones predeterminadas para espacios con un número variable de elementos. Deben identificarse mediante objetivos únicos. Las instancias se insertan en el orden de las secciones. Para el nombre del módulo y el nombre de la instancia, las especificaciones para Slot.DefaultModule o Slot.DefaultName aplicar. El número de asignaciones predeterminadas no debe exceder el dígito superior. La variable abordada por un Slot_Multi la sección debe ser de tipo POINTER TO <INTERFACE> . Cada variable de entrada de tipo entero puede ser direccionada por Var_Count sólo una vez. (Esto también incluye InstRef_Multi.Var_Count y VarArray.Var_Count ). Ejemplo SEC Slot\n SEC Slot_Multi : subs\n Variable := pSubs;\n Var_Count := uiArraySize;\n Role := TL.Role;\n Cardinality := [2 .. 17];\n Type := SUBMODULE;\n RegularExpressionParameterId := Param_RegEx_Ref;\n SEC Default_Allocation : def1\n Module_Name := Sub1;\n Instance_Name := Submodule;\n END_SEC\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC Entre otras declaraciones, la parte de declaración del bloque de funciones debe contener: uiArraySize: UINT; pSubs: POINTER TO ITestModule . En el ejemplo, se define una ranura que contiene al menos 2, pero como máximo 17 subinstancias. Se creará una matriz para las subinstancias y pSubs lo señala. Al agregar la instancia el submódulo con nombre Submodule de tipo Sub1 se agregará automáticamente a la ranura. " }, 
{ "title" : "Sección: SourceTemplate ", 
"url" : "ac_module_fb_sec_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: SourceTemplate ", 
"snippet" : "SourceTemplate Las subsecciones de la sección SourceTemplate define los bloques de funciones que se copiarán en el proyecto. En el editor de módulos se enumeran los bloques de funciones aquí definidos. Allí podrás activar o desactivar la copia. Ver también Plantilla de origen SEC std.SourceTemplate ...", 
"body" : "SourceTemplate Las subsecciones de la sección SourceTemplate define los bloques de funciones que se copiarán en el proyecto. En el editor de módulos se enumeran los bloques de funciones aquí definidos. Allí podrás activar o desactivar la copia. Ver también Plantilla de origen SEC std.SourceTemplate\n SEC SourceFB : <Identifier> \/\/ optional: no\n SourceType := <FunctionBlock>; \/\/ optional: no, type: InstancePath\n Variable := <variable name>; \/\/ optional: no, type: InstancePath\n Default := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n IsMandatory := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n FBVariable := <variable name>; \/\/ optional: yes, type: InstancePath\n DestinationType := <default name>; \/\/ optional: yes, Type: String\/Literal\n END_SEC\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . Especificación: El Identifier se utiliza en el editor de módulos. Define el nombre del bloque de funciones copiado si DestinationType no está definido. SourceType define el bloque de funciones que se va a copiar. Variable define una variable de entrada del bloque de funciones del módulo. Debe ser un puntero a una clase básica de la función copiada o una interfaz, que es implementada por el bloque de funciones que se va a copiar. Default define si el bloque de funciones se copia de forma predeterminada para este módulo. Si falta la definición, TRUE Está establecido. Esta opción se puede ajustar en el editor de módulos. Si IsMandatory se establece en TRUE , el usuario no puede cambiar el IsToCopy opción en el editor de módulos. FBVariable define una variable de entrada del bloque de funciones que se va a copiar. Luego se crea una instancia de la variable de entrada con la instancia del módulo. El tipo de entrada es un puntero a un tipo básico del módulo FB o un puntero a la interfaz del módulo FB. DestinationType define un nombre estándar para el bloque de funciones copiado. Si falta la definición, se utiliza la siguiente convención de nomenclatura: <Nombre de the instancia de módulo>_<Identificador>[_<número consecutivo>]. Las SourceTemplates especificadas se copian en el AC_SourceTemplate carpeta. Son instanciados e inicializados por el módulo FB asignado. SourceTemplates, una vez creadas, se pueden editar y no se sobrescribirán con nuevas ejecuciones del generador. Se cambia el nombre de SourceTemplates, que ya no son necesarios (con el <_unused > sufijo) y se movió al <UnusedSourceTemplates> carpeta. Ejemplo SEC std.SourceTemplate\n SEC SourceFB : ID_ConnectSwitches\n SourceType := ConnectSwitches;\n Variable := itfConnect;\n FBVariable := pBuilding;\n Default := TRUE;\n IsMandatory := FALSE;\n DestinationType := 'TypeInModuleDescription';\n END_SEC\nEND_SEC " }, 
{ "title" : "Sección: Visu ", 
"url" : "ac_module_fb_sec_visu.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: Visu ", 
"snippet" : "Visu SEC Visu \/\/optional: yes, modifier: [UPDATE] Toplevel_Tab; \/\/optional: yes, type: bool Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: Vis...", 
"body" : "Visu SEC Visu \/\/optional: yes, modifier: [UPDATE]\n Toplevel_Tab; \/\/optional: yes, type: bool\n Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: VisuList\n\n SEC DefaultEmbeddings \/\/optional: yes\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier: [HIDE, UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: literal\n Target := <target name>; \/\/optional: yes, type: literal\n ProxyVisuName := <visu name>; \/\/optional: yes, type: literal\n LinkId := <linkID>; \/\/optional: yes, type: literal\n END_SEC\n END_SEC\n\n SEC Toplevel_Tab_Hotkey \/\/optional: yes\n Hotkey := <keycode>; \/\/optional: no, type: literal\n Modifiers := <modifier>; \/\/optional: yes, modifier: [SHIFT, CONTROL, ALT]\n END_SEC\n\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . Especificación: Toplevel_Tab define si la casilla de verificación Crear pestaña de nivel superior en el editor HMI está activado o desactivado por defecto. Page define una lista de objetos de visualización disponibles para el módulo. Embedded define una lista de objetos de visualización disponibles del submódulo que se integrarán en otras pantallas de visualización. Usando el marcador de posición %PAGE_VISU% en lugar del nombre de la visualización, permite que las pantallas de visualización generadas se puedan incrustar opcionalmente en otras pantallas. Embedded_Proxy define una lista de objetos de visualización disponibles del módulo. La lista sólo se utiliza si un decoupled module se inserta en un decoupled slot y si no se crea debajo del controlador de su instancia de módulo padre (como proxy). Para módulos, que importan otro módulo, el marcador de posición %NONE% se puede utilizar en lugar del nombre de la visualización. Esto hace que las visualizaciones importadas queden ocultas. Este enfoque es posible para la lista de pantallas de visualización, así como para las pantallas de visualización (proxy) integradas. Sección: DefaultEmbeddings : Esta sección sirve para la especificación de incrustaciones predeterminadas, que luego aparecerán como una configuración previa en la IHM pestaña de un submódulo (similar a la sección \"Default_Allocation\", ver Sección: Tragamonedas ). Las incrustaciones predeterminadas deseadas se describen en las subsecciones Embedding . Requisito: El objeto de visualización especificado y el proxy deben estar disponibles en la lista de posibles incrustaciones para el módulo (ver arriba: Embedded y Embedded_Proxy ). Sección: Toplevel_Tab_Hotkey : Esta sección define una tecla de acceso rápido como configuración predeterminada para la página de nivel superior. Los atajos de teclado no deben usarse más de una vez. Esta configuración se puede ajustar en el editor de módulos en la IHM pestaña. Ejemplo SEC Visu\n Toplevel_Tab ;\n Page := [VISU_CNC_Machine_1, VISU_CNC_Machine_2];\n Embedded := [%PAGE_VISU%];\n SEC DefaultEmbeddings\n SEC Embedding : No1\n VisuName := SubModule_Emb;\n Target := '..\/..\/TopLevel_2';\n END_SEC\n SEC Embedding : No2\n VisuName := SubModule_Emb_2;\n \/\/ProxyVisuName := SubModule_Emb_1;\n Target := '';\/\/ leave empty for next ancestor\n END_SEC\n END_SEC\n SEC Toplevel_Tab_Hotkey\n Hotkey := T;\n Modifiers := SHIFT | CONTROL;\n END_SEC\nEND_SEC El nombre de visualización es el nombre del objeto de visualización respectivo (no distingue entre mayúsculas y minúsculas). El objeto de visualización debe estar en el mismo nivel jerárquico que el bloque de funciones del módulo. Reglas para la interfaz de objetos de visualización: Todos los objetos de visualización y los objetos de visualización incrustados pueden tener una variable VAR_IN_OUT con el nombre inst , que puede ser del tipo del bloque de funciones del módulo o de una clase base. El nombre de la variable no distingue entre mayúsculas y minúsculas. VAR_IN_OUT   inst : <MODULE_FB> ; END_VAR Como alternativa a la opción descrita aquí con VAR_IN_OUT, también se puede utilizar una variable VAR_INPUT. Esta variable debe cumplir con los siguientes requisitos: Nombre: inst Tipo: interfaz que implementa el bloque de funciones del módulo Los objetos de visualización incrustados pueden tener dos variables adicionales (los nombres de las variables no distinguen entre mayúsculas y minúsculas): VAR_INPUT paVisuFB : POINTER TO POINTER TO AC_Visu_Base ; iOwnFrameIndex : INT ; END_VAR Estas variables deben definirse juntas; no está permitido definir uno sin el otro. Estas dos variables brindan a las visualizaciones incrustadas la capacidad de cambiar el marco central en la visualización de nivel superior. paVisuFB es una matriz de punteros en AC_Visu_Base instances . Usar la variable de visualización global CURRENTCLIENTID para acceder a la instancia correcta del cliente actual. El cambio de trama se realiza mediante una acción ST de la forma: paVisuFB[CURRENTCLIENTID]^.uiFrameIdx := iOwnFrameIndex ; iOwnFrameIndex es el índice que tiene la imagen de visualización del propio módulo en este marco de nivel superior. (Si el propio módulo no define una imagen de visualización este índice es -1.) Aparte de las variables mencionadas anteriormente, no se permiten otras variables VAR_INPUT, VAR_OUTPUT o VAR_INOUT. los AC_Visu_Base las instancias proporcionan la función adicional GetModuleFrameIndex . Esta función devuelve el índice de la pantalla de visualización (si está presente) en la visualización de nivel superior para una instancia de módulo (consulte IModule en AC_Module_Base.library) . Con esta función, puede saltar a cualquier pantalla de visualización en el árbol de instancias del módulo. Para habilitar también la navegación dentro del código de un módulo, el entorno del módulo (ver IModule en AC_Module_Base.library ) posee un miembro, Environment.visus , que corresponde a lo mencionado paVisuFB puntero. Para poder utilizar la variable CURRENTCLIENTID , la biblioteca VisuGlobalClientManager (categoría \"Becario|Visu\") debe agregarse al proyecto. La primera visualización se utilizará como configuración predeterminada. " }, 
{ "title" : "Sección: Trend ", 
"url" : "ac_module_fb_sec_trend.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: Trend ", 
"snippet" : "Trend SEC tre.Trend \/\/optional: yes, modifier: [UPDATE] SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE] Task := <trend task> \/\/optional: yes, type: TimeLiteral CycleTime := <time value> \/\/optional: yes, type: TimeLiteral LimitType := <limit type> \/\/optional: yes, type...", 
"body" : "Trend SEC tre.Trend \/\/optional: yes, modifier: [UPDATE]\n SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE]\n Task := <trend task> \/\/optional: yes, type: TimeLiteral\n CycleTime := <time value> \/\/optional: yes, type: TimeLiteral\n LimitType := <limit type> \/\/optional: yes, type: FileLimitType\n LimitMaximum := <max bytes> \/\/optional: yes, type: Literal\n RecordCondition \/\/optional: yes, type: InstanceAccess\n SEC Visu \/\/optional: yes, modifier: [UPDATE]\n VisuPlaceholder \/\/optional: yes, type: StringLiteral\n VisuTemplate := <visu template> \/\/optional: yes, type: StringLiteral\n Target := <path module instance \/\/optional: yes, type: StringLiteral\n END_SEC\n END_SEC\n\n SEC TrendVariable : <variable identifier> \/\/optional: yes, modifier: [UPDATE]\n Variable := <variable name> \/\/optional: yes, type: InstanceAccess\n TrendRecording := <recording name> \/\/optional: no, type: : Id)\n Description := <tooltip> \/\/optional: yes, type: TextRef\n Color := <graph color> \/\/optional: yes, type: Literal\n GraphType := <graph type> \/\/optional: yes, type: GraphType\n LineWidth := <width> \/\/optional: yes, type: Literal\n LineStyle := <line style> \/\/optional: yes, type: LineStyle\n SEC Warning : MIN\/MAX \/\/optional: yes, modifier: [UPDATE]\n Limit := <limit value> \/\/optional: no, type: Literal\n Color := <limit color> \/\/optional: yes, type: Literal\n END_SEC\n END_SEC\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . Especificación: Task : Define la tarea para el registro de tendencia. Si no se define ninguna tarea, se utilizará la tarea creada automáticamente por visu trend. CycleTime : Tiempo de ciclo del registro de tendencia LimitType : Tipo de limitación de la tendencia registrada. LimitMaximum : Tamaño máximo del registro de tendencias en KB (solo con LimitType ==Límite de archivos). RecordCondition : Condición de grabación. La variable referenciada debe ser de tipo BOOL. VisuPlaceholder : marcador de posición, reemplazado por la visualización de tendencia generada. VisuTemplate : Plantilla para la visu a crear. La plantilla debe tener un marcador de posición. Trend_Placeholder . Puede contener controles con el siguiente identificador: TrendLegend -> tipo: Leyenda TrendTimeRangeSelector -> tipo: Selector de rango de tiempo TrendDateRangeSelector -> Tipo: Selector de intervalo de fechas Target : ruta relativa a la instancia del módulo, en la que se incrustará la visualización. Variable : Variable a registrar. TrendRecording : objeto TrendRecording al que pertenece la variable. Description : entrada de lista de texto, que se mostrará para la variable como información sobre herramientas. Color : Colores de la gráfica de la variable como código de color ARGB GraphType : Tipo de gráfico LineWithPoints : Líneas con puntos Cross : cruces StepWithPoints : Pasos con puntos Point : Puntos Lines : Líneas Step : Pasos LinesWithCrosses : Líneas con cruces \\\\ StepWithCrosses : Pasos con cruces LineWidth : Ancho de la línea dibujada. Rango de valores: 1 a 255. LineStyle : estilo de línea Solid : Sólido Dashed : punteado Dotted : Punteado DashDotted : Guión punteado DashDotDotted : Guión punto punto Warning : Esta subsección debe tener el destino MAX o MIN . Según el objetivo, el exceso o el defecto activarán la advertencia. Limit : Comienzo del rango crítico. Color : Color para el rango crítico como código de color ARGB Ejemplo SEC tre.Trend\n SEC TrendRecording : TrendSensor\n SEC Visu\n VisuPlaceholder := 'TrendPlaceholder_TrendSensor';\n VisuTemplate := 'AC_Trend.GenTrend_VisuTemplate';\n END_SEC\n CycleTime := t#5s;\n LimitType := Records;\n LimitMaximum := 452;\n END_SEC\n SEC TrendVariable : Value\n Variable := value;\n TrendRecording := TrendSensor;\n Color := 16#FF00FF00;\n SEC Warning : MIN\n Limit := -5;\n Color := 16#FF101020;\n END_SEC\n GraphType := LinesWithCrosses;\n LineWidth := 3;\n END_SEC\nEND_SEC " }, 
{ "title" : "Sección: Proxies ", 
"url" : "ac_module_fb_sec_proxies.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: Proxies ", 
"snippet" : "Proxies La sección Proxies define un bloque de funciones que implementa el proxy. Un proxy sirve para el intercambio de datos de módulos de diferente aplicación. La instancia del FB proxy representa la instancia del módulo en una aplicación remota. SEC Proxies \/\/optional: yes, modifier: [UPDATE] SEC...", 
"body" : "Proxies La sección Proxies define un bloque de funciones que implementa el proxy. Un proxy sirve para el intercambio de datos de módulos de diferente aplicación. La instancia del FB proxy representa la instancia del módulo en una aplicación remota. SEC Proxies \/\/optional: yes, modifier: [UPDATE]\n SEC Proxy : <identifier> \/\/optional: yes, modifier [UPDATE]\n FB := <FB name>; \/\/optional: no, type: QID\n SEC MirrorVar : <identifier> \/\/optional: yes, modifier [UPDATE])\n Variable := <variable name>; \/\/optional: no, type: VarPath\n END_SEC\n SEC ProxyParameter : <target> \/\/ optional: yes, modifier [UPDATE]\n Variable := <InstancePath>; \/\/ optional: no, type: VarPath\n END_SEC\n END_SEC\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . Especificación: El bloque de funciones debe derivar de IBaseInstance . El bloque de funciones debe tener un método. SetProxyIdentification con la siguiente firma, que no está incluida en la Interfaz IBaseInstance : SetProxyIdentification(pbyName : POINTER TO BYTE, udiComAddr : UDINT, udiLocalComAddr : UDINT, pEnvironment : MEnv) El nombre de instancia pasado y la dirección establecida deben devolverse desde las propiedades InstanceName , ComAddress , y LocalComAddress . El bloque de función no debe derivar de IModule . La sección MirrorVar permite reflejar una variable de las instancias de un módulo en sus instancias de proxy. Para esto, la ruta de instancia de la variable debe declararse en la definición. Variable , que debe indicarse en forma de ruta relativa (al FB de la instancia del módulo). Las siguientes reglas se aplican a la variable especificada del FB de instancia del módulo: La variable tiene que ser parte de los Vars, Entradas o Salidas del FB de la instancia del módulo. Debe estar definido tanto en el FB de módulo como en el FB de proxy Debe ser del mismo tipo en ambos FB Debe tener un tipo primitivo; por lo tanto, no se permiten punteros, interfaces o estructuras como un todo para la duplicación, sino solo tipos simples (numéricos, STRING, TIME, etc.) Si las variables especificadas cumplen estas condiciones, se transfieren automáticamente como parte del RMP sin que el usuario tenga que preocuparse más por la transferencia. La sección ProxyParameter permite definir el parámetro para el proxy. Se deben tener en cuenta los siguientes puntos: el objetivo de la ProxyParameter debe corresponder a un objetivo de parámetro del módulo los variable del módulo proxy debe coincidir con el tipo de la variable utilizada para el parámetro del módulo. Solo se permiten enumeraciones y tipos primitivos Los parámetros del proxy se establecen una vez en el valor configurado en la instancia del módulo durante la fase de inicialización de la aplicación respectiva. Mientras se ejecuta la aplicación, estas variables no se reflejan en los proxies El nombre del bloque de funciones se puede calificar con una ruta de espacio de nombres. Ejemplo SEC Proxies\n SEC Proxy ProxyFB1\n FB := ProxyModule1;\n SEC MirrorVar : diInput\n Variable := diInput;\n END_SEC\n SEC ProxyParameter : InParam1\n Variable := TL.Input1_Name;\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Sección: VarArrays ", 
"url" : "ac_module_fb_sec_vararray.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: VarArrays ", 
"snippet" : "VarArrays El parámetro VarArrays permite crear matrices con tamaño configurable. SEC VarArrays \/\/optional: yes, modifier: [UPDATE]] SEC VarArray : <slot identifier> \/\/optional: yes, modifier [] Variable := <variable name>; \/\/optional: no, type: InstancePath Var_Count := <variable count>; \/\/optional:...", 
"body" : "VarArrays El parámetro VarArrays permite crear matrices con tamaño configurable. SEC VarArrays \/\/optional: yes, modifier: [UPDATE]]\n SEC VarArray : <slot identifier> \/\/optional: yes, modifier []\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable count>; \/\/optional: no, type: InstancePath\n Inst_Name := <instance name>; \/\/optional: yes, type: StringLiteral\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Var_Decl_Flags := <Flag1> | <Flag2> | ... ; \/\/optional: yes, type: Flags\n END_SEC\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . Especificación: La definición Variable es una ruta de instancia de entrada relativa al bloque de funciones del módulo. El tipo de datos es POINTER TO <ELEMTYPE> . <ELEMTYPE> puede ser cualquier tipo de datos. El objetivo de una sección VarArray debe identificar la matriz de variables de forma única. Var_Count define la ruta de la instancia de entrada de un entero Variable del bloque de funciones del módulo. Para estar disponible en el editor para la configuración, esta variable debe definirse como un parámetro. Alternativamente la variable Var_Count de Slot_Multi o InstRef_Multi se puede utilizar para definir esta variable. Múltiples VarArrays pueden usar el mismo Var_Count variable. Si el tamaño de la matriz es 0, no se generará ninguna matriz y el puntero de la matriz se establecerá en 0. Inst_Name define el nombre de la variable de matriz creada. El marcador de posición %Instancename% y %VariablePath% (la ortografía en mayúsculas o minúsculas no es relevante) será reemplazada por el nombre de la instancia del módulo resp. la ruta de instancia de la variable de puntero. Los puntos serán reemplazados por subrayados. Si se omite la definición, el valor predeterminado AC_ARRAY_%VariablePath% . se usa Se creará un error si dos VarArrays diferentes de un módulo tienen el mismo Inst_Name , que no incluye el marcador de posición %VariablePath% . Pragmas contiene una lista de pragmas del compilador, que se insertarán antes de la variable de matriz generada. Var_Decl_Flags se puede utilizar para especificar el tipo de variable de la matriz creada. Las posibles banderas son NONE , RETAIN , y PERSISTENT . Estas banderas se agregan a la sección de variables. VAR_INPUT , en el que se crea la matriz. (ejemplo: para la bandera RETAIN , VAR_INPUT RETAIN ). Ejemplo SEC VAR_ARRAYS\n SEC VAR_ARRAY : NameList\n Variable := psNameList;\n Var_Count := uiArraySize;\n END_SEC\n ...\n SEC PARAM : ArraySize\n Variable := uiArraySize;\n Name := TL.ArraySize_Name;\n Desc := TL.ArraySize_Desc;\n END_SEC\nEND_SEC Entre otras declaraciones, la parte de declaración del bloque de funciones debe contener: uiArraySize: UINT := 7; psNameList: POINTER TO STRING; . " }, 
{ "title" : "Sección: Constraints ", 
"url" : "ac_module_fb_sec_constraints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: Constraints ", 
"snippet" : "Constraints Esta sección especial permite verificar si cada instancia del módulo se referencia al menos una vez. SEC Constraints \/\/optional: yes, modifier: [UPDATE] Referenced_By := <interface name>; \/\/optional: yes, type: QID) Referenced_Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type...", 
"body" : "Constraints Esta sección especial permite verificar si cada instancia del módulo se referencia al menos una vez. SEC Constraints \/\/optional: yes, modifier: [UPDATE]\n Referenced_By := <interface name>; \/\/optional: yes, type: QID)\n Referenced_Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . Especificación: El parámetro Referenced_By sirve para verificar si las instancias del módulo están referenciadas desde otras instancias del módulo. El valor de ReferencedBy debe ser una interfaz que se deriva de IModule . Si no importa de qué tipo es la instancia de referencia, IModule se puede especificar aquí. Referenced_Cardinality define la frecuencia con la que se debe hacer referencia a este módulo. Si el número de referencias no está en este rango, se produce un error en el escaneo del generador estándar. Ejemplo SEC Constraints\n Referenced_By := ISpecificModule;\n Referenced_Cardinality := [1 .. 3];\nEND_SEC " }, 
{ "title" : "Sección: InstRefs ", 
"url" : "ac_module_fb_sec_instrefs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: InstRefs ", 
"snippet" : "InstRefs La sección InstRefs define referencias a instancias de FB o instancias de estructura. SEC InstRefs \/\/optional: yes, modifier: [UPDATE] SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: no, type: InstancePath Desc := <des...", 
"body" : "InstRefs La sección InstRefs define referencias a instancias de FB o instancias de estructura. SEC InstRefs \/\/optional: yes, modifier: [UPDATE]\n SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n...\n SEC InstRef_Multi : <identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n END_SEC\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . Especificación: Inst_Ref.Variable define la ruta de la instancia de entrada de una variable de tipo POINTER TO <T> o de tipo <interface> . ( <T> es cualquier estructura o tipo de FB) InstRef_Multi.Variable define la ruta de instancia de entrada de tipo POINTER TO POINTER TO <T> o de tipo POINTER TO <interface> . ( <T> es cualquier estructura o tipo de FB) Dos entradas InstRef o InstRef-Multi diferentes no deben usar la misma variable. El destino debe identificar de forma exclusiva la referencia de la instancia. Esto significa que no deben existir dos declaraciones de referencia de instancia diferentes (sección InstRef y InstRef_Multi ) con el mismo objetivo (la ortografía en mayúsculas o minúsculas no es relevante). La variable entera de entrada definida por Var_Count solo se puede usar una vez en todo VarCounts de Slot_Multi o InstRef_Multi . Solo variables enteras definidas por Var_Count de VarArray se puede usar en paralelo Var_Counts de Slot_Multi o InstRef_Multi . Ejemplo SEC InstRef_Multi : Elements\n Variable := piElems ;\n Var_Count := uiArraySize ;\n Desc := TL.Elems_Desc ;\n Cardinality := [1 .. 10] ;\nEND_SEC Entre otras declaraciones, la parte de declaración del bloque de funciones debe contener: uiArraySize : UINT; piElems : POINTER TO Interface; piElems apunta a un creado globalmente, correctamente inicializado ARRAY[0..uiArraySize-1] OF interface o OF POINTER TO <T> , que apunta a las instancias individuales. Como resultado, se puede acceder al i-ésimo objeto por medio de piElems[i] . " }, 
{ "title" : "Sección: mse.Sequence ", 
"url" : "ac_module_fb_sec_sequence.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: mse.Sequence ", 
"snippet" : "mse.Sequence Esta sección determina las definiciones del editor de secuencias. La sección debe estar presente en la declaración del módulo, para que el editor de módulos ofrezca la pestaña adicional Editor de secuencias . SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE] Root := TRUE\/FALSE; \/\/opt...", 
"body" : "mse.Sequence Esta sección determina las definiciones del editor de secuencias. La sección debe estar presente en la declaración del módulo, para que el editor de módulos ofrezca la pestaña adicional Editor de secuencias . SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE]\n Root := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Step := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Parallel := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Branch := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n VisibleParams := [<visparam1>, <visparam2>,...]; \/\/optional: yes, type: ID-list\n VisibleIOs := [<visIO1>, <visIO2>,...]; \/\/optional: yes, type: ID-list\n VisibleRefs := [<visref1>, <visref2>,...]; \/\/optional: yes, type: ID-list\n AConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n BConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n OnlineActiveVar := <xActive>; \/\/optional: yes, type: ID\n OnlineBreakpointVar := <xBreakpoint>; \/\/optional: yes, type: ID\n OnlineBreakpointActiveVar := <xAvtiveBreakpoint>; \/\/optional: yes, type: ID\n OnlineWatchVars := [<variable1>, <variable2>,...]; \/\/optional: yes\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . Especificación: Sólo una de las definiciones. Root , Step , Parallel , o Branch se puede establecer en TRUE para un módulo. Según esta definición, el módulo se representa en el editor de secuencias como uno de los siguientes elementos de secuencia: Raíz: Si la sucesión se define como Root , el editor de la instancia del módulo proporciona la pestaña adicional Editor de secuencias . Para todas las demás secuencias no se muestra ningún editor de secuencias. El ancho de la caja se puede cambiar en las opciones. Paso: Este elemento es similar al Root elemento, pero no habilita la pestaña adicional Editor de secuencias . El cuadro se utiliza para mostrar y ajustar ciertas propiedades del módulo, que se definen en su mse.Sequence sección. Paralela: Se muestra una secuencia paralela con un círculo debajo del cuadro. El cuadro se utiliza para mostrar y ajustar ciertas propiedades del módulo, que se definen en su mse.Sequence sección. Rama: Un cuadrado inclinado debajo del cuadro indica una rama. El cuadro se utiliza para mostrar y ajustar ciertas propiedades del módulo, que se definen en su mse.Sequence sección. VisibleParams define los parámetros que están disponibles en el cuadro de elementos de secuencia. VisibleIOs define las E\/S que están disponibles en el cuadro de elementos de secuencia. VisibleRefs define las referencias que están disponibles en el cuadro de elementos de secuencia. AConnectionColor : Las líneas de conexión entre las instancias del módulo de la ranura asignada se dibujan en el color de la Una conexión . Esto se puede configurar en las opciones del editor de secuencias. BConnectionColor : Las líneas de conexión entre las instancias del módulo de la ranura asignada se dibujan en el color de la conexión B . Esto se puede configurar en las opciones del editor de secuencias. OnlineActiveVar : A este parámetro se le puede asignar una variable booleana, que debe declararse en el bloque de funciones apropiado o en uno de sus bloques de funciones básicos. En el modo en línea, si la variable se establece en TRUE , el paso de la secuencia se muestra en amarillo. OnlineBreakpointVar : A este parámetro se le puede asignar una variable booleana, que debe declararse en el bloque de función correspondiente o en uno de sus bloques de función básicos. En modo en línea el comando Punto de interrupción de palanca desde el menú contextual establece o restablece un punto de interrupción. Además, establece la variable asignada a TRUE o FALSE Si está configurado para TRUE , el paso en el editor de secuencias se muestra con un borde rojo. OnlineBreakpointActiveVar : A este parámetro se le puede asignar una variable booleana, que debe declararse en el bloque de función correspondiente o en uno de sus bloques de función básicos. En el modo en línea, si la variable se establece en TRUE , el paso de la secuencia se muestra en rojo. OnlineWatchVars : Todas las variables (con tipo de datos simple) que se definen en VAR_INPUT , VAR_OUTPUT , VAR , o VAR_IN_OUT del FB (o sus FB base) se pueden utilizar aquí como variables. Tipos de variables complejas (de la forma FBInst.xVariable etc.) no se puede utilizar. Las variables deben ingresarse en una lista separada por comas. Ejemplo SEC mse.Sequence\n Branch;\n VisibleIOs := [xIn];\n AConnectionColor := [itfSequenceTrue];\n BConnectionColor := [itfSequenceFalse];\n OnlineActiveVar := xActive;\n OnlineBreakpointVar := xBreakpoint;\n OnlineBreakpointActiveVar := xBreakpointActive;\n OnlineWatchVars := [iPartTimeElapsed];\nEND_SEC " }, 
{ "title" : "Sección: Decoupled ", 
"url" : "ac_module_fb_sec_decoupled.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: Decoupled ", 
"snippet" : "Decoupled Esta sección define \"módulos desacoplados\". Estos son módulos con las propiedades de los módulos de nivel superior, pero también se pueden insertar como submódulos en ranuras específicas ( Type:= DECOUPLED ) de otros módulos. Los módulos no pueden ser \"de nivel superior\" y \"desacoplados\" a...", 
"body" : "Decoupled Esta sección define \"módulos desacoplados\". Estos son módulos con las propiedades de los módulos de nivel superior, pero también se pueden insertar como submódulos en ranuras específicas ( Type:= DECOUPLED ) de otros módulos. Los módulos no pueden ser \"de nivel superior\" y \"desacoplados\" al mismo tiempo. Los \"módulos desacoplados\" se generan utilizando la sección Decoupled en la declaración del módulo. La sección Decoupled es casi idéntica a la sección Toplevel ; sin embargo, sólo se permite una de estas secciones en una declaración de módulo. SEC Decoupled \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Toplevel_Insertable := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/optional: no, type: Text)\n Flags:= <flag>; \/\/optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en el capítulo sobre la declaración del módulo. Especificación: La especificación de la sección. Decoupled Corresponde a la descripción de la sección. Toplevel . Además, se pueden definir los siguientes parámetros: Toplevel_Insertable define si un \"submódulo desacoplado\" también se puede insertar en el nivel superior como un módulo de nivel superior. Nota: Un \"módulo desacoplado\" debe definir e implementar un proxy respectivo. El proxy debe implementar la misma interfaz que el \"módulo desacoplado\". Si la instancia del módulo principal se encuentra bajo otro controlador como instancia del módulo \"desacoplado\", entonces la instancia del módulo \"desacoplado\" aún se puede insertar en esta ranura a través de su proxy. Ver también Declaración del módulo Sección: Nivel superior " }, 
{ "title" : "Sección MacroModule ", 
"url" : "ac_module_fb_sec_macromodule.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección MacroModule ", 
"snippet" : "MacroModule La sección describe los parámetros para el MacroModule. La sección se crea automáticamente cuando genera un módulo macro. Como alternativa, puede insertar la sección en una declaración de módulo manualmente o editar una sección generada automáticamente. SEC MacroModule \/\/optional: yes, m...", 
"body" : "MacroModule La sección describe los parámetros para el MacroModule. La sección se crea automáticamente cuando genera un módulo macro. Como alternativa, puede insertar la sección en una declaración de módulo manualmente o editar una sección generada automáticamente. SEC MacroModule \/\/optional: yes, modifier: None\n SEC Rootmodule : <identifier> \/\/optional: no, modifier: None\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: no, type: text\n New_Desc := <parameter description>; \/\/optional: no, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO ID>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n SEC VisuEmbeddings \/\/optional: yes, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID>; \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <linke ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTab := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: no, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection>; \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters : <identifier> \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value ID>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Submodule : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: yes, type: text\n New_Desc := <parameter description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO Id>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n Instance_Name := <instance name>; \/\/optional: no, type: ID\n SEC VisuEmbeddings \/\/optional: no, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID> \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID> \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTap := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: yes, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression> \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection> \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Reference : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n Referenced_Instance := <instance ID>; \/\/optional: no, type: ID\n END_SEC\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . Especificación: MacroModule : si se define esta sección, no se permite que aparezca ninguna otra sección dentro de la declaración del módulo completo excepto la sección MetaData . Cada declaración de módulo con esta sección se identifica claramente como tipo MacroModule. otra seccion MacroModule no está permitido dentro de una declaración de módulo. Rootmodule : Indica que las siguientes subsecciones describen el submódulo raíz, que debe ser 1) la raíz de este tipo de MacroMódulo y 2) insertado como el padre superior de todos los demás submódulos del tipo MacroMódulo. Submodule : Indica que las siguientes subsecciones describen un submódulo, que debe insertarse debajo del submódulo raíz en un subárbol para el tipo MacroModule. MacroParameter : Si este tipo de subsección se usa en una sección Submodule o Root , entonces se puede indicar que un parámetro específico del submódulo definido (o raíz) debe ocurrir en sí mismo como un parámetro del módulo macro. Para ello, el objetivo de la sección MacroParameter se utiliza como un nuevo ID de parámetro para el parámetro del módulo macro. El parámetro del submódulo dado (o raíz) se define entonces por Local_ParameterID . Además, las entradas de la lista de texto se pueden crear utilizando las definiciones de New_Name y New_Desc . Estas entradas se utilizan para el nombre y la descripción del nuevo parámetro del módulo macro en lugar del submódulo o parámetro raíz. Todos los objetivos definidos de todas las secciones. MacroParameter dentro de un módulo de macro completo debe estar claro para garantizar ID de parámetros únicos para todos los parámetros del módulo de macro. MacroIO : Si este tipo de subsección se utiliza en la sección Submodule o Root , entonces se puede indicar que una E\/S específica del submódulo definido (o raíz) debe ocurrir en sí misma como una E\/S del módulo macro. Para ello, el objetivo de la sección MacroIO se utiliza como una nueva ID de E\/S para la E\/S del módulo macro. La E\/S del submódulo dado (o raíz) se define entonces por Local_IOID . Además, las entradas de la lista de texto se pueden crear usando las definiciones de New_Name y New_Desc . Estas entradas se utilizan para el nombre y la descripción de la nueva E\/S del módulo macro en lugar del submódulo o la E\/S raíz. Todos los objetivos definidos de todas las secciones. MacroIO dentro de un módulo de macro completo debe estar claro para garantizar ID de E\/S únicos para todas las E\/S del módulo de macro. MacroSlot : Si esta subsección se utiliza en la sección Submodule o Root , entonces se puede indicar que una ranura específica del submódulo definido (o raíz) debería aparecer como una ranura del módulo macro. De esta forma, se pueden insertar instancias de módulos adicionales debajo de esta ranura de la instancia de MacroModule. El objetivo de la sección MacroSlot luego se usa como un nuevo ID de ranura para la ranura de MacroModule. La ranura del submódulo dado (o raíz) se define entonces por Local_SlotID . Además, se puede crear una entrada de lista de texto usando las definiciones New_Role . Esta entrada se utiliza para la función de la nueva ranura del módulo macro en lugar de la del submódulo o la ranura raíz. Todos los objetivos definidos de todas las secciones. MacroSlot dentro de un MacroModule completo debe estar claro para garantizar ID de ranura únicas para todas las ranuras de MacroModule. Parent_Instance : Define un ID correspondiente a un ID objetivo de una sección Rootmodule o Submodule de la sección envolvente MacroModule . Esta definición existe sólo dentro de la sección Submodule . Define la instancia del módulo principal debajo de la cual se debe insertar el submódulo. Este submódulo se describe en la sección respectiva Submodule del MacroMódulo. Además, la definición Parent_Slot también se requiere. Parent_Slot : Define una ID correspondiente a la ID de la ranura ubicada debajo del tipo de submódulo identificado por Parent_Module . El submódulo del tipo MacroModule descrito en la sección Submodule se inserta debajo de esta ranura. Default_Allocation : Esto es idéntico a la sección del mismo nombre bajo las declaraciones de ranuras ( Slot y Slot_Multi ). Esta sección define tanto para el \"módulo raíz\" como para el \"submódulo\" qué tipo de submódulo del tipo MacroModule debe insertarse para qué configuración de instancia. La única diferencia es que no Instance_Name se puede definir para Default_Allocation bajo una sección Rootmodule , sino en secciones Submodule . La razón de esto es que las instancias de módulo insertadas como \"módulo raíz\" reciben su nombre de la instancia de MacroModule y, por lo tanto, no se pueden ingresar de manera \"predeterminada\". Reference : Muestra que las siguientes subsecciones describen una referencia de módulo. Se genera una referencia debajo de la instancia del módulo. Parent_Instance y la ranura Parent_Slot , haciendo referencia al submódulo Referenced_Instance . como el Parent_Instance , esta instancia a la que se hace referencia debe originarse en el conjunto del submódulo de instancias del módulo raíz debajo de la misma sección MacroModule . La declaración de módulo de un tipo MacroModule debe cumplir las siguientes condiciones: no se usará IMPLEMENTED_BY o IMPORTS en su declaración de módulo. Debe incluir la sección MetaData y MacroModule . De lo contrario, no se deben utilizar secciones adicionales. Al menos una sección Rootmodule debe estar disponible debajo de la sección MacroModule Además, una segunda sección Rootmodule no puede existir Para cada submodule , ambos Parent_Instance y el Parent_Slot debe definirse dentro MacroModule . Esto debe definirse entonces como Local_SlotID dentro de MacroSlot de El Parent_Instance . " }, 
{ "title" : "Sección: DeviceGenerator ", 
"url" : "ac_module_fb_sec_devicegenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: DeviceGenerator ", 
"snippet" : "DeviceGenerator La sección DeviceGenerator sirve para definir todos los ajustes relacionados con el generador de dispositivos. Contiene las siguientes subsecciones: Subsección Device : Definiciones para agregar dispositivos al árbol de dispositivos Subsección Parameter : Definiciones para agregar o ...", 
"body" : "DeviceGenerator La sección DeviceGenerator sirve para definir todos los ajustes relacionados con el generador de dispositivos. Contiene las siguientes subsecciones: Subsección Device : Definiciones para agregar dispositivos al árbol de dispositivos Subsección Parameter : Definiciones para agregar o cambiar parámetros del dispositivo Subsección Conexión: Definiciones para conectar las E\/S del módulo a las E\/S del dispositivo Subsección Wildcards : Definiciones para crear dispositivos \"comodín\" Subsección Demand : Definiciones para especificar propiedades de “demanda” Subsección InstRefMapping : Definición para conectar dispositivos creados con InstRefs del módulo Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . " }, 
{ "title" : "Subsección: Device ", 
"url" : "ac_module_fb_sec_devicegenerator_device.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: DeviceGenerator \/ Subsección: Device ", 
"snippet" : "los Device La subsección define los dispositivos que agregará el generador de dispositivos. Hay varios tipos de dispositivos generados que se definen con las diferentes subsecciones Identification , Wildcard , y FlexibleWildcard . Sintaxis: SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC...", 
"body" : "los Device La subsección define los dispositivos que agregará el generador de dispositivos. Hay varios tipos de dispositivos generados que se definen con las diferentes subsecciones Identification , Wildcard , y FlexibleWildcard . Sintaxis: SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Device : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n ParentSlotIndex := <slot number>; \/\/optional: yes, type: literal\/integer\n SEC Identification \/\/optional: yes, modifier: [UPDATE]\n Type := <type number>; \/\/optional: no, type: literal\/string\n ID := <ID mumber>; \/\/optional: no, type: literal\/string\n ModuleID := <module ID>; \/\/optional: yes, type: literal\/string\n Version := <version mumber>; \/\/optional: no, type: literal\/string\n SEC SetChildName \/\/optional: yes, modifier: [UPDATE]\n Value := <child name>; \/\/optional: no, type: literal\/string\n ChildIndex := <index number>; \/\/optional: no, type: literal\/string\n END_SEC\n END_SEC\n END_SEC\n SEC ExportDevice \/\/optional: yes, modifier: [UPDATE, HIDE]\n Files :=[<filename1>, <filename2>, ...]; \/\/optional: no, type: string\n END_SEC\nEND_SEC Especificación: los Device La sección tiene una identificación de destino que la identifica de manera única entre los otros dispositivos generados de un módulo. Este ID se puede utilizar para hacer referencia a este dispositivo. Esto se hace principalmente en la definición. Parent de otros dispositivos creados o E\/S conectadas. los Parent La definición especifica el dispositivo principal deseado bajo el cual se montará el dispositivo creado. El dispositivo principal no se puede identificar en absoluto (la definición es opcional), por su ID o por un parámetro. En detalle, el dispositivo principal se determina de la siguiente manera: Si no Parent se define en absoluto, siempre se utiliza el primer padre coincidente disponible, y para un vacío Parent la definición solo busca a partir del primer módulo principal. Si no se define ningún dispositivo en el propio módulo principal directo, se realiza un seguimiento del historial de los módulos principales hasta que finalmente haya un dispositivo que coincida o se alcance el módulo de nivel superior. En este caso, se utiliza su dispositivo de aplicación si es posible. Si, además, se especifica un ID de dispositivo o un parámetro como Parent , el historial de los dispositivos principales se escanea de la misma manera, por lo que ahora también se tienen en cuenta los dispositivos del propio módulo de salida y un posible dispositivo principal también debe tener la ID correspondiente. Si según las reglas descritas anteriormente no se puede encontrar ningún posible dispositivo principal, se genera un error durante la verificación de generación. ParentSlotIndex : Especifica el índice de la ranura (número de ranura) del dispositivo principal en el que se insertará el dispositivo. Esto es útil cuando se requiere enchufar. la subsección Identifikation incluye la descripción única de un dispositivo que se agregará. Esto crea una clara referencia a este tipo. Device fabricado. Las definiciones Type , ID , ModuleID , y Version de El Identification sección identificar de forma única un tipo de dispositivo de una versión específica. Por ejemplo, un EtherCAT Master tiene la siguiente definición: Type := '64'; ID := '000 0001'; Version := '3.5.1.0'; Si * se define como la versión, siempre se utiliza la última versión del dispositivo. Si el ModuleID no se utiliza la definición, se buscan dispositivos con DeviceIdentification en el sistema; de lo contrario, se buscan dispositivos con una identificación de módulo. Si el dispositivo definido no existe en el repositorio de dispositivos, ya se emite un mensaje de error correspondiente durante el proceso de exploración. Subsección SetChildName con las definiciones Value y ChildIndex Estas opciones le permiten especificar el nombre que debe tener un dispositivo insertado automáticamente. Si se utiliza el mismo nombre más de una vez, el nombre resultante se vuelve único añadiendo un guión bajo y un número. Value : Nombre deseado del dispositivo ChildIndex : Índice del dispositivo insertado automáticamente al que se le cambiará el nombre Esta sección ofrece la posibilidad de llenar los campos con la ayuda del Input Assistant. Para hacer esto, coloque el cursor al final de la línea después de Identification y presiona Regreso . Posteriormente, Input Assistant se abre y ofrece los canales disponibles. Después de elegir un dispositivo, los parámetros correspondientes se transfieren a la declaración del módulo. Tenga en cuenta que esta función solo está disponible cuando el final de la subsección ( END_SEC ) aún no se ha introducido. La definición archivos contiene una lista de dispositivos que se agregarán al proyecto. Estos dispositivos se configuraron y exportaron manualmente a una biblioteca. Ejemplo SEC Device : Buskoppler2\n SEC Identification\n Type := '65';\n ID := '2_044C2C5200110000';\n Version := '*';\n END_SEC\nEND_SEC\nSEC Device : KlemmeDigitalOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\n SEC ExportDevices\n Files := [ExtFile.BK5120_1SDO, ExtFile.BK5120_2SDO];\n END_SEC\nEND_SEC Ejemplo con parámetros SEC std.DeviceGenerator\n SEC Device : CANopen_Manager\n Parent := CurrentCAN;\n SEC FlexibleIdentification\n Type := '16';\n ID := '181016';\n Version := '*';\n Maximum := 1;\n END_SEC\n END_SEC\nEND_SEC\nSEC std.Parameters\n SEC Param : CurrentCAN\n Name := TL.CurrentCAN_Name;\n Desc := TL.CurrentCAN_Desc;\n VariableType := wSTRING;\n Default := 'CANBus_0';\n END_SEC\nEND_SEC Ejemplo de configuración de un nombre de dispositivo SEC std.DeviceGenerator\n\tSEC Device : EcoVario\n\t Parent := CanManager;\n\t\tSEC Identification\n\t\t Type := '18';\n\t\t ID := '1619 0001';\n\t\t Version := '*';\n\t\t SEC SetChildName : ChildDevice\n\t\t\t Value := 'ChildName';\n\t\t\t ChildIndex := 0;\n\t\t END_SEC\n\t END_SEC\n END_SEC\n SEC Parameters : EcoVario\n\t SEC AddParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t ParameterName := 'BoolParam';\n\t \tParameterType := 'std:BOOL';\n\t\t ChildIndex := 0;\n\t END_SEC\n\t SEC SetParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t\tElemPath := '';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\t\tSEC SetParameter : bVirtual\n\t\t\tParameterID := '1040';\n\t\t\tElemPath := '';\n\t\t\tConnectorID := '0';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\tEND_SEC\n SEC InstRefMapping : Axis\n\t SEC Demand\n\t Desc := TL.DescAxis;\n\t\t\tProperties := [SM_DRIVE_CAN];\n\t\tEND_SEC\n\tEND_SEC\nEND_SEC\n " }, 
{ "title" : "Subsección: Connect ", 
"url" : "ac_module_fb_sec_devicegenerator_connect.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: DeviceGenerator \/ Subsección: Connect ", 
"snippet" : "Esta subsección de la sección IOMapping Sirve para conectar módulos de E\/S con dispositivos de E\/S especificados. Este mapeo se realiza sin conocer la estructura IO exacta del dispositivo. Para conexiones directas, se supone que el módulo IO y el dispositivo IO especificado son compatibles SEC Devic...", 
"body" : "Esta subsección de la sección IOMapping Sirve para conectar módulos de E\/S con dispositivos de E\/S especificados. Este mapeo se realiza sin conocer la estructura IO exacta del dispositivo. Para conexiones directas, se supone que el módulo IO y el dispositivo IO especificado son compatibles SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC IOMapping : <mapping identifier> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Connect \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n END_SEC\n END_SEC\nEND_SEC Especificación: La sección IO tiene un destino que corresponde al ID de destino del módulo IO que se conectará. Se buscará este ID de destino en el módulo que contiene la conexión de dispositivo especificada. Si no se encuentra ninguna E\/S de módulo coincidente, se emite un mensaje de error durante la exploración. La definición opcional Parent proporciona el ID del dispositivo que se buscará para el dispositivo IO especificado (ID de parámetro). Hasta que se encuentre, el módulo del dispositivo y el historial de los dispositivos principales se buscarán consecutivamente. Si no se encuentra un dispositivo apropiado, se emite un mensaje de error durante la verificación de generación. La sección Connect contiene todas las definiciones necesarias para conectar un módulo IO a un dispositivo IO. ParameterID define el canal IO ParameterID del dispositivo al que se conectará. Se intenta encontrar este parámetro en los dispositivos especificados por el propio módulo. Si no se especifica ningún dispositivo, se intenta encontrar el parámetro en el siguiente dispositivo principal posible. Luego, el parámetro se conecta a la E\/S del módulo. Si ninguno de los dispositivos generados en la jerarquía del módulo ofrece el parámetro especificado con este ParameterID , se emite un error. ElemPath define el subelemento del parámetro del dispositivo (canal de E\/S) que se conectará al módulo de E\/S. También es posible especificar rutas, etc. El parámetro ConnectorID define opcionalmente el conector del dispositivo, cuyo HostParameterSet contiene la ParameterID . Si no ConnectorID se especifica, el ParameterID se busca bajo el DeviceParameterSet . Esta sección ofrece la posibilidad de llenar los campos con la ayuda del Input Assistant. Para hacer esto, coloque el cursor al final de la línea después de Connect y presiona Regreso . Posteriormente, Input Assistant se abre y ofrece los canales disponibles. Después de elegir un canal, los parámetros correspondientes se transfieren a la declaración del módulo. Tenga en cuenta que esta función solo está disponible cuando el final de la subsección ( END_SEC ) aún no se ha introducido. Ejemplo SEC IOMapping: xIn\n SEC Connect\n ParameterID := '33554434';\n ElemPath := '';\n ConnectorID := '1';\n END_SEC\nEND_SEC " }, 
{ "title" : "Subsección: Demand ", 
"url" : "ac_module_fb_sec_devicegenerator_demand.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: DeviceGenerator \/ Subsección: Demand ", 
"snippet" : "Esta subsección de IOMapping permite que las E\/S del módulo especifiquen propiedades (ejemplo: 24 V y no 230 V), que deben ofrecer las E\/S del dispositivo para una conexión adecuada. Las propiedades solicitadas se pueden asignar como propiedades de \"oferta\" a los dispositivos IO durante la generació...", 
"body" : "Esta subsección de IOMapping permite que las E\/S del módulo especifiquen propiedades (ejemplo: 24 V y no 230 V), que deben ofrecer las E\/S del dispositivo para una conexión adecuada. Las propiedades solicitadas se pueden asignar como propiedades de \"oferta\" a los dispositivos IO durante la generación. La asignación se almacena adjunta al archivo de descripción del dispositivo. Para la conexión automática de E\/S del generador de dispositivos, esto significa que cada módulo de E\/S con propiedades \"demandantes\" escaneará los dispositivos generados o los comodines de sus módulos principales hasta que se encuentre un dispositivo y un canal de E\/S cuyas propiedades de \"oferta\" cumplan con las demandas SEC IOMapping : <target> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n Properties := [<property1>,<property2>,...]; \/\/optional: no, type: IDList\n END_SEC\nEND_SEC Especificación: las subsecciones Demand y Connect no se pueden definir simultáneamente. Desc define una descripción (localizada) de la conexión requerida (en una lista de texto). Properties define una lista de propiedades que describen las propiedades requeridas por el módulo IO (ejemplo: [Input24V, Digital]) Es posible definir varias propiedades que permiten calificar el módulo IO (ejemplo: módulo IO que requiere solo \"Propiedad1\" y módulo IOs que requirieron \"Property1\", \"Property2\", etc.). Parent define el Id del dispositivo bajo el cual se debe conectar el canal. Para E\/S \"exigentes\", también se permiten dispositivos comodín como posibles dispositivos de conexión. SEC std.DeviceGenerator\n SEC IOMapping : xOn\n SEC Demand\n Desc := TL_Rooms.Role_RoomStandard_Lights;\n Properties := [V24Output];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Subsección: Wildcards ", 
"url" : "ac_module_fb_sec_devicegenerator_wildcard.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: DeviceGenerator \/ Subsección: Wildcards ", 
"snippet" : "los Wildcard La subsección se utiliza para crear dispositivos comodín para módulos que aún no se conocen cuando se crea el módulo. Los dispositivos deben ser flexibles para ser especificados por el usuario antes o durante la generación. SEC Device : <target> \/\/optional: yes, modifier [UPDATE] Parent...", 
"body" : "los Wildcard La subsección se utiliza para crear dispositivos comodín para módulos que aún no se conocen cuando se crea el módulo. Los dispositivos deben ser flexibles para ser especificados por el usuario antes o durante la generación. SEC Device : <target> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Wildcard : <target> \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n END_SEC\nEND_SEC Especificación: los Identification , Wildcard , y FlexibleWildcard las subsecciones no se pueden usar al mismo tiempo. El objetivo de la sección Wildcard determina el tipo del dispositivo comodín. Diferentes módulos pueden usar dispositivos comodín del mismo tipo (ejemplo: \"8 entradas\"). Todos los dispositivos comodín del mismo tipo se asignan al mismo dispositivo. Desc define una descripción (localizada) del dispositivo comodín (en una lista de texto). Parent define el dispositivo principal deseado. Los dispositivos comodín también son posibles aquí, siempre que ya estén asignados a dispositivos. Si el dispositivo establecido para el dispositivo comodín no es un dispositivo principal compatible, se emite un error durante la generación. Ejemplo SEC Device : KlemmeAnalogOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\nEND_SEC " }, 
{ "title" : "Subsección: Parameter ", 
"url" : "ac_module_fb_sec_devicegenerator_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: DeviceGenerator \/ Subsección: Parameter ", 
"snippet" : "La sección Parameter con las subsecciones SetParameter y AddParameter sirve para agregar o modificar parámetros de dispositivos. Esto permite generar configuraciones específicas de dispositivos (ejemplo: tiempo de ciclo). SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC Parameters : <para...", 
"body" : "La sección Parameter con las subsecciones SetParameter y AddParameter sirve para agregar o modificar parámetros de dispositivos. Esto permite generar configuraciones específicas de dispositivos (ejemplo: tiempo de ciclo). SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Parameters : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n SEC SetParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n Value := <value name>; \/\/optional: no, type: literal\/string\n ChildIndex := <device ID>;\n Download := <boolean value> \/\/ opional: yes, type: boolean\n END_SEC\n SEC AddParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ParameterName := <parameter name>; \/\/optional: no, type: literal\/string\n ParameterType := <parameter type>; \/\/optional: no, type: literal\/string\n ChannelType := <channel type>; \/\/optional: yes, type: enum\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n ChildIndex := <device ID>;\n END_SEC\n END_SEC\nEND_SEC Especificación: La sección Parameters tiene un objetivo con el que DeviceID del dispositivo de destino cuyos parámetros se van a editar. El dispositivo de destino se busca primero en los dispositivos propios del módulo y luego en su historial principal. El destino también pueden ser dispositivos comodín u otros dispositivos, suponiendo que tengan los parámetros correspondientes y que se les puedan agregar los parámetros correspondientes. Si no se puede encontrar el objetivo, se emite una advertencia durante las comprobaciones de generación. Los objetivos de las secciones SetParameter y AddParameter define el Id de la sección respectiva pero no tiene más uso. Especificación para la sección SetParameter : ParameterID define el ParameterID del parámetro del dispositivo que será modificado. ElemPath especifica el elemento exacto del parámetro que se cambiará. El parámetro ConnectorID define opcionalmente el conector del dispositivo, cuyo HostParemeterSet contiene el parámetro Id. Si no ConnectorID se especifica, el ParameterID se busca en DeviceParameterSet. Value define el valor que se le asignará al elemento del parámetro especificado. Este valor debe ser compatible con el tipo de elemento. El valor puede ser una expresión, por ejemplo. [paramID] + 2*MODULE_SLOT_INDEX Ahí [paramID] define un ID objetivo de un parámetro, de modo que [paramID] será reemplazado por el valor del parámetro. los MODULE_SLOT_INDEX La palabra clave se reemplaza por el índice de ranura que tendría una instancia de módulo del tipo de módulo definido después de la inserción. Si el parámetro no se puede encontrar en el dispositivo de destino, la verificación del generador generará advertencias. ChildIndex define el dispositivo secundario bajo el cual se agrega o establece el parámetro. Si este dispositivo subordinado con el índice específico no existe, se genera una advertencia mientras el generador está en ejecución. Download : Entrada opcional. Si esta entrada tiene el valor FALSE el parámetro no se descarga en el dispositivo. Esto es por ejemplo para desactivar CheckVendorId Útil para dispositivos CAN. Especificación para la sección AddParameter : ParameterID define el nuevo ID del parámetro que se agregará. Debe ser único entre los demás ID de parámetro del dispositivo de destino. El parámetro ConnectorID define opcionalmente el conector del dispositivo, cuyo HostParemeterSet contiene el Id del parámetro que se agregará. Si no se define ningún ID de conector, el ID de parámetro se agregará en DeviceParameterSet. ParameterName define el nombre del parámetro agregado al dispositivo de destino. ParameterType define el tipo de parámetro agregado al dispositivo de destino. Este tipo se nombra de acuerdo con la notación de tipo IEC con prefijo de tipo. Por lo tanto ejemplo: std:bool creará un parámetro booleano. Si no se puede agregar el parámetro, la verificación del generador generará advertencias. ChannelType define el tipo de canal. Los valores posibles son NONE , INPUT , OUTPUT , y OUTPUTREADONLY . ChildIndex define el dispositivo secundario bajo el cual se agrega o establece el parámetro. Si este dispositivo subordinado con el índice específico no existe, se genera una advertencia mientras el generador está en ejecución. Ambas secciones AddParameter y SetParameter se pueden usar juntos para agregar un parámetro a un dispositivo y asignarle un valor al mismo tiempo. Ejemplo SEC Parameters : Buskoppler1\n SEC AddParameter : ExpertSettings\n ParameterID := '805306368';\n ConnectorID := '1';\n ParameterName := 'ExpertSettings';\n ParameterType := 'std:int';\n ChannelType := OUTPUT;\n END_SEC\n SEC SetParameter : ExpertSettings\n ParameterID := '805306368';\n ElemPath := '';\n ConnectorID := '1';\n Value := dwParameterOffset + 2 * MODULE_SLOT_INDEX;\n END_SEC\n END_SEC " }, 
{ "title" : "Subsección: InstRefMapping ", 
"url" : "ac_module_fb_sec_devicegenerator_instrefmapping.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: DeviceGenerator \/ Subsección: InstRefMapping ", 
"snippet" : "En la sección InstRefMapping con la subsección Demand un módulo InstRef se puede llenar automáticamente con una instancia de FB creada por un dispositivo. SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE] Parent := <target ID>...", 
"body" : "En la sección InstRefMapping con la subsección Demand un módulo InstRef se puede llenar automáticamente con una instancia de FB creada por un dispositivo. SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <...>; \/\/optional: no, type: text\n Properties := <...>; \/\/optional: no, type: IDList\n END_SEC\n END_SEC\nEND_SEC Especificación: la sección superior InstRefMapping se complementa con una sección opcional adicional Demand . El objetivo de la sección superior InstRefMapping define el ID de un módulo InstRef, que se llenará con la instancia de FB. Solo se admiten InstRefs individuales (no InstRef_Multi), ya que solo se pueden crear instancias de FB individuales de dispositivos individuales. Desc define una descripción localizada de la conexión. Properties define una lista de propiedades que describen, por ejemplo, los tipos de FB requeridos por el módulo InstRef. Se puede definir más que en la propiedad para que los InstRefs de un solo módulo se clasifiquen como módulos IO. Sintaxis [<Property1>, <Property2>,...] (ejemplo: [SoftMotionVirtualDrive, Property2] ). Parent define la ID del dispositivo requerido, cuya instancia de FB creada se utilizará para llenar el módulo InstRefs. Para los dispositivos comodín InstRefs exigentes, así como los dispositivos fijos insertados, están permitidos. Ejemplo SEC std.InstRefs\n SEC InstRef : axisRef\n Variable := axis_ref;\n Desc := TL.axisref_Desc ;\n END_SEC\nEND_SEC\n\nSEC std.DeviceGenerator\n SEC Device : virtAxis\n SEC Identification\n Type := '1024';\n ID := 'FFFF 0001';\n Version := '*';\n END_SEC\n END_SEC\n SEC InstRefMapping : axisRef\n SEC Demand\n Desc := TL.axisref_Desc;\n Properties := [VirtualAxis];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Reglas para generadores ", 
"url" : "ac_module_fb_sec_devicegenerator_generating_rules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Sección: DeviceGenerator \/ Reglas para generadores ", 
"snippet" : "Reglas de generación de dispositivos Los dispositivos especificados en los módulos de nivel superior se montan debajo del dispositivo principal que contiene la aplicación generada. No se crean dispositivos de nivel superior. Si no se especifica ningún ID de dispositivo principal, el dispositivo prin...", 
"body" : "Reglas de generación de dispositivos Los dispositivos especificados en los módulos de nivel superior se montan debajo del dispositivo principal que contiene la aplicación generada. No se crean dispositivos de nivel superior. Si no se especifica ningún ID de dispositivo principal, el dispositivo principal coincidente más joven se utiliza como nuevo objeto principal. Cuando un módulo secundario crea un dispositivo, se crea en el dispositivo del módulo principal, si es posible. Si el módulo principal directo no tiene ningún dispositivo o no crea un dispositivo que quepa debajo del dispositivo secundario, se utilizan los dispositivos del módulo principal-principal, etc. Si no hay más dispositivos principales creados, se intenta ingresar al nivel superior Generar el dispositivo del módulo de nivel superior respectivo. Si un objeto de módulo principal ofrece varios dispositivos, se utiliza el primer dispositivo bajo el cual encaja el dispositivo que se va a crear. Ver también Subsección: DeviceEl nombre del dispositivo generado es \"ID del dispositivo + nombre del módulo + dispositivo\". Si este nombre ya es utilizado por un dispositivo, se agregará un número ascendente. Los dispositivos ya creados no serán eliminados por una ejecución de nueva generación; por lo tanto, se mantendrán los ajustes manuales de la configuración. Los parámetros adicionales o modificados creados por la declaración del módulo se asignarán a los dispositivos correspondientes con cada ejecución de generación. Como todos los objetos creados por Application Composer, los dispositivos adicionales se marcarán en el árbol de dispositivos. Si se intenta modificar o eliminar dicho dispositivo, se mostrará una advertencia. Esta advertencia llama la atención sobre el hecho de que cualquier cambio realizado en la configuración del dispositivo puede perderse si, por ejemplo, la estructura del módulo se regenera después de haber sido modificada. Reglas adicionales de generación de dispositivos Los dispositivos secundarios, que se agregan automáticamente en ciertos dispositivos, se clasifican en la misma instancia de módulo que su principal. Eso significa que esos dispositivos secundarios se tratan como si estuvieran definidos en la declaración del módulo, que, de hecho, contiene la definición de su dispositivo principal. Los dispositivos secundarios no se crean ni eliminan de forma independiente, sino que solo se tratan junto con sus dispositivos principales. Si un dispositivo tiene un conector explícito, será tratado como si fuera un conector implícito durante la verificación de compatibilidad con otro dispositivo. Esto significa que todos los conectores (explícitos e implícitos) se consideran primero para conectarse a dispositivos y luego se utiliza el conector que encaja para la conexión. Ya sea implícitamente, bajo el objeto del dispositivo o explícitamente, como su propio objeto principal. " }, 
{ "title" : "Generador de alarmas ", 
"url" : "ac_alarmgenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Generador de alarmas ", 
"snippet" : "El generador de alarmas proporciona al desarrollador del módulo una manera fácil de equipar los módulos existentes con la gestión de alarmas disponible en CODESYS . Al hacerlo, se generan funcionalidades para la gestión completa de alarmas, así como la visualización correspondiente. Esta característ...", 
"body" : "El generador de alarmas proporciona al desarrollador del módulo una manera fácil de equipar los módulos existentes con la gestión de alarmas disponible en CODESYS . Al hacerlo, se generan funcionalidades para la gestión completa de alarmas, así como la visualización correspondiente. Esta característica se implementa a través de la nueva declaración del módulo. alg.Alarm. Contiene todas las definiciones necesarias para la gestión de alarmas. Crear la visualización Junto con la generación de alarmas, se crea una pantalla de visualización de alarmas, que es una sugerencia para una visualización general (tabla de alarmas) de las alarmas en el proyecto. La plantilla para esta visualización se establece en la configuración del generador de alarmas. Si el generador de visualización está activo, el objeto de visualización creado o reutilizado se integra como una pestaña en la visualización de nivel superior. " }, 
{ "title" : "Generación de alarmas ", 
"url" : "ac_alarmgenerator.html#UUID-dd47c9b0-4cb3-6491-d721-bbb6aed14278_a4ecc0cda058afc0a8640e004fda36_id_4e1d8099cdf16f9cc0a8640e0073d212", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Generador de alarmas \/ Generación de alarmas ", 
"snippet" : "Como todos los generadores del CODESYS Application Composer , este generador se puede activar o desactivar en el Configuración del generador . El generador realiza los siguientes pasos: Se busca un objeto de configuración de alarma, para que pueda ser utilizado para la próxima generación. Si no exis...", 
"body" : "Como todos los generadores del CODESYS Application Composer , este generador se puede activar o desactivar en el Configuración del generador . El generador realiza los siguientes pasos: Se busca un objeto de configuración de alarma, para que pueda ser utilizado para la próxima generación. Si no existe ningún objeto de configuración de alarma, se crea uno nuevo. Bajo el objeto de configuración de alarma, se busca un objeto de almacenamiento de alarma. Si no existe ningún objeto de almacenamiento de alarmas, se utiliza la plantilla de almacenamiento de alarmas. Esta plantilla se define en la configuración del generador de alarmas. Si la opción Sin almacenamiento se selecciona, no se utiliza ninguna plantilla de almacenamiento de alarmas y el proceso continúa sin almacenamiento de alarmas. Si se encuentra más de una plantilla, se muestra un mensaje de error. Bajo el objeto de configuración de alarma se buscan objetos de clase de alarma que tengan el nombre definido en cualquier descripción de módulo bajo la definición alg.Alarm.SetAlarm.Class . Si se encuentran los objetos de clase de alarma correspondientes, se utilizarán. Si no se encuentra la clase de alarma correspondiente, se intenta crear una nueva. Esto requiere que el objeto de plantilla de clase de alarma del nombre correspondiente exista como plantilla en el grupo de POU del proyecto o en una biblioteca referenciada, para que pueda usarse como plantilla de clase de alarma. Si no hay ningún objeto de plantilla de clase de alarma coincidente disponible, se muestra un error. " }, 
{ "title" : "Sección: alg.Alarma ", 
"url" : "ac_module_fb_sec_alarm.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Generador de alarmas \/ Sección: alg.Alarma ", 
"snippet" : "alg.Alarm La sección SEC alg.Alarm describe una alarma de módulo. Una alarma de módulo corresponde esencialmente a una alarma del CODESYS gestión de alarmas que se ha configurado en un grupo de alarmas. Sin embargo, una alarma de módulo aún contiene adiciones específicas del módulo. Para más informa...", 
"body" : "alg.Alarm La sección SEC alg.Alarm describe una alarma de módulo. Una alarma de módulo corresponde esencialmente a una alarma del CODESYS gestión de alarmas que se ha configurado en un grupo de alarmas. Sin embargo, una alarma de módulo aún contiene adiciones específicas del módulo. Para más información ver capítulo Sintaxis de declaración de módulo y Objeto: grupo de alarmas " }, 
{ "title" : "Especificación ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_355d83fb191b4801c0a864637767cb78", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Generador de alarmas \/ Sección: alg.Alarma \/ Especificación ", 
"snippet" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE] SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE] Class := <class name>; \/\/optional: no, type: ID Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath Latc...", 
"body" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE]\n SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE]\n Class := <class name>; \/\/optional: no, type: ID\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath\n LatchVar2 := <LatchVariable2>; \/\/optional: yes, type: InstancePath\n Deactivation := <DeactivationVariable>; \/\/optional: yes, type: InstancePath\n PendingTime := <PendingTime>; \/\/optional: yes, type: LiteralOrConstant\n PendingTimeParameter := <string> \/\/optional: no, type: literal\/string\n HigherPrioAlarm := <HigherPrioAlarm_ID>; \/\/optional: yes, type: ID\n ModuleCalls := <ModuleCallFlags>; \/\/optional: yes, type: ModuleCallFlag\n SEC Messages : <alarm identifier> \/\/optional: yes, modifier: [UPDATE]\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n Number := <ColumnNumber>; \/\/optional: no, type: Literal\n END_SEC\n SEC LatchVar <latch var identifier> \/\/optional: yes, modifier [UPDATE]\n LatchVar := <LatchVariable>; \/\/optional: no, type: InstancePath\n Number := <LatchVarNumber> \/\/optional: no, type: LiteralOrConstant\n END_SEC\n SEC UpperLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n UpperExpression := <UpperExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC LowerLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n LowerExpression := <LowerExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC InsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC OutsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC Digital \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n Equal := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n EqualsExpression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Change \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Event \/\/optional: yes, modifier: [UPDATE]\n END_SEC\n END_SEC\nEND_SEC SEC SetAlarm Las subsecciones de SetAlarm definir todas las propiedades que son necesarias o posibles para una alarma. el objetivo de SetAlarm identifica la alarma de las otras alarmas en el módulo y se utiliza para hacer referencia a ella (principalmente en la definición HigherPrioAlarm ). Class Nombre de clase de alarma, bajo el cual se creará la alarma. Si esta clase de alarma ya existe en la aplicación, la alarma se creará bajo esta clase. Si esta clase no existe, se busca un objeto de plantilla de clase de alarma, que debe estar presente en el POU vista. Si no se encuentra un objeto de plantilla de clase de alarma apropiado, se emite un error cuando se escanea el módulo. Message DNI (de la forma TextListenName.TextListenEintragID ) de una entrada de lista de texto para el texto de alarma El mensaje al que hace referencia el ID puede contener los mismos marcadores de posición que el texto en una configuración de alarma. Por ejemplo, marcadores de posición como LATCH1 o LATCH2 puede ser usado Si no se puede encontrar una entrada de lista de texto específica, se emite una advertencia durante la exploración. corresponde a la Mensaje ajuste en el Grupo de alarma objeto. LatchVar1 LatchVar2 Variables de marcador de posición En el presente caso de alarmas específicas del módulo, las variables solo se pueden especificar directamente desde el bloque de función del módulo (al igual que las variables se especifican en la declaración del módulo, por ejemplo, parámetros) Corresponde a la configuración Variable de bloqueo 1 \/ Variable de bloqueo 2 para marcadores de posición <LATCH1> \/ <LATCH2> en el Grupo de alarma objeto. Deactivation Variable de desactivación ( BOOL ). TRUE : Desactiva la alarma definida, donde solo se pueden usar las variables del bloque de funciones del módulo. Si el tipo de variable que se ingresa no es BOOL , luego se emite un error durante el escaneo corresponde a la Desactivación ajuste en el Grupo de alarma objeto. PendingTime Tiempo mínimo de espera. Define la cantidad de tiempo antes de que la alarma suene realmente después de alcanzar sus límites. Ejemplo: TIME#5S Corresponde al ajuste mín. tiempo pendiente en el Grupo de alarma objeto. PendingTimeParameter Parámetro para establecer el tiempo mínimo de espera. El valor asignado al parámetro es una cadena que puede interpretarse como tiempo. O como una expresión que consta de parámetros de módulo y literales de tiempo. Ejemplo: TIME#5S 'NoVar' 'WithVar' 'WithVar - NoVar + TIME#5S' HigherPrioAlarm ID de las alarmas de mayor prioridad Para identificar la alarma bajo la cual se debe clasificar la alarma actual, una ID de destino de un SetAlarm La sección se especifica para las alarmas del módulo existente. para encontrar el SetAlarm sección con el ID de destino correspondiente, se realiza una búsqueda jerárquica desde el propio módulo hacia arriba en las instancias del módulo principal para encontrar ID coincidentes entre las declaraciones de alarma. Si no se encuentra ninguna alarma principal correspondiente, se emite un error durante la verificación del generador Corresponde al ajuste Mayor prioridad. alarma en el Grupo de alarma objeto. ModuleCalls Para la gestión de alarmas específicas del módulo, los FB de módulo pueden ofrecer interfaces específicas a las que se puede llamar si se produce una alarma de módulo. Las banderas definen en qué casos sucederá esto. Disponible ModuleCallFlags : NONE : No se producirán llamadas THIS : Se producirá una llamada para las alarmas del módulo presente PARENTS : Se realizará una llamada a todos los módulos principales del módulo actual ALL : Se producirá una llamada a todos los módulos. Los FBs de módulo que serán llamados por esta bandera deben implementar el IModuleAlarming interfaz. La llamada es realizada por el ConsumeModuleAlarm función de esta interfaz Si el PARENTS se estableció un indicador para un módulo de nivel superior, se muestra una advertencia si se ejecuta un análisis (porque estos indicadores no existen para los módulos de nivel superior). SEC Messages La subsección gestiona la misma tarea que la Message parámetro, pero permite múltiples mensajes para una alarma. Por razones de compatibilidad, el parámetro (antiguo) Message aun es válido. El mensaje puede contener los mismos marcadores de posición que el texto real en una configuración de alarma. Esto significa que también los marcadores de posición como <LATCH1> y <LATCH2> puede ser usado. Si no se puede encontrar una entrada de lista de texto específica, se emite una advertencia durante la exploración. Messages : Texto de alarma en forma de una entrada de lista de texto (de la forma TextListenName.TextListenEintragID ) Number : Columna de la tabla de alarmas donde se muestra el mensaje. SEC LatchVar Fijar variables. En esta sección se pueden definir hasta 10 variables de latch. Si, además de esta sección, LatchVar1 o LatchVar2 se define, se utilizará la variable de esta sección. LatchVar : Variable de enganche Number : Número para identificar la variable latch. SEC UpperLimit SEC LowerLimit Condiciones de alarma para alarmas que se disparan si se cruzan los límites superior o inferior. Se permite que la sección ocurra solo una vez debajo de la SEC SetAlarm sección. Si este no es el caso, se emite un error durante el escaneo. Expression : expresión IEC o valor que se prueba. En las expresiones, se pueden utilizar variables locales de los FB del módulo, así como constantes globales. IncludeBorder : TRUE corresponde a <= ( UpperLimit ) o >= ( LowerLimit ). FALSE corresponde a < ( UpperLimit ) o > ( LowerLimit ). UpperExpresssion , LowerExpresssion : Expresión IEC o valor contra el cual se Expresión se prueba En las expresiones, se pueden utilizar variables locales de los FB del módulo, así como constantes globales. Hysteresis : Histéresis de alarma en %. Corresponde a la configuración Limite superior \/ Límite inferior para los tipos de observación en el Grupo de alarma objeto. SEC InsideRange SEC OutsideRange Condiciones de alarma para alarmas que se disparan si una expresión está dentro o fuera de un cierto rango de valores. Se permite que la sección ocurra solo una vez debajo de la SEC SetAlarm sección. Si este no es el caso, se emite un error durante el escaneo. Hysteresis : Histéresis de alarma en % Expression : expresión IEC o valor que se prueba. En las expresiones, se pueden utilizar variables locales de los FB del módulo, así como constantes globales. AreaLow : Límites inferiores del rango (valor o expresión IEC). En las expresiones, se pueden utilizar variables locales de los FB del módulo, así como constantes globales. LowIncludeBorder : Este indicador booleano determina si el propio límite inferior está incluido en el rango de comparación (corresponde a <= ) HighIncludeBorder : Este indicador booleano determina si el propio límite superior está incluido en el rango de comparación (corresponde a >= ) AreaHigh : Límites superiores del rango (valor o expresión IEC). En las expresiones, se pueden utilizar variables locales de los FB del módulo, así como constantes globales. Corresponde a la configuración Rango interior \/ Fuera de rango para los tipos de observación en el Grupo de alarma objeto. SEC Digital Alarma que salta si se comparan dos expresiones entre sí. Se permite que la sección ocurra solo una vez debajo de la SEC SetAlarm sección. Si este no es el caso, se emite un error durante el escaneo. Expression : expresión IEC o valor que se prueba. En las expresiones, se pueden utilizar variables locales de los FB del módulo, así como constantes globales. Equal : TRUE \/ FALSE : Se comprobará la expresión para igualdad\/desigualdad. EqualsExpression : Expresión o valor IEC que se compara con Expression . En las expresiones, se pueden utilizar variables locales de los FB del módulo, así como constantes globales. Corresponde al tipo de observación. Digital en el Grupo de alarma objeto. SEC Change Alarma que salta si una expresión cambia de valor. Se permite que la sección ocurra solo una vez debajo de la SEC SetAlarm sección. Si este no es el caso, se emite un error durante el escaneo. Expression : Expresión IEC o valor que se comprueba para cambios. En las expresiones, se pueden utilizar variables locales de los FB del módulo, así como constantes globales. Corresponde al tipo de observación. Cambiar en el Grupo de alarma objeto. SEC Event Determina que la sección de alarma actual crea una alarma de evento. Esta alarma puede ser disparada por la función RaiseModuleEvent() desde el AC_Alarming Biblioteca. " }, 
{ "title" : "Ejemplo ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_00a4549e191b4801c0a8646366566922", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Generador de alarmas \/ Sección: alg.Alarma \/ Ejemplo ", 
"snippet" : "Rango de valores SEC SetAlarm : ValueRange Class := Error; Message := TL.Alarm_Temperature; LatchVar1 := rAlarmValueLow; LatchVar2 := rAlarmValueHigh; ModuleCalls := THIS | PARENTS; SEC Messages : msg2 Message := TL.msg5_Message; Number := 5; END_SEC SEC OutsideRange Expression := 'rValue'; AreaLow ...", 
"body" : "Rango de valores SEC SetAlarm : ValueRange\n Class := Error;\n Message := TL.Alarm_Temperature;\n LatchVar1 := rAlarmValueLow;\n LatchVar2 := rAlarmValueHigh;\n ModuleCalls := THIS | PARENTS;\n SEC Messages : msg2\n Message := TL.msg5_Message;\n Number := 5;\n END_SEC\n SEC OutsideRange\n Expression := 'rValue';\n AreaLow := 'rAlarmValueLow';\n LowIncludeBorder := TRUE;\n HighIncludeBorder := TRUE;\n AreaHigh := 'rAlarmValueHigh';\n END_SEC\nEND_SEC sección PendingTime SEC alg.Alarm\n\tSEC SetAlarm : NoVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'NoVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : WithVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : SimpleMath\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar - NoVar + TIME#5S';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\t\n\tSEC SetAlarm : NoParam\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTime := TIME#5S;\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\nEND_SEC " }, 
{ "title" : "Generador CFC ", 
"url" : "ac_cfc_generator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Generador CFC ", 
"snippet" : "El generador CFC crea automáticamente programas CFC que pueden contener llamadas de instancias de FB de módulo. Los programas CFC creados se pueden editar. Los cambios de programa persisten después de varias ejecuciones del generador....", 
"body" : "El generador CFC crea automáticamente programas CFC que pueden contener llamadas de instancias de FB de módulo. Los programas CFC creados se pueden editar. Los cambios de programa persisten después de varias ejecuciones del generador. " }, 
{ "title" : "Sección: CFCCreation ", 
"url" : "ac_module_fb_sec_cfccreation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Generador CFC \/ Sección: CFCCreation ", 
"snippet" : "CFCCreación Esta sección contiene todas las subsecciones que son interpretadas por el generador CFC. SEC cfc.CFCCreation SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE] StandardCallTask := <Task type>; \/\/optional: yes, type: ID CustomCallTask := <Task type>; \/\/opti...", 
"body" : "CFCCreación Esta sección contiene todas las subsecciones que son interpretadas por el generador CFC. SEC cfc.CFCCreation\n\n SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE]\n StandardCallTask := <Task type>; \/\/optional: yes, type: ID\n CustomCallTask := <Task type>; \/\/optional: yes, type: ID\n ParentFolder := <create folder ID; \/\/optional: yes, type: ID\n END_SEC\n\n SEC CreateCFCModuleCall \/\/optional: yes, modifier [UPDATE]\n PreferredCFCProgram := <CFC program> \/\/optional: yes; type: FB type\n END_SEC\n\n SEC CreateCFCIOCall : <CFC IO call ID> \/\/ optional: yes; modifier [UPDATE]\n FB := <FB name>; \/\/ optional: no; type: FB type\n PreferredCFCProgram := <CFC program> \/\/ optional: yes; type: FB type\n FBInstanceBaseName := AInput; \/\/ optional: yes; type: identifier\n END_SEC\n\n SEC CreateFolder : <folder ID> \/\/optional: yes, modifier [UPDATE]\n ParentFolder := <folder name>; \/\/optional: yes, type: ID\n END_SEC\n\nEND_SEC Los detalles sobre la sintaxis de los tipos de definición se describen en la sección Declaración del módulo . " }, 
{ "title" : "Subsección: CreateCFCProgram ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_bddcc1eb1403f77cc0a8640e01907eda", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Generador CFC \/ Sección: CFCCreation \/ Subsección: CreateCFCProgram ", 
"snippet" : "Si una declaración de módulo contiene una sección cfc.CFCCreation incluyendo la subsección CreateCFCProgram , se creará un programa CFC para el tipo de módulo asignado. El programa CFC se insertará debajo de la aplicación de destino de la siguiente instancia del módulo principal desacoplado\/nivel su...", 
"body" : "Si una declaración de módulo contiene una sección cfc.CFCCreation incluyendo la subsección CreateCFCProgram , se creará un programa CFC para el tipo de módulo asignado. El programa CFC se insertará debajo de la aplicación de destino de la siguiente instancia del módulo principal desacoplado\/nivel superior superior. La definición CustomCallTask o StandardCallTask se puede utilizar para definir la tarea que llama al programa CFC que se va a crear. Especificación: El objetivo de la sección CreateCFCProgram identifica los programas CFC de este tipo de módulo. Básicamente, un tipo de módulo puede definir y crear varios programas CFC para su instancia de módulo. Una definición para StandardCallTask o CustomCallTask debe existir, pero sólo se permite una definición. Para StandardCallTask las tres identificaciones LOW , MEDIUM , y HIGH están disponibles para definir la tarea de la siguiente instancia superior del módulo principal\/desacoplado. Para CustomCallTask todos los ID de destino están disponibles y se utilizan en la tarea personalizada respectiva de la siguiente instancia superior del módulo principal\/desacoplado superior. En ParentFolder la identificación de destino de la CreateFolder Se puede ingresar la sección. Luego, el programa CFC creado se agrega en esta subsubcarpeta ( CreateFolder ). " }, 
{ "title" : "Subsección: CreateCFCModuleCall ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_4225fb301403f77dc0a8640e01bbc228", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Generador CFC \/ Sección: CFCCreation \/ Subsección: CreateCFCModuleCall ", 
"snippet" : "Si una declaración de módulo contiene una sección cfc.CFCCreation incluyendo la subsección CreateCFCProgram , se crea una llamada del FB de instancia de módulo para el tipo de módulo asignado en el programa CFC de la siguiente instancia de módulo principal superior. Especificación: PreferredCFCProgr...", 
"body" : "Si una declaración de módulo contiene una sección cfc.CFCCreation incluyendo la subsección CreateCFCProgram , se crea una llamada del FB de instancia de módulo para el tipo de módulo asignado en el programa CFC de la siguiente instancia de módulo principal superior. Especificación: PreferredCFCProgram define el programa CFC que se utilizará si hay varios programas disponibles. " }, 
{ "title" : "Subsección: CreateCFCIOCall ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_72ec1fc41403f77ec0a8640e00114156", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Generador CFC \/ Sección: CFCCreation \/ Subsección: CreateCFCIOCall ", 
"snippet" : "La sección se utiliza para marcar E\/S de un tipo de módulo o declaración de módulo. Para estas E\/S se crean instancias de FB de un tipo definido. Luego se crean llamadas de estas instancias de FB dentro del programa CFC. Especificación: el objetivo de la CreateCFCIOCall La sección define el ID de E\/...", 
"body" : "La sección se utiliza para marcar E\/S de un tipo de módulo o declaración de módulo. Para estas E\/S se crean instancias de FB de un tipo definido. Luego se crean llamadas de estas instancias de FB dentro del programa CFC. Especificación: el objetivo de la CreateCFCIOCall La sección define el ID de E\/S del módulo para el que se creará un FB de E\/S global. El FB de E\/S creado se llamará en un programa CFC. FB define el tipo de bloque de función que se instancia globalmente y se llama para el FB de E\/S mencionado anteriormente. PreferredCFCProgram define el programa CFC que se utilizará si hay varios programas disponibles. FBInstanceBaseName define un \"nombre base\" que se utiliza para nombrar los FB de E\/S creados. Si la definición no existe, se utiliza el nombre de la instancia del módulo para la instancia base. " }, 
{ "title" : "Subsección: CreateFolder ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_a2dd1e181403f77ec0a8640e013c4468", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Declaración del módulo \/ Generador CFC \/ Sección: CFCCreation \/ Subsección: CreateFolder ", 
"snippet" : "Esta sección contiene parámetros para crear subcarpetas debajo de la AC_CFC_Programs carpeta. En correspondencia con esto un ParentFolder se puede definir en el CreateCFCProgram sección. Los programas CFC se generan entonces en el directorio creado por el CreateFolder sección. Las carpetas en sí pue...", 
"body" : "Esta sección contiene parámetros para crear subcarpetas debajo de la AC_CFC_Programs carpeta. En correspondencia con esto un ParentFolder se puede definir en el CreateCFCProgram sección. Los programas CFC se generan entonces en el directorio creado por el CreateFolder sección. Las carpetas en sí pueden definir un ParentFolder para especificar más subcarpetas y subsubcarpetas. Especificación: En ParentFolder la identificación de destino de la CreateFolder Se puede ingresar la sección. Luego, el directorio creado se creará en esta subcarpeta ( CreateFolder ). Ejemplo SEC cfc.CFCCreation\n SEC CreateCFCProgram : Standard\n StandardCallTask := MEDIUM;\n ParentFolder := SubFolderUnderFolder;\n END_SEC\n SEC CreateFolder : SubFolderUnderFolder\n ParentFolder := SubFolder;\n END_SEC\nEND_SEC " }, 
{ "title" : "Biblioteca: AC_ModuleBase ", 
"url" : "ac_library.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase ", 
"snippet" : "La biblioteca básica de módulos AC_ModuleBase forma parte del concepto de módulos de la CODESYS Application Composer . Todos los módulos que se desarrollan para estar disponibles en el configurador de árbol de módulos deben derivarse de esta biblioteca básica. Navegación al nivel superior La función...", 
"body" : "La biblioteca básica de módulos AC_ModuleBase forma parte del concepto de módulos de la CODESYS Application Composer . Todos los módulos que se desarrollan para estar disponibles en el configurador de árbol de módulos deben derivarse de esta biblioteca básica. Navegación al nivel superior La función GetToplevelRange devuelve una instancia de rango (tipo SiblingRange ) que proporciona acceso a todas las instancias de nivel superior. La función GetToplevelInstance devuelve el módulo de nivel superior que es un ancestro de la instancia dada. " }, 
{ "title" : "Nombre de instancia ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f44958df1c1aa580c0a8640e00033aeb", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ Nombre de instancia ", 
"snippet" : "La propiedad InstanceName de la clase base devuelve una cadena que contiene el nombre de la instancia del módulo. Propiedad en IInstanceBase : PROPERTY InstanceName : STRING(255) Valor devuelto: nombre de instancia de la instancia del módulo Las instancias de proxy devuelven el nombre de instancia d...", 
"body" : "La propiedad InstanceName de la clase base devuelve una cadena que contiene el nombre de la instancia del módulo. Propiedad en IInstanceBase : PROPERTY InstanceName : STRING(255) Valor devuelto: nombre de instancia de la instancia del módulo Las instancias de proxy devuelven el nombre de instancia de la instancia del módulo remoto. " }, 
{ "title" : "información del módulo ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_a581c7b51c1aa580c0a8640e012cbe1e", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ información del módulo ", 
"snippet" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo : esta propiedad devuelve un puntero a un bloque de funciones ModuleInfo con el método PROPERTY ModuleType : STRING(255) . PROPERTY ModuleType : STRING(255) : esta propiedad devuelve el nombre del módulo calificado por el espacio de nombres de la bibliotec...", 
"body" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo : esta propiedad devuelve un puntero a un bloque de funciones ModuleInfo con el método PROPERTY ModuleType : STRING(255) . PROPERTY ModuleType : STRING(255) : esta propiedad devuelve el nombre del módulo calificado por el espacio de nombres de la biblioteca del módulo. (El espacio de nombres es relativo al proyecto principal). " }, 
{ "title" : "Ruta de la instancia ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_247de8bc1c1aa581c0a8640e00b26998", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ Ruta de la instancia ", 
"snippet" : "La función GetInstancePath(IModule) devuelve la ruta de instancia de una instancia de módulo. La ruta de la instancia se construye concatenando los nombres de instancia de todos los ancestros, desde el módulo de nivel superior hasta la instancia dada. Los nombres de las instancias están separados po...", 
"body" : "La función GetInstancePath(IModule) devuelve la ruta de instancia de una instancia de módulo. La ruta de la instancia se construye concatenando los nombres de instancia de todos los ancestros, desde el módulo de nivel superior hasta la instancia dada. Los nombres de las instancias están separados por puntos. Si el nombre de la instancia resultante tiene más de 255 caracteres, se devuelve una cadena vacía. PROPERTY InstancePath : STRING(255) " }, 
{ "title" : "Navegación plana ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_acbf32a81c1aa581c0a8640e0039f1c2", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ Navegación plana ", 
"snippet" : "La función GetPrevModule(IModule) y GetNextModule(IModule) permitir saltar al elemento anterior o al siguiente (si el árbol de módulos se considera una lista plana de instancias de módulos). Los módulos se devuelven primero en profundidad en el pedido anticipado del árbol de módulos. Las referencias...", 
"body" : "La función GetPrevModule(IModule) y GetNextModule(IModule) permitir saltar al elemento anterior o al siguiente (si el árbol de módulos se considera una lista plana de instancias de módulos). Los módulos se devuelven primero en profundidad en el pedido anticipado del árbol de módulos. Las referencias a módulos se omiten si no hay un módulo anterior o siguiente. Alternativamente, el bloque de funciones DepthFirstRange se puede utilizar que enumera todas las instancias a partir de una instancia específica. La función GetDepthFirstRange devuelve una instancia de bloque de función de rango (de tipo DepthFirstRange ) que enumera el árbol completo, comenzando en una instancia determinada. " }, 
{ "title" : "Navegación jerárquica ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_1e4f5ff21c1aa58ec0a8640e0059614e", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ Navegación jerárquica ", 
"snippet" : "La interfaz IModuleTree permite navegar en el árbol de módulos. Se proporciona un objeto de esta interfaz a cada módulo mediante el uso de un puntero a una instancia de tipo MEnv . Este puntero se pasa a la función SetIdentification . Las referencias a los módulos se omiten en la navegación. El orde...", 
"body" : "La interfaz IModuleTree permite navegar en el árbol de módulos. Se proporciona un objeto de esta interfaz a cada módulo mediante el uso de un puntero a una instancia de tipo MEnv . Este puntero se pasa a la función SetIdentification . Las referencias a los módulos se omiten en la navegación. El orden de los nodos secundarios corresponde al orden de las instancias del módulo en el árbol de módulos. GetParent(itfM : IModule) : IModule : IModule: Devuelve la instancia principal de una instancia de módulo determinada. Para instancias de módulo de nivel superior, el valor de retorno es 0. GetFirstChild(itfM : IModule) : IModule : Devuelve el primer elemento secundario de una instancia de módulo determinada. Para instancias de módulos sin hijos, el valor de retorno es 0 NextSibling(itfM : IModule) : IModule : Devuelve el siguiente hermano de una instancia de módulo. Para instancias de módulo sin más hermanos, devuelve 0. También se puede llamar para instancias de nivel superior. PrevSibling(itfM : IModule) : IModule : Devuelve el hermano anterior de una instancia de módulo. Para instancias de módulos sin hermanos anteriores, devuelve 0. También se puede llamar para instancias de nivel superior. GetFirstToplevelInstance() : IModule : Devuelve la primera instancia de nivel superior del árbol. Devuelve 0 si el árbol está vacío. " }, 
{ "title" : "Navegación a antepasados, hermanos e hijos ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f30cbdfc1c1aa58fc0a8640e0098179e", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ Navegación a antepasados, hermanos e hijos ", 
"snippet" : "El bloque de funciones AncestorRange permite acceder a todos los ancestros de una instancia, comenzando por la instancia misma. El bloque de funciones SiblingRange permite acceder a todos los hermanos siguientes de una instancia en el árbol de módulos, comenzando en la instancia misma. La función Ge...", 
"body" : "El bloque de funciones AncestorRange permite acceder a todos los ancestros de una instancia, comenzando por la instancia misma. El bloque de funciones SiblingRange permite acceder a todos los hermanos siguientes de una instancia en el árbol de módulos, comenzando en la instancia misma. La función GetChildRange devuelve un elemento de rango (tipo SiblingRange ) de todos los hijos de una instancia. " }, 
{ "title" : "Protocolo de mensajes confiables (RMP) ", 
"url" : "ac_reliable_message_protocol.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ Protocolo de mensajes confiables (RMP) ", 
"snippet" : "El protocolo de mensajes fiables se utiliza para enviar mensajes de una instancia de módulo a otra. Esta comunicación puede ser entre aplicaciones. Por lo tanto, se crea una instancia del controlador RMP para cada aplicación. Especificación del direccionamiento: Cada socio posee una ID única de 32 b...", 
"body" : "El protocolo de mensajes fiables se utiliza para enviar mensajes de una instancia de módulo a otra. Esta comunicación puede ser entre aplicaciones. Por lo tanto, se crea una instancia del controlador RMP para cada aplicación. Especificación del direccionamiento: Cada socio posee una ID única de 32 bits, que consta de una palabra alta (bit 16 a 31) para la ID de la aplicación y una palabra baja (bit 0 a 15) para la ID local. Cada ID (32 bits) debe ser único: las palabras individuales (palabra baja o palabra alta) de la ID se pueden usar más de una vez. El ID de la aplicación que llama a la instancia debe definirse en la palabra alta de la instancia. Convenciones de nomenclatura para variables: udi<xxx>ID : ID completa del módulo que consta de la ID de la aplicación y la ID del módulo local ui<xxx>AppID : ID de la aplicación (16 bits), palabra alta de la ID completa ui<xxx>ModuleID : ID de módulo local (16 bits), palabra baja de la ID completa " }, 
{ "title" : "IRMPService ", 
"url" : "ac_rmp_irmpservice.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ IRMPService ", 
"snippet" : "Métodos y propiedades de la interfaz. IRMPService . Propiedad: LocalAppID PROPERTY LocalAppID : UINT (get) Esta propiedad describe la dirección de la aplicación local. (La palabra alta del ID de comunicación de las instancias del módulo de esta aplicación)....", 
"body" : "Métodos y propiedades de la interfaz. IRMPService . Propiedad: LocalAppID PROPERTY LocalAppID : UINT (get) Esta propiedad describe la dirección de la aplicación local. (La palabra alta del ID de comunicación de las instancias del módulo de esta aplicación). " }, 
{ "title" : "Método: IsMessageSent ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_538e8d066de1851ec0a8652001725d6d", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ IRMPService \/ Método: IsMessageSent ", 
"snippet" : "METHOD IsMessageSent : BOOL VAR_INPUT uiHandle: UINT; END_VAR Este método comprueba si un mensaje que se ha puesto en cola con QueueSendMessage ha sido enviado y reconocido. uiHandle es el mango devuelto por QueueSendMessage . Para ello, compruebe el uso del bloque de función. RMPSendMessage Se reco...", 
"body" : "METHOD IsMessageSent : BOOL\nVAR_INPUT\n uiHandle: UINT;\nEND_VAR Este método comprueba si un mensaje que se ha puesto en cola con QueueSendMessage ha sido enviado y reconocido. uiHandle es el mango devuelto por QueueSendMessage . Para ello, compruebe el uso del bloque de función. RMPSendMessage Se recomienda porque proporciona una interfaz de comando estandarizada. " }, 
{ "title" : "Método: QueueSendMessage ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_b6b7ed9d6de18513c0a8652000b31074", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ IRMPService \/ Método: QueueSendMessage ", 
"snippet" : "METHOD QueueSendMessage : UINT VAR_INPUT udiSenderID: UDINT; udiReceiverID: UDINT; tValidity: TIME; pmdData: POINTER TO ARRAY[0..63] OF BYTE; END_VAR Este método agrega un mensaje para enviar a la cola de envío y devuelve un identificador. Este identificador se puede utilizar para comprobar si la tr...", 
"body" : "METHOD QueueSendMessage : UINT\nVAR_INPUT\n udiSenderID: UDINT;\n udiReceiverID: UDINT;\n tValidity: TIME;\n pmdData: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR Este método agrega un mensaje para enviar a la cola de envío y devuelve un identificador. Este identificador se puede utilizar para comprobar si la transmisión se ha realizado correctamente. Un valor de retorno de 16#FFFF indica que el búfer está lleno y el mensaje no se transmitió. Un valor de retorno de 16#FFFE indica que el módulo receptor está en la misma aplicación y que la transmisión fue exitosa. Para agregar un mensaje a la cola de envío, use el bloque de funciones RMPSendMessage Se recomienda porque proporciona una interfaz de comando estandarizada. " }, 
{ "title" : "Método: Recibir ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_385683a56de1850cc0a8652000d330da", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ IRMPService \/ Método: Recibir ", 
"snippet" : "METHOD Receive : UDINT VAR_INPUT uiReceiverModuleID: UINT; pmd: POINTER TO ARRAY[0..63] OF BYTE; END_VAR Este método es llamado por cada módulo que puede recibir un mensaje. Toma el mensaje recibido más antiguo para uiReceiverID y lo reconoce. Si un mensaje no está disponible, entonces 16#FFFFFFFF e...", 
"body" : "METHOD Receive : UDINT\nVAR_INPUT\n uiReceiverModuleID: UINT;\n pmd: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR Este método es llamado por cada módulo que puede recibir un mensaje. Toma el mensaje recibido más antiguo para uiReceiverID y lo reconoce. Si un mensaje no está disponible, entonces 16#FFFFFFFF es regresado. Vuelve 16#FFFFFFFE si hay al menos un mensaje esperando al receptor, si el mensaje más antiguo está actualmente bloqueado por una tarea diferente. En todos los demás casos, se devuelve la dirección de comunicación del remitente. " }, 
{ "title" : "RMPSendMessage ", 
"url" : "ac_rmp_sendmessage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ RMPSendMessage ", 
"snippet" : "Este bloque de funciones sirve para enviar mensajes a cualquier instancia de módulo. La dirección de la instancia debe ser conocida. El comportamiento de las variables xExecute , xDone , xBusy , y xError cumple con las \"Directrices para el diseño de bibliotecas\". Este documento es parte del CODESYS ...", 
"body" : "Este bloque de funciones sirve para enviar mensajes a cualquier instancia de módulo. La dirección de la instancia debe ser conocida. El comportamiento de las variables xExecute , xDone , xBusy , y xError cumple con las \"Directrices para el diseño de bibliotecas\". Este documento es parte del CODESYS instalación estándar. " }, 
{ "title" : "FUNCTION_BLOCK RMPSendMessage ", 
"url" : "ac_rmp_sendmessage.html#UUID-2d1f2b05-610c-bf06-e2fe-18d7e3819bbc_ac_rmp_sendmessage0", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ RMPSendMessage \/ FUNCTION_BLOCK RMPSendMessage ", 
"snippet" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG VAR_IN_OUT mdData: ARRAY[0..63] OF BYTE; END_VAR VAR_INPUT itfrmp: IRMPService; xExecute: BOOL; udiReceiverID: UDINT; uiSenderModuleID: UINT; tValidity: TIME := t#1s; END_VAR VAR_OUTPUT xDone: BOOL; xBusy: BOOL; xError: BOOL; uiErrorID: UINT; END_VAR T...", 
"body" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG\nVAR_IN_OUT\n mdData: ARRAY[0..63] OF BYTE;\nEND_VAR\nVAR_INPUT\n itfrmp: IRMPService;\n xExecute: BOOL;\n udiReceiverID: UDINT;\n uiSenderModuleID: UINT;\n tValidity: TIME := t#1s;\nEND_VAR\nVAR_OUTPUT\n xDone: BOOL;\n xBusy: BOOL;\n xError: BOOL;\n uiErrorID: UINT;\nEND_VAR Tenga en cuenta que el trabajo del bloque de funciones finaliza con éxito tan pronto como se confirma la recepción del mensaje en el RMPService del lado opuesto. Esto no significa necesariamente que el mensaje haya llegado a la interfaz del módulo receptor real. En mdData , se transferirán los datos a enviar. udiReceiverID define el ID del receptor. rmp define la instancia local de RMPService. tValidity define el período de validación del mensaje. Se comprueban las siguientes cosas: La duración hasta que se envíe el mensaje no debe exceder tValidity (de lo contrario, se creará un mensaje de error). La duración hasta que el mensaje sea recogido por el receptor del lado opuesto, no debe exceder tValidity (de lo contrario, el mensaje será eliminado). Los siguientes errores pueden ocurrir y serán devueltos en uiErrorID : El búfer de envío está lleno; se recomienda enviar de nuevo en una fecha posterior. El mensaje no se eliminará del búfer de envío. Las razones pueden ser una transferencia lenta, una conexión interrumpida o un búfer de recepción lleno en el lado opuesto. La aplicación a la que se envía el mensaje no está conectada a esta aplicación. En este caso no es posible una transferencia de los datos. " }, 
{ "title" : "depuración ", 
"url" : "ac_rmp_debugging.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor de declaración de módulo \/ Biblioteca: AC_ModuleBase \/ depuración ", 
"snippet" : "la variable global g_AC_RMP_xDiagLog se puede utilizar para habilitar el mecanismo de registro. Este mecanismo registra todos los eventos de envío y recepción y registra la creación y eliminación de un mensaje en una cola del registro estándar. Además, todos los eventos y errores inesperados se escr...", 
"body" : "la variable global g_AC_RMP_xDiagLog se puede utilizar para habilitar el mecanismo de registro. Este mecanismo registra todos los eventos de envío y recepción y registra la creación y eliminación de un mensaje en una cola del registro estándar. Además, todos los eventos y errores inesperados se escriben en el registro estándar. " }
]
$(document).trigger('search.ready');
});