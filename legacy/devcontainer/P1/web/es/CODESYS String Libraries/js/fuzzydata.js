$(document).ready(function () {indexDict['es'] = [{ "title" : "CODESYS String Libraries ", 
"url" : "_strlib_start_page.html", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Introducci√≥n ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4664735744121633736389596078", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Introducci√≥n ", 
"snippet" : "Las bibliotecas del CODESYS String Libraries el paquete se puede usar para procesar cadenas codificadas en UTF-8. La base es la IString interfaz desde el String Segments biblioteca. Con esta interfaz, las cadenas se pueden pasar a las funciones respectivas por referencia. Por ejemplo, para crear un ...", 
"body" : "Las bibliotecas del CODESYS String Libraries el paquete se puede usar para procesar cadenas codificadas en UTF-8. La base es la IString interfaz desde el String Segments biblioteca. Con esta interfaz, las cadenas se pueden pasar a las funciones respectivas por referencia. Por ejemplo, para crear un IString instancia, el GSB.UTF8String bloque de funciones del Generic String Base se proporciona una biblioteca. Con el paquete se suministran las siguientes bibliotecas: String Segments Funciones b√°sicas para IString instancias Documentaci√≥n de la biblioteca de segmentos de cadenas String Builder Gesti√≥n eficiente de segmentos de cadena codificados en UTF-8 Documentaci√≥n de la biblioteca de String Builder String Conversions Conversi√≥n de cadenas de diferente codificaci√≥n hacia\/desde UTF-8 Documentaci√≥n de la biblioteca de conversiones de cadenas String Functions Funciones para procesar cadenas codificadas en UTF-8 siguiendo el ejemplo de la biblioteca est√°ndar convencional. Documentaci√≥n de la biblioteca de funciones de cadena Unicode Support Funciones para procesar categor√≠as de caracteres Unicode. Documentaci√≥n de la biblioteca de funciones de soporte de Unicode UTF-16 Encoding Support Funci√≥n b√°sica para gestionar √°reas de memoria codificadas en UTF-16 Documentaci√≥n de la biblioteca de soporte de codificaci√≥n UTF-16 UTF-8 Encoding Support Funci√≥n b√°sica para gestionar √°reas de memoria codificadas en UTF-8 Documentaci√≥n de la biblioteca de funciones de soporte de codificaci√≥n UTF-8 Generic String Base Bloques de funciones para procesar cadenas codificadas en UTF-8 que gestionan su memoria de forma est√°tica mediante GENERIC CONSTANT . Documentaci√≥n de la biblioteca de funciones b√°sicas de cadenas gen√©ricas " }, 
{ "title" : "Ventajas de las nuevas bibliotecas de cadenas ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4563869800648033733012917566", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Ventajas de las nuevas bibliotecas de cadenas ", 
"snippet" : "Las nuevas bibliotecas de cadenas no sustituyen a las antiguas funciones de cadenas conocidas del Standard y Standard64 bibliotecas. Sin embargo, recomendamos usar las nuevas bibliotecas de cadenas para proyectos nuevos. Las nuevas bibliotecas de cadenas tambi√©n pueden gestionar cadenas grandes de f...", 
"body" : "Las nuevas bibliotecas de cadenas no sustituyen a las antiguas funciones de cadenas conocidas del Standard y Standard64 bibliotecas. Sin embargo, recomendamos usar las nuevas bibliotecas de cadenas para proyectos nuevos. Las nuevas bibliotecas de cadenas tambi√©n pueden gestionar cadenas grandes de forma eficiente. La longitud de las cadenas es casi ilimitada. Por esta raz√≥n, las bibliotecas tambi√©n son adecuadas para editar archivos de texto y contenido web de gran tama√±o. Otras ventajas: UTF-8 es una codificaci√≥n que puede representar la gama completa de caracteres seg√∫n UNICODE. UTF-8 se usa ampliamente en Internet y es recomendado por el World Wide Web Consortium (W3C). UTF-8 es compatible con los sistemas antiguos debido a su compatibilidad con ASCII. UTF-8 proporciona un alto nivel de interoperabilidad. UTF-8 funciona para optimizar la memoria. Las nuevas bibliotecas de cadenas le permiten consultar una cadena previamente definida mediante los m√©todos correspondientes, tal como la conoce en otros lenguajes de alto nivel. Ejemplo de m√©todo de cadena: Len() udiStringLen := myString.Len();\nif¬†udiStringLen =¬†22¬†THEN\n... A partir de CODESYS 3.5.18.0, puede configurar el compilador para que interprete el contenido de las variables de tipo STRING como codificaci√≥n UTF-8. Seleccionas Codificaci√≥n UTF-8 para STRING opci√≥n en el Configuraci√≥n del proyecto en el Opciones de compilaci√≥n categor√≠a. Si no quieres tratar a todos STRING las variables de un proyecto est√°n codificadas en UTF-8, debe desactivar esta opci√≥n. Despu√©s de eso, puede aplicar la codificaci√≥n UTF-8 a STRING escriba caso por caso. Codificaci√≥n UTF-8 para literales {attribute¬†'monitoring_encoding'¬†:=¬†'UTF-8'}\nsValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë'; Gracias a las capacidades de codificaci√≥n UTF-8, no es necesario utilizar el WSTRING escriba datos en CODESYS para usar un conjunto de caracteres extendido. codificaci√≥n UCS-2 WSTRING se basa en, puede requerir m√°s memoria que una codificaci√≥n UTF-8, seg√∫n la aplicaci√≥n. La codificaci√≥n UCS-2 siempre usa WORD por car√°cter y solo puede representar los caracteres U+0000 para U+D800 y U+DFFF para U+FFFD . La codificaci√≥n UTF-8 requiere entre uno y cuatro bytes por car√°cter. Como resultado, se pueden procesar todos los caracteres Unicode Con la codificaci√≥n UTF-8, si intentas obtener un car√°cter espec√≠fico usando un √≠ndice espec√≠fico, esto generar√° resultados inesperados debido a la longitud variable. Codificaci√≥n de longitud variable {attribute 'monitoring_encoding' := 'UTF-8'}\nsValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë';\n\nbyValue := sValue[13];¬†\/\/ The 'u' is NOT the 13th character in the string\nxOk := byValue <>¬†16#75; Debe determinar el √≠ndice de un car√°cter iterando la cadena. Iteraci√≥n sobre cadenas codificadas en UTF-8 VAR\t\n {attribute 'monitoring_encoding' := 'UTF-8'}\n sValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë';\n\n fbsValue : STR.UTF8Literal := (psValue:=ADR(sValue)); \n fbRange : STR.Range := (itfString:=fbsValue);\n diRune : STR.RUNE;\n udiIndex, udiLength : UDINT;\n xOk : BOOL;\nEND_VAR\n \nWHILE (diRune := fbRange.GetNextRune(udiLength=>udiLength)) <> 0 DO\n IF diRune = 16#75 (* 'u' *) THEN\n EXIT;\n END_IF\n udiIndex := udiIndex + udiLength;\nEND_WHILE\n \nxOk := sValue[udiIndex] = 16#75 (* 'u' *); " }, 
{ "title" : "Desventajas de lo establecido STRING funciones ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4613761597678433733013344138", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Desventajas de lo establecido STRING funciones ", 
"snippet" : "En el anteriormente establecido STRING funciones de la biblioteca est√°ndar, los par√°metros de tipo STRING se copian cuando se pasan a las funciones. El valor devuelto tambi√©n se copia a una variable con la asignaci√≥n. Problemas con las funciones STRING establecidas VAR sValue : STRING; END_VAR sValu...", 
"body" : "En el anteriormente establecido STRING funciones de la biblioteca est√°ndar, los par√°metros de tipo STRING se copian cuando se pasan a las funciones. El valor devuelto tambi√©n se copia a una variable con la asignaci√≥n. Problemas con las funciones STRING establecidas VAR\n sValue : STRING;\nEND_VAR\n \nsValue := CONCAT(CONCAT(CONCAT('Da steh ich nun,', ' ich armer Tor!'), ' Und bin so'), ' klug als wie zu vor');\n\/\/ -> Copy, LEN -> Copy, LEN -> Copy, LEN -> Copy, LEN\n\/\/ -> 2xCopy, LEN\n\/\/ -> 2xCopy, LEN\n\/\/ -> 2xCopy, LEN Antes de procesar los par√°metros de tipo STRING en las funciones respectivas, sus longitudes a menudo tienen que determinarse mediante iteraci√≥n hasta el car√°cter nulo final. En el caso de cadenas m√°s largas, estas operaciones de copia e iteraci√≥n aumentan el tiempo de procesamiento de la aplicaci√≥n. La longitud de las cadenas est√° limitada a 255 caracteres para la aplicaci√≥n de estas funciones " }, 
{ "title" : "Uso del IString interfaz ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4598276788502433733013693363", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Uso del IString interfaz ", 
"snippet" : "El STR.IString La interfaz se introdujo para pasar la estructura de datos que administra la informaci√≥n sobre una cadena por referencia. Esta es una diferencia importante con respecto a las funciones STRING establecidas anteriormente, que no implementan la STR.IString interfaz. Adem√°s, el tama√±o de ...", 
"body" : "El STR.IString La interfaz se introdujo para pasar la estructura de datos que administra la informaci√≥n sobre una cadena por referencia. Esta es una diferencia importante con respecto a las funciones STRING establecidas anteriormente, que no implementan la STR.IString interfaz. Adem√°s, el tama√±o de una cadena (la memoria respectiva para los caracteres codificados en UTF-8) puede estar en el rango num√©rico. UDINT 4 ‚â¶ udiSize ‚â¶ 16#FFFF_FF00 ). En la estructura de datos mencionada, la siguiente informaci√≥n se mantiene actualizada y no es necesario volver a calcularla cada vez antes de un paso de procesamiento: Referencia al segmento de memoria respectivo Capacidad actual (‚Üí GetSegment ) Longitud (‚Üí Len ) en bytes N√∫mero de caracteres (‚Üí RuneCount ) Propiedades de STR.IString VAR\n itfString : STR.IString;\n udiLength, udiSize, udiRuneCount : UDINT;\n pbySegment : POINTER TO BYTE;\n xValid : BOOL;\nEND_VAR\n \nudiLength := itfString.Len(); \/\/ Current length in byte\npbySegment := itfString.GetSegment(udiSize=>udiSize); \/\/ Address first byte, capacity of the segment in bytes\nudiRuneCount := STR.RuneCount(itfString); \/\/ Current number of \"characters\" in the segment\nxValid := itfString.IsValid(); \/\/ Indication that a valid UTF-8 encoding is present. Correlaci√≥n: ¬´personaje¬ª y ¬´runa¬ª El t√©rmino ¬´runa¬ª aparece en las bibliotecas y en el c√≥digo fuente y significa exactamente lo mismo que ¬´punto de c√≥digo Unicode¬ª, con una adici√≥n interesante. Las bibliotecas definen la palabra ¬´runa¬ª como un alias para el tipo DINT . Como resultado, el usuario puede ver claramente cu√°ndo un valor entero representa un punto de c√≥digo. Adem√°s, lo que puede imaginarse como una constante de caracteres se denomina constante r√∫nica Ejemplo: El tipo y el valor de la expresi√≥n WSTRING#\"‚åò\" es una runa con un valor entero DINT#16#2318 . " }, 
{ "title" : "Informaci√≥n para expertos ", 
"url" : "_strlib_expert_information.html", 
"breadcrumbs" : "CODESYS String Libraries \/ Informaci√≥n para expertos ", 
"snippet" : "En CODESYS versiones anteriores a la 3.5.18.0, no tiene la posibilidad de utilizar variables de tipo codificadas en UTF-8 STRING y el Generic String Base biblioteca. Esto solo es posible en la versi√≥n 3.5.19.50 y superiores. Puedes seguir usando las dem√°s bibliotecas CODESYS String Libraries paquete...", 
"body" : "En CODESYS versiones anteriores a la 3.5.18.0, no tiene la posibilidad de utilizar variables de tipo codificadas en UTF-8 STRING y el Generic String Base biblioteca. Esto solo es posible en la versi√≥n 3.5.19.50 y superiores. Puedes seguir usando las dem√°s bibliotecas CODESYS String Libraries paquete. Sin embargo, el manejo de √°reas de memoria codificadas en UTF-8 (por ejemplo, ARRAY OF BYTE ) es algo m√°s complicado all√≠. ANTES DEL SP18 VAR\n abyValue : ARRAY[0..33] OF BYTE := [ \/\/ UTF-8 C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl\n 16#43, 16#C3, 16#98, 16#44, 16#E2, 16#82, 16#AC, 16#C5, 16#A1, 16#C5, 16#B8,\n 16#C5, 16#A0, 16#20, 16#C3, 16#AF, 16#C3, 16#9F, 16#20, 16#76, 16#C3, 16#A4,\n 16#72, 16#C3, 16#BF, 16#20, 16#C3, 16#A7, 16#C3, 16#B4, 16#C3, 16#B5, 16#6C, 0\n ];\n myString : STR.UTF8Literal := (psValue:=ADR(abyValue));\nEND_VAR Tan pronto como variables de tipo codificadas en UTF-8 STRING est√°n disponibles, el ejemplo anterior se simplifica a√∫n m√°s: VAR\n myString : STR.UTF8Literal := (psValue:=ADR(UTF8#'C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl'));\nEND_VAR " }, 
{ "title" : "Conversi√≥n desde STRING para IString ", 
"url" : "_strlib_expert_information.html#UUID-ab7f59ef-3fd1-9368-2073-8d15fffc313a_section-idm4670931916384033733014074571", 
"breadcrumbs" : "CODESYS String Libraries \/ Informaci√≥n para expertos \/ Conversi√≥n desde STRING para IString ", 
"snippet" : "La estructura de datos para gestionar las propiedades de un segmento de cadena se implementa mediante el STR._UTF8String bloque de funciones. Para ello, debe asignar memoria para una instancia de este bloque de funciones y para el segmento de cadena en s√≠. Una instancia de bloque de funciones debe e...", 
"body" : "La estructura de datos para gestionar las propiedades de un segmento de cadena se implementa mediante el STR._UTF8String bloque de funciones. Para ello, debe asignar memoria para una instancia de este bloque de funciones y para el segmento de cadena en s√≠. Una instancia de bloque de funciones debe estar ubicada en un √°rea de memoria que est√© alineada con un __XWORD address . Conversi√≥n de STRING a IString VAR CONSTANT\n c_udiLength : UDINT := MAX(4, 512); \/\/ String segment capacity including terminal NULL\n c_udiXWORD : UDINT := SIZEOF(__XWORD);\n¬† ¬†¬†c_udiMaxIndex : UDINT := (SIZEOF(STR._UTF8String) + c_udiLength +¬† c_udiXWORD¬† -¬†1) \/ c_udiXWORD;\nEND_VAR\n \nVAR\n abyValue : ARRAY[0..33] OF BYTE := [ \/\/ UTF-8 C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl\n 16#43, 16#C3, 16#98, 16#44, 16#E2, 16#82, 16#AC, 16#C5, 16#A1, 16#C5, 16#B8,\n 16#C5, 16#A0, 16#20, 16#C3, 16#AF, 16#C3, 16#9F, 16#20, 16#76, 16#C3, 16#A4,\n 16#72, 16#C3, 16#BF, 16#20, 16#C3, 16#A7, 16#C3, 16#B4, 16#C3, 16#B5, 16#6C, 0\n\t];\n axwMemory : ARRAY[0..c_udiMaxIndex] OF __XWORD;\n udiSize : UDINT;\n itfString : STR.IString := STR.CreateString(\n ADR(axwMemory), SIZEOF(axwMemory),\n ADR(abyValue),\n udiStrSize=>udiSize\n );\n xOk : BOOL;\nEND_VAR\n \nxOk := (\n udiSize >= 512 AND\n itfString.Len() = 33 AND\n STR.RuneCount(itfString) = 20 AND\n itfString.IsValid() AND\n NOT itfString.IsASCII()\n); Con la ayuda del Generic String Base biblioteca, muchos de estos requisitos se tienen en cuenta mediante los bloques de funciones correspondientes y, como resultado, liberan al usuario de muchas tareas. Por encima de todo, la reserva y la alineaci√≥n correctas de la memoria se encapsulan en los bloques de funciones correspondientes " }, 
{ "title" : "Ejemplos ", 
"url" : "_strlib_examples.html", 
"breadcrumbs" : "CODESYS String Libraries \/ Ejemplos ", 
"snippet" : "El Generic String Base se proporciona una biblioteca para que el procesamiento de cadenas sea lo m√°s simple posible. Sin embargo, usa el VAR_GENERIC CONSTANT funci√≥n de compilador y, por lo tanto, solo se puede usar a partir de CODESYS Parche 5 de la versi√≥n 3.5 SP19....", 
"body" : "El Generic String Base se proporciona una biblioteca para que el procesamiento de cadenas sea lo m√°s simple posible. Sin embargo, usa el VAR_GENERIC CONSTANT funci√≥n de compilador y, por lo tanto, solo se puede usar a partir de CODESYS Parche 5 de la versi√≥n 3.5 SP19. " }, 
{ "title" : "Biblioteca: Generic String Base ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4598276773272033733014529891", 
"breadcrumbs" : "CODESYS String Libraries \/ Ejemplos \/ Biblioteca: Generic String Base ", 
"snippet" : "Aqu√≠ hay una instancia ( myString ) de un GSB.UTF8String se crea con una capacidad de 128 bytes y se inicializa el segmento de cadena con el valor de una variable STRING (n√∫mero romano 1968). Los m√©todos de STR.IString est√°n disponibles. Desde STRING para IString VAR ¬† ¬†¬†myString : GSB.UTF8String<12...", 
"body" : "Aqu√≠ hay una instancia ( myString ) de un GSB.UTF8String se crea con una capacidad de 128 bytes y se inicializa el segmento de cadena con el valor de una variable STRING (n√∫mero romano 1968). Los m√©todos de STR.IString est√°n disponibles. Desde STRING para IString VAR\n¬† ¬†¬†myString : GSB.UTF8String<128> := (sValue := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß');¬†\/\/ r√∂misch 1968¬†¬†¬†¬†\n psString : POINTER TO STRING;¬†¬†¬†¬†udiSize, udiLength : UDINT;¬† ¬†¬†xASCII, xOk : BOOL;\nEND_VAR\n \n psString := myString.GetSegment(udiSize=>udiSize, udiLength=>udiLength, xASCII=>xASCII);¬†\/\/ Conversion back to the STRING data type\n \nxOk := (\n myString.IsValid() AND \/\/ A valid UTF-8 encoding is present\n udiSize = 128 AND \/\/ The capacity of the string in bytes\n myString.Len() = 17 AND \/\/ The current length of the string in bytes\n STR.RuneCount(myString) = 6 \/\/ The current number of characters in the string\n); Funci√≥n del generador de cadenas VAR\n myString : GSB.UTF8String<20> := (sValue := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß'); \/\/ roman 1968\n sValue : STRING := 'wurden in Mexico-Stadt die';\n wsValue : WSTRING := \"‚Ö©‚Ö®.\";\n diSpace : STR.RUNE := 32;\n myValue : GSB.UTF8String<128> := (sValue := UTF8#'—∫‚Ñì∆¥ŒºœÅ‚ò§·πß·∏â–ΩŒµŒ∑ $$œÅ—ó‚ÑÆ≈Ç‚ÑØ Œ±‚ô≠‚ÑäŒµ‚ÑåŒ± ü‚ä•‚ÑÆ·æî.');\n \n myBuilder : GSB.Builder<(*udiInitialCapacity*) 64, (*usiExtensionFactor*) 50> := (itfString:=myString);\n myResult : GSB.UTF8String<128>;\n \n {attribute 'monitoring_encoding' := 'UTF-8'}\n sResult : STRING(128) := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß wurden in Mexico-Stadt die ‚Ö©‚Ö®. —∫‚Ñì∆¥ŒºœÅ‚ò§·πß·∏â–ΩŒµŒ∑ $$œÅ—ó‚ÑÆ≈Ç‚ÑØ Œ±‚ô≠‚ÑäŒµ‚ÑåŒ± ü‚ä•‚ÑÆ·æî.';\n \n psResult : POINTER TO STRING;\n udiLength : UDINT;\n xOk : BOOL;\nEND_VAR\n \nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteString(sValue);\nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteWString(wsValue);\nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteIString(myValue);\n \nudiLength := myBuilder.Len(); \/\/ The number of bytes occupied in the builder.\nmyBuilder.ToIString(myResult); \/\/ The individual parts of the string are copied together to myResult.\n \npsResult := myResult.GetSegment(); \nxOk := (psResult^ = sResult); \/\/ Both memory areas should have the same content. En el ejemplo anterior, se crea una instancia del generador con una capacidad inicial de 64 bytes ( udiInitialCapacity ) y un factor din√°mico de 50 ( usiExtensionFactor ). La cadena generada m√°s arriba todav√≠a se incluye en la declaraci√≥n y, como resultado, el generador se rellena con esta cadena ( UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß' ). Utilizando el usiExtensionFactor par√°metro, aumenta el generador en un 50% cuando se agota su capacidad actual. Lectura de un archivo con el constructor VAR\n sPath : STRING := 'myFilePath';\n hFile : RTS_IEC_HANDLE := RTS_INVALID_HANDLE;\n myBuilder : GSB.Builder<(*udiInitialCapacity*) 16#10000, (*usiExtensionFactor*) 50>;\n abyBuffer : ARRAY[0..4095] OF BYTE;\n pbyData : POINTER TO BYTE;\n udiSize : UDINT;\n udiCount : UDINT;\n eEncoding : SCV.ENCODING;\n eErrorID : SCV.ERROR;\n udiResult : RTS_IEC_RESULT;\nEND_VAR\n \nhFile := SysFileOpen(sPath, ACCESS_MODE.AM_READ, ADR(udiResult));\nIF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n RETURN; \nEND_IF\n \nREPEAT \/\/ fake loop - We need the EXIT feature\n pbyData := ADR(abyBuffer);\n udiSize := TO_UDINT(SysFileRead(hFile, pbyData, XSIZEOF(abyBuffer), ADR(udiResult)));\n IF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n EXIT; \n END_IF\n \n \/\/ Determination of the file encoding\n udiCount := SCV.DecodeBOM(pbyData, udiSize, eEncoding=>eEncoding, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n \/\/ handle error condition\n EXIT;\n END_IF\n \n pbyData := pbyData + udiCount;\n udiSize := udiSize - udiCount;\n \n WHILE udiSize > 0 DO\n \/\/ Convert file content to UTF-8 and copy to Builder-Content\n udiCount := myBuilder.WriteMemSegment(pbyData, udiSize, eEncoding, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n \/\/ handle error condition\n EXIT;\n END_IF\n pbyData := ADR(abyBuffer);\n udiSize := TO_UDINT(SysFileRead(hFile, pbyData, XSIZEOF(abyBuffer), ADR(udiResult)));\n IF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n EXIT; \n END_IF\n END_WHILE\nUNTIL TRUE\nEND_REPEAT\n \nIF hFile <> RTS_INVALID_HANDLE THEN\n SysFileClose(hFile);\n hFile := RTS_INVALID_HANDLE;\n udiCount : UDINT;\nEND_IF An√°lisis del contenido de una instancia de construcci√≥n VAR\n myRange : SBD.Range := (itfBuilder := myBuilder);\n diRune : STR.RUNE;\n eError : STR.ERROR;\nEND_VAR\n \nmyRange.Reset();\nWHILE (diRune := myRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND_THEN eErrorID = 0 DO\n IF UC.IsSpace(diRune) THEN\n \/\/ The characters in the builder which are considered as spaces according to UNICODE are counted.\n udiCount := udiCount + 1;\n END_IF\nEND_WHILE Para pasar contenido codificado en UTF-8, no se necesita memoria cach√© para la conversi√≥n de codificaci√≥n porque los datos ya est√°n codificados en UTF-8 en el generador. Por lo tanto, el contenido de los segmentos de un generador se puede enviar directamente, por ejemplo, a trav√©s Transporte del contenido codificado en UTF-8 de un constructor a trav√©s de la red VAR\n itfConnection : NBS.IConnection;\n pbySegment : POINTER TO BYTE;\n udiSize : UDINT;\n eError : NBS.ERROR;\nEND_VAR\n \n(* Provide an active itfConnection *)\n \npbySegment:= myBuilder.GetFirstSegment(udiSize=>udiSize, eErrorID=>eErrorID);\nWHILE pbySegment <> 0 AND eErrorID = 0 DO\n eError := itfConnection.Write(pbySegment, udiSize, udiCount=>udiCount);\n IF eError <> 0 OR udiCount <> udiSize THEN\n \/\/ Handle Error\n EXIT;\n END_IF\n pbySegment := myBuilder.GetNextSegment(pbySegment, udiSize=>udiSize, eErrorID=>eErrorID);\nEND_WHILE\n \n(* e.g. Close itfConnection *) " }, 
{ "title" : "Trabajando con StringPool y RangePool bloques de funciones ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4670931838168033733015007444", 
"breadcrumbs" : "CODESYS String Libraries \/ Ejemplos \/ Trabajando con StringPool y RangePool bloques de funciones ", 
"snippet" : "El siguiente c√≥digo muestra c√≥mo usar la din√°mica IString instancias de un StringPool . StringPool o un RangePool es adecuado para pasarlo a partes subordinadas de un programa. A continuaci√≥n, pueden crear las instancias correspondientes a partir del grupo respectivo, seg√∫n sea necesario, trabajar c...", 
"body" : "El siguiente c√≥digo muestra c√≥mo usar la din√°mica IString instancias de un StringPool . StringPool o un RangePool es adecuado para pasarlo a partes subordinadas de un programa. A continuaci√≥n, pueden crear las instancias correspondientes a partir del grupo respectivo, seg√∫n sea necesario, trabajar con ellas y, a continuaci√≥n, devolver estas instancias al grupo Trabajando con StringPool y RangePool VAR\n myString : GSB.UTF8String<256> := (sValue:=UTF8#'Was du nicht willst, dass man dir tu‚Äô, das f√ºg auch keinem andern zu.');\n myRange : STR.Range := (itfString:=myString);\n \n myStringPool : GSB.StringPool<(*udiStringSize*) 30, (*udiInitialCapacity*) 25, (*usiExtensionFactor*) 0>;\n myRangePool : GSB.RangePool<GSB.RANGE_TYPE.ISTRING, (*udiInitialCapacity*) 10, (*usiExtensionFactor*) 0>;\n \n diRune : STR.RUNE;\n eErrorID : STR.ERROR;\n itfSubString : STR.IString;\n liStart, liEnd : LINT;\n udiCount : UDINT;\nEND_VAR\n \nmyRange.Reset();\n\/\/ Decompose myString into substrings and analyze them via a subroutine.\nWHILE (diRune:=myRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND eErrorID = 0 DO\n IF diRune = 16#2C (*,*) OR diRune = 16#2E (*.*) THEN\n itfSubString := myStringPool.GetString();\n IF itfSubString = 0 THEN\n (* Handle Error *)\n EXIT;\n END_IF\n myString.ToIString(itfSubString, liStart+1, liEnd, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n (* Handle Error *)\n EXIT;\n END_IF\n \/\/ Analyse the substring and use pool's\n \/\/ Will release itfSubString\n udiCount := Analyse(itfSubString, myStringPool, myRangePool);\n (* ... Handle Result ... *)\n IF diRune = 16#2E (*.*) THEN\n EXIT;\n END_IF\n diRune:=myRange.GetNextRune(eErrorID=>eErrorID);\n IF diRune = 16#20 (* space *) AND eErrorID = 0 THEN\n liEnd := liEnd + 1;\n ELSE\n myRange.UngetLastRune();\n END_IF\n liStart := liEnd + 1;\n END_IF\n liEnd := liEnd + 1;\nEND_WHILE " }, 
{ "title" : "Trabajando con las categor√≠as de caracteres de Unicode ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4613758488403233733015299155", 
"breadcrumbs" : "CODESYS String Libraries \/ Ejemplos \/ Trabajando con las categor√≠as de caracteres de Unicode ", 
"snippet" : "El est√°ndar Unicode tiene como objetivo capturar digitalmente todos los caracteres del mundo y describir sus propiedades. Para ello, los caracteres se combinan en grupos (categor√≠as). En la biblioteca Unicode, hay funciones que comprueban la categor√≠a a la que pertenece un car√°cter. Estas funciones ...", 
"body" : "El est√°ndar Unicode tiene como objetivo capturar digitalmente todos los caracteres del mundo y describir sus propiedades. Para ello, los caracteres se combinan en grupos (categor√≠as). En la biblioteca Unicode, hay funciones que comprueban la categor√≠a a la que pertenece un car√°cter. Estas funciones devuelven TRUE si el car√°cter pasado pertenece a la categor√≠a correspondiente; de lo contrario FALSE se devuelve. Nombre Funci√≥n IsControl Reconoce los caracteres de control generales IsLetter Reconoce las letras en un sentido m√°s amplio IsMark Reconoce la combinaci√≥n de caracteres, por ejemplo, caracteres diacr√≠ticos IsDigit Reconoce d√≠gitos decimales IsLower Reconoce letras min√∫sculas IsNumber Reconoce d√≠gitos y caracteres que se aplican a los n√∫meros IsGraphic Reconoce solo los caracteres imprimibles (incluidos los diferentes tipos de caracteres de espacio) IsUpper Reconoce las letras may√∫sculas IsPunct Reconoce los caracteres de puntuaci√≥n IsPrint Reconoce solo los caracteres imprimibles (solo considera 16#20 como car√°cter de espacio) IsTitle Reconoce las letras may√∫sculas de los encabezados IsSpace Detecta espacios de diferente ancho, saltos de l√≠nea, etc. IsSymbol Reconoce los s√≠mbolos en un sentido m√°s amplio, por ejemplo, los s√≠mbolos matem√°ticos y los s√≠mbolos monetarios. El contenido de un IString o IBuilder la instancia se puede analizar ¬´car√°cter por car√°cter¬ª utilizando un bloque funcional de tipo adecuado Range . Las funciones de la biblioteca Unicode pueden resultar muy √∫tiles para el an√°lisis An√°lisis de personajes VAR\n myString : GSB.UTF8String<50> := (sValue:='Hello World!');\n myBuilder : GSB.Builder<100, 0> := (itfString:=myString);\n mySRange : STR.Range := (itfString:=myString);\n myBRange : SBD.Range := (itfBuilder:=myBuilder);\n diSRune, diBRune : STR.RUNE;\n eErrorID : STR.ERROR;\n udiCount : UDINT;\nEND_VAR\n \nWHILE (diSRune:=mySRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND eErrorID = 0 DO\n diBRune := myBRange.GetNextRune();\n IF diSRune <> diBRune THEN\n (* Solle nicht vorkommen *)\n END_IF\n IF UC.IsSpace(diSrune) THEN\n udiCount := udiCount + 1;\n END_IF\nEND_WHILE " }, 
{ "title" : "Conversi√≥n de caracteres ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4613761628716833733015669185", 
"breadcrumbs" : "CODESYS String Libraries \/ Ejemplos \/ Conversi√≥n de caracteres ", 
"snippet" : "Convierte letras a may√∫sculas ( UC.ToUpper ) Convierte letras a min√∫sculas ( UC.ToLower ) Conversi√≥n VAR diRuneA, diRuneB : STR.RUNE; END_VAR diRuneA := 16#1F3; \/\/ U+01F3 = «Ö diRuneB := UC.ToUpper(diRuneA); \/\/ U+01F1 = «± diRuneA := UC.ToLower(diRuneB); \/\/ U+01F3 = «Ö diRuneB := UC.ToTitle(diRuneA); \/...", 
"body" : "Convierte letras a may√∫sculas ( UC.ToUpper ) Convierte letras a min√∫sculas ( UC.ToLower ) Conversi√≥n VAR\n diRuneA, diRuneB : STR.RUNE;\nEND_VAR\n \ndiRuneA := 16#1F3; \/\/ U+01F3 = «Ö\ndiRuneB := UC.ToUpper(diRuneA); \/\/ U+01F1 = «±\ndiRuneA := UC.ToLower(diRuneB); \/\/ U+01F3 = «Ö\ndiRuneB := UC.ToTitle(diRuneA); \/\/ U+01F2 = «≤ " }, 
{ "title" : "Comparaci√≥n de cadenas ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4563870076659233733015900115", 
"breadcrumbs" : "CODESYS String Libraries \/ Ejemplos \/ Comparaci√≥n de cadenas ", 
"snippet" : "Distinga may√∫sculas y min√∫sculas STR.Compare ) No distingue entre may√∫sculas y min√∫sculas ( UC.EqualFold ) Comparaci√≥n de cadenas VAR myFirstString : GSB.UTF8String<50> := (sValue:='test'); mySecondString : GSB.UTF8String<50> := (sValue:='Test'); myThirdString : GSB.UTF8String<50> := (sValue:='CoDeS...", 
"body" : "Distinga may√∫sculas y min√∫sculas STR.Compare ) No distingue entre may√∫sculas y min√∫sculas ( UC.EqualFold ) Comparaci√≥n de cadenas VAR\n myFirstString : GSB.UTF8String<50> := (sValue:='test');\n mySecondString : GSB.UTF8String<50> := (sValue:='Test');\n \n myThirdString : GSB.UTF8String<50> := (sValue:='CoDeSys');\n myFourthString : GSB.UTF8String<50> := (sValue:='CODESYS');\n \n diResult : DINT;\n xEqual : BOOL;\nEND_VAR\n \n\/\/\/ Comparing two Strings lexicographically\n\/\/\/ diResult = 1 --> myFirstString > mySecondString\ndiResult := STR.Compare(myFirstString, mySecondString);\n \n\/\/\/ Unicode defined simple case folding\n\/\/\/ xEqual = TRUE --> myThirdString == myFourthString\nxEqual := UC.EqualFold(\n ADR(myThirdString.sValue), myThirdString.Len(),\n ADR(myFourthString.sValue), myFourthString.Len()\n); " }
]
$(document).trigger('search.ready');
});