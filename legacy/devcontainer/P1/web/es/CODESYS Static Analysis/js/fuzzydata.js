$(document).ready(function () {indexDict['es'] = [{ "title" : "CODESYS Static Analysis ", 
"url" : "_san_start_page.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis ", 
"snippet" : "Con CODESYS Static Analysis , se puede realizar una verificación del código fuente IEC utilizando reglas, convenciones de nomenclatura o métricas definidas. Como resultado, se resaltan los indicios de posibles problemas de desarrollo y los errores se pueden identificar y corregir antes de una prueba...", 
"body" : "Con CODESYS Static Analysis , se puede realizar una verificación del código fuente IEC utilizando reglas, convenciones de nomenclatura o métricas definidas. Como resultado, se resaltan los indicios de posibles problemas de desarrollo y los errores se pueden identificar y corregir antes de una prueba de campo. Esto puede ahorrar mucho tiempo durante el desarrollo de aplicaciones y la verificación de errores. En CODESYS Static Analysis , ya están implementadas más de 100 reglas (algunas de las cuales se pueden parametrizar). Estas reglas se pueden combinar para crear conjuntos de reglas personalizados. En algunas reglas, se incluyen los conjuntos de reglas definidos en las \"PLCopen Coding Guidelines\". También puede definir una convención de nomenclatura para cada tipo de datos posible, cuyo cumplimiento luego se verifica. Además, hay disponibles más de 20 métricas que, si se calculan periódicamente, pueden analizar el código fuente subyacente y proporcionar indicaciones de tendencias negativas y desviaciones de los objetivos de calidad. Puedes descargar el CODESYS Static Analysis de Tienda CODESYS Internacional o Tienda CODESYS Norteamérica . Allí también encontrará la ficha técnica del producto. El producto está sujeto a licencia. Webinar CODESYS Static Analysis Si CODESYS Static Analysis está instalado pero no hay ninguna licencia activada, entonces aparece una interfaz reducida con la funcionalidad de Static Analysis Light se visualiza. Como alternativa a CODESYS Static Analysis , CODESYS Development System proporciona el Static Analysis Light Añadir. El complemento forma parte automáticamente de CODESYS cuando No CODESYS Static Analysis esta instalado. " }, 
{ "title" : "Static Analysis Light ", 
"url" : "_san_start_page.html#UUID-cc139654-e7d3-fe83-903e-e33f8fd0a5ec_section-idm452529692233763389020840932", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis \/ Static Analysis Light ", 
"snippet" : "Static Analysis Light tiene un conjunto de funciones muy limitado y proporciona solo 7 comprobaciones de compilación. El producto está disponible gratuitamente. Puede habilitar las comprobaciones de compilación individualmente en el Proyecto → Configuración del proyecto menú, en el Luz de análisis e...", 
"body" : "Static Analysis Light tiene un conjunto de funciones muy limitado y proporciona solo 7 comprobaciones de compilación. El producto está disponible gratuitamente. Puede habilitar las comprobaciones de compilación individualmente en el Proyecto → Configuración del proyecto menú, en el Luz de análisis estático categoría. Para más información, ver: Configuración del proyecto: Luz de análisis estático " }, 
{ "title" : "Descripción general ", 
"url" : "_san_overview.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Descripción general ", 
"snippet" : "El análisis estático se realiza en el proyecto actual solo para el código de la aplicación. Las bibliotecas y sus códigos fuente no se analizan. CODESYS Static Analysis le ayuda durante la implementación para escribir código mejor y más legible e identificar partes del programa conflictivas o no com...", 
"body" : "El análisis estático se realiza en el proyecto actual solo para el código de la aplicación. Las bibliotecas y sus códigos fuente no se analizan. CODESYS Static Analysis le ayuda durante la implementación para escribir código mejor y más legible e identificar partes del programa conflictivas o no compatibles. En particular, se revelan posibles fuentes de error. Por ejemplo, se identifican ubicaciones donde todavía se encuentra el código de prueba. O se encuentran punteros cuyo valor 0 no se verifica antes de eliminar la referencia. O (con el SA0119 regla) se analizan las ubicaciones donde se utiliza la orientación a objetos y se transfieren a otro entorno de desarrollo, que no admite la orientación a objetos, por lo que es imposible. Como resultado, se puede garantizar la portabilidad del código. Para los errores que informa Static Analysis basándose en información de precompilación, existe soporte para un manejo de errores inmediato (\"Quickfix\"). Esto le permite encontrar y corregir rápidamente las ubicaciones en el código que se informan durante el análisis. Para mejorar la legibilidad del código fuente, puede definir convenciones de nomenclatura y comprobar su cumplimiento. Además, para evaluar la calidad del código, puede ver las métricas determinadas a partir del código fuente. Los ejemplos incluyen la métrica McCabe como medida de la capacidad de prueba del código, o la complejidad cognitiva como medida de la legibilidad y mantenibilidad del código fuente. El análisis del flujo de datos realizado en el análisis estático se basa en el principio de propagación constante. Con el Crear → Realizar análisis estático comando de menú, activa explícitamente el análisis estático. En el Configuración En el cuadro de diálogo, habilita un análisis estático que se realiza automáticamente después de cada compilación de código. Tú usas declaraciones pragmáticas para excluir partes individuales o bloques de código del análisis. En el Reglas En el cuadro de diálogo, puede averiguar qué reglas están configuradas, cómo se activan y cuándo se ejecutan las comprobaciones en la regla respectiva. Allí activas las reglas que sean relevantes para ti. En el Convenciones de nomenclatura En el cuadro de diálogo, asigna un prefijo a cada tipo de datos como se espera en las declaraciones. Se informan las desviaciones. En el Configuración de análisis estático: Métricas En el cuadro de diálogo activará las métricas relevantes para usted. Con el Mostrar complejidad cognitiva para el editor actual comando, los incrementos determinados se muestran línea por línea en el editor activo. El Mostrar valores de propagación constante para el editor actual El comando analiza en detalle el flujo de datos en el editor activo y lo muestra ruta por ruta. Dependiendo de esto, es posible realizar mejoras en el código. Para más información, ver: Reglas, Métrica, y pragmas y atributos" }, 
{ "title" : "Configurar y ejecutar análisis estático ", 
"url" : "_san_configuring_and_running.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configurar y ejecutar análisis estático ", 
"snippet" : "Utilizando un proyecto de muestra básico a continuación, encontrará los pasos y opciones más importantes para configurar y ejecutar un análisis estático. Requisitos: CODESYS Static Analysis esta instalado....", 
"body" : "Utilizando un proyecto de muestra básico a continuación, encontrará los pasos y opciones más importantes para configurar y ejecutar un análisis estático. Requisitos: CODESYS Static Analysis esta instalado. " }, 
{ "title" : "Proyecto de muestra ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-5b7b70fe166a598dc0a864631da88a82", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configurar y ejecutar análisis estático \/ Proyecto de muestra ", 
"snippet" : "Si desea reproducir el proyecto de ejemplo, cree un proyecto estándar e inserte las POU debajo de la aplicación en el árbol de dispositivos. Luego configure los ajustes de comunicación para la conexión a su local CODESYS Control Win . FUNCTION_BLOCK fb1 VAR_INPUT iVar_fb1in1 : INT; ivar_fb1in2 : INT...", 
"body" : "Si desea reproducir el proyecto de ejemplo, cree un proyecto estándar e inserte las POU debajo de la aplicación en el árbol de dispositivos. Luego configure los ajustes de comunicación para la conexión a su local CODESYS Control Win . FUNCTION_BLOCK fb1\nVAR_INPUT\n iVar_fb1in1 : INT;\n ivar_fb1in2 : INT;\n rVar_fb1in3 : REAL;\nEND_VAR\nVAR_OUTPUT\n iVar_fb1out:INT;\nEND_VAR\nVAR\n P_fSampleProperty : INT;\n rVar : REAL;\n PRO : BOOL;\nEND_VAR\n iVar_fb1out:=iVar_fb1in1 + 1; FUNCTION_BLOCK fb2\nVAR_INPUT\n iVar_fb2in:INT;\nEND_VAR\nVAR_OUTPUT\n iVar_fb2out:INT;\nEND_VAR\nVAR\nEND_VAR\n iVar_fb2out:=iVar_fb2in - 1; PROGRAM PLC_PRG\nVAR\n fb1_inst: fb1;\n fb2_inst: fb2;\nEND_VAR fb1_inst(iVar_fb1in1 := 99);\nfb2_inst(iVar_fb2in := 22);\nfb2_inst(iVar_fb2in := 1); " }, 
{ "title" : "Comprobar el cumplimiento de las normas ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9641312f166a598dc0a864630126d291", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configurar y ejecutar análisis estático \/ Comprobar el cumplimiento de las normas ", 
"snippet" : "Hacer clic Construir → Análisis estático → Configuración . Cambiar a la Reglas pestaña . Se muestra una lista que contiene todas las comprobaciones de reglas posibles. Están organizados en una estructura de árbol por categoría temática. El \"número de regla\" se agrega entre paréntesis (ejemplo: Varia...", 
"body" : "Hacer clic Construir → Análisis estático → Configuración . Cambiar a la Reglas pestaña . Se muestra una lista que contiene todas las comprobaciones de reglas posibles. Están organizados en una estructura de árbol por categoría temática. El \"número de regla\" se agrega entre paréntesis (ejemplo: Variables no utilizadas (33) en categoría Objetos no utilizados ). Haga clic en la casilla de verificación de la primera línea varias veces ( Normas nodo). Al hacer clic se alterna el estado de activación. Las casillas de verificación en todo el árbol tienen una marca de verificación roja o naranja, o ninguna marca de verificación. De esta manera, active todas las entradas con una marca de verificación roja. Esto significa que CODESYS Static Analysis debe informar cualquier infracción de regla detectada como errores. Hacer clic Construir → Análisis estático → Ejecutar análisis estático . Los errores se informan en la vista de mensajes. Los textos de los mensajes están etiquetados con un y comience con el número de error \"SA<número de regla>\". Haga doble clic en el mensaje SA0033: Variables no utilizadas 'iVar_fb2out' . El foco se mueve a la parte de declaración del bloque de funciones. fb2 y se selecciona la variable relevante. La variable se declara, pero no se utiliza. Esto está marcado en la Regla 33 ( Variables no utilizadas ). En el código, las ubicaciones relevantes están subrayadas con una línea ondulada. Para probar la ejecución automática del análisis, haga clic en Construir → Análisis estático → Configuración . Sobre el Ajustes pestaña, seleccione la Realice análisis estáticos automáticamente después de la compilación opción. Hacer clic DE ACUERDO para salir del diálogo. Hacer clic En línea → Iniciar sesión . Un mensaje de diálogo indica que existen errores de compilación. Los errores informados por el análisis de código se muestran nuevamente en la vista de mensajes. Hacer clic Construir → Análisis estático → Configuración . Cambiar a la Normas pestaña. Ahora borre todas las reglas en el cuadro de diálogo. En el Objetos no utilizados categoría, active explícitamente la Regla SA0035 ( Variables de entrada no utilizadas (35) ) con una marca de verificación de color naranja para informar una \"advertencia\". Vea la información sobre herramientas para el texto de la regla: Esta regla corresponde a las siguientes reglas PLCopen: CP24 ). Hacer clic DE ACUERDO para salir del diálogo. Hacer clic Construir → Generar código . El análisis se realiza automáticamente. En la vista de mensajes, se informan dos errores al Mensajes de análisis estático categoría: § SA0035: Entrada no utilizada 'iVar_fb1in2' § SA0035: Entrada no utilizada 'iVar_fb1in3' Haga doble clic en el mensaje y comente o elimine la declaración. Realice el análisis del código nuevamente. No se muestran mensajes de error. " }, 
{ "title" : "Comprobación del cumplimiento de las convenciones de nomenclatura definidas ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-d64b88b5166a598dc0a864632e22b38d", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configurar y ejecutar análisis estático \/ Comprobación del cumplimiento de las convenciones de nomenclatura definidas ", 
"snippet" : "Hacer clic Construir → Análisis estático → Configuración . Cambiar a la Convenciones de nombres pestaña. Verá una tabla en una estructura de árbol que está dividida en categorías ampliables de variables y bloques de programa. Ampliar la Prefijos para variables – Prefijos para tipos categoría, y en l...", 
"body" : "Hacer clic Construir → Análisis estático → Configuración . Cambiar a la Convenciones de nombres pestaña. Verá una tabla en una estructura de árbol que está dividida en categorías ampliables de variables y bloques de programa. Ampliar la Prefijos para variables – Prefijos para tipos categoría, y en la Prefijo columna, especifique I para ENTRADA (14) . Ampliar la Prefijos para POU – Prefijos para el tipo de POU categoría. En el Prefijo columna, especifique el prog para PROGRAMA (122) y fb para BLOQUE DE FUNCIONES (103) . Selecciona el El primer carácter después del prefijo debe ser una letra mayúscula. opción. Borre todas las demás opciones. Hacer clic Construir → Análisis estático → Ejecutar análisis estático . Error de mensajes: NC0102: Nombre no válido 'PLC_PRG': se espera el prefijo 'prog' porque PLC_PRG no tiene el prefijo requerido El primer carácter después del prefijo debe estar en mayúscula: 'ivar_fb1in2' porque ivar_fb1in2 : INT; es en fb1 . NC0014: Nombre de variable no válido P_fSampleProperty: Se espera prefijo 'i' porque esta variable entera no tiene el prefijo requerido. " }, 
{ "title" : "Comprobación de símbolos prohibidos ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-7e83abe1166a598dc0a86463714e1dc5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configurar y ejecutar análisis estático \/ Comprobación de símbolos prohibidos ", 
"snippet" : "Hacer clic Construir → Análisis estático → Configuración . Cambiar a la Símbolos Prohibidos pestaña . Un editor de líneas permite especificar cadenas que no deben usarse en el código. Como ejemplo, haga doble clic en la línea en blanco y escriba la cadena no válida PRO directamente. Haga doble clic ...", 
"body" : "Hacer clic Construir → Análisis estático → Configuración . Cambiar a la Símbolos Prohibidos pestaña . Un editor de líneas permite especificar cadenas que no deben usarse en el código. Como ejemplo, haga doble clic en la línea en blanco y escriba la cadena no válida PRO directamente. Haga doble clic en la siguiente línea en blanco y haga clic en el para abrir el Asistente de entrada. Desde Tipos estándar , Seleccione VERDADERO . Hacer clic OK para salir del diálogo. Hacer clic Construir → Análisis estático → Ejecutar análisis estático . Los mensajes de error Forbidden symbol 'REAL' y Forbidden symbol 'PRO' se muestran en la vista de mensajes. Haga doble clic en el texto del mensaje para saltar a la línea de código correspondiente. " }, 
{ "title" : "Visualización de métricas ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configurar y ejecutar análisis estático \/ Visualización de métricas ", 
"snippet" : "CODESYS Static Analysis realiza pruebas seleccionadas en el código y puede mostrar los resultados en una vista. Hacer clic Construir → Análisis estático → Configuración . Cambiar a la Métrica pestaña . Las métricas que CODESYS Static Analysis se aplica al código se enumeran en una tabla. Para este e...", 
"body" : "CODESYS Static Analysis realiza pruebas seleccionadas en el código y puede mostrar los resultados en una vista. Hacer clic Construir → Análisis estático → Configuración . Cambiar a la Métrica pestaña . Las métricas que CODESYS Static Analysis se aplica al código se enumeran en una tabla. Para este ejemplo, active el Número de variables de entrada métrica y especifique el rango de valores permitido: límite inferior 1 y límite superior 2 . Activa algunas métricas más, por ejemplo Tamaño del código y Número de llamadas . Hacer clic Construir → Análisis estático → Ver métricas estándar . La vista incluye una tabla con una línea para cada Unidad de programa del programa de muestra. Para cada métrica activada, hay una columna que muestra los valores medidos. Los valores que están fuera del rango de valores definido en la configuración se resaltan en rojo. En el caso de este ejemplo específico, este es al menos el PLC_PRG\/Entradas porque el número de variables de entrada en esta POU es mayor que el límite superior definido de 2 . " }, 
{ "title" : "Corrección rápida de infracciones de reglas en código ST ", 
"url" : "_san_fix_errors_quickly.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Corrección rápida de infracciones de reglas en código ST ", 
"snippet" : "En el Configuración de análisis estático diálogo, en el Reglas pestaña, puede habilitar reglas para el código ST. El cumplimiento de estas reglas se verifica en base a la información de precompilación. No es necesaria una llamada explícita del análisis estático para detectar tales violaciones de reg...", 
"body" : "En el Configuración de análisis estático diálogo, en el Reglas pestaña, puede habilitar reglas para el código ST. El cumplimiento de estas reglas se verifica en base a la información de precompilación. No es necesaria una llamada explícita del análisis estático para detectar tales violaciones de reglas. El cumplimiento de las reglas se verifica en el editor ST activo durante la precompilación y después de una compilación exitosa. Cuando se produce una infracción de una regla, se muestra inmediatamente en el editor ST mediante un subrayado ondulado. Además, en la vista de mensajes, los mensajes de error o las advertencias se enumeran en la precompilar vista. Para obtener instrucciones, consulte: Comprobación del cumplimiento de las convenciones de nomenclatura definidasPuede encontrar el Quickfix en el editor ST haciendo clic en el código con el subrayado ondulado y luego haciendo clic en el símbolo de la bombilla , o en la vista de mensajes mediante el en la línea del mensaje de error. En cada caso, se le proporcionan los comandos correspondientes para manejar la infracción de la regla. Para Quickfix, se proporcionan los siguientes comandos, cada uno dependiendo del error: Ignorar error\/advertencia El comando se usa para insertar automáticamente pragmas o atributos en el código, que excluyen una verificación de la regla correspondiente para esta línea de código. Ignorar error\/advertencia globalmente para <nombre de objeto de programación> El comando se utiliza para insertar automáticamente un atributo al comienzo de la parte de declaración del objeto de programación. Entonces se excluye una verificación de la regla correspondiente para este objeto de programación. Comando con una sugerencia sobre cómo cambiar el código ST para evitar la violación de la regla (Quickfix). Ejemplo: SA0168: Quitar asignación 'enum1 := 5' Desactivar verificación El comando se usa para deshabilitar la verificación de la regla correspondiente en la configuración. Puede deshacer los efectos de llamar a cualquiera de los comandos. Para ello, primero haga clic en el Dispositivos ver (o POU vista). Entonces la Deshacer el comando está habilitado. " }, 
{ "title" : "Habilitación de reglas ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-1cca77b1336bf579c0a8646302e5e6f3", 
"breadcrumbs" : "CODESYS Static Analysis \/ Corrección rápida de infracciones de reglas en código ST \/ Habilitación de reglas ", 
"snippet" : "Hacer clic Construir → Análisis estático → Configuración . Cambiar a la Reglas pestaña. Se muestra una lista que contiene todas las comprobaciones de reglas posibles. Están organizados en una estructura de árbol por categoría temática. El \"número de regla\" se añade entre paréntesis. Puede filtrar la...", 
"body" : "Hacer clic Construir → Análisis estático → Configuración . Cambiar a la Reglas pestaña. Se muestra una lista que contiene todas las comprobaciones de reglas posibles. Están organizados en una estructura de árbol por categoría temática. El \"número de regla\" se añade entre paréntesis. Puede filtrar las reglas, ordenarlas por opciones o mostrarlas en una lista. Haga clic en el Pantalla estructurada filtro ( símbolo) y, a continuación, seleccione el Estructurado por Momento de Ejecución opción. Las reglas que también se pueden verificar durante la precompilación se enumeran debajo del Ejecutado durante la precompilación y después de una compilación exitosa nodo. Estas son las reglas que se identifican con una marca de verificación en el Precompilar columna. En la columna de la izquierda, ahora puede habilitar la regla para la verificación. Haga clic en la casilla de verificación en la línea de la regla (168) para que el estado cambie de \"marca de verificación roja\" a \"marca de verificación amarilla\" a \"sin marca de verificación\". Una marca de verificación roja significa que la infracción de la regla se emite como un mensaje de error. Una marca de verificación amarilla significa que la infracción de la regla se emite como una advertencia. Sin marca de verificación significa que la regla no está marcada. Las reglas habilitadas ahora están marcadas. En caso de infracción, se marcan en el código y se muestran en la vista de mensajes. " }, 
{ "title" : "Visualización de infracciones de reglas en la vista de mensajes ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8f3e8ec3336bf579c0a86463654e2139", 
"breadcrumbs" : "CODESYS Static Analysis \/ Corrección rápida de infracciones de reglas en código ST \/ Visualización de infracciones de reglas en la vista de mensajes ", 
"snippet" : "Hacer clic Ver → Mensajes . Se abre la vista de mensajes. En la vista de mensajes, en el cuadro de lista, seleccione el precompilar categoría. En esta categoría, solo se muestran las infracciones de reglas que se han detectado durante la precompilación y después de una compilación exitosa, y que pue...", 
"body" : "Hacer clic Ver → Mensajes . Se abre la vista de mensajes. En la vista de mensajes, en el cuadro de lista, seleccione el precompilar categoría. En esta categoría, solo se muestran las infracciones de reglas que se han detectado durante la precompilación y después de una compilación exitosa, y que puede resolver con Quickfix. El El botón proporciona los comandos respectivos para esto. " }, 
{ "title" : "Realización de una corrección rápida ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8a9adfb3336bf579c0a8646308d0b385", 
"breadcrumbs" : "CODESYS Static Analysis \/ Corrección rápida de infracciones de reglas en código ST \/ Realización de una corrección rápida ", 
"snippet" : "En la configuración, la Regla 168 está habilitada y se muestra una violación de la regla en el editor ST. Requisito: al menos una línea tiene un subrayado ondulado en el código ST y el número SA correspondiente se muestra en la vista de mensajes. Haga clic en la línea de código con el subrayado ondu...", 
"body" : "En la configuración, la Regla 168 está habilitada y se muestra una violación de la regla en el editor ST. Requisito: al menos una línea tiene un subrayado ondulado en el código ST y el número SA correspondiente se muestra en la vista de mensajes. Haga clic en la línea de código con el subrayado ondulado. El se muestra el símbolo. Haz clic en el símbolo de la bombilla. Se abre una ventana con comandos de menú para el manejo de errores. Quiere corregir el error. Por lo tanto, haga clic en el comando Asignación 'enum1 := GVL.CONST' . Ahora la línea de código se cambia automáticamente, como se muestra en el comando. El error está arreglado. El tercer comando incluye una sugerencia sobre cómo corregir el error cambiando el código, según la infracción de la regla. El mismo manejo de errores es posible haciendo clic en el en la línea de mensajes de error de la vista de mensajes. " }, 
{ "title" : "Deshabilitar la verificación de reglas para una línea de código ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-107e44f0336bf579c0a8646347e7d5cc", 
"breadcrumbs" : "CODESYS Static Analysis \/ Corrección rápida de infracciones de reglas en código ST \/ Deshabilitar la verificación de reglas para una línea de código ", 
"snippet" : "En la configuración, la Regla 168 está habilitada y se muestra una violación de la regla en el editor ST. Requisito: al menos una línea tiene un subrayado ondulado en el código ST y el número SA correspondiente se muestra en la vista de mensajes. Haga clic en la línea de código con el subrayado ondu...", 
"body" : "En la configuración, la Regla 168 está habilitada y se muestra una violación de la regla en el editor ST. Requisito: al menos una línea tiene un subrayado ondulado en el código ST y el número SA correspondiente se muestra en la vista de mensajes. Haga clic en la línea de código con el subrayado ondulado. El se muestra el símbolo. Haz clic en el símbolo de la bombilla. Se abre una ventana con comandos de menú para el manejo de errores. No desea corregir el error. Por lo tanto, haga clic en el comando Ignorar error\/advertencia . Ahora la línea de código recibe automáticamente pragmas. Los pragmas se utilizan para evitar que se verifique la línea de la regla afectada. No se emite ningún mensaje de error o advertencia. El comando para deshabilitar la verificación de reglas para la línea de código afectada también está disponible a través de la en la línea del mensaje de error en la vista de mensajes. " }, 
{ "title" : "Deshabilitar la verificación de reglas para un objeto de programación ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-6dee377f336bf579c0a8646357b65fa8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Corrección rápida de infracciones de reglas en código ST \/ Deshabilitar la verificación de reglas para un objeto de programación ", 
"snippet" : "En la configuración, la Regla 168 está habilitada y se muestra una violación de la regla en el editor ST. Requisito: Al menos una línea tiene un subrayado ondulado en el código ST y el número SA correspondiente se muestra en la vista de mensajes. Haga clic en la línea de código con el subrayado ondu...", 
"body" : "En la configuración, la Regla 168 está habilitada y se muestra una violación de la regla en el editor ST. Requisito: Al menos una línea tiene un subrayado ondulado en el código ST y el número SA correspondiente se muestra en la vista de mensajes. Haga clic en la línea de código con el subrayado ondulado. El se muestra el símbolo. Haz clic en el símbolo de la bombilla. Se abre una ventana con comandos de menú para el manejo de errores. No desea que el objeto de programación se verifique con la regla especificada. Por lo tanto, haga clic en el segundo comando Ignorar error\/advertencia globalmente para PLC_PRG . La declaración del objeto ahora se proporciona automáticamente con un atributo. El atributo se utiliza para evitar que la regla afectada se compruebe para el objeto. No se emite un mensaje de error o advertencia. El comando para ignorar el mensaje también está disponible mediante el en la línea del mensaje de error en la vista de mensajes. " }, 
{ "title" : "Deshabilitar la comprobación de reglas en general ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Corrección rápida de infracciones de reglas en código ST \/ Deshabilitar la comprobación de reglas en general ", 
"snippet" : "En la configuración, la Regla 168 está habilitada y se muestra una violación de la regla en el editor ST. Requisito: Al menos una línea tiene un subrayado ondulado en el código ST y el número SA correspondiente se muestra en la vista de mensajes. Haga clic en la línea de código con el subrayado ondu...", 
"body" : "En la configuración, la Regla 168 está habilitada y se muestra una violación de la regla en el editor ST. Requisito: Al menos una línea tiene un subrayado ondulado en el código ST y el número SA correspondiente se muestra en la vista de mensajes. Haga clic en la línea de código con el subrayado ondulado. El se muestra el símbolo. Haz clic en el símbolo de la bombilla. Se abre una ventana con comandos de menú para el manejo de errores. No desea que se vuelva a comprobar la regla mostrada. Por lo tanto, haga clic en el cuarto comando Desactivar verificación . La regla está deshabilitada en la configuración de análisis estático. Hacer clic Construir → Análisis estático → Configuración . Cambiar a la Reglas pestaña. Se inhabilita la regla 168. El comando para deshabilitar globalmente la verificación también está disponible mediante el en la línea del mensaje de error en la vista de mensajes. " }, 
{ "title" : "Definición de convenciones de nomenclatura ", 
"url" : "_san_define_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definición de convenciones de nomenclatura ", 
"snippet" : "En el Configuración de análisis estático diálogo, en el Convenciones de nombres pestaña, defina las convenciones de nomenclatura que seguirá en su código. Defina prefijos para los identificadores de sus POU, variables y tipos de datos según sus alcances y calificadores. Luego, puede dejar que el aná...", 
"body" : "En el Configuración de análisis estático diálogo, en el Convenciones de nombres pestaña, defina las convenciones de nomenclatura que seguirá en su código. Defina prefijos para los identificadores de sus POU, variables y tipos de datos según sus alcances y calificadores. Luego, puede dejar que el análisis estático verifique el cumplimiento de las convenciones de nomenclatura. Para obtener instrucciones, consulte: Comprobación del cumplimiento de las convenciones de nomenclatura definidas" }, 
{ "title" : "Definición de prefijos ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-291ced2808fb693bc0a8646323d0819d", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definición de convenciones de nomenclatura \/ Definición de prefijos ", 
"snippet" : "En el Configuración de análisis estático diálogo, en el Convenciones de nombres pestaña, defina las convenciones de nomenclatura en el campo de entrada de la Prefijo columna. Caracter literal Ejemplo: PRG_ en Prefijos para POU , Prefijos para el tipo de POU , PROGRAMA (102) Múltiples literales por e...", 
"body" : "En el Configuración de análisis estático diálogo, en el Convenciones de nombres pestaña, defina las convenciones de nomenclatura en el campo de entrada de la Prefijo columna. Caracter literal Ejemplo: PRG_ en Prefijos para POU , Prefijos para el tipo de POU , PROGRAMA (102) Múltiples literales por entrada que están separados por una coma Sintaxis: <prefix> ( , <next prefix> )* Ejemplo: PRG_, PRG en Prefijos para POU , Prefijos para el tipo de POU , PROGRAMA (102) Expresión regular RegEx que define un conjunto de prefijos Sintaxis: @ <expression> Ejemplos: @x[a-dA-D] define un prefijo que comienza con x , seguido de exactamente un carácter en el conjunto a-dA-D @[A-Za-z][A-Za-z][A-Za-z][A-Za-z0-9] define un prefijo que consta de cuatro caracteres: los primeros tres caracteres son letras y el cuarto carácter también puede ser un número. " }, 
{ "title" : "Definición de prefijos para tipos de datos combinables ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e9a24404c19ad708c0a86463215af896", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definición de convenciones de nomenclatura \/ Definición de prefijos para tipos de datos combinables ", 
"snippet" : "Los siguientes tipos de datos se basan en tipos de datos estándar, tipos de datos existentes o bloques de funciones: Puntero: POINTER TO <basic type> Referencia: REFERENCE TO <basic type> Formación: ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> Estos tipos de datos se pueden an...", 
"body" : "Los siguientes tipos de datos se basan en tipos de datos estándar, tipos de datos existentes o bloques de funciones: Puntero: POINTER TO <basic type> Referencia: REFERENCE TO <basic type> Formación: ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> Estos tipos de datos se pueden anidar y combinar entre sí. Cuando el Prefijos recursivos para tipos de datos combinables está seleccionada, Static Analysis espera prefijos combinados recursivamente para variables de tales tipos de datos combinables. Los prefijos siguen a la declaración y corresponden a las convenciones de nomenclatura definidas para los tipos de datos básicos. Ejemplo Se han establecido las siguientes convenciones de nomenclatura: i en Prefijos para variables , INT (26) p en Prefijos para variables , PUNTERO (26) ref en Prefijos para variables , REFERENCIA (27) struct en Prefijos para variables , Estructura (32) Prefijos recursivos para tipos de datos combinables opción: El siguiente código infringe las convenciones de nomenclatura y es difícil de leer. PROGRAM plc1\nVAR\n var1 : ARRAY[100..110] OF ARRAY[30..50] OF ARRAY[6..7] OF BOOL;\n var2 : ARRAY[1..3] OF INT;\n var3 : REFERENCE TO INT;\n iVar4 : INT;\n iVar5 : INT;\n var6 : ARRAY[1..3] OF INT := [11, 22, 33];\n var7 : POINTER TO ARRAY[1..3] OF INT;\n var8 : REFERENCE TO INT;\n var9 : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n var0 : ARRAY[0..3] OF S_POLYGONLINE; \/\/ S_POLYGONLINE is a already defined structure\nEND_VAR\n\niVar4 := iVar4 + 1;\nvar8 REF= iVar4;\nvar1[100][30][6] := TRUE;\nvar9.aiPoint1[1] := 99;\nvar7 := ADR(var6);\nvar6[2] := 44;\niVar5 := var7^[2];\nvar0[0] := var9; Static Analysis informa de las siguientes violaciones de las convenciones de nomenclatura: NC0102: Nombre no válido 'plc1': Prefijo esperado 'PRG_' NC0014: Nombre de variable no válido 'var0': Prefijo esperado 'astruct' NC0014: Nombre de variable no válido 'var1': Prefijo esperado 'aaax' NC0014: Nombre de variable no válido 'var2': Prefijo esperado 'ai' NC0014: Nombre de variable no válido 'var3': Prefijo esperado 'refi' NC0014: Nombre de variable no válido 'var6': Prefijo esperado 'ai' NC0014: Nombre de variable no válido 'var7': Prefijo esperado 'pai' NC0014: Nombre de variable no válido 'var8': Prefijo esperado 'refi' NC0014: Nombre de variable no válido 'var9': Prefijo esperado 'struct' " }, 
{ "title" : "Definición de prefijos para variables de un alias ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9f66c39a945e11eab0a0b46479d263a5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definición de convenciones de nomenclatura \/ Definición de prefijos para variables de un alias ", 
"snippet" : "Puede definir prefijos para variables de tipo de datos Alias como un literal con el marcador de posición {datatype} . Luego, Static Analysis espera el prefijo del tipo de datos base en lugar del marcador de posición. El Combine el prefijo de ámbito con el prefijo de tipo de datos opción no tiene nin...", 
"body" : "Puede definir prefijos para variables de tipo de datos Alias como un literal con el marcador de posición {datatype} . Luego, Static Analysis espera el prefijo del tipo de datos base en lugar del marcador de posición. El Combine el prefijo de ámbito con el prefijo de tipo de datos opción no tiene ningún efecto sobre el uso del prefijo {datatype} . Ejemplo Se han establecido las siguientes convenciones de nomenclatura: s en Prefijos para variables , Prefijos para tipos , CADENA()19 A_{datatype} en Prefijos para variables , Alias (33) Código TYPE A_MESSAGE : STRING[50]; \/\/ base data type is STRING\nEND_TYPE\n\nVAR\n A_sMessage_N1 : A_MESSAGE := 'Robot is running.';\n A_s_Message_N2 : A_MESSAGE := 'Robot has been finished.';\n As_Message_N3 : A_MESSAGE := 'Robot has been stopped.';\n AsMessage_N4 : A_MESSAGE := 'Error 3 has been occured.';\nEND_VAR Static Analysis informa de la siguiente violación de la convención de nomenclatura: NC0033: Nombre de variable no válido 'As_Message_N3': Prefijo esperado 'A_s' NC0033: Nombre de variable no válido 'AsMessage_N4': Prefijo esperado 'A_s' " }, 
{ "title" : "Definición de prefijos para propiedades ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e0cda739c19ad708c0a864636e955ca0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definición de convenciones de nomenclatura \/ Definición de prefijos para propiedades ", 
"snippet" : "Puede definir el prefijo para POU de tipo de datos PROPERTY como un literal con el marcador de posición {datatype} . Luego, Static Analysis espera el prefijo del tipo de datos de retorno de la propiedad en lugar del marcador de posición. El Combine el prefijo de ámbito con el prefijo de tipo de dato...", 
"body" : "Puede definir el prefijo para POU de tipo de datos PROPERTY como un literal con el marcador de posición {datatype} . Luego, Static Analysis espera el prefijo del tipo de datos de retorno de la propiedad en lugar del marcador de posición. El Combine el prefijo de ámbito con el prefijo de tipo de datos opción no tiene ningún efecto sobre el uso del marcador de posición {datatype} . Ejemplo Se han establecido las siguientes convenciones de nomenclatura: fb en Prefijos para variables , Prefijos para tipos , Instancia de bloque de funciones FB_ en Prefijos para POU , Prefijos para el tipo de POU , BLOQUE DE FUNCIONES (103) prop_{datatype} en Prefijos para POU , Prefijos para el tipo de POU , PROPIEDAD (107) Código FUNCTION_BLOCK blocka \/\/ Invalid function block name\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC vara : INT \/\/ Invalid property name, return data type is INT\nGet\n vara := iA;\nSet\niA := vara;\n\nPROGRAM plc1\nVAR\n var10 : blocka; \/\/ Invalid variable name of typ function block\n iVar11: INT;\nEND_VAR\n\nvar10();\nIF var10.vara > 500 THEN\n var10.vara := 0;\nEND_IF\niVar11 := var10.vara; Static Analysis informa de la siguiente violación de las convenciones de nomenclatura: NC0102: Nombre no válido 'plc1': Prefijo esperado 'PRG_' NC0031: Nombre de variable no válido 'var10': Prefijo esperado 'fb' NC0103: Nombre de variable no válido ''blocka': Prefijo esperado 'FB_' NC0107: Nombre de variable no válido 'blocka.vara': Prefijo esperado 'prop_i' Codificar de acuerdo con las convenciones de nomenclatura FUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC prop_iA : INT\nGet\n prop_iA := iA;\nSet\n iA := prop_iA;\n\nPROGRAM PRG_PLC1\nVAR\n fbA : FB_A;\n iVar11: INT;\nEND_VAR\n\nfbA();\nIF fbA.prop_iA > 500 THEN\n fbA.prop_iA := 0;\nEND_IF\niVar11 := fbA.prop_iA; " }, 
{ "title" : "Definición de prefijos para estructuras ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-ed64228609104c08c0a864630c58c86b", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definición de convenciones de nomenclatura \/ Definición de prefijos para estructuras ", 
"snippet" : "Puede definir un prefijo general para estructuras en el proyecto en Prefijos para DUT , Estructura (151) . También puede dar a una estructura un prefijo especial. El prefijo especial anula el prefijo general. El prefijo especial se define en la declaración del tipo de datos de la estructura con el p...", 
"body" : "Puede definir un prefijo general para estructuras en el proyecto en Prefijos para DUT , Estructura (151) . También puede dar a una estructura un prefijo especial. El prefijo especial anula el prefijo general. El prefijo especial se define en la declaración del tipo de datos de la estructura con el pragma {attribute 'nameprefix' := <special prefix> '} . Luego comience todas las variables de esta estructura con este prefijo <special prefix> . Ejemplo Se han establecido las siguientes convenciones de nomenclatura: struct en Prefijos para variables , Estructura (32) S_ en Prefijos para DUT , Estructura (151) Prefijos recursivos para tipos de datos combinables : Código TYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE\n\n{attribute 'nameprefix' := 'penta'} \/\/ Pragma to define a special prefix\nTYPE S_PENTA EXTENDS S_POLYGONLINE :\nSTRUCT\n aiPoint5 : ARRAY[1..2] OF INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PRG_Compute\nVAR\n structPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n structPentagon : S_PENTAGON := (aiStart:=[0,0], aiPoint1:=[1,1], aiPoint2:=[2,2], aiPoint3:=[3,3], aiPoint4:=[4,4], aiPoint5:=[5,5]);\n structLine0 : S_PENTA;\n pentaLine1 : S_PENTA;\n iXPoint: INT;\n aPoint0: ARRAY [1..2] OF INT;\n aPoint1: ARRAY [1..2] OF INT;\nEND_VAR\n\niXPoint := structPolygon.aiPoint1[1];\naPoint0 := structLine0.aiEnd;\naiPoint1 := pentaLine1.aiEnd; Static Analysis informa de la siguiente violación de las convenciones de nomenclatura: Nombre de variable no válido 'structLine0': Prefijo esperado 'penta' " }, 
{ "title" : "Proporcionar otros CODESYS Static Analysis proyectos con convenciones de nomenclatura ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definición de convenciones de nomenclatura \/ Proporcionar otros CODESYS Static Analysis proyectos con convenciones de nomenclatura ", 
"snippet" : "Guarde sus convenciones de nomenclatura en un archivo CSA. Puede cargar y utilizar este archivo en otros CODESYS Static Analysis proyectos Guardar en un archivo Hacer clic Construir → Análisis estático → Configuración . Haga clic en el Ahorrar botón. Se abre un cuadro de diálogo de selección de arch...", 
"body" : "Guarde sus convenciones de nomenclatura en un archivo CSA. Puede cargar y utilizar este archivo en otros CODESYS Static Analysis proyectos Guardar en un archivo Hacer clic Construir → Análisis estático → Configuración . Haga clic en el Ahorrar botón. Se abre un cuadro de diálogo de selección de archivos. Allí puede almacenar las convenciones de nomenclatura en un archivo con cualquier nombre con la extensión de archivo CSA. Cargar un archivo con convenciones de nomenclatura Hacer clic Construir → Análisis estático → Configuración . Haga clic en el Carga botón. Se abre el cuadro de diálogo de selección de archivos. Seleccione uno de los archivos CSA que se muestran a continuación. " }, 
{ "title" : "Detección de clones de código ", 
"url" : "_san_find_code_clone.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Detección de clones de código ", 
"snippet" : "Requisitos: CODESYS Static Analysis esta instalado. A CODESYS El proyecto está abierto. El proyecto incluye el mismo bloque de código en al menos dos objetos de programación. Hacer clic  Construir → Análisis estático → Detectar clones . El Resultados de la detección de clones se abre la vista. Hacer...", 
"body" : "Requisitos: CODESYS Static Analysis esta instalado. A CODESYS El proyecto está abierto. El proyecto incluye el mismo bloque de código en al menos dos objetos de programación. Hacer clic  Construir → Análisis estático → Detectar clones . El Resultados de la detección de clones se abre la vista. Hacer clic Resultados . Los clones de código detectados se muestran como una vista de árbol en una ventana. Si, además de clones de código idénticos, también hay clones de código con desviaciones, estos nodos secundarios se resaltan en color en la vista de árbol. En la vista de árbol, seleccione dos clones de código de un nodo secundario y haga clic en el Mostrar clones seleccionados botón. Los dos objetos de programación que contienen este código duplicado se abren en el editor y se muestran en la parte superior de la vista. Los clones de código idénticos se resaltan en amarillo claro y los clones de código con desviaciones, como los nombres de las variables ivar3 y ivarx en este ejemplo, están resaltados en rojo. Para crear una función a partir del clon de código idéntico del objeto de programación POU_1 , primero haga doble clic en la vista de árbol en la fila con el clon de código de Objeto POU_1 . El objeto de programación POU_1 se abre en el editor, y en la parte de implementación se resaltan las cuatro filas que contienen el código duplicado. Cuando haces clic en el Extraer función comando en el menú contextual del bloque de código resaltado, el bloque de código se extrae de POU_1 y se crea un nuevo método a partir de él. El bloque de código en la parte de implementación de POU_1 se reemplaza automáticamente por la llamada del método. En el segundo objeto de programación, debe eliminar el código duplicado manualmente y reemplazar la llamada del método. En una versión posterior, la funcionalidad se ampliará para que el bloque de código duplicado se extraiga automáticamente de ambos objetos de programación y pueda ser reemplazado por la llamada de función correcta. " }, 
{ "title" : "Propagación constante ", 
"url" : "_san_constant_propagation.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagación constante ", 
"snippet" : "Con el CODESYS Static Analysis versión V5.0.0.0, el análisis del código se basa en la propagación constante. Los resultados de la propagación constante se utilizan para diversas comprobaciones. Por ejemplo, comprueba si los punteros no son iguales a 0 o si los índices de la matriz están fuera del ra...", 
"body" : "Con el CODESYS Static Analysis versión V5.0.0.0, el análisis del código se basa en la propagación constante. Los resultados de la propagación constante se utilizan para diversas comprobaciones. Por ejemplo, comprueba si los punteros no son iguales a 0 o si los índices de la matriz están fuera del rango válido. Puede respaldar eficazmente el análisis estático con solo saber cómo funciona este análisis y cuáles son sus limitaciones. " }, 
{ "title" : "Propagación constante ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078132035233833484992758", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagación constante \/ Propagación constante ", 
"snippet" : "El análisis estático intenta determinar el valor de una variable en función de su uso. Ejemplo PROGRAM PLC_PRG \/\/Declaration VAR x: INT; bTest: BOOL; END_VAR \/\/Implementation x := 99; IF x < 100 THEN bTest := TRUE; END_IF En la implementación en la línea 1, la propagación constante registra el valor...", 
"body" : "El análisis estático intenta determinar el valor de una variable en función de su uso. Ejemplo PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT;\n bTest: BOOL;\nEND_VAR \/\/Implementation\nx := 99;\nIF x < 100 THEN\n bTest := TRUE;\nEND_IF En la implementación en la línea 1, la propagación constante registra el valor 99 para la variable x utilizar este valor para análisis posteriores. El análisis luego reconoce que la expresión en el siguiente IF -Declaración constante TRUE es. " }, 
{ "title" : "Propagación constante realizada localmente ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4525765239721633833551650952", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagación constante \/ Propagación constante \/ Propagación constante realizada localmente ", 
"snippet" : "Un valor se determina sólo localmente en el bloque de funciones. Es irrelevante cómo se pasa una entrada. Los resultados de las llamadas a funciones también son irrelevantes. Ejemplo FUNCTION Func : BOOL \/\/Declaration VAR_INPUT bText : BOOL; END_VAR \/\/Implementation IF bTest THEN Func := OtherFunc(T...", 
"body" : "Un valor se determina sólo localmente en el bloque de funciones. Es irrelevante cómo se pasa una entrada. Los resultados de las llamadas a funciones también son irrelevantes. Ejemplo FUNCTION Func : BOOL\n\/\/Declaration\nVAR_INPUT\n bText : BOOL;\nEND_VAR \/\/Implementation\nIF bTest THEN\n Func := OtherFunc(TRUE);\nEND_IF Incluso si el parámetro bTest se establece en TRUE en cada llamada, esto no tiene ningún efecto sobre la propagación constante. Incluso si OtherFunc(TRUE) siempre regresa TRUE , esto no tiene ningún efecto sobre la propagación constante. " }, 
{ "title" : "Sólo las variables temporales tienen valores iniciales. ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505885763755233833526533567", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagación constante \/ Propagación constante \/ Sólo las variables temporales tienen valores iniciales. ", 
"snippet" : "Las variables locales estáticas en programas y bloques de funciones no asumen ningún valor inicial. Las variables conservan sus valores de la última llamada y, por lo tanto, en principio pueden ser \"cualquier cosa\". Las variables locales en funciones y las variables temporales tienen un valor inicia...", 
"body" : "Las variables locales estáticas en programas y bloques de funciones no asumen ningún valor inicial. Las variables conservan sus valores de la última llamada y, por lo tanto, en principio pueden ser \"cualquier cosa\". Las variables locales en funciones y las variables temporales tienen un valor inicial en cada llamada. La propagación constante se calcula con este valor inicial. Ejemplo PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT := 6;\n bTest: BOOL;\nEND_VAR\nVAR_TEMP\n y : INT := 8;\nEND_VAR bText := x < y; La variable y se ejecuta cada vez PLC_PRG tiene el valor 8. La variable x , sin embargo, no necesariamente. Por lo tanto, la propagación constante sólo se utiliza para y asumir un valor, pero no por x . Se recomienda declarar variables que siempre se escriben primero y luego se leen como variables temporales. " }, 
{ "title" : "La propagación constante determina rangos de valores para tipos de datos numéricos. ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078129465633833541363136", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagación constante \/ Propagación constante \/ La propagación constante determina rangos de valores para tipos de datos numéricos. ", 
"snippet" : "Para reducir la complejidad, se determina un rango de valores con límites superior e inferior para cada variable. Ejemplo PROGRAM PLC_PRG VAR x: INT := 6; bTest: BOOL; y : INT; END_VAR \/\/Implementation IF bTest THEN x := 1; ELSSE x := 100; END_IF IF x = 77 THEN y := 13; END_IF Aquí el rango de valor...", 
"body" : "Para reducir la complejidad, se determina un rango de valores con límites superior e inferior para cada variable. Ejemplo PROGRAM PLC_PRG\nVAR\n x: INT := 6;\n bTest: BOOL;\n y : INT; \nEND_VAR\n \/\/Implementation\nIF bTest THEN\n x := 1;\nELSSE\n x := 100;\nEND_IF\nIF x = 77 THEN\n y := 13;\nEND_IF Aquí el rango de valores. [1..100] se determina para la variable x . Como resultado, en la línea 7, la comparación x = 77 no se reconoce como una expresión constante porque 77 está dentro del rango de valores. " }, 
{ "title" : "Las expresiones complejas recurrentes no se reconocen como la misma variable. ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4581954142281633833566535545", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagación constante \/ Propagación constante \/ Las expresiones complejas recurrentes no se reconocen como la misma variable. ", 
"snippet" : "Es posible que las expresiones complejas no tengan un valor asignado. Si este tipo de expresiones aparecen varias veces, resulta útil introducir una variable auxiliar. Ejemplo PROGRAM PLC_PRG VAR x: DINT; py : POINTER TO INT; y : INT; testArray : ARRAY [0..4] OF DINT; END_VAR \/\/Implementation IF py^...", 
"body" : "Es posible que las expresiones complejas no tengan un valor asignado. Si este tipo de expresiones aparecen varias veces, resulta útil introducir una variable auxiliar. Ejemplo PROGRAM PLC_PRG\nVAR\n x: DINT;\n py : POINTER TO INT;\n y : INT; \n testArray : ARRAY [0..4] OF DINT; \nEND_VAR\n \/\/Implementation\nIF py^ >= 0 AND py^<= 4 THEN\n x := testArray[py^];\nEND_IF\ny := py^;\nIF y <= 0 AND y <=4 THEN\n x := testArray[y];\nEND_IF En la línea 2 se emite error por un posible acceso mediante puntero a un valor, aunque se comprueba la zona a la que apunta el puntero. Si el valor se copia primero en una variable local y se verifica su rango, entonces la propagación constante puede determinar el rango de valores para esa variable y permite el acceso a la matriz en la línea 7. " }, 
{ "title" : "Derivación ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078204272033833577361725", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagación constante \/ Propagación constante \/ Derivación ", 
"snippet" : "Para las bifurcaciones, las ramas individuales se calculan por separado. A continuación, los rangos de valores de los rangos individuales se combinan para formar un nuevo rango de valores. Ejemplo \/\/Implementation IF func(TRUE) THEN x := 1; ELSE x := 10; END_IF IF func(FALSE) THEN y := x; ELSE Y := ...", 
"body" : "Para las bifurcaciones, las ramas individuales se calculan por separado. A continuación, los rangos de valores de los rangos individuales se combinan para formar un nuevo rango de valores. Ejemplo \/\/Implementation\nIF func(TRUE) THEN\n x := 1;\nELSE \n x := 10;\nEND_IF\n\nIF func(FALSE) THEN\n y := x;\nELSE\n Y := 2*x;\nEND_IF En la línea 6, x tiene el rango [1..10] . Después de la línea 11, y tiene el rango de valores [1..20] ; esto resulta de la unión de los dos rangos de valores [1..10] y [2..20] . " }, 
{ "title" : "Condiciones ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505886343398433833583258632", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagación constante \/ Propagación constante \/ Condiciones ", 
"snippet" : "Ejemplo Las condiciones pueden restringir el rango de valores de una variable en un bloque de código. Se pueden combinar varias condiciones. Las condiciones mutuamente excluyentes también pueden dar como resultado un rango de valores vacío. IF y > 0 AND y < 10 THEN x := y; ELSE x:= 0; END_IF IF x < ...", 
"body" : "Ejemplo Las condiciones pueden restringir el rango de valores de una variable en un bloque de código. Se pueden combinar varias condiciones. Las condiciones mutuamente excluyentes también pueden dar como resultado un rango de valores vacío. IF y > 0 AND y < 10 THEN\n x := y;\nELSE\n x:= 0;\nEND_IF\nIF x < 0 THEN\n i := 99;\nEND_IF y tiene el rango de valores [1..9] en la línea 2. Esto da como resultado el rango de valores [0..9] para x en la línea 6. Combinado con la condición x < 0 , esto da como resultado un conjunto vacío de valores posibles para x en la línea 8. No se puede acceder al código. El análisis estático informará que la condición x < 0 siempre regresa FALSE en este punto. " }, 
{ "title" : "Bucle ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4649940201660833833593476437", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagación constante \/ Propagación constante \/ Bucle ", 
"snippet" : "La propagación constante hará un bucle en el código hasta que los valores de las variables en el bucle ya no cambien. Se supone que un bucle se puede ejecutar cualquier número de veces. Los valores determinados hasta ahora se combinan con los valores anteriores. Las variables que se modifican dentro...", 
"body" : "La propagación constante hará un bucle en el código hasta que los valores de las variables en el bucle ya no cambien. Se supone que un bucle se puede ejecutar cualquier número de veces. Los valores determinados hasta ahora se combinan con los valores anteriores. Las variables que se modifican dentro del bucle tienen un rango cada vez mayor. Aquí, la propagación constante no toma todos los valores posibles para los rangos, sino que utiliza sólo los límites que aparecen en el código y también los valores 0, 1, 2, 3 y 10 porque suelen ser relevantes. Ejemplo La forma más sencilla de describir el procedimiento es con el ejemplo: PROGRAM PLC_PRG\nVAR\n x: DINT;\n i : DINT;\n y : DINT;\nEND_VAR \/\/Implementation\nx := 0;\ny := 0;\nFOR i := 0 TO 5 DO\n x := x + 1;\n y := i;\nEND_FOR La propagación constante sabe lo siguiente sobre el bucle: i , x , y y son 0 al comienzo de la primera ejecución del bucle. La condición i <= 5 se aplica al código en el bucle. La condición i > 5 se aplica al código después del bucle. Para los valores de las variables en el bucle, la propagación constante determina los siguientes valores: i x y [0..5] [0..MAXDINT] [0..5] En detalle, se pasan por los siguientes pasos intermedios: Aprobar i x y 1 0 [0..1] 0 i se inicializó con 0; y siempre obtiene los mismos valores que i. 2 [0..1] [0..2] [0..1] 6 [0..5] [0..6] [0..5] Primero, el rango [0..6] en realidad se calcula para i . Sin embargo, se sabe que i < 5 es una condición. Por lo tanto, el valor del código en el bucle está limitado a este valor. 7 [0..5] [0..7] [0..5] 10 [0..5] [0..10] [0..5] x se incrementa cada vez más. De 10 , sin embargo, el valor se \"redondea\" a MAXINT . 11 [0..5] [0..MAXDINT] [0..5] MAXDINT + 1 resultados en MAXDINT A partir de las 11 A partir del undécimo pase, los valores en el bucle no cambiarán. La propagación ha terminado. Además, i = 6 se aplica al código que sigue a este bucle. El rango [0..6] se determina en el bucle y esto se combina con la condición i > 5 , lo que da como resultado exactamente el valor 6. " }, 
{ "title" : "Referencia: Interfaz de Usuario ", 
"url" : "_san_f_reference_user_interface.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comandos ", 
"url" : "_san_struct_reference_commands.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comando: Extraer función ", 
"url" : "_san_cmd_extract_function.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Extraer función ", 
"snippet" : "Extraer función Función : El comando abre el Extraer la configuración de la función diálogo. El comando extrae el código seleccionado del editor ST y crea un nuevo método o función que contiene este código. El código afectado en el editor ST se reemplaza por una llamada correcta. Cuando el código se...", 
"body" : "Extraer función Función : El comando abre el Extraer la configuración de la función diálogo. El comando extrae el código seleccionado del editor ST y crea un nuevo método o función que contiene este código. El código afectado en el editor ST se reemplaza por una llamada correcta. Cuando el código se extrae de un bloque de funciones o del elemento secundario de un bloque de funciones, se crea un nuevo método a partir del código. Cuando se extrae código de un programa o una función, se crea una nueva función a partir del código. Nótese también en este contexto: Detección de clones de códigoLlamar : Menú de contexto: refactorización Requisitos : Cuando el código seleccionado consta de una o más sentencias: El código seleccionado no contiene ningún error de compilación. El código seleccionado se encuentra en la parte de implementación de una ST POU. El código seleccionado no contiene ningún salto existente Ejemplos de saltos de salida incluyen los siguientes: Utilizando RETURN para salir de la función de cierre Utilizando CONTINUE o EXIT para salir de un bucle que encierra el código Puede deshacer los cambios que el Extraer función comando realizado en su proyecto colocando el cursor en el árbol de dispositivos y haciendo clic en Editar → Deshacer . Extraer la configuración de la función Diálogo Nombre Nombre de la función o método creado recientemente El nombre predeterminado se puede cambiar. Valor devuelto Determina el valor de retorno de una función si hay múltiples parámetros de salida y\/o entrada\/salida Parámetros Visualización de las POU disponibles Configuración si los parámetros se utilizan como variables de entrada, salida o entrada\/salida : variables de entrada : Variables de salida : Variables de entrada\/salida Los cambios realizados para Nombre , Valor de retorno , o Parámetro están deshechos. Ventana de código superior Código creado recientemente de la ubicación de la llamada Ventana de código inferior Código creado recientemente de la función o método OK Los cambios de código mostrados se aceptan en las ST POU y se cierra el cuadro de diálogo. Cancelar Los cambios de código mostrados se rechazan y el cuadro de diálogo se cierra. " }, 
{ "title" : "Comando: Invertir declaración IF ", 
"url" : "_san_cmd_invert_if_statement.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Invertir declaración IF ", 
"snippet" : "Invertir declaración IF Función : Este comando invierte el IF declaración sin cambiar la semántica de la IF declaración. La condición es negada. Las declaraciones en el THEN y ELSE Se intercambian ramas. Todos los comentarios se conservan. Llamar : Menú contextual debajo Refactorización dominio Requ...", 
"body" : "Invertir declaración IF Función : Este comando invierte el IF declaración sin cambiar la semántica de la IF declaración. La condición es negada. Las declaraciones en el THEN y ELSE Se intercambian ramas. Todos los comentarios se conservan. Llamar : Menú contextual debajo Refactorización dominio Requisito: el cursor se encuentra en cualquier lugar dentro un IF declaración. Reglas para la negación Expresión Expresión negada Descripción < >= La comparación de \"menor que\" se convierte en \"mayor que\" y viceversa. <= > La comparación de \"menor o igual que\" se convierte en \"mayor que\" y viceversa. = <> La comparación de \"iguales\" se convierte en \"no iguales\" y viceversa. <expresión1> AND <expresión2> ( NOT <expresión1> ) OR ( NOT <expresión2> ) Negación según De Morgan para AND operador <expresión1> OR <expresión2> (NOT <expresión1> ) AND (NOT <expresión2> ) Negación según De Morgan para OR operador <expresión> NOT <expresión> Negación estándar NOT <expresión> <expresión> sin doble NOT expresión a (*comentario*) = b a (*comentario*) <> b Los comentarios se conservan. Esto se aplica especialmente para operandos intercambiados. Ejemplo PROGRAM Inversion1\nVAR\n xA, xB, xC : BOOL;\n iVar : INT;\nEND_VAR iVar := 0;\nIF NOT(xA AND xB AND xC) THEN\n\tiVar:= 1; (* IF 1 *)\nELSE\n\tiVar := iVar + 1; (* ELSE counter*)\nEND_IFiVar := 0;\n Código después de llamar al comando con lógica invertida con la misma semántica: iVar := 0;\nIF (xA AND xB AND xC) THEN\n iVar := iVar + 1; (* ELSE counter*)\nELSE\n iVar:= 1; (* IF 1 *)\nEND_IF " }, 
{ "title" : "Comando: Mostrar valores de propagación constante para el editor actual ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Mostrar valores de propagación constante para el editor actual ", 
"snippet" : "Mostrar valores de propagación constante para el editor actual Símbolo: Función : El comando inicia el análisis del código estático y calcula un valor medido para la propagación constante del código en el editor actual. El cuadro de diálogo que se abre visualiza el resultado. Se enumera el código an...", 
"body" : "Mostrar valores de propagación constante para el editor actual Símbolo: Función : El comando inicia el análisis del código estático y calcula un valor medido para la propagación constante del código en el editor actual. El cuadro de diálogo que se abre visualiza el resultado. Se enumera el código analizado y se muestran los valores medidos determinados. Llamar : Construir → Análisis estático menú Requisito : Un objeto de programación en el lenguaje de implementación ST está abierto en el editor. Para más información, ver: Propagación constante" }, 
{ "title" : "Diálogo: Resultados de la propagación constante ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html#UUID-948900c6-97a3-c88d-ff29-bca9a5de0d7b_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Mostrar valores de propagación constante para el editor actual \/ Diálogo: Resultados de la propagación constante ", 
"snippet" : "Ejemplo...", 
"body" : "Ejemplo " }, 
{ "title" : "Comando: Ejecutar análisis estático ", 
"url" : "_san_cmd_run_static_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Ejecutar análisis estático ", 
"snippet" : "Ejecutar análisis estático Símbolo: Función : el comando inicia el análisis estático de la aplicación activa y muestra las métricas de todas las POU en una tabla. Llamar : Construir → Análisis estático menú Durante el análisis del código, CODESYS Static Analysis genera código como el Construir → Gen...", 
"body" : "Ejecutar análisis estático Símbolo: Función : el comando inicia el análisis estático de la aplicación activa y muestra las métricas de todas las POU en una tabla. Llamar : Construir → Análisis estático menú Durante el análisis del código, CODESYS Static Analysis genera código como el Construir → Generar código mando. Los resultados del análisis se muestran como errores. y advertencias en la vista de mensajes ( Construir categoría). Los números se refieren al correspondiente reglas como se definen en la configuración del proyecto. La sintaxis de los mensajes mostrados es SA<número de regla>:<texto de regla> . " }, 
{ "title" : "Comando: Configuración ", 
"url" : "_san_cmd_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Configuración ", 
"snippet" : "Ajustes Función : El comando abre el Configuración de análisis estático diálogo. Llamar : Construir → Análisis estático menú Requisito : El paquete CODESYS Static Analysis esta instalado. Un proyecto está abierto....", 
"body" : "Ajustes Función : El comando abre el Configuración de análisis estático diálogo. Llamar : Construir → Análisis estático menú Requisito : El paquete CODESYS Static Analysis esta instalado. Un proyecto está abierto. " }, 
{ "title" : "Comando: Ver métricas estándar ", 
"url" : "_san_cmd_view_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Ver métricas estándar ", 
"snippet" : "Ver métricas estándar Símbolo: Función : El comando inicia el análisis del código estático para la aplicación activa. Las métricas predeterminadas para todos los bloques de programación se calculan y se muestran en una tabla en la página Métricas estándar pestaña. Llamar : Construir → Análisis estát...", 
"body" : "Ver métricas estándar Símbolo: Función : El comando inicia el análisis del código estático para la aplicación activa. Las métricas predeterminadas para todos los bloques de programación se calculan y se muestran en una tabla en la página Métricas estándar pestaña. Llamar : Construir → Análisis estático menú Para más información, ver: Visualización de métricasMétrica" }, 
{ "title" : "Pestaña: Métricas estándar ", 
"url" : "_san_cmd_view_standard_metrics.html#UUID-c2310f81-c613-bf67-ba1e-4f10694a38a1_section-idm4622240725232033866114829692", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Ver métricas estándar \/ Pestaña: Métricas estándar ", 
"snippet" : "Ejemplo En el Configuración de análisis estático: Métricas cuadro de diálogo, puede cambiar la configuración de las métricas. Puede desactivar el cálculo de una métrica. Y puede definir valores límite para métricas específicas. Si un valor está fuera de los límites superior e inferior configurados, ...", 
"body" : "Ejemplo En el Configuración de análisis estático: Métricas cuadro de diálogo, puede cambiar la configuración de las métricas. Puede desactivar el cálculo de una métrica. Y puede definir valores límite para métricas específicas. Si un valor está fuera de los límites superior e inferior configurados, el campo de la tabla se resalta en rojo. Los siguientes comandos se proporcionan en el menú contextual de la tabla: Calcular Actualiza los valores Copiar tabla Copia la tabla al portapapeles. El separador es una pestaña. Imprimir tabla Abre el cuadro de diálogo predeterminado para configurar el trabajo de impresión. Exportar tabla Exporta la tabla a un archivo CSV El separador es un punto y coma. Diagrama de Kiviat Requisito: Al menos tres métricas están habilitadas a las que se les han definido límites superior e inferior. Representa las métricas del bloque de funciones seleccionado como un gráfico de radar. Esto visualiza la calidad del código POU con respecto a un estándar determinado. Cada métrica se representa como un eje con su origen en el centro (valor 0) que se irradia hacia afuera en tres zonas de anillos concéntricos. La zona del anillo interior representa el rango de valores por debajo del límite inferior definido para la métrica. El anillo exterior representa el rango de valores por encima del límite superior. Los ejes de las métricas se distribuyen uniformemente alrededor del círculo. Los valores actuales de las métricas individuales en los ejes están conectados por una línea. En el caso ideal, la línea completa se ubica en la zona media. Configurar Abre la tabla para seleccionar las métricas deseadas. Esto corresponde a la tabla en la configuración del proyecto. POU abierta Abre el editor con la POU. Ejemplo Ejemplo de un diagrama Kiviat para cinco métricas El nombre de la métrica se muestra al final del eje respectivo y el nombre de la POU se muestra en la esquina superior derecha del diagrama. " }, 
{ "title" : "Comando: Calcular y exportar métricas estándar ", 
"url" : "_san_calculate_and_export_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Calcular y exportar métricas estándar ", 
"snippet" : "Calcular y exportar métricas estándar Función: Calcula y exporta las métricas estándar directamente sin mostrar la tabla de métricas en el editor. Especifique un nombre adecuado para el archivo de exportación CSV en el cuadro de diálogo del archivo estándar. Llamar: este comando no está disponible e...", 
"body" : "Calcular y exportar métricas estándar Función: Calcula y exporta las métricas estándar directamente sin mostrar la tabla de métricas en el editor. Especifique un nombre adecuado para el archivo de exportación CSV en el cuadro de diálogo del archivo estándar. Llamar: este comando no está disponible en ningún menú de forma predeterminada. Alternativamente, también puede utilizar el Mostrar métricas estándar comando para mostrar las métricas en el editor. Entre otras cosas, el editor proporciona la Exportar tabla comando de contexto. Personalizando el menú Proporcionando el comando Hacer clic Herramientas → Personalizar . El Menú Se abre la pestaña. Primero necesita definir una posición en el menú para el comando. En este caso, tiene sentido seleccionar un elemento bajo el Construir → Análisis estático menú. Seleccione la posición deseada y haga clic en el Agregar comando botón. Todos los comandos están listados en el Agregar comando diálogo. Selecciona el Análisis estático categoría en el lado izquierdo y luego el comando deseado en el lado derecho. Hacer clic DE ACUERDO para cerrar el diálogo. Luego haga clic DE ACUERDO nuevamente para cerrar el Personalizar diálogo. El Calcular y exportar métricas estándar El comando ahora está disponible en el Construir → Análisis estático menú. " }, 
{ "title" : "Comando: Detectar clones ", 
"url" : "_san_cmd_find_clones.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Detectar clones ", 
"snippet" : "Detectar clones Función : El comando escanea el código del programa del abierto CODESYS proyecto para el código copiado, y abre el Resultados de la detección de clones vista para mostrar los bloques de código clonados detectados. En el proceso, solo los bloques de código más grandes que un tamaño es...", 
"body" : "Detectar clones Función : El comando escanea el código del programa del abierto CODESYS proyecto para el código copiado, y abre el Resultados de la detección de clones vista para mostrar los bloques de código clonados detectados. En el proceso, solo los bloques de código más grandes que un tamaño específico se consideran clones. Los fragmentos de código muy pequeños no se muestran como clones. En este contexto, preste también atención a Extraer función y el Detección de clones de código instrucciones. Llamar : Construir → Análisis estático menú Análisis estático Menú de contexto Requisito : El CODESYS Static Analysis proyecto está abierto. Dos posiciones de código se consideran clones si tienen las siguientes propiedades: Misma composición estructural Las variables tienen el mismo tipo de datos. Los nombres de las variables pueden ser diferentes (excepción: acceso a componentes). Sin embargo, un identificador que está contenido varias veces en el código tiene que estar en el mismo lugar en ambas posiciones del código. Los literales tienen el mismo tipo de datos. Los literales pueden ser diferentes. Un literal que aparece varias veces en el código debe aparecer en el mismo lugar en ambas posiciones del código. Resultados de la detección de clones Vista Resumen Pestaña para mostrar los resultados de la búsqueda Número de secuencias de código clonadas encontradas Número de declaraciones comparadas Número de declaraciones en código clonado Proporción de clones : Especificado como un porcentaje: Número de declaraciones en código clonado \/ Número de declaraciones comparadas Resultados La pestaña muestra los clones de código en una vista de árbol y proporciona comandos y opciones de filtro. La primera aparición de un duplicado del conjunto de duplicados se toma como nodo raíz. El color de fondo de los nodos secundarios indica si el código es diferente o completamente idéntico. Los mismos colores significan el \"mismo código\". Los contenidos de la vista de árbol se clasifican en orden descendente por el número de declaraciones del código duplicado. Comandos y filtros en el Resultados pestaña Subnodos\/Clonar Número de subnodos (sentencias) en el bloque de código Si el número de subnodos es inferior a 20, no se considera el clon de código. Filtrar por objeto Campo de entrada para un Objeto , por el que se filtra la lista de clones Mostrar clones seleccionados Requisito: Se seleccionan dos nodos secundarios del mismo nodo principal. Ambos objetos de programación se muestran en la parte superior de la vista para comparar. En el proceso, los duplicados de código se resaltan y las diferencias (por ejemplo, diferentes nombres de variables) se resaltan en un color diferente. Lista de clones de código columnas Descripción Subnodos\/Clonar Objeto Posición Al hacer doble clic en un nodo secundario, se abre el objeto de programación correspondiente y el bloque de código duplicado se selecciona allí. " }, 
{ "title" : "Comando: Mostrar complejidad cognitiva para el editor actual ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Mostrar complejidad cognitiva para el editor actual ", 
"snippet" : "Mostrar complejidad cognitiva para el editor actual Símbolo: Función : El comando inicia el análisis del código estático y calcula un valor medido para la complejidad cognitiva del código en el editor actual. El cuadro de diálogo que se abre visualiza el resultado y especifica la suma del valor medi...", 
"body" : "Mostrar complejidad cognitiva para el editor actual Símbolo: Función : El comando inicia el análisis del código estático y calcula un valor medido para la complejidad cognitiva del código en el editor actual. El cuadro de diálogo que se abre visualiza el resultado y especifica la suma del valor medido en el título. El código analizado se enumera y muestra con las complejidades detectadas. Llamar : Construir → Análisis estático menú Requisito : Un objeto de programación en el lenguaje de implementación ST está abierto en el editor. " }, 
{ "title" : "Diálogo: Complejidad cognitiva de <nombre de POU>: <valor medido calculado> ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html#UUID-315a7cbe-83be-ba91-4d86-234b9f3e6fc3_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Mostrar complejidad cognitiva para el editor actual \/ Diálogo: Complejidad cognitiva de <nombre de POU>: <valor medido calculado> ", 
"snippet" : "Ejemplo...", 
"body" : "Ejemplo " }, 
{ "title" : "Comando: Ejecutar el análisis estático y exportar a un archivo SARIF ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Ejecutar el análisis estático y exportar a un archivo SARIF ", 
"snippet" : "Ejecute el análisis estático y expórtelo a un archivo SARIF Símbolo: Función : Este comando inicia el análisis del código estático y guarda el resultado en un archivo SARIF. Llamar : Construir → Análisis estático menú Un archivo SARIF (» Formato de intercambio de resultados de análisis estático «) e...", 
"body" : "Ejecute el análisis estático y expórtelo a un archivo SARIF Símbolo: Función : Este comando inicia el análisis del código estático y guarda el resultado en un archivo SARIF. Llamar : Construir → Análisis estático menú Un archivo SARIF (» Formato de intercambio de resultados de análisis estático «) es un archivo JSON legible por máquina con la extensión\" *.sarif.json «, creado por Static Analysis para almacenar los resultados en un formato estandarizado. SARIF es un estándar de OASIS. Esto significa que varias herramientas y plataformas pueden usarlo para intercambiar y procesar los resultados del análisis " }, 
{ "title" : "Comandos de línea de comandos ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html#UUID-b1a6530c-4103-8c37-7a9e-f6ad763d2402_section-idm235003337576496", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Ejecutar el análisis estático y exportar a un archivo SARIF \/ Comandos de línea de comandos ", 
"snippet" : "El comando también se puede ejecutar automáticamente mediante CODESYS Scripting . El comando por lotes [\"staticanalysis\", \"runandexportosarif\"] acepta los siguientes argumentos. Argumento: --sariffile --sariffile=<path to output>; Especifique la ruta en la que debe escribirse el archivo SARIF result...", 
"body" : "El comando también se puede ejecutar automáticamente mediante CODESYS Scripting . El comando por lotes [\"staticanalysis\", \"runandexportosarif\"] acepta los siguientes argumentos. Argumento: --sariffile --sariffile=<path to output>; Especifique la ruta en la que debe escribirse el archivo SARIF resultante. Si no especifica una ruta, el archivo se guarda en la carpeta del proyecto actual Argumento: --rulesfile --rulesfile=<patch to CSA file>; Especifique la ruta a un archivo CSA que debe usarse para el análisis estático. Si no especifica una ruta, se utilizará la configuración actual Ejemplo de la llamada en un script de Python system.commands[\"staticanalysis\", \"runandexportosarif\"].execute(\"--sariffile=result.sarif\", \"--rulesfile=rules.csa\") " }, 
{ "title" : "Comando: Formatear ", 
"url" : "_san_cmd_format.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Comandos \/ Comando: Formatear ", 
"snippet" : "Formato Modo de depuración Esta funcionalidad está disponible sólo cuando su CODESYS La instancia se inicia en modo de depuración. Para hacer esto, inicie su instancia con la siguiente llamada de línea de comando: codesys.exe --debug Función : El comando formatea un objeto ST de acuerdo con las regl...", 
"body" : "Formato Modo de depuración Esta funcionalidad está disponible sólo cuando su CODESYS La instancia se inicia en modo de depuración. Para hacer esto, inicie su instancia con la siguiente llamada de línea de comando: codesys.exe --debug Función : El comando formatea un objeto ST de acuerdo con las reglas configuradas en el CODESYS opciones para mejorar la legibilidad del código. Llamar : Menú contextual bajo el Refactorización menú Requisito: un editor ST está abierto y el cursor está ubicado dentro de una declaración o implementación. Para más información, ver: Formateador automático" }, 
{ "title" : "Diálogos ", 
"url" : "_san_struct_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Diálogos ", 
"snippet" : "Para los cuadros de diálogo para la configuración del análisis de código estático, haga clic en Construir → Análisis estático → Configuración . Requisito: un CODESYS el proyecto tiene que estar abierto....", 
"body" : "Para los cuadros de diálogo para la configuración del análisis de código estático, haga clic en Construir → Análisis estático → Configuración . Requisito: un CODESYS el proyecto tiene que estar abierto. " }, 
{ "title" : "Diálogo: Configuración Análisis estático: Configuración ", 
"url" : "_san_dlg_settings_static_analysis_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Diálogos \/ Diálogo: Configuración Análisis estático: Configuración ", 
"snippet" : "Configuración Función : En el cuadro de diálogo, seleccione automático análisis estático y guarde o cargue la configuración del proyecto para el análisis estático como un archivo CSA. Proyecto → Configuración del proyecto menú, Análisis estático categoría, Abrir cuadro de diálogo de configuración En...", 
"body" : "Configuración Función : En el cuadro de diálogo, seleccione automático análisis estático y guarde o cargue la configuración del proyecto para el análisis estático como un archivo CSA. Proyecto → Configuración del proyecto menú, Análisis estático categoría, Abrir cuadro de diálogo de configuración Enlace Construir → Análisis estático → Configuración menú Requisito : El CODESYS Static Analysis el paquete está instalado. Un proyecto está abierto. Realice análisis estáticos automáticamente : CODESYS Static Analysis realiza la verificación de código automáticamente en cada generación de código (por ejemplo, cuando el Construir → Generar código se ejecuta el comando o antes de una descarga. : La comprobación del código no se realiza automáticamente, pero se puede realizar explícitamente mediante el Construir → Análisis estático → Ejecutar análisis estático mando. Carga Abre el Cargar configuración de análisis estático cuadro de diálogo para seleccionar la configuración del proyecto para el análisis estático como un archivo CSA en el sistema de archivos. Cuando haces clic en el Abierto , se carga el archivo CSA seleccionado. Ahorrar Abre el Guardar configuración de análisis estático cuadro de diálogo para guardar todos los ajustes del proyecto en el Análisis estático categoría como un archivo CSA en el sistema de archivos. " }, 
{ "title" : "Diálogo: Configuración de análisis estático: Reglas ", 
"url" : "_san_dlg_settings_sa_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Diálogos \/ Diálogo: Configuración de análisis estático: Reglas ", 
"snippet" : "Reglas Función : En el cuadro de diálogo, seleccione el normas que se comprueban durante el análisis estático del código fuente de un proyecto. Para más información, ver: Configurar y ejecutar análisis estáticoLlamar : Proyecto → Configuración del proyecto menú, Análisis estático categoría, Abrir cu...", 
"body" : "Reglas Función : En el cuadro de diálogo, seleccione el normas que se comprueban durante el análisis estático del código fuente de un proyecto. Para más información, ver: Configurar y ejecutar análisis estáticoLlamar : Proyecto → Configuración del proyecto menú, Análisis estático categoría, Abrir cuadro de diálogo de configuración Enlace Construir → Análisis estático → Configuración menú Requisito : El CODESYS Static Analysis el paquete está instalado. Un proyecto está abierto. Esta pestaña muestra una estructura de árbol de todas las reglas que se pueden verificar durante el análisis estático. De manera predeterminada, todas las reglas están activadas, excepto SA0016, SA0024, SA0073, SA0101, SA0105, SA0106, SA0133, SA0134, SA0150, SA0162 y todas las \"reglas estrictas de IEC\". Cada regla tiene un número único. Cuando se verifica la regla y se detecta una infracción, el número de regla y una descripción del error se muestran en la vista de mensajes en la Construir categoría en el siguiente formato: SA<número de regla> , donde \"SA\" significa \"Análisis estático\" (ejemplo: \"SA003\" para la regla 3). La lista de reglas disponibles se puede ampliar con complementos específicos. Filtrar Campo de entrada para las cadenas a buscar Las reglas están agrupadas por categoría. Estructurado por importancia : Ordenar por Importancia: Alta , Importancia media , y Importancia baja Por defecto : Estructuración por defecto de las reglas en CODESYS Static Analysis : Las reglas se muestran como una lista plana. Al hacer clic en el encabezado de la columna correspondiente, la lista se puede ordenar por número de regla, activación\/desactivación, configuración específica de la regla o importancia. Algunas reglas que se activan en el cuadro de diálogo se pueden desactivar temporalmente en la aplicación aplicando un pragma . Al hacer clic en la casilla de verificación, la configuración cambia entre , , y . Cuando activa o desactiva un nodo principal, todas las reglas secundarias también se activan o desactivan, respectivamente. columnas Reglas Lista de reglas con número de regla Comprobación de reglas : La regla no está marcada. : Si el resultado de la verificación es positivo, entonces un error ( ) para el análisis estático se emite en la vista de mensajes. : Si el resultado de la comprobación es positivo, aparece una advertencia ( ) para el análisis estático se emite en la vista de mensajes. precompilar : Las reglas que se pueden verificar durante la precompilación se identifican con una marca de verificación ( ) en esta columna. Esto significa que las reglas ya están verificadas cuando se ingresa el código. Una corrección de errores inmediata (Quickfix) es posible para estas reglas. Puede ejecutar un manejo de errores automático e inmediato directamente en las posiciones de código afectadas. : Las reglas que no están marcadas se comprueban sólo después de una compilación exitosa. Configuración específica de la regla Para algunas reglas, puede hacer doble clic en el campo para abrir un cuadro de diálogo específico de la regla para configurar la regla. Importancia : Importancia de la regla: 3 estrellas rojas: alto 2 estrellas naranjas: mediana 1 estrella gris: Baja " }, 
{ "title" : "Diálogo: Configuración de análisis estático: Convenciones de nomenclatura ", 
"url" : "_san_dlg_settings_sa_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Diálogos \/ Diálogo: Configuración de análisis estático: Convenciones de nomenclatura ", 
"snippet" : "Convenciones de nomenclatura Función : En el diálogo, usted definir los prefijos para los tipos de datos y los alcances de las variables, así como los prefijos para las POU y los tipos de datos definidos por el usuario (DUT). Comprobaciones de análisis estático cumplimiento con las convenciones de n...", 
"body" : "Convenciones de nomenclatura Función : En el diálogo, usted definir los prefijos para los tipos de datos y los alcances de las variables, así como los prefijos para las POU y los tipos de datos definidos por el usuario (DUT). Comprobaciones de análisis estático cumplimiento con las convenciones de nomenclatura. Cuando no se observa una convención, el análisis estático informa un mensaje de error en el Mensajes vista. Para más información, ver: Configurar y ejecutar análisis estáticoLlamar : Proyecto → Configuración del proyecto menú, Análisis estático categoría, Abrir cuadro de diálogo de configuración Enlace Construir → Análisis estático → Configuración menú Requisito : El CODESYS Static Analysis el paquete está instalado. Un proyecto está abierto. Los mensajes de error se muestran en el siguiente formato: NC <prefix of convention number> : <message text> . NC significa \"convención de nomenclatura\". Por ejemplo, el mensaje de error NC0102: Nombre no válido... significa una violación de la convención de nomenclatura 102 para POU de tipo PROGRAM . Puedes usar el 'naming' pragma para desactivar convenciones de nomenclatura para individuos identificadores . Los identificadores pueden comenzar con cualquier cosa, no necesariamente con el prefijo. Filtrar Campo de entrada para las cadenas que se buscarán Tabla con las convenciones de nomenclatura nombres Nodos y elementos para los que se puede definir un prefijo. El número entre paréntesis después de cada elemento (por ejemplo, PROGRAMA (102) ) es el número de convención de prefijo que se notifica en caso de incumplimiento de una convención de nomenclatura. Prefijo Campo de entrada del prefijo Se pueden especificar varios prefijos mediante la separación por comas. Ejemplo: Prefijo para POU , PROGRAM (102) : prog, PRG_ Prefijo para POU , FUNCTION (103) : fun, FUN_ Las expresiones regulares (RegEx) también son posibles para los prefijos. Para hacer esto, un @ tiene que ser antepuesto. Ejemplo: El nombre tiene que empezar por x y puede contener un carácter del alcance a-dA-D : @x[a-dA-D] . Para variables de tipo Alias y POUs de tipo Propiedad , el prefijo se puede definir con el marcador de posición {datatype} . Prefijos para variables Nodo organizativo para todas las variables para las que se puede definir un prefijo según el tipo de datos o el ámbito. Prefijos para POU Nodo organizativo para todos los tipos de POU y alcances de métodos para los que se puede definir un prefijo Prefijos para DUT Nodo organizativo para los tipos de datos DUT (estructura, enumeración, alias o unión) para los que se puede definir un prefijo Prefijos para tipos personalizados Nodo organizativo para tipos personalizados especiales (particularmente los de bibliotecas) Puede ampliar la lista con convenciones: haga clic en el espacio en blanco debajo de ella. En el Asistente de entrada cuadro de diálogo, especifique el nombre de un tipo personalizado o seleccione un tipo personalizado. Para eliminar una convención, selecciónela y presione el botón Supr llave. Nota: Estas convenciones tienen prioridad sobre los prefijos que se definen con el atributo {attribute 'nameprefix' := '<prefix>'} . Opciones El primer carácter después del prefijo debe ser una letra mayúscula : el análisis estático informa de un error para una variable cuando el primer carácter del nombre de la variable después del prefijo definido no es una letra mayúscula. Combine el prefijo de ámbito con el prefijo de tipo de datos : Como espacio de nombres, una variable debe tener el prefijo definido seguido del prefijo definido para su tipo de datos. Ejemplo: Se definen los siguientes prefijos: g_ por VAR_GLOBAL , y r para el tipo de datos VERDADERO . El análisis de código informa errores para variables REAL globales que no tienen el prefijo g_r . : si se especifican convenciones para el espacio de nombres para una variable, estas convenciones se tienen en cuenta. Como resultado, se ignoran las convenciones de tipos de datos. Ejemplo: Se definen los siguientes prefijos: g_ por VAR_GLOBAL , y r para el tipo de datos VERDADERO . El análisis de código reporta exclusivamente errores para global REAL variables que no tienen el prefijo g_ . Prefijos recursivos para tipos de datos combinables : Las variables de tipos de datos combinados deben tener prefijos compuestos que sigan las convenciones de nomenclatura definidas. Ejemplo: ppiVariable : POINTER TO POINTER TO INT; el prefijo p se definió para variables de tipo de datos POINTER , y el prefijo I se definió para el tipo de datos INT . El análisis estático informa errores para todas las variables de tipo POINTER TO POINTER TO INT que no tienen el prefijo ppi . refaiVar : REFERENCE TO ARRAY[1..3] OF INT; el prefijo ref se definió para el tipo de datos REFERENCE TO , el prefijo a para una matriz, y el prefijo I para el tipo de datos INT . El análisis estático informa errores para todas las variables de tipo REFERENCE TO ARRAY[1..3] OF INT que no tienen el prefijo refai . Ejemplo La siguiente convención de nomenclatura corresponde en su mayor parte a las recomendaciones que se describen en CODESYS para los \"identificadores\". Ejemplo La convención de nomenclatura (1) se refiere a la POU estándar TON . Como resultado, las declaraciones de la POU de la biblioteca especial se comprueban en busca del prefijo \"ton_\". Haga clic en el espacio en blanco (2) para insertar más convenciones de nomenclatura. " }, 
{ "title" : "Cuadro de diálogo: Configuración de análisis estático: Métricas ", 
"url" : "_san_dlg_settings_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Diálogos \/ Cuadro de diálogo: Configuración de análisis estático: Métricas ", 
"snippet" : "Configuración de análisis estático: Métricas Símbolo: Función : Configura las métricas para que se calculen y muestren en consecuencia cuando Ver métricas estándar se ejecuta el comando. Llamar : Proyecto → Configuración del proyecto menú, Análisis estático categoría, Abrir cuadro de diálogo de conf...", 
"body" : "Configuración de análisis estático: Métricas Símbolo: Función : Configura las métricas para que se calculen y muestren en consecuencia cuando Ver métricas estándar se ejecuta el comando. Llamar : Proyecto → Configuración del proyecto menú, Análisis estático categoría, Abrir cuadro de diálogo de configuración enlace Construir → Análisis estático → Configuración menú Requisito : El CODESYS Static Analysis el paquete está instalado. Un proyecto está abierto. Para más información, ver: Configurar y ejecutar análisis estáticoMétrica Todo seleccionable Métrica se muestran en la columna. Activo : La métrica se muestra para cada POU en el Métricas estándar ver siguiendo el Construir → Análisis estático → Ver métricas estándar mando. : La métrica no se muestra en la Métricas estándar ver siguiendo el Construir → Análisis estático → Ver métricas estándar mando. Límite inferior Valor inferior a partir del cual se muestra la métrica Limite superior Valor superior al que se muestra la métrica El Tamaño del código , Tamaño variable , Tamaño de la pila , y Llamadas las métricas se informan solo para las POU de las bibliotecas que están integradas en el proyecto. Las violaciones de los límites superior e inferior de las métricas activadas se pueden informar como errores de compilación mediante una regla de análisis estático SA0150 . " }, 
{ "title" : "Diálogo: Configuración de análisis estático: Símbolos Prohibidos ", 
"url" : "_san_dlg_settings_sa_forbidden_symbols.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Diálogos \/ Diálogo: Configuración de análisis estático: Símbolos Prohibidos ", 
"snippet" : "Símbolos Prohibidos Función : En el cuadro de diálogo, define las palabras clave y los símbolos que no deben utilizarse en el código del proyecto. Para más información, ver: Configurar y ejecutar análisis estáticoLlamar : Proyecto → Configuración del proyecto menú, Análisis estático categoría, Abrir...", 
"body" : "Símbolos Prohibidos Función : En el cuadro de diálogo, define las palabras clave y los símbolos que no deben utilizarse en el código del proyecto. Para más información, ver: Configurar y ejecutar análisis estáticoLlamar : Proyecto → Configuración del proyecto menú, Análisis estático categoría, Abrir cuadro de diálogo de configuración Enlace Construir → Análisis estático → Configuración menú Requisito : El CODESYS Static Analysis el paquete está instalado. Un proyecto está abierto. Línea de entrada Al hacer doble clic en la línea, se abre el editor de líneas para especificar una palabra clave o un símbolo. : Se abre el Asistente de entrada para seleccionar la palabra clave o el símbolo. " }, 
{ "title" : "Diálogo: Opciones: Formateador automático ", 
"url" : "_cds_dlg_options_smart_code.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Diálogos \/ Diálogo: Opciones: Formateador automático ", 
"snippet" : "Formateador automático Modo de depuración Esta funcionalidad está disponible sólo cuando su CODESYS La instancia se inicia en modo de depuración. Para hacer esto, inicie su instancia con la siguiente llamada de línea de comando: codesys.exe --debug Símbolo: Función : En este cuadro de diálogo se con...", 
"body" : "Formateador automático Modo de depuración Esta funcionalidad está disponible sólo cuando su CODESYS La instancia se inicia en modo de depuración. Para hacer esto, inicie su instancia con la siguiente llamada de línea de comando: codesys.exe --debug Símbolo: Función : En este cuadro de diálogo se configura el formateo automático del código IEC. Llamar : Herramientas → Opciones menú, Formateador automático categoría " }, 
{ "title" : "Formateador automático ", 
"url" : "_cds_dlg_options_smart_code.html#UUID-ed744990-e58a-afa4-07c6-a11c0254c4c0_section-idm4605775334425634132064038043", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Interfaz de Usuario \/ Diálogos \/ Diálogo: Opciones: Formateador automático \/ Formateador automático ", 
"snippet" : "General Declaración e implementación Aplastar líneas vacías true (por defecto): se eliminan las líneas en blanco. false : Se conservan las líneas en blanco. Interfaz Declaración Alinear tipos de variables true (por defecto): Todos los tipos en un bloque variable están organizados para que comiencen ...", 
"body" : "General Declaración e implementación Aplastar líneas vacías true (por defecto): se eliminan las líneas en blanco. false : Se conservan las líneas en blanco. Interfaz Declaración Alinear tipos de variables true (por defecto): Todos los tipos en un bloque variable están organizados para que comiencen con la misma profundidad de línea. false : Alinear inicializaciones de variables true (por defecto): Todas las inicializaciones en un bloque variable están organizadas para que comiencen con la misma profundidad de línea. false : Alinear comentarios finales de variables true (por defecto): Todos los comentarios que se encuentran en la misma línea que la declaración de variable comienzan con la misma profundidad de línea. false : Invocaciones Todas las llamadas se formatean cuando se exceden los valores máximos. Ejemplo: Máx. número de parámetros antes del salto de línea El número de parámetros que puede contener una llamada de una sola línea es limitado. Ejemplo: 4 (predeterminado) Máx. longitud de caracteres de los parámetros antes del salto de línea La cantidad de caracteres en el nombre del parámetro es limitada. Ejemplo: 300 (por defecto) " }, 
{ "title" : "Referencia: Programación ", 
"url" : "_san_f_reference_programming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "pragmas y atributos ", 
"url" : "_san_struct_reference_pragmas.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ pragmas y atributos ", 
"snippet" : "CODESYS Static Analysis proporciona pragmas y atributos para activar o desactivar reglas individuales o convenciones de nomenclatura para el análisis de código estático. Requisito: Las reglas o convenciones están activadas o definidas en la configuración del proyecto. Los atributos se insertan en la...", 
"body" : "CODESYS Static Analysis proporciona pragmas y atributos para activar o desactivar reglas individuales o convenciones de nomenclatura para el análisis de código estático. Requisito: Las reglas o convenciones están activadas o definidas en la configuración del proyecto. Los atributos se insertan en la parte de declaración de una POU para desactivar reglas específicas para un objeto de programación completo. Los pragmas se utilizan en la parte de implementación de una POU para desactivar reglas específicas para líneas de código individuales. Una excepción es la regla 164, que también se puede desactivar en la parte de la declaración. Las reglas que están desactivadas en la configuración del proyecto no pueden activarse mediante pragmas o atributos. La regla SA0004 no se puede desactivar mediante un pragma o un atributo. " }, 
{ "title" : "Pragma: analysis ", 
"url" : "_san_pragma_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ pragmas y atributos \/ Pragma: analysis ", 
"snippet" : "Este pragma se utiliza para desactivar las reglas de código para líneas de código individuales de una POU para que se excluyan de la análisis estático . Las reglas de código se desactivan especificando los números de regla con un signo menos (\"-\") antepuesto. Un signo más antepuesto (\"+\") activa la ...", 
"body" : "Este pragma se utiliza para desactivar las reglas de código para líneas de código individuales de una POU para que se excluyan de la análisis estático . Las reglas de código se desactivan especificando los números de regla con un signo menos (\"-\") antepuesto. Un signo más antepuesto (\"+\") activa la regla. Puede especificar cualquier número de reglas en el pragma. Insertar ubicación : Desactivación: En la parte de implementación, con {analysis - ...} antes de la primera línea de código donde se desactiva el análisis de código. Activación: Con {analysis + ...} después de la última línea de la desactivación. Para la Regla 164, el pragma también se puede insertar en la parte de la declaración antes de un comentario. Sintaxis: Deaktivierung von Regeln:\n\n{analysis -<rule number> ( , -<further rule number> )* }\n* : optional none, one or more further rule numbers Aktivierung von Regeln:\n\nanalysis +<rule number> ( , +<further rule number> )* }\n* : none, one or more further rule numbers Ejemplo La regla 24 se desactiva para dos líneas y luego se reactiva. En consecuencia, la regla 24 no se verifica en estas líneas para que nTest:=DINT#99 está permitido, por ejemplo. {analysis -24}\nnTest := 99;\niVar := INT#2;\n{analysis +24} Desactivar varias reglas: {analysis -10, -24, -18} " }, 
{ "title" : "Atributo: análisis ", 
"url" : "_san_attribute_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ pragmas y atributos \/ Atributo: análisis ", 
"snippet" : "El atributo desactiva reglas específicas para un objeto de programación completo para que sean excluidos de la análisis estático . Las reglas de código se desactivan especificando los números de regla con un signo menos (\"-\") antepuesto. Puede especificar cualquier número de reglas en el atributo. I...", 
"body" : "El atributo desactiva reglas específicas para un objeto de programación completo para que sean excluidos de la análisis estático . Las reglas de código se desactivan especificando los números de regla con un signo menos (\"-\") antepuesto. Puede especificar cualquier número de reglas en el atributo. Insertar ubicación : En la parte de declaración de un POU, en la primera línea. Sintaxis : {attribute 'analysis' := '-<rule number> ( , -<further rule number> )* '}\n* : none, one or more further rule numbers Ejemplo Se desactivan las reglas 33 y 31 para toda la estructura: {attribute 'analysis' := '-33, -31'}\nTYPE My_Structure :\nSTRUCT\n iLocal : INT;\n uiLocal : UINT;\n udiLocal : UDINT;\nEND_STRUCT\nEND_TYPE La regla 100 está desactivada para la matriz: {attribute 'analysis' := '-100'}\nPROGRAM PLC_PRG\nVAR\n aBigData: ARRAY[1..10000] OF DWORD;\n aBigDATA_2: ARRAY[1..10000] OF DWORD;\nEND_VAR\n; " }, 
{ "title" : "Atributo: 'naming' ", 
"url" : "_san_attribute_naming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ pragmas y atributos \/ Atributo: 'naming' ", 
"snippet" : "El atributo marca las líneas de código que se excluyen del análisis de la convención de nomenclatura . Un off se asigna al atributo pragma antes de la primera línea de código donde se desactiva el análisis de código. Un on se asigna después de la última línea. Cuando un omit se asigna, solo se ignor...", 
"body" : "El atributo marca las líneas de código que se excluyen del análisis de la convención de nomenclatura . Un off se asigna al atributo pragma antes de la primera línea de código donde se desactiva el análisis de código. Un on se asigna después de la última línea. Cuando un omit se asigna, solo se ignora la siguiente línea de código. Insertar ubicación : Desactivación: En la parte de declaración de POUs y DUTs, arriba de las líneas afectadas. Activación: Debajo de las líneas afectadas. Sintaxis : {attribute 'naming' := '<switch state>'}\n<switch state> : on | off | omit\non : naming is switched on\noff : naming is switched off\nomit : only next codeline is switched off Ejemplo Convenciones de nomenclatura definidas: 1) Los nombres de variables INT deben ir precedidos de \"int\" como prefijo del identificador, por ejemplo, \"intVar1\". (2) Los nombres de los programas deben comenzar con \"prog\". Para el código que se presenta a continuación, el análisis estático emite mensajes solo para las siguientes variables: cccVar , aVariable , y bVariable . VAR\n{attribute 'naming' := 'off'}\n iVarA : INT;\n iVarB : INT;\n{attribute 'naming' := 'on'}\n iVarC : INT;\nEND_VAR VAR\n ...\n{attribute 'naming' := 'omit'}\n iVarC : INT;\n...\nEND_VAR {attribute 'naming' := 'omit'}\nPROGRAM PLC_PRG\nVAR\n...\nEND_VAR {attribute 'naming' := 'off'}\nPROGRAM DoSomethingA\nVAR\n{attribute 'naming' := 'on'}\n iVarA : INT;\n iVarB : INT;\n …\nVAR_END " }, 
{ "title" : "Atributo: nameprefix ", 
"url" : "_san_attribute_nameprefix.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ pragmas y atributos \/ Atributo: nameprefix ", 
"snippet" : "nameprefix El atributo define un prefijo para las variables de un tipo de datos estructurados. El prefijo debe anteponerse al identificador de las variables declaradas por este tipo. El análisis estático comprueba esta convención de nomenclatura. Insertar ubicación : En la línea antes de la declarac...", 
"body" : "nameprefix El atributo define un prefijo para las variables de un tipo de datos estructurados. El prefijo debe anteponerse al identificador de las variables declaradas por este tipo. El análisis estático comprueba esta convención de nomenclatura. Insertar ubicación : En la línea antes de la declaración de un tipo de datos estructurados Sintaxis : {attribute 'nameprefix' := '<prefix>'} Ejemplo En el siguiente ejemplo, Static Analysis emite un mensaje para pB porque el nombre de la variable no comienza con \"punto\". {attribute 'nameprefix' := 'point'}\nTYPE DATAPOINT :\nSTRUCT\n iX: INT;\n iY: INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n pointA : DATAPOINT;\n pB : DATAPOINT;\nEND_VAR\npointA.iX := 1;\npointA.iY := 10;\npB.iX := 2;\npB.iY := 20; Mensaje de error después del análisis estático: Nombre de variable no válido 'pB': Prefijo esperado 'punto' " }, 
{ "title" : "Atributo: analysis:report-multiple-instance-calls ", 
"url" : "_san_attribute_analysis_report_multiple_instance_calls.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ pragmas y atributos \/ Atributo: analysis:report-multiple-instance-calls ", 
"snippet" : "analysis:report-multiple-instance-calls El atributo marca un bloque de funciones para verificar la regla. regla 105 : Solo se comprueban los bloques de funciones con este atributo si las instancias de los bloques de funciones se llaman más de una vez. Cuando se desactiva la regla 105 en el configura...", 
"body" : "analysis:report-multiple-instance-calls El atributo marca un bloque de funciones para verificar la regla. regla 105 : Solo se comprueban los bloques de funciones con este atributo si las instancias de los bloques de funciones se llaman más de una vez. Cuando se desactiva la regla 105 en el configuración del proyecto , el atributo no tiene ningún efecto. Insertar ubicación : Línea superior en la parte de declaración de un bloque de funciones. Sintaxis : {attribute 'analysis:report-multiple-instance-calls'} Ejemplo \/\/ {attribute 'analysis:report-multiple-instance-calls'} deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\n{attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\niB := iB +1;\n\nPROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nND_VAR\n\nfbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n Salida a la vista Mensajes : SA0105: Instancia 'fbB' llamada varias veces " }, 
{ "title" : "Reglas ", 
"url" : "_san_struct_reference_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0001: Código inalcanzable ", 
"url" : "_san_rule_sa0001.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0001: Código inalcanzable ", 
"snippet" : "Detecta líneas de código que no se ejecutan, por ejemplo debido a un RETURN o CONTINUE declaración Justificación: Siempre se debe evitar el código inalcanzable. El prueba a menudo indica que todavía existe un código de prueba que debe eliminarse. Importancia: Alta Regla PLCopen: CP2 Ejemplo PROGRAM ...", 
"body" : "Detecta líneas de código que no se ejecutan, por ejemplo debido a un RETURN o CONTINUE declaración Justificación: Siempre se debe evitar el código inalcanzable. El prueba a menudo indica que todavía existe un código de prueba que debe eliminarse. Importancia: Alta Regla PLCopen: CP2 Ejemplo PROGRAM PLC_PRG\nVAR\n xReturn_Before_End: BOOL;\n xContinue_In_Loop_FUN: BOOL;\n iCounter: INT;\nEND_VAR\n xContinue_In_Loop_FUN := FALSE;\nFOR iCounter := INT#0 TO INT#5 BY INT#1 DO\n CONTINUE;\n xContinue_In_Loop_FUN := FALSE;\nEND_FOR Salida en el Mensajes vista: SA0001: Código inalcanzable detectado en 'PLC_PRG' " }, 
{ "title" : "SA0002: Objetos vacíos ", 
"url" : "_san_rule_sa0002.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0002: Objetos vacíos ", 
"snippet" : "Detecta POU, GVL, declaraciones de tipos de datos o interfaces que no contienen ningún código Justificación: Deben evitarse los objetos vacíos. A menudo son una señal de que un objeto no se ha implementado por completo. Excepción: en algunos casos, no se especifica ningún código en el cuerpo de un b...", 
"body" : "Detecta POU, GVL, declaraciones de tipos de datos o interfaces que no contienen ningún código Justificación: Deben evitarse los objetos vacíos. A menudo son una señal de que un objeto no se ha implementado por completo. Excepción: en algunos casos, no se especifica ningún código en el cuerpo de un bloque de funciones cuando solo deben usarlo las interfaces. En otros casos, se crea un método solo porque lo requiere una interfaz sin que sea posible una implementación sensible para el método. No importa el caso, este tipo de situación debe ser comentada. Importancia: Media " }, 
{ "title" : "SA0003: Sentencias vacías ", 
"url" : "_san_rule_sa0003.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0003: Sentencias vacías ", 
"snippet" : "Detecta líneas de código que tienen un punto y coma ( ; ) pero no una declaración Justificación: una declaración vacía puede ser una señal de código faltante. Nota: Hay buenas razones para utilizar declaraciones vacías. Por ejemplo, en un CASE declaración, puede tener sentido programar explícitament...", 
"body" : "Detecta líneas de código que tienen un punto y coma ( ; ) pero no una declaración Justificación: una declaración vacía puede ser una señal de código faltante. Nota: Hay buenas razones para utilizar declaraciones vacías. Por ejemplo, en un CASE declaración, puede tener sentido programar explícitamente todos los casos, incluso aquellos en los que no hay nada que hacer. Cuando este tipo de vacío CASE La declaración contiene un comentario, el Análisis estático no genera un mensaje de error. Importancia: Baja Ejemplo CASE value OF\n 1:\n DoSomething();\n 2:\n ;\n 3:\n DoSomethingElse();\nEND_CASE\n Salida en el Mensajes vista: SA0003: Declaraciones vacías CASE value OF\n 1:\n DoSomething();\n 2:\n ; \/\/nothing to do\n 3:\n DoSomethingElse();\nEND_CASE\n Salida en el Mensajes vista: Sin error de SA " }, 
{ "title" : "SA0004: acceso de escritura múltiple en la salida ", 
"url" : "_san_rule_sa0004.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0004: acceso de escritura múltiple en la salida ", 
"snippet" : "Detecta salidas que se escriben en más de una ubicación. Justificación: la mantenibilidad se degrada cuando una salida se escribe en diferentes ubicaciones en el código. Entonces no está claro qué acceso de escritura es el que realmente tiene un efecto en el proceso. Una buena práctica es calcular l...", 
"body" : "Detecta salidas que se escriben en más de una ubicación. Justificación: la mantenibilidad se degrada cuando una salida se escribe en diferentes ubicaciones en el código. Entonces no está claro qué acceso de escritura es el que realmente tiene un efecto en el proceso. Una buena práctica es calcular las variables de salida en variables auxiliares y asignar el valor calculado en una ubicación al final del ciclo. Importancia: Alta Regla PLCopen: CP12 No se emite un error cuando una variable de salida ( VAR_IN_OUT ) se escribe en diferentes ramas de IF y CASE declaraciones. Un pragma no puede deshabilitar esta regla. Ejemplo VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW0 : INT ;\nEND_VAR PROGRAM PLC_PRG IF g_iCondition < INT#0 THEN\n g_xVar := TRUE;\n g_iTest := INT#12;\nEND_IF\n\nCASE g_iCondition OF\n INT#1:\n g_xVar := FALSE;\n INT#2:\n g_iTest := INT#11;\n ELSE\n g_xVar := TRUE;\n g_iTest := INT#9;\nEND_CASE\n Salida en el Mensajes vista: SA0004: Acceso de escritura múltiple en la salida '%QX0.0' SA0004: Acceso de escritura múltiple en la salida '%QW0' " }, 
{ "title" : "SA0006: Acceso de escritura desde varias tareas ", 
"url" : "_san_rule_sa0006.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0006: Acceso de escritura desde varias tareas ", 
"snippet" : "Detecta variables en las que escribe más de una tarea. Justificación: Una variable que se escribe en múltiples tareas puede cambiar su valor inesperadamente. Esto puede conducir a situaciones confusas. Las variables de cadena (y en algunos sistemas de 32 bits también las variables enteras de 64 bits...", 
"body" : "Detecta variables en las que escribe más de una tarea. Justificación: Una variable que se escribe en múltiples tareas puede cambiar su valor inesperadamente. Esto puede conducir a situaciones confusas. Las variables de cadena (y en algunos sistemas de 32 bits también las variables enteras de 64 bits) pueden incluso alcanzar un estado inconsistente si la variable se escribe en dos tareas simultáneamente. Excepción: en casos específicos, puede ser necesario que varias tareas escriban una variable. Por ejemplo, utilice semáforos para asegurarse de que el acceso no conduzca a un estado incoherente. Importancia: Alta Regla PLCopen: CP10 Ejemplo VAR_GLOBAL\n g_iTemp1: INT;\nEND_VAR PROGRAM PLC_PRG \/\/ Controlled by MainTask\ng_iTemp1 := g_iTemp1 + INT#2;\n PROGRAM PLC_PRG_1 \/\/Controlled by SubTask\ng_iTemp1 := g_iTemp1 - INT#3; Salida en el Mensajes vista: SA0006: Acceso de escritura simultáneo a 'g_iTemp1' en Tareas MainTask, SubTask " }, 
{ "title" : "SA0007: Operador de dirección en constantes ", 
"url" : "_san_rule_sa0007.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0007: Operador de dirección en constantes ", 
"snippet" : "Detecta líneas de código donde el operador ADR se aplica para una constante Justificación: El uso de un puntero a una variable constante anula el CONSTANT propiedad de la variable. La variable se puede cambiar por medio del puntero sin ninguna notificación del compilador. Excepción: en casos excepci...", 
"body" : "Detecta líneas de código donde el operador ADR se aplica para una constante Justificación: El uso de un puntero a una variable constante anula el CONSTANT propiedad de la variable. La variable se puede cambiar por medio del puntero sin ninguna notificación del compilador. Excepción: en casos excepcionales, podría ser útil pasar un puntero a una constante a una función. Sin embargo, debe asegurarse de que esta función no cambie el valor transferido. Siempre que sea posible, utilice VAR_IN_OUT CONSTANT . Importancia: Alta Cuando el Reemplazar constantes La opción está seleccionada en el Opciones del compilador De la configuración del proyecto, el operador de dirección no está permitido para constantes escalares (enteros, BOOL , REAL ) y se emite un error de compilación. (Las cadenas, estructuras y matrices constantes siempre tienen una dirección). Ejemplo PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n poiValue : POINTER TO INT;\nEND_VAR\n poiValue := ADR(c_iValue); \/\/ SA0007 Salida en el Mensajes vista: SA0007: Dirección a la variable constante 'c_iValue' " }, 
{ "title" : "SA0008: Comprobar tipos de subrango ", 
"url" : "_san_rule_sa0008.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0008: Comprobar tipos de subrango ", 
"snippet" : "Detecta violaciones fuera de rango de tipos de subrango. El compilador ya verifica los literales asignados. Cuando se asignan constantes, los valores deben estar dentro del rango definido. Cuando se asignan variables, los tipos de datos deben ser idénticos. Justificación: si se utilizan tipos de sub...", 
"body" : "Detecta violaciones fuera de rango de tipos de subrango. El compilador ya verifica los literales asignados. Cuando se asignan constantes, los valores deben estar dentro del rango definido. Cuando se asignan variables, los tipos de datos deben ser idénticos. Justificación: si se utilizan tipos de subrango, asegúrese de que no se salga de este subrango. El compilador verifica este tipo de violaciones de subrango solo para asignaciones de constantes. Importancia: Baja La verificación no se realiza para objetos CFC porque la estructura del código no lo permite. Ejemplo VAR_GLOBAL\n iVarGlob:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iSubr1: INT (INT#1..INT#10);\n iSubr2: INT (INT#1..INT#1000);\n iCount: INT;\n by_SubType : BYTE (BYTE#0..BYTE#11);\n iVar : INT (-4095..4095);\nEND_VAR\n iSubr1 := nCount; \/\/ SA0008\niSubr1 := subr2; \/\/ SA0008\niSubr1 := gvl.iVarGlob; \/\/ SA0008\n\/\/byBYTE_SubType := BYTE#123; \/\/already detected by compiler, error \"Cannot convert type...\" Salida en el Mensajes vista: SA0008: La variable de subrango 'iSubr1' puede estar fuera del rango permitido " }, 
{ "title" : "SA0009: Valores de retorno no utilizados ", 
"url" : "_san_rule_sa0009.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0009: Valores de retorno no utilizados ", 
"snippet" : "Detecta llamadas a funciones, métodos y propiedades en las que no se utiliza el valor devuelto Justificación: Cuando una función o método devuelve un valor de retorno, también debes evaluarlo. El valor de retorno suele indicar si la función se ha ejecutado correctamente o no. Si no se realiza ningun...", 
"body" : "Detecta llamadas a funciones, métodos y propiedades en las que no se utiliza el valor devuelto Justificación: Cuando una función o método devuelve un valor de retorno, también debes evaluarlo. El valor de retorno suele indicar si la función se ha ejecutado correctamente o no. Si no se realiza ninguna evaluación, no podrá identificar más adelante si el valor devuelto se olvidó o si realmente no es necesario. Excepción: Si un valor de retorno es irrelevante para la llamada, entonces debe documentarlo y omitir la asignación. Los retornos de error nunca deben ignorarse. Importancia: Media Regla PLCopen: CP7 \/ CP17 Ejemplo FUNCTION Return_BOOL : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n    xTest : BOOL;\nEND_VAR xTest := FALSE;\nReturn_BOOL := xTest; PROGRAM PLC_PRG\nReturn_BOOL();  \/\/ SA0009\n Salida en el Mensajes vista: SA0009: Ignorar el valor de retorno de 'Return_BOOL' " }, 
{ "title" : "SA0010: Matrices con un solo componente ", 
"url" : "_san_rule_sa0010.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0010: Matrices con un solo componente ", 
"snippet" : "Detecta arreglos con un solo elemento Justificación: una matriz con un elemento se puede reemplazar por una variable de tipo base. El acceso a esta variable es considerablemente más rápido que el acceso por índice a la variable. Excepción: La longitud de una matriz suele estar determinada por una co...", 
"body" : "Detecta arreglos con un solo elemento Justificación: una matriz con un elemento se puede reemplazar por una variable de tipo base. El acceso a esta variable es considerablemente más rápido que el acceso por índice a la variable. Excepción: La longitud de una matriz suele estar determinada por una constante y es un parámetro de un programa. Entonces el programa puede trabajar con matrices de diferentes longitudes y no es necesario cambiarlas si la longitud es solo 1. Este tipo de situación debe documentarse en consecuencia. Importancia: Baja Ejemplo PROGRAM PLC_PRG\nVAR\n aoiEmpty : ARRAY [22..22] OF INT := [22];\n aorEmpty : ARRAY [2..2] OF REAL := [2.2];\n iVar : INT;\n rVAR : REAL;\nEND_VAR iVar := aoiEmpty[22];\nrVAR := aorEmpty[2];\n Salida en el Mensajes vista: SA0010: Elemento de matriz vacío en la variable 'aoiEmpty' SA0010: Elemento de matriz vacío en la variable 'aorEmpty' " }, 
{ "title" : "SA0011: Declaración inútil con un solo miembro. ", 
"url" : "_san_rule_sa0011.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0011: Declaración inútil con un solo miembro. ", 
"snippet" : "Detecta estructuras o enumeraciones con un solo miembro. Justificación: No deben declararse estructuras o enumeraciones con un solo miembro. Este tipo de declaraciones pueden resultar confusas para los lectores. Una estructura con un solo elemento se puede reemplazar por un tipo de alias. Una enumer...", 
"body" : "Detecta estructuras o enumeraciones con un solo miembro. Justificación: No deben declararse estructuras o enumeraciones con un solo miembro. Este tipo de declaraciones pueden resultar confusas para los lectores. Una estructura con un solo elemento se puede reemplazar por un tipo de alias. Una enumeración con un solo elemento se puede reemplazar por una constante. Regla PLCopen: CP22 \/ CP24 Importancia: Baja Ejemplo {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE TYPE SINGLE_UNION :\nUNION\n\tlrValue : LREAL;\nEND_UNION\nEND_TYPE {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE Salida en el Mensajes vista: SA0011: Declaración inútil 'SINGLE_ENUM': No se debe utilizar Struct\/Enum con un solo miembro SA0011: Declaración inútil 'SINGLE_UNION': No se debe utilizar Struct\/Enum con un solo miembro SA0011: Declaración inútil 'SINGLE_STRUCT': No se debe utilizar Struct\/Enum con un solo miembro " }, 
{ "title" : "SA0012: Variable que se puede declarar como constante ", 
"url" : "_san_rule_sa0012.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0012: Variable que se puede declarar como constante ", 
"snippet" : "Detecta variables a las que no se accede con permiso de escritura y por lo tanto podrían declararse como constantes Justificación: Si una variable se escribe sólo en el punto de declaración y, por lo demás, se utiliza sólo para lectura, entonces el análisis estático supone que la variable tampoco de...", 
"body" : "Detecta variables a las que no se accede con permiso de escritura y por lo tanto podrían declararse como constantes Justificación: Si una variable se escribe sólo en el punto de declaración y, por lo demás, se utiliza sólo para lectura, entonces el análisis estático supone que la variable tampoco debe modificarse. En primer lugar, una declaración como constante da como resultado comprobar que la variable no cambia cuando se cambia el programa. En segundo lugar, la declaración como constante puede dar lugar a un código más rápido. Si existen varias aplicaciones en un proyecto, solo se verán afectados los objetos debajo de la aplicación actualmente activa. Si solo hay una aplicación, los objetos del grupo de POU comunes también se ven afectados. Importancia: Baja Ejemplo PROGRAM PLC_PRG\nVAR\n iVar : INT := INT#17;\n iTest : INT;\nEND_VAR\n iTest := iTest + iVar; \/\/ SA0012: 'iVar' could be declared as constant Salida en el Mensajes vista: SA0012: La variable 'iVar' podría declararse como constante " }, 
{ "title" : "SA0013: Declaraciones con el mismo nombre de variable ", 
"url" : "_san_rule_sa0013.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0013: Declaraciones con el mismo nombre de variable ", 
"snippet" : "Detecta variables con nombres que ya utilizan otras variables (por ejemplo, variables globales y locales con el mismo nombre). También se detectan variables cuyos nombres de funciones, acciones, métodos o propiedades se utilizan en el mismo rango de acceso. También se detectan variables que están de...", 
"body" : "Detecta variables con nombres que ya utilizan otras variables (por ejemplo, variables globales y locales con el mismo nombre). También se detectan variables cuyos nombres de funciones, acciones, métodos o propiedades se utilizan en el mismo rango de acceso. También se detectan variables que están declaradas en un GVL en el Dispositivos vista o en el grupo de POU. Para ello, sin embargo, la GVL de la POU La vista debe usarse en el programa de aplicación. Justificación: los mismos nombres pueden ser confusos al leer el código y pueden causar errores si se accede al objeto incorrecto sin querer. Le recomendamos que utilice convenciones de nomenclatura para evitar estas situaciones. Regla PLCopen: N5 \/ N9 Importancia: Media Ejemplo VAR_GLOBAL\n xVar1 : BOOL;\n iVar3 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n xVar1 : BOOL; \/\/ SA0013\n iVar3 : INT; \/\/ SA0013\nEND_VAR\n xVar1 := NOT GVL.xVar1;\niVar3 := iVar3 + INT#2;\niVar3 := GVL.iVar3; Salida en el Mensajes vista: SA0013: La declaración de 'iVar1' oculta el símbolo 'GVL.iVar1' SA0013: La declaración de 'xVar3' oculta el símbolo 'GVL.xVar3' Ejemplo El FB_Pou El bloque de funciones tiene la ACT acción, la METH método y variables locales con los mismos nombres. FUNCTION_BLOCK FB_Pou\nVAR\n ACT : UINT; \/\/ SA0013\n METH : BYTE; \/\/ SA0013\nEND_VAR PROGRAM PLC_PRG\nVAR\n fbPou : FB_Pou;\nEND_VAR\n fbPou(); Salida en el Mensajes vista: SA0013: La declaración de 'ACT' oculta el símbolo 'FB_Pou.ACT' SA0013: La declaración de 'METH' oculta el símbolo 'FB_Pou.METH' " }, 
{ "title" : "SA0014: Asignación de instancias ", 
"url" : "_san_rule_sa0014.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0014: Asignación de instancias ", 
"snippet" : "Detecta asignaciones a instancias de bloques de funciones. En el caso de instancias con puntero o variables de referencia, estas asignaciones son potencialmente riesgosas. Justificación: Esta es una advertencia de rendimiento. Cuando se asigna una instancia a otra instancia, todos los elementos y su...", 
"body" : "Detecta asignaciones a instancias de bloques de funciones. En el caso de instancias con puntero o variables de referencia, estas asignaciones son potencialmente riesgosas. Justificación: Esta es una advertencia de rendimiento. Cuando se asigna una instancia a otra instancia, todos los elementos y subelementos se copian de una instancia a la otra instancia. Los punteros a los datos también se copian, pero no sus datos de referencia, de modo que la instancia de destino y la instancia de origen contengan los mismos datos después de la asignación. Dependiendo del tamaño de las instancias, este tipo de asignación podría durar mucho tiempo. Por ejemplo, si se debe pasar una instancia a una función para su procesamiento, entonces es mucho más eficiente pasar un puntero a la instancia. Si desea copiar valores de forma selectiva de una instancia a otra, un método de copia es útil: inst_First.Copy_From(inst_Second) Importancia: Media Ejemplo PROGRAM PLC_PRG\nVAR\n inst_First : My_FB;\n inst_Second : My_FB;\nEND_VAR\n inst_First();\ninst_Second := inst_First; \/\/ SA0014 Salida en el Mensajes vista: SA0014: Asignación de instancias " }, 
{ "title" : "SA0015: Acceso a datos globales vía FB_Init ", 
"url" : "_san_rule_sa0015.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0015: Acceso a datos globales vía FB_Init ", 
"snippet" : "Detecta el acceso de un bloque de funciones a variables globales mediante el método FB_Init . El valor de esta variable depende del orden de las inicializaciones. Justificación: Dependiendo de la ubicación de la declaración de la instancia de POU, se podría acceder a una variable no inicializada si ...", 
"body" : "Detecta el acceso de un bloque de funciones a variables globales mediante el método FB_Init . El valor de esta variable depende del orden de las inicializaciones. Justificación: Dependiendo de la ubicación de la declaración de la instancia de POU, se podría acceder a una variable no inicializada si se viola la regla. Importancia: Alta Ejemplo VAR_GLOBAL\n g_xTest1 : BOOL;\n g_iTest3 : INT;\nEND_VAR METHOD PUBLIC fb_init : BOOL\nVAR_INPUT\n (* If TRUE, the retain variables are initialized (warm start \/ cold start) *)\n bInitRetains : BOOL; \n (* If TRUE, the instance afterwards gets moved into the copy code (online change) *)\n bInCopyCode : BOOL; \nEND_VAR\n g_xTest1 := NOT g_xTest1; \/\/ SA0015\ng_iTest3 := g_iTest3 + INT#1; \/\/ SA0015 Salida en el Mensajes vista: SA0015: El método FB_Init del bloque de funciones 'POU' accede a datos globales " }, 
{ "title" : "SA0016: Huecos en estructuras ", 
"url" : "_san_rule_sa0016.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0016: Huecos en estructuras ", 
"snippet" : "Detecta brechas en estructuras o bloques de funciones causadas por los requisitos de alineación del sistema de destino establecido actualmente. Si es posible, debe eliminar los huecos recurriendo a los elementos de la estructura o rellenándolos con un elemento ficticio. Si esto no es posible, puede ...", 
"body" : "Detecta brechas en estructuras o bloques de funciones causadas por los requisitos de alineación del sistema de destino establecido actualmente. Si es posible, debe eliminar los huecos recurriendo a los elementos de la estructura o rellenándolos con un elemento ficticio. Si esto no es posible, puede desactivar la regla para las estructuras afectadas mediante el analysis pragma. Justificación: debido a los diferentes requisitos de alineación en diferentes plataformas, puede haber un diseño diferente en la memoria para este tipo de estructuras. Luego, el código puede funcionar de manera diferente, según la plataforma. Importancia: Baja Ejemplo TYPE Unpadded_Structure :\nSTRUCT\n xTest : BOOL;\n iTest : INT; \/\/ SA0016\n byTest : BYTE;\n wTest : WORD;\nEND_STRUCT\nEND_TYPE\n PROGRAM PLC_PRG\nVAR\n myStruct : Unpadded_Structure;\nEND_VAR\n myStruct.iTest := 0; Salida en el Mensajes vista: SA0016: La estructura 'Unpadded_Structure' debe estar rellenada (pack-mode=8) " }, 
{ "title" : "SA0017: Asignación inusual a variable de puntero ", 
"url" : "_san_rule_sa0017.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0017: Asignación inusual a variable de puntero ", 
"snippet" : "Detecta asignaciones a punteros que no son direcciones ( ADR operador, variables de puntero) ni constantes 0 Justificación: Si a un puntero se le asigna un valor que no es una dirección válida, la desreferenciación del puntero conduce a una \"Excepción de infracción de acceso\". Importancia: Alta Ejem...", 
"body" : "Detecta asignaciones a punteros que no son direcciones ( ADR operador, variables de puntero) ni constantes 0 Justificación: Si a un puntero se le asigna un valor que no es una dirección válida, la desreferenciación del puntero conduce a una \"Excepción de infracción de acceso\". Importancia: Alta Ejemplo PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n dwAddress : DWORD;\nEND_VAR\n dwAddress := dwAddress + DWORD#1;\npInt := dwAddress; \/\/ SA0017 Salida en el Mensajes vista: SA0017: Asignación inusual a variable de puntero " }, 
{ "title" : "SA0018: Acceso a bit inusual ", 
"url" : "_san_rule_sa0018.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0018: Acceso a bit inusual ", 
"snippet" : "Detecta el acceso de bits a variables firmadas. Sin embargo, el estándar IEC 61131-3 solo permite operaciones de acceso y desplazamiento de bits en campos de bits. Vea también las reglas estrictas   SA0147 y SA0148 . Justificación: Los tipos de datos firmados no deben usarse como campos de bits y vi...", 
"body" : "Detecta el acceso de bits a variables firmadas. Sin embargo, el estándar IEC 61131-3 solo permite operaciones de acceso y desplazamiento de bits en campos de bits. Vea también las reglas estrictas   SA0147 y SA0148 . Justificación: Los tipos de datos firmados no deben usarse como campos de bits y viceversa. El estándar IEC 61131-3 no proporciona este tipo de acceso y, por lo tanto, debe cumplir con esta regla cuando escriba código portátil. Importancia: Media Excepción para enumeraciones de banderas: cuando una enumeración se declara como bandera por medio de la {attribute 'flags'} atributo pragma, el SA0018 no se emite un error para el acceso a bits con el OR , AND o NOT operadores. Ejemplo PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/SA0018\ndiTemp3.4 := TRUE; \/\/SA0018\nuliTemp4.18 := FALSE; \/\/no error because this is an unsigned data type\nsiTemp5.2 := FALSE; \/\/SA0018\nusiTemp6.3 := TRUE; \/\/no error because this is an unsigned data type\nbyTemp2.5 := FALSE; \/\/no error because the byte is a bitfield Salida en el Mensajes vista: SA0018: Acceso a bits inusual " }, 
{ "title" : "SA0020: Posible asignación de valor truncado a variable REAL ", 
"url" : "_san_rule_sa0020.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0020: Posible asignación de valor truncado a variable REAL ", 
"snippet" : "Detecta operaciones en variables enteras para las que se podría asignar un valor truncado a un REAL variable de tipo de datos Justificación: El análisis estático genera un error cuando el resultado de un cálculo entero se asigna a un REAL o LREAL variable. El programador debe ser alertado de una pos...", 
"body" : "Detecta operaciones en variables enteras para las que se podría asignar un valor truncado a un REAL variable de tipo de datos Justificación: El análisis estático genera un error cuando el resultado de un cálculo entero se asigna a un REAL o LREAL variable. El programador debe ser alertado de una posible interpretación incorrecta de este tipo de asignación: lrealvar := dintvar1 * dintvar2 . Debido a que el rango de valores de LREAL es mayor que la de DINT , se podría suponer que el resultado del cálculo siempre podría representarse en LREAL . Pero ese no es el caso. El procesador calcula el resultado de la multiplicación como un número entero y luego convierte el resultado a LREAL . Se perdería un desbordamiento en el cálculo de enteros. Para solucionar el problema, el cálculo debe hacerse como un REAL operación: lreal_var := TO_LREAL(dintvar1) * TO_LREAL(dintvar2) . Importancia: Alta Ejemplo PROGRAM PLC_PRG\nVAR\n rX : LREAL;\n dI : DINT;\nEND_VAR\n rX := dI * dI \/\/ SA0020\nrX := TO_LREAL(dI) * TO_LREAL(dI) \/\/no message Salida en el Mensajes vista: SA0020: Posible asignación de valor truncado a variable REAL " }, 
{ "title" : "SA0021: Transporte de la dirección de una variable temporal ", 
"url" : "_san_rule_sa0021.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0021: Transporte de la dirección de una variable temporal ", 
"snippet" : "Detecta asignaciones de direcciones de variables temporales (en la pila) a variables no temporales Justificación: Las variables locales de una función o método se crean en la pila y existen solo mientras se procesa la función o el método. Si un puntero apunta a este tipo de variable después de proce...", 
"body" : "Detecta asignaciones de direcciones de variables temporales (en la pila) a variables no temporales Justificación: Las variables locales de una función o método se crean en la pila y existen solo mientras se procesa la función o el método. Si un puntero apunta a este tipo de variable después de procesar el método o la función, puede usar este puntero para acceder a la memoria indefinida o para acceder a una variable incorrecta en otra función. Esta situación debe evitarse a toda costa. Importancia: Alta Ejemplo FUNCTION TempVarInFUNC : DWORD\nVAR\n uiTemp : UINT;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0021 PROGRAM PLC_PRG\nVAR\n dwTest : DWORD;\nEND_VAR dwTest := TempVarInFUNC(); Salida en el Mensajes vista: SA0021: Transporte de dirección de variable temporal al símbolo de alcance externo " }, 
{ "title" : "SA0022: (Posiblemente) valor de retorno no asignado ", 
"url" : "_san_rule_sa0022.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0022: (Posiblemente) valor de retorno no asignado ", 
"snippet" : "Detecta todas las funciones y métodos que incluyen un hilo de ejecución sin una asignación al valor de retorno Justificación: un valor de retorno no asignado en una función o método es una indicación de código faltante. Incluso si el valor devuelto siempre tiene un valor predeterminado, siempre es ú...", 
"body" : "Detecta todas las funciones y métodos que incluyen un hilo de ejecución sin una asignación al valor de retorno Justificación: un valor de retorno no asignado en una función o método es una indicación de código faltante. Incluso si el valor devuelto siempre tiene un valor predeterminado, siempre es útil volver a asignarlo explícitamente para evitar confusiones. Importancia: Media Ejemplo FUNCTION FUN : DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR\n IF bTest THEN\n RETURN;\nEND_IF\nFUN := 99; Salida en el Mensajes vista: SA0022: (Posiblemente) valor de retorno no asignado " }, 
{ "title" : "SA0023: Valores de retorno complejos ", 
"url" : "_san_rule_sa0023.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0023: Valores de retorno complejos ", 
"snippet" : "Determina valores de retorno complejos que no se pueden devolver con una copia de registro simple del procesador. Esto incluye estructuras, matrices y valores de retorno de tipo STRING (independientemente del tamaño de la memoria utilizada). Justificación: Se trata de una advertencia de rendimiento....", 
"body" : "Determina valores de retorno complejos que no se pueden devolver con una copia de registro simple del procesador. Esto incluye estructuras, matrices y valores de retorno de tipo STRING (independientemente del tamaño de la memoria utilizada). Justificación: Se trata de una advertencia de rendimiento. Si se devuelven valores grandes como resultado de una función, método o propiedad, el procesador los copia varias veces al ejecutar el código. Esto puede provocar problemas de tiempo de ejecución y debe evitarse siempre que sea posible. El rendimiento se puede mejorar pasando un valor estructurado como VAR_IN_OUT a una función o método y completándolo en la función o método. Importancia: Media Ejemplo TYPE LargeStructure :\nSTRUCT\n a : LINT;\n b : BOOL;\nEND_STRUCT\nEND_TYPE\n FUNCTION Large_Return_Value_FUNC : LargeStructure \/\/ SA0023 Salida en el Mensajes vista: SA0023: Valores de retorno complejos " }, 
{ "title" : "SA0024: Literales\/constantes sin tipo ", 
"url" : "_san_rule_sa0024.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0024: Literales\/constantes sin tipo ", 
"snippet" : "Identifica literales sin tipo que forman parte de una operación. Justificación: Los literales sin tipo se escriben automáticamente según su uso. En algunos casos, como dw := ROL(DWORD#1, i); , esto puede dar lugar a situaciones inesperadas en las que es mejor utilizar un literal escrito para proporc...", 
"body" : "Identifica literales sin tipo que forman parte de una operación. Justificación: Los literales sin tipo se escriben automáticamente según su uso. En algunos casos, como dw := ROL(DWORD#1, i); , esto puede dar lugar a situaciones inesperadas en las que es mejor utilizar un literal escrito para proporcionar una aclaración única. Importancia: Baja Ejemplo PROGRAM PLC_PRG\nVAR\n iTemp1 : INT := 10; \/\/no part of operation\n diTemp2 : DINT;\n liTemp3 : LINT;\n rTemp4 : REAL;\n lrTemp5 : LREAL;\n END_VAR iTemp1 := iTemp1 + INT#34;\ndiTemp2 := diTemp2 + 23; \/\/ SA0024\nliTemp3 := liTemp3 + 124; \/\/ SA0024\nrTemp4 := rTemp4 + 1.1; \/\/ SA0024\nlrTemp5 := lrTemp5 + 3.4; \/\/ SA0024\n Salida en el Mensajes vista: SA0024: Se encontró un literal sin tipo " }, 
{ "title" : "SA0025: Constantes de enumeración no cualificadas ", 
"url" : "_san_rule_sa0025.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0025: Constantes de enumeración no cualificadas ", 
"snippet" : "Detecta constantes de enumeración para las que un nombre calificado no antepone la enumeración Justificación: El acceso cualificado hace que el código sea más legible y más fácil de mantener. Sin forzar nombres de variables calificados, se podría insertar una enumeración adicional cuando se extienda...", 
"body" : "Detecta constantes de enumeración para las que un nombre calificado no antepone la enumeración Justificación: El acceso cualificado hace que el código sea más legible y más fácil de mantener. Sin forzar nombres de variables calificados, se podría insertar una enumeración adicional cuando se extienda el programa. Esta enumeración contiene una constante con el mismo nombre que una enumeración existente (consulte el siguiente ejemplo: \"rojo\"). Esto daría como resultado un acceso ambiguo a este fragmento de código. En todos los casos, recomendamos utilizar sólo enumeraciones con el pragma {attribute 'qualified-only'} . Importancia: Media Ejemplo TYPE COLOR :\n (red,\n green,\n blue);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n myColor : COLOR;\nEND_VAR\n myColor := COLOR.red; \/\/ OK\nmyColor := red; \/\/ SA0025 Salida en el Mensajes vista: SA0025: Constante de enumeración 'red' no calificada Para más información, ver: Configuración y ejecución de análisis estáticos " }, 
{ "title" : "SA0026: Posibles cadenas truncadas ", 
"url" : "_san_rule_sa0026.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0026: Posibles cadenas truncadas ", 
"snippet" : "Detecta asignaciones de cadenas e inicializaciones de cadenas que no utilizan una longitud de cadena suficiente Justificación: cuando se asignan cadenas de diferentes longitudes, una cadena podría truncarse. Esto puede tener resultados inesperados. Importancia: Media Ejemplo PROGRAM PLC_PRG VAR strV...", 
"body" : "Detecta asignaciones de cadenas e inicializaciones de cadenas que no utilizan una longitud de cadena suficiente Justificación: cuando se asignan cadenas de diferentes longitudes, una cadena podría truncarse. Esto puede tener resultados inesperados. Importancia: Media Ejemplo PROGRAM PLC_PRG\nVAR\n strVar1 : STRING[10];\n strVar2 : STRING[6];\n strVar3 : STRING[6] := 'abcdefghi'; \/\/ SA0026\nEND_VAR\n strVar2 := strVar1; \/\/ SA0026 Salida en el Mensajes vista: SA0026: Truncamiento de 'abcdefghi' SA0026: Posible truncamiento de la cadena 'strVar1' Para más información, ver: Configuración y ejecución de análisis estáticos " }, 
{ "title" : "SA0027: Múltiples usos de identificadores ", 
"url" : "_san_rule_sa0027.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0027: Múltiples usos de identificadores ", 
"snippet" : "Detecta múltiples usos de un nombre\/identificador para una variable o un objeto (POU) dentro del alcance de un proyecto. Para las enumeraciones, se tiene en cuenta el nombre calificado. Justificación: Los mismos nombres pueden resultar confusos al leer el código. Pueden causar errores si se accede a...", 
"body" : "Detecta múltiples usos de un nombre\/identificador para una variable o un objeto (POU) dentro del alcance de un proyecto. Para las enumeraciones, se tiene en cuenta el nombre calificado. Justificación: Los mismos nombres pueden resultar confusos al leer el código. Pueden causar errores si se accede accidentalmente al objeto incorrecto. Defina y siga las convenciones de nomenclatura para evitar cualquier situación como esta. Se detectan los siguientes casos: El nombre de una enumeración es idéntico al nombre de otra enumeración en la aplicación o en una biblioteca integrada. El nombre de una variable es idéntico al nombre de otro objeto en la aplicación o en una biblioteca integrada. El nombre de una variable es idéntico al nombre de una constante de enumeración en una enumeración en la aplicación o en una biblioteca integrada. El nombre de un objeto es idéntico al nombre de otro objeto en la aplicación o en una biblioteca integrada. Importancia: Media Ejemplo TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n color : INT;\nEND_VAR\n Salida en el Mensajes vista: SA0027: El nombre de variable 'color' en 'PLC_PRG' ya se utiliza para un objeto en esta aplicación Para más información, ver: Configurar y ejecutar análisis estático " }, 
{ "title" : "SA0028: Áreas de memoria superpuestas ", 
"url" : "_san_rule_sa0028.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0028: Áreas de memoria superpuestas ", 
"snippet" : "Detecta las líneas de código donde dos o más variables reservan la misma memoria. Justificación: Cuando dos variables reservan la misma memoria, el código puede comportarse con resultados inesperados. Esta situación debe evitarse a toda costa. Si no puede evitar utilizar un valor en diferentes inter...", 
"body" : "Detecta las líneas de código donde dos o más variables reservan la misma memoria. Justificación: Cuando dos variables reservan la misma memoria, el código puede comportarse con resultados inesperados. Esta situación debe evitarse a toda costa. Si no puede evitar utilizar un valor en diferentes interpretaciones (por ejemplo, una vez como DINT y otra vez como REAL ), entonces deberías definir un UNION . También puede utilizar un puntero para acceder a un valor con un tipo diferente sin que se convierta el valor. Importancia: Alta Ejemplo PROGRAM PLC_PRG\nVAR\n iVvar1 AT %QB21: INT;\n dwVar2 AT %QD5: DWORD;\nEND_VAR\n Salida en el Mensajes vista: Las siguientes variables acceden a la misma memoria: SA0028: iVar1 en %QB21 SA0028: dwVar2 EN %QD5 Para más información, ver: Configuración y ejecución de análisis estáticos " }, 
{ "title" : "SA0029: Notación en código diferente a declaración ", 
"url" : "_san_rule_sa0029.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0029: Notación en código diferente a declaración ", 
"snippet" : "Detecta las ubicaciones de código donde la notación de un identificador es diferente de la notación en su declaración Justificación: La norma IEC 61131-3 define que los identificadores no distinguen entre mayúsculas y minúsculas. Esto significa que una variable declarada como \" varx \"también se pued...", 
"body" : "Detecta las ubicaciones de código donde la notación de un identificador es diferente de la notación en su declaración Justificación: La norma IEC 61131-3 define que los identificadores no distinguen entre mayúsculas y minúsculas. Esto significa que una variable declarada como \" varx \"también se puede utilizar como\" VaRx \" en el código. Sin embargo, esto es confuso y engañoso y debe evitarse. Importancia: Media Ejemplo A PLC_PRG POU y un fnc (función) POU existe en el árbol de dispositivos. PROGRAM PLC_PRG\nVAR\n iVar: INT;\n _123test_var_: INT;\nEND_VAR\n ivar := iVar + 1; \/\/ SA0029\n_123TEST_var_ := _123test_var_; \/\/ SA0029\nFnc(); \/\/ SA0029 Salida en el Mensajes vista: SA0029: La notación en el código (ivar) debe ser igual a la declaración (iVar) SA0029: La notación en el código (_123TEST_var_) debe ser igual a la declaración (_123test_var_) SA0029: La notación en el código (Fnc) debe ser igual a la declaración (fnc) Para más información, ver: Configurar y ejecutar análisis estático " }, 
{ "title" : "Objetos no utilizados ", 
"url" : "_san_list_unused_objects.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Objetos no utilizados ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0031: Firmas no utilizadas ", 
"url" : "_san_rule_sa0031.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Objetos no utilizados \/ SA0031: Firmas no utilizadas ", 
"snippet" : "Detecta programas, bloques de funciones, funciones, tipos de datos, interfaces, métodos, propiedades y acciones que no se llaman dentro del código del programa compilado Justificación: Los objetos no utilizados aumentan innecesariamente el tamaño del proyecto y pueden resultar confusos a la hora de ...", 
"body" : "Detecta programas, bloques de funciones, funciones, tipos de datos, interfaces, métodos, propiedades y acciones que no se llaman dentro del código del programa compilado Justificación: Los objetos no utilizados aumentan innecesariamente el tamaño del proyecto y pueden resultar confusos a la hora de leer el código. Importancia: Baja Regla PLCopen: CP2 Si existen varias aplicaciones en un proyecto, solo se verán afectados los objetos debajo de las aplicaciones actualmente activas. Si solo hay una aplicación, los objetos en el grupo de POU también se ven afectados. Ver también Configuración y ejecución de análisis estáticos " }, 
{ "title" : "SA0032: Constantes de enumeración no utilizadas ", 
"url" : "_san_rule_sa0032.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Objetos no utilizados \/ SA0032: Constantes de enumeración no utilizadas ", 
"snippet" : "Detecta constantes de enumeración que no se utilizan en el código del programa compilado Justificación: Las constantes de enumeración no utilizadas aumentan innecesariamente el tamaño de la definición de enumeración y pueden resultar confusos al leer el programa. Regla PLCopen: CP24 Importancia: Baj...", 
"body" : "Detecta constantes de enumeración que no se utilizan en el código del programa compilado Justificación: Las constantes de enumeración no utilizadas aumentan innecesariamente el tamaño de la definición de enumeración y pueden resultar confusos al leer el programa. Regla PLCopen: CP24 Importancia: Baja Si existen varias aplicaciones en un proyecto, solo se verán afectados los objetos debajo de las aplicaciones actualmente activas. Si solo hay una aplicación, los objetos del grupo de POU comunes también se ven afectados. Ejemplo TYPE My_Enum :\n(\n one := 1, \n two := 2\n);\nEND_TYPE\n Salida en el Mensajes vista: SA0032: Constante de enumeración no utilizada 'uno' SA0032: Constante de enumeración no utilizada 'dos' Para más información, ver: Configurar y ejecutar análisis estático " }, 
{ "title" : "SA0033: Variables no utilizadas ", 
"url" : "_san_rule_sa0033.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Objetos no utilizados \/ SA0033: Variables no utilizadas ", 
"snippet" : "Detecta variables que se declaran pero no se usan dentro del código del programa compilado Justificación: Las variables no utilizadas hacen que un programa sea menos legible y mantenible. Las variables no utilizadas llenan la memoria innecesariamente y desperdician tiempo de ejecución innecesariamen...", 
"body" : "Detecta variables que se declaran pero no se usan dentro del código del programa compilado Justificación: Las variables no utilizadas hacen que un programa sea menos legible y mantenible. Las variables no utilizadas llenan la memoria innecesariamente y desperdician tiempo de ejecución innecesariamente durante la inicialización. Importancia: Media Regla PLCopen: CP22 \/ CP24 Para las variables de GVL: si existen varias aplicaciones en un proyecto, solo se consideran los objetos que se encuentran debajo de la aplicación activa actualmente. Si solo hay una aplicación, también se tienen en cuenta los objetos del conjunto de POU común Ejemplo PROGRAM PLC_PRG\nVAR\n iCounter1 : INT;\n iCounter2 : INT; \/\/ SA0033\nEND_VAR\n iCounter1 := 100; Salida en el Mensajes vista: SA0033: Variable 'iCounter2' no utilizada Para más información, ver: Configurar y ejecutar análisis estático " }, 
{ "title" : "SA0035: Variables de entrada no utilizadas ", 
"url" : "_san_rule_sa0035.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Objetos no utilizados \/ SA0035: Variables de entrada no utilizadas ", 
"snippet" : "Detecta variables de entrada que no son utilizadas por ninguna instancia de bloque de funciones Justificación: Las variables de entrada no utilizadas hacen que un programa sea menos legible y fácil de mantener. Las variables no utilizadas llenan innecesariamente la memoria y desperdician innecesaria...", 
"body" : "Detecta variables de entrada que no son utilizadas por ninguna instancia de bloque de funciones Justificación: Las variables de entrada no utilizadas hacen que un programa sea menos legible y fácil de mantener. Las variables no utilizadas llenan innecesariamente la memoria y desperdician innecesariamente el tiempo de ejecución. Se considera que una entrada se usa solo si se hace referencia a ella activamente en la implementación (o los métodos) de la propia instancia del bloque de funciones. Importancia: Media Regla PLCopen: CP24 Ejemplo FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\nEND_VAR iOut1 := iIn1; \/\/ iIn1 is used here PROGRAM PLC_PRG\nVAR\n fbAfb: FB_Afb;\nEND_VAR\n fbAfb(iIn2 := 99); \/\/ iIn2 is unused internally => error Salida en el Mensajes vista: SA0035: Entrada no utilizada 'iIn2' " }, 
{ "title" : "SA0036: Variables de salida no utilizadas ", 
"url" : "_san_rule_sa0036.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Objetos no utilizados \/ SA0036: Variables de salida no utilizadas ", 
"snippet" : "Determina variables de salida de funciones y bloques de funciones que no están asignadas dentro de la función o bloque de funciones relevante. Justificación: Las variables no utilizadas hacen que un programa sea menos legible y mantenible. Las variables no utilizadas llenan la memoria innecesariamen...", 
"body" : "Determina variables de salida de funciones y bloques de funciones que no están asignadas dentro de la función o bloque de funciones relevante. Justificación: Las variables no utilizadas hacen que un programa sea menos legible y mantenible. Las variables no utilizadas llenan la memoria innecesariamente y desperdician tiempo de ejecución innecesariamente durante la inicialización. Importancia: Media Regla PLCopen: CP24 Ejemplo FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\n iOut2: INT;\nEND_VAR\n iOut1 := iIn1 + iIn2; Salida en el Mensajes vista: SA0036: Salida no utilizada 'iOut1' " }, 
{ "title" : "SA0034: Enumeraciones con asignación incorrecta ", 
"url" : "_san_rule_sa0034.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0034: Enumeraciones con asignación incorrecta ", 
"snippet" : "Detecta valores que se asignan a una variable de enumeración. Solo se pueden asignar constantes de enumeración definidas de una variable de enumeración. Justificación: Una variable del tipo enumeración debe tener solo los valores previstos; de lo contrario, es posible que el código que utiliza esta ...", 
"body" : "Detecta valores que se asignan a una variable de enumeración. Solo se pueden asignar constantes de enumeración definidas de una variable de enumeración. Justificación: Una variable del tipo enumeración debe tener solo los valores previstos; de lo contrario, es posible que el código que utiliza esta variable no funcione correctamente. Recomendamos utilizar siempre enumeraciones con el pragma. {attribute 'strict'} . Entonces el compilador ya comprueba el uso correcto de los componentes de enumeración. Importancia: Alta Ejemplo TYPE COLOR :\n(\n Red := 0,\n Green,\n Yellow\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n eColor1: COLOR;\nEND_VAR\n eColor1 := COLOR.Red;\neColor1 := 1; \/\/ SA0034 Salida en el Mensajes vista: SA0034: Utilice el valor de enumeración en lugar de 'INT#1' Para más información, ver: Configurar y ejecutar análisis estático " }, 
{ "title" : "SA0037: Acceso de escritura a la variable de entrada ", 
"url" : "_san_rule_sa0037.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0037: Acceso de escritura a la variable de entrada ", 
"snippet" : "Detecta variables de entrada ( VAR_INPUT ) a los que se accede con permiso de escritura dentro de la POU Justificación: De acuerdo con el estándar IEC 61131-3, una variable de entrada no debe cambiarse dentro de una POU. Este tipo de acceso también es causa de errores y hace que el código sea poco f...", 
"body" : "Detecta variables de entrada ( VAR_INPUT ) a los que se accede con permiso de escritura dentro de la POU Justificación: De acuerdo con el estándar IEC 61131-3, una variable de entrada no debe cambiarse dentro de una POU. Este tipo de acceso también es causa de errores y hace que el código sea poco fácil de mantener. Esta es una indicación de que una variable se utiliza como variable de entrada y como variable auxiliar. Debe evitarse este tipo de doble uso. Importancia: Media Ejemplo VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL;\nEND_VAR PROGRAM PLC_PRG\nVAR_INPUT\n xVarIn1 : BOOL;\n xVarIn2 : BOOL;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_xGlob := xVarIn1;\n INT#2:\n g_xGlob := xVarIn2;\n ELSE\n g_xGlob := FALSE;\n xVarIn1 := FALSE; \/\/ SA0037\nEND_CASE Salida en el Mensajes vista: SA0037: Acceso de escritura a la variable de entrada 'xVarIn1' " }, 
{ "title" : "SA0038: Acceso de lectura a la variable de salida ", 
"url" : "_san_rule_sa0038.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0038: Acceso de lectura a la variable de salida ", 
"snippet" : "Detecta variables de salida ( VAR_OUTPUT ) a los que se accede con permiso de lectura dentro de la POU Justificación: Según la norma IEC 61131-3, está prohibido leer una salida dentro de una POU. Esta es una indicación de que el producto no solo se utiliza como producto, sino también como una variab...", 
"body" : "Detecta variables de salida ( VAR_OUTPUT ) a los que se accede con permiso de lectura dentro de la POU Justificación: Según la norma IEC 61131-3, está prohibido leer una salida dentro de una POU. Esta es una indicación de que el producto no solo se utiliza como producto, sino también como una variable temporal para resultados intermedios. Debe evitarse este tipo de doble uso. Importancia: Baja Ejemplo VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL ;\n g_iGlob AT %QW1 : INT ;\nEND_VAR PROGRAM PLC_PRG\nVAR_OUTPUT\n xVarOut1:BOOL;\n xVarOut2:INT;\n xVarOut3:INT;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n xVarOut1 := g_xGlob;\n xVarOut2 := g_iGlob;\n INT#2:\n xVarOut3 := xVarOut2; \/\/ SA0038\n ELSE\n xVarOut1 := FALSE;\n g_xGlob := xVarOut1; \/\/ SA0038\n xVarOut2 := INT#0;\n xVarOut3 := INT#-1;\nEND_CASE Salida en el Mensajes vista: SA0038: Acceso de lectura a la variable de salida 'xVarOUT2' SA0026: SA0038: Acceso de lectura a la variable de salida 'xVarOUT1' " }, 
{ "title" : "SA0040: Posible división por cero ", 
"url" : "_san_rule_sa0040.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0040: Posible división por cero ", 
"snippet" : "Detecta ubicaciones de código donde existe una posible división por cero Justificación: División por 0 resulta en un error. Siempre se debe comprobar primero si una variable a dividir es 0. Importancia: Alta Ejemplo VAR_GLOBAL g_iVar AT %QW1 : INT; END_VAR PROGRAM PLC_PRG VAR iCounter : INT; iSumme:...", 
"body" : "Detecta ubicaciones de código donde existe una posible división por cero Justificación: División por 0 resulta en un error. Siempre se debe comprobar primero si una variable a dividir es 0. Importancia: Alta Ejemplo VAR_GLOBAL\n g_iVar AT %QW1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n iSumme:INT;\n iMid:INT;\n iVal1:INT := INT#2;\n iVal2:INT;\n iVal3:INT := INT#3;\n iVal4:INT := INT#4;\n iVal5:INT;\nEND_VAR IF iVal2 <> 0 THEN\n iVal1 := iVal1\/iVal2; \/\/ no error\nEND_IF;\niMid := iSumme \/ iCounter; \/\/ SA0040\niCounter := iCounter + INT#1;\niSumme := g_iVar + iSumme;\nIF iMid < INT#100 THEN\n iVal1 := iVal1 \/ iVal2; \/\/ SA0040\nEND_IF Salida en el Mensajes vista: SA0040: Posible división por cero SA0040: Posible división por cero " }, 
{ "title" : "SA0041: Detectar posible código invariable de bucle ", 
"url" : "_san_rule_sa0041.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0041: Detectar posible código invariable de bucle ", 
"snippet" : "Detecta asignaciones en bucles que calculan el mismo valor para cada ciclo de bucle. Estas líneas de código podrían insertarse fuera del bucle. Justificación: Se trata de una advertencia de rendimiento. El código que se ejecuta en un bucle, pero que hace lo mismo en cada ciclo, se puede ejecutar fue...", 
"body" : "Detecta asignaciones en bucles que calculan el mismo valor para cada ciclo de bucle. Estas líneas de código podrían insertarse fuera del bucle. Justificación: Se trata de una advertencia de rendimiento. El código que se ejecuta en un bucle, pero que hace lo mismo en cada ciclo, se puede ejecutar fuera del bucle. Importancia: Media Ejemplo PROGRAM PLC_PRG\nVAR\n iCounter, iVar1, iVar2 : INT;\nEND_VAR FOR iCounter := 0 TO 10 DO\n iVar1 := 100; \/\/ SA0041\n iVar2 := iVar2 + iVar1;\nEND_FOR\n Salida en el Mensajes vista: SAN0041: Posible código invariante de bucle 'iVar1 := 100' " }, 
{ "title" : "SA0042: Uso de diferentes rutas de acceso ", 
"url" : "_san_rule_sa0042.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0042: Uso de diferentes rutas de acceso ", 
"snippet" : "Detecta el uso de diferentes rutas de acceso para la misma variable Justificación: Distintos accesos a un mismo elemento disminuyen la legibilidad y mantenibilidad de un programa. Recomendamos el uso constante de {attribute 'qualified-only'} para bibliotecas, listas de variables globales y enumeraci...", 
"body" : "Detecta el uso de diferentes rutas de acceso para la misma variable Justificación: Distintos accesos a un mismo elemento disminuyen la legibilidad y mantenibilidad de un programa. Recomendamos el uso constante de {attribute 'qualified-only'} para bibliotecas, listas de variables globales y enumeraciones. Esto fuerza un acceso completo. Importancia: Baja Ejemplo VAR_GLOBAL\n iTemp:INT;\n instPOU:POU;\nEND_VAR FUNCTION_BLOCK POU\nVAR\n a:INT;\nEND_VAR\n a := INT#1; PROGRAM SA0042\nVAR\n ptiTemp:POINTER TO INT;\n sTemp:STRING;\nEND_VAR ptiTemp := ADR(iTemp);\n\nptiTemp^ := INT#1;\niTemp := INT#2; \/\/ SA0042 - direct access on variable\nGVL.iTemp := INT#3; \/\/ SA0042 - access on variable via GVL\n\nsTemp := CONCAT( 'ab', 'cd'); \/\/ SA0042 - direct access on function\nsTemp := Standard.CONCAT( 'ab', 'cd'); \/\/ SA0042 - access on function via Standard\n\ninstPOU(); \/\/ SA0042 - direct access on POU instance\nGVL.instPOU(); \/\/ SA0042 - access via GVL\n Salida en el Mensajes vista: SA0042: Diferentes vías de acceso para 'CONCAT' SA0042: Diferentes rutas de acceso para 'Standard.CONCAT' SA0042: Diferentes rutas de acceso para 'instPOU' SA0042: Diferentes rutas de acceso para 'GVL.instPOU' SA0042: Diferentes rutas de acceso para 'iTemp' SA0042: Diferentes rutas de acceso para 'GVL.iTemp' " }, 
{ "title" : "SA0043: Uso de una variable global en una sola POU ", 
"url" : "_san_rule_sa0043.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0043: Uso de una variable global en una sola POU ", 
"snippet" : "Detecta el uso de una variable global en un único POU Justificación: Una variable global que se utiliza sólo en una ubicación también debería declararse únicamente en esta ubicación. Importancia: Media Regla PLCopen: CP26 Ejemplo VAR_GLOBAL g_xVar AT %QX0.0 : BOOL ; g_iTest AT %QW1 : INT ; g_wTest A...", 
"body" : "Detecta el uso de una variable global en un único POU Justificación: Una variable global que se utiliza sólo en una ubicación también debería declararse únicamente en esta ubicación. Importancia: Media Regla PLCopen: CP26 Ejemplo VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW1 : INT ;\n g_wTest AT %QW2 : WORD;\nEND_VAR PROGRAM prog1\nVAR\n iCondition : INT;\n bTemp : BOOL;\nEND_VAR\n iCondition := iCondition + INT#1;\nIF iCondition < INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n ELSIF iCondition = INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\nELSE\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n g_wTest := WORD#4; \/\/ g_WTest used also in prog2 -> OK\nEND_IF PROGRAM prog2\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_iTest := WORD_TO_INT(g_wTest); \/\/ SA0043 - g_iTest only written in this POU\n INT#2:\n g_iTest := INT#2; \/\/ SA0043 - g_iTest only written in this POU\n ELSE\n g_iTest := INT#3; \/\/ SA0043 - g_iTest only written in this POU\nEND_CASE Salida en el Mensajes vista: SA0043: La variable global 'g_xVar' solo se usa en 'prog1' SA0043: La variable global 'g_iTest' solo se usa en 'prog2' " }, 
{ "title" : "SA0044: Declaraciones con referencia a interfaz ", 
"url" : "_san_rule_sa0044.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0044: Declaraciones con referencia a interfaz ", 
"snippet" : "Detecta declaraciones con REFERENCE TO interfaces y declaraciones de VAR_IN_OUT variables con interfaces (implementadas implícitamente por medio de REFERENCE TO ) Justificación: un tipo de interfaz siempre es implícitamente una referencia a una instancia de un bloque de funciones que implementa esta...", 
"body" : "Detecta declaraciones con REFERENCE TO interfaces y declaraciones de VAR_IN_OUT variables con interfaces (implementadas implícitamente por medio de REFERENCE TO ) Justificación: un tipo de interfaz siempre es implícitamente una referencia a una instancia de un bloque de funciones que implementa esta interfaz. Por lo tanto, una referencia a una interfaz es una referencia a una referencia y puede provocar un comportamiento no deseado. Importancia: Alta Ejemplo ITF es una interfaz que se define en el proyecto. FUNCTION_BLOCK POU\nVAR_INPUT\n inst_itf2 : ITF;\nEND_VAR\nVAR_OUTPUT\n inst_itf3 : ITF;\nEND_VAR\nVAR_IN_OUT\n inst_itf4 : ITF; \/\/ SA0044\nEND_VAR\n PROGRAM PLC_PRG\nVAR\n inst : POU;\n itf_inst1 : ITF;\n itf_ref : REFERENCE TO ITF; \/\/ SA0044\nEND_VAR Salida en el Mensajes vista: SA0044: Referencia a la interfaz 'itf4_ref' SA0044: Referencia a la interfaz 'itf_ref' " }, 
{ "title" : "Conversiones ", 
"url" : "_san_conversion.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Conversiones ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0019: Conversiones implícitas de punteros ", 
"url" : "_san_rule_sa0019.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Conversiones \/ SA0019: Conversiones implícitas de punteros ", 
"snippet" : "Detecta las conversiones de punteros generadas de forma implícita Justificación: En CODESYS , los punteros no se escriben estrictamente y se pueden asignar entre sí de cualquier forma. Esto se usa con frecuencia y, por lo tanto, el compilador no lo informa. Sin embargo, también puede provocar un acc...", 
"body" : "Detecta las conversiones de punteros generadas de forma implícita Justificación: En CODESYS , los punteros no se escriben estrictamente y se pueden asignar entre sí de cualquier forma. Esto se usa con frecuencia y, por lo tanto, el compilador no lo informa. Sin embargo, también puede provocar un acceso no autorizado e inesperado. Por ejemplo, si asigna el tipo POINTER TO DWORD a un puntero con el tipo POINTER TO BYTE , la memoria se puede sobrescribir de forma no deseada. Por lo tanto, compruebe siempre esta regla y bloquee el mensaje solo en los casos en los que desee acceder intencionalmente a un valor de un tipo diferente. Conversiones hacia y desde el POINTER TO BYTE SA0019 no comprueba el tipo de datos. Siempre están permitidos. Las conversiones de tipos de datos implícitas se notifican con un mensaje diferente. Importancia: Alta Regla PLCopen: CP25 Excepción: BOOL <-> BIT Ejemplo PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n byteVar : BYTE;\nEND_VAR\n pInt := ADR(byteVar); Salida en el Mensajes vista: SA0019: Conversión implícita de puntero a 'POINTER TO BYTE' a puntero a 'POINTER TO INT' " }, 
{ "title" : "SA0130: Conversiones en expansión implícitas ", 
"url" : "_san_rule_sa0130.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Conversiones \/ SA0130: Conversiones en expansión implícitas ", 
"snippet" : "Detecta ubicaciones de código donde se realizan implícitamente conversiones de tipos de datos más pequeños a más grandes durante operaciones aritméticas. Justificación: El compilador permite asignaciones de diferentes tipos cuando el rango de valores del tipo de origen está completamente contenido d...", 
"body" : "Detecta ubicaciones de código donde se realizan implícitamente conversiones de tipos de datos más pequeños a más grandes durante operaciones aritméticas. Justificación: El compilador permite asignaciones de diferentes tipos cuando el rango de valores del tipo de origen está completamente contenido dentro del rango de valores del tipo de destino. Sin embargo, el compilador realizará una conversión en el código lo más tarde posible. Para una asignación de tipo lint := dint * dint , el compilador realiza la conversión implícita sólo después de la multiplicación: lint := TO_LINT(dint * dint); Por tanto, se trunca un desbordamiento. Si desea evitar esto, ya puede convertir los elementos: lint := TO_LINT(dint) * TO_LINT(dint); Por lo tanto, puede resultar útil informar las ubicaciones donde el compilador implementa conversiones implícitas para comprobar si son exactamente lo que se pretende. Además, se pueden utilizar conversiones explícitas para mejorar la portabilidad a otros sistemas cuando esos sistemas tienen comprobaciones de tipo más restrictivas. Importancia: Baja Ejemplo PROGRAM PLC_PRG\nVAR\n d : DINT;\n l : LINT;\n ui : UINT;\n uli : ULINT;\n usi : USINT;\n lw : LWORD;\n udi : UDINT;\n lr : LREAL;\n b : BYTE;\nEND_VAR\n (*The following lines could result in unwanted truncating by implicit conversions \nand should be reported with SA0130*) \nl := d * d;\nuli := usi * usi;\nlw := udi * udi;\nlr := b * b;\nd := ui * ui; Salida en el Messages  vista: SA0130: Conversión de expansión implícita de tipo 'DINT' al tipo 'LINT' SA0130: Conversión de expansión implícita del tipo 'USINT' al tipo 'ULINT' SA0130:  Conversión de expansión implícita del tipo 'UDINT' al tipo 'LWORD' SA0130: Conversión de expansión implícita del tipo 'USINT' al tipo 'LREAL' SA0130: Conversión de expansión implícita del tipo 'UINT' al tipo 'DINT' " }, 
{ "title" : "SA0133: Conversiones de restricción explícitas ", 
"url" : "_san_rule_sa0133.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Conversiones \/ SA0133: Conversiones de restricción explícitas ", 
"snippet" : "Detecta conversiones explícitas de un tipo de datos más grande a un tipo de datos más pequeño Justificación: Una gran cantidad de conversiones de tipos puede indicar que ha elegido los tipos de datos incorrectos para las variables. Por este motivo, existen pautas de programación que requieren una ju...", 
"body" : "Detecta conversiones explícitas de un tipo de datos más grande a un tipo de datos más pequeño Justificación: Una gran cantidad de conversiones de tipos puede indicar que ha elegido los tipos de datos incorrectos para las variables. Por este motivo, existen pautas de programación que requieren una justificación explícita para las conversiones de tipos de datos. Importancia: Baja Ejemplo PROGRAM SA0133\nVAR\n siVar:SINT;\n diVar:DINT;\n liVar:LINT;\n byVar:BYTE;\n uiVar:UINT;\n dwVar:DWORD;\n lwVar:LWORD;\n rVar:REAL;\n lrVar:LREAL;\nEND_VAR\n siVar := LINT_TO_SINT(liVar); \/\/ SA0133\nbyVar := DINT_TO_BYTE(diVar); \/\/ SA0133\nsiVar := DWORD_TO_SINT(dwVar); \/\/ SA0133\nuiVar := LREAL_TO_UINT(lrVar); \/\/ SA0133\nrVar := LWORD_TO_REAL(lwVar); \/\/ SA0133 Salida en el Mensajes vista: SA0133: Conversión de restricción explícita del tipo 'LINT' al tipo 'SINT' SA0133: Conversión de restricción explícita del tipo 'DINT' al tipo 'BYTE' SA0133: Conversiones de restricción explícita del tipo 'DWORD' al tipo 'SINT' SA0133: Conversión de restricción explícita del tipo 'LREAL' al tipo 'UINT' SA0133: Conversión de restricción explícita del tipo 'LWORD' al tipo 'REAL' " }, 
{ "title" : "SA0134: Conversiones explícitas firmadas\/sin firmar ", 
"url" : "_san_rule_sa0134.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Conversiones \/ SA0134: Conversiones explícitas firmadas\/sin firmar ", 
"snippet" : "Detecta conversiones explícitas de tipos de datos firmados a tipos de datos sin firmar y viceversa Justificación: El uso excesivo de conversiones de tipos puede indicar que se han seleccionado tipos de datos incorrectos para las variables. Por este motivo, existen pautas de programación que requiere...", 
"body" : "Detecta conversiones explícitas de tipos de datos firmados a tipos de datos sin firmar y viceversa Justificación: El uso excesivo de conversiones de tipos puede indicar que se han seleccionado tipos de datos incorrectos para las variables. Por este motivo, existen pautas de programación que requieren una justificación explícita para las conversiones de tipos de datos. Importancia: Baja Ejemplo PROGRAM PLC_PRG\nVAR\n byVar :BYTE;\n udiVar : UDINT;\n uliVar : ULINT;\n lwVar : LWORD;\n wVar : WORD;\n siVar : SINT;\n iVar : INT;\n diVar : DINT;\n liVar : LINT;\nEND_VAR\n liVar := ULINT_TO_LINT(uliVar);\nudiVar := DINT_TO_UDINT(diVar);\nsiVar := BYTE_TO_SINT(byVar);\nwVar := INT_TO_WORD(iVar);\nlwVar := SINT_TO_LWORD(siVar); Salida en el Mensajes vista: SA0134: Conversión explícita firmada\/sin firmar del tipo 'ULINT' al tipo 'LINT' SA0134: Conversión explícita firmada\/sin firmar del tipo 'DINT' al tipo 'UDINT' SA0134: Conversión explícita firmada\/sin firmar del tipo 'BYTE' al tipo 'SINT' SA0134: Conversión explícita firmada\/sin firmar del tipo 'INT' al tipo 'WORD' SA0134: Conversión explícita firmada\/sin firmar del tipo 'SINT' al tipo 'LWORD' " }, 
{ "title" : "Uso de direcciones directas ", 
"url" : "_san_use_direct_adresses.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Uso de direcciones directas ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0005: Direcciones y tipos de datos no válidos ", 
"url" : "_san_rule_sa0005.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Uso de direcciones directas \/ SA0005: Direcciones y tipos de datos no válidos ", 
"snippet" : "Detecta direcciones no válidas y especificaciones de tipos de datos. Prefijos de tamaño válidos en las direcciones: X para BOOL B para tipos de datos de 1 byte, W para tipos de datos de 2 bytes y D para tipos de datos de 4 bytes. Justificación: Las variables ubicadas en direcciones directas deben as...", 
"body" : "Detecta direcciones no válidas y especificaciones de tipos de datos. Prefijos de tamaño válidos en las direcciones: X para BOOL B para tipos de datos de 1 byte, W para tipos de datos de 2 bytes y D para tipos de datos de 4 bytes. Justificación: Las variables ubicadas en direcciones directas deben asociarse preferentemente a una dirección que corresponda al ancho de su tipo de datos. Puede ser confuso para el lector del código, por ejemplo, si un DWORD se asigna a un BYTE habla a. Importancia: Baja Ejemplo PROGRAM Check_Address_Type_PRG\nVAR\n iVar AT %QB0 : INT ; \/\/ OK e. g.: %QW0\n xTest AT %QW1 : BOOL ; \/\/ OK e. g.: %QX1.0\nEND_VAR iVar := iVar + INT#1;\nxTest := NOT xTest;\n Salida en el Mensajes vista: SA0005: Dirección no válida para el tipo de datos 'iVar' Para más información, ver: Configuración y ejecución de análisis estáticos " }, 
{ "title" : "SA0047: Accesos a domicilio directo ", 
"url" : "_san_rule_sa0047.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Uso de direcciones directas \/ SA0047: Accesos a domicilio directo ", 
"snippet" : "Detecta el acceso directo a la dirección en el código de implementación. Justificación: Siempre es preferible la programación simbólica. Una variable tiene un nombre que también puede tener un significado. Una dirección no puede indicar para qué se utiliza. Importancia: Alta Regla PLCopen: N1 \/ CP1 ...", 
"body" : "Detecta el acceso directo a la dirección en el código de implementación. Justificación: Siempre es preferible la programación simbólica. Una variable tiene un nombre que también puede tener un significado. Una dirección no puede indicar para qué se utiliza. Importancia: Alta Regla PLCopen: N1 \/ CP1 Ejemplo PROGRAM PLC_PRG\nVAR\n xVar : BOOL;\n byVar : BYTE;\nEND_VAR\n xVar := %IX0.0;\n%QX0.0 := xVar;\n%MX0.1 := xVar;\n%MB1 := byVar; Salida en el Mensajes vista: SA0047: Accesos a dirección directa '%IX0.0' SA0026: Accesos a dirección directa '%QX0.0' SA0026: Accesos a dirección directa '%MX0.1' SA0026: Accesos a dirección directa '%MB1' " }, 
{ "title" : "SA0048: AT-declaraciones sobre direcciones directas ", 
"url" : "_san_rule_sa0048.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Uso de direcciones directas \/ SA0048: AT-declaraciones sobre direcciones directas ", 
"snippet" : "Detecta AT declaraciones sobre direcciones directas El uso de direcciones directas en el código es problemático porque la dirección aparece en varias ubicaciones: Primero en la configuración del controlador donde se define la asignación de un objeto físico a una dirección Segundo en el programa dond...", 
"body" : "Detecta AT declaraciones sobre direcciones directas El uso de direcciones directas en el código es problemático porque la dirección aparece en varias ubicaciones: Primero en la configuración del controlador donde se define la asignación de un objeto físico a una dirección Segundo en el programa donde se asignan variables a estas direcciones. Si las direcciones se reubican porque se cambia la configuración, entonces necesita reasignar variables a direcciones en una ubicación completamente diferente en el programa. Esto es una causa de error y da como resultado una peor legibilidad y mantenibilidad del código. Por lo tanto, es mejor realizar todas las asignaciones en la asignación de E\/S del editor de dispositivos. Importancia: Alta Regla PLCopen: N1 \/ CP1 Le recomendamos que utilice direcciones directas SÓLO en el Mapeo de E\/S pestaña del editor de dispositivos. Ejemplo PROGRAM PLC_PRG\nVAR\n xVar1 AT %IX0.0 : BOOL;\n byVar1 AT %IB1 : BYTE;\n xVar2 AT %QX0.0 : BOOL;\nEND_VAR\n Salida en el Mensajes vista: SA0048: La declaración utiliza la dirección directa '%IX0.0' SA0048: La declaración utiliza la dirección directa '%IB1' SA0048: La declaración utiliza la dirección directa '%QX0.0' " }, 
{ "title" : "Reglas para Operadores ", 
"url" : "_san_rule_operators.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0051: Operaciones de comparación sobre variables BOOL ", 
"url" : "_san_rule_sa0051.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0051: Operaciones de comparación sobre variables BOOL ", 
"snippet" : "Detecta operaciones de comparación sobre variables de tipo BOOL Justificación: CODESYS permite este tipo de comparaciones. Pero son muy inusuales y pueden resultar confusos. La norma IEC 61131-3 no prevé estas comparaciones. Al evitarlos, aumenta la portabilidad del código a otros sistemas de desarr...", 
"body" : "Detecta operaciones de comparación sobre variables de tipo BOOL Justificación: CODESYS permite este tipo de comparaciones. Pero son muy inusuales y pueden resultar confusos. La norma IEC 61131-3 no prevé estas comparaciones. Al evitarlos, aumenta la portabilidad del código a otros sistemas de desarrollo. Importancia: Media Ejemplo PROGRAM PLC_PRG\nVAR\n xBool1, xBool2 : BOOL;\n xResult : BOOL;\nEND_VAR\n xResult := xBool1 > xBool2; \/\/ SA0051\nxBool1 := NOT xBool1; \/\/ OK!\nxBool2 := xBool2 XOR xBool1; \/\/ OK! Salida en el Mensajes vista: SA0051: Operaciones de comparación sobre variables BOOL " }, 
{ "title" : "SA0052: operación de cambio inusual ", 
"url" : "_san_rule_sa0052.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0052: operación de cambio inusual ", 
"snippet" : "Detecta operaciones de desplazamiento (desplazamiento de bits) en variables con signo. En el caso de operaciones de desplazamiento en tipos de datos de campo de bits ( Byte , DWORD , LWORD , WORD ), no se notifica un error. Justificación: CODESYS permite operaciones de cambio en tipos de datos firma...", 
"body" : "Detecta operaciones de desplazamiento (desplazamiento de bits) en variables con signo. En el caso de operaciones de desplazamiento en tipos de datos de campo de bits ( Byte , DWORD , LWORD , WORD ), no se notifica un error. Justificación: CODESYS permite operaciones de cambio en tipos de datos firmados. Sin embargo, estas operaciones son inusuales y pueden ser confusas. La norma IEC 61131-3 no prevé este tipo de operaciones. Por lo tanto, deben evitarse para aumentar la portabilidad del código a otros sistemas de desarrollo. Importancia: Media Ejemplo PROGRAM PLC_PRG\nVAR\n iTemp : INT;\n dwTemp1 : DWORD;\n byTemp2 : BYTE;\n diTemp3 : DINT;\n siTemp4 : SINT;\n liTemp5 : LINT;\nEND_VAR\n \/\/the following lines each will cause an SA0052:\niTemp := SHL(iTemp, BYTE#2);\ndiTemp3 := SHR(diTemp3, BYTE#4);\nsiTemp4 := ROL(siTemp4, BYTE#2);\nliTemp5 := ROR(liTemp5, BYTE#2);\n\n\/\/no error SA0052 because DWORD and BYTE are bitfield datatypes:\ndwTemp1 := SHL(dwTemp1, BYTE#3);\nbyTemp2 := SHR(byTemp2, BYTE#1); Salida en el Mensajes vista: SA0052: Operación de turno inusual " }, 
{ "title" : "SA0053: Desplazamiento bit a bit demasiado grande ", 
"url" : "_san_rule_sa0053.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0053: Desplazamiento bit a bit demasiado grande ", 
"snippet" : "Detecta si se ha excedido o no el ancho del tipo de datos del operando en el caso de un desplazamiento bit a bit (desplazamiento de bits) de operandos Justificación: si una operación de cambio excede el ancho del tipo de datos, entonces una constante 0 es generado. Si un cambio de rotación excede el...", 
"body" : "Detecta si se ha excedido o no el ancho del tipo de datos del operando en el caso de un desplazamiento bit a bit (desplazamiento de bits) de operandos Justificación: si una operación de cambio excede el ancho del tipo de datos, entonces una constante 0 es generado. Si un cambio de rotación excede el ancho del tipo de datos, entonces es difícil de leer. Por lo tanto, el valor de rotación debe acortarse. Importancia: Alta Ejemplo PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\n lwTemp4 : LWORD;\nEND_VAR\n byTemp1 := SHR(byTemp1, BYTE#25);\nwTemp2 := SHL(wTemp2, BYTE#45);\ndwTemp3 := ROR(dwTemp3, BYTE#78);\nlwTemp4 := ROL(lwTemp4, BYTE#111); Salida en el Mensajes vista: SA0053: Desplazamiento bit a bit demasiado grande " }, 
{ "title" : "SA0054: Comparaciones de REAL\/LREAL para igualdad\/desigualdad ", 
"url" : "_san_rule_sa0054.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0054: Comparaciones de REAL\/LREAL para igualdad\/desigualdad ", 
"snippet" : "Detecta si los operadores de comparación = (igualdad) y <> (desigualdad) comparar los operandos de tipo REAL o LREAL . Justificación: REAL \/ LREAL Los valores se implementan como números de punto flotante según el estándar IEEE 754. Este estándar implica que números decimales específicos, aparenteme...", 
"body" : "Detecta si los operadores de comparación = (igualdad) y <> (desigualdad) comparar los operandos de tipo REAL o LREAL . Justificación: REAL \/ LREAL Los valores se implementan como números de punto flotante según el estándar IEEE 754. Este estándar implica que números decimales específicos, aparentemente simples, no pueden representarse con precisión. Como resultado, puede haber diferentes representaciones como LREAL para el mismo número decimal. Considere las siguientes líneas de código: lr11 := 1.1;\nlr33 := 3.3;\nlrVar1 := lr11 + lr11;\nlrVar2 := lr33 - lr11;\nbotest := lrVar1 = lrVar2; En este caso, botest devoluciones FALSE , incluso si las variables lrVar1 y lrVar2 ambos devuelven el valor de monitoreo de \"2.2\". Esto no es un error del compilador, sino una propiedad de las unidades de coma flotante de todos los procesadores convencionales. Puede evitar esto especificando un valor mínimo por el cual los valores pueden diferir: botest := ABS(lrVar1 - lrVar2) < 0.1; Excepción: Una comparación con 0.0 este análisis no informa. Para el 0, existe una representación exacta en el estándar IEEE 754 y, por lo tanto, la comparación funciona normalmente como se esperaba. Como resultado, para obtener un mejor rendimiento, tiene sentido permitir aquí una comparación directa. Importancia: Alta Regla PLCopen: CP54 Ejemplo PROGRAM PLC_PRG\nVAR\n rTest1 : REAL;\n rTest2 : REAL;\n lrTest3 : LREAL;\n lrTest4 : LREAL;\n xResult : BOOL;\nEND_VAR \/\/the following lines each will cause an SA0054:\nxResult := rTest1 = rTest1;\nxResult := rTest1 = rTest2;\nxResult := rTest1 <> rTest2;\nxResult := lrTest3 = lrTest3;\nxResult := lrTest3 = lrTest4;\nxResult := lrTest3 <> lrTest4;\n\/\/the following lines each will not cause an SA0054:\nxResult := rTest1 > rTest2;\nxResult := lrTest3 < lrTest4;\n Salida en el Mensajes vista: SA0054: Comparaciones de REAL\/LREAL para igualdad\/desigualdad " }, 
{ "title" : "SA0055: Comparaciones innecesarias de operandos sin signo ", 
"url" : "_san_rule_sa0055.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0055: Comparaciones innecesarias de operandos sin signo ", 
"snippet" : "Detecta comparaciones innecesarias con operandos sin signo. Un tipo de datos sin firmar nunca es menor que cero. Esto se puede utilizar como una verificación de signos. Justificación: Una comparación detectada con esta verificación arroja un resultado constante y es una indicación de un error en el ...", 
"body" : "Detecta comparaciones innecesarias con operandos sin signo. Un tipo de datos sin firmar nunca es menor que cero. Esto se puede utilizar como una verificación de signos. Justificación: Una comparación detectada con esta verificación arroja un resultado constante y es una indicación de un error en el código. Importancia: Alta Ejemplo PROGRAM PLC_PRG\nVAR\n byTest: BYTE;\nEND_VAR\n \/\/ SA0055\nWHILE byTest >= 0 DO\n byTest := byTest - 1;\nEND_WHILE Salida en el Mensajes vista: SA0055: Comparaciones innecesarias de operandos sin signo " }, 
{ "title" : "SA0056: Constante fuera de rango válido ", 
"url" : "_san_rule_sa0056.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0056: Constante fuera de rango válido ", 
"snippet" : "Detecta literales (constantes) fuera del rango válido del operador Justificación: El mensaje se emite en los casos en que se compara un valor con una constante que está fuera del rango de este valor. Entonces la comparación regresa constantemente. TRUE o FALSE . Esto es una indicación de un error de...", 
"body" : "Detecta literales (constantes) fuera del rango válido del operador Justificación: El mensaje se emite en los casos en que se compara un valor con una constante que está fuera del rango de este valor. Entonces la comparación regresa constantemente. TRUE o FALSE . Esto es una indicación de un error de programación. Importancia: Alta Ejemplo PROGRAM PLC_PRG\nVAR\n byTestVar: BYTE;\nEND_VAR\n WHILE byTestVar >= 260 DO\n byTestVar := byTestVar + 1;\nEND_WHILE Salida en el Mensajes vista: SA0056: Constante fuera del rango válido " }, 
{ "title" : "SA0057: Posible pérdida de decimales ", 
"url" : "_san_rule_sa0057.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0057: Posible pérdida de decimales ", 
"snippet" : "Detecta sentencias con posible pérdida de decimales Justificación: Una pieza de código del siguiente tipo ( diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) ) puede causar una mala interpretación. El autor o lector de esta línea de código puede suponer que la división se realizaría como un REAL oper...", 
"body" : "Detecta sentencias con posible pérdida de decimales Justificación: Una pieza de código del siguiente tipo ( diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) ) puede causar una mala interpretación. El autor o lector de esta línea de código puede suponer que la división se realizaría como un REAL operación, y en este caso el resultado sería REAL#0.5 . Sin embargo, eso no es verdad. Es una operación entera. El resultado se proyecta a REAL y rTemp1 obtiene el valor REAL#0 . Para evitar esto, utilice un yeso para asegurarse de que la operación se realice como un REAL operación: rTemp1 := TO_REAL(diTemp2) \/ REAL#2; Importancia: Media Ejemplo PROGRAM PLC_PRG\nVAR\n rTemp1 : REAL;\n diTemp2 : DINT;\n liTemp3 : LINT;\nEND_VAR diTemp2 := diTemp2 + DINT#11;\n\/\/ SA0057\nrTemp1 := DINT_TO_REAL(diTemp2 \/ DINT#3); \nrTemp1 := DINT_TO_REAL(diTemp2) \/ REAL#3.0;\nliTemp3 := liTemp3 + LINT#13;\n\/\/ SA0057\nrTemp1 := LINT_TO_REAL(liTemp3 \/ LINT#7);\nrTemp1 := LINT_TO_REAL(liTemp3) \/ REAL#7.0; Salida en el Mensajes vista: SA0057: Posible pérdida de decimales " }, 
{ "title" : "SA0058: Operaciones sobre variables de enumeración ", 
"url" : "_san_rule_sa0058.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0058: Operaciones sobre variables de enumeración ", 
"snippet" : "Detecta operaciones sobre variables del tipo de datos de enumeración Se permiten asignaciones. Justificación: Las enumeraciones no deben utilizarse como valores enteros ordinarios. Alternativamente, se podría definir un tipo de datos de alias o se podría utilizar un tipo de subrango. Importancia: Me...", 
"body" : "Detecta operaciones sobre variables del tipo de datos de enumeración Se permiten asignaciones. Justificación: Las enumeraciones no deben utilizarse como valores enteros ordinarios. Alternativamente, se podría definir un tipo de datos de alias o se podría utilizar un tipo de subrango. Importancia: Media Excepción: si una enumeración está etiquetada con el pragma {attribute 'strict'} , entonces el compilador ya reporta este tipo de operación. Si una enumeración es declarada como bandera por el pragma {attribute 'flags'} , entonces no se emite un error para AND , OR , NOT , u orden XOR operaciones. Ejemplo TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : My_Enum;\nEND_VAR iTemp1 := iTemp1 + INT#1;\nabc := My_Enum.red; \/\/ OK\niTemp1 := My_Enum.black \/ My_Enum.blue; \/\/ SA0058\niTemp1 := My_Enum.green \/ My_Enum.red; \/\/ SA0058\n Salida en el Mensajes vista: SA0058: Operaciones sobre variables de enumeración Ejemplo con pragma {atributo 'flags'} {attribute 'flags'} \/\/ declaring the enumeration as a \"flag\"\nTYPE Flags :\n(\n Unknown := 16#00000001,\n Stopped := 16#00000002,\n Running := 16#00000004\n) DWORD;\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : Flags;\n batate : BYTE;\n dwFlags : DWORD;\n dwState : DWORD;\nEND_VAR \/\/ OK for the following\nIF (dwFlags AND Flags.Unknown) <> DWORD#0 THEN\n dwState := dwState AND Flags.Unknown;\n ELSIF (dwFlags OR Flags.Stopped) <> DWORD#0 THEN\n dwState := dwState OR Flags.Running;\nEND_IF " }, 
{ "title" : "SA0059: Las operaciones de comparación siempre devuelven TRUE o FALSO ", 
"url" : "_san_rule_sa0059.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0059: Las operaciones de comparación siempre devuelven TRUE o FALSO ", 
"snippet" : "Detecta comparaciones con literales cuyo resultado es siempre TRUE o FALSE y ya se puede procesar durante la compilación. Justificación: Una operación que consistentemente produce TRUE o FALSE es una indicación de un error de programación. Importancia: Alta Ejemplo PROGRAM PLC_PRG VAR byTemp1 : BYTE...", 
"body" : "Detecta comparaciones con literales cuyo resultado es siempre TRUE o FALSE y ya se puede procesar durante la compilación. Justificación: Una operación que consistentemente produce TRUE o FALSE es una indicación de un error de programación. Importancia: Alta Ejemplo PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\nEND_VAR\n WHILE byTemp1 <= 255 DO\n byTemp1 := byTemp1 + 1;\nEND_WHILE Salida en el Mensajes vista: SA0059: El operador relacional '<=' siempre se evalúa como 'VERDADERO'\n " }, 
{ "title" : "SA0060: Cero utilizado como operando no válido ", 
"url" : "_san_rule_sa0060.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0060: Cero utilizado como operando no válido ", 
"snippet" : "Detecta operaciones donde un operando con el valor 0 provoca una operación no válida o sin sentido Justificación: Este tipo de expresión podría ser un indicio de un error de programación. En cualquier caso, desperdicia tiempo de ejecución innecesariamente. Importancia: Media Ejemplo PROGRAM PLC_PRG ...", 
"body" : "Detecta operaciones donde un operando con el valor 0 provoca una operación no válida o sin sentido Justificación: Este tipo de expresión podría ser un indicio de un error de programación. En cualquier caso, desperdicia tiempo de ejecución innecesariamente. Importancia: Media Ejemplo PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\nEND_VAR\n byTemp1 := byTemp1 + 0;\nwTemp2 := wTemp2 - WORD#0;\ndwTemp3 := dwTemp3 * DWORD#0; Salida en el Mensajes vista: SA0060: Cero utilizado como operando no válido " }, 
{ "title" : "SA0061: Funcionamiento inusual en el puntero ", 
"url" : "_san_rule_sa0061.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0061: Funcionamiento inusual en el puntero ", 
"snippet" : "Detecta operaciones una variable de tipo POINTER TO que no son = (igualdad), <> (desigualdad), + (adición), o ADR . En CODESYS , la aritmética de punteros generalmente está permitida y también se puede usar apropiadamente. Por lo tanto, la adición de un puntero con un valor entero se considera una o...", 
"body" : "Detecta operaciones una variable de tipo POINTER TO que no son = (igualdad), <> (desigualdad), + (adición), o ADR . En CODESYS , la aritmética de punteros generalmente está permitida y también se puede usar apropiadamente. Por lo tanto, la adición de un puntero con un valor entero se considera una operación común en los punteros. Esto hace posible usar un puntero para procesar una matriz de longitud variable. Todas las demás operaciones (inusuales) con punteros se notifican con SA0061. Importancia: Alta Regla PLCopen: E2 \/ E3 Ejemplo PROGRAM PLC_PRG\nVAR\n piTemp : POINTER TO INT;\n iTemp : INT;\nEND_VAR\n iTemp := iTemp + INT#1;\npiTemp := ADR(iTemp);\npiTemp := piTemp * DWORD#5; \/\/ SA0061\npiTemp := piTemp \/ DWORD#2; \/\/ SA0061\npiTemp := piTemp MOD DWORD#3; \/\/ SA0061\npiTemp := piTemp + DWORD#1;\npiTemp := piTemp - DWORD#1; \/\/ SA0061 Salida en el Mensajes vista: SA0061: Operación inusual en el puntero " }, 
{ "title" : "SA0062: La expresión es constante ", 
"url" : "_san_rule_sa0062.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0062: La expresión es constante ", 
"snippet" : "Detecta el uso de expresiones que siempre tienen el mismo valor en tiempo de ejecución. Justificación: Una expresión compleja que se calcula repetidamente y siempre genera el mismo valor puede indicar un error. Esto se aplica en particular si se pretendía algo diferente. En cada caso, la expresión s...", 
"body" : "Detecta el uso de expresiones que siempre tienen el mismo valor en tiempo de ejecución. Justificación: Una expresión compleja que se calcula repetidamente y siempre genera el mismo valor puede indicar un error. Esto se aplica en particular si se pretendía algo diferente. En cada caso, la expresión sobrecarga innecesariamente el tiempo de ejecución del programa. Importancia: Media Ejemplo PROGRAM PLC_PRG\nVAR\n value : INT;\n condition : BOOL;\nEND_VAR\n value := 8;\ncondition := value = 8 \/\/ Reports: Expression (value=8) is always TRUE Salida en el Mensajes vista: SA0062: La expresión '(valor=8)' siempre es VERDADERA " }, 
{ "title" : "SA0063: Posiblemente operaciones no compatibles con 16 bits ", 
"url" : "_san_rule_sa0063.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0063: Posiblemente operaciones no compatibles con 16 bits ", 
"snippet" : "Detecta operaciones de 16 bits con resultados temporales. Antecedentes: en los sistemas de 16 bits, los resultados temporales de 32 bits se pueden truncar. Ejemplo: (int+10) puede exceder los 16 bits. Justificación: en el caso muy poco frecuente de que tenga que escribir código que deba ejecutarse t...", 
"body" : "Detecta operaciones de 16 bits con resultados temporales. Antecedentes: en los sistemas de 16 bits, los resultados temporales de 32 bits se pueden truncar. Ejemplo: (int+10) puede exceder los 16 bits. Justificación: en el caso muy poco frecuente de que tenga que escribir código que deba ejecutarse tanto en un procesador de 16 bits como en un procesador de 32 bits, este mensaje debería ayudar a evitar cualquier problema. Importancia: Baja Ejemplo PROGRAM PLC_PRG\nVAR\n iVar : INT;\nEND_VAR\n iVar := (iVar + 10) \/ 2; Salida en el Mensajes vista: SA0063: Compatibilidad para 16 Bits – Posible resultado intermedio truncado " }, 
{ "title" : "SA0064: Adición de puntero ", 
"url" : "_san_rule_sa0064.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0064: Adición de puntero ", 
"snippet" : "Detecta la adición de punteros Justificación: En CODESYS , la aritmética de punteros generalmente está permitida y también puede usarse apropiadamente. Sin embargo, también representa una fuente de error. Por lo tanto, existen reglas de programación que generalmente prohíben la aritmética de puntero...", 
"body" : "Detecta la adición de punteros Justificación: En CODESYS , la aritmética de punteros generalmente está permitida y también puede usarse apropiadamente. Sin embargo, también representa una fuente de error. Por lo tanto, existen reglas de programación que generalmente prohíben la aritmética de punteros. Esta prueba puede comprobar tal requisito. Importancia: Media Ejemplo PROGRAM PLC_PRG\nVAR\n iTest : INT;\n ariTest : ARRAY[0..10] OF INT;\n {attribute 'analysis':='-111'}\n piTest : POINTER TO INT;\n i : INT;\nEND_VAR\n piTest := ADR(ariTest[0]); \/\/ OK\npiTest^ := 0;\npiTest := ADR(ariTest) + SIZEOF(INT); \/\/ SA0064\npiTest^ := 1;\npiTest := ADR(ariTest) + 6; \/\/ SA0064\npiTest^ := 3;\npiTest := ADR(ariTest[10]);\nFOR i:=0 TO 10 DO\n piTest^ := i;\n piTest := piTest + 2; \/\/ SA0064\nEND_FOR Salida en el Mensajes vista: SA0064: Adición de puntero " }, 
{ "title" : "SA0065: Adición de puntero incorrecta al tamaño base ", 
"url" : "_san_rule_sa0065.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0065: Adición de puntero incorrecta al tamaño base ", 
"snippet" : "Detecta adiciones de puntero para las cuales el valor que se agregará no coincide con el tamaño base del puntero. Sólo se pueden agregar sin error literales del tamaño de datos base y múltiplos del mismo. Justificación: En CODESYS (a diferencia de C y C++), al agregar un puntero con un valor entero,...", 
"body" : "Detecta adiciones de puntero para las cuales el valor que se agregará no coincide con el tamaño base del puntero. Sólo se pueden agregar sin error literales del tamaño de datos base y múltiplos del mismo. Justificación: En CODESYS (a diferencia de C y C++), al agregar un puntero con un valor entero, solo este valor entero se agrega como número de bytes, y no el valor entero multiplicado por el tamaño base. Ejemplo en ST pINT := ADR(array_of_int[0]);\npINT := pINT + 2; \/\/in CODESYS, pINT then points to array_of_int[1] Este código funcionaría de manera diferente en C: short* pShort\npShort = &(array_of_short[0])\npShort = pShort + 2; \/\/in C, pShort then points to array_of_short[2] Por lo tanto, en CODESYS , siempre debes agregar un múltiplo del tamaño base del puntero a un puntero. De lo contrario, el puntero puede señalar no alineado memoria que (dependiendo del procesador) puede provocar una excepción de alineación al acceder a ella. Importancia: Alta Ejemplo VAR\n pudiTest:POINTER TO UDINT;\n udiTest:UDINT;\n prTest:POINTER TO REAL;\n rTest:REAL;\nEND_VAR pudiTest := ADR(udiTest) + 4; \/\/ OK\npudiTest := ADR(udiTest) + ( 2 + 2 ); \/\/ OK\npudiTest := ADR(udiTest) + SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + 3; \/\/ SA0065\npudiTest := ADR(udiTest) + 2*SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + ( 3 + 2 ); \/\/ SA0065\nprTest := ADR(rTest);\nprTest := prTest + 4; \/\/ OK\nprTest := prTest + ( 2 + 2 ); \/\/ OK\nprTest := prTest + SIZEOF(REAL); \/\/ OK\nprTest := prTest + 1; \/\/ SA0065\nprTest := prTest + 2; \/\/ SA0065\nprTest := prTest + 3; \/\/ SA0065\nprTest := prTest + ( SIZEOF(REAL) - 1 ); \/\/ SA0065\nprTest := prTest + ( 1 + 4 ); \/\/ SA0065\n Salida en el Mensajes vista: SA0065: Adición de puntero incorrecta al tamaño base " }, 
{ "title" : "SA0066: Usos de resultados temporales ", 
"url" : "_san_rule_sa0066.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para Operadores \/ SA0066: Usos de resultados temporales ", 
"snippet" : "Detecta el uso de resultados temporales en declaraciones con un tipo de datos menor que el tamaño del registro. En este caso, la conversión implícita puede conducir a resultados no deseados. Justificación: Por motivos de rendimiento, CODESYS Static Analysis realiza operaciones en el ancho de registr...", 
"body" : "Detecta el uso de resultados temporales en declaraciones con un tipo de datos menor que el tamaño del registro. En este caso, la conversión implícita puede conducir a resultados no deseados. Justificación: Por motivos de rendimiento, CODESYS Static Analysis realiza operaciones en el ancho de registro del procesador. Los resultados intermedios no se truncan. Esto puede dar lugar a malas interpretaciones, como en el siguiente caso: Ejemplo usintTest := 0; xError := usintTest - 1 <> 255; En CODESYS , xError es TRUE en este caso porque la operación usintTest - 1 normalmente se ejecuta como una operación de 32 bits y el resultado no se convierte al tamaño de bytes. Entonces el valor 16#ffffffff (no igual a 255) se encuentra en el registro. Para evitar esto, necesitas convertir el resultado intermedio explícitamente: xError := TO_USINT(usintTest - 1) <> 255; Si este mensaje está activado, se informarán muchas ubicaciones menos problemáticas en el código. Aunque un problema solo puede ocurrir cuando la operación produce un desbordamiento o subdesbordamiento en el tipo de datos, el análisis estático no puede diferenciar entre las ubicaciones individuales. Si incluye un encasillado explícito en todas las ubicaciones informadas, el código será mucho más lento y menos legible. Importancia: Baja Ejemplo PROGRAM PLC_PRG\nVAR\n byTest:BYTE;\n liTest:LINT;\n xError:BOOL;\nEND_VAR \/\/type size smaller than register size;\nbyTest := 0;\nIF (byTest - 1) <> 255 THEN \/\/use of temporary result + implicit casting -> SA0066\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n\n\/\/type size equal to or bigger than register size;\nliTest := 0;\nIF (liTest - 1) <> -1 THEN \/\/ use of temporary result and no implicit casting -> OK\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n Salida en el Mensajes vista: SA0066: Usos de resultados temporales (byTest - USINT #1) " }, 
{ "title" : "Reglas para declaraciones ", 
"url" : "_san_rule_instructions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para declaraciones ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0072: Usos no válidos de variable contador ", 
"url" : "_san_rule_sa0072.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para declaraciones \/ SA0072: Usos no válidos de variable contador ", 
"snippet" : "Detecta el uso de una variable contador en un FOR círculo Justificación: Manipulación de la variable contador en un FOR Un bucle puede fácilmente resultar en un bucle infinito. Para evitar la ejecución del bucle para valores específicos de la variable de contador, utilice CONTINUE o simplemente un I...", 
"body" : "Detecta el uso de una variable contador en un FOR círculo Justificación: Manipulación de la variable contador en un FOR Un bucle puede fácilmente resultar en un bucle infinito. Para evitar la ejecución del bucle para valores específicos de la variable de contador, utilice CONTINUE o simplemente un IF . Importancia: Alta Regla PLCopen: L12 Ejemplo PROGRAM PLC_PRG\nVAR_TEMP\n iIndex : INT;\nEND_VAR FOR iIndex := INT#0 TO INT#20 BY INT#1 DO\n iIndex := iIndex - INT#1;\nEND_FOR Salida en el Mensajes vista: SA0072: Usos no válidos de la variable de contador 'iIndex' " }, 
{ "title" : "SA0073: Usos de variable de contador inadecuado ", 
"url" : "_san_rule_sa0073.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para declaraciones \/ SA0073: Usos de variable de contador inadecuado ", 
"snippet" : "Detecta el uso de variables no temporales en FOR bucles Justificación: Esta es una advertencia de rendimiento. Siempre se inicializa una variable de contador cada vez que se llama a una POU. Puede crear esta variable como una variable temporal ( VAR_TEMP ). El acceso a ella puede ser más rápido y la...", 
"body" : "Detecta el uso de variables no temporales en FOR bucles Justificación: Esta es una advertencia de rendimiento. Siempre se inicializa una variable de contador cada vez que se llama a una POU. Puede crear esta variable como una variable temporal ( VAR_TEMP ). El acceso a ella puede ser más rápido y la variable no ocupa memoria permanente. Importancia: Media Regla PLCopen: CP21 \/ L13 Ejemplo PROGRAM PLC_PRG\nVAR\n nIndex : INT;\n iVar : INT;\nEND_VAR FOR nIndex := INT#0 TO INT#20 BY INT#1 DO\n iVar := iVar + nIndex;\nEND_FOR\n Salida a la vista Mensajes : SA0073: La variable del contador no coincide " }, 
{ "title" : "SA0075: Falta ELSE ", 
"url" : "_san_rule_sa0075.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para declaraciones \/ SA0075: Falta ELSE ", 
"snippet" : "Detecta CASE declaraciones sin ELSE rama Justificación: La programación defensiva requiere la inclusión de un ELSE sucursal en cada CASE declaración. Si no hay nada que hacer en el ELSE rama, luego incluya un comentario para indicarlo. Entonces queda claro para el lector del código que el caso no fu...", 
"body" : "Detecta CASE declaraciones sin ELSE rama Justificación: La programación defensiva requiere la inclusión de un ELSE sucursal en cada CASE declaración. Si no hay nada que hacer en el ELSE rama, luego incluya un comentario para indicarlo. Entonces queda claro para el lector del código que el caso no fue simplemente olvidado. Importancia: Baja Regla abierta PLC: L17 For CASE declaraciones que utilizan enumeraciones con atributo strict  y donde todas las constantes de enumeración se utilizan en el CASE Se utiliza la declaración, no se emite ningún mensaje de error. Ejemplo PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\nCASE iVar OF\n INT#1:\n xTemp := FALSE;\n INT#2:\n xTemp := TRUE;\nEND_CASE\n Salida en el Mensajes vista: SA0075: Falta ELSE en la declaración CASE " }, 
{ "title" : "SA0076: Falta la constante de enumeración ", 
"url" : "_san_rule_sa0076.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para declaraciones \/ SA0076: Falta la constante de enumeración ", 
"snippet" : "Determina si cada constante de enumeración se utiliza o no como condición en CASE declaraciones y consultado en un CASE rama. Justificación: La programación defensiva requiere el procesamiento de todos los valores posibles de una enumeración. Si no se requiere una acción para un valor de enumeración...", 
"body" : "Determina si cada constante de enumeración se utiliza o no como condición en CASE declaraciones y consultado en un CASE rama. Justificación: La programación defensiva requiere el procesamiento de todos los valores posibles de una enumeración. Si no se requiere una acción para un valor de enumeración particular, debe agregar un comentario para indicarlo explícitamente. Entonces queda claro para el lector del código que el valor no se olvidó simplemente. Importancia: Baja Ejemplo TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iVar : My_Enum;\n xTemp : BOOL;\nEND_VAR iVar := My_Enum.black;\nCASE iVar OF\n My_Enum.red:\n xTemp := FALSE;\n My_Enum.blue, My_Enum.green:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n Salida en el Mensajes vista: SA0076: Falta la constante de enumeración 'black' en la declaración CASE " }, 
{ "title" : "SA0077: El tipo de enumeración no coincide con CASE expresión ", 
"url" : "_san_rule_sa0077.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para declaraciones \/ SA0077: El tipo de enumeración no coincide con CASE expresión ", 
"snippet" : "Detecta las posiciones de código en las que un CASE la sentencia mezcla valores de enumeración con tipos que no son de enumeración. Justificación: La combinación de valores de enumeración y valores enteros en las construcciones CASE infringe la seguridad de los tipos de datos, reduce la legibilidad ...", 
"body" : "Detecta las posiciones de código en las que un CASE la sentencia mezcla valores de enumeración con tipos que no son de enumeración. Justificación: La combinación de valores de enumeración y valores enteros en las construcciones CASE infringe la seguridad de los tipos de datos, reduce la legibilidad del código y afecta a la capacidad de mantenimiento. Los valores de enumeración garantizan la claridad semántica. El uso de valores enteros sin procesar conlleva el riesgo de errores menores y hace que el código sea más difícil de entender. Los cambios de tipo de datos en las enumeraciones también pueden destruir las ramas basadas en números enteros, lo que puede. Importancia: Baja Ejemplo {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE DUT_MyEnum :\n(\n\tOne := 1, \n\tTwo := 2, \n\tThree := 3, \n\tFour := 4\n);\nEND_TYPE PROGRAM PRG_Case\nVAR\ndiVar : DINT;\nxTemp : BOOL;\n\neMyEnum : DUT_MyEnum;\nEND_VAR\n CASE diVar OF\n 1 :\n xTemp := FALSE;\n DUT_MyEnum.Two : \/\/ SA0077\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n\nCASE eMyEnum OF\n 1 : \/\/ SA0077\n xTemp := FALSE;\n DUT_MyEnum.Two:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE Salida en el Mensajes vista: SA0077: El tipo no coincide con la expresión CASE " }, 
{ "title" : "SA0078: Faltan ramas CASE ", 
"url" : "_san_rule_sa0078.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para declaraciones \/ SA0078: Faltan ramas CASE ", 
"snippet" : "Detecta CASE declaraciones sin CASE sucursales y solo una ELSE declaración Justificación: A CASE La declaración sin casos desperdicia tiempo de ejecución y es difícil de leer. Importancia: Media Ejemplo PROGRAM PLC_PRG VAR iVar : INT; xTemp : BOOL; END_VAR iVar := iVar + INT#1; \/\/in the following th...", 
"body" : "Detecta CASE declaraciones sin CASE sucursales y solo una ELSE declaración Justificación: A CASE La declaración sin casos desperdicia tiempo de ejecución y es difícil de leer. Importancia: Media Ejemplo PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\n\/\/in the following the case descriptions are missing:\nCASE iVar OF\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n Salida en el Mensajes vista: SA0078: Faltan sucursales CASE " }, 
{ "title" : "SA0081: El borde superior no es una constante ", 
"url" : "_san_rule_sa0081.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para declaraciones \/ SA0081: El borde superior no es una constante ", 
"snippet" : "Detecta el FOR declaraciones donde el límite superior no está definido con un valor constante Justificación: si el límite superior de un bucle es un valor variable, ya no es posible ver con qué frecuencia se ejecuta un bucle. Esto puede resultar en serios problemas en tiempo de ejecución. El peor de...", 
"body" : "Detecta el FOR declaraciones donde el límite superior no está definido con un valor constante Justificación: si el límite superior de un bucle es un valor variable, ya no es posible ver con qué frecuencia se ejecuta un bucle. Esto puede resultar en serios problemas en tiempo de ejecución. El peor de los casos es un bucle infinito. Importancia: Alta Ejemplo PROGRAM PLC_PRG\nVAR\n i:INT;\n iBorder1: INT := 10;\n iBorder2: INT := 10;\n iCounter: INT;\nEND_VAR\nVAR CONSTANT\n ciBorder:INT := 10;\nEND_VAR\n FOR i:=0 TO 10 DO \/\/OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO ciBorder DO \/\/ OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder1 DO \/\/ SA0081\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder2 DO \/\/ SA0081\n iCounter := i;\n IF iCounter = 10 THEN\n iBorder2 := 50;\n END_IF\nEND_FOR\n Salida en el Mensajes vista: SA0081: El borde superior de un bucle for debe ser un valor constante " }, 
{ "title" : "SA0090: Declaración RETURN antes del final de la función ", 
"url" : "_san_rule_sa0090.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Reglas para declaraciones \/ SA0090: Declaración RETURN antes del final de la función ", 
"snippet" : "Detecta ubicaciones de código donde RETURN La declaración no es la última declaración de una función, método, propiedad o programa. Lugares donde un RETURN existe dentro de un IF También se detectan ramas. Justificación: A RETURN en el código da como resultado una peor mantenibilidad, capacidad de p...", 
"body" : "Detecta ubicaciones de código donde RETURN La declaración no es la última declaración de una función, método, propiedad o programa. Lugares donde un RETURN existe dentro de un IF También se detectan ramas. Justificación: A RETURN en el código da como resultado una peor mantenibilidad, capacidad de prueba y legibilidad del código. A RETURN en el código se pasa por alto fácilmente. Antes de cada RETURN , a menudo se olvida insertar código que siempre debe ejecutarse al salir de una función. Importancia: Media Regla PLCopen: CP14 Ejemplo FUNCTION SA0090: DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR IF bTest THEN\n RETURN;\nEND_IF\nSA0090 := 99; Salida en el Mensajes vista: SA0090: Las POU tendrán un único punto de salida " }, 
{ "title" : "SA0095: Cesiones en condiciones ", 
"url" : "_san_rule_sa0095.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0095: Cesiones en condiciones ", 
"snippet" : "Detecta asignaciones en condiciones de IF , CASE , o REPEAT construcciones Justificación: Una asignación (:=) y una comparación (=) pueden confundirse fácilmente. Como resultado, una asignación en una condición puede ser fácilmente no intencional y, por lo tanto, se informa. Esto también puede confu...", 
"body" : "Detecta asignaciones en condiciones de IF , CASE , o REPEAT construcciones Justificación: Una asignación (:=) y una comparación (=) pueden confundirse fácilmente. Como resultado, una asignación en una condición puede ser fácilmente no intencional y, por lo tanto, se informa. Esto también puede confundir al lector del código. Importancia: Alta Ejemplo PROGRAM PLC_PRG\nVAR\n iCond1:INT := INT#1;\n iCond2:INT := INT#2;\n xCond:BOOL := FALSE;\n iVar : INT;\nEND_VAR IF INT_TO_BOOL(iCond1 := iCond2) THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\n ELSIF (iCond1 := 11) = 11 THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF xCond := TRUE THEN \/\/ SA0095\n xCond := FALSE;\nEND_IF\n\nIF (xCond := FALSE) OR (iCond1 := iCond2) = 12 THEN \/\/ SA0095\n xCond := FALSE;\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF (iVar := iVar + 1) = 120 THEN \/\/ SA0095 (can be valid, but is not reparable very well\n iVar := 0;\nEND_IF\n\nWHILE (xCond = TRUE) OR (iCond1 := iCond2) = 12 DO \/\/ SA0095\n xCond := FALSE;\nEND_WHILE\n\n\/\/Error: assignment in repeat loop\nREPEAT\n xCond := FALSE;\nUNTIL (xCond = TRUE) OR (iCond1 := iCond2) = 12 \/\/ SA0095\nEND_REPEAT Salida en el Mensajes vista: SA0095: Asignación en condición: '...' " }, 
{ "title" : "SA0100: Variables mayores a <n> bytes ", 
"url" : "_san_rule_sa0100.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0100: Variables mayores a <n> bytes ", 
"snippet" : "Detecta variables que usan más de n bytes, donde n está definido por la configuración actual. Valor predeterminado: 1024 bytes. El valor se puede cambiar haciendo doble clic en la línea. Justificación: Algunas pautas de programación especifican un tamaño máximo para una sola variable. Esto se puede ...", 
"body" : "Detecta variables que usan más de n bytes, donde n está definido por la configuración actual. Valor predeterminado: 1024 bytes. El valor se puede cambiar haciendo doble clic en la línea. Justificación: Algunas pautas de programación especifican un tamaño máximo para una sola variable. Esto se puede comprobar con esto. Importancia: Baja Ejemplo PROGRAM PLC_PRG\nVAR\n aobyTest : ARRAY [0..1024] OF BYTE;\nEND_VAR\n aobyTest[INT#0] := aobyTest[INT#0] + BYTE#1; Salida en el Mensajes vista: SA0100: Variable 'aobyTest' mayor a 1024 bytes " }, 
{ "title" : "SA0101: Nombres con longitud no válida ", 
"url" : "_san_rule_sa0101.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0101: Nombres con longitud no válida ", 
"snippet" : "Detecta nombres con una longitud no válida. Justificación: Algunas pautas de programación especifican una longitud mínima para los nombres de variables. Este análisis se puede utilizar para comprobar el cumplimiento. Importancia: Baja Regla PLCopen: N6 Todas las reglas están enumeradas en el Configu...", 
"body" : "Detecta nombres con una longitud no válida. Justificación: Algunas pautas de programación especifican una longitud mínima para los nombres de variables. Este análisis se puede utilizar para comprobar el cumplimiento. Importancia: Baja Regla PLCopen: N6 Todas las reglas están enumeradas en el Configuración Análisis estático: reglas diálogo. Allí puede hacer doble clic en la Regla 101 para abrir la configuración específica de la regla. Luego puede definir el número mínimo y máximo de caracteres y establecer excepciones para ellos en el Longitud de los nombres diálogo. Ejemplo PROGRAM PLC1 \/\/ SA0101\nVAR\n iVar1 : INT; \/\/ SA0101\nEND_VAR\n Salida en el Mensajes vista: SA0101: Longitud no válida del nombre 'PLC1' " }, 
{ "title" : "SA0102: Acceso a variables de programa\/fb desde el exterior ", 
"url" : "_san_rule_sa0102.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0102: Acceso a variables de programa\/fb desde el exterior ", 
"snippet" : "Detecta el acceso externo a variables locales de programas o bloques de funciones. Justificación: CODESYS permite el acceso de lectura externo a variables locales de programas o bloques de funciones. Esto contradice el principio de encapsulación de datos (ocultar datos) y no cumple con el estándar I...", 
"body" : "Detecta el acceso externo a variables locales de programas o bloques de funciones. Justificación: CODESYS permite el acceso de lectura externo a variables locales de programas o bloques de funciones. Esto contradice el principio de encapsulación de datos (ocultar datos) y no cumple con el estándar IEC 61131-3. Importancia: Media Ejemplo PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n afb_Instance : AFB;\n bfb_Instance : BFB;\nEND_VAR iCounter := A_PRG.iLocal; \/\/ SA0102\niCounter := bfb_Instance.iLocal; \/\/ SA0102\nA_PRG(); FUNCTION_BLOCK AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iLocal: INT;\nEND_VAR METHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; FUNCTION_BLOCK BFB EXTENDS AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\nEND_VAR\nMETHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; PROGRAM A_PRG\nVAR\n iLocal: INT;\nEND_VAR iLocal := iLocal + 1;\n Salida en el Mensajes vista: SA0102: Acceso al programa\/variable fb 'iLocal' desde el exterior " }, 
{ "title" : "SA0103: Acceso concurrente a datos no atómicos ", 
"url" : "_san_rule_sa0103.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0103: Acceso concurrente a datos no atómicos ", 
"snippet" : "Detecta si las variables no atómicas (por ejemplo, con tipo de datos) STRING , WSTRING , ARRAY , STRUCT , instancias de FB, tipos de datos de 64 bits) se utilizan en más de una tarea Justificación: Cuando no hay sincronización durante el acceso, se pueden leer valores inconsistentes al leer en una t...", 
"body" : "Detecta si las variables no atómicas (por ejemplo, con tipo de datos) STRING , WSTRING , ARRAY , STRUCT , instancias de FB, tipos de datos de 64 bits) se utilizan en más de una tarea Justificación: Cuando no hay sincronización durante el acceso, se pueden leer valores inconsistentes al leer en una tarea y escribir en otra tarea al mismo tiempo. Importancia: Media Para algunos tipos de datos, especialmente los enteros de 64 bits, depende de la plataforma si el acceso es atómico o no. El análisis estático informa de un problema solo cuando el controlador no admite el acceso atómico a tipos de datos enteros de 64 bits. Esta regla no se aplica en los siguientes casos: Si el sistema de destino tiene una unidad de punto flotante (FPU), entonces el acceso de múltiples tareas a LREAL no se detectan las variables Si el sistema de destino es un procesador de 64 bits o se establece la configuración de destino correspondiente para el dispositivo de destino, la regla no se aplica a los tipos de datos de 64 bits. Ejemplo El proyecto contiene ambos programas, PRG1 y PRG2 . El programa PRG1 es llamado por la tarea MainTask_1 . El programa PRG2 es llamado por la tarea MainTask_2 . VAR_GLOBAL\n lrTest : LREAL; \/\/ Since the target system has an FPU, SA0103 does apply.\n lint1 : LINT;\n sTest : STRING; \/\/ SA0103\n wsTest : WSTRING; \/\/ SA0103\nEND_VAR PROGRAM PRG1 GVL.lrTest := 5.0;\nGVL.sTest := 'welt';\nGVL.wsTest := \"welt\";\nGVL.lint1 := 99;\n PROGRAM PRG2 GVL.lrTest := 5.0;\nGVL.sTest := 'hallo';\nGVL.wsTest := \"hallo\";\nGVL.lint1 := 88; Salida en el Mensajes vista: SA0103: Acceso simultáneo a datos no atómicos 'sTest' SA0103: Acceso simultáneo a datos no atómicos 'wsTest' " }, 
{ "title" : "SA0105: Llamadas de múltiples instancias ", 
"url" : "_san_rule_sa0105.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0105: Llamadas de múltiples instancias ", 
"snippet" : "Detecta las instancias de bloques de funciones que se llaman varias veces. Para ello, los bloques de funciones deben marcarse con el siguiente pragma: {attribute 'analysis:report-multiple-instance-calls'} Justificación: Algunos bloques de funciones están diseñados de tal manera que solo se pueden ll...", 
"body" : "Detecta las instancias de bloques de funciones que se llaman varias veces. Para ello, los bloques de funciones deben marcarse con el siguiente pragma: {attribute 'analysis:report-multiple-instance-calls'} Justificación: Algunos bloques de funciones están diseñados de tal manera que solo se pueden llamar una vez en el ciclo. Esta prueba verifica si se realiza o no una llamada en múltiples ubicaciones. Importancia: Baja Regla PLCopen: CP16 \/ CP20 Ejemplo \/\/ {attribute 'analysis:report-multiple-instance-calls'} Deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\n iA := iA + 1; {attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\n iB := iB + 1; PROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nEND_VAR fbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n Salida en el Mensajes vista: SA0105: Instancia 'fbB' llamada más de una vez " }, 
{ "title" : "SA0106: Llamadas a métodos virtuales en FB_INIT ", 
"url" : "_san_rule_sa0106.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0106: Llamadas a métodos virtuales en FB_INIT ", 
"snippet" : "Detecta llamadas a métodos en el FB_Init método de un bloque de funciones base, que se sobrescriben con un bloque de funciones derivado de un bloque de funciones base Justificación: En estos casos, puede ser que las variables de los métodos sobrescritos no estén inicializadas en el FB base. Importan...", 
"body" : "Detecta llamadas a métodos en el FB_Init método de un bloque de funciones base, que se sobrescriben con un bloque de funciones derivado de un bloque de funciones base Justificación: En estos casos, puede ser que las variables de los métodos sobrescritos no estén inicializadas en el FB base. Importancia: Alta Ejemplo El bloque de funciones FB_A incluye los métodos FB_Init y Meth_MyInit . FB_Init llamadas Meth_MyInit para la inicialización. El bloque de funciones FB_B se deriva de FB_A . PLC_PRG llamadas FB_B y por lo tanto utiliza su mbMyDintB variable antes de que haya sido inicializada. FB_B.Meth_MyInit sobrescribe FB_A.Meth_MyInit . FUNCTION_BLOCK FB_A\nVAR\n mbMyDintA : DINT;\nEND_VAR FUNCTION_BLOCK FB_B EXTENDS FB_A\nVAR\n mbMyDintB : DINT;\nEND_VAR METHOD FB_Init : BOOL\nVAR_INPUT\n bInitRetains:BOOL;\n bInCopyCode:BOOL;\nEND_VAR\nVAR\n diDummy:DINT; \/\/SA0106\nEND_VAR\n mbMyDintA := 123;\ndiDummy := Meth_MyInit(); METHOD Meth_MyInit : DINT\nVAR_INPUT\nEND_VAR\n mbMyDintB := 123; \/\/access to member of FB_B PROGRAM PLC_PRG\nVAR\n g_BInst : FB_B;\n xVar : BOOL;\nEND_VAR\n\n xVar := g_BInst.fb_init(TRUE, TRUE);\n\/\/this instruction causes the following order of initializations:\n\/\/FB_A.fb_init\n\/\/FB_B.Meth_MyInit \/\/SA0106\n\/\/FB_B.fb_init\n\/\/FB_B.Meth_MyInit Salida en el Mensajes vista: SA0106: Llamada al método virtual 'Meth_MyInit' en FB_INIT " }, 
{ "title" : "SA0107: Faltan parámetros formales ", 
"url" : "_san_rule_sa0107.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0107: Faltan parámetros formales ", 
"snippet" : "Detecta si faltan o no parámetros formales Justificación: El código se vuelve más legible cuando se especifican parámetros formales en la llamada. Importancia: Baja Ejemplo FUNCTION FUNA : BOOL VAR_INPUT bDo : BOOL; bInit : BOOL; bManual : BOOL; END_VAR VAR iInit : INT; iLocal : INT; iManual : INT; ...", 
"body" : "Detecta si faltan o no parámetros formales Justificación: El código se vuelve más legible cuando se especifican parámetros formales en la llamada. Importancia: Baja Ejemplo FUNCTION FUNA : BOOL\nVAR_INPUT\n bDo : BOOL;\n bInit : BOOL;\n bManual : BOOL;\nEND_VAR\nVAR\n iInit : INT;\n iLocal : INT;\n iManual : INT;\nEND_VAR\n IF bInit = TRUE THEN\n iInit := iInit + 1;\nEND_IF\nIF bDo = TRUE THEN\n iLocal := iLocal + 1;\nEND_IF\nIF bManual = TRUE THEN\n iManual := iManual + 1;\nEND_IF\nFUNA := TRUE;\n PROGRAM PLC_PRG\nVAR\nEND_VAR\n FUNA(bInit := TRUE, bDo := TRUE, bManual := FALSE); \/\/ OK\nFUNA(TRUE, TRUE, bManual:= FALSE); \/\/ SA0107 Salida en el Mensajes vista: SA0107: Falta el parámetro formal para la entrada 'TRUE' " }, 
{ "title" : "Comprobación de las estrictas normas IEC ", 
"url" : "_san_check_strict_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0111: Variables de puntero ", 
"url" : "_san_rule_sa0111.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0111: Variables de puntero ", 
"snippet" : "Detecta variables de tipo POINTER TO Justificación: El estándar IEC 61131-3 no permite punteros. Importancia: Baja Ejemplo VAR piTemp : POINTER TO INT; pbyTemp : POINTER TO BYTE; END_VAR Salida en el Mensajes vista: SA0111: Tipo de datos PUNTERO no permitido...", 
"body" : "Detecta variables de tipo POINTER TO Justificación: El estándar IEC 61131-3 no permite punteros. Importancia: Baja Ejemplo VAR\n piTemp : POINTER TO INT;\n pbyTemp : POINTER TO BYTE;\nEND_VAR\n Salida en el Mensajes vista: SA0111: Tipo de datos PUNTERO no permitido " }, 
{ "title" : "SA0112: Variables de referencia ", 
"url" : "_san_rule_sa0112.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0112: Variables de referencia ", 
"snippet" : "Detecta variables de tipo REFERENCE TO Justificación: La norma IEC 61131-3 no permite referencias. Importancia: Baja Ejemplo VAR ref_int : REFERENCE TO INT; ref_dw : REFERENCE TO DWORD; END_VAR Salida en el Mensajes vista: SA0112: Tipo de datos REFERENCIA no permitido...", 
"body" : "Detecta variables de tipo REFERENCE TO Justificación: La norma IEC 61131-3 no permite referencias. Importancia: Baja Ejemplo VAR\n ref_int : REFERENCE TO INT;\n ref_dw : REFERENCE TO DWORD;\nEND_VAR\n Salida en el Mensajes vista: SA0112: Tipo de datos REFERENCIA no permitido " }, 
{ "title" : "SA0113: Variables con tipo de dato WSTRING ", 
"url" : "_san_rule_sa0113.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0113: Variables con tipo de dato WSTRING ", 
"snippet" : "Determina variables de tipo  WSTRING . Justificación: No todos los sistemas soportan WSTRING . El código es más fácil de transportar sin WSTRING . Importancia: Baja Ejemplo VAR wstrTemp : WSTRING; END_VAR Salida en el Mensajes vista: SA0113: Tipo de datos WSTRING no permitido...", 
"body" : "Determina variables de tipo  WSTRING . Justificación: No todos los sistemas soportan WSTRING . El código es más fácil de transportar sin WSTRING . Importancia: Baja Ejemplo VAR\n wstrTemp : WSTRING;\nEND_VAR\n Salida en el Mensajes vista: SA0113: Tipo de datos WSTRING no permitido " }, 
{ "title" : "SA0114: Variables con tipo de dato LTIME ", 
"url" : "_san_rule_sa0114.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0114: Variables con tipo de dato LTIME ", 
"snippet" : "Detecta variables de tipo LTIME Justificación: No todos los sistemas soportan LTIME El código es más fácil de transportar sin LTIME . Importancia: Baja Ejemplo VAR ltVar : LTIME; \/\/ SA0114 END_VAR Salida en el Mensajes vista: SA0114: Tipo de datos LTIME no permitido Para más información, ver: Atribu...", 
"body" : "Detecta variables de tipo LTIME Justificación: No todos los sistemas soportan LTIME El código es más fácil de transportar sin LTIME . Importancia: Baja Ejemplo VAR\n ltVar : LTIME; \/\/ SA0114\nEND_VAR\n Salida en el Mensajes vista: SA0114: Tipo de datos LTIME no permitido Para más información, ver: Atributo 'análisis:informe-múltiples-instancias-llamadas' " }, 
{ "title" : "SA0115: Variables con tipo de dato UNION ", 
"url" : "_san_rule_sa0115.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0115: Variables con tipo de dato UNION ", 
"snippet" : "Detecta declaraciones de un UNION tipos de datos y declaraciones de variables del UNION escribe Justificación: La norma IEC 61131-3 no incluye uniones. El código es más fácilmente transportable sin uniones. Importancia: Baja Ejemplo TYPE A_UNION: UNION lrTemp : LREAL; liTemp : LINT; END_UNION END_TY...", 
"body" : "Detecta declaraciones de un UNION tipos de datos y declaraciones de variables del UNION escribe Justificación: La norma IEC 61131-3 no incluye uniones. El código es más fácilmente transportable sin uniones. Importancia: Baja Ejemplo TYPE A_UNION: \nUNION\n lrTemp : LREAL;\n liTemp : LINT;\nEND_UNION\nEND_TYPE PROGRAM PLC_PRG\nVAR\n aunionVar: A_UNION;\n liVar : LINT;\nEND_VAR aunionVar.lrTemp := 0.123E-12;\nliVar := aunionVar.liTemp; Salida en el Mensajes vista: SA0115: Uniones no permitidas " }, 
{ "title" : "SA0117: Variables con tipo de dato BIT ", 
"url" : "_san_rule_sa0117.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0117: Variables con tipo de dato BIT ", 
"snippet" : "Detecta declaraciones de variables de tipo de datos. BIT (posible dentro de las definiciones de estructura) Justificación: La norma IEC 61131-3 no incluye el tipo de datos BIT . El código es más fácilmente portátil sin BIT . Importancia: Baja Ejemplo TYPE Struct1 : STRUCT bitVar : BIT; iVar : INT; b...", 
"body" : "Detecta declaraciones de variables de tipo de datos. BIT (posible dentro de las definiciones de estructura) Justificación: La norma IEC 61131-3 no incluye el tipo de datos BIT . El código es más fácilmente portátil sin BIT . Importancia: Baja Ejemplo TYPE Struct1 :\nSTRUCT\n bitVar : BIT;\n iVar : INT;\n bVar : BOOL;\nEND_STRUCT\nEND_TYPE\n Salida en el Mensajes vista: SA0117: Variables con tipo de datos BIT " }, 
{ "title" : "SA0119: Características orientadas a objetos ", 
"url" : "_san_rule_sa0119.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0119: Características orientadas a objetos ", 
"snippet" : "Detecta el uso de funciones orientadas a objetos, como declaraciones de bloques de funciones con EXTENDS y IMPLEMENTS , o declaraciones de propiedades e interfaces. Esta regla es útil cuando escribe código que está destinado a ser portado a otros sistemas compatibles con IEC 61131-3. Justificación: ...", 
"body" : "Detecta el uso de funciones orientadas a objetos, como declaraciones de bloques de funciones con EXTENDS y IMPLEMENTS , o declaraciones de propiedades e interfaces. Esta regla es útil cuando escribe código que está destinado a ser portado a otros sistemas compatibles con IEC 61131-3. Justificación: No todos los sistemas soportan la programación orientada a objetos. El código es más fácil de transportar sin orientación a objetos. Importancia: Baja Ejemplo \/\/Function block extended by another and implementing an interface:\nFUNCTION_BLOCK POU EXTENDS CTD IMPLEMENTS ITF \/\/SA0119\n;\n \/\/ Declaration parts of property methods assigned to a function block:\nPOU.Prop.Get \/\/SA0119 POU.Prop.Set \/\/SA0119 Salida en el Mensajes vista: SA0119: No se permiten funciones orientadas a objetos " }, 
{ "title" : "SA0120: Llamadas de programa ", 
"url" : "_san_rule_sa0120.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0120: Llamadas de programa ", 
"snippet" : "Detecta llamadas de programa Justificación: De acuerdo con el estándar IEC 61131-3, los programas solo se pueden llamar en la configuración de tareas. El código es más fácil de transportar cuando no llama a programas desde otras ubicaciones. Importancia: Baja Ejemplo PROGRAM prog_control VAR END_VAR...", 
"body" : "Detecta llamadas de programa Justificación: De acuerdo con el estándar IEC 61131-3, los programas solo se pueden llamar en la configuración de tareas. El código es más fácil de transportar cuando no llama a programas desde otras ubicaciones. Importancia: Baja Ejemplo PROGRAM prog_control\nVAR\nEND_VAR\n; PROGRAM PLC_PRG\nVAR\nEND_VAR\n prog_control(); Salida en el Mensajes vista: SA0120: Llamada de programa a 'prg_control' no permitida " }, 
{ "title" : "SA0121: Faltan declaraciones VAR_EXTERNAL ", 
"url" : "_san_rule_sa0121.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0121: Faltan declaraciones VAR_EXTERNAL ", 
"snippet" : "Detecta el uso de una variable global en bloques de funciones sin que estén declarados allí como VAR_EXTERNAL Justificación: De acuerdo con la norma IEC 61131-3, el acceso a las variables globales solo se permite mediante una importación explícita mediante un VAR_EXTERNAL declaración. Importancia: B...", 
"body" : "Detecta el uso de una variable global en bloques de funciones sin que estén declarados allí como VAR_EXTERNAL Justificación: De acuerdo con la norma IEC 61131-3, el acceso a las variables globales solo se permite mediante una importación explícita mediante un VAR_EXTERNAL declaración. Importancia: Baja Regla PLCopen: CP18 Ejemplo VAR_GLOBAL\n iGlob1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar : INT;\nEND_VAR\n ivar := iGlob1; \/\/ SA0121 Salida en el Mensajes vista: SA0121: Se requiere declaración VAR_EXTERNAL para la variable 'iGlob1' Ejemplo para evitar errores VAR_GLOBAL\n iGlob1:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar:INT;\nEND_VAR\nVAR_EXTERNAL\n iGlob1:INT;\nEND_VAR\n ivar:=iGlob1; \/\/ OK " }, 
{ "title" : "SA0122: índice de matriz definido como expresión ", 
"url" : "_san_rule_sa0122.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0122: índice de matriz definido como expresión ", 
"snippet" : "Detecta el uso de expresiones en la declaración de índices de matriz Justificación: No todos los sistemas permiten expresiones como límites de matriz. Importancia: Baja Ejemplo PROGRAM PLC_PRG VAR CONSTANT c_iValue : INT := INT#15; END_VAR VAR arr : ARRAY [0..c_iValue + 1] OF INT; END_VAR Salida en ...", 
"body" : "Detecta el uso de expresiones en la declaración de índices de matriz Justificación: No todos los sistemas permiten expresiones como límites de matriz. Importancia: Baja Ejemplo PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n arr : ARRAY [0..c_iValue + 1] OF INT;\nEND_VAR\n Salida en el Mensajes vista: SA0122: Sólo se permiten constantes para la definición de matriz 'arr' " }, 
{ "title" : "SA0123: Usos de INI, ADR o BITADR ", 
"url" : "_san_rule_sa0123.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0123: Usos de INI, ADR o BITADR ", 
"snippet" : "Detecta el uso de la CODESYS Static Analysis -operadores específicos INI , ADR , y BITADR . Justificación: CODESYS -Los operadores específicos impiden la portabilidad del código. Importancia: Baja Ejemplo PROGRAM PLC_PRG VAR uiTemp : UINT; TempVarInFUNC : DWORD; END_VAR TempVarInFUNC := ADR(uiTemp);...", 
"body" : "Detecta el uso de la CODESYS Static Analysis -operadores específicos INI , ADR , y BITADR . Justificación: CODESYS -Los operadores específicos impiden la portabilidad del código. Importancia: Baja Ejemplo PROGRAM PLC_PRG\nVAR\n uiTemp : UINT;\n TempVarInFUNC : DWORD;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0123 Salida en el Mensajes vista: SA0123: Operador 'ADR' no permitido " }, 
{ "title" : "SA0147: Operación de cambio inusual - strict ", 
"url" : "_san_rule_sa0147.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0147: Operación de cambio inusual - strict ", 
"snippet" : "Detecta operaciones de desplazamiento de bits que no se realizan en tipos de datos de campo de bits ( BYTE , WORD , DWORD , LWORD ) Justificación: El estándar IEC 61131-3 permite el acceso de bit solo a los tipos de datos de campo de bit. sin embargo, el CODESYS El compilador también permite operaci...", 
"body" : "Detecta operaciones de desplazamiento de bits que no se realizan en tipos de datos de campo de bits ( BYTE , WORD , DWORD , LWORD ) Justificación: El estándar IEC 61131-3 permite el acceso de bit solo a los tipos de datos de campo de bit. sin embargo, el CODESYS El compilador también permite operaciones de cambio de bits con tipos de datos sin firmar. Importancia: Baja Véase también la regla estricta SA0018 . Ejemplo PROGRAM PLC_PRG\nVAR\n in_byte : BYTE := 16#45; \/\/ 2#01000101\n in_word : WORD := 16#0045; \/\/ 2#0000000001000101\n in_uint : UINT;\n in_dint : DINT;\n erg_byte : BYTE;\n erg_word : WORD;\n erg_uint : UINT;\n erg_dint : DINT;\n n: BYTE := 2;\nEND_VAR\n erg_byte := SHL(in_byte,n); \/\/ no error because BYTE is a bit field\nerg_word := SHL(in_word,n); \/\/ no error because WORD is a bit field\nerg_uint := SHL(in_uint,n); \/\/ SA0147\nerg_dint := SHL(in_dint,n); \/\/ SA0147 Salida en el Mensajes vista: SA0147: Operación de turno inusual – estricta " }, 
{ "title" : "SA0148: Acceso a bit inusual - strict ", 
"url" : "_san_rule_sa0148.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0148: Acceso a bit inusual - strict ", 
"snippet" : "Detecta accesos a bits que no se realizan a tipos de datos de campos de bits ( BYTE , WORD , DWORD , y LWORD ). El estándar IEC 61131-3 solo permite el acceso de bits a los tipos de datos de campo de bits. sin embargo, el CODESYS El compilador también permite el acceso de bits a tipos de datos sin f...", 
"body" : "Detecta accesos a bits que no se realizan a tipos de datos de campos de bits ( BYTE , WORD , DWORD , y LWORD ). El estándar IEC 61131-3 solo permite el acceso de bits a los tipos de datos de campo de bits. sin embargo, el CODESYS El compilador también permite el acceso de bits a tipos de datos sin firmar. Importancia: Baja Ejemplo PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/ SA0148\ndiTemp3.4 := TRUE; \/\/ SA0148\nuliTemp4.18 := FALSE; \/\/ SA0148\nsiTemp5.2 := FALSE; \/\/ SA0148\nusiTemp6.3 := TRUE; \/\/ SA0148\nbyTemp2.5 := FALSE; \/\/ no error because BYTE is a bitfield Salida en el Mensajes vista: SA0148: Acceso a bits inusual – estricto " }, 
{ "title" : "SA0118: Inicializaciones que no utilizan constantes ", 
"url" : "_san_rule_sa0118.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0118: Inicializaciones que no utilizan constantes ", 
"snippet" : "Detecta inicializaciones que no asignan constantes Justificación: Las inicializaciones deben ser constantes si es posible y no deben hacer referencia a otras variables. En particular, debe evitar las llamadas a funciones durante la inicialización porque esto puede permitir el acceso a datos no inici...", 
"body" : "Detecta inicializaciones que no asignan constantes Justificación: Las inicializaciones deben ser constantes si es posible y no deben hacer referencia a otras variables. En particular, debe evitar las llamadas a funciones durante la inicialización porque esto puede permitir el acceso a datos no inicializados. Importancia: Media Ejemplo PROGRAM PLC_PRG\nVAR\n dwTemp : DWORD := 22;\n dwTest : DWORD := dwTemp; \/\/ SA0118\n dwVar : DWORD := TempVarInFUNC(); \/\/ SA0118\nEND_VAR\n Salida en el Mensajes vista: SA0118: Inicializaciones sin uso de constantes " }, 
{ "title" : "SA0124: Desreferencias de punteros en declaraciones ", 
"url" : "_san_rule_sa0124.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0124: Desreferencias de punteros en declaraciones ", 
"snippet" : "Detecta desreferencias de puntero que se utilizan para la inicialización en la parte de la declaración Justificación: No se deben utilizar punteros ni referencias para las inicializaciones porque esto puede provocar violaciones de acceso si el puntero no se ha inicializado. Importancia: Media Ejempl...", 
"body" : "Detecta desreferencias de puntero que se utilizan para la inicialización en la parte de la declaración Justificación: No se deben utilizar punteros ni referencias para las inicializaciones porque esto puede provocar violaciones de acceso si el puntero no se ha inicializado. Importancia: Media Ejemplo TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n pTeststruct : POINTER TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := pTeststruct^.xA; \/\/SA0124 \nEND_VAR\n\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); Salida en el Mensajes vista: SA0124: Desreferencias de puntero en declaraciones " }, 
{ "title" : "SA0125: Referencias en inicializaciones ", 
"url" : "_san_rule_sa0125.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Comprobación de las estrictas normas IEC \/ SA0125: Referencias en inicializaciones ", 
"snippet" : "Detecta variables de referencia que se utilizan para la inicialización en la parte de declaración Justificación: No se deben utilizar punteros ni referencias para las inicializaciones porque esto puede provocar violaciones de acceso si el puntero no se ha inicializado. Importancia: Media Ejemplo TYP...", 
"body" : "Detecta variables de referencia que se utilizan para la inicialización en la parte de declaración Justificación: No se deben utilizar punteros ni referencias para las inicializaciones porque esto puede provocar violaciones de acceso si el puntero no se ha inicializado. Importancia: Media Ejemplo TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n refTeststruct: REFERENCE TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := refTeststruct.xA; \/\/SA0125\nEND_VAR\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); Salida en el Mensajes vista: SA0125: Referencia utilizada en la inicialización " }, 
{ "title" : "SA0140: Declaraciones comentadas ", 
"url" : "_san_rule_sa0140.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0140: Declaraciones comentadas ", 
"snippet" : "Detecta declaraciones comentadas Justificación: el código a menudo se comenta con fines de depuración. Cuando se publica este tipo de comentario, no siempre está claro en un momento posterior si el código debe eliminarse o si se ha comentado con fines de depuración y, sin querer, no se ha dejado de ...", 
"body" : "Detecta declaraciones comentadas Justificación: el código a menudo se comenta con fines de depuración. Cuando se publica este tipo de comentario, no siempre está claro en un momento posterior si el código debe eliminarse o si se ha comentado con fines de depuración y, sin querer, no se ha dejado de comentar. Importancia: Alta Regla PLCopen: C4 Ejemplo PROGRAM PLC_PRG\nVAR\n iValue1: INT;\n iValue2: INT;\nEND_VAR\n iValue1 := 100;\niValue2 := 200;\n\/\/ iValue2 := 300; Salida en el Mensajes vista: SA0140: Declaraciones comentadas: iValue2 := 300 " }, 
{ "title" : "Posible uso de variables no inicializadas ", 
"url" : "_san_non_initialized_variables.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Posible uso de variables no inicializadas ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0039: Posibles deferencias de puntero nulo ", 
"url" : "_san_rule_sa0039.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Posible uso de variables no inicializadas \/ SA0039: Posibles deferencias de puntero nulo ", 
"snippet" : "Detecta ubicaciones de código donde posiblemente se desreferencia un puntero nulo Justificación: Se debe comprobar un puntero antes de cada desreferenciación para asegurarse de que no sea igual a cero. De lo contrario, puede producirse una infracción de acceso en tiempo de ejecución. Importancia: Al...", 
"body" : "Detecta ubicaciones de código donde posiblemente se desreferencia un puntero nulo Justificación: Se debe comprobar un puntero antes de cada desreferenciación para asegurarse de que no sea igual a cero. De lo contrario, puede producirse una infracción de acceso en tiempo de ejecución. Importancia: Alta Ejemplo PROGRAM PLC_PRG\nVAR\n ptiVar1:POINTER TO INT;\n ptiVar2:POINTER TO INT;\n ptiVar3:POINTER TO INT;\n iVar:INT;\n iCount :INT;\n iCondition: INT;\nEND_VAR\n iCount := iCount + INT#1;\nptiVar1 := ADR(iVar);\nptiVar1^ := iCondition; \/\/ OK - valid reference\nptiVar2^ := iCondition; \/\/ SA0039 - null pointer dereferenciation\niVar := ptiVar3^; \/\/ SA0039 - null pointer dereferenciation Salida en el Mensajes vista: SA0039: Posible deferencia de puntero nulo 'ptiVar2^' SA0039: Posible deferencia de puntero nulo 'ptiVar3^' " }, 
{ "title" : "SA0046: Posible uso de interfaz no inicializada ", 
"url" : "_san_rule_sa0046.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Posible uso de variables no inicializadas \/ SA0046: Posible uso de interfaz no inicializada ", 
"snippet" : "Detecta el uso de interfaces que no fueron inicializadas antes de ser utilizadas Justificación: Se debe comprobar que una referencia de interfaz sea <> 0 antes de utilizarla. De lo contrario, puede producirse una infracción de acceso durante el acceso. Importancia: Alta Ejemplo \/\/Declaration of INTE...", 
"body" : "Detecta el uso de interfaces que no fueron inicializadas antes de ser utilizadas Justificación: Se debe comprobar que una referencia de interfaz sea <> 0 antes de utilizarla. De lo contrario, puede producirse una infracción de acceso durante el acceso. Importancia: Alta Ejemplo \/\/Declaration of INTERFACE ITF and assigned METH2:\nMETHOD METH2 : BOOL\nVAR_INPUT\n iInput2:INT;\nEND_VAR \/\/Declaration of INTERFACE Master_ITF1 and assigned METH:\nMETHOD METH : BOOL\nVAR_INPUT\n iInput:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n instPOU : POU;\n instITF : ITF;\n instMasterITF1 : Master_ITF1;\n instMasterITF2 : Master_ITF2;\n iDummy : INT;\n xDummy : BOOL;\n instNoInitITF : ITF;\n instNoInitITF2 : ITF;\n instNoInitMasterITF1 : Master_ITF1;\n instNoInitMasterITF2 : Master_ITF2;\nEND_VAR instITF := instPOU;\nxDummy := instITF.METH(iInput := iDummy); \/\/ OK\ninstMasterITF1 := instPOU;\nxDummy := instMasterITF1.METH(iInput := iDummy); \/\/ OK\n\nxDummy := instNoInitITF.METH(iInput := INT#1); \/\/ SA0046\nxDummy := instNoInitITF.METH2(iInput2 := INT#2); \/\/ SA0046\nxDummy := instNoInitMasterITF1.METH(iInput := INT#3); \/\/ SA0046\niDummy := instNoInitMasterITF2.Prop; \/\/ SA0046\n\nIF instNoInitITF <> 0 THEN\n instNoInitITF.Prop; \/\/ OK, because the interface can't be 0\nEND_IF Salida en el Mensajes vista: SA0046: Posible uso de la interfaz no inicializada 'instNoInitITF' SA0046: Posible uso de la interfaz no inicializada 'instNoInitITF' SA0046: Posible uso de la interfaz no inicializada 'instNoInitMasterITF1' SA0046: Posible uso de la interfaz no inicializada 'instNoInitMasterITF2' " }, 
{ "title" : "SA0145: Posible uso de referencia no inicializada ", 
"url" : "_san_rule_sa0145.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ Posible uso de variables no inicializadas \/ SA0145: Posible uso de referencia no inicializada ", 
"snippet" : "Detecta cualquier variable de referencia que no se pueda inicializar antes del uso y que el operador no verifique __ISVALIDREF . Esta regla se aplica en la parte de implementación de las POU. Para la declaración, hay regla SA0124 . Justificación: Se debe comprobar la validez de una referencia antes ...", 
"body" : "Detecta cualquier variable de referencia que no se pueda inicializar antes del uso y que el operador no verifique __ISVALIDREF . Esta regla se aplica en la parte de implementación de las POU. Para la declaración, hay regla SA0124 . Justificación: Se debe comprobar la validez de una referencia antes del acceso, ya que durante el acceso puede producirse una infracción de acceso. Importancia: Alta Ejemplo PROGRAM PLC_PRG\nVAR_INPUT\n ref_iTest : REFERENCE TO INT;\nEND_VAR\n ref_iTest := 99; \/\/ SA0145\nIF __ISVALIDREF(ref_iTest) THEN\n ref_iTest := 88;\nEND_IF Salida en el Mensajes vista: SA0145: Posible uso de la referencia no inicializada 'ref_iTest' " }, 
{ "title" : "SA0150: Violaciones de límites inferiores o superiores o las métricas ", 
"url" : "_san_rule_sa0150.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0150: Violaciones de límites inferiores o superiores o las métricas ", 
"snippet" : "Detecta las POU que violan las métricas activadas en los límites inferior o superior Justificación: el código que cumple con ciertas métricas es más fácil de leer, más fácil de mantener y más fácil de probar. Importancia: Alta Regla PLCopen: CP9 Ejemplo Situación inicial: La Número de llamadas la mé...", 
"body" : "Detecta las POU que violan las métricas activadas en los límites inferior o superior Justificación: el código que cumple con ciertas métricas es más fácil de leer, más fácil de mantener y más fácil de probar. Importancia: Alta Regla PLCopen: CP9 Ejemplo Situación inicial: La Número de llamadas la métrica se selecciona en Configuración del proyecto → Análisis estático → Métricas . Límite inferior: 0 ; limite superior: 3 . Prog_1 se llama cinco veces. Al ejecutar el análisis estático, el SA0150: Violación de métrica para Prog_1. Informe para llamadas métricas (5) > 2 se emite un error en la vista de mensajes, en el Construir categoría. " }, 
{ "title" : "SA0160: Llamadas recursivas ", 
"url" : "_san_rule_sa0160.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0160: Llamadas recursivas ", 
"snippet" : "Detecta llamadas recursivas en acciones, métodos y propiedades de bloques de funciones. También detecta posibles recurrencias de llamadas de funciones virtuales y llamadas de interfaz. Justificación: Las recurrencias conducen a un comportamiento no determinista y, por lo tanto, son una fuente de err...", 
"body" : "Detecta llamadas recursivas en acciones, métodos y propiedades de bloques de funciones. También detecta posibles recurrencias de llamadas de funciones virtuales y llamadas de interfaz. Justificación: Las recurrencias conducen a un comportamiento no determinista y, por lo tanto, son una fuente de errores. Importancia: Media Regla PLCopen: CP13 Ejemplo El siguiente método Call está asignado al bloque de función FB_Test : FUNCTION_BLOCK FB_Test\nVAR\n bParameter: BOOL;\nEND_VAR\n METHOD Call : BOOL\nVAR_INPUT\nEND_VAR\n Call := THIS^.Call(); \/\/SA0160 El programa PLC_PRG llamadas FB_Test : PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\n bValue : BOOL;\nEND_VAR\n bValue := fbTest.bParameter;\nfbTest.Call(); Salida en el Mensajes vista: SA0160: Llamada recursiva detectada: 'PLC_PRG' -> 'FB_Test.Call' -> 'FB_Test.Call' " }, 
{ "title" : "SA0161: Estructura no empaquetada en estructura empaquetada ", 
"url" : "_san_rule_sa0161.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0161: Estructura no empaquetada en estructura empaquetada ", 
"snippet" : "Detecta estructuras no empaquetadas que se utilizan en estructuras empaquetadas Justificación: El compilador normalmente establece una estructura desempaquetada en una dirección que permite un acceso alineado a todos los elementos dentro de la estructura. Si crea esta estructura en una estructura em...", 
"body" : "Detecta estructuras no empaquetadas que se utilizan en estructuras empaquetadas Justificación: El compilador normalmente establece una estructura desempaquetada en una dirección que permite un acceso alineado a todos los elementos dentro de la estructura. Si crea esta estructura en una estructura empaquetada, el acceso alineado ya no será posible. Además, el acceso a un elemento de la estructura desempaquetada puede provocar una \"excepción de desalineación\". Importancia: Alta Ejemplo La estructura structSingleDataRecord está empaquetado, pero contiene las estructuras desempaquetadas struct4Byte y struct9Byte . {attribute 'pack_mode' := '1'}\nTYPE structSingleDataRecord :\nSTRUCT\n str9ByteData: struct9Byte; (* 9 BYTE *)\n str4ByteData: struct4Byte; (* 4 BYTE *)\n udi1: UDINT;\n udi2: UDINT;\n udi3: UDINT;\n usi4: USINT;\nEND_STRUCT\nEND_TYPE (* 9 BYTE *)\nTYPE struct9Byte :\nSTRUCT\n usiRotorSlots: USINT; (* 1 BYTE *)\n uiMaxCurrent: UINT; (* 2 BYTE *)\n usiVelocity: USINT; (* 1 BYTE *)\n uiAcceleration: UINT; (* 2 BYTE *)\n uiDeceleration: UINT; (* 2 BYTE *)\n usiDirectionChange: USINT; (* 1 BYTE *)\nEND_STRUCT\nEND_TYPE TYPE struct4Byte :\nSTRUCT\n \/\/udiDummy : UDINT;\n rRealDummy : REAL;\nEND_STRUCT\nEND_TYPE Salida en el Mensajes vista: SA0161: Declaración de una estructura desempaquetada 'struct9ByteData' dentro de una estructura empaquetada 'structSingleDataRecord' SA0161: Declaración de una estructura desempaquetada 'struct4ByteData' dentro de una estructura empaquetada 'structSingleDataRecord' " }, 
{ "title" : "SA0162: Faltan comentarios ", 
"url" : "_san_rule_sa0162.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0162: Faltan comentarios ", 
"snippet" : "Detecta ubicaciones no comentadas en el programa Justificación: muchas pautas de programación exigen comentarios completos, lo que aumenta la legibilidad y la capacidad de mantenimiento del código. Importancia: Baja Regla PLCopen: C2 Se requieren comentarios en los siguientes casos: Para la declarac...", 
"body" : "Detecta ubicaciones no comentadas en el programa Justificación: muchas pautas de programación exigen comentarios completos, lo que aumenta la legibilidad y la capacidad de mantenimiento del código. Importancia: Baja Regla PLCopen: C2 Se requieren comentarios en los siguientes casos: Para la declaración de variables. Los comentarios se encuentran arriba o a la derecha. Para la declaración de programas, bloques de funciones o métodos. Los comentarios se encuentran encima de la declaración (en la primera línea). Ejemplo PROGRAM PLC_PRG\nVAR\n iMaxValue: INT;\nEND_VAR\n Salida en el Mensajes vista: SA0162: Falta comentario para 'PLC_PRG' SA0162: Falta comentario para 'iMaxValue' " }, 
{ "title" : "SA0163: Comentarios anidados ", 
"url" : "_san_rule_sa0163.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0163: Comentarios anidados ", 
"snippet" : "Detecta comentarios anidados Justificación: Deben evitarse los comentarios anidados porque son difíciles de leer. Importancia: Baja Regla de PLCopen: C3 Ejemplo {attribute 'do-analysis'} (* That is (* nested comment 1 *) *) PROGRAM PLC_PRG VAR (* That is \/\/ nested comment 2 comment *) iVal1: INT; iV...", 
"body" : "Detecta comentarios anidados Justificación: Deben evitarse los comentarios anidados porque son difíciles de leer. Importancia: Baja Regla de PLCopen: C3 Ejemplo {attribute 'do-analysis'}\n(* That is\n(* nested comment 1 *)\n*)\nPROGRAM PLC_PRG\nVAR\n(* That is\n\/\/ nested comment 2\ncomment *)\n iVal1: INT;\n iVal2: INT;\n\n(* That is\n(* nested comment 3 *) *)\n pVal3: POINTER TO DWORD;\n hugo: INT;\nEND_VAR\n (* That is\n\/\/ nested comment 4\ncomment *)\niVal1 := iVal1 + 1;\n(* That is\n(* nested comment 5 *)\n*)\n\n(* Not that one *) Salida en el Mensajes vista: SA0163: Comentario anidado 'comentario anidado 1' SA0163: Comentario anidado 'comentario anidado 2' SA0163: Comentario anidado 'comentario anidado 3' SA0163: Comentario anidado 'comentario anidado 4' SA0163: Comentario anidado 'comentario anidado 5' " }, 
{ "title" : "SA0164: Comentarios de varias líneas ", 
"url" : "_san_rule_sa0164.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0164: Comentarios de varias líneas ", 
"snippet" : "Detecta comentarios de varias líneas que están codificados como (* comment *) . Solo los comentarios de una sola línea que están codificados como \/\/ comment esta permitido. Justificación: algunas pautas de programación prohíben los comentarios de varias líneas en el código porque el principio y el f...", 
"body" : "Detecta comentarios de varias líneas que están codificados como (* comment *) . Solo los comentarios de una sola línea que están codificados como \/\/ comment esta permitido. Justificación: algunas pautas de programación prohíben los comentarios de varias líneas en el código porque el principio y el final de un comentario podrían perderse y el paréntesis de cierre del comentario podría eliminarse por accidente. Puede desactivar esta comprobación mediante el pragma analysis , también para comentarios en la parte de declaración. Importancia: Baja Regla PLCopen: C5 Ejemplo {attribute 'do-analysis'}\n(*\n This is a multi-line comment \/\/ SA0164\n*)\nPROGRAM PLC_PRG\nVAR\n\/\/ This is a single line comment\n a: DINT;\nEND_VAR\n (* This is not a single line comment *) \/\/ SA0164\na := a + 1; Salida en el Mensajes vista: SA0164: Utilice únicamente comentarios de una sola línea " }, 
{ "title" : "SA0165: Tareas llamando a otras POU que programas ", 
"url" : "_san_rule_sa0165.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0165: Tareas llamando a otras POU que programas ", 
"snippet" : "Detecta tareas que llaman a bloques de funciones o funciones en lugar de un programa Justificación: Esta regla forma parte de las Directrices de Codificación de PLCopen. Por lo tanto, el cumplimiento también se verifica en CODESYS . No vemos ningún problema con la consistencia de los datos en CODESY...", 
"body" : "Detecta tareas que llaman a bloques de funciones o funciones en lugar de un programa Justificación: Esta regla forma parte de las Directrices de Codificación de PLCopen. Por lo tanto, el cumplimiento también se verifica en CODESYS . No vemos ningún problema con la consistencia de los datos en CODESYS si las tareas llamaran a POU que no sean programas. Sin embargo, pueden surgir problemas si el código se va a trasladar a otras plataformas. Importancia: Baja Regla PLCopen: CP16 Las tareas se insertan debajo de la configuración de la tarea. En las tareas se configuran las POUs a llamar. Las POU deben ser las Programa escribe. El bloque de funciones y Función No se permiten tipos. Ejemplo " }, 
{ "title" : "SA0166: máx. número de variables de input\/output\/in-out... ", 
"url" : "_san_rule_sa0166.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0166: máx. número de variables de input\/output\/in-out... ", 
"snippet" : "Detecta si un número definido de variables de entrada ( VAR_INPUT ), variables de salida ( VAR_OUTPUT ) o VAR_IN_OUT variables se excede en una POU. En el Configuración del proyecto , haga doble clic en la entrada de la regla para abrir un cuadro de diálogo donde defina el número máximo. Justificaci...", 
"body" : "Detecta si un número definido de variables de entrada ( VAR_INPUT ), variables de salida ( VAR_OUTPUT ) o VAR_IN_OUT variables se excede en una POU. En el Configuración del proyecto , haga doble clic en la entrada de la regla para abrir un cuadro de diálogo donde defina el número máximo. Justificación: Se trata de verificar las pautas de programación individuales. Muchas pautas de programación prevén un número máximo de parámetros de POU. Demasiados parámetros hacen que el código sea ilegible y que las POU sean difíciles de probar. Importancia: Media Regla PLCopen: CP23 Ejemplo En la configuración del proyecto, para la Regla 166, ha definido un número máximo de 1 por VAR_IN_OUT variables FUNCTION_BLOCK FB1\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nVAR_IN_OUT\n xInOut1 : BOOL;\n xInOut2 : BOOL;\nEND_VAR\n Salida en el Mensajes vista: SA0166: Demasiadas variables VAR_IN_OUT en POU 'FB1' " }, 
{ "title" : "SA0167: Instancias de bloques de funciones temporales ", 
"url" : "_san_rule_sa0167.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0167: Instancias de bloques de funciones temporales ", 
"snippet" : "La comprobación detecta instancias de bloques de funciones que se declaran como variables temporales. Esto afecta a las instancias que se declaran en un método o función o como VAR_TEMP , y por lo tanto se reinicializan en cada ciclo de procesamiento o para cada llamada de POU. Justificación: Los bl...", 
"body" : "La comprobación detecta instancias de bloques de funciones que se declaran como variables temporales. Esto afecta a las instancias que se declaran en un método o función o como VAR_TEMP , y por lo tanto se reinicializan en cada ciclo de procesamiento o para cada llamada de POU. Justificación: Los bloques de funciones tienen un estado que normalmente se mantiene durante múltiples ciclos del PLC. Una instancia en la pila existe solo mientras dura la llamada a la función. Por lo tanto, rara vez tiene sentido crear una instancia como variable temporal. En segundo lugar, las instancias de bloques de funciones suelen ser grandes y necesitan mucho espacio en la pila (que normalmente está restringido a los controladores). En tercer lugar, la inicialización y, a menudo, también la programación de un bloque de funciones puede llevar mucho tiempo. Importancia: Media Ejemplo PROGRAM PLC_PRG\nVAR\nEND_VAR\nVAR_TEMP\n yafb: AFB;\nEND_VAR FUNCTION Fun : INT\nVAR_INPUT\nEND_VAR\nVAR\n funafb: AFB;\nEND_VAR\n METHOD METH : INT\nVAR_INPUT\nEND_VAR\nVAR\n methafb: AFB; \/\/ SA0167\nEND_VAR Salida en el Mensajes vista: SA0167: Instancia de bloque de función temporal: 'methafb' " }, 
{ "title" : "SA0168: Asignaciones innecesarias ", 
"url" : "_san_rule_sa0168.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0168: Asignaciones innecesarias ", 
"snippet" : "Detecta asignaciones a variables que no tienen ningún efecto en el código. Justificación: cuando se asignan valores a una variable varias veces sin que la variable se evalúe entre asignaciones, las primeras asignaciones no tienen ningún efecto en el programa. Importancia: Baja Ejemplo PROGRAM PLC_PR...", 
"body" : "Detecta asignaciones a variables que no tienen ningún efecto en el código. Justificación: cuando se asignan valores a una variable varias veces sin que la variable se evalúe entre asignaciones, las primeras asignaciones no tienen ningún efecto en el programa. Importancia: Baja Ejemplo PROGRAM PLC_PRG\nVAR\n dwVal1 : DWORD;\n dwVal2 : DWORD;\nEND_VAR\n \/\/ unnecessary assignment\ndwVal1 := 1; \nIF dwVal2 > 100 THEN\n dwVal2 := 0;\n dwVal2 := dwVal2 + 1;\nEND_IF\ndwVal1 := 2; Salida en el Mensajes vista: SA0168: Se asigna la variable 'dwVal1', pero nunca se utiliza su valor. " }, 
{ "title" : "SA0169: Salidas ignoradas ", 
"url" : "_san_rule_sa0169.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0169: Salidas ignoradas ", 
"snippet" : "Detecta las salidas de métodos y funciones que no se especifican al llamar al método o función. Justificación: las salidas ignoradas pueden ser un aviso sobre un error no controlado o llamadas a funciones sin sentido porque no se usan los resultados. Importancia: Media Ejemplo FUNCTION Fun1 VAR_INPU...", 
"body" : "Detecta las salidas de métodos y funciones que no se especifican al llamar al método o función. Justificación: las salidas ignoradas pueden ser un aviso sobre un error no controlado o llamadas a funciones sin sentido porque no se usan los resultados. Importancia: Media Ejemplo FUNCTION Fun1\nVAR_INPUT\n bIn : BOOL;\nVAR_END\nVAR_OUTPUT\n bOut : BOOL;\nEND_VA\n ; PROGRAM PLC_PRG\nVAR\n bValue :BOOl;\nEND_VAR\n Fun1(bIn : TRUE);\n Salida en el Mensajes vista: SA0169: La salida 'bOut' se ignora cuando se llama " }, 
{ "title" : "SA0170: No se debe utilizar la dirección de una variable de salida ", 
"url" : "_san_rule_sa0170.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0170: No se debe utilizar la dirección de una variable de salida ", 
"snippet" : "Detecta las ubicaciones del código donde se encuentra la dirección de una variable de salida ( VAR_OUTPUT , VAR_IN_OUT ) de un bloque de funciones. Justificación: No está permitido utilizar la dirección de salida de un bloque de funciones de la siguiente manera: Por medio del ADR operador Por medio ...", 
"body" : "Detecta las ubicaciones del código donde se encuentra la dirección de una variable de salida ( VAR_OUTPUT , VAR_IN_OUT ) de un bloque de funciones. Justificación: No está permitido utilizar la dirección de salida de un bloque de funciones de la siguiente manera: Por medio del ADR operador Por medio de REF= Excepción: no se informa ningún error si la variable de salida se usa dentro del mismo bloque de funciones. Importancia: Media Ejemplo Bloque de funciones FB1 tiene el VAR_OUTPUT variable iOutVal : INT; El siguiente acceso en otra POU genera el Error SA0170: \/\/FB1_inst is of type FB1\naddr1 := ADR(FB1_inst.iOutVal); \/\/SA0170\nrefINT REF= FB1_inst.iOutVal; \/\/SA0179\n El siguiente acceso directamente dentro del FB1 bloque de funciones también genera el error: \/\/other is a POINTER TO FB1\nptr := ADR(other^.iOutVal); \/\/SA0170 El siguiente acceso directamente dentro del FB1 bloque de funciones no genera errores: \/\/iInputVal is a VAR_INPUT of FB1\niOutVal := iInputVal; \n\/\/ptr is a POINTER TO INT\nptr := ADR(THIS^.iOutVal); \nptr := ADR(iOutVal); Salida en el Mensajes vista: SA0170: No debe tomar la dirección de una variable de salida " }, 
{ "title" : "SA0171: Las enumeraciones deben tener el atributo 'strict' ", 
"url" : "_san_rule_sa0171.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0171: Las enumeraciones deben tener el atributo 'strict' ", 
"snippet" : "Detecta declaraciones de enumeraciones que no se proporcionan con el {attribute 'strict'} atributo. Justificación: La {attribute 'strict'} El atributo hace que se emitan errores del compilador si el código viola las estrictas reglas de programación para las enumeraciones. Por defecto, cuando se crea...", 
"body" : "Detecta declaraciones de enumeraciones que no se proporcionan con el {attribute 'strict'} atributo. Justificación: La {attribute 'strict'} El atributo hace que se emitan errores del compilador si el código viola las estrictas reglas de programación para las enumeraciones. Por defecto, cuando se crea una nueva enumeración, a la declaración se le asigna automáticamente el 'strict' atributo. Para más información, ver: Tipo de datos: enumeración Importancia: Alta Ejemplo TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE Salida en el Mensajes vista: SA0171: La enumeración debe tener el atributo 'strict' Sin violación de las reglas de programación: {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE " }, 
{ "title" : "SA0172: Posible intento de acceso fuera de los límites de la matriz ", 
"url" : "_san_rule_sa0172.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0172: Posible intento de acceso fuera de los límites de la matriz ", 
"snippet" : "Detecta el posible acceso a un índice de matriz fuera de los límites de la matriz. A menudo, el rango del índice de la matriz se excede en FOR bucles donde la variable de índice se usa para acceder a un índice de matriz. Importancia: Alta Ejemplo PROGRAM Test VAR_TEMP iIndex: INT; arUSINT: Array[0.....", 
"body" : "Detecta el posible acceso a un índice de matriz fuera de los límites de la matriz. A menudo, el rango del índice de la matriz se excede en FOR bucles donde la variable de índice se usa para acceder a un índice de matriz. Importancia: Alta Ejemplo PROGRAM Test\nVAR_TEMP\n iIndex: INT;\n arUSINT: Array[0..10] OF INT;\nEND_VAR\n FOR iIndex := INT#0 TO INT#50 DO\n arUSINT[iIndex] := 0;\nEND_FOR Salida en el Mensajes vista: SA0172: Posible intento de acceso fuera de los límites de la matriz " }, 
{ "title" : "SA0175: Operación sospechosa en cadena ", 
"url" : "_san_rule_sa0175.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0175: Operación sospechosa en cadena ", 
"snippet" : "No siempre habilite esta regla. Habilite la regla solo cuando sea necesario para encontrar las ubicaciones en el código que deben verificarse al convertir a la codificación UTF-8. Comprueba si la opción de proyecto Codificación UTF-8 para STRING se puede habilitar. Este es el caso cuando no se encue...", 
"body" : "No siempre habilite esta regla. Habilite la regla solo cuando sea necesario para encontrar las ubicaciones en el código que deben verificarse al convertir a la codificación UTF-8. Comprueba si la opción de proyecto Codificación UTF-8 para STRING se puede habilitar. Este es el caso cuando no se encuentran ubicaciones de código con operaciones sospechosas. Al cambiar a la codificación UTF-8, los primeros 127 caracteres corresponden a la codificación ASCII. Sin embargo, todos los demás caracteres están codificados con más de un byte. Esto puede provocar un cambio en el comportamiento al procesar cadenas. Como resultado, un literal de cadena que contenga caracteres que no sean ASCII puede volverse más largo. O el acceso en una cadena por índice puede acceder al elemento incorrecto. Finalmente, incluso puede ocurrir el acceso a un desplazamiento de byte no válido. Cuando la regla está activa, se informan todas las ubicaciones de código que contienen cualquiera de las siguientes construcciones: Índice de acceso a una cadena de bytes Ejemplo: str[2] Mensaje: SA0175: Enumeración con atributo 'strict': Operación sospechosa en cadena: acceso al índice '<expresión>' Acceso de direcciones a cadenas de un solo byte Ejemplo: ADR(str) Mensaje: SA0175: Enumeración con atributo 'strict': Operación sospechosa en cadena: Posible acceso al índice '<expresión>' Llamada de funciones de cadena del Standard biblioteca, excepto cuando llame al CONCAT y LEN funciones Mensaje: SA0175: Enumeración con atributo 'estricto': Operación sospechosa en cadena: Posible acceso al índice '<expresión>' Byte literal que contiene caracteres que no son ASCII Ejemplos: str := '99€';\nstr :='Ä'; Mensaje: SA0175: Operación sospechosa en una cadena: El literal '<literal>' contiene caracteres que no son ASCII " }, 
{ "title" : "SA0180: El rango de índice no cubre toda la matriz ", 
"url" : "_san_rule_sa0180.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Reglas \/ SA0180: El rango de índice no cubre toda la matriz ", 
"snippet" : "Detecta matrices con un rango de índice cubierto de forma incompleta Las matrices a menudo se manejan en bucles, donde el índice del bucle indexa la matriz para que todos los componentes de la matriz salten sin espacios. Esto se da si el índice del bucle y el índice de la matriz son los mismos en to...", 
"body" : "Detecta matrices con un rango de índice cubierto de forma incompleta Las matrices a menudo se manejan en bucles, donde el índice del bucle indexa la matriz para que todos los componentes de la matriz salten sin espacios. Esto se da si el índice del bucle y el índice de la matriz son los mismos en todas las dimensiones. Si el rango del índice no cubre completamente la matriz, esto indica que hay componentes no controlados en la matriz. Importancia: Media Ejemplo {attribute 'do-analysis'}\nPROGRAM PLC_PRG\nVAR\n a : INT;\n arWord : ARRAY [0..100] OF WORD;\nEND_VAR\n\/\/Implementation\nFOR a := INT#1 TO INT#100 BY 1 DO \/\/SA0180: Lower range is not reached\n\tarWord[a] := INT_TO_WORD(a);\nEND_FOR;\n;\n Salida en el Mensajes vista: SA0180: El rango del índice no cubre toda la matriz " }, 
{ "title" : "Métrica ", 
"url" : "_san_reference_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica ", 
"snippet" : "Descripción detallada de las métricas proporcionada por CODESYS Static Analysis El Tamaño del código , tamaño variable , Tamaño de la pila , y Número de llamadas Las métricas se informan solo para las POU de bibliotecas que están integradas en el proyecto....", 
"body" : "Descripción detallada de las métricas proporcionada por CODESYS Static Analysis El Tamaño del código , tamaño variable , Tamaño de la pila , y Número de llamadas Las métricas se informan solo para las POU de bibliotecas que están integradas en el proyecto. " }, 
{ "title" : "Métrica: Tamaño del código (número de bytes) ", 
"url" : "_san_reference_metrics.html#UUID-35adc4d5-9253-44d6-f130-aab7171bff69", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Tamaño del código (número de bytes) ", 
"snippet" : "Tamaño del código (número de bytes) Categorías: Informativo, Eficiencia Número de bytes que un bloque de funciones aporta al código de la aplicación El número también depende del generador de código. Por ejemplo, el generador de código para procesadores ARM generalmente genera más bytes que el gener...", 
"body" : "Tamaño del código (número de bytes) Categorías: Informativo, Eficiencia Número de bytes que un bloque de funciones aporta al código de la aplicación El número también depende del generador de código. Por ejemplo, el generador de código para procesadores ARM generalmente genera más bytes que el generador de código para procesadores x86. " }, 
{ "title" : "Métrica: Tamaño variable (número de bytes) ", 
"url" : "_san_reference_metrics.html#UUID-b07882e2-be28-fe1e-eb10-ed5defcf3c74", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Tamaño variable (número de bytes) ", 
"snippet" : "Tamaño variable (número de bytes) Categorías : Informativo, Eficiencia Tamaño de la memoria estática que utiliza el objeto. Para los bloques de funciones, este es el tamaño que se utiliza para una instancia del bloque de funciones (que puede incluir espacios de memoria, según la alineación de la mem...", 
"body" : "Tamaño variable (número de bytes) Categorías : Informativo, Eficiencia Tamaño de la memoria estática que utiliza el objeto. Para los bloques de funciones, este es el tamaño que se utiliza para una instancia del bloque de funciones (que puede incluir espacios de memoria, según la alineación de la memoria). Para programas, funciones y listas de variables globales, esta es la suma del tamaño de todas las variables estáticas. Ejemplo FUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR La función tiene 3 variables estáticas de tipo INT (f , g , y h ), cada uno de los cuales requiere 2 bytes de memoria. Como resultado, FUN1 tiene un tamaño variable de 6 bytes. " }, 
{ "title" : "Métrica: Tamaño de pila (número de bytes) ", 
"url" : "_san_reference_metrics.html#UUID-52e032c0-e190-f5c0-344b-e6c04694a3ef", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Tamaño de pila (número de bytes) ", 
"snippet" : "Tamaño de pila (número de bytes) Categorías : Informativo, Eficiencia, Confiabilidad Número de bytes necesarios para llamar una función o un bloque de funciones Las variables de entrada y las variables de salida están alineadas con la memoria. Esto puede crear una brecha entre estas variables y las ...", 
"body" : "Tamaño de pila (número de bytes) Categorías : Informativo, Eficiencia, Confiabilidad Número de bytes necesarios para llamar una función o un bloque de funciones Las variables de entrada y las variables de salida están alineadas con la memoria. Esto puede crear una brecha entre estas variables y las variables locales. Esta brecha se cuenta. Los valores de retorno de las funciones llamadas que no caben en un registro se colocan en la pila. El mayor de estos valores determina la memoria adicional asignada, que también cuenta. Las funciones o bloques de funciones que se llaman dentro de las POU consideradas tienen su propio marco de pila. Por tanto, la memoria para este tipo de llamadas no cuenta. Dependiendo del generador de código utilizado, los resultados intermedios de los cálculos también utilizan la pila. Estos resultados no se cuentan. Ejemplo \/\/Declaration\nFUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d,e : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR\n\n\/\/Implementation\nc := b;\nd := a;\ne := a+b; Supuesto: Para el cálculo, suponga un CODESYS Control Win que utiliza el generador de código x86. El ejemplo anterior tiene un tamaño de llamada de 8 bytes: 4 bytes para los dos INT inputs y 4 bytes para el valor de retorno. El dispositivo tiene una alineación de pila de 4 bytes, por lo que hay un espacio de 2 bytes. El tamaño de la persona que llama es de 8 bytes: tres variables locales con 2 bytes cada una más el espacio de 2 bytes para la alineación de la pila. Como resultado, el tamaño total de la pila de FUN1 es de 16 bytes. VAR_STAT no se almacena en la pila y, por lo tanto, no aumenta el tamaño de la pila de una POU. " }, 
{ "title" : "Métrica: Número de llamadas (Llamadas) ", 
"url" : "_san_reference_metrics.html#UUID-652fc3dc-10b7-711b-cea7-9b006e6249b5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Número de llamadas (Llamadas) ", 
"snippet" : "Número de llamadas (llamadas) Categoría : Informativo Número de llamadas de la POU bajo Unidad de programa Ejemplo \/\/Declaration PLC_PRG PROGRAM PLC_PRG VAR myFB : FB1; END_VAR \/\/Implementation myFB(b := FALSE); \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR_INPUT b : BOOL; END_VAR VAR i : INT; END_VAR \/\/...", 
"body" : "Número de llamadas (llamadas) Categoría : Informativo Número de llamadas de la POU bajo Unidad de programa Ejemplo \/\/Declaration PLC_PRG\nPROGRAM PLC_PRG\nVAR\n myFB : FB1;\nEND_VAR\n\n\/\/Implementation\nmyFB(b := FALSE); \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR_INPUT\n b : BOOL;\nEND_VAR\nVAR\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH(i);\nIF b THEN\n METH(i*i);\nEND_IF\n \/\/Declaration FB1.METH\nMETHOD METH : BOOL\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := i >= 42; Si PLC_PRG se llama en una tarea, entonces esta llamada también se cuenta. FB1 tiene exactamente una llamada (en PLC_PRG ). METH tiene dos llamadas, ambas en FB1 . " }, 
{ "title" : "Métrica: Número de llamadas de tareas (Tareas) ", 
"url" : "_san_reference_metrics.html#UUID-3768e9b9-fdef-e8c5-d81a-3ab94c3eed82", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Número de llamadas de tareas (Tareas) ", 
"snippet" : "Número de llamadas de tareas (Tareas) Categorías : Mantenibilidad, Fiabilidad Número de tareas ( Tareas ) donde la POU especificada en Unidad de programa se llama En el caso de los bloques de funciones, se cuenta el número de tareas en las que se llama al propio bloque de funciones o a cualquier blo...", 
"body" : "Número de llamadas de tareas (Tareas) Categorías : Mantenibilidad, Fiabilidad Número de tareas ( Tareas ) donde la POU especificada en Unidad de programa se llama En el caso de los bloques de funciones, se cuenta el número de tareas en las que se llama al propio bloque de funciones o a cualquier bloque de funciones del árbol de herencia del bloque de funciones. En el caso de métodos y acciones se muestra el número de tareas en las que se llama al bloque de funciones (principal). Ejemplo FUNCTION_BLOCK FB\n\/\/... FUNCTION_BLOCK FB2 EXTENDS FB\n\/\/... FUNCTION_BLOCK FB3 EXTENDS FB2\n\/\/... Cada bloque de funciones se llama a su manera. PROGRAM . Cada PROGRAM tiene su propia tarea. El Llamado en tareas rendimientos métricos en 1 para FB3 y 2 para FB2 porque las llamadas de FB3 y FB2 se cuentan. La métrica da como resultado 3 para FB porque en este caso las llamadas de FB3 , FB2 , y FB se cuentan. " }, 
{ "title" : "Métrica: Número de variables globales utilizadas (Globales) ", 
"url" : "_san_reference_metrics.html#UUID-04068c53-4046-0979-468b-866b1a155a8a", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Número de variables globales utilizadas (Globales) ", 
"snippet" : "Número de variables globales utilizadas (Globales) Categorías : Mantenibilidad, Reutilización Número de variables globales utilizadas en la POU bajo Unidad de programa Ejemplo \/\/GVL VAR_GLOBAL gvla : INT; gvlb : INT; gvlc : INT; END_VAR \/PRG declaration PROGRAM PRG VAR x : INT := GVL.gvlc; y : INT; ...", 
"body" : "Número de variables globales utilizadas (Globales) Categorías : Mantenibilidad, Reutilización Número de variables globales utilizadas en la POU bajo Unidad de programa Ejemplo \/\/GVL\nVAR_GLOBAL\n gvla : INT;\n gvlb : INT;\n gvlc : INT;\nEND_VAR \/PRG declaration\nPROGRAM PRG\nVAR\n x : INT := GVL.gvlc;\n y : INT;\nEND_VAR\n\n\/\/PRG implementation\nx := GVL.gvla;\ny := GVL.gvla*GVL.gvlb; El PRG El programa utiliza 3 variables de GVL : gvla , gvlb , y gvlc . " }, 
{ "title" : "Métrica: Número de accesos a direcciones directas (IO) ", 
"url" : "_san_reference_metrics.html#UUID-792a6162-1022-f930-dadb-104aa5a51709", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Número de accesos a direcciones directas (IO) ", 
"snippet" : "Número de accesos a direcciones directas (IO) Categorías : Reutilizabilidad, Mantenibilidad Número de accesos a direcciones directas ( IO ) en la implementación del objeto. Ejemplo \/\/Declaration PROGRAM PRG VAR xVar : BOOL:= %IX0.0; \/\/ +1 direct address access byVar : BYTE; END_VAR \/\/Implementation ...", 
"body" : "Número de accesos a direcciones directas (IO) Categorías : Reutilizabilidad, Mantenibilidad Número de accesos a direcciones directas ( IO ) en la implementación del objeto. Ejemplo \/\/Declaration\nPROGRAM PRG\nVAR\n xVar : BOOL:= %IX0.0; \/\/ +1 direct address access\n byVar : BYTE;\nEND_VAR\n\n\/\/Implementation\nxVar := %IX0.0; \/\/ +1 direct address access\n%QX0.0 := xVar; \/\/ +1\n%MX0.1 := xVar; \/\/ +1\n%MB1 := byVar; \/\/ +1 El ejemplo tiene 5 accesos directos a direcciones. " }, 
{ "title" : "Métrica: Número de variables locales (Locales) ", 
"url" : "_san_reference_metrics.html#UUID-f738f257-cf3a-1e7c-979e-1d6b4733c2d9", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Número de variables locales (Locales) ", 
"snippet" : "Número de variables locales (Locales) Categorías : Informativo, Eficiencia Número de variables declaradas en el VAR área de la POU. Las variables heredadas no se cuentan. Ejemplo \/\/Declaration FUNCTION_BLOCK FB VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR i,j,k,l : INT; m,n,o : BOOL; END_VAR En el bloqu...", 
"body" : "Número de variables locales (Locales) Categorías : Informativo, Eficiencia Número de variables declaradas en el VAR área de la POU. Las variables heredadas no se cuentan. Ejemplo \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,j,k,l : INT;\n m,n,o : BOOL;\nEND_VAR\n En el bloque de funciones se declaran 7 variables locales. " }, 
{ "title" : "Métrica: Número de variables de entrada (Entradas) ", 
"url" : "_san_reference_metrics.html#UUID-03e01655-9ac0-74f4-3fd7-cf22f23db4f6", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Número de variables de entrada (Entradas) ", 
"snippet" : "Número de variables de entrada (Entradas) Categorías : Mantenibilidad, Reutilización Límite superior predeterminado para el correspondiente SA0166 regla: 10 Número de variables declaradas en VAR_INPUT de la unidad del programa. Las variables de entrada heredadas no se cuentan. Ejemplos FUNCTION_BLOC...", 
"body" : "Número de variables de entrada (Entradas) Categorías : Mantenibilidad, Reutilización Límite superior predeterminado para el correspondiente SA0166 regla: 10 Número de variables declaradas en VAR_INPUT de la unidad del programa. Las variables de entrada heredadas no se cuentan. Ejemplos FUNCTION_BLOCK FB\nVAR_INPUT\n i : INT;\n r : REAL;\nEND_VAR\n En el bloque de funciones se declaran 2 variables de entrada: i y r . METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR\n El método tiene 2 entradas: j y l " }, 
{ "title" : "Métrica: Número de variables de salida (Salidas) ", 
"url" : "_san_reference_metrics.html#UUID-7bba3bc6-748c-311d-7f8c-4878fdce9da0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Número de variables de salida (Salidas) ", 
"snippet" : "Número de variables de salida (Salidas) Categorías : Mantenibilidad, Reutilización Límite superior predeterminado para el correspondiente SA0166 regla: 10 Número de variables en VAR_OUTPUT de la unidad de programa En el caso de bloques de funciones, este es el número de variables de salida personali...", 
"body" : "Número de variables de salida (Salidas) Categorías : Mantenibilidad, Reutilización Límite superior predeterminado para el correspondiente SA0166 regla: 10 Número de variables en VAR_OUTPUT de la unidad de programa En el caso de bloques de funciones, este es el número de variables de salida personalizadas ( VAR_OUTPUT ). En el caso de métodos y funciones, este es el número de variables de salida personalizadas más uno si tienen un valor de retorno. También se cuenta el valor de retorno. Las variables de salida heredadas no se cuentan. Un número elevado de variables de salida es un indicio de una violación del principio de responsabilidad única. Ejemplos FUNCTION_BLOCK FB\nVAR_OUTPUT\n i : INT; \/\/ +1 output\n r : REAL; \/\/ +1 output\nEND_VAR El bloque de funciones tiene 2 variables de salida: i y r METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR El método tiene 3 salidas: METH , j , y l METHOD METH1 \/\/ +0 outputs (no return type)\nVAR_OUTPUT\n ar : ARRAY[0..10] OF INT; \/\/ +1 output\n l : LREAL; \/\/ +1 output\nEND_VAR El METH1 El método tiene 2 salidas: ar y i " }, 
{ "title" : "Métrica: NOS – Número de declaraciones ", 
"url" : "_san_reference_metrics.html#UUID-82054fe5-816d-0c12-0afa-11dabf2c47b3", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: NOS – Número de declaraciones ", 
"snippet" : "NOS – Número de declaraciones Categoría : Informativo Número de declaraciones en la implementación de un bloque de funciones, función o método Las declaraciones en la declaración, las declaraciones vacías o los pragmas no se cuentan. Ejemplo \/\/Declaration: FUNCTION POU : BOOL VAR_INPUT END_VAR VAR c...", 
"body" : "NOS – Número de declaraciones Categoría : Informativo Número de declaraciones en la implementación de un bloque de funciones, función o método Las declaraciones en la declaración, las declaraciones vacías o los pragmas no se cuentan. Ejemplo \/\/Declaration:\nFUNCTION POU : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n c : INT := 100; \/\/ statements in the declaration are not counted\nEND_VAR\nVAR_OUTPUT\n test : INT;\n i : INT;\nEND_VAR\n\n\/\/Implementation:\nIF TRUE THEN \/\/if statement: +1\n test := 0; \/\/ +1\nEND_IF\n\nWHILE test = 1 DO \/\/while statement: +1\n ; \/\/ empty statements do not add to the statement count\nEND_WHILE\n\nFOR c := 0 TO 10 BY 2 DO \/\/for statement: +1\n i := i+i; \/\/ +1\nEND_FOR\n\n{text 'simple text pragma'} \/\/pragmas are not counted\ntest := 2; \/\/+1 El ejemplo tiene 6 declaraciones. " }, 
{ "title" : "Métrica: Porcentaje de comentarios ", 
"url" : "_san_reference_metrics.html#UUID-abd88d31-c33e-db93-0f69-bec1a38795f7", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Porcentaje de comentarios ", 
"snippet" : "Porcentaje de comentario Categoría : Mantenibilidad Porcentaje de comentarios en el código fuente. Este número se calcula según la siguiente fórmula: Porcentaje = 100 * <caracteres en comentarios> \/ <suma de caracteres en código fuente y caracteres en comentarios> Varios espacios consecutivos en el ...", 
"body" : "Porcentaje de comentario Categoría : Mantenibilidad Porcentaje de comentarios en el código fuente. Este número se calcula según la siguiente fórmula: Porcentaje = 100 * <caracteres en comentarios> \/ <suma de caracteres en código fuente y caracteres en comentarios> Varios espacios consecutivos en el código fuente se cuentan como un espacio, lo que evita una gran ponderación del código fuente sangrado. Para objetos vacíos (sin código fuente ni comentarios), se devuelve un porcentaje de 0. Ejemplo Parte de la declaración: FUNCTION_BLOCK FB \/\/comments in the declaration are counted, as well\nVAR_TEMP\n hugo : INT;\nEND_VAR Implementación: hugo := hugo + 1;\n\/\/Declaration: 40 letters non comment; 50 letters comment\n\/\/Implementation: 13 letters non comment; 152 letters comment\n\/\/ 100 * 202 \/ 255 -> 79% comments El cálculo del porcentaje 100 * 202\/255 arroja 79%. " }, 
{ "title" : "Métrica: Complejidad (McCabe) ", 
"url" : "_san_reference_metrics.html#UUID-ea21160c-97be-30d4-7748-0adac68532a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Complejidad (McCabe) ", 
"snippet" : "Complejidad (McCabe) Categoría : Comprobabilidad Límite superior recomendado: 10 La complejidad ciclomática según McCabe es una medida de la legibilidad y comprobabilidad del código fuente. Se calcula contando el número de ramas binarias en el flujo de control de la POU. Sin embargo, la complejidad ...", 
"body" : "Complejidad (McCabe) Categoría : Comprobabilidad Límite superior recomendado: 10 La complejidad ciclomática según McCabe es una medida de la legibilidad y comprobabilidad del código fuente. Se calcula contando el número de ramas binarias en el flujo de control de la POU. Sin embargo, la complejidad ciclomática penaliza la alta ramificación porque la alta ramificación aumenta la cantidad de casos de prueba necesarios para una alta cobertura de prueba. Ejemplo: IF declaración \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nIF b1 THEN \/\/ +1 for the THEN branch\n ;\n ELSIF b2 THEN \/\/ +1 for the THEN branch of the IF inside the else\n ;\nELSE \n IF b3 OR b4 THEN \/\/ +1 for the THEN branch\n ;\n END_IF\nEND_IF El fragmento de código tiene una complejidad ciclomática de 4. Ejemplo: CASE declaración \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nCASE a OF\n 1:\t; \/\/ +1\n 2:\t; \/\/ +1\n 3,4,5:\t; \/\/ +1\nELSE \/\/ the ELSE statement does not increase the cyclomatic complexity\n ;\nEND_CASE El fragmento de código tiene una complejidad ciclomática de 4. Ejemplo: Declaración de bucle \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nWHILE b1 DO \/\/ +1 for the WHILE loop\n ;\nEND_WHILE\n\nREPEAT \/\/ +1 for the REPEAT loop\n ;\n UNTIL b2\nEND_REPEAT\n\nFOR a := 0 TO 100 BY 2 DO \/\/ +1 for the REPEAT loop\n ;\nEND_FOR El fragmento de código tiene una complejidad ciclomática de 4. Ejemplo: Otras declaraciones Las siguientes declaraciones también aumentan la complejidad ciclomática: \/\/Declaration\nFUNCTION FUN : STRING\nVAR_INPUT\n condition_return : BOOL;\n condition_jmp : BOOL;\nEND_VAR\nVAR\nEND_VAR\n\n\/\/Implementation\n\/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nJMP(condition_jmp) lbl; \/\/Conditional jumps increase the cyclomatic complexity by 1\n\nFUN := 'u';\nRETURN(condition_return); \/\/Conditional returns increase the cyclomatic complexity by 1, too\n\nlbl:\nFUN := 't';\n El fragmento de código tiene una complejidad ciclomática de 3. " }, 
{ "title" : "Métrica: Complejidad Cognitiva ", 
"url" : "_san_reference_metrics.html#UUID-cd064f18-bd35-1d86-1bd4-2ae3a8fe344f", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Complejidad Cognitiva ", 
"snippet" : "Complejidad cognitiva Categoría : Mantenibilidad Límite superior predeterminado para la regla SA0178 correspondiente: 20 La complejidad cognitiva es una medida de la legibilidad y comprensibilidad del código fuente introducido por Sonarsource™ en 2016. Sin embargo, penaliza el anidamiento intenso de...", 
"body" : "Complejidad cognitiva Categoría : Mantenibilidad Límite superior predeterminado para la regla SA0178 correspondiente: 20 La complejidad cognitiva es una medida de la legibilidad y comprensibilidad del código fuente introducido por Sonarsource™ en 2016. Sin embargo, penaliza el anidamiento intenso del flujo de control y las expresiones booleanas complejas. La complejidad cognitiva se calcula sólo para implementaciones de texto estructurado. Los siguientes ejemplos muestran cómo se calcula la complejidad cognitiva. El Mostrar complejidad cognitiva para el editor actual El comando se puede utilizar para mostrar adicionalmente los incrementos del texto estructurado. Ejemplo: Control de flujo Las declaraciones que manipulan el flujo de control aumentan la complejidad cognitiva en 1 IF TRUE THEN \/\/ +1 cognitive complexity\n ;\nEND_IF\n\nWHILE TRUE DO \/\/+1 cognitive complexity\n ;\nEND_WHILE\n\nFOR i := 0 TO 10 BY 1 DO \/\/+1 cognitive complexity\n ;\nEND_FOR\n\nREPEAT \/\/+1 cognitive complexity\n ;\nUNTIL TRUE\nEND_REPEAT El fragmento de código tiene una complejidad cognitiva de 4. Ejemplo: Anidamiento del flujo de control Al anidar el flujo de control, se agrega un incremento de 1 para cada nivel de anidamiento. IF TRUE THEN \/\/+1 cognitive complexity\n WHILE TRUE DO \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n FOR i := 0 TO 10 BY 1 DO \/\/+3 (+1 for the FOR loop itself, +2 for the nesting inside the WHILE and the IF)\n\t\t\t;\n END_FOR\n END_WHILE\n\n REPEAT \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n ;\n UNTIL TRUE\n END_REPEAT\nEND_IF El fragmento de código tiene una complejidad cognitiva de 8. Ejemplo: Expresión booleana Dado que las expresiones booleanas desempeñan un papel importante en la comprensión del código fuente, también se tienen en cuenta al calcular la complejidad cognitiva. Comprender las expresiones booleanas asociadas con el mismo operador booleano no es tan difícil como comprender una expresión booleana que contiene operadores booleanos alternos. Por tanto, cualquier cadena de operadores booleanos idénticos en una expresión aumenta la complejidad cognitiva. b := b1; \/\/+0: a simple expression, containing no operators, has no increment\n La expresión simple sin operador tiene un incremento de 0. b := b1 AND b2; \/\/+1: one chain of AND operators La expresión con una AND El enlace tiene un incremento de 1. b := b1 AND b2 AND b3; \/\/+1: one more AND, but the number of chains of operators does not change La expresión tiene una más. AND . Pero al ser el mismo operador, el número de la cadena formada con operadores idénticos no cambia. b := b1 AND b2 OR b3; \/\/+2: one chain of AND operators and one chain of OR operators La expresión tiene una cadena de AND operadores y una cadena de OR operadores. Esto da como resultado un incremento de 2. b := b1 AND b2 OR b3 AND b4 AND b5; \/\/+3 El fragmento de código tiene un incremento de 3. b := b1 AND NOT b2 AND b3; \/\/+1: the unary NOT operator is not considered in the cognitive complexity El operador unario NOT no se considera en la complejidad cognitiva. Ejemplo: Otras declaraciones con incremento El texto estructurado tiene declaraciones y expresiones adicionales que cambian el flujo de control. Las siguientes afirmaciones se penalizan con un incremento de complejidad cognitiva: aNewLabel:\nx := MUX(i, a,b,c); \/\/+1 for MUX operator\ny := SEL(b, i,j); \/\/+1 for SEL operator\nJMP aNewLabel; \/\/+1 for JMP to label EXIT y RETURN Las declaraciones no aumentan la complejidad cognitiva. " }, 
{ "title" : "Métrica: DIT – Profundidad del árbol de herencia ", 
"url" : "_san_reference_metrics.html#UUID-c7e1c296-e321-f999-8ed7-9713ebdb50fc", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: DIT – Profundidad del árbol de herencia ", 
"snippet" : "DIT – Profundidad del árbol de herencia Categoría : Mantenibilidad Número de herencias hasta alcanzar un bloque de funciones que no extiende ningún otro bloque de funciones Ejemplo FUNCTION_BLOCK MyBaseFB \/\/ ... FUNCTION_BLOCK AChildFB EXTENDS MyBaseFB \/\/ ... FUNCTION_BLOCK AGrandChildFB EXTENDS ACh...", 
"body" : "DIT – Profundidad del árbol de herencia Categoría : Mantenibilidad Número de herencias hasta alcanzar un bloque de funciones que no extiende ningún otro bloque de funciones Ejemplo FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB tiene un DIT de 0 porque es en sí mismo un bloque de funciones que no extiende ningún otro bloque de funciones. Para AChildFB , el DIT es 1 porque se requiere un paso para llegar a MyBaseFB . AGrandChildFB tiene un DIT de 2: se necesita un paso para AChildFB y otro a MyBaseFB . " }, 
{ "title" : "Métrica: NOC – Número de niños ", 
"url" : "_san_reference_metrics.html#UUID-04314eaf-28e7-40ea-0aa9-e7f46e79bfa0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: NOC – Número de niños ", 
"snippet" : "NOC – Número de niños Categorías : Reutilizabilidad, Mantenibilidad Número de bloques de funciones que amplían el bloque de funciones básico dado. Los bloques de funciones que amplían indirectamente un bloque de funciones básico no se cuentan. Ejemplo FUNCTION_BLOCK MyBaseFB \/\/ ... FUNCTION_BLOCK AC...", 
"body" : "NOC – Número de niños Categorías : Reutilizabilidad, Mantenibilidad Número de bloques de funciones que amplían el bloque de funciones básico dado. Los bloques de funciones que amplían indirectamente un bloque de funciones básico no se cuentan. Ejemplo FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB tiene solo un (1) objeto hijo: AChildFB , que a su vez tiene un objeto secundario, AGrandChildFB . AGrandChildFB no tiene objetos secundarios. " }, 
{ "title" : "Métricas: RFC – Respuesta para clase ", 
"url" : "_san_reference_metrics.html#UUID-0fcfc138-e361-a392-6fbe-11240e7a6e2a", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métricas: RFC – Respuesta para clase ", 
"snippet" : "Respuesta para clase (RFC) Categorías : Mantenibilidad, Reutilización Número de POU, métodos o acciones diferentes que se llaman y, por lo tanto, generan una respuesta de la POU especificada en Unidad de programa Ejemplo \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR d,x,y : INT; END_VAR \/\/Implementation ...", 
"body" : "Respuesta para clase (RFC) Categorías : Mantenibilidad, Reutilización Número de POU, métodos o acciones diferentes que se llaman y, por lo tanto, generan una respuesta de la POU especificada en Unidad de programa Ejemplo \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR\n d,x,y : INT;\nEND_VAR\n\n\/\/Implementation\nx := METH(d+10);\ny := FUN(42, 0.815); \/\/Declaration FB1.METH\nMETHOD METH : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := FUN(CUBE(i), 3.1415); \/\/Declaration CUBE\nFUNCTION CUBE : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nCUBE := i*i*i; \/\/Declaration Function FUN\nFUNCTION FUN : INT\nVAR_INPUT\n a : INT;\n lr : LREAL;\nEND_VAR\n\n\/\/Implementation\nFUN := LREAL_TO_INT(lr*10)*a; Empezando con FUN y CUBE , estas funciones tienen un RFC de 0 porque ninguna de ellas llama a otras funciones, bloques de funciones o métodos para sus cálculos. FB1.METH usos FUN y CUBE , lo que resulta en un RFC de 2. El bloque de funciones FB1 se llama METH y FUN , lo que aumenta su RFC en 2. Para FB1 también hay que tener en cuenta su método METH. METH usa FUN y CUBE. FUN ya se ha agregado al RFC. Por lo tanto, sólo el uso de CUBE en METH aumenta el RFC para FB1 a 3 " }, 
{ "title" : "Métrica: CBO – Acoplamiento entre objetos ", 
"url" : "_san_reference_metrics.html#UUID-d98bd2a3-497b-920f-1f11-f4f38973066f", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: CBO – Acoplamiento entre objetos ", 
"snippet" : "CBO – Acoplamiento entre objetos Categorías : Mantenibilidad, Reutilización Límite superior predeterminado para la regla SA0179 correspondiente: 30 Número de otros bloques de funciones de los que se crean instancias y se utilizan en un bloque de funciones Es probable que un bloque de funciones con u...", 
"body" : "CBO – Acoplamiento entre objetos Categorías : Mantenibilidad, Reutilización Límite superior predeterminado para la regla SA0179 correspondiente: 30 Número de otros bloques de funciones de los que se crean instancias y se utilizan en un bloque de funciones Es probable que un bloque de funciones con un alto acoplamiento entre objetos participe en muchas tareas diferentes y, por lo tanto, viola el principio de responsabilidad única. Ejemplo \/\/ Declaration\nFUNCTION_BLOCK FB_Child EXTENDS FB_Base objects \/\/ +0 for EXTENDS\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i_fb1 : FB1; \/\/ +1 instantiated here\n i_fb2 : FB2; \/\/ +1 instantiated here\nEND_VAR\n\n\/\/Implementation\ni_fb3(); \/\/ +0 instantiated in FB_Base, no increment for call La extensión de un bloque de funciones no aumenta el acoplamiento entre objetos. i_fb3 se instancia en la implementación de FB_Base y pasó a FB_Child ( EXTENDS ). la llamada en FB_Child no aumenta el acoplamiento entre los objetos. La CBO de FB_Child es 2. " }, 
{ "title" : "Métrica: Complejidad de referencia (Elshof) ", 
"url" : "_san_reference_metrics.html#UUID-a43f74c1-523d-b649-00e5-788c653e5ea1", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Complejidad de referencia (Elshof) ", 
"snippet" : "Complejidad de referencia (Elshof) Categorías : Eficiencia, Mantenibilidad, Reutilización Complejidad del flujo de datos de una POU La complejidad de referencia se calcula según la siguiente fórmula: <número de variables utilizadas> \/ <número de accesos a variables> Sólo se consideran los accesos a ...", 
"body" : "Complejidad de referencia (Elshof) Categorías : Eficiencia, Mantenibilidad, Reutilización Complejidad del flujo de datos de una POU La complejidad de referencia se calcula según la siguiente fórmula: <número de variables utilizadas> \/ <número de accesos a variables> Sólo se consideran los accesos a variables en la parte de implementación de la POU. Ejemplo \/\/Declaration\nPROGRAM PRG\nVAR\n i, j : INT;\n k : INT := GVL.m;\n b, c : BOOL;\n myFB : FB;\nEND_VAR\n\n\/\/Implementation\nmyFB(paramA := b); \/\/ +3 accesses (myFB, paramA and b)\ni := j; \/\/ +2 accesses (i and j)\nj := GVL.d; \/\/ +2 accesses (j and GVL.d) Complejidad de referencia en los resultados del fragmento de código: 6 número de variables utilizadas \/ 7 número de accesos variables = 0,85 Precaución: c y k no se utilizan y, por lo tanto, no cuentan como \"variables utilizadas\". La asignación k : INT := GVL.m no se cuenta porque es parte de la declaración del programa. " }, 
{ "title" : "Métrica: Falta de Cohesión de Métodos – LCOM ", 
"url" : "_san_reference_metrics.html#UUID-068c2765-4709-d4e2-80b6-d173998195a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Falta de Cohesión de Métodos – LCOM ", 
"snippet" : "Falta de cohesión de métodos – LCOM Falta de cohesión de métodos – LCOM Categorías : Mantenibilidad, Reutilización La cohesión entre bloques de funciones, sus acciones, transiciones y métodos describe si acceden o no a las mismas variables. La falta de cohesión de los métodos describe cuán fuertemen...", 
"body" : "Falta de cohesión de métodos – LCOM Falta de cohesión de métodos – LCOM Categorías : Mantenibilidad, Reutilización La cohesión entre bloques de funciones, sus acciones, transiciones y métodos describe si acceden o no a las mismas variables. La falta de cohesión de los métodos describe cuán fuertemente están conectados entre sí los objetos de un bloque de funciones. Cuanto menor es la falta de cohesión, más fuerte es la conexión entre los objetos. Es probable que los bloques de funciones con una gran falta de cohesión participen en muchas tareas diferentes y, por lo tanto, violen el principio de responsabilidad única. La métrica se calcula según la siguiente fórmula: MAX(0, <número de pares de objetos sin cohesión> - <número de pares de objetos con cohesión>) Ejemplo \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\n a : BOOL;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,b : BOOL;\nEND_VAR\n\n\/\/Implementation\ni := 42;\n\/\/FB.ACT\ni:= 0; \/\/FB.METH Declaration\nMETHOD METH : BOOL\nVAR_INPUT\n\tc : BOOL;\nEND_VAR\n\n\/\/Implementation\nMETH := c;\ni := 1; \/\/FB.SecondMETH Declaration\nMETHOD SecondMETH : INT\nVAR_INPUT\nEND_VAR\n\n\/\/Implementation\nSecondMETH := SEL(c,3,4); Pares de objetos sin conexión (4 pares): FB, FB.ACT FB , FB.METH FB.ACT , FB.SecondMETH FB.METH , FB.SecondMETH Pares de objetos con conexión (2 pares): FB , FB.SecondMETH (ambos usan c ) FB.ACT , FB.METH (ambos usan i ) La tabla muestra qué variables conectan qué objetos del FB: pensión completa FB.ACT FB.METH FB.SecondMETH FB.SecondMETH c 0 0 . FB.METH 0 i . . FB.ACT 0 . . . FB - . . . " }, 
{ "title" : "Métrica: Número de sucursales de SFC ", 
"url" : "_san_reference_metrics.html#UUID-d74f2703-e85d-ed16-b335-69a4dfd4a8bd", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Número de sucursales de SFC ", 
"snippet" : "Número de sucursales de la SFC Categorías : Comprobabilidad, mantenibilidad Número de ramas alternativas y paralelas de una POU del lenguaje de implementación SFC (diagrama de funciones secuenciales) Ejemplo El fragmento de código anterior en SFC tiene 4 ramas: 3 ramas alternativas y 1 rama paralela...", 
"body" : "Número de sucursales de la SFC Categorías : Comprobabilidad, mantenibilidad Número de ramas alternativas y paralelas de una POU del lenguaje de implementación SFC (diagrama de funciones secuenciales) Ejemplo El fragmento de código anterior en SFC tiene 4 ramas: 3 ramas alternativas y 1 rama paralela " }, 
{ "title" : "Métrica: Número de pasos SFC ", 
"url" : "_san_reference_metrics.html#UUID-19d1353f-ebce-6c25-6214-7b3a97c92490", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referencia: Programación \/ Métrica \/ Métrica: Número de pasos SFC ", 
"snippet" : "Número de pasos SFC Categoría : Mantenibilidad Número de pasos en una POU en SFC (gráfico de funciones secuenciales) Sólo se cuentan los pasos que están contenidos en la POU programada en SFC. No se cuentan los pasos que se encuentran en las implementaciones de acciones o transiciones denominadas en...", 
"body" : "Número de pasos SFC Categoría : Mantenibilidad Número de pasos en una POU en SFC (gráfico de funciones secuenciales) Sólo se cuentan los pasos que están contenidos en la POU programada en SFC. No se cuentan los pasos que se encuentran en las implementaciones de acciones o transiciones denominadas en POU. Ejemplo El fragmento de código en SFC tiene 10 pasos. " }
]
$(document).trigger('search.ready');
});