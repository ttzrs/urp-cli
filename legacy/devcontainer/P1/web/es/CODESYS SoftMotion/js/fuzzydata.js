$(document).ready(function () {indexDict['es'] = [{ "title" : "CODESYS SoftMotion ", 
"url" : "_sm_start_page.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion ", 
"snippet" : "Con CODESYS SoftMotion , puede crear movimientos de PLC de manera eficiente. Esto va desde simples movimientos o levas de un solo eje hasta movimientos complejos en múltiples dimensiones. En particular, las aplicaciones que incluyen control de flujo y control de procesos además de la funcionalidad d...", 
"body" : "Con CODESYS SoftMotion , puede crear movimientos de PLC de manera eficiente. Esto va desde simples movimientos o levas de un solo eje hasta movimientos complejos en múltiples dimensiones. En particular, las aplicaciones que incluyen control de flujo y control de procesos además de la funcionalidad de movimiento están dentro del alcance de aplicación del CODESYS SoftMotion . Puedes descargar el CODESYS SoftMotion desde el  CODESYS Store International o el  CODESYS Store North America . Allí también encontrará la ficha técnica del producto. Ver también CODESYS SoftMotion en el Foro CODESYS " }, 
{ "title" : "Licencia ", 
"url" : "_sm_licensing.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Licencia ", 
"snippet" : "Además de los generales métricas de software con licencia , las métricas se definen para CODESYS SoftMotion que se comprueban durante la descarga. El SoftMotion las métricas se calculan durante la compilación y el valor actual se muestra en el editor solo después. Los valores determinados se refiere...", 
"body" : "Además de los generales métricas de software con licencia , las métricas se definen para CODESYS SoftMotion que se comprueban durante la descarga. El SoftMotion las métricas se calculan durante la compilación y el valor actual se muestra en el editor solo después. Los valores determinados se refieren a una aplicación. Cuando existen múltiples aplicaciones, los valores de las aplicaciones individuales se suman. Grupo Métrico Valor determinado Número de ejes hachas reales El valor de la métrica se define por el mayor valor de los ejes reales y los ejes virtuales utilizados. Ejemplo: Con 3 ejes reales y 4 ejes virtuales, el valor en la aplicación = 4. ejes virtuales Número de grupos de ejes e interpoladores CNC Grupos de ejes El valor de la métrica se define por la suma de grupos de ejes e interpoladores CNC. Ejemplo: Con 2 grupos de ejes y 2 interpoladores CNC, el valor en la aplicación = 4. Interpoladores CNC " }, 
{ "title" : "Componentes de CODESYS SoftMotion ", 
"url" : "_sm_components.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Componentes de CODESYS SoftMotion ", 
"snippet" : "CODESYS SoftMotion es un paquete de software que se utiliza como entorno de desarrollo y tiempo de ejecución para el control de movimiento. Se describe a continuación: Configuración de la unidad : La configuración de la unidad proporciona un editor para que establezca la estructura y la configuració...", 
"body" : "CODESYS SoftMotion es un paquete de software que se utiliza como entorno de desarrollo y tiempo de ejecución para el control de movimiento. Se describe a continuación: Configuración de la unidad : La configuración de la unidad proporciona un editor para que establezca la estructura y la configuración del hardware de la unidad mediante el CODESYS interfaz de usuario. En este momento, se crea una instancia de un bloque de funciones IEC para representar el variador. Este bloque de funciones se comunica automáticamente con los variadores sin esfuerzo adicional por parte del programador IEC. Es responsable de transmitir los datos actualizados. Para controlar los accionamientos, el programa IEC puede direccionar un accionamiento mediante los bloques de función del SoftMotion bibliotecas Alternativamente, también podría desarrollar sus propios bloques de funciones para este propósito. Los valores establecidos (para posición, velocidad, aceleración, etc.) son escritos cíclicamente por estos bloques de función. Nota la CODESYS SoftMotion Light producto es parte de la instalación estándar de CODESYS . Proporciona la capacidad de comandar los ejes. De este modo, CODESYS define solo la posición de destino y espera la respuesta del controlador de eje. El controlador de ejes es responsable de la planificación del movimiento. Un movimiento coordinado de múltiples ejes por CODESYS no es posible. editor de cámara : En el editor de levas, puede describir una leva gráficamente o mediante tablas. CODESYS genera a partir de esto una instancia global de una estructura de datos que describe la leva. Esto se pasa a la aplicación donde las POU correspondientes pueden acceder a él. editor CNC : En el editor CNC, puede generar movimientos multidimensionales. Puede crear la ruta CNC con un editor de texto (según DIN 66025) o con un editor gráfico. Como alternativa al editor de texto, también puede trabajar en una vista tabular simplificada. Configuración del grupo de ejes : Un grupo de ejes define las relaciones entre múltiples ejes dependientes mecánicamente que posicionan y orientan colectivamente una herramienta o placa de herramientas en el espacio. Con el configurador se selecciona y configura la cinemática a utilizar. Además, puede asignar los ejes de SoftMotion. El SM3_Basic biblioteca es una biblioteca básica para todos SoftMotion aplicaciones En concreto, contiene lo siguiente: Bloques de función PLCopen según el estándar PLCopen Con estos bloques de función, puede controlar los movimientos de un eje o los movimientos maestro \/ esclavo de dos ejes (leva eléctrica, accionamientos eléctricos). FB adicionales que no están cubiertos por las funcionalidades de PLCopen Funciones de ayuda: por ejemplo, para el manejo de archivos o para mensajes de error El SM3_CNC biblioteca se basa en la SM3_Basic Biblioteca. Además de los bloques de funciones para transformaciones cinemáticas, proporciona todas las POU necesarias para generar, ejecutar y mostrar el movimiento CNC. También proporciona bloques de funciones para el preprocesamiento y la reconstrucción de rutas. El SM3_Robotics La biblioteca contiene bloques de funciones según PLCopen Parte 4 para robótica y bloques de funciones adicionales. el incluido SM3_Transformations biblioteca contiene las transformaciones cinemáticas admitidas. El interfaz de la unidad es parte del SM3_Basic biblioteca y es responsable de la comunicación entre el programa IEC y los variadores. Para las unidades admitidas, CODESYS SoftMotion proporciona bibliotecas que implementan esta interfaz de unidad. Consulte también las descripciones de los ejemplos de aplicación. " }, 
{ "title" : "Uso de los controladores CODESYS RTE V3 y CODESYS WIN V3 ", 
"url" : "_sm_rtev3_winv3.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Uso de los controladores CODESYS RTE V3 y CODESYS WIN V3 ", 
"snippet" : "En CODESYS Development System SP20 y superior, el SoftMotion controladores CODESYS SoftMotion RTE V3 y CODESYS SoftMotion Win La versión 3 ya no está disponible. CODESYS Control RTE V3 y CODESYS Control Win Ahora se utilizan los controladores V3. Los Comando: Habilitar el comando se usa para convert...", 
"body" : "En CODESYS Development System SP20 y superior, el SoftMotion controladores CODESYS SoftMotion RTE V3 y CODESYS SoftMotion Win La versión 3 ya no está disponible. CODESYS Control RTE V3 y CODESYS Control Win Ahora se utilizan los controladores V3. Los Comando: Habilitar el comando se usa para convertir el controlador estándar en un SoftMotion controlador. " }, 
{ "title" : "SoftMotion con procesadores multinúcleo ", 
"url" : "_sm_multicore_hint.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ SoftMotion con procesadores multinúcleo ", 
"snippet" : "Al distribuir las tareas de movimiento en varios núcleos de procesador, se pueden activar más ejes o grupos de ejes mediante SoftMotion . Como resultado, las tareas de computación intensiva, como el preprocesamiento de rutas CNC o la planificación de rutas robóticas para movimientos de CP, se pueden...", 
"body" : "Al distribuir las tareas de movimiento en varios núcleos de procesador, se pueden activar más ejes o grupos de ejes mediante SoftMotion . Como resultado, las tareas de computación intensiva, como el preprocesamiento de rutas CNC o la planificación de rutas robóticas para movimientos de CP, se pueden cambiar a otro núcleo de procesador. Entonces hay más tiempo para otras tareas en la tarea del autobús. El hecho de que la potencia de cálculo del controlador de un solo núcleo sea insuficiente se demuestra en el caso de la robótica por la inexplicable disminución de la velocidad de trayectoria. Requisitos del sistema SM V4.5.1.0 o superior Compilador V3.5.12.0 o superior Sistema de tiempo de ejecución compatible con multinúcleo Uso Robótica y CNC: establezca las tareas de planificación y bus en diferentes núcleos de procesador Cuando utilice diferentes sistemas de bus, establezca las tareas de bus individuales en diferentes núcleos de procesador Cuando utilice varias tareas y varios núcleos de procesador, tenga en cuenta lo siguiente: Los bloques de funciones de la tarea de planificación del CNC pueden obtener una nueva ventaja en el Execute ingresa solo en estados específicos del interpolador ( iStatus salida). Esto también se aplica a un solo núcleo IPO_UNKNOWN IPO_ESPERA IPO_FINISHED IPO_INIT (solo para el primer inicio, no para reiniciar) Las tareas de bus de ejes interdependientes (grupo de ejes, leva y cinemática CNC) deben ejecutarse en el mismo núcleo de procesador. " }, 
{ "title" : "CODESYS SoftMotion Drives ", 
"url" : "_sm_f_drive_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Configuración de la unidad SoftMotion ", 
"url" : "_sm_f_drive_configuration.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuración de la unidad SoftMotion ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Descripción general ", 
"url" : "_sm_overview_drive_configuration.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuración de la unidad SoftMotion \/ Descripción general ", 
"snippet" : "La interfaz de la unidad SoftMotion es una interfaz estandarizada que se utiliza para vincular, configurar y direccionar el hardware de la unidad dentro de un programa IEC. Al asignar hardware diferente a una interfaz, puede intercambiar unidades fácilmente y reutilizar programas IEC. La interfaz ac...", 
"body" : "La interfaz de la unidad SoftMotion es una interfaz estandarizada que se utiliza para vincular, configurar y direccionar el hardware de la unidad dentro de un programa IEC. Al asignar hardware diferente a una interfaz, puede intercambiar unidades fácilmente y reutilizar programas IEC. La interfaz acopla los variadores al mapeo de E\/S y es responsable de actualizar y transmitir los datos de movimiento requeridos al control del variador. La interfaz del variador consta de los siguientes componentes: Descripción del dispositivo del SoftMotion dispositivos a su representación en el árbol de dispositivos Bibliotecas a las que se hace referencia en la descripción del dispositivo que amplían o sobrecargan los bloques de funciones básicas de AXIS_REF_SM3 según los requisitos de los tipos de accionamiento específicos Bibliotecas que contienen bloques de funciones para lectura y escritura acíclica de datos para envolver funciones estándar para el controlador de bus de campo. Si usas un SoftMotion PLC, como CODESYS SoftMotion Win , las bibliotecas base se vinculan automáticamente en el Administrador de bibliotecas. Este tipo de controladores proporcionan una Grupo de ejes generales SoftMotion . Aquí es donde puede insertar unidades de disco libres. " }, 
{ "title" : "Unidades de accionamiento acopladas ", 
"url" : "_sm_inserting_connected_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuración de la unidad SoftMotion \/ Unidades de accionamiento acopladas ", 
"snippet" : "Los accionamientos acoplados pertenecen a un dispositivo que representa el accionamiento dentro de la topología de bus de campo. Los símbolos de estos convertidores tienen una pequeña marca que indica el tipo de bus de campo correspondiente. Por ejemplo, cada servoaccionamiento estándar está conecta...", 
"body" : "Los accionamientos acoplados pertenecen a un dispositivo que representa el accionamiento dentro de la topología de bus de campo. Los símbolos de estos convertidores tienen una pequeña marca que indica el tipo de bus de campo correspondiente. Por ejemplo, cada servoaccionamiento estándar está conectado al controlador mediante un bus de campo. Al usar unidades, CODESYS SoftMotion proporciona descripciones de dispositivos específicas para el maestro de bus de campo (sufijo \"_SoftMotion\"). Estos tienen parámetros básicos optimizados para la unidad. Para unidades que se utilizan con CODESYS SoftMotion , la manipulación del módulo debe estar desactivada en el accionamiento. El manejo del módulo se realiza mediante CODESYS SoftMotion en el controlador. Si es posible, el rango de recorrido máximo debe establecerse en 32 bits. Adición de un dispositivo de accionamiento acoplado (EtherCAT) Requisito: se ha insertado un controlador compatible con SoftMotion en el proyecto. Selecciona el SoftMotion controlador en el árbol de dispositivos. En el menú contextual, haga clic en Añadir dispositivo . En el Añadir dispositivo cuadro de diálogo, seleccione el Buses de campo → EtherCAT → Maestro → EtherCAT Maestro SoftMotion dispositivo. Haga clic en el Añadir dispositivo botón. El dispositivo se agrega al árbol de dispositivos. El Añadir dispositivo el cuadro de diálogo permanece abierto. Seleccione el dispositivo que acaba de agregar al árbol de dispositivos. En el Añadir dispositivo cuadro de diálogo, seleccione un esclavo SoftMotion ( Buses de campo → EtherCAT → Esclavo → <SoftMotion drive> ). Haga clic en el Añadir dispositivo botón. El dispositivo se agrega al árbol de dispositivos. Al hacer doble clic en el dispositivo, se abre el editor de dispositivos correspondiente. " }, 
{ "title" : "Eje del codificador ", 
"url" : "_sm_encoder_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuración de la unidad SoftMotion \/ Eje del codificador ", 
"snippet" : "Los ejes del codificador se utilizan para convertir los valores del codificador en un eje SoftMotion que se puede utilizar como eje maestro para MC_CamIn , MC_GearIn , y otros bloques de funciones maestro\/esclavo. Los ejes del codificador pueden representar codificadores adicionales de las unidades ...", 
"body" : "Los ejes del codificador se utilizan para convertir los valores del codificador en un eje SoftMotion que se puede utilizar como eje maestro para MC_CamIn , MC_GearIn , y otros bloques de funciones maestro\/esclavo. Los ejes del codificador pueden representar codificadores adicionales de las unidades de accionamiento. En este caso, se configuran como ejes codificadores especiales en los dispositivos de bus de campo del árbol de dispositivos. Como alternativa, los codificadores gratuitos están Piscina General Axis también podría usar entradas analógicas como ejes de codificación. Para obtener más información, consulte: Codificador gratuitoPropiedades Al igual que los ejes lógicos, los ejes del codificador son de «solo lectura». Solo proporcionan los valores de posición y velocidad. No se les puede ordenar ningún movimiento. El estado del eje de los ejes del codificador es siempre standstill . Este es el estado de PLCopen for Motion Control Part 1 que mejor se adapta. Según el gráfico de estado, este estado significa que el eje está listo y no hay ningún error. Además, ninguno de los movimientos ordenados por el PLC está activo en el eje Tenga en cuenta que antes CODESYS SoftMotion en la versión 4.18.0.0, los ejes del codificador estaban en el estado power_off . Sin embargo, cuando MC_Power los llamaron, estaban en un estado standstill . La posición cero del eje del codificador se puede compensar con MC_SetPosition . Los bloques de funciones maestro\/esclavo siempre utilizan los valores reales del eje del codificador. Se puede usar un eje lógico por debajo del eje del codificador para compensar el tiempo muerto. Cuando se utilizan ejes codificadores, no es necesario llamar MC_Power , y no hace ninguna diferencia en el comportamiento del eje del codificador para CODESYS SoftMotion versión 4.18.0.0 y superior. " }, 
{ "title" : "Inserción de unidades de accionamiento libres ", 
"url" : "_sm_f_free_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuración de la unidad SoftMotion \/ Inserción de unidades de accionamiento libres ", 
"snippet" : "Las unidades de accionamiento libres no están acopladas permanentemente con otros dispositivos en el árbol de dispositivos. Se insertan en el árbol de dispositivos a continuación. SoftMotion Piscina de propulsión general ....", 
"body" : "Las unidades de accionamiento libres no están acopladas permanentemente con otros dispositivos en el árbol de dispositivos. Se insertan en el árbol de dispositivos a continuación. SoftMotion Piscina de propulsión general . " }, 
{ "title" : "Control de conducción 'Drive_PosControl' ", 
"url" : "_sm_drive_controller_drive_poscontrol.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuración de la unidad SoftMotion \/ Inserción de unidades de accionamiento libres \/ Control de conducción 'Drive_PosControl' ", 
"snippet" : "Con el Drive_PosControl control de accionamiento, puede dejar que el control de posición de un eje de CODESYS seguir corriendo El requisito es un dispositivo que esté controlado por la velocidad establecida y devuelva su posición actual. Por ejemplo, puede ser un dispositivo controlado por velocidad...", 
"body" : "Con el Drive_PosControl control de accionamiento, puede dejar que el control de posición de un eje de CODESYS seguir corriendo El requisito es un dispositivo que esté controlado por la velocidad establecida y devuelva su posición actual. Por ejemplo, puede ser un dispositivo controlado por velocidad (convertidor de frecuencia) con retroalimentación de posición. Adición de un control de conducción Requisito: Hay un controlador SoftMotion insertado en el proyecto. En el árbol de dispositivos, seleccione SoftMotion Grupo del Eje General . En el menú contextual, haga clic en Añadir dispositivo . En el Añadir dispositivo cuadro de diálogo, seleccione el Accionamientos SoftMotion → accionamientos controlados por posición → SMC_Drive_PosControl dispositivo. Haga clic en el Añadir dispositivo botón. El dispositivo se agrega al árbol de dispositivos. Al hacer doble clic en el dispositivo, se abre el editor de dispositivos correspondiente. Para más información, ver: Pestaña: General" }, 
{ "title" : "Unidad lógica ", 
"url" : "_sm_drive_controller_logical_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuración de la unidad SoftMotion \/ Inserción de unidades de accionamiento libres \/ Unidad lógica ", 
"snippet" : "Puede agregar una unidad lógica a cualquier tipo de unidad de disco. El eje de la unidad lógica refleja el movimiento de su eje maestro mientras representa una instancia independiente. Esto permite la ejecución de las siguientes instrucciones en él sin afectar el eje maestro. MC_SetPosition : Establ...", 
"body" : "Puede agregar una unidad lógica a cualquier tipo de unidad de disco. El eje de la unidad lógica refleja el movimiento de su eje maestro mientras representa una instancia independiente. Esto permite la ejecución de las siguientes instrucciones en él sin afectar el eje maestro. MC_SetPosition : Establecer la posición en un valor definido (ejemplo: 0) MC_TouchProbe : Guardar la posición actual del eje de una señal de disparo MC_AbortTrigger : Desactivación de un sensor previamente activado con MC_TouchProbe Una aplicación sería una cinta transportadora que atraviesa varias estaciones de procesamiento. La posición del componente se detecta mediante una señal externa (por ejemplo, una barrera de luz) y el eje se ajusta a una posición definida (función de palpador). La unidad lógica proporciona la capacidad de filtrar la señal. Por lo tanto, la unidad lógica también se puede utilizar con un codificador que emite una señal de ruido. Adición de una unidad lógica Requisito: Hay un controlador SoftMotion insertado en el proyecto. Seleccione una unidad de accionamiento en el árbol de dispositivos. En el menú contextual, haga clic en Añadir dispositivo . En el Añadir dispositivo cuadro de diálogo, seleccione el Unidades SoftMotion → unidades virtuales → SM_Drive_Logical dispositivo. Haga clic en el Añadir dispositivo botón. El dispositivo se agrega al árbol de dispositivos. Al hacer doble clic en el dispositivo, se abre el editor de dispositivos correspondiente. " }, 
{ "title" : "unidad virtual ", 
"url" : "_sm_drive_controller_virtual_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuración de la unidad SoftMotion \/ Inserción de unidades de accionamiento libres \/ unidad virtual ", 
"snippet" : "Las unidades virtuales son unidades simuladas en software. Con esto, puede probar sus programas sin hardware conectado o implementar funcionalidades extendidas. Este tipo de funciones incluyen, por ejemplo, el control de la anulación del movimiento del eje y el método cartesiano manual de un robot e...", 
"body" : "Las unidades virtuales son unidades simuladas en software. Con esto, puede probar sus programas sin hardware conectado o implementar funcionalidades extendidas. Este tipo de funciones incluyen, por ejemplo, el control de la anulación del movimiento del eje y el método cartesiano manual de un robot en un espacio. Para más información, ver: Control de una unidad de levas con un eje de tiempo virtualLas unidades virtuales simulan una unidad física utilizando las posiciones establecidas de los ciclos anteriores para calcular los valores reales de posición, velocidad y aceleración al inicio de un ciclo. Funciones que requieren un disco físico, como MC_TouchProbe en la unidad o mediante el uso de SMC_SetControllerMode , no son compatibles. Adición de una unidad virtual Requisito: Hay un controlador SoftMotion insertado en el proyecto. En el árbol de dispositivos, seleccione SoftMotion Grupo del Eje General . En el menú contextual, haga clic en Añadir dispositivo . En el Añadir dispositivo cuadro de diálogo, seleccione el Unidades SoftMotion → unidades virtuales → SM_Drive_Virtual dispositivo. Haga clic en el Añadir dispositivo botón. El dispositivo se agrega al árbol de dispositivos. Al hacer doble clic en el dispositivo, se abre el editor de dispositivos correspondiente. " }, 
{ "title" : "Codificador gratuito ", 
"url" : "_sm_drive_controller_free_encoder.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuración de la unidad SoftMotion \/ Inserción de unidades de accionamiento libres \/ Codificador gratuito ", 
"snippet" : "Utilizar el Codificador gratuito para integrar un codificador que no está acoplado permanentemente a E\/S o hardware. Agregar un codificador gratuito En el árbol de dispositivos, seleccione SoftMotion Grupo del Eje General . En el menú contextual, haga clic en Añadir dispositivo . En el Añadir dispos...", 
"body" : "Utilizar el Codificador gratuito para integrar un codificador que no está acoplado permanentemente a E\/S o hardware. Agregar un codificador gratuito En el árbol de dispositivos, seleccione SoftMotion Grupo del Eje General . En el menú contextual, haga clic en Añadir dispositivo . En el Añadir dispositivo cuadro de diálogo, seleccione el Unidades SoftMotion → Codificadores libres → SMC_FreeeEncoder dispositivo. Haga clic en el Añadir dispositivo botón. El dispositivo se agrega al árbol de dispositivos. Abra el codificador en el Editor . Adapte la configuración al hardware y configure el ancho de bits y la escala. Asigne el valor de entrada del codificador al <FREE_ENCODER_AXIS>.diEncoderPosition variable. Esto es posible ya sea como código IEC o mapeando la memoria de los datos de entrada. Durante la inicialización del bus de campo, esta entrada puede generar valores no válidos. Puedes usar el bDelayActivation input para deshabilitar la evaluación de la entrada hasta que esté disponible un valor válido. Ahora puede usar el codificador como una unidad. Para obtener más información, consulte: Eje del codificador" }, 
{ "title" : "Creación de ejes mediante programación ", 
"url" : "_sm_programmatic_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuración de la unidad SoftMotion \/ Inserción de unidades de accionamiento libres \/ Creación de ejes mediante programación ", 
"snippet" : "Las siguientes unidades de disco libre también se pueden crear mediante programación: Hachas SMC_VIRTUAL_AXIS Crea un eje virtual sin tener que añadirlo al árbol de dispositivos Para obtener más información, consulte lo siguiente: unidad virtualEje lógico SMC Crea un eje lógico sin tener que añadirl...", 
"body" : "Las siguientes unidades de disco libre también se pueden crear mediante programación: Hachas SMC_VIRTUAL_AXIS Crea un eje virtual sin tener que añadirlo al árbol de dispositivos Para obtener más información, consulte lo siguiente: unidad virtualEje lógico SMC Crea un eje lógico sin tener que añadirlo al árbol de dispositivos. Para obtener más información, consulte lo siguiente: Unidad lógicaCodificador SMC_Free Crea un eje de codificación sin tener que añadirlo al árbol de dispositivos Para obtener más información, consulte lo siguiente: Codificador gratuito" }, 
{ "title" : "Unidades compatibles ", 
"url" : "_sm_drives_supported_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Unidades compatibles ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Unidades compatibles: EtherCAT ", 
"url" : "_sm_drives_supported_drives_ethercat.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Unidades compatibles \/ Unidades compatibles: EtherCAT ", 
"snippet" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control...", 
"body" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control Techniques Mentor Control Techniques Unidrive M Copley Accelnet Danfoss ISD 520 Delta ASDA A2 Delta ASDA A3 Delta ASDA B3 Delta R1-EC5621 Festo CMMP EtherCAT Controlador CiA 402 genérico: consulte Configuración del eje CiA402 genéricoGenerischer SoE Treiber (auch für mehrachsige Antriebe) Hitachi ADV series Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB H6 KEBA KeDrive D3 Kollmorgen AKD Kollmorgen AKD-N\/C Kollmorgen MKD-N\/C Kollmorgen AKD2G Kollmorgen KED Metronix ARS 2000-Serie Mitsubishi Melservo MR-J5 Mitsubishi Melservo MR-JET Omron G5 Panasonic MINAS A5B Panasonic MINAS A6B Panasonic MINAS A6 MultiDrive Parker compax3 Parker SBC Parker PSD Sanyo Denki RS2 Schneider Electric Lexium32 Schneider Electric Lexium32i Servotronix CDHD Stäubli uniVAL Stöber Posidrive Stöber SD6 Stöber SI6\/SC6 WEG SCA06 Yaskawa Sigma7 series " }, 
{ "title" : "Unidades compatibles: CAN ", 
"url" : "_sm_drives_supported_drives_can.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Unidades compatibles \/ Unidades compatibles: CAN ", 
"snippet" : "PUEDE Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP Controlador CiA 402 genérico: consulte Configuración del eje CiA402 genéricoInfranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schne...", 
"body" : "PUEDE Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP Controlador CiA 402 genérico: consulte Configuración del eje CiA402 genéricoInfranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schneider Electric Lexium05 Schneider Electric Lexium23 Schneider Electric Lexium28 Schneider Electric Lexium32 Schneider Electric Lexium32i Schneider Electric SD-3 " }, 
{ "title" : "Casos de uso ", 
"url" : "_sm_f_use_cases_drive_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casos de uso ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Casos de uso estándar ", 
"url" : "_sm_special_use_cases.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casos de uso \/ Casos de uso estándar ", 
"snippet" : "El SM3_Basic La biblioteca contiene bloques de funciones de orden superior que no interactúan con el accionamiento a través de la interfaz estándar de valor real\/configurado. Estos bloques de funciones proporcionan comandos o cambian la configuración del variador al leer o escribir los parámetros de...", 
"body" : "El SM3_Basic La biblioteca contiene bloques de funciones de orden superior que no interactúan con el accionamiento a través de la interfaz estándar de valor real\/configurado. Estos bloques de funciones proporcionan comandos o cambian la configuración del variador al leer o escribir los parámetros de la instancia de AXIS_REF_SM3 . " }, 
{ "title" : "Reiniciar una unidad ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_0e9f93f91e8d4c6dc0a8640e01d50c94", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casos de uso \/ Casos de uso estándar \/ Reiniciar una unidad ", 
"snippet" : "Si cambiaste los parámetros de la unidad durante el tiempo de ejecución, tendrás que reinicializar la unidad. Ejemplo: cambie el factor de escalado o el período del módulo de las unidades rotativas. Al llamar al SMC3_ReinitDrive bloque de función con un borde ascendente en Execute entrada, el wCommu...", 
"body" : "Si cambiaste los parámetros de la unidad durante el tiempo de ejecución, tendrás que reinicializar la unidad. Ejemplo: cambie el factor de escalado o el período del módulo de las unidades rotativas. Al llamar al SMC3_ReinitDrive bloque de función con un borde ascendente en Execute entrada, el wCommuncationState se restablece el parámetro de la unidad y se repite el proceso de inicio completo de la unidad. La reinicialización tiene que esperar hasta que el eje alcance el estado requerido SMC_COMSTATE_BASE_COM_INITIALIZATION o mas alto. De lo contrario, el error saldrá SMC_RAG_ERROR_AXIS_NO_INITIALIZED . Si se interrumpe la comunicación de un bus de campo subordinado, ya no es necesaria la reinicialización explícita para CODESYS SoftMotion versión 4.18.0.0 y superior. El eje se reinicia automáticamente tan pronto como se restablece la comunicación del bus de campo. Antes de la versión 4.18.0.0, una vez interrumpida la comunicación del bus de campo, se realizaba SMC3_ReinitDrive era necesario (error con SMC_DI_GENERAL_COMMUNICATION_ERROR ) tan pronto como se restablezca la comunicación del bus de campo. El comportamiento anterior se puede restaurar configurando el AutoRestart entrada del SMC_AxisChangeSettings bloque de funciones para SMC_AXIS_AUTORESTART_MODE.OFF . " }, 
{ "title" : "Encendido y apagado de una unidad ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_bd45abb41e8d4c6dc0a8640e01589872", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casos de uso \/ Casos de uso estándar \/ Encendido y apagado de una unidad ", 
"snippet" : "El bRegulatorOn y bDriveStart parámetros de la AXIS_REF_SM3 El bloque de funciones controla el nivel de rendimiento y la desaceleración de un variador. El acceso se realiza mediante el MC_Power bloque de funciones Para liberar la etapa de salida, debe configurar el bRegulatorOn parámetro de la MC_Po...", 
"body" : "El bRegulatorOn y bDriveStart parámetros de la AXIS_REF_SM3 El bloque de funciones controla el nivel de rendimiento y la desaceleración de un variador. El acceso se realiza mediante el MC_Power bloque de funciones Para liberar la etapa de salida, debe configurar el bRegulatorOn parámetro de la MC_Power bloque de funciones El convertidor informa del estado actual de este proceso a través del bRegulatorRealState producción. Si es compatible con la unidad, un bRegulatorOn reset durante el movimiento desactivará inmediatamente el par. En este caso, el bloque de funciones informa de un error y establece los ejes en el errorstop Expresar. El bDriveStart La variable determina si se permite o no que la unidad se mueva. El estado actual de este parámetro se encuentra en bDriveStartRealState . Si es compatible con la unidad, un bDriveStart el restablecimiento de parámetros desacelera el accionamiento con la rampa configurada (\"QuickStop\") durante el movimiento. A continuación, el accionamiento se detiene en la posición alcanzada durante el tiempo establecido en bRegulatorOn . El eje permanece en el stopping mientras el mecanismo \"QuickStop\" esté activo ( bDriveStart entrada = FALSO). Si la unidad ha sido movida por un bloque de funciones anteriormente, ahora mostrará CommandAborted . Esto no se aplica a la MC_Stop bloque de funciones que informa de un error y establece los ejes en el errorstop Expresar. " }, 
{ "title" : "Manejo de frenos mecánicos ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_6670a1571e8d4c6ec0a8640e01f5eecb", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casos de uso \/ Casos de uso estándar \/ Manejo de frenos mecánicos ", 
"snippet" : "Si es compatible con la unidad, el eBrakeControl La variable se puede configurar o restablecer mediante el SMC3_BrakeControl bloque de funciones Son posibles tres modos diferentes. SMC3_BrakeSetState SMC_BRAKE_AUTO : El accionamiento controla el estado del freno. SMC_BRAKE_OPEN : El freno está abier...", 
"body" : "Si es compatible con la unidad, el eBrakeControl La variable se puede configurar o restablecer mediante el SMC3_BrakeControl bloque de funciones Son posibles tres modos diferentes. SMC3_BrakeSetState SMC_BRAKE_AUTO : El accionamiento controla el estado del freno. SMC_BRAKE_OPEN : El freno está abierto. SMC_BRAKE_CLOSE : El freno está cerrado. El bBrakeClosedRealState La variable informa el estado actual del freno. Desde el punto de vista de SoftMotion , el control, así como el estado del freno mecánico, no depende del estado del accionamiento o del movimiento de marcha. " }, 
{ "title" : "Cambiar el modo del mando ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_959f85271e8d4c6ec0a8640e01ed4fcb", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casos de uso \/ Casos de uso estándar \/ Cambiar el modo del mando ", 
"snippet" : "Con el Modo SMC_SetController bloque de funciones, puedes cambiar entre los diferentes modos del controlador. byControllerMode y byRealControllerMode parámetros de AXIS_REF_SM3 representan el modo deseado y el modo actual del controlador. Valores posibles SMC_nocontrol SoftMotion no envía datos cícl...", 
"body" : "Con el Modo SMC_SetController bloque de funciones, puedes cambiar entre los diferentes modos del controlador. byControllerMode y byRealControllerMode parámetros de AXIS_REF_SM3 representan el modo deseado y el modo actual del controlador. Valores posibles SMC_nocontrol SoftMotion no envía datos cíclicos al variador. Esto hace posible controlar el accionamiento de otras maneras. SMC_torque Control de par\/fuerza SMC_velocity control de velocidad SMC_position , Control de posición Tras escribir el byControllerMode variables, se comprueba el modo actual hasta que coincida con el modo de controlador deseado. El bloque de funciones calcula los valores establecidos hasta que la unidad confirme el nuevo modo. Tan pronto como la unidad confirme el nuevo modo, bDone la salida está configurada y SMC_SetControllerMode ya no escribe los valores establecidos. Esto debe hacerse usando otros bloques de funciones. Ejemplo: El bDone la salida está conectada al Execute entrada de un bloque de funciones, como MC_MoveVelocity , MC_MoveAbsolute , o MC_Halt . De lo contrario, el eje se detiene inmediatamente después de cambiar el modo. Tenga en cuenta que el tiempo muerto se utiliza para calcular la posición establecida. Para obtener más información, consulte lo siguiente: Valores reales, valores establecidos y tiempo muerto. " }, 
{ "title" : "Homing (controlado por accionamiento) ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_7fa66d251e8d4c6fc0a8640e00782f3b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casos de uso \/ Casos de uso estándar \/ Homing (controlado por accionamiento) ", 
"snippet" : "En SoftMotion , hay dos formas de hacer referencia a una unidad: Referenciado por un controlador en el PLC: Este referenciado se realiza llamando al SMC_Homing bloque de funciones La señal de referencia debe ser parte del mapeo de E\/S de la unidad de control. En el momento de la referenciación, el a...", 
"body" : "En SoftMotion , hay dos formas de hacer referencia a una unidad: Referenciado por un controlador en el PLC: Este referenciado se realiza llamando al SMC_Homing bloque de funciones La señal de referencia debe ser parte del mapeo de E\/S de la unidad de control. En el momento de la referenciación, el accionamiento permanece en el modo de control \"control de posición\". En general, este método no es particularmente preciso porque la detección de la posición (cuando el interruptor de referencia está activado) se basa en las posiciones actuales obtenidas por el variador. Como resultado, la precisión está limitada por el ciclo de comunicación. Referenciado por un controlador en el variador: El interruptor de referencia está cableado al variador. Su posición se detecta más rápido y con mayor precisión. Durante la ruta de referencia controlada por el variador, el variador está en otro modo de control, en el que el variador está controlado por procesos internos y no sigue los valores establecidos de la unidad de control. Cuando finaliza la ruta de referencia, el variador se restablece a su modo de control original. El MC_HOME  El bloque de funciones inicia la ruta de referencia controlada por el variador configurando fReference y bStartReference . Además, el estado de AXIS_REF_SM3 ( wState ) se establece en homing . Cuando el variador pasa a la ruta de referencia (lo que significa que ya no sigue los valores especificados por la unidad de control), el variador establece el parámetro en TRUE . Para mostrar el final de la ruta de referencia, el controlador establece los valores de bStartReference y bStartReferenceRealState a FALSE . " }, 
{ "title" : "enganche ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_index_14", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casos de uso \/ Casos de uso estándar \/ enganche ", 
"snippet" : "Puede detectar la posición de un eje de muchas formas, según las funciones de accionamiento que admite el accionamiento: El accionamiento detecta la posición del eje por sí mismo (integrado o activando un sensor externo). Debido a que la posición real es transferida por el propio variador, el tiempo...", 
"body" : "Puede detectar la posición de un eje de muchas formas, según las funciones de accionamiento que admite el accionamiento: El accionamiento detecta la posición del eje por sí mismo (integrado o activando un sensor externo). Debido a que la posición real es transferida por el propio variador, el tiempo de transferencia de la señal es mínimo y preciso. La posición actual del eje se determina independientemente del accionamiento y se transfiere al controlador a través de una entrada. La latencia de la entrada del controlador y el ciclo de aplicación hacen que este método sea menos preciso. Cuando se transfiere la posición del accionamiento en sí, se procesa directamente en la aplicación normalmente por el controlador respectivo dependiendo del fabricante. Para determinar la posición de este tipo de eje, puede utilizar el MC_TouchProbe bloque de funciones Permite el registro de la posición del eje en un disparador configurable y dentro de una ventana de posición. Si la posición no es transferida por el accionamiento, entonces tiene que pasarse al controlador de dispositivo del accionamiento, por ejemplo, para el control. Para más información, ver: Control de posición en el controlador con SM_Drive_PosControl" }, 
{ "title" : "Persistencia de una posición del eje ", 
"url" : "_sm_storing_axis_position_persistently.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casos de uso \/ Persistencia de una posición del eje ", 
"snippet" : "Un eje que tenga un codificador absoluto puede guardar una posición para que conserve su posición anterior después de reiniciar el controlador. La localización no es necesaria. El SMC3_PersistPosition y SMC3_PersistPositionLogical bloques de funciones proporcionan la funcionalidad para la operación ...", 
"body" : "Un eje que tenga un codificador absoluto puede guardar una posición para que conserve su posición anterior después de reiniciar el controlador. La localización no es necesaria. El SMC3_PersistPosition y SMC3_PersistPositionLogical bloques de funciones proporcionan la funcionalidad para la operación de guardar. Los datos necesarios se guardan en SMC3_PersistPosition_Data y SMC3_PersistPositionLogical_Data . El bPositionStored la salida indica si el contenido de PersistentData han cambiado. Esto ocurre en diferentes momentos según el tipo de persistencia. El rango de valores que conserva el codificador debe configurarse en SMC_PersistPosition.maxPersistedValue entrada. Para los codificadores de varias vueltas, el valor se establece 16#FFFFFFFFFF . Para un codificador de 12 bits de una sola vuelta, por ejemplo, el valor se establece en 2^12 = 4096 Para más información, ver: Persistencia de datos La instancia se hace persistente por medio de una declaración como VAR_PERSISTENT o el administrador de persistencia del compositor de la aplicación. Persistencia de la posición del eje de un eje lógico Requisito: El eje es lógico. Usa el SMC3_PersistPositionLogical bloque de función para hacer que la posición del eje lógico sea persistente. Esto solo funciona si la posición del eje físico superior se hizo persistente. La posición de un eje virtual no se puede hacer persistente mediante estos FB Crea una instancia del SMC3_PersistPositionLogical bloque de funciones para el eje. ppl: SM3_BASIC.SMC3_PersistPositionLogical; Instanciar una estructura de datos persistente de la SMC3_PersistPositionLogical_Data escribe. ppl_Data: SMC3_PersistPositionLogical_Data; Amplíe el programa de la tarea de movimiento para que una llamada del SMC3_PersistPositionLogical se implementa la instancia y los datos persistentes de tipo SMC3_PersistPositionLogical_Data se le pasa. " }, 
{ "title" : "Persistencia de la posición del eje de un encoder absoluto multivuelta con eje físico ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_49c53944c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casos de uso \/ Persistencia de una posición del eje \/ Persistencia de la posición del eje de un encoder absoluto multivuelta con eje físico ", 
"snippet" : "Requisito: El eje dispone de un encóder absoluto multivueltas. Utilizar el SMC3_PersistPosition FB para hacer persistente la posición del eje físico. El programa respectivo se ejecuta en la tarea de movimiento. Crea una instancia del SMC3_PersistPosition bloque de funciones para el eje. pp: SM3_BASI...", 
"body" : "Requisito: El eje dispone de un encóder absoluto multivueltas. Utilizar el SMC3_PersistPosition FB para hacer persistente la posición del eje físico. El programa respectivo se ejecuta en la tarea de movimiento. Crea una instancia del SMC3_PersistPosition bloque de funciones para el eje. pp: SM3_BASIC.SMC3_PersistPosition; Instanciar una estructura de datos persistente de la SMC3_PersistPosition_Data escribe. pp_Data: SM3_BASIC.SMC3_PersistPosition_Data1; Amplíe el programa de la tarea de movimiento para que una llamada del SMC3_PersistPosition instancia se implementa allí. Llamada implementada en CFC: El bloque de funciones se llama en ciclos con la tarea de movimiento. El SMC3_PersistPosition instancia realiza la restauración de la posición guardada durante la operación de inicio. En el funcionamiento normal, el FB guarda la posición actual en la estructura de datos respectiva. " }, 
{ "title" : "Persistencia de la posición del eje del codificador absoluto monovuelta con eje físico ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_a4cc9967c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casos de uso \/ Persistencia de una posición del eje \/ Persistencia de la posición del eje del codificador absoluto monovuelta con eje físico ", 
"snippet" : "Requisito: El eje físico tiene un encoder absoluto monovuelta. Usa el SMC3_PersistPosition bloque de funciones para que la posición del eje sea persistente. El programa correspondiente se ejecuta en la tarea de movimiento. La posición se muestra correctamente solo si el eje no ha recorrido ninguna d...", 
"body" : "Requisito: El eje físico tiene un encoder absoluto monovuelta. Usa el SMC3_PersistPosition bloque de funciones para que la posición del eje sea persistente. El programa correspondiente se ejecuta en la tarea de movimiento. La posición se muestra correctamente solo si el eje no ha recorrido ninguna distancia o solo ha recorrido una distancia corta (como máximo la mitad de la distancia de un solo giro) entre la desconexión y el encendido del mando. Para ello, puede utilizar un freno mecánico, por ejemplo. Si el eje hace un gran movimiento cuando el controlador está apagado, entonces recibe una posición incorrecta. No es posible comprobarlo mediante el FB Crea una instancia del SMC3_PersistPosition bloque de funciones para el eje. ppst_X: SM3_BASIC.SMC3_PersistPositionSinglturn; Cree una instancia de una estructura de datos persistente del SMC3_PersistPosition_Data tipo. ppst_Data_X: SMC3_PersistPositionSingleturn_Data; Amplíe el programa de la tarea de movimiento para que una llamada del SMC3_PersistPosition la instancia está implementada y la estructura de datos persistente del SMC_PersistPosition_Data se le pasa el tipo. " }, 
{ "title" : "Detección de posición inicial de un eje Modulo ", 
"url" : "_sm_initial_positioning_of_a_rotary_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casos de uso \/ Detección de posición inicial de un eje Modulo ", 
"snippet" : "La posición real de una unidad o codificador se transmite como DWORD al controlador. Para un eje de módulo, el período P se define en incrementos por el valor de módulo y la escala. El período P especifica el número exacto de incrementos en una rotación. Esto significa que los valores posicionales X...", 
"body" : "La posición real de una unidad o codificador se transmite como DWORD al controlador. Para un eje de módulo, el período P se define en incrementos por el valor de módulo y la escala. El período P especifica el número exacto de incrementos en una rotación. Esto significa que los valores posicionales X, X+1*P, X+2*P, etc. describen la misma posición física. La posición X+n*P excede el límite de DWORD cuando n es lo suficientemente grande. Esto sucede en la posición 0x1 00 00 00 00. Luego se corta el lugar inicial y el valor comienza en 0 . Si P no es un factor de 0x1 00 00 00 00 , entonces la posición X ya no describe la misma posición física antes y después de la interrupción. Si las relaciones de transmisión se establecen de modo que el período no sea un factor de 0x1 0000 0000 , entonces la posición de un eje de rotación se puede mover después de la activación. Ejemplo El eje comienza en la posición 0x0 . Está a 0°. Un período es de 360°. La escala se selecciona de modo que corresponda a 3600000 = 0x36 EE80 incrementos Después de 1193 rotaciones, el eje se detiene en 0xFFFD 7280=1193*3600000 . Después de otra rotación completa, el eje alcanza la posición 0x10034 6100 . En la interrupción, se corta el 1 inicial y la posición 0x34 6100 se forma Si mueve el eje de nuevo a la posición 0x0 , luego el eje se detiene en la posición 16.7296°. Por lo tanto, la posición 0x0 corresponde a la posición 0°, 16.7296°, etc., dependiendo de la interrupción real. Si ha seleccionado la escala para que se produzca el efecto anterior, y si no es posible o no es necesario realizar un recorrido de referencia al inicio del programa, puede recuperar la posición anterior a la última desactivación mediante el SMC3_PersistPosition bloque de funciones Aquí se utiliza un codificador de valor absoluto. " }, 
{ "title" : "Ejes CiA402 ", 
"url" : "_sm_cia402_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejes CiA402 ", 
"snippet" : "Para obtener más información, consulte Agregar...", 
"body" : "Para obtener más información, consulte Agregar " }, 
{ "title" : "Configuración del eje CiA402 genérico ", 
"url" : "_sm_drives_generic_cia402_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejes CiA402 \/ Configuración del eje CiA402 genérico ", 
"snippet" : "CODESYS SoftMotion proporciona controladores para varias unidades. Si no hay ningún controlador específico disponible para la unidad CiA402 que está utilizando, puede utilizar el eje CiA402 genérico Sin embargo, la compatibilidad y el comportamiento del eje genérico dependen en gran medida de la imp...", 
"body" : "CODESYS SoftMotion proporciona controladores para varias unidades. Si no hay ningún controlador específico disponible para la unidad CiA402 que está utilizando, puede utilizar el eje CiA402 genérico Sin embargo, la compatibilidad y el comportamiento del eje genérico dependen en gran medida de la implementación del CiA402 en la unidad respectiva. En la práctica, se ha demostrado que los diferentes fabricantes interpretan el estándar CiA402 de manera diferente, especialmente en lo que respecta a la gestión de errores y a la compatibilidad con Por lo tanto, no se puede garantizar que el eje CiA402 genérico funcione siempre correctamente o completamente con un variador en particular. El controlador genérico CiA402 admite hasta 8 ejes en caso de que la descripción del dispositivo del controlador no especifique un número. De lo contrario, se admite el número de ejes definido en la descripción del dispositivo. CANopen El número de ejes posibles depende de los perfiles de los dispositivos lógicos en el archivo EDS ( 1000H objeto y 67FFH + X * 800H , dónde X = número de dispositivos lógicos). Para obtener más detalles, consulte el estándar CANopen CiA301. EtherCAT : El número de ejes posibles depende de los canales CiA402 definidos (CoE DS402Channels) en el archivo ESI. El fabricante del dispositivo debe realizar una adaptación del archivo EDS o ESI. " }, 
{ "title" : "Objetos utilizados en la puesta en servicio ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e06c925bc32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejes CiA402 \/ Configuración del eje CiA402 genérico \/ Objetos utilizados en la puesta en servicio ", 
"snippet" : "Durante la puesta en servicio, se accede a los siguientes objetos si son compatibles con el dispositivo. Objeto Acceso de lectura \/ escritura (M) Obligatorio (O) Opcional Comentario 0x1000:0 Leer M El valor más bajo tiene que ser 402. De lo contrario, cancele. 0x1018:1 Leer O 0x1018:2 Leer O 0x1018:...", 
"body" : "Durante la puesta en servicio, se accede a los siguientes objetos si son compatibles con el dispositivo. Objeto Acceso de lectura \/ escritura (M) Obligatorio (O) Opcional Comentario 0x1000:0 Leer M El valor más bajo tiene que ser 402. De lo contrario, cancele. 0x1018:1 Leer O 0x1018:2 Leer O 0x1018:3 Leer O 0x1018:4 Leer O 0x6502:0 Leer O 0x605A:0 Leer O 0x60C2:1 Escribir Si parámetro Set60C2 = TRUE 0x60C2:2 Escribir Si parámetro Set60C2 = TRUE 0x6076:0 Leer O " }, 
{ "title" : "Objetos utilizados durante la operación ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7dfc492c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejes CiA402 \/ Configuración del eje CiA402 genérico \/ Objetos utilizados durante la operación ", 
"snippet" : "Los siguientes objetos se utilizan durante el funcionamiento en función de las funciones utilizadas: 0x603F:00 , 0x6040:00 , 0x6041:00 , 0x6060:00 , 0x6061:00 , 0x6062:00 , 0x6064:00 , 0x606B:00 , 0x606C:00 , 0x6074:00 , 0x6077:00 , 0x6078:00 , 0x607C:00 , 0x60B1:00 , 0x60B2:00, 0x60B8:00 0x60B9:00 ...", 
"body" : "Los siguientes objetos se utilizan durante el funcionamiento en función de las funciones utilizadas: 0x603F:00 , 0x6040:00 , 0x6041:00 , 0x6060:00 , 0x6061:00 , 0x6062:00 , 0x6064:00 , 0x606B:00 , 0x606C:00 , 0x6074:00 , 0x6077:00 , 0x6078:00 , 0x607C:00 , 0x60B1:00 , 0x60B2:00, 0x60B8:00 0x60B9:00 , 0x60BA:00 , 0x60BB:00 , 0x60BC:00 , 0x60BD:00 , 0x60F4:00 . " }, 
{ "title" : "Configuración avanzada ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7e012b4c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejes CiA402 \/ Configuración del eje CiA402 genérico \/ Configuración avanzada ", 
"snippet" : "Necesitas seleccionar el Mostrar editores de configuración de dispositivos genéricos opción en el Opciones – Editor de dispositivos para que se muestre la pestaña con los parámetros. Puede utilizar los siguientes parámetros para ajustar el flujo del diagrama de estado CiA402. Parámetro CiA402 Descri...", 
"body" : "Necesitas seleccionar el Mostrar editores de configuración de dispositivos genéricos opción en el Opciones – Editor de dispositivos para que se muestre la pestaña con los parámetros. Puede utilizar los siguientes parámetros para ajustar el flujo del diagrama de estado CiA402. Parámetro CiA402 Descripción _readVelocityFactor_6096 TRUE : El factor de velocidad (objeto 6096 ) se lee y se usa para convertir las unidades de velocidad. FALSE : No se lee el factor de velocidad. Se supone que la unidad de velocidad son incrementos por segundo _bImmediateDisabling TRUE : Cambia el estado de la unidad. Operation enabled justo después de Switch on disabled , si bRegulator en FALSE se reinicia. FALSE : Cambia el estado a través de \"Encendido\" y \"Listo para encender\", dando al variador la oportunidad de ejecutar una parada rápida y manejar el freno correctamente. Nota: Si esta opción está establecida en FALSE , entonces los estados para los que está desconectada la desactivación inmediata se pueden ajustar con la máscara de bits _dwStatesImmediateDisabling . _bForbidReenableDuringDisabling Sólo es relevante cuando _bImmediateDisabling = FALSE . TRUE : El variador se deshabilita paso a paso hasta que el variador señale que está en Ready to switch on antes de que se procese un nuevo comando de habilitación. dwStatesImmediateDisabling Sólo es relevante cuando _bImmediateDisabling = FALSE . Máscara de bits de los estados para los que está activada la desactivación inmediata. Bit 0: Funcionamiento normal Bit 1: parada rápida Bit 2: Parada rápida externa Bit 3: Homing Ejemplo: suponiendo _bImmediateDisabling = FALSE , el valor 2#0110 significa que la desactivación inmediata se desactiva sólo para los estados \"Funcionamiento normal\" y \"Homing\". Para los estados \"Quickstop\" y \"External Quickstop\", se activa la desactivación inmediata. _uiPreHomingWait Número de ciclos que espera la máquina de estados en estado PRE_HOMING antes de iniciar el proceso de referencia configurando el bit 4 de la palabra de control. _uiPostHomingWait Número de ciclos en los que permanece la máquina de estados HOMING_DONE antes de volver a \"Funcionamiento normal\". _uiHomingMinCycles Número de ciclos al comienzo de HOMING , donde los bits de finalización (bit 10\/12 de la palabra de estado) se ignoran. _uiWaitCyclesForStateSwitch Número de ciclos que espera el sistema hasta que el variador haya ejecutado un comando de cambio de estado. Si la unidad falla, el sistema volverá a funcionar SWITCH_ON_DISABLED . _bPreHomingWaitBit12Clear TRUE : Espere hasta que el bit 12 sea FALSE . Luego, se establece el bit 4 y se inicia el procedimiento de búsqueda de inicio. Tenga en cuenta que, en cualquier caso, la máquina de estado permanece en PRE_HOMING por al menos _uiPreHomingCycles . _bCheckBit10PostHoming TRUE : Si el bit 12 y el bit 10 son TRUE , entonces el HOMING_DONE el estado está activado. FALSE : El bit 10 se ignora. _bCheckOpMode TRUE : Comprobar si 0x6061 muestra el valor establecido en 0x6060 al habilitar el eje. FALSE : Omita esta verificación y actívela inmediatamente después de configurar el modo de funcionamiento. _abyControllerMode Este ARRAY[0..7] OF BYTE contiene los modos de operación (objeto 0x6060 ) que corresponden con AXIS_REF_SM3.byOperationMode . (índice 0,3 = posición; índice 1 = velocidad; índice 2 = par) _bCheckBit12InPositionMode TRUE : AxisIsReadyForMotion comprueba el bit 12 en CSP o IP. FALSE : AxisIsReadyForMotion no comprueba el bit 12. _bDoHaltWhenStopInterruptsHome TRUE : Cuando MC_Stop interrupciones, cancelar el recorrido de referencia con el bit 8 de la palabra de control. FALSE : No configure el bit 8, pero cambie directamente el modo de operación. _bCheckBit13InHomingMode TRUE : En HOMING_ACTIVE , wStatusWord.13 = TRUE conduce a una parada de error y wControlWord.8 := TRUE (Dependiendo de _bDoHaltWhenStopInterruptsHome ) _bSetControlBit4InCSP TRUE : Establece el bit 4 de la palabra de estado también en modo CSP. Algunas unidades lo requieren, aunque no es estándar. _uiHomingWaitListeningBits101213 en estado HOMING_ACTIVE , no escuche los bits 10, 12 y 13 durante este número de ciclos desde la configuración del bit 4. (Algunas unidades tardan algún tiempo en restablecer estos bits). _bRegulatorOnRequiresVoltageEnabled Si el bit 4 de la palabra de estado (voltaje habilitado) necesita ser TRUE de modo que bRegulatorRealState = TRUE (valor por defecto: FALSE ). _bDriveStartRequiresOperationEnabled Si el bit 2 de la palabra de estado (operación habilitada) necesita ser TRUE de modo que bDriveStartRealState = TRUE (valor por defecto: TRUE ). _modeOfOperation_Torque El ModeOfOperation para usarse en el modo controlador torque . Debe comportarse como el modo de par de sincronización cíclico. _modeOfOperation_Velocity El ModeOfOperation para usarse en el modo controlador velocity . Debe comportarse como el modo de velocidad de sincronización cíclica. _modeOfOperation_Position El ModeOfOperation para usarse en el modo controlador position . Debe comportarse como el modo de posición de sincronización cíclica. _bStayInSwitchOnDisabled FALSE : Una transición automática desde SWITCH_ON_DISABLED para READY_TO_SWITCH_ON se lleva a cabo, si alguno de los dos MC_Power.bDriveStart es TRUE o el código de opción de parada rápida ( object 0x605A:00 ) es > 4. CIERTO: La transición de SWITCH_ON_DISABLED para READY_TO_SWITCH_ON solo se hace si MC_Power.bRegulatorOn es TRUE . " }, 
{ "title" : "Sonda táctil ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087437140543", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejes CiA402 \/ Configuración del eje CiA402 genérico \/ Sonda táctil ", 
"snippet" : "El MC_TouchProbe el bloque de funciones requiere un TRIGGER_REF como entrada. TRIGGER_REF.iTriggerNumber tiene el siguiente significado para el eje CiA402 genérico: Trigger_ref.it Número de activación Significado 0 Sonda táctil 1, borde positivo 1 Sonda táctil 1, borde negativo 2 Sonda táctil 2, bor...", 
"body" : "El MC_TouchProbe el bloque de funciones requiere un TRIGGER_REF como entrada. TRIGGER_REF.iTriggerNumber tiene el siguiente significado para el eje CiA402 genérico: Trigger_ref.it Número de activación Significado 0 Sonda táctil 1, borde positivo 1 Sonda táctil 1, borde negativo 2 Sonda táctil 2, borde positivo 3 Sonda táctil 2, borde negativo " }, 
{ "title" : "Diagnóstico de errores: la unidad no se puede encender mediante MC_Power ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087440495495", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejes CiA402 \/ Configuración del eje CiA402 genérico \/ Diagnóstico de errores: la unidad no se puede encender mediante MC_Power ", 
"snippet" : "El eje genérico espera los siguientes bits de la palabra de estado para devolver MC_Power.Status = TRUE : Bit 0 (listo para encenderse) Bit 1 (encendido) Bit 2 (operación habilitada) Bit 5 (parada rápida) Bit 12 Sin embargo, no todas las unidades configuran el bit 12. Si la unidad no ajusta el bit, ...", 
"body" : "El eje genérico espera los siguientes bits de la palabra de estado para devolver MC_Power.Status = TRUE : Bit 0 (listo para encenderse) Bit 1 (encendido) Bit 2 (operación habilitada) Bit 5 (parada rápida) Bit 12 Sin embargo, no todas las unidades configuran el bit 12. Si la unidad no ajusta el bit, entonces el _bCheckBit12InPositionMode el parámetro del eje genérico se puede establecer en FALSE . " }, 
{ "title" : "Sonda táctil ", 
"url" : "_sm_touch_probe.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejes CiA402 \/ Sonda táctil ", 
"snippet" : "Las unidades con un perfil CiA402 a veces admiten la selección de la fuente de la sonda táctil. No es posible configurar la fuente a través del MC_TouchProbe bloque de funciones. De forma predeterminada, se utiliza la entrada digital que pertenece a la sonda táctil. Cambiar la fuente: Escritura manu...", 
"body" : "Las unidades con un perfil CiA402 a veces admiten la selección de la fuente de la sonda táctil. No es posible configurar la fuente a través del MC_TouchProbe bloque de funciones. De forma predeterminada, se utiliza la entrada digital que pertenece a la sonda táctil. Cambiar la fuente: Escritura manual del objeto de sonda táctil 0x60B8 Para ello, debe llamar al MC_WriteParameter bloque de funciones con ParameterNumber = 10184 . Esto corresponde al objeto CiA 402 0x60B8 . Si la salida MC_WriteParameter.Done = TRUE , a continuación, puede ordenar el MC_TouchProbe bloque de funciones como de costumbre. Solo los bits del objeto 0x60B8 son conjuntos que pueden definirse por MC_TouchProbe (indicado por ). Los bits restantes conservan el valor del paso 1 (indicado por ): Trozos de objeto 0x60B8 Sonda táctil 2 Sonda táctil 1 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 Nota sobre el objeto 0x60D0 En el objeto de la sonda táctil 0x60B8 , puede especificar la fuente para que se resuelva mediante el objeto 0x60D0 . Esto corresponde a la combinación de bits 10 b para pedacitos 3 , 2 o 11 , 10 de objeto 0x60B8 . En este caso, necesitas escribir el objeto 0x60D0 antes de ejecutar MC_TouchProbe . Para hacer esto, debes usar el MC_WriteParameter bloque de función, en el que el ParameterNumber se calcula mediante el SMC_ParameterNumber_CoE función. " }, 
{ "title" : "Valores reales, valores establecidos y tiempo muerto ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valores reales, valores establecidos y tiempo muerto ", 
"snippet" : "Esta página responde a la pregunta de cuándo se reciben y envían los valores reales y establecidos, y cómo se relacionan con el tiempo muerto. En aras de la simplicidad, nos centramos en la posición, pero lo mismo se aplica a otros valores como la velocidad o el par. También nos centramos en EtherCA...", 
"body" : "Esta página responde a la pregunta de cuándo se reciben y envían los valores reales y establecidos, y cómo se relacionan con el tiempo muerto. En aras de la simplicidad, nos centramos en la posición, pero lo mismo se aplica a otros valores como la velocidad o el par. También nos centramos en EtherCAT. El comportamiento es similar en otros buses de campo. (Tenga en cuenta que asumimos la configuración predeterminada y recomendada FrameAtTaskStart = TRUE .) " }, 
{ "title" : "¿Cuándo se reciben los valores reales? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054861776368", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valores reales, valores establecidos y tiempo muerto \/ ¿Cuándo se reciben los valores reales? ", 
"snippet" : "The actual position ( <DriveA>.fActPosition ) is received at the beginning of the current bus task cycle. It is the actual position of the drive at the time of the previous EtherCAT SYNC event. En el ciclo de tareas de bus i, se recibe la trama EtherCAT que se envió en el ciclo de tareas de bus i-1 ...", 
"body" : "The actual position ( <DriveA>.fActPosition ) is received at the beginning of the current bus task cycle. It is the actual position of the drive at the time of the previous EtherCAT SYNC event. En el ciclo de tareas de bus i, se recibe la trama EtherCAT que se envió en el ciclo de tareas de bus i-1 anterior. Este marco contiene la posición real que la unidad bloqueó en el evento SYNC " }, 
{ "title" : "¿Cuándo se envían los valores establecidos? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862001312", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valores reales, valores establecidos y tiempo muerto \/ ¿Cuándo se envían los valores establecidos? ", 
"snippet" : "Los valores establecidos que se calculan en el ciclo de tareas del bus actual i se envían a la unidad en el siguiente ciclo de tareas del bus i+1 y la unidad los aplica en el evento SYNC i+1. Consulta el diagrama de arriba...", 
"body" : "Los valores establecidos que se calculan en el ciclo de tareas del bus actual i se envían a la unidad en el siguiente ciclo de tareas del bus i+1 y la unidad los aplica en el evento SYNC i+1. Consulta el diagrama de arriba " }, 
{ "title" : "¿Qué es el tiempo muerto, cómo se estima y cómo se usa? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862210917", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valores reales, valores establecidos y tiempo muerto \/ ¿Qué es el tiempo muerto, cómo se estima y cómo se usa? ", 
"snippet" : "Como regla general, el tiempo muerto es importante siempre que sea necesario realizar una acción exactamente cuando la unidad llega a una posición. El tiempo muerto también es importante para determinar con exactitud la posición de conducción en un momento dado. Por ejemplo, aplicar pegamento a alta...", 
"body" : "Como regla general, el tiempo muerto es importante siempre que sea necesario realizar una acción exactamente cuando la unidad llega a una posición. El tiempo muerto también es importante para determinar con exactitud la posición de conducción en un momento dado. Por ejemplo, aplicar pegamento a alta velocidad o realizar una sonda táctil en el PLC con entradas digitales de alta precisión conectadas al PLC. " }, 
{ "title" : "Definición del tiempo muerto ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862962511", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valores reales, valores establecidos y tiempo muerto \/ ¿Qué es el tiempo muerto, cómo se estima y cómo se usa? \/ Definición del tiempo muerto ", 
"snippet" : "El tiempo muerto es el tiempo que tarda el variador en alcanzar realmente la posición establecida enviada por el PLC. Eso significa que es el lapso de tiempo entre fActPosition y el fSetPosition , al principio del ciclo de tareas actual del bus. El tiempo muerto se puede configurar en el editor gene...", 
"body" : "El tiempo muerto es el tiempo que tarda el variador en alcanzar realmente la posición establecida enviada por el PLC. Eso significa que es el lapso de tiempo entre fActPosition y el fSetPosition , al principio del ciclo de tareas actual del bus. El tiempo muerto se puede configurar en el editor general de la unidad ( Pestaña: General) o mediante el Parámetro MC_Write bloque de función con el número de parámetro 1070 ( fSetActTimeLagCycles ). El tiempo muerto es la suma de las siguientes veces: El tiempo que se tarda en enviar la posición establecida a la unidad El tiempo que necesita el controlador de la unidad para alcanzar la posición establecida El tiempo que se tarda en recibir la posición real de la unidad " }, 
{ "title" : "Estimación del tiempo muerto ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054864599382", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valores reales, valores establecidos y tiempo muerto \/ ¿Qué es el tiempo muerto, cómo se estima y cómo se usa? \/ Estimación del tiempo muerto ", 
"snippet" : "El tiempo muerto se puede estimar utilizando el SMC_EstimateDeadtime bloque de funciones. La unidad debe moverse a una velocidad constante y debe usarse la mediana o el promedio de varias mediciones de tiempo muerto Alternativamente, el tiempo muerto se puede estimar utilizando el editor de rastreo....", 
"body" : "El tiempo muerto se puede estimar utilizando el SMC_EstimateDeadtime bloque de funciones. La unidad debe moverse a una velocidad constante y debe usarse la mediana o el promedio de varias mediciones de tiempo muerto Alternativamente, el tiempo muerto se puede estimar utilizando el editor de rastreo. Para obtener más información, consulte lo siguiente: Determinación del tiempo muerto del sistema" }, 
{ "title" : "Uso del tiempo muerto ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054865995483", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valores reales, valores establecidos y tiempo muerto \/ ¿Qué es el tiempo muerto, cómo se estima y cómo se usa? \/ Uso del tiempo muerto ", 
"snippet" : "El tiempo muerto se utiliza en la siguiente funcionalidad. Si utiliza alguna de estas funciones y necesita una alta precisión, asegúrese de determinar y configurar el tiempo muerto. Al cambiar el modo controlador al modo controlador SMC_position Para obtener más información, consulte lo siguiente: C...", 
"body" : "El tiempo muerto se utiliza en la siguiente funcionalidad. Si utiliza alguna de estas funciones y necesita una alta precisión, asegúrese de determinar y configurar el tiempo muerto. Al cambiar el modo controlador al modo controlador SMC_position Para obtener más información, consulte lo siguiente: Casos de uso estándarEn modo controlador SMC_velocity para calcular la posición establecida a partir de la posición real y la velocidad establecida En modo controlador SMC_torque para calcular la posición establecida a partir de la posición real y la velocidad real Si la monitorización del retraso de posición del software está activada En el SMC_GetTravelTime bloque de funciones de la entrada ValueSource tiene el valor MC_SOURCE.ACT En el SMC_DigitalCamSwitch_HighPrecision bloque de función de la entrada ValueSource tiene el valor MC_SOURCE.ACT En el SMC_ETC_InterpolateAxisPosition bloque de funciones (sonda táctil basada en PLC) " }, 
{ "title" : "Ejemplos ", 
"url" : "_sm_drives_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejemplos ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Control de posición en el controlador con SM_Drive_PosControl ", 
"url" : "_sm_example_poscontrol.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejemplos \/ Control de posición en el controlador con SM_Drive_PosControl ", 
"snippet" : "Vea el proyecto de ejemplo para esto PosControl.project en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . En la mayoría de los casos, un servocontrol asume el control de posición del variador, así como el control de potencia y el control de velocidad de rotación....", 
"body" : "Vea el proyecto de ejemplo para esto PosControl.project en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . En la mayoría de los casos, un servocontrol asume el control de posición del variador, así como el control de potencia y el control de velocidad de rotación. Sin embargo, hay casos de uso en los que el controlador asume el control de posición del eje. Este ejemplo demuestra cómo un dispositivo con control de velocidad (por ejemplo, un convertidor de frecuencia con realimentación de posición) es controlado por posición por CODESYS SoftMotion . El requisito es un dispositivo que esté controlado por la velocidad establecida y devuelva su posición actual. En este ejemplo, se utiliza un terminal de salida analógica de 10 V EL4031 con una señal que se utiliza como punto de ajuste de velocidad para un convertidor de frecuencia. Se utiliza un terminal de codificador EL5101 para la retroalimentación de posición. " }, 
{ "title" : "Control de la posición del eje mediante SM_Drive_PosControl ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_7bfb9b9f2d9ce618c0a8646335ff28dd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejemplos \/ Control de posición en el controlador con SM_Drive_PosControl \/ Control de la posición del eje mediante SM_Drive_PosControl ", 
"snippet" : "Agregar un eje de tipo controlado por posición SM_Drive_PosControl debajo Piscina SoftMotion General Axis en el árbol de dispositivos. Agregue los terminales para el terminal analógico (EL4031) y el codificador (EL5101) al árbol de dispositivos. Árbol de dispositivos: Las descripciones de los dispos...", 
"body" : "Agregar un eje de tipo controlado por posición SM_Drive_PosControl debajo Piscina SoftMotion General Axis en el árbol de dispositivos. Agregue los terminales para el terminal analógico (EL4031) y el codificador (EL5101) al árbol de dispositivos. Árbol de dispositivos: Las descripciones de los dispositivos de bus de campo deben descargarse e instalarse del fabricante. Abre el SM_Drive_PosControl dispositivo en el editor y especifique el parámetro general Módulo con valor 360.0 sobre el General pestaña. Haga clic en el Escalado \/ Mapeo pestaña. El número de incrementos por vuelta del motor se toma de la hoja de datos del codificador. En este ejemplo, 4096 los incrementos (1) son una vuelta de motor. Como está trabajando con grados angulares en la aplicación, especifique el valor 360 (2) para unidades en aplicación . Ajustes: Cambie al SoftMotion Drive: bucle de control de posición pestaña y especifique los siguientes parámetros: D 2.0 El tiempo muerto determina el número de ciclos en los que la posición real recibida (codificador) se desplaza de fase a la posición establecida del eje. El tiempo muerto depende de los componentes aplicados y debe determinarse mediante prueba y error. Kp 0.0 La constante de proporcionalidad es el factor por el cual se multiplica el error de posición (la desviación entre la posición establecida y la real) para agregarla más tarde a la velocidad establecida. Ahora establezca este valor en 0 . Determinará el valor experimentalmente en un momento posterior. Bit width: 16 El ancho de bits del valor real se recibe en función de los componentes utilizados y se puede establecer como valores de 16, 24 o 32 bits. Establezca el valor en 16 porque los componentes usados dan la posición como UINT . max Deje el interruptor de control de errores de posición apagado. Puede volver a encenderlo si es necesario. Seleccione la casilla de verificación y especifique un retraso máximo permitido. Si se excede este valor durante el funcionamiento, el eje entra en un estado de error. δ\/δt El parámetro tiene el valor 1 y debe cambiarse solo en casos muy especiales. Define la relación entre la velocidad establecida y la derivación de la posición. El rango de valores es de 0 a 1: 0 : El valor de fSetVelocity se utiliza como fuente. 1 : La derivación numérica de la posición establecida se utiliza como fuente. Bucle de control: Ahora configura los valores de velocidad que se envían al actuador. Para ello, debe conocer la velocidad máxima en unidades de aplicación y el valor bruto correspondiente de los datos transferidos. En este ejemplo, la velocidad máxima se logra mediante la salida del valor 16#7FFF , que corresponde a una velocidad de 10 vueltas por segundo. Esto también corresponde a 3600 grados por segundo según la configuración. Ajustes: " }, 
{ "title" : "Mapeo de variables a entradas y salidas ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_869c8e3e2852db2ec0a8640e00c42e8b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejemplos \/ Control de posición en el controlador con SM_Drive_PosControl \/ Mapeo de variables a entradas y salidas ", 
"snippet" : "Asigne las variables con los datos del eje a los módulos de E \/ S. Los datos cíclicos disponibles del eje se encuentran en las estructuras de datos in y out . Puede establecer esta conexión en el editor de dispositivos del dispositivo de entrada y salida mediante programación o directamente. Conecte...", 
"body" : "Asigne las variables con los datos del eje a los módulos de E \/ S. Los datos cíclicos disponibles del eje se encuentran en las estructuras de datos in y out . Puede establecer esta conexión en el editor de dispositivos del dispositivo de entrada y salida mediante programación o directamente. Conecte la salida (velocidad establecida) al dispositivo EL4031. Abra el dispositivo en el editor y haga clic en el Asignación de E \/ S EtherCAT pestaña. Asignar la variable out.iSetVelocity del eje a la salida. En el caso de una salida de 32 bits, out.diSetVelocity se utiliza. Cartografía: Proceda de la misma forma con la entrada de posición. Abra el dispositivo EL5101 en el editor y establezca el valor de entrada de posición en in.wActPosition . Para una entrada de 32 bits, establezca el valor en in.dwActPosition . Cartografía: Para que funcionen la habilitación de control, la parada rápida y el interruptor de límite, las entradas correspondientes de SMC_PosControlInput tienen que estar definidos por los valores de la unidad. Las salidas de SMC_PosControlOutput deben transmitirse al convertidor (consulte la descripción a continuación). Si la unidad no admite la parada rápida, por ejemplo, SM_Drive_PosControl.in.bDriveStartRealState := TRUE tiene que ser configurado y SM_Drive_PosControl.out.bDriveStart puede ignorarse. En este ejemplo, bDriveStartRealState y bRegulatorRealState deben configurarse en la aplicación. SM_Drive_PosControl.in.bDriveStartRealState := TRUE;\nSM_Drive_PosControl.in.bRegulatorRealState := TRUE; " }, 
{ "title" : "Determinación del tiempo muerto del sistema ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_section-idm43260109050006", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejemplos \/ Control de posición en el controlador con SM_Drive_PosControl \/ Determinación del tiempo muerto del sistema ", 
"snippet" : "Ahora configure el modo en línea con el eje y configure los parámetros de control. Tenga en cuenta que el eje puede moverse fuera de control. Por lo tanto, debe tomar las precauciones de seguridad correspondientes. Luego intente operar el eje sin control de posición. fKp ya está establecido en 0.0 y...", 
"body" : "Ahora configure el modo en línea con el eje y configure los parámetros de control. Tenga en cuenta que el eje puede moverse fuera de control. Por lo tanto, debe tomar las precauciones de seguridad correspondientes. Luego intente operar el eje sin control de posición. fKp ya está establecido en 0.0 y la configuración de escala está verificada. Cambie el eje a MC_Power y empezar MC_MoveVelocity . El eje se mueve ahora con la velocidad programada de 1 U \/ s. En el caso de desviaciones, debe corregir la escala en consecuencia. Termine el movimiento, por ejemplo con MC_MoveRelative e inicie la función de seguimiento. Determine el tiempo muerto del sistema midiendo la diferencia de tiempo entre la posición establecida y la posición real. En MC_MoveRelative , establezca la velocidad máxima y una gran aceleración. Inicie la traza de muestreo con MC_MoveRelative . Ahora determine la diferencia de tiempo entre el movimiento inicial de la posición ajustada y la primera reacción de la posición real. Rastro: Para determinar el tiempo muerto D , divide esta diferencia de tiempo por el tiempo del ciclo (D = diferencia horaria\/tiempo del ciclo). En el SoftMotion Drive: control de posición pestaña, especifique este valor en el bucle de control en D . Ahora intenta determinar el ajuste correcto para fKp . Para ello, cambie el valor de la variable <drive>.controller.fKp en una lista de vigilancia. Set fKp a un número pequeño (por ejemplo, 0,0001) y aumente el valor paso a paso. Compruebe el comportamiento de cada cambio con la traza de muestreo. Tan pronto como detecte fluctuaciones, se habrá alcanzado el límite superior. Ahora disminuya el valor de fKp aproximadamente un 10% y especifíquelo en el SoftMotion Drive: control de posición pestaña en el bucle de control en Kp . Ahora puedes usar el eje. " }, 
{ "title" : "Bloque de funciones: SMC_PosControlInput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_666f8939fd0b11e3b1f5b5a0173eacdc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejemplos \/ Control de posición en el controlador con SM_Drive_PosControl \/ Bloque de funciones: SMC_PosControlInput ", 
"snippet" : "Biblioteca: SM3_Drive_PosControl Entradas (VAR_INPUT) Nombre Tipo de datos Valor inicial Descripción bLimitPos BOOL Final de carrera en sentido positivo (solo para ejes finitos) Desde SoftMotion la versión 4.12.0.0, la supervisión del interruptor de límite está habilitada de forma predeterminada. Pa...", 
"body" : "Biblioteca: SM3_Drive_PosControl Entradas (VAR_INPUT) Nombre Tipo de datos Valor inicial Descripción bLimitPos BOOL Final de carrera en sentido positivo (solo para ejes finitos) Desde SoftMotion la versión 4.12.0.0, la supervisión del interruptor de límite está habilitada de forma predeterminada. Para las versiones anteriores, esto debe habilitarse manualmente configurando bHWLimitEnable para TRUE . Esto se hace normalmente escribiendo el número de parámetro correspondiente 1206 por medio de MC_WriteBoolParameter . TRUE : Final de carrera no accionado FALSE : Interruptor de límite accionado bLimitNeg BOOL Final de carrera en dirección negativa TRUE : Final de carrera no accionado FALSE : Interruptor de límite accionado wActPosition WORD Posición actual (posición real) como valor de 16 bits dwActPosition DWORD Posición actual (posición real) como valor de 32 bits bExternalError BOOL Error externo bRegulatorRealState BOOL TRUE : Eje siendo controlado bDriveStartRealState BOOL FALSE : Eje en Quick Stop dwEncoderCounterModulo DWORD 0 bDelayActivation BOOL TRUE : Siempre y cuando bDelayActivation es TRUE , SM3_Drive_PosControl no cambia al estado de comunicación 100 . Caso de uso: el valor se mantiene en TRUE hasta que el codificador aplicado arroje valores posicionales válidos. " }, 
{ "title" : "Bloque de funciones: SMC_PosControlOutput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_60809817bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejemplos \/ Control de posición en el controlador con SM_Drive_PosControl \/ Bloque de funciones: SMC_PosControlOutput ", 
"snippet" : "Biblioteca: SM3_Drive_PosControl Salidas (VAR_OUTPUT) Nombre Tipo de datos Valor inicial Descripción bRegulatorOnIn BOOL TRUE : El eje debe estar controlado. bDriveStart BOOL FALSE : El eje debe ejecutar una parada rápida. diSetVelocity DINT Establecer velocidad iSetVelocity INT Establecer velocidad...", 
"body" : "Biblioteca: SM3_Drive_PosControl Salidas (VAR_OUTPUT) Nombre Tipo de datos Valor inicial Descripción bRegulatorOnIn BOOL TRUE : El eje debe estar controlado. bDriveStart BOOL FALSE : El eje debe ejecutar una parada rápida. diSetVelocity DINT Establecer velocidad iSetVelocity INT Establecer velocidad " }, 
{ "title" : "Bloque de funciones: SMC_SetPosControlParams ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_6080e639bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Ejemplos \/ Control de posición en el controlador con SM_Drive_PosControl \/ Bloque de funciones: SMC_SetPosControlParams ", 
"snippet" : "Biblioteca: SM3_Drive_PosControl Cambia los parámetros de un SM3_Drive_PosControl eje Entradas (VAR_INPUT) Nombre Tipo de datos Valor inicial Descripción Axis AXIS_REF_POSCONTROL Referencia de eje bExecute BOOL TRUE : Activa la ejecución del bloque de funciones. fKp LREAL -1 Ganancia proporcional po...", 
"body" : "Biblioteca: SM3_Drive_PosControl Cambia los parámetros de un SM3_Drive_PosControl eje Entradas (VAR_INPUT) Nombre Tipo de datos Valor inicial Descripción Axis AXIS_REF_POSCONTROL Referencia de eje bExecute BOOL TRUE : Activa la ejecución del bloque de funciones. fKp LREAL -1 Ganancia proporcional por retraso Se ignora un valor menor que 0. fPartVelPilotControl LREAL -1 Factor para el control de velocidad con fSetPosition 0: Sin control piloto de velocidad; 1: Salida directa de fSetVelocity . Se ignora un valor menor que 0. fDeadTime LREAL -1 Retraso de tiempo en ciclos entre fSetPosition y fActPositioin Este valor no debe ser 0. Se ignora un valor menor que 0. fMaxPositionDiff LREAL -1 Retraso de posición máximo 0 desactiva la comprobación del retardo de posición máximo. Se ignora un valor menor que 0. Salidas (VAR_OUTPUT) Nombre Tipo de datos Valor inicial Descripción bDone BOOL La ejecución del bloque de funciones ha finalizado. bError BOOL TRUE : Se ha producido un error en el bloque de funciones. ErrorID SMC_ERROR Error de identificación Ejemplo Los parámetros de la unidad de eje SM_Drive_PosControl se establecen. PROGRAM PLC_PRG\nVAR\n fbSetPosControlParams : SMC_SetPosControlParams;\nEND_VAR\n\nfbSetPosControlParams.fKp := 1;\nfbSetPosControlParams.fPartVelPilotControl :=0;\nfbSetPosControlParams.fDeadTime :=0.1;\nfbSetPosControlParams.fMaxPositionDiff :=1;\n\nfbSetPosControlParams(Axis:= SM_Drive_PosControl, bExecute:= TRUE); " }, 
{ "title" : "Interfaz de usuario ", 
"url" : "_sm_drives_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaz de usuario ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comando: Agregar SoftMotion Eje CiA402 ", 
"url" : "_sm_cmd_add_softmotion_cia402_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaz de usuario \/ Comando: Agregar SoftMotion Eje CiA402 ", 
"snippet" : "Agregar SoftMotion Eje CiA402 Función : El comando agrega un general SoftMotion Eje CiA402 debajo de un esclavo de bus de campo en el árbol de dispositivos. Llama : Proyecto menú; menú contextual del dispositivo Requisito : En el árbol de dispositivos, se selecciona un dispositivo que admite esta un...", 
"body" : "Agregar SoftMotion Eje CiA402 Función : El comando agrega un general SoftMotion Eje CiA402 debajo de un esclavo de bus de campo en el árbol de dispositivos. Llama : Proyecto menú; menú contextual del dispositivo Requisito : En el árbol de dispositivos, se selecciona un dispositivo que admite esta unidad. Ejemplos: esclavo EtherCAT o esclavo CAN El archivo ESI de la unidad contiene la entrada de que se trata de un eje CiA402 ( ProfileNo 402 ). El comando inserta un eje CiA402 genérico. Para obtener más información, consulte lo siguiente Configuración del eje CiA402 genérico " }, 
{ "title" : "Comando: Agregar SoftMotion Eje Sercos ", 
"url" : "_sm_cmd_add_softmotion_sercos_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaz de usuario \/ Comando: Agregar SoftMotion Eje Sercos ", 
"snippet" : "Agregar SoftMotion Eje Sercos Función : El comando agrega un general SoftMotion Eje Sercos debajo de un Módulo Sercos. Llama : Proyecto menú; menú contextual del Sercos Slave Requisito : Se selecciona un esclavo Sercos apropiado en el árbol de dispositivos. Los ejes Sercos ya no son compatibles con ...", 
"body" : "Agregar SoftMotion Eje Sercos Función : El comando agrega un general SoftMotion Eje Sercos debajo de un Módulo Sercos. Llama : Proyecto menú; menú contextual del Sercos Slave Requisito : Se selecciona un esclavo Sercos apropiado en el árbol de dispositivos. Los ejes Sercos ya no son compatibles con SoftMotion Versión 4.17.0.0 y superior. Este comando se utiliza para que cualquier servodrive funcione con CODESYS SoftMotion . La unidad solo tiene que ser compatible con el estándar Sercos. CODESYS utiliza un controlador estándar para comunicarse con el dispositivo. La forma en que funciona o no la unidad con el dispositivo depende de la implementación en el propio dispositivo. Por lo tanto, no hay garantía de cómo funciona o no el controlador con el dispositivo. El controlador Sercos genérico admite dispositivos de varios ejes de hasta ocho ejes. " }, 
{ "title" : "Comando: Agregar SoftMotion Eje SoE ", 
"url" : "_sm_cmd_add_softmotion_soe_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaz de usuario \/ Comando: Agregar SoftMotion Eje SoE ", 
"snippet" : "Agregar SoftMotion Eje SoE Función : El comando agrega un general SoftMotion Eje SoE debajo de un esclavo EtherCAT. Llama : Proyecto menú; menú contextual del esclavo Requisito : Se selecciona un esclavo EtherCAT adecuado en el árbol de dispositivos. Este comando se utiliza para que cualquier servod...", 
"body" : "Agregar SoftMotion Eje SoE Función : El comando agrega un general SoftMotion Eje SoE debajo de un esclavo EtherCAT. Llama : Proyecto menú; menú contextual del esclavo Requisito : Se selecciona un esclavo EtherCAT adecuado en el árbol de dispositivos. Este comando se utiliza para que cualquier servodrive funcione con CODESYS SoftMotion . El servodrive solo tiene que ser compatible con el estándar SoE. CODESYS utiliza un controlador estándar para comunicarse con el dispositivo. La forma en que funciona o no la unidad con el dispositivo depende de la implementación en el propio dispositivo. Por lo tanto, no hay garantía de cómo funciona o no el controlador con el dispositivo. El controlador SoE genérico admite dispositivos de varios ejes de hasta ocho ejes. " }, 
{ "title" : "SoftMotion Drives ", 
"url" : "_sm_f_reference_object_sm_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaz de usuario \/ SoftMotion Drives ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Pestaña: General ", 
"url" : "_sm_edt_drive_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaz de usuario \/ SoftMotion Drives \/ Pestaña: General ", 
"snippet" : "Tipo de eje y configuración Tipo de eje Modo virtual : La unidad se sustituye por una simulación similar a la de una unidad de disco virtual. Cuando hay una unidad acoplada, esto no tiene ningún efecto en el dispositivo de bus de campo. Funcionan como de costumbre sin enviar ni recibir mensajes haci...", 
"body" : "Tipo de eje y configuración Tipo de eje Modo virtual : La unidad se sustituye por una simulación similar a la de una unidad de disco virtual. Cuando hay una unidad acoplada, esto no tiene ningún efecto en el dispositivo de bus de campo. Funcionan como de costumbre sin enviar ni recibir mensajes hacia o desde un dispositivo físico Nota: También puede configurar y restablecer un modo virtual de una unidad en código IEC mediante el SMC3_ReinitDrive bloque de funciones Modulo : El accionamiento gira sin cesar sin limitar el rango de desplazamiento (ejemplo: transmisión por correa). Valor de módulo [u] : Valor de un ciclo (período de módulo) El valor se guarda en el fPositionPeriod parámetro de la AXIS_REF_SM3 bloque de funciones Nota: si selecciona el Modulo tipo de unidad, luego el producto fPositionPeriod * dwRatioTechUnitsDenom tiene que ser un número entero. Finito : El convertidor tiene un área de trabajo fija (ejemplo: un convertidor lineal). Interruptores de fin de carrera por software Activado : Los valores de posición están restringidos por el límite inferior Negativo y un límite superior Positivo . Negativo : Campo de entrada para el valor límite negativo Positivo : Campo de entrada para el valor límite positivo Tipo de motor Rotary : La configuración en Escalado se aplican a motores rotativos. Lineal : La configuración en Escalado se aplican a motores lineales. (Configuración simplificada sin engranajes ni giros del motor) Tipo de rampa de velocidad Define el perfil de velocidad para los módulos maestro\/esclavo y de eje único que generan movimiento: Nota: Los tipos de rampa Sin² y Cuadrático (suave) no son compatibles con la robótica. Trapezoide : Perfil de velocidad trapezoidal (con aceleración constante en cada segmento) Pecado² : un perfil de velocidad definido por la función sin² (con una curva de aceleración constante). cuadrática : Perfil de aceleración en forma trapezoidal con limitación de sacudidas Cuadrático (suave) : Me gusta Cuadrático pero genera un perfil imbécil sin saltos. Identificación ID Identificador de números enteros. Debe ser único para cada unidad. Por ejemplo, este identificador se utiliza en el registro del PLC para identificar la unidad cuando se produce un error. Tiempo muerto Ciclos El tiempo muerto en los ciclos entre fActPosition y el fSetPosition al principio de este ciclo Límites dinámicos Se tienen en cuenta los valores límite de las POU de la parte 4 de PLCopen. Además, las POU de la biblioteca las utilizan con SMC_ControlAxisBy* para detectar saltos. Velocidad [u\/s] Valor límite de velocidad, aceleración, desaceleración y tirón Aceleración [u\/s²] Deceleración [u\/s²] Imbécil [u\/s³] Monitorización y reacción a errores Límites de software Activado : Los valores de posición están restringidos por el límite inferior Negativo y un límite superior Positivo . Negativo : campo de entrada para el valor límite negativo Positivo : Campo de entrada para el valor límite positivo Reacción de error de software Causas de un error de software Alcanzar un cambio de límite de software Superar el retraso de software máximo permitido Para ejes finitos: demasiados desbordamientos de 32 bits MC_Power.bRegulatorOn = FALSE durante un movimiento activo (error: SMC_FB_ACTIVE_AXIS_DISABLED ) Bloque de funciones de movimiento con Busy=TRUE no se llama (error: SMC_FB_WASNT_CALLED_DURING_MOTION ) Para la reacción de error del software, el Desaceleración , el Max. , y se tiene en cuenta la desaceleración de los límites dinámicos. La desaceleración también se calcula a partir de la distancia máxima. El valor más alto de estos valores de desaceleración se utiliza para Deceleración [u\/s²] : Desaceleración de la rampa de error Distancia máxima [u] Opcional La unidad debe haberse detenido dentro de esta distancia después de que se haya producido un error. Monitorización del desfase de posición Respuesta del sistema a un retraso detectado. Se detecta un retraso cuando la diferencia entre la posición establecida y la posición real compensada supera el límite de retraso. La posición real extrapolada se calcula con la siguiente fórmula: extrapolated actual position := actual position + actual velocity * cycle time * Axis.fSetActTimeLagCycles Este valor es la posición real del eje compensada por el tiempo muerto. Nota: Si está monitoreando el retraso, debe determinar e ingresar el tiempo muerto. Para obtener una descripción, consulte el capítulo siguiente: Valores reales, valores establecidos y tiempo muerto. Nota: La supervisión del retraso no está disponible para las unidades virtuales. Desactivado Sin respuesta La monitorización del retraso está desactivada. Desactivar la unidad El bRegulatorOn pero se ve obligado a FALSE (comparar con MC_Power input), que primero fuerza la desaceleración del variador y, a continuación, la desactivación del variador (según la implementación del variador). Haz una parada rápida El bDriveStart bit se ve obligado a FALSE (comparar con MC_Power input), lo que obliga a la unidad a realizar una parada rápida. Manténgase habilitado La unidad permanece encendida, pero todos los movimientos de marcha se detienen bruscamente. Límite de retraso : Monitorización del retraso en el controlador La supervisión independiente también puede existir en la unidad, pero no está configurada en este cuadro de diálogo. En línea Requisito: el PLC está en modo online. Tabla de variables Lista de variables de unidad con nombre de variable, Valor ajustado y Valor actual Estado Visualización del estado actual de la unidad SoftMotion Configuración de comunicación Visualización del estado de comunicación actual Error Error de eje Error de FB uiDriveInterfaceError strDriveInterfaceError Para más información, ver: Determinación del tiempo muerto del sistemaEjemplo Las siguientes imágenes demuestran el efecto de los diferentes tipos de rampa. La posición se dibuja en verde, la velocidad en azul y la aceleración en rojo. Trapezoide La velocidad es parcialmente lineal y continua, mientras que la aceleración parcialmente constante indica saltos. Sin² Las rupturas en el perfil de velocidad se suavizan (utilizando la función sin² en lugar de líneas) para reducir los saltos de aceleración. El usuario no puede limitar el tirón para este tipo de rampa. El tirón máximo establecido tiene efecto solo si la aceleración no es igual a cero al comienzo del movimiento y la rampa de desaceleración y aceleración interrumpida no puede continuar sin problemas. Luego, teniendo en cuenta el límite de tirones, la aceleración se reduce a cero antes de que se inicie el movimiento actual. En comparación con el perfil de velocidad trapezoidal, la desaceleración lleva más tiempo en este caso. Cuadrático La aceleración es parcialmente lineal y continua y el tirón tiene saltos. La velocidad consta de segmentos cuadráticos y lineales. Cuadrático (suave) Las rampas de aceleración lineal del tipo de rampa cuadrática se reemplazan por una función \"suave\" con un valor de pendiente cero al principio y al final. Como resultado, el tirón también es continuo. Nota: Si se interrumpe un movimiento, pueden producirse interrupciones en el tirón. Para obtener más información, consulte: Interrupción de movimientos" }, 
{ "title" : "Pestaña: Escalado\/Mapeo ", 
"url" : "_sm_edt_drive_scaling_mapping.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaz de usuario \/ SoftMotion Drives \/ Pestaña: Escalado\/Mapeo ", 
"snippet" : "En esta pestaña, puede definir la relación entre las unidades técnicas (por ejemplo, milímetros o grados) y las unidades de accionamiento (incrementos). Dependiendo de la descripción del dispositivo, las opciones de configuración se muestran simplificadas (parámetro bHiresMode = TRUE ), y \/ o escala...", 
"body" : "En esta pestaña, puede definir la relación entre las unidades técnicas (por ejemplo, milímetros o grados) y las unidades de accionamiento (incrementos). Dependiendo de la descripción del dispositivo, las opciones de configuración se muestran simplificadas (parámetro bHiresMode = TRUE ), y \/ o escalado para motores lineales también puede ser posible (parámetro IsLinearMotor = TRUE ). Si es necesario, también puede influir en la asignación de objetos de accionamiento transmitidos cíclicamente a variables IEC. Escalada Invertir dirección : Se invierte el sentido de giro. El motor obtiene los valores especificados con signos opuestos. Precisión (dígitos decimales) Requisito: La descripción del dispositivo especifica un cuadro de diálogo de configuración simplificado (parámetro bHiresMode = TRUE ). En este caso, las configuraciones ocultas obtienen el valor predeterminado de 1 . Número de posiciones decimales para las unidades de usuario de los incrementos a escalar y transferir. Por ejemplo, 3 corresponde a una precisión de 10 3 . incrementos <=> vueltas del motor Número de incrementos que corresponden a un número determinado de vueltas del motor. Puede ver el parámetro en el Configuración pestaña del editor de dispositivos. el motor gira <=> la salida del engranaje gira Número de vueltas del motor que corresponden a un número dado de vueltas de salida del engranaje. la salida del engranaje gira <=> unidades en la aplicación Número de vueltas de salida del engranaje que corresponden a una unidad en la aplicación. Ejemplo de una configuración completa En la configuración de muestra, un variador que tiene 3600 incrementos para un giro del motor se escala de modo que las unidades técnicas de la aplicación sean grados angulares rectos. Cartografía Nota: Estos parámetros no están disponibles para Drive_PosControl. Mapeo automático : Los parámetros IEC que afectan al variador se asignan automáticamente a las entradas y salidas correspondientes del dispositivo. Después de la desactivación de la opción, el mapeo se puede editar manualmente. Para hacer esto, cambie la dirección o el tipo de las entradas y salidas a la lista de parámetros mostrada que se creó de acuerdo con el archivo de descripción del dispositivo. " }, 
{ "title" : "Pestaña: Puesta en marcha ", 
"url" : "_sm_edt_drive_commisioning.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaz de usuario \/ SoftMotion Drives \/ Pestaña: Puesta en marcha ", 
"snippet" : "Puede mover la unidad mediante los botones de esta página. La unidad puede realizar movimientos inesperados. Tome todas las precauciones de seguridad necesarias. Esta pestaña se utiliza con fines de prueba al poner en marcha unidades físicas. Está disponible sólo si el Modo de configuración en línea...", 
"body" : "Puede mover la unidad mediante los botones de esta página. La unidad puede realizar movimientos inesperados. Tome todas las precauciones de seguridad necesarias. Esta pestaña se utiliza con fines de prueba al poner en marcha unidades físicas. Está disponible sólo si el Modo de configuración en línea está habilitado. En este modo, el sistema de desarrollo está conectado al dispositivo; sin embargo, no es necesario descargar una aplicación. En línea Requisito: el PLC está en modo online. Tabla de variables Lista de variables de unidad con nombre de variable, Valor ajustado y Valor actual Estado Visualización del estado actual de la unidad SoftMotion Configuración de comunicación Visualización del estado de comunicación actual Error Error de eje Error de FB uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "Elementos operativos ", 
"url" : "_sm_edt_drive_commisioning.html#UUID-44ff80c7-7f0e-b818-51b8-af95752bbbbd_id_b3c83ad0f91194c0a8646325634a44_id_063bbc9a58bd11e68fa9d28177272265", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaz de usuario \/ SoftMotion Drives \/ Pestaña: Puesta en marcha \/ Elementos operativos ", 
"snippet" : "Elementos operativos Poder El convertidor recibe alimentación (compárese con MC_Power ). Error de reinicio Reinicia la unidad después de un error (comparar con MC_Reset ). Empezar a buscar El variador ejecuta el homing con los parámetros establecidos en el variador (comparar con MC_Home ). Trotar Po...", 
"body" : "Elementos operativos Poder El convertidor recibe alimentación (compárese con MC_Power ). Error de reinicio Reinicia la unidad después de un error (comparar con MC_Reset ). Empezar a buscar El variador ejecuta el homing con los parámetros establecidos en el variador (comparar con MC_Home ). Trotar Por medio de los interruptores <y>, la unidad se puede mover hacia adelante y hacia atrás de acuerdo con los valores especificados para Distancia , Velocidad , Aceleración , Desaceleración , y Imbécil (Comparar con MC_Inch ). Leer escribir Para el parámetro de variador especificado, la corriente Valor se lee desde el PLC y se muestra. En Valor preparado , puede especificar un nuevo valor y escribir en el parámetro en la unidad mediante el botón pequeño (comparar con MC_ReadParameter , MC_WriteParameter ). " }, 
{ "title" : "Pestaña: SoftMotion Drive – Control de posición ", 
"url" : "_sm_edt_drive_poscontrol_position_control_loop.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaz de usuario \/ SoftMotion Drives \/ Pestaña: SoftMotion Drive – Control de posición ", 
"snippet" : "En esta pestaña, establece los parámetros para el control de posición. Tenga en cuenta también el ejemplo Control de posición en el controlador con SM_Drive_PosControl. Bucle de control de posición fSetPosition Establecer valor de posición D El tiempo muerto determina el número de ciclos en los que ...", 
"body" : "En esta pestaña, establece los parámetros para el control de posición. Tenga en cuenta también el ejemplo Control de posición en el controlador con SM_Drive_PosControl. Bucle de control de posición fSetPosition Establecer valor de posición D El tiempo muerto determina el número de ciclos en los que la posición real recibida (codificador) se desplaza de fase a la posición establecida del eje. El tiempo muerto depende de los componentes aplicados y debe determinarse mediante prueba y error. Para más información, ver: Determinación del tiempo muerto del sistemafActPosition Valor de posición real Ancho de bits El ancho de bits del valor real se recibe en función de los componentes utilizados y se puede establecer como valores de 16, 24 o 32 bits. Max : La supervisión de errores de posición está activada. Entrada del retraso máximo permitido Si se excede este valor durante el funcionamiento, el eje entra en un estado de error. Kp La constante de proporcionalidad es el factor por el cual se multiplica el error de posición (la desviación entre la posición establecida y la real) para agregarla más tarde a la velocidad establecida. fSetVelocity Establecer valor de velocidad Escalado de la salida de velocidad fActPosition y la salida de velocidad tienen direcciones opuestas : Si la salida de velocidad y la posición actual tienen una dirección opuesta, esto se corrige activando la opción. Aplicación [tu \/ s] Valor de velocidad mínima y máxima (en unidades de aplicación) por ejemplo 3600 rotaciones por segundo. Valor de salida Valor de salida mínimo y máximo que se envía al actuador (por ejemplo, 16 # 7FFF). " }, 
{ "title" : "Pestaña: Ejes Lógicos ", 
"url" : "_sm_edt_drive_logical_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaz de usuario \/ SoftMotion Drives \/ Pestaña: Ejes Lógicos ", 
"snippet" : "Tipo de eje Modulo : El accionamiento gira sin fin sin limitar el rango de desplazamiento (ejemplo: accionamiento por correa). Configuración de módulo Valor de módulo : Valor de un ciclo El valor se guarda en el fPositionPeriod parámetro de la AXIS_REF_SM3 bloque de funciones. Nota: si selecciona el...", 
"body" : "Tipo de eje Modulo : El accionamiento gira sin fin sin limitar el rango de desplazamiento (ejemplo: accionamiento por correa). Configuración de módulo Valor de módulo : Valor de un ciclo El valor se guarda en el fPositionPeriod parámetro de la AXIS_REF_SM3 bloque de funciones. Nota: si selecciona el Modulo tipo de unidad, luego el producto fPositionPeriod * dwRatioTechUnitsDenom tiene que ser un número entero. Finito : El convertidor tiene un área de trabajo fija (ejemplo: un convertidor lineal). Negativo : Campo de entrada para el valor límite negativo Positivo : Campo de entrada para el valor límite positivo Valor de referencia maestro Colocar : El valor ajustado del maestro se utiliza como entrada para el eje lógico y la compensación del tiempo muerto. Real : El valor real del maestro se utiliza como entrada para el eje lógico y la compensación del tiempo muerto. Desplazamiento de tiempo Desfase de tiempo relativo a los valores maestros Número de ciclos Los valores establecidos deben extrapolarse en este lapso de tiempo Filtros de datos de entrada Con los filtros, es posible suavizar los valores de posición y velocidad de un codificador utilizando un filtro PT1. Posición Número de ciclos utilizados como constante de tiempo del filtro PT1. Rango de valores: [0..999.9] Valor 0: no se realiza ningún filtrado (se devuelven valores sin procesar). El valor de retorno filtrado es una combinación de una señal de posición filtrada PT1 y una extrapolación de posición adicional utilizando la señal de velocidad. La propia extrapolación también utiliza un filtro PT1 para mitigar el ruido y selecciona automáticamente una constante de tiempo adecuada: Si solo se deben filtrar los valores establecidos o el eje envía la señal de velocidad, entonces la constante de tiempo de la extrapolación PT1 es la misma que para el filtro de posición PT1. De lo contrario, se utiliza un enfoque heurístico: T Extrapolate = (T Pos + T Dead ) * T Pos \/ T Cycle T Extrapolate : Constante de tiempo del filtro de extrapolación PT1 T Pos : Constante de tiempo del filtro de posición PT1 T Cycle : Tiempo del ciclo TDead : Compensación de tiempo muerto, utilizando el cambio de tiempo relativo a los valores maestros del eje lógico nShift  y el tiempo del ciclo T Cycle : TDead = nShift * T Cycle Velocidad Número de ciclos utilizados como constante de tiempo del filtro PT1. Rango de valores: [0..999.9] Valor 0: no se realiza ningún filtrado (se devuelven valores sin procesar). El valor de retorno filtrado es una combinación de una señal de velocidad filtrada PT1 y una extrapolación de velocidad adicional utilizando la señal de aceleración. Tenga en cuenta que la extrapolación se usa solo si el eje envía una señal de velocidad o si se deben filtrar los puntos de ajuste. La propia extrapolación también utiliza un filtro PT1 para mitigar el ruido y selecciona automáticamente una constante de tiempo adecuada: T Extrapolate = (T Vel + T Dead ) * T Vel \/ T Cycle con T Extrapolate : Constante de tiempo del filtro de extrapolación PT1 T Vel : Constante de tiempo del filtro de velocidad PT1 T Cycle : Tiempo del ciclo T Dead : Compensación de tiempo muerto, utilizando el cambio de tiempo relativo a los valores maestros del eje lógico  n Shift  y el tiempo del ciclo  T Cycle : T Dead = n Shift * T Cycle Señal de velocidad del eje lógico ( fActVelocity ): Caso 1: Valor de referencia maestro = Establecer fSetVelocity del eje maestro se utiliza como valor bruto para la señal de velocidad del eje lógico. Caso 2: Valor de referencia maestro = Actual y sin señal de velocidad del eje maestro. La derivada numérica de la posición filtrada del eje lógico ( fActPosition ) se utiliza como valor bruto para la señal de velocidad del eje lógico. Caso 3: Valor de referencia maestro = Actual y una señal de velocidad del eje maestro. La señal de velocidad se utiliza como valor bruto para la señal de velocidad del eje lógico. El filtrado de velocidad se realiza en esta señal sin procesar. Esto quiere decir que si se configura con el valor por defecto usiFilterDepthVelocity = 0 , entonces esta señal se pasa sin cambios a fActVelocity . En el caso 2, también sería posible utilizar la derivada numérica de la posición sin filtrar ( fActPosition del eje maestro). Se ha seleccionado la posición filtrada porque en este caso la fActVelocity del eje lógico coincide con el fActPosition en la configuración por defecto sin filtrado de velocidad. Para la velocidad, la extrapolación del retardo del filtro se realiza solo en los casos 1 y 3. En el caso 2, esto no sería numéricamente estable o requeriría demasiado filtrado de la aceleración para ser significativo. Aceleración del eje lógico ( fActAcceleration ) Caso 1: Valor de referencia maestro = Establecer fSetAcceleration del eje maestro se utiliza para la señal de aceleración del eje lógico. Caso 2: Valor de referencia maestro = Actual y una señal de velocidad del eje maestro. La derivada numérica de la velocidad filtrada del eje lógico ( fActVelocity ) se utiliza para la señal de aceleración del eje lógico. Caso 3: Valor de referencia maestro = Actual y sin señal de velocidad del eje maestro. El valor 0 se utiliza para la señal de aceleración del eje lógico porque la diferenciación de una posición ruidosa dos veces conduce a resultados inutilizables. Tirón del eje lógico ( fActJerk ) El tirón del eje lógico ( fActJerk ) es cualquiera Caso 1: Valor de referencia maestro = Establecer fSetJerk del eje maestro se utiliza para la señal de jaloneo del eje lógico. Caso 2: Valor de referencia maestro = Actual El valor 0 se utiliza para la señal de tirón del eje lógico porque la diferenciación de una señal de posición ruidosa tres veces conduce a resultados inutilizables. No se realiza ninguna compensación de tiempo muerto para la señal de aceleración y tirones. Todos los valores establecidos (posición, velocidad, aceleración y tirones) del eje lógico corresponden a los valores reales. Escribir valores Escribe los valores de Filtros de datos de entrada y Desplazamiento de tiempo en el PLC. Identificación IDENTIFICACIÓN ID único del eje lógico En línea Requisito: el PLC está en modo online. Tabla de variables Lista de variables de unidad con nombre de variable, Valor ajustado y Valor actual Estado Visualización del estado actual de la unidad SoftMotion Configuración de comunicación Visualización del estado de comunicación actual Error Error de eje Error de FB uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "Pestaña: Codificador ", 
"url" : "_sm_edt_drive_free_encoder_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaz de usuario \/ SoftMotion Drives \/ Pestaña: Codificador ", 
"snippet" : "Configuración general del codificador Modulo En un variador de módulo, esta opción debe estar activada y Valor de módulo especificado. : El accionamiento gira sin cesar sin limitar el rango de desplazamiento (ejemplo: transmisión por correa). los Configuración de módulo se muestra la ventana: Valor ...", 
"body" : "Configuración general del codificador Modulo En un variador de módulo, esta opción debe estar activada y Valor de módulo especificado. : El accionamiento gira sin cesar sin limitar el rango de desplazamiento (ejemplo: transmisión por correa). los Configuración de módulo se muestra la ventana: Valor de módulo : Campo de entrada para el valor del módulo El valor se guarda en el fPositionPeriod parámetro de la AXIS_REF_SM3 bloque de funciones. Nota: si selecciona el Modulo tipo de unidad, luego el producto fPositionPeriod * dwRatioTechUnitsDenom tiene que ser un número entero. Finito : La unidad es limitada. Ancho de bits Cuadro de lista para un ancho de bit apropiado Escalada Definición de la conversión de los valores posicionales enteros que envía el dispositivo; en incrementos y unidades técnicas que se utilizan en una aplicación IEC. Invertir dirección : El codificador recibe los valores especificados con signos invertidos y, por lo tanto, gira en el sentido de giro opuesto. incrementos <=> rotaciones del codificador Número de incrementos que corresponden al número de completos rotaciones del codificador rotaciones del codificador <=> unidades en la aplicación Número de el codificador gira que corresponden a unidades en aplicación En línea Requisito: el PLC está en modo online. Tabla de variables Lista de variables de unidad con nombre de variable, Valor ajustado y Valor actual Estado Visualización del estado actual de la unidad SoftMotion Configuración de comunicación Visualización del estado de comunicación actual Error Error de eje Error de FB uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "CODESYS Softmotion Basic ", 
"url" : "_sm_basic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Descripción general ", 
"url" : "_sm_overview_basic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Descripción general ", 
"snippet" : "CODESYS Softmotion Basic Proporciona una interfaz para bloques de funciones para el control de movimiento de ejes individuales. Esta interfaz se basa en la especificación PLCopen \"Bloques de función para control de movimiento Parte 1 V2.0\". La planificación de trayectoria se realiza en el CODESYS co...", 
"body" : "CODESYS Softmotion Basic Proporciona una interfaz para bloques de funciones para el control de movimiento de ejes individuales. Esta interfaz se basa en la especificación PLCopen \"Bloques de función para control de movimiento Parte 1 V2.0\". La planificación de trayectoria se realiza en el CODESYS controlador. La gama de funciones abarca desde el movimiento hasta una posición o velocidad objetivo, pasando por la superposición de dos movimientos y movimientos sincronizados, pasando por engranajes y levas virtuales. Los comandos de movimiento se pueden almacenar y cancelar con precisión de ciclo, así como desacelerar o detener y reanudar mediante anulación. " }, 
{ "title" : "Empezar con CODESYS Softmotion Basic ", 
"url" : "_sm_basic_first_steps.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Empezar con CODESYS Softmotion Basic ", 
"snippet" : "Para programar un movimiento con CODESYS Softmotion Basic , es necesario configurar al menos un eje en el árbol de dispositivos. Esto incluye configurar el tipo de eje ( módulo o finito ), el tipo de rampa de velocidad, los finales de carrera por software y la reacción ante errores. Puede encontrar ...", 
"body" : "Para programar un movimiento con CODESYS Softmotion Basic , es necesario configurar al menos un eje en el árbol de dispositivos. Esto incluye configurar el tipo de eje ( módulo o finito ), el tipo de rampa de velocidad, los finales de carrera por software y la reacción ante errores. Puede encontrar una descripción general de los tipos de movimiento admitidos en la Movimientos de un solo eje capítulo. Para obtener información sobre cómo programar un movimiento de un solo eje, consulte la Controlar el movimiento de ejes individuales capítulo. Para obtener más información sobre el uso básico de las levas, consulte la Control de una unidad de levas con un eje de tiempo virtual capítulo. Para obtener información sobre cómo almacenar en búfer, mezclar y superponer movimientos, consulte la Dirigiendo múltiples movimientos sección. Para más información, ver: Visión general de CámarasCapítulo: Cambiar entre cámarasCreación de una cámara online desde la aplicación: Estructuras de datos de levas.Capítulo: Adaptación dinámica con MC_SetOverride" }, 
{ "title" : "Bloques de funciones administrativas ", 
"url" : "_sm_administrative_fbs.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Bloques de funciones administrativas ", 
"snippet" : "Los bloques de funciones administrativas se utilizan para consultar información o cambiar ajustes específicos. Sin embargo, nunca desencadenan un movimiento. Una unidad física (denominada unidad de ahora en adelante) se representa en CODESYS SoftMotion por el objeto de software AXIS_REF_SM3 (denomin...", 
"body" : "Los bloques de funciones administrativas se utilizan para consultar información o cambiar ajustes específicos. Sin embargo, nunca desencadenan un movimiento. Una unidad física (denominada unidad de ahora en adelante) se representa en CODESYS SoftMotion por el objeto de software AXIS_REF_SM3 (denominado eje de ahora en adelante). Según el bloque de funciones administrativas que se utilice, la ejecución se lleva a cabo en la unidad, en el eje o en ambos. Bloques de funciones MC_Power Controla la fase de potencia de la unidad MC_Reset Restablece los errores de eje y conducción MC_SetPosition Cambia el sistema de coordenadas del eje a cualquier valor; por ejemplo, esto puede resultar útil como referencia. SMC3_BrakeControl Controla el freno mecánico cuando la transmisión admite esta función SMC3_BrakeStatus Lee el estado actual del freno mecánico SMC_ChangeDynamicLimits Establece los límites dinámicos (velocidad, aceleración, desaceleración, tirón y par) de un eje Para obtener más información, consulte lo siguiente: Límites dinámicos en Pestaña: GeneralSMC_ChangeAxisScalingLinear Cambia la escala de un eje lineal SMC_ChangeAxisScalingRotary Cambia la escala de un eje giratorio SMC_SetForecast Establece el Pronóstico de un eje SMC_GetForecast Devuelve la previsión establecida del eje SMC_GetTravelTime Devuelve el momento en que el eje alcanza una posición específica. Esto es especialmente útil cuando se combina con Pronóstico. SMC_SetAdditionalConversionFactors Establece factores adicionales para la conversión. Por ejemplo, el factor de par se puede utilizar para tener en cuenta una caja de cambios SMC_SetControllerMode Establece un modo de funcionamiento diferente para el eje cuando el variador admite esta función SMC_SetMovementType Establece el tipo de movimiento de un eje virtual en limitado o módulo Para obtener más información, consulte lo siguiente: Pestaña: General. SMC_SetRampType Establece el tipo de rampa de velocidad de un eje Para obtener más información, consulte lo siguiente: Tipo de rampa de velocidad en el Pestaña: General capítulo SMC_SetSoftwareLimits Establece los límites de posición para ejes limitados y la reacción correspondiente en caso de error Para obtener más información, consulte lo siguiente: Conmutadores de límite de software y Reacción de error de software en el Pestaña: General capítulo MC_TouchProbe Devuelve la posición de conducción cuando se produce un evento de activación definido MC_AbortTrigger Anula las funciones que utilizan eventos desencadenantes (ejemplo: MC_TouchProbe ) SMC_ReadFBError Devuelve la entrada más antigua de la memoria de errores del bloque de funciones del eje. Esta información se puede usar para mostrarla en una visualización, por ejemplo. SMC_ClearFBError Elimina la entrada más antigua de la memoria de errores del bloque de funciones del eje. SMC_ReadSetPosition Devuelve la posición establecida del eje SMC_ReadSetValues Devuelve la posición establecida, la velocidad establecida, la aceleración y la sacudida establecida. ¿Cuándo Pronóstico está habilitada, los datos también se pueden consultar en el futuro. Para obtener más información, consulte lo siguiente: SMC_SetForecast MC_ReadActualPosition Devuelve la posición real de la unidad MC_ReadActualVelocity Devuelve la velocidad real de la unidad MC_ReadActualTorque Devuelve el par real o la fuerza real de la transmisión MC_ReadAxisError Lee el error de la unidad MC_ReadStatus Lee el estado actual del eje SMC_CheckAxisCommunication Devuelve el estado de comunicación del eje SMC_CheckLimits Comprueba si los valores establecidos actuales superan los límites dinámicos establecidos del eje Para obtener más información, consulte lo siguiente: SMC_ChangedynamicLimits y Límites dinámicos en Pestaña: GeneralSMC_GetTrackingError Devuelve el desfase del eje (diferencia entre la posición establecida del eje y la posición real del variador) SMC_InPosition Devuelve si el retraso está dentro de un rango configurable SMC_MeasureDistance Devuelve la distancia recorrida por el eje desde que se inició el bloque. Esto es especialmente útil para los ejes de los módulos MC_ReadBoolParameter Lee un valor booleano del eje o la unidad MC_ReadParameter Lee un valor del eje o la unidad MC_WriteBoolParameter Escribe un valor booleano en el eje o la unidad MC_WriteParameter Escribe un valor en el eje o en la unidad Bloques de funciones de diagnóstico SMC_AxisDiagnosticLog Escribe los valores establecidos y los valores reales (posición, velocidad y aceleración) del eje y la conducción de forma cíclica en un archivo. Esto puede resultar útil para el diagnóstico de errores y secuencias de movimiento en otras herramientas SMC_GetMaxSetVelocity Registra el valor máximo de la velocidad establecida del eje. Este bloque de funciones puede resultar útil para fines de diagnóstico. SMC_GetMaxSetAccDec Registra el valor máximo de la aceleración establecida del eje. Este bloque de funciones puede resultar útil para fines de diagnóstico. Persistir SMC3_PersistPosition Conserva la posición de un eje con codificador absoluto Para obtener más información sobre «Persist», consulta lo siguiente: Persistencia de una posición del ejeSMC3_PersistPositionLogical Persiste en la posición de un eje lógico Para obtener más información acerca de los ejes lógicos, consulte lo siguiente: Unidad lógica" }, 
{ "title" : "Movimientos de un solo eje ", 
"url" : "_sm_basic_single_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos de un solo eje ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Descripción general ", 
"url" : "_sm_overview_single_axis_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos de un solo eje \/ Descripción general ", 
"snippet" : "CODESYS SoftMotion distingue entre movimientos que actúan sólo sobre un único eje y movimientos en los que dos ejes están sincronizados (por ejemplo, mediante levas electrónicas o engranajes virtuales). Este último se describe en el Movimientos sincrónicos de dos ejes página de ayuda. Básicamente, l...", 
"body" : "CODESYS SoftMotion distingue entre movimientos que actúan sólo sobre un único eje y movimientos en los que dos ejes están sincronizados (por ejemplo, mediante levas electrónicas o engranajes virtuales). Este último se describe en el Movimientos sincrónicos de dos ejes página de ayuda. Básicamente, los bloques de movimiento que actúan sólo sobre un único eje se pueden subdividir en las siguientes categorías: Bloques de movimiento Bloquear Descripción MC_MoveAbsolute Ejecuta un movimiento a la posición especificada. MC_MoveRelative Ejecuta un movimiento por la distancia especificada en relación con la posición actual MC_MoveAdditive Ejecuta un movimiento a la distancia especificada en relación con la última posición objetivo ordenada de otro movimiento (por ejemplo, desde MC_MoveAbsolute ) MC_MoveSuperimposed Ejecuta un movimiento por la distancia relativa especificada además de otro movimiento activo (por ejemplo, desde MC_MoveAbsolute ). El movimiento activo no se cancela. MC_MoveVelocity Ejecuta un movimiento continuo a la velocidad especificada. SMC_MoveContinuousAbsolute Ejecuta un movimiento a la posición especificada. En este caso se alcanza la posición objetivo con una velocidad definida que se mantiene posteriormente. SMC_MoveContinuousRelative Ejecuta un movimiento de la distancia especificada con respecto a la posición actual. En este caso se alcanza la posición objetivo con una velocidad definida que se mantiene posteriormente. MC_Jog Ejecuta un movimiento continuo a la velocidad especificada siempre que el eje se mueva hacia adelante o hacia atrás. SMC_Inch Ejecuta un movimiento por la distancia especificada en relación con la posición actual siempre que el eje deba moverse hacia adelante o hacia atrás. Paralización de movimientos Bloquear Descripción MC_Halt Ejecuta una parada controlada, interrumpe cualquier movimiento activo y detiene el eje. MC_Halt Está previsto para condiciones normales de funcionamiento porque la parada puede verse interrumpida por nuevos movimientos. Además, el funcionamiento se puede reanudar más fácilmente después de una parada porque el eje permanece en estado operativo. MC_Stop Ejecuta una parada controlada, interrumpe cualquier movimiento activo y detiene el eje. MC_Stop Está destinado a situaciones de emergencia porque la parada no puede ser interrumpida por nuevos movimientos. Una vez realizada la parada, el eje queda en estado de parada para que no se acepten nuevos movimientos. Sólo es posible volver a realizar nuevos movimientos una vez finalizada la parada y Execute la entrada está configurada en FALSE . MC_HaltSuperImposed Ejecuta una parada controlada de SuperImposed movimientos. El movimiento subyacente no se interrumpe en el proceso. Buscador de blancos Bloquear Descripción MC_Home Inicia un homing del eje controlado por el variador. El funcionamiento y sus parámetros dependen del variador y del fabricante. SMC_Homing Inicia un homing del eje controlado por el controlador. MC_SetPosition No mueve el eje, solo desplaza el punto cero. De este modo, el bloque se puede utilizar, por ejemplo, como referencia. Además, el bloque también se puede llamar durante un movimiento activo. Movimientos especiales Bloquear Descripción SMC_FollowPosition Escribe la posición establecida del eje. Esto se puede utilizar para pasar sus propias trayectorias calculadas al eje. SMC_FollowVelocity Escribe la velocidad establecida del eje. Esto se puede utilizar para pasar sus propias trayectorias calculadas al eje. SMC_FollowPositionVelocity Escribe la posición y la velocidad establecidas del eje. Esto se puede utilizar para pasar sus propias trayectorias calculadas al eje. SMC_FollowSetValues Escribe selectivamente la posición, velocidad, aceleración, sacudida y\/o el par objetivo establecido del eje. Esto se puede utilizar para pasar sus propias trayectorias calculadas al eje. SMC_SetTorque Escribe el par ajustado del eje. Dependiendo del modo de funcionamiento del eje, el valor se utiliza para el control anticipativo del par o como el par que se supone que debe aplicar el eje. " }, 
{ "title" : "Interrupción de movimientos ", 
"url" : "_sm_interrupt_single_axis_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos de un solo eje \/ Interrupción de movimientos ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Interrupción de los movimientos de un solo eje ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_section-idm234855926060424", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos de un solo eje \/ Interrupción de movimientos \/ Interrupción de los movimientos de un solo eje ", 
"snippet" : "Movimientos de un solo eje, como MC_MoveAbsolute , puede interrumpirse en cualquier momento mediante otros movimientos. Puede tratarse de un movimiento hacia una posición diferente o de un cambio en la velocidad máxima, la aceleración o la sacudida con el mismo tipo de movimiento y hacia la misma po...", 
"body" : "Movimientos de un solo eje, como MC_MoveAbsolute , puede interrumpirse en cualquier momento mediante otros movimientos. Puede tratarse de un movimiento hacia una posición diferente o de un cambio en la velocidad máxima, la aceleración o la sacudida con el mismo tipo de movimiento y hacia la misma posición. La interrupción se implementa de tal manera que no se produce un salto en la velocidad. Para todos los tipos de rampas cuadráticas, tampoco hay ningún salto en la aceleración En casos específicos, la inversión del eje es inevitable debido al movimiento abortado: Si la nueva posición objetivo de un MC_MoveAbsolute existe antes del final de la distancia de desaceleración actual Si se utiliza una desaceleración máxima menor y\/o una sacudida máxima menor para el movimiento abortado, lo que a su vez extiende la distancia de desaceleración más allá de la posición objetivo Si SMC_MoveContinuousAbsolute o SMC_MoveContinuousRelative se usa con un EndVelocity al que no se puede llegar desde el estado actual del eje sin invertirlo Cuando la rampa escribe sin² y cuadrático (suave) se utilizan, puede producirse una inversión durante la interrupción, incluso si no parece necesaria. (Es decir, incluso si los motivos enumerados anteriormente no se aplican. Consulte las explicaciones que figuran a continuación.) Entonces, la nueva posición objetivo podría estar sobrerecorrida, aunque no esté ubicada antes de la posición objetivo anterior. Esto puede suceder incluso si la desaceleración máxima y la sacudida máxima no cambian (o incluso aumentan) y la velocidad final no cambia en comparación con el movimiento abortado. En este caso, se aplican las Para los tipos de rampas trapezoidales y cuadráticas, nunca hay ningún sobrerecorrido. Para el sin² tipo de rampa, no hay sobrerecorrido cuando la nueva posición objetivo y los valores límite de aceleración y deceleración son iguales a los valores anteriores. En todos los demás casos, es posible que se sobreviaje con sin² y cuadrático (suave) tipos de rampa. Explicación de la sin² tipo de rampa: el movimiento abortado comienza con una nueva rampa de velocidad sin², lo que significa que la aceleración comienza en 0 y aumenta o disminuye gradualmente. Si el eje tiene una aceleración distinta de 0 en el momento de abortar, la aceleración pasa a 0 al inicio de la rampa de velocidad sin². Esto puede provocar un sobreviaje, ya que aumentar o disminuir la Explicación de la cuadrático (suavizado) tipo de rampa: se aplica la misma explicación que para sin² , pero por la sacudida en vez de por la aceleración. Nota sobre la anulación Basándose en las explicaciones anteriores, utilizando MC_SetOverride con el sin² y cuadrático (suavizado) no se recomienda el tipo de rampa " }, 
{ "title" : "Interrupción durante la fase de desaceleración ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_id_fbc677d73098ed1c0a86463411e7edd_id_b5d8fdf3fc0362bfc0a8658d00b6a52e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos de un solo eje \/ Interrupción de movimientos \/ Interrupción durante la fase de desaceleración ", 
"snippet" : "Movimientos de un solo eje, como MC_MoveAbsolute , puede ser interrumpido en cualquier momento por otros movimientos. Esto puede ser un movimiento a otra posición o un cambio de velocidad o aceleración. Básicamente, la interrupción del movimiento es implementada por otro de tal manera que no hay sal...", 
"body" : "Movimientos de un solo eje, como MC_MoveAbsolute , puede ser interrumpido en cualquier momento por otros movimientos. Esto puede ser un movimiento a otra posición o un cambio de velocidad o aceleración. Básicamente, la interrupción del movimiento es implementada por otro de tal manera que no hay salto en la velocidad. Para todos los tipos de rampa (excepto trapezoide ), tampoco hay salto en la aceleración. Cuando los tipos de rampa pecado² y cuadrático (suave) se utilizan, una inversión puede ocurrir durante la interrupción y no parece necesaria al principio (ver explicación). Luego, la nueva posición de destino se recorre en exceso, aunque no se encuentra antes de la posición de destino anterior. Esto puede ocurrir en las siguientes situaciones: Si se establece un valor de desaceleración máxima más pequeño para el movimiento de cancelación que antes En este caso, la distancia de deceleración disponible hasta la nueva posición de destino es posiblemente demasiado corta (para todos los tipos de rampa). En consecuencia, por cuadrático y cuadrático (suave) Tipos de rampa cuando se establece un valor máximo más bajo para jerk Sin embargo, si estos valores máximos permanecen sin cambios (o aumentan), se aplican las siguientes reglas: Para trapezoide y cuadrático tipos de rampa, nunca hay sobrecarrera. Para el pecado² rampa, no hay sobrecarrera cuando la nueva posición de destino y los valores límite de aceleración y deceleración son iguales a los valores anteriores. En todos los demás casos, puede haber sobrecarrera con pecado² y cuadrático (suave) tipos de rampa " }, 
{ "title" : "Movimientos sincrónicos de dos ejes ", 
"url" : "_sm_basic_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Descripción general ", 
"url" : "_sm_overview_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Descripción general ", 
"snippet" : "Esta sección proporciona una descripción general de los movimientos para los cuales un eje se mueve sincrónicamente con otro eje (dependiendo del tiempo o la posición). Levas: Dependiendo de un accionamiento (maestro), otro accionamiento (esclavo) deberá ejecutar cualquier tipo de movimiento definid...", 
"body" : "Esta sección proporciona una descripción general de los movimientos para los cuales un eje se mueve sincrónicamente con otro eje (dependiendo del tiempo o la posición). Levas: Dependiendo de un accionamiento (maestro), otro accionamiento (esclavo) deberá ejecutar cualquier tipo de movimiento definido. Para más información, ver: CámarasSincronización de dos ejes con una relación de transmisión definida mediante MC_GearIn , MC_GearOut , y MC_GearInPos . Para obtener más información sobre estas funciones, consulte la documentación del bloque de funciones respectivo. Desplazamiento de fase entre un eje maestro y esclavo usando MC_Fase . Para obtener más información sobre esta función, consulte la documentación del bloque de funciones. Compensación del juego entre componentes mecánicos (por ejemplo, en una caja de cambios) mediante SMC_BacklashCompensación . Para obtener más información sobre esta función, consulte la documentación del bloque de funciones. " }, 
{ "title" : "Cámaras ", 
"url" : "_sm_f_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Descripción general ", 
"url" : "_sm_overview_synch_movements_2_axis_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Descripción general ", 
"snippet" : "El SoftMotion La cámara está integrada en la interfaz de usuario de CODESYS . En el editor de levas se pueden implementar levas y taqués de forma gráfica o mediante tablas. Tan pronto como se genera el código para la aplicación correspondiente, se crean estructuras de datos globales (\"Cam Data\") a l...", 
"body" : "El SoftMotion La cámara está integrada en la interfaz de usuario de CODESYS . En el editor de levas se pueden implementar levas y taqués de forma gráfica o mediante tablas. Tan pronto como se genera el código para la aplicación correspondiente, se crean estructuras de datos globales (\"Cam Data\") a las que puede acceder el programa IEC. Para este propósito, el SM3_Basic también se vincula automáticamente al proyecto al insertar una unidad SoftMotion. Para más información, ver: Definición de un y Cómo crear una cámara" }, 
{ "title" : "Definición de un SoftMotion Leva ", 
"url" : "_sm_cam_definition_softmotion_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Definición de un SoftMotion Leva ", 
"snippet" : "Una leva describe la dependencia funcional de un accionamiento (esclavo) de otro accionamiento (maestro). La relación se describe mediante una función continua (o curva) que asigna un rango definido de valores maestros a valores esclavos. Para ser más precisos: después de dividir el eje maestro en s...", 
"body" : "Una leva describe la dependencia funcional de un accionamiento (esclavo) de otro accionamiento (maestro). La relación se describe mediante una función continua (o curva) que asigna un rango definido de valores maestros a valores esclavos. Para ser más precisos: después de dividir el eje maestro en segmentos adecuados, el gráfico de estas funciones se puede representar en cada uno de estos intervalos mediante una línea o un polinomio de quinto grado. Ejemplo Los valores maestros se aplican al eje horizontal y los valores esclavos al eje vertical en el gráfico de levas. En el ejemplo, los valores maestros están entre 0 y 360. Este rango se divide en tres intervalos: (1) Primer intervalo: [0, 140] (2) Segundo intervalo: [140, 280] (3) Tercer intervalo: [280, 360] La función (gráfico) es lineal en el primer y tercer intervalo y su gráfico se muestra como una línea. Como resultado, su primera derivada (pendiente) es constante y todas las derivadas superiores son 0. En el segundo intervalo, el gráfico se describe mediante un polinomio de quinto grado. Por lo tanto, su primera derivada es un polinomio de cuarto grado, su segunda derivada (curvatura) es un polinomio de tercer grado, su tercera derivada es un polinomio de segundo grado, etc. Cuando la función describe el movimiento del esclavo en función de la posición del maestro, su primera derivada corresponde a la velocidad del esclavo y la segunda derivada a su aceleración. Cuando se tiene en cuenta esta interpretación física, es obvio que el mapeo tiene que ser continuo. Esto significa que su gráfico no puede tener saltos. En particular, la continuidad también debe cumplirse en cada punto donde se encuentran dos intervalos. Además, la continuidad en general también es requerida por la primera y segunda derivada. (De hecho, estas tres condiciones de continuidad en los puntos inicial y final de un intervalo determinan los coeficientes del polinomio de quinto grado insertado entre dos segmentos rectos. Además, puede agregar empujadores (interruptores binarios) a la leva en cualquier posición. De esta forma, puede crear tablas de leva que contengan solo empujadores. A continuación, la posición del esclavo se pone a cero en todo el rango de valores del maestro. " }, 
{ "title" : "Descripción general de los tipos de segmentos definidos ", 
"url" : "_sm_overview_segment_types.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Descripción general de los tipos de segmentos definidos ", 
"snippet" : "CODESYS SoftMotion proporciona varios tipos de segmentos para levas. Dependiendo de formato de compilación , solo se admiten algunos de los tipos de segmentos: XYVA: Solo Line y Poly5. Segmentos: se admiten todos los tipos de segmentos. Tipo de segmento Parámetros Curva Poly7 Condiciones límite Pues...", 
"body" : "CODESYS SoftMotion proporciona varios tipos de segmentos para levas. Dependiendo de formato de compilación , solo se admiten algunos de los tipos de segmentos: XYVA: Solo Line y Poly5. Segmentos: se admiten todos los tipos de segmentos. Tipo de segmento Parámetros Curva Poly7 Condiciones límite Puesto de maestro Posición de esclavo Velocidad del esclavo Aceleración esclava Imbécil esclavo Poly5 Condiciones límite Puesto de maestro Posición de esclavo Velocidad del esclavo Aceleración esclava ModifiedSine Condiciones límite Puesto de maestro Posición de esclavo Velocidad del esclavo Parámetros de segmento Cualquiera de los parámetros del punto de inflexión λ (0≤λ ≤1) O parámetro de aceleración C a * (desaceleración máxima) Line Condiciones límite Puesto de maestro Posición de esclavo InclinedSine Condiciones límite Puesto de maestro Posición de esclavo La selección del tipo de segmento depende de la aplicación, ya que cada tipo tiene propiedades dinámicas especiales. Hay varios tipos de segmentos aplicables en función de la tarea de movimiento (por ejemplo, permanencia: velocidad constante). En la tabla siguiente se ofrece una descripción general: Morar (v=0, a=0) Velocidad constante (v­­≠0, a=0) Reversión (v=0, a≠0) Movimiento (v≠0, a≠0) Morar (v=0, a=0) Line Poly5\/7 InclinedSine ModifiedSine Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 Velocidad constante (v≠0, a=0) Poly5\/7 ModifiedSine Line Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 Reversión (v=0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 Movimiento (v≠0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 " }, 
{ "title" : "Estructura del editor de leva ", 
"url" : "_sm_cam_editor_layout.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Estructura del editor de leva ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Descripción general ", 
"url" : "_sm_overview_synch_movements_2_axis_cam_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Estructura del editor de leva \/ Descripción general ", 
"snippet" : "Abra el editor de cámara haciendo doble clic en Leva objeto en el árbol de dispositivos. El editor consta de las siguientes pestañas: Pestaña: Cámara pestaña: En este editor, utiliza un editor gráfico para crear una ruta de leva. Aquí puede mostrar y modificar la posición del esclavo, la velocidad d...", 
"body" : "Abra el editor de cámara haciendo doble clic en Leva objeto en el árbol de dispositivos. El editor consta de las siguientes pestañas: Pestaña: Cámara pestaña: En este editor, utiliza un editor gráfico para crear una ruta de leva. Aquí puede mostrar y modificar la posición del esclavo, la velocidad del esclavo, la aceleración del esclavo y la sacudida del esclavo. En el editor gráfico reconoces muy rápidamente cuando programas un movimiento con alta aceleración. mesa de levas pestaña: En este editor, los puntos base se presentan en una tabla. Aquí puede especificar las posiciones y velocidades exactas. Taqués Pestaña: En este editor se programan los taqués (puntos de conmutación) en un diagrama. Esta pantalla proporciona una muy buena visión general del orden secuencial de los empujadores. Mesa taqué Pestaña: En este editor, los puntos de cambio se presentan en una tabla. Aquí puede especificar los puntos de conmutación exactos. Las pestañas se dividen en un editor, así como en un Caja de herramientas ver y Propiedades vista. Ejemplo de programa para utilizar el editor de cámaras " }, 
{ "title" : "Pestaña: Cámara ", 
"url" : "_sm_obj_cam_table_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Estructura del editor de leva \/ Pestaña: Cámara ", 
"snippet" : "En este editor gráfico, se definen los gráficos de levas. En cualquier momento, puede cambiar entre el editor gráfico y el editor tabular alternativo ( Pestaña: Tabla de leva). Las curvas de cuatro gráficos se muestran en el editor: Posición esclava (negro) Velocidad esclava (azul) Aceleración escla...", 
"body" : "En este editor gráfico, se definen los gráficos de levas. En cualquier momento, puede cambiar entre el editor gráfico y el editor tabular alternativo ( Pestaña: Tabla de leva). Las curvas de cuatro gráficos se muestran en el editor: Posición esclava (negro) Velocidad esclava (azul) Aceleración esclava (verde) Jerk esclavo (amarillo) El eje horizontal de los cuatro sistemas de coordenadas muestra el rango de los valores maestros ([0,360]). El eje vertical en el diagrama de posición muestra el rango de valores que se define en las propiedades de la leva. El eje vertical de velocidad, aceleración y tirón se escala automáticamente. Una nueva leva insertada se asigna con valores predeterminados. Consta de cuatro puntos que subdividen el gráfico en tres secciones: [0,120], [120,240] y [240,360]. Cada una de las partes de intervalo de los gráficos de levas es de tipo Poly5 (polinomio de 5º grado). Puede editar todas las curvas. Como la velocidad, la aceleración y la sacudida son curvas derivadas, un cambio en una de las gráficas también afecta a las demás. Cambia la altura del diagrama moviendo las barras de separación horizontales. Vista: Caja de herramientas Seleccione Seleccione una línea en la tabla usando esta herramienta. Los puntos seleccionados se eliminan presionando el Del llave. Agregar punto Agrega nuevos puntos con esta herramienta. Haga clic en el punto de inserción en el diagrama. A continuación, el gráfico se adapta automáticamente para que su curva pase por el nuevo punto insertado. Vista 'Propiedades' X Posición X del eje esclavo Y Posición Y del eje esclavo V Velocidad del eje esclavo A Aceleración del eje esclavo J Jerk del eje esclavo Para más información, ver: Diálogo: Propiedades – Cámara y Cómo crear una cámara" }, 
{ "title" : "Pestaña: Tabla de leva ", 
"url" : "_sm_obj_cam_table_cam_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Estructura del editor de leva \/ Pestaña: Tabla de leva ", 
"snippet" : "Como alternativa al editor gráfico, también puede definir los gráficos de levas en la tabla de levas ( Leva pestaña). Puede cambiar entre el editor tabular y el editor gráfico en cualquier momento. La primera línea de la tabla siempre contiene la posición de inicio del maestro (y los valores de escl...", 
"body" : "Como alternativa al editor gráfico, también puede definir los gráficos de levas en la tabla de levas ( Leva pestaña). Puede cambiar entre el editor tabular y el editor gráfico en cualquier momento. La primera línea de la tabla siempre contiene la posición de inicio del maestro (y los valores de esclavo relacionados) y la última línea es siempre la posición final. Las líneas intermedias definen alternativamente segmentos y puntos. Inserta una nueva línea Elimina el segmento seleccionado X Posición X del eje esclavo Y Posición Y del eje esclavo V Velocidad del eje esclavo A Aceleración del eje esclavo J Jerk del eje esclavo Tipo de segmento Line : Línea Poly5 : polinomio de quinto grado Poly7 : polinomio de séptimo grado InclinedSine : Línea sinusoidal inclinada ModifiedSine : línea sinusoidal modificada Lambda Parámetros del punto de inflexión para la línea sinusoidal modificada Parámetros de aceleración Parámetros de retardo máximo para la línea sinusoidal modificada Los siguientes valores resultan de los valores del segmento respectivo. No se pueden modificar. min (posición) Valor mínimo de la posición del esclavo max (posición) Valor máximo de la posición del esclavo Velocidad máxima) Valor máximo de la velocidad del esclavo, basado en el eje maestro max (aceleración) Valor máximo de la aceleración del esclavo, basado en el eje maestro Vista: Caja de herramientas Seleccione Seleccione una línea en la tabla usando esta herramienta. Los puntos seleccionados se eliminan presionando el Del llave. Para más información, ver: Diálogo: Propiedades – Cámara y Cómo crear una cámara" }, 
{ "title" : "Pestaña: Empujadores ", 
"url" : "_sm_obj_cam_table_tappets.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Estructura del editor de leva \/ Pestaña: Empujadores ", 
"snippet" : "En este editor gráfico, se definen las rutas de los taqués. Una trayectoria de empujadores define uno o más empujadores según la posición del maestro. En el borde superior de la ventana del editor, un eje horizontal se acerca al rango de las posiciones maestras. A continuación se muestran las rutas ...", 
"body" : "En este editor gráfico, se definen las rutas de los taqués. Una trayectoria de empujadores define uno o más empujadores según la posición del maestro. En el borde superior de la ventana del editor, un eje horizontal se acerca al rango de las posiciones maestras. A continuación se muestran las rutas de los taqués individuales. En cualquier momento, puede cambiar entre el editor gráfico y el editor tabular alternativo ( Pestaña: Mesa de taqués). \"ID de pista\" de la ruta del taqué Todos los empujadores de una trayectoria de empujadores se refieren al mismo interruptor de empujadores (una variable de tipo BOOL). Vista: Caja de herramientas Seleccione Utilice esta herramienta para seleccionar los taqués. Puede arrastrar los taqués seleccionados a otra posición. Puede modificar el atributo de encendido \/ apagado de un empujador haciendo clic en el extremo correspondiente del línea cruzada. Elimine el empujador seleccionado presionando el Del llave. Agregue nuevos taqués con esta herramienta. Haga clic en el punto de inserción en la ruta. Vista 'Propiedades' El taqué se asigna a un resultado, si se pasa desde la posición del eje maestro en la dirección positiva (valores maestros en aumento) o negativa. X Posición del taqué Pase positivo Activar \/ desactivar atributo Ninguna acción Cambiar a ON Cambiar a APAGADO Invertir Pase negativo Activar \/ desactivar atributo Ninguna acción Cambiar a ON Cambiar a APAGADO Invertir Tabla de posibles combinaciones de atributos de taqués Símbolo de empujador Pase positivo Pase negativo Ninguna acción Ninguna acción Cambiar a ON Ninguna acción Cambiar a APAGADO Ninguna acción Ninguna acción Cambiar a ON Ninguna acción Cambiar a APAGADO Cambiar a ON Cambiar a APAGADO Cambiar a ON Cambiar a APAGADO Cambiar a APAGADO Cambiar a ON Cambiar a APAGADO Cambiar a APAGADO Invertir Ninguna acción Ninguna acción Invertir Cambiar a ON Invertir Invertir Cambiar a ON Invertir Cambiar a APAGADO Cambiar a APAGADO Invertir Invertir Invertir Para más información, ver: Cómo definir puntos de conmutación" }, 
{ "title" : "Pestaña: Mesa de taqués ", 
"url" : "_sm_obj_cam_table_tappet_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Estructura del editor de leva \/ Pestaña: Mesa de taqués ", 
"snippet" : "En esta tabla tabular, también puede configurar las rutas de los taqués como una alternativa al editor gráfico ( Pestaña: Empujadores). Una trayectoria de empujadores define uno o más empujadores según la posición del maestro. En la tabla, las líneas con las definiciones de los respectivos taqués se...", 
"body" : "En esta tabla tabular, también puede configurar las rutas de los taqués como una alternativa al editor gráfico ( Pestaña: Empujadores). Una trayectoria de empujadores define uno o más empujadores según la posición del maestro. En la tabla, las líneas con las definiciones de los respectivos taqués se enumeran debajo de cada línea que define una ruta de taqués. Puede cambiar entre el editor tabular y el editor gráfico en cualquier momento. Inserta un nuevo empujador Elimina el taqué Identificador de pista ID de la ruta del taqué Todos los empujadores de una trayectoria de empujadores se refieren al mismo interruptor de empujadores (una variable de tipo BOOL). X Posición del taqué Pase positivo Activar \/ desactivar atributo Ninguna acción Cambiar a ON Cambiar a APAGADO Invertir Pase negativo Activar \/ desactivar atributo Ninguna acción Cambiar a ON Cambiar a APAGADO Invertir Vista: Propiedades El taqué se asigna a un resultado, si se pasa desde la posición del eje maestro en la dirección positiva (valores maestros en aumento) o negativa. X Posición del taqué Pase positivo Activar \/ desactivar atributo Ninguna acción Cambiar a ON Cambiar a APAGADO Invertir Pase negativo Activar \/ desactivar atributo Ninguna acción Cambiar a ON Cambiar a APAGADO Invertir Para más información, ver: Cómo definir puntos de conmutación" }, 
{ "title" : "Cómo crear una cámara ", 
"url" : "_sm_cam_creating_a_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Cómo crear una cámara ", 
"snippet" : "Los pasos para crear una leva se explican mediante una aplicación de ejemplo que describe una mesa giratoria con ocho ranuras (división de 45°). En el interior, hay un componente que se fusiona ultrasónicamente. La herramienta de soldadura es alimentada por un accionamiento lineal después de que la ...", 
"body" : "Los pasos para crear una leva se explican mediante una aplicación de ejemplo que describe una mesa giratoria con ocho ranuras (división de 45°). En el interior, hay un componente que se fusiona ultrasónicamente. La herramienta de soldadura es alimentada por un accionamiento lineal después de que la mesa giratoria haya girado. Después de soldar, el eje lineal regresa y la mesa giratoria continúa girando. pasos de trabajo La mesa giratoria gira 45° (duración: 400 ms). El cabezal de soldadura se mueve hacia abajo por un eje vertical de 250 mm (duración: 200 ms). Empezar a soldar (duración: 1200 ms). El cabezal de soldadura se mueve hacia arriba por un eje vertical de 250 mm (duración: 200 ms). De los tiempos totales resulta un tiempo de ciclo de 2000 ms. La aplicación se implementa mediante un eje maestro virtual que se ejecuta de forma continua (módulo). El valor final del eje se proyecta según el tiempo de ciclo de 2000 ms. La mesa giratoria se realiza como una leva (módulo; valor final: 45°). El eje vertical también se realiza como una leva (restringida; valor final: 300 mm). El proceso de soldadura es controlado por un empujador. Configuración de las propiedades de la leva Selecciona el mesa giratoria cam en el árbol de dispositivos. Hacer clic Propiedades en el Vista menú o en el menú contextual. Selecciona el Leva pestaña. Especifique los siguientes valores: Posición de inicio maestro : 0 Posición final maestra : 2000 Posición de inicio del esclavo : 0 Posición final del esclavo : 45 Transición suave : (discapacitado) Hacer clic OK para salir del diálogo. Confirme el cuadro de diálogo para cambiar el objeto de leva. Cambiar los valores de Eje vertical cam de la misma manera: Posición de inicio maestro : 0 Posición final maestra : 2000 Posición de inicio del esclavo : 0 Posición final del esclavo : 300 Transición suave : (activado) Hacer clic OK para salir del diálogo. Confirme el cuadro de diálogo para cambiar el objeto de leva. " }, 
{ "title" : "Adición de una cámara al árbol de dispositivos ", 
"url" : "_sm_cam_creating_a_cam.html#UUID-7c227a8f-47be-4a95-ca96-f0cd1d78635d_id_edb85f246cc9d9f4c0a8646368ed3bd6_id_fa86c256038b2152c0a864632d864483", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Cómo crear una cámara \/ Adición de una cámara al árbol de dispositivos ", 
"snippet" : "Requisito: se ha seleccionado un controlador SoftMotion. En el árbol de dispositivos, seleccione el Solicitud objeto. Hacer clic Proyecto → Agregar objeto → Tabla de leva . Especificar el nombre mesa giratoria para la cámara y haga clic OK . El objeto se inserta en el árbol de dispositivos. Se abre ...", 
"body" : "Requisito: se ha seleccionado un controlador SoftMotion. En el árbol de dispositivos, seleccione el Solicitud objeto. Hacer clic Proyecto → Agregar objeto → Tabla de leva . Especificar el nombre mesa giratoria para la cámara y haga clic OK . El objeto se inserta en el árbol de dispositivos. Se abre el editor de cámaras. Inserte otra cámara llamada Eje vertical . " }, 
{ "title" : "Cómo cambiar la ruta de la cámara ", 
"url" : "_sm_cam_changing_the_course.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Cómo cambiar la ruta de la cámara ", 
"snippet" : "Estas instrucciones utilizan el ejemplo de la Cómo crear una cámara capítulo para demostrar cómo cambiar una leva....", 
"body" : "Estas instrucciones utilizan el ejemplo de la Cómo crear una cámara capítulo para demostrar cómo cambiar una leva. " }, 
{ "title" : "Cambiar la ruta con el editor gráfico ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_0e7e8ac72c554f26c0a86463347ccca5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Cómo cambiar la ruta de la cámara \/ Cambiar la ruta con el editor gráfico ", 
"snippet" : "Abre el mesa giratoria cámara en el editor. El Leva la pestaña es visible. Seleccione el punto en 120 y elimínelo presionando la tecla eliminar ( Supr ). También elimine el punto en 240. Selecciona el Añadir punto herramienta de la Caja de herramientas vista. El puntero del mouse se convierte en una...", 
"body" : "Abre el mesa giratoria cámara en el editor. El Leva la pestaña es visible. Seleccione el punto en 120 y elimínelo presionando la tecla eliminar ( Supr ). También elimine el punto en 240. Selecciona el Añadir punto herramienta de la Caja de herramientas vista. El puntero del mouse se convierte en una cruz cuando lo mueve al editor. Haga clic cerca posición de maestro 400 y posición de esclavo 45 en los gráficos superiores (posición de esclavo). Se cambia la curva de la posición del esclavo. Las curvas de velocidad, aceleración y sacudida también cambian. Seleccione el nuevo punto insertado haciendo clic en él. Arrastre el punto a otra posición. La curva de la posición del esclavo se ajusta en consecuencia. Cambiar el X y Y propiedades a los valores exactos de 400 y 45, respectivamente. De la misma manera, cambie el valor X a 45 del punto en la posición maestra 2000. Selecciona el Seleccione herramienta de la Caja de herramientas vista. Seleccione el segundo elemento de la curva (entre 400 y 2000). Cambiar el Tipo de segmento propiedad a Línea . Compruebe la curva en el editor gráfico. Monitor: " }, 
{ "title" : "Cambiando la ruta con una mesa de levas ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_a888a2ff556a11e6abf6d2d0503b3e46", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Cómo cambiar la ruta de la cámara \/ Cambiando la ruta con una mesa de levas ", 
"snippet" : "Abre el Eje vertical cámara en el editor. El Leva la pestaña es visible. Selecciona el mesa de levas pestaña. Haga clic en el símbolo para eliminar el punto en 120. También elimine el punto en 240. Haga clic en el símbolo. Se insertan un nuevo punto y un nuevo segmento en (1000\/150). Añade dos punto...", 
"body" : "Abre el Eje vertical cámara en el editor. El Leva la pestaña es visible. Selecciona el mesa de levas pestaña. Haga clic en el símbolo para eliminar el punto en 120. También elimine el punto en 240. Haga clic en el símbolo. Se insertan un nuevo punto y un nuevo segmento en (1000\/150). Añade dos puntos más. Cambie los valores X \/ Y de los siguientes puntos: Punto 1: 0 \/ 0 Punto 2: 400 \/ 0 Punto 3: 600 \/ 250 Punto 4: 1800 \/ 250 Punto 5: 2000 \/ 0 Se cambia la curva de la posición del esclavo. Las curvas de velocidad, aceleración y sacudida también cambian. En la tabla de levas, cambie el Tipo de segmento del primer y tercer segmento para Línea . Compruebe la curva en el editor gráfico. Monitor: En la práctica, las curvas de las diferentes levas se definen frecuentemente como superpuestas para ahorrar tiempo de ciclo. En el ejemplo anterior, el eje vertical ya podría iniciar el movimiento mientras la mesa giratoria todavía está en movimiento (por ejemplo, en X: 350). " }, 
{ "title" : "Cómo definir puntos de conmutación ", 
"url" : "_sm_cam_defining_tappets.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Cómo definir puntos de conmutación ", 
"snippet" : "Utilice puntos de conmutación para activar eventos según la posición del maestro. Esto puede ser, por ejemplo, la configuración de una salida o la llamada de un bloque de funciones. Estas instrucciones utilizan el ejemplo de la Cómo crear una cámara capítulo para demostrar cómo definir los puntos de...", 
"body" : "Utilice puntos de conmutación para activar eventos según la posición del maestro. Esto puede ser, por ejemplo, la configuración de una salida o la llamada de un bloque de funciones. Estas instrucciones utilizan el ejemplo de la Cómo crear una cámara capítulo para demostrar cómo definir los puntos de cambio. En este ejemplo, el empujador inicia y detiene el proceso de soldadura. Abre el Eje vertical cámara en el editor. El Leva la pestaña es visible. Selecciona el Pestaña: Empujadores. En el Caja de herramientas ver, seleccione el Añadir taqué herramienta. El puntero del mouse se convierte en una cruz cuando lo mueve al editor. Haga clic debajo de la posición maestra cerca de la posición 600. Se inserta un empujador en la ruta del empujador 1. Seleccione el taqué. Cambie los valores del empujador en la vista \"Propiedades\". X : 600 Pase positiver : Encender Pase negativo : Ninguna acción Inserte otro empujador en la trayectoria 1 del empujador en X: 1800. X : 1800 Pase positiver : Apagar Pase negativo : Ninguna acción Compruebe el resultado. También puede cambiar los valores de pase positivo y pase negativo haciendo clic en el extremo respectivo de la punto de mira Tenga en cuenta que también puede establecer los puntos de cambio en el Mesa de taqués pestaña. Este editor le proporciona las mismas opciones, pero en forma tabular. " }, 
{ "title" : "Crear cámaras mediante programación ", 
"url" : "_sm_basic_cam_programmatic_creation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Crear cámaras mediante programación ", 
"snippet" : "A partir de CODESYS SoftMotion versión 4.17.0.0, la CamBuilder El bloque de funciones proporciona una interfaz para crear levas mediante programación directamente en la aplicación IEC. Para obtener más información, consulte el ejemplo: Crear cámaras mediante programación...", 
"body" : "A partir de CODESYS SoftMotion versión 4.17.0.0, la CamBuilder El bloque de funciones proporciona una interfaz para crear levas mediante programación directamente en la aplicación IEC. Para obtener más información, consulte el ejemplo: Crear cámaras mediante programación" }, 
{ "title" : "Usando el bloque de funciones CamBuilder (a partir de SM 4.17.0.0) ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4552813176932834337885510319", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Crear cámaras mediante programación \/ Usando el bloque de funciones CamBuilder (a partir de SM 4.17.0.0) ", 
"snippet" : "La siguiente cámara se crea de forma predeterminada cuando se crea un objeto de cámara en el árbol de dispositivos: La leva consta de tres polinomios de quinto grado con los siguientes cuatro valores límite: X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 Para crear esta cámara mediante programa...", 
"body" : "La siguiente cámara se crea de forma predeterminada cuando se crea un objeto de cámara en el árbol de dispositivos: La leva consta de tres polinomios de quinto grado con los siguientes cuatro valores límite: X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 Para crear esta cámara mediante programación, una instancia de la CamBuilder El bloque de funciones se declara primero: VAR\n camBuilder : SMCB.CamBuilder;\nEND_VAR En la parte de implementación, el CamBuilder La instancia primero debe inicializarse. Tres segmentos de tipo Poly5 Luego se puede agregar usando el Append método: camBuilder.Init();\n \ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(120, 120, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(240, 240, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(360, 360))); Los polinomios se definen mediante las condiciones de contorno izquierda y derecha. En el ejemplo, el BoundImplicit La función siempre se utiliza para el límite izquierdo. Como resultado, se aplica la condición de contorno derecho del segmento anterior. Si el BoundImplicit La función se utiliza como límite izquierdo para el primer segmento, luego comienza en cero: en este ejemplo, con el segmento Poly5 en (X, Y, V, A) = (0, 0, 0, 0). Cuando el MC_CamTableSelect y MC_CamIn se utilizan bloques de funciones, la leva definida en CamBuilder el bloque de funciones finalmente tiene que convertirse en un MC_CamRef . Hay dos maneras de hacerlo, dependiendo de dónde se llame al CamBuilder Llamar a CamBuilder en la tarea del bus: En primer lugar, la parte de la declaración debe ser extendida por las instancias correspondientes: VAR\n    ...\n    camRef : MC_CAM_REF;\n    aCamSegments : ARRAY[1..3] OF SMC_CAM_SEGMENT;\nEND_VAR Luego, la instancia del bloque de funciones MC_CAM_REF se inicializa y escribe con el Write método del CamBuilder bloque de funciones. SMCB.InitCamRef(camRef, ADR(aCamSegments), XSIZEOF(aCamSegments));\ncamBuilder.Write(camRef); Llamar al CamBuilder en otra tarea (multitarea, multinúcleo): En primer lugar, se crea una instancia de la cámara segura para múltiples tareas\/multinúcleo en una GVL, a la que acceden tanto la tarea bus como la tarea CamBuilder. VAR_GLOBAL\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR A continuación, la creación de la cámara en la otra tarea se inicia desde la tarea del bus. Para determinar en la tarea del bus cuándo se escribió la nueva cámara en la otra tarea, el programa recuerda el CamId en STATE_INIT_ONLINE_TABLE_MULTITASK antes de crear la cámara. A continuación, se inicia la creación de la cámara en la otra tarea del STATE_START_CREATE_ONLINE_TABLE_MULTITASK estado. A continuación, la cámara creada se lee en el STATE_READ_ONLINE_TABLE_MULTITASK estado. PROGRAM BUS_TASK\nVAR\n    state : UDINT;\n    error : SMC_ERROR;\n    camIdBeforeCreate : UDINT;\n    camSegments: ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    camRef: MC_CAM_REF;\nEND_VAR\nVAR CONSTANT\n    STATE_INIT_ONLINE_TABLE_MULTITASK : UDINT := 0;\n    STATE_START_CREATE_ONLINE_TABLE_MULTITASK : UDINT := 10;\n    STATE_READ_ONLINE_TABLE_MULTITASK : UDINT := 20;\n    STATE_ERROR : UDINT := 1000;\nEND_VAR\n\n\nCASE state OF\nSTATE_INIT_ONLINE_TABLE_MULTITASK:\n    camIdBeforeCreate := GVL.safeCam.CamId;\n\n    state := STATE_START_CREATE_ONLINE_TABLE_MULTITASK;\n\nSTATE_START_CREATE_ONLINE_TABLE_MULTITASK:\n    CamBuilderTask.BuildCam := TRUE;\n\n    state := STATE_READ_ONLINE_TABLE_MULTITASK;\n\nSTATE_READ_ONLINE_TABLE_MULTITASK:\n    IF CamBuilderTask.Error THEN\n        error := CamBuilderTask.ErrorId;\n        state := state + STATE_ERROR;\n    ELSIF GVL.safeCam.CamId <> camIdBeforeCreate THEN\n        error := GVL.safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n        IF error = SMC_NO_ERROR THEN\n            state := state + 10;\n        ELSE\n            state := state + STATE_ERROR;\n        END_IF\n    END_IF\nEND_CASE En la tarea CamBuilder, la cámara multitarea\/segura para múltiples núcleos se escribe llamando CamBuilder.WriteMulticoreSafe() : PROGRAM CamBuilderTask\nVAR_INPUT\n    BuildCam : BOOL;\nEND_VAR\nVAR_OUTPUT\n    Error : BOOL;\n    ErrorId : SMC_ERROR;\nEND_VAR\nVAR\n    camBuilder : SMCB.CamBuilder;\nEND_VAR\n\nIF BuildCam THEN\n    BuildCam := FALSE;\n\n    camBuilder.Init();\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(120, 120, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(240, 240, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(360, 360)));\n     \n Error := camBuilder.IsErrorPending(errorID=> ErrorId);\n\n    IF NOT Error THEN\n        ErrorId := camBuilder.WriteMulticoreSafe(GVL.safeCam);\n        Error := ErrorId <> SMC_NO_ERROR;\n    END_IF\nEND_IF " }, 
{ "title" : "Condiciones de contorno implícitas y explícitas ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930557874", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Crear cámaras mediante programación \/ Usando el bloque de funciones CamBuilder (a partir de SM 4.17.0.0) \/ Condiciones de contorno implícitas y explícitas ", 
"snippet" : "Una condición de frontera implícita definida con BoundImplicit se asegura de que la transición al segmento adyacente sea lo más suave posible. Para hacer esto, la condición de contorno del segmento adyacente debe definirse explícitamente usando el Bound método. Entonces, si la condición de frontera ...", 
"body" : "Una condición de frontera implícita definida con BoundImplicit se asegura de que la transición al segmento adyacente sea lo más suave posible. Para hacer esto, la condición de contorno del segmento adyacente debe definirse explícitamente usando el Bound método. Entonces, si la condición de frontera izquierda de un segmento es implícita, entonces la condición de frontera derecha del segmento anterior tiene que ser explícita. Por el contrario, si la condición de frontera derecha está implícita, entonces la condición de frontera izquierda del segmento posterior tiene que ser explícita. El caso de uso más común es presumiblemente que solo se especifican explícitamente las condiciones de contorno correctas de los segmentos, como en el ejemplo anterior. Debido a las condiciones implícitas del límite izquierdo, las transiciones de los segmentos son automáticamente lo más suaves posible y no hay espacios en el área de definición. El siguiente ejemplo es un caso sencillo en el que resulta útil desviarse de este enfoque: El eje esclavo debe viajar a velocidad constante desde la posición 20 a 100: camBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100))); Antes y después de esto, un Poly5 El segmento se utiliza para aceleración y desaceleración: camBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.BoundImplicit()));\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(120, 120, 0))); La leva así definida tiene fases de aceleración y desaceleración no deseadas en los segmentos Poly5 (velocidad en azul): Para evitar esto, es suficiente ajustar la posición del maestro en el segmento de tipo Line (por ejemplo, el del límite izquierdo de 20 a 30 y el del límite derecho de 100 a 90): ...\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(30, 20),\n SMCB.Bound(90, 100)));\n... No es necesario ajustar los segmentos de tipo Poly5 porque se agregan automáticamente al segmento de línea de la manera más suave posible debido a las condiciones de contorno definidas usando el BoundImplicit función. " }, 
{ "title" : "Manejo de errores ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930649954", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Crear cámaras mediante programación \/ Usando el bloque de funciones CamBuilder (a partir de SM 4.17.0.0) \/ Manejo de errores ", 
"snippet" : "El Append método de la CamBuilder retornos del bloque de funciones TRUE cuando un segmento se ha agregado exitosamente y regresa FALSE si ha ocurrido un error. Después de un error, no se pueden agregar más segmentos y el CamBuilder El bloque de funciones debe reinicializarse utilizando el Init métod...", 
"body" : "El Append método de la CamBuilder retornos del bloque de funciones TRUE cuando un segmento se ha agregado exitosamente y regresa FALSE si ha ocurrido un error. Después de un error, no se pueden agregar más segmentos y el CamBuilder El bloque de funciones debe reinicializarse utilizando el Init método. La causa del error se puede determinar utilizando el IsErrorPending método: camBuilder.IsErrorPending(errorId=> errorId); " }, 
{ "title" : "Creación manual de la estructura de datos MC_CAM_REF (antes de SM 4.17.0.0) ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4565212026644834337937734299", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Crear cámaras mediante programación \/ Creación manual de la estructura de datos MC_CAM_REF (antes de SM 4.17.0.0) ", 
"snippet" : "Se recomienda utilizar el SM3_CamBuilder biblioteca a partir de CODESYS SoftMotion 4.17.0.0....", 
"body" : "Se recomienda utilizar el SM3_CamBuilder biblioteca a partir de CODESYS SoftMotion 4.17.0.0. " }, 
{ "title" : "Estructuras de datos de levas. ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793858538", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Crear cámaras mediante programación \/ Creación manual de la estructura de datos MC_CAM_REF (antes de SM 4.17.0.0) \/ Estructuras de datos de levas. ", 
"snippet" : "Al compilar el proyecto, los datos de la cámara creados se convierten internamente en una lista de variables globales. Haciendo click Mostrar código generado En el editor de cámaras, puede mostrar las variables globales creadas automáticamente. Cada cámara está representada por la estructura de dato...", 
"body" : "Al compilar el proyecto, los datos de la cámara creados se convierten internamente en una lista de variables globales. Haciendo click Mostrar código generado En el editor de cámaras, puede mostrar las variables globales creadas automáticamente. Cada cámara está representada por la estructura de datos. MC_CAM_REF . Puede acceder a esta estructura de datos mediante el programa IEC o mediante funciones de preprocesamiento y bloques de funciones. Está disponible por el SM3_Basic biblioteca. El programa IEC también puede generar o completar un bloque de funciones que describe una leva en tiempo de ejecución. Ejemplo Definición de la estructura de datos: TYPE mySMC_CAMTable_LREAL_10000_2 :\nSTRUCT\n Table: ARRAY[0..9999] OF ARRAY[0..1] OF LREAL;\n (* set all scaling definitions to 0 and 1\n result: all values of the table are not scaled *)\n fEditorMasterMin: REAL := 0;\n fEditorMasterMax: REAL := 1;\n fEditorSlaveMin: REAL := 0;\n fEditorSlaveMax: REAL := 1;\n fTableMasterMin: REAL := 0;\n fTableMasterMax: REAL := 1;\n fTableSlaveMin: REAL := 0;\n fTableSlaveMax: REAL := 1;\nEND_STRUCT\nEND_TYPE Creación de instancias de la estructura de datos: Cam: MC_CAM_REF;\nCam_PointArray : mySMC_CAMTable_LREAL_10000_2; Calculando la leva: Cam.byType:=2;\nCam.byVarType:=6;\nCam.nTappets:=0;\nCam.strCAMName:='myCAM';\nCam.pce:= ADR(CAM_PointArray);\nFOR i:=0 TO 9999 DO\n (* example cam: master 0..360, slave 0..100,\n constant velocity *)\n Cam_PointArray.Table[i][0]:=UDINT_TO_LREAL(I)\/10000 * 360; (* X *)\n Cam_PointArray.Table[i][1]:=UDINT_TO_LREAL(I)\/10000 * 100; (* Y *)\nEND_FOR\nCam.nElements:=10000\nCam.xStart:=0.0;\nCam.xEnd:=360.0; " }, 
{ "title" : "Cámaras generadas manualmente ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793936406", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Crear cámaras mediante programación \/ Creación manual de la estructura de datos MC_CAM_REF (antes de SM 4.17.0.0) \/ Cámaras generadas manualmente ", 
"snippet" : "Se puede crear una leva en un programa IEC sin utilizar el editor de levas. Ejemplo Declaración: VAR i: INT; CAM: MC_CAM_REF := ( byType:=2, (* non-equidistant *) byVarType:=2, (* UINT *) nElements:=128, xStart:=0, xEnd:=360); Table: SMC_CAMTable_UINT_128_2 := ( fEditorMasterMin := 0, fEditorMasterM...", 
"body" : "Se puede crear una leva en un programa IEC sin utilizar el editor de levas. Ejemplo Declaración: VAR\ni: INT;\nCAM: MC_CAM_REF := (\n byType:=2, (* non-equidistant *)\n byVarType:=2, (* UINT *)\n nElements:=128,\n xStart:=0,\n xEnd:=360);\nTable: SMC_CAMTable_UINT_128_2 := (\n fEditorMasterMin := 0, fEditorMasterMax := 360,\n fTableMasterMin := 0, fTableMasterMax := 6000,\n fEditorSlaveMin := 0, fEditorSlaveMax := 360,\n fTableSlaveMin := 0, fTableSlaveMax := 6000);\nEND_VAR Implementación: (* Create cam disk (example straight line); unambiguous *)\nFOR i:=0 TO 127 DO\n Table.Table[i][0] := Table.Table[i][1] := REAL_TO_UINT(i \/ 127.0 * 6000);\nEND_FOR\n(* Link pointer; must be done in every cycle! *)\nCAM.pce := ADR(Table); Esta leva generada se puede especificar en el MC_CamTableSelect bloque de funciones y su salida se utiliza nuevamente para MC_CamIn . " }, 
{ "title" : "Compilación de definiciones de cámaras ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793975398", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Crear cámaras mediante programación \/ Creación manual de la estructura de datos MC_CAM_REF (antes de SM 4.17.0.0) \/ Compilación de definiciones de cámaras ", 
"snippet" : "En tiempo de compilación, variables de tipo MC_CAM_REF se crean para una cámara. Incluyen una descripción de cada segmento de la leva. Las estructuras de datos de este tipo se pasan al MC_CamTableSelect bloque de funciones. La estructura es parte de la SM3_Basic biblioteca....", 
"body" : "En tiempo de compilación, variables de tipo MC_CAM_REF se crean para una cámara. Incluyen una descripción de cada segmento de la leva. Las estructuras de datos de este tipo se pasan al MC_CamTableSelect bloque de funciones. La estructura es parte de la SM3_Basic biblioteca. " }, 
{ "title" : "Cambiar entre cámaras ", 
"url" : "_sm_cam_switch_between_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Cambiar entre cámaras ", 
"snippet" : "Básicamente, puedes cambiar entre diferentes cámaras en cualquier momento. Sin embargo, debes considerar algunos puntos: En el editor de levas, la posición del esclavo se define unívocamente como valor de función de la función de levas. Esta función se define en el rango de valores maestros y se pue...", 
"body" : "Básicamente, puedes cambiar entre diferentes cámaras en cualquier momento. Sin embargo, debes considerar algunos puntos: En el editor de levas, la posición del esclavo se define unívocamente como valor de función de la función de levas. Esta función se define en el rango de valores maestros y se puede expresar de la siguiente manera: SlavePosition = CAM( MasterPosition ) Debido a que la posición actual del accionamiento maestro generalmente se desvía del rango de valores maestros, debe escalar la posición maestra en el rango de definición de la función de leva para representar un argumento válido: SlavePosition = CAM( MasterScale*MasterPosition + MasterOffset ) De manera similar, debe escalar el valor de la función (la posición del esclavo) si el inicio de la leva en el modo Absolute daría lugar a un salto: SlavePosition = SlaveScale*CAM( MasterPosition ) + SlaveOffset Es posible que deba aplicar ambos valores de escala, lo que da como resultado lo siguiente: Slaveposition = SlaveScale*CAM( MasterScale*Masterposition + MasterOffset ) + SlaveOffset Los valores apropiados para los parámetros de escala y compensación pueden variar de un período a otro. El cambio entre cámaras se puede realizar de tres formas: Inicie la segunda cámara a través de una segunda instancia de MC_CamIn con BufferMode = MC_BUFFER_MODE.Buffered , StartMode = relative , MasterAbsolute = FALSE , y SlaveAbsolute = FALSE . A partir de CODESYS SoftMotion versión 4.17.0.0 Inicio de la nueva leva asignando MC_CamIn.CamTableID a la nueva leva (sin reinicio de la MC_CamIn bloque de funciones requerido). Se recomienda esta variante si los siguientes puntos se aplican a su caso de uso: Todas las levas siguientes deben ejecutarse relativamente con MasterAbsolute = FALSE o SlaveAbsolute = FALSE . La nueva leva debe comenzar exactamente al final de la anterior. No se modifican otros parámetros (ejemplo: SlaveOffset ). El salto, que se explica en el siguiente ejemplo para levas periódicas y SlaveAbsolute = FALSE , lo hace no se aplican a esta variante porque la leva siguiente se coloca exactamente en las posiciones finales de la leva anterior. La nueva leva se coloca exactamente al final de la leva anterior solo si el cambio a la leva nueva se realiza en el mismo ciclo cuando la leva anterior informa EndOfProfile = TRUE . Inicio de la nueva leva reiniciando el MC_CamIn bloque de funciones Se recomienda esta variante si se deben cambiar los parámetros para el correcto funcionamiento de la nueva leva (por ejemplo, SlaveOffset del siguiente ejemplo). Se aplican las restricciones del siguiente ejemplo. Ejemplo En el siguiente ejemplo, cambia de CAM1 a CAM2 : CAM1 consta de un polinomio de quinto orden seguido de dos segmentos de línea. CAM2 consta de dos segmentos de recta seguidos de un polinomio de quinto orden. Al cambiar entre ambas cámaras, debe considerar lo siguiente: Para evitar saltos, los valores de velocidad y aceleración en el punto final de la primera leva deben coincidir con los valores en el punto inicial de la segunda leva. En el ejemplo, esta condición se cumple porque se asigna la misma velocidad (=1) y aceleración (=0) al punto final de CAM1 y el punto de partida de CAM2 . Puede iniciar la segunda cámara en Relative modo cuando haya definido la posición de inicio del esclavo como 0. Sin embargo, la primera leva tiene que estar funcionando en non-periodic modo. De lo contrario, si CAM1 eran periódicas, entonces la Relative el ajuste daría como resultado un salto. La ampliación muestra la transición de CAM1 a CAM2 . Las líneas azules marcan las evaluaciones de las funciones de la leva en las posiciones maestras x1 y x2 . Ahora, veremos el caso desfavorable de periodic : MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=TRUE); La llamada inicia una evaluación de la leva en la posición maestra x1 , que es menor que la posición final del maestro de CAM1 . Entonces CAM1 se evalúa por defecto y produce un punto 1 como la posición para el esclavo. CAM(x2, CAM1, PERIODIC:=TRUE); Para la siguiente llamada del módulo, la posición maestra x2 está fuera del rango de valores maestros de CAM1 , cuyo límite está marcado por la línea discontinua verde y concuerda con el eje horizontal del punto 3p . Por lo tanto, la EndOfProfile Está establecido. Porque CAM1 se inició en periodic modo, su reinicio se produce al final del rango de valores, lo que finalmente produce el punto 2p como resultado de la llamada del módulo. CAM(EXECUTE:=FALSE); Cambiar a la nueva cámara CAM(x2, CAM2, PERIODIC:=TRUE); Segunda evaluación en posición de maestro x2 . Esta vez, el nuevo CAM2 se evalúa. Después CAM2 se inicia en Relative modo, la posición actual del esclavo ( 2p ) se agrega como compensación a la imagen de la función de leva de CAM2 . Esto mueve el punto de inicio de su gráfico al punto 3p y su evaluación en el puesto de maestro x2 da el punto 4p , y por lo tanto un salto desfavorable. Selecciona el non-periodic Modo para evitar saltos: MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=FALSE); La llamada inicia una evaluación de la leva en la posición maestra x1 , que es menor que la posición final del maestro de CAM1 . Entonces CAM1 se evalúa por defecto y produce el punto 1 como la posición del esclavo. CAM(x2, CAM1, PERIODIC:=FALSE); Para la siguiente llamada del módulo, la posición maestra x2 está fuera del rango de valores maestros de CAM1 , cuyo límite está marcado por la línea discontinua verde y coincide con el eje horizontal del punto 3n . Por lo tanto, la EndOfProfile Está establecido. Porque CAM1 se inició en non-periodic modo, posición esclava ( 2n ) asignado al puesto maestro x2 es idéntica a la posición del esclavo al alcanzar el final del rango de valores de CAM1 ( 3n ). CAM(EXECUTE:=FALSE); Cambiar a cámara nueva. CAM(x2, CAM2, PERIODIC:=FALSE); Segunda evaluación en posición de maestro x2 . Esta vez, el nuevo CAM2 se evalúa. Después CAM2 se inicia en Relative modo, la posición actual del esclavo ( 2n ) se agrega como compensación a la imagen de la función de leva de CAM2 . Esto mueve el punto de inicio de su gráfico al punto 3n y su evaluación en el puesto de maestro x2 da el punto 4n , que está en la línea específica a través de los puntos 1 y 3n . Para iniciar la cámara en Absolute modo, debe asegurarse de que el esclavo esté en una posición de inicio adecuada. Si el rango de valores del maestro coincide con el período del esclavo, entonces el cambio entre levas no tiene ninguna complicación, independientemente de si las levas son periódicas o no. En el ejemplo anterior, puede comenzar CAM2 en Absolute modo cuando los períodos del maestro y el esclavo concuerdan con el rango de valor maestro de CAM2 (cada uno es de 360°). Si no, por ejemplo cuando el período del esclavo es 270° (indicado por la línea azul claro), luego el Absolute opción no está permitida sin tomar acciones adicionales. En este caso, el esclavo está a 90° cuando cambia de CAM1 a CAM2 . A partir de CAM2 en Absolute modo provoca un salto a 0° (indicado por una línea gris). Sin embargo, el salto se puede evitar ajustando la compensación del esclavo al valor apropiado de 90°. " }, 
{ "title" : "Cámaras periódicas ", 
"url" : "_sm_basic_periodic_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Cámaras periódicas ", 
"snippet" : "Una leva se puede ejecutar repetidamente cuando el Periodic entrada de la MC_CamTableSelect El bloque de funciones está configurado en TRUE . Luego, la leva se reinicia automáticamente después de alcanzar la posición final. Si esta entrada es FALSE , entonces el EndOfProfile variable de salida del M...", 
"body" : "Una leva se puede ejecutar repetidamente cuando el Periodic entrada de la MC_CamTableSelect El bloque de funciones está configurado en TRUE . Luego, la leva se reinicia automáticamente después de alcanzar la posición final. Si esta entrada es FALSE , entonces el EndOfProfile variable de salida del MC_CamIn El bloque de funciones está configurado en TRUE cuando se alcanza la posición final del maestro. El esclavo se detiene en su posición actual. Tenga en cuenta que la actividad de la leva no se detiene después de salir del rango de valores maestros. Cuando el accionamiento maestro vuelve a entrar en el rango de valores maestro, el accionamiento esclavo vuelve a seguir la placa de leva. Comportamiento en el caso de Slave.EndPosition <> Slave.StartPosition : El bloque de funciones MC_CamIn calcula una compensación interna al final de un período. En el período siguiente, la leva se desplaza según este desplazamiento, de modo que continúa en la posición actual del esclavo y, por lo tanto, evita saltos. Para una leva periódica, puede activar el Transición suave opción en las propiedades de la cámara. Esto se utiliza para evitar que se produzcan saltos al pasar de un período a otro. Entonces el esclavo tiene la misma velocidad y aceleración en la posición final que en la posición inicial. El período y el avance se miden en unidades de escala esclava. Incluso si no selecciona el Transición suave Opcionalmente, la leva puede funcionar de forma continua. En este caso, su tarea es asegurarse de que la coherencia de las transiciones se cumpla en un grado suficiente. " }, 
{ "title" : "Elemento de visualización 'Editor de cámara en línea' ", 
"url" : "_sm_cam_visu_elem_online_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Elemento de visualización 'Editor de cámara en línea' ", 
"snippet" : "El editor de cámaras en línea es una plantilla de visualización que muestra una cámara en la visualización. Con este elemento, puede modificar la cámara en modo online. El elemento de visualización está disponible en una plantilla de visualización ( SMC_Visu_CamEditor ) del SM3_Basic_Visu biblioteca...", 
"body" : "El editor de cámaras en línea es una plantilla de visualización que muestra una cámara en la visualización. Con este elemento, puede modificar la cámara en modo online. El elemento de visualización está disponible en una plantilla de visualización ( SMC_Visu_CamEditor ) del SM3_Basic_Visu biblioteca. La encontrará en el editor de visualización del Caja de herramientas ver en el SM3_Basic_Visu etiqueta. El SMC_Visu_CamEditor se inserta en la visualización mediante un marco. Para obtener más información sobre este elemento de visualización, consulte: Elemento de visualización: marco . Además de las propiedades del elemento marco, esta plantilla contiene las siguientes propiedades: Propiedad Descripción Cámara segura Referencia a la cámara que se va a editar Mostrar posición Variable booleana para activar y desactivar la visualización de la curva de posición Mostrar velocidad Variable booleana para activar y desactivar la visualización de la curva de velocidad Mostrar aceleración Variable booleana para activar y desactivar la visualización de la curva de aceleración ShowJerk Variable booleana para activar y desactivar la visualización de la curva brusca Mostrar segmento seleccionado Variable booleana para activar y desactivar el resaltado del segmento seleccionado La cámara que se va a editar se transfiere a través de una instancia del SMCB.CAM_REF_MULTICORE_SAFE bloque de funciones. PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR " }, 
{ "title" : "Editor de cámaras en modo en línea ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_id_ba4cc02c6ccda90bc0a864637badf4e0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Elemento de visualización 'Editor de cámara en línea' \/ Editor de cámaras en modo en línea ", 
"snippet" : "En el modo online, los segmentos individuales de la leva se pueden seleccionar en el gráfico. El editor de segmentos de la derecha se puede utilizar para añadir y eliminar segmentos, así como para adaptar las condiciones de contorno del segmento seleccionado (1) Cámara de carga Carga la cámara confi...", 
"body" : "En el modo online, los segmentos individuales de la leva se pueden seleccionar en el gráfico. El editor de segmentos de la derecha se puede utilizar para añadir y eliminar segmentos, así como para adaptar las condiciones de contorno del segmento seleccionado (1) Cámara de carga Carga la cámara configurada en el editor (2) Guardar cámara Guarda la cámara editada (3) Barra de estado Muestra los mensajes de estado (4) Selección de segmentos Se puede seleccionar un segmento con las flechas. El tipo de segmento se puede cambiar mediante el cuadro de lista. (5) Puesto de maestro La posición maestra en los bordes izquierdo y derecho del segmento (6) Posición de esclavo La posición esclava en los bordes izquierdo y derecho del segmento. (7) Velocidad del esclavo La velocidad del esclavo en los bordes izquierdo y derecho del segmento. No se puede editar para todos los tipos de segmentos (8) Aceleración esclava La aceleración secundaria en los bordes izquierdo y derecho del segmento. No se puede editar para todos los tipos de segmentos (9) Esclavo idiota El tirón esclavo en los bordes izquierdo y derecho del segmento. No se puede editar para todos los tipos de segmentos (10) Parámetro lambda Parámetro lambda para la línea sinusoidal modificada. (11) Split Divide el segmento seleccionado en dos segmentos. (12) Eliminar Elimina el segmento seleccionado. " }, 
{ "title" : "Uso de una cámara creada en la aplicación ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_section-idm234870310600632", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimientos sincrónicos de dos ejes \/ Cámaras \/ Elemento de visualización 'Editor de cámara en línea' \/ Uso de una cámara creada en la aplicación ", 
"snippet" : "Puede utilizar la cámara creada con el SMC_Visu_CamEditor elemento de visualización en la aplicación llamando al GetCopy método del CAM_REF_MULTICORE_SAFE instancia. PROGRAM PLC_PRG VAR     safeCam : SMCB.CAM_REF_MULTICORE_SAFE;     camRef : MC_CAM_REF;     camSegments : ARRAY[0..99] OF SMC_CAM_SEGM...", 
"body" : "Puede utilizar la cámara creada con el SMC_Visu_CamEditor elemento de visualización en la aplicación llamando al GetCopy método del CAM_REF_MULTICORE_SAFE instancia. PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\n    camRef : MC_CAM_REF;\n    camSegments : ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    error : SMC_ERROR;\nEND_VAR\n\nIF safeCam.CamId <> oldCamId THEN\n     error :=\n         safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n oldCamId := safeCam.CamId;\nEND_IF El programa comprueba primero si se ha creado una nueva cámara ( CamId <> oldCamID ). Si es así, se crea una copia de esta cámara utilizando el GetCopy método. Si la llamada vuelve SMC_NO_ERROR , luego el camRef instancia del MC_CAM_REF el bloque de funciones se puede usar con los bloques de funciones de cámara de SoftMotion MC_CamTableSelect y MC_CamIn . GetCopy la llamada es segura para la tarea y, por lo tanto, no es necesario realizarla desde la tarea de Visu. " }, 
{ "title" : "Dirigiendo múltiples movimientos ", 
"url" : "_sm_basic_mulitple_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Descripción general ", 
"url" : "_sm_overview_mulitple_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos \/ Descripción general ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Modo búfer ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844820766", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos \/ Descripción general \/ Modo búfer ", 
"snippet" : "Algunos bloques de funciones tienen una BufferMode entrada que se utiliza para controlar el orden cronológico de los movimientos. El modo de búfer define si el bloque de funciones funciona en modo sin búfer (\"Aborting\", comportamiento estándar) o en modo con búfer (\"Buffered\"). La diferencia entre e...", 
"body" : "Algunos bloques de funciones tienen una BufferMode entrada que se utiliza para controlar el orden cronológico de los movimientos. El modo de búfer define si el bloque de funciones funciona en modo sin búfer (\"Aborting\", comportamiento estándar) o en modo con búfer (\"Buffered\"). La diferencia entre estos dos modos es el momento en el que inician sus acciones: \"Modo sin búfer\": el comando de movimiento tiene efecto inmediatamente, incluso si esto interrumpe otro movimiento. Se borra el buffer de los movimientos ordenados. \"Modo almacenado en búfer\": el comando de movimiento espera hasta que el bloque de funciones actual establezca su salida Done (o InPosition , o InVelocity , etc.). Los modos de amortiguación también se utilizan para definir cómo debe verse la curva de velocidad en la transición de los movimientos. La entrada BufferMode es un ENUM de tipo MC_BUFFER_MODE. Aborting Modo predeterminado sin almacenamiento en búfer. El bloque de funciones se inicia inmediatamente y cancela un movimiento activo. El comando tiene efecto inmediato en el eje. Buffered El bloque de funciones comienza tan pronto como finaliza el último movimiento ordenado. Aquí no se produce ninguna mezcla. El nuevo movimiento comienza a la velocidad que tiene el movimiento anterior cuando se alcanza la condición final ( Done , InVelocity , InEndVelocity , InGear , InSync , EndOfProfile , etc.). Si el movimiento anterior fue MC_MoveAbsolute o MC_MoveRelative , entonces el nuevo movimiento comienza desde el punto muerto. BlendingLow El bloque de funciones comienza tan pronto como finaliza el último movimiento ordenado. El eje no se detiene entre movimientos, sino que recorre la posición final del primer movimiento con la velocidad más baja de las dos órdenes de movimiento. BlendingPrevious El bloque de funciones comienza tan pronto como finaliza el último movimiento ordenado. El eje no se detiene entre movimientos, sino que recorre la posición final del primer movimiento con la velocidad de la primera orden de movimiento. BlendingNext El bloque de funciones comienza tan pronto como finaliza el último movimiento ordenado. El eje no se detiene entre movimientos, sino que recorre la posición final del primer movimiento con la velocidad de la segunda orden de movimiento. BlendingHigh El bloque de funciones comienza tan pronto como finaliza el último movimiento ordenado. El eje no se detiene entre movimientos, sino que recorre la posición final del primer movimiento con la velocidad más alta de las dos órdenes de movimiento. " }, 
{ "title" : "Bloques de funciones compatibles ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844838676", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos \/ Descripción general \/ Modo búfer \/ Bloques de funciones compatibles ", 
"snippet" : "Todos los bloques de funciones que se pueden especificar como comandos almacenados en búfer\/mezcla tienen las siguientes entradas y salidas: BufferMode aporte ( MC_BUFFER_MODE tipo) Active producción: ( BOOL tipo) Se acepta un comando cuando el bloque de funciones cambia al estado Busy después de qu...", 
"body" : "Todos los bloques de funciones que se pueden especificar como comandos almacenados en búfer\/mezcla tienen las siguientes entradas y salidas: BufferMode aporte ( MC_BUFFER_MODE tipo) Active producción: ( BOOL tipo) Se acepta un comando cuando el bloque de funciones cambia al estado Busy después de que se haya ordenado un nuevo movimiento. Bloque de funciones Se puede definir como un comando almacenado en búfer\/mezclado Puede ir seguido de un comando almacenado en búfer\/mezcla Señal relevante para activar el siguiente FB almacenado en buffer\/combinación MC_Power No No MC_Home No No MC_Stop No No MC_Halt No No MC_MoveAbsolute MC_MoveRelative Sí Sí Done MC_MoveAdditive No Sí ( Buffered solo) Done MC_MoveSuperImposed MC_HaltSuperImposed No No Para más información, ver: Comportamiento de MC_MoveSuperImposed y MC_HaltSuperImposedMC_MoveVelocity Sí Sí ( Buffered solo) InVelocity SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative No Sí ( Buffered solo) InEndVelocity MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile No Sí ( Buffered solo) Done MC_CamIn Sí (solo Buffered y BlendingPrevious ) Sí, también si es periódico (sólo Buffered ) EndOfProfile MC_CamOut No Sí ( Buffered solo) Done MC_GearIn Sí ( BlendingPrevious solo) Sí ( Buffered solo) InGear MC_GearOut No Sí ( Buffered solo) Done MC_GearInPos Sí ( BlendingPrevious solo) Sí ( Buffered solo) InSync SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues No No SMC_SetTorque No No MC_Phasing No No MC_Jog SMC_Inch No No Estos bloques de funciones no deben usarse cuando los movimientos se ordenan con el modo buffer Buffered o Blending* . El jogging y los movimientos ordenados podrían interrumpirse mutuamente. SMC_BacklashCompensation No No SMC_TrackAxis No No SMC_TrackSetValues No No Nota para MC_GearInPos y MC_GearIn : El comportamiento de otros modos de buffer como BlendingPrevious es difícil de establecer. El principal problema es que la velocidad de estos bloques de funciones puede cambiar en cualquier momento dependiendo del eje maestro. Dado que el licuado funciona mejor cuando se conoce la velocidad de licuado lo antes posible, solo BlendingPrevious esta apoyado. En el caso de BlendingPrevious , la dirección del eje maestro también puede cambiar en cualquier momento. Esto significa que la dirección que debe tener el eje esclavo para MC_GearInPos solo se conoce cuando se completa la combinación. Sin embargo, necesitamos una dirección para el movimiento de fusión justo cuando comienza la fusión. Es por eso que el primer movimiento define tanto la velocidad de fusión como la dirección, independientemente de la dirección definida por los siguientes. MC_GearIn(Pos) . " }, 
{ "title" : "Comportamiento en caso de movimientos amortiguados ", 
"url" : "_sm_buffermode_buffered_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos \/ Comportamiento en caso de movimientos amortiguados ", 
"snippet" : "Cuando se ordena un movimiento amortiguado después MC_MoveAbsolute o MC_MoveRelative , el movimiento amortiguado está activo en el mismo ciclo donde informa el movimiento anterior Done y alcanza la velocidad 0. Sin embargo, la interpolación del movimiento amortiguado no comienza hasta el siguiente c...", 
"body" : "Cuando se ordena un movimiento amortiguado después MC_MoveAbsolute o MC_MoveRelative , el movimiento amortiguado está activo en el mismo ciclo donde informa el movimiento anterior Done y alcanza la velocidad 0. Sin embargo, la interpolación del movimiento amortiguado no comienza hasta el siguiente ciclo, por lo que la velocidad del eje al final del ciclo es igual a 0. Cuando se ordena un movimiento amortiguado después MC_CamIn , el movimiento amortiguado está activo en el mismo ciclo donde informa el movimiento anterior EndOfProfile . Inmediatamente en este ciclo comienza la interpolación del movimiento amortiguado. " }, 
{ "title" : "Comportamiento en el caso de mezcla ", 
"url" : "_sm_buffermode_blending.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos \/ Comportamiento en el caso de mezcla ", 
"snippet" : "Una propiedad básica del comportamiento de mezcla de CODESYS SoftMotion es que el eje se mueve a lo largo de las mismas posiciones durante la mezcla que durante un movimiento amortiguado. La única diferencia es la velocidad a lo largo de estas posiciones. Esto es obvio para casos simples. Vea el sig...", 
"body" : "Una propiedad básica del comportamiento de mezcla de CODESYS SoftMotion es que el eje se mueve a lo largo de las mismas posiciones durante la mezcla que durante un movimiento amortiguado. La única diferencia es la velocidad a lo largo de estas posiciones. Esto es obvio para casos simples. Vea el siguiente ejemplo para esto: Hay casos en los que la propiedad de recorrer las mismas posiciones por el eje independientemente del modo de amortiguación influye en la velocidad de fusión efectiva entre los dos movimientos. Este es el caso, por ejemplo, si el ejemplo anterior se modifica de modo que la velocidad máxima del segundo movimiento sea tan alta que no pueda alcanzarse en la posición de mezclado. Según las reglas descritas en PLCopen, la velocidad de mezclado debe ser de 500 u\/s. Sin embargo, para lograr esta velocidad en la posición 100 u, el eje tendría que invertirse, moverse en dirección negativa a una posición menor que 0 u y luego acelerar a 500 u\/s. En cambio, en tales casos, la velocidad de mezcla efectiva se limita a la velocidad máxima que se puede lograr sin inversión ni sobrepaso de posición. En este ejemplo, la velocidad máxima es 447 u\/s. Las siguientes reglas para la velocidad de mezcla efectiva resultan de la propiedad de que el modo de búfer no cambia las posiciones conducidas: Si no se puede alcanzar la velocidad de mezcla sin sobrepasar la posición, entonces la velocidad de mezcla efectiva es la siguiente velocidad posible que se puede alcanzar sin sobrepasar (consulte el ejemplo anterior). Nota: La velocidad de mezcla efectiva puede ser mayor o menor que la velocidad de mezcla. Si la dirección al comienzo del segundo movimiento es opuesta a la dirección del primer movimiento, entonces la velocidad de fusión efectiva se establece en 0. Esto evita que la posición se exceda en la dirección del primer movimiento más allá de su posición de destino. Si la trayectoria del segundo movimiento es demasiado corta para permitir la desaceleración desde la velocidad de licuado hasta detenerse, entonces se ajusta la velocidad de licuado efectiva. Está ajustado a la velocidad máxima que permite un frenado seguro hasta detenerse en la trayectoria del segundo movimiento. En el caso de ejes módulo, el efecto de la entrada Direction de MC_MoveAbsolute no se ve afectado por la fusión con un segundo movimiento. Esto significa que la posición de destino del primer movimiento está siempre en el mismo período de módulo, independientemente de si sigue o no un movimiento de fusión. En el caso de ejes de módulo y un segundo movimiento de tipo MC_MoveAbsolute , la velocidad de fusión no afecta el período de módulo de la posición objetivo del segundo movimiento cuando Direction = fastest se usa Esto significa que se selecciona el mismo período de destino independientemente de si el segundo movimiento se ordena con Buffered o Blending . " }, 
{ "title" : "Aceleración, desaceleración y sacudida durante la mezcla ", 
"url" : "_sm_buffermode_blending.html#UUID-60273b62-3ad5-7014-3fa9-e2fa61f7a008_section-idm235068399508112", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos \/ Comportamiento en el caso de mezcla \/ Aceleración, desaceleración y sacudida durante la mezcla ", 
"snippet" : "El modo búfer ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext ) del segundo movimiento determina la velocidad a la que se alcanza la posición inicial del movimiento. Por el contrario, la aceleración máxima, la desaceleración y la sacudida máxima durante la mezcla son siempre los valor...", 
"body" : "El modo búfer ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext ) del segundo movimiento determina la velocidad a la que se alcanza la posición inicial del movimiento. Por el contrario, la aceleración máxima, la desaceleración y la sacudida máxima durante la mezcla son siempre los valores del primer movimiento. Esto se debe a que la posición objetivo del primer movimiento puede superarse si, por ejemplo, el retraso máximo del segundo movimiento es inferior al del primero y se utiliza el menor retraso " }, 
{ "title" : "Almacenamiento en búfer\/combinación de movimiento continuo o sincronizado ", 
"url" : "_sm_buffermode_continuous_motion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos \/ Almacenamiento en búfer\/combinación de movimiento continuo o sincronizado ", 
"snippet" : "Según PLCopen, el modo de búfer de mezcla determina la velocidad al final del primer movimiento. En algunos casos, la velocidad ya está completamente determinada por el primer movimiento. Este es el caso cuando el primer movimiento es de uno de los siguientes tipos: movimiento continuo ( MC_MoveVelo...", 
"body" : "Según PLCopen, el modo de búfer de mezcla determina la velocidad al final del primer movimiento. En algunos casos, la velocidad ya está completamente determinada por el primer movimiento. Este es el caso cuando el primer movimiento es de uno de los siguientes tipos: movimiento continuo ( MC_MoveVelocity , SMC_MoveContinuousRelative , o SMC_MoveContinuousAbsolute ) Movimiento sincronizado ( MC_CamIn , MC_GearIn , o MC_GearInPos ) En estos casos, CODESYS SoftMotion solo admite el Buffered y Aborting modos de búfer. El uso de uno de los modos de búfer de mezcla provoca un error de FB ( SMC_BLENDING_NOT_SUPPORTED_BY_PREVIOUS_MOVEMENT) . Cuando el siguiente comando almacenado en búfer se activa, la salida CommandAborted se establece en TRUE para un comando de movimiento previo. Además, las salidas \"Inxxx\" (por ejemplo, InVelocity para MC_MoveVelocity o InGear para MC_GearIn ) y la salida Busy están configurados para un ciclo. Esto contrasta con PLCopen, Sección 2.4.1, en la que CommandAborted y \"Inxxx\", así como Busy son mutuamente excluyentes. " }, 
{ "title" : "Orden de ejecución de los bloques de funciones de movimiento ", 
"url" : "_sm_buffermode_execution_order.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos \/ Orden de ejecución de los bloques de funciones de movimiento ", 
"snippet" : "Cuando se ordenan movimientos almacenados en búfer o movimientos combinados, la instancia del bloque de funciones que ordena el movimiento posterior no debe ejecutarse antes que la instancia del bloque de funciones que ordena el movimiento anterior. Si se infringe este pedido, entonces el nuevo erro...", 
"body" : "Cuando se ordenan movimientos almacenados en búfer o movimientos combinados, la instancia del bloque de funciones que ordena el movimiento posterior no debe ejecutarse antes que la instancia del bloque de funciones que ordena el movimiento anterior. Si se infringe este pedido, entonces el nuevo error SMC_FB_WASNT_CALLED_DURING_MOTION se notifica y el eje cambia al estado Errorstop . Ejemplo movement1();\nmovement2(); Orden de ejecución correcto Ejecución de movement1() Ejecución de movement2() Tan pronto como movement1() está activo Orden de ejecución no válida Ejecución de movement2() Ejecución de movement1() Tan pronto como movement2() está activo Esto resulta en el SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT error. " }, 
{ "title" : "Uso de una instancia de bloque de funciones para controlar múltiples movimientos ", 
"url" : "_sm_buffermode_one_fb.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos \/ Uso de una instancia de bloque de funciones para controlar múltiples movimientos ", 
"snippet" : "Una única instancia de bloque de funciones (por ejemplo, de MC_MoveAbsolute ) no se puede utilizar para controlar múltiples movimientos amortiguados\/mezclados siempre que esté Busy . Cuando una instancia de bloque de funciones es Busy , el comando para un nuevo movimiento almacenado en búfer o combi...", 
"body" : "Una única instancia de bloque de funciones (por ejemplo, de MC_MoveAbsolute ) no se puede utilizar para controlar múltiples movimientos amortiguados\/mezclados siempre que esté Busy . Cuando una instancia de bloque de funciones es Busy , el comando para un nuevo movimiento almacenado en búfer o combinado con esta instancia genera el error SMC_MORE_THAN_ONE_MOVEMENT_PER_INSTANCE . Para ordenar múltiples movimientos almacenados en buffer o combinados del mismo tipo en un orden corto, se requieren múltiples instancias de módulo de funciones. " }, 
{ "title" : "Comportamiento en Caso de Error ", 
"url" : "_sm_basic_behavior_error.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos \/ Comportamiento en Caso de Error ", 
"snippet" : "Si se produce un error de eje (por ejemplo, el eje cambia al estado Errorstop ), el movimiento activo informará de un error junto con todos los demás movimientos aceptados. Si se produce un error de FB en el bloque de función de un movimiento activo, todos los movimientos aceptados posteriormente ta...", 
"body" : "Si se produce un error de eje (por ejemplo, el eje cambia al estado Errorstop ), el movimiento activo informará de un error junto con todos los demás movimientos aceptados. Si se produce un error de FB en el bloque de función de un movimiento activo, todos los movimientos aceptados posteriormente también notifican un error. Esto contrasta con PLCopen, Sección 2.2.2, en el que los comandos subsiguientes continuarán y luego se ejecutarán después de un error de FB. " }, 
{ "title" : "Comportamiento de MC_MoveSuperImposed y MC_HaltSuperImposed ", 
"url" : "_sm_buffermode_movesuperimposed.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos \/ Comportamiento de MC_MoveSuperImposed y MC_HaltSuperImposed ", 
"snippet" : "Si MC_MoveSuperImposed o MC_HaltSuperImposed está activo y el movimiento subyacente se cancela, entonces MC_MoveSuperImposed \/ MC_HaltSuperImposed también se aborta. Si no se cancela el movimiento subyacente, sino otro movimiento con el modo Buffered o se ordena uno de los Blending-BufferMode, el co...", 
"body" : "Si MC_MoveSuperImposed o MC_HaltSuperImposed está activo y el movimiento subyacente se cancela, entonces MC_MoveSuperImposed \/ MC_HaltSuperImposed también se aborta. Si no se cancela el movimiento subyacente, sino otro movimiento con el modo Buffered o se ordena uno de los Blending-BufferMode, el comportamiento es el siguiente: MC_MoveSuperImposed \/ MC_HaltSuperImposed no se cancelará cuando comience la combinación o se active el nuevo movimiento. En cambio, MC_MoveSuperImposed \/ MC_HaltSuperImposed continúa en segundo plano hasta terminar. " }, 
{ "title" : "A partir de CODESYS SoftMotion versión 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439539337338", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos \/ Comportamiento de MC_MoveSuperImposed y MC_HaltSuperImposed \/ A partir de CODESYS SoftMotion versión 4.17.0.0 ", 
"snippet" : "Cuando un MC_MoveAbsolute configurado con un modo almacenado en búfer o un modo de combinación, la posición final resultante es la suma de la posición configurada en MC_MoveAbsolute y la distancia configurada en MC_MoveSuperImposed \/ MC_HaltSuperImposed . Es irrelevante si o no MC_MoveSuperImposed \/...", 
"body" : "Cuando un MC_MoveAbsolute configurado con un modo almacenado en búfer o un modo de combinación, la posición final resultante es la suma de la posición configurada en MC_MoveAbsolute y la distancia configurada en MC_MoveSuperImposed \/ MC_HaltSuperImposed . Es irrelevante si o no MC_MoveSuperImposed \/ MC_HaltSuperImposed sigue activo. La distancia SuperImposed se conserva incluso después de que se haya completado el movimiento SuperImposed. La distancia Superimpuesta se restablece tan pronto como se ordena un movimiento de interrupción. " }, 
{ "title" : "Antes CODESYS SoftMotion versión 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439540497353", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dirigiendo múltiples movimientos \/ Comportamiento de MC_MoveSuperImposed y MC_HaltSuperImposed \/ Antes CODESYS SoftMotion versión 4.17.0.0 ", 
"snippet" : "Si una MC_MoveAbsolute asignado con el modo almacenado en búfer o se ordena un modo de fusión mientras se MC_MoveSuperImposed \/ MC_HaltSuperImposed está activo, la posición final resultante depende del estado del MC_MoveSuperImposed \/ MC_HaltSuperImposed en el momento en que el MC_MoveAbsolute está ...", 
"body" : "Si una MC_MoveAbsolute asignado con el modo almacenado en búfer o se ordena un modo de fusión mientras se MC_MoveSuperImposed \/ MC_HaltSuperImposed está activo, la posición final resultante depende del estado del MC_MoveSuperImposed \/ MC_HaltSuperImposed en el momento en que el MC_MoveAbsolute está activo. Si MC_MoveSuperImposed \/ MC_HaltSuperImposed todavía está activo en este momento, entonces la posición final resultante es la suma de la posición de MC_MoveAbsolute y la distancia de MC_MoveSuperImposed \/ MC_HaltSuperImposed . Por otra parte, si MC_MoveSuperImposed \/ MC_HaltSuperImposed ya no está activo en este momento, entonces la posición final resultante es la posición de MC_MoveAbsolute sin la distancia de MC_MoveSuperImposed \/ MC_HaltSuperImposed . De manera similar, la velocidad resultante de MC_MoveVelocity depende del estado de MC_MoveSuperImposed \/ MC_HaltSuperImposed cuando MC_MoveVelocity está activo. La siguiente curva muestra una MC_MoveSuperImposed ( sorber bloque de funciones) paralelo a tres movimientos absolutos con modo de búfer de mezcla BlendingHigh . El primer y segundo movimiento se ordenan con una velocidad de 100 u\/s con el ma0 y ma1 bloques de funciones. El ma2 El bloque de funciones ordena el tercer movimiento con una velocidad de 120 u\/s. La primera posición objetivo es 10 u, la segunda es 25 u y la tercera es 40 u. La velocidad del movimiento superpuesto es 20 y la distancia es 10. La posición resultante es 50 u: la posición del último movimiento absoluto más la distancia de MC_MoveSuperimposed . " }, 
{ "title" : "Puntos de conmutación digitales ", 
"url" : "_sm_digital_switches.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Puntos de conmutación digitales ", 
"snippet" : "CODESYS SoftMotion ofrece varias opciones para crear puntos de conmutación digitales. En esta sección se ofrece una descripción general de las ventajas y desventajas respectivas....", 
"body" : "CODESYS SoftMotion ofrece varias opciones para crear puntos de conmutación digitales. En esta sección se ofrece una descripción general de las ventajas y desventajas respectivas. " }, 
{ "title" : "Ejemplo de aplicación ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632666072", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Puntos de conmutación digitales \/ Ejemplo de aplicación ", 
"snippet" : "Se requieren puntos de conmutación digitales, por ejemplo, para encender una pistola de pegamento en función de la posición del eje. En el siguiente ejemplo, la pistola de pegamento debe aplicar adhesivo a un producto desde la posición 90 hasta la posición 120. Una pistola de pegamento tiene un retr...", 
"body" : "Se requieren puntos de conmutación digitales, por ejemplo, para encender una pistola de pegamento en función de la posición del eje. En el siguiente ejemplo, la pistola de pegamento debe aplicar adhesivo a un producto desde la posición 90 hasta la posición 120. Una pistola de pegamento tiene un retraso entre el encendido y la aplicación del pegamento. Lo mismo se aplica a la desconexión. Por lo tanto, es necesaria una compensación de encendido\/apagado para que la pistola de encolado se encienda 50 ms antes de la posición 90 y se apague 50 ms antes de la posición 120 " }, 
{ "title" : "Descripción general de los bloques de funciones ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632773598", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Puntos de conmutación digitales \/ Descripción general de los bloques de funciones ", 
"snippet" : "Bloque de funciones Múltiples puntos de conmutación Compensación activada\/desactivada Previsión Alta precisión (resolución temporal superior a la duración del ciclo) Base de datos Nota SMC_DigitalCamSwitch_HighPrecision 1 2 Definir posición o posición real Útil cuando se requiere una mayor precisión...", 
"body" : "Bloque de funciones Múltiples puntos de conmutación Compensación activada\/desactivada Previsión Alta precisión (resolución temporal superior a la duración del ciclo) Base de datos Nota SMC_DigitalCamSwitch_HighPrecision 1 2 Definir posición o posición real Útil cuando se requiere una mayor precisión de tiempo. Además de este bloque de funciones, se requiere una tarjeta de salida digital de alta precisión para un funcionamiento de alta precisión. Esta combinación permite conmutar las salidas con una gran precisión temporal incluso en ciclos más largos Para obtener más información sobre el uso del bloque de funciones, consulte lo siguiente: ejemplo Uso de MC_DigitalCamSwitch_HighPrecision. SMC_GetTravelTime 2 Definir posición o posición real Útil si se trata de una versión separada del DigitalCamSwitch se debe implementar el bloque de funciones (por ejemplo, porque se requieren funciones adicionales). MC_DigitalCamSwitch 3 Definir posición o posición real Útil si una resolución temporal precisa del ciclo es suficiente. SMC_GetTappetValue Definir posición o posición real Estos bloques de funciones se conservan únicamente por motivos de compatibilidad. Para los proyectos actuales y futuros, se deben usar los otros bloques de funciones más avanzados. SMC_CamRegister Definir posición o posición real 1 Exacto. Se utilizan los datos de la previsión. 2 La previsión debe establecerse mediante el SMC_SetForecast bloque de funciones. Para obtener más información sobre la previsión, consulte lo siguiente: Pronóstico. 3 Solo por extrapolación " }, 
{ "title" : "Adaptación dinámica con MC_SetOverride ", 
"url" : "_sm_adjust_dynamics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adaptación dinámica con MC_SetOverride ", 
"snippet" : "La dinámica (velocidad, aceleración y sacudida) de los movimientos activos y futuros se puede adaptar utilizando MC_SetOverride . Una adaptación de la dinámica significa siempre una reducción respecto al movimiento originalmente ordenado (no se permiten factores mayores que 1). Esto permite a los op...", 
"body" : "La dinámica (velocidad, aceleración y sacudida) de los movimientos activos y futuros se puede adaptar utilizando MC_SetOverride . Una adaptación de la dinámica significa siempre una reducción respecto al movimiento originalmente ordenado (no se permiten factores mayores que 1). Esto permite a los operadores de la máquina detener temporalmente un movimiento ( VelFactor = 0 ) o ejecutarlo con valores dinámicos reducidos, por ejemplo para comprobar nuevas secuencias de movimiento. La adaptación de la dinámica con MC_SetOverride y la adaptación resultante de la trayectoria tiene efecto directamente en el mismo ciclo. El requisito para esto es que MC_SetOverride se llama antes del bloque de funciones de movimiento activo. Para obtener más información, consulte también el ejemplo. Anulación de velocidad para ejes SoftMotion. " }, 
{ "title" : "Bloques de funciones compatibles ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4626631011382434026679825113", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adaptación dinámica con MC_SetOverride \/ Bloques de funciones compatibles ", 
"snippet" : "Bloque de funciones Apoyo: MC_SetOverride Comentario MC_Stop -- MC_Stop Es una parada de emergencia que siempre debe realizarse lo más rápido posible. Por lo tanto, los factores dinámicos de MC_SetOverride no tiene ningún efecto sobre el movimiento. MC_Halt ✓ El factor de velocidad no tiene ningún e...", 
"body" : "Bloque de funciones Apoyo: MC_SetOverride Comentario MC_Stop -- MC_Stop Es una parada de emergencia que siempre debe realizarse lo más rápido posible. Por lo tanto, los factores dinámicos de MC_SetOverride no tiene ningún efecto sobre el movimiento. MC_Halt ✓ El factor de velocidad no tiene ningún efecto. MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_Jog SMC_Inch ✓ SMC_Homing ✓ SMC_ControlAxisByPos SMC_ControlAxisByPosVel SMC_ControlAxisByVel O Los factores dinámicos tienen efecto sólo si el bAvoidGaps La función está activada y se ha detectado un salto. los factores de MC_SetOverride tener en cuenta tanto la parada como el posterior movimiento absoluto para cerrar la brecha. MC_Home -- El recorrido de referencia se realiza de forma independiente por el variador, de modo que los factores dinámicos de MC_SetOverride no tiene ningún efecto. MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- Recomendamos usar MC_CamIn en lugar de estos bloques de funciones. MC_CamIn O Los factores dinámicos dejan de tener efecto en cuanto se sincroniza el movimiento ( MC_CamIn.InSync = TRUE ). MC_CamOut -- MC_CamOut no tiene límites dinámicos ajustables y debe mantener la velocidad actual. Los factores dinámicos de MC_SetOverride por lo tanto no tienen efecto. MC_GearIn O Los factores dinámicos dejan de tener efecto en cuanto se sincroniza el movimiento ( MC_GearIn.InGear = TRUE ). Durante la rampa, sólo se consideran los factores de aceleración y sacudida. Cambios en el factor de velocidad (especialmente VelFactor=0 ) son ignorados. MC_GearInPos -- En contraste con MC_GearIn , no dispone de movimiento de rampa configurable. Por lo tanto, los factores dinámicos de MC_SetOverride no tiene efecto. SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- Estos bloques de funciones escriben los valores establecidos del eje (por ejemplo, fSetPosition ). Estos valores no deben modificarse. Por lo tanto, los factores dinámicos de MC_SetOverride no tiene efecto. MC_Phasing O Los factores dinámicos dejan de tener efecto en cuanto se sincroniza el movimiento ( MC_Phasing.Done = TRUE ). Durante la rampa, sólo se consideran los factores de aceleración y sacudida. Cambios en el factor de velocidad (especialmente VelFactor=0 ) son ignorados. SMC_BacklashCompensation -- Los factores dinámicos no influyen en los movimientos sincronizados. Por lo tanto, este bloque de funciones ignora los factores dinámicos de MC_SetOverride . " }, 
{ "title" : "Superar la posición objetivo o la velocidad objetivo cambiando los factores dinámicos ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469374918434026680028303", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adaptación dinámica con MC_SetOverride \/ Superar la posición objetivo o la velocidad objetivo cambiando los factores dinámicos ", 
"snippet" : "Si durante un movimiento activo se reduce el factor de aceleración y\/o el factor de sacudida, es posible que se supere temporalmente la posición objetivo o la velocidad objetivo. Esto puede provocar daños a la máquina. Con SMC_MoveContinuousAbsolute y SMC_MoveContinuousRelative , una modificación de...", 
"body" : "Si durante un movimiento activo se reduce el factor de aceleración y\/o el factor de sacudida, es posible que se supere temporalmente la posición objetivo o la velocidad objetivo. Esto puede provocar daños a la máquina. Con SMC_MoveContinuousAbsolute y SMC_MoveContinuousRelative , una modificación del factor de velocidad también puede provocar que se superen los límites o se produzca una inversión. Se pueden encontrar más detalles en la documentación de los dos bloques de funciones. " }, 
{ "title" : "Efecto del perfil de velocidad en el uso de MC_SetOverride ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469646968034026680341439", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adaptación dinámica con MC_SetOverride \/ Efecto del perfil de velocidad en el uso de MC_SetOverride ", 
"snippet" : "En general, se recomienda usar MC_SetOverride junto con un perfil de velocidad trapezoidal o cuadrático de los ejes. Los perfiles de velocidad cuadráticamente suavizados y sin² no responden bien al reiniciar ( Interrupción de movimientos). Como cambiar la anulación equivale a reiniciar el movimiento...", 
"body" : "En general, se recomienda usar MC_SetOverride junto con un perfil de velocidad trapezoidal o cuadrático de los ejes. Los perfiles de velocidad cuadráticamente suavizados y sin² no responden bien al reiniciar ( Interrupción de movimientos). Como cambiar la anulación equivale a reiniciar el movimiento con los límites modificados, también es posible superar los límites establecidos al utilizar estos perfiles de velocidad en combinación MC_SetOverride . " }, 
{ "title" : "Efecto de MC_SetOverride en movimientos coordinados con un grupo de ejes ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm456655390848963402668059106", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adaptación dinámica con MC_SetOverride \/ Efecto de MC_SetOverride en movimientos coordinados con un grupo de ejes ", 
"snippet" : "Movimientos coordinados con un grupo de ejes (por ejemplo, MC_MoveLinearAbsolute ) considere las anulaciones establecidas con MC_SetOverride para cada eje durante la planificación del movimiento. En cambio, MC_GroupSetOverride sobrescribe las anulaciones de cada eje del grupo de ejes....", 
"body" : "Movimientos coordinados con un grupo de ejes (por ejemplo, MC_MoveLinearAbsolute ) considere las anulaciones establecidas con MC_SetOverride para cada eje durante la planificación del movimiento. En cambio, MC_GroupSetOverride sobrescribe las anulaciones de cada eje del grupo de ejes. " }, 
{ "title" : "Pronóstico ", 
"url" : "_sm_basic_forecast.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Pronóstico ", 
"snippet" : "La función de previsión se puede utilizar para consultar información sobre el movimiento futuro de un eje. Una aplicación importante del pronóstico es determinar el tiempo hasta que se alcanza una posición (similar a la funcionalidad de activación). Otra aplicación es determinar la posición y veloci...", 
"body" : "La función de previsión se puede utilizar para consultar información sobre el movimiento futuro de un eje. Una aplicación importante del pronóstico es determinar el tiempo hasta que se alcanza una posición (similar a la funcionalidad de activación). Otra aplicación es determinar la posición y velocidad que tendrá un eje en un momento dado. De esta manera se pueden compensar tiempos muertos al conectar actuadores, por ejemplo al conectar una boquilla de encolado. También se puede utilizar para controlar con precisión actuadores con tiempo muerto, como controlar la salida de encolado en función de la velocidad del eje 100 ms en el futuro. Para implementar estas aplicaciones, puede utilizar el SMC_GetTravelTime y SMC_ReadSetValues bloques de funciones después de haber configurado la duración del pronóstico con SMC_SetForecast . Para ver un ejemplo de uso, consulte: Previsión de movimientos de un solo eje" }, 
{ "title" : "Bloques de funciones de movimiento con funcionalidad de previsión. ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm2344331274012", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Pronóstico \/ Bloques de funciones de movimiento con funcionalidad de previsión. ", 
"snippet" : "La siguiente descripción general muestra qué bloques de funciones admiten la función de pronóstico. Bloque de funciones Pronóstico MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute...", 
"body" : "La siguiente descripción general muestra qué bloques de funciones admiten la función de pronóstico. Bloque de funciones Pronóstico MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- MC_CamIn ✓ MC_CamOut ✓ MC_GearIn ✓ MC_GearOut ✓ MC_GearInPos ✓ SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- SMC_SetTorque -- MC_Phasing ✓ MC_Jog SMC_Inch ✓ SMC_BacklashCompensation ✓ " }, 
{ "title" : "Habilitar la función de pronóstico ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433129890703", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Pronóstico \/ Habilitar la función de pronóstico ", 
"snippet" : "La función de pronóstico está deshabilitada de forma predeterminada. Esto significa que SMC_ReadSetValues devuelve valores válidos sólo para un TimeOffset entre 0 s (inicio del ciclo de tarea actual) y el intervalo de tarea (final del ciclo de tarea actual), y SMC_GetTravelTime devuelve un tiempo vá...", 
"body" : "La función de pronóstico está deshabilitada de forma predeterminada. Esto significa que SMC_ReadSetValues devuelve valores válidos sólo para un TimeOffset entre 0 s (inicio del ciclo de tarea actual) y el intervalo de tarea (final del ciclo de tarea actual), y SMC_GetTravelTime devuelve un tiempo válido sólo para las posiciones que se alcanzan en este ciclo. El SMC_SetForecast El bloque de funciones se utiliza para configurar la duración del pronóstico requerido y el SMC_GetForecast El bloque de funciones se utiliza para leer. Notas: La duración del pronóstico se puede cambiar en cualquier momento. Evite una duración de pronóstico innecesariamente larga porque el cálculo del pronóstico consume tiempo de cálculo. Seleccione el valor más pequeño que sea suficiente para su aplicación. Si utiliza bloques de funciones maestro\/esclavo (como MC_CamIn ), entonces la previsión debe estar habilitada tanto para el eje maestro como para el eje esclavo. " }, 
{ "title" : "Orden de llamada ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130424909", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Pronóstico \/ Orden de llamada ", 
"snippet" : "Para que la función de pronóstico produzca los mejores resultados posibles, es importante asegurarse de que los bloques de funciones maestro\/esclavo se llamen en el orden correcto. Esto aplica a MC_CamIn , MC_GearIn , MC_GearInPos , MC_Phasing , SMC_BacklashCompensation , y SMC_TrackAxis . El bloque...", 
"body" : "Para que la función de pronóstico produzca los mejores resultados posibles, es importante asegurarse de que los bloques de funciones maestro\/esclavo se llamen en el orden correcto. Esto aplica a MC_CamIn , MC_GearIn , MC_GearInPos , MC_Phasing , SMC_BacklashCompensation , y SMC_TrackAxis . El bloque de funciones de movimiento del eje maestro debe llamarse antes que el bloque de funciones maestro\/esclavo. Incluso sin previsión, la trayectoria es mejor cuando el orden de llamada es correcto. Cuando el orden es incorrecto, el movimiento del esclavo se retrasa un ciclo. Para MC_SetOverride , este bloque de funciones también debe llamarse antes de los bloques de funciones de movimiento del eje. Al cambiar la anulación, el movimiento del eje se cambia en el mismo ciclo de tarea. Como resultado, los valores determinados previamente según el pronóstico pierden su validez. Están decididos nuevamente la próxima vez. SMC_GetTravelTime o SMC_ReadSetValues se llama. " }, 
{ "title" : "Modos de búfer ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130652478", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Pronóstico \/ Modos de búfer ", 
"snippet" : "La función de previsión no se limita a un único movimiento. También se extiende a todos los movimientos posteriores que se ordenan con un modo de mezcla o búfer almacenado en búfer. Cuando se ejecuta un movimiento de aborto en un eje, cambia el movimiento del eje en este ciclo de tarea. Como resulta...", 
"body" : "La función de previsión no se limita a un único movimiento. También se extiende a todos los movimientos posteriores que se ordenan con un modo de mezcla o búfer almacenado en búfer. Cuando se ejecuta un movimiento de aborto en un eje, cambia el movimiento del eje en este ciclo de tarea. Como resultado, los valores determinados previamente según el pronóstico pierden su validez. Están decididos nuevamente la próxima vez. SMC_GetTravelTime o SMC_ReadSetValues se llama. " }, 
{ "title" : "Previsión\/restricciones efectivas ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130869747", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Pronóstico \/ Previsión\/restricciones efectivas ", 
"snippet" : "Idealmente, la duración efectiva del pronóstico disponible es igual a la duración del pronóstico configurado. Sin embargo, existen algunos factores que pueden provocar que la previsión efectiva sea más corta que la previsión configurada. Cuando se ejecuta un movimiento maestro\/esclavo, la previsión ...", 
"body" : "Idealmente, la duración efectiva del pronóstico disponible es igual a la duración del pronóstico configurado. Sin embargo, existen algunos factores que pueden provocar que la previsión efectiva sea más corta que la previsión configurada. Cuando se ejecuta un movimiento maestro\/esclavo, la previsión efectiva del esclavo es el mínimo de la previsión efectiva del maestro y la previsión configurada del esclavo. Para ejes lógicos y ejes codificadores, la previsión efectiva es siempre 0. Si el bloque de funciones de movimiento activo no admite la función de pronóstico, entonces el pronóstico efectivo también es 0. En todos los demás casos, la previsión efectiva es la misma que la previsión configurada. " }, 
{ "title" : "Diagnóstico ", 
"url" : "_sm_basic_error_diagnosis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Diagnóstico ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Errores comunes ", 
"url" : "_sm_basic_common_errors.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Diagnóstico \/ Errores comunes ", 
"snippet" : "Esta página describe errores comunes al usar CODESYS Softmotion Basic , sus causas y posibles acciones a tomar para corregir el error. Para obtener una lista de todos los errores posibles con una breve descripción, consulte la documentación de la biblioteca: SMC_ERROR Código de error Descripción y c...", 
"body" : "Esta página describe errores comunes al usar CODESYS Softmotion Basic , sus causas y posibles acciones a tomar para corregir el error. Para obtener una lista de todos los errores posibles con una breve descripción, consulte la documentación de la biblioteca: SMC_ERROR Código de error Descripción y causas Comportamiento SMC_DI_AXIS_ERROR La unidad ha informado de un error. Posibles Causas: Retraso de posición Límite de cambio Sobrecarga (error I²t) Compruebe qué error informa la unidad. El error se puede leer en la pantalla de la unidad (si está disponible) o buscándolo con el MC_ReadAxisError bloque de funciones. SMC_AXIS_ERROR_DURING_MOTION La unidad ha informado de un error. Durante un movimiento, el bloque de movimiento activo devuelve este error. Ver las acciones para el error. SMC_DI_AXIS_ERROR . SMC_FB_WASNT_CALLED_DURING_MOTION El bloque de funciones que controla el movimiento activo no ha sido llamado en el ciclo actual. Posibles causas: El orden de llamada para los movimientos almacenados en búfer o los movimientos de combinación es incorrecto. La instancia del bloque funcional del movimiento posterior no debe invocarse antes que la instancia del bloque funcional que ordenó el movimiento anterior A partir de SoftMotion En la versión 4.15.0.0, el mensaje de registro de este error contiene la ruta de la instancia al bloque de funciones afectado. Compruebe en la aplicación por qué el bloque de funciones no se ha llamado cíclicamente. Arregle la llamada para que se realice cíclicamente (al menos mientras el bloque esté en uso). SMC_BLOCKING_MC_STOP_WASNT_CALLED Durante una parada activa, el bloque de funciones asociado MC_Stop no fue convocado en el ciclo actual. Ver las acciones para el error. SMC_FB_WASNT_CALLED_DURING_MOTION . SMC_AXIS_NOT_READY_FOR_MOTION El eje no está listo para su uso y no puede ejecutar el movimiento deseado. Posibles Causas: El eje no se encuentra en estado operativo para el movimiento respectivo (p. ej. power_off o errorstop ). El eje está en estado de error y todos los movimientos almacenados en búfer devuelven este error. El eje está en el stopping estado (durante una actividad MC_Stop ) y se ordena un nuevo movimiento de aborto. Comprobar el estado del eje: ¿Está el eje en estado operativo según MC_Power ? ¿Está el eje en el errorstop ¿estado? Si es así, identifique el error del eje y corríjalo. ¿El estado del eje coincide con el movimiento ordenado? Por ejemplo, MC_CamOut Sólo se puede ordenar cuando el eje está en estado de movimiento sincronizado. SMC_FB_CALLED_FROM_WRONG_TASK El SoftMotion El bloque fue llamado desde una tarea que no corresponde a la tarea de bus del eje. Porque el SoftMotion Los bloques cambian los valores en el eje, pueden ocurrir estados inconsistentes si las llamadas se realizan desde tareas distintas a la tarea del bus. Esto puede provocar errores indefinidos, lo que se evita con este error. Compruebe el registro: se registran el eje afectado y la instancia de bloque. Elimine la llamada de la tarea incorrecta. SMC_DI_FIELDBUS_LOST_SYNCRONICITY Ocurre cuando se usa EtherCAT con relojes distribuidos si la trama del controlador a la unidad no se recibió a tiempo (dentro de la ventana de tiempo definida (\"SyncWindow\") o no se recibió en absoluto. Posibles Causas: Problemas en tiempo real: La inquietud de la tarea es demasiado alta. La prioridad de la tarea del EtherCAT La tarea es demasiado baja. Otros buses de campo (por ejemplo, Modbus ) u operaciones prolongadas además de las tareas de control (por ejemplo, acceso a archivos) en el EtherCAT tarea Modbus se ejecuta en otra tarea, pero los canales de E\/S que utiliza también se hacen referencia en la EtherCAT tarea. Especialmente con los sistemas operativos Linux, la configuración del sistema (por ejemplo, prioridades IRQ) problema de comunicación con el EtherCAT esclavo: Conexión interrumpida, problemas de compatibilidad electromagnética (EMC), etc. Verifique la causa del comportamiento. Las siguientes funciones pueden ayudarle con esto: El Página de estado del EtherCAT Maestro Análisis del ciclo y tiempos de jitter de la tarea EtherCAT en el Configuración de tareas Posibles acciones para problemas en tiempo real: Optimiza el tiempo real. Para ello, siga las instrucciones que aparecen en Optimización del rendimiento Aumentar el tiempo del ciclo del EtherCAT tarea. Aumentar DCInSyncWindow del EtherCAT Maestro. Ver: IoDrvEtherCAT.DCInSyncWindow (PROP) Permitir FrameAtTaskStart Para el EtherCAT Maestro. Ver: IoDrvEtherCAT.FrameAtTaskStart (PROP) Si la unidad puede manejar los problemas de sincronización, entonces la verificación de sincronización se puede desactivar mediante SMC_Set_ETC_DCSyncSupervisión . SMC_DI_SWLIMITS_EXCEEDED El eje se mueve en dirección al final de carrera por software positivo o negativo y lo sobrepasará con la dinámica actual. El error también se produce antes de la posición real del final de carrera, ya que en el cálculo también se incluye la distancia de frenado necesaria. Compruebe si se desea o no el movimiento en este rango de posiciones. Si es necesario, ajuste la posición del interruptor de límite de software negativo y\/o positivo. Ver Pestaña: GeneralSMC_DI_HWLIMITS_EXCEEDED El final de carrera por hardware positivo o negativo se ha disparado y el eje se mueve en la dirección de este final de carrera. Comprobar la posición comandada del movimiento. Esto no debe exceder las posiciones de los interruptores de límite de hardware. Si el movimiento es correcto, verifique las señales de los finales de carrera de hardware. SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT No hay movimiento activo, pero la velocidad ajustada no es igual a cero y el eje se encuentra en un estado operativo en el que se siguen los valores ajustados. Posibles Causas: Cuando usas MC_PositionProfile , MC_VelocityProfile , o MC_AccelerationProfile , el eje debe detenerse al final de este movimiento o se debe ordenar un movimiento posterior en el mismo ciclo. De lo contrario, se devuelve este error. Verifique la causa del problema: Orden de llamada incorrecto para movimientos almacenados en búfer y combinados: ajuste el orden de llamada. Para más información, consulte la sección Orden de ejecución de los bloques de funciones de movimiento. MC_PositionProfile , MC_VelocityProfile , o MC_AccelerationProfile se utiliza y al final no se llega a la parada: ajustar el perfil correspondientemente para que se alcance la parada al final. O en su lugar usar Cámaras, que cubren un caso de uso similar a estos bloques de funciones, pero son más flexibles y fáciles de usar. " }, 
{ "title" : "Actuación ", 
"url" : "_sm_diagnosis_performance.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Diagnóstico \/ Actuación ", 
"snippet" : "POU que utilizan el AXIS_REF_SM3 El bloque de funciones siempre comprueba si se llaman o no desde la tarea de ciclo de bus. Esta verificación se puede deshabilitar para aplicaciones de tiempo crítico por medio de la definición del compilador SM3_DISABLE_TASK_CHECKS ....", 
"body" : "POU que utilizan el AXIS_REF_SM3 El bloque de funciones siempre comprueba si se llaman o no desde la tarea de ciclo de bus. Esta verificación se puede deshabilitar para aplicaciones de tiempo crítico por medio de la definición del compilador SM3_DISABLE_TASK_CHECKS . " }, 
{ "title" : "Ejemplos ", 
"url" : "_sm_basic_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Movimientos de un solo eje ", 
"url" : "_sm_basic_examples_single_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos de un solo eje ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Controlar el movimiento de ejes individuales ", 
"url" : "_sm_example_single_axis_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos de un solo eje \/ Controlar el movimiento de ejes individuales ", 
"snippet" : "Ver el PLCopenSingle.project proyecto de ejemplo en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo demuestra cómo controlar un convertidor mediante bloques de función estandarizados PLCopen. Inserte una unidad virtual llamada Drive en el árbol de dis...", 
"body" : "Ver el PLCopenSingle.project proyecto de ejemplo en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo demuestra cómo controlar un convertidor mediante bloques de función estandarizados PLCopen. Inserte una unidad virtual llamada Drive en el árbol de dispositivos a continuación Piscina SoftMotion General Axis . Crear un MOTION_PRG programa en ST. PROGRAM MOTION_PRG\nVAR\n iStatus: INT;\n Power: MC_Power;\n MoveAbsolute: MC_MoveAbsolute;\n p:REAL:=100;\nEND_VAR\n\nCASE iStatus OF\n\n\/\/ initialization of the axis\n0:\n Power(Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE, Axis:=Drive);\n IF Power.Status THEN\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis to position p by use of the MC_MoveAbsolute function block\n1:\n MoveAbsolute(Execute:=TRUE, Position:= p, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis back to position 0 by use of the MC_MoveAbsolute function block:\n2:\n MoveAbsolute(Execute:=TRUE, Position:= 0, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := 1;\n END_IF Agregue la llamada del programa MOTION_PRG a la tarea Tarea principal . Árbol de dispositivos: Descargue el proyecto al controlador e inícielo. Abre el Conducir eje virtual en el editor. En el En línea parte de General pestaña, verá el movimiento del eje. " }, 
{ "title" : "Control del movimiento de ejes individuales en CFC con una plantilla de visualización ", 
"url" : "_sm_example_single_axis_visu_template.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos de un solo eje \/ Control del movimiento de ejes individuales en CFC con una plantilla de visualización ", 
"snippet" : "Ver el PLCopenSingle2.project proyecto de ejemplo en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . También se puede utilizar cualquiera de los otros lenguajes de implementación IEC en lugar de ST, por ejemplo, aquí CFC. Este lenguaje demuestra el mecanismo de in...", 
"body" : "Ver el PLCopenSingle2.project proyecto de ejemplo en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . También se puede utilizar cualquiera de los otros lenguajes de implementación IEC en lugar de ST, por ejemplo, aquí CFC. Este lenguaje demuestra el mecanismo de inicio e interrupción de los bloques de funciones. Además, los diferentes modos de inicio del bloque de funciones MC_MoveAbsolute se puede probar para ejes rotatorios. Inserte una unidad virtual llamada Drive en el árbol de dispositivos a continuación Piscina SoftMotion General Axis . Haga doble clic en el objeto para abrir su editor. Cambie los parámetros a un actuador giratorio con un período de 360 °. Tipo de eje : Módulo Valor de módulo [u] : 360.0 Crear un MOTION_PRG programa en CFC. Insertar los bloques de función MC_Power , MC_MoveAbsolute , y MC_MoveVelocity . Generalmente se recomienda inicializar las entradas del bloque de funciones. Entonces no es necesario que especifique los valores una y otra vez más tarde al iniciar esta aplicación de prueba. PROGRAM MOTION_PRG\nVAR\n mcp: MC_Power := (Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n mcmv: MC_MoveVelocity :=(Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\n mcma: MC_MoveAbsolute := (Position:=180, Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\nEND_VAR CFC: Agregue la llamada del MOTION_PRG programa a la tarea Tarea principal . Agrega un Visualización objetar la solicitud. Posicionar las plantillas de visualización VISU_NEW_MC_MoveAbsolute , VISU_NEW_MC_MoveVelocity , VISU_NEW_MC_Power , y RotDrive en el editor de visualización. Vincularlos a las instancias de bloques de funciones de MOTION_PRG . Visualización: Construya el proyecto y descárguelo al PLC. Inicie el proyecto. Abra la visualización en el editor. Haga clic en el Habilitar entrada (MC_Power) y luego la Ejecutar entrada (MC_Move_Absolute). La unidad gira. Abre el Conducir eje virtual en el editor. En el En línea parte de General pestaña, verá el movimiento del eje. Experimente con los parámetros de estos bloques de funciones. Cambie los parámetros y observe el comportamiento. " }, 
{ "title" : "Previsión de movimientos de un solo eje ", 
"url" : "_sm_basic_example_forecast.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos de un solo eje \/ Previsión de movimientos de un solo eje ", 
"snippet" : "El BasicMotion_Forecast.project El proyecto de muestra se encuentra en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo definir un pronóstico para un eje para obtener información sobre el estado del eje en el futuro. En el ejemplo, se ejecuta un...", 
"body" : "El BasicMotion_Forecast.project El proyecto de muestra se encuentra en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo definir un pronóstico para un eje para obtener información sobre el estado del eje en el futuro. En el ejemplo, se ejecuta un movimiento absoluto en un eje hasta la posición 10. Fijando una previsión de 300 ms en el eje, se puede saber de antemano en la aplicación cuándo y con qué dinámica se moverá el eje hasta la posición 8. Para más información sobre la previsión por ejes, consulte: Pronóstico" }, 
{ "title" : "Estructura de la aplicación ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768266588", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos de un solo eje \/ Previsión de movimientos de un solo eje \/ Estructura de la aplicación ", 
"snippet" : "La aplicación consiste en un PLC_PRG programa y un Trace . PLC_PRG El eje virtual se enciende en el STATE_POWER_DRIVE estado. Entonces el SMC_SetForecast El bloque de funciones se utiliza para definir un pronóstico de 300 ms para el eje en el STATE_SET_FORECAST estado. El SMC_GetForecast El bloque d...", 
"body" : "La aplicación consiste en un PLC_PRG programa y un Trace . PLC_PRG El eje virtual se enciende en el STATE_POWER_DRIVE estado. Entonces el SMC_SetForecast El bloque de funciones se utiliza para definir un pronóstico de 300 ms para el eje en el STATE_SET_FORECAST estado. El SMC_GetForecast El bloque de funciones se puede utilizar para leer el pronóstico establecido para el eje. En el STATE_MOVE_TO_POSITION estado, se ejecuta un movimiento absoluto a la posición 10. El SMC_GetTravelTime También se inicia el bloque de funciones. El bloque de funciones se utiliza para leer el tiempo en que el eje alcanzará la posición 8. El SMC_ReadSetValues El bloque de funciones se utiliza para determinar la dinámica en la posición 8. Se puede pasar un desplazamiento de tiempo a este bloque de funciones donde se debe leer la dinámica del eje. En nuestro caso, pasamos el tiempo que necesita el eje para alcanzar la posición 8. Rastro Puede utilizar la traza para seguir el movimiento del eje virtual. Se registran la posición actual, la velocidad y la aceleración del eje. También se muestran la duración hasta la posición 8 y la dinámica del eje en esta posición. Tenga en cuenta que la duración de SMC_GetTravelTime se especifica en relación con el inicio del ciclo. Los valores configurados del eje corresponden a los del final del ciclo. " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768283734", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos de un solo eje \/ Previsión de movimientos de un solo eje \/ Puesta en servicio ", 
"snippet" : "Compile la aplicación y descárguela a un controlador. Inicie el rastreo y la aplicación. En el seguimiento, puede seguir el movimiento del eje virtual. Preste atención a la duración hasta la posición 8 y a la dinámica en la posición 8....", 
"body" : "Compile la aplicación y descárguela a un controlador. Inicie el rastreo y la aplicación. En el seguimiento, puede seguir el movimiento del eje virtual. Preste atención a la duración hasta la posición 8 y a la dinámica en la posición 8. " }, 
{ "title" : "Movimientos sincrónicos de dos ejes ", 
"url" : "_sm_basic_synch_movements_2_axis_example.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos sincrónicos de dos ejes ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Engranajes electrónicos, compensación de fase y compensación del juego del engranaje ", 
"url" : "_sm_basic_example_synchronized_motion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos sincrónicos de dos ejes \/ Engranajes electrónicos, compensación de fase y compensación del juego del engranaje ", 
"snippet" : "Ver el BasicMotion_SynchronizedMotion.project ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo utilizar una caja de cambios electrónica en combinación con un desplazamiento de fase y una compensación del juego del engranaje....", 
"body" : "Ver el BasicMotion_SynchronizedMotion.project ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo utilizar una caja de cambios electrónica en combinación con un desplazamiento de fase y una compensación del juego del engranaje. " }, 
{ "title" : "Estructura de la aplicación ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos sincrónicos de dos ejes \/ Engranajes electrónicos, compensación de fase y compensación del juego del engranaje \/ Estructura de la aplicación ", 
"snippet" : "La aplicación consta de una máquina de estados simple en el PLC_PRG programa y un seguimiento que puede utilizar para realizar un seguimiento sencillo de la funcionalidad de los bloques de funciones. Habilitar los ejes con MC_Power . (STATE_POWER ) Inicie los movimientos sincrónicos y mueva el eje m...", 
"body" : "La aplicación consta de una máquina de estados simple en el PLC_PRG programa y un seguimiento que puede utilizar para realizar un seguimiento sencillo de la funcionalidad de los bloques de funciones. Habilitar los ejes con MC_Power . (STATE_POWER ) Inicie los movimientos sincrónicos y mueva el eje maestro continuamente entre la posición 0 y la posición 100 ( STATE_COMMAND_POS_0 y STATE_COMMAND_POS_1 ). " }, 
{ "title" : "Uso ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos sincrónicos de dos ejes \/ Engranajes electrónicos, compensación de fase y compensación del juego del engranaje \/ Uso ", 
"snippet" : "El eje maestro (negro en el diagrama de seguimiento) se mueve continuamente hacia adelante y hacia atrás entre la posición 0 y la posición 100 a una velocidad máxima de 50 unidades por segundo. Una caja de cambios electrónica ( MC_GearIn ) con una relación de transmisión de 2:3 convierte el movimien...", 
"body" : "El eje maestro (negro en el diagrama de seguimiento) se mueve continuamente hacia adelante y hacia atrás entre la posición 0 y la posición 100 a una velocidad máxima de 50 unidades por segundo. Una caja de cambios electrónica ( MC_GearIn ) con una relación de transmisión de 2:3 convierte el movimiento maestro en el Slave0 eje (verde en el diagrama de seguimiento). La velocidad máxima resultante de los engranajes es de 75 unidades por segundo. Entonces, un desplazamiento de fase ( MC_Phasing ) de 30 unidades se aplica a la Slave1 eje (naranja en el diagrama de traza). La velocidad es idéntica a la Slave0 eje, excepto en la fase de rampa de entrada. Finalmente, la compensación del juego del engranaje se utiliza para llevar el movimiento al Drive eje (azul en el diagrama de seguimiento). Para fines demostrativos se establece un valor irrealmente alto de 5 unidades para el juego del engranaje. El diagrama muestra un movimiento de compensación al inicio del movimiento y en cada inversión de la dirección del movimiento. " }, 
{ "title" : "GearInPos (Sierra voladora) ", 
"url" : "_sm_basic_example_gearinpos.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos sincrónicos de dos ejes \/ GearInPos (Sierra voladora) ", 
"snippet" : "Ver el BasicMotion_GearInPos.project ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo utilizar MC_GearInPos para implementar una sierra voladora. Para este proyecto, recomendamos instalar CODESYS Depictor , que puede mostrar la aplica...", 
"body" : "Ver el BasicMotion_GearInPos.project ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo utilizar MC_GearInPos para implementar una sierra voladora. Para este proyecto, recomendamos instalar CODESYS Depictor , que puede mostrar la aplicación como una animación 3D. (La versión gratuita sin licencia es suficiente para hacer esto). " }, 
{ "title" : "Estructura de la aplicación ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4565133330038434227193133829", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos sincrónicos de dos ejes \/ GearInPos (Sierra voladora) \/ Estructura de la aplicación ", 
"snippet" : "La aplicación consta de una máquina de estados en el PLC_PRG programa, una representación 3D (Escena, DepictorCalculation programa), una simulación simple de la pieza ( SimulateWorkpiece programa), y un seguimiento que puede utilizar para comprender fácilmente el efecto de los bloques de funciones. ...", 
"body" : "La aplicación consta de una máquina de estados en el PLC_PRG programa, una representación 3D (Escena, DepictorCalculation programa), una simulación simple de la pieza ( SimulateWorkpiece programa), y un seguimiento que puede utilizar para comprender fácilmente el efecto de los bloques de funciones. El flujo en PLC_PRG es el siguiente: Habilitar los ejes con MC_Power . ( STATE_POWER ) Espere hasta que la barrera fotoeléctrica detecte una pieza. ( STATE_WAIT_FOR_WORKPIECE ) Tan pronto como la barrera fotoeléctrica detecta una pieza, el esclavo que transporta la sierra paralelamente a la cinta transportadora se sincroniza con la pieza sobre la cinta transportadora (controlado por el Master eje). ( STATE_WAIT_FOR_SYNC ) Cuando se alcanza la sincronización, la sierra se mueve hacia adelante y hacia atrás una vez perpendicularmente a la pieza de trabajo. ( STATE_MOVE_TOOL_0\/1 ) Mueva el esclavo a la posición de reposo y comience el proceso nuevamente en 2. ( STATE_MOVE_TO_REST ) " }, 
{ "title" : "Sistemas de coordenadas y dimensiones. ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4627667581768034227193767932", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos sincrónicos de dos ejes \/ GearInPos (Sierra voladora) \/ Sistemas de coordenadas y dimensiones. ", 
"snippet" : "El origen del sistema de coordenadas está en el centro de la cinta transportadora, el eje Z apunta hacia arriba y el eje X apunta en la dirección del movimiento de la cinta transportadora. Desde la cinta transportadora, el eje Y apunta en dirección opuesta a la sierra. Las dimensiones de la cinta tr...", 
"body" : "El origen del sistema de coordenadas está en el centro de la cinta transportadora, el eje Z apunta hacia arriba y el eje X apunta en la dirección del movimiento de la cinta transportadora. Desde la cinta transportadora, el eje Y apunta en dirección opuesta a la sierra. Las dimensiones de la cinta transportadora y de la pieza de trabajo, la posición de la barrera fotoeléctrica y la posición de marcha sincronizada de la sierra con la pieza de trabajo se guardan como constantes en el GVL Const . " }, 
{ "title" : "Uso ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm458752582335683422719410462", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Movimientos sincrónicos de dos ejes \/ GearInPos (Sierra voladora) \/ Uso ", 
"snippet" : "Inicie la aplicación. En el Escena Objeto representador y en la traza se puede ver cómo se realiza la sincronización entre el maestro (pieza de trabajo en la cinta transportadora) y el esclavo (sierra)....", 
"body" : "Inicie la aplicación. En el Escena Objeto representador y en la traza se puede ver cómo se realiza la sincronización entre el maestro (pieza de trabajo en la cinta transportadora) y el esclavo (sierra). " }, 
{ "title" : "Cámaras ", 
"url" : "_sm_basic_examples_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Levas alternas ", 
"url" : "_sm_example_changing_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Levas alternas ", 
"snippet" : "Ver el PLCopenMultiCAM.project proyecto de ejemplo en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo demuestra cómo se puede crear un movimiento de levas con dos levas alternas. El programa se implementa en ST y ejecuta las mismas acciones que el eje...", 
"body" : "Ver el PLCopenMultiCAM.project proyecto de ejemplo en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo demuestra cómo se puede crear un movimiento de levas con dos levas alternas. El programa se implementa en ST y ejecuta las mismas acciones que el ejemplo \"Control de accionamiento de levas utilizando un eje de tiempo virtual\". Al final de la primera leva, el MC_CamIn bloque de función establece el EndOfProfile producción. De esta forma, la otra tabla de curvas se asigna a MC_CamTableSelect y MC_CamIn se reinicia. " }, 
{ "title" : "Control de una unidad de levas con un eje de tiempo virtual ", 
"url" : "_sm_example_drive_control_virtual_time_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Control de una unidad de levas con un eje de tiempo virtual ", 
"snippet" : "Ver el PLCopenMulti.project proyecto de ejemplo en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo demuestra cómo implementar una leva periódica en un accionamiento lineal. El ejemplo también demuestra cómo utilizar la función de empujador. Inserte un...", 
"body" : "Ver el PLCopenMulti.project proyecto de ejemplo en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo demuestra cómo implementar una leva periódica en un accionamiento lineal. El ejemplo también demuestra cómo utilizar la función de empujador. Inserte una cámara llamada Example en el árbol de dispositivos a continuación Solicitud . Abra la cámara en el editor. Defina un empujador en el Alzaválvulas pestaña. X : 8.0 Pase positivo : Invert Pase negativo : Invert Inserte una unidad virtual llamada Drive en el árbol de dispositivos a continuación Piscina SoftMotion General Axis . Para este eje, seleccione el tipo de eje Modulo con un valor de módulo de 360 . Inserte otra unidad virtual llamada Virtual . Para este eje, seleccione el Modulo tipo de eje con un valor de módulo de 10 . Crear un MOTION_PRG programa en CFC. PROGRAM MOTION_PRG\nVAR\n power1, power2: MC_Power;\n TableSelect: MC_CamTableSelect;\n CamIn: MC_CamIn;\n Tappet: SMC_GetTappetValue;\n MoveVirtual: MC_MoveVelocity;\nEND_VAR Insertar un elemento de caja y asignar la variable power1 lo. El elemento de caja se utiliza para encender el Drive . Configure las entradas de la siguiente manera: Eje : Drive Habilitar : TRUE bRegulatorOn : TRUE bDriveStart TRUE Insertar un elemento de caja y asignar la variable power2 lo. El elemento de caja se utiliza para encender el Virtual conducir. Configure las entradas de la siguiente manera: Eje : Virtual Habilitar : TRUE bRegulatorOn : TRUE bDriveStart TRUE Insertar un elemento de caja y asignar la variable MoveVirtual lo. El elemento de caja se utiliza para mover el maestro virtual. Configure las entradas de la siguiente manera: Eje : Virtual Ejecutar : power2.Status Velocidad : 2 Aceleración 10 Desaceleración 10 Dirección positive Insertar un elemento de caja y asignar la variable TableSelect lo. El elemento de caja se utiliza para seleccionar una leva. Configure las entradas de la siguiente manera: Maestría : Virtual Esclavo : Drive CamTable : Example Ejecutar TRUE Periódico TRUE Maestro Absoluto TRUE Esclavo Absoluto TRUE Insertar un elemento de caja y asignar la variable CamIn lo. El elemento de caja implementa la placa de levas seleccionada. Configure las entradas de la siguiente manera: Maestría : Virtual Esclavo : Drive Ejecutar power1.Status MasterOffset : 0 SlaveOffset : 0 MasterScaling : 1 Esclavo Escalado : 1 StartMode : absolute CamTableID : TableSelect.CamTableID VelocityDiff : 1 Aceleración : 1 Desaceleración : 1 Tappet Histéresis : 1 Insertar un elemento de caja y asignar la variable Tappet lo. El elemento de caja comprueba el ajuste del interruptor de leva. Configure las entradas de la siguiente manera: Tappets : CamIn.Tappets iID : 1 bInitValue FALSE bSetInitValueAtReset : FALSE El empujador se define como un empujador inversor. Por esta razón, su valor se cambia cada 10 segundos. El proyecto de muestra proporciona una visualización para comprobar los bloques de función individuales y la posición de los ejes. Agregue la llamada del MOTION_PRG programa a la tarea Tarea principal . Descargue el proyecto al controlador e inícielo. Para más información, ver: MC_Power MC_CamTableSelect MC_CamIn SMC_GetTappetValue MC_Velocidad de movimiento " }, 
{ "title" : "Crear cámaras mediante programación ", 
"url" : "_sm_basic_example_cam_programmatic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Crear cámaras mediante programación ", 
"snippet" : "El BasicMotion_CreateCamTableOnline.project El proyecto de muestra se encuentra en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . El ejemplo muestra cómo puede usar el código IEC para crear y usar una cámara. Aquí se tratan los siguientes puntos Una cámara creada en el...", 
"body" : "El BasicMotion_CreateCamTableOnline.project El proyecto de muestra se encuentra en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . El ejemplo muestra cómo puede usar el código IEC para crear y usar una cámara. Aquí se tratan los siguientes puntos Una cámara creada en el editor de cámaras se vuelve a crear con código IEC. En un caso, el disco de leva se genera en la tarea de bus. En el otro caso, el disco de leva se genera en una tarea separada. Luego, las tres levas funcionan con el mismo eje maestro y diferentes ejes esclavos. El movimiento de las tres esclavas es idéntico. La leva generada en el código IEC se muestra en la visualización. Para obtener más información sobre la creación programática de cámaras, consulte: Crear cámaras mediante programación" }, 
{ "title" : "Estructura de la aplicación ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Crear cámaras mediante programación \/ Estructura de la aplicación ", 
"snippet" : "La aplicación consta de los siguientes componentes: CamOffline La cámara creada en el editor de cámaras que debe volver a crearse con el código IEC. PLC_PRG El programa consiste en una máquina de estados simple y, lógicamente, en tres partes. En la primera y la segunda parte, se crea una leva en cód...", 
"body" : "La aplicación consta de los siguientes componentes: CamOffline La cámara creada en el editor de cámaras que debe volver a crearse con el código IEC. PLC_PRG El programa consiste en una máquina de estados simple y, lógicamente, en tres partes. En la primera y la segunda parte, se crea una leva en código IEC. En la tercera parte, se ejecutan las cámaras creadas anteriormente y una cámara idéntica creada sin conexión Parte 1: en el primer estado STATE_CREATE_ONLINE_TABLE , se crea una leva en código IEC. El SMCB.CamBuilder bloque de funciones del SM3_CamBuilder La biblioteca se utiliza para este propósito. Se agregan tres segmentos: un elemento Poly5 seguido de un elemento Line y otro elemento Poly5. El constructor genera un camonline cámara de esto. A partir de este momento, la leva se crea en código IEC y se puede utilizar de la misma manera que la Cámara sin conexión cámara creada sin conexión en el editor de cámara. Parte 2: En el STATE_INIT_ONLINE_TABLE_MULTITASK , STATE_START_CREATE_ONLINE_TABLE_MULTITASK , y STATE_READ_ONLINE_TABLE_MULTITASK indica que la creación de la cámara se inicia en otra tarea y, a continuación, se lee. Parte 3: En el STATE_POWER_DRIVES estado, se inicializan los ejes virtuales del eje maestro y de los tres ejes esclavos. A continuación, las levas se seleccionan mediante MC_CamTableSelect en el STATE_SELECT_TABLE estado y ejecutado en la final STATE_MOVEMENT estado. El eje maestro se mueve usando MC_MoveVelocity y se usa como maestro para las tres levas. MultitaskCamBuilder Un programa que genera una cámara como se describe en la parte 1 de PLC_PRG . La única diferencia aquí es que se utiliza una variante de la cámara multitarea y segura para varios núcleos GVL Aquí se instancia la variante multitarea\/multicore segura de la cámara. Visualization La visualización contiene el SMC_Visu_CamDisplayer elemento para mostrar cámaras. La cámara generada en la parte 1 de PLC_PRG se muestra. CamDisplayerSettings Elementos adicionales para mostrar la cámara en Visualization Trace Puede usar la traza para rastrear el movimiento de los ejes virtuales. Se registra la posición actual del maestro, así como la posición, la velocidad y la aceleración de los tres ejes secundarios. " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Crear cámaras mediante programación \/ Puesta en servicio ", 
"snippet" : "Compile la aplicación y descárguela a un controlador. Inicie el rastreo y la aplicación. Observe el rastro de muestreo. Visualización de la cámara generada en la visualización...", 
"body" : "Compile la aplicación y descárguela a un controlador. Inicie el rastreo y la aplicación. Observe el rastro de muestreo. Visualización de la cámara generada en la visualización " }, 
{ "title" : "Uso de MC_DigitalCamSwitch_HighPrecision ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Uso de MC_DigitalCamSwitch_HighPrecision ", 
"snippet" : "El ejemplo BasicMotion_DigitalCamSwitch_HighPrecision.project se encuentra en el directorio de instalación CODESYS debajo ..\\CODESYS SoftMotion\\Examples . En este ejemplo se muestra cómo utilizar las salidas de SMC_DigitalCamSwitch_HighPrecision para controlar salidas digitales con alta resolución t...", 
"body" : "El ejemplo BasicMotion_DigitalCamSwitch_HighPrecision.project se encuentra en el directorio de instalación CODESYS debajo ..\\CODESYS SoftMotion\\Examples . En este ejemplo se muestra cómo utilizar las salidas de SMC_DigitalCamSwitch_HighPrecision para controlar salidas digitales con alta resolución temporal. Los terminales EL2258 y EL2252 de Beckhoff Las descripciones de los dispositivos de Beckhoff no se incluyen en el ejemplo. Puede descargarlas directamente del proveedor e instalarlas en el repositorio de dispositivos. Para ejecutar el ejemplo, necesita un acoplador de bus EK1100, un terminal EL2258 y un terminal EL2252 Este ejemplo se desarrolló y probó de acuerdo con la revisión 0017 de EL2258 y la revisión 0020 de EL2252. Solo sirve como ejemplo. No garantizamos la exactitud. El código fuente debe probarse antes de usarlo. Si es necesario, debe modificarse para adaptarlo a otras revisiones de los terminales. " }, 
{ "title" : "Estructura de la solicitud ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856510750361", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Uso de MC_DigitalCamSwitch_HighPrecision \/ Estructura de la solicitud ", 
"snippet" : "La aplicación consiste en Main programa, el DigitalCamSwitch_EL2258 y DigitalCamSwitch_EL2252 bloques de funciones y un acoplador de bus EK1100 con los terminales de salida EL2258 y EL2252. El DigitalCamSwitch_EL2258 y DigitalCamSwitch_EL2252 bloques de funciones son las partes esenciales del ejempl...", 
"body" : "La aplicación consiste en Main programa, el DigitalCamSwitch_EL2258 y DigitalCamSwitch_EL2252 bloques de funciones y un acoplador de bus EK1100 con los terminales de salida EL2258 y EL2252. El DigitalCamSwitch_EL2258 y DigitalCamSwitch_EL2252 bloques de funciones son las partes esenciales del ejemplo. Muestran cómo usar el Events salida de SMC_DigitalCamSwitch_HighPrecision para programar salidas digitales. Los bloques de funciones deben entenderse como ejemplos que pueden adaptarse a otro hardware. " }, 
{ "title" : "DigitalCamSwitch_EL2258 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856513787236", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Uso de MC_DigitalCamSwitch_HighPrecision \/ Estructura de la solicitud \/ DigitalCamSwitch_EL2258 ", 
"snippet" : "El bloque de funciones funciona de la siguiente manera: El bloque de función se inicializa en un borde ascendente en el Enable entrada. En el STATE_INIT_0 y STATE_INIT_1 estados, el OutputBufferReset se escriben las señales del terminal EL2258 y el aLastEventIds la matriz está inicializada. El ID de...", 
"body" : "El bloque de funciones funciona de la siguiente manera: El bloque de función se inicializa en un borde ascendente en el Enable entrada. En el STATE_INIT_0 y STATE_INIT_1 estados, el OutputBufferReset se escriben las señales del terminal EL2258 y el aLastEventIds la matriz está inicializada. El ID del último evento procesado para cada pista se guarda en esta matriz. Esto evita que un evento se transfiera al terminal varias veces. Una vez inicializado ( STATE_ACTIVE ), todas las pistas se procesan sucesivamente y se ejecuta la siguiente lógica para cada pista: Compruebe si el terminal EL2258 ya ha aceptado los últimos eventos ordenados ( ChannelsIn[channel].OutputOrderFeedback = ChannelsOut[channel].OutputOrderCounter ). Recorre todos los eventos de la pista. Solo aquellos eventos cuyo ToggleEventId es mayor que la última ID procesada y se consideran más adelante. (Consulta EventId_GreaterThan(event^.ToggleEventId, aLastEventIds[channel]) ) Consulta la sección: «Nota sobre el orden de los eventos». Convierte el Duration del evento en una marca de tiempo de EtherCAT y la correspondiente escritura del ChannelsOut[channel].OutputEventState y ChannelsOut[channel].OutputEventTime salidas. Anule el procesamiento después de un máximo de 5 eventos. Notifique a la terminal que existen nuevos eventos si se ha encontrado al menos un evento ( ChannelsOut[channel].OutputOrderCounter := ChannelsOut[channel].OutputOrderCounter + 1 ). Nota sobre el orden de los eventos Los eventos son devueltos por el SMC_DigitalCamSwitch_HighPrecision bloque de función para cada pista de una matriz. SwitchNumber y un ToggleEventId se devuelven para cada evento. ToggleEventId es único y ascendente para cada pista. Para obtener más información, consulte: SMC_CAMSWITCH_TOGGLE_EVENT . En el ejemplo, el aLastEventIds[trackNo] una matriz almacena para cada pista que ToggleEventId transfirió por última vez al terminal en una llamada de bloqueo de funciones anterior. Porque el ToggleEventIds están en orden ascendente, la próxima llamada sabrá exactamente qué eventos aún deben transferirse. Aún deben tenerse en cuenta dos detalles: Porque no se sabe en qué ToggleEventId los eventos comienzan, a valid la bandera se guarda en EventId tipo de datos además del ID. Para el EventId_GreaterThan comparación, esto valid la bandera se tiene en cuenta en consecuencia. El ToggleEventIds tienen el tipo de datos de 32 bits UDINT y, por lo tanto, puede, en principio, desbordarse con un tiempo de ejecución largo o una frecuencia de conmutación alta, respectivamente. A continuación, el valor pasa de 2^32-1 a 0. La función de comparación EventId_GreaterThan también tiene en cuenta los desbordamientos de 32 bits. Mapeo PDO EL2258 El ChannelsOut y ChannelsIn salidas del DigitalCamSwitch_EL2258 bloques de funciones están conectados a los canales de E\/S respectivos del terminal EL2258. La siguiente imagen muestra las asignaciones del canal 1. El canal 2 es similar; solo cuando se accede ChannelsOut y ChannelsIn el índice es 2, no 1. " }, 
{ "title" : "DigitalCamSwitch_EL2252 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434780928", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Uso de MC_DigitalCamSwitch_HighPrecision \/ Estructura de la solicitud \/ DigitalCamSwitch_EL2252 ", 
"snippet" : "El principio básico es idéntico al DigitalCamSwitch_EL2258 . La diferencia está en la forma en que se escriben las señales porque el terminal EL2252 solo puede programar un evento activo En primer lugar, el bloque de función se inicializa en STATE_INIT . Entonces STATE_CHECK_FOR_EVENT comprueba si l...", 
"body" : "El principio básico es idéntico al DigitalCamSwitch_EL2258 . La diferencia está en la forma en que se escriben las señales porque el terminal EL2252 solo puede programar un evento activo En primer lugar, el bloque de función se inicializa en STATE_INIT . Entonces STATE_CHECK_FOR_EVENT comprueba si los eventos del SMC_DigitalCamSwitch_HighPrecision el bloque de funciones está pendiente. Si hay un evento disponible, debe programarse en dos ciclos: Las salidas y la marca de tiempo de EtherCAT se escriben en el primer ciclo. El Activate la salida se establece en 0. En el segundo ciclo, el Activate la salida está configurada en 3 pulgadas STATE_ACTIVATE_EVENT_IN_EL2252 . Esto activa el evento en la terminal. En STATE_WAIT_UNTIL_THE_INPUTS_MATCH_THE_OUTPUTS , el sistema espera entonces hasta que se haya ejecutado el evento. Las señales del Feedback para ello se utiliza la entrada del terminal. Mapeo PDO EL2252 " }, 
{ "title" : "Main ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434889277", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Uso de MC_DigitalCamSwitch_HighPrecision \/ Estructura de la solicitud \/ Main ", 
"snippet" : "En el programa principal, se configuran cuatro conmutadores (dos en cada pista). Las pistas también tienen diferentes compensaciones de encendido\/apagado OnComp , OffComp ): El programa incluye las llamadas a bloques de funciones necesarias para activar una previsión para el eje y moverlo constantem...", 
"body" : "En el programa principal, se configuran cuatro conmutadores (dos en cada pista). Las pistas también tienen diferentes compensaciones de encendido\/apagado OnComp , OffComp ): El programa incluye las llamadas a bloques de funciones necesarias para activar una previsión para el eje y moverlo constantemente a 180°\/s (*), así como para SMC_DigitalCamSwitch_HighPrecision , DigitalCamSwitch_EL2258 , y DigitalCamSwitch_EL2252 . Antes de iniciar el movimiento, el bus de campo debe estar completamente encendido. De lo contrario, los eventos no se pueden transmitir al terminal (*) Se eligió el movimiento constante para mantener el ejemplo simple y claro. Sin embargo, el SMC_DigitalCamSwitch_HighPrecision el bloque de funciones funciona con todo tipo de movimientos. Por ejemplo, también proporciona marcas de tiempo exactas durante una fase de aceleración o con " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856511865803", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Uso de MC_DigitalCamSwitch_HighPrecision \/ Puesta en servicio ", 
"snippet" : "Cree la aplicación y descárguela en un controlador. Inicie la aplicación....", 
"body" : "Cree la aplicación y descárguela en un controlador. Inicie la aplicación. " }, 
{ "title" : "Exportación e importación de cámaras ", 
"url" : "_sm_example_cams_export_import.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Exportación e importación de cámaras ", 
"snippet" : "El BasicMotion_CamExportAndImport.project el proyecto de ejemplo se encuentra en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . El ejemplo muestra cómo exportar e importar una cámara....", 
"body" : "El BasicMotion_CamExportAndImport.project el proyecto de ejemplo se encuentra en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . El ejemplo muestra cómo exportar e importar una cámara. " }, 
{ "title" : "Estructura de la solicitud ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm235085906313629", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Exportación e importación de cámaras \/ Estructura de la solicitud ", 
"snippet" : "La aplicación consiste en PLC_PRG programa y un CamEditor cámara. PLC_PRG El programa consiste en una máquina de estados simple donde se crea una leva en código IEC en el STATE_CREATE_CAM estado. Para obtener más información, consulte lo siguiente: Crear cámaras mediante programación. A continuación...", 
"body" : "La aplicación consiste en PLC_PRG programa y un CamEditor cámara. PLC_PRG El programa consiste en una máquina de estados simple donde se crea una leva en código IEC en el STATE_CREATE_CAM estado. Para obtener más información, consulte lo siguiente: Crear cámaras mediante programación. A continuación, esta cámara se exporta en STATE_EXPORT_CAM estado usando el SMC_WriteCam bloque de función y, a continuación, importado en STATE_START_IMPORT_CAM estado usando el SMC_ReadCam bloque de funciones. CamEditor La cámara no tiene ningún significado al principio porque no se usa en la aplicación. La exportada proviene de PLC_PRG se puede importar al editor de cámaras. Este es un paso manual que se describe en la siguiente sección. " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm23508590648994", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Cámaras \/ Exportación e importación de cámaras \/ Puesta en servicio ", 
"snippet" : "Cree la aplicación y descárguela en un controlador. Inicie la aplicación. El PLC_PRG el programa genera la cámara y la exporta al PlcLogic directorio del controlador. También puede mostrar y editar la cámara exportada en el editor de cámaras. Para ello, abre el CamEditor cámara e importe la cámara u...", 
"body" : "Cree la aplicación y descárguela en un controlador. Inicie la aplicación. El PLC_PRG el programa genera la cámara y la exporta al PlcLogic directorio del controlador. También puede mostrar y editar la cámara exportada en el editor de cámaras. Para ello, abre el CamEditor cámara e importe la cámara usando el Leer archivo de Cam Online comando. Una vez realizados los cambios, puede exportar la leva modificada mediante el Escribir archivo de Cam Online comando. Esta cámara se puede leer en el código IEC con el SMC_ReadCAM bloque de funciones y utilizado en la aplicación. " }, 
{ "title" : "Anulación de velocidad para ejes SoftMotion ", 
"url" : "_sm_example_override.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Anulación de velocidad para ejes SoftMotion ", 
"snippet" : "El BasicMotion_Override.project El proyecto de ejemplo descrito aquí se encuentra en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo definir una anulación de velocidad para un eje SoftMotion. Para obtener más información sobre la anulación, con...", 
"body" : "El BasicMotion_Override.project El proyecto de ejemplo descrito aquí se encuentra en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo definir una anulación de velocidad para un eje SoftMotion. Para obtener más información sobre la anulación, consulte: Adaptación dinámica con MC_SetOverride" }, 
{ "title" : "Estructura de la aplicación ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4552520462032034028650702932", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Anulación de velocidad para ejes SoftMotion \/ Estructura de la aplicación ", 
"snippet" : "La aplicación consiste en un PLC_PRG programa y un Trace . PLC_PRG El programa consta de una máquina de estados simple. en el primer estado STATE_POWER , el eje virtual Drive se inicializa. en el segundo estado STATE_COMMAND_MOVEMENT , se ajusta una corrección de velocidad de 0,5 para que los movimi...", 
"body" : "La aplicación consiste en un PLC_PRG programa y un Trace . PLC_PRG El programa consta de una máquina de estados simple. en el primer estado STATE_POWER , el eje virtual Drive se inicializa. en el segundo estado STATE_COMMAND_MOVEMENT , se ajusta una corrección de velocidad de 0,5 para que los movimientos del eje se ejecuten sólo a la mitad de la velocidad. Luego se ejecuta un movimiento usando MC_MoveAbsolute a la posición 10. En el bloque de funciones se especifica una velocidad máxima de 20 unidades\/s. Debido a la corrección de velocidad establecida en el eje virtual, el movimiento se ejecuta a una velocidad máxima de 10 unidades\/s. Tan pronto como se completa la mitad del movimiento en la posición 5, la anulación de velocidad se reduce a 0,25 en el STATE_CHANGE_OVERRIDE estado. El eje desacelera a 5 unidades\/s y realiza el resto del movimiento a esta velocidad. Los factores de anulación activos (velocidad, aceleración y sacudida) del eje virtual también se leen en el programa. El SMC_GetOverride Para ello se utiliza el bloque de funciones. Rastro La traza se puede utilizar para seguir el movimiento del eje virtual. Se registran la posición actual especificada, la velocidad y la aceleración del eje y la corrección de velocidad activa. " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4563439233780834028650966211", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Anulación de velocidad para ejes SoftMotion \/ Puesta en servicio ", 
"snippet" : "Compile la aplicación y descárguela a un controlador. Inicie el rastreo y la aplicación. En el seguimiento, puede seguir el movimiento del eje virtual....", 
"body" : "Compile la aplicación y descárguela a un controlador. Inicie el rastreo y la aplicación. En el seguimiento, puede seguir el movimiento del eje virtual. " }, 
{ "title" : "Rampa basada en la distancia ", 
"url" : "_sm_axis_based_ramp_in.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Rampa basada en la distancia ", 
"snippet" : "El BasicMotion_CamIn_StartModes.project El proyecto de ejemplo descrito aquí se encuentra en el directorio de instalación de CODESYS bajo la ..\\CODESYS SoftMotion\\Examples directorio. Este ejemplo muestra cómo utilizar el StartMode entrada de la MC_CamIn bloque de funciones. Esta entrada se utiliza ...", 
"body" : "El BasicMotion_CamIn_StartModes.project El proyecto de ejemplo descrito aquí se encuentra en el directorio de instalación de CODESYS bajo la ..\\CODESYS SoftMotion\\Examples directorio. Este ejemplo muestra cómo utilizar el StartMode entrada de la MC_CamIn bloque de funciones. Esta entrada se utiliza para configurar cómo se sincroniza el eje esclavo con el eje maestro cuando MC_CamIn Está empezado. Básicamente, hay tres formas posibles: El eje esclavo sigue inmediatamente la trayectoria especificada por la leva y el eje maestro. Dependiendo del estado inicial del eje esclavo, esto puede provocar un salto de posición, velocidad y\/o aceleración del eje esclavo. StartMode : absolute , relative El eje esclavo se sincroniza lo más rápido posible manteniendo los límites predefinidos de velocidad, aceleración, desaceleración y sacudidas. StartMode : ramp_in , ramp_in_pos , ramp_in_neg Se especifica una posición maestra en la leva donde el eje esclavo debe seguir la trayectoria especificada por la leva y el eje maestro. La sincronización se realiza a una distancia configurable del eje maestro. StartMode : ramp_in_dist Para obtener más información sobre el bloque de funciones MC_CamIn, consulte: MC_CamIn (FB) " }, 
{ "title" : "Estructura de la aplicación ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4561064201451234280796827706", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Rampa basada en la distancia \/ Estructura de la aplicación ", 
"snippet" : "La aplicación consiste en un PLC_PRG programa y un Trace. Además, existen cuatro ejes virtuales: el eje maestro Master y las tres hachas esclavas SlaveAbsolute , SlaveRampIn , y SlaveRampInDist . Y ahí está la cámara Cam . En el PLC_PRG programa, tres instancias de MC_CamIn se ejecutan con el StartM...", 
"body" : "La aplicación consiste en un PLC_PRG programa y un Trace. Además, existen cuatro ejes virtuales: el eje maestro Master y las tres hachas esclavas SlaveAbsolute , SlaveRampIn , y SlaveRampInDist . Y ahí está la cámara Cam . En el PLC_PRG programa, tres instancias de MC_CamIn se ejecutan con el StartMode input establecer de manera diferente: ciSlaveAbsolute con StartMode = absolute ciSlaveRampIn con StartMode = ramp_in ciSlaveRampInDist con StartMode = ramp_in_dist Las instancias del bloque de funciones controlan los ejes virtuales correspondientes. SlaveAbsolute , SlaveRampIn , y SlaveRampInDist . El eje maestro se mueve a una velocidad constante usando un MC_MoveVelocity instancia. Las trayectorias de las tres hachas esclavas y el Active y InSync salidas de la instancias   MC_CamIn   se pueden rastrear en el traza. Todo MC_CamIn Las instancias se inician cuando el eje maestro excede la posición 40: El SlaveAbsolute El eje salta inmediatamente a los valores establecidos definidos por la leva. El correspondiente MC_CamIn la instancia es inmediatamente Active y InSync . El eje   SlaveRampIn   se sincroniza manteniendo los límites dinámicos ordenados. El correspondiente MC_CamIn la instancia es inmediatamente Active . Desde la posición maestra ~114 , el eje esclavo sigue la trayectoria especificada por la leva y el eje maestro y el MC_CamIn informes de instancia InSync . El SlaveRampInDist El eje primero permanece estacionario hasta que el eje maestro se haya acercado al MasterSyncPosition de 120 hasta el MasterStartDistance de 60 configurados en el MC_CamIn instance . Entonces comienza la sincronización y el MC_CamIn informes de instancia Active . Cuando el eje maestro alcanza el MasterSyncPosition de 120 , el eje esclavo sigue la trayectoria especificada por la leva y el eje maestro y el MC_CamIn informes de instancia InSync . " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4602846053456034280814845985", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Ejemplos \/ Rampa basada en la distancia \/ Puesta en servicio ", 
"snippet" : "Compile la aplicación y descárguela a un controlador. Inicie el rastreo y la aplicación. En el trazado se puede seguir el movimiento de los ejes virtuales....", 
"body" : "Compile la aplicación y descárguela a un controlador. Inicie el rastreo y la aplicación. En el trazado se puede seguir el movimiento de los ejes virtuales. " }, 
{ "title" : "Interfaz de usuario ", 
"url" : "_sm_basic_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaz de usuario ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Leva ", 
"url" : "_sm_basic_user_interface_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaz de usuario \/ Leva ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Diálogo: Propiedades – Cámara ", 
"url" : "_sm_dlg_properties_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaz de usuario \/ Leva \/ Diálogo: Propiedades – Cámara ", 
"snippet" : "Función : Utilice este diálogo para definir las variables globales de la leva. Dimensiones Posición inicial \/ final del maestro Las posiciones inicial y final del maestro definen el rango de los valores del maestro y, por lo tanto, la escala del eje horizontal de la leva. Los ajustes predeterminados...", 
"body" : "Función : Utilice este diálogo para definir las variables globales de la leva. Dimensiones Posición inicial \/ final del maestro Las posiciones inicial y final del maestro definen el rango de los valores del maestro y, por lo tanto, la escala del eje horizontal de la leva. Los ajustes predeterminados se dan en grados angulares con 0 y 360 como valores límite. Posición inicial \/ final del esclavo Las posiciones esclavas asociadas están determinadas por el tipo de gráfico que se define para la leva. Sin embargo, el segmento representado por las curvas (esta es también la escala del eje vertical) se puede definir por las posiciones inicial y final del esclavo que se dan aquí. Período Estas configuraciones afectan el trabajo en el editor de levas y la tabla de levas. Dependiendo de estos parámetros, el punto inicial del esclavo se ajusta automáticamente cuando se cambia el punto final, y al revés. Este ajuste optimiza la transición del período para que sea lo más suave y sin sacudidas posible. Transición suave : Los valores de posición, velocidad y aceleración se ajustan automáticamente. Período esclavo Indica cuando el período esclavo se repite mecánicamente. Entonces, la posición del esclavo al comienzo y al final del período maestro puede desviarse en un múltiplo entero de este valor. Este valor es efectivo solo si el Transición suave está seleccionada la casilla de verificación. Requisitos de continuidad La activación de estas opciones para la continuidad de la curva no tiene ningún efecto a la hora de editar la leva. Sin embargo, solicita una verificación de continuidad, que informa cualquier infracción a la vista de mensajes ( LEVA categoría). No es posible editar saltos en la curva de posición. La configuración predeterminada también requiere la continuidad de la velocidad y la aceleración. Puede borrar estas opciones, por ejemplo, en el caso especial de una curva que consta únicamente de segmentos lineales. Sin embargo, esto puede provocar roturas en la curva de posiciones. Por defecto, el tirón (cuarta derivada) no se prueba para saltos. Posición : La curva se comprueba para ver si hay saltos. Velocidad Aceleración Imbécil Formato de compilación Al compilar, MC_CAM_REF generan variables de estructura. Una leva se describe de acuerdo con las siguientes opciones: polinomio (XYVA) Descripción polinomial de los puntos individuales, que consta de la posición del maestro, la posición del esclavo, la velocidad del esclavo y la aceleración del esclavo. matriz de puntos unidimensionales Tabla 1D de posiciones esclavas matriz de puntos bidimensional Tabla 2D de posiciones compuestas maestro \/ esclavo Elementos Número de elementos para las matrices de puntos de 1 o 2 dimensiones. Esta matriz ya se creó en SM3_Basic para los casos estándar 128 y 256 . Si escribes otro valor, tendrás que crear la estructura en tu aplicación. Para ello, consulta el siguiente ejemplo. Segmentos Formato de compilación estándar; admite todos los tipos de segmentos Ejemplo de una matriz con 720 elementos TYPE SMC_CAMTable_LREAL_720_2 :\nSTRUCT\n Table: ARRAY[0..719] OF ARRAY[0..1] OF LREAL;\n fEditorMasterMin, fEditorMasterMax: REAL;\n fEditorSlaveMin, fEditorSlaveMax: REAL;\n fTableMasterMin, fTableMasterMax: REAL;\n fTableSlaveMin, fTableSlaveMax: REAL;\nEND_STRUCT\nEND_TYPE Para más información, ver: Cómo crear una cámara" }, 
{ "title" : "Comando: Mostrar código generado ", 
"url" : "_sm_cmd_cam_display_generated_code.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaz de usuario \/ Leva \/ Comando: Mostrar código generado ", 
"snippet" : "Mostrar código generado Función : El comando abre el Código generado diálogo donde se muestra el código de inicialización IEC de la leva representada. Llama : Leva menú Requisito : El editor de levas está abierto y muestra una leva. No se muestra ningún código generado para Segmentos formato de comp...", 
"body" : "Mostrar código generado Función : El comando abre el Código generado diálogo donde se muestra el código de inicialización IEC de la leva representada. Llama : Leva menú Requisito : El editor de levas está abierto y muestra una leva. No se muestra ningún código generado para Segmentos formato de compilación. El código generado ya no es necesario porque la API de CamBuilder se puede usar para generar cámaras de forma programática de una manera mejor Código generado Diálogo Ejemplo: código de inicialización IEC {attribute 'linkalways'}\n\nVAR_GLOBAL\nCam_A: ARRAY[0..3] OF SMC_CAMXYVA := [\n (dX := 0, dY := 0, dV := 0, dA := 0),\n (dX := 120, dY := 120, dV := 1, dA := 0),\n (dX := 240, dY := 240, dV := 1, dA := 0),\n (dX := 360, dY := 360, dV := 0, dA := 0)];\nCam: MC_CAM_REF := (nElements := 4, byType := 3, xStart := 0, xEnd := 360, nTappets := 0, strCAMName := 'Cam', pce := ADR(Cam_A), xPartofLM := TRUE);\nEND_VAR " }, 
{ "title" : "Leer datos de levas de la tabla ASCII Mando ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaz de usuario \/ Leva \/ Leer datos de levas de la tabla ASCII Mando ", 
"snippet" : "Leer datos de levas de la tabla ASCII Función : El comando lee un ASCII expediente. Llama : Leva menú Requisito : El editor de levas está abierto. Cuando se leen, los datos del archivo se interpretan como los valores X \/ Y de una leva. los Número de puntos Se abre el cuadro de diálogo para que pueda...", 
"body" : "Leer datos de levas de la tabla ASCII Función : El comando lee un ASCII expediente. Llama : Leva menú Requisito : El editor de levas está abierto. Cuando se leen, los datos del archivo se interpretan como los valores X \/ Y de una leva. los Número de puntos Se abre el cuadro de diálogo para que pueda reducir el número de puntos de interpolación. Luego, los puntos determinados se interpolan a una leva y se muestran en el editor. los Escribir datos de levas en una tabla ASCII comandos crea un apropiado TXT expediente. " }, 
{ "title" : "Número de puntos Diálogo ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html#UUID-dc22ffbd-b76b-ca74-a92b-235fbf0143cb_id_d53fe1240e8dd1c0a8640e0032565c_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaz de usuario \/ Leva \/ Leer datos de levas de la tabla ASCII Mando \/ Número de puntos Diálogo ", 
"snippet" : "Número de puntos Número de puntos utilizados para la interpolación. Preestablecido: Según el número de valores X \/ Y que se almacenan en el archivo leído. Ejemplo: 256 Puede disminuir el valor preestablecido para determinar la leva con menos puntos de interpolación. Al determinar los puntos de inter...", 
"body" : "Número de puntos Número de puntos utilizados para la interpolación. Preestablecido: Según el número de valores X \/ Y que se almacenan en el archivo leído. Ejemplo: 256 Puede disminuir el valor preestablecido para determinar la leva con menos puntos de interpolación. Al determinar los puntos de interpolación, sus valores X se distribuyen de manera equidistante. Como la leva se interpola utilizando un polinomio de quinto grado, un mayor número de puntos de interpolación puede causar oscilaciones. " }, 
{ "title" : "Comando: Escribir datos de cámara en tabla ASCII ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaz de usuario \/ Leva \/ Comando: Escribir datos de cámara en tabla ASCII ", 
"snippet" : "Escribir datos de levas en una tabla ASCII Función : El comando crea un ASCII expediente ( TXT extensión) en el sistema de desarrollo. En este archivo se guarda un número específico de valores X \/ Y de la leva activa. Primero se abre un cuadro de diálogo predeterminado y luego Número de puntos diálo...", 
"body" : "Escribir datos de levas en una tabla ASCII Función : El comando crea un ASCII expediente ( TXT extensión) en el sistema de desarrollo. En este archivo se guarda un número específico de valores X \/ Y de la leva activa. Primero se abre un cuadro de diálogo predeterminado y luego Número de puntos diálogo. Llama : Leva menú Requisito : El editor de levas está abierto y muestra una leva. " }, 
{ "title" : "Número de puntos Diálogo ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html#UUID-b84e5af8-679e-916c-e8a6-2358c4cccb5c_id_c2bdaa8241199e2c0a8640e018c7af7_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaz de usuario \/ Leva \/ Comando: Escribir datos de cámara en tabla ASCII \/ Número de puntos Diálogo ", 
"snippet" : "La tabla ASCII no contiene información sobre levas. Número de puntos Número de valores X \/ Y que se guardan en el archivo y se representan en la forma de la curva. Para ello, la curva X se divide equidistantemente y se determina el valor Y respectivo....", 
"body" : "La tabla ASCII no contiene información sobre levas. Número de puntos Número de valores X \/ Y que se guardan en el archivo y se representan en la forma de la curva. Para ello, la curva X se divide equidistantemente y se determina el valor Y respectivo. " }, 
{ "title" : "Comando: Leer archivo en línea de la cámara ", 
"url" : "_sm_cmd_cam_read_online_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaz de usuario \/ Leva \/ Comando: Leer archivo en línea de la cámara ", 
"snippet" : "Leer archivo de Cam Online Función : El comando lee un archivo externo con datos de cámara. La extensión del archivo es CAM . La leva se muestra en el editor de levas. Llama : Leva menú Requisito : El editor de levas está abierto. los Escribir archivo de Cam Online comando crea un archivo apropiado ...", 
"body" : "Leer archivo de Cam Online Función : El comando lee un archivo externo con datos de cámara. La extensión del archivo es CAM . La leva se muestra en el editor de levas. Llama : Leva menú Requisito : El editor de levas está abierto. los Escribir archivo de Cam Online comando crea un archivo apropiado en CAM formato. " }, 
{ "title" : "Comando: Escribir archivo en línea de cámara ", 
"url" : "_sm_cmd_cam_write_online_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaz de usuario \/ Leva \/ Comando: Escribir archivo en línea de cámara ", 
"snippet" : "Escribir archivo de Cam Online Función : El comando crea un archivo ( CAM extensión). El archivo contiene los datos de la leva que está activa en el editor. Llama : Leva menú Requisito : El editor de levas está abierto y muestra una leva. Los datos de la leva se componen de una descripción de la lev...", 
"body" : "Escribir archivo de Cam Online Función : El comando crea un archivo ( CAM extensión). El archivo contiene los datos de la leva que está activa en el editor. Llama : Leva menú Requisito : El editor de levas está abierto y muestra una leva. Los datos de la leva se componen de una descripción de la leva y las posiciones y tipos de levas. A CAM El archivo se puede leer al editor mediante el Leer archivo de cámara en línea mando. Además, una instancia del SMC_ReadCAM El bloque de funciones puede leer el archivo para cargar una tabla de leva en la aplicación en tiempo de ejecución. Para más información, ver: Estructuras de datos de levas." }, 
{ "title" : "CODESYS SoftMotion CNC ", 
"url" : "_sm_f_cnc.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Editor ", 
"url" : "_sm_f_cnc_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Descripción general ", 
"url" : "_sm_overview_cnc_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Descripción general ", 
"snippet" : "En el editor CNC se implementan movimientos multidimensionales complejos en el editor de tablas o de texto según el lenguaje CNC DIN 66025. Además, el editor ofrece lo siguiente: Editor gráfico para mostrar el camino. Caja de herramientas para el editor gráfico. Ver con propiedades del elemento de r...", 
"body" : "En el editor CNC se implementan movimientos multidimensionales complejos en el editor de tablas o de texto según el lenguaje CNC DIN 66025. Además, el editor ofrece lo siguiente: Editor gráfico para mostrar el camino. Caja de herramientas para el editor gráfico. Ver con propiedades del elemento de ruta seleccionado. " }, 
{ "title" : "Fundamentos del editor CNC ", 
"url" : "_sm_cnc_edt_basics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Fundamentos del editor CNC ", 
"snippet" : "Con DIN 66025, puede crear caminos de hasta 9 dimensiones. Tres de estas dimensiones no se interpolan linealmente. En X\/Y\/Z, puede programar líneas, arcos, elipses, parábolas y splines. Se proporcionan otros ocho ejes adicionales. De estos, cinco están interpolados linealmente (P\/Q\/U\/V\/W) y tres con...", 
"body" : "Con DIN 66025, puede crear caminos de hasta 9 dimensiones. Tres de estas dimensiones no se interpolan linealmente. En X\/Y\/Z, puede programar líneas, arcos, elipses, parábolas y splines. Se proporcionan otros ocho ejes adicionales. De estos, cinco están interpolados linealmente (P\/Q\/U\/V\/W) y tres con un polinomio de tercer grado (A\/B\/C). Para cada bloque de movimiento en el programa CNC, el interpolador calcula la trayectoria transversal. Al mismo tiempo, el interpolador calcula la forma de la trayectoria, la velocidad, la aceleración y la sacudida de acuerdo con la interpolación especificada. Para cada ruta programada, CODESYS crea una estructura de datos global automáticamente con los datos del CNC que se puede utilizar en un programa IEC. Hay diferentes opciones para este propósito: SMC_CNC_REF : El programa CNC se guarda como una matriz de palabras de código G que se procesan en tiempo de ejecución de la aplicación por medio de SMC_NCInterpreter . El resultado es la ruta CNC descrita como una secuencia de objetos de estructura GEOINFO. Por medio de módulos de preprocesamiento de ruta de la biblioteca SM3_CNC (ejemplo: corrección del radio de la herramienta), estos objetos se pueden editar, interpolar, transformar y transferir desde la interfaz del controlador al hardware para la comunicación. SMC_OUTQUEUE : El programa CNC se escribe en una estructura de datos como una lista de objetos de estructura GEOINFO con el nombre SMC_OUTQUEUE , y luego se puede ingresar directamente en el interpolador. En consecuencia, a diferencia de SMC_CNC_REF , el bloque de función de intérprete y los bloques de función de preprocesamiento de ruta no tienen que llamarse. Sin embargo, el programa no se puede cambiar en tiempo de ejecución y no se pueden usar variables en código G en este modo. FILE : Luego, el programa CNC se guarda como un archivo ASCII en el sistema de archivos del controlador y se lee e implementa paso a paso. Este método es especialmente apropiado para programas grandes que no se pueden almacenar por completo en la memoria. También es apropiado para programas generados por el usuario después de compilar la aplicación del controlador. " }, 
{ "title" : "Estructura del editor CNC ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_43423fe2e9a24fa0c0a864632228473f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Fundamentos del editor CNC \/ Estructura del editor CNC ", 
"snippet" : "El editor CNC consta de los siguientes componentes: Editor principal: El editor de texto muestra el programa DIN 66025, o el editor tabular muestra la ruta del CNC. Editor gráfico: Aquí se muestra la vista gráfica de la ruta. Propiedades vista de los elementos CNC Caja de herramientas vista: contien...", 
"body" : "El editor CNC consta de los siguientes componentes: Editor principal: El editor de texto muestra el programa DIN 66025, o el editor tabular muestra la ruta del CNC. Editor gráfico: Aquí se muestra la vista gráfica de la ruta. Propiedades vista de los elementos CNC Caja de herramientas vista: contiene herramientas para seleccionar e insertar elementos de ruta Cuando presionas el botón F6 tecla, el foco alterna entre el editor principal y el editor gráfico. Si se selecciona un elemento de ruta en el editor gráfico, entonces el bloque de movimiento o la línea respectiva se selecciona implícitamente en el editor de texto o tabular. Asimismo, un elemento seleccionado en el editor tabular o editor de texto también se selecciona en el editor gráfico. Los cambios en el editor gráfico se aplican en el editor de texto o en el editor tabular, y viceversa. Los ajustes CNC de toda la aplicación se aplican y guardan en el Configuración CNC objeto. Los ajustes CNC específicos del objeto se aplican y guardan en el Propiedades cuadro de diálogo del objeto CNC. " }, 
{ "title" : "Componentes del software SoftMotion del editor CNC ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_92f7df24e9a24fa0c0a864630c4c4560", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Fundamentos del editor CNC \/ Componentes del software SoftMotion del editor CNC ", 
"snippet" : "(1) editor CNC (2) programa IEC (3) Parámetro (4) Intérprete (5) GeoInfo (6) Preprocesamiento de ruta (7) Interpolador (8) Puntos de ruta (9) Coordenadas cartesianas (10) Cinemática directa (11) Transformación específica de la máquina (12) Cinemática inversa (13) Posición del eje (14) Interfaz de ac...", 
"body" : "(1) editor CNC (2) programa IEC (3) Parámetro (4) Intérprete (5) GeoInfo (6) Preprocesamiento de ruta (7) Interpolador (8) Puntos de ruta (9) Coordenadas cartesianas (10) Cinemática directa (11) Transformación específica de la máquina (12) Cinemática inversa (13) Posición del eje (14) Interfaz de accionamiento " }, 
{ "title" : "Compilación de objetos CNC ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_c0635f14eddc9007c0a8646316c80481", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Fundamentos del editor CNC \/ Compilación de objetos CNC ", 
"snippet" : "El Modo de compilación se selecciona al agregar un nuevo objeto CNC, y si es necesario se puede cambiar en el Propiedades diálogo ( CNC pestaña del objeto CNC). Dependiendo de Modo de compilación , a SMC_OutQueue bloque de funciones, SMC_CNC_REF bloque de función, o se crea un archivo ASCII con la r...", 
"body" : "El Modo de compilación se selecciona al agregar un nuevo objeto CNC, y si es necesario se puede cambiar en el Propiedades diálogo ( CNC pestaña del objeto CNC). Dependiendo de Modo de compilación , a SMC_OutQueue bloque de funciones, SMC_CNC_REF bloque de función, o se crea un archivo ASCII con la ruta CNC programada en tiempo de compilación. Si el Excluir de la compilación se selecciona la opción en el Propiedades diálogo sobre el Construir ficha del objeto CNC, no se generarán datos IEC. En modo de compilación Archivo , no se descargan datos al controlador. " }, 
{ "title" : "Abriendo un CoDeSys V2.3 Proyectos ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_88cb0aeee9a24fa0c0a864634f00b359", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Fundamentos del editor CNC \/ Abriendo un CoDeSys V2.3 Proyectos ", 
"snippet" : "Cuando abres un CoDeSys V2.3 proyecto en CODESYS , se proporciona un convertidor para ejecutar las siguientes funciones siempre que se utilice un controlador SoftMotion: Cada programa CNC se convierte en un objeto CNC con el mismo nombre y tipo de implementación DIN 66025. El modo de compilación, el...", 
"body" : "Cuando abres un CoDeSys V2.3 proyecto en CODESYS , se proporciona un convertidor para ejecutar las siguientes funciones siempre que se utilice un controlador SoftMotion: Cada programa CNC se convierte en un objeto CNC con el mismo nombre y tipo de implementación DIN 66025. El modo de compilación, el tamaño de la cola y la posición de inicio del programa convertido también se aplican como el estado de la supresión de pasos. Si el Excluir de la compilación se selecciona la opción en el programa CNC del CoDeSys V2.3 proyecto, entonces se acepta esta opción. El Configuraciones CNC El objeto se genera automáticamente. Todos los objetos CNC se enumeran debajo de una aplicación compatible con SoftMotion. " }, 
{ "title" : "Creación de un programa CNC ", 
"url" : "_sm_cnc_creating_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Creación de un programa CNC ", 
"snippet" : "Seleccione una aplicación en el árbol de dispositivos. Hacer clic Proyecto → Agregar objeto → Programa CNC . Especifique un nombre en el Agregar programa CNC cuadro de diálogo y seleccione un Implementación del cuadro de lista: DIN 66025 : Para crear su programa en el editor de texto Mesa : Para cre...", 
"body" : "Seleccione una aplicación en el árbol de dispositivos. Hacer clic Proyecto → Agregar objeto → Programa CNC . Especifique un nombre en el Agregar programa CNC cuadro de diálogo y seleccione un Implementación del cuadro de lista: DIN 66025 : Para crear su programa en el editor de texto Mesa : Para crear su programa en el editor tabular Seleccione un Modo de compilación para determinar el comportamiento al compilar: SMC_OutQueue : se genera una estructura de datos SMC_OutQueue en la compilación. Se le otorga acceso global por medio de g_CNCQueueManager (SMC_OutQueue). SMC_CNC_REF : Las variables de programa se generan en la compilación. Se le otorga acceso global por medio de g_CNCProgManager (SMC-CNC_REF) en un programa IEC. ARCHIVO : Un archivo generado por el código G se descarga y actualiza en cada inicio de sesión. El PLC puede descargar este archivo mediante bloques de función. Puedes cambiar el Implementación y Modo de compilación más tarde en el Propiedades diálogo ( CNC pestaña del programa CNC). Hacer clic Agregar . El objeto CNC se inserta en el árbol de dispositivos y se abre en el editor. " }, 
{ "title" : "Programación de una ruta según DIN 66025 ", 
"url" : "_sm_cnc_programming_din_66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Programación de una ruta según DIN 66025 ", 
"snippet" : "SoftMotion admite partes del lenguaje CNC DIN 66025 que permite la programación de trayectorias geométricas en el editor de un objeto CNC. El Redactor DIN 66025 del objeto CNC (también: editor de texto CNC) se proporciona para la programación en el lenguaje CNC DIN 66025. Requisito: un programa CNC ...", 
"body" : "SoftMotion admite partes del lenguaje CNC DIN 66025 que permite la programación de trayectorias geométricas en el editor de un objeto CNC. El Redactor DIN 66025 del objeto CNC (también: editor de texto CNC) se proporciona para la programación en el lenguaje CNC DIN 66025. Requisito: un programa CNC el objeto está abierto con DIN 66025 implementación. Coloque el cursor en la línea en blanco. Ingrese los bloques de código G línea por línea en el editor. Cuando haya introducido un bloque (ejemplo: N10 G01 X100 Y100 E100 F100 E-200 ), el elemento de ruta se muestra inmediatamente en el editor gráfico. Aquí es donde puede usar el campo operativo para cambiar la vista y la dirección de la vista en los diferentes ejes. Si selecciona el elemento de ruta en el editor gráfico, sus propiedades se muestran en el Propiedades vista. Para más información, ver: Fundamentos de DIN 66025" }, 
{ "title" : "Programación de una ruta en el editor tabular ", 
"url" : "_sm_cnc_programming_table_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Programación de una ruta en el editor tabular ", 
"snippet" : "Requisito: un programa CNC el objeto se crea con el Mesa implementación, y el objeto está abierto en el editor tabular ....", 
"body" : "Requisito: un programa CNC el objeto se crea con el Mesa implementación, y el objeto está abierto en el editor tabular . " }, 
{ "title" : "Insertar elementos ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f56fa52f4ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Programación de una ruta en el editor tabular \/ Insertar elementos ", 
"snippet" : "Haga doble clic en el Vacío celda en el Escribe columna. Seleccione un elemento del cuadro de lista y presione el botón Ingresar llave. Si es el primer elemento de la tabla, los campos se rellenan con los valores iniciales del elemento. De lo contrario, el elemento recibe los valores del elemento de...", 
"body" : "Haga doble clic en el Vacío celda en el Escribe columna. Seleccione un elemento del cuadro de lista y presione el botón Ingresar llave. Si es el primer elemento de la tabla, los campos se rellenan con los valores iniciales del elemento. De lo contrario, el elemento recibe los valores del elemento de la línea anterior. Todos los demás campos permanecen sombreados en gris y el elemento se muestra en el editor gráfico. La última línea de la tabla es una línea en blanco con el tipo Vacío . Para agregar otro elemento, también puede hacer clic en el Insertar elemento comando en el menú contextual de una entrada de tabla. " }, 
{ "title" : "Cambiar una entrada de la tabla ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f568c7504ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Programación de una ruta en el editor tabular \/ Cambiar una entrada de la tabla ", 
"snippet" : "Haga doble clic en una entrada de la tabla de un elemento. El campo es editable o hay un símbolo de un cuadro de lista. El elemento está marcado en rojo en el editor gráfico. Cambia el valor de la entrada de la tabla. El cambio se muestra en el editor gráfico. Si hace clic en el comando Aplicar valo...", 
"body" : "Haga doble clic en una entrada de la tabla de un elemento. El campo es editable o hay un símbolo de un cuadro de lista. El elemento está marcado en rojo en el editor gráfico. Cambia el valor de la entrada de la tabla. El cambio se muestra en el editor gráfico. Si hace clic en el comando Aplicar valor a todos los elementos en el menú contextual de la entrada de la tabla, el valor actual se aplica en todas las demás entradas de la misma columna. Requisito: El valor se puede utilizar para el tipo de elemento respectivo. El número de línea no se puede editar. " }, 
{ "title" : "Eliminación de un elemento ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f0684d0502561eafc0a864633d0e8542", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Programación de una ruta en el editor tabular \/ Eliminación de un elemento ", 
"snippet" : "Seleccione una línea de la tabla y haga clic en el comando Quitar elemento en el menú contextual. La última línea de la tabla con el tipo Vacío no se puede eliminar....", 
"body" : "Seleccione una línea de la tabla y haga clic en el comando Quitar elemento en el menú contextual. La última línea de la tabla con el tipo Vacío no se puede eliminar. " }, 
{ "title" : "Estructuras de datos CNC y acceso global ", 
"url" : "_sm_cnc_data_structure_global_access.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Estructuras de datos CNC y acceso global ", 
"snippet" : "Los objetos CNC disponibles en el proyecto se compilan en bloques de función de tipo SMC_OUTQUEUE o SMC_CNC_REF . (Esto no sucede cuando el método de compilación ARCHIVO se usa.) Cuando se compila el proyecto, los datos CNC creados se gestionan internamente en el SMC_CNC_Data bloques de funciones Pa...", 
"body" : "Los objetos CNC disponibles en el proyecto se compilan en bloques de función de tipo SMC_OUTQUEUE o SMC_CNC_REF . (Esto no sucede cuando el método de compilación ARCHIVO se usa.) Cuando se compila el proyecto, los datos CNC creados se gestionan internamente en el SMC_CNC_Data bloques de funciones Para el modo de compilación SMC_OutQueue , cada elemento del CNC está representado por un SMC_OUTQUEUE bloque de funciones Para el modo de compilación SMC_CNC_REF , un elemento CNC está representado por SMC_CNC_REF . Mientras se procesa el programa IEC, los bloques de funciones se crean instancias y se completan con valores que se pueden procesar en programas IEC. Todas estas POU están contenidas en SM3_CNC . " }, 
{ "title" : "Acceso global a datos CNC ", 
"url" : "_sm_cnc_data_structure_global_access.html#UUID-aaee586d-72f4-405c-8bb5-b4b2cb32f52d_id_cb8536efda52bb5c0a8646375871841_id_4fd460ed02599820c0a864633ab223de", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Estructuras de datos CNC y acceso global \/ Acceso global a datos CNC ", 
"snippet" : "Durante la inicialización, el tipo y el número de objetos generados se determinan a partir del programa CNC. Todos estos objetos se enumeran juntos en una estructura de datos global que se declara implícitamente. Objetos de tipo SMC_OUTQUEUE se enumeran en el objeto de datos globales g_CNCQueueManag...", 
"body" : "Durante la inicialización, el tipo y el número de objetos generados se determinan a partir del programa CNC. Todos estos objetos se enumeran juntos en una estructura de datos global que se declara implícitamente. Objetos de tipo SMC_OUTQUEUE se enumeran en el objeto de datos globales g_CNCQueueManager con la propiedad Count y el metodo GetOutQueue(int n) . Objetos de tipo SMC_CNC_REF se enumeran en el objeto de datos globales g_CNCProgManager con la propiedad Count y el metodo GetProgram(int n) . El usuario ahora puede acceder a él en un programa IEC. Ejemplo Acceso a objetos de datos de la estructura. SMC_OUTQUEUE PROGRAM CNCManageQueue\nVAR\n pCNC_OutQueue : POINTER TO SMC_OUTQUEUE;\n n: INT;\n i: INT;\nEND_VAR\n\nn := g_CNCQueueManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_OutQueue := g_CNCQueueManager.GetOutQueue(I);\n (* calculate pCNC_OutQueue *)\nEND_FOR Acceso a objetos de datos de la estructura. SMC_CNC_REF PROGRAM CNCManageRef\nVAR\n pCNC_Ref: POINTER TO SMC_CNC_REF;\n n: INT;\nEND_VAR\n\nn := g_CNCProgManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_Ref := g_CNCProgManager.GetProgram(I);\n (* calculate pCNC_Ref *)\nEND_FOR " }, 
{ "title" : "Transformaciones cinemáticas ", 
"url" : "_sm_f_cnc_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Transformación directa e inversa ", 
"url" : "_sm_cnc_forward_backward_transformation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Transformación directa e inversa ", 
"snippet" : "CODESYS SoftMotion proporciona bloques de funciones para la transformación matemática directa e inversa para muchas cinemáticas populares. Para cada diseño cinemático, hay dos bloques de funciones disponibles para la transformación. El POU denominado SMC_TRAFO_<kinematics> calcula la posición del ej...", 
"body" : "CODESYS SoftMotion proporciona bloques de funciones para la transformación matemática directa e inversa para muchas cinemáticas populares. Para cada diseño cinemático, hay dos bloques de funciones disponibles para la transformación. El POU denominado SMC_TRAFO_<kinematics> calcula la posición del eje a partir de la posición en el espacio (transformación inversa). El POU denominado SMC_TRAFOF_<kinematics> calcula la posición en el espacio a partir de la posición del eje (transformación hacia adelante). Puede vincular rápida y fácilmente las instancias de las POU de transformación directa a las plantillas de visualización para visualizar la cinemática. SMC_TRAFOV_ Algunas de las transformaciones inversas también utilizan la velocidad de la trayectoria y la dirección de la trayectoria para calcular las velocidades de los ejes. Los nombres de estas POU de transformación comienzan con SMC_TRAFOV_ en vez de SMC_TRAFO_ . Estas POU obtienen la tangente de la ruta ( v ) y la velocidad de trayectoria ( dVel ) como entradas adicionales del interpolador. También devuelven las velocidades establecidas ( dvx\/dvy\/dvz ) además de las posiciones establecidas. La ventaja es que el retraso en el variador se puede minimizar mediante el control de entrada de la velocidad, siempre que el variador admita este método. Para transferir las velocidades establecidas al variador, debe usar SMC_ControlAxisByPosVel en vez de SMC_ControlAxisByPos en este caso. Para más información, ver: SMC_ControlAxisByPos (FB) , SMC_ControlAxisByVel (FB) y SMC_ControlAxisByPosVel (FB) " }, 
{ "title" : "Transformación de 5 ejes ", 
"url" : "_sm_trafo_pou_five_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Transformación de 5 ejes ", 
"snippet" : "Con la transformación de 5 ejes, puede controlar cinemáticas que constan de tres ejes espaciales lineales (X, Y, Z) y un cabezal de herramienta. El cabezal de la herramienta consta de dos ejes que sujetan la herramienta. Un eje de herramienta gira alrededor del eje Z y la herramienta inclina a los d...", 
"body" : "Con la transformación de 5 ejes, puede controlar cinemáticas que constan de tres ejes espaciales lineales (X, Y, Z) y un cabezal de herramienta. El cabezal de la herramienta consta de dos ejes que sujetan la herramienta. Un eje de herramienta gira alrededor del eje Z y la herramienta inclina a los demás de acuerdo con el siguiente esquema. Parámetro: Longitud de dTool = Distancia desde el punto de procesamiento (punta de la herramienta = TCP) hasta la inclinación del eje giratorio. Control de la transformación de 5 ejes por cinco valores posicionales: Posición X\/Y\/Z del punto de procesamiento (TCP) que se incluye en pi.dX, pi.dY, pi.dZ . Unidad: Unidades de posición de los ejes. Orientación de la herramienta por coordenadas esféricas (inclinación y acimut) que se incluyen en pi.dB y pi.dC . Unidad: Grados angulares. posición cero El punto de procesamiento (TCP) se encuentra en la posición ( 0\/0\/-dTool ). La herramienta se extiende en la dirección del eje Z negativo. La inclinación del eje giratorio se coloca de tal manera que al girar en la dirección positiva, la herramienta se movería en la dirección del eje X positivo. Ejemplo Para el movimiento N30, el eje de inclinación que primero apunta en la dirección X se gira y permanece inclinado en la dirección X negativa al final del movimiento. N0 PB360 PC360 (set axis B and C in modulo mode 360)\nN10 F10 FB100 FC100 (velocity in X\/Y\/Z: 10, in B and C 100)\nN20 G0 X0 Y0 Z0 C0 B30 (start position)\nN30 G1 X20 B-30 (target position) Para más información, ver: SMC_TRAFO_5Ejes (FB) y SMC_TRAFOF_5Ejes (FB) " }, 
{ "title" : "Sistema de pórtico ", 
"url" : "_sm_trafo_pou_gantry_system.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Sistema de pórtico ", 
"snippet" : "Los sistemas de pórtico consisten en dos o tres ejes lineales que están dispuestos en ángulo recto. Dado que las transformaciones no tienen que ejecutarse en sistemas de pórtico, los respectivos módulos para transformaciones inversas y directas agregan solo un desplazamiento a los ejes X, Y y Z en d...", 
"body" : "Los sistemas de pórtico consisten en dos o tres ejes lineales que están dispuestos en ángulo recto. Dado que las transformaciones no tienen que ejecutarse en sistemas de pórtico, los respectivos módulos para transformaciones inversas y directas agregan solo un desplazamiento a los ejes X, Y y Z en dos o tres dimensiones. Para más información, ver: MC_TRAFO_Gantry2 (FB) SMC_TRAFOF_Gantry2 (FB) SMC_TRAFO_Gantry3 (FB) SMC_TRAFOF_Gantry3 (FB) " }, 
{ "title" : "Sistema Gantry con Ejes de Orientación ", 
"url" : "_sm_trafo_pou_gantry_cutter.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Sistema Gantry con Ejes de Orientación ", 
"snippet" : "Un \"cortador de pórtico\" es un sistema de pórtico con un eje giratorio que está equipado con una herramienta de corte. La configuración de un sistema de pórtico con eje giratorio es similar a la de un sistema de pórtico simple. Sin embargo, estos sistemas también tienen un eje giratorio donde se aco...", 
"body" : "Un \"cortador de pórtico\" es un sistema de pórtico con un eje giratorio que está equipado con una herramienta de corte. La configuración de un sistema de pórtico con eje giratorio es similar a la de un sistema de pórtico simple. Sin embargo, estos sistemas también tienen un eje giratorio donde se acopla la unidad de corte vertical. Cuando utiliza un sistema de pórtico con un eje giratorio, tiene que utilizar el SMC_TRAFO<n>_GantryCutter<n> POU en lugar de SMC_TRAFO<n>_Gantry<n> . Luego, el eje giratorio se controla de tal manera que se orienta a lo largo de la tangente de la trayectoria actual. Las POU de la cortadora de pórtico tienen las siguientes entradas adicionales: DriveR : Eje giratorio que debe utilizarse con un período de 360° dOffsetR : Offset del eje rotativo iDirectionR : Dirección de rotación Para más información, ver: SMC_TRAFO_GantryCutter2 (FB) SMC_TRAFOF_GantryCutter2 (FB) SMC_TRAFO_GantryCutter3 (FB) SMC_TRAFOF_GantryCutter3 (FB) Las POU para la transformación inversa también deben incluir el vector de la tangente del camino actual (v) que es una salida del interpolador. Para más información, ver: SMC_TRAFOV_GantryCutter2 (FB) y SMC_TRAFOV_GantryCutter3 (FB) " }, 
{ "title" : "Sistema de pórtico con compensación de herramientas ", 
"url" : "_sm_trafo_pou_gantry_system_tool.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Sistema de pórtico con compensación de herramientas ", 
"snippet" : "Si el eje de la herramienta tiene un desplazamiento y no coincide con el eje Z del sistema de pórtico, entonces el punto de contacto de la herramienta no coincide con la posición X\/Y\/Z del sistema de pórtico. Si el eje Z no se puede girar, el desplazamiento resultante de las coordenadas X e Y es con...", 
"body" : "Si el eje de la herramienta tiene un desplazamiento y no coincide con el eje Z del sistema de pórtico, entonces el punto de contacto de la herramienta no coincide con la posición X\/Y\/Z del sistema de pórtico. Si el eje Z no se puede girar, el desplazamiento resultante de las coordenadas X e Y es constante y se puede utilizar directamente para la transformación de pórtico estándar. Si el eje C gira la herramienta (alrededor de Z), entonces el desplazamiento no es constante, sino que depende de la posición del eje C. En este caso, se puede seleccionar una de las dos POU, según la forma de la herramienta: SMC_TRAFO_Gantry2Tool1 y SMC_TRAFOF_Gantry2Tool1 La herramienta apunta a lo largo del eje X rotado por dAlpha y tiene una longitud de dToolA . SMC_TRAFO_Gantry2Tool2 y SMC_TRAFOF_Gantry2Tool2 La herramienta está parcialmente en la dirección del eje X girada por dAlpha (longitud: dToolA ) y parcialmente en la dirección del eje Y girado (longitud: dToolB ). En la figura del siguiente ejemplo, el láser está conectado con un desplazamiento tanto en la dirección X como en la dirección Y. En lugar de ejecutar esta transformación unidimensional, la ruta también se puede modular con una compensación de herramienta. En este momento, la herramienta se aproxima a una línea recta. El SMC_ToolCorr o SMC_ToolRadiusCorr Para ello se utilizan bloques de funciones. La diferencia entre estos dos métodos es la velocidad de la punta de la herramienta. Si la modulación se utiliza desde SMC_ToolCorr , luego la velocidad del punto de rotación se controla de acuerdo con los valores predeterminados en el programa CNC (F, E). La velocidad de la punta de la herramienta puede fluctuar. Si se utiliza la transformación unidimensional, el programa CNC determina la velocidad del punto de la herramienta. Para calcular la orientación de la herramienta, el SMC_CalcDirectionFromVector Se utiliza POU. " }, 
{ "title" : "Pórtico en H con ejes estacionarios ", 
"url" : "_sm_trafo_pou_h_gantry_stationary_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Pórtico en H con ejes estacionarios ", 
"snippet" : "La configuración cinemática es similar al sistema de pórtico, pero los ejes (accionamientos) están firmemente montados. Mueven el portaherramientas mediante una correa. Transformación por medio de la SMC_TRAFO_GantryH2 y SMC_TRAFOF_GantryH2 Las POU requieren las siguientes configuraciones de ejes. S...", 
"body" : "La configuración cinemática es similar al sistema de pórtico, pero los ejes (accionamientos) están firmemente montados. Mueven el portaherramientas mediante una correa. Transformación por medio de la SMC_TRAFO_GantryH2 y SMC_TRAFOF_GantryH2 Las POU requieren las siguientes configuraciones de ejes. Se pueden realizar otras configuraciones intercambiando x e y: Esta transformación requiere un recorrido de referencia especial: ambos ejes deben moverse a la misma velocidad. Si el movimiento debe ser en la dirección X, entonces las unidades A y B deben moverse, mientras que deben moverse con velocidad inversa estrictamente para un movimiento X. Solo para un movimiento X, deben moverse con una velocidad opuesta. Si se encuentra el inicio, los valores X e Y calculados a partir de la POU de transformación directa se utilizan como compensación ( dOffsetX y dOffsetY ). " }, 
{ "title" : "Pórtico en T con ejes estacionarios ", 
"url" : "_sm_trafo_pou_t_gantry_statinary_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Pórtico en T con ejes estacionarios ", 
"snippet" : "Este sistema cinemático es similar a los sistemas de pórtico en H. Los accionamientos aquí también están montados estacionarios y el portaherramientas se mueve por medio de una correa. Las transformaciones que ejecuta el SMC_TRAFO_GantryT2 y SMC_TRAFOF_GantryT2   Las POU están diseñadas para las sig...", 
"body" : "Este sistema cinemático es similar a los sistemas de pórtico en H. Los accionamientos aquí también están montados estacionarios y el portaherramientas se mueve por medio de una correa. Las transformaciones que ejecuta el SMC_TRAFO_GantryT2 y SMC_TRAFOF_GantryT2   Las POU están diseñadas para las siguientes constelaciones de unidades: Tenga en cuenta que se necesita una orientación especial para esta transformación. Si ejecuta un movimiento en la dirección X, debe mover los accionamientos A y B a la misma velocidad. Si ejecuta estrictamente un movimiento Y, entonces las unidades deben girar en direcciones opuestas. Si el variador encuentra la posición de inicio, los valores X e Y calculados a partir de la POU de transformación directa se utilizan como compensación ( dOffsetX y dOffsetY ). El SMC_TRAFO_GantryT2_O y SMC_TRAFOF_GantryT2_O Los bloques de funciones ejecutan el mismo cálculo con la siguiente constelación: " }, 
{ "title" : "sistema polar ", 
"url" : "_sm_trafo_pou_polar_system.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ sistema polar ", 
"snippet" : "Los sistemas polares consisten en un eje de rotación (dirección) y un eje lineal (distancia). El origen y la dirección del eje lineal se pueden cambiar por medio de las compensaciones dPhi y dR . Para más información, ver: SMC_TRAFO_Polar (FB) y SMC_TRAFOF_Polar (FB)...", 
"body" : "Los sistemas polares consisten en un eje de rotación (dirección) y un eje lineal (distancia). El origen y la dirección del eje lineal se pueden cambiar por medio de las compensaciones dPhi y dR . Para más información, ver: SMC_TRAFO_Polar (FB) y SMC_TRAFOF_Polar (FB) " }, 
{ "title" : "Sistema SCARA de 2 articulaciones ", 
"url" : "_sm_trafo_pou_two_jointed_scara.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Sistema SCARA de 2 articulaciones ", 
"snippet" : "El Brazo robótico de ensamblaje de cumplimiento selectivo (SCARA) es un tipo especial de robot industrial que es similar a un brazo humano. Un sistema SCARA tiene dos ejes y dos grados de libertad. El movimiento está restringido al plano X\/Y. Para más información, ver: SMC_TRAFO_Scara2 (FB) y SMC_TR...", 
"body" : "El Brazo robótico de ensamblaje de cumplimiento selectivo (SCARA) es un tipo especial de robot industrial que es similar a un brazo humano. Un sistema SCARA tiene dos ejes y dos grados de libertad. El movimiento está restringido al plano X\/Y. Para más información, ver: SMC_TRAFO_Scara2 (FB) y SMC_TRAFOF_Scara2 (FB) " }, 
{ "title" : "Sistema SCARA de 3 articulaciones ", 
"url" : "_sm_trafo_pou_three_jointed_scara.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Sistema SCARA de 3 articulaciones ", 
"snippet" : "El sistema SCARA de 3 articulaciones tiene un tercer eje que permite el movimiento en una dirección constante. Como en los sistemas de 2 articulaciones, el movimiento está restringido al plano X\/Y. Para más información, ver: SMC_TRAFO_Scara3 (FB) y SMC_TRAFOF_Scara3 (FB)...", 
"body" : "El sistema SCARA de 3 articulaciones tiene un tercer eje que permite el movimiento en una dirección constante. Como en los sistemas de 2 articulaciones, el movimiento está restringido al plano X\/Y. Para más información, ver: SMC_TRAFO_Scara3 (FB) y SMC_TRAFOF_Scara3 (FB) " }, 
{ "title" : "cinemática paralela ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ cinemática paralela ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Trípode con ejes lineales ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_b6b32d1fbe665307c0a8640e00033022", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ cinemática paralela \/ Trípode con ejes lineales ", 
"snippet" : "Este sistema tiene tres accionamientos lineales que se encuentran en un ángulo definido entre sí. Los accionamientos constan de 3 raíles con carros transversales. La placa portaherramientas está unida a las correderas mediante bielas de la misma longitud. Un conjunto emparejado de bielas mantiene la...", 
"body" : "Este sistema tiene tres accionamientos lineales que se encuentran en un ángulo definido entre sí. Los accionamientos constan de 3 raíles con carros transversales. La placa portaherramientas está unida a las correderas mediante bielas de la misma longitud. Un conjunto emparejado de bielas mantiene la placa de herramientas paralela al piso en la misma orientación. La cinemática puede mover la placa de la herramienta en tres dimensiones. La transformación directa e inversa de estas cinemáticas se calcula en el SMC_Trafo_Tripod_Lin y SMC_TrafoF_Tripod_Lin POU. El ángulo del eje del trípode se define por el ángulo entre el riel y el eje vertical ( dAxisAngle ). Requisitos mecánicos y sistema de coordenadas Las longitudes de los 3 ejes son idénticas. Las longitudes de las bielas son idénticas. La distancia entre los pares de bielas entre sí es idéntica para todos los pares. El ángulo del eje entre los rieles de accionamiento y el eje vertical es idéntico para los tres accionamientos. El margen de ángulo está entre 0° y 90°. El eje define el movimiento del punto entre las juntas de biela en las correderas. El sistema de coordenadas XYZ es diestro. Los vectores X e Y son horizontales y Z apunta hacia arriba. El origen se define de modo que las intersecciones de los tres ejes de movimiento con el plano XY (gráficos a continuación: puntos A) estén en un círculo en la posición [0,0,0]. Parametrización del bloque de función SMC_TrafoF_Tripod_Lin Nombre Descripción dInnerRadius Distancia desde el centro de la placa portaherramientas hasta los puntos de agarre de las bielas dOuterRadius El punto A es la intersección del eje con el plano XY. dLength Longitud de las bielas dDistance Distancia entre las dos bielas en un par dRotationOffset El punto A del primer eje define el eje X por defecto. El desplazamiento se utiliza para rotar toda la estructura sobre el eje Z. En este caso, el punto A ya no está en el eje X. dOffsetA El desplazamiento se utiliza para establecer el valor posicional del eje en su configuración predeterminada de cero. dOffsetB dOffsetC Encontrará información sobre otros parámetros en la descripción de la biblioteca. " }, 
{ "title" : "Trípode con ejes verticales ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_74ba1833be665308c0a8640e019694c6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ cinemática paralela \/ Trípode con ejes verticales ", 
"snippet" : "Este sistema es una variante especial del diseño cinemático descrito anteriormente y tiene los mismos requisitos mecánicos. El ángulo dAxisAngle entre los rieles guía y el eje vertical es 0° y los rieles guía son paralelos al eje vertical. La transformación directa e inversa de estas cinemáticas se ...", 
"body" : "Este sistema es una variante especial del diseño cinemático descrito anteriormente y tiene los mismos requisitos mecánicos. El ángulo dAxisAngle entre los rieles guía y el eje vertical es 0° y los rieles guía son paralelos al eje vertical. La transformación directa e inversa de estas cinemáticas se calcula en el SMC_Trafo_Tripod_Lin y SMC_TrafoF_Tripod_Lin bloques de funciones El ángulo del eje del trípode se define por el ángulo entre el riel y el eje vertical ( dAxisAngle ). Parametrización del bloque de función SMC_TrafoF_Tripod_Lin Nombre Descripción dInnerRadius El parámetro define el radio del círculo que describen los seis puntos de sujeción de las bielas a la placa de la herramienta. dOuterRadius dLength Longitud de las bielas dDistance Distancia de los pares de bielas entre sí dRotationOffset El punto A del primer eje define el eje X por defecto. El desplazamiento se utiliza para rotar toda la estructura sobre el eje Z. En este caso, el punto A ya no está en el eje X. dOffsetA El desplazamiento se utiliza para establecer el valor posicional del eje en su configuración predeterminada de cero. dOffsetB dOffsetC Encontrará información sobre otros parámetros en la descripción de la biblioteca. " }, 
{ "title" : "Trípode con ejes giratorios ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_30491f2ca003ef70c0a864631e92f50c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ cinemática paralela \/ Trípode con ejes giratorios ", 
"snippet" : "Para los trípodes, la cinemática se implementa mediante 3 accionamientos giratorios que están conectados a la placa de la herramienta mediante brazos y bielas. El origen del sistema de coordenadas es la ubicación del centro de la placa de la herramienta cuando los 3 brazos están en posición horizont...", 
"body" : "Para los trípodes, la cinemática se implementa mediante 3 accionamientos giratorios que están conectados a la placa de la herramienta mediante brazos y bielas. El origen del sistema de coordenadas es la ubicación del centro de la placa de la herramienta cuando los 3 brazos están en posición horizontal. La transformación directa e inversa de estas cinemáticas se calcula en el SMC_TRAFO_Tripod_Arm y SMC_TRAFOF_Tripod_Arm bloques de funciones Requisitos mecánicos y sistema de coordenadas Las longitudes de los tres ejes son idénticas. Las longitudes de las bielas son idénticas. La distancia entre los pares de bielas entre sí es idéntica para todos los pares. Parametrización del bloque de función SMC_TrafoF_Tripod_Arm Nombre Descripción dArmLength1 dArmLength2 dArm1Radius El parámetro define el radio del círculo que establecen los 3 puntos P de los accionamientos. dStewartRadius El parámetro define el radio del círculo que describen los 6 puntos de agarre de las bielas a la placa de la herramienta. dDistance Distancia entre las dos bielas en un par dOffsetA dOffsetB dOffsetC Encontrará información sobre otros parámetros en la descripción de la biblioteca. La imagen muestra la posición cero de todos los ejes. (Los tres brazos superiores son horizontales). El MCS se muestra en la placa de herramientas. Las flechas en los ejes A0, A1 y A2 muestran la dirección de rotación de los accionamientos según la regla de la mano derecha. Sistema de coordenadas de máquina (MCS) Origen Se define en el punto medio de la placa de herramientas cuando los 3 brazos superiores (aquellos que están conectados directamente con A0, A1 o A2) están en posición horizontal X Desde el origen, apunta lejos del primer motor (A0), paralelo al segmento del brazo superior del primer brazo Y Determinado por X y Z para que el MCS sea diestro Z Ortogonal a la placa de la herramienta Señala desde la placa de herramientas en la dirección de los motores Las respectivas transformaciones son ejecutadas por las siguientes POUs SMC_TRAFO_Tripod_Arm y SMC_TRAFOF_Tripod_Arm : Ejemplo: trípode 3S Configuraciones de transformación tta:\nSMC_TRAFO_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41,dMaxAngleBallJoint:=60);\nttaf:\nSMC_TRAFOF_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41); " }, 
{ "title" : "Cinemática del paletizador de 4 ejes ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Cinemática del paletizador de 4 ejes ", 
"snippet" : "La cinemática del paletizador de 4 ejes es un tipo de robot general que se utiliza con frecuencia para tareas de paletizado. La cinemática está provista de cuatro ejes giratorios controlados (marcados en rojo) y un quinto eje giratorio mecánico (marcado en gris). El SMC_Trafo_4AxisPaletizador y SMC_...", 
"body" : "La cinemática del paletizador de 4 ejes es un tipo de robot general que se utiliza con frecuencia para tareas de paletizado. La cinemática está provista de cuatro ejes giratorios controlados (marcados en rojo) y un quinto eje giratorio mecánico (marcado en gris). El SMC_Trafo_4AxisPaletizador y SMC_TrafoF_4AxisPaletizer Las POU implementan su transformación directa e inversa. El sistema de coordenadas cartesianas es la base del paletizador. El eje Z apunta hacia abajo perpendicularmente y el eje X \"hacia adelante\", lo que significa en la dirección en que el brazo apunta en la dirección cero de los ejes. El origen del sistema de coordenadas cartesianas es la intersección del eje de articulación 1 y la parte inferior del robot. Objetos la estructura de datos SMC_TrafoConfig_4AxisPalletizer y el SMC_Trafo_4AxisPalletizer y SMC_TrafoF_4AxisPalletizer los bloques de funciones están vinculados a la biblioteca SM3_Transformation . Para obtener una descripción de los parámetros, busque estos objetos en el Administrador de biblioteca. " }, 
{ "title" : "Definición de ejes ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_945c0811df409256c0a8657d0066458b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Cinemática del paletizador de 4 ejes \/ Definición de ejes ", 
"snippet" : "La siguiente imagen muestra la dirección de rotación de los cuatro ejes. Las flechas negras corren a lo largo del eje de la articulación. La dirección de rotación se determina de acuerdo con la regla de la mano derecha: si el pulgar de la mano derecha apunta hacia abajo a lo largo de la flecha, ento...", 
"body" : "La siguiente imagen muestra la dirección de rotación de los cuatro ejes. Las flechas negras corren a lo largo del eje de la articulación. La dirección de rotación se determina de acuerdo con la regla de la mano derecha: si el pulgar de la mano derecha apunta hacia abajo a lo largo de la flecha, entonces la dirección de rotación positiva es en la dirección del dedo ligeramente curvado. Por ejemplo, cuando se ve desde arriba, la dirección de rotación positiva del eje 0 es en el sentido de las agujas del reloj, mientras que los ejes 1 y 2 se inclinan \"hacia adelante\" para una rotación positiva. La cinemática tiene 4 ejes de rotación controlados (consulte los ejes a0, a1, a2, a3 coloreados en rojo) y un quinto eje de rotación mecánico (consulte el eje M de color gris). Rangos de valores de los ejes: Eje 0: ]-180°, 180°[ Eje 1: [-90°, 90°] Eje 2: [-180°, 90[ Eje M: eje mecánico de rotación. Sin límite Eje 3: Sin restricciones; el rango también puede ser mayor a 360° " }, 
{ "title" : "Posición cero y dimensiones ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Cinemática del paletizador de 4 ejes \/ Posición cero y dimensiones ", 
"snippet" : "La imagen muestra la cinemática en posición cero de todos los ejes. En la posición cero, los ejes del sistema de coordenadas de la herramienta discurren paralelos a los del sistema de coordenadas de la máquina. Especifique las dimensiones indicadas en la estructura de configuración SMC_TrafoConfig_4...", 
"body" : "La imagen muestra la cinemática en posición cero de todos los ejes. En la posición cero, los ejes del sistema de coordenadas de la herramienta discurren paralelos a los del sistema de coordenadas de la máquina. Especifique las dimensiones indicadas en la estructura de configuración SMC_TrafoConfig_4AxisPaletizer también especificar todo a_i con signos positivos y todo d_i con signos negativos. Los nombres de los parámetros están de acuerdo con la convención Denavit-Hartenberg. Transformación de articulaciones Denavit-Hartenberg Compensación conjunta (sigma_i) Distancia conjunta (d_i) Longitud del elemento del brazo (a_i) Torsión (alfa_i) 1 0° d_1 a_1 90° 2 -90° 0 a_2 0° 3 90° 0 a_3 0° 4 0° 0 a_4 90° 5 0° d_5 0 180° " }, 
{ "title" : "Programación en código G ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_67269b93df408f35c0a8657d0178e964", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Cinemática del paletizador de 4 ejes \/ Programación en código G ", 
"snippet" : "La posición de la pinza se controla con X, Y y Z. La rotación de la pinza en la vertical se controla mediante el eje adicional C. Los ángulos se especifican en grados....", 
"body" : "La posición de la pinza se controla con X, Y y Z. La rotación de la pinza en la vertical se controla mediante el eje adicional C. Los ángulos se especifican en grados. " }, 
{ "title" : "Robot articulado de 6 ejes ", 
"url" : "_sm_trafo_pou_six_dof_robot.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Robot articulado de 6 ejes ", 
"snippet" : "Transformación de un robot de brazo articulado con seis ejes rotativos y seis grados de libertad (DoF). Los tres ejes de orientación del brazo del robot se cruzan en un punto: el centro de la articulación. El SMC_Trafo_ArticulatedRobot_6DOF y SMC_TrafoF_ArticulatedRobot_6DOF Los bloques de funciones...", 
"body" : "Transformación de un robot de brazo articulado con seis ejes rotativos y seis grados de libertad (DoF). Los tres ejes de orientación del brazo del robot se cruzan en un punto: el centro de la articulación. El SMC_Trafo_ArticulatedRobot_6DOF y SMC_TrafoF_ArticulatedRobot_6DOF Los bloques de funciones implementan transformaciones directas e inversas de un robot de brazo articulado con seis ejes de rotación. En la imagen, el sistema de coordenadas cartesianas está marcado debajo en el eje 0. El eje z apunta hacia abajo y el eje x apunta hacia adelante en la dirección del punto central de la herramienta (TCP). El origen del sistema de coordenadas cartesianas es el eje de intersección 0 y la parte inferior del robot. Objetos de transformación la estructura de datos SMC_TrafoConfig_ArticulatedRobot_6DOF y el SMC_Trafo_Robot Articulado_6DOF y SMC_TrafoF_Robot articulado_6DOF Los bloques de funciones están vinculados a SM3_CNC . " }, 
{ "title" : "Definición de ejes ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_7e060a95379b6b55c0a8640e01f01d63", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Robot articulado de 6 ejes \/ Definición de ejes ", 
"snippet" : "Los ejes giratorios se identifican con flechas negras. La dirección de rotación positiva viene dada por la regla de la mano derecha. Por ejemplo, cuando el eje 0 se gira en dirección positiva, el robot gira en el sentido de las agujas del reloj cuando se ve desde arriba. Los ejes están restringidos ...", 
"body" : "Los ejes giratorios se identifican con flechas negras. La dirección de rotación positiva viene dada por la regla de la mano derecha. Por ejemplo, cuando el eje 0 se gira en dirección positiva, el robot gira en el sentido de las agujas del reloj cuando se ve desde arriba. Los ejes están restringidos a los siguientes rangos: Ejes 0, 1, 3 y 4:] -180 °, 180 ° [ Eje 2: [-90 °, 180 °] Eje 5: Sin restricciones; el rango puede ser superior a 360 °. " }, 
{ "title" : "Posición y dimensiones de inicio ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Robot articulado de 6 ejes \/ Posición y dimensiones de inicio ", 
"snippet" : "La imagen de la izquierda muestra la posición de inicio de la cinemática, que es la posición en la que todos los ejes están en su posición cero. Especifique las dimensiones indicadas en la estructura de configuración  SMC_TrafoConfig_ArticulatedRobot_6DOF . Los nombres y signos de los parámetros est...", 
"body" : "La imagen de la izquierda muestra la posición de inicio de la cinemática, que es la posición en la que todos los ejes están en su posición cero. Especifique las dimensiones indicadas en la estructura de configuración  SMC_TrafoConfig_ArticulatedRobot_6DOF . Los nombres y signos de los parámetros están de acuerdo con la convención Denavit-Hartenberg. La imagen de la derecha muestra el parámetro adicional Denavit-Hartenberg d3 . Nota: a1, a3, d4 y d6 tienen que ser> = 0 a2 tiene que ser> 0 (> g_fSMC_CNC_EPS ) d1 tiene que ser <= 0 Transformación de juntas de Denavit-Hartenberg Desplazamiento de articulación (sigma_i) Desplazamiento de palanca (d_i) Longitud de la palanca (a_i) Rotación de la palanca (alpha_i) 1 0 ° d1 a_1 -90 ° 2 90 ° 0 a_2 0 ° 3 0 ° d3 a_3 90 ° 4 0 ° d4 0 90 ° 5 0 ° 0 0 -90 ° 6 0 ° d6 0 0 ° " }, 
{ "title" : "Programación ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_9cf41a3c6a5fb376c0a8640e005461c1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Robot articulado de 6 ejes \/ Programación ", 
"snippet" : "La posición del centro de la herramienta se controla con X, Y y Z. Las unidades de X, Y y Z son las mismas que se utilizan para los parámetros a_i y d_i (por ejemplo: mm). La orientación se controla en grados con A (guiñada), B (cabeceo) y C (balanceo)....", 
"body" : "La posición del centro de la herramienta se controla con X, Y y Z. Las unidades de X, Y y Z son las mismas que se utilizan para los parámetros a_i y d_i (por ejemplo: mm). La orientación se controla en grados con A (guiñada), B (cabeceo) y C (balanceo). " }, 
{ "title" : "Contenedor para bloques de funciones de transformación cinemática del SM3_Transformation biblioteca ", 
"url" : "_sm_wrapper_kinematic_fbs.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformaciones cinemáticas \/ Contenedor para bloques de funciones de transformación cinemática del SM3_Transformation biblioteca ", 
"snippet" : "El SMC_Trafo_Wrapper y SMC_Trafof_Wrapper los bloques de funciones permiten utilizar la cinemática del SM3_Transformation biblioteca para aplicaciones CNC. Para obtener más información sobre la cinemática del SM3_Transformation biblioteca, consulte lo siguiente: CinemáticaEs posible utilizar cualqui...", 
"body" : "El SMC_Trafo_Wrapper y SMC_Trafof_Wrapper los bloques de funciones permiten utilizar la cinemática del SM3_Transformation biblioteca para aplicaciones CNC. Para obtener más información sobre la cinemática del SM3_Transformation biblioteca, consulte lo siguiente: CinemáticaEs posible utilizar cualquier transformación que implemente el MC_KIN_REF_SM3 interfaz. Además, son posibles combinaciones de «cinemática de posición» y «cinemática de orientación Para obtener más información, consulte lo siguiente: Combinación de cinemática de posición y orientación" }, 
{ "title" : "Lenguaje CNC en DIN 66025 ", 
"url" : "_sm_struct_reference_programming_din66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Fundamentos de DIN 66025 ", 
"url" : "_sm_cnc_din66025_basics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Fundamentos de DIN 66025 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Estructura de un programa DIN 66025 ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_c348b29fedfe7b9ec0a86463427bc61d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Fundamentos de DIN 66025 \/ Estructura de un programa DIN 66025 ", 
"snippet" : "El programa DIN 66025 consta de bloques de movimiento individuales. El número de bloque se encuentra al comienzo de cada bloque. ['%' <Programmname>] <Satz>{<Satz>} Los bloques se pueden estructurar de la siguiente manera: N<block number> G<expression> <G code words> N<block number> <G code words> (...", 
"body" : "El programa DIN 66025 consta de bloques de movimiento individuales. El número de bloque se encuentra al comienzo de cada bloque. ['%' <Programmname>]\n<Satz>{<Satz>} Los bloques se pueden estructurar de la siguiente manera: N<block number> G<expression> <G code words> N<block number> <G code words> (los G<expression> del bloque anterior se aplican) N<block number> M<expression> <G code words> N<block number> <subroutine name> ( <ActualParamList> ) Estructuras de bloques adicionales para subrutinas: SUBPROGRAM <Name> {<FormalParamList>} <RESTORE_OPT> N<block number> RETURN END_SUBPROGRAM Ejemplo Ruta de dos líneas y un arco, seguida de una llamada de subrutina % MyProgram\nN10 G01 X100 Y100 E100 F100 E-200\nN20 G01 Z40 F20\nN30 G03 X-100 R200 F100\nN40 SubPrg{5} " }, 
{ "title" : "Sintaxis ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_section-idm4580346248046432600861986014", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Fundamentos de DIN 66025 \/ Sintaxis ", 
"snippet" : "['%' <nombre del programa>] Encabezado opcional Comienza con%, seguido del nombre del programa separado por un Espacio o Pestaña <bloque> El bloque se procesa palabra por palabra de derecha a izquierda. \/ Supresión de pasos Si un bloque comienza con \/ y el CNC ➔ Supresión de pasos se selecciona el c...", 
"body" : "['%' <nombre del programa>] Encabezado opcional Comienza con%, seguido del nombre del programa separado por un Espacio o Pestaña <bloque> El bloque se procesa palabra por palabra de derecha a izquierda. \/ Supresión de pasos Si un bloque comienza con \/ y el CNC ➔ Supresión de pasos se selecciona el comando, entonces el bloque no se ejecuta. N <número de bloque> El número de bloque se utiliza como marcador para definir objetivos de salto. Ejemplo: N01 G <expresión> Comando de viaje Si no se especifica ningún comando de desplazamiento en un bloque, el comando de desplazamiento del bloque anterior se complementa automáticamente. Se ignoran las mayúsculas y las minúsculas. Los ceros iniciales se ignoran. Por lo tanto, G01 = g1 aplica Corresponde a un elemento de ruta o un objeto de ruta Ejemplo: G1 (lineal), G2 (arco) La velocidad a la que se interpolan los objetos de la trayectoria; en principio corresponde a la velocidad de trayectoria establecida, la aceleración de trayectoria y la desaceleración de trayectoria. El interpolador se asegura de que no se superen estos valores límite. <Palabra de código G> Se ignoran las mayúsculas y las minúsculas. Palabra de código G Consta de una dirección (ejemplo: E) y una expresión (ejemplo: 100 ); juntos E100 ) Se ignoran las mayúsculas y las minúsculas. Los ceros iniciales se ignoran. Escribe el número de la palabra en una variable. La letra de la palabra es el nombre de la variable. El comando de viaje accede a esto. Todos los números pueden ser valores de coma flotante. Esto no se aplica a la G<expression> comando de viaje, M<expression> Función M, y H<expression> punto de conmutación. Las palabras de un bloque están separadas por un espacio o pestaña . <expresión> Ver: Expresiones() Comentario Los caracteres entre paréntesis se interpretan como un comentario. Nota: Los comentarios se pueden redefinir mediante el bParenthesesAsComments aporte ( FB SMC_ReadNCFile2 ) . Interpolación entre dos bloques consecutivos La velocidad al realizar la transición de dos objetos adyacentes está determinada por las siguientes reglas: Si uno de los dos objetos es un posicionamiento de G0 , entonces la velocidad de transición = 0. Si el ángulo entre las tangentes de ambos elementos de la trayectoria en la transición es mayor que la tolerancia del ángulo, entonces la velocidad de transición = 0. De lo contrario, la velocidad de transición es la velocidad mínima especificada de ambos elementos de la trayectoria. Como regla general, el comando de desplazamiento es responsable de una interpolación de la posición de destino del último comando de recorrido a la posición de destino, que fue especificada por el comando de recorrido actual, que debe ejecutarse. El primer comando de desplazamiento comienza en la posición que se definió en el decodificador o editor CNC. Si esta posición no está definida, entonces el punto de partida es X = 0, Y = 0, Z = 0. " }, 
{ "title" : "Comandos de viaje y elementos de ruta correspondientes ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_48e0dea1edfe7b9ec0a8646321fb969d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Fundamentos de DIN 66025 \/ Comandos de viaje y elementos de ruta correspondientes ", 
"snippet" : "Comando de viaje Descripción Elemento de ruta G0 Movimiento directo sin operación de herramienta; movimiento lineal PosicionamientoG1 Movimiento lineal con operación de herramienta Movimiento linealG2 Segmento circular o círculo, en el sentido de las agujas del reloj ArcoG3 Segmento circular o círcu...", 
"body" : "Comando de viaje Descripción Elemento de ruta G0 Movimiento directo sin operación de herramienta; movimiento lineal PosicionamientoG1 Movimiento lineal con operación de herramienta Movimiento linealG2 Segmento circular o círculo, en el sentido de las agujas del reloj ArcoG3 Segmento circular o círculo, en sentido antihorario ArcoG4 Tiempo de permanencia Tiempo de permanenciaG5 Punto de una spline cardinal 2D RanuraG6 Parábola ParábolaG8 Arco elíptico o elipse, en el sentido de las agujas del reloj ElipseG9 Arco elíptico o elipse, en sentido antihorario ElipseG10 Punto de una spline cardinal 3D RanuraG15 Cambiar a 2D Modo 3DG16 Cambie a 3D activando el modo 3D con el vector normal I \/ J \/ K al avion Modo 3DG17 Cambie a 3D activando el modo 3D en X \/ Y plano Modo 3DG18 Cambie a 3D activando el modo 3D en Z \/ X plano Modo 3DG19 Cambie a 3D activando el modo 3D en Y \/ Z plano Modo 3DG20 Salto condicional a L , si K <> 0 SaltoG31 Eliminar la distancia restante con la parada de decodificación Función de sondeo (distancia restante libre)G36 Escribir valor D a variable O Cambiar los valores de las variablesG37 Variable de incremento O por valor D Cambiar los valores de las variablesG38 Activar la función de preprocesamiento extendida Activación de la función de preprocesamiento ampliadaG39 Desactivar la función de preprocesamiento extendida Activación de la función de preprocesamiento ampliadaG40 Compensación de radio de fin de herramienta PreprocesamientoG41 Inicio de la compensación del radio de la herramienta, a la izquierda del sentido de la marcha PreprocesamientoG42 Inicio de la compensación del radio de la herramienta, a la derecha del sentido de la marcha PreprocesamientoG43 Inicia la corrección de la longitud de la herramienta PreprocesamientoG50 Redondeo\/suavizado del final de la esquina PreprocesamientoG51 Inicio del alisado de esquinas PreprocesamientoG52 Inicio del redondeo de esquinas PreprocesamientoG53 Finaliza la transformación de coordenadas y restablece el sistema de coordenadas del decodificador a la posición original (= sistema de coordenadas de la máquina) Cambiar, rotar y escalar el sistema de coordenadasG54 Transformación absoluta de las coordenadas Cambiar, rotar y escalar el sistema de coordenadasG55 Transformación relativa de las coordenadas Cambiar, rotar y escalar el sistema de coordenadasG56 Establece la orientación, posición y escala actuales del DCS se establece como punto de referencia Cambiar, rotar y escalar el sistema de coordenadasG60 Supresión de fin de bucle PreprocesamientoG61 Inicio de la supresión de bucle PreprocesamientoG70 Fin del suavizado de ejes adicionales Ver: SMC_SmoothAddAxes PreprocesamientoG71 Inicio del suavizado de ejes adicionales Ver: SMC_SmoothAddAxes PreprocesamientoG75 Sincronización de tiempos con el interpolador Sincronización de tiempo con interpoladorG90 Las coordenadas ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) se interpretan como valores absolutos. (Esta es la configuración predeterminada). ModosG91 Las coordenadas ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) se interpretan como valores relativos a la posición actual. ModosG92 Posicionamiento por salto PosicionamientoG98 Los puntos medios del eje ( I \/ J \/ K ) se interpretan como valores absolutos. ModosG99 Los puntos medios del eje ( I \/ J \/ K ) se interpretan como valores relativos a la posición inicial. (Esta es la configuración predeterminada). Modos" }, 
{ "title" : "Reconocimiento de palabras en código G ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_591ac87c61b577fcc0a8640e0070747c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Fundamentos de DIN 66025 \/ Reconocimiento de palabras en código G ", 
"snippet" : "A Posición de destino del eje estriado adicional Para una transformación de coordenadas en el sistema de coordenadas del decodificador, la palabra contiene un ángulo. B C D Radio de herramienta para compensación G40 - G42 Distancia entre herramientas para redondear esquinas G50 - G51 Valor variable ...", 
"body" : "A Posición de destino del eje estriado adicional Para una transformación de coordenadas en el sistema de coordenadas del decodificador, la palabra contiene un ángulo. B C D Radio de herramienta para compensación G40 - G42 Distancia entre herramientas para redondear esquinas G50 - G51 Valor variable G36 \/ G37 E Aceleración \/ desaceleración máxima de la ruta en [u \/ s 2 ]. Valor> 0: aceleración; valor <0: desaceleración EF Aceleración \/ desaceleración de trayectoria para G0 movimiento E<axis> Aceleración \/ desaceleración individual (> 0 \/ <0) de la especificada <axis> eje adicional Los ejes adicionales son A , B , C , P , Q , U , V , W , y también Z en modo 2D. Si se usa este código G, entonces el bloque de procesamiento de ruta SMC_ExtendedVelocityChecks debe utilizarse para restringir la velocidad. F Velocidad (en [u \/ seg]): \"Feed\" FF Velocidad para G0 movimientos F<axis> Velocidad individual del eje adicional <axis> especificado Los ejes adicionales son A , B , C , P , Q , U , V , W , y también Z en modo 2D. Si se usa este código G, entonces el bloque de procesamiento de ruta SMC_ExtendedVelocityChecks debe utilizarse para restringir la velocidad. G Condición de la ruta H Punto de conmutación (función H) Positivo: encender Negativo: apagar I Coordenada X del punto medio del círculo \/ elipse para G02 \/ G03 \/ G08 \/ G09 Coordenada X del vértice de la parábola para G06 Vector normal (X) para la función de plano 3D Parámetros para activar funciones de preprocesamiento extendidas para G38 \/ G39 Escalado en la dirección X para G54 \/ G55 \/ G56 Corrección de herramienta en la dirección X para G43 J Coordenada Y del punto medio del círculo \/ elipse para G02 \/ G03 \/ G08 \/ G09 Coordenada Y del vértice de la parábola para G06 Vector normal (Y) para la función de plano 3D Parámetros para activar funciones de preprocesamiento extendidas para G38 \/ G39 Escalado en la dirección Y para G54 \/ G55 \/ G56 Corrección de herramienta en la dirección Y para G43 K Dirección del eje de la elipse primario; matemáticamente: 0 ° = O , 90 ° = N etc. Condición de salto para G20 Valor del parámetro dT1 para la función M Coordenada Z del punto medio del círculo para G02 \/ G03 en modo 3D Vector normal (Z) para la función de plano 3D Parámetros para activar funciones de preprocesamiento extendidas para G38 \/ G39 Escalado en la dirección Z para G54 \/ G55 \/ G56 Corrección de herramienta en la dirección Z para G43 L Posición de conmutación absoluta para la función H, medida desde el inicio del elemento de ruta (si la posición es > 0) o medida desde el final del elemento de ruta (si la posición es < 0). Saltar objetivo para G20 Valor del parámetro dT2 para la función M Número del eje adicional para G70 y G71 M Opción adicional para maquinaria; también función M O Posición relativa del punto de conmutación con rango de valores [0..1] para función H Valor variable G36 \/ G37 . Estructura de datos para los parámetros de una función M P Posición de destino del eje lineal adicional P P<axis><period> Configuración de los ejes de módulo Si Period = 0 se aplica (ejemplo: PA0 ), entonces el comportamiento del eje es lineal. PROBE Activa la función de sondeo (despeja la distancia restante) para el movimiento Q Posición de destino del eje lineal adicional Q R Alternativa de radio de círculo a I, J con G02 \/ G03 Relación de longitud del eje elíptico secundario \/ primario en el rango de valores de [0..1] con G08 \/ G09 S Perfil en S para ejes lineales Positivo: encender Negativo: apagar Eje 3 : Z, si Z está en modo 2D 7 : PAG 8 : Q 9 : U 10 : V 11 : W T Parámetro específico del comando U Posición de destino del eje lineal adicional U V Posición de destino del eje lineal adicional V W Posición de destino del eje lineal adicional W X Coordenada X de la posición de destino Y Coordenada Y de la posición de destino Z Coordenada Z de la posición de destino " }, 
{ "title" : "Modo 3D ", 
"url" : "_sm_cnc_din66025_3dmode.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Modo 3D ", 
"snippet" : "Código G : G15 , G16 , G17 , G18 , G19 Código G Descripción G15 Cambia al modo 2D. Válido para todos los demás elementos G16 Activa la función de plano 3D en el plano normal con vector normal I \/ J \/ K y cambia al modo 3D Válido para todos los demás elementos G17 Activa la función de plano 3D en el ...", 
"body" : "Código G : G15 , G16 , G17 , G18 , G19 Código G Descripción G15 Cambia al modo 2D. Válido para todos los demás elementos G16 Activa la función de plano 3D en el plano normal con vector normal I \/ J \/ K y cambia al modo 3D Válido para todos los demás elementos G17 Activa la función de plano 3D en el plano X \/ Y y cambia al modo 3D Válido para todos los demás elementos G18 Activa la función de plano 3D en el plano X \/ Z. Cambia al modo 3D Válido para todos los demás elementos G19 Activa la función de plano 3D en el plano Y \/ Z. Cambia al modo 3D Válido para todos los demás elementos Los elementos de ruta tridimensionales se utilizan en modo 3D. En el espacio 3D, puede establecer puntos y conectarse con splines 3D. También puede insertar arcos en cualquier plano espacial. A diferencia de los elementos de trayectoria 2.5D que usan solo coordenadas X \/ Y, la velocidad y aceleración de la trayectoria se refieren al movimiento en las coordenadas X \/ Y \/ Z. El eje Z se trata del mismo modo que el eje X y el eje Y. Por lo tanto, cada movimiento se puede implementar en la dirección Z. Modo 3D El modo no admite elipses, parábolas y splines 2D. Se emite un mensaje de error. SMC_CheckVelocities comprueba el componente Z SMC_ToolCorr y SMC_AvoidLoop generar errores Diferencias principales entre 2.5D y 3D Diferencias principales entre 2.5D y 3D Velocidad y aceleración (F \/ E): En 3D: define la velocidad y la aceleración del camino. En 2.5D: Define la velocidad y aceleración de la proyección de la trayectoria en el plano X \/ Y. Estrías 3D: con un componente Z suavizado y sin tirones (G10) 2.5D: En dirección Z no suavizada (G5) Arco 3D: Puede definirse en todos los planos posibles del espacio (G2 \/ G3 con G16 \/ G17 \/ G18 \/ G19) 2.5D: restringido al plano X \/ Y (G2 \/ G3) Ejemplo Comparación de velocidad de 3D y 2.5D N0 G1 X1 Z100 F1 3D requiere el movimiento durante aproximadamente 100 segundos, porque la longitud del objeto contiene el componente Z. Longitud = (1 2 + 100 2 ) 1\/2 A una velocidad de 1, se requieren aproximadamente 100 segundos. La velocidad del componente Z es aproximadamente 1. En 2.5D, el movimiento requiere aproximadamente 1 segundo para el cálculo o la longitud = 1. La velocidad en la dirección Z es aproximadamente 100. " }, 
{ "title" : "Activación de la función de preprocesamiento ampliada ", 
"url" : "_sm_cnc_din66025_activating_extended_preprocessor_functions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Activación de la función de preprocesamiento ampliada ", 
"snippet" : "Código G : G38 , G39 Función : Estos comandos activan y desactivan la función de preprocesamiento ampliada. Sintaxis G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> G39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> Palabra de código G Descripción <bit> Valor entre 0 y 31. La asignación...", 
"body" : "Código G : G38 , G39 Función : Estos comandos activan y desactivan la función de preprocesamiento ampliada. Sintaxis G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value>\nG39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> Palabra de código G Descripción <bit> Valor entre 0 y 31. La asignación de bits a funciones se deja al desarrollador. Algunos bloques de funciones, como SMC_SmoothMerge o SMC_SmoothBSpline , tiene una entrada wFeatureBit (valor inicial 0) que define el bit a utilizar. El bit se guarda en la variable SMC_GeoInfo.dwFeatureFlags . <Param1Value> Algún valor. Los valores se guardan en la matriz. SMC_GeoInfo.aAdditionalParams : ARRAY[0..MAX_ADDITIONAL_PARAMS-1] OF LREAL . <Param1Value> <Param1Value> " }, 
{ "title" : "Cambiar, rotar y escalar el sistema de coordenadas ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Cambiar, rotar y escalar el sistema de coordenadas ", 
"snippet" : "Código G : G53 , G54 , G55 , G56 Función : Los comandos del código G G54 , G55 , y G56 desplazar, rotar y escalar el sistema de coordenadas del decodificador que utiliza internamente el bloque de funciones del intérprete SMC_NCInterpreter . Las transformaciones de coordenadas se calculan para todos ...", 
"body" : "Código G : G53 , G54 , G55 , G56 Función : Los comandos del código G G54 , G55 , y G56 desplazar, rotar y escalar el sistema de coordenadas del decodificador que utiliza internamente el bloque de funciones del intérprete SMC_NCInterpreter . Las transformaciones de coordenadas se calculan para todos los elementos de la ruta durante la ejecución del SMC_NCInterpreter instancia de bloque de funciones. El comando del código G G53 restablece el sistema de coordenadas del decodificador a la posición, orientación y escala originales (correspondiente al sistema de coordenadas de la máquina). Cambia y gira el sistema de coordenadas del decodificador para reutilizar el código G de los mismos elementos de la ruta que solo se diferencian por la posición, la orientación o la escala. Girar y escalar el sistema de coordenadas del decodificador solo funciona en el intérprete en línea (no en el editor CNC). " }, 
{ "title" : "Sistemas de coordenadas MCS y DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Cambiar, rotar y escalar el sistema de coordenadas \/ Sistemas de coordenadas MCS y DCS ", 
"snippet" : "El sistema de coordenadas de la máquina (MCS) está definido por la cinemática aplicada que determina su posición y orientación. El sistema de coordenadas del decodificador (DCS) es gestionado por el intérprete ( SMC_NCInterpreter instancia del bloque de funciones). Toda la información de coordenadas...", 
"body" : "El sistema de coordenadas de la máquina (MCS) está definido por la cinemática aplicada que determina su posición y orientación. El sistema de coordenadas del decodificador (DCS) es gestionado por el intérprete ( SMC_NCInterpreter instancia del bloque de funciones). Toda la información de coordenadas para los comandos de movimiento se interpreta en este sistema de coordenadas. Esto afecta a la posición objetivo de un movimiento ( X\/Y\/Z ), así como un punto medio de arco ( I\/J\/K ) o un plano que se establece con G15\/G16\/G17\/G18\/G19 . El DCS está programado con los comandos G53\/G54\/G55\/G56 . Puede rotar, desplazar y escalar el DCS con respecto al sistema de coordenadas de la máquina y, por lo tanto, adaptar la posición, la orientación y la escala en el archivo de código G tantas veces como desee. Los elementos de la ruta se programan en relación con el DCS. Por ejemplo, esto puede ser una ventaja para los mismos elementos de trayectoria en diferentes posiciones y orientaciones. La siguiente imagen muestra un cambio (izquierda) y un cambio con rotación (derecha). El intérprete obtiene la información de su eOriConv entrada sobre si A\/B\/C se tratan como ejes adicionales o como valores de orientación. Las coordenadas de los elementos de la ruta se transforman en consecuencia. Por lo tanto, el bloque de funciones del intérprete gestiona un sistema de coordenadas activo. Inicialmente, si el DCS no se desplaza, ni se rota, ni se escala, entonces el DCS corresponde al MCS. Las posiciones inicial y objetivo y el plano de los arcos se especifican en los objetos GeoInfo generados siempre en relación con el MCS. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES No se especifica ninguna convención de orientación. El contenido de la palabra de código G A \/ B \/ C se interpreta como un valor de desplazamiento. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYZ La convención de orientación es la convención Y estándar (Z, Y ', Z' '). El contenido de la palabra de código G A \/ B \/ C se interpreta como un valor de ángulo. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYX La convención de orientación es la convención de guiñada-cabeceo-balanceo (Z, Y ', X' '). El contenido de la palabra de código G A \/ B \/ C se interpreta como un valor de ángulo. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.XYZ La convención de orientación es la convención XYZ (X, Y ', Z' '). El contenido de la palabra de código G A \/ B \/ C se interpreta como un valor de ángulo. " }, 
{ "title" : "Comandos G53, G54, G55, G56 ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Cambiar, rotar y escalar el sistema de coordenadas \/ Comandos G53, G54, G55, G56 ", 
"snippet" : "Código G Descripción G53 Restablece el sistema de coordenadas del decodificador. El DCS se restablece a la misma posición y orientación que el MCS. G54 Absoluto desplazamiento, rotación y escalado del DCS Los valores se refieren al MCS. Si una convención de orientación es no especificado ( SMC_NCInt...", 
"body" : "Código G Descripción G53 Restablece el sistema de coordenadas del decodificador. El DCS se restablece a la misma posición y orientación que el MCS. G54 Absoluto desplazamiento, rotación y escalado del DCS Los valores se refieren al MCS. Si una convención de orientación es no especificado ( SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES ), entonces el comando produce un desplazamiento solo a lo largo de los ejes X\/Y\/Z\/A\/B\/C y en todos los ejes lineales adicionales P\/Q\/U\/V\/W. Por lo tanto, también se puede programar un desplazamiento a lo largo de los ejes A\/B\/C. Si se especifica una convención de orientación, entonces el comando da como resultado un desplazamiento también a lo largo de los ejes X \/ Y \/ Z y a lo largo de los ejes lineales adicionales P \/ Q \/ U \/ V \/ W. Además, se rotan los ejes de coordenadas. Luego, la convención de orientación proporciona el orden de rotación y las palabras de código G A \/ B \/ C dan los ángulos de rotación en grados. Nota: El decodificador puede realizar rotaciones direccionales en un rango de -180° a +180°. Si especifica un ángulo fuera de este rango, el decodificador convierte el valor para que esté dentro del rango ejecutable. Sólo entonces el decodificador gira los ejes de coordenadas. Por ejemplo, se realiza una rotación de -10° para un ángulo de 350°. G55 Relativo Cambio, rotación y escalado del DCS a su posición y orientación actuales. Por lo tanto, los valores son relativos al origen del DCS actual y se interpretan en la dirección de los ejes de coordenadas actuales del DCS. Se agrega un cambio \/ rotación adicional con respecto al sistema de coordenadas de la máquina. Si una convención de orientación es no especificado, el comando da como resultado un desplazamiento relativo solo a lo largo de los ejes X \/ Y \/ Z \/ A \/ B \/ C y en todos los ejes lineales adicionales P \/ Q \/ U \/ V \/ W. Por lo tanto, también se puede programar un cambio a lo largo de los ejes A \/ B \/ C. Si se especifica una convención de orientación, entonces el comando da como resultado un desplazamiento relativo también a lo largo de los ejes X \/ Y \/ Z y a lo largo de los ejes lineales adicionales P \/ Q \/ U \/ V \/ W. Pero sobre todo, los ejes de coordenadas se giran más. Entonces, la convención de orientación proporciona el orden de rotación y las palabras de código G A \/ B \/ C dan los ángulos de rotación. G56 Restablece el punto de referencia del sistema de coordenadas del decodificador. La orientación, posición y escala actuales del DCS se establecen como referencia. Sugerencia: Si el punto de referencia es X0 Y0 Z0 A0 B0 C0, entonces el DCS se establece de manera idéntica a la posición y orientación actuales. Sintaxis G53\nG54 X Y Z A B C I J K P Q U V W\nG55 X Y Z A B C I J K P Q U V W\nG56 X Y Z A B C I J K P Q U V W Palabra de código G Descripción X Y Z Valor alrededor del cual se desplaza el sistema de coordenadas del decodificador A B C Si la entrada es eOriConf = SMC_ORI_CONVENTION.ADDAXES en SMC_NCInterpreter , se indica en unidades el valor de hasta qué punto se desplaza el respectivo eje adicional. Por lo tanto, el parámetro define el desplazamiento para cada eje del sistema de coordenadas del decodificador con respecto al sistema de coordenadas de la máquina. Si el eOriConf la entrada es SMC_ORI_CONVENTION.ZYZ , SMC_ORI_CONVENTION.ZYX , o SMC_ORI_CONVENTION.XYZ en SMC_NCInterpreter , entonces se proporciona una convención de orientación. En este caso, los valores dados aquí se interpretan automáticamente como grados y determinan cuánto giran los ejes del sistema de coordenadas del decodificador con respecto al sistema de coordenadas de la máquina. Por lo tanto, la rotación de los ejes principales se define según la convención de orientación. Nota: Al programar la rotación del DCS, los ángulos de rotación siempre deben especificarse en A\/B\/C para los tres ejes. Un ángulo de rotación faltante provoca un error al decodificar ( SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ). I Escalando en dirección X Ejemplo: 10 para extender por un factor de 10 J Escalando en dirección Y Ejemplo: 10 para extender por un factor de 10 K Escalando en dirección Z Ejemplo: 10 para extender por un factor de 10 P Q U V W Valor alrededor del cual se desplaza el eje adicional del sistema de coordenadas del decodificador " }, 
{ "title" : "Cambiando el DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Cambiar, rotar y escalar el sistema de coordenadas \/ Cambiando el DCS ", 
"snippet" : "Selecciona el eOriConv entrada de la SMC_NCInterpreter instancia de bloque de funciones para SMC_ORI_CONVENTION.ADDAXES . El DCS se puede cambiar. No es posible una rotación. Programe la ruta del CNC. Primero, especifique el cambio de posición del DCS. Ejemplo: G54 X10 Y10 Z10 A30 B30 C30 Los ejes X...", 
"body" : "Selecciona el eOriConv entrada de la SMC_NCInterpreter instancia de bloque de funciones para SMC_ORI_CONVENTION.ADDAXES . El DCS se puede cambiar. No es posible una rotación. Programe la ruta del CNC. Primero, especifique el cambio de posición del DCS. Ejemplo: G54 X10 Y10 Z10 A30 B30 C30 Los ejes X \/ Y \/ Z \/ A \/ B \/ C del DCS están desplazados. Ejemplo Desplazamiento absoluto N10 G0 X100 Y100 F100\nN20 G54 X50 Y50 (Offset auf 50\/50)\nN30 G1 X0 Y0 (Fahrt nach 50\/50)\nN40 G54 X100 Y100 (Offset auf 100\/100)\nN50 G1 X0 Y0 (Fahrt nach 100\/100)\nN60 G53 (Offset auf 0)\nN70 G1 X0 Y0 (Fahrt nach 0\/0) Posición actual como compensación N0 G0 X100 Y100 F100\nN10 G56 X0 Y0 (Aktuelle Position 100\/100 wird 0\/0)\nN20 G1 X10 (Fahrt nach 110\/100)\nN30 G56 X20 Y0 (Aktuelle Position 110\/100 wird 20\/0)\nN40 G1 X0 (Fahrt nach 90\/100) Adaptar el desplazamiento por valor N0 G54 X10 Y20 Z30 U7 (Offset: X=10, Y=20, Z=30, U=7)\nN10 G55 X-10 U7 (Offset: X=0, Y=20, Z=30, U=14) Mismos elementos de ruta en dos posiciones N05 G17\nN10 G54 X10 Y10 Z10\nN20 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN30 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN040 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097\nN50 G55 X10 Y10 Z10\nN60 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN70 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN80 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097 " }, 
{ "title" : "Cambio y rotación del DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_df6926f62eedd311c0a8646378b457e7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Cambiar, rotar y escalar el sistema de coordenadas \/ Cambio y rotación del DCS ", 
"snippet" : "Selecciona el eOriConv entrada de la SMC_NCInterpreter instancia de bloque de funciones según la convención de orientación deseada (por ejemplo, SMC_ORI_CONVENTION.ZYZ ). Se programan la convención de orientación y el orden de rotación de los ejes X \/ Y \/ Z del DCS. Para SMC_ORI_CONVENTION.ZYZ , el ...", 
"body" : "Selecciona el eOriConv entrada de la SMC_NCInterpreter instancia de bloque de funciones según la convención de orientación deseada (por ejemplo, SMC_ORI_CONVENTION.ZYZ ). Se programan la convención de orientación y el orden de rotación de los ejes X \/ Y \/ Z del DCS. Para SMC_ORI_CONVENTION.ZYZ , el orden de rotación es ZY'Z '' y corresponde a la convención Y estándar. Nota: siempre que la entrada eOriConv contiene una convención de orientación y no el valor SMC_ORI_CONVENTION.ADDAXES , los valores de las palabras A\/B\/C se interpretan como valores de ángulo para la rotación de los comandos del código G G54\/G55\/G56 . Programe la ruta del CNC. Primero, especifique el cambio de posición y la rotación del DCS. Ejemplo: G54 X10 Y10 Z10 A30 B30 C30 Los valores de las palabras A\/B\/C proporcione la dirección de rotación y el ángulo en grados. El sistema de coordenadas se rota en consecuencia. Los valores de las palabras X\/Y\/Z definir el turno. Nota: Al programar la rotación del DCS, los ángulos de rotación siempre deben especificarse en A\/B\/C para los tres ejes. Un ángulo de rotación faltante provoca un error al decodificar ( SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ). Si el eOriConv entrada de la SMC_NCInterpreter la instancia del bloque de funciones contiene el valor SMC_ORI_CONVENTION.ADDAXES , entonces no es posible girar el DCS. Los valores en G54\/G55\/G56 se interpretan como valores adicionales del eje spline. El cambio es posible. Ejemplos de La convención de orientación se definió en los ejemplos como la convención Y estándar ( eOriConv = SMC_ORI_CONVENTION.ZYZ ). En general para G54 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W proporciona un valor absoluto en el MCS. G55 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W proporciona un valor relativo en el DCS. G56 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W proporciona un valor absolutamente nuevo en el DCS. Orientación absoluta con G54 N01 G54 X10 A30 B0 C0 G54 resulta en un cambio y rotación. La posición y la orientación se proporcionan de forma absoluta al MCS. Orientación relativa con G55 N01 G54 X10 A30 B0 C0 (Bezieht sich auf MCS)\nN02 G55 Y10 A0 B30 C0 (Bezieht sich auf das in 01 definierte DCS) G54 da como resultado un desplazamiento de 10 unidades en la dirección X y una rotación de 30 ° alrededor del eje Z absoluto al MCS. En el bloque 02, el DCS se desplaza 10 unidades adicionales en la dirección del eje Y girado y luego se gira 30 ° más alrededor del eje Y girado. Por tanto, la transformación en el bloque 02 es relativa a la transformación en el bloque 01. Referenciación con respecto a la orientación actual con G56 N01 G01 X10 A10 B90 C10 (Orientierung ist A=10°, B=90°, C=10°)\nN02 G56 A0 B0 C0 (DCS wird auf X=10, A=10°, B=90°, C=10° gesetzt) G56 da como resultado que la orientación actual del DCS (programada en el bloque 01 en el ejemplo) se establezca como referencia. Ejemplo: Arco N0 G17\nN0 G54 A0 B90 C0 El plano circular seleccionado se interpreta en relación con el DCS. En el ejemplo, el plano X \/ Y se selecciona con G17 y luego el DCS se gira 90 ° alrededor del eje Y. Entonces, el plano seleccionado en el DCS es el plano X \/ Y como antes. Esto corresponde a la del plano X \/ Z en el MCS. Con G17 , se selecciona el plano X \/ Y. Luego, el DCS se gira 90 °. Esto da como resultado que el plano X \/ Y se active en el DCS como antes. Esto corresponde al plano X \/ Y en el MCS. En modo 2.5D ( G15 ), solo se permite la rotación alrededor del eje Z. La rotación alrededor de otro eje provoca un error que emite el decodificador ( SMC_DEC_DCS_2D_NOT_IN_XY_PLANE ). Por lo tanto, el plano X\/Y del MCS siempre permanece configurado en modo 2,5D. " }, 
{ "title" : "Escalar el sistema de coordenadas ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_52b3763cadb811e79ffc84f8a2d3d270", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Cambiar, rotar y escalar el sistema de coordenadas \/ Escalar el sistema de coordenadas ", 
"snippet" : "Si se programa una rotación después de una escala desigual, puede producirse un recorte. En este caso, el error SMC_DEC_ROTATION_AFFECTS_SCALING no se emite. Deben especificarse los tres factores de escala o ninguno en absoluto. Escala absoluta Sintaxis: G54 I<i> J<j> K<k> Un sistema de coordenadas ...", 
"body" : "Si se programa una rotación después de una escala desigual, puede producirse un recorte. En este caso, el error SMC_DEC_ROTATION_AFFECTS_SCALING no se emite. Deben especificarse los tres factores de escala o ninguno en absoluto. Escala absoluta Sintaxis: G54 I<i> J<j> K<k> Un sistema de coordenadas se puede estirar o comprimir en las tres direcciones espaciales X\/Y\/Z independientemente unos de otros. Puede especificar un factor para cada dirección. Especifique el factor de escala para X en I, Y en J y Z en K. Se extiende un factor de escala> 1. Un factor de escala <1 comprime. Ampliación de 10x: N01 G01 X10\nN02 G54 A90 B0 C0 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 Todos los puntos de destino se extienden 10 veces en la dirección del eje X girado. El siguiente código genera la misma ruta: N01 G01 X10\nN02 G01 X-20 Y100\nN03 G01 X-10 Y50. Si no se especifican ni I ni J ni K, el valor establecido anteriormente permanece sin cambios: N01 G54 I10 J1 K1\nN02 G54 X1\nN03 G01 X10 La misma ruta se logra con el siguiente código: N01 G01 X101 Escala relativa Sintaxis: G55 I<i> J<j> K<k> Se extiende un factor de escala> 1. Un factor de escala <1 comprime. Los factores de escala se multiplican. Ampliación de 100x: N01 G54 I10 J1 K1\nN02 G55 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 El siguiente código da como resultado la misma escala: N01 G55 I100 J1 K1 Escala circular La escala de un arco es válida solo si el elemento sigue siendo un arco (no una elipse) después de la escala. Resultado de rutas válidas: Cuando los tres factores de escala tienen el mismo valor Cuando el plano circular es uno de los planos primarios del DCS y los dos factores de escala correspondientes son los mismos valores " }, 
{ "title" : "Reflejando el sistema de coordenadas ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_adba25b098ef7863c0a8646324d700b4", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Cambiar, rotar y escalar el sistema de coordenadas \/ Reflejando el sistema de coordenadas ", 
"snippet" : "Una escala absoluta con factores de escala negativos en I , J , o K da como resultado la duplicación del sistema de coordenadas actual. Factor de escala negativo G54 A30 B0 C0 I-1 J1 K1...", 
"body" : "Una escala absoluta con factores de escala negativos en I , J , o K da como resultado la duplicación del sistema de coordenadas actual. Factor de escala negativo G54 A30 B0 C0 I-1 J1 K1 " }, 
{ "title" : "Modos ", 
"url" : "_sm_cnc_din66025_modi.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Modos ", 
"snippet" : "Función : Estos comandos determinan si las coordenadas y los puntos medios del eje se interpretan como valores absolutos o coordenadas relativas. Código G Descripción G90 Las coordenadas ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) se interpretan como valores absolutos. (Esta es la configuración pr...", 
"body" : "Función : Estos comandos determinan si las coordenadas y los puntos medios del eje se interpretan como valores absolutos o coordenadas relativas. Código G Descripción G90 Las coordenadas ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) se interpretan como valores absolutos. (Esta es la configuración predeterminada). G91 Las coordenadas ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) se interpretan como valores relativos a la posición actual. G98 Los puntos medios del eje ( I \/ J \/ K ) se interpretan como valores absolutos. G99 Los puntos medios del eje ( I \/ J \/ K ) se interpretan como valores relativos a la posición inicial. (Esta es la configuración predeterminada). Sintaxis G90\nG91\nG98\nG99 Ejemplos de Valor de coordenadas como valor absoluto El interpolador se mueve a 10\/10 y luego a 100\/10. Las coordenadas se interpretan como valores absolutos. N0 G90\nN10 G1 X10 Y10 F100 (Startposition)\nN20 G1 X100 (Nächste Position) Valor de coordenadas como valor relativo El interpolador se mueve a 10\/10 y luego a 110\/10. Las coordenadas se interpretan como valores relativos. N0 G91\nN10 G1 X10 Y10 F100\nN20 G1 X100 Valor de coordenadas como valor absoluto en I \/ J \/ K El punto medio del semicírculo está en 150\/0. Las coordenadas se interpretan como valores absolutos. N00 G98\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I150 J0 F100 Valor de coordenadas como valor relativo en I \/ J \/ K El punto medio del semicírculo está en 150\/0. Las coordenadas se interpretan como valores relativos. N00 G99\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I50 J0 F100 Para más información, ver: Configuración de ejes adicionales individuales como ejes de módulo (PA \/ PB \/…)" }, 
{ "title" : "Tiempo de permanencia ", 
"url" : "_sm_cnc_din66025_delay.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Tiempo de permanencia ", 
"snippet" : "Código G : G4 Función : El comando hace que el interpolador permanezca en la posición actual durante un tiempo específico. Ejemplo Tiempo de permanencia N0 G4 T1 El interpolador se detiene durante un segundo....", 
"body" : "Código G : G4 Función : El comando hace que el interpolador permanezca en la posición actual durante un tiempo específico. Ejemplo Tiempo de permanencia N0 G4 T1 El interpolador se detiene durante un segundo. " }, 
{ "title" : "Punto de conmutación (función H) ", 
"url" : "_sm_cnc_din66025_hfunction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Punto de conmutación (función H) ", 
"snippet" : "Función : La función de punto de conmutación o la función H activa conmutadores binarios dependientes de la ruta. Un número máximo de tres puntos de conmutación ( MAX_SWITCHES ) se puede procesar para cada elemento de ruta. Sintaxis [G-Befehl] H O\/L Primero, se define el número de punto de conmutaci...", 
"body" : "Función : La función de punto de conmutación o la función H activa conmutadores binarios dependientes de la ruta. Un número máximo de tres puntos de conmutación ( MAX_SWITCHES ) se puede procesar para cada elemento de ruta. Sintaxis [G-Befehl] H O\/L Primero, se define el número de punto de conmutación H <número>, y luego la posición del punto de conmutación en el elemento de ruta se define como absoluta (palabra L <posición>) o relativa (palabra O <posición>). Palabra de código G Descripción H {-} <número> Número de la función H Si el número H es positivo, se activa la función de conmutación correspondiente. Si el número H es negativo, la función de conmutación está desactivada. El número H es distinto de cero y está en el rango de -32768 a 32767. O <posición> Posición relativa [0… 1] en el elemento de ruta 0: inicio del elemento 1: Fin L <posición> L> 0: Distancia al punto de inicio L <0: Distancia al punto final Representación grafica En el editor gráfico, puede usar el mouse para mover los puntos de conmutación a lo largo de la ruta. Cuando se mueve el mouse sobre la función H, se muestra una información sobre herramientas con el número H de la función H. Efecto sobre el SMC_Interpolator bloque de funciones El interpolador envía el último número H conmutado al iLastSwitch producción. iLastSwitch es positivo cuando la función H está activada. los dwSwitches la salida es una máscara de bits. Número de bits i indica si la función H (i + 1) está configurada actualmente. Si el número H está entre 1 y 32, el bit correspondiente se establece en el interpolador. dwSwitches producción. Un valor negativo entre -1 y -32 restablece el bit. los iLastSwitch La salida tiene el número del último punto de conmutación de ejecución, incluso si el valor está fuera del rango de -32 a 32. Ejemplos de Desconexión del punto de conmutación 2 con posición relativa al elemento El punto de conmutación 2 se desconecta en la posición X = 40 \/ Y = 25 después del primer cuarto del elemento. N90 G1 X20 Y20\nN100 G1 X100 Y40 H-2 O0.25 Encendido y apagado del punto de conmutación 2 con posición relativa al punto inicial y final El punto de conmutación 2 se conecta en la posición X = 40, que es 20 unidades después del punto de inicio del elemento de trayectoria. El punto de conmutación 2 se desconecta en la posición X = 90, que está 10 unidades antes del punto final. N90 G1 X20\nN100 G1 X100 H2 L20 H-2 L-10 " }, 
{ "title" : "Función M ", 
"url" : "_sm_cnc_din66025_mfunction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Función M ", 
"snippet" : "Función : Las funciones M o funciones adicionales inician acciones durante la interpolación del código G. El interpolador desacelera a la velocidad 0, envía el número de la función M en cola a la salida wM , y espera la confirmación en bAcknM antes de acelerar de nuevo. A diferencia del punto de con...", 
"body" : "Función : Las funciones M o funciones adicionales inician acciones durante la interpolación del código G. El interpolador desacelera a la velocidad 0, envía el número de la función M en cola a la salida wM , y espera la confirmación en bAcknM antes de acelerar de nuevo. A diferencia del punto de conmutación, el programa permanece en la posición actual hasta que se confirma la función M configurando la entrada en el interpolador. Si SMC_PreAcknowledgeM se ejecuta, entonces el bloque de función confirma la función M anticipadamente. Si el bloque de funciones se ejecuta a tiempo, el interpolador no se detiene y el programa continúa como si la instrucción M no estuviera presente. Una función M es implementada por la aplicación y no definida por el sistema. Sintaxis M K L O Palabra de código G Descripción M Número de la función M, M> 0 Nota: Los números 65533–65535 están reservados para funciones internas. K Parámetro numérico ( LREAL ) L Parámetro numérico ( LREAL ) O Referencias con O $ var $ una variable de tipo SMC_M_PARAMETERS que contiene otros parámetros. En la aplicación, los valores de los parámetros de las variables se leen en tiempo de ejecución mediante la función SMC_GetMParameters . Además, todos los parámetros se evalúan en el momento de la decodificación y se guardan en la estructura de datos. SMC_GEOINFO del búfer SMC_OUTQUEUE . Como regla general, esto ocurre en un momento antes de ejecutar la función M en el interpolador. Para que la variable pueda ser encontrada por el bloque de función utilizado (por ejemplo SMC_ReadNCFile2 ) durante la decodificación, debe agregarse a su SMC_VARLIST con el tipo SMC_VARTYPE.SMC_TYPE_USERDEF . Ejemplos de M con parámetro Se inicia la función M 10. Para la ejecución del programa de N90, el sistema espera hasta que la confirmación esté disponible. N90 M10 K100.7 M con parámetro adicional Se inicia la función M 10. La estructura de datos definida por el usuario g_myMParams (tipo de datos SMC_M_PARAMETER ) se hace referencia con O $ var $ . g_myMParams contiene parámetros adicionales. Los valores de K, L y los parámetros de g_myMParams se puede leer en el momento de la parada de trayectoria de la función M. Se hace llamando a una instancia del bloque de funciones. SMC_GetMParameters . N150 M13 O$g_myMParams$ " }, 
{ "title" : "Sincronización de tiempo con interpolador ", 
"url" : "_sm_cnc_din66025_time_synchronisation_with_interpolator.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Sincronización de tiempo con interpolador ", 
"snippet" : "Código G : G75 Función : El comando evita que el bloque de funciones del decodificador procese el código G hasta que el interpolador haya recorrido todos los objetos anteriores. Cuando el interpolador alcanza G75 , todas las colas están vacías y el NCDecoder y todos los bloques de funciones de prepr...", 
"body" : "Código G : G75 Función : El comando evita que el bloque de funciones del decodificador procese el código G hasta que el interpolador haya recorrido todos los objetos anteriores. Cuando el interpolador alcanza G75 , todas las colas están vacías y el NCDecoder y todos los bloques de funciones de preprocesamiento continúan ejecutándose. Esta función es útil para usar variables. El decodificador reemplaza las variables cuando se procesa la línea correspondiente. Sin embargo, la ejecución por parte del interpolador ocurre después de un tiempo especificado según el mecanismo de cola. Puedes usar G75 para esperar y sincronizar la evaluación de las variables y el posterior procesamiento por parte del interpolador. Sintaxis G75 Ejemplo N10 G1 X100\nN20 G75\nN30 G1 Y$g_y$ La variable g_y está disponible con el elemento G1 y no se detecta de antemano. Si G75 no está insertado, entonces el NCDecoder procesa la línea 30 inmediatamente antes de que se detecte el valor. G75 no tiene ningún efecto sobre el editor CNC o las rutas que genera el editor CNC como SMC_OutQueue . " }, 
{ "title" : "Salto ", 
"url" : "_sm_cnc_din66025_jump.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Salto ", 
"snippet" : "Código G : G20 Función : El comando ejecuta un salto condicional. Sintaxis G20 L K Palabra de código G Descripción L Objetivo de salto: Número de línea definido (ejemplo: L20 ) Saltar etiqueta El salto se define mediante un signo de interrogación y un índice (ejemplo: L?4 ). El comando para el objet...", 
"body" : "Código G : G20 Función : El comando ejecuta un salto condicional. Sintaxis G20 L K Palabra de código G Descripción L Objetivo de salto: Número de línea definido (ejemplo: L20 ) Saltar etiqueta El salto se define mediante un signo de interrogación y un índice (ejemplo: L?4 ). El comando para el objetivo del salto en sí se identifica con un signo de exclamación y el índice correspondiente (ejemplo: L!4 ). El objetivo de salto se puede adjuntar a cualquier comando de código G. Este salto se utiliza para programas de CNC generados automáticamente cuando se desconoce la línea objetivo. Los saltos con objetivos desconocidos para saltar etiquetas funcionan solo en el decodificador en línea (no en el editor CNC). Requisito: La línea con la etiqueta de salto debe ubicarse después de la línea con el comando de salto. \"Saltar hacia atrás\" no es posible. Si la \"línea de destino\" no está definida, los comandos que siguen al comando de salto no se ejecutan. K Condición Si K <> 0, entonces se ejecuta el salto. Si K no está definido, se utiliza una variable decodificadora interna. El valor de la variable del decodificador interno se puede definir con el Cambiar los valores de las variables comando. El valor predeterminado de esta variable interna es -1 . Ejemplo: ejecutar salto hasta contador interno = 0 Diez líneas están unidas por el modo relativo. Esto da como resultado un movimiento de línea a 100\/100. N00 G36 D10 (set counter to 10)\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G37 D-1 (decrement counter)\nN40 G20 L20 (jump, if counter != 0) Ejemplo: evaluar la condición de salto en el momento de la decodificación Requisito: el comportamiento de la variable bvar está programado en la aplicación. Si el eje X excede la posición 15, entonces bvar FALSE Está establecido. ( bVar se establece inicialmente en TRUE .) En el primer ciclo del programa, la posición X es 10 y el programa salta a la línea 20. El bucle se ejecuta continuamente porque la evaluación de la condición tiene lugar en el momento de la decodificación y el interpolador aún no se inició o está ocupado con el procesamiento. de objetos al comienzo del búfer. Esta condición se cumple y el decodificador salta del bucle solo después de que se generen suficientes objetos para que el búfer esté lleno y el interpolador comience a procesar. En la segunda ejecución, el eje X aún no está en la posición 20. La condición no se cumple y bVar no estaba configurado para FALSE en el código IEC. N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G20 L20 K$bvar$ (jump, if counter != 0) Ejemplo: insertar sincronización de tiempo G75 ejecuta una sincronización de tiempo del interpolador. G75 pausa el procesamiento del decodificador hasta que el interpolador y la mecánica alcanzan la posición respectiva. N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN25 G75\nN30 G20 L20 K$x$ (jump, if counter != 0) Para más información, ver: Sincronización de tiempo con interpoladorEjemplo: saltar a la etiqueta de salto Nota: Saltos a etiquetas de salto funcionan solo en el decodificador en línea (no en el editor CNC). N0 G16 F100 E100 E-100\nN10 G20 L?4 \/\/unconditional jump to the unknown target with index 4\nN15 G20 L60\nN20 G1 X1\nN30 G1 X1 L!5 \/\/resolution unknown jump target with index 5\nN40 G1 Z1 L!4 \/\/resolution unknown jump target with index 4\nN50 G20 L15\nN55 G1 Y1\nN60 G0 X0 Y0 Z0 " }, 
{ "title" : "Arco ", 
"url" : "_sm_cnc_din66025_arc.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Arco ", 
"snippet" : "Código G : G2 , G3 Función : El comando interpola un arco desde la posición actual a lo largo de una trayectoria circular hasta la posición de destino. G2 se mueve en el sentido de las agujas del reloj y G3 se mueve en sentido antihorario. El arco se define de la siguiente manera: Método de radio Co...", 
"body" : "Código G : G2 , G3 Función : El comando interpola un arco desde la posición actual a lo largo de una trayectoria circular hasta la posición de destino. G2 se mueve en el sentido de las agujas del reloj y G3 se mueve en sentido antihorario. El arco se define de la siguiente manera: Método de radio Coordenada objetivo + radio: Las coordenadas objetivo se definen en X \/ Y \/ Z. La curva está definida por el radio R. Método de punto medio Coordenada objetivo + coordenada del punto medio: Las coordenadas objetivo se definen en X \/ Y \/ Z. La curva está definida por la coordenada del punto medio I \/ J \/ K. La coordenada del punto medio se encuentra en las bisectrices perpendiculares de los puntos inicial y final. Si este no es el caso, la coordenada del punto medio se corrige automáticamente. La desviación no debe ser superior al 10%. Método de ángulo de apertura Ángulo de apertura + coordenada del punto medio: Ángulo de apertura definido en T y coordenadas del punto medio en I \/ J \/ K. La posición de destino se calcula automáticamente. Los parámetros inconsistentes hacen que se recorra una línea en lugar de un círculo. Ejemplos: si el radio es inferior a la mitad de la distancia entre el inicio y el objetivo, la desviación no se puede corregir. Este también es el caso si el punto medio definido a la posición inicial y final tiene una distancia diferente. Sintaxis G2 X Y Z R A B C P Q U V W F E H L\/O D S\nG2 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG2 I J K T A B C P Q U V W F E H L\/O D S\nG3 X Y Z R A B C P Q U V W F E H L\/O D S\nG3 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG3 I J K T A B C P Q U V W F E H L\/O D S Palabra de código G Descripción X Y Z Posiciones de destino de los ejes cartesianos R Radio del círculo I J K Coordenadas del punto medio del círculo T Ángulo de apertura (en grados) A B C P Q U V W Posiciones de destino de los ejes adicionales F E Velocidad de trayectoria, aceleración \/ desaceleración de trayectoria H L\/O Punto de conmutación D Radio de herramienta S Perfil S Representación grafica : Un arco está representado por puntos finales negros. Los puntos finales se pueden mover cuando selecciona el elemento. Arco en modo 3D En modo 3D, el sistema define los arcos por el plano de interpolación que se define mediante G15-G19. Ejemplo Un semicírculo en el plano X \/ Z y un semicírculo en el plano X \/ Y N10 G1 X100 Y100\nN15 G18\nN20 G2 X200 R50\nN25 G17\nN30 G3 X100 R50 " }, 
{ "title" : "Método de radio ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_535707857cba3404c0a86463692656db", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Arco \/ Método de radio ", 
"snippet" : "Puede utilizar el método del radio para generar un arco <180 °. El método del radio es válido para dos arcos. Uno es más pequeño que un semicírculo y el otro es más grande que un semicírculo. El sistema siempre usa el arco más pequeño. Ejemplo Semicírculo N10 G1 X100 Y100 F100 N20 G2 X200 Y100 R50 U...", 
"body" : "Puede utilizar el método del radio para generar un arco <180 °. El método del radio es válido para dos arcos. Uno es más pequeño que un semicírculo y el otro es más grande que un semicírculo. El sistema siempre usa el arco más pequeño. Ejemplo Semicírculo N10 G1 X100 Y100 F100\nN20 G2 X200 Y100 R50 Utilice el método del punto medio con I \/ J \/ K para generar un arco con un ángulo de apertura superior a 180 °. El método del radio es único, excepto en el caso de que los puntos inicial y final del círculo sean idénticos. Esto define un círculo nulo o un círculo completo. En este caso, el sistema inserta un círculo completo. " }, 
{ "title" : "Método de punto medio ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_7dc8851b7cba3404c0a864637c8195be", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Arco \/ Método de punto medio ", 
"snippet" : "Si usa el método del punto medio, entonces distingue si las coordenadas I \/ J \/ K son relativas o absolutas. Si I , J , y K no se especifican correctamente, entonces un arco no es posible y el sistema lo reemplaza con una línea. Si es correcto, entonces la distancia entre el punto medio y el punto i...", 
"body" : "Si usa el método del punto medio, entonces distingue si las coordenadas I \/ J \/ K son relativas o absolutas. Si I , J , y K no se especifican correctamente, entonces un arco no es posible y el sistema lo reemplaza con una línea. Si es correcto, entonces la distancia entre el punto medio y el punto inicial o final es idéntica. Ejemplos de Mismo semicírculo que en el método del radio; especificado por medio de un punto medio relativo N10 G1 X100 Y100 F100\nN15 G99\nN20 G2 X200 Y100 I50 J0 Mismo semicírculo que en el método del radio; especificado por medio de un punto medio absoluto N10 G1 X100 Y100 F100\nN15 G98\nN20 G2 X200 Y100 I150 J100 " }, 
{ "title" : "Método de ángulo de apertura ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_955d99e37cba3404c0a864634d5c784c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Arco \/ Método de ángulo de apertura ", 
"snippet" : "Si define el círculo por el ángulo de apertura T, se permite un máximo de tres círculos completos (T ≤ 1080). El método del ángulo de apertura es apropiado para un arco> 180 °. Ejemplos de Mismo semicírculo que en el método del radio; especificado mediante ángulo de apertura N10 G1 X100 Y100 N15 G99...", 
"body" : "Si define el círculo por el ángulo de apertura T, se permite un máximo de tres círculos completos (T ≤ 1080). El método del ángulo de apertura es apropiado para un arco> 180 °. Ejemplos de Mismo semicírculo que en el método del radio; especificado mediante ángulo de apertura N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T180 Hélice (dos círculos completos) N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T720 " }, 
{ "title" : "Elipse ", 
"url" : "_sm_cnc_din66025_ellipse.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Elipse ", 
"snippet" : "Código G : G8 , G9 Función : El comando especifica un arco de elipse a través de las coordenadas de destino X \/ Y, el punto medio de la elipse I \/ J, las direcciones del eje principal de la elipse K y la relación de longitud R entre los ejes primario y secundario. Sintaxis G8 X Y Z R I J K A B C P Q...", 
"body" : "Código G : G8 , G9 Función : El comando especifica un arco de elipse a través de las coordenadas de destino X \/ Y, el punto medio de la elipse I \/ J, las direcciones del eje principal de la elipse K y la relación de longitud R entre los ejes primario y secundario. Sintaxis G8 X Y Z R I J K A B C P Q U V W F E H L\/O D S\nG9 X Y Z R I J K A B C P Q U V W F E H L\/O D S Palabra de código G Descripción X Y Z Posiciones de destino de los ejes cartesianos R Relación de longitud R entre ejes primarios y secundarios. Alcance: 0 < R <= 1 R solo se usa si el arco de la elipse no está definido de forma única por los puntos finales, el punto medio y la pendiente del eje principal. Este es el caso cuando ambos puntos finales están a la misma distancia del eje principal. Entonces, ambos puntos finales deben estar a la misma distancia del eje secundario. De lo contrario, no pasa ninguna elipse por estos puntos y el sistema sustituye la elipse por una línea I J Punto medio K Dirección del eje primario de la elipse (en grados) 0: en la dirección del eje X 90: En la dirección del eje Y -90: en la dirección opuesta al eje Y A B C P Q U V W Posiciones de destino de los ejes adicionales F E Velocidad de trayectoria, aceleración \/ desaceleración de trayectoria H L\/O Punto de conmutación D Radio de herramienta S Perfil S La elipse es un objeto 2.5D. Esto significa que la elipse siempre pertenece al plano X \/ Y. No se admiten elipses en otros planos. Ejemplo N10 G0 X100 Y100 F100\nN15 G98\nN20 G8 X200 Y100 I150 J100 K45 R0.5 " }, 
{ "title" : "Movimiento lineal ", 
"url" : "_sm_cnc_din66025_line.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Movimiento lineal ", 
"snippet" : "Código G : G1 Función : Este comando de posicionamiento ejecuta una interpolación de línea. La interpolación de línea mueve el punto de interpolación desde la posición actual a las coordenadas objetivo definidas en una línea. Todos los ejes llegan allí al mismo tiempo. Las coordenadas de destino (X ...", 
"body" : "Código G : G1 Función : Este comando de posicionamiento ejecuta una interpolación de línea. La interpolación de línea mueve el punto de interpolación desde la posición actual a las coordenadas objetivo definidas en una línea. Todos los ejes llegan allí al mismo tiempo. Las coordenadas de destino (X \/ Y \/ Z) deben definirse para la descripción de las líneas. Además del movimiento en el espacio, puede especificar posiciones de destino para los ejes adicionales A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W que se alcanzan al mismo tiempo con las coordenadas de destino cartesianas. Dos posiciones idénticas consecutivas siempre provocan una parada del movimiento en esta posición. La parada también se produce cuando el camino subsiguiente se conecta de manera constante y se puede recorrer sin detenerse. Sintaxis G1 X Y Z A B C P Q U V W F E H L\/O D S Palabra de código G Descripción X Y Z Posiciones de destino de los ejes cartesianos A B C P Q U V W Posiciones de destino de los ejes adicionales F E Velocidad de trayectoria, aceleración \/ desaceleración de trayectoria H L\/O Punto de conmutación D Radio de herramienta S Perfil S Ejemplos de Interpolación linear La herramienta se coloca en la posición inicial 0\/0\/0 (preestablecida) y luego viaja en línea recta hasta la posición objetivo 1\/2\/3 a la velocidad 1, aceleración 10 y desaceleración 20. Al mismo tiempo, la orientación el eje A se recorre a 180 grados: N010 G01 X1 Y2 Z3 A180 F1 E10 E-20 Posición de salida Posición inicial 50\/50\/50, interpolación lineal de 50\/50\/50 a 64\/30\/0 con avance 100 N000 G92 X50 Y50 Z50 F100\nN010 G01 X64 Y30 Z0 " }, 
{ "title" : "Parábola ", 
"url" : "_sm_cnc_din66025_parabel.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Parábola ", 
"snippet" : "Código G : G6 Función : El comando interpola una parábola que está definida por las coordenadas del punto final X \/ Y \/ Z y el vértice I \/ J. El vértice es el punto donde la tangente del elemento es paralela a la línea de conexión del punto inicial y final. Una parábola es un objeto 2.5D que siempre...", 
"body" : "Código G : G6 Función : El comando interpola una parábola que está definida por las coordenadas del punto final X \/ Y \/ Z y el vértice I \/ J. El vértice es el punto donde la tangente del elemento es paralela a la línea de conexión del punto inicial y final. Una parábola es un objeto 2.5D que siempre está en el plano X \/ Y. No se admiten parábolas en otros planos. Sintaxis G6 X Y Z I J A B C P Q U V W F E H L\/O D S Palabra de código G Descripción X Y Z Posiciones de destino de los ejes cartesianos I J Vértice de la parábola A B C P Q U V W Posiciones de destino de los ejes adicionales F E Velocidad de trayectoria, aceleración \/ desaceleración de trayectoria H L\/O Función H D Radio de herramienta S Perfil S Ejemplo N010 G00 X100 Y200 Z0 F100\nN020 G98\nN030 G06 X-100 Y200 Z00 I0 J0 " }, 
{ "title" : "Posicionamiento ", 
"url" : "_sm_cnc_din66025_positioning.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Posicionamiento ", 
"snippet" : "Código G : G0 , G92 Función : Estos comandos posicionan la herramienta. G0 ordena un posicionamiento rápido en línea recta a la posición definida (normalmente sin operación de herramienta). El G92 establece inmediatamente la posición. El resultado es que también se ejecuta un salto en los ejes. SMC_...", 
"body" : "Código G : G0 , G92 Función : Estos comandos posicionan la herramienta. G0 ordena un posicionamiento rápido en línea recta a la posición definida (normalmente sin operación de herramienta). El G92 establece inmediatamente la posición. El resultado es que también se ejecuta un salto en los ejes. SMC_ControlAxisByPos.bAvoidGaps:=TRUE está establecido, entonces no se ejecuta el salto. En cambio, todos los ejes se desplazan individualmente hasta la posición objetivo en la distancia más corta. El G92 se puede insertar al principio de la ruta para establecer la posición inicial En una serie de comandos G92, el último se ejecuta primero. Se omiten los anteriores. Si se inserta un bloque G1 con coordenadas idénticas, el salto se ejecuta durante un ciclo. Esto es una ventaja si la ruta entre las posiciones de los comandos de salto no es importante, pero la posición especificada debe recorrerse lo más rápido posible. los SMC_ControlAxisByPos* Los bloques de función detectan un salto a los valores especificados, pausan el interpolador e interpolan cada eje individualmente lo más rápido posible. Dos posiciones idénticas consecutivas siempre provocan una parada del movimiento en esta posición. La parada también se produce cuando el camino subsiguiente se conecta de manera constante y se puede recorrer sin detenerse. Para obtener más información, consulte la documentación de la biblioteca sobre Direct Axis Control Sintaxis G0 X Y Z A B C P Q U V W F FF E EF H L\/O S\nG92 X Y Z A B C P Q U V W H L\/O Palabra de código G Descripción X Y Z Posiciones de destino de los ejes cartesianos A B C P Q U V W Posiciones de destino de los ejes adicionales E Aceleración \/ desaceleración de trayectoria EF Aceleración \/ desaceleración de trayectoria solo para movimiento G0. Si se establece EF <> 0, el valor definido en E no se tiene en cuenta para los movimientos G0. F Velocidad de trayectoria FF Velocidad que se usa solo para movimientos G0. Si se establece FF <> 0, el valor definido en F no se tiene en cuenta para los movimientos G0. H L\/O Función H S Perfil S Representación grafica En el editor gráfico, los comandos G0 están representados por una línea verde. Los comandos G92 no se representan directamente. Simplemente mueven el punto de partida del elemento siguiente. Los comandos de posicionamiento solo se pueden insertar en el editor de texto del CNC o en el editor tabular. Se pueden mover en el editor gráfico. Ejemplos de Posicionamiento con interpolación lineal con avance definido N0 G92 X10 Y10 Sets the start position at 10\/10\nN10 G1 X20 F10 Linear interpolation to 20\/10 with feed 10\nN20 G0 Y20 F100 Linear positioning to 20\/20 with feed 100 Diferentes modos de posicionamiento N0 G92 X100 Y100 F100 Sets the position at 100\/100\nN10 G1 X100 Y100 Saves the output of this position for one cycle\nN20 G92 X50 Y100 Sets the position suddenly to 50\/100 Posicionamiento con velocidad de trayectoria definida N1 G0 X1000 Y0 FF1000 EF10000 EF-10000 Positioning with velocity 1000\nN2 G1 Y100 F100 E100 E-100 Interpolating positioning with velocity 100\nN3 G0 X0 Y0 Positioning with velocity 1000\nN4 G0 X1000 FF0 EF0 Positioning with velocity 100 because FF and FE are reset; thus the values in F and E are used. " }, 
{ "title" : "Ranura ", 
"url" : "_sm_cnc_din66025_spline.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Ranura ", 
"snippet" : "Código G : G5 , G10 Función : El comando interpola el elemento de ruta con una spline para que las transiciones del elemento de ruta anterior y al siguiente elemento de ruta se fusionen entre sí sin interrupciones. Al mismo tiempo, el segmento de spline del sistema se calcula de modo que la tangente...", 
"body" : "Código G : G5 , G10 Función : El comando interpola el elemento de ruta con una spline para que las transiciones del elemento de ruta anterior y al siguiente elemento de ruta se fusionen entre sí sin interrupciones. Al mismo tiempo, el segmento de spline del sistema se calcula de modo que la tangente final del elemento de ruta anterior coincida con la tangente inicial de la spline. Del mismo modo, la tangente final de la spline coincide con el elemento de ruta siguiente. Función : El comando crea un segmento spline para la posición dada. Las transiciones desde el elemento de ruta anterior al siguiente elemento de ruta son continuamente posicionales y tangenciales. Sintaxis G5 X Y Z A B C P Q U V W F E H L\/O D S\nG10 X Y Z A B C P Q U V W F E H L\/O D S Palabra de código G Descripción X Y Z Posiciones de destino de los ejes cartesianos A B C P Q U V W Posiciones de destino de los ejes adicionales F E Velocidad de trayectoria, aceleración \/ desaceleración de trayectoria H L\/O Punto de conmutación D Radio de herramienta S Perfil S Se conectan varios segmentos spline consecutivos de la siguiente manera: Iniciar tangente Si existe un elemento de trayectoria con operación de herramienta (ejemplo: G1, G2, G3, G8, G9), la tangente final del elemento de trayectoria se utiliza como tangente inicial para la spline. Si no hay ningún elemento de trayectoria disponible con la operación de la herramienta (p. Ej., G0, G92, M), entonces la línea de conexión entre el punto inicial y el primer punto spline se utiliza como tangente inicial. Tangente en el medio de la spline Los puntos adyacentes están conectados. La tangente del punto es paralela a esta línea de conexión (línea verde). Final tangente Si existe un elemento de trayectoria con operación de herramienta (ejemplo: G1, G2, G3, G8, G9), la tangente inicial del elemento de trayectoria se utiliza como tangente final para la spline. Si no hay ningún elemento de trayectoria disponible con la operación de herramienta (por ejemplo, G0, G92, M), entonces la línea de conexión entre el punto final y el primer punto spline se utiliza como tangente final. Ejemplos de Perfil de escalera con estrías redondeadas N0 G0 X0 Y0 Z0 F100 (Startposition)\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40 Perfil redondeado con doble estría N0 G0 X0 Y0 F100 (Startposition)\nN5 G1 X5 Y0\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN21 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40\nN45 G1 X0 Y40 El punto de spline para X20 Y20 existe dos veces. De esta forma, la spline se interrumpe y se reinicia. Esto está determinado por el método de definición de la tangente en este punto. Los puntos de inicio y finalización están definidos por las tangentes de inicio del segmento de línea anterior y posterior. " }, 
{ "title" : "Preprocesamiento ", 
"url" : "_sm_cnc_din66025_preprocessor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Preprocesamiento ", 
"snippet" : "Código G : G40, G41, G42, G43, G50, G51, G52, G60, G61, G70, G71 Función : Los comandos activan módulos de preprocesamiento, como SMC_SmoothPath , SMC_RoundPath , SMC_AvoidLoop , SMC_ToolCorr , SMC_ToolLengthCorr , y SMC_ToolRadiusCorr . Si el Mostrar ruta preprocesada está seleccionada la opción, e...", 
"body" : "Código G : G40, G41, G42, G43, G50, G51, G52, G60, G61, G70, G71 Función : Los comandos activan módulos de preprocesamiento, como SMC_SmoothPath , SMC_RoundPath , SMC_AvoidLoop , SMC_ToolCorr , SMC_ToolLengthCorr , y SMC_ToolRadiusCorr . Si el Mostrar ruta preprocesada está seleccionada la opción, entonces la ruta editada es visible en el editor gráfico. Sintaxis G40\nG41 D\nG42 D\nG50\nG51 D\nG52 D\nG60\nG61 Palabra de código G Descripción D Radio de herramienta o radio de superposición para G51\/G52 . Para versiones anteriores a 4.18.0.0: El redondeo y suavizado del ángulo ( G51\/G52 ) y la corrección del radio de la herramienta ( G41\/G42 ) pueden influirse mutuamente porque ambos preprocesos interpretan cada palabra D del código G. Por ejemplo, si la corrección del radio de una herramienta con un radio igual a 1 está activa cuando el redondeo de un ángulo comienza en D = 5, como resultado, la corrección del radio de la herramienta también utiliza un radio Para la versión 4.18.0.0 y superior: redondeo y suavizado de ángulos ( G51\/G52 ) y la corrección del radio de la herramienta ( G41\/G42 ) se pueden usar simultáneamente sin que se afecten entre sí. En este caso, se aplica el siguiente comportamiento. Para la corrección del radio de la herramienta ( G41\/G42 ): De forma predeterminada, el radio de la «Herramienta» utilizado por SMC_ToolRadiusCorr es 0. Si se especifica una palabra D después de las palabras G G41\/G42 , a continuación, los bloques de funciones ajustan el radio de la «herramienta» y lo tienen en cuenta. Cuando no se especifica ningún valor, se utiliza el radio de «Herramienta» establecido actualmente. Para redondear o suavizar ángulos ( G51\/G52 ): De forma predeterminada, el radio «Suave» utilizado por SMC_Round\/SmoothPath es 0. Si se especifica una palabra D después de cualquier palabra G (excepto G36\/G37\/G40\/G41\/G42 ) o por sí sola (por ejemplo, N00 D5 ), entonces esto afecta al radio «Suave» actual y es tenido en cuenta por el SMC_Round\/SmoothPath bloques de funciones. Comandos para la corrección de herramientas Código G Descripción G40 Compensación de radio de fin de herramienta G41 Inicio de la compensación del radio de la herramienta a la izquierda de la pieza de trabajo G42 Inicio de la compensación del radio de la herramienta a la derecha de la pieza de trabajo G43 Inicio de la compensación de la longitud de la herramienta. La compensación de herramienta a corregir se especifica con los parámetros I, J K (por X, Y, Z ). La compensación de la longitud de la herramienta se desactiva poniendo los parámetros a cero. Después de la activación o desactivación, se realiza una rampa de entrada o salida. Para obtener más detalles, consulte: SMC_ToolLengthCorr Nota: La longitud de la herramienta no debe cambiar durante una compensación de radio de herramienta activa porque puede romper la trayectoria. La corrección de la longitud de la herramienta (G43) solo funciona en el decodificador en línea (no en el editor CNC). Comandos para redondeo y suavizado de ángulos Código G Descripción G50 Fin del redondeo y suavizado de ángulos G51 Inicio del suavizado de ángulos mediante SMC_SmoothPath G52 Inicio del redondeo de ángulos mediante SMC_RoundPath G70 Fin del suavizado de ejes adicionales mediante SMC_SmoothAddAxes G71 Inicio del suavizado de ejes adicionales mediante SMC_SmoothAddAxes Comandos para la supresión de bucles Código G Descripción G60 Fin de función para supresión de bucle G61 Inicio de la función para la supresión de bucles mediante SMC_AvoidLoop Ejemplo: suavizado de ángulos N0 G51 D10 F100\nN10 G01 X$g_x$ Y0 F50 E30 E-30\nN20 G01 X0 Y$g_y$\nN30 G01 X0 Y0\nN40 G50 " }, 
{ "title" : "Ejes spline adicionales A, B, C ", 
"url" : "_sm_cnc_din66025_additional_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Ejes spline adicionales A, B, C ", 
"snippet" : "Palabra de código G : A , B , C Función : Uso A , B , y C para definir las posiciones objetivo de los ejes estriados adicionales. Estos ejes son similares a P , Q , U , V , y W . P , Q , U , y V se interpolan linealmente, A , B , y C se interpolan con un polinomio de tercer grado. Uso A , B , o C ex...", 
"body" : "Palabra de código G : A , B , C Función : Uso A , B , y C para definir las posiciones objetivo de los ejes estriados adicionales. Estos ejes son similares a P , Q , U , V , y W . P , Q , U , y V se interpolan linealmente, A , B , y C se interpolan con un polinomio de tercer grado. Uso A , B , o C excluye el uso de los ejes adicionales U , V , y W porque U , V , y W define el gradiente. Los ejes A , B , o C se puede seleccionar con los bits 3, 4 o 5 en wAxis entrada de SMC_LimitDynamics o wAddAxis de SMC_CheckForLimits . El SMC_SmoothPath , SMC_SmoothMerge , SMC_SmoothBSpline , y SMC_Recompute ABC Slopes bloques de funciones determinan automáticamente la pendiente de los ejes adicionales. Esto significa que la definición de U , V , o W no es necesario. Ejemplo 1 Código G N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X100 A100 P100 El eje adicional lineal P se interpola linealmente a la trayectoria recorrida. En consecuencia, su perfil de tiempo devuelve el de la velocidad de la trayectoria. El eje spline adicional A se interpola como una función polinomial. Ejemplo 2 El uso de la función spline es necesario, especialmente si se usa una ruta con transiciones tangentes constantes, que el interpolador no tiene que desacelerar hasta la velocidad 0: Código G N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X50 A40 P40\nN30 G1 X100 A100 P100 En el caso lineal, verá un salto en la velocidad, porque 40 unidades del eje adicional viajan en 50 unidades de trayectoria en la primera parte, y 60 unidades del eje adicional viajan en 50 unidades de trayectoria en la segunda parte. Debido a que la velocidad de la trayectoria define (XYZ) solo después del espacio cartesiano de la trayectoria, una velocidad constante en X provoca un salto de velocidad en P: El eje spline muestra el siguiente perfil: Ejemplo 3 La pendiente de los ejes A, B y C en la posición final se puede definir mediante la palabra U, V y W. La unidad de la pendiente es la unidad de trayectoria del eje adicional por unidad de trayectoria en el espacio. Código G N10 G0 X0 A0 F10 E30 E-30\nN20 G1 X100 A100 U1.5\nN30 G1 X200 A200 U0 La pendiente programada por el usuario (U=2) del eje A se aplica porque este programa contiene una transición continua entre N20 y N30 . Por lo tanto, para X=100, la posición del eje A aumenta dos veces más rápido que la longitud de la trayectoria " }, 
{ "title" : "Suavizado de movimiento de eje adicional usando varios objetos ", 
"url" : "_sm_cnc_din66025_smooth_additional_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Suavizado de movimiento de eje adicional usando varios objetos ", 
"snippet" : "Código G : G70 , G71 Función : G71 comienza y G70 finaliza el suavizado de movimiento en el eje adicional que se da en L y viaja sobre múltiples objetos. Sintaxis G70 L4 G71 L4 Palabra de código G Eje adicional L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W...", 
"body" : "Código G : G70 , G71 Función : G71 comienza y G70 finaliza el suavizado de movimiento en el eje adicional que se da en L y viaja sobre múltiples objetos. Sintaxis G70 L4\nG71 L4 Palabra de código G Eje adicional L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W " }, 
{ "title" : "Configuración de ejes adicionales individuales como ejes de módulo (PA \/ PB \/…) ", 
"url" : "_sm_cnc_din66025_define_additional_axis_modulo.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Configuración de ejes adicionales individuales como ejes de módulo (PA \/ PB \/…) ", 
"snippet" : "Función: Para los ejes A, B, C, P, Q, U, V y W, se puede especificar un período de módulo configurando las palabras PA , PB , PC , etc. De forma predeterminada, PA , PB , etc.tienen el valor 0, lo que significa que el eje es lineal. Si se configura un eje adicional como eje de módulo, la distancia m...", 
"body" : "Función: Para los ejes A, B, C, P, Q, U, V y W, se puede especificar un período de módulo configurando las palabras PA , PB , PC , etc. De forma predeterminada, PA , PB , etc.tienen el valor 0, lo que significa que el eje es lineal. Si se configura un eje adicional como eje de módulo, la distancia más corta siempre se interpola desde la posición de inicio a la posición de destino. Para un período de módulo de 360, el viaje es desde la posición de inicio 270 a la posición de destino 45 de la siguiente manera: en la dirección positiva (más allá de 360) en 135 unidades en total y no en la dirección negativa en 225 unidades, como para una línea de tiempo lineal . La salida de posición del interpolador puede estar fuera del intervalo [0..límite de período [. (Por ejemplo, 400 en lugar de 40 para un período de módulo de 360.) La posición se mueve al rango de módulo siguiendo las POU, como SMC_ControlAxisByPos , o SMC_FollowPosition . Ejemplo Control rotatorio de un eje por modo módulo En el bloque 30, el eje A se mueve en la dirección positiva 90 ° de 270 ° a 360 ° = 0 °. N10 PA360 (A axis has a period of 360 degree)\nN20 G92 A270 (Set the position of A axis to 270)\nN30 G1 A0 " }, 
{ "title" : "Usando Variables ", 
"url" : "_sm_cnc_din66025_usage_of_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Usando Variables ", 
"snippet" : "Sintaxis $<Variablenname>$ Tipos de base IEC válidos para variables y expresiones: INT , SINT , USINT , UINT , DINT , UDINT , BYTE , WORD , DWORD , REAL , y LREAL . Las excepciones incluyen el parámetro O para funciones M (que espera una variable de tipo SMC_M_PARAMETERS ) y G36\/G37 (donde también s...", 
"body" : "Sintaxis $<Variablenname>$ Tipos de base IEC válidos para variables y expresiones: INT , SINT , USINT , UINT , DINT , UDINT , BYTE , WORD , DWORD , REAL , y LREAL . Las excepciones incluyen el parámetro O para funciones M (que espera una variable de tipo SMC_M_PARAMETERS ) y G36\/G37 (donde también se permiten variables de cadena). Se pueden definir variables o expresiones para todas las palabras, excepto N palabras (números de bloque). Las expresiones y variables IEC se reemplazan por sus valores actuales solo en la POU del decodificador en línea. Esto sucede cuando se decodifica la línea, que es un tiempo antes de que el elemento se procese en el interpolador. El valor de una variable en modo fuera de línea se cambia en el Valores de variables sin conexión diálogo. El cuadro de diálogo se abre mediante el CNC → Establecer variable comando o el Variables en las propiedades del objeto CNC. Usar una variable global en modo fuera de línea Declare las variables en la lista de variables globales. Utilice las variables del editor CNC en al menos una ubicación. Ejecute el CNC → Establecer variable mando. los Valores de variables sin conexión Se abre el cuadro de diálogo. Especifique los valores deseados en la tabla. Ejemplo VAR_GLOBAL\n rVal_x1: REAL:=100;\n rVal_y1: REAL:=50;\nEND_VAR\n\n\/\/ CNC-Editor\nN0 G01 X$rVal_x1$ Y0 F50 E30 E-30\nN10 G01 X0 Y$rVal_y1$\nN20 G01 X0 Y0 Comportamiento en modo online Si el programa como una variable de programa con SMC_CNC_REF traducido y procesado en línea por el módulo decodificador, funciona el uso de variables. Las variables se reemplazan en el momento en que el decodificador procesa la línea correspondiente. El uso de variables en programas de código G que se leen en línea requiere una preparación adicional con SMC_VARLIST . Si el programa CNC como SMC_OUTQUEUE se compila, el mecanismo variable no funciona porque la ruta se crea fuera de línea y se transfiere a la aplicación como una estructura de datos inalterable. En este caso y para su visualización en modo offline, el editor reemplaza la variable por su valor offline. Para más información, ver: Estructuras de datos CNC y acceso global" }, 
{ "title" : "Cambiar los valores de las variables ", 
"url" : "_sm_cnc_din66025_change_variable_values.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Cambiar los valores de las variables ", 
"snippet" : "Código G : G36 , G37 Función : Los comandos cambian el valor de una variable. G36 escribe el valor especificado en una variable. G37 incrementa la variable por el valor especificado. O$var$ define la variable que se edita. D define el valor que está escrito para G36 o agregado para G37 . El comando ...", 
"body" : "Código G : G36 , G37 Función : Los comandos cambian el valor de una variable. G36 escribe el valor especificado en una variable. G37 incrementa la variable por el valor especificado. O$var$ define la variable que se edita. D define el valor que está escrito para G36 o agregado para G37 . El comando se usa, por ejemplo, para un contador de bucle requerido para saltos condicionales. Sintaxis G36 O D\nG37 O D Palabra de código G para G36 Descripción O Variable que está escrita. O no está definido, entonces se usa una variable de decodificación interna. El valor predeterminado de esta variable interna -1 . La variable interna se puede utilizar en Salto comando. D Nuevo valor de variable Palabra de código G para G37 O Variable que se incrementa. Si O no está definida, se utiliza una variable decodificadora interna. D Incremento Ejemplo Programación del contador (si la ruta se procesa en línea) los g_i La variable global se establece en 5. N1000 G36 O$g_i$ D5 Las líneas 1010 y 1020 se recorren cinco veces. N1000 G36 O$g_i$ D5\nN1010 G1 X100 F100 E100 E-100\nN1020 G1 X0\nN1030 G37 O$g_i$ D-1\nN1040 G20 L1010 K$g_i$ El mecanismo funciona solo si la ruta se procesa en línea, porque solo entonces se pueden usar variables. Este mecanismo no funciona en el editor CNC. Programación del contador para el modo fuera de línea Para trabajar con el editor fuera de línea, no especifique ninguna variable mediante O . Luego, una variable decodificadora implícita de tipo INT se utiliza. Sin embargo, solo está disponible una variable. No puede programar saltos o bucles anidados. Usando variables de cadena Puede usar una variable de cadena en la palabra O en código G. Además, se puede asignar e insertar un valor de cadena a esta variable mediante el comando G36 y G37 . Ejemplo N10 G36 O$strTest$ D'Name' los strTest la variable obtiene el valor de Nombre. N20 G37 O$strTest$ D'=Test' El valor =Test se agrega a la variable strTest . Si se utilizan variables de cadena en el programa CNC, y si el programa CNC (en el programa IEC) se lee mediante el SMC_ReadNCFile bloque de funciones, entonces los búferes para las cadenas deben reservarse en el programa IEC. De lo contrario, el error SMV_RNCF_NO_STRINGBUFFER ocurre. los SMC_StringBuffer El bloque de funciones está disponible para este propósito. Cada cadena del programa CNC requiere su propio espacio en la instancia del bloque de función de SMC_StringBuffer , incluso si la misma cadena aparece varias veces. La siguiente declaración puede almacenar en búfer 32 cadenas, por ejemplo: sb: SMC_StringBuffer(uiBufferSize := 32); La instancia del bloque de funciones sb se pasa como un puntero al pStringBuffer entrada de la SMC_ReadNCFile ejemplo. " }, 
{ "title" : "Subprogramas ", 
"url" : "_sm_cnc_din66025_subprograms.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Subprogramas ", 
"snippet" : "Función : Llamada de un subprograma Las tareas que se repiten con frecuencia, como el fresado de cajeras, la perforación de orificios y el cambio de herramientas, pueden cambiarse a subprogramas de código G y llamarse desde allí. Durante una llamada, los parámetros se pueden pasar al subprograma. Lo...", 
"body" : "Función : Llamada de un subprograma Las tareas que se repiten con frecuencia, como el fresado de cajeras, la perforación de orificios y el cambio de herramientas, pueden cambiarse a subprogramas de código G y llamarse desde allí. Durante una llamada, los parámetros se pueden pasar al subprograma. Los tipos de datos BOOL , LREAL , y STRING están permitidos para este propósito. Si usa subprogramas, entonces debe usar los bloques de función SMC_ReadNCFile2 y SMC_NCInterpreter en lugar de SMC_ReadNCFile y SMC_NCDecoder . Los subprogramas solo funcionan en el decodificador en línea (no en el editor CNC). Cada subprograma se almacena en un archivo separado. Estos archivos se guardan en uno o más subdirectorios del controlador. Deben tener la extensión de archivo .cnc . El nombre del archivo debe corresponder al nombre del subprograma y estar en minúsculas. Ejemplo: nombre de subprograma \"Drill\" -> nombre de archivo drill.cnc . Tenga en cuenta que el nombre del archivo del subprograma debe escribirse en minúsculas. El POU SMC_ReadNCFile2 tiene una entrada aSubProgramDirs : ARRAY[0..4] OF STRING(174) . Se pueden especificar hasta cinco subdirectorios más allá de esto. Se escanean en el orden indicado. Si hay subprogramas con el mismo nombre en varios directorios, entonces se encuentra el subprograma que tiene el directorio con el índice más bajo en la matriz. El nombre del subprograma se convierte a minúsculas. Ejemplo aSubProgramDirs = ['subprograms\/user', 'subprograms\/system', ''] El subprograma DrillA1 se escanea primero en el archivo subprograms\/user\/drilla1.cnc . Si este archivo no existe, la búsqueda continúa en subprograms\/system\/drilla1.cnc . Es posible llamar a subprogramas indirectamente por medio de una variable (más precisamente, por medio de una expresión de tipo STRING ). La expresión (y, por lo tanto, también cualquier búsqueda de variables) se evalúa, generalmente en el caso de usar variables en el código G, en el momento del preprocesamiento cuando el intérprete llega a la línea. En este caso, la verificación de tipo de los argumentos se realiza solo cuando el intérprete ha llegado a la línea y no durante el análisis, como es el caso de las llamadas estáticas. Los subprogramas no se pueden crear fuera de línea en el editor CNC. Profundidad máxima de anidamiento de las llamadas de subprogramas Antes de la versión 4.18.0.0: la profundidad máxima de anidamiento de las llamadas a subprogramas está limitada a 14. Versión 4.18.0.0 y superior: la profundidad de anidamiento ahora solo está limitada por la memoria. El valor máximo se puede cambiar mediante SMC_CNC_LIBPARAMS.MAX_SUBPROGRAM_NESTING_DEPTH . " }, 
{ "title" : "Sintaxis de la llamada ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Subprogramas \/ Sintaxis de la llamada ", 
"snippet" : "Las llamadas a subprogramas son bloques especiales en el código G que constan de un número de bloque y solo una llamada. No se permiten palabras adicionales. N<SentenceNo> <Name> <BracketOpen> <ActualParamList> <BracketClosed> N<SentenceNo> DYNCALL <BracketOpen> <SubNameExp> [, <ActualParamListNotEm...", 
"body" : "Las llamadas a subprogramas son bloques especiales en el código G que constan de un número de bloque y solo una llamada. No se permiten palabras adicionales. N<SentenceNo> <Name> <BracketOpen> <ActualParamList> <BracketClosed>\nN<SentenceNo> DYNCALL <BracketOpen> <SubNameExp> [, <ActualParamListNotEmpty] <BracketClosed>\n\n<SubNameExp> : An expression with exactly one value of type STRING\n<ActualParamList> ::= Empty | <ActualParamListNotEmpty>\n<ActualParamListNotEmpty> ::= <ActualParamValue> | <ActualParamValue>, <ActualParamListNotEmpty> <Name> Identificador IEC válido con un mínimo de 3 y un máximo de 80 caracteres. Debe corresponder al nombre del archivo (sin extensión) donde está definido el subprograma. Las mayúsculas o minúsculas no importan para los nombres de los subprogramas. [a-zA-Z0-9_] están permitidos. Las siguientes palabras clave no son válidas como nombres: SUBPROGRAM, RETURN, END_SUBPROGRAM, RESTORE_MODES, BOOL, LREAL, STRING, LET, DYNCALL, IF, ELSE, END_IF, CASE, END_CASE, FOR,END_FOR, WHILE, END_WHILE, REPEAT, UNTIL, END_REPEAT . <ActualParamList> Tiene que haber exactamente el mismo número de valores de parámetro especificados como define el subprograma (ver \"Sintaxis de la declaración\"). El tipo de valor de cada parámetro debe coincidir con la declaración. <BracketOpen>\/<BracketClosed> Por razones de compatibilidad, se utilizan llaves en lugar de paréntesis en la configuración predeterminada para SMC_ReadNCFile2 y convocatorias y declaraciones de subprogramas. Los paréntesis son válidos en código G para comentarios. El bloque de funciones SMC_ReadNCFile2 tiene un modo bParenthesesAsComments input) donde los paréntesis no son comentarios. En cambio, los comentarios de varias líneas se abren con (* y cerrado con *) . En este nuevo modo, tanto las llaves como los paréntesis se pueden usar para las llamadas y declaraciones de subprogramas. <ActualParamValue> Variable, literal o cualquier expresión Ejemplo N10 SUB1()\nN20 DRILL(10.0)\nN30 SUB2(5, \"Text\", 2.5)\nN40 G36 O#SUBNAME D'DRILL' % Indirect call via local variable\nN40 DYNCALL(#SUBNAME, 2) % equivalent to N40 DRILL(2)\nN50 DYNCALL($SUBNAME$, 2, 4) % Indirect call via IEC variable " }, 
{ "title" : "Sintaxis de la declaración ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Subprogramas \/ Sintaxis de la declaración ", 
"snippet" : "Un subprograma debe guardarse en un archivo separado. La primera línea (ni vacía ni de comentario) debe contener la declaración del subprograma. Se aplica la siguiente sintaxis: SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT> <Inhalt Unterprogramm> END_SUBPROGRAM <For...", 
"body" : "Un subprograma debe guardarse en un archivo separado. La primera línea (ni vacía ni de comentario) debe contener la declaración del subprograma. Se aplica la siguiente sintaxis: SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT>\n<Inhalt Unterprogramm>\nEND_SUBPROGRAM\n\n<FormalParamList> ::= Empty | <FormalParamListNotEmpty>\n<FormalParamListNoEmpty> ::= <FormalParam> | <FormalParam> , <FormalParamListNotEmpty>\n<FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String with a maximum length of 255 bytes\n<RESTORE_OPT> ::= RESTORE_MODES <ParamName> La longitud del nombre puede tener un máximo de 80 caracteres (sin incluir el prefijo # ). RESTORE_MODES Si se especifica esta palabra clave, los siguientes estados modales se restauran al regresar al programa de llamada (establecido en el valor que tenía en la llamada): Código G activo Modo relativo \/ absoluto (G90 \/ G91, G98 \/ G99) Plano circular y modo 2D \/ 3D Sistema de coordenadas del decodificador (incluida la escala) Velocidades de avance (trayectoria y ejes adicionales), velocidad de desplazamiento rápido, aceleraciones y desaceleraciones máximas (trayectoria y ejes adicionales) Indicadores de funciones y parámetros generales (G38) Radio de la herramienta (palabra D) Correcciones de herramienta (G43) Perfil S (palabra S) Los siguientes estados modales no se restauran: Posición actual del decodificador\/intérprete, así como el estado cardinal actual de la ranura La posición incluye toda la estructura SMC_POSINFO (es decir, X, Y, Z, la orientación y todos los ejes adicionales). Estado (encendido \/ apagado) de las POU de preprocesamiento de ruta (G40-G43, G50-G52, G60-G61, G70-G71) Ajuste de módulo de los ejes adicionales (PA, PB,…) Nota: Independientemente de esta palabra clave, las variables de contador implícitas (G36, G37) se restauran al regresar del subprograma al programa de llamada. Ejemplos de SUBPROGRAM SUB1() ; no formal parameters\nSUBPROGRAM DRILL(#depth : LREAL)\nSUBPROGRAM SUB2(#a : LREAL, #b : STRING, #c : LREAL)\nSUBPROGRAM SRM1() RESTORE_MODES " }, 
{ "title" : "Sintaxis para la devolución ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Subprogramas \/ Sintaxis para la devolución ", 
"snippet" : "La devolución se realiza al final del texto del subprograma (antes del END_SUBPROGRAM ) o explícitamente con la siguiente sintaxis: N<block number> RETURN ....", 
"body" : "La devolución se realiza al final del texto del subprograma (antes del END_SUBPROGRAM ) o explícitamente con la siguiente sintaxis: N<block number> RETURN . " }, 
{ "title" : "Usando los parámetros formales en el subprograma ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_ba614a0b6544562fc0a864631e9ee966", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Subprogramas \/ Usando los parámetros formales en el subprograma ", 
"snippet" : "Se puede acceder a los valores de los parámetros formales en el subprograma mediante #<ParamName> . El número de parámetros formales está limitado a 21. Ejemplo SUBPROGRAM SUB(#Param1 : LREAL) N10 G01 X#Param1...", 
"body" : "Se puede acceder a los valores de los parámetros formales en el subprograma mediante #<ParamName> . El número de parámetros formales está limitado a 21. Ejemplo SUBPROGRAM SUB(#Param1 : LREAL)\nN10 G01 X#Param1 " }, 
{ "title" : "Visualización de la pila de llamadas ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Subprogramas \/ Visualización de la pila de llamadas ", 
"snippet" : "El interprete ( SMC_NCInterpreter ) tiene una salida que contiene los 10 principales programas \/ subprogramas activos: aActivePrograms : ARRAY[0..9] OF STRING . La primera entrada ( aActivePrograms[0] ) es el programa \/ subprograma actualmente interpretado. La segunda entrada ( aActivePrograms[1] ) ...", 
"body" : "El interprete ( SMC_NCInterpreter ) tiene una salida que contiene los 10 principales programas \/ subprogramas activos: aActivePrograms : ARRAY[0..9] OF STRING . La primera entrada ( aActivePrograms[0] ) es el programa \/ subprograma actualmente interpretado. La segunda entrada ( aActivePrograms[1] ) es el programa \/ subprograma que llama y así sucesivamente. Si no hay un programa de llamada, la cadena correspondiente está vacía. La pila de llamadas también se puede mostrar en el momento de la interpolación. los SMC_DisplayNCCallstack POU muestra los programas \/ subprogramas activos en el mismo formato que el intérprete, solo más tarde (es decir, cuando se ejecuta el movimiento). Al hacerlo, la salida del intérprete CallstackInfo (SMC_NCCallstackInfo) y el interpolador se le pasa como VAR_IN_OUT variables. SMC_NCCallstackInfo almacena todos los cambios de la pila de llamadas, incluido el correspondiente SMC_GeoInfo número de objeto, en un búfer circular. En este momento, esto restringe el número de cambios de pila de llamadas almacenables entre el tiempo de interpretación y el tiempo de interpolación a 128. Debido a que el búfer de anillo no cumple con los criterios de multitarea, SMC_DisplayNCCallstack tiene que ser llamado desde la tarea de intérprete. El programa de muestra Ejemplo 07 de CNC: uso de expresiones y subprogramasmuestra un ejemplo de la visualización de la pila de llamadas en el momento de la interpolación. " }, 
{ "title" : "Expresiones ", 
"url" : "_sm_cnc_din66025_expressions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Expresiones ", 
"snippet" : "Función : En la versión 4.4.0.0 y posteriores, es posible utilizar expresiones matemáticas, booleanas y de cadena. los SMC_ReadNCFile2 y SMC_NCInterpreter Los bloques de funciones deben usarse para esto (en lugar de SMC_ReadNCFile y SMC_NCDecoder ). Las expresiones funcionan solo en el decodificador...", 
"body" : "Función : En la versión 4.4.0.0 y posteriores, es posible utilizar expresiones matemáticas, booleanas y de cadena. los SMC_ReadNCFile2 y SMC_NCInterpreter Los bloques de funciones deben usarse para esto (en lugar de SMC_ReadNCFile y SMC_NCDecoder ). Las expresiones funcionan solo en el decodificador en línea (no en el editor CNC). En principio, las expresiones se pueden utilizar en código G en dos posiciones: Como valores de palabras G (una palabra G consta de una dirección y un valor, por ejemplo, \"G1\") Como parámetros de transferencia para llamadas a subprogramas " }, 
{ "title" : "Sintaxis: general ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_42546a9cc18a4349c0a86463750fefea", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Expresiones \/ Sintaxis: general ", 
"snippet" : "Una expresión puede constar de los siguientes elementos: Literales numéricos y de cadena Variables globales y locales Operadores y funciones de infijo Comas y corchetes De la misma manera, los paréntesis (si no se usan para identificar comentarios) y las llaves se pueden usar para estructurar expres...", 
"body" : "Una expresión puede constar de los siguientes elementos: Literales numéricos y de cadena Variables globales y locales Operadores y funciones de infijo Comas y corchetes De la misma manera, los paréntesis (si no se usan para identificar comentarios) y las llaves se pueden usar para estructurar expresiones. Esto significa que la expresión (1 + 2} * 3 esta permitido. El bloque de funciones SMC_ReadNCFile2 tiene un nuevo modo bParenthesesAsComments input) donde los paréntesis no son comentarios. En su lugar, los comentarios de varias líneas se abren y cierran con \"(*\" y \"*)\", respectivamente. En este nuevo modo, se pueden usar llaves y paréntesis para las expresiones. Se requiere un espacio después de la dirección G solo si SMC_ReadNCFile2 no lo reconocería como un token independiente (ejemplo: X abs{-2} en lugar de Xabs{-2}. ). A diferencia de ST, las funciones de una sola posición no tienen que llamarse necesariamente entre paréntesis (ejemplo: sin 3 ). Al analizar, a cada expresión parcial se le asigna uno de los tres tipos: BOOL, LREAL o STRING. En consecuencia, cada operador Infix y cada función espera una secuencia específica de tipos de argumentos para los cuales el incumplimiento (tipo incorrecto, muy pocos o demasiados argumentos) devuelve un error. Restricciones: Los números de bloque deben ser literales numéricos. Por razones estrictamente técnicas, los marcadores de salto ( x en L!x ) no debe contener ninguna variable local. Para obtener más información, consulte: Salto, Usando Variables" }, 
{ "title" : "Ejemplos de ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_5b6258e8c18a4349c0a864632640e903", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Expresiones \/ Ejemplos de ", 
"snippet" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}} N02 G1 X$var$ + sin{pi + 3 * #locvar} N03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}}...", 
"body" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}}\nN02 G1 X$var$ + sin{pi + 3 * #locvar}\nN03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}} " }, 
{ "title" : "Operadores y funciones compatibles ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_da2d0ac5c18a4349c0a864637cb30dc8", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Expresiones \/ Operadores y funciones compatibles ", 
"snippet" : "Operadores de infijo Personaje Escribe Argumentos Precedencia MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , ...", 
"body" : "Operadores de infijo Personaje Escribe Argumentos Precedencia MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , LREAL 10 <> BOOL STRING , STRING 10 > BOOL LREAL , LREAL 10 < BOOL LREAL , LREAL 10 >= BOOL LREAL , LREAL 10 <= BOOL LREAL , LREAL 10 AND BOOL BOOL , BOOL 6 XOR BOOL BOOL , BOOL 5 OR BOOL BOOL , BOOL 4 Funciones Personaje Escribe Argumentos - LREAL LREAL ABS LREAL LREAL MAX LREAL LREAL , LREAL MIN LREAL LREAL , LREAL NOT BOOL BOOL TRUE BOOL FALSE BOOL SIN LREAL LREAL COS LREAL LREAL TAN LREAL LREAL ASIN LREAL LREAL ACOS LREAL LREAL ATAN LREAL LREAL EXP LREAL LREAL LN LREAL LREAL SQRT LREAL LREAL EXPT LREAL LREAL , LREAL FLOOR LREAL LREAL CEIL LREAL LREAL PI LREAL LEN LREAL STRING CONCAT STRING STRING , STRING " }, 
{ "title" : "Definiendo sus propias funciones ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_fca8916cc18a4349c0a8646350db2bd3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Expresiones \/ Definiendo sus propias funciones ", 
"snippet" : "Es posible agregar sus propias funciones o sobrescribir una implementación existente. (Al analizar el código G, las funciones se buscan primero en las funciones del usuario). Se debe implementar la interfaz SMC_NC_iFunction y se debe transferir una instancia global de la POU correspondiente a SMC_Re...", 
"body" : "Es posible agregar sus propias funciones o sobrescribir una implementación existente. (Al analizar el código G, las funciones se buscan primero en las funciones del usuario). Se debe implementar la interfaz SMC_NC_iFunction y se debe transferir una instancia global de la POU correspondiente a SMC_ReadNCFile2 o SMC_ReadNCFromStream a través de la estructura SMC_NC_GFunctionTable . La enumeración SMC_GVar_Type se utiliza para el tipo de retorno y los tipos de argumento. La entrada contenida allí T_OTHER se puede utilizar como marcador de posición para un tipo. Al analizar, el sistema comprueba que todos los argumentos que corresponden a un T_OTHER en la firma tienen el mismo tipo. No importa el tipo. Para obtener más información, consulte: Funciones de código G específicas del usuario" }, 
{ "title" : "Manejo de errores ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Expresiones \/ Manejo de errores ", 
"snippet" : "Cuando es posible, la posición exacta del token defectuoso y su longitud se emiten en errores de sintaxis. La posición del error se enumera en SMC_ReadNCFile2.errorPos ....", 
"body" : "Cuando es posible, la posición exacta del token defectuoso y su longitud se emiten en errores de sintaxis. La posición del error se enumera en SMC_ReadNCFile2.errorPos . " }, 
{ "title" : "Variables locales ", 
"url" : "_sm_cnc_din66025_local_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Variables locales ", 
"snippet" : "Cada archivo de código G puede declarar variables locales. Para los programas principales, las declaraciones deben insertarse al principio; para subprogramas, directamente después de la declaración del subprograma. Las variables locales son visibles solo en el programa o subprograma donde se declara...", 
"body" : "Cada archivo de código G puede declarar variables locales. Para los programas principales, las declaraciones deben insertarse al principio; para subprogramas, directamente después de la declaración del subprograma. Las variables locales son visibles solo en el programa o subprograma donde se declaran. (Sin alcance dinámico) Las variables locales funcionan solo en el decodificador en línea (no en el editor CNC). Número de variables locales Antes de la versión 4.18.0.0: el número de variables locales está restringido a 21 por subprograma y en el programa principal. Versión 4.18.0.0 y superior: el número de variables locales solo está limitado por la memoria. El valor máximo se puede cambiar mediante el parámetro de biblioteca SMC_CNC_LIBPARAMS.MAX_SUBPROGRAM_PARAMS . Para obtener más información, consulte: Parámetros de biblioteca Sintaxis de la declaración La sintaxis es similar a la utilizada para declarar parámetros de subprograma. Se puede declarar una variable por bloque. El bloque no comienza con una palabra N. La variable puede recibir un valor inicial opcional cuando se declara. De lo contrario, se le asigna un valor predeterminado en función del tipo de datos ( LREAL: 0, BOOL: FALSE, STRING: ‘‘ ). Sintaxis de la declaración: LET <FormalParam> [:= <InitialValue>] . <FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String mit maximaler Länge von 255 Bytes <InitialValue> : Expresión que tiene un valor y un tipo que coincide con la variable. La expresión también puede usar variables locales (y en subprogramas los parámetros del subprograma), pero solo las declaradas anteriormente en el código del programa. Ejemplos de • LET #x : LREAL (* Variable #x, Typ LREAL, Initialwert 0 *)\n• LET #y : LREAL := #x + 1 (* Variable #y, Typ LREAL, Initialwert #x+1 = 1 *)\n• LET #b : BOOL := #x >= #y (* Variable #b, Typ BOOL, Initialwert FALSE *) Al igual que con los parámetros de subprograma, las variables locales no distinguen entre mayúsculas y minúsculas. (Ambos #x y #X indicar la misma variable.) Los nombres de todas las variables locales declaradas en un programa \/ subprograma deben ser diferentes. Deben diferir de los nombres de los parámetros formales del subprograma. Las variables locales se pueden utilizar en código G como parámetros de subprogramas. Ejemplos de • N10 G01 X#x Y#y\n• N20 G20 L10 K#b " }, 
{ "title" : "Función de sondeo (distancia restante libre) ", 
"url" : "_sm_probe_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Lenguaje CNC en DIN 66025 \/ Función de sondeo (distancia restante libre) ", 
"snippet" : "Código G : G31 \/Cualquier comando de movimiento junto con el PROBE palabra Función : La función de sondeo (distancia restante despejada) es un movimiento especial que se interrumpe tan pronto como se emite una señal ( PROBE ) está pendiente. El resto del código G continúa desde la posición en la que...", 
"body" : "Código G : G31 \/Cualquier comando de movimiento junto con el PROBE palabra Función : La función de sondeo (distancia restante despejada) es un movimiento especial que se interrumpe tan pronto como se emite una señal ( PROBE ) está pendiente. El resto del código G continúa desde la posición en la que se interrumpió el movimiento, no desde la posición final programada del La función de sondeo (borrar la distancia restante) provoca una parada de decodificación implícita antes del siguiente movimiento (similar a G75 ). La decodificación del código G continuará solo después de que se haya recibido la señal. Los casos de uso típicos incluyen medir la longitud de una herramienta (pasar a un interruptor) o pasar a un bloque La función de sondeo (distancia restante despejada) se puede activar para cualquier número de movimientos, como líneas rectas y arcos circulares. Para ello, solo el PROBE hay que añadir una palabra al código G. G31 es un movimiento lineal con la función de sondeo (distancia restante libre), con el número de sonda predeterminado 1. Este valor predeterminado se puede anular con una Cada movimiento puede tener como máximo una PROBE palabra. Las funciones H (activadores) no son compatibles con los movimientos con la función de sondeo (distancia restante libre). El preprocesamiento de rutas, como el suavizado de esquinas, la corrección del radio de la herramienta, etc., no es compatible con los movimientos con la función de sondeo (borrar la distancia restante). El número de sonda debe ser positivo. Si no se recibe ninguna señal de sonda durante el procesamiento de un movimiento con la función de sondeo (distancia restante limpia), la interpolación se detiene al final del movimiento con un error. El interpolador primero debe detenerse cuando se recibe una señal de sonda. Una de las entradas bSlow_Stop , bQuick_Stop , o bEmergency_Stop se puede usar para este propósito. Tan pronto como se detenga la interpolación, se podrá confirmar la función de sondeo (borrar la distancia restante). Para ello, se aplica un borde ascendente al SMC_Interpolator.bAcknProbe entrada. Sintaxis G31 X Y Z A B C P Q U V W F E S PROBE\nG1\/2\/3\/8\/9 X Y Z A B C P Q U V W F E S PROBE Palabra de código G Descripción X Y Z Posiciones objetivo de los ejes cartesianos A B C P Q U V W Posiciones objetivo de los ejes adicionales F E Velocidad de trayectoria, aceleración\/desaceleración de trayectoria S Perfil S PROBE El número de sonda debe ser positivo. Ejemplos Movimiento lineal Movimiento lineal con la función de sondeo (distancia restante libre) y el número de sonda predeterminado 1 N010 G31 X100 Movimiento circular Movimiento circular con la función de sondeo (distancia restante libre) y la sonda número 7 N010 G02 X100 R50 PROBE 7 Para obtener más información, consulte el ejemplo: Ejemplo CNC 16: Función de sondeo (distancia libre restante) (G31)" }, 
{ "title" : "Preprocesamiento de rutas y tamaños de cola ", 
"url" : "_sm_preprocessing_queuesize.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Preprocesamiento de rutas y tamaños de cola ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Canalización del procesamiento del código G ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103127844091", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Preprocesamiento de rutas y tamaños de cola \/ Canalización del procesamiento del código G ", 
"snippet" : "Cuando se lee el código G de un archivo, a menudo no es práctico leer y procesar todo el archivo antes de iniciar el mecanizado. Para algunas aplicaciones, los archivos de código G pueden tener unos cientos de miles o incluso millones de líneas. Leer todo de una vez llevaría mucho tiempo y también r...", 
"body" : "Cuando se lee el código G de un archivo, a menudo no es práctico leer y procesar todo el archivo antes de iniciar el mecanizado. Para algunas aplicaciones, los archivos de código G pueden tener unos cientos de miles o incluso millones de líneas. Leer todo de una vez llevaría mucho tiempo y también requeriría mucha memoria En cambio, el código G se lee línea por línea, pero solo una pequeña fracción (unos pocos cientos de líneas) se guarda en la memoria en cada momento. Esta parte se guarda en colas, es decir, en estructuras de datos que funcionan según el principio de «primero en entrar, primero en salir»: el bloque de función productor añade elementos a la cola. El bloque de funciones consumidoras lee y elimina los elementos en el mismo orden en que se insertaron El diagrama muestra el flujo del código G a través del sistema. En primer lugar, el código G se lee de un archivo y, a continuación, el intérprete lo convierte en los denominados elementos GeoInfo. Estos elementos son procesados por la ruta, preprocesando los bloques de funciones y, finalmente, los interpolan. Las partes marcadas con «GeoInfo» representan las colas. Si hay más de un preprocesador de rutas SMC_SmoothPath , SMC_ToolRadiusCorr , o SMC_AvoidLoop ) se usa, luego también están conectados por colas. " }, 
{ "title" : "Tamaños de cola recomendados ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128036484", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Preprocesamiento de rutas y tamaños de cola \/ Tamaños de cola recomendados ", 
"snippet" : "Como regla general, para la mayoría de las colas es adecuado un tamaño de 16 elementos. La última cola antes del SMC_Interpolator bloque de función (que suele ser la cola de la ruta que preprocesa el bloque de funciones antes SMC_CheckVelocities ) debería tener un tamaño de cola mayor: 100 elementos...", 
"body" : "Como regla general, para la mayoría de las colas es adecuado un tamaño de 16 elementos. La última cola antes del SMC_Interpolator bloque de función (que suele ser la cola de la ruta que preprocesa el bloque de funciones antes SMC_CheckVelocities ) debería tener un tamaño de cola mayor: 100 elementos es un buen punto de partida para la mayoría de las aplicaciones. Para entender estas reglas y saber cuándo desviarse de ellas, analizamos los efectos del tamaño de las colas: Latencia de procesamiento: cuanto más grandes sean las colas, más tardará en llenarse inicialmente. El SMC_Interpolator bloque de función espera hasta que se llene la última cola antes de comenzar con la interpolación. Para la latencia, el tamaño total de la cola (la suma de todos los tamaños de cola Mira hacia adelante del interpolador: el tamaño de la última cola antes del SMC_Interpolator determina la anticipación de la interpolación. Al calcular una trayectoria, el interpolador solo puede planificar hasta el final de la previsión. Si la previsión es demasiado pequeña, es posible que el interpolador no pueda alcanzar la velocidad máxima de la trayectoria. Según la velocidad de la trayectoria y la longitud de los elementos, 100 elementos es un buen punto de partida, pero en el caso de los elementos con velocidades altas o cortos, puede ser necesaria una cola más grande Efecto en bloques de funciones particulares : bloques de funciones como SMC_AvoidLoop o SMC_SmoothMerge requieren un tamaño determinado de la cola de entrada para funcionar de forma eficaz. Por ejemplo, para detectar un bucle en el código G, este bucle debe caber en la cola antes SMC_AvoidLoop . Consulta la documentación de los bloques de funciones de tu proceso de procesamiento de rutas para obtener más información. " }, 
{ "title" : "Llamar a los bloques de funciones de procesamiento ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128219711", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Preprocesamiento de rutas y tamaños de cola \/ Llamar a los bloques de funciones de procesamiento ", 
"snippet" : "Como se mencionó anteriormente, la interpolación comienza solo después de que se hayan llenado todas las colas. Esto provoca una latencia inicial al iniciar el mecanizado. Además de reducir el tamaño total de la cola, hay una forma adicional de reducir esta latencia Los bloques de funciones de prepr...", 
"body" : "Como se mencionó anteriormente, la interpolación comienza solo después de que se hayan llenado todas las colas. Esto provoca una latencia inicial al iniciar el mecanizado. Además de reducir el tamaño total de la cola, hay una forma adicional de reducir esta latencia Los bloques de funciones de preprocesamiento de rutas se suelen llamar en una tarea cíclica en segundo plano, como se muestra en los ejemplos, como Ejemplo 03 de CNC: Realización del preprocesamiento de ruta en línea. Para reducir la latencia, el programa llama SMC_ReadNCFile2 , SMC_NCInterpreter , y los preprocesadores de rutas se pueden invocar en un bucle. En función de las prioridades de la aplicación y de las tareas, puede ser suficiente ejecutar el programa varias veces por llamada de tarea (por ejemplo, 100 veces) o terminar el ciclo después de un período de tiempo determinado (por ejemplo, 5 ms) " }, 
{ "title" : "Ejemplos ", 
"url" : "_sm_cnc_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Ejemplo 01 de CNC: Generación de OutQueue directamente ", 
"url" : "_sm_example_cnc_1.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 01 de CNC: Generación de OutQueue directamente ", 
"snippet" : "Ver el CNC01_direct.project proyecto de ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra un programa CNC con dos ejes. Se abordan cuatro posiciones en el plano X\/Y con una velocidad y aceleración definidas. El programa establece dos puntos...", 
"body" : "Ver el CNC01_direct.project proyecto de ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra un programa CNC con dos ejes. Se abordan cuatro posiciones en el plano X\/Y con una velocidad y aceleración definidas. El programa establece dos puntos de cambio de ruta en la ruta. El programa se escribe directamente en una estructura de datos usando el SMC_OutQueue modo de compilación. Puesta en servicio Compile e inicie el programa creado. El programa ejecuta el movimiento del CNC tan pronto como Execute se ha configurado la entrada del interpolador. Una vez que el programa se haya ejecutado por completo, puede reiniciarlo mediante un nuevo flanco ascendente. Tenga en cuenta la función de los conmutadores de ruta que también se muestran en la visualización del bloque de función de interpolación. " }, 
{ "title" : "Crear un programa NC en el editor CNC ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_0decf30fe1170213c0a864632e7a1fa2", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 01 de CNC: Generación de OutQueue directamente \/ Crear un programa NC en el editor CNC ", 
"snippet" : "Crear un CNCdirect proyecto con un SoftMotion controlador. Insertar un Programa CNC objeto nombrado Example . Selecciona el Implementación Din66025 y el Modo de compilación SMC_OutQueue . Especifique los siguientes bloques de movimiento: Editor CNC:...", 
"body" : "Crear un CNCdirect proyecto con un SoftMotion controlador. Insertar un Programa CNC objeto nombrado Example . Selecciona el Implementación Din66025 y el Modo de compilación SMC_OutQueue . Especifique los siguientes bloques de movimiento: Editor CNC: " }, 
{ "title" : "Creación de una interfaz de accionamiento y configuración de PLC ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_502a86c7e1170213c0a864631de910a9", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 01 de CNC: Generación de OutQueue directamente \/ Creación de una interfaz de accionamiento y configuración de PLC ", 
"snippet" : "Defina una estructura de accionamiento con dos accionamientos lineales de la siguiente manera: Inserte dos unidades virtuales X_Drive y Y_Drive bajo el Piscina de eje general SoftMotion . Selecciona el Tipo de eje parámetro a Finite (1). Editor de configuración:...", 
"body" : "Defina una estructura de accionamiento con dos accionamientos lineales de la siguiente manera: Inserte dos unidades virtuales X_Drive y Y_Drive bajo el Piscina de eje general SoftMotion . Selecciona el Tipo de eje parámetro a Finite (1). Editor de configuración: " }, 
{ "title" : "Crear un programa IEC ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_2840ecebe1170213c0a8646360b1cd08", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 01 de CNC: Generación de OutQueue directamente \/ Crear un programa IEC ", 
"snippet" : "Agregar un nuevo programa de CFC Ipo a la aplicación y configurar una tarea cíclica con un intervalo de 3 ms. Active la unidad con el MC_Power bloque de funciones POU: Introduzca el SMC_Interpolator POU. El bloque de funciones convierte una ruta definida por objetos GEOINFO en puntos de ruta discret...", 
"body" : "Agregar un nuevo programa de CFC Ipo a la aplicación y configurar una tarea cíclica con un intervalo de 3 ms. Active la unidad con el MC_Power bloque de funciones POU: Introduzca el SMC_Interpolator POU. El bloque de funciones convierte una ruta definida por objetos GEOINFO en puntos de ruta discretos. El bloque de función recibe la dirección del programa CNC creado en la entrada poqDataIn . Luego, el tiempo de ciclo de la tarea IEC debe escribirse en la entrada dwIpoTime . Puede especificar estos como valores constantes en la entrada dwIpoTime o puedes usar la variable dwCycle de la estructura del grupo de ejes desde la configuración del PLC. La ventaja de esto es que el tiempo correcto se usa automáticamente como entrada del interpolador cuando cambia el tiempo de ciclo de la tarea. POU: En este ejemplo, se controlará un sistema de pórtico. Para este propósito, inserte una instancia de los bloques de función de transformación inversa y directa de la SM_Trafo Biblioteca. El bloque de función de transformación directa contiene los variadores como entradas. El bloque de función de transformación inversa debe contener la posición establecida del interpolador. La transformación hacia adelante en el ejemplo es necesaria solo para la visualización. Instancia de bloque de función: Las salidas del bloque de funciones (las coordenadas del eje) deben escribirse en los accionamientos. Esto se hace con el SMC_ControlAxisByPos bloque de funciones. Debido a que la aplicación no garantiza que las salidas del interpolador sean constantes (p. Ej., La ruta termina en un punto distinto de donde comenzó), active la evitación de espacios ( bAvoidGaps , fGapVelocity , fGapAcceleration , fGapDeceleration ). Luego conecta el StopIpo salida a la bEmergency_Stop entrada del interpolador y conectar la salida del interpolador iStatus a las respectivas entradas de los bloques de función de control de ejes. Tenga en cuenta el orden correcto de los bloques de función al programar con CFC. CFC: " }, 
{ "title" : "Creación de una interfaz operativa y una interfaz de prueba ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 01 de CNC: Generación de OutQueue directamente \/ Creación de una interfaz operativa y una interfaz de prueba ", 
"snippet" : "Vincula dos objetos de visualización a una nueva visualización: la plantilla del interpolador y la plantilla de la transformación. Debe utilizar marcadores de posición para vincularlos a las respectivas instancias del bloque de funciones (aquí: Ipo.smci y Ipo.trafof )....", 
"body" : "Vincula dos objetos de visualización a una nueva visualización: la plantilla del interpolador y la plantilla de la transformación. Debe utilizar marcadores de posición para vincularlos a las respectivas instancias del bloque de funciones (aquí: Ipo.smci y Ipo.trafof ). " }, 
{ "title" : "Ejemplo 02 de CNC: Decodificación en línea con variables ", 
"url" : "_sm_example_cnc_2.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 02 de CNC: Decodificación en línea con variables ", 
"snippet" : "Ver el CNC02_online.project proyecto de ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . El ejemplo muestra cómo usar variables para decodificar un programa CNC. Puesta en servicio Compile e inicie el programa creado. El programa ejecuta el movimiento del CNC ...", 
"body" : "Ver el CNC02_online.project proyecto de ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . El ejemplo muestra cómo usar variables para decodificar un programa CNC. Puesta en servicio Compile e inicie el programa creado. El programa ejecuta el movimiento del CNC tan pronto como Execute Se ha configurado la entrada del decodificador y el interpolador. Si cambia los valores de las variables globales, entonces se utilizan cuando se reinicia el decodificador y la ruta se adapta en consecuencia. Supervise la función del Append entrada del decodificador también. " }, 
{ "title" : "Crear un programa NC en el editor CNC ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_4c86ec04e529c0bcc0a864636a6ae1dc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 02 de CNC: Decodificación en línea con variables \/ Crear un programa NC en el editor CNC ", 
"snippet" : "Crear un CNCOnline programa con un SoftMotion controlador. Cree una lista de variables globales y declare dos variables. VAR_GLOBAL g_x: REAL:=100; g_y:REAL:=50; END_VAR Insertar un Programa CNC objeto nombrado Example . Selecciona el Implementación Din66025 y el Modo de compilación SMC_CNC_REF . Es...", 
"body" : "Crear un CNCOnline programa con un SoftMotion controlador. Cree una lista de variables globales y declare dos variables. VAR_GLOBAL\n g_x: REAL:=100;\n g_y:REAL:=50;\nEND_VAR Insertar un Programa CNC objeto nombrado Example . Selecciona el Implementación Din66025 y el Modo de compilación SMC_CNC_REF . Este modo es necesario porque utiliza variables en su programa. Especifique los siguientes bloques de movimiento: Editor CNC: " }, 
{ "title" : "Creación de una interfaz de accionamiento y configuración de PLC ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_7e9d1704e529c0bcc0a8646343b60bbd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 02 de CNC: Decodificación en línea con variables \/ Creación de una interfaz de accionamiento y configuración de PLC ", 
"snippet" : "Definir una estructura de unidad (p. Ej. CNCdirect )....", 
"body" : "Definir una estructura de unidad (p. Ej. CNCdirect ). " }, 
{ "title" : "Crear un programa IEC ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3989abe9e529c0bcc0a864630f20ee19", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 02 de CNC: Decodificación en línea con variables \/ Crear un programa IEC ", 
"snippet" : "Agregue un POU (CFC) llamado Path a la aplicación. La decodificación del programa NC para OUTQUEUE y la verificación de velocidad se realizan en el Path programa. Vocación SMC_CheckVelocities es requerido. CFC: Agregue un POU (CFC) llamado Ipo a la aplicación. Este programa es casi idéntico al CNCdi...", 
"body" : "Agregue un POU (CFC) llamado Path a la aplicación. La decodificación del programa NC para OUTQUEUE y la verificación de velocidad se realizan en el Path programa. Vocación SMC_CheckVelocities es requerido. CFC: Agregue un POU (CFC) llamado Ipo a la aplicación. Este programa es casi idéntico al CNCdirect proyecto de muestra. Sin embargo, la entrada de datos del interpolador no se corresponde con los nombres de los programas del CNC ( ADR(Example) ), sino a la salida OutQueue de los bloques de funciones de preprocesamiento de ruta ( checkVel.poqDataOut ). " }, 
{ "title" : "Crear una tarea para el preprocesamiento de rutas ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3014d45de529c0bcc0a86463617895a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 02 de CNC: Decodificación en línea con variables \/ Crear una tarea para el preprocesamiento de rutas ", 
"snippet" : "Porque ha seleccionado el modo de compilación SMC_CNC_REF , debe realizar la decodificación y el preprocesamiento de ruta en el programa IEC. Este cálculo requiere mucho tiempo. No es necesario que se ejecute en el ciclo del interpolador porque se genera un objeto de ruta por llamada al decodificado...", 
"body" : "Porque ha seleccionado el modo de compilación SMC_CNC_REF , debe realizar la decodificación y el preprocesamiento de ruta en el programa IEC. Este cálculo requiere mucho tiempo. No es necesario que se ejecute en el ciclo del interpolador porque se genera un objeto de ruta por llamada al decodificador, y este objeto se usa normalmente para muchas llamadas al interpolador. Debe cambiar esta operación a una tarea con baja prioridad y llamadas menos frecuentes. Crear un PathTask tarea. Defina los siguientes parámetros: Prioridad : 10 Intervalo : T # 30 ms Añade el Path POU a la tarea. Tarea \"PathTask\" Mecanismo subyacente: En la tarea lenta, al principio se genera aproximadamente un objeto GEOINFO por ciclo. Este objeto se almacena en la estructura OUTQUEUE del bloque de funciones del decodificador. Si la SALIDA está llena, los bloques de funciones de la tarea lenta se detienen hasta que la SALIDA ya no está llena. Esto sucede tan pronto como la tarea rápida procesa el primer objeto GEOINFO y lo elimina de la SALIDA. Luego, los bloques de función de la tarea lenta se vuelven a activar y llenan la estructura OUTQUEUE. En la tarea rápida, un punto de ruta de la estructura OUTQUEUE, que el DataIn puntos de entrada, se calcula y procesa en cada ciclo. Debido a que un objeto GEOINFO generalmente consta de múltiples puntos de ruta, se necesitan algunos ciclos hasta que el primer objeto GEOINFO sea procesado y eliminado automáticamente por el interpolador. Como el procesamiento de un objeto GEOINFO dura varios ciclos en lugar de su creación, la tarea lenta se puede llamar con menos frecuencia que la tarea rápida. Sin embargo, los tiempos de las tareas deben seleccionarse de modo que siempre se almacenen suficientes objetos GEOINFO en el último OUTQUEUE de la tarea lenta, evitando así la aparición de datos insuficientes. Esto sucede cuando no hay más objetos GEOINFO disponibles para el interpolador desde DataIn y aún no se ha alcanzado el final de la ruta. En este caso, el interpolador se ralentiza y se detiene hasta que los nuevos elementos de datos vuelven a estar disponibles. " }, 
{ "title" : "Creación de una interfaz operativa y una interfaz de prueba ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 02 de CNC: Decodificación en línea con variables \/ Creación de una interfaz operativa y una interfaz de prueba ", 
"snippet" : "La visualización corresponde a la CNCdirect.project proyecto de muestra. Agregue plantillas adicionales a los nuevos bloques de funciones ( SMC_NCDecoder y SMC_CheckVelocities ). Cree una pantalla también para las variables globales g_x y g_y para que pueda comprobar su funcionamiento más tarde en l...", 
"body" : "La visualización corresponde a la CNCdirect.project proyecto de muestra. Agregue plantillas adicionales a los nuevos bloques de funciones ( SMC_NCDecoder y SMC_CheckVelocities ). Cree una pantalla también para las variables globales g_x y g_y para que pueda comprobar su funcionamiento más tarde en la puesta en servicio. " }, 
{ "title" : "Ejemplo 03 de CNC: Realización del preprocesamiento de ruta en línea ", 
"url" : "_sm_example_cnc_3.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 03 de CNC: Realización del preprocesamiento de ruta en línea ", 
"snippet" : "Ver el CNC03_prepro.project proyecto de ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . El ejemplo muestra cómo se puede realizar el preprocesamiento de ruta en línea en el PLC. Extender el CNC02_online proyecto con un preprocesador de ruta. Entonces los ángu...", 
"body" : "Ver el CNC03_prepro.project proyecto de ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . El ejemplo muestra cómo se puede realizar el preprocesamiento de ruta en línea en el PLC. Extender el CNC02_online proyecto con un preprocesador de ruta. Entonces los ángulos del movimiento del CNConline proyecto se redondean mediante splines. Esto se hace con el SMC_SmoothPath bloque de funciones Ampliar el programa CNC: Anexar el programa anterior con los elementos G51\/G50 . Hacer clic CNC → Mostrar ruta preprocesada para que las splines creadas por el preprocesamiento de ruta se muestren en el editor, como en la captura de pantalla a continuación. Monitor: Sin utilizar variables, podría compilar el programa en esta forma como una cola e ingresarlo directamente en el interpolador. Sin embargo, como hay variables disponibles, debe realizar la decodificación y el suavizado de ángulos usted mismo. Declare un nuevo bloque de funciones de tipo SMC_SmoothPath . Llámelo después del decodificador. Configure la entrada de datos del bloque de funciones del interpolador como de costumbre en el poqDataOut salida de la CheckVelocities bloque de funciones. Se debe declarar un nuevo búfer para la entrada SMC_SmoothPath.pbyBufferOutQueue . CFC: Puesta en servicio Compile e inicie el programa creado. A diferencia del programa anterior, este programa ya no se detiene en los ángulos del programa NC porque los ángulos de la trayectoria se han liberado de torceduras mediante el preprocesamiento de la trayectoria. " }, 
{ "title" : "CNC Ejemplo 04: Programación de CNC usando el Editor Tabular ", 
"url" : "_sm_example_cnc_4.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ CNC Ejemplo 04: Programación de CNC usando el Editor Tabular ", 
"snippet" : "Vea el proyecto de ejemplo para esto CNC04_table.project en el directorio de instalación de CODESYS entre ..\\CODESYS SoftMotion\\Examples . En este proyecto está la funcionalidad del proyecto. CNC03_prepro.project programado con el editor de tablas. En contraste con CNC03_prepro.project En este proye...", 
"body" : "Vea el proyecto de ejemplo para esto CNC04_table.project en el directorio de instalación de CODESYS entre ..\\CODESYS SoftMotion\\Examples . En este proyecto está la funcionalidad del proyecto. CNC03_prepro.project programado con el editor de tablas. En contraste con CNC03_prepro.project En este proyecto no se utilizan variables IEC, pero los cálculos se realizan con valores fijos. De lo contrario, la funcionalidad es idéntica. " }, 
{ "title" : "Ejemplo 05 de CNC: Creación de CNC a partir de un archivo ", 
"url" : "_sm_example_cnc_5.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 05 de CNC: Creación de CNC a partir de un archivo ", 
"snippet" : "Ver el CNC05_File.project proyecto de ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Con este proyecto de muestra, puede comprender cómo se lee un programa de código G desde un archivo ASCII que está almacenado en el PLC. El uso de este tipo de archivo tiene...", 
"body" : "Ver el CNC05_File.project proyecto de ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Con este proyecto de muestra, puede comprender cómo se lee un programa de código G desde un archivo ASCII que está almacenado en el PLC. El uso de este tipo de archivo tiene sentido cuando el programa de código G es muy grande. La función del proyecto es similar a la CNC02_online.project proyecto de muestra. Sin embargo, el programa de código G se lee desde un archivo ASCII. No se utilizan variables y el orden de procesamiento es comparable al del CNC02_online.project proyecto de muestra. Se pueden determinar las siguientes diferencias: Unidad virtual adicional (eje z) Bloque funcional smoothpath no requerido Código G leído del archivo Preprocesamiento en línea (ver CNC02_online.project ) " }, 
{ "title" : "Ejemplo 06 de CNC: uso de Path3D con SoftMotion CNC ", 
"url" : "_sm_example_cnc_6.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 06 de CNC: uso de Path3D con SoftMotion CNC ", 
"snippet" : "Ver el CNC06_File_3DPath.project proyecto de ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo amplía el ejemplo anterior. CNC05_File . Demuestra una posible aplicación del elemento de visualización Path3D con CODESYS SoftMotion CNC. Ampliación del...", 
"body" : "Ver el CNC06_File_3DPath.project proyecto de ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo amplía el ejemplo anterior. CNC05_File . Demuestra una posible aplicación del elemento de visualización Path3D con CODESYS SoftMotion CNC. Ampliación del programa CNC_File a CNC_File_Path3D Abre el Gerente de biblioteca y agrega el SM3_CNC_Visu Biblioteca. Crea una instancia de SMC_PathCopierFile en CNC_PreparePath y llamarlo al comienzo del procesamiento de la ruta ( iState=0 ). Programación: En el Visualización visualización, reemplace la visualización gráfica de la posición utilizada anteriormente con la Path3D elemento. Cambiar las propiedades del Path3D elemento: Descripción de la ruta → Datos de la ruta (VisuStruct3DTrack) : CNC_prepare_path.pcf.vs3dt Inserte el Cuadro elemento de visualización. Referencia el Panel de control visualización desde el VisuElem3DPath Biblioteca. Este elemento se utiliza para controlar la posición de la cámara del elemento. En la declaración de la CNC_PreparePath programa, crea una instancia de VisuStruct3DControl ( VisuElem3DPath Biblioteca): vc: VisuStruct3DControl; . Esta instancia forma la interfaz de datos entre el elemento Path3D y el panel de control de la cámara. Cambiar las propiedades del Path3D elemento: Control de cámara → Estructura de datos de control (VisuStruct3DControl) : CNC_PreparePath.vc Cambiar las propiedades del Panel de control elemento: Referencias → VisuElem3DPath.ControlPanel → vc : CNC_PreparePath.vc Compile, descargue e inicie la aplicación. El elemento Path3D muestra la ruta. Puede controlar la posición de la cámara desde el panel. Agregue una instancia del SMC_PositionTracker bloque de funciones en el CNC programa. Crea una memoria para rastrear la pista actual (las últimas posiciones recorridas). pt: SMC_PositionTracker; pointbuffer_pt: ARRAY [0..1000] OF VisuStruct3DPathPoint; Inserte una llamada de la instancia: SMC_PositionTracker en el Interpolation acción CFC: Vincula los datos de la ruta al elemento Path3D. Cambiar las propiedades del Path3D elemento: Descripción de la ruta → Datos de la ruta (VisuStruct3DTrack) : CNC.pt.vs3dt Conéctese e inicie la aplicación. El elemento Path3D muestra la última ruta interpolada también a la ruta. Configurar otras propiedades de Path3D . Por ejemplo, configure los elementos de la ruta procesada para que se muestren en gris: Resaltar → Resaltar color : Gray Proyecto de muestra: \"Generador de ruta 3D\" " }, 
{ "title" : "Ejemplo 07 de CNC: uso de expresiones y subprogramas ", 
"url" : "_sm_example_cnc_7.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 07 de CNC: uso de expresiones y subprogramas ", 
"snippet" : "Vea el proyecto de ejemplo para esto CNC07_Subprogram.project en el directorio de instalación de CODESYS entre ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo llamar a un  subprograma de un archivo CNC, así como el uso expresiones en instrucciones de movimiento CNC. En el CNC programa, lo...", 
"body" : "Vea el proyecto de ejemplo para esto CNC07_Subprogram.project en el directorio de instalación de CODESYS entre ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo llamar a un  subprograma de un archivo CNC, así como el uso expresiones en instrucciones de movimiento CNC. En el CNC programa, los accionamientos se encienden primero, como en los otros ejemplos. los CNC_PreparePath programa utiliza el SMC_ReadNCFile2 bloque de funciones para leer el archivo CNC. SMC_ReadNCFile2 crea el SMC_ReadNCFile POU y lo amplía con soporte para subprogramas y expresiones. El programa CNC CNC2Main.cnc se convierte mediante el SMC_NCInterpreter bloque de funciones. SMC_NCInterpreter crea el SMC_NCDecoder POU y lo amplía con soporte para subrutinas y expresiones. El proyecto contiene dos programas de CNC: el programa principal CNC2Main.cnc y el subprograma CNC2.cnc . El programa principal pasa el valor 25 en el #RADIUS parámetro al subprograma. En el subprograma, la expresión X#RADIUS*2 se utiliza para calcular la trayectoria circular. Programa principal N0 G01 X$g_x$ Y0 F50 E30 E-30\nN10 G01 X0 Y$g_y$\nN20 CNC2{25}\nN30 G01 X0 Y-200 Subprograma SUBPROGRAM CNC2{#RADIUS : LREAL}\nN010 G91\nN020 G02 X#RADIUS*2 Y0 R#RADIUS Z2.5 F100 E-100 E100\nN030 G02 X-#RADIUS*2 Y0 R#RADIUS Z7.5\nEND_SUBPROGRAM " }, 
{ "title" : "CNC Ejemplo 08: Uso de Ejes Adicionales ", 
"url" : "_sm_example_external_axes_usage.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ CNC Ejemplo 08: Uso de Ejes Adicionales ", 
"snippet" : "Ver el CNC08_AdditionalAxes.project proyecto de ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo amplía la CNC01_direct.projekt proyecto que se describe en Ejemplo 01 de CNC: Generación de OutQueue directamente. Demuestra cómo usar ejes adicionale...", 
"body" : "Ver el CNC08_AdditionalAxes.project proyecto de ejemplo en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo amplía la CNC01_direct.projekt proyecto que se describe en Ejemplo 01 de CNC: Generación de OutQueue directamente. Demuestra cómo usar ejes adicionales. Como en el Ejemplo 01 de CNC, se desplazan cuatro posiciones en el plano X\/Y con una velocidad y aceleración definidas. Además, el eje adicional A se ejecuta durante cada movimiento. El programa establece dos puntos de cambio de ruta en la ruta. " }, 
{ "title" : "Edición de un programa CNC en el editor ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4510557821784033079793683298", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ CNC Ejemplo 08: Uso de Ejes Adicionales \/ Edición de un programa CNC en el editor ", 
"snippet" : "Abre el CNC01_direct.project proyecto desde el directorio de instalación de CODESYS . En el proyecto, abra el programa CNC. Example . Agregue posiciones para el eje adicional A a los comandos de viaje: editor CNC N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30 N10 G02 X84.9 Y84.6 A40 R100 H12 L10 N20 G01 X 6.6 ...", 
"body" : "Abre el CNC01_direct.project proyecto desde el directorio de instalación de CODESYS . En el proyecto, abra el programa CNC. Example . Agregue posiciones para el eje adicional A a los comandos de viaje: editor CNC N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30\nN10 G02 X84.9 Y84.6 A40 R100 H12 L10\nN20 G01 X 6.6 Y25.7 A60 H-1 O0.8\nN30 G03 X54.6 Y49.7 A80 R100 " }, 
{ "title" : "Creación de una interfaz de accionamiento y configuración de PLC ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758202758433079807306962", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ CNC Ejemplo 08: Uso de Ejes Adicionales \/ Creación de una interfaz de accionamiento y configuración de PLC ", 
"snippet" : "Insertar una unidad virtual adicional Una vuelta bajo el Grupo de ejes general de SoftMotion . Establezca los parámetros de la siguiente manera:...", 
"body" : "Insertar una unidad virtual adicional Una vuelta bajo el Grupo de ejes general de SoftMotion . Establezca los parámetros de la siguiente manera: " }, 
{ "title" : "Edición de un programa IEC ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758311412833079809057524", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ CNC Ejemplo 08: Uso de Ejes Adicionales \/ Edición de un programa IEC ", 
"snippet" : "Abra el programa CFC Ipo . Activar la unidad agregada anteriormente Una vuelta con el MC_Power bloque de funciones En este ejemplo, un eje de orientación simple ( Una vuelta ) debe controlarse con el eje adicional A. Por este motivo, no se necesitan más módulos de transformación. La posición nominal...", 
"body" : "Abra el programa CFC Ipo . Activar la unidad agregada anteriormente Una vuelta con el MC_Power bloque de funciones En este ejemplo, un eje de orientación simple ( Una vuelta ) debe controlarse con el eje adicional A. Por este motivo, no se necesitan más módulos de transformación. La posición nominal del interpolador se corresponde directamente con la posición nominal del accionamiento y se aplica a través del SMC_POSINFO seleccionador con el SMC_ControlAxisByPos bloque de funciones La aplicación no garantiza que las salidas del interpolador sean continuas. Por ejemplo, la posición del eje adicional termina en un punto diferente al que comienza. Por lo tanto, debe activar la prevención de espacios ( bAvoidGaps , fGapVelocity , fGapAcceleration , y fGapDeceleration ). Luego conecte el bStopIpo salida a la bEmergency_Stop entrada del interpolador y conectar la salida del interpolador iStatus a las respectivas entradas de los bloques de funciones de control de ejes. Sobre todo, preste atención al orden correcto de los bloques de función al programar con CFC. " }, 
{ "title" : "Puesta en marcha ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4584880865328033079813143466", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ CNC Ejemplo 08: Uso de Ejes Adicionales \/ Puesta en marcha ", 
"snippet" : "Compile e inicie el programa creado. El programa ejecuta el movimiento CNC tan pronto como el Execute se ha fijado la entrada del interpolador. Una vez que el programa se haya ejecutado por completo, puede aplicar un nuevo flanco ascendente para reiniciarlo. Durante la ejecución del programa CNC, ob...", 
"body" : "Compile e inicie el programa creado. El programa ejecuta el movimiento CNC tan pronto como el Execute se ha fijado la entrada del interpolador. Una vez que el programa se haya ejecutado por completo, puede aplicar un nuevo flanco ascendente para reiniciarlo. Durante la ejecución del programa CNC, observe la posición del eje adicional A ( piSetPosition.dA ) que se muestra en la visualización del POU de interpolación. " }, 
{ "title" : "Ejemplo 09 de CNC: uso de compensación de longitud de herramienta ", 
"url" : "_sm_example_tool_correction_usage.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 09 de CNC: uso de compensación de longitud de herramienta ", 
"snippet" : "Vea el proyecto de ejemplo para esto CNC09_ToolLengthCorr.project en el directorio de instalación de CODESYS entre ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo usar el bloque SMC_ToolLengthCorr se puede compensar la longitud de una herramienta. Para obtener más información sobre el tem...", 
"body" : "Vea el proyecto de ejemplo para esto CNC09_ToolLengthCorr.project en el directorio de instalación de CODESYS entre ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo usar el bloque SMC_ToolLengthCorr se puede compensar la longitud de una herramienta. Para obtener más información sobre el tema de la compensación de la longitud de la herramienta, consulte: Preprocesamiento" }, 
{ "title" : "Solicitud ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm458488080921763308005489139", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 09 de CNC: uso de compensación de longitud de herramienta \/ Solicitud ", 
"snippet" : "Para el ejemplo, se utiliza una cinemática Gantry3 junto con un eje de orientación adicional ( AxisA ) que puede girar sobre el eje Z. Una herramienta con una longitud de 2 unidades en la dirección Z se adjunta a su vez al eje de orientación. Se debe ejecutar un programa CNC simple. Esto se almacena...", 
"body" : "Para el ejemplo, se utiliza una cinemática Gantry3 junto con un eje de orientación adicional ( AxisA ) que puede girar sobre el eje Z. Una herramienta con una longitud de 2 unidades en la dirección Z se adjunta a su vez al eje de orientación. Se debe ejecutar un programa CNC simple. Esto se almacena en el proyecto como un externo CNC.cnc archivo y se puede abrir con un editor de texto. En el programa CNC, la corrección de la longitud de la herramienta se activa primero mediante código G G43 . los I , J , y K los parámetros corresponden al desplazamiento en las direcciones X, Y y Z para esto. A continuación, se recorren tres puntos en el plano XY. Durante el movimiento al último punto, el eje adicional A también gira 90 grados. N000 G43 I0 J0 K2 (Activate tool length correction with tool offset X=0 Y=0 Z=2)\nN010 G01 X10 F10 E100 E-100\nN020 G03 Y10 R5N030 G01 X0 A90 La aplicación consta de varias partes. En el CNC_PreparePath programa, el programa CNC CNC.cnc se importa como un archivo desde el controlador y se procesa previamente. En el CNC programa, las unidades se encienden primero, como en los otros ejemplos. Luego se realiza la interpolación del programa CNC leído anteriormente. En cada ciclo, el interpolador emite una posición establecida (piSetPosition ) y el corrector actual de la herramienta (adToolLength ). los SMC_ToolLengthCorr POU requiere esta información para compensar la longitud de la herramienta especificada. La posición compensada es luego transformada y finalmente pasada a los ejes por medio del SMC_ControlAxisByPos POU. El programa es casi idéntico a los otros ejemplos. Solo el SMC_ToolLengthCorr Se ha insertado POU después del interpolador y antes de la transformación para procesar la salida de posición establecida por el interpolador. " }, 
{ "title" : "Puesta en marcha ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm4590758219934433080059282556", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo 09 de CNC: uso de compensación de longitud de herramienta \/ Puesta en marcha ", 
"snippet" : "Compile e inicie el programa creado. El programa ejecuta el movimiento CNC en cuanto el CNC_PreparePath.xStart se ha configurado la entrada. Puede hacer clic en el comienzo botón para establecer esta variable en la aplicación o en la visualización. Una vez que el programa se haya ejecutado por compl...", 
"body" : "Compile e inicie el programa creado. El programa ejecuta el movimiento CNC en cuanto el CNC_PreparePath.xStart se ha configurado la entrada. Puede hacer clic en el comienzo botón para establecer esta variable en la aplicación o en la visualización. Una vez que el programa se haya ejecutado por completo, puede aplicar un nuevo flanco ascendente para reiniciarlo. Durante la ejecución del programa CNC, tenga en cuenta las salidas del interpolador ( piSetPosition , adToolLength ) y la posición compensada ( piOut ) del SMC_ToolLengthCorr POU. Nota: La rotación de AxisA durante el último movimiento del programa CNC no tiene ningún efecto (adicional) sobre la posición cartesiana compensada en este ejemplo porque la herramienta solo tiene un desplazamiento en dirección Z. Si agrega un componente al desplazamiento de la herramienta (en el archivo CNC, en el controlador en la carpeta de la aplicación) en dirección X e Y, entonces la rotación de AxisA durante el último movimiento tendrá un efecto adicional sobre la posición compensada. " }, 
{ "title" : "Lectura del estado del interpolador ", 
"url" : "_sm_example_state_interpolator.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Lectura del estado del interpolador ", 
"snippet" : "Vea el CNC13_ReadInterpolatorState.project proyecto de ejemplo en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . El proyecto de ejemplo muestra cómo leer el estado del interpolador CNC. El estado se usa para mostrar la posición de la máquina en las coordenadas de la ...", 
"body" : "Vea el CNC13_ReadInterpolatorState.project proyecto de ejemplo en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . El proyecto de ejemplo muestra cómo leer el estado del interpolador CNC. El estado se usa para mostrar la posición de la máquina en las coordenadas de la máquina y del decodificador " }, 
{ "title" : "Estructura de la solicitud ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234546899564", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Lectura del estado del interpolador \/ Estructura de la solicitud ", 
"snippet" : "La estructura es típica de las aplicaciones de CNC. El código G se lee en la tarea en segundo plano. La interpolación se realiza en la tarea del bus Durante la interpolación, el SMC_ReadAdditionalIpoState bloque de función llamado. Tan pronto como comience la interpolación, el Valid la salida es TRU...", 
"body" : "La estructura es típica de las aplicaciones de CNC. El código G se lee en la tarea en segundo plano. La interpolación se realiza en la tarea del bus Durante la interpolación, el SMC_ReadAdditionalIpoState bloque de función llamado. Tan pronto como comience la interpolación, el Valid la salida es TRUE . La posición del interpolador, que siempre aparece en el sistema de coordenadas de la máquina (MCS), se convierte a continuación utilizando el sistema de coordenadas del decodificador (DCS) actual y SMC_V3_Set(pos_MCS, ipo.piSetPosition.dX, ipo.piSetPosition.dY, ipo.piSetPosition.dZ);\n\nreadState(\n    Enable:= TRUE,\n    ipo:= ipo);\n\nIF readState.Valid THEN\n    SMC_PosInfo_Trf_Inverse(\n        piOut:= piMCS_to_DCS,\n        piIn:= readState.State.DCS,\n        eOriConv:= readState.State.OriConv);\n\n SMC_PosInfo_Trf_Apply(\n        vDst:= pos_DCS,\n        piTrf:= piMCS_to_DCS,\n        vSrc:= pos_MCS,\n        eOriConv:= readState.State.OriConv);\nEND_IF Para obtener más información sobre el sistema de coordenadas del decodificador, consulte lo siguiente: Cambiar, rotar y escalar el sistema de coordenadas. " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234714771807", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Lectura del estado del interpolador \/ Puesta en servicio ", 
"snippet" : "Cree la aplicación y descárguela en un controlador. Abra la visualización. Inicie la aplicación y pulse el Comenzar botón de la visualización. Puede rastrear el movimiento de las coordenadas X e Y en MCS y DCS....", 
"body" : "Cree la aplicación y descárguela en un controlador. Abra la visualización. Inicie la aplicación y pulse el Comenzar botón de la visualización. Puede rastrear el movimiento de las coordenadas X e Y en MCS y DCS. " }, 
{ "title" : "Implementación de un bloque de funciones de preprocesamiento de rutas ", 
"url" : "_sm_example_cnc14_path_preprocessing.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Implementación de un bloque de funciones de preprocesamiento de rutas ", 
"snippet" : "Vea el CNC14_PathPreprocessing.project proyecto de ejemplo en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . El proyecto de ejemplo muestra cómo implementar un nuevo bloque de funciones de preprocesamiento de rutas. El preprocesamiento de rutas se usa generalmente pa...", 
"body" : "Vea el CNC14_PathPreprocessing.project proyecto de ejemplo en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . El proyecto de ejemplo muestra cómo implementar un nuevo bloque de funciones de preprocesamiento de rutas. El preprocesamiento de rutas se usa generalmente para modificar la ruta que se lee del código G. Esto permite implementar funciones como la corrección del radio de la herramienta o el suavizado de esquinas. Sin embargo, también es posible integrar funciones específicas para una máquina o aplicación en particular como un bloque de funciones de preprocesamiento de rutas Para obtener más información sobre el preprocesamiento de rutas, consulte lo siguiente: Preprocesamiento de rutas y tamaños de cola. Para ver un ejemplo de cómo usar un bloque de función de preprocesamiento de rutas, consulte lo siguiente: Ejemplo 03 de CNC: Realización del preprocesamiento de ruta en línea. " }, 
{ "title" : "Limitar el cambio de tangente ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234576416031", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Implementación de un bloque de funciones de preprocesamiento de rutas \/ Limitar el cambio de tangente ", 
"snippet" : "El ejemplo muestra una aplicación de corte 2D. Se debe usar un cuchillo para cortar a lo largo de una trayectoria definida por el código G. El SMC_TRAFO_GantryCutter2 La transformación se usa para determinar el ángulo de la cuchilla en función de la tangente actual de la trayectoria. El desafío es q...", 
"body" : "El ejemplo muestra una aplicación de corte 2D. Se debe usar un cuchillo para cortar a lo largo de una trayectoria definida por el código G. El SMC_TRAFO_GantryCutter2 La transformación se usa para determinar el ángulo de la cuchilla en función de la tangente actual de la trayectoria. El desafío es que la cuchilla no debe girar demasiado rápido, de lo contrario el corte no quedará limpio. La limitación de la velocidad angular de la cuchilla se resuelve en el proyecto de muestra mediante el bloque de funciones de preprocesamiento de rutas recién creado LimitTangentVelocity . Cambia la velocidad de avance en la trayectoria para que la velocidad de cambio de la tangente no supere un valor máximo configurable El código G es un rectángulo simple con esquinas suavizadas. La traza muestra el resultado de la ejecución: la velocidad del eje C, que corresponde a la velocidad de rotación de la cuchilla, se muestra en naranja. Está limitado a 45 °\/s según lo especificado " }, 
{ "title" : "Estructura de la solicitud ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234546899564", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Implementación de un bloque de funciones de preprocesamiento de rutas \/ Estructura de la solicitud ", 
"snippet" : "La estructura es típica de las aplicaciones de CNC. El código G se lee en la tarea en segundo plano y aquí también se realiza el preprocesamiento de la ruta. La interpolación se realiza en El LimitTangentVelocity el bloque de función muestra los pasos y estados necesarios para un bloque de funciones...", 
"body" : "La estructura es típica de las aplicaciones de CNC. El código G se lee en la tarea en segundo plano y aquí también se realiza el preprocesamiento de la ruta. La interpolación se realiza en El LimitTangentVelocity el bloque de función muestra los pasos y estados necesarios para un bloque de funciones de preprocesamiento de rutas. El principio básico es que el bloque de funciones lee, procesa y, a continuación, escribe los elementos de la ruta (tipo SMC_GEOINFO ) de la cola de entrada ( poqDataIn ) a la cola de salida ( poqDataOut ). Los elementos se eliminan de la cola de entrada La lógica para cambiar la velocidad de alimentación se encuentra en las líneas 102-138. ComputeMaxCurvature calcula la curvatura máxima que puede producirse en un elemento de trayectoria determinado. \/\/ Our velocity limitation comes here. This modifies an element from the\n\/\/ input queue and copies the modified element to the output queue.\n\/\/ Finally, the element is removed from the input queue\n\nm_geo := pgeo^; \/\/ Copy the element\n \/\/ Note: the feature flags set in the G-Code with G38\/G39 can be queried\n \/\/ by reading pgo^.dwFeatureFlags, like this:\n IF (SHR(m_geo.dwFeatureFlags, featureFlag) AND 1) = 1 THEN\n     \/\/ feature is turned on\n\n     ok := ComputeMaxCurvature(m_geo, kappa=> kappa_max);\n     IF NOT ok THEN\n         \/\/ Curvature cannot be computed\n         m_state := STATE_ERROR;\n         ErrorID := SMC_INVALID_PARAMETER;\n         OnExit();\n         RETURN;\n     END_IF\n\n     \/\/ Compute maximum allowed path velocity based on maximum curvature\n     \/\/ and maximum allowed angular velocity\n     IF kappa_max = 0 THEN\n         \/\/ No curvature, no limitation necessary\n         vel := m_geo.dVel;\n     ELSE\n         vel := m_maxAngularVelocity_rad \/ kappa_max;\n     END_IF\n\n     IF velMin < 0 OR vel < velMin THEN\n         velMin := vel;\n     END_IF\n\n     \/\/ Set new maximum velocity for the element\n     m_geo.dVel := MIN(m_geo.dVel, vel);\n ELSE\n     \/\/ feature is turned off\n END_IF " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234584108811", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Implementación de un bloque de funciones de preprocesamiento de rutas \/ Puesta en servicio ", 
"snippet" : "Cree la aplicación y descárguela en un controlador. Inicie la aplicación. Abra la traza y descárguela al controlador. Escribe el valor TRUE a las variables Path.bExecute y PLC_PRG.bStart . Puede rastrear el procesamiento del código G en la traza....", 
"body" : "Cree la aplicación y descárguela en un controlador. Inicie la aplicación. Abra la traza y descárguela al controlador. Escribe el valor TRUE a las variables Path.bExecute y PLC_PRG.bStart . Puede rastrear el procesamiento del código G en la traza. " }, 
{ "title" : "Preprocesamiento de archivos de código G de gran tamaño ", 
"url" : "_sm_example_large_c_code.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Preprocesamiento de archivos de código G de gran tamaño ", 
"snippet" : "El CNC15_LargeGCode.project el proyecto de ejemplo se encuentra en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . El proyecto de ejemplo muestra cómo procesar archivos de código G de gran tamaño. Dado que los archivos de gran tamaño son especialmente comunes como sal...", 
"body" : "El CNC15_LargeGCode.project el proyecto de ejemplo se encuentra en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . El proyecto de ejemplo muestra cómo procesar archivos de código G de gran tamaño. Dado que los archivos de gran tamaño son especialmente comunes como salida de los sistemas CAD\/CAM, este caso se muestra a modo Los sistemas CAD\/CAM suelen generar archivos de código G con varios cientos de miles de líneas. Consisten en segmentos lineales muy cortos G1 ), normalmente en el intervalo de 100 micrómetros a un milímetro. Estos segmentos lineales cortos trazan el contorno de la pieza. No forman un camino suave. La tangente normalmente salta entre los segmentos lineales El ejemplo muestra cómo leer estos archivos grandes de manera eficiente con requisitos de memoria constantes y cómo lograr una curva de velocidad suave en una ruta que consta de tantos segmentos lineales cortos. El contorno original de la pieza de trabajo se reconstruye mientras se preprocesa " }, 
{ "title" : "Estructura de la solicitud ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231424931037", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Preprocesamiento de archivos de código G de gran tamaño \/ Estructura de la solicitud ", 
"snippet" : "La estructura es típica de las aplicaciones de CNC. El código G se lee en la tarea en segundo plano PathTask ), y el preprocesamiento de rutas también tiene lugar aquí. La interpolación se realiza en la tarea del bus MainTask )....", 
"body" : "La estructura es típica de las aplicaciones de CNC. El código G se lee en la tarea en segundo plano PathTask ), y el preprocesamiento de rutas también tiene lugar aquí. La interpolación se realiza en la tarea del bus MainTask ). " }, 
{ "title" : "Lectura de archivos de gran tamaño ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425324995", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Preprocesamiento de archivos de código G de gran tamaño \/ Lectura de archivos de gran tamaño ", 
"snippet" : "Para mantener corta la latencia al principio del procesamiento del código G, se utiliza un bucle en la tarea en segundo plano. Para simplificar, se utiliza un contador para la condición de cancelación. Según la aplicación, el código G y el rendimiento del PLC, pueden resultar útiles otras condicione...", 
"body" : "Para mantener corta la latencia al principio del procesamiento del código G, se utiliza un bucle en la tarea en segundo plano. Para simplificar, se utiliza un contador para la condición de cancelación. Según la aplicación, el código G y el rendimiento del PLC, pueden resultar útiles otras condiciones de cancelación, como un temporizador. El ciclo finalizará antes de alcanzar esta condición de cancelación cuando la cola de rutas \/\/ Set this value depending on your other tasks, PLC performance, and G-Code\ncounter := 25;\n\nWHILE counter > 0 AND\n      (poqDataOut = 0 OR_ELSE (NOT poqDataOut^.bFull AND NOT poqDataOut^.bEndOfList))\nDO\n     <Read G-Code and process it>\n\n     counter := counter - 1;\nEND_WHILE Mediante la canalización en el preprocesamiento , incluso los archivos de código G de gran tamaño se pueden leer con requisitos de memoria pequeños y constantes. Los tamaños de las colas se eligen para que sean lo suficientemente grandes como para permitir una previsión suficiente de los bloques de funciones respectivos La cola de salida de SMC_NCInterpreter es también la cola de entrada de SMC_SmoothMerge . Se reservan un total de 128+3 elementos para la cola de salida. 3 es una SMC_OutQueue y quedan 128 para usarse como previsión para SMC_SmoothMerge . SMC_SmoothMerge combina un máximo de 128 segmentos lineales cortos en una sola ranura. La cola de salida de SMC_SmoothMerge es también la cola de entrada de SMC_SmoothPath . SMC_SmoothPath requiere al menos 2 elementos, más una reserva de 3 elementos, como previsión. Si las funciones M se encuentran entre dos elementos suavizados, se necesitarán más elementos según el número de La cola de salida de SMC_SmoothMerge es también la cola de entrada de SMC_Interpolator . Una previsión de 100 elementos es adecuada para la mayoría de las aplicaciones. Para obtener más información, consulte lo siguiente: Preprocesamiento de rutas y tamaños de cola. \/\/\/ Buffer of the interpreter, lookahead for SMC_SmoothMerge\naBufIp : ARRAY[0..130] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothMerge\naBufSmm : ARRAY[0..15] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothPath, lookahead for SMC_Interpolator\naBufSmp : ARRAY[0..99] OF SMC_GeoInfo; " }, 
{ "title" : "Preprocesamiento de segmentos lineales ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425764624", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Preprocesamiento de archivos de código G de gran tamaño \/ Preprocesamiento de segmentos lineales ", 
"snippet" : "El SMC_SmoothMerge bloque funcional garantiza una curva de velocidad suave en los muchos segmentos lineales muy cortos. Combina tantos segmentos lineales consecutivos como sea posible en una sola ranura, manteniendo las tolerancias especificadas. En este ejemplo, se permite una desviación máxima de ...", 
"body" : "El SMC_SmoothMerge bloque funcional garantiza una curva de velocidad suave en los muchos segmentos lineales muy cortos. Combina tantos segmentos lineales consecutivos como sea posible en una sola ranura, manteniendo las tolerancias especificadas. En este ejemplo, se permite una desviación máxima de 0,1 mm en X e Y PARAMETERS.piMaxDifference ). Las figuras muestran el procesamiento paso a paso: Lectura de los segmentos lineales cortos Combinación de varios segmentos lineales en splines mediante SMC_SmoothMerge . Suavizar entre las estrías con SMC_SmoothPath porque, como se ha visto anteriormente, las splines no se conectan tangencialmente entre sí. " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425998344", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Preprocesamiento de archivos de código G de gran tamaño \/ Puesta en servicio ", 
"snippet" : "Cree la aplicación y descárguela en un controlador. Abra la traza y descárguela al controlador. Inicie la aplicación. Puede realizar un seguimiento del procesamiento del código G....", 
"body" : "Cree la aplicación y descárguela en un controlador. Abra la traza y descárguela al controlador. Inicie la aplicación. Puede realizar un seguimiento del procesamiento del código G. " }, 
{ "title" : "Ejemplo CNC 16: Función de sondeo (distancia libre restante) (G31) ", 
"url" : "_sm_example_cnc_16.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo CNC 16: Función de sondeo (distancia libre restante) (G31) ", 
"snippet" : "Vea el CNC16_G31.project proyecto de ejemplo en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . El proyecto de ejemplo muestra cómo utilizar la función de sondeo (distancia restante libre). En el ejemplo, la máquina se mueve en la dirección X hasta que se alcanza una ...", 
"body" : "Vea el CNC16_G31.project proyecto de ejemplo en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . El proyecto de ejemplo muestra cómo utilizar la función de sondeo (distancia restante libre). En el ejemplo, la máquina se mueve en la dirección X hasta que se alcanza una barrera de luz en X=50 . Tan pronto como se alcance la barrera de luz, la máquina debe detenerse. El código G restante debe procesarse a partir de esta posición " }, 
{ "title" : "Estructura de la solicitud ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224424924168", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo CNC 16: Función de sondeo (distancia libre restante) (G31) \/ Estructura de la solicitud ", 
"snippet" : "La estructura es típica de las aplicaciones de CNC. El código G se lee en la tarea en segundo plano PathTask ). El preprocesamiento de rutas también se realiza en esta tarea. La interpolación se realiza en la tarea del bus MainTask ). utiliza el siguiente código G. En bloque N10 , se realiza un posi...", 
"body" : "La estructura es típica de las aplicaciones de CNC. El código G se lee en la tarea en segundo plano PathTask ). El preprocesamiento de rutas también se realiza en esta tarea. La interpolación se realiza en la tarea del bus MainTask ). utiliza el siguiente código G. En bloque N10 , se realiza un posicionamiento rápido para X = 20 . Luego, con la G31 (función de sondeo: despejar el camino restante), se realiza un movimiento X = 100 . Finalmente, en bloque N30 , se realiza un movimiento lineal para X = 20, Y = 50 . N10 G0 X20 F100 E1000 E-1000\nN20 G31 X100\nN30 G1 X20 Y50 La interacción entre el interpolador y el intérprete es particularmente importante para la función de sondeo (borrar la ruta restante). El intérprete decodifica el código G y genera una línea recta a partir de X=20 para X=100 para bloquear N20 . Luego deja de decodificar. El interpolador realiza el movimiento lineal y emite simultáneamente el número de sonda como salida udiActProbe . Para el G31, el número de muestra es siempre 1 En la aplicación, el interpolador se detiene con bQuick_Stop tan pronto como la unidad se desplace más allá de su posición X=50 . (Esto simula la barrera de luz). En la tarea del autobús, el SMC_SetInterpreterStartPosition el bloque de funciones se usa para copiar continuamente la posición actual de la máquina. En el PathTask , la posición inicial se asigna a la entrada SMC_NCInterpreter.piStartPosition : inter(\n    sentences:= read.sentences,\n    bExecute:= read.bExecute,\n    nSizeOutQueue:= SIZEOF(bufIpo),\n    pbyBufferOutQueue:= ADR(bufIpo),\n    piStartPosition:= Main.setStart.StartPos); Tan pronto como se detenga el interpolador, bAcknProbe entrada se usa para confirmar el comando G31. En una aplicación real, también se debe comprobar en este punto que los ejes han alcanzado realmente la posición de parada. SMC_InPosition el bloque de funciones se puede usar para hacer esto. Esto hace que el intérprete reanude la decodificación, pero con la posición de inicio actualizada, de modo que el siguiente bloque N30 se inicia desde la posición X=55.5 . En el siguiente diagrama se muestran estos pasos. Los números entre paréntesis se refieren a los pasos correspondientes del proceso descrito anteriormente. " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224425037675", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo CNC 16: Función de sondeo (distancia libre restante) (G31) \/ Puesta en servicio ", 
"snippet" : "Cree la aplicación y descárguela en un controlador. Abra la traza y descárguela al controlador. Inicie la aplicación y abra la visualización....", 
"body" : "Cree la aplicación y descárguela en un controlador. Abra la traza y descárguela al controlador. Inicie la aplicación y abra la visualización. " }, 
{ "title" : "Ejemplo CNC 17: lectura de código G a partir de cadenas ", 
"url" : "_sm_example_cnc_17.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo CNC 17: lectura de código G a partir de cadenas ", 
"snippet" : "Vea el CNC17_ReadGCodeFromStrings.project proyecto de ejemplo en el directorio de instalación de CODESYS en ..\\CODESYS SoftMotion\\Examples . El proyecto de ejemplo muestra cómo usar SMC_StringStream2 para leer el código G de una cadena. Este ejemplo puede verse como un punto de partida y usarse para...", 
"body" : "Vea el CNC17_ReadGCodeFromStrings.project proyecto de ejemplo en el directorio de instalación de CODESYS en ..\\CODESYS SoftMotion\\Examples . El proyecto de ejemplo muestra cómo usar SMC_StringStream2 para leer el código G de una cadena. Este ejemplo puede verse como un punto de partida y usarse para leer código G de otras fuentes, por ejemplo, a través de la comunicación de red (sockets). En este caso, es necesario implementar un bloque de funciones que implemente SMC_ITextStream interactúa y lee el texto (por ejemplo, desde un socket). Esto es similar a cómo SMC_StringStream2 implementa esta interfaz para leer el código G de una cadena. " }, 
{ "title" : "Estructura de la solicitud ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224424924168", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo CNC 17: lectura de código G a partir de cadenas \/ Estructura de la solicitud ", 
"snippet" : "La estructura es típica de las aplicaciones de CNC. El código G se lee en la tarea en segundo plano PathTask ), y el preprocesamiento de rutas también tiene lugar aquí. La interpolación se realiza en la tarea del bus En el Path programa, el SMC_ReadNCFromStream bloque de funciones se usa para leer e...", 
"body" : "La estructura es típica de las aplicaciones de CNC. El código G se lee en la tarea en segundo plano PathTask ), y el preprocesamiento de rutas también tiene lugar aquí. La interpolación se realiza en la tarea del bus En el Path programa, el SMC_ReadNCFromStream bloque de funciones se usa para leer el código G. Por razones técnicas, no solo es una secuencia de texto SMC_StringStream2 se pasa a este bloque de funciones, pero también a una matriz cuyo tamaño depende del parámetro SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPTH . La primera secuencia de la matriz se usa para el programa principal, mientras que las otras se usan para posibles llamadas a subprogramas Al principio, el programa principal se carga en la primera secuencia de la matriz: \/\/ Load G-Code into first stream\naStringStream[0].Init(sProgramName) ;\naStringStream[0].AppendData(sGCode) ;\naStringStream[0].SetEndOfData() ; Entonces todo está preparado para leer los programas habituales de código G. El ejemplo también muestra cómo se pueden admitir las llamadas a subprogramas Para ello, es necesario crear un bloque de funciones que implemente el SMC_INCLookup interfaz. Este bloque de funciones es responsable de devolver el código G de un subprograma cuando es leído por SMC_ReadNCFromStream . Lookup el método recibe el nombre del subprograma e inicializa una secuencia entrante con el código G: METHOD LookUp : SMC_ERROR\nVAR_IN_OUT CONSTANT\n    programName : STRING;\nEND_VAR\nVAR_INPUT\n    stream : SMC_ITextStream;\nEND_VAR\nVAR\n    i : UDINT ;\n    pStringStream : POINTER TO SMC_StringStream2 ;\nEND_VAR En este ejemplo se busca en una serie de subprogramas. La matriz se define en Path programa como VAR_INPUT : \/\/ The table of subprograms.\n aSubs : ARRAY[0..0] OF SubProgram := [\n            (stName := 'SUB1',\n             stContent := '\nSUBPROGRAM SUB1{#p1 : LREAL, #p2 : LREAL, #p3 : LREAL}\nN10 G1 X#p1\nN20 G1 X#p2\nN30 G1 X#p3\nEND_SUBPROGRAM')\n        ] ; En Lookup , la matriz se repite hasta que se encuentra un subprograma con un nombre coincidente: i := 0 ;\nWHILE i < nNumSPs DO\n IF psp[i].stName = programName THEN\n IF NOT __QUERYPOINTER(stream, pStringStream) OR_ELSE\n pStringStream = 0\n THEN\n \/\/ A stream of the wrong type has been passed by SMC_ReadNCFromStream.\n LookUp := SMC_CNC_INTERNAL_ERROR ;\n ELSE\n pStringStream^.Init(sName := psp[i].stName) ;\n LookUp := pStringStream^.AppendData(psp[i].stContent) ;\n pStringStream^.SetEndOfData() ;\n END_IF\n RETURN ;\n END_IF\n\n i := i + 1 ;\nEND_WHILE\n \n\/\/ No subprogram with name programName has been found in the array psp.\nLookUp := SMC_RNCF_SUBPROGRAM_FILE_NOT_FOUND ; " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224425037675", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo CNC 17: lectura de código G a partir de cadenas \/ Puesta en servicio ", 
"snippet" : "Cree la aplicación y descárguela en un controlador. Abra la visualización. Prensa Comenzar para iniciar el procesamiento del código G....", 
"body" : "Cree la aplicación y descárguela en un controlador. Abra la visualización. Prensa Comenzar para iniciar el procesamiento del código G. " }, 
{ "title" : "Ejemplo de CNC 10: Programación de una ruta de CNC dinámica ", 
"url" : "_sm_example_dynamic_path.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Ejemplo de CNC 10: Programación de una ruta de CNC dinámica ", 
"snippet" : "Vea el proyecto de ejemplo para esto CNC10_DynamicPath.project en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo se puede crear una ruta CNC directamente en la aplicación en tiempo de ejecución, sin alimentar con código G de un objeto de...", 
"body" : "Vea el proyecto de ejemplo para esto CNC10_DynamicPath.project en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo se puede crear una ruta CNC directamente en la aplicación en tiempo de ejecución, sin alimentar con código G de un objeto de programa CNC o un archivo. Cuando se compila este tipo de programa CNC convencional, los datos de ruta se almacenan en un SMC_CNC_Data tipo de estructura de datos. Estos datos internos luego se compilan en estructuras de datos globales específicas según el modo de compilación ( SMC_CNC_REF o SMC_OutQueue ). En modo de compilación SMC_CNC_REF , los datos se almacenan en una matriz de SMC_GEOINFO elementos. La matriz en el código de la aplicación generalmente se pasa a la instancia del bloque de funciones. SMC_NCDecoder . En tiempo de ejecución, los datos se decodifican allí y se almacenan en una estructura de datos global de tipo SMC_OUTQUEUE . Luego se pueden llamar los bloques de funciones de preprocesamiento de ruta. En modo de compilación SMC_OutQueue , una estructura de datos global ( SMC_OUTQUEUE ) es generado directamente . Esta estructura de datos en el código de la aplicación se pasa al interpolador ( SMC_Interpolator instancia de FB). El bloque de funciones SMC_NCDecoder no se llama En modo de compilación EXPEDIENTE , los datos se almacenan en un archivo. Los datos se almacenan como una matriz de elementos de tipo SMC_GEOINFO y corresponden a los datos que se generan en modo compilación SMC_CNC_REF . En lugar de programar la ruta del CNC, puede programar un código de aplicación que instancia una estructura de datos de tipo SMC_OUTQUEUE en tiempo de ejecución y asigna sus valores. Se programa una ruta de CNC que se genera dinámicamente en tiempo de ejecución. Puede pasar la estructura de datos a otras instancias de bloques de funciones (por ejemplo, a los bloques de funciones de preprocesamiento de ruta o al bloque de funciones SMC_Interpolator ). Programación Él CNCDynamicPath proyecto de muestra se encuentra en el directorio de instalación de CODESYS . El proyecto de muestra fue desarrollado a partir de la CNConline proyecto. Incluye el Path programa en lugar del programado gráficamente Example camino. Una estructura de datos de tipo SMC_OUTQUEUE se genera dinámicamente. Declaración: Declarar una estructura de datos de tipo SMC_OUTQUEUE . La estructura de datos contiene los datos de la ruta del CNC y se completa dinámicamente. Ejemplo: QUEUE Asigne memoria para la ruta con la cantidad requerida para SMC_GEOINFO elementos. Ejemplo: BUF Declarar una variable de tipo SMC_GEOINFO con un paso inicial. Ejemplo: GEO Implementación: Un elemento de matriz de tipo de datos SMC_GEOINFO corresponde a un elemento de ruta en el código CNC. Los siguientes pasos deben realizarse para cada elemento con el fin de agregar el elemento al SMC_OUTQUEUE : Cada elemento de la matriz tiene una posición inicial que corresponde a la posición final del elemento de la matriz anterior. Ejemplo: GEO.piStartPos.dX := 0; o GEO.piStartPos := GEO.piDestPos; Determine un tipo de movimiento para cada elemento de la matriz. Ejemplo: GEO.iMoveType := CCLW; o GEO.iMoveType := LIN; Configure los parámetros del tipo de movimiento. Esto no es necesario para todos los tipos de movimiento. Ejemplo: para un arco (tipo de movimiento: CCLW), es necesario configurar las siguientes posiciones: geoinfo_A[i].dP1 := 200; geoinfo_A[i].dP2 := 100; geoinfo_A[i].dP3 := 50; geoinfo_A[i].dT1 := 0; geoinfo_A[i].dT2 := 90; Inserte el cálculo de la posición final. SMC_CalcEndPnt(ADR(GEO)); Inserte el cálculo de la longitud del objeto. SMC_CalcLengthGeo(ADR(GEO)); Guarde el objeto en QUEUE : SMC_AppendObj(POQ:=ADR(QUEUE), PGI:=ADR(GEO)); Cuando la ruta se crea por completo, los marcadores finales deben establecerse: QUEUE-bEndOfList = TRUE; Luego, cuando se llama a un bloque de funciones de preprocesamiento de ruta, es necesario establecer el bit de inicio o fin para InternMark . Ejemplo Ruta CNC con dos elementos de ruta En este ejemplo, las matrices no están definidas con las posiciones X \/ Y. Si este debe ser un ejemplo con dos elementos de ruta como se describe, entonces estas matrices tendrían que tener dos elementos cada una. Por ejemplo, derivado del proyecto de muestra: xp:ARRAY[1..2] OF REAL:= [100,50]; yp:ARRAY[1..2] OF REAL:= [0,100]; PROGRAM Path\nVAR\n iState : INT;\n QUEUE : SMC_OUTQUEUE;\n BUF : ARRAY[0..49] OF SMC_GEOINFO;\n \/\/ Memory allocation\n GEO : SMC_GEOINFO:=(dT1:=0, dT2:=1, dToolRadius:=0, dVel:=100, dVel_End:=100, dAccel:=200, dDecel:=500, iObj_Nr:=0);\n \/\/ Initial path element\n n : INT := 0;\n QUEUE.nSize := SIZEOF(BUF);\nEND_VAR\n\nCASE iState OF\n0:\n QUEUE.pbyBuffer := ADR(BUF[0]);\n \/\/ Initialize QUEUE\n SMC_SetQueueCapacity(ADR(QUEUE), SIZEOF(BUF));\n iState := iState + 1;\n\n1:\n \/\/ Fill QUEUE\n WHILE NOT QUEUE.bFull DO\n \/\/ When QUEUE is full, wait until it has been processed by the following FBs\n n := n + 1;\n GEO.iSourceLine_No := n;\n GEO.piStartPos := GEO.piDestPos;\n \/\/ Copying last destination\n GEO.iMoveType := LIN;\n \/\/ Generating linear movement\n GEO.iObjNo := GEO.iObjNo + 1;\n \/\/ Calculating number\n GEO.piDestPos.dX := xp[n];\n \/\/ Generatint position\n GEO.piDestPos.dY := yp[n];\n SMC_CalcLengthGeo(pg := ADR(GEO));\n \/\/ Calculating length of object with the help of the standard function\n SMC_AppendObj(poq:=ADR(QUEUE), pgi:=ADR(GEO));\n \/\/ Appending object to QUEUE\n IF n = SIZEOF(xp)\/SIZEOF(xp[1]) THEN\n \/\/ All target positions processed\n QUEUE.bEndOfList := TRUE;\n n := 0;\n iState := 2;\n EXIT;\n END_IF\n END_WHILE\n\n2:\n \/\/Done\n ;\nEND_CASE\n\nCheckVel(bExecute:=TRUE , poqDataIn:=ADR(queue)); \/\/ Preprocessing Si el SMC_OUTQUEUE la estructura de datos está poblada con SMC_GEOINFO datos y el elemento de estructura de datos se estableció en bFULL = TRUE , entonces no recomendamos una asignación adicional de SMC_GEOINFO datos. En este caso, la creación de la ruta se interrumpe en tiempo de ejecución hasta que el primer elemento del SMC_OUTQUEUE La estructura de datos se procesa en el interpolador. Solo entonces se inserta otro elemento. Evite esta interrupción asignando suficiente memoria. Ver variable BUF . Si la estructura de datos SMC_OUTQUEUE se vuelve a llenar después de la primera ejecución, luego el interpolador y todos los bloques de funciones de preprocesamiento (ejemplo: SMC_CheckVelocities ) tienen que ser reiniciados por un flanco ascendente en Execute . " }, 
{ "title" : "Usar la búsqueda de bloques ", 
"url" : "_sm_example_using_block_search.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Usar la búsqueda de bloques ", 
"snippet" : "Una búsqueda de bloque permite que la interpolación continúe después de una interrupción. La posición de parada se recorre primero y el camino se recorre sin cambios desde esta posición. Para ello, se debe ampliar el programa que realiza la interpolación y el programa que realiza el preprocesamiento...", 
"body" : "Una búsqueda de bloque permite que la interpolación continúe después de una interrupción. La posición de parada se recorre primero y el camino se recorre sin cambios desde esta posición. Para ello, se debe ampliar el programa que realiza la interpolación y el programa que realiza el preprocesamiento de la ruta. Ejemplo Un cabezal de fresado interrumpido detiene el recorrido. Después de ser reparado, la ruta se puede continuar con la búsqueda de bloques. Extienda la aplicación por Instancia de bloque de función en la tarea de interpolación que guarda la posición de preprocesamiento Instancia de bloque de funciones en la tarea de ruta que acorta un elemento de ruta Para obtener más información, consulte: SMC_BlockSearchSavePos, SMC_BlockSearchPos y SMC_BlockSearch Usando la búsqueda de bloques Una instancia de la SMC_Búsqueda de bloque El bloque de funciones debe llamarse en la misma tarea que el preprocesamiento de la ruta restante, generalmente directamente antes del SMC_CheckVelocities bloque de funciones Si existe un flanco ascendente en bExecute , luego se realiza una búsqueda de bloque. Después de comenzar, se recorre la posición guardada y la ruta se recorre sin cambios desde esta posición. Declare una instancia del SMC_BlockSearch bloque de función en el programa que realiza el preprocesamiento de ruta. bs: SMC_BlockSearch; Implementar la activación del bExecute entrada de la SMC_BlockSearch ejemplo. La posición guardada previamente con el SMC_BlockSearchSavePos El bloque de funciones tiene que ser pasado como el epos entrada de la SMC_BlockSearch bloque de funciones Ejemplo: búsqueda de bloque en el preprocesamiento de ruta PROGRAM CNC_PreparePath\n...\nVAR\n bs: SMC_BlockSearch;\nEND_VAR\n...\nbs(\n ePos:=CNC.bssp.ePos ,\n bExecute:=rncf.bExecuteDecoder ,\n bAbort:= ,\n bAppend:= ,\n poqDataIn:=ncd.poqDataOut ,\n bStartFromSavedPos:=CNC.bssp.bPositionStored ,\n nSizeOutQueue:=SIZEOF(agiBufBlockSearch) ,\n pbyBufferOutQueue:=ADR(agiBufBlockSearch) ,\n bDone=> ,\n bBusy=> ,\n bError=> ,\n wErrorID=> ,\n poqDataOut=> ); los bStartFromSavedPos La entrada también se puede activar con una variable de control. La variable de control se puede activar después de una cancelación para continuar nuevamente en la última posición guardada. " }, 
{ "title" : "Guardar la posición de preprocesamiento ", 
"url" : "_sm_example_using_block_search.html#UUID-c7e93ecd-388f-baf1-4162-0ba994d84585_id_defc89f86dbffeecc0a86463490ce87e_id_04188a3f3bea4adbc0a8640e000b4984", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Usar la búsqueda de bloques \/ Guardar la posición de preprocesamiento ", 
"snippet" : "Puedes usar el SMC_BlockSearchSavePos bloque de función para guardar la posición actual en el comando. En este momento, la instancia del bloque de funciones debe ejecutarse en la tarea del interpolador. El programa interpolador del ejemplo se denomina \"CNC\". Declare una instancia del SMC_BlockSearch...", 
"body" : "Puedes usar el SMC_BlockSearchSavePos bloque de función para guardar la posición actual en el comando. En este momento, la instancia del bloque de funciones debe ejecutarse en la tarea del interpolador. El programa interpolador del ejemplo se denomina \"CNC\". Declare una instancia del SMC_BlockSearchSavePos bloque de función en el programa que realiza la interpolación. bssp: SMC_BlockSearchSavePos; Conecta el ipo entrada de la SMC_BlockSearchSavePos instancia a la instancia del interpolador. Conecta el bExecute entrada a una variable de control que se establece en la aplicación cuando se cancela el programa CNC (por ejemplo, si el bAbort se configuró la entrada de la instancia SMC_Interpolator). La posición almacenada en el ePos La salida se utiliza de la siguiente manera para la búsqueda de bloques mediante SMC_BlockSearc . Después de la interrupción, bExecute debe reiniciarse con un flanco ascendente. Ejemplo Parte del programa que realiza la interpolación con la instancia del SMC_BlockSearchSavePos bloque de función en CFC. " }, 
{ "title" : "ReadNCFile2 con modificador de token ", 
"url" : "_sm_example_readncfile2_token_modifier.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ ReadNCFile2 con modificador de token ", 
"snippet" : "El CNC12_TokenModifier.project el proyecto de ejemplo se encuentra en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . En este ejemplo se muestra cómo modificar el código G durante la importación para convertir la unidad de velocidad de trayectoria (palabra F) de mm\/mi...", 
"body" : "El CNC12_TokenModifier.project el proyecto de ejemplo se encuentra en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . En este ejemplo se muestra cómo modificar el código G durante la importación para convertir la unidad de velocidad de trayectoria (palabra F) de mm\/min a mm\/s. Esto se hace insertando el código G 1\/60.0 * antes del valor de velocidad mientras se lee el código G de la palabra F. F6000 luego se convierte F 1\/60.0 * 6000 , que posteriormente es procesado por el SMC_NCInterpreter bloque de función para F100 . En casos simples, puedes saltarte la multiplicación por 1\/60 y simplemente ajusta el valor (por ejemplo, desde 6000 para 100 ). Sin embargo, la multiplicación es más general porque también funciona cuando se usan variables F $SPEED$ se convierte F 1\/60.0 * $SPEED$ . " }, 
{ "title" : "Estructura de la solicitud ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818233271", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ ReadNCFile2 con modificador de token \/ Estructura de la solicitud ", 
"snippet" : "Como es habitual en las aplicaciones de CNC, la aplicación consiste en el procesamiento de rutas ( CNC_PreparePath programa) e interpolación ( CNC programa). Debido a que la interpolación no es diferente de los otros ejemplos, no se analizará más aquí El procesamiento de rutas se llama cíclicamente ...", 
"body" : "Como es habitual en las aplicaciones de CNC, la aplicación consiste en el procesamiento de rutas ( CNC_PreparePath programa) e interpolación ( CNC programa). Debido a que la interpolación no es diferente de los otros ejemplos, no se analizará más aquí El procesamiento de rutas se llama cíclicamente cada 20 ms en la prioridad baja PathTask . La interpolación se llama cíclicamente cada 4 MotionTask . La tarea en segundo plano VISU_TASK está definido para la visualización. Puede empezar a procesar el código G en la visualización. El código G y el movimiento de la máquina (pórtico 3D) se muestran en el lado derecho de la " }, 
{ "title" : "El código G ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818432406", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ ReadNCFile2 con modificador de token \/ El código G ", 
"snippet" : "CNC_PathSpeed N10 G01 X1000 F6000 N20 Y1000 En este código G, la velocidad de la trayectoria en bloque N10 está configurado con F6000 a 6000 mm\/min. Sin embargo, los bloques de funciones del CNC esperan la velocidad de trayectoria en mm\/s. Se ordenan dos movimientos lineales, primero X=1000 y luego ...", 
"body" : "CNC_PathSpeed N10 G01 X1000 F6000\nN20 Y1000 En este código G, la velocidad de la trayectoria en bloque N10 está configurado con F6000 a 6000 mm\/min. Sin embargo, los bloques de funciones del CNC esperan la velocidad de trayectoria en mm\/s. Se ordenan dos movimientos lineales, primero X=1000 y luego a X=1000, Y=1000 . " }, 
{ "title" : "Procesamiento de tokens ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819460923", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ ReadNCFile2 con modificador de token \/ Procesamiento de tokens ", 
"snippet" : "El SMC_ReadNCFile2 y SMC_ReadNCFromStream los bloques de funciones proporcionan la capacidad de realizar sus propias transformaciones cuando se lee el código G. Aquí lo estamos usando con SMC_ITokenModifier interfaz, que se pasa a través de aTokenModifier entrada. Esta interfaz funciona con «tokens»...", 
"body" : "El SMC_ReadNCFile2 y SMC_ReadNCFromStream los bloques de funciones proporcionan la capacidad de realizar sus propias transformaciones cuando se lee el código G. Aquí lo estamos usando con SMC_ITokenModifier interfaz, que se pasa a través de aTokenModifier entrada. Esta interfaz funciona con «tokens». Estas son las partes básicas del código G en las que se subdivide el texto del código G cuando se inicia el procesamiento Ejemplo N50 G36 O$plc_variable$ D'TextTest' X-1 (Comment) Este código G se subdivide de la siguiente manera: Texto SMC_TOKENTYPE SMC_TOKENVALUE N identifer stValue = 'N' 50 number fValue = 50.0 G identifer stValue = 'G' 36 number fValue = 36.0 O identifer stValue = 'O' $plc_variable$ variable stValue = 'plc_variable' D identifer stValue = 'D' 'TextTest' strLiteral stValue = 'TextTest' X identifer stValue = 'X' - operator stValue = '-' 1 number fValue = 1.0 La información que no es necesaria para un procesamiento posterior (por ejemplo, espacios en blanco, saltos de línea y comentarios) no aparece en la lista de fichas. Cuando el SMC_ITokenModifier está implementada la interfaz, la lista de tokens se puede adaptar añadiendo nuevos tokens, eliminando tokens y cambiando los valores de los tokens. La interfaz define dos métodos: Start : Inicialización del bloque de funciones. Se restablece el estado interno Call : Llamada a este método mientras se procesa el código G. Los tokens pueden leerse y eliminarse de la cola de entrada y añadirse a la cola de salida " }, 
{ "title" : "Implementación ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819739016", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ ReadNCFile2 con modificador de token \/ Implementación ", 
"snippet" : "El flujo de procesamiento en PLC_PRG es el siguiente: Todos los tokens se mueven de la cola de entrada a la cola de salida. Si se detecta una palabra con F, entonces dos símbolos nuevos, 1\/60 y * , se añaden después del símbolo de «F» y antes del símbolo del valor de velocidad. El Call El método con...", 
"body" : "El flujo de procesamiento en PLC_PRG es el siguiente: Todos los tokens se mueven de la cola de entrada a la cola de salida. Si se detecta una palabra con F, entonces dos símbolos nuevos, 1\/60 y * , se añaden después del símbolo de «F» y antes del símbolo del valor de velocidad. El Call El método contiene la lógica para procesar los tokens. Es útil mover primero los tokens de la cola de entrada tokensIn ) a una cola temporal ( m_tmpQueue ), procesarlos allí y, a continuación, moverlos a la cola de salida ( tokensOut ). La cola temporal no es absolutamente necesaria para adaptar la velocidad de la ruta, pero simplifica la estructura del programa en casos más complicados Método: Llamar Al principio, el sistema espera en STATE_RUNNING estado hasta que se pueda iniciar el procesamiento (cuando los tokens estén disponibles en la cola de entrada y aún haya espacio en la cola de salida). IF NOT SMC_NC_CanProcessTokens(tokensIn, tokensOut) THEN\n    \/\/ Wait until processing can proceed\n    RETURN;\nEND_IF Luego, un token se mueve de la cola de entrada a la cola temporal. IF m_tmpQueue.IsEmpty() THEN\n    \/\/ Move the next token from the in-queue to the tmp-queue.\n  pt := tokensIn.GetFromStart(0);\n    m_tmpQueue.Append(pt^);\n    tokensIn.RemoveFirst();\nEND_IF El procesamiento real se realiza en ConvertSpeed método. IF NOT m_tmpQueue.IsEmpty() THEN\n    \/\/ The actual processing is done here\n    ConvertSpeed();\nEND_IF Al final del método, un token se mueve de la cola temporal a la cola de salida. Método: ConvertSpeed Se comprueba el primer token de la cola temporal. Si es un identificador con el valor F se encuentra, luego se agregan dos fichas adicionales: el número 1\/60.0 y el operador * . (El tamaño de la cola temporal se selecciona de forma que quepan dos fichas más en la cola además del único token de la cola de entrada). tk := m_tmpQueue.GetFromStart(0)^;\n\nIF tk.tokenType = SMC_TokenType.identifier THEN\n tk.GetString(pbyString => pby, iSize => iSize);\n \/\/ 70 = ASCII code for F (path velocity)\n IF iSize = 1 AND pby^ = 70 THEN\n \/\/ Insert the number 1\/60\n SMC_Token_InitNumber(\n tk:= tkNumber,\n value:= 1\/60.0,\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkNumber);\n\n \/\/ Insert operator '*' for multiplication\n SMC_Token_InitOperator(\n tk:= tkOperator,\n value:= '*',\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkOperator);\n END_IF\nEND_IF " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869820021001", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ ReadNCFile2 con modificador de token \/ Puesta en servicio ", 
"snippet" : "Cree la aplicación y descárguela en un controlador. Inicie la aplicación, cambie a la visualización y pulse Start ....", 
"body" : "Cree la aplicación y descárguela en un controlador. Inicie la aplicación, cambie a la visualización y pulse Start . " }, 
{ "title" : "Funciones de código G específicas del usuario ", 
"url" : "_sm_custom_g_code_functions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Funciones de código G específicas del usuario ", 
"snippet" : "El CNC11_CustomFunctions.project el proyecto de ejemplo se encuentra en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . En este ejemplo se muestra cómo crear sus propias funciones para usarlas en expresiones en código G. Para obtener más información acerca de las expr...", 
"body" : "El CNC11_CustomFunctions.project el proyecto de ejemplo se encuentra en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . En este ejemplo se muestra cómo crear sus propias funciones para usarlas en expresiones en código G. Para obtener más información acerca de las expresiones y funciones en el código G, consulte: Expresiones. Allí encontrará una lista de todos los operadores y funciones compatibles de forma predeterminada. El ejemplo define la SEL operador de IEC 61131-3 para que también se pueda usar en código G. " }, 
{ "title" : "Estructura de la solicitud ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867931475267", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Funciones de código G específicas del usuario \/ Estructura de la solicitud ", 
"snippet" : "Como es habitual en las aplicaciones de CNC, la aplicación consiste en el procesamiento de rutas ( CNC_PreparePath programa) e interpolación ( CNC programa). Debido a que la interpolación no difiere de los otros ejemplos, el tema no se discutirá más aquí El procesamiento de rutas se llama cíclicamen...", 
"body" : "Como es habitual en las aplicaciones de CNC, la aplicación consiste en el procesamiento de rutas ( CNC_PreparePath programa) e interpolación ( CNC programa). Debido a que la interpolación no difiere de los otros ejemplos, el tema no se discutirá más aquí El procesamiento de rutas se llama cíclicamente cada 20 ms en la prioridad baja PathTask . La interpolación se llama cíclicamente cada 4 MotionTask . La tarea en segundo plano VISU_TASK está definido para la visualización. En la visualización, puede empezar a procesar el código G y establecer el valor de la variable $LONGLINE$ . El código G y el movimiento de la máquina (pórtico 3D) se muestran en el lado derecho de la " }, 
{ "title" : "El código G ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867932695176", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Funciones de código G específicas del usuario \/ El código G ", 
"snippet" : "CNC LET #WIDTH : LREAL N10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110) N20 F50 E100 E-100 N30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2 N40 Y-#WIDTH N50 X-#WIDTH Z-#WIDTH\/2 N60 Y#WIDTH N70 X0 Y0 Z0 Línea 1: Declaración de la variable local #WIDTH de tipo LREAL . Línea 2, bloque N10: Asignación del valor de SEL($LONG...", 
"body" : "CNC LET #WIDTH : LREAL\nN10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110)\nN20 F50 E100 E-100\nN30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2\nN40 Y-#WIDTH\nN50 X-#WIDTH Z-#WIDTH\/2\nN60 Y#WIDTH\nN70 X0 Y0 Z0 Línea 1: Declaración de la variable local #WIDTH de tipo LREAL . Línea 2, bloque N10: Asignación del valor de SEL($LONGLINE$, 40, 110) a la variable #WIDTH . Si el valor de la variable PLC $LONGLINE$ es TRUE , entonces el valor de la expresión es 110; de lo contrario, es 40. En las siguientes líneas, se recorre un rectángulo con movimiento adicional en la dirección Z; la longitud de un lado del rectángulo es 2*#WIDTH . " }, 
{ "title" : "Implementación del SEL función ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867935164437", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Funciones de código G específicas del usuario \/ Implementación del SEL función ", 
"snippet" : "Para crear una función definida por el usuario, debe escribir un bloque de funciones que implemente el SMC_NC_IFunction interfaz. Para obtener más información, consulte: Función SMC_NC_I . La interfaz define dos métodos: GetSignature . Aquí se devuelven el tipo de retorno, el recuento y los tipos de...", 
"body" : "Para crear una función definida por el usuario, debe escribir un bloque de funciones que implemente el SMC_NC_IFunction interfaz. Para obtener más información, consulte: Función SMC_NC_I . La interfaz define dos métodos: GetSignature . Aquí se devuelven el tipo de retorno, el recuento y los tipos de argumentos de la función. En este ejemplo, el SEL la función devuelve un valor de tipo T_OTHER y tiene 3 argumentos de tipo T_BOOL , T_OTHER , y T_OTHER . T_OTHER representa cualquier tipo (ya sea T_BOOL , T_LREAL , o T_STRING ]. Las 3 apariciones de T_OTHER debe ser del mismo tipo. METHOD GetSignature\nVAR_OUTPUT\n    resultType : SMC_GVar_Type;\n    nNumArguments : UDINT;\n    pType : POINTER TO SMC_GVar_Type;\nEND_VAR\nVAR    argTypes : ARRAY[0..2] OF SMC_GVar_Type :=\n        [SMC_GVar_Type.T_BOOL,\n         SMC_GVar_Type.T_OTHER,\n         SMC_GVar_Type.T_OTHER];\nEND_VAR\n\nresultType := SMC_GVAR_Type.T_OTHER;\nnNumArguments := 3;\npType := ADR(argTypes); Call : Este método se invoca cuando se procesa el código G. Los argumentos se transmiten a través del pa entrada. La expresión pa[0].argValue.bValue se usa para acceder al valor booleano del primer argumento. Según el tipo del segundo argumento pa[1].argType , el resultado es el valor devuelto result.argType y la bifurcación en una sentencia CASE. METHOD Call\nVAR_IN_OUT\n    result : SMC_NC_GArgument;\nEND_VAR\nVAR_INPUT\n    pa : POINTER TO SMC_NC_GArgument;\nEND_VA\nRVAR_OUTPUT\n    eError : SMC_ERROR;\nEND_VAR\nVAR\n    g : BOOL;\nEND_VAR\n\ng := pa[0].argValue.bValue;\n\nresult.argType := pa[1].argType;\n\nCASE result.argType OF\nSMC_GVAR_Type.T_BOOL:\n    result.argValue.bValue := SEL(g, pa[1].argValue.bValue, pa[2].argValue.bValue);\n\nSMC_GVAR_Type.T_STRING:\n    result.argValue.sValue := SEL(g, pa[1].argValue.sValue, pa[2].argValue.sValue);\n\nSMC_GVAR_Type.T_LREAL:\n    result.argValue.fValue := SEL(g, pa[1].argValue.fValue, pa[2].argValue.fValue);\n\nELSE\n    eError := SMC_INVALID_PARAMETER;\nEND_CASE " }, 
{ "title" : "Configuración de SMC_ReadNCFile2 ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867956933133", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Funciones de código G específicas del usuario \/ Configuración de SMC_ReadNCFile2 ", 
"snippet" : "Una instancia del CNC_Sel el bloque de función se crea en GVL_CNCFunctions lista global de variables. Una matriz aCNCFunctions de longitud 1 se inicializa con el nombre y la instancia del bloque de funciones. A continuación, esta matriz se vincula a la tabla funTable de tipo SMC_NC_GFunctionTable . ...", 
"body" : "Una instancia del CNC_Sel el bloque de función se crea en GVL_CNCFunctions lista global de variables. Una matriz aCNCFunctions de longitud 1 se inicializa con el nombre y la instancia del bloque de funciones. A continuación, esta matriz se vincula a la tabla funTable de tipo SMC_NC_GFunctionTable . aCNCFunctions : ARRAY[0..0] OF SMC_NC_GFunction :=\n    [(stName:= 'SEL', iFunc:= GVL_CNCFunctions.g_Sel)];\n\nfunTable : SMC_NC_GFunctionTable :=\n    (numFunctions:= 1,     pFunction:= ADR(aCNCFunctions)) ; Por último, esta tabla se pasa al SMC_ReadNCFile2 bloque de funciones: rncf2 : SMC_ReadNCFile2 := (bParenthesesAsComments:= FALSE);\n\n[...]\n\nrncf2(\n    bExecute:= TRUE,\n    sFileName:= sFileName,\n    pCustomFunTable:= ADR(funTable),\n    pvl:= ADR(varList)); " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867960408693", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Ejemplos \/ Funciones de código G específicas del usuario \/ Configuración de SMC_ReadNCFile2 \/ Puesta en servicio ", 
"snippet" : "Cree la aplicación y descárguela en un controlador. Inicie la aplicación, cambie a la visualización y pulse Start . Puedes usar el Longline botón de radio para establecer el valor de la variable $LONGLINE$ en el código G para TRUE o FALSE ....", 
"body" : "Cree la aplicación y descárguela en un controlador. Inicie la aplicación, cambie a la visualización y pulse Start . Puedes usar el Longline botón de radio para establecer el valor de la variable $LONGLINE$ en el código G para TRUE o FALSE . " }, 
{ "title" : "Interfaz de usuario ", 
"url" : "_sm_cnc_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comando: Analizar Dinámica ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Analizar Dinámica ", 
"snippet" : "Analizar dinámica Función : El comando inicia un análisis dinámico de la ruta del CNC activa en el editor. Al mismo tiempo, las dimensiones de posición, velocidad, aceleración y tirón de la trayectoria del CNC se determinan en función del tiempo y se muestran en los gráficos de tiempo del Análisis d...", 
"body" : "Analizar dinámica Función : El comando inicia un análisis dinámico de la ruta del CNC activa en el editor. Al mismo tiempo, las dimensiones de posición, velocidad, aceleración y tirón de la trayectoria del CNC se determinan en función del tiempo y se muestran en los gráficos de tiempo del Análisis de dinámica diálogo. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Para realizar un análisis dinámico de la trayectoria del CNC, no debe haber errores en el cálculo del preprocesamiento de su trayectoria. Para más información, ver: Mostrar ruta preprocesada" }, 
{ "title" : "Diálogo: Análisis de Dinámica ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html#UUID-172573a8-7bc5-69ee-931b-3074ace95453_id_f14ff69a244133a5c0a8640e0144954d_id_72da7ed158aa22a9c0a864637a09d164", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Analizar Dinámica \/ Diálogo: Análisis de Dinámica ", 
"snippet" : "Los ajustes del cuadro de diálogo se utilizan exclusivamente para mostrar el análisis dinámico y no tienen ningún efecto sobre el programa del CNC o los ajustes del CNC. En el análisis de dinámica, las curvas de tiempo para las dimensiones de posición, velocidad, aceleración y tirón se determinan pa...", 
"body" : "Los ajustes del cuadro de diálogo se utilizan exclusivamente para mostrar el análisis dinámico y no tienen ningún efecto sobre el programa del CNC o los ajustes del CNC. En el análisis de dinámica, las curvas de tiempo para las dimensiones de posición, velocidad, aceleración y tirón se determinan para toda la trayectoria recorrida. Los gráficos de tiempo se muestran en el cuadro de diálogo en el mismo eje de tiempo. Se utilizan los ajustes del cuadro de diálogo (predeterminados o guardados). Gráfico de posición Curva de posición del eje seleccionado (negro) Circulo rojo; indica el comienzo de un elemento de ruta La información sobre herramientas del marcador proporciona información sobre los números de línea en el código G respectivo o en la tabla. Gráfico de velocidad Curva de velocidad del eje seleccionado (azul) Gráfico de aceleración Curva de aceleración del eje seleccionado (verde) Gráfico de tirones Curva de tirón del eje seleccionado (naranja) La configuración se guarda cuando se cierra y se utiliza la próxima vez que se abre el cuadro de diálogo. Por ejemplo, el factor de zoom hace visible solo una parte de la curva. Amplía una parte de las curvas de tiempo. Alternativa: control + + control + Rueda de ratón Aleja las curvas de tiempo Alternativa: control + - control + Rueda de ratón Amplía las curvas de tiempo para que se muestren todas las trayectorias del CNC. Eje Selección de ejes: X , Y , Z , A , B , C , A1(P) , A2(Q) , A3 (U) , A4(V) , A5(W) , A6 , o Sendero Preestablecido: X eje Sendero eje: visualización de la posición de la trayectoria, la velocidad de la trayectoria, la aceleración de la trayectoria y el tirón de la trayectoria Tiempo de ciclo [µs] Valor para el dwIpoTime entrada de la SMC_Interpolator bloque de funciones Preestablecido: Valor Tiempo de ciclo [µs] en objeto Configuraciones CNC (pestaña Preinterpolación ) Modo de velocidad Valor para el iVelMode entrada de la SMC_Interpolador bloque de funciones Trapezoide Perfil de velocidad trapezoidal Sigmoideo Igual que Trapezoide , pero los bordes ascendentes o descendentes son reemplazados por funciones sen² de la misma superficie. En este modo de velocidad, el valor límite se excede en aproximadamente un factor de π \/ 2. Sigmoide limitado Igual que Sigmoideo , pero la duración de la interpolación de la ruta es la misma que en el modo de velocidad Trapezoide . Defecto Cuadrático Perfil de aceleración en forma trapezoidal con limitación de tirones El tirón alcanza un valor máximo en Sacudida máxima [u \/ s³] . Esto da como resultado un perfil de velocidad cuadrático. El perfil de posición consta de polinomios de tercer grado. El resultado es que el perfil de velocidad consta de parábolas, la aceleración consta de segmentos lineales y el tirón consta de segmentos de línea horizontal. Sacudida máxima [u \/ s³] Limitación de tirones " }, 
{ "title" : "Comando: Importar desde archivo DXF ", 
"url" : "_sm_cmd_cnc_dxf_import.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Importar desde archivo DXF ", 
"snippet" : "Importar desde archivo DXF Función : El comando abre el cuadro de diálogo predeterminado. Después de seleccionar el archivo, el Importar archivo DXF Se abre el cuadro de diálogo para configurar la importación de un archivo DXF en el editor CNC. Llama : CNC menú Requisito : Hay un objeto CNC abierto ...", 
"body" : "Importar desde archivo DXF Función : El comando abre el cuadro de diálogo predeterminado. Después de seleccionar el archivo, el Importar archivo DXF Se abre el cuadro de diálogo para configurar la importación de un archivo DXF en el editor CNC. Llama : CNC menú Requisito : Hay un objeto CNC abierto en el editor. Restricciones del estándar DXF en la importación de archivos SPLINE los elementos no se importan exactamente. Estos splines cardinales solo leen y colocan los puntos de control. No se admiten referencias externas. (Estas son referencias a otros archivos DXF en un BLOCK elemento.) Las elipses solo se admiten en la medida en que existan en el plano X \/ Y. Arcos (elemento ARC ) y círculos (elemento CIRCLE ) se admiten solo cuando la escala es igual en todos los ejes espaciales (parámetros 41, 42 y 43 del elemento INSERT ). Esto también afecta a los elementos POLYLINE y LWPOLYLINE que incluyen arcos (parámetro bulge no igual a 0 ). Bloque de referencias (elemento INSERT ) solo se admiten cuando la matriz de escalado no es un espejo. (El producto de los factores de escala debe ser positivo). Los elementos de área, las mallas poligonales y las mallas policaras no son compatibles. Elementos sólidos ( SOLID ,…) Tampoco son compatibles. Los elementos MLINE (multilínea), RAY , XLINE , y LEADER (línea directriz) no son compatibles. Los elementos TEXT , MTEXT , y DIMENSION no son compatibles. Se ignoran el ancho, el color y el estilo de la línea, así como la información sobre la visibilidad del elemento. Archivos DXF binarios (extensión de archivo DXB ) no son compatibles. Los elementos no admitidos se ignoran (implícitamente) en la importación. " }, 
{ "title" : "Diálogo: Importar archivo DXF ", 
"url" : "_sm_cmd_cnc_dxf_import.html#UUID-ceb47740-324e-76a2-abd9-2d1fa27e1a26_id_fde6e1824400e36c0a8640e013dba7a_id_754451675df6e481c0a8646326153262", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Importar desde archivo DXF \/ Diálogo: Importar archivo DXF ", 
"snippet" : "Capas Todas las capas del dibujo técnico; determinado a partir de los datos del archivo DXF : La capa se importará. Tamaño máximo de la brecha Distancia entre los puntos finales de los elementos geométricos hasta donde los puntos se ven como interconectados. Determinado a partir de los datos del arc...", 
"body" : "Capas Todas las capas del dibujo técnico; determinado a partir de los datos del archivo DXF : La capa se importará. Tamaño máximo de la brecha Distancia entre los puntos finales de los elementos geométricos hasta donde los puntos se ven como interconectados. Determinado a partir de los datos del archivo DXF. Ejemplo: 0.001 Vista previa en ruta CNC Los datos del archivo DXF seleccionado se muestran en la forma en que se importan al editor CNC. También se tiene en cuenta la capa seleccionada para la visualización. Ejemplo: Vista Para cambiar la capa que se considera en la ventana de vista previa. plano x \/ y; seleccionado para ver plano x \/ z plano y \/ z Botón ' Importar ' Los datos se cargan en el editor CNC y se reemplaza el programa CNC existente. Los números de bloque se asignan automáticamente. El objeto CNC conserva su nombre. " }, 
{ "title" : "Comando: Información CNC ", 
"url" : "_sm_cmd_cnc_info.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Información CNC ", 
"snippet" : "Información CNC Función : El comando abre el Información del CNC sobre el programa <nombre> diálogo. Llama : CNC menú Menú contextual de un objeto (tipo Programa CNC ) Requisito : Hay un programa de CNC abierto en el editor. Diálogo: Código generado El cuadro de diálogo muestra el código de iniciali...", 
"body" : "Información CNC Función : El comando abre el Información del CNC sobre el programa <nombre> diálogo. Llama : CNC menú Menú contextual de un objeto (tipo Programa CNC ) Requisito : Hay un programa de CNC abierto en el editor. Diálogo: Código generado El cuadro de diálogo muestra el código de inicialización IEC del programa CNC activo, según el modo de compilación del bloque de funciones. SMC_OutQueue o SMC_CNC_REF . Ejemplo: código de inicialización IEC {attribute 'linkalways'}\nVAR_GLOBAL\n {attribute 'init_on_onlchange'}\n {attribute 'init_on_onlchange'}\n Example : SMC_CNC_REF := (nElements := 22, strProgramName := 'Example', piStartPosition := (iFrameNo:=0, wAuxData:=7, wSProfile:=0, dX:=0, dY:=0, dZ:=0, dA:=0, dB:=0, dC:=0, dA1:=0, dA2:=0, dA3:=0, dA4:=0, dA5:=0, dA6:=0), pgc := ADR(Example_D), xPartofLM := TRUE);\n {attribute 'blobinit'}\n {attribute 'init_on_onlchange'}\n Example_D : ARRAY[0..21] OF SMC_GCODE_WORD := [\n {p 35184372088832 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 70, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 69, fValue:=100, diValue:=100),\n {p 35184372088832 }\n (byLetter := 69, fValue:=-100, diValue:=-100),\n {p 35184372088832 }\n (byLetter := 128, fValue:=1, diValue:=1),\n {p 36283883716609 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 36835250143233 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 38486665068545 }\n (byLetter := 88, pAdr := ADR(g_x), byVarType := ANY_TO_BYTE(__TYPEOF(g_x) + 32)),\n {p 36291399909377 }\n (byLetter := 89, fValue:=0, diValue:=0),\n {p 36842766336001 }\n (byLetter := 70, fValue:=50, diValue:=50),\n {p 36844913819649 }\n (byLetter := 69, fValue:=30, diValue:=30),\n {p 37396817117185 }\n (byLetter := 69, fValue:=-30, diValue:=-30),\n {p 35184372088832 }\n (byLetter := 128, fValue:=2, diValue:=2),\n {p 36833639530498 }\n (byLetter := 78, fValue:=10, diValue:=10),\n {p 36835787014146 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683906 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 38488812552194 }\n (byLetter := 89, pAdr := ADR(g_y), byVarType := ANY_TO_BYTE(__TYPEOF(g_y) + 32)),\n {p 35184372088832 }\n (byLetter := 128, fValue:=3, diValue:=3),\n {p 36833639530499 }\n (byLetter := 78, fValue:=20, diValue:=20),\n {p 36835787014147 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683907 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 36289789296643 }\n (byLetter := 89, fValue:=0, diValue:=0)];\nEND_VAR " }, 
{ "title" : "Información de CNC del programa <nombre> Diálogo ", 
"url" : "_sm_cmd_cnc_info.html#UUID-ad8caf78-e0cf-3500-0750-16c2eb5fabe7_id_dc9afe4124423d69c0a8640e01f781e8_id_fc2c1e2959841990c0a864630e5a26e5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Información CNC \/ Información de CNC del programa <nombre> Diálogo ", 
"snippet" : "El cuadro de diálogo proporciona información sobre el programa de CNC especificado. Nombre del programa Ejemplo: Workpiece_1 Versión de bloques funcionales Ejemplo: 4.2.0.0 Número de líneas Ejemplo: 5 Numero de objetos Ejemplo: 3 Longitud de la ruta [unidades] Ejemplo: 261.803398874992 Duración [s] ...", 
"body" : "El cuadro de diálogo proporciona información sobre el programa de CNC especificado. Nombre del programa Ejemplo: Workpiece_1 Versión de bloques funcionales Ejemplo: 4.2.0.0 Número de líneas Ejemplo: 5 Numero de objetos Ejemplo: 3 Longitud de la ruta [unidades] Ejemplo: 261.803398874992 Duración [s] Tiempo (en segundos) para recorrer la ruta preprocesada Ejemplo: 10.158 Requisito: preprocesamiento de la ruta sin errores y puntos de interpolación generados con éxito Mostrar código generado los Código generado Se abre el cuadro de diálogo. Requisito: el programa no contiene errores. " }, 
{ "title" : "Comando: Cargar programa desde archivo ASCII ", 
"url" : "_sm_cmd_cnc_load_program_from_ascii_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Cargar programa desde archivo ASCII ", 
"snippet" : "Cargar programa desde archivo ASCII Función : El comando carga un ASCII archivo con los datos del programa CNC en el editor CNC. El objeto CNC conserva su nombre. Llama : CNC menú Requisito : Hay un objeto CNC abierto en el editor. El comando abre el cuadro de diálogo predeterminado para buscar en e...", 
"body" : "Cargar programa desde archivo ASCII Función : El comando carga un ASCII archivo con los datos del programa CNC en el editor CNC. El objeto CNC conserva su nombre. Llama : CNC menú Requisito : Hay un objeto CNC abierto en el editor. El comando abre el cuadro de diálogo predeterminado para buscar en el sistema de archivos. El filtro debe configurarse en CNC, GCODE o TXT. El archivo seleccionado se carga en el editor de CNC activo. Se sobrescribe cualquier programa de CNC existente (después de otra consulta). " }, 
{ "title" : "Comando: Mover programa ", 
"url" : "_sm_cmd_cnc_move_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Mover programa ", 
"snippet" : "Mover programa Función : El comando abre el Vector de traducción diálogo para configurar un movimiento de la trayectoria del CNC. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor....", 
"body" : "Mover programa Función : El comando abre el Vector de traducción diálogo para configurar un movimiento de la trayectoria del CNC. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. " }, 
{ "title" : "Restricción ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_e69692297289ca8ec0a864631a178469", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Mover programa \/ Restricción ", 
"snippet" : "Es posible mover la trayectoria del CNC en las siguientes condiciones: Sin uso del eje A, B o C de variables...", 
"body" : "Es posible mover la trayectoria del CNC en las siguientes condiciones: Sin uso del eje A, B o C de variables " }, 
{ "title" : "Diálogo: Vector de traducción ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Mover programa \/ Diálogo: Vector de traducción ", 
"snippet" : "Vector de traslación en coordenadas para todos los ejes X Defecto: 1.0000000 Y Z P Q U V W OK Esto mueve la trayectoria del CNC. Además, se inserta un comando G0 (comando de posicionamiento relativo) con las coordenadas del vector de traslación en el programa del CNC antes del primer comando de posi...", 
"body" : "Vector de traslación en coordenadas para todos los ejes X Defecto: 1.0000000 Y Z P Q U V W OK Esto mueve la trayectoria del CNC. Además, se inserta un comando G0 (comando de posicionamiento relativo) con las coordenadas del vector de traslación en el programa del CNC antes del primer comando de posicionamiento. Los comandos de posicionamiento son G1, G2, G3, G5, G6, G8, G9, G10, G11 y G92. Si los comandos G54, G55 o G56 cambian el sistema de coordenadas en el programa CNC, entonces los argumentos se adaptan en estos comandos. Los bloques hasta G53 sin punto requieren ninguna adaptación adicional. Si un comando G56 es el primer comando de posicionamiento, solo se adapta ese comando. Los números de bloque se asignan automáticamente. " }, 
{ "title" : "Comando: Renumerar programa CNC ", 
"url" : "_sm_cmd_cnc_renumber_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Renumerar programa CNC ", 
"snippet" : "Renumerar programa CNC Símbolo: Función : El comando actualiza la numeración de líneas de programa en el programa CNC. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Los números comienzan en 0 y se incrementan en 10. Cada bloque sin un número de bloque recibe un número. Se co...", 
"body" : "Renumerar programa CNC Símbolo: Función : El comando actualiza la numeración de líneas de programa en el programa CNC. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Los números comienzan en 0 y se incrementan en 10. Cada bloque sin un número de bloque recibe un número. Se corrige el código L en bloques G20. " }, 
{ "title" : "Comando: Invertir Dirección ", 
"url" : "_sm_cmd_cnc_reverse_direction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Invertir Dirección ", 
"snippet" : "Invertir dirección Función : El comando invierte el programa del CNC y establece los elementos de la ruta en orden inverso. Los números de bloque del programa CNC también se restablecen automáticamente. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Restricción Es posible inv...", 
"body" : "Invertir dirección Función : El comando invierte el programa del CNC y establece los elementos de la ruta en orden inverso. Los números de bloque del programa CNC también se restablecen automáticamente. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Restricción Es posible invertir la trayectoria del CNC en las siguientes condiciones: Si se seleccionó el preprocesamiento para el programa CNC, los bloques G41 \/ G42 se procesan en el programa inverso: G41 se convierte en G42 y G42 se convierte en G41. La dirección de la corrección también se invierte. Si el programa CNC contiene arcos definidos con un ángulo de apertura (parámetro K para elementos 2D o parámetro T para elementos 3D), entonces el comando no genera arcos invertidos exactos. Si la trayectoria del CNC fue programada por los siguientes medios, entonces no es posible invertir. No dar marcha atrás cuando Usando el eje A, B o C Usando Variables Supresión de pasos de llamada " }, 
{ "title" : "Comando: Rotar programa ", 
"url" : "_sm_cmd_cnc_rotate_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Rotar programa ", 
"snippet" : "Rotar programa Función : El comando abre el Parámetros de rotación diálogo donde se configura la rotación de la trayectoria del CNC. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor....", 
"body" : "Rotar programa Función : El comando abre el Parámetros de rotación diálogo donde se configura la rotación de la trayectoria del CNC. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. " }, 
{ "title" : "Restricción ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_45841f775e56fd50c0a864632eb28d67", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Rotar programa \/ Restricción ", 
"snippet" : "Es posible rotar la trayectoria del CNC en las siguientes condiciones: Sin uso del eje A, B o C de variables...", 
"body" : "Es posible rotar la trayectoria del CNC en las siguientes condiciones: Sin uso del eje A, B o C de variables " }, 
{ "title" : "Diálogo: Parámetros de rotación ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Rotar programa \/ Diálogo: Parámetros de rotación ", 
"snippet" : "Ángulo (grados) Ángulo de rotación (en grados) alrededor del Eje rotatorio . Ejemplo: Dado Rotación sobre el eje Z El eje X apunta hacia la derecha y el eje Y apunta hacia abajo. La dirección de visualización es contra el eje de rotación (regla de la mano derecha). Para un valor negativo, la rotació...", 
"body" : "Ángulo (grados) Ángulo de rotación (en grados) alrededor del Eje rotatorio . Ejemplo: Dado Rotación sobre el eje Z El eje X apunta hacia la derecha y el eje Y apunta hacia abajo. La dirección de visualización es contra el eje de rotación (regla de la mano derecha). Para un valor negativo, la rotación se realiza en el sentido de las agujas del reloj. Para un valor positivo, la rotación se realiza en sentido antihorario. Eje de rotación La selección de un eje giratorio solo es posible si los elementos de la trayectoria del CNC son todos elementos 3D. No hay selección si la trayectoria del CNC de uno de los siguientes elementos incluye: Spline G5 Parábola Elipse Arco 2D El eje rotatorio está definido por los parámetros X , Y , y Z . Defecto: X : 0, Y : 0, Z : 1 -> rotación sobre el eje Z X Defecto: 0.00000 Y Defecto: 0.00000 Z Defecto: 1.00000 OK Se ejecuta la rotación. Los números de bloque se asignan automáticamente. " }, 
{ "title" : "Comando: Programa de escala ", 
"url" : "_sm_cmd_cnc_scale_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Programa de escala ", 
"snippet" : "Programa de escala Función : El comando abre el Programa de escala diálogo donde se configura el escalado de la ruta del CNC. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor....", 
"body" : "Programa de escala Función : El comando abre el Programa de escala diálogo donde se configura el escalado de la ruta del CNC. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. " }, 
{ "title" : "Restricción ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_1320e28c7289c9f2c0a864633d064770", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Programa de escala \/ Restricción ", 
"snippet" : "Es posible escalar la trayectoria del CNC en las siguientes condiciones: Sin uso del eje A, B o C de variables...", 
"body" : "Es posible escalar la trayectoria del CNC en las siguientes condiciones: Sin uso del eje A, B o C de variables " }, 
{ "title" : "Diálogo: Programa de escala ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Programa de escala \/ Diálogo: Programa de escala ", 
"snippet" : "Factor de escala Defecto: 0.001 Condición: factor de escala> = 1e-3 Para un factor de escala> 1, se escala. Ejes : El eje está escalado. D (radio de la herramienta) : Se escala el radio D de la herramienta. OK Se realiza el escalado. Los números de bloque se asignan automáticamente....", 
"body" : "Factor de escala Defecto: 0.001 Condición: factor de escala> = 1e-3 Para un factor de escala> 1, se escala. Ejes : El eje está escalado. D (radio de la herramienta) : Se escala el radio D de la herramienta. OK Se realiza el escalado. Los números de bloque se asignan automáticamente. " }, 
{ "title" : "Comando: vista de ruta de desplazamiento ", 
"url" : "_sm_cmd_cnc_scroll_path_view.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: vista de ruta de desplazamiento ", 
"snippet" : "Vista de ruta de desplazamiento Función : El comando activa y desactiva el desplazamiento de la ruta del CNC. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Si el desplazamiento está activado, la vista de la ruta del CNC se desplaza y se amplía en el editor gráfico de modo qu...", 
"body" : "Vista de ruta de desplazamiento Función : El comando activa y desactiva el desplazamiento de la ruta del CNC. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Si el desplazamiento está activado, la vista de la ruta del CNC se desplaza y se amplía en el editor gráfico de modo que un elemento de la ruta que está seleccionado en el programa del CNC sea completamente visible. " }, 
{ "title" : "Comando: Establecer Variables ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Establecer Variables ", 
"snippet" : "Establecer variables Función : El comando abre el Valores fuera de línea de variables diálogo. Las variables del programa CNC se pueden definir aquí para el modo offline. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor....", 
"body" : "Establecer variables Función : El comando abre el Valores fuera de línea de variables diálogo. Las variables del programa CNC se pueden definir aquí para el modo offline. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. " }, 
{ "title" : "Diálogo: Valores fuera de línea de variables ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html#UUID-101f0c28-cef6-51dc-ec33-33b8d27ee9c8_id_c97aba1d244400ffc0a8640e01a5ad6c_id_d54502d95df6e2f6c0a8646351ba116d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Establecer Variables \/ Diálogo: Valores fuera de línea de variables ", 
"snippet" : "Variable Variable del programa CNC Ejemplo: G_X Si la variable se muestra en cursiva gris, entonces no se está utilizando en el programa del CNC. Valor Valor fuera de línea configurado Ejemplo: 100 Establecer en valores en línea Los valores se sobrescriben con los valores asignados actualmente en la...", 
"body" : "Variable Variable del programa CNC Ejemplo: G_X Si la variable se muestra en cursiva gris, entonces no se está utilizando en el programa del CNC. Valor Valor fuera de línea configurado Ejemplo: 100 Establecer en valores en línea Los valores se sobrescriben con los valores asignados actualmente en la aplicación. Requisito: El comando está disponible si la aplicación se está ejecutando y el editor CNC está en modo en línea. Entonces es posible cargar los valores en línea. OK Si los valores son válidos, se aplican en el programa CNC y se actualiza la ruta del editor. " }, 
{ "title" : "Comando: Mostrar puntos finales ", 
"url" : "_sm_cmd_cnc_show_end_points.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Mostrar puntos finales ", 
"snippet" : "Mostrar puntos finales Función : El comando activa y desactiva la visualización de los puntos de trayectoria del CNC. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Si la pantalla está activada, todos los elementos de la ruta cuentan con puntos finales....", 
"body" : "Mostrar puntos finales Función : El comando activa y desactiva la visualización de los puntos de trayectoria del CNC. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Si la pantalla está activada, todos los elementos de la ruta cuentan con puntos finales. " }, 
{ "title" : "Comando: Mostrar cuadrícula ", 
"url" : "_sm_cmd_cnc_show_grid.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Mostrar cuadrícula ", 
"snippet" : "Mostrar cuadrícula Símbolo: Función : El comando activa y desactiva la visualización de una cuadrícula en el editor gráfico. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. El factor de zoom determina el espaciado de las líneas de la cuadrícula. La expansión de la ruta determi...", 
"body" : "Mostrar cuadrícula Símbolo: Función : El comando activa y desactiva la visualización de una cuadrícula en el editor gráfico. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. El factor de zoom determina el espaciado de las líneas de la cuadrícula. La expansión de la ruta determina el tamaño de la cuadrícula. " }, 
{ "title" : "Comando: Mostrar puntos de interpolación ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Mostrar puntos de interpolación ", 
"snippet" : "Mostrar puntos de interpolación Símbolo: Función : El comando activa y desactiva la visualización de puntos de interpolación. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Si la visualización de los puntos de interpolación está activada, la trayectoria del CNC se muestra con...", 
"body" : "Mostrar puntos de interpolación Símbolo: Función : El comando activa y desactiva la visualización de puntos de interpolación. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Si la visualización de los puntos de interpolación está activada, la trayectoria del CNC se muestra con los puntos de interpolación. El tiempo de ciclo, que se establece en el cuadro de diálogo de los ajustes del CNC ( Preinterpolación tab), se utiliza para determinar los puntos de interpolación. Además, esta función determina si se muestra o no una ruta de CNC con preprocesamiento en el editor. " }, 
{ "title" : "Mostrar en el editor gráfico ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html#UUID-043dd64e-e07a-5e2b-2f1d-fc2a843ef4b7_id_be380e1242fa185c0a8640e005adee9_id_d6d5fcd172c9c53cc0a864633c37464d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Mostrar puntos de interpolación \/ Mostrar en el editor gráfico ", 
"snippet" : "Se muestra un punto de interpolación con una línea perpendicular a la dirección del movimiento. La longitud de la línea es proporcional a la velocidad de la trayectoria actual. Esto hace posible una estimación aproximada del comportamiento de la velocidad. Mayor distancia y línea larga Alta velocida...", 
"body" : "Se muestra un punto de interpolación con una línea perpendicular a la dirección del movimiento. La longitud de la línea es proporcional a la velocidad de la trayectoria actual. Esto hace posible una estimación aproximada del comportamiento de la velocidad. Mayor distancia y línea larga Alta velocidad Distancia más pequeña y línea corta Baja velocidad rojo El interpolador se desacelera. Verde El interpolador se acelera. gris El interpolador tiene una velocidad constante. " }, 
{ "title" : "Comando: Supresión de pasos ", 
"url" : "_sm_cmd_cnc_step_suppression.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Supresión de pasos ", 
"snippet" : "Supresión de pasos Símbolo: Función : El comando activa y desactiva la supresión de pasos. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. El programa CNC se implementa como DIN66025. Si la supresión de pasos está activada, los bloques del programa CNC que comienzan con \/ son ...", 
"body" : "Supresión de pasos Símbolo: Función : El comando activa y desactiva la supresión de pasos. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. El programa CNC se implementa como DIN66025. Si la supresión de pasos está activada, los bloques del programa CNC que comienzan con \/ son ignorados. Si el programa CNC se implementa como una tabla, entonces el comando no está disponible. " }, 
{ "title" : "Comando: Escribir programa en archivo ASCII ", 
"url" : "_sm_cmd_cnc_write_program_to_ascii_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Escribir programa en archivo ASCII ", 
"snippet" : "Escribir programa en archivo ASCII Función : El comando abre el cuadro de diálogo predeterminado para guardar un archivo en el sistema de archivos. El programa CNC se puede guardar como un archivo ASCII. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Nombre Predeterminado: no...", 
"body" : "Escribir programa en archivo ASCII Función : El comando abre el cuadro de diálogo predeterminado para guardar un archivo en el sistema de archivos. El programa CNC se puede guardar como un archivo ASCII. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Nombre Predeterminado: nombre del objeto CNC Ejemplo: cncSpiral_A Tipo de archivo Extensión de archivo: TXT , GCODE , CNC " }, 
{ "title" : "Comando: Mostrar ruta preprocesada ", 
"url" : "_sm_cmd_cnc_show_preprocessed_path.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Comando: Mostrar ruta preprocesada ", 
"snippet" : "Mostrar ruta preprocesada Símbolo: Función : El comando activa y desactiva la visualización de la trayectoria del CNC con preprocesamiento. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Si la pantalla está activa, la ruta se muestra con preprocesamiento y la ruta original se...", 
"body" : "Mostrar ruta preprocesada Símbolo: Función : El comando activa y desactiva la visualización de la trayectoria del CNC con preprocesamiento. Llama : CNC menú Requisito : Hay una ruta de CNC abierta en el editor. Si la pantalla está activa, la ruta se muestra con preprocesamiento y la ruta original se muestra en gris claro en el fondo. El preprocesamiento se configura en el Configuraciones CNC diálogo ( Preprocesamiento de ruta pestaña). Se muestra el preprocesamiento configurado allí. Luego, puede simular el efecto de los diferentes bloques de funciones (en serie) en el preprocesamiento. El comando no tiene ningún efecto sobre la generación de código. Incluso si se genera una estructura de archivo SMC_OutQueue al compilar el programa CNC, el comando no tiene ningún efecto sobre el contenido del archivo. El preprocesamiento siempre se tiene en cuenta al compilar. " }, 
{ "title" : "Objeto: Programa CNC ", 
"url" : "_sm_f_reference_object_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Programa CNC ", 
"snippet" : "Programa CNC...", 
"body" : "Programa CNC " }, 
{ "title" : "Descripción general ", 
"url" : "_sm_f_reference_object_cnc_program-1561724.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Programa CNC \/ Descripción general ", 
"snippet" : "CODESYS proporciona la capacidad de crear programas CNC en dos editores diferentes: el editor para DIN 66025 y el editor tabular. Ambos editores muestran una vista gráfica de la ruta programada. Aunque la programación se puede intercambiar entre los editores, esto puede provocar pérdidas de informac...", 
"body" : "CODESYS proporciona la capacidad de crear programas CNC en dos editores diferentes: el editor para DIN 66025 y el editor tabular. Ambos editores muestran una vista gráfica de la ruta programada. Aunque la programación se puede intercambiar entre los editores, esto puede provocar pérdidas de información. Los editores individuales proporcionan un manejo diferente de los elementos. Elemento Editor para DIN 66025 Editor tabular Posicionamiento X X Línea X X Arco X X Elipse X X Ranura X X Posicionamiento rapido X X Función M X X Parábola X Usando Variables X Salto X Cambio de coordenadas X Supresión de pasos X Tiempo de permanencia X Sincronización de tiempo con interpolador X Para más información, ver: Editor tabular y Editor para DIN 66025" }, 
{ "title" : "Editor tabular ", 
"url" : "_sm_obj_cnc_program_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Programa CNC \/ Editor tabular ", 
"snippet" : "En el editor tabular, los comandos de ruta se enumeran en una tabla. Sobre el Editor tabular pestaña, en la Configuraciones CNC , puede personalizar las columnas de esta tabla. los Configuraciones CNC se encuentran como un objeto en el árbol de dispositivos. De forma predeterminada, las propiedades ...", 
"body" : "En el editor tabular, los comandos de ruta se enumeran en una tabla. Sobre el Editor tabular pestaña, en la Configuraciones CNC , puede personalizar las columnas de esta tabla. los Configuraciones CNC se encuentran como un objeto en el árbol de dispositivos. De forma predeterminada, las propiedades del elemento de ruta seleccionado se muestran en el lado derecho de la tabla. Estos no se pueden editar allí. Cuando selecciona una línea, la ruta de movimiento respectiva se dibuja en el editor gráfico. El tipo de elemento determina qué propiedades específicas de un elemento de ruta se pueden cambiar. Los parámetros no editables están sombreados. Pulsando el F6 cambia el enfoque al editor gráfico y viceversa. Para obtener una descripción general de los elementos admitidos por este editor, consulte el Programa CNC capítulo. Para más información, ver: Programación de una ruta en el editor tabular y Editor gráfico" }, 
{ "title" : "Editor para DIN 66025 ", 
"url" : "_sm_obj_cnc_program_din66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Programa CNC \/ Editor para DIN 66025 ", 
"snippet" : "En este editor, los elementos de la ruta se especifican como un programa de CNC según DIN 66025. Por defecto, las propiedades del elemento de ruta seleccionado se muestran en el lado derecho. Sin embargo, no se pueden modificar allí. Cuando selecciona una línea, la ruta de movimiento respectiva se d...", 
"body" : "En este editor, los elementos de la ruta se especifican como un programa de CNC según DIN 66025. Por defecto, las propiedades del elemento de ruta seleccionado se muestran en el lado derecho. Sin embargo, no se pueden modificar allí. Cuando selecciona una línea, la ruta de movimiento respectiva se dibuja en el editor gráfico. Pulsando el F6 cambia el enfoque al editor gráfico y viceversa. Para obtener una descripción general de los elementos admitidos por este editor, consulte el capítulo \"Programa objeto de CNC\". Tenga en cuenta que las referencias de las variables globales se evalúan en el módulo decodificador cuando el intérprete está procesando los bloques. Esto puede suceder algunos ciclos antes de que el objeto viaje. Para más información, ver: Programación de una ruta según DIN 66025 y Configuraciones CNC" }, 
{ "title" : "Editor gráfico ", 
"url" : "_sm_obj_cnc_program_graphical.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Programa CNC \/ Editor gráfico ", 
"snippet" : "El editor gráfico se encuentra en la parte inferior del editor tabular del CNC y el editor para DIN 66025. El editor se utiliza para visualizar el programa CNC programado. El editor proporciona herramientas para modificar y ampliar la ruta. Estructura del editor (1): editor tabular o editor según DI...", 
"body" : "El editor gráfico se encuentra en la parte inferior del editor tabular del CNC y el editor para DIN 66025. El editor se utiliza para visualizar el programa CNC programado. El editor proporciona herramientas para modificar y ampliar la ruta. Estructura del editor (1): editor tabular o editor según DIN 66025 (2): Vista de propiedades: muestra las propiedades del elemento de ruta seleccionado (3): editor gráfico (4): Panel de control: elementos para controlar la posición de la cámara y la dirección de visualización (5): Herramientas para modificar la ruta Notas sobre cómo trabajar con el editor gráfico El elemento de ruta seleccionado se muestra en rojo. Los comandos de posicionamiento (G0) y las funciones del punto de conmutación se muestran en verde. Si el punto final de un elemento se puede mover, se muestra como un pequeño círculo con contorno negro. Las tangentes inicial y final se muestran en gris. La posición actual del elemento de ruta seleccionado se muestra en la barra de estado. Tenga en cuenta los comandos del menú del CNC para escalar y mover toda la ruta. Tenga en cuenta los programas de muestra incluidos en la instalación de CODESYS SoftMotion . " }, 
{ "title" : "Instrumentos ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_0ffa6b2d9c1625bec0a8646341693b76", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Programa CNC \/ Editor gráfico \/ Instrumentos ", 
"snippet" : "Puede utilizar herramientas para modificar y ampliar las trayectorias de movimiento en el editor gráfico. Los cambios son visibles simultáneamente en el editor de texto y el editor tabular. Seleccione : Esta herramienta selecciona un punto o un elemento de ruta. A continuación, el elemento se muestr...", 
"body" : "Puede utilizar herramientas para modificar y ampliar las trayectorias de movimiento en el editor gráfico. Los cambios son visibles simultáneamente en el editor de texto y el editor tabular. Seleccione : Esta herramienta selecciona un punto o un elemento de ruta. A continuación, el elemento se muestra en rojo con un punto de partida azul. El puntero del mouse en el editor gráfico se convierte en un puntero. Línea : Agrega o inserta una nueva línea. El puntero del mouse en el editor gráfico se convierte en una cruz. Insertar círculo (en el sentido de las agujas del reloj) : Agrega o inserta un nuevo arco (en el sentido de las agujas del reloj). El puntero del mouse en el editor gráfico se convierte en una cruz. Insertar círculo (en sentido antihorario) : Agrega o inserta un nuevo arco (en sentido antihorario). El puntero del mouse en el editor gráfico se convierte en una cruz. Ranura : Agrega o inserta un nuevo punto de spline. El puntero del mouse en el editor gráfico se convierte en una cruz. " }, 
{ "title" : "Posición de la cámara y dirección de visualización ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_05ff18059c1625bec0a864634ba4f71d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Programa CNC \/ Editor gráfico \/ Posición de la cámara y dirección de visualización ", 
"snippet" : "Puede utilizar el ratón para modificar la posición y la perspectiva de la cámara en la ruta del programa de cualquier forma. Boton izquierdo del raton presionado + movimiento del mouse: Mueve la posición de la cámara a lo largo de los ejes en el plano de visualización. Botón derecho del mouse presio...", 
"body" : "Puede utilizar el ratón para modificar la posición y la perspectiva de la cámara en la ruta del programa de cualquier forma. Boton izquierdo del raton presionado + movimiento del mouse: Mueve la posición de la cámara a lo largo de los ejes en el plano de visualización. Botón derecho del mouse presionado + movimiento del mouse: Gira la vista en el programa CNC. control + Rueda de ratón : Cambia el factor de zoom. " }, 
{ "title" : "Panel operativo para control de pantalla ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_4693d34dba46042bc0a864633b130501", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Programa CNC \/ Editor gráfico \/ Panel operativo para control de pantalla ", 
"snippet" : "En la esquina superior izquierda del editor gráfico, un panel operativo proporciona varios comandos para cambiar la vista de la ruta. La ruta no se modifica en el proceso. En cambio, solo se cambian la posición de la cámara y la perspectiva de la cámara. Puede contraer el panel de control haciendo c...", 
"body" : "En la esquina superior izquierda del editor gráfico, un panel operativo proporciona varios comandos para cambiar la vista de la ruta. La ruta no se modifica en el proceso. En cambio, solo se cambian la posición de la cámara y la perspectiva de la cámara. Puede contraer el panel de control haciendo clic en la flecha negra para maximizar el tamaño del espacio de trabajo del editor. Al hacer clic de nuevo, se expande el panel de control. El panel de control proporciona los siguientes comandos para configurar la orientación, la posición y el zoom. Acercarse Disminuir el zoom Cambiar el tono de la cámara (en el sentido de las agujas del reloj) Cambiar el tono de la cámara (en sentido antihorario) Cambiar la orientación de la cámara (en el sentido de las agujas del reloj) Cambiar la orientación de la cámara (en sentido antihorario) Gire la cámara (en el sentido de las agujas del reloj) Gire la cámara (en sentido antihorario) Mover la cámara hacia arriba Mover la cámara a la izquierda Mover la cámara a la derecha Mover la cámara hacia abajo Establezca la dirección de la vista en el eje z negativo y cambie la escala Establezca la dirección de la vista en el eje x y cambie la escala Establezca la dirección de la vista en el eje y y cambie la escala " }, 
{ "title" : "Diálogo: Propiedades CNC ", 
"url" : "_sm_dlg_cnc_program_properties.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Programa CNC \/ Diálogo: Propiedades CNC ", 
"snippet" : "Símbolo: Función : El cuadro de diálogo proporciona parámetros para Programa CNC objeto. Llama : Ver → Propiedades mando; menú contextual del objeto Requisito : El objeto CNC está seleccionado en el árbol de dispositivos. Los ajustes de CNC de toda la aplicación se guardan en el Configuraciones CNC ...", 
"body" : "Símbolo: Función : El cuadro de diálogo proporciona parámetros para Programa CNC objeto. Llama : Ver → Propiedades mando; menú contextual del objeto Requisito : El objeto CNC está seleccionado en el árbol de dispositivos. Los ajustes de CNC de toda la aplicación se guardan en el Configuraciones CNC objeto. " }, 
{ "title" : "Pestaña: General ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_e398c87e5062d26bc0a86520014051d1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Programa CNC \/ Diálogo: Propiedades CNC \/ Pestaña: General ", 
"snippet" : "Cambie el nombre del objeto CNC....", 
"body" : "Cambie el nombre del objeto CNC. " }, 
{ "title" : "Control de acceso Pestaña ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_6f1287e45062d25bc0a865200009f33d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Programa CNC \/ Diálogo: Propiedades CNC \/ Control de acceso Pestaña ", 
"snippet" : "Aquí especifica los permisos de los grupos de usuarios. Para más información, ver: Propiedades – Control de acceso...", 
"body" : "Aquí especifica los permisos de los grupos de usuarios. Para más información, ver: Propiedades – Control de acceso " }, 
{ "title" : "Pestaña: Construir ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_18be1ff163875181c0a865ca014256df", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Programa CNC \/ Diálogo: Propiedades CNC \/ Pestaña: Construir ", 
"snippet" : "Active la opción para excluir el objeto CNC de la construcción. Entonces no se generan datos IEC. Sin embargo, es posible guardar el código G como un archivo ASCII. Para leer este tipo de archivo en tiempo de ejecución, puede utilizar los bloques de función del SM3_CNC Biblioteca. Para más informaci...", 
"body" : "Active la opción para excluir el objeto CNC de la construcción. Entonces no se generan datos IEC. Sin embargo, es posible guardar el código G como un archivo ASCII. Para leer este tipo de archivo en tiempo de ejecución, puede utilizar los bloques de función del SM3_CNC Biblioteca. Para más información, ver: Propiedades – Control de acceso " }, 
{ "title" : "CNC Pestaña ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Programa CNC \/ Diálogo: Propiedades CNC \/ CNC Pestaña ", 
"snippet" : "Implementación Din66025 : La trayectoria de movimiento se define en el lenguaje CNC DIN 66025. Mesa : La trayectoria del movimiento se define mediante la parametrización de una tabla. Modo de compilación Comportamiento al compilar SMC_OutQueue : Se genera una estructura de datos SMC_OutQueue en la c...", 
"body" : "Implementación Din66025 : La trayectoria de movimiento se define en el lenguaje CNC DIN 66025. Mesa : La trayectoria del movimiento se define mediante la parametrización de una tabla. Modo de compilación Comportamiento al compilar SMC_OutQueue : Se genera una estructura de datos SMC_OutQueue en la compilación. Se le concede acceso global mediante g_CNCQueueManager . SMC_CNC_REF : Las variables de programa se generan en la compilación. Se le concede acceso global mediante g_CNCProgManager . Expediente : Un archivo generado por el código G se descarga y actualiza en cada inicio de sesión. El PLC puede descargar este archivo mediante bloques de función. Los archivos de código G se actualizan cada vez que se inicia sesión en la aplicación. Esto significa que los archivos del PLC se sobrescriben en cada inicio de sesión. Nombre del archivo Requisito: Modo de compilación se establece en Expediente . Defecto: $ ObjectName $ .cnc . Este valor predeterminado es un marcador de posición que se reemplaza por el nombre de objeto del objeto CNC (nombre de archivo efectivo) al iniciar sesión. Solo se permiten los caracteres [a-zA-Z0-9 $ _.] En un nombre de archivo. El campo para el nombre del archivo no debe estar en blanco ni comenzar ni terminar con un punto. Además, no es necesario que un punto sea parte de la ruta en el nombre del archivo. Tamaño de la cola [elementos] Predeterminado: 100 La configuración de tamaño no afecta el tamaño de la generada SMC_OutQueue estructura de datos (cuando se selecciona este modo). La talla de SMC_OutQueue está determinada únicamente por el número de objetos de ruta. Sin embargo, el parámetro establece el tamaño del búfer de los FB de preprocesamiento (por ejemplo, SMC_NCDecoder , SMC_RoundPath ) que se utilizan internamente y definen el tamaño del búfer de búsqueda anticipada. Valores predeterminados Velocidad (F) [u \/ s] Este valor se utiliza cuando el valor de la velocidad (en la palabra \"F\") no está configurado en el programa del CNC. En unidades de ruta por segundo. Intervalo de valores: [0, 1e9]. Predeterminado: 0 Aceleración (E +) [u \/ s²] Este valor se utiliza cuando no se establece el valor de la aceleración (en la palabra \"E\" con un valor positivo). En unidades de ruta por segundo al cuadrado. Intervalo de valores:] 0, 1e9]. Predeterminado: 100 Deceleración (E-) [u \/ s²] Este valor se utiliza cuando no se establece el valor de la desaceleración (en la palabra \"E\" con un valor negativo). En unidades de ruta por segundo al cuadrado. Intervalo de valores:] 0, 1e9]. Predeterminado: 100 Valores predeterminados para avance rápido (G0) Velocidad (FF) [u \/ s] Este valor se utiliza cuando el valor de avance de la velocidad (en la palabra \"FF\") no está configurado en el programa del CNC. En unidades de ruta por segundo. Intervalo de valores: [0, 1e9]. Predeterminado: 0 Aceleración (EF +) [u \/ s²] Este valor se utiliza cuando no se establece el valor de avance de la aceleración (en la palabra \"EF +\" con un valor positivo). En unidades de ruta por segundo al cuadrado. Intervalo de valores: [0, 1e9]. Predeterminado: 0 Deceleración (EF-) [u \/ s²] Este valor se usa cuando el valor de avance de la desaceleración (en la palabra \"EF-\" con un valor negativo) no está configurado. En unidades de ruta por segundo al cuadrado. Intervalo de valores: [0, 1e9]. Predeterminado: 0 Modo 3D Requisito: Implementación Din66025 , modo de traducción CNC_REF , y OUTQueue : El modo 3D es el valor predeterminado. Valores fuera de línea de variables Variables : Si se definen valores fuera de línea, Valores de variables sin conexión Se abre el cuadro de diálogo. En este cuadro de diálogo se muestran las variables que también se pueden editar. Posición de salida Predeterminado: 0 Precisión La precisión de la ruta en unidades técnicas. Este valor especifica la precisión de las posiciones que se leen del código G. Por ejemplo, si el código G se especifica con 3 decimales, entonces la precisión debe establecerse en 0,001 unidades. La precisión no debe ser negativa. Este valor se utiliza, por ejemplo, en el preprocesamiento de rutas, como SMC_ToolRadiusCorr y SMC_AvoidLoop . " }, 
{ "title" : "Objeto: Configuración CNC ", 
"url" : "_sm_obj_cnc_settings.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Configuración CNC ", 
"snippet" : "Configuraciones CNC Símbolo: Los ajustes de este objeto son válidos para todos los objetos CNC de la aplicación. El objeto se agrega al árbol de dispositivos de la aplicación o se genera automáticamente cuando se agrega un objeto CNC a la aplicación. El objeto puede existir solo una vez por aplicaci...", 
"body" : "Configuraciones CNC Símbolo: Los ajustes de este objeto son válidos para todos los objetos CNC de la aplicación. El objeto se agrega al árbol de dispositivos de la aplicación o se genera automáticamente cuando se agrega un objeto CNC a la aplicación. El objeto puede existir solo una vez por aplicación y no se puede cambiar el nombre. En el editor del objeto, se pueden especificar configuraciones para los módulos de preprocesamiento de ruta, preinterpolación y editor tabular CNC. Puede eliminar el Configuraciones CNC objeto solo si no existe ningún objeto CNC debajo de la aplicación. Los ajustes que son válidos solo para un programa de CNC específico se guardan en el Ajustes diálogo del programa CNC. " }, 
{ "title" : "Pestaña: Preprocesadores de ruta ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_de809dbaa55775c9c0a8646311985883", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Configuración CNC \/ Pestaña: Preprocesadores de ruta ", 
"snippet" : "En esta pestaña, el preprocesamiento de la ruta se programa seleccionando los bloques de función. Bloques de función disponibles Lista de todos los bloques de función disponibles Instancias de bloques de funciones activas Lista de las instancias de bloques de funciones seleccionadas La posición en l...", 
"body" : "En esta pestaña, el preprocesamiento de la ruta se programa seleccionando los bloques de función. Bloques de función disponibles Lista de todos los bloques de función disponibles Instancias de bloques de funciones activas Lista de las instancias de bloques de funciones seleccionadas La posición en la lista define el orden de procesamiento y se puede cambiar. Se puede crear una instancia de un bloque de funciones en la lista varias veces. Parámetro Abre el Editor de parámetros para <instancia de bloque de función activa seleccionada> diálogo Alternativa: haga doble clic en una instancia de bloque de función activa Agrega una instancia del bloque de funciones al Instancias de bloques de funciones activas que se selecciona en Instancias de bloques de funciones activas Elimina la instancia de bloque de función seleccionada Las instancias de bloques de funciones de bloques de funciones, que se muestran en cursiva gris claro, no se pueden borrar. Mueve la instancia de bloque de función activa seleccionada hacia arriba en una línea Alternativa: Presione Cambio + Flecha arriba Mueve la instancia de bloque de función activa seleccionada hacia abajo una línea Alternativa: Presione Cambio + Flecha hacia abajo Editor de parámetros para <instancia de bloque de función activa seleccionada> Diálogo El cuadro de diálogo se utiliza para mostrar y cambiar las entradas de la instancia seleccionada. No todas las entradas son visibles. Spalte1 Nombre del parámetro de la instancia de bloque de función activa seleccionada Spalte2 Cuadro de lista para establecer el valor Spalte3 Descripción del parámetro " }, 
{ "title" : "Pestaña: Preinterpolación ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_9a258724a55775c9c0a8646350128da9", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Configuración CNC \/ Pestaña: Preinterpolación ", 
"snippet" : "Tiempo de ciclo µs Tiempo de interpolación Valor inicial: 20000 Modo de velocidad Trapezoide : Perfil de velocidad con forma trapezoidal Sigmoidal : Perfil de velocidad como el perfil trapezoidal pero con funciones sen² que reemplazan la rampa de velocidad lineal Sigmoide limitado : Perfil de veloci...", 
"body" : "Tiempo de ciclo µs Tiempo de interpolación Valor inicial: 20000 Modo de velocidad Trapezoide : Perfil de velocidad con forma trapezoidal Sigmoidal : Perfil de velocidad como el perfil trapezoidal pero con funciones sen² que reemplazan la rampa de velocidad lineal Sigmoide limitado : Perfil de velocidad como el perfil sigmoidal pero teniendo en cuenta los límites de aceleración y desaceleración Cuadrático : Perfil de aceleración con forma trapezoidal con limitación de tirones como se define en Tirón máximo . El perfil de velocidad cuadrático resultante también se reconoce como una curva S. Cuadrático (suave) : Funciona como Cuadrático modo pero genera un perfil jerk sin saltos. Sacudida máxima [u \/ s³] Limitación del valor absoluto del tirón Se utiliza solo para el perfil de velocidad cuadrática El tiempo de interpolación y el tiempo de ciclo de la tarea respectiva, en la que se llama al interpolador, deben coincidir para un comportamiento idéntico del editor CNC y la aplicación en línea. " }, 
{ "title" : "Pestaña: Editor tabular ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_section-idm43260108321858", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaz de usuario \/ Objeto: Configuración CNC \/ Pestaña: Editor tabular ", 
"snippet" : "Las columnas del editor tabular y su orden se definen en esta pestaña. Columnas de la tabla Lista de todos los atributos disponibles : El atributo está visible en el editor tabular. El orden en esta lista determina el orden de las líneas en el editor tabular. Mueve el atributo seleccionado una línea...", 
"body" : "Las columnas del editor tabular y su orden se definen en esta pestaña. Columnas de la tabla Lista de todos los atributos disponibles : El atributo está visible en el editor tabular. El orden en esta lista determina el orden de las líneas en el editor tabular. Mueve el atributo seleccionado una línea hacia arriba Mueve el atributo seleccionado una línea hacia abajo " }, 
{ "title" : "CODESYS SoftMotion Robotics ", 
"url" : "_sm_f_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Descripción general ", 
"url" : "_sm_overview_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Descripción general ", 
"snippet" : "CODESYS SoftMotion Robotics proporciona una interfaz de bloques de funciones para el control de movimiento de robots, que se basa en la especificación PLCopen \"Bloques de funciones para el control de movimiento Parte 4\". Las secuencias de movimiento complejas pueden estar compuestas de movimientos s...", 
"body" : "CODESYS SoftMotion Robotics proporciona una interfaz de bloques de funciones para el control de movimiento de robots, que se basa en la especificación PLCopen \"Bloques de funciones para el control de movimiento Parte 4\". Las secuencias de movimiento complejas pueden estar compuestas de movimientos simples de punto a punto o de trayectoria continua, como líneas rectas o arcos circulares. Es posible realizar combinaciones configurables entre los movimientos individuales (por ejemplo, en función de la distancia o la velocidad). Se tienen en cuenta los límites de velocidad, aceleración y tirones, tanto de los distintos ejes como de la trayectoria. La planificación de trayectoria se realiza en línea en el CODESYS controlador, paralelo a la ejecución del movimiento. Se pueden agregar nuevos movimientos en el momento del procesamiento y sin detener el robot. El volumen de suministro incluye modelos cinemáticos para diferentes robots estándar, desde pórticos simples hasta robots delta y SCARA y los típicos robots industriales de seis ejes. Los modelos cinemáticos personalizados para máquinas especiales se pueden vincular en forma de un bloque de funciones IEC 61131-3. De manera similar, los modelos dinámicos se pueden utilizar a través de una interfaz para limitar las fuerzas y pares que se producen y permitir el control anticipado del par. Se utilizan otros bloques de funciones para implementar fácilmente casos de uso típicos. Esto incluye la sincronización con sistemas de coordenadas móviles, la interrupción y reanudación de movimientos o el control de salidas digitales de alta precisión mediante disparadores. " }, 
{ "title" : "Empezando ", 
"url" : "_sm_robotics_first_steps.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Empezando ", 
"snippet" : "Para programar los movimientos de los ejes de un robot, primero debe crear un grupo de ejes debajo de la aplicación en su proyecto. Para obtener más información sobre esto, consulte: Cómo crear un grupo de ejes. El grupo de ejes creado se configura con la cinemática deseada. Inserta ejes reales o vi...", 
"body" : "Para programar los movimientos de los ejes de un robot, primero debe crear un grupo de ejes debajo de la aplicación en su proyecto. Para obtener más información sobre esto, consulte: Cómo crear un grupo de ejes. El grupo de ejes creado se configura con la cinemática deseada. Inserta ejes reales o virtuales debajo del dispositivo y vincula estos ejes al grupo de ejes. Para obtener más información, consulte las páginas de ayuda en Cinemática: Estados del grupo del ejeCombinación de cinemática de posición y orientaciónJuntas rotativas y ejes de móduloEjes rotativos con rango de valor superior a 360 °Cómo crear un programa para el control de ejes después de crear y configurar los ejes se muestra aquí como un ejemplo: Cómo crear un programa para controlar el grupo de ejesPara obtener información sobre cómo implementar las diversas demandas de control de movimiento, consulte las páginas de ayuda adicionales en Control de movimiento . Amortiguación y combinación de movimientosMovimiento de grupos de ejesInterrupción y continuación de movimientosSincronización con un sistema de coordenadas en movimientoConfiguración de una compensación de herramientaPuede encontrar información básica para comprender cómo se realizan movimientos específicos aquí: Interpolación de orientación para movimientos CPPara usuarios avanzados: Limitación de par y control de avance de parCreación de cinemáticas personalizadas" }, 
{ "title" : "Grupo de ejes ", 
"url" : "_sm_robotics_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Grupo de ejes ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Cómo crear un grupo de ejes ", 
"url" : "_sm_creating_an_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Grupo de ejes \/ Cómo crear un grupo de ejes ", 
"snippet" : "Adición de objetos al árbol de dispositivos Los siguientes pasos describen cómo crear y configurar un grupo de ejes. Cree un nuevo proyecto estándar con CODESYS Control . para el punto de uso PLC_PRG , seleccione el idioma de implementación de CFC. En el árbol de dispositivos, abra el menú contextua...", 
"body" : "Adición de objetos al árbol de dispositivos Los siguientes pasos describen cómo crear y configurar un grupo de ejes. Cree un nuevo proyecto estándar con CODESYS Control . para el punto de uso PLC_PRG , seleccione el idioma de implementación de CFC. En el árbol de dispositivos, abra el menú contextual del Dispositivo objeto y seleccione el Habilitar movimiento suave dominio. A Grupo de ejes generales de SoftMotion El objeto se inserta debajo del Dispositivo . En el árbol de dispositivos, seleccione Grupo de ejes generales de SoftMotion . En el menú contextual, haga clic en Añadir dispositivo . El Añadir dispositivo se abre el cuadro de diálogo. Selecciona el SM_Drive_Virtual dispositivo. Especifique el nombre del dispositivo como \"DriveX\". De la misma manera, inserte dos unidades más denominadas \"DriveY\" y \"DriveZ\" . En el árbol de dispositivos, abra el menú contextual del Solicitud objeto y haga clic Proyecto → Agregar objeto → Grupo de ejes . Insertar el objeto con el nombre especificado. Grupo de ejes . El Grupo de ejes el objeto se inserta debajo de la aplicación. Se abre el configurador de grupos de ejes. En el editor de configuración, haga clic en el Seleccionar cinemática botón. El Seleccionar cinemática Se abre un cuadro de diálogo con una lista de todas las configuraciones cinemáticas disponibles y sus descripciones. Selecciona el TRAFO.Kin_Gantry3 configuración cinemática. Se abre el editor de configuración para la configuración cinemática seleccionada. En el Mapeo a ejes grupo de parámetros, asigne los ejes a los variadores utilizados en el proyecto. Para hacer esto, especifique el valor. DriveX en el X campo de entrada, el valor DriveY en el Y campo de entrada y el valor DriveZ en el z campo de entrada. También puedes usar el Asistente de entrada para seleccionar la unidad o arrástrela desde el árbol de dispositivos al campo de entrada. Para más información, ver: Editor de grupo de ejes" }, 
{ "title" : "Editor de grupo de ejes ", 
"url" : "_sm_obj_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Grupo de ejes \/ Editor de grupo de ejes ", 
"snippet" : "Símbolo: En el editor de la Grupo eje objeto, seleccione el tipo de cinemática básica y cinemática de orientación. La cinemática de orientación solo se puede seleccionar cuando es compatible con la cinemática básica. Además, asigna los ejes de la cinemática a los accionamientos de su proyecto. Cinem...", 
"body" : "Símbolo: En el editor de la Grupo eje objeto, seleccione el tipo de cinemática básica y cinemática de orientación. La cinemática de orientación solo se puede seleccionar cuando es compatible con la cinemática básica. Además, asigna los ejes de la cinemática a los accionamientos de su proyecto. Cinemática Seleccionar cinemática Cambiar cinemática Abre una lista de todas las cinemáticas admitidas por CODESYS Cuando selecciona un tipo de cinemática, se muestra una breve descripción en el cuadro a la derecha de la lista. Después de seleccionar un tipo de cinemática, puede modificar los parámetros respectivos en el editor. Cinemática de orientación Seleccionar cinemática Cambiar cinemática Abre una lista de todas las cinemáticas de orientación admitidas por CODESYS Cuando selecciona un tipo de cinemática, se muestra una breve descripción en el cuadro a la derecha de la lista. Después de seleccionar un tipo de cinemática, puede modificar los parámetros respectivos en el editor. Mapeo de ejes Dependiendo de la cinemática seleccionada, asigna los ejes de la cinemática a los accionamientos en su proyecto. Ejes adicionales Añadir eje Añade un campo de configuración para un eje adicional. La unidad del proyecto se introduce en este campo de configuración. Tareas Tarea de ciclo de bus Tarea de ciclo de bus de los ejes, si los ejes ya están mapeados La configuración no se puede cambiar aquí. Tarea de planificación Tarea para la planificación de tareas de CP Una tarea de planificación se crea automáticamente cuando se inserta el primer grupo de ejes. No se debe configurar un mecanismo de vigilancia porque el tiempo de ejecución puede fluctuar considerablemente. Para más información, ver: Configuración de la tarea de planificaciónSi elimina esta tarea, se emite un error en la vista de mensajes. Para crear una nueva tarea, haga clic en Proyecto → Crear tarea de planificación . Para más información, ver: Cómo crear un grupo de ejes" }, 
{ "title" : "Estados del grupo del eje ", 
"url" : "_sm_robotics_state_machine.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Grupo de ejes \/ Estados del grupo del eje ", 
"snippet" : "La siguiente imagen muestra los estados posibles para los grupos de ejes y las transiciones entre los estados. Los errores de cada eje siempre dirigen el grupo de ejes hacia el GroupErrorStop estado. Si el grupo de ejes cambia a GroupMoving , entonces todos los ejes se cambian a SynchronizedMotion ....", 
"body" : "La siguiente imagen muestra los estados posibles para los grupos de ejes y las transiciones entre los estados. Los errores de cada eje siempre dirigen el grupo de ejes hacia el GroupErrorStop estado. Si el grupo de ejes cambia a GroupMoving , entonces todos los ejes se cambian a SynchronizedMotion . Si el grupo de ejes cambia de GroupMoving a GroupStandby , entonces todos los ejes se cambian a standstill . Si el grupo de ejes cambia de GroupMoving a GroupErrorStop , entonces todos los ejes se cambian a GroupErrorStop . Si el grupo de ejes está en GroupStandby , entonces los ejes individuales no están necesariamente todos en standstill porque pueden ser controlados por medio de bloques de función de movimiento de un solo eje como MC_Jog . Si el movimiento finaliza con un error, todos los movimientos posteriores almacenados en el buffer se cancelan con CommandAborted . Mientras el grupo de ejes siga un sistema de coordenadas dinámico, permanecerá en GroupMoving . El grupo de ejes está en GroupMoving si y solo si el grupo se mueve de manera coordinada (por uno de los bloques de movimiento de la Parte 4). Cambiar de GroupMoving a GroupStandby se realiza un ciclo después del último cambio de posición. " }, 
{ "title" : "Configuración de la tarea de planificación ", 
"url" : "_sm_configuration_planning_task.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Grupo de ejes \/ Configuración de la tarea de planificación ", 
"snippet" : "La planificación del movimiento del grupo de ejes se realiza en una tarea separada que se crea automáticamente con el nombre \"SoftMotion_PlanningTask\" cuando se inserta un grupo de ejes. De forma predeterminada, esta tarea de planificación se ejecuta en el mismo núcleo de procesador que la tarea de ...", 
"body" : "La planificación del movimiento del grupo de ejes se realiza en una tarea separada que se crea automáticamente con el nombre \"SoftMotion_PlanningTask\" cuando se inserta un grupo de ejes. De forma predeterminada, esta tarea de planificación se ejecuta en el mismo núcleo de procesador que la tarea de bus. En sistemas multinúcleo, es recomendable ubicarlos en un núcleo separado. Dependiendo de si la tarea de planificación se ejecuta o no en su propio núcleo, es necesario configurarla de manera diferente. Núcleo simple Si la tarea de planificación se ejecuta en el mismo núcleo que la tarea del bus, entonces debe configurarse como una tarea libre con baja prioridad en tiempo real. Este es el caso por defecto. La tarea de planificación se crea automáticamente como una tarea libre con prioridad 15. multinúcleo En sistemas multinúcleo, la tarea de planificación debe ejecutarse en un núcleo separado con la prioridad más alta (0). El tipo de tarea debe establecerse en cíclico y el intervalo de tarea en un valor bajo (por ejemplo, 2 ms). Con esta configuración, la tarea de planificación frecuentemente excederá su intervalo de tarea. Esto es de esperarse y no es un problema. La configuración de la tarea se selecciona para garantizar que la tarea de planificación se vuelva a llamar inmediatamente después de una ejecución. De esta manera, el núcleo dedicado se utiliza tanto como sea posible para la planificación del movimiento. Para obtener más información sobre la configuración de tareas, consulte: Configuración de tareas Objeto: Configuración de tareas Objeto: Tarea " }, 
{ "title" : "Cinemática ", 
"url" : "_sm_robotics_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Descripción general ", 
"url" : "_sm_overview_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Descripción general ", 
"snippet" : "Una de las tareas más importantes de la robótica es mover una herramienta (por ejemplo, una placa de herramientas o una pistola de soldar) a lo largo de una ruta predefinida. Para ello, CODESYS SoftMotion Robotics calcula cómo deben moverse las articulaciones individuales del robot para que la punta...", 
"body" : "Una de las tareas más importantes de la robótica es mover una herramienta (por ejemplo, una placa de herramientas o una pistola de soldar) a lo largo de una ruta predefinida. Para ello, CODESYS SoftMotion Robotics calcula cómo deben moverse las articulaciones individuales del robot para que la punta de la herramienta, el punto central de la herramienta (TCP), siga la trayectoria ordenada con la orientación deseada. La cinemática o la transformación cinemática son fundamentales para este cálculo. Implementa la conversión de posiciones conjuntas a posición TCP y orientación TCP, y La regla de cálculo varía según el tipo de robot que se utilice. CODESYS SoftMotion Robotics incluye cinemática configurable para numerosos robots estándar. Para obtener más información, consulte: Cinemática incluida en La cinemática se divide en cinemáticas de posicionamiento y orientación que se pueden combinar. Para obtener más información, consulte: Combinación de cinemática de posición y orientaciónSe puede configurar una compensación de herramienta que se puede cambiar en tiempo de ejecución. Para obtener más información, consulte: Configuración de una compensación de herramientaLos ejes modulares que giran sin cesar son compatibles con las juntas giratorias. Para obtener más información, consulte: Juntas rotativas y ejes de móduloPara tipos de robots especiales cuya regla de cálculo no se puede mapear mediante una de las cinemáticas suministradas, puede implementar su propia cinemática en forma de bloque de funciones. Para obtener más información, consulte: Creación de cinemáticas personalizadas" }, 
{ "title" : "Cinemática incluida en CODESYS SoftMotion ", 
"url" : "_sm_robotics_cds_sm_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Cinemática incluida en CODESYS SoftMotion ", 
"snippet" : "Sistemas de pórtico Nombre Representación Se puede vincular con cinemática de orientación. información adicional Gantry2 ✓ Kin_Gantry2 (FB) Gantry3 ✓ Kin_Gantry3 (FB) HGantry2 ✓ Kin_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ Kin_TGantry2 (FB) pórtico de 5 ejes -- Kin_5Ejes (FB) Sistemas S...", 
"body" : "Sistemas de pórtico Nombre Representación Se puede vincular con cinemática de orientación. información adicional Gantry2 ✓ Kin_Gantry2 (FB) Gantry3 ✓ Kin_Gantry3 (FB) HGantry2 ✓ Kin_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ Kin_TGantry2 (FB) pórtico de 5 ejes -- Kin_5Ejes (FB) Sistemas SCARA Nombre Representación Se puede vincular con cinemática de orientación. información adicional Polar ✓ Kin_Polar (FB) Polar con eje Z ✓ Kin_Polar_Z (FB) Scara2 con eje Z ✓ Kin_Scara2_Z (FB) Scara3 con eje Z -- Kin_Scara3_Z (FB) Robots articulados Nombre Representación Se puede vincular con cinemática de orientación. información adicional Robot articulado de 3 ejes giratorios. ✓ Kin_Pos_RRR (FB) paletizador de 4 ejes -- Paletizador Kin_4Axes (FB) robot articulado de 6 ejes -- Kin_ArticulatedRobot_6DOF (FB) Sistemas paralelos Nombre Representación Se puede vincular con cinemática de orientación. información adicional Bípode con ejes giratorios. ✓ Kin_Bipod_Rotary (FB) Trípode con ejes giratorios. ✓ Kin_Tripod_Rotary (FB) Trípode con ejes lineales. ✓ Kin_Tripod_Linear (FB) Cinemática de orientación Nombre Representación información adicional eje C Kin_CAxis (FB) Eje C con herramienta Kin_CAxis_Tool (FB) Herramienta Kin_Tool (FB) Wrist2 Kin_Wrist2 (FB) Wrist3 Kin_Wrist3 (FB) " }, 
{ "title" : "Combinación de cinemática de posición y orientación ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Combinación de cinemática de posición y orientación ", 
"snippet" : "Con el configurador de grupos de ejes se pueden combinar cinemáticas de posición y cinemáticas de orientación. De este modo se pueden configurar un gran número de robots con un número reducido de cinemáticas. Los ejemplos de cinemática de posición incluyen pórticos ( Kin_Gantry3 ) y trípodes ( Kin_T...", 
"body" : "Con el configurador de grupos de ejes se pueden combinar cinemáticas de posición y cinemáticas de orientación. De este modo se pueden configurar un gran número de robots con un número reducido de cinemáticas. Los ejemplos de cinemática de posición incluyen pórticos ( Kin_Gantry3 ) y trípodes ( Kin_Tripod_Lin , Kin_Tripod_Rotary ). Estas cinemáticas pueden viajar a cualquier punto o posición, pero no pueden realizar ninguna cantidad de orientaciones. El sistema de coordenadas frontal de un sistema cinemático de posición se denomina sistema de coordenadas de brida. Define el lugar donde se fijan las cinemáticas de orientación (figura de la izquierda). Ejemplos de cinemática de orientación son Kin_CAxis , Kin_Wrist2 , y Kin_Wrist3 . Esta cinemática puede resultar en una orientación deseada del TCP, pero no puede alcanzar ninguna posición (vea la figura a la derecha). Al combinar la cinemática de posición y la cinemática de orientación, es posible recorrer cualquier número de posiciones en la orientación deseada o al revés. Observaciones sobre cinemáticas personalizadas Los usuarios que quieran crear su propia cinemática de posición u orientación deben implementar las siguientes interfaces adicionales en sus bloques de funciones cinemáticas: Para cinemática de posiciones: la interfaz ISMPositionKinematics2 con los métodos AxesToOrientation y GetOrientationImage . AxesToOrientation es una transformación directa \"abreviada\" que calcula la orientación del sistema de coordenadas de la brida a partir de los valores del eje. Es necesario sólo por razones de eficiencia. Por ejemplo, con un pórtico no se tiene que calcular nada, sino que se puede devolver una orientación constante. GetOrientationImage devuelve cómo puede cambiar la orientación del sistema de coordenadas de la brida. Este método sólo es necesario para comprobar si la cinemática de orientación es compatible con la cinemática de posición. Para la cinemática de orientación: la interfaz ISMToolKinematics2 con los métodos GetPositionFromOrientation2 y IsCompatibleWithPosKin . GetPositionFromOrientation2 calcula el vector entre el sistema de coordenadas de la brida y TCP a partir de la orientación deseada (en MCS). Este cálculo es necesario para la transformación inversa de la cinemática combinada. El método IsCompatibleWithPosKin comprueba si la cinemática de orientación es compatible con la cinemática de posición. " }, 
{ "title" : "Combinaciones no válidas ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_718d71abf014b14bc0a864635271f262", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Combinación de cinemática de posición y orientación \/ Combinaciones no válidas ", 
"snippet" : "No todas las combinaciones de cinemática de posición y cinemática de orientación son posibles porque a veces no se puede determinar una transformación inversa única. Un ejemplo es un SCARA con dos juntas articuladas como cinemática de posición y Kin_CAxis_Tool como cinemática de orientación con una ...", 
"body" : "No todas las combinaciones de cinemática de posición y cinemática de orientación son posibles porque a veces no se puede determinar una transformación inversa única. Un ejemplo es un SCARA con dos juntas articuladas como cinemática de posición y Kin_CAxis_Tool como cinemática de orientación con una corrección de herramienta que no es 0 en la coordenada X o Y. La orientación del sistema de coordenadas de la brida del SCARA no es constante. Se gira sobre el eje Z en relación con la posición 0. Para el cálculo de la transformación inversa, esta rotación aún no se conoce, lo que hace imposible determinar claramente los ángulos de los ejes en este caso. Si una combinación es posible se puede comprobar en tiempo de ejecución, ya que depende de la parametrización de la cinemática. En este caso, el error SMC_TRAFO_INVALID_COUPLING se emite. " }, 
{ "title" : "Comportamiento al programar orientaciones \"imposibles\" ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_5ba01e61f014b14bc0a86463044fcdf7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Combinación de cinemática de posición y orientación \/ Comportamiento al programar orientaciones \"imposibles\" ", 
"snippet" : "En la práctica, suele ser útil poder programar orientaciones que no están disponibles para la cinemática. Como ejemplo simple, considere un robot SCARA con una herramienta que tiene un grado de libertad (rotación sobre el eje Z). En principio, este robot solo puede aceptar orientaciones en las que l...", 
"body" : "En la práctica, suele ser útil poder programar orientaciones que no están disponibles para la cinemática. Como ejemplo simple, considere un robot SCARA con una herramienta que tiene un grado de libertad (rotación sobre el eje Z). En principio, este robot solo puede aceptar orientaciones en las que la herramienta apunte verticalmente hacia abajo. Cuando se deban recorrer posiciones en una pieza de trabajo, se inclinará fácilmente desde el plano X\/Y. El usuario enseña la pieza de trabajo y luego programa las posiciones y orientaciones relativas a la pieza de trabajo. La inclinación de la pieza de trabajo da como resultado orientaciones en las que la dirección de la herramienta está ligeramente inclinada con respecto a la vertical. ¿Cómo afrontamos una orientación tan imposible e inalcanzable? Una medida drástica sería denunciar una infracción del espacio de trabajo. Sin embargo, como muestra el ejemplo, esto haría que la programación fuera tediosa. Por lo tanto, la cinemática de orientación ( Kin_CAxis_Tool en este ejemplo) se implementan de tal manera que asumen la orientación más cercana posible. En este ejemplo, esto significa que la orientación ordenada se inclina de tal manera que la herramienta se mantiene vertical y se acepta esta orientación. El comportamiento se puede reducir a las siguientes reglas (siempre que la cinemática de posición pueda posicionarse en las tres direcciones espaciales): La posición siempre se aproxima exactamente (de lo contrario, se informa de un error). La orientación se \"proyecta\" a la accesible más cercana si no se puede alcanzar. Al proyectar la orientación, la dirección de la herramienta tiene prioridad. Las dificultades descritas aquí surgen porque la cinemática de orientación no tiene los tres grados de libertad para lograr todas las orientaciones deseadas. Este es el caso de Kin_Wrist2 y Kin_CAxis , pero no con Kin_Wrist3 . Surgen dificultades adicionales cuando la cinemática de posición tampoco tiene todos los grados de libertad espacial. (Esto no ocurre a menudo en la práctica.) Un ejemplo es la combinación de Kin_Gantry2 , un pórtico que solo se puede colocar en X\/Y, y con Kin_Wrist2 , una herramienta con sólo dos grados de libertad. En este caso, existen orientaciones imposibles y posiciones imposibles, porque la coordenada Z ya está definida por la longitud de la herramienta y la posición del eje de orientación. Por lo tanto, le recomendamos que no utilice este tipo de combinaciones, sino que programe solo las posiciones alcanzables. " }, 
{ "title" : "Configuraciones cinemáticas ", 
"url" : "_sm_configure_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Configuraciones cinemáticas ", 
"snippet" : "Una configuración cinemática describe la disposición de los ejes en un grupo de ejes entre sí. Dependiendo de la cinemática, son posibles varias configuraciones para la misma posición TCP. Por ejemplo, se muestran dos configuraciones posibles para SCARA 2. El grupo de ejes tiene una configuración ac...", 
"body" : "Una configuración cinemática describe la disposición de los ejes en un grupo de ejes entre sí. Dependiendo de la cinemática, son posibles varias configuraciones para la misma posición TCP. Por ejemplo, se muestran dos configuraciones posibles para SCARA 2. El grupo de ejes tiene una configuración activa que no necesariamente tiene que corresponder a las posiciones actuales de los ejes. Si se ordena un movimiento, la posición de destino se puede convertir en coordenadas de eje. Se utiliza la configuración que está activa en el momento del comando. Esta configuración activa se puede establecer con el bloque de función SMC_SetKinConfiguration . Durante la inicialización y cada vez que se cambia la cinemática, el grupo de ejes aplica la configuración estándar. Toda cinemática con una configuración tiene una configuración estándar. No es posible un movimiento de CP entre dos configuraciones. En este caso, el posicionamiento debe realizarse mediante un movimiento PTP. La configuración actual se puede determinar con el bloque de función MC_GroupReadActualPosition . " }, 
{ "title" : "Establecer la configuración para un diseño cinemático ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b2318eb4acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Configuraciones cinemáticas \/ Establecer la configuración para un diseño cinemático ", 
"snippet" : "Cada diseño cinemático con una configuración tiene su propia POU para calcular los datos de configuración. El nombre de este bloque de función corresponde al nombre de la cinemática más el sufijo _config . La POU convierte las diferentes configuraciones en el tipo de datos ConfigData . Este tipo de ...", 
"body" : "Cada diseño cinemático con una configuración tiene su propia POU para calcular los datos de configuración. El nombre de este bloque de función corresponde al nombre de la cinemática más el sufijo _config . La POU convierte las diferentes configuraciones en el tipo de datos ConfigData . Este tipo de datos se pasa al bloque de funciones SMC_SetKinConfiguration . Ejemplo: establecer una configuración para un diseño cinemático SCARA 2 Llamar al bloque de funciones Kin_Scara2_Z_Config de la biblioteca SM3_Transformation . Aporte xElbowRight = VERDADERO El bloque de funciones produce los datos de configuración de tipo ConfigData . Llamar al bloque de funciones SMC_SetKinConfiguration de la biblioteca SM3_Robotics . Escribe la entrada ConfigData con los datos de configuración previamente determinados. Establecer la configuración activa del SCARA 2. VAR\n config: TRAFO.Kin_Scara2_Z_Config;\n skc: SMC_SetKinConfiguration;\nEND_VAR\n\nconfig(xElbowRight := TRUE);\nskc(AxisGroup := Scara2, Execute := TRUE, ConfigData := config.Config); " }, 
{ "title" : "Manejo de cinemáticas acopladas ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b22c1067acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Configuraciones cinemáticas \/ Manejo de cinemáticas acopladas ", 
"snippet" : "La cinemática acoplada existe cuando la cinemática de posición y la cinemática de orientación se utilizan simultáneamente. Esto da como resultado la configuración \"acoplada\" de ambas configuraciones llamando Kin_Coupled_Config de la biblioteca SM3_Transformation . La configuración de la cinemática d...", 
"body" : "La cinemática acoplada existe cuando la cinemática de posición y la cinemática de orientación se utilizan simultáneamente. Esto da como resultado la configuración \"acoplada\" de ambas configuraciones llamando Kin_Coupled_Config de la biblioteca SM3_Transformation . La configuración de la cinemática de posición y la cinemática de orientación se proporciona al bloque de función en las entradas. Para más información, ver: Ejes rotativos con rango de valor superior a 360 °" }, 
{ "title" : "Configuración de una compensación de herramienta ", 
"url" : "_sm_configure_tool_offset.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Configuración de una compensación de herramienta ", 
"snippet" : "Puede ajustar la compensación entre el sistema de coordenadas de la brida de la cinemática (XYZ) y el sistema de coordenadas TCP de la cinemática (X'Y'Z') mediante la configuración de una corrección de herramienta. Este corrector de herramienta actúa sobre todos los movimientos posteriores. TCP: Pun...", 
"body" : "Puede ajustar la compensación entre el sistema de coordenadas de la brida de la cinemática (XYZ) y el sistema de coordenadas TCP de la cinemática (X'Y'Z') mediante la configuración de una corrección de herramienta. Este corrector de herramienta actúa sobre todos los movimientos posteriores. TCP: Punto central de la herramienta El corrector de herramienta se especifica mediante un cambio v=(x,y,z) y una rotacion r=(A,B,C) en ZYZ ángulos de Euler. El desplazamiento y la rotación se expresan en relación con el sistema de coordenadas de brida de la cinemática. Cuando configura una compensación de herramienta, puede ser incompatible con la cinemática actual. Como resultado, una corrección de herramienta puede provocar que la cinemática no pueda alcanzar orientaciones. En esta situación, se emite un error y se ignora la compensación de herramienta. Por ejemplo, puede configurar una corrección de herramienta en la dirección Z para la cinemática. Kin_Scara2_Z . Por otro lado, un desplazamiento con piezas en la dirección X o Y produce un error. Cuando la cinemática tiene este tipo de restricciones, se describen con el cinemática . " }, 
{ "title" : "Bloque de funciones: SMC_GroupSetTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_348cb75b4119d4bfc0a864631ca28fed", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Configuración de una compensación de herramienta \/ Bloque de funciones: SMC_GroupSetTool ", 
"snippet" : "El bloque de funciones configura la compensación de herramienta especificada en la entrada ToolOffset (escribe MC_COORD_REF ) para un grupo de ejes. Sin embargo, siempre que el grupo de ejes esté en el estado GroupDisabled o GroupErrorStop , No se puede configurar el corrector de herramienta. Si la ...", 
"body" : "El bloque de funciones configura la compensación de herramienta especificada en la entrada ToolOffset (escribe MC_COORD_REF ) para un grupo de ejes. Sin embargo, siempre que el grupo de ejes esté en el estado GroupDisabled o GroupErrorStop , No se puede configurar el corrector de herramienta. Si la herramienta no es compatible con la cinemática actual, entonces la POU emite el error SMC_AXIS_GROUP_TOOL_OFFSET_INCOMPATIBLE_WITH_KINEMATICS . Este error también se emite si la interfaz ISMKinematicsWithOrientationImage no se ha implementado para la descripción de la cinemática. " }, 
{ "title" : "Bloque de funciones: SMC_GroupReadTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_c1689be51d4132b4c0a864637c06bdff", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Configuración de una compensación de herramienta \/ Bloque de funciones: SMC_GroupReadTool ", 
"snippet" : "Este bloque de función lee la compensación de herramienta: salida ToolOffset (escribe MC_COORD_REF ). En este proceso, la entrada ReadMode determina si se debe leer la herramienta del movimiento activo, el último movimiento ordenado o la herramienta configurada actualmente en el grupo de ejes....", 
"body" : "Este bloque de función lee la compensación de herramienta: salida ToolOffset (escribe MC_COORD_REF ). En este proceso, la entrada ReadMode determina si se debe leer la herramienta del movimiento activo, el último movimiento ordenado o la herramienta configurada actualmente en el grupo de ejes. " }, 
{ "title" : "cinemáticas compatibles ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_ff04bb6d41a8190bc0a864635e26fe13", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Configuración de una compensación de herramienta \/ cinemáticas compatibles ", 
"snippet" : "No todas las cinemáticas admiten todas las compensaciones de herramienta. La siguiente lista muestra qué herramientas son adecuadas para qué cinemática. Cinemática Herramienta Compatible Cinemática SCARA 2 Kin_Scara2_Z Herramientas con desplazamiento de posición en la dirección Z y desplazamiento en...", 
"body" : "No todas las cinemáticas admiten todas las compensaciones de herramienta. La siguiente lista muestra qué herramientas son adecuadas para qué cinemática. Cinemática Herramienta Compatible Cinemática SCARA 2 Kin_Scara2_Z Herramientas con desplazamiento de posición en la dirección Z y desplazamiento en la orientación SCARA 3 cinemática Kin_Scara3_Z Todas las herramientas cinemática polar Kin_Polar , Kin_Polar_Z Herramientas con desplazamiento de posición en la dirección Z y desplazamiento en la orientación robot articulado de 3 ejes Kin_Pos_RRR Herramientas con desplazamiento en la orientación robot articulado de 6 ejes Kin_ArticulatedRobot_6DOF Todas las herramientas paletizador de 4 ejes Kin_4AxisPalletizer Todas las herramientas bípode Kin_Bipod_Rotary Todas las herramientas pórtico de 5 ejes Kin_5Axes Todas las herramientas Sistemas de pórtico Todas las herramientas Sistema de pórtico en H Todas las herramientas sistema de pórtico en T Todas las herramientas Trípode giratorio o lineal Todas las herramientas Si un sistema cinemático no tiene 3 grados de libertad para la orientación, es posible que no todos los correctores de herramientas sean compatibles. " }, 
{ "title" : "Para cinemática personalizada ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_6c7b39581d4132b4c0a8646366a3228c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Configuración de una compensación de herramienta \/ Para cinemática personalizada ", 
"snippet" : "Para utilizar su cinemática personalizada con una compensación de herramienta, debe implementar la ISMKinematicsWithOrientationImage interfaz. Para agregar un desplazamiento de herramienta para su cinemática de posición personalizada, primero debe implementar la interfaz ISMPositionKinematics2 ....", 
"body" : "Para utilizar su cinemática personalizada con una compensación de herramienta, debe implementar la ISMKinematicsWithOrientationImage interfaz. Para agregar un desplazamiento de herramienta para su cinemática de posición personalizada, primero debe implementar la interfaz ISMPositionKinematics2 . " }, 
{ "title" : "Interfaz: ISMKinematicsWithOrientationImage ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_592ee99f1d4132b4c0a864637bd8a061", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Configuración de una compensación de herramienta \/ Interfaz: ISMKinematicsWithOrientationImage ", 
"snippet" : "La interfaz cinemática proporciona el método GetFlangeOrientationImage con la variable mR_Flange de tipo de datos SMC_Matrix3 , que contiene la orientación ordenada de la brida. Como consecuencia, el método devuelve posibles orientaciones resultantes oriInfo como tipo de datos OrientationSpace . Com...", 
"body" : "La interfaz cinemática proporciona el método GetFlangeOrientationImage con la variable mR_Flange de tipo de datos SMC_Matrix3 , que contiene la orientación ordenada de la brida. Como consecuencia, el método devuelve posibles orientaciones resultantes oriInfo como tipo de datos OrientationSpace . Comportamiento de la interfaz En particular, cuando se conoce la orientación de la brida en la orientación ordenada, dof = zero se devuelve y mOriZero está ajustado a la orientación conocida. Si la orientación R de la brida se conoce sólo parcialmente en la forma R*vU = vRot (donde vU y vRot son vectores unitarios conocidos), entonces dof = one es regresado. mOriZero se establece en una orientación en el espacio alcanzable. De lo contrario, dof = three es regresado. Una compensación de herramienta especificada es compatible con la cinemática si la posición de la brida se puede calcular de forma única teniendo en cuenta la orientación calculada. Este es siempre el caso cuando la orientación calculada puede lograrse mediante la cinemática. La corrección de la herramienta puede ser incompatible solo si no se pueden alcanzar todas las orientaciones. Además, si el método GetFlangeOrientationImage devoluciones dof = zero , entonces todas las compensaciones de herramienta son compatibles. Si el método devuelve dof = one , entonces solo el desplazamiento de la posición de la herramienta v_off paralelo al vector unitario vU es compatible. En este caso, R*v_off = R*vU*x = vRot*x no depende de las partes desconocidas de la matriz de orientación R . Esto también incluye un corrector de herramienta con v_off = 0 (donde x = 0). Si dof = three se devuelve, entonces solo los cambios de posición sin un desplazamiento en x\/y\/z son compatibles. Notas de implementación Implementar la interfaz ISMOrientationKinematicsWithOriImage2 para la cinemática de orientación. Entonces se puede utilizar una corrección de herramienta para acoplar la cinemática de orientación con la cinemática de posición. La interfaz tiene el método GetOrientationImage2 con la variable VAR_IN_OUT CONSTANT mR_Flange de tipo de datos SMC_Matrix3 , que contiene la orientación ordenada de la brida. El método vuelve csTool y oriinfo con el tipo de datos OrientationSpace en el sistema de coordenadas base de la cinemática de orientación. Además, el método regresa en bActive si los grados de libertad de orinfo están activos ( TRUE ) o pasivo ( FALSE ). Ejemplo de grados de libertad activos: Kin_CAxis . La rotación sobre el eje z está controlada por el eje cinemático de orientación. Ejemplo de grados de libertad pasivos: Kin_Wrist2 . El grado de libertad restante es la rotación de X\/Y sobre el eje Z, que apunta en la dirección programada por el usuario. Cuando tanto el último movimiento comandado como el nuevo movimiento son movimientos CP (ambos movimientos lineales o giratorios) durante un cambio de herramienta, el modo de búfer del movimiento subsiguiente cambia de Blending o Aborting a Buffered . Si configura una nueva corrección de herramienta después MC_GroupInterrupt y antes MC_GroupContinue , entonces se utiliza la antigua corrección de herramienta para los movimientos interrumpidos. El nuevo corrector de herramienta se utiliza solo para movimientos que se ordenan posteriormente. Cuando se cambia la cinemática ( MC_SetKinTransform ), la corrección de la herramienta se restablece (sin cambio, sin rotación). " }, 
{ "title" : "Juntas rotativas y ejes de módulo ", 
"url" : "_sm_robotics_rotary_joints_modulo_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Juntas rotativas y ejes de módulo ", 
"snippet" : "Los ejes Modulo dentro de los grupos de ejes son compatibles a partir de SoftMotion 4.12.0.0. Los ejes Modulo solo están permitidos para juntas giratorias de cinemática. Son juntas giratorias para las que SMKinematicWithInfo.GetAxisProperties devuelve el valor props.eType = Axis_Type.Rotary . Si se ...", 
"body" : "Los ejes Modulo dentro de los grupos de ejes son compatibles a partir de SoftMotion 4.12.0.0. Los ejes Modulo solo están permitidos para juntas giratorias de cinemática. Son juntas giratorias para las que SMKinematicWithInfo.GetAxisProperties devuelve el valor props.eType = Axis_Type.Rotary . Si se utiliza un eje de módulo para una articulación lineal o para una cinemática que no implementa ISMKinematicWithInfo , después MC_GroupEnable devuelve el SMC_MODULO_AXIS_FOR_NON_ROTARY_JOINT error. Si se utiliza un eje de módulo y la cinemática limita el rango de una junta giratoria, entonces MC_GroupEnable devuelve el SMC_MODULO_AXIS_FOR_LIMITED_ROTARY_JOINT error. Los ejes de módulo solo se admiten si el período de módulo es de 360°. La razón de esto es que los ejes conectados a juntas giratorias deben configurarse de tal manera que una unidad técnica [u] corresponda a un grado angular [°]. Un período tiene que corresponder a una rotación completa. Si se utiliza un eje de módulo con un período distinto de 360°, entonces MC_GroupEnable devuelve el SMC_MODULO_AXIS_PERIOD_NOT_360 error. A partir de la versión 4.12.0.0, SoftMotion solo admite el shortest modo ( MC_DIRECTION ). Esto significa que la distancia y la dirección de un eje de módulo se seleccionan de tal manera que estén lo más cerca posible de la posición inicial del eje. Por ejemplo, si el eje de orientación está en a2 = 30° al comienzo del movimiento y en a2 = 290° en la posición de destino, entonces se selecciona la posición a2 = 290° – 360° = –70° y el eje se mueve 100° en dirección negativa en lugar de moverse 260° en dirección positiva. " }, 
{ "title" : "Creación de cinemáticas personalizadas ", 
"url" : "_sm_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinemática \/ Creación de cinemáticas personalizadas ", 
"snippet" : "La herramienta de código abierto wkhtmltopdf es necesario para generar la documentación para la cinemática a partir de los comentarios en el bloque de funciones. Sin embargo, este componente ya no está incluido en la configuración de CODESYS versión 3.5 SP15 y superior. Puede descargar la DLL desde ...", 
"body" : "La herramienta de código abierto wkhtmltopdf es necesario para generar la documentación para la cinemática a partir de los comentarios en el bloque de funciones. Sin embargo, este componente ya no está incluido en la configuración de CODESYS versión 3.5 SP15 y superior. Puede descargar la DLL desde https:\/\/wkhtmltopdf.org\/downloads.html . Crear un directorio llamado DocScripting\\3.5.xx.x\\bin en el directorio de instalación de CODESYS y guarde el archivo wkhtmltox.dll allí. Precaución: desde wkhtmltox.dll ya no admite imágenes de forma predeterminada en la versión 0.12.6 y superior, debe usar la versión 0.12.5 o inferior. Cuando se utiliza una instancia de una transformación cinemática de un grupo de ejes, las entradas de la instancia no deben cambiarse más. Para cambiar la parametrización de la transformación cinemática, debe utilizar la configuración si es posible o crear varias instancias. Cuando crea cinemática personalizada, debe observar lo siguiente: La cinemática se describe mediante bloques de funciones especiales que se pueden almacenar en bibliotecas o en el POU vista del proyecto. Para CODESYS Para enumerar las cinemáticas en el configurador, los bloques de función asociados deben implementar el MC_KIN_REF_SM3 interfaz (parte de SM3_Transformation.library ). Puede definir la cinemática como una combinación de otras dos cinemáticas. Las cinemáticas con posibilidad de acoplar placas de herramientas o herramientas también deben implementar la ISMPosiciónCinemática2 interfaz. Las cinemáticas que especifican una placa de herramienta o una herramienta tienen que implementar el ISMToolCinemática2 interfaz. Si implementas solo ISMPositionKinematics \/ ISMToolKinematics en vez de ISMPositionKinematics2 \/ ISMToolKinematics2 , entonces las orientaciones \"no disponibles\" podrían procesarse incorrectamente. Cuando también implementas la interfaz ISMPositionKinematics_Offset , puede utilizar el modo de orientación Axis . Cuando el POU tiene la sm_kin_libdoc atributo, el comentario especificado en el bloque de función se utiliza en el configurador como descripción de la cinemática. Para ello se utiliza el formato de \"Texto reestructurado\". Tenga en cuenta, sin embargo, que los enlaces no son compatibles. Los parámetros relacionados con el diseño, como las longitudes y los ángulos de los brazos, se crean como variables VAR_INPUT del bloque de funciones. Debes comentar los parámetros porque el comentario sirve como descripción en el configurador. Si los parámetros son de tipo numérico y su rango de valores está restringido, entonces se les debe proporcionar la sm_kin_param_range atributo. La sintaxis del rango de valores es [a .. b] para intervalos cerrados y ]a .. b[ para intervalos abiertos. Las formas combinadas ]a .. b] y [a .. b[ también son posibles. Para este propósito, a y b tienen que ser literales apropiados para el tipo de parámetro. Los valores especiales +inf y -inf son posibles para los límites de intervalo abiertos. Ejemplos: [0 .. 1] , [1 .. +inf[ , ]-inf .. -5] . Los parámetros pueden ser de cualquier tipo numérico o BOOL . Los parámetros deben tener un valor inicial que se utilice como valor predeterminado. Puede especificar la unidad del parámetro con el atributo opcional sm_kin_param_unit (ejemplo: \"rad\", \"°\", \"grados\"). Debes usar la unidad \"u\" para longitudes y distancias. La aplicación y la escala de las unidades determinan si estas unidades son \"mm\", \"cm\" o \"m\". Si no hay documentación de biblioteca disponible para el bloque de funciones, el comentario del elemento FB se muestra en las posiciones respectivas como opción alternativa. El idioma configurado en CODESYS es el idioma que se muestra para la documentación de LibDoc. Si una localización no está disponible en este idioma, se utiliza el idioma predeterminado de la biblioteca. Los nombres de eje de la cinemática están definidos por el atributo FB sm_kin_axes . El valor del atributo es una lista de nombres de ejes (ejemplo: \"A1, A2, A3\"). Se especifica un icono opcional con el atributo FB sm_kin_icon . El valor se especifica en la forma <image pool>.<identifier> . El conjunto de imágenes se especifica en relación con el bloque de funciones. Si crea un bloque de función de cinemática personalizado con ejes giratorios (por ejemplo, Kin_Scara3_Z_Config ), entonces debe usar el concepto de período para estos ejes e implementar el ISMKinPeriodHandling interfaz. Para ejes rotativos, sólo la transformación cinemática inversa ( CartesianToAxes ) es responsable del cálculo del ángulo. Entonces CODESYS SoftMotion cambia automáticamente este ángulo al período correcto. Por ejemplo, si la transformación calcula un ángulo en el rango ]-180°, 180°], entonces CODESYS SoftMotion cambia este ángulo al rango [0°, 360°[, siempre que los límites del software de la unidad sean 0° .. 360°. Además, debe implementar la ISMKinematicsWithConfiguration3 interfaz. Esta es la única forma de asegurarse de que la cinemática de los movimientos CP funcione sin problemas. En el caso de cinemáticas acopladas con un diseño irregular de cinemáticas de posición y orientación, debe implementar el ISMCoupledKinematics3 interfaz. De esta forma, el sistema puede detectar si un eje para la cinemática de posición u orientación pertenece o no al número de eje respectivo. Nota: Debe implementar el ISMKinematicWithConfigurations2.CPConnectible método de tal manera que la configuración del período se ignora en la comparación. Entonces CPConnectible devuelve el valor TRUE , incluso si la configuración del período es diferente. Todas las transformaciones inversas tienen una entrada de tipo CONFIGDATA que contiene una matriz de bytes con información sobre la configuración de la cinemática. Las transformaciones directas tienen una salida correspondiente. Las cinemáticas con una configuración tienen que implementar el ISMKinematicWithConfigurations interfaz. Cada una de estas cinemáticas incluye un bloque de función que tiene que implementar el ISMConfigurationData interfaz (función para la serialización de los datos de configuración). El nombre de este bloque de funciones debe ser el mismo que cinemática más el sufijo _config . Puede utilizar este FB para modificar la configuración en la aplicación (mediante el bloque de función SMC_SetKinConfiguration cuadra). Sin embargo, la cinemática no debe contener ninguna instancia del FB correspondiente. Para obtener instrucciones paso a paso, consulte la Cinemática personalizada capítulo. " }, 
{ "title" : "Sistemas de coordenadas ", 
"url" : "_sm_coordinate_systems.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemas de coordenadas ", 
"snippet" : "CODESYS SoftMotion Robotics proporciona diferentes sistemas de coordenadas en los que se pueden controlar los movimientos. Sistema de coordenadas de ejes (ACS) Sistema de coordenadas de herramientas (TCS) Sistema mundial de coordenadas (WCS) Sistema de coordenadas de máquinas (MCS) Sistema de coorde...", 
"body" : "CODESYS SoftMotion Robotics proporciona diferentes sistemas de coordenadas en los que se pueden controlar los movimientos. Sistema de coordenadas de ejes (ACS) Sistema de coordenadas de herramientas (TCS) Sistema mundial de coordenadas (WCS) Sistema de coordenadas de máquinas (MCS) Sistema de coordenadas del producto (PCS_1, PCS_2) Sistema de coordenadas Descripción Sistema de coordenadas de ejes (ACS) El sistema de coordenadas del eje define un sistema de coordenadas en el espacio del eje donde cada eje del robot abarca una dimensión. Como resultado, se puede especificar una posición para cada eje del robot Sistema de coordenadas de herramientas (TCS) El sistema de coordenadas de la herramienta es un sistema de coordenadas cartesianas que se encuentra en el punto central de la herramienta (TCP) de la cinemática. Su posición y orientación dependen de la posición del robot Sistema mundial de coordenadas (WCS) El sistema de coordenadas mundial es un sistema de coordenadas cartesianas estático y constituye la base de todos los sistemas de coordenadas posteriores. Estos se definen en relación con el sistema de coordenadas mundial Sistema de coordenadas de máquinas (MCS) El sistema de coordenadas de la máquina es un sistema de coordenadas cartesianas estáticas. La posición y la orientación del MCS en relación con el robot físico están definidas por El Transformación de coordenadas MC_Set el bloque de funciones se puede usar para cambiar el sistema de coordenadas en relación con el sistema de coordenadas mundial (WCS). Sistema de coordenadas del producto (PCS_1, PCS_2) Los sistemas de coordenadas del producto son sistemas de coordenadas cartesianas que el usuario puede definir. Se expresan en relación con el sistema de coordenadas mundial (WCS) y pueden ser estáticos o dinámicos Estática El Transformación de coordenadas MC_Set el bloque de funciones se puede usar para mover los sistemas de coordenadas en relación con el sistema de coordenadas mundial (WCS). Dinámica Los siguientes bloques de funciones se pueden utilizar para definir sistemas de coordenadas dinámicos: MC_SetDynCoordTransform SMC_SetDynCoordTransformEx Cinta transportadora MC_Track Mesa giratoria MC_Track " }, 
{ "title" : "Posición inicial y orientación de los sistemas de coordenadas ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056579261585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemas de coordenadas \/ Posición inicial y orientación de los sistemas de coordenadas ", 
"snippet" : "La cinemática del robot determina la posición inicial y la orientación de los sistemas de coordenadas. Esto se describe en la documentación de la cinemática La cinemática define lo siguiente: Posición y orientación del sistema de coordenadas de la máquina (MCS) en relación con el robot físico Posici...", 
"body" : "La cinemática del robot determina la posición inicial y la orientación de los sistemas de coordenadas. Esto se describe en la documentación de la cinemática La cinemática define lo siguiente: Posición y orientación del sistema de coordenadas de la máquina (MCS) en relación con el robot físico Posición y orientación del punto central de la herramienta (TCP) en relación con el MCS y, por lo tanto, con el sistema de coordenadas de la herramienta (TCS) Posición cero del robot, así como las direcciones de rotación o movimiento de los ejes individuales El sistema de coordenadas mundial (WCS) y los sistemas de coordenadas del producto (PCS_1, PCS_2) no se desplazan inicialmente y son idénticos al sistema de coordenadas de la máquina. " }, 
{ "title" : "Múltiples robots y piezas ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581220108", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemas de coordenadas \/ Múltiples robots y piezas ", 
"snippet" : "La posición y la orientación de los sistemas de coordenadas se definen para cada robot. Cuando varios robots trabajan juntos, puede resultar útil definir el sistema de coordenadas mundiales (WCS) como un sistema de coordenadas base común. Basándose en este sistema de coordenadas, los sistemas de coo...", 
"body" : "La posición y la orientación de los sistemas de coordenadas se definen para cada robot. Cuando varios robots trabajan juntos, puede resultar útil definir el sistema de coordenadas mundiales (WCS) como un sistema de coordenadas base común. Basándose en este sistema de coordenadas, los sistemas de coordenadas de máquinas (MCS) y los sistemas de coordenadas de productos (PCS_1, PCS_2) de " }, 
{ "title" : "Ejemplo ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581719182", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemas de coordenadas \/ Ejemplo ", 
"snippet" : "Ejemplo de uso de un robot con dos juntas giratorias ( a0 y a1 )...", 
"body" : "Ejemplo de uso de un robot con dos juntas giratorias ( a0 y a1 ) " }, 
{ "title" : "Cinemática ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582142746", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemas de coordenadas \/ Ejemplo \/ Cinemática ", 
"snippet" : "La cinemática define la posición cero del robot (como se muestra a continuación). El origen del sistema de coordenadas de la máquina se encuentra en el eje de rotación del eje a0 . El eje X apunta en la dirección del primer enlace cuando la posición del primer a0 es 0 . El eje Y apunta en la direcci...", 
"body" : "La cinemática define la posición cero del robot (como se muestra a continuación). El origen del sistema de coordenadas de la máquina se encuentra en el eje de rotación del eje a0 . El eje X apunta en la dirección del primer enlace cuando la posición del primer a0 es 0 . El eje Y apunta en la dirección del primer enlace cuando la posición del primer a0 es +90° . La rotación en sentido contrario a las agujas del reloj corresponde a la dirección de rotación positiva. El punto central de la herramienta (TCP) se encuentra al final del segundo enlace del robot (como se muestra a continuación) y constituye el origen del TCS. El TCS está alineado de tal manera que el eje X discurre a lo largo del segundo enlace " }, 
{ "title" : "Sistema de coordenadas de ejes (ACS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582875889", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemas de coordenadas \/ Ejemplo \/ Sistema de coordenadas de ejes (ACS) ", 
"snippet" : "La cinemática ha especificado la posición cero del robot y la dirección de rotación de los ejes individuales. Porque el robot consta de dos ejes a0 y a1 , podemos especificar las posiciones de los ejes a0 y a1 en la ACS. En la primera imagen, especificamos la posición ( a0:= 0, a1:= 0 ). Esto corres...", 
"body" : "La cinemática ha especificado la posición cero del robot y la dirección de rotación de los ejes individuales. Porque el robot consta de dos ejes a0 y a1 , podemos especificar las posiciones de los ejes a0 y a1 en la ACS. En la primera imagen, especificamos la posición ( a0:= 0, a1:= 0 ). Esto corresponde a la posición cero del robot. En la segunda imagen, especificamos la posición ( a0:= 90, a1:= 0 ). Partiendo de la posición cero, el primer eje a0 está girado 90° en el sentido de rotación positivo. El segundo eje a1 permanece en la posición cero. En la tercera imagen, especificamos la posición ( a0:= 90, a1:= -90 ). Partiendo de la posición cero, el primer eje a0 está girado 90° en la dirección de rotación positiva (como en la segunda imagen). Además, el segundo eje a1 está girado 90° en el sentido de rotación negativo. " }, 
{ "title" : "Sistema de coordenadas de herramientas (TCS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056583569251", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemas de coordenadas \/ Ejemplo \/ Sistema de coordenadas de herramientas (TCS) ", 
"snippet" : "La cinemática define la posición y la orientación del TCP y el TCS. Dependiendo de cómo movamos el robot, la posición y la orientación del TCS...", 
"body" : "La cinemática define la posición y la orientación del TCP y el TCS. Dependiendo de cómo movamos el robot, la posición y la orientación del TCS " }, 
{ "title" : "Sistema de coordenadas mundial (WCS), sistema de coordenadas de máquinas (MCS) y sistema de coordenadas de productos (PCS_1, PCS_2) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056584038831", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemas de coordenadas \/ Ejemplo \/ Sistema de coordenadas mundial (WCS), sistema de coordenadas de máquinas (MCS) y sistema de coordenadas de productos (PCS_1, PCS_2) ", 
"snippet" : "En una nave de producción, dos robots se encuentran a la izquierda y a la derecha de una cinta transportadora. Los robots deben procesar los productos en la cinta transportadora. Definimos un sistema de coordenadas mundial común y lo colocamos en la esquina superior izquierda de nuestra nave de prod...", 
"body" : "En una nave de producción, dos robots se encuentran a la izquierda y a la derecha de una cinta transportadora. Los robots deben procesar los productos en la cinta transportadora. Definimos un sistema de coordenadas mundial común y lo colocamos en la esquina superior izquierda de nuestra nave de producción. Partiendo de este sistema de coordenadas, determinamos la distancia y la rotación entre los sistemas de coordenadas de la máquina y el producto, y cambiamos los sistemas de coordenadas en consecuencia En el ejemplo, todos los sistemas de coordenadas están alineados de la misma manera, por lo que solo necesitamos cambiar los sistemas de coordenadas. El sistema de coordenadas de la máquina del robot de la izquierda se desplaza en la dirección Y, el sistema de coordenadas de la máquina del robot de la derecha se desplaza en la dirección X y el sistema de coordenadas del producto se desplaza tanto en la dirección X como en la dirección " }, 
{ "title" : "Control de movimiento ", 
"url" : "_sm_f_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Descripción general ", 
"url" : "_sm_overview_robotics_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Descripción general ", 
"snippet" : "Este capítulo describe los tipos básicos de movimiento en robótica: Correr SMC_GroupJog2 Movimientos PTP (Punto a Punto) MC_MoveDirectAbsoluto MC_MoveDirectRelativo Movimientos CP (Camino Continuo) MC_MoveLinearAbsoluto MC_MoveLinearRelative MC_MoveCircularAbsoluto MC_MoveCircularRelativo Esperar SM...", 
"body" : "Este capítulo describe los tipos básicos de movimiento en robótica: Correr SMC_GroupJog2 Movimientos PTP (Punto a Punto) MC_MoveDirectAbsoluto MC_MoveDirectRelativo Movimientos CP (Camino Continuo) MC_MoveLinearAbsoluto MC_MoveLinearRelative MC_MoveCircularAbsoluto MC_MoveCircularRelativo Esperar SMC_GroupWait Detener (ver Detenerse en el camino con MC_GroupHalt o MC_GroupStop y Interrupción y continuación de movimientos) MC_GroupHalt MC_GroupStop MC_GroupInterrupción Además, también se explican todos los temas importantes relacionados con los movimientos: Amortiguación y combinación de movimientosSincronización con un sistema de coordenadas en movimientoSincronización de ejes externos, control de avance de parEjes adicionalesDiagnóstico en caso de movimientos lentos o espasmódicos." }, 
{ "title" : "Cómo crear un programa para controlar el grupo de ejes ", 
"url" : "_sm_creating_an_axis_group_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Cómo crear un programa para controlar el grupo de ejes ", 
"snippet" : "Las siguientes instrucciones describen cómo crear un programa para controlar un grupo de ejes. Requisito : Se ha creado un proyecto con un grupo de ejes, como se especifica en el Cómo crear un grupo de ejes capítulo. El programa para controlar un grupo de ejes se crea en el PLC_PRG POU con CFC como ...", 
"body" : "Las siguientes instrucciones describen cómo crear un programa para controlar un grupo de ejes. Requisito : Se ha creado un proyecto con un grupo de ejes, como se especifica en el Cómo crear un grupo de ejes capítulo. El programa para controlar un grupo de ejes se crea en el PLC_PRG POU con CFC como lenguaje de implementación. Abre el PLC_PRG programa en el editor. Arrastrar el Caja elemento al editor. Asignar el bloque de funciones SMC_GroupPower a la caja Configure el bloque de funciones de acuerdo con la siguiente imagen. Explicación: El bloque de funciones activa los accionamientos del grupo de ejes. La salida Status indica una habilitación exitosa del controlador. Crear un bloque de funciones de tipo MC_GroupEnable . Este bloque de funciones transfiere el control de los ejes vinculados al GrupoEje grupo de ejes. Conecta el Status salida de la SMC_GroupPower bloque de funciones para el Execute entrada de la MC_GroupEnable bloque de funciones Explicación: Cuando todos los controladores de ejes están encendidos ( Status = TRUE ), el control de los ejes se transfiere al grupo de ejes. El Done la salida informa el éxito del comando. Insertar un MC_MoveDirectAbsolute bloque de funciones para hacer funcionar el variador. Conecta el Done salida de la MC_GroupEnable bloque de funciones para el Execute entrada de la MC_MoveDirectAbsolute bloque de funciones Ampliar el programa de la siguiente manera: Explicación: El MC_MoveDirectAbsolute El bloque de funciones ordena un movimiento PTP del Grupo de ejes grupo de ejes. En el ejemplo, la cinemática se mueve a la posición (X = 10, Y= 20, Z = 30). Este valor se asigna a la Position entrada a través de la SMC_POS_REF estructura. La posición se especifica en el sistema de coordenadas de la máquina (MCS). El sistema de coordenadas se selecciona mediante el CoordSystem aporte. Iniciando el programa Si el programa se ha creado completamente y se puede compilar sin errores, entonces puede transferirlo al controlador. Iniciar el CODESYS Control Win sistema de ejecución ( CODESYSControlService.exe programa en el \"...\\GatewayPLC\" directorio). En el Configuración de comunicación , configure la ruta de conexión a su controlador. Hacer clic En línea → Acceso . Descargue el proyecto al controlador. Hacer clic Depurar → Iniciar . En el editor, abra el GrupoEje objeto. Se muestran las posiciones de los ejes. Hacer clic Depurar → Comenzar . Las posiciones de los ejes cambian. " }, 
{ "title" : "Movimiento de grupos de ejes ", 
"url" : "_sm_cartesian_jogging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Movimiento de grupos de ejes ", 
"snippet" : "Puedes usar el SMC_GroupJog2 bloque de funciones para mover un grupo de ejes en el espacio. El SMC_GroupJog2 El bloque de funciones tiene dos entradas booleanas para cada coordenada. Una entrada es para avanzar a lo largo de esta coordenada y la otra entrada es para avanzar hacia atrás. Las entradas...", 
"body" : "Puedes usar el SMC_GroupJog2 bloque de funciones para mover un grupo de ejes en el espacio. El SMC_GroupJog2 El bloque de funciones tiene dos entradas booleanas para cada coordenada. Una entrada es para avanzar a lo largo de esta coordenada y la otra entrada es para avanzar hacia atrás. Las entradas booleanas para las diferentes coordenadas de SMC_GroupJog2 se puede interpretar de diferentes maneras. Por ejemplo, en coordenadas cartesianas, coordenadas de máquina, coordenadas de eje o coordenadas de herramienta, dependiendo del sistema de coordenadas que se establezca. Con una entrada especial ABC_as_ACS: BOOL , tanto X\/Y\/Z como los ejes de la cinemática de la herramienta se pueden desplazar simultáneamente en coordenadas cartesianas y de eje. El avance \"mixto\" sólo se admite si las cinemáticas están acopladas y la cinemática de posición implementa la interfaz ISMPositionKinematics_Offset . (De lo contrario, el bloque de funciones generará un error). En el modo de avance lento, A gira el TCP sobre el eje X del sistema de coordenadas configurado (MCS, WCS, PCS o TCS). B y C rotan el TCP sobre los ejes Y y Z en el mismo sistema de coordenadas. Sin embargo, esto se aplica solo cuando ABC_as_ACS = FALSE . El movimiento cartesiano comienza cuando el SMC_GroupJog2 bloque de funciones recibe un flanco ascendente y establece el Busy producción. El jogging cartesiano provoca la interrupción de movimientos coordinados activos o movimientos de los ejes de la cinemática. El jogging cartesiano finaliza cuando el jogging es interrumpido por un movimiento (coordinado o sobre los ejes de la cinemática) o cuando la posición está fuera del espacio de trabajo. En jogging, los límites de los ejes siempre se mantienen en los ejes de la cinemática. Para más información, ver: Correr un robot" }, 
{ "title" : "Movimientos PTP de trayectoria invariante ", 
"url" : "_sm_robotics_path_invariant_ptp_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Movimientos PTP de trayectoria invariante ", 
"snippet" : "Para los movimientos PTP, la trayectoria en el espacio depende de la cinemática y solo se fijan los puntos de inicio y destino. El movimiento es totalmente síncrono, de modo que la fase de aceleración, movimiento constante y desaceleración de todos los ejes comienza y finaliza al mismo tiempo. Los m...", 
"body" : "Para los movimientos PTP, la trayectoria en el espacio depende de la cinemática y solo se fijan los puntos de inicio y destino. El movimiento es totalmente síncrono, de modo que la fase de aceleración, movimiento constante y desaceleración de todos los ejes comienza y finaliza al mismo tiempo. Los movimientos PTP son siempre invariantes en la trayectoria y, por lo tanto, se aplican las siguientes características: La ruta es independiente de la anulación. La trayectoria es independiente de todos los límites dinámicos de los ejes (límites de velocidad, aceleración, desaceleración y tirón). La única excepción es para determinar los puntos de corte en TMStartVelocity modo. En TMCornerDistance modo, la ruta es independiente del tipo de fusión ( BlendingHigh \/ Low \/ Previous \/ Next ). El camino no se abandona al detenerse o detenerse ( MC_GroupHalt \/ MC_GroupStop ). El camino no se abandona al interrumpir o continuar ( MC_GroupInterrupt \/ MC_GroupContinue ). " }, 
{ "title" : "Movimientos PC ", 
"url" : "_sm_robotics_cp_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Movimientos PC ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Descripción general ", 
"url" : "_sm_overview_robotics_motion_control_cp.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Movimientos PC \/ Descripción general ", 
"snippet" : "Los movimientos CP (Continuous Path) vienen dados por su recorrido geométrico. En el caso de la robótica, se trata de segmentos lineales ( MC_MoveLinearAbsolute y MC_MoveLinearRelative ) y segmentos circulares ( MC_MoveCircularAbsolute y MC_MoveCircularRelative ). Se puede especificar una velocidad ...", 
"body" : "Los movimientos CP (Continuous Path) vienen dados por su recorrido geométrico. En el caso de la robótica, se trata de segmentos lineales ( MC_MoveLinearAbsolute y MC_MoveLinearRelative ) y segmentos circulares ( MC_MoveCircularAbsolute y MC_MoveCircularRelative ). Se puede especificar una velocidad de trayectoria máxima, una aceleración de trayectoria máxima y una sacudida de trayectoria máxima para los movimientos CP. Si la combinación se realiza entre dos movimientos CP y ambos movimientos se encuentran en un plano común, entonces este plano no se abandona durante la combinación. Por ejemplo, dos segmentos de recta consecutivos siempre se encuentran en el mismo plano. La geometría de la ruta aún no determina cómo se transfiere la orientación del TCP desde la orientación inicial a la orientación objetivo. Esto se explica en el Interpolación de orientación para movimientos CP sección. Los movimientos CP siempre empiezan y terminan en el mismo configuración del robot. No es posible cambiar la configuración con movimientos CP porque el robot se movería por una posición singular. El movimiento a través de una posición singular puede conducir a velocidades de eje ilimitadas. Puedes usar Movimientos PTP de trayectoria invariante para cambiar entre configuraciones. " }, 
{ "title" : "Interpolación de orientación para movimientos CP ", 
"url" : "_sm_robotics_orientation_interpolation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Movimientos PC \/ Interpolación de orientación para movimientos CP ", 
"snippet" : "En el caso de movimientos de CP como MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , o MC_MoveCircularRelative , cualquier orientación de destino de la herramienta se puede especificar por medio de la posición de destino del movimiento. La consecuencia es que la orientación...", 
"body" : "En el caso de movimientos de CP como MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , o MC_MoveCircularRelative , cualquier orientación de destino de la herramienta se puede especificar por medio de la posición de destino del movimiento. La consecuencia es que la orientación de la herramienta se convierte en la orientación del objetivo durante el movimiento de la trayectoria con la punta de la herramienta desplazándose por la trayectoria. Para la interpolación de orientación, no hace ninguna diferencia en qué sistema de coordenadas se dio la orientación del objetivo, ya sea en coordenadas de eje (ACS) o coordenadas de máquina (MCS). La siguiente imagen muestra una interpolación lineal con la interpolación de orientación simultánea. La flecha roja indica la dirección de la herramienta en los puntos inicial y final. La línea roja discontinua indica cómo se posiciona la herramienta en algunas ubicaciones durante la interpolación. Los bloques de función mencionados anteriormente para los movimientos de trayectoria tienen la OrientationMode aporte. Esta entrada define cómo se pasa la orientación inicial a la orientación del objetivo. Interpolación de gran círculo ( SMC_Orientation_Mode.GreatCircle ) Ésta es una configuración predeterminada. Con esta configuración, la orientación inicial también se pasa a la orientación del objetivo en la distancia más corta. La distancia más corta significa que la herramienta se gira en la orientación del objetivo para minimizar el ángulo de recorrido de la rotación. Interpolación de orientación del eje ( SMC_Orientation_Mode.Axis ) Ejemplo 1: interpolación de gran círculo Considere un pórtico que tiene un eje C con un rango de valores de -360 ° a 360 °. La orientación inicial es C = 179 ° y la orientación del objetivo es C = -175 °. La interpolación del círculo máximo mueve el eje C del ángulo de Euler ZYZ (A, B, C) proporcionalmente a la distancia recorrida en la trayectoria desde 179 ° en la dirección positiva más allá de 180 ° hasta 185 °, que corresponde a -175 °. En este caso, recorre un ángulo total de 6 °. Ejemplo 2: interpolación de orientación de ejes Considere nuevamente el pórtico que tiene un eje C con un rango de valores de -180 ° a 180 °. La orientación inicial es C = 179 ° y la orientación del objetivo es C = -175 °. La interpolación del eje mueve el eje C del pórtico proporcionalmente a la distancia recorrida en la trayectoria desde 179 ° en la dirección negativa pasando de 0 ° a -175 °, recorriendo un ángulo total de 354 °. (Si se usó la interpolación de círculo máximo en este ejemplo, entonces se habría producido un error, porque se habría excedido el espacio de trabajo del eje C). Estos dos tipos de interpolación difieren en algunas características importantes. En la interpolación de círculo máximo, se puede predecir el cambio en la orientación de la herramienta. En la interpolación de ejes, es difícil predecir el cambio de orientación, porque los ejes de orientación pueden afectar la orientación de manera diferente según la posición. La interpolación de la orientación del eje comparte esta característica con los movimientos PTP. (Sin embargo, esto no significa que sea difícil predecir la ruta en el espacio para la interpolación de la orientación del eje. La ruta es la misma para ambos tipos de interpolación de orientación y el TCP siempre recorre el contorno definido exactamente). Con la interpolación de círculo máximo, las singularidades en la cinemática de orientación no se pueden recorrer. Esto es posible fácilmente con la interpolación de ejes. En la interpolación de círculo máximo pueden producirse violaciones de los límites de los ejes de orientación, como se menciona en el segundo ejemplo. Por lo tanto, al dar órdenes es necesario asegurarse de que no se violen los límites del eje al desplazarse hacia la orientación objetivo con la rotación más corta. Con la interpolación de ejes, es posible girar más de 360°. Si un eje de orientación tiene un área de trabajo de más de 360°, entonces se puede desplazar, por ejemplo, a la posición 540°, en lugar de a la posición 180°. Esto corresponde a la misma orientación de la herramienta. Con la interpolación de círculo máximo, esto no es posible. El giro más corto hacia la orientación objetivo siempre corresponde a un ángulo total de como máximo 180°. La interpolación de la orientación del eje requiere cinemática acoplada que consta de cinemática de posición y de herramienta. La parte de posición tiene que implementar la interfaz. ISMPositionKinematics_Offset2 . Si la cinemática no tiene ningún eje giratorio e implementan la interfaz ISMPositionKinematics , luego el modo de orientación seleccionado ( SMC_Orientation_Mode ) se ignora. Singularidades en la interpolación de orientación de ejes Con la interpolación de la orientación del eje, se puede realizar un movimiento de trayectoria a través de las singularidades de la cinemática de orientación, lo que puede facilitar significativamente la programación. Las singularidades de la cinemática de posición cambian para este propósito. En el caso de una interpolación circular grande, Scara3_Z tiene una singularidad si el punto de ala (A3) está ubicado en la línea definida por la primera parte del brazo (si el segundo ángulo de articulación es 0 °). Para la interpolación de la orientación del eje, las singularidades de la cinemática de posición cambian de modo que el TCP asume el papel que tiene el punto de brida (A3) de otra manera. Esta singularidad ocurre cuando el TCP (no el punto de la brida) se ubica en la línea definida por la primera parte del brazo. Al ordenar un movimiento con interpolación de orientación de eje, se comprueba si esta singularidad modificada se encuentra o no entre las posiciones inicial y objetivo del movimiento. Si es así, el movimiento no se acepta y se emite un error. Para los robots de brazo articulado de 6 ejes, la situación es comparable a Scara3_Z, pero son posibles dos singularidades. La primera ocurre cuando el TCP se encuentra en la línea que pasa por A2 y A3. El segundo ocurre cuando el TCP se encuentra en la línea que pasa por A1. El mando también comprueba aquí que no se transita ninguna singularidad. Puede suceder que la configuración de Scara3 (o el robot de brazo articulado de 6 ejes) cambie al viajar con interpolación de orientación de ejes. Sin embargo, al final del movimiento siempre se aplica la misma configuración que tenía el robot en el punto de partida. " }, 
{ "title" : "Ejes adicionales ", 
"url" : "_sm_additional_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Ejes adicionales ", 
"snippet" : "Los ejes adicionales son ejes que forman parte del grupo de ejes pero no forman parte de la cinemática. Se pueden mover de forma sincrónica con el movimiento coordinado de la cinemática. Los ejes adicionales y los ejes de la cinemática comienzan a moverse y alcanzan su posición objetivo al mismo tie...", 
"body" : "Los ejes adicionales son ejes que forman parte del grupo de ejes pero no forman parte de la cinemática. Se pueden mover de forma sincrónica con el movimiento coordinado de la cinemática. Los ejes adicionales y los ejes de la cinemática comienzan a moverse y alcanzan su posición objetivo al mismo tiempo. Los movimientos de los ejes adicionales se amortiguan y se combinan con movimientos coordinados. Lo mismo se aplica a los movimientos puramente adicionales del eje, sin ningún movimiento de la cinemática " }, 
{ "title" : "Diferencias en comparación con los movimientos de un solo eje ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062102818545", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Ejes adicionales \/ Diferencias en comparación con los movimientos de un solo eje ", 
"snippet" : "La principal diferencia en comparación con los movimientos de un solo eje que se controlan con bloques de funciones como MC_MoveAbsolute o MC_MoveRelative es la sincronización del movimiento. Si la sincronización no es importante, entonces podría tener sentido ordenar los ejes con bloques de funcion...", 
"body" : "La principal diferencia en comparación con los movimientos de un solo eje que se controlan con bloques de funciones como MC_MoveAbsolute o MC_MoveRelative es la sincronización del movimiento. Si la sincronización no es importante, entonces podría tener sentido ordenar los ejes con bloques de funciones de un solo eje, ya que así los ejes podrían moverse más rápido. Otra diferencia es que los ejes adicionales se administran junto con el grupo de ejes. Están habilitados con SMC_GroupPower y los errores se pueden restablecer junto con MC_GroupReset . Debe tenerse en cuenta que un error en un solo eje de un eje adicional provocará un error en el grupo de ejes " }, 
{ "title" : "Controlar movimientos de eje adicionales ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062103093337", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Ejes adicionales \/ Controlar movimientos de eje adicionales ", 
"snippet" : "Al ordenar movimientos de ejes adicionales, siempre puede elegir entre movimientos absolutos y relativos, independientemente de si el movimiento principal del grupo de ejes es absoluto o relativo. Por ejemplo, se puede ordenar un movimiento relativo adicional del eje de forma sincrónica con un MC_Mo...", 
"body" : "Al ordenar movimientos de ejes adicionales, siempre puede elegir entre movimientos absolutos y relativos, independientemente de si el movimiento principal del grupo de ejes es absoluto o relativo. Por ejemplo, se puede ordenar un movimiento relativo adicional del eje de forma sincrónica con un MC_MoveLinearAbsolute comando. Los movimientos adicionales del eje se ordenan mediante el AdditionalAxes entrada de los bloques de funciones de movimiento para el grupo de ejes. Por ejemplo, un movimiento PTP absoluto con un movimiento de eje relativo adicional se puede ordenar de la siguiente manera: Si solo se deben mover los ejes adicionales, entonces un movimiento coordinado de longitud 0 (por ejemplo, MC_MoveDirectRelative con distancia 0 ) se puede controlar junto con un movimiento de eje adicional. " }, 
{ "title" : "Notas ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062106608843", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Ejes adicionales \/ Notas ", 
"snippet" : "Los ejes de módulo también se admiten como ejes adicionales. Siempre se operan shortest modo para movimientos de eje adicionales absolutos. Para obtener más información, consulte lo siguiente: MC_DirectionMC_Direction El número máximo de ejes adicionales está limitado por el parámetro de biblioteca....", 
"body" : "Los ejes de módulo también se admiten como ejes adicionales. Siempre se operan shortest modo para movimientos de eje adicionales absolutos. Para obtener más información, consulte lo siguiente: MC_DirectionMC_Direction El número máximo de ejes adicionales está limitado por el parámetro de biblioteca. MAX_NUM_ADDITIONAL_AXES del SM3_CPKernelDefaults biblioteca. Este parámetro se puede cambiar en el administrador de la biblioteca. Para ver un ejemplo sobre cómo usar ejes adicionales, consulte lo siguiente: Uso de ejes adicionales en robótica" }, 
{ "title" : "Tolerancias para la precisión de la ruta ", 
"url" : "_sm_path_accuracy_tolerances.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Tolerancias para la precisión de la ruta ", 
"snippet" : "Se pueden establecer tolerancias para la precisión de la trayectoria para los grupos de ejes. En caso de un movimiento inesperado de un sistema de coordenadas dinámico, estas tolerancias permiten que un grupo de ejes alcance este sistema de coordenadas en lugar de detenerse por error. SMC_AXIS_GROUP...", 
"body" : "Se pueden establecer tolerancias para la precisión de la trayectoria para los grupos de ejes. En caso de un movimiento inesperado de un sistema de coordenadas dinámico, estas tolerancias permiten que un grupo de ejes alcance este sistema de coordenadas en lugar de detenerse por error. SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED , o SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED . " }, 
{ "title" : "Descripción general ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4560250800668834033944790208", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Tolerancias para la precisión de la ruta \/ Descripción general ", 
"snippet" : "¿Por qué son necesarias las tolerancias para la precisión de la trayectoria? Idealmente, el grupo de ejes debería seguir la ruta exactamente. Sin embargo, si se utiliza un sistema de coordenadas dinámico (por ejemplo, un objeto en una correa o mesa giratoria, o un sistema de coordenadas especificado...", 
"body" : "¿Por qué son necesarias las tolerancias para la precisión de la trayectoria? Idealmente, el grupo de ejes debería seguir la ruta exactamente. Sin embargo, si se utiliza un sistema de coordenadas dinámico (por ejemplo, un objeto en una correa o mesa giratoria, o un sistema de coordenadas especificado por otro grupo de ejes), en algunos casos no es posible seguir la ruta. Ejemplo: un robot debe colocar una pieza en una cinta transportadora. La cinta se mueve a una velocidad constante, pero justo antes de que el robot llegue a la posición para colocar la pieza, la cinta acelera inesperadamente. En esta situación ya se ha calculado la trayectoria de colocación de la pieza, pero asumiendo que la cinta continúa moviéndose a velocidad constante. Por lo tanto, el movimiento restante ahora puede provocar una violación de la aceleración máxima de uno de los ejes del robot. En situaciones como esta, las tolerancias son importantes. Permiten que el grupo de ejes se desvíe de la trayectoria dentro de los límites especificados y vuelva a alcanzar el sistema de coordenadas. La precisión de la ruta está controlada por un filtro. El filtro recibe la trayectoria planificada ( q_ref ) y las últimas posiciones objetivo calculadas ( q_set ) como entrada. La salida del filtro son las posiciones de destino ( q_set ), que se transfieren a los accionamientos. Si q_ref viola uno de los límites del eje, entonces el filtro abandona la ruta y sigue la trayectoria planificada lo más cerca posible sin violar un límite del eje. Mientras el desfase entre q_set y q_ref está dentro de las tolerancias, no se genera ningún error. Las tolerancias para la precisión de la trayectoria constan de varios valores: Retraso máximo del TCP en unidades técnicas (valor predeterminado: 1 u ) Error máximo de orientación del TCP en grados angulares (valor predeterminado: 1 deg ) Retraso máximo permitido de cada eje en unidades técnicas del eje (valor predeterminado: infinito) " }, 
{ "title" : "Efecto sobre los bloques de funciones administrativas ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4579672191731234033944887183", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Tolerancias para la precisión de la ruta \/ Efecto sobre los bloques de funciones administrativas ", 
"snippet" : "Los valores de posición, velocidad, aceleración y sacudida que devuelve el SMC_GroupReadSetPosition , SMC_GroupReadSetVelocity , SMC_GroupReadSetAcceleration , y SMC_GroupReadSetJerk Los bloques de funciones se calculan en función de la trayectoria planificada ( q_ref ). Por tanto, no contienen el a...", 
"body" : "Los valores de posición, velocidad, aceleración y sacudida que devuelve el SMC_GroupReadSetPosition , SMC_GroupReadSetVelocity , SMC_GroupReadSetAcceleration , y SMC_GroupReadSetJerk Los bloques de funciones se calculan en función de la trayectoria planificada ( q_ref ). Por tanto, no contienen el aporte del filtro. Por otro lado, los valores reales de posición, velocidad y sacudida, que devuelve el MC_GroupReadActualPosition , MC_GroupReadActualVelocity , y MC_GroupReadActualAcceleration Bloques de funciones: se calculan en función de la posición real de los accionamientos del grupo de ejes. Por tanto, también contienen el aporte del filtro. La dinámica de la ruta que son devueltas por SMC_GroupReadPathDynamics con Source = MC_SOURCE.SET se basa en la trayectoria planificada ( q_ref ) y por lo tanto no se ve influenciado por el filtro. (Para otros valores del Source entrada, se incluye el aporte del filtro) Los desencadenantes siempre se refieren a la trayectoria planificada ( q_ref ). El tiempo que es devuelto por MC_GroupReadTrigger es el momento en que la trayectoria planificada llega al gatillo. Cuando el filtro está activo ( q_ref<>q_set ), el grupo de ejes no suele alcanzar exactamente la posición y\/o el tiempo del disparador. Nota: Un movimiento informa Done sólo cuando tanto la trayectoria planificada ( q_ref ) ha llegado al final del movimiento y el filtro no está (o ya no) activo (es decir, se ha eliminado un posible retraso). Luego la posición establecida ( q_set ) corresponde a la posición objetivo del movimiento. " }, 
{ "title" : "Ajustar las tolerancias y controlar la desviación de la trayectoria ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4575205545955234033945121691", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Tolerancias para la precisión de la ruta \/ Ajustar las tolerancias y controlar la desviación de la trayectoria ", 
"snippet" : "Las tolerancias se pueden establecer usando el SMC_GroupSetPathTolerance bloque de funciones. El estado del filtro y el desfase actual entre la trayectoria planificada. q_ref y los valores establecidos q_set del grupo de ejes se puede controlar con el InSync , PositionLag , y OrientationLag salidas ...", 
"body" : "Las tolerancias se pueden establecer usando el SMC_GroupSetPathTolerance bloque de funciones. El estado del filtro y el desfase actual entre la trayectoria planificada. q_ref y los valores establecidos q_set del grupo de ejes se puede controlar con el InSync , PositionLag , y OrientationLag salidas de MC_GroupReadStatus . InSync = TRUE significa que q_ref = q_set y que el filtro no está activo. InSync = FALSE significa que q_ref<>q_set y que el filtro esté activo. " }, 
{ "title" : "Amortiguación y combinación de movimientos ", 
"url" : "_sm_robotics_blending.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Amortiguación y combinación de movimientos ", 
"snippet" : "Los comandos de movimiento se pueden almacenar en búfer con CODESYS SoftMotion . Para cada movimiento ordenado, se puede especificar cómo se amortigua el movimiento y cómo se debe realizar la combinación del movimiento anterior con el nuevo movimiento. La ruta ordenada se ajusta redondeando las esqu...", 
"body" : "Los comandos de movimiento se pueden almacenar en búfer con CODESYS SoftMotion . Para cada movimiento ordenado, se puede especificar cómo se amortigua el movimiento y cómo se debe realizar la combinación del movimiento anterior con el nuevo movimiento. La ruta ordenada se ajusta redondeando las esquinas para poder recorrerla Si un movimiento está amortiguado o no y cómo se realiza, se puede configurar mediante el BufferMode entrada del bloque de movimiento (por ejemplo, MC_MoveDirectAbsolute o MC_MoveCircularRelative ). Para obtener más información, consulte lo siguiente: MC_Buffer_Mode . El TransitionMode y TransitionParameter las entradas determinan cómo se redondean las esquinas. Para obtener más información, consulte lo siguiente: MC_TRANSITION_MODE . Para obtener más información sobre los movimientos, consulte lo siguiente: Bloques de funciones para movimientos En los modos de fusión, el TransitionMode no debe ser igual a TMNone . La combinación entre dos movimientos comienza como muy pronto a la mitad del primer movimiento y termina como muy tarde a la mitad del segundo movimiento. Si el primer movimiento ya se ha planificado demasiado, es posible que ya no sea posible mezclar con los parámetros ajustados. Entonces el área de mezclado se reduce o ya no es posible mezclar. Para garantizar una mezcla exitosa, ambos movimientos deben realizarse en el mismo ciclo. " }, 
{ "title" : "Dinámica de rutas al mezclar ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-idm43523137701146", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Amortiguación y combinación de movimientos \/ Dinámica de rutas al mezclar ", 
"snippet" : "Si la combinación se realiza entre movimientos de CP (entre segmentos lineales y circulares), debe tenerse en cuenta que la aceleración máxima de la trayectoria y la máxima sacudida de la trayectoria pueden superarse durante la combinación. Cuanto más corto sea el rango de fusión, más prominente ser...", 
"body" : "Si la combinación se realiza entre movimientos de CP (entre segmentos lineales y circulares), debe tenerse en cuenta que la aceleración máxima de la trayectoria y la máxima sacudida de la trayectoria pueden superarse durante la combinación. Cuanto más corto sea el rango de fusión, más prominente será este efecto. Sin embargo, los límites de los ejes (la aceleración máxima del eje y la máxima sacudida del eje) siempre se mantienen Por lo tanto, si la aceleración máxima de la trayectoria es baja y la aceleración máxima del eje es alta, pueden producirse aceleraciones demasiado altas durante la combinación. Esto se puede contrarrestar mediante el AccFactor entrada de los bloques de movimiento, por ejemplo, reduciendo la aceleración máxima del eje para un movimiento. " }, 
{ "title" : "Características de TMStartVelocity ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231378653745", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Amortiguación y combinación de movimientos \/ Características de TMStartVelocity ", 
"snippet" : "El cálculo de los puntos de mezcla se basa en una curva de velocidad idealizada, que puede desviarse de la curva de velocidad real. En este momento, se simula una rampa de desaceleración en la trayectoria original hacia el punto de fusión y una rampa de aceleración y alejándose del punto de fusión. ...", 
"body" : "El cálculo de los puntos de mezcla se basa en una curva de velocidad idealizada, que puede desviarse de la curva de velocidad real. En este momento, se simula una rampa de desaceleración en la trayectoria original hacia el punto de fusión y una rampa de aceleración y alejándose del punto de fusión. Como velocidad objetivo se utiliza el mínimo de la velocidad de trayectoria programada y la velocidad de trayectoria máxima estimada resultante de los límites del eje Además, al combinar líneas rectas, se tiene en cuenta el ángulo entre ellas. El radio de curvatura mínimo para el elemento de fusión es el resultado de la velocidad de trayectoria deseada y de los límites dinámicos estimados. Los puntos A' y B' se derivan sucesivamente de este radio y del ángulo entre las líneas rectas Si los movimientos se ralentizan durante el proceso de mezcla a pesar de tener un factor establecido de 1, entonces aumentar el factor puede ayudar. " }, 
{ "title" : "Ejemplo ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231380207819", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Amortiguación y combinación de movimientos \/ Ejemplo ", 
"snippet" : "En una pequeña aplicación de ejemplo, se supone que se debe recoger una pieza de trabajo. El robot debe moverse primero por encima de la pieza de trabajo y luego hacia abajo para recogerla. Para llegar a la pieza lo más rápido posible, el recorrido entre los dos movimientos no debe detenerse, sino m...", 
"body" : "En una pequeña aplicación de ejemplo, se supone que se debe recoger una pieza de trabajo. El robot debe moverse primero por encima de la pieza de trabajo y luego hacia abajo para recogerla. Para llegar a la pieza lo más rápido posible, el recorrido entre los dos movimientos no debe detenerse, sino mezclarse. La fusión en el segundo movimiento debe comenzar diez unidades antes de llegar al final del primer movimiento Para cumplir con los requisitos, se deben ordenar dos movimientos. El primer movimiento ( moveAbove ) sobre la pieza y el segundo movimiento ( moveDown ) hacia abajo, hacia la pieza de trabajo. Para el segundo movimiento, se debe definir cómo se debe amortiguar y mezclar el movimiento Como se muestra en la siguiente imagen, BlendingHigh está seleccionado para BufferMode . Esto define que el movimiento debe amortiguarse después del primer movimiento y luego mezclarse. Además, para el TransitionMode , TMCornerDistance se define con una distancia de 10 unidades para combinar suavemente el primer movimiento con el segundo movimiento. Para configurar las dos entradas TransitionMode y TransitionParameter apropiadamente, el SMC_CornerDistance se usa un bloque de funciones. " }, 
{ "title" : "Esperando entre movimientos ", 
"url" : "_sm_robotics_wait.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Esperando entre movimientos ", 
"snippet" : "SoftMotion Robotics Proporciona la capacidad de esperar un tiempo específico entre dos movimientos. Esto puede ser necesario, por ejemplo, cuando un robot debe agarrar una pieza de trabajo en la posición objetivo de un movimiento antes de iniciar el siguiente movimiento. De manera similar a los movi...", 
"body" : "SoftMotion Robotics Proporciona la capacidad de esperar un tiempo específico entre dos movimientos. Esto puede ser necesario, por ejemplo, cuando un robot debe agarrar una pieza de trabajo en la posición objetivo de un movimiento antes de iniciar el siguiente movimiento. De manera similar a los movimientos, el tiempo de espera se controla mediante el SMC_GroupWait bloque de funciones. Para obtener más información sobre este bloque de funciones, consulte: SMC_GroupWait . " }, 
{ "title" : "Detenerse en el camino con MC_GroupHalt o MC_GroupStop ", 
"url" : "_sm_robotics_halt_stop.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Detenerse en el camino con MC_GroupHalt o MC_GroupStop ", 
"snippet" : "El MC_GroupHalt y MC_GroupStop Los bloques de funciones permiten detenerse en el camino, teniendo en cuenta los límites de desaceleración y tirones configurables. La parada comienza inmediatamente. Los límites de desaceleración y tirones para detenerse pueden diferir de los del movimiento activo y p...", 
"body" : "El MC_GroupHalt y MC_GroupStop Los bloques de funciones permiten detenerse en el camino, teniendo en cuenta los límites de desaceleración y tirones configurables. La parada comienza inmediatamente. Los límites de desaceleración y tirones para detenerse pueden diferir de los del movimiento activo y pueden ser tanto mayores como menores. Se mantienen mientras no se abandone el camino. En medio de la carretera, por ejemplo, es posible realizar una parada suave con una desaceleración baja. Sin embargo, al final del camino, la desaceleración es al menos lo suficientemente fuerte como para evitar que se avance más allá del final. Diferencia entre MC_GroupHalt y MC_GroupStop La principal diferencia entre MC_GroupHalt y MC_GroupStop ¿Es eso un MC_GroupStop no se puede abortar y que los movimientos posteriores se aceptan sólo después de Execute La entrada se ha restablecido. Un MC_GroupStop impide que el grupo de ejes se mueva. Diferenciación de MC_GroupInterrupt En contraste con MC_GroupHalt y MC_GroupStop , un MC_GroupInterrupt comienza con un breve retraso y no tiene límites de desaceleración ni tirones configurables. En cambio, se utilizan los límites del movimiento activo. después de un MC_GroupInterrupt , el movimiento interrumpido se puede reanudar con MC_GroupContinue . Con la ayuda de SMC_GroupSaveContinueData , esto también es posible con MC_GroupHalt y MC_GroupStop . Para más información, ver: Interrupción y continuación de movimientos. Comportamiento con movimientos en sistemas de coordenadas en movimiento. Para movimientos en sistemas de coordenadas móviles (por ejemplo, cuando el robot se mueve con respecto a una cinta transportadora), un MC_GroupHalt o MC_GroupStop resulta en una parada absoluta. Por lo tanto, no se detiene con respecto al sistema de coordenadas en movimiento. El grupo de ejes permanece en la trayectoria que habría recorrido en el sistema de coordenadas de la máquina (MCS) si no MC_GroupHalt o MC_GroupStop había sido ordenado. " }, 
{ "title" : "Planificación del movimiento ", 
"url" : "_sm_robotics_factor_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Planificación del movimiento ", 
"snippet" : "Cuando se ordena un movimiento, por ejemplo con MC_MoveLinearAbsolute , la velocidad resultante del robot depende de los siguientes factores: La velocidad, aceleración y sacudida máximas configuradas para cada eje del grupo de ejes. (configurado en la configuración de ejes). Los límites superiores d...", 
"body" : "Cuando se ordena un movimiento, por ejemplo con MC_MoveLinearAbsolute , la velocidad resultante del robot depende de los siguientes factores: La velocidad, aceleración y sacudida máximas configuradas para cada eje del grupo de ejes. (configurado en la configuración de ejes). Los límites superiores definen para cada eje la velocidad a la que se le permite moverse. Los demás límites que se explican a continuación sólo pueden reducir los límites efectivos. No pueden aumentarlos más allá de estos límites. La velocidad, aceleración y sacudida máximas que se proporcionan como entradas al bloque de funciones de movimiento. Estos límites superiores definen qué tan rápido puede moverse el TCP a lo largo del camino. Se aplican además de los límites de los ejes individuales. La anulación actual (ver MC_GroupSetOverride ) y los límites auxiliares para un grupo de ejes Para obtener una descripción de cómo se combinan todos estos límites para calcular la ruta efectiva y los límites del eje, consulte la ayuda para SMC_GroupSetAncillaryAxisLimits , SMC_GroupSetAncillaryPathLimits , y SMC_GroupSetAxisLimitFactors . La ruta programada del robot. Por ejemplo, cuando la combinación de movimientos da como resultado un radio de curvatura muy pequeño, el robot tiene que moverse lentamente para no exceder los límites del eje. Juntos, estos factores determinan la velocidad máxima efectiva en la trayectoria. Sin embargo, hay un factor más que puede limitar la velocidad alcanzable: el rendimiento del PLC. Si el rendimiento no es suficiente para planificar el movimiento, entonces el robot se mueve a una velocidad más lenta. Si, por motivos de rendimiento, el algoritmo de planificación no puede verificar que es seguro acelerar, se moverá a una velocidad más lenta. Para más información, ver: Actuación" }, 
{ "title" : "Interrupción y continuación de movimientos ", 
"url" : "_sm_robotics_stop_continue_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Interrupción y continuación de movimientos ", 
"snippet" : "Mientras un grupo de ejes está en movimiento, el movimiento puede detenerse. Esto puede ser una parada intencional ( MC_GroupHalt , MC_GroupStop ), o una pausa en el camino ( MC_GroupInterrupt ), o una interrupción debido a un error. En todos los casos, CODESYS SoftMotion proporciona bloques de func...", 
"body" : "Mientras un grupo de ejes está en movimiento, el movimiento puede detenerse. Esto puede ser una parada intencional ( MC_GroupHalt , MC_GroupStop ), o una pausa en el camino ( MC_GroupInterrupt ), o una interrupción debido a un error. En todos los casos, CODESYS SoftMotion proporciona bloques de funciones para mover el grupo de ejes de regreso a la ruta planificada y continuarlo. Detener un movimiento debido a un error Si un movimiento se detiene debido a un error, los ejes individuales de un grupo de ejes se detienen individualmente y cambian al estado de error. En el proceso, el TCP abandona la ruta planificada. Ahora puede reconocer el error, restablecer el grupo de ejes y moverse a la posición donde se detectó el error. Posteriormente, puede indicar al grupo de ejes que continúe con los movimientos planificados previamente. usas el SMC_GroupEnableResumeAfterError bloque de función para permitir que la función reanude los movimientos programados después de un error. El bloque de función debe llamarse cíclicamente en la tarea de ciclo de bus. Solo se puede llamar una instancia de este bloque de funciones por grupo de ejes. Si el grupo de ejes detecta un error y cambia al estado Errorstop , luego guarda los movimientos ya aceptados y la información de estado necesaria en una variable de tipo SMC_AXIS_GROUP_CONTINUE_DATA . Entonces esta variable contiene los \"datos de continuación\" y se pasa como una entrada de SMC_GroupEnableResumeAfterError . Esto le permite reanudar los movimientos más tarde usando MC_GroupContinuar . Si los errores son causados por los movimientos ordenados (por ejemplo, violaciones del espacio de trabajo o un radio de arco no válido), no se pueden resolver de esta manera. Estos errores volverán a ocurrir después de que el movimiento continúe. El mecanismo está diseñado más para errores de un solo eje y otros eventos externos que obligan al grupo de ejes a detenerse por error. MC_GroupContinue requiere que el grupo de ejes esté en una posición específica al continuar el movimiento. En caso de reanudar después de un error, esta posición es la posición actual en el momento en que se detectó el error. Puedes usar el SMC_GroupGetContinuePosition bloque de funciones para obtener esta posición. Si un error de grupo de ejes no permite la continuación del movimiento (como un error interno al escribir los datos de continuación), entonces MC_GroupContinue y SMC_GroupGetContinuePosition devolver el nuevo ID de error SMC_AXIS_GROUP_CONTINUE_DATA_NOT_WRITTEN . Si una MC_GroupStop está activo cuando ocurre el error, entonces MC_GroupStop también se reactiva cuando el movimiento continúa. El grupo de ejes ya se ha detenido y el MC_GroupStop ha borrado todos los movimientos pendientes para que no se produzca ningún movimiento. Cuando se produce un error de grupo de ejes, la instancia del bloque de funciones del movimiento activo emite el error (salidas Active y Busy cambiar a FALSE y salida Error cambia a TRUE ). Las instancias de bloques de funciones de movimientos en búfer o combinados, que aún no se han activado, también emiten un error. Después de reiniciar, todas estas instancias de bloques de funciones se restablecen a Busy \/ Active y sus salidas se restablecen a Error \/ CommandAborted . " }, 
{ "title" : "Detener un movimiento haciendo una pausa ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_74b10b31cbbdb856c0a8646354735c5f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Interrupción y continuación de movimientos \/ Detener un movimiento haciendo una pausa ", 
"snippet" : "Puedes usar el MC_GroupInterrupt y MC_GroupInterruptAt bloques de función para interrumpir la ejecución de los movimientos comandados. Para MC_GroupInterrupt , se ejecuta una parada inmediata. Para MC_GroupInterruptAt , se ejecuta una parada en una posición específica. Entonces el movimiento se pued...", 
"body" : "Puedes usar el MC_GroupInterrupt y MC_GroupInterruptAt bloques de función para interrumpir la ejecución de los movimientos comandados. Para MC_GroupInterrupt , se ejecuta una parada inmediata. Para MC_GroupInterruptAt , se ejecuta una parada en una posición específica. Entonces el movimiento se puede continuar más tarde con MC_GroupContinuar . El bloque de funciones MC_GroupInterruptAt proporciona la entrada SMC_GroupInterruptPositionMvtRel . Esto especifica una posición de interrupción relativa a un movimiento. El movimiento es referenciado por su SMC_Movement_Id . La posición dentro del movimiento está definida por un valor (real) entre 0 y 1, donde 0 es el comienzo del movimiento y 1 es el final. Una posición entre los puntos B y A se interpreta exactamente como si no hubiera fusión. Una posición entre P comienzo y B o entre A y P dest se proyecta en la ruta de fusión. Manejo de errores para MC_GroupInterruptAt Cuando se desconoce el ID de movimiento especificado, el bloque de funciones devuelve un error. El movimiento de carrera no se interrumpe. Si el estado dinámico actual del grupo de ejes no permite alcanzar la parada antes de la posición de interrupción especificada, entonces SMC_GroupInterruptAt se comporta exactamente como MC_GroupInterrupt : la interrupción se ejecuta inmediatamente y el grupo de ejes se detiene en algún lugar detrás de la posición de interrupción ordenada. Todos los demás errores se manejan exactamente como para MC_GroupInterrupt Limitaciones de MC_GroupInterruptAt Una interrupción en una posición específica se puede cancelar con otro movimiento siempre que aún no haya comenzado el proceso de parada en la posición de interrupción. Solo se puede ordenar una interrupción en una posición específica al mismo tiempo. Si se ha ordenado una interrupción, debe completarse o cancelarse para que se pueda aceptar otra interrupción. Cuando ejecutas MC_GroupInterrupt o MC_GroupInterruptAt , una parada invariante de ruta se ejecuta al principio, similar a una MC_GroupHalt . Luego, el estado del grupo de ejes (\"continuar datos\") se almacena en una variable transferida por el usuario (escriba SMC_AXIS_GROUP_CONTINUE_DATA ). Ahora el grupo de ejes está en el estado GroupStandby y se puede utilizar normalmente. Un ejemplo típico sería que el grupo de ejes se mueva. Puedes venir conmigo más tarde. MC_GroupContinue reanudar la ejecución interrumpida. Para hacer esto, transfiera los \"Continuar datos\" guardados. Para que esto funcione sin error, la posición del grupo de ejes debe coincidir con la posición que tendrá después de ejecutar MC_GroupInterrupt tendría. (Consulte SMC_GroupGetContinuePosition .) Cuando se ha interrumpido un movimiento de seguimiento (es decir, un movimiento que se ordenó en relación con un sistema de coordenadas dinámico), MC_GroupInterrupt no se detiene absolutamente (como MC_GroupHalt ), pero relativamente al sistema de coordenadas dinámicas. Por ejemplo, si una pieza de trabajo se rastrea en una mesa giratoria, MC_GroupInterrupt se detiene con respecto a la pieza de trabajo. El grupo de ejes continúa siguiendo la pieza de trabajo. Los datos continuos deben actualizarse con SMC_GroupUpdateContinueData si la cinemática tiene ejes rotativos con múltiples periodos. Posteriormente, se puede continuar el movimiento con MC_GroupContinue . La variable de tipo SMC_AXIS_GROUP_CONTINUE_DATA no debe almacenarse de forma persistente ni modificarse durante un cambio en línea. Usando el bloque de funciones SMC_GroupWait , puede esperar en la ruta entre dos movimientos durante un tiempo programable. " }, 
{ "title" : "Parada de movimiento vía MC_GroupHalt o MC_GroupStop ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_28e8e9a71ed1fa93c0a8646375852228", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Interrupción y continuación de movimientos \/ Parada de movimiento vía MC_GroupHalt o MC_GroupStop ", 
"snippet" : "Después de una parada de movimiento provocada por MC_GroupHalt o MC_GroupStop , el movimiento del grupo de ejes se puede reanudar de la siguiente manera sin pérdida de información: Llamar al bloque de funciones SMC_GroupSaveContinueData antes de llamar MC_GroupHalt o MC_GroupStop . Esta POU guarda e...", 
"body" : "Después de una parada de movimiento provocada por MC_GroupHalt o MC_GroupStop , el movimiento del grupo de ejes se puede reanudar de la siguiente manera sin pérdida de información: Llamar al bloque de funciones SMC_GroupSaveContinueData antes de llamar MC_GroupHalt o MC_GroupStop . Esta POU guarda el estado actual, la posición actual y todos los movimientos ordenados en el momento en que se llamó al comando de parada o parada. Esto permite que el movimiento continúe más tarde desde exactamente esta posición. Nota: Esta NO es la posición que tenía el grupo de ejes después de alcanzar la posición de parada. Comportamiento antes de la versión 4.12.0.0: El SMC_GroupSaveContinueData el bloque de función tiene que ser llamado en el mismo ciclo donde MC_GroupHalt o MC_GroupStop se llama. En este momento, debe asegurarse de que SMC_GroupSaveContinueData se llama antes MC_GroupHalt o MC_GroupStop . De lo contrario, los movimientos abortados serán eliminados de la cola. Comportamiento a partir de la versión 4.12.0.0: El SMC_GroupSaveContinueData El bloque de función se puede llamar en cualquier momento hasta el primer movimiento después de llamar MC_GroupHalt o MC_GroupStop . La posición de continuación es la posición actual del grupo de ejes en el momento de la primera llamada del bloque de función. La ruta guardada consta de todos los movimientos que han sido aceptados antes del comando de parada\/parada. Para poder continuar la ruta en la posición donde el grupo de ejes se detuvo debido a MC_GroupHalt o MC_GroupStop , SMC_GroupSaveContinueData debe llamarse en el ciclo donde MC_GroupHalt o MC_GroupStop establece el Done señal. Solo una instancia de SMC_GroupSaveContinueData se puede llamar por grupo de ejes. Guardar el estado actual antes del comando de parada \/ parada puede llevar varios ciclos, pero se garantiza que la información de estado en el primer ciclo se guardará antes de cualquier movimiento interrumpido. SMC_GroupSaveContinueData se puede llamar en cualquier momento para guardar el estado actual, no solo en relación con la llamada MC_GroupHalt o MC_GroupStop . " }, 
{ "title" : "Interacción con movimientos de un solo eje ", 
"url" : "_sm_additional_axes_single_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Interacción con movimientos de un solo eje ", 
"snippet" : "Cada eje de un grupo de ejes (incluidos los ejes adicionales) también se puede mover con movimientos de un solo eje. Esto no requiere eliminar el eje del grupo de ejes. Se utilizan las siguientes reglas: Si el grupo de ejes está en GroupStandby estado cuando se ordena un movimiento de un solo eje en...", 
"body" : "Cada eje de un grupo de ejes (incluidos los ejes adicionales) también se puede mover con movimientos de un solo eje. Esto no requiere eliminar el eje del grupo de ejes. Se utilizan las siguientes reglas: Si el grupo de ejes está en GroupStandby estado cuando se ordena un movimiento de un solo eje en uno de sus ejes, el grupo de ejes permanece en este estado. Para obtener más información, consulte lo siguiente: Estados del grupo del ejeSi el grupo de ejes está en GroupMoving estado cuando se ordena un movimiento de un solo eje en uno de sus ejes, entonces el grupo de ejes cambia al GroupError estado. ¿El error? SMC_AXIS_GROUP_INTERRUPTED_BY_SINGLE_AXIS se notifica y todos los demás ejes se detienen. Si se ordena un movimiento en el grupo de ejes mientras un movimiento de un solo eje está activo en al menos uno de sus ejes, el grupo de ejes pasa al GroupError estado. " }, 
{ "title" : "Sincronización con un sistema de coordenadas en movimiento ", 
"url" : "_sm_robotics_dynamic_tracking.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Sincronización con un sistema de coordenadas en movimiento ", 
"snippet" : "La función de seguimiento integrada permite la programación de movimientos relativos a un sistema de coordenadas en movimiento. Un caso de uso típico es recoger un producto de una cinta transportadora y colocarlo en una cinta transportadora diferente. Después de definir un sistema de coordenadas din...", 
"body" : "La función de seguimiento integrada permite la programación de movimientos relativos a un sistema de coordenadas en movimiento. Un caso de uso típico es recoger un producto de una cinta transportadora y colocarlo en una cinta transportadora diferente. Después de definir un sistema de coordenadas dinámico para cada banda, el usuario puede simplemente proporcionar posiciones de destino para los movimientos que son relativos a este sistema de coordenadas. CODESYS SoftMotion se encarga de superponer el movimiento comandado del grupo de ejes y el movimiento de la correa. Un movimiento de seguimiento típico consta de tres fases: Seguimiento de entrada: pasar de otro sistema de coordenadas al sistema de coordenadas dinámicas. Una vez alcanzada la posición de destino, el grupo de ejes seguirá el movimiento del sistema de coordenadas dinámicas. Movimiento de seguimiento: Moverse a una posición diferente dentro del mismo sistema de coordenadas dinámicas. Se superpondrán el movimiento comandado y el movimiento del sistema de coordenadas dinámicas. Seguimiento: Pasar del sistema de coordenadas dinámicas a un sistema de coordenadas diferente. Una vez alcanzada la posición de destino, el movimiento del grupo de ejes ya no se verá afectado por el movimiento del sistema de coordenadas dinámicas. " }, 
{ "title" : "Definición de un sistema de coordenadas dinámico ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4599737357387233382157942652", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Sincronización con un sistema de coordenadas en movimiento \/ Definición de un sistema de coordenadas dinámico ", 
"snippet" : "El primer paso para implementar una aplicación de seguimiento dinámico es definir un sistema de coordenadas dinámico. CODESYS SoftMotion proporciona cuatro bloques de funciones para definir sistemas de coordenadas dinámicas: MC_TrackConveyorBelt : un bloque de funciones fácil de usar para el caso de...", 
"body" : "El primer paso para implementar una aplicación de seguimiento dinámico es definir un sistema de coordenadas dinámico. CODESYS SoftMotion proporciona cuatro bloques de funciones para definir sistemas de coordenadas dinámicas: MC_TrackConveyorBelt : un bloque de funciones fácil de usar para el caso de uso común de seguimiento de una cinta transportadora. Se proporciona una referencia al cinturón real a través del ConveyorBelt input, que espera un eje SoftMotion de tipo AXIS_REF_SM3 . MC_TrackRotaryTable : un bloque de funciones fácil de usar para el caso de uso común de seguimiento de una mesa giratoria. Se proporciona una referencia a la mesa giratoria real a través del RotaryTable input, que espera un eje SoftMotion de tipo AXIS_REF_SM3 . MC_SetDynCoordTransform : El bloque de funciones funciona de forma similar a MC_TrackConveyorBelt y MC_TrackRotaryTable , pero, en lugar de estar controlado por un solo eje, está controlado por un grupo de ejes completo. Esto permite implementar un sistema de coordenadas dinámico con hasta seis grados de libertad. SMC_SetDynCoordTransformEx : El bloque de funciones permite implementar un sistema de coordenadas dinámico completamente personalizado. Cada uno de los cuatro bloques de funciones tiene un CoordSystem entrada que esencialmente permite dar un nombre al sistema de coordenadas, ya sea PCS_1 o PCS_2 . Al ordenar un movimiento, el sistema de coordenadas se referencia con este nombre. " }, 
{ "title" : "Ordenar un movimiento a una posición en un sistema de coordenadas dinámico ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4620464078688033382158385681", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Sincronización con un sistema de coordenadas en movimiento \/ Ordenar un movimiento a una posición en un sistema de coordenadas dinámico ", 
"snippet" : "Después de haber definido un sistema de coordenadas dinámico, es fácil comandar un movimiento a una posición en este sistema de coordenadas. Cada bloque de función de movimiento, por ejemplo MC_MoveLinearAbsolute , tiene un CoordSystem aporte. Esta entrada debe configurarse con el nombre ( PCS_1 o P...", 
"body" : "Después de haber definido un sistema de coordenadas dinámico, es fácil comandar un movimiento a una posición en este sistema de coordenadas. Cada bloque de función de movimiento, por ejemplo MC_MoveLinearAbsolute , tiene un CoordSystem aporte. Esta entrada debe configurarse con el nombre ( PCS_1 o PCS_2 ) dado al sistema de coordenadas dinámicas. los Position la entrada se puede establecer en la posición deseada en relación con el origen del sistema de coordenadas dinámicas. La ejecución del bloque de función de movimiento conducirá a un movimiento a la posición dentro del sistema de coordenadas en movimiento. Una vez que se ha alcanzado la posición de destino, el grupo de ejes seguirá el sistema de coordenadas dinámicas mientras permanece en esta posición relativa. " }, 
{ "title" : "La salida \"InUse\" de los bloques de funciones del sistema de coordenadas dinámicas ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4663886345662433382158689616", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Sincronización con un sistema de coordenadas en movimiento \/ La salida \"InUse\" de los bloques de funciones del sistema de coordenadas dinámicas ", 
"snippet" : "Cada bloque de función del sistema de coordenadas dinámicas ( MC_TrackConveyorBelt , MC_TrackRotaryTable , MC_SetDynCoordTransform , y SMC_SetDynCoordTransformEx ) tiene un InUse producción. No se permite reiniciar un bloque de funciones mientras el sistema de coordenadas todavía está en uso y dará ...", 
"body" : "Cada bloque de función del sistema de coordenadas dinámicas ( MC_TrackConveyorBelt , MC_TrackRotaryTable , MC_SetDynCoordTransform , y SMC_SetDynCoordTransformEx ) tiene un InUse producción. No se permite reiniciar un bloque de funciones mientras el sistema de coordenadas todavía está en uso y dará como resultado el error SMC_AXIS_GROUP_PCS_STILL_IN_USE . Se utilizará un sistema de coordenadas dinámico tan pronto como se ordene un movimiento a una posición en el sistema de coordenadas. Permanecerá en uso hasta que se alcance una posición de destino en un sistema de coordenadas diferente. " }, 
{ "title" : "Límites de ejes para movimientos de seguimiento ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4557758355867233382158929251", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Sincronización con un sistema de coordenadas en movimiento \/ Límites de ejes para movimientos de seguimiento ", 
"snippet" : "Los límites de los ejes tienen que tener en cuenta tanto el movimiento del sistema de coordenadas como el movimiento ordenado en relación con el sistema de coordenadas. Si se requiere una dinámica de eje alta para seguir el sistema de coordenadas, el movimiento relativo al sistema de coordenadas pue...", 
"body" : "Los límites de los ejes tienen que tener en cuenta tanto el movimiento del sistema de coordenadas como el movimiento ordenado en relación con el sistema de coordenadas. Si se requiere una dinámica de eje alta para seguir el sistema de coordenadas, el movimiento relativo al sistema de coordenadas puede ser lento o no ser posible en absoluto. Si el grupo de ejes está cerca de una singularidad de la cinemática, esto puede suceder incluso con un sistema de coordenadas de movimiento relativamente lento. Para más información, ver: Pestaña: General" }, 
{ "title" : "Dinámica de trayectoria de los movimientos de CP durante el seguimiento ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm466388653271043338215917861", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Sincronización con un sistema de coordenadas en movimiento \/ Dinámica de trayectoria de los movimientos de CP durante el seguimiento ", 
"snippet" : "Se debe prestar especial atención a la dinámica de la trayectoria de los movimientos del PC. Esto incluye el Velocity , Acceleration , Deceleration , y Jerk entradas de MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , y MC_MoveCircularRelative . Si la posición inicial y de d...", 
"body" : "Se debe prestar especial atención a la dinámica de la trayectoria de los movimientos del PC. Esto incluye el Velocity , Acceleration , Deceleration , y Jerk entradas de MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , y MC_MoveCircularRelative . Si la posición inicial y de destino están en el mismo sistema de coordenadas dinámico, la dinámica de la ruta será relativa a este sistema de coordenadas. Sin embargo, si la posición inicial y final están en sistemas de coordenadas diferentes, la dinámica de la trayectoria se combina desde la dinámica relativa al primer sistema de coordenadas hasta la dinámica relativa al segundo sistema de coordenadas. Es importante que la dinámica de la trayectoria se establezca por encima del valor absoluto de la diferencia de dinámica entre los dos sistemas de coordenadas. En particular, al pasar de un sistema de coordenadas estático a uno dinámico, la dinámica de la trayectoria debe establecerse por encima del valor absoluto de la dinámica del sistema de coordenadas. La velocidad de trayectoria no puede ser monitoreada con SMC_GroupReadPathDynamics al moverse entre sistemas de coordenadas (seguimiento hacia adentro, hacia afuera o entre diferentes sistemas de coordenadas dinámicos). SMC_GroupReadPathDynamics calcula la dinámica de la ruta en relación con un sistema de coordenadas específico. En el caso de seguimiento de entrada o salida o movimiento entre sistemas de coordenadas dinámicas, este es un movimiento que depende de dos sistemas de coordenadas (los sistemas de coordenadas de inicio y destino difieren). Como resultado, el SMC_GroupReadPathDynamics El bloque de funciones no es adecuado para calcular la dinámica de trayectoria en estos casos. " }, 
{ "title" : "Evite los errores SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED o SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED. ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4558812953211233382159412375", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Sincronización con un sistema de coordenadas en movimiento \/ Evite los errores SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED o SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED. ", 
"snippet" : "Los errores SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED , o SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED se informan si no es posible seguir la ruta ordenada sin violar los límites del eje configurados o la dinámica de la ruta. Si se produce este error, primero se ...", 
"body" : "Los errores SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED , o SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED se informan si no es posible seguir la ruta ordenada sin violar los límites del eje configurados o la dinámica de la ruta. Si se produce este error, primero se debe verificar si los límites del eje y la dinámica de la trayectoria están configurados de acuerdo con las dos secciones anteriores. La desviación del recorrido se puede controlar con las salidas PositionLag y OrientationLag del MC_GroupReadStatus bloque de funciones. Las posibles soluciones son las siguientes: Aumente los límites del eje. Aumente la dinámica de la ruta de los movimientos de CP al realizar un seguimiento en un sistema de coordenadas dinámicas. Reducir la dinámica del sistema de coordenadas. Evitar movimientos cercanos a una singularidad de la cinemática, por ejemplo reposicionando el robot. Si el sistema de coordenadas dinámicas está controlado por la salida de un codificador ruidoso, podría ser útil filtrar la señal del codificador mediante un eje lógico. Para más información, ver Pestaña: Ejes Lógicos. Se puede configurar una tolerancia aceptable para el retraso de posición y orientación mediante el SMC_GroupSetPathTolerance bloque de funciones " }, 
{ "title" : "Ejes rotativos con rango de valor superior a 360 ° ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Ejes rotativos con rango de valor superior a 360 ° ", 
"snippet" : "Comportamiento en el caso de movimientos de PC Durante un movimiento CP ( MC_MoveLinearAbsolute \/ MC_MoveLinearRelative , MC_MoveCircularAbsolute \/ MC_MoveCircularRelative ), los ejes giratorios siempre se accionan en modo automático (período 0). El período del eje siempre se selecciona para que no ...", 
"body" : "Comportamiento en el caso de movimientos de PC Durante un movimiento CP ( MC_MoveLinearAbsolute \/ MC_MoveLinearRelative , MC_MoveCircularAbsolute \/ MC_MoveCircularRelative ), los ejes giratorios siempre se accionan en modo automático (período 0). El período del eje siempre se selecciona para que no haya salto en el eje. Es posible que al final del movimiento CP no se alcance el valor del eje comandado, pero que el eje llegue en un período diferente debido a la selección automática del período. Esto significa que la posición ordenada no se puede alcanzar con el tipo de movimiento seleccionado. Este conflicto se detecta antes de alcanzar la posición de destino, el grupo de ejes se detiene y se emite un error. Ejemplo: utiliza un robot SCARA con tres ejes giratorios A1, A2 y A3. A3 tiene un rango de valores de -360° a +360°. Enseñas dos posiciones en coordenadas de eje. Posición1 = (A1 = 0°, A2 = 90°, A3 = 170°), Posición2 = (A1 = 10°, A2 = 90°, A3 = -170°). Luego ordenas un movimiento lineal ( MC_MoveLinear\/MC_MoveAbsolute) ) con el modo de orientación GreatCircle . Esta combinación de mando en ACS y la interpolación de orientación de gran círculo crea un conflicto. Para seguir la interpolación de orientación, el eje A3 tendría que moverse de 170° en dirección positiva a 190°. Por lo tanto, no puede alcanzar la posición objetivo requerida (-170°). Comentario: En el caso de movimientos CP, el período del eje giratorio está determinado por el tipo de interpolación seleccionado. Esto también significa que la posición de destino del eje depende de la trayectoria de aproximación al punto de destino. Por lo tanto, es posible, por ejemplo, que al combinar dos movimientos un eje llegue en un período diferente al que habría ocurrido con los movimientos amortiguados. Para más información, ver: Interpolación de orientación para movimientos CP" }, 
{ "title" : "Introducción ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_48a1e2bdb79a4093c0a864631bc39e2b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Ejes rotativos con rango de valor superior a 360 ° \/ Introducción ", 
"snippet" : "Los robots suelen tener ejes giratorios con un rango de valores superior a 360 °. Por ejemplo, el último eje (eje de orientación A3) de un robot SCARA a menudo puede viajar más de una rotación, desde aproximadamente -540 ° a 540 °. Esto significa que se puede abordar la misma posición y orientación ...", 
"body" : "Los robots suelen tener ejes giratorios con un rango de valores superior a 360 °. Por ejemplo, el último eje (eje de orientación A3) de un robot SCARA a menudo puede viajar más de una rotación, desde aproximadamente -540 ° a 540 °. Esto significa que se puede abordar la misma posición y orientación de múltiples maneras. Considerando SCARA, por ejemplo, la orientación y posición de la herramienta es idéntica, independientemente de si el último eje está en -170 ° o en 190 ° (= -170 ° + 360 °). Como resultado, la conversión de la posición y orientación cartesianas a valores de eje (la transformación cinemática inversa) no es única, pero tiene varias soluciones. Esto se puede utilizar, por ejemplo, en aplicaciones Pick & Place para ahorrar tiempo al pasar de 170 ° a 190 ° y no a -170 °. Nota: El movimiento del eje de orientación SCARA puede convertirse rápidamente en un factor limitante para el tiempo de ciclo en estas aplicaciones. " }, 
{ "title" : "Resolución de ambigüedad ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_e9620f70b79a4093c0a86463477a7031", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Ejes rotativos con rango de valor superior a 360 ° \/ Resolución de ambigüedad ", 
"snippet" : "Si los puntos a recorrer se ordenan en el sistema de coordenadas del eje (ACS), entonces está claro para cada eje qué valor tomará en el punto de destino. Por otro lado, en el comando cartesiano (posición X \/ Y \/ Z y orientación en A \/ B \/ C) existe esta ambigüedad para los ejes giratorios. La confi...", 
"body" : "Si los puntos a recorrer se ordenan en el sistema de coordenadas del eje (ACS), entonces está claro para cada eje qué valor tomará en el punto de destino. Por otro lado, en el comando cartesiano (posición X \/ Y \/ Z y orientación en A \/ B \/ C) existe esta ambigüedad para los ejes giratorios. La configuración de la cinemática se utiliza para resolver esta ambigüedad. Con los robots SCARA, la configuración ya incluye la configuración de si el SCARA debe acercarse a un punto con ElbowRight o ElbowLeft . Además, la configuración SCARA también incluye la configuración nPeriodA3 , que se puede utilizar para determinar cómo se debe resolver la ambigüedad para el eje A3. Para ello, todo el rango de valores se divide en períodos de la longitud máxima de 360 °: Periodo -1 de -540 ° a -180 ° Periodo 1 de -180 ° a 180 ° Periodo 2 de 180 ° a 540 ° (Para un rango de valores más grande del eje, hay correspondientemente más períodos posibles). También hay un valor especial. Si nPeriodA3 := 0 está configurado, entonces se activa una resolución automática de ambigüedad. Para los movimientos PTP, esto significa que el período se selecciona de modo que la distancia entre las posiciones inicial y final para el eje 4 sea lo más pequeña posible. (El comportamiento con los movimientos de CP se describe a continuación). Por lo tanto, es posible controlar la resolución de la ambigüedad de un eje giratorio estableciendo la configuración cinemática en consecuencia (ver SMC_SetKinConfiguration ). Las cinemáticas que admiten esta funcionalidad implementan la interfaz SMKinematicWithConfigurations3 . El SMC_GroupReadSetPosition , MC_GroupReadActualPosition , y SMC_GroupTargetPosition Los bloques de funciones siempre emiten la configuración con la resolución automática activada de los períodos. La configuración actual con períodos establecidos explícitamente se puede leer leyendo la posición en el ACS y luego convirtiéndola a MCS por medio de SMC_GroupConvertPosition . La configuración devuelta tiene períodos establecidos explícitamente. Para más información, ver: Configuraciones cinemáticas" }, 
{ "title" : "Sincronización de ejes externos, control de avance de par ", 
"url" : "_sm_robotics_external_axis_torque_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ Sincronización de ejes externos, control de avance de par ", 
"snippet" : "Los valores de los ejes de un grupo de ejes normalmente se calculan al final del ciclo después de que se haya ejecutado el código de aplicación programado por el usuario. Sin embargo, para determinadas aplicaciones es necesario que estos valores estén disponibles antes para poder utilizarlos en el c...", 
"body" : "Los valores de los ejes de un grupo de ejes normalmente se calculan al final del ciclo después de que se haya ejecutado el código de aplicación programado por el usuario. Sin embargo, para determinadas aplicaciones es necesario que estos valores estén disponibles antes para poder utilizarlos en el código de la aplicación. El Actualización de SMC_Group El bloque de funciones garantiza que los valores de todos los ejes que forman parte de un grupo de ejes se actualicen inmediatamente. Un caso de uso para SMC_GroupUpdate es la sincronización de ejes que no forman parte del grupo de ejes. Un ejemplo sería un segundo accionamiento para el eje X en un pórtico XY. Antes CODESYS SoftMotion versión 4.13.0.0: Un caso de uso adicional para el SMC_GroupUpdate El bloque de funciones es el control de avance del par. Los valores de los ejes calculados en el ciclo actual se pueden utilizar para calcular los pares establecidos adecuados utilizando un modelo dinámico del robot. En CODESYS SoftMotion versión 4.13.0.0 y superior: Si se ha asignado un modelo dinámico al grupo de ejes usando SMC_GroupSetDynamics , los pares establecidos se calculan automáticamente de forma cíclica y se pueden utilizar para el control anticipativo del par. El uso de SMC_GroupUpdate ya no es necesario para este caso de uso. Para más información, ver: Limitación de par y control de avance de par" }, 
{ "title" : "disparadores ", 
"url" : "_sm_digital_switches-1517880.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ disparadores ", 
"snippet" : "Los activadores se utilizan para realizar una acción cuando el grupo de ejes alcanza una posición definida en la ruta. Por ejemplo, un dispensador de pegamento se puede encender al llegar a la posición de encolado. Los activadores también permiten cambiar el tiempo para que la acción se pueda realiz...", 
"body" : "Los activadores se utilizan para realizar una acción cuando el grupo de ejes alcanza una posición definida en la ruta. Por ejemplo, un dispensador de pegamento se puede encender al llegar a la posición de encolado. Los activadores también permiten cambiar el tiempo para que la acción se pueda realizar en un momento preciso antes o después de alcanzar la posición. Esto se puede usar, por ejemplo, para compensar el tiempo muerto de un dispensador de pegamento. Para este propósito, CODESYS SoftMotion permite configurar los factores desencadenantes de los movimientos y, a continuación, leer de forma continua el tiempo restante hasta alcanzar la posición. Cuando utilice disparadores, preste atención a lo siguiente: El tiempo hasta que se alcanza un desencadenante solo se puede recuperar cuando el grupo de ejes se ha acercado al desencadenante hasta el momento de un pronóstico configurable. Cómo se configura este pronóstico y qué impactos tienen las configuraciones se explica en el Configuración de la aplicación para usar disparadores sección. La trayectoria no cambia con el uso de disparadores. En particular, la trayectoria no se ralentiza para cumplir con la previsión configurada. Si, por ejemplo, la posición de un disparador al comienzo de un movimiento ya se alcanza después de 0,01 segundos, incluso un pronóstico más alto no puede lograr que se proporcione una notificación sobre alcanzar el punto más de 0,01 segundos antes. Para obtener más información, consulte los ejemplos. Activador Ejemplo 1: Ejemplo simple y Activador Ejemplo 2: Proceso de encolado. " }, 
{ "title" : "Configuración de la aplicación para usar disparadores ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612456003211233798533752147", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ disparadores \/ Configuración de la aplicación para usar disparadores ", 
"snippet" : "Configuración de la duración de la previsión La duración del pronóstico determina qué tan lejos en el futuro se realiza la planificación. Esto lo establece el fPlanningForecastDuration parámetro de la SMC_TuneCPKernel bloque de funciones La forma en que se debe configurar este parámetro depende de l...", 
"body" : "Configuración de la duración de la previsión La duración del pronóstico determina qué tan lejos en el futuro se realiza la planificación. Esto lo establece el fPlanningForecastDuration parámetro de la SMC_TuneCPKernel bloque de funciones La forma en que se debe configurar este parámetro depende de los requisitos de la aplicación. Hay dos requisitos principalmente contradictorios: Duración de pronóstico más larga posible Latencia más baja posible. La latencia al iniciar un movimiento aumenta porque primero se tiene que establecer la previsión. El tamaño de esta latencia adicional depende principalmente del rendimiento del controlador utilizado y, en general, es mucho menor que el pronóstico configurado. Además, la latencia del grupo de ejes para reaccionar ante movimientos abortados e interrupciones aumenta según la previsión configurada. El pronóstico no tiene ningún impacto en MC_GroupHalt y MC_GroupStop . Ambos bloques de funciones actúan siempre de forma inmediata e independiente de la previsión configurada. El fPlanningForecastDuration parámetro de la SMC_TuneCPKernel Por lo tanto, el bloque de funciones debe establecerse tan alto como sea necesario pero tan bajo como sea posible. Si no se requiere un pronóstico, entonces el parámetro se puede dejar en el valor predeterminado de 0. La previsión real disponible puede diferir de la configurada por varios motivos, por ejemplo, si ya casi se alcanza el final del último movimiento. El pronóstico actual disponible puede ser monitoreado por medio del CurrentPlanningForecast salida de MC_GroupReadStatus . Configuración del número máximo de disparadores por movimiento Como entregado, CODESYS SoftMotion admite hasta 8 disparadores por movimiento. Si este número no es suficiente, entonces el MAX_NUM_TRIGGERS_PER_MOVEMENT El parámetro se puede cambiar como un parámetro de biblioteca. Esto es posible con el Gerente de biblioteca y el respectivo editor de la parámetros de la biblioteca . Para usar los parámetros de la biblioteca, un CODESYS Se recomienda la versión >= SP19. " }, 
{ "title" : "Ordenar y evaluar disparadores ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4620348699414433798534144567", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ disparadores \/ Ordenar y evaluar disparadores ", 
"snippet" : "Hay dos bloques de funciones disponibles para comandar disparadores: SMC_GroupPrepareTrigger y SMC_GroupReadTrigger . Los activadores se asignan a un movimiento. Cada gatillo individual tiene que ser preparado usando el SMC_GroupPrepareTrigger bloque de funciones La posición se puede especificar rel...", 
"body" : "Hay dos bloques de funciones disponibles para comandar disparadores: SMC_GroupPrepareTrigger y SMC_GroupReadTrigger . Los activadores se asignan a un movimiento. Cada gatillo individual tiene que ser preparado usando el SMC_GroupPrepareTrigger bloque de funciones La posición se puede especificar relativa, absoluta o como una intersección con un plano (ver SMC_TriggerPositionType ). El orden de llamada de SMC_GroupPrepareTrigger y el movimiento respectivo es de particular importancia porque los disparadores preparados se asignan al siguiente movimiento comandado en el mismo ciclo. Por lo tanto, en cada aplicación debe prestar atención a lo siguiente: SMC_GroupPrepareTrigger siempre tiene que llamarse antes del bloque de funciones de movimiento. Los gatillos y el respectivo movimiento deben ser comandados siempre en el mismo ciclo. Si no se inicia ningún movimiento en el ciclo, los disparadores preparados se descartan y el CommandAborted salida de la SMC_GroupPrepareTrigger se establecen los bloques de funciones. Cuando el disparador se asigna a un movimiento, la información sobre un disparador se puede recuperar usando SMC_GroupReadTrigger . Tan pronto como el disparador esté dentro de la duración de pronóstico disponible, el estado cambia a SMC_TRIGGER_STATUS.Active y se puede leer el tiempo hasta que se alcanza el disparador. El tiempo siempre se refiere a la hora de inicio del ciclo actual. Dependiendo de cuándo debe activarse el disparador (antes, durante o después de alcanzar la posición), la acción deseada puede ejecutarse en la aplicación en un ciclo adecuado. Los disparadores no se pueden cancelar cuando se han asignado a un movimiento. En su lugar, simplemente se pueden ignorar. Si un movimiento es abortado por un segundo movimiento con MC_BUFFER_MODE.Aborting , entonces también desaparecen los disparadores asignados al primer movimiento. " }, 
{ "title" : "Gatillos para movimientos con blending ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612455902227233798534431018", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Control de movimiento \/ disparadores \/ Gatillos para movimientos con blending ", 
"snippet" : "Para movimientos con Amortiguación y combinación de movimientos, los disparadores se proyectan en la ruta de fusión. La siguiente imagen muestra cualitativamente un caso en el que un movimiento de P1 a P2, así como un siguiente movimiento, se ordenaron con mezcla. La fusión con el primer movimiento ...", 
"body" : "Para movimientos con Amortiguación y combinación de movimientos, los disparadores se proyectan en la ruta de fusión. La siguiente imagen muestra cualitativamente un caso en el que un movimiento de P1 a P2, así como un siguiente movimiento, se ordenaron con mezcla. La fusión con el primer movimiento finaliza en el punto B, y la fusión con el movimiento anterior comienza en el punto A. El gatillo azul se encuentra entre P1 y B. Se proyecta en la mitad posterior del primer movimiento de fusión (resaltado por la línea azul) . De la misma manera, el gatillo rojo, ubicado entre A y P2, se proyecta en la mitad frontal del segundo movimiento de fusión (resaltado por la línea roja). El gatillo verde está fuera de las áreas de fusión y no se desplaza. Cuando se combina con disparadores, hay una característica especial relacionada con el estado del movimiento y los disparadores respectivos. El bloque de función de comando para pasar de los informes P1 a P2 Done tan pronto como se alcanza el punto A. Sin embargo, el gatillo rojo asociado con este movimiento permanece activo hasta que se alcanza la posición en el elemento de fusión al que se proyectó. " }, 
{ "title" : "Limitación de par y control de avance de par ", 
"url" : "_sm_torque_limitation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitación de par y control de avance de par ", 
"snippet" : "La limitación de par de CODESYS SoftMotion evita que se excedan los límites especificados de los pares o fuerzas de los accionamientos durante los movimientos coordinados. Estos límites de pares y fuerzas se respetan además de los límites existentes para la velocidad, aceleración y tirones de los ac...", 
"body" : "La limitación de par de CODESYS SoftMotion evita que se excedan los límites especificados de los pares o fuerzas de los accionamientos durante los movimientos coordinados. Estos límites de pares y fuerzas se respetan además de los límites existentes para la velocidad, aceleración y tirones de los accionamientos. El requisito para esto es un modelo dinámico para la cinemática aplicada en forma de un bloque de función que implementa el ISMDynamics interfaz de la SM3_Dynamics biblioteca. Básicamente, un AxesStateToTorque Se necesita un método que calcule los pares requeridos para un estado dado de los ejes (para su posición, velocidad y aceleración). Además de la limitación de par, un modelo dinámico permite el cálculo de pares establecidos para un control de avance de par. Puede encontrar un ejemplo de aplicación en el capítulo Modelo de robot dinámico. " }, 
{ "title" : "casos de uso ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597660278291233422349551383", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitación de par y control de avance de par \/ casos de uso ", 
"snippet" : "En muchas cinemáticas, especialmente en cinemáticas en serie, hay un acoplamiento de múltiples articulaciones o de todas las articulaciones. Un ejemplo simple de esto es el péndulo doble con accionamientos en las articulaciones como se muestra a continuación: Caso de uso 1 caso de uso 2 El accionami...", 
"body" : "En muchas cinemáticas, especialmente en cinemáticas en serie, hay un acoplamiento de múltiples articulaciones o de todas las articulaciones. Un ejemplo simple de esto es el péndulo doble con accionamientos en las articulaciones como se muestra a continuación: Caso de uso 1 caso de uso 2 El accionamiento en la primera articulación realiza una rotación de 90°; la segunda articulación no debe moverse (caso de uso 1). Suponiendo una segunda articulación pasiva, es fácil imaginar que la segunda extremidad del péndulo doble girará hacia la izquierda debido a su inercia. Para evitar esta rotación, el accionamiento de la segunda articulación debe generar un par hacia la derecha. Por tanto, el movimiento del primer accionamiento requiere una reacción del segundo accionamiento. El acoplamiento en la dirección opuesta existe, por ejemplo, en el caso de que el primer accionamiento deba moverse a velocidad constante mientras que el segundo accionamiento retrae la segunda rama del péndulo doble (Caso de uso 2). Esto reduce las matrices de inercia del doble péndulo con respecto a la primera articulación. Para obtener el momento angular (el producto de las matrices de inercia y la velocidad angular), es necesario aumentar la velocidad angular de la primera articulación. Para mantener constante la velocidad angular, se debe disminuir el momento angular cambiando el par de la primera transmisión en contra de su dirección de rotación. Por tanto, el movimiento del segundo accionamiento requiere una reacción del primer accionamiento. Sin un modelo dinámico, solo se pueden enviar al variador la posición establecida, la velocidad establecida y la aceleración establecida. En el primer caso, se define una posición fija constante para el segundo accionamiento, independientemente de que la primera articulación se mueva o no. La unidad de control en el segundo accionamiento debe poder manejar el hecho de que se debe generar un par en un caso y no en otro caso para los mismos valores establecidos. El comportamiento es similar en el segundo caso. Aquí, la misma velocidad establecida constante se especifica para la primera transmisión, independientemente de si la segunda articulación se está moviendo o no. También en este caso, la unidad de control del accionamiento debe hacer frente al hecho de que deben generarse diferentes pares para los mismos valores nominales. Con un modelo dinámico, los pares establecidos se pueden calcular y enviar a los convertidores. Allí se pueden utilizar como una dimensión de avance para las unidades de control. Como resultado, la unidad de control recibe información adicional que permite mejorar la calidad del control. La limitación del par permite un cumplimiento más preciso de los límites del accionamiento. En muchos casos, no es decisiva la limitación de la velocidad o la aceleración del accionamiento, sino la limitación de los pares. Las ventajas de la limitación del par quedan claras a partir del ejemplo del péndulo doble descrito anteriormente cuando se comparan los siguientes movimientos: un movimiento del primer accionamiento con el segundo brazo retraído y un movimiento del primer accionamiento con el segundo brazo extendido. En estado retraído, las matrices de inercia con respecto a la primera articulación son menores que en estado extendido. Por lo tanto, para el mismo movimiento (las mismas curvas de velocidad y aceleración del accionamiento), se requiere un par mayor en el estado extendido que en el estado retraído. Sin un modelo dinámico, los límites de velocidad y aceleración deben establecerse para que los límites de par se respeten en ambos estados. Esto puede causar que la primera transmisión se mueva a una velocidad o aceleración más baja en el estado retraído que la que sería necesaria para cumplir con los límites de torsión de la transmisión. Con un modelo dinámico, los límites de par pueden configurarse, tenerse en cuenta al planificar el movimiento y, por lo tanto, utilizarse completamente en ambos estados. Un ejemplo un poco más complejo es el primer caso descrito anteriormente, donde la primera unidad se mueve y la segunda unidad debe mantener su posición. El par requerido en el segundo accionamiento para mantener su posición depende del movimiento del primer accionamiento. Si el primer accionamiento acelera demasiado, entonces, en principio, se puede violar el límite de par del segundo accionamiento. Sin un modelo dinámico, esto solo se puede evitar configurando los límites de aceleración de la primera unidad en consecuencia. Con un modelo dinámico, el límite de par configurado del segundo accionamiento se puede tener en cuenta al planificar el movimiento y se puede limitar la aceleración del primer accionamiento. En el caso de movimientos o cinemáticas más complejos, los efectos de acoplamiento descritos aquí se combinan con aún más efectos de acoplamiento. Un modelo dinámico permite tener en cuenta estos acoplamientos, lo que da como resultado mejores especificaciones de valores establecidos y una mejor adherencia a los límites de los accionamientos. " }, 
{ "title" : "Configuración del modelo dinámico ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4510933957710433418427140333", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitación de par y control de avance de par \/ Configuración del modelo dinámico ", 
"snippet" : "Un modelo dinámico existente en forma de un bloque de funciones que implementa el ISMDynamics La interfaz se puede asignar a un grupo de ejes mediante el SMC_GroupSetDynamics bloque de funciones Además del modelo dinámico, el bloque de funciones también debe usarse para configurar la dirección y la ...", 
"body" : "Un modelo dinámico existente en forma de un bloque de funciones que implementa el ISMDynamics La interfaz se puede asignar a un grupo de ejes mediante el SMC_GroupSetDynamics bloque de funciones Además del modelo dinámico, el bloque de funciones también debe usarse para configurar la dirección y la magnitud de la aceleración gravitacional en forma de vector en el sistema de coordenadas de la máquina. " }, 
{ "title" : "Consideración de cargas ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552490173838433418429772624", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitación de par y control de avance de par \/ Consideración de cargas ", 
"snippet" : "Las cargas adicionales (por ejemplo, objetos agarrados o herramientas acopladas) se pueden tener en cuenta mediante el SMC_GroupSetLoad bloque de funciones y cambiado en tiempo de ejecución. Él ExecutionMode La entrada del bloque de funciones se puede utilizar para definir cuándo debe tener efecto u...", 
"body" : "Las cargas adicionales (por ejemplo, objetos agarrados o herramientas acopladas) se pueden tener en cuenta mediante el SMC_GroupSetLoad bloque de funciones y cambiado en tiempo de ejecución. Él ExecutionMode La entrada del bloque de funciones se puede utilizar para definir cuándo debe tener efecto un cambio de carga (por ejemplo, inmediatamente o solo después de que se haya completado el movimiento actual). Continuación con MC_GroupContinue : Al continuar, cada movimiento que se almacena en los datos de continuar mantiene la carga con la que se ordenó originalmente. Cualquier movimiento que se ordene después de la continuación utiliza la última carga establecida. " }, 
{ "title" : "Consideración de una caja de cambios ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552678559262433422353734728", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitación de par y control de avance de par \/ Consideración de una caja de cambios ", 
"snippet" : "Los pares establecidos se calculan para la salida del reductor y no se convierten automáticamente al accionamiento. Él SMC_SetAdditionalConversionFactors El bloque de funciones se puede utilizar para configurar un factor de conversión adicional para el par de cada eje. La caja de cambios también se ...", 
"body" : "Los pares establecidos se calculan para la salida del reductor y no se convierten automáticamente al accionamiento. Él SMC_SetAdditionalConversionFactors El bloque de funciones se puede utilizar para configurar un factor de conversión adicional para el par de cada eje. La caja de cambios también se puede tener en cuenta de esta manera. " }, 
{ "title" : "Unidades ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597662777713633422354433707", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitación de par y control de avance de par \/ Unidades ", 
"snippet" : "Las fuerzas y pares y sus límites se especifican básicamente en la aplicación en newtons (N) o newton metros (Nm). Antes de que se envíen las fuerzas o los pares establecidos a los variadores, se puede realizar un cambio de escala. Para ello, la norma CiA 402 exige, por ejemplo, que los pares ajusta...", 
"body" : "Las fuerzas y pares y sus límites se especifican básicamente en la aplicación en newtons (N) o newton metros (Nm). Antes de que se envíen las fuerzas o los pares establecidos a los variadores, se puede realizar un cambio de escala. Para ello, la norma CiA 402 exige, por ejemplo, que los pares ajustados se envíen al variador en milésimas del par nominal (en mNm). La unidad de longitud es específica del usuario en SoftMotion. Debido a que las fuerzas y los pares se definen como una unidad fija (N o Nm), se debe configurar un factor de conversión de una unidad de longitud específica del usuario a metros (a menos que se utilicen metros como unidad de longitud). Esto se puede hacer con el SMC_GroupSetUnits bloque de funciones " }, 
{ "title" : "Limitación de par en sistemas de coordenadas en movimiento ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552049322772833422354993274", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitación de par y control de avance de par \/ Limitación de par en sistemas de coordenadas en movimiento ", 
"snippet" : "Si el grupo de ejes se mueve en un sistema de coordenadas móvil, entonces los límites de par se pueden respetar solo cuando el grupo de ejes puede seguir exactamente el sistema de coordenadas móvil. Si esto no es posible y las tolerancias para la desviación se configuran mediante SMC_GroupSetPathTol...", 
"body" : "Si el grupo de ejes se mueve en un sistema de coordenadas móvil, entonces los límites de par se pueden respetar solo cuando el grupo de ejes puede seguir exactamente el sistema de coordenadas móvil. Si esto no es posible y las tolerancias para la desviación se configuran mediante SMC_GroupSetPathTolerance , es posible que se excedan los límites de par al intentar compensar la desviación. Si se produce un error porque las desviaciones están fuera de las tolerancias, el grupo de ejes se detiene. Durante esta parada, también se pueden superar los límites de par. Los pares ajustados se calculan en cada caso y se envían a los accionamientos. " }, 
{ "title" : "Limitación de par en caso de error ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4612699285196833422355410226", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitación de par y control de avance de par \/ Limitación de par en caso de error ", 
"snippet" : "Si se detecta un error durante la planificación (por ejemplo, que un movimiento ordenado violará el área de trabajo), el grupo de ejes se detiene en la ruta ordenada anteriormente. Al hacerlo, se respetan los límites de par. Si no es posible detenerse en el camino (por ejemplo, porque una unidad inf...", 
"body" : "Si se detecta un error durante la planificación (por ejemplo, que un movimiento ordenado violará el área de trabajo), el grupo de ejes se detiene en la ruta ordenada anteriormente. Al hacerlo, se respetan los límites de par. Si no es posible detenerse en el camino (por ejemplo, porque una unidad informa de un error), tampoco se podrán cumplir los límites de par. " }, 
{ "title" : "Diferencias al usar movimientos de un solo eje y movimientos coordinados ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4483062104566433422355806924", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitación de par y control de avance de par \/ Diferencias al usar movimientos de un solo eje y movimientos coordinados ", 
"snippet" : "Básicamente, los pares establecidos se calculan para todos los ejes que forman parte de un grupo de ejes con un modelo dinámico. Esto se aplica tanto en parada como cuando el eje se desplaza mediante movimientos de un solo eje (p. ej., MC_MoveAbsolute ) o todo el grupo de ejes se desplaza mediante m...", 
"body" : "Básicamente, los pares establecidos se calculan para todos los ejes que forman parte de un grupo de ejes con un modelo dinámico. Esto se aplica tanto en parada como cuando el eje se desplaza mediante movimientos de un solo eje (p. ej., MC_MoveAbsolute ) o todo el grupo de ejes se desplaza mediante movimientos coordinados (p. ej., MC_MoveDirectAbsolute ). La limitación de par está activa solo para movimientos coordinados. La razón de esto es que los pares necesarios de un eje, como se describió anteriormente, dependen de la posición y el movimiento de algunos o todos los otros ejes en el grupo de ejes. Por lo tanto, solo es posible una limitación del par cuando todos los ejes del grupo de ejes se pueden mover como movimientos coordinados. Una excepción es el SMC_GroupJog bloque de funciones. Este bloque de funciones no admite la limitación de par. Se recomienda utilizar SMC_GroupJog2 en cambio. " }, 
{ "title" : "Diagnóstico ", 
"url" : "_sm_robotics_diagnosis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnóstico ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Errores comunes ", 
"url" : "_sm_robotics_errors.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnóstico \/ Errores comunes ", 
"snippet" : "Esta página describe errores comunes de grupos de ejes, sus causas y posibles acciones a tomar para corregir el error. Para obtener una lista de todos los errores posibles con una breve descripción, consulte la página de ayuda para SMC_ERROR (ENUM) . Código de error Explicación y causas Comportamien...", 
"body" : "Esta página describe errores comunes de grupos de ejes, sus causas y posibles acciones a tomar para corregir el error. Para obtener una lista de todos los errores posibles con una breve descripción, consulte la página de ayuda para SMC_ERROR (ENUM) . Código de error Explicación y causas Comportamiento SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED El grupo de ejes no puede seguir la ruta ordenada sin violar un límite de eje (velocidad, aceleración o sacudida). Este error ocurre a menudo durante seguimiento si el sistema de coordenadas dinámico se mueve inesperadamente. El error también puede ocurrir cuando el camino pasa cerca de una posición singular del robot. Posiciones singulares ocurren entre diferentes configuraciones (por ejemplo, con el robot SCARA cuando el brazo está totalmente extendido). Ver Evite los errores SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED o SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED.Si no se utiliza ningún sistema de coordenadas dinámico, asegúrese de que la trayectoria del robot no pase cerca de una posición singular. SMC_CP_QUEUE_UNDERRUN La trayectoria (perfil de velocidad) del grupo de ejes no se pudo calcular lo suficientemente rápido y, como resultado, el grupo de ejes tiene que cancelar el movimiento. Posibles Causas: Problemas de rendimiento. El controlador en uso no proporciona suficiente rendimiento o se calcula demasiado en una tarea de alta prioridad. Configuración de tareas desfavorable: el cálculo de la trayectoria se ve desplazado por otras tareas. Comandos de computación intensiva. Por ejemplo, puede ser necesario más tiempo de cálculo si un movimiento de mezcla se interrumpe mediante un movimiento de interrupción y este se interrumpe de nuevo mediante un movimiento de interrupción. El uso de seguimiento (sistemas de coordenadas dinámicos) también requiere más tiempo de cálculo. la ejecución de SMC_GroupSaveContinueData durante un movimiento y el uso de muchos disparadores activos simultáneamente también pueden aumentar el tiempo de cálculo requerido. Compruebe si la configuración de la tarea de planificación del grupo de ejes se ha seleccionado correctamente y, si es posible, reubique esta tarea en un núcleo de CPU independiente y dedicado. Para más información, ver: Configuración de la tarea de planificaciónSobre el Supervisión pestaña de configuración de tareas 1 compruebe si una tarea de alta prioridad requiere mucho tiempo de computación y, si es posible, mueva los cálculos que requieren un alto rendimiento a una tarea de baja prioridad. Usar SMC_TuneCPKernel para aumentar el intervalo de planificación. Para más información, ver: Diagnóstico en caso de movimientos lentos o espasmódicos.Nota: Puede utilizar los contadores de rendimiento de SMC_GroupReadPlanningStatistics para determinar el efecto de estas acciones. Para más información, ver: Diagnóstico en caso de movimientos lentos o espasmódicos.SMC_TRAFO_INVALID_CONSTELLATION SMC_AXIS_POSITION_EXCEEDS_POSLIMITS SMC_AXIS_INVERSE_TRAFO_EXCEEDING_POSLIMITS La ruta está total o parcialmente fuera del espacio de trabajo del robot. Posibles Causas: El punto inicial o final de un movimiento está fuera del espacio de trabajo. Dependiendo del tipo de robot, parte del movimiento de un CP puede realizarse fuera del espacio de trabajo. Un segmento circular con un radio demasiado grande puede encontrarse al principio y al final del espacio de trabajo, mientras que la sección central sale del espacio de trabajo. Cuando se utiliza el seguimiento (sistemas de coordenadas dinámicos), es posible que una posición que se haya ubicado previamente dentro del espacio de trabajo abandone el espacio de trabajo con el tiempo debido al movimiento del sistema de coordenadas. Nota: Cuando se informa el error, el grupo de ejes no está necesariamente cerca de la posición problemática. Es posible que el error se encuentre y se notifique durante el cálculo de la trayectoria y se refiera a un segmento de trayectoria que aún se encuentra a una gran distancia de la posición actual. Verifique los movimientos ordenados y asegúrese de que estén completamente dentro del espacio de trabajo. Cuando utilice el seguimiento: utilice límites adecuados para asegurarse de que el grupo de ejes no se salga del espacio de trabajo con el tiempo. Por ejemplo, en Pick&Place con cinta transportadora es habitual definir una zona segura en la que todavía se puedan recoger piezas de la cinta transportadora. Después de que una pieza haya abandonado esta región, el grupo de ejes ya no debería moverse hacia la pieza. SMC_CP_CONFIGS_DIFFER SMC_CP_AXIS_ORIENTATION_IPO_CONFIG_DIFFERS Las posiciones inicial y objetivo de un movimiento CP se encuentran en diferentes configuraciones. El manejo de las configuraciones se explica en la Configuraciones cinemáticas capítulo. Cuando usas OrientationMode Axis , ver el Interpolación de orientación para movimientos CP capítulo para obtener detalles sobre la configuración de la parte de orientación del robot. Posibles acciones: Asegúrese de que las posiciones inicial y final de los movimientos CP estén ubicadas en la misma configuración. Si es necesario, utilice el SMC_SetKinConfiguration bloque de funciones para establecer la configuración del robot al principio (después MC_GroupEnable ). Utilice movimientos PTP para cambiar entre configuraciones si lo desea. " }, 
{ "title" : "Actuación ", 
"url" : "_sm_robotics_performance.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnóstico \/ Actuación ", 
"snippet" : "La planificación de movimientos se realiza en una tarea separada porque el cálculo requiere un uso intensivo de la CPU. Esta tarea separada se denomina tarea de planificación y se ejecuta en paralelo con la tarea del bus. Si el rendimiento del PLC no es suficiente para planificar la ruta en la tarea...", 
"body" : "La planificación de movimientos se realiza en una tarea separada porque el cálculo requiere un uso intensivo de la CPU. Esta tarea separada se denomina tarea de planificación y se ejecuta en paralelo con la tarea del bus. Si el rendimiento del PLC no es suficiente para planificar la ruta en la tarea de planificación a tiempo para la tarea del bus, entonces se trata de problemas de rendimiento. Los problemas de rendimiento en la planificación del movimiento pueden conducir a la SMC_CP_QUEUE_UNDERRUN error, pero también pueden provocar un movimiento entrecortado o más lento de lo esperado. Para información sobre el SMC_CP_QUEUE_UNDERRUN error, ver el Errores comunes capítulo. El diagnóstico de problemas relacionados con el rendimiento con los movimientos se describe a continuación. " }, 
{ "title" : "Diagnóstico en caso de movimientos lentos o espasmódicos. ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm4597696111868834242456592379", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnóstico \/ Actuación \/ Diagnóstico en caso de movimientos lentos o espasmódicos. ", 
"snippet" : "Si no hay problemas de ejecución, entonces cada movimiento se planifica de tal manera que al menos uno de los límites efectivos se alcanza durante todo el movimiento. Como ejemplo, considere un pórtico bidimensional simple con dos ejes X e Y y un movimiento PTP desde la posición (0,0) a (10,-10). La...", 
"body" : "Si no hay problemas de ejecución, entonces cada movimiento se planifica de tal manera que al menos uno de los límites efectivos se alcanza durante todo el movimiento. Como ejemplo, considere un pórtico bidimensional simple con dos ejes X e Y y un movimiento PTP desde la posición (0,0) a (10,-10). La velocidad máxima del eje es 20, la aceleración máxima del eje es 100 y la sacudida máxima del eje es 1000. El movimiento esperado se ve así: La aceleración se establece primero con una sacudida máxima hasta alcanzar el valor límite de aceleración de 100. Después de una breve fase de aceleración constante, la aceleración se reduce nuevamente con un tirón máximo, de modo que con aceleración 0 se alcanza el valor límite de velocidad 20. Después de una fase de velocidad constante, se desacelera de manera que se alcanza la posición objetivo con velocidad. y aceleración 0. Hay dos posibles razones por las que el movimiento real se desvía de esta curva ideal: El movimiento planificado no se corresponde con la curva ideal debido a problemas de desempeño en la tarea de planificación. El movimiento planificado corresponde a la curva ideal, pero el robot no lo ejecuta como se esperaba. " }, 
{ "title" : "Caso 1: Problemas de desempeño de la tarea de planificación ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433006527711", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnóstico \/ Actuación \/ Diagnóstico en caso de movimientos lentos o espasmódicos. \/ Caso 1: Problemas de desempeño de la tarea de planificación ", 
"snippet" : "Si hay problemas con el rendimiento durante la planificación, entonces el movimiento podría verse así: Esto se debe a que el movimiento se planifica en la tarea de planificación en paralelo a la ejecución en la tarea de autobús. En promedio, la tarea de planificación debe proporcionar tanta trayecto...", 
"body" : "Si hay problemas con el rendimiento durante la planificación, entonces el movimiento podría verse así: Esto se debe a que el movimiento se planifica en la tarea de planificación en paralelo a la ejecución en la tarea de autobús. En promedio, la tarea de planificación debe proporcionar tanta trayectoria como requiere la tarea del autobús. Si el rendimiento no es suficiente para ello, el movimiento se ralentiza. Esto conduce a la curva de velocidad ondulada. La primera y más importante herramienta para diagnosticar este tipo de problemas es el rastreo. Además de fSetPosition , fSetVelocity , y fSetAcceleration variables para cada eje, la numTimeBudgetExceeded y numSlowDownLowIpoQueue salidas de la SMC_GroupReadPlanningStatistics El bloque de funciones también debe registrarse. Si estos contadores aumentan continuamente, entonces hay un problema de rendimiento. De manera similar a la fSetPosition , fSetVelocity , y fSetAcceleration variables, también está la fSetJerk variable para el tirón. Cabe señalar que la sacudida no es la sacudida promedio que se aplica durante el ciclo de la tarea del bus (como a menudo se espera), sino más bien la sacudida instantánea al final del ciclo. Por lo tanto, FSetJerk tiene sólo una importancia limitada para diagnosticar problemas de rendimiento. " }, 
{ "title" : "Formas de mejorar el movimiento. ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm43443300985204", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnóstico \/ Actuación \/ Diagnóstico en caso de movimientos lentos o espasmódicos. \/ Caso 1: Problemas de desempeño de la tarea de planificación \/ Formas de mejorar el movimiento. ", 
"snippet" : "La siguiente lista contiene pasos para manejar problemas de rendimiento: Ajuste de los valores límite de velocidad, aceleración y sacudida: Cuanto más se tarde en desacelerar desde la velocidad actual hasta detenerse, mayor será la potencia de cálculo necesaria Por lo tanto, es más probable que un v...", 
"body" : "La siguiente lista contiene pasos para manejar problemas de rendimiento: Ajuste de los valores límite de velocidad, aceleración y sacudida: Cuanto más se tarde en desacelerar desde la velocidad actual hasta detenerse, mayor será la potencia de cálculo necesaria Por lo tanto, es más probable que un valor límite efectivo alto para la velocidad y unos valores límite efectivos bajos para la aceleración y la sacudida conduzcan a problemas de rendimiento. En particular, los valores límite para la aceleración y la sacudida no deberían fijarse innecesariamente bajos. Aumente la prioridad de la tarea de planificación o disminuya la prioridad de las otras tareas si están bloqueando la tarea de planificación. La tarea de planificación debería tener la segunda prioridad más alta después de la tarea del autobús. Asigne la tarea de planificación a un núcleo dedicado si hay varios núcleos de CPU disponibles (consulte Configuración de la tarea de planificación). Usar SMC_TuneCPKernel para aumentar el valor de la fPlanningInterval y\/o fSyncBufferDuration parámetros de planificación. El fPlanningInterval El parámetro especifica el incremento máximo de planificación (en segundos). El tiempo de ciclo de la tarea de planificación no debe exceder permanentemente este valor. Un valor más alto reduce la potencia de cálculo, pero también puede provocar que los valores límite ajustados para velocidad, aceleración y sacudida no se aprovechen en su totalidad. A partir de un valor inicial de 0,016 segundos (el valor predeterminado desde CODESYS SoftMotion versión 4.6.0.0), el valor debe aumentarse gradualmente hasta que el rendimiento sea aceptable. El fSyncBufferDuration El parámetro especifica el tamaño del búfer entre la tarea de planificación y de bus. Los tiempos de ciclo pico de la tarea de planificación no deben exceder este valor. Un valor más alto puede compensar los picos en el tiempo del ciclo de la tarea de planificación. Al mismo tiempo, esto también aumenta la latencia en la ejecución de interrupciones y movimientos de interrupción. " }, 
{ "title" : "Caso 2: El robot no sigue el movimiento planificado como se esperaba ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433008452776", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnóstico \/ Actuación \/ Diagnóstico en caso de movimientos lentos o espasmódicos. \/ Caso 2: El robot no sigue el movimiento planificado como se esperaba ", 
"snippet" : "Si el robot no sigue el movimiento planificado como se esperaba, esto puede deberse a las siguientes razones: Capacidad insuficiente del controlador en tiempo real Problemas en el circuito de control de los variadores. En un controlador sin capacidad de tiempo real, como el CODESYS Control Win , o u...", 
"body" : "Si el robot no sigue el movimiento planificado como se esperaba, esto puede deberse a las siguientes razones: Capacidad insuficiente del controlador en tiempo real Problemas en el circuito de control de los variadores. En un controlador sin capacidad de tiempo real, como el CODESYS Control Win , o un controlador basado en Linux sin un parche en tiempo real del sistema Linux subyacente, pueden ocurrir movimientos demasiado lentos o entrecortados incluso con un rendimiento suficiente. Esto sucede si la tarea del bus no se ejecuta a tiempo en el período de tiempo configurado. " }, 
{ "title" : "Formas de mejorar el movimiento. ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433012326085", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnóstico \/ Actuación \/ Diagnóstico en caso de movimientos lentos o espasmódicos. \/ Caso 2: El robot no sigue el movimiento planificado como se esperaba \/ Formas de mejorar el movimiento. ", 
"snippet" : "En la pestaña \"Monitoreo\" de la configuración de tareas 1 , compruebe si la tarea de la tarea del bus 2 es muy alto. Este puede ser el caso porque la tarea del bus está siendo desplazada por una tarea con la misma o mayor prioridad, o porque el controlador no tiene suficiente capacidad en tiempo rea...", 
"body" : "En la pestaña \"Monitoreo\" de la configuración de tareas 1 , compruebe si la tarea de la tarea del bus 2 es muy alto. Este puede ser el caso porque la tarea del bus está siendo desplazada por una tarea con la misma o mayor prioridad, o porque el controlador no tiene suficiente capacidad en tiempo real. Si la fluctuación es demasiado alta y ya se ha asegurado de que la tarea del bus tenga la máxima prioridad, entonces la capacidad en tiempo real del controlador no es suficiente. En este caso, utilice un controlador con mejores propiedades en tiempo real. Si hay problemas con el circuito de control en el variador, entonces deberá ajustar los parámetros del circuito de control. El control de avance del par también puede mejorar el rendimiento del circuito de control. Para más información, ver: Limitación de par y control de avance de par1 : Es aconsejable restablecer los valores medidos de la supervisión de tareas en el menú contextual porque el primer ciclo del PLC después de iniciar la aplicación a menudo tiene una duración mayor y una mayor fluctuación. 2 : Valores de fluctuación de hasta aprox. 20 us son muy buenos y valores de hasta aprox. 100 nosotros estamos bien. Dependiendo de las unidades utilizadas, también puede funcionar el funcionamiento con valores de fluctuación más altos. Los valores de fluctuación que alcanzan el orden de magnitud del intervalo de tarea de la tarea del bus pueden dar como resultado el patrón de error descrito anteriormente. " }, 
{ "title" : "Información de registro ", 
"url" : "_sm_information_logging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnóstico \/ Información de registro ", 
"snippet" : "El Registro de eventos de SMC_Groupe bloque de funciones se introdujo con la versión 4.18.0.0 de SoftMotion. El bloque de funciones se puede usar para habilitar los mensajes de registro para un grupo de ejes. Tan pronto como se habilitan los mensajes de registro, el grupo de ejes escribe las accione...", 
"body" : "El Registro de eventos de SMC_Groupe bloque de funciones se introdujo con la versión 4.18.0.0 de SoftMotion. El bloque de funciones se puede usar para habilitar los mensajes de registro para un grupo de ejes. Tan pronto como se habilitan los mensajes de registro, el grupo de ejes escribe las acciones que realiza en el Registrar del dispositivo. De esta forma, los eventos del grupo de ejes se pueden rastrear cronológicamente. Esto puede resultar útil a la hora de investigar los problemas y el comportamiento inesperado del grupo de ejes Asigna nombres a tus movimientos, cargas, herramientas, etc. para recibir mensajes de registro informativos. CODESYS SoftMotion versión 4.18.0.0 y superiores, algunos bloques de funciones de comando (como MC_MoveLinearAbsolute , SMC_GroupSetTool y MC_SetCoordinateTransform ) han recibido un nuevo Name entrada. El registro puede tener un impacto negativo en el rendimiento y, por lo tanto, debe habilitarse mediante SMC_GroupEventLogging bloque de funciones. En CODESYS SoftMotion en la versión 4.18.0.0, se registran los mensajes relacionados con la ruta del grupo de ejes. Categoría Acción Descripción Información adicional Movimiento Comienza el movimiento El grupo de ejes ha iniciado la interpolación de un movimiento. Descripción generalFinaliza el movimiento El grupo de ejes ha completado la interpolación de un movimiento. Comienza la mezcla El grupo de ejes ha comenzado a fusionarse del movimiento activo al movimiento siguiente. Finaliza la mezcla El grupo de ejes ha terminado de fusionarse y continúa con la interpolación en el siguiente movimiento. Se inicia el aborto El grupo de ejes abortó el movimiento actual y se está fusionando con el movimiento abortado. Finaliza la interrupción El grupo de ejes ha terminado de fusionarse y continúa con la interpolación en el movimiento de aborto. Comienza la espera El grupo de ejes espera en la posición actual. La espera termina El grupo de ejes ha terminado de esperar. Detener\/detener arranques El grupo de ejes ha empezado a detener o detener la ruta. Finaliza la parada o parada El grupo de ejes ha realizado la detención\/parada en la ruta. Herramienta Herramienta adjunta El grupo de ejes utiliza una nueva herramienta. Configuración de una compensación de herramientaCargar Carga adjunta El grupo de ejes usa una carga nueva. Limitación de par y control de avance de parAnular Modificación de eje o ruta cambiada La modificación del eje o la ruta ha cambiado y el grupo de ejes la ha aplicado. MC_GroupSetOverride (FB) Precisión de trayectoria El camino se ha ido El grupo de ejes se ha desviado de la ruta ordenada para evitar infringir los límites del eje. El grupo de ejes intenta volver a alcanzar la ruta ordenada. Tolerancias para la precisión de la rutaSe ha vuelto a alcanzar el camino El grupo de ejes ha vuelto a alcanzar la ruta ordenada. Interrumpir: continuar Se inicia la interrupción El grupo de ejes ha empezado a ejecutar una interrupción. Interrupción y continuación de movimientosFinaliza la interrupción El grupo de ejes ejecutó la interrupción y guardó los datos de Continuar. Continuar comienza El grupo de ejes ha leído Continuar con los datos y comienza a continuarlos. " }, 
{ "title" : "Ejemplos ", 
"url" : "_sm_robotics_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Correr un robot ", 
"url" : "_sm_robotics_jogging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Correr un robot ", 
"snippet" : "Ver el Robotics_Jogging.project proyecto de ejemplo en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo demuestra cómo desplazar un grupo de ejes con el SMC_GroupJog2 POU. Se recomienda instalar el CODESYS Depictor para este ejemplo (la versión de demo...", 
"body" : "Ver el Robotics_Jogging.project proyecto de ejemplo en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo demuestra cómo desplazar un grupo de ejes con el SMC_GroupJog2 POU. Se recomienda instalar el CODESYS Depictor para este ejemplo (la versión de demostración gratuita es suficiente). Alternativamente, también puede eliminar las partes de código correspondientes del ejemplo para usar el ejemplo sin Depictor. " }, 
{ "title" : "Solicitud ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584875037158433080105006434", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Correr un robot \/ Solicitud ", 
"snippet" : "Para demostrar el caso más general posible, el ejemplo tiene las siguientes funciones: Utilización de un robot con singularidades (robot articulado de 6 ejes). El ejemplo muestra que puede mover el robot a través de singularidades en ACS y luego continuar trotando de forma cartesiana en una configur...", 
"body" : "Para demostrar el caso más general posible, el ejemplo tiene las siguientes funciones: Utilización de un robot con singularidades (robot articulado de 6 ejes). El ejemplo muestra que puede mover el robot a través de singularidades en ACS y luego continuar trotando de forma cartesiana en una configuración diferente. Desplazamiento y rotación del sistema de coordenadas de máquina (MCS) del robot con respecto al sistema de coordenadas mundial (WCS). De esta forma, puede ver cómo se diferencia el jogging en MCS y WCS. Configuración de una herramienta desplazada y girada con respecto a la brida (F). En la siguiente figura, puede ver la herramienta y el desplazamiento y rotación del TCS con respecto a la brida (F). Un eje lineal adicional Add0 y un eje giratorio adicional Add1 . " }, 
{ "title" : "Estructura de la aplicación ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4576391101379233081218831739", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Correr un robot \/ Estructura de la aplicación ", 
"snippet" : "Programa principal el programa principal PLC_PRG consiste en una máquina de estado, que Activa el grupo de ejes (estado 0) Configura la herramienta (estado 5) Configura el MCS (estado 6) Inicia el trote (estado 10) En el estado 20, se manejan los errores de avance y se aceptan los comandos de movimi...", 
"body" : "Programa principal el programa principal PLC_PRG consiste en una máquina de estado, que Activa el grupo de ejes (estado 0) Configura la herramienta (estado 5) Configura el MCS (estado 6) Inicia el trote (estado 10) En el estado 20, se manejan los errores de avance y se aceptan los comandos de movimiento ( Mover a la posición cambiar en la visualización). Los otros estados se utilizan para realizar el movimiento (60, 70) y para manejar y reconocer errores (900, 1000). Según la máquina de estados, todas las POU robóticas y el GroupJog2 El programa se llama cíclicamente y se realizan algunos cálculos para la visualización 3D en Depictor. Programa Group Jog2 Este programa contiene una máquina de estado con los siguientes pasos: En el estado 10 se establecen las entradas de SMC_GroupJog2 y se lee la configuración de los ejes del robot (SMC_GroupReadActualPosition). Esta configuración se realiza en el estado 20 en el grupo de ejes (SMC_SetKinConfiguration). En el estado 30, el sistema reacciona a los errores durante el avance, así como a los cambios en la configuración del avance (por ejemplo, a un sistema de coordenadas modificado). Si hay un cambio, el sistema vuelve al estado 10. El estado 50 se ingresa en un flanco descendente de la entrada Habilitar. MC_GroupHalt detiene el avance. " }, 
{ "title" : "Puesta en marcha ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584880854092833081221538291", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Correr un robot \/ Puesta en marcha ", 
"snippet" : "Compile e inicie el programa creado. Puede utilizar la visualización para ejecutar el robot. Puede definir todos los ajustes relevantes para el avance (por ejemplo, en qué sistema de coordenadas se realiza el avance ya qué velocidad). Si ha instalado el CODESYS Depictor , entonces se recomienda colo...", 
"body" : "Compile e inicie el programa creado. Puede utilizar la visualización para ejecutar el robot. Puede definir todos los ajustes relevantes para el avance (por ejemplo, en qué sistema de coordenadas se realiza el avance ya qué velocidad). Si ha instalado el CODESYS Depictor , entonces se recomienda colocar la ventana con el Depictor ( Scene POU) junto a la ventana de visualización. El Depictor representa el TCS (Sistema de coordenadas de herramientas) en la parte delantera del robot. Además, el eje de rotación actual del TCS se muestra en púrpura. Esto es útil para comprobar los diferentes tipos de cambio de orientación (por ejemplo, probar el ABC_as_ACS opción y la TCS sistema coordinado). " }, 
{ "title" : "Interrupción y continuación de movimientos ", 
"url" : "_sm_robotics_example_stop_continue.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Interrupción y continuación de movimientos ", 
"snippet" : "El Robotics_Interrupt_Continue.project El proyecto de ejemplo descrito aquí se encuentra en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo los movimientos ordenados se pueden interrumpir con el SMC_GroupInterrupt bloque de funciones y se reanu...", 
"body" : "El Robotics_Interrupt_Continue.project El proyecto de ejemplo descrito aquí se encuentra en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Este ejemplo muestra cómo los movimientos ordenados se pueden interrumpir con el SMC_GroupInterrupt bloque de funciones y se reanuda más tarde con el SMC_GroupContinue bloque de funciones. El grupo de ejes puede realizar cualquier movimiento entre interrupción y continuación. " }, 
{ "title" : "Estructura de la aplicación ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4519127872464034232302809299", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Interrupción y continuación de movimientos \/ Estructura de la aplicación ", 
"snippet" : "La aplicación consta de una máquina de estados simple en el PLC_PRG programa y un seguimiento para rastrear fácilmente las transiciones de estado. Primero, se habilitan los ejes y el grupo de ejes. ( STATE_POWER_ON ) Luego, dos movimientos, moveLinearA y moveLinearB , se ordenan con la combinación. ...", 
"body" : "La aplicación consta de una máquina de estados simple en el PLC_PRG programa y un seguimiento para rastrear fácilmente las transiciones de estado. Primero, se habilitan los ejes y el grupo de ejes. ( STATE_POWER_ON ) Luego, dos movimientos, moveLinearA y moveLinearB , se ordenan con la combinación. ( STATE_START_MOVING ) Tan pronto como el segundo movimiento está activo (cuando comienza la mezcla), el movimiento se interrumpe. La causa podría ser, por ejemplo, que se haya detectado un defecto en la herramienta. (STATE_INTERRUPT ) Se realiza un movimiento PTP relativo en dirección Z positiva, por ejemplo, para sustituir la herramienta después del defecto. (STATE_INTERMEDIATE_MOVEMENT ) Antes de reanudar, el sistema vuelve a la posición donde se interrumpió el movimiento original. ( STATE_GET_CONTINUE_POS \/ STATE_MOVE_TO_CONTINUE_POS ) Se retoma el movimiento original. (STATE_CONTINUE) " }, 
{ "title" : "Uso ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4586020725065634232302901331", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Interrupción y continuación de movimientos \/ Uso ", 
"snippet" : "Compile el programa creado e inicie sesión. Para realizar un seguimiento de los diferentes estados, puede descargar el seguimiento al controlador. Inicie la aplicación....", 
"body" : "Compile el programa creado e inicie sesión. Para realizar un seguimiento de los diferentes estados, puede descargar el seguimiento al controlador. Inicie la aplicación. " }, 
{ "title" : "Programación de un robot con Pick & Place ", 
"url" : "_sm_example_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Programación de un robot con Pick & Place ", 
"snippet" : "Ver el Robotics_PickAndPlace.project y Robotics_PickAndPlace_without_Depictor.project proyectos de muestra en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . los Robotics_PickAndPlace.project proyecto requiere la CODESYS Depictor Paquete Depictor a instalar. Este ...", 
"body" : "Ver el Robotics_PickAndPlace.project y Robotics_PickAndPlace_without_Depictor.project proyectos de muestra en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . los Robotics_PickAndPlace.project proyecto requiere la CODESYS Depictor Paquete Depictor a instalar. Este proyecto muestra la cinemática en una animación 3D. El proyecto Robotics_PickAndPlace_without_Depictor.project muestra una forma simplificada de la secuencia en una pantalla de visualización. Este capítulo cubre solo los objetos que son relevantes para SoftMotion . El ejemplo consta de un trípode, una mesa giratoria y un transportador. La cinemática recoge un anillo que se encuentra en la mesa giratoria. Al recoger, la placa de herramientas de la cinemática se mueve sincrónicamente con la mesa giratoria. Luego, el anillo se coloca en un cono que se encuentra en una cinta transportadora. Al colocar, la cinemática se mueve sincrónicamente con la cinta transportadora. En la pantalla de visualización hay dos botones para controlar la secuencia. Cuando presiona el Auto botón, los anillos se colocan automáticamente. De lo contrario, el Jugar Aparece el botón para que coloques el anillo. Bloques de funciones: MC_TrackConveyorBelt y MC_TrackRotaryTable El MC_TrackRotaryTable bloque de funciones, que se llama en el Ring bloque de funciones, se utiliza para determinar el PCS_1 sistema de coordenadas parciales. Este sistema de coordenadas se establece cuando se coloca un anillo en la mesa giratoria. El origen del sistema de coordenadas de la mesa giratoria RotaryTableOrigin es el punto medio de la mesa giratoria. El eje Z es el eje giratorio de la mesa giratoria. El PCS_1 gira alrededor del eje Z del sistema de coordenadas de la mesa giratoria en función de la variable de entrada RotaryTable . Dado que el grupo de ejes se mueve en PCS_1, sigue la rotación de la mesa. El comportamiento es similar al MC_TrackConveyorBelt bloque de funciones, que se llama en el Cone bloque de funciones En este caso, el PCS ( PCS_2 ) sigue el eje X del sistema de coordenadas ConveyorBeltOrigin . " }, 
{ "title" : "Estructura del proyecto ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_9645ebb75a1273b0c0a8640e01c9af58", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Programación de un robot con Pick & Place \/ Estructura del proyecto ", 
"snippet" : "CODESYS SoftMotion Controlador Grupo eje Trípode : El grupo de ejes define la cinemática y el mapeo a los ejes individuales Trípode1 , Trípode2 , y Trípode3 . DepictorCalculations (PRG) , Medio ambiente (PRG) , Anillo (FB) : Programas para controlar la secuencia completa y la visualización. Estos PO...", 
"body" : "CODESYS SoftMotion Controlador Grupo eje Trípode : El grupo de ejes define la cinemática y el mapeo a los ejes individuales Trípode1 , Trípode2 , y Trípode3 . DepictorCalculations (PRG) , Medio ambiente (PRG) , Anillo (FB) : Programas para controlar la secuencia completa y la visualización. Estos POU no son relevantes para comprender los bloques PLCopen, excepto la definición del sistema de coordenadas del producto (PCS_1 y PCS_2). Robot (PRG) : Programa para controlar las secuencias de movimiento. Una descripción detallada se encuentra en el siguiente párrafo. Visualización : Visualización animada para aclarar la secuencia. Trípode1 , Trípode2 , Trípode3 : Ejes lineales del trípode. DriveRotaryTable : Eje de la mesa giratoria. DriveConveyorCinturón : Eje para la cinta transportadora. " }, 
{ "title" : "Estructura del programa secuencial del Robot (PRG) ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_d2b72ec95a1273b5c0a8640e012cc527", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Programación de un robot con Pick & Place \/ Estructura del programa secuencial del Robot (PRG) ", 
"snippet" : "los Robot (PRG) El programa se ejecuta en ciclos. En este momento, los pasos individuales se realizan según el state . Al final de un programa, las llamadas de todos los bloques de función utilizados están listas para el comando de movimiento. Se activan los ejes individuales del trípode (bloques de...", 
"body" : "los Robot (PRG) El programa se ejecuta en ciclos. En este momento, los pasos individuales se realizan según el state . Al final de un programa, las llamadas de todos los bloques de función utilizados están listas para el comando de movimiento. Se activan los ejes individuales del trípode (bloques de función pwA1 , pwA2 , y pwA3 de tipo MC_Power ). CASE 0 : Espere a que los ejes participantes estén operativos. CASE 10 : Establece posiciones de inicio; En aplicaciones físicas, el homing se realiza en esta posición (bloques de función spA1 , spA2 , y spA3 de tipo MC_SetPosition ). CASE 20 : Colocación del sistema de coordenadas de la máquina en el sistema de coordenadas mundial (bloque de función setCoord de tipo MC_SetCoordinateTransform ). CASE 30 : Liberación del grupo de ejes (bloque de funciones enable de tipo MC_GroupEnable . Espere una respuesta de que el grupo de ejes ha aplicado todos los valores. CASE 40 para CASE 130 : Aplicación Pick & Place: todos los movimientos se ordenan posiblemente con múltiples instancias MC_MoveDirectAbsolute , MC_MoveDirectRelative , y MC_MoveLinear que se llaman en ciclos. Un borde ascendente en el Execute La entrada de estas POU en cada estado conduce a la emisión de un nuevo comando de movimiento en el que la salida bCommandAccepted indica el éxito del proceso. Una cadena típica de comandos resulta de interrogar esta salida antes del siguiente comando de movimiento. " }, 
{ "title" : "Modelo de robot dinámico ", 
"url" : "_sm_dynamic_robot_model.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Modelo de robot dinámico ", 
"snippet" : "Ver el Robotics_DynamicModel.project proyecto de ejemplo en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . Para limitar los pares\/fuerzas del eje durante un movimiento, se requiere un modelo dinámico que calcule estos valores a partir del estado actual del eje (p...", 
"body" : "Ver el Robotics_DynamicModel.project proyecto de ejemplo en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples . Para limitar los pares\/fuerzas del eje durante un movimiento, se requiere un modelo dinámico que calcule estos valores a partir del estado actual del eje (posición, velocidad y aceleración). Este ejemplo incluye las siguientes partes: La parte 1 muestra cómo utilizar un modelo dinámico existente en una aplicación y los resultados de algunos movimientos de muestra. La parte 2 muestra cómo crear un modelo dinámico para un robot SCARA basado en un algoritmo que se presenta en el libro \"Modern Robotics\" de KM Lynch y FC Park. " }, 
{ "title" : "Estructura de la aplicación ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4640407923376033369958289569", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Modelo de robot dinámico \/ Estructura de la aplicación ", 
"snippet" : "Parte 1: Uso de un modelo dinámico en una aplicación El código para esta parte se encuentra en el TorqueLimitationDemo carpeta. PLC_PRG es el programa principal, que incluye una máquina de estados que desencadena movimientos de prueba. Los movimientos se pueden controlar mediante el Trace . Parte 2:...", 
"body" : "Parte 1: Uso de un modelo dinámico en una aplicación El código para esta parte se encuentra en el TorqueLimitationDemo carpeta. PLC_PRG es el programa principal, que incluye una máquina de estados que desencadena movimientos de prueba. Los movimientos se pueden controlar mediante el Trace . Parte 2: Creación de un modelo de robot dinámico El código para el modelo dinámico se encuentra en el DynModel carpeta. DynModel_Scara2_Z es el modelo dinámico del robot SCARA. DynModel_Tests ejecuta todas las pruebas de Test_DynModel_Scara2_Z para comprobar si hay errores comunes. El modelo dinámico se basa en un robot SCARA con dos articulaciones giratorias y un eje Z prismático. A continuación se muestra una figura del robot con las dimensiones y sistemas de coordenadas requeridos para el modelo dinámico: Dimensión en la figura Nombre de variable correspondiente en el proyecto de muestra en el bloque de funciones DynModel_Scara2_Z h0 baseHeight h1 armOneHeight h2 armTwoHeight h3 zAxisLength h4 zAxisOffset l1 armOneLength l1 armTwoLength " }, 
{ "title" : "Parte 1: Uso de un modelo dinámico en una aplicación ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4592064830952033369979173999", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Modelo de robot dinámico \/ Parte 1: Uso de un modelo dinámico en una aplicación ", 
"snippet" : "El uso de un modelo dinámico en una aplicación requiere un modelo que implemente el ISMDynamics interfaz de la SM3_Dynamics biblioteca. El modelo dinámico de Parte 2: Creación de un modelo de robot dinámico se utiliza para esta demostración. El modelo se puede asignar a un grupo de ejes usando SMC_G...", 
"body" : "El uso de un modelo dinámico en una aplicación requiere un modelo que implemente el ISMDynamics interfaz de la SM3_Dynamics biblioteca. El modelo dinámico de Parte 2: Creación de un modelo de robot dinámico se utiliza para esta demostración. El modelo se puede asignar a un grupo de ejes usando SMC_GroupSetDynamics . Este paso requiere configurar la aceleración gravitacional con respecto al MCS. Debido a que el SCARA en este ejemplo está montado en el piso, la aceleración gravitacional apunta en la dirección z0 positiva. La aceleración gravitatoria debe especificarse en unidades de usuario u\/s². Debido a que todas las longitudes en este ejemplo se han definido en la unidad de usuario m, también se debe especificar la aceleración gravitacional en m\/s². SMC_ChangeDynamicLimits se puede utilizar para ajustar los límites de cada eje. Tenga en cuenta que el grupo de ejes debe habilitarse nuevamente usando MC_GroupEnable para activar los nuevos límites dinámicos. Si se agregan masas adicionales al TCP (por ejemplo, una herramienta o un objeto que es recogido por el robot), entonces SMC_GroupSetLoad se puede utilizar para definir la carga. los PLC_PRG El programa contiene todos los componentes anteriores y ejecuta dos movimientos de prueba: Movimiento 1 Movimiento 2 Movimiento del brazo recto de (a0=0°, a1=0°, a2=0 m) a (a0=90°, a1=0°, a2=0,02 m): Movimiento del brazo en ángulo de (a0=0°, a1=-120°, a2=0 m) a (a0=90°, a1=-120°, a2=0,02 m): Cada movimiento se ejecuta tres veces consecutivas con las siguientes condiciones de contorno: El límite de par de todos los ejes es infinito (ilimitado). El límite de par del Brazo 2 se establece en un valor inferior al par máximo alcanzado durante el movimiento ilimitado. El valor se fijó arbitrariamente en 2 Nm . El límite de torque del brazo 2 todavía está 2 Nm , y además se ha aplicado una carga en el TCP ( mLoad=3 kg , lLoad=0.2 m ): El cálculo de la inercia de la carga se ha simplificado utilizando varillas finas: Los movimientos pueden ser monitoreados en la traza. El movimiento 1 tiene los siguientes resultados: Aunque el Brazo 2 no se mueve durante el Movimiento 1, el movimiento del Brazo 1 genera un par para el Brazo 2 durante la aceleración\/desaceleración. El par calculado se envía al variador y puede mejorar potencialmente el lazo del controlador en el modo de controlador SMC_velocity o SMC_position . Esto también se denomina control de avance de par. La segunda ejecución con par limitado muestra que aunque el Brazo 2 no se mueva, un límite de par para el Brazo 2 ralentiza el movimiento del Brazo 1. Sin el modelo dinámico, la aceleración y la desaceleración del Brazo 1 tendrían que reducirse manualmente para esto. movimiento para evitar una tensión mecánica excesiva en el Brazo 2. La tercera carrera con carga ralentiza aún más el movimiento del Brazo 1 para no violar el límite de torsión del Brazo 2. Las ventajas de usar un modelo dinámico son obvias. Para evitar un estrés mecánico excesivo sin un modelo dinámico: Los límites dinámicos para cada movimiento tendrían que establecerse según el estado actual del robot. O los límites dinámicos de todos los ejes tendrían que reducirse de tal manera que todos los movimientos potenciales no conduzcan a una tensión mecánica excesiva en ningún eje. El primer método es una tarea compleja y puede ser difícil calcular límites razonables, mientras que el segundo método da como resultado movimientos que no son tan rápidos como sea posible la mayor parte del tiempo. Estos inconvenientes ya no existen con un modelo dinámico porque el robot siempre se mueve lo más rápido posible respetando los límites mecánicos de cada eje. Estas ventajas se ilustran con los resultados del Movimiento 2: Debido al brazo 2 en ángulo, el par resultante del brazo 2 es considerablemente más bajo que con el movimiento 1. Por lo tanto, las tres carreras nunca están limitadas por el par del eje. Si se hubieran utilizado límites dinámicos ajustados basados en el Movimiento 1 (aceleración y desaceleración reducidas para no violar el límite de torque del Brazo 2), entonces este movimiento habría sido más lento de lo necesario. " }, 
{ "title" : "Parte 2: Creación de un modelo de robot dinámico ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4583105024958433369980945572", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Modelo de robot dinámico \/ Parte 2: Creación de un modelo de robot dinámico ", 
"snippet" : "El modelo que se crea en este ejemplo se basa en un algoritmo para robots de cadena abierta como se presenta en el libro \"Modern Robotics\" de KM Lynch y FC Park (consulte el Capítulo 8 \"Dinámica de cadenas abiertas\"). La explicación de este algoritmo está más allá del alcance de este ejemplo. En su ...", 
"body" : "El modelo que se crea en este ejemplo se basa en un algoritmo para robots de cadena abierta como se presenta en el libro \"Modern Robotics\" de KM Lynch y FC Park (consulte el Capítulo 8 \"Dinámica de cadenas abiertas\"). La explicación de este algoritmo está más allá del alcance de este ejemplo. En su lugar, el ejemplo se centra en cómo definir los valores de entrada del algoritmo. simplificaciones Para hacer este ejemplo más comprensible, se han hecho algunas simplificaciones: Las longitudes de los brazos l1 y l2 (distancia entre los ejes de rotación) se utilizan como su respectiva longitud total del brazo. El centro de masa siempre está ubicado en el centro geométrico de cada eslabón. Las matrices de inercia espacial de los brazos y el eje Z se calculan para varillas delgadas. Requisitos del modelo dinámico Para utilizar el modelo dinámico en una aplicación SoftMotion, este modelo tiene que implementar el ISMDynamics interfaz de la SM3_Dynamics biblioteca. La posición cero, los sistemas de coordenadas y la dirección de rotación positiva del modelo dinámico teóricamente pueden desviarse del modelo cinemático. Sin embargo, estas diferencias deben tenerse en cuenta y, para simplificar el modelo dinámico, se recomienda utilizar las definiciones del modelo cinemático. Debido a que el modelo dinámico debe calcular los valores de torque en Nm y las fuerzas en N, tiene que convertir la unidad de usuario u para longitudes a unidades SI m. El factor de conversión se puede establecer mediante SMC_GroupSetUnits y está incluido en el addParams entrada de ISMDynamics.AxesStateToTorque . Este ejemplo usa solo m para longitudes y, por lo tanto, puede ignorar el factor de conversión. Especificación de los datos geométricos y dinámicos del modelo. La implementación IEC del algoritmo presentado en el libro \"Modern Robotics\" de KM Lynch y FC Park (consulte el Capítulo 8 \"Dinámica de cadenas abiertas\") requiere los siguientes valores de entrada: La posición del centro de masa de cada enlace cuando el robot está en la posición inicial. La posición se especifica en el sistema de coordenadas del enlace anterior (el primer enlace se especifica en relación con el sistema de coordenadas base). La matriz de inercia espacial y la masa de cada eslabón, expresadas en el marco de eslabón respectivo. El eje del tornillo de cada junta, expresado en el marco base. Posiciones del centro de masa Los cuadros con la posición del centro de masa de cada eslabón son los siguientes: Enlace Cuadro Brazo 1 El centro de masa del Brazo 1, expresado en el sistema de coordenadas base x 0 , y 0 , z 0 : Tenga en cuenta que hay una rotación de 180° alrededor del eje x0. brazo 2 El centro de masa del Brazo 2, expresado en el sistema de coordenadas del Brazo 1: Eje Z El centro de masa del eje Z expresado en el sistema de coordenadas del Brazo 2: Punto central de la herramienta (TCP) Un marco adicional para manejar una carga arbitraria en el TCP (por ejemplo, por una herramienta, un producto o una combinación de ambos), expresada en el sistema de coordenadas del eje Z: Matrices de inercia espacial Los valores de inercia espacial deben expresarse en el marco de enlace respectivo. Dado que los marcos están definidos en el centro de masa, la inercia espacial se puede representar mediante una matriz de inercia rotacional de 3x3 y la masa del cuerpo. Con la simplificación de usar varillas delgadas para las juntas, los componentes de la matriz de inercia rotacional son los siguientes: Enlace Matriz de inercia espacial Brazo 1, Brazo 2 Brazo 1 y Brazo 2 con su masa correspondiente m1 y m2 y longitud l1 y l2 : Eje Z ejes de tornillo Los ejes de los tornillos de todas las uniones deben expresarse en relación con el sistema de coordenadas base x 0 , y 0 , z 0 . Enlace Eje de tornillo Brazo 1 Imagine una plataforma giratoria girando alrededor de la articulación 1 en dirección positiva con una velocidad angular de 1 rad\/s. Expresado en el sistema de coordenadas base, esta es una rotación positiva alrededor de la z 0 -eje según la regla de la mano derecha: Debido a que el eje de rotación del Brazo 1 es igual al centro del sistema de coordenadas base, la velocidad lineal es cero: brazo 2 Nuevamente, imagine una plataforma giratoria girando alrededor de la articulación 2 en dirección positiva con una velocidad angular de 1 rad\/s, que se muestra en la vista superior del brazo 1 en la siguiente figura: En cuanto al Brazo 1, la velocidad angular es: La figura muestra la velocidad lineal resultante v 2 años , que apunta en y negativa 0 dirección y es igual a v 2 años =-ω 2,z * yo 1 . Eje Z El eje Z es un eje prismático para el que se aplican las siguientes reglas: El vector de velocidad angular ω es cero. El vector de velocidad lineal es un vector unitario en la dirección de traslación positiva. Esto conduce a los siguientes vectores, expresados en el sistema de coordenadas base x 0 , y 0 , z 0 : Pruebas Ahora se puede probar el modelo dinámico porque todos los parámetros del modelo están definidos. Esta sección incluye algunas pruebas básicas del modelo. Comprobación de los ejes de los tornillos Un eje de tornillo S con velocidad angular ω y velocidad lineal v puede expresarse como un elemento de se(3) : Una transformación hacia adelante T se puede ejecutar con los ejes de tornillo S , un marco de efector final M para la posición cero del robot y el ángulo de articulación θ de cada articulación: El proyecto de muestra ya incluye una función que resuelve esta ecuación (ver SMC_OpenChainKinematics_SolveForward ). Para más detalles, consulte el libro \"Modern Robotics\" de KM Lynch y FC Park. Usando la ecuación de transformación directa, ahora se puede ejecutar una prueba con posiciones de eje conocidas y verificar si la transformación conduce al resultado esperado. Comprobación del cálculo del par en parada Para verificar los marcos de posición del centro de masa, se puede calcular manualmente el par de eje resultante en reposo para posiciones de eje dadas y compararlos con los valores calculados por el modelo. Dado que este ejemplo se basa en un robot SCARA montado en el suelo, todas las posiciones de los ejes en reposo darán lugar a los mismos pares o fuerzas de los accionamientos: Articulación Par\/fuerza resultante Brazo 1 Como el brazo 1 es un eje de revolución, el resultado es un par: M1=0 Nm . brazo 2 Como el brazo 2 es un eje de revolución, el resultado es un par: M2=0 Nm . Eje Z Como el eje Z es un eje prismático, el resultado es una fuerza: F3=m3*g N con aceleración gravitatoria g . " }, 
{ "title" : "Cinemática personalizada ", 
"url" : "_sm_example_custom_robotics_kinematic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Cinemática personalizada ", 
"snippet" : "Ver el PLCopenSingle2.project proyecto de muestra y el CustomKinematics.library biblioteca en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples. En este ejemplo se describe cómo crear una biblioteca con una transformación cinemática definida por el usuario ( Gantry3C ...", 
"body" : "Ver el PLCopenSingle2.project proyecto de muestra y el CustomKinematics.library biblioteca en el directorio de instalación de CODESYS por debajo ..\\CODESYS SoftMotion\\Examples. En este ejemplo se describe cómo crear una biblioteca con una transformación cinemática definida por el usuario ( Gantry3C ) y cómo usar esta biblioteca en un proyecto para controlar el robot. La transformación cinemática Gantry3C consta de 3 ejes lineales (X, Y y Z) que mueven el cabezal de una herramienta. El cabezal de la herramienta se compone de un eje adicional y de una herramienta montada en él. El cabezal de la herramienta se puede girar alrededor del eje Z. " }, 
{ "title" : "1. Crea un nuevo proyecto de biblioteca. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3b0657d06b6990f1c0a8646379b25f1e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Cinemática personalizada \/ 1. Crea un nuevo proyecto de biblioteca. ", 
"snippet" : "Cree un nuevo proyecto con el Biblioteca vacía plantilla....", 
"body" : "Cree un nuevo proyecto con el Biblioteca vacía plantilla. " }, 
{ "title" : "2. Agregue un administrador de biblioteca. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_0125d98b6b6990f1c0a8646339c29917", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Cinemática personalizada \/ 2. Agregue un administrador de biblioteca. ", 
"snippet" : "Agregar un administrador de biblioteca al POU vista. Añade el SM3_Transformation , SM3_Math , y SM3_Error bibliotecas al administrador de bibliotecas....", 
"body" : "Agregar un administrador de biblioteca al POU vista. Añade el SM3_Transformation , SM3_Math , y SM3_Error bibliotecas al administrador de bibliotecas. " }, 
{ "title" : "3. Cree el bloque de funciones Gantry3C. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_b156dbec6b6990f1c0a86463322b661a", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Cinemática personalizada \/ 3. Cree el bloque de funciones Gantry3C. ", 
"snippet" : "Este bloque de funciones implementa las interfaces MC_KIN_REF_SM3 y ISMKinematicsWithInfo2 de la biblioteca SM3_Transformation . Puede definir un desplazamiento como entrada para cada eje. Este desplazamiento se resta antes de la transformación hacia adelante y se suma después de la transformación i...", 
"body" : "Este bloque de funciones implementa las interfaces MC_KIN_REF_SM3 y ISMKinematicsWithInfo2 de la biblioteca SM3_Transformation . Puede definir un desplazamiento como entrada para cada eje. Este desplazamiento se resta antes de la transformación hacia adelante y se suma después de la transformación inversa. Ejemplo de Gantry3C con dos cinemáticas desacopladas y KinCoupled : FUNCTION_BLOCK Custom_Kin_Gantry3 IMPLEMENTS ISMPositionKinematics\nFUNCTION_BLOCK Custom_Kin_CAxis IMPLEMENTS ISMOrientationKinematics\n\nFUNCTION_BLOCK Custom_Kin_Gantry3C EXTENDS Kin_Coupled Proporcionar los bloques de funciones Custom_Kin_Gantry3 y Custom_Kin_CAxis como entradas para el bloque de funciones Kin_Coupled durante la inicialización. Ahora Custom_Kin_Gantry3C se convierte en una cinemática acoplada que combina la cinemática de posición y orientación. " }, 
{ "title" : "4. Implementar los métodos de la interfaz MC_KIN_REF_SM3 y la propiedad NumAxes4. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_f0953a666b6990f1c0a864632a54ddd5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Cinemática personalizada \/ 4. Implementar los métodos de la interfaz MC_KIN_REF_SM3 y la propiedad NumAxes4. ", 
"snippet" : "AxesToCartesian : Cinemática hacia adelante: Cálculo de la posición y orientación a partir de los valores del eje. CartesianToAxes : Cinemática inversa: Cálculo de los valores de los ejes a partir de la posición y la orientación. NumAxes : Número de ejes de la cinemática...", 
"body" : "AxesToCartesian : Cinemática hacia adelante: Cálculo de la posición y orientación a partir de los valores del eje. CartesianToAxes : Cinemática inversa: Cálculo de los valores de los ejes a partir de la posición y la orientación. NumAxes : Número de ejes de la cinemática " }, 
{ "title" : "5. Implementar los métodos de las interfaces ISMKinematicsWithInfo2 e ISMKinematicsWithInfo. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_cd5f17f76b6990f1c0a86463705dcfa1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Cinemática personalizada \/ 5. Implementar los métodos de las interfaces ISMKinematicsWithInfo2 e ISMKinematicsWithInfo. ", 
"snippet" : "GetAxisProperties : Propiedades, como el tipo de eje. Se pueden definir los límites para cada eje. GetKinematicsName : Nombre de la cinemática IsSingularity : Puede ignorarse para esta cinemática....", 
"body" : "GetAxisProperties : Propiedades, como el tipo de eje. Se pueden definir los límites para cada eje. GetKinematicsName : Nombre de la cinemática IsSingularity : Puede ignorarse para esta cinemática. " }, 
{ "title" : "6. Especifique la información del proyecto. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_2f5ca72b6b6990f1c0a864634f9c8dd7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Cinemática personalizada \/ 6. Especifique la información del proyecto. ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "7. Consulte la biblioteca para ver si hay errores del compilador. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_24eaad936b6990f1c0a864633896924b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Cinemática personalizada \/ 7. Consulte la biblioteca para ver si hay errores del compilador. ", 
"snippet" : "Para consultar la biblioteca, haga clic Construir → Verifique todos los objetos de la piscina ....", 
"body" : "Para consultar la biblioteca, haga clic Construir → Verifique todos los objetos de la piscina . " }, 
{ "title" : "8. Cree la descripción en el configurador de grupos de ejes. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_51fd948a6c11885ac0a8646354b16b84", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Cinemática personalizada \/ 8. Cree la descripción en el configurador de grupos de ejes. ", 
"snippet" : "Para crear la descripción, primero tiene que instalar CODESYS Library Documentation Support complemento. Este complemento contiene el programa libdoc.exe, que se requiere en las instrucciones siguientes El complemento se puede instalar a través de CODESYS Installer . Cuando la POU tiene el atributo ...", 
"body" : "Para crear la descripción, primero tiene que instalar CODESYS Library Documentation Support complemento. Este complemento contiene el programa libdoc.exe, que se requiere en las instrucciones siguientes El complemento se puede instalar a través de CODESYS Installer . Cuando la POU tiene el atributo sm_kin_libdoc , el comentario especificado en el bloque de funciones se utiliza en el configurador de grupos de ejes como descripción de la cinemática. Para ello, se utiliza formato de texto reestructurado. Para generar la descripción de la cinemática a partir de los comentarios del bloque de función en el editor de grupos de ejes, siga estos pasos: Incluir el atributo sm_kin_libdoc como se muestra en la imagen de arriba. Incluya las propiedades requeridas del proyecto DocFormat y DocLanguages (en el cuadro de diálogo de información del proyecto) relacionado con la documentación de la biblioteca. Resultado: Asegúrese de que el directorio de instalación de CODESYS contiene la libdoc.exe archivo ejecutable (directorio: ...\\DocScripting\\3.5.xx.0 \\). Descargue el convertidor wkhtmltox de 32 bits con la versión 0.12.5 o inferior de https:\/\/wkhtmltopdf.org\/downloads.html . Extrae el wkhtmltox.dll archivar y copiar a ...\\DocScripting\\3.5.xx.0\\\\bin en el CODESYS directorio de instalación. Ya que wkhtmltox.dll ya no admite imágenes de forma predeterminada en la versión 0.12.6 y superior, debe utilizar la versión 0.12.5 o inferior. Crea la variable del sistema LIBDOC_CODESYS en Windows. Establezca el valor en la ruta del archivo de CODESYS.exe . Asegúrese de especificar el nombre de la ruta y el nombre del perfil entre comillas dobles. Resultado: Guarde, cierre y vuelva a abrir el proyecto de biblioteca. Hacer clic Archivo → Guardar proyecto como biblioteca compilada . La biblioteca compilada se instalará en el proyecto que utiliza esta cinemática. " }, 
{ "title" : "Usar la biblioteca en un proyecto (CustomKinematics_Implementation.project) ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3c747e2a6b6990f1c0a864637a72fb84", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Cinemática personalizada \/ Usar la biblioteca en un proyecto (CustomKinematics_Implementation.project) ", 
"snippet" : "El proyecto demuestra cómo usar y controlar la cinemática creada en la sección anterior haciendo jogging o al mando de un movimiento. Crear un CODESYS proyecto estándar con el CODESYS SoftMotion Win controlador. Abra el Administrador de bibliotecas e instale la biblioteca CustomKinematics.compiled-l...", 
"body" : "El proyecto demuestra cómo usar y controlar la cinemática creada en la sección anterior haciendo jogging o al mando de un movimiento. Crear un CODESYS proyecto estándar con el CODESYS SoftMotion Win controlador. Abra el Administrador de bibliotecas e instale la biblioteca CustomKinematics.compiled-library (creado en la sección anterior) que contiene la cinemática Gantry3C. Agregue la biblioteca al Administrador de bibliotecas. Agregue un objeto de grupo de ejes y seleccione el KinCustom.Gantry3C cinemática. Resultado: Agregue 4 ejes virtuales al Piscina SoftMotion General Axis grupo de ejes en el árbol de dispositivos. (DriveX, Y, Z y C) Abra el configurador de grupos de ejes. En el Asignación a ejes sección, mapee los ejes a sus respectivos campos. Resultado: El programa Prg_Visu es el programa principal que controla el grupo de ejes. Cuando se inicia la aplicación, Prg_Visu enciende el grupo de ejes y lo habilita. Además, llama a todos los bloques de función necesarios para controlar el grupo de ejes (jogging, lineales y movimientos PTP). Todos estos movimientos se pueden controlar desde la visualización adjunta. Resultado: Bloque de funciones: Jog : Este FB combina jogging en el espacio de ejes y en el espacio cartesiano. Utiliza dos instancias de SMC_GroupJog2 . Uno es para el espacio de ejes y el otro es para el espacio cartesiano. Este bloque de funciones se puede utilizar con las plantillas de visualización. V_RobotPosition_ejes y V_RobotPosition_cart_Jog para activar cualquier cinemática en el espacio cartesiano y de ejes. Resultado: FB SMC_TRAFOF_Gantry3C : Este bloque de funciones transforma los valores del eje de entrada de una cinemática Gantry3C en sus respectivos valores de TCP. Además, los valores de los ejes se normalizan para que se puedan utilizar con la plantilla de visualización. TRAFOF_Gantry3C_YZ visualizar los movimientos de la cinemática. Resultado: Compila y ejecuta la aplicación. Abra la visualización. Puede mover el robot en el espacio del eje así como en el espacio cartesiano. También hay plantillas de visualización para controlar un movimiento lineal o PTP. Resultado: El ejemplo que se describe aquí analiza los ejes de posicionamiento y orientación en un bloque de función común. Muchas cinemáticas pueden comprender dos cinemáticas parciales desacopladas: una cinemática de posicionamiento (delta, pórtico, etc.) y una cinemática de orientación (herramientas como el eje C, Wrist2, Wrist3, etc.). Ambas cinemáticas están conectadas entre sí en el \"punto de brida\", el TCP de la cinemática de posicionamiento. La cinemática de orientación se caracteriza por el hecho de que es capaz de calcular el vector desde el punto de brida hasta el TCP de la cinemática acoplada. El cálculo se realiza utilizando solo la orientación de este TCP (lo que significa que es independiente de la cinemática de posicionamiento o independiente de la orientación del punto de brida). La cinemática de posicionamiento, a su vez, debe poder determinar las posiciones de sus ejes únicamente a partir de la posición del punto de brida. No debe depender de la orientación del punto de la brida. En este caso, puede recurrir a interfaces como ISMPositionKinematics o ISMOrientationKinematics . Para implementar estas interfaces, defina un bloque de funciones para implementar ISMPositionKinematics y otro bloque de funciones para implementar ISMOrientationKinematics . Finalmente, defina un bloque de funciones que extienda el bloque de funciones. Kin_Coupled (de SM3_Transformation ) con los bloques de funciones previamente definidos como entradas. Para más información, ver: Creación de cinemáticas personalizadas" }, 
{ "title" : "Uso de Depictor para visualizar grupos de ejes ", 
"url" : "_sm_example_axis_group_depictor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Uso de Depictor para visualizar grupos de ejes ", 
"snippet" : "Para este proyecto, también necesita el CODESYS Depictor complemento con una licencia válida. La aplicación SoftMotion consta de cuatro accionamientos giratorios configurados como un grupo de ejes. Los primeros tres ejes mueven el TCP en el plano X \/ Y y el cuarto eje en el plano Z. El ejemplo demue...", 
"body" : "Para este proyecto, también necesita el CODESYS Depictor complemento con una licencia válida. La aplicación SoftMotion consta de cuatro accionamientos giratorios configurados como un grupo de ejes. Los primeros tres ejes mueven el TCP en el plano X \/ Y y el cuarto eje en el plano Z. El ejemplo demuestra cómo se puede utilizar Depictor con la configuración cinemática Kin_Scara3_Z. También puede personalizar el mismo procedimiento para otras configuraciones cinemáticas. Iniciar y probar el programa Puede modificar los valores de los ejes en la visualización del proyecto. Si comenta el comando de movimiento activo ( MoveAbs... , ...) en el programa PLC_PRG y elimine los comentarios del segundo comando de movimiento, luego puede modificar las coordenadas cartesianas. Construya el proyecto y descárguelo al PLC. Abra el editor del objeto Depictor en su proyecto. Cambie a la visualización y modifique los valores del eje o los valores cartesianos. Observe el movimiento del robot SCARA en Depictor. " }, 
{ "title" : "Creando el proyecto estándar ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a87f67372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Uso de Depictor para visualizar grupos de ejes \/ Creando el proyecto estándar ", 
"snippet" : "Cree un proyecto estándar con el CODESYS SoftMotion Win controlador y el lenguaje de programación ST. Agregue un administrador de biblioteca en el POU vista. Abra el Administrador de bibliotecas y agregue las bibliotecas SM3_Depictor y DepictorBase ....", 
"body" : "Cree un proyecto estándar con el CODESYS SoftMotion Win controlador y el lenguaje de programación ST. Agregue un administrador de biblioteca en el POU vista. Abra el Administrador de bibliotecas y agregue las bibliotecas SM3_Depictor y DepictorBase . " }, 
{ "title" : "Añadiendo y parametrizando los ejes ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a65c81372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Uso de Depictor para visualizar grupos de ejes \/ Añadiendo y parametrizando los ejes ", 
"snippet" : "Inserte cuatro ejes virtuales debajo del objeto Piscina SoftMotion General Axis y nombre los ejes como Drive1 ... Drive4. Parametrizar los ejes Drive1, Drive2, Drive3 y Drive4 como tipo de eje finito con interruptores finales de software de -180 grados a 180 grados. Editor de configuración: Para más...", 
"body" : "Inserte cuatro ejes virtuales debajo del objeto Piscina SoftMotion General Axis y nombre los ejes como Drive1 ... Drive4. Parametrizar los ejes Drive1, Drive2, Drive3 y Drive4 como tipo de eje finito con interruptores finales de software de -180 grados a 180 grados. Editor de configuración: Para más información, ver: unidad virtual" }, 
{ "title" : "Configurar los grupos de ejes ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5e750372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Uso de Depictor para visualizar grupos de ejes \/ Configurar los grupos de ejes ", 
"snippet" : "Agregue un grupo de ejes \"KinScara\" debajo de la aplicación. Para hacer esto, haga clic en Proyecto → Agregar objeto → Grupo de ejes . En el configurador, haga clic en Seleccionar cinemática . Selecciona el TRAFO.Kin_Scara3_Z cinemática. Defina los parámetros de la siguiente manera: dArmLength1 , dA...", 
"body" : "Agregue un grupo de ejes \"KinScara\" debajo de la aplicación. Para hacer esto, haga clic en Proyecto → Agregar objeto → Grupo de ejes . En el configurador, haga clic en Seleccionar cinemática . Selecciona el TRAFO.Kin_Scara3_Z cinemática. Defina los parámetros de la siguiente manera: dArmLength1 , dArmLength2 , dArmLength3 : 500 dOffsetA1 , dOffsetA2 , dOffsetA3 , dOffsetZ : 0 Ordene los ejes de la siguiente manera: A1 : Drive1 A2 : Drive2 A3 : Drive3 Z : Drive4 Nota: Puede arrastrar los ejes directamente al campo de entrada. Para más información, ver: Cinemática" }, 
{ "title" : "Creando el programa del controlador ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_26c321018be5c522c0a864636ae45467", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Uso de Depictor para visualizar grupos de ejes \/ Creando el programa del controlador ", 
"snippet" : "En el PLC_PRG programa, declare instancias del MC_Power bloque de funciones para todas las unidades. Crear un istate variable para el diagrama de estado. VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power; istate: INT; END_VAR Defina un diagrama de estado en la implementación. CAS...", 
"body" : "En el PLC_PRG programa, declare instancias del MC_Power bloque de funciones para todas las unidades. Crear un istate variable para el diagrama de estado. VAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power;\n istate: INT;\nEND_VAR Defina un diagrama de estado en la implementación. CASE istate OF\n 0:\n 1:\n 2:\nEND_CASE Activar todas las unidades en estado 0 . 0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF Cuando los ejes están activados, habilite el grupo de ejes (cambie de \"desactivado\" a \"standby\"). VAR\n GroupEnable:MC_GroupEnable;\nEND_VAR\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF Declare e inicialice una variable para guardar el valor establecido en coordenadas de máquina. Declare dos instancias de tipo SMC_POS_REF para representar el TCP en coordenadas cartesianas y de eje. VAR\n Frame: MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart: SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis: SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\nEND_VAR\nVAR CONSTANT\n axispos: TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR\n\n2:\n Pos_Cart.c:= Frame; \/\/ To represent the TCP in cartesian coordinates; Declare una instancia de MC_MoveDirectAbsolute para mover el robot SCARA a las coordenadas especificadas. VAR\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates\nEND_VAR\n\n2:\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined Axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF Declarar una variable de tipo SMC_GroupReadSetPosition para leer el valor actual del robot en coordenadas cartesianas y coordenadas de eje. VAR\n Car_pos, Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current axis values\nEND_VAR\n\n2:\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ to read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ to read the current axis values " }, 
{ "title" : "Todo el programa PLC_PRG ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5721f372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Uso de Depictor para visualizar grupos de ejes \/ Todo el programa PLC_PRG ", 
"snippet" : "Compare su programa y agregue las partes del programa que faltan. Declaración PROGRAM PLC_PRG VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power; istate: INT; GroupEnable:MC_GroupEnable; Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orienta...", 
"body" : "Compare su programa y agregue las partes del programa que faltan. Declaración PROGRAM PLC_PRG\nVAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power;\n istate: INT;\n\n GroupEnable:MC_GroupEnable;\n\n Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart:SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis:SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\n\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates (PTP)\n\n Car_pos,Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current position of the TCP in Cartesian and Axis Coordinates and display it on the visu\n\n scara_Config:trafo.Kin_Scara3_Z_Config; \/\/ To set the configuration of the SCARA_3_Z\n kin_Config:SMC_SetKinConfiguration; \/\/ To set the defined configuration of SCARA_3_Z to the axis group used\n nPeriod:DINT:=0; \/\/ SCARA_3_Z Period\n Xelbow:BOOL:=TRUE;\n\nEND_VAR\nVAR CONSTANT\n axispos : TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR Implementación CASE istate OF\n\n0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF\n\n2:\n scara_Config(xElbowRight:=Xelbow, nPeriodA3:=nPeriod);\n kin_Config(AxisGroup:=KinScara,ConfigData:=scara_Config.Config, Execute:=TRUE);\n Pos_Cart.c:=Frame; \/\/ To represent the TCP in cartesian coordinates\n\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ read the current position in Axis coordinates\n\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF\nEND_CASE " }, 
{ "title" : "Creación de un programa de representación ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_8f044cf9373811e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Uso de Depictor para visualizar grupos de ejes \/ Creación de un programa de representación ", 
"snippet" : "Agregue un nuevo POU \"Representación\" del tipo \"Programa\" debajo de la aplicación. Para hacer esto, haga clic en Proyecto → Agregar objeto → POU . Declarar una variable de tipo SM3_Depictor.SMC_R_Scara3_Z_Data . Declarar una variable LrSize de tipo LREAL e inicializar la variable con el valor de 100...", 
"body" : "Agregue un nuevo POU \"Representación\" del tipo \"Programa\" debajo de la aplicación. Para hacer esto, haga clic en Proyecto → Agregar objeto → POU . Declarar una variable de tipo SM3_Depictor.SMC_R_Scara3_Z_Data . Declarar una variable LrSize de tipo LREAL e inicializar la variable con el valor de 100. VAR\n ScaraTrafo : SM3_Depictor.SMC_R_Scara3_Z_Data;\n LrSize:LREAL:=100;\nEND_VAR Inserte una llamada al bloque de funciones en la implementación. ScaraTrafo(AxisGroup:=KinScara, trf:=KinScara.trafo); Agrega el POU \"Representación\" al Tarea principal . " }, 
{ "title" : "Configuración de Depictor ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a523fe372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Uso de Depictor para visualizar grupos de ejes \/ Configuración de Depictor ", 
"snippet" : "Agrega un objeto \"Representante\" debajo de la aplicación. Para hacer esto, haga clic en Proyecto → Agregar objeto → Representante . Haz doble clic en el objeto. Selecciona el Pose elemento en el árbol de Depictor. Hacer clic Representante → Agregar elemento . los Caja El elemento se agrega debajo de...", 
"body" : "Agrega un objeto \"Representante\" debajo de la aplicación. Para hacer esto, haga clic en Proyecto → Agregar objeto → Representante . Haz doble clic en el objeto. Selecciona el Pose elemento en el árbol de Depictor. Hacer clic Representante → Agregar elemento . los Caja El elemento se agrega debajo de la pose. Selecciona el Representante Ref. opción en las propiedades del elemento. Haga clic en el botón. Selecciona el SMC_R_Depictor_Scara3_Z objeto del SM3_Depictor Biblioteca. Defina las variables de la interfaz de la siguiente manera: pensión completa : Representante.ScaraTrafo lrZ_ : Drive1.fSetPosition lrZmin : 10 lrZmax : -50 lrSize : Depic.LrSize xShowPlane : 0 " }, 
{ "title" : "Creando visualizaciones ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a460ad372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Uso de Depictor para visualizar grupos de ejes \/ Creando visualizaciones ", 
"snippet" : "Cree una pantalla de visualización en la que se puedan visualizar y modificar las coordenadas cartesianas y las coordenadas del eje. Agregue un objeto \"Visualización\" debajo de la aplicación. Para hacer esto, haga clic en Proyecto → Agregar objeto → Visualización . Abra la visualización en el editor...", 
"body" : "Cree una pantalla de visualización en la que se puedan visualizar y modificar las coordenadas cartesianas y las coordenadas del eje. Agregue un objeto \"Visualización\" debajo de la aplicación. Para hacer esto, haga clic en Proyecto → Agregar objeto → Visualización . Abra la visualización en el editor. Insertar un Rectángulo elemento de visualización (1). Cambia las propiedades del elemento. Textos → Texto : %s Variables de texto → Variable de texto : PLC_PRG.Car_pos.Position.c.X Configuración de entrada → OnMouseDown → Escribir variable Tipo de entrada : VisuDialogs.Numpad Usa otra variable : PLC_PRG.Frame.X Inserta el otro Caja elementos de visualización. Cambie las propiedades de los elementos (2) y (3). Textos → Texto : %s Variables de texto → Variable de texto : PLC_PRG.Car_pos.Position.c.Y o PLC_PRG.Car_pos.Position.c.Z Configuración de entrada → OnMouseDown → Escribir variable Tipo de entrada : VisuDialogs.Numpad Usa otra variable : PLC_PRG.Frame.Y y PLC_PRG.Frame.Z Cambie las propiedades de los elementos (4), (5) y (6). Textos → Texto : %s Variables de texto → Variable de texto : PLC_PRG.Frame.A o PLC_PRG.Frame.B o PLC_PRG.Frame.C Cambie las propiedades de los elementos (7), (8), (9) y (10). Textos → Texto : %s Variables de texto → Variable de texto : PLC_PRG.Axis_pos.Position.a.a0 o PLC_PRG.Axis_pos.Position.a.a1 o PLC_PRG.Axis_pos.Position.a.a2 o PLC_PRG.Axis_pos.Position.a.a3 Configuración de entrada → OnMouseDown → Escribir variable Tipo de entrada : VisuDialogs.Numpad Usa otra variable : PLC_PRG.Pos_Axis.a.a0 y PLC_PRG.Pos_Axis.a.a1 y PLC_PRG.Pos_Axis.a.a2 y PLC_PRG.Pos_Axis.a.a3 Etiquete los elementos de visualización con el Etiqueta elemento. " }, 
{ "title" : "Activador Ejemplo 1: Ejemplo simple ", 
"url" : "_sm_example_digital_switches1.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Activador Ejemplo 1: Ejemplo simple ", 
"snippet" : "El Robotics_Trigger.project El proyecto de ejemplo descrito aquí se encuentra en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Los disparadores se utilizan para averiguar exactamente cuándo un grupo de ejes llega a un punto específico en la ruta comandada. Esta inform...", 
"body" : "El Robotics_Trigger.project El proyecto de ejemplo descrito aquí se encuentra en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Los disparadores se utilizan para averiguar exactamente cuándo un grupo de ejes llega a un punto específico en la ruta comandada. Esta información se puede utilizar, por ejemplo, para encender o apagar una herramienta exactamente en el momento adecuado. Este ejemplo muestra cómo se ordena un solo disparador en un movimiento y luego se lee cíclicamente. Con base en esto, el Activador Ejemplo 2: Proceso de encolado El proyecto muestra una aplicación de muestra realista. " }, 
{ "title" : "Estructura de la aplicación ", 
"url" : "_sm_example_digital_switches1.html#UUID-69fc12d0-622f-ba4d-33ec-32604b337f95_section-idm4609369968113633803655575311", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Activador Ejemplo 1: Ejemplo simple \/ Estructura de la aplicación ", 
"snippet" : "La aplicación consta de dos programas: un Main_PRG correr en la tarea del autobús y un Planning_PRG ejecutándose en la tarea de planificación del grupo de ejes. Además, también hay un rastro. PRG_principal : El Main_PRG El programa contiene la máquina de estado principal de la aplicación. Los primer...", 
"body" : "La aplicación consta de dos programas: un Main_PRG correr en la tarea del autobús y un Planning_PRG ejecutándose en la tarea de planificación del grupo de ejes. Además, también hay un rastro. PRG_principal : El Main_PRG El programa contiene la máquina de estado principal de la aplicación. Los primeros dos estados se utilizan para inicializar y encender los variadores y el grupo de ejes. En el STATE_COMMAND_MOVEMENT_WITH_TRIGGER estado, primero se prepara un disparador usando una instancia del SMC_GroupPrepareTrigger bloque de funciones La posición se especifica relativamente con un valor de 0,6. Como resultado, el gatillo se coloca en el punto donde se completa el 60% del movimiento asignado. El gatillo preparado se asigna al siguiente movimiento ordenado. En este ejemplo, un movimiento lineal a la posición (X=20, Y=10) es comandado por un MC_MoveLinearAbsolute . prepTrigger.PositionType := SMC_TriggerPositionType.MvtRelative;\nprepTrigger.Position.MvtPosition := 0.6;\nprepTrigger(AxisGroup:= AxisGroup, Execute:= TRUE);\n \nmoveLinear(AxisGroup:= AxisGroup, Execute:= prepTrigger.Prepared); en el siguiente estado STATE_ENABLE_READ_TRIGGER , una instancia de SMC_GroupReadTrigger se inicia para leer el estado del disparador comandado. El vínculo con el activador se establece mediante el TriggerId devuelto por SMC_GroupPrepareTrigger . readTrigger.TriggerId := prepTrigger.TriggerId;\nreadTrigger.Enable := TRUE; En el STATE_CHECK_TRIGGER state, finalmente se comprueba cíclicamente el estado del disparador. Tan pronto como SMC_GroupReadTrigger informes Active como estado, se puede leer la duración hasta que se alcanza el disparador. La duración siempre se refiere al inicio del ciclo actual. Por lo tanto, el disparo se alcanza en el ciclo actual si la duración es menor que el tiempo del ciclo (en este ejemplo, 0,004 s): IF readTrigger.TriggerInfo.status = SMC_TRIGGER_STATUS.Active THEN\n IF readTrigger.TriggerInfo.triggerTime <= 0.004 THEN\n triggerFired := TRUE;\n ...\n END_IF\nEND_IF Planificación_PRG En el Planning_PRG programa, la duración prevista de la planificación se configura mediante el SMC_TuneCPKernel bloque de funciones El SMC_GroupReadTrigger El bloque de funciones puede generar una salida cuando se alcanza la duración prevista de un disparador. En el ejemplo, la duración de la previsión se establece en 0,1 s. Por lo tanto, el estado de la SMC_GroupReadTrigger Cambios en el bloque de funciones a Active 0,1 s antes de que el grupo de ejes alcance el disparador y emita una duración válida a partir de ese momento. tuneCpKernel(AxisGroup:= axisGroup, Execute:= TRUE, fPlanningForecastDuration:= 0.1); Rastro La traza se puede utilizar para rastrear el comportamiento del SMC_GroupReadTrigger bloque de funciones En el primer diagrama se puede ver que se ejecuta un movimiento desde (X=0, Y=0) hasta (X=20, Y=10). El gatillo se encuentra en la posición relativa 0,6 del movimiento, es decir, en (X=12, Y=6). El segundo diagrama muestra el valor de la triggerTime salida de SMC_GroupReadTrigger . El valor salta a 0,1 s porque la duración prevista de la planificación es de 0,1 s y luego cae linealmente hasta que se alcanza el valor 0 en la posición (X=12, Y=6). El tercer diagrama muestra el valor de la triggerFired variable que se establece en el STATE_CHECK_TRIGGER estado de Main_PRG tan pronto como el grupo de ejes esté a menos de 0,004 s del disparador. " }, 
{ "title" : "Activador Ejemplo 2: Proceso de encolado ", 
"url" : "_sm_example_digital_switches2.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Activador Ejemplo 2: Proceso de encolado ", 
"snippet" : "El Robotics_Trigger_Advanced.project El proyecto de ejemplo descrito aquí se encuentra en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Los activadores se pueden utilizar para realizar acciones en posiciones específicas de la ruta, como encender y apagar una boquilla ...", 
"body" : "El Robotics_Trigger_Advanced.project El proyecto de ejemplo descrito aquí se encuentra en el directorio de instalación de CODESYS bajo ..\\CODESYS SoftMotion\\Examples . Los activadores se pueden utilizar para realizar acciones en posiciones específicas de la ruta, como encender y apagar una boquilla de encolado. Este ejemplo incluye los siguientes componentes: La configuración de una previsión garantizada de la trayectoria por parte del fPlanningForecastDuration parámetro de la SMC_TuneCPKernel bloque de funciones El comando de diferentes disparadores. Aquí, se utilizan los tres métodos disponibles para definir la posición de la ruta (ver SMC_TriggerPositionType ). El uso de disparadores con cambio de tiempo. La aplicación de ejemplo contiene el TriggerWithTimeShift bloque de función, que puede reaccionar al alcanzar la posición de la ruta con un desfase de tiempo (anterior y posterior). Estos componentes se muestran en una aplicación de muestra para un proceso de encolado. Se ejecuta (con blending) el movimiento que se muestra en rojo en la siguiente imagen. Los activadores se han definido en las posiciones marcadas en verde: Posición 1: Encienda el dispositivo de encolado 0,05 s antes de llegar a la posición. Posición 1: Encienda la lámpara UV cuando se alcance la posición. Posición 2: llene el contenedor de suministro de pegamento cuando se alcance la posición. Posición 3: Apague el dispositivo de encolado y deje de llenar el contenedor de suministro de pegamento 0,05 s antes de llegar a la posición. Posición 3: Apague la lámpara UV 1,5 s después de llegar a la posición " }, 
{ "title" : "Estructura de la aplicación ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4589008317470433803801762921", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Activador Ejemplo 2: Proceso de encolado \/ Estructura de la aplicación ", 
"snippet" : "La aplicación consta de las siguientes partes. GlueApplication : Este programa contiene la aplicación de muestra que muestra cómo usar los disparadores para un proceso de encolado. Planning_PRG : En este programa se configura una previsión de la trayectoria. TriggerWithTimeShift : Este bloque de fun...", 
"body" : "La aplicación consta de las siguientes partes. GlueApplication : Este programa contiene la aplicación de muestra que muestra cómo usar los disparadores para un proceso de encolado. Planning_PRG : En este programa se configura una previsión de la trayectoria. TriggerWithTimeShift : Este bloque de funciones contiene la lógica para disparadores con un cambio de tiempo y se utiliza en el GlueApplication programa de muestra Trace : La traza muestra la dinámica de los ejes y también las salidas de los GlueApplication programa que son conmutados por los activadores. " }, 
{ "title" : "Configuración de un pronóstico ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4570491496867233803803206327", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Activador Ejemplo 2: Proceso de encolado \/ Configuración de un pronóstico ", 
"snippet" : "Si desea reaccionar antes de que se alcance un disparo, por ejemplo, 0,05 s antes, entonces el fPlanningForecastDuration parámetro del SMC_ SMC_TuneCPKernel el bloque de funciones debe ajustarse al menos a 0,05 s. Debido a que el parámetro tiene un impacto directo en la latencia, su valor no debe se...", 
"body" : "Si desea reaccionar antes de que se alcance un disparo, por ejemplo, 0,05 s antes, entonces el fPlanningForecastDuration parámetro del SMC_ SMC_TuneCPKernel el bloque de funciones debe ajustarse al menos a 0,05 s. Debido a que el parámetro tiene un impacto directo en la latencia, su valor no debe ser mayor de lo necesario (consulte la documentación de fPlanificaciónPronósticoDuración ). Tenga en cuenta que SMC_TuneCPKernel tiene que ser llamado en el SoftMotion tarea de planificación. Por este motivo, la configuración no se ejecuta en el programa principal. GlueApplication , pero en el Planning_PRG programa. En esta aplicación de ejemplo, se requiere la evaluación del disparador como mínimo 0,05 s antes de que se alcance una posición. Por esta razón, el parámetro fPlanningForecastDuration =0.05 se establece en el Planning_PRG programa. " }, 
{ "title" : "Bloque de funciones: TriggerWithTimeShift ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4609369977958433803803968971", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Activador Ejemplo 2: Proceso de encolado \/ Bloque de funciones: TriggerWithTimeShift ", 
"snippet" : "El TriggerWithTimeShift El bloque de funciones proporciona una interfaz simplificada para usar disparadores. Además, se puede definir un cambio de tiempo para que el disparador pueda reaccionar antes de que se alcance una posición (valor positivo) así como después de que se alcance una posición (val...", 
"body" : "El TriggerWithTimeShift El bloque de funciones proporciona una interfaz simplificada para usar disparadores. Además, se puede definir un cambio de tiempo para que el disparador pueda reaccionar antes de que se alcance una posición (valor positivo) así como después de que se alcance una posición (valor negativo). Dependiendo de la precisión de tiempo requerida en una aplicación, la reacción al alcanzar un disparador puede ser la siguiente: Precisión de tiempo requerida >= ciclo de tarea de bus: En este caso, el TriggerWithTimeShift.TriggerReachedThisCycle Se puede utilizar la salida. Precisión de tiempo requerida < ciclo de tarea de bus: en este caso, el tiempo restante exacto TriggerWithTimeShift.TriggerTime hasta que se alcance el gatillo se puede utilizar. Internamente, TriggerWithTimeShift usa el SMC_GroupPrepareTrigger y SMC_GroupReadTrigger bloques de funciones " }, 
{ "title" : "Disparadores de mando ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4608844104630433803805051855", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Activador Ejemplo 2: Proceso de encolado \/ Disparadores de mando ", 
"snippet" : "En el GlueApplication programa, se comandan los movimientos y disparadores. El orden de llamada es particularmente importante para los disparadores porque los disparadores preparados usando SMC_GroupPrepareTrigger se asignan al siguiente movimiento comandado en el mismo ciclo. Por lo tanto, en cada ...", 
"body" : "En el GlueApplication programa, se comandan los movimientos y disparadores. El orden de llamada es particularmente importante para los disparadores porque los disparadores preparados usando SMC_GroupPrepareTrigger se asignan al siguiente movimiento comandado en el mismo ciclo. Por lo tanto, en cada aplicación debe prestar atención a lo siguiente: Los bloques de funciones para el comando de disparadores siempre se llaman antes que los bloques de funciones de movimiento. Los gatillos y el respectivo movimiento son comandados siempre en el mismo ciclo. Los activadores utilizan todos los tipos de SMC_TriggerPositionType : Los disparadores en la Posición 1 usan la definición de una distancia relativa ( SMC_TriggerPositionType.MvtRelative ) y como Posición 0.5. Debido a que el movimiento respectivo tiene una distancia de 10, los disparadores están ubicados en X=5. El disparador en la Posición 2 usa la definición de una distancia en unidades de usuario u ( SMC_TriggerPositionType.MvtDistance ) y como Posición 5. Como resultado, el gatillo también se encuentra en X=5. Los disparadores en la Posición 3 usan la intersección con un plano ( SMC_TriggerPositionType.PlaneIntersection ). El plano se ha definido de modo que los disparadores estén ubicados en X=5. GlueApplication tiene el EnableGlue , EnableUVLamp , y RefillGlueStorage salidas. Estos se activan en los disparadores apropiados en GlueApplication.EvaluateTriggers() . El movimiento y el estado de estas salidas se pueden monitorear y evaluar en la traza. " }, 
{ "title" : "Uso de ejes adicionales en robótica ", 
"url" : "_sm_example_additional_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Uso de ejes adicionales en robótica ", 
"snippet" : "El Robotics_AdditionalAxes.project Un proyecto de ejemplo muestra cómo se configuran y utilizan ejes adicionales en robótica. Los ejes adicionales son ejes que se mueven sincrónicamente con los movimientos coordinados del robot El proyecto se encuentra en el directorio de instalación de CODESYS deba...", 
"body" : "El Robotics_AdditionalAxes.project Un proyecto de ejemplo muestra cómo se configuran y utilizan ejes adicionales en robótica. Los ejes adicionales son ejes que se mueven sincrónicamente con los movimientos coordinados del robot El proyecto se encuentra en el directorio de instalación de CODESYS debajo ..\\CODESYS SoftMotion\\Examples . " }, 
{ "title" : "Estructura de la solicitud ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063293414778", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Uso de ejes adicionales en robótica \/ Estructura de la solicitud ", 
"snippet" : "El grupo de ejes está configurado en Axis Group objeto. Se utiliza un robot SCARA con 3 ejes (dos ejes giratorios y un eje Z lineal) También se han agregado dos ejes adicionales a continuación Ejes adicionales y vinculado a los dos ejes DriveAdd1 y DriveAdd2 . El PLC_PRG el programa contiene una máq...", 
"body" : "El grupo de ejes está configurado en Axis Group objeto. Se utiliza un robot SCARA con 3 ejes (dos ejes giratorios y un eje Z lineal) También se han agregado dos ejes adicionales a continuación Ejes adicionales y vinculado a los dos ejes DriveAdd1 y DriveAdd2 . El PLC_PRG el programa contiene una máquina de estados simple para el flujo del programa. Primero, el grupo de ejes está habilitado en estado 0 , y luego un movimiento PTP a la posición (X=50, Y=50) lleva a cabo. Esto luego se mezcla en un movimiento lineal para posicionarse (X=50, Y=-50) . Para el primer movimiento del robot, un movimiento relativo adicional del eje con la distancia (10, 20) está comandado. Para el segundo movimiento del robot, la distancia del eje adicional es (-10, -20) . El MC_GroupReadActualPosition y MC_GroupReadActualVelocity los bloques de funciones se utilizan para leer la posición y la velocidad de la cinemática y de los ejes adicionales. " }, 
{ "title" : "Puesta en servicio ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063296617065", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Ejemplos \/ Uso de ejes adicionales en robótica \/ Puesta en servicio ", 
"snippet" : "Cree la aplicación y descárguela en un controlador. Abra la traza y descárguela en el controlador. Inicie la aplicación. Puede rastrear el movimiento de las coordenadas X e Y y de los dos ejes adicionales de la traza....", 
"body" : "Cree la aplicación y descárguela en un controlador. Abra la traza y descárguela en el controlador. Inicie la aplicación. Puede rastrear el movimiento de las coordenadas X e Y y de los dos ejes adicionales de la traza. " }, 
{ "title" : "Interfaz de usuario ", 
"url" : "_sm_robotics_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Interfaz de usuario ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comando: Crear tarea de planificación ", 
"url" : "_sm_cmd_create_planning_task.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Interfaz de usuario \/ Comando: Crear tarea de planificación ", 
"snippet" : "Función : El comando crea una tarea de planificación automáticamente. Esta tarea es necesaria para la planificación de movimientos CP (por ejemplo, mover lineal o circular). Llama : Proyecto menú; menú contextual del grupo de ejes Requisito : El comando solo está disponible si no hay ninguna tarea d...", 
"body" : "Función : El comando crea una tarea de planificación automáticamente. Esta tarea es necesaria para la planificación de movimientos CP (por ejemplo, mover lineal o circular). Llama : Proyecto menú; menú contextual del grupo de ejes Requisito : El comando solo está disponible si no hay ninguna tarea de planificación configurada para el grupo de ejes. " }, 
{ "title" : "Editor de grupo de ejes ", 
"url" : "_sm_obj_axis_group-1018069.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Interfaz de usuario \/ Editor de grupo de ejes ", 
"snippet" : "Símbolo: En el editor de la Grupo eje objeto, seleccione el tipo de cinemática básica y cinemática de orientación. La cinemática de orientación solo se puede seleccionar cuando es compatible con la cinemática básica. Además, asigna los ejes de la cinemática a los accionamientos de su proyecto. Cinem...", 
"body" : "Símbolo: En el editor de la Grupo eje objeto, seleccione el tipo de cinemática básica y cinemática de orientación. La cinemática de orientación solo se puede seleccionar cuando es compatible con la cinemática básica. Además, asigna los ejes de la cinemática a los accionamientos de su proyecto. Cinemática Seleccionar cinemática Cambiar cinemática Abre una lista de todas las cinemáticas admitidas por CODESYS Cuando selecciona un tipo de cinemática, se muestra una breve descripción en el cuadro a la derecha de la lista. Después de seleccionar un tipo de cinemática, puede modificar los parámetros respectivos en el editor. Cinemática de orientación Seleccionar cinemática Cambiar cinemática Abre una lista de todas las cinemáticas de orientación admitidas por CODESYS Cuando selecciona un tipo de cinemática, se muestra una breve descripción en el cuadro a la derecha de la lista. Después de seleccionar un tipo de cinemática, puede modificar los parámetros respectivos en el editor. Mapeo de ejes Dependiendo de la cinemática seleccionada, asigna los ejes de la cinemática a los accionamientos en su proyecto. Ejes adicionales Añadir eje Añade un campo de configuración para un eje adicional. La unidad del proyecto se introduce en este campo de configuración. Tareas Tarea de ciclo de bus Tarea de ciclo de bus de los ejes, si los ejes ya están mapeados La configuración no se puede cambiar aquí. Tarea de planificación Tarea para la planificación de tareas de CP Una tarea de planificación se crea automáticamente cuando se inserta el primer grupo de ejes. No se debe configurar un mecanismo de vigilancia porque el tiempo de ejecución puede fluctuar considerablemente. Para más información, ver: Configuración de la tarea de planificaciónSi elimina esta tarea, se emite un error en la vista de mensajes. Para crear una nueva tarea, haga clic en Proyecto → Crear tarea de planificación . Para más información, ver: Cómo crear un grupo de ejes" }, 
{ "title" : "Interfaz de usuario ", 
"url" : "_sm_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Interfaz de usuario ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comando: Habilitar SoftMotion ", 
"url" : "_sm_cmd_enable_softmotion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Interfaz de usuario \/ Comando: Habilitar SoftMotion ", 
"snippet" : "Función : El comando habilita los componentes de SoftMotion para el controlador seleccionado y permite utilizar el controlador como controlador de movimiento. Llama : Proyecto menú; menú contextual de un dispositivo seleccionado en el árbol de dispositivos Requisito : Para el controlador seleccionad...", 
"body" : "Función : El comando habilita los componentes de SoftMotion para el controlador seleccionado y permite utilizar el controlador como controlador de movimiento. Llama : Proyecto menú; menú contextual de un dispositivo seleccionado en el árbol de dispositivos Requisito : Para el controlador seleccionado, SoftMotion no está habilitado. El comando hace que Piscina SoftMotion General Axis dispositivo que se agregará debajo de la configuración del controlador siempre que el objeto aún no esté disponible. Hay como mucho uno Piscina SoftMotion General Axis por dispositivo PLC. Además, las bibliotecas de SoftMotion (con prefijo SM3_ ) se agregan al Administrador de bibliotecas. Como resultado, puede utilizar la funcionalidad de SoftMotion en todos los PLC convencionales y, por ejemplo, llamar a los bloques de función de SoftMotion incluso sin una licencia al menos en modo de demostración. Activación automática Si su dispositivo está deshabilitado para SoftMotion y agregó cualquier objeto SoftMotion debajo del dispositivo, entonces el Habilitar SoftMotion El comando se ejecuta inmediatamente de forma implícita. Un objeto SoftMotion es un objeto de leva, un objeto CNC, un objeto de grupo de ejes o cualquier eje SoftMotion. Actualización del dispositivo de un PLC SoftMotion a un PLC estándar Si SoftMotion se ha habilitado y los dispositivos se han configurado a continuación Piscina SoftMotion General Axis , entonces puede actualizar su dispositivo a un PLC estándar de todos modos. Esto se debe a que estos dispositivos permanecen disponibles incluso después de la actualización. Por ejemplo, puede actualizar desde CODESYS SoftMotion RTE para CODESYS Control RTE sin pérdidas. " }, 
{ "title" : "Comando: Deshabilitar SoftMotion ", 
"url" : "_sm_cmd_disable_softmotion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Interfaz de usuario \/ Comando: Deshabilitar SoftMotion ", 
"snippet" : "Función : El comando deshabilita los componentes de SoftMotion . Llama : Proyecto menú; menú contextual de un dispositivo seleccionado en el árbol de dispositivos Requisito : Para el controlador seleccionado, SoftMotion se habilitó mediante el comando. SoftMotion no se puede deshabilitar para los co...", 
"body" : "Función : El comando deshabilita los componentes de SoftMotion . Llama : Proyecto menú; menú contextual de un dispositivo seleccionado en el árbol de dispositivos Requisito : Para el controlador seleccionado, SoftMotion se habilitó mediante el comando. SoftMotion no se puede deshabilitar para los controladores que están destinados a admitir SoftMotion (ejemplo: CODESYS SoftMotion Win ). El comando hace que Piscina SoftMotion General Axis dispositivo que se eliminará de debajo de la configuración del controlador. Además, las bibliotecas de SoftMotion (con prefijo SM3_ ) se eliminan del Administrador de bibliotecas. Ya no puede utilizar la funcionalidad SoftMotion. " }
]
$(document).trigger('search.ready');
});