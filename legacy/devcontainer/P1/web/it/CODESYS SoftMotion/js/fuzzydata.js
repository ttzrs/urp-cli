$(document).ready(function () {indexDict['it'] = [{ "title" : "CODESYS SoftMotion ", 
"url" : "_sm_start_page.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion ", 
"snippet" : "Insieme a CODESYS SoftMotion , puoi creare movimenti PLC in modo efficiente. Si va da semplici movimenti o camme ad asse singolo a movimenti complessi in più dimensioni. In particolare, le applicazioni che includono il controllo di flusso e il controllo di processo oltre alla funzionalità di movimen...", 
"body" : "Insieme a CODESYS SoftMotion , puoi creare movimenti PLC in modo efficiente. Si va da semplici movimenti o camme ad asse singolo a movimenti complessi in più dimensioni. In particolare, le applicazioni che includono il controllo di flusso e il controllo di processo oltre alla funzionalità di movimento rientrano nell'ambito di applicazione del CODESYS SoftMotion . Puoi scaricare il CODESYS SoftMotion dal  CODESYS Store International  o il  CODESYS Store North America . Lì troverai anche la scheda tecnica del prodotto. Guarda anche CODESYS SoftMotion nel Forum CODESYS " }, 
{ "title" : "Licenza ", 
"url" : "_sm_licensing.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Licenza ", 
"snippet" : "Oltre al generale metriche del software concesso in licenza , le metriche sono definite per CODESYS SoftMotion che vengono controllati durante il download. IL SoftMotion le metriche vengono calcolate durante la compilazione e il valore corrente viene visualizzato nell'editor solo successivamente. I ...", 
"body" : "Oltre al generale metriche del software concesso in licenza , le metriche sono definite per CODESYS SoftMotion che vengono controllati durante il download. IL SoftMotion le metriche vengono calcolate durante la compilazione e il valore corrente viene visualizzato nell'editor solo successivamente. I valori determinati si riferiscono ad un'applicazione. Quando esistono più applicazioni, i valori delle singole applicazioni vengono sommati. Gruppo Metrico Valore determinato Numero di assi Assi reali Il valore della metrica è definito dal valore maggiore degli assi reali e degli assi virtuali utilizzati. Esempio: Con 3 assi reali e 4 assi virtuali, il valore nell'applicazione = 4. Assi virtuali Numero di gruppi di assi e interpolatori CNC Gruppi di assi Il valore della metrica è definito dalla somma dei gruppi di assi e degli interpolatori CNC. Esempio: Con 2 gruppi di assi e 2 interpolatori CNC, il valore nell'applicazione = 4. Interpolatori CNC " }, 
{ "title" : "Componenti di CODESYS SoftMotion ", 
"url" : "_sm_components.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Componenti di CODESYS SoftMotion ", 
"snippet" : "CODESYS SoftMotion è un pacchetto software utilizzato come ambiente di sviluppo e runtime per il controllo del movimento. Si delinea come segue: Configurazione dell'azionamento : La configurazione dell'azionamento fornisce un editor per impostare la struttura e la configurazione dell'hardware dell'a...", 
"body" : "CODESYS SoftMotion è un pacchetto software utilizzato come ambiente di sviluppo e runtime per il controllo del movimento. Si delinea come segue: Configurazione dell'azionamento : La configurazione dell'azionamento fornisce un editor per impostare la struttura e la configurazione dell'hardware dell'azionamento tramite il CODESYS interfaccia utente. A questo punto, viene creata un'istanza di un blocco funzione IEC per rappresentare l'azionamento. Questo blocco funzione comunica automaticamente con gli azionamenti senza ulteriore sforzo da parte del programmatore IEC. È responsabile della trasmissione dei dati aggiornati. Per controllare gli azionamenti, il programma IEC può indirizzare un azionamento tramite i blocchi funzione del SoftMotion biblioteche. In alternativa, puoi anche sviluppare i tuoi blocchi funzione per questo scopo. I valori impostati (per posizione, velocità, accelerazione, ecc.) vengono scritti ciclicamente da questi blocchi funzione. Notare la CODESYS SoftMotion Light il prodotto fa parte dell'installazione standard di CODESYS . Fornisce la capacità di comandare gli assi. In questo modo, CODESYS definisce solo la posizione di destinazione e attende la risposta dal controller dell'asse. Il controllore dell'asse è responsabile della pianificazione del movimento. Un movimento coordinato di più assi di CODESYS non è possibile. Editor di camme : Nell'editor di camme è possibile descrivere una camma graficamente o tramite tabelle. CODESYS genera da ciò un'istanza globale di una struttura dati che descrive la camma. Questo viene passato all'applicazione a cui le POU applicabili possono accedervi. Editore CNC : Nell'editor CNC è possibile generare movimenti multidimensionali. È possibile creare il percorso CNC con un editor di testo (secondo DIN 66025) o con un editor grafico. In alternativa all'editor di testo, puoi anche lavorare in una vista tabellare semplificata. Configurazione del gruppo di assi : un gruppo di assi definisce le relazioni tra più assi meccanicamente dipendenti che posizionano e orientano collettivamente un utensile o una piastra utensile nello spazio. Con il configuratore si seleziona e si configura la cinematica da utilizzare. Inoltre è possibile assegnare gli assi SoftMotion. Il SM3_Basic libreria è una libreria di base per tutti SoftMotion applicazioni. Nello specifico, contiene quanto segue: Blocchi funzione PLCopen secondo lo standard PLCopen Con questi blocchi funzione è possibile controllare movimenti di un asse o movimenti master\/slave di due assi (camma elettrica, azionamenti elettrici). FB aggiuntivi non coperti dalle funzionalità PLCopen Funzioni di aiuto: ad esempio per la gestione dei file o per i messaggi di errore Il SM3_CNC la libreria si basa sul SM3_Basic biblioteca. Oltre ai blocchi funzione per le trasformazioni cinematiche, fornisce tutte le POU necessarie per generare, eseguire e visualizzare il movimento CNC. Fornisce inoltre blocchi funzione per la preelaborazione del percorso e la ricostruzione del percorso. Il SM3_Robotics la libreria contiene blocchi funzione secondo PLCopen Parte 4 per la robotica e blocchi funzione aggiuntivi. L'incluso SM3_Transformations libreria contiene le trasformazioni cinematiche supportate. Il Interfaccia di guida fa parte del SM3_Basic libreria ed è responsabile della comunicazione tra il programma IEC e gli azionamenti. Per le unità supportate, CODESYS SoftMotion fornisce librerie che implementano questa interfaccia di unità. Vedi anche le descrizioni degli esempi applicativi. " }, 
{ "title" : "Utilizzo dei controller CODESYS RTE V3 e CODESYS WIN V3 ", 
"url" : "_sm_rtev3_winv3.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Utilizzo dei controller CODESYS RTE V3 e CODESYS WIN V3 ", 
"snippet" : "Nel CODESYS Development System SP20 e versioni successive, SoftMotion controller CODESYS SoftMotion RTE V3 e CODESYS SoftMotion Win V3 non sono più disponibili. CODESYS Control RTE V3 e CODESYS Control Win controller V3 vengono ora utilizzati. Comando: Abilita il comando viene utilizzato per convert...", 
"body" : "Nel CODESYS Development System SP20 e versioni successive, SoftMotion controller CODESYS SoftMotion RTE V3 e CODESYS SoftMotion Win V3 non sono più disponibili. CODESYS Control RTE V3 e CODESYS Control Win controller V3 vengono ora utilizzati. Comando: Abilita il comando viene utilizzato per convertire il controller standard in un SoftMotion controller. " }, 
{ "title" : "SoftMotion con Processori Multicore ", 
"url" : "_sm_multicore_hint.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ SoftMotion con Processori Multicore ", 
"snippet" : "Distribuendo i task di movimento su più core del processore, è possibile azionare più assi o gruppi di assi SoftMotion . Di conseguenza, le attività ad alta intensità di calcolo, come la preelaborazione del percorso CNC o la pianificazione del percorso robotica per i movimenti CP, possono essere sos...", 
"body" : "Distribuendo i task di movimento su più core del processore, è possibile azionare più assi o gruppi di assi SoftMotion . Di conseguenza, le attività ad alta intensità di calcolo, come la preelaborazione del percorso CNC o la pianificazione del percorso robotica per i movimenti CP, possono essere sostituite con un altro core del processore. Quindi c'è più tempo per altre attività nell'attività bus. Il fatto che la potenza di calcolo del controller single-core sia insufficiente è dimostrato nel caso della robotica dall'inspiegabile diminuzione della velocità del percorso. Requisiti di sistema SM V4.5.1.0 o successivo Compilatore V3.5.12.0 o successivo Sistema di runtime compatibile con multicore Utilizzo Robotica e CNC: imposta le attività di pianificazione e bus su diversi core del processore Quando si utilizzano sistemi bus diversi, impostare le singole attività bus su core del processore diversi Quando si utilizzano più attività e più core del processore, prendere nota di quanto segue: I blocchi funzionali nell'attività di pianificazione CNC possono ottenere un nuovo vantaggio in Execute input solo in stati specifici dell'interpolatore ( iStatus uscita). Questo vale anche per il single-core IPO_SCONOSCIUTO IPO_WAIT IPO_FINITA IPO_INIT (solo per il primo avvio, non per il riavvio) I task bus degli assi interdipendenti (gruppo di assi, camma e cinematica CNC) devono essere eseguiti sullo stesso core del processore. " }, 
{ "title" : "CODESYS SoftMotion Drives ", 
"url" : "_sm_f_drive_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Configurazione dell'unità SoftMotion ", 
"url" : "_sm_f_drive_configuration.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configurazione dell'unità SoftMotion ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_sm_overview_drive_configuration.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configurazione dell'unità SoftMotion \/ Panoramica ", 
"snippet" : "L'interfaccia dell'azionamento SoftMotion è un'interfaccia standardizzata utilizzata per collegare, configurare e indirizzare l'hardware dell'azionamento all'interno di un programma IEC. Mappando hardware diversi su un'unica interfaccia, è possibile sostituire facilmente le unità e riutilizzare i pr...", 
"body" : "L'interfaccia dell'azionamento SoftMotion è un'interfaccia standardizzata utilizzata per collegare, configurare e indirizzare l'hardware dell'azionamento all'interno di un programma IEC. Mappando hardware diversi su un'unica interfaccia, è possibile sostituire facilmente le unità e riutilizzare i programmi IEC. L'interfaccia accoppia gli azionamenti alla mappatura I\/O ed è responsabile dell'aggiornamento e della trasmissione dei dati di movimento richiesti al controllo dell'azionamento. L'interfaccia dell'azionamento è costituita dai seguenti componenti: Descrizione del dispositivo del SoftMotion dispositivi alla loro rappresentazione nell'albero dei dispositivi Librerie a cui si fa riferimento nella descrizione del dispositivo che estendono o sovraccaricano i blocchi funzionali di base di ASSE_REF_SM3 in base ai requisiti dei tipi di azionamento specifici Librerie che contengono i blocchi funzione per la lettura e scrittura aciclica dei dati per racchiudere funzioni standard per il driver del bus di campo Se usi a SoftMotion PLC, come ad es CODESYS SoftMotion Win , le librerie di base verranno automaticamente collegate nel Gestore della libreria. Questi tipi di controller forniscono a Pool di assi generali SoftMotion . Qui è possibile inserire unità di azionamento libere. " }, 
{ "title" : "Unità di azionamento accoppiate ", 
"url" : "_sm_inserting_connected_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configurazione dell'unità SoftMotion \/ Unità di azionamento accoppiate ", 
"snippet" : "Gli azionamenti accoppiati appartengono a un dispositivo che rappresenta l'azionamento all'interno della topologia del bus di campo. I simboli di questi azionamenti hanno un piccolo segno che indica il tipo di bus di campo corrispondente. Ad esempio, ogni servoazionamento standard è collegato al con...", 
"body" : "Gli azionamenti accoppiati appartengono a un dispositivo che rappresenta l'azionamento all'interno della topologia del bus di campo. I simboli di questi azionamenti hanno un piccolo segno che indica il tipo di bus di campo corrispondente. Ad esempio, ogni servoazionamento standard è collegato al controller tramite un bus di campo. Quando si utilizzano unità, CODESYS SoftMotion fornisce descrizioni dei dispositivi specifiche per il master bus di campo (suffisso \"_SoftMotion\"). Questi hanno parametri di base ottimizzati per l'azionamento. Per azionamenti utilizzati con CODESYS SoftMotion , la gestione del modulo deve essere disattivata nell'azionamento. La gestione del modulo viene eseguita da CODESYS SoftMotion nel controllore. Se possibile, l'intervallo di spostamento massimo dovrebbe essere impostato su 32 bit. Aggiunta di un dispositivo di azionamento accoppiato (EtherCAT) Requisito: nel progetto è inserito un controllore compatibile con SoftMotion. Seleziona il SoftMotion controller nell'albero dei dispositivi. Nel menu contestuale, fare clic su Aggiungi dispositivo . Nel Aggiungi dispositivo finestra di dialogo, selezionare il Bus di campo → EtherCAT → Master → EtherCAT Master SoftMotion dispositivo. Clicca il Aggiungi dispositivo pulsante. Il dispositivo viene aggiunto all'albero dei dispositivi. Il Aggiungi dispositivo la finestra di dialogo rimane aperta. Seleziona il dispositivo che hai appena aggiunto all'albero dei dispositivi. Nel Aggiungi dispositivo finestra di dialogo, selezionare uno slave SoftMotion ( Bus di campo → EtherCAT → Slave → <Drive SoftMotion> ). Clicca il Aggiungi dispositivo pulsante. Il dispositivo viene aggiunto all'albero dei dispositivi. Facendo doppio clic sul dispositivo si apre l'editor del dispositivo corrispondente. " }, 
{ "title" : "Asse dell'encoder ", 
"url" : "_sm_encoder_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configurazione dell'unità SoftMotion \/ Asse dell'encoder ", 
"snippet" : "Gli assi dell'encoder vengono utilizzati per convertire i valori dell'encoder in un asse SoftMotion che può essere utilizzato come asse principale per MC_CamIn , MC_GearIn e altri blocchi funzionali Master\/Slave. Gli assi dell'encoder possono rappresentare encoder aggiuntivi delle unità di azionamen...", 
"body" : "Gli assi dell'encoder vengono utilizzati per convertire i valori dell'encoder in un asse SoftMotion che può essere utilizzato come asse principale per MC_CamIn , MC_GearIn e altri blocchi funzionali Master\/Slave. Gli assi dell'encoder possono rappresentare encoder aggiuntivi delle unità di azionamento. In questo caso, sono configurati come assi encoder speciali nei dispositivi fieldbus nell'albero dei dispositivi. In alternativa, gli encoder gratuiti in General Axis Pool potrebbe anche utilizzare ingressi analogici come assi dell'encoder. Per ulteriori informazioni, vedere: Codificatore gratuitoProprietà Analogamente agli assi logici, gli assi dell'encoder sono «di sola lettura». Forniscono solo i valori di posizione e velocità. Su di essi non è possibile comandare alcun movimento Lo stato degli assi dell'encoder è sempre standstill . Questo è lo stato di PLCopen for Motion Control Part 1 che corrisponde meglio. Secondo il diagramma di stato, questo stato indica che l'asse è pronto e non vi sono errori. Inoltre, nessuno dei movimenti comandati dal PLC è attivo sull' Nota che prima CODESYS SoftMotion nella versione 4.18.0.0 gli assi dell'encoder erano nello stato power_off . Tuttavia, quando MC_Power è stato chiamato per loro, erano in uno stato standstill . La posizione zero dell'asse dell'encoder può essere compensata con MC_SetPosition . I blocchi funzionali Master\/Slave utilizzano sempre i valori effettivi dell'asse dell'encoder. Un asse logico al di sotto dell'asse dell'encoder può essere utilizzato per la compensazione dei tempi morti. Quando si utilizzano gli assi dell'encoder, non è necessario chiamare MC_Power e non fa alcuna differenza nel comportamento dell'asse dell'encoder per CODESYS SoftMotion versione 4.18.0.0 e successive. " }, 
{ "title" : "Inserimento di unità di azionamento libere ", 
"url" : "_sm_f_free_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configurazione dell'unità SoftMotion \/ Inserimento di unità di azionamento libere ", 
"snippet" : "Le unità di azionamento libere non sono accoppiate in modo permanente con altri dispositivi nell'albero dei dispositivi. Sono inseriti nell'albero dei dispositivi qui sotto SoftMotion Pool generale di unità ....", 
"body" : "Le unità di azionamento libere non sono accoppiate in modo permanente con altri dispositivi nell'albero dei dispositivi. Sono inseriti nell'albero dei dispositivi qui sotto SoftMotion Pool generale di unità . " }, 
{ "title" : "Controllo dell'azionamento Drive_PosControl ", 
"url" : "_sm_drive_controller_drive_poscontrol.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configurazione dell'unità SoftMotion \/ Inserimento di unità di azionamento libere \/ Controllo dell'azionamento Drive_PosControl ", 
"snippet" : "Con il Drive_PosControl controllo dell'azionamento, è possibile lasciare che il controllo della posizione di un asse di CODESYS continuare a correre. Il requisito è un dispositivo che sia controllato dalla velocità impostata e restituisca la sua posizione attuale. Può trattarsi, ad esempio, di un di...", 
"body" : "Con il Drive_PosControl controllo dell'azionamento, è possibile lasciare che il controllo della posizione di un asse di CODESYS continuare a correre. Il requisito è un dispositivo che sia controllato dalla velocità impostata e restituisca la sua posizione attuale. Può trattarsi, ad esempio, di un dispositivo a velocità controllata (convertitore di frequenza) con feedback di posizione. Aggiunta di un controllo dell'unità Presupposto: nel progetto è inserito un controllore SoftMotion. Nella struttura dei dispositivi, selezionare SoftMotion Pool dell'Asse Generale . Nel menu contestuale, fare clic su Aggiungi dispositivo . Nel Aggiungi dispositivo finestra di dialogo, selezionare il Azionamenti SoftMotion → azionamenti con posizione controllata → SMC_Drive_PosControl dispositivo. Clicca il Aggiungi dispositivo pulsante. Il dispositivo viene aggiunto all'albero dei dispositivi. Facendo doppio clic sul dispositivo si apre l'editor del dispositivo corrispondente. Per ulteriori informazioni, vedere: Scheda: Generale" }, 
{ "title" : "Guida logica ", 
"url" : "_sm_drive_controller_logical_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configurazione dell'unità SoftMotion \/ Inserimento di unità di azionamento libere \/ Guida logica ", 
"snippet" : "È possibile aggiungere un'unità logica a qualsiasi tipo di unità unità. L'asse dell'unità logica rispecchia il movimento dell'asse principale mentre rappresenta un'istanza autonoma. Ciò consente l'esecuzione delle seguenti istruzioni su di esso senza influire sull'asse master. MC_SetPosition : Impos...", 
"body" : "È possibile aggiungere un'unità logica a qualsiasi tipo di unità unità. L'asse dell'unità logica rispecchia il movimento dell'asse principale mentre rappresenta un'istanza autonoma. Ciò consente l'esecuzione delle seguenti istruzioni su di esso senza influire sull'asse master. MC_SetPosition : Impostazione della posizione su un valore definito (esempio: 0) MC_TouchProbe : Salvataggio della posizione attuale dell'asse di un segnale trigger MC_AbortTrigger : Disattivazione di un sensore precedentemente attivato con MC_TouchProbe Un'applicazione potrebbe essere un nastro trasportatore che attraversa diverse stazioni di lavorazione. La posizione del componente viene rilevata tramite un segnale esterno (ad es. una fotocellula) e l'asse viene impostato su una posizione definita (funzione di tastatura). L'unità logica fornisce la capacità di filtrare il segnale. Pertanto, l'unità logica può essere utilizzata anche con un encoder che fornisce un segnale di rumore. Aggiunta di un'unità logica Presupposto: nel progetto è inserito un controller SoftMotion. Selezionare un'unità di azionamento nell'albero dei dispositivi. Nel menu contestuale, fare clic su Aggiungi dispositivo . Nel Aggiungi dispositivo finestra di dialogo, selezionare il Unità SoftMotion → unità virtuali → SM_Drive_Logical dispositivo. Clicca il Aggiungi dispositivo pulsante. Il dispositivo viene aggiunto all'albero dei dispositivi. Facendo doppio clic sul dispositivo si apre l'editor del dispositivo corrispondente. " }, 
{ "title" : "Unità virtuale ", 
"url" : "_sm_drive_controller_virtual_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configurazione dell'unità SoftMotion \/ Inserimento di unità di azionamento libere \/ Unità virtuale ", 
"snippet" : "Le unità virtuali sono unità simulate nel software. Con questo, puoi testare i tuoi programmi senza hardware connesso o implementare funzionalità estese. Questo tipo di funzioni include, ad esempio, il controllo dell'override del movimento dell'asse e il metodo cartesiano manuale di un robot in uno ...", 
"body" : "Le unità virtuali sono unità simulate nel software. Con questo, puoi testare i tuoi programmi senza hardware connesso o implementare funzionalità estese. Questo tipo di funzioni include, ad esempio, il controllo dell'override del movimento dell'asse e il metodo cartesiano manuale di un robot in uno spazio. Per ulteriori informazioni, vedere: Controllo di un Cam Drive con un asse temporale virtualeLe unità virtuali simulano un'unità fisica utilizzando le posizioni impostate dei cicli precedenti per calcolare i valori effettivi di posizione, velocità e accelerazione all'inizio di un ciclo. Funzioni che richiedono un'unità fisica, MC_TouchProbe nell'azionamento o nell'uso di SMC_SetControllerMode , non sono supportati. Aggiunta di un'unità virtuale Presupposto: nel progetto è inserito un controller SoftMotion. Nella struttura dei dispositivi, selezionare SoftMotion Pool dell'Asse Generale . Nel menu contestuale, fare clic su Aggiungi dispositivo . Nel Aggiungi dispositivo finestra di dialogo, selezionare il Unità SoftMotion → unità virtuali → SM_Drive_Virtual dispositivo. Clicca il Aggiungi dispositivo pulsante. Il dispositivo viene aggiunto all'albero dei dispositivi. Facendo doppio clic sul dispositivo si apre l'editor del dispositivo corrispondente. " }, 
{ "title" : "Codificatore gratuito ", 
"url" : "_sm_drive_controller_free_encoder.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configurazione dell'unità SoftMotion \/ Inserimento di unità di azionamento libere \/ Codificatore gratuito ", 
"snippet" : "Utilizzare il Codificatore gratuito per l'integrazione di un encoder non accoppiato permanentemente a I\/O o hardware. Aggiunta di un codificatore gratuito Nella struttura dei dispositivi, selezionare SoftMotion Pool dell'Asse Generale . Nel menu contestuale, fare clic su Aggiungi dispositivo . Nel A...", 
"body" : "Utilizzare il Codificatore gratuito per l'integrazione di un encoder non accoppiato permanentemente a I\/O o hardware. Aggiunta di un codificatore gratuito Nella struttura dei dispositivi, selezionare SoftMotion Pool dell'Asse Generale . Nel menu contestuale, fare clic su Aggiungi dispositivo . Nel Aggiungi dispositivo finestra di dialogo, selezionare il Azionamenti SoftMotion → Encoder liberi → SMC_FreeeEncoder dispositivo. Clicca il Aggiungi dispositivo pulsante. Il dispositivo viene aggiunto all'albero dei dispositivi. Aprire l'encoder in Editore . Adatta le impostazioni all'hardware e imposta la larghezza del bit e il ridimensionamento. Assegnare il valore di ingresso dell'encoder a <FREE_ENCODER_AXIS>.diEncoderPosition variabile. Questo è possibile sia come codice IEC che mappando la memoria dei dati in ingresso. Durante l'inizializzazione del bus di campo questo ingresso può fornire valori non validi. Puoi usare il bAttivazione ritardo input per disabilitare la valutazione dell'input finché non è disponibile un valore valido. Ora puoi usare l'encoder come un drive. Per ulteriori informazioni, vedere: Asse dell'encoder" }, 
{ "title" : "Creazione di assi a livello di codice ", 
"url" : "_sm_programmatic_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configurazione dell'unità SoftMotion \/ Inserimento di unità di azionamento libere \/ Creazione di assi a livello di codice ", 
"snippet" : "Le seguenti unità di azionamento gratuite possono essere create anche a livello di programmazione: Assi ASSE VIRTUALE SMC Crea un asse virtuale senza doverlo aggiungere all'albero dei dispositivi Per ulteriori informazioni, vedere quanto segue: Unità virtualeAsse_logico SMC Crea un asse logico senza...", 
"body" : "Le seguenti unità di azionamento gratuite possono essere create anche a livello di programmazione: Assi ASSE VIRTUALE SMC Crea un asse virtuale senza doverlo aggiungere all'albero dei dispositivi Per ulteriori informazioni, vedere quanto segue: Unità virtualeAsse_logico SMC Crea un asse logico senza doverlo aggiungere all'albero dei dispositivi. Per ulteriori informazioni, vedere quanto segue: Guida logicaEncoder SMC_Free Crea un asse dell'encoder senza doverlo aggiungere all'albero dei dispositivi Per ulteriori informazioni, vedere quanto segue: Codificatore gratuito" }, 
{ "title" : "Unità supportate ", 
"url" : "_sm_drives_supported_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Unità supportate ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Unità supportate: EtherCAT ", 
"url" : "_sm_drives_supported_drives_ethercat.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Unità supportate \/ Unità supportate: EtherCAT ", 
"snippet" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control...", 
"body" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control Techniques Mentor Control Techniques Unidrive M Copley Accelnet Danfoss ISD 520 Delta ASDA A2 Delta ASDA A3 Delta ASDA B3 Delta R1-EC5621 Festo CMMP EtherCAT Driver CiA 402 generico: vedi Configurazione dell'asse cIA402 genericoGenerischer SoE Treiber (auch für mehrachsige Antriebe) Hitachi ADV series Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB H6 KEBA KeDrive D3 Kollmorgen AKD Kollmorgen AKD-N\/C Kollmorgen MKD-N\/C Kollmorgen AKD2G Kollmorgen KED Metronix ARS 2000-Serie Mitsubishi Melservo MR-J5 Mitsubishi Melservo MR-JET Omron G5 Panasonic MINAS A5B Panasonic MINAS A6B Panasonic MINAS A6 MultiDrive Parker compax3 Parker SBC Parker PSD Sanyo Denki RS2 Schneider Electric Lexium32 Schneider Electric Lexium32i Servotronix CDHD Stäubli uniVAL Stöber Posidrive Stöber SD6 Stöber SI6\/SC6 WEG SCA06 Yaskawa Sigma7 series " }, 
{ "title" : "Unità supportate: CAN ", 
"url" : "_sm_drives_supported_drives_can.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Unità supportate \/ Unità supportate: CAN ", 
"snippet" : "PUÒ Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP Driver CiA 402 generico: vedi Configurazione dell'asse cIA402 genericoInfranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schneider Ele...", 
"body" : "PUÒ Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP Driver CiA 402 generico: vedi Configurazione dell'asse cIA402 genericoInfranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schneider Electric Lexium05 Schneider Electric Lexium23 Schneider Electric Lexium28 Schneider Electric Lexium32 Schneider Electric Lexium32i Schneider Electric SD-3 " }, 
{ "title" : "Casi d'uso ", 
"url" : "_sm_f_use_cases_drive_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casi d'uso ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Casi d'uso standard ", 
"url" : "_sm_special_use_cases.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casi d'uso \/ Casi d'uso standard ", 
"snippet" : "Il SM3_Basic libreria contiene blocchi funzione sovraordinati che non interagiscono con l'azionamento tramite l'interfaccia valore nominale\/ reale standard. Questi blocchi funzione forniscono comandi o modificano le impostazioni del convertitore leggendo o scrivendo i parametri dell'istanza di AXIS_...", 
"body" : "Il SM3_Basic libreria contiene blocchi funzione sovraordinati che non interagiscono con l'azionamento tramite l'interfaccia valore nominale\/ reale standard. Questi blocchi funzione forniscono comandi o modificano le impostazioni del convertitore leggendo o scrivendo i parametri dell'istanza di AXIS_REF_SM3 . " }, 
{ "title" : "Reinizializzazione di un'unità ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_0e9f93f91e8d4c6dc0a8640e01d50c94", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casi d'uso \/ Casi d'uso standard \/ Reinizializzazione di un'unità ", 
"snippet" : "Se sono stati modificati i parametri dell'unità in fase di esecuzione, è necessario reinizializzare l'unità. Esempio: modifica del fattore di scala o del periodo di modulo degli azionamenti rotativi. Chiamando il Unità SMC3_ReinitD blocco funzionale con un bordo ascendente in Execute input, il wComm...", 
"body" : "Se sono stati modificati i parametri dell'unità in fase di esecuzione, è necessario reinizializzare l'unità. Esempio: modifica del fattore di scala o del periodo di modulo degli azionamenti rotativi. Chiamando il Unità SMC3_ReinitD blocco funzionale con un bordo ascendente in Execute input, il wCommuncationState il parametro dell'unità viene ripristinato e il processo di avvio completo dell'unità viene ripetuto. La reinizializzazione deve attendere che l'asse raggiunga lo stato richiesto SMC_COMSTATE_BASE_COM_INITIALIZATION o più alto. In caso contrario, verrà visualizzato l'errore SMC_RAG_ERROR_AXIS_NOT_INITIALIZED . Se la comunicazione di un bus di campo subordinato viene interrotta, la reinizializzazione esplicita non è più necessaria per CODESYS SoftMotion versione 4.18.0.0 e successive. L'asse viene reinizializzato automaticamente non appena viene ripristinata la comunicazione con il bus di campo. Prima della versione 4.18.0.0, dopo l'interruzione della comunicazione del bus di campo, veniva richiamata SMC3_ReinitDrive era necessario (errore con SMC_DI_GENERAL_COMMUNICATION_ERROR ) non appena la comunicazione con il bus di campo è stata ripristinata. Il vecchio comportamento può essere ripristinato impostando AutoRestart ingresso di SMC_AxisChangeSettings blocco funzione per SMC_AXIS_AUTORESTART_MODE.OFF . " }, 
{ "title" : "Accensione e spegnimento di un'unità ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_bd45abb41e8d4c6dc0a8640e01589872", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casi d'uso \/ Casi d'uso standard \/ Accensione e spegnimento di un'unità ", 
"snippet" : "Il bRegulatorOn e bDriveStart parametri del AXIS_REF_SM3 il blocco funzione controlla il livello di prestazioni e la decelerazione di un convertitore. L'accesso avviene tramite il MC_Power blocco funzione. Per rilasciare lo stadio di uscita, è necessario impostare il bRegulatorOn parametro del MC_Po...", 
"body" : "Il bRegulatorOn e bDriveStart parametri del AXIS_REF_SM3 il blocco funzione controlla il livello di prestazioni e la decelerazione di un convertitore. L'accesso avviene tramite il MC_Power blocco funzione. Per rilasciare lo stadio di uscita, è necessario impostare il bRegulatorOn parametro del MC_Power blocco funzione. L'azionamento segnala lo stato attuale di questo processo tramite il bRegulatorRealState produzione. Se è supportato dall'unità, a bRegulatorOn reset durante il movimento disattiva immediatamente la coppia. In questo caso, il blocco funzione segnala un errore e imposta gli assi su errorstop stato. Il bDriveStart variabile determina se l'unità può muoversi o meno. Lo stato corrente di questo parametro si trova in bDriveStartRealState . Se è supportato dall'unità, a bDriveStart il ripristino dei parametri decelera l'azionamento con la rampa configurata (\"QuickStop\") durante il movimento. Dopodiché, l'azionamento si ferma nella posizione raggiunta fintanto che è stato impostato bRegulatorOn . L'asse rimane nel stopping stato finché il meccanismo \"QuickStop\" è attivo ( bDriveStart input = FALSO). Se l'azionamento è stato spostato in precedenza da un blocco funzione, ora verrà visualizzato CommandAborted . Questo non si applica al MC_Stop blocco funzione che segnala un errore e imposta gli assi su errorstop stato. " }, 
{ "title" : "Gestione dei freni meccanici ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_6670a1571e8d4c6ec0a8640e01f5eecb", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casi d'uso \/ Casi d'uso standard \/ Gestione dei freni meccanici ", 
"snippet" : "Se è supportato dall'unità, il eBrakeControl variabile può essere impostata o ripristinata tramite il tasto SMC3_BrakeControl blocco funzione. Sono possibili tre diverse modalità. SMC3_BrakeSetState SMC_BRAKE_AUTO : Lo stato del freno è controllato dall'azionamento. SMC_BRAKE_OPEN : Il freno è apert...", 
"body" : "Se è supportato dall'unità, il eBrakeControl variabile può essere impostata o ripristinata tramite il tasto SMC3_BrakeControl blocco funzione. Sono possibili tre diverse modalità. SMC3_BrakeSetState SMC_BRAKE_AUTO : Lo stato del freno è controllato dall'azionamento. SMC_BRAKE_OPEN : Il freno è aperto. SMC_BRAKE_CLOSE : Il freno è chiuso. Il bBrakeClosedRealState la variabile riporta lo stato attuale del freno. Dal punto di vista di SoftMotion , il controllo, così come lo stato del freno meccanico, non dipende dallo stato dell'azionamento o dal movimento in corso. " }, 
{ "title" : "Modifica della modalità del controller ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_959f85271e8d4c6ec0a8640e01ed4fcb", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casi d'uso \/ Casi d'uso standard \/ Modifica della modalità del controller ", 
"snippet" : "Con il modalità SMC_SetController blocco funzione, è possibile passare da una modalità di controllo all'altra. byControllerMode e byRealControllerMode parametri da AXIS_REF_SM3 rappresentano la modalità desiderata e la modalità corrente del controller. Possibili valori SMC_nocontrol SoftMotion non i...", 
"body" : "Con il modalità SMC_SetController blocco funzione, è possibile passare da una modalità di controllo all'altra. byControllerMode e byRealControllerMode parametri da AXIS_REF_SM3 rappresentano la modalità desiderata e la modalità corrente del controller. Possibili valori SMC_nocontrol SoftMotion non invia dati ciclici all'azionamento. Ciò consente di controllare l'azionamento in altri modi. SMC_torque Controllo coppia\/forza SMC_velocity Controllo della velocità SMC_position , Controllo di posizione Dopo aver scritto il byControllerMode variabili, la modalità corrente viene controllata finché non corrisponde alla modalità controller desiderata. Il blocco funzionale calcola i valori impostati fino alla conferma della nuova modalità da parte del convertitore. Non appena l'unità conferma la nuova modalità, bDone l'uscita è impostata e SMC_SetControllerMode non scrive più i valori impostati. Questa operazione deve essere eseguita utilizzando altri blocchi funzione. Esempio: The bDone l'uscita è collegata al Execute immissione di un blocco funzionale, ad esempio MC_MoveVelocity , MC_MoveAbsolute , oppure MC_Halt . Altrimenti l'asse si arresta immediatamente dopo la modifica della modalità. Si noti che il tempo morto viene utilizzato per calcolare la posizione impostata. Per ulteriori informazioni, vedere quanto segue: Valori effettivi, valori impostati e tempo morto. " }, 
{ "title" : "Homing (controllato dall'azionamento) ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_7fa66d251e8d4c6fc0a8640e00782f3b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casi d'uso \/ Casi d'uso standard \/ Homing (controllato dall'azionamento) ", 
"snippet" : "In SoftMotion , esistono due modi per fare riferimento a un'unità: Riferimento da un controller nel PLC: questo riferimento viene eseguito chiamando il SMC_Homing blocco funzione. Il segnale di riferimento deve essere parte della mappatura I\/O dell'unità di controllo. Al momento del referenziamento,...", 
"body" : "In SoftMotion , esistono due modi per fare riferimento a un'unità: Riferimento da un controller nel PLC: questo riferimento viene eseguito chiamando il SMC_Homing blocco funzione. Il segnale di riferimento deve essere parte della mappatura I\/O dell'unità di controllo. Al momento del referenziamento, l'azionamento rimane nella modalità di controllo \"controllo di posizione\". In generale, questo metodo non è particolarmente accurato perché il rilevamento della posizione (quando è attivato l'interruttore di riferimento) si basa sulle posizioni attuali ottenute dall'azionamento. Di conseguenza, la precisione è limitata dal ciclo di comunicazione. Riferimento da un controller nell'azionamento: l'interruttore di riferimento è collegato all'azionamento. La sua posizione viene rilevata più velocemente e con maggiore precisione. Durante il percorso di riferimento controllato dall'azionamento, l'azionamento si trova in un'altra modalità di controllo, in cui l'azionamento è controllato da processi interni e non segue i valori impostati dell'unità di controllo. Al termine del percorso di riferimento, l'azionamento viene riportato alla modalità di controllo originale. Il MC_Home  Il blocco funzione avvia il percorso di riferimento controllato dall'azionamento mediante l'impostazione fReference e bStartReference . Inoltre, lo stato di AXIS_REF_SM3 ( wState ) è impostato per homing . Quando l'azionamento passa alla traiettoria di riferimento (ovvero non segue più i valori specificati dalla centralina), l'azionamento imposta il parametro su TRUE . Per visualizzare la fine del percorso di riferimento, il driver imposta i valori di bStartReference e bStartReferenceRealState a FALSE . " }, 
{ "title" : "Aggancio ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_index_14", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casi d'uso \/ Casi d'uso standard \/ Aggancio ", 
"snippet" : "È possibile rilevare la posizione di un asse in molti modi, a seconda delle funzioni dell'azionamento supportate dall'azionamento: L'azionamento rileva la posizione dell'asse stesso (integrato o attivando un sensore esterno). Poiché la posizione effettiva viene trasferita dall'azionamento stesso, il...", 
"body" : "È possibile rilevare la posizione di un asse in molti modi, a seconda delle funzioni dell'azionamento supportate dall'azionamento: L'azionamento rileva la posizione dell'asse stesso (integrato o attivando un sensore esterno). Poiché la posizione effettiva viene trasferita dall'azionamento stesso, il tempo di trasferimento del segnale è minimo e preciso. La posizione attuale dell'asse viene determinata indipendentemente dall'azionamento e trasmessa al controllore tramite un ingresso. La latenza dell'input del controller e il ciclo dell'applicazione rendono questo metodo meno preciso. Quando la posizione dell'azionamento stesso viene trasferita, viene elaborata direttamente nell'applicazione in genere dal rispettivo driver a seconda del produttore. Per determinare la posizione di questo tipo di asse, è possibile utilizzare il MC_TouchProbe blocco funzione. Consente la registrazione della posizione dell'asse su un trigger configurabile e all'interno di una finestra di posizione. Se la posizione non viene trasferita dall'azionamento, deve essere trasmessa al driver del dispositivo dell'azionamento, ad esempio per il controllo. Per ulteriori informazioni, vedere: Controllo di posizione sul controllore con SM_Drive_PosControl" }, 
{ "title" : "Persistenza di una posizione dell'asse ", 
"url" : "_sm_storing_axis_position_persistently.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casi d'uso \/ Persistenza di una posizione dell'asse ", 
"snippet" : "Un asse dotato di un encoder assoluto può salvare una posizione in modo che mantenga la posizione precedente dopo il riavvio del controller. L'homing non è richiesto. Il SMC3_PersistPosition e SMC3_PersistPositionLogical blocchi funzione forniscono la funzionalità per l'operazione di salvataggio. I ...", 
"body" : "Un asse dotato di un encoder assoluto può salvare una posizione in modo che mantenga la posizione precedente dopo il riavvio del controller. L'homing non è richiesto. Il SMC3_PersistPosition e SMC3_PersistPositionLogical blocchi funzione forniscono la funzionalità per l'operazione di salvataggio. I dati necessari vengono salvati in SMC3_PersistPosition_Data e SMC3_PersistPositionLogical_Data . Le bPositionStored l'output indica se il contenuto di PersistentData sono cambiati. Ciò si verifica in momenti diversi a seconda del tipo di persistenza. L'intervallo di valori mantenuto dall'encoder deve essere configurato in SMC_PersistPosition.maxPersistedValue ingresso. Per gli encoder multigiro, il valore è impostato 16#FFFFFFFFFF . Per un encoder a giro singolo a 12 bit, ad esempio, il valore è impostato su 2^12 = 4096 Per ulteriori informazioni, vedere: Persistenza dei dati L'istanza è resa persistente mediante una dichiarazione come VAR_PERSISTENT o il Persistence Manager dell'Application Composer. Persistenza della posizione dell'asse di un asse logico Presupposto: l'asse è logico. Usa il SMC3_PersistPosition Logical blocco funzionale per rendere persistente la posizione dell'asse logico. Funziona solo se la posizione dell'asse fisico sovraordinato è stata resa persistente. La posizione di un asse virtuale non può essere resa persistente mediante questi FB Crea un'istanza di SMC3_PersistPositionLogical blocco funzionale per l'asse. ppl: SM3_BASIC.SMC3_PersistPositionLogical; Istanziare una struttura dati persistente di SMC3_PersistPositionLogical_Data genere. ppl_Data: SMC3_PersistPositionLogical_Data; Estendere il programma del task di movimento in modo che una chiamata del SMC3_PersistPositionLogical istanza è implementata e i dati persistenti di tipo SMC3_PersistPositionLogical_Data gli viene passato. " }, 
{ "title" : "Persistenza della posizione dell'asse di un encoder assoluto multigiro con un asse fisico ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_49c53944c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casi d'uso \/ Persistenza di una posizione dell'asse \/ Persistenza della posizione dell'asse di un encoder assoluto multigiro con un asse fisico ", 
"snippet" : "Presupposto: l'asse dispone di un encoder assoluto multigiro. Utilizzare il SMC3_Posizione persistente FB per rendere persistente la posizione dell'asse fisico. Il rispettivo programma viene eseguito nel task di movimento. Crea un'istanza di SMC3_PersistPosition blocco funzionale per l'asse. pp: SM3...", 
"body" : "Presupposto: l'asse dispone di un encoder assoluto multigiro. Utilizzare il SMC3_Posizione persistente FB per rendere persistente la posizione dell'asse fisico. Il rispettivo programma viene eseguito nel task di movimento. Crea un'istanza di SMC3_PersistPosition blocco funzionale per l'asse. pp: SM3_BASIC.SMC3_PersistPosition; Istanziare una struttura dati persistente di SMC3_PersistPosition_Data genere. pp_Data: SM3_BASIC.SMC3_PersistPosition_Data1; Estendere il programma del task di movimento in modo che una chiamata del SMC3_PersistPosition l'istanza è implementata lì. Call implementato in CFC: Il blocco funzione viene richiamato in cicli con il task di movimento. Il SMC3_PersistPosition istanza esegue il ripristino della posizione salvata durante l'operazione di avvio. Nel funzionamento normale l'FB salva la posizione attuale nella rispettiva struttura dati. " }, 
{ "title" : "Persistenza della posizione dell'asse dell'encoder assoluto monogiro con asse fisico ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_a4cc9967c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casi d'uso \/ Persistenza di una posizione dell'asse \/ Persistenza della posizione dell'asse dell'encoder assoluto monogiro con asse fisico ", 
"snippet" : "Presupposto: l'asse fisico dispone di un encoder assoluto a giro singolo. Usa il SMC3_PersistPosition blocco funzionale per rendere persistente la posizione dell'asse. Il rispettivo programma viene eseguito nel task motion. La posizione viene visualizzata correttamente solo se l'asse non ha percorso...", 
"body" : "Presupposto: l'asse fisico dispone di un encoder assoluto a giro singolo. Usa il SMC3_PersistPosition blocco funzionale per rendere persistente la posizione dell'asse. Il rispettivo programma viene eseguito nel task motion. La posizione viene visualizzata correttamente solo se l'asse non ha percorso alcuna distanza o ha percorso solo una breve distanza (massimo la metà della distanza di un giro) tra lo spegnimento e l'accensione del controller. A tale scopo, ad esempio, è possibile utilizzare un freno meccanico. Se l'asse compie un movimento ampio quando il controller è spento, riceve una posizione errata. Non è possibile effettuare il controllo tramite l'FB Crea un'istanza di SMC3_PersistPosition blocco funzionale per l'asse. ppst_X: SM3_BASIC.SMC3_PersistPositionSinglturn; Istanziare una struttura dati persistente del SMC3_PersistPosition_Data tipo. ppst_Data_X: SMC3_PersistPositionSingleturn_Data; Estendere il programma dell'attività di movimento in modo che una chiamata del SMC3_PersistPosition viene implementata l'istanza e la struttura dati persistente di SMC_PersistPosition_Data gli viene passato il tipo. " }, 
{ "title" : "Rilevamento della posizione iniziale di un asse Modulo ", 
"url" : "_sm_initial_positioning_of_a_rotary_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Casi d'uso \/ Rilevamento della posizione iniziale di un asse Modulo ", 
"snippet" : "La posizione effettiva di un convertitore o encoder viene trasmessa come DWORD al controller. Per un asse modulo, il periodo P è definito in incrementi dal valore modulo e dalla scala. Il periodo P specifica il numero esatto di incrementi in una rotazione. Ciò significa che i valori posizionali X, X...", 
"body" : "La posizione effettiva di un convertitore o encoder viene trasmessa come DWORD al controller. Per un asse modulo, il periodo P è definito in incrementi dal valore modulo e dalla scala. Il periodo P specifica il numero esatto di incrementi in una rotazione. Ciò significa che i valori posizionali X, X+1*P, X+2*P, ecc. descrivono la stessa posizione fisica. La posizione X+n*P supera il limite di DWORD quando n è sufficientemente grande. Ciò accade alla posizione 0x1 00 00 00 00. Quindi il primo posto viene tagliato e il valore inizia a 0 . Se P non è un fattore di 0x1 00 00 00 00 , la posizione X non descrive più la stessa posizione fisica prima e dopo l'interruzione. Se i rapporti di trasmissione sono impostati in modo che il periodo non sia un fattore di 0x1 0000 0000 , dopo l'attivazione è possibile spostare la posizione di un asse di rotazione. Esempio L'asse inizia in posizione 0x0 . È a 0°. Un periodo è 360°. La scalatura è selezionata in modo che corrisponda a 3600000 = 0x36 EE80 incrementi. Dopo 1193 rotazioni, l'asse si ferma a 0xFFFD 7280=1193*3600000 . Dopo un'altra rotazione completa, l'asse raggiunge la posizione 0x10034 6100 . All'interruzione, l'1 iniziale viene tagliato e la posizione 0x34 6100 è formato. Se si riporta l'asse in posizione 0x0 , quindi l'asse si ferma alla posizione 16.7296°. Pertanto, la posizione 0x0 corrisponde alla posizione 0°, 16.7296°, ecc., a seconda dell'effettiva interruzione. Se hai selezionato la scalatura in modo che si possa verificare l'effetto di cui sopra, e se l'homing non è possibile o richiesto all'inizio del programma, puoi recuperare la posizione prima dell'ultima disattivazione tramite il SMC3_Posizione persistente blocco funzione. Qui si utilizza un encoder assoluto. " }, 
{ "title" : "Assi CiA402 ", 
"url" : "_sm_cia402_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Assi CiA402 ", 
"snippet" : "Per ulteriori informazioni, vedere Aggiungi...", 
"body" : "Per ulteriori informazioni, vedere Aggiungi " }, 
{ "title" : "Configurazione dell'asse cIA402 generico ", 
"url" : "_sm_drives_generic_cia402_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Assi CiA402 \/ Configurazione dell'asse cIA402 generico ", 
"snippet" : "CODESYS SoftMotion fornisce driver per diverse unità. Se non è disponibile alcun driver specifico per l'unità cIA402 che si sta utilizzando, è possibile utilizzare l'asse cIA402 generico Tuttavia, la compatibilità e il comportamento dell'asse generico dipendono in larga misura dall'implementazione d...", 
"body" : "CODESYS SoftMotion fornisce driver per diverse unità. Se non è disponibile alcun driver specifico per l'unità cIA402 che si sta utilizzando, è possibile utilizzare l'asse cIA402 generico Tuttavia, la compatibilità e il comportamento dell'asse generico dipendono in larga misura dall'implementazione di cIA402 nel rispettivo azionamento. In pratica, è stato dimostrato che diversi produttori interpretano lo standard CiA402 in modo diverso, in particolare per quanto riguarda la gestione degli errori Pertanto, non è possibile garantire che l'asse CiA402 generico funzioni sempre correttamente o completamente con un particolare azionamento. Il driver generico CiA402 supporta fino a 8 assi nel caso in cui la descrizione del dispositivo dell'azionamento non specifichi un numero. In caso contrario, viene supportato il numero di assi definito nella descrizione del dispositivo. CANopen : Il numero di assi possibili dipende dai profili dei dispositivi logici nel file EDS ( 1000H oggetto e 67FFH + X * 800H , dove X = numero di dispositivi logici). Per maggiori dettagli, vedere lo standard CANopen CiA301. EtherCAT : Il numero di assi possibili dipende dai canali CiA402 definiti (CoE DS402Channels) nel file ESI. Un adattamento del file EDS o ESI deve essere effettuato dal produttore del dispositivo. " }, 
{ "title" : "Oggetti utilizzati durante la messa in servizio ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e06c925bc32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Assi CiA402 \/ Configurazione dell'asse cIA402 generico \/ Oggetti utilizzati durante la messa in servizio ", 
"snippet" : "Durante la messa in servizio si accede ai seguenti oggetti se supportati dal dispositivo. Oggetto Accesso in lettura\/scrittura (M) Obbligatorio (O) Opzionale Commento 0x1000:0 Leggi M Il valore più basso deve essere 402. Altrimenti annullare. 0x1018:1 Leggi O 0x1018:2 Leggi O 0x1018:3 Leggi O 0x1018...", 
"body" : "Durante la messa in servizio si accede ai seguenti oggetti se supportati dal dispositivo. Oggetto Accesso in lettura\/scrittura (M) Obbligatorio (O) Opzionale Commento 0x1000:0 Leggi M Il valore più basso deve essere 402. Altrimenti annullare. 0x1018:1 Leggi O 0x1018:2 Leggi O 0x1018:3 Leggi O 0x1018:4 Leggi O 0x6502:0 Leggi O 0x605A:0 Leggi O 0x60C2:1 Scrivi Se parametro Set60C2 = TRUE 0x60C2:2 Scrivi Se parametro Set60C2 = TRUE 0x6076:0 Leggi O " }, 
{ "title" : "Oggetti utilizzati durante il funzionamento ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7dfc492c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Assi CiA402 \/ Configurazione dell'asse cIA402 generico \/ Oggetti utilizzati durante il funzionamento ", 
"snippet" : "I seguenti oggetti vengono utilizzati durante il funzionamento a seconda delle funzioni utilizzate: 0x603F:00 , 0x6040:00 , 0x6041:00 , 0x6060:00 , 0x6061:00 , 0x6062:00 , 0x6064:00 , 0x606B:00 , 0x606C:00 , 0x6074:00 , 0x6077:00 , 0x6078:00 , 0x607C:00 , 0x60B1:00 , 0x60B2:00, 0x60B8:00 0x60B9:00 ,...", 
"body" : "I seguenti oggetti vengono utilizzati durante il funzionamento a seconda delle funzioni utilizzate: 0x603F:00 , 0x6040:00 , 0x6041:00 , 0x6060:00 , 0x6061:00 , 0x6062:00 , 0x6064:00 , 0x606B:00 , 0x606C:00 , 0x6074:00 , 0x6077:00 , 0x6078:00 , 0x607C:00 , 0x60B1:00 , 0x60B2:00, 0x60B8:00 0x60B9:00 , 0x60BA:00 , 0x60BB:00 , 0x60BC:00 , 0x60BD:00 , 0x60F4:00 . " }, 
{ "title" : "Configurazione avanzata ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7e012b4c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Assi CiA402 \/ Configurazione dell'asse cIA402 generico \/ Configurazione avanzata ", 
"snippet" : "È necessario selezionare il Mostra editor di configurazione generici del dispositivo opzione nel Opzioni – Editor del dispositivo finestra di dialogo in modo che venga visualizzata la scheda con i parametri. È possibile utilizzare i seguenti parametri per mettere a punto il flusso del diagramma di s...", 
"body" : "È necessario selezionare il Mostra editor di configurazione generici del dispositivo opzione nel Opzioni – Editor del dispositivo finestra di dialogo in modo che venga visualizzata la scheda con i parametri. È possibile utilizzare i seguenti parametri per mettere a punto il flusso del diagramma di stato CiA402. Parametro CiA402 Descrizione _readVelocityFactor_6096 TRUE : Il fattore di velocità (oggetto) 6096 ) viene letto e utilizzato per convertire le unità di velocità. FALSE : Il fattore di velocità non viene letto. Si presume che l'unità di velocità sia costituita da incrementi _bImmediateDisabling TRUE : Quando bRegulator viene reimpostato su FALSE , cambia lo stato dell'unità da Operation enabled direttamente a Switch on disabled . FALSE : Cambia lo stato tramite \"Acceso\" e \"Pronto per l'accensione\", dando all'azionamento la possibilità di eseguire un arresto rapido e gestire correttamente il freno. Nota: se questa opzione è impostata su FALSE , allora gli stati per i quali è disattivata la disattivazione immediata possono essere regolati con la maschera di bit _dwStatesImmediateDisabling . _bForbidReenableDuringDisabling Rilevante solo quando _bImmediateDisabling = FALSE . TRUE : L'azionamento viene disabilitato passo dopo passo finché l'azionamento non segnala di essere inserito Ready to switch on prima che venga elaborato un nuovo comando enable. dwStatesImmediateDisabling Rilevante solo quando _bImmediateDisabling = FALSE . Maschera di bit degli stati per i quali è attivata la disabilitazione immediata. Bit 0: funzionamento normale Bit 1: Arresto rapido Bit 2: Quickstop esterno Bit 3: Homing Esempio: supponendo _bImmediateDisabling = FALSE , il valore 2#0110 significa che la disabilitazione immediata è disattivata solo per gli stati \"Normal Operation\" e \"Homing\". Per gli stati \"Quickstop\" e \"External Quickstop\", è attivata la disabilitazione immediata. _uiPreHomingWait Numero di cicli che la macchina a stati attende nello stato PRE_HOMING prima di iniziare il processo di homing impostando il bit 4 della parola di controllo. _uiPostHomingWait Numero di cicli in cui rimane la macchina a stati HOMING_DONE prima di tornare al \"Funzionamento normale\". _uiHomingMinCycles Numero di cicli all'inizio di HOMING , dove i bit di fine (bit 10\/12 della parola di stato) vengono ignorati. _uiWaitCyclesForStateSwitch Numero di cicli che il sistema attende prima che l'azionamento esegua un comando di cambio di stato. Se l'unità si guasta, il sistema tornerà alla modalità SWITCH_ON_DISABLED . _bPreHomingWaitBit12Clear TRUE : Aspetta dentro PRE_HOMING finché il bit 12 della parola di stato non viene cancellato dal convertitore prima di iniziare la corsa al punto di riferimento (prima di impostare il bit 4 della parola di controllo). Si noti che in ogni caso la macchina a stati rimane attiva PRE_HOMING per almeno _uiPreHomingCycles . _bCheckBit10PostHoming TRUE : Passa a HOMING_DONE se il bit 12 e il bit 10 della parola di stato sono entrambi TRUE (come specificato in CiA-402). FALSE : Ignora il bit 10; usa solo il bit 12 _bCheckOpMode TRUE : Controlla se 0x6061 mostra il valore impostato in 0x6060 quando si abilita l'asse. FALSE : Omettere questo controllo e abilitarlo subito dopo aver impostato la modalità di funzionamento. _abyControllerMode Questo ARRAY[0..7] OF BYTE contiene le modalità operative (oggetto 0x6060 ) che corrispondono a AXIS_REF_SM3.byOperationMode . (indice 0,3 = posizione; indice 1 = velocità; indice 2 = coppia) _bCheckBit12InPositionMode TRUE : AxisIsReadyForMotion controlla il bit 12 in CSP o IP. FALSE : AxisIsReadyForMotion non controlla il bit 12. _bDoHaltWhenStopInterruptsHome TRUE : Quando MC_Stop interrompe, interrompe la corsa di riferimento con il bit 8 della parola di controllo. FALSE : Non impostare il bit 8, ma cambiare direttamente la modalità di funzionamento. _bCheckBit13InHomingMode TRUE : In HOMING_ACTIVE , wStatusWord.13 = TRUE porta a un errore di arresto e wControlWord.8 := TRUE (a seconda di _bDoHaltWhenStopInterruptsHome ) _bSetControlBit4InCSP TRUE : Imposta anche il bit 4 della parola di stato in modalità CSP. Alcune unità lo richiedono anche se non è standard. _uiHomingWaitListeningBits101213 In stato HOMING_ACTIVE , non ascoltare i bit 10, 12 e 13 durante questo numero di cicli dall'impostazione del bit 4. (Alcune unità impiegano del tempo per reimpostare questi bit). _bRegulatorOnRequiresVoltageEnabled Indica se il bit 4 della parola di stato (tensione abilitata) deve essere TRUE affinché bRegulatorRealState = TRUE (valore di default: FALSE ). _bDriveStartRequiresOperationEnabled Indica se il bit 2 della parola di stato (funzionamento abilitato) deve essere TRUE affinché bDriveStartRealState = TRUE (valore di default: TRUE ). _modeOfOperation_Torque Le ModeOfOperation da utilizzare per la modalità controller torque . Deve comportarsi come la modalità di coppia di sincronizzazione ciclica _modeOfOperation_Velocity Le ModeOfOperation da utilizzare per la modalità controller velocity . Deve comportarsi come la modalità di velocità di sincronizzazione ciclica _modeOfOperation_Position Le ModeOfOperation da utilizzare per la modalità controller position . Deve comportarsi come la modalità di sincronizzazione ciclica della posizione _bStayInSwitchOnDisabled FALSE : Una transizione automatica da SWITCH_ON_DISABLED a READY_TO_SWITCH_ON viene eseguita, se MC_Power.bDriveStart è TRUE o il codice dell'opzione Quick Stop ( object 0x605A:00 ) è > 4. VERO: Il passaggio da SWITCH_ON_DISABLED a READY_TO_SWITCH_ON viene eseguito solo se MC_Power.bRegulatorOn è TRUE . " }, 
{ "title" : "Sonda tattile ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087437140543", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Assi CiA402 \/ Configurazione dell'asse cIA402 generico \/ Sonda tattile ", 
"snippet" : "Le MC_TouchProbe il blocco funzione richiede un TRIGGER_REF come input. TRIGGER_REF.iTriggerNumber ha il seguente significato per l'asse generico CiA402: Trigger_ref.itNumero di attivazione Significato 0 Sonda tattile 1, bordo positivo 1 Sonda tattile 1, bordo negativo 2 Sonda tattile 2, bordo posit...", 
"body" : "Le MC_TouchProbe il blocco funzione richiede un TRIGGER_REF come input. TRIGGER_REF.iTriggerNumber ha il seguente significato per l'asse generico CiA402: Trigger_ref.itNumero di attivazione Significato 0 Sonda tattile 1, bordo positivo 1 Sonda tattile 1, bordo negativo 2 Sonda tattile 2, bordo positivo 3 Sonda tattile 2, bordo negativo " }, 
{ "title" : "Diagnosi degli errori: l'unità non può essere accesa tramite MC_Power ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087440495495", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Assi CiA402 \/ Configurazione dell'asse cIA402 generico \/ Diagnosi degli errori: l'unità non può essere accesa tramite MC_Power ", 
"snippet" : "L'asse generico prevede che vengano restituiti i seguenti bit nella parola di stato MC_Power.Status = TRUE : Bit 0 (pronto per l'accensione) Bit 1 (acceso) Bit 2 (operazione abilitata) Bit 5 (arresto rapido) Bit 12 Tuttavia, Bit 12 non è impostato da tutte le unità. Se l'unità non imposta il bit, al...", 
"body" : "L'asse generico prevede che vengano restituiti i seguenti bit nella parola di stato MC_Power.Status = TRUE : Bit 0 (pronto per l'accensione) Bit 1 (acceso) Bit 2 (operazione abilitata) Bit 5 (arresto rapido) Bit 12 Tuttavia, Bit 12 non è impostato da tutte le unità. Se l'unità non imposta il bit, allora _bCheckBit12InPositionMode il parametro dell'asse generico può essere impostato su FALSE . " }, 
{ "title" : "Sonda tattile ", 
"url" : "_sm_touch_probe.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Assi CiA402 \/ Sonda tattile ", 
"snippet" : "Le unità con profilo CiA402 a volte supportano la selezione della sorgente della sonda tattile. Non è possibile impostare la sorgente tramite MC_TouchProbe blocco funzionale. Per impostazione predefinita, viene utilizzato l'ingresso digitale appartenente alla sonda tattile Modifica della fonte: Scri...", 
"body" : "Le unità con profilo CiA402 a volte supportano la selezione della sorgente della sonda tattile. Non è possibile impostare la sorgente tramite MC_TouchProbe blocco funzionale. Per impostazione predefinita, viene utilizzato l'ingresso digitale appartenente alla sonda tattile Modifica della fonte: Scrittura manuale dell'oggetto della sonda tattile 0x60B8 Per fare ciò, è necessario chiamare il MC_WriteParameter blocco funzionale con ParameterNumber = 10184 . Ciò corrisponde all'oggetto CiA 402 0x60B8 . Se l'output MC_WriteParameter.Done = TRUE , quindi puoi comandare il MC_TouchProbe blocco funzionale come al solito. Solo i bit dell'oggetto 0x60B8 sono impostati che possono essere definiti da MC_TouchProbe (indicato da ). I bit rimanenti mantengono il valore del passaggio 1 (indicato da ): Bit di oggetto 0x60B8 Sonda tattile 2 Sonda tattile 1 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 Nota sull'oggetto 0x60D0 Nell'oggetto della sonda tattile 0x60B8 , è possibile specificare l'origine in modo che venga risolta tramite l'oggetto 0x60D0 . Corrisponde alla combinazione di bit 10 b per pezzi 3 , 2 o 11 , 10 dell'oggetto 0x60B8 . In questo caso, devi scrivere l'oggetto 0x60D0 prima dell'esecuzione MC_TouchProbe . Per fare ciò, è necessario utilizzare MC_WriteParameter blocco funzionale, in cui ParameterNumber viene calcolato utilizzando SMC_ParameterNumber_CoE funzione. " }, 
{ "title" : "Valori effettivi, valori impostati e tempo morto ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valori effettivi, valori impostati e tempo morto ", 
"snippet" : "Questa pagina risponde alla domanda su quando i valori effettivi e i valori impostati vengono ricevuti e inviati e in che modo sono correlati al tempo morto. Per semplicità, ci concentriamo sulla posizione, ma lo stesso vale per altri valori come la velocità o la coppia. Ci concentriamo anche su Eth...", 
"body" : "Questa pagina risponde alla domanda su quando i valori effettivi e i valori impostati vengono ricevuti e inviati e in che modo sono correlati al tempo morto. Per semplicità, ci concentriamo sulla posizione, ma lo stesso vale per altri valori come la velocità o la coppia. Ci concentriamo anche su EtherCAT. Il comportamento è simile per altri bus di campo. (Nota che assumiamo la configurazione predefinita e consigliata FrameAtTaskStart = TRUE .) " }, 
{ "title" : "Quando vengono ricevuti i valori effettivi? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054861776368", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valori effettivi, valori impostati e tempo morto \/ Quando vengono ricevuti i valori effettivi? ", 
"snippet" : "The actual position ( <DriveA>.fActPosition ) is received at the beginning of the current bus task cycle. It is the actual position of the drive at the time of the previous EtherCAT SYNC event. Nel ciclo di attività del bus i, viene ricevuto il frame EtherCAT inviato nel precedente ciclo di attività...", 
"body" : "The actual position ( <DriveA>.fActPosition ) is received at the beginning of the current bus task cycle. It is the actual position of the drive at the time of the previous EtherCAT SYNC event. Nel ciclo di attività del bus i, viene ricevuto il frame EtherCAT inviato nel precedente ciclo di attività del bus i-1. Questo frame contiene la posizione effettiva che è stata bloccata dall'unità all'evento SYNC " }, 
{ "title" : "Quando vengono inviati i valori impostati? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862001312", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valori effettivi, valori impostati e tempo morto \/ Quando vengono inviati i valori impostati? ", 
"snippet" : "I valori impostati calcolati nel ciclo di attività del bus corrente i vengono inviati all'unità nel seguente ciclo di attività del bus i+1 e applicati dall'unità all'evento SYNC i+1. Vedere il diagramma riportato sopra....", 
"body" : "I valori impostati calcolati nel ciclo di attività del bus corrente i vengono inviati all'unità nel seguente ciclo di attività del bus i+1 e applicati dall'unità all'evento SYNC i+1. Vedere il diagramma riportato sopra. " }, 
{ "title" : "Cos'è il tempo morto, come viene stimato e come viene utilizzato? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862210917", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valori effettivi, valori impostati e tempo morto \/ Cos'è il tempo morto, come viene stimato e come viene utilizzato? ", 
"snippet" : "Come regola generale, il tempo morto è importante ogni volta che è necessario eseguire un'azione esattamente quando l'azionamento raggiunge una posizione. Il tempo morto è importante anche per determinare con precisione la posizione del motore in un determinato momento. Gli esempi includono l'applic...", 
"body" : "Come regola generale, il tempo morto è importante ogni volta che è necessario eseguire un'azione esattamente quando l'azionamento raggiunge una posizione. Il tempo morto è importante anche per determinare con precisione la posizione del motore in un determinato momento. Gli esempi includono l'applicazione della colla ad alta velocità o l'esecuzione di una sonda tattile nel PLC con ingressi digitali ad alta precisione collegati al " }, 
{ "title" : "Definizione del tempo morto ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862962511", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valori effettivi, valori impostati e tempo morto \/ Cos'è il tempo morto, come viene stimato e come viene utilizzato? \/ Definizione del tempo morto ", 
"snippet" : "Il tempo morto è il tempo impiegato dall'azionamento per raggiungere effettivamente la posizione impostata inviata dal PLC. Ciò significa che è l'intervallo di tempo fActPosition e il fSetPosition , all'inizio del ciclo di attività del bus corrente. Il tempo morto può essere configurato nell'editor ...", 
"body" : "Il tempo morto è il tempo impiegato dall'azionamento per raggiungere effettivamente la posizione impostata inviata dal PLC. Ciò significa che è l'intervallo di tempo fActPosition e il fSetPosition , all'inizio del ciclo di attività del bus corrente. Il tempo morto può essere configurato nell'editor generale dell'unità ( Scheda: Generale) o utilizzando il Parametro MC_WRITE blocco funzionale con il numero di parametro 1070 ( fSetActTimeLagCycles ). Il tempo morto è dato dalla somma dei seguenti tempi: Il tempo necessario per inviare la posizione impostata all'azionamento Il tempo necessario al controller dell'azionamento per raggiungere la posizione impostata Il tempo necessario per ricevere la posizione effettiva dal convertitore " }, 
{ "title" : "Stima del tempo morto ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054864599382", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valori effettivi, valori impostati e tempo morto \/ Cos'è il tempo morto, come viene stimato e come viene utilizzato? \/ Stima del tempo morto ", 
"snippet" : "Il tempo morto può essere stimato utilizzando SMC_EstimateDeadtime blocco funzionale. L'azionamento deve essere spostato a velocità costante e deve essere utilizzata la mediana o la media di diverse misurazioni del tempo morto In alternativa, il tempo morto può essere stimato utilizzando l'editor di...", 
"body" : "Il tempo morto può essere stimato utilizzando SMC_EstimateDeadtime blocco funzionale. L'azionamento deve essere spostato a velocità costante e deve essere utilizzata la mediana o la media di diverse misurazioni del tempo morto In alternativa, il tempo morto può essere stimato utilizzando l'editor di tracce. Per ulteriori informazioni, vedere quanto segue: Determinazione dei tempi morti del sistema" }, 
{ "title" : "Utilizzo del tempo morto ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054865995483", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valori effettivi, valori impostati e tempo morto \/ Cos'è il tempo morto, come viene stimato e come viene utilizzato? \/ Utilizzo del tempo morto ", 
"snippet" : "Il tempo morto viene utilizzato nelle seguenti funzionalità. Se utilizzate una di queste funzioni e avete bisogno di un'elevata precisione, assicuratevi di determinare e configurare il tempo morto. Quando si passa dalla modalità controller alla modalità controller SMC_position Per ulteriori informaz...", 
"body" : "Il tempo morto viene utilizzato nelle seguenti funzionalità. Se utilizzate una di queste funzioni e avete bisogno di un'elevata precisione, assicuratevi di determinare e configurare il tempo morto. Quando si passa dalla modalità controller alla modalità controller SMC_position Per ulteriori informazioni, vedere quanto segue: Casi d'uso standardIn modalità controller SMC_velocity per calcolare la posizione impostata a partire dalla posizione effettiva e dalla velocità impostata In modalità controller SMC_torque per calcolare la posizione impostata partendo dalla posizione effettiva e dalla velocità effettiva Se il monitoraggio del ritardo di posizione del software è attivato Nel SMC_GetTravelTime blocco funzionale dell'input ValueSource ha il valore MC_SOURCE.ACT Nel SMC_DigitalCamSwitch_HighPrecision blocco funzionale dell'input ValueSource ha il valore MC_SOURCE.ACT Nel SMC_ETC_InterpolateAxisPosition blocco funzionale (sonda tattile basata su PLC) " }, 
{ "title" : "Esempi ", 
"url" : "_sm_drives_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Esempi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Controllo di posizione sul controllore con SM_Drive_PosControl ", 
"url" : "_sm_example_poscontrol.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Esempi \/ Controllo di posizione sul controllore con SM_Drive_PosControl ", 
"snippet" : "Vedi il PosControl.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Nella maggior parte dei casi, un servocontrollo assume il controllo della posizione dell'azionamento, nonché il controllo della potenza e il controllo della velocità di r...", 
"body" : "Vedi il PosControl.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Nella maggior parte dei casi, un servocontrollo assume il controllo della posizione dell'azionamento, nonché il controllo della potenza e il controllo della velocità di rotazione. Tuttavia, esistono casi d'uso in cui il controllore assume il controllo della posizione dell'asse. Questo esempio mostra come un dispositivo controllato in velocità (ad esempio un convertitore di frequenza con feedback di posizione) è controllato in posizione da CODESYS SoftMotion . Il requisito è un dispositivo che è controllato dalla velocità impostata e restituisce la sua posizione attuale. In questo esempio, viene utilizzato un terminale di uscita analogica a 10 V EL4031 con un segnale utilizzato come setpoint di velocità per un convertitore di frequenza. Un terminale dell'encoder EL5101 viene utilizzato per il feedback di posizione. " }, 
{ "title" : "Controllare la posizione dell'asse con SM_Drive_PosControl ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_7bfb9b9f2d9ce618c0a8646335ff28dd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Esempi \/ Controllo di posizione sul controllore con SM_Drive_PosControl \/ Controllare la posizione dell'asse con SM_Drive_PosControl ", 
"snippet" : "Aggiungere un asse controllato in posizione di tipo SM_Drive_PosControl sotto Pool di assi generali SoftMotion nell'albero dei dispositivi. Aggiungere i terminali per il terminale analogico (EL4031) e l'encoder (EL5101) all'albero dei dispositivi. Albero dei dispositivi: Le descrizioni dei dispositi...", 
"body" : "Aggiungere un asse controllato in posizione di tipo SM_Drive_PosControl sotto Pool di assi generali SoftMotion nell'albero dei dispositivi. Aggiungere i terminali per il terminale analogico (EL4031) e l'encoder (EL5101) all'albero dei dispositivi. Albero dei dispositivi: Le descrizioni dei dispositivi del bus di campo devono essere scaricate e installate dal produttore. Apri il SM_Drive_PosControl dispositivo nell'editor e specificare il parametro generale Modulo con valore 360.0 sul Generale scheda. Clicca il Ridimensionamento\/Mappatura scheda. Il numero di incrementi per giro motore è ricavato dalla scheda tecnica dell'encoder. In questo esempio, 4096 gli incrementi (1) sono di un giro del motore. Poiché stai lavorando con gradi angolari nell'applicazione, specifichi il valore 360 (2) per unità in applicazione . Impostazioni: Passa a Azionamento SoftMotion: anello di controllo della posizione scheda e specificare i seguenti parametri: D 2.0 Il tempo morto determina il numero di cicli in cui la posizione effettiva ricevuta (encoder) viene sfasata alla posizione impostata dell'asse. Il tempo morto dipende dai componenti applicati e deve essere determinato per tentativi ed errori. Kp 0.0 La costante di proporzionalità è il fattore per il quale viene moltiplicato l'errore di posizione (lo scostamento tra posizione impostata e posizione effettiva) da sommare successivamente alla velocità impostata. Ora imposta questo valore su 0 . Il valore verrà determinato sperimentalmente in un secondo momento. Bit width: 16 La larghezza di bit del valore effettivo viene ricevuta a seconda dei componenti utilizzati e può essere impostata come valori a 16, 24 o 32 bit. Imposta il valore su 16 perché i componenti utilizzati danno la posizione come UINT . max Lasciare spento l'interruttore di monitoraggio dell'errore di posizione. Se necessario, puoi riaccenderlo. Selezionare la casella di controllo e specificare un ritardo massimo consentito. Se questo valore viene superato durante il funzionamento, l'asse entra in uno stato di errore. δ\/δt Il parametro ha il valore 1 e va modificato solo in casi molto particolari. Definisce il rapporto tra la velocità impostata e la derivazione della posizione. L'intervallo di valori va da 0 a 1: 0 : Il valore di fSetVelocity viene utilizzato come fonte. 1 : Come sorgente viene utilizzata la derivazione numerica della posizione impostata. Ciclo di controllo: Ora si impostano i valori di velocità che vengono inviati all'attuatore. A tal fine è necessario conoscere la velocità massima in unità applicative e il corrispondente valore grezzo dei dati trasferiti. In questo esempio, la velocità massima è raggiunta dall'uscita del valore 16#7FFF , che corrisponde a una velocità di 10 giri al secondo. Questo corrisponde anche a 3600 gradi al secondo secondo le impostazioni. Impostazioni: " }, 
{ "title" : "Mappatura delle variabili su input e output ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_869c8e3e2852db2ec0a8640e00c42e8b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Esempi \/ Controllo di posizione sul controllore con SM_Drive_PosControl \/ Mappatura delle variabili su input e output ", 
"snippet" : "Mappare le variabili con i dati dell'asse sui moduli I\/O. I dati ciclici disponibili dell'asse si trovano nelle strutture dati in e out . È possibile stabilire questa connessione nell'editor del dispositivo del dispositivo di input e output in modo programmatico o direttamente. Collegare l'uscita (v...", 
"body" : "Mappare le variabili con i dati dell'asse sui moduli I\/O. I dati ciclici disponibili dell'asse si trovano nelle strutture dati in e out . È possibile stabilire questa connessione nell'editor del dispositivo del dispositivo di input e output in modo programmatico o direttamente. Collegare l'uscita (velocità impostata) al dispositivo EL4031. Apri il dispositivo nell'editor e fai clic su Mappatura I\/O EtherCAT scheda. Assegna la variabile out.iSetVelocity dell'asse all'uscita. Nel caso di un'uscita a 32 bit, out.diSetVelocity viene utilizzato. Mappatura: Procedere allo stesso modo con l'inserimento della posizione. Aprire il dispositivo EL5101 nell'editor e impostare il valore di input della posizione su in.wActPosition . Per un ingresso a 32 bit, impostare il valore su in.dwActPosition . Mappatura: Affinché l'abilitazione del controllo, l'arresto rapido e l'interruttore di fine corsa funzionino, gli ingressi corrispondenti di SMC_PosControlInput devono essere definiti dai valori dell'azionamento. Le uscite di SMC_PosControlOutput devono essere trasmessi all'azionamento (vedi descrizione sotto). Se l'unità non supporta l'arresto rapido, ad esempio, allora SM_Drive_PosControl.in.bDriveStartRealState := TRUE deve essere impostato e SM_Drive_PosControl.out.bDriveStart può essere ignorato. In questo esempio, bDriveStartRealState e bRegulatorRealState devono essere impostati nell'applicazione. SM_Drive_PosControl.in.bDriveStartRealState := TRUE;\nSM_Drive_PosControl.in.bRegulatorRealState := TRUE; " }, 
{ "title" : "Determinazione dei tempi morti del sistema ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_section-idm43260109050006", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Esempi \/ Controllo di posizione sul controllore con SM_Drive_PosControl \/ Determinazione dei tempi morti del sistema ", 
"snippet" : "Ora imposta la modalità online con l'asse e imposta i parametri di controllo. Notare che l'asse potrebbe spostarsi fuori controllo. Pertanto è necessario prendere le dovute precauzioni di sicurezza. Quindi provare a far funzionare l'asse senza controllo di posizione. fKp è già impostato su 0.0 e le ...", 
"body" : "Ora imposta la modalità online con l'asse e imposta i parametri di controllo. Notare che l'asse potrebbe spostarsi fuori controllo. Pertanto è necessario prendere le dovute precauzioni di sicurezza. Quindi provare a far funzionare l'asse senza controllo di posizione. fKp è già impostato su 0.0 e le impostazioni di ridimensionamento sono verificate. Cambia l'asse su MC_Power e inizia MC_MoveVelocity . L'asse si muove ora con la velocità programmata di 1 U\/s. In caso di deviazioni, è necessario correggere la scala di conseguenza. Termina il movimento, ad esempio con MC_MoveRelative e avviare la funzione di traccia. Determina il tempo morto del sistema misurando la differenza di tempo tra la posizione impostata e la posizione effettiva. In MC_MoveRelative , impostare la velocità massima e una grande accelerazione. Avviare la traccia di campionamento con MC_MoveRelative . Determinare ora la differenza di tempo tra il movimento iniziale della posizione impostata e la prima reazione della posizione effettiva. Traccia: Per determinare il tempo morto D , dividi questa differenza di tempo per il tempo di ciclo (D = differenza di tempo\/tempo di ciclo). SoftMotion Drive: controllo della posizione scheda, specificare questo valore nel ciclo di controllo in D . Ora cercate di determinare l'impostazione corretta per fKp . A tale scopo, modificate il valore della variabile <drive>.controller.fKp in un elenco di controllo. Set fKp a un numero piccolo (ad esempio 0,0001) e aumenta il valore passo dopo passo. Controlla il comportamento di ogni modifica con la traccia di campionamento. Non appena si rilevano delle fluttuazioni, il limite massimo è stato raggiunto. Ora riduci il valore di fKp di circa il 10% e specificarlo sul SoftMotion Drive: controllo della posizione scheda nel circuito di controllo in Kp . Ora puoi usare l'asse. " }, 
{ "title" : "Modulo funzionale SMC_PosControlInput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_666f8939fd0b11e3b1f5b5a0173eacdc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Esempi \/ Controllo di posizione sul controllore con SM_Drive_PosControl \/ Modulo funzionale SMC_PosControlInput ", 
"snippet" : "Biblioteca: SM3_Drive_PosControl Ingressi (VAR_INPUT) Nome Tipo di dati Valore iniziale Descrizione bLimitPos BOOL Finecorsa in direzione positiva (solo per assi finiti) Dal SoftMotion versione 4.12.0.0, il monitoraggio dei finecorsa è abilitato per impostazione predefinita. Per le versioni preceden...", 
"body" : "Biblioteca: SM3_Drive_PosControl Ingressi (VAR_INPUT) Nome Tipo di dati Valore iniziale Descrizione bLimitPos BOOL Finecorsa in direzione positiva (solo per assi finiti) Dal SoftMotion versione 4.12.0.0, il monitoraggio dei finecorsa è abilitato per impostazione predefinita. Per le versioni precedenti, questo deve essere abilitato manualmente impostando bHWLimitEnable a TRUE . Questa operazione viene in genere eseguita scrivendo il numero del parametro corrispondente 1206 per mezzo di MC_WriteBoolParameter . TRUE : Finecorsa non azionato FALSE : Finecorsa azionato bLimitNeg BOOL Finecorsa in direzione negativa TRUE : Finecorsa non azionato FALSE : Finecorsa azionato wActPosition WORD Posizione attuale (posizione effettiva) come valore a 16 bit dwActPosition DWORD Posizione attuale (posizione effettiva) come valore a 32 bit bExternalError BOOL Errore esterno bRegulatorRealState BOOL TRUE : Asse da controllare bDriveStartRealState BOOL FALSE : Asse in Quick Stop dwEncoderCounterModulo DWORD 0 bDelayActivation BOOL TRUE : Fino a quando bDelayActivation è TRUE , SM3_Drive_PosControl non passa allo stato di comunicazione 100 . Caso d'uso: il valore è mantenuto a TRUE fino a quando l'encoder applicato non fornisce valori di posizione validi. " }, 
{ "title" : "Modulo funzionale SMC_PosControlOutput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_60809817bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Esempi \/ Controllo di posizione sul controllore con SM_Drive_PosControl \/ Modulo funzionale SMC_PosControlOutput ", 
"snippet" : "Biblioteca: SM3_Drive_PosControl Uscite (VAR_OUTPUT) Nome Tipo di dati Valore iniziale Descrizione bRegulatorOnIn BOOL TRUE : L'asse deve essere controllato. bDriveStart BOOL FALSE : L'asse deve eseguire un arresto rapido. diSetVelocity DINT Imposta velocità iSetVelocity INT Imposta velocità...", 
"body" : "Biblioteca: SM3_Drive_PosControl Uscite (VAR_OUTPUT) Nome Tipo di dati Valore iniziale Descrizione bRegulatorOnIn BOOL TRUE : L'asse deve essere controllato. bDriveStart BOOL FALSE : L'asse deve eseguire un arresto rapido. diSetVelocity DINT Imposta velocità iSetVelocity INT Imposta velocità " }, 
{ "title" : "Blocco funzione SMC_SetPosControlParams ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_6080e639bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Esempi \/ Controllo di posizione sul controllore con SM_Drive_PosControl \/ Blocco funzione SMC_SetPosControlParams ", 
"snippet" : "Biblioteca: SM3_Drive_PosControl Modifica i parametri di an SM3_Drive_PosControl asse Ingressi (VAR_INPUT) Nome Tipo di dati Valore iniziale Descrizione Axis AXIS_REF_POSCONTROL Riferimento dell'asse bExecute BOOL TRUE : Attiva l'esecuzione del blocco funzione fKp LREAL -1 Guadagno proporzionale per...", 
"body" : "Biblioteca: SM3_Drive_PosControl Modifica i parametri di an SM3_Drive_PosControl asse Ingressi (VAR_INPUT) Nome Tipo di dati Valore iniziale Descrizione Axis AXIS_REF_POSCONTROL Riferimento dell'asse bExecute BOOL TRUE : Attiva l'esecuzione del blocco funzione fKp LREAL -1 Guadagno proporzionale per lag Un valore inferiore a 0 viene ignorato. fPartVelPilotControl LREAL -1 Fattore per il controllo della velocità con fSetPosition 0: Nessun controllo pilota di velocità; 1: Uscita diretta di fSetVelocity . Un valore inferiore a 0 viene ignorato. fDeadTime LREAL -1 Ritardo di tempo nei cicli tra fSetPosition e fActPositioin Questo valore non deve essere 0. Un valore inferiore a 0 viene ignorato. fMaxPositionDiff LREAL -1 Ritardo di posizione massimo 0 disattiva il controllo del massimo ritardo di posizione. Un valore inferiore a 0 viene ignorato. Uscite (VAR_OUTPUT) Nome Tipo di dati Valore iniziale Descrizione bDone BOOL L'esecuzione del blocco funzione è stata terminata. bError BOOL TRUE : Si è verificato un errore nel blocco funzione. ErrorID SMC_ERROR Identificazione dell'errore Esempio I parametri dell'azionamento dell'asse SM_Drive_PosControl sono impostati. PROGRAM PLC_PRG\nVAR\n fbSetPosControlParams : SMC_SetPosControlParams;\nEND_VAR\n\nfbSetPosControlParams.fKp := 1;\nfbSetPosControlParams.fPartVelPilotControl :=0;\nfbSetPosControlParams.fDeadTime :=0.1;\nfbSetPosControlParams.fMaxPositionDiff :=1;\n\nfbSetPosControlParams(Axis:= SM_Drive_PosControl, bExecute:= TRUE); " }, 
{ "title" : "Interfaccia utente ", 
"url" : "_sm_drives_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaccia utente ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comando: Aggiungi SoftMotion Asse CiA402 ", 
"url" : "_sm_cmd_add_softmotion_cia402_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaccia utente \/ Comando: Aggiungi SoftMotion Asse CiA402 ", 
"snippet" : "Aggiungi SoftMotion Asse CiA402 Funzione : Il comando aggiunge un generale SoftMotion Asse CiA402 sotto uno slave bus di campo nell'albero dei dispositivi. Chiamata : Progetto menù; menu di scelta rapida di un oggetto dispositivo nella struttura dei dispositivi Requisito : Nell'albero dei dispositiv...", 
"body" : "Aggiungi SoftMotion Asse CiA402 Funzione : Il comando aggiunge un generale SoftMotion Asse CiA402 sotto uno slave bus di campo nell'albero dei dispositivi. Chiamata : Progetto menù; menu di scelta rapida di un oggetto dispositivo nella struttura dei dispositivi Requisito : Nell'albero dei dispositivi, viene selezionato un dispositivo che supporta questa unità. Esempi: slave EtherCAT o slave Il file ESI dell'unità contiene la voce che si tratta di un asse cIA402 ( ProfileNo 402 ). Il comando inserisce un asse CiA402 generico. Per ulteriori informazioni, Configurazione dell'asse cIA402 generico " }, 
{ "title" : "Comando: Aggiungi SoftMotion Asse Sercos ", 
"url" : "_sm_cmd_add_softmotion_sercos_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaccia utente \/ Comando: Aggiungi SoftMotion Asse Sercos ", 
"snippet" : "Aggiungere SoftMotion Asse Sercos Funzione : Il comando aggiunge un generale SoftMotion Asse Sercos sotto un modulo Sercos. Chiamata : Progetto menù; menu contestuale del Sercos Slave Requisiti : Nella struttura dei dispositivi è selezionato uno slave Sercos appropriato. Gli assi Sercos non sono più...", 
"body" : "Aggiungere SoftMotion Asse Sercos Funzione : Il comando aggiunge un generale SoftMotion Asse Sercos sotto un modulo Sercos. Chiamata : Progetto menù; menu contestuale del Sercos Slave Requisiti : Nella struttura dei dispositivi è selezionato uno slave Sercos appropriato. Gli assi Sercos non sono più supportati SoftMotion Versione 4.17.0.0 e successive. Questo comando viene utilizzato per far funzionare qualsiasi servoazionamento CODESYS SoftMotion . L'unità deve supportare solo lo standard Sercos. CODESYS utilizza un driver standard per comunicare con il dispositivo. Il modo in cui l'unità funziona o meno con il dispositivo dipende dall'implementazione nel dispositivo stesso. Pertanto, non vi è alcuna garanzia sul funzionamento o meno del driver con il dispositivo. Il driver Sercos generico supporta dispositivi multiasse fino a otto assi. " }, 
{ "title" : "Comando: Aggiungi SoftMotion Asse SoE ", 
"url" : "_sm_cmd_add_softmotion_soe_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaccia utente \/ Comando: Aggiungi SoftMotion Asse SoE ", 
"snippet" : "Aggiungere SoftMotion Asse SoE Funzione : Il comando aggiunge un generale SoftMotion Asse SoE al di sotto di uno Slave EtherCAT. Chiamata : Progetto menù; menu contestuale dello schiavo Requisiti : Nella struttura dei dispositivi è selezionato uno slave EtherCAT appropriato. Questo comando viene uti...", 
"body" : "Aggiungere SoftMotion Asse SoE Funzione : Il comando aggiunge un generale SoftMotion Asse SoE al di sotto di uno Slave EtherCAT. Chiamata : Progetto menù; menu contestuale dello schiavo Requisiti : Nella struttura dei dispositivi è selezionato uno slave EtherCAT appropriato. Questo comando viene utilizzato per far funzionare qualsiasi servoazionamento CODESYS SoftMotion . Il servoazionamento deve solo supportare lo standard SoE. CODESYS utilizza un driver standard per comunicare con il dispositivo. Il modo in cui l'unità funziona o meno con il dispositivo dipende dall'implementazione nel dispositivo stesso. Pertanto, non vi è alcuna garanzia sul funzionamento o meno del driver con il dispositivo. Il driver SoE generico supporta dispositivi multiasse fino a otto assi. " }, 
{ "title" : "SoftMotion Azionamenti ", 
"url" : "_sm_f_reference_object_sm_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaccia utente \/ SoftMotion Azionamenti ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Scheda: Generale ", 
"url" : "_sm_edt_drive_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaccia utente \/ SoftMotion Azionamenti \/ Scheda: Generale ", 
"snippet" : "Tipo e impostazioni degli assi Tipo di asse Modalità virtuale : L'unità viene sostituita da una simulazione simile a un'unità di azionamento virtuale. Quando è presente un azionamento accoppiato, ciò non ha alcun effetto sul dispositivo fieldbus. Funzionano normalmente senza inviare o ricevere messa...", 
"body" : "Tipo e impostazioni degli assi Tipo di asse Modalità virtuale : L'unità viene sostituita da una simulazione simile a un'unità di azionamento virtuale. Quando è presente un azionamento accoppiato, ciò non ha alcun effetto sul dispositivo fieldbus. Funzionano normalmente senza inviare o ricevere messaggi da o verso un Nota: è anche possibile impostare e ripristinare una modalità virtuale di un convertitore in codice IEC tramite il pulsante SMC3_ReinitDrive blocco funzione. Modulo : La trasmissione gira all'infinito senza limitare il campo di traslazione (esempio: trasmissione a cinghia). Valore modulo [u] : Valore di un ciclo (periodo modulo) Il valore viene salvato nel fPositionPeriod parametro del AXIS_REF_SM3 blocco funzione. Nota: se si seleziona Modulo tipo di unità, quindi il prodotto fPositionPeriod * dwRatioTechUnitsDenom deve essere un numero intero. Finito : L'azionamento ha un'area di lavoro fissa (esempio: un azionamento lineare). Finecorsa software attivato : I valori di posizione sono limitati dal limite inferiore Negativo e un limite superiore Positivo . Negativo : Campo di immissione per il valore limite negativo Positivo : Campo di immissione per il valore limite positivo Tipo di motore Rotary : Le impostazioni in Ridimensionamento si applicano ai motori rotativi. Lineare : Le impostazioni in Ridimensionamento si applicano ai motori lineari. (Configurazione semplificata senza ingranaggi e giri del motore Tipo di rampa di velocità Definisce il profilo di velocità per i moduli monoasse e master\/slave che generano movimento: Nota: i tipi di rampa Sin² e Quadratico (liscio) non sono supportati per la robotica. Trapezio : Profilo di velocità trapezoidale (con accelerazione costante in ogni segmento) Peccato² : un profilo di velocità definito dalla funzione sin² (con curva di accelerazione costante). Quadratico : Profilo di accelerazione in forma trapezoidale con limitazione degli strappi Quadratico (liscio) : Mi piace Quadratico ma genera un profilo idiota senza salti. Identificazione ID Identificatore intero. Deve essere univoco per ogni unità. Ad esempio, questo identificatore viene utilizzato nel registro del PLC per identificare l'unità in caso di errore Tempo morto Cicli Il tempo morto in cicli tra fActPosition e il fSetPosition all'inizio di questo ciclo Limiti dinamici Vengono presi in considerazione i valori limite delle POU PLCopen Parte 4. Inoltre, sono utilizzati dalle POU della libreria con SMC_ControlAxisBy* per rilevare i salti. Velocità [u\/s] Valore limite di velocità, accelerazione, decelerazione e strappo Accelerazione [u\/s²] Decelerazione [u\/s²] Coglione [u\/s³] Monitoraggio e reazione agli errori Limiti del software Attivato : i valori di posizione sono limitati dal limite inferiore Negativo e un limite massimo Positivo . Negativo : campo di immissione per il valore limite negativo Positivo : campo di immissione per il valore limite positivo Reazione all'errore del software Cause di un errore software Raggiungere un finecorsa software Superamento del ritardo software massimo consentito Per assi finiti: troppi overflow a 32 bit MC_Power.bRegulatorOn = FALSE durante un movimento attivo (errore: SMC_FB_ACTIVE_AXIS_DISABLED ) Blocco funzionale di movimento con Busy=TRUE non chiamato (errore: SMC_FB_WASNT_CALLED_DURING_MOTION ) Per la reazione all'errore del software, Decelerazione , il Massimo. e si tiene conto della decelerazione dei limiti dinamici. Viene calcolata anche una decelerazione a partire dalla distanza massima. Il valore di decelerazione più elevato viene Decelerazione [u\/s²] : Decelerazione per la rampa di errore Distanza massima [u] Facoltativo L'unità deve essersi fermata entro questa distanza dopo che si è verificato un errore. Monitoraggio del ritardo di posizione Risposta del sistema a un ritardo rilevato. Un ritardo viene rilevato quando la differenza tra la posizione impostata e la posizione effettiva compensata supera il limite di ritardo. La posizione effettiva estrapolata viene calcolata con la seguente formula extrapolated actual position := actual position + actual velocity * cycle time * Axis.fSetActTimeLagCycles Questo valore è la posizione effettiva dell'asse compensata dal tempo morto. Nota: se si sta monitorando il ritardo, è necessario determinare e inserire il tempo morto. Per una descrizione, consulta il capitolo seguente: Valori effettivi, valori impostati e tempo morto. Nota: il monitoraggio del ritardo non è disponibile per le unità virtuali. Disattivato Nessuna risposta Il monitoraggio dei ritardi è disattivato. Disabilita l'unità Le bRegulatorOn bit è costretto a FALSE (confronta con MC_Power input) che forza prima la decelerazione dell'azionamento e poi la disattivazione del convertitore (a seconda dell'implementazione dell'azionamento). Fai una sosta rapida Le bDriveStart bit è costretto a farlo FALSE (confronta con MC_Power input) che obbliga l'azionamento a eseguire un arresto rapido. Resta abilitato L'azionamento rimane acceso, ma tutti i movimenti di marcia vengono interrotti bruscamente. Limite di ritardo : Monitoraggio dei ritardi nel controller Nell'unità può essere presente anche un monitoraggio indipendente, ma non è configurato in questa finestra di dialogo. in linea Presupposto: il controllore è in modalità online. Tabella variabile Elenco delle variabili di azionamento con nome variabile, Valore impostato e Valore corrente Stato Visualizzazione dello stato attuale dell'azionamento SoftMotion Impostazioni di comunicazione Visualizzazione dello stato attuale della comunicazione Errore Errore dell'asse Errore FB Errore interfaccia uiDrive strDriveInterfaceError Per ulteriori informazioni, vedere: Determinazione dei tempi morti del sistemaEsempio Le immagini seguenti mostrano l'effetto dei diversi tipi di rampa. La posizione è disegnata in verde, la velocità in blu e l'accelerazione in rosso. trapezio La velocità è parzialmente lineare e continua, mentre l'accelerazione parzialmente costante indica salti. peccato² Le interruzioni nel profilo di velocità vengono attenuate (utilizzando la funzione sin² invece delle linee) per ridurre i salti in accelerazione. L'utente non può limitare il jerk per questo tipo di rampa. Lo strappo massimo impostato ha effetto solo se l'accelerazione non è uguale a zero all'inizio del movimento e la rampa di decelerazione e accelerazione interrotta non può continuare senza soluzione di continuità. Quindi, tenendo conto del limite di strappo, l'accelerazione viene ridotta a zero prima che inizi il movimento corrente. Rispetto al profilo di velocità trapezoidale, in questo caso la decelerazione richiede più tempo. quadratico L'accelerazione è parzialmente lineare e continua e il jerk ha dei salti. La velocità è costituita da segmenti quadratici e lineari. Quadratico (liscio) Le rampe di accelerazione lineare del tipo a rampa quadratica sono sostituite da una funzione \"liscia\" con un valore di pendenza pari a zero all'inizio e alla fine. Di conseguenza, anche il jerk è continuo. Nota: se un movimento viene interrotto, possono verificarsi interruzioni nello strappo. Per ulteriori informazioni, vedere: Interruzione dei movimenti" }, 
{ "title" : "Scheda: Ridimensionamento\/Mappatura ", 
"url" : "_sm_edt_drive_scaling_mapping.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaccia utente \/ SoftMotion Azionamenti \/ Scheda: Ridimensionamento\/Mappatura ", 
"snippet" : "In questa scheda è possibile definire la relazione tra le unità tecniche (ad esempio, millimetri o gradi) e le unità di azionamento (incrementi). A seconda della descrizione del dispositivo, le opzioni di impostazione vengono visualizzate semplificate (parametro bHiresMode = TRUE ), e\/o la messa in ...", 
"body" : "In questa scheda è possibile definire la relazione tra le unità tecniche (ad esempio, millimetri o gradi) e le unità di azionamento (incrementi). A seconda della descrizione del dispositivo, le opzioni di impostazione vengono visualizzate semplificate (parametro bHiresMode = TRUE ), e\/o la messa in scala per motori lineari può anche essere possibile (parametro IsLinearMotor = TRUE ). Se necessario, è anche possibile influenzare la mappatura di oggetti di azionamento trasmessi ciclicamente su variabili IEC. Ridimensionamento Inverti direzione : La direzione di svolta è invertita. Il motore ottiene i valori specificati con segni opposti. Precisione (cifre decimali) Requisito: la descrizione del dispositivo specifica una finestra di dialogo di configurazione semplificata (parametro bHiresMode = TRUE ). In questo caso, le impostazioni nascoste ottengono il valore predefinito di 1 . Numero di decimali per le unità utente degli incrementi da scalare e trasferire. Per esempio, 3 corrisponde a una precisione di 10 3 . incrementi <=> giri motore Numero di incrementi che corrispondono a un dato numero di giri del motore. Puoi vedere il parametro sul Configurazione scheda dell'editor del dispositivo. giri motore <=> giri uscita ingranaggio Numero di giri del motore che corrisponde ad un dato numero di giri di uscita dell'ingranaggio. l'uscita dell'ingranaggio gira <=> unità nell'applicazione Numero di giri in uscita dell'ingranaggio che corrispondono a un'unità nell'applicazione. Esempio di una configurazione completa Nella configurazione di esempio, un azionamento che ha 3600 incrementi per giro di motore viene scalato in modo che le unità tecniche dell'applicazione siano gradi angolari diritti. Mappatura Nota: questi parametri non sono disponibili per Drive_PosControl. Mappatura automatica : I parametri IEC che interessano il drive vengono mappati automaticamente ai corrispondenti ingressi e uscite del dispositivo. Dopo la disattivazione dell'opzione, la mappatura può essere modificata manualmente. Per fare ciò, modificare l'indirizzo o il tipo degli ingressi e delle uscite nell'elenco dei parametri visualizzato che è stato creato secondo il file di descrizione del dispositivo. " }, 
{ "title" : "Scheda: Messa in servizio ", 
"url" : "_sm_edt_drive_commisioning.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaccia utente \/ SoftMotion Azionamenti \/ Scheda: Messa in servizio ", 
"snippet" : "È possibile spostare l'unità tramite i pulsanti in questa pagina. L'unità potrebbe compiere movimenti imprevisti. Prendere tutte le precauzioni di sicurezza necessarie. Questa scheda viene utilizzata a scopo di test durante la messa in servizio delle unità fisiche. È disponibile solo se il Modalità ...", 
"body" : "È possibile spostare l'unità tramite i pulsanti in questa pagina. L'unità potrebbe compiere movimenti imprevisti. Prendere tutte le precauzioni di sicurezza necessarie. Questa scheda viene utilizzata a scopo di test durante la messa in servizio delle unità fisiche. È disponibile solo se il Modalità di configurazione in linea è abilitato. In questa modalità il sistema di sviluppo è connesso al dispositivo; tuttavia, non è necessario scaricare un'applicazione. in linea Presupposto: il controllore è in modalità online. Tabella variabile Elenco delle variabili di azionamento con nome variabile, Valore impostato e Valore corrente Stato Visualizzazione dello stato attuale dell'azionamento SoftMotion Impostazioni di comunicazione Visualizzazione dello stato attuale della comunicazione Errore Errore dell'asse Errore FB Errore interfaccia uiDrive strDriveInterfaceError " }, 
{ "title" : "Elementi operativi ", 
"url" : "_sm_edt_drive_commisioning.html#UUID-44ff80c7-7f0e-b818-51b8-af95752bbbbd_id_b3c83ad0f91194c0a8646325634a44_id_063bbc9a58bd11e68fa9d28177272265", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaccia utente \/ SoftMotion Azionamenti \/ Scheda: Messa in servizio \/ Elementi operativi ", 
"snippet" : "Elementi operativi Potenza L'azionamento è alimentato (confrontare con MC_Power ). Ripristino errore Reimposta l'unità a seguito di un errore (confronta con MC_Reset ). Inizia a casa L'azionamento esegue l'homing con i parametri impostati nell'azionamento (confrontare con MC_Home ). Jogging Mediante...", 
"body" : "Elementi operativi Potenza L'azionamento è alimentato (confrontare con MC_Power ). Ripristino errore Reimposta l'unità a seguito di un errore (confronta con MC_Reset ). Inizia a casa L'azionamento esegue l'homing con i parametri impostati nell'azionamento (confrontare con MC_Home ). Jogging Mediante gli interruttori < e >, l'azionamento può essere spostato avanti e indietro secondo i valori specificati per Distanza , Velocità , Accelerazione , Decelerazione , e Cretino (paragonare con MC_Inch ). Leggere scrivere Per il parametro di azionamento specificato, la corrente Valore viene letto dal PLC e visualizzato. In Valore preparato , è possibile specificare un nuovo valore e scrivere il parametro nell'unità tramite il piccolo pulsante (confrontare con MC_ReadParameter , MC_WriteParameter ). " }, 
{ "title" : "Scheda: SoftMotion Drive – Controllo della posizione ", 
"url" : "_sm_edt_drive_poscontrol_position_control_loop.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaccia utente \/ SoftMotion Azionamenti \/ Scheda: SoftMotion Drive – Controllo della posizione ", 
"snippet" : "In questa scheda si impostano i parametri per il controllo della posizione. Si prega di notare anche l'esempio Controllo di posizione sul controllore con SM_Drive_PosControl. Anello di controllo della posizione fSetPosition Imposta valore di posizione D Il tempo morto determina il numero di cicli in...", 
"body" : "In questa scheda si impostano i parametri per il controllo della posizione. Si prega di notare anche l'esempio Controllo di posizione sul controllore con SM_Drive_PosControl. Anello di controllo della posizione fSetPosition Imposta valore di posizione D Il tempo morto determina il numero di cicli in cui la posizione effettiva ricevuta (encoder) viene sfasata alla posizione impostata dell'asse. Il tempo morto dipende dai componenti applicati e deve essere determinato per tentativi ed errori. Per ulteriori informazioni, vedere: Determinazione dei tempi morti del sistemafAttoPosizione Valore di posizione effettivo Larghezza in bit La larghezza di bit del valore effettivo viene ricevuta a seconda dei componenti utilizzati e può essere impostata come valori a 16, 24 o 32 bit. Max : Il monitoraggio dell'errore di posizione è attivato. Inserimento del ritardo massimo consentito Se questo valore viene superato durante il funzionamento, l'asse entra in uno stato di errore. Kp La costante di proporzionalità è il fattore per il quale viene moltiplicato l'errore di posizione (lo scostamento tra posizione impostata e posizione effettiva) da sommare successivamente alla velocità impostata. fSetVelocity Imposta il valore di velocità Ridimensionamento dell'uscita di velocità fActPosition e l'uscita di velocità hanno direzioni opposte : Se l'uscita di velocità e la posizione corrente hanno una direzione opposta, questo viene corretto attivando l'opzione. Applicazione [tu\/i] Valore minimo e massimo della velocità (in unità applicative) ad esempio 3600 rotazioni al secondo. Valore di uscita Valore di uscita minimo e massimo che viene inviato all'attuatore (es. 16#7FFF). " }, 
{ "title" : "Scheda: Assi logici ", 
"url" : "_sm_edt_drive_logical_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaccia utente \/ SoftMotion Azionamenti \/ Scheda: Assi logici ", 
"snippet" : "Tipo di asse Modulo : L'azionamento gira all'infinito senza limitare il campo di traslazione (esempio: trasmissione a cinghia). Impostazioni modulo Valore modulo : Valore di un ciclo Il valore viene salvato nel fPositionPeriod parametro di AXIS_REF_SM3 blocco funzionale. Nota: se si seleziona Modulo...", 
"body" : "Tipo di asse Modulo : L'azionamento gira all'infinito senza limitare il campo di traslazione (esempio: trasmissione a cinghia). Impostazioni modulo Valore modulo : Valore di un ciclo Il valore viene salvato nel fPositionPeriod parametro di AXIS_REF_SM3 blocco funzionale. Nota: se si seleziona Modulo tipo di unità, quindi il prodotto fPositionPeriod * dwRatioTechUnitsDenom deve essere un numero intero. Finito : L'azionamento ha un'area di lavoro fissa (esempio: un azionamento lineare). Negativo : Campo di immissione per il valore limite negativo Positivo : Campo di immissione per il valore limite positivo Valore di riferimento principale Set : Il valore impostato del master viene utilizzato come ingresso per l'asse logico e la compensazione dei tempi morti. Effettivo : Il valore reale del master viene utilizzato come ingresso per l'asse logico e la compensazione del tempo morto. Differenza di fuso orario Offset temporale rispetto ai valori master Numero di cicli I valori impostati devono essere estrapolati in questo lasso di tempo Filtri dati di input Con i filtri è possibile livellare i valori di posizione e velocità di un encoder utilizzando un filtro PT1. Posizione Numero di cicli utilizzati come costante di tempo del filtro PT1. Intervallo di valori: [0..999,9] Valore 0: non viene eseguito alcun filtraggio (vengono restituiti valori grezzi). Il valore di ritorno filtrato è una combinazione di un segnale di posizione filtrato PT1 e un'estrapolazione di posizione aggiuntiva tramite il segnale di velocità. L'estrapolazione stessa utilizza anche un filtro PT1 per mitigare il rumore e seleziona automaticamente una costante di tempo appropriata: Se solo i valori impostati devono essere filtrati o l'asse invia il segnale di velocità, la costante di tempo dell'estrapolazione PT1 è la stessa del filtro di posizione PT1. In caso contrario, viene utilizzato un approccio euristico: T Extrapolate = (T Pos + T Dead ) * T Pos \/ T Cycle T Extrapolate : Costante di tempo dal filtro di estrapolazione PT1 T pos : Costante di tempo dal filtro di posizione PT1 T Cycle : Tempo di ciclo T Dead : Compensazione del tempo morto, utilizzando lo sfasamento temporale relativo ai valori master dell'asse logico  n Shift  e il tempo di ciclo  T Cycle : T Dead = n Shift * T Cycle Velocità Numero di cicli utilizzati come costante di tempo del filtro PT1. Intervallo di valori: [0..999,9] Valore 0: non viene eseguito alcun filtraggio (vengono restituiti valori grezzi). Il valore di ritorno filtrato è una combinazione di un segnale di velocità filtrato PT1 e un'estrapolazione di velocità aggiuntiva tramite il segnale di accelerazione. Si noti che l'estrapolazione viene utilizzata solo se l'asse invia un segnale di velocità o se i set point devono essere filtrati. L'estrapolazione stessa utilizza anche un filtro PT1 per mitigare il rumore e seleziona automaticamente una costante di tempo appropriata: T Extrapolate = (T Vel + T Dead ) * T Vel \/ T Cycle con T Extrapolate : Costante di tempo dal filtro di estrapolazione PT1 T Vel : Costante di tempo dal filtro di velocità PT1 T Cycle : Tempo di ciclo T Dead : Compensazione del tempo morto, utilizzando lo sfasamento temporale relativo ai valori master dell'asse logico  n Shift  e il tempo di ciclo  T Cycle : T Dead = n Shift * T Cycle Segnale di velocità dell'asse logico ( fActVelocity ): Caso 1: Valore di riferimento principale = Impostare fSetVelocity dell'asse master viene utilizzato come valore grezzo per il segnale di velocità dell'asse logico. Caso 2: Valore di riferimento principale = Effettivo e nessun segnale di velocità dall'asse master. La derivata numerica della posizione filtrata dell'asse logico ( fActPosition ) viene utilizzato come valore grezzo per il segnale di velocità dell'asse logico. Caso 3: Valore di riferimento principale = Effettivo e un segnale di velocità dall'asse master. Il segnale di velocità viene utilizzato come valore grezzo per il segnale di velocità dell'asse logico. Il filtraggio della velocità viene eseguito su questo segnale grezzo. Ciò significa che se è configurato con il valore predefinito usiFilterDepthVelocity = 0 , quindi questo segnale viene passato invariato a fActVelocity . Nel caso 2, sarebbe anche possibile utilizzare la derivata numerica della posizione non filtrata ( fActPosition dell'asse maestro). La posizione filtrata è stata selezionata perché in questo caso il fActVelocity dell'asse logico corrisponde a fActPosition nella configurazione predefinita senza filtraggio della velocità. Per la velocità, l'estrapolazione del ritardo del filtro viene eseguita solo nei casi 1 e 3. Nel caso 2, questo non sarebbe numericamente stabile o richiederebbe un filtraggio eccessivo dell'accelerazione per essere significativo. Accelerazione dell'asse logico ( fActAcceleration ) Caso 1: Valore di riferimento principale = Impostare fSetAcceleration dell'asse maestro viene utilizzato per il segnale di accelerazione dell'asse logico. Caso 2: Valore di riferimento principale = Effettivo e un segnale di velocità dall'asse master. La derivata numerica della velocità filtrata dell'asse logico ( fActVelocity ) viene utilizzato per il segnale di accelerazione dell'asse logico. Caso 3: Valore di riferimento principale = Effettivo e nessun segnale di velocità dall'asse master. Il valore 0 viene utilizzato per il segnale di accelerazione dell'asse logico perché differenziare due volte una posizione rumorosa porta a risultati inutilizzabili. Jerk dell'asse logico ( fActJerk ) Lo strappo dell'asse logico ( fActJerk ) è l'uno o l'altro Caso 1: Valore di riferimento principale = Impostare fSetJerk dell'asse master viene utilizzato per il segnale di strappo dell'asse logico. Caso 2: Valore di riferimento principale = Effettivo Il valore 0 viene utilizzato per il segnale di strappo dell'asse logico perché differenziare tre volte un segnale di posizione rumoroso porta a risultati inutilizzabili. Non viene eseguita alcuna compensazione del tempo morto per il segnale di accelerazione e strappo. Tutti i valori impostati (posizione, velocità, accelerazione e strappo) dell'asse logico corrispondono ai valori reali. Scrivi valori Scrive i valori di Filtri dati di input e Differenza di fuso orario sul PLC. Identificazione ID ID univoco dell'asse logico in linea Presupposto: il controllore è in modalità online. Tabella variabile Elenco delle variabili di azionamento con nome variabile, Valore impostato e Valore corrente Stato Visualizzazione dello stato attuale dell'azionamento SoftMotion Impostazioni di comunicazione Visualizzazione dello stato attuale della comunicazione Errore Errore dell'asse Errore FB Errore interfaccia uiDrive strDriveInterfaceError " }, 
{ "title" : "Scheda: codificatore ", 
"url" : "_sm_edt_drive_free_encoder_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interfaccia utente \/ SoftMotion Azionamenti \/ Scheda: codificatore ", 
"snippet" : "Impostazioni generali dell'encoder Modulo In un azionamento modulo, questa opzione deve essere attivata e a Valore modulo specificato. : La trasmissione gira all'infinito senza limitare il campo di traslazione (esempio: trasmissione a cinghia). Il Impostazioni modulo viene visualizzata la finestra: ...", 
"body" : "Impostazioni generali dell'encoder Modulo In un azionamento modulo, questa opzione deve essere attivata e a Valore modulo specificato. : La trasmissione gira all'infinito senza limitare il campo di traslazione (esempio: trasmissione a cinghia). Il Impostazioni modulo viene visualizzata la finestra: Valore modulo : Campo di immissione per il valore del modulo Il valore viene salvato nel fPositionPeriod parametro di AXIS_REF_SM3 blocco funzionale. Nota: se si seleziona Modulo tipo di unità, quindi il prodotto fPositionPeriod * dwRatioTechUnitsDenom deve essere un numero intero. Finito : L'unità è limitata. Larghezza in bit Casella di riepilogo per una larghezza di bit appropriata Ridimensionamento Definizione della conversione dei valori interi posizionali inviati dal dispositivo; in incrementi e unità tecniche utilizzate in un'applicazione IEC. Inverti direzione : L'encoder riceve i valori indicati con segno inverso e quindi ruota nel senso di rotazione opposto. incrementi < = > rotazioni encoder Numero di incrementi che corrispondono al numero di complete rotazioni dell'encoder rotazioni encoder <=> unità nell'applicazione Numero di giri dell'encoder che corrispondono a unità in applicazione in linea Presupposto: il controllore è in modalità online. Tabella variabile Elenco delle variabili di azionamento con nome variabile, Valore impostato e Valore corrente Stato Visualizzazione dello stato attuale dell'azionamento SoftMotion Impostazioni di comunicazione Visualizzazione dello stato attuale della comunicazione Errore Errore dell'asse Errore FB Errore interfaccia uiDrive strDriveInterfaceError " }, 
{ "title" : "CODESYS Softmotion Basic ", 
"url" : "_sm_basic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_sm_overview_basic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Panoramica ", 
"snippet" : "CODESYS Softmotion Basic fornisce un'interfaccia per blocchi funzione per il controllo del movimento dei singoli assi. Questa interfaccia si basa sulla specifica PLCopen \"Blocchi funzionali per Motion Control Parte 1 V2.0\". La pianificazione della traiettoria viene eseguita in CODESYS controllore. L...", 
"body" : "CODESYS Softmotion Basic fornisce un'interfaccia per blocchi funzione per il controllo del movimento dei singoli assi. Questa interfaccia si basa sulla specifica PLCopen \"Blocchi funzionali per Motion Control Parte 1 V2.0\". La pianificazione della traiettoria viene eseguita in CODESYS controllore. La gamma di funzioni si estende dal movimento verso una posizione o velocità target, alla sovrapposizione di due movimenti e movimenti sincronizzati, fino a tramite ingranaggi e camme virtuali. I comandi di movimento possono essere bufferizzati e interrotti con precisione di ciclo, nonché decelerati o arrestati e ripresi tramite override. " }, 
{ "title" : "Iniziare con CODESYS Softmotion Basic ", 
"url" : "_sm_basic_first_steps.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Iniziare con CODESYS Softmotion Basic ", 
"snippet" : "Per programmare un movimento con CODESYS Softmotion Basic , almeno un asse deve essere configurato nell'albero dei dispositivi. Ciò include l'impostazione del tipo di asse ( modulo O finito ), il tipo di rampa di velocità, i finecorsa software e la reazione all'errore. Una panoramica dei tipi di mov...", 
"body" : "Per programmare un movimento con CODESYS Softmotion Basic , almeno un asse deve essere configurato nell'albero dei dispositivi. Ciò include l'impostazione del tipo di asse ( modulo O finito ), il tipo di rampa di velocità, i finecorsa software e la reazione all'errore. Una panoramica dei tipi di movimento supportati è disponibile nel file Movimenti ad asse singolo capitolo. Per informazioni su come programmare un movimento ad asse singolo, vedere il Controllo del movimento dei singoli assi capitolo. Per ulteriori informazioni sull'uso di base delle camme, consultare la Controllo di un Cam Drive con un asse temporale virtuale capitolo. Per informazioni sui movimenti di buffering, fusione e sovrapposizione, vedere il file Comandare più movimenti sezione. Per ulteriori informazioni, vedere: Panoramica di cammeCapitolo: Passaggio tra le cammeCreazione di una cam online dall'applicazione: Strutture dati delle cammeCapitolo: Adattamento dinamico con MC_SetOverride" }, 
{ "title" : "Blocchi di funzioni amministrative ", 
"url" : "_sm_administrative_fbs.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Blocchi di funzioni amministrative ", 
"snippet" : "I blocchi funzione amministrativi vengono utilizzati per richiedere informazioni o modificare impostazioni specifiche. Tuttavia, non innescano mai un movimento. Un'unità fisica (da qui in poi denominata unità) è rappresentata in CODESYS SoftMotion dall'oggetto software AXIS_REF_SM3 (da qui in poi de...", 
"body" : "I blocchi funzione amministrativi vengono utilizzati per richiedere informazioni o modificare impostazioni specifiche. Tuttavia, non innescano mai un movimento. Un'unità fisica (da qui in poi denominata unità) è rappresentata in CODESYS SoftMotion dall'oggetto software AXIS_REF_SM3 (da qui in poi denominato asse). A seconda del blocco funzionale amministrativo utilizzato, l'esecuzione avviene sull'unità, sull'asse o su entrambi. Blocchi funzionali MC_Power Controlla lo stadio di potenza del convertitore MC_Reset Reimposta gli errori degli assi e degli azionamenti MC_SetPosition Sposta il sistema di coordinate dell'asse su qualsiasi valore; ad esempio, può essere utile per fare riferimento. SMC3_BrakeControl Controlla il freno meccanico quando l'azionamento supporta questa funzione SMC3_BrakeStatus Legge lo stato attuale del freno meccanico SMC_ChangeDynamicLimits Imposta i limiti dinamici (velocità, accelerazione, decelerazione, strappo e coppia) di un asse Per ulteriori informazioni, vedere quanto segue: Limiti dinamici in Scheda: GeneraleSMC_ChangeAxisScalingLinear Modifica la scala di un asse lineare SMC_ChangeAxisScalingRotary Modifica la scala di un asse rotante SMC_SetForecast Imposta il Previsione di un asse SMC_GetForecast Restituisce la previsione impostata dell'asse SMC_GetTravelTime Restituisce l'ora in cui l'asse raggiunge una posizione specifica. Ciò è particolarmente utile se combinato con Previsione. SMC_SetAdditionalConversionFactors Imposta fattori aggiuntivi per la conversione. Ad esempio, il fattore di coppia può essere utilizzato per prendere in considerazione un cambio. SMC_SetControllerMode Imposta una modalità operativa diversa per l'asse quando l'azionamento supporta questa funzione SMC_SetMovementType Imposta il tipo di movimento di un asse virtuale su limitato o modulo Per ulteriori informazioni, vedere quanto segue: Scheda: Generale. SMC_SetRampType Imposta il tipo di rampa di velocità di un asse Per ulteriori informazioni, vedere quanto segue: Tipo di rampa di velocità nel Scheda: Generale capitolo SMC_SetSoftwareLimits Imposta i limiti di posizione per assi limitati e la reazione corrispondente in caso di errore Per ulteriori informazioni, vedere quanto segue: Interruttori di limite software e Reazione all'errore del software nel Scheda: Generale capitolo MC_TouchProbe Restituisce la posizione dell'azionamento quando viene generato un evento di attivazione definito MC_AbortTrigger Interrompe le funzioni che utilizzano eventi trigger (esempio: MC_TouchProbe ) SMC_ReadFBError Restituisce la voce più vecchia dalla memoria degli errori del blocco funzione dell'asse. Queste informazioni possono essere utilizzate, ad esempio, per la visualizzazione in una visualizzazione SMC_ClearFBError Elimina la voce più vecchia dalla memoria degli errori del blocco funzione dell'asse. SMC_ReadSetPosition Restituisce la posizione impostata dell'asse SMC_ReadSetValues Restituisce la posizione impostata, la velocità impostata, l'accelerazione impostata e il set jerk. Quando Previsione è abilitato, i dati possono essere interrogati anche in futuro. Per ulteriori informazioni, vedere quanto segue: SMC_setForecast MC_ReadActualPosition Restituisce la posizione effettiva dell'azionamento MC_ReadActualVelocity Restituisce la velocità effettiva del convertitore MC_ReadActualTorque Restituisce la coppia effettiva o la forza effettiva dell'azionamento MC_ReadAxisError Legge l'errore dall'unità MC_ReadStatus Legge lo stato corrente dell'asse SMC_CheckAxisCommunication Restituisce lo stato di comunicazione dell'asse SMC_CheckLimits Verifica se i valori impostati correnti superano i limiti dinamici impostati dell'asse Per ulteriori informazioni, vedere quanto segue: SMC_ChangeDynamicLimits e Limiti dinamici nel Scheda: GeneraleSMC_GetTrackingError Restituisce il ritardo dell'asse (differenza tra la posizione impostata dell'asse e la posizione effettiva dell'azionamento) SMC_InPosition Indica se il ritardo rientra in un intervallo configurabile SMC_MeasureDistance Restituisce la distanza percorsa dall'asse dall'avvio del blocco. Ciò è particolarmente utile per gli assi del modulo MC_ReadBoolParameter Legge un valore booleano dall'asse o dall'unità MC_ReadParameter Legge un valore dall'asse o dall'azionamento MC_WriteBoolParameter Scrive un valore booleano sull'asse o sull'unità MC_WriteParameter Scrive un valore sull'asse o sull'azionamento Blocchi funzionali diagnostici SMC_AxisDiagnosticLog Scrive i valori impostati e i valori effettivi (posizione, velocità e accelerazione) dell'asse e dell'unità ciclicamente in un file. Questo può essere utile per la diagnosi di errori e sequenze di movimento SMC_GetMaxSetVelocity Registra il valore massimo della velocità impostata dell'asse. Questo blocco funzionale può essere utile per scopi diagnostici. SMC_GetMaxSetAccDec Registra il valore massimo dell'accelerazione impostata dell'asse. Questo blocco funzionale può essere utile per scopi diagnostici. Persistere SMC3_PersistPosition Persiste la posizione di un asse con encoder assoluto Per ulteriori informazioni su «Persist», vedere quanto segue: Persistenza di una posizione dell'asseSMC3_PersistPositionLogical Persiste la posizione di un asse logico Per ulteriori informazioni sugli assi logici, vedere quanto segue: Guida logica" }, 
{ "title" : "Movimenti ad asse singolo ", 
"url" : "_sm_basic_single_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti ad asse singolo ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_sm_overview_single_axis_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti ad asse singolo \/ Panoramica ", 
"snippet" : "CODESYS SoftMotion distingue tra movimenti che agiscono su un solo asse e movimenti in cui due assi sono sincronizzati (ad esempio tramite camme elettroniche o ingranaggi virtuali). Quest'ultimo è descritto nel Movimenti sincroni di due assi pagina di aiuto. Fondamentalmente i blocchi di movimento c...", 
"body" : "CODESYS SoftMotion distingue tra movimenti che agiscono su un solo asse e movimenti in cui due assi sono sincronizzati (ad esempio tramite camme elettroniche o ingranaggi virtuali). Quest'ultimo è descritto nel Movimenti sincroni di due assi pagina di aiuto. Fondamentalmente i blocchi di movimento che agiscono solo su un singolo asse possono essere suddivisi nelle seguenti categorie: Blocchi di movimento Bloccare Descrizione MC_MoveAbsolute Esegue un movimento nella posizione specificata MC_MoveRelative Esegue un movimento della distanza specificata rispetto alla posizione corrente MC_MoveAdditive Esegue un movimento della distanza specificata rispetto all'ultima posizione target comandata di un altro movimento (ad esempio, da MC_MoveAbsolute ) MC_MoveSuperimposed Esegue un movimento della distanza relativa specificata in aggiunta a un altro movimento attivo (ad esempio, da MC_MoveAbsolute ). Il movimento attivo non viene interrotto. MC_MoveVelocity Esegue un movimento continuo alla velocità specificata SMC_MoveContinuousAbsolute Esegue un movimento nella posizione specificata. In questo caso la posizione target viene raggiunta con una velocità definita che viene successivamente mantenuta. SMC_MoveContinuousRelative Esegue un movimento della distanza specificata rispetto alla posizione corrente. In questo caso la posizione target viene raggiunta con una velocità definita che viene successivamente mantenuta. MC_Jog Esegue un movimento continuo alla velocità specificata finché l'asse deve spostarsi avanti o indietro SMC_Inch Esegue un movimento della distanza specificata rispetto alla posizione corrente finché l'asse deve spostarsi in avanti o indietro Arresto dei movimenti Bloccare Descrizione MC_Halt Esegue un arresto controllato, interrompe qualsiasi movimento attivo e arresta l'asse. MC_Halt è destinato alle normali condizioni di funzionamento perché l'arresto può essere interrotto da nuovi movimenti. Inoltre, il funzionamento può essere ripreso più facilmente dopo un arresto poiché l'asse rimane in uno stato operativo. MC_Stop Esegue un arresto controllato, interrompe qualsiasi movimento attivo e arresta l'asse. MC_Stop è destinato alle situazioni di emergenza perché la fermata non può essere interrotta da nuovi movimenti. Dopo che è stato effettuato l'arresto, l'asse si trova nello stato di arresto in modo che non vengano accettati nuovi movimenti. Nuovi movimenti sono nuovamente possibili solo dopo che l'arresto è stato completato e il Execute l'ingresso è impostato su FALSE . MC_HaltSuperImposed Esegue un arresto controllato di SuperImposed movimenti. Il movimento sottostante non viene interrotto nel processo Homing Bloccare Descrizione MC_Home Avvia l'homing dell'asse controllato dall'azionamento. Il funzionamento e i suoi parametri dipendono dal convertitore e dal produttore. SMC_Homing Avvia l'homing dell'asse controllato dal controller MC_SetPosition Non sposta l'asse, ma sposta solo il punto zero. In questo modo il blocco può essere utilizzato ad es. per il riferimento. Inoltre il blocco può essere richiamato anche durante un movimento attivo. Movimenti speciali Bloccare Descrizione SMC_FollowPosition Scrive la posizione impostata dell'asse. Questo può essere usato per passare le traiettorie calcolate all'asse. SMC_FollowVelocity Scrive la velocità impostata dell'asse. Questo può essere usato per passare le traiettorie calcolate all'asse. SMC_FollowPositionVelocity Scrive la posizione e la velocità impostate dell'asse. Questo può essere usato per passare le traiettorie calcolate all'asse. SMC_FollowSetValues Scrive selettivamente la posizione impostata, la velocità, l'accelerazione, lo strappo e\/o la coppia target impostata dell'asse. Questo può essere usato per passare le traiettorie calcolate all'asse. SMC_SetTorque Scrive la coppia impostata dell'asse. A seconda della modalità operativa dell'asse, il valore viene utilizzato per il controllo feed forward della coppia o come coppia che l'asse dovrebbe applicare. " }, 
{ "title" : "Interruzione dei movimenti ", 
"url" : "_sm_interrupt_single_axis_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti ad asse singolo \/ Interruzione dei movimenti ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Interruzione dei movimenti su un asse ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_section-idm234855926060424", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti ad asse singolo \/ Interruzione dei movimenti \/ Interruzione dei movimenti su un asse ", 
"snippet" : "Movimenti ad asse singolo, come mc_move Absolute , può essere interrotto in qualsiasi momento da altri movimenti. Può trattarsi di un movimento verso una posizione diversa o di una variazione della velocità massima, dell'accelerazione o dello strappo con lo stesso tipo di movimento e nella stessa po...", 
"body" : "Movimenti ad asse singolo, come mc_move Absolute , può essere interrotto in qualsiasi momento da altri movimenti. Può trattarsi di un movimento verso una posizione diversa o di una variazione della velocità massima, dell'accelerazione o dello strappo con lo stesso tipo di movimento e nella stessa posizione. L'interruzione è implementata in modo tale che non vi sia alcun salto di velocità. Per tutti i tipi di rampa quadratica, inoltre, non vi è alcun In casi specifici, un'inversione dell'asse è inevitabile a causa del movimento interrotto: Se la nuova posizione bersaglio di un MC_MoveAbsolute esiste prima della fine della distanza di decelerazione corrente Se per il movimento interrotto viene utilizzata una decelerazione massima inferiore e\/o uno strappo massimo inferiore, che a sua volta estende la distanza di decelerazione oltre la posizione target Se SMC_MoveContinuousAbsolute o SMC_MoveContinuousRelative viene utilizzato con un EndVelocity che non può essere raggiunto dallo stato attuale dell'asse senza inversione Quando la rampa è di tipo sin² e quadratico (liscio) vengono utilizzati, durante l'interruzione può verificarsi un'inversione anche se non sembra necessaria. (Cioè, anche se i motivi sopra elencati non sono applicabili. Vedi le spiegazioni di seguito.) Quindi la nuova posizione bersaglio potrebbe essere superata, sebbene non si trovi prima della vecchia posizione bersaglio. Ciò può accadere anche se la decelerazione massima e lo strappo massimo non vengono modificati (o addirittura aumentati) e la velocità finale non viene modificata rispetto al movimento interrotto. In questo caso Per i tipi di rampe trapezoidali e quadratiche, non vi è mai alcun superamento. Per il peccato² tipo di rampa, non si verifica alcun superamento quando la nuova posizione target e i valori limite per l'accelerazione e la decelerazione sono uguali ai valori precedenti. In tutti gli altri casi, potrebbe verificarsi un eccesso di viaggio con peccato² e quadratico (liscio) tipi di rampa. Spiegazione per peccato² tipo di rampa: Il movimento interrotto inizia con una nuova rampa di velocità sin², il che significa che l'accelerazione parte da 0 e aumenta o diminuisce gradualmente. Se l'asse ha un'accelerazione diversa da 0 al momento dell'interruzione, l'accelerazione salta a 0 all'inizio della rampa di velocità sin². Ciò può portare a un eccesso di velocità perché aumentare o diminuire l'accelerazione Spiegazione per quadratico (levigato) tipo di rampa: La stessa spiegazione vale per sin² , ma per il cretino invece che per l'accelerazione. Nota sull'override Sulla base delle spiegazioni precedenti, utilizzando MC_SetOverride con il peccato² e quadratico (levigato) il tipo di rampa non è raccomandato " }, 
{ "title" : "Interruzione durante la fase di decelerazione ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_id_fbc677d73098ed1c0a86463411e7edd_id_b5d8fdf3fc0362bfc0a8658d00b6a52e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti ad asse singolo \/ Interruzione dei movimenti \/ Interruzione durante la fase di decelerazione ", 
"snippet" : "Movimenti ad asse singolo, ad es MC_MoveAbsolute , può essere interrotto in qualsiasi momento da altri movimenti. Questo può essere un movimento in un'altra posizione o un cambiamento di velocità o accelerazione. In sostanza, l'interruzione del movimento è attuata da un altro in modo tale che non vi...", 
"body" : "Movimenti ad asse singolo, ad es MC_MoveAbsolute , può essere interrotto in qualsiasi momento da altri movimenti. Questo può essere un movimento in un'altra posizione o un cambiamento di velocità o accelerazione. In sostanza, l'interruzione del movimento è attuata da un altro in modo tale che non vi sia alcun salto di velocità. Per tutti i tipi di rampa (tranne trapezoidale ), non c'è nemmeno un salto nell'accelerazione. Quando la rampa digita peccato² e quadratico (liscio) vengono utilizzati, durante l'interruzione può verificarsi un'inversione e all'inizio non sembra necessario (vedi spiegazione). Quindi la nuova posizione di destinazione viene superata, sebbene non si trovi prima della vecchia posizione di destinazione. Ciò può verificarsi nelle seguenti situazioni: Se viene impostato un valore di decelerazione massimo inferiore per il movimento di annullamento rispetto a prima In questo caso, la distanza di decelerazione disponibile per la nuova posizione di destinazione è forse troppo breve (per tutti i tipi di rampa). Di conseguenza, per quadratico e quadratico (liscio) tipi di rampa quando è impostato un valore massimo inferiore per lo strappo Tuttavia, se questi valori massimi rimangono invariati (o aumentano), si applicano le seguenti regole: Per trapezoidale e quadratico tipi di rampa, non c'è mai alcuno spostamento eccessivo. Per il peccato² tipo di rampa, se la nuova posizione di destinazione ei valori limite per l'accelerazione e la decelerazione sono uguali ai vecchi valori, non si ha il superamento della corsa. In tutti gli altri casi, potrebbe esserci un viaggio eccessivo peccato² e quadratico (liscio) tipi di rampa. " }, 
{ "title" : "Movimenti sincroni di due assi ", 
"url" : "_sm_basic_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_sm_overview_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ Panoramica ", 
"snippet" : "Questa sezione fornisce una panoramica dei movimenti per i quali un asse viene spostato in modo sincrono con un altro asse (a seconda del tempo o della posizione. Camme: a seconda di un azionamento (master), un altro azionamento (slave) deve eseguire qualsiasi tipo di movimento definito. Per ulterio...", 
"body" : "Questa sezione fornisce una panoramica dei movimenti per i quali un asse viene spostato in modo sincrono con un altro asse (a seconda del tempo o della posizione. Camme: a seconda di un azionamento (master), un altro azionamento (slave) deve eseguire qualsiasi tipo di movimento definito. Per ulteriori informazioni, vedere: cammeSincronizzazione di due assi con un rapporto di trasmissione definito tramite MC_GearIn , MC_GearOut , E MC_GearInPos . Per ulteriori informazioni su queste funzioni, consultare la documentazione del rispettivo blocco funzione. Offset di fase tra un asse master e uno slave utilizzando MC_Fasatura . Per ulteriori informazioni su questa funzione, consultare la documentazione del blocco funzione. Compensazione del gioco tra componenti meccanici (ad esempio, in un cambio) utilizzando SMC_BacklashCompensation . Per ulteriori informazioni su questa funzione, consultare la documentazione del blocco funzione. " }, 
{ "title" : "camme ", 
"url" : "_sm_f_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_sm_overview_synch_movements_2_axis_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Panoramica ", 
"snippet" : "IL SoftMotion cam è integrato nell'interfaccia utente di CODESYS . Nell'editor camme è possibile realizzare camme e punterie graficamente o mediante tabelle. Non appena viene generato il codice per la corrispondente applicazione, vengono create strutture di dati globali (\"Cam Data\") alle quali può a...", 
"body" : "IL SoftMotion cam è integrato nell'interfaccia utente di CODESYS . Nell'editor camme è possibile realizzare camme e punterie graficamente o mediante tabelle. Non appena viene generato il codice per la corrispondente applicazione, vengono create strutture di dati globali (\"Cam Data\") alle quali può accedere il programma IEC. A questo scopo, il SM3_Basic viene inoltre collegato automaticamente al progetto quando si inserisce un'unità SoftMotion. Per ulteriori informazioni, vedere: Definizione di a E Come creare una telecamera" }, 
{ "title" : "Definizione di a SoftMotion Camera ", 
"url" : "_sm_cam_definition_softmotion_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Definizione di a SoftMotion Camera ", 
"snippet" : "Una camma descrive la dipendenza funzionale di un azionamento (slave) da un altro azionamento (master). La relazione è descritta da una funzione continua (o curva) che mappa un intervallo definito di valori master su valori slave. Per essere più precisi: Dopo aver diviso l'asse master in opportuni s...", 
"body" : "Una camma descrive la dipendenza funzionale di un azionamento (slave) da un altro azionamento (master). La relazione è descritta da una funzione continua (o curva) che mappa un intervallo definito di valori master su valori slave. Per essere più precisi: Dopo aver diviso l'asse master in opportuni segmenti, il grafico di queste funzioni può essere rappresentato su ciascuno di questi intervalli da una linea o da un polinomio di 5° grado. Esempio I valori master vengono applicati all'asse orizzontale e i valori slave all'asse verticale nel grafico della camma. Nell'esempio, i valori master sono compresi tra 0 e 360. Questo intervallo è suddiviso in tre intervalli: (1) Primo intervallo: [0, 140] (2) Secondo intervallo: [140, 280] (3) Terzo intervallo: [280, 360] La funzione (grafico) è lineare nel primo e nel terzo intervallo e il suo grafico viene visualizzato come una linea. Di conseguenza, la sua derivata prima (pendenza) è costante e tutte le derivate superiori sono 0. Nel secondo intervallo, il grafico è descritto da un polinomio di 5° grado. Pertanto, la sua derivata prima è un polinomio di 4° grado, la sua derivata seconda (curvatura) è un polinomio di 3° grado e la sua derivata terza è un polinomio di 2° grado, ecc. Quando la funzione descrive il movimento dello slave in funzione della posizione del master, la sua derivata prima corrisponde alla velocità dello slave e la derivata seconda alla sua accelerazione. Quando si tiene presente questa interpretazione fisica, è ovvio che la mappatura deve essere continua. Ciò significa che il suo grafico non può avere alcun salto. In particolare, la continuità deve essere rispettata anche in ogni punto in cui due intervalli si incontrano. Inoltre, la continuità in generale è richiesta anche dalla prima e dalla seconda derivata. (Infatti queste tre condizioni di continuità ai punti di inizio e di fine di un intervallo determinano i coefficienti del polinomio di 5° grado inserito tra due segmenti retti. Inoltre, è possibile aggiungere punterie (interruttori binari) alla camma in qualsiasi posizione. In questo modo è possibile creare tabelle camme che contengono solo punterie. La posizione slave viene quindi impostata su zero nell'intero campo dei valori master. " }, 
{ "title" : "Panoramica dei tipi di segmenti definiti ", 
"url" : "_sm_overview_segment_types.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Panoramica dei tipi di segmenti definiti ", 
"snippet" : "CODESYS SoftMotion fornisce vari tipi di segmenti per le camme. A seconda del formato di compilazione , sono supportati solo alcuni tipi di segmento: XYVA: solo Line e Poly5. Segmenti: sono supportati tutti i tipi di segmenti. Tipo di segmento Parametri Curva Poly7 Condizioni al contorno Posizione p...", 
"body" : "CODESYS SoftMotion fornisce vari tipi di segmenti per le camme. A seconda del formato di compilazione , sono supportati solo alcuni tipi di segmento: XYVA: solo Line e Poly5. Segmenti: sono supportati tutti i tipi di segmenti. Tipo di segmento Parametri Curva Poly7 Condizioni al contorno Posizione principale Posizione dello schiavo Velocità slave Accelerazione slave Schiavo idiota Poly5 Condizioni al contorno Posizione principale Posizione dello schiavo Velocità slave Accelerazione slave ModifiedSine Condizioni al contorno Posizione principale Posizione dello schiavo Velocità slave Parametri del segmento Qualsiasi parametro del punto di flesso λ (0≤λ ≤1) O parametro di accelerazione C a * (decelerazione massima) Line Condizioni al contorno Posizione principale Posizione dello schiavo InclinedSine Condizioni al contorno Posizione principale Posizione dello schiavo La selezione del tipo di segmento dipende dall'applicazione, poiché ogni tipo ha proprietà dinamiche speciali. Esistono vari tipi di segmenti applicabili a seconda dell'attività di movimento (ad esempio, permanenza, velocità costante La tabella seguente fornisce una panoramica: Abitare (v=0, a=0) Velocità costante (v­­≠0, a=0) Inversione (v=0, a≠0) Movimento (v≠0, a≠0) Abitare (v=0, a=0) Line Poly5\/7 InclinedSine ModifiedSine Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 Velocità costante (v≠0, a=0) Poly5\/7 ModifiedSine Line Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 Inversione (v=0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 Movimento (v≠0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 " }, 
{ "title" : "Struttura dell'editor cam ", 
"url" : "_sm_cam_editor_layout.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Struttura dell'editor cam ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_sm_overview_synch_movements_2_axis_cam_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Struttura dell'editor cam \/ Panoramica ", 
"snippet" : "Aprire l'editor delle camme facendo doppio clic su Camera oggetto nell'albero dei dispositivi. L'editor è composto dalle seguenti schede: Scheda: Camme Scheda: In questo editor si utilizza un editor grafico per creare un percorso camma. Qui è possibile visualizzare e modificare la posizione dello sl...", 
"body" : "Aprire l'editor delle camme facendo doppio clic su Camera oggetto nell'albero dei dispositivi. L'editor è composto dalle seguenti schede: Scheda: Camme Scheda: In questo editor si utilizza un editor grafico per creare un percorso camma. Qui è possibile visualizzare e modificare la posizione dello slave, la velocità dello slave, l'accelerazione dello slave e il jerk dello slave. Nell'editor grafico si riconosce molto rapidamente quando si programma un movimento con elevata accelerazione. Tavolo Cam scheda: In questo editor, i punti base sono presentati in una tabella. Qui è possibile specificare le posizioni e le velocità esatte. Punterie Scheda: In questo editor si programmano le punterie (punti di commutazione) in uno schema. Questa visualizzazione fornisce un'ottima panoramica dell'ordine sequenziale delle punterie. Tavolo punterie scheda: In questo editor i punti di commutazione vengono presentati in una tabella. Qui è possibile specificare i punti di commutazione esatti. Le schede sono suddivise in un editor e in un file Cassetta degli attrezzi vista e Proprietà visualizzazione. Esempio di programma per l'utilizzo dell'editor di camme " }, 
{ "title" : "Scheda: Camme ", 
"url" : "_sm_obj_cam_table_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Struttura dell'editor cam \/ Scheda: Camme ", 
"snippet" : "In questo editor grafico vengono definiti i grafici delle camme. In qualsiasi momento è possibile passare dall'editor grafico all'editor tabulare alternativo ( Scheda: Tabella delle camme). Nell'editor vengono visualizzate le curve di quattro grafici: Posizione dello schiavo (nero) Velocità slave (b...", 
"body" : "In questo editor grafico vengono definiti i grafici delle camme. In qualsiasi momento è possibile passare dall'editor grafico all'editor tabulare alternativo ( Scheda: Tabella delle camme). Nell'editor vengono visualizzate le curve di quattro grafici: Posizione dello schiavo (nero) Velocità slave (blu) Accelerazione slave (verde) schiavo coglione (giallo) L'asse orizzontale di tutti e quattro i sistemi di coordinate mostra l'intervallo dei valori master ([0,360]). L'asse verticale nel diagramma di posizione mostra il campo di valori definito nelle proprietà della camma. L'asse verticale di velocità, accelerazione e strappo viene ridimensionato automaticamente. Ad una nuova camma inserita vengono assegnati i valori di default. Consiste di quattro punti che suddividono il grafico in tre sezioni: [0,120], [120,240] e [240,360]. Ciascuna delle parti di intervallo dei grafici a camme è di tipo Poly5 (polinomio di 5° grado). È possibile modificare tutte le curve. Poiché velocità, accelerazione e strappo sono curve derivate, una modifica in uno dei grafici influisce anche sugli altri. Si modifica l'altezza del diagramma spostando le barre di separazione orizzontali. Visualizzazione: Cassetta degli attrezzi Selezionare Seleziona una riga nella tabella utilizzando questo strumento. I punti selezionati vengono eliminati premendo il tasto Del chiave. Aggiungi punto Aggiungi nuovi punti con questo strumento. Fare clic sul punto di inserimento nel diagramma. Il grafico viene quindi adattato automaticamente in modo che la sua curva attraversi il nuovo punto inserito. Vista \"Proprietà\" X Posizione X dell'asse slave Y Posizione Y dell'asse slave V Velocità dell'asse slave A Accelerazione dell'asse slave J Jerk dell'asse schiavo Per ulteriori informazioni, vedere: Finestra di dialogo: Proprietà – Cam e Come creare una telecamera" }, 
{ "title" : "Scheda: Tabella delle camme ", 
"url" : "_sm_obj_cam_table_cam_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Struttura dell'editor cam \/ Scheda: Tabella delle camme ", 
"snippet" : "In alternativa all'editor grafico è possibile definire i grafici delle camme anche nella tabella delle camme ( Camera scheda). Puoi passare dall'editor tabulare all'editor grafico in qualsiasi momento. La prima riga della tabella contiene sempre la posizione iniziale del master (ei relativi valori d...", 
"body" : "In alternativa all'editor grafico è possibile definire i grafici delle camme anche nella tabella delle camme ( Camera scheda). Puoi passare dall'editor tabulare all'editor grafico in qualsiasi momento. La prima riga della tabella contiene sempre la posizione iniziale del master (ei relativi valori dello slave) e l'ultima riga è sempre la posizione finale. Le linee intermedie definiscono alternativamente segmenti e punti. Inserisce una nuova riga Elimina il segmento selezionato X Posizione X dell'asse slave Y Posizione Y dell'asse slave V Velocità dell'asse slave A Accelerazione dell'asse slave J Jerk dell'asse schiavo Tipo di segmento Line : Linea Poly5 : polinomio di 5° grado Poly7 : Polinomio di 7° grado InclinedSine : Linea sinusoidale inclinata ModifiedSine : Linea sinusoidale modificata Lambda Parametri del punto di flesso per la linea sinusoidale modificata Parametri di accelerazione Parametri di ritardo massimo per la linea sinusoidale modificata I seguenti valori risultano dai valori del rispettivo segmento. Non possono essere modificati. min(posizione) Valore minimo della posizione dello slave massimo (posizione) Valore massimo della posizione dello slave max (velocità) Valore massimo della velocità dello slave, in base all'asse master massimo (accelerazione) Valore massimo dell'accelerazione dello slave, in base all'asse master Visualizzazione: Cassetta degli attrezzi Selezionare Seleziona una riga nella tabella utilizzando questo strumento. I punti selezionati vengono eliminati premendo il tasto Del chiave. Per ulteriori informazioni, vedere: Finestra di dialogo: Proprietà – Cam e Come creare una telecamera" }, 
{ "title" : "Scheda: punterie ", 
"url" : "_sm_obj_cam_table_tappets.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Struttura dell'editor cam \/ Scheda: punterie ", 
"snippet" : "In questo editor grafico vengono definiti i percorsi delle punterie. Un percorso punterie definisce una o più punterie a seconda della posizione del master. Sul bordo superiore della finestra dell'editor, un asse orizzontale si avvicina al campo delle posizioni master. Di seguito sono riportati i si...", 
"body" : "In questo editor grafico vengono definiti i percorsi delle punterie. Un percorso punterie definisce una o più punterie a seconda della posizione del master. Sul bordo superiore della finestra dell'editor, un asse orizzontale si avvicina al campo delle posizioni master. Di seguito sono riportati i singoli percorsi delle punterie. In qualsiasi momento è possibile passare dall'editor grafico all'editor tabulare alternativo ( Scheda: Tabella punterie). \"Track ID\" del percorso punterie Tutte le punterie di un percorso punterie si riferiscono allo stesso interruttore punterie (una variabile di tipo BOOL). Visualizzazione: Cassetta degli attrezzi Selezionare Utilizzare questo strumento per selezionare le punterie. È possibile trascinare le punterie selezionate in un'altra posizione. È possibile modificare l'attributo di accensione\/spegnimento di una punteria facendo clic sull'estremità corrispondente del linea incrociata. Eliminare la punteria selezionata premendo il tasto Del chiave. Aggiungi nuove punterie con questo strumento. Fare clic sul punto di inserimento nel percorso. Vista \"Proprietà\" La punteria è assegnata a un risultato, se è passata dalla posizione dell'asse master in direzione positiva (valori master crescenti) o negativa. X Posizione della punteria Passaggio positivo Attributo di attivazione\/disattivazione Nessuna azione Passa a ON Passa a OFF Invertire Passaggio negativo Attributo di attivazione\/disattivazione Nessuna azione Passa a ON Passa a OFF Invertire Tabella delle possibili combinazioni di attributi punterie Simbolo della punteria Passaggio positivo Passaggio negativo Nessuna azione Nessuna azione Passa a ON Nessuna azione Passa a OFF Nessuna azione Nessuna azione Passa a ON Nessuna azione Passa a OFF Passa a ON Passa a OFF Passa a ON Passa a OFF Passa a OFF Passa a ON Passa a OFF Passa a OFF Invertire Nessuna azione Nessuna azione Invertire Passa a ON Invertire Invertire Passa a ON Invertire Passa a OFF Passa a OFF Invertire Invertire Invertire Per ulteriori informazioni, vedere: Come definire i punti di commutazione" }, 
{ "title" : "Scheda: Tabella punterie ", 
"url" : "_sm_obj_cam_table_tappet_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Struttura dell'editor cam \/ Scheda: Tabella punterie ", 
"snippet" : "In questa tabella tabellare è possibile configurare anche i percorsi delle punterie in alternativa all'editor grafico ( Scheda: punterie). Un percorso punterie definisce una o più punterie a seconda della posizione del master. Nella tabella le righe con le definizioni delle rispettive punterie sono ...", 
"body" : "In questa tabella tabellare è possibile configurare anche i percorsi delle punterie in alternativa all'editor grafico ( Scheda: punterie). Un percorso punterie definisce una o più punterie a seconda della posizione del master. Nella tabella le righe con le definizioni delle rispettive punterie sono elencate sotto ogni riga che definisce un percorso punterie. Puoi passare dall'editor tabulare all'editor grafico in qualsiasi momento. Inserisce una nuova punteria Elimina la punteria ID traccia ID del percorso punterie Tutte le punterie di un percorso punterie si riferiscono allo stesso interruttore punterie (una variabile di tipo BOOL). X Posizione della punteria Passaggio positivo Attributo di attivazione\/disattivazione Nessuna azione Passa a ON Passa a OFF Invertire Passaggio negativo Attributo di attivazione\/disattivazione Nessuna azione Passa a ON Passa a OFF Invertire Visualizzazione: Proprietà La punteria è assegnata a un risultato, se è passata dalla posizione dell'asse master in direzione positiva (valori master crescenti) o negativa. X Posizione della punteria Passaggio positivo Attributo di attivazione\/disattivazione Nessuna azione Passa a ON Passa a OFF Invertire Passaggio negativo Attributo di attivazione\/disattivazione Nessuna azione Passa a ON Passa a OFF Invertire Per ulteriori informazioni, vedere: Come definire i punti di commutazione" }, 
{ "title" : "Come creare una telecamera ", 
"url" : "_sm_cam_creating_a_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Come creare una telecamera ", 
"snippet" : "I passaggi per la creazione di una camma sono spiegati per mezzo di un'applicazione di esempio che descrive una tavola rotante con otto scanalature (divisione a 45°). All'interno, c'è un componente che viene fuso ad ultrasuoni. L'utensile di saldatura viene alimentato da un azionamento lineare dopo ...", 
"body" : "I passaggi per la creazione di una camma sono spiegati per mezzo di un'applicazione di esempio che descrive una tavola rotante con otto scanalature (divisione a 45°). All'interno, c'è un componente che viene fuso ad ultrasuoni. L'utensile di saldatura viene alimentato da un azionamento lineare dopo che la tavola rotante ha ruotato. Dopo la saldatura, l'asse lineare ritorna e la tavola rotante continua a girare. Fasi di lavoro La tavola rotante ruota di 45° (durata: 400 ms). La testa di saldatura viene spostata verso il basso di un asse verticale di 250 mm (durata: 200 ms). Avviare la saldatura (durata: 1200 ms). La testa di saldatura viene spostata verso l'alto di un asse verticale di 250 mm (durata: 200 ms). Dai tempi totali risulta un tempo di ciclo di 2000 ms. L'applicazione è implementata per mezzo di un asse master virtuale che funziona in modo continuo (modulo). Il valore finale dell'asse viene proiettato in base al tempo di ciclo di 2000 ms. La tavola rotante si ottiene come una camma (modulo; valore finale: 45°). L'asse verticale viene realizzato anche come camma (limitata; valore finale: 300 mm). Il processo di saldatura è controllato da una punteria. Impostazione delle proprietà della camma Seleziona il Tavola rotante cam nell'albero dei dispositivi. Clic Proprietà nel Visualizzazione menu o nel menu contestuale. Seleziona il Camera scheda. Specificare i seguenti valori: Posizione di partenza principale : 0 Posizione finale principale : 2000 Posizione di partenza dello schiavo : 0 Posizione finale slave : 45 Transizione graduale : (Disabilitato) Clic ok per uscire dalla finestra di dialogo. Confermare la finestra di dialogo per la modifica dell'oggetto camma. Modificare i valori per il Asse verticale cam nello stesso modo: Posizione di partenza principale : 0 Posizione finale principale : 2000 Posizione di partenza dello schiavo : 0 Posizione finale slave : 300 Transizione graduale : (abilitato) Clic ok per uscire dalla finestra di dialogo. Confermare la finestra di dialogo per la modifica dell'oggetto camma. " }, 
{ "title" : "Aggiunta di una cam all'albero dei dispositivi ", 
"url" : "_sm_cam_creating_a_cam.html#UUID-7c227a8f-47be-4a95-ca96-f0cd1d78635d_id_edb85f246cc9d9f4c0a8646368ed3bd6_id_fa86c256038b2152c0a864632d864483", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Come creare una telecamera \/ Aggiunta di una cam all'albero dei dispositivi ", 
"snippet" : "Requisito: è selezionato un controller SoftMotion. Nella struttura dei dispositivi, selezionare il Applicazione oggetto. Clic Progetto → Aggiungi oggetto → Tabella cam . Specificare il nome Tavola rotante per la cam e fare clic ok . L'oggetto viene inserito nell'albero dei dispositivi. Si apre l'edi...", 
"body" : "Requisito: è selezionato un controller SoftMotion. Nella struttura dei dispositivi, selezionare il Applicazione oggetto. Clic Progetto → Aggiungi oggetto → Tabella cam . Specificare il nome Tavola rotante per la cam e fare clic ok . L'oggetto viene inserito nell'albero dei dispositivi. Si apre l'editor di camme. Inserisci un'altra cam denominata Asse verticale . " }, 
{ "title" : "Come modificare il percorso della camma ", 
"url" : "_sm_cam_changing_the_course.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Come modificare il percorso della camma ", 
"snippet" : "Queste istruzioni utilizzano l'esempio di Come creare una telecamera capitolo per dimostrare come cambiare una camma....", 
"body" : "Queste istruzioni utilizzano l'esempio di Come creare una telecamera capitolo per dimostrare come cambiare una camma. " }, 
{ "title" : "Modifica del percorso con l'editor grafico ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_0e7e8ac72c554f26c0a86463347ccca5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Come modificare il percorso della camma \/ Modifica del percorso con l'editor grafico ", 
"snippet" : "Apri il Tavola rotante cam nell'editor. Il Camera la scheda è visibile. Selezionare il punto a 120 ed eliminarlo premendo il tasto cancella ( Del ). Elimina anche il punto a 240. Seleziona il Aggiungi punto strumento dal Cassetta degli attrezzi Visualizza. Il puntatore del mouse si trasforma in un m...", 
"body" : "Apri il Tavola rotante cam nell'editor. Il Camera la scheda è visibile. Selezionare il punto a 120 ed eliminarlo premendo il tasto cancella ( Del ). Elimina anche il punto a 240. Seleziona il Aggiungi punto strumento dal Cassetta degli attrezzi Visualizza. Il puntatore del mouse si trasforma in un mirino quando lo sposti nell'editor. Clicca vicino Posizione di maestro 400 e Posizione schiava 45 nei grafici superiori (posizione slave). La curva della posizione slave viene modificata. Anche le curve di velocità, accelerazione e jerk cambiano. Selezionare il nuovo punto inserito facendo clic su di esso. Trascina il punto in un'altra posizione. La curva della posizione slave viene adattata di conseguenza. Cambiare il X e Y proprietà ai valori esatti di 400 e 45, rispettivamente. Allo stesso modo, modifica il valore X a 45 del punto nella posizione master 2000. Seleziona il Selezionare strumento dal Cassetta degli attrezzi Visualizza. Selezionare il secondo elemento della curva (tra 400 e 2000). Cambiare il Tipo di segmento proprietà a Linea . Controllare la curva nell'editor grafico. Schermo: " }, 
{ "title" : "Modifica del percorso con una tabella camme ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_a888a2ff556a11e6abf6d2d0503b3e46", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Come modificare il percorso della camma \/ Modifica del percorso con una tabella camme ", 
"snippet" : "Apri il Asse verticale cam nell'editor. Il Camera la scheda è visibile. Seleziona il Tavolo a camme scheda. Clicca il simbolo per cancellare il punto a 120. Cancellare anche il punto a 240. Clicca il simbolo. Un nuovo punto e un nuovo segmento vengono inseriti in (1000\/150). Aggiungi altri due punti...", 
"body" : "Apri il Asse verticale cam nell'editor. Il Camera la scheda è visibile. Seleziona il Tavolo a camme scheda. Clicca il simbolo per cancellare il punto a 120. Cancellare anche il punto a 240. Clicca il simbolo. Un nuovo punto e un nuovo segmento vengono inseriti in (1000\/150). Aggiungi altri due punti. Modificare i valori X\/Y dei seguenti punti: Punto 1: 0 \/ 0 Punto 2: 400 \/ 0 Punto 3: 600 \/ 250 Punto 4: 1800 \/ 250 Punto 5: 2000 \/ 0 La curva della posizione slave viene modificata. Anche le curve di velocità, accelerazione e jerk cambiano. Nella tabella delle camme, cambia il Tipo di segmento del primo e terzo segmento a Linea . Controllare la curva nell'editor grafico. Schermo: In pratica, le curve delle diverse camme vengono definite frequentemente come sovrapposte per risparmiare tempo ciclo. Nell'esempio sopra, l'asse verticale potrebbe già iniziare il movimento mentre la tavola rotante è ancora in movimento (ad esempio, a X: 350). " }, 
{ "title" : "Come definire i punti di commutazione ", 
"url" : "_sm_cam_defining_tappets.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Come definire i punti di commutazione ", 
"snippet" : "Utilizzare i punti di commutazione per attivare eventi a seconda della posizione principale. Può trattarsi, ad esempio, dell'impostazione di un'uscita o del richiamo di un blocco funzione. Queste istruzioni utilizzano l'esempio di Come creare una telecamera capitolo per dimostrare come definire i pu...", 
"body" : "Utilizzare i punti di commutazione per attivare eventi a seconda della posizione principale. Può trattarsi, ad esempio, dell'impostazione di un'uscita o del richiamo di un blocco funzione. Queste istruzioni utilizzano l'esempio di Come creare una telecamera capitolo per dimostrare come definire i punti di commutazione. In questo esempio, la punteria avvia e interrompe il processo di saldatura. Apri il Asse verticale cam nell'editor. Il Camera la scheda è visibile. Seleziona il Scheda: punterie. Nel Cassetta degli attrezzi visualizzare, selezionare il Aggiungi punterie attrezzo. Il puntatore del mouse si trasforma in un mirino quando lo sposti nell'editor. Fare clic sotto la posizione principale vicino alla posizione 600. Una punteria viene inserita nel percorso della punteria 1. Seleziona la punteria. Modificare i valori della punteria nella vista \"Proprietà\". X : 600 Passaggio positivo : Accendere Passaggio negativo : Nessuna azione Inserire un'altra punteria nel percorso punterie 1 in X: 1800. X : 1800 Passaggio positivo : Spegnere Passaggio negativo : Nessuna azione Controlla il risultato. Puoi anche modificare i valori per Passaggio positivo e Passaggio negativo facendo clic sulla rispettiva estremità del mirino. Nota che puoi anche impostare i punti di commutazione su Tavolo punterie scheda. Questo editor fornisce le stesse opzioni, ma in forma tabellare. " }, 
{ "title" : "Creazione di camme a livello di codice ", 
"url" : "_sm_basic_cam_programmatic_creation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Creazione di camme a livello di codice ", 
"snippet" : "Come di CODESYS SoftMotion versione 4.17.0.0, il CamBuilder Il blocco funzione fornisce un'interfaccia per la creazione di camme a livello di programmazione direttamente nell'applicazione IEC. Per ulteriori informazioni, vedere l'esempio: Creazione di camme a livello di codice...", 
"body" : "Come di CODESYS SoftMotion versione 4.17.0.0, il CamBuilder Il blocco funzione fornisce un'interfaccia per la creazione di camme a livello di programmazione direttamente nell'applicazione IEC. Per ulteriori informazioni, vedere l'esempio: Creazione di camme a livello di codice" }, 
{ "title" : "Utilizzo del blocco funzione CamBuilder (a partire da SM 4.17.0.0) ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4552813176932834337885510319", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Creazione di camme a livello di codice \/ Utilizzo del blocco funzione CamBuilder (a partire da SM 4.17.0.0) ", 
"snippet" : "Per impostazione predefinita, quando si crea un oggetto camma nell'albero dei dispositivi, viene creata la seguente camma elettronica: La camma è composta da tre polinomi di quinto grado con i seguenti quattro valori limite: X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 Per creare questa camma...", 
"body" : "Per impostazione predefinita, quando si crea un oggetto camma nell'albero dei dispositivi, viene creata la seguente camma elettronica: La camma è composta da tre polinomi di quinto grado con i seguenti quattro valori limite: X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 Per creare questa camma a livello di codice, un'istanza di CamBuilder il blocco funzione viene dichiarato per primo: VAR\n camBuilder : SMCB.CamBuilder;\nEND_VAR Nella parte di implementazione, il CamBuilder l'istanza deve prima essere inizializzata. Tre segmenti di tipo Poly5 può quindi essere aggiunto utilizzando il file Append metodo: camBuilder.Init();\n \ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(120, 120, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(240, 240, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(360, 360))); I polinomi sono definiti tramite le condizioni al contorno sinistra e destra. Nell'esempio, il BoundImplicit la funzione viene sempre utilizzata per il confine sinistro. Di conseguenza, viene applicata la condizione al contorno destra del segmento precedente. Se la BoundImplicit viene utilizzata come limite sinistro per il primo segmento, quindi inizia da zero: in questo esempio, con il segmento Poly5 in (X, Y, V, A) = (0, 0, 0, 0). Quando il MC_CamTableSelect e MC_CamIn vengono utilizzati i blocchi funzionali, la camma è definita in CamBuilder il blocco funzionale deve infine essere convertito in un MC_CamRef . Esistono due modi per farlo, a seconda di dove viene chiamato CamBuilder Chiamare il CamBuilder nel task del bus: Innanzitutto, la parte della dichiarazione deve essere estesa dalle istanze corrispondenti: VAR\n    ...\n    camRef : MC_CAM_REF;\n    aCamSegments : ARRAY[1..3] OF SMC_CAM_SEGMENT;\nEND_VAR Quindi l'istanza del blocco funzionale MC_CAM_REF viene inizializzato e scritto utilizzando Write metodo del CamBuilder blocco funzionale. SMCB.InitCamRef(camRef, ADR(aCamSegments), XSIZEOF(aCamSegments));\ncamBuilder.Write(camRef); Chiamare CamBuilder in un'altra attività (multitask, multicore): Innanzitutto, viene creata un'istanza multitask\/multicore-safe della videocamera in un GVL, a cui si accede sia dal task bus che dal task CamBuilder. VAR_GLOBAL\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR Quindi la creazione della camma nell'altra attività viene avviata dall'attività del bus. Per determinare nell'operazione del bus quando la nuova camma è stata scritta nell'altra operazione, il programma ricorda CamId nel STATE_INIT_ONLINE_TABLE_MULTITASK prima che la camma venga creata. Quindi la creazione della camma viene avviata nell'altra attività nel STATE_START_CREATE_ONLINE_TABLE_MULTITASK stato. Quindi, la cam creata viene letta nel STATE_READ_ONLINE_TABLE_MULTITASK stato. PROGRAM BUS_TASK\nVAR\n    state : UDINT;\n    error : SMC_ERROR;\n    camIdBeforeCreate : UDINT;\n    camSegments: ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    camRef: MC_CAM_REF;\nEND_VAR\nVAR CONSTANT\n    STATE_INIT_ONLINE_TABLE_MULTITASK : UDINT := 0;\n    STATE_START_CREATE_ONLINE_TABLE_MULTITASK : UDINT := 10;\n    STATE_READ_ONLINE_TABLE_MULTITASK : UDINT := 20;\n    STATE_ERROR : UDINT := 1000;\nEND_VAR\n\n\nCASE state OF\nSTATE_INIT_ONLINE_TABLE_MULTITASK:\n    camIdBeforeCreate := GVL.safeCam.CamId;\n\n    state := STATE_START_CREATE_ONLINE_TABLE_MULTITASK;\n\nSTATE_START_CREATE_ONLINE_TABLE_MULTITASK:\n    CamBuilderTask.BuildCam := TRUE;\n\n    state := STATE_READ_ONLINE_TABLE_MULTITASK;\n\nSTATE_READ_ONLINE_TABLE_MULTITASK:\n    IF CamBuilderTask.Error THEN\n        error := CamBuilderTask.ErrorId;\n        state := state + STATE_ERROR;\n    ELSIF GVL.safeCam.CamId <> camIdBeforeCreate THEN\n        error := GVL.safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n        IF error = SMC_NO_ERROR THEN\n            state := state + 10;\n        ELSE\n            state := state + STATE_ERROR;\n        END_IF\n    END_IF\nEND_CASE Nel task CamBuilder, la cam multitask\/multicore-safe viene scritta chiamando CamBuilder.WriteMulticoreSafe() : PROGRAM CamBuilderTask\nVAR_INPUT\n    BuildCam : BOOL;\nEND_VAR\nVAR_OUTPUT\n    Error : BOOL;\n    ErrorId : SMC_ERROR;\nEND_VAR\nVAR\n    camBuilder : SMCB.CamBuilder;\nEND_VAR\n\nIF BuildCam THEN\n    BuildCam := FALSE;\n\n    camBuilder.Init();\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(120, 120, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(240, 240, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(360, 360)));\n     \n Error := camBuilder.IsErrorPending(errorID=> ErrorId);\n\n    IF NOT Error THEN\n        ErrorId := camBuilder.WriteMulticoreSafe(GVL.safeCam);\n        Error := ErrorId <> SMC_NO_ERROR;\n    END_IF\nEND_IF " }, 
{ "title" : "Condizioni al contorno implicite ed esplicite ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930557874", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Creazione di camme a livello di codice \/ Utilizzo del blocco funzione CamBuilder (a partire da SM 4.17.0.0) \/ Condizioni al contorno implicite ed esplicite ", 
"snippet" : "Una condizione al contorno implicita definita con BoundImplicit assicura che la transizione al segmento adiacente sia il più agevole possibile. Per fare ciò, la condizione al contorno del segmento adiacente deve essere definita esplicitamente utilizzando il Bound metodo. Quindi se la condizione al c...", 
"body" : "Una condizione al contorno implicita definita con BoundImplicit assicura che la transizione al segmento adiacente sia il più agevole possibile. Per fare ciò, la condizione al contorno del segmento adiacente deve essere definita esplicitamente utilizzando il Bound metodo. Quindi se la condizione al contorno sinistra di un segmento è implicita, allora la condizione al contorno destra del segmento precedente deve essere esplicita. Viceversa, se la condizione al contorno destra è implicita, allora la condizione al contorno sinistra del segmento successivo deve essere esplicita. Il caso d'uso più comune è presumibilmente che solo le giuste condizioni al contorno dei segmenti siano specificate esplicitamente, come nell'esempio sopra. A causa delle condizioni al contorno sinistro implicite, le transizioni dei segmenti sono automaticamente il più fluide possibile e non ci sono spazi vuoti nell'area di definizione. L’esempio seguente è un caso semplice in cui è utile deviare da questo approccio: L'asse slave dovrebbe spostarsi a velocità costante dalla posizione 20 a 100: camBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100))); Prima e dopo questo, a Poly5 il segmento viene utilizzato per l'accelerazione e la decelerazione: camBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.BoundImplicit()));\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(120, 120, 0))); La camma così definita presenta fasi di accelerazione e decelerazione indesiderate nei segmenti Poly5 (velocità in blu): Per evitare ciò è sufficiente regolare la posizione del master nel segmento di tipo Line (ad esempio, quello del confine sinistro da 20 a 30 e quello del confine destro da 100 a 90): ...\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(30, 20),\n SMCB.Bound(90, 100)));\n... Non è necessario modificare i segmenti del tipo Poly5 perché vengono aggiunti automaticamente al segmento di linea nel modo più fluido possibile a causa delle condizioni al contorno definite utilizzando BoundImplicit funzione. " }, 
{ "title" : "Gestione degli errori ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930649954", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Creazione di camme a livello di codice \/ Utilizzo del blocco funzione CamBuilder (a partire da SM 4.17.0.0) \/ Gestione degli errori ", 
"snippet" : "IL Append metodo del CamBuilder ritorni del blocco funzione TRUE quando un segmento è stato aggiunto con successo e ritorna FALSE se si è verificato un errore. Dopo un errore non è possibile aggiungere altri segmenti e il file CamBuilder il blocco funzione deve essere reinizializzato utilizzando il ...", 
"body" : "IL Append metodo del CamBuilder ritorni del blocco funzione TRUE quando un segmento è stato aggiunto con successo e ritorna FALSE se si è verificato un errore. Dopo un errore non è possibile aggiungere altri segmenti e il file CamBuilder il blocco funzione deve essere reinizializzato utilizzando il comando Init metodo. La causa dell'errore può essere determinata utilizzando IsErrorPending metodo: camBuilder.IsErrorPending(errorId=> errorId); " }, 
{ "title" : "Creazione manuale della struttura dati MC_CAM_REF (prima di SM 4.17.0.0) ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4565212026644834337937734299", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Creazione di camme a livello di codice \/ Creazione manuale della struttura dati MC_CAM_REF (prima di SM 4.17.0.0) ", 
"snippet" : "Si consiglia di utilizzare il SM3_CamBuilder biblioteca a partire da CODESYS SoftMotion 4.17.0.0....", 
"body" : "Si consiglia di utilizzare il SM3_CamBuilder biblioteca a partire da CODESYS SoftMotion 4.17.0.0. " }, 
{ "title" : "Strutture dati delle camme ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793858538", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Creazione di camme a livello di codice \/ Creazione manuale della struttura dati MC_CAM_REF (prima di SM 4.17.0.0) \/ Strutture dati delle camme ", 
"snippet" : "Durante la compilazione del progetto, i dati camma creati vengono convertiti internamente in un elenco di variabili globali. Cliccando Visualizza il codice generato nell'editor camme è possibile visualizzare le variabili globali create automaticamente. Ogni camma è rappresentata dalla struttura dati...", 
"body" : "Durante la compilazione del progetto, i dati camma creati vengono convertiti internamente in un elenco di variabili globali. Cliccando Visualizza il codice generato nell'editor camme è possibile visualizzare le variabili globali create automaticamente. Ogni camma è rappresentata dalla struttura dati MC_CAM_REF . È possibile accedere a questa struttura dati tramite il programma IEC o preelaborando funzioni e blocchi funzionali. È disponibile presso il SM3_Basic biblioteca. Un blocco funzione che descrive una camma può anche essere generato o popolato dal programma IEC in fase di esecuzione. Esempio Definizione della struttura dei dati: TYPE mySMC_CAMTable_LREAL_10000_2 :\nSTRUCT\n Table: ARRAY[0..9999] OF ARRAY[0..1] OF LREAL;\n (* set all scaling definitions to 0 and 1\n result: all values of the table are not scaled *)\n fEditorMasterMin: REAL := 0;\n fEditorMasterMax: REAL := 1;\n fEditorSlaveMin: REAL := 0;\n fEditorSlaveMax: REAL := 1;\n fTableMasterMin: REAL := 0;\n fTableMasterMax: REAL := 1;\n fTableSlaveMin: REAL := 0;\n fTableSlaveMax: REAL := 1;\nEND_STRUCT\nEND_TYPE Istanziare la struttura dei dati: Cam: MC_CAM_REF;\nCam_PointArray : mySMC_CAMTable_LREAL_10000_2; Calcolo della camma: Cam.byType:=2;\nCam.byVarType:=6;\nCam.nTappets:=0;\nCam.strCAMName:='myCAM';\nCam.pce:= ADR(CAM_PointArray);\nFOR i:=0 TO 9999 DO\n (* example cam: master 0..360, slave 0..100,\n constant velocity *)\n Cam_PointArray.Table[i][0]:=UDINT_TO_LREAL(I)\/10000 * 360; (* X *)\n Cam_PointArray.Table[i][1]:=UDINT_TO_LREAL(I)\/10000 * 100; (* Y *)\nEND_FOR\nCam.nElements:=10000\nCam.xStart:=0.0;\nCam.xEnd:=360.0; " }, 
{ "title" : "Camme generate manualmente ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793936406", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Creazione di camme a livello di codice \/ Creazione manuale della struttura dati MC_CAM_REF (prima di SM 4.17.0.0) \/ Camme generate manualmente ", 
"snippet" : "È possibile creare una camma elettronica in un programma IEC senza utilizzare l'editor camma. Esempio Dichiarazione: VAR i: INT; CAM: MC_CAM_REF := ( byType:=2, (* non-equidistant *) byVarType:=2, (* UINT *) nElements:=128, xStart:=0, xEnd:=360); Table: SMC_CAMTable_UINT_128_2 := ( fEditorMasterMin ...", 
"body" : "È possibile creare una camma elettronica in un programma IEC senza utilizzare l'editor camma. Esempio Dichiarazione: VAR\ni: INT;\nCAM: MC_CAM_REF := (\n byType:=2, (* non-equidistant *)\n byVarType:=2, (* UINT *)\n nElements:=128,\n xStart:=0,\n xEnd:=360);\nTable: SMC_CAMTable_UINT_128_2 := (\n fEditorMasterMin := 0, fEditorMasterMax := 360,\n fTableMasterMin := 0, fTableMasterMax := 6000,\n fEditorSlaveMin := 0, fEditorSlaveMax := 360,\n fTableSlaveMin := 0, fTableSlaveMax := 6000);\nEND_VAR Implementazione: (* Create cam disk (example straight line); unambiguous *)\nFOR i:=0 TO 127 DO\n Table.Table[i][0] := Table.Table[i][1] := REAL_TO_UINT(i \/ 127.0 * 6000);\nEND_FOR\n(* Link pointer; must be done in every cycle! *)\nCAM.pce := ADR(Table); Questa camma generata può essere specificata nel file MC_CamTableSelect blocco funzione e il suo output riutilizzato MC_CamIn . " }, 
{ "title" : "Compilazione delle definizioni di camma ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793975398", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Creazione di camme a livello di codice \/ Creazione manuale della struttura dati MC_CAM_REF (prima di SM 4.17.0.0) \/ Compilazione delle definizioni di camma ", 
"snippet" : "In fase di compilazione, variabili di tipo MC_CAM_REF vengono creati per una camma. Includono una descrizione di ciascun segmento della camma. Strutture dati di questo tipo vengono passate al file MC_CamTableSelect blocco funzione. La struttura fa parte del SM3_Basic biblioteca....", 
"body" : "In fase di compilazione, variabili di tipo MC_CAM_REF vengono creati per una camma. Includono una descrizione di ciascun segmento della camma. Strutture dati di questo tipo vengono passate al file MC_CamTableSelect blocco funzione. La struttura fa parte del SM3_Basic biblioteca. " }, 
{ "title" : "Passaggio tra le camme ", 
"url" : "_sm_cam_switch_between_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Passaggio tra le camme ", 
"snippet" : "Fondamentalmente, puoi passare da una telecamera all'altra in qualsiasi momento. Tuttavia, dovresti considerare alcuni punti: Nell'editor camma, la posizione dello slave è definita in modo univoco come valore della funzione della camma. Questa funzione è definita nel campo dei valori master e può es...", 
"body" : "Fondamentalmente, puoi passare da una telecamera all'altra in qualsiasi momento. Tuttavia, dovresti considerare alcuni punti: Nell'editor camma, la posizione dello slave è definita in modo univoco come valore della funzione della camma. Questa funzione è definita nel campo dei valori master e può essere espressa come segue: SlavePosition = CAM( MasterPosition ) Poiché la posizione attuale dell'azionamento master si discosta generalmente dal campo dei valori master, per rappresentare un argomento valido è necessario scalare la posizione master nel campo di definizione della funzione camma: SlavePosition = CAM( MasterScale*MasterPosition + MasterOffset ) In modo simile, devi scalare il valore della funzione (la posizione slave) se l'inizio della camma è in modalità Absolute porterebbe ad un salto: SlavePosition = SlaveScale*CAM( MasterPosition ) + SlaveOffset Potrebbe essere necessario applicare entrambi i valori di ridimensionamento, il che risulta quanto segue: Slaveposition = SlaveScale*CAM( MasterScale*Masterposition + MasterOffset ) + SlaveOffset I valori appropriati per i parametri di ridimensionamento e offset possono variare da periodo a periodo. Il passaggio da una camma all'altra può essere effettuato in tre modi: Avviare la seconda camma tramite una seconda istanza di MC_CamIn con BufferMode = MC_BUFFER_MODE.Buffered , StartMode = relative , MasterAbsolute = FALSE , E SlaveAbsolute = FALSE . Come di CODESYS SoftMotion versione 4.17.0.0 Inizio della nuova camma mediante assegnazione MC_CamIn.CamTableID alla nuova cam (nessun riavvio del MC_CamIn blocco funzione richiesto). Questa variante è consigliata se si applicano i seguenti punti al tuo caso d'uso: Tutte le camme seguenti dovrebbero essere eseguite relativamente con MasterAbsolute = FALSE o SlaveAbsolute = FALSE . La nuova camma dovrebbe partire esattamente alla fine della precedente. Nessun altro parametro viene modificato (esempio: SlaveOffset ). Il salto, spiegato nell'esempio seguente per camme periodiche e SlaveAbsolute = FALSE , fa non valgono per questa variante perché la camma successiva si trova esattamente nelle posizioni finali della camma precedente. La nuova camma viene posizionata esattamente alla fine della camma precedente solo se il passaggio alla nuova camma avviene nello stesso ciclo in cui la camma precedente riporta EndOfProfile = TRUE . Avvia la nuova cam riavviando il MC_CamIn blocco funzione. Questa variante è consigliata se è necessario modificare i parametri per il corretto funzionamento della nuova camma (ad esempio, SlaveOffset dal seguente esempio). Si applicano le restrizioni dell'esempio seguente. Esempio Nell'esempio seguente si passa da CAM1 a CAM2 : CAM1 è costituito da un polinomio di 5° ordine seguito da due segmenti di linea. CAM2 è costituito da due segmenti di linea seguiti da un polinomio di 5° ordine. Quando si passa da una telecamera all'altra, è necessario considerare quanto segue: Per evitare salti, i valori di velocità e accelerazione al punto finale della prima camma dovrebbero coincidere con i valori al punto di partenza della seconda camma. Nell'esempio questa condizione è soddisfatta perché al punto finale di CAM1 e il punto di partenza di CAM2 . Puoi avviare la seconda cam Relative quando è stata definita la posizione iniziale dello slave come 0. Tuttavia, la prima camma deve essere in rodaggio non-periodic modalità. Altrimenti, se CAM1 erano periodici, poi il Relative l'impostazione comporterebbe un salto. L'ingrandimento mostra la transizione da CAM1 a CAM2 . Le linee blu contrassegnano le valutazioni delle funzioni camma nelle posizioni master x1 e x2 . Ora esamineremo il caso sfavorevole di periodic : MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=TRUE); Il richiamo avvia una valutazione della camma nella posizione master x1 , che è inferiore alla posizione finale del master di CAM1 . Poi CAM1 viene valutato per impostazione predefinita e restituisce un punto 1 come posizione per lo schiavo. CAM(x2, CAM1, PERIODIC:=TRUE); Per la successiva chiamata del modulo, la posizione master x2 è al di fuori dell'intervallo di valori master di CAM1 , il cui limite è segnato dalla linea tratteggiata verde e coincide con l'asse orizzontale del punto 3p . quindi, il EndOfProfile è impostato. Perché CAM1 è stato avviato nel periodic modalità, il suo riavvio avviene alla fine dell'intervallo di valori, che alla fine cede il punto 2p come risultato della chiamata del modulo. CAM(EXECUTE:=FALSE); Passa alla nuova camma CAM(x2, CAM2, PERIODIC:=TRUE); Seconda valutazione in posizione magistrale x2 . Questa volta, il nuovo CAM2 viene valutato. A seguito di CAM2 è iniziato in Relative modalità, la posizione attuale dello slave ( 2p ) viene aggiunto come offset all'immagine della funzione camma di CAM2 . Questo sposta il punto iniziale del suo grafico nel punto 3p e la sua valutazione nella posizione di master x2 rende il punto 4p , e quindi un salto sfavorevole. Seleziona il non-periodic modalità per evitare salti: MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=FALSE); Il richiamo avvia una valutazione della camma nella posizione master x1 , che è inferiore alla posizione finale del master di CAM1 . Poi CAM1 viene valutato di default e restituisce il punto 1 come posizione per lo slave. CAM(x2, CAM1, PERIODIC:=FALSE); Per la successiva chiamata del modulo, la posizione master x2 è al di fuori dell'intervallo di valori master di CAM1 , il cui limite è segnato dalla linea tratteggiata verde e coincide con l'asse orizzontale del punto 3n . quindi, il EndOfProfile è impostato. Perché CAM1 è stato avviato nel non-periodic modalità, posizione slave ( 2n ) assegnato alla posizione master x2 è identico alla posizione dello slave al raggiungimento della fine del campo di valori CAM1 ( 3n ). CAM(EXECUTE:=FALSE); Passa alla nuova camma. CAM(x2, CAM2, PERIODIC:=FALSE); Seconda valutazione in posizione magistrale x2 . Questa volta, il nuovo CAM2 viene valutato. A seguito di CAM2 è iniziato in Relative modalità, la posizione attuale dello slave ( 2n ) viene aggiunto come offset all'immagine della funzione camma di CAM2 . Questo sposta il punto iniziale del suo grafico nel punto 3n e la sua valutazione nella posizione di master x2 rende il punto 4n , che si trova sulla retta specifica passante per i punti 1 e 3n . Per avviare la camma Absolute modalità, è necessario assicurarsi che lo slave sia in una posizione di partenza appropriata. Se il campo di valori del master coincide con il periodo dello slave, la commutazione tra camme non presenta complicazioni, indipendentemente dal fatto che le camme siano periodiche o meno. Nell'esempio sopra, puoi iniziare CAM2 in Absolute modalità quando i periodi del master e dello slave concordano con l'intervallo di valori master di CAM2 (ognuno è a 360°). In caso contrario, ad esempio quando è il periodo dello schiavo 270° (indicato dalla linea azzurra), quindi il Absolute opzione non è consentita senza intraprendere ulteriori azioni. In questo caso lo slave è a 90° quando si passa da CAM1 a CAM2 . Di partenza CAM2 in Absolute la modalità provoca un salto a 0° (indicato da una linea grigia). Tuttavia, il salto può essere impedito impostando l'offset slave sul valore appropriato di 90°. " }, 
{ "title" : "Camme periodiche ", 
"url" : "_sm_basic_periodic_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Camme periodiche ", 
"snippet" : "Una camma può essere eseguita ripetutamente quando Periodic ingresso del MC_CamTableSelect il blocco funzione è impostato su TRUE . Successivamente la camma si riavvia automaticamente una volta raggiunta la posizione finale. Se questo input è FALSE , poi il EndOfProfile variabile di uscita del MC_Ca...", 
"body" : "Una camma può essere eseguita ripetutamente quando Periodic ingresso del MC_CamTableSelect il blocco funzione è impostato su TRUE . Successivamente la camma si riavvia automaticamente una volta raggiunta la posizione finale. Se questo input è FALSE , poi il EndOfProfile variabile di uscita del MC_CamIn il blocco funzione è impostato su TRUE quando viene raggiunta la posizione finale del master. Lo slave si ferma nella sua posizione attuale. Si noti che l'attività della camma non si arresta dopo aver lasciato l'intervallo dei valori master. Quando l'azionamento master rientra nell'intervallo dei valori master, l'azionamento slave segue nuovamente la camma. Comportamento in caso di Slave.EndPosition <> Slave.StartPosition : Il blocco funzione MC_CamIn calcola un offset interno alla fine di un periodo. Nel periodo successivo la camma viene spostata di questo offset in modo che continui nella posizione attuale dello slave e quindi eviti salti. Per una camma periodica è possibile attivare il Transizione graduale opzione nelle proprietà della camma. Viene utilizzato per evitare che si verifichino salti durante la transizione da un periodo all'altro. Quindi lo slave ha la stessa velocità e accelerazione nella posizione finale e nella posizione iniziale. Il periodo e l'avanzamento sono misurati nelle unità di scala slave. Anche se non selezioni il Transizione graduale opzione, la camma può essere azionata in modo continuo. In questo caso, il tuo compito è assicurarti che la coerenza delle transizioni sia soddisfatta in misura sufficiente. " }, 
{ "title" : "Elemento di visualizzazione Online Cam Editor ", 
"url" : "_sm_cam_visu_elem_online_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Elemento di visualizzazione Online Cam Editor ", 
"snippet" : "L'editor di webcam online è un modello di visualizzazione che mostra una videocamera nella visualizzazione. Con questo elemento, puoi modificare la videocamera in modalità online L'elemento di visualizzazione è reso disponibile in un modello di visualizzazione ( SMC_Visu_CamEditor ) del SM3_Basic_Vi...", 
"body" : "L'editor di webcam online è un modello di visualizzazione che mostra una videocamera nella visualizzazione. Con questo elemento, puoi modificare la videocamera in modalità online L'elemento di visualizzazione è reso disponibile in un modello di visualizzazione ( SMC_Visu_CamEditor ) del SM3_Basic_Visu libreria. La trovi nell'editor di visualizzazione in Casella degli attrezzi visualizza in SM3_basic_visu etichetta. Le SMC_Visu_CamEditor viene inserito nella visualizzazione tramite una cornice. Per ulteriori informazioni su questo elemento di visualizzazione, vedere: Elemento di visualizzazione: Frame . Oltre alle proprietà dell'elemento frame, questo modello contiene le seguenti proprietà: Proprietà Descrizione SafeCam Riferimento alla videocamera da modificare Mostra posizione Variabile booleana per attivare e disattivare la visualizzazione della curva di posizione Mostra velocità Variabile booleana per attivare e disattivare la visualizzazione della curva di velocità Mostra accelerazione Variabile booleana per attivare e disattivare la visualizzazione della curva di accelerazione Mostrare cretino Variabile booleana per attivare e disattivare la visualizzazione della curva jerk Mostra segmento selezionato Variabile booleana per attivare e disattivare l'evidenziazione del segmento selezionato La videocamera da modificare viene trasferita tramite un'istanza del SMCB.CAM_REF_MULTICORE_SAFE blocco funzionale. PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR " }, 
{ "title" : "Editor di camme in modalità online ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_id_ba4cc02c6ccda90bc0a864637badf4e0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Elemento di visualizzazione Online Cam Editor \/ Editor di camme in modalità online ", 
"snippet" : "In modalità online, i singoli segmenti della videocamera possono essere selezionati nel grafico. L'editor di segmenti sul lato destro può essere utilizzato per aggiungere ed eliminare segmenti, nonché per adattare le condizioni al contorno del (1) Camma di carico Carica la camma configurata nell'edi...", 
"body" : "In modalità online, i singoli segmenti della videocamera possono essere selezionati nel grafico. L'editor di segmenti sul lato destro può essere utilizzato per aggiungere ed eliminare segmenti, nonché per adattare le condizioni al contorno del (1) Camma di carico Carica la camma configurata nell'editor (2) Salva Cam Salva la videocamera modificata (3) Barra di stato Visualizza i messaggi di stato (4) Selezione del segmento È possibile selezionare un segmento utilizzando le frecce. Il tipo di segmento può essere modificato tramite la casella di riepilogo (5) Posizione principale La posizione principale sul bordo sinistro e destro del segmento (6) Posizione slave La posizione dello slave sul bordo sinistro e destro del segmento. (7) Velocità slave La velocità dello slave sul bordo sinistro e destro del segmento. Non modificabile per tutti i tipi di segmento (8) Accelerazione slave L'accelerazione slave sul bordo sinistro e destro del segmento. Non modificabile per tutti i tipi di segmento (9) Schiavo idiota Lo slave jerk sul bordo sinistro e destro del segmento. Non modificabile per tutti i tipi di segmento (10) Parametro Lambda Parametro lambda per la linea sinusoidale modificata. (11) Spalato Divide il segmento selezionato in due segmenti. (12) Elimina Elimina il segmento selezionato. " }, 
{ "title" : "Utilizzo di una videocamera creata nell'applicazione ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_section-idm234870310600632", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Movimenti sincroni di due assi \/ camme \/ Elemento di visualizzazione Online Cam Editor \/ Utilizzo di una videocamera creata nell'applicazione ", 
"snippet" : "È possibile utilizzare la videocamera creata con SMC_Visu_CamEditor elemento di visualizzazione nell'applicazione chiamando il GetCopy metodo del CAM_REF_MULTICORE_SAFE istanza. PROGRAM PLC_PRG VAR     safeCam : SMCB.CAM_REF_MULTICORE_SAFE;     camRef : MC_CAM_REF;     camSegments : ARRAY[0..99] OF ...", 
"body" : "È possibile utilizzare la videocamera creata con SMC_Visu_CamEditor elemento di visualizzazione nell'applicazione chiamando il GetCopy metodo del CAM_REF_MULTICORE_SAFE istanza. PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\n    camRef : MC_CAM_REF;\n    camSegments : ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    error : SMC_ERROR;\nEND_VAR\n\nIF safeCam.CamId <> oldCamId THEN\n     error :=\n         safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n oldCamId := safeCam.CamId;\nEND_IF Il programma verifica innanzitutto se è stata creata una nuova camma ( CamId <> oldCamID ). In tal caso, viene creata una copia di questa videocamera utilizzando GetCopy metodo. Se la chiamata ritorna SMC_NO_ERROR , quindi camRef istanza di MC_CAM_REF il blocco funzione può essere utilizzato con i blocchi funzione SoftMotion cam MC_CamTableSelect e MC_CamIn . GetCopy la chiamata è sicura e quindi non deve essere effettuata dall'attività di Visu. " }, 
{ "title" : "Comandare più movimenti ", 
"url" : "_sm_basic_mulitple_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_sm_overview_mulitple_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti \/ Panoramica ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Modalità buffer ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844820766", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti \/ Panoramica \/ Modalità buffer ", 
"snippet" : "Alcuni blocchi funzione hanno a BufferMode input che viene utilizzato per controllare l'ordine cronologico dei movimenti. La modalità buffer definisce se il blocco funzione funziona in modalità senza buffer (\"Aborting\", comportamento standard) o in modalità buffer (\"Buffered\"). La differenza tra que...", 
"body" : "Alcuni blocchi funzione hanno a BufferMode input che viene utilizzato per controllare l'ordine cronologico dei movimenti. La modalità buffer definisce se il blocco funzione funziona in modalità senza buffer (\"Aborting\", comportamento standard) o in modalità buffer (\"Buffered\"). La differenza tra queste due modalità è il momento in cui iniziano le loro azioni: \"Modalità non bufferizzata\": Il comando di movimento ha effetto immediato, anche se questo interrompe un altro movimento. Il buffer dei movimenti comandati viene cancellato. \"Buffered Mode\": il comando di movimento attende finché il blocco funzione corrente non imposta la sua uscita Done (O InPosition , O InVelocity , eccetera.). Le modalità buffer vengono utilizzate anche per definire come dovrebbe apparire la curva di velocità durante la transizione dei movimenti. L'ingresso BufferMode è un ENUM di tipo MC_BUFFER_MODE. Aborting Modalità predefinita senza buffering. Il blocco funzione si avvia immediatamente e interrompe un movimento attivo. Il comando ha effetto immediato sull'asse. Buffered Il blocco funzione si avvia non appena termina l'ultimo movimento comandato. Qui non avviene alcuna fusione. Il nuovo movimento inizia alla velocità che ha il movimento precedente quando viene raggiunta la condizione finale ( Done , InVelocity , InEndVelocity , InGear , InSync , EndOfProfile , eccetera.). Se il movimento precedente fosse MC_MoveAbsolute O MC_MoveRelative , allora il nuovo movimento parte da fermo. BlendingLow Il blocco funzione si avvia non appena termina l'ultimo movimento comandato. L'asse non si ferma tra un movimento e l'altro, ma attraversa la posizione finale del primo movimento alla velocità inferiore dei due comandi di movimento. BlendingPrevious Il blocco funzione si avvia non appena termina l'ultimo movimento comandato. L'asse non si ferma tra un movimento e l'altro, ma attraversa la posizione finale del primo movimento alla velocità del primo comando di movimento. BlendingNext Il blocco funzione si avvia non appena termina l'ultimo movimento comandato. L'asse non si ferma tra un movimento e l'altro, ma attraversa la posizione finale del primo movimento alla velocità del secondo comando di movimento. BlendingHigh Il blocco funzione si avvia non appena termina l'ultimo movimento comandato. L'asse non si ferma tra un movimento e l'altro, ma attraversa la posizione finale del primo movimento alla velocità maggiore dei due comandi di movimento. " }, 
{ "title" : "Blocchi funzione supportati ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844838676", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti \/ Panoramica \/ Modalità buffer \/ Blocchi funzione supportati ", 
"snippet" : "Tutti i blocchi funzione che possono essere specificati come comandi bufferizzati\/combinati hanno i seguenti ingressi e uscite: BufferMode ingresso ( MC_BUFFER_MODE tipo) Active produzione: ( BOOL tipo) Un comando viene accettato quando il blocco funzione passa allo stato Busy dopo che è stato coman...", 
"body" : "Tutti i blocchi funzione che possono essere specificati come comandi bufferizzati\/combinati hanno i seguenti ingressi e uscite: BufferMode ingresso ( MC_BUFFER_MODE tipo) Active produzione: ( BOOL tipo) Un comando viene accettato quando il blocco funzione passa allo stato Busy dopo che è stato comandato un nuovo movimento. Blocco funzione Può essere definito come un comando bufferizzato\/miscelato Può essere seguito da un comando bufferizzato\/miscelato Segnale rilevante per l'attivazione del successivo FB bufferizzato\/miscelato MC_Power NO NO MC_Home NO NO MC_Stop NO NO MC_Halt NO NO MC_MoveAbsolute MC_MoveRelative SÌ SÌ Done MC_MoveAdditive NO SÌ ( Buffered soltanto) Done MC_MoveSuperImposed MC_HaltSuperImposed NO NO Per ulteriori informazioni, vedere: Comportamento di MC_MoveSuperImposed e MC_HaltSuperImposedMC_MoveVelocity SÌ SÌ ( Buffered soltanto) InVelocity SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative NO SÌ ( Buffered soltanto) InEndVelocity MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile NO SÌ ( Buffered soltanto) Done MC_CamIn Sì (solo Buffered e BlendingPrevious ) Sì, anche se periodico (solo Buffered ) EndOfProfile MC_CamOut NO SÌ ( Buffered soltanto) Done MC_GearIn SÌ ( BlendingPrevious soltanto) SÌ ( Buffered soltanto) InGear MC_GearOut NO SÌ ( Buffered soltanto) Done MC_GearInPos SÌ ( BlendingPrevious soltanto) SÌ ( Buffered soltanto) InSync SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues NO NO SMC_SetTorque NO NO MC_Phasing NO NO MC_Jog SMC_Inch NO NO Questi blocchi funzione non devono essere utilizzati quando i movimenti vengono comandati in modalità buffer Buffered O Blending* . Il jogging e i movimenti comandati potrebbero interrompersi a vicenda. SMC_BacklashCompensation NO NO SMC_TrackAxis NO NO SMC_TrackSetValues NO NO Nota per MC_GearInPos E MC_GearIn : Il comportamento di altre modalità buffer come BlendingPrevious è difficile da stabilire. Il problema principale è che la velocità di questi blocchi funzione può cambiare in qualsiasi momento a seconda dell'asse master. Perché la miscelazione funziona meglio solo quando la velocità di miscelazione è nota il più presto possibile BlendingPrevious è supportato. In caso di BlendingPrevious , anche la direzione dell'asse master può cambiare in qualsiasi momento. Ciò significa che la direzione che dovrà avere l'asse slave per MC_GearInPos è nota solo al termine della fusione. Tuttavia, abbiamo bisogno di una direzione per il movimento di fusione proprio quando inizia la fusione. Ecco perché il primo movimento definisce sia la velocità di fusione che la direzione, indipendentemente dalla direzione definita dal successivo MC_GearIn(Pos) . " }, 
{ "title" : "Comportamento nel caso di movimenti tamponati ", 
"url" : "_sm_buffermode_buffered_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti \/ Comportamento nel caso di movimenti tamponati ", 
"snippet" : "Quando viene comandato un movimento bufferizzato dopo MC_MoveAbsolute o MC_MoveRelative , il movimento tamponato è attivo nello stesso ciclo in cui è riportato il movimento precedente Done e raggiunge la velocità 0. Tuttavia, l'interpolazione del movimento tamponato non inizia fino al ciclo successi...", 
"body" : "Quando viene comandato un movimento bufferizzato dopo MC_MoveAbsolute o MC_MoveRelative , il movimento tamponato è attivo nello stesso ciclo in cui è riportato il movimento precedente Done e raggiunge la velocità 0. Tuttavia, l'interpolazione del movimento tamponato non inizia fino al ciclo successivo, per cui la velocità dell'asse a fine ciclo è uguale a 0. Quando viene comandato un movimento bufferizzato MC_CamIn , il movimento tamponato è attivo nello stesso ciclo in cui riporta il movimento precedente EndOfProfile . In questo ciclo inizia immediatamente l'interpolazione del movimento bufferizzato. " }, 
{ "title" : "Comportamento nel caso della fusione ", 
"url" : "_sm_buffermode_blending.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti \/ Comportamento nel caso della fusione ", 
"snippet" : "Una proprietà di base del comportamento di fusione di CODESYS SoftMotion è che l'asse si muove lungo le stesse posizioni durante l'unione come durante un movimento tamponato. L'unica differenza è la velocità lungo queste posizioni. Questo è ovvio per i casi semplici. Vedi il seguente esempio per que...", 
"body" : "Una proprietà di base del comportamento di fusione di CODESYS SoftMotion è che l'asse si muove lungo le stesse posizioni durante l'unione come durante un movimento tamponato. L'unica differenza è la velocità lungo queste posizioni. Questo è ovvio per i casi semplici. Vedi il seguente esempio per questo: Ci sono casi in cui la proprietà di percorrere le stesse posizioni da parte dell'asse indipendentemente dalla modalità buffer influenza l'effettiva velocità di fusione tra i due movimenti. Questo è il caso, ad esempio, se l'esempio precedente viene modificato in modo che la velocità massima del secondo movimento sia così elevata che non può essere raggiunta nella posizione di fusione. Secondo le regole descritte in PLCopen, la velocità di miscelazione dovrebbe essere di 500 u\/s. Tuttavia, per raggiungere questa velocità nella posizione 100 u, l'asse dovrebbe invertire la direzione, spostarsi nella direzione negativa fino a una posizione inferiore a 0 u, e quindi accelerare fino a 500 u\/s. Invece, in questi casi la velocità di miscelazione effettiva è limitata alla velocità massima che può essere raggiunta senza inversione e superamento della posizione. In questo esempio, la velocità massima è 447 u\/s. Le seguenti regole per la velocità di miscelazione effettiva derivano dalla proprietà che la modalità buffer non modifica le posizioni guidate: Se la velocità di mescolamento non può essere raggiunta senza superamento della posizione, la velocità di mescolamento effettiva è la prossima velocità possibile che può essere raggiunta senza superamento (vedi esempio sopra). Nota: la velocità di fusione effettiva può essere superiore o inferiore alla velocità di fusione. Se la direzione all'inizio del secondo movimento è opposta alla direzione del primo movimento, la velocità di fusione effettiva viene impostata su 0. Ciò impedisce che la posizione superi la direzione del primo movimento oltre la sua posizione target. Se il percorso del secondo movimento è troppo breve per consentire la decelerazione dalla velocità di miscelazione all'arresto, la velocità di miscelazione effettiva viene regolata. È impostato sulla velocità massima che consente una frenata sicura fino all'arresto sulla traiettoria del secondo movimento. Nel caso di assi modulo, l'effetto dell'ingresso Direction di MC_MoveAbsolute non è influenzato dalla fusione con un secondo movimento. Ciò significa che la posizione di destinazione del primo movimento è sempre nello stesso periodo modulo, indipendentemente dal fatto che segua o meno un movimento di raccordo. Nel caso di assi modulo e un secondo movimento di tipo MC_MoveAbsolute , la velocità di fusione non influisce sul periodo modulo della posizione target del secondo movimento quando Direction = fastest si usa. Ciò significa che viene selezionato lo stesso periodo target indipendentemente dal fatto che il secondo movimento sia comandato con Buffered o Blending . " }, 
{ "title" : "Accelerazione, decelerazione e strappo durante la miscelazione ", 
"url" : "_sm_buffermode_blending.html#UUID-60273b62-3ad5-7014-3fa9-e2fa61f7a008_section-idm235068399508112", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti \/ Comportamento nel caso della fusione \/ Accelerazione, decelerazione e strappo durante la miscelazione ", 
"snippet" : "La modalità buffer ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext ) del secondo movimento determina la velocità alla quale viene raggiunta la posizione iniziale del movimento. Al contrario, l'accelerazione massima, la decelerazione e lo strappo massimo durante la fusione sono sempre ...", 
"body" : "La modalità buffer ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext ) del secondo movimento determina la velocità alla quale viene raggiunta la posizione iniziale del movimento. Al contrario, l'accelerazione massima, la decelerazione e lo strappo massimo durante la fusione sono sempre i valori del primo movimento. Il motivo è che la posizione target del primo movimento può essere superata se, ad esempio, il ritardo massimo del secondo movimento è inferiore a quello del primo e viene utilizzato il ritardo minore " }, 
{ "title" : "Buffering\/Miscelazione da movimento continuo o sincronizzato ", 
"url" : "_sm_buffermode_continuous_motion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti \/ Buffering\/Miscelazione da movimento continuo o sincronizzato ", 
"snippet" : "Secondo PLCopen, la modalità buffer di fusione determina la velocità alla fine del primo movimento. In alcuni casi, la velocità è già interamente determinata dal primo movimento. Questo è il caso quando il primo movimento è di uno dei seguenti tipi: Movimento continuo ( MC_MoveVelocity , SMC_MoveCon...", 
"body" : "Secondo PLCopen, la modalità buffer di fusione determina la velocità alla fine del primo movimento. In alcuni casi, la velocità è già interamente determinata dal primo movimento. Questo è il caso quando il primo movimento è di uno dei seguenti tipi: Movimento continuo ( MC_MoveVelocity , SMC_MoveContinuousRelative , o SMC_MoveContinuousAbsolute ) Movimento sincronizzato ( MC_CamIn , MC_GearIn , o MC_GearInPos ) In questi casi, CODESYS SoftMotion supporta solo il Buffered e Aborting modalità tampone. L'utilizzo di una delle modalità del buffer di fusione provoca un errore FB ( SMC_BLENDING_NOT_SUPPORTED_BY_PREVIOUS_MOVEMENT) . Quando il successivo comando memorizzato nel buffer diventa attivo, l'output CommandAborted è impostato per TRUE per un precedente comando di movimento. Inoltre, le uscite \"Inxxx\" (ad esempio, InVelocity per MC_MoveVelocity O InGear per MC_GearIn ) e l'output Busy sono impostati per un ciclo. Ciò è in contrasto con PLCopen, Sezione 2.4.1, in cui CommandAborted e \"Inxxx\" così come Busy si escludono a vicenda. " }, 
{ "title" : "Ordine di esecuzione dei blocchi funzione di movimento ", 
"url" : "_sm_buffermode_execution_order.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti \/ Ordine di esecuzione dei blocchi funzione di movimento ", 
"snippet" : "Quando vengono comandati movimenti bufferizzati o movimenti di fusione, l'istanza del blocco funzione che comanda il movimento successivo non deve essere eseguita prima dell'istanza del blocco funzione che ha comandato il movimento precedente. Se questo ordine viene violato, allora il nuovo errore S...", 
"body" : "Quando vengono comandati movimenti bufferizzati o movimenti di fusione, l'istanza del blocco funzione che comanda il movimento successivo non deve essere eseguita prima dell'istanza del blocco funzione che ha comandato il movimento precedente. Se questo ordine viene violato, allora il nuovo errore SMC_FB_WASNT_CALLED_DURING_MOTION viene segnalato e l'asse passa allo stato Errorstop . Esempio movement1();\nmovement2(); Ordine di esecuzione corretto Esecuzione di movement1() Esecuzione di movement2() non appena movement1() è attivo Ordine di esecuzione non valido Esecuzione di movement2() Esecuzione di movement1() non appena movement2() è attivo Ciò si traduce nel SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT errore. " }, 
{ "title" : "Utilizzo di un'istanza di blocco funzione per controllare più movimenti ", 
"url" : "_sm_buffermode_one_fb.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti \/ Utilizzo di un'istanza di blocco funzione per controllare più movimenti ", 
"snippet" : "Una singola istanza di blocco funzione (ad esempio, from MC_MoveAbsolute ) non può essere utilizzato per controllare più movimenti bufferizzati\/miscelati finché lo è Busy . Quando un'istanza di blocco funzione è Busy , il comando per un nuovo movimento bufferizzato o combinato con questa istanza gen...", 
"body" : "Una singola istanza di blocco funzione (ad esempio, from MC_MoveAbsolute ) non può essere utilizzato per controllare più movimenti bufferizzati\/miscelati finché lo è Busy . Quando un'istanza di blocco funzione è Busy , il comando per un nuovo movimento bufferizzato o combinato con questa istanza genera un errore SMC_MORE_THAN_ONE_MOVEMENT_PER_INSTANCE . Per comandare più movimenti bufferizzati o combinati dello stesso tipo in breve tempo, sono necessarie più istanze del modulo funzione. " }, 
{ "title" : "Comportamento in caso di errore ", 
"url" : "_sm_basic_behavior_error.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti \/ Comportamento in caso di errore ", 
"snippet" : "Se si verifica un errore dell'asse (ad esempio, l'asse passa allo stato Errorstop ), il movimento attivo riporterà un errore insieme a tutti gli altri movimenti accettati. Se si verifica un errore FB nel blocco funzione di un movimento attivo, anche tutti i movimenti accettati successivamente segnal...", 
"body" : "Se si verifica un errore dell'asse (ad esempio, l'asse passa allo stato Errorstop ), il movimento attivo riporterà un errore insieme a tutti gli altri movimenti accettati. Se si verifica un errore FB nel blocco funzione di un movimento attivo, anche tutti i movimenti accettati successivamente segnalano un errore. Ciò è in contrasto con PLCopen, Sezione 2.2.2, in cui i comandi successivi continueranno l'esecuzione dopo un errore dell'FB. " }, 
{ "title" : "Comportamento di MC_MoveSuperImposed e MC_HaltSuperImposed ", 
"url" : "_sm_buffermode_movesuperimposed.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti \/ Comportamento di MC_MoveSuperImposed e MC_HaltSuperImposed ", 
"snippet" : "Se MC_MoveSuperImposed O MC_HaltSuperImposed è attivo e il movimento sottostante viene interrotto MC_MoveSuperImposed \/ MC_HaltSuperImposed viene anche interrotto. Se non viene annullato il movimento sottostante, ma un altro movimento con la modalità Buffered o viene comandato uno dei Blending-Buffe...", 
"body" : "Se MC_MoveSuperImposed O MC_HaltSuperImposed è attivo e il movimento sottostante viene interrotto MC_MoveSuperImposed \/ MC_HaltSuperImposed viene anche interrotto. Se non viene annullato il movimento sottostante, ma un altro movimento con la modalità Buffered o viene comandato uno dei Blending-BufferMode, il comportamento è il seguente: MC_MoveSuperImposed \/ MC_HaltSuperImposed non verrà annullato quando inizia la fusione o il nuovo movimento diventa attivo. Invece, MC_MoveSuperImposed \/ MC_HaltSuperImposed continua in background fino al termine. " }, 
{ "title" : "Come di CODESYS SoftMotion versione 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439539337338", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti \/ Comportamento di MC_MoveSuperImposed e MC_HaltSuperImposed \/ Come di CODESYS SoftMotion versione 4.17.0.0 ", 
"snippet" : "Quando un MC_MoveAbsolute configurato con una modalità bufferizzata o una modalità di fusione viene comandata, la posizione finale risultante è la somma della posizione configurata MC_MoveAbsolute e la distanza configurata a MC_MoveSuperImposed \/ MC_HaltSuperImposed . È irrilevante se MC_MoveSuperIm...", 
"body" : "Quando un MC_MoveAbsolute configurato con una modalità bufferizzata o una modalità di fusione viene comandata, la posizione finale risultante è la somma della posizione configurata MC_MoveAbsolute e la distanza configurata a MC_MoveSuperImposed \/ MC_HaltSuperImposed . È irrilevante se MC_MoveSuperImposed \/ MC_HaltSuperImposed è ancora attivo. La distanza sovrapposta viene mantenuta anche dopo il completamento del movimento sovrapposto. La distanza sovrapposta viene ripristinata non appena viene comandato un movimento di interruzione. " }, 
{ "title" : "Prima CODESYS SoftMotion versione 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439540497353", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Comandare più movimenti \/ Comportamento di MC_MoveSuperImposed e MC_HaltSuperImposed \/ Prima CODESYS SoftMotion versione 4.17.0.0 ", 
"snippet" : "Se uno MC_MoveAbsolute assegnato con la modalità bufferizzata o una modalità di fusione viene comandata mentre un MC_MoveSuperImposed \/ MC_HaltSuperImposed è attivo, la posizione finale risultante dipende dallo stato di MC_MoveSuperImposed \/ MC_HaltSuperImposed nel momento in cui il MC_MoveAbsolute ...", 
"body" : "Se uno MC_MoveAbsolute assegnato con la modalità bufferizzata o una modalità di fusione viene comandata mentre un MC_MoveSuperImposed \/ MC_HaltSuperImposed è attivo, la posizione finale risultante dipende dallo stato di MC_MoveSuperImposed \/ MC_HaltSuperImposed nel momento in cui il MC_MoveAbsolute è attivo. Se MC_MoveSuperImposed \/ MC_HaltSuperImposed è ancora attivo in questo momento, la posizione finale risultante è la somma della posizione di MC_MoveAbsolute e la distanza di MC_MoveSuperImposed \/ MC_HaltSuperImposed . D'altra parte, se MC_MoveSuperImposed \/ MC_HaltSuperImposed non è più attivo in questo momento, la posizione finale risultante sarà la posizione di MC_MoveAbsolute senza la distanza di MC_MoveSuperImposed \/ MC_HaltSuperImposed . In modo simile, la velocità risultante di MC_MoveVelocity dipende dallo stato di MC_MoveSuperImposed \/ MC_HaltSuperImposed Quando MC_MoveVelocity è attivo. La curva sottostante mostra un MC_MoveSuperImposed ( sup blocco funzione) parallelo a tre movimenti assoluti con modalità blending buffer BlendingHigh . Il primo e il secondo movimento vengono comandati con una velocità di 100 u\/s con il ma0 E ma1 blocchi funzione. IL ma2 il blocco funzione comanda il terzo movimento con una velocità di 120 u\/s. La prima posizione target è 10 u, la seconda è 25 u e la terza è 40 u. La velocità del movimento sovrapposto è 20 e la distanza è 10. La posizione risultante è 50 u: la posizione dell'ultimo movimento assoluto più la distanza di MC_MoveSuperimposed . " }, 
{ "title" : "Punti di commutazione digitali ", 
"url" : "_sm_digital_switches.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Punti di commutazione digitali ", 
"snippet" : "CODESYS SoftMotion offre varie opzioni per la creazione di punti di commutazione digitali. Questa sezione fornisce una panoramica dei rispettivi vantaggi e svantaggi....", 
"body" : "CODESYS SoftMotion offre varie opzioni per la creazione di punti di commutazione digitali. Questa sezione fornisce una panoramica dei rispettivi vantaggi e svantaggi. " }, 
{ "title" : "Esempio di applicazione ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632666072", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Punti di commutazione digitali \/ Esempio di applicazione ", 
"snippet" : "I punti di commutazione digitali sono necessari, ad esempio, per accendere una pistola per colla in base alla posizione dell'asse. Nel seguente esempio, la pistola per colla deve applicare l'adesivo su un prodotto dalla posizione 90 alla posizione 120. Una pistola per colla ha un ritardo tra l'accen...", 
"body" : "I punti di commutazione digitali sono necessari, ad esempio, per accendere una pistola per colla in base alla posizione dell'asse. Nel seguente esempio, la pistola per colla deve applicare l'adesivo su un prodotto dalla posizione 90 alla posizione 120. Una pistola per colla ha un ritardo tra l'accensione e l'applicazione della colla. Lo stesso vale per lo spegnimento. È quindi necessaria una compensazione on\/off in modo che la pistola adesiva venga accesa 50 ms prima della posizione 90 e spenta 50 ms " }, 
{ "title" : "Panoramica dei blocchi funzionali ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632773598", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Punti di commutazione digitali \/ Panoramica dei blocchi funzionali ", 
"snippet" : "Blocco funzionale Punti di commutazione multipli Compensazione On\/Off Previsione Alta precisione (risoluzione temporale superiore al tempo di ciclo) Base di dati Nota SMC_DigitalCamSwitch_HighPrecision 1 2 Impostare la posizione o la posizione effettiva Utile quando è richiesta una maggiore precisio...", 
"body" : "Blocco funzionale Punti di commutazione multipli Compensazione On\/Off Previsione Alta precisione (risoluzione temporale superiore al tempo di ciclo) Base di dati Nota SMC_DigitalCamSwitch_HighPrecision 1 2 Impostare la posizione o la posizione effettiva Utile quando è richiesta una maggiore precisione temporale. Oltre a questo blocco funzionale, è necessaria una scheda di uscita digitale ad alta precisione per un funzionamento ad alta precisione. Questa combinazione consente di commutare le uscite con elevata precisione anche a tempi di ciclo più elevati Per ulteriori informazioni sull'uso del blocco funzione, vedere quanto segue: esempio Utilizzo di MC_DigitalCamSwitch_HighPrecision. SMC_GetTravelTime 2 Impostare la posizione o la posizione effettiva Utile se si tratta di una versione separata di DigitalCamSwitch il blocco funzione deve essere implementato (ad esempio, perché sono necessarie funzioni aggiuntive). MC_DigitalCamSwitch 3 Impostare la posizione o la posizione effettiva Utile se è sufficiente una risoluzione temporale precisa del ciclo. SMC_GetTappetValue Impostare la posizione o la posizione effettiva Questi blocchi funzionali vengono conservati solo per motivi di compatibilità. Per i progetti attuali e futuri, è necessario utilizzare gli altri blocchi funzionali più avanzati SMC_CamRegister Impostare la posizione o la posizione effettiva 1 Esatto. Vengono utilizzati i dati della previsione. 2 La previsione deve essere impostata mediante SMC_SetForecast blocco funzionale. Per ulteriori informazioni sulla previsione, vedere quanto segue: Previsione. 3 Solo per estrapolazione " }, 
{ "title" : "Adattamento dinamico con MC_SetOverride ", 
"url" : "_sm_adjust_dynamics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adattamento dinamico con MC_SetOverride ", 
"snippet" : "La dinamica (velocità, accelerazione e strappo) dei movimenti attivi e futuri può essere adattata utilizzando MC_SetOverride . Un adattamento della dinamica comporta sempre una riduzione rispetto al movimento originariamente comandato (non sono ammessi fattori superiori a 1). Ciò consente agli opera...", 
"body" : "La dinamica (velocità, accelerazione e strappo) dei movimenti attivi e futuri può essere adattata utilizzando MC_SetOverride . Un adattamento della dinamica comporta sempre una riduzione rispetto al movimento originariamente comandato (non sono ammessi fattori superiori a 1). Ciò consente agli operatori della macchina di arrestare temporaneamente un movimento ( VelFactor = 0 ) oppure eseguirlo con valori dinamici ridotti, ad esempio per verificare nuove sequenze di movimento. L'adattamento della dinamica con MC_SetOverride e il conseguente adattamento della traiettoria hanno effetto direttamente nello stesso ciclo. Il requisito per questo è quello MC_SetOverride viene chiamato prima del blocco funzione di movimento attivo. Per ulteriori informazioni vedere anche l'esempio Override della velocità per gli assi SoftMotion. " }, 
{ "title" : "Blocchi funzione supportati ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4626631011382434026679825113", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adattamento dinamico con MC_SetOverride \/ Blocchi funzione supportati ", 
"snippet" : "Blocco funzione Supporto: MC_SetOverride Commento MC_Stop -- MC_Stop è un arresto di emergenza che deve essere sempre eseguito il più rapidamente possibile. Pertanto, i fattori dinamici di MC_SetOverride non hanno alcun effetto sul movimento. MC_Halt ✓ Il fattore di velocità non ha alcun effetto. MC...", 
"body" : "Blocco funzione Supporto: MC_SetOverride Commento MC_Stop -- MC_Stop è un arresto di emergenza che deve essere sempre eseguito il più rapidamente possibile. Pertanto, i fattori dinamici di MC_SetOverride non hanno alcun effetto sul movimento. MC_Halt ✓ Il fattore di velocità non ha alcun effetto. MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_Jog SMC_Inch ✓ SMC_Homing ✓ SMC_ControlAxisByPos SMC_ControlAxisByPosVel SMC_ControlAxisByVel O I fattori dinamici hanno effetto solo se il bAvoidGaps la funzione è attivata ed è stato rilevato un salto. I fattori di MC_SetOverride prendere in considerazione sia lo stop che il successivo movimento assoluto per colmare il divario. MC_Home -- La corsa di riferimento viene eseguita indipendentemente dall'azionamento in modo che i fattori dinamici di MC_SetOverride non hanno alcun effetto. MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- Si consiglia di utilizzare MC_CamIn invece di questi blocchi funzione. MC_CamIn O I fattori dinamici non hanno più effetto non appena il movimento è sincronizzato ( MC_CamIn.InSync = TRUE ). MC_CamOut -- MC_CamOut non ha limiti dinamici regolabili e dovrebbe mantenere la velocità corrente. I fattori dinamici di MC_SetOverride quindi non hanno alcun effetto. MC_GearIn O I fattori dinamici non hanno più effetto non appena il movimento è sincronizzato ( MC_GearIn.InGear = TRUE ). Durante la rampa vengono considerati solo i fattori di accelerazione e jerk. Modifiche al fattore di velocità (in particolare VelFactor=0 ) vengono ignorati. MC_GearInPos -- In contrasto con MC_GearIn , non ha un movimento in rampa configurabile. Pertanto, i fattori dinamici di MC_SetOverride non hanno alcun effetto. SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- Questi blocchi funzione scrivono i valori impostati dell'asse (ad esempio, fSetPosition ). Questi valori non devono essere modificati. Pertanto, i fattori dinamici di MC_SetOverride non hanno alcun effetto. MC_Phasing O I fattori dinamici non hanno più effetto non appena il movimento è sincronizzato ( MC_Phasing.Done = TRUE ). Durante la rampa vengono considerati solo i fattori di accelerazione e jerk. Modifiche al fattore di velocità (in particolare VelFactor=0 ) vengono ignorati. SMC_BacklashCompensation -- I fattori dinamici non hanno effetto sui movimenti sincronizzati. Pertanto, questo blocco funzione ignora i fattori dinamici di MC_SetOverride . " }, 
{ "title" : "Superamento della posizione target o della velocità target modificando i fattori dinamici ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469374918434026680028303", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adattamento dinamico con MC_SetOverride \/ Superamento della posizione target o della velocità target modificando i fattori dinamici ", 
"snippet" : "Se durante un movimento attivo viene ridotto il fattore di accelerazione e\/o il fattore di strappo, è possibile che la posizione di destinazione o la velocità di destinazione vengano temporaneamente superate. Ciò può causare danni alla macchina. Con SMC_MoveContinuousAbsolute E SMC_MoveContinuousRel...", 
"body" : "Se durante un movimento attivo viene ridotto il fattore di accelerazione e\/o il fattore di strappo, è possibile che la posizione di destinazione o la velocità di destinazione vengano temporaneamente superate. Ciò può causare danni alla macchina. Con SMC_MoveContinuousAbsolute E SMC_MoveContinuousRelative , una modifica del fattore di velocità può anche portare al superamento dei limiti o ad un'inversione. Maggiori dettagli si trovano nella documentazione dei due blocchi funzione. " }, 
{ "title" : "Effetto del profilo di velocità sull'uso di MC_SetOverride ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469646968034026680341439", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adattamento dinamico con MC_SetOverride \/ Effetto del profilo di velocità sull'uso di MC_SetOverride ", 
"snippet" : "In genere si consiglia di utilizzare MC_SetOverride insieme a un profilo di velocità trapezoidale o quadratico degli assi. I profili di velocità quadratic smoothed e sin² non rispondono bene al riavvio o all'interruzione del movimento in alcuni casi (vedere Interruzione dei movimenti). Poiché una mo...", 
"body" : "In genere si consiglia di utilizzare MC_SetOverride insieme a un profilo di velocità trapezoidale o quadratico degli assi. I profili di velocità quadratic smoothed e sin² non rispondono bene al riavvio o all'interruzione del movimento in alcuni casi (vedere Interruzione dei movimenti). Poiché una modifica all'override equivale a un riavvio del movimento con limiti modificati, è anche possibile che i limiti comandati vengano superati quando si utilizzano questi profili di velocità MC_SetOverride . " }, 
{ "title" : "Effetto di MC_SetOverride sui movimenti coordinati con un gruppo di assi ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm456655390848963402668059106", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adattamento dinamico con MC_SetOverride \/ Effetto di MC_SetOverride sui movimenti coordinati con un gruppo di assi ", 
"snippet" : "Movimenti coordinati con un gruppo di assi (ad esempio, MC_MoveLinearAbsolute ) considerano le sostituzioni impostate con MC_SetOverride per ciascun asse durante la pianificazione del movimento. Al contrario, MC_GroupSetOverride sovrascrive le sostituzioni di ciascun asse del gruppo di assi....", 
"body" : "Movimenti coordinati con un gruppo di assi (ad esempio, MC_MoveLinearAbsolute ) considerano le sostituzioni impostate con MC_SetOverride per ciascun asse durante la pianificazione del movimento. Al contrario, MC_GroupSetOverride sovrascrive le sostituzioni di ciascun asse del gruppo di assi. " }, 
{ "title" : "Previsione ", 
"url" : "_sm_basic_forecast.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Previsione ", 
"snippet" : "La funzione di previsione può essere utilizzata per interrogare informazioni sul movimento futuro di un asse. Un'importante applicazione della previsione è determinare il tempo fino al raggiungimento di una posizione (simile alla funzionalità di attivazione). Un'altra applicazione è determinare la p...", 
"body" : "La funzione di previsione può essere utilizzata per interrogare informazioni sul movimento futuro di un asse. Un'importante applicazione della previsione è determinare il tempo fino al raggiungimento di una posizione (simile alla funzionalità di attivazione). Un'altra applicazione è determinare la posizione e la velocità che avrà un asse in un dato momento. In questo modo è possibile compensare i tempi morti all'accensione degli attuatori, ad esempio quando viene acceso un ugello di incollaggio. Può anche essere utilizzato per controllare con precisione attuatori con tempi morti, ad esempio controllare l'uscita di incollaggio in base alla velocità dell'asse 100 ms nel futuro Per implementare queste applicazioni è possibile utilizzare il file SMC_GetTravelTime E SMC_ReadSetValues blocchi funzione dopo aver configurato la durata della previsione con SMC_SetForecast . Per un esempio di utilizzo, vedere: Previsione per movimenti ad asse singolo" }, 
{ "title" : "Blocchi funzione di movimento con funzionalità di previsione ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm2344331274012", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Previsione \/ Blocchi funzione di movimento con funzionalità di previsione ", 
"snippet" : "La seguente panoramica mostra quali blocchi funzione supportano la funzione di previsione. Blocco funzione Previsione MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveCont...", 
"body" : "La seguente panoramica mostra quali blocchi funzione supportano la funzione di previsione. Blocco funzione Previsione MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- MC_CamIn ✓ MC_CamOut ✓ MC_GearIn ✓ MC_GearOut ✓ MC_GearInPos ✓ SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- SMC_SetTorque -- MC_Phasing ✓ MC_Jog SMC_Inch ✓ SMC_BacklashCompensation ✓ " }, 
{ "title" : "Abilitazione della funzione di previsione ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433129890703", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Previsione \/ Abilitazione della funzione di previsione ", 
"snippet" : "La funzione di previsione è disabilitata per impostazione predefinita. Ciò significa che SMC_ReadSetValues restituisce valori validi solo per a TimeOffset tra 0 s (inizio del ciclo del task corrente) e l'intervallo del task (fine del ciclo del task corrente), e SMC_GetTravelTime restituisce un tempo...", 
"body" : "La funzione di previsione è disabilitata per impostazione predefinita. Ciò significa che SMC_ReadSetValues restituisce valori validi solo per a TimeOffset tra 0 s (inizio del ciclo del task corrente) e l'intervallo del task (fine del ciclo del task corrente), e SMC_GetTravelTime restituisce un tempo valido solo per le posizioni raggiunte in questo ciclo. IL SMC_SetForecast Il blocco funzione viene utilizzato per configurare la durata della previsione richiesta e il SMC_GetForecast il blocco funzione viene utilizzato per leggere. Appunti: La durata della previsione può essere modificata in qualsiasi momento. Evitare una durata della previsione inutilmente lunga poiché il calcolo della previsione consuma tempo di elaborazione. Seleziona il valore più piccolo sufficiente per la tua applicazione. Se si utilizzano blocchi funzione master\/slave (come MC_CamIn ), allora la previsione deve essere abilitata sia per l'asse master che per l'asse slave. " }, 
{ "title" : "Chiama ordine ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130424909", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Previsione \/ Chiama ordine ", 
"snippet" : "Affinché la funzione di previsione produca i migliori risultati possibili, è importante assicurarsi che i blocchi funzione master\/slave vengano richiamati nell'ordine corretto. Questo vale per MC_CamIn , MC_GearIn , MC_GearInPos , MC_Phasing , SMC_BacklashCompensation , E SMC_TrackAxis . Il blocco f...", 
"body" : "Affinché la funzione di previsione produca i migliori risultati possibili, è importante assicurarsi che i blocchi funzione master\/slave vengano richiamati nell'ordine corretto. Questo vale per MC_CamIn , MC_GearIn , MC_GearInPos , MC_Phasing , SMC_BacklashCompensation , E SMC_TrackAxis . Il blocco funzione di movimento dell'asse master deve essere richiamato prima del blocco funzione master\/slave. Anche senza previsione, la traiettoria è migliore quando l’ordine delle chiamate è corretto. Quando l'ordine è sbagliato, il movimento dello slave viene ritardato di un ciclo. Per MC_SetOverride , questo blocco funzione deve essere richiamato anche prima dei blocchi funzione di movimento dell'asse. Modificando l'override, il movimento dell'asse viene modificato nello stesso ciclo del task. Di conseguenza i valori precedentemente determinati in base alle previsioni perdono la loro validità. Saranno determinati di nuovo la prossima volta SMC_GetTravelTime O SMC_ReadSetValues è chiamato. " }, 
{ "title" : "Modalità buffer ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130652478", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Previsione \/ Modalità buffer ", 
"snippet" : "La funzione di previsione non è limitata a un singolo movimento. Si estende anche a tutti i movimenti successivi comandati in modalità blending o buffered buffer. Quando viene eseguito un movimento di interruzione su un asse, viene modificato il movimento dell'asse in questo ciclo del task. Di conse...", 
"body" : "La funzione di previsione non è limitata a un singolo movimento. Si estende anche a tutti i movimenti successivi comandati in modalità blending o buffered buffer. Quando viene eseguito un movimento di interruzione su un asse, viene modificato il movimento dell'asse in questo ciclo del task. Di conseguenza i valori precedentemente determinati in base alle previsioni perdono la loro validità. Saranno determinati di nuovo la prossima volta SMC_GetTravelTime O SMC_ReadSetValues è chiamato. " }, 
{ "title" : "Previsioni\/restrizioni efficaci ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130869747", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Previsione \/ Previsioni\/restrizioni efficaci ", 
"snippet" : "Idealmente, la durata effettiva della previsione disponibile è uguale alla durata della previsione configurata. Tuttavia, ci sono alcuni fattori che possono far sì che la previsione effettiva sia più breve della previsione configurata. Quando viene eseguito un movimento master\/slave, la previsione e...", 
"body" : "Idealmente, la durata effettiva della previsione disponibile è uguale alla durata della previsione configurata. Tuttavia, ci sono alcuni fattori che possono far sì che la previsione effettiva sia più breve della previsione configurata. Quando viene eseguito un movimento master\/slave, la previsione effettiva dello slave è il minimo tra la previsione effettiva del master e la previsione configurata dello slave. Per gli assi logici e gli assi encoder, la previsione effettiva è sempre 0. Se il blocco funzione di movimento attivo non supporta la funzione di previsione, anche la previsione effettiva sarà 0. In tutti gli altri casi, la previsione effettiva è la stessa della previsione configurata. " }, 
{ "title" : "Diagnosi ", 
"url" : "_sm_basic_error_diagnosis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Diagnosi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Errori comuni ", 
"url" : "_sm_basic_common_errors.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Diagnosi \/ Errori comuni ", 
"snippet" : "Questa pagina descrive gli errori comuni durante l'utilizzo CODESYS Softmotion Basic , le relative cause e le possibili azioni da intraprendere per correggere l'errore. Per un elenco di tutti i possibili errori con una breve descrizione, consultare la documentazione della libreria: SMC_ERRORE Codice...", 
"body" : "Questa pagina descrive gli errori comuni durante l'utilizzo CODESYS Softmotion Basic , le relative cause e le possibili azioni da intraprendere per correggere l'errore. Per un elenco di tutti i possibili errori con una breve descrizione, consultare la documentazione della libreria: SMC_ERRORE Codice di errore Descrizione e cause Azioni SMC_DI_AXIS_ERROR L'unità ha segnalato un errore. Cause possibili: Ritardo di posizione Finecorsa Sovraccarico (errore I²t) Controlla quale errore sta segnalando l'unità. L'errore può essere letto dal display dell'azionamento (se disponibile) oppure recuperandolo con il file MC_ReadAxisError blocco funzione. SMC_AXIS_ERROR_DURING_MOTION L'unità ha segnalato un errore. Durante un movimento, il blocco di movimento attivo restituisce questo errore. Vedere le azioni per l'errore SMC_DI_AXIS_ERROR . SMC_FB_WASNT_CALLED_DURING_MOTION Il blocco funzione che controlla il movimento attivo non è stato chiamato nel ciclo corrente. Possibili cause: L'ordine di chiamata per i movimenti bufferizzati o i movimenti di fusione non è corretto. L'istanza del blocco funzione del movimento successivo non deve essere chiamata prima dell'istanza del blocco funzione che ha comandato il Come di SoftMotion versione 4.15.0.0, il messaggio di registro per questo errore contiene il percorso dell'istanza del blocco funzione interessato. Nell'applicazione verificare il motivo per cui il blocco funzione non è stato richiamato ciclicamente. Correggere la chiamata in modo che venga eseguita ciclicamente (almeno finché il blocco è in uso). SMC_BLOCKING_MC_STOP_WASNT_CALLED Durante un arresto attivo, il blocco funzione associato MC_Stop non è stato chiamato nel ciclo corrente. Vedere le azioni per l'errore SMC_FB_WASNT_CALLED_DURING_MOTION . SMC_AXIS_NOT_READY_FOR_MOTION L'asse non è pronto per l'uso e non può eseguire il movimento desiderato. Cause possibili: L'asse non è in uno stato operativo per il rispettivo movimento (ad es. power_off O errorstop ). L'asse è in uno stato di errore e tutti i movimenti bufferizzati restituiscono questo errore. L'asse è nel stopping stato (durante uno stato attivo MC_Stop ) e viene comandato un nuovo movimento di interruzione. Controllare lo stato dell'asse: L'asse è in uno stato operativo? MC_Power ? L'asse è nel errorstop stato? In tal caso, identificare l'errore dell'asse e correggerlo. Lo stato dell'asse corrisponde al movimento comandato? Per esempio, MC_CamOut può essere comandato solo quando l'asse è nello stato di movimento sincronizzato. SMC_FB_CALLED_FROM_WRONG_TASK IL SoftMotion il blocco è stato richiamato da un task che non corrisponde al task bus dell'asse. Perché il SoftMotion i blocchi modificano i valori nell'asse, possono verificarsi stati incoerenti se vengono effettuate chiamate da task diversi dal task bus. Ciò può portare a errori non definiti, che vengono impediti da questo errore. Controllare il protocollo: l'asse interessato e l'istanza del blocco vengono registrati. Rimuovere la chiamata dall'attività errata. SMC_DI_FIELDBUS_LOST_SYNCRONICITY Si verifica durante l'utilizzo EtherCAT con orologi distribuiti, se il telegramma dal controllore all'azionamento non è stato ricevuto in tempo (entro la finestra temporale definita (\"SyncWindow\") o non è stato ricevuto affatto. Cause possibili: Problemi in tempo reale: Il jitter del compito è troppo alto. La priorità del compito del EtherCAT il compito è troppo basso. Altri bus di campo (ad esempio, Modbus ) o operazioni lunghe in aggiunta alle attività di controllo (ad esempio, accesso ai file) nel file EtherCAT compito Modbus viene eseguito in un altro task, ma si fa riferimento anche ai canali I\/O che utilizza nel file EtherCAT compito. Soprattutto con i sistemi operativi Linux, la configurazione del sistema (ad esempio le priorità IRQ) Problema di comunicazione con il EtherCAT slave: Collegamento interrotto, problemi di compatibilità elettromagnetica (EMC), ecc. Verificare la causa del comportamento. Le seguenti funzioni possono aiutarti in questo: IL Pagina di stato del EtherCAT Maestro Analisi dei tempi di ciclo e di jitter del task EtherCAT nel file Configurazione dell'attività Possibili azioni per problemi in tempo reale: Ottimizza il tempo reale. Per fare ciò, segui le istruzioni in Ottimizzazione delle prestazioni Aumentare il tempo di ciclo del EtherCAT compito. Aumento DCInSyncWindow del EtherCAT Maestro. Vedere: Finestra IoDrvEtherCAT.DCInSync (PROP) Abilitare FrameAtTaskStart per il EtherCAT Maestro. Vedere: IoDrvEtherCAT.FrameAtTaskStart (PROP) Se l'unità è in grado di gestire i problemi di sincronizzazione, il controllo della sincronizzazione può essere disabilitato tramite SMC_Set_ETC_DCSyncSupervision . SMC_DI_SWLIMITS_EXCEEDED L'asse si muove nella direzione del finecorsa software positivo o negativo e lo supera con la dinamica attuale. L'errore si attiva anche prima della posizione effettiva del finecorsa perché nel calcolo viene inclusa anche la distanza di frenata richiesta. Controllare se il movimento è desiderato o meno in questo intervallo di posizioni. Se necessario, regolare la posizione del finecorsa software negativo e\/o positivo. Vedere Scheda: GeneraleSMC_DI_HWLIMITS_EXCEEDED Il finecorsa hardware positivo o negativo è intervenuto e l'asse si muove nella direzione di questo finecorsa. Controllare la posizione comandata del movimento. Questo non deve superare le posizioni dei finecorsa hardware. Se il movimento è ok verificare i segnali dei finecorsa hardware. SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT Non c'è movimento attivo, ma la velocità impostata non è uguale a zero e l'asse è in uno stato operativo in cui vengono seguiti i valori impostati. Cause possibili: Quando si usa MC_PositionProfile , MC_VelocityProfile , O MC_AccelerationProfile , al termine di questo movimento l'asse deve arrestarsi oppure nello stesso ciclo deve essere comandato un movimento successivo. Altrimenti viene restituito questo errore. Verificare la causa del problema: Ordine di chiamata errato per movimenti bufferizzati e blending: modificare l'ordine di chiamata. Per ulteriori informazioni consultare la sezione Ordine di esecuzione dei blocchi funzione di movimento. MC_PositionProfile , MC_VelocityProfile , O MC_AccelerationProfile viene utilizzato e alla fine non viene raggiunto alcun arresto: adattare opportunamente il profilo in modo tale che alla fine venga raggiunto l'arresto. O invece usa camme, che coprono un caso d'uso simile a questi blocchi funzione, ma sono più flessibili e più facili da usare. " }, 
{ "title" : "Prestazione ", 
"url" : "_sm_diagnosis_performance.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Diagnosi \/ Prestazione ", 
"snippet" : "POU che utilizzano il AXIS_REF_SM3 blocco funzione controllano sempre se vengono richiamati o meno dal task del ciclo del bus. Questo controllo può essere disabilitato per le applicazioni time-critical tramite la definizione del compilatore SM3_DISABLE_TASK_CHECKS ....", 
"body" : "POU che utilizzano il AXIS_REF_SM3 blocco funzione controllano sempre se vengono richiamati o meno dal task del ciclo del bus. Questo controllo può essere disabilitato per le applicazioni time-critical tramite la definizione del compilatore SM3_DISABLE_TASK_CHECKS . " }, 
{ "title" : "Esempi ", 
"url" : "_sm_basic_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Movimenti ad asse singolo ", 
"url" : "_sm_basic_examples_single_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti ad asse singolo ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Controllo del movimento dei singoli assi ", 
"url" : "_sm_example_single_axis_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti ad asse singolo \/ Controllo del movimento dei singoli assi ", 
"snippet" : "Vedi il PLCopenSingle.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come controllare un azionamento mediante blocchi funzione standardizzati PLCopen. Inserisci un'unità virtuale denominata Drive nell'albero dei di...", 
"body" : "Vedi il PLCopenSingle.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come controllare un azionamento mediante blocchi funzione standardizzati PLCopen. Inserisci un'unità virtuale denominata Drive nell'albero dei dispositivi qui sotto Pool di assi generali SoftMotion . Creare un MOTION_PRG programma in ST. PROGRAM MOTION_PRG\nVAR\n iStatus: INT;\n Power: MC_Power;\n MoveAbsolute: MC_MoveAbsolute;\n p:REAL:=100;\nEND_VAR\n\nCASE iStatus OF\n\n\/\/ initialization of the axis\n0:\n Power(Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE, Axis:=Drive);\n IF Power.Status THEN\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis to position p by use of the MC_MoveAbsolute function block\n1:\n MoveAbsolute(Execute:=TRUE, Position:= p, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis back to position 0 by use of the MC_MoveAbsolute function block:\n2:\n MoveAbsolute(Execute:=TRUE, Position:= 0, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := 1;\n END_IF Aggiungere la chiamata del programma MOTION_PRG al task Compito principale . Albero dei dispositivi: Scarica il progetto sul controller e avvialo. Apri il Unità asse virtuale nell'editor. Nel in linea parte di Generale scheda, si vede il movimento dell'asse. " }, 
{ "title" : "Controllo del movimento di singoli assi in CFC con un modello di visualizzazione ", 
"url" : "_sm_example_single_axis_visu_template.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti ad asse singolo \/ Controllo del movimento di singoli assi in CFC con un modello di visualizzazione ", 
"snippet" : "Vedi il PLCopenSingle2.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Al posto di ST può essere utilizzato anche uno qualsiasi degli altri linguaggi di implementazione IEC, ad esempio CFC qui. Questo linguaggio mostra il meccanismo di a...", 
"body" : "Vedi il PLCopenSingle2.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Al posto di ST può essere utilizzato anche uno qualsiasi degli altri linguaggi di implementazione IEC, ad esempio CFC qui. Questo linguaggio mostra il meccanismo di avvio e interruzione dei blocchi funzione. Inoltre, le diverse modalità di avvio per il blocco funzione MC_MoveAbsolute può essere testato per assi rotanti. Inserisci un'unità virtuale denominata Drive nell'albero dei dispositivi qui sotto Pool di assi generali SoftMotion . Fare doppio clic sull'oggetto per aprire il suo editor. Modificare i parametri in un azionamento rotativo con un periodo di 360°. Tipo di asse : Modulo Valore modulo [u] : 360.0 Creare un MOTION_PRG programma in CFC. Inserisci i blocchi funzione MC_Power , MC_MoveAbsolute , e MC_MoveVelocity . In genere si consiglia di inizializzare gli ingressi dei blocchi funzione. Quindi non è necessario specificare i valori più e più volte in seguito all'avvio di questa applicazione di prova. PROGRAM MOTION_PRG\nVAR\n mcp: MC_Power := (Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n mcmv: MC_MoveVelocity :=(Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\n mcma: MC_MoveAbsolute := (Position:=180, Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\nEND_VAR CFC: Aggiungi la chiamata del MOTION_PRG programma per il compito Compito principale . Aggiungere un Visualizzazione opporsi alla domanda. Posiziona i modelli di visualizzazione VISU_NEW_MC_MoveAbsolute , VISU_NEW_MC_MoveVelocity , VISU_NEW_MC_Power , e RotDrive nell'editor di visualizzazione. Collegarli alle istanze del blocco funzione di MOTION_PRG . Visualizzazione: Compila il progetto e scaricalo nel PLC. Avvia il progetto. Apri la visualizzazione nell'editor. Clicca il Abilitare ingresso (MC_Power) e poi il Eseguire ingresso (MC_Move_Absolute). L'unità ruota. Apri il Unità asse virtuale nell'editor. Nel in linea parte di Generale scheda, si vede il movimento dell'asse. Sperimenta con i parametri di questi blocchi funzione. Modificare i parametri e osservare il comportamento. " }, 
{ "title" : "Previsione per movimenti ad asse singolo ", 
"url" : "_sm_basic_example_forecast.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti ad asse singolo \/ Previsione per movimenti ad asse singolo ", 
"snippet" : "IL BasicMotion_Forecast.project progetto di esempio si trova nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come definire una previsione per un asse per ottenere informazioni sullo stato futuro dell'asse. Nell'esempio viene eseguito un movime...", 
"body" : "IL BasicMotion_Forecast.project progetto di esempio si trova nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come definire una previsione per un asse per ottenere informazioni sullo stato futuro dell'asse. Nell'esempio viene eseguito un movimento assoluto su un asse fino alla posizione 10. Impostando sull'asse una previsione di 300 ms è possibile sapere in anticipo nell'applicazione quando e con quale dinamica l'asse si sposterà attraverso la posizione 8. Per ulteriori informazioni sulla previsione per gli assi, vedere: Previsione" }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768266588", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti ad asse singolo \/ Previsione per movimenti ad asse singolo \/ Struttura dell'applicazione ", 
"snippet" : "L'applicazione è composta da a PLC_PRG programma e a Trace . PLC_PRG L'asse virtuale è acceso in STATE_POWER_DRIVE stato. Poi il SMC_SetForecast Il blocco funzione viene utilizzato per definire una previsione di 300 ms per l'asse nel file STATE_SET_FORECAST stato. IL SMC_GetForecast blocco funzione ...", 
"body" : "L'applicazione è composta da a PLC_PRG programma e a Trace . PLC_PRG L'asse virtuale è acceso in STATE_POWER_DRIVE stato. Poi il SMC_SetForecast Il blocco funzione viene utilizzato per definire una previsione di 300 ms per l'asse nel file STATE_SET_FORECAST stato. IL SMC_GetForecast blocco funzione può essere utilizzato per leggere la previsione impostata per l'asse. Nel STATE_MOVE_TO_POSITION stato, viene eseguito un movimento assoluto alla posizione 10. IL SMC_GetTravelTime viene avviato anche il blocco funzione. Il blocco funzione viene utilizzato per leggere l'ora in cui l'asse raggiungerà la posizione 8. Il SMC_ReadSetValues blocco funzione viene utilizzato per determinare la dinamica nella posizione 8. A questo blocco funzione può essere passato un offset temporale in cui deve essere letta la dinamica dell'asse. Nel nostro caso trascorriamo il tempo necessario all'asse per raggiungere la posizione 8. Traccia È possibile utilizzare la traccia per tracciare il movimento dell'asse virtuale. Vengono registrate la posizione attuale, la velocità e l'accelerazione dell'asse. Vengono inoltre visualizzate la durata fino alla posizione 8 e la dinamica dell'asse in questa posizione. Si noti che la durata di SMC_GetTravelTime viene specificato rispetto all'inizio del ciclo. I valori impostati dell'asse corrispondono a quelli di fine ciclo. " }, 
{ "title" : "La messa in produzione ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768283734", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti ad asse singolo \/ Previsione per movimenti ad asse singolo \/ La messa in produzione ", 
"snippet" : "Costruisci l'applicazione e scaricala su un controller. Avviare la traccia e l'applicazione. Nella traccia è possibile seguire il movimento dell'asse virtuale. Presta attenzione alla durata fino alla posizione 8 e alla dinamica alla posizione 8....", 
"body" : "Costruisci l'applicazione e scaricala su un controller. Avviare la traccia e l'applicazione. Nella traccia è possibile seguire il movimento dell'asse virtuale. Presta attenzione alla durata fino alla posizione 8 e alla dinamica alla posizione 8. " }, 
{ "title" : "Movimenti sincroni di due assi ", 
"url" : "_sm_basic_synch_movements_2_axis_example.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti sincroni di due assi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Ingranaggi elettronici, sfasamento e compensazione del gioco degli ingranaggi ", 
"url" : "_sm_basic_example_synchronized_motion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti sincroni di due assi \/ Ingranaggi elettronici, sfasamento e compensazione del gioco degli ingranaggi ", 
"snippet" : "Vedi il BasicMotion_SynchronizedMotion.project esempio nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come utilizzare un riduttore elettronico in combinazione con uno sfasamento e una compensazione del gioco degli ingranaggi....", 
"body" : "Vedi il BasicMotion_SynchronizedMotion.project esempio nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come utilizzare un riduttore elettronico in combinazione con uno sfasamento e una compensazione del gioco degli ingranaggi. " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti sincroni di due assi \/ Ingranaggi elettronici, sfasamento e compensazione del gioco degli ingranaggi \/ Struttura dell'applicazione ", 
"snippet" : "L'applicazione consiste in una semplice macchina a stati nel formato PLC_PRG programma e una traccia che può essere utilizzata per monitorare facilmente la funzionalità dei blocchi funzione. Abilitare gli assi con MC_Power . (STATE_POWER ) Avviare i movimenti sincroni e spostare l'asse master in mod...", 
"body" : "L'applicazione consiste in una semplice macchina a stati nel formato PLC_PRG programma e una traccia che può essere utilizzata per monitorare facilmente la funzionalità dei blocchi funzione. Abilitare gli assi con MC_Power . (STATE_POWER ) Avviare i movimenti sincroni e spostare l'asse master in modo continuo tra la posizione 0 e la posizione 100 ( STATE_COMMAND_POS_0 E STATE_COMMAND_POS_1 ). " }, 
{ "title" : "Utilizzo ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti sincroni di due assi \/ Ingranaggi elettronici, sfasamento e compensazione del gioco degli ingranaggi \/ Utilizzo ", 
"snippet" : "L'asse principale (nero nel diagramma della traccia) si muove continuamente avanti e indietro tra la posizione 0 e la posizione 100 ad una velocità massima di 50 unità al secondo. Un cambio elettronico ( MC_GearIn ) con un rapporto di trasmissione di 2:3 converte il movimento principale in Slave0 as...", 
"body" : "L'asse principale (nero nel diagramma della traccia) si muove continuamente avanti e indietro tra la posizione 0 e la posizione 100 ad una velocità massima di 50 unità al secondo. Un cambio elettronico ( MC_GearIn ) con un rapporto di trasmissione di 2:3 converte il movimento principale in Slave0 asse (verde nel diagramma della traccia). La velocità massima risultante dagli ingranaggi è di 75 unità al secondo. Quindi, uno sfasamento ( MC_Phasing ) di 30 unità si applica al Slave1 asse (arancione nel diagramma della traccia). La velocità è identica a Slave0 asse, ad eccezione della fase di rampa-in. Infine, la compensazione del gioco degli ingranaggi viene utilizzata per portare il movimento al limite massimo Drive asse (blu nel diagramma della traccia). A scopo dimostrativo per il gioco degli ingranaggi è stato impostato un valore irrealisticamente elevato di 5 unità. Il diagramma mostra un movimento di compensazione all'inizio del movimento e ad ogni inversione della direzione del movimento. " }, 
{ "title" : "GearInPos (sega volante) ", 
"url" : "_sm_basic_example_gearinpos.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti sincroni di due assi \/ GearInPos (sega volante) ", 
"snippet" : "Vedi il BasicMotion_GearInPos.project esempio nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come utilizzare MC_GearInPos per implementare una sega volante. Per questo progetto, consigliamo l'installazione CODESYS Depictor , che può visualizz...", 
"body" : "Vedi il BasicMotion_GearInPos.project esempio nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come utilizzare MC_GearInPos per implementare una sega volante. Per questo progetto, consigliamo l'installazione CODESYS Depictor , che può visualizzare l'applicazione come animazione 3D. (La versione gratuita senza licenza è sufficiente per farlo.) " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4565133330038434227193133829", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti sincroni di due assi \/ GearInPos (sega volante) \/ Struttura dell'applicazione ", 
"snippet" : "L'applicazione è costituita da una macchina a stati nel file PLC_PRG programma, una rappresentazione 3D (Scena, DepictorCalculation programma), una semplice simulazione del pezzo ( SimulateWorkpiece programma) e una traccia che può essere utilizzata per comprendere facilmente l'effetto dei blocchi f...", 
"body" : "L'applicazione è costituita da una macchina a stati nel file PLC_PRG programma, una rappresentazione 3D (Scena, DepictorCalculation programma), una semplice simulazione del pezzo ( SimulateWorkpiece programma) e una traccia che può essere utilizzata per comprendere facilmente l'effetto dei blocchi funzione. Il flusso in PLC_PRG è il seguente: Abilitare gli assi con MC_Power . ( STATE_POWER ) Attendere fino a quando la fotocellula rileva un pezzo. ( STATE_WAIT_FOR_WORKPIECE ) Non appena la fotocellula rileva un pezzo, lo slave che trasporta la sega parallelamente al nastro trasportatore viene sincronizzato con il pezzo sul nastro trasportatore (controllato dal Master asse). ( STATE_WAIT_FOR_SYNC ) Una volta raggiunta la sincronizzazione, la sega viene spostata avanti e indietro una volta perpendicolarmente al pezzo da lavorare. ( STATE_MOVE_TOOL_0\/1 ) Spostare lo slave nella posizione di riposo e riavviare il processo da 2. ( STATE_MOVE_TO_REST ) " }, 
{ "title" : "Sistemi di coordinate e dimensioni ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4627667581768034227193767932", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti sincroni di due assi \/ GearInPos (sega volante) \/ Sistemi di coordinate e dimensioni ", 
"snippet" : "L'origine del sistema di coordinate è al centro del nastro trasportatore, l'asse Z punta verso l'alto e l'asse X punta nella direzione di movimento del nastro trasportatore. Dal nastro trasportatore, l'asse Y punta lontano dalla sega. Le dimensioni del nastro trasportatore e del pezzo, la posizione ...", 
"body" : "L'origine del sistema di coordinate è al centro del nastro trasportatore, l'asse Z punta verso l'alto e l'asse X punta nella direzione di movimento del nastro trasportatore. Dal nastro trasportatore, l'asse Y punta lontano dalla sega. Le dimensioni del nastro trasportatore e del pezzo, la posizione della fotocellula e la posizione in cui la sega funziona in sincronia con il pezzo vengono memorizzate come costanti nel GVL Const . " }, 
{ "title" : "Utilizzo ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm458752582335683422719410462", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Movimenti sincroni di due assi \/ GearInPos (sega volante) \/ Utilizzo ", 
"snippet" : "Avviare l'applicazione. Nel Scena Oggetto descrittore e nella traccia è possibile vedere come viene eseguita la sincronizzazione tra il master (pezzo sul nastro trasportatore) e lo slave (sega)....", 
"body" : "Avviare l'applicazione. Nel Scena Oggetto descrittore e nella traccia è possibile vedere come viene eseguita la sincronizzazione tra il master (pezzo sul nastro trasportatore) e lo slave (sega). " }, 
{ "title" : "Camme ", 
"url" : "_sm_basic_examples_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Camme alternate ", 
"url" : "_sm_example_changing_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Camme alternate ", 
"snippet" : "Vedi il PLCopenMultiCAM.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come è possibile creare un movimento di camma con due camme alternate. Il programma è implementato in ST ed esegue le stesse azioni dell'esempi...", 
"body" : "Vedi il PLCopenMultiCAM.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come è possibile creare un movimento di camma con due camme alternate. Il programma è implementato in ST ed esegue le stesse azioni dell'esempio \"Cam Drive Control using a Virtual Time Axis\". Alla fine della prima camma, il MC_CamIn blocco funzione imposta il EndOfProfile produzione. In questo modo, l'altra tabella di curve è assegnata a MC_CamTableSelect e MC_CamIn viene riavviato. " }, 
{ "title" : "Controllo di un Cam Drive con un asse temporale virtuale ", 
"url" : "_sm_example_drive_control_virtual_time_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Controllo di un Cam Drive con un asse temporale virtuale ", 
"snippet" : "Vedi il PLCopenMulti.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come implementare una camma periodica su un azionamento lineare. L'esempio mostra anche come utilizzare la funzione punteria. Inserisci una camma ...", 
"body" : "Vedi il PLCopenMulti.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come implementare una camma periodica su un azionamento lineare. L'esempio mostra anche come utilizzare la funzione punteria. Inserisci una camma chiamata Example nell'albero dei dispositivi qui sotto Applicazione . Apri la cam nell'editor. Definire una punteria sul punteria scheda. X : 8.0 Passaggio positivo : Invert Passaggio negativo : Invert Inserisci un'unità virtuale denominata Drive nell'albero dei dispositivi qui sotto Pool di assi generali SoftMotion . Per questo asse, seleziona il tipo di asse Modulo con un valore modulo di 360 . Inserisci un'altra unità virtuale denominata Virtual . Per questo asse, selezionare il Modulo tipo di asse con un valore modulo di 10 . Creare un MOTION_PRG programma in CFC. PROGRAM MOTION_PRG\nVAR\n power1, power2: MC_Power;\n TableSelect: MC_CamTableSelect;\n CamIn: MC_CamIn;\n Tappet: SMC_GetTappetValue;\n MoveVirtual: MC_MoveVelocity;\nEND_VAR Inserisci un elemento box e assegna la variabile power1 ad esso. L'elemento box viene utilizzato per l'accensione del Drive . Configurare gli ingressi come segue: Asse : Drive Abilitare : TRUE bRegulatorOn : TRUE bDriveStart TRUE Inserisci un elemento box e assegna la variabile power2 ad esso. L'elemento box viene utilizzato per l'accensione del Virtual unità. Configurare gli ingressi come segue: Asse : Virtual Abilitare : TRUE bRegulatorOn : TRUE bDriveStart TRUE Inserisci un elemento box e assegna la variabile MoveVirtual ad esso. L'elemento box viene utilizzato per spostare il master virtuale. Configurare gli ingressi come segue: Asse : Virtual Eseguire : power2.Status Velocità : 2 Accelerazione 10 Decelerazione 10 Direzione positive Inserisci un elemento box e assegna la variabile TableSelect ad esso. L'elemento box viene utilizzato per selezionare una camma. Configurare gli ingressi come segue: Maestro : Virtual Schiavo : Drive CamTable : Example Eseguire TRUE Periodico TRUE MasterAbsolute TRUE schiavoassoluto TRUE Inserisci un elemento box e assegna la variabile CamIn ad esso. L'elemento box implementa la piastra camma selezionata. Configurare gli ingressi come segue: Maestro : Virtual Schiavo : Drive Eseguire power1.Status MasterOffset : 0 SlaveOffset : 0 MasterScaling : 1 Ridimensionamento degli schiavi : 1 StartModalità : absolute CamTableID : TableSelect.CamTableID VelocityDiff : 1 Accelerazione : 1 Decelerazione : 1 Isteresi della punteria : 1 Inserisci un elemento box e assegna la variabile Tappet ad esso. L'elemento box controlla l'impostazione dell'interruttore a camme. Configurare gli ingressi come segue: punterie : CamIn.Tappets iID : 1 bInitValue FALSE bSetInitValueAtReset : FALSE La punteria è definita come punteria invertente. Per questo motivo il suo valore viene modificato ogni 10 secondi. Il progetto di esempio fornisce una visualizzazione per il controllo dei singoli blocchi funzionali e della posizione degli assi. Aggiungi la chiamata del MOTION_PRG programma per il compito Compito principale . Scarica il progetto sul controller e avvialo. Per ulteriori informazioni, vedere: MC_Potenza MC_CamTableSelect MC_CamIn SMC_GetTappetValue MC_MoveVelocity " }, 
{ "title" : "Creazione di camme a livello di codice ", 
"url" : "_sm_basic_example_cam_programmatic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Creazione di camme a livello di codice ", 
"snippet" : "IL BasicMotion_CreateCamTableOnline.project progetto di esempio si trova nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . L'esempio mostra come è possibile utilizzare il codice IEC per creare e utilizzare una camma. I seguenti punti sono trattati qui: Una camma crea...", 
"body" : "IL BasicMotion_CreateCamTableOnline.project progetto di esempio si trova nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . L'esempio mostra come è possibile utilizzare il codice IEC per creare e utilizzare una camma. I seguenti punti sono trattati qui: Una camma creata nell'editor delle camme viene creata nuovamente utilizzando il codice IEC. In un caso, il disco a camme viene generato nel task del bus. Nell'altro caso, il disco a camme viene generato in un'operazione separata. Quindi, tutte e tre le camme vengono eseguite con lo stesso asse principale e diversi assi slave. Il movimento dei tre slave è identico. La camma generata nel codice IEC viene visualizzata nella visualizzazione. Per ulteriori informazioni sulla creazione programmatica delle camme, vedere: Creazione di camme a livello di codice" }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Creazione di camme a livello di codice \/ Struttura dell'applicazione ", 
"snippet" : "L'applicazione è composta dai seguenti componenti: CamOffline La camma creata nell'editor delle camme che deve essere creata nuovamente utilizzando il codice IEC. PLC_PRG Il programma è composto da una semplice macchina a stati e, logicamente, da tre parti. Nella prima e nella seconda parte, viene c...", 
"body" : "L'applicazione è composta dai seguenti componenti: CamOffline La camma creata nell'editor delle camme che deve essere creata nuovamente utilizzando il codice IEC. PLC_PRG Il programma è composto da una semplice macchina a stati e, logicamente, da tre parti. Nella prima e nella seconda parte, viene creata una camma in codice IEC. Nella terza parte, vengono eseguite le camme create in precedenza e una camma identica creata offline Parte 1: Nel primo stato STATE_CREATE_ONLINE_TABLE , viene creata una camma in codice IEC. IL SMCB.CamBuilder blocco funzione da SM3_CamBuilder la biblioteca viene utilizzata a questo scopo. Vengono aggiunti tre segmenti: un elemento Poly5 seguito da un elemento Line e un altro elemento Poly5. Il costruttore genera un file CamOnline cam da questo. Da questo momento in poi la camma viene creata in codice IEC e può essere utilizzata allo stesso modo della camma CamOffline camma creata offline nell'editor camma. Parte 2: Nel STATE_INIT_ONLINE_TABLE_MULTITASK , STATE_START_CREATE_ONLINE_TABLE_MULTITASK e STATE_READ_ONLINE_TABLE_MULTITASK afferma che la creazione della camma viene avviata in un'altra operazione e quindi viene letta. Parte 3: Nel STATE_POWER_DRIVES stato, gli assi virtuali per il master e i tre assi slave vengono inizializzati. Le camme vengono quindi selezionate utilizzando MC_CamTableSelect nel STATE_SELECT_TABLE stato ed eseguito in finale STATE_MOVEMENT stato. L'asse principale viene spostato usando MC_MoveVelocity e viene utilizzato come master per le tre camme. MultitaskCamBuilder Un programma che genera una camma come descritto nella Parte 1 di PLC_PRG . L'unica differenza qui è che viene utilizzata una variante multitask\/multicore sicura della videocamera GVL La variante multitask\/multicore-safe della cam viene istanziata qui. Visualization La visualizzazione contiene SMC_Visu_CamDisplayer elemento per la visualizzazione delle camme. La camma generata nella parte 1 di PLC_PRG viene visualizzato. CamDisplayerSettings Elementi aggiuntivi per la visualizzazione della camma in Visualization Trace È possibile utilizzare la traccia per tracciare il movimento degli assi virtuali. Viene registrata la posizione corrente del master, nonché la posizione, la velocità e l'accelerazione dei tre assi slave " }, 
{ "title" : "La messa in produzione ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Creazione di camme a livello di codice \/ La messa in produzione ", 
"snippet" : "Costruisci l'applicazione e scaricala su un controller. Avviare la traccia e l'applicazione. Osservare la traccia del campionamento. Visualizzazione della camma generata nella visualizzazione...", 
"body" : "Costruisci l'applicazione e scaricala su un controller. Avviare la traccia e l'applicazione. Osservare la traccia del campionamento. Visualizzazione della camma generata nella visualizzazione " }, 
{ "title" : "Utilizzo di MC_DigitalCamSwitch_HighPrecision ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Utilizzo di MC_DigitalCamSwitch_HighPrecision ", 
"snippet" : "L'esempio BasicMotion_DigitalCamSwitch_HighPrecision.project si trova nella directory di installazione CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come utilizzare gli output di SMC_DigitalCamSwitch_HighPrecision per controllare le uscite digitali con alta risoluzione tempora...", 
"body" : "L'esempio BasicMotion_DigitalCamSwitch_HighPrecision.project si trova nella directory di installazione CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come utilizzare gli output di SMC_DigitalCamSwitch_HighPrecision per controllare le uscite digitali con alta risoluzione temporale. I terminali EL2258 ed EL2252 di Beckhoff sono usati Le descrizioni dei dispositivi di Beckhoff non sono incluse nell'esempio. È possibile scaricarli direttamente dal fornitore e installarli nel repository dei dispositivi. Per eseguire l'esempio, sono necessari un accoppiatore bus EK1100, un terminale EL2258 e un terminale EL2252 Questo esempio è stato sviluppato e testato secondo la revisione 0017 di EL2258 e la revisione 0020 di EL2252. Serve solo come esempio. Non garantiamo la correttezza. Il codice sorgente deve essere testato prima dell'uso. Se necessario, deve essere modificato con altre revisioni dei terminali " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856510750361", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Utilizzo di MC_DigitalCamSwitch_HighPrecision \/ Struttura dell'applicazione ", 
"snippet" : "L'applicazione è composta da Main programma, DigitalCamSwitch_EL2258 e DigitalCamSwitch_EL2252 blocchi funzionali e un accoppiatore bus EK1100 con terminali di uscita EL2258 ed EL2252. Le DigitalCamSwitch_EL2258 e DigitalCamSwitch_EL2252 blocchi funzionali sono le parti essenziali dell'esempio. Most...", 
"body" : "L'applicazione è composta da Main programma, DigitalCamSwitch_EL2258 e DigitalCamSwitch_EL2252 blocchi funzionali e un accoppiatore bus EK1100 con terminali di uscita EL2258 ed EL2252. Le DigitalCamSwitch_EL2258 e DigitalCamSwitch_EL2252 blocchi funzionali sono le parti essenziali dell'esempio. Mostrano come usare il Events uscita di SMC_DigitalCamSwitch_HighPrecision per programmare uscite digitali. I blocchi funzionali devono essere intesi come esempi che possono essere adattati ad altro hardware " }, 
{ "title" : "DigitalCamSwitch_EL2258 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856513787236", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Utilizzo di MC_DigitalCamSwitch_HighPrecision \/ Struttura dell'applicazione \/ DigitalCamSwitch_EL2258 ", 
"snippet" : "Il blocco funzionale funziona come segue: Il blocco funzione viene inizializzato su un bordo ascendente in corrispondenza del Enable input. STATE_INIT_0 e STATE_INIT_1 afferma, il OutputBufferReset i segnali del terminale EL2258 vengono scritti e aLastEventIds l'array è inizializzato. L'ID dell'ulti...", 
"body" : "Il blocco funzionale funziona come segue: Il blocco funzione viene inizializzato su un bordo ascendente in corrispondenza del Enable input. STATE_INIT_0 e STATE_INIT_1 afferma, il OutputBufferReset i segnali del terminale EL2258 vengono scritti e aLastEventIds l'array è inizializzato. L'ID dell'ultimo evento elaborato per ogni traccia viene salvato in questo array. Ciò impedisce che un evento venga trasferito più volte al terminale. Una volta inizializzato ( STATE_ACTIVE ), tutte le tracce vengono elaborate a turno e per ciascuna traccia viene eseguita la seguente logica: Verificate se il terminale EL2258 ha già accettato gli ultimi eventi comandati ( ChannelsIn[channel].OutputOrderFeedback = ChannelsOut[channel].OutputOrderCounter ). Ripeti tutti gli eventi della traccia. Solo quegli eventi di cui ToggleEventId è maggiore dell'ultimo ID elaborato viene considerato ulteriormente. (Interrogazione EventId_GreaterThan(event^.ToggleEventId, aLastEventIds[channel]) ) Vedi sezione: «Nota sull'ordine degli eventi». Convertire il Duration dell'evento in un timestamp EtherCAT e corrispondente scrittura del ChannelsOut[channel].OutputEventState e ChannelsOut[channel].OutputEventTime uscite. Interrompe l'elaborazione dopo un massimo di 5 eventi. Notifica al terminale che esistono nuovi eventi se è stato trovato almeno un evento ( ChannelsOut[channel].OutputOrderCounter := ChannelsOut[channel].OutputOrderCounter + 1 ). Nota sull'ordine dell'evento Gli eventi vengono restituiti dal SMC_DigitalCamSwitch_HighPrecision blocco funzionale per ogni traccia in un array. SwitchNumber e un ToggleEventId vengono restituiti per ogni evento. ToggleEventId è unico e crescente per ogni traccia. Per ulteriori informazioni, vedere: SMC_CAMSWITCH_TOGGLE_EVENT . Nell'esempio, aLastEventIds[trackNo] l'array memorizza per ogni traccia che ToggleEventId è stato trasferito l'ultima volta al terminale in una precedente chiamata al blocco funzione. Perché il ToggleEventIds sono in ordine crescente, la chiamata successiva saprà esattamente quali eventi devono ancora essere trasferiti. Due dettagli devono ancora essere considerati: Perché non è noto in quale ToggleEventId gli eventi iniziano, a valid il flag viene salvato in EventId tipo di dati oltre all'ID. EventId_GreaterThan confronto, questo valid la bandiera viene presa in considerazione di conseguenza. Le ToggleEventIds hanno il tipo di dati a 32 bit UDINT e può quindi, in linea di principio, traboccare con una durata rispettivamente lunga o un'elevata frequenza di commutazione. Il valore passa quindi da 2^32-1 a 0. La funzione di confronto EventId_GreaterThan tiene conto anche degli overflow a 32 bit. Mappatura PDO EL2258 Le ChannelsOut e ChannelsIn uscite di DigitalCamSwitch_EL2258 i blocchi funzione sono collegati ai rispettivi canali I\/O del terminale EL2258. L'immagine seguente mostra le mappature per il canale 1. Il canale 2 è simile; solo ChannelsOut e ChannelsIn l'indice è 2, non 1. " }, 
{ "title" : "DigitalCamSwitch_EL2252 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434780928", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Utilizzo di MC_DigitalCamSwitch_HighPrecision \/ Struttura dell'applicazione \/ DigitalCamSwitch_EL2252 ", 
"snippet" : "Il principio di base è identico a DigitalCamSwitch_EL2258 . La differenza sta nel modo in cui i segnali vengono scritti perché il terminale EL2252 può programmare un solo evento attivo Innanzitutto, il blocco funzione viene inizializzato in STATE_INIT . Poi STATE_CHECK_FOR_EVENT controlla se gli eve...", 
"body" : "Il principio di base è identico a DigitalCamSwitch_EL2258 . La differenza sta nel modo in cui i segnali vengono scritti perché il terminale EL2252 può programmare un solo evento attivo Innanzitutto, il blocco funzione viene inizializzato in STATE_INIT . Poi STATE_CHECK_FOR_EVENT controlla se gli eventi di SMC_DigitalCamSwitch_HighPrecision i blocchi funzionali sono in sospeso. Se un evento è disponibile, deve essere programmato entro due cicli: Le uscite e il timestamp EtherCAT vengono scritti nel primo ciclo. Le Activate l'uscita è impostata su 0. Nel secondo ciclo, il Activate l'uscita è impostata su 3 pollici STATE_ACTIVATE_EVENT_IN_EL2252 . Questo attiva l'evento nel terminale Nel STATE_WAIT_UNTIL_THE_INPUTS_MATCH_THE_OUTPUTS il sistema attende quindi che l'evento sia stato eseguito. I segnali provenienti da Feedback a tale scopo vengono utilizzati gli input del terminale. Mappatura PDO EL2252 " }, 
{ "title" : "Main ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434889277", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Utilizzo di MC_DigitalCamSwitch_HighPrecision \/ Struttura dell'applicazione \/ Main ", 
"snippet" : "Nel programma principale, sono configurati quattro interruttori (due su ogni traccia). Le tracce hanno anche diverse compensazioni on\/off ( OnComp , OffComp ): Il programma include le chiamate ai blocchi funzionali necessarie per attivare una previsione per l'asse e spostarlo costantemente a 180°\/s ...", 
"body" : "Nel programma principale, sono configurati quattro interruttori (due su ogni traccia). Le tracce hanno anche diverse compensazioni on\/off ( OnComp , OffComp ): Il programma include le chiamate ai blocchi funzionali necessarie per attivare una previsione per l'asse e spostarlo costantemente a 180°\/s (*), nonché per SMC_DigitalCamSwitch_HighPrecision , DigitalCamSwitch_EL2258 e DigitalCamSwitch_EL2252 . Prima di iniziare il movimento, il bus di campo deve essere completamente acceso. Altrimenti gli eventi non possono essere trasmessi al terminale (*) È stato scelto un movimento costante per mantenere l'esempio semplice e chiaro. Tuttavia, SMC_DigitalCamSwitch_HighPrecision il blocco funzionale funziona con tutti i tipi di movimenti. Ad esempio, fornisce anche timestamp esatti durante una fase di accelerazione o " }, 
{ "title" : "Messa in servizio ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856511865803", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Utilizzo di MC_DigitalCamSwitch_HighPrecision \/ Messa in servizio ", 
"snippet" : "Crea l'applicazione e scaricala su un controller. Avviare l'applicazione....", 
"body" : "Crea l'applicazione e scaricala su un controller. Avviare l'applicazione. " }, 
{ "title" : "Esportazione e importazione di camme ", 
"url" : "_sm_example_cams_export_import.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Esportazione e importazione di camme ", 
"snippet" : "Le BasicMotion_CamExportAndImport.project il progetto di esempio si trova nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . L'esempio mostra come esportare e importare una videocamera....", 
"body" : "Le BasicMotion_CamExportAndImport.project il progetto di esempio si trova nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . L'esempio mostra come esportare e importare una videocamera. " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm235085906313629", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Esportazione e importazione di camme \/ Struttura dell'applicazione ", 
"snippet" : "L'applicazione è composta da PLC_PRG programma e un CamEditor telecamera. PLC_PRG Il programma è costituito da una semplice macchina a stati in cui viene creata una camma in codice IEC nel STATE_CREATE_CAM stato. Per ulteriori informazioni, vedere quanto segue: Creazione di camme a livello di codice...", 
"body" : "L'applicazione è composta da PLC_PRG programma e un CamEditor telecamera. PLC_PRG Il programma è costituito da una semplice macchina a stati in cui viene creata una camma in codice IEC nel STATE_CREATE_CAM stato. Per ulteriori informazioni, vedere quanto segue: Creazione di camme a livello di codice. Quindi questa cam viene esportata nel STATE_EXPORT_CAM stato utilizzando il SMC_WriteCam blocco funzione e quindi importato nel STATE_START_IMPORT_CAM stato utilizzando il SMC_ReadCam blocco funzionale. CamEditor La videocamera non ha alcun significato all'inizio perché non viene utilizzata nell'applicazione. La telecamera esportata da PLC_PRG può essere importato nell'editor delle camme. Questa è una fase manuale descritta nella sezione seguente. " }, 
{ "title" : "Messa in servizio ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm23508590648994", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Camme \/ Esportazione e importazione di camme \/ Messa in servizio ", 
"snippet" : "Crea l'applicazione e scaricala su un controller. Avviare l'applicazione. Le PLC_PRG il programma genera la camma e la esporta nel PlcLogic elenco del controller. Puoi anche visualizzare e modificare la videocamera esportata nell'editor delle camme. Per fare ciò, apri il CamEditor cam e importa la c...", 
"body" : "Crea l'applicazione e scaricala su un controller. Avviare l'applicazione. Le PLC_PRG il programma genera la camma e la esporta nel PlcLogic elenco del controller. Puoi anche visualizzare e modificare la videocamera esportata nell'editor delle camme. Per fare ciò, apri il CamEditor cam e importa la cam usando il Leggi il file della videocamera online comando. Dopo aver apportato le modifiche, è possibile esportare la camma modificata utilizzando Scrivi file Cam online comando. Questa camma può essere letta nel codice IEC con il SMC_ReadCAM blocco funzionale e utilizzato nell'applicazione. " }, 
{ "title" : "Override della velocità per gli assi SoftMotion ", 
"url" : "_sm_example_override.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Override della velocità per gli assi SoftMotion ", 
"snippet" : "IL BasicMotion_Override.project progetto di esempio qui descritto si trova nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come definire un override di velocità per un asse SoftMotion. Per ulteriori informazioni sull'override, vedere: Adattame...", 
"body" : "IL BasicMotion_Override.project progetto di esempio qui descritto si trova nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come definire un override di velocità per un asse SoftMotion. Per ulteriori informazioni sull'override, vedere: Adattamento dinamico con MC_SetOverride" }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4552520462032034028650702932", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Override della velocità per gli assi SoftMotion \/ Struttura dell'applicazione ", 
"snippet" : "L'applicazione è composta da a PLC_PRG programma e a Trace . PLC_PRG Il programma consiste in una semplice macchina a stati. Nel primo stato STATE_POWER , l'asse virtuale Drive è inizializzato. Nel secondo stato STATE_COMMAND_MOVEMENT , viene impostato un override di velocità pari a 0,5 in modo che ...", 
"body" : "L'applicazione è composta da a PLC_PRG programma e a Trace . PLC_PRG Il programma consiste in una semplice macchina a stati. Nel primo stato STATE_POWER , l'asse virtuale Drive è inizializzato. Nel secondo stato STATE_COMMAND_MOVEMENT , viene impostato un override di velocità pari a 0,5 in modo che i movimenti dell'asse vengano eseguiti solo a metà velocità. Viene quindi eseguito un movimento utilizzando MC_MoveAbsolute alla posizione 10. Nel blocco funzione è specificata una velocità massima di 20 unità\/s. A causa dell'override di velocità impostato nell'asse virtuale, il movimento viene eseguito ad una velocità massima di 10 unità\/s. Non appena è completata la metà del movimento nella posizione 5, l'override di velocità viene ridotto a 0,25 nel STATE_CHANGE_OVERRIDE stato. L'asse decelera a 5 unità\/s ed esegue il resto del movimento a questa velocità. Nel programma vengono letti anche i fattori di override attivi (velocità, accelerazione e jerk) dell'asse virtuale. IL SMC_GetOverride a questo scopo viene utilizzato il blocco funzione. Traccia La traccia può essere utilizzata per tracciare il movimento dell'asse virtuale. Vengono registrate la posizione attualmente specificata, la velocità e l'accelerazione dell'asse e l'override di velocità attivo. " }, 
{ "title" : "La messa in produzione ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4563439233780834028650966211", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Override della velocità per gli assi SoftMotion \/ La messa in produzione ", 
"snippet" : "Costruisci l'applicazione e scaricala su un controller. Avviare la traccia e l'applicazione. Nella traccia è possibile seguire il movimento dell'asse virtuale....", 
"body" : "Costruisci l'applicazione e scaricala su un controller. Avviare la traccia e l'applicazione. Nella traccia è possibile seguire il movimento dell'asse virtuale. " }, 
{ "title" : "Rampa basata sulla distanza ", 
"url" : "_sm_axis_based_ramp_in.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Rampa basata sulla distanza ", 
"snippet" : "IL BasicMotion_CamIn_StartModes.project progetto di esempio qui descritto si trova nella directory di installazione di CODESYS sotto il ..\\CODESYS SoftMotion\\Examples directory. Questo esempio mostra come utilizzare il file StartMode ingresso del MC_CamIn blocco funzione. Questo ingresso viene utili...", 
"body" : "IL BasicMotion_CamIn_StartModes.project progetto di esempio qui descritto si trova nella directory di installazione di CODESYS sotto il ..\\CODESYS SoftMotion\\Examples directory. Questo esempio mostra come utilizzare il file StartMode ingresso del MC_CamIn blocco funzione. Questo ingresso viene utilizzato per configurare il modo in cui l'asse slave viene sincronizzato con l'asse master quando MC_CamIn è iniziato. Fondamentalmente le strade possibili sono tre: L'asse slave segue immediatamente la traiettoria specificata dalla camma e dall'asse master. A seconda dello stato iniziale dell'asse slave, ciò può portare ad un salto di posizione, velocità e\/o accelerazione dell'asse slave. StartMode : absolute , relative L'asse slave si sincronizza il più rapidamente possibile mantenendo i limiti predefiniti di velocità, accelerazione, decelerazione e jerk. StartMode : ramp_in , ramp_in_pos , ramp_in_neg Nella camma viene specificata una posizione master in cui l'asse slave deve seguire la traiettoria specificata dalla camma e dall'asse master. La sincronizzazione avviene su una distanza configurabile dall'asse master. StartMode : ramp_in_dist Per ulteriori informazioni sul blocco funzione MC_CamIn, vedere: MC_CamIn (FB) " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4561064201451234280796827706", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Rampa basata sulla distanza \/ Struttura dell'applicazione ", 
"snippet" : "L'applicazione è composta da a PLC_PRG programma e una traccia. Inoltre, ci sono quattro assi virtuali: l'asse master Master e i tre assi slave SlaveAbsolute , SlaveRampIn , e SlaveRampInDist . E c'è la disco a camme  Cam . Nel PLC_PRG programma, tre istanze di MC_CamIn vengono eseguiti con il Start...", 
"body" : "L'applicazione è composta da a PLC_PRG programma e una traccia. Inoltre, ci sono quattro assi virtuali: l'asse master Master e i tre assi slave SlaveAbsolute , SlaveRampIn , e SlaveRampInDist . E c'è la disco a camme  Cam . Nel PLC_PRG programma, tre istanze di MC_CamIn vengono eseguiti con il StartMode input impostare diversamente: ciSlaveAbsolute con StartMode = absolute ciSlaveRampIn con StartMode = ramp_in ciSlaveRampInDist con StartMode = ramp_in_dist Le istanze dei blocchi funzione controllano gli assi virtuali corrispondenti SlaveAbsolute , SlaveRampIn , E SlaveRampInDist . L'asse master viene spostato a velocità costante utilizzando un MC_MoveVelocity esempio. Le traiettorie dei tre assi slave e il Active E InSync uscite del MC_CamIn le istanze possono essere tracciate nella traccia. Tutto MC_CamIn le istanze vengono avviate quando l'asse master supera la posizione 40: IL SlaveAbsolute l'asse salta immediatamente ai valori impostati definiti dalla camma. Il corrispondente MC_CamIn l'istanza è immediatamente Active E InSync . IL SlaveRampIn l'asse si sincronizza mantenendo i limiti dinamici comandati. Il corrispondente MC_CamIn l'istanza è immediatamente Active . Dalla posizione principale ~114 , l'asse slave segue la traiettoria specificata dalla camma e l'asse master e il MC_CamIn rapporti di istanza InSync . IL SlaveRampInDist l'asse principale rimane fermo finché l'asse master non si è avvicinato al MasterSyncPosition di 120 fino al MasterStartDistance di 60 configurati sul MC_CamIn instance . Quindi inizia la sincronizzazione e il file MC_CamIn rapporti di istanza Active . Quando l'asse master raggiunge il MasterSyncPosition Di 120 , l'asse slave segue la traiettoria specificata dalla camma e l'asse master e il MC_CamIn rapporti di istanza InSync . " }, 
{ "title" : "La messa in produzione ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4602846053456034280814845985", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Esempi \/ Rampa basata sulla distanza \/ La messa in produzione ", 
"snippet" : "Costruisci l'applicazione e scaricala su un controller. Avviare la traccia e l'applicazione. Nella traccia è possibile seguire il movimento degli assi virtuali....", 
"body" : "Costruisci l'applicazione e scaricala su un controller. Avviare la traccia e l'applicazione. Nella traccia è possibile seguire il movimento degli assi virtuali. " }, 
{ "title" : "Interfaccia utente ", 
"url" : "_sm_basic_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaccia utente ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Camera ", 
"url" : "_sm_basic_user_interface_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaccia utente \/ Camera ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Finestra di dialogo: Proprietà – Cam ", 
"url" : "_sm_dlg_properties_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaccia utente \/ Camera \/ Finestra di dialogo: Proprietà – Cam ", 
"snippet" : "Funzione : Utilizzare questa finestra di dialogo per definire le variabili globali della camma. Dimensioni Posizione iniziale\/finale principale Le posizioni iniziale e finale del master definiscono l'intervallo dei valori master e quindi la scala dell'asse orizzontale della camma. Le impostazioni pr...", 
"body" : "Funzione : Utilizzare questa finestra di dialogo per definire le variabili globali della camma. Dimensioni Posizione iniziale\/finale principale Le posizioni iniziale e finale del master definiscono l'intervallo dei valori master e quindi la scala dell'asse orizzontale della camma. Le impostazioni predefinite sono fornite in gradi angolari con 0 e 360 come valori limite. Posizione iniziale\/finale slave Le posizioni slave associate sono determinate dal tipo di grafico definito per la camma. Tuttavia, il segmento rappresentato dalle curve (questa è anche la scala dell'asse verticale) può essere definito dalle posizioni di inizio e di fine dello slave qui riportate. Periodo Queste impostazioni influenzano il lavoro nell'editor delle camme e nella tabella delle camme. A seconda di questi parametri, il punto iniziale dello slave viene adattato automaticamente quando viene modificato il punto finale e viceversa. Questa regolazione ottimizza la transizione del periodo in modo che sia quanto più fluida e senza strappi possibile. Transizione graduale : I valori di posizione, velocità e accelerazione vengono regolati automaticamente. periodo schiavo Indica quando il periodo slave viene ripetuto meccanicamente. Quindi la posizione dello slave all'inizio e alla fine del periodo master può deviare di un multiplo intero di questo valore. Questo valore è efficace solo se il Transizione graduale casella di controllo è selezionata. Requisiti di continuità L'attivazione di queste opzioni per la continuità della curva non ha alcun effetto durante la modifica della camma. Tuttavia, richiede un controllo di continuità, che segnala eventuali violazioni alla visualizzazione del messaggio ( CAMERA categoria). Non è possibile modificare i salti nella curva di posizione. L'impostazione predefinita richiede anche la continuità di velocità e accelerazione. È possibile deselezionare queste opzioni, ad esempio nel caso speciale di una curva composta solo da segmenti lineari. Tuttavia, ciò può portare a rotture nella curva di posizione. Per impostazione predefinita, il jerk (4a derivata) non viene testato per i salti. Posizione : La curva viene controllata per i salti. Velocità Accelerazione Cretino Formato di compilazione Durante la compilazione, MC_CAM_REF struttura vengono generate. Una camma viene descritta in base alle seguenti opzioni: polinomio (XYVA) Descrizione polinomiale dei singoli punti, costituita da posizione master, posizione slave, velocità slave e accelerazione slave. matrice di punti unidimensionale Tabella 1D delle posizioni degli slave matrice di punti bidimensionale Tabella 2D delle posizioni master\/slave composite Elementi Numero di elementi per le matrici di punti monodimensionali o bidimensionali. Questo array è già stato creato in SM3_Basic per i casi standard 128 e 256 . Se si digita un altro valore, è necessario creare la struttura nell'applicazione. A tale proposito, vedete l'esempio seguente. Segmenti Formato di compilazione standard; supporta tutti i tipi di segmenti Esempio di un array con 720 elementi TYPE SMC_CAMTable_LREAL_720_2 :\nSTRUCT\n Table: ARRAY[0..719] OF ARRAY[0..1] OF LREAL;\n fEditorMasterMin, fEditorMasterMax: REAL;\n fEditorSlaveMin, fEditorSlaveMax: REAL;\n fTableMasterMin, fTableMasterMax: REAL;\n fTableSlaveMin, fTableSlaveMax: REAL;\nEND_STRUCT\nEND_TYPE Per ulteriori informazioni, vedere: Come creare una telecamera" }, 
{ "title" : "Comando: Mostra codice generato ", 
"url" : "_sm_cmd_cam_display_generated_code.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaccia utente \/ Camera \/ Comando: Mostra codice generato ", 
"snippet" : "Mostra codice generato Funzione : Il comando apre il Codice generato finestra di dialogo in cui viene visualizzato il codice di inizializzazione IEC della camma rappresentata. Chiamata : Camera menù Requisiti : L'editor della camma è aperto e mostra una camma. Non viene visualizzato alcun codice gen...", 
"body" : "Mostra codice generato Funzione : Il comando apre il Codice generato finestra di dialogo in cui viene visualizzato il codice di inizializzazione IEC della camma rappresentata. Chiamata : Camera menù Requisiti : L'editor della camma è aperto e mostra una camma. Non viene visualizzato alcun codice generato per Segmenti formato di compilazione. Il codice generato non è più necessario perché l'API CamBuilder può essere utilizzata per generare camme a livello di codice in un modo Finestra di dialogo: codice generato Esempio: codice di inizializzazione IEC {attribute 'linkalways'}\n\nVAR_GLOBAL\nCam_A: ARRAY[0..3] OF SMC_CAMXYVA := [\n (dX := 0, dY := 0, dV := 0, dA := 0),\n (dX := 120, dY := 120, dV := 1, dA := 0),\n (dX := 240, dY := 240, dV := 1, dA := 0),\n (dX := 360, dY := 360, dV := 0, dA := 0)];\nCam: MC_CAM_REF := (nElements := 4, byType := 3, xStart := 0, xEnd := 360, nTappets := 0, strCAMName := 'Cam', pce := ADR(Cam_A), xPartofLM := TRUE);\nEND_VAR " }, 
{ "title" : "Comando: Leggi i dati della camma dalla tabella ASCII ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaccia utente \/ Camera \/ Comando: Leggi i dati della camma dalla tabella ASCII ", 
"snippet" : "Leggi i dati della camma dalla tabella ASCII Funzione : Il comando legge an ASCII file. Chiamata : Camera menù Requisiti : L'editor delle camme è aperto. Durante la lettura, i dati del file vengono interpretati come i valori X\/Y di una camma. Il Numero di punti si apre la finestra di dialogo in cui ...", 
"body" : "Leggi i dati della camma dalla tabella ASCII Funzione : Il comando legge an ASCII file. Chiamata : Camera menù Requisiti : L'editor delle camme è aperto. Durante la lettura, i dati del file vengono interpretati come i valori X\/Y di una camma. Il Numero di punti si apre la finestra di dialogo in cui è possibile diminuire il numero di punti di interpolazione. Quindi i punti rilevati vengono interpolati su una camma elettronica e visualizzati nell'editor. Il Scrivi i dati della camma nella tabella ASCII comandi crea un'appropriata TXT file. " }, 
{ "title" : "Finestra di dialogo: numero di punti ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html#UUID-dc22ffbd-b76b-ca74-a92b-235fbf0143cb_id_d53fe1240e8dd1c0a8640e0032565c_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaccia utente \/ Camera \/ Comando: Leggi i dati della camma dalla tabella ASCII \/ Finestra di dialogo: numero di punti ", 
"snippet" : "Numero di punti Numero di punti utilizzati per l'interpolazione. Preimpostato: in base al numero di valori X\/Y memorizzati nel file letto. Esempio: 256 È possibile diminuire il valore preimpostato per determinare la camma con meno punti di appoggio. Quando si determinano i punti di interpolazione, i...", 
"body" : "Numero di punti Numero di punti utilizzati per l'interpolazione. Preimpostato: in base al numero di valori X\/Y memorizzati nel file letto. Esempio: 256 È possibile diminuire il valore preimpostato per determinare la camma con meno punti di appoggio. Quando si determinano i punti di interpolazione, i loro valori X sono distribuiti equidistanti. Poiché la camma è interpolata utilizzando un polinomio di 5° grado, un numero maggiore di punti di interpolazione può causare oscillazioni. " }, 
{ "title" : "Comando: Scrivi i dati della camma nella tabella ASCII ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaccia utente \/ Camera \/ Comando: Scrivi i dati della camma nella tabella ASCII ", 
"snippet" : "Scrivi i dati della camma nella tabella ASCII Funzione : Il comando crea un ASCII file ( TXT estensione) sul sistema di sviluppo. In questo file viene salvato un numero specificato di valori X\/Y della camma attiva. Si apre prima una finestra di dialogo predefinita e poi il pulsante Numero di punti d...", 
"body" : "Scrivi i dati della camma nella tabella ASCII Funzione : Il comando crea un ASCII file ( TXT estensione) sul sistema di sviluppo. In questo file viene salvato un numero specificato di valori X\/Y della camma attiva. Si apre prima una finestra di dialogo predefinita e poi il pulsante Numero di punti dialogo. Chiamata : Camera menù Requisiti : L'editor della camma è aperto e mostra una camma. " }, 
{ "title" : "Finestra di dialogo: numero di punti ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html#UUID-b84e5af8-679e-916c-e8a6-2358c4cccb5c_id_c2bdaa8241199e2c0a8640e018c7af7_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaccia utente \/ Camera \/ Comando: Scrivi i dati della camma nella tabella ASCII \/ Finestra di dialogo: numero di punti ", 
"snippet" : "La tabella ASCII non contiene alcuna informazione sulle camme. Numero di punti Numero di valori X\/Y salvati nel file e rappresentati nella forma della curva. A tal fine, la curva X viene divisa equidistantemente e viene determinato il rispettivo valore Y....", 
"body" : "La tabella ASCII non contiene alcuna informazione sulle camme. Numero di punti Numero di valori X\/Y salvati nel file e rappresentati nella forma della curva. A tal fine, la curva X viene divisa equidistantemente e viene determinato il rispettivo valore Y. " }, 
{ "title" : "Comando: Leggi il file Cam Online ", 
"url" : "_sm_cmd_cam_read_online_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaccia utente \/ Camera \/ Comando: Leggi il file Cam Online ", 
"snippet" : "Leggi il file della videocamera online Funzione : Il comando legge un file esterno con i dati della camma. L'estensione del file è CAM . La camma viene visualizzata nell'editor delle camme. Chiamata : Camera menù Requisiti : L'editor delle camme è aperto. Il Scrivi file Cam online comando crea un fi...", 
"body" : "Leggi il file della videocamera online Funzione : Il comando legge un file esterno con i dati della camma. L'estensione del file è CAM . La camma viene visualizzata nell'editor delle camme. Chiamata : Camera menù Requisiti : L'editor delle camme è aperto. Il Scrivi file Cam online comando crea un file appropriato in CAM formato. " }, 
{ "title" : "Comando: Scrivi file Cam Online ", 
"url" : "_sm_cmd_cam_write_online_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interfaccia utente \/ Camera \/ Comando: Scrivi file Cam Online ", 
"snippet" : "Scrivi file Cam online Funzione : Il comando crea un file ( CAM estensione). Il file contiene i dati della camma attiva nell'editor. Chiamata : Camera menù Requisiti : L'editor della camma è aperto e mostra una camma. I dati della camma sono composti da una descrizione della camma e dalle posizioni ...", 
"body" : "Scrivi file Cam online Funzione : Il comando crea un file ( CAM estensione). Il file contiene i dati della camma attiva nell'editor. Chiamata : Camera menù Requisiti : L'editor della camma è aperto e mostra una camma. I dati della camma sono composti da una descrizione della camma e dalle posizioni e dai tipi di camme. UN CAM il file può essere letto nell'editor tramite il tasto Leggi il file online della videocamera comando. Inoltre, un'istanza di SMC_ReadCAM il blocco funzione può leggere il file per caricare una tabella camma nell'applicazione in fase di esecuzione. Per ulteriori informazioni, vedere: Strutture dati delle camme" }, 
{ "title" : "CODESYS SoftMotion CNC ", 
"url" : "_sm_f_cnc.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Editore ", 
"url" : "_sm_f_cnc_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_sm_overview_cnc_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Panoramica ", 
"snippet" : "Nell'editor CNC si realizzano movimenti multidimensionali complessi nell'editor tabellare o nell'editor di testo secondo il linguaggio CNC della norma DIN 66025. Inoltre l'editor offre quanto segue: Editor grafico per la visualizzazione del percorso Casella degli strumenti per l'editor grafico Vista...", 
"body" : "Nell'editor CNC si realizzano movimenti multidimensionali complessi nell'editor tabellare o nell'editor di testo secondo il linguaggio CNC della norma DIN 66025. Inoltre l'editor offre quanto segue: Editor grafico per la visualizzazione del percorso Casella degli strumenti per l'editor grafico Vista con le proprietà dell'elemento del percorso selezionato " }, 
{ "title" : "Fondamenti dell'editor CNC ", 
"url" : "_sm_cnc_edt_basics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Fondamenti dell'editor CNC ", 
"snippet" : "Con la DIN 66025 è possibile creare percorsi fino a 9 dimensioni. Tre di queste dimensioni non sono interpolate linearmente. In X\/Y\/Z è possibile programmare linee, archi, ellissi, parabole e spline. Sono forniti altri otto assi aggiuntivi. Di questi, cinque sono interpolati linearmente (P\/Q\/U\/V\/W) ...", 
"body" : "Con la DIN 66025 è possibile creare percorsi fino a 9 dimensioni. Tre di queste dimensioni non sono interpolate linearmente. In X\/Y\/Z è possibile programmare linee, archi, ellissi, parabole e spline. Sono forniti altri otto assi aggiuntivi. Di questi, cinque sono interpolati linearmente (P\/Q\/U\/V\/W) e tre con un polinomio di 3° grado (A\/B\/C). Per ogni blocco di movimento nel programma CNC, l'interpolatore calcola il percorso di traslazione. Allo stesso tempo, l'interpolatore calcola la forma del percorso, la velocità, l'accelerazione e lo strappo in base all'interpolazione specificata. Per ogni percorso programmato, CODESYS crea automaticamente una struttura dati globale con i dati CNC che possono essere utilizzati in un programma IEC. Ci sono diverse opzioni per questo scopo: SMC_CNC_REF : Il programma CNC viene salvato come un array di parole in codice G che vengono elaborate durante il runtime dell'applicazione mediante SMC_NCInterpreter . Il risultato è il percorso CNC descritto come una sequenza di oggetti struttura GEOINFO. Mediante i moduli di preelaborazione del percorso della libreria SM3_CNC (esempio: correzione raggio utensile), questi oggetti possono essere modificati, interpolati, trasformati e trasferiti dall'interfaccia dell'azionamento all'hardware per la comunicazione. SMC_OUTQUEUE : Il programma CNC viene scritto in una struttura dati come un elenco di oggetti struttura GEOINFO con il nome SMC_OUTQUEUE , e può quindi essere inserito direttamente nell'interpolatore. Di conseguenza, in contrasto con SMC_CNC_REF , non è necessario richiamare il blocco funzionale interprete e il blocco funzionale di preelaborazione del percorso. Tuttavia, il programma non può essere modificato in fase di esecuzione e nessuna variabile nel codice G può essere utilizzata in questa modalità. FILE : Quindi il programma CNC viene salvato come file ASCII nel file system del controller e letto e implementato passo dopo passo. Questo metodo è appropriato soprattutto per programmi di grandi dimensioni che non possono essere archiviati interamente nella memoria. È anche appropriato per i programmi che sono stati generati dall'utente dopo aver compilato l'applicazione del controller. " }, 
{ "title" : "Struttura dell'editor CNC ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_43423fe2e9a24fa0c0a864632228473f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Fondamenti dell'editor CNC \/ Struttura dell'editor CNC ", 
"snippet" : "L'editor CNC è costituito dai seguenti componenti: Editor principale: L'editor di testo mostra il programma DIN 66025, oppure l'editor tabellare mostra il percorso del CNC. Editor grafico: qui viene mostrata la rappresentazione grafica del percorso. Proprietà vista degli elementi del CNC Cassetta de...", 
"body" : "L'editor CNC è costituito dai seguenti componenti: Editor principale: L'editor di testo mostra il programma DIN 66025, oppure l'editor tabellare mostra il percorso del CNC. Editor grafico: qui viene mostrata la rappresentazione grafica del percorso. Proprietà vista degli elementi del CNC Cassetta degli attrezzi vista: contiene strumenti per la selezione e l'inserimento di elementi di percorso Quando si preme il F6 tasto, lo stato attivo passa dall'editor principale all'editor grafico. Se nell'editor grafico viene selezionato un elemento di percorso, il rispettivo blocco di movimento o riga viene selezionato implicitamente nell'editor di testo o nell'editor di tabelle. Allo stesso modo, un elemento selezionato nell'editor tabulare o nell'editor di testo viene selezionato anche nell'editor grafico. Le modifiche nell'editor grafico vengono applicate nell'editor di testo o nell'editor tabulare e viceversa. Le impostazioni CNC a livello di applicazione vengono applicate e salvate nel file Impostazioni CNC oggetto. Le impostazioni CNC specifiche dell'oggetto vengono applicate e salvate nel file Proprietà finestra di dialogo dell'oggetto CNC. " }, 
{ "title" : "Componenti software SoftMotion dell'editor CNC ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_92f7df24e9a24fa0c0a864630c4c4560", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Fondamenti dell'editor CNC \/ Componenti software SoftMotion dell'editor CNC ", 
"snippet" : "(1) Editor CNC (2) Programma IEC (3) Parametro (4) Interprete (5) Informazioni geografiche (6) Pre-elaborazione del percorso (7) Interpolatore (8) Punti del percorso (9) Coordinate cartesiane (10) Cinematica diretta (11) Trasformazione specifica per la macchina (12) Cinematica inversa (13) Posizione...", 
"body" : "(1) Editor CNC (2) Programma IEC (3) Parametro (4) Interprete (5) Informazioni geografiche (6) Pre-elaborazione del percorso (7) Interpolatore (8) Punti del percorso (9) Coordinate cartesiane (10) Cinematica diretta (11) Trasformazione specifica per la macchina (12) Cinematica inversa (13) Posizione dell'asse (14) Interfaccia dell'unità " }, 
{ "title" : "Compilazione di oggetti CNC ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_c0635f14eddc9007c0a8646316c80481", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Fondamenti dell'editor CNC \/ Compilazione di oggetti CNC ", 
"snippet" : "Il Modalità di compilazione viene selezionato quando si aggiunge un nuovo oggetto CNC e, se necessario, può essere modificato nel file Proprietà dialogo ( CNC scheda dell'oggetto CNC). Dipende da Modalità di compilazione , un SMC_OutQueue blocco funzione, SMC_CNC_REF blocco funzione o un file ASCII ...", 
"body" : "Il Modalità di compilazione viene selezionato quando si aggiunge un nuovo oggetto CNC e, se necessario, può essere modificato nel file Proprietà dialogo ( CNC scheda dell'oggetto CNC). Dipende da Modalità di compilazione , un SMC_OutQueue blocco funzione, SMC_CNC_REF blocco funzione o un file ASCII con il percorso CNC programmato viene creato in fase di compilazione. Se la Escludi dalla build l'opzione è selezionata in Proprietà dialogo sul Costruire scheda dell'oggetto CNC, non vengono generati dati IEC. In modalità compilazione File , nessun dato viene scaricato nel controllore. " }, 
{ "title" : "Apertura a CoDeSys V2.3 Progetti ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_88cb0aeee9a24fa0c0a864634f00b359", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Fondamenti dell'editor CNC \/ Apertura a CoDeSys V2.3 Progetti ", 
"snippet" : "Quando apri un CoDeSys V2.3 progetto dentro CODESYS , viene fornito un convertitore per eseguire le seguenti funzioni purché venga utilizzato un controller SoftMotion: Ogni programma CNC viene convertito in un oggetto CNC con lo stesso nome e tipo di implementazione DIN 66025. La modalità di compila...", 
"body" : "Quando apri un CoDeSys V2.3 progetto dentro CODESYS , viene fornito un convertitore per eseguire le seguenti funzioni purché venga utilizzato un controller SoftMotion: Ogni programma CNC viene convertito in un oggetto CNC con lo stesso nome e tipo di implementazione DIN 66025. La modalità di compilazione, la dimensione della coda e la posizione iniziale del programma convertito vengono applicati anche come stato della soppressione del passo. Se la Escludi dalla build l'opzione è selezionata nel programma CNC del CoDeSys V2.3 progetto, allora questa opzione è accettata. Il Impostazioni CNC l'oggetto viene generato automaticamente. Tutti gli oggetti CNC sono elencati sotto un'applicazione compatibile con SoftMotion. " }, 
{ "title" : "Creazione di un programma CNC ", 
"url" : "_sm_cnc_creating_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Creazione di un programma CNC ", 
"snippet" : "Selezionare un'applicazione nella struttura dei dispositivi. Clic Progetto → Aggiungi oggetto → Programma CNC . Specificare un nome in Aggiungi programma CNC finestra di dialogo e selezionare un Implementazione dalla casella di riepilogo: DIN 66025 : Per creare il tuo programma nell'editor di testo ...", 
"body" : "Selezionare un'applicazione nella struttura dei dispositivi. Clic Progetto → Aggiungi oggetto → Programma CNC . Specificare un nome in Aggiungi programma CNC finestra di dialogo e selezionare un Implementazione dalla casella di riepilogo: DIN 66025 : Per creare il tuo programma nell'editor di testo Tavolo : Per creare il tuo programma nell'editor tabulare Seleziona un Modalità di compilazione per determinare il comportamento durante la compilazione: SMC_OutQueue : Durante la compilazione viene generata una struttura dati SMC_OutQueue. Ti viene concesso l'accesso globale tramite g_CNCQueueManager (SMC_OutQueue). SMC_CNC_REF : le variabili di programma vengono generate durante la compilazione. Ti viene concesso l'accesso globale tramite g_CNCProgManager (SMC-CNC_REF) in un programma IEC. FILE : Un file generato dal codice G viene scaricato e aggiornato ad ogni accesso. Il PLC può scaricare questo file tramite blocchi funzione. Puoi cambiare il Implementazione e Modalità di compilazione più avanti nel Proprietà dialogo ( CNC scheda del programma CNC). Clic Aggiungere . L'oggetto CNC viene inserito nell'albero dei dispositivi e aperto nell'editor. " }, 
{ "title" : "Programmazione di un percorso secondo DIN 66025 ", 
"url" : "_sm_cnc_programming_din_66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Programmazione di un percorso secondo DIN 66025 ", 
"snippet" : "SoftMotion supporta parti del linguaggio CNC DIN 66025 che consente la programmazione di percorsi geometrici nell'editor di un oggetto CNC. Il Editore DIN 66025 dell'oggetto CNC (anche: editor di testo CNC) è previsto per la programmazione nel linguaggio CNC DIN 66025. Requisito: A Programma CNC l'o...", 
"body" : "SoftMotion supporta parti del linguaggio CNC DIN 66025 che consente la programmazione di percorsi geometrici nell'editor di un oggetto CNC. Il Editore DIN 66025 dell'oggetto CNC (anche: editor di testo CNC) è previsto per la programmazione nel linguaggio CNC DIN 66025. Requisito: A Programma CNC l'oggetto è aperto con DIN 66025 implementazione. Posiziona il cursore nella riga vuota. Immettere i blocchi di codice G riga per riga nell'editor. Dopo aver inserito un blocco (esempio: N10 G01 X100 Y100 E100 F100 E-200 ), l'elemento del percorso viene visualizzato immediatamente nell'editor grafico. Qui è possibile utilizzare il campo operativo per modificare la vista e la direzione della vista sui diversi assi. Se si seleziona l'elemento del percorso nell'editor grafico, le sue proprietà vengono visualizzate nel file Proprietà Visualizza. Per ulteriori informazioni, vedere: Fondamenti DIN 66025" }, 
{ "title" : "Programmazione di un percorso nell'editor tabulare ", 
"url" : "_sm_cnc_programming_table_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Programmazione di un percorso nell'editor tabulare ", 
"snippet" : "Requisito: A Programma CNC l'oggetto viene creato con il Tavolo implementazione e l'oggetto è aperto nel file editore di tabelle ....", 
"body" : "Requisito: A Programma CNC l'oggetto viene creato con il Tavolo implementazione e l'oggetto è aperto nel file editore di tabelle . " }, 
{ "title" : "Inserimento di elementi ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f56fa52f4ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Programmazione di un percorso nell'editor tabulare \/ Inserimento di elementi ", 
"snippet" : "Fare doppio clic su Vuoto cella nel Tipo colonna. Selezionare un elemento dalla casella di riepilogo e premere il accedere chiave. Se è il primo elemento nella tabella, i campi vengono popolati con i valori iniziali dell'elemento. In caso contrario, l'elemento riceve i valori dall'elemento della rig...", 
"body" : "Fare doppio clic su Vuoto cella nel Tipo colonna. Selezionare un elemento dalla casella di riepilogo e premere il accedere chiave. Se è il primo elemento nella tabella, i campi vengono popolati con i valori iniziali dell'elemento. In caso contrario, l'elemento riceve i valori dall'elemento della riga precedente. Tutti gli altri campi rimangono ombreggiati in grigio e l'elemento viene visualizzato nell'editor grafico. L'ultima riga della tabella è una riga vuota con il tipo Vuoto . Per aggiungere un altro elemento, puoi anche fare clic su Inserisci elemento comando nel menu contestuale di una voce di tabella. " }, 
{ "title" : "Modifica di una voce della tabella ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f568c7504ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Programmazione di un percorso nell'editor tabulare \/ Modifica di una voce della tabella ", 
"snippet" : "Fare doppio clic su una voce di tabella di un elemento. Il campo è modificabile o è presente un simbolo per una casella di riepilogo. L'elemento è contrassegnato in rosso nell'editor grafico. Modificare il valore della voce della tabella. La modifica viene visualizzata nell'editor grafico. Se fai cl...", 
"body" : "Fare doppio clic su una voce di tabella di un elemento. Il campo è modificabile o è presente un simbolo per una casella di riepilogo. L'elemento è contrassegnato in rosso nell'editor grafico. Modificare il valore della voce della tabella. La modifica viene visualizzata nell'editor grafico. Se fai clic sul comando Applica valore a tutti gli elementi nel menu contestuale della voce della tabella, il valore corrente viene applicato a tutte le altre voci della stessa colonna. Requisito: il valore può essere utilizzato per il rispettivo tipo di elemento. Il numero di riga non può essere modificato. " }, 
{ "title" : "Eliminazione di un elemento ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f0684d0502561eafc0a864633d0e8542", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Programmazione di un percorso nell'editor tabulare \/ Eliminazione di un elemento ", 
"snippet" : "Selezionare una riga della tabella e fare clic sul comando Rimuovi elemento nel menu contestuale. L'ultima riga della tabella con il tipo Vuoto non può essere cancellato....", 
"body" : "Selezionare una riga della tabella e fare clic sul comando Rimuovi elemento nel menu contestuale. L'ultima riga della tabella con il tipo Vuoto non può essere cancellato. " }, 
{ "title" : "Strutture dati CNC e accesso globale ", 
"url" : "_sm_cnc_data_structure_global_access.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Strutture dati CNC e accesso globale ", 
"snippet" : "Gli oggetti CNC disponibili nel progetto sono compilati in blocchi funzione di tipo SMC_OUTQUEUE o SMC_CNC_REF . (Ciò non accade quando il metodo compile FILE si usa.) Quando il progetto viene compilato, i dati del CNC creati vengono gestiti internamente nel file SMC_CNC_Data blocchi funzione. Per l...", 
"body" : "Gli oggetti CNC disponibili nel progetto sono compilati in blocchi funzione di tipo SMC_OUTQUEUE o SMC_CNC_REF . (Ciò non accade quando il metodo compile FILE si usa.) Quando il progetto viene compilato, i dati del CNC creati vengono gestiti internamente nel file SMC_CNC_Data blocchi funzione. Per la modalità di compilazione SMC_OutQueue , ogni elemento del CNC è rappresentato da a SMC_OUTQUEUE blocco funzione. Per la modalità di compilazione SMC_CNC_REF , un elemento CNC è rappresentato da SMC_CNC_REF . Durante l'elaborazione del programma IEC, i blocchi funzione vengono istanziati e popolati con valori che possono essere elaborati nei programmi IEC. Tutte queste POU sono contenute in SM3_CNC . " }, 
{ "title" : "Accesso globale ai dati CNC ", 
"url" : "_sm_cnc_data_structure_global_access.html#UUID-aaee586d-72f4-405c-8bb5-b4b2cb32f52d_id_cb8536efda52bb5c0a8646375871841_id_4fd460ed02599820c0a864633ab223de", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editore \/ Strutture dati CNC e accesso globale \/ Accesso globale ai dati CNC ", 
"snippet" : "Durante l'inizializzazione, dal programma del CNC vengono rilevati il tipo e il numero degli oggetti generati. Tutti questi oggetti sono elencati insieme in una struttura dati globale dichiarata in modo implicito. Oggetti di tipo SMC_OUTQUEUE sono elencati nell'oggetto dati globale g_CNCQueueManager...", 
"body" : "Durante l'inizializzazione, dal programma del CNC vengono rilevati il tipo e il numero degli oggetti generati. Tutti questi oggetti sono elencati insieme in una struttura dati globale dichiarata in modo implicito. Oggetti di tipo SMC_OUTQUEUE sono elencati nell'oggetto dati globale g_CNCQueueManager con la proprietà Count e il metodo GetOutQueue(int n) . Oggetti di tipo SMC_CNC_REF sono elencati nell'oggetto dati globale g_CNCProgManager con la proprietà Count e il metodo GetProgram(int n) . L'utente può ora accedervi in un programma IEC. Esempio Accesso agli oggetti dati della struttura SMC_OUTQUEUE PROGRAM CNCManageQueue\nVAR\n pCNC_OutQueue : POINTER TO SMC_OUTQUEUE;\n n: INT;\n i: INT;\nEND_VAR\n\nn := g_CNCQueueManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_OutQueue := g_CNCQueueManager.GetOutQueue(I);\n (* calculate pCNC_OutQueue *)\nEND_FOR Accesso agli oggetti dati della struttura SMC_CNC_REF PROGRAM CNCManageRef\nVAR\n pCNC_Ref: POINTER TO SMC_CNC_REF;\n n: INT;\nEND_VAR\n\nn := g_CNCProgManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_Ref := g_CNCProgManager.GetProgram(I);\n (* calculate pCNC_Ref *)\nEND_FOR " }, 
{ "title" : "Trasformazioni cinematiche ", 
"url" : "_sm_f_cnc_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Trasformazione in avanti e inversa ", 
"url" : "_sm_cnc_forward_backward_transformation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Trasformazione in avanti e inversa ", 
"snippet" : "CODESYS SoftMotion fornisce blocchi funzione per la trasformazione matematica in avanti e inversa per molte cinematiche popolari. Per ogni progetto cinematico sono disponibili due blocchi funzione per la trasformazione. Il POU nominato SMC_TRAFO_<kinematics> calcola la posizione dell'asse dalla posi...", 
"body" : "CODESYS SoftMotion fornisce blocchi funzione per la trasformazione matematica in avanti e inversa per molte cinematiche popolari. Per ogni progetto cinematico sono disponibili due blocchi funzione per la trasformazione. Il POU nominato SMC_TRAFO_<kinematics> calcola la posizione dell'asse dalla posizione nello spazio (trasformazione inversa). Il POU nominato SMC_TRAFOF_<kinematics> calcola la posizione nello spazio dalla posizione dell'asse (trasformazione in avanti). È possibile collegare in modo rapido e semplice le istanze delle POU di trasformazione in avanti ai modelli di visualizzazione per visualizzare la cinematica. SMC_TRAFOV_ Alcune delle trasformazioni inverse utilizzano anche la velocità del percorso e la direzione del percorso per calcolare le velocità degli assi. I nomi di queste POU di trasformazione iniziano con SMC_TRAFOV_ invece di SMC_TRAFO_ . Questi POU ottengono il percorso tangente ( v ) e velocità del percorso ( dVel ) come ingressi aggiuntivi dall'interpolatore. Restituiscono anche le velocità impostate ( dvx\/dvy\/dvz ) oltre alle posizioni impostate. Il vantaggio è che il ritardo nell'azionamento può essere ridotto al minimo mediante il controllo in ingresso della velocità, a condizione che l'azionamento supporti questo metodo. Per trasferire le velocità impostate all'azionamento, è necessario utilizzare SMC_ControlAxisByPosVel invece di SMC_ControlAxisByPos in questo caso. Per ulteriori informazioni, vedere: SMC_ControlAxisByPos (FB) , SMC_ControlAxisByVel (FB) e SMC_ControlAxisByPosVel (FB) " }, 
{ "title" : "Trasformazione a 5 assi ", 
"url" : "_sm_trafo_pou_five_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Trasformazione a 5 assi ", 
"snippet" : "Con la trasformazione a 5 assi è possibile controllare una cinematica composta da tre assi spaziali lineari (X, Y, Z) e una testa utensile. La testa dell'utensile è composta da due assi che sostengono l'utensile. Un asse utensile ruota attorno all'asse Z e lo strumento inclina gli altri secondo lo s...", 
"body" : "Con la trasformazione a 5 assi è possibile controllare una cinematica composta da tre assi spaziali lineari (X, Y, Z) e una testa utensile. La testa dell'utensile è composta da due assi che sostengono l'utensile. Un asse utensile ruota attorno all'asse Z e lo strumento inclina gli altri secondo lo schema seguente. Parametro: Lunghezza di dTool = Distanza dal punto di lavorazione (punta utensile = TCP) all'inclinazione dell'asse rotante. Controllo della trasformazione a 5 assi tramite cinque valori posizionali: Posizione X\/Y\/Z del punto di elaborazione (TCP) incluso in pi.dX, pi.dY, pi.dZ . Unità: unità di posizione degli assi. Orientamento dell'utensile in base alle coordinate sferiche (inclinazione e azimut) che sono incluse in pi.dB e pi.dC . Unità: gradi angolari. Posizione zero Il punto di elaborazione (TCP) si trova nella posizione ( 0\/0\/-dTool ). L'utensile si estende nella direzione dell'asse Z negativo. L'inclinazione dell'asse rotante è posizionata in modo tale che la rotazione in direzione positiva sposti l'utensile nella direzione dell'asse X positivo. Esempio Per il movimento N30, l'asse di inclinazione che per primo punta in direzione X viene ruotato e al termine del movimento rimane inclinato in direzione X negativa. N0 PB360 PC360 (set axis B and C in modulo mode 360)\nN10 F10 FB100 FC100 (velocity in X\/Y\/Z: 10, in B and C 100)\nN20 G0 X0 Y0 Z0 C0 B30 (start position)\nN30 G1 X20 B-30 (target position) Per ulteriori informazioni, vedere: SMC_TRAFO_5Assi (FB) e SMC_TRAFOF_5Assi (FB) " }, 
{ "title" : "Sistema a portale ", 
"url" : "_sm_trafo_pou_gantry_system.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Sistema a portale ", 
"snippet" : "I sistemi a portale sono costituiti da due o tre assi lineari disposti ad angolo retto. Poiché le trasformazioni non devono essere eseguite nei sistemi gantry, i rispettivi moduli per le trasformazioni inverse e avanti aggiungono solo un offset agli assi X, Y e Z in due o tre dimensioni. Per ulterio...", 
"body" : "I sistemi a portale sono costituiti da due o tre assi lineari disposti ad angolo retto. Poiché le trasformazioni non devono essere eseguite nei sistemi gantry, i rispettivi moduli per le trasformazioni inverse e avanti aggiungono solo un offset agli assi X, Y e Z in due o tre dimensioni. Per ulteriori informazioni, vedere: MC_TRAFO_Gantry2 (FB) SMC_TRAFOF_Gantry2 (FB) SMC_TRAFO_Gantry3 (FB) SMC_TRAFOF_Gantry3 (FB) " }, 
{ "title" : "Sistema Gantry con Assi di Orientamento ", 
"url" : "_sm_trafo_pou_gantry_cutter.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Sistema Gantry con Assi di Orientamento ", 
"snippet" : "Una \"fresa a portale\" è un sistema a portale con un asse rotante dotato di un utensile da taglio. La configurazione di un sistema a portale con asse rotante è simile a quella di un semplice sistema a portale. Tuttavia, questi sistemi hanno anche un asse rotante su cui è fissato l'unità di taglio ver...", 
"body" : "Una \"fresa a portale\" è un sistema a portale con un asse rotante dotato di un utensile da taglio. La configurazione di un sistema a portale con asse rotante è simile a quella di un semplice sistema a portale. Tuttavia, questi sistemi hanno anche un asse rotante su cui è fissato l'unità di taglio verticale. Quando si utilizza un sistema a portale con un asse rotante, è necessario utilizzare il SMC_TRAFO<n>_GantryCutter<n> POU invece di SMC_TRAFO<n>_Gantry<n> . Quindi l'asse rotante viene comandato in modo tale da essere orientato lungo la tangente alla traiettoria attuale. Le POU della taglierina a portale hanno i seguenti ingressi aggiuntivi: DriveR : Asse rotante da utilizzare con un periodo di 360° dOffsetR : Offset dell'asse rotante iDirectionR : Direzione di rotazione Per ulteriori informazioni, vedere: SMC_TRAFO_GantryCutter2 (FB) SMC_TRAFOF_GantryCutter2 (FB) SMC_TRAFO_GantryCutter3 (FB) SMC_TRAFOF_GantryCutter3 (FB) Le POU per la trasformazione inversa devono includere anche il vettore della tangente al percorso corrente (v) che è un'uscita dell'interpolatore. Per ulteriori informazioni, vedere: SMC_TRAFOV_GantryCutter2 (FB) e SMC_TRAFOV_GantryCutter3 (FB) " }, 
{ "title" : "Sistema a portale con offset utensile ", 
"url" : "_sm_trafo_pou_gantry_system_tool.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Sistema a portale con offset utensile ", 
"snippet" : "Se l'asse dell'utensile ha un offset e non coincide con l'asse Z del sistema a portale, il punto di contatto dell'utensile non coincide con la posizione X\/Y\/Z del sistema a portale. Se l'asse Z non può essere ruotato, l'offset risultante delle coordinate X e Y è costante e può essere utilizzato dire...", 
"body" : "Se l'asse dell'utensile ha un offset e non coincide con l'asse Z del sistema a portale, il punto di contatto dell'utensile non coincide con la posizione X\/Y\/Z del sistema a portale. Se l'asse Z non può essere ruotato, l'offset risultante delle coordinate X e Y è costante e può essere utilizzato direttamente per la trasformazione gantry standard. Se l'utensile viene ruotato dell'asse C (circa Z), l'offset non è costante, ma dipende dalla posizione dell'asse C. In questo caso è possibile selezionare una delle due POU, a seconda della forma dello strumento: SMC_TRAFO_Gantry2Tool1 e SMC_TRAFOF_Gantry2Tool1 L'utensile punta lungo l'asse X ruotato di dAlpha ed ha una lunghezza di dToolA . SMC_TRAFO_Gantry2Tool2 e SMC_TRAFOF_Gantry2Tool2 L'utensile è parzialmente nella direzione dell'asse X di cui è ruotato dAlpha (lunghezza: dToolA ) e parzialmente nella direzione dell'asse Y ruotato (lunghezza: dToolB ). Nella figura dell'esempio seguente, il laser è fissato con un offset sia in direzione X che in direzione Y. Invece di eseguire questa trasformazione unidimensionale, il percorso può essere modulato anche con una correzione utensile. In questo momento, lo strumento si avvicina a una linea retta. Il SMC_ToolCorr o SMC_ToolRadiusCorr i blocchi funzione vengono utilizzati per questo. La differenza tra questi due metodi è la velocità del punto utensile. Se la modulazione viene utilizzata da SMC_ToolCorr , quindi la velocità del punto di rotazione viene controllata in base alle preimpostazioni nel programma CNC (F, E). La velocità della punta dell'utensile può variare. Se viene utilizzata la trasformazione unidimensionale, la velocità del punto utensile viene determinata dal programma CNC. Per calcolare l'orientamento dell'utensile, il SMC_CalcDirectionFromVector Viene utilizzato POU. " }, 
{ "title" : "H-Gantry con assi stazionari ", 
"url" : "_sm_trafo_pou_h_gantry_stationary_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ H-Gantry con assi stazionari ", 
"snippet" : "La configurazione cinematica è simile al sistema a portale, ma gli assi (azionamenti) sono montati saldamente. Spostano il portautensili per mezzo di una cinghia. Trasformazione mediante il SMC_TRAFO_GantryH2 e SMC_TRAFOF_GantryH2 Le POU richiedono le seguenti configurazioni degli assi. Altre config...", 
"body" : "La configurazione cinematica è simile al sistema a portale, ma gli assi (azionamenti) sono montati saldamente. Spostano il portautensili per mezzo di una cinghia. Trasformazione mediante il SMC_TRAFO_GantryH2 e SMC_TRAFOF_GantryH2 Le POU richiedono le seguenti configurazioni degli assi. Altre configurazioni possono essere eseguite scambiando x e y: Questa trasformazione richiede una speciale ricerca del punto di riferimento: entrambi gli assi devono essere spostati alla stessa velocità. Se il movimento deve essere nella direzione X, allora gli azionamenti A e B devono essere spostati, mentre devono muoversi con velocità inversa per un movimento rigorosamente X. Solo per un movimento X, devono essere spostati con una velocità opposta. Se viene trovato il punto di riferimento, i valori X e Y calcolati dalla trasformazione in avanti POU vengono utilizzati come offset ( dOffsetX e dOffsetY ). " }, 
{ "title" : "T-Gantry con assi stazionari ", 
"url" : "_sm_trafo_pou_t_gantry_statinary_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ T-Gantry con assi stazionari ", 
"snippet" : "Questo sistema cinematico è simile ai sistemi H-gantry. Anche qui gli azionamenti sono fissi e il portautensili viene spostato per mezzo di una cinghia. La trasformazione operata dai moduli SMC_TRAFO_GantryT2 e SMC_TRAFOF_GantryT2 sono progettati per le seguenti configurazioni di azionamento: Si not...", 
"body" : "Questo sistema cinematico è simile ai sistemi H-gantry. Anche qui gli azionamenti sono fissi e il portautensili viene spostato per mezzo di una cinghia. La trasformazione operata dai moduli SMC_TRAFO_GantryT2 e SMC_TRAFOF_GantryT2 sono progettati per le seguenti configurazioni di azionamento: Si noti che per questa trasformazione è necessario un homing speciale. Se si esegue un movimento nella direzione X, è necessario muovere gli azionamenti A e B alla stessa velocità. Se si esegue rigorosamente un movimento Y, gli azionamenti devono ruotare in direzioni opposte. Se l'azionamento trova la posizione di riferimento, i valori X e Y calcolati dalla trasformazione in avanti POU vengono utilizzati come offset ( dOffsetX e dOffsetY ). Il SMC_TRAFO_GantryT2_O e SMC_TRAFOF_GantryT2_O i blocchi funzione eseguono lo stesso calcolo con la seguente costellazione: " }, 
{ "title" : "Sistema Polare ", 
"url" : "_sm_trafo_pou_polar_system.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Sistema Polare ", 
"snippet" : "I sistemi polari sono costituiti da un asse di rotazione (direzione) e un asse lineare (distanza). L'origine e la direzione dell'asse lineare possono essere modificate tramite gli offset dPhi e dR . Per ulteriori informazioni, vedere: SMC_TRAFO_Polar (FB) e SMC_TRAFOF_Polare (FB)...", 
"body" : "I sistemi polari sono costituiti da un asse di rotazione (direzione) e un asse lineare (distanza). L'origine e la direzione dell'asse lineare possono essere modificate tramite gli offset dPhi e dR . Per ulteriori informazioni, vedere: SMC_TRAFO_Polar (FB) e SMC_TRAFOF_Polare (FB) " }, 
{ "title" : "Sistema SCARA a 2 giunti ", 
"url" : "_sm_trafo_pou_two_jointed_scara.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Sistema SCARA a 2 giunti ", 
"snippet" : "Il Braccio robotico per assemblaggio di conformità selettiva (SCARA) è un tipo speciale di robot industriale simile a un braccio umano. Un sistema SCARA ha due assi e due gradi di libertà. Il movimento è limitato al piano X\/Y. Per ulteriori informazioni, vedere: SMC_TRAFO_Scara2 (FB) e SMC_TRAFOF_Sc...", 
"body" : "Il Braccio robotico per assemblaggio di conformità selettiva (SCARA) è un tipo speciale di robot industriale simile a un braccio umano. Un sistema SCARA ha due assi e due gradi di libertà. Il movimento è limitato al piano X\/Y. Per ulteriori informazioni, vedere: SMC_TRAFO_Scara2 (FB) e SMC_TRAFOF_Scara2 (FB) " }, 
{ "title" : "Sistema SCARA a 3 snodi ", 
"url" : "_sm_trafo_pou_three_jointed_scara.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Sistema SCARA a 3 snodi ", 
"snippet" : "Il sistema SCARA a 3 snodi ha un terzo asse che consente il movimento in direzione costante. Come nei sistemi a 2 giunti, il movimento è limitato al piano X\/Y. Per ulteriori informazioni, vedere: SMC_TRAFO_Scara3 (FB) e SMC_TRAFOF_Scara3 (FB)...", 
"body" : "Il sistema SCARA a 3 snodi ha un terzo asse che consente il movimento in direzione costante. Come nei sistemi a 2 giunti, il movimento è limitato al piano X\/Y. Per ulteriori informazioni, vedere: SMC_TRAFO_Scara3 (FB) e SMC_TRAFOF_Scara3 (FB) " }, 
{ "title" : "Cinematica parallela ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Cinematica parallela ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Treppiede ad assi lineari ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_b6b32d1fbe665307c0a8640e00033022", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Cinematica parallela \/ Treppiede ad assi lineari ", 
"snippet" : "Questo sistema ha tre azionamenti lineari che si trovano ad un angolo definito l'uno rispetto all'altro. Gli azionamenti sono costituiti da 3 binari con slitte traslanti. La piastra portautensili è collegata alle slitte di traslazione mediante bielle della stessa lunghezza. Un set accoppiato di biel...", 
"body" : "Questo sistema ha tre azionamenti lineari che si trovano ad un angolo definito l'uno rispetto all'altro. Gli azionamenti sono costituiti da 3 binari con slitte traslanti. La piastra portautensili è collegata alle slitte di traslazione mediante bielle della stessa lunghezza. Un set accoppiato di bielle tiene la piastra portautensili parallela al pavimento con lo stesso orientamento. La cinematica può spostare la piastra portautensili in tre dimensioni. La trasformazione in avanti e inversa di queste cinematiche è calcolata in SMC_Trafo_Tripod_Lin e SMC_TrafoF_Tripod_Lin POU. L'angolo dell'asse del treppiede è definito dall'angolo tra la guida e l'asse verticale ( dAxisAngle ). Requisiti meccanici e sistema di coordinate Le lunghezze dei 3 assi sono identiche. Le lunghezze delle bielle sono identiche. La distanza tra le coppie di bielle è identica per tutte le coppie. L'angolo dell'asse tra le rotaie di trasmissione e l'asse verticale è identico per tutti e tre gli azionamenti. L'angolo di tolleranza è compreso tra 0° e 90°. L'asse definisce il movimento del punto tra i giunti di biella sui cursori. Il sistema di coordinate XYZ è destrorso. I vettori X e Y sono orizzontali e Z punta verso l'alto. L'origine è definita in modo che l'intersezione dei tre assi di movimento con il piano XY (grafico sotto: punti A) sia su un cerchio nella posizione [0,0,0]. Parametrizzazione del blocco funzione SMC_TrafoF_Tripod_Lin Nome Descrizione dInnerRadius Distanza dal centro della piastra portautensili ai punti di presa delle bielle dOuterRadius Il punto A è l'intersezione dell'asse con il piano XY. dLength Lunghezza delle bielle dDistance Distanza tra le due bielle in una coppia dRotationOffset Il punto A del primo asse definisce l'asse X per impostazione predefinita. L'offset viene utilizzato per ruotare l'intera struttura attorno all'asse Z. In questo caso, il punto A non è più sull'asse X. dOffsetA L'offset viene utilizzato per impostare il valore di posizione dell'asse sull'impostazione predefinita di zero. dOffsetB dOffsetC Troverai informazioni su altri parametri nella descrizione della libreria. " }, 
{ "title" : "Treppiede ad assi verticali ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_74ba1833be665308c0a8640e019694c6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Cinematica parallela \/ Treppiede ad assi verticali ", 
"snippet" : "Questo sistema è una variante speciale del progetto cinematico sopra descritto e presenta gli stessi requisiti meccanici. L'angolo dAxisAngle tra le rotaie di guida e l'asse verticale è 0° e le rotaie di guida sono parallele all'asse verticale. La trasformazione in avanti e inversa di queste cinemat...", 
"body" : "Questo sistema è una variante speciale del progetto cinematico sopra descritto e presenta gli stessi requisiti meccanici. L'angolo dAxisAngle tra le rotaie di guida e l'asse verticale è 0° e le rotaie di guida sono parallele all'asse verticale. La trasformazione in avanti e inversa di queste cinematiche è calcolata in SMC_Trafo_Tripod_Lin e SMC_TrafoF_Tripod_Lin blocchi funzione. L'angolo dell'asse del treppiede è definito dall'angolo tra la guida e l'asse verticale ( dAxisAngle ). Parametrizzazione del blocco funzione SMC_TrafoF_Tripod_Lin Nome Descrizione dInnerRadius Il parametro definisce il raggio del cerchio che è descritto dai sei punti di presa delle bielle alla piastra portautensile. dOuterRadius dLength Lunghezza delle bielle dDistance Distanza delle coppie di bielle tra loro dRotationOffset Il punto A del primo asse definisce di default l'asse X. L'offset viene utilizzato per ruotare l'intera struttura attorno all'asse Z. In questo caso, il punto A non è più sull'asse X. dOffsetA L'offset viene utilizzato per impostare il valore di posizione dell'asse sull'impostazione predefinita di zero. dOffsetB dOffsetC Troverai informazioni su altri parametri nella descrizione della libreria. " }, 
{ "title" : "Treppiede con assi rotanti ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_30491f2ca003ef70c0a864631e92f50c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Cinematica parallela \/ Treppiede con assi rotanti ", 
"snippet" : "Per i treppiedi, la cinematica è implementata da 3 azionamenti rotanti collegati alla piastra portautensili tramite bracci e bielle. L'origine del sistema di coordinate è la posizione del centro della piastra portautensili quando tutti e 3 i bracci sono in posizione orizzontale. La trasformazione in...", 
"body" : "Per i treppiedi, la cinematica è implementata da 3 azionamenti rotanti collegati alla piastra portautensili tramite bracci e bielle. L'origine del sistema di coordinate è la posizione del centro della piastra portautensili quando tutti e 3 i bracci sono in posizione orizzontale. La trasformazione in avanti e inversa di queste cinematiche è calcolata in SMC_TRAFO_Tripod_Arm e SMC_TRAFOF_Tripod_Arm blocchi funzione. Requisiti meccanici e sistema di coordinate Le lunghezze dei tre assi sono identiche. Le lunghezze delle bielle sono identiche. La distanza tra le coppie di bielle è identica per tutte le coppie. Parametrizzazione del blocco funzione SMC_TrafoF_Tripod_Arm Nome Descrizione dArmLength1 dArmLength2 dArm1Radius Il parametro definisce il raggio del cerchio che viene stabilito dai 3 punti P degli azionamenti. dStewartRadius Il parametro definisce il raggio del cerchio che è descritto dai 6 punti di presa delle bielle alla piastra portautensile. dDistance Distanza tra le due bielle in una coppia dOffsetA dOffsetB dOffsetC Troverai informazioni su altri parametri nella descrizione della libreria. L'immagine mostra la posizione zero di tutti gli assi. (I tre bracci superiori sono orizzontali.) L'MCS è mostrato sulla piastra dell'utensile. Le frecce sugli assi A0, A1 e A2 indicano il senso di rotazione degli azionamenti secondo la regola della mano destra. Sistema di coordinate macchina (MCS) Origine Definito nel punto medio della piastra portautensili quando tutti e 3 i bracci superiori (quelli collegati direttamente con A0, A1 o A2) sono in posizione orizzontale X Dall'origine, punta lontano dal primo motore (A0), parallelo al segmento del braccio superiore del primo braccio Y Determinato da X e Z in modo che l'MCS sia destrorso Z Ortogonale alla piastra portautensili Punti dalla piastra dell'utensile in direzione dei motori Le rispettive trasformazioni vengono eseguite dalle seguenti POU SMC_TRAFO_Tripod_Arm e SMC_TRAFOF_Tripod_Arm : Esempio: treppiede 3S Impostazioni di trasformazione tta:\nSMC_TRAFO_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41,dMaxAngleBallJoint:=60);\nttaf:\nSMC_TRAFOF_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41); " }, 
{ "title" : "Cinematica del pallettizzatore a 4 assi ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Cinematica del pallettizzatore a 4 assi ", 
"snippet" : "La cinematica del pallettizzatore a 4 assi è un tipo di robot generico che viene utilizzato frequentemente per attività di pallettizzazione. La cinematica è dotata di quattro assi rotativi controllati (contrassegnati in rosso) e di un quinto asse rotativo meccanico (contrassegnato in grigio). Il Pal...", 
"body" : "La cinematica del pallettizzatore a 4 assi è un tipo di robot generico che viene utilizzato frequentemente per attività di pallettizzazione. La cinematica è dotata di quattro assi rotativi controllati (contrassegnati in rosso) e di un quinto asse rotativo meccanico (contrassegnato in grigio). Il Pallettizzatore SMC_Trafo_4Axis e SMC_TrafoF_4AxisPallettizzatore Le POU implementano la sua trasformazione in avanti e inversa. Il sistema di coordinate cartesiane è la base per il pallettizzatore. L'asse Z punta in basso perpendicolarmente e l'asse X \"in avanti\", il che significa nella direzione in cui punta il braccio nella direzione zero degli assi. L'origine del sistema di coordinate cartesiane è l'intersezione dell'asse 1 del giunto e la parte inferiore del robot. Oggetti La struttura dei dati SMC_TrafoConfig_4AxisPalletizer e il SMC_Trafo_4AxisPalletizer e SMC_TrafoF_4AxisPalletizer i blocchi funzione sono collegati alla libreria SM3_Transformation . Per una descrizione dei parametri, cercare questi oggetti in Library Manager. " }, 
{ "title" : "Definizione di assi ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_945c0811df409256c0a8657d0066458b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Cinematica del pallettizzatore a 4 assi \/ Definizione di assi ", 
"snippet" : "L'immagine seguente mostra il senso di rotazione dei quattro assi. Le frecce nere corrono lungo l'asse del giunto. Il senso di rotazione è determinato secondo la regola della mano destra: se il pollice della mano destra punta verso il basso lungo la freccia, il senso di rotazione positivo è nella di...", 
"body" : "L'immagine seguente mostra il senso di rotazione dei quattro assi. Le frecce nere corrono lungo l'asse del giunto. Il senso di rotazione è determinato secondo la regola della mano destra: se il pollice della mano destra punta verso il basso lungo la freccia, il senso di rotazione positivo è nella direzione del dito leggermente curvo. Ad esempio, se visto dall'alto, la direzione di rotazione positiva dell'asse 0 è in senso orario, mentre gli assi 1 e 2 si inclinano \"in avanti\" per la rotazione positiva. La cinematica è dotata di quattro assi rotativi controllati (vedi assi rossi a0, a1, a2, a3) e un quinto asse rotativo meccanico (vedi asse M di colore grigio). Campi di valori degli assi: Asse 0: ]-180°, 180°[ Asse 1: [-90°, 90°] Asse 2: [-180°, 90[ Asse M: asse rotante meccanico. Nessuna restrizione Asse 3: illimitato; la portata può essere anche maggiore di 360° " }, 
{ "title" : "Posizione zero e dimensioni ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Cinematica del pallettizzatore a 4 assi \/ Posizione zero e dimensioni ", 
"snippet" : "L'immagine mostra la cinematica in posizione zero di tutti gli assi. Nella posizione zero, gli assi del sistema di coordinate utensile corrono paralleli a quelli del sistema di coordinate macchina. Specificare le dimensioni indicate nella struttura di configurazione SMC_TrafoConfig_4AxisPallettizzat...", 
"body" : "L'immagine mostra la cinematica in posizione zero di tutti gli assi. Nella posizione zero, gli assi del sistema di coordinate utensile corrono paralleli a quelli del sistema di coordinate macchina. Specificare le dimensioni indicate nella struttura di configurazione SMC_TrafoConfig_4AxisPallettizzatore Specificare anche tutto a_i con segni positivi e tutto d_i con segni negativi. I nomi dei parametri sono secondo la convenzione Denavit-Hartenberg. Denavit-Hartenberg trasformazione delle articolazioni Offset giunto (sigma_i) Distanza articolare (d_i) Lunghezza elemento braccio (a_i) Torsione (alfa_i) 1 0° d_1 a_1 90° 2 -90° 0 a_2 0° 3 90° 0 a_3 0° 4 0° 0 a_4 90° 5 0° d_5 0 180° " }, 
{ "title" : "Programmazione in codice G ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_67269b93df408f35c0a8657d0178e964", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Cinematica del pallettizzatore a 4 assi \/ Programmazione in codice G ", 
"snippet" : "La posizione della pinza è controllata con X, Y e Z. La rotazione della pinza sulla verticale è controllata dall'asse aggiuntivo C. Gli angoli sono specificati in gradi....", 
"body" : "La posizione della pinza è controllata con X, Y e Z. La rotazione della pinza sulla verticale è controllata dall'asse aggiuntivo C. Gli angoli sono specificati in gradi. " }, 
{ "title" : "Robot articolato a 6 assi ", 
"url" : "_sm_trafo_pou_six_dof_robot.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Robot articolato a 6 assi ", 
"snippet" : "Trasformazione di un robot a braccio articolato con sei assi rotanti e sei gradi di libertà (DoF). I tre assi di orientamento del braccio del robot si intersecano in un punto: il centro del giunto. Il SMC_Trafo_ArticulatedRobot_6DOF e SMC_TrafoF_ArticulatedRobot_6DOF i blocchi funzione implementano ...", 
"body" : "Trasformazione di un robot a braccio articolato con sei assi rotanti e sei gradi di libertà (DoF). I tre assi di orientamento del braccio del robot si intersecano in un punto: il centro del giunto. Il SMC_Trafo_ArticulatedRobot_6DOF e SMC_TrafoF_ArticulatedRobot_6DOF i blocchi funzione implementano le trasformazioni in avanti e inversa di un robot a braccio articolato con sei assi di rotazione. Nell'immagine, il sistema di coordinate cartesiane è contrassegnato in basso sull'asse 0. L'asse z punta verso il basso e l'asse x punta in avanti nella direzione del punto centrale dell'utensile (TCP). L'origine del sistema di coordinate cartesiane è l'asse di intersezione 0 e la parte inferiore del robot. Oggetti di trasformazione La struttura dei dati SMC_TrafoConfig_ArticulatedRobot_6DOF e i blocchi funzione SMC_Trafo_ArticulatedRobot_6DOF e SMC_TrafoF_ArticulatedRobot_6DOF essere con SM3_CNC integrato. " }, 
{ "title" : "Definizione di assi ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_7e060a95379b6b55c0a8640e01f01d63", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Robot articolato a 6 assi \/ Definizione di assi ", 
"snippet" : "Gli assi rotanti sono identificati da frecce nere. Il senso di rotazione positivo è dato dalla regola della mano destra. Ad esempio, quando l'asse 0 viene ruotato in direzione positiva, il robot ruota in senso orario se visto dall'alto. Gli assi sono limitati ai seguenti intervalli: Assi 0, 1, 3 e 4...", 
"body" : "Gli assi rotanti sono identificati da frecce nere. Il senso di rotazione positivo è dato dalla regola della mano destra. Ad esempio, quando l'asse 0 viene ruotato in direzione positiva, il robot ruota in senso orario se visto dall'alto. Gli assi sono limitati ai seguenti intervalli: Assi 0, 1, 3 e 4: ]-180°, 180°[ Asse 2: [-90°, 180°] Asse 5: Senza restrizioni; la portata può essere maggiore di 360°. " }, 
{ "title" : "Posizione di riferimento e dimensioni ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Robot articolato a 6 assi \/ Posizione di riferimento e dimensioni ", 
"snippet" : "La figura a sinistra mostra la posizione di riferimento della cinematica, ovvero la posizione in cui tutti gli assi si trovano nella posizione zero. Immettere le dimensioni mostrate qui nella struttura di configurazione SMC_TrafoConfig_ArticulatedRobot_6DOF uno. I nomi e i segni dei parametri sono c...", 
"body" : "La figura a sinistra mostra la posizione di riferimento della cinematica, ovvero la posizione in cui tutti gli assi si trovano nella posizione zero. Immettere le dimensioni mostrate qui nella struttura di configurazione SMC_TrafoConfig_ArticulatedRobot_6DOF uno. I nomi e i segni dei parametri sono conformi alla convenzione Denavit-Hartenberg. La figura a destra mostra il parametro aggiuntivo Denavit-Hartenberg d3 . Nota: a1, a3, d4 e d6 devono essere >= 0 a2 deve essere > 0 (> g_fSMC_CNC_EPS ) d1 deve essere <= 0 Trasformazione di Denavit-Hartenberg delle articolazioni Compensazione congiunta (sigma_i) Spostamento leva (d_i) Lunghezza leva (a_i) Rotazione della leva (alpha_i) 1 0° d1 a_1 -90° 2 90° 0 a_2 0° 3 0° d3 a_3 90° 4 0° d4 0 90° 5 0° 0 0 -90° 6 0° d6 0 0° " }, 
{ "title" : "Programmazione ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_9cf41a3c6a5fb376c0a8640e005461c1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Robot articolato a 6 assi \/ Programmazione ", 
"snippet" : "La posizione del centro dell'utensile è controllata con X, Y e Z. Le unità di X, Y e Z sono le stesse utilizzate per i parametri a_i e d_i (ad esempio: mm). L'orientamento è controllato in gradi con A (imbardata), B (inclinazione) e C (rotazione)....", 
"body" : "La posizione del centro dell'utensile è controllata con X, Y e Z. Le unità di X, Y e Z sono le stesse utilizzate per i parametri a_i e d_i (ad esempio: mm). L'orientamento è controllato in gradi con A (imbardata), B (inclinazione) e C (rotazione). " }, 
{ "title" : "Wrapper per blocchi funzionali di trasformazione cinematica di SM3_Transformation libreria ", 
"url" : "_sm_wrapper_kinematic_fbs.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Trasformazioni cinematiche \/ Wrapper per blocchi funzionali di trasformazione cinematica di SM3_Transformation libreria ", 
"snippet" : "Le SMC_Trafo_wrapper e SMC_Trafof_Wrapper i blocchi funzione consentono di utilizzare la cinematica in SM3_Transformation libreria per applicazioni CNC. Per ulteriori informazioni sulla cinematica del SM3_Transformation libreria, vedi quanto segue: CinematicaÈ possibile utilizzare qualsiasi trasform...", 
"body" : "Le SMC_Trafo_wrapper e SMC_Trafof_Wrapper i blocchi funzione consentono di utilizzare la cinematica in SM3_Transformation libreria per applicazioni CNC. Per ulteriori informazioni sulla cinematica del SM3_Transformation libreria, vedi quanto segue: CinematicaÈ possibile utilizzare qualsiasi trasformazione che implementa il MC_KIN_REF_SM3 interfaccia. Inoltre, sono possibili combinazioni di «cinematica di posizione» e «cinematica di orientamento Per ulteriori informazioni, vedere quanto segue: Combinazione di cinematica di posizione e orientamento" }, 
{ "title" : "Linguaggio CNC in DIN 66025 ", 
"url" : "_sm_struct_reference_programming_din66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Fondamenti DIN 66025 ", 
"url" : "_sm_cnc_din66025_basics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Fondamenti DIN 66025 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Struttura di un programma DIN 66025 ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_c348b29fedfe7b9ec0a86463427bc61d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Fondamenti DIN 66025 \/ Struttura di un programma DIN 66025 ", 
"snippet" : "Il programma DIN 66025 è costituito da singoli blocchi di movimento. Il numero del blocco si trova all'inizio di ogni blocco. ['%' <Programmname>] <Satz>{<Satz>} I blocchi possono essere così strutturati: N<block number> G<expression> <G code words> N<block number> <G code words> (il G<expression> d...", 
"body" : "Il programma DIN 66025 è costituito da singoli blocchi di movimento. Il numero del blocco si trova all'inizio di ogni blocco. ['%' <Programmname>]\n<Satz>{<Satz>} I blocchi possono essere così strutturati: N<block number> G<expression> <G code words> N<block number> <G code words> (il G<expression> del blocco precedente si applicano) N<block number> M<expression> <G code words> N<block number> <subroutine name> ( <ActualParamList> ) Strutture di blocco aggiuntive per i sottoprogrammi: SUBPROGRAM <Name> {<FormalParamList>} <RESTORE_OPT> N<block number> RETURN END_SUBPROGRAM Esempio Percorso da due linee e un arco, seguito da una chiamata di subroutine % MyProgram\nN10 G01 X100 Y100 E100 F100 E-200\nN20 G01 Z40 F20\nN30 G03 X-100 R200 F100\nN40 SubPrg{5} " }, 
{ "title" : "Sintassi ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_section-idm4580346248046432600861986014", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Fondamenti DIN 66025 \/ Sintassi ", 
"snippet" : "['%' <nome programma>] Intestazione opzionale Inizia con %, seguito dal nome del programma separato da a Spazio o tab <blocco> Il blocco viene elaborato parola per parola da destra a sinistra. \/ Soppressione del passo Se un blocco inizia con \/ e CNC ➔ Soppressione del passo comando è selezionato, il...", 
"body" : "['%' <nome programma>] Intestazione opzionale Inizia con %, seguito dal nome del programma separato da a Spazio o tab <blocco> Il blocco viene elaborato parola per parola da destra a sinistra. \/ Soppressione del passo Se un blocco inizia con \/ e CNC ➔ Soppressione del passo comando è selezionato, il blocco non viene eseguito. N<numero blocco> Il numero di blocco viene utilizzato come marker per definire i target di salto. Esempio: N01 G<espressione> Comando di viaggio Se in un blocco non è specificato alcun comando di traslazione, il comando di traslazione nel blocco precedente viene integrato automaticamente. Maiuscole e minuscole vengono ignorate. Gli zeri iniziali vengono ignorati. Perciò, G01 = g1 si applica Corrisponde a un elemento del percorso o un oggetto del percorso Esempio: G1 (lineare), G2 (arco) La velocità con cui vengono interpolati gli oggetti di interpolazione; in linea di principio corrisponde alla velocità vettoriale, all'accelerazione vettoriale e alla decelerazione impostate. L'interpolatore fa in modo che questi valori limite non vengano superati. <Parola in codice G> Maiuscole e minuscole vengono ignorate. Parola in codice G È costituito da un indirizzo (ad es. E ) e un'espressione (ad es. 100 ; insieme E100 ) Maiuscole e minuscole vengono ignorate. Gli zeri iniziali vengono ignorati. Scrive il numero della parola in una variabile La lettera della parola è il nome della variabile. Il comando di viaggio accede a questo. Tutti i numeri possono essere valori in virgola mobile. Questo non si applica al G<expression> comando di viaggio, M<expression> funzione M, e H<expression> punto di commutazione. Le parole di un blocco sono separate da a spazio o tab . <espressione> Vedere: espressioni() Commento I caratteri tra parentesi vengono interpretati come un commento. Nota: Circa l'ingresso bParenthesesAsComments ( FB SMC_ReadNCFile2 ) i commenti possono essere ridefiniti. Interpolazione tra due blocchi consecutivi La velocità durante la transizione di due oggetti adiacenti è determinata dalle seguenti regole: Se uno dei due oggetti è un posizionamento di G0 , quindi la velocità di transizione = 0. Se l'angolo tra le tangenti di entrambi gli elementi del percorso sulla transizione è maggiore della tolleranza dell'angolo, la velocità di transizione = 0. In caso contrario, la velocità di transizione è la velocità minima specificata di entrambi gli elementi del percorso. Di norma, il comando di traslazione è responsabile di un'interpolazione della posizione di arrivo dell'ultimo comando di traslazione sulla posizione di arrivo, che è stata specificata dall'attuale comando di traslazione, da eseguire. Il primo comando di traslazione inizia nella posizione definita nel decoder o nell'editor CNC. Se questa posizione non è definita, il punto di partenza è X=0, Y=0, Z=0. " }, 
{ "title" : "Comandi di viaggio e relativi elementi di percorso ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_48e0dea1edfe7b9ec0a8646321fb969d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Fondamenti DIN 66025 \/ Comandi di viaggio e relativi elementi di percorso ", 
"snippet" : "Comando di viaggio Descrizione Elemento del percorso G0 Movimento diretto senza azionamento dell'utensile; moto lineare PosizionamentoG1 Movimento lineare con azionamento utensile Moto lineareG2 Segmento circolare o cerchio, in senso orario ArcoG3 Segmento circolare o cerchio, in senso antiorario Ar...", 
"body" : "Comando di viaggio Descrizione Elemento del percorso G0 Movimento diretto senza azionamento dell'utensile; moto lineare PosizionamentoG1 Movimento lineare con azionamento utensile Moto lineareG2 Segmento circolare o cerchio, in senso orario ArcoG3 Segmento circolare o cerchio, in senso antiorario ArcoG4 Tempo di sosta Tempo di sostaG5 Punto di una spline cardinale 2D SplineG6 Parabola ParabolaG8 Arco ellittico o ellisse, in senso orario EllisseG9 Arco ellittico o ellisse, in senso antiorario EllisseG10 Punto di una spline cardinale 3D SplineG15 Passa a 2D Modalità 3DG16 Passa al 3D attivando la modalità 3D con il vettore normale I \/ J \/ K all'aereo Modalità 3DG17 Passa al 3D attivando la modalità 3D in X \/ Y aereo Modalità 3DG18 Passa al 3D attivando la modalità 3D in Z \/ X aereo Modalità 3DG19 Passa al 3D attivando la modalità 3D in Y \/ Z aereo Modalità 3DG20 Salto condizionale a L , Se K <> 0 SaltoG31 Elimina la distanza residua con arresto di decodifica Funzione di rilevamento (distanza residua chiara)G36 Scrivi valore D a variabile O Modifica dei valori delle variabiliG37 Variabile di incremento O per valore D Modifica dei valori delle variabiliG38 Attiva la funzione di preelaborazione estesa Attivazione della funzione di preelaborazione estesaG39 Disattiva la funzione di preelaborazione estesa Attivazione della funzione di preelaborazione estesaG40 Compensazione fine raggio utensile Pre-elaborazioneG41 Inizio della compensazione raggio utensile, a sinistra della direzione di marcia Pre-elaborazioneG42 Inizio della compensazione del raggio utensile, a destra della direzione di marcia Pre-elaborazioneG43 Avvia la correzione della lunghezza dell'utensile Pre-elaborazioneG50 Arrotondamento\/smussatura dell'estremità degli angoli Pre-elaborazioneG51 Inizio della levigatura degli angoli Pre-elaborazioneG52 Inizio dell'arrotondamento degli angoli Pre-elaborazioneG53 Termina la trasformazione delle coordinate e ripristina il sistema di coordinate del decoder nella posizione originale (= sistema di coordinate macchina) Spostamento, rotazione e ridimensionamento del sistema di coordinateG54 Trasformazione assoluta delle coordinate Spostamento, rotazione e ridimensionamento del sistema di coordinateG55 Trasformazione relativa delle coordinate Spostamento, rotazione e ridimensionamento del sistema di coordinateG56 Imposta l'orientamento, la posizione e la scala correnti del DCS è impostato come punto di riferimento Spostamento, rotazione e ridimensionamento del sistema di coordinateG60 Soppressione della fine del ciclo Pre-elaborazioneG61 Inizio della soppressione del ciclo Pre-elaborazioneG70 Fine del livellamento degli assi aggiuntivi Vedere: SMC_SmoothAddAxes Pre-elaborazioneG71 Inizio del livellamento di ulteriori assi Vedere: SMC_SmoothAddAxes Pre-elaborazioneG75 Sincronizzazione del tempo con l'interpolatore Sincronizzazione dei tempi con l'interpolatoreG90 Le coordinate ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) sono interpretati come valori assoluti. (Questa è l'impostazione predefinita.) modalitàG91 Le coordinate ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) vengono interpretati come valori relativi alla posizione corrente. modalitàG92 Posizionamento per salto PosizionamentoG98 I punti medi dell'asse ( I \/ J \/ K ) sono interpretati come valori assoluti. modalitàG99 I punti medi dell'asse ( I \/ J \/ K ) vengono interpretati come valori relativi alla posizione iniziale. (Questa è l'impostazione predefinita.) modalità" }, 
{ "title" : "Riconoscimento delle parole in codice G ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_591ac87c61b577fcc0a8640e0070747c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Fondamenti DIN 66025 \/ Riconoscimento delle parole in codice G ", 
"snippet" : "A Posizione di destinazione dell'asse spline aggiuntivo Per una trasformazione delle coordinate nel sistema di coordinate del decodificatore, la parola contiene un angolo. B C D Raggio utensile per la compensazione G40 - G42 Distanza dell'utensile per arrotondare gli angoli G50 - G51 Valore variabil...", 
"body" : "A Posizione di destinazione dell'asse spline aggiuntivo Per una trasformazione delle coordinate nel sistema di coordinate del decodificatore, la parola contiene un angolo. B C D Raggio utensile per la compensazione G40 - G42 Distanza dell'utensile per arrotondare gli angoli G50 - G51 Valore variabile G36 \/ G37 E Accelerazione\/decelerazione massima del percorso in [u\/sec 2 ]. Valore > 0: accelerazione; valore < 0: decelerazione EF Accelerazione\/decelerazione del percorso per G0 movimento E<axis> Accelerazione\/decelerazione individuale (>0\/<0) del valore specificato <axis> asse aggiuntivo Gli assi aggiuntivi sono A , B , C , P , Q , U , V , W , e anche Z in modalità 2D. Se viene utilizzato questo codice G, allora il blocco di elaborazione del percorso SMC_ExtendedVelocityChecks deve essere utilizzato per limitare la velocità. F Velocità (in [u\/sec]): \"Avanzamento\" FF Velocità per G0 movimenti F<axis> Velocità individuale dell'asse aggiuntivo specificato <asse> Gli assi aggiuntivi sono A , B , C , P , Q , U , V , W , e anche Z in modalità 2D. Se viene utilizzato questo codice G, allora il blocco di elaborazione del percorso SMC_ExtendedVelocityChecks deve essere utilizzato per limitare la velocità. G Condizione del percorso H Punto di commutazione (funzione H) Positivo: accendere Negativo: Spegnere I Coordinata X del punto medio del cerchio\/ellisse per G02 \/ G03 \/ G08 \/ G09 Coordinata X del vertice della parabola per G06 Vettore normale (X) per la funzione piano 3D Parametri per l'attivazione delle funzioni di preelaborazione estese per G38 \/ G39 Ridimensionamento in direzione X per G54 \/ G55 \/ G56 Correzione utensile in direzione X per G43 J Coordinata Y del punto medio cerchio\/ellisse per G02 \/ G03 \/ G08 \/ G09 Coordinata Y del vertice della parabola per G06 Vettore normale (Y) per la funzione piano 3D Parametri per l'attivazione delle funzioni di preelaborazione estese per G38 \/ G39 Ridimensionamento in direzione Y per G54 \/ G55 \/ G56 Correzione utensile in direzione Y per G43 K Direzione dell'asse dell'ellisse primaria; matematicamente: 0° = O , 90° = N , eccetera. Condizione di salto per G20 Valore del parametro dT1 per la funzione M Coordinata Z del punto medio del cerchio per G02 \/ G03 in modalità 3D Vettore normale (Z) per la funzione piano 3D Parametri per l'attivazione delle funzioni di preelaborazione estese per G38 \/ G39 Ridimensionamento in direzione Z per G54 \/ G55 \/ G56 Correzione utensile in direzione Z per G43 L Posizione assoluta dell'interruttore per la funzione H, misurata dall'inizio dell'elemento del percorso (se posizione > 0) o misurata dalla fine dell'elemento del percorso (se posizione < 0). Salta il bersaglio per G20 Valore del parametro dT2 per la funzione M Numero dell'asse aggiuntivo per G70 e G71 M Opzione aggiuntiva per macchinari; anche funzione M O Posizione relativa del punto di commutazione con campo di valori [0..1] per funzione H Valore variabile G36 \/ G37 . Struttura dei dati per i parametri di una funzione M P Posizione di destinazione dell'asse lineare aggiuntivo P P<axis><period> Configurazione degli assi modulo Se Period = 0 si applica (esempio: PA0 ), allora il comportamento dell'asse è lineare. PROBE Attiva la funzione di rilevamento (distanza residua chiara) per il movimento Q Posizione di destinazione dell'asse lineare aggiuntivo Q R Raggio del cerchio alternativo a I, J con G02 \/ G03 Rapporto di lunghezza dell'asse ellittico secondario\/primario nel campo di valori di [0..1] con G08 \/ G09 S Profilo a S per assi lineari Positivo: accendere Negativo: Spegnere Asse 3 : Z, se Z è in modalità 2D 7 : P 8 : Q 9 : U 10 : V 11 : W T Parametro specifico del comando U Posizione di destinazione dell'asse lineare aggiuntivo U V Posizione di destinazione dell'asse lineare aggiuntivo V W Posizione di destinazione dell'asse lineare aggiuntivo W X Coordinata X della posizione target Y Coordinata Y della posizione target Z Coordinata Z della posizione di destinazione " }, 
{ "title" : "Modalità 3D ", 
"url" : "_sm_cnc_din66025_3dmode.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Modalità 3D ", 
"snippet" : "codice G : G15 , G16 , G17 , G18 , G19 Codice G Descrizione G15 Passa alla modalità 2D. Valido per tutti gli altri elementi G16 Attiva la funzione piano 3D nel piano normale con vettore normale I\/J\/K e passa alla modalità 3D Valido per tutti gli altri elementi G17 Attiva la funzione del piano 3D nel...", 
"body" : "codice G : G15 , G16 , G17 , G18 , G19 Codice G Descrizione G15 Passa alla modalità 2D. Valido per tutti gli altri elementi G16 Attiva la funzione piano 3D nel piano normale con vettore normale I\/J\/K e passa alla modalità 3D Valido per tutti gli altri elementi G17 Attiva la funzione del piano 3D nel piano X\/Y e passa alla modalità 3D Valido per tutti gli altri elementi G18 Attiva la funzione piano 3D nel piano X\/Z. Passa alla modalità 3D Valido per tutti gli altri elementi G19 Attiva la funzione del piano 3D nel piano Y\/Z. Passa alla modalità 3D Valido per tutti gli altri elementi Gli elementi del percorso tridimensionali vengono utilizzati in modalità 3D. Nello spazio 3D, puoi impostare punti e connetterti con spline 3D. Puoi anche inserire archi in qualsiasi piano spaziale. A differenza degli elementi del percorso 2.5D che utilizzano solo le coordinate X\/Y, la velocità e l'accelerazione del percorso si riferiscono al movimento nelle coordinate X\/Y\/Z. L'asse Z viene trattato come l'asse X e l'asse Y. Pertanto, ogni movimento può essere eseguito nella direzione Z. Modalità 3D La modalità non supporta ellissi, parabole e spline 2D. Viene emesso un messaggio di errore. SMC_CheckVelocities controlla il componente Z SMC_ToolCorr e SMC_AvoidLoop generare errori Differenze primarie tra 2.5D e 3D Differenze primarie tra 2.5D e 3D Velocità e accelerazione (F\/E): In 3D: definisce la velocità e l'accelerazione del percorso. In 2.5D: Definisce la velocità e l'accelerazione della proiezione del percorso sul piano X\/Y. Spline 3D: con un componente Z levigato e senza strappi (G10) 2.5D: in direzione Z non levigato (G5) Arco 3D: può essere definito in ogni possibile piano nello spazio (G2\/G3 con G16\/G17\/G18\/G19) 2.5D: limitato al piano X\/Y (G2\/G3) Esempio Confronto di velocità di 3D e 2.5D N0 G1 X1 Z100 F1 Il 3D richiede il movimento per circa 100 secondi, poiché la lunghezza dell'oggetto contiene il componente Z. Lunghezza = (1 2 + 100 2 ) 1\/2 A una velocità di 1, sono necessari circa 100 secondi. La velocità della componente Z è di circa 1. In 2.5D, il movimento richiede circa 1 secondo per il calcolo o la lunghezza = 1. La velocità nella direzione Z è di circa 100. " }, 
{ "title" : "Attivazione della funzione di preelaborazione estesa ", 
"url" : "_sm_cnc_din66025_activating_extended_preprocessor_functions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Attivazione della funzione di preelaborazione estesa ", 
"snippet" : "codice G : G38 , G39 Funzione : Questi comandi attivano e disattivano la funzione di preelaborazione estesa. Sintassi G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> G39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> Parola in codice G Descrizione <bit> Valore compreso tra 0 e 31. L'ass...", 
"body" : "codice G : G38 , G39 Funzione : Questi comandi attivano e disattivano la funzione di preelaborazione estesa. Sintassi G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value>\nG39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> Parola in codice G Descrizione <bit> Valore compreso tra 0 e 31. L'assegnazione dei bit alle funzioni è lasciata allo sviluppatore. Alcuni blocchi funzione, come SMC_SmoothMerge o SMC_SmoothBSpline , avere un input wFeatureBit (valore iniziale 0) che definisce il bit da utilizzare. Il bit viene salvato nella variabile SMC_GeoInfo.dwFeatureFlags . <Param1Value> Qualsiasi valore. I valori vengono salvati nell'array SMC_GeoInfo.aAdditionalParams : ARRAY[0..MAX_ADDITIONAL_PARAMS-1] OF LREAL . <Param1Value> <Param1Value> " }, 
{ "title" : "Spostamento, rotazione e ridimensionamento del sistema di coordinate ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Spostamento, rotazione e ridimensionamento del sistema di coordinate ", 
"snippet" : "codice G : G53 , G54 , G55 , G56 Funzione : I comandi del codice G G54 , G55 , E G56 spostare, ruotare e scalare il sistema di coordinate del decodificatore utilizzato internamente dal blocco funzione interprete SMC_NCInterpreter . Le trasformazioni delle coordinate vengono calcolate per tutti gli e...", 
"body" : "codice G : G53 , G54 , G55 , G56 Funzione : I comandi del codice G G54 , G55 , E G56 spostare, ruotare e scalare il sistema di coordinate del decodificatore utilizzato internamente dal blocco funzione interprete SMC_NCInterpreter . Le trasformazioni delle coordinate vengono calcolate per tutti gli elementi del percorso durante l'esecuzione del SMC_NCInterpreter istanza del blocco funzione. Il comando in codice G G53 reimposta il sistema di coordinate del decodificatore alla posizione, all'orientamento e alla scala originali (corrispondenti al sistema di coordinate della macchina). Si sposta e si ruota il sistema di coordinate del decodificatore per riutilizzare il codice G degli stessi elementi del percorso che differiscono solo per posizione, orientamento o scala. La rotazione e la scalatura del sistema di coordinate del decodificatore funzionano solo nell'interprete online (non nell'editor CNC). " }, 
{ "title" : "Sistemi di coordinate MCS e DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Spostamento, rotazione e ridimensionamento del sistema di coordinate \/ Sistemi di coordinate MCS e DCS ", 
"snippet" : "Il sistema di coordinate macchina (MCS) è definito dalla cinematica applicata che ne determina la posizione e l'orientamento. Il sistema di coordinate del decodificatore (DCS) è gestito dall'interprete ( SMC_NCInterpreter istanza del blocco funzione). Tutte le informazioni sulle coordinate per i com...", 
"body" : "Il sistema di coordinate macchina (MCS) è definito dalla cinematica applicata che ne determina la posizione e l'orientamento. Il sistema di coordinate del decodificatore (DCS) è gestito dall'interprete ( SMC_NCInterpreter istanza del blocco funzione). Tutte le informazioni sulle coordinate per i comandi di movimento vengono interpretate in questo sistema di coordinate. Ciò influisce sulla posizione target di un movimento ( X\/Y\/Z ), nonché un punto medio dell'arco ( I\/J\/K ) o un aereo impostato con G15\/G16\/G17\/G18\/G19 . Il DCS si programma con i comandi G53\/G54\/G55\/G56 . È possibile ruotare, spostare e ridimensionare il DCS rispetto al sistema di coordinate della macchina e quindi adattare la posizione, l'orientamento e la scala nel file del codice G un numero qualsiasi di volte. Si programmano gli elementi del percorso relativi al DCS. Ad esempio, questo può essere un vantaggio per gli stessi elementi di percorso in posizioni e orientamenti diversi. L'immagine seguente mostra uno spostamento (a sinistra) e uno spostamento con rotazione (a destra). L'interprete ottiene le informazioni dal suo eOriConv input su se A\/B\/C vengono trattati come assi aggiuntivi o come valori di orientamento. Le coordinate degli elementi del percorso vengono trasformate di conseguenza. Pertanto, il blocco funzione interprete gestisce un sistema di coordinate attivo. Inizialmente, se il DCS non viene né spostato, né ruotato, né scalato, allora il DCS corrisponde al MCS. Le posizioni iniziale e finale e il piano per gli archi sono specificati negli oggetti GeoInfo generati sempre in relazione all'MCS. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES Non è specificata alcuna convenzione di orientamento. Il contenuto della parola in codice G A\/B\/C viene interpretato come valore di shift. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYZ La convenzione di orientamento è la convenzione Y standard (Z, Y', Z''). Il contenuto della parola in codice G A\/B\/C viene interpretato come valore angolare. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYX La convenzione di orientamento è la convenzione imbardata-pitch-roll (Z, Y', X''). Il contenuto della parola in codice G A\/B\/C viene interpretato come valore angolare. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.XYZ La convenzione di orientamento è la convenzione XYZ (X, Y', Z''). Il contenuto della parola in codice G A\/B\/C viene interpretato come valore angolare. " }, 
{ "title" : "Comandi G53, G54, G55, G56 ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Spostamento, rotazione e ridimensionamento del sistema di coordinate \/ Comandi G53, G54, G55, G56 ", 
"snippet" : "Codice G Descrizione G53 Reimposta il sistema di coordinate del decodificatore Il DCS viene reimpostato nella stessa posizione e orientamento dell'MCS. G54 Assoluto spostamento, rotazione e ridimensionamento del DCS I valori si riferiscono al MCS. Se una convenzione di orientamento è non specificato...", 
"body" : "Codice G Descrizione G53 Reimposta il sistema di coordinate del decodificatore Il DCS viene reimpostato nella stessa posizione e orientamento dell'MCS. G54 Assoluto spostamento, rotazione e ridimensionamento del DCS I valori si riferiscono al MCS. Se una convenzione di orientamento è non specificato ( SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES ), allora il comando provoca uno spostamento solo lungo gli assi X\/Y\/Z\/A\/B\/C e su tutti gli ulteriori assi lineari P\/Q\/U\/V\/W. Pertanto è possibile programmare uno spostamento anche lungo gli assi A\/B\/C. Se viene specificata una convenzione di orientamento, il comando comporta uno spostamento anche lungo gli assi X\/Y\/Z e lungo gli assi lineari aggiuntivi P\/Q\/U\/V\/W. Inoltre, gli assi delle coordinate vengono ruotati. Quindi la convenzione di orientamento fornisce l'ordine di rotazione e le parole in codice G A\/B\/C forniscono gli angoli di rotazione in gradi. Nota: il decoder può eseguire rotazioni direzionali in un intervallo compreso tra -180° e +180°. Se si specifica un angolo al di fuori di questo intervallo, il decodificatore converte il valore in modo che rientri nell'intervallo eseguibile. Solo allora il decoder ruota gli assi delle coordinate. Ad esempio, per un angolo di 350° viene eseguita una rotazione di -10°. G55 Parente spostamento, rotazione e ridimensionamento del DCS nella sua posizione e orientamento correnti Pertanto i valori sono relativi all'origine del DCS corrente e interpretati nella direzione degli assi delle coordinate correnti del DCS. Viene aggiunto un ulteriore spostamento\/rotazione rispetto al sistema di coordinate della macchina. Se una convenzione di orientamento è non specificato, allora il comando risulta in uno spostamento relativo solo lungo gli assi X\/Y\/Z\/A\/B\/C e su tutti gli assi lineari aggiuntivi P\/Q\/U\/V\/W. Pertanto è possibile programmare uno spostamento anche lungo gli assi A\/B\/C. Se viene specificata una convenzione di orientamento, allora il comando risulta in uno spostamento relativo anche lungo gli assi X\/Y\/Z e lungo gli assi lineari aggiuntivi P\/Q\/U\/V\/W. Ma soprattutto, gli assi delle coordinate vengono ruotati ulteriormente. Quindi la convenzione di orientamento fornisce l'ordine di rotazione e le parole in codice G A\/B\/C forniscono gli angoli di rotazione. G56 Reimposta il punto di riferimento del sistema di coordinate del decoder L'orientamento, la posizione e la scala correnti del DCS sono impostati come riferimento. Suggerimento: se il punto di riferimento è X0 Y0 Z0 A0 B0 C0, il DCS viene impostato in modo identico alla posizione e all'orientamento attuali. Sintassi G53\nG54 X Y Z A B C I J K P Q U V W\nG55 X Y Z A B C I J K P Q U V W\nG56 X Y Z A B C I J K P Q U V W Parola in codice G Descrizione X Y Z Valore attorno al quale viene spostato il sistema di coordinate del decodificatore A B C Se l'input è eOriConf = SMC_ORI_CONVENTION.ADDAXES A SMC_NCInterpreter , quindi viene fornito il valore in unità di quanto viene spostato il rispettivo asse aggiuntivo. Pertanto, il parametro definisce lo spostamento per ciascun asse del sistema di coordinate del decodificatore rispetto al sistema di coordinate della macchina. Se la eOriConf l'input è SMC_ORI_CONVENTION.ZYZ , SMC_ORI_CONVENTION.ZYX , O SMC_ORI_CONVENTION.XYZ A SMC_NCInterpreter , allora viene fornita una convenzione di orientamento. In questo caso i valori qui indicati vengono interpretati automaticamente come gradi e determinano di quanto vengono ruotati gli assi del sistema di coordinate del decodificatore rispetto al sistema di coordinate della macchina. Pertanto, si definisce la rotazione degli assi principali secondo la convenzione di orientamento. Nota: quando si programma la rotazione DCS, gli angoli di rotazione devono essere sempre specificati in A\/B\/C per tutti e tre gli assi. Un angolo di rotazione mancante provoca un errore durante la decodifica ( SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ). I Scala in direzione X Esempio: 10 per l'estensione di un fattore 10 J Scala in direzione sì Esempio: 10 per l'estensione di un fattore 10 K Scala in direzione Z Esempio: 10 per l'estensione di un fattore 10 P Q U V W Valore attorno al quale viene spostato l'asse aggiuntivo del sistema di coordinate del decodificatore " }, 
{ "title" : "Spostamento del DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Spostamento, rotazione e ridimensionamento del sistema di coordinate \/ Spostamento del DCS ", 
"snippet" : "Impostare il eOriConv ingresso del SMC_NCInterpreter istanza del blocco funzione a SMC_ORI_CONVENTION.ADDAXES . Il DCS può essere spostato. Una rotazione non è possibile. Programmare il percorso CNC. Innanzitutto, specificare lo spostamento di posizione del DCS. Esempio: G54 X10 Y10 Z10 A30 B30 C30 ...", 
"body" : "Impostare il eOriConv ingresso del SMC_NCInterpreter istanza del blocco funzione a SMC_ORI_CONVENTION.ADDAXES . Il DCS può essere spostato. Una rotazione non è possibile. Programmare il percorso CNC. Innanzitutto, specificare lo spostamento di posizione del DCS. Esempio: G54 X10 Y10 Z10 A30 B30 C30 Gli assi X\/Y\/Z\/A\/B\/C del DCS vengono spostati. Esempio Offset assoluto N10 G0 X100 Y100 F100\nN20 G54 X50 Y50 (Offset auf 50\/50)\nN30 G1 X0 Y0 (Fahrt nach 50\/50)\nN40 G54 X100 Y100 (Offset auf 100\/100)\nN50 G1 X0 Y0 (Fahrt nach 100\/100)\nN60 G53 (Offset auf 0)\nN70 G1 X0 Y0 (Fahrt nach 0\/0) Posizione attuale come offset N0 G0 X100 Y100 F100\nN10 G56 X0 Y0 (Aktuelle Position 100\/100 wird 0\/0)\nN20 G1 X10 (Fahrt nach 110\/100)\nN30 G56 X20 Y0 (Aktuelle Position 110\/100 wird 20\/0)\nN40 G1 X0 (Fahrt nach 90\/100) Adatta offset per valore N0 G54 X10 Y20 Z30 U7 (Offset: X=10, Y=20, Z=30, U=7)\nN10 G55 X-10 U7 (Offset: X=0, Y=20, Z=30, U=14) Stessi elementi di percorso in due posizioni N05 G17\nN10 G54 X10 Y10 Z10\nN20 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN30 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN040 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097\nN50 G55 X10 Y10 Z10\nN60 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN70 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN80 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097 " }, 
{ "title" : "Spostamento e rotazione del DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_df6926f62eedd311c0a8646378b457e7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Spostamento, rotazione e ridimensionamento del sistema di coordinate \/ Spostamento e rotazione del DCS ", 
"snippet" : "Impostare il eOriConv ingresso del SMC_NCInterpreter istanza del blocco funzione alla convenzione di orientamento desiderata (ad esempio, SMC_ORI_CONVENTION.ZYZ ). La convenzione di orientamento e l'ordine di rotazione degli assi X\/Y\/Z del DCS sono programmati. Per SMC_ORI_CONVENTION.ZYZ , l'ordine ...", 
"body" : "Impostare il eOriConv ingresso del SMC_NCInterpreter istanza del blocco funzione alla convenzione di orientamento desiderata (ad esempio, SMC_ORI_CONVENTION.ZYZ ). La convenzione di orientamento e l'ordine di rotazione degli assi X\/Y\/Z del DCS sono programmati. Per SMC_ORI_CONVENTION.ZYZ , l'ordine di rotazione è ZY'Z'' e corrisponde alla convenzione Y standard. Nota: finché l'ingresso eOriConv contiene una convenzione di orientamento e non il valore SMC_ORI_CONVENTION.ADDAXES , i valori delle parole A\/B\/C vengono interpretati come valori angolari per la rotazione per i comandi in codice G G54\/G55\/G56 . Programmare il percorso CNC. Innanzitutto, specificare lo spostamento di posizione e la rotazione del DCS. Esempio: G54 X10 Y10 Z10 A30 B30 C30 I valori delle parole A\/B\/C fornire il senso di rotazione e l'angolo in gradi. Il sistema di coordinate viene ruotato di conseguenza. I valori delle parole X\/Y\/Z definire lo spostamento. Nota: quando si programma la rotazione DCS, gli angoli di rotazione devono essere sempre specificati in A\/B\/C per tutti e tre gli assi. Un angolo di rotazione mancante provoca un errore durante la decodifica ( SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ). Se la eOriConv ingresso del SMC_NCInterpreter l'istanza del blocco funzione contiene il valore SMC_ORI_CONVENTION.ADDAXES , non è possibile ruotare il DCS. I valori dentro G54\/G55\/G56 vengono interpretati come valori aggiuntivi dell'asse spline. Lo spostamento è possibile. Esempi La convenzione di orientamento è stata definita negli esempi come la convenzione Y standard ( eOriConv = SMC_ORI_CONVENTION.ZYZ ). In generale per G54 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W fornisce un valore assoluto nel MCS. G55 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W fornisce un valore relativo nel DCS. G56 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W fornisce un nuovo valore assoluto nel DCS. Orientamento assoluto con G54 N01 G54 X10 A30 B0 C0 G54 comporta uno spostamento e una rotazione. La posizione e l'orientamento sono forniti assoluti all'MCS. Orientamento relativo con G55 N01 G54 X10 A30 B0 C0 (Bezieht sich auf MCS)\nN02 G55 Y10 A0 B30 C0 (Bezieht sich auf das in 01 definierte DCS) G54 comporta uno spostamento di 10 unità nella direzione X e una rotazione di 30° attorno all'asse Z assoluto rispetto all'MCS. Nel blocco 02, il DCS viene spostato di ulteriori 10 unità nella direzione dell'asse Y ruotato e quindi ruotato di ulteriori 30° attorno all'asse Y ruotato. Pertanto, la trasformazione nel blocco 02 è relativa alla trasformazione nel blocco 01. Riferimento rispetto all'orientamento corrente con G56 N01 G01 X10 A10 B90 C10 (Orientierung ist A=10°, B=90°, C=10°)\nN02 G56 A0 B0 C0 (DCS wird auf X=10, A=10°, B=90°, C=10° gesetzt) G56 determina l'orientamento corrente del DCS (programmato nel blocco 01 nell'esempio) da impostare come riferimento. Esempio: Arco N0 G17\nN0 G54 A0 B90 C0 Il piano circolare selezionato viene interpretato rispetto al DCS. Nell'esempio, il piano X\/Y è selezionato con G17 e quindi il DCS viene ruotato di 90° attorno all'asse Y. Quindi il piano selezionato nel DCS è il piano X\/Y come prima. Ciò corrisponde a quello del piano X\/Z nell'MCS. Insieme a G17 , viene selezionato il piano X\/Y. Quindi il DCS viene ruotato di 90°. Ciò si traduce nell'attivazione del piano X\/Y nel DCS come prima. Questo corrisponde al piano X\/Y nell'MCS. Nella modalità 2.5D ( G15 ), la rotazione è consentita solo attorno all'asse Z. La rotazione attorno ad un altro asse provoca un errore emesso dal decoder ( SMC_DEC_DCS_2D_NOT_IN_XY_PLANE ). Pertanto, il piano X\/Y dell'MCS rimane sempre impostato in modalità 2.5D. " }, 
{ "title" : "Scalare il sistema di coordinate ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_52b3763cadb811e79ffc84f8a2d3d270", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Spostamento, rotazione e ridimensionamento del sistema di coordinate \/ Scalare il sistema di coordinate ", 
"snippet" : "Se viene programmata una rotazione dopo un ridimensionamento ineguale, può verificarsi il ritaglio. In questo caso, l'errore SMC_DEC_ROTATION_AFFECTS_SCALING non viene rilasciato. Tutti e tre i fattori di scala devono essere specificati o nessuno. Ridimensionamento assoluto Sintassi: G54 I<i> J<j> K...", 
"body" : "Se viene programmata una rotazione dopo un ridimensionamento ineguale, può verificarsi il ritaglio. In questo caso, l'errore SMC_DEC_ROTATION_AFFECTS_SCALING non viene rilasciato. Tutti e tre i fattori di scala devono essere specificati o nessuno. Ridimensionamento assoluto Sintassi: G54 I<i> J<j> K<k> Un sistema di coordinate può essere allungato o compresso nelle tre direzioni spaziali X\/Y\/Z indipendentemente l'uno dall'altro. È possibile specificare un fattore per ogni direzione. Specificare il fattore di scala per X in I, Y in J e Z in K. Un fattore di scala > 1 si estende. Un fattore di scala < 1 si comprime. Estensione di 10 volte: N01 G01 X10\nN02 G54 A90 B0 C0 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 Tutti i caposaldo vengono estesi di 10 volte nella direzione dell'asse X ruotato. Il codice seguente genera lo stesso percorso: N01 G01 X10\nN02 G01 X-20 Y100\nN03 G01 X-10 Y50. Se non vengono specificati né I né J né K, il valore precedentemente impostato rimane invariato: N01 G54 I10 J1 K1\nN02 G54 X1\nN03 G01 X10 Lo stesso percorso si ottiene con il seguente codice: N01 G01 X101 Ridimensionamento relativo Sintassi: G55 I<i> J<j> K<k> Un fattore di scala > 1 si estende. Un fattore di scala < 1 si comprime. I fattori di scala vengono moltiplicati. Estensione di 100 volte: N01 G54 I10 J1 K1\nN02 G55 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 Il codice seguente produce lo stesso ridimensionamento: N01 G55 I100 J1 K1 Ridimensionamento circolare La scalatura di un arco è valida solo se l'elemento è ancora un arco (non un'ellisse) dopo la scalatura. Risultato dei percorsi validi: Quando tutti e tre i fattori di scala hanno lo stesso valore Quando il piano circolare è uno dei piani primari del DCS e i due fattori di scala corrispondenti sono gli stessi valori " }, 
{ "title" : "Specchio del sistema di coordinate ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_adba25b098ef7863c0a8646324d700b4", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Spostamento, rotazione e ridimensionamento del sistema di coordinate \/ Specchio del sistema di coordinate ", 
"snippet" : "Un ridimensionamento assoluto con fattori di ridimensionamento negativi in I , J , o K determina il mirroring del sistema di coordinate corrente. Fattore di scala negativo G54 A30 B0 C0 I-1 J1 K1...", 
"body" : "Un ridimensionamento assoluto con fattori di ridimensionamento negativi in I , J , o K determina il mirroring del sistema di coordinate corrente. Fattore di scala negativo G54 A30 B0 C0 I-1 J1 K1 " }, 
{ "title" : "modalità ", 
"url" : "_sm_cnc_din66025_modi.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ modalità ", 
"snippet" : "Funzione : Questi comandi determinano se le coordinate ei punti medi dell'asse vengono interpretati come valori assoluti o coordinate relative. Codice G Descrizione G90 Le coordinate ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) sono interpretati come valori assoluti. (Questa è l'impostazione predef...", 
"body" : "Funzione : Questi comandi determinano se le coordinate ei punti medi dell'asse vengono interpretati come valori assoluti o coordinate relative. Codice G Descrizione G90 Le coordinate ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) sono interpretati come valori assoluti. (Questa è l'impostazione predefinita.) G91 Le coordinate ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) vengono interpretati come valori relativi alla posizione corrente. G98 I punti medi dell'asse ( I \/ J \/ K ) sono interpretati come valori assoluti. G99 I punti medi dell'asse ( I \/ J \/ K ) vengono interpretati come valori relativi alla posizione iniziale. (Questa è l'impostazione predefinita.) Sintassi G90\nG91\nG98\nG99 Esempi Valore della coordinata come valore assoluto L'interpolatore si sposta a 10\/10 e poi a 100\/10. Le coordinate vengono interpretate come valori assoluti. N0 G90\nN10 G1 X10 Y10 F100 (Startposition)\nN20 G1 X100 (Nächste Position) Valore della coordinata come valore relativo L'interpolatore si sposta a 10\/10 e poi a 110\/10. Le coordinate vengono interpretate come valori relativi. N0 G91\nN10 G1 X10 Y10 F100\nN20 G1 X100 Valore della coordinata come valore assoluto in I\/J\/K Il punto medio del semicerchio è a 150\/0. Le coordinate vengono interpretate come valori assoluti. N00 G98\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I150 J0 F100 Valore della coordinata come valore relativo in I\/J\/K Il punto medio del semicerchio è a 150\/0. Le coordinate vengono interpretate come valori relativi. N00 G99\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I50 J0 F100 Per ulteriori informazioni, vedere: Configurazione di singoli assi aggiuntivi come assi modulo (PA\/PB\/…)" }, 
{ "title" : "Tempo di sosta ", 
"url" : "_sm_cnc_din66025_delay.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Tempo di sosta ", 
"snippet" : "codice G : G4 Funzione : Il comando fa sì che l'interpolatore rimanga nella posizione corrente per un tempo specifico. Esempio tempo di sosta N0 G4 T1 L'interpolatore si ferma per un secondo....", 
"body" : "codice G : G4 Funzione : Il comando fa sì che l'interpolatore rimanga nella posizione corrente per un tempo specifico. Esempio tempo di sosta N0 G4 T1 L'interpolatore si ferma per un secondo. " }, 
{ "title" : "Punto di commutazione (funzione H) ", 
"url" : "_sm_cnc_din66025_hfunction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Punto di commutazione (funzione H) ", 
"snippet" : "Funzione : La funzionalità del punto di commutazione o la funzione H attiva gli interruttori binari dipendenti dal percorso. Un numero massimo di tre punti di commutazione ( MAX_SWITCHES ) possono essere elaborati per ogni elemento del percorso. Sintassi [G-Befehl] H O\/L Per prima cosa viene definit...", 
"body" : "Funzione : La funzionalità del punto di commutazione o la funzione H attiva gli interruttori binari dipendenti dal percorso. Un numero massimo di tre punti di commutazione ( MAX_SWITCHES ) possono essere elaborati per ogni elemento del percorso. Sintassi [G-Befehl] H O\/L Per prima cosa viene definito il numero del punto di commutazione H<numero>, quindi la posizione del punto di commutazione nell'elemento del percorso viene definita come assoluta (L<posizione> parola) o relativa (O<posizione> parola). Parola in codice G Descrizione H{-}<numero> Numero della funzione H Se il numero H è positivo, viene attivata la rispettiva funzione dell'interruttore. Se il numero H è negativo, la funzione dell'interruttore è disattivata. Il numero H è diverso da zero e compreso tra -32768 e 32767. O<posizione> Posizione relativa [0…1] nell'elemento del percorso 0: Inizio dell'elemento 1: Fine L<posizione> L>0: distanza dal punto di partenza L<0: distanza dal punto finale Rappresentazione grafica Nell'editor grafico è possibile utilizzare il mouse per spostare i punti di commutazione lungo il percorso. Quando si sposta il mouse sulla funzione H, viene visualizzato un suggerimento con il numero H della funzione H. Effetto sul SMC_Interpolator blocco funzione L'interpolatore invia l'ultimo numero H commutato al iLastSwitch produzione. iLastSwitch è positivo quando la funzione H è attiva. Il dwSwitches l'output è una maschera di bit. Numero bit i indica se la funzione H (i+1) è attualmente impostata o meno. Se il numero H è compreso tra 1 e 32, il bit corrispondente viene impostato nell'interpolatore dwSwitches produzione. Un valore negativo compreso tra -1 e -32 azzera il bit. Il iLastSwitch l'uscita ha il numero dell'ultimo punto di commutazione dell'esecuzione, anche se il valore è al di fuori dell'intervallo da -32 a 32. Esempi Spegnimento punto di commutazione 2 con posizione relativa all'elemento Il punto di commutazione 2 viene disattivato nella posizione X=40\/Y=25 dopo il primo quarto dell'elemento. N90 G1 X20 Y20\nN100 G1 X100 Y40 H-2 O0.25 Accensione e spegnimento punto di commutazione 2 con posizione relativa al punto iniziale e finale Il punto di commutazione 2 viene attivato nella posizione X=40, ovvero 20 unità dopo il punto di partenza dell'elemento di traiettoria. Il punto di commutazione 2 viene disattivato nella posizione X=90, ovvero 10 unità prima del punto finale. N90 G1 X20\nN100 G1 X100 H2 L20 H-2 L-10 " }, 
{ "title" : "Funzione M ", 
"url" : "_sm_cnc_din66025_mfunction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Funzione M ", 
"snippet" : "Funzione : Le funzioni M o le funzioni aggiuntive avviano azioni durante l'interpolazione del codice G. L'interpolatore decelera alla velocità 0, invia all'uscita il numero della funzione M in coda wM , e attende la conferma in bAcknM prima di accelerare di nuovo. Contrariamente al punto di commutaz...", 
"body" : "Funzione : Le funzioni M o le funzioni aggiuntive avviano azioni durante l'interpolazione del codice G. L'interpolatore decelera alla velocità 0, invia all'uscita il numero della funzione M in coda wM , e attende la conferma in bAcknM prima di accelerare di nuovo. Contrariamente al punto di commutazione, il programma rimane nella posizione attuale finché la funzione M non viene confermata impostando l'ingresso sull'interpolatore. Se SMC_PreAcknowledgeM viene eseguita, quindi il blocco funzione conferma in anticipo la funzione M. Se il blocco funzione viene eseguito in tempo, l'interpolatore non si arresta e il programma continua come se l'istruzione M non fosse presente. Una funzione M è implementata dall'applicazione e non definita dal sistema. Sintassi M K L O Parola in codice G Descrizione M Numero della funzione M, M > 0 Nota: i numeri 65533–65535 sono riservati alle funzioni interne. K Parametro numerico ( LREAL ) L Parametro numerico ( LREAL ) O Riferimenti con O$var$ una variabile di tipo SMC_M_PARAMETERS che contiene altri parametri. Nell'applicazione, i valori dei parametri delle variabili vengono letti in fase di esecuzione tramite la funzione SMC_GetMParameters . Inoltre, tutti i parametri vengono valutati al momento della decodifica e salvati nella struttura dati SMC_GEOINFO del tampone SMC_OUTQUEUE . Di norma, ciò avviene in un momento prima dell'esecuzione della funzione M sull'interpolatore. In modo che la variabile possa essere trovata dal blocco funzione utilizzato (ad esempio SMC_ReadNCFile2 ) durante la decodifica, deve essere aggiunto al suo SMC_VARLIST con il tipo SMC_VARTYPE.SMC_TYPE_USERDEF . Esempi M con parametro La funzione M 10 si avvia. Per l'esecuzione del programma di N90, il sistema attende la disponibilità della conferma. N90 M10 K100.7 M con parametro aggiuntivo La funzione M 10 si avvia. La struttura dei dati definita dall'utente g_myMParams (tipo di dati SMC_M_PARAMETER ) è referenziato con O$var$ . g_myMParams contiene parametri aggiuntivi. I valori di K, L e i parametri di g_myMParams può essere letto al momento dell'arresto del percorso della funzione M. Lo si fa chiamando un'istanza del blocco funzione SMC_GetMParameters . N150 M13 O$g_myMParams$ " }, 
{ "title" : "Sincronizzazione dei tempi con l'interpolatore ", 
"url" : "_sm_cnc_din66025_time_synchronisation_with_interpolator.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Sincronizzazione dei tempi con l'interpolatore ", 
"snippet" : "codice G : G75 Funzione : Il comando impedisce al blocco funzione del decoder di elaborare il codice G finché l'interpolatore non ha attraversato tutti gli oggetti precedenti. Quando l'interpolatore raggiunge G75 , tutte le code sono vuote e l'NCDecoder e tutti i blocchi funzione di preelaborazione ...", 
"body" : "codice G : G75 Funzione : Il comando impedisce al blocco funzione del decoder di elaborare il codice G finché l'interpolatore non ha attraversato tutti gli oggetti precedenti. Quando l'interpolatore raggiunge G75 , tutte le code sono vuote e l'NCDecoder e tutti i blocchi funzione di preelaborazione continuano a funzionare. Questa funzione è utile per utilizzare le variabili. Il decoder sostituisce le variabili quando viene elaborata la riga corrispondente. Tuttavia, l'esecuzione da parte dell'interpolatore avviene dopo un tempo specificato in base al meccanismo della coda. Puoi usare G75 per attendere e sincronizzare la valutazione delle variabili e la successiva elaborazione da parte dell'interpolatore. Sintassi G75 Esempio N10 G1 X100\nN20 G75\nN30 G1 Y$g_y$ La variabile g_y è disponibile con l'elemento G1 e non viene rilevato in anticipo. Se G75 non è inserito, quindi il NCDecoder elabora la riga 30 immediatamente prima che venga rilevato il valore. G75 non ha alcun effetto sull'editor CNC o sui percorsi che l'editor CNC genera come SMC_OutQueue . " }, 
{ "title" : "Salto ", 
"url" : "_sm_cnc_din66025_jump.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Salto ", 
"snippet" : "codice G : G20 Funzione : Il comando esegue un salto condizionato. Sintassi G20 L K Parola in codice G Descrizione L Obiettivo di salto: Numero di riga definito (esempio: L20 ) Etichetta di salto Il salto è definito da un punto interrogativo e da un indice (esempio: L?4 ). Il comando per il bersagli...", 
"body" : "codice G : G20 Funzione : Il comando esegue un salto condizionato. Sintassi G20 L K Parola in codice G Descrizione L Obiettivo di salto: Numero di riga definito (esempio: L20 ) Etichetta di salto Il salto è definito da un punto interrogativo e da un indice (esempio: L?4 ). Il comando per il bersaglio del salto stesso è identificato da un punto esclamativo e dall'indice corrispondente (esempio: L!4 ). Il target di salto può essere collegato a qualsiasi comando in codice G. Questo salto viene utilizzato per i programmi CNC generati automaticamente quando la linea di destinazione è sconosciuta. I salti con destinazioni sconosciute per saltare le etichette funzionano solo nel decodificatore online (non nell'editor CNC). Presupposto: la riga con l'etichetta di salto deve trovarsi dopo la riga con il comando di salto. Non è possibile \"saltare indietro\". Se la \"linea di destinazione\" non è definita, i comandi che seguono il comando di salto non vengono eseguiti. K Condizione Se K <> 0, il salto viene eseguito. Se K non è definito, viene utilizzata una variabile di decodifica interna. Il valore della variabile del decodificatore interno può essere definito con Modifica dei valori delle variabili comando. Il valore predefinito di questa variabile interna è -1 . Esempio: eseguire il salto fino al contatore interno = 0 Dieci righe sono collegate tra loro dalla relativa modalità. Ciò si traduce in un movimento di linea a 100\/100. N00 G36 D10 (set counter to 10)\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G37 D-1 (decrement counter)\nN40 G20 L20 (jump, if counter != 0) Esempio: valutare la condizione di salto al momento della decodifica Requisito: Il comportamento della variabile bvar è programmato nell'applicazione. Se l'asse X supera la posizione 15, allora bvar FALSE è impostato. ( bVar è inizialmente impostato su TRUE .) Nel primo ciclo di programma, la posizione X è 10 e il programma salta alla riga 20. Il ciclo viene eseguito continuamente perché la valutazione della condizione avviene al momento della decodifica e l'interpolatore non è stato ancora avviato o è occupato con l'elaborazione di oggetti all'inizio del buffer. Questa condizione è soddisfatta e il decodificatore salta fuori dal ciclo solo dopo che sono stati generati abbastanza oggetti da riempire il buffer e l'interpolatore inizia l'elaborazione. Nella seconda esecuzione, l'asse X non è ancora nella posizione 20. La condizione non è soddisfatta e bVar non era impostato su FALSE nel codice IEC. N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G20 L20 K$bvar$ (jump, if counter != 0) Esempio: inserire la sincronizzazione dei tempi G75 esegue una sincronizzazione temporale dell'interpolatore. G75 sospende l'elaborazione del decoder fino a quando l'interpolatore e la meccanica raggiungono la rispettiva posizione. N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN25 G75\nN30 G20 L20 K$x$ (jump, if counter != 0) Per ulteriori informazioni, vedere: Sincronizzazione dei tempi con l'interpolatoreEsempio: etichetta salta per saltare Nota: i salti alle etichette di salto funzionano solo nel decoder online (non nell'editor CNC). N0 G16 F100 E100 E-100\nN10 G20 L?4 \/\/unconditional jump to the unknown target with index 4\nN15 G20 L60\nN20 G1 X1\nN30 G1 X1 L!5 \/\/resolution unknown jump target with index 5\nN40 G1 Z1 L!4 \/\/resolution unknown jump target with index 4\nN50 G20 L15\nN55 G1 Y1\nN60 G0 X0 Y0 Z0 " }, 
{ "title" : "Arco ", 
"url" : "_sm_cnc_din66025_arc.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Arco ", 
"snippet" : "codice G : G2 , G3 Funzione : Il comando interpola un arco dalla posizione corrente lungo un percorso circolare fino alla posizione di destinazione. G2 si sposta in senso orario e G3 si muove in senso antiorario. L'arco è definito come segue: Metodo del raggio Coordinate target + raggio: le coordina...", 
"body" : "codice G : G2 , G3 Funzione : Il comando interpola un arco dalla posizione corrente lungo un percorso circolare fino alla posizione di destinazione. G2 si sposta in senso orario e G3 si muove in senso antiorario. L'arco è definito come segue: Metodo del raggio Coordinate target + raggio: le coordinate target sono definite in X\/Y\/Z. La curva è definita dal raggio R. Metodo del punto medio Coordinata del target + coordinata del punto medio: le coordinate del target sono definite in X\/Y\/Z. La curva è definita dalla coordinata del punto medio I\/J\/K. La coordinata del punto medio si trova sulle bisettrici perpendicolari dei punti iniziale e finale. In caso contrario, la coordinata del punto medio viene corretta automaticamente. La deviazione non deve essere superiore al 10%. Metodo dell'angolo di apertura Angolo di apertura + coordinata del punto medio: Angolo di apertura definito in T e coordinate del punto medio in I\/J\/K. La posizione di destinazione viene calcolata automaticamente. Parametri incoerenti portano a percorrere una linea anziché un cerchio. Esempi: se il raggio è inferiore alla metà della distanza tra l'inizio e l'obiettivo, la deviazione non può essere corretta. Questo vale anche se il punto medio definito rispetto alla posizione iniziale e di destinazione ha una distanza diversa. Sintassi G2 X Y Z R A B C P Q U V W F E H L\/O D S\nG2 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG2 I J K T A B C P Q U V W F E H L\/O D S\nG3 X Y Z R A B C P Q U V W F E H L\/O D S\nG3 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG3 I J K T A B C P Q U V W F E H L\/O D S Parola in codice G Descrizione X Y Z Posizioni target degli assi cartesiani R Raggio del cerchio I J K Coordinate del punto medio del cerchio T Angolo di apertura (in gradi) A B C P Q U V W Posizioni di destinazione degli assi aggiuntivi F E Velocità del percorso, accelerazione\/decelerazione del percorso H L\/O Punto di commutazione D Raggio utensile S Profilo S Rappresentazione grafica : Un arco è rappresentato da punti finali neri. I punti finali possono essere spostati quando si seleziona l'elemento. Arco in modalità 3D In modalità 3D, il sistema definisce gli archi tramite il piano di interpolazione definito mediante G15-G19. Esempio Un semicerchio nel piano X\/Z e un semicerchio nel piano X\/Y N10 G1 X100 Y100\nN15 G18\nN20 G2 X200 R50\nN25 G17\nN30 G3 X100 R50 " }, 
{ "title" : "Metodo del raggio ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_535707857cba3404c0a86463692656db", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Arco \/ Metodo del raggio ", 
"snippet" : "È possibile utilizzare il metodo del raggio per generare un arco < 180°. Il metodo del raggio è valido per due archi. Uno è più piccolo di un semicerchio e uno è più grande di un semicerchio. Il sistema utilizza sempre l'arco più piccolo. Esempio Semicerchio N10 G1 X100 Y100 F100 N20 G2 X200 Y100 R5...", 
"body" : "È possibile utilizzare il metodo del raggio per generare un arco < 180°. Il metodo del raggio è valido per due archi. Uno è più piccolo di un semicerchio e uno è più grande di un semicerchio. Il sistema utilizza sempre l'arco più piccolo. Esempio Semicerchio N10 G1 X100 Y100 F100\nN20 G2 X200 Y100 R50 Utilizzare il metodo del punto medio con I\/J\/K per generare un arco con un angolo di apertura maggiore di 180°. Il metodo del raggio è unico, tranne nel caso in cui i punti iniziale e finale del cerchio siano identici. Questo definisce un cerchio nullo o un cerchio completo. In questo caso, il sistema inserisce un cerchio completo. " }, 
{ "title" : "Metodo del punto medio ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_7dc8851b7cba3404c0a864637c8195be", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Arco \/ Metodo del punto medio ", 
"snippet" : "Se usi il metodo del punto medio, puoi distinguere se le coordinate I\/J\/K sono relative o assolute. Se I , J , e K non sono specificati correttamente, allora un arco non è possibile e il sistema lo sostituisce con una linea. Se è corretto, la distanza tra il punto medio e il punto iniziale o finale ...", 
"body" : "Se usi il metodo del punto medio, puoi distinguere se le coordinate I\/J\/K sono relative o assolute. Se I , J , e K non sono specificati correttamente, allora un arco non è possibile e il sistema lo sostituisce con una linea. Se è corretto, la distanza tra il punto medio e il punto iniziale o finale è identica. Esempi Stesso semicerchio del metodo del raggio; specificato mediante punto medio relativo N10 G1 X100 Y100 F100\nN15 G99\nN20 G2 X200 Y100 I50 J0 Stesso semicerchio del metodo del raggio; specificato mediante punto medio assoluto N10 G1 X100 Y100 F100\nN15 G98\nN20 G2 X200 Y100 I150 J100 " }, 
{ "title" : "Metodo dell'angolo di apertura ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_955d99e37cba3404c0a864634d5c784c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Arco \/ Metodo dell'angolo di apertura ", 
"snippet" : "Se si definisce il cerchio in base all'angolo di apertura T, sono consentiti al massimo tre cerchi completi (T ≤ 1080). Il metodo dell'angolo di apertura è appropriato per un arco > 180°. Esempi Stesso semicerchio del metodo del raggio; specificato mediante angolo di apertura N10 G1 X100 Y100 N15 G9...", 
"body" : "Se si definisce il cerchio in base all'angolo di apertura T, sono consentiti al massimo tre cerchi completi (T ≤ 1080). Il metodo dell'angolo di apertura è appropriato per un arco > 180°. Esempi Stesso semicerchio del metodo del raggio; specificato mediante angolo di apertura N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T180 Elica (due cerchi completi) N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T720 " }, 
{ "title" : "Ellisse ", 
"url" : "_sm_cnc_din66025_ellipse.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Ellisse ", 
"snippet" : "codice G : G8 , G9 Funzione : Il comando specifica un arco di ellisse attraverso le coordinate di destinazione X\/Y, il punto medio dell'ellisse I\/J, le direzioni dell'asse principale dell'ellisse K e il rapporto di lunghezza R tra gli assi primario e secondario. Sintassi G8 X Y Z R I J K A B C P Q U...", 
"body" : "codice G : G8 , G9 Funzione : Il comando specifica un arco di ellisse attraverso le coordinate di destinazione X\/Y, il punto medio dell'ellisse I\/J, le direzioni dell'asse principale dell'ellisse K e il rapporto di lunghezza R tra gli assi primario e secondario. Sintassi G8 X Y Z R I J K A B C P Q U V W F E H L\/O D S\nG9 X Y Z R I J K A B C P Q U V W F E H L\/O D S Parola in codice G Descrizione X Y Z Posizioni target degli assi cartesiani R Rapporto di lunghezza R tra asse primario e secondario. Intervallo: 0 < R <= 1 R viene utilizzato solo se l'arco dell'ellisse non è definito in modo univoco dai punti finali, dal punto medio e dalla pendenza dell'asse primario. Questo è il caso in cui entrambi i punti finali hanno la stessa distanza dall'asse primario. Quindi, entrambi i punti finali devono avere la stessa distanza dall'asse secondario. Altrimenti, non vi è alcuna ellisse che attraversa questi punti e il sistema sostituisce l'ellisse I J punto medio K Direzione dell'asse primario dell'ellisse (in gradi) 0: nella direzione dell'asse X 90: In direzione dell'asse Y -90: Nella direzione opposta dell'asse Y A B C P Q U V W Posizioni di destinazione degli assi aggiuntivi F E Velocità del percorso, accelerazione\/decelerazione del percorso H L\/O Punto di commutazione D Raggio utensile S Profilo S L'ellisse è un oggetto 2.5D. Ciò significa che l'ellisse appartiene sempre al piano X\/Y. Le ellissi in altri piani non sono supportate. Esempio N10 G0 X100 Y100 F100\nN15 G98\nN20 G8 X200 Y100 I150 J100 K45 R0.5 " }, 
{ "title" : "Moto lineare ", 
"url" : "_sm_cnc_din66025_line.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Moto lineare ", 
"snippet" : "codice G : G1 Funzione : Questo comando di posizionamento esegue un'interpolazione di linea. L'interpolazione della linea sposta il punto di interpolazione dalla posizione corrente alle coordinate di destinazione definite su una linea. Tutti gli assi arrivano contemporaneamente. Le coordinate del ta...", 
"body" : "codice G : G1 Funzione : Questo comando di posizionamento esegue un'interpolazione di linea. L'interpolazione della linea sposta il punto di interpolazione dalla posizione corrente alle coordinate di destinazione definite su una linea. Tutti gli assi arrivano contemporaneamente. Le coordinate del target (X\/Y\/Z) devono essere definite per la descrizione delle linee. Oltre al movimento nello spazio, è possibile specificare le posizioni target per gli assi aggiuntivi A\/B\/C\/P\/Q\/U\/V\/W che vengono raggiunti contemporaneamente con le coordinate target cartesiane. Due posizioni identiche consecutive determinano sempre un arresto del movimento in questa posizione. La fermata si verifica anche quando il percorso successivo si collega stabilmente e potrebbe essere percorso senza fermarsi. Sintassi G1 X Y Z A B C P Q U V W F E H L\/O D S Parola in codice G Descrizione X Y Z Posizioni target degli assi cartesiani A B C P Q U V W Posizioni di destinazione degli assi aggiuntivi F E Velocità del percorso, accelerazione\/decelerazione del percorso H L\/O Punto di commutazione D Raggio utensile S Profilo S Esempi Interpolazione lineare L'utensile viene posizionato nella posizione iniziale 0\/0\/0 (preimpostato) e quindi si sposta in linea retta verso la posizione finale 1\/2\/3 a velocità 1, accelerazione 10 e decelerazione 20. Allo stesso tempo, l'orientamento l'asse A è percorso a 180 gradi: N010 G01 X1 Y2 Z3 A180 F1 E10 E-20 Posizione di partenza Posizione di partenza 50\/50\/50, interpolazione lineare da 50\/50\/50 a 64\/30\/0 con avanzamento 100 N000 G92 X50 Y50 Z50 F100\nN010 G01 X64 Y30 Z0 " }, 
{ "title" : "Parabola ", 
"url" : "_sm_cnc_din66025_parabel.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Parabola ", 
"snippet" : "codice G : G6 Funzione : Il comando interpola una parabola definita dalle coordinate del punto finale X\/Y\/Z e del vertice I\/J. Il vertice è il punto in cui la tangente dell'elemento è parallela alla linea di collegamento del punto iniziale e finale. Una parabola è un oggetto 2.5D che si trova sempre...", 
"body" : "codice G : G6 Funzione : Il comando interpola una parabola definita dalle coordinate del punto finale X\/Y\/Z e del vertice I\/J. Il vertice è il punto in cui la tangente dell'elemento è parallela alla linea di collegamento del punto iniziale e finale. Una parabola è un oggetto 2.5D che si trova sempre nel piano X\/Y. Le parabole su altri piani non sono supportate. Sintassi G6 X Y Z I J A B C P Q U V W F E H L\/O D S Parola in codice G Descrizione X Y Z Posizioni target degli assi cartesiani I J Vertice della parabola A B C P Q U V W Posizioni di destinazione degli assi aggiuntivi F E Velocità del percorso, accelerazione\/decelerazione del percorso H L\/O funzione H D Raggio utensile S Profilo S Esempio N010 G00 X100 Y200 Z0 F100\nN020 G98\nN030 G06 X-100 Y200 Z00 I0 J0 " }, 
{ "title" : "Posizionamento ", 
"url" : "_sm_cnc_din66025_positioning.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Posizionamento ", 
"snippet" : "codice G : G0 , G92 Funzione : Questi comandi posizionano l'utensile. G0 comanda un posizionamento rapido su una retta fino alla posizione definita (normalmente senza intervento dell'utensile). G92 imposta immediatamente la posizione. Il risultato è che viene eseguito un salto anche sugli assi. Se S...", 
"body" : "codice G : G0 , G92 Funzione : Questi comandi posizionano l'utensile. G0 comanda un posizionamento rapido su una retta fino alla posizione definita (normalmente senza intervento dell'utensile). G92 imposta immediatamente la posizione. Il risultato è che viene eseguito un salto anche sugli assi. Se SMC_ControlAxisByPos.bAvoidGaps:=TRUE è impostato, quindi non viene eseguito un salto. Invece, tutti gli assi vengono spostati individualmente fino alla posizione target sulla distanza più breve. G92 può essere inserito all'inizio del percorso per impostare la In una serie di comandi G92, l'ultimo viene eseguito per primo. I precedenti vengono saltati. Se viene inserito un blocco G1 con coordinate identiche, il salto viene eseguito per un ciclo. Questo è un vantaggio se il percorso tra le posizioni dei comandi di salto non è importante, ma la posizione specificata deve essere percorsa il più velocemente possibile. Il SMC_ControlAxisByPos* i blocchi funzione rilevano un salto ai valori specificati, mettono in pausa l'interpolatore e interpolano ciascun asse singolarmente il più velocemente possibile. Due posizioni identiche consecutive determinano sempre un arresto del movimento in questa posizione. La fermata si verifica anche quando il percorso successivo si collega stabilmente e potrebbe essere percorso senza fermarsi. Per ulteriori informazioni, vedere la documentazione della libreria su Direct Axis Control Sintassi G0 X Y Z A B C P Q U V W F FF E EF H L\/O S\nG92 X Y Z A B C P Q U V W H L\/O Parola in codice G Descrizione X Y Z Posizioni target degli assi cartesiani A B C P Q U V W Posizioni di destinazione degli assi aggiuntivi E Accelerazione\/decelerazione del percorso EF Accelerazione\/decelerazione del percorso solo per il movimento G0. Se è impostato EF <> 0, allora il valore che è definito in E non viene preso in considerazione per i movimenti G0. F Velocità del percorso FF Velocità che viene utilizzata solo per i movimenti G0. Se è impostato FF <> 0, allora il valore che è definito in F non viene preso in considerazione per i movimenti G0. H L\/O funzione H S Profilo S Rappresentazione grafica Nell'editor grafico, i comandi G0 sono rappresentati da una linea verde. I comandi G92 non sono rappresentati direttamente. Spostano semplicemente il punto di partenza dell'elemento successivo. I comandi di posizionamento possono essere inseriti solo nell'editor di testo del CNC o nell'editor tabulare. Possono essere spostati nell'editor grafico. Esempi Posizionamento con interpolazione lineare con avanzamento definito N0 G92 X10 Y10 Sets the start position at 10\/10\nN10 G1 X20 F10 Linear interpolation to 20\/10 with feed 10\nN20 G0 Y20 F100 Linear positioning to 20\/20 with feed 100 Diverse modalità di posizionamento N0 G92 X100 Y100 F100 Sets the position at 100\/100\nN10 G1 X100 Y100 Saves the output of this position for one cycle\nN20 G92 X50 Y100 Sets the position suddenly to 50\/100 Posizionamento con velocità vettoriale definita N1 G0 X1000 Y0 FF1000 EF10000 EF-10000 Positioning with velocity 1000\nN2 G1 Y100 F100 E100 E-100 Interpolating positioning with velocity 100\nN3 G0 X0 Y0 Positioning with velocity 1000\nN4 G0 X1000 FF0 EF0 Positioning with velocity 100 because FF and FE are reset; thus the values in F and E are used. " }, 
{ "title" : "Spline ", 
"url" : "_sm_cnc_din66025_spline.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Spline ", 
"snippet" : "codice G : G5 , G10 Funzione : Il comando interpola l'elemento di traiettoria con una spline in modo che le transizioni dall'elemento di traiettoria precedente e all'elemento di traiettoria successivo si uniscano l'una nell'altra senza interruzioni. Allo stesso tempo, il segmento della spline dal si...", 
"body" : "codice G : G5 , G10 Funzione : Il comando interpola l'elemento di traiettoria con una spline in modo che le transizioni dall'elemento di traiettoria precedente e all'elemento di traiettoria successivo si uniscano l'una nell'altra senza interruzioni. Allo stesso tempo, il segmento della spline dal sistema viene calcolato in modo che la tangente finale dell'elemento del percorso precedente coincida con la tangente iniziale della spline. Allo stesso modo, la tangente finale della spline concorda con l'elemento del percorso successivo. Funzione : Il comando crea un segmento spline per la posizione data. I passaggi dall'elemento del percorso precedente a quello successivo sono continuamente in posizione e tangenti. Sintassi G5 X Y Z A B C P Q U V W F E H L\/O D S\nG10 X Y Z A B C P Q U V W F E H L\/O D S Parola in codice G Descrizione X Y Z Posizioni target degli assi cartesiani A B C P Q U V W Posizioni di destinazione degli assi aggiuntivi F E Velocità del percorso, accelerazione\/decelerazione del percorso H L\/O Punto di commutazione D Raggio utensile S Profilo S Più segmenti spline consecutivi sono collegati come segue: Inizia tangente Se esiste un elemento del percorso con operazione utensile (esempio: G1, G2, G3, G8, G9), la tangente finale dell'elemento del percorso viene utilizzata come tangente iniziale per la spline. Se non è disponibile alcun elemento del percorso con l'operazione utensile (ad es. G0, G92, M), la linea di collegamento tra il punto iniziale e il primo punto spline viene utilizzata come tangente iniziale. Tangente al centro della spline I punti adiacenti sono collegati. La tangente del punto è parallela a questa linea di collegamento (linea verde). tangente finale Se esiste un elemento del percorso con operazione utensile (esempio: G1, G2, G3, G8, G9), la tangente iniziale dell'elemento del percorso viene utilizzata come tangente finale per la spline. Se nessun elemento del percorso è disponibile con l'operazione utensile (ad esempio, G0, G92, M), la linea di collegamento tra il punto finale e il primo punto spline viene utilizzata come tangente finale. Esempi Profilo scala con scanalature arrotondate N0 G0 X0 Y0 Z0 F100 (Startposition)\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40 Profilo arrotondato con doppia nervatura N0 G0 X0 Y0 F100 (Startposition)\nN5 G1 X5 Y0\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN21 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40\nN45 G1 X0 Y40 Il punto spline per X20 Y20 esiste due volte. In questo modo la spline viene interrotta e riavviata. Questo è determinato dal metodo di definizione della tangente a questo punto. I punti iniziale e finale sono definiti dalle tangenti iniziali del segmento di linea precedente e successivo. " }, 
{ "title" : "Pre-elaborazione ", 
"url" : "_sm_cnc_din66025_preprocessor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Pre-elaborazione ", 
"snippet" : "codice G : G40, G41, G42, G43, G50, G51, G52, G60, G61, G70, G71 Funzione : I comandi attivano moduli di pre-elaborazione, come SMC_SmoothPath , SMC_RoundPath , SMC_AvoidLoop , SMC_ToolCorr , SMC_ToolLengthCorr , e SMC_ToolRadiusCorr . Se la Mostra percorso preelaborato l'opzione è selezionata, il p...", 
"body" : "codice G : G40, G41, G42, G43, G50, G51, G52, G60, G61, G70, G71 Funzione : I comandi attivano moduli di pre-elaborazione, come SMC_SmoothPath , SMC_RoundPath , SMC_AvoidLoop , SMC_ToolCorr , SMC_ToolLengthCorr , e SMC_ToolRadiusCorr . Se la Mostra percorso preelaborato l'opzione è selezionata, il percorso modificato è visibile nell'editor grafico. Sintassi G40\nG41 D\nG42 D\nG50\nG51 D\nG52 D\nG60\nG61 Parola in codice G Descrizione D Raggio utensile o raggio di sovrapposizione per G51\/G52 . Per le versioni precedenti alla 4.18.0.0: L'arrotondamento\/smussamento dell'angolo ( G51\/G52 ) e correzione del raggio dell'utensile ( G41\/G42 ) possono influenzarsi a vicenda perché entrambi i preprocessi interpretano ogni parola D nel codice G. Ad esempio, se una correzione del raggio dell'utensile con radius=1 è attiva quando un arrotondamento angolare inizia con D=5, di conseguenza la correzione del raggio dell'utensile utilizza anche un raggio Per la versione 4.18.0.0 e successive: arrotondamento\/smussamento dell'angolo ( G51\/G52 ) e correzione del raggio dell'utensile ( G41\/G42 ) possono essere utilizzati contemporaneamente senza influire l'uno sull'altro. A tale scopo si applica il seguente comportamento. Per la correzione del raggio dell'utensile ( G41\/G42 ): Per impostazione predefinita, il raggio «Strumento» utilizzato da SMC_ToolRadiusCorr è 0. Se dopo le parole G viene specificata una parola D G41\/G42 , quindi il raggio dello «Strumento» viene regolato e preso in considerazione dai blocchi funzionali. Quando non viene specificato alcun valore, viene utilizzato il raggio «Strumento» attualmente impostato Per arrotondamento\/smussatura degli angoli ( G51\/G52 ): Per impostazione predefinita, il raggio 'Smooth' utilizzato da SMC_Round\/SmoothPath è 0. Se viene specificata una parola D dopo una parola G (eccetto G36\/G37\/G40\/G41\/G42 ) o da solo (ad esempio, N00 D5 ), quindi ciò influisce sul raggio «Smooth» corrente e viene preso in considerazione dal SMC_Round\/SmoothPath blocchi funzionali. Comandi per la correzione dell'utensile Codice G Descrizione G40 Compensazione fine raggio utensile G41 Inizio della compensazione raggio utensile a sinistra del pezzo G42 Inizio della compensazione raggio utensile a destra del pezzo G43 Inizio della compensazione della lunghezza dell'utensile. Il correttore utensile da correggere è specificato con i parametri I, J K (per X, Y, Z ). La correzione della lunghezza utensile viene disattivata impostando i parametri a zero. Dopo l'attivazione o la disattivazione, viene eseguita la rampa in entrata o in uscita. Per maggiori dettagli, vedere: SMC_ToolLengthCorr Nota: la lunghezza dell'utensile non deve cambiare durante una compensazione raggio utensile attiva perché può interrompere il percorso. La correzione della lunghezza utensile (G43) funziona solo nel decoder online (non nell'editor CNC). Comandi per l'arrotondamento e l'arrotondamento dell'angolo Codice G Descrizione G50 Arrotondamento e levigatura di fine angolo G51 Inizio del livellamento dell'angolo mediante SMC_SmoothPath G52 Inizio dell'arrotondamento dell'angolo mediante SMC_RoundPath G70 Fine del livellamento degli assi aggiuntivi mediante SMC_SmoothAddAxes G71 Inizio livellamento assi aggiuntivi mediante SMC_SmoothAddAxes Comandi per la soppressione del loop Codice G Descrizione G60 Fine della funzione per la soppressione del loop G61 Inizio della funzione per la soppressione del loop tramite SMC_AvoidLoop Esempio: livellamento dell'angolo N0 G51 D10 F100\nN10 G01 X$g_x$ Y0 F50 E30 E-30\nN20 G01 X0 Y$g_y$\nN30 G01 X0 Y0\nN40 G50 " }, 
{ "title" : "Assi spline aggiuntivi A, B, C ", 
"url" : "_sm_cnc_din66025_additional_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Assi spline aggiuntivi A, B, C ", 
"snippet" : "Parola in codice G : A , B , C Funzione : Uso A , B , e C per definire le posizioni target per gli assi spline aggiuntivi. Questi assi sono simili a P , Q , U , V , e W . P , Q , U , e V sono interpolati linearmente, A , B , e C sono interpolati con un polinomio di terzo grado. Usando A , B , o C es...", 
"body" : "Parola in codice G : A , B , C Funzione : Uso A , B , e C per definire le posizioni target per gli assi spline aggiuntivi. Questi assi sono simili a P , Q , U , V , e W . P , Q , U , e V sono interpolati linearmente, A , B , e C sono interpolati con un polinomio di terzo grado. Usando A , B , o C esclude l'uso degli assi aggiuntivi U , V , e W perché U , V , e W definire il gradiente. Gli assi A , B , o C può essere selezionato con i bit 3, 4 o 5 in wAxis ingresso di SMC_Limit Dynamics o wAddAxis di SMC_CheckForLimits . Le SMC_SmoothPath , SMC_SmoothMerge , Spline SMC_SmoothB , e SMC_Ricalcola le pendenze ABC blocchi funzionali determinano automaticamente la pendenza degli assi aggiuntivi. Ciò significa che la definizione di U , V , o W non è necessario Esempio 1 Codice G N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X100 A100 P100 L'asse addizionale lineare P viene interpolato linearmente alla traiettoria percorsa. Di conseguenza, il suo profilo temporale restituisce quello della velocità del percorso. L'asse spline aggiuntivo A viene interpolato come funzione polinomiale. Esempio 2 L'utilizzo della funzione spline è necessario, soprattutto se si utilizza un percorso con transizioni tangenti costanti, che l'interpolatore non deve decelerare alla velocità 0: Codice G N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X50 A40 P40\nN30 G1 X100 A100 P100 Nel caso lineare, si vede un salto nella velocità, perché 40 unità dell'asse aggiuntivo viaggiano su 50 unità di percorso nella prima parte e 60 unità dell'asse aggiuntivo viaggiano su 50 unità di percorso nella seconda parte. Poiché la velocità del percorso definisce (XYZ) solo dopo lo spazio cartesiano del percorso, una velocità costante in X provoca un salto di velocità in P: L'asse della spline mostra il seguente profilo: Esempio 3 La pendenza degli assi A, B e C nella posizione finale può essere definita dalla parola U, V e W. L'unità della pendenza è l'unità di percorso dell'asse aggiuntivo per unità di percorso nello spazio. Codice G N10 G0 X0 A0 F10 E30 E-30\nN20 G1 X100 A100 U1.5\nN30 G1 X200 A200 U0 La pendenza programmata dall'utente (U=2) dell'asse A si applica perché questo programma contiene una transizione continua tra N20 e N30 . Pertanto, per X=100 la posizione dell'asse A aumenta due volte più velocemente della lunghezza del percorso " }, 
{ "title" : "Smussamento del movimento dell'asse aggiuntivo utilizzando più oggetti ", 
"url" : "_sm_cnc_din66025_smooth_additional_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Smussamento del movimento dell'asse aggiuntivo utilizzando più oggetti ", 
"snippet" : "codice G : G70 , G71 Funzione : G71 inizia e G70 termina il livellamento del movimento sull'asse aggiuntivo che è dato in L e viaggia su più oggetti. Sintassi G70 L4 G71 L4 Parola in codice G Asse aggiuntivo L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W...", 
"body" : "codice G : G70 , G71 Funzione : G71 inizia e G70 termina il livellamento del movimento sull'asse aggiuntivo che è dato in L e viaggia su più oggetti. Sintassi G70 L4\nG71 L4 Parola in codice G Asse aggiuntivo L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W " }, 
{ "title" : "Configurazione di singoli assi aggiuntivi come assi modulo (PA\/PB\/…) ", 
"url" : "_sm_cnc_din66025_define_additional_axis_modulo.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Configurazione di singoli assi aggiuntivi come assi modulo (PA\/PB\/…) ", 
"snippet" : "Funzione: Per gli assi A, B, C, P, Q, U, V e W è possibile specificare un periodo modulo impostando le parole PA , PB , PC , ecc. Per impostazione predefinita, PA , PB , ecc. hanno il valore 0, il che significa che l'asse è lineare. Se un asse aggiuntivo è configurato come asse modulo, la distanza p...", 
"body" : "Funzione: Per gli assi A, B, C, P, Q, U, V e W è possibile specificare un periodo modulo impostando le parole PA , PB , PC , ecc. Per impostazione predefinita, PA , PB , ecc. hanno il valore 0, il che significa che l'asse è lineare. Se un asse aggiuntivo è configurato come asse modulo, la distanza più breve viene sempre interpolata dalla posizione di partenza alla posizione di destinazione. Per un periodo modulo di 360, il viaggio è dalla posizione iniziale 270 alla posizione target 45 come segue: nella direzione positiva (oltre 360) di 135 unità in tutto e non nella direzione negativa di 225 unità, come per una linea del tempo lineare . L'uscita di posizione dell'interpolatore può essere al di fuori dell'intervallo [0..limite periodo[. (Ad esempio, 400 invece di 40 per un periodo modulo di 360.) La posizione viene spostata nell'intervallo modulo seguendo le POU, come SMC_ControlAxisByPos , o SMC_FollowPosition . Esempio Controllo rotativo di un asse in modalità modulo Nel blocco 30 l'asse A viene spostato in senso positivo di 90° da 270° a 360°=0°. N10 PA360 (A axis has a period of 360 degree)\nN20 G92 A270 (Set the position of A axis to 270)\nN30 G1 A0 " }, 
{ "title" : "Utilizzo delle variabili ", 
"url" : "_sm_cnc_din66025_usage_of_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Utilizzo delle variabili ", 
"snippet" : "Sintassi $<Variablenname>$ Tipi di base IEC validi per variabili ed espressioni: INT , SINT , USINT , UINT , DINT , UDINT , BYTE , WORD , DWORD , REAL , e LREAL . Le eccezioni includono il parametro O per le funzioni M (che prevede una variabile di tipo SMC_M_PARAMETERS ) e G36\/G37 (dove sono consen...", 
"body" : "Sintassi $<Variablenname>$ Tipi di base IEC validi per variabili ed espressioni: INT , SINT , USINT , UINT , DINT , UDINT , BYTE , WORD , DWORD , REAL , e LREAL . Le eccezioni includono il parametro O per le funzioni M (che prevede una variabile di tipo SMC_M_PARAMETERS ) e G36\/G37 (dove sono consentite anche variabili stringa). È possibile definire variabili o espressioni per tutte le parole, eccetto N parole (numeri di blocco). Le espressioni e le variabili IEC vengono sostituite dai loro valori correnti solo nella POU del decodificatore online. Questo accade quando la linea viene decodificata, che è un po' di tempo prima che l'elemento venga elaborato nell'interpolatore. Il valore di una variabile in modalità offline viene modificato nel Valori offline delle variabili dialogo. Si apre la finestra di dialogo tramite il CNC → Imposta variabile comando o il Variabili pulsante nelle proprietà dell'oggetto CNC. Utilizzo di una variabile globale in modalità offline Dichiarare le variabili nell'elenco delle variabili globali. Utilizzare le variabili nell'editor CNC in almeno una posizione. Esegui il CNC → Imposta variabile comando. Il Valori offline delle variabili si apre la finestra di dialogo. Specificare i valori desiderati nella tabella. Esempio VAR_GLOBAL\n rVal_x1: REAL:=100;\n rVal_y1: REAL:=50;\nEND_VAR\n\n\/\/ CNC-Editor\nN0 G01 X$rVal_x1$ Y0 F50 E30 E-30\nN10 G01 X0 Y$rVal_y1$\nN20 G01 X0 Y0 Comportamento in modalità online Se il programma come variabile di programma con SMC_CNC_REF tradotto ed elaborato online dal modulo decoder, l'uso delle variabili funziona. Le variabili vengono sostituite nel momento in cui il decodificatore elabora la riga corrispondente. L'utilizzo di variabili nei programmi in codice G che vengono letti online richiede una preparazione aggiuntiva con SMC_VARLIST . Se il programma CNC come SMC_OUTQUEUE viene compilato, il meccanismo delle variabili non funziona perché il percorso viene quindi creato offline e trasferito all'applicazione come struttura dati immodificabile. In questo caso e per la visualizzazione in modalità offline, l'editor sostituisce la variabile con il suo valore offline. Per ulteriori informazioni, vedere: Strutture dati CNC e accesso globale" }, 
{ "title" : "Modifica dei valori delle variabili ", 
"url" : "_sm_cnc_din66025_change_variable_values.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Modifica dei valori delle variabili ", 
"snippet" : "codice G : G36 , G37 Funzione : I comandi cambiano il valore di una variabile. G36 scrive il valore specificato in una variabile. G37 incrementa la variabile del valore specificato. O$var$ definisce la variabile che viene modificata. D definisce il valore che è scritto per G36 o aggiunto per G37 . I...", 
"body" : "codice G : G36 , G37 Funzione : I comandi cambiano il valore di una variabile. G36 scrive il valore specificato in una variabile. G37 incrementa la variabile del valore specificato. O$var$ definisce la variabile che viene modificata. D definisce il valore che è scritto per G36 o aggiunto per G37 . Il comando viene utilizzato, ad esempio, per un contatore di loop necessario per i salti condizionali. Sintassi G36 O D\nG37 O D Parola di codice G per G36 Descrizione O Variabile scritta. O non è definito, quindi viene utilizzata una variabile di decodifica interna. Il valore predefinito di questa variabile interna -1 . La variabile interna può essere utilizzata nel Salto comando. D Nuovo valore variabile Parola di codice G per G37 O Variabile che viene incrementata. Se O non è definita, viene utilizzata una variabile di decodifica interna. D Incremento Esempio Programmazione del contatore (se il percorso viene elaborato online) Il g_i la variabile globale è impostata su 5. N1000 G36 O$g_i$ D5 Le linee 1010 e 1020 vengono percorse cinque volte. N1000 G36 O$g_i$ D5\nN1010 G1 X100 F100 E100 E-100\nN1020 G1 X0\nN1030 G37 O$g_i$ D-1\nN1040 G20 L1010 K$g_i$ Il meccanismo funziona solo se il percorso viene elaborato online, perché solo così è possibile utilizzare le variabili. Questo meccanismo non funziona nell'editor CNC. Programmazione del contatore per la modalità offline Per lavorare con l'editor offline, non specificare nessuna variabile tramite O . Quindi una variabile di decodifica implicita di tipo INT viene utilizzato. Tuttavia, è disponibile solo una variabile. Non è possibile programmare salti o loop nidificati. Utilizzo di variabili stringa Puoi usare una variabile stringa nella parola O nel codice G. Inoltre, a questa variabile può essere assegnato e inserito un valore di stringa tramite il comando G36 e G37 . Esempio N10 G36 O$strTest$ D'Name' Il strTest variabile ottiene il valore Nome. N20 G37 O$strTest$ D'=Test' Il valore =Test viene aggiunto alla variabile strTest . Se si utilizzano variabili stringa nel programma CNC e se il programma CNC (nel programma IEC) viene letto mediante il tasto SMC_ReadNCFile blocco funzione, quindi i buffer per le stringhe devono essere riservati nel programma IEC. Altrimenti, l'errore SMV_RNCF_NO_STRINGBUFFER si verifica. Il SMC_StringBuffer blocco funzione è disponibile per questo scopo. Ogni stringa del programma CNC richiede il proprio spazio nell'istanza del blocco funzione di SMC_StringBuffer , anche se la stessa stringa si verifica più volte. La seguente dichiarazione può bufferizzare 32 stringhe, ad esempio: sb: SMC_StringBuffer(uiBufferSize := 32); L'istanza del blocco funzione sb viene passato come puntatore al pStringBuffer ingresso del SMC_ReadNCFile esempio. " }, 
{ "title" : "sottoprogrammi ", 
"url" : "_sm_cnc_din66025_subprograms.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ sottoprogrammi ", 
"snippet" : "Funzione : Richiamo di un sottoprogramma Le attività ricorrenti, come la fresatura di tasche, la foratura e il cambio utensile, possono essere scambiate in sottoprogrammi in codice G e richiamate da lì. Durante una chiamata, i parametri possono essere passati al sottoprogramma. I tipi di dati BOOL ,...", 
"body" : "Funzione : Richiamo di un sottoprogramma Le attività ricorrenti, come la fresatura di tasche, la foratura e il cambio utensile, possono essere scambiate in sottoprogrammi in codice G e richiamate da lì. Durante una chiamata, i parametri possono essere passati al sottoprogramma. I tipi di dati BOOL , LREAL , e STRING sono consentiti a tale scopo. Se usi sottoprogrammi, allora devi usare i blocchi funzione SMC_ReadNCFile2 e SMC_NCInterpreter invece di SMC_ReadNCFile e SMC_NCDecoder . I sottoprogrammi funzionano solo nel decoder online (non nell'editor CNC). Ogni sottoprogramma è memorizzato in un file separato. Questi file vengono salvati in una o più sottodirectory del controller. Devono avere l'estensione del file .cnc . Il nome del file deve corrispondere al nome del sottoprogramma ed essere minuscolo. Esempio: nome del sottoprogramma \"Drill\" -> nome file drill.cnc . Si noti che il nome del file del sottoprogramma deve essere scritto in minuscolo. il POU SMC_ReadNCFile2 ha un ingresso aSubProgramDirs : ARRAY[0..4] OF STRING(174) . È possibile specificare fino a cinque sottodirectory oltre a questa. Vengono scansionati nell'ordine indicato. Se sono presenti sottoprogrammi con lo stesso nome in più directory, viene trovato il sottoprogramma con la directory con l'indice più basso nell'array. Il nome del sottoprogramma viene convertito in minuscolo. Esempio aSubProgramDirs = ['subprograms\/user', 'subprograms\/system', ''] Il sottoprogramma DrillA1 viene scansionato per primo nel file subprograms\/user\/drilla1.cnc . Se questo file non esiste, la ricerca continua in subprograms\/system\/drilla1.cnc . È possibile richiamare i sottoprogrammi indirettamente tramite una variabile (più precisamente tramite un'espressione di tipo STRING ). L'espressione (e quindi anche l'eventuale ricerca di variabili) viene valutata – generalmente nel caso di utilizzo di variabili nel codice G – al momento della preelaborazione quando l'interprete raggiunge la riga. In questo caso il controllo del tipo degli argomenti viene effettuato solo quando l'interprete ha raggiunto la linea e non già durante l'analisi, come nel caso delle chiamate statiche. I sottoprogrammi non possono essere creati offline nell'editor CNC. Profondità massima di annidamento delle chiamate ai sottoprogrammi Prima della versione 4.18.0.0: la profondità massima di annidamento delle chiamate ai sottoprogrammi è limitata a 14. Versione 4.18.0.0 e successive: la profondità di annidamento è ora limitata solo dalla memoria. Il valore massimo può essere modificato SMC_CNC_LIBPARAMS.MAX_SUBPROGRAM_NESTING_DEPTH . " }, 
{ "title" : "Sintassi per la chiamata ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ sottoprogrammi \/ Sintassi per la chiamata ", 
"snippet" : "I richiami di sottoprogrammi sono blocchi speciali nel codice G che consistono in un numero di blocco e solo in un richiamo. Non sono consentite parole aggiuntive. N<SentenceNo> <Name> <BracketOpen> <ActualParamList> <BracketClosed> N<SentenceNo> DYNCALL <BracketOpen> <SubNameExp> [, <ActualParamLis...", 
"body" : "I richiami di sottoprogrammi sono blocchi speciali nel codice G che consistono in un numero di blocco e solo in un richiamo. Non sono consentite parole aggiuntive. N<SentenceNo> <Name> <BracketOpen> <ActualParamList> <BracketClosed>\nN<SentenceNo> DYNCALL <BracketOpen> <SubNameExp> [, <ActualParamListNotEmpty] <BracketClosed>\n\n<SubNameExp> : An expression with exactly one value of type STRING\n<ActualParamList> ::= Empty | <ActualParamListNotEmpty>\n<ActualParamListNotEmpty> ::= <ActualParamValue> | <ActualParamValue>, <ActualParamListNotEmpty> <Name> Identificatore IEC valido con un minimo di 3 e un massimo di 80 caratteri. Deve corrispondere al nome del file (senza estensione) in cui è definito il sottoprogramma. Le lettere maiuscole o minuscole non sono importanti per i nomi dei sottoprogrammi. [a-zA-Z0-9_] sono consentiti. Le seguenti parole chiave non sono valide per i nomi: RETURN,\\\\ IF,\\\\ ELSE,\\\\ END_IF,\\\\ CASE,\\\\ END_CASE,\\\\ FOR,\\\\ END_FOR,\\\\ WHILE,\\\\ END_WHILE, REPEAT,\\\\ UNTIL,\\\\ END_REPEAT . <ActualParamList> Deve essere specificato esattamente lo stesso numero di valori dei parametri definiti dal sottoprogramma (vedere \"Sintassi per la dichiarazione\"). Il tipo di ogni valore di parametro deve concordare con la dichiarazione. <BracketOpen>\/<BracketClosed> Per motivi di compatibilità, le parentesi graffe vengono utilizzate al posto delle parentesi nelle impostazioni predefinite per SMC_ReadNCFile2 e chiamate e dichiarazioni di sottoprogrammi. Le parentesi sono valide nel codice G per i commenti. Il blocco funzione SMC_ReadNCFile2 ha una modalità ( bParenthesesAsComments input) dove le parentesi non sono commenti. Invece, i commenti su più righe vengono aperti con (* e chiuso con *) . In questa nuova modalità, è possibile utilizzare sia le parentesi graffe che le parentesi per le chiamate e le dichiarazioni di sottoprogrammi. <ActualParamValue> Variabile, letterale o qualsiasi espressione Esempio N10 SUB1()\nN20 DRILL(10.0)\nN30 SUB2(5, \"Text\", 2.5)\nN40 G36 O#SUBNAME D'DRILL' % Indirect call via local variable\nN40 DYNCALL(#SUBNAME, 2) % equivalent to N40 DRILL(2)\nN50 DYNCALL($SUBNAME$, 2, 4) % Indirect call via IEC variable " }, 
{ "title" : "Sintassi per la dichiarazione ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ sottoprogrammi \/ Sintassi per la dichiarazione ", 
"snippet" : "Un sottoprogramma deve essere salvato in un file separato. La prima riga (né vuota né riga di commento) deve contenere la dichiarazione del sottoprogramma. Si applica la seguente sintassi: SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT> <Inhalt Unterprogramm> END_SUBP...", 
"body" : "Un sottoprogramma deve essere salvato in un file separato. La prima riga (né vuota né riga di commento) deve contenere la dichiarazione del sottoprogramma. Si applica la seguente sintassi: SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT>\n<Inhalt Unterprogramm>\nEND_SUBPROGRAM\n\n<FormalParamList> ::= Empty | <FormalParamListNotEmpty>\n<FormalParamListNoEmpty> ::= <FormalParam> | <FormalParam> , <FormalParamListNotEmpty>\n<FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String with a maximum length of 255 bytes\n<RESTORE_OPT> ::= RESTORE_MODES <ParamName> La lunghezza del nome può essere un massimo di 80 caratteri (escluso il prefisso # ). RESTORE_MODES Se viene specificata questa parola chiave, vengono ripristinati i seguenti stati modali quando si torna al programma chiamante (impostato sul valore che aveva alla chiamata): Codice G attivo Modalità relativa\/assoluta (G90\/G91, G98\/G99) Piano circolare e modalità 2D\/3D Sistema di coordinate del decodificatore (incluso il ridimensionamento) Avanzamenti (assi traiettoria e aggiuntivi), velocità di traslazione rapida, accelerazioni e decelerazioni massime (assi traiettoria e aggiuntivi) Flag di feature e parametri generali (G38) Raggio utensile (parola D) Correzioni utensile (G43) Profilo S (parola S) I seguenti stati modali non vengono ripristinati: Posizione attuale del decoder\/interprete e stato attuale della spline cardinale La posizione include l'intera struttura SMC_POSINFO (ad esempio, X, Y, Z, l'orientamento e tutti gli assi aggiuntivi). Stato (on\/off) delle POU di preelaborazione del percorso (G40-G43, G50-G52, G60-G61, G70-G71) Impostazione modulo degli assi aggiuntivi (PA, PB, …) Nota: indipendentemente da questa parola chiave, le variabili di conteggio implicite (G36, G37) vengono ripristinate al ritorno dal sottoprogramma al programma chiamante. Esempi SUBPROGRAM SUB1() ; no formal parameters\nSUBPROGRAM DRILL(#depth : LREAL)\nSUBPROGRAM SUB2(#a : LREAL, #b : STRING, #c : LREAL)\nSUBPROGRAM SRM1() RESTORE_MODES " }, 
{ "title" : "Sintassi per il ritorno ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ sottoprogrammi \/ Sintassi per il ritorno ", 
"snippet" : "Il ritorno avviene sia alla fine del testo del sottoprogramma (prima del END_SUBPROGRAM ) o esplicitamente con la seguente sintassi: N<block number> RETURN ....", 
"body" : "Il ritorno avviene sia alla fine del testo del sottoprogramma (prima del END_SUBPROGRAM ) o esplicitamente con la seguente sintassi: N<block number> RETURN . " }, 
{ "title" : "Utilizzo dei parametri formali nel sottoprogramma ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_ba614a0b6544562fc0a864631e9ee966", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ sottoprogrammi \/ Utilizzo dei parametri formali nel sottoprogramma ", 
"snippet" : "I valori dei parametri formali sono accessibili nel sottoprogramma tramite #<ParamName> . Il numero di parametri formali è limitato a 21. Esempio SUBPROGRAM SUB(#Param1 : LREAL) N10 G01 X#Param1...", 
"body" : "I valori dei parametri formali sono accessibili nel sottoprogramma tramite #<ParamName> . Il numero di parametri formali è limitato a 21. Esempio SUBPROGRAM SUB(#Param1 : LREAL)\nN10 G01 X#Param1 " }, 
{ "title" : "Visualizzazione dello stack di chiamate ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ sottoprogrammi \/ Visualizzazione dello stack di chiamate ", 
"snippet" : "L'interprete ( SMC_NCInterpreter ) ha un output che contiene i primi 10 programmi\/sottoprogrammi attivi: aActivePrograms : ARRAY[0..9] OF STRING . La prima voce ( aActivePrograms[0] ) è il programma\/sottoprogramma attualmente interpretato. La seconda voce ( aActivePrograms[1] ) è il programma\/sottop...", 
"body" : "L'interprete ( SMC_NCInterpreter ) ha un output che contiene i primi 10 programmi\/sottoprogrammi attivi: aActivePrograms : ARRAY[0..9] OF STRING . La prima voce ( aActivePrograms[0] ) è il programma\/sottoprogramma attualmente interpretato. La seconda voce ( aActivePrograms[1] ) è il programma\/sottoprogramma chiamante e così via. Se non esiste un programma chiamante, la stringa corrispondente è vuota. Lo stack di chiamate può essere visualizzato anche durante l'interpolazione. Il SMC_DisplayNCCallstack La POU mostra i programmi\/sottoprogrammi attivi nello stesso formato dell'interprete, solo in un secondo momento (cioè quando viene eseguito il movimento). In tal modo, l'output dell'interprete CallstackInfo (SMC_NCCallstackInfo) e l'interpolatore gli viene passato come VAR_IN_OUT variabili. SMC_NCCallstackInfo memorizza tutte le modifiche allo stack di chiamate, incluso il corrispondente SMC_GeoInfo numero oggetto, in un buffer circolare. Al momento, questo limita a 128 il numero di modifiche dello stack di chiamate memorizzabili tra il tempo di interpretazione e il tempo di interpolazione. Poiché il buffer circolare non soddisfa i criteri di multitasking, SMC_DisplayNCCallstack deve essere chiamato dal compito di interprete. Il programma di esempio Esempio CNC 07: Uso di espressioni e sottoprogrammimostra un esempio di visualizzazione dello stack di chiamate al momento dell'interpolazione. " }, 
{ "title" : "espressioni ", 
"url" : "_sm_cnc_din66025_expressions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ espressioni ", 
"snippet" : "Funzione : Nella versione 4.4.0.0 e successive, è possibile utilizzare espressioni matematiche, booleane e stringa. Il SMC_ReadNCFile2 e SMC_NCInterpreter blocchi funzione devono essere usati per questo (invece di SMC_ReadNCFile e SMC_NCDecoder ). Le espressioni funzionano solo nel decoder online (n...", 
"body" : "Funzione : Nella versione 4.4.0.0 e successive, è possibile utilizzare espressioni matematiche, booleane e stringa. Il SMC_ReadNCFile2 e SMC_NCInterpreter blocchi funzione devono essere usati per questo (invece di SMC_ReadNCFile e SMC_NCDecoder ). Le espressioni funzionano solo nel decoder online (non nell'editor CNC). In linea di principio, le espressioni possono essere utilizzate nel codice G in due posizioni: Come valori di parole G (una parola G è composta da un indirizzo e un valore, ad esempio \"G1\") Come parametri di trasferimento per chiamate di sottoprogrammi " }, 
{ "title" : "Sintassi – Generale ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_42546a9cc18a4349c0a86463750fefea", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ espressioni \/ Sintassi – Generale ", 
"snippet" : "Un'espressione può essere costituita dai seguenti elementi: Letterali numerici e stringa Variabili globali e locali Operatori e funzioni infissi Virgole e parentesi Allo stesso modo, le parentesi (se non utilizzate per identificare i commenti) e le parentesi graffe possono essere utilizzate per la s...", 
"body" : "Un'espressione può essere costituita dai seguenti elementi: Letterali numerici e stringa Variabili globali e locali Operatori e funzioni infissi Virgole e parentesi Allo stesso modo, le parentesi (se non utilizzate per identificare i commenti) e le parentesi graffe possono essere utilizzate per la strutturazione delle espressioni. Ciò significa che l'espressione (1 + 2} * 3 è permesso. Il blocco funzione SMC_ReadNCFile2 ha una nuova modalità ( bParenthesesAsComments input) dove le parentesi non sono commenti. Invece, i commenti su più righe vengono aperti e chiusi rispettivamente con \"(*\" e \"*)\". In questa nuova modalità, è possibile utilizzare sia le parentesi graffe che le parentesi per le espressioni. Uno spazio dopo l'indirizzo G è richiesto solo se SMC_ReadNCFile2 non lo riconoscerebbe come token indipendente (esempio: X abs{-2} invece di Xabs{-2}. ). A differenza di ST, le funzioni a posizione singola non devono necessariamente essere chiamate tra parentesi (esempio: sin 3 ). Durante l'analisi, a ciascuna espressione parziale viene assegnato uno dei tre tipi: BOOL, LREAL o STRING. Di conseguenza, ogni operatore Infix e ogni funzione si aspettano una sequenza specifica di tipi di argomenti per i quali la non conformità (tipo errato, troppi pochi o troppi argomenti) restituisce un errore. Restrizioni: I numeri di blocco devono essere letterali numerici. Per motivi strettamente tecnici, i marcatori di salto ( x in L!x ) non deve contenere variabili locali. Per ulteriori informazioni, vedere: Salto, Utilizzo delle variabili" }, 
{ "title" : "Esempi ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_5b6258e8c18a4349c0a864632640e903", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ espressioni \/ Esempi ", 
"snippet" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}} N02 G1 X$var$ + sin{pi + 3 * #locvar} N03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}}...", 
"body" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}}\nN02 G1 X$var$ + sin{pi + 3 * #locvar}\nN03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}} " }, 
{ "title" : "Operatori e funzioni supportati ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_da2d0ac5c18a4349c0a864637cb30dc8", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ espressioni \/ Operatori e funzioni supportati ", 
"snippet" : "Operatori infissi Carattere Tipo argomenti Precedenza MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , LREAL 10...", 
"body" : "Operatori infissi Carattere Tipo argomenti Precedenza MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , LREAL 10 <> BOOL STRING , STRING 10 > BOOL LREAL , LREAL 10 < BOOL LREAL , LREAL 10 >= BOOL LREAL , LREAL 10 <= BOOL LREAL , LREAL 10 AND BOOL BOOL , BOOL 6 XOR BOOL BOOL , BOOL 5 OR BOOL BOOL , BOOL 4 Funzioni Carattere Tipo argomenti - LREAL LREAL ABS LREAL LREAL MAX LREAL LREAL , LREAL MIN LREAL LREAL , LREAL NOT BOOL BOOL TRUE BOOL FALSE BOOL SIN LREAL LREAL COS LREAL LREAL TAN LREAL LREAL ASIN LREAL LREAL ACOS LREAL LREAL ATAN LREAL LREAL EXP LREAL LREAL LN LREAL LREAL SQRT LREAL LREAL EXPT LREAL LREAL , LREAL FLOOR LREAL LREAL CEIL LREAL LREAL PI LREAL LEN LREAL STRING CONCAT STRING STRING , STRING " }, 
{ "title" : "Definire le proprie funzioni ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_fca8916cc18a4349c0a8646350db2bd3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ espressioni \/ Definire le proprie funzioni ", 
"snippet" : "È possibile aggiungere le proprie funzioni o sovrascrivere un'implementazione esistente. (Quando si analizza il codice G, le funzioni vengono cercate prima nelle funzioni utente.) L'interfaccia SMC_NC_IFunction deve essere implementata e un'istanza globale della POU corrispondente deve essere trasfe...", 
"body" : "È possibile aggiungere le proprie funzioni o sovrascrivere un'implementazione esistente. (Quando si analizza il codice G, le funzioni vengono cercate prima nelle funzioni utente.) L'interfaccia SMC_NC_IFunction deve essere implementata e un'istanza globale della POU corrispondente deve essere trasferita a SMC_ReadNCFile2 o SMC_ReadNCFromStream tramite la struttura SMC_NC_GFunctionTable . L'enumerazione SMC_GVar_Type viene utilizzato per il tipo restituito e i tipi di argomento. La voce ivi contenuta T_OTHER può essere utilizzato come segnaposto per un tipo. Durante l'analisi, il sistema verifica che tutti gli argomenti che corrispondono a a T_OTHER nella firma hanno lo stesso tipo. Il tipo non importa. Per ulteriori informazioni, vedere: Funzioni G-Code specifiche per l'utente" }, 
{ "title" : "Gestione degli errori ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ espressioni \/ Gestione degli errori ", 
"snippet" : "Quando possibile, la posizione esatta del token difettoso e la sua lunghezza vengono emesse negli errori di sintassi. La posizione dell'errore è elencata in SMC_ReadNCFile2.errorPos ....", 
"body" : "Quando possibile, la posizione esatta del token difettoso e la sua lunghezza vengono emesse negli errori di sintassi. La posizione dell'errore è elencata in SMC_ReadNCFile2.errorPos . " }, 
{ "title" : "Variabili locali ", 
"url" : "_sm_cnc_din66025_local_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Variabili locali ", 
"snippet" : "Ogni file di codice G può dichiarare variabili locali. Per i programmi principali, le dichiarazioni devono essere inserite all'inizio; per i sottoprogrammi, subito dopo la dichiarazione del sottoprogramma. Le variabili locali sono visibili solo nel programma o sottoprogramma in cui sono dichiarate. ...", 
"body" : "Ogni file di codice G può dichiarare variabili locali. Per i programmi principali, le dichiarazioni devono essere inserite all'inizio; per i sottoprogrammi, subito dopo la dichiarazione del sottoprogramma. Le variabili locali sono visibili solo nel programma o sottoprogramma in cui sono dichiarate. (Nessun ambito dinamico) Le variabili locali funzionano solo nel decoder online (non nell'editor CNC). Numero di variabili locali Prima della versione 4.18.0.0: il numero di variabili locali è limitato a 21 per sottoprogramma e nel programma principale. Versione 4.18.0.0 e successive: il numero di variabili locali è limitato solo dalla memoria. Il valore massimo può essere modificato utilizzando SMC_CNC_LIBPARAMS.MAX_SUBPROGRAM_PARAMS . Per ulteriori informazioni, vedere: Parametri della libreria Sintassi per la dichiarazione La sintassi è simile alla sintassi utilizzata per dichiarare i parametri del sottoprogramma. È possibile dichiarare una variabile per blocco. Il blocco non inizia con una N-word. La variabile può essere fornita con un valore iniziale opzionale quando viene dichiarata. In caso contrario, viene assegnato un valore predefinito a seconda del tipo di dati ( LREAL: 0, BOOL: FALSE, STRING: ‘‘ ). Sintassi della dichiarazione: LET <FormalParam> [:= <InitialValue>] . <FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String mit maximaler Länge von 255 Bytes <InitialValue> : Espressione che ha un valore e un tipo che corrisponde alla variabile. L'espressione può utilizzare anche variabili locali (e nei sottoprogrammi i parametri del sottoprogramma), ma solo quelle dichiarate sopra nel codice del programma. Esempi • LET #x : LREAL (* Variable #x, Typ LREAL, Initialwert 0 *)\n• LET #y : LREAL := #x + 1 (* Variable #y, Typ LREAL, Initialwert #x+1 = 1 *)\n• LET #b : BOOL := #x >= #y (* Variable #b, Typ BOOL, Initialwert FALSE *) Come con i parametri del sottoprogramma, le variabili locali non fanno distinzione tra maiuscole e minuscole. (Entrambi #x e #X indicare la stessa variabile.) I nomi di tutte le variabili locali dichiarate in un programma\/sottoprogramma devono essere diversi. Devono differire dai nomi dei parametri formali del sottoprogramma. Le variabili locali possono essere utilizzate in codice G come parametri di sottoprogrammi. Esempi • N10 G01 X#x Y#y\n• N20 G20 L10 K#b " }, 
{ "title" : "Funzione di rilevamento (distanza residua chiara) ", 
"url" : "_sm_probe_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Linguaggio CNC in DIN 66025 \/ Funzione di rilevamento (distanza residua chiara) ", 
"snippet" : "Codice G : G31 \/Qualsiasi comando di movimento insieme al PROBE parola Funzione : La funzione di rilevamento (distanza residua chiara) è un movimento speciale che viene interrotto non appena viene emesso un segnale ( PROBE ) è in sospeso. Il resto del codice G continua dalla posizione in cui il movi...", 
"body" : "Codice G : G31 \/Qualsiasi comando di movimento insieme al PROBE parola Funzione : La funzione di rilevamento (distanza residua chiara) è un movimento speciale che viene interrotto non appena viene emesso un segnale ( PROBE ) è in sospeso. Il resto del codice G continua dalla posizione in cui il movimento è stato interrotto, non dalla posizione finale programmata del La funzione di rilevamento (distanza residua chiara) causa un arresto implicito della decodifica prima del movimento successivo (simile a G75 ). La decodifica del codice G continuerà solo dopo la ricezione del segnale. I casi d'uso tipici includono la misurazione della lunghezza di un utensile (spostamento in un interruttore) o lo spostamento su un blocco La funzione di rilevamento (distanza residua chiara) può essere attivata per qualsiasi numero di movimenti, come linee rette e archi circolari. Per questo, solo PROBE la parola deve essere aggiunta al codice G. G31 è un movimento lineare con la funzione di rilevamento (distanza residua chiara), con il numero di sonda predefinito 1. Questo valore predefinito può essere sovrascritto con Ogni movimento può avere al massimo uno PROBE parola. Le funzioni H (trigger) non sono supportate per i movimenti con la funzione di rilevamento (distanza residua chiara). La preelaborazione del percorso come la levigatura degli angoli, la correzione del raggio dell'utensile, ecc. non è supportata per i movimenti con la funzione di rilevamento (distanza residua chiara). Il numero della sonda deve essere positivo. Se durante l'elaborazione di un movimento con la funzione di rilevamento non viene ricevuto alcun segnale dalla sonda (distanza residua chiara), l'interpolazione si interrompe alla fine del movimento con un errore. L'interpolatore deve prima essere fermato quando viene ricevuto un segnale della sonda. Uno degli ingressi bSlow_Stop , bQuick_Stop , o bEmergency_Stop può essere utilizzato per questo scopo. Non appena l'interpolazione si è interrotta, è possibile riconoscere la funzione di rilevamento (chiara distanza residua). A tale scopo, viene applicato un bordo ascendente al SMC_Interpolator.bAcknProbe ingresso. Sintassi G31 X Y Z A B C P Q U V W F E S PROBE\nG1\/2\/3\/8\/9 X Y Z A B C P Q U V W F E S PROBE Codice G Word Descrizione X Y Z Posizioni target degli assi cartesiani A B C P Q U V W Posizioni target degli assi aggiuntivi F E Velocità del percorso, accelerazione\/decelerazione del percorso S Profilo S PROBE Il numero della sonda deve essere positivo. Esempi Movimento lineare Movimento lineare con funzione di rilevamento (distanza residua chiara) e sonda predefinita numero 1 N010 G31 X100 Movimento circolare Movimento circolare con funzione di rilevamento (distanza residua chiara) e sonda numero 7 N010 G02 X100 R50 PROBE 7 Per ulteriori informazioni, vedere l'esempio: Esempio CNC 16: funzione di sondaggio (distanza residua chiara) (G31)" }, 
{ "title" : "Preelaborazione del percorso e dimensioni della coda ", 
"url" : "_sm_preprocessing_queuesize.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Preelaborazione del percorso e dimensioni della coda ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Pipeline dell'elaborazione del codice G ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103127844091", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Preelaborazione del percorso e dimensioni della coda \/ Pipeline dell'elaborazione del codice G ", 
"snippet" : "Quando il codice G viene letto da un file, spesso non è pratico leggere ed elaborare l'intero file prima di iniziare la lavorazione. Per alcune applicazioni, i file G-code possono avere alcune centinaia di migliaia o addirittura milioni di righe. Leggere tutto in una volta richiederebbe molto tempo ...", 
"body" : "Quando il codice G viene letto da un file, spesso non è pratico leggere ed elaborare l'intero file prima di iniziare la lavorazione. Per alcune applicazioni, i file G-code possono avere alcune centinaia di migliaia o addirittura milioni di righe. Leggere tutto in una volta richiederebbe molto tempo e anche molta memoria Invece, il codice G viene letto riga per riga, ma solo una piccola parte (poche centinaia di righe) viene conservata in memoria in ogni momento. Questa parte viene mantenuta in code, cioè in strutture dati che funzionano secondo il principio «first in, first out»: il blocco funzionale che produce aggiunge elementi alla coda. Il blocco funzionale che consuma legge e rimuove gli elementi nello stesso ordine in cui sono stati inseriti Il diagramma mostra il flusso del codice G attraverso il sistema. Innanzitutto, il codice G viene letto da un file, quindi convertito in cosiddetti elementi GeoInfo dall'interprete. Questi elementi vengono elaborati dai blocchi funzionali di preelaborazione del percorso e infine interpolati. Le parti contrassegnate da «GeoInfo» rappresentano le code. Se più di un preprocessore di percorso SMC_SmoothPath , SMC_ToolRadiusCorr , oppure SMC_AvoidLoop ) viene utilizzato, quindi sono anche collegati da code. " }, 
{ "title" : "Dimensioni della coda consigliate ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128036484", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Preelaborazione del percorso e dimensioni della coda \/ Dimensioni della coda consigliate ", 
"snippet" : "Come regola generale, per la maggior parte delle code è adatta una dimensione di 16 elementi. L'ultima coda prima SMC_Interpolator blocco di funzioni (che di solito è la coda del percorso, il blocco funzionale precedente alla preelaborazione) SMC_CheckVelocities ) dovrebbe avere una dimensione della...", 
"body" : "Come regola generale, per la maggior parte delle code è adatta una dimensione di 16 elementi. L'ultima coda prima SMC_Interpolator blocco di funzioni (che di solito è la coda del percorso, il blocco funzionale precedente alla preelaborazione) SMC_CheckVelocities ) dovrebbe avere una dimensione della coda maggiore: 100 elementi sono un buon punto di partenza per la maggior parte delle applicazioni. Per comprendere queste regole e sapere quando deviare da esse, esaminiamo gli effetti delle dimensioni delle code: Latenza di elaborazione: più grandi sono le code, più tempo ci vorrà per riempirle inizialmente. Le SMC_Interpolator blocco funzione attende il riempimento dell'ultima coda prima di iniziare con l'interpolazione. Per la latenza, è rilevante la dimensione totale della coda (somma di tutte le dimensioni della coda Guardare avanti dell'interpolatore: la dimensione dell'ultima coda prima del SMC_Interpolator determina il lookahead dell'interpolazione. Quando calcola una traiettoria, l'interpolatore può pianificare solo fino alla fine del lookahead. Se il lookahead è troppo piccolo, l'interpolatore potrebbe non essere in grado di raggiungere l'intera velocità del percorso. A seconda della velocità del percorso e della lunghezza degli elementi, 100 elementi sono un buon punto di partenza, ma per elementi ad alta velocità e\/o brevi, potrebbe essere necessaria una dimensione della coda Effetto su blocchi funzionali particolari : Blocchi funzionali come SMC_AvoidLoop o SMC_SmoothMerge richiedono una certa dimensione della coda in entrata per funzionare in modo efficace. Ad esempio, per rilevare un loop nel G-Code, questo loop deve essere inserito SMC_AvoidLoop . Per i dettagli, consultate la documentazione dei blocchi funzionali nella pipeline di elaborazione dei percorsi " }, 
{ "title" : "Chiamata dei blocchi funzionali di elaborazione ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128219711", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Preelaborazione del percorso e dimensioni della coda \/ Chiamata dei blocchi funzionali di elaborazione ", 
"snippet" : "Come accennato in precedenza, l'interpolazione inizia solo dopo che tutte le code sono state riempite. Ciò causa una latenza iniziale all'avvio della lavorazione. Oltre a ridurre la dimensione totale della coda, esiste un altro modo per ridurre I blocchi funzionali di preelaborazione del percorso ve...", 
"body" : "Come accennato in precedenza, l'interpolazione inizia solo dopo che tutte le code sono state riempite. Ciò causa una latenza iniziale all'avvio della lavorazione. Oltre a ridurre la dimensione totale della coda, esiste un altro modo per ridurre I blocchi funzionali di preelaborazione del percorso vengono generalmente richiamati in un'attività ciclica in background, come mostrato negli esempi come Esempio CNC 03: esecuzione della preelaborazione del percorso in linea. Per ridurre la latenza, il programma chiama SMC_ReadNCFile2 , SMC_NCInterpreter e i preprocessori di percorso possono essere richiamati in un ciclo. A seconda delle priorità dell'applicazione e dell'attività, può essere sufficiente eseguire il programma più volte per chiamata all'operazione (ad esempio 100 volte) o terminare il ciclo dopo un determinato intervallo di tempo (ad esempio 5 " }, 
{ "title" : "Esempi ", 
"url" : "_sm_cnc_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Esempio CNC 01: Generazione diretta di OutQueue ", 
"url" : "_sm_example_cnc_1.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 01: Generazione diretta di OutQueue ", 
"snippet" : "Vedi il CNC01_direct.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra un programma CNC con due assi. Vengono raggiunte quattro posizioni nel piano X\/Y con velocità e accelerazione definite. Il programma imposta due p...", 
"body" : "Vedi il CNC01_direct.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra un programma CNC con due assi. Vengono raggiunte quattro posizioni nel piano X\/Y con velocità e accelerazione definite. Il programma imposta due punti di commutazione del percorso sul percorso. Il programma viene scritto direttamente in una struttura dati utilizzando l'estensione SMC_OutQueue modalità di compilazione. La messa in produzione Compila e avvia il programma creato. Il programma esegue il movimento del CNC non appena il Execute è stato impostato l'ingresso dell'interpolatore. Dopo che il programma è stato eseguito completamente, è possibile riavviarlo mediante un nuovo fronte di salita. Notare la funzione degli interruttori di percorso che vengono visualizzati anche nella visualizzazione del blocco funzione di interpolazione. " }, 
{ "title" : "Creazione di un programma NC nell'editor CNC ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_0decf30fe1170213c0a864632e7a1fa2", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 01: Generazione diretta di OutQueue \/ Creazione di un programma NC nell'editor CNC ", 
"snippet" : "Creare un CNCdirect progetto con a SoftMotion controllore. Inserisci a Programma CNC oggetto chiamato Example . Seleziona il Implementazione Din66025 e il Modalità di compilazione SMC_OutQueue . Specificare i seguenti blocchi di movimento: Editor CNC:...", 
"body" : "Creare un CNCdirect progetto con a SoftMotion controllore. Inserisci a Programma CNC oggetto chiamato Example . Seleziona il Implementazione Din66025 e il Modalità di compilazione SMC_OutQueue . Specificare i seguenti blocchi di movimento: Editor CNC: " }, 
{ "title" : "Creazione di un'interfaccia dell'azionamento e configurazione del PLC ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_502a86c7e1170213c0a864631de910a9", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 01: Generazione diretta di OutQueue \/ Creazione di un'interfaccia dell'azionamento e configurazione del PLC ", 
"snippet" : "Definire una struttura di azionamento con due azionamenti lineari come segue: Inserisci due unità virtuali X_Drive e Y_Drive sotto il Pool di assi generali SoftMotion . Impostare il Tipo di asse parametro a Finite (1). Editor di configurazione:...", 
"body" : "Definire una struttura di azionamento con due azionamenti lineari come segue: Inserisci due unità virtuali X_Drive e Y_Drive sotto il Pool di assi generali SoftMotion . Impostare il Tipo di asse parametro a Finite (1). Editor di configurazione: " }, 
{ "title" : "Creazione di un programma IEC ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_2840ecebe1170213c0a8646360b1cd08", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 01: Generazione diretta di OutQueue \/ Creazione di un programma IEC ", 
"snippet" : "Aggiungi un nuovo programma CFC ipo all'applicazione e configurare un task ciclico con un intervallo di 3 ms. Attivare gli azionamenti con il blocco funzione MC_Power . POU: Ora aggiungi il blocco di costruzione SMC_Interpolator  uno. Il blocco converte un percorso descritto dagli oggetti GEOINFO in...", 
"body" : "Aggiungi un nuovo programma CFC ipo all'applicazione e configurare un task ciclico con un intervallo di 3 ms. Attivare gli azionamenti con il blocco funzione MC_Power . POU: Ora aggiungi il blocco di costruzione SMC_Interpolator  uno. Il blocco converte un percorso descritto dagli oggetti GEOINFO in punti di percorso discreti. Il blocco riceve in ingresso poqDataIn l'indirizzo del programma CNC creato. Inoltre, sull'ingresso deve essere impostato il tempo di ciclo del task IEC dwIpoTime da scrivere. Puoi usarlo come valore costante all'ingresso dwIpoTime inserisci o usi la variabile dwCycle la struttura del gruppo di assi dalla configurazione del controllo. Il vantaggio è che l'ora corretta viene utilizzata automaticamente come ingresso dell'interpolatore se si modifica il tempo di ciclo del task. POU: In questo esempio, verrà controllato un sistema a portale. A tal fine, inserire un'istanza dei blocchi funzione di trasformazione inversa e diretta dal SM_Trafo biblioteca. Il blocco funzione di trasformazione in avanti contiene gli azionamenti come ingressi. Il blocco funzione di trasformazione inversa deve contenere la posizione impostata dell'interpolatore. La trasformazione in avanti nell'esempio è richiesta solo per la visualizzazione. Istanza del blocco funzione: Le uscite del blocco funzione (le coordinate degli assi) devono essere scritte negli azionamenti. Questo è fatto con il SMC_ControlAxisByPos blocco funzionale. Poiché l'applicazione non garantisce che le uscite dell'interpolatore siano costanti (es. il percorso termina in un punto diverso da quello in cui è iniziato), attivare l'evitamento gap ( bAvoidGaps , fGapVelocity , fGapAcceleration , fGapDeceleration ). Quindi collegare il StopIpo uscita al bEmergency_Stop ingresso dell'interpolatore e collegare l'uscita dell'interpolatore iStatus ai rispettivi ingressi dei blocchi funzione di controllo assi. Osservare l'ordine corretto dei blocchi funzione durante la programmazione con CFC. CFC: " }, 
{ "title" : "Creazione di un'interfaccia operativa e di un'interfaccia di test ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 01: Generazione diretta di OutQueue \/ Creazione di un'interfaccia operativa e di un'interfaccia di test ", 
"snippet" : "Collega due oggetti di visualizzazione a una nuova visualizzazione: il modello dell'interpolatore e il modello della trasformazione. È necessario utilizzare i segnaposto per collegarli alle rispettive istanze di blocchi funzione (qui: Ipo.smci e Ipo.trafof )....", 
"body" : "Collega due oggetti di visualizzazione a una nuova visualizzazione: il modello dell'interpolatore e il modello della trasformazione. È necessario utilizzare i segnaposto per collegarli alle rispettive istanze di blocchi funzione (qui: Ipo.smci e Ipo.trafof ). " }, 
{ "title" : "Esempio CNC 02: Decodifica in linea con variabili ", 
"url" : "_sm_example_cnc_2.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 02: Decodifica in linea con variabili ", 
"snippet" : "Vedi il CNC02_online.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . L'esempio mostra come utilizzare le variabili per decodificare un programma CNC. La messa in produzione Compila e avvia il programma creato. Il programma esegue il movi...", 
"body" : "Vedi il CNC02_online.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . L'esempio mostra come utilizzare le variabili per decodificare un programma CNC. La messa in produzione Compila e avvia il programma creato. Il programma esegue il movimento del CNC non appena il Execute è stato impostato l'ingresso del decoder e dell'interpolatore. Se si modificano i valori delle variabili globali, vengono utilizzati al riavvio del decoder e il percorso viene adattato di conseguenza. Monitorare la funzione del Append anche l'ingresso del decoder. " }, 
{ "title" : "Creazione di un programma NC nell'editor CNC ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_4c86ec04e529c0bcc0a864636a6ae1dc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 02: Decodifica in linea con variabili \/ Creazione di un programma NC nell'editor CNC ", 
"snippet" : "Creare un CNCOnline programma con a SoftMotion controllore. Crea un elenco di variabili globali e dichiara due variabili. VAR_GLOBAL g_x: REAL:=100; g_y:REAL:=50; END_VAR Inserisci a Programma CNC oggetto chiamato Example . Seleziona il Implementazione Din66025 e il Modalità di compilazione  SMC_CNC...", 
"body" : "Creare un CNCOnline programma con a SoftMotion controllore. Crea un elenco di variabili globali e dichiara due variabili. VAR_GLOBAL\n g_x: REAL:=100;\n g_y:REAL:=50;\nEND_VAR Inserisci a Programma CNC oggetto chiamato Example . Seleziona il Implementazione Din66025 e il Modalità di compilazione  SMC_CNC_REF . Questa modalità è necessaria perché si utilizzano variabili nel programma. Specificare i seguenti blocchi di movimento: Editor CNC: " }, 
{ "title" : "Creazione di un'interfaccia dell'azionamento e configurazione del PLC ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_7e9d1704e529c0bcc0a8646343b60bbd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 02: Decodifica in linea con variabili \/ Creazione di un'interfaccia dell'azionamento e configurazione del PLC ", 
"snippet" : "Definire una struttura dell'unità (ad es CNCdirect )....", 
"body" : "Definire una struttura dell'unità (ad es CNCdirect ). " }, 
{ "title" : "Creazione di un programma IEC ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3989abe9e529c0bcc0a864630f20ee19", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 02: Decodifica in linea con variabili \/ Creazione di un programma IEC ", 
"snippet" : "Aggiungi un POU (CFC) denominato Path all'applicazione. La decodifica del programma NC per OUTQUEUE e il controllo della velocità avvengono nel Path programma. chiamando SMC_CheckVelocities è obbligatorio. CFC: Aggiungi un POU (CFC) denominato Ipo all'applicazione. Questo programma è quasi identico ...", 
"body" : "Aggiungi un POU (CFC) denominato Path all'applicazione. La decodifica del programma NC per OUTQUEUE e il controllo della velocità avvengono nel Path programma. chiamando SMC_CheckVelocities è obbligatorio. CFC: Aggiungi un POU (CFC) denominato Ipo all'applicazione. Questo programma è quasi identico al CNCdirect progetto campione. Tuttavia, i dati immessi dall'interpolatore non corrispondono ai nomi dei programmi CNC ( ADR(Example) ), ma all'output OutQueue dei blocchi funzione di preelaborazione del percorso ( checkVel.poqDataOut ). " }, 
{ "title" : "Creazione di un'attività per la preelaborazione del percorso ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3014d45de529c0bcc0a86463617895a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 02: Decodifica in linea con variabili \/ Creazione di un'attività per la preelaborazione del percorso ", 
"snippet" : "Perché hai selezionato la modalità di compilazione SMC_CNC_REF , è necessario eseguire la decodifica e la preelaborazione del percorso nel programma IEC. Questo calcolo richiede tempo. Non deve essere eseguito nel ciclo dell'interpolatore poiché per ogni richiamo del decoder viene generato un oggett...", 
"body" : "Perché hai selezionato la modalità di compilazione SMC_CNC_REF , è necessario eseguire la decodifica e la preelaborazione del percorso nel programma IEC. Questo calcolo richiede tempo. Non deve essere eseguito nel ciclo dell'interpolatore poiché per ogni richiamo del decoder viene generato un oggetto vettoriale e questo oggetto viene generalmente utilizzato per molti richiami dell'interpolatore. Dovresti sostituire questa operazione con un'attività con priorità bassa e chiamate meno frequenti. Creare un PathTask compito. Definire i seguenti parametri: Priorità : 10 Intervallo : T#30ms Aggiungi il Path POU al compito. Compito \"PathTask\" Meccanismo sottostante: Nel task lento, all'inizio viene generato circa un oggetto GEOINFO per ciclo. Questo oggetto è memorizzato nella struttura OUTQUEUE del blocco funzione del decodificatore. Se OUTQUEUE è pieno, i blocchi funzione del task lento si interrompono fino a quando OUTQUEUE non è più pieno. Questo accade non appena l'attività veloce elabora il primo oggetto GEOINFO e lo elimina da OUTQUEUE. Quindi i blocchi funzione del task lento diventano nuovamente attivi e riempiono la struttura OUTQUEUE. Nel compito veloce, un punto di percorso dalla struttura OUTQUEUE, che il DataIn l'input punta a, viene calcolato ed elaborato in ogni ciclo. Poiché un oggetto GEOINFO è generalmente costituito da più punti di percorso, sono necessari alcuni cicli prima che il primo oggetto GEOINFO venga elaborato e cancellato automaticamente dall'interpolatore. Poiché l'elaborazione di un oggetto GEOINFO dura diversi cicli rispetto alla sua creazione, il task lento può essere chiamato meno frequentemente rispetto al task veloce. Tuttavia, i tempi del task devono essere selezionati in modo che un numero sufficiente di oggetti GEOINFO sia sempre memorizzato nell'ultimo OUTQUEUE del task lento, prevenendo così il verificarsi di eventuali underrun di dati. Questo accade quando non ci sono più oggetti GEOINFO disponibili per l'interpolatore da DataIn e la fine del percorso non è stata ancora raggiunta. In questo caso, l'interpolatore rallenta e si ferma fino a quando non sono nuovamente disponibili nuovi elementi di dati. " }, 
{ "title" : "Creazione di un'interfaccia operativa e di un'interfaccia di test ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 02: Decodifica in linea con variabili \/ Creazione di un'interfaccia operativa e di un'interfaccia di test ", 
"snippet" : "La visualizzazione corrisponde al CNCdirect.project progetto campione. Aggiungere modelli aggiuntivi ai nuovi blocchi funzione ( SMC_NCDecoder e SMC_CheckVelocities ). Crea un display anche per le variabili globali g_x e g_y in modo da poterne verificare il funzionamento in seguito durante la messa ...", 
"body" : "La visualizzazione corrisponde al CNCdirect.project progetto campione. Aggiungere modelli aggiuntivi ai nuovi blocchi funzione ( SMC_NCDecoder e SMC_CheckVelocities ). Crea un display anche per le variabili globali g_x e g_y in modo da poterne verificare il funzionamento in seguito durante la messa in servizio. " }, 
{ "title" : "Esempio CNC 03: esecuzione della preelaborazione del percorso in linea ", 
"url" : "_sm_example_cnc_3.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 03: esecuzione della preelaborazione del percorso in linea ", 
"snippet" : "Vedi il CNC03_prepro.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . L'esempio mostra come eseguire online la preelaborazione del percorso nel controllore. Estendere il CNC02_online progetto con un preprocessore di percorso. Poi gli ango...", 
"body" : "Vedi il CNC03_prepro.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . L'esempio mostra come eseguire online la preelaborazione del percorso nel controllore. Estendere il CNC02_online progetto con un preprocessore di percorso. Poi gli angoli del movimento del CNConline progetto sono arrotondati per mezzo di spline. Questo viene fatto con il SMC_SmoothPath blocco funzione. Estendere il programma CNC: Accodare il programma precedente con gli elementi G51\/G50 . Clic CNC → Mostra percorso preelaborato in modo che le spline create dalla preelaborazione del percorso vengano visualizzate nell'editor, come nello screenshot qui sotto. Schermo: Senza utilizzare variabili, è possibile compilare il programma in questa forma come una coda e inserirlo direttamente nell'interpolatore. Tuttavia, poiché le variabili sono disponibili, devi eseguire tu stesso la decodifica e il livellamento dell'angolo. Dichiarare un nuovo blocco funzione di tipo SMC_SmoothPath . Chiamalo dopo il decoder. Impostare l'ingresso dati del blocco funzione interpolatore come di consueto su poqDataOut uscita del CheckVelocities blocco funzionale. Deve essere dichiarato un nuovo buffer per l'input SMC_SmoothPath.pbyBufferOutQueue . CFC: La messa in produzione Compila e avvia il programma creato. Contrariamente al programma precedente, questo programma non si ferma più sugli angoli del programma NC perché gli angoli del percorso sono stati liberati da piegature mediante la preelaborazione del percorso. " }, 
{ "title" : "Esempio CNC 04: Programmazione CNC utilizzando l'editor tabulare ", 
"url" : "_sm_example_cnc_4.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 04: Programmazione CNC utilizzando l'editor tabulare ", 
"snippet" : "Vedi il CNC04_table.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . In questo progetto, la funzionalità del CNC03_prepro.project progetto di esempio è programmato con l'editor tabulare. In contrasto con CNC03_prepro.project , in questo p...", 
"body" : "Vedi il CNC04_table.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . In questo progetto, la funzionalità del CNC03_prepro.project progetto di esempio è programmato con l'editor tabulare. In contrasto con CNC03_prepro.project , in questo progetto non vengono utilizzate variabili IEC. Al contrario, viene calcolato con valori fissi. Altrimenti, la funzionalità è identica. " }, 
{ "title" : "Esempio CNC 05: Creazione di CNC da un file ", 
"url" : "_sm_example_cnc_5.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 05: Creazione di CNC da un file ", 
"snippet" : "Vedi il CNC05_File.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Con questo progetto di esempio è possibile comprendere come viene letto un programma in codice G da un file ASCII memorizzato nel PLC. L'utilizzo di questo tipo di file h...", 
"body" : "Vedi il CNC05_File.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Con questo progetto di esempio è possibile comprendere come viene letto un programma in codice G da un file ASCII memorizzato nel PLC. L'utilizzo di questo tipo di file ha senso quando il programma in codice G è molto grande. La funzione del progetto è simile al CNC02_online.project progetto campione. Tuttavia, il programma in codice G viene letto da un file ASCII. Non vengono utilizzate variabili e l'ordine di elaborazione è paragonabile a quello del file CNC02_online.project progetto campione. Si possono determinare le seguenti differenze: Unità virtuale aggiuntiva (asse z) Blocco funzione smoothpath non richiesto Codice G letto da file Preelaborazione online (cfr CNC02_online.project ) " }, 
{ "title" : "Esempio CNC 06: Utilizzo di Path3D con SoftMotion CNC ", 
"url" : "_sm_example_cnc_6.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 06: Utilizzo di Path3D con SoftMotion CNC ", 
"snippet" : "Vedi il CNC06_File_3DPath.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio estende l'esempio precedente CNC05_File . Dimostra una possibile applicazione dell'elemento di visualizzazione Path3D con CODESYS SoftMotion CNC. Es...", 
"body" : "Vedi il CNC06_File_3DPath.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio estende l'esempio precedente CNC05_File . Dimostra una possibile applicazione dell'elemento di visualizzazione Path3D con CODESYS SoftMotion CNC. Estensione del programma CNC_File a CNC_File_Path3D Apri il Gestore della Biblioteca e aggiungi il SM3_CNC_Visu biblioteca. Crea un'istanza di SMC_PathCopierFile in CNC_PreparePath e chiamarlo all'inizio dell'elaborazione del percorso ( iState=0 ). Programmazione: Nel Visualizzazione visualizzazione, sostituire la visualizzazione grafica della posizione precedentemente utilizzata con il Percorso3D elemento. Modificare le proprietà del Percorso3D elemento: Descrizione percorso → Dati percorso (VisuStruct3DTrack) : CNC_prepare_path.pcf.vs3dt Inserisci il Portafoto elemento di visualizzazione. Fare riferimento al Pannello di controllo visualizzazione da VisuElem3DPath biblioteca. Questo elemento viene utilizzato per controllare la posizione della telecamera dell'elemento. Nella dichiarazione del CNC_PreparePath programma, creare un'istanza di VisuStruct3DControl ( VisuElem3DPath biblioteca): vc: VisuStruct3DControl; . Questa istanza costituisce l'interfaccia dati tra l'elemento Path3D e il pannello di controllo della fotocamera. Modificare le proprietà del Percorso3D elemento: Controllo telecamera → Struttura dati di controllo (VisuStruct3DControl) : CNC_PreparePath.vc Modificare le proprietà del Pannello di controllo elemento: Riferimenti → VisuElem3DPath.ControlPanel → vc : CNC_PreparePath.vc Compila, scarica e avvia l'applicazione. L'elemento Path3D mostra il percorso. È possibile controllare la posizione della telecamera dal pannello. Aggiungi un'istanza di SMC_PositionTracker blocco funzione nel CNC programma. Crea una memoria per tracciare la traccia corrente (le ultime posizioni percorse). pt: SMC_PositionTracker; pointbuffer_pt: ARRAY [0..1000] OF VisuStruct3DPathPoint; Inserisci una chiamata dell'istanza: SMC_PositionTracker nel Interpolation azione CFC: Collega i dati del percorso all'elemento Path3D. Modificare le proprietà del Percorso3D elemento: Descrizione percorso → Dati percorso (VisuStruct3DTrack) : CNC.pt.vs3dt Vai online e avvia l'applicazione. L'elemento Path3D visualizza l'ultimo percorso interpolato anche sul percorso. Configura altre proprietà di Percorso3D . Ad esempio, configurare gli elementi del percorso elaborati in modo che vengano visualizzati in grigio: Evidenzia → Evidenzia colore : Gray Progetto di esempio: \"Generatore di percorsi 3D\" " }, 
{ "title" : "Esempio CNC 07: Uso di espressioni e sottoprogrammi ", 
"url" : "_sm_example_cnc_7.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 07: Uso di espressioni e sottoprogrammi ", 
"snippet" : "Vedi il CNC07_Subprogram.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come chiamare a  sottoprogramma da un file CNC così come l'uso espressioni nelle istruzioni di movimento CNC. Nel CNC programma, gli azionamen...", 
"body" : "Vedi il CNC07_Subprogram.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come chiamare a  sottoprogramma da un file CNC così come l'uso espressioni nelle istruzioni di movimento CNC. Nel CNC programma, gli azionamenti vengono prima accesi, come negli altri esempi. Il CNC_PreparePath il programma usa il SMC_ReadNCFile2 blocco funzione per la lettura del file CNC. SMC_ReadNCFile2 crea il SMC_ReadNCFile POU e lo estende con il supporto per sottoprogrammi ed espressioni. Il programma CNC CNC2Main.cnc viene convertito mediante il SMC_NCInterpreter blocco funzionale. SMC_NCInterpreter crea il SMC_NCDecoder POU e lo estende con il supporto per subroutine ed espressioni. Il progetto contiene due programmi CNC: il programma principale CNC2Main.cnc e il sottoprogramma CNC2.cnc . Il programma principale passa il valore 25 nel #RADIUS parametro al sottoprogramma. Nel sottoprogramma, l'espressione X#RADIUS*2 viene utilizzato per calcolare il percorso circolare. Programma principale N0 G01 X$g_x$ Y0 F50 E30 E-30\nN10 G01 X0 Y$g_y$\nN20 CNC2{25}\nN30 G01 X0 Y-200 sottoprogramma SUBPROGRAM CNC2{#RADIUS : LREAL}\nN010 G91\nN020 G02 X#RADIUS*2 Y0 R#RADIUS Z2.5 F100 E-100 E100\nN030 G02 X-#RADIUS*2 Y0 R#RADIUS Z7.5\nEND_SUBPROGRAM " }, 
{ "title" : "Esempio CNC 08: Utilizzo di Assi Addizionali ", 
"url" : "_sm_example_external_axes_usage.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 08: Utilizzo di Assi Addizionali ", 
"snippet" : "Vedi il CNC08_AdditionalAxes.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio estende il CNC01_direct.projekt progetto descritto in Esempio CNC 01: Generazione diretta di OutQueue. Dimostra come utilizzare assi aggiuntivi. ...", 
"body" : "Vedi il CNC08_AdditionalAxes.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio estende il CNC01_direct.projekt progetto descritto in Esempio CNC 01: Generazione diretta di OutQueue. Dimostra come utilizzare assi aggiuntivi. Come nell'esempio CNC 01, vengono raggiunte quattro posizioni nel piano X\/Y con velocità e accelerazione definite. Inoltre, l'asse aggiuntivo A è azionato durante ogni movimento. Il programma imposta due punti di commutazione del percorso sul percorso. " }, 
{ "title" : "Modifica di un programma CNC nell'editor ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4510557821784033079793683298", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 08: Utilizzo di Assi Addizionali \/ Modifica di un programma CNC nell'editor ", 
"snippet" : "Apri il CNC01_direct.project project dalla directory di installazione di CODESYS . Nel progetto, aprire il programma CNC Example . Aggiungere le posizioni per l'asse aggiuntivo A ai comandi di spostamento: Editore CNC N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30 N10 G02 X84.9 Y84.6 A40 R100 H12 L10 N20 G01 X...", 
"body" : "Apri il CNC01_direct.project project dalla directory di installazione di CODESYS . Nel progetto, aprire il programma CNC Example . Aggiungere le posizioni per l'asse aggiuntivo A ai comandi di spostamento: Editore CNC N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30\nN10 G02 X84.9 Y84.6 A40 R100 H12 L10\nN20 G01 X 6.6 Y25.7 A60 H-1 O0.8\nN30 G03 X54.6 Y49.7 A80 R100 " }, 
{ "title" : "Creazione di un'interfaccia dell'azionamento e configurazione del PLC ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758202758433079807306962", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 08: Utilizzo di Assi Addizionali \/ Creazione di un'interfaccia dell'azionamento e configurazione del PLC ", 
"snippet" : "Inserisci un'unità virtuale aggiuntiva A_Drive sotto il Pool di assi generali SoftMotion . Impostare i parametri come segue:...", 
"body" : "Inserisci un'unità virtuale aggiuntiva A_Drive sotto il Pool di assi generali SoftMotion . Impostare i parametri come segue: " }, 
{ "title" : "Modifica di un programma IEC ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758311412833079809057524", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 08: Utilizzo di Assi Addizionali \/ Modifica di un programma IEC ", 
"snippet" : "Aprire il programma CFC Ipo . Attiva l'unità aggiunta in precedenza A_Drive con il MC_Power blocco funzione. In questo esempio, un semplice asse di orientamento ( A_Drive ) deve essere controllato con l'asse aggiuntivo A. Per questo motivo non sono necessari più moduli di trasformazione. La posizion...", 
"body" : "Aprire il programma CFC Ipo . Attiva l'unità aggiunta in precedenza A_Drive con il MC_Power blocco funzione. In questo esempio, un semplice asse di orientamento ( A_Drive ) deve essere controllato con l'asse aggiuntivo A. Per questo motivo non sono necessari più moduli di trasformazione. La posizione nominale dell'interpolatore corrisponde direttamente alla posizione nominale dell'azionamento e viene applicata tramite il SMC_POSINFO selettore con il SMC_ControlAxisByPos blocco funzione. L'applicazione non garantisce che le uscite dell'interpolatore siano continue. Ad esempio, la posizione dell'asse aggiuntivo termina in un punto diverso da quello in cui inizia. Pertanto, è necessario attivare l'evitare il gap ( bAvoidGaps , fGapVelocity , fGapAcceleration , e fGapDeceleration ). Quindi collegare il bStopIpo uscita al bEmergency_Stop ingresso dell'interpolatore e collegare l'uscita dell'interpolatore iStatus ai rispettivi ingressi dei blocchi funzione di controllo dell'asse. Prestare attenzione soprattutto al corretto ordine dei blocchi funzione durante la programmazione con CFC. " }, 
{ "title" : "La messa in produzione ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4584880865328033079813143466", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 08: Utilizzo di Assi Addizionali \/ La messa in produzione ", 
"snippet" : "Compila e avvia il programma creato. Il programma esegue il movimento del CNC non appena il Execute è stato impostato l'ingresso dell'interpolatore. Dopo che il programma è stato eseguito completamente, è possibile applicare un nuovo fronte di salita per riavviarlo. Durante l'esecuzione del programm...", 
"body" : "Compila e avvia il programma creato. Il programma esegue il movimento del CNC non appena il Execute è stato impostato l'ingresso dell'interpolatore. Dopo che il programma è stato eseguito completamente, è possibile applicare un nuovo fronte di salita per riavviarlo. Durante l'esecuzione del programma CNC, annotare la posizione dell'asse aggiuntivo A ( piSetPosition.dA ) che viene mostrato nella visualizzazione della POU di interpolazione. " }, 
{ "title" : "Esempio CNC 09: Uso della correzione della lunghezza dell'utensile ", 
"url" : "_sm_example_tool_correction_usage.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 09: Uso della correzione della lunghezza dell'utensile ", 
"snippet" : "Vedere il progetto di esempio per questo CNC09_ToolLengthCorr.project nella directory di installazione di CODESYS tra ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come utilizzare il SMC_ToolLengthCorr POU per compensare la lunghezza di un utensile. Per ulteriori informazioni sull'argomento...", 
"body" : "Vedere il progetto di esempio per questo CNC09_ToolLengthCorr.project nella directory di installazione di CODESYS tra ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come utilizzare il SMC_ToolLengthCorr POU per compensare la lunghezza di un utensile. Per ulteriori informazioni sull'argomento della correzione della lunghezza utensile, vedere: Pre-elaborazione" }, 
{ "title" : "Applicazione ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm458488080921763308005489139", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 09: Uso della correzione della lunghezza dell'utensile \/ Applicazione ", 
"snippet" : "Per l'esempio, viene utilizzata una cinematica Gantry3 insieme a un asse di orientamento aggiunto ( AxisA ) che può ruotare attorno all'asse Z. Un utensile con una lunghezza di 2 unità nella direzione Z è a sua volta attaccato all'asse di orientamento. Dovrebbe essere eseguito un semplice programma ...", 
"body" : "Per l'esempio, viene utilizzata una cinematica Gantry3 insieme a un asse di orientamento aggiunto ( AxisA ) che può ruotare attorno all'asse Z. Un utensile con una lunghezza di 2 unità nella direzione Z è a sua volta attaccato all'asse di orientamento. Dovrebbe essere eseguito un semplice programma CNC. Questo viene memorizzato nel progetto come esterno CNC.cnc file e può essere aperto con un editor di testo. Nel programma CNC, la correzione della lunghezza utensile viene prima attivata tramite il codice G G43 . Il I , J , e K i parametri corrispondono all'offset nelle direzioni X, Y e Z per questo. Successivamente, vengono percorsi tre punti nel piano XY. Durante il movimento verso l'ultimo punto, anche l'asse aggiuntivo A viene ruotato di 90 gradi. N000 G43 I0 J0 K2 (Activate tool length correction with tool offset X=0 Y=0 Z=2)\nN010 G01 X10 F10 E100 E-100\nN020 G03 Y10 R5N030 G01 X0 A90 L'applicazione è composta da più parti. Nel CNC_PreparePath programma, il programma CNC CNC.cnc viene importato come file dal controller e preelaborato. Nel CNC programma, gli azionamenti vengono prima accesi, come negli altri esempi. Quindi viene eseguita l'interpolazione del programma CNC precedentemente letto. In ogni ciclo, l'interpolatore emette una posizione impostata (piSetPosition ) e l'offset corrente dell'utensile (adToolLength ). Il SMC_ToolLengthCorr POU richiede queste informazioni per compensare la lunghezza utensile specificata. La posizione compensata viene quindi trasformata e infine passata agli assi tramite il SMC_ControlAxisByPos POU. Il programma è quasi identico agli altri esempi. Solo il SMC_ToolLengthCorr POU è stata inserita dopo l'interpolatore e prima della trasformazione per elaborare la posizione impostata emessa dall'interpolatore. " }, 
{ "title" : "La messa in produzione ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm4590758219934433080059282556", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 09: Uso della correzione della lunghezza dell'utensile \/ La messa in produzione ", 
"snippet" : "Compila e avvia il programma creato. Il programma esegue il movimento del CNC non appena il CNC_PreparePath.xStart l'ingresso è stato impostato. È possibile fare clic su Inizio pulsante per impostare questa variabile nell'applicazione o nella visualizzazione. Dopo che il programma è stato eseguito c...", 
"body" : "Compila e avvia il programma creato. Il programma esegue il movimento del CNC non appena il CNC_PreparePath.xStart l'ingresso è stato impostato. È possibile fare clic su Inizio pulsante per impostare questa variabile nell'applicazione o nella visualizzazione. Dopo che il programma è stato eseguito completamente, è possibile applicare un nuovo fronte di salita per riavviarlo. Durante l'esecuzione del programma CNC, annotare le uscite dell'interpolatore ( piSetPosition , adToolLength ) e la posizione compensata ( piOut ) del SMC_ToolLengthCorr POU. Nota: la rotazione di AxisA durante l'ultimo movimento del programma CNC non ha alcun effetto (aggiuntivo) sulla posizione cartesiana compensata in questo esempio perché l'utensile ha solo un offset in direzione Z. Se si aggiunge un componente all'offset dell'utensile (nel file CNC, sul controller nella cartella dell'applicazione) in direzione X e Y, la rotazione di AxisA durante l'ultimo movimento avrà un effetto aggiuntivo sulla posizione compensata. " }, 
{ "title" : "Leggere lo stato dell'interpolatore ", 
"url" : "_sm_example_state_interpolator.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Leggere lo stato dell'interpolatore ", 
"snippet" : "Vedi il CNC13_ReadInterpolatorState.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Il progetto di esempio mostra come leggere lo stato dell'interpolatore CNC. Lo stato viene utilizzato per visualizzare la posizione della macchina nelle ...", 
"body" : "Vedi il CNC13_ReadInterpolatorState.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Il progetto di esempio mostra come leggere lo stato dell'interpolatore CNC. Lo stato viene utilizzato per visualizzare la posizione della macchina nelle coordinate della macchina e del decodificatore " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234546899564", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Leggere lo stato dell'interpolatore \/ Struttura dell'applicazione ", 
"snippet" : "La struttura è tipica delle applicazioni CNC. Il codice G viene letto nell'attività in background. L'interpolazione viene eseguita nel task del bus Durante l'interpolazione, SMC_ReadAdditionalIpoState blocco funzionale chiamato. Non appena inizia l'interpolazione, Valid l'output è TRUE . La posizion...", 
"body" : "La struttura è tipica delle applicazioni CNC. Il codice G viene letto nell'attività in background. L'interpolazione viene eseguita nel task del bus Durante l'interpolazione, SMC_ReadAdditionalIpoState blocco funzionale chiamato. Non appena inizia l'interpolazione, Valid l'output è TRUE . La posizione dell'interpolatore, che viene sempre emessa nel sistema di coordinate della macchina (MCS), viene quindi convertita utilizzando l'attuale sistema di coordinate del decodificatore (DCS) e SMC_V3_Set(pos_MCS, ipo.piSetPosition.dX, ipo.piSetPosition.dY, ipo.piSetPosition.dZ);\n\nreadState(\n    Enable:= TRUE,\n    ipo:= ipo);\n\nIF readState.Valid THEN\n    SMC_PosInfo_Trf_Inverse(\n        piOut:= piMCS_to_DCS,\n        piIn:= readState.State.DCS,\n        eOriConv:= readState.State.OriConv);\n\n SMC_PosInfo_Trf_Apply(\n        vDst:= pos_DCS,\n        piTrf:= piMCS_to_DCS,\n        vSrc:= pos_MCS,\n        eOriConv:= readState.State.OriConv);\nEND_IF Per ulteriori informazioni sul sistema di coordinate del decodificatore, vedere quanto segue: Spostamento, rotazione e ridimensionamento del sistema di coordinate. " }, 
{ "title" : "Messa in servizio ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234714771807", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Leggere lo stato dell'interpolatore \/ Messa in servizio ", 
"snippet" : "Crea l'applicazione e scaricala su un controller. Aprire la visualizzazione. Avviare l'applicazione e premere il pulsante Avviare pulsante della visualizzazione. È possibile tracciare il movimento delle coordinate X e Y in MCS e DCS....", 
"body" : "Crea l'applicazione e scaricala su un controller. Aprire la visualizzazione. Avviare l'applicazione e premere il pulsante Avviare pulsante della visualizzazione. È possibile tracciare il movimento delle coordinate X e Y in MCS e DCS. " }, 
{ "title" : "Implementazione di un blocco funzionale di preelaborazione del percorso ", 
"url" : "_sm_example_cnc14_path_preprocessing.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Implementazione di un blocco funzionale di preelaborazione del percorso ", 
"snippet" : "Vedi il CNC14_PathPreprocessing.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Il progetto di esempio mostra come implementare un nuovo blocco funzione di preelaborazione del percorso. preelaborazione del percorso viene generalmente uti...", 
"body" : "Vedi il CNC14_PathPreprocessing.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Il progetto di esempio mostra come implementare un nuovo blocco funzione di preelaborazione del percorso. preelaborazione del percorso viene generalmente utilizzata per modificare il percorso letto dal codice G. Ciò consente di implementare funzioni come la correzione del raggio dell'utensile o la levigatura degli angoli. Tuttavia, è anche possibile integrare funzioni specifiche per una particolare macchina o applicazione come blocco funzionale di preelaborazione del percorso Per ulteriori informazioni sulla preelaborazione dei percorsi, vedere quanto segue: Preelaborazione del percorso e dimensioni della coda. Per un esempio di come utilizzare un blocco funzione di preelaborazione del percorso, vedere quanto segue: Esempio CNC 03: esecuzione della preelaborazione del percorso in linea. " }, 
{ "title" : "Limitazione del cambio di tangente ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234576416031", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Implementazione di un blocco funzionale di preelaborazione del percorso \/ Limitazione del cambio di tangente ", 
"snippet" : "L'esempio mostra un'applicazione di taglio 2D. È necessario utilizzare un coltello per tagliare lungo un percorso definito dal codice G. Il SMC_TRAFO_GantryCutter2 la trasformazione viene utilizzata per determinare l'angolo del coltello in base alla tangente corrente del percorso. La sfida è che il ...", 
"body" : "L'esempio mostra un'applicazione di taglio 2D. È necessario utilizzare un coltello per tagliare lungo un percorso definito dal codice G. Il SMC_TRAFO_GantryCutter2 la trasformazione viene utilizzata per determinare l'angolo del coltello in base alla tangente corrente del percorso. La sfida è che il coltello non deve ruotare troppo velocemente, altrimenti il taglio non sarà netto. La limitazione della velocità angolare del coltello viene risolta nel progetto di esempio mediante il blocco funzionale Path-Preprocessing appena creato LimitTangentVelocity . Cambia la velocità di avanzamento sul percorso in modo che la velocità di variazione della tangente non superi un valore massimo configurabile Il codice G è un semplice rettangolo con angoli smussati. La traccia mostra il risultato dell'esecuzione: la velocità dell'asse C, che corrisponde alla velocità di rotazione del coltello, viene visualizzata in arancione. È limitato a 45°\/s come specificato " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234546899564", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Implementazione di un blocco funzionale di preelaborazione del percorso \/ Struttura dell'applicazione ", 
"snippet" : "La struttura è tipica delle applicazioni CNC. Il codice G viene letto nell'attività in background e qui avviene anche la preelaborazione del percorso. L'interpolazione viene eseguita nel Le LimitTangentVelocity il blocco funzione mostra i passaggi e gli stati necessari per un blocco funzionale di pr...", 
"body" : "La struttura è tipica delle applicazioni CNC. Il codice G viene letto nell'attività in background e qui avviene anche la preelaborazione del percorso. L'interpolazione viene eseguita nel Le LimitTangentVelocity il blocco funzione mostra i passaggi e gli stati necessari per un blocco funzionale di preelaborazione del percorso. Il principio di base è che il blocco funzione legge, elabora e quindi scrive gli elementi del percorso (tipo SMC_GEOINFO ) dalla coda di input ( poqDataIn ) alla coda di output ( poqDataOut ). Gli elementi vengono rimossi dalla coda di input La logica per modificare la velocità di avanzamento si trova nelle righe 102-138. La funzione ausiliaria ComputeMaxCurvature calcola la curvatura massima che può verificarsi su un determinato elemento del percorso. \/\/ Our velocity limitation comes here. This modifies an element from the\n\/\/ input queue and copies the modified element to the output queue.\n\/\/ Finally, the element is removed from the input queue\n\nm_geo := pgeo^; \/\/ Copy the element\n \/\/ Note: the feature flags set in the G-Code with G38\/G39 can be queried\n \/\/ by reading pgo^.dwFeatureFlags, like this:\n IF (SHR(m_geo.dwFeatureFlags, featureFlag) AND 1) = 1 THEN\n     \/\/ feature is turned on\n\n     ok := ComputeMaxCurvature(m_geo, kappa=> kappa_max);\n     IF NOT ok THEN\n         \/\/ Curvature cannot be computed\n         m_state := STATE_ERROR;\n         ErrorID := SMC_INVALID_PARAMETER;\n         OnExit();\n         RETURN;\n     END_IF\n\n     \/\/ Compute maximum allowed path velocity based on maximum curvature\n     \/\/ and maximum allowed angular velocity\n     IF kappa_max = 0 THEN\n         \/\/ No curvature, no limitation necessary\n         vel := m_geo.dVel;\n     ELSE\n         vel := m_maxAngularVelocity_rad \/ kappa_max;\n     END_IF\n\n     IF velMin < 0 OR vel < velMin THEN\n         velMin := vel;\n     END_IF\n\n     \/\/ Set new maximum velocity for the element\n     m_geo.dVel := MIN(m_geo.dVel, vel);\n ELSE\n     \/\/ feature is turned off\n END_IF " }, 
{ "title" : "Messa in servizio ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234584108811", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Implementazione di un blocco funzionale di preelaborazione del percorso \/ Messa in servizio ", 
"snippet" : "Crea l'applicazione e scaricala su un controller. Avviare l'applicazione. Apri la traccia e scaricala sul controller. Scrivi il valore TRUE alle variabili Path.bExecute e PLC_PRG.bStart . È possibile tenere traccia dell'elaborazione del codice G nella traccia....", 
"body" : "Crea l'applicazione e scaricala su un controller. Avviare l'applicazione. Apri la traccia e scaricala sul controller. Scrivi il valore TRUE alle variabili Path.bExecute e PLC_PRG.bStart . È possibile tenere traccia dell'elaborazione del codice G nella traccia. " }, 
{ "title" : "Preelaborazione di file G-Code di grandi dimensioni ", 
"url" : "_sm_example_large_c_code.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Preelaborazione di file G-Code di grandi dimensioni ", 
"snippet" : "Le CNC15_LargeGCode.project il progetto di esempio si trova nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Il progetto di esempio mostra come elaborare file G-code di grandi dimensioni. Poiché i file di grandi dimensioni sono particolarmente comuni come output da ...", 
"body" : "Le CNC15_LargeGCode.project il progetto di esempio si trova nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Il progetto di esempio mostra come elaborare file G-code di grandi dimensioni. Poiché i file di grandi dimensioni sono particolarmente comuni come output da sistemi CAD\/CAM, questo caso viene mostrato come esempio I sistemi CAD\/CAM generano spesso file G-code con diverse centinaia di migliaia di righe. Sono costituiti da segmenti lineari molto corti G1 ), in genere nell'intervallo da 100 micrometri a un millimetro. Questi brevi segmenti lineari tracciano il contorno del pezzo. Non formano un percorso regolare. La tangente di solito salta tra i segmenti lineari L'esempio mostra come leggere questi file di grandi dimensioni in modo efficiente con requisiti di memoria costanti e come ottenere una curva di velocità uniforme su un percorso composto da tanti brevi segmenti lineari. Il contorno originale del pezzo viene ricostruito durante la " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231424931037", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Preelaborazione di file G-Code di grandi dimensioni \/ Struttura dell'applicazione ", 
"snippet" : "La struttura è tipica delle applicazioni CNC. Il codice G viene letto nell'attività in background PathTask ) e qui avviene anche la preelaborazione del percorso. L'interpolazione viene eseguita nel task del bus MainTask )....", 
"body" : "La struttura è tipica delle applicazioni CNC. Il codice G viene letto nell'attività in background PathTask ) e qui avviene anche la preelaborazione del percorso. L'interpolazione viene eseguita nel task del bus MainTask ). " }, 
{ "title" : "Lettura di file di grandi dimensioni ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425324995", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Preelaborazione di file G-Code di grandi dimensioni \/ Lettura di file di grandi dimensioni ", 
"snippet" : "Per mantenere breve la latenza all'inizio dell'elaborazione del codice G, viene utilizzato un ciclo nell'attività in background. Per semplicità, viene utilizzato un contatore per la condizione di interruzione. A seconda dell'applicazione, del codice G e delle prestazioni del PLC, possono essere util...", 
"body" : "Per mantenere breve la latenza all'inizio dell'elaborazione del codice G, viene utilizzato un ciclo nell'attività in background. Per semplicità, viene utilizzato un contatore per la condizione di interruzione. A seconda dell'applicazione, del codice G e delle prestazioni del PLC, possono essere utili altre condizioni di interruzione, ad esempio un timer. Il ciclo terminerà prima di raggiungere questa condizione di interruzione quando la coda dei percorsi \/\/ Set this value depending on your other tasks, PLC performance, and G-Code\ncounter := 25;\n\nWHILE counter > 0 AND\n      (poqDataOut = 0 OR_ELSE (NOT poqDataOut^.bFull AND NOT poqDataOut^.bEndOfList))\nDO\n     <Read G-Code and process it>\n\n     counter := counter - 1;\nEND_WHILE Mediante tubazioni nel preelaborazione , anche file G-code molto grandi possono essere letti con requisiti di memoria ridotti e costanti. Le dimensioni della coda sono scelte in modo da consentire una previsione sufficiente dei rispettivi blocchi funzionali La coda di output di SMC_NCInterpreter è anche la coda di input di SMC_SmoothMerge . Un totale di 128+3 elementi sono riservati alla coda di output. 3 è SMC_OutQueue e 128 rimangono da utilizzare come previsione per SMC_SmoothMerge . SMC_SmoothMerge combina un massimo di 128 brevi segmenti lineari in un'unica spline. La coda di output di SMC_SmoothMerge è anche la coda di input di SMC_SmoothPath . SMC_SmoothPath richiede almeno 2 elementi, più una riserva di 3 elementi, come previsione. Se le funzioni M si trovano tra due elementi levigati, sono necessari più elementi in base al numero di La coda di output di SMC_SmoothMerge è anche la coda di input di SMC_Interpolator . Una previsione di 100 elementi è adatta per la maggior parte delle applicazioni. Per ulteriori informazioni, vedere quanto segue: Preelaborazione del percorso e dimensioni della coda. \/\/\/ Buffer of the interpreter, lookahead for SMC_SmoothMerge\naBufIp : ARRAY[0..130] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothMerge\naBufSmm : ARRAY[0..15] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothPath, lookahead for SMC_Interpolator\naBufSmp : ARRAY[0..99] OF SMC_GeoInfo; " }, 
{ "title" : "Preelaborazione di segmenti lineari ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425764624", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Preelaborazione di file G-Code di grandi dimensioni \/ Preelaborazione di segmenti lineari ", 
"snippet" : "Le SMC_SmoothMerge blocco funzionale garantisce una curva di velocità regolare sui numerosi segmenti lineari molto corti. Combina il maggior numero possibile di segmenti lineari consecutivi in un'unica spline, mantenendo le tolleranze specificate. In questo esempio, è consentita una deviazione massi...", 
"body" : "Le SMC_SmoothMerge blocco funzionale garantisce una curva di velocità regolare sui numerosi segmenti lineari molto corti. Combina il maggior numero possibile di segmenti lineari consecutivi in un'unica spline, mantenendo le tolleranze specificate. In questo esempio, è consentita una deviazione massima di 0,1 mm in X e Y ( PARAMETERS.piMaxDifference ). Le figure mostrano l'elaborazione passo dopo passo: Lettura dei brevi segmenti lineari Combinazione di più segmenti lineari in spline utilizzando SMC_SmoothMerge . Lisciatura tra le spline con SMC_SmoothPath perché, come visto sopra, le spline non si connettono tangenzialmente tra loro. " }, 
{ "title" : "Messa in servizio ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425998344", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Preelaborazione di file G-Code di grandi dimensioni \/ Messa in servizio ", 
"snippet" : "Crea l'applicazione e scaricala su un controller. Apri la traccia e scaricala sul controller. Avviare l'applicazione. Puoi tracciare l'elaborazione del codice G....", 
"body" : "Crea l'applicazione e scaricala su un controller. Apri la traccia e scaricala sul controller. Avviare l'applicazione. Puoi tracciare l'elaborazione del codice G. " }, 
{ "title" : "Esempio CNC 16: funzione di sondaggio (distanza residua chiara) (G31) ", 
"url" : "_sm_example_cnc_16.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 16: funzione di sondaggio (distanza residua chiara) (G31) ", 
"snippet" : "Vedi il CNC16_G31.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Il progetto di esempio mostra come utilizzare la funzione di rilevamento (distanza residua chiara). Nell'esempio, la macchina si muove in direzione X fino a raggiungere un...", 
"body" : "Vedi il CNC16_G31.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Il progetto di esempio mostra come utilizzare la funzione di rilevamento (distanza residua chiara). Nell'esempio, la macchina si muove in direzione X fino a raggiungere una barriera luminosa a X=50 . Non appena la barriera fotoelettrica è stata raggiunta, la macchina deve fermarsi. Il G-Code rimanente deve essere elaborato a partire da questa posizione " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224424924168", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 16: funzione di sondaggio (distanza residua chiara) (G31) \/ Struttura dell'applicazione ", 
"snippet" : "La struttura è tipica delle applicazioni CNC. Il codice G viene letto nell'attività in background PathTask ). In questa attività viene eseguita anche la preelaborazione del percorso. L'interpolazione viene eseguita nel task del bus MainTask ). Viene utilizzato il seguente codice G. In blocco N10 , v...", 
"body" : "La struttura è tipica delle applicazioni CNC. Il codice G viene letto nell'attività in background PathTask ). In questa attività viene eseguita anche la preelaborazione del percorso. L'interpolazione viene eseguita nel task del bus MainTask ). Viene utilizzato il seguente codice G. In blocco N10 , viene effettuato un posizionamento rapido per X = 20 . Quindi, con G31 (funzione di rilevamento: percorso residuo libero), viene effettuato un movimento X = 100 . Infine, in blocco N30 , viene effettuato un movimento lineare per X = 20, Y = 50 . N10 G0 X20 F100 E1000 E-1000\nN20 G31 X100\nN30 G1 X20 Y50 L'interazione tra l'interpolatore e l'interprete è particolarmente importante per la funzione di sondaggio (percorso residuo chiaro). L'interprete decodifica il codice G e genera una linea retta da X=20 a X=100 per blocco N20 . Quindi interrompe la decodifica. L'interpolatore esegue il movimento lineare e contemporaneamente emette il numero della sonda come uscita udiActProbe Per il G31, il numero del campione è sempre 1 Nell'applicazione, l'interpolatore viene arrestato con bQuick_Stop non appena l'unità supera la posizione X=50 . (Questo simula la barriera fotoelettrica. Nel compito del bus, SMC_SetInterpreterStartPosition il blocco funzione viene utilizzato per copiare in modo continuo la posizione corrente della macchina. Nel PathTask , la posizione iniziale viene assegnata all'input SMC_NCInterpreter.piStartPosition : inter(\n    sentences:= read.sentences,\n    bExecute:= read.bExecute,\n    nSizeOutQueue:= SIZEOF(bufIpo),\n    pbyBufferOutQueue:= ADR(bufIpo),\n    piStartPosition:= Main.setStart.StartPos); Non appena l'interpolatore viene fermato, bAcknProbe l'input viene utilizzato per riconoscere il comando G31. In un'applicazione reale, è inoltre necessario verificare a questo punto che gli assi abbiano effettivamente raggiunto la posizione di arresto. Il SMC_Inposition a tale scopo è possibile utilizzare il blocco funzione. Ciò fa sì che l'interprete riprenda la decodifica, ma con la posizione iniziale aggiornata in modo che il blocco seguente N30 viene avviato dalla posizione X=55.5 . Il diagramma seguente illustra questi passaggi. I numeri tra parentesi si riferiscono alle fasi corrispondenti del processo sopra descritto " }, 
{ "title" : "Messa in servizio ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224425037675", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 16: funzione di sondaggio (distanza residua chiara) (G31) \/ Messa in servizio ", 
"snippet" : "Crea l'applicazione e scaricala su un controller. Apri la traccia e scaricala sul controller. Avvia l'applicazione e apri la visualizzazione....", 
"body" : "Crea l'applicazione e scaricala su un controller. Apri la traccia e scaricala sul controller. Avvia l'applicazione e apri la visualizzazione. " }, 
{ "title" : "Esempio 17 CNC: lettura del codice G dalle stringhe ", 
"url" : "_sm_example_cnc_17.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio 17 CNC: lettura del codice G dalle stringhe ", 
"snippet" : "Vedi il CNC17_ReadGCodeFromStrings.project progetto di esempio nella directory di installazione di CODESYS in ..\\CODESYS SoftMotion\\Examples . Il progetto di esempio mostra come usare SMC_StringStream2 per leggere il codice G da una stringa. Questo esempio può essere visto come punto di partenza e u...", 
"body" : "Vedi il CNC17_ReadGCodeFromStrings.project progetto di esempio nella directory di installazione di CODESYS in ..\\CODESYS SoftMotion\\Examples . Il progetto di esempio mostra come usare SMC_StringStream2 per leggere il codice G da una stringa. Questo esempio può essere visto come punto di partenza e utilizzato per leggere il codice G da altre fonti, ad esempio tramite comunicazione di rete (socket). In questo caso, è necessario implementare un blocco funzionale che implementa SMC_ITextStream interfaccia e legge il testo (ad esempio, da un socket). Questo è simile a come SMC_StringStream2 implementa questa interfaccia per leggere il codice G da una stringa. " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224424924168", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio 17 CNC: lettura del codice G dalle stringhe \/ Struttura dell'applicazione ", 
"snippet" : "La struttura è tipica delle applicazioni CNC. Il codice G viene letto nell'attività in background PathTask ) e qui avviene anche la preelaborazione del percorso. L'interpolazione viene eseguita nel task del bus Nel Path programma, il SMC_ReadNCFromStream blocco funzione viene utilizzato per leggere ...", 
"body" : "La struttura è tipica delle applicazioni CNC. Il codice G viene letto nell'attività in background PathTask ) e qui avviene anche la preelaborazione del percorso. L'interpolazione viene eseguita nel task del bus Nel Path programma, il SMC_ReadNCFromStream blocco funzione viene utilizzato per leggere il codice G. Per motivi tecnici, non solo uno stream di tipo SMC_StringStream2 viene passato a questo blocco funzione, ma anche a un array la cui dimensione dipende dal parametro SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPTH . Il primo stream dell'array viene utilizzato per il programma principale, mentre gli altri stream vengono utilizzati per eventuali chiamate al sottoprogramma All'inizio, il programma principale viene caricato nel primo flusso dell'array: \/\/ Load G-Code into first stream\naStringStream[0].Init(sProgramName) ;\naStringStream[0].AppendData(sGCode) ;\naStringStream[0].SetEndOfData() ; Quindi tutto è pronto per leggere i soliti programmi G-code. L'esempio mostra anche come possono essere supportate le chiamate ai sottoprogrammi Per fare ciò, è necessario creare un blocco funzione che implementa SMC_INCLookup interfaccia. Questo blocco funzionale è responsabile della restituzione del codice G di un sottoprogramma quando viene letto SMC_ReadNCFromStream . Lookup il metodo riceve il nome del sottoprogramma e inizializza un flusso in entrata con il codice G: METHOD LookUp : SMC_ERROR\nVAR_IN_OUT CONSTANT\n    programName : STRING;\nEND_VAR\nVAR_INPUT\n    stream : SMC_ITextStream;\nEND_VAR\nVAR\n    i : UDINT ;\n    pStringStream : POINTER TO SMC_StringStream2 ;\nEND_VAR Questo esempio esegue una ricerca in una serie di sottoprogrammi. L'array è definito in Path programma come VAR_INPUT : \/\/ The table of subprograms.\n aSubs : ARRAY[0..0] OF SubProgram := [\n            (stName := 'SUB1',\n             stContent := '\nSUBPROGRAM SUB1{#p1 : LREAL, #p2 : LREAL, #p3 : LREAL}\nN10 G1 X#p1\nN20 G1 X#p2\nN30 G1 X#p3\nEND_SUBPROGRAM')\n        ] ; Nel Lookup , l'array viene ripetuto finché non viene trovato un sottoprogramma con un nome corrispondente: i := 0 ;\nWHILE i < nNumSPs DO\n IF psp[i].stName = programName THEN\n IF NOT __QUERYPOINTER(stream, pStringStream) OR_ELSE\n pStringStream = 0\n THEN\n \/\/ A stream of the wrong type has been passed by SMC_ReadNCFromStream.\n LookUp := SMC_CNC_INTERNAL_ERROR ;\n ELSE\n pStringStream^.Init(sName := psp[i].stName) ;\n LookUp := pStringStream^.AppendData(psp[i].stContent) ;\n pStringStream^.SetEndOfData() ;\n END_IF\n RETURN ;\n END_IF\n\n i := i + 1 ;\nEND_WHILE\n \n\/\/ No subprogram with name programName has been found in the array psp.\nLookUp := SMC_RNCF_SUBPROGRAM_FILE_NOT_FOUND ; " }, 
{ "title" : "Messa in servizio ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224425037675", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio 17 CNC: lettura del codice G dalle stringhe \/ Messa in servizio ", 
"snippet" : "Crea l'applicazione e scaricala su un controller. Aprire la visualizzazione. Premere Inizio per avviare l'elaborazione del codice G....", 
"body" : "Crea l'applicazione e scaricala su un controller. Aprire la visualizzazione. Premere Inizio per avviare l'elaborazione del codice G. " }, 
{ "title" : "Esempio CNC 10: Programmazione di percorsi CNC dinamici ", 
"url" : "_sm_example_dynamic_path.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Esempio CNC 10: Programmazione di percorsi CNC dinamici ", 
"snippet" : "Vedi il CNC10_DynamicPath.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come è possibile creare un percorso CNC direttamente nell'applicazione in fase di runtime, non alimentato con codice G da un oggetto programm...", 
"body" : "Vedi il CNC10_DynamicPath.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come è possibile creare un percorso CNC direttamente nell'applicazione in fase di runtime, non alimentato con codice G da un oggetto programma CNC o da un file. Quando viene compilato questo tipo di programma CNC convenzionale, i dati del percorso vengono memorizzati in un file SMC_CNC_Data tipo di struttura dati. Questi dati interni vengono quindi compilati in specifiche strutture di dati globali a seconda della modalità di compilazione ( SMC_CNC_REF o SMC_OutQueue ). In modalità traduzione SMC_CNC_REF i dati sono in una matrice di elementi di tipo SMC_GEOINFO salvato. L'array è in genere collegato all'istanza del blocco funzione nel codice dell'applicazione SMC_NCDecoder devolvere. In fase di esecuzione, i dati vengono qui decodificati e convertiti in una struttura dati globale di tipo SMC_OUTQUEUE scarti. Quindi è possibile richiamare i blocchi di preelaborazione del percorso. In modalità traduzione SMC_OutQueue volere diretto una struttura dati globale ( SMC_OUTQUEUE ) viene generato, che nel codice dell'applicazione viene inviato all'interpolatore (istanza FB SMC_Interpolator ) è passato. Il blocco funzione SMC_NCDecoder non è chiamato. In modalità di compilazione FILE , i dati vengono archiviati in un file. I dati sono memorizzati come un array di elementi di tipo SMC_GEOINFO e corrispondono ai dati che vengono generati in modalità di compilazione SMC_CNC_REF . Invece di programmare il percorso CNC, è possibile programmare un codice applicativo che istanzia una struttura dati di tipo SMC_OUTQUEUE in fase di esecuzione e ne assegna i valori. Si programma un percorso CNC che viene generato dinamicamente in runtime. È possibile passare la struttura dati ad altre istanze di blocchi funzione (ad esempio ai blocchi funzione di preelaborazione del percorso o al blocco funzione SMC_Interpolator ). Programmazione Nella directory di installazione di CODESYS trova il progetto di esempio CNCDynamicPath . Il progetto di esempio è stato rimosso dal progetto CNConline sviluppato. Contiene invece del percorso programmato graficamente Example il programma Path . Crea dinamicamente una struttura dati con tipo SMC_OUTQUEUE . Dichiarazione: Dichiarare una struttura dati di tipo SMC_OUTQUEUE . La struttura dati contiene i dati del percorso CNC ed è popolata dinamicamente. Esempio: QUEUE Allocare memoria per il percorso con la quantità richiesta a SMC_GEOINFO elementi. Esempio: BUF Dichiarare una variabile di tipo SMC_GEOINFO con un primo passo. Esempio: GEO Implementazione: Un elemento dell'array di tipo di dati SMC_GEOINFO corrisponde a un elemento del percorso nel codice CNC. I seguenti passaggi devono essere eseguiti per ogni elemento al fine di aggiungere l'elemento al SMC_OUTQUEUE : Ogni elemento dell'array ha una posizione iniziale che corrisponde alla posizione finale dell'elemento dell'array precedente. Esempio: GEO.piStartPos.dX := 0; o GEO.piStartPos := GEO.piDestPos; Determinare un tipo di movimento per ogni elemento dell'array. Esempio: GEO.iMoveType := CCLW; o GEO.iMoveType := LIN; Imposta i parametri del tipo di movimento. Questo non è richiesto per tutti i tipi di movimento. Esempio: Per un arco (tipo di movimento: CCLW), è richiesta l'impostazione delle seguenti posizioni: geoinfo_A[i].dP1 := 200; geoinfo_A[i].dP2 := 100; geoinfo_A[i].dP3 := 50; geoinfo_A[i].dT1 := 0; geoinfo_A[i].dT2 := 90; Inserire il calcolo della posizione finale. SMC_CalcEndPnt(ADR(GEO)); Inserisci il calcolo della lunghezza dell'oggetto. SMC_CalcLengthGeo(ADR(GEO)); Salva l'oggetto in QUEUE : SMC_AppendObj(POQ:=ADR(QUEUE), PGI:=ADR(GEO)); Quando il percorso è stato creato completamente, gli indicatori di fine devono essere impostati: QUEUE-bEndOfList = TRUE; Quindi, quando viene chiamato un blocco funzione di preelaborazione del percorso, è necessario impostare il bit di inizio o di fine per InternMark . Esempio Percorso CNC con due elementi di percorso In questo esempio, gli array non sono definiti con le posizioni X\/Y. Se questo dovesse essere un esempio con due elementi di percorso come descritto, allora questi array dovrebbero avere due elementi ciascuno. Ad esempio, derivato dal progetto di esempio: xp:ARRAY[1..2] OF REAL:= [100,50]; yp:ARRAY[1..2] OF REAL:= [0,100]; PROGRAM Path\nVAR\n iState : INT;\n QUEUE : SMC_OUTQUEUE;\n BUF : ARRAY[0..49] OF SMC_GEOINFO;\n \/\/ Memory allocation\n GEO : SMC_GEOINFO:=(dT1:=0, dT2:=1, dToolRadius:=0, dVel:=100, dVel_End:=100, dAccel:=200, dDecel:=500, iObj_Nr:=0);\n \/\/ Initial path element\n n : INT := 0;\n QUEUE.nSize := SIZEOF(BUF);\nEND_VAR\n\nCASE iState OF\n0:\n QUEUE.pbyBuffer := ADR(BUF[0]);\n \/\/ Initialize QUEUE\n SMC_SetQueueCapacity(ADR(QUEUE), SIZEOF(BUF));\n iState := iState + 1;\n\n1:\n \/\/ Fill QUEUE\n WHILE NOT QUEUE.bFull DO\n \/\/ When QUEUE is full, wait until it has been processed by the following FBs\n n := n + 1;\n GEO.iSourceLine_No := n;\n GEO.piStartPos := GEO.piDestPos;\n \/\/ Copying last destination\n GEO.iMoveType := LIN;\n \/\/ Generating linear movement\n GEO.iObjNo := GEO.iObjNo + 1;\n \/\/ Calculating number\n GEO.piDestPos.dX := xp[n];\n \/\/ Generatint position\n GEO.piDestPos.dY := yp[n];\n SMC_CalcLengthGeo(pg := ADR(GEO));\n \/\/ Calculating length of object with the help of the standard function\n SMC_AppendObj(poq:=ADR(QUEUE), pgi:=ADR(GEO));\n \/\/ Appending object to QUEUE\n IF n = SIZEOF(xp)\/SIZEOF(xp[1]) THEN\n \/\/ All target positions processed\n QUEUE.bEndOfList := TRUE;\n n := 0;\n iState := 2;\n EXIT;\n END_IF\n END_WHILE\n\n2:\n \/\/Done\n ;\nEND_CASE\n\nCheckVel(bExecute:=TRUE , poqDataIn:=ADR(queue)); \/\/ Preprocessing Se la SMC_OUTQUEUE la struttura dei dati è popolata con SMC_GEOINFO data e l'elemento della struttura dei dati è stato impostato su bFULL = TRUE , quindi sconsigliamo un ulteriore incarico di SMC_GEOINFO dati. In questo caso, la creazione del percorso viene interrotta a runtime fino al primo elemento del SMC_OUTQUEUE la struttura dei dati viene elaborata nell'interpolatore. Solo allora viene inserito un altro elemento. Evitare questa interruzione allocando memoria sufficiente. Vedi variabile BUF . Se la struttura dei dati SMC_OUTQUEUE viene ricaricato dopo la prima esecuzione, quindi l'interpolatore e tutti i blocchi funzione di preelaborazione (esempio: SMC_CheckVelocities ) devono essere riavviati con un fronte di salita a Execute . " }, 
{ "title" : "Utilizzo della ricerca blocchi ", 
"url" : "_sm_example_using_block_search.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Utilizzo della ricerca blocchi ", 
"snippet" : "Una ricerca blocco consente di continuare l'interpolazione dopo un'interruzione. La posizione di arresto viene percorsa per prima e la traiettoria viene percorsa invariata da questa posizione. Per questo, il programma che esegue l'interpolazione e il programma che esegue la preelaborazione del perco...", 
"body" : "Una ricerca blocco consente di continuare l'interpolazione dopo un'interruzione. La posizione di arresto viene percorsa per prima e la traiettoria viene percorsa invariata da questa posizione. Per questo, il programma che esegue l'interpolazione e il programma che esegue la preelaborazione del percorso deve essere esteso. Esempio Una testa di fresatura interrotta arresta la corsa. Dopo essere stato riparato, il percorso può essere proseguito con la ricerca del blocco. Estendi l'applicazione di Istanza del blocco funzione nel task di interpolazione che salva la posizione di preelaborazione Istanza del blocco funzione nell'attività del percorso che accorcia un elemento del percorso Per ulteriori informazioni, vedere: SMC_BlockSearchSavePos, SMC_BlockSearchPos e SMC_BlockSearch Utilizzo della ricerca a blocchi Un'istanza del blocco funzione SMC_BlockSearch deve essere richiamato nello stesso task del resto della preelaborazione del percorso, in genere direttamente prima del blocco funzione SMC_CheckVelocities . quando acceso bExecute è presente un fronte di salita, viene eseguita una ricerca blocco. Dopo l'avvio, viene raggiunta la posizione memorizzata e il percorso viene eseguito invariato da questa posizione. Dichiarare un'istanza di SMC_BlockSearch blocco funzione nel programma eseguito dalla preelaborazione del percorso. bs: SMC_BlockSearch; Attuare l'attivazione del bExecute ingresso del SMC_BlockSearch esempio. Come ingresso epos del blocco funzione SMC_BlockSearch deve essere fatto in anticipo utilizzando il modulo funzione SMC_BlockSearchSavePos la posizione memorizzata viene trasferita. Esempio: ricerca blocco nella preelaborazione del percorso PROGRAM CNC_PreparePath\n...\nVAR\n bs: SMC_BlockSearch;\nEND_VAR\n...\nbs(\n ePos:=CNC.bssp.ePos ,\n bExecute:=rncf.bExecuteDecoder ,\n bAbort:= ,\n bAppend:= ,\n poqDataIn:=ncd.poqDataOut ,\n bStartFromSavedPos:=CNC.bssp.bPositionStored ,\n nSizeOutQueue:=SIZEOF(agiBufBlockSearch) ,\n pbyBufferOutQueue:=ADR(agiBufBlockSearch) ,\n bDone=> ,\n bBusy=> ,\n bError=> ,\n wErrorID=> ,\n poqDataOut=> ); Il bStartFromSavedPos l'ingresso può essere attivato anche con una variabile di controllo. La variabile di controllo può essere attivata dopo una cancellazione per continuare di nuovo dall'ultima posizione salvata. " }, 
{ "title" : "Salvataggio della posizione di pre-elaborazione ", 
"url" : "_sm_example_using_block_search.html#UUID-c7e93ecd-388f-baf1-4162-0ba994d84585_id_defc89f86dbffeecc0a86463490ce87e_id_04188a3f3bea4adbc0a8640e000b4984", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Utilizzo della ricerca blocchi \/ Salvataggio della posizione di pre-elaborazione ", 
"snippet" : "Puoi usare il SMC_BlockSearchSavePos blocco funzione per il salvataggio della posizione corrente su comando. A questo punto, l'istanza del blocco funzione deve essere eseguita nel task dell'interpolatore. Il programma dell'interpolatore nell'esempio si chiama \"CNC\". Dichiarare un'istanza di SMC_Bloc...", 
"body" : "Puoi usare il SMC_BlockSearchSavePos blocco funzione per il salvataggio della posizione corrente su comando. A questo punto, l'istanza del blocco funzione deve essere eseguita nel task dell'interpolatore. Il programma dell'interpolatore nell'esempio si chiama \"CNC\". Dichiarare un'istanza di SMC_BlockSearchSavePos blocco funzione nel programma che esegue l'interpolazione. bssp: SMC_BlockSearchSavePos; Connetti il ipo ingresso del SMC_BlockSearchSavePos istanza all'istanza dell'interpolatore. Connetti il bExecute input a una variabile di controllo che viene impostata nell'applicazione quando il programma CNC viene cancellato (ad esempio se il bAbort è stato impostato l'ingresso dell'istanza SMC_Interpolator). La posizione memorizzata in ePos l'uscita viene utilizzata come segue per la ricerca del blocco tramite SMC_BlockSearc . Dopo l'interruzione, bExecute deve essere resettato con un fronte di salita. Esempio Parte del programma che esegue l'interpolazione con l'istanza di SMC_BlockSearchSavePos blocco funzionale in CFC. " }, 
{ "title" : "ReadNCFile2 con modificatore di token ", 
"url" : "_sm_example_readncfile2_token_modifier.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ ReadNCFile2 con modificatore di token ", 
"snippet" : "Le CNC12_TokenModifier.project il progetto di esempio si trova nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come modificare il codice G durante l'importazione per convertire l'unità di velocità del percorso (parola F) da mm\/min a mm\/s inser...", 
"body" : "Le CNC12_TokenModifier.project il progetto di esempio si trova nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come modificare il codice G durante l'importazione per convertire l'unità di velocità del percorso (parola F) da mm\/min a mm\/s inserendo il codice G. 1\/60.0 * prima del valore della velocità durante la lettura del codice G per la parola F. F6000 quindi diventa F 1\/60.0 * 6000 , che viene successivamente elaborato dal SMC_NCInterpreter blocco funzionale per F100 . In casi semplici, puoi saltare la moltiplicazione per 1\/60 e basta regolare il valore (ad esempio, da 6000 fino a 100 ). Tuttavia, la moltiplicazione è più generale perché funziona anche quando si utilizzano variabili F $SPEED$ diventa F 1\/60.0 * $SPEED$ . " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818233271", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ ReadNCFile2 con modificatore di token \/ Struttura dell'applicazione ", 
"snippet" : "Come di consueto per le applicazioni CNC, l'applicazione consiste nell'elaborazione del percorso ( CNC_PreparePath programma) e interpolazione ( CNC programma). Poiché l'interpolazione non è diversa dagli altri esempi, non verrà discussa ulteriormente qui L'elaborazione del percorso viene chiamata c...", 
"body" : "Come di consueto per le applicazioni CNC, l'applicazione consiste nell'elaborazione del percorso ( CNC_PreparePath programma) e interpolazione ( CNC programma). Poiché l'interpolazione non è diversa dagli altri esempi, non verrà discussa ulteriormente qui L'elaborazione del percorso viene chiamata ciclicamente ogni 20 ms nella modalità a bassa priorità PathTask . L'interpolazione viene chiamata ciclicamente ogni 4 ms MotionTask . L'attività in background VISU_TASK è definito per la visualizzazione. È possibile iniziare a elaborare il codice G nella visualizzazione. Il codice G e il movimento della macchina (portale 3D) sono visualizzati sul lato destro della " }, 
{ "title" : "Il codice G ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818432406", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ ReadNCFile2 con modificatore di token \/ Il codice G ", 
"snippet" : "CNC_PathSpeed N10 G01 X1000 F6000 N20 Y1000 In questo codice G, la velocità del percorso in blocco N10 è impostato con F6000 fino a 6000 mm\/min. Tuttavia, i blocchi funzionali CNC prevedono la velocità del percorso in mm\/s. Vengono comandati due movimenti lineari X=1000 e poi a X=1000, Y=1000 ....", 
"body" : "CNC_PathSpeed N10 G01 X1000 F6000\nN20 Y1000 In questo codice G, la velocità del percorso in blocco N10 è impostato con F6000 fino a 6000 mm\/min. Tuttavia, i blocchi funzionali CNC prevedono la velocità del percorso in mm\/s. Vengono comandati due movimenti lineari X=1000 e poi a X=1000, Y=1000 . " }, 
{ "title" : "Elaborazione dei token ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819460923", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ ReadNCFile2 con modificatore di token \/ Elaborazione dei token ", 
"snippet" : "Le SMC_ReadNCFile2 e SMC_ReadNCFromStream i blocchi funzione forniscono la capacità di eseguire le proprie trasformazioni quando viene letto il codice G. Qui stiamo usando con SMC_ITokenModifier interfaccia, che viene passata tramite aTokenModifier input. Questa interfaccia funziona su «token». Ques...", 
"body" : "Le SMC_ReadNCFile2 e SMC_ReadNCFromStream i blocchi funzione forniscono la capacità di eseguire le proprie trasformazioni quando viene letto il codice G. Qui stiamo usando con SMC_ITokenModifier interfaccia, che viene passata tramite aTokenModifier input. Questa interfaccia funziona su «token». Queste sono le parti base del codice G in cui viene suddiviso il testo del codice G all'avvio dell'elaborazione Esempio N50 G36 O$plc_variable$ D'TextTest' X-1 (Comment) Questo codice G è suddiviso come segue: Testo SMC_TOKENTYPE SMC_TOKENVALUE N identifer stValue = 'N' 50 number fValue = 50.0 G identifer stValue = 'G' 36 number fValue = 36.0 O identifer stValue = 'O' $plc_variable$ variable stValue = 'plc_variable' D identifer stValue = 'D' 'TextTest' strLiteral stValue = 'TextTest' X identifer stValue = 'X' - operator stValue = '-' 1 number fValue = 1.0 Le informazioni che non sono necessarie per l'ulteriore elaborazione (ad esempio, spazi bianchi, interruzioni di riga e commenti) non vengono visualizzate nell'elenco dei token. Quando il SMC_ITokenModifier l'interfaccia è implementata, l'elenco dei token può essere adattato aggiungendo nuovi token, eliminando i token e modificando i valori dei token. L'interfaccia definisce due metodi: Start : inizializzazione del blocco funzionale. Lo stato interno viene ripristinato Call : Chiamata di questo metodo durante l'elaborazione del codice G. I token possono essere letti e rimossi dalla coda di input e aggiunti alla coda " }, 
{ "title" : "Attuazione ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819739016", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ ReadNCFile2 con modificatore di token \/ Attuazione ", 
"snippet" : "Il flusso di elaborazione in PLC_PRG è il seguente: Tutti i token vengono spostati dalla coda di input alla coda di output. Se viene rilevata una parola F, allora due nuovi token, 1\/60 e * , vengono aggiunti dopo il token per «F» e prima del token per il valore della velocità. Le Call il metodo cont...", 
"body" : "Il flusso di elaborazione in PLC_PRG è il seguente: Tutti i token vengono spostati dalla coda di input alla coda di output. Se viene rilevata una parola F, allora due nuovi token, 1\/60 e * , vengono aggiunti dopo il token per «F» e prima del token per il valore della velocità. Le Call il metodo contiene la logica per elaborare i token. È utile spostare prima i token dalla coda di input tokensIn ) in una coda temporanea ( m_tmpQueue ), li elabora lì e poi li sposta nella coda di output ( tokensOut ). La coda temporanea non è assolutamente necessaria per adattare la velocità del percorso, ma semplifica la struttura del programma nei Metodo: chiamata Inizialmente, il sistema attende STATE_RUNNING stato fino all'inizio dell'elaborazione (quando i token sono disponibili nella coda di input e c'è ancora spazio nella coda di output). IF NOT SMC_NC_CanProcessTokens(tokensIn, tokensOut) THEN\n    \/\/ Wait until processing can proceed\n    RETURN;\nEND_IF Quindi un token viene spostato dalla coda di input alla coda temporanea. IF m_tmpQueue.IsEmpty() THEN\n    \/\/ Move the next token from the in-queue to the tmp-queue.\n  pt := tokensIn.GetFromStart(0);\n    m_tmpQueue.Append(pt^);\n    tokensIn.RemoveFirst();\nEND_IF L'elaborazione effettiva viene effettuata nel ConvertSpeed metodo. IF NOT m_tmpQueue.IsEmpty() THEN\n    \/\/ The actual processing is done here\n    ConvertSpeed();\nEND_IF Alla fine del metodo, un token viene spostato dalla coda temporanea alla coda di output. Metodo: ConvertSpeed Viene selezionato il primo token della coda temporanea. Se un identificatore con il valore F viene trovato, quindi vengono aggiunti due token aggiuntivi: il numero 1\/60.0 e l'operatore * . (La dimensione della coda temporanea è selezionata in modo tale che altri due token entrino nella coda oltre a quello della coda di input). tk := m_tmpQueue.GetFromStart(0)^;\n\nIF tk.tokenType = SMC_TokenType.identifier THEN\n tk.GetString(pbyString => pby, iSize => iSize);\n \/\/ 70 = ASCII code for F (path velocity)\n IF iSize = 1 AND pby^ = 70 THEN\n \/\/ Insert the number 1\/60\n SMC_Token_InitNumber(\n tk:= tkNumber,\n value:= 1\/60.0,\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkNumber);\n\n \/\/ Insert operator '*' for multiplication\n SMC_Token_InitOperator(\n tk:= tkOperator,\n value:= '*',\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkOperator);\n END_IF\nEND_IF " }, 
{ "title" : "Messa in servizio ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869820021001", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ ReadNCFile2 con modificatore di token \/ Messa in servizio ", 
"snippet" : "Crea l'applicazione e scaricala su un controller. Avviare l'applicazione, passare alla visualizzazione e premere Start ....", 
"body" : "Crea l'applicazione e scaricala su un controller. Avviare l'applicazione, passare alla visualizzazione e premere Start . " }, 
{ "title" : "Funzioni G-Code specifiche per l'utente ", 
"url" : "_sm_custom_g_code_functions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Funzioni G-Code specifiche per l'utente ", 
"snippet" : "Le CNC11_CustomFunctions.project il progetto di esempio si trova nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come creare funzioni personalizzate da utilizzare nelle espressioni in codice G. Per ulteriori informazioni sulle espressioni e le...", 
"body" : "Le CNC11_CustomFunctions.project il progetto di esempio si trova nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come creare funzioni personalizzate da utilizzare nelle espressioni in codice G. Per ulteriori informazioni sulle espressioni e le funzioni in codice G, vedere: espressioni. Lì troverai un elenco di tutti gli operatori e le funzioni supportati di default. L'esempio definisce SEL operatore conforme alla norma IEC 61131-3 in modo che possa essere utilizzato anche nel codice G. " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867931475267", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Funzioni G-Code specifiche per l'utente \/ Struttura dell'applicazione ", 
"snippet" : "Come di consueto per le applicazioni CNC, l'applicazione consiste nell'elaborazione del percorso ( CNC_PreparePath programma) e interpolazione ( CNC programma). Poiché l'interpolazione non differisce dagli altri esempi, l'argomento non verrà discusso ulteriormente qui L'elaborazione del percorso vie...", 
"body" : "Come di consueto per le applicazioni CNC, l'applicazione consiste nell'elaborazione del percorso ( CNC_PreparePath programma) e interpolazione ( CNC programma). Poiché l'interpolazione non differisce dagli altri esempi, l'argomento non verrà discusso ulteriormente qui L'elaborazione del percorso viene chiamata ciclicamente ogni 20 ms nella modalità a bassa priorità PathTask . L'interpolazione viene chiamata ciclicamente ogni 4 ms MotionTask . L'attività in background VISU_TASK è definito per la visualizzazione. Nella visualizzazione, puoi iniziare a elaborare il codice G e impostare il valore della variabile $LONGLINE$ . Il codice G e il movimento della macchina (portale 3D) sono visualizzati sul lato destro della " }, 
{ "title" : "Il codice G ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867932695176", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Funzioni G-Code specifiche per l'utente \/ Il codice G ", 
"snippet" : "CNC LET #WIDTH : LREAL N10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110) N20 F50 E100 E-100 N30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2 N40 Y-#WIDTH N50 X-#WIDTH Z-#WIDTH\/2 N60 Y#WIDTH N70 X0 Y0 Z0 Linea 1: Dichiarazione della variabile locale #WIDTH di tipo LREAL . Linea 2, Blocco N10: Assegnazione del valore di SE...", 
"body" : "CNC LET #WIDTH : LREAL\nN10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110)\nN20 F50 E100 E-100\nN30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2\nN40 Y-#WIDTH\nN50 X-#WIDTH Z-#WIDTH\/2\nN60 Y#WIDTH\nN70 X0 Y0 Z0 Linea 1: Dichiarazione della variabile locale #WIDTH di tipo LREAL . Linea 2, Blocco N10: Assegnazione del valore di SEL($LONGLINE$, 40, 110) alla variabile #WIDTH . Se il valore della variabile PLC $LONGLINE$ è TRUE , allora il valore dell'espressione è 110; altrimenti è 40. Nelle righe seguenti, viene attraversato un rettangolo con movimento aggiuntivo in direzione Z; la lunghezza di un lato del rettangolo è 2*#WIDTH . " }, 
{ "title" : "Implementazione del SEL funzione ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867935164437", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Funzioni G-Code specifiche per l'utente \/ Implementazione del SEL funzione ", 
"snippet" : "Per creare una funzione definita dall'utente, è necessario scrivere un blocco funzione che implementa il SMC_NC_IFunction interfaccia. Per ulteriori informazioni, vedere: Funzione SMC_NC_I . L'interfaccia definisce due metodi: GetSignature . Il tipo restituito, il conteggio e i tipi degli argomenti ...", 
"body" : "Per creare una funzione definita dall'utente, è necessario scrivere un blocco funzione che implementa il SMC_NC_IFunction interfaccia. Per ulteriori informazioni, vedere: Funzione SMC_NC_I . L'interfaccia definisce due metodi: GetSignature . Il tipo restituito, il conteggio e i tipi degli argomenti della funzione vengono restituiti qui. In questo esempio, SEL la funzione restituisce un valore di tipo T_OTHER e ha 3 argomenti di tipo T_BOOL , T_OTHER , e T_OTHER . T_OTHER sta per qualsiasi tipo (o T_BOOL , T_LREAL , oppure T_STRING ]. Tutte e 3 le occorrenze di T_OTHER deve essere dello stesso tipo. METHOD GetSignature\nVAR_OUTPUT\n    resultType : SMC_GVar_Type;\n    nNumArguments : UDINT;\n    pType : POINTER TO SMC_GVar_Type;\nEND_VAR\nVAR    argTypes : ARRAY[0..2] OF SMC_GVar_Type :=\n        [SMC_GVar_Type.T_BOOL,\n         SMC_GVar_Type.T_OTHER,\n         SMC_GVar_Type.T_OTHER];\nEND_VAR\n\nresultType := SMC_GVAR_Type.T_OTHER;\nnNumArguments := 3;\npType := ADR(argTypes); Call : Questo metodo viene chiamato durante l'elaborazione del codice G. Gli argomenti vengono passati tramite pa ingresso. L'espressione pa[0].argValue.bValue viene utilizzato per accedere al valore booleano del primo argomento. A seconda del tipo del secondo argomento pa[1].argType , il risultato è il valore restituito result.argType e la ramificazione in un'istruzione CASE. METHOD Call\nVAR_IN_OUT\n    result : SMC_NC_GArgument;\nEND_VAR\nVAR_INPUT\n    pa : POINTER TO SMC_NC_GArgument;\nEND_VA\nRVAR_OUTPUT\n    eError : SMC_ERROR;\nEND_VAR\nVAR\n    g : BOOL;\nEND_VAR\n\ng := pa[0].argValue.bValue;\n\nresult.argType := pa[1].argType;\n\nCASE result.argType OF\nSMC_GVAR_Type.T_BOOL:\n    result.argValue.bValue := SEL(g, pa[1].argValue.bValue, pa[2].argValue.bValue);\n\nSMC_GVAR_Type.T_STRING:\n    result.argValue.sValue := SEL(g, pa[1].argValue.sValue, pa[2].argValue.sValue);\n\nSMC_GVAR_Type.T_LREAL:\n    result.argValue.fValue := SEL(g, pa[1].argValue.fValue, pa[2].argValue.fValue);\n\nELSE\n    eError := SMC_INVALID_PARAMETER;\nEND_CASE " }, 
{ "title" : "Configurazione di SMC_ReadNCFile2 ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867956933133", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Funzioni G-Code specifiche per l'utente \/ Configurazione di SMC_ReadNCFile2 ", 
"snippet" : "Un esempio di CNC_Sel il blocco funzione viene creato in GVL_CNCFunctions elenco globale delle variabili. Un array aCNCFunctions di lunghezza 1 viene inizializzato con il nome e l'istanza del blocco funzione. Questo array viene quindi collegato nella tabella funTable di tipo SMC_NC_GFunctionTable . ...", 
"body" : "Un esempio di CNC_Sel il blocco funzione viene creato in GVL_CNCFunctions elenco globale delle variabili. Un array aCNCFunctions di lunghezza 1 viene inizializzato con il nome e l'istanza del blocco funzione. Questo array viene quindi collegato nella tabella funTable di tipo SMC_NC_GFunctionTable . aCNCFunctions : ARRAY[0..0] OF SMC_NC_GFunction :=\n    [(stName:= 'SEL', iFunc:= GVL_CNCFunctions.g_Sel)];\n\nfunTable : SMC_NC_GFunctionTable :=\n    (numFunctions:= 1,     pFunction:= ADR(aCNCFunctions)) ; Infine, questa tabella viene passata al SMC_ReadNCFile2 blocco funzionale: rncf2 : SMC_ReadNCFile2 := (bParenthesesAsComments:= FALSE);\n\n[...]\n\nrncf2(\n    bExecute:= TRUE,\n    sFileName:= sFileName,\n    pCustomFunTable:= ADR(funTable),\n    pvl:= ADR(varList)); " }, 
{ "title" : "Messa in servizio ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867960408693", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Esempi \/ Funzioni G-Code specifiche per l'utente \/ Configurazione di SMC_ReadNCFile2 \/ Messa in servizio ", 
"snippet" : "Crea l'applicazione e scaricala su un controller. Avviare l'applicazione, passare alla visualizzazione e premere Start . Puoi usare Longline pulsante radio per impostare il valore della variabile $LONGLINE$ nel codice G per TRUE o FALSE ....", 
"body" : "Crea l'applicazione e scaricala su un controller. Avviare l'applicazione, passare alla visualizzazione e premere Start . Puoi usare Longline pulsante radio per impostare il valore della variabile $LONGLINE$ nel codice G per TRUE o FALSE . " }, 
{ "title" : "Interfaccia utente ", 
"url" : "_sm_cnc_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comando: Analizza la dinamica ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Analizza la dinamica ", 
"snippet" : "Analizza le dinamiche Funzione : Il comando avvia un'analisi dinamica del percorso CNC attivo nell'editor. Allo stesso tempo, le dimensioni di posizione, velocità, accelerazione e strappo della traiettoria CNC vengono determinate in base al tempo e vengono visualizzate nei grafici temporali del Anal...", 
"body" : "Analizza le dinamiche Funzione : Il comando avvia un'analisi dinamica del percorso CNC attivo nell'editor. Allo stesso tempo, le dimensioni di posizione, velocità, accelerazione e strappo della traiettoria CNC vengono determinate in base al tempo e vengono visualizzate nei grafici temporali del Analisi Dinamica dialogo. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Per eseguire un'analisi dinamica del percorso CNC, non devono esserci errori nel calcolo della loro preelaborazione del percorso. Per ulteriori informazioni, vedere: Mostra percorso preelaborato" }, 
{ "title" : "Finestra di dialogo: analisi dinamica ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html#UUID-172573a8-7bc5-69ee-931b-3074ace95453_id_f14ff69a244133a5c0a8640e0144954d_id_72da7ed158aa22a9c0a864637a09d164", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Analizza la dinamica \/ Finestra di dialogo: analisi dinamica ", 
"snippet" : "Le impostazioni nella finestra di dialogo vengono utilizzate esclusivamente per visualizzare l'analisi dinamica e non hanno alcun effetto sul programma CNC o sulle impostazioni CNC. Nell'analisi dinamica, le curve temporali per le dimensioni di posizione, velocità, accelerazione e strappo sono deter...", 
"body" : "Le impostazioni nella finestra di dialogo vengono utilizzate esclusivamente per visualizzare l'analisi dinamica e non hanno alcun effetto sul programma CNC o sulle impostazioni CNC. Nell'analisi dinamica, le curve temporali per le dimensioni di posizione, velocità, accelerazione e strappo sono determinate per l'intero percorso percorso. I grafici temporali sono mostrati nella finestra di dialogo sullo stesso asse temporale. Vengono utilizzate le impostazioni della finestra di dialogo (preimpostate o salvate). Grafico di posizione Curva di posizione dell'asse selezionato (nero) Cerchio rosso; indica l'inizio di un elemento di percorso Il tooltip del marker fornisce informazioni sui numeri di riga nel rispettivo codice G o nella tabella. Grafico della velocità Curva di velocità dell'asse selezionato (blu) Grafico di accelerazione Curva di accelerazione dell'asse selezionato (verde) Grafico a scatti Curva di strappo dell'asse selezionato (arancione) Le impostazioni vengono salvate alla chiusura e utilizzate alla successiva apertura della finestra di dialogo. Ad esempio, il fattore di zoom rende visibile solo una parte della curva. Ingrandisce una parte delle curve temporali Alternativa: Ctrl + + Ctrl + Rotellina del mouse Riduce le curve temporali Alternativa: Ctrl + - Ctrl + Rotellina del mouse Ingrandisce le curve temporali in modo da visualizzare tutti i percorsi CNC Asse Selezione degli assi: X , Y , Z , A , B , C , A1(P) , A2(Q) , A3 (U) , A4(V) , A5(W) , A6 , o Il percorso Preimpostato: X asse Il percorso asse: Visualizzazione della posizione del percorso, della velocità del percorso, dell'accelerazione del percorso e dello strappo del percorso Tempo di ciclo [µs] Valore per il dwIpoTime ingresso del SMC_Interpolator blocco funzione Preimpostazione: valore Tempo ciclo [µs] in oggetto Impostazioni CNC (tab Preinterpolazione ) Modalità velocità Valore per il iVelMode ingresso del SMC_Interpolatore blocco funzione trapezio Profilo di velocità trapezoidale Sigmoide Piace trapezio , ma i fronti di salita o di discesa sono sostituiti da funzioni sin² della stessa superficie. In questa modalità di velocità, il valore limite viene superato di circa un fattore di \/2. Sigmoide limitato Piace Sigmoide , ma la durata dell'interpolazione del percorso è la stessa lunghezza della modalità velocità trapezio . Predefinito quadratico Profilo di accelerazione in forma trapezoidale con limitazione dello strappo Il jerk raggiunge un valore massimo in Coglione massimo [u\/s³] . Ciò si traduce in un profilo di velocità quadratico. Il profilo di posizione è costituito da polinomi di terzo grado. Il risultato è che il profilo di velocità è costituito da parabole, l'accelerazione è costituita da segmenti lineari e il jerk è costituito da segmenti di linea orizzontali. Coglione massimo [u\/s³] Limitazione dello strappo " }, 
{ "title" : "Comando: Importa da file DXF ", 
"url" : "_sm_cmd_cnc_dxf_import.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Importa da file DXF ", 
"snippet" : "Importa da file DXF Funzione : Il comando apre la finestra di dialogo predefinita. Dopo aver selezionato il file, il Importa file DXF si apre la finestra di dialogo per configurare l'importazione di un file DXF nell'editor CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un oggetto CNC. Res...", 
"body" : "Importa da file DXF Funzione : Il comando apre la finestra di dialogo predefinita. Dopo aver selezionato il file, il Importa file DXF si apre la finestra di dialogo per configurare l'importazione di un file DXF nell'editor CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un oggetto CNC. Restrizioni dello standard DXF all'importazione dei file SPLINE gli elementi non vengono importati esattamente. Solo i punti di controllo vengono letti e posizionati da queste spline cardinali. I riferimenti esterni non sono supportati. (Questi sono riferimenti ad altri file DXF in a BLOCK elemento.) Le ellissi sono supportate solo nella misura in cui esistono nel piano X\/Y. Archi (elemento ARC ) e cerchi (elemento CIRCLE ) sono supportati solo quando la scala è uguale in tutti gli assi spaziali (parametri 41, 42 e 43 dell'elemento INSERT ). Questo influenza anche gli elementi POLYLINE e LWPOLYLINE che includono archi (parametro bulge non uguale a 0 ). Riferimenti di blocco (elemento INSERT ) sono supportati solo quando la matrice di ridimensionamento non è uno specchio. (Il prodotto dei fattori di scala deve essere positivo.) Gli elementi area, le mesh poligonali e le mesh poliedriche non sono supportati. Elementi solidi ( SOLID , …) non sono supportati. Gli elementi MLINE (multilinea), RAY , XLINE , e LEADER (linea principale) non sono supportati. Gli elementi TEXT , MTEXT , e DIMENSION non sono supportati. Lo spessore, il colore e lo stile della linea vengono ignorati, così come le informazioni sulla visibilità degli elementi. File DXF binari (estensione file DXB ) non sono supportati. Gli elementi non supportati vengono ignorati (implicitamente) all'importazione. " }, 
{ "title" : "Finestra di dialogo: Importa file DXF ", 
"url" : "_sm_cmd_cnc_dxf_import.html#UUID-ceb47740-324e-76a2-abd9-2d1fa27e1a26_id_fde6e1824400e36c0a8640e013dba7a_id_754451675df6e481c0a8646326153262", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Importa da file DXF \/ Finestra di dialogo: Importa file DXF ", 
"snippet" : "strati Tutti gli strati del disegno tecnico; determinato dai dati nel file DXF : Il livello verrà importato. Dimensione massima della distanza Distanza tra i punti estremi degli elementi geometrici fino a quando i punti sono visti come interconnessi. Determinato dai dati nel file DXF. Esempio: 0.001...", 
"body" : "strati Tutti gli strati del disegno tecnico; determinato dai dati nel file DXF : Il livello verrà importato. Dimensione massima della distanza Distanza tra i punti estremi degli elementi geometrici fino a quando i punti sono visti come interconnessi. Determinato dai dati nel file DXF. Esempio: 0.001 Anteprima su percorso CNC I dati del file DXF selezionato vengono visualizzati nel modo in cui vengono importati nell'editor CNC. Viene preso in considerazione anche il livello selezionato per la visualizzazione. Esempio: Visualizzazione Per cambiare il livello considerato nella finestra di anteprima. piano x\/y; selezionato per la visualizzazione piano x\/z piano y\/z Pulsante ' Importare ' I dati vengono caricati nell'editor CNC e il programma CNC esistente viene sostituito. I numeri di blocco vengono assegnati automaticamente. L'oggetto CNC mantiene il suo nome. " }, 
{ "title" : "Comando: Info CNC ", 
"url" : "_sm_cmd_cnc_info.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Info CNC ", 
"snippet" : "Informazioni CNC Funzione : Il comando apre il Informazioni CNC sul programma <name> dialogo. Chiamata : CNC menù Menu contestuale di un oggetto (tipo Programma CNC ) Requisiti : Nell'editor è aperto un programma CNC. Finestra di dialogo: codice generato La finestra di dialogo mostra il codice di in...", 
"body" : "Informazioni CNC Funzione : Il comando apre il Informazioni CNC sul programma <name> dialogo. Chiamata : CNC menù Menu contestuale di un oggetto (tipo Programma CNC ) Requisiti : Nell'editor è aperto un programma CNC. Finestra di dialogo: codice generato La finestra di dialogo mostra il codice di inizializzazione IEC del programma CNC attivo, a seconda della modalità di compilazione per il blocco funzione SMC_OutQueue o SMC_CNC_REF . Esempio: codice di inizializzazione IEC {attribute 'linkalways'}\nVAR_GLOBAL\n {attribute 'init_on_onlchange'}\n {attribute 'init_on_onlchange'}\n Example : SMC_CNC_REF := (nElements := 22, strProgramName := 'Example', piStartPosition := (iFrameNo:=0, wAuxData:=7, wSProfile:=0, dX:=0, dY:=0, dZ:=0, dA:=0, dB:=0, dC:=0, dA1:=0, dA2:=0, dA3:=0, dA4:=0, dA5:=0, dA6:=0), pgc := ADR(Example_D), xPartofLM := TRUE);\n {attribute 'blobinit'}\n {attribute 'init_on_onlchange'}\n Example_D : ARRAY[0..21] OF SMC_GCODE_WORD := [\n {p 35184372088832 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 70, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 69, fValue:=100, diValue:=100),\n {p 35184372088832 }\n (byLetter := 69, fValue:=-100, diValue:=-100),\n {p 35184372088832 }\n (byLetter := 128, fValue:=1, diValue:=1),\n {p 36283883716609 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 36835250143233 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 38486665068545 }\n (byLetter := 88, pAdr := ADR(g_x), byVarType := ANY_TO_BYTE(__TYPEOF(g_x) + 32)),\n {p 36291399909377 }\n (byLetter := 89, fValue:=0, diValue:=0),\n {p 36842766336001 }\n (byLetter := 70, fValue:=50, diValue:=50),\n {p 36844913819649 }\n (byLetter := 69, fValue:=30, diValue:=30),\n {p 37396817117185 }\n (byLetter := 69, fValue:=-30, diValue:=-30),\n {p 35184372088832 }\n (byLetter := 128, fValue:=2, diValue:=2),\n {p 36833639530498 }\n (byLetter := 78, fValue:=10, diValue:=10),\n {p 36835787014146 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683906 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 38488812552194 }\n (byLetter := 89, pAdr := ADR(g_y), byVarType := ANY_TO_BYTE(__TYPEOF(g_y) + 32)),\n {p 35184372088832 }\n (byLetter := 128, fValue:=3, diValue:=3),\n {p 36833639530499 }\n (byLetter := 78, fValue:=20, diValue:=20),\n {p 36835787014147 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683907 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 36289789296643 }\n (byLetter := 89, fValue:=0, diValue:=0)];\nEND_VAR " }, 
{ "title" : "Informazioni CNC del programma <nome> Dialogo ", 
"url" : "_sm_cmd_cnc_info.html#UUID-ad8caf78-e0cf-3500-0750-16c2eb5fabe7_id_dc9afe4124423d69c0a8640e01f781e8_id_fc2c1e2959841990c0a864630e5a26e5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Info CNC \/ Informazioni CNC del programma <nome> Dialogo ", 
"snippet" : "La finestra di dialogo fornisce informazioni sul programma CNC specificato. Nome del programma Esempio: Workpiece_1 Versione dei blocchi funzione Esempio: 4.2.0.0 Numero di righe Esempio: 5 Numero di oggetti Esempio: 3 Lunghezza del percorso [unità] Esempio: 261.803398874992 Durata [s] Tempo (in sec...", 
"body" : "La finestra di dialogo fornisce informazioni sul programma CNC specificato. Nome del programma Esempio: Workpiece_1 Versione dei blocchi funzione Esempio: 4.2.0.0 Numero di righe Esempio: 5 Numero di oggetti Esempio: 3 Lunghezza del percorso [unità] Esempio: 261.803398874992 Durata [s] Tempo (in secondi) per percorrere il percorso preelaborato Esempio: 10.158 Requisito: preelaborazione del percorso senza errori e punti di interpolazione generati correttamente Mostra codice generato Il Codice generato si apre la finestra di dialogo. Presupposto: il programma non contiene errori. " }, 
{ "title" : "Comando: Carica programma da file ASCII ", 
"url" : "_sm_cmd_cnc_load_program_from_ascii_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Carica programma da file ASCII ", 
"snippet" : "Carica programma da file ASCII Funzione : Il comando carica an ASCII file con i dati del programma CNC nell'editor CNC. L'oggetto CNC mantiene il suo nome. Chiamata : CNC menù Requisiti : Nell'editor è aperto un oggetto CNC. Il comando apre la finestra di dialogo predefinita per la ricerca nel file ...", 
"body" : "Carica programma da file ASCII Funzione : Il comando carica an ASCII file con i dati del programma CNC nell'editor CNC. L'oggetto CNC mantiene il suo nome. Chiamata : CNC menù Requisiti : Nell'editor è aperto un oggetto CNC. Il comando apre la finestra di dialogo predefinita per la ricerca nel file system. Il filtro deve essere impostato su CNC, GCODE o TXT. Il file selezionato viene caricato nell'editor CNC attivo. Qualsiasi programma CNC esistente viene sovrascritto (dopo un'altra query). " }, 
{ "title" : "Comando: sposta programma ", 
"url" : "_sm_cmd_cnc_move_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: sposta programma ", 
"snippet" : "Sposta programma Funzione : Il comando apre il Vettore di traduzione finestra di dialogo per la configurazione di uno spostamento della traiettoria CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC....", 
"body" : "Sposta programma Funzione : Il comando apre il Vettore di traduzione finestra di dialogo per la configurazione di uno spostamento della traiettoria CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. " }, 
{ "title" : "vincolo ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_e69692297289ca8ec0a864631a178469", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: sposta programma \/ vincolo ", 
"snippet" : "Lo spostamento del percorso CNC è possibile alle seguenti condizioni: Nessun utilizzo dell'asse A, B o C di variabili...", 
"body" : "Lo spostamento del percorso CNC è possibile alle seguenti condizioni: Nessun utilizzo dell'asse A, B o C di variabili " }, 
{ "title" : "Finestra di dialogo: vettore di traduzione ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: sposta programma \/ Finestra di dialogo: vettore di traduzione ", 
"snippet" : "Vettore di traslazione in coordinate per tutti gli assi X Predefinito: 1.0000000 Y Z P Q U V W ok Questo sposta il percorso del CNC. Inoltre, viene inserito un comando G0 (comando di posizionamento relativo) con le coordinate del vettore di traslazione nel programma CNC prima del primo comando di po...", 
"body" : "Vettore di traslazione in coordinate per tutti gli assi X Predefinito: 1.0000000 Y Z P Q U V W ok Questo sposta il percorso del CNC. Inoltre, viene inserito un comando G0 (comando di posizionamento relativo) con le coordinate del vettore di traslazione nel programma CNC prima del primo comando di posizionamento. I comandi di posizionamento sono G1, G2, G3, G5, G6, G8, G9, G10, G11 e G92. Se i comandi G54, G55 o G56 spostano il sistema di coordinate nel programma CNC, gli argomenti vengono adattati in questi comandi. I blocchi fino a G53 no dot richiedono ulteriori adattamenti. Se un comando G56 è il primo comando di posizionamento, viene adattato solo quel comando. I numeri di blocco vengono assegnati automaticamente. " }, 
{ "title" : "Comando: Rinumera programma CNC ", 
"url" : "_sm_cmd_cnc_renumber_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Rinumera programma CNC ", 
"snippet" : "Rinumera programma CNC Simbolo: Funzione : Il comando aggiorna la numerazione delle righe di programma nel programma CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. I numeri iniziano da 0 e vengono incrementati di 10. Ogni blocco senza numero di blocco riceve un numero. Il...", 
"body" : "Rinumera programma CNC Simbolo: Funzione : Il comando aggiorna la numerazione delle righe di programma nel programma CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. I numeri iniziano da 0 e vengono incrementati di 10. Ogni blocco senza numero di blocco riceve un numero. Il codice L nei blocchi G20 è corretto. " }, 
{ "title" : "Comando: inverti direzione ", 
"url" : "_sm_cmd_cnc_reverse_direction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: inverti direzione ", 
"snippet" : "Inverti direzione Funzione : Il comando inverte il programma CNC e imposta gli elementi del percorso in ordine inverso. Anche i numeri di blocco del programma CNC vengono ripristinati automaticamente. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. vincolo L'inversione del perc...", 
"body" : "Inverti direzione Funzione : Il comando inverte il programma CNC e imposta gli elementi del percorso in ordine inverso. Anche i numeri di blocco del programma CNC vengono ripristinati automaticamente. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. vincolo L'inversione del percorso CNC è possibile alle seguenti condizioni: Se per il programma CNC è stata selezionata la preelaborazione, i blocchi G41\/G42 vengono elaborati nel programma inverso: G41 diventa G42 e G42 diventa G41. Anche la direzione della correzione è invertita. Se il programma CNC contiene archi definiti con un angolo di apertura (parametro K per elementi 2D o parametro T per elementi 3D), il comando non genera archi invertiti esatti. Se il percorso CNC è stato programmato con i seguenti mezzi, l'inversione non è possibile. Nessuna inversione quando Utilizzo dell'asse A, B o C Utilizzo delle variabili Chiamare la soppressione del passo " }, 
{ "title" : "Comando: ruota programma ", 
"url" : "_sm_cmd_cnc_rotate_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: ruota programma ", 
"snippet" : "Ruota programma Funzione : Il comando apre il Parametri di rotazione finestra di dialogo in cui è configurata la rotazione del percorso CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC....", 
"body" : "Ruota programma Funzione : Il comando apre il Parametri di rotazione finestra di dialogo in cui è configurata la rotazione del percorso CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. " }, 
{ "title" : "vincolo ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_45841f775e56fd50c0a864632eb28d67", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: ruota programma \/ vincolo ", 
"snippet" : "La rotazione del percorso CNC è possibile alle seguenti condizioni: Nessun utilizzo dell'asse A, B o C di variabili...", 
"body" : "La rotazione del percorso CNC è possibile alle seguenti condizioni: Nessun utilizzo dell'asse A, B o C di variabili " }, 
{ "title" : "Finestra di dialogo: parametri di rotazione ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: ruota programma \/ Finestra di dialogo: parametri di rotazione ", 
"snippet" : "Angolo (gradi) Angolo di rotazione (in gradi) intorno al Asse rotante . Esempio: Dato Rotazione attorno all'asse Z L'asse X punta a destra e l'asse Y punta verso il basso. La direzione di visualizzazione è contro l'asse di rotazione (regola della mano destra). Per un valore negativo, la rotazione vi...", 
"body" : "Angolo (gradi) Angolo di rotazione (in gradi) intorno al Asse rotante . Esempio: Dato Rotazione attorno all'asse Z L'asse X punta a destra e l'asse Y punta verso il basso. La direzione di visualizzazione è contro l'asse di rotazione (regola della mano destra). Per un valore negativo, la rotazione viene eseguita in senso orario. Per un valore positivo, la rotazione viene eseguita in senso antiorario. Asse di rotazione La selezione di un asse rotante è possibile solo se gli elementi del percorso CNC sono tutti elementi 3D. Nessuna selezione se il percorso CNC di uno dei seguenti elementi include: Spline G5 Parabola Ellisse arco 2D L'asse rotante è definito dai parametri X , sì , e Z . Predefinito: X : 0, sì : 0, Z : 1 --> rotazione attorno all'asse Z X Predefinito: 0.00000 Y Predefinito: 0.00000 Z Predefinito: 1.00000 ok La rotazione viene eseguita. I numeri di blocco vengono assegnati automaticamente. " }, 
{ "title" : "Comando: Programma in scala ", 
"url" : "_sm_cmd_cnc_scale_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Programma in scala ", 
"snippet" : "Programma scala Funzione : Il comando apre il Programma bilancia finestra di dialogo in cui è configurata la scalatura del percorso CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC....", 
"body" : "Programma scala Funzione : Il comando apre il Programma bilancia finestra di dialogo in cui è configurata la scalatura del percorso CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. " }, 
{ "title" : "vincolo ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_1320e28c7289c9f2c0a864633d064770", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Programma in scala \/ vincolo ", 
"snippet" : "La scalatura del percorso CNC è possibile alle seguenti condizioni: Nessun utilizzo dell'asse A, B o C di variabili...", 
"body" : "La scalatura del percorso CNC è possibile alle seguenti condizioni: Nessun utilizzo dell'asse A, B o C di variabili " }, 
{ "title" : "Finestra di dialogo: programma di scala ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Programma in scala \/ Finestra di dialogo: programma di scala ", 
"snippet" : "Fattore di scala Predefinito: 0.001 Condizione: fattore di scala >= 1e-3 Per un fattore di scala > 1, viene eseguito l'upscaling. Assi : L'asse viene scalato. D (raggio utensile) : Il raggio dell'utensile D viene scalato. ok La scalatura viene eseguita. I numeri di blocco vengono assegnati automatic...", 
"body" : "Fattore di scala Predefinito: 0.001 Condizione: fattore di scala >= 1e-3 Per un fattore di scala > 1, viene eseguito l'upscaling. Assi : L'asse viene scalato. D (raggio utensile) : Il raggio dell'utensile D viene scalato. ok La scalatura viene eseguita. I numeri di blocco vengono assegnati automaticamente. " }, 
{ "title" : "Comando: Scorri la visualizzazione del percorso ", 
"url" : "_sm_cmd_cnc_scroll_path_view.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Scorri la visualizzazione del percorso ", 
"snippet" : "Visualizza percorso di scorrimento Funzione : Il comando attiva e disattiva lo scorrimento del percorso del CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Se lo scorrimento è attivato, la visualizzazione del percorso CNC viene spostata e ingrandita nell'editor grafico in ...", 
"body" : "Visualizza percorso di scorrimento Funzione : Il comando attiva e disattiva lo scorrimento del percorso del CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Se lo scorrimento è attivato, la visualizzazione del percorso CNC viene spostata e ingrandita nell'editor grafico in modo che un elemento del percorso selezionato nel programma CNC sia completamente visibile. " }, 
{ "title" : "Comando: imposta variabili ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: imposta variabili ", 
"snippet" : "Imposta variabili Funzione : Il comando apre il Valori offline delle variabili dialogo. Le variabili del programma CNC possono essere definite qui per la modalità offline. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC....", 
"body" : "Imposta variabili Funzione : Il comando apre il Valori offline delle variabili dialogo. Le variabili del programma CNC possono essere definite qui per la modalità offline. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. " }, 
{ "title" : "Finestra di dialogo: valori offline delle variabili ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html#UUID-101f0c28-cef6-51dc-ec33-33b8d27ee9c8_id_c97aba1d244400ffc0a8640e01a5ad6c_id_d54502d95df6e2f6c0a8646351ba116d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: imposta variabili \/ Finestra di dialogo: valori offline delle variabili ", 
"snippet" : "Variabile Variabile del programma CNC Esempio: G_X Se la variabile è mostrata in corsivo grigio, significa che non è utilizzata nel programma CNC. Valore Valore offline configurato Esempio: 100 Imposta su valori online I valori vengono sovrascritti con i valori attualmente assegnati nell'applicazion...", 
"body" : "Variabile Variabile del programma CNC Esempio: G_X Se la variabile è mostrata in corsivo grigio, significa che non è utilizzata nel programma CNC. Valore Valore offline configurato Esempio: 100 Imposta su valori online I valori vengono sovrascritti con i valori attualmente assegnati nell'applicazione. Requisito: Il comando è disponibile se l'applicazione è in esecuzione e l'editor CNC è in modalità online. Quindi è possibile caricare i valori online. ok Se i valori sono validi, vengono applicati nel programma CNC e viene aggiornato il percorso dell'editor. " }, 
{ "title" : "Comando: Mostra punti finali ", 
"url" : "_sm_cmd_cnc_show_end_points.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Mostra punti finali ", 
"snippet" : "Mostra punti finali Funzione : Il comando attiva e disattiva la visualizzazione dei punti di traiettoria del CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Se la visualizzazione è attivata, tutti gli elementi del percorso sono dotati di punti finali....", 
"body" : "Mostra punti finali Funzione : Il comando attiva e disattiva la visualizzazione dei punti di traiettoria del CNC. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Se la visualizzazione è attivata, tutti gli elementi del percorso sono dotati di punti finali. " }, 
{ "title" : "Comando: Mostra griglia ", 
"url" : "_sm_cmd_cnc_show_grid.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Mostra griglia ", 
"snippet" : "Mostra griglia Simbolo: Funzione : Il comando attiva e disattiva la visualizzazione di una griglia nell'editor grafico. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Il fattore di zoom determina la spaziatura delle linee della griglia. L'espansione del percorso determina la d...", 
"body" : "Mostra griglia Simbolo: Funzione : Il comando attiva e disattiva la visualizzazione di una griglia nell'editor grafico. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Il fattore di zoom determina la spaziatura delle linee della griglia. L'espansione del percorso determina la dimensione della griglia. " }, 
{ "title" : "Comando: Mostra punti di interpolazione ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Mostra punti di interpolazione ", 
"snippet" : "Mostra punti di interpolazione Simbolo: Funzione : Il comando attiva e disattiva la visualizzazione dei punti di interpolazione. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Se è attivata la visualizzazione dei punti di appoggio, il percorso CNC viene visualizzato con i punt...", 
"body" : "Mostra punti di interpolazione Simbolo: Funzione : Il comando attiva e disattiva la visualizzazione dei punti di interpolazione. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Se è attivata la visualizzazione dei punti di appoggio, il percorso CNC viene visualizzato con i punti di appoggio. Il tempo di ciclo, che è impostato nella finestra di dialogo delle impostazioni del CNC ( preinterpolazione tab), serve per determinare i punti di interpolazione. Inoltre, questa funzione determina se un percorso CNC viene visualizzato o meno con la preelaborazione nell'editor. " }, 
{ "title" : "Visualizza nell'editor grafico ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html#UUID-043dd64e-e07a-5e2b-2f1d-fc2a843ef4b7_id_be380e1242fa185c0a8640e005adee9_id_d6d5fcd172c9c53cc0a864633c37464d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Mostra punti di interpolazione \/ Visualizza nell'editor grafico ", 
"snippet" : "Viene visualizzato un punto di appoggio con una linea perpendicolare alla direzione del movimento. La lunghezza della linea è proporzionale alla velocità del percorso attuale. Ciò rende possibile una stima approssimativa del comportamento della velocità. Distanza maggiore e linea lunga Alta velocità...", 
"body" : "Viene visualizzato un punto di appoggio con una linea perpendicolare alla direzione del movimento. La lunghezza della linea è proporzionale alla velocità del percorso attuale. Ciò rende possibile una stima approssimativa del comportamento della velocità. Distanza maggiore e linea lunga Alta velocità Distanza ridotta e linea corta Bassa velocità rosso L'interpolatore viene decelerato. Verde L'interpolatore viene accelerato. Grigio L'interpolatore ha una velocità costante. " }, 
{ "title" : "Comando: Soppressione del gradino ", 
"url" : "_sm_cmd_cnc_step_suppression.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Soppressione del gradino ", 
"snippet" : "Soppressione del passo Simbolo: Funzione : Il comando attiva e disattiva la soppressione gradini. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Il programma CNC è implementato come DIN66025. Se la soppressione dei passi è attivata, i blocchi nel programma CNC che iniziano con...", 
"body" : "Soppressione del passo Simbolo: Funzione : Il comando attiva e disattiva la soppressione gradini. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Il programma CNC è implementato come DIN66025. Se la soppressione dei passi è attivata, i blocchi nel programma CNC che iniziano con \/ vengono ignorati. Se il programma CNC è implementato come tabella, il comando non è disponibile. " }, 
{ "title" : "Comando: Scrivi programma su file ASCII ", 
"url" : "_sm_cmd_cnc_write_program_to_ascii_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Scrivi programma su file ASCII ", 
"snippet" : "Scrivi programma su file ASCII Funzione : il comando apre la finestra di dialogo predefinita per il salvataggio di un file nel file system. Il programma CNC può essere salvato come file ASCII. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Nome Default: Nome dell'oggetto CNC E...", 
"body" : "Scrivi programma su file ASCII Funzione : il comando apre la finestra di dialogo predefinita per il salvataggio di un file nel file system. Il programma CNC può essere salvato come file ASCII. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Nome Default: Nome dell'oggetto CNC Esempio: cncSpiral_A Tipo di file Estensione del file: TXT , GCODE , CNC " }, 
{ "title" : "Comando: Mostra percorso preelaborato ", 
"url" : "_sm_cmd_cnc_show_preprocessed_path.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Comando: Mostra percorso preelaborato ", 
"snippet" : "Mostra percorso preelaborato Simbolo: Funzione : Il comando attiva e disattiva la visualizzazione del percorso CNC con preelaborazione. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Se la visualizzazione è attiva, il percorso viene visualizzato con la preelaborazione e il per...", 
"body" : "Mostra percorso preelaborato Simbolo: Funzione : Il comando attiva e disattiva la visualizzazione del percorso CNC con preelaborazione. Chiamata : CNC menù Requisiti : Nell'editor è aperto un percorso CNC. Se la visualizzazione è attiva, il percorso viene visualizzato con la preelaborazione e il percorso originale viene visualizzato in grigio chiaro sullo sfondo. La pre-elaborazione è configurata in Impostazioni CNC finestra di dialogo ( Pre-elaborazione del percorso scheda). Viene visualizzata la preelaborazione ivi configurata. Quindi è possibile simulare l'effetto dei diversi blocchi funzione (in serie) sulla preelaborazione. Il comando non ha alcun effetto sulla generazione del codice. Anche se durante la compilazione del programma CNC viene generata una struttura di file SMC_OutQueue, il comando non ha alcun effetto sul contenuto del file. La pre-elaborazione viene sempre presa in considerazione durante la compilazione. " }, 
{ "title" : "Oggetto: Programma CNC ", 
"url" : "_sm_f_reference_object_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Programma CNC ", 
"snippet" : "Programma CNC...", 
"body" : "Programma CNC " }, 
{ "title" : "Panoramica ", 
"url" : "_sm_f_reference_object_cnc_program-1561724.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Programma CNC \/ Panoramica ", 
"snippet" : "CODESYS offre la possibilità di creare programmi CNC in due diversi editor: l'editor per DIN 66025 e l'editor tabulare. Entrambi gli editor mostrano una visualizzazione grafica del percorso programmato. Sebbene la programmazione possa essere scambiata tra gli editor, ciò può portare a perdite di inf...", 
"body" : "CODESYS offre la possibilità di creare programmi CNC in due diversi editor: l'editor per DIN 66025 e l'editor tabulare. Entrambi gli editor mostrano una visualizzazione grafica del percorso programmato. Sebbene la programmazione possa essere scambiata tra gli editor, ciò può portare a perdite di informazioni. I singoli editor forniscono una gestione diversa degli elementi. Elemento Editor per DIN 66025 Editor tabulare Posizionamento X X Linea X X Arco X X Ellisse X X Spline X X Posizionamento rapido X X Funzione M X X Parabola X Utilizzo delle variabili X Salto X Spostamento delle coordinate X Soppressione del passo X Tempo di sosta X Sincronizzazione dei tempi con l'interpolatore X Per ulteriori informazioni, vedere: Editor tabulare e Editor per DIN 66025" }, 
{ "title" : "Editor tabulare ", 
"url" : "_sm_obj_cnc_program_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Programma CNC \/ Editor tabulare ", 
"snippet" : "Nell'editor tabulare, i comandi del percorso sono elencati in una tabella. Sul Editor tabulare scheda, in Impostazioni CNC , puoi personalizzare le colonne di questa tabella. Il Impostazioni CNC si trovano come oggetti nella struttura dei dispositivi. Per impostazione predefinita, le proprietà dell'...", 
"body" : "Nell'editor tabulare, i comandi del percorso sono elencati in una tabella. Sul Editor tabulare scheda, in Impostazioni CNC , puoi personalizzare le colonne di questa tabella. Il Impostazioni CNC si trovano come oggetti nella struttura dei dispositivi. Per impostazione predefinita, le proprietà dell'elemento del percorso selezionato vengono visualizzate sul lato destro della tabella. Questi non possono essere modificati lì. Quando si seleziona una linea, il rispettivo percorso di movimento viene disegnato nell'editor grafico. Il tipo di elemento determina quali proprietà specifiche di un elemento del percorso possono essere modificate. I parametri non modificabili sono ombreggiati. Premendo il F6 il tasto commuta lo stato attivo sull'editor grafico e viceversa. Per una panoramica degli elementi supportati da questo editor, vedere il capitolo \"Programma oggetto CNC\". Per ulteriori informazioni, vedere: Programmazione di un percorso nell'editor tabulare e Editor grafico" }, 
{ "title" : "Editor per DIN 66025 ", 
"url" : "_sm_obj_cnc_program_din66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Programma CNC \/ Editor per DIN 66025 ", 
"snippet" : "In questo editor si definiscono gli elementi del percorso come programma CNC secondo DIN 66025. Per impostazione predefinita, le proprietà dell'elemento del percorso selezionato vengono visualizzate sul lato destro. Tuttavia, non possono essere modificati lì. Quando si seleziona una linea, il rispet...", 
"body" : "In questo editor si definiscono gli elementi del percorso come programma CNC secondo DIN 66025. Per impostazione predefinita, le proprietà dell'elemento del percorso selezionato vengono visualizzate sul lato destro. Tuttavia, non possono essere modificati lì. Quando si seleziona una linea, il rispettivo percorso di movimento viene disegnato nell'editor grafico. Premendo il F6 il tasto commuta lo stato attivo sull'editor grafico e viceversa. Per una panoramica degli elementi supportati da questo editor, vedere il capitolo \"Programma oggetto CNC\". Si noti che i riferimenti delle variabili globali vengono valutati nel modulo decoder quando l'interprete sta elaborando i blocchi. Questo può accadere con alcuni cicli di anticipo prima che l'oggetto viaggi. Per ulteriori informazioni, vedere: Programmazione di un percorso secondo DIN 66025 e Impostazioni CNC" }, 
{ "title" : "Editor grafico ", 
"url" : "_sm_obj_cnc_program_graphical.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Programma CNC \/ Editor grafico ", 
"snippet" : "L'editor grafico si trova nella parte inferiore dell'editor tabulare CNC e dell'editor per DIN 66025. L'editor viene utilizzato per visualizzare il programma CNC programmato. L'editor fornisce strumenti per modificare ed estendere il percorso. Struttura dell'editor (1): Editor tabulare o editor seco...", 
"body" : "L'editor grafico si trova nella parte inferiore dell'editor tabulare CNC e dell'editor per DIN 66025. L'editor viene utilizzato per visualizzare il programma CNC programmato. L'editor fornisce strumenti per modificare ed estendere il percorso. Struttura dell'editor (1): Editor tabulare o editor secondo DIN 66025 (2): Visualizzazione proprietà: mostra le proprietà dell'elemento del percorso selezionato (3): Editor grafico (4): Pannello di controllo: elementi per controllare la posizione della telecamera e la direzione di visualizzazione (5): Strumenti per modificare il percorso Note su come lavorare con l'editor grafico L'elemento del percorso selezionato viene visualizzato in rosso. I comandi di posizionamento (G0) e le funzioni dei punti di commutazione sono visualizzati in verde. Se il punto finale di un elemento è mobile, viene visualizzato come un piccolo cerchio con contorno nero. Le tangenti iniziale e finale sono visualizzate in grigio. La posizione attuale dell'elemento del percorso selezionato viene visualizzata nella barra di stato. Notare i comandi del menu del CNC per ridimensionare e spostare l'intero percorso. Prendere nota dei programmi di esempio inclusi nell'installazione di CODESYS SoftMotion . " }, 
{ "title" : "Utensili ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_0ffa6b2d9c1625bec0a8646341693b76", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Programma CNC \/ Editor grafico \/ Utensili ", 
"snippet" : "È possibile utilizzare gli strumenti per modificare ed estendere i percorsi di movimento nell'editor grafico. Le modifiche sono visibili contemporaneamente nell'editor di testo e nell'editor tabulare. Selezionare : Questo strumento seleziona un punto o un elemento del percorso. L'elemento viene quin...", 
"body" : "È possibile utilizzare gli strumenti per modificare ed estendere i percorsi di movimento nell'editor grafico. Le modifiche sono visibili contemporaneamente nell'editor di testo e nell'editor tabulare. Selezionare : Questo strumento seleziona un punto o un elemento del percorso. L'elemento viene quindi visualizzato in rosso con un punto iniziale blu. Il puntatore del mouse nell'editor grafico si trasforma in un puntatore. Linea : Aggiunge o inserisce una nuova riga. Il puntatore del mouse nell'editor grafico si trasforma in una croce. Inserisci cerchio (in senso orario) : Aggiunge o inserisce un nuovo arco (in senso orario). Il puntatore del mouse nell'editor grafico si trasforma in una croce. Inserisci cerchio (in senso antiorario) : Aggiunge o inserisce un nuovo arco (in senso antiorario). Il puntatore del mouse nell'editor grafico si trasforma in una croce. Spline : Aggiunge o inserisce un nuovo punto spline. Il puntatore del mouse nell'editor grafico si trasforma in una croce. " }, 
{ "title" : "Posizione della telecamera e direzione di visualizzazione ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_05ff18059c1625bec0a864634ba4f71d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Programma CNC \/ Editor grafico \/ Posizione della telecamera e direzione di visualizzazione ", 
"snippet" : "È possibile utilizzare il mouse per modificare in qualsiasi modo la posizione e la prospettiva della telecamera sul percorso del programma. Tasto sinistro del mouse premuto + movimento del mouse: sposta la posizione della telecamera lungo gli assi nel piano di visualizzazione. Tasto destro del mouse...", 
"body" : "È possibile utilizzare il mouse per modificare in qualsiasi modo la posizione e la prospettiva della telecamera sul percorso del programma. Tasto sinistro del mouse premuto + movimento del mouse: sposta la posizione della telecamera lungo gli assi nel piano di visualizzazione. Tasto destro del mouse premuto + movimento del mouse: Ruota la vista sul programma CNC. Ctrl + Rotellina del mouse : Modifica il fattore di zoom. " }, 
{ "title" : "Pannello operativo per il controllo del display ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_4693d34dba46042bc0a864633b130501", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Programma CNC \/ Editor grafico \/ Pannello operativo per il controllo del display ", 
"snippet" : "Nell'angolo in alto a sinistra dell'editor grafico, un pannello operativo fornisce vari comandi per cambiare la visualizzazione del percorso. Il percorso non viene modificato durante il processo. Vengono invece modificate solo la posizione e la prospettiva della telecamera. Puoi comprimere il pannel...", 
"body" : "Nell'angolo in alto a sinistra dell'editor grafico, un pannello operativo fornisce vari comandi per cambiare la visualizzazione del percorso. Il percorso non viene modificato durante il processo. Vengono invece modificate solo la posizione e la prospettiva della telecamera. Puoi comprimere il pannello di controllo facendo clic sulla freccia nera per massimizzare le dimensioni dell'area di lavoro dell'editor. Facendo nuovamente clic si espande il pannello di controllo. Il pannello di controllo fornisce i seguenti comandi per impostare l'orientamento, la posizione e lo zoom. Ingrandire Rimpicciolisci Modificare l'inclinazione della telecamera (in senso orario) Modificare il passo della telecamera (in senso antiorario) Modificare l'imbardata della telecamera (in senso orario) Modificare l'imbardata della telecamera (in senso antiorario) Ruota la telecamera (in senso orario) Ruota la telecamera (in senso antiorario) Sposta la fotocamera verso l'alto Sposta la telecamera a sinistra Sposta la fotocamera a destra Sposta la fotocamera verso il basso Imposta la direzione della vista sull'asse z negativo e ridimensiona Imposta la direzione della vista sull'asse x e ridimensiona Imposta la direzione della vista sull'asse y e ridimensiona " }, 
{ "title" : "Finestra di dialogo: proprietà del CNC ", 
"url" : "_sm_dlg_cnc_program_properties.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Programma CNC \/ Finestra di dialogo: proprietà del CNC ", 
"snippet" : "Simbolo: Funzione : La finestra di dialogo fornisce i parametri per il Programma CNC oggetto. Chiamata : Visualizza → Proprietà comando; menu contestuale dell'oggetto Requisiti : L'oggetto CNC è selezionato nell'albero dei dispositivi. Le impostazioni del CNC a livello di applicazione vengono salvat...", 
"body" : "Simbolo: Funzione : La finestra di dialogo fornisce i parametri per il Programma CNC oggetto. Chiamata : Visualizza → Proprietà comando; menu contestuale dell'oggetto Requisiti : L'oggetto CNC è selezionato nell'albero dei dispositivi. Le impostazioni del CNC a livello di applicazione vengono salvate nel Impostazioni CNC oggetto. " }, 
{ "title" : "Scheda: Generale ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_e398c87e5062d26bc0a86520014051d1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Programma CNC \/ Finestra di dialogo: proprietà del CNC \/ Scheda: Generale ", 
"snippet" : "Modificare il nome dell'oggetto CNC....", 
"body" : "Modificare il nome dell'oggetto CNC. " }, 
{ "title" : "Scheda: Controllo accessi ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_6f1287e45062d25bc0a865200009f33d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Programma CNC \/ Finestra di dialogo: proprietà del CNC \/ Scheda: Controllo accessi ", 
"snippet" : "Qui si specificano i permessi dei gruppi di utenti. Per ulteriori informazioni, vedere: Proprietà – Controllo accessi...", 
"body" : "Qui si specificano i permessi dei gruppi di utenti. Per ulteriori informazioni, vedere: Proprietà – Controllo accessi " }, 
{ "title" : "Scheda: Crea ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_18be1ff163875181c0a865ca014256df", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Programma CNC \/ Finestra di dialogo: proprietà del CNC \/ Scheda: Crea ", 
"snippet" : "Attivare l'opzione per escludere l'oggetto CNC dalla build. Quindi i dati IEC non vengono generati. Tuttavia, è possibile salvare il codice G come file ASCII. Per leggere questo tipo di file in fase di esecuzione, è possibile utilizzare i blocchi funzione dal SM3_CNC biblioteca. Per ulteriori inform...", 
"body" : "Attivare l'opzione per escludere l'oggetto CNC dalla build. Quindi i dati IEC non vengono generati. Tuttavia, è possibile salvare il codice G come file ASCII. Per leggere questo tipo di file in fase di esecuzione, è possibile utilizzare i blocchi funzione dal SM3_CNC biblioteca. Per ulteriori informazioni, vedere: Proprietà – Controllo accessi " }, 
{ "title" : "CNC tab ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Programma CNC \/ Finestra di dialogo: proprietà del CNC \/ CNC tab ", 
"snippet" : "Implementazione Din66025 : Il percorso di movimento è definito nel linguaggio CNC DIN 66025. Tavolo : Il percorso di movimento viene definito mediante la parametrizzazione di una tabella. Modalità di compilazione Comportamento in compilazione SMC_OutQueue : durante la compilazione viene generata una...", 
"body" : "Implementazione Din66025 : Il percorso di movimento è definito nel linguaggio CNC DIN 66025. Tavolo : Il percorso di movimento viene definito mediante la parametrizzazione di una tabella. Modalità di compilazione Comportamento in compilazione SMC_OutQueue : durante la compilazione viene generata una struttura dati SMC_OutQueue. Ti viene concesso l'accesso globale tramite g_CNCQueueManager . SMC_CNC_REF : Le variabili del programma vengono generate durante la compilazione. Ti viene concesso l'accesso globale tramite g_CNCProgManager . File : Un file generato dal codice G viene scaricato e aggiornato ad ogni accesso. Il PLC può scaricare questo file tramite blocchi funzione. I file del codice G vengono aggiornati ogni volta ad ogni accesso all'applicazione. Ciò significa che i file sul PLC vengono sovrascritti ad ogni login. Nome del file Requisiti: Modalità di compilazione è impostato per File . Predefinito: $NomeOggetto$.cnc . Questo valore predefinito è un segnaposto che viene sostituito dal nome dell'oggetto dell'oggetto CNC (nome file effettivo) al momento del login. Solo i caratteri [a-zA-Z0-9$_.] sono consentiti in un nome di file. Il campo per il nome del file non deve essere vuoto o iniziare o terminare con un punto. Inoltre, non è necessario che un punto faccia parte del percorso nel nome del file. Dimensione coda [elementi] Predefinito: 100 L'impostazione della dimensione non influisce sulla dimensione del generato SMC_OutQueue struttura dati (quando è selezionata questa modalità). La dimensione di SMC_OutQueue è determinato solo dal numero di oggetti percorso. Tuttavia, il parametro imposta la dimensione del buffer degli FB di preelaborazione (ad esempio, SMC_NCDecoder , SMC_RoundPath ) che vengono utilizzati internamente e definiscono la dimensione del buffer lookahead. Valori standard Velocità (F) [u\/s] Questo valore viene utilizzato quando il valore della velocità (nella parola \"F\") non è impostato nel programma CNC. In unità di percorso al secondo. Intervallo di valori: [0, 1e9]. Predefinito: 0 Accelerazione (E+) [u\/s²] Questo valore viene utilizzato quando il valore dell'accelerazione (nella parola \"E\" con valore positivo) non è impostato. In unità di percorso al secondo al quadrato. Intervallo di valori: ]0, 1e9]. Predefinito: 100 Decelerazione (E-) [u\/s²] Questo valore viene utilizzato quando il valore del rallentamento (nella word \"E\" con valore negativo) non è impostato. In unità di percorso al secondo al quadrato. Intervallo di valori: ]0, 1e9]. Predefinito: 100 Valori predefiniti per l'avanzamento rapido (G0) Velocità (FF) [u\/s] Questo valore viene utilizzato quando il valore di avanzamento della velocità (nella parola \"FF\") non è impostato nel programma CNC. In unità di percorso al secondo. Intervallo di valori: [0, 1e9]. Predefinito: 0 Accelerazione (EF+) [u\/s²] Questo valore viene utilizzato quando il valore di avanzamento dell'accelerazione (nella parola \"EF+\" con valore positivo) non è impostato. In unità di percorso al secondo al quadrato. Intervallo di valori: [0, 1e9]. Predefinito: 0 Decelerazione (EF-) [u\/s²] Questo valore viene utilizzato quando il valore di avanzamento della decelerazione (nella parola \"EF-\" con valore negativo) non è impostato. In unità di percorso al secondo al quadrato. Intervallo di valori: [0, 1e9]. Predefinito: 0 Modalità 3D Requisito: implementazione Din66025 , modalità di traduzione CNC_REF , e OUTQueue : La modalità 3D è il valore predefinito. Valori offline delle variabili Variabili : Se sono definiti valori offline, allora il Valori offline delle variabili si apre la finestra di dialogo. In questa finestra di dialogo vengono visualizzate le variabili che possono anche essere modificate. Posizione di partenza Predefinito: 0 Precisione La precisione del percorso in unità tecniche. Questo valore specifica la precisione delle posizioni lette dal codice G. Ad esempio, se il codice G viene specificato con 3 cifre decimali, la precisione dovrebbe essere impostata su 0,001 unità. La precisione non deve essere negativa. Questo valore viene utilizzato, ad esempio, dalla preelaborazione del percorso come SMC_ToolRadiusCorr E SMC_AvoidLoop . " }, 
{ "title" : "Oggetto: Impostazioni CNC ", 
"url" : "_sm_obj_cnc_settings.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Impostazioni CNC ", 
"snippet" : "Impostazioni CNC Simbolo: Le impostazioni in questo oggetto sono valide per tutti gli oggetti CNC dell'applicazione. L'oggetto viene aggiunto all'albero dei dispositivi dell'applicazione o viene generato automaticamente quando un oggetto CNC viene aggiunto all'applicazione. L'oggetto può esistere so...", 
"body" : "Impostazioni CNC Simbolo: Le impostazioni in questo oggetto sono valide per tutti gli oggetti CNC dell'applicazione. L'oggetto viene aggiunto all'albero dei dispositivi dell'applicazione o viene generato automaticamente quando un oggetto CNC viene aggiunto all'applicazione. L'oggetto può esistere solo una volta per applicazione e non può essere rinominato. Nell'editor dell'oggetto è possibile specificare le impostazioni per i moduli di preelaborazione del percorso, la preinterpolazione e l'editor tabulare CNC. Puoi eliminare il Impostazioni CNC oggetto solo se non esiste alcun oggetto CNC al di sotto dell'applicazione. Le impostazioni valide solo per un programma CNC specifico vengono salvate nel Impostazioni finestra di dialogo del programma CNC. " }, 
{ "title" : "Scheda: Preprocessori di percorso ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_de809dbaa55775c9c0a8646311985883", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Impostazioni CNC \/ Scheda: Preprocessori di percorso ", 
"snippet" : "In questa scheda viene programmata la preelaborazione del percorso selezionando i blocchi funzione. Blocchi funzione disponibili Elenco di tutti i blocchi funzione disponibili Istanze di blocchi funzione attivi Elenco delle istanze dei blocchi funzione selezionate La posizione nell'elenco definisce ...", 
"body" : "In questa scheda viene programmata la preelaborazione del percorso selezionando i blocchi funzione. Blocchi funzione disponibili Elenco di tutti i blocchi funzione disponibili Istanze di blocchi funzione attivi Elenco delle istanze dei blocchi funzione selezionate La posizione nell'elenco definisce l'ordine di elaborazione e può essere modificata. Un blocco funzione può essere istanziato più volte nell'elenco. Parametro Apre il Editor parametri per <istanza di blocco funzione attiva selezionata> dialogo Alternativa: fare doppio clic su un'istanza di blocco funzione attiva Aggiunge un'istanza del blocco funzione a Istanze di blocchi funzione attivi che è selezionato in Istanze di blocchi funzione attivi Elimina l'istanza del blocco funzione selezionata Le istanze dei blocchi funzione dei blocchi funzione, visualizzate in corsivo grigio chiaro, non possono essere eliminate. Sposta l'istanza del blocco funzione attivo selezionato verso l'alto di una riga Alternativa: premere Spostare + Freccia su Sposta l'istanza del blocco funzione attivo selezionato verso il basso di una riga Alternativa: premere Spostare + Freccia giù Editor parametri per <istanza di blocco funzione attiva selezionata> Dialogo La finestra di dialogo viene utilizzata per visualizzare e modificare gli input dell'istanza selezionata. Non tutti gli input sono visibili. Spalte1 Nome del parametro dell'istanza di blocco funzione attiva selezionata Spalte2 Casella di riepilogo per impostare il valore Spalte3 Descrizione del parametro " }, 
{ "title" : "Scheda: Preinterpolazione ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_9a258724a55775c9c0a8646350128da9", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Impostazioni CNC \/ Scheda: Preinterpolazione ", 
"snippet" : "Tempo di ciclo µs Tempo di interpolazione Valore iniziale: 20000 Modalità velocità trapezio : Profilo di velocità con forma trapezoidale Sigmoidale : Profilo di velocità come il profilo trapezoidale ma con funzioni sin² che sostituiscono la rampa di velocità lineare Sigmoide limitato : Profilo di ve...", 
"body" : "Tempo di ciclo µs Tempo di interpolazione Valore iniziale: 20000 Modalità velocità trapezio : Profilo di velocità con forma trapezoidale Sigmoidale : Profilo di velocità come il profilo trapezoidale ma con funzioni sin² che sostituiscono la rampa di velocità lineare Sigmoide limitato : Profilo di velocità come il profilo sigmoidale ma tenendo conto dei limiti di accelerazione e decelerazione quadratico : Profilo di accelerazione con forma trapezoidale con limitazione dello strappo come definito in coglione massimo . Anche il profilo di velocità quadratico risultante è riconosciuto come una curva a S. Quadratico (liscio) : Funziona come quadratico modalità ma genera un profilo jerk senza salti. Coglione massimo [u\/s³] Limitazione del valore assoluto del jerk Utilizzato solo per il profilo di velocità quadratico Il tempo di interpolazione e il tempo di ciclo del rispettivo task, in cui viene chiamato l'interpolatore, devono corrispondere per un comportamento identico dell'editor CNC e dell'applicazione online. " }, 
{ "title" : "Scheda: Editor tabulare ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_section-idm43260108321858", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interfaccia utente \/ Oggetto: Impostazioni CNC \/ Scheda: Editor tabulare ", 
"snippet" : "Le colonne dell'editor tabulare e il suo ordine sono definiti in questa scheda. Colonne della tabella Elenco di tutti gli attributi disponibili : l'attributo è visibile nell'editor tabulare. L'ordine in questo elenco determina l'ordine delle righe nell'editor tabulare. Sposta l'attributo selezionato...", 
"body" : "Le colonne dell'editor tabulare e il suo ordine sono definiti in questa scheda. Colonne della tabella Elenco di tutti gli attributi disponibili : l'attributo è visibile nell'editor tabulare. L'ordine in questo elenco determina l'ordine delle righe nell'editor tabulare. Sposta l'attributo selezionato verso l'alto di una riga Sposta l'attributo selezionato verso il basso di una riga " }, 
{ "title" : "CODESYS SoftMotion Robotics ", 
"url" : "_sm_f_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_sm_overview_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Panoramica ", 
"snippet" : "CODESYS SoftMotion Robotics fornisce un'interfaccia a blocchi funzione per il controllo del movimento dei robot, basata sulla specifica PLCopen \"Blocchi funzione per il controllo del movimento Parte 4\". Le sequenze di movimento complesse possono essere composte da semplici movimenti punto a punto o ...", 
"body" : "CODESYS SoftMotion Robotics fornisce un'interfaccia a blocchi funzione per il controllo del movimento dei robot, basata sulla specifica PLCopen \"Blocchi funzione per il controllo del movimento Parte 4\". Le sequenze di movimento complesse possono essere composte da semplici movimenti punto a punto o da movimenti continui, come linee rette o archi circolari. È possibile una fusione configurabile tra i singoli movimenti (ad esempio, in base alla distanza o alla velocità). Vengono presi in considerazione i limiti di velocità, accelerazione e jerk, sia dei singoli assi che del percorso. La pianificazione della traiettoria viene effettuata online su CODESYS controller, parallelamente all'esecuzione del movimento. È possibile aggiungere nuovi movimenti durante l'elaborazione e senza arrestare il robot. La fornitura comprende modelli cinematici per diversi robot standard, dai semplici portali, ai robot Delta e SCARA e ai tipici robot industriali a sei assi. I modelli cinematici personalizzati per macchine speciali possono essere collegati sotto forma di blocco funzione IEC 61131-3. Allo stesso modo, i modelli dinamici possono essere utilizzati tramite un'interfaccia per limitare le forze e le coppie che si verificano e consentire il controllo feed forward della coppia. Altri blocchi funzione vengono utilizzati per implementare facilmente casi d'uso tipici. Ciò include la sincronizzazione con sistemi di coordinate in movimento, l'interruzione e la ripresa dei movimenti o il controllo delle uscite digitali ad alta precisione tramite trigger. " }, 
{ "title" : "Iniziare ", 
"url" : "_sm_robotics_first_steps.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Iniziare ", 
"snippet" : "Per programmare i movimenti degli assi per un robot, devi prima creare un gruppo di assi sotto l'applicazione nel tuo progetto. Per ulteriori informazioni su questo, vedere: Come creare un gruppo di assi. Configurare il gruppo di assi creato con la cinematica desiderata. Si inseriscono assi reali o ...", 
"body" : "Per programmare i movimenti degli assi per un robot, devi prima creare un gruppo di assi sotto l'applicazione nel tuo progetto. Per ulteriori informazioni su questo, vedere: Come creare un gruppo di assi. Configurare il gruppo di assi creato con la cinematica desiderata. Si inseriscono assi reali o virtuali sotto il dispositivo e si collegano questi assi al gruppo di assi. Per ulteriori informazioni consultare le pagine di aiuto in Cinematica: Stati del Gruppo dell'AsseCombinazione di cinematica di posizione e orientamentoGiunti rotanti e assi moduloAssi rotanti con range di valori su 360°Come creare un programma per il controllo degli assi dopo aver creato e configurato gli assi è mostrato qui come esempio: Come creare un programma per il controllo del gruppo di assiPer informazioni su come implementare le varie richieste di controllo del movimento, vedere le pagine di aiuto aggiuntive in Controllo del movimento . Buffering e fusione dei movimentiJogging di gruppi di assiInterruzione e continuazione dei movimentiSincronizzazione con un sistema di coordinate in movimentoConfigurazione di un offset utensileInformazioni di base per capire come vengono eseguiti movimenti specifici possono essere trovate qui: Interpolazione di orientamento per movimenti CPPer utenti avanzati: Limitazione della coppia e controllo dell'avanzamento della coppiaCreazione di una cinematica personalizzata" }, 
{ "title" : "Gruppo dell'Asse ", 
"url" : "_sm_robotics_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Gruppo dell'Asse ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Come creare un gruppo di assi ", 
"url" : "_sm_creating_an_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Gruppo dell'Asse \/ Come creare un gruppo di assi ", 
"snippet" : "Aggiunta di oggetti all'albero dei dispositivi I passaggi seguenti descrivono come creare e configurare un gruppo di assi. Crea un nuovo progetto standard con CODESYS Control . Per il PO PLC_PRG selezionare la lingua di implementazione CFC. Nella struttura dei dispositivi, aprire il menu di scelta r...", 
"body" : "Aggiunta di oggetti all'albero dei dispositivi I passaggi seguenti descrivono come creare e configurare un gruppo di assi. Crea un nuovo progetto standard con CODESYS Control . Per il PO PLC_PRG selezionare la lingua di implementazione CFC. Nella struttura dei dispositivi, aprire il menu di scelta rapida del Dispositivo oggetto e selezionare il Abilita Soft Motion comando. UN Pool asse generale SoftMotion oggetto è inserito sotto il Dispositivo . Nella struttura dei dispositivi, selezionare Pool di assi generali SoftMotion . Nel menu contestuale, fare clic su Aggiungi dispositivo . Il Aggiungi dispositivo si apre la finestra di dialogo. Seleziona il SM_Drive_Virtuale dispositivo. Specificare il nome del dispositivo come \"DriveX\". Allo stesso modo, inserisci altre due unità denominate \"DriveY\" e \"DriveZ\" . Nell'albero dei dispositivi, aprire il menu contestuale del Applicazione oggetto e fare clic Progetto → Aggiungi oggetto → Gruppo dell'Asse . Inserisci l'oggetto con il nome specificato Gruppo d'Assi . Il Gruppo di assi oggetto viene inserito sotto l'applicazione. Si apre il configuratore di gruppi di assi. Nell'editor di configurazione, fare clic su Seleziona cinematica pulsante. Il Seleziona cinematica si apre la finestra di dialogo con un elenco di tutte le configurazioni cinematiche disponibili e le relative descrizioni. Seleziona il TRAFO.Kin_Gantry3 configurazione cinematica. Si apre l'editor di configurazione per la configurazione cinematica selezionata. Nel Mappatura sugli assi gruppo di parametri, mappare gli assi sugli azionamenti utilizzati nel progetto. Per fare ciò, specificare il valore DriveX nel X campo di input, il valore DriveY nel Y campo di input e il valore DriveZ nel Z Campo di inserimento. Puoi anche utilizzare l'Assistente di input per selezionare l'unità o trascinarla dalla struttura ad albero dei dispositivi nel campo di immissione. Per ulteriori informazioni, vedere: Editor del gruppo di assi" }, 
{ "title" : "Editor del gruppo di assi ", 
"url" : "_sm_obj_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Gruppo dell'Asse \/ Editor del gruppo di assi ", 
"snippet" : "Simbolo: Nell'editore di Gruppo di assi oggetto, selezionare il tipo di cinematica di base e cinematica di orientamento. La cinematica di orientamento può essere selezionata solo quando è supportata dalla cinematica di base. Inoltre, nel progetto si mappano gli assi della cinematica sugli azionament...", 
"body" : "Simbolo: Nell'editore di Gruppo di assi oggetto, selezionare il tipo di cinematica di base e cinematica di orientamento. La cinematica di orientamento può essere selezionata solo quando è supportata dalla cinematica di base. Inoltre, nel progetto si mappano gli assi della cinematica sugli azionamenti. Cinematica Seleziona cinematica Cambia cinematica Apre un elenco di tutte le cinematiche supportate da CODESYS Quando si seleziona un tipo di cinematica, nel riquadro a destra dell'elenco viene mostrata una breve descrizione. Dopo aver selezionato un tipo di cinematica, è possibile modificare i rispettivi parametri nell'editor. Cinematica di orientamento Seleziona cinematica Cambia cinematica Apre un elenco di tutte le cinematiche di orientamento supportate da CODESYS Quando si seleziona un tipo di cinematica, nel riquadro a destra dell'elenco viene mostrata una breve descrizione. Dopo aver selezionato un tipo di cinematica, è possibile modificare i rispettivi parametri nell'editor. Mappatura degli assi A seconda della cinematica selezionata, si mappano gli assi della cinematica sugli azionamenti nel progetto. Assi aggiuntivi Aggiungi asse Aggiunge un campo di configurazione per un asse aggiuntivo. L'unità del progetto viene inserita in questo campo di configurazione. Compiti Task ciclo bus Task ciclo bus degli assi, se gli assi sono già mappati L'impostazione non può essere modificata qui. Compito di pianificazione Compito per la pianificazione dei compiti CP Un'attività di pianificazione viene creata automaticamente quando viene inserito il primo gruppo di assi. Non è opportuno configurare un watchdog perché il tempo di esecuzione può variare notevolmente. Per ulteriori informazioni, vedere: Configurazione dell'attività di pianificazioneSe elimini questa attività, viene generato un errore nella visualizzazione del messaggio. Per creare una nuova attività, fare clic su Progetto → Creare un'attività di pianificazione . Per ulteriori informazioni, vedere: Come creare un gruppo di assi" }, 
{ "title" : "Stati del Gruppo dell'Asse ", 
"url" : "_sm_robotics_state_machine.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Gruppo dell'Asse \/ Stati del Gruppo dell'Asse ", 
"snippet" : "L'immagine seguente mostra i possibili stati per i gruppi di assi e le transizioni tra gli stati. Gli errori dei singoli assi indirizzano sempre il gruppo di assi verso GroupErrorStop stato. Se il gruppo di assi passa a GroupMoving , tutti gli assi vengono commutati su SynchronizedMotion . Se il gru...", 
"body" : "L'immagine seguente mostra i possibili stati per i gruppi di assi e le transizioni tra gli stati. Gli errori dei singoli assi indirizzano sempre il gruppo di assi verso GroupErrorStop stato. Se il gruppo di assi passa a GroupMoving , tutti gli assi vengono commutati su SynchronizedMotion . Se il gruppo di assi passa da GroupMoving A GroupStandby , tutti gli assi vengono commutati su standstill . Se il gruppo di assi passa da GroupMoving A GroupErrorStop , tutti gli assi vengono commutati su GroupErrorStop . Se il gruppo di assi è in GroupStandby , quindi i singoli assi non sono necessariamente tutti in standstill perché possono essere controllati per mezzo di blocchi funzione di movimento ad asse singolo come MC_Jog . Se il movimento viene terminato con un errore, tutti i movimenti successivi memorizzati nel buffer vengono interrotti CommandAborted . Finché il gruppo di assi segue un sistema di coordinate dinamico, rimarrà attivo GroupMoving . Il gruppo di assi è in GroupMoving se e solo se il gruppo viene spostato in modo coordinato (da uno dei blocchi di movimento della Parte 4). Passaggio da GroupMoving a GroupStandby viene eseguito un ciclo dopo l'ultimo cambio di posizione. " }, 
{ "title" : "Configurazione dell'attività di pianificazione ", 
"url" : "_sm_configuration_planning_task.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Gruppo dell'Asse \/ Configurazione dell'attività di pianificazione ", 
"snippet" : "La pianificazione del movimento del gruppo di assi viene eseguita in un task separato che viene creato automaticamente con il nome \"SoftMotion_PlanningTask\" quando viene inserito un gruppo di assi. Per impostazione predefinita, questa attività di pianificazione viene eseguita sullo stesso core del p...", 
"body" : "La pianificazione del movimento del gruppo di assi viene eseguita in un task separato che viene creato automaticamente con il nome \"SoftMotion_PlanningTask\" quando viene inserito un gruppo di assi. Per impostazione predefinita, questa attività di pianificazione viene eseguita sullo stesso core del processore dell'attività del bus. Sui sistemi multicore è consigliabile posizionarli su un core separato. A seconda che l'attività di pianificazione venga eseguita o meno su un proprio core, deve essere configurata in modo diverso. Single core Se l'attività di pianificazione viene eseguita sullo stesso core dell'attività bus, deve essere configurata come attività a esecuzione libera con bassa priorità in tempo reale. Questo è il caso per impostazione predefinita. L'attività di pianificazione viene creata automaticamente come attività a esecuzione libera con priorità 15. Multicore Sui sistemi multicore, l'attività di pianificazione deve essere eseguita su un core separato con la priorità più alta (0). Il tipo di attività deve essere impostato su ciclico e l'intervallo dell'attività su un valore basso (ad esempio, 2 ms). Con queste impostazioni, l'attività di pianificazione supererà spesso l'intervallo di attività. Questo è prevedibile e non è un problema. Le impostazioni dell'attività vengono selezionate per garantire che l'attività di pianificazione venga richiamata immediatamente dopo un'esecuzione. In questo modo il core dedicato viene utilizzato il più possibile per la pianificazione del movimento. Per ulteriori informazioni sulla configurazione delle attività, vedere: Configurazione delle attività Oggetto: Configurazione attività Oggetto: compito " }, 
{ "title" : "Cinematica ", 
"url" : "_sm_robotics_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_sm_overview_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Panoramica ", 
"snippet" : "Uno dei compiti più importanti della robotica è lo spostamento di un utensile (ad esempio, una piastra portautensili o una pistola di saldatura) lungo un percorso predefinito. A tale scopo, CODESYS SoftMotion Robotics calcola come devono muoversi i singoli giunti del robot in modo che la punta dell'...", 
"body" : "Uno dei compiti più importanti della robotica è lo spostamento di un utensile (ad esempio, una piastra portautensili o una pistola di saldatura) lungo un percorso predefinito. A tale scopo, CODESYS SoftMotion Robotics calcola come devono muoversi i singoli giunti del robot in modo che la punta dell'utensile, il Tool Center Point (TCP), segua il percorso comandato con l'orientamento desiderato. La cinematica o trasformazione cinematica è fondamentale per questo calcolo. Implementa la conversione dalle posizioni congiunte alla posizione TCP e all'orientamento TCP e viceversa La regola di calcolo varia a seconda del tipo di robot utilizzato. CODESYS SoftMotion Robotics include una cinematica configurabile per numerosi robot standard. Per ulteriori informazioni, vedere: Cinematica inclusa in La cinematica è suddivisa in cinematica di posizionamento e orientamento che possono essere combinate. Per ulteriori informazioni, vedere: Combinazione di cinematica di posizione e orientamentoÈ possibile configurare un offset dell'utensile che può essere modificato in fase di esecuzione. Per ulteriori informazioni, vedere: Configurazione di un offset utensileGli assi modulo a rotazione continua sono supportati per i giunti rotanti. Per ulteriori informazioni, vedere: Giunti rotanti e assi moduloPer tipi speciali di robot la cui regola di calcolo non può essere mappata da una delle cinematiche fornite, è possibile implementare la propria cinematica sotto forma di blocco funzionale. Per ulteriori informazioni, vedere: Creazione di una cinematica personalizzata" }, 
{ "title" : "Cinematica inclusa in CODESYS SoftMotion ", 
"url" : "_sm_robotics_cds_sm_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Cinematica inclusa in CODESYS SoftMotion ", 
"snippet" : "Sistemi a portale Nome Rappresentazione Può essere collegato alla cinematica di orientamento Informazioni aggiuntive Gantry2 ✓ Kin_Gantry2 (FB) Gantry3 ✓ Kin_Gantry3 (FB) HGantry2 ✓ Kin_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ Kin_TGantry2 (FB) Portale a 5 assi -- Kin_5Assi (FB) Sistemi...", 
"body" : "Sistemi a portale Nome Rappresentazione Può essere collegato alla cinematica di orientamento Informazioni aggiuntive Gantry2 ✓ Kin_Gantry2 (FB) Gantry3 ✓ Kin_Gantry3 (FB) HGantry2 ✓ Kin_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ Kin_TGantry2 (FB) Portale a 5 assi -- Kin_5Assi (FB) Sistemi SCARA Nome Rappresentazione Può essere collegato alla cinematica di orientamento Informazioni aggiuntive Polare ✓ Kin_Polar (FB) Polare con asse Z ✓ Kin_Polar_Z (FB) Scara2 con asse Z ✓ Kin_Scara2_Z (FB) Scara3 con asse Z -- Kin_Scara3_Z (FB) Robot articolati Nome Rappresentazione Può essere collegato alla cinematica di orientamento Informazioni aggiuntive Robot articolato a 3 assi rotativi ✓ Kin_Pos_RRR (FB) Palettizzatore a 4 assi -- Kin_4AxesPalettizzatore (FB) Robot articolato a 6 assi -- Kin_ArticulatedRobot_6DOF (FB) Sistemi paralleli Nome Rappresentazione Può essere collegato alla cinematica di orientamento Informazioni aggiuntive Bipiede con assi rotanti ✓ Kin_Bipod_Rotary (FB) Treppiede con assi rotanti ✓ Kin_Tripod_Rotary (FB) Treppiede con assi lineari ✓ Kin_Tripod_Lineare (FB) Cinematica dell'orientamento Nome Rappresentazione Informazioni aggiuntive Asse C Kin_CAxis (FB) Asse C con utensile Kin_CAxis_Tool (FB) Attrezzo Kin_Tool (FB) Wrist2 Kin_Polso2 (FB) Wrist3 Kin_Polso3 (FB) " }, 
{ "title" : "Combinazione di cinematica di posizione e orientamento ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Combinazione di cinematica di posizione e orientamento ", 
"snippet" : "Con il configuratore di gruppi di assi è possibile combinare cinematica di posizione e cinematica di orientamento. In questo modo è possibile configurare un gran numero di robot con un numero limitato di cinematiche. Esempi di cinematica di posizione includono i gantry ( Kin_Gantry3 ) e treppiedi ( ...", 
"body" : "Con il configuratore di gruppi di assi è possibile combinare cinematica di posizione e cinematica di orientamento. In questo modo è possibile configurare un gran numero di robot con un numero limitato di cinematiche. Esempi di cinematica di posizione includono i gantry ( Kin_Gantry3 ) e treppiedi ( Kin_Tripod_Lin , Kin_Tripod_Rotary ). Queste cinematiche possono viaggiare in qualsiasi punto o posizione, ma non possono eseguire un numero qualsiasi di orientamenti. Il sistema di coordinate anteriore di un sistema cinematico di posizione viene chiamato sistema di coordinate della flangia. Definisce il luogo in cui vengono fissate le cinematiche di orientamento (figura a sinistra). Esempi di cinematica di orientamento sono Kin_CAxis , Kin_Wrist2 , e Kin_Wrist3 . Queste cinematiche possono determinare un orientamento desiderato del TCP, ma non possono raggiungere alcuna posizione (vedi figura a destra). Combinando sia la cinematica di posizione che la cinematica di orientamento, è possibile percorrere un numero qualsiasi di posizioni nell'orientamento desiderato o viceversa. Osservazioni sulla cinematica personalizzata Gli utenti che desiderano creare una propria cinematica di posizione o orientamento devono implementare le seguenti interfacce aggiuntive nei propri blocchi funzionali cinematica: Per la cinematica di posizione: L'interfaccia ISMPositionKinematics2 con i metodi AxesToOrientation e GetOrientationImage . AxesToOrientation è una trasformazione in avanti \"abbreviata\" che calcola l'orientamento del sistema di coordinate della flangia dai valori dell'asse. È necessario solo per ragioni di efficienza. Ad esempio, non è necessario calcolare nulla con un gantry, ma è possibile restituire un orientamento costante. GetOrientationImage restituisce come può cambiare l'orientamento del sistema di coordinate della flangia. Questo metodo è necessario solo per verificare se la cinematica di orientamento è compatibile con la cinematica di posizione. Per la cinematica di orientamento: L'interfaccia ISMToolKinematics2 con i metodi GetPositionFromOrientation2 e IsCompatibleWithPosKin . GetPositionFromOrientation2 calcola il vettore tra il sistema di coordinate della flangia e TCP dall'orientamento desiderato (in MCS). Questo calcolo è necessario per la trasformazione inversa della cinematica combinata. Il metodo IsCompatibleWithPosKin verifica se la cinematica di orientamento è compatibile con la cinematica di posizione. " }, 
{ "title" : "Combinazioni non valide ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_718d71abf014b14bc0a864635271f262", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Combinazione di cinematica di posizione e orientamento \/ Combinazioni non valide ", 
"snippet" : "Non tutte le combinazioni di cinematica di posizione e cinematica di orientamento sono possibili perché a volte non è possibile determinare un'unica trasformazione inversa. Un esempio è uno SCARA con due giunti articolati come cinematica di posizione e Kin_CAxis_Tool come cinematica di orientamento ...", 
"body" : "Non tutte le combinazioni di cinematica di posizione e cinematica di orientamento sono possibili perché a volte non è possibile determinare un'unica trasformazione inversa. Un esempio è uno SCARA con due giunti articolati come cinematica di posizione e Kin_CAxis_Tool come cinematica di orientamento con una correzione utensile diversa da 0 nella coordinata X o Y. L'orientamento del sistema di coordinate della flangia dello SCARA non è costante. Viene ruotato attorno all'asse Z rispetto alla posizione 0. Per il calcolo della trasformazione inversa, questa rotazione non è ancora nota, il che rende impossibile determinare chiaramente gli angoli dell'asse in questo caso. In runtime è possibile verificare se una combinazione è possibile, poiché dipende dalla parametrizzazione della cinematica. In questo caso, l'errore SMC_TRAFO_INVALID_COUPLING viene emesso. " }, 
{ "title" : "Comportamento durante la programmazione di orientamenti \"impossibili\". ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_5ba01e61f014b14bc0a86463044fcdf7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Combinazione di cinematica di posizione e orientamento \/ Comportamento durante la programmazione di orientamenti \"impossibili\". ", 
"snippet" : "In pratica è spesso utile poter programmare orientamenti che non sono disponibili per la cinematica. Come semplice esempio, si consideri un robot SCARA con un utensile avente un grado di libertà (rotazione attorno all'asse Z). In linea di principio, questo robot può accettare solo orientamenti in cu...", 
"body" : "In pratica è spesso utile poter programmare orientamenti che non sono disponibili per la cinematica. Come semplice esempio, si consideri un robot SCARA con un utensile avente un grado di libertà (rotazione attorno all'asse Z). In linea di principio, questo robot può accettare solo orientamenti in cui l'utensile punta verticalmente verso il basso. Quando le posizioni devono essere percorse su un pezzo, sarà facilmente inclinato dal piano X\/Y. L'utente insegna il pezzo e quindi programma le posizioni e gli orientamenti relativi al pezzo. L'inclinazione del pezzo determina orientamenti in cui la direzione dell'utensile è leggermente inclinata rispetto alla verticale. Come affrontare un orientamento così impossibile e irraggiungibile? Una misura drastica sarebbe segnalare una violazione dello spazio di lavoro. Tuttavia, come mostra l'esempio, ciò renderebbe noiosa la programmazione. Pertanto, la cinematica di orientamento ( Kin_CAxis_Tool in questo esempio) sono implementati in modo tale da assumere l'orientamento più vicino ottenibile. In questo esempio ciò significa che l'orientamento comandato viene inclinato in modo tale che l'utensile sia in posizione verticale e questo orientamento venga accettato. Il comportamento può essere ridotto alle seguenti regole (ammesso che la cinematica di posizione possa posizionarsi in tutte e tre le direzioni spaziali): La posizione viene sempre avvicinata esattamente (altrimenti viene segnalato un errore). L'orientamento viene \"proiettato\" a quello accessibile più vicino se non è raggiungibile. Quando si proietta l'orientamento, la direzione dell'utensile ha la priorità. Le difficoltà qui descritte sorgono perché la cinematica di orientamento non ha i tre gradi di libertà per ottenere tutti gli orientamenti desiderati. Questo è il caso di Kin_Wrist2 e Kin_CAxis , ma non con Kin_Wrist3 . Ulteriori difficoltà sorgono quando anche la cinematica di posizione non ha tutti i gradi di libertà spaziali. (Questo non si verifica spesso nella pratica.) Un esempio è la combinazione di Kin_Gantry2 , un gantry posizionabile solo in X\/Y, e con Kin_Wrist2 , uno strumento con solo due gradi di libertà. In questo caso, ci sono sia orientamenti impossibili che posizioni impossibili, perché la coordinata Z è già definita dalla lunghezza dell'utensile e dalla posizione dell'asse di orientamento. Consigliamo quindi di non utilizzare questo tipo di combinazioni, ma di programmare solo posizioni raggiungibili. " }, 
{ "title" : "Configurazioni cinematiche ", 
"url" : "_sm_configure_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Configurazioni cinematiche ", 
"snippet" : "Una configurazione cinematica descrive la disposizione reciproca degli assi in un gruppo di assi. A seconda della cinematica sono possibili più configurazioni per la stessa posizione TCP. Ad esempio, vengono mostrate due possibili configurazioni per SCARA 2. Il gruppo di assi ha una configurazione a...", 
"body" : "Una configurazione cinematica descrive la disposizione reciproca degli assi in un gruppo di assi. A seconda della cinematica sono possibili più configurazioni per la stessa posizione TCP. Ad esempio, vengono mostrate due possibili configurazioni per SCARA 2. Il gruppo di assi ha una configurazione attiva che non deve necessariamente corrispondere alle posizioni attuali dell'asse. Se viene comandato un movimento, la posizione di destinazione può essere convertita in coordinate dell'asse. Viene utilizzata la configurazione attiva al momento del comando. Questa configurazione attiva può essere impostata con il blocco funzione SMC_SetKinConfiguration . Durante l'inizializzazione e ogni volta che si cambia la cinematica, il gruppo di assi applica la configurazione standard. Tutta la cinematica con una configurazione ha una configurazione standard. Non è possibile un movimento CP tra due configurazioni. In questo caso il posizionamento deve essere effettuato tramite un movimento PTP. La configurazione attuale può essere determinata con il blocco funzione MC_GroupReadActualPosition . " }, 
{ "title" : "Impostazione della configurazione per un progetto cinematico ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b2318eb4acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Configurazioni cinematiche \/ Impostazione della configurazione per un progetto cinematico ", 
"snippet" : "Ogni progetto cinematico con una configurazione dispone di una propria POU per il calcolo dei dati di configurazione. Il nome di questo blocco funzione corrisponde al nome della cinematica più il suffisso _config . La POU converte le diverse configurazioni nel tipo di dati ConfigData . Questo tipo d...", 
"body" : "Ogni progetto cinematico con una configurazione dispone di una propria POU per il calcolo dei dati di configurazione. Il nome di questo blocco funzione corrisponde al nome della cinematica più il suffisso _config . La POU converte le diverse configurazioni nel tipo di dati ConfigData . Questo tipo di dati viene passato al blocco funzione SMC_SetKinConfiguration . Esempio: impostazione di una configurazione per un progetto cinematico SCARA 2 Richiamare il blocco funzione Kin_Scara2_Z_Config dalla biblioteca SM3_Transformation . Ingresso xElbowRight = VERO Il blocco funzione fornisce i dati di configurazione di tipo ConfigData . Richiamare il blocco funzione SMC_SetKinConfiguration dalla biblioteca SM3_Robotics . Scrivi l'input ConfigData con i dati di configurazione precedentemente determinati. Impostare la configurazione attiva dello SCARA 2. VAR\n config: TRAFO.Kin_Scara2_Z_Config;\n skc: SMC_SetKinConfiguration;\nEND_VAR\n\nconfig(xElbowRight := TRUE);\nskc(AxisGroup := Scara2, Execute := TRUE, ConfigData := config.Config); " }, 
{ "title" : "Gestione della cinematica accoppiata ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b22c1067acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Configurazioni cinematiche \/ Gestione della cinematica accoppiata ", 
"snippet" : "La cinematica accoppiata esiste quando la cinematica di posizione e la cinematica di orientamento vengono utilizzate contemporaneamente. Ciò si traduce nella configurazione \"accoppiata\" da entrambe le configurazioni tramite chiamata Kin_Coupled_Config dalla biblioteca SM3_Transformation . La configu...", 
"body" : "La cinematica accoppiata esiste quando la cinematica di posizione e la cinematica di orientamento vengono utilizzate contemporaneamente. Ciò si traduce nella configurazione \"accoppiata\" da entrambe le configurazioni tramite chiamata Kin_Coupled_Config dalla biblioteca SM3_Transformation . La configurazione della cinematica di posizione e della cinematica di orientamento viene fornita al blocco funzionale agli ingressi. Per ulteriori informazioni, vedere: Assi rotanti con range di valori su 360°" }, 
{ "title" : "Configurazione di un offset utensile ", 
"url" : "_sm_configure_tool_offset.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Configurazione di un offset utensile ", 
"snippet" : "È possibile impostare l'offset tra il sistema di coordinate della flangia della cinematica (XYZ) e il sistema di coordinate TCP della cinematica (X'Y'Z') mediante la progettazione di una correzione utensile. Questo correttore utensile agisce su tutti i movimenti successivi. TCP: punto centrale dell'...", 
"body" : "È possibile impostare l'offset tra il sistema di coordinate della flangia della cinematica (XYZ) e il sistema di coordinate TCP della cinematica (X'Y'Z') mediante la progettazione di una correzione utensile. Questo correttore utensile agisce su tutti i movimenti successivi. TCP: punto centrale dell'utensile La correzione utensile è specificata da uno spostamento v=(x,y,z) e una rotazione r=(A,B,C) negli angoli di Eulero ZYZ. Lo spostamento e la rotazione sono espressi rispetto al sistema di coordinate della flangia della cinematica. Quando si configura un correttore utensile, questo può essere incompatibile con la cinematica attuale. Di conseguenza, un offset utensile può impedire alla cinematica di raggiungere l'orientamento. In questa situazione, viene emesso un errore e l'offset utensile viene ignorato. È possibile progettare ad esempio una correzione utensile in direzione Z per la cinematica Kin_Scara2_Z . D'altro canto, un offset con parti nella direzione X o Y genera un errore. Quando la cinematica presenta questo tipo di restrizioni, queste vengono descritte con il cinematica . " }, 
{ "title" : "Blocco funzione: SMC_GroupSetTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_348cb75b4119d4bfc0a864631ca28fed", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Configurazione di un offset utensile \/ Blocco funzione: SMC_GroupSetTool ", 
"snippet" : "Il blocco funzione configura la correzione utensile specificata all'ingresso ToolOffset (genere MC_COORD_REF ) per un gruppo di assi. Tuttavia, finché il gruppo di assi è nello stato GroupDisabled o GroupErrorStop , no è possibile configurare la correzione utensile. Se l'utensile non è compatibile c...", 
"body" : "Il blocco funzione configura la correzione utensile specificata all'ingresso ToolOffset (genere MC_COORD_REF ) per un gruppo di assi. Tuttavia, finché il gruppo di assi è nello stato GroupDisabled o GroupErrorStop , no è possibile configurare la correzione utensile. Se l'utensile non è compatibile con la cinematica attuale, la POU emette l'errore SMC_AXIS_GROUP_TOOL_OFFSET_INCOMPATIBLE_WITH_KINEMATICS . Questo errore viene emesso anche se l'interfaccia ISMKinematicsWithOrientationImage non è stato implementato per la descrizione della cinematica. " }, 
{ "title" : "Blocco funzione: SMC_GroupReadTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_c1689be51d4132b4c0a864637c06bdff", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Configurazione di un offset utensile \/ Blocco funzione: SMC_GroupReadTool ", 
"snippet" : "Questo blocco funzione legge la correzione utensile: output ToolOffset (genere MC_COORD_REF ). In questo processo, l'input ReadMode determina se deve essere letto l'utensile del movimento attivo, l'ultimo movimento comandato o l'utensile attualmente impostato nel gruppo di assi....", 
"body" : "Questo blocco funzione legge la correzione utensile: output ToolOffset (genere MC_COORD_REF ). In questo processo, l'input ReadMode determina se deve essere letto l'utensile del movimento attivo, l'ultimo movimento comandato o l'utensile attualmente impostato nel gruppo di assi. " }, 
{ "title" : "Cinematica compatibile ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_ff04bb6d41a8190bc0a864635e26fe13", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Configurazione di un offset utensile \/ Cinematica compatibile ", 
"snippet" : "Non tutte le cinematiche supportano ogni correzione utensile. L'elenco seguente mostra quali utensili sono adatti per quale cinematica. Cinematica Strumento compatibile Cinematica SCARA 2 Kin_Scara2_Z Utensili con offset di posizione nella direzione Z e offset nell'orientamento Cinematica SCARA 3 Ki...", 
"body" : "Non tutte le cinematiche supportano ogni correzione utensile. L'elenco seguente mostra quali utensili sono adatti per quale cinematica. Cinematica Strumento compatibile Cinematica SCARA 2 Kin_Scara2_Z Utensili con offset di posizione nella direzione Z e offset nell'orientamento Cinematica SCARA 3 Kin_Scara3_Z Tutti gli strumenti Cinematica polare Kin_Polar , Kin_Polar_Z Utensili con offset di posizione nella direzione Z e offset nell'orientamento Robot articolato a 3 assi Kin_Pos_RRR Strumenti con un offset nell'orientamento Robot articolato a 6 assi Kin_ArticulatedRobot_6DOF Tutti gli strumenti Palettizzatore a 4 assi Kin_4AxisPalletizer Tutti gli strumenti Bipiede Kin_Bipod_Rotary Tutti gli strumenti Portale a 5 assi Kin_5Axes Tutti gli strumenti Sistemi a portale Tutti gli strumenti Sistema a portale H Tutti gli strumenti Sistema a portale a T Tutti gli strumenti Treppiede rotativo o lineare Tutti gli strumenti Se un sistema cinematico non dispone di 3 gradi di libertà per l'orientamento, è possibile che non tutte le correzioni utensile siano compatibili. " }, 
{ "title" : "Per cinematica personalizzata ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_6c7b39581d4132b4c0a8646366a3228c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Configurazione di un offset utensile \/ Per cinematica personalizzata ", 
"snippet" : "Per utilizzare la cinematica personalizzata con un offset utensile, è necessario implementare il file ISMKinematicsWithOrientationImage interfaccia. Per aggiungere un offset utensile per la cinematica della posizione personalizzata, devi prima implementare l'interfaccia ISMPositionKinematics2 ....", 
"body" : "Per utilizzare la cinematica personalizzata con un offset utensile, è necessario implementare il file ISMKinematicsWithOrientationImage interfaccia. Per aggiungere un offset utensile per la cinematica della posizione personalizzata, devi prima implementare l'interfaccia ISMPositionKinematics2 . " }, 
{ "title" : "Interfaccia: ISMKinematicsWithOrientationImage ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_592ee99f1d4132b4c0a864637bd8a061", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Configurazione di un offset utensile \/ Interfaccia: ISMKinematicsWithOrientationImage ", 
"snippet" : "L'interfaccia cinematica fornisce il metodo GetFlangeOrientationImage con la variabile mR_Flange di tipo di dati SMC_Matrix3 , che contiene l'orientamento comandato della flangia. Di conseguenza, il metodo restituisce possibili orientamenti risultanti oriInfo come tipo di dati OrientationSpace . Com...", 
"body" : "L'interfaccia cinematica fornisce il metodo GetFlangeOrientationImage con la variabile mR_Flange di tipo di dati SMC_Matrix3 , che contiene l'orientamento comandato della flangia. Di conseguenza, il metodo restituisce possibili orientamenti risultanti oriInfo come tipo di dati OrientationSpace . Comportamento dell'interfaccia In particolare, quando è noto l'orientamento della flangia nell'orientamento comandato, dof = zero viene restituito e mOriZero è impostato sull'orientamento noto. Se l'orientamento R della flangia è noto solo parzialmente nella forma R*vU = vRot (dove vU e vRot sono noti vettori unitari), quindi dof = one viene restituito. mOriZero è impostato su un orientamento nello spazio raggiungibile. Altrimenti, dof = three viene restituito. Una correzione utensile specificata è compatibile con la cinematica se la posizione della flangia può essere calcolata in modo univoco tenendo conto dell'orientamento calcolato. Questo è sempre il caso quando l'orientamento calcolato può essere raggiunto dalla cinematica. La correzione utensile può essere incompatibile solo se non è possibile raggiungere tutti gli orientamenti. Inoltre, se il metodo GetFlangeOrientationImage ritorna dof = zero , allora ogni correttore utensile è compatibile. Se il metodo ritorna dof = one , quindi solo l'offset posizione utensile v_off parallela al vettore unitario vU è compatibile. In questo caso, R*v_off = R*vU*x = vRot*x non dipende dalle parti sconosciute della matrice di orientamento R . Ciò include anche una correzione utensile con v_off = 0 (dove x = 0). Se dof = three viene restituito, sono compatibili solo gli spostamenti di posizione senza un offset in x\/y\/z. Note di attuazione Implementare l'interfaccia ISMOrientationKinematicsWithOriImage2 per la cinematica di orientamento. Quindi è possibile utilizzare una correzione utensile per accoppiare la cinematica di orientamento con la cinematica di posizione. L'interfaccia ha il metodo GetOrientationImage2 con la variabile VAR_IN_OUT CONSTANT mR_Flange di tipo di dati SMC_Matrix3 , che contiene l'orientamento comandato della flangia. Il metodo ritorna csTool e oriinfo con il tipo di dati OrientationSpace nel sistema di coordinate di base della cinematica di orientamento. Inoltre, il metodo ritorna bActive se i gradi di libertà da orinfo sono attivi ( TRUE ) o passivo ( FALSE ). Esempio di gradi di libertà attivi: Kin_CAxis . La rotazione attorno all'asse z è controllata dall'asse della cinematica di orientamento. Esempio di gradi di libertà passivi: Kin_Wrist2 . Il restante grado di libertà è la rotazione di X\/Y attorno all'asse Z, che punta nella direzione programmata dall'utente. Quando sia l'ultimo movimento comandato che il nuovo movimento sono movimenti CP (sia movimenti lineari che rotativi) durante un cambio utensile, la modalità buffer del movimento successivo viene modificata da Blending o Aborting a Buffered . Se si configura un nuovo correttore utensile dopo MC_GroupInterrupt e prima MC_GroupContinue , per i movimenti interrotti viene utilizzata la vecchia correzione utensile. Il nuovo correttore utensile viene utilizzato solo per i movimenti che vengono comandati in seguito. Quando si cambia la cinematica ( MC_SetKinTransform ), il correttore utensile viene ripristinato (nessuno spostamento, nessuna rotazione). " }, 
{ "title" : "Giunti rotanti e assi modulo ", 
"url" : "_sm_robotics_rotary_joints_modulo_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Giunti rotanti e assi modulo ", 
"snippet" : "Gli assi modulo all'interno di gruppi di assi sono supportati a partire da SoftMotion 4.12.0.0. Gli assi modulo sono consentiti solo per i giunti girevoli della cinematica. Questi sono giunti girevoli per i quali SMKinematicWithInfo.GetAxisProperties restituisce il valore props.eType = Axis_Type.Rot...", 
"body" : "Gli assi modulo all'interno di gruppi di assi sono supportati a partire da SoftMotion 4.12.0.0. Gli assi modulo sono consentiti solo per i giunti girevoli della cinematica. Questi sono giunti girevoli per i quali SMKinematicWithInfo.GetAxisProperties restituisce il valore props.eType = Axis_Type.Rotary . Se si utilizza un asse modulo per un giunto lineare o per una cinematica che non implementa ISMKinematicWithInfo , poi MC_GroupEnable restituisce il SMC_MODULO_AXIS_FOR_NON_ROTARY_JOINT errore. Se si utilizza un asse modulo e la cinematica limita il campo di un giunto girevole, allora MC_GroupEnable restituisce il SMC_MODULO_AXIS_FOR_LIMITED_ROTARY_JOINT errore. Gli assi modulo sono supportati solo se il periodo modulo è 360°. Il motivo è che gli assi collegati ai giunti girevoli devono essere configurati in modo tale che un'unità tecnica [u] corrisponda a un grado angolare [°]. Un periodo deve corrispondere a una rotazione completa. Se viene utilizzato un asse modulo con un periodo diverso da 360°, allora MC_GroupEnable restituisce il SMC_MODULO_AXIS_PERIOD_NOT_360 errore. A partire dalla versione 4.12.0.0, SoftMotion supporta solo il shortest modalità ( DIREZIONE_MC ). Ciò significa che la distanza e la direzione di un asse modulo sono selezionate in modo tale che siano il più vicino possibile alla posizione iniziale dell'asse. Ad esempio, se l'asse di orientamento è in a2 = 30° all'inizio del movimento e in a2 = 290° alla posizione di destinazione, viene selezionata la posizione a2 = 290° – 360° = –70° e l'asse si sposta 100° in direzione negativa invece di spostarsi di 260° in direzione positiva. " }, 
{ "title" : "Creazione di una cinematica personalizzata ", 
"url" : "_sm_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinematica \/ Creazione di una cinematica personalizzata ", 
"snippet" : "Lo strumento open source wkhtmltopdf è necessario per generare la documentazione per la cinematica dai commenti nel blocco funzione. Tuttavia, questo componente non è più incluso nell'installazione di CODESYS versione 3.5 SP15 e successive. È possibile scaricare la DLL da https:\/\/wkhtmltopdf.org\/dow...", 
"body" : "Lo strumento open source wkhtmltopdf è necessario per generare la documentazione per la cinematica dai commenti nel blocco funzione. Tuttavia, questo componente non è più incluso nell'installazione di CODESYS versione 3.5 SP15 e successive. È possibile scaricare la DLL da https:\/\/wkhtmltopdf.org\/downloads.html . Crea una directory denominata DocScripting\\3.5.xx.x\\bin nella directory di installazione di CODESYS e salva il file wkhtmltox.dll là. Attenzione: poiché wkhtmltox.dll non supporta più le immagini per impostazione predefinita nella versione 0.12.6 e successive, è necessario utilizzare la versione 0.12.5 o precedente. Se si utilizza un'istanza di una trasformazione cinematica di un gruppo di assi, gli ingressi dell'istanza non devono più essere modificati. Per modificare la parametrizzazione della trasformazione cinematica è necessario utilizzare la configurazione, se possibile, oppure creare più istanze. Quando crei una cinematica personalizzata, devi osservare quanto segue: La cinematica è descritta da speciali blocchi funzione che possono essere memorizzati in librerie o in POU vista del progetto. Per CODESYS per elencare le cinematiche nel configuratore, i blocchi funzione associati devono implementare il MC_KIN_REF_SM3 interfaccia (parte di SM3_Transformation.library ). È possibile definire la cinematica come una combinazione di altre due cinematiche. Anche la cinematica con la possibilità di montare piastre portautensili o utensili deve essere implementata ISMPosizioneCinematica2 interfaccia. La cinematica che specifica una piastra utensile o un utensile deve implementare il file ISMToolKinematics2 interfaccia. Se si implementa solo ISMPositionKinematics \/ ISMToolKinematics invece di ISMPositionKinematics2 \/ ISMToolKinematics2 , gli orientamenti \"non disponibili\" potrebbero essere elaborati in modo errato. Quando si implementa anche l'interfaccia ISMPositionKinematics_Offset , è possibile utilizzare la modalità di orientamento Axis . Quando la POU ha il sm_kin_libdoc attributo, il commento specificato nel blocco funzione viene utilizzato nel configuratore come descrizione della cinematica. Per questo viene utilizzata la formattazione \"Testo ristrutturato\". Tieni presente, tuttavia, che i collegamenti non sono supportati. I parametri relativi alla progettazione, come lunghezze e angoli dei bracci, vengono creati come variabili VAR_INPUT del blocco funzione. Dovresti commentare i parametri perché il commento serve come descrizione nel configuratore. Se i parametri sono di tipo numerico e il loro intervallo di valori è ristretto, è necessario fornirli con l'estensione sm_kin_param_range attributo. La sintassi dell'intervallo di valori è [a .. b] per intervalli chiusi e ]a .. b[ per intervalli aperti. Le forme combinate ]a .. b] e [a .. b[ sono anche possibili. Per questo scopo, a e b devono essere letterali appropriati per il tipo di parametro. I valori speciali +inf e -inf sono possibili per limiti di intervallo aperti. Esempi: [0 .. 1] , [1 .. +inf[ , ]-inf .. -5] . I parametri possono essere di qualsiasi tipo numerico o BOOL . I parametri devono avere un valore iniziale che viene utilizzato come valore predefinito. È possibile specificare l'unità del parametro con l'attributo facoltativo sm_kin_param_unit (esempio: \"rad\", \"°\", \"deg\"). Dovresti usare l'unità \"u\" per lunghezze e distanze. L'applicazione e la scalatura degli azionamenti determinano se queste unità sono \"mm\", \"cm\" o \"m\". Se per il blocco funzione non è disponibile la documentazione della libreria, come opzione di fallback viene visualizzato il commento dell'elemento FB nelle rispettive posizioni. La lingua configurata in CODESYS è la lingua visualizzata per la documentazione di LibDoc. Se una localizzazione non è disponibile in questa lingua, viene utilizzata la lingua predefinita della libreria. I nomi degli assi della cinematica sono definiti dall'attributo FB sm_kin_axes . Il valore dell'attributo è un elenco di nomi di assi (esempio: \"A1, A2, A3\"). Un'icona facoltativa è specificata con l'attributo FB sm_kin_icon . Il valore è specificato nel modulo <image pool>.<identifier> . Il pool di immagini viene specificato rispetto al blocco funzione. Se si crea un blocco funzione cinematico personalizzato con assi rotativi (ad es. Kin_Scara3_Z_Config ), allora dovresti usare il concetto di periodo per gli assi di tesi e implementare il ISMKinPeriodHandling interfaccia. Per gli assi rotativi, solo la trasformazione cinematica inversa ( CartesianToAxes ) è responsabile del calcolo dell'angolo. Poi CODESYS SoftMotion sposta automaticamente questo angolo sul periodo corretto. Ad esempio, se la trasformazione calcola un angolo nell'intervallo ]-180°, 180°], allora CODESYS SoftMotion sposta questo angolo nell'intervallo [0°, 360°[, a condizione che i limiti software dell'azionamento siano 0° .. 360°. Inoltre, dovresti implementare il ISMKinematicsWithConfiguration3 interfaccia. Questo è l'unico modo per assicurarsi che la cinematica per i movimenti CP funzioni senza problemi. Nel caso di cinematica accoppiata con disposizione irregolare della cinematica di posizione e orientamento, è opportuno implementare il ISMCoupledKinematics3 interfaccia. In questo modo il sistema può rilevare se un asse per la cinematica di posizione o di orientamento appartiene o meno al rispettivo numero di asse. Nota: è necessario implementare il ISMKinematicWithConfigurations2.CPConnectible metodo in modo tale che le impostazioni del periodo vengano ignorate durante il confronto. Poi CPConnectible restituisce il valore TRUE , anche se l'impostazione del periodo è diversa. Tutte le trasformazioni inverse hanno un input di tipo CONFIGDATA che contiene un array di byte con informazioni sulla configurazione della cinematica. Le trasformazioni in avanti hanno un output corrispondente. La cinematica con una configurazione deve implementare il ISMKinematicWithConfigurations interfaccia. Ciascuna di queste cinematiche include un blocco funzione che deve implementare il ISMConfigurationData interfaccia (funzione per la serializzazione dei dati di configurazione). Il nome di questo blocco funzione deve essere lo stesso nome della cinematica più il suffisso _config . È possibile utilizzare questo FB per modificare la configurazione nell'applicazione (tramite il blocco funzione SMC_SetKinConfiguration bloccare). Tuttavia, la cinematica non dovrebbe contenere alcuna istanza dell'FB corrispondente. Per istruzioni dettagliate, consultare la Cinematica personalizzata capitolo. " }, 
{ "title" : "Sistemi di coordinate ", 
"url" : "_sm_coordinate_systems.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemi di coordinate ", 
"snippet" : "CODESYS SoftMotion Robotics fornisce diversi sistemi di coordinate in cui è possibile comandare i movimenti. Sistema di coordinate degli assi (ACS) Sistema di coordinate degli utensili (TCS) Sistema di coordinate mondiali (WCS) Sistema di coordinate della macchina (MCS) Sistema di coordinate del pro...", 
"body" : "CODESYS SoftMotion Robotics fornisce diversi sistemi di coordinate in cui è possibile comandare i movimenti. Sistema di coordinate degli assi (ACS) Sistema di coordinate degli utensili (TCS) Sistema di coordinate mondiali (WCS) Sistema di coordinate della macchina (MCS) Sistema di coordinate del prodotto (PCS_1, PCS_2) Sistema di coordinate Descrizione Sistema di coordinate degli assi (ACS) Il sistema di coordinate degli assi definisce un sistema di coordinate nello spazio degli assi in cui ogni asse del robot si estende su una dimensione. Di conseguenza, è possibile specificare una posizione per ciascun asse del robot Sistema di coordinate degli utensili (TCS) Il sistema di coordinate dell'utensile è un sistema di coordinate cartesiane che si trova sul punto centrale dell'utensile (TCP) della cinematica. La sua posizione e il suo orientamento dipendono dalla posizione del robot Sistema di coordinate mondiali (WCS) Il sistema di coordinate mondiali è un sistema di coordinate cartesiane statico e costituisce la base per tutti i sistemi di coordinate successivi. Questi sono definiti rispetto al sistema di coordinate mondiali Sistema di coordinate della macchina (MCS) Il sistema di coordinate macchina è un sistema di coordinate cartesiane statiche. La posizione e l'orientamento dell'MCS rispetto al robot fisico sono definiti dalla Le Trasformazione di coordinate MC_Set il blocco funzione può essere utilizzato per spostare il sistema di coordinate rispetto al sistema di coordinate mondiali (WCS). Sistema di coordinate del prodotto (PCS_1, PCS_2) I sistemi di coordinate del prodotto sono sistemi di coordinate cartesiane che possono essere definiti dall'utente. Sono espressi rispetto al sistema di coordinate mondiali (WCS) e possono essere statici o dinamici Statico Le Trasformazione di coordinate MC_Set il blocco funzione può essere utilizzato per spostare i sistemi di coordinate relativi al sistema di coordinate mondiali (WCS). Dinamico I seguenti blocchi funzione possono essere utilizzati per definire sistemi di coordinate dinamici: Trasformazione MC_setDyncoordTransform SMC_SetDYNCOORDTRANSFORMEX Nastro trasportatore MC_Track Tavola rotante MC_Track " }, 
{ "title" : "Posizione iniziale e orientamento dei sistemi di coordinate ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056579261585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemi di coordinate \/ Posizione iniziale e orientamento dei sistemi di coordinate ", 
"snippet" : "La cinematica del robot determina la posizione iniziale e l'orientamento dei sistemi di coordinate. Questo è descritto nella documentazione della cinematica La cinematica definisce quanto segue: Posizione e orientamento del sistema di coordinate della macchina (MCS) rispetto al robot fisico Posizion...", 
"body" : "La cinematica del robot determina la posizione iniziale e l'orientamento dei sistemi di coordinate. Questo è descritto nella documentazione della cinematica La cinematica definisce quanto segue: Posizione e orientamento del sistema di coordinate della macchina (MCS) rispetto al robot fisico Posizione e orientamento del punto centrale dell'utensile (TCP) rispetto al MCS e quindi al sistema di coordinate dell'utensile (TCS) Posizione zero del robot e direzioni di rotazione o movimento dei singoli assi Il sistema di coordinate mondiali (WCS) e i sistemi di coordinate del prodotto (PCS_1, PCS_2) non sono inizialmente spostati e sono identici al sistema di coordinate macchina. " }, 
{ "title" : "Robot e pezzi in lavorazione multipli ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581220108", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemi di coordinate \/ Robot e pezzi in lavorazione multipli ", 
"snippet" : "La posizione e l'orientamento dei sistemi di coordinate sono definiti per ogni robot. Quando più robot lavorano insieme, può essere utile definire il sistema di coordinate mondiali (WCS) come un sistema di coordinate di base comune. In base a questo sistema di coordinate, è possibile spostare i sist...", 
"body" : "La posizione e l'orientamento dei sistemi di coordinate sono definiti per ogni robot. Quando più robot lavorano insieme, può essere utile definire il sistema di coordinate mondiali (WCS) come un sistema di coordinate di base comune. In base a questo sistema di coordinate, è possibile spostare i sistemi di coordinate macchina (MCS) e i sistemi di coordinate del prodotto (PCS_1, PCS_2) " }, 
{ "title" : "Esempio ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581719182", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemi di coordinate \/ Esempio ", 
"snippet" : "Esempio di utilizzo di un robot con due giunti rotanti ( a0 e a1 )...", 
"body" : "Esempio di utilizzo di un robot con due giunti rotanti ( a0 e a1 ) " }, 
{ "title" : "Cinematica ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582142746", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemi di coordinate \/ Esempio \/ Cinematica ", 
"snippet" : "La cinematica definisce la posizione zero del robot (come mostrato di seguito). L'origine del sistema di coordinate della macchina si trova sull'asse di rotazione dell'asse a0 . L'asse X punta nella direzione del primo collegamento quando si trova la posizione del primo a0 è 0 . L'asse Y punta nella...", 
"body" : "La cinematica definisce la posizione zero del robot (come mostrato di seguito). L'origine del sistema di coordinate della macchina si trova sull'asse di rotazione dell'asse a0 . L'asse X punta nella direzione del primo collegamento quando si trova la posizione del primo a0 è 0 . L'asse Y punta nella direzione del primo collegamento quando si trova la posizione del primo a0 è +90° . La rotazione in senso antiorario corrisponde alla direzione di rotazione positiva. Il punto centrale dello strumento (TCP) si trova all'estremità del secondo collegamento del robot (come mostrato di seguito) e costituisce l'origine del TCS. Il TCS è allineato in modo tale che l'asse X scorra lungo il secondo " }, 
{ "title" : "Sistema di coordinate degli assi (ACS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582875889", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemi di coordinate \/ Esempio \/ Sistema di coordinate degli assi (ACS) ", 
"snippet" : "La cinematica ha specificato la posizione zero del robot e il senso di rotazione dei singoli assi. Perché il robot è composto da due assi a0 e a1 , possiamo specificare le posizioni degli assi a0 e a1 nell'ACS. Nella prima immagine, specifichiamo la posizione ( a0:= 0, a1:= 0 ). Ciò corrisponde alla...", 
"body" : "La cinematica ha specificato la posizione zero del robot e il senso di rotazione dei singoli assi. Perché il robot è composto da due assi a0 e a1 , possiamo specificare le posizioni degli assi a0 e a1 nell'ACS. Nella prima immagine, specifichiamo la posizione ( a0:= 0, a1:= 0 ). Ciò corrisponde alla posizione zero del robot. Nella seconda immagine, specifichiamo la posizione ( a0:= 90, a1:= 0 ). Partendo dalla posizione zero, il primo asse a0 è ruotato 90° nel senso di rotazione positivo. Il secondo asse a1 rimane nella posizione zero. Nella terza immagine, specifichiamo la posizione ( a0:= 90, a1:= -90 ). Partendo dalla posizione zero, il primo asse a0 è ruotato 90° nel senso di rotazione positivo (come nella seconda immagine). Inoltre, il secondo asse a1 è ruotato 90° nel senso di rotazione negativo. " }, 
{ "title" : "Sistema di coordinate degli utensili (TCS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056583569251", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemi di coordinate \/ Esempio \/ Sistema di coordinate degli utensili (TCS) ", 
"snippet" : "La cinematica definisce la posizione e l'orientamento del TCP e del TCS. A seconda di come spostiamo il robot, cambiano anche la posizione e l'orientamento del...", 
"body" : "La cinematica definisce la posizione e l'orientamento del TCP e del TCS. A seconda di come spostiamo il robot, cambiano anche la posizione e l'orientamento del " }, 
{ "title" : "Sistema di coordinate mondiali (WCS), sistema di coordinate macchina (MCS) e sistema di coordinate del prodotto (PCS_1, PCS_2) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056584038831", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Sistemi di coordinate \/ Esempio \/ Sistema di coordinate mondiali (WCS), sistema di coordinate macchina (MCS) e sistema di coordinate del prodotto (PCS_1, PCS_2) ", 
"snippet" : "In un capannone di produzione, due robot si trovano a sinistra e a destra di un nastro trasportatore. I robot devono trattare i prodotti sul nastro trasportatore. Definiamo un sistema di coordinate mondiali comune e lo posizioniamo nell'angolo in alto a sinistra del nostro capannone di produzione. P...", 
"body" : "In un capannone di produzione, due robot si trovano a sinistra e a destra di un nastro trasportatore. I robot devono trattare i prodotti sul nastro trasportatore. Definiamo un sistema di coordinate mondiali comune e lo posizioniamo nell'angolo in alto a sinistra del nostro capannone di produzione. Partendo da questo sistema di coordinate, determiniamo la distanza e la rotazione rispetto ai sistemi di coordinate della macchina e al prodotto e spostiamo i sistemi di coordinate Nell'esempio, tutti i sistemi di coordinate sono allineati allo stesso modo, quindi dobbiamo solo spostare i sistemi di coordinate. Il sistema di coordinate macchina del robot sinistro viene spostato in direzione Y, il sistema di coordinate macchina del robot destro viene spostato in direzione X e il sistema di coordinate del prodotto viene spostato sia in direzione X che in " }, 
{ "title" : "Controllo del movimento ", 
"url" : "_sm_f_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_sm_overview_robotics_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Panoramica ", 
"snippet" : "Questo capitolo descrive i tipi base di movimento nella robotica: Jogging SMC_GroupJog2 Movimenti PTP (punto a punto) MC_MoveDirectAbsolute MC_MoveDirectRelative Movimenti CP (Percorso Continuo) MC_MoveLinearAbsolute MC_MoveLinearRelative MC_MoveCircularAbsolute MC_MoveCircularRelative Aspettare SMC...", 
"body" : "Questo capitolo descrive i tipi base di movimento nella robotica: Jogging SMC_GroupJog2 Movimenti PTP (punto a punto) MC_MoveDirectAbsolute MC_MoveDirectRelative Movimenti CP (Percorso Continuo) MC_MoveLinearAbsolute MC_MoveLinearRelative MC_MoveCircularAbsolute MC_MoveCircularRelative Aspettare SMC_GroupWait Fermati (vedi Arresto sul percorso con MC_GroupHalt o MC_GroupStop E Interruzione e continuazione dei movimenti) MC_GroupHalt MC_GroupStop MC_GroupInterrupt Inoltre, vengono spiegati anche tutti gli argomenti importanti relativi ai movimenti: Buffering e fusione dei movimentiSincronizzazione con un sistema di coordinate in movimentoSincronizzazione degli assi esterni, controllo del feed forward della coppiaAssi aggiuntiviDiagnosi in caso di movimenti lenti o a scatti" }, 
{ "title" : "Come creare un programma per il controllo del gruppo di assi ", 
"url" : "_sm_creating_an_axis_group_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Come creare un programma per il controllo del gruppo di assi ", 
"snippet" : "Le seguenti istruzioni descrivono come creare un programma per il controllo di un gruppo di assi. Requisiti : È stato creato un progetto con un gruppo di assi, come specificato in Come creare un gruppo di assi capitolo. Il programma per il controllo di un gruppo di assi viene creato in PLC_PRG POU c...", 
"body" : "Le seguenti istruzioni descrivono come creare un programma per il controllo di un gruppo di assi. Requisiti : È stato creato un progetto con un gruppo di assi, come specificato in Come creare un gruppo di assi capitolo. Il programma per il controllo di un gruppo di assi viene creato in PLC_PRG POU con CFC come linguaggio di implementazione. Apri il PLC_PRG programma nell'editor. Trascina il Scatola elemento all'editor. Mappare il blocco funzione SMC_GroupPower alla scatola. Configurare il blocco funzione secondo l'immagine seguente. Spiegazione: Il blocco funzione attiva gli azionamenti del gruppo di assi. Il risultato Status indica l'abilitazione del controller riuscita. Creare un blocco funzione di tipo MC_GroupEnable . Questo blocco funzione trasferisce il controllo degli assi collegati al AxisGroup gruppo di assi. Collega il Status uscita del SMC_GroupPower blocco funzione al Execute ingresso del MC_GroupEnable blocco funzione. Spiegazione: Quando tutti i controller degli assi sono alimentati ( Status = TRUE ), il controllo degli assi viene trasferito al gruppo di assi. IL Done output riporta il successo del comando. Inserisci un MC_MoveDirectAbsolute blocco funzione per l'esecuzione dell'azionamento. Collega il Done uscita del MC_GroupEnable blocco funzione al Execute ingresso del MC_MoveDirectAbsolute blocco funzione. Estendi il programma come segue: Spiegazione: IL MC_MoveDirectAbsolute il blocco funzione comanda un movimento PTP del Gruppo d'Assi gruppo di assi. Nell'esempio la cinematica viene spostata nella posizione (X = 10, Y= 20, Z = 30). Questo valore è mappato a Position ingresso tramite il SMC_POS_REF struttura. La posizione è specificata nel sistema di coordinate della macchina (MCS). Il sistema di coordinate viene selezionato mediante il CoordSystem ingresso. Avvio del programma Se il programma è stato creato completamente e può essere compilato senza errori, è possibile trasferirlo al controllore. Inizia il CODESYS Control Win sistema di esecuzione ( CODESYSControlService.exe programma nel \"...\\GatewayPLC\" rubrica). Nel Impostazioni di comunicazione , imposta il percorso di connessione al controller. Clic in linea → Login . Scarica il progetto nel controller. Clic Debug → Avvia . Nell'editor, apri il file AxisGroup oggetto. Vengono visualizzate le posizioni degli assi. Clic Debug → Inizio . Le posizioni degli assi cambiano. " }, 
{ "title" : "Jogging di gruppi di assi ", 
"url" : "_sm_cartesian_jogging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Jogging di gruppi di assi ", 
"snippet" : "Puoi usare il SMC_GroupJog2 blocco funzione per spostare un gruppo di assi nello spazio. IL SMC_GroupJog2 il blocco funzione ha due ingressi booleani per ciascuna coordinata. Un input serve per spostarsi in avanti lungo questa coordinata e un input serve per spostarsi all'indietro. Gli input boolean...", 
"body" : "Puoi usare il SMC_GroupJog2 blocco funzione per spostare un gruppo di assi nello spazio. IL SMC_GroupJog2 il blocco funzione ha due ingressi booleani per ciascuna coordinata. Un input serve per spostarsi in avanti lungo questa coordinata e un input serve per spostarsi all'indietro. Gli input booleani per le diverse coordinate di SMC_GroupJog2 può essere interpretato in diversi modi. Ad esempio in coordinate cartesiane, coordinate macchina, coordinate assi o coordinate utensile, a seconda del sistema di coordinate impostato. Con un input speciale ABC_as_ACS: BOOL , sia X\/Y\/Z che gli assi della cinematica dell'utensile possono essere spostati simultaneamente in coordinate cartesiane e coordinate degli assi. Il jogging \"misto\" è supportato solo se le cinematiche sono accoppiate e la cinematica di posizione implementa l'interfaccia ISMPositionKinematics_Offset . (Altrimenti il blocco funzione genera un errore.) In modalità jogging, A ruota il TCP attorno all'asse X del sistema di coordinate configurato (MCS, WCS, PCS o TCS). B e C ruotano il TCP attorno agli assi Y e Z nello stesso sistema di coordinate. Tuttavia, questo vale solo quando ABC_as_ACS = FALSE . Il jogging cartesiano inizia quando il SMC_GroupJog2 il blocco funzione riceve un fronte di salita e imposta il Busy produzione. Il jogging cartesiano provoca l'interruzione dei movimenti coordinati attivi o dei movimenti degli assi della cinematica. Il jogging cartesiano termina quando il jogging è interrotto da un movimento (coordinato o sugli assi della cinematica) o quando la posizione è fuori dell'area di lavoro. Durante il jogging, i limiti degli assi vengono sempre mantenuti sugli assi della cinematica. Per ulteriori informazioni, vedere: Fare jogging con un robot" }, 
{ "title" : "Movimenti PTP invarianti per il percorso ", 
"url" : "_sm_robotics_path_invariant_ptp_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Movimenti PTP invarianti per il percorso ", 
"snippet" : "Per i movimenti PTP, il percorso nello spazio dipende dalla cinematica e sono fissi solo i punti di partenza e di arrivo. Il movimento è completamente sincrono in modo che la fase di accelerazione, movimento costante e decelerazione per tutti gli assi inizi e termini contemporaneamente. I movimenti ...", 
"body" : "Per i movimenti PTP, il percorso nello spazio dipende dalla cinematica e sono fissi solo i punti di partenza e di arrivo. Il movimento è completamente sincrono in modo che la fase di accelerazione, movimento costante e decelerazione per tutti gli assi inizi e termini contemporaneamente. I movimenti PTP sono sempre invarianti di percorso e pertanto si applicano le seguenti caratteristiche: Il percorso è indipendente dall'override. Il percorso è indipendente da tutti i limiti dinamici degli assi (limiti di velocità, accelerazione, decelerazione e strappo). L'unica eccezione è per determinare i punti di taglio in TMStartVelocity modalità. In TMCornerDistance modalità, il percorso è indipendente dal tipo di fusione ( BlendingHigh \/ Low \/ Previous \/ Next ). Il percorso non è partito in stop o stop ( MC_GroupHalt \/ MC_GroupStop ). Il percorso non viene abbandonato in caso di interruzione o continua ( MC_GroupInterrupt \/ MC_GroupContinue ). " }, 
{ "title" : "Movimenti CP ", 
"url" : "_sm_robotics_cp_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Movimenti CP ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_sm_overview_robotics_motion_control_cp.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Movimenti CP \/ Panoramica ", 
"snippet" : "I movimenti CP (Continuous Path) sono dati dal loro percorso geometrico. Nel caso della robotica si tratta di segmenti lineari ( MC_MoveLinearAbsolute E MC_MoveLinearRelative ) e segmenti circolari ( MC_MoveCircularAbsolute E MC_MoveCircularRelative ). Per i movimenti CP è possibile specificare una ...", 
"body" : "I movimenti CP (Continuous Path) sono dati dal loro percorso geometrico. Nel caso della robotica si tratta di segmenti lineari ( MC_MoveLinearAbsolute E MC_MoveLinearRelative ) e segmenti circolari ( MC_MoveCircularAbsolute E MC_MoveCircularRelative ). Per i movimenti CP è possibile specificare una velocità vettoriale massima, un'accelerazione vettoriale massima e uno strappo massimo della traiettoria. Se la fusione viene eseguita tra due movimenti CP e se entrambi i movimenti giacciono su un piano comune, allora questo piano non viene lasciato durante la fusione. Ad esempio, due segmenti consecutivi di retta giacciono sempre sullo stesso piano. La geometria del percorso non determina ancora il modo in cui l'orientamento del TCP viene trasferito dall'orientamento iniziale all'orientamento di destinazione. Ciò è spiegato nel Interpolazione di orientamento per movimenti CP sezione. I movimenti CP iniziano e finiscono sempre nello stesso modo configurazione del robot. Non è possibile modificare la configurazione con movimenti CP perché il robot si muoverebbe attraverso una posizione singolare. Il movimento attraverso una posizione singolare può portare a velocità degli assi illimitate. Puoi usare Movimenti PTP invarianti per il percorso per passare da una configurazione all'altra. " }, 
{ "title" : "Interpolazione di orientamento per movimenti CP ", 
"url" : "_sm_robotics_orientation_interpolation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Movimenti CP \/ Interpolazione di orientamento per movimenti CP ", 
"snippet" : "Con movimenti CP come MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute o MC_MoveCircularRelative qualsiasi orientamento target dell'utensile può essere specificato tramite la posizione target del movimento. La conseguenza di ciò è che l'orientamento dell'utensile viene trasfer...", 
"body" : "Con movimenti CP come MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute o MC_MoveCircularRelative qualsiasi orientamento target dell'utensile può essere specificato tramite la posizione target del movimento. La conseguenza di ciò è che l'orientamento dell'utensile viene trasferito all'orientamento del target durante il movimento del percorso, con la punta dell'utensile che si sposta sul percorso. Per inciso, è irrilevante per l'interpolazione dell'orientamento in quale sistema di coordinate è stato specificato l'orientamento del target, ad esempio in coordinate assi (ACS) o coordinate macchina (MCS). L'immagine seguente mostra un'interpolazione lineare con l'interpolazione dell'orientamento simultaneo. La freccia rossa indica la direzione dell'utensile nei punti iniziale e finale. La linea rossa tratteggiata indica come l'utensile è posizionato in alcune posizioni durante l'interpolazione. I blocchi funzione sopra menzionati per i movimenti di traiettoria hanno il OrientationMode ingresso. Questo input definisce come l'orientamento iniziale viene passato all'orientamento di destinazione. Interpolazione del cerchio massimo ( SMC_Orientation_Mode.GreatCircle ) Questa è un'impostazione predefinita. Con questa impostazione, l'orientamento iniziale viene passato anche all'orientamento target nella distanza più breve. La distanza più breve significa che l'utensile viene ruotato nell'orientamento target in modo che l'angolo di rotazione percorso sia ridotto al minimo. Interpolazione dell'orientamento dell'asse ( SMC_Orientation_Mode.Axis ) Esempio 1: interpolazione del cerchio massimo Considera un gantry con un asse C con un intervallo di valori da -360° a 360°. L'orientamento iniziale è C=179° e l'orientamento target è C=-175°. L'interpolazione del cerchio massimo sposta l'asse C dell'angolo ZYZ di Eulero (A,B,C) proporzionalmente alla distanza percorsa sul percorso da 179° in direzione positiva oltre 180° fino a 185°, che corrisponde a -175°. In questo caso, percorre un angolo totale di 6°. Esempio 2: interpolazione dell'orientamento degli assi Consideriamo ancora il gantry con un asse C con un intervallo di valori da -180° a 180°. L'orientamento iniziale è C=179° e l'orientamento target è C=-175°. L'interpolazione degli assi sposta l'asse C del gantry proporzionalmente alla distanza percorsa sulla traiettoria da 179° in direzione negativa oltre 0° fino a -175°, percorrendo un angolo totale di 354°. (Se in questo esempio fosse stata utilizzata l'interpolazione del cerchio massimo, si sarebbe verificato un errore, poiché lo spazio di lavoro dell'asse C sarebbe stato superato.) Questi due tipi di interpolazione differiscono per alcune importanti caratteristiche. Nell'interpolazione del cerchio massimo, è possibile prevedere il cambiamento nell'orientamento dell'utensile. Nell'interpolazione degli assi, è difficile prevedere il cambiamento di orientamento, perché gli assi di orientamento possono influenzare l'orientamento in modo diverso a seconda della posizione. L'interpolazione dell'orientamento degli assi condivide questa caratteristica con i movimenti PTP. (Tuttavia, ciò non significa che sia difficile prevedere il percorso nello spazio per l'interpolazione dell'orientamento degli assi. Il percorso è lo stesso per entrambi i tipi di interpolazione dell'orientamento e il TCP percorre sempre esattamente il contorno definito.) Con l'interpolazione del cerchio massimo, le singolarità nella cinematica di orientamento non possono essere percorse. Questo è facilmente possibile con l'interpolazione degli assi. Nell'interpolazione ortodromica possono verificarsi violazioni dei limiti degli assi di orientamento, come menzionato nel secondo esempio. Durante il comando è quindi necessario assicurarsi che non vengano violati i limiti dell'asse durante il movimento verso l'orientamento di destinazione con la rotazione più breve. Con l'interpolazione degli assi è possibile ruotare più di 360°. Se un asse di orientamento ha un'area di lavoro di oltre 360°, è possibile spostarsi ad esempio nella posizione 540° invece che nella posizione 180°. Ciò corrisponde allo stesso orientamento dell'utensile. Con l'interpolazione ortodromica questo non è possibile. La rotazione più breve rispetto all'orientamento del bersaglio corrisponde sempre a un angolo totale massimo di 180°. L'interpolazione dell'orientamento degli assi richiede una cinematica accoppiata composta da cinematica di posizione e utensile. La parte della posizione deve implementare l'interfaccia ISMPositionKinematics_Offset2 . Se le cinematiche non hanno assi rotanti e implementano l'interfaccia ISMPositionKinematics , quindi la modalità di orientamento selezionata ( SMC_Orientation_Mode ) viene ignorato. Singolarità nell'interpolazione dell'orientamento degli assi Con l'interpolazione dell'orientamento degli assi può avvenire un movimento di traiettoria attraverso le singolarità della cinematica di orientamento, che può facilitare notevolmente la programmazione. Le singolarità della cinematica di posizione cambiano per questo scopo. Nel caso di grande interpolazione circolare, Scara3_Z ha singolarità se il punto di flangia (A3) si trova sulla linea definita dalla prima parte del braccio (se il secondo angolo di giunzione è 0°). Per l'interpolazione dell'orientamento dell'asse, le singolarità della cinematica di posizione cambiano in modo che il TCP assuma il ruolo che altrimenti avrebbe il punto di flangia (A3). Questa singolarità si verifica quando il TCP (non il punto di flangia) si trova sulla linea definita dalla prima parte del braccio. Quando si comanda un movimento con interpolazione dell'orientamento dell'asse, viene verificato se questa singolarità modificata si trova o meno tra le posizioni di inizio e di arrivo del movimento. In caso affermativo, il movimento non viene accettato e viene emesso un errore. Per i robot a braccio articolato a 6 assi la situazione è paragonabile a Scara3_Z, ma sono possibili due singolarità. Il primo si verifica quando il TCP si trova sulla linea attraverso A2 e A3. Il secondo si verifica quando il TCP si trova sulla linea attraverso A1. Il comandante controlla anche qui che nessuna singolarità sia attraversata. Può capitare che la configurazione di Scara3 (o del robot a braccio articolato a 6 assi) cambi quando si viaggia con interpolazione dell'orientamento degli assi. Tuttavia, alla fine del movimento viene sempre applicata la stessa configurazione che il robot aveva al punto di partenza. " }, 
{ "title" : "Assi aggiuntivi ", 
"url" : "_sm_additional_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Assi aggiuntivi ", 
"snippet" : "Gli assi aggiuntivi sono assi che fanno parte del gruppo di assi ma non della cinematica. Possono essere spostati in modo sincrono con il movimento coordinato della cinematica. Gli assi aggiuntivi e gli assi della cinematica iniziano a muoversi e raggiungono contemporaneamente la posizione desiderat...", 
"body" : "Gli assi aggiuntivi sono assi che fanno parte del gruppo di assi ma non della cinematica. Possono essere spostati in modo sincrono con il movimento coordinato della cinematica. Gli assi aggiuntivi e gli assi della cinematica iniziano a muoversi e raggiungono contemporaneamente la posizione desiderata. I movimenti aggiuntivi degli assi vengono attenuati e combinati con movimenti coordinati. Lo stesso vale per i puri movimenti aggiuntivi degli assi, senza alcun movimento della cinematica " }, 
{ "title" : "Differenze rispetto ai movimenti ad asse singolo ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062102818545", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Assi aggiuntivi \/ Differenze rispetto ai movimenti ad asse singolo ", 
"snippet" : "La differenza principale rispetto ai movimenti ad asse singolo che sono comandati con blocchi funzione come MC_MoveAbsolute o MC_MoveRelative è la sincronizzazione del movimento. Se la sincronizzazione non è importante, potrebbe avere senso comandare gli assi con blocchi funzione ad asse singolo per...", 
"body" : "La differenza principale rispetto ai movimenti ad asse singolo che sono comandati con blocchi funzione come MC_MoveAbsolute o MC_MoveRelative è la sincronizzazione del movimento. Se la sincronizzazione non è importante, potrebbe avere senso comandare gli assi con blocchi funzione ad asse singolo perché in tal caso gli assi potrebbero essere spostati più rapidamente. Un'altra differenza è che gli assi aggiuntivi vengono gestiti insieme al gruppo di assi. Sono abilitati con SMC_GroupPower e gli errori possono essere ripristinati insieme a MC_GroupReset . Va notato che un errore su un asse singolo di un asse aggiuntivo comporterà un errore di gruppo di assi " }, 
{ "title" : "Comandare movimenti aggiuntivi degli assi ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062103093337", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Assi aggiuntivi \/ Comandare movimenti aggiuntivi degli assi ", 
"snippet" : "Quando si comandano movimenti aggiuntivi degli assi, è sempre possibile scegliere tra movimenti assoluti e relativi, indipendentemente dal fatto che il movimento principale del gruppo di assi sia assoluto o relativo. Ad esempio, un movimento relativo aggiuntivo dell'asse può essere comandato in modo...", 
"body" : "Quando si comandano movimenti aggiuntivi degli assi, è sempre possibile scegliere tra movimenti assoluti e relativi, indipendentemente dal fatto che il movimento principale del gruppo di assi sia assoluto o relativo. Ad esempio, un movimento relativo aggiuntivo dell'asse può essere comandato in modo sincrono con MC_MoveLinearAbsolute comando. I movimenti aggiuntivi degli assi sono comandati tramite AdditionalAxes inserimento dei blocchi funzionali di movimento per il gruppo di assi. Ad esempio, un movimento PTP assoluto con un movimento relativo aggiuntivo dell'asse può essere comandato come segue Se devono essere spostati solo gli assi aggiuntivi, allora un movimento coordinato di lunghezza 0 (ad esempio, MC_MoveDirectRelative con distanza 0 ) può essere comandato insieme a un movimento aggiuntivo dell'asse. " }, 
{ "title" : "Note ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062106608843", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Assi aggiuntivi \/ Note ", 
"snippet" : "Gli assi Modulo sono supportati anche come assi aggiuntivi. Vengono sempre utilizzati shortest modalità per movimenti assoluti aggiuntivi degli assi. Per ulteriori informazioni, vedere quanto segue: MC_DIRECTIONMC_DIRECTION Il numero massimo di assi aggiuntivi è limitato dal parametro della libreria...", 
"body" : "Gli assi Modulo sono supportati anche come assi aggiuntivi. Vengono sempre utilizzati shortest modalità per movimenti assoluti aggiuntivi degli assi. Per ulteriori informazioni, vedere quanto segue: MC_DIRECTIONMC_DIRECTION Il numero massimo di assi aggiuntivi è limitato dal parametro della libreria MAX_NUM_ADDITIONAL_AXES dal SM3_CPKernelDefaults libreria. Questo parametro può essere modificato nel Library Manager. Per un esempio su come utilizzare assi aggiuntivi, vedere quanto segue: Utilizzo di assi aggiuntivi nella robotica" }, 
{ "title" : "Tolleranze per la precisione del percorso ", 
"url" : "_sm_path_accuracy_tolerances.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Tolleranze per la precisione del percorso ", 
"snippet" : "È possibile impostare tolleranze per la precisione del percorso per i gruppi di assi. In caso di movimento imprevisto di un sistema di coordinate dinamico, queste tolleranze consentono a un gruppo di assi di recuperare il ritardo con questo sistema di coordinate invece di fermarsi con errore SMC_AXI...", 
"body" : "È possibile impostare tolleranze per la precisione del percorso per i gruppi di assi. In caso di movimento imprevisto di un sistema di coordinate dinamico, queste tolleranze consentono a un gruppo di assi di recuperare il ritardo con questo sistema di coordinate invece di fermarsi con errore SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED , O SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED . " }, 
{ "title" : "Panoramica ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4560250800668834033944790208", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Tolleranze per la precisione del percorso \/ Panoramica ", 
"snippet" : "Perché le tolleranze sono necessarie per la precisione del percorso? Idealmente, il gruppo di assi dovrebbe seguire esattamente il percorso. Tuttavia, se viene utilizzato un sistema di coordinate dinamico (ad esempio, un oggetto su un nastro o una tavola rotante, oppure un sistema di coordinate spec...", 
"body" : "Perché le tolleranze sono necessarie per la precisione del percorso? Idealmente, il gruppo di assi dovrebbe seguire esattamente il percorso. Tuttavia, se viene utilizzato un sistema di coordinate dinamico (ad esempio, un oggetto su un nastro o una tavola rotante, oppure un sistema di coordinate specificato da un altro gruppo di assi), in alcuni casi non è possibile seguire il percorso. Esempio: un robot deve posizionare un pezzo su un nastro trasportatore. Il nastro si muove a velocità costante, ma appena prima che il robot raggiunga la posizione in cui posizionare il pezzo, il nastro accelera inaspettatamente. In questa situazione la traiettoria per posizionare il pezzo è già stata calcolata, ma presupponendo che il nastro continui a muoversi a velocità costante. Pertanto, il movimento rimanente potrebbe ora portare a una violazione dell'accelerazione massima di uno degli assi del robot. In situazioni come questa, le tolleranze sono importanti. Consentono al gruppo di assi di deviare dal percorso entro i limiti specificati e di raggiungere nuovamente il sistema di coordinate. La precisione del percorso è controllata da un filtro. Il filtro riceve la traiettoria pianificata ( q_ref ) e le ultime posizioni target calcolate ( q_set ) come input. L'output del filtro sono le posizioni target ( q_set ), che vengono trasferiti alle unità. Se q_ref viola uno dei limiti dell'asse, il filtro abbandona il percorso e segue la traiettoria pianificata il più fedelmente possibile senza violare un limite dell'asse. Finché il ritardo tra q_set E q_ref rientra nelle tolleranze, non viene emesso alcun errore. Le tolleranze per la precisione del percorso sono costituite da diversi valori: Lag massimo del TCP in unità tecniche (valore predefinito: 1 u ) Errore massimo di orientamento del TCP in gradi angolari (valore predefinito: 1 deg ) Ritardo massimo consentito di ciascun asse in unità tecniche dell'asse (valore predefinito: infinito) " }, 
{ "title" : "Effetto sui blocchi funzione amministrativi ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4579672191731234033944887183", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Tolleranze per la precisione del percorso \/ Effetto sui blocchi funzione amministrativi ", 
"snippet" : "I valori di posizione, velocità, accelerazione e jerk restituiti da SMC_GroupReadSetPosition , SMC_GroupReadSetVelocity , SMC_GroupReadSetAcceleration , E SMC_GroupReadSetJerk i blocchi funzione vengono calcolati in base alla traiettoria pianificata ( q_ref ). Pertanto non contengono il contributo d...", 
"body" : "I valori di posizione, velocità, accelerazione e jerk restituiti da SMC_GroupReadSetPosition , SMC_GroupReadSetVelocity , SMC_GroupReadSetAcceleration , E SMC_GroupReadSetJerk i blocchi funzione vengono calcolati in base alla traiettoria pianificata ( q_ref ). Pertanto non contengono il contributo del filtro. D'altro canto, i valori attuali di posizione, velocità e jerk, che vengono restituiti dal file MC_GroupReadActualPosition , MC_GroupReadActualVelocity , E MC_GroupReadActualAcceleration blocchi funzione – vengono calcolati in base alla posizione effettiva degli azionamenti del gruppo di assi. Contengono quindi anche il contributo del filtro. Le dinamiche del percorso restituite da SMC_GroupReadPathDynamics con Source = MC_SOURCE.SET si basa sulla traiettoria pianificata ( q_ref ) e quindi non viene influenzato dal filtro. (Per altri valori di Source ingresso, il contributo del filtro è incluso) I trigger si riferiscono sempre alla traiettoria pianificata ( q_ref ). L'ora restituita da MC_GroupReadTrigger è il momento in cui la traiettoria pianificata raggiunge il trigger. Quando il filtro è attivo ( q_ref<>q_set ), il gruppo di assi normalmente non raggiunge esattamente la posizione e\/o il momento del trigger. Nota: si segnala un movimento Done solo quando sia la traiettoria pianificata ( q_ref ) è arrivato alla fine del movimento e il filtro non è (o non è più) attivo (ovvero è stato eliminato un possibile ritardo). Quindi la posizione impostata ( q_set ) corrisponde alla posizione target del movimento. " }, 
{ "title" : "Impostazione delle tolleranze e monitoraggio della deviazione del percorso ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4575205545955234033945121691", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Tolleranze per la precisione del percorso \/ Impostazione delle tolleranze e monitoraggio della deviazione del percorso ", 
"snippet" : "Le tolleranze possono essere impostate utilizzando il SMC_GroupSetPathTolerance blocco funzione. Lo stato del filtro e il ritardo attuale tra la traiettoria pianificata q_ref e i valori impostati q_set del gruppo di assi può essere monitorato con InSync , PositionLag , E OrientationLag uscite di MC_...", 
"body" : "Le tolleranze possono essere impostate utilizzando il SMC_GroupSetPathTolerance blocco funzione. Lo stato del filtro e il ritardo attuale tra la traiettoria pianificata q_ref e i valori impostati q_set del gruppo di assi può essere monitorato con InSync , PositionLag , E OrientationLag uscite di MC_GroupReadStatus . InSync = TRUE significa che q_ref = q_set e che il filtro non è attivo. InSync = FALSE significa che q_ref<>q_set e che il filtro sia attivo. " }, 
{ "title" : "Buffering e fusione dei movimenti ", 
"url" : "_sm_robotics_blending.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Buffering e fusione dei movimenti ", 
"snippet" : "I comandi di movimento possono essere bufferizzati con CODESYS SoftMotion . Per ogni movimento comandato, è possibile specificare in che modo il movimento viene bufferizzato e come deve essere eseguita la fusione dal movimento precedente al nuovo movimento. Il percorso comandato viene regolato arrot...", 
"body" : "I comandi di movimento possono essere bufferizzati con CODESYS SoftMotion . Per ogni movimento comandato, è possibile specificare in che modo il movimento viene bufferizzato e come deve essere eseguita la fusione dal movimento precedente al nuovo movimento. Il percorso comandato viene regolato arrotondando gli angoli in modo da poterlo percorrere senza fermarsi È possibile configurare se un movimento è bufferizzato o meno e come viene eseguito tramite BufferMode input del blocco di movimento (ad esempio, MC_MoveDirectAbsolute o MC_MoveCircularRelative ). Per ulteriori informazioni, vedere quanto segue: MC_Buffer_Mode . Le TransitionMode e TransitionParameter gli input determinano il modo in cui gli angoli vengono arrotondati. Per ulteriori informazioni, vedere quanto segue: MC_TRANSITION_MODE . Per ulteriori informazioni sui movimenti, vedere quanto segue: Blocchi funzionali per i movimenti Nelle modalità di fusione, TransitionMode non deve essere uguale a TMNone . La fusione tra due movimenti inizia non prima della metà del primo movimento e termina al più tardi a metà del secondo movimento. Se il primo movimento è già stato pianificato troppo a lungo, la fusione potrebbe non essere più possibile con i parametri impostati. Quindi l'area di fusione viene ridotta o la fusione non è più possibile. Per garantire una miscelazione riuscita, entrambi i movimenti dovrebbero essere comandati nello stesso ciclo. " }, 
{ "title" : "Dinamica del percorso durante la fusione ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-idm43523137701146", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Buffering e fusione dei movimenti \/ Dinamica del percorso durante la fusione ", 
"snippet" : "Se la fusione viene eseguita tra movimenti CP (tra segmenti lineari e circolari), si deve notare che l'accelerazione massima del percorso e lo strappo massimo del percorso possono essere superati durante la fusione. Quanto più breve è l'intervallo di fusione, tanto più evidente sarà questo effetto. ...", 
"body" : "Se la fusione viene eseguita tra movimenti CP (tra segmenti lineari e circolari), si deve notare che l'accelerazione massima del percorso e lo strappo massimo del percorso possono essere superati durante la fusione. Quanto più breve è l'intervallo di fusione, tanto più evidente sarà questo effetto. Tuttavia, i limiti degli assi (l'accelerazione massima dell'asse e lo strappo massimo dell'asse) vengono sempre mantenuti Pertanto, se l'accelerazione massima del percorso è bassa e l'accelerazione massima dell'asse è alta, durante la fusione possono verificarsi accelerazioni troppo elevate. Ciò può essere contrastato mediante AccFactor immissione dei blocchi di movimento, ad esempio, riducendo l'accelerazione massima dell'asse per un movimento. " }, 
{ "title" : "Caratteristiche di TMStartVelocity ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231378653745", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Buffering e fusione dei movimenti \/ Caratteristiche di TMStartVelocity ", 
"snippet" : "Il calcolo dei punti di fusione si basa su una curva di velocità idealizzata, che può deviare dalla curva di velocità effettiva. In questo momento, viene simulata una rampa di decelerazione sul percorso originale verso il punto di fusione e una rampa di accelerazione allontanandosi dal punto di fusi...", 
"body" : "Il calcolo dei punti di fusione si basa su una curva di velocità idealizzata, che può deviare dalla curva di velocità effettiva. In questo momento, viene simulata una rampa di decelerazione sul percorso originale verso il punto di fusione e una rampa di accelerazione allontanandosi dal punto di fusione. Come velocità target viene utilizzata la velocità minima del percorso programmata e la velocità massima stimata del percorso risultante dai limiti degli assi. Inoltre, quando si fondono linee rette, viene preso in considerazione l'angolo tra di esse. Un raggio di curvatura minimo per l'elemento di fusione risulta dalla velocità del percorso desiderata e dai limiti dinamici stimati. I punti A' e B' risultano a loro volta da questo raggio e dall'angolo tra le linee rette Se i movimenti vengono rallentati durante il processo di miscelazione nonostante un fattore impostato pari a 1, può essere utile aumentare il fattore. " }, 
{ "title" : "Esempio ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231380207819", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Buffering e fusione dei movimenti \/ Esempio ", 
"snippet" : "In un piccolo esempio di applicazione, si suppone che un pezzo venga prelevato. Il robot deve prima spostarsi sopra il pezzo e poi verso il basso per raccoglierlo. Per raggiungere il pezzo il più velocemente possibile, lo spostamento tra i due movimenti non deve essere interrotto, ma attenuato. La f...", 
"body" : "In un piccolo esempio di applicazione, si suppone che un pezzo venga prelevato. Il robot deve prima spostarsi sopra il pezzo e poi verso il basso per raccoglierlo. Per raggiungere il pezzo il più velocemente possibile, lo spostamento tra i due movimenti non deve essere interrotto, ma attenuato. La fusione nel secondo movimento dovrebbe iniziare dieci unità prima che venga raggiunta la fine del primo movimento Per soddisfare i requisiti, è necessario comandare due movimenti. Il primo movimento moveAbove ) sul pezzo e il secondo movimento ( moveDown ) verso il basso verso il pezzo. Per il secondo movimento, è necessario definire in che modo il movimento deve essere tamponato e miscelato Come mostrato nell'immagine seguente, BlendingHigh è selezionato per BufferMode Questo definisce che il movimento deve essere tamponato dopo il primo movimento e poi miscelato. Inoltre, TransitionMode , TMCornerDistance è definito con una distanza di 10 unità per fondere uniformemente il primo movimento con il secondo movimento. Per impostare i due ingressi TransitionMode e TransitionParameter appropriatamente, il SMC_CornerDistance viene utilizzato il blocco funzione. " }, 
{ "title" : "Attesa tra i movimenti ", 
"url" : "_sm_robotics_wait.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Attesa tra i movimenti ", 
"snippet" : "SoftMotion Robotics fornisce la capacità di attendere un tempo specifico tra due movimenti. Ciò può essere necessario, ad esempio, quando si suppone che un robot afferri un pezzo nella posizione target di un movimento prima di iniziare il movimento successivo. Analogamente ai movimenti, il tempo di ...", 
"body" : "SoftMotion Robotics fornisce la capacità di attendere un tempo specifico tra due movimenti. Ciò può essere necessario, ad esempio, quando si suppone che un robot afferri un pezzo nella posizione target di un movimento prima di iniziare il movimento successivo. Analogamente ai movimenti, il tempo di attesa viene comandato tramite il SMC_GroupWait blocco funzione. Per ulteriori informazioni su questo blocco funzione, vedere: SMC_GroupWait . " }, 
{ "title" : "Arresto sul percorso con MC_GroupHalt o MC_GroupStop ", 
"url" : "_sm_robotics_halt_stop.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Arresto sul percorso con MC_GroupHalt o MC_GroupStop ", 
"snippet" : "IL MC_GroupHalt E MC_GroupStop i blocchi funzione consentono l'arresto sul percorso, tenendo conto dei limiti di decelerazione e jerk configurabili. L'arresto inizia immediatamente. I limiti di decelerazione e di strappo per l'arresto possono differire da quelli del movimento attivo e possono essere...", 
"body" : "IL MC_GroupHalt E MC_GroupStop i blocchi funzione consentono l'arresto sul percorso, tenendo conto dei limiti di decelerazione e jerk configurabili. L'arresto inizia immediatamente. I limiti di decelerazione e di strappo per l'arresto possono differire da quelli del movimento attivo e possono essere maggiori o minori. Vengono mantenuti finché il sentiero non viene abbandonato. Al centro del percorso, ad esempio, è possibile una fermata dolce con una decelerazione ridotta. Alla fine del percorso, tuttavia, la decelerazione è almeno sufficientemente forte da impedire qualsiasi spostamento oltre la fine. Differenza fra MC_GroupHalt E MC_GroupStop La differenza principale tra MC_GroupHalt E MC_GroupStop è quello un MC_GroupStop non può essere interrotto e che i movimenti successivi vengono accettati solo dopo il Execute l'ingresso è stato ripristinato. UN MC_GroupStop impedisce al gruppo di assi di spostarsi. Differenziazione da MC_GroupInterrupt In contrasto con MC_GroupHalt E MC_GroupStop , UN MC_GroupInterrupt inizia con un breve ritardo e non ha limiti di decelerazione e jerk configurabili. Vengono invece utilizzati i limiti del movimento attivo. Dopo un MC_GroupInterrupt , con si può riprendere il movimento interrotto MC_GroupContinue . Con l'aiuto di SMC_GroupSaveContinueData , questo è possibile anche con MC_GroupHalt E MC_GroupStop . Per ulteriori informazioni, vedere: Interruzione e continuazione dei movimenti. Comportamento con movimenti in sistemi di coordinate mobili Per i movimenti in sistemi di coordinate in movimento (ad esempio, quando il robot si muove rispetto a un nastro trasportatore), an MC_GroupHalt O MC_GroupStop comporta uno stop assoluto. Pertanto, non viene arrestato rispetto al sistema di coordinate in movimento. Il gruppo di assi rimane sul percorso che avrebbe percorso nel sistema di coordinate macchina (SCM) altrimenti MC_GroupHalt O MC_GroupStop era stato comandato. " }, 
{ "title" : "Pianificazione del movimento ", 
"url" : "_sm_robotics_factor_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Pianificazione del movimento ", 
"snippet" : "Quando viene comandato un movimento, ad esempio con MC_MoveLinearAbsolute , la velocità risultante del robot dipende dai seguenti fattori: La velocità massima, l'accelerazione e lo strappo configurati per ciascun asse del gruppo di assi. (configurato nella configurazione degli assi). I limiti superi...", 
"body" : "Quando viene comandato un movimento, ad esempio con MC_MoveLinearAbsolute , la velocità risultante del robot dipende dai seguenti fattori: La velocità massima, l'accelerazione e lo strappo configurati per ciascun asse del gruppo di assi. (configurato nella configurazione degli assi). I limiti superiori definiscono per ciascun asse la velocità con cui è consentito muoversi. Gli altri limiti spiegati di seguito possono solo ridurre i limiti effettivi. Non possono aumentarli oltre questi limiti. La velocità massima, l'accelerazione e lo strappo forniti come input al blocco funzione di movimento. Questi limiti superiori definiscono la velocità con cui il TCP può muoversi lungo il percorso. Valgono in aggiunta ai limiti dei singoli assi. L'attuale override (vedi MC_GroupSetOverride ) e i limiti accessori per un gruppo di assi Per una descrizione di come tutti questi limiti vengono combinati per calcolare il percorso effettivo e i limiti dell'asse, consultare la guida di SMC_GroupSetAncillaryAxisLimits , SMC_GroupSetAncillaryPathLimits , E SMC_GroupSetAxisLimitFactors . Il percorso programmato del robot Ad esempio, quando la fusione tra i movimenti determina un raggio di curvatura molto piccolo, il robot deve muoversi lentamente per non superare i limiti dell'asse. Insieme, questi fattori determinano la velocità massima effettiva sul percorso. Tuttavia, esiste un altro fattore che può limitare la velocità raggiungibile: le prestazioni del PLC. Se le prestazioni non sono sufficienti per pianificare il movimento, il robot si muove a una velocità inferiore. Se, per motivi di prestazioni, l'algoritmo di pianificazione non può verificare se è sicuro accelerare, si sposterà invece a una velocità inferiore. Per ulteriori informazioni, vedere: Prestazione" }, 
{ "title" : "Interruzione e continuazione dei movimenti ", 
"url" : "_sm_robotics_stop_continue_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Interruzione e continuazione dei movimenti ", 
"snippet" : "Mentre un gruppo di assi è in movimento, il movimento può essere interrotto. Questo può essere un arresto intenzionale ( MC_GroupHalt , MC_GroupStop ), o una pausa sul percorso ( MC_GroupInterrupt ), o un arresto a causa di un errore. In tutti i casi, CODESYS SoftMotion fornisce blocchi funzione per...", 
"body" : "Mentre un gruppo di assi è in movimento, il movimento può essere interrotto. Questo può essere un arresto intenzionale ( MC_GroupHalt , MC_GroupStop ), o una pausa sul percorso ( MC_GroupInterrupt ), o un arresto a causa di un errore. In tutti i casi, CODESYS SoftMotion fornisce blocchi funzione per riportare il gruppo di assi sul percorso pianificato e continuarlo. Arresto di un movimento a causa di un errore Se un movimento viene interrotto a causa di un errore, i singoli assi di un gruppo di assi vengono arrestati singolarmente e commutati nello stato di errore. Nel processo, il TCP lascia il percorso pianificato. Ora è possibile confermare l'errore, ripristinare il gruppo di assi e spostarsi nella posizione in cui è stato rilevato l'errore. Successivamente, è possibile indicare al gruppo di assi di continuare i movimenti pianificati in precedenza. Con il blocco funzione SMC_GroupEnableResumeAfterError attivare la funzione per riprendere i movimenti programmati dopo un errore. Il blocco deve essere richiamato ciclicamente nel task del ciclo bus. È possibile richiamare solo un'istanza di questo blocco funzione per ogni gruppo di assi. Se il gruppo di assi rileva un errore e passa allo stato Errorstop , quindi salva i movimenti già accettati e le informazioni di stato necessarie in una variabile di tipo SMC_AXIS_GROUP_CONTINUE_DATA . Quindi questa variabile contiene i \"dati continui\" e viene passata come input di SMC_GroupEnableResumeAfterError . Quindi puoi usare i movimenti Gruppo_MCContinua riprendere più tardi. Se gli errori sono causati dai movimenti comandati (esempio: violazioni dell'area di lavoro o raggio dell'arco non valido), non possono essere eliminati in questo modo. Questi errori si ripresenteranno dopo la ripresa del movimento. Il meccanismo è più destinato agli errori di un singolo asse e ad altri eventi esterni che forzano il gruppo di assi all'arresto per errore. MC_GroupContinue richiede che il gruppo di assi si trovi in una posizione specifica quando il movimento continua. In caso di ripristino dell'errore, questa posizione è la posizione corrente nel momento in cui è stato rilevato l'errore. È possibile utilizzare questa posizione con il modulo funzione SMC_GroupGetContinuePosition Interrogare. Se un errore del gruppo di assi non consente la continuazione del movimento (come un errore interno durante la scrittura dei dati di continuazione), allora MC_GroupContinue e SMC_GroupGetContinuePosition restituisce il nuovo ID di errore SMC_AXIS_GROUP_CONTINUE_DATA_NOT_WRITTEN . Quando un MC_GroupStop è attivo quando si verifica l'errore, quindi il MC_GroupStop di nuovo attivo anche dopo la ripresa. Il gruppo assale si è già fermato e il MC_GroupStop ha cancellato tutti i movimenti in sospeso, quindi non ha luogo alcun movimento. Quando si verifica un errore del gruppo di assi, l'istanza del blocco funzione del movimento attivo emette l'errore (uscite Active e Busy passa a FALSE e uscita Error passa a TRUE ). Anche le istanze dei blocchi funzione di movimenti bufferizzati o combinati, che non sono ancora attivi, generano un errore. Dopo il riavvio, tutte queste istanze di blocchi funzione vengono reimpostate su Busy \/ Active e le loro uscite si resettano a Error \/ CommandAborted . " }, 
{ "title" : "Fermare un movimento mettendo in pausa ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_74b10b31cbbdb856c0a8646354735c5f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Interruzione e continuazione dei movimenti \/ Fermare un movimento mettendo in pausa ", 
"snippet" : "Con l'aiuto dei blocchi funzione MC_GroupInterrupt e MC_GroupInterruptAt puoi mettere in pausa l'esecuzione dei movimenti comandati. Così facendo, MC_GroupInterrupt uno stop istantaneo MC_GroupInterruptAt una sosta in una determinata posizione. Il movimento può quindi più tardi con Gruppo_MCContinua...", 
"body" : "Con l'aiuto dei blocchi funzione MC_GroupInterrupt e MC_GroupInterruptAt puoi mettere in pausa l'esecuzione dei movimenti comandati. Così facendo, MC_GroupInterrupt uno stop istantaneo MC_GroupInterruptAt una sosta in una determinata posizione. Il movimento può quindi più tardi con Gruppo_MCContinua continua. Il blocco funzione MC_GroupInterruptAt fornisce l'input SMC_GroupInterruptPositionMvtRel . Specifica una posizione di interruzione relativa a un movimento. Il movimento è referenziato dal suo SMC_Movement_Id . La posizione all'interno del movimento è definita da un valore (reale) compreso tra 0 e 1, dove 0 è l'inizio del movimento e 1 è la fine. Una posizione tra i punti B e A viene interpretata esattamente come se non ci fosse fusione. Una posizione tra P cominciare e B o tra A e P destinazione è proiettato sul percorso di fusione. Gestione degli errori per MC_GroupInterruptAt Quando l'ID movimento specificato è sconosciuto, il blocco funzione restituisce un errore. Il movimento in corso non viene interrotto. Se lo stato dinamico attuale del gruppo di assi non consente di raggiungere l'arresto prima della posizione di interruzione specificata, allora SMC_GroupInterruptAt si comporta esattamente come MC_GroupInterrupt : l'interruzione viene eseguita immediatamente e il gruppo di assi raggiunge l'arresto da qualche parte dietro la posizione di interruzione comandata. Tutti gli altri errori vengono gestiti esattamente come per MC_GroupInterrupt Restrizioni su MC_GroupInterruptAt Un'interruzione in una posizione specifica può essere interrotta con un altro movimento finché il processo di arresto nella posizione di interruzione non è ancora iniziato. È possibile comandare un solo interrupt alla volta in una posizione specifica. Se è stato comandato un interrupt, allora deve essere completato o interrotto in modo che un altro interrupt possa essere accettato. Quando esegui MC_GroupInterrupt o MC_GroupInterruptAt , dapprima viene eseguito un arresto invariante di percorso, simile a un MC_GroupHalt . Quindi lo stato del gruppo di assi (\"continua dati\") viene memorizzato in una variabile trasferita dall'utente (tipo SMC_AXIS_GROUP_CONTINUE_DATA ). Ora il gruppo di assi è nello stato GroupStandby e può essere utilizzato normalmente. Un tipico esempio potrebbe essere che il gruppo di assi sia in jog. Puoi venire con me più tardi MC_GroupContinue riprendere l'esecuzione interrotta. A tal fine, trasferire i \"Dati continuativi\" salvati. Affinché ciò funzioni senza errori, la posizione del gruppo di assi deve corrispondere alla posizione che avrà dopo l'esecuzione MC_GroupInterrupt aveva. (Per favore, riferisci SMC_GroupGetContinuePosition .) Quando un movimento di tracciamento è stato interrotto (ovvero un movimento che è stato comandato rispetto a un sistema di coordinate dinamico), MC_GroupInterrupt non si ferma assolutamente (come MC_GroupHalt ), ma relativamente al sistema di coordinate dinamiche. Ad esempio, se un pezzo viene tracciato su una tavola rotante, MC_GroupInterrupt si ferma rispetto al pezzo. Il gruppo di assi continua a seguire il pezzo. I dati continue devono essere aggiornati SMC_GroupUpdateContinueData se la cinematica ha assi rotanti a più periodi. Successivamente, il movimento può essere continuato con MC_GroupContinue . La variabile di tipo SMC_AXIS_GROUP_CONTINUE_DATA non devono essere memorizzati in modo permanente o modificati durante una modifica online. Utilizzo del blocco funzione SMC_GroupWait , è possibile attendere sul percorso tra due movimenti per un tempo programmabile. " }, 
{ "title" : "Arresto del movimento da MC_GroupHalt o MC_GroupStop ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_28e8e9a71ed1fa93c0a8646375852228", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Interruzione e continuazione dei movimenti \/ Arresto del movimento da MC_GroupHalt o MC_GroupStop ", 
"snippet" : "Dopo un arresto del movimento attivato da MC_GroupHalt o MC_GroupStop , il movimento del gruppo di assi può essere ripreso come segue senza perdita di informazioni: Richiamare il blocco funzione SMC_GroupSaveContinueData prima di chiamare MC_GroupHalt o MC_GroupStop . Questa POU salva lo stato corre...", 
"body" : "Dopo un arresto del movimento attivato da MC_GroupHalt o MC_GroupStop , il movimento del gruppo di assi può essere ripreso come segue senza perdita di informazioni: Richiamare il blocco funzione SMC_GroupSaveContinueData prima di chiamare MC_GroupHalt o MC_GroupStop . Questa POU salva lo stato corrente, la posizione corrente e tutti i movimenti comandati nel momento in cui è stato chiamato il comando di arresto o arresto. Ciò consente di continuare il movimento in seguito esattamente da questa posizione. Nota: questa NON è la posizione che il gruppo di assi aveva dopo aver raggiunto la posizione di arresto. Comportamento prima della versione 4.12.0.0: The SMC_GroupSaveContinueData il blocco funzione deve essere chiamato nello stesso ciclo in cui MC_GroupHalt o MC_GroupStop è chiamato. In questo momento, devi assicurarti che SMC_GroupSaveContinueData viene chiamato prima MC_GroupHalt o MC_GroupStop . In caso contrario, i movimenti interrotti verranno rimossi dalla coda. Comportamento dalla versione 4.12.0.0: The SMC_GroupSaveContinueData il blocco funzione può essere richiamato in qualsiasi momento fino al primo movimento successivo al richiamo MC_GroupHalt o MC_GroupStop . La posizione di proseguimento è la posizione attuale del gruppo di assi al momento del primo richiamo del blocco funzionale. Il percorso salvato è costituito da tutti i movimenti che sono stati accettati prima del comando di arresto\/arresto. Per poter continuare il percorso nella posizione in cui il gruppo di assi si è fermato a causa di MC_GroupHalt o MC_GroupStop , SMC_GroupSaveContinueData dovrebbe essere chiamato nel ciclo in cui MC_GroupHalt o MC_GroupStop imposta il Done segnale. Solo un'istanza di SMC_GroupSaveContinueData può essere chiamato per gruppo di assi. Il salvataggio dello stato corrente prima del comando di arresto\/stop può richiedere diversi cicli, ma è garantito che le informazioni di stato nel primo ciclo verranno salvate prima di eventuali movimenti interrotti. SMC_GroupSaveContinueData può essere chiamato in qualsiasi momento per salvare lo stato corrente, non solo in connessione con la chiamata MC_GroupHalt o MC_GroupStop . " }, 
{ "title" : "Interazione con i movimenti ad asse singolo ", 
"url" : "_sm_additional_axes_single_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Interazione con i movimenti ad asse singolo ", 
"snippet" : "Ogni asse di un gruppo di assi (compresi eventuali assi aggiuntivi) può essere spostato anche con movimenti ad asse singolo. Ciò non richiede la rimozione dell'asse dal gruppo di assi. Vengono utilizzate le seguenti regole: Se il gruppo di assi è nel GroupStandby stato quando viene comandato un movi...", 
"body" : "Ogni asse di un gruppo di assi (compresi eventuali assi aggiuntivi) può essere spostato anche con movimenti ad asse singolo. Ciò non richiede la rimozione dell'asse dal gruppo di assi. Vengono utilizzate le seguenti regole: Se il gruppo di assi è nel GroupStandby stato quando viene comandato un movimento ad asse singolo su uno dei suoi assi, il gruppo di assi rimane in questo stato. Per ulteriori informazioni, vedere quanto segue: Stati del Gruppo dell'AsseSe il gruppo di assi è nel GroupMoving stato quando viene comandato un movimento ad asse singolo su uno dei suoi assi, allora il gruppo di assi passa a GroupError stato. L'errore SMC_AXIS_GROUP_INTERRUPTED_BY_SINGLE_AXIS viene segnalato e tutti gli altri assi vengono fermati. Se si comanda un movimento sul gruppo di assi mentre un movimento ad asse singolo è attivo su almeno uno dei suoi assi, allora il gruppo di assi entra nel GroupError stato. " }, 
{ "title" : "Sincronizzazione con un sistema di coordinate in movimento ", 
"url" : "_sm_robotics_dynamic_tracking.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Sincronizzazione con un sistema di coordinate in movimento ", 
"snippet" : "La funzione di tracciamento integrata consente la programmazione di movimenti relativi a un sistema di coordinate in movimento. Un tipico caso d'uso è prelevare un prodotto da un nastro trasportatore e posizionarlo su un altro nastro trasportatore. Dopo aver definito un sistema di coordinate dinamic...", 
"body" : "La funzione di tracciamento integrata consente la programmazione di movimenti relativi a un sistema di coordinate in movimento. Un tipico caso d'uso è prelevare un prodotto da un nastro trasportatore e posizionarlo su un altro nastro trasportatore. Dopo aver definito un sistema di coordinate dinamico per ciascun nastro, l'utente può semplicemente fornire le posizioni target per i movimenti relativi a questi sistemi di coordinate. CODESYS SoftMotion si occupa di sovrapporre il movimento comandato del gruppo assi e il movimento del nastro. Un tipico movimento di tracciamento è costituito da tre fasi: Tracking in: spostamento da un altro sistema di coordinate al sistema di coordinate dinamico. Dopo che la posizione di destinazione è stata raggiunta, il gruppo di assi seguirà il movimento del sistema di coordinate dinamico. Movimento di tracciamento: spostamento in una posizione diversa all'interno dello stesso sistema di coordinate dinamico. Il movimento comandato e il movimento del sistema di coordinate dinamico saranno sovrapposti. Tracking out: passaggio dal sistema di coordinate dinamico a un sistema di coordinate diverso. Una volta raggiunta la posizione di destinazione, il movimento del gruppo di assi non sarà più influenzato dal movimento del sistema di coordinate dinamico. " }, 
{ "title" : "Definizione di un sistema di coordinate dinamico ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4599737357387233382157942652", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Sincronizzazione con un sistema di coordinate in movimento \/ Definizione di un sistema di coordinate dinamico ", 
"snippet" : "Il primo passaggio dell'implementazione di un'applicazione di tracciamento dinamico è la definizione di un sistema di coordinate dinamico. CODESYS SoftMotion fornisce quattro blocchi funzione per la definizione di sistemi di coordinate dinamici: MC_TrackConveyorBelt : un blocco funzione di facile ut...", 
"body" : "Il primo passaggio dell'implementazione di un'applicazione di tracciamento dinamico è la definizione di un sistema di coordinate dinamico. CODESYS SoftMotion fornisce quattro blocchi funzione per la definizione di sistemi di coordinate dinamici: MC_TrackConveyorBelt : un blocco funzione di facile utilizzo per il caso d'uso comune di tracciamento di un nastro trasportatore. Un riferimento alla cintura effettiva viene fornito tramite il ConveyorBelt input, che prevede un asse SoftMotion di tipo AXIS_REF_SM3 . MC_TrackRotaryTable : un blocco funzione di facile utilizzo per il caso d'uso comune di tracciamento di una tavola rotante. Un riferimento alla tavola rotante effettiva viene fornito tramite il RotaryTable input, che prevede un asse SoftMotion di tipo AXIS_REF_SM3 . MC_SetDynCoordTransform : Il blocco funzione funziona in modo simile a MC_TrackConveyorBelt e MC_TrackRotaryTable , ma, invece di essere controllato da un singolo asse, è controllato da un intero gruppo di assi. Ciò consente di implementare un sistema di coordinate dinamico con un massimo di sei gradi di libertà. SMC_SetDynCoordTransformEx : Il blocco funzione consente di implementare un sistema di coordinate dinamico completamente personalizzato. Ciascuno dei quattro blocchi funzione ha un CoordSystem input che essenzialmente consente di dare un nome al sistema di coordinate PCS_1 o PCS_2 . Quando si comanda un movimento, il sistema di coordinate viene indicato con questo nome. " }, 
{ "title" : "Comando di un movimento verso una posizione in un sistema di coordinate dinamico ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4620464078688033382158385681", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Sincronizzazione con un sistema di coordinate in movimento \/ Comando di un movimento verso una posizione in un sistema di coordinate dinamico ", 
"snippet" : "Dopo aver definito un sistema di coordinate dinamico, è facile comandare un movimento verso una posizione in questo sistema di coordinate. Ogni blocco funzione di movimento, ad esempio MC_MoveLinearAbsolute , ha un CoordSystem ingresso. Questo input deve essere impostato sul nome ( PCS_1 o PCS_2 ) d...", 
"body" : "Dopo aver definito un sistema di coordinate dinamico, è facile comandare un movimento verso una posizione in questo sistema di coordinate. Ogni blocco funzione di movimento, ad esempio MC_MoveLinearAbsolute , ha un CoordSystem ingresso. Questo input deve essere impostato sul nome ( PCS_1 o PCS_2 ) dato al sistema di coordinate dinamico. Il Position l'input può quindi essere impostato sulla posizione desiderata rispetto all'origine del sistema di coordinate dinamico. L'esecuzione del blocco funzione movimento porterà a un movimento verso la posizione all'interno del sistema di coordinate in movimento. Una volta raggiunta la posizione di destinazione, il gruppo di assi seguirà il sistema di coordinate dinamico rimanendo in questa posizione relativa. " }, 
{ "title" : "L'uscita \"InUse\" dei blocchi funzione del sistema di coordinate dinamico ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4663886345662433382158689616", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Sincronizzazione con un sistema di coordinate in movimento \/ L'uscita \"InUse\" dei blocchi funzione del sistema di coordinate dinamico ", 
"snippet" : "Ciascun blocco funzione del sistema di coordinate dinamico ( MC_TrackConveyorBelt , MC_TrackRotaryTable , MC_SetDynCoordTransform , e SMC_SetDynCoordTransformEx ) ha un InUse produzione. Il riavvio di un blocco funzione mentre il sistema di coordinate è ancora in uso non è consentito e provocherà l'...", 
"body" : "Ciascun blocco funzione del sistema di coordinate dinamico ( MC_TrackConveyorBelt , MC_TrackRotaryTable , MC_SetDynCoordTransform , e SMC_SetDynCoordTransformEx ) ha un InUse produzione. Il riavvio di un blocco funzione mentre il sistema di coordinate è ancora in uso non è consentito e provocherà l'errore SMC_AXIS_GROUP_PCS_STILL_IN_USE . Un sistema di coordinate dinamico entrerà in uso non appena viene comandato un movimento verso una posizione nel sistema di coordinate. Rimarrà in uso fino al raggiungimento di una posizione target in un diverso sistema di coordinate. " }, 
{ "title" : "Limiti dell'asse per i movimenti di tracciamento ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4557758355867233382158929251", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Sincronizzazione con un sistema di coordinate in movimento \/ Limiti dell'asse per i movimenti di tracciamento ", 
"snippet" : "I limiti dell'asse devono tenere conto sia del movimento del sistema di coordinate sia del movimento comandato relativo al sistema di coordinate. Se è richiesta un'elevata dinamica dell'asse per seguire il sistema di coordinate, il movimento relativo al sistema di coordinate potrebbe essere lento o ...", 
"body" : "I limiti dell'asse devono tenere conto sia del movimento del sistema di coordinate sia del movimento comandato relativo al sistema di coordinate. Se è richiesta un'elevata dinamica dell'asse per seguire il sistema di coordinate, il movimento relativo al sistema di coordinate potrebbe essere lento o non essere affatto possibile. Se il gruppo di assi è vicino a una singolarità della cinematica, ciò può accadere anche con un sistema di coordinate in movimento relativamente lento. Per ulteriori informazioni, vedere: Scheda: Generale" }, 
{ "title" : "Dinamica del percorso dei movimenti CP durante il tracciamento ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm466388653271043338215917861", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Sincronizzazione con un sistema di coordinate in movimento \/ Dinamica del percorso dei movimenti CP durante il tracciamento ", 
"snippet" : "Una considerazione speciale deve essere data alle dinamiche del percorso dei movimenti CP. Ciò include il Velocity , Acceleration , Deceleration , E Jerk ingressi di MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , E MC_MoveCircularRelative . Se la posizione iniziale e quell...", 
"body" : "Una considerazione speciale deve essere data alle dinamiche del percorso dei movimenti CP. Ciò include il Velocity , Acceleration , Deceleration , E Jerk ingressi di MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , E MC_MoveCircularRelative . Se la posizione iniziale e quella di destinazione si trovano nello stesso sistema di coordinate dinamiche, la dinamica del percorso sarà relativa a questo sistema di coordinate. Tuttavia, se la posizione iniziale e finale si trovano in sistemi di coordinate diversi, le dinamiche del percorso vengono combinate dalla dinamica relativa al primo sistema di coordinate alla dinamica relativa al secondo sistema di coordinate. È importante che la dinamica del percorso sia impostata su un valore superiore al valore assoluto della differenza di dinamica tra i due sistemi di coordinate. In particolare, quando si passa da un sistema di coordinate statico a uno dinamico, la dinamica del percorso dovrebbe essere impostata su un valore superiore al valore assoluto della dinamica del sistema di coordinate. La velocità vettoriale non può essere monitorata con SMC_GroupReadPathDynamics quando ci si sposta tra sistemi di coordinate (tracking in, out o tra diversi sistemi di coordinate dinamici). SMC_GroupReadPathDynamics calcola la dinamica del percorso rispetto a un sistema di coordinate specificato. Nel caso di tracciamento in entrata o in uscita o spostamento tra sistemi di coordinate dinamici, si tratta di un movimento che dipende da due sistemi di coordinate (i sistemi di coordinate di partenza e di destinazione differiscono). Di conseguenza, il SMC_GroupReadPathDynamics il blocco funzione non è adatto per calcolare la dinamica del percorso per questi casi. " }, 
{ "title" : "Evitare gli errori SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED o SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED. ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4558812953211233382159412375", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Sincronizzazione con un sistema di coordinate in movimento \/ Evitare gli errori SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED o SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED. ", 
"snippet" : "Gli errori SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED , O SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED vengono segnalati se non è possibile seguire il percorso comandato senza violare i limiti dell'asse configurati o la dinamica del percorso. Se si verifica questo...", 
"body" : "Gli errori SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED , O SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED vengono segnalati se non è possibile seguire il percorso comandato senza violare i limiti dell'asse configurati o la dinamica del percorso. Se si verifica questo errore, è necessario verificare innanzitutto se i limiti dell'asse e la dinamica del percorso sono configurati secondo le due sezioni precedenti. La deviazione del percorso può essere monitorata con le uscite PositionLag E OrientationLag del MC_GroupReadStatus blocco funzione. Le possibili soluzioni sono le seguenti: Aumentare i limiti dell'asse. Aumenta la dinamica del percorso dei movimenti CP durante il tracciamento in un sistema di coordinate dinamico. Ridurre la dinamica del sistema di coordinate. Evitare movimenti vicini a una singolarità della cinematica, ad esempio riposizionando il robot. Se il sistema di coordinate dinamico è controllato dall'uscita di un encoder rumoroso, potrebbe essere utile filtrare il segnale dell'encoder utilizzando un asse logico. Per ulteriori informazioni, vedere  Scheda: Assi logici. È possibile configurare una tolleranza accettabile per il ritardo di posizione e orientamento utilizzando il SMC_GroupSetPathTolerance blocco funzione. " }, 
{ "title" : "Assi rotanti con range di valori su 360° ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Assi rotanti con range di valori su 360° ", 
"snippet" : "Comportamento in caso di movimenti di PC Durante un movimento CP ( MC_MoveLinearAbsolute \/ MC_MoveLinearRelative , MC_MoveCircularAbsolute \/ MC_MoveCircularRelative ), gli assi rotanti sono sempre azionati in modalità automatica (Periodo 0). Il periodo dell'asse è sempre selezionato in modo che non ...", 
"body" : "Comportamento in caso di movimenti di PC Durante un movimento CP ( MC_MoveLinearAbsolute \/ MC_MoveLinearRelative , MC_MoveCircularAbsolute \/ MC_MoveCircularRelative ), gli assi rotanti sono sempre azionati in modalità automatica (Periodo 0). Il periodo dell'asse è sempre selezionato in modo che non ci siano salti nell'asse. È possibile che al termine dello spostamento del CP, il valore dell'asse comandato non venga raggiunto, ma che l'asse arrivi in un periodo diverso a causa della selezione automatica del periodo. Ciò significa che la posizione comandata non può essere raggiunta con il tipo di movimento selezionato. Questo conflitto viene rilevato prima di raggiungere la posizione di destinazione, il gruppo di assi viene arrestato e viene emesso un errore. Esempio: utilizzi un robot SCARA con tre assi rotanti A1, A2 e A3. A3 ha un intervallo di valori da -360° a +360°. Si insegnano due posizioni nelle coordinate dell'asse. Posizione1 = (A1 = 0°, A2 = 90°, A3 = 170°), Posizione2 = (A1 = 10°, A2 = 90°, A3 = -170°). Quindi comandi un movimento lineare ( MC_MoveLinear\/MC_MoveAbsolute) ) con la modalità di orientamento GreatCircle . Questa combinazione di comando in ACS e interpolazione dell'orientamento ortodromico crea un conflitto. Per seguire l'interpolazione dell'orientamento, l'asse A3 dovrebbe spostarsi da 170° in direzione positiva a 190°. Pertanto non può raggiungere la posizione target richiesta (-170°). Nota: Nei movimenti CP il periodo dell'asse rotante viene determinato dal tipo di interpolazione selezionato. Ciò significa anche che la posizione di destinazione dell'asse dipende dal percorso attraverso il quale viene raggiunto il punto di destinazione. È quindi possibile, ad esempio, che attraverso la fusione tra due movimenti un asse arrivi in un periodo diverso rispetto a quello che sarebbe avvenuto con i movimenti bufferizzati. Per ulteriori informazioni, vedere: Interpolazione di orientamento per movimenti CP" }, 
{ "title" : "introduzione ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_48a1e2bdb79a4093c0a864631bc39e2b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Assi rotanti con range di valori su 360° \/ introduzione ", 
"snippet" : "I robot hanno spesso assi rotanti con un campo di valori oltre i 360°. Ad esempio, l'ultimo asse (asse di orientamento A3) di un robot SCARA può spesso percorrere più di una rotazione, da circa -540 a 540°. Ciò significa che è possibile avvicinarsi alla stessa posizione e orientamento in più modi. C...", 
"body" : "I robot hanno spesso assi rotanti con un campo di valori oltre i 360°. Ad esempio, l'ultimo asse (asse di orientamento A3) di un robot SCARA può spesso percorrere più di una rotazione, da circa -540 a 540°. Ciò significa che è possibile avvicinarsi alla stessa posizione e orientamento in più modi. Considerando ad esempio SCARA, l'orientamento e la posizione dell'utensile è identico, indipendentemente dal fatto che l'ultimo asse sia a -170° oa 190° (= -170° + 360°). Di conseguenza, la conversione della posizione cartesiana e dell'orientamento ai valori degli assi (la trasformazione cinematica inversa) non è univoca, ma ha diverse soluzioni. Questo può essere utilizzato, ad esempio, nelle applicazioni Pick&Place per risparmiare tempo passando da 170° a 190° e non a -170°. Nota: Il movimento dell'asse di orientamento SCARA può diventare rapidamente un fattore limitante per il tempo di ciclo in queste applicazioni. " }, 
{ "title" : "Risoluzione dell'ambiguità ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_e9620f70b79a4093c0a86463477a7031", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Assi rotanti con range di valori su 360° \/ Risoluzione dell'ambiguità ", 
"snippet" : "Se i punti da percorrere sono comandati nel sistema di coordinate degli assi (ACS), allora è chiaro per ogni asse quale valore assumerà nel caposaldo. D'altra parte, nel comando cartesiano (posizione X\/Y\/Z e orientamento in A\/B\/C) questa ambiguità esiste per gli assi rotativi. La configurazione dell...", 
"body" : "Se i punti da percorrere sono comandati nel sistema di coordinate degli assi (ACS), allora è chiaro per ogni asse quale valore assumerà nel caposaldo. D'altra parte, nel comando cartesiano (posizione X\/Y\/Z e orientamento in A\/B\/C) questa ambiguità esiste per gli assi rotativi. La configurazione della cinematica viene utilizzata per risolvere questa ambiguità. Con i robot SCARA, la configurazione include già l'impostazione se lo SCARA deve avvicinarsi a un punto con ElbowRight o ElbowLeft . Inoltre, la configurazione SCARA include anche l'impostazione nPeriodA3 , che può essere utilizzato per determinare come deve essere risolta l'ambiguità per l'asse A3. A tal fine, l'intero campo di valori è suddiviso in periodi della lunghezza massima di 360°: Periodo -1 da -540° a -180° Periodo 1 da -180° a 180° Periodo 2 da 180° a 540° (Per un intervallo di valori più ampio dell'asse, ci sono di conseguenza più periodi possibili.) C'è anche un valore speciale. Se nPeriodA3 := 0 è impostato, quindi viene attivata una risoluzione automatica dell'ambiguità. Per i movimenti PTP, ciò significa che il periodo è selezionato in modo tale che la distanza tra la posizione iniziale e quella di destinazione per l'asse 4 sia la più piccola possibile. (Il comportamento con i movimenti CP è descritto di seguito.) È quindi possibile controllare la risoluzione dell'ambiguità di un asse rotante impostando opportunamente la configurazione cinematica (vedi SMC_SetKinConfiguration ). La cinematica che supporta questa funzionalità implementa l'interfaccia SMKinematicWithConfigurations3 . IL SMC_GroupReadSetPosition , MC_GroupReadActualPosition , E SMC_GroupTargetPosition i blocchi funzione emettono sempre la configurazione con la risoluzione automatica dei periodi attivata. La configurazione corrente con periodi impostati in modo esplicito può essere letta leggendo la posizione nell'ACS e poi convertendola nell'MCS tramite SMC_GroupConvertPosition . La configurazione restituita ha periodi impostati in modo esplicito. Per ulteriori informazioni, vedere: Configurazioni cinematiche" }, 
{ "title" : "Sincronizzazione degli assi esterni, controllo del feed forward della coppia ", 
"url" : "_sm_robotics_external_axis_torque_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Sincronizzazione degli assi esterni, controllo del feed forward della coppia ", 
"snippet" : "I valori degli assi di un gruppo di assi vengono normalmente calcolati alla fine del ciclo dopo aver eseguito il codice applicativo programmato dall'utente. Tuttavia, per alcune applicazioni è necessario che questi valori siano disponibili prima per poterli utilizzare nel codice dell'applicazione. I...", 
"body" : "I valori degli assi di un gruppo di assi vengono normalmente calcolati alla fine del ciclo dopo aver eseguito il codice applicativo programmato dall'utente. Tuttavia, per alcune applicazioni è necessario che questi valori siano disponibili prima per poterli utilizzare nel codice dell'applicazione. IL SMC_GroupAggiornamento Il blocco funzione assicura che i valori di tutti gli assi che fanno parte di un gruppo di assi vengano aggiornati immediatamente. Un caso d'uso per SMC_GroupUpdate è la sincronizzazione degli assi che non fanno parte del gruppo assi. Un esempio potrebbe essere un secondo azionamento per l'asse X nel caso di un portale XY. Prima CODESYS SoftMotion versione 4.13.0.0: un caso d'uso aggiuntivo per SMC_GroupUpdate il blocco funzione è il controllo feed forward della coppia. I valori degli assi calcolati nel ciclo corrente possono essere utilizzati per calcolare le coppie impostate adeguate utilizzando un modello dinamico del robot. In CODESYS SoftMotion versione 4.13.0.0 e successive: se un modello dinamico è stato assegnato al gruppo di assi utilizzando SMC_GroupSetDynamics , le coppie impostate vengono calcolate automaticamente ciclicamente e possono essere utilizzate per il controllo feed forward della coppia. L'impiego di SMC_GroupUpdate non è più necessario per questo caso d'uso. Per ulteriori informazioni, vedere: Limitazione della coppia e controllo dell'avanzamento della coppia" }, 
{ "title" : "Trigger ", 
"url" : "_sm_digital_switches-1517880.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Trigger ", 
"snippet" : "I trigger vengono utilizzati per eseguire un'azione quando il gruppo di assi raggiunge una posizione definita sul percorso. Ad esempio, un distributore di colla può essere acceso quando si raggiunge la posizione di incollaggio. I trigger supportano anche i turni temporali in modo che l'azione possa ...", 
"body" : "I trigger vengono utilizzati per eseguire un'azione quando il gruppo di assi raggiunge una posizione definita sul percorso. Ad esempio, un distributore di colla può essere acceso quando si raggiunge la posizione di incollaggio. I trigger supportano anche i turni temporali in modo che l'azione possa essere eseguita in un momento preciso prima o dopo il raggiungimento della posizione. Questo può essere utilizzato, ad esempio, per compensare i tempi morti di un distributore di colla. A tale scopo CODESYS SoftMotion offre la possibilità di configurare i trigger dei movimenti e quindi di leggere continuamente il tempo rimanente fino al raggiungimento della posizione. Quando si utilizzano i trigger, prestare attenzione a quanto segue: Il tempo fino al raggiungimento di un trigger può essere recuperato solo quando il gruppo di assi si è avvicinato al trigger fino al tempo di una previsione configurabile. Come viene configurata questa previsione e quale impatto hanno le impostazioni è spiegato nel Configurazione dell'applicazione per l'utilizzo dei trigger sezione. La traiettoria non viene modificata dall'uso di trigger. In particolare, la traiettoria non viene rallentata per rispettare la previsione configurata. Se, ad esempio, la posizione di un trigger all'inizio di un movimento viene raggiunta già dopo 0,01 secondi, anche una previsione più elevata non può ottenere che venga fornita una notifica sul raggiungimento del punto con più di 0,01 secondi di anticipo. Per ulteriori informazioni, vedere gli esempi Esempio di trigger 1: esempio semplice E Esempio di trigger 2: processo di incollaggio. " }, 
{ "title" : "Configurazione dell'applicazione per l'utilizzo dei trigger ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612456003211233798533752147", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Trigger \/ Configurazione dell'applicazione per l'utilizzo dei trigger ", 
"snippet" : "Configurazione della durata della previsione La durata della previsione determina quanto nel futuro viene eseguita la pianificazione. Questo è impostato dal fPlanningForecastDuration parametro del SMC_TuneCPKernel blocco funzione. La modalità di impostazione di questo parametro dipende dai requisiti...", 
"body" : "Configurazione della durata della previsione La durata della previsione determina quanto nel futuro viene eseguita la pianificazione. Questo è impostato dal fPlanningForecastDuration parametro del SMC_TuneCPKernel blocco funzione. La modalità di impostazione di questo parametro dipende dai requisiti dell'applicazione. Ci sono due requisiti principalmente contraddittori: Durata della previsione più lunga possibile Latenza più bassa possibile. La latenza all'inizio di un movimento aumenta perché la previsione deve essere stabilita per prima. La dimensione di questa latenza aggiuntiva dipende principalmente dalle prestazioni del controller utilizzato ed è generalmente molto inferiore alla previsione configurata. Inoltre, la latenza del gruppo di assi per reagire all'interruzione di movimenti e interruzioni aumenta della previsione configurata. La previsione non ha alcun impatto su MC_GroupHalt E MC_GroupStop . Entrambi i blocchi funzione agiscono sempre immediatamente e indipendentemente dalla previsione configurata. IL fPlanningForecastDuration parametro del SMC_TuneCPKernel blocco funzione dovrebbe quindi essere impostato al livello più alto necessario ma il più basso possibile. Se non è richiesta una previsione, il parametro può essere lasciato al valore predefinito 0. La previsione effettiva disponibile può differire da quella configurata per vari motivi, ad esempio se la fine dell'ultimo movimento è già quasi raggiunta. L'attuale previsione disponibile può essere monitorata mediante il CurrentPlanningForecast uscita di MC_GroupReadStatus . Configurazione del numero massimo di trigger per movimento Come consegnato, CODESYS SoftMotion supporta fino a 8 trigger per movimento. Se questo numero non è sufficiente, allora il MAX_NUM_TRIGGERS_PER_MOVEMENT parametro può essere modificato come parametro di libreria. Questo è possibile con il Responsabile Biblioteca e il rispettivo editore per il parametri della libreria . Per utilizzare i parametri della libreria, a CODESYS versione >= SP19 è consigliata. " }, 
{ "title" : "Comandare e valutare i trigger ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4620348699414433798534144567", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Trigger \/ Comandare e valutare i trigger ", 
"snippet" : "Sono disponibili due blocchi funzione per comandare i trigger: SMC_GroupPrepareTrigger E SMC_GroupReadTrigger . I trigger sono assegnati a un movimento. Ogni singolo trigger deve essere preparato utilizzando il SMC_GroupPrepareTrigger blocco funzione. La posizione può essere specificata relativa, as...", 
"body" : "Sono disponibili due blocchi funzione per comandare i trigger: SMC_GroupPrepareTrigger E SMC_GroupReadTrigger . I trigger sono assegnati a un movimento. Ogni singolo trigger deve essere preparato utilizzando il SMC_GroupPrepareTrigger blocco funzione. La posizione può essere specificata relativa, assoluta o come intersezione con un piano (vedi SMC_TriggerPositionType ). L'ordine di chiamata di SMC_GroupPrepareTrigger e il rispettivo movimento è di particolare importanza perché i trigger preparati sono assegnati al successivo movimento comandato nello stesso ciclo. Pertanto, in ogni applicazione è necessario prestare attenzione a quanto segue: SMC_GroupPrepareTrigger deve sempre essere chiamato prima del blocco funzione di movimento. I trigger e il rispettivo movimento devono sempre essere comandati nello stesso ciclo. Se nel ciclo non viene avviato alcun movimento, i trigger preparati vengono scartati e il CommandAborted uscita del SMC_GroupPrepareTrigger i blocchi funzione sono impostati. Quando il trigger è assegnato a un movimento, le informazioni su un trigger possono essere recuperate utilizzando SMC_GroupReadTrigger . Non appena il trigger rientra nella durata della previsione disponibile, lo stato cambia in SMC_TRIGGER_STATUS.Active e il tempo fino al raggiungimento del trigger può essere letto. L'ora si riferisce sempre all'ora di inizio del ciclo in corso. A seconda di quando deve essere attivato il trigger (prima, durante o dopo il raggiungimento della posizione), l'azione desiderata può essere eseguita nell'applicazione in un ciclo adeguato. I trigger non possono essere interrotti quando sono stati assegnati a un movimento. Invece, possono semplicemente essere ignorati. Se un movimento viene interrotto da un secondo movimento con MC_BUFFER_MODE.Aborting , scompaiono anche i trigger assegnati al primo movimento. " }, 
{ "title" : "Trigger per movimenti con blending ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612455902227233798534431018", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Controllo del movimento \/ Trigger \/ Trigger per movimenti con blending ", 
"snippet" : "Per movimenti con Buffering e fusione dei movimenti, i trigger vengono proiettati sul percorso di fusione. L'immagine seguente mostra qualitativamente un caso in cui un movimento da P1 a P2 e un movimento successivo sono stati comandati ciascuno con la fusione. La fusione al primo movimento termina ...", 
"body" : "Per movimenti con Buffering e fusione dei movimenti, i trigger vengono proiettati sul percorso di fusione. L'immagine seguente mostra qualitativamente un caso in cui un movimento da P1 a P2 e un movimento successivo sono stati comandati ciascuno con la fusione. La fusione al primo movimento termina nel punto B e la fusione al movimento precedente inizia nel punto A. Il trigger blu si trova tra P1 e B. Viene proiettato sulla metà posteriore del primo movimento di fusione (evidenziato dalla linea blu) . Allo stesso modo, il grilletto rosso, situato tra A e P2, viene proiettato sulla metà anteriore del secondo movimento di sfumatura (evidenziato dalla linea rossa). Il grilletto verde è al di fuori delle aree di fusione e non è spostato. Quando ci si fonde con i trigger, c'è una funzione speciale riguardante lo stato del movimento e i rispettivi trigger. Il blocco funzione di comando per il passaggio da P1 a P2 segnala Done non appena si raggiunge il punto A. Tuttavia, il trigger rosso associato a questo movimento rimane attivo fino a quando non viene raggiunta la posizione sull'elemento di fusione su cui è stato proiettato. " }, 
{ "title" : "Limitazione della coppia e controllo dell'avanzamento della coppia ", 
"url" : "_sm_torque_limitation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitazione della coppia e controllo dell'avanzamento della coppia ", 
"snippet" : "La limitazione di coppia di CODESYS SoftMotion impedisce il superamento dei limiti specificati delle coppie o delle forze degli azionamenti durante i movimenti coordinati. Questi limiti di coppia e forza vengono rispettati in aggiunta ai limiti esistenti per velocità, accelerazione e jerk degli azio...", 
"body" : "La limitazione di coppia di CODESYS SoftMotion impedisce il superamento dei limiti specificati delle coppie o delle forze degli azionamenti durante i movimenti coordinati. Questi limiti di coppia e forza vengono rispettati in aggiunta ai limiti esistenti per velocità, accelerazione e jerk degli azionamenti. Il requisito per questo è un modello dinamico per la cinematica applicata sotto forma di un blocco funzione che implementa il ISMDynamics interfaccia dal SM3_Dynamics biblioteca. Fondamentalmente, un AxesStateToTorque è necessario un metodo che calcoli le coppie richieste per un dato stato degli assi (per la loro posizione, velocità e accelerazione). Oltre alla limitazione della coppia, un modello dinamico consente il calcolo delle coppie impostate per un controllo feed forward della coppia. È possibile trovare un esempio di applicazione nel capitolo Modello di robot dinamico. " }, 
{ "title" : "Casi d'uso ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597660278291233422349551383", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitazione della coppia e controllo dell'avanzamento della coppia \/ Casi d'uso ", 
"snippet" : "In molte cinematiche, in particolare nelle cinematiche seriali, esiste un accoppiamento di più giunti o di tutti i giunti. Un semplice esempio di ciò è il doppio pendolo con azionamenti nelle articolazioni come mostrato di seguito: Caso d'uso 1 Caso d'uso 2 L'azionamento nel primo giunto compie una ...", 
"body" : "In molte cinematiche, in particolare nelle cinematiche seriali, esiste un accoppiamento di più giunti o di tutti i giunti. Un semplice esempio di ciò è il doppio pendolo con azionamenti nelle articolazioni come mostrato di seguito: Caso d'uso 1 Caso d'uso 2 L'azionamento nel primo giunto compie una rotazione di 90°; il secondo giunto non dovrebbe muoversi (caso d'uso 1). Assumendo un secondo giunto passivo, è facile immaginare che il secondo lembo del doppio pendolo ruoterà verso sinistra a causa della sua inerzia. Per impedire questa rotazione, l'azionamento nel secondo giunto deve generare una coppia verso destra. Pertanto, il movimento della prima spinta richiede una reazione della seconda spinta. L'accoppiamento in direzione opposta esiste, ad esempio, nel caso in cui il primo azionamento si muova a velocità costante mentre il secondo azionamento ritrae il secondo lembo del doppio pendolo (caso d'uso 2). Questo riduce le matrici di inerzia del doppio pendolo rispetto al primo giunto. Per ottenere il momento angolare (il prodotto delle matrici di inerzia e della velocità angolare), occorre aumentare la velocità angolare del primo giunto. Per mantenere costante la velocità angolare, il momento angolare deve essere diminuito modificando la coppia del primo azionamento contro la sua direzione di rotazione. Pertanto, il movimento della seconda spinta richiede una reazione della prima spinta. Senza un modello dinamico, solo la posizione impostata, la velocità impostata e l'accelerazione impostata possono essere inviate all'azionamento. Nel primo caso, viene definita una posizione impostata costante per il secondo azionamento, indipendentemente dal fatto che il primo giunto sia in movimento o meno. L'unità di controllo nel secondo azionamento deve essere in grado di gestire il fatto che una coppia deve essere generata in un caso e non in un altro caso per gli stessi valori impostati. Il comportamento è simile nel secondo caso. Qui, la stessa velocità impostata costante viene specificata per il primo azionamento, indipendentemente dal fatto che il secondo giunto si muova o meno. Anche in questo caso, l'unità di controllo nell'azionamento deve fare i conti con il fatto che devono essere generate coppie diverse per gli stessi valori impostati. Con un modello dinamico, le coppie impostate possono essere calcolate e inviate agli azionamenti. Lì possono essere utilizzati come dimensione di feed forward per le unità di controllo. Di conseguenza, l'unità di controllo riceve informazioni aggiuntive che consentono un miglioramento della qualità del controllo. La limitazione della coppia consente un rispetto più preciso dei limiti dell'azionamento. In molti casi, non è decisiva la limitazione della velocità o dell'accelerazione dell'azionamento, ma la limitazione delle coppie. I vantaggi della limitazione di coppia risultano evidenti dall'esempio del doppio pendolo come sopra descritto quando si confrontano i seguenti movimenti: un movimento del primo motore con il secondo braccio retratto e un movimento del primo motore con il secondo braccio esteso. Nello stato retratto, le matrici di inerzia rispetto al primo giunto sono inferiori rispetto allo stato esteso. Per lo stesso movimento (le stesse curve di velocità e accelerazione dell'azionamento), è quindi necessaria una coppia maggiore nello stato esteso rispetto allo stato retratto. Senza un modello dinamico, i limiti di velocità e accelerazione devono essere impostati in modo che i limiti di coppia siano rispettati in entrambi gli stati. Ciò può far sì che il primo azionamento si muova a una velocità o accelerazione inferiore nello stato retratto rispetto a quanto sarebbe necessario per rispettare i limiti di coppia dell'azionamento. Con un modello dinamico, i limiti di coppia possono essere configurati, presi in considerazione durante la pianificazione del movimento e quindi pienamente utilizzati in entrambi gli stati. Un esempio leggermente più complesso è il primo caso descritto sopra, in cui il primo azionamento si sta muovendo e il secondo dovrebbe mantenere la sua posizione. La coppia richiesta nel secondo azionamento per mantenere la sua posizione dipende dal movimento del primo azionamento. Se il primo azionamento accelera troppo bruscamente, in linea di principio potrebbe essere violato il limite di coppia del secondo azionamento. Senza un modello dinamico, ciò può essere evitato solo configurando di conseguenza i limiti di accelerazione del primo azionamento. Con un modello dinamico, il limite di coppia configurato del secondo azionamento può essere preso in considerazione durante la pianificazione del movimento e l'accelerazione del primo azionamento può essere limitata. Nel caso di movimenti o cinematiche più complesse, gli effetti di accoppiamento qui descritti si uniscono ad effetti di accoppiamento ancora più numerosi. Un modello dinamico consente di tenere conto di questi accoppiamenti, con conseguente migliore specifica dei valori impostati e migliore aderenza ai limiti degli azionamenti. " }, 
{ "title" : "Configurazione del modello dinamico ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4510933957710433418427140333", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitazione della coppia e controllo dell'avanzamento della coppia \/ Configurazione del modello dinamico ", 
"snippet" : "Un modello dinamico esistente sotto forma di un blocco funzione che implementa il ISMDynamics interfaccia può essere assegnata a un gruppo di assi tramite il SMC_GroupSetDynamics blocco funzione. Oltre al modello dinamico, il blocco funzione deve essere utilizzato anche per configurare la direzione ...", 
"body" : "Un modello dinamico esistente sotto forma di un blocco funzione che implementa il ISMDynamics interfaccia può essere assegnata a un gruppo di assi tramite il SMC_GroupSetDynamics blocco funzione. Oltre al modello dinamico, il blocco funzione deve essere utilizzato anche per configurare la direzione e l'entità dell'accelerazione gravitazionale sotto forma di vettore nel sistema di coordinate della macchina. " }, 
{ "title" : "Considerazione dei carichi ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552490173838433418429772624", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitazione della coppia e controllo dell'avanzamento della coppia \/ Considerazione dei carichi ", 
"snippet" : "Carichi aggiuntivi (ad esempio, oggetti afferrati o strumenti attaccati) possono essere presi in considerazione mediante il SMC_GroupSetLoad blocco funzione e modificato in fase di esecuzione. Il ExecutionMode l'ingresso del blocco funzione può essere utilizzato per definire quando deve avere effett...", 
"body" : "Carichi aggiuntivi (ad esempio, oggetti afferrati o strumenti attaccati) possono essere presi in considerazione mediante il SMC_GroupSetLoad blocco funzione e modificato in fase di esecuzione. Il ExecutionMode l'ingresso del blocco funzione può essere utilizzato per definire quando deve avere effetto una modifica del carico (ad esempio, immediatamente o solo dopo che il movimento corrente è stato completato). Continuazione con MC_GroupContinue : In prosecuzione, ogni movimento memorizzato nei dati di prosecuzione mantiene il carico con cui era originariamente comandato. Qualsiasi movimento comandato dopo la continuazione utilizza l'ultimo carico impostato. " }, 
{ "title" : "Considerazione di un cambio ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552678559262433422353734728", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitazione della coppia e controllo dell'avanzamento della coppia \/ Considerazione di un cambio ", 
"snippet" : "Le coppie impostate vengono calcolate per la potenza del cambio e non vengono convertite automaticamente nell'azionamento. Il SMC_SetAdditionalConversionFactors blocco funzione può essere utilizzato per configurare un ulteriore fattore di conversione per la coppia per ciascun asse. Anche il cambio p...", 
"body" : "Le coppie impostate vengono calcolate per la potenza del cambio e non vengono convertite automaticamente nell'azionamento. Il SMC_SetAdditionalConversionFactors blocco funzione può essere utilizzato per configurare un ulteriore fattore di conversione per la coppia per ciascun asse. Anche il cambio può essere preso in considerazione in questo modo. " }, 
{ "title" : "Unità ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597662777713633422354433707", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitazione della coppia e controllo dell'avanzamento della coppia \/ Unità ", 
"snippet" : "Le forze e le coppie ei loro limiti sono sostanzialmente specificati nell'applicazione in newton (N) o newton metri (Nm). Prima che le forze impostate o le coppie impostate vengano inviate agli azionamenti, è possibile eseguire un ridimensionamento. Per questo lo standard CiA 402 richiede, ad esempi...", 
"body" : "Le forze e le coppie ei loro limiti sono sostanzialmente specificati nell'applicazione in newton (N) o newton metri (Nm). Prima che le forze impostate o le coppie impostate vengano inviate agli azionamenti, è possibile eseguire un ridimensionamento. Per questo lo standard CiA 402 richiede, ad esempio, che le coppie impostate vengano inviate al drive in millesimi della coppia nominale (in mNm). L'unità per le lunghezze è specifica dell'utente in SoftMotion. Poiché le forze e le coppie sono definite come un'unità fissa (N o Nm), è necessario configurare un fattore di conversione da un'unità di lunghezza specifica dell'utente in metri (a meno che i metri non vengano utilizzati come unità di lunghezza). Questo può essere fatto con il SMC_GroupSetUnits blocco funzione. " }, 
{ "title" : "Limitazione di coppia nei sistemi di coordinate in movimento ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552049322772833422354993274", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitazione della coppia e controllo dell'avanzamento della coppia \/ Limitazione di coppia nei sistemi di coordinate in movimento ", 
"snippet" : "Se il gruppo di assi si sposta in un sistema di coordinate mobile, allora i limiti di coppia possono essere rispettati solo quando il gruppo di assi può seguire esattamente il sistema di coordinate mobili. Se questo non è possibile e le tolleranze per la deviazione sono configurate mediante SMC_Grou...", 
"body" : "Se il gruppo di assi si sposta in un sistema di coordinate mobile, allora i limiti di coppia possono essere rispettati solo quando il gruppo di assi può seguire esattamente il sistema di coordinate mobili. Se questo non è possibile e le tolleranze per la deviazione sono configurate mediante SMC_GroupSetPathTolerance , allora i limiti di coppia possono essere superati quando si tenta di compensare la deviazione. Se si verifica un errore perché le deviazioni sono al di fuori delle tolleranze, il gruppo di assi si arresta. Durante questo arresto, i limiti di coppia possono anche essere superati. Le coppie impostate vengono calcolate di volta in volta e inviate agli azionamenti. " }, 
{ "title" : "Limitazione della coppia in caso di errore ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4612699285196833422355410226", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitazione della coppia e controllo dell'avanzamento della coppia \/ Limitazione della coppia in caso di errore ", 
"snippet" : "Se durante la pianificazione viene rilevato un errore (ad esempio, un movimento comandato viola l'area di lavoro), il gruppo di assi si ferma sul percorso comandato in precedenza. In tal modo vengono rispettati i limiti di coppia. Se non è possibile arrestarsi sulla traiettoria (ad es. perché un azi...", 
"body" : "Se durante la pianificazione viene rilevato un errore (ad esempio, un movimento comandato viola l'area di lavoro), il gruppo di assi si ferma sul percorso comandato in precedenza. In tal modo vengono rispettati i limiti di coppia. Se non è possibile arrestarsi sulla traiettoria (ad es. perché un azionamento segnala un errore), anche i limiti di coppia non possono essere rispettati. " }, 
{ "title" : "Differenze nell'utilizzo di movimenti ad asse singolo e movimenti coordinati ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4483062104566433422355806924", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitazione della coppia e controllo dell'avanzamento della coppia \/ Differenze nell'utilizzo di movimenti ad asse singolo e movimenti coordinati ", 
"snippet" : "Fondamentalmente, le coppie impostate vengono calcolate per tutti gli assi che fanno parte di un gruppo di assi con un modello dinamico. Ciò vale sia da fermo sia quando l'asse viene spostato mediante movimenti ad asse singolo (ad es. MC_MoveAbsolute ) oppure l'intero gruppo di assi viene spostato m...", 
"body" : "Fondamentalmente, le coppie impostate vengono calcolate per tutti gli assi che fanno parte di un gruppo di assi con un modello dinamico. Ciò vale sia da fermo sia quando l'asse viene spostato mediante movimenti ad asse singolo (ad es. MC_MoveAbsolute ) oppure l'intero gruppo di assi viene spostato mediante movimenti coordinati (ad es. MC_MoveDirectAbsolute ). La limitazione di coppia è attiva solo per i movimenti coordinati. La ragione di ciò è che le coppie necessarie di un asse, come descritto sopra, dipendono dalla posizione e dal movimento di alcuni o di tutti gli altri assi nel gruppo di assi. Pertanto, una limitazione della coppia è possibile solo quando tutti gli assi del gruppo di assi possono essere spostati come movimenti coordinati. Un'eccezione è il SMC_GroupJog blocco funzioni. Questo blocco funzione non supporta la limitazione di coppia. Si consiglia di utilizzare SMC_GroupJog2 invece. " }, 
{ "title" : "Diagnosi ", 
"url" : "_sm_robotics_diagnosis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Errori comuni ", 
"url" : "_sm_robotics_errors.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosi \/ Errori comuni ", 
"snippet" : "Questa pagina descrive gli errori comuni del gruppo di assi, le relative cause e le possibili azioni da intraprendere per correggere l'errore. Per un elenco di tutti i possibili errori con una breve descrizione, consultare la pagina della guida per SMC_ERRORE (ENUM) . Codice di errore Spiegazione e ...", 
"body" : "Questa pagina descrive gli errori comuni del gruppo di assi, le relative cause e le possibili azioni da intraprendere per correggere l'errore. Per un elenco di tutti i possibili errori con una breve descrizione, consultare la pagina della guida per SMC_ERRORE (ENUM) . Codice di errore Spiegazione e cause Azioni SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED Il gruppo di assi non può seguire il percorso comandato senza violare un limite dell'asse (velocità, accelerazione o strappo). Questo errore si verifica spesso durante tracciamento se il sistema di coordinate dinamiche si muove inaspettatamente. L'errore può verificarsi anche quando il percorso passa in prossimità di una singola posizione del robot. Posizioni singolari si verificano tra diversi configurazioni (ad esempio con il robot SCARA quando il braccio è completamente esteso). Vedere Evitare gli errori SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED o SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED.Se non viene utilizzato alcun sistema di coordinate dinamiche, assicurarsi che il percorso del robot non passi vicino a una posizione singolare. SMC_CP_QUEUE_UNDERRUN Non è stato possibile calcolare la traiettoria (profilo di velocità) del gruppo di assi abbastanza velocemente e di conseguenza il gruppo di assi deve interrompere il movimento. Cause possibili: Problemi di prestazioni. Il controller in uso non fornisce prestazioni sufficienti oppure ne vengono calcolate troppe in un'attività ad alta priorità. Impostazioni sfavorevoli delle attività: il calcolo della traiettoria viene spostato da altre attività. Comandi ad alta intensità di calcolo. Potrebbe ad esempio essere necessario più tempo di elaborazione se un movimento di fusione viene interrotto da un movimento interrotto e questo viene poi nuovamente interrotto da un movimento interrotto. Anche l'uso del tracking (sistemi di coordinate dinamiche) richiede più tempo di calcolo. L'esecuzione di SMC_GroupSaveContinueData durante un movimento e l'utilizzo di più trigger attivi contemporaneamente possono anche aumentare il tempo di calcolo richiesto. Verificare se le impostazioni dell'attività per l'attività di pianificazione del gruppo di assi sono state selezionate correttamente e, se possibile, trasferire questa attività su un core della CPU separato e dedicato. Per ulteriori informazioni, vedere: Configurazione dell'attività di pianificazioneSul Monitoraggio scheda della configurazione dell'attività 1 controlla se un'attività ad alta priorità richiede molto tempo di elaborazione e, se possibile, sposta i calcoli ad alta intensità di prestazioni in un'attività a bassa priorità. Utilizzo SMC_TuneCPKernel per aumentare l'intervallo di pianificazione. Per ulteriori informazioni, vedere: Diagnosi in caso di movimenti lenti o a scattiNota: è possibile utilizzare i contatori delle prestazioni di SMC_GroupReadPlanningStatistics per determinare l’effetto di queste azioni. Per ulteriori informazioni, vedere: Diagnosi in caso di movimenti lenti o a scattiSMC_TRAFO_INVALID_CONSTELLATION SMC_AXIS_POSITION_EXCEEDS_POSLIMITS SMC_AXIS_INVERSE_TRAFO_EXCEEDING_POSLIMITS Il percorso è completamente o parzialmente esterno all'area di lavoro del robot. Cause possibili: Il punto iniziale o finale di un movimento è esterno all'area di lavoro. A seconda del tipo di robot, parte del movimento di un movimento CP potrebbe svolgersi al di fuori dell'area di lavoro. Un segmento circolare con un raggio troppo grande può trovarsi all'inizio e alla fine dell'area di lavoro, mentre la parte centrale esce dall'area di lavoro. Quando si utilizza il tracking (sistemi di coordinate dinamiche), è possibile che una posizione precedentemente individuata all'interno dell'area di lavoro lasci l'area di lavoro nel tempo a causa del movimento del sistema di coordinate. Nota: quando viene segnalato l'errore, il gruppo di assi non è necessariamente vicino alla posizione problematica. È possibile che l'errore venga rilevato e segnalato durante il calcolo della traiettoria e riguardi un segmento di percorso ancora molto distante dalla posizione attuale. Controllare i movimenti comandati e assicurarsi che siano completamente all'interno dell'area di lavoro. Quando si utilizza il tracciamento: utilizzare limiti adeguati per assicurarsi che il gruppo di assi non si sposti fuori dall'area di lavoro nel tempo. Nel Pick&Place con nastri trasportatori, ad esempio, è prassi comune definire un'area sicura in cui i pezzi possono ancora essere prelevati dal nastro trasportatore. Dopo che una parte ha lasciato questa regione, il gruppo di assi non dovrebbe più spostarsi sulla parte. SMC_CP_CONFIGS_DIFFER SMC_CP_AXIS_ORIENTATION_IPO_CONFIG_DIFFERS Le posizioni iniziale e finale di un movimento CP si trovano in diverse configurazioni. La gestione delle configurazioni è spiegata nel file Configurazioni cinematiche capitolo. Quando si usa OrientationMode Axis , vedere il Interpolazione di orientamento per movimenti CP capitolo per i dettagli sulla configurazione della parte di orientamento del robot. Azioni possibili: Assicurarsi che le posizioni iniziale e finale dei movimenti del CP si trovino nella stessa configurazione. Se necessario, utilizzare il SMC_SetKinConfiguration blocco funzione per impostare la configurazione del robot all'inizio (dopo MC_GroupEnable ). Se lo desideri, utilizza i movimenti PTP per passare da una configurazione all'altra. " }, 
{ "title" : "Prestazione ", 
"url" : "_sm_robotics_performance.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosi \/ Prestazione ", 
"snippet" : "La pianificazione dei movimenti viene eseguita in un'attività separata poiché il calcolo richiede un utilizzo intensivo della CPU. Questa attività separata viene definita attività di pianificazione e viene eseguita parallelamente all'attività del bus. Se le prestazioni del PLC non sono sufficienti p...", 
"body" : "La pianificazione dei movimenti viene eseguita in un'attività separata poiché il calcolo richiede un utilizzo intensivo della CPU. Questa attività separata viene definita attività di pianificazione e viene eseguita parallelamente all'attività del bus. Se le prestazioni del PLC non sono sufficienti per pianificare in tempo il percorso nell'attività di pianificazione per l'attività del bus, si tratta di problemi di prestazioni. I problemi di prestazione nella pianificazione del movimento possono portare a SMC_CP_QUEUE_UNDERRUN errore, ma possono anche comportare un movimento a scatti o più lento del previsto. Per informazioni su SMC_CP_QUEUE_UNDERRUN errore, vedere il Errori comuni capitolo. La diagnosi dei problemi legati alle prestazioni con i movimenti è descritta di seguito. " }, 
{ "title" : "Diagnosi in caso di movimenti lenti o a scatti ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm4597696111868834242456592379", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosi \/ Prestazione \/ Diagnosi in caso di movimenti lenti o a scatti ", 
"snippet" : "Se non ci sono problemi di prestazione, allora ogni movimento è pianificato in modo tale che almeno uno dei limiti effettivi viene raggiunta durante tutto il movimento. Ad esempio, consideriamo un semplice portale bidimensionale con due assi X e Y e un movimento PTP dalla posizione (0,0) a (10,-10)....", 
"body" : "Se non ci sono problemi di prestazione, allora ogni movimento è pianificato in modo tale che almeno uno dei limiti effettivi viene raggiunta durante tutto il movimento. Ad esempio, consideriamo un semplice portale bidimensionale con due assi X e Y e un movimento PTP dalla posizione (0,0) a (10,-10). La velocità massima dell'asse è 20, l'accelerazione massima dell'asse è 100 e lo strappo massimo dell'asse è 1000. Il movimento previsto è simile al seguente: L'accelerazione viene inizialmente stabilita con uno strappo massimo fino al raggiungimento del valore limite di accelerazione di 100. Dopo una breve fase di accelerazione costante, l'accelerazione viene nuovamente ridotta con uno strappo massimo, in modo che con l'accelerazione 0 venga raggiunto il valore limite di velocità di 20. Dopo una fase di velocità costante avviene una decelerazione in modo che la posizione di destinazione venga raggiunta con velocità e accelerazione 0. Ci sono due possibili ragioni per cui il movimento reale si discosta da questa curva ideale: Il movimento pianificato non corrisponde alla curva ideale a causa di problemi di prestazione nell'attività di pianificazione. Il movimento pianificato corrisponde alla curva ideale, ma il robot non lo esegue come previsto. " }, 
{ "title" : "Caso 1: problemi di prestazione dell'attività di pianificazione ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433006527711", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosi \/ Prestazione \/ Diagnosi in caso di movimenti lenti o a scatti \/ Caso 1: problemi di prestazione dell'attività di pianificazione ", 
"snippet" : "Se si verificano problemi con le prestazioni durante la pianificazione, il movimento potrebbe invece assomigliare a questo: Questo perché il movimento viene pianificato nell'attività di pianificazione parallelamente all'esecuzione nell'attività bus. In media, l'attività di pianificazione deve fornir...", 
"body" : "Se si verificano problemi con le prestazioni durante la pianificazione, il movimento potrebbe invece assomigliare a questo: Questo perché il movimento viene pianificato nell'attività di pianificazione parallelamente all'esecuzione nell'attività bus. In media, l'attività di pianificazione deve fornire tutta la traiettoria richiesta dall'attività dell'autobus. Se le prestazioni non sono sufficienti, il movimento viene rallentato. Ciò porta alla curva di velocità ondulata. Il primo e più importante strumento per diagnosticare tali problemi è la traccia. In aggiunta a fSetPosition , fSetVelocity , E fSetAcceleration variabili per ciascun asse, il numTimeBudgetExceeded E numSlowDownLowIpoQueue uscite del SMC_GroupReadPlanningStatistics anche il blocco funzione dovrebbe essere registrato. Se questi contatori aumentano continuamente, si è verificato un problema di prestazioni. Allo stesso modo al fSetPosition , fSetVelocity , E fSetAcceleration variabili, c'è anche il fSetJerk variabile per lo scatto. Va notato che il jerk non è il jerk medio applicato durante il ciclo del task del bus (come spesso previsto), ma piuttosto il jerk istantaneo alla fine del ciclo. Perciò, FSetJerk ha solo un significato limitato per la diagnosi dei problemi di prestazioni. " }, 
{ "title" : "Modi per migliorare il movimento ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm43443300985204", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosi \/ Prestazione \/ Diagnosi in caso di movimenti lenti o a scatti \/ Caso 1: problemi di prestazione dell'attività di pianificazione \/ Modi per migliorare il movimento ", 
"snippet" : "L'elenco seguente contiene i passaggi per gestire i problemi di prestazioni: Adattamento dei valori limite per velocità, accelerazione e strappo: Quanto più tempo occorre per decelerare dalla velocità attuale fino all'arresto, tanto maggiore è la potenza di calcolo richiesta Un valore limite effetti...", 
"body" : "L'elenco seguente contiene i passaggi per gestire i problemi di prestazioni: Adattamento dei valori limite per velocità, accelerazione e strappo: Quanto più tempo occorre per decelerare dalla velocità attuale fino all'arresto, tanto maggiore è la potenza di calcolo richiesta Un valore limite effettivo elevato per la velocità e valori limite effettivi bassi per accelerazione e strappo hanno quindi maggiori probabilità di causare problemi di prestazione. In particolare i valori limite per l'accelerazione e lo strappo non dovrebbero quindi essere impostati inutilmente bassi Aumentare la priorità dell'attività di pianificazione o diminuire la priorità delle altre attività se bloccano l'attività di pianificazione. L'attività di pianificazione dovrebbe avere la seconda priorità più alta dopo l'attività del bus. Assegnare l'attività di pianificazione a un core dedicato se sono disponibili più core CPU (vedere Configurazione dell'attività di pianificazione). Utilizzo SMC_TuneCPKernel per aumentare il valore del fPlanningInterval e\/o fSyncBufferDuration parametri di pianificazione. IL fPlanningInterval Il parametro specifica l'incremento massimo di pianificazione (in secondi). Il tempo di ciclo dell'attività di pianificazione non deve superare in modo permanente questo valore. Un valore più elevato riduce la potenza di calcolo, ma può anche far sì che i valori limite impostati per velocità, accelerazione e strappo non vengano utilizzati completamente. Da un valore iniziale di 0,016 secondi (il valore predefinito da allora CODESYS SoftMotion versione 4.6.0.0), il valore dovrebbe essere gradualmente aumentato finché le prestazioni non saranno accettabili. IL fSyncBufferDuration Il parametro specifica la dimensione del buffer tra la pianificazione e l'attività del bus. I tempi di ciclo di punta dell'attività di pianificazione non devono superare questo valore. Un valore più elevato può compensare i picchi nel tempo di ciclo dell'attività di pianificazione. Allo stesso tempo, però, ciò aumenta anche la latenza per l'esecuzione di interruzioni e movimenti di interruzione. " }, 
{ "title" : "Caso 2: Il robot non segue il movimento pianificato come previsto ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433008452776", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosi \/ Prestazione \/ Diagnosi in caso di movimenti lenti o a scatti \/ Caso 2: Il robot non segue il movimento pianificato come previsto ", 
"snippet" : "Se il robot non segue il movimento pianificato come previsto, ciò potrebbe essere dovuto ai seguenti motivi: Capacità in tempo reale insufficiente del controller Problemi del loop di controllo degli azionamenti Su un controller non compatibile con il tempo reale come il CODESYS Control Win o un cont...", 
"body" : "Se il robot non segue il movimento pianificato come previsto, ciò potrebbe essere dovuto ai seguenti motivi: Capacità in tempo reale insufficiente del controller Problemi del loop di controllo degli azionamenti Su un controller non compatibile con il tempo reale come il CODESYS Control Win o un controller basato su Linux senza una patch in tempo reale del sistema Linux sottostante, possono verificarsi movimenti troppo lenti o a scatti anche con prestazioni sufficienti. Ciò accade se l'attività del bus non viene eseguita puntualmente nell'intervallo di tempo configurato. " }, 
{ "title" : "Modi per migliorare il movimento ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433012326085", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosi \/ Prestazione \/ Diagnosi in caso di movimenti lenti o a scatti \/ Caso 2: Il robot non segue il movimento pianificato come previsto \/ Modi per migliorare il movimento ", 
"snippet" : "Nella scheda \"Monitoraggio\" della configurazione dell'attività 1 , controlla se l'attività è jitter dell'attività del bus 2 è troppo alto. Ciò può verificarsi perché il task del bus viene sostituito da un task con priorità uguale o superiore oppure perché il controller non è sufficientemente in grad...", 
"body" : "Nella scheda \"Monitoraggio\" della configurazione dell'attività 1 , controlla se l'attività è jitter dell'attività del bus 2 è troppo alto. Ciò può verificarsi perché il task del bus viene sostituito da un task con priorità uguale o superiore oppure perché il controller non è sufficientemente in grado di gestire il tempo reale. Se il jitter è troppo elevato e ci si è già assicurati che il task del bus abbia la massima priorità, la capacità in tempo reale del controller non è sufficiente. In questo caso, utilizzare un controller con migliori proprietà in tempo reale. Se si verificano problemi nel circuito di controllo nel convertitore, è necessario regolare i parametri del circuito di controllo. Il controllo feed forward della coppia può anche migliorare le prestazioni del circuito di controllo. Per ulteriori informazioni, vedere: Limitazione della coppia e controllo dell'avanzamento della coppia1 : Si consiglia di reimpostare i valori misurati del monitoraggio dell'attività nel menu contestuale poiché il primo ciclo PLC dopo l'avvio dell'applicazione ha spesso una durata maggiore e un jitter maggiore. 2 : Valori di jitter fino a ca. 20 us sono molto buoni e valori fino a ca. 100 noi sono buoni. A seconda degli azionamenti utilizzati, può funzionare anche il funzionamento con valori di jitter più elevati. I valori di jitter che raggiungono l'ordine di grandezza dell'intervallo del task del bus possono provocare il modello di errore sopra descritto. " }, 
{ "title" : "Informazioni di registrazione ", 
"url" : "_sm_information_logging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosi \/ Informazioni di registrazione ", 
"snippet" : "Le Registrazione degli eventi SMC_GROUP blocco funzione è stato introdotto con la versione 4.18.0.0 di SoftMotion. Il blocco funzione può essere utilizzato per abilitare i messaggi di registro per un gruppo di assi. Non appena i messaggi di registro sono abilitati, il gruppo di assi scrive le azioni...", 
"body" : "Le Registrazione degli eventi SMC_GROUP blocco funzione è stato introdotto con la versione 4.18.0.0 di SoftMotion. Il blocco funzione può essere utilizzato per abilitare i messaggi di registro per un gruppo di assi. Non appena i messaggi di registro sono abilitati, il gruppo di assi scrive le azioni che esegue nel Registra del dispositivo. In questo modo, gli eventi del gruppo di assi possono essere tracciati cronologicamente. Ciò può essere utile quando si analizzano problemi e comportamenti imprevisti del gruppo di assi Assegna nomi ai tuoi movimenti, carichi, strumenti, ecc. per ottenere messaggi di registro informativi. In CODESYS SoftMotion versione 4.18.0.0 e successive, alcuni blocchi di funzioni di comando (come MC_MoveLinearAbsolute , SMC_GroupSetTool e MC_SetCoordinateTransform ) sono stati dotati di un nuovo Name input. La registrazione può avere un impatto negativo sulle prestazioni e deve quindi essere abilitata tramite SMC_GroupEventLogging blocco funzionale. Nel CODESYS SoftMotion nella versione 4.18.0.0, vengono registrati i messaggi relativi al percorso del gruppo di assi. Categoria Azione Descrizione Informazioni aggiuntive Movimento Inizia il movimento Il gruppo di assi ha avviato l'interpolazione di un movimento. PanoramicaIl movimento finisce Il gruppo di assi ha completato l'interpolazione di un movimento. Inizia la fusione Il gruppo di assi ha iniziato a passare dal movimento attivo al movimento successivo. La fusione termina Il gruppo di assi ha completato la fusione e continua l'interpolazione al movimento successivo. L'interruzione inizia Il gruppo di assi ha interrotto il movimento attuale e si sta fondendo con il movimento abortivo. L'interruzione termina Il gruppo di assi ha completato la fusione e continua l'interpolazione sul movimento interrotto. L'attesa inizia Il gruppo di assi attende nella posizione corrente. L'attesa finisce Il gruppo di assi ha terminato l'attesa. Avviamenti Halt\/Stop Il gruppo di assi ha iniziato a eseguire una fermata\/arresto sul percorso. Ferma\/stop termina Il gruppo di assi ha eseguito l'arresto\/arresto sul percorso. Utensile Attrezzo allegato Il gruppo di assi utilizza un nuovo strumento. Configurazione di un offset utensileCaricare Carico allegato Il gruppo di assi utilizza un nuovo carico. Limitazione della coppia e controllo dell'avanzamento della coppiaSostituisci Sostituzione dell'asse o del percorso modificata L'override dell'asse o del percorso è stato modificato ed è stato applicato dal gruppo di assi. mc_GroupsetOverride (FB) Precisione del percorso Sentiero partito Il gruppo di assi ha abbandonato il percorso comandato per evitare di violare i limiti degli assi. Il gruppo di assi tenta di raggiungere nuovamente il percorso comandato Tolleranze per la precisione del percorsoSentiero raggiunto nuovamente Il gruppo di assi ha raggiunto nuovamente il percorso comandato. Interrompi: continua L'interruzione inizia Il gruppo di assi ha iniziato a eseguire un'interruzione. Interruzione e continuazione dei movimentiL'interruzione termina Il gruppo di assi ha eseguito l'interrupt e salvato i dati Continue. Continua inizia Il gruppo di assi ha letto i dati Continue e inizia a continuare. " }, 
{ "title" : "Esempi ", 
"url" : "_sm_robotics_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Fare jogging con un robot ", 
"url" : "_sm_robotics_jogging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Fare jogging con un robot ", 
"snippet" : "Vedi il Robotics_Jogging.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come muovere un gruppo di assi in jog con il SMC_GroupJog2 POU. Si consiglia di installare il CODESYS Depictor per questo esempio (è sufficien...", 
"body" : "Vedi il Robotics_Jogging.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come muovere un gruppo di assi in jog con il SMC_GroupJog2 POU. Si consiglia di installare il CODESYS Depictor per questo esempio (è sufficiente la versione demo gratuita). In alternativa, puoi anche rimuovere le parti di codice corrispondenti dall'esempio per utilizzare l'esempio senza Depictor. " }, 
{ "title" : "Applicazione ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584875037158433080105006434", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Fare jogging con un robot \/ Applicazione ", 
"snippet" : "Per dimostrare il caso più generale possibile, l'esempio ha le seguenti funzioni: Utilizzo di un robot con singolarità (robot articolato a 6 assi). L'esempio mostra che è possibile spostare il robot attraverso le singolarità in ACS e quindi continuare a fare jogging in modo cartesiano in una configu...", 
"body" : "Per dimostrare il caso più generale possibile, l'esempio ha le seguenti funzioni: Utilizzo di un robot con singolarità (robot articolato a 6 assi). L'esempio mostra che è possibile spostare il robot attraverso le singolarità in ACS e quindi continuare a fare jogging in modo cartesiano in una configurazione diversa. Spostamento e rotazione del sistema di coordinate macchina (MCS) del robot rispetto al sistema di coordinate mondiali (WCS). In questo modo, puoi vedere come è diverso il jogging in MCS e WCS. Configurazione di un utensile spostato e ruotato rispetto alla flangia (F). Nella figura sottostante è possibile vedere l'utensile e lo spostamento e la rotazione del TCS rispetto alla flangia (F). Un asse aggiuntivo lineare Add0 e un asse rotativo aggiuntivo Add1 . " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4576391101379233081218831739", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Fare jogging con un robot \/ Struttura dell'applicazione ", 
"snippet" : "Programma principale Il programma principale PLC_PRG consiste in una macchina a stati, che Attiva il gruppo di assi (stato 0) Configura lo strumento (stato 5) Configura l'MCS (stato 6) Inizia il jogging (stato 10) Nello stato 20, vengono gestiti gli errori di jogging e vengono accettati i comandi di...", 
"body" : "Programma principale Il programma principale PLC_PRG consiste in una macchina a stati, che Attiva il gruppo di assi (stato 0) Configura lo strumento (stato 5) Configura l'MCS (stato 6) Inizia il jogging (stato 10) Nello stato 20, vengono gestiti gli errori di jogging e vengono accettati i comandi di movimento ( Sposta in posizione passare alla visualizzazione). Gli altri stati vengono utilizzati per eseguire il movimento (60, 70) e per gestire e riconoscere gli errori (900, 1000). Secondo la macchina statale, tutte le POU di robotica e GroupJog2 i programmi vengono chiamati ciclicamente e alcuni calcoli vengono eseguiti per la visualizzazione 3D in Depictor. Programma GroupJog2 Questo programma contiene una macchina a stati con i seguenti passaggi: Nello stato 10 vengono impostati gli ingressi di SMC_GroupJog2 e viene letta la configurazione degli assi del robot (SMC_GroupReadActualPosition). Questa configurazione viene eseguita nello stato 20 nel gruppo di assi (SMC_SetKinConfiguration). Nello stato 30, il sistema reagisce agli errori durante il jogging, nonché alle modifiche alle impostazioni del jogging (ad esempio, a un sistema di coordinate modificato). In caso di modifica, il sistema torna allo stato 10. Lo stato 50 viene inserito su un fronte di discesa dell'ingresso di abilitazione. Il jogging viene interrotto da MC_GroupHalt. " }, 
{ "title" : "La messa in produzione ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584880854092833081221538291", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Fare jogging con un robot \/ La messa in produzione ", 
"snippet" : "Compila e avvia il programma creato. È possibile utilizzare la visualizzazione per eseguire il robot. È possibile definire tutte le impostazioni rilevanti per il jogging (ad esempio, in quale sistema di coordinate viene eseguito il jogging ea quale velocità). Se hai installato il CODESYS Depictor , ...", 
"body" : "Compila e avvia il programma creato. È possibile utilizzare la visualizzazione per eseguire il robot. È possibile definire tutte le impostazioni rilevanti per il jogging (ad esempio, in quale sistema di coordinate viene eseguito il jogging ea quale velocità). Se hai installato il CODESYS Depictor , quindi si consiglia di posizionare la finestra con il Depictor ( Scene POU) accanto alla finestra di visualizzazione. Il Depictor rappresenta il TCS (Tool Coordinate System) nella parte anteriore del robot. Inoltre, l'asse di rotazione corrente del TCS viene visualizzato in viola. Questo è utile per verificare i diversi tipi di cambio di orientamento (ad esempio, testare il ABC_come_ACS opzione e il TCS sistema di coordinate). " }, 
{ "title" : "Interruzione e continuazione dei movimenti ", 
"url" : "_sm_robotics_example_stop_continue.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Interruzione e continuazione dei movimenti ", 
"snippet" : "IL Robotics_Interrupt_Continue.project progetto di esempio qui descritto si trova nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come i movimenti comandati possono essere interrotti con SMC_GroupInterrupt blocco funzione e ripreso in un secon...", 
"body" : "IL Robotics_Interrupt_Continue.project progetto di esempio qui descritto si trova nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . Questo esempio mostra come i movimenti comandati possono essere interrotti con SMC_GroupInterrupt blocco funzione e ripreso in un secondo momento con il SMC_GroupContinue blocco funzione. Il gruppo di assi può eseguire qualsiasi movimento tra l'interruzione e la continuazione. " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4519127872464034232302809299", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Interruzione e continuazione dei movimenti \/ Struttura dell'applicazione ", 
"snippet" : "L'applicazione consiste in una semplice macchina a stati nel formato PLC_PRG programma e una traccia per tracciare facilmente le transizioni di stato. Innanzitutto vengono abilitati gli assi e il gruppo di assi. ( STATE_POWER_ON ) Poi, due movimenti, moveLinearA E moveLinearB , vengono comandati con...", 
"body" : "L'applicazione consiste in una semplice macchina a stati nel formato PLC_PRG programma e una traccia per tracciare facilmente le transizioni di stato. Innanzitutto vengono abilitati gli assi e il gruppo di assi. ( STATE_POWER_ON ) Poi, due movimenti, moveLinearA E moveLinearB , vengono comandati con la fusione. ( STATE_START_MOVING ) Non appena è attivo il secondo movimento (quando inizia la miscelazione), il movimento viene interrotto. La causa potrebbe essere ad esempio il rilevamento di un difetto dell'utensile. (STATE_INTERRUPT ) Un movimento PTP relativo viene eseguito nella direzione Z positiva, ad esempio, per sostituire l'utensile dopo il difetto. (STATE_INTERMEDIATE_MOVEMENT ) Prima di riprendere il sistema ritorna nella posizione in cui il movimento originario era stato interrotto. ( STATE_GET_CONTINUE_POS \/ STATE_MOVE_TO_CONTINUE_POS ) Viene ripreso il movimento originale. (STATE_CONTINUE) " }, 
{ "title" : "Utilizzo ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4586020725065634232302901331", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Interruzione e continuazione dei movimenti \/ Utilizzo ", 
"snippet" : "Compilare il programma creato ed effettuare il login. Per tracciare i diversi stati è possibile scaricare la traccia nel controller. Avviare l'applicazione....", 
"body" : "Compilare il programma creato ed effettuare il login. Per tracciare i diversi stati è possibile scaricare la traccia nel controller. Avviare l'applicazione. " }, 
{ "title" : "Programmare un Robot con Pick&Place ", 
"url" : "_sm_example_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Programmare un Robot con Pick&Place ", 
"snippet" : "Vedi il Robotics_PickAndPlace.project e Robotics_PickAndPlace_without_Depictor.project progetti di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Il Robotics_PickAndPlace.project progetto richiede il CODESYS Depictor Pacchetto Depictor da installare. Quest...", 
"body" : "Vedi il Robotics_PickAndPlace.project e Robotics_PickAndPlace_without_Depictor.project progetti di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Il Robotics_PickAndPlace.project progetto richiede il CODESYS Depictor Pacchetto Depictor da installare. Questo progetto mostra la cinematica in un'animazione 3D. Il progetto Robotics_PickAndPlace_without_Depictor.project mostra una forma semplificata della sequenza in una schermata di visualizzazione. Questo capitolo tratta solo gli oggetti che sono rilevanti per SoftMotion . L'esempio è costituito da un treppiede, una tavola rotante e un trasportatore. La cinematica preleva un anello che si trova sulla tavola rotante. Durante il prelievo, la piastra portautensili della cinematica si muove in sincronia con la tavola rotante. Quindi l'anello viene posizionato su un cono che si trova su un nastro trasportatore. Durante il posizionamento, la cinematica si muove in sincronia con il nastro trasportatore. Sulla schermata di visualizzazione sono presenti due pulsanti per il controllo della sequenza. Quando premi il Auto pulsante, gli squilli vengono impostati automaticamente. In caso contrario, il Giocare a viene visualizzato il pulsante per posizionare l'anello. Blocchi funzione MC_TrackConveyorBelt e MC_TrackRotaryTable Il blocco funzione MC_TrackRotaryTable , che si trova nel modulo funzione Ring viene chiamato, viene utilizzato per determinare il sistema di coordinate della parte PCS_1 . Questo sistema di coordinate viene impostato non appena un anello viene posizionato sulla tavola rotante. L'origine del sistema di coordinate della tavola rotante RotaryTableOrigin è il punto medio della tavola rotante. L'asse Z è l'asse rotante della tavola rotante. Il PCS_1 viene ruotato attorno all'asse Z del sistema di coordinate della tavola rotante in funzione della variabile di ingresso RotaryTable . Poiché il gruppo di assi si sposta in PCS_1, segue la rotazione della tabella. Con il blocco funzione MC_TrackConveyorBelt , che si trova nel modulo funzione Cone si chiama, il comportamento è analogo. Il PC ( PCS_2 ) segue l'asse X del sistema di coordinate ConveyorBeltOrigin . " }, 
{ "title" : "Struttura del progetto ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_9645ebb75a1273b0c0a8640e01c9af58", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Programmare un Robot con Pick&Place \/ Struttura del progetto ", 
"snippet" : "CODESYS SoftMotion Controllore Gruppo di assi Treppiedi : Il gruppo assi definisce la cinematica e la mappatura sui singoli assi Treppiede1 , Treppiede2 , e Treppiede3 . DepictorCalcoli (PRG) , Ambiente (PRG) , Anello (FB) : Programmi per il controllo dell'intera sequenza e visualizzazione. Queste P...", 
"body" : "CODESYS SoftMotion Controllore Gruppo di assi Treppiedi : Il gruppo assi definisce la cinematica e la mappatura sui singoli assi Treppiede1 , Treppiede2 , e Treppiede3 . DepictorCalcoli (PRG) , Ambiente (PRG) , Anello (FB) : Programmi per il controllo dell'intera sequenza e visualizzazione. Queste POU non sono rilevanti per la comprensione dei blocchi PLCopen, ad eccezione della definizione del sistema di coordinate del prodotto (PCS_1 e PCS_2). Robot (PRG) : Programma per il controllo delle sequenze di movimento. Una descrizione dettagliata si trova nel paragrafo successivo. Visualizzazione : Visualizzazione animata per chiarire la sequenza. Treppiede1 , Treppiede2 , Tripode3 : assi lineari del treppiede. DriveRotaryTable : Asse per la tavola rotante. DriveNastro trasportatore : Asse per il nastro trasportatore. " }, 
{ "title" : "Struttura del programma di sequenza Robot (PRG) ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_d2b72ec95a1273b5c0a8640e012cc527", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Programmare un Robot con Pick&Place \/ Struttura del programma di sequenza Robot (PRG) ", 
"snippet" : "Il Robot (PRG) il programma viene eseguito in cicli. A questo punto, i singoli passaggi vengono eseguiti a seconda del state . Alla fine di un programma, i richiami di tutti i blocchi funzione utilizzati sono pronti per il comando di movimento. Vengono attivati i singoli assi del treppiede (blocchi ...", 
"body" : "Il Robot (PRG) il programma viene eseguito in cicli. A questo punto, i singoli passaggi vengono eseguiti a seconda del state . Alla fine di un programma, i richiami di tutti i blocchi funzione utilizzati sono pronti per il comando di movimento. Vengono attivati i singoli assi del treppiede (blocchi funzione pwA1 , pwA2 , e pwA3 di tipo MC_Power ). CASE 0 : Attendere che gli assi partecipanti siano operativi. CASE 10 : Imposta le posizioni di riferimento; nelle applicazioni fisiche, l'homing viene eseguito in questa posizione (blocchi funzione spA1 , spA2 , e spA3 di tipo MC_SetPosition ). CASE 20 : Posizionamento del sistema di coordinate macchina nel sistema di coordinate globali (blocco funzione setCoord di tipo MC_SetCoordinateTransform ). CASE 30 : Rilascio del gruppo di assi (blocco funzione enable di tipo MC_GroupEnable . Attendi una risposta che il gruppo di assi abbia applicato tutti i valori. CASE 40 a CASE 130 : Applicazione Pick&Place: Tutti i movimenti sono comandati possibilmente con più istanze MC_MoveDirectAbsolute , MC_MoveDirectRelative , e MC_MoveLinear che sono chiamati in cicli. Un fronte in salita al Execute l'ingresso di queste POU in ogni stato porta all'emissione di un nuovo comando di movimento in cui l'uscita bCommandAccepted indica il successo del processo. Una tipica catena di comandi risulta dall'interrogazione di questa uscita prima del successivo comando di movimento. " }, 
{ "title" : "Modello di robot dinamico ", 
"url" : "_sm_dynamic_robot_model.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Modello di robot dinamico ", 
"snippet" : "Vedi il Robotics_DynamicModel.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Per limitare le coppie\/forze dell'asse durante un movimento, è necessario un modello dinamico che calcoli questi valori dallo stato attuale dell'asse (posizion...", 
"body" : "Vedi il Robotics_DynamicModel.project progetto di esempio nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . Per limitare le coppie\/forze dell'asse durante un movimento, è necessario un modello dinamico che calcoli questi valori dallo stato attuale dell'asse (posizione, velocità e accelerazione). Questo esempio include le seguenti parti: La parte 1 mostra come utilizzare un modello dinamico esistente in un'applicazione e i risultati di alcuni movimenti di esempio. La parte 2 mostra come creare un modello dinamico per un robot SCARA basato su un algoritmo presentato nel libro \"Modern Robotics\" di KM Lynch e FC Park. " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4640407923376033369958289569", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Modello di robot dinamico \/ Struttura dell'applicazione ", 
"snippet" : "Parte 1: utilizzo di un modello dinamico in un'applicazione Il codice per questa parte si trova nel file TorqueLimitationDemo cartella. PLC_PRG è il programma principale, che include una macchina a stati che attiva i movimenti di prova. I movimenti possono essere monitorati utilizzando il Trace . Pa...", 
"body" : "Parte 1: utilizzo di un modello dinamico in un'applicazione Il codice per questa parte si trova nel file TorqueLimitationDemo cartella. PLC_PRG è il programma principale, che include una macchina a stati che attiva i movimenti di prova. I movimenti possono essere monitorati utilizzando il Trace . Parte 2: creazione di un modello di robot dinamico Il codice per il modello dinamico si trova nel file DynModel cartella. DynModel_Scara2_Z è il modello dinamico del robot SCARA. DynModel_Tests esegue tutti i test di Test_DynModel_Scara2_Z per verificare gli errori comuni. Il modello dinamico si basa su un robot SCARA con due giunti rotanti e un asse Z prismatico. Di seguito è mostrata una figura del robot con le dimensioni e i sistemi di coordinate richiesti per il modello dinamico: Dimensione in figura Nome variabile corrispondente nel progetto di esempio nel blocco funzione DynModel_Scara2_Z h0 baseHeight h1 armOneHeight h2 armTwoHeight h3 zAxisLength h4 zAxisOffset l1 armOneLength l1 armTwoLength " }, 
{ "title" : "Parte 1: utilizzo di un modello dinamico in un'applicazione ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4592064830952033369979173999", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Modello di robot dinamico \/ Parte 1: utilizzo di un modello dinamico in un'applicazione ", 
"snippet" : "L'utilizzo di un modello dinamico in un'applicazione richiede un modello che implementi il ISMDynamics interfaccia del SM3_Dynamics biblioteca. Il modello dinamico da Parte 2: creazione di un modello di robot dinamico viene utilizzato per questa dimostrazione. Il modello può essere assegnato a un gr...", 
"body" : "L'utilizzo di un modello dinamico in un'applicazione richiede un modello che implementi il ISMDynamics interfaccia del SM3_Dynamics biblioteca. Il modello dinamico da Parte 2: creazione di un modello di robot dinamico viene utilizzato per questa dimostrazione. Il modello può essere assegnato a un gruppo di assi utilizzando SMC_GroupSetDynamics . Questo passaggio richiede l'impostazione dell'accelerazione gravitazionale rispetto al MCS. Poiché lo SCARA in questo esempio è montato sul pavimento, l'accelerazione gravitazionale punta nella direzione positiva z0. L'accelerazione gravitazionale deve essere specificata in unità utente u\/s². Poiché tutte le lunghezze in questo esempio sono state definite nell'unità utente m, anche l'accelerazione gravitazionale deve essere specificata in m\/s². SMC_ChangeDynamicLimits può essere utilizzato per regolare i limiti di ciascun asse. Si noti che il gruppo di assi deve essere nuovamente abilitato utilizzando MC_GroupEnable per attivare i nuovi limiti dinamici. Se vengono aggiunte ulteriori masse al TCP (ad esempio, uno strumento o un oggetto che viene raccolto dal robot), allora SMC_GroupSetLoad può essere utilizzato per definire il carico. Il PLC_PRG programma contiene tutti i componenti di cui sopra ed esegue due movimenti di prova: Movimento 1 Movimento 2 Movimento del braccio rettilineo da (a0=0°, a1=0°, a2=0 m) a (a0=90°, a1=0°, a2=0,02 m): Movimento del braccio inclinato da (a0=0°, a1=-120°, a2=0 m) a (a0=90°, a1=-120°, a2=0,02 m): Ogni movimento viene eseguito tre volte consecutive con le seguenti condizioni al contorno: Il limite di coppia di tutti gli assi è infinito (illimitato). Il limite di coppia del braccio 2 è impostato su un valore inferiore alla coppia massima raggiunta durante il movimento illimitato. Il valore è stato arbitrariamente impostato su 2 Nm . Il limite di coppia del braccio 2 è fermo 2 Nm , e inoltre è stato applicato un carico al TCP ( mLoad=3 kg , lLoad=0.2 m ): Il calcolo dell'inerzia per il carico è stato semplificato utilizzando barre sottili: I movimenti possono essere monitorati nella traccia. Il movimento 1 ha i seguenti risultati: Anche se il braccio 2 non si muove durante il movimento 1, il movimento del braccio 1 provoca una coppia per il braccio 2 durante l'accelerazione\/decelerazione. La coppia calcolata viene inviata all'azionamento e può potenzialmente migliorare il loop del controller in modalità controller SMC_velocity o SMC_position . Questo è anche chiamato controllo feed forward della coppia. La seconda corsa con coppia limitata mostra che anche se il braccio 2 non si muove, un limite di coppia per il braccio 2 rallenta il movimento del braccio 1. Senza il modello dinamico, l'accelerazione e la decelerazione del braccio 1 dovrebbero essere ridotte manualmente per questo movimento per evitare eccessive sollecitazioni meccaniche sul braccio 2. La terza corsa con un carico rallenta ancora di più il movimento del braccio 1 per non violare il limite di coppia del braccio 2. I vantaggi dell'utilizzo di un modello dinamico sono evidenti. Per evitare sollecitazioni meccaniche eccessive senza modello dinamico: O i limiti dinamici per ogni movimento dovrebbero essere impostati a seconda dello stato attuale del robot. Oppure i limiti dinamici di tutti gli assi dovrebbero essere ridotti in modo tale che tutti i potenziali movimenti non portino a sollecitazioni meccaniche eccessive su alcun asse. Il primo metodo è un compito complesso e può essere difficile calcolare limiti ragionevoli, mentre il secondo metodo si traduce in movimenti che non sono il più veloci possibile per la maggior parte del tempo. Questi inconvenienti non esistono più con un modello dinamico perché il robot si muove sempre il più velocemente possibile pur rispettando i limiti meccanici di ciascun asse. Questi vantaggi sono illustrati dai risultati del Movimento 2: A causa del Braccio 2 angolato, la coppia risultante del Braccio 2 è notevolmente inferiore a quella del Movimento 1. Pertanto, tutte e tre le corse non sono mai limitate dalla coppia dell'asse. Se si fossero utilizzati limiti dinamici adattati basati sul Movimento 1 (accelerazione e decelerazione ridotte per non violare il limite di coppia del Braccio 2), allora questo movimento sarebbe stato più lento del necessario. " }, 
{ "title" : "Parte 2: creazione di un modello di robot dinamico ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4583105024958433369980945572", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Modello di robot dinamico \/ Parte 2: creazione di un modello di robot dinamico ", 
"snippet" : "Il modello creato in questo esempio si basa su un algoritmo per robot a catena aperta presentato nel libro \"Modern Robotics\" di KM Lynch e FC Park (vedere il capitolo 8 \"Dynamics of Open Chains\"). La spiegazione di questo algoritmo va oltre lo scopo di questo esempio. Invece, l'esempio si concentra ...", 
"body" : "Il modello creato in questo esempio si basa su un algoritmo per robot a catena aperta presentato nel libro \"Modern Robotics\" di KM Lynch e FC Park (vedere il capitolo 8 \"Dynamics of Open Chains\"). La spiegazione di questo algoritmo va oltre lo scopo di questo esempio. Invece, l'esempio si concentra su come definire i valori di input dell'algoritmo. Semplificazioni Per rendere più comprensibile questo esempio, sono state apportate alcune semplificazioni: Le lunghezze delle braccia l1 e l2 (distanza tra gli assi di rotazione) vengono utilizzati come rispettiva lunghezza totale del braccio. Il centro di massa si trova sempre nel centro geometrico di ciascun collegamento. Le matrici di inerzia spaziale dei bracci e dell'asse Z sono calcolate per aste sottili. Requisiti del modello dinamico Per utilizzare il modello dinamico in un'applicazione SoftMotion, questo modello deve implementare il file ISMDynamics interfaccia del SM3_Dynamics biblioteca. La posizione zero, i sistemi di coordinate e il senso di rotazione positivo del modello dinamico possono discostarsi teoricamente dal modello cinematico. Tuttavia, queste differenze devono essere prese in considerazione e, per semplificare il modello dinamico, si raccomanda quindi di utilizzare le definizioni del modello cinematico. Poiché il modello dinamico deve calcolare i valori della coppia in Nm e le forze in N, deve convertire l'unità utente u per le lunghezze in unità SI m. Il fattore di conversione può essere impostato da SMC_GroupSetUnits ed è incluso nel addParams ingresso di ISMDynamics.AxesStateToTorque . Questo esempio usa solo m per le lunghezze e può quindi ignorare il fattore di conversione. Specifica dei dati geometrici e dinamici del modello L'implementazione IEC dell'algoritmo presentato nel libro \"Modern Robotics\" di KM Lynch e FC Park (vedi capitolo 8 \"Dynamics of Open Chains\") richiede i seguenti valori di input: La posizione del centro di massa di ciascun collegamento quando il robot è nella posizione iniziale. La posizione è specificata nel sistema di coordinate del collegamento precedente (il primo collegamento è specificato rispetto al sistema di coordinate di base). La matrice di inerzia spaziale e la massa di ciascun collegamento, espresse nel rispettivo frame di collegamento. L'asse della vite di ciascun giunto, espresso nel telaio di base. Posizioni del centro di massa I fotogrammi con la posizione del baricentro di ciascun collegamento sono i seguenti: Collegamento Telaio Braccio 1 Il centro di massa del braccio 1, espresso nel sistema di coordinate di base x 0 , e 0 , z 0 : Si noti che c'è una rotazione di 180° attorno all'asse x0. Braccio 2 Il centro di massa del braccio 2, espresso nel sistema di coordinate del braccio 1: Asse Z Il centro di massa dell'asse Z espresso nel sistema di coordinate del braccio 2: Punto centrale dell'utensile (TCP) Un frame aggiuntivo per gestire un carico arbitrario sul TCP (ad esempio, da uno strumento, un prodotto o una combinazione di entrambi), espresso nel sistema di coordinate dell'asse Z: Matrici di inerzia spaziale I valori di inerzia spaziale devono essere espressi nel rispettivo frame di collegamento. Poiché i telai sono definiti al centro di massa, l'inerzia spaziale può essere rappresentata da una matrice di inerzia rotazionale 3x3 e dalla massa del corpo. Con la semplificazione dell'utilizzo di aste sottili per i giunti, i componenti della matrice di inerzia rotazionale sono i seguenti: Collegamento Matrice di inerzia spaziale Braccio 1, Braccio 2 Braccio 1 e Braccio 2 con la massa corrispondente m1 e m2 , e lunghezza l1 e l2 : Asse Z Assi a vite Gli assi delle viti di tutti i giunti devono essere espressi rispetto al sistema di coordinate di base x 0 , e 0 , z 0 . Collegamento Asse della vite Braccio 1 Immagina una piattaforma girevole che ruota attorno al giunto 1 in direzione positiva con una velocità angolare di 1 rad\/s. Espressa nel sistema di coordinate di base, questa è una rotazione positiva attorno alla z 0 -asse secondo la regola della mano destra: Poiché l'asse di rotazione del braccio 1 è uguale al centro del sistema di coordinate di base, la velocità lineare è zero: Braccio 2 Ancora una volta, immagina una piattaforma girevole che ruota attorno al giunto 2 in direzione positiva con una velocità angolare di 1 rad\/s, che viene visualizzata nella vista dall'alto del braccio 1 nella figura seguente: Per quanto riguarda il braccio 1, la velocità angolare è: La figura mostra la velocità lineare risultante v 2,a , che indica y negativo 0 direzione ed è uguale a v 2,a =-ω 2,z *l 1 . Asse Z L'asse Z è un asse prismatico per il quale si applicano le seguenti regole: Il vettore velocità angolare ω è zero. Il vettore velocità lineare è un vettore unitario nella direzione della traslazione positiva. Questo porta ai seguenti vettori, espressi nel sistema di coordinate di base x 0 , e 0 , z 0 : Test Il modello dinamico può ora essere testato perché tutti i parametri del modello sono definiti. Questa sezione include alcuni test di base del modello. Controllo degli assi della vite Un asse a vite S con velocità angolare ω e velocità lineare v può essere espresso come un elemento di se(3) : Una trasformazione in avanti T può essere eseguito con gli assi a vite S , un frame dell'effettore finale M per la posizione zero del robot e l'angolo del giunto θ di ogni giunto: Il progetto di esempio include già una funzione che risolve questa equazione (vedi SMC_OpenChainKinematics_SolveForward ). Per maggiori dettagli, vedere il libro \"Modern Robotics\" di KM Lynch e FC Park. Utilizzando l'equazione di trasformazione in avanti, è ora possibile eseguire un test con posizioni degli assi note e verificare se la trasformazione porta al risultato atteso. Controllo del calcolo della coppia da fermo Per controllare il centro dei frame di posizione della massa, è possibile calcolare manualmente la coppia risultante dell'asse in stato di fermo per determinate posizioni dell'asse e confrontarle con i valori calcolati dal modello. Poiché questo esempio si basa su un robot SCARA montato a pavimento, tutte le posizioni degli assi in stato di fermo porteranno alle stesse coppie o forze degli azionamenti: Giunto Coppia\/Forza risultante Braccio 1 Poiché il braccio 1 è un asse di rivoluzione, il risultato è una coppia: M1=0 Nm . Braccio 2 Poiché il braccio 2 è un asse di rivoluzione, il risultato è una coppia: M2=0 Nm . Asse Z Poiché l'asse Z è un asse prismatico, il risultato è una forza: F3=m3*g N con accelerazione gravitazionale g . " }, 
{ "title" : "Cinematica personalizzata ", 
"url" : "_sm_example_custom_robotics_kinematic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Cinematica personalizzata ", 
"snippet" : "Vedi il PLCopenSingle2.project progetto di esempio e il CustomKinematics.library libreria nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples. Questo esempio descrive come creare una libreria con una trasformazione cinematica personalizzata ( Gantry3C ) e come usare ques...", 
"body" : "Vedi il PLCopenSingle2.project progetto di esempio e il CustomKinematics.library libreria nella directory di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples. Questo esempio descrive come creare una libreria con una trasformazione cinematica personalizzata ( Gantry3C ) e come usare questa libreria in un progetto per controllare il robot. Le Gantry3C la trasformazione cinematica è costituita da 3 assi lineari (X, Y e Z) che portano una testa utensile. La testa dell'utensile è costituita da un asse aggiuntivo che trasporta un utensile montato. La testa dell'utensile può essere ruotata attorno all'asse Z. " }, 
{ "title" : "1. Crea un nuovo progetto di libreria ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3b0657d06b6990f1c0a8646379b25f1e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Cinematica personalizzata \/ 1. Crea un nuovo progetto di libreria ", 
"snippet" : "Crea un nuovo progetto con il Libreria vuota modello....", 
"body" : "Crea un nuovo progetto con il Libreria vuota modello. " }, 
{ "title" : "2. Aggiungi un gestore di libreria. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_0125d98b6b6990f1c0a8646339c29917", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Cinematica personalizzata \/ 2. Aggiungi un gestore di libreria. ", 
"snippet" : "Aggiungi un Gestore della Libreria al file POU visualizzazione. Aggiungi il SM3_Transformation , SM3_Math , E SM3_Error biblioteche al Gestore della Biblioteca....", 
"body" : "Aggiungi un Gestore della Libreria al file POU visualizzazione. Aggiungi il SM3_Transformation , SM3_Math , E SM3_Error biblioteche al Gestore della Biblioteca. " }, 
{ "title" : "3. Creazione del blocco funzione Gantry3C ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_b156dbec6b6990f1c0a86463322b661a", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Cinematica personalizzata \/ 3. Creazione del blocco funzione Gantry3C ", 
"snippet" : "Questo blocco funzione implementa le interfacce MC_KIN_REF_SM3 e ISMKinematicsWithInfo2 dalla biblioteca SM3_Transformation . È possibile definire un offset come input per ciascun asse. Questo offset viene sottratto prima della trasformazione diretta e aggiunto dopo la trasformazione inversa. Esempi...", 
"body" : "Questo blocco funzione implementa le interfacce MC_KIN_REF_SM3 e ISMKinematicsWithInfo2 dalla biblioteca SM3_Transformation . È possibile definire un offset come input per ciascun asse. Questo offset viene sottratto prima della trasformazione diretta e aggiunto dopo la trasformazione inversa. Esempio di Gantry3C con due cinematiche disaccoppiate e KinCoupled : FUNCTION_BLOCK Custom_Kin_Gantry3 IMPLEMENTS ISMPositionKinematics\nFUNCTION_BLOCK Custom_Kin_CAxis IMPLEMENTS ISMOrientationKinematics\n\nFUNCTION_BLOCK Custom_Kin_Gantry3C EXTENDS Kin_Coupled Fornire i blocchi funzione Custom_Kin_Gantry3 e Custom_Kin_CAxis come ingressi per il blocco funzione Kin_Coupled durante l'inizializzazione. Ora Custom_Kin_Gantry3C diventa una cinematica accoppiata che combina la cinematica di posizione e di orientamento. " }, 
{ "title" : "4. Implementazione dei metodi dell'interfaccia MC_KIN_REF_SM3 e della proprietà NumAxes4 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_f0953a666b6990f1c0a864632a54ddd5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Cinematica personalizzata \/ 4. Implementazione dei metodi dell'interfaccia MC_KIN_REF_SM3 e della proprietà NumAxes4 ", 
"snippet" : "AxesToCartesian : Cinematica in avanti: Calcolo della posizione e dell'orientamento dai valori degli assi. CartesianToAxes : Cinematica inversa: Calcolo dei valori degli assi dalla posizione e dall'orientamento. NumAxes : Numero di assi della cinematica...", 
"body" : "AxesToCartesian : Cinematica in avanti: Calcolo della posizione e dell'orientamento dai valori degli assi. CartesianToAxes : Cinematica inversa: Calcolo dei valori degli assi dalla posizione e dall'orientamento. NumAxes : Numero di assi della cinematica " }, 
{ "title" : "5. Implementazione dei metodi delle interfacce ISMKinematicsWithInfo2 e ISMKinematicsWithInfo ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_cd5f17f76b6990f1c0a86463705dcfa1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Cinematica personalizzata \/ 5. Implementazione dei metodi delle interfacce ISMKinematicsWithInfo2 e ISMKinematicsWithInfo ", 
"snippet" : "GetAxisProperties : Proprietà, come il tipo di asse. I limiti per ogni asse possono essere definiti. GetKinematicsName : Nome della cinematica IsSingularity : Può essere ignorato per questa cinematica...", 
"body" : "GetAxisProperties : Proprietà, come il tipo di asse. I limiti per ogni asse possono essere definiti. GetKinematicsName : Nome della cinematica IsSingularity : Può essere ignorato per questa cinematica " }, 
{ "title" : "6. Specificare le informazioni sul progetto. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_2f5ca72b6b6990f1c0a864634f9c8dd7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Cinematica personalizzata \/ 6. Specificare le informazioni sul progetto. ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "7. Controllare la libreria per errori del compilatore. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_24eaad936b6990f1c0a864633896924b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Cinematica personalizzata \/ 7. Controllare la libreria per errori del compilatore. ", 
"snippet" : "Per controllare la libreria, fare clic su Costruire → Controlla tutti gli oggetti del pool ....", 
"body" : "Per controllare la libreria, fare clic su Costruire → Controlla tutti gli oggetti del pool . " }, 
{ "title" : "8. Creare la descrizione nel configuratore del gruppo di assi. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_51fd948a6c11885ac0a8646354b16b84", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Cinematica personalizzata \/ 8. Creare la descrizione nel configuratore del gruppo di assi. ", 
"snippet" : "Per creare la descrizione, devi prima installare CODESYS Library Documentation Support componente aggiuntivo. Questo componente aggiuntivo contiene il programma libdoc.exe richiesto nelle seguenti istruzioni L'add-on può essere installato tramite CODESYS Installer . Quando il POU ha l'attributo sm_k...", 
"body" : "Per creare la descrizione, devi prima installare CODESYS Library Documentation Support componente aggiuntivo. Questo componente aggiuntivo contiene il programma libdoc.exe richiesto nelle seguenti istruzioni L'add-on può essere installato tramite CODESYS Installer . Quando il POU ha l'attributo sm_kin_libdoc , il commento specificato nel blocco funzione viene utilizzato nel configuratore del gruppo di assi come descrizione della cinematica. A tale scopo viene utilizzata la formattazione del testo ristrutturata. Per generare la descrizione della cinematica dai commenti dei blocchi funzione nell'editor dei gruppi di assi, procedere nel modo seguente: Includi l'attributo sm_kin_libdoc come mostrato nell'immagine sopra. Includi le proprietà del progetto richieste DocFormat e DocLanguages (nella finestra di dialogo delle informazioni sul progetto) relativo alla documentazione della libreria. Risultato: Assicurati che la directory di installazione di CODESYS il file eseguibile libdoc.exe contiene (directory ...\\DocScripting\\3.5.xx.0 \\). Scarica il convertitore wkhtmltox a 32 bit con versione 0.12.5 o precedente da https:\/\/wkhtmltopdf.org\/downloads.html giù. Decomprimi il file wkhtmltox.dll e incollali CODESYS - Directory di installazione in ...\\DocScripting\\3.5.xx.0\\bin uno. Da quando wkhtmltox.dll non supporta più le immagini per impostazione predefinita nella versione 0.12.6 e successive, devi utilizzare la versione 0.12.5 o precedente. Crea la variabile di sistema LIBDOC_CODESYS in Windows. Imposta il valore sul percorso del file di CODESYS.exe . Assicurati di specificare il nome del percorso e il nome del profilo tra virgolette doppie. Risultato: Salva, chiudi e riapri il progetto della libreria. Clic File → Salva progetto come libreria compilata . La libreria compilata verrà installata nel progetto che utilizza questa cinematica. " }, 
{ "title" : "Utilizzo della libreria in un progetto (CustomKinematics_Implementation.project) ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3c747e2a6b6990f1c0a864637a72fb84", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Cinematica personalizzata \/ Utilizzo della libreria in un progetto (CustomKinematics_Implementation.project) ", 
"snippet" : "Il progetto dimostra come utilizzare e controllare la cinematica creata nella sezione precedente facendo jogging o comandando un movimento. Creare un CODESYS progetto standard con il CODESYS SoftMotion Win controllore. Apri il Gestore della libreria e installa la libreria CustomKinematics.compiled-l...", 
"body" : "Il progetto dimostra come utilizzare e controllare la cinematica creata nella sezione precedente facendo jogging o comandando un movimento. Creare un CODESYS progetto standard con il CODESYS SoftMotion Win controllore. Apri il Gestore della libreria e installa la libreria CustomKinematics.compiled-library (creato nella sezione precedente) contenente la cinematica Gantry3C. Aggiungi la libreria al Gestore della libreria. Aggiungere un oggetto di gruppo asse e selezionare il KinCustom.Gantry3C cinematica. Risultato: Aggiungi 4 assi virtuali al Pool di assi generali SoftMotion pool di assi nell'albero dei dispositivi. (DriveX, Y, Z e C) Aprire il configuratore del gruppo di assi. Nel Mappatura sugli assi sezione, mappare gli assi nei rispettivi campi. Risultato: Il programma Prg_Visu è il programma principale che controlla il gruppo di assi. Quando l'applicazione viene avviata, Prg_Visu accende il gruppo di assi e lo abilita. Inoltre, richiama tutti i blocchi funzione necessari per controllare il gruppo di assi (jogging, movimenti lineari e PTP). Tutti questi movimenti possono essere controllati dalla visualizzazione allegata. Risultato: Blocco funzione: Jog : Questo FB combina il jogging nello spazio degli assi e nello spazio cartesiano. Utilizza due istanze di SMC_GroupJog2 . Uno è per lo spazio degli assi e l'altro è per lo spazio cartesiano. Questo blocco funzione può essere utilizzato con i modelli di visualizzazione V_Posizione_Robot_assi E V_RobotPosition_carrello_Jog per spostare qualsiasi cinematica nello spazio cartesiano e negli assi. Risultato: FB SMC_TRAFOF_Gantry3C : Questo blocco funzione trasforma i valori dell'asse di ingresso di una cinematica Gantry3C nei rispettivi valori TCP. Inoltre, i valori degli assi sono normalizzati in modo che possano essere utilizzati con il modello di visualizzazione TRAFOF_Gantry3C_YZ per visualizzare i movimenti della cinematica. Risultato: Compila ed esegui l'applicazione. Apri la visualizzazione. Puoi muovere il robot nello spazio degli assi così come nello spazio cartesiano. Sono inoltre disponibili modelli di visualizzazione per comandare un movimento lineare o PTP. Risultato: L'esempio qui descritto discute gli assi di posizionamento e orientamento in un blocco funzione comune. Molte cinematiche possono comprendere due cinematiche parziali disaccoppiate: una cinematica di posizionamento (delta, gantry, ecc.) e una cinematica di orientamento (strumenti come asse C, polso2, polso3, ecc.). Entrambe le cinematiche sono collegate tra loro nel \"punto di flangia\", il TCP della cinematica di posizionamento. La cinematica di orientamento è caratterizzata dal fatto di poter calcolare il vettore dal punto di flangia al TCP della cinematica accoppiata. Il calcolo viene effettuato utilizzando solo l'orientamento di questo TCP (cioè indipendente dalla cinematica di posizionamento o indipendente dall'orientamento del punto di flangia). La cinematica di posizionamento a sua volta deve essere in grado di determinare le sue posizioni dell'asse solo dalla posizione del punto di flangia. Non deve dipendere dall'orientamento del punto della flangia. In questo caso, puoi ricorrere a interfacce come ISMPositionKinematics O ISMOrientationKinematics . Per implementare queste interfacce, definire un blocco funzione da implementare ISMPositionKinematics e un altro blocco funzione da implementare ISMOrientationKinematics . Infine, definire un blocco funzione che estenda il blocco funzione Kin_Coupled (da SM3_Transformation ) con i blocchi funzione precedentemente definiti come ingressi. Per ulteriori informazioni, vedere: Creazione di una cinematica personalizzata" }, 
{ "title" : "Utilizzo di Depictor per visualizzare i gruppi di assi ", 
"url" : "_sm_example_axis_group_depictor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Utilizzo di Depictor per visualizzare i gruppi di assi ", 
"snippet" : "Per questo progetto è necessario anche il CODESYS Depictor componente aggiuntivo con una licenza valida. L'applicazione SoftMotion è costituita da quattro azionamenti rotativi configurati come gruppo di assi. I primi tre assi spostano il TCP nel piano X\/Y e il quarto asse nel piano Z. L'esempio most...", 
"body" : "Per questo progetto è necessario anche il CODESYS Depictor componente aggiuntivo con una licenza valida. L'applicazione SoftMotion è costituita da quattro azionamenti rotativi configurati come gruppo di assi. I primi tre assi spostano il TCP nel piano X\/Y e il quarto asse nel piano Z. L'esempio mostra come è possibile utilizzare Depictor con la configurazione cinematica Kin_Scara3_Z. È possibile personalizzare la stessa procedura anche per altre configurazioni cinematiche. Avvio e test del programma È possibile modificare i valori degli assi nella visualizzazione del progetto. Se si commenta il comando di movimento attivo ( MoveAbs... , ...) nel programma PLC_PRG e rimuovere i commenti del secondo comando di spostamento, quindi è possibile modificare le coordinate cartesiane. Compila il progetto e scaricalo nel PLC. Apri l'editor dell'oggetto Depictor nel tuo progetto. Passare alla visualizzazione e modificare i valori degli assi oi valori cartesiani. Osserva il movimento del robot SCARA in Depictor. " }, 
{ "title" : "Creazione del progetto standard ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a87f67372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Utilizzo di Depictor per visualizzare i gruppi di assi \/ Creazione del progetto standard ", 
"snippet" : "Crea un progetto standard con il CODESYS SoftMotion Win controller e il linguaggio di programmazione ST. Aggiungi un gestore di libreria nel POU Visualizza. Apri il Gestore della libreria e aggiungi le librerie SM3_Depictor e DepictorBase ....", 
"body" : "Crea un progetto standard con il CODESYS SoftMotion Win controller e il linguaggio di programmazione ST. Aggiungi un gestore di libreria nel POU Visualizza. Apri il Gestore della libreria e aggiungi le librerie SM3_Depictor e DepictorBase . " }, 
{ "title" : "Aggiunta e parametrizzazione degli assi ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a65c81372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Utilizzo di Depictor per visualizzare i gruppi di assi \/ Aggiunta e parametrizzazione degli assi ", 
"snippet" : "Inserisci quattro assi virtuali sotto l'oggetto Pool di assi generali SoftMotion e denominare gli assi Drive1...Drive4. Parametrizzare gli assi Drive1, Drive2, Drive3 e Drive4 come tipo di asse finito con finecorsa software da -180 gradi a 180 gradi. Editor di configurazione: Per ulteriori informazi...", 
"body" : "Inserisci quattro assi virtuali sotto l'oggetto Pool di assi generali SoftMotion e denominare gli assi Drive1...Drive4. Parametrizzare gli assi Drive1, Drive2, Drive3 e Drive4 come tipo di asse finito con finecorsa software da -180 gradi a 180 gradi. Editor di configurazione: Per ulteriori informazioni, vedere: Unità virtuale" }, 
{ "title" : "Configurazione dei gruppi di assi ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5e750372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Utilizzo di Depictor per visualizzare i gruppi di assi \/ Configurazione dei gruppi di assi ", 
"snippet" : "Aggiungi un gruppo di assi \"KinScara\" sotto l'applicazione. Per fare ciò, fare clic su Progetto → Aggiungi oggetto → Gruppo di assi . Nel configuratore, fare clic su Seleziona cinematica . Seleziona il TRAFO.Kin_Scara3_Z cinematica. Definire i parametri come segue: dArmLength1 , dArmLength2 , dArmLe...", 
"body" : "Aggiungi un gruppo di assi \"KinScara\" sotto l'applicazione. Per fare ciò, fare clic su Progetto → Aggiungi oggetto → Gruppo di assi . Nel configuratore, fare clic su Seleziona cinematica . Seleziona il TRAFO.Kin_Scara3_Z cinematica. Definire i parametri come segue: dArmLength1 , dArmLength2 , dArmLength3 : 500 dOffsetA1 , dOffsetA2 , dOffsetA3 , dOffsetZ : 0 Ordina gli assi come segue: A1 : Drive1 la2 : Drive2 LA3 : Drive3 Z : Drive4 Nota: è possibile trascinare gli assi direttamente nel campo di immissione. Per ulteriori informazioni, vedere: Cinematica" }, 
{ "title" : "Creazione del programma del controller ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_26c321018be5c522c0a864636ae45467", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Utilizzo di Depictor per visualizzare i gruppi di assi \/ Creazione del programma del controller ", 
"snippet" : "Nel PLC_PRG programma, dichiarare le istanze di MC_Power blocco funzione per tutti gli azionamenti. Creare un istate variabile per il diagramma di stato. VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power; istate: INT; END_VAR Definire un diagramma di stato nell'implementazione. C...", 
"body" : "Nel PLC_PRG programma, dichiarare le istanze di MC_Power blocco funzione per tutti gli azionamenti. Creare un istate variabile per il diagramma di stato. VAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power;\n istate: INT;\nEND_VAR Definire un diagramma di stato nell'implementazione. CASE istate OF\n 0:\n 1:\n 2:\nEND_CASE Attiva tutte le unità in stato 0 . 0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF Quando gli assi sono attivati, abilitare il gruppo di assi (passaggio da \"disattivato\" a \"standby\"). VAR\n GroupEnable:MC_GroupEnable;\nEND_VAR\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF Dichiarare e inizializzare una variabile per salvare il valore impostato nelle coordinate macchina. Dichiara due istanze di tipo SMC_POS_REF per rappresentare il TCP in coordinate cartesiane e assi. VAR\n Frame: MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart: SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis: SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\nEND_VAR\nVAR CONSTANT\n axispos: TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR\n\n2:\n Pos_Cart.c:= Frame; \/\/ To represent the TCP in cartesian coordinates; Dichiarare un'istanza di MC_MoveDirectAbsolute per spostare il robot SCARA alle coordinate specificate. VAR\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates\nEND_VAR\n\n2:\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined Axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF Dichiarare una variabile di tipo SMC_GroupReadSetPosition per leggere il valore corrente del robot in coordinate cartesiane e coordinate assi. VAR\n Car_pos, Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current axis values\nEND_VAR\n\n2:\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ to read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ to read the current axis values " }, 
{ "title" : "L'intero programma PLC_PRG ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5721f372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Utilizzo di Depictor per visualizzare i gruppi di assi \/ L'intero programma PLC_PRG ", 
"snippet" : "Confronta il tuo programma e aggiungi le parti di programma mancanti. Dichiarazione PROGRAM PLC_PRG VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power; istate: INT; GroupEnable:MC_GroupEnable; Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & o...", 
"body" : "Confronta il tuo programma e aggiungi le parti di programma mancanti. Dichiarazione PROGRAM PLC_PRG\nVAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power;\n istate: INT;\n\n GroupEnable:MC_GroupEnable;\n\n Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart:SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis:SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\n\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates (PTP)\n\n Car_pos,Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current position of the TCP in Cartesian and Axis Coordinates and display it on the visu\n\n scara_Config:trafo.Kin_Scara3_Z_Config; \/\/ To set the configuration of the SCARA_3_Z\n kin_Config:SMC_SetKinConfiguration; \/\/ To set the defined configuration of SCARA_3_Z to the axis group used\n nPeriod:DINT:=0; \/\/ SCARA_3_Z Period\n Xelbow:BOOL:=TRUE;\n\nEND_VAR\nVAR CONSTANT\n axispos : TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR Implementazione CASE istate OF\n\n0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF\n\n2:\n scara_Config(xElbowRight:=Xelbow, nPeriodA3:=nPeriod);\n kin_Config(AxisGroup:=KinScara,ConfigData:=scara_Config.Config, Execute:=TRUE);\n Pos_Cart.c:=Frame; \/\/ To represent the TCP in cartesian coordinates\n\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ read the current position in Axis coordinates\n\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF\nEND_CASE " }, 
{ "title" : "Creazione di un programma Depictor ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_8f044cf9373811e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Utilizzo di Depictor per visualizzare i gruppi di assi \/ Creazione di un programma Depictor ", 
"snippet" : "Aggiungere una nuova POU \"Depic\" di tipo \"Programma\" sotto l'applicazione. Per fare ciò, fare clic su Progetto → Aggiungi oggetto → POU . Dichiarare una variabile di tipo SM3_Depictor.SMC_R_Scara3_Z_Data . Dichiarare una variabile LrSize di tipo LREAL e inizializzare la variabile con il valore di 10...", 
"body" : "Aggiungere una nuova POU \"Depic\" di tipo \"Programma\" sotto l'applicazione. Per fare ciò, fare clic su Progetto → Aggiungi oggetto → POU . Dichiarare una variabile di tipo SM3_Depictor.SMC_R_Scara3_Z_Data . Dichiarare una variabile LrSize di tipo LREAL e inizializzare la variabile con il valore di 100. VAR\n ScaraTrafo : SM3_Depictor.SMC_R_Scara3_Z_Data;\n LrSize:LREAL:=100;\nEND_VAR Inserire una chiamata al blocco funzione nell'implementazione. ScaraTrafo(AxisGroup:=KinScara, trf:=KinScara.trafo); Aggiungi il POU \"Depic\" al Compito principale . " }, 
{ "title" : "Configurazione del visualizzatore ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a523fe372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Utilizzo di Depictor per visualizzare i gruppi di assi \/ Configurazione del visualizzatore ", 
"snippet" : "Aggiungi un oggetto \"Depictor\" sotto l'applicazione. Per fare ciò, fare clic su Progetto → Aggiungi oggetto → Rappresentante . Fare doppio clic sull'oggetto. Seleziona il Posa elemento nell'albero di rappresentazione. Clic Rappresentante → Aggiungi elemento . Il Scatola l'elemento viene aggiunto sot...", 
"body" : "Aggiungi un oggetto \"Depictor\" sotto l'applicazione. Per fare ciò, fare clic su Progetto → Aggiungi oggetto → Rappresentante . Fare doppio clic sull'oggetto. Seleziona il Posa elemento nell'albero di rappresentazione. Clic Rappresentante → Aggiungi elemento . Il Scatola l'elemento viene aggiunto sotto la posa. Seleziona il Rif. raffigurante opzione nelle proprietà dell'elemento. Clicca il pulsante. Seleziona il SMC_R_Depictor_Scara3_Z oggetto dal SM3_Depictor biblioteca. Definire le variabili di interfaccia come segue: fb : Depic.ScaraTrafo lrZ_ : Drive1.fSetPosition lrZmin : 10 lrZmax : -50 lrSize : Depic.LrSize xShowPlane : 0 " }, 
{ "title" : "Creazione di visualizzazioni ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a460ad372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Utilizzo di Depictor per visualizzare i gruppi di assi \/ Creazione di visualizzazioni ", 
"snippet" : "Creare una schermata di visualizzazione in cui è possibile visualizzare e modificare le coordinate cartesiane e le coordinate degli assi. Aggiungi un oggetto \"Visualizzazione\" sotto l'applicazione. Per fare ciò, fare clic su Progetto → Aggiungi oggetto → Visualizzazione . Apri la visualizzazione nel...", 
"body" : "Creare una schermata di visualizzazione in cui è possibile visualizzare e modificare le coordinate cartesiane e le coordinate degli assi. Aggiungi un oggetto \"Visualizzazione\" sotto l'applicazione. Per fare ciò, fare clic su Progetto → Aggiungi oggetto → Visualizzazione . Apri la visualizzazione nell'editor. Inserisci a Rettangolo elemento di visualizzazione (1). Modificare le proprietà dell'elemento. Testi → Testo : %S Variabili di testo → Variabile di testo : PLC_PRG.Car_pos.Position.c.X Configurazione ingressi → OnMouseDown → Scrivi variabile Tipo di ingresso : VisuDialogs.Tastierino numerico Usa un'altra variabile : PLC_PRG.Frame.X Inserisci l'altro Scatola elementi di visualizzazione. Modificare le proprietà degli elementi (2) e (3). Testi → Testo : %S Variabili di testo → Variabile di testo : PLC_PRG.Car_pos.Position.c.Y o PLC_PRG.Car_pos.Position.c.Z Configurazione ingressi → OnMouseDown → Scrivi variabile Tipo di ingresso : VisuDialogs.Tastierino numerico Usa un'altra variabile : PLC_PRG.Frame.Y e PLC_PRG.Frame.Z Modificare le proprietà degli elementi (4), (5) e (6). Testi → Testo : %S Variabili di testo → Variabile di testo : PLC_PRG.Frame.A o PLC_PRG.Frame.B o PLC_PRG.Frame.C Modificare le proprietà degli elementi (7), (8), (9) e (10). Testi → Testo : %S Variabili di testo → Variabile di testo : PLC_PRG.Axis_pos.Position.a.a0 o PLC_PRG.Axis_pos.Position.a.a1 o PLC_PRG.Axis_pos.Position.a.a2 o PLC_PRG.Axis_pos.Position.a.a3 Configurazione ingressi → OnMouseDown → Scrivi variabile Tipo di ingresso : VisuDialogs.Tastierino numerico Usa un'altra variabile : PLC_PRG.Pos_Axis.a.a0 e PLC_PRG.Pos_Axis.a.a1 e PLC_PRG.Pos_Axis.a.a2 e PLC_PRG.Pos_Axis.a.a3 Etichetta gli elementi di visualizzazione con il Etichetta elemento. " }, 
{ "title" : "Esempio di trigger 1: esempio semplice ", 
"url" : "_sm_example_digital_switches1.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Esempio di trigger 1: esempio semplice ", 
"snippet" : "IL Robotics_Trigger.project progetto di esempio qui descritto si trova nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . I trigger vengono utilizzati per scoprire esattamente quando un gruppo di assi raggiunge un punto specifico sul percorso comandato. Queste informa...", 
"body" : "IL Robotics_Trigger.project progetto di esempio qui descritto si trova nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . I trigger vengono utilizzati per scoprire esattamente quando un gruppo di assi raggiunge un punto specifico sul percorso comandato. Queste informazioni possono essere utilizzate, ad esempio, per accendere o spegnere uno strumento esattamente al momento giusto. Questo esempio mostra come un singolo trigger viene comandato su un movimento e quindi letto ciclicamente. Sulla base di ciò, il Esempio di trigger 2: processo di incollaggio mostra un'applicazione di esempio realistica. " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_example_digital_switches1.html#UUID-69fc12d0-622f-ba4d-33ec-32604b337f95_section-idm4609369968113633803655575311", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Esempio di trigger 1: esempio semplice \/ Struttura dell'applicazione ", 
"snippet" : "L'applicazione è composta da due programmi: a Main_PRG in esecuzione nell'attività del bus e a Planning_PRG in esecuzione nell'attività di pianificazione del gruppo di assi. Inoltre, c'è anche una traccia. Principale_PRG : IL Main_PRG programma contiene la macchina a stati principale dell'applicazio...", 
"body" : "L'applicazione è composta da due programmi: a Main_PRG in esecuzione nell'attività del bus e a Planning_PRG in esecuzione nell'attività di pianificazione del gruppo di assi. Inoltre, c'è anche una traccia. Principale_PRG : IL Main_PRG programma contiene la macchina a stati principale dell'applicazione. I primi due stati servono per l'inizializzazione e l'accensione degli azionamenti e del gruppo di assi. Nel STATE_COMMAND_MOVEMENT_WITH_TRIGGER stato, un trigger viene prima preparato utilizzando un'istanza dal file SMC_GroupPrepareTrigger blocco funzione. La posizione è specificata relativamente con un valore di 0,6. Di conseguenza, il grilletto viene posizionato nel punto in cui viene completato il 60% del movimento assegnato. Il trigger preparato viene assegnato al successivo movimento comandato. In questo esempio, un movimento lineare verso la posizione (X=20, Y=10) è comandato da an MC_MoveLinearAbsolute . prepTrigger.PositionType := SMC_TriggerPositionType.MvtRelative;\nprepTrigger.Position.MvtPosition := 0.6;\nprepTrigger(AxisGroup:= AxisGroup, Execute:= TRUE);\n \nmoveLinear(AxisGroup:= AxisGroup, Execute:= prepTrigger.Prepared); Nel prossimo stato STATE_ENABLE_READ_TRIGGER , un esempio di SMC_GroupReadTrigger viene avviato per leggere lo stato del trigger comandato. Il collegamento con il trigger viene stabilito mediante il TriggerId restituito da SMC_GroupPrepareTrigger . readTrigger.TriggerId := prepTrigger.TriggerId;\nreadTrigger.Enable := TRUE; Nel STATE_CHECK_TRIGGER state, lo stato del trigger viene infine verificato ciclicamente. Non appena SMC_GroupReadTrigger rapporti Active come stato è possibile leggere la durata fino al raggiungimento del trigger. La durata si riferisce sempre all'inizio del ciclo in corso. Pertanto, il trigger viene raggiunto nel ciclo corrente se la durata è inferiore al tempo di ciclo (in questo esempio, 0,004 s): IF readTrigger.TriggerInfo.status = SMC_TRIGGER_STATUS.Active THEN\n IF readTrigger.TriggerInfo.triggerTime <= 0.004 THEN\n triggerFired := TRUE;\n ...\n END_IF\nEND_IF Pianificazione_PRG Nel Planning_PRG programma, la durata prevista della pianificazione è configurata tramite il SMC_TuneCPKernel blocco funzione. IL SMC_GroupReadTrigger il blocco funzione può emettere quando viene raggiunta la durata prevista di un trigger. Nell'esempio, la durata della previsione è impostata su 0,1 s. Pertanto, lo stato del SMC_GroupReadTrigger il blocco funzione cambia in Active 0,1 s prima che il gruppo di assi raggiunga il trigger e da quel momento in poi emetta una durata valida. tuneCpKernel(AxisGroup:= axisGroup, Execute:= TRUE, fPlanningForecastDuration:= 0.1); Traccia La traccia può essere utilizzata per tenere traccia del comportamento del file SMC_GroupReadTrigger blocco funzione. Nel primo diagramma si vede che viene eseguito un movimento da (X=0, Y=0) a (X=20, Y=10). Il grilletto si trova nella posizione relativa 0.6 sul movimento, cioè in (X=12, Y=6). Il secondo diagramma mostra il valore di triggerTime uscita da SMC_GroupReadTrigger . Il valore salta a 0,1 s perché la durata prevista della pianificazione è 0,1 s, quindi scende linearmente fino a raggiungere il valore 0 nella posizione (X=12, Y=6). Il terzo diagramma mostra il valore del triggerFired variabile impostata in STATE_CHECK_TRIGGER stato di Main_PRG non appena il gruppo di assi si trova a meno di 0,004 s dal trigger. " }, 
{ "title" : "Esempio di trigger 2: processo di incollaggio ", 
"url" : "_sm_example_digital_switches2.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Esempio di trigger 2: processo di incollaggio ", 
"snippet" : "IL Robotics_Trigger_Advanced.project progetto di esempio qui descritto si trova nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . I trigger possono essere utilizzati per eseguire azioni in posizioni specifiche sul percorso, come l'accensione e lo spegnimento di un ug...", 
"body" : "IL Robotics_Trigger_Advanced.project progetto di esempio qui descritto si trova nella directory di installazione di CODESYS Sotto ..\\CODESYS SoftMotion\\Examples . I trigger possono essere utilizzati per eseguire azioni in posizioni specifiche sul percorso, come l'accensione e lo spegnimento di un ugello di incollaggio. Questo esempio include i seguenti componenti: La configurazione di una previsione garantita della traiettoria da parte del fPlanningForecastDuration parametro da SMC_TuneCPKernel blocco funzione. Il comando di diversi trigger. Qui vengono utilizzati tutti e tre i metodi disponibili per definire la posizione del percorso (vedere SMC_TriggerPositionType ). L'uso di trigger con time shift. L'applicazione di esempio contiene il file TriggerWithTimeShift blocco funzione, che può reagire al raggiungimento della posizione del percorso con un offset temporale (prima e dopo). Questi componenti sono mostrati in un esempio di applicazione per un processo di incollaggio. Viene eseguito il movimento visualizzato in rosso nell'immagine seguente (con fusione). I trigger sono stati definiti nelle posizioni contrassegnate in verde: Posizione 1: accendere il dispositivo di incollaggio 0,05 s prima di raggiungere la posizione. Posizione 1: accendere la lampada UV quando viene raggiunta la posizione. Posizione 2: Riempire il serbatoio di alimentazione della colla quando viene raggiunta la posizione. Posizione 3: Spegnere il dispositivo di incollaggio e interrompere il riempimento del serbatoio della colla 0,05 s prima di raggiungere la posizione. Posizione 3: Spegnere la lampada UV 1,5 s dopo aver raggiunto la posizione " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4589008317470433803801762921", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Esempio di trigger 2: processo di incollaggio \/ Struttura dell'applicazione ", 
"snippet" : "L'applicazione è composta dalle seguenti parti. GlueApplication : Questo programma contiene l'applicazione di esempio che mostra come utilizzare i trigger per un processo di incollaggio. Planning_PRG : In questo programma è configurata una previsione della traiettoria. TriggerWithTimeShift : Questo ...", 
"body" : "L'applicazione è composta dalle seguenti parti. GlueApplication : Questo programma contiene l'applicazione di esempio che mostra come utilizzare i trigger per un processo di incollaggio. Planning_PRG : In questo programma è configurata una previsione della traiettoria. TriggerWithTimeShift : Questo blocco funzione contiene la logica per i trigger con uno spostamento temporale e viene utilizzato in GlueApplication programma di esempio. Trace : La traccia mostra la dinamica degli assi e anche le uscite del GlueApplication programma che vengono attivati dai trigger. " }, 
{ "title" : "Configurazione di una previsione ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4570491496867233803803206327", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Esempio di trigger 2: processo di incollaggio \/ Configurazione di una previsione ", 
"snippet" : "Se vuoi reagire in anticipo prima che venga raggiunto un trigger, ad esempio 0,05 s prima, allora il fPlanningForecastDuration parametro da SMC_ SMC_TuneCPKernel blocco funzione deve essere impostato su almeno 0,05 s. Poiché il parametro ha un impatto diretto sulla latenza, il suo valore non dovrebb...", 
"body" : "Se vuoi reagire in anticipo prima che venga raggiunto un trigger, ad esempio 0,05 s prima, allora il fPlanningForecastDuration parametro da SMC_ SMC_TuneCPKernel blocco funzione deve essere impostato su almeno 0,05 s. Poiché il parametro ha un impatto diretto sulla latenza, il suo valore non dovrebbe essere maggiore del necessario (vedere la documentazione di fPlanningForecastDuration ). Notare che SMC_TuneCPKernel deve essere chiamato in SoftMotion compito di pianificazione. Per questo motivo la configurazione non viene eseguita nel programma principale GlueApplication , ma nel Planning_PRG programma. In questa applicazione di esempio, la valutazione del trigger è richiesta al più presto 0,05 s prima che venga raggiunta una posizione. Per questo motivo il parametro fPlanningForecastDuration =0.05 è impostato nel Planning_PRG programma. " }, 
{ "title" : "Blocco funzione: TriggerWithTimeShift ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4609369977958433803803968971", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Esempio di trigger 2: processo di incollaggio \/ Blocco funzione: TriggerWithTimeShift ", 
"snippet" : "IL TriggerWithTimeShift Il blocco funzione fornisce un'interfaccia semplificata per l'utilizzo dei trigger. Inoltre, è possibile definire uno spostamento temporale in modo che il trigger possa reagire prima del raggiungimento di una posizione (valore positivo) e dopo il raggiungimento di una posizio...", 
"body" : "IL TriggerWithTimeShift Il blocco funzione fornisce un'interfaccia semplificata per l'utilizzo dei trigger. Inoltre, è possibile definire uno spostamento temporale in modo che il trigger possa reagire prima del raggiungimento di una posizione (valore positivo) e dopo il raggiungimento di una posizione (valore negativo). A seconda della precisione temporale richiesta in un'applicazione, la reazione al raggiungimento di un trigger può essere la seguente: Precisione temporale richiesta >= ciclo task bus: In questo caso, il file TriggerWithTimeShift.TriggerReachedThisCycle l'uscita può essere utilizzata. Precisione temporale richiesta < ciclo task bus: in questo caso, il tempo rimanente esatto TriggerWithTimeShift.TriggerTime fino al raggiungimento del trigger può essere utilizzato. Internamente, TriggerWithTimeShift utilizza il SMC_GroupPrepareTrigger E SMC_GroupReadTrigger blocchi funzione. " }, 
{ "title" : "Trigger di comando ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4608844104630433803805051855", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Esempio di trigger 2: processo di incollaggio \/ Trigger di comando ", 
"snippet" : "Nel GlueApplication programma, i movimenti e i trigger vengono comandati. L'ordine di chiamata è particolarmente importante per i trigger perché i trigger vengono preparati utilizzando SMC_GroupPrepareTrigger vengono assegnati al movimento successivo comandato nello stesso ciclo. Pertanto, in ogni a...", 
"body" : "Nel GlueApplication programma, i movimenti e i trigger vengono comandati. L'ordine di chiamata è particolarmente importante per i trigger perché i trigger vengono preparati utilizzando SMC_GroupPrepareTrigger vengono assegnati al movimento successivo comandato nello stesso ciclo. Pertanto, in ogni applicazione è necessario prestare attenzione a quanto segue: I blocchi funzione per comandare i trigger vengono sempre richiamati prima dei blocchi funzione di movimento. I trigger e il rispettivo movimento vengono comandati sempre nello stesso ciclo. I trigger utilizzano tutti i tipi da SMC_TriggerPositionType : I trigger alla posizione 1 utilizzano la definizione di una distanza relativa ( SMC_TriggerPositionType.MvtRelative ) e come Posizione 0.5. Poiché il rispettivo movimento ha una distanza di 10, i trigger si trovano in X=5. Il trigger in posizione 2 utilizza la definizione di una distanza in unità utente u ( SMC_TriggerPositionType.MvtDistance ) e come posizione 5. Di conseguenza, anche il trigger si trova in X=5. I trigger in posizione 3 utilizzano l'intersezione con un piano ( SMC_TriggerPositionType.PlaneIntersection ). Il piano è stato definito in modo che i trigger si trovino in X=5. GlueApplication ha il EnableGlue , EnableUVLamp , E RefillGlueStorage uscite. Questi vengono attivati nei trigger appropriati GlueApplication.EvaluateTriggers() . Il movimento e lo stato di queste uscite possono essere monitorati e valutati nel Trace. " }, 
{ "title" : "Utilizzo di assi aggiuntivi nella robotica ", 
"url" : "_sm_example_additional_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Utilizzo di assi aggiuntivi nella robotica ", 
"snippet" : "Le Robotics_AdditionalAxes.project un progetto di esempio mostra come gli assi aggiuntivi vengono configurati e utilizzati nella robotica. Gli assi aggiuntivi sono assi che vengono spostati in modo sincrono con movimenti coordinati Il progetto si trova nella cartella di installazione di CODESYS sott...", 
"body" : "Le Robotics_AdditionalAxes.project un progetto di esempio mostra come gli assi aggiuntivi vengono configurati e utilizzati nella robotica. Gli assi aggiuntivi sono assi che vengono spostati in modo sincrono con movimenti coordinati Il progetto si trova nella cartella di installazione di CODESYS sotto ..\\CODESYS SoftMotion\\Examples . " }, 
{ "title" : "Struttura dell'applicazione ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063293414778", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Utilizzo di assi aggiuntivi nella robotica \/ Struttura dell'applicazione ", 
"snippet" : "Il gruppo di assi è configurato nel Gruppo Axis oggetto. Viene utilizzato un robot SCARA a 3 assi (due assi rotativi e un asse Z lineare Di seguito sono stati aggiunti anche due assi aggiuntivi Assi aggiuntivi e collegati ai due assi DriveAdd1 e DriveAdd2 Le PLC_PRG il programma contiene una semplic...", 
"body" : "Il gruppo di assi è configurato nel Gruppo Axis oggetto. Viene utilizzato un robot SCARA a 3 assi (due assi rotativi e un asse Z lineare Di seguito sono stati aggiunti anche due assi aggiuntivi Assi aggiuntivi e collegati ai due assi DriveAdd1 e DriveAdd2 Le PLC_PRG il programma contiene una semplice macchina a stati per il flusso del programma. Innanzitutto, il gruppo di assi è abilitato nello stato 0 , quindi un movimento PTP verso la posizione (X=50, Y=50) viene eseguita. Questo viene poi mescolato in un movimento lineare verso la posizione (X=50, Y=-50) . Per il primo movimento del robot, un movimento relativo dell'asse aggiuntivo con distanza (10, 20) è comandato. Per il secondo movimento del robot, la distanza dell'asse aggiuntivo (-10, -20) . Le MC_GroupReadActualPosition e MC_GroupReadActualVelocity i blocchi funzione vengono utilizzati per leggere la posizione e la velocità della cinematica e degli assi aggiuntivi. " }, 
{ "title" : "Messa in servizio ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063296617065", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Esempi \/ Utilizzo di assi aggiuntivi nella robotica \/ Messa in servizio ", 
"snippet" : "Crea l'applicazione e scaricala su un controller. Apri la traccia e scaricala sul controller. Avviare l'applicazione. È possibile tracciare il movimento delle coordinate X e Y e dei due assi aggiuntivi nella traccia....", 
"body" : "Crea l'applicazione e scaricala su un controller. Apri la traccia e scaricala sul controller. Avviare l'applicazione. È possibile tracciare il movimento delle coordinate X e Y e dei due assi aggiuntivi nella traccia. " }, 
{ "title" : "Interfaccia utente ", 
"url" : "_sm_robotics_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Interfaccia utente ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comando: Crea attività di pianificazione ", 
"url" : "_sm_cmd_create_planning_task.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Interfaccia utente \/ Comando: Crea attività di pianificazione ", 
"snippet" : "Funzione : il comando crea automaticamente un'attività di pianificazione. Questo compito è necessario per la pianificazione dei movimenti CP (ad esempio, movimento lineare o movimento circolare). Chiamata : Progetto menù; menu contestuale del gruppo di assi Requisiti : Il comando è disponibile solo ...", 
"body" : "Funzione : il comando crea automaticamente un'attività di pianificazione. Questo compito è necessario per la pianificazione dei movimenti CP (ad esempio, movimento lineare o movimento circolare). Chiamata : Progetto menù; menu contestuale del gruppo di assi Requisiti : Il comando è disponibile solo se non è configurata alcuna attività di pianificazione per il gruppo di assi. " }, 
{ "title" : "Editor del gruppo di assi ", 
"url" : "_sm_obj_axis_group-1018069.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Interfaccia utente \/ Editor del gruppo di assi ", 
"snippet" : "Simbolo: Nell'editore di Gruppo di assi oggetto, selezionare il tipo di cinematica di base e cinematica di orientamento. La cinematica di orientamento può essere selezionata solo quando è supportata dalla cinematica di base. Inoltre, nel progetto si mappano gli assi della cinematica sugli azionament...", 
"body" : "Simbolo: Nell'editore di Gruppo di assi oggetto, selezionare il tipo di cinematica di base e cinematica di orientamento. La cinematica di orientamento può essere selezionata solo quando è supportata dalla cinematica di base. Inoltre, nel progetto si mappano gli assi della cinematica sugli azionamenti. Cinematica Seleziona cinematica Cambia cinematica Apre un elenco di tutte le cinematiche supportate da CODESYS Quando si seleziona un tipo di cinematica, nel riquadro a destra dell'elenco viene mostrata una breve descrizione. Dopo aver selezionato un tipo di cinematica, è possibile modificare i rispettivi parametri nell'editor. Cinematica di orientamento Seleziona cinematica Cambia cinematica Apre un elenco di tutte le cinematiche di orientamento supportate da CODESYS Quando si seleziona un tipo di cinematica, nel riquadro a destra dell'elenco viene mostrata una breve descrizione. Dopo aver selezionato un tipo di cinematica, è possibile modificare i rispettivi parametri nell'editor. Mappatura degli assi A seconda della cinematica selezionata, si mappano gli assi della cinematica sugli azionamenti nel progetto. Assi aggiuntivi Aggiungi asse Aggiunge un campo di configurazione per un asse aggiuntivo. L'unità del progetto viene inserita in questo campo di configurazione. Compiti Task ciclo bus Task ciclo bus degli assi, se gli assi sono già mappati L'impostazione non può essere modificata qui. Compito di pianificazione Compito per la pianificazione dei compiti CP Un'attività di pianificazione viene creata automaticamente quando viene inserito il primo gruppo di assi. Non è opportuno configurare un watchdog perché il tempo di esecuzione può variare notevolmente. Per ulteriori informazioni, vedere: Configurazione dell'attività di pianificazioneSe elimini questa attività, viene generato un errore nella visualizzazione del messaggio. Per creare una nuova attività, fare clic su Progetto → Creare un'attività di pianificazione . Per ulteriori informazioni, vedere: Come creare un gruppo di assi" }, 
{ "title" : "Interfaccia utente ", 
"url" : "_sm_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Interfaccia utente ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comando: Abilita SoftMotion ", 
"url" : "_sm_cmd_enable_softmotion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Interfaccia utente \/ Comando: Abilita SoftMotion ", 
"snippet" : "Funzione : Il comando abilita i componenti di SoftMotion per il controller selezionato e consente di utilizzare il controller come controller di movimento. Chiamata : Progetto menù; menu contestuale di un dispositivo selezionato nella struttura dei dispositivi Requisiti : Per il controller seleziona...", 
"body" : "Funzione : Il comando abilita i componenti di SoftMotion per il controller selezionato e consente di utilizzare il controller come controller di movimento. Chiamata : Progetto menù; menu contestuale di un dispositivo selezionato nella struttura dei dispositivi Requisiti : Per il controller selezionato, SoftMotion non è abilitato. Il comando provoca il Pool di assi generali SoftMotion dispositivo da aggiungere sotto la configurazione del controller fintanto che l'oggetto è ancora mancante. Ce n'è al massimo uno Pool di assi generali SoftMotion per dispositivo PLC. Inoltre, le librerie SoftMotion (con prefisso SM3_ ) vengono aggiunti al Gestore della libreria. Di conseguenza, è possibile utilizzare la funzionalità SoftMotion su tutti i PLC convenzionali e, ad esempio, richiamare i blocchi funzione SoftMotion anche senza licenza almeno in modalità demo. Attivazione automatica Se il tuo dispositivo è disabilitato per SoftMotion e hai aggiunto qualsiasi oggetto SoftMotion sotto il dispositivo, allora il Abilita SoftMotion comando viene eseguito immediatamente in modo implicito. Un oggetto SoftMotion è un oggetto camma, un oggetto CNC, un oggetto di gruppo asse o qualsiasi asse SoftMotion. Aggiornamento del dispositivo da un PLC SoftMotion a un PLC standard Se SoftMotion è stato abilitato e i dispositivi sono stati configurati di seguito Pool di assi generali SoftMotion , quindi puoi comunque aggiornare il tuo dispositivo a un PLC standard. Questo perché questi dispositivi rimangono disponibili anche dopo l'aggiornamento. Ad esempio, puoi aggiornare da CODESYS SoftMotion RTE a CODESYS Control RTE senza alcuna perdita. " }, 
{ "title" : "Comando: Disattiva SoftMotion ", 
"url" : "_sm_cmd_disable_softmotion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Interfaccia utente \/ Comando: Disattiva SoftMotion ", 
"snippet" : "Funzione : Il comando disabilita i componenti di SoftMotion . Chiamata : Progetto menù; menu contestuale di un dispositivo selezionato nella struttura dei dispositivi Requisiti : Per il controller selezionato, SoftMotion è stato abilitato tramite il comando. SoftMotion non può essere disabilitato pe...", 
"body" : "Funzione : Il comando disabilita i componenti di SoftMotion . Chiamata : Progetto menù; menu contestuale di un dispositivo selezionato nella struttura dei dispositivi Requisiti : Per il controller selezionato, SoftMotion è stato abilitato tramite il comando. SoftMotion non può essere disabilitato per i controller che sono destinati a supportare SoftMotion (esempio: CODESYS SoftMotion Win ). Il comando provoca il Pool di assi generali SoftMotion dispositivo da rimuovere al di sotto della configurazione del controller. Inoltre, le librerie SoftMotion (con prefisso SM3_ ) vengono rimossi dal Gestore della libreria. Non è più possibile utilizzare la funzionalità SoftMotion. " }
]
$(document).trigger('search.ready');
});