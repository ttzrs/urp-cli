$(document).ready(function () {indexDict['it'] = [{ "title" : "CODESYS Control ", 
"url" : "_rtsl_start_page.html", 
"breadcrumbs" : "CODESYS Control \/ CODESYS Control ", 
"snippet" : "Puoi installare il CODESYS Control for <device> SL sistema runtime su vari dispositivi industriali. Di conseguenza, si hanno le seguenti possibilità per la programmazione e il controllo dei dispositivi: Programmazione uniforme secondo IEC 61131-3 con CODESYS Development System Download, gestione ed ...", 
"body" : "Puoi installare il CODESYS Control for <device> SL sistema runtime su vari dispositivi industriali. Di conseguenza, si hanno le seguenti possibilità per la programmazione e il controllo dei dispositivi: Programmazione uniforme secondo IEC 61131-3 con CODESYS Development System Download, gestione ed esecuzione del codice dell'applicazione compilato da CODESYS Debug dell'applicazione di controllo dall'interno CODESYS Gestione di sistemi I\/O e bus di campo Esecuzione di componenti opzionali, come ad esempio CODESYS TargetVisu , CODESYS WebVisu , CODESYS SoftMotion CNC + robotica e server OPC UA " }, 
{ "title" : "Avvisi di sicurezza ", 
"url" : "_rtsl_start_page.html#UUID-421e9fc4-30bc-da26-ebd8-4038f3d434c1_section-idm4550391658761633048843474945", 
"breadcrumbs" : "CODESYS Control \/ CODESYS Control \/ Avvisi di sicurezza ", 
"snippet" : "Il Titolare non deve in nessun caso essere accessibile da Internet. In particolare, le porte di programmazione del controller non devono essere accessibili in nessun caso da Internet senza protezione. Di seguito sono elencati i numeri di porta più importanti per tutti i sistemi runtime. Per impostaz...", 
"body" : "Il Titolare non deve in nessun caso essere accessibile da Internet. In particolare, le porte di programmazione del controller non devono essere accessibili in nessun caso da Internet senza protezione. Di seguito sono elencati i numeri di porta più importanti per tutti i sistemi runtime. Per impostazione predefinita, vengono assegnati dal sistema, ma possono essere modificati mediante la configurazione: 1740..1743: driver di blocco UDP nel sistema gateway e runtime 11740..11743: driver di blocco TCP nel gateway e nel sistema di runtime 1217: Gateway per la connessione CODESYS alla porta 8080: CODESYS server web 443: CODESYS server web (SSL) * * 9090: per BeagleBone 4840: CODESYS Server OPC UA 22: connessione SSH alla destinazione (installazione\/aggiornamento dei runtime SL basati su Linux tramite CODESYS sistema di programmazione) Se l'accesso da Internet deve comunque essere possibile, è assolutamente necessario selezionare un metodo sicuro per la connessione al controllore (esempio: VPN). Poiché i sistemi runtime consentono l'accesso al PC, devono essere dotati di una corrispondente gestione degli utenti e dei diritti. Puoi scaricare i prodotti su CODESYS Control da CODESYS Store International o CODESYS Store Nord America . Lì troverai anche la scheda tecnica del prodotto. CODESYS Deploy Tool " }, 
{ "title" : "Panoramica del Prodotto ", 
"url" : "_rtsl_product_overview.html", 
"breadcrumbs" : "CODESYS Control \/ Panoramica del Prodotto ", 
"snippet" : "Informazioni sulle esigenze del sistema e sull'ambito di fornitura del CODESYS Control for <device> SL i prodotti si possono trovare su CODESYS Store International : Le licenze per i sistemi runtime sono disponibili all'indirizzo CODESYS Store International . Senza una licenza valida, il runtime di ...", 
"body" : "Informazioni sulle esigenze del sistema e sull'ambito di fornitura del CODESYS Control for <device> SL i prodotti si possono trovare su CODESYS Store International : Le licenze per i sistemi runtime sono disponibili all'indirizzo CODESYS Store International . Senza una licenza valida, il runtime di tutti i sistemi runtime è limitato a 2 ore. " }, 
{ "title" : "Sistemi runtime indipendenti dall'hardware ", 
"url" : "_rtsl_product_overview.html#UUID-da861021-6b3f-718d-ac40-c1e7e9f72bd8_section-idm4613712476080033169570967262", 
"breadcrumbs" : "CODESYS Control \/ Panoramica del Prodotto \/ Sistemi runtime indipendenti dall'hardware ", 
"snippet" : "CODESYS Control Win SL CODESYS Control RTE SL CODESYS Control for Linux SL CODESYS Control for Linux ARM\/ARM64 CODESYS Virtual Control SL CODESYS Virtual Safe Control SL...", 
"body" : "CODESYS Control Win SL CODESYS Control RTE SL CODESYS Control for Linux SL CODESYS Control for Linux ARM\/ARM64 CODESYS Virtual Control SL CODESYS Virtual Safe Control SL " }, 
{ "title" : "Sistemi di runtime specifici dell'hardware ", 
"url" : "_rtsl_product_overview.html#UUID-da861021-6b3f-718d-ac40-c1e7e9f72bd8_section-idm4589278258244833169573395522", 
"breadcrumbs" : "CODESYS Control \/ Panoramica del Prodotto \/ Sistemi di runtime specifici dell'hardware ", 
"snippet" : "CODESYS Control for Beaglebone SL CODESYS Control for Raspberry PI SL CODESYS Control for PFC100 SL CODESYS Control for PFC200 SL CODESYS Control for emPC-A\/iMX6 SL CODESYS Control for WAGO Touch Panels 600 SL CODESYS Control for PLCnext SL CODESYS Control RTE SL (for Beckhoff CX)...", 
"body" : "CODESYS Control for Beaglebone SL CODESYS Control for Raspberry PI SL CODESYS Control for PFC100 SL CODESYS Control for PFC200 SL CODESYS Control for emPC-A\/iMX6 SL CODESYS Control for WAGO Touch Panels 600 SL CODESYS Control for PLCnext SL CODESYS Control RTE SL (for Beckhoff CX) " }, 
{ "title" : "Gateway perimetrali ", 
"url" : "_rtsl_product_overview.html#UUID-da861021-6b3f-718d-ac40-c1e7e9f72bd8_section-idm4544772720513633169577754493", 
"breadcrumbs" : "CODESYS Control \/ Panoramica del Prodotto \/ Gateway perimetrali ", 
"snippet" : "Il CODESYS Edge Gateway è un esteso CODESYS gateway che collega il CODESYS Automation Server insieme a CODESYS controllori in una rete locale. CODESYS Edge Gateway per Linux CODESYS Edge Gateway per Windows...", 
"body" : "Il CODESYS Edge Gateway è un esteso CODESYS gateway che collega il CODESYS Automation Server insieme a CODESYS controllori in una rete locale. CODESYS Edge Gateway per Linux CODESYS Edge Gateway per Windows " }, 
{ "title" : "Sistemi runtime basati su Linux ", 
"url" : "_rtsl_linux_runtime_systems.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Iniziare ", 
"url" : "_rtsl_first_steps.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare ", 
"snippet" : "In questo capitolo, imparerai come mettere in servizio un dispositivo con CODESYS Control Runtime SL, iniziate con un piccolo CODESYS applicazione e concedere in licenza il controller....", 
"body" : "In questo capitolo, imparerai come mettere in servizio un dispositivo con CODESYS Control Runtime SL, iniziate con un piccolo CODESYS applicazione e concedere in licenza il controller. " }, 
{ "title" : "Preparazione ", 
"url" : "_rtsl_preparation_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Preparazione ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Controller ", 
"url" : "_rtsl_preparation_linux.html#UUID-6cfdd13d-15e9-2ce9-6bfc-ddfaec59e7f5_section-idm234655601003053", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Preparazione \/ Controller ", 
"snippet" : "Requisito: sul controller deve essere installato un sistema operativo Linux aggiornato (ad esempio Debian o Ubuntu) e deve essere installato e attivato un server SSH. Per verificare se il server SSH è attivo, esegui il seguente comando sul controller: sudo systemctl status ssh Quando il server SSH è...", 
"body" : "Requisito: sul controller deve essere installato un sistema operativo Linux aggiornato (ad esempio Debian o Ubuntu) e deve essere installato e attivato un server SSH. Per verificare se il server SSH è attivo, esegui il seguente comando sul controller: sudo systemctl status ssh Quando il server SSH è attivo, l'output dovrebbe assomigliare a questo: ssh.service - OpenBSD Secure Shell server \n Loaded: loaded (\/lib\/systemd\/system\/ssh.service; enabled; preset: enabled) \n Active: active (running) since [...] \n Docs: man:sshd(8) \n man:sshd_config(5) \n Main PID: 741 (sshd) \n Tasks: 1 (limit: 18876) \n Memory: 10.4M \n CPU: 12.778s \n CGroup: \/system.slice\/ssh.service \n └─741 \"sshd: \/usr\/sbin\/sshd -D [listener] 0 of 10-100 startups\" Se il server SSH non è attivato, puoi attivare il server in modo permanente con il seguente comando: sudo systemctl enable ssh . Quindi controlla se il servizio è attivo come descritto sopra. Se vuoi usare CODESYS Virtual Control for Linux SL , deve essere installata anche una versione aggiornata del seguente software: Python 3 Docker o Podman Per istruzioni su come installare un Docker su Debian, vedere Installazione di un motore Docker su Debian . " }, 
{ "title" : "CODESYS Ambiente di sviluppo ", 
"url" : "_rtsl_preparation_linux.html#UUID-6cfdd13d-15e9-2ce9-6bfc-ddfaec59e7f5_section-idm234655602655537", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Preparazione \/ CODESYS Ambiente di sviluppo ", 
"snippet" : "Usa il CODESYS Installer per installare una versione aggiornata di CODESYS Development System e il CODESYS pacchetto per il controller in cui si desidera utilizzare il sistema di runtime. Sono necessari almeno i seguenti pacchetti: l CODESYS Control SL Deploy Tool CODESYS Control for<device> (exampl...", 
"body" : "Usa il CODESYS Installer per installare una versione aggiornata di CODESYS Development System e il CODESYS pacchetto per il controller in cui si desidera utilizzare il sistema di runtime. Sono necessari almeno i seguenti pacchetti: l CODESYS Control SL Deploy Tool CODESYS Control for<device> (example: CODESYS Control for Linux ARM ) " }, 
{ "title" : "Installazione del CODESYS Control for <device> SL pacchetto in CODESYS ", 
"url" : "_rtsl_preparation_linux.html#UUID-6cfdd13d-15e9-2ce9-6bfc-ddfaec59e7f5_section-idm43465561410290", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Preparazione \/ Installazione del CODESYS Control for <device> SL pacchetto in CODESYS ", 
"snippet" : "Avvia il CODESYS Development System . Fare clic Utensili → Installatore CODESYS . Le Installatore CODESYS si apre una finestra di dialogo. Sotto Componenti aggiuntivi , fai clic Sfoglia . Seleziona il pacchetto del prodotto runtime. Il pacchetto è installato: il pacchetto runtime, le librerie, le de...", 
"body" : "Avvia il CODESYS Development System . Fare clic Utensili → Installatore CODESYS . Le Installatore CODESYS si apre una finestra di dialogo. Sotto Componenti aggiuntivi , fai clic Sfoglia . Seleziona il pacchetto del prodotto runtime. Il pacchetto è installato: il pacchetto runtime, le librerie, le descrizioni dei dispositivi e i progetti di esempio vengono archiviati nel sistema di sviluppo. A seconda del prodotto, il pacchetto di sistema runtime è disponibile come file di sistema runtime Debian o IPK nella cartella ..\\Users\\<user name>\\CODESYS Control for <device> . " }, 
{ "title" : "Installazione del sistema operativo ", 
"url" : "_rtsl_linux_install_operating_system.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Preparazione \/ Installazione del sistema operativo ", 
"snippet" : "Per installare CODESYS Control for <device> SL sul tuo dispositivo o hardware, hai bisogno di un sistema operativo Linux. Prestare attenzione alle istruzioni specifiche del produttore. Installa il sistema operativo Linux sulla scheda di memoria del tuo dispositivo secondo la descrizione sulla homepa...", 
"body" : "Per installare CODESYS Control for <device> SL sul tuo dispositivo o hardware, hai bisogno di un sistema operativo Linux. Prestare attenzione alle istruzioni specifiche del produttore. Installa il sistema operativo Linux sulla scheda di memoria del tuo dispositivo secondo la descrizione sulla homepage del produttore. Il sistema operativo è installato sulla scheda di memoria. Avviare il dispositivo con la scheda di memoria. Il sistema operativo è in esecuzione ed è pronto per l'uso. " }, 
{ "title" : "Impostazioni specifiche del dispositivo ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm4599163518809633054177648631", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Preparazione \/ Installazione del sistema operativo \/ Impostazioni specifiche del dispositivo ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "BeagleBone ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417852438", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Preparazione \/ Installazione del sistema operativo \/ Impostazioni specifiche del dispositivo \/ BeagleBone ", 
"snippet" : "Se BeagleBone è collegato direttamente al sistema locale tramite un cavo USB, l'indirizzo IP predefinito è 192.168.7.2 ....", 
"body" : "Se BeagleBone è collegato direttamente al sistema locale tramite un cavo USB, l'indirizzo IP predefinito è 192.168.7.2 . " }, 
{ "title" : "PFC100\/200 ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417882662", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Preparazione \/ Installazione del sistema operativo \/ Impostazioni specifiche del dispositivo \/ PFC100\/200 ", 
"snippet" : "Assicurati che il controller WAGO sia acceso e connesso alla tua rete. Il cavo di rete che collega il controller al CODESYS la piattaforma di ingegneria deve essere inserita nella presa X1. La presa X2 viene utilizzata per i bus di campo. Quando si utilizza un bus di campo Ethernet, è necessario imp...", 
"body" : "Assicurati che il controller WAGO sia acceso e connesso alla tua rete. Il cavo di rete che collega il controller al CODESYS la piattaforma di ingegneria deve essere inserita nella presa X1. La presa X2 viene utilizzata per i bus di campo. Quando si utilizza un bus di campo Ethernet, è necessario impostare le interfacce Ethernet del PFC100\/200 su \"Separated\". Digita l'indirizzo IP del dispositivo nel tuo browser. Si apre la pagina \"Gestione basata sul Web\" per il dispositivo. Fai clic su Rete → TCP-IP comando di menu. Se ti viene richiesto di fornire i dati di accesso dell'utente, digita il nome utente admin e parola d'ordine wago . In Cambia configurazione , seleziona il Separato opzione e fare clic Invia per confermare. Chiudi il browser. Nota sulla gestione basata sul Web: La modifica della partizione attiva non è ancora possibile nella versione attuale di CODESYS Control for PFC100\/200 (voce di menu: \"Memoria di massa\"). Le informazioni sulla licenza contenute in Informazioni → Dettagli del controller → Informazioni sulla licenza la voce di menu si riferisce al controller WAGO preinstallato, non al CODESYS Control for PFC100\/200 . Le impostazioni per il firewall ( Tempo di esecuzione PLC e PLC WebVisu ) si riferiscono anche al controller WAGO preinstallato, non al CODESYS Control for PFC100\/200 . Se il firewall deve essere configurato per CODESYS Control for PFC100\/200 , i \"filtri utente\" possono essere utilizzati per la configurazione manuale. Informazioni sulla scheda di rete: Per i bus di campo basati su Ethernet, il runtime utilizza automaticamente la seconda interfaccia di rete (\"X2\" o \"br1\"). Le impostazioni nell'adattatore Ethernet e nel configuratore EtherCAT per l'interfaccia di rete utilizzata vengono sovrascritte. " }, 
{ "title" : "Raspberry Pi ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417928746", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Preparazione \/ Installazione del sistema operativo \/ Impostazioni specifiche del dispositivo \/ Raspberry Pi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Configurazione del Raspberry Pi ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm41652708964375", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Preparazione \/ Installazione del sistema operativo \/ Impostazioni specifiche del dispositivo \/ Raspberry Pi \/ Configurazione del Raspberry Pi ", 
"snippet" : "Esegui il sudo raspi-config comando in una console o tramite SSH (ad esempio, utilizzando il Putty attrezzo). Nota: a partire dalla versione 8 di Debian (\"Jessie\"), esiste anche un'interfaccia di configurazione grafica con le stesse impostazioni. Lo strumento di configurazione viene avviato. Selezio...", 
"body" : "Esegui il sudo raspi-config comando in una console o tramite SSH (ad esempio, utilizzando il Putty attrezzo). Nota: a partire dalla versione 8 di Debian (\"Jessie\"), esiste anche un'interfaccia di configurazione grafica con le stesse impostazioni. Lo strumento di configurazione viene avviato. Seleziona il 1 Expand Filesystem comando. Opzionale: Seleziona il 8 Advanced Options comando e specificare un nome univoco per il Raspberry Pi. Opzionale: Seleziona il 5 Enable Camera comando. La fotocamera è operativa. Uscire dallo strumento di configurazione e riavviare. " }, 
{ "title" : "Attivazione delle interfacce periferiche I²C, SPI e 1-Wire ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417928748", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Preparazione \/ Installazione del sistema operativo \/ Impostazioni specifiche del dispositivo \/ Raspberry Pi \/ Attivazione delle interfacce periferiche I²C, SPI e 1-Wire ", 
"snippet" : "Modifica il \/boot\/config.txt file con un editor di testo (ad esempio, utilizzando sudo nano \/boot\/config.txt ). Attenzione ai permessi. Controlla la tua configurazione e regolala se necessario. Le seguenti righe sono incluse (e non commentate con # ): dtparam=i2c_arm=on dtparam=spi=on dtoverlay=w1-g...", 
"body" : "Modifica il \/boot\/config.txt file con un editor di testo (ad esempio, utilizzando sudo nano \/boot\/config.txt ). Attenzione ai permessi. Controlla la tua configurazione e regolala se necessario. Le seguenti righe sono incluse (e non commentate con # ): dtparam=i2c_arm=on\ndtparam=spi=on\ndtoverlay=w1-gpio-pullup,pullup=1 Nota: le interfacce periferiche I²C, SPI e 1-Wire sono opzionali. " }, 
{ "title" : "Attivazione della fotocamera ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm46610835857494", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Preparazione \/ Installazione del sistema operativo \/ Impostazioni specifiche del dispositivo \/ Raspberry Pi \/ Attivazione della fotocamera ", 
"snippet" : "Esegui il sudo raspi-config comando in una console o tramite SSH (ad esempio, utilizzando il Putty attrezzo). Seleziona il 5 Enable Camera comando. Esegui i seguenti comandi: sudo apt-get update sudo apt-get dist-upgrade sudo rpi-update git clone https:\/\/github.com\/silvanmelchior\/RPi_Cam_Web_Interfa...", 
"body" : "Esegui il sudo raspi-config comando in una console o tramite SSH (ad esempio, utilizzando il Putty attrezzo). Seleziona il 5 Enable Camera comando. Esegui i seguenti comandi: sudo apt-get update\nsudo apt-get dist-upgrade\nsudo rpi-update\ngit clone https:\/\/github.com\/silvanmelchior\/RPi_Cam_Web_Interface.git\ncd RPi_Cam_Web_Interface\nchmod u+x RPi_Cam_Web_Interface_Installer.sh\n.\/RPi_Cam_Web_Interface_Installer.sh install Avvia un browser Web e apri http:\/\/<network address> . Se l'installazione ha esito positivo, verrà caricata l'interfaccia utente di RPi Cam Control e sarà possibile utilizzare la videocamera. " }, 
{ "title" : "Stabilire una connessione ", 
"url" : "_rtsl_establish_connection_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Stabilire una connessione ", 
"snippet" : "Requisito: il sistema operativo è già installato sul controller. In caso contrario, segui i passaggi indicati in Installazione del sistema operativo capitolo. Le seguenti istruzioni descrivono come determinare l'indirizzo di rete del dispositivo Linux per connettere il Deploy Tool al dispositivo....", 
"body" : "Requisito: il sistema operativo è già installato sul controller. In caso contrario, segui i passaggi indicati in Installazione del sistema operativo capitolo. Le seguenti istruzioni descrivono come determinare l'indirizzo di rete del dispositivo Linux per connettere il Deploy Tool al dispositivo. " }, 
{ "title" : "Rilevamento dell'indirizzo di rete ", 
"url" : "_rtsl_establish_connection_linux.html#UUID-8282f374-6dd3-23b6-eb03-311464e44f1b_section-idm43466295058734", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Stabilire una connessione \/ Rilevamento dell'indirizzo di rete ", 
"snippet" : "Rilevamento dell'indirizzo di rete con CODESYS sulla rete Inizio CODESYS . Fai clic su Utensili → Implementa Control SL comando. Le Comunicazione la vista si apre. Accanto a Port <port> , fare clic sul pulsante Scan . Le Dispositivi disponibili la finestra di dialogo elenca gli indirizzi IP dei disp...", 
"body" : "Rilevamento dell'indirizzo di rete con CODESYS sulla rete Inizio CODESYS . Fai clic su Utensili → Implementa Control SL comando. Le Comunicazione la vista si apre. Accanto a Port <port> , fare clic sul pulsante Scan . Le Dispositivi disponibili la finestra di dialogo elenca gli indirizzi IP dei dispositivi disponibili nella rete. Identifica il tuo dispositivo. Rilevamento dell'indirizzo di rete con il dispositivo Requisito: il dispositivo dispone di una connessione per tastiera, mouse e monitor. Effettua il login Apri una console ed esegui ip a s comando. Viene restituito l'indirizzo di rete. Rilevamento dell'indirizzo di rete con Windows sulla rete Requisito: il dispositivo ha un nome noto e univoco nella rete (esempio: «BeagleBoneBlack»). Aprire un prompt dei comandi di Windows. Esegui il ping comando sul nome del dispositivo (impostazione predefinita: BeagleBoneBlack). Viene restituito l'indirizzo di rete. Il passaggio successivo consiste nell'installare il sistema runtime sul controller. " }, 
{ "title" : "Connessione al sistema di destinazione ", 
"url" : "_rtsl_establish_connection_linux.html#UUID-8282f374-6dd3-23b6-eb03-311464e44f1b_section-idm43466297829590", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Stabilire una connessione \/ Connessione al sistema di destinazione ", 
"snippet" : "La connessione al sistema di destinazione è il requisito per la successiva installazione di immagini e pacchetti, nonché per la creazione e la gestione delle istanze. Fai clic su Utensili → Implementa Control SL comando. Le Implementa Control SL l'oggetto si apre. Sul Comunicazione scheda, configura...", 
"body" : "La connessione al sistema di destinazione è il requisito per la successiva installazione di immagini e pacchetti, nonché per la creazione e la gestione delle istanze. Fai clic su Utensili → Implementa Control SL comando. Le Implementa Control SL l'oggetto si apre. Sul Comunicazione scheda, configura le impostazioni di connessione al dispositivo di destinazione. Specifica l'indirizzo IP del sistema di destinazione o fai prima clic su Scansiona pulsante per visualizzare tutti gli indirizzi IP disponibili sulla rete. Quindi specificare la porta. I seguenti metodi sono supportati per l'accesso al sistema di destinazione: Credenziali: nome utente e password Autenticazione basata su chiave. Per ulteriori informazioni, consulta Connessione con autenticazione a chiave pubblica" }, 
{ "title" : "Credenziali predefinite dei dispositivi ", 
"url" : "_rtsl_establish_connection_linux.html#UUID-8282f374-6dd3-23b6-eb03-311464e44f1b_section-idm43466298221944", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Stabilire una connessione \/ Credenziali predefinite dei dispositivi ", 
"snippet" : "Le credenziali predefinite sono elencate qui. Se riscontri un problema, controlla nella home page del produttore le credenziali del dispositivo in Utente Password Raspberry PI pi raspberry Beagle Bone root Vuoto IOT2000 Credenziali configurate del dispositivo PFC 100\/200 root wago PLC successivo adm...", 
"body" : "Le credenziali predefinite sono elencate qui. Se riscontri un problema, controlla nella home page del produttore le credenziali del dispositivo in Utente Password Raspberry PI pi raspberry Beagle Bone root Vuoto IOT2000 Credenziali configurate del dispositivo PFC 100\/200 root wago PLC successivo admin Stampato sul controller WAGO TP600 root wago EMPC-A-IMX6 Credenziali configurate del dispositivo " }, 
{ "title" : "Installazione del runtime sul controller ", 
"url" : "_rtsl_install_runtime_on_controller.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Installazione del runtime sul controller ", 
"snippet" : "Requisito: Le Utensili → Implementa Control SL il comando è stato eseguito e la connessione al dispositivo è stata stabilita. In caso contrario, segui i passaggi indicati in Stabilire una connessione capitolo. L'add-on per il controller desiderato (esempio: CODESYS Control for Linux ARM64 ) è instal...", 
"body" : "Requisito: Le Utensili → Implementa Control SL il comando è stato eseguito e la connessione al dispositivo è stata stabilita. In caso contrario, segui i passaggi indicati in Stabilire una connessione capitolo. L'add-on per il controller desiderato (esempio: CODESYS Control for Linux ARM64 ) è installato nel CODESYS Development System . " }, 
{ "title" : "Controller basati su pacchetti ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm234664620258912", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Installazione del runtime sul controller \/ Controller basati su pacchetti ", 
"snippet" : "Le seguenti istruzioni descrivono come installare il sistema runtime sul dispositivo Linux. Aprire il Distribuzione scheda. Nel Prodotto casella di riepilogo, seleziona il prodotto desiderato. Nel Versione casella di riepilogo, seleziona la versione desiderata. Fai clic su Installa pulsante. Il sist...", 
"body" : "Le seguenti istruzioni descrivono come installare il sistema runtime sul dispositivo Linux. Aprire il Distribuzione scheda. Nel Prodotto casella di riepilogo, seleziona il prodotto desiderato. Nel Versione casella di riepilogo, seleziona la versione desiderata. Fai clic su Installa pulsante. Il sistema runtime selezionato viene installato sul dispositivo. Il controller viene riavviato automaticamente. Non è richiesto un riavvio manuale Per disinstallare un pacchetto, procedi come segue: Nel Pacchetti installati sezione, seleziona la voce corrispondente. Arresta il controller se è in esecuzione e fai clic su pulsante. Nella finestra di dialogo successiva, fai clic su Sì . Il pacchetto è stato disinstallato. Verificare l'installazione testando il progetto di esempio incluso nel CODESYS pacchetto. " }, 
{ "title" : "Controller basati su container ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm234664621921259", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Installazione del runtime sul controller \/ Controller basati su container ", 
"snippet" : "I passaggi seguenti mostrano come gestire immagini e istanze....", 
"body" : "I passaggi seguenti mostrano come gestire immagini e istanze. " }, 
{ "title" : "Gestione delle immagini ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm43466462476384", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Installazione del runtime sul controller \/ Controller basati su container \/ Gestione delle immagini ", 
"snippet" : "Per la configurazione di un prodotto virtuale (ad esempio, un'istanza di runtime o un'istanza gateway), deve esistere un'immagine corrispondente sul dispositivo di destinazione. Quando si installa CODESYS Virtual Control for Linux SL , le immagini vengono copiate nella directory C:\\Users\\<user>\\CODE...", 
"body" : "Per la configurazione di un prodotto virtuale (ad esempio, un'istanza di runtime o un'istanza gateway), deve esistere un'immagine corrispondente sul dispositivo di destinazione. Quando si installa CODESYS Virtual Control for Linux SL , le immagini vengono copiate nella directory C:\\Users\\<user>\\CODESYS Virtual Control for Linux SL\\Delivery\\ come archivio con estensione .tar.gz . Installing an image Aprire il Distribuzione scheda. Nel Prodotto casella di riepilogo, seleziona il prodotto virtuale desiderato. Nel Versione casella di riepilogo, seleziona la versione desiderata. Fai clic su Installa pulsante. L'immagine viene trasferita al sistema di destinazione ed elencata nella Immagini installate sezione. A differenza dei prodotti non virtuali, non esiste un avvio automatico. Per i prodotti virtuali, è necessario prima creare un'istanza su Operazione scheda. Eliminazione di un'immagine dal sistema di destinazione Sul Distribuzione scheda, nella Gestire le immagini area, seleziona l'immagine corrispondente e fai clic su pulsante e quindi seleziona Elimina comando. Quando un'immagine viene utilizzata da un'istanza, non può essere eliminata. " }, 
{ "title" : "Gestione delle istanze virtuali ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm43466462511166", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Installazione del runtime sul controller \/ Controller basati su container \/ Gestione delle istanze virtuali ", 
"snippet" : "Le istanze sul sistema di destinazione sono gestite su Operazione scheda. Alcuni valori della configurazione non possono essere modificati. La configurazione non può essere modificata per le istanze in esecuzione. Creazione e configurazione di una nuova istanza Fai clic su pulsante. Le Aggiungi nuov...", 
"body" : "Le istanze sul sistema di destinazione sono gestite su Operazione scheda. Alcuni valori della configurazione non possono essere modificati. La configurazione non può essere modificata per le istanze in esecuzione. Creazione e configurazione di una nuova istanza Fai clic su pulsante. Le Aggiungi nuova istanza si apre la finestra di dialogo. Nel Nome , specificare un nome univoco. Il nome può essere composto solo da caratteri alfanumerici e dai caratteri .-_ . Tuttavia, i personaggi .-_ non deve essere all'inizio. Facoltativo: nel Filtro casella di riepilogo, seleziona il tipo di immagine (esempio: Runtime System o Gateway ). L'elenco delle immagini disponibili viene ridotto alle immagini del tipo selezionato. Quindi seleziona il corrispondente Immagine . Quindi fai clic su OK . La nuova istanza viene visualizzata nella vPLC sezione. Seleziona l'istanza per configurare l'istanza appena creata. Le impostazioni per l'istanza selezionata vengono visualizzate a destra nel Impostazioni sezione. In questa sezione, puoi visualizzare e modificare tutte le impostazioni di questa istanza. Per ulteriori informazioni, vedere: Configurazione: Eliminazione di un'istanza Nota: le istanze avviate non possono essere eliminate. Sul Operazione scheda, seleziona l'istanza. Fai clic su pulsante e seleziona Elimina selezionati comando. L'istanza selezionata, la configurazione e il progetto di avvio dell'istanza vengono eliminati. Le Epurazione il comando arresta ed elimina tutte le istanze, le configurazioni e qualsiasi CODESYS immagini presenti sul dispositivo di destinazione. " }, 
{ "title" : "Avvio del sistema runtime ", 
"url" : "_rtsl_start_runtime.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Avvio del sistema runtime ", 
"snippet" : "Nota : Una licenza valida deve essere installata sul tuo PC per far funzionare il sistema runtime. In caso contrario, il controller si avvia in modalità demo completamente funzionante, ma a tempo limitato. Nel caso dei sistemi runtime si tratta di licenze dispositivo. Attivate queste licenze nel Lic...", 
"body" : "Nota : Una licenza valida deve essere installata sul tuo PC per far funzionare il sistema runtime. In caso contrario, il controller si avvia in modalità demo completamente funzionante, ma a tempo limitato. Nel caso dei sistemi runtime si tratta di licenze dispositivo. Attivate queste licenze nel License Manager. Per ulteriori informazioni, vedere: Licenza dei prodotti Fai clic su Utensili → Implementa Control SL comando. Le Implementa Control SL le schede si aprono. Seleziona il Operazione scheda e seleziona la voce desiderata. È possibile selezionare una sola voce. Fai clic su Avvia selezionato comando. Il controller viene avviato e gli elenchi vengono aggiornati per mostrare il nuovo stato. Per includere un'istanza del gateway nel CODESYS Automation Server , l'istanza del gateway può essere avviata in modalità manutenzione. Se hai configurato correttamente le istanze di CODESYS Virtual Control for Linux SL , ora puoi connetterti a questa istanza. Per ulteriori informazioni, consulta: Stabilire una connessione a un'istanza. " }, 
{ "title" : "Scaricare e avviare il file CODESYS Applicazione sul controller ", 
"url" : "_rtsl_load_and_start_application.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Scaricare e avviare il file CODESYS Applicazione sul controller ", 
"snippet" : "Nota per CODESYS Virtual Control for Linux SL Requisito: esiste un'istanza in esecuzione di un «Virtual Edge Gateway». A tale scopo, installa un'immagine corrente di CODESYS Virtual Edge Gateway for Linux , crea una nuova istanza e avviala. Per ulteriori informazioni, vedere: Installazione del runti...", 
"body" : "Nota per CODESYS Virtual Control for Linux SL Requisito: esiste un'istanza in esecuzione di un «Virtual Edge Gateway». A tale scopo, installa un'immagine corrente di CODESYS Virtual Edge Gateway for Linux , crea una nuova istanza e avviala. Per ulteriori informazioni, vedere: Installazione del runtime sul controller: controller virtuali In CODESYS , creare un progetto standard: fare clic su File → Nuovo progetto . Nel Nuovo progetto finestra di dialogo, selezionare il Progetto standard modello e specificare un nome e una posizione. Poi nel Progetto Standard finestra di dialogo, selezionare il rispettivo controller. Nell'albero dei dispositivi ( Dispositivi view) del nuovo progetto, ora c'è una voce per il controller ( Dispositivo (...) ) e sotto di essa un'applicazione con un POU ( PLC_PRG (PRG) e un compito Compito principale che chiama PLC_PRG). In PLC_PRG , scrivere un programma semplice (ad esempio un contatore). PROGRAM PLC_PRG\nVAR\n iCount: INT;\nEND_VAR\n\niCount := iCount+1; Stabilire una connessione al controller. Per fare questo, usa il Impostazioni di comunicazione scheda dell'editor del dispositivo. Puoi aprirlo facendo doppio clic su Dispositivo (...) voce nella struttura ad albero dei dispositivi. Normalmente, il gateway è già attivo ora. In caso contrario, controllate lo stato e avviate esplicitamente il gateway, se necessario. Quindi, sul Comunicazione scheda, fai clic su Scansione della rete comando. Le Seleziona dispositivo si apre una finestra di dialogo con i dispositivi rilevati. Se il controller non viene trovato, assicurati che sia stato installato e avviato correttamente. Selezionare il controller rilevato e fare clic OK . Se il controller non viene trovato, controllare quanto segue: Sul Impostazioni di comunicazione scheda, nel Dispositivo → Opzioni menu, disabilitare il Filtra le scansioni di rete in base all'ID di destinazione opzione. Se il tuo dispositivo viene visualizzato ora, allora hai un errore errato TargetID . Il tuo componente SysTargetOEM potrebbe non essere stato caricato correttamente. Il tuo dispositivo è connesso alla tua rete? Per impostazione predefinita, la comunicazione con il tuo dispositivo avviene tramite UDP. Quando utilizzi questo metodo di comunicazione, il tuo dispositivo deve trovarsi nella stessa sottorete del tuo host. Entrambi i dispositivi richiedono la stessa identica maschera di rete configurata. All'avvio è possibile verificare le impostazioni di rete per i messaggi del sistema runtime. Ad esempio, dovrebbero essere i seguenti: 1287759127: Cmp=CmpBlkDrvUdp, Class=1, Error=0, Info=6, pszInfo=Network interface: <ipaddress>192.168.101.41<\/ipaddress> <subnetmask>255.255.252.0<\/subnetmask> CODESYS tenta di autenticarsi su questo sistema di destinazione e ottenere un canale di comunicazione. La connessione è stabilita. Fai clic su Online → Accedi comando. Si apre la finestra di dialogo per confermare il download dell'applicazione. Eseguire il download e avviare l'applicazione. L'applicazione viene elaborata sul tuo dispositivo. Nel PLC_PRG programma, verificare se il contatore è in esecuzione o meno. " }, 
{ "title" : "Autorizzazione del Titolare ", 
"url" : "_rtsl_license_controller_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Autorizzazione del Titolare ", 
"snippet" : "Casi d'uso per la licenza di CODESYS Control prodotti di esecuzione: Licenza locale La licenza per gestire il CODESYS Control prodotto si trova sul dispositivo stesso. Licenza di rete La licenza per gestire il CODESYS Control il prodotto si trova su un dispositivo in rete. Più controllori possono co...", 
"body" : "Casi d'uso per la licenza di CODESYS Control prodotti di esecuzione: Licenza locale La licenza per gestire il CODESYS Control prodotto si trova sul dispositivo stesso. Licenza di rete La licenza per gestire il CODESYS Control il prodotto si trova su un dispositivo in rete. Più controllori possono contattare questo dispositivo centrale per ottenere un CODESYS licenza. IL CODESYS Network License Server per questo è necessario il prodotto. Attualmente, solo le licenze di rete possono essere utilizzate per CODESYS Virtual Control SL . A tale scopo, l'indirizzo IP del server di licenza deve essere configurato nel Server di licenza campo nella rispettiva istanza. " }, 
{ "title" : "Acquisizione licenze ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234389354567343", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Autorizzazione del Titolare \/ Acquisizione licenze ", 
"snippet" : "Puoi scaricare il CODESYS Control prodotto da Negozio CODESYS internazionale O Negozio CODESYS Nord America ....", 
"body" : "Puoi scaricare il CODESYS Control prodotto da Negozio CODESYS internazionale O Negozio CODESYS Nord America . " }, 
{ "title" : "Licenza locale ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm4588328499004833054120306755", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Autorizzazione del Titolare \/ Licenza locale ", 
"snippet" : "La licenza può essere installata su un dongle USB o su un soft container. Quando si utilizza il contenitore software, la licenza è bloccata sul dispositivo durante l'attivazione e può essere attivata o ripristinata solo su questo dispositivo. Requisiti: Il sistema di sviluppo con CODESYS Development...", 
"body" : "La licenza può essere installata su un dongle USB o su un soft container. Quando si utilizza il contenitore software, la licenza è bloccata sul dispositivo durante l'attivazione e può essere attivata o ripristinata solo su questo dispositivo. Requisiti: Il sistema di sviluppo con CODESYS Development System disponga di accesso a Internet e sia connesso al dispositivo. Aprire CODESYS . Crea un progetto standard. Aggiorna il dispositivo nella struttura dei dispositivi. Clic Strumenti → Gestore licenze per aprire il CODESYS Gestore delle licenze. Selezionare Dispositivo nella procedura guidata, quindi selezionare Dongle o Contenitore morbido , a seconda del dispositivo. IL Seleziona dispositivo si apre la finestra di dialogo. Seleziona il rispettivo dispositivo. IL Gestore delle licenze si apre la finestra di dialogo. Contenitore mostra il nome del contenitore morbido o della chiave di sicurezza sul dispositivo. Non c'è ancora una voce per il rispettivo dispositivo nel file Prodotti finestra. Seleziona il Installa le licenze azione in basso a sinistra. Il Installa licenze su <dispositivo di destinazione> <nome contenitore> – Seleziona Operazione inizia la procedura guidata. Seleziona il Attiva licenza opzione. Specificare la ID biglietto e clicca Prossimo . La licenza è attivata. " }, 
{ "title" : "Licenza di rete ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234367072936383", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Autorizzazione del Titolare \/ Licenza di rete ", 
"snippet" : "IL CODESYS Network License Server il prodotto consente la licenza di rete per CODESYS prodotti, ad esempio quelli basati su Linux CODESYS Control Runtime SL da CODESYS Store International . IL CODESYS Network License Server si basa sul runtime WIBU CodeMeter in modalità di rete e fornisce il support...", 
"body" : "IL CODESYS Network License Server il prodotto consente la licenza di rete per CODESYS prodotti, ad esempio quelli basati su Linux CODESYS Control Runtime SL da CODESYS Store International . IL CODESYS Network License Server si basa sul runtime WIBU CodeMeter in modalità di rete e fornisce il supporto per il framework di gestione basato sul web \"Cockpit\" (vedi: https:\/\/cockpit-project.org\/) . Per utilizzare il server delle licenze di rete, è necessario innanzitutto utilizzare CODESYS Installer per installare CODESYS Network License Server componente aggiuntivo. Quindi è possibile installare il prodotto sul dispositivo utilizzando Distribuzione scheda. Per ulteriori informazioni, vedere: Scheda: Distribuzione. " }, 
{ "title" : "Caratteristiche delle licenze di rete ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234373994123211", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Autorizzazione del Titolare \/ Licenza di rete \/ Caratteristiche delle licenze di rete ", 
"snippet" : "IL Installare il comando installa il file CODESYS Network License Server (incluso WIBU CodeMeter Runtime). Se il framework Cockpit non è ancora installato sul sistema di destinazione, viene visualizzato il seguente messaggio: Se il framework Cockpit è già stato installato sul sistema di destinazione...", 
"body" : "IL Installare il comando installa il file CODESYS Network License Server (incluso WIBU CodeMeter Runtime). Se il framework Cockpit non è ancora installato sul sistema di destinazione, viene visualizzato il seguente messaggio: Se il framework Cockpit è già stato installato sul sistema di destinazione, solo il file CODESYS I plugin del Cockpit sono installati per funzionare CODESYS Network License Server . IL Inizio E Fermare i comandi sono disabilitati perché non è necessario arrestare o avviare il servizio. IL Pozzetto aperto Il comando apre la gestione basata sul Web del dispositivo Linux nel browser predefinito. " }, 
{ "title" : "Attivazione della licenza di rete ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234373989651141", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Autorizzazione del Titolare \/ Licenza di rete \/ Attivazione della licenza di rete ", 
"snippet" : "Per attivare un ticket di licenza sul CODESYS Network License Server , procedi come segue: Clicca il Pozzetto aperto Il pulsante apre la gestione basata sul web nel browser Usa il normale login Linux per questo. Clicca il CODESYS WBM (1)→ Licenza CODESYS (2) pulsanti. Copia il numero di serie (1). I...", 
"body" : "Per attivare un ticket di licenza sul CODESYS Network License Server , procedi come segue: Clicca il Pozzetto aperto Il pulsante apre la gestione basata sul web nel browser Usa il normale login Linux per questo. Clicca il CODESYS WBM (1)→ Licenza CODESYS (2) pulsanti. Copia il numero di serie (1). Immettere il numero di serie nel Numero di serie (2) campo. Inserisci il numero del biglietto nel Biglietto campo (3). Clicca il ATTIVA IL BIGLIETTO pulsante. In fondo alla pagina, controlla nella panoramica per vedere che gli articoli e i codici prodotto desiderati (come parte del ticket) sono stati installati sul server delle licenze di rete. Per impostazione predefinita, CODESYS Network License Server pacchetto crea un contenitore di licenze in cui è possibile installare una licenza. Se desideri creare un nuovo contenitore, procedi come segue: Copia il *.WibuCmLif file da CODESYS Network License Server al tuo computer (ad esempio, utilizzando un client SSH o SCP). Nella gestione basata sul Web, fare clic su Navigare pulsante in Crea un nuovo contenitore sezione e seleziona il file che hai salvato in precedenza. Clicca il CREARE pulsante. Nella parte inferiore della pagina, controlla la panoramica per vedere che il nuovo contenitore è stato creato. In caso di errore, è possibile trovare ulteriori informazioni su Registri pagina. " }, 
{ "title" : "Utilizzo della licenza di rete ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234460444116218", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Autorizzazione del Titolare \/ Licenza di rete \/ Utilizzo della licenza di rete ", 
"snippet" : "Affinché il controller possa utilizzare il server di licenza configurato in precedenza, questo deve essere inserito nella configurazione. Per fare ciò, le seguenti impostazioni devono essere aggiunte al [CmpCodeMeter] sezione nella \/etc\/codesyscontrol\/CODESYSControl_User.cfg file: EnableNetLicenses=...", 
"body" : "Affinché il controller possa utilizzare il server di licenza configurato in precedenza, questo deve essere inserito nella configurazione. Per fare ciò, le seguenti impostazioni devono essere aggiunte al [CmpCodeMeter] sezione nella \/etc\/codesyscontrol\/CODESYSControl_User.cfg file: EnableNetLicenses=1\nLicenseServer.1=<IP1>\nLicenseServer.2=<IP2> " }, 
{ "title" : "Backup e ripristino CODESYS Licenze ", 
"url" : "_rtsl_backup_restore_wibu.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Backup e ripristino CODESYS Licenze ", 
"snippet" : "Queste istruzioni non si applicano ai prodotti di CODESYS Virtual Control SL famiglia di prodotti....", 
"body" : "Queste istruzioni non si applicano ai prodotti di CODESYS Virtual Control SL famiglia di prodotti. " }, 
{ "title" : "Licenze per Codemeter Embedded ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4622936815712034049201310732", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Embedded ", 
"snippet" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ Licenza di backup e ripristino...", 
"body" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ Licenza di backup e ripristino " }, 
{ "title" : "Backup di una licenza ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4641146992569634049209836102", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Embedded \/ Backup di una licenza ", 
"snippet" : "Stabilire una connessione da CODESYS al tuo controllore. Nella struttura dei dispositivi, seleziona il controller e apri il file File scheda. Nella finestra sul lato destro, fare clic sull'icona di aggiornamento ( ). Vengono visualizzati i file disponibili sul controller. Nella finestra sul lato sin...", 
"body" : "Stabilire una connessione da CODESYS al tuo controllore. Nella struttura dei dispositivi, seleziona il controller e apri il file File scheda. Nella finestra sul lato destro, fare clic sull'icona di aggiornamento ( ). Vengono visualizzati i file disponibili sul controller. Nella finestra sul lato sinistro, seleziona la directory in cui desideri archiviare il backup. Nella finestra sul lato destro, seleziona il cmact_licenses directory e fare clic su pulsante. Sul tuo computer viene creata una copia di backup della directory delle licenze. Verificare che la copia di backup sia stata creata correttamente. " }, 
{ "title" : "Ripristino di una licenza ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm451020213344483404921010438", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Embedded \/ Ripristino di una licenza ", 
"snippet" : "Si noti che è possibile la perdita di dati quando si eseguono le seguenti istruzioni al passaggio 6. Pertanto, leggere attentamente queste istruzioni. Stabilire una connessione da CODESYS al tuo controllore. Nella struttura dei dispositivi, seleziona il controller e apri il file File scheda. Nella f...", 
"body" : "Si noti che è possibile la perdita di dati quando si eseguono le seguenti istruzioni al passaggio 6. Pertanto, leggere attentamente queste istruzioni. Stabilire una connessione da CODESYS al tuo controllore. Nella struttura dei dispositivi, seleziona il controller e apri il file File scheda. Nella finestra sul lato destro, fare clic sull'icona di aggiornamento ( ). Vengono visualizzati i file disponibili sul controller. Nella finestra sul lato destro, seleziona la directory di destinazione. Questa deve essere la directory di livello superiore ( posizione di archiviazione : \/ ) Nella finestra sul lato sinistro, seleziona la copia di backup precedentemente creata sul tuo computer e clicca su pulsante. La copia di backup viene copiata sul controller. Se esiste già una directory con lo stesso nome, ti verrà richiesto di sovrascrivere tutti i file in essa contenuti. Attenzione: se si seleziona \"Sì\", tutti i file con lo stesso nome della directory di backup verranno rimossi dalla directory esistente. Lo stesso nome non significa necessariamente che i contenuti siano identici. Pertanto, assicurati di non sovrascrivere accidentalmente i file di cui hai bisogno. Riavviare il controller dopo che la copia di backup è stata trasferita con successo. " }, 
{ "title" : "Licenze per Codemeter Runtime ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4592433740225634049202010617", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Runtime ", 
"snippet" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL...", 
"body" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL " }, 
{ "title" : "Backup di una licenza ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4582704430054434049230836628", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Runtime \/ Backup di una licenza ", 
"snippet" : "Quando si utilizza CodeMeter Runtime, non è necessario creare un backup....", 
"body" : "Quando si utilizza CodeMeter Runtime, non è necessario creare un backup. " }, 
{ "title" : "Ripristino di una licenza ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4548752769854434049231197546", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Runtime \/ Ripristino di una licenza ", 
"snippet" : "Ripristina licenza Creazione di un file di richiesta di licenza Nel CODESYS , apri il License Manager. Nelle due finestre di dialogo seguenti selezionare Dispositivo E Contenitore morbido . Stabilire una connessione da CODESYS al controller su cui desideri ripristinare la licenza. Clic Installa lice...", 
"body" : " Ripristina licenza Creazione di un file di richiesta di licenza Nel CODESYS , apri il License Manager. Nelle due finestre di dialogo seguenti selezionare Dispositivo E Contenitore morbido . Stabilire una connessione da CODESYS al controller su cui desideri ripristinare la licenza. Clic Installa licenze , Selezionare Richiedi licenza e fare clic Prossimo . Se il Fornitore di software il campo è vuoto, quindi puoi usare il codice aziendale. Le modalità di recupero del codice aziendale sono descritte nella sezione «Recupero di un codice aziendale Seleziona il contenitore in cui deve essere installata la licenza e seleziona il percorso in cui il file di richiesta di licenza deve essere salvato sul tuo computer. Clic Fine . Download del file di aggiornamento della licenza Apri il WebDepot centrale licenze e specifica l'ID del ticket che desideri ripristinare. Clic Prossimo . Clic Ripristina licenze . In basso a destra, fai clic su Trasferimento della licenza basato su file . (Se la pagina dice Trasferimento diretto della licenza , allora sei già sulla pagina corretta). Caricare il file di richiesta di licenza creato in precedenza e fare clic su Carica la richiesta e continua ora . Clic Scarica subito il file di aggiornamento della licenza e salva il file sul tuo computer. Installazione di un aggiornamento della licenza Nel CODESYS , apri il License Manager. Nelle due finestre di dialogo seguenti selezionare Dispositivo E Contenitore morbido . Stabilire una connessione da CODESYS al controller su cui desideri ripristinare la licenza. Clic Installa licenze , Selezionare Installa licenza e fare clic Prossimo . Seleziona il contenitore in cui desideri installare la licenza e seleziona il file di aggiornamento precedentemente scaricato (estensione: .WibuCmRaU ). Clic Fine . Dopo alcuni secondi, la licenza verrà visualizzata nel Gestore licenze. " }, 
{ "title" : "Recupero di un codice aziendale ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4641146913656034049243306333", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Runtime \/ Recupero di un codice aziendale ", 
"snippet" : "Apri il WebDepot centrale licenze e specifica l'ID del ticket che desideri ripristinare. Clic Prossimo . Clic Ripristina licenze . In basso a destra, fai clic su Trasferimento della licenza basato su file . Copia il codice azienda come previsto al primo punto....", 
"body" : "Apri il WebDepot centrale licenze e specifica l'ID del ticket che desideri ripristinare. Clic Prossimo . Clic Ripristina licenze . In basso a destra, fai clic su Trasferimento della licenza basato su file . Copia il codice azienda come previsto al primo punto. " }, 
{ "title" : "Configura ed estendi ", 
"url" : "_rtsl_configure_and_extend.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Control Extension Package ", 
"url" : "_rtsl_extension.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_rtsl_extension_overview.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Panoramica ", 
"snippet" : "IL CODESYS Control Extension Package fornisce molte diverse opzioni e interfacce per connettere i propri programmi al sistema di runtime Linux e all'applicazione IEC. Ciò consente, ad esempio, di controllare il PLC, rispondere agli eventi dal PLC o aggiungere le proprie funzionalità al PLC o all'app...", 
"body" : "IL CODESYS Control Extension Package fornisce molte diverse opzioni e interfacce per connettere i propri programmi al sistema di runtime Linux e all'applicazione IEC. Ciò consente, ad esempio, di controllare il PLC, rispondere agli eventi dal PLC o aggiungere le proprie funzionalità al PLC o all'applicazione IEC. Vedi sotto per una panoramica delle interfacce e delle funzionalità più importanti. Nota: \"Dall'esterno del PLC\" significa ancora che sei sul sistema Linux. Le interfacce sono disponibili solo sul sistema Linux e non su un altro dispositivo, ma comunque al di fuori del processo di sistema di runtime. Attività evento esterno: È possibile controllare autonomamente il tempo di esecuzione di un task IEC (dall'esterno del PLC). Meccanismo di eventi: È possibile reagire all'esterno del PLC agli eventi dell'applicazione IEC (esempio: avvio\/arresto\/eccezione). Accesso alla shell del PLC: È possibile accedere alla shell del PLC al di fuori del PLC. Interruttore START\/STOP: È possibile collegare il proprio interruttore di avvio\/arresto (al di fuori del PLC) in modi molto semplici. Chiamare una funzione esterna: È possibile richiamare molto facilmente la propria funzionalità implementata al di fuori del PLC. Collegamento dei propri I\/O: È possibile collegare facilmente i propri I\/O (esempio: locale) al di fuori del PLC. SDK di estensione: È possibile implementare molto facilmente le proprie funzioni in codice C, che possono quindi essere utilizzate dall'applicazione IEC. Conserva i dati nella memoria condivisa: è possibile collegare i dati Retain dall'applicazione tramite SHM nel controller. Per una panoramica delle misure di sicurezza adottate e degli avvisi rilevanti per la sicurezza, vedere: Meccanismi di sicurezza. Questi nuovi meccanismi e interfacce sono in gran parte basati sulla separazione dei processi che si basano su risorse standard di Linux (file, socket o simili). Tra le altre cose, vengono utilizzati \" socket di dominio unix\" e quindi un \"terminale remoto\" può essere implementato indipendentemente dalla tecnologia (Python, C, e così via). Il collegamento del proprio codice C (Extension SDK) è un'eccezione perché il codice C qui compilato sotto forma di un componente di sistema dinamico di runtime (oggetto condiviso) viene aggiunto direttamente al CODESYS sistema di runtime ed eseguito. Per ulteriori informazioni, vedere: SDK di estensione . Gli esempi si trovano nella directory di installazione del programma CODESYS Control Extension Package . Per impostazione predefinita, questa è: C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\Examples . " }, 
{ "title" : "Meccanismi di sicurezza ", 
"url" : "_rtsl_extension_security.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Meccanismi di sicurezza ", 
"snippet" : "L'API di estensione fornisce opzioni complete per influenzare il sistema di runtime. Di conseguenza, l'utente deve prestare attenzione alle misure di sicurezza necessarie. Per CODESYS Control Extension Package 4.4.0.0 e versioni successive, il codesysuser il gruppo viene creato al momento dell'insta...", 
"body" : "L'API di estensione fornisce opzioni complete per influenzare il sistema di runtime. Di conseguenza, l'utente deve prestare attenzione alle misure di sicurezza necessarie. Per CODESYS Control Extension Package 4.4.0.0 e versioni successive, il codesysuser il gruppo viene creato al momento dell'installazione del pacchetto. Alcune funzioni dell'API di estensione richiedono che l'utente Linux che le utilizza sia un membro del codesysuser gruppo. Puoi aggiungere un utente a questo gruppo con privilegi di amministratore il seguente comando (come esempio): $ sudo adduser $USER codesysuser Il motivo alla base di questo metodo è che i meccanismi utilizzano il \/var\/run\/codesysextension\/ e \/var\/opt\/codesysextension\/ directory di lavoro. Questi hanno il permesso 770 e sono assegnati al codesysuser gruppo. Ciò garantisce che utenti non autorizzati non possano interferire con il sistema di runtime. Tutti i membri del codesysuser gruppo può influenzare il sistema di runtime. I seguenti meccanismi sono basati su un Unix Domain Socket (UDS): Attività evento esterno Meccanismo di eventi Accesso alla shell del PLC Chiamare una funzione esterna Collegamento dei propri I\/O È necessario che il programmatore IEC interroghi i codici di errore del rispettivo blocco funzione per questi meccanismi e reagisca in modo appropriato (esempio: creazione o interruzione di una connessione). Per prevenire un attacco al carico di lavoro, Unix esegue il peering ( u niente D omain S ockets) devono avere almeno la stessa priorità o una priorità maggiore rispetto al task IEC stesso. I peer UDS sono gli esempi forniti o i programmi creati dall'utente che utilizzano le funzioni dell'API Extension. Questa priorità non è la priorità visualizzata nella configurazione dell'attività di CODESYS . Può essere determinato sul sistema Linux per mezzo di htop . Questa è un'attività che ha lo stesso nome dell'attività IEC assegnata CODESYS . Il shell PLC richiede l'\"utente anonimo\". Se è abilitato, non è possibile tracciare quale utente Linux ha utilizzato la shell del PLC. A causa della separazione dei processi, le nuove interfacce del CODESYS Control Extension Package non forniscono la capacità di autenticazione dell'utente (dal punto di vista del CODESYS Development System ). Non è possibile assegnare un utente Linux o un nome utente corrispondente a un utente IEC. Di conseguenza, non solo gli utenti IEC, ma anche gli utenti Linux devono essere considerati e amministrati di conseguenza quando si considera la sicurezza dell'applicazione IEC. Solo gli utenti autorizzati possono avere accesso amministrativo al sistema Linux del sistema runtime. Nel caso di interfacce che utilizzano la separazione dei processi, non si può escludere che i dati vengano trasmessi non crittografati sul sistema. Ciò significa che un utente malintenzionato con autorizzazioni amministrative sul sistema potrebbe registrarli. " }, 
{ "title" : "Attività evento esterno ", 
"url" : "_rtsl_extension_external_event_task.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Attività evento esterno ", 
"snippet" : "Il meccanismo \"Task evento esterno\" può essere utilizzato per attivare un task tramite un evento esterno. \"Unix Domain Sockets\" sono usati per la separazione dei processi. Il file socket corrispondente si trova nel sistema di destinazione in base al nome scelto dall'utente per l'evento esterno: \/var...", 
"body" : "Il meccanismo \"Task evento esterno\" può essere utilizzato per attivare un task tramite un evento esterno. \"Unix Domain Sockets\" sono usati per la separazione dei processi. Il file socket corrispondente si trova nel sistema di destinazione in base al nome scelto dall'utente per l'evento esterno: \/var\/run\/codesyscontrolapi\/eventtasks\/<EventName>.sock " }, 
{ "title" : "Creazione di un'attività di tipo \"Evento esterno\". ", 
"url" : "_rtsl_extension_external_event_task.html#UUID-3c54739a-5fc2-8bad-4ca3-572d189df031_fe5af4cc6c60dcbcc0a8646324da24c1_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Attività evento esterno \/ Creazione di un'attività di tipo \"Evento esterno\". ", 
"snippet" : "Crea un evento esterno. Nella struttura dei dispositivi, selezionare Configurazione attività e nel menu contestuale fare clic su Gestisci eventi esterni (1). Nel Gestisci eventi esterni finestra di dialogo (2), aggiungi il nuovo evento. Il nome non deve contenere spazi o caratteri speciali. → Config...", 
"body" : "Crea un evento esterno. Nella struttura dei dispositivi, selezionare Configurazione attività e nel menu contestuale fare clic su Gestisci eventi esterni (1). Nel Gestisci eventi esterni finestra di dialogo (2), aggiungi il nuovo evento. Il nome non deve contenere spazi o caratteri speciali. → Configura un'attività come una nuova attività evento esterno: Nel Configurazione attività casella di riepilogo, selezionare un'attività. Nel Tipo casella di riepilogo, selezionare gli ultimi disponibili Esterno tipo di attività (3). Assegna il desiderato Evento esterno (4) al compito. → Il progetto di esempio fornito ExternalEventTask.Project contiene la configurazione sopra descritta. L'attività è assegnata a IL MIO EVENTO 1 evento esterno e il file \/var\/opt\/codesyscontrolapi\/eventtasks\/MYEVENT1.sock viene creato sul sistema. Con lo strumento da riga di comando \"socat\", puoi utilizzare molto facilmente questa interfaccia, ad esempio con il seguente comando: $ socat - UNIX-CLIENT:\/var\/opt\/codesyscontrolapi\/eventtasks\/MYEVENT1.sock Ciò stabilisce una connessione socket nella finestra del terminale e consente di inviare messaggi individuali al socket. Con ogni messaggio viene attivato il task configurato nel PLC. I contenuti del messaggio non sono rilevanti per l'attivazione dell'evento esterno. La lunghezza del messaggio è specificata come 1 byte. Utilizzo dell'interfaccia solo come membro di Linux codesyscontrolapi gruppo di utenti sì Separazione del processo sì " }, 
{ "title" : "Meccanismo di eventi ", 
"url" : "_rtsl_extension_event_mechanism.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Meccanismo di eventi ", 
"snippet" : "Il sistema di runtime utilizza gli \"eventi\" per comunicare eventi come l'avvio\/arresto\/ripristino del PLC, il verificarsi di un'eccezione e così via. Con il \"meccanismo degli eventi\" è possibile ricevere un messaggio non appena viene attivato un evento selezionato. Vengono inoltrati i seguenti event...", 
"body" : "Il sistema di runtime utilizza gli \"eventi\" per comunicare eventi come l'avvio\/arresto\/ripristino del PLC, il verificarsi di un'eccezione e così via. Con il \"meccanismo degli eventi\" è possibile ricevere un messaggio non appena viene attivato un evento selezionato. Vengono inoltrati i seguenti eventi relativi all'applicazione: EVT_StartDone EVT_StopDone EVT_ResetDone EVT_ExitDone EVT_AllBootprojectsLoaded EVT_CmpApp_Exception EVT_StateChanged EVT_CmpDevice_InteractiveLogin EVT_CmpMgr_LicenseState SysGraphic_EVT_OpenKeyboard SysGraphic_EVT_CloseKeyboard Il consegnato uds_events.py campione fornisce il CODESYS_EventHandler classe che implementa la registrazione a un evento. Questa classe ha bisogno del eventid così come il componentid of dell'evento da registrare, che vengono archiviati nel liEvents elenco: liEvents = {\n \"CmpApp_EVT_StartDone\" : (0x00000002, 0x10000 + 2),\n \"CmpApp_EVT_StopDone\" : (0x00000002, 0x10000 + 4),\n \"CmpApp_EVT_ResetDone\" : (0x00000002, 0x10000 + 6),\n \"CmpApp_EVT_ExitDone\" : (0x00000002, 0x10000 + 15),\n \"CmpApp_EVT_AllBootprojectsLoaded\" : (0x00000002, 0x10000 + 25),\n \"CmpApp_EVT_CmpApp_Exception\" : (0x00000002, 0x00080000 + 28),\n \"CmpApp_EVT_StateChanged\" : (0x00000002,0x10000 + 43),\n \"CmpDevice_EVT_CmpDevice_InteractiveLogin\" : (0x0000000E, 0x00010000+ 1),\n \"CmpMgr_EVT_LicenseState\" : (0x00000001, 0x00010000 + 9),\n \"SysGraphic_EVT_OpenKeyboard\" : (0x00000142, 0x00010000 + 1),\n \"SysGraphic_EVT_CloseKeyboard\" : (0x00000142, 0x00010000 + 2,\n} Inoltre, deve essere specificata una funzione di callback che verrà chiamata quando si verifica l'evento: def callbackfunction_start(componentid, eventid):\n print(\"Start event occured\") Entro Main , un evento viene registrato come segue e viene specificata la funzione di callback necessaria: componentid, eventid = liEvents[\"CmpApp_EVT_StartDone\"]\nmyEventHandler_Start = CODESYS_EventHandler(componentid, eventid, callbackfunction_start)\nmyEventHandler_Start.start() Ora la funzione di richiamata callbackfunction_start viene chiamato non appena il sistema di runtime passa a Start. Il meccanismo sottostante è mostrato nella figura seguente: Utilizzo dell'interfaccia solo come membro di Linux codesysuser gruppo di utenti sì Separazione del processo sì " }, 
{ "title" : "Accesso alla shell del PLC ", 
"url" : "_rtsl_extension_accessing_plc_shell.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Accesso alla shell del PLC ", 
"snippet" : "L'API di estensione consente l'accesso esterno alla shell del PLC. Per questa funzione, viene utilizzato un «Unix Domain Socket», che il sistema runtime utilizza per ricevere i comandi in arrivo e inviare la risposta corrispondente. Il file socket corrispondente \/var\/opt\/codesyscontrolapi\/plcshell.s...", 
"body" : "L'API di estensione consente l'accesso esterno alla shell del PLC. Per questa funzione, viene utilizzato un «Unix Domain Socket», che il sistema runtime utilizza per ricevere i comandi in arrivo e inviare la risposta corrispondente. Il file socket corrispondente \/var\/opt\/codesyscontrolapi\/plcshell.sock . Per questa funzione, il sistema di runtime deve avere l'autorizzazione \"Utente anonimo\". Consentire l'accesso anonimo avviene tramite il Impostazioni di comunicazione del dispositivo nel Modifica la politica di comunicazione dialogo (1): Consenti accesso anonimo opzione 2). " }, 
{ "title" : "Esempi ", 
"url" : "_rtsl_extension_accessing_plc_shell.html#UUID-f4776bb8-9dd5-0306-cfe0-2ef01425a6f9_e67b71746d20c0a8646363fbfe36_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Accesso alla shell del PLC \/ Esempi ", 
"snippet" : "Requisiti Il sistema di runtime ha consentito l'\"Utente anonimo\". Hai effettuato l'accesso al sistema Linux. Il tuo utente è assegnato al codesyscontrolapi gruppo. Accesso manuale tramite terminale Esegui il comando seguente. $ socat - UNIX-CLIENT:\/var\/opt\/codesyscontrolapi\/plcshell.sock Ora puoi es...", 
"body" : "Requisiti Il sistema di runtime ha consentito l'\"Utente anonimo\". Hai effettuato l'accesso al sistema Linux. Il tuo utente è assegnato al codesyscontrolapi gruppo. Accesso manuale tramite terminale Esegui il comando seguente. $ socat - UNIX-CLIENT:\/var\/opt\/codesyscontrolapi\/plcshell.sock Ora puoi eseguire i comandi della shell del PLC nel terminale Script di esempio copia plcshell.py dagli esempi forniti al sistema Linux. Esegui lo script. Lo script Python esegue in sequenza una serie di comandi utilizzando la shell PLC e dimostra l'uso della shell PLC in Python. Per ulteriori informazioni, vedere: Scheda: <nome dispositivo> PLC Shell Utilizzo dell'interfaccia solo come membro di Linux codesyscontrolapi gruppo di utenti sì Separazione del processo sì " }, 
{ "title" : "Interruttore START\/STOP ", 
"url" : "_rtsl_extension_start_stop_switch.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Interruttore START\/STOP ", 
"snippet" : "L'interruttore START\/STOP rappresenta un interruttore fisico che può essere utilizzato per impostare il PLC nello stato di avvio o arresto. Questo meccanismo è attivo se il file \/var\/opt\/codesyscontrolapi\/runstop.switch esiste. Attenzione: a differenza delle altre funzionalità del pacchetto di esten...", 
"body" : "L'interruttore START\/STOP rappresenta un interruttore fisico che può essere utilizzato per impostare il PLC nello stato di avvio o arresto. Questo meccanismo è attivo se il file \/var\/opt\/codesyscontrolapi\/runstop.switch esiste. Attenzione: a differenza delle altre funzionalità del pacchetto di estensione, il \/var\/opt\/codesyscontrolapi\/ viene interrogato. Questo file non viene creato dal sistema runtime. È necessario creare il file se si desidera utilizzare la funzione START\/STOP. Quando il contenuto di runstop.switch è \"RUN «, il PLC viene avviato. Quando il contenuto è diverso, il PLC è impostato su Il file di commutazione viene letto ciclicamente. Il PLC può essere arrestato e avviato in runtime. Se la runstop.switch il file viene cancellato in fase di esecuzione, quindi il componente perde la sua funzione e il PLC si avvia. Limitazione: i prodotti SL basati su Linux che dispongono già di un interruttore START\/STOP integrato nell'hardware non supportano questo meccanismo. Questi includono i seguenti prodotti: CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for WAGO Touch Panel 600 Utilizzo dell'interfaccia solo come membro di Linux codesyscontrolapi gruppo di utenti sì Separazione del processo sì " }, 
{ "title" : "Chiamare una funzione esterna ", 
"url" : "_rtsl_extension_calling_external_function.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Chiamare una funzione esterna ", 
"snippet" : "Questo meccanismo può essere utilizzato per chiamare una funzione esterna in un'applicazione IEC tramite un socket di dominio Unix. Ciò ti consente di creare le tue funzionalità. Allo stesso tempo, si ottiene la separazione del processo. Come interfaccia in IEC, il EXTAPI.UDSExternalFunction il bloc...", 
"body" : "Questo meccanismo può essere utilizzato per chiamare una funzione esterna in un'applicazione IEC tramite un socket di dominio Unix. Ciò ti consente di creare le tue funzionalità. Allo stesso tempo, si ottiene la separazione del processo. Come interfaccia in IEC, il EXTAPI.UDSExternalFunction il blocco funzione è fornito in ExtensionAPI libreria.In Python, il ExternalFunctionBase class viene utilizzata per questo scopo, fornito nell'esempio fornito. Questo esempio spiega anche come utilizzare il meccanismo. L'esempio contiene un progetto IEC con richiamo implementato di una funzione esterna. Inoltre, l'esempio contiene l'implementazione della funzione chiamata myExternalFunction in Python. Dopo CODESYS Control Extension Package l'installazione, è possibile trovare l'esempio UDSExternalCallExample.project e lo script Python uds_external_function.py nella seguente directory: C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalCall . " }, 
{ "title" : "Esempio, applicazione IEC ", 
"url" : "_rtsl_extension_calling_external_function.html#UUID-a1f120f1-d7f7-9c1c-f2c1-f02f0f73aa23_c32c4ba6c484ae1c0a864634bce6538_id_da88391a8bc94ccdc0a864631f91843d", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Chiamare una funzione esterna \/ Esempio, applicazione IEC ", 
"snippet" : "Nel UDSExternalCallExample.project progetto di esempio, un nuovo myExternalFunction viene creato il blocco funzione. Ciò estende il EXTAPI.UDSExternalFunction FB con ingressi e uscite di tipo DINT .Sono possibili anche altri tipi di dati. All'inizio è necessario passare il nome della funzione da chi...", 
"body" : "Nel UDSExternalCallExample.project progetto di esempio, un nuovo myExternalFunction viene creato il blocco funzione. Ciò estende il EXTAPI.UDSExternalFunction FB con ingressi e uscite di tipo DINT .Sono possibili anche altri tipi di dati. All'inizio è necessario passare il nome della funzione da chiamare in Python. Questo indirizzo deve essere univoco. Il codice seguente viene utilizzato per aggiungere gli ingressi della funzione esterna dell'interfaccia: Result := THIS^.AddParameter('parameterIn1', 'DINT', TO_STRING(diIn1)); Il codice seguente viene quindi utilizzato per chiamare la funzione esterna: Result := THIS^.Call(); Il codice seguente viene utilizzato per interrogare il valore di ritorno della funzione implementata in Python: Result := THIS^.GetParameter('parameterOut', 'DINT', ADR(sValue)); I parametri sono di tipo string . Di conseguenza, deve essere eseguito il cast del tipo di dati desiderato. " }, 
{ "title" : "Esempio, script Python ", 
"url" : "_rtsl_extension_calling_external_function.html#UUID-a1f120f1-d7f7-9c1c-f2c1-f02f0f73aa23_c32c4ba6c484ae1c0a864634bce6538_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Chiamare una funzione esterna \/ Esempio, script Python ", 
"snippet" : "Gli esempi Python forniti per l'API di estensione richiedono Python 3.0. L'incluso uds_external_function.py campione fornisce il ExternalFunctionBase class, che fornisce la comunicazione Unix Domain Socket con il sistema di runtime per questa funzionalità. Il myExternalFunction classe implementata n...", 
"body" : "Gli esempi Python forniti per l'API di estensione richiedono Python 3.0. L'incluso uds_external_function.py campione fornisce il ExternalFunctionBase class, che fornisce la comunicazione Unix Domain Socket con il sistema di runtime per questa funzionalità. Il myExternalFunction classe implementata nell'esempio estende il ExternalFunctionBase classe.Il Call() è necessaria la funzione, che viene chiamata dal meccanismo da IEC. I parametri di input e output vengono passati sotto forma di tuple di stringhe. Esempio: {'parameterIn1': ('DINT', '11'), 'parameterIn2': ('DINT', '22')} Nell'esempio, il Call() La funzione implementa una semplice aggiunta dei due parametri di input: def Call(self, dictParams):\n in1 = int(dictParams['parameterIn1'][1])\n in2 = int(dictParams['parameterIn2'][1])\n\n dictRetParams = {}\n dictRetParams['parameterOut'] = 'DINT', in1 + in2\n\n return dictRetParams Copiare lo script uds_external_function.py (situato nella directory C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalCall dopo l'installazione di CODESYS Control Extension Package ) sul dispositivo di destinazione. Esegui lo script uds_external_function.py . Quindi avviare il UDSExternalCallExample.project esempio di progetto in CODESYS . Puoi vedere che il progetto chiama il file myExternalFunction() funzione dello script Python e vengono sommati i due parametri di input. Utilizzo dell'interfaccia solo come membro di Linux codesysuser gruppo di utenti sì Separazione del processo sì " }, 
{ "title" : "Collegamento dei propri I\/O ", 
"url" : "_rtsl_extension_connecting_user_ios.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Collegamento dei propri I\/O ", 
"snippet" : "Con questa funzionalità, gli I\/O locali possono essere collegati a un controllore e utilizzati dall'applicazione IEC....", 
"body" : "Con questa funzionalità, gli I\/O locali possono essere collegati a un controllore e utilizzati dall'applicazione IEC. " }, 
{ "title" : "Modifica della descrizione del dispositivo ", 
"url" : "_rtsl_extension_connecting_user_ios.html#UUID-13dba825-3390-b677-ab9e-c88d5217ab74_a82230b6c3b57c1c0a86463472f7ec5_id_f93f1df46d57d55ac0a864632a96c684", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Collegamento dei propri I\/O \/ Modifica della descrizione del dispositivo ", 
"snippet" : "Nell'esempio UDSIoDrvExample.project fornito, vengono creati due ingressi e due uscite con la descrizione del dispositivo. Gli ingressi e le uscite sono collegati tramite una presa di dominio Unix. L'esempio si trova nella directory di installazione di CODESYS , nella sottodirectory CODESYS Control ...", 
"body" : "Nell'esempio UDSIoDrvExample.project fornito, vengono creati due ingressi e due uscite con la descrizione del dispositivo. Gli ingressi e le uscite sono collegati tramite una presa di dominio Unix. L'esempio si trova nella directory di installazione di CODESYS , nella sottodirectory CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalIoDrv . Per definire i propri ingressi e uscite, il file di descrizione del dispositivo SocketUnixIOTemplate.devdesc.xml deve essere adattato. Un XML parameter l'elemento deve essere definito per ciascuno degli ingressi e delle uscite ParameterId deve essere univoco qui all'interno del file di descrizione del dispositivo. Si consiglia semplicemente di numerare in ordine crescente senza spazi vuoti. Esempio: 1000 1001 1002 e così via: gli ingressi devono essere numerati da 1000, le uscite da 2000. Se la descrizione del dispositivo viene modificata, deve essere reinstallato nel repository dei dispositivi in modo che sia disponibile nel progetto. <Parameter ParameterId=\"1000\" type=\"std:DWORD\">\n <Attributes channel=\"input\"\/>\n <Default\/>\n <Name name=\"local:in1\">\/Namne>\n<\/Parameter> Nome Descrizione ParametroId ID univoco mediante il quale viene chiamato l'input o l'output genere Definizione della larghezza dell'ingresso o dell'uscita. Viene fatto specificando un tipo di dati adeguatamente ampio come std:BYTE , std:WORD , std:DWORD , o std:LWORD . Sono consentiti anche altri tipi di dati semplici. Attributi canale input o output Nome nome Nome per il rispettivo ingresso o uscita Inoltre, deve essere assegnato l'ID del dispositivo, che è definito in <DeviceIdentification> .A tale scopo viene fornito l'intervallo da 0x0001 8000 a 0x0001 80FF per evitare collisioni con dispositivi esistenti. La descrizione del dispositivo e il driver I\/O sottostante non devono essere istanziati più volte in un PLC perché l'ordine dei moduli non è fisso. Ciò può comportare che il driver I\/O non sia in grado di garantire l'assegnazione. " }, 
{ "title" : "Esempio Python ", 
"url" : "_rtsl_extension_connecting_user_ios.html#UUID-13dba825-3390-b677-ab9e-c88d5217ab74_a82230b6c3b57c1c0a86463472f7ec5_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Collegamento dei propri I\/O \/ Esempio Python ", 
"snippet" : "Nell'esempio Python uds_io_driver.py , vengono ricevute le uscite e scritti gli ingressi del dispositivo. I parametri di ingresso (uscite IEC) vengono passati come tuple di stringhe ( paramType , paramValue ) con l'ID parametro della descrizione del dispositivo come indice. Il driver può gestire i t...", 
"body" : "Nell'esempio Python uds_io_driver.py , vengono ricevute le uscite e scritti gli ingressi del dispositivo. I parametri di ingresso (uscite IEC) vengono passati come tuple di stringhe ( paramType , paramValue ) con l'ID parametro della descrizione del dispositivo come indice. Il driver può gestire i tipi di dati USINT , UINT , UDINT , e ULINT . Altri tipi di dati devono essere convertiti in un tipo di dati adatto. Esempio: ( '2000': ('UDINT', '11'), '2001': ('UDINT', '22')} .I parametri di output sono nello stesso formato. Anche per il peer, un parametro \"output\"\/output è comunque un valore di output che deve essere trasportato \"verso l'esterno\" dall'applicazione IEC (ad esempio, scritto in GPIO reali). Il UDS_IODriver_0 classe implementata nell'esempio estende il ExternalFunctionBase class.Da cui deriva il nome della classe UDS_IODriver_ seguito dall'indice di istanza in ordine crescente.Il Call() è necessaria la funzione, che viene richiamata dal meccanismo di IEC. Le uscite IEC possono ora essere valutate qui e gli ingressi IEC possono essere trasferiti. Utilizzo dell'interfaccia solo come membro di Linux codesysuser gruppo di utenti sì Separazione del processo sì " }, 
{ "title" : "Conserva i dati nella memoria condivisa ", 
"url" : "_rtsl_extension_retains_in_shared_memory.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ Conserva i dati nella memoria condivisa ", 
"snippet" : "Alcuni prodotti non includono una connessione automatica di conservazione dei dati dall'applicazione nel controller (a causa della mancanza di opzioni di archiviazione generalmente valide). Esiste tuttavia un meccanismo esistente nel sistema runtime mediante un collegamento tramite memoria condivisa...", 
"body" : "Alcuni prodotti non includono una connessione automatica di conservazione dei dati dall'applicazione nel controller (a causa della mancanza di opzioni di archiviazione generalmente valide). Esiste tuttavia un meccanismo esistente nel sistema runtime mediante un collegamento tramite memoria condivisa (SHM) che può essere utilizzato a tale scopo con una rispettiva configurazione. L'utilizzo è possibile, ad esempio, con quanto segue CODESYS Control Prodotti SL: CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control for Raspberry Pi CODESYS Control for BeagleBone Nota sulla versione: la versione minima di CODESYS Control Il prodotto SL è V4.4.0.0 ( CODESYS Control versione 3.5.17.30) Fondamentalmente, i \"Retains\" sono abilitati tramite SHM dalle seguenti impostazioni in \/etc\/CODESYSControl_User.cfg sul dispositivo di destinazione: [CmpApp]\n RetainType.Applications=InSHM [CmpRetain]\n Retain.SHM.Size=0x1FFFF ; Total size of remanent memory in bytes\n Retain.SHM.Name=MyRetainMemory ; Optional (Default: \"RetainMemory\") Dopo un riavvio, il sistema runtime crea un file di memoria condivisa con il nome configurato sotto \/dev\/shm . Mappando questo file, la memoria può essere reindirizzata a qualsiasi file non volatile, ad esempio, tramite i seguenti comandi: sudo touch \/dev\/shm\/MyRetainMemory\nsudo mount -o bind \/var\/opt\/MyRetainMemory \/dev\/shm\/MyRetainMemory Al file si accede ciclicamente in base al tempo di ciclo impostato nell'applicazione PLC. Il file SHM non dovrebbe quindi mai essere reindirizzato a un file in un file system basato su flash, altrimenti c'è il rischio che la memoria venga distrutta. " }, 
{ "title" : "SDK di estensione ", 
"url" : "_rtsl_extension_extension_sdk.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ SDK di estensione ", 
"snippet" : "Con Extension SDK è possibile implementare le proprie funzioni in C e richiamarle dall'applicazione IEC. Per questo collegamento, il codice C è integrato nel sistema di runtime sotto forma di un componente dinamico separato ( shared object ). Ci sono due modi per includere: Preparato sul controller:...", 
"body" : "Con Extension SDK è possibile implementare le proprie funzioni in C e richiamarle dall'applicazione IEC. Per questo collegamento, il codice C è integrato nel sistema di runtime sotto forma di un componente dinamico separato ( shared object ). Ci sono due modi per includere: Preparato sul controller: il componente dinamico è già configurato su CODESYS sistema di esecuzione (a shared object esiste ed è configurato sul sistema Linux). Quindi, è richiesta solo la rispettiva libreria IEC. Sotto forma di libreria IEC con un componente dinamico integrato. Non è necessario preparare nulla sul sistema Linux stesso. Quando si utilizza la libreria IEC, il componente dinamico viene aggiunto automaticamente al file CODESYS sistema di runtime e utilizzato. In entrambi i casi, l'utente deve essere in grado di creare un file shared object che è adatto per l'architettura del sistema di runtime (x64\/ARM6\/ARM7\/AARCH64). L'SDK di estensione ti supporta nella creazione di questo tipo di componente dinamico (shared object ). Di seguito viene descritto come creare la libreria e il componente dinamico per entrambe le varianti. " }, 
{ "title" : "Sviluppo dell'ambiente ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_3742f1416db55357c0a864630d1ff3cd", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ SDK di estensione \/ Sviluppo dell'ambiente ", 
"snippet" : "Sviluppo dell'ambiente Aprire CODESYS e creare una nuova libreria. Imposta il titolo della libreria( Informazioni di progetto , Riepilogo scheda) e salvare la libreria con lo stesso nome. Aggiungere le funzioni desiderate e contrassegnarle come Implementazione esterna . Nel menu contestuale della fu...", 
"body" : "Sviluppo dell'ambiente Aprire CODESYS e creare una nuova libreria. Imposta il titolo della libreria( Informazioni di progetto , Riepilogo scheda) e salvare la libreria con lo stesso nome. Aggiungere le funzioni desiderate e contrassegnarle come Implementazione esterna . Nel menu contestuale della funzione nel navigatore di progetto, fare clic su Proprietà . Sul Costruire scheda, seleziona Implementazione esterna . Nota: la funzione deve contenere \" _cext \" nel nome. Ora genera i file *ce *m4: Clic Compila → Genera file di sistema di runtime . Selezionare File di interfaccia M4 e File stub C . Seleziona la posizione di salvataggio. " }, 
{ "title" : "Linux ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_8bf074606db55357c0a864636bb48d02", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ SDK di estensione \/ Linux ", 
"snippet" : "Copiare Extension SDK su un sistema Linux che dispone dell'ambiente di compilazione corrispondente per il sistema di destinazione. Per impostazione predefinita, trovi Extension SDK in: C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\ExtensionSDK . La directo...", 
"body" : "Copiare Extension SDK su un sistema Linux che dispone dell'ambiente di compilazione corrispondente per il sistema di destinazione. Per impostazione predefinita, trovi Extension SDK in: C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\ExtensionSDK . La directory verrà denominata <SDK DIR> nei passaggi seguenti. Crea una nuova cartella in cui crei l'implementazione C. Questa cartella è la seguente <PROJECT DIR> . Navigare verso <PROJECT DIR> e corri: $ make -f <SDKDIR>\/makefile newproject Copia i file *ce *m4 che hai creato nell'ambiente di sviluppo in <PROJECT DIR> . Implementare le funzioni in C. Crea l'oggetto condiviso: $ make all Il shared object è generato e si trova in <PROJECT DIR>\/out\/libCmpMyTest.so . Di conseguenza, è stato creato un componente dinamico che ora può essere richiamato dall'applicazione IEC tramite la propria libreria IEC. Dettagli sul processo di compilazione ( make ) si trovano anche nei makefile e README file nell'SDK di estensione. Ora scegli uno dei due modi seguenti per includere il componente: " }, 
{ "title" : "Compreso il componente dinamico ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_section-idm234821879525116", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ SDK di estensione \/ Compreso il componente dinamico ", 
"snippet" : "Sono disponibili le seguenti opzioni per includere il componente:...", 
"body" : "Sono disponibili le seguenti opzioni per includere il componente: " }, 
{ "title" : "Compreso il componente dinamico sul dispositivo di destinazione ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_e85c7db98c25e844c0a864634a8e2492", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ SDK di estensione \/ Compreso il componente dinamico \/ Compreso il componente dinamico sul dispositivo di destinazione ", 
"snippet" : "Questo metodo consente di includere l'oggetto condiviso precedentemente creato in C nel sistema di runtime. Non sono richieste autorizzazioni di sistema aggiuntive per l'utente e la libreria può essere implementata sui dispositivi utilizzando metodi familiari. Copia l'oggetto condiviso creato sopra ...", 
"body" : "Questo metodo consente di includere l'oggetto condiviso precedentemente creato in C nel sistema di runtime. Non sono richieste autorizzazioni di sistema aggiuntive per l'utente e la libreria può essere implementata sui dispositivi utilizzando metodi familiari. Copia l'oggetto condiviso creato sopra nel sistema di runtime. Copia l'oggetto condiviso in \/usr\/lib\/ o una directory di libreria equivalente in cui le librerie vengono trovate dal sistema. Arrestare il sistema di runtime (esempio: $ sudo \/etc\/init.d\/codesyscontrol stop ) Aprire \/etc\/CODESYSControl_User.cfg con autorizzazioni di amministratore: $ sudo nano \/etc\/CODESYSControl_User.cfg Nel [ComponentManager] sezione, aggiungi gli oggetti condivisi creati: [ComponentManager]\nComponent.1=CmpFirstTest\nComponent.2=CmpSomeOtherComponent\n... Nota: il numero è un numero incrementale che non deve entrare in conflitto con i componenti esistenti. Avvia il sistema di runtime: $ sudo \/etc\/init.d\/codesyscontrol start Ora puoi verificare se il componente è stato caricato: $ cat \/tmp\/codesyscontrol.log " }, 
{ "title" : "Incluso il componente dinamico nella libreria IEC ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_4cf431216db55357c0a86463621d9489", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ SDK di estensione \/ Compreso il componente dinamico \/ Incluso il componente dinamico nella libreria IEC ", 
"snippet" : "Aggiungi il componente dinamico alla libreria IEC utilizzando la funzionalità \"Integrazione codice C\". Per ulteriori informazioni, vedere Integrazione del codice C nell'aiuto generale. Aprire la libreria IEC. In POU , aggiungere un Libreria C-Implementata oggetto. In questo oggetto, aggiungi un File...", 
"body" : "Aggiungi il componente dinamico alla libreria IEC utilizzando la funzionalità \"Integrazione codice C\". Per ulteriori informazioni, vedere Integrazione del codice C nell'aiuto generale. Aprire la libreria IEC. In POU , aggiungere un Libreria C-Implementata oggetto. In questo oggetto, aggiungi un File oggetto per dispositivi : Seleziona il componente dinamico (file) creato in precedenza e aggiungilo. Specificare un nome componente adatto. Seleziona il dispositivo adatto. Ora, quando si utilizza questa libreria con il dispositivo selezionato, il componente dinamico viene aggiunto automaticamente al sistema di runtime e può essere richiamato utilizzando le POU della libreria. " }, 
{ "title" : "Altro ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Control Extension Package \/ SDK di estensione \/ Altro ", 
"snippet" : "Restrizioni: Con Extension SDK è possibile includere solo il codice C. Non è possibile utilizzare un debugger per esaminare o eseguire il debug del codice C (ad esempio, come nel sistema di programmazione). Il codice C non può \"interagire\" con il sistema di runtime o l'applicazione IEC. Questo signi...", 
"body" : "Restrizioni: Con Extension SDK è possibile includere solo il codice C. Non è possibile utilizzare un debugger per esaminare o eseguire il debug del codice C (ad esempio, come nel sistema di programmazione). Il codice C non può \"interagire\" con il sistema di runtime o l'applicazione IEC. Questo significa: L'accesso automatico alle variabili dell'applicazione IEC non è possibile. L'accesso alla funzionalità del sistema runtime non è possibile. Tuttavia, l'accesso alle variabili dell'applicazione IEC è ovviamente possibile passandole a una funzione implementata in codice C by reference (ad esempio via POINTER ). Utilizzo dell'interfaccia solo come membro di Linux codesysuser gruppo di utenti No Separazione del processo No " }, 
{ "title" : "Configurazione specifica del prodotto ", 
"url" : "_rtsl_product_configuration_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "BeagleBone ", 
"url" : "_rtsl_linux_beaglebone.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ BeagleBone ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Configurazione di CAN\/Serial Capes ", 
"url" : "_rtsl_linux_rbp_can_capes.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ BeagleBone \/ Configurazione di CAN\/Serial Capes ", 
"snippet" : "Sono disponibili diverse mantelle (schede di estensione) per il  BeagleBone Black  per ampliare la gamma di funzioni. Un mantello è inserito nello slot di espansione del  BeagleBone Black  e fornisce esso stesso uno slot di espansione aggiuntivo. Un  BeagleBone Black  può essere ampliato con un mass...", 
"body" : "Sono disponibili diverse mantelle (schede di estensione) per il  BeagleBone Black  per ampliare la gamma di funzioni. Un mantello è inserito nello slot di espansione del  BeagleBone Black  e fornisce esso stesso uno slot di espansione aggiuntivo. Un  BeagleBone Black  può essere ampliato con un massimo di quattro mantelle. Questo capitolo descrive la configurazione generale di a  BeagleBone Black  che si estende con un mantello CAN. Il requisito per estendere il mantello è la versione del kernel 4.1. Le descrizioni possono variare leggermente per altre versioni del kernel. È possibile utilizzare i seguenti comandi nella riga di comando per determinare la versione del kernel (ad esempio, tramite una connessione SSH): uname -a uname -r " }, 
{ "title" : "Montare il Capo ", 
"url" : "_rtsl_linux_rbp_installing_capes.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ BeagleBone \/ Configurazione di CAN\/Serial Capes \/ Montare il Capo ", 
"snippet" : "Montare il mantello abbinato sul  BeagleBone Black  come descritto nel manuale utente del mantello. Fornire alimentazione a  BeagleBone Black . Verificare la connessione con il comando: cat \/sys\/devices\/platform\/bone_capemgr\/slots Ad esempio, ottieni il seguente output: Mon 0: P---L- 0 cape-CBB-Seri...", 
"body" : "Montare il mantello abbinato sul  BeagleBone Black  come descritto nel manuale utente del mantello. Fornire alimentazione a  BeagleBone Black . Verificare la connessione con il comando: cat \/sys\/devices\/platform\/bone_capemgr\/slots Ad esempio, ottieni il seguente output: Mon\n0: P---L- 0 cape-CBB-Serial,r01,Logic Supply,cape-CBB-Serial\n1: PF---- -1\n2: PF---- -1\n3: PF---- -1 In alternativa, puoi anche controllare la visualizzazione del kernel come segue: dmesg | grep cape L'output dovrebbe assomigliare a questo: ...\n\n[3.719868] bone_capemgr bone_capemgr: Baseboard: 'A335BNLT,000B,1614BBBK0256'\n[3.719904] bone_capemgr bone_capemgr: compatible-baseboard=ti,beaglebone-black - #slots=4\n[3.762237] bone_capemgr bone_capemgr: slot #0: 'cape-CBB-Serial,r01,Logic Supply,cape-CBB-Serial'\n[3.818178] bone_capemgr bone_capemgr: slot #1: No cape found\n[3.878171] bone_capemgr bone_capemgr: slot #2: No cape found\n[3.938165] bone_capemgr bone_capemgr: slot #3: No cape found\n[3.944194] bone_capemgr bone_capemgr: initialized OK.\n[3.963568] bone_capemgr bone_capemgr: slot #0: dtbo 'cape-CBB-Serial-r01.dtbo' loaded; overlay id #0\n\n... Questo output mostra che è stato rilevato un mantello ed è stato caricato un overlay dell'albero del dispositivo corrispondente. " }, 
{ "title" : "Configurazione e test delle interfacce CAN ", 
"url" : "_rtsl_linux_bbb_configuring_can.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ BeagleBone \/ Configurazione di CAN\/Serial Capes \/ Configurazione e test delle interfacce CAN ", 
"snippet" : "Test CAN Per testare il CAN direttamente dalla riga di comando, puoi usare \"can-utils\" per il pacchetto Debian: Installa il pacchetto Debian: sudo apt-get install can-utils Invia un messaggio CAN: cansend can0 5A1#ABCDABCD Ricevi un messaggio CAN: candump can0...", 
"body" : "Test CAN Per testare il CAN direttamente dalla riga di comando, puoi usare \"can-utils\" per il pacchetto Debian: Installa il pacchetto Debian: sudo apt-get install can-utils Invia un messaggio CAN: cansend can0 5A1#ABCDABCD Ricevi un messaggio CAN: candump can0 " }, 
{ "title" : "Configurazione CAN ", 
"url" : "_rtsl_linux_bbb_configuring_can.html#UUID-efad06fa-f9d6-75e9-4a70-c5faf6598419_id_c96cb9d2e581efc0a86463263b6289-id-749f3d54d353c531c0a864631cb78ab4", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ BeagleBone \/ Configurazione di CAN\/Serial Capes \/ Configurazione e test delle interfacce CAN \/ Configurazione CAN ", 
"snippet" : "Se DCAN0 viene utilizzato su a  BeagleBone Black , allora entra in conflitto con la funzionalità I2C-2. Pertanto, DCAN1 viene generalmente utilizzato con P9 pin24 (Rx) e P9 pin26 (Tx). Requisito: sei connesso a  BeagleBone Black  tramite un client SSH, ad esempio con \"Putty\". Per configurare e testa...", 
"body" : "Se DCAN0 viene utilizzato su a  BeagleBone Black , allora entra in conflitto con la funzionalità I2C-2. Pertanto, DCAN1 viene generalmente utilizzato con P9 pin24 (Rx) e P9 pin26 (Tx). Requisito: sei connesso a  BeagleBone Black  tramite un client SSH, ad esempio con \"Putty\". Per configurare e testare manualmente il CAN, utilizzare i seguenti comandi: sudo modprobe can\nsudo modprobe can-dev\nsudo modprobe can-raw Il comando seguente carica il modulo del kernel (potrebbe essere necessario caricare un modulo diverso per hardware diverso): sudo modprobe c_can_platform Potrebbe essere necessario caricare un modulo diverso per hardware diverso. Inserisci nel file tutti i driver necessari per il funzionamento di CAN cape \" ..\/etc\/modules \". Esempio: can\ncan-dev\ncan-raw Ora è possibile utilizzare il meccanismo Linux \"socketcan\". Per impostazione predefinita, questo è supportato da  CODESYS Control for BeagleBone . I moduli del kernel vengono caricati automaticamente quando  BeagleBone Black  è iniziato. Imposta la velocità di trasmissione: sudo ip link set can0 up type can bitrate 125000 Attiva l'interfaccia: sudo ifconfig can0 up L'interfaccia CAN è configurata. " }, 
{ "title" : "Configurazione e test degli UART ", 
"url" : "_rtsl_linux_rbp_configuring_uarts.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ BeagleBone \/ Configurazione di CAN\/Serial Capes \/ Configurazione e test degli UART ", 
"snippet" : "Testare gli UART Esegui il seguente frammento di codice Python in una shell Python interattiva o crea un piccolo file di testo con estensione .py ed eseguilo con l'interprete Python: import serial import time uart2_file='\/dev\/ttyO2' baud=115200 ser = serial.Serial(uart2_file, baud) while True: ser.w...", 
"body" : "Testare gli UART Esegui il seguente frammento di codice Python in una shell Python interattiva o crea un piccolo file di testo con estensione .py ed eseguilo con l'interprete Python: import serial\nimport time\nuart2_file='\/dev\/ttyO2'\nbaud=115200\nser = serial.Serial(uart2_file, baud)\nwhile True:\n ser.write(\"Testing\")\n time.sleep(1) UART2 con baud rate 115200 si apre e trasmette il Testing stringa ogni secondo. Ora puoi collegare un cavo seriale e controllare l'uscita sul tuo PC (ad esempio, con Putty). " }, 
{ "title" : "Configurazione degli UART ", 
"url" : "_rtsl_linux_rbp_configuring_uarts.html#UUID-b5665400-7f51-ce43-e2ec-127a0725936a_id_be9f181d33627c4c0a8646366c6b2ff-id-4c119c87d346da4ec0a86463175a71c5", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ BeagleBone \/ Configurazione di CAN\/Serial Capes \/ Configurazione e test degli UART \/ Configurazione degli UART ", 
"snippet" : "Le interfacce seriali (chiamate anche UART) su questo capo (UART2 e UART4) sono accessibili dal \/dev\/ttyO2 e \/dev\/ttyO4 dispositivi. Se vuoi accedere tu stesso alla porta seriale dall'esterno di CODESYS , quindi fare riferimento alla documentazione Linux corrispondente. Se desideri accedere agli UAR...", 
"body" : "Le interfacce seriali (chiamate anche UART) su questo capo (UART2 e UART4) sono accessibili dal \/dev\/ttyO2 e \/dev\/ttyO4 dispositivi. Se vuoi accedere tu stesso alla porta seriale dall'esterno di CODESYS , quindi fare riferimento alla documentazione Linux corrispondente. Se desideri accedere agli UART da CODESYS , quindi specifica la configurazione SysCom nel file CODESYSControl.cfg : [SysCom]\nLinux.Devicefile=\/dev\/ttyO È possibile indicizzare le voci di configurazione. Esempio: Linux.Devicefile.7=\/dev\/usb0 Questo crea \/dev\/usb0 mappato su COM7. " }, 
{ "title" : "Problemi noti ", 
"url" : "_rtsl_linux_bbb_problems.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ BeagleBone \/ Configurazione di CAN\/Serial Capes \/ Problemi noti ", 
"snippet" : "Seriale RS485 Quando si utilizza l'RS485 del capo CAN\/Serial fornito, si verifica un problema nell'utilizzo del ricetrasmettitore RS485. Poiché il driver Linux non può passare dalla modalità di trasmissione a quella di ricezione, le applicazioni potrebbero non funzionare come previsto. Descrizione d...", 
"body" : "Seriale RS485 Quando si utilizza l'RS485 del capo CAN\/Serial fornito, si verifica un problema nell'utilizzo del ricetrasmettitore RS485. Poiché il driver Linux non può passare dalla modalità di trasmissione a quella di ricezione, le applicazioni potrebbero non funzionare come previsto. Descrizione dettagliata: Il driver seriale del BeagleBone Black(OMAP) non supporta la commutazione di trasmissione\/ricezione (DE\/RE o RTS) necessaria per RS-485. Ha invece una modalità RS485 che utilizza un pin GPIO assegnato in modo permanente per il controllo delle linee DE\/RE e ha una struttura modificata (serial_rs485 struct) rispetto al driver seriale standard. Devi usare ioctl sul file devtty corrispondente per posizionare il driver seriale in modalità RS-485 e dirgli quale pin deve usare. Inoltre, devi occuparti del multiplexing del pin in modalità GPIO. " }, 
{ "title" : "Utilizzo di GPIO e ingressi analogici ", 
"url" : "_rtsl_linux_bbb_gpios_analog_inputs.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ BeagleBone \/ Utilizzo di GPIO e ingressi analogici ", 
"snippet" : "Questo capitolo descrive le limitazioni quando si utilizza la mappatura I\/O di a  BeagleBone Black  per accedere ai GPIO e agli ingressi analogici....", 
"body" : "Questo capitolo descrive le limitazioni quando si utilizza la mappatura I\/O di a  BeagleBone Black  per accedere ai GPIO e agli ingressi analogici. " }, 
{ "title" : "Pin di accesso su P8\/P9 ", 
"url" : "_rtsl_linux_bbb_access_pins.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ BeagleBone \/ Utilizzo di GPIO e ingressi analogici \/ Pin di accesso su P8\/P9 ", 
"snippet" : "I connettori P8 e P9 consentono l'accesso a molti GPIO e agli ingressi analogici. Tuttavia, non tutti sono liberamente utilizzabili per impostazione predefinita. Gli \"slot\" standard dell'albero dei dispositivi HDMI e Linux utilizzano alcuni pin per HDMI, eMMC e MCASP0. L'elenco seguente mostra quali...", 
"body" : "I connettori P8 e P9 consentono l'accesso a molti GPIO e agli ingressi analogici. Tuttavia, non tutti sono liberamente utilizzabili per impostazione predefinita. Gli \"slot\" standard dell'albero dei dispositivi HDMI e Linux utilizzano alcuni pin per HDMI, eMMC e MCASP0. L'elenco seguente mostra quali pin possono essere utilizzati come GPIO o ingressi analogici e quali pin sono già utilizzati dal sistema. Prestare attenzione alle diverse tensioni e correnti consentite per gli ingressi e le uscite. Spina P9 Perno di intestazione Nome pin CODESYS Supporto Utilizzato dal sistema P9_01 GND NO NO P9_02 GND NO NO P9_03 CC_3,3 V NO NO P9_04 CC_3,3 V NO NO P9_05 VDD_5V NO NO P9_06 VDD_5V NO NO P9_07 SYS_5V NO NO P9_08 SYS_5V NO NO P9_09 PWR_BUT NO NO P9_10 SYS_RESETn NO NO P9_11 UART4_RXD SÌ NO P9_12 GPIO1_28 SÌ NO P9_13 UART4_TXD SÌ NO P9_14 EHRPWM1A SÌ NO P9_15 GPIO1_16 SÌ NO P9_16 EHRPWM1B SÌ NO P9_17 I2C1_SCL NO PINMUX I 2 C P9_18 I2C1_SDA NO PINMUX I 2 C P9_19 I2C2_SCL NO PINMUX I 2 C P9_20 I2C2_SDA NO PINMUX I 2 C P9_21 UART2_TXD SÌ NO P9_22 UART2_RXD SÌ NO P9_23 GPIO1_17 SÌ NO P9_24 UART1_TXD SÌ NO P9_25 GPIO3_21 NO MCASPO P9_26 UART1_RXD SÌ NO P9_27 GPIO3_19 SÌ NO P9_28 SPI1_CS0 NO MCASP0 P9_29 SPI1_D0 NO MCASP0 P9_30 SPI1_D1 NO MCASP0 P9_31 SPI1_SCLK NO MCASP0 P9_32 VADC NO NO P9_33 AIN4 SÌ NO P9_34 AGND NO NO P9_35 AIN6 SÌ NO P9_36 AIN5 SÌ NO P9_37 AIN2 SÌ NO P9_38 AIN3 SÌ NO P9_39 AIN0 SÌ NO P9_40 AIN1 SÌ NO P9_41 GPIO0_20 SÌ NO P9_42 GPIO0_7 SÌ NO P9_43 GND NO NO P9_44 GND NO NO P9_45 GND NO NO P9_46 GND NO NO Spina P8 Perno di intestazione Nome pin CODESYS Supporto Utilizzato dal sistema P8_01 DGND NO NO P8_02 DGND NO NO P8_03 GPIO1_6 NO eMMC P8_04 GPIO1_7 NO eMMC P8_05 GPIO1_2 NO eMMC P8_06 GPIO1_3 NO eMMC P8_07 TIMER4 SÌ NO P8_08 TIMER7 SÌ NO P8_09 TIMER5 SÌ NO P8_10 TIMER6 SÌ NO P8_11 GPIO1_13 SÌ NO P8_12 GPIO1_12 SÌ NO P8_13 EHRPWM2B SÌ NO P8_14 GPIO0_26 SÌ NO P8_15 GPIO1_15 SÌ NO P8_16 GPIO1_14 SÌ NO P8_17 GPIO0_27 SÌ NO P8_18 GPIO2_1 SÌ NO P8_19 EHRPWM2A SÌ NO P8_20 GPIO1_31 NO eMMC P8_21 GPIO1_30 NO eMMC P8_22 GPIO1_5 NO eMMC P8_23 GPIO1_4 NO eMMC P8_24 GPIO1_1 NO eMMC P8_25 GPIO1_0 NO eMMC P8_26 GPIO1_29 SÌ NO P8_27 GPIO2_22 NO HDMI P8_28 GPIO2_24 NO HDMI P8_29 GPIO2_23 NO HDMI P8_30 GPIO2_25 NO HDMI P8_31 UART5_CTSN NO HDMI P8_32 UART5_RTSN NO HDMI P8_33 UART4_RTSN NO HDMI P8_34 UART3_RTSN NO HDMI P8_35 UART4_CTSN NO HDMI P8_36 UART3_CTSN NO HDMI P8_37 UART5_TXD NO HDMI P8_38 UART5_TXD NO HDMI P8_39 GPIO2_12 NO HDMI P8_40 GPIO2_13 NO HDMI P8_41 GPIO2_10 NO HDMI P8_42 GPIO2_11 NO HDMI P8_43 GPIO2_8 NO HDMI P8_44 GPIO2_9 NO HDMI P8_45 GPIO2_6 NO HDMI P8_46 GPIO2_7 NO HDMI " }, 
{ "title" : "Configura dispositivi di archiviazione esterni ", 
"url" : "_rtsl_linux_bbb_external_storage.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ BeagleBone \/ Configura dispositivi di archiviazione esterni ", 
"snippet" : "È possibile configurare il  BeagleBone Black  da cui accedere a un dispositivo di archiviazione USB o a una scheda µSD  CODESYS Control for BeagleBone . La compatibilità di specifici dispositivi di archiviazione USB o schede µSD dipende dall'hardware. In teoria, tuttavia, ogni dispositivo di archivi...", 
"body" : "È possibile configurare il  BeagleBone Black  da cui accedere a un dispositivo di archiviazione USB o a una scheda µSD  CODESYS Control for BeagleBone . La compatibilità di specifici dispositivi di archiviazione USB o schede µSD dipende dall'hardware. In teoria, tuttavia, ogni dispositivo di archiviazione USB o scheda µSD dovrebbe funzionare con  BeagleBone Black . Accesso a un dispositivo di archiviazione USB o a una scheda µSD Configurazione di Linux per il montaggio automatico Debian fornisce un pacchetto che si occupa del montaggio automatico dei supporti di memorizzazione collegabili. Questo pacchetto può essere installato anche sul tuo  BeagleBone Black . Installazione del pacchetto usbmount dalla directory Debian: command> sudo apt-get install usbmount Il dispositivo deve essere connesso a Internet e configurato in modo da poter accedere al server Debian. Accesso ai dispositivi di archiviazione USB Quando un dispositivo di archiviazione USB è collegato, usbautomount crea automaticamente il file \/media\/usb cartella in cui è possibile accedere ai file sul dispositivo di memoria USB. Il CODESYS Il sistema di runtime di controllo è configurato in modo che i dispositivi di archiviazione USB vengano visualizzati automaticamente quando sono disponibili. Quando un dispositivo di archiviazione USB è collegato, viene aggiunto al file \/media\/usb cartella. In CODESYS , il $USB$ il segnaposto può essere utilizzato per accedere a questa cartella. Ci sono due modi per farlo: È possibile utilizzare il trasferimento di file in CODESYS Development System per accedere al $USB$ segnaposto. Puoi accedere a questi stessi file dalla tua applicazione IEC utilizzando la libreria CAA_File. Prestare attenzione che i file potrebbero non essere accessibili perché il supporto è collegabile. Pertanto, controlla il risultato di CAAFileOpen. " }, 
{ "title" : "Raspberry Pi ", 
"url" : "_rtsl_linux_raspberry.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi ", 
"snippet" : "Usa questo Raspberry Pi con il sistema operativo Raspbian, che puoi ottenere da Fondazione Raspberry Pi . IL Raspberry Pi è stato sviluppato per scopi di test e insegnamento. Si sconsiglia l'utilizzo per scopi industriali! Iniziare con il Raspberry Pi Un runtime con funzionalità multicore è disponib...", 
"body" : "Usa questo Raspberry Pi con il sistema operativo Raspbian, che puoi ottenere da Fondazione Raspberry Pi . IL Raspberry Pi è stato sviluppato per scopi di test e insegnamento. Si sconsiglia l'utilizzo per scopi industriali! Iniziare con il Raspberry Pi Un runtime con funzionalità multicore è disponibile a partire da Raspberry Pi Versione 2. " }, 
{ "title" : "Sviluppo dei driver ", 
"url" : "_rtsl_linux_rbp_driver_development.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Sviluppo dei driver ", 
"snippet" : "Ci sono molti dispositivi che possono essere collegati a Raspberry Pi . CODESYS Control for Raspberry Pi supporta solo una piccola parte dell'hardware disponibile. Se desideri connettere un dispositivo non supportato al tuo Raspberry Pi , quindi puoi scrivere il tuo driver I\/O. Per fare ciò, avrai b...", 
"body" : "Ci sono molti dispositivi che possono essere collegati a Raspberry Pi . CODESYS Control for Raspberry Pi supporta solo una piccola parte dell'hardware disponibile. Se desideri connettere un dispositivo non supportato al tuo Raspberry Pi , quindi puoi scrivere il tuo driver I\/O. Per fare ciò, avrai bisogno di alcune capacità di configurazione e programmazione. Fondamentalmente, è possibile adottare i seguenti approcci per collegare e utilizzare dispositivi aggiuntivi tramite le interfacce di sistema I 2 C, SPI (Serial Peripheral Interface) o 1-Wire. Implementare un blocco funzione (FB) Il blocco funzione gestisce la mappatura dei dati su variabili esistenti o nuove e garantisce la coerenza del ciclo dei dati. Per fare ciò, dichiarare manualmente l'interfaccia e chiamare un'istanza nel programma. Implementare un blocco funzione (FB) con una descrizione del dispositivo Quindi puoi aggiungere un dispositivo speciale al file CODESYS albero dei dispositivi e configurarlo. Implementare i driver di I\/O Questi e altri approcci sono descritti nell'open-source CODESYS Forgia piattaforma nel Driver → Driver I\/O menù. " }, 
{ "title" : "Configurazione del runtime ", 
"url" : "_rtsl_linux_rbp_configure_runtime.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Configurazione del runtime ", 
"snippet" : "CODESYS Control for Raspberry Pi Dalla versione V3.5 SP14 supporta anche hardware multi-core ( Raspberry Pi 2 e Raspberry Pi 3). Il sistema runtime può essere utilizzato in tre diverse modalità: Multicore a 64 bit (Aarch64): questa modalità utilizza un runtime con funzionalità multicore in modalità ...", 
"body" : "CODESYS Control for Raspberry Pi Dalla versione V3.5 SP14 supporta anche hardware multi-core ( Raspberry Pi 2 e Raspberry Pi 3). Il sistema runtime può essere utilizzato in tre diverse modalità: Multicore a 64 bit (Aarch64): questa modalità utilizza un runtime con funzionalità multicore in modalità a 64 bit e deve essere eseguita con una descrizione del dispositivo ottimizzata per esso. Multicore a 32 bit (ARMv7): questa modalità utilizza un runtime compatibile con multicore in modalità a 32 bit e deve essere eseguita con una descrizione del dispositivo ottimizzata per esso. Impostazione predefinita: questa modalità può essere utilizzata per tutti Raspberry Pi varianti ed è compatibile con le versioni precedenti di CODESYS Control for Raspberry Pi (compresa la descrizione del dispositivo). Non supporta il CODESYS funzionalità multicore. Una modalità viene preselezionata automaticamente quando viene installato il sistema runtime Raspberry Pi. Puoi vedere quale modalità è stata selezionata nella finestra di registro. Per cambiare la modalità, selezionate innanzitutto il sistema runtime Raspberry Pi nell'elenco dei servizi. Dopo un breve periodo di caricamento, l'architettura di runtime corrente viene visualizzata sul lato destro È possibile selezionare l'architettura desiderata tramite Runtime system architecture casella di riepilogo. Fai clic Salva per trasferire la modifica sul dispositivo. La modalità utilizzabile dipende anche dall'immagine del sistema operativo utilizzata. Se si utilizza un'immagine puramente a 64 bit, è possibile utilizzare solo la modalità a 64 bit. Se si utilizza un'immagine esclusivamente a 32 bit, è possibile selezionare solo le modalità a 32 bit. A seconda dell'hardware utilizzato (Raspberry PI 2B, PI 3, PI 4, ecc.), sono supportate solo le modalità selezionate. (vedi descrizione comando). Se si desidera cambiare modalità, assicurarsi che la descrizione del dispositivo corrispondente sia configurata nel progetto. In caso contrario, la comunicazione con il controller non è più possibile. Le applicazioni di avvio esistenti sul controller non possono più essere caricate dopo il passaggio. Devono essere nuovamente scaricati sul controller con la descrizione del dispositivo corrispondente. " }, 
{ "title" : "Esempi di progetti ", 
"url" : "_rtsl_linux_rbp_examples.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti ", 
"snippet" : "I seguenti progetti di esempio si trovano nella directory di installazione (example C:\\Users\\<Name>\\ CODESYS Control for Raspberry Pi \\3.5.11.0\\Examples )....", 
"body" : "I seguenti progetti di esempio si trovano nella directory di installazione (example C:\\Users\\<Name>\\ CODESYS Control for Raspberry Pi \\3.5.11.0\\Examples ). " }, 
{ "title" : "Configurazione di WebVisu ", 
"url" : "_rtsl_linux_rbp_examples_webvisu.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione di WebVisu ", 
"snippet" : "Il progetto: WebVisu.project contiene un'applicazione con un'interfaccia utente creata con CODESYS Visualization . Apri il WebVisu.project progetto. Nella struttura dei dispositivi, fare doppio clic Dispositivo . In Impostazioni di comunicazione , fare clic Scansione rete . Se il dispositivo si trov...", 
"body" : "Il progetto: WebVisu.project contiene un'applicazione con un'interfaccia utente creata con CODESYS Visualization . Apri il WebVisu.project progetto. Nella struttura dei dispositivi, fare doppio clic Dispositivo . In Impostazioni di comunicazione , fare clic Scansione rete . Se il dispositivo si trova sulla stessa rete del PC di sviluppo, il dispositivo viene visualizzato per la selezione. Selezionare la linea di collegamento e fare clic In linea → Accedi . L'applicazione viene scaricata sul tuo Raspberry Pi. Avviare il programma (esempio: premere il tasto F5 chiave). Apri un qualsiasi browser (possibilmente su uno smartphone) e specifica l'indirizzo <network address>:8080\/webvisu.htm . Nel browser viene visualizzata l'interfaccia utente così come è stata creata nel progetto. " }, 
{ "title" : "Configurazione del modulo fotocamera ", 
"url" : "_rtsl_linux_rbp_examples_camera.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione del modulo fotocamera ", 
"snippet" : "Visualizzazione delle immagini della telecamera Il CameraStream.project project contiene un'applicazione con un'interfaccia utente WebVisu che visualizza un flusso live della telecamera o solo una singola immagine. Requisito: l'hardware di espansione della fotocamera Raspberry Pi è collegato e attiv...", 
"body" : "Visualizzazione delle immagini della telecamera Il CameraStream.project project contiene un'applicazione con un'interfaccia utente WebVisu che visualizza un flusso live della telecamera o solo una singola immagine. Requisito: l'hardware di espansione della fotocamera Raspberry Pi è collegato e attivato. A seconda della versione di RPi_Cam_Web_Interface e l'installazione di Apache inclusa, potrebbe essere la posizione predefinita ..\/var\/www\/ o ..\/var\/www\/html\/ . La posizione viene utilizzata nell'applicazione in PLC_PRG sulla riga 3 e devi regolarlo di conseguenza. Apri il Camera.project progetto e aggiornarlo. Nella struttura dei dispositivi, fare doppio clic Dispositivo . Si apre l'editor del dispositivo. In Impostazioni di comunicazione , fare clic Scansione rete . Se il tuo Raspberry Pi e il sistema di sviluppo si trovano sulla stessa rete, il tuo Raspberry Pi viene visualizzato per la selezione. Selezionalo e fai clic In linea → Accedi . L'applicazione viene scaricata sul tuo Raspberry Pi. Avviare il programma (premere il F5 chiave). Apri un qualsiasi browser (possibilmente su uno smartphone) e specifica l'indirizzo <network address>:8080\/webvisu.htm . Si apre l'interfaccia utente del progetto. La parte superiore mostra lo streaming live della telecamera e sotto di essa l'ultimo fotogramma. Quando si fa clic sul pulsante, la cornice verrà aggiornata. " }, 
{ "title" : "Salvataggio delle immagini della fotocamera ", 
"url" : "_rtsl_linux_rbp_examples_camera.html#UUID-7ae4b070-9730-d58c-9609-58bda5038aa4_id_fa1d2aa65ca341bec0a864637b1b4eb2-id-919df6bb9f68aed4c0a864630c86131d", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione del modulo fotocamera \/ Salvataggio delle immagini della fotocamera ", 
"snippet" : "Requisito: l'hardware di espansione della fotocamera Raspberry Pi è collegato e attivato. Il Camera.project project contiene un'applicazione che controlla un modulo Raspberry Pi Camera, acquisisce singole immagini e le salva come file. Su alcuni modelli, il preinstallato RPi Cam Control l'applicazio...", 
"body" : "Requisito: l'hardware di espansione della fotocamera Raspberry Pi è collegato e attivato. Il Camera.project project contiene un'applicazione che controlla un modulo Raspberry Pi Camera, acquisisce singole immagini e le salva come file. Su alcuni modelli, il preinstallato RPi Cam Control l'applicazione deve essere disabilitata. Per fare ciò, apri un browser e specifica http:\/\/<network address> . Si apre la pagina di configurazione. Eseguire il stop camera comando lì. Apri il Camera.project progetto e aggiornarlo. Nella struttura dei dispositivi, fare doppio clic Dispositivo . Si apre l'editor del dispositivo. In Impostazioni di comunicazione , fare clic Scansione rete . Se il tuo Raspberry Pi e il sistema di sviluppo si trovano sulla stessa rete, il tuo Raspberry Pi viene visualizzato per la selezione. Selezionalo e fai clic In linea → Accedi . L'applicazione viene scaricata sul tuo Raspberry Pi. Avviare il programma (premere il F5 chiave). Impostare il xTakePicture variabile a TRUE . La fotocamera scatta una foto e la salva nel file system locale sotto il nome Picture.jpg . È possibile copiare il file immagine nell'editor del dispositivo in File al tuo sistema di sviluppo. Clicca il simbolo per aggiornare la visualizzazione del file. " }, 
{ "title" : "Configurazione GPIO ", 
"url" : "_rtsl_linux_rbp_examples_gpio.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione GPIO ", 
"snippet" : "Il GPIO.project project contiene un'applicazione con GPIO gratuiti con un editor di dispositivi in cui è configurata l'immagine I\/O. Qui vengono definiti anche gli ingressi e le uscite digitali. Nell'editor del dispositivo, sotto il Immagine I\/O GPIO scheda, a DWORD viene dichiarata una variabile pe...", 
"body" : "Il GPIO.project project contiene un'applicazione con GPIO gratuiti con un editor di dispositivi in cui è configurata l'immagine I\/O. Qui vengono definiti anche gli ingressi e le uscite digitali. Nell'editor del dispositivo, sotto il Immagine I\/O GPIO scheda, a DWORD viene dichiarata una variabile per ciascuno degli input e degli output. Il Bit<X> contiene il valore di GPIO<X> . Nell'esempio, GPIO18 è stata definita come uscita. Viene assegnato con un segnale lampeggiante in PLC_PRG programma. La visualizzazione visualizza il valore degli ingressi e permette di impostare le uscite. È disponibile una descrizione del dispositivo separata ed estesa per la variante del modello Raspberry Pi B+. Per utilizzare il GPIO B+\/Pi2 descrizione del dispositivo invece di GPIO A\/B , fare clic Aggiorna dispositivo nel menu contestuale e selezionare il GPIO B+\/Pi2 tipo di dispositivo nella finestra di dialogo. A seconda dei driver caricati, alcuni GPIO potrebbero essere assegnati in modo permanente ad altre funzioni e quindi non disponibili. " }, 
{ "title" : "Configurazione di PiFace Digital ", 
"url" : "_rtsl_linux_rbp_examples_piface.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione di PiFace Digital ", 
"snippet" : "Controllo e funzionamento con il modulo PiFace Control and Display Requisito: l'hardware di espansione PiFace Control e Display è collegato. Il PiFaceDisplayAndControl.project Il progetto contiene un'applicazione che controlla un display di testo a due righe oltre all'hardware I\/O digitale Raspberry...", 
"body" : "Controllo e funzionamento con il modulo PiFace Control and Display Requisito: l'hardware di espansione PiFace Control e Display è collegato. Il PiFaceDisplayAndControl.project Il progetto contiene un'applicazione che controlla un display di testo a due righe oltre all'hardware I\/O digitale Raspberry PiFace con 8 ingressi e uscite digitali per configurare i parametri dell'applicazione. È possibile raggiungere la scheda di controllo e display PiFace tramite la porta SPI 1 \/dev\/spidev0.1 che è configurato nel master SPI. Quando il dispositivo viene aggiunto all'albero dei dispositivi, viene creata un'istanza FB che fornisce vari metodi e proprietà per il controllo del dispositivo. Inoltre, viene restituito lo stato dei pulsanti. Bit da 0 a 7 del bySwitches supporto di uscita per i seguenti pulsanti: Nel progetto di esempio il PiFace_Control_Display FB viene passato a un'istanza di ParamListPiFace FB che implementa un editor di parametri. Nella sua modalità di visualizzazione è possibile scorrere l'elenco dei parametri tramite il pulsante di navigazione (6\/7). Premendo il pulsante di navigazione (5), è possibile visualizzare in dettaglio il parametro della prima riga. Si esce dalla visualizzazione dettagliata premendo il pulsante 4. Premere nuovamente 5 per accedere alla modalità di modifica. Lì è possibile modificare il valore nell'intervallo consentito con i pulsanti 0 e 1. Con il pulsante 2, il valore viene memorizzato. Premere il pulsante 4 per uscire dalla modalità di modifica. " }, 
{ "title" : "Controllo dell'hardware I\/O digitale PiFace ", 
"url" : "_rtsl_linux_rbp_examples_piface.html#UUID-c604b911-bae8-3ccf-0ad8-13b30c6d647a_id_a539525ca8913fc0a864630d69208b-id-9f45924d66a164bcc0a864631b646b6a", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione di PiFace Digital \/ Controllo dell'hardware I\/O digitale PiFace ", 
"snippet" : "Requisito: l'hardware di espansione PiFace Digital è collegato. Il PiFace.project contiene un'applicazione che controlla un hardware I\/O digitale Raspberry PiFace con 8 ingressi e uscite digitali. Apri il PiFace.project progetto e aggiornarlo. Nella struttura dei dispositivi, fare doppio clic Device...", 
"body" : "Requisito: l'hardware di espansione PiFace Digital è collegato. Il PiFace.project contiene un'applicazione che controlla un hardware I\/O digitale Raspberry PiFace con 8 ingressi e uscite digitali. Apri il PiFace.project progetto e aggiornarlo. Nella struttura dei dispositivi, fare doppio clic Device . Si apre l'editor del dispositivo. Sul Impostazioni di comunicazione scheda, fare clic Scansione rete . Se il tuo Raspberry Pi e il sistema di sviluppo si trovano sulla stessa rete, il tuo Raspberry Pi viene visualizzato per la selezione. Selezionalo e fai clic In linea → Accedi . L'applicazione viene scaricata sul tuo Raspberry Pi. Avviare il programma (premere il F5 chiave). Quando si preme il pulsante S1, l'uscita relè K0 viene commutata con un ritardo di un secondo. Quando si preme il pulsante S2, K1 viene commutato immediatamente. K1 viene trattenuto per mezzo secondo dopo il rilascio di S2. Si noti inoltre che è possibile utilizzare più istanze (indirizzo hardware modificabile tramite jumper JP1, JP2) regolando di conseguenza il parametro del dispositivo sul dispositivo PiFace nella struttura del dispositivo. Il Raspberry SPI_PiFace libreria, che abilita la connessione, è a loro disposizione come codice sorgente. Può essere utilizzato come esempio per altre connessioni. Il Raspberry Pi Peripherals biblioteca è la base per la comunicazione tramite SPI. Le loro interfacce sono documentate sia nell'help che nel Library Manager. " }, 
{ "title" : "Controllo del modulo PiFace Digital tramite driver I\/O ", 
"url" : "_rtsl_linux_rbp_examples_piface.html#UUID-c604b911-bae8-3ccf-0ad8-13b30c6d647a_id_a539525ca8913fc0a864630d69208b-id-24768c9d66a164bcc0a864631df6fefb", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione di PiFace Digital \/ Controllo del modulo PiFace Digital tramite driver I\/O ", 
"snippet" : "Requisito: l'hardware di espansione PiFace Digital è collegato. Il PiFaceIoDrv.project Il progetto contiene un'applicazione che controlla un hardware I\/O digitale Raspberry PiFace con 8 ingressi e uscite digitali. Ma viene utilizzato un driver I\/O invece di un'istanza FB implicita. Il driver I\/O rea...", 
"body" : "Requisito: l'hardware di espansione PiFace Digital è collegato. Il PiFaceIoDrv.project Il progetto contiene un'applicazione che controlla un hardware I\/O digitale Raspberry PiFace con 8 ingressi e uscite digitali. Ma viene utilizzato un driver I\/O invece di un'istanza FB implicita. Il driver I\/O realizza lo scambio di ingressi e uscite come di consueto per i controllori tramite l'immagine di processo. Il IoDrvPiFace libreria contiene il driver I\/O come codice sorgente. " }, 
{ "title" : "Configurazione I 2 C ", 
"url" : "_rtsl_linux_rbp_examples_i2c.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione I 2 C ", 
"snippet" : "Requisito: l'hardware speciale è collegato tramite I²C. Il I2CExample.project project contiene un'applicazione che controlla vari chip e breakout collegati tramite I²C. Hardware collegato: PWM Adafruit a 16 canali\/12 bit SRF02 (sensore di distanza ad ultrasuoni) Drotek IMU 9DOF - MPU9150 (giroscopio...", 
"body" : "Requisito: l'hardware speciale è collegato tramite I²C. Il I2CExample.project project contiene un'applicazione che controlla vari chip e breakout collegati tramite I²C. Hardware collegato: PWM Adafruit a 16 canali\/12 bit SRF02 (sensore di distanza ad ultrasuoni) Drotek IMU 9DOF - MPU9150 (giroscopio, accelerometro, magnetoscopio) Il Raspberry I2C <name> le librerie, che abilitano la connessione, sono disponibili come codice sorgente. Possono essere usati come esempio per altre connessioni. Il Raspberry Pi Peripherals biblioteca è la base per la comunicazione tramite I²C. Le loro interfacce sono documentate sia nell'help che nel Library Manager. " }, 
{ "title" : "Configurazione del convertitore A\/D MPC3008 ", 
"url" : "_rtsl_linux_rbp_examples_mcp3008.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione del convertitore A\/D MPC3008 ", 
"snippet" : "Prerequisito: l'hardware speciale è collegato tramite SPI. Il MCP3008_Temperature.project project contiene un'applicazione che legge un sensore di temperatura analogico (LM35) collegato a un chip convertitore A\/D (MCP3008) tramite SPI. L'MCP3008 può valutare 8 canali analogici, ma in questo esempio ...", 
"body" : "Prerequisito: l'hardware speciale è collegato tramite SPI. Il MCP3008_Temperature.project project contiene un'applicazione che legge un sensore di temperatura analogico (LM35) collegato a un chip convertitore A\/D (MCP3008) tramite SPI. L'MCP3008 può valutare 8 canali analogici, ma in questo esempio ne viene utilizzato solo uno. Configurazione di prova: Il SPI_MCP3008 libreria, che abilita la connessione, è a loro disposizione come codice sorgente. Può essere utilizzato come esempio per altre connessioni. Il Raspberry Pi Peripherals biblioteca è la base per la comunicazione tramite SPI. Le loro interfacce sono documentate sia nell'help che nel Library Manager. " }, 
{ "title" : "Configurazione dell'Espansione Porta MCP23S17 ", 
"url" : "_rtsl_linux_rbp_examples_mcp23s17.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione dell'Espansione Porta MCP23S17 ", 
"snippet" : "Prerequisito: l'hardware speciale è collegato tramite SPI. Il MCP23S17.project il progetto contiene un'applicazione in cui un chip di espansione della porta (MCP23S17) è stato collegato tramite SPI. Nell'editor dei dispositivi è possibile configurare quali pin GPIO vengono utilizzati come ingressi o...", 
"body" : "Prerequisito: l'hardware speciale è collegato tramite SPI. Il MCP23S17.project il progetto contiene un'applicazione in cui un chip di espansione della porta (MCP23S17) è stato collegato tramite SPI. Nell'editor dei dispositivi è possibile configurare quali pin GPIO vengono utilizzati come ingressi o uscite. È inoltre possibile attivare una resistenza di pull-up per gli ingressi. A seconda dell'assegnazione dell'indirizzo IO pin, l'indirizzo hardware deve essere configurato di conseguenza. " }, 
{ "title" : "Configurazione 1 filo ", 
"url" : "_rtsl_linux_rbp_examples_1_wire.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione 1 filo ", 
"snippet" : "Requisito: è collegato un sensore di temperatura a 1 filo. Il OneWire.project project contiene un'applicazione che rileva i dispositivi collegati tramite 1-Wire. Inoltre viene controllato un sensore di temperatura tipo DS18B20. In questo caso, la linea dati 1-Wire è collegata a GPIO4. È possibile ut...", 
"body" : "Requisito: è collegato un sensore di temperatura a 1 filo. Il OneWire.project project contiene un'applicazione che rileva i dispositivi collegati tramite 1-Wire. Inoltre viene controllato un sensore di temperatura tipo DS18B20. In questo caso, la linea dati 1-Wire è collegata a GPIO4. È possibile utilizzare l'applicazione di avvio per rilevare l'ID. Funzionalità dell'applicazione di esempio: Cerca nella rete i dispositivi 1-Wire e visualizza gli ID dei dispositivi rilevati in una visualizzazione Misurare e visualizzare la temperatura del sensore se è presente un DS18B20 con un ID configurato correttamente tra i dispositivi rilevati. Lo scambio di dati tramite 1-Wire richiede molto tempo. Nel frattempo, l'attività è bloccata. Per le applicazioni critiche dal punto di vista temporale, assegnare l'applicazione dei dispositivi bus di campo 1-Wire a un'altra attività. È possibile assegnare attività nell'Editor dispositivi su Elenco delle attività scheda. " }, 
{ "title" : "Configurazione servomotore ", 
"url" : "_rtsl_linux_rbp_examples_softmotion_servo.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione servomotore ", 
"snippet" : "Requisito: una scheda PWM Adafruit a 16 canali\/12 bit è collegata tramite I²C e un servo modello è collegato al suo primo canale PWM. Il SoftMotion Servo Example.project progetto contiene un'applicazione in cui CODESYS SoftMotion viene utilizzato in combinazione con i servomotori modello. Come inter...", 
"body" : "Requisito: una scheda PWM Adafruit a 16 canali\/12 bit è collegata tramite I²C e un servo modello è collegato al suo primo canale PWM. Il SoftMotion Servo Example.project progetto contiene un'applicazione in cui CODESYS SoftMotion viene utilizzato in combinazione con i servomotori modello. Come interfaccia di comunicazione viene utilizzata una scheda di espansione (Adafruit ID 815) collegata tramite I²C. Apri il SoftMotion Servo Example.project progetto e aggiornarlo. Nella struttura dei dispositivi, fare doppio clic Dispositivo . Si apre l'editor del dispositivo. In Impostazioni di comunicazione , fare clic Scansione rete . Se il tuo Raspberry Pi e il sistema di sviluppo si trovano sulla stessa rete, il tuo Raspberry Pi viene visualizzato per la selezione. Selezionalo e fai clic In linea → Accedi . L'applicazione viene scaricata sul tuo Raspberry Pi. Avviare il programma (premere il F5 chiave). Il servomotore inizia a ruotare costantemente da sinistra a destra. Il PLC_PRG programma implementato in SFC è responsabile di questo. Attiva l'asse e quindi lo sposta tra le posizioni -60 e +60 specificate come posizioni finali in SM_Drive_Servo configurazione dell'asse. La posizione preimpostata viene trasportata tramite l'interfaccia PWM, come di consueto con i servi di modellazione. Un impulso ALTO, di durata compresa tra 1 e 2 ms, viene trasmesso con una frequenza fissa (default: 50 Hz; parametro del dispositivo Adafruit PWM SoftMotion). 1 ms corrisponde alla posizione finale inferiore e 2 ms alla posizione finale superiore. La gamma di movimento varia da tipo di motore a tipo di motore. Se il motore è controllato in gradi angolari, è necessario misurare il raggio di movimento. Per fare ciò, guidare fino alle posizioni finali (nell'esempio -60, +60) e inserire le posizioni misurate nella schermata di configurazione: Apri un qualsiasi browser (possibilmente su uno smartphone) e specifica l'indirizzo <network address>:8080\/webvisu.htm . La visualizzazione si apre e mostra la posizione specificata generata. Puoi controllare la velocità. " }, 
{ "title" : "Configurazione di EtherCAT ", 
"url" : "_rtsl_linux_rbp_examples_ethercat.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione di EtherCAT ", 
"snippet" : "Requisito: Il Beckhoff EK1100 con i dispositivi Beckhoff EL2008 è collegato all'adattatore Ethernet. Il EtherCAT.project project contiene un'applicazione in cui viene controllato un dispositivo bus di campo EtherCAT. Le otto uscite disponibili vengono attivate. Se si utilizza la porta LAN del Raspbe...", 
"body" : "Requisito: Il Beckhoff EK1100 con i dispositivi Beckhoff EL2008 è collegato all'adattatore Ethernet. Il EtherCAT.project project contiene un'applicazione in cui viene controllato un dispositivo bus di campo EtherCAT. Le otto uscite disponibili vengono attivate. Se si utilizza la porta LAN del Raspberry Pi per il bus di campo EtherCAT, è necessaria un'interfaccia di programmazione alternativa. Utilizzare un adattatore Wi-Fi USB come Edimax N150. Apri il EtherCAT.project progetto e aggiornarlo. Nella struttura dei dispositivi, fare doppio clic Dispositivo . Si apre l'editor del dispositivo. In Impostazioni di comunicazione , fare clic Scansione rete . Se il tuo Raspberry Pi e il sistema di sviluppo si trovano sulla stessa rete, il tuo Raspberry Pi viene visualizzato per la selezione. Selezionalo e fai clic In linea → Accedi . L'applicazione viene scaricata sul tuo Raspberry Pi. Avviare il programma (premere il F5 chiave). Le uscite del terminale EL2008 cambiano quindi continuamente. " }, 
{ "title" : "Configurazione di OPC UA ", 
"url" : "_rtsl_linux_rbp_examples_opc_ua.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione di OPC UA ", 
"snippet" : "Il OPCUA.project project contiene un'applicazione in cui le variabili sono configurate per accedere a un client OPC UA. Per fare ciò, le due variabili del PLC_PRG oggetto sono stati pubblicati nel Configurazione simboli oggetto. In un client OPC UA adatto, come Unified Automation UaExpert, puoi conn...", 
"body" : "Il OPCUA.project project contiene un'applicazione in cui le variabili sono configurate per accedere a un client OPC UA. Per fare ciò, le due variabili del PLC_PRG oggetto sono stati pubblicati nel Configurazione simboli oggetto. In un client OPC UA adatto, come Unified Automation UaExpert, puoi connetterti al tuo RaspberryPi tramite l'URL opc.tcp:\/\/<network address>:4840 . Nel client vengono visualizzati i suoi simboli (variabili pubblicate) e vengono visualizzati i valori correnti. Se l'autorizzazione di scrittura è concessa nella configurazione dei simboli, è possibile scrivere sui simboli. " }, 
{ "title" : "Configurazione di Sense HAT ", 
"url" : "_rtsl_linux_rbp_examples_sense_hat.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ Raspberry Pi \/ Esempi di progetti \/ Configurazione di Sense HAT ", 
"snippet" : "Requisito: è necessario il  Raspberry Pi  scheda aggiuntiva Sense HAT. Un  Raspberry Pi  con un Sense collegato La scheda aggiuntiva HAT è dotata di sensori per accelerazione, temperatura e pressione barometrica, nonché sensori per un giroscopio e un magnetometro. Pertanto è possibile creare, ad ese...", 
"body" : "Requisito: è necessario il  Raspberry Pi  scheda aggiuntiva Sense HAT. Un  Raspberry Pi  con un Sense collegato La scheda aggiuntiva HAT è dotata di sensori per accelerazione, temperatura e pressione barometrica, nonché sensori per un giroscopio e un magnetometro. Pertanto è possibile creare, ad esempio, una stazione meteorologica. Il progetto SenseHat.project fornisce un'applicazione per il funzionamento di una scheda aggiuntiva Sense HAT. Funzionalità dell'applicazione di esempio: Misura e visualizzazione dei dati del sensore Controllo dei sensori Controllo tramite joystick Interfaccia utente: " }, 
{ "title" : "PLCnext ", 
"url" : "_rtsl_plcnext.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ PLCnext ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Note specifiche dell'applicazione ", 
"url" : "_rtsl_plcnext_hints.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ PLCnext \/ Note specifiche dell'applicazione ", 
"snippet" : "Per ottimizzare i casi d'uso speciali, consigliamo le seguenti impostazioni dell'applicazione\/configurazione....", 
"body" : "Per ottimizzare i casi d'uso speciali, consigliamo le seguenti impostazioni dell'applicazione\/configurazione. " }, 
{ "title" : "Configurazione per caso d'uso: PROFINET ", 
"url" : "_rtsl_plcnext_hints.html#UUID-1e21ef99-5642-2ae9-585e-0f712913f733_section-idm4605464568745633478907338798", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ PLCnext \/ Note specifiche dell'applicazione \/ Configurazione per caso d'uso: PROFINET ", 
"snippet" : "Quando si usa PROFINET , è necessario osservare le seguenti istruzioni: Quando possibile, utilizzare la funzionalità multicore di CODESYS . Quando lo fai, usa core 0 for PROFINET compiti. Se possibile, utilizzare un adattatore di rete separato per PROFINET connessione. Se vuoi essere sicuro che il t...", 
"body" : "Quando si usa PROFINET , è necessario osservare le seguenti istruzioni: Quando possibile, utilizzare la funzionalità multicore di CODESYS . Quando lo fai, usa core 0 for PROFINET compiti. Se possibile, utilizzare un adattatore di rete separato per PROFINET connessione. Se vuoi essere sicuro che il tuo bus di campo continui a inviare e ricevere frame anche quando l'applicazione viene arrestata, abilita il Aggiorna I\/O in Stop opzione nelle impostazioni del PLC. " }, 
{ "title" : "Configurazione per caso utente: Axioline ", 
"url" : "_rtsl_plcnext_hints.html#UUID-1e21ef99-5642-2ae9-585e-0f712913f733_section-idm458155578255363347890799443", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ PLCnext \/ Note specifiche dell'applicazione \/ Configurazione per caso utente: Axioline ", 
"snippet" : "Quando si utilizza Axioline, è necessario osservare le seguenti istruzioni: Quando possibile, utilizzare la funzionalità multicore di CODESYS . In tal caso, utilizzare il core 1 per il task Axioline e il task del ciclo del bus. Alcuni moduli Axioline del controllore PLCNext dispongono di informazion...", 
"body" : "Quando si utilizza Axioline, è necessario osservare le seguenti istruzioni: Quando possibile, utilizzare la funzionalità multicore di CODESYS . In tal caso, utilizzare il core 1 per il task Axioline e il task del ciclo del bus. Alcuni moduli Axioline del controllore PLCNext dispongono di informazioni aggiuntive denominate \"oggetti PDI\". È possibile accedere a queste informazioni tramite IoDrvPLCNextAxioLib.PdiRead E IoDrvPLCNextAxioLib.PdiWrite . " }, 
{ "title" : "CODESYS Virtual Control for Linux SL ", 
"url" : "_rtsl_codesys_virtual_for_linux_control_sl.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ CODESYS Virtual Control for Linux SL ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Panoramica ", 
"url" : "_rtsl_virtual_control_sl_overview.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ CODESYS Virtual Control for Linux SL \/ Panoramica ", 
"snippet" : "IL CODESYS Virtual Control for Linux SL il componente aggiuntivo può essere utilizzato per gestire il runtime virtuale e le istanze del gateway. Un sistema di runtime virtuale è basato sulla tecnologia dei container Docker o Podman. Ad esempio, Docker distingue tra un'immagine e un contenitore. Un'i...", 
"body" : "IL CODESYS Virtual Control for Linux SL il componente aggiuntivo può essere utilizzato per gestire il runtime virtuale e le istanze del gateway. Un sistema di runtime virtuale è basato sulla tecnologia dei container Docker o Podman. Ad esempio, Docker distingue tra un'immagine e un contenitore. Un'immagine è il modello per un contenitore che esegue un processo incapsulato dal resto del sistema. L'incapsulamento consente di eseguire più contenitori contemporaneamente sullo stesso sistema, indipendentemente dall'hardware. CODESYS Virtual Control for Linux SL utilizza queste funzionalità per fornire un controller indipendente dall'hardware. Troverai descrizioni su come utilizzare lo strumento \"Runtime Deploy\" per trasferire le immagini al sistema di destinazione, creare istanze dalle immagini e gestire queste istanze. Controller basati su containerAvvio del sistema runtimeStabilire una connessione a un'istanza CODESYS Virtual Control SL " }, 
{ "title" : "Stabilire una connessione a un'istanza ", 
"url" : "_rtsl_extablish_connection_to_instance.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ CODESYS Virtual Control for Linux SL \/ Stabilire una connessione a un'istanza ", 
"snippet" : "Stabilire una connessione diretta a un'istanza di runtime Il port forwarding consente di connettersi direttamente alle istanze di runtime. Ciò non richiede altre istanze oltre all'istanza di runtime. Requisiti La porta dell'istanza di runtime per la comunicazione diretta ( 11740 ) deve essere inoltr...", 
"body" : "Stabilire una connessione diretta a un'istanza di runtime Il port forwarding consente di connettersi direttamente alle istanze di runtime. Ciò non richiede altre istanze oltre all'istanza di runtime. Requisiti La porta dell'istanza di runtime per la comunicazione diretta ( 11740 ) deve essere inoltrato. Appunti: Questa non è la configurazione predefinita per un'istanza di runtime, ma l'istanza deve essere configurata successivamente. La configurazione multipla della stessa porta sullo stesso dispositivo di destinazione non è possibile. Tuttavia, è possibile utilizzare la porta libera successiva per la seconda istanza di runtime. Esempio: 11741:11740 Esiste un gateway configurato e raggiungibile. Questo gateway non deve trovarsi sulla stessa rete. Sul Comunicazione scheda, selezionare un gateway attivo. Quindi, sul lato del dispositivo da connettere, inserisci l'indirizzo IP del sistema host che esegue l'istanza di runtime, seguito dalla porta inoltrata. Scheda: Comunicazione : Istanza del gateway sul dispositivo di destinazione È possibile utilizzare un'istanza del gateway per stabilire un CODESYS connessione alle istanze di runtime. Requisiti: La porta dell'istanza del gateway per la comunicazione del gateway ( 1217 ) deve essere inoltrato. Questa è la configurazione predefinita per un'istanza del gateway. Le istanze di gateway e runtime devono trovarsi sulla stessa rete di container. Questa è la configurazione predefinita. Ora, per connetterti a un'istanza in esecuzione, crea un nuovo file CODESYS progetto con il CODESYS Virtual Control for Linux SL dispositivo. Crea un nuovo gateway. Per il nuovo gateway, specifica l'indirizzo IP del tuo computer host dove CODESYS Virtual Control for Linux SL sta correndo nel Indirizzo IP campo del Portale dialogo. Seleziona il nuovo gateway ed esegui una scansione della rete. Vengono visualizzate le istanze runtime configurate e avviate. " }, 
{ "title" : "Configurazione: CODESYS Virtual Control for Linux SL ", 
"url" : "_rtsl_reference.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ CODESYS Virtual Control for Linux SL \/ Configurazione: CODESYS Virtual Control for Linux SL ", 
"snippet" : "Impostazione delle opzioni per le istanze Configurazione Valore Descrizione Avvio automatico TRUE o FALSE Avvio automatico dell'istanza all'avvio\/avvio del dispositivo di destinazione. Le dipendenze vengono risolte e le istanze vengono avviate nell'ordine corretto Funzionalità Elenco separato da vir...", 
"body" : "Impostazione delle opzioni per le istanze Configurazione Valore Descrizione Avvio automatico TRUE o FALSE Avvio automatico dell'istanza all'avvio\/avvio del dispositivo di destinazione. Le dipendenze vengono risolte e le istanze vengono avviate nell'ordine corretto Funzionalità Elenco separato da virgole, ad esempio: cap_sys_admin, cap_sched, cap_chown, cap_ipc_lock Autorizzazioni per l'istanza sul dispositivo di destinazione. La preselezione è necessaria per la conformità in tempo reale. Per le impostazioni Docker, vedi: Docker docks: Runtime Privilege e funzionalità Linux Dipendenze Corda Elenco di istanze separate da virgole da cui dipende l'istanza corrente. Di conseguenza, le istanze elencate qui vengono avviate in anticipo per rendere disponibile la memoria condivisa. Se l'istanza specificata non esiste, viene emesso un messaggio di errore Inst_B,Inst_C Se l'istanza corrente (ad esempio, Inst_A ) viene avviato con Inizio selezionato comando, quindi viene visualizzato un avviso che indica che Inst_B e Inst_C devono anche essere avviati. Quando ciò è confermato, vengono avviate prima queste due istanze e poi Instance_A istanza. Nome host Corda Nome di rete dell'istanza Il valore predefinito è il nome dell'istanza. Immagine Corda Immagine utilizzata per l'istanza IPC Corda Fondamentalmente, tutti i valori specificati anche nel Docker Docs per il campo sono consentiti. Il campo viene convalidato solo quando contiene container: prefisso. Secondo Docker Docs, viene utilizzato per utilizzare una memoria condivisa esistente («join»). Questa memoria condivisa deve essere creata sull'istanza denominata container: utilizzando il shareable parola chiave. Per assicurarsi che la memoria condivisa sia disponibile all'avvio dell'istanza, è necessario definire una dipendenza corrispondente sull'istanza inserita dopo container: prefisso. condivisibile nessuna container:Inst_first Server di licenze Corda Indirizzi IP dei server di licenza Specificato in un elenco separato da virgole Esempio: 192.168.0.1,10.0.0.1,172.17.0.2 Supporti Elenco separato da virgole Monta l'istanza sull'host. Da specificare nella sintassi Host path:Instance path Note: I percorsi sono assoluti. Il percorso host contiene i nomi delle istanze. Per i montaggi predefiniti (dati\/conf), questo percorso non deve essere modificato Rete Corda Rete in cui l'istanza verrà montata sull'host. Vedi: Docker docs: impostazioni di rete Nota: è possibile specificare una sola rete. Docker networks allow containers to communicate with each other. If the configured Docker network does not exist yet, then a new one will be created. The IP address of the respective instance within this network can be configured via the Nic field. For more information about Docker networks, see the Docker documentation . Nic Corda Configurazione degli adattatori di rete del sistema di destinazione assegnati esclusivamente a un'istanza. Questa configurazione è necessaria quando devono essere utilizzati bus di campo basati su Ethernet Per la configurazione viene utilizzato il seguente formato: <Nic>\/<IP>\/<network mask>,<Nic2>\/<IP2>\/<network mask2>,... È possibile specificare più adattatori di rete con un elenco separato da virgole. Esempi: Configurazione desiderata Configurazione «Nic» NIC : eno1 IP : 192.168.0.100 Maschera: 255.255.255.0 → \/24 eno1\/192.168.0.100\/24 NIC : eno1 IP : - Maschera: - NIC2 : eno2 IP2 : 192.168.0.100 Maschera 2: 255.255.248.0 → \/21 eno1,eno2\/102.168.0.100\/21 NIC : eno1 IP : - Maschera: - NIC2 : eno2 IP2 : - Maschera 2: - eno1,2eno2 Note: Un adattatore può essere assegnato a una sola istanza. Di conseguenza, anche questo adattatore non è più disponibile sul sistema di destinazione. L'indirizzo IP deve essere specificato insieme alla maschera di rete corrispondente. La maschera di rete è specificata con un suffisso (esempio: «\/24\" o «\/21\"). Non è possibile assegnare più indirizzi IP a un adattatore. Porte Elenco separato da virgole, ad esempio: 1217:1217, 8081:8080 Porte utilizzate dall'istanza di runtime Da specificare nella sintassi HostPort:InstancePort (elenco separato da virgole) Nota: una porta host non può essere assegnata più di una volta. Per i casi d'uso o le porte più comuni, vedere: CODESYS ControlEsempi: Gateway 1217. Webvisu (https) 443, OPC UA 4840 Tipo di prodotto Runtime \/ Gateway Tipo di prodotto: Runtime o Gateway Questo valore non può essere modificato. Tecnologia Docker \/ Podman Tecnologia container utilizzata nel sistema di destinazione Questo valore non può essere modificato. Avvio successivo in modalità manutenzione TRUE o FALSE Only for CODESYS Virtual Edge Gateway for Linux and CODESYS Edge Gateway for Linux This setting determines whether or not the Edge Gateway is started in maintenance mode. In this mode, a connection between the Edge Gateway and the Automation Server can be configured using the CODESYS Automation Server Connector . Usa questa modalità solo in un ambiente sicuro. Questa modalità viene disattivata dopo 30 minuti, al riavvio del gateway o al termine della configurazione. " }, 
{ "title" : "CODESYS TargetVisu for Linux SL ", 
"url" : "_rtsl_target_visu_for_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ CODESYS TargetVisu for Linux SL ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Configurazione CODESYS TargetVisu for Linux SL ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234374412744104", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ CODESYS TargetVisu for Linux SL \/ Configurazione CODESYS TargetVisu for Linux SL ", 
"snippet" : "Per impostazione predefinita, la visualizzazione di destinazione mostra diverse finestre di dialogo all'avvio per ottenere le informazioni necessarie per stabilire una connessione al controller. Queste informazioni vengono salvate e possono essere modificate o eliminate in un secondo momento mediant...", 
"body" : "Per impostazione predefinita, la visualizzazione di destinazione mostra diverse finestre di dialogo all'avvio per ottenere le informazioni necessarie per stabilire una connessione al controller. Queste informazioni vengono salvate e possono essere modificate o eliminate in un secondo momento mediante la configurazione della visualizzazione di destinazione inoltre possibile definire questi parametri prima di iniziare la visualizzazione per la prima volta. Dopodiché, le finestre di dialogo non vengono più visualizzate all'avvio della visualizzazione Impostazioni Applicazione Il nome dell'applicazione in cui è in esecuzione la visualizzazione Password CODESYS Password del CODESYS utente con cui la visualizzazione accede al controller. Utente CODESYS Nome utente con cui la visualizzazione accede al controller. Nome host Il nome host del PLC a cui si connette la visualizzazione. Il nome può essere determinato sulla maggior parte delle distribuzioni Linux utilizzando hostname comando. Per connettersi a un controller sull'attuale dispositivo di destinazione, è necessario definire qui il nome host di questo PLC Richiedi impostazioni su Next Start Le impostazioni vengono ripristinate e la visualizzazione del target richiederà tutte le informazioni nelle finestre di dialogo corrispondenti al successivo avvio. " }, 
{ "title" : "Avvio automatico ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234374413098957", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ CODESYS TargetVisu for Linux SL \/ Avvio automatico ", 
"snippet" : "Dopo aver riavviato il dispositivo di destinazione, la visualizzazione di destinazione si apre automaticamente. Potrebbe volerci fino a un minuto per caricare tutti i moduli e visualizzare l'applicazione. La prima volta che viene stabilita una connessione con il PLC, potrebbe volerci un po' più di t...", 
"body" : "Dopo aver riavviato il dispositivo di destinazione, la visualizzazione di destinazione si apre automaticamente. Potrebbe volerci fino a un minuto per caricare tutti i moduli e visualizzare l'applicazione. La prima volta che viene stabilita una connessione con il PLC, potrebbe volerci un po' più di tempo perché le risorse utilizzate nella visualizzazione devono essere trasferite la prima volta. " }, 
{ "title" : "Prima CODESYS TargetVisu for Linux SL versione 4.13.0.0 ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234461986157731", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ CODESYS TargetVisu for Linux SL \/ Avvio automatico \/ Prima CODESYS TargetVisu for Linux SL versione 4.13.0.0 ", 
"snippet" : "L'avvio automatico è implementato da un .desktop file. Ci sono 2 modi per installare il pacchetto: Salva il codesysvisualization.desktop archiviare \/etc\/xdg\/autostart\/ Allega lo script di avvio in ~\/.xinitrc o in alternativa in \/etc\/X11\/xinit Se queste directory non esistono sul tuo sistema o non ci...", 
"body" : "L'avvio automatico è implementato da un .desktop file. Ci sono 2 modi per installare il pacchetto: Salva il codesysvisualization.desktop archiviare \/etc\/xdg\/autostart\/ Allega lo script di avvio in ~\/.xinitrc o in alternativa in \/etc\/X11\/xinit Se queste directory non esistono sul tuo sistema o non ci lavori, allora devi configurare tu stesso l'avvio automatico. Gli script di avvio e arresto si trovano in \/opt\/codesysvisualization\/scripts Per ulteriori informazioni sulla struttura delle directory, vedere: https:\/\/content.helpme-codesys.com\/de\/CODESYS Control\/_rtsl_linux_installation_without_pm.html CODESYS TargetVisu for Linux SL non modifica il comportamento di accesso dell'account Linux corrente. Se il tuo account Linux ha disattivato l'accesso automatico, l'autenticazione è comunque richiesta per avviare la visualizzazione. " }, 
{ "title" : "In CODESYS TargetVisu for Linux SL versione 4.13.0.0 e successive ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234461987255572", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Configurazione specifica del prodotto \/ CODESYS TargetVisu for Linux SL \/ Avvio automatico \/ In CODESYS TargetVisu for Linux SL versione 4.13.0.0 e successive ", 
"snippet" : "L'avvio automatico è implementato da systemd Il file dell'unità si trova sotto ~\/.config\/systemd\/user\/codesysvisualization.service Per configurare autonomamente l'avvio automatico, puoi disattivare il servizio in modo permanente con systemctl --user disable codesysvisualization oppure modificare il ...", 
"body" : "L'avvio automatico è implementato da systemd Il file dell'unità si trova sotto ~\/.config\/systemd\/user\/codesysvisualization.service Per configurare autonomamente l'avvio automatico, puoi disattivare il servizio in modo permanente con systemctl --user disable codesysvisualization oppure modificare il file dell'unità e ricaricarlo con systemctl --user daemon-reload . " }, 
{ "title" : "CODESYS Virtual Safe Control for Linux SL ", 
"url" : "_rtsl_codesys_virtual_for_linux_control_sl-1825956.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Control for Linux SL ", 
"snippet" : "Le CODESYS Virtual Safe Control for Linux SL è un controller indipendente dall'hardware e funzionalmente sicuro che funziona come un sistema di runtime indipendente parallelo a quello funzionale CODESYS Virtual Control SL controllore. Tieni presente che questa documentazione viene fornita solo a sco...", 
"body" : "Le CODESYS Virtual Safe Control for Linux SL è un controller indipendente dall'hardware e funzionalmente sicuro che funziona come un sistema di runtime indipendente parallelo a quello funzionale CODESYS Virtual Control SL controllore. Tieni presente che questa documentazione viene fornita solo a scopo informativo. Per le restrizioni e le informazioni sulla sicurezza e la certificazione, si prega di fare riferimento al manuale di sicurezza H1 – SafetyManual.pdf . Quando si utilizza il CODESYS Virtual Safe Control for Linux SL , devono essere rispettati i requisiti di sicurezza del white paper sulla sicurezza. Per ulteriori informazioni, vedere: White paper sulla sicurezza di CODESYS Per ulteriori informazioni sullo sviluppo di applicazioni critiche per la sicurezza con CODESYS , vedere: Manuale di sicurezza H1 – SafetyManual.pdf , memorizzato nella directory ..\/<user>\/CODESYS Virtual Safe Control Linux SL\/Delivery\/Manuals CODESYS Safety Extension Istruzioni su come configurare inizialmente CODESYS Virtual Safe Control for Linux SL sono descritti nello scenario Scenario «La casa sicura»: vPLC + vSafe + PROFIsafe + Time Provider + License Server. " }, 
{ "title" : "Eccezioni relative al timestamp ", 
"url" : "_rtsl_timestamp_exceptions.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Control for Linux SL \/ Eccezioni relative al timestamp ", 
"snippet" : "La sezione seguente descrive gli errori che possono verificarsi durante la convalida del comportamento temporale del controller sicuro. È necessaria una seconda base temporale indipendente per convalidare il comportamento temporale....", 
"body" : "La sezione seguente descrive gli errori che possono verificarsi durante la convalida del comportamento temporale del controller sicuro. È necessaria una seconda base temporale indipendente per convalidare il comportamento temporale. " }, 
{ "title" : "I diversi timestamp ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm234959765203734", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Control for Linux SL \/ Eccezioni relative al timestamp \/ I diversi timestamp ", 
"snippet" : "Vengono utilizzati tre timestamp per convalidare il comportamento temporale del controller sicuro. Remote Timestamp : Timestamp ricavato dal computer del fornitore dell'orario. Sample Timestamp : Timestamp acquisito localmente al momento del ricevimento. Local Timestamp : Timestamp acquisito localme...", 
"body" : "Vengono utilizzati tre timestamp per convalidare il comportamento temporale del controller sicuro. Remote Timestamp : Timestamp ricavato dal computer del fornitore dell'orario. Sample Timestamp : Timestamp acquisito localmente al momento del ricevimento. Local Timestamp : Timestamp acquisito localmente al momento dell'esecuzione dell'applicazione. " }, 
{ "title" : "Possibili messaggi di errore ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm234959951496687", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Control for Linux SL \/ Eccezioni relative al timestamp \/ Possibili messaggi di errore ", 
"snippet" : "Tutti gli errori del time provider restituiscono quattro valori numerici esadecimali. Si tratta di valori temporali in microsecondi. Hanno i seguenti significati: Valore 1: tempo tra gli ultimi due Local Timestamps Valore 2: tempo tra gli ultimi due Remote Timestamps Valore 3: tempo tra gli ultimi d...", 
"body" : "Tutti gli errori del time provider restituiscono quattro valori numerici esadecimali. Si tratta di valori temporali in microsecondi. Hanno i seguenti significati: Valore 1: tempo tra gli ultimi due Local Timestamps Valore 2: tempo tra gli ultimi due Remote Timestamps Valore 3: tempo tra gli ultimi due Sample Timestamps Valore 4: Tempo che intercorre tra il ricevimento dell'ultimo Remote Timestamps e valutazione di questo timestamp L'ordine dei valori corrisponde all'ordine nel messaggio di errore. Ci sono 3 possibili messaggi di errore durante la convalida del tempo. Di seguito è riportata una descrizione del controllo che causa questo errore, dell'errore che si verifica e di alcune possibili cause dell'errore. Solo il primo errore che si è verificato viene registrato nel Tab Log perché l'applicazione IEC è già stata interrotta dopo questo errore. Per analizzare la causa dell'errore in modo più dettagliato, è possibile visualizzare i quattro valori numerici esadecimali emessi con il messaggio di errore. " }, 
{ "title" : "Messaggio: Plausibility check of the local timestamp to the cycle time ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm43495995265356", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Control for Linux SL \/ Eccezioni relative al timestamp \/ Possibili messaggi di errore \/ Messaggio: Plausibility check of the local timestamp to the cycle time ", 
"snippet" : "Verifica: Confronto tra il tempo di ciclo impostato e il tempo effettivo trascorso dall'ultimo ciclo. La Local Timestamp viene utilizzato per questo. Errore: La misurazione interna del tempo, che avviene ad ogni ciclo, mostra che il tempo trascorso (in base all'orologio interno del computer) si disc...", 
"body" : "Verifica: Confronto tra il tempo di ciclo impostato e il tempo effettivo trascorso dall'ultimo ciclo. La Local Timestamp viene utilizzato per questo. Errore: La misurazione interna del tempo, che avviene ad ogni ciclo, mostra che il tempo trascorso (in base all'orologio interno del computer) si discosta di oltre il 5% dal tempo di ciclo impostato. Cause comuni: Problemi con la pianificazione dell'applicazione sicura. " }, 
{ "title" : "Messaggio: Plausibility check of the remote timestamp to the cycle time ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm43495995331862", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Control for Linux SL \/ Eccezioni relative al timestamp \/ Possibili messaggi di errore \/ Messaggio: Plausibility check of the remote timestamp to the cycle time ", 
"snippet" : "Verifica: Confronto del tempo di ciclo impostato con il periodo tra gli ultimi due Sample Timestamps . Sample Timestamp viene utilizzato. Viene sempre utilizzato l'ultimo timestamp valido ricevuto in un ciclo. I precedenti vengono eliminati. Ciò significa che un timestamp non valido non causa immedi...", 
"body" : "Verifica: Confronto del tempo di ciclo impostato con il periodo tra gli ultimi due Sample Timestamps . Sample Timestamp viene utilizzato. Viene sempre utilizzato l'ultimo timestamp valido ricevuto in un ciclo. I precedenti vengono eliminati. Ciò significa che un timestamp non valido non causa immediatamente un errore di sistema. Errore: Non nuovo Remote Timestamp è stato ricevuto per più di un ciclo. Cause comuni: Fornitore orario inattivo o interrotto Nessuna connessione di rete tra controller e time provider Errore di rete Gravi problemi di pianificazione " }, 
{ "title" : "Messaggio: Plausibility check of remote timestamp to local timestamp ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm43495995376508", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Control for Linux SL \/ Eccezioni relative al timestamp \/ Possibili messaggi di errore \/ Messaggio: Plausibility check of remote timestamp to local timestamp ", 
"snippet" : "Verifica: Confronto dell'intervallo tra gli ultimi due Sample Timestamps utilizzato e l'intervallo tra gli ultimi due Remote Timestamps usato. Sample Timestamp e il Remote Timestamp vengono utilizzati. Errore: La differenza tra l'intervallo tra gli ultimi due Sample Timestamps e l'intervallo tra gli...", 
"body" : "Verifica: Confronto dell'intervallo tra gli ultimi due Sample Timestamps utilizzato e l'intervallo tra gli ultimi due Remote Timestamps usato. Sample Timestamp e il Remote Timestamp vengono utilizzati. Errore: La differenza tra l'intervallo tra gli ultimi due Sample Timestamps e l'intervallo tra gli ultimi due Remote Timestamps è superiore alla tolleranza consentita del 5%. Cause comuni: Problemi di pianificazione con il fornitore di orari Problemi di pianificazione del thread per la ricezione dei timestamp Ritardi nella rete di trasmissione (interruttori, ecc.) " }, 
{ "title" : "Avvio dell'applicazione ", 
"url" : "_rtsl_application_start.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Control for Linux SL \/ Avvio dell'applicazione ", 
"snippet" : "Per CODESYS Virtual Safe Control SL, l'avvio dell'applicazione di avvio deve essere confermato dall'utente. Nel CODESYS Safety Extension versione 4.3.0.0 e successive, il nuovo stato ( waiting for confirmation ) viene visualizzato nell'albero del progetto e nello stato dell'applicazione attiva. Con ...", 
"body" : "Per CODESYS Virtual Safe Control SL, l'avvio dell'applicazione di avvio deve essere confermato dall'utente. Nel CODESYS Safety Extension versione 4.3.0.0 e successive, il nuovo stato ( waiting for confirmation ) viene visualizzato nell'albero del progetto e nello stato dell'applicazione attiva. Con CODESYS Safety Extension inferiore alla versione 4.3.0.0, lo stato non viene visualizzato né nell'albero dei dispositivi né nello stato. Tuttavia, lo stato può essere preso dal registro del controller sicuro Le Avvia BootApp il blocco funzione viene utilizzato per confermare l'avvio dell'applicazione di avvio scaricata Condizioni per l'avvio dell'applicazione di avvio: Il valore attuale dell'uscita FB SafeApplication.BootAppConfirmation deve essere trasferito al StartBootApp blocco funzionale. necessario specificare un ClientID. Il clientID è definito nel file CFG del sistema di runtime Impostazione predefinita per l'applicazione standard: 16#ED387206 . Il clientID, la versione del firmware, l'AppID e il valore di SafeApplication.BootAppConfirmtion deve essere inviato al controller. Questa operazione viene eseguita con StartBootApp blocco funzionale. Per ulteriori informazioni, vedere: Estensione di sicurezza CODESYS . " }, 
{ "title" : "CODESYS Virtual Safe Time Provider ", 
"url" : "_rtsl_virtual_safe_time_provider.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Time Provider ", 
"snippet" : "IL CODESYS Virtual Safe Time Provider è un'interfaccia standard che l'utente può utilizzare per trasferire una seconda base temporale esterna al CODESYS Virtual Safe Control . L'implementazione avviene come client, che deve essere eseguito su un altro sistema con una base temporale indipendente....", 
"body" : "IL CODESYS Virtual Safe Time Provider è un'interfaccia standard che l'utente può utilizzare per trasferire una seconda base temporale esterna al CODESYS Virtual Safe Control . L'implementazione avviene come client, che deve essere eseguito su un altro sistema con una base temporale indipendente. " }, 
{ "title" : "Installazione ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964887312564", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Time Provider \/ Installazione ", 
"snippet" : "IL CODESYS Virtual Safe Time Provider SL viene installato tramite CODESYS Control SL Deploy Tool Per ulteriori informazioni, vedere: Scenario «La casa sicura»: vPLC + vSafe + PROFIsafe + Time Provider + License Server. IL CODESYS Virtual Safe Time Provider SL non deve essere eseguito sullo stesso ho...", 
"body" : "IL CODESYS Virtual Safe Time Provider SL viene installato tramite CODESYS Control SL Deploy Tool Per ulteriori informazioni, vedere: Scenario «La casa sicura»: vPLC + vSafe + PROFIsafe + Time Provider + License Server. IL CODESYS Virtual Safe Time Provider SL non deve essere eseguito sullo stesso host del CODESYS Virtual Safe Control SL. " }, 
{ "title" : "Funzionalità ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964887538634", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Time Provider \/ Funzionalità ", 
"snippet" : "IL Time Provider serve come una seconda fonte temporale per il CODESYS Virtual Safe Control SL e invia un timestamp come messaggio tramite la rete a intervalli definiti. Questo messaggio può quindi essere ricevuto e valutato da diversi ricevitori ( CODESYS Virtual Safe Control l SL, ridondante Time ...", 
"body" : "IL Time Provider serve come una seconda fonte temporale per il CODESYS Virtual Safe Control SL e invia un timestamp come messaggio tramite la rete a intervalli definiti. Questo messaggio può quindi essere ricevuto e valutato da diversi ricevitori ( CODESYS Virtual Safe Control l SL, ridondante Time Provider ). IL CODESYS Virtual Safe Control SL esegue l'applicazione con un tempo di ciclo definito in cui deve arrivare almeno un timestamp da un timer esterno. L'intervallo di invio del Time Provider dovrebbe essere configurato in modo da essere inferiore alla metà del tempo di ciclo dell'applicazione. Per aumentare la stabilità dovuta a problemi di rete o di programmazione del Time Provider e quindi il CODESYS Virtual Safe Control SL, il Time Provider può essere eseguito in modo ridondante. Si distingue tra due tipi. " }, 
{ "title" : "Time Provider ridondanza ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm43496653769816", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Time Provider \/ Funzionalità \/ Time Provider ridondanza ", 
"snippet" : "In caso di Time Provider ridondanza, due Time Provider Le istanze vengono eseguite su due host indipendenti. Un'istanza funge da mittente attivo e l'altra monitora passivamente l'invio dei timestamp. Per utilizzare la funzionalità, due Time Provider le istanze vengono avviate e il parametro di ridon...", 
"body" : "In caso di Time Provider ridondanza, due Time Provider Le istanze vengono eseguite su due host indipendenti. Un'istanza funge da mittente attivo e l'altra monitora passivamente l'invio dei timestamp. Per utilizzare la funzionalità, due Time Provider le istanze vengono avviate e il parametro di ridondanza deve essere impostato su TRUE in entrambi i casi. Non appena l'invio del timestamp dell'istanza attiva viene ritardato o non avviene, l'istanza passiva subentra immediatamente nell'invio con l'ultimo offset noto dell'istanza attiva. Ciò significa che non si verificano errori di CODESYS Virtual Safe Control SL. È importante che entrambe le istanze funzionino sulla stessa rete. Solo allora l'istanza passiva può monitorare i messaggi inviati dall'istanza attiva. Se un attivo Time Provider in una rete rileva un'altra istanza attiva sul bus, quindi l'istanza con l'indirizzo IP di priorità più alta rimane attiva e tutte le altre istanze passano in modalità passiva. " }, 
{ "title" : "Ridondanza di rete ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm43496653810142", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Time Provider \/ Funzionalità \/ Ridondanza di rete ", 
"snippet" : "In caso di ridondanza di rete, il Time Provider le istanze utilizzano ciascuna la propria rete, a differenza di Time Provider ridondanza. Tuttavia, è necessario che il passivo Time Provider istanza per ricevere i messaggi dall'istanza attiva in modo da subentrare nell'invio in caso di ritardo o erro...", 
"body" : "In caso di ridondanza di rete, il Time Provider le istanze utilizzano ciascuna la propria rete, a differenza di Time Provider ridondanza. Tuttavia, è necessario che il passivo Time Provider istanza per ricevere i messaggi dall'istanza attiva in modo da subentrare nell'invio in caso di ritardo o errore. La ridondanza di rete non è ancora stata implementata. " }, 
{ "title" : "Configurazione ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964888427036", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Time Provider \/ Configurazione ", 
"snippet" : "Opzione Descrizione Valore predefinito -a\/--address Indirizzo IP di destinazione 127.0.0.1 (host locale) -p\/--port Porto di destinazione 60000 -c\/--cycletime Intervallo di invio del Time Provider timestamp in [ms] 3 -P\/--priority Priorità di pianificazione SCHED_FIFO 55 -C\/--cpu_pin Pinning della CP...", 
"body" : "Opzione Descrizione Valore predefinito -a\/--address Indirizzo IP di destinazione 127.0.0.1 (host locale) -p\/--port Porto di destinazione 60000 -c\/--cycletime Intervallo di invio del Time Provider timestamp in [ms] 3 -P\/--priority Priorità di pianificazione SCHED_FIFO 55 -C\/--cpu_pin Pinning della CPU Tutti i thread sono associati a una CPU definita, a partire dal valore 0. 0 -r\/--redundancy Modalità di ridondanza Quando è disabilitato, il Time Provider invia immediatamente i timestamp. Quando è abilitato, Time Provider invia solo se non c'è altra priorità più alta Time Provider sta inviando. Per ulteriori informazioni, vedere quanto segue: Time ProviderDisabili -s\/--syslog Registrazione del syslog A \/dev\/log Disabili --stat_print_time Intervallo di diagnosi in [s] 60 Il valore predefinito dell'indirizzo IP è 127.0.0.1 (localhost). Si consiglia di utilizzare questo valore solo per la messa in servizio e i test. Time Provider fornisce una base temporale indipendente e pertanto non deve essere utilizzato localmente. Se si utilizza il valore predefinito, Time Provider emette un avviso. " }, 
{ "title" : "Diagnosi ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964888678287", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ CODESYS Virtual Safe Time Provider \/ Diagnosi ", 
"snippet" : "Gli errori che possono verificarsi durante la valutazione dei timestamp sulla pagina del CODESYS Virtual Safe Control SL: La porta configurata è già in uso. Se la porta configurata è già in uso e non può essere aperta, viene visualizzato il seguente messaggio: Could not open port <Port number> it is...", 
"body" : "Gli errori che possono verificarsi durante la valutazione dei timestamp sulla pagina del CODESYS Virtual Safe Control SL: La porta configurata è già in uso. Se la porta configurata è già in uso e non può essere aperta, viene visualizzato il seguente messaggio: Could not open port <Port number> it is already in use! L'invio del timestamp nell'istanza attiva è ritardato o non avviene. Se un timestamp del mittente attivo viene ritardato o non viene inviato e un mittente passivo Time Provider l'istanza prende il controllo dell'invio, quindi viene emesso il seguente messaggio diagnostico: Started sending: take over from higher priority time provider <priority> Quando la priorità più alta Time Provider l'istanza è nuovamente disponibile e riprende l'invio dalla precedente istanza passiva, viene emesso il seguente messaggio: Stopped sending: higher priority time provider is active: <priority> Statistiche cicliche sui timestamp (istanza attiva\/mittente) Le statistiche per i timestamp inviati vengono emesse all'intervallo configurato ( -stat_print_time opzione) nella risoluzione di microsecondi [us]. Viene emesso l'intervallo di invio minimo e massimo, nonché un valore medio sul periodo configurato: Statistics: min: <minimum sending interval>, max: <maximum sending interval>, avg: <average sending interval> - send time interval Statistiche cicliche sui timestamp (istanza passiva\/ricevitore) Poiché l'istanza passiva riceve i timestamp inviati dall'istanza attiva, le informazioni ricevute possono essere valutate a fini diagnostici. Le statistiche vengono emesse all'intervallo configurato ( -stat_print_time opzione) nella risoluzione di microsecondi [us] e percentuali [%]. Viene emesso l'intervallo minimo e massimo, nonché un valore medio sul periodo configurato: Statistics: min: <minimum deviation>, max: <maximum deviation>, avg: <average deviation> - remote to sample time deviation Statistics: min: <minimum sample interval>, max: <maximum sample interval>, avg: <average sample interval> - sample time interval Statistics: min: <minimum remote interval>, max: <maximum remote interval>, avg: <average remote interval> - remote time interval Contatore per messaggi persi Se l'istanza attiva non invia alcun timestamp, un contatore viene incrementato e restituisce il seguente output: Statistics: lost messages: <number of lost messages> " }, 
{ "title" : "Ottimizzazione delle prestazioni ", 
"url" : "_rtsl_performance_optimization_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Ottimizzazione delle prestazioni ", 
"snippet" : "In questa pagina ti mostreremo come configurare il tuo dispositivo, CODESYS Virtual Control SL e la tua applicazione in modo da ottenere le migliori prestazioni possibili. Ti forniamo gli strumenti che puoi utilizzare per verificare e valutare lo stato attuale del tuo sistema. Raccomandiamo la segue...", 
"body" : "In questa pagina ti mostreremo come configurare il tuo dispositivo, CODESYS Virtual Control SL e la tua applicazione in modo da ottenere le migliori prestazioni possibili. Ti forniamo gli strumenti che puoi utilizzare per verificare e valutare lo stato attuale del tuo sistema. Raccomandiamo la seguente procedura. Eseguire questi passaggi nell'ordine specificato. Non ha senso passare al passaggio successivo se quello attuale non è ottimizzato come dovrebbe essere. Controllo dell'hardwareConfigurazione di LinuxConfigurazione del sistema runtime CODESYSConfigurazione dell'applicazione IECDopo ogni passaggio, controlla che le ultime modifiche non abbiano influenzato negativamente le ottimizzazioni dei passaggi precedenti. Dopo aver raggiunto le prestazioni desiderate con carico normale, è possibile opzionalmente eseguire un test con carico elevato stress-ng O iperf . Puoi trovare maggiori informazioni sui seguenti siti web: Fondazione Linux Linutronix " }, 
{ "title" : "Controllo dell'hardware ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4640115908976034154363059654", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Ottimizzazione delle prestazioni \/ Controllo dell'hardware ", 
"snippet" : "Non utilizzare cache condivise per i core del processore del controller. Se utilizzi bus di campo basati su Ethernet per il tuo dispositivo di destinazione, utilizza per essi un adattatore fisico. Non utilizzare un'architettura switch....", 
"body" : "Non utilizzare cache condivise per i core del processore del controller. Se utilizzi bus di campo basati su Ethernet per il tuo dispositivo di destinazione, utilizza per essi un adattatore fisico. Non utilizzare un'architettura switch. " }, 
{ "title" : "Configurazione di Linux ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm43415437655754", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Ottimizzazione delle prestazioni \/ Configurazione di Linux ", 
"snippet" : "Utilizza un kernel in tempo reale. Si consiglia di utilizzare il kernel di prelazione RT ( https:\/\/rt.wiki.kernel.org ) per il tuo sistema Linux. Nel caso delle distribuzioni Debian e Ubuntu troverai un kernel RT come pacchetto che potrai installare facilmente utilizzando il comando apt comando. Per...", 
"body" : "Utilizza un kernel in tempo reale. Si consiglia di utilizzare il kernel di prelazione RT ( https:\/\/rt.wiki.kernel.org ) per il tuo sistema Linux. Nel caso delle distribuzioni Debian e Ubuntu troverai un kernel RT come pacchetto che potrai installare facilmente utilizzando il comando apt comando. Per dettagli a riguardo, consultare il manuale della propria distribuzione. Sui sistemi Debian sudo apt-get install linux-image-rt-amd64 Controlla quale kernel stai utilizzando con il file uname -a comando. Per esempio. Evita di utilizzare un gestore di finestre, un server GUI\/X o simili sul tuo sistema. L'utilizzo di questi strumenti potrebbe influire sulle capacità in tempo reale del sistema, con conseguente jitter elevato nell'applicazione IEC). Test Utilizzo degli \"rt-tools\": Installazione di \"rt-tools\": sudo apt install rt-tests Avvio del \"test ciclico\": sudo cyclictest -p 99 -t -m IL man cyclictest Il comando mostra più opzioni della riga di comando che puoi utilizzare per misurare meglio aspetti prestazionali più o specifici del tuo sistema. Dipende dal vostro hardware se il valore determinato con \"cyclictest\" può essere considerato \"buono\" oppure no. Se utilizzi un processore molto potente (ad esempio Intel Core i7), dovresti avere al massimo un numero basso di 1 cifra. Se stai utilizzando un vecchio processore ARM, 100 potrebbe essere un buon risultato. Opzioni di ottimizzazione Dopo aver modificato ogni impostazione o combinazione di impostazioni, è necessario eseguire il programma «cyclictest» per verificare l'efficacia delle modifiche. Queste impostazioni non sono permanenti e pertanto devono essere ripristinate dopo l'avvio o il riavvio del sistema. Disabilita la modalità di risparmio energetico della CPU. Disabilita l'hyperthreading. È possibile utilizzare il comando seguente per disabilitare l'hyperthreading (esempio): echo off | sudo tee \/sys\/devices\/system\/cpu\/smt\/control Disabilitare il ridimensionamento e la commutazione della frequenza della CPU il più possibile. Ad esempio, impostare la frequenza minima e massima della CPU sullo stesso valore (fisso). Disabilita il meccanismo di limitazione in tempo reale del kernel Linux, perché ciò può causare jitter sul tuo sistema. Per ulteriori informazioni, vedere: The Linux Foundation: Scheduling — RT throttling È possibile utilizzare il comando seguente per disattivare la limitazione in tempo reale (esempio): echo -1 > \/proc\/sys\/kernel\/sched_rt_runtime_us Controllare e modificare il regolatore di pianificazione\/dimensionamento. Controllare il regolatore di pianificazione\/scalabilità utilizzato: cat \/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_governor Modificare il governatore di pianificazione\/scalabilità utilizzato (come root\/admin ) A Performance : echo \"performance\" > \/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_governor\n# set it for all available cores:\necho \"performance\" > \/sys\/devices\/system\/cpu\/cpu1\/cpufreq\/scaling_governor\necho \"performance\" > \/sys\/devices\/system\/cpu\/cpu2\/cpufreq\/scaling_governor\necho \"performance\" > \/sys\/devices\/system\/cpu\/cpu3\/cpufreq\/scaling_governor Si noti che il regolatore di scala deve essere reimpostato ogni volta che si avvia il sistema. Puoi anche impostarlo tramite la configurazione del kernel. IL intel_pstate driver del kernel può rendere più difficile l'impostazione corretta. Pertanto, dovresti usare il file cpufreq-info comando per verificare la configurazione. Puoi anche utilizzare programmi come cpu-freq-utils . Ciò potrebbe interferire con i driver Intel pstate. Questi driver normalmente richiedono un approccio diverso per impostare la frequenza della CPU. Per ulteriori informazioni, vedere: https:\/\/www.kernel.org\/doc\/Documentation\/cpu-freq\/governors.txt disattivare HyperV nel BIOS (se disponibile). " }, 
{ "title" : "Configurazione del sistema runtime CODESYS ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4554832147912034154456684842", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Ottimizzazione delle prestazioni \/ Configurazione del sistema runtime CODESYS ", 
"snippet" : "Crea un'applicazione di prova che descriva approssimativamente l'applicazione per la quale desideri ottimizzare il tuo sistema (in termini di risorse richieste, prestazioni richieste e dimensioni del progetto). Puoi farlo in modo iterativo: prima crea un'approssimazione molto approssimativa e poi es...", 
"body" : "Crea un'applicazione di prova che descriva approssimativamente l'applicazione per la quale desideri ottimizzare il tuo sistema (in termini di risorse richieste, prestazioni richieste e dimensioni del progetto). Puoi farlo in modo iterativo: prima crea un'approssimazione molto approssimativa e poi espandila per avvicinarti sempre di più all'applicazione reale. Test Quando l'applicazione è in esecuzione, controlla la configurazione dell'attività. Apri il Configurazione delle attività e seleziona il Tenere sotto controllo scheda. minimo Jitter (μs)\/max. Jitter (μs) I valori dovrebbero avvicinarsi il più possibile ai valori determinati dal programma \"cycletest\". I dettagli sono descritti nella sezione Configurazione di Linux. Per ulteriori informazioni su jitter e latenza, vedere: Definizioni di jitter e latenza Per ulteriori informazioni sulla scheda Monitoraggio, vedere: Scheda: Monitoraggio Tempo ciclo medio (μs)\/max. Tempo di ciclo (μs) Tempo di ciclo (μs) Il ciclo massimo non dovrebbe mai avvicinarsi al tempo di ciclo configurato. Ciò porta a problemi non appena il sistema sperimenta un carico elevato. Mantenere sempre il tempo di ciclo il più breve possibile. Opzioni di ottimizzazione Dopo aver modificato ciascuna impostazione o combinazione di impostazioni, è necessario eseguire il programma \"ciclicotest\" per verificare l'efficacia delle modifiche. Suddividi le attività di lunga durata in più attività più piccole. Durante l'esecuzione, il tempo di ciclo massimo del task con la priorità più alta non dovrebbe mai raggiungere il tempo di ciclo configurato. Se non è possibile evitarlo, è necessario aumentare il tempo di ciclo progettato per garantire tempi di esecuzione coerenti. All'avvio dei sistemi bus di campo (ad esempio EtherCAT o PROFINET) i cicli di avvio possono comportare un carico leggermente maggiore della CPU. In questo caso ha senso monitorare il carico della CPU subito dopo l'avvio dell'applicazione. Non è possibile modificare le seguenti opzioni CODESYS Virtual Control SL , ma devono essere configurati sull'host: Imposta il valore per DisableCpuDmaLatency a 1: [SysCpuHandling]\nLinux.DisableCpuDmaLatency=1 Tieni presente che questa è l'impostazione predefinita a partire dalla versione runtime 4.11.0.0. Per verificare la versione del runtime, fare clic su Extra → Aggiorna Linux → Sistema → Informazioni di sistema . Controllare se il kernel in tempo reale viene realmente utilizzato o meno. A partire dalla versione 4.11.0.0 è possibile utilizzare il comando della shell PLC rt-get kernelinfo per verificare questo. Se disponi di una versione precedente, puoi farlo direttamente sulla riga di comando con il comando uname -a . Se il kernel in tempo reale non viene utilizzato, è necessario ricominciare dall'inizio. " }, 
{ "title" : "Configurazione dell'applicazione IEC ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4633380190436834154474610871", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Ottimizzazione delle prestazioni \/ Configurazione dell'applicazione IEC ", 
"snippet" : "Questa sezione si riferisce alla tua applicazione effettiva. Test È possibile utilizzare i test del passaggio precedente Configurazione del sistema runtime CODESYS per testare la tua applicazione IEC. Opzioni di ottimizzazione Dopo aver modificato ciascuna impostazione o combinazione di impostazioni...", 
"body" : "Questa sezione si riferisce alla tua applicazione effettiva. Test È possibile utilizzare i test del passaggio precedente Configurazione del sistema runtime CODESYS per testare la tua applicazione IEC. Opzioni di ottimizzazione Dopo aver modificato ciascuna impostazione o combinazione di impostazioni, è necessario eseguire il programma \"ciclicotest\" per verificare l'efficacia delle modifiche. Puoi usare il Multicore caratteristica in CODESYS . Determina le priorità corrette per i tuoi compiti. I compiti importanti dovrebbero avere una priorità più alta. Mappatura delle priorità delle attività IEC e delle priorità dei thread Linux: Priorità del compito IEC Priorità Linux -- 88 (SCHED_FIFO) -- 57 (SCHED_FIFO) 0 (massima priorità in tempo reale) 56 (SCHED_FIFO) 15 (priorità in tempo reale più bassa) 41 (SCHED_FIFO) 16 (priorità non in tempo reale) 0 (SCHED_OTHER) 31 (priorità non in tempo reale) 0 (SCHED_OTHER) -- 0 (SCHED_OTHER) Su un sistema Linux convenzionale, la maggior parte degli interrupt (IRQ) e dei kernel worker hanno la priorità Linux 50. L'uso di priorità (con carico elevato) superiori a tale valore può far sì che le funzioni di sistema (rete\/storage) non funzionino È possibile configurare la priorità di un'attività nella rispettiva configurazione dell'attività. Se non ottieni le prestazioni desiderate dopo tutti i passaggi qui menzionati, puoi consultare le seguenti sezioni: Informazioni specifiche del bus di campo[Per esperti] – Strumenti e argomenti aggiuntivi" }, 
{ "title" : "Informazioni specifiche del bus di campo ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4494465964555234154489740927", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Ottimizzazione delle prestazioni \/ Informazioni specifiche del bus di campo ", 
"snippet" : "Test Controlla il Send Time \/ Recv Time valori nella pagina di stato EtherCAT. Una CPU x64 con processore Intel Core i7 e un buon adattatore dovrebbe avere meno di 10μs. I processori ARM con chip integrato avranno ~50μs o più. Controlla il Send Time \/ Recv Time valori nella pagina di stato PROFINET....", 
"body" : "Test Controlla il Send Time \/ Recv Time valori nella pagina di stato EtherCAT. Una CPU x64 con processore Intel Core i7 e un buon adattatore dovrebbe avere meno di 10μs. I processori ARM con chip integrato avranno ~50μs o più. Controlla il Send Time \/ Recv Time valori nella pagina di stato PROFINET. Una CPU x64 con processore Intel Core i7 e un buon adattatore dovrebbe avere meno di 10μs. I processori ARM con chip integrato avranno ~50μs o più. Opzioni di ottimizzazione Per ordinare le priorità e gli IRQ richiesti, è possibile utilizzare i comandi della shell PLC irq-list E irq-set-prio . Questi comandi utilizzano le normali priorità Linux e non le priorità IEC. Questa ottimizzazione non è possibile in CODESYS Virtual Control SL , ma piuttosto sul sistema host. Utilizzare un adattatore di rete separato per i dispositivi. Per ulteriori informazioni, vedere: EtherCAT PROFINET Ethernet\/IP CANbus, CANopen " }, 
{ "title" : "[Per esperti] – Strumenti e argomenti aggiuntivi ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm464011317245123415449146407", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Configura ed estendi \/ Ottimizzazione delle prestazioni \/ [Per esperti] – Strumenti e argomenti aggiuntivi ", 
"snippet" : "Gli strumenti e le opzioni descritti in questa sezione sono destinati esclusivamente agli utenti esperti e richiedono una ricerca personale, poiché le misure da adottare dipendono fortemente dal sistema in questione. Pertanto non siamo in grado di offrirvi soluzioni specifiche. KernelShark\/traccia d...", 
"body" : "Gli strumenti e le opzioni descritti in questa sezione sono destinati esclusivamente agli utenti esperti e richiedono una ricerca personale, poiché le misure da adottare dipendono fortemente dal sistema in questione. Pertanto non siamo in grado di offrirvi soluzioni specifiche. KernelShark\/traccia del kernel Questo è il programma da scegliere se ritieni che la causa dei tuoi problemi di prestazioni sia la pianificazione. Con l'aiuto della \"traccia del kernel\", puoi vedere se la tua attività viene interrotta da un'altra attività, da un altro servizio o da un'interruzione. trace-cmd record -p function È possibile utilizzare KernelShark per esaminare il file generato trace.dat file. In generale, i problemi di pianificazione possono essere suddivisi in due categorie: Sostituzione\/prelazione Se l'interruzione o l'attività che impedisce l'esecuzione non è necessaria, disabilitala. Aumenta la priorità del tuo compito o riduci la priorità degli altri. Passa a un core della CPU diverso. Verificare l'efficacia delle modifiche utilizzando i programmi descritti nel capitolo precedente. Tempo di esecuzione Vedi sotto: \"Traccia delle funzioni del kernel\" Traccia della funzione del kernel Se determini che il tempo di esecuzione del codice è troppo elevato, puoi utilizzare questo strumento per individuare il problema. Se la funzione con un tempo di esecuzione troppo elevato è nel tuo codice, devi ottimizzarla. Se nel kernel è presente una funzione con un tempo di esecuzione troppo elevato, è possibile provare a ottenere la funzionalità desiderata con un'altra funzione del kernel. In alternativa, potresti anche passare i parametri di configurazione al driver del kernel per ridurre il tempo di esecuzione. Se nessuna di queste opzioni risolve il problema, probabilmente dovrai utilizzare hardware più potente. Osserva i seguenti punti e verifica se sono o meno lo strumento corretto per raggiungere i tuoi obiettivi di performance: PREEMPT_FULL isolcpu rcu_nocbs rcu_nocb_poll nosoftlockup disabilitazione del bilanciamento irq kernel.sched_rt_runtime_us " }, 
{ "title" : "Casi d'uso ", 
"url" : "_rtsl_use_cases_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Connessione con autenticazione a chiave pubblica ", 
"url" : "_rtsl_linux_public_key_authentification.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Connessione con autenticazione a chiave pubblica ", 
"snippet" : "SSH consente una connessione al controller sicura, crittografata e autenticata. Ciò consente di eseguire la gestione remota del controller in un ambiente sicuro. L'autenticazione può essere effettuata fornendo le credenziali (nome utente e password). Puoi anche scegliere un metodo più potente utiliz...", 
"body" : "SSH consente una connessione al controller sicura, crittografata e autenticata. Ciò consente di eseguire la gestione remota del controller in un ambiente sicuro. L'autenticazione può essere effettuata fornendo le credenziali (nome utente e password). Puoi anche scegliere un metodo più potente utilizzando l'autenticazione basata su chiave (autenticazione a chiave pubblica). L'utente utilizza una chiave per accedere al controller. Una chiave è composta da una chiave pubblica e una privata. Questo tipo di coppia di chiavi è molto più difficile da compromettere rispetto a una password. L'operazione di registrazione verifica se la chiave pubblica del controller corrisponde alla chiave privata del sistema di sviluppo. In questo caso, l'accesso viene concesso senza l'utilizzo di una password. Crei le chiavi SSH utilizzate in CODESYS sul sistema di sviluppo basato su Windows. È possibile opzionalmente specificare una passphrase in modo da aumentare ulteriormente la sicurezza dell'autenticazione con chiave pubblica. È possibile copiare la chiave pubblica su uno o anche più controller, il che potrebbe essere desiderabile, ad esempio, su una macchina composta da più controller. La chiave privata rimane sempre nel sistema di sviluppo e non deve mai essere condivisa in nessun caso. Non condividere mai la chiave privata. " }, 
{ "title" : "Creazione di una chiave SSH ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4635616815128032538919569496", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Connessione con autenticazione a chiave pubblica \/ Creazione di una chiave SSH ", 
"snippet" : "Innanzitutto crea una chiave SSH in Windows composta da una chiave privata e una pubblica. Installa lo strumento open source \"PuTTY\". Diverse applicazioni si trovano in C:\\Program Files (x86)\\PuTTY . Apri lo strumento \"PuTTYgen\". Si apre la seguente finestra di dialogo. Seleziona il RSA opzione e fa...", 
"body" : "Innanzitutto crea una chiave SSH in Windows composta da una chiave privata e una pubblica. Installa lo strumento open source \"PuTTY\". Diverse applicazioni si trovano in C:\\Program Files (x86)\\PuTTY . Apri lo strumento \"PuTTYgen\". Si apre la seguente finestra di dialogo. Seleziona il RSA opzione e fare clic su creare pulsante. Inizia la creazione della chiave. Nel frattempo, sposta il mouse nello spazio libero sotto la barra di avanzamento fino a creare la chiave. Si apre la seguente finestra di dialogo: Se necessario, puoi designare una passphrase sicura e univoca in Passphrase chiave e Conferma passphrase . Se hai assegnato una passphrase, anche le chiavi sono protette. Avrai bisogno della passphrase ogni volta che usi una chiave per accedere al tuo controller CODESYS . Mantieni segreta la passphrase in modo che solo le persone autorizzate la sappiano. Clicca il Salva chiave privata e specificare un nome file (esempio: serviceuser.ppk ). Clic Salva . Viene creata la chiave PPK privata. Fai clic su Conversioni → Esporta chiave OpenSSH comando. Specificare un nome file (esempio: serviceuser.openssh ). Viene creata la chiave OPENSSH privata. Nel Chiave pubblica da incollare nel file Authorized_keys di OpenSSH campo di testo, ora seleziona l'intera stringa. Nel menu contestuale , fai clic Copia per copiare la stringa negli appunti e incollarla in un file di testo. Assegna un nome al file di testo (esempio serviceuser.pub ). Viene creata la chiave PUB privata. Sposta le chiavi in una posizione adatta, forse anche nascosta, sul computer di sviluppo. Oppure salva i file su una chiavetta USB che rimane con il sistema di sviluppo. Ad esempio, le chiavi private e pubbliche si trovano ora nel file D:\\PLCs\\BeagleBone\\Keys directory. Assicurati che la chiave privata rimanga sempre nel sistema di sviluppo. La chiave privata non deve mai essere condivisa. " }, 
{ "title" : "Copia della chiave pubblica nel controller ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4635616712388832538922040216", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Connessione con autenticazione a chiave pubblica \/ Copia della chiave pubblica nel controller ", 
"snippet" : "Copia la chiave pubblica (esempio: serviceuser.pub ) al responsabile del trattamento. Prestare attenzione alle informazioni sul fornitore....", 
"body" : "Copia la chiave pubblica (esempio: serviceuser.pub ) al responsabile del trattamento. Prestare attenzione alle informazioni sul fornitore. " }, 
{ "title" : "Collegamento di chiavi private in CODESYS ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4570645292920032538924011205", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Connessione con autenticazione a chiave pubblica \/ Collegamento di chiavi private in CODESYS ", 
"snippet" : "Aperta CODESYS e fai clic su Utensili → Implementa Control SL comando. Sul Comunicazione scheda, espandi il Login basato su chiavi sezione. Fai clic su Aggiungi Keyfile pulsante. Si apre una finestra di dialogo per la selezione dei file. Selezionare la chiave privata desiderata (file OPENSH). Esempi...", 
"body" : "Aperta CODESYS e fai clic su Utensili → Implementa Control SL comando. Sul Comunicazione scheda, espandi il Login basato su chiavi sezione. Fai clic su Aggiungi Keyfile pulsante. Si apre una finestra di dialogo per la selezione dei file. Selezionare la chiave privata desiderata (file OPENSH). Esempio: serviceuser.openssh Clic ok per confermare il dialogo. La finestra di dialogo si chiude. Ora CODESYS ha la chiave privata. Puoi anche collegare la chiave privata nelle opzioni, nel Strumento Runtime Deploy categoria. " }, 
{ "title" : "Accesso basato su chiave con una chiave SSH ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4570645233654432538931011655", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Connessione con autenticazione a chiave pubblica \/ Accesso basato su chiave con una chiave SSH ", 
"snippet" : "Accedi al controller con la chiave SSH. Fai clic su Utensili → Implementa Control SL comando. Il Strumento di distribuzione runtime si apre. Seleziona il Accesso SSH basato sulla chiave opzione. Una casella di riepilogo fornisce tutte le chiavi conosciute CODESYS . Selezionare la chiave desiderata s...", 
"body" : "Accedi al controller con la chiave SSH. Fai clic su Utensili → Implementa Control SL comando. Il Strumento di distribuzione runtime si apre. Seleziona il Accesso SSH basato sulla chiave opzione. Una casella di riepilogo fornisce tutte le chiavi conosciute CODESYS . Selezionare la chiave desiderata serviceuser.openssh . Specificare il nome utente e la password e, se necessario, la passphrase nei rispettivi campi di immissione. Clicca il Scansione pulsante. La rete viene scansionata alla ricerca di controller corrispondenti. Viene visualizzato il risultato della ricerca. Selezionare quello desiderato dall'elenco dei controller. Ad esempio, fare clic Informazioni di sistema . Il server SSH sul controller controlla se la chiave privata corrisponde o meno alla chiave pubblica. In questo caso, sei autenticato e connesso. Dopodiché, il comando viene eseguito e le informazioni di sistema del controller vengono visualizzate in CODESYS . " }, 
{ "title" : "Installazione di prodotti SL senza un gestore pacchetti ", 
"url" : "_rtsl_linux_installation_without_pm.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Installazione di prodotti SL senza un gestore pacchetti ", 
"snippet" : "Lo strumento di aggiornamento per i prodotti SL copia un pacchetto di installazione (.deb o .ipk) sul dispositivo di destinazione in background e quindi lo installa. Ciò richiede l'installazione di un gestore di pacchetti (dpkg o ipkg) sul dispositivo di destinazione. Se non è installato un gestore ...", 
"body" : "Lo strumento di aggiornamento per i prodotti SL copia un pacchetto di installazione (.deb o .ipk) sul dispositivo di destinazione in background e quindi lo installa. Ciò richiede l'installazione di un gestore di pacchetti (dpkg o ipkg) sul dispositivo di destinazione. Se non è installato un gestore di pacchetti, lo strumento di aggiornamento non può installare un Tuttavia, è ancora possibile installare manualmente il pacchetto se lo si desidera. Per i prodotti generici, questo è spiegato di seguito utilizzando CODESYS Control​ for Linux V4.7.0.0 come esempio. CODESYS Control non supporta dispositivi con un file system (parzialmente) protetto da scrittura. Se il tuo dispositivo ha un file system protetto da scrittura e hai problemi durante l'installazione o l'avvio di un prodotto, controlla se i problemi persistono dopo aver disabilitato la protezione da scrittura. " }, 
{ "title" : "Installazione manuale del sistema runtime sul dispositivo di destinazione ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4590635748291233589649632523", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Installazione di prodotti SL senza un gestore pacchetti \/ Installazione manuale del sistema runtime sul dispositivo di destinazione ", 
"snippet" : "Dopo l'installazione del CODESYS Control​ for Linux pacchetto, i file richiesti si trovano sul PC Windows: <user>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.deb O <user>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.ipk <...", 
"body" : "Dopo l'installazione del CODESYS Control​ for Linux pacchetto, i file richiesti si trovano sul PC Windows: <user>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.deb O <user>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.ipk <user>\/CODESYS Control for Linux SL\/Dependency\/codemeter-lite_<Version>.deb (per licenza) Copia questi file sul dispositivo di destinazione. Disimballare il pacchetto: $ ar -x codesyscontrol_linux_<Version> Vengono creati i seguenti file: control.tar.gz : Contiene gli script che il gestore pacchetti esegue prima e dopo l'installazione o la disinstallazione. Ciò non è rilevante per l'installazione manuale. data.tar.gz : contiene binari di sistema di runtime, librerie, script di avvio e configurazioni debian-binary : specifica la versione del pacchetto .deb. Ciò non è rilevante per l'installazione manuale. Disimballare il data.tar.gz file. Crea una nuova cartella per questo in anticipo: $ mkdir data\n$ tar -xf data.tar.gz -C data In data\/ , ora troverai i file importanti per il funzionamento del sistema runtime: data\n├── etc\n│ ├── default\n│ │ └── codesyscontrol\n│ ├── init.d\n│ │ └── codesyscontrol\n│ └── codesyscontrol\n│ ├── 3S.dat\n│ ├── CODESYSControl.cfg\n│ └── CODESYSControl_User.cfg\n├── opt\n│ └── codesys\n│ ├── bin\n│ │ └── codesyscontrol.bin\n│ ├── lib\n│ │ ├── libCmpHilscherCIFX.so\n│ │ └── libSysPci.so\n│ └── scripts\n│ ├── init-functions\n│ ├── init-vars\n│ ├── PlcWink.sh\n│ └── rts_set_baud.sh\n├── usr\n│ └── share\n│ └── doc\n│ └── codesyscontrol\n│ └── copyright\n└── var\n └── opt\n └── codesys\n ├── bacstac.ini\n ├── cmact_licenses\n └── .SoftContainer_CmRuntime.wbb Ora il gestore dei pacchetti (dpkg o ipkg) normalmente copia questa struttura di directory nella directory principale del sistema. Questo deve essere fatto manualmente senza un gestore di pacchetti: Cambia al data\/ directory dove il data.tar.gz il file è stato decompresso: $ cd data\/ Copia le singole directory nelle rispettive directory root della destinazione: Se commetti un errore, questo passaggio può rendere inutilizzabile il tuo dispositivo di destinazione e dovrai ripristinarlo. $ sudo cp -r etc\/* \/etc\n$ sudo cp -r opt\/* \/opt\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var Ora il gestore pacchetti eseguirà alcuni passaggi post-installazione per completare l'installazione. Eseguire questi passaggi manualmente: $ sudo chmod a+rw \/etc\/codesyscontrol\/CODESYSControl.cfg\n$ sudo chmod a+rw \/etc\/codesyscontrol\/CODESYSControl_User.cfg Se il codesysuser il gruppo non esiste già sul dispositivo di destinazione, quindi aggiungilo. $ groupadd codesysuser Questo gruppo viene utilizzato per l'API di estensione. Per ulteriori informazioni, vedere: Meccanismi di sicurezzaIl sistema runtime è ora installato. Tuttavia, ha ancora bisogno dell'ambiente di runtime Codemeter. " }, 
{ "title" : "Installazione manuale dell'ambiente di runtime Codemeter sul dispositivo di destinazione ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4590635833291233589649827584", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Installazione di prodotti SL senza un gestore pacchetti \/ Installazione manuale dell'ambiente di runtime Codemeter sul dispositivo di destinazione ", 
"snippet" : "Dopo l'installazione del pacchetto CODESYS Control SL, il pacchetto .deb viene salvato in <User>\/CODESYS Control für Linux SL\/Dependency\/codemeter-lite_<Version>.deb . Copia anche questo pacchetto .deb in una cartella vuota appena creata sul sistema di destinazione. Scompattare il pacchetto Debian. ...", 
"body" : "Dopo l'installazione del pacchetto CODESYS Control SL, il pacchetto .deb viene salvato in <User>\/CODESYS Control für Linux SL\/Dependency\/codemeter-lite_<Version>.deb . Copia anche questo pacchetto .deb in una cartella vuota appena creata sul sistema di destinazione. Scompattare il pacchetto Debian. $ ar -x codemeter-lite_<Version>.deb IL control.tar.gz , data.tar.gz , debian-binary , e anche _gpgorigin i file vengono estratti. Disimballare il data.tar.gz file in una cartella appena creata. $ mkdir data\n$ tar -xf data.tar.gz -C data Successivamente, i file binari e altri file come librerie e script sono disponibili in data\/ : data\n├── etc\n│ ├── init.d\n│ │ ├── codemeter\n│ │ └── codemeter-webadmin\n│ └── wibu\n│ └── CodeMeter\n│ └── Server.ini\n├── lib\n│ ├── systemd\n│ │ └── system\n│ │ ├── codemeter.service\n│ │ └── codemeter-webadmin.service\n│ └── udev\n│ └── rules.d\n│ └── 60-codemeter-lite.rules\n├── usr\n│ ├── bin\n│ │ ├── cmu\n│ │ └── codemeter-info\n│ ├── lib\n│ │ └── x86_64-linux-gnu\n│ │ ├── jni\n│ │ │ ├── libwibucmJNI64.so -> libwibucmJNI.so\n│ │ │ └── libwibucmJNI.so\n│ │ ├── libwibucmlin64-4.so -> libwibucm.so\n│ │ ├── libwibucmlin64.so -> libwibucm.so\n│ │ ├── libwibucmlin.so -> libwibucm.so\n│ │ └── libwibucm.so\n│ ├── sbin\n│ │ ├── CmWebAdmin\n│ │ └── CodeMeterLin\n│ └── share\n│ ├── bash-completion\n│ │ └── completions\n│ │ └── cmu\n│ ├── doc\n│ │ ├── CodeMeter\n│ │ │ ├── OpenSource_en.pdf\n│ │ │ └── README\n│ │ └── codemeter-lite\n│ │ ├── changelog.gz\n│ │ └── copyright\n│ └── man\n│ └── man1\n│ └── codemeter-info.1.gz\n└── var\n ├── lib\n │ └── CodeMeter\n │ ├── Backup\n │ ├── CmAct\n │ ├── CmCloud\n │ ├── NamedUser\n │ └── WebAdmin\n └── log\n └── CodeMeter Cambia al data\/ directory dove il data.tar.gz il file è stato decompresso: $ cd data\/ Ora copia l'intera directory nella directory principale del dispositivo di destinazione: Se commetti un errore, questo passaggio può rendere inutilizzabile il tuo dispositivo di destinazione e dovrai ripristinarlo. $ sudo cp -r etc\/* \/etc\n$ sudo cp -r lib\/* \/lib\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var Ora il pacchetto Codemeter eseguirà alcuni passaggi post-installazione per completare l'installazione. Eseguire questi passaggi manualmente: $ sudo udevadm trigger -vn --subsystem-match=usb --attr-match=idVendor=064f | xargs -rn1 -d\\\\n udevadm trigger -b\n$ sudo mkdir -p \"\/etc\/systemd\/system\/multi-user.target.wants\/\"\n$ sudo ln -sT \/lib\/systemd\/system\/codemeter.service \/etc\/systemd\/system\/multi-user.target.wants\/codemeter.service Ora è necessario configurare il servizio Codemeter con il seguente comando (avvia come root ): CodemeterLin -x\n L'installazione di Codemeter Lite e del sistema runtime è ora completa. " }, 
{ "title" : "Installazione manuale del gateway edge: ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4604985458336033589650100426", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Installazione di prodotti SL senza un gestore pacchetti \/ Installazione manuale del gateway edge: ", 
"snippet" : "Puoi installare il gateway edge allo stesso modo del sistema di runtime e di Codemeter. Sul PC Windows, il pacchetto è memorizzato in <user>\/CODESYS Edge Gateway for Linux\/Delivery\/codesysedge_edgeamd64_<Version>.deb . Copia il pacchetto Debian in una nuova cartella vuota sul dispositivo di destinaz...", 
"body" : "Puoi installare il gateway edge allo stesso modo del sistema di runtime e di Codemeter. Sul PC Windows, il pacchetto è memorizzato in <user>\/CODESYS Edge Gateway for Linux\/Delivery\/codesysedge_edgeamd64_<Version>.deb . Copia il pacchetto Debian in una nuova cartella vuota sul dispositivo di destinazione. Scompattare il pacchetto Debian: $ ar -x codesysedge_edgeamd64_<Version>.deb I file control.tar.gz , data.tar.gz E debian-binary vengono estratti. Disimballare il data.tar.gz file in una cartella appena creata: $ mkdir data\n$ tar -xf data.tar.gz -C data Successivamente, i file binari e altri file come librerie e script sono disponibili in data\/ : data\n├── etc\n│ ├── default\n│ │ └── codesysedge\n│ ├── init.d\n│ │ └── codesysedge\n│ └── codesysedge\n│ ├── Gateway.cfg\n│ ├── GatewayvControl.cfg\n│ └── Gateway_User.cfg\n├── opt\n│ └── codesysedge\n│ ├── bin\n│ │ └── codesysedge.bin\n│ ├── lib\n│ └── scripts\n│ ├── rts_set_baud.sh\n│ └── startup.sh\n├── usr\n│ └── share\n\n│ └── doc\n│ └── codesysedge\n│ └── copyright\n└── var\n └── opt\n └── codesysedge Cambia al data\/ directory dove il data.tar.gz il file è stato decompresso: $ cd data\/ Ora copia l'intera directory nella directory principale del dispositivo di destinazione: Se commetti un errore, questo passaggio può rendere inutilizzabile il tuo dispositivo di destinazione e dovrai ripristinarlo. $ sudo cp -r etc\/* \/etc\n$ sudo cp -r opt\/* \/opt\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var Eseguire nuovamente i passaggi di post-elaborazione del gestore pacchetti: $ chmod a+rw \/etc\/codesysedge\/Gateway.cfg\n$ chmod a+rw \/etc\/codesysedge\/Gateway_User.cfg Il gateway edge è ora installato. " }, 
{ "title" : "Avvio di Codemeter, del sistema di runtime e del gateway edge ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4554611316182433589650574679", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Installazione di prodotti SL senza un gestore pacchetti \/ Avvio di Codemeter, del sistema di runtime e del gateway edge ", 
"snippet" : "I pacchetti installati possono ora essere avviati: Codemeter $ sudo \/usr\/sbin\/CodeMeterLin Puoi avviare Codemeter con il file -v flag per ottenere l'output esteso. Con l'input di -Help , ottieni assistenza su più funzioni. Sistema di runtime e gateway edge $ sudo \/etc\/init.d\/codesyscontrol start $ s...", 
"body" : "I pacchetti installati possono ora essere avviati: Codemeter $ sudo \/usr\/sbin\/CodeMeterLin Puoi avviare Codemeter con il file -v flag per ottenere l'output esteso. Con l'input di -Help , ottieni assistenza su più funzioni. Sistema di runtime e gateway edge $ sudo \/etc\/init.d\/codesyscontrol start\n$ sudo \/etc\/init.d\/codesysedge start " }, 
{ "title" : "Installazione CODESYS TargetVisu for Linux SL senza un gestore di pacchetti ", 
"url" : "_rtsl_targetvisu_installation_without_pm.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Installazione CODESYS TargetVisu for Linux SL senza un gestore di pacchetti ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Installazione manuale del sistema runtime sul dispositivo di destinazione ", 
"url" : "_rtsl_targetvisu_installation_without_pm.html#UUID-b70db7d9-478d-5a8c-9e0b-7e2599f42fe7_section-idm4590635748291233589649632523", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Installazione CODESYS TargetVisu for Linux SL senza un gestore di pacchetti \/ Installazione manuale del sistema runtime sul dispositivo di destinazione ", 
"snippet" : "Dopo l'installazione del CODESYS Control​ for Linux pacchetto, i file richiesti si trovano sul PC Windows: <user>\/CODESYS TargetVisu for Linux SL\/Delivery\/visualization<architecture>\/codesysvisualization_visualizationamd64_4.13.0.0_amd64.deb Copia questi file sul dispositivo di destinazione. Disimba...", 
"body" : "Dopo l'installazione del CODESYS Control​ for Linux pacchetto, i file richiesti si trovano sul PC Windows: <user>\/CODESYS TargetVisu for Linux SL\/Delivery\/visualization<architecture>\/codesysvisualization_visualizationamd64_4.13.0.0_amd64.deb Copia questi file sul dispositivo di destinazione. Disimballare il pacchetto: $ ar -x codesyscontrol_linux_<Version> Vengono creati i seguenti file: control.tar.gz : Contiene gli script che il gestore pacchetti esegue prima e dopo l'installazione o la disinstallazione. Ciò non è rilevante per l'installazione manuale. data.tar.gz : contiene binari di sistema di runtime, librerie, script di avvio e configurazioni debian-binary : specifica la versione del pacchetto .deb. Ciò non è rilevante per l'installazione manuale. Disimballare il data.tar.gz file. Crea una nuova cartella per questo in anticipo: $ mkdir data\n$ tar -xf data.tar.gz -C data In data\/ , ora troverai i file importanti per il funzionamento del sistema runtime: data\n├── etc\n│ └── codesysvisualization\n│ ├── CODESYSVisualization.cfg\n│ ├── CODESYSVisualizationTV.cfg\n│ └── CODESYSVisualization_User.cfg\n├── opt\n│ └── codesysvisualization\n│ ├── bin\n│ │ └── codesysvisualization.bin\n│ └── codesysvisualization.service\n├── usr\n│ └── share\n│ └── doc\n│ └── codesysvisualization\n│ └── copyright\n└── var \n └── opt \n └── codesysvisualization\n Ora il gestore di pacchetti (dpkg) normalmente copia questa struttura di directory nella directory principale del sistema. Questa operazione deve essere eseguita manualmente senza un gestore di pacchetti: Cambia al data\/ directory dove il data.tar.gz il file è stato decompresso: $ cd data\/ Copia le singole directory nelle rispettive directory root della destinazione: Se commetti un errore, questo passaggio può rendere inutilizzabile il tuo dispositivo di destinazione e dovrai ripristinarlo. $ sudo cp -r etc\/* \/etc\n$ sudo cp -r opt\/* \/opt\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var Ora il gestore pacchetti eseguirà alcuni passaggi post-installazione per completare l'installazione. Eseguire questi passaggi manualmente: $ sudo chmod a+rw \/etc\/codesysvisualization\/CODESYSVisualization.cfg\n$ sudo chmod a+rw \/etc\/codesysvisualization\/CODESYSVisualization_User.cfg Se il codesysvisualization il gruppo non esiste già sul dispositivo di destinazione, quindi aggiungilo. $ groupadd codesysvisualization Crea cartelle aggiuntive e prepara il servizio. $ mkdir -p .config\/systemd\/user\/\n$ cp \/opt\/codesysvisualization\/codesysvisualization.service .config\/systemd\/user\/\n$ mkdir -p .config\/systemd\/user\/graphical.target.wants\/\n$ ln -s .config\/systemd\/user\/codesysvisualization.service .config\/systemd\/user\/graphical.target.wants\/. Imposta le autorizzazioni e gli utenti per le directory. $ sudo chmod -R u+x \/etc\/codesysvisualization\/\n$ sudo chmod 740 \/opt\/codesysvisualization\/bin\/codesysvisualization.bin\n$ sudo chmod 640 ~\/.config\/systemd\/user\/codesysvisualization.service\n$ sudo chmod -R 640 \/var\/opt\/codesysvisualization\/\n$ sudo chmod -R u+X \/var\/opt\/codesysvisualization\/\n$ sudo chmod 640 \/usr\/share\/doc\/codesysvisualization\/copyright\n$ sudo chown --recursive <USER> \/var\/opt\/codesysvisualization\n$ sudo chown --recursive <USER> \/opt\/codesysvisualization\/\n$ sudo chown --recursive <USER> \/etc\/codesysvisualization\/\n$ sudo chown --recursive <USER> .config\/systemd\/ " }, 
{ "title" : "Installazione del License Server senza un Package Manager ", 
"url" : "_rtsl_licenseserver_installation_without_pm.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Installazione del License Server senza un Package Manager ", 
"snippet" : "Requisito: Codemeter Runtime è installato sul dispositivo. Per ulteriori informazioni sull'installazione di Codemeter senza un gestore di pacchetti, vedere: Installazione manuale dell'ambiente di runtime Codemeter sul dispositivo di destinazioneCODESYS Il WBM può essere utilizzato solo con Cockpit. ...", 
"body" : "Requisito: Codemeter Runtime è installato sul dispositivo. Per ulteriori informazioni sull'installazione di Codemeter senza un gestore di pacchetti, vedere: Installazione manuale dell'ambiente di runtime Codemeter sul dispositivo di destinazioneCODESYS Il WBM può essere utilizzato solo con Cockpit. Il computer deve inoltre essere connesso contemporaneamente al dispositivo di destinazione e a Internet " }, 
{ "title" : "Se Cockpit non è installato o non può essere installato: ", 
"url" : "_rtsl_licenseserver_installation_without_pm.html#UUID-9309cb91-08d3-fde6-39f2-4317ba0b2561_section-idm234676479498753", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Installazione del License Server senza un Package Manager \/ Se Cockpit non è installato o non può essere installato: ", 
"snippet" : "È necessario configurare manualmente il server delle licenze, creare il soft container e importare le licenze. Configurare il server delle licenze Stop Codemeter: sudo \/etc\/init.d\/codemeter stop Passa al server di rete. Per fare ciò, è necessario impostare il valore IsNetworkServer a 1 pollice \/etc\/...", 
"body" : "È necessario configurare manualmente il server delle licenze, creare il soft container e importare le licenze. Configurare il server delle licenze Stop Codemeter: sudo \/etc\/init.d\/codemeter stop Passa al server di rete. Per fare ciò, è necessario impostare il valore IsNetworkServer a 1 pollice \/etc\/wibu\/CodeMeter\/Server.ini : IsNetworkServer=1 Salva le modifiche e avvia Codemeter: sudo \/etc\/init.d\/codemeter start Crea un contenitore morbido Controlla se esiste già un contenitore morbido: cmu -x | grep 'FC=6000437' Se è elencata una voce, puoi saltare questa sezione perché esiste già un soft container. Decomprimere il pacchetto Debian del server di licenze. Questo pacchetto è normalmente incluso nel CODESYS pacchetto del server di licenza. Questo contiene un file .UFC_SoftContainer_CmRuntime.WibuCmLif nel \/opt\/codesyslicenseserver\/bin . Trasferiscilo sul dispositivo su cui deve essere eseguito il server delle licenze. Crea il contenitore morbido: cmu --import --file .UFC_SoftContainer_CmRuntime.WibuCmLif Controlla se il comando cmu -x | grep 'FC=6000437' restituisce una voce. Importa una licenza Usa il comando cmu -x per rilevare il numero di serie del soft container in cui deve essere importata la licenza. Create the context file: cmu -c 6000437 -s <serial number> --file <file name>.WibuCmRaC Transfer the context file to a device with Internet access. Apri l'indirizzo https:\/\/license.codesys.com\/ e inserisci il numero del biglietto di licenza. AVANTI e ATTIVA LE LICENZE nella pagina successiva. Quindi seleziona il tipo di contenitore desiderato. Fai clic su Trasferimento della licenza basato su file link sul lato destro della pagina successiva. Carica il file di contesto generato in precedenza e fai clic su Inizia subito l'attivazione . Scarica il file di aggiornamento della licenza e trasferisci il file sul dispositivo che fungerà da server delle licenze. Import the file: cmu --import --file <file name>.WibuCmRaU The license is now activated. " }, 
{ "title" : "If Cockpit is installed ", 
"url" : "_rtsl_licenseserver_installation_without_pm.html#UUID-9309cb91-08d3-fde6-39f2-4317ba0b2561_section-idm234676479776826", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Installazione del License Server senza un Package Manager \/ If Cockpit is installed ", 
"snippet" : "Copiare i file di CODESYS WBM nel sistema: Decomprimere il pacchetto Debian codesyswbmbase e copia i file che si trovano in \/usr\/share\/cockpit\/codesys_wbm in una directory con lo stesso nome nello stesso percorso sul sistema. Decomprimere il pacchetto Debian codesyswbmlicensing e copia i file che si...", 
"body" : "Copiare i file di CODESYS WBM nel sistema: Decomprimere il pacchetto Debian codesyswbmbase e copia i file che si trovano in \/usr\/share\/cockpit\/codesys_wbm in una directory con lo stesso nome nello stesso percorso sul sistema. Decomprimere il pacchetto Debian codesyswbmlicensing e copia i file che si trovano in \/usr\/share\/cockpit\/codesys_wbm\/codesys_licensing in una directory con lo stesso nome e nello stesso percorso sul sistema. Riavvia Cockpit: systemctl restart cockpit.socket Ora dovresti essere in grado di accedere all'interfaccia Cockpit tramite il tuo browser sulla porta 9090 ed eseguire il processo di licenza usando CODESYS WBM. " }, 
{ "title" : "Scenario «parco giochi virtuale»: vPLC + License Server + Edge Gateway ", 
"url" : "_rtsl_scenario_virtual_playground.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario «parco giochi virtuale»: vPLC + License Server + Edge Gateway ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Requisiti ", 
"url" : "_rtsl_scenario_virtual_playground.html#UUID-135a713b-cb33-fd0c-80cc-22d356b14153_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario «parco giochi virtuale»: vPLC + License Server + Edge Gateway \/ Requisiti ", 
"snippet" : "Hardware Sono inoltre necessari i seguenti dispositivi: PC desktop con CODESYS installato PC Linux (con Docker o Podman, Python3 e accesso SSH installati), qui denominato «Linux Host PC». I seguenti prodotti aggiuntivi devono essere installati sul PC desktop (con CODESYS installato): CODESYS Virtual...", 
"body" : "Hardware Sono inoltre necessari i seguenti dispositivi: PC desktop con CODESYS installato PC Linux (con Docker o Podman, Python3 e accesso SSH installati), qui denominato «Linux Host PC». I seguenti prodotti aggiuntivi devono essere installati sul PC desktop (con CODESYS installato): CODESYS Virtual Edge Gateway for Linux . CODESYS Virtual Control for Linux SL CODESYS License Server for Linux SL " }, 
{ "title" : "PC host Linux ", 
"url" : "_rtsl_scenario_virtual_playground.html#UUID-135a713b-cb33-fd0c-80cc-22d356b14153_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario «parco giochi virtuale»: vPLC + License Server + Edge Gateway \/ PC host Linux ", 
"snippet" : "Esegui il comando Utensili → Implementa Control SL e stabilire una connessione al PC host Linux ( Comunicazione scheda). Per ulteriori informazioni, vedere: Stabilire una connessioneInstalla le versioni più recenti dei seguenti pacchetti\/immagini ( Distribuzione scheda): CODESYS Virtual Edge Gateway...", 
"body" : "Esegui il comando Utensili → Implementa Control SL e stabilire una connessione al PC host Linux ( Comunicazione scheda). Per ulteriori informazioni, vedere: Stabilire una connessioneInstalla le versioni più recenti dei seguenti pacchetti\/immagini ( Distribuzione scheda): CODESYS Virtual Edge Gateway for Linux CODESYS Virtual Control for Linux SL CODESYS License Server for Linux SL Per ulteriori informazioni, vedere: Installing an imageIl server delle licenze può anche essere installato ed eseguito su un sistema host diverso (requisito: sistema operativo Linux). La comunicazione dal PC host Linux al server delle licenze avviene tramite il protocollo TCP\/IP Crea le istanze richieste e configurale. Le istanze per il gateway e i PLC sono necessarie sul PC host Linux. Sul Operazione scheda, crea l'istanza come segue: Installazione dell'istanza per il gateway Nel vPLC sezione, fai clic su pulsante. Le Aggiungi nuova istanza si apre la finestra di dialogo. Nel Nome campo, specificare un nome (esempio: vGateway ). Nel Filtro casella di riepilogo, seleziona Gateway valore. Seleziona la versione più recente dell'immagine CODESYS Virtual Edge Gateway for Linux. Quindi fai clic OK . La nuova istanza è elencata nella vPLC sezione. Installazione dell'istanza per vPLC Nel vPLC sezione, fai clic su pulsante. Le Aggiungi nuova istanza si apre la finestra di dialogo. Nel Nome campo, specificare un nome (esempio: vPLC1 ). Nel Filtro casella di riepilogo, seleziona Runtime valore. Seleziona la versione più recente di CODESYS Virtual Control for Linux SL immagine. Quindi fai clic OK . La nuova istanza è elencata nella vPLC sezione. Sotto Server di licenza , specificare l'indirizzo IP del server delle licenze. Nell'esempio mostrato, questo è l'indirizzo IP del PC host Linux. Fare clic Salva per confermare la modifica. Le impostazioni vengono applicate sul PC host Linux. Facoltativo: ripetere questi passaggi per istanze vPLC aggiuntive. Per ulteriori informazioni, consulta «Creazione di istanze». Avvia le istanze virtuali. Nel vPLC sezione, fai clic su Inizia tutto pulsante per avviare tutte le istanze. Nel Stato colonna, lo stato di tutte le istanze virtuali cambia in In esecuzione . D'ora in poi, è possibile accedere e programmare le istanze PLC virtuali in esecuzione come normali PLC tramite CODESYS . La connessione viene stabilita tramite il «VGateway\" che è stato impostato Senza una licenza valida, i PLC funzionano in modalità demo (2 ore di autonomia). " }, 
{ "title" : "Installazione delle licenze ", 
"url" : "_rtsl_scenario_virtual_playground.html#UUID-135a713b-cb33-fd0c-80cc-22d356b14153_section-idm234664177345706", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario «parco giochi virtuale»: vPLC + License Server + Edge Gateway \/ PC host Linux \/ Installazione delle licenze ", 
"snippet" : "Le licenze per il funzionamento dei PLC possono essere ottenute presso CODESYS Store International e installate sul server delle licenze. Per ulteriori informazioni, vedere: Attivazione della licenza di rete...", 
"body" : "Le licenze per il funzionamento dei PLC possono essere ottenute presso CODESYS Store International e installate sul server delle licenze. Per ulteriori informazioni, vedere: Attivazione della licenza di rete" }, 
{ "title" : "Scenario: controllo virtuale con VLAN ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: controllo virtuale con VLAN ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Requisiti ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: controllo virtuale con VLAN \/ Requisiti ", 
"snippet" : "Scenario Configurazione riuscita del Scenario «parco giochi virtuale»: vPLC + License Server + Edge GatewayAlmeno due casi di CODESYS Virtual Control for Linux SL (in questo esempio, vPLC1 e vPLC2 ) Hardware Uno switch compatibile con VLAN Dispositivi Fieldbus (basati su Ethernet), ad esempio Profin...", 
"body" : "Scenario Configurazione riuscita del Scenario «parco giochi virtuale»: vPLC + License Server + Edge GatewayAlmeno due casi di CODESYS Virtual Control for Linux SL (in questo esempio, vPLC1 e vPLC2 ) Hardware Uno switch compatibile con VLAN Dispositivi Fieldbus (basati su Ethernet), ad esempio Profinet " }, 
{ "title" : "PC host Linux ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: controllo virtuale con VLAN \/ PC host Linux ", 
"snippet" : "Se configuri il dispositivo in modo errato, potresti perdere l'accesso al dispositivo. Collegare l'adattatore (dove devono essere definite le VLAN) allo switch. In questo esempio, due interfacce VLAN vengono aggiunte al enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group defau...", 
"body" : "Se configuri il dispositivo in modo errato, potresti perdere l'accesso al dispositivo. Collegare l'adattatore (dove devono essere definite le VLAN) allo switch. In questo esempio, due interfacce VLAN vengono aggiunte al enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\n    link\/ether f0:b2:b9:11:b8:b3 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.2.2\/24 brd 192.168.2.255 scope global noprefixroute enp1s0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::2e96:178c:586a:b97b\/64 scope link noprefixroute\n       valid_lft forever preferred_lft forever Aprire l'interfaccia di configurazione dello switch. Per istruzioni su come aprire l'interfaccia e le credenziali, consulta le istruzioni del fornitore Dopo aver effettuato l'accesso, apri la pagina di configurazione per la VLAN. Se lo switch supporta protocolli diversi, seleziona 802.1Q VLAN . Sul Port Config pagina, configura il Link Type della porta precedentemente connessa come Trunk . Collegate tutti i dispositivi fieldbus allo switch. Sul VLAN Config pagina, aggiungi due nuove VLAN. In questo esempio, stai lavorando con gli ID VLAN 100 e 200. Aggiungi la porta precedentemente connessa e configurata come Trunk a ciascuna VLAN. Aggiungete la porta di un dispositivo fieldbus a Nella seguente configurazione di esempio, la connessione dal controller allo switch è stata stabilita sulla porta 14. Link Type di questa porta è stata configurata come Trunk . Un dispositivo fieldbus è collegato sia alla porta 11 che alla porta ID VLAN Descrizione Porte 100 VLAN 100 11, 14 200 VLAN 200 12, 14 " }, 
{ "title" : "Configurazione delle interfacce VLAN ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm234821994565272", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: controllo virtuale con VLAN \/ Configurazione delle interfacce VLAN ", 
"snippet" : "Prima di apportare modifiche permanenti alla configurazione di rete, è necessario testare le impostazioni e modificarle in base alle proprie esigenze. Crea un nuovo adattatore di tipo VLAN . Il comando ha il seguente formato: sudo ip link add link <physical_adapter> name <virtual_adapter_name> type ...", 
"body" : "Prima di apportare modifiche permanenti alla configurazione di rete, è necessario testare le impostazioni e modificarle in base alle proprie esigenze. Crea un nuovo adattatore di tipo VLAN . Il comando ha il seguente formato: sudo ip link add link <physical_adapter> name <virtual_adapter_name> type vlan id <vlan_id> La convenzione è aggiungere l'ID VLAN al nome dell'adattatore virtuale. Nel caso della configurazione dell'adattatore e dello switch mostrata sopra, il comando ha il seguente aspetto sudo ip link add link enp1s0 name enp1s0.100 type vlan id 100 Sostituisci enp1s0 e l'ID VLAN con i valori del sistema. Ora, quando corri ip a , dovresti vedere qualcosa come il seguente risultato: enp1s0.100@enp1s0: <BROADCAST,MULTICAST,PROMISC> mtu 1500 qdisc noop state DOWN group default qlen 1000 Esegui questo comando anche per la seconda VLAN. " }, 
{ "title" : "Test della configurazione ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm234822002492998", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: controllo virtuale con VLAN \/ Test della configurazione ", 
"snippet" : "Apri il CODESYS Control SL Deploy Tool e stabilisci una connessione al controller. Per ulteriori informazioni, vedere: Stabilire una connessione. Passa al Operazione scheda e seleziona vPLC1 istanza. Nella vista di configurazione sul lato destro, fai clic su Nic linea e sul bordo destro fai clic su ...", 
"body" : "Apri il CODESYS Control SL Deploy Tool e stabilisci una connessione al controller. Per ulteriori informazioni, vedere: Stabilire una connessione. Passa al Operazione scheda e seleziona vPLC1 istanza. Nella vista di configurazione sul lato destro, fai clic su Nic linea e sul bordo destro fai clic su pulsante. Si apre la finestra di dialogo di configurazione Nic. Nell'elenco degli adattatori disponibili, fai clic su enp1s0.100 e seleziona Mappa sull'istanza opzione. Se necessario, configurare un indirizzo IP e una maschera di rete. La maschera di rete ha il formato della notazione CIDR (esempio 24 ). Per ulteriori informazioni, vedere: https:\/\/en.wikipedia.org\/wiki\/Classless_Inter-Domain_Routing Fai clic su OK e Salva pulsanti. Seleziona il vPLC2 istanza ed esegui i passaggi 3-6 con enp1s0.200 adattatore. Avvia le istanze e un gateway sul controller. Per ulteriori informazioni, vedere: Avvio del sistema runtimeCarica una piccola applicazione su ciascuna delle due istanze per verificare la funzionalità della rete. Per ulteriori informazioni, consulta Scaricare e avviare il file " }, 
{ "title" : "Persistenza della configurazione dell'adattatore ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm234821994914623", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: controllo virtuale con VLAN \/ Persistenza della configurazione dell'adattatore ", 
"snippet" : "Se la configurazione è corretta, è comunque necessario salvarla in modo permanente. Per istruzioni su come salvare in modo permanente la configurazione dello switch, consulta le istruzioni del fornitore. La configurazione delle due istanze vPLC1 e vPLC2 sono già persistenti. Qui devi solo impostare ...", 
"body" : "Se la configurazione è corretta, è comunque necessario salvarla in modo permanente. Per istruzioni su come salvare in modo permanente la configurazione dello switch, consulta le istruzioni del fornitore. La configurazione delle due istanze vPLC1 e vPLC2 sono già persistenti. Qui devi solo impostare Avvio automatico impostazione su Sì . I passaggi seguenti descrivono come configurare i due adattatori VLAN sul controller in modo che siano disponibili all'avvio del sistema. Queste impostazioni possono essere potenzialmente dannose per il sistema. Crea un backup di tutti i file importanti. Crea una copia di tutti i file che sono stati modificati in precedenza in modo da poter annullare facilmente le modifiche. Aperto \/etc\/network\/interfaces in un editor (esempio: sudo nano \/etc\/network\/interfaces ). Aggiungi le seguenti righe (modifica i nomi degli adattatori e gli ID VLAN del controller): # enp1s0.100 vlan (vPLC1)\nauto enp1s0.100\niface enp1s0.100 inet dhcp\n    vlan-raw-device enp1s0\n# enp1s0.200 vlan (vPLC2)\nauto enp1s0.200\niface enp1s0.200 inet dhcp\n    vlan-raw-device enp1s0 Per ulteriori informazioni su questo file, vedere: https:\/\/wiki.debian.org\/NetworkConfiguration Riavvia il sistema o esegui il comando sudo systemctl restart networking per applicare le modifiche. Questo metodo di configurazione è stato testato su Debian 12. Potrebbe essere necessario selezionare un metodo diverso per il dispositivo o il sistema operativo per salvare la configurazione in modo permanente Altri esempi sono netplan ( https:\/\/netplan.readthedocs.io\/en\/stable\/structure-id\/ ) o NetworkManager ( https:\/\/networkmanager.dev\/ ). Le istruzioni appropriate per il controller sono disponibili nella rispettiva documentazione. " }, 
{ "title" : "Scenario «virtuale con Fieldbus»: vPLC + License Server + Edge Gateway + Fieldbus ", 
"url" : "_rtsl_scenario_virtual_fieldbus.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario «virtuale con Fieldbus»: vPLC + License Server + Edge Gateway + Fieldbus ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Requisiti ", 
"url" : "_rtsl_scenario_virtual_fieldbus.html#UUID-8d90cd73-67b3-e75d-2d43-8f604bccd457_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario «virtuale con Fieldbus»: vPLC + License Server + Edge Gateway + Fieldbus \/ Requisiti ", 
"snippet" : "Scenario Configurazione riuscita del Scenario «parco giochi virtuale»: vPLC + License Server + Edge GatewayHardware È inoltre necessario il seguente dispositivo: Dispositivi Fieldbus (basati su Ethernet), ad esempio Profinet....", 
"body" : "Scenario Configurazione riuscita del Scenario «parco giochi virtuale»: vPLC + License Server + Edge GatewayHardware È inoltre necessario il seguente dispositivo: Dispositivi Fieldbus (basati su Ethernet), ad esempio Profinet. " }, 
{ "title" : "Configurazione del bus di campo ", 
"url" : "_rtsl_scenario_virtual_fieldbus.html#UUID-8d90cd73-67b3-e75d-2d43-8f604bccd457_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario «virtuale con Fieldbus»: vPLC + License Server + Edge Gateway + Fieldbus \/ Configurazione del bus di campo ", 
"snippet" : "Un adattatore Ethernet per la connessione fieldbus viene assegnato a un'istanza PLC virtuale come segue: Nel vPLC sezione, selezionate l'istanza vPLC desiderata e fate clic Stop Selected . Lo stato del PLC cambia in «Arrestato». Le impostazioni corrispondenti sono visualizzate in Impostazioni . Sott...", 
"body" : "Un adattatore Ethernet per la connessione fieldbus viene assegnato a un'istanza PLC virtuale come segue: Nel vPLC sezione, selezionate l'istanza vPLC desiderata e fate clic Stop Selected . Lo stato del PLC cambia in «Arrestato». Le impostazioni corrispondenti sono visualizzate in Impostazioni . Sotto Nic , selezionare l'adattatore di rete del PC host Linux utilizzato per la connessione fieldbus. Se necessario, assegnate un indirizzo IP e una maschera di rete Fare clic Salva per confermare la modifica. Le impostazioni vengono applicate sul PC host Linux. Fare clic Inizio selezionato per avviare l'istanza vPLC. Lo stato del PLC cambia in «In esecuzione». L'adattatore di rete è ora assegnato esclusivamente al vPLC configurato e non è più disponibile sul PC host Linux. Il fieldbus può ora essere configurato e CODESYS . " }, 
{ "title" : "Scenario «La casa sicura»: vPLC + vSafe + PROFIsafe + Time Provider + License Server ", 
"url" : "_rtsl_scenario_safe_house.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario «La casa sicura»: vPLC + vSafe + PROFIsafe + Time Provider + License Server ", 
"snippet" : "La documentazione nelle pagine seguenti viene fornita solo a scopo informativo. Per restrizioni e informazioni sulla sicurezza o sulla certificazione, consultare la documentazione di sicurezza del produttore del dispositivo che si sta programmando...", 
"body" : "La documentazione nelle pagine seguenti viene fornita solo a scopo informativo. Per restrizioni e informazioni sulla sicurezza o sulla certificazione, consultare la documentazione di sicurezza del produttore del dispositivo che si sta programmando " }, 
{ "title" : "Requisiti ", 
"url" : "_rtsl_scenario_safe_house.html#UUID-8c70494a-5eac-cd26-0994-8e503c1ca9ab_section-idm234653932399925", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario «La casa sicura»: vPLC + vSafe + PROFIsafe + Time Provider + License Server \/ Requisiti ", 
"snippet" : "Scenari: Il requisito per questo scenario è la corretta configurazione del Scenario «virtuale con Fieldbus»: vPLC + License Server + Edge Gateway + Fieldbus. Hardware Sono inoltre necessari i seguenti dispositivi: PC desktop con CODESYS Development System installato PC host Linux con Edge Gateway vi...", 
"body" : "Scenari: Il requisito per questo scenario è la corretta configurazione del Scenario «virtuale con Fieldbus»: vPLC + License Server + Edge Gateway + Fieldbus. Hardware Sono inoltre necessari i seguenti dispositivi: PC desktop con CODESYS Development System installato PC host Linux con Edge Gateway virtuale, PLC virtuale 1 e server di licenza installati Sono inoltre necessari i seguenti dispositivi aggiuntivi: Host per il time provider, denominato Linux Host PC 2 nel diagramma. Requisiti per questo host: il sistema operativo Linux e Docker devono essere installati e SSH configurato Real-time capable network to the Linux Host PC to ensure deterministic transmission of data packages. Prodotti aggiuntivi CODESYS Virtual Safe Control SL deve essere installato sul PC desktop. " }, 
{ "title" : "Linux Host PC 2 ", 
"url" : "_rtsl_scenario_safe_house.html#UUID-8c70494a-5eac-cd26-0994-8e503c1ca9ab_section-idm2346539369198", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario «La casa sicura»: vPLC + vSafe + PROFIsafe + Time Provider + License Server \/ Linux Host PC 2 ", 
"snippet" : "Sul Linux Host PC 2, configura il time provider. Il time provider invia l'ora corrente a una destinazione configurata e può essere utilizzato per fornire il secondo orario richiesto da Virtual Safe Control SL. Esegui il comando Utensili → Implementa Control SL e stabilire una connessione al Linux Ho...", 
"body" : "Sul Linux Host PC 2, configura il time provider. Il time provider invia l'ora corrente a una destinazione configurata e può essere utilizzato per fornire il secondo orario richiesto da Virtual Safe Control SL. Esegui il comando Utensili → Implementa Control SL e stabilire una connessione al Linux Host PC 2 ( Comunicazione scheda). Per ulteriori informazioni, vedere: Stabilire una connessioneInstalla le versioni più recenti delle seguenti immagini ( Distribuzione scheda): CODESYS Fornitore di tempo sicuro virtuale Per ulteriori informazioni, vedere: Installing an imageFai clic su Distribuzione scheda. Nel Prodotto casella di riepilogo, seleziona CODESYS Virtual Safe Time Provider SL . Nel Versione casella di riepilogo, seleziona la versione più recente. Fai clic su Installa pulsante. L'immagine CODESYS Virtual Safe Time Provider SL appare nella Immagini installate sezione. Crea le istanze richieste. Sul Linux Host PC 2, è richiesta l'istanza timeprovider, che si crea come segue su Operazione scheda: Nel vPLC sezione, fai clic su pulsante. Le Aggiungi nuova istanza si apre la finestra di dialogo. Specificare timeprovider come nome. Nel Filtro casella di riepilogo, seleziona Safety Timeprovider . Seleziona la versione più recente di CODESYS Virtual Safe Timeprovider SL immagine e clicca OK . La nuova istanza è elencata nella vPLC sezione. Configura le istanze: L'indirizzo IP di destinazione e la porta di destinazione devono essere configurati per timeprovider istanza. L'obiettivo è vHost e porta 60000 per impostazione predefinita. Comandi generici: -e TARGET_IP= [IP o nome host del PC host Linux] -e TARGET_PORT=60000 60000 è la porta predefinita per un Virtual Safe Control SL per ricevere una fonte di ora esterna dal timer. Avvio automatico Sì Quando Sì è selezionato, l'istanza viene avviata automaticamente ogni volta che il sistema viene avviato. Nel vPLC sezione, fai clic su timeprovider istanza. Le impostazioni per timeprovider le istanze vengono visualizzate sul lato destro. TARGET_IP e TARGET_PORT sono già preassegnati in Genericcommands con i valori vSafePLC1 e 60000 . Cambia il TARGET_IP al nome host o all'indirizzo IP del PC host Linux 1. Per ulteriori informazioni, vedere: Rilevamento dell'indirizzo di reteNel Avvio automatico casella di riepilogo, modifica il valore in Sì . Fai clic su Salva pulsante per salvare le modifiche. Per ulteriori informazioni, vedere: Creazione e configurazione di una nuova istanzaAvvia l'istanza. Avvia il timeprovider istanza selezionandola nel vPLC sezione e quindi facendo clic su Inizio selezionato pulsante. Nel Stato colonna, lo stato di tutte le istanze cambia in In esecuzione . " }, 
{ "title" : "PC host Linux ", 
"url" : "_rtsl_scenario_safe_house.html#UUID-8c70494a-5eac-cd26-0994-8e503c1ca9ab_section-idm234653987267355", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario «La casa sicura»: vPLC + vSafe + PROFIsafe + Time Provider + License Server \/ PC host Linux ", 
"snippet" : "Sul PC host Linux, configurare CODESYS Virtual Safe Control for Linux SL . Esegui il comando Utensili → Implementa Control SL e stabilire una connessione al Linux Host PC 2 ( Comunicazione scheda). Passa al Operazione scheda. Installa le versioni più recenti delle seguenti immagini ( Distribuzione s...", 
"body" : "Sul PC host Linux, configurare CODESYS Virtual Safe Control for Linux SL . Esegui il comando Utensili → Implementa Control SL e stabilire una connessione al Linux Host PC 2 ( Comunicazione scheda). Passa al Operazione scheda. Installa le versioni più recenti delle seguenti immagini ( Distribuzione scheda): CODESYS Virtual Safe Control SL Crea le istanze richieste. Sul Linux Host PC 1, è richiesta l'istanza vSafePLC, che si crea come segue nel Funzionamento scheda: Nel vPLC sezione, fai clic su pulsante. Le Aggiungi nuova istanza si apre la finestra di dialogo. Specificare vSafePLC come nome. Nel Filtro casella di riepilogo, seleziona Sistema di runtime di sicurezza . Quindi seleziona la versione più recente di CODESYS Virtual Safe Control for Linux SL immagine. Quindi fai clic OK . La nuova istanza è elencata nella vPLC sezione. Insieme alle istanze create su questo dispositivo nell'ultimo scenario, le seguenti istanze dovrebbero ora essere disponibili nel VPLCs sezione: Istanza Stato Prodotto Gateway Fermato Gateway vPLC Fermato Sistema di runtime PLC vSafe Fermato Sistema di sicurezza in fase di esecuzione Verificate se la seguente voce è disponibile nel Services sezione: Prodotto Stato CODESYS LicenseServer per Linux SL Correre Prima di riconfigurare, fare clic su Ferma tutto pulsante per interrompere le istanze. Lo stato di tutte le istanze cambia in Fermato . Nel vPLC sezione, fai clic su vSafePLC istanza. Le impostazioni per vSafePLC le istanze sono visualizzate sul lato destro. Configura il vSafePLC istanza come segue: Porte: 60000:60000 \/udp Questa è la porta predefinita per un Virtual Safe Control SL per ricevere una fonte di ora esterna dal fornitore di orario Ipc: Contenitore: VPLC Accesso allo spazio dei nomi IPC dell'istanza vPLC per la comunicazione tra queste due istanze. Dipendenze: vPLC Il vPLC deve essere avviato per primo perché questo crea lo spazio dei nomi IPC a cui questa istanza vuole unirsi. Una dipendenza garantirà Nel vPLC sezione, fai clic su vPLC istanza. Le impostazioni per l'istanza vSafePLC sono visualizzate sul lato destro. Configura il vPLC esempio come segue: IPC: condivisibile Crea uno spazio dei nomi IPC per questo contenitore che può essere utilizzato da altri contenitori. In questo caso, l'istanza vSafePLC dovrebbe unirsi per la comunicazione tra queste due istanze Avvia le istanze. Nel vPLC sezione, fai clic su Inizia tutto pulsante per avviare tutte le istanze. Nel Stato colonna, lo stato di tutte le istanze cambia in In esecuzione . Controlla la configurazione. Per assicurarsi che gli orari del timeprovider arrivino al vSafePLC come desiderato e configurato, è possibile verificarlo nel registro dell'istanza. Per fare ciò, seleziona vSafePLCs istanza in vPLC sezione. Nel Azioni sezione in alto a destra, fai clic su Mostra registro pulsante. Le Registro di sistema di runtime si apre una finestra. Il messaggio External Time Provider found esiste nel registro. Tutti i dispositivi necessari sono ora pronti. I passaggi successivi per la creazione di un progetto e l'integrazione di PROFIsafe sono Estensione di sicurezza CODESYS documentazione. " }, 
{ "title" : "Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su un sistema ", 
"url" : "_rtsl_scenario_virtual_redundancy.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su un sistema ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Requisiti ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su un sistema \/ Requisiti ", 
"snippet" : "Scenario Configurazione riuscita del Scenario «parco giochi virtuale»: vPLC + License Server + Edge Gateway scenario con almeno due vPLC....", 
"body" : "Scenario Configurazione riuscita del Scenario «parco giochi virtuale»: vPLC + License Server + Edge Gateway scenario con almeno due vPLC. " }, 
{ "title" : "Configurazione della rete di contenitori: ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su un sistema \/ Configurazione della rete di contenitori: ", 
"snippet" : "Per garantire la funzionalità della ridondanza, i controller utilizzati devono avere indirizzi IP statici. Se un indirizzo IP cambia, la connessione al dispositivo non può essere ristabilita automaticamente. Le reti devono essere configurate direttamente tramite il motore del contenitore utilizzato....", 
"body" : "Per garantire la funzionalità della ridondanza, i controller utilizzati devono avere indirizzi IP statici. Se un indirizzo IP cambia, la connessione al dispositivo non può essere ristabilita automaticamente. Le reti devono essere configurate direttamente tramite il motore del contenitore utilizzato. Per farlo, connettiti al tuo PC host Linux tramite SSH. Nel terminale, immettere il seguente comando (l'indirizzo IP, la subnet e il nome della rete possono essere selezionati liberamente). docker network create --subnet=192.168.5.0\/24 mynetwork " }, 
{ "title" : "Configurazione delle istanze ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm23496702624416", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su un sistema \/ Configurazione delle istanze ", 
"snippet" : "Ora è necessario specificare un indirizzo IP separato per le istanze vPLC e assegnare la rete. PLC virtuale 1: Comandi generici --ip 192.168.5.1 Indirizzo IP statico dell'istanza. Il comando generico --ip è consentito solo quando l'istanza si trova in una rete di contenitori con una subnet corrispon...", 
"body" : "Ora è necessario specificare un indirizzo IP separato per le istanze vPLC e assegnare la rete. PLC virtuale 1: Comandi generici --ip 192.168.5.1 Indirizzo IP statico dell'istanza. Il comando generico --ip è consentito solo quando l'istanza si trova in una rete di contenitori con una subnet corrispondente. Rete mynetwork Rete di contenitori per le istanze configurate PLC virtuale 2: Comandi generici: --ip 192.168.5. 2 Indirizzo IP statico dell'istanza. Il comando generico --ip è consentito solo quando l'istanza si trova in una rete di container con una subnet corrispondente. Rete: mynetwork Rete di contenitori per le istanze configurate Anche l'Edge Gateway virtuale deve essere aggiunto alla rete. Gateway Edge virtuale: Rete mynetwork Rete di contenitori per le istanze configurate " }, 
{ "title" : "Avvio delle istanze virtuali ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm234967029997363", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su un sistema \/ Avvio delle istanze virtuali ", 
"snippet" : "Nel vPLC sezione, fare clic su Inizia tutto pulsante. Lo stato delle istanze virtuali configurate cambia in Running . Per la funzione di ridondanza, seguire le istruzioni Introduzione – Configurazione del sistema di ridondanza...", 
"body" : "Nel vPLC sezione, fare clic su Inizia tutto pulsante. Lo stato delle istanze virtuali configurate cambia in Running . Per la funzione di ridondanza, seguire le istruzioni Introduzione – Configurazione del sistema di ridondanza " }, 
{ "title" : "Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su due sistemi ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm234968298823991", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su un sistema \/ Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su due sistemi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Requisiti ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43496829968904", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su un sistema \/ Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su due sistemi \/ Requisiti ", 
"snippet" : "Scenario Configurazione riuscita del Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su un sistema scenario. Hardware Sono inoltre richiesti i seguenti dispositivi: Host per vPLC aggiuntivi, denominato Linux Host PC 2 nel diagramma. Requisiti per questo host È necessa...", 
"body" : "Scenario Configurazione riuscita del Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su un sistema scenario. Hardware Sono inoltre richiesti i seguenti dispositivi: Host per vPLC aggiuntivi, denominato Linux Host PC 2 nel diagramma. Requisiti per questo host È necessario che il sistema operativo Linux e Docker siano installati e che SSH sia configurato. Rete in grado di comunicare in tempo reale con il PC host Linux per garantire la trasmissione deterministica di pacchetti di dati sensibili al fattore tempo. Configurazione aggiuntiva delle istanze su entrambi i sistemi. Per ulteriori informazioni, vedere: Configurazione delle istanzePer le due istanze sui rispettivi host è necessario configurare quanto segue. porti 1205:1205 Questa è la porta predefinita per la comunicazione di ridondanza. È anche possibile modificare questa porta nell'interfaccia di configurazione della ridondanza nel progetto. Si noti, tuttavia, che la modifica deve essere apportata anche nella configurazione delle istanze corrispondenti. " }, 
{ "title" : "Avvio delle istanze virtuali ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43496830001058", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su un sistema \/ Scenario: \"Ridondanza virtuale\": vPLC + vPLC + server di licenza + gateway edge su due sistemi \/ Requisiti \/ Avvio delle istanze virtuali ", 
"snippet" : "Nel vPLC sezione, fare clic su Inizia tutto pulsante. Lo stato delle istanze virtuali configurate cambia in Running . Per la funzione di ridondanza, seguire le istruzioni Introduzione – Configurazione del sistema di ridondanza...", 
"body" : "Nel vPLC sezione, fare clic su Inizia tutto pulsante. Lo stato delle istanze virtuali configurate cambia in Running . Per la funzione di ridondanza, seguire le istruzioni Introduzione – Configurazione del sistema di ridondanza " }, 
{ "title" : "CODESYS TargetVisu for Linux SL ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ CODESYS TargetVisu for Linux SL ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Casi d'uso ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412002576", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ CODESYS TargetVisu for Linux SL \/ Casi d'uso ", 
"snippet" : "CODESYS TargetVisu for Linux SL è un piccolo sistema runtime separato che gestisce la visualizzazione di una visualizzazione. CODESYS TargetVisu for Linux SL copre i seguenti casi d'uso: CODESYS TargetVisu for Linux SL può essere configurato in diversi modi: Come Remote TargetVisu che si collega a u...", 
"body" : "CODESYS TargetVisu for Linux SL è un piccolo sistema runtime separato che gestisce la visualizzazione di una visualizzazione. CODESYS TargetVisu for Linux SL copre i seguenti casi d'uso: CODESYS TargetVisu for Linux SL può essere configurato in diversi modi: Come Remote TargetVisu che si collega a un altro controller Come TargetVisu locale che viene eseguito direttamente sul controller Questo caso d'uso non è adatto per i controller con esigenze in tempo reale. Per ulteriori informazioni, vedere: Ottimizzazione delle prestazioniRispetto alle visualizzazioni target classiche, CODESYS TargetVisu for Linux SL offre i seguenti vantaggi: I processi sono separati gli uni dagli altri. Un errore nella visualizzazione non arresta automaticamente la macchina. La visualizzazione consuma meno risorse perché richiede meno componenti. Tutte le comunicazioni avvengono tramite CODESYS protocollo di comunicazione ed è quindi sicuro. " }, 
{ "title" : "Requisiti ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412127657", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ CODESYS TargetVisu for Linux SL \/ Requisiti ", 
"snippet" : "Per poter utilizzare CODESYS TargetVisu for Linux SL , il sistema deve soddisfare i seguenti requisiti: Sul sistema devono essere installate le seguenti librerie: libqt6core6 libqt6gui6 libqt6widgets6 libqt6network6 libqt6svg6 libqt6webenginewidgets6 libqt6webenginecore6 libqt6webenginequick6 libqt6...", 
"body" : "Per poter utilizzare CODESYS TargetVisu for Linux SL , il sistema deve soddisfare i seguenti requisiti: Sul sistema devono essere installate le seguenti librerie: libqt6core6 libqt6gui6 libqt6widgets6 libqt6network6 libqt6svg6 libqt6webenginewidgets6 libqt6webenginecore6 libqt6webenginequick6 libqt6webview6 libqt6webviewquick6 libqt6qmlworkerscript6 libqt6quickshapes6 libqt6quickcontrols2-6 libqt6quickcontrols2impl6 libqt6quicktemplates2-6 Sul sistema deve essere installato un ambiente desktop, ad esempio: Xfce KDE gnome lxde È necessario collegare un display fisico al dispositivo di destinazione. L'utilizzo con X-Forwarding o simili non è testato. È necessario installare Qt versione 6.4.2 o successiva (ad esempio, almeno Debian 12 o Ubuntu 23.10). " }, 
{ "title" : "Utilizzando CODESYS TargetVisu for Linux SL nel progetto ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412333472", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ CODESYS TargetVisu for Linux SL \/ Utilizzando CODESYS TargetVisu for Linux SL nel progetto ", 
"snippet" : "Per poter utilizzare CODESYS TargetVisu for Linux SL , è necessario disabilitare il file Supporta animazioni client e sovrapposizione di elementi nativi opzione nel Gestore visualizzazione. Nella struttura dei dispositivi, seleziona Gestione visualizzazione. Inserisci il TargetVisu remoto oggetto so...", 
"body" : "Per poter utilizzare CODESYS TargetVisu for Linux SL , è necessario disabilitare il file Supporta animazioni client e sovrapposizione di elementi nativi opzione nel Gestore visualizzazione. Nella struttura dei dispositivi, seleziona Gestione visualizzazione. Inserisci il TargetVisu remoto oggetto sottostante. Aprire Remote TargetVisu nell'editor del dispositivo e definire lì la visualizzazione iniziale desiderata. " }, 
{ "title" : "Installazione CODESYS TargetVisu for Linux SL sul dispositivo di destinazione ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412538107", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ CODESYS TargetVisu for Linux SL \/ Installazione CODESYS TargetVisu for Linux SL sul dispositivo di destinazione ", 
"snippet" : "Fai clic su Strumenti → Implementa Control SL comando di menu. Le Implementa Control SL si apre la scheda. Stabilire una connessione con il controller. Per ulteriori informazioni, vedere: Connessione al sistema di destinazioneFai clic su Distribuzione scheda. Nel Prodotto casella di riepilogo, selez...", 
"body" : "Fai clic su Strumenti → Implementa Control SL comando di menu. Le Implementa Control SL si apre la scheda. Stabilire una connessione con il controller. Per ulteriori informazioni, vedere: Connessione al sistema di destinazioneFai clic su Distribuzione scheda. Nel Prodotto casella di riepilogo, seleziona CODESYS TargetVisu for Linux SL prodotto. Nel Versione casella di riepilogo, seleziona la versione desiderata. Fai clic su Installa pulsante. L'account utilizzato per l'installazione CODESYS TargetVisu for Linux SL deve essere lo stesso account utilizzato per accedere al dispositivo. CODESYS controlla che tutte le librerie richieste siano installate e che Qt sia disponibile almeno nella versione sopra specificata. Prima di poter utilizzare la visualizzazione di destinazione, il dispositivo di destinazione deve essere riavviato una volta. " }, 
{ "title" : "Risoluzione dei problemi ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374413199442", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Casi d'uso \/ CODESYS TargetVisu for Linux SL \/ Risoluzione dei problemi ", 
"snippet" : "Prima CODESYS TargetVisu for Linux SL versione 4.13.0.0 L'accesso locale non riesce Se viene visualizzata una schermata nera durante l'accesso dopo l'installazione e quindi viene visualizzata nuovamente la schermata di accesso, potrebbe esserci un errore con DISPLAY variabile d'ambiente che è stata ...", 
"body" : "Prima CODESYS TargetVisu for Linux SL versione 4.13.0.0 L'accesso locale non riesce Se viene visualizzata una schermata nera durante l'accesso dopo l'installazione e quindi viene visualizzata nuovamente la schermata di accesso, potrebbe esserci un errore con DISPLAY variabile d'ambiente che è stata impostata. Per verificarlo, puoi cancellare il Imposta X Display + User al momento dell'accesso opzione nella finestra di dialogo di configurazione della visualizzazione del target in CODESYS . Se in seguito riesci ad accedere al dispositivo di destinazione, controlla l'output di echo $DISPLAY . Inserisci questo valore in \/etc\/default\/codesysvisualization per il valore XDISPLAY e riprova. " }, 
{ "title" : "Risoluzione dei problemi ", 
"url" : "_rtsl_troubleshooting.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Sistema di programmazione\/IDE\/ Deploy Tool ", 
"url" : "_rtsl_toubleshooting_deploytool.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool ", 
"snippet" : "I capitoli seguenti forniscono istruzioni per la risoluzione dei problemi con i prodotti SL basati su Linux e CODESYS Development System o il Deploy Tool . Deploy Tool è un plug-in che puoi utilizzare per installare i prodotti SL basati su Linux sul tuo sistema Linux....", 
"body" : "I capitoli seguenti forniscono istruzioni per la risoluzione dei problemi con i prodotti SL basati su Linux e CODESYS Development System o il Deploy Tool . Deploy Tool è un plug-in che puoi utilizzare per installare i prodotti SL basati su Linux sul tuo sistema Linux. " }, 
{ "title" : "L'installazione del prodotto termina con un errore. ", 
"url" : "_rtsl_toubleshooting_deploytool1.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ L'installazione del prodotto termina con un errore. ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Requisiti ", 
"url" : "_rtsl_toubleshooting_deploytool1.html#UUID-11b462c5-1f28-10cc-d2e1-e6130d87abc3_section-idm234790470711208", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ L'installazione del prodotto termina con un errore. \/ Requisiti ", 
"snippet" : "Le CODESYS l'installazione include le specifiche del prodotto CODESYS pacchetto (e i prodotti dipendenti). È possibile ottenere una panoramica dei prodotti installati nella CODESYS Installer nell'elenco dei componenti aggiuntivi installati....", 
"body" : "Le CODESYS l'installazione include le specifiche del prodotto CODESYS pacchetto (e i prodotti dipendenti). È possibile ottenere una panoramica dei prodotti installati nella CODESYS Installer nell'elenco dei componenti aggiuntivi installati. " }, 
{ "title" : "Risoluzione dei problemi ", 
"url" : "_rtsl_toubleshooting_deploytool1.html#UUID-11b462c5-1f28-10cc-d2e1-e6130d87abc3_section-idm234790470799509", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ L'installazione del prodotto termina con un errore. \/ Risoluzione dei problemi ", 
"snippet" : "Gli errori durante l'installazione possono essere causati dal dispositivo di destinazione. Gli errori più comuni sono i file system di sola lettura e le dipendenze obsolete o mancanti Tutti i prodotti prevedono che il loro pacco venga immagazzinato nel luogo in cui CODESYS Installer lo ha archiviato...", 
"body" : "Gli errori durante l'installazione possono essere causati dal dispositivo di destinazione. Gli errori più comuni sono i file system di sola lettura e le dipendenze obsolete o mancanti Tutti i prodotti prevedono che il loro pacco venga immagazzinato nel luogo in cui CODESYS Installer lo ha archiviato al momento dell'installazione del componente aggiuntivo. Le Deploy Tool esegue le seguenti operazioni per ogni prodotto installato: Interrompere il processo di runtime. Salva il vecchio file di configurazione. Elimina il pacchetto esistente. Trasferisci il nuovo pacchetto. Di seguito sono elencati ulteriori controlli specifici del prodotto, tra cui Deploy Tool esegue in base al prodotto. Il Package Manager tenta quindi di installare il pacchetto appena trasferito: BeagleBoneBlack Non vengono eseguiti passaggi o controlli aggiuntivi. Edge Gateway Le Deploy Tool controlla se il dispositivo ha un'architettura armv4, armv5 o armv6. Il valore viene letto eseguendo uname -m . emPC Non vengono eseguiti passaggi o controlli aggiuntivi. IOT2000 Non vengono eseguiti passaggi o controlli aggiuntivi. Server di licenza Le Deploy Tool tenta di installare una versione corrente di Codemeter. Se Codemeter o Codemeter Lite sono installati nella stessa versione o in una versione più recente Deploy Tool , quindi non verrà apportata alcuna modifica al sistema. Se è necessario un aggiornamento o una modifica, si aprirà una finestra di dialogo da concordare prima di apportare modifiche al sistema. Se accettate, la versione attualmente installata di Codemeter verrà rimossa e verrà installata una versione corrente. Tieni presente che il CODESYS License Server for Linux SL non può essere utilizzato se Codemeter non è installato sul sistema. Le Deploy Tool consente anche di installare un plug-in opzionale chiamato «Cockpit». Ciò consente CODESYS WBM da utilizzare, che facilita l'attivazione delle licenze sul dispositivo di destinazione. Puoi rifiutare questa opzione e il processo di installazione continuerà. Se siete d'accordo e si verifica un errore durante l'installazione del pacchetto Cockpit, il processo di installazione verrà interrotto Linux SL LinuxARM SL LinuxARM64 SL Le Deploy Tool tenta di installare una versione corrente di Codemeter. Se Codemeter o Codemeter Lite sono installati nella stessa versione o in una versione più recente Deploy Tool , quindi non verrà apportata alcuna modifica al sistema. Se è necessario un aggiornamento o una modifica, si aprirà una finestra di dialogo da concordare prima di apportare modifiche al sistema. Se siete d'accordo, la versione attualmente installata di Codemeter verrà rimossa e verrà invece installata una versione corrente Si noti che questi prodotti non possono essere utilizzati se Codemeter non è installato sul sistema. Safe Control Non vengono eseguiti passaggi o controlli aggiuntivi. SafeTimeProvider Non vengono eseguiti passaggi o controlli aggiuntivi. PFC100 PFC200 Prima della versione 4.15: Le Deploy Tool tenta di installare il pacchetto EntropyHelper. I prodotti si aspettano che il pacchetto venga archiviato nella posizione in cui CODESYS Installer lo ha archiviato al momento dell'installazione del componente aggiuntivo. Se il pacchetto non è elencato, non è stato trovato o l'installazione non riesce, il prodotto non verrà installato TP600 Non vengono eseguiti passaggi o controlli aggiuntivi. PLCNext Le Deploy Tool tenta di leggere la versione del firmware con il seguente comando: cat \/etc\/plcnext\/arpversion | head -1 | cut -f2 -d' ' | cut -f-3 -d '.' Se la versione non può essere letta, l'installazione viene interrotta. Le Deploy Tool cerca localmente il codesys-arp PLCnext pacchetto in una versione corrispondente al firmware. Il pacchetto è installato. Se non viene trovato alcun pacchetto o l'installazione non riesce, l'installazione del prodotto viene interrotta. Raspberry Pi Dopo l'installazione del pacchetto, viene definito il tipo di runtime da utilizzare. Il tipo dipende dai caricatori disponibili nel sistema. I caricatori vengono recuperati Architetture Userlandcapitolo». Se non viene trovato alcun loader, viene utilizzata la variante armv6l. L'elenco seguente mostra Multicore a 64 bit: aarch64 Multicore a 32 bit: ARMv7 Standard (senza multicore): ARMv6 A seconda del sistema in uso, è possibile modificare questa impostazione nella Deploy Tool dopo l'installazione del prodotto. TargetVisualization Non vengono eseguiti passaggi o controlli aggiuntivi. Virtual Control Virtual Edge Virtual Safe Virtual SafeTimeProvider Python versione 3.9 o successiva e Docker o Podman devono essere installati sul dispositivo. " }, 
{ "title" : "La connessione al dispositivo di destinazione non riesce. ", 
"url" : "_rtsl_toubleshooting_deploytool2.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ La connessione al dispositivo di destinazione non riesce. ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Requisiti ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790221847662", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ La connessione al dispositivo di destinazione non riesce. \/ Requisiti ", 
"snippet" : "Il server SSH sul dispositivo di destinazione è in esecuzione su una porta nota (ad esempio, la porta 22). L'indirizzo IP corretto del dispositivo di destinazione è noto. È possibile eseguire il ping del dispositivo di destinazione tramite l'indirizzo IP...", 
"body" : "Il server SSH sul dispositivo di destinazione è in esecuzione su una porta nota (ad esempio, la porta 22). L'indirizzo IP corretto del dispositivo di destinazione è noto. È possibile eseguire il ping del dispositivo di destinazione tramite l'indirizzo IP " }, 
{ "title" : "Risoluzione dei problemi ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790223645865", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ La connessione al dispositivo di destinazione non riesce. \/ Risoluzione dei problemi ", 
"snippet" : "Anche altri problemi, come una rete lenta o un errore di rete, possono causare l'interruzione della connessione. Dopo la connessione al dispositivo di destinazione, Deploy Tool legge alcuni parametri di sistema per determinare quali pacchetti e funzioni sono disponibili. Vengono controllati i seguen...", 
"body" : "Anche altri problemi, come una rete lenta o un errore di rete, possono causare l'interruzione della connessione. Dopo la connessione al dispositivo di destinazione, Deploy Tool legge alcuni parametri di sistema per determinare quali pacchetti e funzioni sono disponibili. Vengono controllati i seguenti aspetti del dispositivo di destinazione: " }, 
{ "title" : "Architetture Userland ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790227601997", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ La connessione al dispositivo di destinazione non riesce. \/ Risoluzione dei problemi \/ Architetture Userland ", 
"snippet" : "Le Deploy Tool rileva i caricatori disponibili sul dispositivo di destinazione. I caricatori disponibili determinano quali file binari possono essere eseguiti. A tale scopo Deploy Tool esegue il comando seguente: ls -la \/lib*\/ld-linux* Se l'output contiene uno dei seguenti valori, la rispettiva arch...", 
"body" : "Le Deploy Tool rileva i caricatori disponibili sul dispositivo di destinazione. I caricatori disponibili determinano quali file binari possono essere eseguiti. A tale scopo Deploy Tool esegue il comando seguente: ls -la \/lib*\/ld-linux* Se l'output contiene uno dei seguenti valori, la rispettiva architettura è considerata disponibile: x86-64, i386, x32, armhf, aarch64. Per la versione 4.14.0.0: Se non viene trovato nessuno di questi valori, la connessione viene disconnessa. Per la versione 4.15.0.0 e successive: Se non viene trovato nessuno di questi valori, Deploy Tool stampa un messaggio di registro che indica che non è stata rilevata alcuna architettura Userland. Vengono quindi controllati i seguenti parametri. Tuttavia, ciò non dovrebbe causare una disconnessione. " }, 
{ "title" : "Architettura del dispositivo ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790234401598", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ La connessione al dispositivo di destinazione non riesce. \/ Risoluzione dei problemi \/ Architettura del dispositivo ", 
"snippet" : "Le Deploy Tool controlla quale CPU è disponibile sul dispositivo di destinazione. A tale scopo, Deploy Tool esegue i seguenti comandi: lscpu | grep ^Architecture: Se l'output contiene uno dei seguenti valori, viene utilizzata la rispettiva architettura: x86_64, i686, aarch64, armv7l, armv6l. Se l'ou...", 
"body" : "Le Deploy Tool controlla quale CPU è disponibile sul dispositivo di destinazione. A tale scopo, Deploy Tool esegue i seguenti comandi: lscpu | grep ^Architecture: Se l'output contiene uno dei seguenti valori, viene utilizzata la rispettiva architettura: x86_64, i686, aarch64, armv7l, armv6l. Se l'output non contiene nessuno di questi valori, allora il comando cat \/proc\/cpuinfo | grep '^model name' viene eseguito. cat \/proc\/cpuinfo | grep '^model name' Se l'output contiene uno dei seguenti valori, viene utilizzata la rispettiva architettura: x86_64, i686, aarch64, armv7l, armv6l. Se l'output non contiene nessuno di questi valori, viene stampato un messaggio di registro. " }, 
{ "title" : "Motore per container ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790244053777", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ La connessione al dispositivo di destinazione non riesce. \/ Risoluzione dei problemi \/ Motore per container ", 
"snippet" : "Le Deploy Tool controlla quali motori di container sono disponibili sul dispositivo di destinazione. A tale scopo, Deploy Tool esegue i seguenti comandi: which docker Se il codice di uscita è 0, Docker viene riconosciuto come motore. which podman Se il codice di uscita è 0, Podman viene riconosciuto...", 
"body" : "Le Deploy Tool controlla quali motori di container sono disponibili sul dispositivo di destinazione. A tale scopo, Deploy Tool esegue i seguenti comandi: which docker Se il codice di uscita è 0, Docker viene riconosciuto come motore. which podman Se il codice di uscita è 0, Podman viene riconosciuto come motore. L'uso simultaneo di due motori per container non è stato testato e non è completamente supportato. Di conseguenza, ciò potrebbe causare problemi " }, 
{ "title" : "Architettura del contenitore ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm2347902491793", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ La connessione al dispositivo di destinazione non riesce. \/ Risoluzione dei problemi \/ Architettura del contenitore ", 
"snippet" : "Le Deploy Tool controlla quali architetture il motore del contenitore può eseguire. Per fare ciò Deploy Tool esegue il comando seguente, a seconda del motore rilevato: docker info Se il Architecture: l'output contiene uno dei seguenti valori, quindi viene utilizzata la rispettiva architettura: x86_6...", 
"body" : "Le Deploy Tool controlla quali architetture il motore del contenitore può eseguire. Per fare ciò Deploy Tool esegue il comando seguente, a seconda del motore rilevato: docker info Se il Architecture: l'output contiene uno dei seguenti valori, quindi viene utilizzata la rispettiva architettura: x86_64, aarch64, armv7l, armv6l. Se non viene trovato nessuno di questi valori, viene stampato un messaggio di registro. podman info Se il arch: l'output contiene uno dei seguenti valori, quindi viene utilizzata la rispettiva architettura: amd64, aarch64, armv7l, armv6l. Se non viene trovato nessuno di questi valori, viene stampato un messaggio di registro. " }, 
{ "title" : "Processo di avvio ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790249419828", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ La connessione al dispositivo di destinazione non riesce. \/ Risoluzione dei problemi \/ Processo di avvio ", 
"snippet" : "Le Deploy Tool controlla quali processi di init sono disponibili sul dispositivo di destinazione. Per fare ciò, Deploy Tool esegue i seguenti comandi: systemctl > \/dev\/null 2>&1 ; echo $? Se il codice di uscita è 0 e l'output contiene 0, allora systemd è riconosciuto come processo di inizializzazion...", 
"body" : "Le Deploy Tool controlla quali processi di init sono disponibili sul dispositivo di destinazione. Per fare ciò, Deploy Tool esegue i seguenti comandi: systemctl > \/dev\/null 2>&1 ; echo $? Se il codice di uscita è 0 e l'output contiene 0, allora systemd è riconosciuto come processo di inizializzazione disponibile. ls \/etc\/init.d > \/dev\/null 2>&1 ; echo $? Se il codice di uscita è 0 e l'output contiene 0, allora initd è riconosciuto come processo di inizializzazione disponibile. " }, 
{ "title" : "Gestori di pacchetti ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790249681867", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ La connessione al dispositivo di destinazione non riesce. \/ Risoluzione dei problemi \/ Gestori di pacchetti ", 
"snippet" : "Le Deploy Tool controlla quali gestori di pacchetti sono disponibili sul dispositivo di destinazione. Per fare ciò, Deploy Tool esegue i seguenti comandi: which dpkg > \/dev\/null 2>&1; echo $? Se il codice di uscita è 0 e l'output contiene 0, allora dpkg è registrato come gestore di pacchetti disponi...", 
"body" : "Le Deploy Tool controlla quali gestori di pacchetti sono disponibili sul dispositivo di destinazione. Per fare ciò, Deploy Tool esegue i seguenti comandi: which dpkg > \/dev\/null 2>&1; echo $? Se il codice di uscita è 0 e l'output contiene 0, allora dpkg è registrato come gestore di pacchetti disponibile. which ipkg > \/dev\/null 2>&1; echo $? Se il codice di uscita è 0 e l'output contiene 0, allora ipkg è registrato come gestore di pacchetti disponibile. which opkg > \/dev\/null 2>1; echo $? Se il codice di uscita è 0 e l'output contiene 0, allora opkg è registrato come gestore di pacchetti disponibile. Per la versione 4.15 e successive: which rpm > \/dev\/null 2>1; echo $? Se il codice di uscita è 0 e l'output contiene 0, allora rpm è registrato come gestore di pacchetti disponibile. Se un prodotto e il tuo sistema supportano dpkg e ipkg o opkg , quindi dpkg è usato. " }, 
{ "title" : "Pitone ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790250012792", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ La connessione al dispositivo di destinazione non riesce. \/ Risoluzione dei problemi \/ Pitone ", 
"snippet" : "Le Deploy Tool controlla se Python è disponibile sul dispositivo di destinazione. Per fare ciò, Deploy Tool esegue il comando seguente: python3 -v Se il codice di uscita è 0 e la versione è maggiore di 3.9, Python viene riconosciuto come installato....", 
"body" : "Le Deploy Tool controlla se Python è disponibile sul dispositivo di destinazione. Per fare ciò, Deploy Tool esegue il comando seguente: python3 -v Se il codice di uscita è 0 e la versione è maggiore di 3.9, Python viene riconosciuto come installato. " }, 
{ "title" : "Il prodotto da installare sul dispositivo di destinazione non può essere selezionato. ", 
"url" : "_rtsl_toubleshooting_deploytool3.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ Il prodotto da installare sul dispositivo di destinazione non può essere selezionato. ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Requisiti ", 
"url" : "_rtsl_toubleshooting_deploytool3.html#UUID-492eba96-8c2f-b3cd-6935-f8dd7506d72f_section-idm23478724692167", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ Il prodotto da installare sul dispositivo di destinazione non può essere selezionato. \/ Requisiti ", 
"snippet" : "Le CODESYS l'installazione include le specifiche del prodotto CODESYS pacchetto (e i prodotti dipendenti). È possibile ottenere una panoramica dei prodotti installati nella CODESYS Installer nell'elenco dei componenti aggiuntivi installati....", 
"body" : "Le CODESYS l'installazione include le specifiche del prodotto CODESYS pacchetto (e i prodotti dipendenti). È possibile ottenere una panoramica dei prodotti installati nella CODESYS Installer nell'elenco dei componenti aggiuntivi installati. " }, 
{ "title" : "Risoluzione dei problemi ", 
"url" : "_rtsl_toubleshooting_deploytool3.html#UUID-492eba96-8c2f-b3cd-6935-f8dd7506d72f_section-idm234787250012849", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Sistema di programmazione\/IDE\/ Deploy Tool \/ Il prodotto da installare sul dispositivo di destinazione non può essere selezionato. \/ Risoluzione dei problemi ", 
"snippet" : "Puoi selezionare un prodotto con Deploy Tool solo quando il dispositivo di destinazione soddisfa i requisiti per questo prodotto (architetture disponibili, gestori di pacchetti, processi di inizializzazione, ecc.). Ogni prodotto richiede un'architettura Userland corrispondente, un gestore di pacchet...", 
"body" : "Puoi selezionare un prodotto con Deploy Tool solo quando il dispositivo di destinazione soddisfa i requisiti per questo prodotto (architetture disponibili, gestori di pacchetti, processi di inizializzazione, ecc.). Ogni prodotto richiede un'architettura Userland corrispondente, un gestore di pacchetti e un processo di inizializzazione (se non diversamente specificato, initd è obbligatorio). Per ulteriori informazioni, vedere: Risoluzione dei problemi. L'elenco seguente mostra cosa controllano i singoli prodotti: Prodotto BeagleBoneBlack L'output di cat \/proc\/cpuinfo | grep '^model name\\|^Hardware' deve contenere ARMv7 e Generic AM33XX . Edge Gateway Se utilizzato su un controller PLCnext, il componente aggiuntivo PLCnext Edge Gateway deve essere disponibile sul computer Windows. (Dovrebbe trovarsi nella L'output del comando uname -m non deve contenere uarmv4 , uarmv5 , oppure uarmv6 . emPC eth0 o eth1 deve avere un indirizzo MAC che inizia con 00:90:E9 . IOT2000 eth0 o eth1 deve avere un indirizzo MAC che inizia con E0:DC:A0 . License Server Nessun controllo aggiuntivo LinuxARM SL und LinuxARM64 SL L'architettura Userland corrispondente deve essere disponibile ( armhf o aarch64 ). Safe Control Richiede un'architettura AMD a 32 bit (i386) SafeTimeProvider Richiede un'architettura AMD a 64 bit (x86-64) e la disponibilità di Python. Per una descrizione di come verificarlo, consulta la sezione «Python» di \" La connessione al dispositivo di destinazione non riesce.capitolo». Linux SL Richiede un'architettura AMD a 64 bit (x86-64) PFC100 PFC200 TP600 Richiede ipkg o opkg e un'architettura ARM a 32 bit ( armhf ) PLCNext Richiede il percorso \/etc\/plcnext\/arpversion esistere Raspberry Pi cat \/proc\/cpuinfo | grep ^Model | awk -F':' '{print $2}' deve contenere «Raspberry». TargetVisualization È necessario installare i seguenti pacchetti. libqt6core6 libqt6gui6 libqt6widgets6 libqt6network6 libqt6svg6 libqt6webenginewidgets6 libqt6webenginecore6 I nomi devono corrispondere esattamente. Il pacchetto installato viene determinato con questo comando: L'output del comando dpkg -l <package> | awk '\/<package>\/ {print }' deve contenere ii per tutti i pacchetti. libqt6core6 deve essere installato nella versione 6.4.2 o superiore. La versione viene determinata con questo comando: dpkg -s libqt6core6 | grep '^Version:' | grep -o -E '\\b[0-9]+\\.[0-9]+\\.[0-9]+\\b' Virtual Control Virtual Edge Virtual Safe Virtual SafeTimeProvider Python deve essere disponibile. Per una descrizione di come verificarlo, consulta la sezione «Python» di \" La connessione al dispositivo di destinazione non riesce.capitolo». Podman o Docker devono essere installati e deve essere disponibile un'immagine che corrisponda a un'architettura di container disponibile. Virtual SafeTimeProvider L'architettura x86-64 Userland e Python devono essere disponibili. Per una descrizione di come verificarlo, consulta la sezione «Python» di \" La connessione al dispositivo di destinazione non riesce.capitolo». Virtual Safe L'architettura i386 Userland e Python devono essere disponibili. Per una descrizione di come verificarlo, consulta la sezione «Python» di \" La connessione al dispositivo di destinazione non riesce.capitolo». Virtual Control Virtual Edge È richiesta una delle architetture Userland x86-64, ARMHF o ARM64 e Python deve essere disponibile. Per una descrizione di come verificarlo, consulta la sezione «Python» di \" La connessione al dispositivo di destinazione non riesce.capitolo». " }, 
{ "title" : "Obiettivo Linux ", 
"url" : "_rtsl_toubleshooting_linuxtarget.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Obiettivo Linux ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Strano comportamento nell'applicazione IEC ", 
"url" : "_rtsl_toubleshooting_linuxtarget_stange.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Obiettivo Linux \/ Strano comportamento nell'applicazione IEC ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Requisiti ", 
"url" : "_rtsl_toubleshooting_linuxtarget_stange.html#UUID-15af7838-c568-6bc8-9b0d-6c5ba94f66cf_section-idm234790740254336", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Obiettivo Linux \/ Strano comportamento nell'applicazione IEC \/ Requisiti ", 
"snippet" : "Stai usando un CODESYS runtime....", 
"body" : "Stai usando un CODESYS runtime. " }, 
{ "title" : "Risoluzione dei problemi ", 
"url" : "_rtsl_toubleshooting_linuxtarget_stange.html#UUID-15af7838-c568-6bc8-9b0d-6c5ba94f66cf_section-idm234790740478094", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Obiettivo Linux \/ Strano comportamento nell'applicazione IEC \/ Risoluzione dei problemi ", 
"snippet" : "Se osservi un comportamento strano, dovresti verificare se il runtime logger fornisce suggerimenti o informazioni preziosi. Il CODESYS runtime logger dispone di un meccanismo per filtrare i messaggi per categoria. Eseguire il debug la categoria non è abilitata per impostazione predefinita. Abilita q...", 
"body" : "Se osservi un comportamento strano, dovresti verificare se il runtime logger fornisce suggerimenti o informazioni preziosi. Il CODESYS runtime logger dispone di un meccanismo per filtrare i messaggi per categoria. Eseguire il debug la categoria non è abilitata per impostazione predefinita. Abilita questa categoria per trovare la causa di comportamenti strani o sintomi imprevisti. Sono disponibili filtri di registro globali e specifici dei componenti. È possibile visualizzare un elenco dettagliato di tutti i possibili filtri specifici dei componenti nel file di registro del runtime. Utilizza i filtri come descritto di seguito Sintomi correlati a Possibile filtro di registro basato su componenti Licenze CmpCodeMeter Compiti\/tempistiche IEC (livello superiore) CmpIecTask Compiti\/tempistiche IEC (livello basso) CmpSchedule , SysTask Applicazione IEC (generale) CmpApp , CmpIecTask Applicazione IEC (memoria) SysMem Comunicazione socket SysSocket Comunicazione Ethernet SysEthernet File\/cartelle SysFile , SysDir Non abilitate tutte le categorie di debug contemporaneamente perché ciò renderebbe difficile l'individuazione del problema effettivo. Procedi passo dopo passo e disabilita i filtri «irrilevanti» per avere una visione migliore del problema Attivare il Eseguire il debug categoria di messaggio tramite la shell PLC (per le versioni runtime >= SP20). Apri il tuo CODESYS proietta e collegalo al controller. Aprire la shell del PLC facendo doppio clic sul controller nell'albero dei dispositivi. Inserisci «? \"nella shell per vedere tutti i comandi possibili. Usa il logsetfilter , loggetfilter , e logdelfilter comandi per scrivere, leggere ed eliminare un filtro. È possibile utilizzare filtri di debug globali per l'intero runtime o filtri per un componente specifico Per leggere la categoria di log corrente a livello globale: loggetfilter potrebbe restituire il seguente risultato: Logger.0.Filter : 0x0000000F Per impostare la categoria di registro corrente a livello globale: logsetfilter 0xffffffff Per leggere la categoria di registro corrente per un componente specifico (ad esempio, CmpCodeMeter ): loggetfilter CmpCodeMeter Per impostare la categoria di registro corrente per un componente specifico (ad esempio, CMPCodeMeter): logsetfilter CmpCodeMeter 0xffffffff Abilitazione della categoria dei logger tramite il file di configurazione del runtime (per le versioni di runtime precedenti) Esempio: tramite una connessione SSH e un editor di testo Interrompi il runtime tramite il Deploy Tool. Connettiti al tuo sistema di destinazione (ad esempio, tramite putty o un altro client SSH). Aprire il file di configurazione specifico dell'utente dell'ambiente di runtime con un editor di testo (ad esempio nano ): sudo nano \/etc\/codesyscontrol\/CODESYSControl_User.cfg Trova il CmpLog sezione e imposta il filtro. Impostazione di un filtro globale Esempio: Logger.0.Filter=0xFFFFFFFFFF per abilitare tutti i messaggi di debug Impostazione di un filtro specifico per i componenti [CmpLog]\nCmpCodeMeter.Filter=0xFFFFFFFF\nSysTask.Filter=0xFFFFFFFF Salva e chiudi il file. Riavviare il runtime con il Deploy Tool. " }, 
{ "title" : "Applicazione IEC ", 
"url" : "_rtsl_toubleshooting_iec.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "L'applicazione IEC dipende dai semafori. ", 
"url" : "_rtsl_toubleshooting_iec_semaphores.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ L'applicazione IEC dipende dai semafori. ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Requisiti ", 
"url" : "_rtsl_toubleshooting_iec_semaphores.html#UUID-0421c326-6af8-0336-eb1f-9f6120d597b5_section-idm234795575934472", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ L'applicazione IEC dipende dai semafori. \/ Requisiti ", 
"snippet" : "Si dispone di una versione di runtime basata su Linux o Windows >= SP20....", 
"body" : "Si dispone di una versione di runtime basata su Linux o Windows >= SP20. " }, 
{ "title" : "Risoluzione dei problemi ", 
"url" : "_rtsl_toubleshooting_iec_semaphores.html#UUID-0421c326-6af8-0336-eb1f-9f6120d597b5_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ L'applicazione IEC dipende dai semafori. \/ Risoluzione dei problemi ", 
"snippet" : "Se si osservano deadlock o blocchi dei semafori durante l'esecuzione dell'applicazione IEC o si eseguono operazioni con CODESYS runtime, ciò potrebbe essere causato da blocchi o deadlock dei semafori. Le versioni runtime SP20 e successive (Linux e Windows) sono in grado di aiutare con una funzione d...", 
"body" : "Se si osservano deadlock o blocchi dei semafori durante l'esecuzione dell'applicazione IEC o si eseguono operazioni con CODESYS runtime, ciò potrebbe essere causato da blocchi o deadlock dei semafori. Le versioni runtime SP20 e successive (Linux e Windows) sono in grado di aiutare con una funzione diagnostica per i semafori. Questa diagnosi può aiutare a trovare il semaforo o l'interazione tra attività correlate che lavorano sul È necessario abilitare questa funzionalità nel file di configurazione: [SysSem]\nSemEnterDiagnosis=1 Ciò può avere un grave impatto sulle prestazioni e sui tempi dell'applicazione (e del runtime). Usare solo per scopi diagnostici. Non utilizzare nei sistemi di produzione. L'output sarà simile a questo: In questo esempio, MainTask_1 contiene un semaforo per alcuni millisecondi e MainTask tenta di accedere a questo semaforo. " }, 
{ "title" : "L'applicazione IEC non può aprire altri handle di file. ", 
"url" : "_rtsl_toubleshooting_iec_filehandles.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ L'applicazione IEC non può aprire altri handle di file. ", 
"snippet" : "Prima di modificare il limite di gestione dei file sul tuo sistema, dovresti considerare urgentemente le conseguenze per tutti i servizi sul tuo sistema Linux. Consigliamo invece di individuare la causa della perdita...", 
"body" : "Prima di modificare il limite di gestione dei file sul tuo sistema, dovresti considerare urgentemente le conseguenze per tutti i servizi sul tuo sistema Linux. Consigliamo invece di individuare la causa della perdita " }, 
{ "title" : "Risoluzione dei problemi ", 
"url" : "_rtsl_toubleshooting_iec_filehandles.html#UUID-4043602f-b92d-ba82-ffe1-5d6eea5cf6f5_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ L'applicazione IEC non può aprire altri handle di file. \/ Risoluzione dei problemi ", 
"snippet" : "I seguenti effetti possono essere causati da una perdita di handle di file: Perdita dello status della licenza. La licenza WIBU viene interrotta dopo un certo periodo di tempo Non è possibile aprire nuovi file. Il comportamento predefinito dei processi Linux è consentire un numero massimo di handle ...", 
"body" : "I seguenti effetti possono essere causati da una perdita di handle di file: Perdita dello status della licenza. La licenza WIBU viene interrotta dopo un certo periodo di tempo Non è possibile aprire nuovi file. Il comportamento predefinito dei processi Linux è consentire un numero massimo di handle di file aperti. Quando un processo raggiunge questo limite, non è più possibile aprire nuovi file. Puoi controllare il valore limite del tuo sistema con il comando della console: ulimit -n Ogni processo in Linux ha un ID di processo e il kernel fornisce informazioni dettagliate su ogni processo nel suo sistema di file\/cartelle procfs . Ciò consente di determinare facilmente il numero di gestioni di file di cui dispone un processo in un dato momento. Consigliamo i seguenti passaggi per indagare su una possibile fuga di handle di file: Trova l'ID del processo di CODESYS ambiente di runtime. È possibile utilizzare gli strumenti standard di Linux per trovare l'ID del processo CODESYS ambiente di runtime: htop normalmente visualizza l'ID del processo nella prima colonna (PID). top normalmente visualizza l'ID del processo nella prima colonna (PID). Puoi combinare ps e grep comandi per una ricerca rapida: ps aux | grep codesyscontrol Prendete nota dell'ID del processo e usatelo nei comandi seguenti in cui viene usato il segnaposto <pid> . Controlla e monitora gli handle dei file. Ora elenca le voci in procfs per vedere gli handle dei file del processo di runtime. sudo ls -la \/proc\/<pid>\/fd\/ Questo può apparire come segue Se gli handle dei file sono file «reali», puoi vedere il percorso. Altri handle di file potrebbero essere socket o simili Se esegui questo comando più volte uno dopo l'altro, puoi osservare se hai un numero crescente di handle di file e quali file sono aperti. Le watch il comando crea una vista che viene aggiornata ogni 2 secondi. watch sudo ls -la \/proc\/<pid>\/fd\/ Queste azioni possono aiutarti a monitorare gli handle aperti e quindi a scoprire quali file potrebbero essere coinvolti nella perdita di handle di file. " }, 
{ "title" : "Il consumo di memoria della mia applicazione IEC è in aumento. ", 
"url" : "_rtsl_toubleshooting_iec_memory.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ Il consumo di memoria della mia applicazione IEC è in aumento. ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Preparazioni: ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234795798419608", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ Il consumo di memoria della mia applicazione IEC è in aumento. \/ Preparazioni: ", 
"snippet" : "È necessario un sistema runtime in cui CmpMemGC il componente è abilitato e attivo. È possibile verificare se questo componente è caricato nel registro di runtime....", 
"body" : "È necessario un sistema runtime in cui CmpMemGC il componente è abilitato e attivo. È possibile verificare se questo componente è caricato nel registro di runtime. " }, 
{ "title" : "Risoluzione dei problemi ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ Il consumo di memoria della mia applicazione IEC è in aumento. \/ Risoluzione dei problemi ", 
"snippet" : "Se si notano strani effetti dopo un determinato periodo di funzionamento dell'applicazione IEC (ad esempio la perdita dello stato della licenza o l'impossibilità di allocare nuova memoria), ciò potrebbe essere causato da una perdita di memoria. Dovresti esaminare questi effetti e trovare l'origine d...", 
"body" : "Se si notano strani effetti dopo un determinato periodo di funzionamento dell'applicazione IEC (ad esempio la perdita dello stato della licenza o l'impossibilità di allocare nuova memoria), ciò potrebbe essere causato da una perdita di memoria. Dovresti esaminare questi effetti e trovare l'origine del problema. " }, 
{ "title" : "CODESYS Dispositivo di memoria Trace ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234796058905879", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ Il consumo di memoria della mia applicazione IEC è in aumento. \/ Risoluzione dei problemi \/ CODESYS Dispositivo di memoria Trace ", 
"snippet" : "Questa funzione è disponibile nei sistemi runtime versione SP19 (versione SL 4.9.0.0) e successive. Può essere utilizzata molto facilmente Abilita l'impostazione nell'ambiente di runtime. Interrompi il runtime tramite Deploy Tool . Connettiti al tuo sistema di destinazione tramite putty o un altro c...", 
"body" : "Questa funzione è disponibile nei sistemi runtime versione SP19 (versione SL 4.9.0.0) e successive. Può essere utilizzata molto facilmente Abilita l'impostazione nell'ambiente di runtime. Interrompi il runtime tramite Deploy Tool . Connettiti al tuo sistema di destinazione tramite putty o un altro client SSH. Apri il file di configurazione dell'ambiente di runtime con un editor di testo (ad esempio, nano): sudo nano \/etc\/codesyscontrol\/CODESYSControl.cfg Nel CmpMemGC sezione, aggiungi la voce EnableMemTrace=1 . [CmpMemGC]\nEnableMemTrace=1 Salva e chiudi il file. Riavviare il runtime tramite Deploy Tool . Aggiungi la traccia del dispositivo al tuo CODESYS progetto (dove si verifica questo problema). Nell'albero dei dispositivi, fate clic con il pulsante destro del mouse sul dispositivo. Clicca Aggiungi oggetto → Traccia del dispositivo . Le Device Trace l'oggetto viene inserito sotto il controller. Le Traccia del dispositivo viene visualizzata la scheda. Fai clic su Traccia → Carica Trace comando. Le Tracce online del dispositivo 'Codesys_Control_for_Linux_SL' si apre una finestra di dialogo. Se non riesci a trovare il MemGCTrace immissione, quindi l'impostazione del passaggio 1 non è impostata correttamente. Se il controller non supporta il meccanismo, utilizzate una delle due opzioni seguenti per la diagnosi. Seleziona il MemGCTrace immissione e clic Carica e chiudi la finestra di dialogo . La traccia della memoria ( MemGCTrace ) viene aggiunto a DeviceTrace Per ulteriori informazioni, vedere: Comando: Upload Trace " }, 
{ "title" : "CODESYS Libreria: SysMem ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234796059265431", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ Il consumo di memoria della mia applicazione IEC è in aumento. \/ Risoluzione dei problemi \/ CODESYS Libreria: SysMem ", 
"snippet" : "inoltre possibile accedere alle informazioni interne in modo programmatico. È possibile accedere alla panoramica attuale di tutta la RAM\/memoria heap allocata tramite SysMem.SysMemGetCurrentHeapSize() Questo valore può essere utilizzato per osservare la dimensione attuale dell'heap. Puoi guardare qu...", 
"body" : "inoltre possibile accedere alle informazioni interne in modo programmatico. È possibile accedere alla panoramica attuale di tutta la RAM\/memoria heap allocata tramite SysMem.SysMemGetCurrentHeapSize() Questo valore può essere utilizzato per osservare la dimensione attuale dell'heap. Puoi guardare questo valore o scriverlo su una traccia Questo può aiutarti a determinare se l'aumento della memoria allocata è basato sul tempo con determinati altri eventi nell'applicazione IEC. " }, 
{ "title" : "Riga di comando Linux ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234796059607787", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ Il consumo di memoria della mia applicazione IEC è in aumento. \/ Risoluzione dei problemi \/ Riga di comando Linux ", 
"snippet" : "Se hai accesso alla console Linux (ad esempio, tramite un client SSH), puoi anche controllare il comportamento della memoria. Esistono vari strumenti e comandi per raggiungere questo obiettivo: alto\/alto Si tratta di strumenti grafici per analizzare i processi (e i thread) su un sistema Linux. Quasi...", 
"body" : "Se hai accesso alla console Linux (ad esempio, tramite un client SSH), puoi anche controllare il comportamento della memoria. Esistono vari strumenti e comandi per raggiungere questo obiettivo: alto\/alto Si tratta di strumenti grafici per analizzare i processi (e i thread) su un sistema Linux. Quasi tutte le distribuzioni Linux forniscono questi strumenti, quindi puoi installarli facilmente tramite apt o dnf o la gestione dei pacchetti della distribuzione. htop \n# or \ntop Entrambi gli strumenti possono essere utilizzati per visualizzare i thread in una visualizzazione ad albero e per analizzare i CODESYS processo di runtime e relativi thread. Ogni attività IEC pthread all'interno del processo di runtime. Nello strumento htop, puoi personalizzare la vista tramite F2 (menu di configurazione): Ti consigliamo di abilitare il Tree view e Show custom thread names opzioni. Nella parte superiore, puoi abilitare la visualizzazione ad albero con la combinazione di tasti Shift + V e quindi vedi l'utilizzo della CPU\/utilizzo della memoria per thread. Questo può aiutarti a determinare se l'aumento della memoria allocata è basato sul tempo in base a determinati altri eventi nell'applicazione IEC o se si è verificata una perdita di memoria " }, 
{ "title" : "Il runtime di sicurezza mostra gli errori di temporizzazione nel file di registro. ", 
"url" : "_rtsl_toubleshooting_iec_safety.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ Il runtime di sicurezza mostra gli errori di temporizzazione nel file di registro. ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Preparazioni: ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795798419608", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ Il runtime di sicurezza mostra gli errori di temporizzazione nel file di registro. \/ Preparazioni: ", 
"snippet" : "Stai gestendo un CODESYS Safe Control SL o CODESYS Virtual Safe Control SL combinato con CODESYS Safe Time Provider ....", 
"body" : "Stai gestendo un CODESYS Safe Control SL o CODESYS Virtual Safe Control SL combinato con CODESYS Safe Time Provider . " }, 
{ "title" : "Risoluzione dei problemi ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ Il runtime di sicurezza mostra gli errori di temporizzazione nel file di registro. \/ Risoluzione dei problemi ", 
"snippet" : "Se si riscontrano problemi segnalati dal CODESYS Safe Control Ambiente di runtime SL e menziona i problemi di temporizzazione (da CmpSIL3 componente), allora potreste avere problemi di temporizzazione nella rete Safe Time che dovreste esaminare. Un messaggio di registro potrebbe essere simile a ques...", 
"body" : "Se si riscontrano problemi segnalati dal CODESYS Safe Control Ambiente di runtime SL e menziona i problemi di temporizzazione (da CmpSIL3 componente), allora potreste avere problemi di temporizzazione nella rete Safe Time che dovreste esaminare. Un messaggio di registro potrebbe essere simile a questo: #### Exception: ID: 0x40000066 <p0>0xb633<\/p0> <p1>0xbcdd<\/p1> <p2>0xbce1<\/p2> <p3>0xb2fd<\/p3> <p4>0x0<\/p4> Gli errori di eccezione hanno i seguenti significati: 0x40000065 : Canale di eccezione x: verifica della plausibilità del timestamp locale per il tempo di ciclo 0x40000066 : Canale di eccezione x: verifica della plausibilità del timestamp remoto rispetto al tempo di ciclo 0x40000067 : Canale di eccezione x: verifica della plausibilità del timestamp remoto rispetto al timestamp locale La rete del tempo sicuro (tra CODESYS Safe Time Provider e il CODESYS Safe Control ambiente di runtime) ha gli stessi elevati requisiti di stabilità e tempo reale di una rete fieldbus (ad esempio, EtherCAT o Profinet). " }, 
{ "title" : "Tracciamento con tcpdump ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795897227037", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ Il runtime di sicurezza mostra gli errori di temporizzazione nel file di registro. \/ Risoluzione dei problemi \/ Tracciamento con tcpdump ", 
"snippet" : "È possibile creare facilmente una traccia sulla riga di comando di Linux utilizzando tcpdump strumento. Se conosci già Wireshark o un dispositivo di tracciamento hardware, puoi utilizzarlo anche per creare I passaggi fondamentali da seguire: Determina la scheda di rete che desideri tracciare. Scopri...", 
"body" : "È possibile creare facilmente una traccia sulla riga di comando di Linux utilizzando tcpdump strumento. Se conosci già Wireshark o un dispositivo di tracciamento hardware, puoi utilizzarlo anche per creare I passaggi fondamentali da seguire: Determina la scheda di rete che desideri tracciare. Scopri cosa vuoi tracciare (contenuto, tipo di pacchetto, registro, ecc.) per ridurre la traccia. Comandi utili Installare tcpdump (a seconda della distribuzione o della gestione dei pacchetti software) Ad esempio, basato su Debian\/Ubuntu «apt»: sudo apt install tcpdump Basato su Red Hat «YUM\/DNF»: sudo yum install tcpdump Puoi vedere tutti gli adattatori di rete disponibili che tcpdump può monitorare: > tcpdump -D \n1.eno1 [Up, Running, Connected]\n2.any (Pseudo-device that captures on all interfaces) [Up, Running]\n3.lo [Up, Running, Loopback] È possibile correre tcpdump come utente normale. Se vuoi farlo, leggi il tcpdump documentazione per maggiori dettagli. argomenti della riga di comando tcpdump Dettagli su tutti i comandi possibili con tcpdump può essere trovato in tcpdump pagina man: https:\/\/www.tcpdump.org\/manpages\/tcpdump.1.html Oppure chiama tcpdump : > tcpdump --help \n\ntcpdump version 4.99.3\nlibpcap version 1.10.3 (with TPACKET_V3)\nOpenSSL 3.0.15 3 Sep 2024\nUsage: tcpdump [-AbdDefhHIJKlLnNOpqStuUvxX#] [ -B size ] [ -c count ] [--count]\n                [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]\n                [ -i interface ] [ --immediate-mode ] [ -j tstamptype ]\n                [ -M secret ] [ --number ] [ --print ] [ -Q in|out|inout ]\n                [ -r file ] [ -s snaplen ] [ -T type ] [ --version ]\n                [ -V file ] [ -w file ] [ -W filecount ] [ -y datalinktype ]\n                [ --time-stamp-precision precision ] [ --micro ] [ --nano ]\n                [ -z postrotate-command ] [ -Z user ] [ expression ] Le bandiere e i filtri più importanti: Bandiera (corta\/lunga) Descrizione -D --list-interfaces Restituisce l'elenco delle interfacce di rete disponibili sul sistema e in cui tcpdump il comando può catturare pacchetti -i <interface> --interface <interface> Interroga l'interfaccia e restituisce le seguenti informazioni: Elenco dei tipi di livelli di collegamento Elenco dei tipi di timestamp Risultati della compilazione di un'espressione di filtro -c <Count> Termina la query dopo aver ricevuto o letto un numero di pacchetti <count> . -n Impedisce la conversione degli indirizzi (indirizzi host, numeri di porta, ecc.) in nomi -A Emette ogni pacchetto (meno l'intestazione a livello di collegamento) in formato ASCII -x Durante l'analisi, oltre alle intestazioni di ciascun pacchetto, stampa i dati di ciascun pacchetto (meno le intestazioni a livello di collegamento) in formato esadecimale -s <snaplen> --snapshot-length=<snaplen> Utilizza <snaplen> byte di dati da ogni pacchetto invece del valore predefinito di 262144 byte -w <file> Scrive i pacchetti di dati grezzi in un file invece di analizzarli e stamparli -t Impedisce l'emissione di un timestamp in ogni riga di dump -tt Restituisce il timestamp, in secondi dal 1° gennaio 1970, 00:00:00, UTC e frazioni di secondo da quel momento, in ogni riga di dump -ttt Stampa una risoluzione delta (microsecondi o nanosecondi), a seconda --time-stamp-precision opzione) tra la riga corrente e quella precedente su ciascuna riga di dump. L'impostazione predefinita è una risoluzione in microsecondi -tttt Stampa un timestamp, in ore, minuti, secondi e frazioni di secondo dalla mezzanotte, su ogni riga di dump. L'output è preceduto dalla data -v Fornisce informazioni aggiuntive (dettagliate) Tracciamento del pacco Acquisizione e output semplici sulla console: > sudo tcpdump -i <interfacename>\n\n# e.g. with interface \"eno1\":\n> sudo tcpdump -i eno1 Acquisizione e riproduzione come file compatibile con Wireshark > sudo tcpdump -i <interfacename> -w <file>\n \n# e.g.\n> sudo tcpdump -i eno1 -w myfirsttrace.pcap Quindi il file myfirsttrace.pcap può essere aperto in Wireshark. ( .pcap è l'estensione di file predefinita per i file di traccia di Wireshark.) Esempio > sudo tcpdump -i eno1 -w myfirsttrace.cap -s 200 udp port 60000 " }, 
{ "title" : "Indagine\/analisi ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795898218432", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Risoluzione dei problemi \/ Applicazione IEC \/ Il runtime di sicurezza mostra gli errori di temporizzazione nel file di registro. \/ Risoluzione dei problemi \/ Indagine\/analisi ", 
"snippet" : "Una volta creata, una traccia deve essere analizzata. Questo può essere fatto con tcpdump o graficamente Registra la traccia sull'host del Safe Control SL (lato ricevente della comunicazione timeprovider), come mostrato nell'esempio precedente. Quindi apri il file *.pcap con Wireshark. Assomiglierà ...", 
"body" : "Una volta creata, una traccia deve essere analizzata. Questo può essere fatto con tcpdump o graficamente Registra la traccia sull'host del Safe Control SL (lato ricevente della comunicazione timeprovider), come mostrato nell'esempio precedente. Quindi apri il file *.pcap con Wireshark. Assomiglierà a questo Noterai che i pacchi vengono normalmente inviati con un intervallo di 1 millisecondo (la differenza di tempo tra i pacchi). (Vedi pacchetto numero 58 Una tipica situazione problematica in cui CODESYS Safe Control SL emetterà un'eccezione\/problema dovuto alla tempistica, visibile nel pacchetto numero 74: questo pacchetto viene ricevuto ~2 ms dopo il pacchetto precedente, quindi il ritardo è di ~1 ms. Questo non è accettabile per CODESYS Safe Control SL come timestamp affidabile e in tempo reale. Azioni per ridurre il ritardo Scopri se il problema è visibile sul lato ricevente o mittente. È necessario considerare sia il lato ricevente ( CODESYS Safe Control Host) e il lato mittente ( CODESYS Safe Time Provider Host). Migliora le funzionalità in tempo reale e la robustezza di questa comunicazione con timestamp in generale. Puoi farlo rimuovendo le altre comunicazioni e il carico che interferiscono da questa rete (utilizzalo esclusivamente Migliora le prestazioni di invio e ricezione configurando la priorità di processo dell'IRQ corrispondente (del driver di rete). Se non riesci a migliorare ulteriormente e se il tuo processo di sicurezza lo consente, puoi aumentare il tempo di ciclo del CODESYS Safe Time Provider (invio del timestamp). " }, 
{ "title" : "Riferimento ", 
"url" : "_rtsl_reference_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Riferimento ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comando: Deploy Control SL ", 
"url" : "_rtsl_cmd_deploy_control_sl.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Riferimento \/ Comando: Deploy Control SL ", 
"snippet" : "Funzione : Il comando apre il Comunicazione , Distribuzione , e Operazione schede. Chiama : Utensili menu Per ulteriori informazioni, vedere: Scheda: DistribuzioneTab: ComunicazioneScheda: Funzionamento...", 
"body" : "Funzione : Il comando apre il Comunicazione , Distribuzione , e Operazione schede. Chiama : Utensili menu Per ulteriori informazioni, vedere: Scheda: DistribuzioneTab: ComunicazioneScheda: Funzionamento" }, 
{ "title" : "Scheda: Distribuzione ", 
"url" : "_rtsl_dlg_deploy_deployment.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Riferimento \/ Scheda: Distribuzione ", 
"snippet" : "Installazione e distribuzione del prodotto Prodotto Il prodotto da installare Quando viene selezionato un prodotto, viene installato CODESYS i pacchetti vengono visualizzati nella parte inferiore della scheda. Vengono visualizzati solo i pacchetti che possono essere installati sul dispositivo attual...", 
"body" : "Installazione e distribuzione del prodotto Prodotto Il prodotto da installare Quando viene selezionato un prodotto, viene installato CODESYS i pacchetti vengono visualizzati nella parte inferiore della scheda. Vengono visualizzati solo i pacchetti che possono essere installati sul dispositivo attualmente connesso. Versione La versione del prodotto selezionato da installare. Se la versione selezionata del prodotto è già installata, viene visualizzato un messaggio a destra della casella di riepilogo. Installare Avvia l'installazione Pacchetti installati Prodotto Nome del prodotto della confezione Versione Versione del pacchetto Immagini installate Prodotto Prodotto associato (runtime, safe runtime, Edge Gateway, time provider) Versione dell'immagine Versione dell'immagine Architettura Architettura dell'immagine. Ciò è rilevante quando il controller e il motore del contenitore supportano più architetture Usato da Un elenco delle istanze che utilizzano questa immagine " }, 
{ "title" : "Tab: Comunicazione ", 
"url" : "_rtsl_dlg_deploy_communication.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Riferimento \/ Tab: Comunicazione ", 
"snippet" : "Accedi indirizzo IP L'indirizzo IP del controller a cui ti stai connettendo. In alternativa, qui potrebbe essere utilizzato anche il nome host del controller. Se non si conoscono né il nome host né l'indirizzo IP, i dispositivi disponibili possono essere visualizzati utilizzando Scansiona comando. I...", 
"body" : "Accedi indirizzo IP L'indirizzo IP del controller a cui ti stai connettendo. In alternativa, qui potrebbe essere utilizzato anche il nome host del controller. Se non si conoscono né il nome host né l'indirizzo IP, i dispositivi disponibili possono essere visualizzati utilizzando Scansiona comando. Il dispositivo può quindi essere trovato tramite l'indirizzo MAC. Se nessuna di queste informazioni è nota, è necessario connettersi direttamente al controller per scoprire il nome host o l'indirizzo IP. Porto Porta tramite la quale ci si connette Scansione Apre il Dispositivi disponibili finestra di dialogo Visualizza i dispositivi visibili nella rete. Nome utente L'account utilizzato per accedere al controller Password La password dell'account utilizzato per accedere Stato Stato attuale della connessione Connetti Stabilisce una connessione al controller con i parametri sopra specificati Disconnetti Disconnette la connessione corrente Login basato su chiave Accesso SSH basato sulla chiave : abilita l'uso della chiave SSH selezionata Frase segreta Facoltativo; la passphrase per la chiave SSH selezionata File chiave Casella di riepilogo con le chiavi SSH configurate Aggiungi file chiave Apre il Strumento Runtime Deploy opzioni. Puoi aggiungere chiavi SSH lì Informazioni sul dispositivo Riavvio Riavvia il controller Dialogo: Dispositivi disponibili Campo di immissione superiore Filtra per indirizzo IP o MAC Annulla Chiude la finestra di dialogo Scansiona di nuovo Riavvia il processo di scansione OK Quando si seleziona una voce dall'elenco, il relativo indirizzo IP viene inserito nel indirizzo IP campo nella finestra di dialogo esterna. " }, 
{ "title" : "Scheda: Funzionamento ", 
"url" : "_rtsl_dlg_deploy_operation.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Linux \/ Riferimento \/ Scheda: Funzionamento ", 
"snippet" : "Servizi Inizia tutto Avvia tutti i servizi elencati Ferma tutto Interrompe tutti i servizi elencati Inizio selezionato Avvia il servizio selezionato Interrompi selezione Interrompe il servizio selezionato Prodotto Il nome del servizio Stato Stato attuale del servizio Aggiorna Ottiene lo stato più re...", 
"body" : "Servizi Inizia tutto Avvia tutti i servizi elencati Ferma tutto Interrompe tutti i servizi elencati Inizio selezionato Avvia il servizio selezionato Interrompi selezione Interrompe il servizio selezionato Prodotto Il nome del servizio Stato Stato attuale del servizio Aggiorna Ottiene lo stato più recente di tutti gli elementi e aggiorna le tabelle Duplicato Crea una nuova istanza basata sul servizio attualmente selezionato Esporta Crea un file di esportazione in formato ZIP. Contiene l'istanza attualmente selezionata. Importa Apre una finestra di dialogo per l'importazione di un file di esportazione generato in precedenza VPLC Inizia tutto Avvia tutti i VPLC elencati Ferma tutto Interrompe tutti i VPLC elencati Inizio selezionato Avvia il VPLC selezionato Interrompi selezione Arresta il VPLC selezionato Istanza Nome del VPLC Stato Stato del VPLC Prodotto Tipo di VPLC (runtime, safe runtime, Edge Gateway, time provider) Dipendenze Altre istanze da cui dipende l'istanza selezionata. Queste altre istanze vengono avviate prima dell'istanza selezionata e interrotte dopo Apre il Aggiungi nuova istanza finestra di dialogo Elimina singole o tutte le istanze. Un'istanza in esecuzione non può essere eliminata. «Purge» elimina tutte le istanze e Aggiorna lo stato corrente di tutti gli elementi Azioni Vengono visualizzati diversi comandi a seconda dell'elemento selezionato. Mostra registro Visualizza il registro del rispettivo elemento Disabilita l'applicazione di avvio Disattiva l'applicazione di avvio del runtime Apri WBM Apre CODESYS Gestione basata sul Web nel browser Impostazioni Un elenco dinamico di tutte le opzioni per l'elemento selezionato. Una descrizione dettagliata delle rispettive opzioni è disponibile nel capitolo Configura ed estendiSalva Il comando viene abilitato non appena viene modificata un'impostazione e non sono stati rilevati errori nella configurazione. Aggiungi nuova istanza Nome Nome della nuova istanza Filtro Filtra per l'elenco delle immagini disponibili Immagine Elenco delle immagini disponibili OK Abilitato quando è stata selezionata un'immagine ed è stato specificato un nome valido. La nuova istanza viene creata e visualizzata. Annulla Chiude la finestra di dialogo; non viene apportata alcuna modifica. Configura Nic Adattatori disponibili Gli adattatori attualmente disponibili nel sistema. Quando un adattatore è già stato mappato su un'istanza, in questo elenco viene visualizzata una breve nota Mappa per istanza Determina se questo adattatore è mappato all'istanza attualmente selezionata adattatore Non può essere modificato Mostra il nome dell'adattatore selezionato IP Indirizzo IP di questo adattatore nel contenitore. Quando si specifica questo valore, è necessario specificare anche la maschera. Maschera Maschera di rete di questo adattatore nel contenitore. Quando si specifica questo valore, è necessario specificare anche l'indirizzo IP. " }, 
{ "title" : "Sistemi runtime basati su Windows ", 
"url" : "_rtsl_windows_runtime_systems.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Iniziare ", 
"url" : "_rtsl_first_steps_win.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare ", 
"snippet" : "In questo capitolo imparerai come mettere in funzione un dispositivo con CODESYS Controlla il runtime di SL, avvia un piccolo CODESYS applicazione e concedere in licenza il controller....", 
"body" : "In questo capitolo imparerai come mettere in funzione un dispositivo con CODESYS Controlla il runtime di SL, avvia un piccolo CODESYS applicazione e concedere in licenza il controller. " }, 
{ "title" : "Installazione del runtime sul controller ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Installazione del runtime sul controller ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Installazione del CODESYS Control RTE ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc_section-idm43305899023692", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Installazione del runtime sul controller \/ Installazione del CODESYS Control RTE ", 
"snippet" : "Il file eseguibile Setup_CODESYSControlRTE<32|64>V3.<version>setup.exe nel pacchetto di installazione è indicato di seguito come \"setup\". Il programma di installazione installa tutti i driver disponibili inclusi nel pacchetto. Il setup determina il tipo di piattaforma su cui installare e modifica il...", 
"body" : "Il file eseguibile Setup_CODESYSControlRTE<32|64>V3.<version>setup.exe nel pacchetto di installazione è indicato di seguito come \"setup\". Il programma di installazione installa tutti i driver disponibili inclusi nel pacchetto. Il setup determina il tipo di piattaforma su cui installare e modifica il file di configurazione CODESYSControl.cfg automaticamente (dopo aver confermato). Per impostazione predefinita, la directory di lavoro di CODESYS Control RTE è C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 . Requisiti: Si conosce il numero di core della CPU nel sistema in cui si desidera installare il file CODESYS Control RTE . Hai eseguito i preparativi sopra descritti sul tuo sistema. (La designazione esatta della tua CPU è mostrata nella finestra di dialogo \"Sistema\" del pannello di controllo di Windows. Con queste informazioni, puoi utilizzare Internet per ricercare il numero di core CPU fisici.) Si prega di notare anche le informazioni sulla configurazione hardware: Configurazione hardware - RaccomandazioniCarica il pacchetto di installazione sul tuo computer. CODESYS Control RTE è disponibile nel CODESYS Store International come versione con licenza singola. Avviare l'installazione eseguendo il file CODESYS Control RTE <32|64> <version>.exe . Seguire la procedura guidata con le impostazioni predefinite fino al Utilizzo della CPU multicore viene visualizzata la finestra di dialogo. Risultato: La procedura guidata di installazione tenta di rilevare il numero totale di core del processore fisico in Nuclei totali . Controllare queste informazioni e correggerle se necessario. In Nuclei RTE , definire quanti core del processore devono essere riservati esclusivamente per il CODESYS Control RTE compiti. Di conseguenza, questi core non sono più disponibili per Windows (modalità \"AMP\"). Nota: il numero già specificato (esempio: 6 ) è solo un suggerimento della configurazione. Normalmente l'installazione può rilevare correttamente il numero di core CPU fisici del sistema. Un core della CPU che viene visualizzato da Windows può anche essere un core della CPU \"logico\" che non è appropriato per il funzionamento del sistema in tempo reale su di esso (\"core dell'hyperthreading\"). Segui anche le istruzioni: L'hyperthreading DEVE essere disabilitato dalle impostazioni del BIOS! . Funzionalità della CPU come l'hyperthreading influenzano negativamente il comportamento in tempo reale. Dovrai confermare in seguito in una finestra di dialogo che il setup dovrebbe riservare un core della CPU per l'RTE modificando la configurazione di avvio del sistema. Quando si esegue questa operazione, l'opzione boot numproc è impostato su <numero di processori fisici meno 1 >. Clic Prossimo per confermare il numero specificato di core. Quindi vedi il Le opzioni di avvio cambieranno finestra di dialogo con informazioni sulle modifiche annotate alla configurazione di avvio del PC. Clic Prossimo per continuare al Impostare le opzioni di avvio? dialogo. Risultato: Nel Imposta le opzioni di avvio dialogo, si decide se il setup deve applicare o meno le seguenti modifiche alla configurazione iniziale del sistema: Limite del numero di core CPU disponibili per Windows; tramite l'opzione di avvio \" numproc \" a <number of physical cores> - 1 . Disattivazione della funzionalità del processore \"Data Execution Prevention\". Disattivazione della funzionalità del processore \"Physical Address Extension (PAE)\". Le funzionalità del processore \"Data Execution Prevention\" e \"PAE\" non devono essere necessariamente disattivate. Modificando manualmente la configurazione di avvio, puoi limitare solo il numero di core per Windows. Tuttavia, questo tipo di configurazione non è testato da CODESYS . L'opzione di avvio numproc è assolutamente necessario per il funzionamento dell'RTE in questa configurazione. Pertanto, se si decide qui che l'installazione non deve impostare questa opzione, è necessario attivare l'opzione manualmente. Se il setup dovesse applicare le modifiche appena descritte, cliccare sì . Se desideri eseguire queste modifiche manualmente in un secondo momento, fai clic su No . Clic Prossimo per continuare al Target Tipo di RTE dialogo. Risultato: Con versione CODESYS 3.5 SP17 non è più necessaria una distinzione tra i tipi di apparecchio \"Control\" e \"Softmotion\". Il tipo di dispositivo \"Control\" include anche la funzionalità completa che era riservata in precedenza ai dispositivi SoftMotion. La distinzione ora esiste solo per motivi di compatibilità. Per i nuovi progetti, si consiglia di utilizzare \"Controllo\". Nel Target Tipo di RTE finestra di dialogo, selezionare il tipo di RTE da installare: CODESYS Controllo RTE o CODESYS Soft Motion RTE . Il tipo di installazione dipende dall'applicazione e dalla licenza. Seleziona \"SoftMotion\" solo se hai acquistato e vuoi utilizzare a CODESYS Soft Motion RTE licenza. In caso contrario, l'RTE inizierà in modalità demo a tempo limitato. Nel prossimo Seleziona Funzionalità dialogo, è comunque possibile modificare la selezione delle effettive funzionalità da installare: CODESYS Soft Motion RTE e CodeMeter® per Windows . Puoi passare manualmente da uno all'altro CODESYS Control RTE tipi in un secondo momento modificando il file di configurazione CODESYSControl.cfg . Per farlo, inserisci le seguenti righe nel file di configurazione CODESYSControl.cfg : [SysTarget] TargetType=0x1006 DeviceName=CODESYS SoftmotionRTE V3 Eliminando queste voci (o anteponendo un punto e virgola), ottieni un file CODESYS Control RTE ancora. Nel Seleziona Funzionalità finestra di dialogo, selezionare le funzionalità che si desidera installare. Apri il firewall se vuoi accedere al file CODESYS Control RTE da altri computer. Ciò è necessario, ad esempio, per la comunicazione con CODESYS , CODESYS OPC e quando si lavora con bus di campo basati su Ethernet. Risultato: In una delle fasi di esecuzione, viene richiesto se l'accuratezza dell'ora di CODESYS Control RTE dovrebbe essere aumentato creando e attivando un profilo hardware. Se lo affermi, viene selezionata l'opzione di risparmio energia \"Prestazioni elevate\" (Pannello di controllo -> Opzioni risparmio energia) e la velocità della CPU viene impostata al 100%. Al termine dell'installazione, il file simbolo viene visualizzato nella barra di stato dello schermo. Puoi aprire il CODESYS Control RTE menu facendo clic con il pulsante destro del mouse su di esso. Il file di configurazione CODESYSControl.cfg viene adattato automaticamente. Controlla se la descrizione del dispositivo corrente per CODESYS Control RTE installato nel tuo CODESYS Development System . Questa installazione è necessaria per l'utilizzo CODESYS Control RTE insieme a CODESYS . (Il sistema di sviluppo non si trova necessariamente sul sistema di destinazione in cui è in esecuzione RTE.) Se devi reinstallare la descrizione del dispositivo, ad esempio perché era necessaria una modifica successiva, apri il file CODESYS repository del dispositivo ed eseguire il file Installare comando. I file descrittivi per l'adattamento dell'RTE ( .devdesc.xml ) vengono generati dal setup nella directory di installazione Others . È imperativo eseguire il riavvio richiesto al termine dell'installazione. Per ulteriori informazioni, vedere: Installazione di dispositivi " }, 
{ "title" : "Adattare la configurazione di CODESYS Control RTE ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc_section-idm43305899148826", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Installazione del runtime sul controller \/ Installazione del CODESYS Control RTE \/ Adattare la configurazione di CODESYS Control RTE ", 
"snippet" : "Requisito: aver eseguito l'installazione come descritto sopra. Hai installato CODESYS . Sono possibili le seguenti opzioni: Usa il tuo dispositivo con la configurazione disponibile dopo l'installazione: Continua con le istruzioni sotto \"Avvio CODESYS Control RTE \". Adattare la configurazione dell'in...", 
"body" : "Requisito: aver eseguito l'installazione come descritto sopra. Hai installato CODESYS . Sono possibili le seguenti opzioni: Usa il tuo dispositivo con la configurazione disponibile dopo l'installazione: Continua con le istruzioni sotto \"Avvio CODESYS Control RTE \". Adattare la configurazione dell'installazione locale CODESYS Control RTE : Clicca il CODESYS Control RTE simbolo nella barra delle applicazioni del tuo PC. Clic Configurazione PLC nel CODESYS Control RTE menu per aprire l'editor di configurazione. Modifica le impostazioni come preferisci. Utilizzare il CODESYS Control RTE installato su un PC remoto. Clicca il CODESYS Control RTE simbolo nella barra delle applicazioni del tuo PC. Nel CODESYS Control RTE menu, fare clic PLC remoto . Nella finestra di dialogo aperta, configurare le impostazioni di connessione del PLC remoto. La configurazione viene salvata nel file di configurazione CODESYSControl.cfg nella rubrica C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 . " }, 
{ "title" : "Installazione del CODESYS Control Win ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc_section-idm4555504420804833058987427815", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Installazione del runtime sul controller \/ Installazione del CODESYS Control Win ", 
"snippet" : "Dopo l'installazione riuscita, CODESYS Control Win funziona come un servizio sul tuo computer. Si ottiene un'installazione nei seguenti modi: Hai installato il CODESYS Development System . Di conseguenza, a CODESYS Control Win versione con durata limitata è installata sul tuo PC. Hai scaricato CODES...", 
"body" : "Dopo l'installazione riuscita, CODESYS Control Win funziona come un servizio sul tuo computer. Si ottiene un'installazione nei seguenti modi: Hai installato il CODESYS Development System . Di conseguenza, a CODESYS Control Win versione con durata limitata è installata sul tuo PC. Hai scaricato CODESYS Control Win dal CODESYS Memorizza ed esegui il file di installazione per installarlo. " }, 
{ "title" : "Avvio del sistema runtime ", 
"url" : "_rtsl_start_runtime-1816376.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Avvio del sistema runtime ", 
"snippet" : "Nota : Una licenza valida deve essere installata sul tuo PC per far funzionare il sistema runtime. In caso contrario, il controller si avvia in modalità demo completamente funzionante, ma a tempo limitato. Nel caso dei sistemi runtime si tratta di licenze dispositivo. Attivate queste licenze nel Lic...", 
"body" : "Nota : Una licenza valida deve essere installata sul tuo PC per far funzionare il sistema runtime. In caso contrario, il controller si avvia in modalità demo completamente funzionante, ma a tempo limitato. Nel caso dei sistemi runtime si tratta di licenze dispositivo. Attivate queste licenze nel License Manager. Per ulteriori informazioni, vedere: Licenza dei prodotti " }, 
{ "title" : "CODESYS Control RTE ", 
"url" : "_rtsl_start_runtime-1816376.html#UUID-065101d1-259a-9d21-37c7-74cc493827e0_section-idm43463171121528", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Avvio del sistema runtime \/ CODESYS Control RTE ", 
"snippet" : "Inizio CODESYS Control RTE tramite il comando Avviare il PLC nel CODESYS Control RTE menu ( ). Se il simbolo nella barra delle applicazioni non è disponibile, assicurati che l'installazione sia corretta. Facendo doppio clic sul file CODESYSControlRTESysTray.exe nella cartella di installazione di COD...", 
"body" : "Inizio CODESYS Control RTE tramite il comando Avviare il PLC nel CODESYS Control RTE menu ( ). Se il simbolo nella barra delle applicazioni non è disponibile, assicurati che l'installazione sia corretta. Facendo doppio clic sul file CODESYSControlRTESysTray.exe nella cartella di installazione di CODESYS Control RTE , è possibile avviare la visualizzazione dell'interfaccia utente manualmente nella barra delle applicazioni. Il simbolo nella barra delle applicazioni diventa dopo l'avvio CODESYS Control RTE . Le seguenti istruzioni descrivono come creare un semplice CODESYS applicazione da eseguire su CODESYS Control RTE . " }, 
{ "title" : "CODESYS Control Win ", 
"url" : "_rtsl_start_runtime-1816376.html#UUID-065101d1-259a-9d21-37c7-74cc493827e0_section-idm43463171151726", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Avvio del sistema runtime \/ CODESYS Control Win ", 
"snippet" : "Nel caso di CODESYS Control Win , si tratta di una licenza per il dispositivo. Questa licenza viene attivata nel License Manager. Per ulteriori informazioni, vedere: Concessione in licenza dei prodotti Avvio automatico: Se CODESYS Control Win dovrebbe avviarsi automaticamente all'avvio del sistema, ...", 
"body" : "Nel caso di CODESYS Control Win , si tratta di una licenza per il dispositivo. Questa licenza viene attivata nel License Manager. Per ulteriori informazioni, vedere: Concessione in licenza dei prodotti Avvio automatico: Se CODESYS Control Win dovrebbe avviarsi automaticamente all'avvio del sistema, quindi è necessario configurare il servizio come segue: Aprire Windows Servizi finestra di dialogo di sistema dal menu di avvio del computer. Nell'elenco, seleziona il servizio CODESYS Control Win V3 e apri il Proprietà finestra di dialogo dal menu contestuale. Generale scheda, imposta Tipo di avvio a Automatico . Avvio manuale: Nella barra di sistema, fai clic con il pulsante destro del mouse su simbolo o simbolo e clicca Avviare il PLC nel menu. Se il simbolo non è presente nella barra di sistema, assicurati che l'installazione sia corretta e che il display nella barra di sistema sia avviato. Nota aggiuntiva: facendo doppio clic sul file CODESYSControlSysTray.exe nella directory di installazione di GatewayPLC , è possibile avviare la visualizzazione dell'interfaccia utente manualmente nella barra delle applicazioni. Dopo un avvio positivo, il CODESYS Control Win il simbolo nella barra di sistema diventa o . " }, 
{ "title" : "Scaricare e avviare il file CODESYS Applicazione sul controller ", 
"url" : "_rtsl_load_and_start_application_win.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Scaricare e avviare il file CODESYS Applicazione sul controller ", 
"snippet" : "Presupposto: il controller è avviato. In CODESYS , creare un progetto standard: fare clic su File → Nuovo progetto . Nel Nuovo progetto finestra di dialogo, selezionare il Progetto standard modello e specificare un nome e una posizione. Poi nel Progetto Standard finestra di dialogo, selezionare il r...", 
"body" : "Presupposto: il controller è avviato. In CODESYS , creare un progetto standard: fare clic su File → Nuovo progetto . Nel Nuovo progetto finestra di dialogo, selezionare il Progetto standard modello e specificare un nome e una posizione. Poi nel Progetto Standard finestra di dialogo, selezionare il rispettivo controller. Nell'albero dei dispositivi ( Dispositivi view) del nuovo progetto, ora c'è una voce per il controller ( Dispositivo (...) ) e sotto di essa un'applicazione con un POU ( PLC_PRG (PRG) e un compito Compito principale che chiama PLC_PRG). In PLC_PRG , scrivere un programma semplice (ad esempio un contatore). PROGRAM PLC_PRG\nVAR\n iCount: INT;\nEND_VAR\n\niCount := iCount+1; Stabilire una connessione al controller. Per fare questo, usa il Impostazioni di comunicazione scheda dell'editor del dispositivo. Puoi aprirlo facendo doppio clic su Dispositivo (...) voce nella struttura ad albero dei dispositivi. Normalmente, il gateway è già attivo ora. In caso contrario, verificare lo stato e, se necessario, avviare esplicitamente il gateway. Quindi fare clic Scansione rete sul Comunicazione scheda. Il Seleziona dispositivo si apre la finestra di dialogo con i dispositivi rilevati. Nel caso in cui il controller non venga trovato, assicurarsi che sia stato installato e avviato correttamente. Selezionare il controller rilevato e fare clic OK . Se il controller non viene trovato, controllare quanto segue: Sul Impostazioni di comunicazione scheda, nel Dispositivo → Opzioni menu, disabilitare il Filtra le scansioni di rete in base all'ID di destinazione opzione. Se il tuo dispositivo viene visualizzato ora, allora hai un errore errato TargetID . Il tuo componente SysTargetOEM potrebbe non essere stato caricato correttamente. Il tuo dispositivo è connesso alla tua rete? Per impostazione predefinita, la comunicazione con il tuo dispositivo avviene tramite UDP. Quando utilizzi questo metodo di comunicazione, il tuo dispositivo deve trovarsi nella stessa sottorete del tuo host. Entrambi i dispositivi richiedono la stessa identica maschera di rete configurata. All'avvio è possibile verificare le impostazioni di rete per i messaggi del sistema runtime. Ad esempio, dovrebbero essere i seguenti: 1287759127: Cmp=CmpBlkDrvUdp, Class=1, Error=0, Info=6, pszInfo=Network interface: <ipaddress>192.168.101.41<\/ipaddress> <subnetmask>255.255.252.0<\/subnetmask> CODESYS tenta di autenticarsi su questo sistema di destinazione e ottenere un canale di comunicazione. La connessione è stabilita. Clic In linea → Accedi . Si apre la finestra di dialogo per confermare il download dell'applicazione. Eseguire il download e avviare l'applicazione. L'applicazione viene elaborata sul tuo dispositivo. Nel PLC_PRG programma, verificare se il contatore è in esecuzione o meno. " }, 
{ "title" : "Autorizzazione del Titolare ", 
"url" : "_rtsl_license_controller_win.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Autorizzazione del Titolare ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Acquisizione licenze ", 
"url" : "_rtsl_license_controller_win.html#UUID-3805d9ea-0c7b-2463-7ef4-1d99d0c4e100_section-idm234389354567343", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Autorizzazione del Titolare \/ Acquisizione licenze ", 
"snippet" : "Puoi scaricare il CODESYS Control prodotto da Negozio CODESYS internazionale O Negozio CODESYS Nord America ....", 
"body" : "Puoi scaricare il CODESYS Control prodotto da Negozio CODESYS internazionale O Negozio CODESYS Nord America . " }, 
{ "title" : "Licenza locale ", 
"url" : "_rtsl_license_controller_win.html#UUID-3805d9ea-0c7b-2463-7ef4-1d99d0c4e100_section-idm4588328499004833054120306755", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Autorizzazione del Titolare \/ Licenza locale ", 
"snippet" : "La licenza può essere installata su un dongle USB o su un soft container. Quando si utilizza il contenitore software, la licenza è bloccata sul dispositivo durante l'attivazione e può essere attivata o ripristinata solo su questo dispositivo. Requisiti: Il sistema di sviluppo con CODESYS Development...", 
"body" : "La licenza può essere installata su un dongle USB o su un soft container. Quando si utilizza il contenitore software, la licenza è bloccata sul dispositivo durante l'attivazione e può essere attivata o ripristinata solo su questo dispositivo. Requisiti: Il sistema di sviluppo con CODESYS Development System disponga di accesso a Internet e sia connesso al dispositivo. Aprire CODESYS . Crea un progetto standard. Aggiorna il dispositivo nella struttura dei dispositivi. Clic Strumenti → Gestore licenze per aprire il CODESYS Gestore delle licenze. Selezionare Dispositivo nella procedura guidata, quindi selezionare Dongle o Contenitore morbido , a seconda del dispositivo. IL Seleziona dispositivo si apre la finestra di dialogo. Seleziona il rispettivo dispositivo. IL Gestore delle licenze si apre la finestra di dialogo. Contenitore mostra il nome del contenitore morbido o della chiave di sicurezza sul dispositivo. Non c'è ancora una voce per il rispettivo dispositivo nel file Prodotti finestra. Seleziona il Installa le licenze azione in basso a sinistra. Il Installa licenze su <dispositivo di destinazione> <nome contenitore> – Seleziona Operazione inizia la procedura guidata. Seleziona il Attiva licenza opzione. Specificare la ID biglietto e clicca Prossimo . La licenza è attivata. " }, 
{ "title" : "Backup e ripristino CODESYS Licenze ", 
"url" : "_rtsl_backup_restore_wibu_win.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Backup e ripristino CODESYS Licenze ", 
"snippet" : "Queste istruzioni non si applicano ai prodotti della CODESYS Famiglia di prodotti Virtual Control....", 
"body" : "Queste istruzioni non si applicano ai prodotti della CODESYS Famiglia di prodotti Virtual Control. " }, 
{ "title" : "Licenze per Codemeter Embedded ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4622936815712034049201310732", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Embedded ", 
"snippet" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ Licenza di backup e ripristino...", 
"body" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ Licenza di backup e ripristino " }, 
{ "title" : "Backup di una licenza ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4641146992569634049209836102", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Embedded \/ Backup di una licenza ", 
"snippet" : "Stabilire una connessione da CODESYS al tuo controllore. Nella struttura dei dispositivi, seleziona il controller e apri il file File scheda. Nella finestra sul lato destro, fare clic sull'icona di aggiornamento ( ). Vengono visualizzati i file disponibili sul controller. Nella finestra sul lato sin...", 
"body" : "Stabilire una connessione da CODESYS al tuo controllore. Nella struttura dei dispositivi, seleziona il controller e apri il file File scheda. Nella finestra sul lato destro, fare clic sull'icona di aggiornamento ( ). Vengono visualizzati i file disponibili sul controller. Nella finestra sul lato sinistro, seleziona la directory in cui desideri archiviare il backup. Nella finestra sul lato destro, seleziona il cmact_licenses directory e fare clic su pulsante. Sul tuo computer viene creata una copia di backup della directory delle licenze. Verificare che la copia di backup sia stata creata correttamente. " }, 
{ "title" : "Ripristino di una licenza ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm451020213344483404921010438", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Embedded \/ Ripristino di una licenza ", 
"snippet" : "Si noti che è possibile la perdita di dati quando si eseguono le seguenti istruzioni al passaggio 6. Pertanto, leggere attentamente queste istruzioni. Stabilire una connessione da CODESYS al tuo controllore. Nella struttura dei dispositivi, seleziona il controller e apri il file File scheda. Nella f...", 
"body" : "Si noti che è possibile la perdita di dati quando si eseguono le seguenti istruzioni al passaggio 6. Pertanto, leggere attentamente queste istruzioni. Stabilire una connessione da CODESYS al tuo controllore. Nella struttura dei dispositivi, seleziona il controller e apri il file File scheda. Nella finestra sul lato destro, fare clic sull'icona di aggiornamento ( ). Vengono visualizzati i file disponibili sul controller. Nella finestra sul lato destro, seleziona la directory di destinazione. Questa deve essere la directory di livello superiore ( posizione di archiviazione : \/ ) Nella finestra sul lato sinistro, seleziona la copia di backup precedentemente creata sul tuo computer e clicca su pulsante. La copia di backup viene copiata sul controller. Se esiste già una directory con lo stesso nome, ti verrà richiesto di sovrascrivere tutti i file in essa contenuti. Attenzione: se si seleziona \"Sì\", tutti i file con lo stesso nome della directory di backup verranno rimossi dalla directory esistente. Lo stesso nome non significa necessariamente che i contenuti siano identici. Pertanto, assicurati di non sovrascrivere accidentalmente i file di cui hai bisogno. Riavviare il controller dopo che la copia di backup è stata trasferita con successo. " }, 
{ "title" : "Licenze per Codemeter Runtime ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4592433740225634049202010617", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Runtime ", 
"snippet" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL...", 
"body" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL " }, 
{ "title" : "Backup di una licenza ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4582704430054434049230836628", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Runtime \/ Backup di una licenza ", 
"snippet" : "Quando si utilizza CodeMeter Runtime, non è necessario creare un backup....", 
"body" : "Quando si utilizza CodeMeter Runtime, non è necessario creare un backup. " }, 
{ "title" : "Ripristino di una licenza ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4548752769854434049231197546", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Runtime \/ Ripristino di una licenza ", 
"snippet" : "Ripristina licenza Creazione di un file di richiesta di licenza In CODESYS , aprire Gestione licenze. Nelle due finestre di dialogo seguenti selezionare Dispositivo E Contenitore morbido . Stabilire una connessione da CODESYS al controller su cui desideri ripristinare la licenza. Clic Installa licen...", 
"body" : " Ripristina licenza Creazione di un file di richiesta di licenza In CODESYS , aprire Gestione licenze. Nelle due finestre di dialogo seguenti selezionare Dispositivo E Contenitore morbido . Stabilire una connessione da CODESYS al controller su cui desideri ripristinare la licenza. Clic Installa licenze , Selezionare Richiedi licenza e fare clic Prossimo . Se la Fornitore di software è vuoto, è possibile utilizzare il codice azienda. Come recuperare il codice azienda è descritto nella sezione \"Recupero codice azienda\". Seleziona il contenitore in cui deve essere installata la licenza e seleziona il percorso in cui il file di richiesta di licenza deve essere salvato sul tuo computer. Clic Fine . Download del file di aggiornamento della licenza Apri il WebDepot centrale licenze e specifica l'ID del ticket che desideri ripristinare. Clic Prossimo . Clic Ripristina licenze . In basso a destra, fai clic su Trasferimento della licenza basato su file . (Se la pagina dice Trasferimento diretto della licenza , allora sei già sulla pagina corretta). Caricare il file di richiesta di licenza creato in precedenza e fare clic su Carica la richiesta e continua ora . Clic Scarica subito il file di aggiornamento della licenza e salva il file sul tuo computer. Installazione di un aggiornamento della licenza In CODESYS , aprire Gestione licenze. Nelle due finestre di dialogo seguenti selezionare Dispositivo E Contenitore morbido . Stabilire una connessione da CODESYS al controller su cui desideri ripristinare la licenza. Clic Installa licenze , Selezionare Installa licenza e fare clic Prossimo . Seleziona il contenitore in cui desideri installare la licenza e seleziona il file di aggiornamento precedentemente scaricato (estensione: .WibuCmRaU ). Clic Fine . Dopo alcuni secondi, la licenza verrà visualizzata nel Gestore licenze. " }, 
{ "title" : "Recupero di un codice azienda ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4641146913656034049243306333", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Iniziare \/ Backup e ripristino CODESYS Licenze \/ Licenze per Codemeter Runtime \/ Recupero di un codice azienda ", 
"snippet" : "Apri il WebDepot centrale licenze e specifica l'ID del ticket che desideri ripristinare. Clic Prossimo . Clic Ripristina licenze . In basso a destra, fai clic su Trasferimento della licenza basato su file . Copia il codice azienda come previsto al primo punto....", 
"body" : "Apri il WebDepot centrale licenze e specifica l'ID del ticket che desideri ripristinare. Clic Prossimo . Clic Ripristina licenze . In basso a destra, fai clic su Trasferimento della licenza basato su file . Copia il codice azienda come previsto al primo punto. " }, 
{ "title" : "Configura ed estendi ", 
"url" : "_rtsl_configure_and_extend-1816377.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Controllo Vincere V3 ", 
"url" : "_rtsl_windows_win_v3.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo Vincere V3 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Aggiunta di componenti dinamici ", 
"url" : "_rtsl_windows_win_v3_dynamic_components.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo Vincere V3 \/ Aggiunta di componenti dinamici ", 
"snippet" : "CODESYS Control Win viene configurato tramite un file di configurazione ( CODESYSControl.cfg ). Il file cfg nel percorso di installazione contiene un riferimento al file di configurazione effettivo CODESYSControl.cfg nella directory di lavoro: [SysFile] Windows.WorkingDirectory=C:\\ProgramData\\CODESY...", 
"body" : "CODESYS Control Win viene configurato tramite un file di configurazione ( CODESYSControl.cfg ). Il file cfg nel percorso di installazione contiene un riferimento al file di configurazione effettivo CODESYSControl.cfg nella directory di lavoro: [SysFile]\nWindows.WorkingDirectory=C:\\ProgramData\\CODESYS\\CODESYSControlWinV3x64\\801BFF8C Nel file cfg nella directory di lavoro è possibile inserire i componenti aggiuntivi desiderati (driver). Quindi questi vengono sempre caricati quando CODESYS Control Win viene riavviato. Inserisci un nuovo componente nella sezione [ComponentManager] . È importante che non vi siano voci mancanti nel numero di tutte le voci componenti. [ComponentManager]\n...\nComponent.6=SysCpuBreakpoints\nComponent.7=<Neue Komponente>\n... Vedi sotto quali componenti puoi aggiungere. " }, 
{ "title" : "Supporto di adattatori bus di campo opzionali ", 
"url" : "_rtsl_windows_win_v3_dynamic_components.html#UUID-8ec48f4e-4fbf-ff18-64cb-d07a65c567cc_id_e00e47aa45e147ec0a8646334522c52-id-035992cdebec2318c0a8646340efc345", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo Vincere V3 \/ Aggiunta di componenti dinamici \/ Supporto di adattatori bus di campo opzionali ", 
"snippet" : "CmpHilscherCIFX Autista Questo componente supporta una scheda PC NetX di Hilscher. Per questo, devi semplicemente inserire il componente \"CmpHilscherCIFX\" nel file di configurazione di CODESYS Control Win come segue: [ComponentManager] Component.<n>=CmpHilscherCIFX Quindi, dopo aver installato l'ada...", 
"body" : "CmpHilscherCIFX Autista Questo componente supporta una scheda PC NetX di Hilscher. Per questo, devi semplicemente inserire il componente \"CmpHilscherCIFX\" nel file di configurazione di CODESYS Control Win come segue: [ComponentManager]\nComponent.<n>=CmpHilscherCIFX Quindi, dopo aver installato l'adattatore, devi solo installare il driver SysDrv3S.sys all'avvio del sistema operativo. Questo si trova nel CODESYS directory di installazione in $\\GatewayPLC\\Driver per un sistema operativo Windows a 32 bit o in $\\GatewayPLC\\Driver\\x64 per un sistema operativo Windows a 64 bit. Nota: il configuratore Hilscher SyCon o SYCON.net e il driver Hilscher non devono funzionare in parallelo CODESYS . CmpSofting Profibus Autista Questo componente è necessario se si desidera utilizzare un adattatore di interfaccia USB master PROFIBUS di Softing Industrial Automation GmbH con CODESYS in un'applicazione IEC. Rappresenta l'interfaccia tra il sistema di runtime e il driver proprietario di Softing, utilizzato dalla nostra libreria di driver IoDrvSoftingPROFIusb . In CODESYS , questa libreria viene integrata automaticamente in Library Manager quando aggiungi un dispositivo PROFIusb nell'albero dei dispositivi. Di conseguenza, è possibile utilizzare e configurare il CODESYS sistema runtime su un PC Windows come master PROFIBUS. Per ulteriori informazioni, vedere: Aggiunta di interfacce USB per PROFIBUS CmpBACnet Autista Il componente è necessario quando si desidera utilizzare il collegamento IP BACnet di CODESYS Control Win . Nel file di configurazione è necessaria la seguente voce: [ComponentManager]\nComponent.<n>=CmpBACnet CmpPCANBasicDrv Autista Questo componente implementa il collegamento dell'hardware Peak CAN tramite l'API di base PCAN. Per le istruzioni di installazione, consultare la guida in linea. Non sono necessarie voci del file di configurazione. CmpCAACanL2 Autista Questo componente fornisce un'interfaccia indipendente dall'hardware per l'invio e la ricezione di messaggi CAN. Voci facoltative del file di configurazione: [CmpCAACanL2]\n;If setting PersistentBaudrate is enabled (0: disabled; 1: enabled)\n;the baudrate will be stored into Net.X.DefaultBaudrate (where X equals NetId) when opening the driver.\nPersistentBaudrate=1\n;Default baudrate for CAN network 0. This baudrate will be used when the network is opened (e.g from CmpBlkDrvCan or CANopen) with the baudrate set to 0.\nNet.0.DefaultBaudrate=1000 Nel file di configurazione è possibile salvare un baud rate standard per ciascuna rete CAN (connessione CAN fisica). Questa velocità di trasmissione standard viene sempre utilizzata quando la funzione CL2 DriverOpenH viene chiamato con baud rate 0 e il driver non è ancora aperto. Se questa voce del file di configurazione è mancante, nel caso citato viene emesso un errore poiché la velocità di trasmissione è sconosciuta. La voce è particolarmente utile in connessione con la funzione PersistenBaudrate che è disattivato per impostazione predefinita. Se PersistentBaudrate=1 , poi CODESYS usa la funzione CmpSettings per scrivere questo baud rate nel file di configurazione a un baud rate specifico per ogni chiamata di DriverOpenH . Questo ha l'effetto, ad esempio, che la voce Net.0.DefaultBaudrate è cambiato. Ciò è particolarmente utile quando un controller comunica tramite il driver del blocco CAN. Se il baud rate è 0 ( 0.Baud rate = 0 ) in CmpBlkDrvCanServer , l'utente può modificare il baud rate della comunicazione del driver di blocco modificando il baud rate nel progetto, scaricando l'applicazione e riavviando il controller. CmpCAASdoClient Autista Questo componente implementa il protocollo client SDO CANopen. Voci di configurazione opzionali: [CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity Qui è possibile ridurre il numero di messaggi CAN inviati per ciclo in un trasferimento a blocchi. Ciò è necessario quando un controller ha problemi con una serie di molti frame CAN con lo stesso ID. Tuttavia, questo limita anche le prestazioni, facendo sì che un trasferimento a blocchi richieda più tempo. Server CmpCAASDO Autista Questo componente implementa il protocollo del server CANopen SDO. Voci facoltative del file di configurazione: [CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity Qui è possibile ridurre il numero di messaggi CAN inviati per ciclo in un trasferimento a blocchi. CmpEL6751CanDrv Autista Questo componente implementa il collegamento del terminale gateway CAN\/EtherCAT Beckhoff EL6751. Poiché il componente implementa un minidriver CAN, è possibile utilizzare il CANL2 componente e tutto CODESYS Stack basati su CAN. Non sono richieste voci del file di configurazione. CmpNetXCanDlDrv Autista Questo componente è un minidriver CAN per un adattatore CAN NetX. Con questo driver, CODESYS Control Win può utilizzare le librerie CAN di CODESYS GmbH tramite un adattatore NetX. La configurazione del componente nel file di configurazione di CODESYS Control Win : [CmpNetXCanDlDrv]\nMaxNumberOfCanNetworks=0..n -> number of the CAN networks (number of the NetIds)\nNetId.0.Channel=0 -> mapping of the NetId onboard nad NetX channels (see CmpHilscherCIFX)\nNetId.0.Board=0\n\n[ComponentManager]\n...\nComponent.6=CmpHilscherCIFX\nComponent.7=CmpNetXCanDlDrv\n... " }, 
{ "title" : "Canali di comunicazione opzionali ", 
"url" : "_rtsl_windows_win_v3_dynamic_components.html#UUID-8ec48f4e-4fbf-ff18-64cb-d07a65c567cc_id_e00e47aa45e147ec0a8646334522c52-id-8aa5b4ef9fc59bd9c0a8646351124931", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo Vincere V3 \/ Aggiunta di componenti dinamici \/ Canali di comunicazione opzionali ", 
"snippet" : "CmpBlkDrvCanClient Autista Questo componente implementa a CODESYS block driver per la comunicazione di a CODESYS gateway con a CODESYS controllore tramite CAN (comunicazione di servizio). La comunicazione avviene tramite il protocollo CANopen SDO (\"segmentato\" o \"trasferimento a blocchi\"). Il compon...", 
"body" : "CmpBlkDrvCanClient Autista Questo componente implementa a CODESYS block driver per la comunicazione di a CODESYS gateway con a CODESYS controllore tramite CAN (comunicazione di servizio). La comunicazione avviene tramite il protocollo CANopen SDO (\"segmentato\" o \"trasferimento a blocchi\"). Il componente CmpBlkDrvCanClient è necessario lato gateway e hardware CAN di Peak (ad esempio un dongle USB PCAN). Una configurazione tipica nel file di configurazione del gateway è la seguente: [ComponentManager]\nComponent.1=CmpBlkDrvCANClient\nComponent.2=CmpCAASdoClient\nComponent.3=CmpCAACanL2\nComponent.4=CmpPCANBasicDrv\n\n[CmpBlkDrvCanClient]\nCycleTimeMs=1\nNumChannels=1 ; Number of block driver instances\n0.Name=BlkDrvCanClient\n0.NetId=0 ; CANbus Network Id (0..n)\n0.Baudrate=1000 ; CANbus Baudrate in kbit\/s\n0.NodeId=1 ; unique NodeId of Gateway\n0.BlockTransfer=1 ; Use block transfer for more performance\n\n[CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity\n[CmpBlkDrvCanClient]\nCycleTimeMs=1\nNumChannels=1 ; Number of block driver instances\n0.Name=BlkDrvCanClient\n0.NetId=0 ; CANbus Network Id (0..n)\n0.Baudrate=1000 ; CANbus Baudrate in kbit\/s\n0.NodeId=1 ; unique NodeId of Gateway\n0.BlockTransfer=1 ; Use block transfer for more performance\n\n[CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity CmpBlkDrvCanServer Autista Questo componente implementa a CODESYS block driver per la comunicazione di a CODESYS gateway con a CODESYS controllore tramite CAN (comunicazione di servizio). La comunicazione avviene tramite il protocollo CANopen SDO (\"segmentato\" o \"trasferimento a blocchi\"). Il componente CmpBlkDrvCanServer è necessario sul lato controller e un corrispondente minidriver CAN. Una configurazione tipica nel file di configurazione del controller è la seguente: [Components]\nComponent.1=CmpAnyCANMiniDriverComponent ; TODO: Replace component name by your CAN Mini driver component\nComponent.2=CmpBlkDrvCanServer\n[Components]\nComponent.1=CmpAnyCANMiniDriverComponent ; TODO: Replace component name by your CAN Mini driver component\nComponent.2=CmpBlkDrvCanServer\n\n[CmpCAACanL2]\n;If setting PersistentBaudrate is enabled (0: disabled; 1: enabled)\n;the baudrate will be stored into Net.X.DefaultBaudrate (where X equals NetId)\n;when opening the driver.\nPersistentBaudrate=1\n;Default baudrate for CAN network 0. This baudrate will be used when the network \n;is opened (e.g from CmpBlkDrvCan or CANopen) with the baudrate set to 0.\nNet.0.DefaultBaudrate=1000\n\n[CmpBlkDrvCanServer]\nCycleTimeMs=1\n0.NetId=0\n0.Baudrate=0 ; 0 means: use setting from CmpCAACanL2 section\n0.NodeId=10\n\n[CmpCAASdoServer]\nMaxSegmentsPerCycle=0 ;for block upload: maximum of sent segments per cycle\n;0 means infinity " }, 
{ "title" : "CODESYS Controllo RTE V3 ", 
"url" : "_rtsl_windows_rts_v3.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Gestore protocollo TCP\/UDP (SysSocketLwIP) ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp-protocol_handler.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Gestore protocollo TCP\/UDP (SysSocketLwIP) ", 
"snippet" : "A partire dalla versione 3.5.16.0, uno stack TCP\/UDP è integrato nel CODESYS Control RTE . In passato si verificavano problemi ricorrenti con bus di campo basati su Ethernet che erano basati su stack di protocollo (= gestori di protocollo) di Windows (esempio: EtherNet\/IP, ModbusTCP). Questi bus di ...", 
"body" : "A partire dalla versione 3.5.16.0, uno stack TCP\/UDP è integrato nel CODESYS Control RTE . In passato si verificavano problemi ricorrenti con bus di campo basati su Ethernet che erano basati su stack di protocollo (= gestori di protocollo) di Windows (esempio: EtherNet\/IP, ModbusTCP). Questi bus di campo non potevano soddisfare in modo affidabile le aspettative di un sistema in tempo reale. Con l'introduzione dello stack di protocollo interno, i driver della scheda di rete SysEthernet ( CmpEt100Drv , CmpEt1000Drv , CmpRTL813xMpd , CmpRTL8169Mpd , CmpCX5000Mpd ) non sono più trattati esclusivamente da SysEthernet (o di IoDrvEtherCAT e IoDrvProfinet ). Ora sono indirizzati anche da TCP\/UDP, lo stack di protocollo per la comunicazione IP diretta. " }, 
{ "title" : "Configurazione ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp_configuration.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Gestore protocollo TCP\/UDP (SysSocketLwIP) \/ Configurazione ", 
"snippet" : "Affinché lo stack di protocollo TCP\/UDP integrato venga utilizzato dal sistema runtime, il driver dell'adattatore di rete corrispondente deve essere configurato nell'elenco dei componenti dell'RTE. Il driver nel file di configurazione di RTE CODESYSControl_User.cfg deve essere inserito nel segmento ...", 
"body" : "Affinché lo stack di protocollo TCP\/UDP integrato venga utilizzato dal sistema runtime, il driver dell'adattatore di rete corrispondente deve essere configurato nell'elenco dei componenti dell'RTE. Il driver nel file di configurazione di RTE CODESYSControl_User.cfg deve essere inserito nel segmento [ComponentManager] . Tutte le voci possibili qui sono già preconfigurate dal setup dell'RTE e possono essere attivate nel Configurazione PLC → Gestore componenti menu o eliminando il \";\" all'inizio della riga. (Esempio per tutti gli adattatori di rete 10\/100\/1000 Mbit di Intel: Component.xy=CmpEt1000Drv ) Non sono necessarie impostazioni aggiuntive. La configurazione dell'adattatore di rete viene presa e utilizzata da Windows. Per gli adattatori interessati, uno dei driver della scheda di rete SysEthernet deve essere installato anche in Gestione dispositivi di Windows Componenti dinamici disponibili). I driver delle schede di rete si registrano con lo stack di protocollo interno e decidono in fase di esecuzione se per il protocollo applicato deve essere utilizzato lo stack di protocollo interno o Windows. " }, 
{ "title" : "Log Output dello Stack di Protocollo ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp_log.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Gestore protocollo TCP\/UDP (SysSocketLwIP) \/ Log Output dello Stack di Protocollo ", 
"snippet" : "Gli output di log sono l'unico modo per l'utente di monitorare il comportamento dello stack di protocollo integrato. Impostando il filtro di registro, nel logger vengono scritti più output di quelli forniti dall'impostazione predefinita. Per fare questo, il valore Logger.0.Filter è impostato per 0xF...", 
"body" : "Gli output di log sono l'unico modo per l'utente di monitorare il comportamento dello stack di protocollo integrato. Impostando il filtro di registro, nel logger vengono scritti più output di quelli forniti dall'impostazione predefinita. Per fare questo, il valore Logger.0.Filter è impostato per 0xFFFFFFFF nel file di configurazione dell'RTE CODESYSControl_User.cfg , nel segmento [CmpLog] . Allo stack di protocollo TCP\/UDP integrato possono essere assegnate le seguenti uscite di registro e la relativa causa: *** SysSocketlwIP -> No network-adapter for LwIP available! Nessuno dei driver della scheda di rete è stato caricato perché non esiste nella configurazione (elenco dei componenti) o non è stato installato per almeno una scheda di rete tramite Gestione dispositivi di Windows. *** SysSocketlwIP -> x network-adapters for LwIP available. Almeno una scheda di rete è disponibile per l'utilizzo da parte dello stack di protocollo integrato. *** SysSocketlwIP -> Switched to Winsock, use of unknown adapter! Winsock: 0xxxxxxxx . Un socket con l'indirizzo dell'handle dopo i due punti è stato passato allo stack IP di Windows per un ulteriore utilizzo. Nella maggior parte dei casi, la causa è una chiamata da SysSockBind o SysSockSendTo a un indirizzo dell'adattatore sconosciuto allo stack del protocollo interno, ad esempio 127.0.0.1 (localhost) o 0.0.0.0 (ANY_ADDR). L'output di questo tipo di log è normale quando si avvia il sistema di runtime perché i componenti interni come il server OPC UA, il server Web o CmpBlkDrvTcp si collegano a localhost\/ANY_ADDR. *** Error: SysSocketlwIP driver -> local receive buffer overrun. Se il sistema di runtime è estremamente occupato (ad esempio a causa di compiti IEC che consumano più dell'80 o del 90 percento della potenza di calcolo totale disponibile), può accadere che i frame Ethernet ricevuti non possano essere valutati in tempo dallo stack di protocollo prima della ricezione il buffer è pieno. Nel caso di UDP, questi dati vengono persi e la ripetizione dipende dal protocollo sovrastante. Per le connessioni TCP, viene fornita una ripetizione del blocco. Altro *** Error… non dovrebbero verificarsi output di log e, se necessario, dovrebbero essere segnalati al team di supporto. " }, 
{ "title" : "Attività di comunicazione dello stack di protocollo ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp_communication_task.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Gestore protocollo TCP\/UDP (SysSocketLwIP) \/ Attività di comunicazione dello stack di protocollo ", 
"snippet" : "Lo stack di protocollo interno necessita di un'attività propria per elaborare molte attività UDP e TCP\/IP. Questo task viene creato immediatamente quando il sistema di runtime viene inizializzato e ha priorità 55, che corrisponde a una priorità del task IEC di 23. I task IEC con una priorità più alt...", 
"body" : "Lo stack di protocollo interno necessita di un'attività propria per elaborare molte attività UDP e TCP\/IP. Questo task viene creato immediatamente quando il sistema di runtime viene inizializzato e ha priorità 55, che corrisponde a una priorità del task IEC di 23. I task IEC con una priorità più alta non sono influenzati dalla comunicazione UDP\/TCP. In alcune circostanze, i task IEC con priorità inferiore sono influenzati dalla comunicazione UDP\/TCP. La priorità è stata impostata intenzionalmente per dare allo sviluppatore dell'applicazione la possibilità di non interrompere la comunicazione (bus di campo) con attività a priorità più bassa e che richiedono tempo. O per definire compiti che sono più importanti della comunicazione puntuale. " }, 
{ "title" : "Controllo del comportamento temporale ", 
"url" : "_rtsl_windows_rte_v3_check_timing_rte.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Controllo del comportamento temporale ", 
"snippet" : "Crea un semplice progetto standard con CODESYS . Configura l'unica attività su un tempo di ciclo di 1 ms. Programma una variabile contatore come tipo DWORD che conta i cicli. Di conseguenza, rilevi immediatamente se il 1000° posto viene incrementato circa una volta al secondo, come vogliamo in quest...", 
"body" : "Crea un semplice progetto standard con CODESYS . Configura l'unica attività su un tempo di ciclo di 1 ms. Programma una variabile contatore come tipo DWORD che conta i cicli. Di conseguenza, rilevi immediatamente se il 1000° posto viene incrementato circa una volta al secondo, come vogliamo in questo caso. In modalità online, apri il Monitoraggio scheda nel Configurazione attività . Vengono visualizzati i tempi di jitter calcolati dall'RTE. Su un sistema normale, questi oscillano di ±100 μs. Se l'hardware è dotato di una porta seriale o parallela, è possibile utilizzare SysPort.library per programmare le uscite sui singoli pin di queste porte nel progetto sopra descritto. Quindi puoi esaminare il comportamento temporale di CODESYS Control RTE molto precisamente per mezzo di un oscilloscopio. Se si dispone di uno slave EtherCAT con I\/O digitali, è possibile utilizzare questi I\/O per eseguire misurazioni molto buone anche con l'oscilloscopio. Per ulteriori informazioni, vedere: Configurazione del comportamento in tempo reale su piattaforme speciali e Scheda: Monitoraggio " }, 
{ "title" : "Configurazione del comportamento in tempo reale su piattaforme speciali ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Configurazione del comportamento in tempo reale su piattaforme speciali ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comportamento in tempo reale di CODESYS Control RTE su piattaforme speciali ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-904131440f59a05ac0a864633beb1ad4", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Configurazione del comportamento in tempo reale su piattaforme speciali \/ Comportamento in tempo reale di CODESYS Control RTE su piattaforme speciali ", 
"snippet" : "Il comportamento temporale di CODESYS Control RTE dipende dalla coerenza del clock della CPU e dal ciclo del front-side bus. Con impostazioni specifiche nel BIOS e in Windows, è possibile modificare il comportamento temporale in base alle condizioni delle diverse piattaforme....", 
"body" : "Il comportamento temporale di CODESYS Control RTE dipende dalla coerenza del clock della CPU e dal ciclo del front-side bus. Con impostazioni specifiche nel BIOS e in Windows, è possibile modificare il comportamento temporale in base alle condizioni delle diverse piattaforme. " }, 
{ "title" : "Impostazioni nel BIOS ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-24bd95e00f59a05ac0a8646332b0218d", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Configurazione del comportamento in tempo reale su piattaforme speciali \/ Impostazioni nel BIOS ", 
"snippet" : "Possono essere fornite solo raccomandazioni generali per ottimizzare il comportamento temporale di CODESYS Control RTE perché la maggior parte delle piattaforme ha diversi tipi di BIOS....", 
"body" : "Possono essere fornite solo raccomandazioni generali per ottimizzare il comportamento temporale di CODESYS Control RTE perché la maggior parte delle piattaforme ha diversi tipi di BIOS. " }, 
{ "title" : "Impostazioni in Windows ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-6c4e42d628502216c0a864630d4e6b2f", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Configurazione del comportamento in tempo reale su piattaforme speciali \/ Impostazioni in Windows ", 
"snippet" : "Raccomandazione: lo schema di alimentazione deve essere sempre impostato su \" Sempre acceso \". Aggiornamenti automatici : Gli aggiornamenti devono sempre essere eseguiti manualmente per un controller industriale perché il PC può essere riavviato con un meccanismo automatico senza alcuna richiesta de...", 
"body" : "Raccomandazione: lo schema di alimentazione deve essere sempre impostato su \" Sempre acceso \". Aggiornamenti automatici : Gli aggiornamenti devono sempre essere eseguiti manualmente per un controller industriale perché il PC può essere riavviato con un meccanismo automatico senza alcuna richiesta dell'utente. " }, 
{ "title" : "Adattamenti per \"APIC\" (singolo e multiprocessore) e \"AMP\" (funzionamento dell'RTE su singolo core della CPU) ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-3cbaa0b1908b4745c0a86463315e2cd5", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Configurazione del comportamento in tempo reale su piattaforme speciali \/ Adattamenti per \"APIC\" (singolo e multiprocessore) e \"AMP\" (funzionamento dell'RTE su singolo core della CPU) ", 
"snippet" : "L'adeguamento generale alle caratteristiche specifiche delle piattaforme è effettuato dal CmpDrvSchedulerAMP E CmpDrvSchedulerAPIC componenti (non più rilevanti dall'interruzione di Windows 7). Per impostazione predefinita, il CmpDrvSchedulerAMP viene installato dalla configurazione di CODESYS Contr...", 
"body" : "L'adeguamento generale alle caratteristiche specifiche delle piattaforme è effettuato dal CmpDrvSchedulerAMP E CmpDrvSchedulerAPIC componenti (non più rilevanti dall'interruzione di Windows 7). Per impostazione predefinita, il CmpDrvSchedulerAMP viene installato dalla configurazione di CODESYS Control RTE . CmpDrvSchedulerAPIC è ancora incluso solo per motivi di compatibilità e può essere installato manualmente solo su vecchi PC Windows 7. In generale, il CODESYS Control RTE può essere eseguito solo su PC con più di un core del processore ( CmpDrvSchedulerAMP ). L'unica eccezione è la piattaforma Windows \"Windows 7 (32 bit)\". Il CmpDrvSchedulerAPIC può ancora essere utilizzato solo su questa piattaforma. Con questo componente, il CODESYS Control RTE può utilizzare il time slicing per condividere il core 0 della CPU con Windows. Test complicati vengono eseguiti all'avvio del CODESYS Control RTE per la prima volta per scalare le velocità di clock a microsecondi. I risultati di questo messaggio vengono salvati nel registro di Windows: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\CmpDrvSchedulerAMP\\Params o HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\CmpDrvSchedulerAPIC\\Params , i valori SetClocksPerUS e SetCountsPerMS . Ogni volta il CODESYS Control RTE viene avviato, le misurazioni non vengono eseguite nuovamente quando i valori ottenuti dalla misurazione al primo avvio possono essere letti dal registro. Se un adattamento effettuato nel sistema (ad esempio, l'impostazione di risparmio energetico nel BIOS) ha causato la modifica dell'orologio della CPU rispetto alla misurazione, questi valori devono essere eliminati dal registro di Windows. Solo allora le frequenze di clock vengono ridimensionate quando il CODESYS Control RTE è ricominciato. Per ulteriori informazioni, vedere: Configurazione hardware - Raccomandazioni" }, 
{ "title" : "Messa in servizio della Hilscher CIFX Card ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Messa in servizio della Hilscher CIFX Card ", 
"snippet" : "Per installare una scheda di rete Hilscher CIFX, procedere come segue CODESYS Control RTE . La procedura è indipendente dal sistema bus di campo utilizzato. Sono supportati i seguenti bus di campo con CIFX: PROFINET Controllore e PROFINET Dispositivo PROFIBUS Maestro e PROFIBUS Controllore netX-CAN ...", 
"body" : "Per installare una scheda di rete Hilscher CIFX, procedere come segue CODESYS Control RTE . La procedura è indipendente dal sistema bus di campo utilizzato. Sono supportati i seguenti bus di campo con CIFX: PROFINET Controllore e PROFINET Dispositivo PROFIBUS Maestro e PROFIBUS Controllore netX-CAN EtherNet\/IP Scanner " }, 
{ "title" : "Installazione del driver di Windows ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-3b8953bc0e40fc79c0a8646325dd6b8e", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Messa in servizio della Hilscher CIFX Card \/ Installazione del driver di Windows ", 
"snippet" : "Quando si utilizza la scheda Hilscher con il CODESYS Control RTE runtime, non è necessario utilizzare il driver Hilscher fornito per la scheda di rete. Se usi CODESYS Control RTE con NetX, è necessario installare SysDrv3s.sys ( SysDrv3S sottodirectory) fornita con il pacchetto di installazione di RT...", 
"body" : "Quando si utilizza la scheda Hilscher con il CODESYS Control RTE runtime, non è necessario utilizzare il driver Hilscher fornito per la scheda di rete. Se usi CODESYS Control RTE con NetX, è necessario installare SysDrv3s.sys ( SysDrv3S sottodirectory) fornita con il pacchetto di installazione di RTE. " }, 
{ "title" : "Firmware NetX e caricatore di avvio NetX ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-82e7a36597005e19c0a864632973a990", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Messa in servizio della Hilscher CIFX Card \/ Firmware NetX e caricatore di avvio NetX ", 
"snippet" : "Il firmware NetX e il boot loader NetX sono forniti insieme al pacchetto di installazione e si trovano nella sottocartella HilscherCIFX\\Firmware dopo l'installazione....", 
"body" : "Il firmware NetX e il boot loader NetX sono forniti insieme al pacchetto di installazione e si trovano nella sottocartella HilscherCIFX\\Firmware dopo l'installazione. " }, 
{ "title" : "Aggiunta del componente ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-6d2a7e991eb48aa8c0a86463368630e2", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Messa in servizio della Hilscher CIFX Card \/ Aggiunta del componente ", 
"snippet" : "Nel CODESYS Control RTE menu, fare clic Configurazione PLC . Nella finestra di dialogo, passa a Gestore componenti scheda. Aggiungi il componente facoltativo CmpHilscherCIFX e fare clic ok per confermare....", 
"body" : "Nel CODESYS Control RTE menu, fare clic Configurazione PLC . Nella finestra di dialogo, passa a Gestore componenti scheda. Aggiungi il componente facoltativo CmpHilscherCIFX e fare clic ok per confermare. " }, 
{ "title" : "Configurazione di RTE con \"CODESYSControl.cfg\" ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-a4398f680e40fc88c0a864635dd4fc93", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Messa in servizio della Hilscher CIFX Card \/ Configurazione di RTE con \"CODESYSControl.cfg\" ", 
"snippet" : "Il file di configurazione CODESYSControl.cfg si trova nella directory di installazione. Aggiungi il componente CmpHilscherCifX : [ComponentManager] ...Component.x=CmpHilscherCIFX ... Nel segmento CmpHilscherCIFX , attivare le righe corrispondenti in base al numero di schede CIFX (rimuovere \";\" all'i...", 
"body" : "Il file di configurazione CODESYSControl.cfg si trova nella directory di installazione. Aggiungi il componente CmpHilscherCifX : [ComponentManager]\n...Component.x=CmpHilscherCIFX\n... Nel segmento CmpHilscherCIFX , attivare le righe corrispondenti in base al numero di schede CIFX (rimuovere \";\" all'inizio della riga). ...\n[CmpHilscherCIFX]\n;TraceLevel=0xFFFFFFFF\nDevice.0.BootloaderFilePath=... (see image)\nDevice.0.Channel.0.FirmwareFile=...\n\n TraceLevel : per attivare attività di debug aggiuntive nel logger CODESYS BootloaderFilePath : Percorso file e nomi file del caricatore di avvio NetX per ciascun controller NetX. Un percorso relativo inizia nella directory di installazione. Può essere utilizzato anche un percorso assoluto. Se stai utilizzando più di un controller NetX, devi specificare più di un percorso di file. ...\nDevice.0.BootloaderFilePath=NXCIF50-RTE.bin\nDevice.1.BootloaderFilePath=NXCIF50-RTE.bin\n... Device.X.Channel.X.FirmwareFile : Percorso file e nomi file del firmware NetX per ciascun adattatore e ciascun canale. Un percorso relativo inizia nella directory di installazione. Può essere utilizzato anche un percorso assoluto. Viene utilizzato principalmente solo il \"Canale 0\". Se stai usando più di un chip NetX, devi specificare più di un percorso di file. ...\nDevice.0.Channel.0.FirmwareFile=cifxdpm.nxf\nDevice.1.Channel.0.FirmwareFile=cifxdpm.nxf\n... Risultato: " }, 
{ "title" : "Avvio del sistema di runtime ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-b219f19c0e40fc88c0a864630469e13f", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Messa in servizio della Hilscher CIFX Card \/ Avvio del sistema di runtime ", 
"snippet" : "Avviare il sistema di runtime facendo clic Avvia PLC nel menu SysTray di CODESYS Control RTE . Non appena il sistema di runtime è in esecuzione, le voci per CmpHilscherCIFX appaiono nel logger di sistema di runtime. Vedi le voci nel Tronco d'albero finestra di dialogo dell'editor del dispositivo in ...", 
"body" : "Avviare il sistema di runtime facendo clic Avvia PLC nel menu SysTray di CODESYS Control RTE . Non appena il sistema di runtime è in esecuzione, le voci per CmpHilscherCIFX appaiono nel logger di sistema di runtime. Vedi le voci nel Tronco d'albero finestra di dialogo dell'editor del dispositivo in CODESYS , così come nel LogPLCxx.csv file nel CODESYS Control RTE directory. Controllare quanto segue: Il componente CmpHilscherCIFX devono essere stati caricati. La versione del toolkit di CmpHilscherCIFX componente deve essere visualizzato. Il firmware è caricato. Il logger notifica il nome e la versione del firmware. Se imposti TraceLevel a 0xFFFFFFFF , le informazioni vengono emesse da CmpHilscherCIFX per ogni canale NetX configurato. Per ulteriori informazioni, vedere: Scheda: Registro " }, 
{ "title" : "Creazione di un CODESYS progetto con configurazione I\/O ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-1f474e4c0e40fc88c0a8646300249b0e", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Messa in servizio della Hilscher CIFX Card \/ Creazione di un CODESYS progetto con configurazione I\/O ", 
"snippet" : "Ora puoi creare un semplice CODESYS progetto con il bus di campo in funzione: Crea un nuovo progetto standard in CODESYS . Seleziona il dispositivo CODESYS Control RTE durante la creazione. Aggiungere un master bus di campo CIFX-PB nella struttura dei dispositivi. Aprire la finestra di dialogo di co...", 
"body" : "Ora puoi creare un semplice CODESYS progetto con il bus di campo in funzione: Crea un nuovo progetto standard in CODESYS . Seleziona il dispositivo CODESYS Control RTE durante la creazione. Aggiungere un master bus di campo CIFX-PB nella struttura dei dispositivi. Aprire la finestra di dialogo di configurazione per il master bus di campo facendo doppio clic sulla voce nella struttura ad albero dei dispositivi. Passa al Configurazione NetX scheda. Imposta i valori di Fessura e Canale di comunicazione NetX in modo che siano identici ai numeri di dispositivo nel file di configurazione CODESYSControl.cfg . Confrontare i valori con le voci del logger del sistema di runtime. Crea l'applicazione. Scarica l'applicazione sul controller e avviala. Ora ogni nodo dell'albero dei dispositivi deve essere contrassegnato in verde. " }, 
{ "title" : "FAQ ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-d19e04ada023b398c0a8646370386558", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Messa in servizio della Hilscher CIFX Card \/ FAQ ", 
"snippet" : "Il master bus di campo nell'albero dei dispositivi non è verde. Come posso trovare il problema? Aprire l'editor di configurazione del PLC (il Impostazioni di comunicazione si trovano anche in questo editor), passare a Tronco d'albero scheda e fare clic sulla freccia verde. CODESYS carica e visualizz...", 
"body" : "Il master bus di campo nell'albero dei dispositivi non è verde. Come posso trovare il problema? Aprire l'editor di configurazione del PLC (il Impostazioni di comunicazione si trovano anche in questo editor), passare a Tronco d'albero scheda e fare clic sulla freccia verde. CODESYS carica e visualizza tutte le voci del logger dal PLC. Quindi puoi cercare errori ed eccezioni. Ci sono riferimenti irrisolti. Se nell'applicazione sono presenti riferimenti non risolti, il componente di sistema di runtime non viene caricato o viene caricata una versione errata. Controlla il CODESYS logger. Il componente CmpHilscherCIFX devono essere stati caricati. Se CmpHilscherCIFX non è stato caricato, inserire il componente nel file CODESYSControl.cfg file. Se CmpHilscherCIFX è stato caricato, potrebbe essere stata utilizzata una versione deprecata. In questo caso aggiornare l'intero sistema runtime reinstallando RTE. TraceLevel è stato attivato, ma non è possibile trovare una nuova voce per il CmpHilscherCIFX componente. Ciò significa che il runtime non trova l'adattatore o il chip NetX. Verificare che l'adattatore sia inserito correttamente e che sia installato il driver corrispondente. Per ulteriori informazioni, vedere sopra: Installazione del driver di Windows. " }, 
{ "title" : "Configurazione hardware - Raccomandazioni ", 
"url" : "_rtsl_windows_rte_v3_examples_hints.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Configurazione hardware - Raccomandazioni ", 
"snippet" : "Potrebbe essere necessario adattare le impostazioni del BIOS per il CODESYS Control RTE per funzionare sulla rispettiva piattaforma con un jitter ottimale. Vedere gli esempi seguenti per gli adattamenti, che dovrebbero essere considerati solo come raccomandazioni. Le seguenti impostazioni del BIOS d...", 
"body" : "Potrebbe essere necessario adattare le impostazioni del BIOS per il CODESYS Control RTE per funzionare sulla rispettiva piattaforma con un jitter ottimale. Vedere gli esempi seguenti per gli adattamenti, che dovrebbero essere considerati solo come raccomandazioni. Le seguenti impostazioni del BIOS devono essere sempre disabilitate: HT (hyperthreading con CPU Intel; multithreading simultaneo con CPU AMD) VT (tecnologia di virtualizzazione per CPU Intel; AMD-V per CPU AMD) In Windows 10 o versioni successive, VT fa sì che Windows stesso venga avviato in un ambiente virtuale e l'RTE non è quindi in grado di avviare un core della CPU anche se non è utilizzato da Windows. Un'alternativa alla disattivazione di questa opzione BIOS è quindi la disattivazione della funzionalità «Virtual Machine Platform» di Windows o la funzionalità «Windows Hypervisor Platform». Alla fine, disabilitare l'opzione VT è il BIOS l'opzione migliore USB legacy o altre funzioni BIOS che portano a SMI periodici. Le SMI sono interruzioni di gestione del sistema che arrestano l'intero sistema per alcune decine o centinaia di microsecondi. Opzioni di risparmio energetico per processori Intel o AMD che comportano variazioni di frequenza (come EIST per CPU Intel o Cool'n'Quiet per CPU AMD) Autotest o test di memoria periodici Le «modalità sleep» svolgono un ruolo decisivo («C-States» nella terminologia ACPI). I numeri più alti dopo la «C» indicano stati di sonno inferiori. In modalità sleep, i processori non solo riducono la tensione e la velocità di clock, ma disattivano anche la cache e intere aree del servizio. Nel BIOS, le opzioni responsabili di ciò sono in genere chiamate «C-States «SpeedStep» di Intel o «PowerNow» di AMD vengono talvolta denominati «EIST» e in questo caso devono essere disattivati. Se il controllo o la configurazione delle impostazioni del processore non è coperto dal BIOS o l'opzione non è disponibile, è possibile trovare gli strumenti corrispondenti su Internet. Esempi: RightMark CPU CPU-Z (CPUID) RM Clock Opzioni di alimentazione come Avvio veloce O Ibernazione non deve essere consentito in nessun caso. " }, 
{ "title" : "Componenti dinamici disponibili ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Componenti dinamici disponibili ", 
"snippet" : "Per l'adattamento vengono utilizzati componenti opzionali CODESYS Control RTE all'hardware specifico. È inoltre possibile caricare questi componenti nella configurazione dal file Responsabile dei componenti scheda del Configurazione PLC  dialogo. Per ulteriori informazioni, vedere: Finestra di dialo...", 
"body" : "Per l'adattamento vengono utilizzati componenti opzionali CODESYS Control RTE all'hardware specifico. È inoltre possibile caricare questi componenti nella configurazione dal file Responsabile dei componenti scheda del Configurazione PLC  dialogo. Per ulteriori informazioni, vedere: Finestra di dialogo: Configurazione del sistema – Gestore componenti" }, 
{ "title" : "Adattamento alla piattaforma hardware ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-80961508ba9b6b22c0a8646354292cdd", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Componenti dinamici disponibili \/ Adattamento alla piattaforma hardware ", 
"snippet" : "Sui processori multicore, CmpDrvSchedulerAMP viene sempre inizializzato dal setup. Questo scarica l'esecuzione dell'RTE su un core della CPU non utilizzato da Windows. Su Windows 64-bit o versioni di Windows > 7, un'operazione in tempo reale è possibile solo in questo modo. Di conseguenza, l'install...", 
"body" : "Sui processori multicore, CmpDrvSchedulerAMP viene sempre inizializzato dal setup. Questo scarica l'esecuzione dell'RTE su un core della CPU non utilizzato da Windows. Su Windows 64-bit o versioni di Windows > 7, un'operazione in tempo reale è possibile solo in questo modo. Di conseguenza, l'installazione limiterà l'esecuzione di Windows ai primi <numero di core fisicamente disponibili - 1> core tramite l'opzione di avvio numproc . I core di hyperthreading devono essere abbandonati completamente. Il setup riconosce la piattaforma e inserisce automaticamente il driver richiesto come primo componente nel file cfg dell'RTE. Questo non deve mai essere cambiato. I driver salvano i risultati della misurazione al primo avvio quando viene determinata la velocità dell'hardware applicato. Questi vengono salvati come nomi nel percorso dei servizi di sistema HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Service nella chiave Params . A tutti i successivi avvii del sistema, il valore determinato viene letto dal registro. Quando mancano i valori, la misurazione viene ripetuta. " }, 
{ "title" : "Supporto di adattatori bus di campo opzionali ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-db3e9d0eba9b6b22c0a86463246ec925", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Componenti dinamici disponibili \/ Supporto di adattatori bus di campo opzionali ", 
"snippet" : "CmpEt1000Drv Autista Questo driver supporta direttamente Pro1000 -set di chip compatibili di Intel. Per utilizzare il componente, è necessario sostituire il driver originale di Intel con questo driver in Gestione dispositivi di Windows. Continua come segue: Apri Gestione dispositivi di Windows. Fare...", 
"body" : "CmpEt1000Drv Autista Questo driver supporta direttamente Pro1000 -set di chip compatibili di Intel. Per utilizzare il componente, è necessario sostituire il driver originale di Intel con questo driver in Gestione dispositivi di Windows. Continua come segue: Apri Gestione dispositivi di Windows. Fare clic con il pulsante destro del mouse sul selezionato Pro1000 scheda di rete e fare clic sul comando Aggiorna il software del driver . Selezionare il driver manualmente e specificare il percorso come <RTE installation directory>\\CmpET1000MPD . Se il gestore dispositivi si rifiuta di installare il driver, disinstallare il driver originale da Intel premendo il tasto <Canc> chiave ed eliminare il corrispondente inf e pnf file nella directory <SystemRoot>\\inf . Nota: SystemRoot di solito è \" C:Windows \". Il inf i file da utilizzare qui sono ampiamente denominati net557*.inf \/ pnf o net559*.inf \/ pnf . Nota: se si fa riferimento a Pro1000 nel inf file, quindi di solito è il file corretto. Il pnf il file ha sempre lo stesso nome di inf file. Quindi, quando il sistema viene riavviato, Windows non può più installare il driver automaticamente. Viene avviato il gestore hardware e il driver inserito <RTE installation directory>\\CmpET1000MPD viene trasferito ad esso. Devi anche abilitare i componenti di runtime nel file CODESYSControl_User.cfg : Component.<subsequent number>=CmpEt1000Drv CmpEt100Drv Autista Nota: questo driver viene fornito solo per motivi di compatibilità. L'hardware non può più essere acquistato. Questo driver supporta direttamente Pro100 -set di chip compatibili di Intel. Per utilizzare il componente, è necessario sostituire il driver originale di Intel con questo driver in Gestione dispositivi di Windows. Continua come segue: Apri Gestione dispositivi di Windows. Fare clic con il pulsante destro del mouse sul selezionato Pro100 scheda di rete e fare clic sul comando Aggiorna il software del driver . Selezionare il driver manualmente e specificare il percorso come <RTE installation directory>\\CmpET100MPD . Se il gestore dispositivi si rifiuta di installare il driver, disinstallare il driver originale da Intel premendo il tasto <Canc> chiave ed eliminare il corrispondente inf e pnf file nella directory <SystemRoot>\\inf . Nota: SystemRoot di solito è \" C:\\Windows \". Il inf i file da utilizzare qui sono ampiamente denominati net557*.inf \/ pnf o net559*.inf \/ pnf . Nota: se si fa riferimento a Pro100 nel inf file, quindi di solito è il file corretto. Il pnf il file ha sempre lo stesso nome di inf file. Quindi, quando il sistema viene riavviato, Windows non può più installare il driver automaticamente. Viene avviato il gestore hardware e il driver inserito <RTE installation directory>\\CmpET100MPD viene trasferito ad esso. Devi anche abilitare i componenti di runtime nel file CODESYSControl_User.cfg : Component.<subsequent number>=CmpEt100Drv CmpSJACanDrv Autista CmpSJACanDrv è un driver generico per hardware CAN basato sul controller CAN SJA1000 o controller compatibili. Gli adattatori PCI di Peak, Ixxat (adattatore CAN passivo) e Automata sono supportati direttamente. Dopo aver installato l'adattatore, è possibile selezionare e installare i driver corrispondenti dalla directory W2K_XP_Drivers (nella directory di installazione di RTE). Per fare ciò, usa la procedura guidata che appare direttamente sopra Nuovo hardware trovato o utilizzare il gestore dispositivi di Windows (menu contestuale: comando Aggiorna il software del driver ). Si installa il driver desiderato selezionando manualmente un driver e navigando in una delle directory sopra citate. Il dispositivo si trova nella categoria \" 3S compatible devices \". Nota: il driver originale del produttore non deve essere installato. L'autista CmpSJACanDrv può anche indirizzare SJA1000 controller fissati sull'hardware. Le proprietà di questi tipi di controller CAN integrati possono essere trasferite al driver tramite voci nel file di configurazione di CODESYS Control RTE nella sezione [CmpSJACanDrv] . Possibili voci: NumDevices=1 <number of SJAs> ;Number of SJAs, that are configured in the following>\n;(optional: <DisableRetain=1> The driver is told that it should\n; not create any retain entry in the cfg file, even if a CAN adapter is equipped with NVRAM.)\n0.Address=<physical address of the SJA1000> \n0.Interrupt=<interrupt vector of the SJA1000>\n0.IntEdgeTrig=<0 or 1. 0 hardware dependent>\n0.XtalFrequency=<frequency> ;normally 16000000Hz, 24000000Hz is also a possible variant\n0.BusType=<bus type> ;depending on the type of switching of the SJA, \n;1 for ISA, 3 for PCI, 0 for memory\n0.Alignment=<alignment> ;normally 1, hardware dependent\n0.Name=<any name>\n.OutputCtrl=<valid values:e.g. 0xFE, 4C, 1A> ;Depends on the CAN switching\n0.PortAddress=<port address> ;This address is written one time for \n;initializing the CAN switching.\n0.PortValue=<vlaue> ;The value that is written for the initialization. CmpNetXCandlDrv Autista Questo componente è un minidriver CAN per un adattatore CAN NetX. Con questo driver, CODESYS Control RTE può utilizzare le librerie CAN da CODESYS GmbH tramite un adattatore NetX. CmpNetXCanDlDrv può essere utilizzato solo con CmpHilscherCIFX su cui caricare un firmware CAN (master o slave). Non importa se viene utilizzato un master o uno slave perché CmpNetXCanDlDrv utilizza solo l'interfaccia del driver CAN dell'adattatore. Il protocollo è gestito da una libreria 3S CAN. La configurazione del componente nel file di configurazione di CODESYS Control RTE : [CmpNetXCanDlDrv]MaxNumberOfCanNetworks=0..n -> number of the CAN networks (number of the NetIds)\nNetId.0.Channel=0 -> mapping of the NetId onboard nad NetX channels (see CmpHilscherCIFX)\nNetId.0.Board=0 CmpRTL81x9Mpd Autista Nota: questo driver viene fornito solo per motivi di compatibilità. L'hardware non può più essere acquistato. Questo driver supporta direttamente Realtek RTL8139 (e compatibili) controller Ethernet. I set di gettoni combinati 8100 e 8110 sono anche compatibili. Anche l'installazione viene eseguita in modo simile a CmpEt100Drv . CmpRTL8169Mpd Autista Allo stesso modo di per CmpRTL81x9Mpd ; per la variante gigabit di cui sopra Realtek Controller Ethernet. CmpSercos3Master Autista Questo driver supporta il SERCOS III PCI adapter 700353x0 da Automi. Dopo aver installato l'adattatore, installare il driver da W2K_XP_Drivers\\Automata_SERCOS3 . CmpHilscherCIFX Autista Questo driver supporta una scheda CifX di Hilscher. Dopo aver installato la scheda, è possibile installare il driver fornito da Hilscher o SysDrv3S . (Nell'ambito della fornitura del CODESYS Control Win sistema di runtime per Windows da CODESYS GmbH ). Specificare il componente nel file cfg file di CODESYS Control RTE . Ciò è possibile tramite un editor o tramite il Configurazione PLC dialogo. Genera il [CmpHilscherCIFX] anche la sezione. Le seguenti voci sono necessarie per il conducente (esempio): Device.0.BootloaderFilePath=NXCIF50-RTE.bin\nDevice.0.Channel.0.FirmwareFile=cifxdpm.nxf In questo esempio, il 0 in Device.0 è l'indice in base 0 dell'adattatore se ne viene utilizzato più di uno. Channel è sempre seguito da 0 perché tutti gli adattatori PCI di Hilscher supportano un solo canale. I file che contengono i boot loader o il firmware vengono forniti con la scheda CifX di Hilscher. Devi inserirli nella directory del file radice del file CODESYS Control RTE . Potrebbe anche essere necessario adattare i nomi dei file o le voci nel file di configurazione. Per ulteriori informazioni, vedere: Messa in servizio della Hilscher CIFX Card " }, 
{ "title" : "Adattatori plug-in PCI NVRAM ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-70a6f7c2ba9b6b22c0a86463083c7758", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Componenti dinamici disponibili \/ Adattatori plug-in PCI NVRAM ", 
"snippet" : "CmpPciRetain Autista Questo driver consente l'uso della NVRAM come memoria di ritenzione su un adattatore PCI. Requisiti: la NVRAM è raggiungibile direttamente tramite l'indirizzo fisico nei registri PCI e supporta tutti i campi di accesso, ad esempio byte, word e double word access. È possibile con...", 
"body" : "CmpPciRetain Autista Questo driver consente l'uso della NVRAM come memoria di ritenzione su un adattatore PCI. Requisiti: la NVRAM è raggiungibile direttamente tramite l'indirizzo fisico nei registri PCI e supporta tutti i campi di accesso, ad esempio byte, word e double word access. È possibile configurare il componente con le seguenti voci nel file di configurazione CoDeSysControl.cfg di CODESYS Control RTE nella sezione [CmpPciRetain] : VendorID , DeviceID , SubDeviceID , SubVendorID : Identificazione del dispositivo PCI. AddressIndex : Registro indirizzi PCI ( BAR0 – BAR5 ) che contiene l'indirizzo di base fisico della NVRAM. Valore di default: 0 . MemorySize : Dimensione (in byte) della NVRAM disponibile. Valore di default: 0x80000 (512KB). AddrOffset : Spostamento della NVRAM rispetto al registro degli indirizzi utilizzato. Consultare la documentazione dell'adattatore PCI utilizzato per i valori di AddressIndex , MemorySize , e AddrOffset . I valori predefiniti dei quattro ID identificano il dispositivo MRAM in un PC Siemens NanoBox. " }, 
{ "title" : "Componenti specifici per Beckhoff CX5xxx ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-821f92efba9b6b32c0a8646353736f59", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Componenti dinamici disponibili \/ Componenti specifici per Beckhoff CX5xxx ", 
"snippet" : "CmpCX5000Mpd Autista Questo è un driver di rete di Windows. Può essere utilizzato solo su a CXxxxx PC Beckhoff con a CX5000 processore di comunicazione. Se l'impostazione di CODESYS Control RTE viene eseguito su a CXxxxx PC, poi il driver CmpCX5000Mpd viene installato automaticamente e aggiunto a un...", 
"body" : "CmpCX5000Mpd Autista Questo è un driver di rete di Windows. Può essere utilizzato solo su a CXxxxx PC Beckhoff con a CX5000 processore di comunicazione. Se l'impostazione di CODESYS Control RTE viene eseguito su a CXxxxx PC, poi il driver CmpCX5000Mpd viene installato automaticamente e aggiunto a un elenco di componenti (nel file cfg). Informazioni aggiuntive e installazione manuale: Eccezione: un CX-IPC è stato installato per impostazione predefinita con \"Windows7 embedded standard\". Questo comprende un driver Beckhoff per il dispositivo PCI con gli ID hardware VendorID = SubVendorID = 0x15ec e DeviceID = SubDeviceID = 0x5000 . Dopo l'installazione di CODESYS Control RTE , puoi sostituire questo driver con il driver CmpCX5000Mpd.sys . In questo caso, utilizzare la funzione Aggiorna il software del driver nel Pannello di controllo di Windows: Apri Gestione dispositivi di Windows. Cerca il dispositivo di sistema da Beckhoff, fai clic con il pulsante destro del mouse, quindi esegui il comando Aggiorna il software del driver . Nella procedura guidata, seleziona il Cerca manualmente il software del driver opzione e fare clic Avere il disco . Seleziona il inf file nella directory di installazione di CODESYS Control RTE (sottodirectory CmpCX5000Mpd ). Confermare eventuali richieste relative all'installazione del driver. Windows installa una scheda di rete denominata CX5000 driver for CODESYS Ethernet . Specificare manualmente il driver nel file di configurazione CoDeSysControl.cfg (directory di installazione di CODESYS Control RTE ): Esempio: Component.3=CmpCX5000Mpd . Quindi un download di un CODESYS progetto con EtherCAT non dovrebbe più visualizzare riferimenti irrisolti. CmpCXSecUPS Autista Questo driver può essere utilizzato solo su un \"PC integrato\" della serie CX5000 o CX5100 di Beckhoff. Il componente monitora un pin che monitora lo stato dell'alimentatore in una chiamata ciclica a bassa priorità del task di comunicazione. Se viene rilevata un'interruzione di corrente, le applicazioni vengono arrestate e i dati di conservazione vengono salvati in un file (in genere Application.ret ). Nota: esistono le seguenti restrizioni durante il salvataggio dei dati di conservazione: A seconda del carico attuale del PLC, il rilevamento dell'interruzione di corrente può essere ritardato. A seconda del carico del PC, varia il tempo che può essere utilizzato per il salvataggio dei dati dopo un'interruzione di corrente. A causa di queste restrizioni, è necessario testare la memorizzazione dei dati ritentivi con le applicazioni completate. Si raccomanda inoltre di verificare la validità delle variabili rimanenti all'avvio dell'applicazione. Il componente non dispone di alcuna opzione di configurazione. Devi aggiungerli solo all'elenco dei componenti del controller. Per ulteriori informazioni, vedere: Voci anagrafiche della RTE " }, 
{ "title" : "Voci anagrafiche della RTE ", 
"url" : "_rtsl_windows_rte_v3_registry_entries.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ CODESYS Controllo RTE V3 \/ Voci anagrafiche della RTE ", 
"snippet" : "Il comportamento di CODESYS Control RTE può essere configurato parzialmente nell'editor del registro di Windows (registro di Windows). La tabella seguente fornisce informazioni sui valori e sui rispettivi valori predefiniti utilizzati se il valore è mancante. Solo una parte di questi valori può esse...", 
"body" : "Il comportamento di CODESYS Control RTE può essere configurato parzialmente nell'editor del registro di Windows (registro di Windows). La tabella seguente fornisce informazioni sui valori e sui rispettivi valori predefiniti utilizzati se il valore è mancante. Solo una parte di questi valori può essere modificata in Configurazione PLC dialogo di CODESYS Control RTE . Tutti i valori si trovano nel registro nel percorso HKEY_LOCAL_MACHINE\\SOFTWARE\\3S-Smart Software Solutions GmbH\\CODESYS SP\\3SRTE3 o relativo quando viene specificata una chiave prima del nome nella tabella. Nome Tipo Senso Valore di default AutoStartPLC DWORD 0 o 1 : Con 1 , il PLC viene avviato automaticamente dal servizio di sistema. 0 AllowSetAppConfiguration DWORD 0 o 1 : determina se l'utente può utilizzare la finestra di dialogo per impostare i valori di Applicazione finestra di configurazione. 1 AllowSetCMConfiguration DWORD 0 oder 1 : <come nella voce precedente> 1 AllowSetFileConfiguration DWORD 0 oder 1 : <come nella voce precedente> 1 AllowSetLoggerConfiguration DWORD 0 oder 1 : <come nella voce precedente> 1 AllowSetSchedConfiguration DWORD DWORD 0 oder 1 : <come nella voce precedente> 1 AllowSetTargetConfiguration DWORD 0 oder 1 : <come nella voce precedente> 1 CallBuffersize DWORD Dimensione del buffer per le chiamate di funzione asincrone (tutte le chiamate di funzione eseguite da Windows (ad esempio, servizi file o funzioni socket). Più chiamate simultanee richiede un'applicazione, maggiore dovrebbe essere questo buffer per motivi di prestazioni. 65536 CfgFile STRING Questo valore punta direttamente al file di configurazione di CODESYS Control RTE . <percorso di installazione di CODESYS Control RTE > DisablePlcAutoStart DWORD Questo valore viene utilizzato internamente dal Configurazione PLC dialogo. Questa variabile può essere modificata manualmente, ad esempio, solo se la finestra di configurazione si arresta in modo anomalo e la variabile non scrive più 0 automaticamente. 0 ShowAppConfiguration DWORD 0 o 1 : determina se l'utente può visualizzare il Applicazione scheda nel Configurazione PLC dialogo. 1 ShowCMConfiguration DWORD 0 oder 1 : <come nella voce precedente> 1 ShowFileConfiguration DWORD 0 oder 1 : <come nella voce precedente> 1 ShowLoggerConfiguration DWORD 0 oder 1 : <come nella voce precedente> 1 ShowSchedConfiguration DWORD 0 oder 1 : <come nella voce precedente> 1 ShowTargetConfiguration DWORD 0 oder 1 : <come nella voce precedente> 1 LastExit DWORD 0 o 1 per controllare se l'ultima uscita dalla RTE è andata a buon fine. 1 Path STRING Questo valore punta alla directory che è il percorso principale del file system di CODESYS Control RTE . <percorso di installazione di CODESYS Control RTE > SysTrayLocalPort DWORD Porta TCP\/IP dove avviene localmente la comunicazione tra \"SysTray\" e il servizio di sistema di CODESYS Control RTE . 15965 SysTrayRemoteAddr DWORD DWORD Indirizzo IP del sistema remoto che deve essere gestito con il \"SysTray\" di CODESYS Control RTE . 0 SysTrayRemotePort DWORD Uguale a SysTrayLocalPort ; per il sistema remoto. 15965 SysTrayUseRemotePLC DWORD 0 o 1 : Determina se il PC locale o a CODESYS Control RTE su un altro PC (sistema remoto). 0 KernelVersion STRING Versione di CODESYS Control RTE che è stato avviato l'ultima volta su questo PC. Scritto ogni volta il CODESYS Control RTE inizia. <ID versione> VersionSrv STRING Versione del servizio di sistema di CODESYS Control RTE . Dovrebbe essere sempre la stessa versione del kernel, ad eccezione delle patch manuali per le quali il kernel o il servizio di sistema sono stati sostituiti manualmente da un'altra versione a scopo di test. <ID versione> IO Driverpool KEY Tutte le sottochiavi in questa chiave vengono visualizzate nella casella di riepilogo dei componenti disponibili in Configurazione PLC dialogo. StackSizePerTask DWORD Dimensioni dello stack per ogni attività quando necessario (arresto anomalo inspiegabile per chiamate di funzioni complesse). 0x6000 (24 KB) CreateBluescreenOnFirstException DWORD La prima eccezione che si verifica dovrebbe generare una schermata blu della morte (e quindi un core dump utilizzato a fini diagnostici. Memoria del kernel dovrebbe essere selezionato nelle impostazioni di sistema di Windows per Avvia e ripristina . 0 Per ulteriori informazioni, vedere: Configurazione del comportamento in tempo reale su piattaforme speciali " }, 
{ "title" : "Ottimizzazione delle prestazioni ", 
"url" : "_rtsl_performance_realtime_windows.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ Ottimizzazione delle prestazioni ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comportamento \"soft in tempo reale\" di CODESYS Control Win ", 
"url" : "_rtsl_performance_realtime_windows.html#UUID-260b1b52-f206-9ca7-1cd0-920e224c4997_section-idm43415804467536", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Configura ed estendi \/ Ottimizzazione delle prestazioni \/ Comportamento \"soft in tempo reale\" di CODESYS Control Win ", 
"snippet" : "IL CODESYS Control Win viene gestito come un processo \"in tempo reale\" su Windows, ma ciò non equivale ai rigidi requisiti di tempo reale di un PLC. Latenza e tempi di jitter rientrano nell'intervallo di diversi millisecondi. In casi eccezionali possono essere anche diversi 10 millisecondi. Questo r...", 
"body" : "IL CODESYS Control Win viene gestito come un processo \"in tempo reale\" su Windows, ma ciò non equivale ai rigidi requisiti di tempo reale di un PLC. Latenza e tempi di jitter rientrano nell'intervallo di diversi millisecondi. In casi eccezionali possono essere anche diversi 10 millisecondi. Questo ritardo dipende da molti fattori, come il carico del kernel di Windows, il carico della rete, l'uso di driver sfavorevoli o obsoleti e le prestazioni del computer. Questi ritardi rendono il CODESYS Control Win inadatto per le tipiche applicazioni Motion. In generale, i requisiti dell'applicazione reale devono essere convalidati rispetto alle capacità e ai limiti dell'applicazione CODESYS Control Win sul PC specifico. A causa delle numerose condizioni al contorno, non è possibile fornire un'indicazione generale sui tempi massimi di jitter previsti. " }, 
{ "title" : "Riferimento ", 
"url" : "_rtsl_reference_windows.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Dialoghi ", 
"url" : "_rtsl_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Dialoghi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Finestra di dialogo: Opzioni – Strumento di distribuzione runtime ", 
"url" : "_rtsl_dlg_options_runtime_deploy_tool.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Dialoghi \/ Finestra di dialogo: Opzioni – Strumento di distribuzione runtime ", 
"snippet" : "Simbolo: Funzione : La finestra di dialogo consente di accedere al file system del sistema di sviluppo per gestire la chiave privata SSH. Chiamata : Strumenti → Opzioni menù, Strumento di distribuzione runtime categoria Requisiti : La finestra di dialogo è disponibile solo se almeno una CODESYS Il p...", 
"body" : "Simbolo: Funzione : La finestra di dialogo consente di accedere al file system del sistema di sviluppo per gestire la chiave privata SSH. Chiamata : Strumenti → Opzioni menù, Strumento di distribuzione runtime categoria Requisiti : La finestra di dialogo è disponibile solo se almeno una CODESYS Il prodotto SL è stato installato. In Strumenti → Gestore pacchetti , puoi vedere quali prodotti sono installati. chiave SSH Chiave Nome del file OPENSSH che funge da chiave privata Esempio: serviceuser.openssh Nota: vengono visualizzati solo i file chiave di cui è stata verificata la correttezza. Sentiero Posizione della chiave SSH Esempio: D:\\PLCs\\Keys\\serviceuser.openssh Aggiungere Apre una finestra di dialogo per la gestione dei file Lì si seleziona il file della chiave con la chiave privata (file OPENSH). Il file è collegato al Strumento di distribuzione runtime . Suggerimento: salva la chiave privata sul computer di sviluppo in una posizione adatta o segreta. Nota: non condividere mai la chiave privata. Rimuovere Rimuove il collegamento al file chiave selezionato ok Accetta le impostazioni e chiude la finestra di dialogo Annulla Chiude la finestra di dialogo " }, 
{ "title" : "Finestra di dialogo: Configurazione del sistema – Diagnostica ", 
"url" : "_rtsl_dlg_system_config_diagnosis.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Dialoghi \/ Finestra di dialogo: Configurazione del sistema – Diagnostica ", 
"snippet" : "Chiamata : CODESYS Control RTE menu nella barra di stato Il Configurazione di sistema si apre la finestra di dialogo con la prima Diagnostico scheda. Contiene informazioni su vari stati e ID del controller....", 
"body" : "Chiamata : CODESYS Control RTE menu nella barra di stato Il Configurazione di sistema si apre la finestra di dialogo con la prima Diagnostico scheda. Contiene informazioni su vari stati e ID del controller. " }, 
{ "title" : "Finestra di dialogo: Configurazione del sistema – Destinazione ", 
"url" : "_rtsl_dlg_system_config_target.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Dialoghi \/ Finestra di dialogo: Configurazione del sistema – Destinazione ", 
"snippet" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il Obbiettivo scheda Un nome fisso per l'installazione CODESYS Control RTE può essere specificato in Nome di destinazione . Per impostazione predefinita, il PLC riporta con il nome del computer su cui è in esecuzione....", 
"body" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il Obbiettivo scheda Un nome fisso per l'installazione CODESYS Control RTE può essere specificato in Nome di destinazione . Per impostazione predefinita, il PLC riporta con il nome del computer su cui è in esecuzione. " }, 
{ "title" : "Finestra di dialogo: Configurazione del sistema – File ", 
"url" : "_rtsl_dlg_system_config_file.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Dialoghi \/ Finestra di dialogo: Configurazione del sistema – File ", 
"snippet" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il File scheda Posizioni predefinite per diversi tipi di file su CODESYS Control RTE può essere configurato qui. File Percorso file relativo Percorso relativo per la directory di lavoro dell'RTE ( C:\\ProgramData\\CODESYS\\CODESYSControlRT...", 
"body" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il File scheda Posizioni predefinite per diversi tipi di file su CODESYS Control RTE può essere configurato qui. File Percorso file relativo Percorso relativo per la directory di lavoro dell'RTE ( C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 ). File da archiviare in questo percorso file (ad es. *.app, *.crc) Tipi di file che devono essere salvati nel percorso del file. Elenco separato da virgole (esempio: *.app, *.crc ) " }, 
{ "title" : "Finestra di dialogo: Configurazione del sistema – Utilità di pianificazione ", 
"url" : "_rtsl_dlg_system_config_scheduler.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Dialoghi \/ Finestra di dialogo: Configurazione del sistema – Utilità di pianificazione ", 
"snippet" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il Programmatore scheda Le impostazioni si trovano qui per l'utilità di pianificazione del sistema di runtime. Influiscono sul modo in cui viene eseguito il monitoraggio del carico e sul comportamento in caso di violazione del valore li...", 
"body" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il Programmatore scheda Le impostazioni si trovano qui per l'utilità di pianificazione del sistema di runtime. Influiscono sul modo in cui viene eseguito il monitoraggio del carico e sul comportamento in caso di violazione del valore limite. Una modifica di queste impostazioni è necessaria solo per esigenze speciali. Carico del processore Massimo carico del processore Limitazione del carico del sistema A partire da questo carico della CPU, viene generata un'eccezione o viene avviata la suddivisione del tempo. La modifica di questa impostazione può causare un guasto (eccezione) del controller. Per ulteriori informazioni, vedere: CODESYS Control V3 Documentazione del sistema di runtime " }, 
{ "title" : "Finestra di dialogo: Configurazione del sistema – Logger ", 
"url" : "_rtsl_dlg_system_config_logger.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Dialoghi \/ Finestra di dialogo: Configurazione del sistema – Logger ", 
"snippet" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il Registratore scheda Qui si trovano le impostazioni per salvare i messaggi di registro dal PLC in uno o più file. Registratore standard Abilitare : Un'applicazione di avvio viene generata implicitamente al download, ma il progetto non...", 
"body" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il Registratore scheda Qui si trovano le impostazioni per salvare i messaggi di registro dal PLC in uno o più file. Registratore standard Abilitare : Un'applicazione di avvio viene generata implicitamente al download, ma il progetto non viene scaricato in memoria. File di backend Abilitare : : Uno o più file con i messaggi di registro vengono creati nella directory di lavoro ( C:\\ProgramData\\CODESYS\\CODESYSControlRTE ). Se necessario, il file più vecchio viene sovrascritto. Massimo File : Numero massimo di file. 0 significa che nessun file viene sovrascritto e tutte le voci di registro vengono archiviate. Massimo dimensione dei file : Dimensione massima di un file. Massimo inserimenti : Numero massimo di voci di registro in un file. Per ulteriori informazioni, vedere: Scheda: Registro " }, 
{ "title" : "Finestra di dialogo: Configurazione del sistema – Applicazione ", 
"url" : "_rtsl_dlg_system_config_application.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Dialoghi \/ Finestra di dialogo: Configurazione del sistema – Applicazione ", 
"snippet" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il Applicazione scheda Qui vengono effettuate le impostazioni per il componente dell'applicazione del PLC. Applicazioni di avvio Crea al download : Un'applicazione di avvio viene generata implicitamente al download. Memorizza solo su Do...", 
"body" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il Applicazione scheda Qui vengono effettuate le impostazioni per il componente dell'applicazione del PLC. Applicazioni di avvio Crea al download : Un'applicazione di avvio viene generata implicitamente al download. Memorizza solo su Download : Un'applicazione di avvio viene generata implicitamente al download, ma il progetto non viene scaricato in memoria. (Solo per applicazioni speciali) Comportamento in caso di Mantenimento mancata corrispondenza Opzioni per il comportamento del PLC in caso di Retain Data corrotti: Non caricare : L'applicazione di avvio non è stata caricata. Carica con eccezione : l'applicazione di avvio viene caricata, ma non avviata. Viene generata un'eccezione. Carica e inizializza conserva : L'applicazione di avvio viene caricata e inizializzata come dopo un download. Invalida le applicazioni di avvio Opzioni relative all'annullamento dell'applicazione di avvio se il controller non viene chiuso correttamente: Mai : L'applicazione di avvio non viene mai invalidata. IMPOSTANDO : L'applicazione di avvio è dichiarata non valida nel file di configurazione del PLC ( *.cfg ). Per rinominare : Il *.app il file dell'applicazione di avvio viene rinominato, il che rende l'applicazione di avvio non valida. Mantieni tipo Opzioni per salvare i file di conservazione su CODESYS Control RTE : Nessuno : I dati non vengono salvati e il PLC non può utilizzare alcun dato di conservazione. SRAM : Il PLC può utilizzare la memoria fisica non volatile per i dati ritentivi. In mancanza di alimentazione : i dati ritentivi vengono salvati in un file quando il controller viene spento. A tal fine, il sistema deve essere dotato di un UPS. Quindi vengono coperte anche le interruzioni di corrente. Forza persistente Se abilitati, i valori forzati vengono mantenuti anche dopo il riavvio del controller. Per ulteriori informazioni, vedere: Creazione di un'applicazione di avvio " }, 
{ "title" : "Finestra di dialogo: Configurazione del sistema – Gestore componenti ", 
"url" : "_rtsl_dlg_system_config_component_manager.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Dialoghi \/ Finestra di dialogo: Configurazione del sistema – Gestore componenti ", 
"snippet" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il Responsabile dei componenti scheda Qui vengono gestiti componenti aggiuntivi che non vengono caricati dal PLC per impostazione predefinita. Per ulteriori informazioni, vedere quanto segue: Componenti dinamici disponibiliGestore compo...", 
"body" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il Responsabile dei componenti scheda Qui vengono gestiti componenti aggiuntivi che non vengono caricati dal PLC per impostazione predefinita. Per ulteriori informazioni, vedere quanto segue: Componenti dinamici disponibiliGestore componenti Percorso di configurazione del PLC Percorso radice del file system del PLC. Esempio: C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 Componenti aggiuntivi I componenti che non vengono scaricati dal PLC per impostazione predefinita possono essere inseriti\/selezionati qui. " }, 
{ "title" : "Finestra di dialogo: Configurazione del sistema – Avvio ", 
"url" : "_rtsl_dlg_system_config_startup.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Dialoghi \/ Finestra di dialogo: Configurazione del sistema – Avvio ", 
"snippet" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il Avviare scheda Seleziona una delle opzioni per avviare il CODESYS Control RTE : Avviare Avviare il servizio di sistema di base RTE all'avvio Il servizio di sistema (nome visualizzato \" 3S RTE Service V3 \") viene avviato automaticamen...", 
"body" : "Chiamata: CODESYS Control RTE menu nella barra di stato, quindi il Avviare scheda Seleziona una delle opzioni per avviare il CODESYS Control RTE : Avviare Avviare il servizio di sistema di base RTE all'avvio Il servizio di sistema (nome visualizzato \" 3S RTE Service V3 \") viene avviato automaticamente all'avvio del sistema. In questo modo, il servizio è disponibile prima dell'accesso dell'utente. Avviare il PLC con il servizio di base del sistema Il PLC viene avviato all'avvio dei servizi di sistema. Insieme alla prima opzione, il PLC viene avviato subito dopo l'avvio del PC. Non caricare le applicazioni di avvio Anche il PLC non carica la sua applicazione di avvio per un avvio automatico. " }, 
{ "title" : "Comandi ", 
"url" : "_rtsl_commands.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Comandi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Menu nella barra delle applicazioni ", 
"url" : "_rtsl_cmd_menu.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Comandi \/ Menu nella barra delle applicazioni ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Control ", 
"url" : "_rtsl_cmd_menu.html#UUID-dc0920ec-91e3-5d46-7959-a04fb4357af3_section-idm4616768769337633167655660684", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Comandi \/ Menu nella barra delle applicazioni \/ CODESYS Control ", 
"snippet" : "Accesso all'interfaccia utente di CODESYS Control Win ti viene concesso per mezzo del simbolo nella barra delle applicazioni (\"Systray\") del PC. Fare clic con il pulsante destro del mouse su simbolo per aprire un menu con i seguenti comandi: Avvia PLC : Accende il PLC. Il simbolo nella barra di stat...", 
"body" : "Accesso all'interfaccia utente di CODESYS Control Win ti viene concesso per mezzo del simbolo nella barra delle applicazioni (\"Systray\") del PC. Fare clic con il pulsante destro del mouse su simbolo per aprire un menu con i seguenti comandi: Avvia PLC : Accende il PLC. Il simbolo nella barra di stato cambia in . Nota: se il PLC deve essere acceso automaticamente all'avvio del sistema, è necessario impostare l'opzione di avvio corrispondente nelle proprietà del servizio. Per ulteriori informazioni, consultare la pagina della guida \"Installazione e avviamento\". Arrestare PLC : Spegne il PLC. Il simbolo cambia in . Uscire dal controllo PLC : termina la disponibilità del menu utente nella barra delle applicazioni. Il simbolo viene rimosso, ma il PLC continua a funzionare. Il file eseguibile responsabile della visualizzazione della barra delle applicazioni è CODESYSControlSysTray.exe . Si trova nella directory di installazione nella sottodirectory GatewayPLC di CODESYS Control Win . Di : mostra le informazioni sulla versione del file installato CODESYS Control Win " }, 
{ "title" : "CODESYS Control RTE ", 
"url" : "_rtsl_cmd_menu.html#UUID-dc0920ec-91e3-5d46-7959-a04fb4357af3_section-idm4544772591294433167656742159", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Comandi \/ Menu nella barra delle applicazioni \/ CODESYS Control RTE ", 
"snippet" : "Accesso all'interfaccia utente di CODESYS Control RTE ti viene concesso tramite il simbolo presente nella system tray (\"Systray\") del tuo PC. Fare clic con il pulsante destro del mouse su simbolo per aprire un menu con i seguenti comandi: Avvia PLC : Accende il PLC. Il simbolo cambia in . Arrestare ...", 
"body" : "Accesso all'interfaccia utente di CODESYS Control RTE ti viene concesso tramite il simbolo presente nella system tray (\"Systray\") del tuo PC. Fare clic con il pulsante destro del mouse su simbolo per aprire un menu con i seguenti comandi: Avvia PLC : Accende il PLC. Il simbolo cambia in . Arrestare PLC : Spegne il PLC. Il simbolo cambia in . Uscire dal controllo PLC : Controllo del CODESYS Control RTE tramite la barra delle applicazioni non è più possibile. Il simbolo viene rimosso, ma il PLC continua a funzionare. Configurazione PLC : Apre il Configurazione di sistema dialogo. Diverse schede includono informazioni diagnostiche e le impostazioni di configurazione di CODESYS Control RTE . PLC remoto : Apre il Configurazione remota dialogo. Abilitando o disabilitando il Controlla il PC remoto, non locale opzione, si determina se viene utilizzato un PLC che si trova su un PC remoto o locale. Di conseguenza, i comandi del menu Avvia PLC , Arrestare PLC , e Configurazione PLC fare riferimento al PC locale o ad un PC raggiunto in rete. Per il PC remoto, specificare il file Indirizzo del PC di destinazione , Numero di porta , e un Tempo scaduto valore (in ms) per la connessione ( Timeout remoto [ms] ). Di : mostra le informazioni sulla versione del file installato CODESYS Control RTE " }, 
{ "title" : "Comando: Aggiorna Edge Gateway ", 
"url" : "_rtsl_cmd_update_edge_gateway.html", 
"breadcrumbs" : "CODESYS Control \/ Sistemi runtime basati su Windows \/ Riferimento \/ Comandi \/ Comando: Aggiorna Edge Gateway ", 
"snippet" : "Funzione : Il comando apre il Gateway perimetrale Visualizza. Nella vista è possibile installare, avviare e interrompere il pacchetto Edge Gateway (file DEB). Inoltre, sono fornite funzionalità a livello di sistema e di runtime che supportano l'utente durante la messa in servizio e lo sviluppo dell'...", 
"body" : "Funzione : Il comando apre il Gateway perimetrale Visualizza. Nella vista è possibile installare, avviare e interrompere il pacchetto Edge Gateway (file DEB). Inoltre, sono fornite funzionalità a livello di sistema e di runtime che supportano l'utente durante la messa in servizio e lo sviluppo dell'applicazione. Chiamata : Utensili menù Credenziali di accesso Nome utente Nome utente e password del computer Linux Parola d'ordine Seleziona destinazione indirizzo IP Indirizzo IP o nome del dispositivo di destinazione Esempio: 192.168.99.39 Scansione Apre il Scansione Edge Gateway dialogo Tutti i dispositivi attualmente collegati alla rete e corrispondenti al tipo di dispositivo sono elencati qui con gli indirizzi IP e il rispettivo indirizzo MAC (tra parentesi). Il tipo di dispositivo è identificato dall'indirizzo MAC. Esempio: 192.168.123.123(BB:27:EB:FA:98:52) CODESYS Edge Gateway for Linux Pacchetto Versione Versione e architettura dell'Edge Gateway da installare Esempio: V3.5.15.0 (amd64) Installare Avvia l'operazione di installazione per il pacchetto Edge Gateway nella versione e nell'architettura impostate. Rimuovere Rimuove l'installazione attualmente in corso Linux dispositivo Quindi puoi installare qualsiasi versione. Directory del pacchetto Cartella in cui i pacchetti Edge Gateway ( *.deb ) si trovano. Pacchetti aggiuntivi Installare Installa pacchetti Linux aggiuntivi sul PLC o aggiorna i pacchetti esistenti Esempio: pacchetto runtime Wibu CodeMeter. È possibile scaricare il pacchetto dalla homepage di Wibu Systems e utilizzare questo comando per installarlo o aggiornarlo sul PLC. Maneggio Apre una finestra di dialogo che mostra tutti i pacchetti installati con informazioni aggiuntive È possibile disinstallare singoli pacchetti in questa finestra di dialogo. Sistema Informazioni di sistema Apre il Informazioni di sistema <nome utente>@indirizzo IP dialogo Esempio: Informazioni di sistema root@192.168.123.123 Riavvia la destinazione Riavvia il sistema sul PLC Edge Gateway Inizio Avvia l'Edge Gateway Fermare Arresta l'Edge Gateway " }
]
$(document).trigger('search.ready');
});