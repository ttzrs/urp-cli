$(document).ready(function () {indexDict['it'] = [{ "title" : "CODESYS String Libraries ", 
"url" : "_strlib_start_page.html", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Introduzione ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4664735744121633736389596078", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Introduzione ", 
"snippet" : "Le biblioteche del CODESYS String Libraries pacchetto pu√≤ essere utilizzato per elaborare stringhe codificate in UTF-8. La base √® IString interfaccia da String Segments libreria. Utilizzando questa interfaccia, le stringhe possono essere passate alle rispettive funzioni per riferimento. Ad esempio, ...", 
"body" : "Le biblioteche del CODESYS String Libraries pacchetto pu√≤ essere utilizzato per elaborare stringhe codificate in UTF-8. La base √® IString interfaccia da String Segments libreria. Utilizzando questa interfaccia, le stringhe possono essere passate alle rispettive funzioni per riferimento. Ad esempio, per creare un IString istanza, il GSB.UTF8String blocco funzione del Generic String Base viene fornita la libreria. Le seguenti librerie sono fornite con il pacchetto: String Segments Funzioni base per IString istanze Documentazione della libreria String Segments String Builder Gestione efficiente dei segmenti di stringa con codifica UTF-8 Documentazione della libreria String Buil String Conversions Conversione di stringhe con codifica diversa da\/verso UTF-8 Documentazione della libreria String Conversions String Functions Funzioni per l'elaborazione di stringhe codificate UTF-8 seguendo l'esempio della libreria standard convenzionale. Documentazione della libreria String Functions Unicode Support Funzioni per l'elaborazione di categorie di caratteri Unicode. Documentazione della libreria delle funzioni di supporto Unicode UTF-16 Encoding Support Funzione base per la gestione delle aree di memoria codificate UTF-16 Documentazione della libreria di supporto alla codifica UTF-16 UTF-8 Encoding Support Funzione base per la gestione delle aree di memoria codificate UTF-8 Documentazione della libreria delle funzioni di supporto alla codifica UTF-8 Generic String Base Blocchi funzionali per l'elaborazione di stringhe codificate UTF-8 che gestiscono la loro memoria staticamente tramite GENERIC CONSTANT . Documentazione generica della libreria String Base Functions " }, 
{ "title" : "Vantaggi delle nuove librerie di stringhe ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4563869800648033733012917566", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Vantaggi delle nuove librerie di stringhe ", 
"snippet" : "Le nuove librerie di stringhe non sostituiscono le vecchie e familiari funzioni di stringa di Standard e Standard64 librerie. Tuttavia, consigliamo di utilizzare le nuove librerie di stringhe per nuovi progetti. Le nuove librerie di stringhe possono anche gestire stringhe di grandi dimensioni in mod...", 
"body" : "Le nuove librerie di stringhe non sostituiscono le vecchie e familiari funzioni di stringa di Standard e Standard64 librerie. Tuttavia, consigliamo di utilizzare le nuove librerie di stringhe per nuovi progetti. Le nuove librerie di stringhe possono anche gestire stringhe di grandi dimensioni in modo efficiente. La lunghezza delle stringhe √® quasi illimitata. Per questo motivo, le librerie sono adatte anche per modificare file di testo e contenuti web di grandi dimensioni Altri vantaggi: UTF-8 √® una codifica che pu√≤ rappresentare l'intera gamma di caratteri secondo UNICODE. UTF-8 √® ampiamente utilizzato su Internet ed √® raccomandato dal World Wide Web Consortium (W3C). UTF-8 √® compatibile con i sistemi precedenti grazie alla compatibilit√† ASCII. UTF-8 offre un elevato livello di interoperabilit√†. UTF-8 funziona per ottimizzare la memoria. Le nuove librerie di stringhe consentono di interrogare una stringa definita in precedenza tramite i metodi corrispondenti, proprio come la si conosce in altri linguaggi di alto livello. Esempio di metodo stringa: Len() udiStringLen := myString.Len();\nif¬†udiStringLen =¬†22¬†THEN\n... A partire da CODESYS 3.5.18.0, √® possibile impostare il compilatore per interpretare il contenuto delle variabili di tipo STRING come codifica UTF-8. Si seleziona il Codifica UTF8 per STRING opzione in Impostazioni del progetto nel Opzioni di compilazione categoria. Se non vuoi trattare tutto STRING variabili in un progetto con codifica UTF-8, quindi √® necessario deselezionare questa opzione. Dopodich√©, puoi applicare la codifica UTF-8 STRING digitare caso per caso. Codifica UTF-8 per i valori letterali {attribute¬†'monitoring_encoding'¬†:=¬†'UTF-8'}\nsValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë'; Grazie alle funzionalit√† della codifica UTF-8, non √® necessario utilizzare WSTRING tipo di dati in CODESYS per utilizzare un set di caratteri esteso. codifica UCS-2 WSTRING √® basato su, pu√≤ richiedere pi√π memoria rispetto a una codifica UTF-8, a seconda dell'applicazione. La codifica UCS-2 WORD per carattere e pu√≤ rappresentare solo i personaggi U+0000 a U+D800 e U+DFFF a U+FFFD . La codifica UTF-8 richiede da uno a quattro byte per carattere. Di conseguenza, tutti i caratteri Unicode Con la codifica UTF-8, se si tenta di ottenere un carattere specifico utilizzando un indice specifico, ci√≤ porter√† a risultati imprevisti a causa della lunghezza variabile. Codifica di lunghezza variabile {attribute 'monitoring_encoding' := 'UTF-8'}\nsValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë';\n\nbyValue := sValue[13];¬†\/\/ The 'u' is NOT the 13th character in the string\nxOk := byValue <>¬†16#75; √à necessario determinare l'indice di un carattere iterando la stringa. Iterazione su stringhe codificate UTF-8 VAR\t\n {attribute 'monitoring_encoding' := 'UTF-8'}\n sValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë';\n\n fbsValue : STR.UTF8Literal := (psValue:=ADR(sValue)); \n fbRange : STR.Range := (itfString:=fbsValue);\n diRune : STR.RUNE;\n udiIndex, udiLength : UDINT;\n xOk : BOOL;\nEND_VAR\n \nWHILE (diRune := fbRange.GetNextRune(udiLength=>udiLength)) <> 0 DO\n IF diRune = 16#75 (* 'u' *) THEN\n EXIT;\n END_IF\n udiIndex := udiIndex + udiLength;\nEND_WHILE\n \nxOk := sValue[udiIndex] = 16#75 (* 'u' *); " }, 
{ "title" : "Svantaggi del consolidato STRING funzioni ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4613761597678433733013344138", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Svantaggi del consolidato STRING funzioni ", 
"snippet" : "Nel precedentemente stabilito STRING funzioni della libreria standard, i parametri di tipo STRING vengono copiati quando vengono passati alle funzioni. Il valore restituito viene inoltre copiato in una variabile con l' Problemi con le funzioni STRING stabilite VAR sValue : STRING; END_VAR sValue := ...", 
"body" : "Nel precedentemente stabilito STRING funzioni della libreria standard, i parametri di tipo STRING vengono copiati quando vengono passati alle funzioni. Il valore restituito viene inoltre copiato in una variabile con l' Problemi con le funzioni STRING stabilite VAR\n sValue : STRING;\nEND_VAR\n \nsValue := CONCAT(CONCAT(CONCAT('Da steh ich nun,', ' ich armer Tor!'), ' Und bin so'), ' klug als wie zu vor');\n\/\/ -> Copy, LEN -> Copy, LEN -> Copy, LEN -> Copy, LEN\n\/\/ -> 2xCopy, LEN\n\/\/ -> 2xCopy, LEN\n\/\/ -> 2xCopy, LEN Prima di elaborare i parametri di tipo STRING nelle rispettive funzioni, le loro lunghezze devono spesso essere determinate mediante iterazione fino al carattere nullo di terminazione. Per stringhe pi√π lunghe, queste operazioni di copia e iterazione aumentano il tempo di elaborazione dell'applicazione. La lunghezza delle stringhe √® limitata a 255 caratteri per l'applicazione di " }, 
{ "title" : "Usando il IString interfaccia ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4598276788502433733013693363", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Usando il IString interfaccia ", 
"snippet" : "Le STR.IString l'interfaccia √® stata introdotta per passare la struttura dati che gestisce le informazioni su una stringa per riferimento. Questa √® una grande differenza rispetto alle funzioni STRING precedentemente stabilite, che non implementano STR.IString interfaccia. Inoltre, la dimensione di u...", 
"body" : "Le STR.IString l'interfaccia √® stata introdotta per passare la struttura dati che gestisce le informazioni su una stringa per riferimento. Questa √® una grande differenza rispetto alle funzioni STRING precedentemente stabilite, che non implementano STR.IString interfaccia. Inoltre, la dimensione di una stringa (la rispettiva memoria per i caratteri codificati UTF-8) pu√≤ essere compresa nell'intervallo numerico UDINT 4 ‚â¶ udiSize ‚â¶ 16#FFFF_FF00 ). Nella suddetta struttura dei dati, le seguenti informazioni sono mantenute aggiornate e non devono essere ricalcolate ogni volta prima di una fase di elaborazione: Riferimento al rispettivo segmento di memoria Capacit√† attuale (‚Üí GetSegment ) Lunghezza (‚Üí Len ) in byte Numero di caratteri (‚Üí RuneCount ) Propriet√† di STR.IString VAR\n itfString : STR.IString;\n udiLength, udiSize, udiRuneCount : UDINT;\n pbySegment : POINTER TO BYTE;\n xValid : BOOL;\nEND_VAR\n \nudiLength := itfString.Len(); \/\/ Current length in byte\npbySegment := itfString.GetSegment(udiSize=>udiSize); \/\/ Address first byte, capacity of the segment in bytes\nudiRuneCount := STR.RuneCount(itfString); \/\/ Current number of \"characters\" in the segment\nxValid := itfString.IsValid(); \/\/ Indication that a valid UTF-8 encoding is present. Correlazione: ¬´personaggio¬ª e ¬´runa¬ª Il termine ¬´runa¬ª appare nelle librerie e nel codice sorgente e significa esattamente lo stesso di ¬´punto di codice Unicode¬ª, con un'interessante aggiunta. Le librerie definiscono la parola ¬´rune¬ª come alias per il tipo DINT . Di conseguenza, l'utente pu√≤ vedere chiaramente quando un valore intero rappresenta un punto di codice. Inoltre, ci√≤ che pu√≤ essere immaginato come una costante di carattere √® chiamata costante runica Esempio: il tipo e il valore dell'espressione WSTRING#\"‚åò\" √® una runa con valore intero DINT#16#2318 . " }, 
{ "title" : "Informazioni per esperti ", 
"url" : "_strlib_expert_information.html", 
"breadcrumbs" : "CODESYS String Libraries \/ Informazioni per esperti ", 
"snippet" : "Nel CODESYS versioni precedenti alla 3.5.18.0, non √® possibile utilizzare variabili di tipo codificate UTF-8 STRING e il Generic String Base libreria. Questo √® possibile solo nella versione 3.5.19.50 e successive. Puoi comunque utilizzare le altre librerie CODESYS String Libraries pacchetto. Tuttavi...", 
"body" : "Nel CODESYS versioni precedenti alla 3.5.18.0, non √® possibile utilizzare variabili di tipo codificate UTF-8 STRING e il Generic String Base libreria. Questo √® possibile solo nella versione 3.5.19.50 e successive. Puoi comunque utilizzare le altre librerie CODESYS String Libraries pacchetto. Tuttavia, la gestione delle aree di memoria codificate UTF-8 (ad esempio ARRAY OF BYTE ) √® un po' pi√π complicato l√¨. PRIMA DELLA SP18 VAR\n abyValue : ARRAY[0..33] OF BYTE := [ \/\/ UTF-8 C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl\n 16#43, 16#C3, 16#98, 16#44, 16#E2, 16#82, 16#AC, 16#C5, 16#A1, 16#C5, 16#B8,\n 16#C5, 16#A0, 16#20, 16#C3, 16#AF, 16#C3, 16#9F, 16#20, 16#76, 16#C3, 16#A4,\n 16#72, 16#C3, 16#BF, 16#20, 16#C3, 16#A7, 16#C3, 16#B4, 16#C3, 16#B5, 16#6C, 0\n ];\n myString : STR.UTF8Literal := (psValue:=ADR(abyValue));\nEND_VAR Non appena variabili di tipo codificate in UTF-8 STRING sono disponibili, l'esempio precedente √® ancora pi√π semplificato: VAR\n myString : STR.UTF8Literal := (psValue:=ADR(UTF8#'C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl'));\nEND_VAR " }, 
{ "title" : "Conversione da STRING a IString ", 
"url" : "_strlib_expert_information.html#UUID-ab7f59ef-3fd1-9368-2073-8d15fffc313a_section-idm4670931916384033733014074571", 
"breadcrumbs" : "CODESYS String Libraries \/ Informazioni per esperti \/ Conversione da STRING a IString ", 
"snippet" : "La struttura dati per la gestione delle propriet√† di un segmento di stringa √® implementata tramite STR._UTF8String blocco funzionale. Per fare ci√≤, √® necessario allocare memoria per un'istanza di questo blocco funzione e per il segmento di stringa stesso. Un'istanza del blocco funzione deve trovarsi...", 
"body" : "La struttura dati per la gestione delle propriet√† di un segmento di stringa √® implementata tramite STR._UTF8String blocco funzionale. Per fare ci√≤, √® necessario allocare memoria per un'istanza di questo blocco funzione e per il segmento di stringa stesso. Un'istanza del blocco funzione deve trovarsi in un'area di memoria allineata a un __XWORD address . Conversione da String a IString VAR CONSTANT\n c_udiLength : UDINT := MAX(4, 512); \/\/ String segment capacity including terminal NULL\n c_udiXWORD : UDINT := SIZEOF(__XWORD);\n¬† ¬†¬†c_udiMaxIndex : UDINT := (SIZEOF(STR._UTF8String) + c_udiLength +¬† c_udiXWORD¬† -¬†1) \/ c_udiXWORD;\nEND_VAR\n \nVAR\n abyValue : ARRAY[0..33] OF BYTE := [ \/\/ UTF-8 C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl\n 16#43, 16#C3, 16#98, 16#44, 16#E2, 16#82, 16#AC, 16#C5, 16#A1, 16#C5, 16#B8,\n 16#C5, 16#A0, 16#20, 16#C3, 16#AF, 16#C3, 16#9F, 16#20, 16#76, 16#C3, 16#A4,\n 16#72, 16#C3, 16#BF, 16#20, 16#C3, 16#A7, 16#C3, 16#B4, 16#C3, 16#B5, 16#6C, 0\n\t];\n axwMemory : ARRAY[0..c_udiMaxIndex] OF __XWORD;\n udiSize : UDINT;\n itfString : STR.IString := STR.CreateString(\n ADR(axwMemory), SIZEOF(axwMemory),\n ADR(abyValue),\n udiStrSize=>udiSize\n );\n xOk : BOOL;\nEND_VAR\n \nxOk := (\n udiSize >= 512 AND\n itfString.Len() = 33 AND\n STR.RuneCount(itfString) = 20 AND\n itfString.IsValid() AND\n NOT itfString.IsASCII()\n); Con l'aiuto di Generic String Base libreria, molti di questi requisiti vengono presi in considerazione dai blocchi funzione corrispondenti e, di conseguenza, sollevano l'utente da molte attivit√†. Soprattutto, la corretta prenotazione e allineamento della memoria sono incapsulati nei " }, 
{ "title" : "Esempi ", 
"url" : "_strlib_examples.html", 
"breadcrumbs" : "CODESYS String Libraries \/ Esempi ", 
"snippet" : "Le Generic String Base la libreria viene fornita per rendere l'elaborazione delle stringhe il pi√π semplice possibile. Tuttavia, utilizza VAR_GENERIC CONSTANT funzionalit√† del compilatore e pu√≤ quindi essere utilizzata solo a partire da CODESYS V3.5 SP19 Patch 5....", 
"body" : "Le Generic String Base la libreria viene fornita per rendere l'elaborazione delle stringhe il pi√π semplice possibile. Tuttavia, utilizza VAR_GENERIC CONSTANT funzionalit√† del compilatore e pu√≤ quindi essere utilizzata solo a partire da CODESYS V3.5 SP19 Patch 5. " }, 
{ "title" : "Biblioteca: Generic String Base ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4598276773272033733014529891", 
"breadcrumbs" : "CODESYS String Libraries \/ Esempi \/ Biblioteca: Generic String Base ", 
"snippet" : "Ecco un esempio ( myString ) di un GSB.UTF8String viene creato con una capacit√† di 128 byte e viene inizializzato il segmento di stringa con il valore di una variabile STRING (numero romano 1968). I metodi di STR.IString sono disponibili. Da STRING a IString VAR ¬† ¬†¬†myString : GSB.UTF8String<128> :=...", 
"body" : "Ecco un esempio ( myString ) di un GSB.UTF8String viene creato con una capacit√† di 128 byte e viene inizializzato il segmento di stringa con il valore di una variabile STRING (numero romano 1968). I metodi di STR.IString sono disponibili. Da STRING a IString VAR\n¬† ¬†¬†myString : GSB.UTF8String<128> := (sValue := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß');¬†\/\/ r√∂misch 1968¬†¬†¬†¬†\n psString : POINTER TO STRING;¬†¬†¬†¬†udiSize, udiLength : UDINT;¬† ¬†¬†xASCII, xOk : BOOL;\nEND_VAR\n \n psString := myString.GetSegment(udiSize=>udiSize, udiLength=>udiLength, xASCII=>xASCII);¬†\/\/ Conversion back to the STRING data type\n \nxOk := (\n myString.IsValid() AND \/\/ A valid UTF-8 encoding is present\n udiSize = 128 AND \/\/ The capacity of the string in bytes\n myString.Len() = 17 AND \/\/ The current length of the string in bytes\n STR.RuneCount(myString) = 6 \/\/ The current number of characters in the string\n); Funzione del generatore di stringhe VAR\n myString : GSB.UTF8String<20> := (sValue := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß'); \/\/ roman 1968\n sValue : STRING := 'wurden in Mexico-Stadt die';\n wsValue : WSTRING := \"‚Ö©‚Ö®.\";\n diSpace : STR.RUNE := 32;\n myValue : GSB.UTF8String<128> := (sValue := UTF8#'—∫‚Ñì∆¥ŒºœÅ‚ò§·πß·∏â–ΩŒµŒ∑ $$œÅ—ó‚ÑÆ≈Ç‚ÑØ Œ±‚ô≠‚ÑäŒµ‚ÑåŒ± ü‚ä•‚ÑÆ·æî.');\n \n myBuilder : GSB.Builder<(*udiInitialCapacity*) 64, (*usiExtensionFactor*) 50> := (itfString:=myString);\n myResult : GSB.UTF8String<128>;\n \n {attribute 'monitoring_encoding' := 'UTF-8'}\n sResult : STRING(128) := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß wurden in Mexico-Stadt die ‚Ö©‚Ö®. —∫‚Ñì∆¥ŒºœÅ‚ò§·πß·∏â–ΩŒµŒ∑ $$œÅ—ó‚ÑÆ≈Ç‚ÑØ Œ±‚ô≠‚ÑäŒµ‚ÑåŒ± ü‚ä•‚ÑÆ·æî.';\n \n psResult : POINTER TO STRING;\n udiLength : UDINT;\n xOk : BOOL;\nEND_VAR\n \nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteString(sValue);\nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteWString(wsValue);\nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteIString(myValue);\n \nudiLength := myBuilder.Len(); \/\/ The number of bytes occupied in the builder.\nmyBuilder.ToIString(myResult); \/\/ The individual parts of the string are copied together to myResult.\n \npsResult := myResult.GetSegment(); \nxOk := (psResult^ = sResult); \/\/ Both memory areas should have the same content. Nell'esempio precedente, viene creata un'istanza del builder con una capacit√† iniziale di 64 byte ( udiInitialCapacity ) e un fattore dinamico di 50 ( usiExtensionFactor ). La stringa generata pi√π sopra viene ancora passata nella dichiarazione e, di conseguenza, il builder viene riempito con questa stringa ( UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß' ). Utilizzando il usiExtensionFactor parametro, aumenta il generatore del 50% quando la sua capacit√† attuale √® esaurita. Leggere un file con il generatore VAR\n sPath : STRING := 'myFilePath';\n hFile : RTS_IEC_HANDLE := RTS_INVALID_HANDLE;\n myBuilder : GSB.Builder<(*udiInitialCapacity*) 16#10000, (*usiExtensionFactor*) 50>;\n abyBuffer : ARRAY[0..4095] OF BYTE;\n pbyData : POINTER TO BYTE;\n udiSize : UDINT;\n udiCount : UDINT;\n eEncoding : SCV.ENCODING;\n eErrorID : SCV.ERROR;\n udiResult : RTS_IEC_RESULT;\nEND_VAR\n \nhFile := SysFileOpen(sPath, ACCESS_MODE.AM_READ, ADR(udiResult));\nIF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n RETURN; \nEND_IF\n \nREPEAT \/\/ fake loop - We need the EXIT feature\n pbyData := ADR(abyBuffer);\n udiSize := TO_UDINT(SysFileRead(hFile, pbyData, XSIZEOF(abyBuffer), ADR(udiResult)));\n IF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n EXIT; \n END_IF\n \n \/\/ Determination of the file encoding\n udiCount := SCV.DecodeBOM(pbyData, udiSize, eEncoding=>eEncoding, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n \/\/ handle error condition\n EXIT;\n END_IF\n \n pbyData := pbyData + udiCount;\n udiSize := udiSize - udiCount;\n \n WHILE udiSize > 0 DO\n \/\/ Convert file content to UTF-8 and copy to Builder-Content\n udiCount := myBuilder.WriteMemSegment(pbyData, udiSize, eEncoding, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n \/\/ handle error condition\n EXIT;\n END_IF\n pbyData := ADR(abyBuffer);\n udiSize := TO_UDINT(SysFileRead(hFile, pbyData, XSIZEOF(abyBuffer), ADR(udiResult)));\n IF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n EXIT; \n END_IF\n END_WHILE\nUNTIL TRUE\nEND_REPEAT\n \nIF hFile <> RTS_INVALID_HANDLE THEN\n SysFileClose(hFile);\n hFile := RTS_INVALID_HANDLE;\n udiCount : UDINT;\nEND_IF Analisi del contenuto di un'istanza del generatore VAR\n myRange : SBD.Range := (itfBuilder := myBuilder);\n diRune : STR.RUNE;\n eError : STR.ERROR;\nEND_VAR\n \nmyRange.Reset();\nWHILE (diRune := myRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND_THEN eErrorID = 0 DO\n IF UC.IsSpace(diRune) THEN\n \/\/ The characters in the builder which are considered as spaces according to UNICODE are counted.\n udiCount := udiCount + 1;\n END_IF\nEND_WHILE Per passare contenuti con codifica UTF-8, non √® necessaria alcuna cache per la conversione della codifica perch√© i dati sono gi√† codificati in UTF-8 nel generatore. Pertanto, il contenuto di un segmento di un generatore pu√≤ essere inviato direttamente, ad esempio tramite una Trasporto dei contenuti codificati UTF-8 di un builder sulla rete VAR\n itfConnection : NBS.IConnection;\n pbySegment : POINTER TO BYTE;\n udiSize : UDINT;\n eError : NBS.ERROR;\nEND_VAR\n \n(* Provide an active itfConnection *)\n \npbySegment:= myBuilder.GetFirstSegment(udiSize=>udiSize, eErrorID=>eErrorID);\nWHILE pbySegment <> 0 AND eErrorID = 0 DO\n eError := itfConnection.Write(pbySegment, udiSize, udiCount=>udiCount);\n IF eError <> 0 OR udiCount <> udiSize THEN\n \/\/ Handle Error\n EXIT;\n END_IF\n pbySegment := myBuilder.GetNextSegment(pbySegment, udiSize=>udiSize, eErrorID=>eErrorID);\nEND_WHILE\n \n(* e.g. Close itfConnection *) " }, 
{ "title" : "Lavorare con StringPool e RangePool blocchi funzionali ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4670931838168033733015007444", 
"breadcrumbs" : "CODESYS String Libraries \/ Esempi \/ Lavorare con StringPool e RangePool blocchi funzionali ", 
"snippet" : "Il codice seguente mostra come usare dynamic IString istanze da a StringPool . StringPool o un RangePool √® adatto per essere passato a parti subordinate di un programma. Quindi possono creare le istanze corrispondenti dal rispettivo pool in base alle esigenze, utilizzarle e quindi restituire queste ...", 
"body" : "Il codice seguente mostra come usare dynamic IString istanze da a StringPool . StringPool o un RangePool √® adatto per essere passato a parti subordinate di un programma. Quindi possono creare le istanze corrispondenti dal rispettivo pool in base alle esigenze, utilizzarle e quindi restituire queste istanze al Lavorare con StringPool e RangePool VAR\n myString : GSB.UTF8String<256> := (sValue:=UTF8#'Was du nicht willst, dass man dir tu‚Äô, das f√ºg auch keinem andern zu.');\n myRange : STR.Range := (itfString:=myString);\n \n myStringPool : GSB.StringPool<(*udiStringSize*) 30, (*udiInitialCapacity*) 25, (*usiExtensionFactor*) 0>;\n myRangePool : GSB.RangePool<GSB.RANGE_TYPE.ISTRING, (*udiInitialCapacity*) 10, (*usiExtensionFactor*) 0>;\n \n diRune : STR.RUNE;\n eErrorID : STR.ERROR;\n itfSubString : STR.IString;\n liStart, liEnd : LINT;\n udiCount : UDINT;\nEND_VAR\n \nmyRange.Reset();\n\/\/ Decompose myString into substrings and analyze them via a subroutine.\nWHILE (diRune:=myRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND eErrorID = 0 DO\n IF diRune = 16#2C (*,*) OR diRune = 16#2E (*.*) THEN\n itfSubString := myStringPool.GetString();\n IF itfSubString = 0 THEN\n (* Handle Error *)\n EXIT;\n END_IF\n myString.ToIString(itfSubString, liStart+1, liEnd, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n (* Handle Error *)\n EXIT;\n END_IF\n \/\/ Analyse the substring and use pool's\n \/\/ Will release itfSubString\n udiCount := Analyse(itfSubString, myStringPool, myRangePool);\n (* ... Handle Result ... *)\n IF diRune = 16#2E (*.*) THEN\n EXIT;\n END_IF\n diRune:=myRange.GetNextRune(eErrorID=>eErrorID);\n IF diRune = 16#20 (* space *) AND eErrorID = 0 THEN\n liEnd := liEnd + 1;\n ELSE\n myRange.UngetLastRune();\n END_IF\n liStart := liEnd + 1;\n END_IF\n liEnd := liEnd + 1;\nEND_WHILE " }, 
{ "title" : "Lavorare con le categorie di caratteri di Unicode ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4613758488403233733015299155", 
"breadcrumbs" : "CODESYS String Libraries \/ Esempi \/ Lavorare con le categorie di caratteri di Unicode ", 
"snippet" : "Lo standard Unicode mira a catturare digitalmente tutti i caratteri in tutto il mondo e a descriverne le propriet√†. Per fare ci√≤, i caratteri vengono combinati in gruppi (categorie). Nella libreria Unicode, ci sono funzioni che controllano un carattere in base alla categoria a cui appartiene. Queste...", 
"body" : "Lo standard Unicode mira a catturare digitalmente tutti i caratteri in tutto il mondo e a descriverne le propriet√†. Per fare ci√≤, i caratteri vengono combinati in gruppi (categorie). Nella libreria Unicode, ci sono funzioni che controllano un carattere in base alla categoria a cui appartiene. Queste funzioni restituiscono TRUE se il carattere passato appartiene alla rispettiva categoria; altrimenti FALSE viene restituito. Nome Funzione IsControl Riconosce i caratteri di controllo generali IsLetter Riconosce le lettere in senso lato IsMark Riconosce la combinazione di caratteri, ad esempio i caratteri diacritici IsDigit Riconosce le cifre decimali IsLower Riconosce le lettere minuscole IsNumber Riconosce cifre e caratteri che si applicano ai numeri IsGraphic Riconosce solo caratteri stampabili (inclusi diversi tipi di caratteri spaziali) IsUpper Riconosce le lettere maiuscole IsPunct Riconosce i caratteri di punteggiatura IsPrint Riconosce solo caratteri stampabili (considera solo 16#20 come spazio (carattere) IsTitle Riconosce le lettere maiuscole per le intestazioni IsSpace Rileva spazi di diversa larghezza, interruzioni di riga, ecc. IsSymbol Riconosce i simboli in un senso pi√π ampio, ad esempio simboli matematici e simboli valutari. Il contenuto di un IString o IBuilder l'istanza pu√≤ essere analizzata ¬´carattere per carattere¬ª utilizzando un blocco funzione di tipo adeguato Range . Le funzioni della libreria Unicode possono essere molto utili per l'analisi Analisi del personaggio VAR\n myString : GSB.UTF8String<50> := (sValue:='Hello World!');\n myBuilder : GSB.Builder<100, 0> := (itfString:=myString);\n mySRange : STR.Range := (itfString:=myString);\n myBRange : SBD.Range := (itfBuilder:=myBuilder);\n diSRune, diBRune : STR.RUNE;\n eErrorID : STR.ERROR;\n udiCount : UDINT;\nEND_VAR\n \nWHILE (diSRune:=mySRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND eErrorID = 0 DO\n diBRune := myBRange.GetNextRune();\n IF diSRune <> diBRune THEN\n (* Solle nicht vorkommen *)\n END_IF\n IF UC.IsSpace(diSrune) THEN\n udiCount := udiCount + 1;\n END_IF\nEND_WHILE " }, 
{ "title" : "Conversione di caratteri ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4613761628716833733015669185", 
"breadcrumbs" : "CODESYS String Libraries \/ Esempi \/ Conversione di caratteri ", 
"snippet" : "Converti lettere in maiuscole ( UC.ToUpper ) Convertire le lettere in lettere minuscole ( UC.ToLower ) Conversione VAR diRuneA, diRuneB : STR.RUNE; END_VAR diRuneA := 16#1F3; \/\/ U+01F3 = «Ö diRuneB := UC.ToUpper(diRuneA); \/\/ U+01F1 = «± diRuneA := UC.ToLower(diRuneB); \/\/ U+01F3 = «Ö diRuneB := UC.ToTit...", 
"body" : "Converti lettere in maiuscole ( UC.ToUpper ) Convertire le lettere in lettere minuscole ( UC.ToLower ) Conversione VAR\n diRuneA, diRuneB : STR.RUNE;\nEND_VAR\n \ndiRuneA := 16#1F3; \/\/ U+01F3 = «Ö\ndiRuneB := UC.ToUpper(diRuneA); \/\/ U+01F1 = «±\ndiRuneA := UC.ToLower(diRuneB); \/\/ U+01F3 = «Ö\ndiRuneB := UC.ToTitle(diRuneA); \/\/ U+01F2 = «≤ " }, 
{ "title" : "Confronto di stringhe ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4563870076659233733015900115", 
"breadcrumbs" : "CODESYS String Libraries \/ Esempi \/ Confronto di stringhe ", 
"snippet" : "Sensibile alle maiuscole ( STR.Compare ) Non distingue tra maiuscole e minuscole ( UC.EqualFold ) Confronto di stringhe VAR myFirstString : GSB.UTF8String<50> := (sValue:='test'); mySecondString : GSB.UTF8String<50> := (sValue:='Test'); myThirdString : GSB.UTF8String<50> := (sValue:='CoDeSys'); myFo...", 
"body" : "Sensibile alle maiuscole ( STR.Compare ) Non distingue tra maiuscole e minuscole ( UC.EqualFold ) Confronto di stringhe VAR\n myFirstString : GSB.UTF8String<50> := (sValue:='test');\n mySecondString : GSB.UTF8String<50> := (sValue:='Test');\n \n myThirdString : GSB.UTF8String<50> := (sValue:='CoDeSys');\n myFourthString : GSB.UTF8String<50> := (sValue:='CODESYS');\n \n diResult : DINT;\n xEqual : BOOL;\nEND_VAR\n \n\/\/\/ Comparing two Strings lexicographically\n\/\/\/ diResult = 1 --> myFirstString > mySecondString\ndiResult := STR.Compare(myFirstString, mySecondString);\n \n\/\/\/ Unicode defined simple case folding\n\/\/\/ xEqual = TRUE --> myThirdString == myFourthString\nxEqual := UC.EqualFold(\n ADR(myThirdString.sValue), myThirdString.Len(),\n ADR(myFourthString.sValue), myFourthString.Len()\n); " }
]
$(document).trigger('search.ready');
});