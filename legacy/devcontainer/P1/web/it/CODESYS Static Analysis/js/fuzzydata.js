$(document).ready(function () {indexDict['it'] = [{ "title" : "CODESYS Static Analysis ", 
"url" : "_san_start_page.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis ", 
"snippet" : "Con CODESYS Static Analysis , è possibile eseguire un controllo del codice sorgente IEC utilizzando regole definite, convenzioni di denominazione o metriche. Di conseguenza, vengono evidenziate le indicazioni di possibili problemi di sviluppo e gli errori possono essere identificati e corretti prima...", 
"body" : "Con CODESYS Static Analysis , è possibile eseguire un controllo del codice sorgente IEC utilizzando regole definite, convenzioni di denominazione o metriche. Di conseguenza, vengono evidenziate le indicazioni di possibili problemi di sviluppo e gli errori possono essere identificati e corretti prima di un test sul campo. Ciò può far risparmiare molto tempo durante lo sviluppo dell'applicazione e il controllo degli errori. In CODESYS Static Analysis , sono già implementate più di 100 regole (alcune delle quali parametrizzabili). Queste regole possono essere combinate per creare set di regole personalizzate. In alcune regole sono inclusi i set di regole definiti nelle \"Linee guida per la codifica PLCopen\". È inoltre possibile definire una convenzione di denominazione per ogni possibile tipo di dati, di cui viene quindi verificata la conformità. Inoltre, sono disponibili più di 20 metriche che, se calcolate regolarmente, possono analizzare il codice sorgente sottostante e fornire indicazioni su tendenze negative e deviazioni dagli obiettivi di qualità. Puoi scaricare il CODESYS Static Analysis da Negozio CODESYS internazionale O Negozio CODESYS Nord America . Lì troverai anche la scheda tecnica del prodotto. Il prodotto è soggetto a licenza. Webinar CODESYS Static Analysis Se CODESYS Static Analysis è installato ma non è attivata alcuna licenza, quindi un'interfaccia ridotta con le funzionalità di Static Analysis Light È visualizzato. In alternativa a CODESYS Static Analysis , CODESYS Development System fornisce il Static Analysis Light Aggiungi su. Il componente aggiuntivo fa automaticamente parte di CODESYS Quando NO CODESYS Static Analysis è installato. " }, 
{ "title" : "Static Analysis Light ", 
"url" : "_san_start_page.html#UUID-cc139654-e7d3-fe83-903e-e33f8fd0a5ec_section-idm452529692233763389020840932", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis \/ Static Analysis Light ", 
"snippet" : "Static Analysis Light ha un set di funzionalità molto limitato e fornisce solo 7 controlli di compilazione. Il prodotto è liberamente disponibile. È possibile abilitare i controlli di compilazione individualmente nel file Progetto → Impostazioni progetto menu, nel Luce di analisi statica categoria. ...", 
"body" : "Static Analysis Light ha un set di funzionalità molto limitato e fornisce solo 7 controlli di compilazione. Il prodotto è liberamente disponibile. È possibile abilitare i controlli di compilazione individualmente nel file Progetto → Impostazioni progetto menu, nel Luce di analisi statica categoria. Per ulteriori informazioni, vedere: Impostazioni del progetto: Luce analisi statica " }, 
{ "title" : "Panoramica ", 
"url" : "_san_overview.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Panoramica ", 
"snippet" : "L'analisi statica viene eseguita nel progetto corrente solo per il codice dell'applicazione. Le biblioteche e i loro codici sorgente non vengono analizzati. CODESYS Static Analysis ti aiuta durante l'implementazione per scrivere codice migliore e più leggibile e per identificare parti di programma i...", 
"body" : "L'analisi statica viene eseguita nel progetto corrente solo per il codice dell'applicazione. Le biblioteche e i loro codici sorgente non vengono analizzati. CODESYS Static Analysis ti aiuta durante l'implementazione per scrivere codice migliore e più leggibile e per identificare parti di programma in conflitto o non supportate. In particolare vengono individuate potenziali fonti di errore. Ad esempio, vengono identificate le posizioni in cui è ancora contenuto il codice di test. Oppure vengono trovati puntatori che non vengono controllati per 0 prima del dereferenziamento. Oppure (con il SA0119 regola) vengono analizzate le posizioni in cui viene utilizzato l'orientamento agli oggetti e i collegamenti a un altro ambiente di sviluppo, che non supporta l'orientamento agli oggetti, rendendolo quindi impossibile. Di conseguenza, la portabilità del codice può essere garantita. Per gli errori segnalati da Static Analysis sulla base delle informazioni di precompilazione, è disponibile il supporto per una gestione immediata degli errori (\"Quickfix\"). Ciò consente di trovare e correggere rapidamente le posizioni nel codice segnalate durante l'analisi. Per migliorare la leggibilità del codice sorgente, è possibile definire convenzioni di denominazione e verificarne la conformità. Inoltre, per valutare la qualità del codice, è possibile visualizzare le metriche determinate dal codice sorgente. Gli esempi includono la metrica McCabe come misura della testabilità del codice o la complessità cognitiva come misura della leggibilità e manutenibilità del codice sorgente. L'analisi del flusso di dati eseguita nell'analisi statica si basa sul principio della propagazione costante. Con il Crea → Esegui analisi statica comando del menu si attiva esplicitamente l'analisi statica. Nel Impostazioni finestra di dialogo, si abilita un'analisi statica che viene eseguita automaticamente dopo ogni compilazione del codice. Usate affermazioni pragmatiche per escludere singole parti o blocchi di codice dall'analisi. Nel Regole finestra di dialogo, puoi scoprire quali regole sono configurate, come vengono attivate e quando vengono eseguiti i controlli sulla rispettiva regola. Lì attivi le regole che sono rilevanti per te. Nel Convenzioni di denominazione dialog, si assegna un prefisso a ciascun tipo di dati come previsto nelle dichiarazioni. Vengono segnalate le deviazioni. Nel Impostazioni di analisi statica: Metriche finestra di dialogo, attivi le metriche rilevanti per te. Con il Mostra complessità cognitiva per l'editor corrente comando, gli incrementi determinati vengono visualizzati riga per riga nell'editor attivo. IL Mostra valori di propagazione costante per l'editor corrente Il comando analizza in dettaglio il flusso di dati nell'editor attivo e lo visualizza percorso per percorso. A seconda di ciò, sono possibili miglioramenti al codice. Per ulteriori informazioni, vedere: regole, Metrica, E Pragma e attributi" }, 
{ "title" : "Configurazione ed esecuzione dell'analisi statica ", 
"url" : "_san_configuring_and_running.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configurazione ed esecuzione dell'analisi statica ", 
"snippet" : "Utilizzando un progetto di esempio di base riportato di seguito, troverai i passaggi e le opzioni più importanti per la configurazione e l'esecuzione di un'analisi statica. Requisiti: CODESYS Static Analysis è installato....", 
"body" : "Utilizzando un progetto di esempio di base riportato di seguito, troverai i passaggi e le opzioni più importanti per la configurazione e l'esecuzione di un'analisi statica. Requisiti: CODESYS Static Analysis è installato. " }, 
{ "title" : "Progetto di esempio ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-5b7b70fe166a598dc0a864631da88a82", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configurazione ed esecuzione dell'analisi statica \/ Progetto di esempio ", 
"snippet" : "Se si desidera riprodurre il progetto di esempio, creare un progetto standard e inserire le POU sotto l'applicazione nell'albero dei dispositivi. Configura quindi le impostazioni di comunicazione per la connessione al tuo locale CODESYS Control Win . FUNCTION_BLOCK fb1 VAR_INPUT iVar_fb1in1 : INT; i...", 
"body" : "Se si desidera riprodurre il progetto di esempio, creare un progetto standard e inserire le POU sotto l'applicazione nell'albero dei dispositivi. Configura quindi le impostazioni di comunicazione per la connessione al tuo locale CODESYS Control Win . FUNCTION_BLOCK fb1\nVAR_INPUT\n iVar_fb1in1 : INT;\n ivar_fb1in2 : INT;\n rVar_fb1in3 : REAL;\nEND_VAR\nVAR_OUTPUT\n iVar_fb1out:INT;\nEND_VAR\nVAR\n P_fSampleProperty : INT;\n rVar : REAL;\n PRO : BOOL;\nEND_VAR\n iVar_fb1out:=iVar_fb1in1 + 1; FUNCTION_BLOCK fb2\nVAR_INPUT\n iVar_fb2in:INT;\nEND_VAR\nVAR_OUTPUT\n iVar_fb2out:INT;\nEND_VAR\nVAR\nEND_VAR\n iVar_fb2out:=iVar_fb2in - 1; PROGRAM PLC_PRG\nVAR\n fb1_inst: fb1;\n fb2_inst: fb2;\nEND_VAR fb1_inst(iVar_fb1in1 := 99);\nfb2_inst(iVar_fb2in := 22);\nfb2_inst(iVar_fb2in := 1); " }, 
{ "title" : "Verifica del rispetto delle regole ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9641312f166a598dc0a864630126d291", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configurazione ed esecuzione dell'analisi statica \/ Verifica del rispetto delle regole ", 
"snippet" : "Scegli il comando Costruisci → Analisi statica → Impostazioni . Passa a scheda regole . Viene visualizzato un elenco contenente tutti i possibili controlli delle regole. Sono organizzati in una struttura ad albero per categorie tematiche. Il \"numero della regola\" viene aggiunto tra parentesi (esempi...", 
"body" : "Scegli il comando Costruisci → Analisi statica → Impostazioni . Passa a scheda regole . Viene visualizzato un elenco contenente tutti i possibili controlli delle regole. Sono organizzati in una struttura ad albero per categorie tematiche. Il \"numero della regola\" viene aggiunto tra parentesi (esempio: Variabili non utilizzate (33) nella categoria Oggetti inutilizzati ). Fare clic più volte sulla casella di controllo della prima riga ( Regole nodo). Facendo clic si alterna lo stato di attivazione. Le caselle di controllo nell'intero albero hanno un segno di spunta rosso o arancione o nessun segno di spunta. In questo modo attivi tutte le voci con il segno di spunta rosso. Ciò significa che CODESYS Static Analysis dovrebbe segnalare qualsiasi violazione delle regole rilevata come errori. Clic Costruisci → Analisi statica → Esegui analisi statica . Gli errori vengono segnalati nella visualizzazione dei messaggi. I testi dei messaggi sono contrassegnati con a e iniziare con il numero di errore \"SA<numero regola>\". Fare doppio clic sul messaggio SA0033: Variabili non utilizzate 'iVar_fb2out' . L'attenzione si sposta sulla parte di dichiarazione del blocco funzione fb2 e viene selezionata la variabile pertinente. La variabile viene dichiarata, ma non utilizzata. Ciò è verificato nella regola 33 ( Variabili inutilizzate ). Nel codice le sedi rilevanti sono sottolineate con una linea ondulata. Per testare l'esecuzione automatica dell'analisi, fare clic su Costruisci → Analisi statica → Impostazioni . Sul Impostazioni scheda, selezionare il Eseguire automaticamente l'analisi statica dopo la compilazione opzione. Clic OK per uscire dalla finestra di dialogo. Clic In linea → Accedi . Una finestra di dialogo indica la presenza di errori di compilazione. Gli errori segnalati dall'analisi del codice vengono nuovamente visualizzati nella visualizzazione dei messaggi. Clic Compila → Analisi statica → Impostazioni . Passa a Regole scheda. Ora cancella tutte le regole nella finestra di dialogo. Nel Oggetti inutilizzati categoria, attivare esplicitamente la Regola SA0035 ( Variabili di input non utilizzate (35) ) con un segno di spunta di colore arancione per segnalare un \"avviso\". Vedi la descrizione comando per il testo della regola: Questa regola corrisponde alle seguenti regole PLCopen: CP24 ). Clic OK per uscire dalla finestra di dialogo. Clic Costruisci → Genera codice . L'analisi viene eseguita automaticamente. Nella visualizzazione dei messaggi vengono segnalati due errori Messaggi di analisi statica categoria: § SA0035: Ingresso non utilizzato 'iVar_fb1in2' § SA0035: Ingresso non utilizzato 'iVar_fb1in3' Fare doppio clic sul messaggio e commentare o rimuovere la dichiarazione. Eseguire nuovamente l'analisi del codice. Non viene visualizzato alcun messaggio di errore. " }, 
{ "title" : "Verifica della conformità alle convenzioni di denominazione definite ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-d64b88b5166a598dc0a864632e22b38d", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configurazione ed esecuzione dell'analisi statica \/ Verifica della conformità alle convenzioni di denominazione definite ", 
"snippet" : "Clic Compila → Analisi statica → Impostazioni . Passa a Convenzioni di denominazione scheda. Viene visualizzata una tabella in una struttura ad albero divisa in categorie espandibili di variabili e blocchi di programma. Espandi il Prefissi per variabili – Prefissi per i tipi categoria e nella Prefis...", 
"body" : "Clic Compila → Analisi statica → Impostazioni . Passa a Convenzioni di denominazione scheda. Viene visualizzata una tabella in una struttura ad albero divisa in categorie espandibili di variabili e blocchi di programma. Espandi il Prefissi per variabili – Prefissi per i tipi categoria e nella Prefisso colonna, specificare I per INTERNO (14) . Espandi il Prefissi per POU – Prefissi per il tipo POU categoria. Nel Prefisso colonna, specificare il prog per PROGRAMMA (122) E fb per BLOCCO FUNZIONE (103) . Seleziona il Il primo carattere dopo il prefisso deve essere una lettera maiuscola opzione. Cancella tutte le altre opzioni. Clic Costruisci → Analisi statica → Esegui analisi statica . Messaggio di errore: NC0102: Nome non valido 'PLC_PRG': Previsto prefisso 'prog' perché PLC_PRG non ha il prefisso richiesto Il primo carattere dopo il prefisso deve essere maiuscolo: 'ivar_fb1in2' Perché ivar_fb1in2 : INT; è dentro fb1 . NC0014: nome variabile non valido P_fSampleProperty: previsto prefisso 'i' perché questa variabile intera non ha il prefisso richiesto. " }, 
{ "title" : "Controllo dei simboli proibiti ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-7e83abe1166a598dc0a86463714e1dc5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configurazione ed esecuzione dell'analisi statica \/ Controllo dei simboli proibiti ", 
"snippet" : "Scegli il comando Costruisci → Analisi statica → Impostazioni . Passa a scheda Simboli proibiti . Un editor di riga consente di specificare stringhe che non devono essere utilizzate nel codice. Ad esempio, fare doppio clic sulla riga vuota e digitare la stringa non valida PRO direttamente. Fare dopp...", 
"body" : "Scegli il comando Costruisci → Analisi statica → Impostazioni . Passa a scheda Simboli proibiti . Un editor di riga consente di specificare stringhe che non devono essere utilizzate nel codice. Ad esempio, fare doppio clic sulla riga vuota e digitare la stringa non valida PRO direttamente. Fare doppio clic sulla riga vuota successiva e fare clic su per aprire l'Assistente di input. Da Tipi standard , Selezionare VERO . Clic OK per uscire dalla finestra di dialogo. Clic Costruisci → Analisi statica → Esegui analisi statica . I messaggi di errore Forbidden symbol 'REAL' E Forbidden symbol 'PRO' vengono visualizzati nella visualizzazione dei messaggi. Fare doppio clic sul testo del messaggio per passare alla riga di codice pertinente. " }, 
{ "title" : "Visualizzazione delle metriche ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configurazione ed esecuzione dell'analisi statica \/ Visualizzazione delle metriche ", 
"snippet" : "CODESYS Static Analysis esegue i test selezionati sul codice ed è possibile visualizzare i risultati in una vista. Scegli il comando Costruisci → Analisi statica → Impostazioni . Passa a scheda metrica . Le metriche che CODESYS Static Analysis applicabili al codice sono elencati in una tabella. Per ...", 
"body" : "CODESYS Static Analysis esegue i test selezionati sul codice ed è possibile visualizzare i risultati in una vista. Scegli il comando Costruisci → Analisi statica → Impostazioni . Passa a scheda metrica . Le metriche che CODESYS Static Analysis applicabili al codice sono elencati in una tabella. Per questo esempio, attiva il Numero di variabili di input metrica e specificare l'intervallo di valori consentito: limite inferiore 1 e limite superiore 2 . Attiva alcune altre metriche, ad esempio Dimensione del codice E Numero di chiamate . Clic Costruisci → Analisi statica → Visualizza metriche standard . La vista include una tabella con una riga per ciascuna Unità di programma del programma di esempio. Per ogni metrica attivata, è presente una colonna che mostra i valori misurati. I valori che non rientrano nell'intervallo di valori definito nelle impostazioni sono evidenziati in rosso. Nel caso di questo esempio specifico, questo è almeno il PLC_PRG\/Ingressi campo perché il numero di variabili di ingresso in questa POU è maggiore del limite superiore definito di 2 . " }, 
{ "title" : "Correggi rapidamente le violazioni delle regole nel codice ST ", 
"url" : "_san_fix_errors_quickly.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correggi rapidamente le violazioni delle regole nel codice ST ", 
"snippet" : "In dialogo Impostazioni Analisi statica sotto la scheda regole è possibile attivare regole per il codice ST, il cui rispetto viene verificato sulla base delle informazioni di precompilazione. Non è necessario richiamare esplicitamente l'analisi del codice statico per trovare tali violazioni delle re...", 
"body" : "In dialogo Impostazioni Analisi statica sotto la scheda regole è possibile attivare regole per il codice ST, il cui rispetto viene verificato sulla base delle informazioni di precompilazione. Non è necessario richiamare esplicitamente l'analisi del codice statico per trovare tali violazioni delle regole. Il rispetto delle regole viene verificato nell'editor ST attivo durante la precompilazione e dopo la corretta compilazione. Se si verifica una violazione della regola, questa viene immediatamente visualizzata nell'editor ST mediante underring. Vengono inoltre visualizzati nella finestra dei messaggi nella vista precompilazione messaggi di errore o avvisi. Per le istruzioni, vedere: Verifica della conformità alle convenzioni di denominazione definitePuoi trovare la correzione rapida nell'editor ST facendo clic sul codice con la sottolineatura ondulata e quindi facendo clic sul simbolo della lampadina o nella visualizzazione dei messaggi tramite il pulsante nella riga del messaggio di errore. In ciascun caso vengono forniti i comandi corrispondenti per gestire la violazione della regola. A seconda dell'errore, vengono offerti i seguenti comandi per una rapida risoluzione dei problemi (soluzione rapida): Ignora il messaggio di errore\/avviso Il comando inserisce automaticamente pragma o attributi nel codice che precludono un controllo della regola associata per quella riga di codice. Ignora messaggio di errore\/avviso a livello globale per <nome oggetto di programmazione> Il comando fa sì che un attributo venga inserito automaticamente all'inizio della parte di dichiarazione dell'oggetto di programmazione. Quindi viene esclusa una verifica della regola associata per questo oggetto di programmazione. Comando con un suggerimento su come modificare il codice ST per evitare la violazione della regola (soluzione rapida). Per esempio SA0168: Rimuovere l'assegnazione 'enum1 := 5' Disattiva il controllo Il comando fa sì che il controllo della regola associata venga disabilitato nelle impostazioni. Puoi annullare gli effetti dell'invocazione di entrambi i comandi. Per fare ciò, prima fai clic nella vista attrezzatura (o in alternativa nella vista POU ). Poi il comando annullare attivato. " }, 
{ "title" : "abilitare le regole ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-1cca77b1336bf579c0a8646302e5e6f3", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correggi rapidamente le violazioni delle regole nel codice ST \/ abilitare le regole ", 
"snippet" : "Scegli il comando Costruisci → Analisi statica → Impostazioni . Passa alla scheda regole . Ottieni un elenco di tutti i possibili controlli delle regole. Sono organizzati in una struttura ad albero in categorie tematiche. Il \"numero di regola\" viene aggiunto tra parentesi tonde. Puoi filtrare le reg...", 
"body" : "Scegli il comando Costruisci → Analisi statica → Impostazioni . Passa alla scheda regole . Ottieni un elenco di tutti i possibili controlli delle regole. Sono organizzati in una struttura ad albero in categorie tematiche. Il \"numero di regola\" viene aggiunto tra parentesi tonde. Puoi filtrare le regole, ordinarle in base alle opzioni o visualizzarle come un elenco. Fare clic sul filtro Vista strutturata sull'icona e selezionare l'opzione Strutturato per tempo di esecuzione . Le regole che possono essere verificate anche durante la precompilazione sono elencate di seguito Eseguito durante la precompilazione e dopo una compilazione riuscita nodo. Queste sono le regole identificate da un segno di spunta nel file Precompilare colonna. Nella colonna di sinistra ora puoi abilitare la regola per il controllo. Nella riga della regola (168), fare clic sulla casella di controllo in modo che lo stato cambi da \"segno di spunta rosso\" a \"segno di spunta giallo\" a \"nessun segno di spunta\". Un segno di spunta rosso significa che la violazione della regola viene emessa come messaggio di errore. Un segno di spunta giallo indica che la violazione del regolamento viene emessa come avvertimento. Nessun segno di spunta significa che la regola non è verificata. Le regole attivate vengono ora verificate e, se violate, contrassegnate nel codice e visualizzate nella finestra del messaggio. " }, 
{ "title" : "Visualizza le violazioni delle regole nella finestra del messaggio ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8f3e8ec3336bf579c0a86463654e2139", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correggi rapidamente le violazioni delle regole nel codice ST \/ Visualizza le violazioni delle regole nella finestra del messaggio ", 
"snippet" : "Scegli il comando Visualizza → Messaggi . Si apre la finestra del messaggio. Nella finestra del messaggio, selezionare la categoria dall'elenco di selezione precompilazione . In questa categoria vengono visualizzate solo le violazioni delle regole che sono state rilevate durante la precompilazione e...", 
"body" : "Scegli il comando Visualizza → Messaggi . Si apre la finestra del messaggio. Nella finestra del messaggio, selezionare la categoria dall'elenco di selezione precompilazione . In questa categoria vengono visualizzate solo le violazioni delle regole che sono state rilevate durante la precompilazione e dopo una compilazione riuscita e che è possibile risolvere con Quickfix. IL Il pulsante fornisce i rispettivi comandi per questo. " }, 
{ "title" : "Eseguire una rapida risoluzione dei problemi ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8a9adfb3336bf579c0a8646308d0b385", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correggi rapidamente le violazioni delle regole nel codice ST \/ Eseguire una rapida risoluzione dei problemi ", 
"snippet" : "La regola 168 è attivata nelle impostazioni e una violazione della regola viene visualizzata nell'editor ST. Presupposto: Nel codice ST almeno una riga è sottolineata ondulata e nella visualizzazione delle segnalazioni viene visualizzato il rispettivo numero SA. Fare clic sulla riga di codice con la...", 
"body" : "La regola 168 è attivata nelle impostazioni e una violazione della regola viene visualizzata nell'editor ST. Presupposto: Nel codice ST almeno una riga è sottolineata ondulata e nella visualizzazione delle segnalazioni viene visualizzato il rispettivo numero SA. Fare clic sulla riga di codice con la sottolineatura ondulata. Il simbolo appare. Fare clic sull'icona della lampadina. Si apre una finestra con i comandi di menu per la gestione degli errori. Vuoi correggere l'errore. Quindi scegli il comando Assegnazione 'enum1 := GVL.CONST' . La riga di codice viene ora modificata automaticamente come mostrato nel comando. Il problema è risolto. Il terzo comando contiene un suggerimento su come correggere l'errore modificando il codice, a seconda della violazione della regola. La stessa gestione degli errori avviene tramite un clic del pulsante possibile nella riga del messaggio di errore nella finestra del messaggio. " }, 
{ "title" : "Disabilita il controllo delle regole per una riga di codice ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-107e44f0336bf579c0a8646347e7d5cc", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correggi rapidamente le violazioni delle regole nel codice ST \/ Disabilita il controllo delle regole per una riga di codice ", 
"snippet" : "La regola (168) viene attivata nelle impostazioni e una violazione della regola viene visualizzata nell'editor ST. Presupposto: Nel codice ST almeno una riga è sottolineata ondulata e nella visualizzazione delle segnalazioni viene visualizzato il rispettivo numero SA. Fare clic sulla riga di codice ...", 
"body" : "La regola (168) viene attivata nelle impostazioni e una violazione della regola viene visualizzata nell'editor ST. Presupposto: Nel codice ST almeno una riga è sottolineata ondulata e nella visualizzazione delle segnalazioni viene visualizzato il rispettivo numero SA. Fare clic sulla riga di codice con la sottolineatura ondulata. IL viene visualizzato il simbolo . Fare clic sull'icona della lampadina. Si apre una finestra con i comandi di menu per la gestione degli errori. Non vuoi correggere l'errore. Ecco perché scegli il comando Ignora il messaggio di errore\/avviso . Ora la riga di codice viene automaticamente dotata di pragma. I pragma vengono utilizzati per impedire il controllo della riga relativa alla regola interessata. Non viene emesso un messaggio di errore o un avviso. Puoi anche trovare il comando per disabilitare il controllo delle regole per la riga di codice interessata usando il pulsante nella riga del messaggio di errore nella finestra del messaggio. " }, 
{ "title" : "Disabilita il controllo delle regole per un oggetto di programmazione ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-6dee377f336bf579c0a8646357b65fa8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correggi rapidamente le violazioni delle regole nel codice ST \/ Disabilita il controllo delle regole per un oggetto di programmazione ", 
"snippet" : "La regola 168 è attivata nelle impostazioni e una violazione della regola viene visualizzata nell'editor ST. Presupposto: nel codice ST almeno una riga è sottolineata ondulata e nella visualizzazione delle segnalazioni viene visualizzato il rispettivo numero SA. Fare clic sulla riga di codice con la...", 
"body" : "La regola 168 è attivata nelle impostazioni e una violazione della regola viene visualizzata nell'editor ST. Presupposto: nel codice ST almeno una riga è sottolineata ondulata e nella visualizzazione delle segnalazioni viene visualizzato il rispettivo numero SA. Fare clic sulla riga di codice con la sottolineatura ondulata. Il simbolo appare. Fare clic sulla lampadina. Si apre una finestra con i comandi di menu per la gestione degli errori. Non si desidera che l'oggetto di programmazione venga verificato per la regola specificata. Ecco perché scegli il secondo comando Ignora messaggio di errore\/avviso a livello globale per PLC_PRG . La dichiarazione dell'oggetto viene ora fornita automaticamente con un attributo. L'attributo indica che la regola interessata non è più verificata per l'oggetto. Non viene emesso alcun messaggio di errore o avviso. Puoi anche trovare il comando per ignorare il messaggio tramite il pulsante nella riga del messaggio di errore nella finestra del messaggio. " }, 
{ "title" : "Disabilita il controllo della regola in generale ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correggi rapidamente le violazioni delle regole nel codice ST \/ Disabilita il controllo della regola in generale ", 
"snippet" : "La regola 168 è attivata nelle impostazioni e una violazione della regola viene visualizzata nell'editor ST. Presupposto: Nel codice ST almeno una riga è sottolineata ondulata e nella visualizzazione delle segnalazioni viene visualizzato il rispettivo numero SA. Fare clic sulla riga di codice con la...", 
"body" : "La regola 168 è attivata nelle impostazioni e una violazione della regola viene visualizzata nell'editor ST. Presupposto: Nel codice ST almeno una riga è sottolineata ondulata e nella visualizzazione delle segnalazioni viene visualizzato il rispettivo numero SA. Fare clic sulla riga di codice con la sottolineatura ondulata. Il simbolo appare. Fare clic sulla lampadina. Si apre una finestra con i comandi di menu per la gestione degli errori. Si desidera che la regola visualizzata non sia più controllata. Ecco perché scegli il quarto comando Disattiva il controllo . La regola è disattivata nelle impostazioni dell'analisi statica. Scegli il comando Costruisci → Analisi statica → Impostazioni . Passa alla scheda regole . La regola 168 è disabilitata. Puoi anche trovare il comando per la disattivazione globale del controllo tramite il pulsante nella riga del messaggio di errore nella finestra del messaggio. " }, 
{ "title" : "Definire le convenzioni di denominazione ", 
"url" : "_san_define_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definire le convenzioni di denominazione ", 
"snippet" : "In dialogo Impostazioni Analisi statica sotto la scheda convenzioni di denominazione definisci le convenzioni di denominazione che seguirai nel tuo codice. Definisci i prefissi per gli identificatori dei tuoi blocchi di programmazione, variabili e tipi di dati in base ai loro ambiti e qualificatori....", 
"body" : "In dialogo Impostazioni Analisi statica sotto la scheda convenzioni di denominazione definisci le convenzioni di denominazione che seguirai nel tuo codice. Definisci i prefissi per gli identificatori dei tuoi blocchi di programmazione, variabili e tipi di dati in base ai loro ambiti e qualificatori. È quindi possibile fare in modo che l'analisi statica verifichi la conformità alle convenzioni di denominazione. Per le istruzioni, vedere: Verifica della conformità alle convenzioni di denominazione definite" }, 
{ "title" : "Definisci i prefissi ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-291ced2808fb693bc0a8646323d0819d", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definire le convenzioni di denominazione \/ Definisci i prefissi ", 
"snippet" : "In dialogo Impostazioni Analisi statica sotto la scheda convenzioni di denominazione definire le convenzioni di denominazione nel campo di input della colonna prefisso . carattere letterale Esempio: PRG_ in Prefissi per POU , Prefissi per il tipo POU , PROGRAMMA (102) Più letterali per voce, separat...", 
"body" : "In dialogo Impostazioni Analisi statica sotto la scheda convenzioni di denominazione definire le convenzioni di denominazione nel campo di input della colonna prefisso . carattere letterale Esempio: PRG_ in Prefissi per POU , Prefissi per il tipo POU , PROGRAMMA (102) Più letterali per voce, separati da una virgola Sintassi: <prefix> ( , <next prefix> )* Esempio: PRG_, PRG in Prefissi per POU , Prefissi per il tipo POU , PROGRAMMA (102) espressione regolare RegEx , che definisce un insieme di prefissi Sintassi: @ <expression> Esempi: @x[a-dA-D] definisce un prefisso che inizia con x inizia, seguito esattamente da un carattere dell'intervallo a-dA-D @[A-Za-z][A-Za-z][A-Za-z][A-Za-z0-9] definisce un prefisso composto da 4 caratteri: i primi 3 sono lettere, il 4° carattere può essere anche un numero " }, 
{ "title" : "Definire i prefissi per i tipi di dati combinabili ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e9a24404c19ad708c0a86463215af896", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definire le convenzioni di denominazione \/ Definire i prefissi per i tipi di dati combinabili ", 
"snippet" : "I seguenti tipi di dati si basano su tipi di dati standard, tipi di dati esistenti o blocchi funzione: puntatori: POINTER TO <basic type> Riferimento: REFERENCE TO <basic type> Vettore: ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> Questi tipi di dati possono essere nidificati ...", 
"body" : "I seguenti tipi di dati si basano su tipi di dati standard, tipi di dati esistenti o blocchi funzione: puntatori: POINTER TO <basic type> Riferimento: REFERENCE TO <basic type> Vettore: ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> Questi tipi di dati possono essere nidificati e combinati tra loro. Se l'opzione Prefissi ricorsivi per tipi di dati combinabili è attivata, l'analisi statica prevede prefissi composti in modo ricorsivo per variabili di tali tipi di dati combinabili. I prefissi seguono la dichiarazione e corrispondono alle convenzioni di denominazione concordate per i tipi di dati di base. esempio Sono state stabilite le seguenti convenzioni di denominazione: i in Prefissi per variabili , INT (26) p in Prefissi per variabili , PUNTATORI (26) ref in Prefissi per variabili , RIFERIMENTI (27) struct in Prefissi per variabili , Struttura (32) opzione Prefissi ricorsivi per tipi di dati combinabili : Il codice seguente viola le convenzioni di denominazione ed è difficile da leggere. PROGRAM plc1\nVAR\n var1 : ARRAY[100..110] OF ARRAY[30..50] OF ARRAY[6..7] OF BOOL;\n var2 : ARRAY[1..3] OF INT;\n var3 : REFERENCE TO INT;\n iVar4 : INT;\n iVar5 : INT;\n var6 : ARRAY[1..3] OF INT := [11, 22, 33];\n var7 : POINTER TO ARRAY[1..3] OF INT;\n var8 : REFERENCE TO INT;\n var9 : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n var0 : ARRAY[0..3] OF S_POLYGONLINE; \/\/ S_POLYGONLINE is a already defined structure\nEND_VAR\n\niVar4 := iVar4 + 1;\nvar8 REF= iVar4;\nvar1[100][30][6] := TRUE;\nvar9.aiPoint1[1] := 99;\nvar7 := ADR(var6);\nvar6[2] := 44;\niVar5 := var7^[2];\nvar0[0] := var9; L'analisi statica segnala le seguenti violazioni delle convenzioni di denominazione: NC0102: nome non valido 'plc1': prefisso previsto 'PRG_' NC0014: Nome variabile 'var0' non valido: Prefisso previsto 'astruct' NC0014: Nome variabile 'var1' non valido: Prefisso previsto 'aaax' NC0014: nome variabile 'var2' non valido: prefisso previsto 'ai' NC0014: Nome variabile 'var3' non valido: Prefisso previsto 'refi' NC0014: nome variabile 'var6' non valido: prefisso previsto 'ai' NC0014: Nome variabile 'var7' non valido: Prefisso previsto 'pai' NC0014: Nome variabile 'var8' non valido: Prefisso previsto 'refi' NC0014: nome variabile 'var9' non valido: prefisso previsto 'struct' " }, 
{ "title" : "Definire i prefissi per le variabili di un alias ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9f66c39a945e11eab0a0b46479d263a5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definire le convenzioni di denominazione \/ Definire i prefissi per le variabili di un alias ", 
"snippet" : "È possibile utilizzare i prefissi per le variabili del tipo di dati Alias come letterale con il carattere jolly {datatype} definire. Quindi l'analisi statica prevede il prefisso del tipo di dati di base anziché il segnaposto. L'opzione Combina il prefisso dello spazio dei nomi con il prefisso del ti...", 
"body" : "È possibile utilizzare i prefissi per le variabili del tipo di dati Alias come letterale con il carattere jolly {datatype} definire. Quindi l'analisi statica prevede il prefisso del tipo di dati di base anziché il segnaposto. L'opzione Combina il prefisso dello spazio dei nomi con il prefisso del tipo di dati non pregiudica l'uso del prefisso {datatype} . esempio Sono state stabilite le seguenti convenzioni di denominazione: s in Prefissi per variabili , Digita i prefissi , STRINGA()19 A_{datatype} in Prefissi per variabili , Alias (33) codice TYPE A_MESSAGE : STRING[50]; \/\/ base data type is STRING\nEND_TYPE\n\nVAR\n A_sMessage_N1 : A_MESSAGE := 'Robot is running.';\n A_s_Message_N2 : A_MESSAGE := 'Robot has been finished.';\n As_Message_N3 : A_MESSAGE := 'Robot has been stopped.';\n AsMessage_N4 : A_MESSAGE := 'Error 3 has been occured.';\nEND_VAR L'analisi statica segnala la seguente violazione della convenzione di denominazione: NC0033: Nome variabile 'As_Message_N3' non valido: Prefisso previsto 'A_s' NC0033: Nome variabile 'AsMessage_N4' non valido: Prefisso previsto 'A_s'' " }, 
{ "title" : "Definire i prefissi per le proprietà ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e0cda739c19ad708c0a864636e955ca0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definire le convenzioni di denominazione \/ Definire i prefissi per le proprietà ", 
"snippet" : "È possibile utilizzare il prefisso per i blocchi predefiniti (POU) del tipo di dati PROPERTY come letterale con il carattere jolly {datatype} definire. Quindi l'analisi statica prevede il prefisso del tipo di dati restituito della proprietà anziché il segnaposto. L'opzione Combina il prefisso dello ...", 
"body" : "È possibile utilizzare il prefisso per i blocchi predefiniti (POU) del tipo di dati PROPERTY come letterale con il carattere jolly {datatype} definire. Quindi l'analisi statica prevede il prefisso del tipo di dati restituito della proprietà anziché il segnaposto. L'opzione Combina il prefisso dello spazio dei nomi con il prefisso del tipo di dati non pregiudica l'uso del segnaposto {datatype} . esempio Sono state stabilite le seguenti convenzioni di denominazione: fb in Prefissi per variabili , Digita i prefissi , istanza del blocco funzione FB_ in Prefissi per POU , Prefissi per il tipo POU , BLOCCO FUNZIONI (103) prop_{datatype} in Prefissi per POU , Prefissi per il tipo POU , IMMOBILE (107) codice FUNCTION_BLOCK blocka \/\/ Invalid function block name\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC vara : INT \/\/ Invalid property name, return data type is INT\nGet\n vara := iA;\nSet\niA := vara;\n\nPROGRAM plc1\nVAR\n var10 : blocka; \/\/ Invalid variable name of typ function block\n iVar11: INT;\nEND_VAR\n\nvar10();\nIF var10.vara > 500 THEN\n var10.vara := 0;\nEND_IF\niVar11 := var10.vara; L'analisi statica segnala la seguente violazione della convenzione di denominazione: NC0102: nome non valido ''plc1': prefisso previsto 'PRG_'' NC0031: Nome variabile ''var10'' non valido: Prefisso previsto ''fb'' NC0103: Nome variabile ''blocka' non valido: Prefisso previsto 'FB_'' NC0107: Nome variabile 'blocka.vara' non valido: Prefisso previsto 'prop_i'' Codice secondo le convenzioni di denominazione FUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC prop_iA : INT\nGet\n prop_iA := iA;\nSet\n iA := prop_iA;\n\nPROGRAM PRG_PLC1\nVAR\n fbA : FB_A;\n iVar11: INT;\nEND_VAR\n\nfbA();\nIF fbA.prop_iA > 500 THEN\n fbA.prop_iA := 0;\nEND_IF\niVar11 := fbA.prop_iA; " }, 
{ "title" : "Definire i prefissi per le strutture ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-ed64228609104c08c0a864630c58c86b", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definire le convenzioni di denominazione \/ Definire i prefissi per le strutture ", 
"snippet" : "È possibile impostare un prefisso generale per le strutture nel progetto in Prefissi per DUT , Struttura (151) definire. Puoi anche fornire una struttura con un prefisso speciale. Il prefisso speciale quindi oscura il prefisso generale. Il prefisso speciale è specificato nella dichiarazione del tipo...", 
"body" : "È possibile impostare un prefisso generale per le strutture nel progetto in Prefissi per DUT , Struttura (151) definire. Puoi anche fornire una struttura con un prefisso speciale. Il prefisso speciale quindi oscura il prefisso generale. Il prefisso speciale è specificato nella dichiarazione del tipo di dati della struttura con il pragma {attribute 'nameprefix' := <special prefix> '} Sono definiti. Quindi avvia tutte le variabili di questa struttura con questo prefisso <special prefix> . esempio Sono state stabilite le seguenti convenzioni di denominazione: struct in Prefissi per variabili , Struttura(32) S_ in Prefissi per DUT , Struttura (151) Prefissi ricorsivi per tipi di dati combinabili : codice TYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE\n\n{attribute 'nameprefix' := 'penta'} \/\/ Pragma to define a special prefix\nTYPE S_PENTA EXTENDS S_POLYGONLINE :\nSTRUCT\n aiPoint5 : ARRAY[1..2] OF INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PRG_Compute\nVAR\n structPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n structPentagon : S_PENTAGON := (aiStart:=[0,0], aiPoint1:=[1,1], aiPoint2:=[2,2], aiPoint3:=[3,3], aiPoint4:=[4,4], aiPoint5:=[5,5]);\n structLine0 : S_PENTA;\n pentaLine1 : S_PENTA;\n iXPoint: INT;\n aPoint0: ARRAY [1..2] OF INT;\n aPoint1: ARRAY [1..2] OF INT;\nEND_VAR\n\niXPoint := structPolygon.aiPoint1[1];\naPoint0 := structLine0.aiEnd;\naiPoint1 := pentaLine1.aiEnd; L'analisi statica segnala la seguente violazione della convenzione di denominazione: Nome variabile 'structLine0' non valido: prefisso previsto 'penta' " }, 
{ "title" : "ulteriore CODESYS Static Analysis - Fornire progetti con convenzioni di denominazione ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Definire le convenzioni di denominazione \/ ulteriore CODESYS Static Analysis - Fornire progetti con convenzioni di denominazione ", 
"snippet" : "Salva le tue convenzioni di denominazione in un file CSA. Puoi usare questo file in altri CODESYS Static Analysis -Carica e usa i progetti. Salva su file Scegli il comando Costruisci → Analisi statica → Impostazioni . Scegli il pulsante Risparmia sul computer . Si apre una finestra di dialogo per la...", 
"body" : "Salva le tue convenzioni di denominazione in un file CSA. Puoi usare questo file in altri CODESYS Static Analysis -Carica e usa i progetti. Salva su file Scegli il comando Costruisci → Analisi statica → Impostazioni . Scegli il pulsante Risparmia sul computer . Si apre una finestra di dialogo per la selezione dei file. Lì puoi memorizzare le convenzioni di denominazione in un file con qualsiasi nome con estensione CSA. Carica il file con le convenzioni di denominazione Scegli il comando Costruisci → Analisi statica → Impostazioni . Scegli il pulsante caricare . Si apre la finestra di dialogo per la selezione dei file. Selezionane uno dai file CSA visualizzati. " }, 
{ "title" : "Trova cloni di codice ", 
"url" : "_san_find_code_clone.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Trova cloni di codice ", 
"snippet" : "Requisiti: CODESYS Static Analysis È installato. Un  CODESYS il progetto è aperto. Il progetto prevede lo stesso blocco di codice in almeno due oggetti di programmazione. Clic  Costruisci → Analisi statica → Rileva cloni . La vista Clona i risultati della ricerca si apre. clicca su risultati . I clo...", 
"body" : "Requisiti: CODESYS Static Analysis È installato. Un  CODESYS il progetto è aperto. Il progetto prevede lo stesso blocco di codice in almeno due oggetti di programmazione. Clic  Costruisci → Analisi statica → Rileva cloni . La vista Clona i risultati della ricerca si apre. clicca su risultati . I cloni di codice trovati vengono visualizzati come una vista ad albero in una finestra. Se sono presenti cloni di codice con differenze oltre a cloni di codice identici, questi nodi figlio vengono evidenziati a colori nella vista ad albero. Nella vista ad albero, seleziona due cloni di codice di un nodo figlio e fai clic sul pulsante Mostra cloni selezionati . I due oggetti di programmazione contenenti questo codice duplicato vengono aperti nell'editor e visualizzati nella parte superiore della vista. I cloni di codice identici sono contrassegnati in giallo chiaro e i cloni di codice con differenze, come i nomi delle variabili in questo esempio ivar3 e ivarx , sono evidenziati in rosso. Per ottenere dal codice identico clone dell'oggetto di programmazione POU_1 Per creare una funzione, fare prima doppio clic sulla riga con il clone di codice nella vista ad albero oggetto POU_1 . L'oggetto di programmazione POU_1 si apre nell'editor e nella parte implementativa vengono evidenziate le quattro righe contenenti il codice duplicato. Se si utilizza il comando nel menu contestuale del blocco di codice selezionato funzione di estrazione selezionando , il blocco di codice si disattiva POU_1 estratto e un nuovo metodo creato da esso. Il blocco di codice nella parte di implementazione di POU_1 viene automaticamente sostituito chiamando il metodo. Nel secondo oggetto di programmazione è necessario rimuovere manualmente il codice duplicato e sostituirlo con la chiamata al metodo. In una versione successiva, la funzionalità verrà ampliata in modo tale che il blocco di codice duplicato possa essere estratto automaticamente da entrambi gli oggetti di programmazione e sostituito con la chiamata di funzione corretta. " }, 
{ "title" : "Propagazione costante ", 
"url" : "_san_constant_propagation.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagazione costante ", 
"snippet" : "Con il CODESYS Static Analysis versione V5.0.0.0, l'analisi del codice si basa sulla propagazione costante. I risultati della propagazione costante vengono utilizzati per vari controlli. Ad esempio, controlla se i puntatori non sono uguali a 0 o se gli indici dell'array non rientrano nell'intervallo...", 
"body" : "Con il CODESYS Static Analysis versione V5.0.0.0, l'analisi del codice si basa sulla propagazione costante. I risultati della propagazione costante vengono utilizzati per vari controlli. Ad esempio, controlla se i puntatori non sono uguali a 0 o se gli indici dell'array non rientrano nell'intervallo valido. Puoi supportare efficacemente l'analisi statica semplicemente conoscendo come funziona questa analisi e quali sono i suoi limiti. " }, 
{ "title" : "Propagazione costante ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078132035233833484992758", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagazione costante \/ Propagazione costante ", 
"snippet" : "L'analisi statica tenta di determinare il valore di una variabile in base al suo utilizzo. Esempio PROGRAM PLC_PRG \/\/Declaration VAR x: INT; bTest: BOOL; END_VAR \/\/Implementation x := 99; IF x < 100 THEN bTest := TRUE; END_IF Nell'implementazione della riga 1 la propagazione costante registra il val...", 
"body" : "L'analisi statica tenta di determinare il valore di una variabile in base al suo utilizzo. Esempio PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT;\n bTest: BOOL;\nEND_VAR \/\/Implementation\nx := 99;\nIF x < 100 THEN\n bTest := TRUE;\nEND_IF Nell'implementazione della riga 1 la propagazione costante registra il valore 99 per la variabile x utilizzare questo valore per ulteriori analisi. L'analisi riconosce quindi l'espressione seguente IF -Costante di istruzione TRUE È. " }, 
{ "title" : "Propagazione costante eseguita localmente ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4525765239721633833551650952", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagazione costante \/ Propagazione costante \/ Propagazione costante eseguita localmente ", 
"snippet" : "Un valore viene determinato solo localmente nel blocco funzione. È irrilevante il modo in cui viene passato un input. Anche i risultati delle chiamate di funzione sono irrilevanti. Esempio FUNCTION Func : BOOL \/\/Declaration VAR_INPUT bText : BOOL; END_VAR \/\/Implementation IF bTest THEN Func := Other...", 
"body" : "Un valore viene determinato solo localmente nel blocco funzione. È irrilevante il modo in cui viene passato un input. Anche i risultati delle chiamate di funzione sono irrilevanti. Esempio FUNCTION Func : BOOL\n\/\/Declaration\nVAR_INPUT\n bText : BOOL;\nEND_VAR \/\/Implementation\nIF bTest THEN\n Func := OtherFunc(TRUE);\nEND_IF Anche se il parametro bTest è impostato per TRUE ad ogni chiamata ciò non ha alcun effetto sulla propagazione costante. Anche se OtherFunc(TRUE) ritorna sempre TRUE , questo non ha alcun effetto sulla propagazione costante. " }, 
{ "title" : "Solo le variabili temporanee hanno valori iniziali. ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505885763755233833526533567", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagazione costante \/ Propagazione costante \/ Solo le variabili temporanee hanno valori iniziali. ", 
"snippet" : "Le variabili locali statiche nei programmi e nei blocchi funzione non hanno alcun valore iniziale presunto. Le variabili mantengono i valori dell'ultima chiamata e quindi in linea di principio possono essere \"qualsiasi cosa\". Le variabili locali nelle funzioni e le variabili temporanee hanno un valo...", 
"body" : "Le variabili locali statiche nei programmi e nei blocchi funzione non hanno alcun valore iniziale presunto. Le variabili mantengono i valori dell'ultima chiamata e quindi in linea di principio possono essere \"qualsiasi cosa\". Le variabili locali nelle funzioni e le variabili temporanee hanno un valore iniziale ad ogni chiamata. La propagazione costante viene calcolata con questo valore iniziale. Esempio PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT := 6;\n bTest: BOOL;\nEND_VAR\nVAR_TEMP\n y : INT := 8;\nEND_VAR bText := x < y; La variabile y viene eseguito ogni volta PLC_PRG hanno il valore 8. La variabile x , tuttavia, non necessariamente. Pertanto, la propagazione costante viene utilizzata solo per y assumere un valore, ma non per x . Si consiglia di dichiarare variabili che vengono sempre scritte prima e poi lette come variabili temporanee. " }, 
{ "title" : "La propagazione costante determina gli intervalli di valori per i tipi di dati numerici. ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078129465633833541363136", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagazione costante \/ Propagazione costante \/ La propagazione costante determina gli intervalli di valori per i tipi di dati numerici. ", 
"snippet" : "Per ridurre la complessità, per ciascuna variabile viene determinato un intervallo di valori con limiti superiore e inferiore. Esempio PROGRAM PLC_PRG VAR x: INT := 6; bTest: BOOL; y : INT; END_VAR \/\/Implementation IF bTest THEN x := 1; ELSSE x := 100; END_IF IF x = 77 THEN y := 13; END_IF Ecco l'in...", 
"body" : "Per ridurre la complessità, per ciascuna variabile viene determinato un intervallo di valori con limiti superiore e inferiore. Esempio PROGRAM PLC_PRG\nVAR\n x: INT := 6;\n bTest: BOOL;\n y : INT; \nEND_VAR\n \/\/Implementation\nIF bTest THEN\n x := 1;\nELSSE\n x := 100;\nEND_IF\nIF x = 77 THEN\n y := 13;\nEND_IF Ecco l'intervallo di valori [1..100] è determinato per la variabile x . Di conseguenza, alla riga 7, il confronto x = 77 non è riconosciuto come espressione costante perché 77 rientra nell'intervallo di valori. " }, 
{ "title" : "Le espressioni complesse ricorrenti non vengono riconosciute come la stessa variabile. ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4581954142281633833566535545", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagazione costante \/ Propagazione costante \/ Le espressioni complesse ricorrenti non vengono riconosciute come la stessa variabile. ", 
"snippet" : "Alle espressioni complesse potrebbe non essere assegnato un valore. Se tali espressioni ricorrono più volte, è utile introdurre una variabile ausiliaria. Esempio PROGRAM PLC_PRG VAR x: DINT; py : POINTER TO INT; y : INT; testArray : ARRAY [0..4] OF DINT; END_VAR \/\/Implementation IF py^ >= 0 AND py^<...", 
"body" : "Alle espressioni complesse potrebbe non essere assegnato un valore. Se tali espressioni ricorrono più volte, è utile introdurre una variabile ausiliaria. Esempio PROGRAM PLC_PRG\nVAR\n x: DINT;\n py : POINTER TO INT;\n y : INT; \n testArray : ARRAY [0..4] OF DINT; \nEND_VAR\n \/\/Implementation\nIF py^ >= 0 AND py^<= 4 THEN\n x := testArray[py^];\nEND_IF\ny := py^;\nIF y <= 0 AND y <=4 THEN\n x := testArray[y];\nEND_IF Alla riga 2 viene emesso un errore per un possibile accesso tramite puntatore ad un valore, sebbene venga controllata l'area puntata dal puntatore. Se il valore viene prima copiato in una variabile locale e il suo intervallo viene controllato, la propagazione costante può determinare l'intervallo di valori per quella variabile e consentire l'accesso all'array alla riga 7. " }, 
{ "title" : "Ramificazione ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078204272033833577361725", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagazione costante \/ Propagazione costante \/ Ramificazione ", 
"snippet" : "Per quanto riguarda la ramificazione, i singoli rami vengono calcolati separatamente. Gli intervalli di valori dei singoli intervalli vengono quindi combinati per formare un nuovo intervallo di valori. Esempio \/\/Implementation IF func(TRUE) THEN x := 1; ELSE x := 10; END_IF IF func(FALSE) THEN y := ...", 
"body" : "Per quanto riguarda la ramificazione, i singoli rami vengono calcolati separatamente. Gli intervalli di valori dei singoli intervalli vengono quindi combinati per formare un nuovo intervallo di valori. Esempio \/\/Implementation\nIF func(TRUE) THEN\n x := 1;\nELSE \n x := 10;\nEND_IF\n\nIF func(FALSE) THEN\n y := x;\nELSE\n Y := 2*x;\nEND_IF Sulla linea 6, x ha la portata [1..10] . Dopo la linea 11, y ha l'intervallo di valori [1..20] ; questo risulta dall'unione dei due intervalli di valori [1..10] E [2..20] . " }, 
{ "title" : "Condizioni ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505886343398433833583258632", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagazione costante \/ Propagazione costante \/ Condizioni ", 
"snippet" : "Esempio Le condizioni possono limitare l'intervallo di valori di una variabile in un blocco di codice. È possibile combinare diverse condizioni. Condizioni che si escludono a vicenda possono anche risultare in un intervallo di valori vuoto. IF y > 0 AND y < 10 THEN x := y; ELSE x:= 0; END_IF IF x < ...", 
"body" : "Esempio Le condizioni possono limitare l'intervallo di valori di una variabile in un blocco di codice. È possibile combinare diverse condizioni. Condizioni che si escludono a vicenda possono anche risultare in un intervallo di valori vuoto. IF y > 0 AND y < 10 THEN\n x := y;\nELSE\n x:= 0;\nEND_IF\nIF x < 0 THEN\n i := 99;\nEND_IF y ha l'intervallo di valori [1..9] sulla riga 2. Ciò risulta nell'intervallo di valori [0..9] per x alla riga 6. Combinato con la condizione x < 0 , il risultato è un insieme vuoto di possibili valori per x alla riga 8. Il codice non è accessibile. L'analisi statica riporterà la condizione x < 0 ritorna sempre FALSE a questo punto. " }, 
{ "title" : "Ciclo ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4649940201660833833593476437", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagazione costante \/ Propagazione costante \/ Ciclo ", 
"snippet" : "La propagazione costante eseguirà il loop del codice finché i valori delle variabili nel loop non cambieranno più. Si presuppone che un ciclo possa essere eseguito un numero qualsiasi di volte. I valori finora determinati vengono combinati con i valori precedenti. Le variabili che vengono modificate...", 
"body" : "La propagazione costante eseguirà il loop del codice finché i valori delle variabili nel loop non cambieranno più. Si presuppone che un ciclo possa essere eseguito un numero qualsiasi di volte. I valori finora determinati vengono combinati con i valori precedenti. Le variabili che vengono modificate all'interno del ciclo hanno un intervallo crescente. In questo caso la propagazione costante non accetta tutti i valori possibili per gli intervalli, ma utilizza solo i limiti presenti nel codice e anche i valori 0, 1, 2, 3 e 10 perché questi sono spesso rilevanti. Esempio Il modo più semplice per descrivere la procedura è tramite un esempio: PROGRAM PLC_PRG\nVAR\n x: DINT;\n i : DINT;\n y : DINT;\nEND_VAR \/\/Implementation\nx := 0;\ny := 0;\nFOR i := 0 TO 5 DO\n x := x + 1;\n y := i;\nEND_FOR La propagazione costante conosce quanto segue riguardo al ciclo: i , x , E y sono 0 all'inizio della prima esecuzione del ciclo. La condizione i <= 5 si applica al codice nel loop. La condizione i > 5 si applica al codice dopo il ciclo. Per i valori delle variabili nel ciclo, la propagazione costante determina i seguenti valori: i x y [0..5] [0..MAXDINT] [0..5] Nel dettaglio si attraversano i seguenti passaggi intermedi: Passaggio i x y 1 0 [0..1] 0 i è stato inizializzato con 0; y ottiene sempre gli stessi valori di i. 2 [0..1] [0..2] [0..1] 6 [0..5] [0..6] [0..5] Innanzitutto, la gamma [0..6] è effettivamente calcolato i . Questo però è noto i < 5 è una condizione. Pertanto, il valore del codice nel ciclo è limitato a questo valore. 7 [0..5] [0..7] [0..5] 10 [0..5] [0..10] [0..5] x viene incrementato sempre di più. Da 10 , tuttavia, il valore viene \"arrotondato per eccesso\" a MAXINT . 11 [0..5] [0..MAXDINT] [0..5] MAXDINT + 1 risultati in MAXDINT A partire dalle 11 Dall'undicesimo passaggio i valori nel ciclo non cambieranno. La propagazione è terminata. Inoltre, i = 6 si applica al codice che segue questo ciclo. La gamma [0..6] viene determinato nel ciclo e questo viene combinato con la condizione i > 5 , che risulta esattamente nel valore 6. " }, 
{ "title" : "Riferimento: Interfaccia Utente ", 
"url" : "_san_f_reference_user_interface.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "comandi ", 
"url" : "_san_struct_reference_commands.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comando: Estrai funzione ", 
"url" : "_san_cmd_extract_function.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Estrai funzione ", 
"snippet" : "Funzione di estrazione funzione : Il comando apre la finestra di dialogo Configurazione per l'estrazione della funzione . Il comando estrae le posizioni di codice selezionate dall'editor ST e crea un nuovo metodo o funzione che contiene questo codice. Il codice interessato nell'editor ST viene sosti...", 
"body" : "Funzione di estrazione funzione : Il comando apre la finestra di dialogo Configurazione per l'estrazione della funzione . Il comando estrae le posizioni di codice selezionate dall'editor ST e crea un nuovo metodo o funzione che contiene questo codice. Il codice interessato nell'editor ST viene sostituito con una chiamata corretta. Quando il codice viene estratto da un blocco funzione o dal figlio di un blocco funzione, dal codice viene creato un nuovo metodo. Quando il codice viene estratto da un programma o da una funzione, dal codice viene creata una nuova funzione. Notare anche in questo contesto: Trova cloni di codicechiamata : menù contestuale refactoring requisiti , se il codice selezionato è composto da una o più affermazioni: Il codice selezionato non contiene errori di traduzione Il codice selezionato si trova nella parte di implementazione di un blocco di programmazione ST Il codice selezionato non contiene salti in uscita Esempi di salti in uscita sono: Lascia la funzione circostante con RETURN Esci da un ciclo che racchiude il codice con CONTINUE o EXIT Puoi farlo con il comando funzione di estrazione annulla le modifiche apportate al tuo progetto posizionando il cursore nell'albero dei dispositivi e il comando Modifica → Annulla Selezionare. dialogo Configurazione per l'estrazione della funzione Cognome Nome per la funzione o il metodo appena creato Il nome immesso per impostazione predefinita può essere modificato. valore di ritorno Determinazione del valore di ritorno di una funzione quando sono presenti più parametri di output e\/o input\/output parametro Visualizzazione delle POU disponibili Configurazione se i parametri vengono utilizzati come variabili di input, output o input\/output : variabili di input : variabili di uscita : variabili di ingresso\/uscita L'at Cognome , valore di ritorno o parametro le modifiche apportate vengono annullate. Finestra del codice superiore Codice appena creato del punto di chiamata Finestra del codice inferiore Codice appena creato della funzione o del metodo ok Le modifiche al codice visualizzate vengono acquisite nei blocchi ST e la finestra di dialogo viene chiusa. Interrompere Le modifiche al codice visualizzato vengono annullate e la finestra di dialogo viene chiusa. " }, 
{ "title" : "Comando: Inverti istruzione IF ", 
"url" : "_san_cmd_invert_if_statement.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Inverti istruzione IF ", 
"snippet" : "Inverti istruzione IF Funzione : Questo comando inverte il IF istruzione senza modificare la semantica di IF dichiarazione. La condizione è negata. Le dichiarazioni in THEN E ELSE i rami vengono scambiati. Tutti i commenti vengono conservati. Chiamata : menu contestuale sotto Refactoring comando Pre...", 
"body" : "Inverti istruzione IF Funzione : Questo comando inverte il IF istruzione senza modificare la semantica di IF dichiarazione. La condizione è negata. Le dichiarazioni in THEN E ELSE i rami vengono scambiati. Tutti i commenti vengono conservati. Chiamata : menu contestuale sotto Refactoring comando Presupposto: il cursore è posizionato ovunque entro UN IF dichiarazione. Regole per la negazione Espressione Espressione negata Descrizione < >= Il confronto su “minore di” diventa “maggiore di” e viceversa. <= > Il confronto su “minore o uguale a” diventa “maggiore di” e viceversa. = <> Il confronto su “è uguale” diventa “non è uguale” e viceversa. <espressione1> AND <espressione2> ( NOT <espressione1> ) OR ( NOT <espressione2> ) Negazione secondo De Morgan per AND operatore <espressione1> OR <espressione2> (NOT <espressione1> ) AND (NOT <espressione2> ) Negazione secondo De Morgan per OR operatore <espressione> NOT <espressione> Negazione standard NOT <espressione> <espressione> Nessun doppio NOT espressione a (*commento*) = b a (*commento*) <> b I commenti vengono conservati. Ciò vale soprattutto per gli operandi scambiati Esempio PROGRAM Inversion1\nVAR\n xA, xB, xC : BOOL;\n iVar : INT;\nEND_VAR iVar := 0;\nIF NOT(xA AND xB AND xC) THEN\n\tiVar:= 1; (* IF 1 *)\nELSE\n\tiVar := iVar + 1; (* ELSE counter*)\nEND_IFiVar := 0;\n Codice dopo aver chiamato il comando con logica invertita con la stessa semantica: iVar := 0;\nIF (xA AND xB AND xC) THEN\n iVar := iVar + 1; (* ELSE counter*)\nELSE\n iVar:= 1; (* IF 1 *)\nEND_IF " }, 
{ "title" : "Comando: Mostra valori di propagazione costante per l'editor corrente ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Mostra valori di propagazione costante per l'editor corrente ", 
"snippet" : "Mostra valori di propagazione costante per l'editor corrente Simbolo: Funzione : Il comando avvia l'analisi statica del codice e calcola un valore misurato per la propagazione costante del codice nell'editor corrente. La finestra di dialogo che si apre visualizza il risultato. Il codice analizzato v...", 
"body" : "Mostra valori di propagazione costante per l'editor corrente Simbolo: Funzione : Il comando avvia l'analisi statica del codice e calcola un valore misurato per la propagazione costante del codice nell'editor corrente. La finestra di dialogo che si apre visualizza il risultato. Il codice analizzato viene elencato e vengono visualizzati i valori misurati rilevati. Chiamata : Costruisci → Analisi statica menù Requisiti : Nell'editor è aperto un oggetto di programmazione nel linguaggio di implementazione ST. Per ulteriori informazioni, vedere: Propagazione costante" }, 
{ "title" : "Dialogo: risultati della propagazione costante ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html#UUID-948900c6-97a3-c88d-ff29-bca9a5de0d7b_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Mostra valori di propagazione costante per l'editor corrente \/ Dialogo: risultati della propagazione costante ", 
"snippet" : "Esempio...", 
"body" : "Esempio " }, 
{ "title" : "Comando: Esegui analisi statica ", 
"url" : "_san_cmd_run_static_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Esegui analisi statica ", 
"snippet" : "Esegui analisi statica Simbolo: funzione : il comando avvia l'analisi del codice statico per l'applicazione attiva e visualizza le metriche per tutti i blocchi di programmazione in una tabella. chiamata : Menù Crea → Analisi statica Leader nell'analisi del codice CODESYS Static Analysis una generazi...", 
"body" : "Esegui analisi statica Simbolo: funzione : il comando avvia l'analisi del codice statico per l'applicazione attiva e visualizza le metriche per tutti i blocchi di programmazione in una tabella. chiamata : Menù Crea → Analisi statica Leader nell'analisi del codice CODESYS Static Analysis una generazione di codice tramite, oltre che con il comando Crea → Genera codice . I risultati dell'analisi vengono visualizzati nella finestra dei messaggi nella categoria Tradurre come un errore e avvertimenti rilasciato. I numeri si riferiscono a quelli corrispondenti regole , come definito nelle impostazioni del progetto. La sintassi per l'output del messaggio è SA<numero regola>:<testo regola> . " }, 
{ "title" : "Comando: Impostazioni ", 
"url" : "_san_cmd_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Impostazioni ", 
"snippet" : "Impostazioni funzione : Il comando apre la finestra di dialogo Impostazioni Analisi statica . chiamata : Menù Crea → Analisi statica Requisiti : Il pacchetto CODESYS Static Analysis È installato. Un progetto è aperto...", 
"body" : "Impostazioni funzione : Il comando apre la finestra di dialogo Impostazioni Analisi statica . chiamata : Menù Crea → Analisi statica Requisiti : Il pacchetto CODESYS Static Analysis È installato. Un progetto è aperto " }, 
{ "title" : "Comando: Visualizza metriche standard ", 
"url" : "_san_cmd_view_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Visualizza metriche standard ", 
"snippet" : "Visualizza metriche standard Simbolo: Funzione : Il comando avvia l'analisi del codice statico per l'applicazione attiva. Le metriche predefinite per tutti i blocchi di programmazione vengono quindi calcolate e visualizzate in una tabella sul Metriche standard scheda. Chiamata : Costruisci → Analisi...", 
"body" : "Visualizza metriche standard Simbolo: Funzione : Il comando avvia l'analisi del codice statico per l'applicazione attiva. Le metriche predefinite per tutti i blocchi di programmazione vengono quindi calcolate e visualizzate in una tabella sul Metriche standard scheda. Chiamata : Costruisci → Analisi statica menù Per ulteriori informazioni, vedere: Visualizzazione delle metricheMetrica" }, 
{ "title" : "Scheda: Metriche standard ", 
"url" : "_san_cmd_view_standard_metrics.html#UUID-c2310f81-c613-bf67-ba1e-4f10694a38a1_section-idm4622240725232033866114829692", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Visualizza metriche standard \/ Scheda: Metriche standard ", 
"snippet" : "Esempio Nel Impostazioni di analisi statica: Metriche finestra di dialogo, è possibile modificare la configurazione delle metriche. È possibile disabilitare il calcolo per una metrica. Inoltre, puoi definire valori limite per metriche specifiche. Se un valore non rientra nei limiti superiore e infer...", 
"body" : "Esempio Nel Impostazioni di analisi statica: Metriche finestra di dialogo, è possibile modificare la configurazione delle metriche. È possibile disabilitare il calcolo per una metrica. Inoltre, puoi definire valori limite per metriche specifiche. Se un valore non rientra nei limiti superiore e inferiore configurati, il campo nella tabella viene evidenziato in rosso. Nel menu contestuale della tabella sono disponibili i seguenti comandi: Calcolare Aggiorna i valori Copia tabella Copia la tabella negli appunti Il separatore è una scheda. Stampa tabella Apre la finestra di dialogo predefinita per impostare il lavoro di stampa Tabella di esportazione Esporta la tabella in un file CSV Il separatore è un punto e virgola. Diagramma di Kiviat Requisito: sono abilitati almeno tre parametri a cui sono stati definiti i limiti superiore e inferiore. Rappresenta i parametri per il blocco funzione selezionato come un grafico radar Questo visualizza la qualità del codice POU rispetto ad un dato standard. Ogni metrica è rappresentata come un asse con la sua origine al centro (valore 0) che si irradia verso l'esterno in tre zone ad anello concentriche. La zona dell'anello interno rappresenta l'intervallo di valori al di sotto del limite inferiore definito per la metrica. L'anello esterno rappresenta l'intervallo di valori al di sopra del limite superiore. Gli assi delle metriche sono distribuiti uniformemente attorno al cerchio. I valori correnti delle singole metriche sugli assi sono collegati da una linea. Nel caso ideale, la linea completa si trova nella zona centrale. Configura Apre la tabella per selezionare le metriche desiderate Ciò corrisponde alla tabella nelle impostazioni del progetto. Apri POU Apre l'editor con la POU Esempio Esempio di diagramma Kiviat per cinque metriche Il nome della metrica viene visualizzato alla fine del rispettivo asse e il nome della POU viene visualizzato nell'angolo in alto a destra del diagramma. " }, 
{ "title" : "Comando: Calcola ed esporta metriche standard ", 
"url" : "_san_calculate_and_export_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Calcola ed esporta metriche standard ", 
"snippet" : "Calcola ed esporta metriche standard Funzione: Calcola ed esporta direttamente le metriche standard senza visualizzare la tabella delle metriche nell'editor. Specificare un nome adatto per il file di esportazione CSV nella finestra di dialogo file standard. Chiama: questo comando non è disponibile i...", 
"body" : "Calcola ed esporta metriche standard Funzione: Calcola ed esporta direttamente le metriche standard senza visualizzare la tabella delle metriche nell'editor. Specificare un nome adatto per il file di esportazione CSV nella finestra di dialogo file standard. Chiama: questo comando non è disponibile in nessun menu per impostazione predefinita. In alternativa, potresti anche usare il file Mostra metriche standard comando per visualizzare le metriche nell'editor. Tra le altre cose, l'editore fornisce il file Tabella di esportazione comando di contesto. Personalizzazione del Menù Fornire il comando Clic Strumenti → Personalizza . IL Menù si apre la scheda. Per prima cosa è necessario definire una posizione nel menu per il comando. In questo caso ha senso selezionare un elemento sotto il file Costruisci → Analisi statica menù. Selezionare la posizione desiderata e fare clic su Aggiungi comando pulsante. Tutti i comandi sono elencati nel file Aggiungi comando dialogo. Seleziona il Analisi statica categoria sul lato sinistro e poi il comando desiderato sul lato destro. Clic OK per chiudere la finestra di dialogo. Quindi fare clic OK di nuovo per chiudere il personalizzare dialogo. IL Calcola ed esporta metriche standard il comando è ora disponibile nel file Costruisci → Analisi statica menù. " }, 
{ "title" : "Comando: trova cloni ", 
"url" : "_san_cmd_find_clones.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: trova cloni ", 
"snippet" : "Rileva cloni funzione : Il comando ricerca il codice di programma dell'open CODESYS -Progetto per il codice copiato e apre la vista Clona i risultati della ricerca per visualizzare i blocchi di codice clonati trovati. Solo i blocchi di codice più grandi di una certa dimensione sono considerati cloni...", 
"body" : "Rileva cloni funzione : Il comando ricerca il codice di programma dell'open CODESYS -Progetto per il codice copiato e apre la vista Clona i risultati della ricerca per visualizzare i blocchi di codice clonati trovati. Solo i blocchi di codice più grandi di una certa dimensione sono considerati cloni. Pezzi di codice molto piccoli non appariranno come cloni. In questo contesto, prestare attenzione anche a Funzione di estrazione e il Trova cloni di codice Istruzioni. chiamata : menù Crea → Analisi statica menù contestuale Analisi statica Requisiti : Il CODESYS Static Analysis -Il progetto è aperto. Due codici sono considerati cloni se hanno le seguenti proprietà: Stesso disegno strutturale Le variabili hanno lo stesso tipo di dati I nomi delle variabili possono essere diversi (eccezione: accesso ai componenti). Tuttavia, un identificatore contenuto più di una volta nel codice deve trovarsi nella stessa posizione in entrambi i codici. I letterali hanno lo stesso tipo di dati I letterali possono essere diversi. Un valore letterale che appare più volte nel codice deve apparire nella stessa posizione in entrambi i codici. opinione Clona i risultati della ricerca riepilogo Scheda per visualizzare il risultato della ricerca Numero di blocchi di codice clonati trovati Numero di affermazioni confrontate Numero di istruzioni nel codice clonato clonare parte : Specifica in percentuale: Numero di istruzioni nel codice clonato \/ Numero di affermazioni confrontate risultati Nella scheda, i cloni del codice vengono visualizzati in una vista ad albero e sono disponibili comandi e opzioni di filtro. La prima occorrenza di un duplicato dall'insieme di duplicati viene presa come nodo radice. Il colore di sfondo dei nodi figlio indica se il codice è diverso o identico. Gli stessi colori significano \"stesso codice\". I contenuti della vista ad albero sono ordinati in ordine decrescente in base al numero di istruzioni nel codice duplicato. Comandi e filtri nella scheda risultati sottomoduli\/clone Numero di sottomoduli (istruzioni) nel blocco di codice Se il numero di sottomoduli è inferiore a 20, il codice clone non verrà considerato Filtra per oggetto Campo di immissione per a oggetto , mediante il quale viene filtrata la raccolta di cloni Mostra cloni selezionati Requisito: sono selezionati due nodi figlio dello stesso nodo padre. I due oggetti di programmazione vengono visualizzati nella parte superiore della vista per il confronto. I duplicati del codice sono contrassegnati e le differenze (es. nomi di variabili differenti) sono evidenziate con un colore diverso. Elenco dei cloni di codice colonne descrizione sottomodulo\/clone oggetto posizione Facendo doppio clic su un nodo figlio si apre l'oggetto di programmazione corrispondente, dove viene selezionato il blocco di codice duplicato. " }, 
{ "title" : "Comando: Mostra complessità cognitiva per l'editor corrente ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Mostra complessità cognitiva per l'editor corrente ", 
"snippet" : "Mostra complessità cognitiva per l'editor corrente Simbolo: Funzione : Il comando avvia l'analisi statica del codice e calcola un valore misurato per la complessità cognitiva del codice nell'editor corrente. La finestra di dialogo che si apre visualizza il risultato e specifica la somma dei valori m...", 
"body" : "Mostra complessità cognitiva per l'editor corrente Simbolo: Funzione : Il comando avvia l'analisi statica del codice e calcola un valore misurato per la complessità cognitiva del codice nell'editor corrente. La finestra di dialogo che si apre visualizza il risultato e specifica la somma dei valori misurati nel titolo. Il codice analizzato viene elencato e visualizzato con le complessità rilevate. Chiamata : Costruisci → Analisi statica menù Requisiti : Nell'editor è aperto un oggetto di programmazione nel linguaggio di implementazione ST. " }, 
{ "title" : "Finestra di dialogo: Complessità cognitiva di <nome POU>: <valore misurato calcolato> ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html#UUID-315a7cbe-83be-ba91-4d86-234b9f3e6fc3_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Mostra complessità cognitiva per l'editor corrente \/ Finestra di dialogo: Complessità cognitiva di <nome POU>: <valore misurato calcolato> ", 
"snippet" : "Esempio...", 
"body" : "Esempio " }, 
{ "title" : "Comando: Esegui l'analisi statica ed esporta nel file SARIF ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Esegui l'analisi statica ed esporta nel file SARIF ", 
"snippet" : "Esegui l'analisi statica ed esporta nel file SARIF Simbolo: Funzione : Questo comando avvia l'analisi statica del codice e salva il risultato in un file SARIF. Chiamata : Costruisci → Analisi statica menù Un file SARIF (» Formato di interscambio dei risultati dell'analisi statica «) è un file JSON l...", 
"body" : "Esegui l'analisi statica ed esporta nel file SARIF Simbolo: Funzione : Questo comando avvia l'analisi statica del codice e salva il risultato in un file SARIF. Chiamata : Costruisci → Analisi statica menù Un file SARIF (» Formato di interscambio dei risultati dell'analisi statica «) è un file JSON leggibile dalla macchina con l'estensione\" *.sarif.json \"creato da Static Analysis per archiviare i risultati in un formato standardizzato. Il SARIF è uno standard OASIS. Ciò significa che vari strumenti e piattaforme possono utilizzarlo per scambiare ed elaborare i risultati delle analisi " }, 
{ "title" : "Comandi da riga di comando ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html#UUID-b1a6530c-4103-8c37-7a9e-f6ad763d2402_section-idm235003337576496", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Esegui l'analisi statica ed esporta nel file SARIF \/ Comandi da riga di comando ", 
"snippet" : "Il comando può essere eseguito anche automaticamente tramite CODESYS Scripting . Il comando batch [\"staticanalysis\", \"runandexportosarif\"] accetta gli argomenti seguenti. Argomento: --sariffile --sariffile=<path to output>; Specifica il percorso in cui deve essere scritto il file SARIF risultante. S...", 
"body" : "Il comando può essere eseguito anche automaticamente tramite CODESYS Scripting . Il comando batch [\"staticanalysis\", \"runandexportosarif\"] accetta gli argomenti seguenti. Argomento: --sariffile --sariffile=<path to output>; Specifica il percorso in cui deve essere scritto il file SARIF risultante. Se non si specifica un percorso, il file viene salvato nella cartella del progetto corrente Argomento: --rulesfile --rulesfile=<patch to CSA file>; Specificate il percorso di un file CSA da utilizzare per l'analisi statica. Se non si specifica un percorso, viene utilizzata la configurazione corrente Esempio di chiamata in uno script Python system.commands[\"staticanalysis\", \"runandexportosarif\"].execute(\"--sariffile=result.sarif\", \"--rulesfile=rules.csa\") " }, 
{ "title" : "Comando: Formato ", 
"url" : "_san_cmd_format.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ comandi \/ Comando: Formato ", 
"snippet" : "Formato Modalità di debug Questa funzionalità è disponibile solo quando il tuo CODESYS l'istanza viene avviata in modalità debug. Per fare ciò, avvia l'istanza con la seguente chiamata alla riga di comando: codesys.exe --debug Funzione : Il comando formatta un oggetto ST secondo le regole configurat...", 
"body" : "Formato Modalità di debug Questa funzionalità è disponibile solo quando il tuo CODESYS l'istanza viene avviata in modalità debug. Per fare ciò, avvia l'istanza con la seguente chiamata alla riga di comando: codesys.exe --debug Funzione : Il comando formatta un oggetto ST secondo le regole configurate nel file CODESYS opzioni per migliorare la leggibilità del codice. Chiamata : Menu contestuale sotto Refactoring menù Presupposto: Un editor ST è aperto e il cursore si trova all'interno di una dichiarazione o di un'implementazione. Per ulteriori informazioni, vedere: Formattazione automatica" }, 
{ "title" : "dialoghi ", 
"url" : "_san_struct_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ dialoghi ", 
"snippet" : "Per le finestre di dialogo per la configurazione dell'analisi del codice statico, fare clic su Costruisci → Analisi statica → Impostazioni . Requisito: A CODESYS il progetto deve essere aperto....", 
"body" : "Per le finestre di dialogo per la configurazione dell'analisi del codice statico, fare clic su Costruisci → Analisi statica → Impostazioni . Requisito: A CODESYS il progetto deve essere aperto. " }, 
{ "title" : "Finestra di dialogo: Impostazioni Analisi statica: Impostazioni ", 
"url" : "_san_dlg_settings_static_analysis_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ dialoghi \/ Finestra di dialogo: Impostazioni Analisi statica: Impostazioni ", 
"snippet" : "Impostazioni Funzione : Nella finestra di dialogo attivare l'automatico analisi del codice statico e salva o carica le impostazioni del progetto per l'analisi del codice statico come file CSA. pulsante Apri la finestra di configurazione in Progetto → Impostazioni progetto , categoria Analisi del cod...", 
"body" : "Impostazioni Funzione : Nella finestra di dialogo attivare l'automatico analisi del codice statico e salva o carica le impostazioni del progetto per l'analisi del codice statico come file CSA. pulsante Apri la finestra di configurazione in Progetto → Impostazioni progetto , categoria Analisi del codice statico menù Costruisci → Analisi statica → Impostazioni Requisiti : Il pacchetto CODESYS Static Analysis È installato Un progetto è aperto Eseguire automaticamente l'analisi statica : CODESYS Static Analysis esegue automaticamente il controllo del codice ogni volta che viene generato il codice, ad esempio quando viene eseguito il comando Crea → Genera codice o prima di un download. : La revisione del codice non viene eseguita automaticamente, ma può essere eseguita esplicitamente tramite il comando Costruisci → Analisi statica → Esegui analisi statica essere eseguito. caricare Apre la finestra di dialogo standard Carica la configurazione dell'analisi statica per caricare le impostazioni del progetto per l'analisi statica come file csa dal file system. Se fai clic sul pulsante Aprire fare clic, il file csa selezionato viene caricato. Risparmia sul computer Apre la finestra di dialogo standard Salvare la configurazione dell'analisi statica per salvare tutte le impostazioni del progetto della categoria Analisi del codice statico come file csa nel file system. " }, 
{ "title" : "Finestra di dialogo: Impostazioni analisi statica: Regole ", 
"url" : "_san_dlg_settings_sa_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ dialoghi \/ Finestra di dialogo: Impostazioni analisi statica: Regole ", 
"snippet" : "Regole Funzione : Nella finestra di dialogo selezionare il regole che vengono controllati durante l'analisi statica del codice sorgente di un progetto. Per ulteriori informazioni, vedere: Configurazione ed esecuzione dell'analisi staticaChiamata : Progetto → Impostazioni progetto menù, Analisi stati...", 
"body" : "Regole Funzione : Nella finestra di dialogo selezionare il regole che vengono controllati durante l'analisi statica del codice sorgente di un progetto. Per ulteriori informazioni, vedere: Configurazione ed esecuzione dell'analisi staticaChiamata : Progetto → Impostazioni progetto menù, Analisi statica categoria, Apri la finestra di dialogo di configurazione collegamento Compila → Analisi statica → Impostazioni menù Requisiti : IL CODESYS Static Analysis il pacchetto è installato. Un progetto è aperto. Questa scheda mostra una struttura ad albero di tutte le regole che possono essere controllate durante l'analisi statica. Per impostazione predefinita, tutte le regole sono attivate, ad eccezione di SA0016, SA0024, SA0073, SA0101, SA0105, SA0106, SA0133, SA0134, SA0150, SA0162 e tutte le \"rigorose regole IEC\". Ogni regola ha un numero univoco. Quando la regola viene controllata e viene rilevata una violazione, il numero della regola e una descrizione dell'errore vengono visualizzati nella visualizzazione dei messaggi nel file Costruire categoria nel seguente formato: SA<numero regola> , dove \"SA\" sta per \"Analisi statica\" (esempio: \"SA003\" per la regola 3). L'elenco delle regole disponibili può essere ampliato mediante plug-in specifici. Filtro Campo di input per le stringhe da cercare Le regole sono raggruppate per categoria. Strutturato per importanza : Ordinamento per Importanza alta , Importanza media , E Importanza bassa Predefinito : Strutturazione predefinita delle regole in CODESYS Static Analysis : le regole vengono visualizzate come un elenco semplice. Facendo clic sull'intestazione della colonna corrispondente, l'elenco può essere ordinato per numero di regola, attivazione\/disattivazione, configurazione specifica della regola o importanza. Alcune regole attivate nella finestra di dialogo possono essere disattivate temporaneamente nell'applicazione applicando a pragma . Quando si fa clic sulla casella di controllo, l'impostazione alterna tra , , E . Quando attivi o disattivi un nodo genitore, anche tutte le regole figlie vengono rispettivamente attivate o disattivate. Colonne Regole Elenco delle regole con numero di regola Controllo delle regole : La regola non è controllata. : Se l'esito del controllo è positivo, allora viene visualizzato un errore ( ) per l'analisi statica viene emesso nella visualizzazione dei messaggi. : Se l'esito del controllo è positivo appare un avviso ( ) per l'analisi statica viene emesso nella visualizzazione dei messaggi. Precompilare : Le regole che possono essere controllate durante la precompilazione sono identificate da un segno di spunta ( ) in questa colonna. Ciò significa che le regole sono già controllate quando si inserisce il codice. Per queste regole è possibile una correzione immediata dei bug (Quickfix). È possibile eseguire una gestione degli errori automatica e immediata direttamente nelle posizioni del codice interessate. : Le regole che non sono contrassegnate vengono controllate solo dopo una compilazione riuscita. Configurazione specifica della regola Per alcune regole, puoi fare doppio clic sul campo per aprire una finestra di dialogo specifica per configurare la regola. Importanza : Importanza della regola: 3 stelle rosse: alte 2 stelle arancioni: medie 1 stella grigia: bassa " }, 
{ "title" : "Finestra di dialogo: Impostazioni dell'analisi statica: Convenzioni di denominazione ", 
"url" : "_san_dlg_settings_sa_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ dialoghi \/ Finestra di dialogo: Impostazioni dell'analisi statica: Convenzioni di denominazione ", 
"snippet" : "Convenzioni di denominazione funzione : Nel dialogo definire i prefissi per i tipi di dati e gli ambiti delle variabili, nonché i prefissi per le POU e i tipi di dati definiti dall'utente (DUT). il osservanza delle convenzioni di denominazione è verificata dall'analisi del codice statico. Per l'anal...", 
"body" : "Convenzioni di denominazione funzione : Nel dialogo definire i prefissi per i tipi di dati e gli ambiti delle variabili, nonché i prefissi per le POU e i tipi di dati definiti dall'utente (DUT). il osservanza delle convenzioni di denominazione è verificata dall'analisi del codice statico. Per l'analisi del codice statico, se una convenzione viene violata, nella vista viene visualizzato un messaggio di errore messaggi visualizzato. Maggiori informazioni su questo: Configurazione ed esecuzione dell'analisi staticachiamata : pulsante Apri la finestra di configurazione nel menu Progetto → Impostazioni progetto , categoria Analisi del codice statico menù Costruisci → Analisi statica → Impostazioni Requisiti : Il pacchetto CODESYS Static Analysis È installato Un progetto è aperto I messaggi di errore sono nel modulo NC <Präfix-Konventionsnummer> : <Meldungstext> visualizzato. NC sta per Convenzione di denominazione. Ad esempio, il messaggio di errore significa NC0102: Nome non valido... una violazione della convenzione di denominazione 102 per le POU di tipo PROGRAM . Puoi per single identificatore le convenzioni di denominazione con il pragma 'naming' disattivare. Gli identificatori possono quindi iniziare a piacimento e non necessariamente con il prefisso. filtro Campo di immissione per la stringa di caratteri da cercare Tabella delle convenzioni di denominazione nomi Nodi ed elementi per i quali è possibile definire un prefisso Il numero tra parentesi dopo ogni elemento, ad esempio PROGRAMMA (102) , è il numero di convenzione del prefisso che viene restituito quando viene violata la convenzione di denominazione. prefisso Campo di immissione per il prefisso È possibile inserire più prefissi, separati da virgole. Esempio: Prefisso per POU , PROGRAM (102) : prog, PRG_ Prefisso per POU , FUNCTION (103) : fun, FUN_ Le espressioni regolari (RegEx) sono possibili anche per i prefissi. Per questo è necessario un @ essere preceduto. Esempio: Il nome deve accompagnarlo x iniziare e quindi aggiungere un altro personaggio all'area a-dA-D contenere: @x[a-dA-D] Per le variabili del tipo di dati Alias e per i building block (POU) del tipo di dati Proprietà il prefisso con il segnaposto {datatype} Da definire Prefissi per variabili Hub organizzativo per tutte le variabili che possono essere definite con un prefisso dipendente dal tipo di dati o dall'ambito Prefissi per POU Nodo organizzativo per tutti i tipi di POU e gli ambiti del metodo per i quali è possibile definire un prefisso Prefissi per DUT Nodo organizzativo per la struttura dei tipi di dati DUT, l'enumerazione, l'alias o l'unione per cui è possibile definire un prefisso Prefissi di tipo personalizzati Hub organizzativo per tipi speciali definiti dall'utente, in particolare quelli delle librerie Puoi espandere l'elenco delle convenzioni: clicca sulla riga vuota sottostante. Quindi inserisci un nome di tipo personalizzato o seleziona un tipo personalizzato nella finestra di dialogo aiuto di input fuori. È possibile eliminare una convenzione selezionandola e premendo il pulsante distanza Selezionare. Nota Queste convenzioni hanno la precedenza sui prefissi associati all'attributo {attribute 'nameprefix' := '<prefix>'} Sono definiti. opzioni Il primo carattere dopo il prefisso deve essere maiuscolo : L'analisi del codice statico segnala un errore per una variabile se il primo carattere del nome della variabile dopo il prefisso definito non è maiuscolo. Combina il prefisso dello spazio dei nomi con il prefisso del tipo di dati : una variabile deve avere il prefisso definito per il proprio spazio dei nomi, seguito dal prefisso definito per il tipo di dati. Esempio: sono definiti i seguenti prefissi: For VAR_GLOBALE g_ , per tipo di dati VERO r . L'analisi del codice riporta gli errori per le variabili REAL globali che non hanno il prefisso g_r . : se sono state specificate convenzioni per lo spazio dei nomi per una variabile, queste convenzioni vengono prese in considerazione. Eventuali convenzioni sui tipi di dati vengono quindi ignorate. Esempio: sono definiti i seguenti prefissi: For VAR_GLOBALE g_ , per tipo di dati VERO r . L'analisi del codice riporta esclusivamente errori per global REAL variabili che non hanno il prefisso g_ . Prefissi ricorsivi per tipi di dati combinabili : le variabili di tipi di dati combinati devono avere prefissi composti conformi alle convenzioni di denominazione definite. Esempio: ppiVariable : POINTER TO POINTER TO INT; Per le variabili del tipo di dati POINTER TO divenne il prefisso p definito per il tipo di dati INT il prefisso i . L'analisi statica riporta gli errori per tutte le variabili di tipo POINTER TO POINTER TO INT che non hanno il prefisso ppi . refaiVar : REFERENCE TO ARRAY[1..3] OF INT; Per il tipo di dati REFERENCE TO divenne il prefisso ref definisce, per un array, il prefisso a e per il tipo di dati INT il prefisso i . L'analisi statica riporta gli errori per tutte le variabili di tipo REFERENCE TO ARRAY[1..3] OF INT che non hanno il prefisso refai . esempio La seguente convenzione di denominazione segue da vicino le raccomandazioni fatte per gli \"identificatori\" in CODESYS sono descritti. esempio La convenzione di denominazione (1) si riferisce al blocco standard TON . Di conseguenza, le dichiarazioni del blocco di costruzione speciale della libreria vengono verificate per il prefisso \"ton_\". È possibile aggiungere ulteriori convenzioni di denominazione facendo clic nella riga vuota (2). " }, 
{ "title" : "Finestra di dialogo: Impostazioni dell'analisi statica: Metriche ", 
"url" : "_san_dlg_settings_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ dialoghi \/ Finestra di dialogo: Impostazioni dell'analisi statica: Metriche ", 
"snippet" : "Impostazioni di analisi statica: Metriche Simbolo: Funzione : configura le metriche in modo che vengano calcolate e visualizzate di conseguenza quando il Visualizza metriche standard il comando viene eseguito. Chiamata : Progetto → Impostazioni progetto menù, Analisi statica categoria, Apri la fines...", 
"body" : "Impostazioni di analisi statica: Metriche Simbolo: Funzione : configura le metriche in modo che vengano calcolate e visualizzate di conseguenza quando il Visualizza metriche standard il comando viene eseguito. Chiamata : Progetto → Impostazioni progetto menù, Analisi statica categoria, Apri la finestra di dialogo di configurazione collegamento Compila → Analisi statica → Impostazioni menù Requisiti : Il pacchetto CODESYS Static Analysis È installato Un progetto è aperto Per ulteriori informazioni, vedere: Configurazione ed esecuzione dell'analisi staticaMetrico Tutto selezionabile Metrica vengono visualizzati nella colonna. Attivo : la metrica è sul comando Crea → Analisi statica → Mostra metriche predefinite nella finestra Metriche standard visualizzato per ogni blocco di costruzione. : la metrica è sul comando Crea → Analisi statica → Mostra metriche predefinite nella finestra Metriche standard non visualizzato. Limite inferiore Valore inferiore da cui viene visualizzata la metrica Limite superiore Valore superiore al quale viene visualizzata la metrica Le metriche dimensione del codice , dimensione variabile , dimensione della pila e numero di visualizzazioni vengono emessi solo per i blocchi delle biblioteche integrate nel progetto. È possibile rilevare le violazioni dei limiti superiore e inferiore delle metriche abilitate tramite la regola SA0150 l'output dell'analisi del codice statico come errore di traduzione. " }, 
{ "title" : "Finestra di dialogo: Impostazioni analisi statica: Simboli proibiti ", 
"url" : "_san_dlg_settings_sa_forbidden_symbols.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ dialoghi \/ Finestra di dialogo: Impostazioni analisi statica: Simboli proibiti ", 
"snippet" : "Simboli proibiti funzione : Nella finestra di dialogo si definiscono le parole chiave ei simboli che non possono essere utilizzati nel codice del progetto. Maggiori informazioni su questo: Configurazione ed esecuzione dell'analisi staticachiamata : pulsante Apri la finestra di configurazione nel men...", 
"body" : "Simboli proibiti funzione : Nella finestra di dialogo si definiscono le parole chiave ei simboli che non possono essere utilizzati nel codice del progetto. Maggiori informazioni su questo: Configurazione ed esecuzione dell'analisi staticachiamata : pulsante Apri la finestra di configurazione nel menu Progetto → Impostazioni progetto , categoria Analisi del codice statico menù Costruisci → Analisi statica → Impostazioni Requisiti : Il pacchetto CODESYS Static Analysis È installato Un progetto è aperto linea di ingresso Facendo doppio clic nella riga si apre l'editor di riga per l'immissione di una parola chiave o di un simbolo. : si apre la guida all'immissione per selezionare il simbolo o la parola chiave. " }, 
{ "title" : "Finestra di dialogo: Opzioni: Formattazione automatica ", 
"url" : "_cds_dlg_options_smart_code.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ dialoghi \/ Finestra di dialogo: Opzioni: Formattazione automatica ", 
"snippet" : "Formattazione automatica Modalità di debug Questa funzionalità è disponibile solo quando il tuo CODESYS l'istanza viene avviata in modalità debug. Per fare ciò, avvia l'istanza con la seguente chiamata alla riga di comando: codesys.exe --debug Simbolo: Funzione : In questa finestra di dialogo viene ...", 
"body" : "Formattazione automatica Modalità di debug Questa funzionalità è disponibile solo quando il tuo CODESYS l'istanza viene avviata in modalità debug. Per fare ciò, avvia l'istanza con la seguente chiamata alla riga di comando: codesys.exe --debug Simbolo: Funzione : In questa finestra di dialogo viene configurata la formattazione automatica del codice IEC. Chiamata : Strumenti → Opzioni menù, Formattazione automatica categoria " }, 
{ "title" : "Formattazione automatica ", 
"url" : "_cds_dlg_options_smart_code.html#UUID-ed744990-e58a-afa4-07c6-a11c0254c4c0_section-idm4605775334425634132064038043", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Interfaccia Utente \/ dialoghi \/ Finestra di dialogo: Opzioni: Formattazione automatica \/ Formattazione automatica ", 
"snippet" : "Generale Dichiarazione e attuazione Schiaccia le righe vuote true (predefinito): Le righe vuote vengono rimosse. false : Le righe vuote vengono mantenute. Interfaccia Dichiarazione Allinea i tipi di variabile true (predefinito): Tutti i tipi in un blocco variabile sono disposti in modo che inizino c...", 
"body" : "Generale Dichiarazione e attuazione Schiaccia le righe vuote true (predefinito): Le righe vuote vengono rimosse. false : Le righe vuote vengono mantenute. Interfaccia Dichiarazione Allinea i tipi di variabile true (predefinito): Tutti i tipi in un blocco variabile sono disposti in modo che inizino con la stessa profondità di linea. false : Allinea le inizializzazioni delle variabili true (predefinito): Tutte le inizializzazioni in un blocco variabile sono disposte in modo tale da iniziare con la stessa profondità di linea. false : Allinea i commenti finali delle variabili true (predefinito): Tutti i commenti che si trovano nella stessa riga della dichiarazione della variabile iniziano alla stessa profondità di riga. false : Invocazioni Tutte le chiamate vengono formattate quando vengono superati i valori massimi. Esempio: Massimo. numero di parametri prima dell'interruzione di riga Il numero di parametri che può contenere una chiamata su linea singola è limitato. Esempio: 4 (predefinito) Massimo. lunghezza in caratteri dei parametri prima dell'interruzione di riga Il numero di caratteri nel nome del parametro è limitato. Esempio: 300 (predefinito) " }, 
{ "title" : "Riferimento: Programmazione ", 
"url" : "_san_f_reference_programming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Pragma e attributi ", 
"url" : "_san_struct_reference_pragmas.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Pragma e attributi ", 
"snippet" : "CODESYS Static Analysis fornisce pragma e attributi per attivare o disattivare singole regole o convenzioni di denominazione per l'analisi statica del codice. Requisito: le regole o le convenzioni sono attivate o definite nelle impostazioni del progetto. Gli attributi vengono inseriti nella parte di...", 
"body" : "CODESYS Static Analysis fornisce pragma e attributi per attivare o disattivare singole regole o convenzioni di denominazione per l'analisi statica del codice. Requisito: le regole o le convenzioni sono attivate o definite nelle impostazioni del progetto. Gli attributi vengono inseriti nella parte di dichiarazione di un blocco di programmazione per disattivare determinate regole per un intero oggetto di programmazione. I pragma vengono utilizzati nella parte di implementazione di un blocco predefinito di programmazione per disabilitare determinate regole per singole righe di codice. L'eccezione è la regola 164, che può essere disattivata anche nella parte di dichiarazione. Le regole disabilitate nelle impostazioni del progetto non possono essere abilitate tramite un pragma o un attributo. La regola SA0004 non può essere disabilitata tramite un pragma o un attributo. " }, 
{ "title" : "Pragma: analysis ", 
"url" : "_san_pragma_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Pragma e attributi \/ Pragma: analysis ", 
"snippet" : "Con questo pragma si disattivano le regole di codifica per singole righe di codice in un blocco di programmazione in modo che possano essere utilizzate nel analisi del codice statico non vengono presi in considerazione. Disabiliti le regole di codifica specificando i numeri delle regole e un segno m...", 
"body" : "Con questo pragma si disattivano le regole di codifica per singole righe di codice in un blocco di programmazione in modo che possano essere utilizzate nel analisi del codice statico non vengono presi in considerazione. Disabiliti le regole di codifica specificando i numeri delle regole e un segno meno (\"-\"). Un segno più (\"+\") è preceduto per l'attivazione. Puoi specificare tutte le regole che vuoi nel pragma. posizione di inserimento : Disattivazione: Nella parte implementativa, prima della prima riga di codice, da cui è disattivata l'analisi del codice, con {analysis - ...} . Attivazione: Dopo l'ultima riga di disattivazione con {analysis + ...} . Per la regola 164, il pragma può essere inserito anche nella parte dichiarativa prima di un commento. Sintassi: Deaktivierung von Regeln:\n\n{analysis -<rule number> ( , -<further rule number> )* }\n* : optional none, one or more further rule numbers Aktivierung von Regeln:\n\nanalysis +<rule number> ( , +<further rule number> )* }\n* : none, one or more further rule numbers esempio La regola 24 è disabilitata per due righe e quindi riattivata. Ciò significa che la regola 24 non è verificata in queste righe, quindi, ad esempio nTest:=DINT#99 consentito è. {analysis -24}\nnTest := 99;\niVar := INT#2;\n{analysis +24} Disabilita più regole: {analysis -10, -24, -18} " }, 
{ "title" : "Attributo: analysis ", 
"url" : "_san_attribute_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Pragma e attributi \/ Attributo: analysis ", 
"snippet" : "L'attributo disabilita determinate regole per un intero oggetto di programmazione in modo che non si applichino a analisi del codice statico non vengono presi in considerazione. Si disattivano le regole di codifica specificando i numeri delle regole e un segno meno (\"-\"). Puoi specificare tutte le r...", 
"body" : "L'attributo disabilita determinate regole per un intero oggetto di programmazione in modo che non si applichino a analisi del codice statico non vengono presi in considerazione. Si disattivano le regole di codifica specificando i numeri delle regole e un segno meno (\"-\"). Puoi specificare tutte le regole che desideri nell'attributo. posizione di inserimento : Nella parte di dichiarazione di un blocco di programmazione nella prima riga. sintassi : {attribute 'analysis' := '-<rule number> ( , -<further rule number> )* '}\n* : none, one or more further rule numbers esempio Le regole 33 e 31 sono disattivate per l'intera struttura: {attribute 'analysis' := '-33, -31'}\nTYPE My_Structure :\nSTRUCT\n iLocal : INT;\n uiLocal : UINT;\n udiLocal : UDINT;\nEND_STRUCT\nEND_TYPE La regola 100 è disattivata per l'array: {attribute 'analysis' := '-100'}\nPROGRAM PLC_PRG\nVAR\n aBigData: ARRAY[1..10000] OF DWORD;\n aBigDATA_2: ARRAY[1..10000] OF DWORD;\nEND_VAR\n; " }, 
{ "title" : "Nome 'naming' ", 
"url" : "_san_attribute_naming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Pragma e attributi \/ Nome 'naming' ", 
"snippet" : "L'attributo identifica le righe di codice utilizzate dal Analisi della convenzione di denominazione esclusi sono. Prima della prima riga di codice in cui l'analisi del codice è sospesa, l'attributo pragma è attivo off , dopo l'ultima riga on assegnato. Quando un omit assegnato, solo la riga di codic...", 
"body" : "L'attributo identifica le righe di codice utilizzate dal Analisi della convenzione di denominazione esclusi sono. Prima della prima riga di codice in cui l'analisi del codice è sospesa, l'attributo pragma è attivo off , dopo l'ultima riga on assegnato. Quando un omit assegnato, solo la riga di codice successiva viene ignorata. posizione di inserimento : Disattivazione: Nella parte dichiarativa di POU e DUT sopra le righe pertinenti. Attivazione: Di seguito le righe pertinenti. sintassi : {attribute 'naming' := '<switch state>'}\n<switch state> : on | off | omit\non : naming is switched on\noff : naming is switched off\nomit : only next codeline is switched off esempio Convenzioni di denominazione definite: (1) Gli identificatori delle variabili INT devono essere forniti con un prefisso \"int\", ad esempio \"intVar1\". (2) I nomi dei programmi devono iniziare con \"prog\". Per il codice mostrato di seguito, l'analisi statica riporta solo le seguenti variabili: cccVar , aVariable , bVariable . VAR\n{attribute 'naming' := 'off'}\n iVarA : INT;\n iVarB : INT;\n{attribute 'naming' := 'on'}\n iVarC : INT;\nEND_VAR VAR\n ...\n{attribute 'naming' := 'omit'}\n iVarC : INT;\n...\nEND_VAR {attribute 'naming' := 'omit'}\nPROGRAM PLC_PRG\nVAR\n...\nEND_VAR {attribute 'naming' := 'off'}\nPROGRAM DoSomethingA\nVAR\n{attribute 'naming' := 'on'}\n iVarA : INT;\n iVarB : INT;\n …\nVAR_END " }, 
{ "title" : "Attributo: nameprefix ", 
"url" : "_san_attribute_nameprefix.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Pragma e attributi \/ Attributo: nameprefix ", 
"snippet" : "nameprefix L'attributo definisce un prefisso per le variabili di un tipo di dati strutturato. Il prefisso deve precedere gli identificatori delle variabili dichiarate con questo tipo. Questa convenzione di denominazione controlla il analisi del codice statico . posizione di inserimento : Sulla riga ...", 
"body" : "nameprefix L'attributo definisce un prefisso per le variabili di un tipo di dati strutturato. Il prefisso deve precedere gli identificatori delle variabili dichiarate con questo tipo. Questa convenzione di denominazione controlla il analisi del codice statico . posizione di inserimento : Sulla riga prima della dichiarazione di un tipo di dati strutturato sintassi : {attribute 'nameprefix' := '<prefix>'} esempio Nell'esempio seguente, l'analisi statica emette un messaggio per pB perché il nome della variabile non inizia con \"punto\". {attribute 'nameprefix' := 'point'}\nTYPE DATAPOINT :\nSTRUCT\n iX: INT;\n iY: INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n pointA : DATAPOINT;\n pB : DATAPOINT;\nEND_VAR\npointA.iX := 1;\npointA.iY := 10;\npB.iX := 2;\npB.iY := 20; Messaggio di errore dopo l'analisi del codice statico: Nome variabile 'pB' non valido: prefisso previsto 'punto' " }, 
{ "title" : "Attributo: analysis:report-multiple-instance-calls ", 
"url" : "_san_attribute_analysis_report_multiple_instance_calls.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Pragma e attributi \/ Attributo: analysis:report-multiple-instance-calls ", 
"snippet" : "analysis:report-multiple-instance-calls L'attributo identifica un modulo funzione per un controllo Regola 105 : vengono controllati solo i blocchi funzione con questo attributo per verificare se le istanze del blocco funzione vengono richiamate più volte. Se la regola 105 nel impostazioni del proget...", 
"body" : "analysis:report-multiple-instance-calls L'attributo identifica un modulo funzione per un controllo Regola 105 : vengono controllati solo i blocchi funzione con questo attributo per verificare se le istanze del blocco funzione vengono richiamate più volte. Se la regola 105 nel impostazioni del progetto è disabilitato, l'attributo non ha effetto. posizione di inserimento : prima riga nella parte di dichiarazione di un blocco funzione. sintassi : {attribute 'analysis:report-multiple-instance-calls'} esempio \/\/ {attribute 'analysis:report-multiple-instance-calls'} deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\n{attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\niB := iB +1;\n\nPROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nND_VAR\n\nfbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n Uscita in vista Messaggi : SA0105: Istanza 'fbB' richiamata più volte " }, 
{ "title" : "regole ", 
"url" : "_san_struct_reference_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0001: Codice irraggiungibile ", 
"url" : "_san_rule_sa0001.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0001: Codice irraggiungibile ", 
"snippet" : "Rileva righe di codice che non vengono eseguite, ad esempio a causa di a RETURN O CONTINUE dichiarazione Motivo: il codice irraggiungibile dovrebbe essere evitato in ogni caso. Spesso il test indica che contiene ancora codice di prova che deve essere rimosso di nuovo. Importanza: Alta Regola PLCopen...", 
"body" : "Rileva righe di codice che non vengono eseguite, ad esempio a causa di a RETURN O CONTINUE dichiarazione Motivo: il codice irraggiungibile dovrebbe essere evitato in ogni caso. Spesso il test indica che contiene ancora codice di prova che deve essere rimosso di nuovo. Importanza: Alta Regola PLCopen: CP2 Esempio PROGRAM PLC_PRG\nVAR\n xReturn_Before_End: BOOL;\n xContinue_In_Loop_FUN: BOOL;\n iCounter: INT;\nEND_VAR\n xContinue_In_Loop_FUN := FALSE;\nFOR iCounter := INT#0 TO INT#5 BY INT#1 DO\n CONTINUE;\n xContinue_In_Loop_FUN := FALSE;\nEND_FOR Uscita in Messaggi vista: SA0001: Codice irraggiungibile rilevato in 'PLC_PRG' " }, 
{ "title" : "SA0002: Oggetti vuoti ", 
"url" : "_san_rule_sa0002.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0002: Oggetti vuoti ", 
"snippet" : "Rileva POU, GVL, dichiarazioni di tipo di dati o interfacce che non contengono codice. Motivo: evitare oggetti vuoti. Spesso sono un segno che un oggetto non è completamente implementato. Eccezione: in alcuni casi, non viene assegnato alcun codice al corpo di un blocco funzione se deve essere utiliz...", 
"body" : "Rileva POU, GVL, dichiarazioni di tipo di dati o interfacce che non contengono codice. Motivo: evitare oggetti vuoti. Spesso sono un segno che un oggetto non è completamente implementato. Eccezione: in alcuni casi, non viene assegnato alcun codice al corpo di un blocco funzione se deve essere utilizzato solo tramite interfacce. In altri casi, un metodo verrà creato solo perché richiesto da un'interfaccia, senza che sia possibile un'implementazione significativa per il metodo. In ogni caso, una situazione del genere dovrebbe essere commentata. Importanza: media " }, 
{ "title" : "SA0003: Dichiarazioni vuote ", 
"url" : "_san_rule_sa0003.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0003: Dichiarazioni vuote ", 
"snippet" : "Trova le righe di codice che contengono un punto e virgola ; , ma nessuna istruzione inclusa. Motivazione: un'istruzione vuota può indicare codice mancante. Nota: ci sono buone ragioni per utilizzare istruzioni vuote. Ad esempio, nell'a CASE può avere senso programmare esplicitamente tutti i casi, a...", 
"body" : "Trova le righe di codice che contengono un punto e virgola ; , ma nessuna istruzione inclusa. Motivazione: un'istruzione vuota può indicare codice mancante. Nota: ci sono buone ragioni per utilizzare istruzioni vuote. Ad esempio, nell'a CASE può avere senso programmare esplicitamente tutti i casi, anche quelli in cui non c'è nulla da fare. Quando questo tipo di vuoto CASE contiene un commento, Static Analysis non genera un messaggio di errore. Importanza: Bassa Esempio CASE value OF\n 1:\n DoSomething();\n 2:\n ;\n 3:\n DoSomethingElse();\nEND_CASE\n Uscita in Messaggi vista: SA0003: Dichiarazioni vuote CASE value OF\n 1:\n DoSomething();\n 2:\n ; \/\/nothing to do\n 3:\n DoSomethingElse();\nEND_CASE\n Uscita in Messaggi vista: Nessun errore SA " }, 
{ "title" : "SA0004: Accesso multiplo in scrittura all'uscita ", 
"url" : "_san_rule_sa0004.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0004: Accesso multiplo in scrittura all'uscita ", 
"snippet" : "Trova gli output scritti in più di una posizione. Motivazione: la manutenibilità ne risente quando un'uscita viene scritta in punti diversi del codice. Non è quindi chiaro quale sia l'accesso in scrittura quello che ha effettivamente un impatto sul processo. È buona norma eseguire il calcolo della v...", 
"body" : "Trova gli output scritti in più di una posizione. Motivazione: la manutenibilità ne risente quando un'uscita viene scritta in punti diversi del codice. Non è quindi chiaro quale sia l'accesso in scrittura quello che ha effettivamente un impatto sul processo. È buona norma eseguire il calcolo della variabile di uscita in variabili ausiliarie e assegnare il valore calcolato in un punto alla fine del ciclo. Importanza: Alta Regola PLCopen: CP12 Non viene generato alcun errore quando si accede a una variabile di output ( VAR_IN_OUT ) in diversi rami di IF o CASE le istruzioni sono scritte. Questa regola non può essere disattivata tramite un pragma. Esempio VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW0 : INT ;\nEND_VAR PROGRAM PLC_PRG IF g_iCondition < INT#0 THEN\n g_xVar := TRUE;\n g_iTest := INT#12;\nEND_IF\n\nCASE g_iCondition OF\n INT#1:\n g_xVar := FALSE;\n INT#2:\n g_iTest := INT#11;\n ELSE\n g_xVar := TRUE;\n g_iTest := INT#9;\nEND_CASE\n Uscita in Messaggi vista: SA0004: Accesso multiplo in scrittura sull'uscita '%QX0.0' SA0004: Accesso multiplo in scrittura sull'uscita '%QW0' " }, 
{ "title" : "SA0006: accesso in scrittura da più attività ", 
"url" : "_san_rule_sa0006.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0006: accesso in scrittura da più attività ", 
"snippet" : "Determina le variabili in cui vengono scritte più attività. Motivo: una variabile scritta in più attività può cambiare il proprio valore in modo imprevisto. Questo può portare a situazioni confuse. Le variabili stringa e su alcuni sistemi a 32 bit anche le variabili intere a 64 bit possono persino o...", 
"body" : "Determina le variabili in cui vengono scritte più attività. Motivo: una variabile scritta in più attività può cambiare il proprio valore in modo imprevisto. Questo può portare a situazioni confuse. Le variabili stringa e su alcuni sistemi a 32 bit anche le variabili intere a 64 bit possono persino ottenere uno stato incoerente se la variabile viene scritta in due attività contemporaneamente. Eccezione: in alcuni casi può essere necessario che più attività scrivano una variabile. Quindi assicurati, ad esempio utilizzando i semafori, che l'accesso non porti a uno stato incoerente. Importanza: Alta Regola PLCopen: CP10 Esempio VAR_GLOBAL\n g_iTemp1: INT;\nEND_VAR PROGRAM PLC_PRG \/\/ Controlled by MainTask\ng_iTemp1 := g_iTemp1 + INT#2;\n PROGRAM PLC_PRG_1 \/\/Controlled by SubTask\ng_iTemp1 := g_iTemp1 - INT#3; Uscita in Messaggi vista: SA0006: Accesso in scrittura simultaneo a 'g_iTemp1' in Tasks MainTask, SubTask " }, 
{ "title" : "SA0007: Operatore indirizzo su costanti ", 
"url" : "_san_rule_sa0007.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0007: Operatore indirizzo su costanti ", 
"snippet" : "Trova le righe di codice in cui l'operatore ADR applicato a una costante. Motivo: un puntatore a una variabile costante solleva il CONSTANT proprietà della variabile. La variabile può essere modificata tramite il puntatore senza che il compilatore lo riporti. Eccezione: in rari casi può avere senso ...", 
"body" : "Trova le righe di codice in cui l'operatore ADR applicato a una costante. Motivo: un puntatore a una variabile costante solleva il CONSTANT proprietà della variabile. La variabile può essere modificata tramite il puntatore senza che il compilatore lo riporti. Eccezione: in rari casi può avere senso trasferire un puntatore a una costante in una funzione. Tuttavia, è necessario assicurarsi che questa funzione non modifichi il valore trasferito. Usa se possibile VAR_IN_OUT CONSTANT . Importanza: Alta Quando il Sostituisci le costanti l'opzione è selezionata in Opzioni del compilatore delle impostazioni del progetto, l'operatore indirizzo non è consentito per le costanti scalari (intere, BOOL , REAL ) e viene emesso un errore di compilazione. (Le stringhe, le strutture e gli array costanti hanno sempre un indirizzo.) Esempio PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n poiValue : POINTER TO INT;\nEND_VAR\n poiValue := ADR(c_iValue); \/\/ SA0007 Uscita in Messaggi vista: SA0007: Indirizzo della variabile costante 'c_iValue' " }, 
{ "title" : "SA0008: Verifica i tipi di sottoarea ", 
"url" : "_san_rule_sa0008.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0008: Verifica i tipi di sottoarea ", 
"snippet" : "Rileva le violazioni dell'intervallo dei tipi di sottointervallo. I valori letterali assegnati sono già controllati dal compilatore. Se vengono assegnate costanti, i valori devono rientrare nell'intervallo definito. Quando le variabili vengono mappate, i tipi di dati devono essere gli stessi. Motivo...", 
"body" : "Rileva le violazioni dell'intervallo dei tipi di sottointervallo. I valori letterali assegnati sono già controllati dal compilatore. Se vengono assegnate costanti, i valori devono rientrare nell'intervallo definito. Quando le variabili vengono mappate, i tipi di dati devono essere gli stessi. Motivo: se si utilizzano tipi di sottoarea, è necessario assicurarsi che questa sottoarea non venga chiusa. Il compilatore controlla solo tali violazioni di sottointervallo per le assegnazioni costanti. Importanza: Bassa Il controllo non viene eseguito per gli oggetti CFC perché la struttura del codice non lo consente. Esempio VAR_GLOBAL\n iVarGlob:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iSubr1: INT (INT#1..INT#10);\n iSubr2: INT (INT#1..INT#1000);\n iCount: INT;\n by_SubType : BYTE (BYTE#0..BYTE#11);\n iVar : INT (-4095..4095);\nEND_VAR\n iSubr1 := nCount; \/\/ SA0008\niSubr1 := subr2; \/\/ SA0008\niSubr1 := gvl.iVarGlob; \/\/ SA0008\n\/\/byBYTE_SubType := BYTE#123; \/\/already detected by compiler, error \"Cannot convert type...\" Uscita in Messaggi vista: SA0008: La variabile del sottointervallo \"iSubr1\" potrebbe essere fuori dall'intervallo consentito " }, 
{ "title" : "SA0009: Valori di ritorno non utilizzati ", 
"url" : "_san_rule_sa0009.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0009: Valori di ritorno non utilizzati ", 
"snippet" : "Rileva le chiamate di funzioni, metodi e proprietà in cui il valore restituito non viene utilizzato. Giustificazione: quando una funzione o un metodo restituisce un valore restituito, dovresti anche valutarlo. Il valore restituito spesso indica se la funzione è stata eseguita correttamente o meno. S...", 
"body" : "Rileva le chiamate di funzioni, metodi e proprietà in cui il valore restituito non viene utilizzato. Giustificazione: quando una funzione o un metodo restituisce un valore restituito, dovresti anche valutarlo. Il valore restituito spesso indica se la funzione è stata eseguita correttamente o meno. Se non viene eseguita alcuna valutazione, non sarà possibile verificare in seguito se il valore restituito è stato dimenticato o se effettivamente non è necessario. Eccezione: Se un valore di ritorno non è rilevante per il richiamo, documentarlo e tralasciare l'assegnazione. I ritorni di errore non dovrebbero mai essere ignorati. Importanza: Media Regola PLCopen: CP7\/CP17 Esempio FUNCTION Return_BOOL : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n    xTest : BOOL;\nEND_VAR xTest := FALSE;\nReturn_BOOL := xTest; PROGRAM PLC_PRG\nReturn_BOOL();  \/\/ SA0009\n Uscita in Messaggi vista: SA0009: Ignorare il valore restituito di 'Return_BOOL' " }, 
{ "title" : "SA0010: Array con un solo componente ", 
"url" : "_san_rule_sa0010.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0010: Array con un solo componente ", 
"snippet" : "Trova gli array con un solo componente. Motivo: un array con 1 componente può essere sostituito da una variabile di tipo base. L'accesso a questa variabile è significativamente più veloce rispetto all'accesso a una variabile con un indice. Eccezione: La lunghezza di un array è spesso determinata da ...", 
"body" : "Trova gli array con un solo componente. Motivo: un array con 1 componente può essere sostituito da una variabile di tipo base. L'accesso a questa variabile è significativamente più veloce rispetto all'accesso a una variabile con un indice. Eccezione: La lunghezza di un array è spesso determinata da una costante ed è un parametro per un programma. Quindi il programma può funzionare con array di diversa lunghezza e non è necessario modificarlo se la lunghezza è solo 1. Questo tipo di situazione dovrebbe essere documentata di conseguenza. Importanza: Bassa Esempio PROGRAM PLC_PRG\nVAR\n aoiEmpty : ARRAY [22..22] OF INT := [22];\n aorEmpty : ARRAY [2..2] OF REAL := [2.2];\n iVar : INT;\n rVAR : REAL;\nEND_VAR iVar := aoiEmpty[22];\nrVAR := aorEmpty[2];\n Uscita in Messaggi vista: SA0010: Elemento di array vuoto nella variabile 'aoiEmpty' SA0010: Elemento di array vuoto nella variabile 'aorEmpty' " }, 
{ "title" : "SA0011: Dichiarazione inutile con un solo membro ", 
"url" : "_san_rule_sa0011.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0011: Dichiarazione inutile con un solo membro ", 
"snippet" : "Rileva strutture o enumerazioni con un solo membro Motivazione: Non dovrebbero essere dichiarate strutture o enumerazioni con un solo membro. Tali dichiarazioni possono creare confusione per i lettori. Una struttura con un solo elemento può essere sostituita da un tipo alias. Un'enumerazione con un ...", 
"body" : "Rileva strutture o enumerazioni con un solo membro Motivazione: Non dovrebbero essere dichiarate strutture o enumerazioni con un solo membro. Tali dichiarazioni possono creare confusione per i lettori. Una struttura con un solo elemento può essere sostituita da un tipo alias. Un'enumerazione con un solo elemento può essere sostituita da una costante. Regola PLCopen: CP22\/CP24 Importanza: Bassa Esempio {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE TYPE SINGLE_UNION :\nUNION\n\tlrValue : LREAL;\nEND_UNION\nEND_TYPE {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE Uscita in Messaggi vista: SA0011: Dichiarazione inutile 'SINGLE_ENUM': Struct\/Enum con un solo membro non deve essere utilizzato SA0011: Dichiarazione inutile 'SINGLE_UNION': Struct\/Enum con un solo membro non deve essere utilizzato SA0011: Dichiarazione inutile 'SINGLE_STRUCT': Struct\/Enum con un solo membro non deve essere utilizzato " }, 
{ "title" : "SA0012: Variabili che possono essere dichiarate come costanti ", 
"url" : "_san_rule_sa0012.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0012: Variabili che possono essere dichiarate come costanti ", 
"snippet" : "Determina le variabili a cui non si accede per la scrittura e che quindi potrebbero essere dichiarate come costanti. Motivazione: Se una variabile viene scritta solo nel punto di dichiarazione e altrimenti viene utilizzata solo per la lettura, l'analisi statica presuppone che anche la variabile non ...", 
"body" : "Determina le variabili a cui non si accede per la scrittura e che quindi potrebbero essere dichiarate come costanti. Motivazione: Se una variabile viene scritta solo nel punto di dichiarazione e altrimenti viene utilizzata solo per la lettura, l'analisi statica presuppone che anche la variabile non debba essere modificata. In primo luogo, una dichiarazione come costante ha come risultato il controllo che la variabile non venga modificata quando si cambia il programma. In secondo luogo, la dichiarazione come costante può risultare in un codice più veloce. Se in un progetto sono presenti più applicazioni, vengono presi in considerazione solo gli oggetti nell'applicazione attualmente attiva. Se è presente una sola applicazione, vengono presi in considerazione anche gli oggetti nel pool di POU generali. Importanza: Bassa Esempio PROGRAM PLC_PRG\nVAR\n iVar : INT := INT#17;\n iTest : INT;\nEND_VAR\n iTest := iTest + iVar; \/\/ SA0012: 'iVar' could be declared as constant Uscita in Messaggi vista: SA0012: La variabile 'iVar' potrebbe essere dichiarata come costante " }, 
{ "title" : "SA0013: Dichiarazioni con lo stesso nome di variabile ", 
"url" : "_san_rule_sa0013.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0013: Dichiarazioni con lo stesso nome di variabile ", 
"snippet" : "Rileva variabili con nomi già utilizzati da altre variabili (ad esempio, variabili globali e locali con lo stesso nome). Vengono rilevate anche le variabili i cui nomi di funzioni, azioni, metodi o proprietà vengono utilizzati nello stesso intervallo di accesso. Vengono rilevate anche le variabili d...", 
"body" : "Rileva variabili con nomi già utilizzati da altre variabili (ad esempio, variabili globali e locali con lo stesso nome). Vengono rilevate anche le variabili i cui nomi di funzioni, azioni, metodi o proprietà vengono utilizzati nello stesso intervallo di accesso. Vengono rilevate anche le variabili dichiarate in un GVL nel file Dispositivi vista o nel pool di POU. Per questo, però, la GVL dell' POU view devono essere utilizzate nel programma applicativo. Motivazione: nomi identici possono creare confusione durante la lettura del codice e possono causare errori se si accede inavvertitamente all'oggetto sbagliato. Si consiglia di utilizzare convenzioni di denominazione che evitino tali situazioni. Regola PLCopen: N5\/N9 Importanza: Media Esempio VAR_GLOBAL\n xVar1 : BOOL;\n iVar3 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n xVar1 : BOOL; \/\/ SA0013\n iVar3 : INT; \/\/ SA0013\nEND_VAR\n xVar1 := NOT GVL.xVar1;\niVar3 := iVar3 + INT#2;\niVar3 := GVL.iVar3; Uscita in Messaggi vista: SA0013: La dichiarazione di 'iVar1' nasconde il simbolo 'GVL.iVar1' SA0013: La dichiarazione di 'xVar3' nasconde il simbolo 'GVL.xVar3' Esempio IL FB_Pou il blocco funzione ha il ACT azione, il METH metodo e variabili locali con gli stessi nomi. FUNCTION_BLOCK FB_Pou\nVAR\n ACT : UINT; \/\/ SA0013\n METH : BYTE; \/\/ SA0013\nEND_VAR PROGRAM PLC_PRG\nVAR\n fbPou : FB_Pou;\nEND_VAR\n fbPou(); Uscita in Messaggi vista: SA0013: La dichiarazione di 'ACT' nasconde il simbolo 'FB_Pou.ACT' SA0013: La dichiarazione di 'METH' nasconde il simbolo 'FB_Pou.METH' " }, 
{ "title" : "SA0014: Assegnazioni alle istanze ", 
"url" : "_san_rule_sa0014.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0014: Assegnazioni alle istanze ", 
"snippet" : "Determina le assegnazioni alle istanze dei blocchi funzione. Per le istanze con puntatore o variabili di riferimento, queste assegnazioni possono essere rischiose. Motivo: questo è un avviso di prestazione. Se un'istanza viene assegnata a un'altra istanza, tutti gli elementi ei sottoelementi vengono...", 
"body" : "Determina le assegnazioni alle istanze dei blocchi funzione. Per le istanze con puntatore o variabili di riferimento, queste assegnazioni possono essere rischiose. Motivo: questo è un avviso di prestazione. Se un'istanza viene assegnata a un'altra istanza, tutti gli elementi ei sottoelementi vengono copiati da un'istanza all'altra. Vengono copiati anche i puntatori ai dati, ma non i relativi dati di riferimento, in modo che l'istanza di destinazione e l'istanza di origine contengano gli stessi dati dopo l'assegnazione. A seconda delle dimensioni delle istanze, tale assegnazione può richiedere molto tempo. Ad esempio, se un'istanza deve essere passata a una funzione per l'elaborazione, è molto più efficiente passare un puntatore all'istanza. Se vuoi copiare selettivamente i valori da un'istanza all'altra, un metodo di copia può essere utile: inst_First.Copy_From(inst_Second) Importanza: Media Esempio PROGRAM PLC_PRG\nVAR\n inst_First : My_FB;\n inst_Second : My_FB;\nEND_VAR\n inst_First();\ninst_Second := inst_First; \/\/ SA0014 Uscita in Messaggi vista: SA0014: Assegnazione di istanze " }, 
{ "title" : "SA0015: Accesso ai dati globali tramite FB_Init ", 
"url" : "_san_rule_sa0015.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0015: Accesso ai dati globali tramite FB_Init ", 
"snippet" : "Determina l'accesso di un blocco funzione alle variabili globali tramite il metodo FB_Init . Il valore di questa variabile dipende dall'ordine delle inizializzazioni! Motivo: a seconda del punto di dichiarazione dell'istanza di un blocco, in caso di violazione della regola è possibile che si acceda ...", 
"body" : "Determina l'accesso di un blocco funzione alle variabili globali tramite il metodo FB_Init . Il valore di questa variabile dipende dall'ordine delle inizializzazioni! Motivo: a seconda del punto di dichiarazione dell'istanza di un blocco, in caso di violazione della regola è possibile che si acceda a una variabile non inizializzata. Importanza: Alta Esempio VAR_GLOBAL\n g_xTest1 : BOOL;\n g_iTest3 : INT;\nEND_VAR METHOD PUBLIC fb_init : BOOL\nVAR_INPUT\n (* If TRUE, the retain variables are initialized (warm start \/ cold start) *)\n bInitRetains : BOOL; \n (* If TRUE, the instance afterwards gets moved into the copy code (online change) *)\n bInCopyCode : BOOL; \nEND_VAR\n g_xTest1 := NOT g_xTest1; \/\/ SA0015\ng_iTest3 := g_iTest3 + INT#1; \/\/ SA0015 Uscita in Messaggi vista: SA0015: Il metodo FB_Init del blocco funzione 'POU' accede ai dati globali " }, 
{ "title" : "SA0016: Lacune nelle strutture ", 
"url" : "_san_rule_sa0016.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0016: Lacune nelle strutture ", 
"snippet" : "Determina le lacune nelle strutture o nei blocchi funzione causati dai requisiti di allineamento del sistema target attualmente impostato. Se possibile, dovresti rimuovere gli spazi vuoti riorganizzando gli elementi della struttura o riempiendoli con un elemento fittizio. Se ciò non è possibile, è p...", 
"body" : "Determina le lacune nelle strutture o nei blocchi funzione causati dai requisiti di allineamento del sistema target attualmente impostato. Se possibile, dovresti rimuovere gli spazi vuoti riorganizzando gli elementi della struttura o riempiendoli con un elemento fittizio. Se ciò non è possibile, è possibile utilizzare la regola per le strutture interessate attraverso il pragma analysis disattivare. Motivo: a causa dei diversi requisiti di allineamento su piattaforme diverse, può esserci un layout diverso in memoria per tali strutture. Il codice può quindi comportarsi in modo diverso a seconda della piattaforma. Importanza: Bassa Esempio TYPE Unpadded_Structure :\nSTRUCT\n xTest : BOOL;\n iTest : INT; \/\/ SA0016\n byTest : BYTE;\n wTest : WORD;\nEND_STRUCT\nEND_TYPE\n PROGRAM PLC_PRG\nVAR\n myStruct : Unpadded_Structure;\nEND_VAR\n myStruct.iTest := 0; Uscita in Messaggi vista: SA0016: La struttura 'Unpadded_Structure' deve essere riempita (pack-mode=8) " }, 
{ "title" : "SA0017: Assegnazione insolita alla variabile puntatore ", 
"url" : "_san_rule_sa0017.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0017: Assegnazione insolita alla variabile puntatore ", 
"snippet" : "Determina le assegnazioni ai puntatori che non hanno un indirizzo (operatore ADR o variabili puntatore) o costante 0 sono. Giustificazione: Se ad un puntatore viene assegnato un valore che non è un indirizzo valido, la dereferenziazione del puntatore porta ad una \"Eccezione di violazione di accesso\"...", 
"body" : "Determina le assegnazioni ai puntatori che non hanno un indirizzo (operatore ADR o variabili puntatore) o costante 0 sono. Giustificazione: Se ad un puntatore viene assegnato un valore che non è un indirizzo valido, la dereferenziazione del puntatore porta ad una \"Eccezione di violazione di accesso\". Importanza: Alta Esempio PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n dwAddress : DWORD;\nEND_VAR\n dwAddress := dwAddress + DWORD#1;\npInt := dwAddress; \/\/ SA0017 Uscita in Messaggi vista: SA0017: Assegnazione insolita alla variabile puntatore " }, 
{ "title" : "SA0018: Accessi bit insoliti ", 
"url" : "_san_rule_sa0018.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0018: Accessi bit insoliti ", 
"snippet" : "Rileva l'accesso bit alle variabili firmate. Tuttavia, lo standard IEC 61131-3 consente solo operazioni di accesso ai bit e spostamento di bit sui campi di bit. Vedi anche le regole severe SA0147  e  SA0148 . Motivo: i tipi di dati con segno non devono essere utilizzati come campi di bit e viceversa...", 
"body" : "Rileva l'accesso bit alle variabili firmate. Tuttavia, lo standard IEC 61131-3 consente solo operazioni di accesso ai bit e spostamento di bit sui campi di bit. Vedi anche le regole severe SA0147  e  SA0148 . Motivo: i tipi di dati con segno non devono essere utilizzati come campi di bit e viceversa. La norma IEC 61131-3 non prevede tale accesso, quindi è necessario seguire questa regola se si desidera scrivere codice portatile. Importanza: Media Eccezione per le enumerazioni flag: se un'enumerazione utilizza l'attributo pragma {attribute 'flags'} è dichiarato come flag, viene utilizzato per gli accessi ai bit con le operazioni OR , AND o NOT l'errore SA0018 non speso. Esempio PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/SA0018\ndiTemp3.4 := TRUE; \/\/SA0018\nuliTemp4.18 := FALSE; \/\/no error because this is an unsigned data type\nsiTemp5.2 := FALSE; \/\/SA0018\nusiTemp6.3 := TRUE; \/\/no error because this is an unsigned data type\nbyTemp2.5 := FALSE; \/\/no error because the byte is a bitfield Uscita in Messaggi vista: SA0018: Accesso bit insolito " }, 
{ "title" : "SA0020: Possibile assegnazione del valore troncato alla variabile REAL ", 
"url" : "_san_rule_sa0020.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0020: Possibile assegnazione del valore troncato alla variabile REAL ", 
"snippet" : "Rileva le operazioni su variabili intere che possono implicare un valore troncato di una variabile di tipo di dati REAL è assegnato. Motivo: l'analisi del codice statico fornisce un errore se il risultato di un calcolo di numeri interi è a REAL - o LREAL -Le variabili sono assegnate. Il programmator...", 
"body" : "Rileva le operazioni su variabili intere che possono implicare un valore troncato di una variabile di tipo di dati REAL è assegnato. Motivo: l'analisi del codice statico fornisce un errore se il risultato di un calcolo di numeri interi è a REAL - o LREAL -Le variabili sono assegnate. Il programmatore dovrebbe essere informato di una possibile interpretazione errata di tale assegnazione: lrealvar := dintvar1 * dintvar2 . Perché l'intervallo di valori di LREAL è maggiore di quella di DINT , si potrebbe presumere che il risultato del calcolo possa essere sempre rappresentato in LREAL . Ma non è così. Il processore calcola il risultato della moltiplicazione come numero intero e quindi esegue il cast del risultato LREAL . Un overflow nel calcolo dell'intero andrebbe perso. Per aggirare il problema, il calcolo deve essere eseguito come a REAL operazione: lreal_var := TO_LREAL(dintvar1) * TO_LREAL(dintvar2) . Importanza: Alta Esempio PROGRAM PLC_PRG\nVAR\n rX : LREAL;\n dI : DINT;\nEND_VAR\n rX := dI * dI \/\/ SA0020\nrX := TO_LREAL(dI) * TO_LREAL(dI) \/\/no message Uscita in Messaggi vista: SA0020: Eventuale assegnazione di valore troncato a variabile REAL " }, 
{ "title" : "SA0021: Trasferimento dell'indirizzo di una variabile temporanea ", 
"url" : "_san_rule_sa0021.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0021: Trasferimento dell'indirizzo di una variabile temporanea ", 
"snippet" : "Recupera le assegnazioni di indirizzi di variabili temporanee (variabili nello stack) a variabili non temporanee. Motivo: le variabili locali di una funzione o di un metodo vengono create nello stack ed esistono solo durante l'elaborazione della funzione o del metodo. Se un puntatore punta a una tal...", 
"body" : "Recupera le assegnazioni di indirizzi di variabili temporanee (variabili nello stack) a variabili non temporanee. Motivo: le variabili locali di una funzione o di un metodo vengono create nello stack ed esistono solo durante l'elaborazione della funzione o del metodo. Se un puntatore punta a una tale variabile dopo che il metodo o la funzione è stato elaborato, è possibile utilizzare questo puntatore per accedere alla memoria non definita o per accedere a una variabile errata in un'altra funzione. Questa situazione deve essere evitata in ogni caso. Importanza: Alta Esempio FUNCTION TempVarInFUNC : DWORD\nVAR\n uiTemp : UINT;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0021 PROGRAM PLC_PRG\nVAR\n dwTest : DWORD;\nEND_VAR dwTest := TempVarInFUNC(); Uscita in Messaggi vista: SA0021: Trasporto dell'indirizzo della variabile temporanea al simbolo dell'ambito esterno " }, 
{ "title" : "SA0022: (Eventualmente) valore restituito non assegnato ", 
"url" : "_san_rule_sa0022.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0022: (Eventualmente) valore restituito non assegnato ", 
"snippet" : "Trova tutte le funzioni e i metodi che contengono un thread di esecuzione senza un'assegnazione al valore restituito. Motivazione: un valore restituito non assegnato in una funzione o in un metodo indica codice mancante. Anche se il valore restituito ha sempre un valore predefinito, ha sempre senso ...", 
"body" : "Trova tutte le funzioni e i metodi che contengono un thread di esecuzione senza un'assegnazione al valore restituito. Motivazione: un valore restituito non assegnato in una funzione o in un metodo indica codice mancante. Anche se il valore restituito ha sempre un valore predefinito, ha sempre senso assegnarlo nuovamente in modo esplicito per evitare ambiguità. Importanza: Media Esempio FUNCTION FUN : DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR\n IF bTest THEN\n RETURN;\nEND_IF\nFUN := 99; Uscita in Messaggi vista: SA0022: (Eventualmente) valore restituito non assegnato " }, 
{ "title" : "SA0023: Valori di ritorno complessi ", 
"url" : "_san_rule_sa0023.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0023: Valori di ritorno complessi ", 
"snippet" : "Determina valori di ritorno complessi che non possono essere restituiti con una semplice copia del registro del processore. Ciò include strutture, array e valori restituiti di tipo STRING (indipendentemente dalle dimensioni dello spazio di archiviazione occupato). Motivazione: Si tratta di un avviso...", 
"body" : "Determina valori di ritorno complessi che non possono essere restituiti con una semplice copia del registro del processore. Ciò include strutture, array e valori restituiti di tipo STRING (indipendentemente dalle dimensioni dello spazio di archiviazione occupato). Motivazione: Si tratta di un avviso di prestazione. Se vengono restituiti valori di grandi dimensioni come risultato di una funzione, metodo o proprietà, il processore li copia più volte durante l'esecuzione del codice. Ciò può portare a problemi di runtime e dovrebbe essere evitato quando possibile. Le prestazioni possono essere migliorate passando un valore strutturato come VAR_IN_OUT a una funzione o un metodo e compilandolo nella funzione o nel metodo. Importanza: Media Esempio TYPE LargeStructure :\nSTRUCT\n a : LINT;\n b : BOOL;\nEND_STRUCT\nEND_TYPE\n FUNCTION Large_Return_Value_FUNC : LargeStructure \/\/ SA0023 Uscita in Messaggi vista: SA0023: Valori restituiti complessi " }, 
{ "title" : "SA0024: Letterali\/costanti non tipizzati ", 
"url" : "_san_rule_sa0024.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0024: Letterali\/costanti non tipizzati ", 
"snippet" : "Identifica i valori letterali non tipizzati che fanno parte di un'operazione Giustificazione: i valori letterali non tipizzati vengono digitati automaticamente in base al loro utilizzo. In alcuni casi, come ad es dw := ROL(DWORD#1, i); , questo può portare a situazioni inaspettate in cui è meglio ut...", 
"body" : "Identifica i valori letterali non tipizzati che fanno parte di un'operazione Giustificazione: i valori letterali non tipizzati vengono digitati automaticamente in base al loro utilizzo. In alcuni casi, come ad es dw := ROL(DWORD#1, i); , questo può portare a situazioni inaspettate in cui è meglio utilizzare un letterale digitato per fornire un chiarimento univoco. Importanza: Bassa Esempio PROGRAM PLC_PRG\nVAR\n iTemp1 : INT := 10; \/\/no part of operation\n diTemp2 : DINT;\n liTemp3 : LINT;\n rTemp4 : REAL;\n lrTemp5 : LREAL;\n END_VAR iTemp1 := iTemp1 + INT#34;\ndiTemp2 := diTemp2 + 23; \/\/ SA0024\nliTemp3 := liTemp3 + 124; \/\/ SA0024\nrTemp4 := rTemp4 + 1.1; \/\/ SA0024\nlrTemp5 := lrTemp5 + 3.4; \/\/ SA0024\n Uscita in Messaggi vista: SA0024: Trovato letterale non tipizzato " }, 
{ "title" : "SA0025: Costanti di enumerazione non qualificate ", 
"url" : "_san_rule_sa0025.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0025: Costanti di enumerazione non qualificate ", 
"snippet" : "Determina le costanti di enumerazione che non hanno un nome completo prima dell'enumerazione. Motivazione: L'accesso qualificato rende il codice più leggibile e più facile da mantenere. Senza forzare nomi di variabili qualificati, è possibile inserire un'enumerazione aggiuntiva quando il programma v...", 
"body" : "Determina le costanti di enumerazione che non hanno un nome completo prima dell'enumerazione. Motivazione: L'accesso qualificato rende il codice più leggibile e più facile da mantenere. Senza forzare nomi di variabili qualificati, è possibile inserire un'enumerazione aggiuntiva quando il programma viene esteso. Questa enumerazione contiene una costante con lo stesso nome di un'enumerazione esistente (vedere l'esempio seguente: \"red\"). Ciò comporterebbe un accesso ambiguo a questo pezzo di codice. In ogni caso, si consiglia di utilizzare solo enumerazioni con il pragma {attribute 'qualified-only'} . Importanza: Media Esempio TYPE COLOR :\n (red,\n green,\n blue);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n myColor : COLOR;\nEND_VAR\n myColor := COLOR.red; \/\/ OK\nmyColor := red; \/\/ SA0025 Uscita in Messaggi vista: SA0025: Costante di enumerazione 'red' non qualificata Per ulteriori informazioni, vedere: Configura ed esegui analisi del codice statico " }, 
{ "title" : "SA0026: Possibile troncamento della stringa ", 
"url" : "_san_rule_sa0026.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0026: Possibile troncamento della stringa ", 
"snippet" : "Identifica le assegnazioni di stringhe e gli inizializzatori di stringhe che non utilizzano una lunghezza di stringa sufficiente. Motivo: se vengono assegnate stringhe di lunghezza diversa, è possibile che una stringa venga troncata. Il risultato quindi non è quello che ci si aspetta. Importanza: Me...", 
"body" : "Identifica le assegnazioni di stringhe e gli inizializzatori di stringhe che non utilizzano una lunghezza di stringa sufficiente. Motivo: se vengono assegnate stringhe di lunghezza diversa, è possibile che una stringa venga troncata. Il risultato quindi non è quello che ci si aspetta. Importanza: Media Esempio PROGRAM PLC_PRG\nVAR\n strVar1 : STRING[10];\n strVar2 : STRING[6];\n strVar3 : STRING[6] := 'abcdefghi'; \/\/ SA0026\nEND_VAR\n strVar2 := strVar1; \/\/ SA0026 Uscita in Messaggi vista: SA0026: Troncamento di 'abcdefghi' SA0026: Possibile troncamento della stringa 'strVar1' Per ulteriori informazioni, vedere: Configura ed esegui analisi del codice statico " }, 
{ "title" : "SA0027: Usi multipli di identificatori ", 
"url" : "_san_rule_sa0027.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0027: Usi multipli di identificatori ", 
"snippet" : "Rileva l'uso multiplo di un nome\/identificatore di variabile o oggetto (POU) nell'ambito di un progetto. Per le enumerazioni si tiene conto del nome qualificato. Motivazione: gli stessi nomi possono creare confusione durante la lettura del codice. Possono causare errori se si accede inavvertitamente...", 
"body" : "Rileva l'uso multiplo di un nome\/identificatore di variabile o oggetto (POU) nell'ambito di un progetto. Per le enumerazioni si tiene conto del nome qualificato. Motivazione: gli stessi nomi possono creare confusione durante la lettura del codice. Possono causare errori se si accede inavvertitamente all'oggetto sbagliato. Pertanto, definire e seguire le convenzioni di denominazione per evitare tali situazioni. Sono coperti i seguenti casi: Il nome di una costante di enumerazione è identico al nome in un'altra enumerazione all'interno dell'applicazione o in una libreria collegata. Il nome di una variabile è identico al nome di un altro oggetto nell'applicazione o in una libreria integrata. Il nome di una variabile è identico al nome di una costante di enumerazione in un'enumerazione nell'applicazione o in una libreria integrata. Il nome di un oggetto è identico al nome di un altro oggetto nell'applicazione o in una libreria collegata. Importanza: Media Esempio TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n color : INT;\nEND_VAR\n Uscita in Messaggi vista: SA0027: Il nome della variabile 'color' in 'PLC_PRG' è già utilizzato per un oggetto in questa applicazione Per ulteriori informazioni, vedere: Configurazione ed esecuzione dell'analisi statica " }, 
{ "title" : "SA0028: Aree di memoria sovrapposte ", 
"url" : "_san_rule_sa0028.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0028: Aree di memoria sovrapposte ", 
"snippet" : "Determina i codici attraverso i quali 2 o più variabili occupano lo stesso spazio di memoria. Giustificazione: Quando due variabili riservano la stessa memoria, il codice potrebbe comportarsi con risultati imprevisti. Questa situazione dovrebbe essere evitata a tutti i costi. Se non è possibile evit...", 
"body" : "Determina i codici attraverso i quali 2 o più variabili occupano lo stesso spazio di memoria. Giustificazione: Quando due variabili riservano la stessa memoria, il codice potrebbe comportarsi con risultati imprevisti. Questa situazione dovrebbe essere evitata a tutti i costi. Se non è possibile evitare di utilizzare un valore in diverse interpretazioni (ad esempio, una volta as DINT e un'altra volta come REAL ), allora dovresti definire a UNION . È inoltre possibile utilizzare un puntatore per accedere a un valore di tipo diverso senza che il valore venga convertito. Importanza: Alta Esempio PROGRAM PLC_PRG\nVAR\n iVvar1 AT %QB21: INT;\n dwVar2 AT %QD5: DWORD;\nEND_VAR\n Uscita in Messaggi vista: Le seguenti variabili accedono alla stessa memoria: SA0028: iVar1 AT %QB21 SA0028: dwVar2 A %QD5 Per ulteriori informazioni, vedere: Configura ed esegui analisi del codice statico " }, 
{ "title" : "SA0029: Notazione in attuazione e dichiarazione differente ", 
"url" : "_san_rule_sa0029.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0029: Notazione in attuazione e dichiarazione differente ", 
"snippet" : "Determina le posizioni del codice in cui la notazione di un identificatore differisce dalla notazione nella relativa dichiarazione. Motivazione: La norma IEC 61131-3 definisce gli identificatori come non sensibili alle maiuscole. Ciò significa che una variabile dichiarata come \" varx \" può essere ut...", 
"body" : "Determina le posizioni del codice in cui la notazione di un identificatore differisce dalla notazione nella relativa dichiarazione. Motivazione: La norma IEC 61131-3 definisce gli identificatori come non sensibili alle maiuscole. Ciò significa che una variabile dichiarata come \" varx \" può essere utilizzato anche come \" VaRx \" nel codice. Tuttavia, ciò crea confusione e fuorviante e dovrebbe essere evitato. Importanza: Media Esempio È presente un blocco nell'albero dei dispositivi PLC_PRG e un mattone fnc (Funzione). PROGRAM PLC_PRG\nVAR\n iVar: INT;\n _123test_var_: INT;\nEND_VAR\n ivar := iVar + 1; \/\/ SA0029\n_123TEST_var_ := _123test_var_; \/\/ SA0029\nFnc(); \/\/ SA0029 Uscita in Messaggi vista: SA0029: La notazione nel codice (ivar) deve essere uguale alla dichiarazione (iVar) SA0029: La notazione nel codice (_123TEST_var_) deve essere uguale alla dichiarazione (_123test_var_) SA0029: La notazione nel codice (Fnc) deve essere uguale alla dichiarazione (fnc) Per ulteriori informazioni, vedere: Configurazione ed esecuzione dell'analisi statica " }, 
{ "title" : "Elenca gli oggetti inutilizzati ", 
"url" : "_san_list_unused_objects.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Elenca gli oggetti inutilizzati ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0031: Firme inutilizzate ", 
"url" : "_san_rule_sa0031.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Elenca gli oggetti inutilizzati \/ SA0031: Firme inutilizzate ", 
"snippet" : "Identifica programmi, blocchi funzione, funzioni, tipi di dati, interfacce, metodi, proprietà e azioni che non vengono richiamati nel codice del programma compilato. Motivazione: gli oggetti inutilizzati aggiungono ingombro non necessario al progetto e possono creare confusione durante la lettura de...", 
"body" : "Identifica programmi, blocchi funzione, funzioni, tipi di dati, interfacce, metodi, proprietà e azioni che non vengono richiamati nel codice del programma compilato. Motivazione: gli oggetti inutilizzati aggiungono ingombro non necessario al progetto e possono creare confusione durante la lettura del codice. Importanza: bassa Regola PLCopen: CP2 Se in un progetto sono presenti più applicazioni, vengono presi in considerazione solo gli oggetti nell'applicazione attualmente attiva. Se è presente una sola applicazione, vengono presi in considerazione anche gli oggetti nel pool di POU. Guarda anche Configura ed esegui analisi del codice statico " }, 
{ "title" : "SA0032: Costanti di enumerazione non utilizzate ", 
"url" : "_san_rule_sa0032.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Elenca gli oggetti inutilizzati \/ SA0032: Costanti di enumerazione non utilizzate ", 
"snippet" : "Determina le costanti di enumerazione che non vengono utilizzate nel codice del programma compilato. Motivazione: Le costanti di enumerazione non utilizzate aumentano inutilmente la dimensione della definizione di enumerazione e possono creare confusione durante la lettura del programma. Regola PLCo...", 
"body" : "Determina le costanti di enumerazione che non vengono utilizzate nel codice del programma compilato. Motivazione: Le costanti di enumerazione non utilizzate aumentano inutilmente la dimensione della definizione di enumerazione e possono creare confusione durante la lettura del programma. Regola PLCopen: CP24 Importanza: Bassa Se in un progetto sono presenti più applicazioni, vengono presi in considerazione solo gli oggetti sotto quello attualmente attivo. Se è presente una sola applicazione, vengono presi in considerazione anche gli oggetti nel pool di POU generali. Esempio TYPE My_Enum :\n(\n one := 1, \n two := 2\n);\nEND_TYPE\n Uscita in Messaggi vista: SA0032: Costante di enumerazione 'one' non utilizzata SA0032: costante di enumerazione 'two' non utilizzata Per ulteriori informazioni, vedere: Configurazione ed esecuzione dell'analisi statica " }, 
{ "title" : "SA0033: Variabili non utilizzate ", 
"url" : "_san_rule_sa0033.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Elenca gli oggetti inutilizzati \/ SA0033: Variabili non utilizzate ", 
"snippet" : "Determina le variabili dichiarate ma non utilizzate nel codice del programma compilato. Motivazione: le variabili inutilizzate rendono un programma meno leggibile e meno manutenibile. Le variabili che non vengono utilizzate occupano inutilmente memoria e costano inutilmente il runtime durante l'iniz...", 
"body" : "Determina le variabili dichiarate ma non utilizzate nel codice del programma compilato. Motivazione: le variabili inutilizzate rendono un programma meno leggibile e meno manutenibile. Le variabili che non vengono utilizzate occupano inutilmente memoria e costano inutilmente il runtime durante l'inizializzazione. Importanza: Media Regola PLCopen: CP22 \/ CP24 Per le variabili GVL: se in un progetto esistono più applicazioni, vengono considerati solo gli oggetti al di sotto dell'applicazione attualmente attiva. Se è presente una sola applicazione, vengono considerati anche gli oggetti nel pool POU comune Esempio PROGRAM PLC_PRG\nVAR\n iCounter1 : INT;\n iCounter2 : INT; \/\/ SA0033\nEND_VAR\n iCounter1 := 100; Uscita in Messaggi vista: SA0033: variabile «iCounter2» non utilizzata Per ulteriori informazioni, vedere: Configurazione ed esecuzione dell'analisi statica " }, 
{ "title" : "SA0035: variabili di ingresso non utilizzate ", 
"url" : "_san_rule_sa0035.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Elenca gli oggetti inutilizzati \/ SA0035: variabili di ingresso non utilizzate ", 
"snippet" : "Determina le variabili di input che non vengono utilizzate da alcuna istanza di blocco funzione. Giustificazione: Le variabili di input non utilizzate rendono un programma meno leggibile e manutenibile. Le variabili inutilizzate riempiono inutilmente la memoria e sprecano inutilmente il tempo. Un in...", 
"body" : "Determina le variabili di input che non vengono utilizzate da alcuna istanza di blocco funzione. Giustificazione: Le variabili di input non utilizzate rendono un programma meno leggibile e manutenibile. Le variabili inutilizzate riempiono inutilmente la memoria e sprecano inutilmente il tempo. Un input è considerato utilizzato solo se viene referenziato attivamente all'interno dell'implementazione (o dei metodi) dell'istanza del blocco funzione stessa. Importanza: Media Regola PLCopen: CP24 Esempio FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\nEND_VAR iOut1 := iIn1; \/\/ iIn1 is used here PROGRAM PLC_PRG\nVAR\n fbAfb: FB_Afb;\nEND_VAR\n fbAfb(iIn2 := 99); \/\/ iIn2 is unused internally => error Uscita in Messaggi vista: SA0035: Ingresso non utilizzato 'iIn2' " }, 
{ "title" : "SA0036: variabili di uscite non utilizzate ", 
"url" : "_san_rule_sa0036.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Elenca gli oggetti inutilizzati \/ SA0036: variabili di uscite non utilizzate ", 
"snippet" : "Determina le variabili di uscita delle funzioni e dei blocchi funzione che non sono assegnati all'interno della funzione o del blocco funzione pertinente. Giustificazione: Le variabili inutilizzate rendono un programma meno leggibile e manutenibile. Le variabili non utilizzate riempiono inutilmente ...", 
"body" : "Determina le variabili di uscita delle funzioni e dei blocchi funzione che non sono assegnati all'interno della funzione o del blocco funzione pertinente. Giustificazione: Le variabili inutilizzate rendono un programma meno leggibile e manutenibile. Le variabili non utilizzate riempiono inutilmente la memoria e sprecano inutilmente tempo di esecuzione durante l'inizializzazione. Importanza: Media Regola PLCopen: CP24 Esempio FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\n iOut2: INT;\nEND_VAR\n iOut1 := iIn1 + iIn2; Uscita in Messaggi vista: SA0036: Uscita non utilizzata 'iOut1' " }, 
{ "title" : "SA0034: Enumerazioni con assegnazione errata ", 
"url" : "_san_rule_sa0034.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0034: Enumerazioni con assegnazione errata ", 
"snippet" : "Recupera i valori assegnati a una variabile di enumerazione. Solo le costanti di enumerazione definite possono essere assegnate a una variabile di enumerazione. Giustificazione: una variabile di tipo enumerazione dovrebbe avere solo i valori previsti, altrimenti il codice che utilizza questa variabi...", 
"body" : "Recupera i valori assegnati a una variabile di enumerazione. Solo le costanti di enumerazione definite possono essere assegnate a una variabile di enumerazione. Giustificazione: una variabile di tipo enumerazione dovrebbe avere solo i valori previsti, altrimenti il codice che utilizza questa variabile potrebbe non funzionare correttamente. Si consiglia di utilizzare sempre le enumerazioni con il pragma {attribute 'strict'} . Quindi il compilatore controlla già il corretto utilizzo dei componenti di enumerazione. Importanza: Alta Esempio TYPE COLOR :\n(\n Red := 0,\n Green,\n Yellow\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n eColor1: COLOR;\nEND_VAR\n eColor1 := COLOR.Red;\neColor1 := 1; \/\/ SA0034 Uscita in Messaggi vista: SA0034: Utilizza il valore di enumerazione anziché 'INT#1' Per ulteriori informazioni, vedere: Configurazione ed esecuzione dell'analisi statica " }, 
{ "title" : "SA0037: Accesso in scrittura alla variabile di ingresso ", 
"url" : "_san_rule_sa0037.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0037: Accesso in scrittura alla variabile di ingresso ", 
"snippet" : "Rileva le variabili di input ( VAR_INPUT ) a cui si accede con autorizzazione di scrittura all'interno della POU Motivazione: Secondo la norma IEC 61131-3 una variabile di ingresso non può essere modificata all'interno di un POU. Questo tipo di accesso è anche causa di errori e rende il codice diffi...", 
"body" : "Rileva le variabili di input ( VAR_INPUT ) a cui si accede con autorizzazione di scrittura all'interno della POU Motivazione: Secondo la norma IEC 61131-3 una variabile di ingresso non può essere modificata all'interno di un POU. Questo tipo di accesso è anche causa di errori e rende il codice difficilmente gestibile. Questa è un'indicazione che una variabile viene utilizzata sia come variabile di input che come variabile ausiliaria. Questo tipo di duplice uso dovrebbe essere evitato. Importanza: Media Esempio VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL;\nEND_VAR PROGRAM PLC_PRG\nVAR_INPUT\n xVarIn1 : BOOL;\n xVarIn2 : BOOL;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_xGlob := xVarIn1;\n INT#2:\n g_xGlob := xVarIn2;\n ELSE\n g_xGlob := FALSE;\n xVarIn1 := FALSE; \/\/ SA0037\nEND_CASE Uscita in Messaggi vista: SA0037: Accesso in scrittura alla variabile di ingresso 'xVarIn1' " }, 
{ "title" : "SA0038: Accesso in lettura alla variabile di uscita ", 
"url" : "_san_rule_sa0038.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0038: Accesso in lettura alla variabile di uscita ", 
"snippet" : "Rileva le variabili di output ( VAR_OUTPUT ) a cui si accede con autorizzazione di lettura all'interno della POU Motivazione: Secondo la norma IEC 61131-3 è vietato leggere un'uscita all'interno di una POU. Ciò indica che l'output non viene utilizzato solo come output ma anche come variabile tempora...", 
"body" : "Rileva le variabili di output ( VAR_OUTPUT ) a cui si accede con autorizzazione di lettura all'interno della POU Motivazione: Secondo la norma IEC 61131-3 è vietato leggere un'uscita all'interno di una POU. Ciò indica che l'output non viene utilizzato solo come output ma anche come variabile temporanea per risultati intermedi. Questo tipo di duplice uso dovrebbe essere evitato. Importanza: Bassa Esempio VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL ;\n g_iGlob AT %QW1 : INT ;\nEND_VAR PROGRAM PLC_PRG\nVAR_OUTPUT\n xVarOut1:BOOL;\n xVarOut2:INT;\n xVarOut3:INT;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n xVarOut1 := g_xGlob;\n xVarOut2 := g_iGlob;\n INT#2:\n xVarOut3 := xVarOut2; \/\/ SA0038\n ELSE\n xVarOut1 := FALSE;\n g_xGlob := xVarOut1; \/\/ SA0038\n xVarOut2 := INT#0;\n xVarOut3 := INT#-1;\nEND_CASE Uscita in Messaggi vista: SA0038: Accesso in lettura alla variabile di uscita 'xVarOUT2' SA0026: SA0038: Accesso in lettura alla variabile di uscita 'xVarOUT1' " }, 
{ "title" : "SA0040: Possibile divisione per zero ", 
"url" : "_san_rule_sa0040.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0040: Possibile divisione per zero ", 
"snippet" : "Determina i codici in cui può verificarsi la divisione per zero. Motivazione: Divisione per 0 risulta in un errore. Una variabile da dividere deve essere sempre controllata per prima su 0. Importanza: Alta Esempio VAR_GLOBAL g_iVar AT %QW1 : INT; END_VAR PROGRAM PLC_PRG VAR iCounter : INT; iSumme:IN...", 
"body" : "Determina i codici in cui può verificarsi la divisione per zero. Motivazione: Divisione per 0 risulta in un errore. Una variabile da dividere deve essere sempre controllata per prima su 0. Importanza: Alta Esempio VAR_GLOBAL\n g_iVar AT %QW1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n iSumme:INT;\n iMid:INT;\n iVal1:INT := INT#2;\n iVal2:INT;\n iVal3:INT := INT#3;\n iVal4:INT := INT#4;\n iVal5:INT;\nEND_VAR IF iVal2 <> 0 THEN\n iVal1 := iVal1\/iVal2; \/\/ no error\nEND_IF;\niMid := iSumme \/ iCounter; \/\/ SA0040\niCounter := iCounter + INT#1;\niSumme := g_iVar + iSumme;\nIF iMid < INT#100 THEN\n iVal1 := iVal1 \/ iVal2; \/\/ SA0040\nEND_IF Uscita in Messaggi vista: SA0040: Possibile divisione per zero SA0040: Possibile divisione per zero " }, 
{ "title" : "SA0041: Possibile codice invariante di loop ", 
"url" : "_san_rule_sa0041.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0041: Possibile codice invariante di loop ", 
"snippet" : "Rileva le assegnazioni nei loop che calcolano lo stesso valore per ogni ciclo del loop. Tali righe di codice potrebbero essere inserite all'esterno del ciclo. Motivazione: Si tratta di un avviso di prestazione. Il codice che viene eseguito in un ciclo, ma che fa la stessa cosa in ogni ciclo del cicl...", 
"body" : "Rileva le assegnazioni nei loop che calcolano lo stesso valore per ogni ciclo del loop. Tali righe di codice potrebbero essere inserite all'esterno del ciclo. Motivazione: Si tratta di un avviso di prestazione. Il codice che viene eseguito in un ciclo, ma che fa la stessa cosa in ogni ciclo del ciclo, può essere eseguito all'esterno del ciclo. Importanza: Media Esempio PROGRAM PLC_PRG\nVAR\n iCounter, iVar1, iVar2 : INT;\nEND_VAR FOR iCounter := 0 TO 10 DO\n iVar1 := 100; \/\/ SA0041\n iVar2 := iVar2 + iVar1;\nEND_FOR\n Uscita in Messaggi vista: SAN0041: Possibile codice invariante del loop 'iVar1 := 100' " }, 
{ "title" : "SA0042: Utilizzo di diversi percorsi di accesso ", 
"url" : "_san_rule_sa0042.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0042: Utilizzo di diversi percorsi di accesso ", 
"snippet" : "Rileva l'uso di percorsi di accesso diversi per la stessa variabile. Motivo: l'accesso diverso allo stesso elemento riduce la leggibilità e la manutenibilità di un programma. Si consiglia l'uso coerente di {attribute 'qualified-only'} per librerie, elenchi di variabili globali ed enumerazioni. Ciò i...", 
"body" : "Rileva l'uso di percorsi di accesso diversi per la stessa variabile. Motivo: l'accesso diverso allo stesso elemento riduce la leggibilità e la manutenibilità di un programma. Si consiglia l'uso coerente di {attribute 'qualified-only'} per librerie, elenchi di variabili globali ed enumerazioni. Ciò impone l'accesso completo. Importanza: Bassa Esempio VAR_GLOBAL\n iTemp:INT;\n instPOU:POU;\nEND_VAR FUNCTION_BLOCK POU\nVAR\n a:INT;\nEND_VAR\n a := INT#1; PROGRAM SA0042\nVAR\n ptiTemp:POINTER TO INT;\n sTemp:STRING;\nEND_VAR ptiTemp := ADR(iTemp);\n\nptiTemp^ := INT#1;\niTemp := INT#2; \/\/ SA0042 - direct access on variable\nGVL.iTemp := INT#3; \/\/ SA0042 - access on variable via GVL\n\nsTemp := CONCAT( 'ab', 'cd'); \/\/ SA0042 - direct access on function\nsTemp := Standard.CONCAT( 'ab', 'cd'); \/\/ SA0042 - access on function via Standard\n\ninstPOU(); \/\/ SA0042 - direct access on POU instance\nGVL.instPOU(); \/\/ SA0042 - access via GVL\n Uscita in Messaggi vista: SA0042: Diversi percorsi di accesso per 'CONCAT' SA0042: Percorsi di accesso diversi per 'Standard.CONCAT' SA0042: Percorsi di accesso diversi per 'instPOU' SA0042: Percorsi di accesso diversi per 'GVL.instPOU' SA0042: Diversi percorsi di accesso per 'iTemp' SA0042: Diversi percorsi di accesso per 'GVL.iTemp' " }, 
{ "title" : "SA0043: Utilizzo di una variabile globale in una sola POU ", 
"url" : "_san_rule_sa0043.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0043: Utilizzo di una variabile globale in una sola POU ", 
"snippet" : "Rileva l'uso di una variabile globale in un solo blocco predefinito. Motivazione: Una variabile globale utilizzata in una sola posizione dovrebbe essere dichiarata anche solo in questa posizione. Importanza: Media Regola PLCopen: CP26 Esempio VAR_GLOBAL g_xVar AT %QX0.0 : BOOL ; g_iTest AT %QW1 : IN...", 
"body" : "Rileva l'uso di una variabile globale in un solo blocco predefinito. Motivazione: Una variabile globale utilizzata in una sola posizione dovrebbe essere dichiarata anche solo in questa posizione. Importanza: Media Regola PLCopen: CP26 Esempio VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW1 : INT ;\n g_wTest AT %QW2 : WORD;\nEND_VAR PROGRAM prog1\nVAR\n iCondition : INT;\n bTemp : BOOL;\nEND_VAR\n iCondition := iCondition + INT#1;\nIF iCondition < INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n ELSIF iCondition = INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\nELSE\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n g_wTest := WORD#4; \/\/ g_WTest used also in prog2 -> OK\nEND_IF PROGRAM prog2\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_iTest := WORD_TO_INT(g_wTest); \/\/ SA0043 - g_iTest only written in this POU\n INT#2:\n g_iTest := INT#2; \/\/ SA0043 - g_iTest only written in this POU\n ELSE\n g_iTest := INT#3; \/\/ SA0043 - g_iTest only written in this POU\nEND_CASE Uscita in Messaggi vista: SA0043: Variabile globale 'g_xVar' utilizzata solo in 'prog1' SA0043: Variabile globale 'g_iTest' utilizzata solo in 'prog2' " }, 
{ "title" : "SA0044: Dichiarazioni con riferimento interfaccia ", 
"url" : "_san_rule_sa0044.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0044: Dichiarazioni con riferimento interfaccia ", 
"snippet" : "Determina le dichiarazioni con REFERENCE TO -Interfacce e dichiarazioni di VAR_IN_OUT -Variabili con interfacce (implicite tramite REFERENCE TO realizzato). Giustificazione: Un tipo di interfaccia è sempre implicitamente un riferimento a un'istanza di un blocco funzione che implementa questa interfa...", 
"body" : "Determina le dichiarazioni con REFERENCE TO -Interfacce e dichiarazioni di VAR_IN_OUT -Variabili con interfacce (implicite tramite REFERENCE TO realizzato). Giustificazione: Un tipo di interfaccia è sempre implicitamente un riferimento a un'istanza di un blocco funzione che implementa questa interfaccia. Un riferimento a un'interfaccia è quindi un riferimento a un riferimento e può provocare un comportamento indesiderato. Importanza: Alta Esempio ITF è un'interfaccia definita nel progetto. FUNCTION_BLOCK POU\nVAR_INPUT\n inst_itf2 : ITF;\nEND_VAR\nVAR_OUTPUT\n inst_itf3 : ITF;\nEND_VAR\nVAR_IN_OUT\n inst_itf4 : ITF; \/\/ SA0044\nEND_VAR\n PROGRAM PLC_PRG\nVAR\n inst : POU;\n itf_inst1 : ITF;\n itf_ref : REFERENCE TO ITF; \/\/ SA0044\nEND_VAR Uscita in Messaggi vista: SA0044: Riferimento all'interfaccia 'itf4_ref' SA0044: Riferimento all'interfaccia 'itf_ref' " }, 
{ "title" : "conversioni ", 
"url" : "_san_conversion.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ conversioni ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0019: Conversioni implicite di puntatori ", 
"url" : "_san_rule_sa0019.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ conversioni \/ SA0019: Conversioni implicite di puntatori ", 
"snippet" : "Recupera le conversioni del puntatore generate in modo implicito. Giustificazione: In CODESYS , i puntatori non sono digitati in modo rigoroso e possono essere assegnati l'uno all'altro in qualsiasi modo. Questo è spesso usato e quindi non viene segnalato dal compilatore. Tuttavia, può anche portare...", 
"body" : "Recupera le conversioni del puntatore generate in modo implicito. Giustificazione: In CODESYS , i puntatori non sono digitati in modo rigoroso e possono essere assegnati l'uno all'altro in qualsiasi modo. Questo è spesso usato e quindi non viene segnalato dal compilatore. Tuttavia, può anche portare ad accessi non autorizzati e imprevisti. Ad esempio, se si assegna il tipo POINTER TO DWORD a un puntatore con il tipo POINTER TO BYTE , la memoria può essere sovrascritta in modo indesiderato. Pertanto, controlla sempre questa regola e blocca il messaggio solo nei casi in cui desideri accedere intenzionalmente a un valore con un tipo diverso. Conversioni da e verso POINTER TO BYTE i tipi di dati non sono controllati dalla regola SA0019. Sono sempre consentiti Le conversioni implicite del tipo di dati vengono segnalate con un messaggio diverso. Importanza: Alta Regola PLCopen: CP25 Eccezione: BOOL <-> BIT Esempio PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n byteVar : BYTE;\nEND_VAR\n pInt := ADR(byteVar); Uscita in Messaggi vista: SA0019: Conversione implicita dal puntatore a 'POINTER TO BYTE' al puntatore a 'POINTER TO INT' " }, 
{ "title" : "SA0130: Conversioni espandibili implicite ", 
"url" : "_san_rule_sa0130.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ conversioni \/ SA0130: Conversioni espandibili implicite ", 
"snippet" : "Rileva le posizioni del codice in cui le conversioni da tipi di dati più piccoli a quelli più grandi vengono eseguite implicitamente durante le operazioni aritmetiche Giustificazione: Il compilatore consente qualsiasi assegnazione di tipi diversi se l'intervallo di valori del tipo sorgente è complet...", 
"body" : "Rileva le posizioni del codice in cui le conversioni da tipi di dati più piccoli a quelli più grandi vengono eseguite implicitamente durante le operazioni aritmetiche Giustificazione: Il compilatore consente qualsiasi assegnazione di tipi diversi se l'intervallo di valori del tipo sorgente è completamente contenuto nell'intervallo di valori del tipo di destinazione. Tuttavia, il compilatore creerà una conversione nel codice il più tardi possibile. Per un incarico di tipo lint := dint * dint , il compilatore esegue la conversione implicita solo dopo la moltiplicazione: lint := TO_LINT(dint * dint); Un overflow viene quindi troncato. Se vuoi evitarlo, puoi già convertire gli elementi: lint := TO_LINT(dint) * TO_LINT(dint); Pertanto, potrebbe essere utile segnalare le posizioni in cui il compilatore implementa le conversioni implicite per verificare se queste sono esattamente ciò che si intende. Inoltre, è possibile utilizzare conversioni esplicite per migliorare la portabilità su altri sistemi quando tali sistemi dispongono di controlli di tipo più restrittivi. Importanza: bassa Esempio PROGRAM PLC_PRG\nVAR\n d : DINT;\n l : LINT;\n ui : UINT;\n uli : ULINT;\n usi : USINT;\n lw : LWORD;\n udi : UDINT;\n lr : LREAL;\n b : BYTE;\nEND_VAR\n (*The following lines could result in unwanted truncating by implicit conversions \nand should be reported with SA0130*) \nl := d * d;\nuli := usi * usi;\nlw := udi * udi;\nlr := b * b;\nd := ui * ui; Uscita in Messages  vista: SA0130: Conversione espandibile implicita dal tipo 'DINT' al tipo 'LINT' SA0130: Conversione espandibile implicita dal tipo 'USINT' al tipo 'ULINT' SA0130: Conversione espandibile implicita dal tipo 'UDINT' al tipo 'LWORD' SA0130: Conversione espandibile implicita dal tipo 'USINT' al tipo 'LREAL' SA0130: Conversione espandibile implicita dal tipo 'UINT' al tipo 'DINT' " }, 
{ "title" : "SA0133: Conversioni esplicite di restringimento ", 
"url" : "_san_rule_sa0133.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ conversioni \/ SA0133: Conversioni esplicite di restringimento ", 
"snippet" : "Determina le conversioni eseguite in modo esplicito da un tipo di dati più grande a uno più piccolo. Giustificazione: Un numero elevato di conversioni di tipo potrebbe indicare che sono stati scelti tipi di dati errati per le variabili. Per questo motivo esistono linee guida di programmazione che ri...", 
"body" : "Determina le conversioni eseguite in modo esplicito da un tipo di dati più grande a uno più piccolo. Giustificazione: Un numero elevato di conversioni di tipo potrebbe indicare che sono stati scelti tipi di dati errati per le variabili. Per questo motivo esistono linee guida di programmazione che richiedono una giustificazione esplicita per le conversioni del tipo di dati. Importanza: Bassa Esempio PROGRAM SA0133\nVAR\n siVar:SINT;\n diVar:DINT;\n liVar:LINT;\n byVar:BYTE;\n uiVar:UINT;\n dwVar:DWORD;\n lwVar:LWORD;\n rVar:REAL;\n lrVar:LREAL;\nEND_VAR\n siVar := LINT_TO_SINT(liVar); \/\/ SA0133\nbyVar := DINT_TO_BYTE(diVar); \/\/ SA0133\nsiVar := DWORD_TO_SINT(dwVar); \/\/ SA0133\nuiVar := LREAL_TO_UINT(lrVar); \/\/ SA0133\nrVar := LWORD_TO_REAL(lwVar); \/\/ SA0133 Uscita in Messaggi vista: SA0133: Conversione di restringimento esplicita dal tipo 'LINT' al tipo 'SINT' SA0133: Conversione di restringimento esplicita dal tipo 'DINT' al tipo 'BYTE' SA0133: Conversioni di restringimento esplicite dal tipo \"DWORD\" al tipo \"SINT\" SA0133: Conversione di restringimento esplicita dal tipo 'LREAL' al tipo 'UINT' SA0133: Conversione di restringimento esplicita dal tipo \"LWORD\" al tipo \"REAL\" " }, 
{ "title" : "SA0134: Conversioni firmate\/non firmate esplicite ", 
"url" : "_san_rule_sa0134.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ conversioni \/ SA0134: Conversioni firmate\/non firmate esplicite ", 
"snippet" : "Determina le conversioni dai tipi di dati con segno a quelli senza segno e viceversa che sono state eseguite in modo esplicito. Giustificazione: Un uso eccessivo delle conversioni di tipo può indicare che sono stati selezionati tipi di dati errati per le variabili. Per questo motivo esistono linee g...", 
"body" : "Determina le conversioni dai tipi di dati con segno a quelli senza segno e viceversa che sono state eseguite in modo esplicito. Giustificazione: Un uso eccessivo delle conversioni di tipo può indicare che sono stati selezionati tipi di dati errati per le variabili. Per questo motivo esistono linee guida di programmazione che richiedono una giustificazione esplicita per le conversioni del tipo di dati. Importanza: bassa Esempio PROGRAM PLC_PRG\nVAR\n byVar :BYTE;\n udiVar : UDINT;\n uliVar : ULINT;\n lwVar : LWORD;\n wVar : WORD;\n siVar : SINT;\n iVar : INT;\n diVar : DINT;\n liVar : LINT;\nEND_VAR\n liVar := ULINT_TO_LINT(uliVar);\nudiVar := DINT_TO_UDINT(diVar);\nsiVar := BYTE_TO_SINT(byVar);\nwVar := INT_TO_WORD(iVar);\nlwVar := SINT_TO_LWORD(siVar); Uscita in Messaggi vista: SA0134: Conversione esplicita con segno\/senza segno dal tipo 'ULINT' al tipo 'LINT' SA0134: Conversione esplicita con segno\/senza segno dal tipo 'DINT' al tipo 'UDINT' SA0134: Conversione esplicita con segno\/senza segno dal tipo 'BYTE' al tipo 'SINT' SA0134: Conversione esplicita con segno\/senza segno dal tipo 'INT' al tipo 'WORD' SA0134: Conversione esplicita con segno\/senza segno dal tipo 'SINT' al tipo 'LWORD' " }, 
{ "title" : "Utilizzo di indirizzi diretti ", 
"url" : "_san_use_direct_adresses.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Utilizzo di indirizzi diretti ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0005: Indirizzi e tipi di dati non validi ", 
"url" : "_san_rule_sa0005.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Utilizzo di indirizzi diretti \/ SA0005: Indirizzi e tipi di dati non validi ", 
"snippet" : "Rileva l'indirizzo non valido e le specifiche del tipo di dati. Prefissi di dimensioni validi negli indirizzi: X per BOOL , B per tipi di dati a 1 byte, W per tipi di dati a 2 byte e D per tipi di dati a 4 byte. Motivo: le variabili che si trovano in indirizzi diretti devono essere associate a un in...", 
"body" : "Rileva l'indirizzo non valido e le specifiche del tipo di dati. Prefissi di dimensioni validi negli indirizzi: X per BOOL , B per tipi di dati a 1 byte, W per tipi di dati a 2 byte e D per tipi di dati a 4 byte. Motivo: le variabili che si trovano in indirizzi diretti devono essere associate a un indirizzo che corrisponda al loro intervallo di tipi di dati. Può confondere il lettore del codice se, ad esempio, a DWORD su un BYTE l'indirizzo è fissato. Importanza: Bassa Esempio PROGRAM Check_Address_Type_PRG\nVAR\n iVar AT %QB0 : INT ; \/\/ OK e. g.: %QW0\n xTest AT %QW1 : BOOL ; \/\/ OK e. g.: %QX1.0\nEND_VAR iVar := iVar + INT#1;\nxTest := NOT xTest;\n Uscita in Messaggi vista: SA0005: indirizzo non valido per il tipo di dati 'iVar' Per ulteriori informazioni, vedere: Configura ed esegui analisi del codice statico " }, 
{ "title" : "SA0047: Accede all'indirizzo diretto ", 
"url" : "_san_rule_sa0047.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Utilizzo di indirizzi diretti \/ SA0047: Accede all'indirizzo diretto ", 
"snippet" : "Determina l'accesso diretto all'indirizzo nel codice di implementazione. Motivazione: La programmazione simbolica è sempre preferibile. Una variabile ha un nome che può avere anche un significato. Un indirizzo non può indicare a cosa serve. Importanza: Alta Regola PLCopen: N1 \/ CP1 Esempio PROGRAM P...", 
"body" : "Determina l'accesso diretto all'indirizzo nel codice di implementazione. Motivazione: La programmazione simbolica è sempre preferibile. Una variabile ha un nome che può avere anche un significato. Un indirizzo non può indicare a cosa serve. Importanza: Alta Regola PLCopen: N1 \/ CP1 Esempio PROGRAM PLC_PRG\nVAR\n xVar : BOOL;\n byVar : BYTE;\nEND_VAR\n xVar := %IX0.0;\n%QX0.0 := xVar;\n%MX0.1 := xVar;\n%MB1 := byVar; Uscita in Messaggi vista: SA0047: accessi all'indirizzo diretto '%IX0.0' SA0026: accessi all'indirizzo diretto '%QX0.0' SA0026: accessi all'indirizzo diretto '%MX0.1' SA0026: accessi all'indirizzo diretto '%MB1' " }, 
{ "title" : "SA0048: dichiarazioni AT su indirizzi diretti ", 
"url" : "_san_rule_sa0048.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Utilizzo di indirizzi diretti \/ SA0048: dichiarazioni AT su indirizzi diretti ", 
"snippet" : "Rileva AT dichiarazioni sugli indirizzi diretti L'uso di indirizzi diretti nel codice è problematico perché l'indirizzo appare in più posizioni: Innanzitutto nella configurazione del controller dove viene definita l'assegnazione di un oggetto fisico ad un indirizzo Il secondo nel programma in cui le...", 
"body" : "Rileva AT dichiarazioni sugli indirizzi diretti L'uso di indirizzi diretti nel codice è problematico perché l'indirizzo appare in più posizioni: Innanzitutto nella configurazione del controller dove viene definita l'assegnazione di un oggetto fisico ad un indirizzo Il secondo nel programma in cui le variabili vengono assegnate a questi indirizzi. Se gli indirizzi vengono spostati perché la configurazione è stata modificata, è necessario riassegnare le variabili agli indirizzi in una posizione completamente diversa nel programma. Ciò è causa di errore e comporta una scarsa leggibilità e manutenibilità del codice. Pertanto, è meglio eseguire tutte le assegnazioni nella mappatura I\/O dell'editor del dispositivo. Importanza: Alta Regola PLCopen: N1 \/ CP1 Ti consigliamo di utilizzare indirizzi diretti SOLO nel file Mappatura I\/O scheda dell'editor del dispositivo. Esempio PROGRAM PLC_PRG\nVAR\n xVar1 AT %IX0.0 : BOOL;\n byVar1 AT %IB1 : BYTE;\n xVar2 AT %QX0.0 : BOOL;\nEND_VAR\n Uscita in Messaggi vista: SA0048: la dichiarazione utilizza l'indirizzo diretto '%IX0.0' SA0048: la dichiarazione utilizza l'indirizzo diretto '%IB1' SA0048: la dichiarazione utilizza l'indirizzo diretto '%QX0.0' " }, 
{ "title" : "Regole per gli operatori ", 
"url" : "_san_rule_operators.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0051: Operazioni di confronto su variabili BOOL ", 
"url" : "_san_rule_sa0051.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0051: Operazioni di confronto su variabili BOOL ", 
"snippet" : "Determina le operazioni di confronto sulle variabili di tipo BOOL . Giustificazione: CODESYS consente questo tipo di confronti. Ma sono molto insoliti e possono creare confusione. La norma IEC 61131-3 non prevede questi confronti. Evitandoli, aumenti la portabilità del codice su altri sistemi di svi...", 
"body" : "Determina le operazioni di confronto sulle variabili di tipo BOOL . Giustificazione: CODESYS consente questo tipo di confronti. Ma sono molto insoliti e possono creare confusione. La norma IEC 61131-3 non prevede questi confronti. Evitandoli, aumenti la portabilità del codice su altri sistemi di sviluppo. Importanza: Media Esempio PROGRAM PLC_PRG\nVAR\n xBool1, xBool2 : BOOL;\n xResult : BOOL;\nEND_VAR\n xResult := xBool1 > xBool2; \/\/ SA0051\nxBool1 := NOT xBool1; \/\/ OK!\nxBool2 := xBool2 XOR xBool1; \/\/ OK! Uscita in Messaggi vista: SA0051: Operazioni di confronto su variabili BOOL " }, 
{ "title" : "SA0052: Operazione di turno insolita ", 
"url" : "_san_rule_sa0052.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0052: Operazione di turno insolita ", 
"snippet" : "Determina le operazioni di spostamento (spostamento di bit) su variabili con segno. Per operazioni di spostamento su tipi di dati bit field ( Byte , DWORD , LWORD , WORD ) non viene emesso alcun errore. Motivo: CODESYS consente operazioni di turno sui tipi di dati firmati. Tuttavia, queste operazion...", 
"body" : "Determina le operazioni di spostamento (spostamento di bit) su variabili con segno. Per operazioni di spostamento su tipi di dati bit field ( Byte , DWORD , LWORD , WORD ) non viene emesso alcun errore. Motivo: CODESYS consente operazioni di turno sui tipi di dati firmati. Tuttavia, queste operazioni sono rare e possono creare confusione. La norma IEC-61131-3 non prevede tali operazioni e dovrebbero essere evitate per aumentare la portabilità del codice ad altri sistemi di sviluppo. Importanza: Media Esempio PROGRAM PLC_PRG\nVAR\n iTemp : INT;\n dwTemp1 : DWORD;\n byTemp2 : BYTE;\n diTemp3 : DINT;\n siTemp4 : SINT;\n liTemp5 : LINT;\nEND_VAR\n \/\/the following lines each will cause an SA0052:\niTemp := SHL(iTemp, BYTE#2);\ndiTemp3 := SHR(diTemp3, BYTE#4);\nsiTemp4 := ROL(siTemp4, BYTE#2);\nliTemp5 := ROR(liTemp5, BYTE#2);\n\n\/\/no error SA0052 because DWORD and BYTE are bitfield datatypes:\ndwTemp1 := SHL(dwTemp1, BYTE#3);\nbyTemp2 := SHR(byTemp2, BYTE#1); Uscita in Messaggi vista: SA0052: Funzionamento del cambio insolito " }, 
{ "title" : "SA0053: spostamento bit a bit troppo grande ", 
"url" : "_san_rule_sa0053.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0053: spostamento bit a bit troppo grande ", 
"snippet" : "Quando si esegue lo spostamento bit per bit (spostamento dei bit) degli operandi, determina se la larghezza del tipo di dati dell'operando è stata superata. Motivo: se un'operazione di spostamento va oltre la larghezza del tipo di dati, viene creata una costante 0 . Se uno spostamento di rotazione s...", 
"body" : "Quando si esegue lo spostamento bit per bit (spostamento dei bit) degli operandi, determina se la larghezza del tipo di dati dell'operando è stata superata. Motivo: se un'operazione di spostamento va oltre la larghezza del tipo di dati, viene creata una costante 0 . Se uno spostamento di rotazione supera la larghezza del tipo di dati, è difficile da leggere. Pertanto, il valore di rotazione dovrebbe essere ridotto. Importanza: Alta Esempio PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\n lwTemp4 : LWORD;\nEND_VAR\n byTemp1 := SHR(byTemp1, BYTE#25);\nwTemp2 := SHL(wTemp2, BYTE#45);\ndwTemp3 := ROR(dwTemp3, BYTE#78);\nlwTemp4 := ROL(lwTemp4, BYTE#111); Uscita in Messaggi vista: SA0053: Spostamento bit per bit troppo grande " }, 
{ "title" : "SA0054: Confronta REAL \/ LREAL per uguaglianza\/disuguaglianza ", 
"url" : "_san_rule_sa0054.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0054: Confronta REAL \/ LREAL per uguaglianza\/disuguaglianza ", 
"snippet" : "Determina se gli operatori di confronto = (uguaglianza) e <> (disuguaglianza) Operandi di tipo REAL o LREAL per confrontare. Giustificazione: REAL \/ LREAL i valori sono implementati come numeri in virgola mobile secondo lo standard IEEE 754. Questo standard implica che numeri decimali specifici, app...", 
"body" : "Determina se gli operatori di confronto = (uguaglianza) e <> (disuguaglianza) Operandi di tipo REAL o LREAL per confrontare. Giustificazione: REAL \/ LREAL i valori sono implementati come numeri in virgola mobile secondo lo standard IEEE 754. Questo standard implica che numeri decimali specifici, apparentemente semplici, non possano essere rappresentati con precisione. Di conseguenza, potrebbero esserci rappresentazioni diverse come LREAL per lo stesso numero decimale. Consideriamo le seguenti righe di codice: lr11 := 1.1;\nlr33 := 3.3;\nlrVar1 := lr11 + lr11;\nlrVar2 := lr33 - lr11;\nbotest := lrVar1 = lrVar2; In questo caso, botest ritorna FALSE , anche se le variabili lrVar1 E lrVar2 entrambi restituiscono il valore di monitoraggio di \"2.2\". Questo non è un errore del compilatore, ma una proprietà delle unità in virgola mobile di tutti i processori convenzionali. Puoi evitarlo specificando un valore minimo in base al quale i valori possono differire: botest := ABS(lrVar1 - lrVar2) < 0.1; Eccezione: un confronto con 0.0 non è riportato in questa analisi. Per lo 0 esiste una rappresentazione esatta nello standard IEEE 754 e quindi il confronto funziona normalmente come previsto. Pertanto, per ottenere prestazioni migliori, è opportuno consentire qui un confronto diretto. Importanza: Alta Regola PLCopen: CP54 Esempio PROGRAM PLC_PRG\nVAR\n rTest1 : REAL;\n rTest2 : REAL;\n lrTest3 : LREAL;\n lrTest4 : LREAL;\n xResult : BOOL;\nEND_VAR \/\/the following lines each will cause an SA0054:\nxResult := rTest1 = rTest1;\nxResult := rTest1 = rTest2;\nxResult := rTest1 <> rTest2;\nxResult := lrTest3 = lrTest3;\nxResult := lrTest3 = lrTest4;\nxResult := lrTest3 <> lrTest4;\n\/\/the following lines each will not cause an SA0054:\nxResult := rTest1 > rTest2;\nxResult := lrTest3 < lrTest4;\n Uscita in Messaggi vista: SA0054: Confronti REAL\/LREAL per uguaglianza\/disuguaglianza " }, 
{ "title" : "SA0055: Operazioni di confronto non necessarie di operandi senza segno ", 
"url" : "_san_rule_sa0055.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0055: Operazioni di confronto non necessarie di operandi senza segno ", 
"snippet" : "Rileva confronti non necessari con operandi senza segno. Un tipo di dati senza segno non è mai inferiore a zero. Questo può essere usato come un segno di controllo. Motivo: un confronto scoperto con questo controllo restituisce un risultato costante e questo indica un errore nel codice. Importanza: ...", 
"body" : "Rileva confronti non necessari con operandi senza segno. Un tipo di dati senza segno non è mai inferiore a zero. Questo può essere usato come un segno di controllo. Motivo: un confronto scoperto con questo controllo restituisce un risultato costante e questo indica un errore nel codice. Importanza: Alta Esempio PROGRAM PLC_PRG\nVAR\n byTest: BYTE;\nEND_VAR\n \/\/ SA0055\nWHILE byTest >= 0 DO\n byTest := byTest - 1;\nEND_WHILE Uscita in Messaggi vista: SA0055: Confronti non necessari di operandi senza segno " }, 
{ "title" : "SA0056: Costante fuori range ", 
"url" : "_san_rule_sa0056.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0056: Costante fuori range ", 
"snippet" : "Trova i valori letterali (costanti) al di fuori dell'ambito dell'operatore. Motivo: il messaggio viene emesso nei casi in cui un valore viene confrontato con una costante che si trova al di fuori dell'intervallo di valori di questo valore. Il confronto quindi restituisce costante TRUE o FALSE . Ques...", 
"body" : "Trova i valori letterali (costanti) al di fuori dell'ambito dell'operatore. Motivo: il messaggio viene emesso nei casi in cui un valore viene confrontato con una costante che si trova al di fuori dell'intervallo di valori di questo valore. Il confronto quindi restituisce costante TRUE o FALSE . Questo indica un errore di programmazione. Importanza: Alta Esempio PROGRAM PLC_PRG\nVAR\n byTestVar: BYTE;\nEND_VAR\n WHILE byTestVar >= 260 DO\n byTestVar := byTestVar + 1;\nEND_WHILE Uscita in Messaggi vista: SA0056: Costante fuori intervallo valido " }, 
{ "title" : "SA0057: Possibile perdita di decimali ", 
"url" : "_san_rule_sa0057.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0057: Possibile perdita di decimali ", 
"snippet" : "Determina le istruzioni con possibile perdita di cifre decimali. Motivo: un pezzo di codice del seguente tipo: diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) può portare a interpretazioni errate. L'autore o il lettore di questa riga di codice può presumere che la divisione sarebbe come REAL -Opera...", 
"body" : "Determina le istruzioni con possibile perdita di cifre decimali. Motivo: un pezzo di codice del seguente tipo: diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) può portare a interpretazioni errate. L'autore o il lettore di questa riga di codice può presumere che la divisione sarebbe come REAL -Operazione eseguita e il risultato sarebbe in questo caso REAL#0.5 essendo. Tuttavia, questo non è il caso, l'operazione viene eseguita come un'operazione intera, il risultato è attivo REAL cast e rTemp1 ottiene il valore REAL#0 . Per evitare ciò, utilizzare un cast per assicurarsi che l'operazione venga eseguita come a REAL operazione: rTemp1 := TO_REAL(diTemp2) \/ REAL#2; Importanza: Media Esempio PROGRAM PLC_PRG\nVAR\n rTemp1 : REAL;\n diTemp2 : DINT;\n liTemp3 : LINT;\nEND_VAR diTemp2 := diTemp2 + DINT#11;\n\/\/ SA0057\nrTemp1 := DINT_TO_REAL(diTemp2 \/ DINT#3); \nrTemp1 := DINT_TO_REAL(diTemp2) \/ REAL#3.0;\nliTemp3 := liTemp3 + LINT#13;\n\/\/ SA0057\nrTemp1 := LINT_TO_REAL(liTemp3 \/ LINT#7);\nrTemp1 := LINT_TO_REAL(liTemp3) \/ REAL#7.0; Uscita in Messaggi vista: SA0057: Possibile perdita di cifre decimali " }, 
{ "title" : "SA0058: Operazione su variabili di enumerazione ", 
"url" : "_san_rule_sa0058.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0058: Operazione su variabili di enumerazione ", 
"snippet" : "Determina le operazioni sulle variabili dell'enumerazione del tipo di dati. Sono ammessi incarichi. Motivazione: Le enumerazioni non dovrebbero essere utilizzate come valori interi ordinari. In alternativa, è possibile definire un tipo di dati alias o utilizzare un tipo di sottointervallo. Importanz...", 
"body" : "Determina le operazioni sulle variabili dell'enumerazione del tipo di dati. Sono ammessi incarichi. Motivazione: Le enumerazioni non dovrebbero essere utilizzate come valori interi ordinari. In alternativa, è possibile definire un tipo di dati alias o utilizzare un tipo di sottointervallo. Importanza: Media Eccezione: se un'enumerazione con l'attributo {attribute 'strict'} è contrassegnato, quindi il compilatore segnala già tale operazione. Se un'enumerazione dal pragma {attribute 'flags'} viene dichiarato per cui viene utilizzata una bandiera AND -, OR -, NOT - o XOR -Le operazioni non hanno restituito errori. Esempio TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : My_Enum;\nEND_VAR iTemp1 := iTemp1 + INT#1;\nabc := My_Enum.red; \/\/ OK\niTemp1 := My_Enum.black \/ My_Enum.blue; \/\/ SA0058\niTemp1 := My_Enum.green \/ My_Enum.red; \/\/ SA0058\n Uscita in Messaggi vista: SA0058: Operazioni sulle variabili di enumerazione Esempio con un pragma {attributo 'flags'} {attribute 'flags'} \/\/ declaring the enumeration as a \"flag\"\nTYPE Flags :\n(\n Unknown := 16#00000001,\n Stopped := 16#00000002,\n Running := 16#00000004\n) DWORD;\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : Flags;\n batate : BYTE;\n dwFlags : DWORD;\n dwState : DWORD;\nEND_VAR \/\/ OK for the following\nIF (dwFlags AND Flags.Unknown) <> DWORD#0 THEN\n dwState := dwState AND Flags.Unknown;\n ELSIF (dwFlags OR Flags.Stopped) <> DWORD#0 THEN\n dwState := dwState OR Flags.Running;\nEND_IF " }, 
{ "title" : "SA0059: Operazioni di confronto che restituiscono sempre TRUE o FALSE ", 
"url" : "_san_rule_sa0059.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0059: Operazioni di confronto che restituiscono sempre TRUE o FALSE ", 
"snippet" : "Rileva confronti con valori letterali il cui risultato è sempre TRUE O FALSE , e può essere già elaborato durante la compilazione. Motivazione: Un'operazione che è costante TRUE o FALSE restituisce è un'indicazione di un errore di programmazione. Importanza: Alta Esempio PROGRAM PLC_PRG VAR byTemp1 ...", 
"body" : "Rileva confronti con valori letterali il cui risultato è sempre TRUE O FALSE , e può essere già elaborato durante la compilazione. Motivazione: Un'operazione che è costante TRUE o FALSE restituisce è un'indicazione di un errore di programmazione. Importanza: Alta Esempio PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\nEND_VAR\n WHILE byTemp1 <= 255 DO\n byTemp1 := byTemp1 + 1;\nEND_WHILE Uscita in Messaggi vista: SA0059: L'operatore relazionale '<=' restituisce sempre 'TRUE'\n " }, 
{ "title" : "SA0060: Null come operando non valido ", 
"url" : "_san_rule_sa0060.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0060: Null come operando non valido ", 
"snippet" : "Rileva le operazioni in cui è presente un operando con il valore 0 provoca un'operazione non valida o priva di senso Motivo: tale espressione può indicare un errore di programmazione. In ogni caso, costa runtime inutilmente. Importanza: Media Esempio PROGRAM PLC_PRG VAR byTemp1 : BYTE; wTemp2 : WORD...", 
"body" : "Rileva le operazioni in cui è presente un operando con il valore 0 provoca un'operazione non valida o priva di senso Motivo: tale espressione può indicare un errore di programmazione. In ogni caso, costa runtime inutilmente. Importanza: Media Esempio PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\nEND_VAR\n byTemp1 := byTemp1 + 0;\nwTemp2 := wTemp2 - WORD#0;\ndwTemp3 := dwTemp3 * DWORD#0; Uscita in Messaggi vista: SA0060: Zero utilizzato come operando non valido " }, 
{ "title" : "SA0061: Operazione insolita sul puntatore ", 
"url" : "_san_rule_sa0061.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0061: Operazione insolita sul puntatore ", 
"snippet" : "Determina le operazioni sulle variabili di tipo POINTER TO che non lo fanno = (Uguaglianza), <> (Disuguaglianza), + (aggiunta) o ADR sono. In CODESYS L'aritmetica del puntatore è generalmente consentita e può anche essere utilizzata in modo ragionevole. L'aggiunta di un puntatore con valore intero è...", 
"body" : "Determina le operazioni sulle variabili di tipo POINTER TO che non lo fanno = (Uguaglianza), <> (Disuguaglianza), + (aggiunta) o ADR sono. In CODESYS L'aritmetica del puntatore è generalmente consentita e può anche essere utilizzata in modo ragionevole. L'aggiunta di un puntatore con valore intero è quindi classificata come una normale operazione sui puntatori. Ciò consente di elaborare un array con una lunghezza variabile utilizzando un puntatore. Tutte le altre operazioni (insolite) con i puntatori vengono riportate con SA0061. Importanza: Alta Regola PLCopen: E2 \/ E3 Esempio PROGRAM PLC_PRG\nVAR\n piTemp : POINTER TO INT;\n iTemp : INT;\nEND_VAR\n iTemp := iTemp + INT#1;\npiTemp := ADR(iTemp);\npiTemp := piTemp * DWORD#5; \/\/ SA0061\npiTemp := piTemp \/ DWORD#2; \/\/ SA0061\npiTemp := piTemp MOD DWORD#3; \/\/ SA0061\npiTemp := piTemp + DWORD#1;\npiTemp := piTemp - DWORD#1; \/\/ SA0061 Uscita in Messaggi vista: SA0061: Operazione insolita sul puntatore " }, 
{ "title" : "SA0062: L'espressione è costante ", 
"url" : "_san_rule_sa0062.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0062: L'espressione è costante ", 
"snippet" : "Rileva l'utilizzo di espressioni che hanno sempre lo stesso valore in fase di esecuzione. Giustificazione: Un'espressione complessa che viene calcolata ripetutamente e genera sempre lo stesso valore può indicare un errore. Ciò vale in particolare se si intendeva qualcos'altro. In ogni caso, l'espres...", 
"body" : "Rileva l'utilizzo di espressioni che hanno sempre lo stesso valore in fase di esecuzione. Giustificazione: Un'espressione complessa che viene calcolata ripetutamente e genera sempre lo stesso valore può indicare un errore. Ciò vale in particolare se si intendeva qualcos'altro. In ogni caso, l'espressione grava inutilmente sull'esecuzione del programma. Importanza: Media Esempio PROGRAM PLC_PRG\nVAR\n value : INT;\n condition : BOOL;\nEND_VAR\n value := 8;\ncondition := value = 8 \/\/ Reports: Expression (value=8) is always TRUE Uscita in Messaggi visualizza: SA0062: L'espressione '(value=8)' è sempre VERA " }, 
{ "title" : "SA0063: Possibili operazioni non compatibili a 16 bit ", 
"url" : "_san_rule_sa0063.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0063: Possibili operazioni non compatibili a 16 bit ", 
"snippet" : "Determina le operazioni a 16 bit con risultati intermedi. Sfondo: i risultati intermedi a 32 bit possono essere troncati su sistemi a 16 bit. Esempio: (int+10) può superare i 16 bit. Motivo: questo messaggio ha lo scopo di proteggere da problemi nel caso molto raro in cui devi scrivere codice che do...", 
"body" : "Determina le operazioni a 16 bit con risultati intermedi. Sfondo: i risultati intermedi a 32 bit possono essere troncati su sistemi a 16 bit. Esempio: (int+10) può superare i 16 bit. Motivo: questo messaggio ha lo scopo di proteggere da problemi nel caso molto raro in cui devi scrivere codice che dovrebbe essere eseguito sia su un processore a 16 bit che su un processore a 32 bit. Importanza: Bassa Esempio PROGRAM PLC_PRG\nVAR\n iVar : INT;\nEND_VAR\n iVar := (iVar + 10) \/ 2; Uscita in Messaggi vista: SA0063: Compatibilità per 16 Bit – Possibile risultato intermedio troncato " }, 
{ "title" : "SA0064: Aggiunta di un puntatore ", 
"url" : "_san_rule_sa0064.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0064: Aggiunta di un puntatore ", 
"snippet" : "Determina le addizioni di puntatori. Motivazione: In CODESYS , l'aritmetica dei puntatori è generalmente consentita e può anche essere utilizzata in modo appropriato. Rappresenta però anche una fonte di errore. Pertanto, esistono regole di programmazione che generalmente vietano l'aritmetica dei pun...", 
"body" : "Determina le addizioni di puntatori. Motivazione: In CODESYS , l'aritmetica dei puntatori è generalmente consentita e può anche essere utilizzata in modo appropriato. Rappresenta però anche una fonte di errore. Pertanto, esistono regole di programmazione che generalmente vietano l'aritmetica dei puntatori. Questo test può verificare tale requisito. Importanza: Media Esempio PROGRAM PLC_PRG\nVAR\n iTest : INT;\n ariTest : ARRAY[0..10] OF INT;\n {attribute 'analysis':='-111'}\n piTest : POINTER TO INT;\n i : INT;\nEND_VAR\n piTest := ADR(ariTest[0]); \/\/ OK\npiTest^ := 0;\npiTest := ADR(ariTest) + SIZEOF(INT); \/\/ SA0064\npiTest^ := 1;\npiTest := ADR(ariTest) + 6; \/\/ SA0064\npiTest^ := 3;\npiTest := ADR(ariTest[10]);\nFOR i:=0 TO 10 DO\n piTest^ := i;\n piTest := piTest + 2; \/\/ SA0064\nEND_FOR Uscita in Messaggi vista: SA0064: Aggiunta del puntatore " }, 
{ "title" : "SA0065: L'aggiunta del puntatore non corrisponde alla dimensione della base ", 
"url" : "_san_rule_sa0065.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0065: L'aggiunta del puntatore non corrisponde alla dimensione della base ", 
"snippet" : "Rileva aggiunte di puntatori per le quali il valore da aggiungere non corrisponde alla dimensione di base del puntatore. Solo i valori letterali della dimensione dei dati di base e i loro multipli possono essere aggiunti senza errori. Motivazione: In CODESYS (a differenza di C e C++), quando si aggi...", 
"body" : "Rileva aggiunte di puntatori per le quali il valore da aggiungere non corrisponde alla dimensione di base del puntatore. Solo i valori letterali della dimensione dei dati di base e i loro multipli possono essere aggiunti senza errori. Motivazione: In CODESYS (a differenza di C e C++), quando si aggiunge un puntatore con un valore intero, viene aggiunto solo questo valore intero come numero di byte e non il valore intero moltiplicato per la dimensione di base. Esempio a ST pINT := ADR(array_of_int[0]);\npINT := pINT + 2; \/\/in CODESYS, pINT then points to array_of_int[1] Questo codice funzionerebbe diversamente in C: short* pShort\npShort = &(array_of_short[0])\npShort = pShort + 2; \/\/in C, pShort then points to array_of_short[2] Pertanto, dentro CODESYS , dovresti sempre aggiungere a un puntatore un multiplo della dimensione di base del puntatore. Altrimenti, il puntatore potrebbe puntare a non allineato memoria che (a seconda del processore) può portare a un'eccezione di allineamento quando si accede ad essa. Importanza: Alta Esempio VAR\n pudiTest:POINTER TO UDINT;\n udiTest:UDINT;\n prTest:POINTER TO REAL;\n rTest:REAL;\nEND_VAR pudiTest := ADR(udiTest) + 4; \/\/ OK\npudiTest := ADR(udiTest) + ( 2 + 2 ); \/\/ OK\npudiTest := ADR(udiTest) + SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + 3; \/\/ SA0065\npudiTest := ADR(udiTest) + 2*SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + ( 3 + 2 ); \/\/ SA0065\nprTest := ADR(rTest);\nprTest := prTest + 4; \/\/ OK\nprTest := prTest + ( 2 + 2 ); \/\/ OK\nprTest := prTest + SIZEOF(REAL); \/\/ OK\nprTest := prTest + 1; \/\/ SA0065\nprTest := prTest + 2; \/\/ SA0065\nprTest := prTest + 3; \/\/ SA0065\nprTest := prTest + ( SIZEOF(REAL) - 1 ); \/\/ SA0065\nprTest := prTest + ( 1 + 4 ); \/\/ SA0065\n Uscita in Messaggi vista: SA0065: Aggiunta errata del puntatore alla dimensione di base " }, 
{ "title" : "SA0066: Utilizzo di risultati intermedi ", 
"url" : "_san_rule_sa0066.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per gli operatori \/ SA0066: Utilizzo di risultati intermedi ", 
"snippet" : "Rileva l'uso di risultati temporanei nelle istruzioni con un tipo di dati inferiore alla dimensione del registro. In questo caso, il cast implicito può portare a risultati indesiderati. Motivazione: Per ragioni di prestazione, CODESYS Static Analysis esegue operazioni sulla larghezza di registro del...", 
"body" : "Rileva l'uso di risultati temporanei nelle istruzioni con un tipo di dati inferiore alla dimensione del registro. In questo caso, il cast implicito può portare a risultati indesiderati. Motivazione: Per ragioni di prestazione, CODESYS Static Analysis esegue operazioni sulla larghezza di registro del processore. I risultati intermedi non vengono troncati. Ciò può portare a interpretazioni errate, come nel caso seguente: Esempio usintTest := 0; xError := usintTest - 1 <> 255; In CODESYS , xError È TRUE in questo caso perché l'operazione usintTest - 1 viene in genere eseguito come un'operazione a 32 bit e il risultato non viene convertito nella dimensione in byte. Poi il valore 16#ffffffff (diverso da 255) si trova nel registro. Per evitare ciò, è necessario eseguire esplicitamente il cast del risultato intermedio: xError := TO_USINT(usintTest - 1) <> 255; Se questa notifica viene attivata, verrà segnalato un numero elevato di posti nel codice piuttosto non problematici. Un problema può sorgere solo se l'operazione produce un overflow o un underflow nel tipo di dati, ma l'analisi statica non è in grado di distinguere tra le singole posizioni. Se installi un typecast esplicito in tutte le posizioni segnalate, il codice sarà notevolmente più lento e meno leggibile! Importanza: Bassa Esempio PROGRAM PLC_PRG\nVAR\n byTest:BYTE;\n liTest:LINT;\n xError:BOOL;\nEND_VAR \/\/type size smaller than register size;\nbyTest := 0;\nIF (byTest - 1) <> 255 THEN \/\/use of temporary result + implicit casting -> SA0066\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n\n\/\/type size equal to or bigger than register size;\nliTest := 0;\nIF (liTest - 1) <> -1 THEN \/\/ use of temporary result and no implicit casting -> OK\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n Uscita in Messaggi vista: SA0066: Utilizzo di risultati temporanei (byTest - USINT #1) " }, 
{ "title" : "Regole per le istruzioni ", 
"url" : "_san_rule_instructions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per le istruzioni ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0072: Utilizzo non valido di una variabile contatore ", 
"url" : "_san_rule_sa0072.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per le istruzioni \/ SA0072: Utilizzo non valido di una variabile contatore ", 
"snippet" : "Determina l'uso di una variabile contatore all'interno di a FOR -Nastro. Motivazione: Manipolazione della controvariabile in a FOR loop può facilmente risultare in un ciclo infinito. Per impedire l'esecuzione del ciclo per valori specifici della variabile contatore, utilizzare CONTINUE o semplicemen...", 
"body" : "Determina l'uso di una variabile contatore all'interno di a FOR -Nastro. Motivazione: Manipolazione della controvariabile in a FOR loop può facilmente risultare in un ciclo infinito. Per impedire l'esecuzione del ciclo per valori specifici della variabile contatore, utilizzare CONTINUE o semplicemente un IF . Importanza: Alta Regola PLCopen: L12 Esempio PROGRAM PLC_PRG\nVAR_TEMP\n iIndex : INT;\nEND_VAR FOR iIndex := INT#0 TO INT#20 BY INT#1 DO\n iIndex := iIndex - INT#1;\nEND_FOR Uscita in Messaggi visualizzazione: SA0072: Usi non validi della variabile contatore 'iIndex' " }, 
{ "title" : "SA0073: Utilizzo di una variabile contatore non temporanea ", 
"url" : "_san_rule_sa0073.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per le istruzioni \/ SA0073: Utilizzo di una variabile contatore non temporanea ", 
"snippet" : "Rileva l'uso di variabili non temporanee in FOR -Macinare. Motivo: questo è un avviso di prestazione. Una variabile contatore viene sempre inizializzata ogni volta che viene richiamato un blocco di programmazione. È possibile utilizzare tale variabile come variabile temporanea ( VAR_TEMP ), l'access...", 
"body" : "Rileva l'uso di variabili non temporanee in FOR -Macinare. Motivo: questo è un avviso di prestazione. Una variabile contatore viene sempre inizializzata ogni volta che viene richiamato un blocco di programmazione. È possibile utilizzare tale variabile come variabile temporanea ( VAR_TEMP ), l'accesso potrebbe essere più rapido e la variabile non occupa spazio di memoria permanente. Importanza: media Regola PLCopen: CP21 \/ L13 Esempio PROGRAM PLC_PRG\nVAR\n nIndex : INT;\n iVar : INT;\nEND_VAR FOR nIndex := INT#0 TO INT#20 BY INT#1 DO\n iVar := iVar + nIndex;\nEND_FOR\n Uscita in vista Messaggi : SA0073: Variabile contatore non corrispondente " }, 
{ "title" : "SA0075: ELSE mancante ", 
"url" : "_san_rule_sa0075.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per le istruzioni \/ SA0075: ELSE mancante ", 
"snippet" : "determinato CASE -Istruzioni senza ELSE -Ramo. Motivazione: La programmazione difensiva richiede la presenza di a ELSE in ciascuna CASE -Istruzione. se io sono ELSE -Se non c'è niente da fare, dovresti contrassegnarlo con un commento. È quindi chiaro al lettore del codice che il caso non è stato sem...", 
"body" : "determinato CASE -Istruzioni senza ELSE -Ramo. Motivazione: La programmazione difensiva richiede la presenza di a ELSE in ciascuna CASE -Istruzione. se io sono ELSE -Se non c'è niente da fare, dovresti contrassegnarlo con un commento. È quindi chiaro al lettore del codice che il caso non è stato semplicemente dimenticato. Importanza: bassa Regola PLCopen: L17 For CASE istruzioni che utilizzano enumerazioni con attributo strict  e dove vengono utilizzate tutte le costanti di enumerazione in CASE viene utilizzata l'istruzione, non viene emesso alcun messaggio di errore. Esempio PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\nCASE iVar OF\n INT#1:\n xTemp := FALSE;\n INT#2:\n xTemp := TRUE;\nEND_CASE\n Uscita in Messaggi visualizzazione: SA0075: ELSE mancante nell'istruzione CASE " }, 
{ "title" : "SA0076: Costante di enumerazione mancante ", 
"url" : "_san_rule_sa0076.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per le istruzioni \/ SA0076: Costante di enumerazione mancante ", 
"snippet" : "Determina se ciascuna costante di enumerazione viene utilizzata o meno come condizione in CASE dichiarazioni e interrogato in a CASE ramo. Motivazione: la programmazione difensiva richiede la gestione di tutti i possibili valori di un'enumerazione. Se non è richiesta alcuna azione per un valore di e...", 
"body" : "Determina se ciascuna costante di enumerazione viene utilizzata o meno come condizione in CASE dichiarazioni e interrogato in a CASE ramo. Motivazione: la programmazione difensiva richiede la gestione di tutti i possibili valori di un'enumerazione. Se non è richiesta alcuna azione per un valore di enumerazione specifico, contrassegnarlo esplicitamente con un commento. È quindi chiaro al lettore del codice che il valore non è stato semplicemente dimenticato. Importanza: Bassa Esempio TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iVar : My_Enum;\n xTemp : BOOL;\nEND_VAR iVar := My_Enum.black;\nCASE iVar OF\n My_Enum.red:\n xTemp := FALSE;\n My_Enum.blue, My_Enum.green:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n Uscita in Messaggi vista: SA0076: Costante di enumerazione 'black' mancante nell'istruzione CASE " }, 
{ "title" : "SA0077: Mancata corrispondenza del tipo di enumerazione con CASE espressione ", 
"url" : "_san_rule_sa0077.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per le istruzioni \/ SA0077: Mancata corrispondenza del tipo di enumerazione con CASE espressione ", 
"snippet" : "Rileva le posizioni del codice in cui un CASE l'istruzione mescola i valori di enumerazione con i tipi non di enumerazione. Giustificazione: La combinazione di valori di enumerazione e valori interi nei costrutti CASE viola la sicurezza dei tipi di dati, riduce la leggibilità del codice e influisce ...", 
"body" : "Rileva le posizioni del codice in cui un CASE l'istruzione mescola i valori di enumerazione con i tipi non di enumerazione. Giustificazione: La combinazione di valori di enumerazione e valori interi nei costrutti CASE viola la sicurezza dei tipi di dati, riduce la leggibilità del codice e influisce sulla manutenibilità. I valori di enumerazione garantiscono la chiarezza semantica. L'uso di valori interi non elaborati comporta il rischio di errori minori e rende il codice più difficile da comprendere. Le modifiche al tipo di dati apportate alle enumerazioni possono inoltre distruggere i rami basati su numeri interi. Importanza: Bassa Esempio {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE DUT_MyEnum :\n(\n\tOne := 1, \n\tTwo := 2, \n\tThree := 3, \n\tFour := 4\n);\nEND_TYPE PROGRAM PRG_Case\nVAR\ndiVar : DINT;\nxTemp : BOOL;\n\neMyEnum : DUT_MyEnum;\nEND_VAR\n CASE diVar OF\n 1 :\n xTemp := FALSE;\n DUT_MyEnum.Two : \/\/ SA0077\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n\nCASE eMyEnum OF\n 1 : \/\/ SA0077\n xTemp := FALSE;\n DUT_MyEnum.Two:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE Uscita in Messaggi vista: SA0077: Tipo non corrispondente con l'espressione CASE " }, 
{ "title" : "SA0078: istruzioni CASE senza un ramo CASE ", 
"url" : "_san_rule_sa0078.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per le istruzioni \/ SA0078: istruzioni CASE senza un ramo CASE ", 
"snippet" : "determinato CASE -Istruzioni senza CASE -rami e con uno solo ELSE -Istruzione. Motivazione: A CASE l'istruzione senza casi fa sprecare tempo di esecuzione ed è difficile da leggere. Importanza: Media Esempio PROGRAM PLC_PRG VAR iVar : INT; xTemp : BOOL; END_VAR iVar := iVar + INT#1; \/\/in the followi...", 
"body" : "determinato CASE -Istruzioni senza CASE -rami e con uno solo ELSE -Istruzione. Motivazione: A CASE l'istruzione senza casi fa sprecare tempo di esecuzione ed è difficile da leggere. Importanza: Media Esempio PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\n\/\/in the following the case descriptions are missing:\nCASE iVar OF\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n Uscita in Messaggi vista: SA0078: Rami CASE mancanti " }, 
{ "title" : "SA0081: Il limite superiore non è un valore costante ", 
"url" : "_san_rule_sa0081.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per le istruzioni \/ SA0081: Il limite superiore non è un valore costante ", 
"snippet" : "Rileva il FOR istruzioni in cui il limite superiore non è definito con un valore costante Motivo: se il limite superiore di un ciclo è un valore variabile, non è più possibile vedere la frequenza con cui viene eseguito un ciclo. Questo può portare a seri problemi in fase di esecuzione, nel peggiore ...", 
"body" : "Rileva il FOR istruzioni in cui il limite superiore non è definito con un valore costante Motivo: se il limite superiore di un ciclo è un valore variabile, non è più possibile vedere la frequenza con cui viene eseguito un ciclo. Questo può portare a seri problemi in fase di esecuzione, nel peggiore dei casi a un ciclo infinito. Importanza: Alta Esempio PROGRAM PLC_PRG\nVAR\n i:INT;\n iBorder1: INT := 10;\n iBorder2: INT := 10;\n iCounter: INT;\nEND_VAR\nVAR CONSTANT\n ciBorder:INT := 10;\nEND_VAR\n FOR i:=0 TO 10 DO \/\/OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO ciBorder DO \/\/ OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder1 DO \/\/ SA0081\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder2 DO \/\/ SA0081\n iCounter := i;\n IF iCounter = 10 THEN\n iBorder2 := 50;\n END_IF\nEND_FOR\n Uscita in Messaggi vista: SA0081: Il bordo superiore di un ciclo for deve essere un valore costante " }, 
{ "title" : "SA0090: Istruzione RETURN prima della fine della funzione ", 
"url" : "_san_rule_sa0090.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Regole per le istruzioni \/ SA0090: Istruzione RETURN prima della fine della funzione ", 
"snippet" : "Rileva le posizioni dei codici in cui RETURN L'istruzione non è l'ultima istruzione in una funzione, metodo, proprietà o programma. Luoghi in cui a RETURN esiste all'interno di un IF vengono rilevati anche i rami. Motivo: A RETURN nel codice porta a una minore manutenibilità, testabilità e leggibili...", 
"body" : "Rileva le posizioni dei codici in cui RETURN L'istruzione non è l'ultima istruzione in una funzione, metodo, proprietà o programma. Luoghi in cui a RETURN esiste all'interno di un IF vengono rilevati anche i rami. Motivo: A RETURN nel codice porta a una minore manutenibilità, testabilità e leggibilità del codice. UN RETURN nel codice è facilmente trascurato. È necessario codificare che dovrebbe essere eseguito con tutti i mezzi quando una funzione esce, prima di ciascuno RETURN inserire e che spesso viene dimenticato. Importanza: Media Regola PLCopen: CP14 Esempio FUNCTION SA0090: DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR IF bTest THEN\n RETURN;\nEND_IF\nSA0090 := 99; Uscita in Messaggi vista: SA0090: Le POU dovranno avere un unico punto di uscita " }, 
{ "title" : "SA0095: Allocazione in condizione ", 
"url" : "_san_rule_sa0095.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0095: Allocazione in condizione ", 
"snippet" : "Determina gli incarichi in condizioni di IF -, CASE - o REPEAT -costruisce. Motivo: un compito (:=) e un confronto (=) possono essere facilmente confusi. Un'assegnazione in una condizione può quindi essere facilmente effettuata involontariamente e viene quindi segnalata. Questo può anche confondere ...", 
"body" : "Determina gli incarichi in condizioni di IF -, CASE - o REPEAT -costruisce. Motivo: un compito (:=) e un confronto (=) possono essere facilmente confusi. Un'assegnazione in una condizione può quindi essere facilmente effettuata involontariamente e viene quindi segnalata. Questo può anche confondere il lettore del codice. Importanza: Alta Esempio PROGRAM PLC_PRG\nVAR\n iCond1:INT := INT#1;\n iCond2:INT := INT#2;\n xCond:BOOL := FALSE;\n iVar : INT;\nEND_VAR IF INT_TO_BOOL(iCond1 := iCond2) THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\n ELSIF (iCond1 := 11) = 11 THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF xCond := TRUE THEN \/\/ SA0095\n xCond := FALSE;\nEND_IF\n\nIF (xCond := FALSE) OR (iCond1 := iCond2) = 12 THEN \/\/ SA0095\n xCond := FALSE;\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF (iVar := iVar + 1) = 120 THEN \/\/ SA0095 (can be valid, but is not reparable very well\n iVar := 0;\nEND_IF\n\nWHILE (xCond = TRUE) OR (iCond1 := iCond2) = 12 DO \/\/ SA0095\n xCond := FALSE;\nEND_WHILE\n\n\/\/Error: assignment in repeat loop\nREPEAT\n xCond := FALSE;\nUNTIL (xCond = TRUE) OR (iCond1 := iCond2) = 12 \/\/ SA0095\nEND_REPEAT Uscita in Messaggi vista: SA0095: Assegnazione nella condizione: '...' " }, 
{ "title" : "SA0100: Variabili maggiori di <n> byte ", 
"url" : "_san_rule_sa0100.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0100: Variabili maggiori di <n> byte ", 
"snippet" : "Trova le variabili usando più di n byte, dove n è dato dalla configurazione corrente. Predefinito: 1024 byte. Il valore può essere modificato facendo doppio clic sulla riga. Motivazione: alcune linee guida di programmazione stabiliscono una dimensione massima per una singola variabile. Questo può es...", 
"body" : "Trova le variabili usando più di n byte, dove n è dato dalla configurazione corrente. Predefinito: 1024 byte. Il valore può essere modificato facendo doppio clic sulla riga. Motivazione: alcune linee guida di programmazione stabiliscono una dimensione massima per una singola variabile. Questo può essere verificato qui. Importanza: Bassa Esempio PROGRAM PLC_PRG\nVAR\n aobyTest : ARRAY [0..1024] OF BYTE;\nEND_VAR\n aobyTest[INT#0] := aobyTest[INT#0] + BYTE#1; Uscita in Messaggi vista: SA0100: variabile \"aobyTest\" maggiore di 1024 byte " }, 
{ "title" : "SA0101: Nomi di lunghezza illegali ", 
"url" : "_san_rule_sa0101.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0101: Nomi di lunghezza illegali ", 
"snippet" : "Trova nomi con lunghezza non valida. Facendo doppio clic sulla riga di questa regola nella finestra di dialogo impostazioni del progetto si apre una finestra di dialogo in cui è possibile definire la lunghezza dei nomi e specificare le eccezioni. Motivo: alcune linee guida di programmazione specific...", 
"body" : "Trova nomi con lunghezza non valida. Facendo doppio clic sulla riga di questa regola nella finestra di dialogo impostazioni del progetto si apre una finestra di dialogo in cui è possibile definire la lunghezza dei nomi e specificare le eccezioni. Motivo: alcune linee guida di programmazione specificano una lunghezza minima per i nomi delle variabili. La conformità può essere verificata con questa analisi. Importanza: bassa Regola PLCopen: N6 Tutte le regole sono elencate nel Impostazioni Analisi statica: Regole dialogo. Lì puoi fare doppio clic sulla Regola 101 per aprire la configurazione specifica della regola. Quindi puoi definire il numero minimo e massimo di caratteri e impostare delle eccezioni nel file Lunghezza dei nomi dialogo. Esempio PROGRAM PLC1 \/\/ SA0101\nVAR\n iVar1 : INT; \/\/ SA0101\nEND_VAR\n Uscita in Messaggi visualizzazione: SA0101: Lunghezza del nome 'PLC1' non valida " }, 
{ "title" : "SA0102: Accesso alle variabili del programma\/fb dall'esterno ", 
"url" : "_san_rule_sa0102.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0102: Accesso alle variabili del programma\/fb dall'esterno ", 
"snippet" : "Determina l'accesso esterno alle variabili locali di programmi o blocchi funzione. Motivo: CODESYS consente l'accesso esterno in lettura alle variabili locali di programmi o blocchi funzione. Ciò rompe con il principio dell'incapsulamento dei dati (nascondere i dati) e non è conforme allo standard I...", 
"body" : "Determina l'accesso esterno alle variabili locali di programmi o blocchi funzione. Motivo: CODESYS consente l'accesso esterno in lettura alle variabili locali di programmi o blocchi funzione. Ciò rompe con il principio dell'incapsulamento dei dati (nascondere i dati) e non è conforme allo standard IEC 61131-3. Importanza: Media Esempio PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n afb_Instance : AFB;\n bfb_Instance : BFB;\nEND_VAR iCounter := A_PRG.iLocal; \/\/ SA0102\niCounter := bfb_Instance.iLocal; \/\/ SA0102\nA_PRG(); FUNCTION_BLOCK AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iLocal: INT;\nEND_VAR METHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; FUNCTION_BLOCK BFB EXTENDS AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\nEND_VAR\nMETHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; PROGRAM A_PRG\nVAR\n iLocal: INT;\nEND_VAR iLocal := iLocal + 1;\n Uscita in Messaggi vista: SA0102: Accesso al programma\/variabile fb 'iLocal' dall'esterno " }, 
{ "title" : "SA0103: Accesso simultaneo a dati non atomici ", 
"url" : "_san_rule_sa0103.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0103: Accesso simultaneo a dati non atomici ", 
"snippet" : "Determina se le variabili non atomiche (ad es. con tipo di dati STRING , WSTRING , ARRAY , STRUCT , istanze FB, tipi di dati a 64 bit) possono essere utilizzati in più task. Motivo: se non c'è sincronizzazione durante l'accesso, la lettura in un'attività e la scrittura in un'altra attività possono c...", 
"body" : "Determina se le variabili non atomiche (ad es. con tipo di dati STRING , WSTRING , ARRAY , STRUCT , istanze FB, tipi di dati a 64 bit) possono essere utilizzati in più task. Motivo: se non c'è sincronizzazione durante l'accesso, la lettura in un'attività e la scrittura in un'altra attività possono comportare la lettura di valori incoerenti. Importanza: Media Per alcuni tipi di dati, in particolare interi a 64 bit, il fatto che l'accesso sia atomico o meno dipende dalla piattaforma. L'analisi del codice statico segnala un problema solo se il controller non supporta l'accesso atomico ai tipi di dati interi a 64 bit. Questa regola non si applica nei seguenti casi: Se il sistema di destinazione dispone di una FPU (Floating Point Unit), l'accesso a più attività è limitato LREAL -Variabili non determinate Se il sistema di destinazione è un processore a 64 bit o è impostata l'impostazione di destinazione appropriata per il dispositivo di destinazione, la regola non si applica ai tipi di dati a 64 bit Esempio Il progetto contiene i due programmi PRG1 e PRG2 . Il programma PRG1 viene chiamato dal compito MainTask_1 . Il programma PRG2 viene chiamato dal compito MainTask_2 . VAR_GLOBAL\n lrTest : LREAL; \/\/ Since the target system has an FPU, SA0103 does apply.\n lint1 : LINT;\n sTest : STRING; \/\/ SA0103\n wsTest : WSTRING; \/\/ SA0103\nEND_VAR PROGRAM PRG1 GVL.lrTest := 5.0;\nGVL.sTest := 'welt';\nGVL.wsTest := \"welt\";\nGVL.lint1 := 99;\n PROGRAM PRG2 GVL.lrTest := 5.0;\nGVL.sTest := 'hallo';\nGVL.wsTest := \"hallo\";\nGVL.lint1 := 88; Uscita in Messaggi vista: SA0103: Accesso simultaneo su dati non atomici 'sTest' SA0103: Accesso simultaneo su dati non atomici 'wsTest' " }, 
{ "title" : "SA0105: Chiamate a più istanze ", 
"url" : "_san_rule_sa0105.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0105: Chiamate a più istanze ", 
"snippet" : "Rileva le istanze di blocchi funzione che vengono chiamati più volte. A questo scopo i blocchi funzione devono essere contrassegnati con il seguente pragma: {attribute 'analysis:report-multiple-instance-calls'} Giustificazione: Alcuni blocchi funzionali sono progettati in modo tale da poter essere r...", 
"body" : "Rileva le istanze di blocchi funzione che vengono chiamati più volte. A questo scopo i blocchi funzione devono essere contrassegnati con il seguente pragma: {attribute 'analysis:report-multiple-instance-calls'} Giustificazione: Alcuni blocchi funzionali sono progettati in modo tale da poter essere richiamati solo una volta nel ciclo. Questo test verifica se una chiamata viene effettuata o meno in più sedi. Importanza: Bassa Regola PLCopen: CP16 \/ CP20 Esempio \/\/ {attribute 'analysis:report-multiple-instance-calls'} Deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\n iA := iA + 1; {attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\n iB := iB + 1; PROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nEND_VAR fbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n Uscita in Messaggi vista: SA0105: Istanza 'fbB' richiamata più di una volta " }, 
{ "title" : "SA0106: Richiami di metodi virtuali in FB_Init ", 
"url" : "_san_rule_sa0106.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0106: Richiami di metodi virtuali in FB_Init ", 
"snippet" : "Rileva le chiamate al metodo nel metodo FB_Init di un blocco funzione di base che vengono sovrascritti da un blocco funzione derivato dall'FB di base. Motivo: in questi casi è possibile che le variabili nei metodi sovrascritti nell'FB di base non vengano inizializzate. Importanza: Alta Esempio modul...", 
"body" : "Rileva le chiamate al metodo nel metodo FB_Init di un blocco funzione di base che vengono sovrascritti da un blocco funzione derivato dall'FB di base. Motivo: in questi casi è possibile che le variabili nei metodi sovrascritti nell'FB di base non vengano inizializzate. Importanza: Alta Esempio modulo funzionale FB_A ha i metodi FB_Init e Meth_MyInit . FB_Init chiamate Meth_MyInit per l'inizializzazione. modulo funzionale FB_B è di FB_A derivato. PLC_PRG chiamate FB_B e quindi usa la sua variabile mbMyDintB prima che fosse inizializzato. FB_B.Meth_MyInit sovrascrive FB_A.Meth_MyInit . FUNCTION_BLOCK FB_A\nVAR\n mbMyDintA : DINT;\nEND_VAR FUNCTION_BLOCK FB_B EXTENDS FB_A\nVAR\n mbMyDintB : DINT;\nEND_VAR METHOD FB_Init : BOOL\nVAR_INPUT\n bInitRetains:BOOL;\n bInCopyCode:BOOL;\nEND_VAR\nVAR\n diDummy:DINT; \/\/SA0106\nEND_VAR\n mbMyDintA := 123;\ndiDummy := Meth_MyInit(); METHOD Meth_MyInit : DINT\nVAR_INPUT\nEND_VAR\n mbMyDintB := 123; \/\/access to member of FB_B PROGRAM PLC_PRG\nVAR\n g_BInst : FB_B;\n xVar : BOOL;\nEND_VAR\n\n xVar := g_BInst.fb_init(TRUE, TRUE);\n\/\/this instruction causes the following order of initializations:\n\/\/FB_A.fb_init\n\/\/FB_B.Meth_MyInit \/\/SA0106\n\/\/FB_B.fb_init\n\/\/FB_B.Meth_MyInit Uscita in Messaggi vista: SA0106: Chiamata del metodo virtuale 'Meth_MyInit' in FB_INIT " }, 
{ "title" : "SA0107: Parametri formali mancanti ", 
"url" : "_san_rule_sa0107.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0107: Parametri formali mancanti ", 
"snippet" : "Determina se mancano parametri formali. Motivazione: Il codice diventa più leggibile quando nel bando vengono specificati parametri formali. Importanza: Bassa Esempio FUNCTION FUNA : BOOL VAR_INPUT bDo : BOOL; bInit : BOOL; bManual : BOOL; END_VAR VAR iInit : INT; iLocal : INT; iManual : INT; END_VA...", 
"body" : "Determina se mancano parametri formali. Motivazione: Il codice diventa più leggibile quando nel bando vengono specificati parametri formali. Importanza: Bassa Esempio FUNCTION FUNA : BOOL\nVAR_INPUT\n bDo : BOOL;\n bInit : BOOL;\n bManual : BOOL;\nEND_VAR\nVAR\n iInit : INT;\n iLocal : INT;\n iManual : INT;\nEND_VAR\n IF bInit = TRUE THEN\n iInit := iInit + 1;\nEND_IF\nIF bDo = TRUE THEN\n iLocal := iLocal + 1;\nEND_IF\nIF bManual = TRUE THEN\n iManual := iManual + 1;\nEND_IF\nFUNA := TRUE;\n PROGRAM PLC_PRG\nVAR\nEND_VAR\n FUNA(bInit := TRUE, bDo := TRUE, bManual := FALSE); \/\/ OK\nFUNA(TRUE, TRUE, bManual:= FALSE); \/\/ SA0107 Uscita in Messaggi vista: SA0107: Parametro formale mancante per l'ingresso 'TRUE' " }, 
{ "title" : "Controllare le rigide regole IEC ", 
"url" : "_san_check_strict_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0111: Variabili del puntatore ", 
"url" : "_san_rule_sa0111.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0111: Variabili del puntatore ", 
"snippet" : "Rileva variabili di tipo POINTER TO Motivo: lo standard IEC 61131-3 non consente i puntatori. Importanza: Bassa Esempio VAR piTemp : POINTER TO INT; pbyTemp : POINTER TO BYTE; END_VAR Uscita in Messaggi vista: SA0111: Tipo di dati POINTER non consentito...", 
"body" : "Rileva variabili di tipo POINTER TO Motivo: lo standard IEC 61131-3 non consente i puntatori. Importanza: Bassa Esempio VAR\n piTemp : POINTER TO INT;\n pbyTemp : POINTER TO BYTE;\nEND_VAR\n Uscita in Messaggi vista: SA0111: Tipo di dati POINTER non consentito " }, 
{ "title" : "SA0112: variabili di riferimento ", 
"url" : "_san_rule_sa0112.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0112: variabili di riferimento ", 
"snippet" : "Rileva variabili di tipo REFERENCE TO Motivo: la norma IEC 61131-3 non consente riferimenti. Importanza: Bassa Esempio VAR ref_int : REFERENCE TO INT; ref_dw : REFERENCE TO DWORD; END_VAR Uscita in Messaggi vista: SA0112: Tipo di dati REFERENCE non consentito...", 
"body" : "Rileva variabili di tipo REFERENCE TO Motivo: la norma IEC 61131-3 non consente riferimenti. Importanza: Bassa Esempio VAR\n ref_int : REFERENCE TO INT;\n ref_dw : REFERENCE TO DWORD;\nEND_VAR\n Uscita in Messaggi vista: SA0112: Tipo di dati REFERENCE non consentito " }, 
{ "title" : "SA0113: Variabili con tipo di dati WSTRING ", 
"url" : "_san_rule_sa0113.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0113: Variabili con tipo di dati WSTRING ", 
"snippet" : "Determina le variabili di tipo WSTRING . Motivo: non tutti i sistemi lo supportano WSTRING . Il codice diventa più portabile quando si fa clic su WSTRING rinunciato. Importanza: Bassa Esempio VAR wstrTemp : WSTRING; END_VAR Uscita in Messaggi vista: SA0113: Tipo di dati WSTRING non consentito...", 
"body" : "Determina le variabili di tipo WSTRING . Motivo: non tutti i sistemi lo supportano WSTRING . Il codice diventa più portabile quando si fa clic su WSTRING rinunciato. Importanza: Bassa Esempio VAR\n wstrTemp : WSTRING;\nEND_VAR\n Uscita in Messaggi vista: SA0113: Tipo di dati WSTRING non consentito " }, 
{ "title" : "SA0114: Variabili con tipo di dati LTIME ", 
"url" : "_san_rule_sa0114.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0114: Variabili con tipo di dati LTIME ", 
"snippet" : "Rileva variabili di tipo LTIME Motivo: non tutti i sistemi lo supportano LTIME . Il codice diventa più portabile quando si fa clic su LTIME rinunciato. Importanza: Bassa Esempio VAR ltVar : LTIME; \/\/ SA0114 END_VAR Uscita in Messaggi vista: SA0114: tipo di dati LTIME non consentito Per ulteriori inf...", 
"body" : "Rileva variabili di tipo LTIME Motivo: non tutti i sistemi lo supportano LTIME . Il codice diventa più portabile quando si fa clic su LTIME rinunciato. Importanza: Bassa Esempio VAR\n ltVar : LTIME; \/\/ SA0114\nEND_VAR\n Uscita in Messaggi vista: SA0114: tipo di dati LTIME non consentito Per ulteriori informazioni, vedere: Attributo 'analysis:report-multiple-instance-calls' " }, 
{ "title" : "SA0115: Dichiarazioni con tipo di dati UNION ", 
"url" : "_san_rule_sa0115.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0115: Dichiarazioni con tipo di dati UNION ", 
"snippet" : "Recupera le dichiarazioni di a UNION -Tipo di dati e dichiarazioni di variabili di tipo a UNION . Motivazione: La norma IEC 61131-3 non prevede i sindacati. Il codice è più facilmente trasportabile senza sindacati. Importanza: Bassa Esempio TYPE A_UNION: UNION lrTemp : LREAL; liTemp : LINT; END_UNIO...", 
"body" : "Recupera le dichiarazioni di a UNION -Tipo di dati e dichiarazioni di variabili di tipo a UNION . Motivazione: La norma IEC 61131-3 non prevede i sindacati. Il codice è più facilmente trasportabile senza sindacati. Importanza: Bassa Esempio TYPE A_UNION: \nUNION\n lrTemp : LREAL;\n liTemp : LINT;\nEND_UNION\nEND_TYPE PROGRAM PLC_PRG\nVAR\n aunionVar: A_UNION;\n liVar : LINT;\nEND_VAR aunionVar.lrTemp := 0.123E-12;\nliVar := aunionVar.liTemp; Uscita in Messaggi vista: SA0115: Unioni non consentite " }, 
{ "title" : "SA0117: Variabili con tipo di dati BIT ", 
"url" : "_san_rule_sa0117.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0117: Variabili con tipo di dati BIT ", 
"snippet" : "Rileva dichiarazioni di variabili del tipo di dati BIT (possibile all'interno delle definizioni della struttura) Motivazione: La norma IEC 61131-3 non include il tipo di dati BIT . Il codice è più facilmente trasportabile senza BIT . Importanza: Bassa Esempio TYPE Struct1 : STRUCT bitVar : BIT; iVar...", 
"body" : "Rileva dichiarazioni di variabili del tipo di dati BIT (possibile all'interno delle definizioni della struttura) Motivazione: La norma IEC 61131-3 non include il tipo di dati BIT . Il codice è più facilmente trasportabile senza BIT . Importanza: Bassa Esempio TYPE Struct1 :\nSTRUCT\n bitVar : BIT;\n iVar : INT;\n bVar : BOOL;\nEND_STRUCT\nEND_TYPE\n Uscita in Messaggi vista: SA0117: Variabili con tipo dati BIT " }, 
{ "title" : "SA0119: Funzionalità orientata agli oggetti ", 
"url" : "_san_rule_sa0119.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0119: Funzionalità orientata agli oggetti ", 
"snippet" : "Determina l'uso di funzionalità orientate agli oggetti come le dichiarazioni di blocchi funzione EXTENDS e IMPLEMENTS o dichiarazioni di proprietà e interfaccia. Questa regola è utile quando si scrive codice da trasferire su altri sistemi 61131-3. Motivo: non tutti i sistemi supportano la programmaz...", 
"body" : "Determina l'uso di funzionalità orientate agli oggetti come le dichiarazioni di blocchi funzione EXTENDS e IMPLEMENTS o dichiarazioni di proprietà e interfaccia. Questa regola è utile quando si scrive codice da trasferire su altri sistemi 61131-3. Motivo: non tutti i sistemi supportano la programmazione orientata agli oggetti. Il codice diventa più portabile se non si utilizza l'orientamento agli oggetti. Importanza: Bassa Esempio \/\/Function block extended by another and implementing an interface:\nFUNCTION_BLOCK POU EXTENDS CTD IMPLEMENTS ITF \/\/SA0119\n;\n \/\/ Declaration parts of property methods assigned to a function block:\nPOU.Prop.Get \/\/SA0119 POU.Prop.Set \/\/SA0119 Uscita in Messaggi vista: SA0119: Funzionalità orientate agli oggetti non consentite " }, 
{ "title" : "SA0120: Chiamate di programma ", 
"url" : "_san_rule_sa0120.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0120: Chiamate di programma ", 
"snippet" : "Determina le chiamate del programma. Motivo: secondo la norma IEC 61131-3, i programmi possono essere richiamati solo nella configurazione dell'attività. Il codice diventa più portabile se non chiami il programma altrove. Importanza: Bassa Esempio PROGRAM prog_control VAR END_VAR ; PROGRAM PLC_PRG V...", 
"body" : "Determina le chiamate del programma. Motivo: secondo la norma IEC 61131-3, i programmi possono essere richiamati solo nella configurazione dell'attività. Il codice diventa più portabile se non chiami il programma altrove. Importanza: Bassa Esempio PROGRAM prog_control\nVAR\nEND_VAR\n; PROGRAM PLC_PRG\nVAR\nEND_VAR\n prog_control(); Uscita in Messaggi vista: SA0120: Chiamata del programma a 'prg_control' non consentita " }, 
{ "title" : "SA0121: Dichiarazioni VAR_EXTERNAL mancanti ", 
"url" : "_san_rule_sa0121.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0121: Dichiarazioni VAR_EXTERNAL mancanti ", 
"snippet" : "Rileva l'uso di una variabile globale nei blocchi funzione senza che vengano dichiarati lì come VAR_EXTERNAL Motivo: secondo la norma IEC 61131-3, l'accesso alle variabili globali è possibile solo tramite un'importazione esplicita utilizzando un VAR_EXTERNAL -Dichiarazione consentita. Importanza: Ba...", 
"body" : "Rileva l'uso di una variabile globale nei blocchi funzione senza che vengano dichiarati lì come VAR_EXTERNAL Motivo: secondo la norma IEC 61131-3, l'accesso alle variabili globali è possibile solo tramite un'importazione esplicita utilizzando un VAR_EXTERNAL -Dichiarazione consentita. Importanza: Bassa Regola PLCopen: CP18 Esempio VAR_GLOBAL\n iGlob1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar : INT;\nEND_VAR\n ivar := iGlob1; \/\/ SA0121 Uscita in Messaggi vista: SA0121: Dichiarazione VAR_EXTERNAL richiesta per la variabile 'iGlob1' Esempio per evitare errori VAR_GLOBAL\n iGlob1:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar:INT;\nEND_VAR\nVAR_EXTERNAL\n iGlob1:INT;\nEND_VAR\n ivar:=iGlob1; \/\/ OK " }, 
{ "title" : "SA0122: Indice array definito come espressione ", 
"url" : "_san_rule_sa0122.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0122: Indice array definito come espressione ", 
"snippet" : "Rileva l'uso di espressioni durante la dichiarazione di indici di matrice. Motivo: non tutti i sistemi consentono espressioni come limiti di array. Importanza: Bassa Esempio PROGRAM PLC_PRG VAR CONSTANT c_iValue : INT := INT#15; END_VAR VAR arr : ARRAY [0..c_iValue + 1] OF INT; END_VAR Uscita in Mes...", 
"body" : "Rileva l'uso di espressioni durante la dichiarazione di indici di matrice. Motivo: non tutti i sistemi consentono espressioni come limiti di array. Importanza: Bassa Esempio PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n arr : ARRAY [0..c_iValue + 1] OF INT;\nEND_VAR\n Uscita in Messaggi vista: SA0122: Sono consentite solo costanti per la definizione di array 'arr' " }, 
{ "title" : "SA0123: Utilizzo di INI, ADR o BITDR ", 
"url" : "_san_rule_sa0123.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0123: Utilizzo di INI, ADR o BITDR ", 
"snippet" : "Determina l'uso di CODESYS Static Analysis - operatori specifici INI , ADR e BITADR . Motivo: CODESYS - operatori specifici impediscono la portabilità del codice. Importanza: Bassa Esempio PROGRAM PLC_PRG VAR uiTemp : UINT; TempVarInFUNC : DWORD; END_VAR TempVarInFUNC := ADR(uiTemp); \/\/SA0123 Uscita...", 
"body" : "Determina l'uso di CODESYS Static Analysis - operatori specifici INI , ADR e BITADR . Motivo: CODESYS - operatori specifici impediscono la portabilità del codice. Importanza: Bassa Esempio PROGRAM PLC_PRG\nVAR\n uiTemp : UINT;\n TempVarInFUNC : DWORD;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0123 Uscita in Messaggi vista: SA0123: Operatore 'ADR' non consentito " }, 
{ "title" : "SA0147: Operazione di spostamento insolita -strict ", 
"url" : "_san_rule_sa0147.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0147: Operazione di spostamento insolita -strict ", 
"snippet" : "Determina le operazioni di spostamento dei bit che non si applicano ai tipi di dati bitfield ( BYTE , WORD , DWORD , LWORD ) rispettivamente. Motivo: lo standard IEC 61131-3 consente l'accesso bit solo ai tipi di dati bit field. il CODESYS Tuttavia, il compilatore consente anche operazioni di sposta...", 
"body" : "Determina le operazioni di spostamento dei bit che non si applicano ai tipi di dati bitfield ( BYTE , WORD , DWORD , LWORD ) rispettivamente. Motivo: lo standard IEC 61131-3 consente l'accesso bit solo ai tipi di dati bit field. il CODESYS Tuttavia, il compilatore consente anche operazioni di spostamento di bit con tipi di dati senza segno. Importanza: Bassa Vedi anche la regola non rigorosa SA0018 . Esempio PROGRAM PLC_PRG\nVAR\n in_byte : BYTE := 16#45; \/\/ 2#01000101\n in_word : WORD := 16#0045; \/\/ 2#0000000001000101\n in_uint : UINT;\n in_dint : DINT;\n erg_byte : BYTE;\n erg_word : WORD;\n erg_uint : UINT;\n erg_dint : DINT;\n n: BYTE := 2;\nEND_VAR\n erg_byte := SHL(in_byte,n); \/\/ no error because BYTE is a bit field\nerg_word := SHL(in_word,n); \/\/ no error because WORD is a bit field\nerg_uint := SHL(in_uint,n); \/\/ SA0147\nerg_dint := SHL(in_dint,n); \/\/ SA0147 Uscita in Messaggi vista: SA0147: Funzionamento del turno insolito – rigoroso " }, 
{ "title" : "SA0148: Accesso bit insolito - strict ", 
"url" : "_san_rule_sa0148.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0148: Accesso bit insolito - strict ", 
"snippet" : "Determina gli accessi ai bit che non sono basati sui tipi di dati del campo di bit ( BYTE , WORD , DWORD , LWORD ) rispettivamente. Lo standard IEC 61131-3 consente solo l'accesso bit ai tipi di dati bit field. il CODESYS Tuttavia, il compilatore consente anche l'accesso ai bit ai tipi di dati senza...", 
"body" : "Determina gli accessi ai bit che non sono basati sui tipi di dati del campo di bit ( BYTE , WORD , DWORD , LWORD ) rispettivamente. Lo standard IEC 61131-3 consente solo l'accesso bit ai tipi di dati bit field. il CODESYS Tuttavia, il compilatore consente anche l'accesso ai bit ai tipi di dati senza segno. Importanza: Bassa Esempio PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/ SA0148\ndiTemp3.4 := TRUE; \/\/ SA0148\nuliTemp4.18 := FALSE; \/\/ SA0148\nsiTemp5.2 := FALSE; \/\/ SA0148\nusiTemp6.3 := TRUE; \/\/ SA0148\nbyTemp2.5 := FALSE; \/\/ no error because BYTE is a bitfield Uscita in Messaggi vista: SA0148: Accesso bit insolito – strict " }, 
{ "title" : "SA0118: Inizializzazione non con costanti ", 
"url" : "_san_rule_sa0118.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0118: Inizializzazione non con costanti ", 
"snippet" : "Trova gli inizializzatori che non assegnano costanti. Motivo: le inizializzazioni dovrebbero essere il più costanti possibile e non fare riferimento ad altre variabili. In particolare, dovresti evitare le chiamate di funzione nell'inizializzazione, perché ciò può portare all'accesso a dati non inizi...", 
"body" : "Trova gli inizializzatori che non assegnano costanti. Motivo: le inizializzazioni dovrebbero essere il più costanti possibile e non fare riferimento ad altre variabili. In particolare, dovresti evitare le chiamate di funzione nell'inizializzazione, perché ciò può portare all'accesso a dati non inizializzati. Importanza: Media Esempio PROGRAM PLC_PRG\nVAR\n dwTemp : DWORD := 22;\n dwTest : DWORD := dwTemp; \/\/ SA0118\n dwVar : DWORD := TempVarInFUNC(); \/\/ SA0118\nEND_VAR\n Uscita in Messaggi vista: SA0118: Inizializzazioni senza utilizzo di costanti " }, 
{ "title" : "SA0124: Dereferenziazione puntatore nella parte di dichiarazione ", 
"url" : "_san_rule_sa0124.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0124: Dereferenziazione puntatore nella parte di dichiarazione ", 
"snippet" : "Determina i dereferences del puntatore utilizzati per l'inizializzazione nella parte di dichiarazione. Motivazione: Puntatori e riferimenti non dovrebbero essere utilizzati per le inizializzazioni perché ciò può portare a violazioni di accesso se il puntatore non è stato inizializzato. Importanza: M...", 
"body" : "Determina i dereferences del puntatore utilizzati per l'inizializzazione nella parte di dichiarazione. Motivazione: Puntatori e riferimenti non dovrebbero essere utilizzati per le inizializzazioni perché ciò può portare a violazioni di accesso se il puntatore non è stato inizializzato. Importanza: Media Esempio TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n pTeststruct : POINTER TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := pTeststruct^.xA; \/\/SA0124 \nEND_VAR\n\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); Uscita in Messaggi vista: SA0124: Dereferenziamenti dei puntatori nelle dichiarazioni " }, 
{ "title" : "SA0125: Riferimenti nelle inizializzazioni ", 
"url" : "_san_rule_sa0125.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Controllare le rigide regole IEC \/ SA0125: Riferimenti nelle inizializzazioni ", 
"snippet" : "Rileva le variabili di riferimento utilizzate per l'inizializzazione nella parte di dichiarazione Motivazione: Puntatori e riferimenti non dovrebbero essere utilizzati per le inizializzazioni perché ciò può portare a violazioni di accesso se il puntatore non è stato inizializzato. Importanza: Media ...", 
"body" : "Rileva le variabili di riferimento utilizzate per l'inizializzazione nella parte di dichiarazione Motivazione: Puntatori e riferimenti non dovrebbero essere utilizzati per le inizializzazioni perché ciò può portare a violazioni di accesso se il puntatore non è stato inizializzato. Importanza: Media Esempio TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n refTeststruct: REFERENCE TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := refTeststruct.xA; \/\/SA0125\nEND_VAR\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); Uscita in Messaggi vista: SA0125: Riferimento utilizzato nell'inizializzazione " }, 
{ "title" : "SA0140: Dichiarazioni commentate ", 
"url" : "_san_rule_sa0140.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0140: Dichiarazioni commentate ", 
"snippet" : "Rileva le dichiarazioni commentate Motivazione: Il codice è spesso commentato a scopo di debug. Quando viene rilasciato questo tipo di commento, non è sempre chiaro in un secondo momento se il codice debba essere eliminato o se sia stato commentato per scopi di debug e involontariamente non decommen...", 
"body" : "Rileva le dichiarazioni commentate Motivazione: Il codice è spesso commentato a scopo di debug. Quando viene rilasciato questo tipo di commento, non è sempre chiaro in un secondo momento se il codice debba essere eliminato o se sia stato commentato per scopi di debug e involontariamente non decommentato. Importanza: Alta Regola PLCopen: C4 Esempio PROGRAM PLC_PRG\nVAR\n iValue1: INT;\n iValue2: INT;\nEND_VAR\n iValue1 := 100;\niValue2 := 200;\n\/\/ iValue2 := 300; Uscita in Messaggi vista: SA0140: Istruzioni commentate: iValue2 := 300 " }, 
{ "title" : "Possibile utilizzo di variabili non inizializzate ", 
"url" : "_san_non_initialized_variables.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Possibile utilizzo di variabili non inizializzate ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0039: Possibili deferenze del puntatore nullo ", 
"url" : "_san_rule_sa0039.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Possibile utilizzo di variabili non inizializzate \/ SA0039: Possibili deferenze del puntatore nullo ", 
"snippet" : "Rileva le posizioni del codice in cui è possibile che un puntatore null sia dereferenziato Motivazione: Un puntatore dovrebbe essere controllato prima di ogni dereferenziazione per assicurarsi che non sia uguale a zero. In caso contrario potrebbe verificarsi una violazione di accesso in fase di esec...", 
"body" : "Rileva le posizioni del codice in cui è possibile che un puntatore null sia dereferenziato Motivazione: Un puntatore dovrebbe essere controllato prima di ogni dereferenziazione per assicurarsi che non sia uguale a zero. In caso contrario potrebbe verificarsi una violazione di accesso in fase di esecuzione. Importanza: Alta Esempio PROGRAM PLC_PRG\nVAR\n ptiVar1:POINTER TO INT;\n ptiVar2:POINTER TO INT;\n ptiVar3:POINTER TO INT;\n iVar:INT;\n iCount :INT;\n iCondition: INT;\nEND_VAR\n iCount := iCount + INT#1;\nptiVar1 := ADR(iVar);\nptiVar1^ := iCondition; \/\/ OK - valid reference\nptiVar2^ := iCondition; \/\/ SA0039 - null pointer dereferenciation\niVar := ptiVar3^; \/\/ SA0039 - null pointer dereferenciation Uscita in Messaggi vista: SA0039: Possibile deferenza del puntatore nullo 'ptiVar2^' SA0039: Possibile deferenza del puntatore nullo 'ptiVar3^' " }, 
{ "title" : "SA0046: Possibile utilizzo interfaccia non inizializzata ", 
"url" : "_san_rule_sa0046.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Possibile utilizzo di variabili non inizializzate \/ SA0046: Possibile utilizzo interfaccia non inizializzata ", 
"snippet" : "Rileva l'uso di interfacce che non sono state inizializzate prima di essere utilizzate Giustificazione: Un riferimento all'interfaccia dovrebbe essere controllato per <> 0 prima di essere utilizzato. Altrimenti durante l'accesso potrebbe verificarsi una violazione dell'accesso. Importanza: Alta Esem...", 
"body" : "Rileva l'uso di interfacce che non sono state inizializzate prima di essere utilizzate Giustificazione: Un riferimento all'interfaccia dovrebbe essere controllato per <> 0 prima di essere utilizzato. Altrimenti durante l'accesso potrebbe verificarsi una violazione dell'accesso. Importanza: Alta Esempio \/\/Declaration of INTERFACE ITF and assigned METH2:\nMETHOD METH2 : BOOL\nVAR_INPUT\n iInput2:INT;\nEND_VAR \/\/Declaration of INTERFACE Master_ITF1 and assigned METH:\nMETHOD METH : BOOL\nVAR_INPUT\n iInput:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n instPOU : POU;\n instITF : ITF;\n instMasterITF1 : Master_ITF1;\n instMasterITF2 : Master_ITF2;\n iDummy : INT;\n xDummy : BOOL;\n instNoInitITF : ITF;\n instNoInitITF2 : ITF;\n instNoInitMasterITF1 : Master_ITF1;\n instNoInitMasterITF2 : Master_ITF2;\nEND_VAR instITF := instPOU;\nxDummy := instITF.METH(iInput := iDummy); \/\/ OK\ninstMasterITF1 := instPOU;\nxDummy := instMasterITF1.METH(iInput := iDummy); \/\/ OK\n\nxDummy := instNoInitITF.METH(iInput := INT#1); \/\/ SA0046\nxDummy := instNoInitITF.METH2(iInput2 := INT#2); \/\/ SA0046\nxDummy := instNoInitMasterITF1.METH(iInput := INT#3); \/\/ SA0046\niDummy := instNoInitMasterITF2.Prop; \/\/ SA0046\n\nIF instNoInitITF <> 0 THEN\n instNoInitITF.Prop; \/\/ OK, because the interface can't be 0\nEND_IF Uscita in Messaggi vista: SA0046: Possibile utilizzo dell'interfaccia non inizializzata 'instNoInitITF' SA0046: Possibile utilizzo dell'interfaccia non inizializzata 'instNoInitITF' SA0046: Possibile utilizzo dell'interfaccia non inizializzata 'instNoInitMasterITF1' SA0046: Possibile utilizzo dell'interfaccia non inizializzata 'instNoInitMasterITF2' " }, 
{ "title" : "SA0145: Possibile utilizzo di riferimento non inizializzato ", 
"url" : "_san_rule_sa0145.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ Possibile utilizzo di variabili non inizializzate \/ SA0145: Possibile utilizzo di riferimento non inizializzato ", 
"snippet" : "Rileva eventuali variabili di riferimento che potrebbero non essere inizializzate prima dell'uso e non sono verificate dall'operatore __ISVALIDREF . Questa regola viene applicata nella parte di implementazione delle POU. Per la dichiarazione c'è la regola SA0124 . Motivazione: Prima dell'accesso è n...", 
"body" : "Rileva eventuali variabili di riferimento che potrebbero non essere inizializzate prima dell'uso e non sono verificate dall'operatore __ISVALIDREF . Questa regola viene applicata nella parte di implementazione delle POU. Per la dichiarazione c'è la regola SA0124 . Motivazione: Prima dell'accesso è necessario verificare la validità di un riferimento poiché durante l'accesso potrebbe verificarsi una violazione dell'accesso. Importanza: Alta Esempio PROGRAM PLC_PRG\nVAR_INPUT\n ref_iTest : REFERENCE TO INT;\nEND_VAR\n ref_iTest := 99; \/\/ SA0145\nIF __ISVALIDREF(ref_iTest) THEN\n ref_iTest := 88;\nEND_IF Uscita in Messaggi vista: SA0145: Possibile utilizzo del riferimento non inizializzato 'ref_iTest' " }, 
{ "title" : "SA0150: Violazioni dei limiti inferiori o superiori o delle metriche ", 
"url" : "_san_rule_sa0150.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0150: Violazioni dei limiti inferiori o superiori o delle metriche ", 
"snippet" : "Rileva le POU che violano le metriche attivate ai limiti inferiore o superiore Motivazione: Il codice conforme a determinate metriche è più facile da leggere, più facile da mantenere e più facile da testare. Importanza: alta Regola PLCopen: CP9 Esempio Situazione iniziale: il Numero di chiamate la m...", 
"body" : "Rileva le POU che violano le metriche attivate ai limiti inferiore o superiore Motivazione: Il codice conforme a determinate metriche è più facile da leggere, più facile da mantenere e più facile da testare. Importanza: alta Regola PLCopen: CP9 Esempio Situazione iniziale: il Numero di chiamate la metrica è selezionata in Impostazioni progetto → Analisi statica → Metriche . Limite inferiore: 0 ; limite superiore: 3 . Prog_1 viene chiamato cinque volte. Quando si esegue l'analisi statica, il SA0150: Violazione metrica per Prog_1. Report per chiamate metriche (5) > 2 viene emesso un errore nella visualizzazione dei messaggi, nel file Costruire categoria. " }, 
{ "title" : "SA0160: Chiamate ricorsive ", 
"url" : "_san_rule_sa0160.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0160: Chiamate ricorsive ", 
"snippet" : "Rileva le chiamate ricorsive nelle azioni, nei metodi e nelle proprietà dei blocchi funzione. Rileva anche possibili ricorsioni da chiamate di funzioni virtuali e chiamate di interfaccia. Motivazione: Le ricorsioni portano a comportamenti non deterministici e sono quindi fonte di errori. Importanza:...", 
"body" : "Rileva le chiamate ricorsive nelle azioni, nei metodi e nelle proprietà dei blocchi funzione. Rileva anche possibili ricorsioni da chiamate di funzioni virtuali e chiamate di interfaccia. Motivazione: Le ricorsioni portano a comportamenti non deterministici e sono quindi fonte di errori. Importanza: Media Regola PLCopen: CP13 Esempio Il seguente metodo Call è assegnato al blocco funzione FB_Test : FUNCTION_BLOCK FB_Test\nVAR\n bParameter: BOOL;\nEND_VAR\n METHOD Call : BOOL\nVAR_INPUT\nEND_VAR\n Call := THIS^.Call(); \/\/SA0160 Il programma PLC_PRG chiamate FB_Test : PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\n bValue : BOOL;\nEND_VAR\n bValue := fbTest.bParameter;\nfbTest.Call(); Uscita in Messaggi vista: SA0160: Chiamata ricorsiva rilevata: 'PLC_PRG' -> 'FB_Test.Call' -> 'FB_Test.Call' " }, 
{ "title" : "SA0161: Struttura disimballata in struttura imballata ", 
"url" : "_san_rule_sa0161.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0161: Struttura disimballata in struttura imballata ", 
"snippet" : "Rileva le strutture non imballate che vengono utilizzate nelle strutture imballate Giustificazione: Il compilatore tipicamente imposta una struttura decompressa su un indirizzo che consente un accesso allineato a tutti gli elementi all'interno della struttura. Se create questa struttura in una strut...", 
"body" : "Rileva le strutture non imballate che vengono utilizzate nelle strutture imballate Giustificazione: Il compilatore tipicamente imposta una struttura decompressa su un indirizzo che consente un accesso allineato a tutti gli elementi all'interno della struttura. Se create questa struttura in una struttura compressa, l'accesso allineato non sarà più possibile. Inoltre, l'accesso ad un elemento della struttura non imballata può portare ad una \"eccezione di disallineamento\". Importanza: Alta Esempio La struttura structSingleDataRecord è imballato, ma contiene le strutture non imballate struct4Byte e struct9Byte . {attribute 'pack_mode' := '1'}\nTYPE structSingleDataRecord :\nSTRUCT\n str9ByteData: struct9Byte; (* 9 BYTE *)\n str4ByteData: struct4Byte; (* 4 BYTE *)\n udi1: UDINT;\n udi2: UDINT;\n udi3: UDINT;\n usi4: USINT;\nEND_STRUCT\nEND_TYPE (* 9 BYTE *)\nTYPE struct9Byte :\nSTRUCT\n usiRotorSlots: USINT; (* 1 BYTE *)\n uiMaxCurrent: UINT; (* 2 BYTE *)\n usiVelocity: USINT; (* 1 BYTE *)\n uiAcceleration: UINT; (* 2 BYTE *)\n uiDeceleration: UINT; (* 2 BYTE *)\n usiDirectionChange: USINT; (* 1 BYTE *)\nEND_STRUCT\nEND_TYPE TYPE struct4Byte :\nSTRUCT\n \/\/udiDummy : UDINT;\n rRealDummy : REAL;\nEND_STRUCT\nEND_TYPE Uscita in Messaggi vista: SA0161: Dichiarazione di una struttura decompressa 'struct9ByteData' all'interno di una struttura compressa 'structSingleDataRecord' SA0161: Dichiarazione di una struttura decompressa 'struct4ByteData' all'interno di una struttura compressa 'structSingleDataRecord' " }, 
{ "title" : "SA0162: Commenti mancanti ", 
"url" : "_san_rule_sa0162.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0162: Commenti mancanti ", 
"snippet" : "Rileva le posizioni non commentate nel programma Motivazione: Il commento completo è richiesto da molte linee guida di programmazione e aumenta la leggibilità e la manutenibilità del codice. Importanza: bassa Regola PLCopen: C2 I commenti sono obbligatori nei seguenti casi: Per la dichiarazione di v...", 
"body" : "Rileva le posizioni non commentate nel programma Motivazione: Il commento completo è richiesto da molte linee guida di programmazione e aumenta la leggibilità e la manutenibilità del codice. Importanza: bassa Regola PLCopen: C2 I commenti sono obbligatori nei seguenti casi: Per la dichiarazione di variabili. I commenti si trovano sopra o a destra. Per la dichiarazione di programmi, blocchi funzione o metodi. I commenti si trovano sopra la dichiarazione (nella prima riga). Esempio PROGRAM PLC_PRG\nVAR\n iMaxValue: INT;\nEND_VAR\n Uscita in Messaggi vista: SA0162: Commento mancante per 'PLC_PRG' SA0162: commento mancante per 'iMaxValue' " }, 
{ "title" : "SA0163: commenti nidificati ", 
"url" : "_san_rule_sa0163.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0163: commenti nidificati ", 
"snippet" : "Rileva i commenti nidificati Motivazione: I commenti annidati dovrebbero essere evitati perché di difficile lettura. Importanza: Bassa Regola PLCopen: C3 Esempio {attribute 'do-analysis'} (* That is (* nested comment 1 *) *) PROGRAM PLC_PRG VAR (* That is \/\/ nested comment 2 comment *) iVal1: INT; i...", 
"body" : "Rileva i commenti nidificati Motivazione: I commenti annidati dovrebbero essere evitati perché di difficile lettura. Importanza: Bassa Regola PLCopen: C3 Esempio {attribute 'do-analysis'}\n(* That is\n(* nested comment 1 *)\n*)\nPROGRAM PLC_PRG\nVAR\n(* That is\n\/\/ nested comment 2\ncomment *)\n iVal1: INT;\n iVal2: INT;\n\n(* That is\n(* nested comment 3 *) *)\n pVal3: POINTER TO DWORD;\n hugo: INT;\nEND_VAR\n (* That is\n\/\/ nested comment 4\ncomment *)\niVal1 := iVal1 + 1;\n(* That is\n(* nested comment 5 *)\n*)\n\n(* Not that one *) Uscita in Messaggi vista: SA0163: Commento nidificato 'nested comment 1' SA0163: Commento nidificato 'nested comment 2' SA0163: Commento nidificato 'nested comment 3' SA0163: Commento nidificato 'nested comment 4' SA0163: Commento nidificato 'nested comment 5' " }, 
{ "title" : "SA0164: Commenti su più righe ", 
"url" : "_san_rule_sa0164.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0164: Commenti su più righe ", 
"snippet" : "Rileva i commenti su più righe codificati come (* comment *) . Solo commenti a riga singola codificati come \/\/ comment sono ammessi. Motivazione: alcune linee guida di programmazione vietano i commenti su più righe nel codice perché l'inizio e la fine di un commento potrebbero andare persi e la pare...", 
"body" : "Rileva i commenti su più righe codificati come (* comment *) . Solo commenti a riga singola codificati come \/\/ comment sono ammessi. Motivazione: alcune linee guida di programmazione vietano i commenti su più righe nel codice perché l'inizio e la fine di un commento potrebbero andare persi e la parentesi di commento di chiusura potrebbe essere cancellata per errore. È possibile disattivare questo controllo tramite il pragma analysis , anche per i commenti nella parte dichiarativa. Importanza: Bassa Regola PLCopen: C5 Esempio {attribute 'do-analysis'}\n(*\n This is a multi-line comment \/\/ SA0164\n*)\nPROGRAM PLC_PRG\nVAR\n\/\/ This is a single line comment\n a: DINT;\nEND_VAR\n (* This is not a single line comment *) \/\/ SA0164\na := a + 1; Uscita in Messaggi vista: SA0164: utilizzare solo commenti a riga singola " }, 
{ "title" : "SA0165: Attività che richiamano POU diversi dai programmi ", 
"url" : "_san_rule_sa0165.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0165: Attività che richiamano POU diversi dai programmi ", 
"snippet" : "Rileva attività che richiamano blocchi funzione o funzioni anziché un programma Motivazione: Questa regola fa parte delle linee guida di codifica PLCopen. Pertanto, viene verificata anche la conformità CODESYS . Non vediamo alcun problema con la coerenza dei dati in CODESYS se le attività chiamasser...", 
"body" : "Rileva attività che richiamano blocchi funzione o funzioni anziché un programma Motivazione: Questa regola fa parte delle linee guida di codifica PLCopen. Pertanto, viene verificata anche la conformità CODESYS . Non vediamo alcun problema con la coerenza dei dati in CODESYS se le attività chiamassero POU diverse dai programmi. Tuttavia, possono verificarsi problemi se il codice deve essere trasferito su altre piattaforme. Importanza: bassa Regola PLCopen: CP16 Le attività vengono inserite sotto la configurazione delle attività. Le POU da chiamare vengono configurate nei task. Le POU devono essere le Programma genere. Il Blocco funzione e Funzione i tipi non sono ammessi. Esempio " }, 
{ "title" : "SA0166: max. numero di variabili input\/output\/in-out... ", 
"url" : "_san_rule_sa0166.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0166: max. numero di variabili input\/output\/in-out... ", 
"snippet" : "Rileva se un numero definito di variabili di input ( VAR_INPUT ), variabili di uscita ( VAR_OUTPUT ) o VAR_IN_OUT viene superata in una POU. Nel Impostazioni del progetto , fare doppio clic sulla voce della regola per aprire una finestra di dialogo in cui si definisce il numero massimo. Motivazione:...", 
"body" : "Rileva se un numero definito di variabili di input ( VAR_INPUT ), variabili di uscita ( VAR_OUTPUT ) o VAR_IN_OUT viene superata in una POU. Nel Impostazioni del progetto , fare doppio clic sulla voce della regola per aprire una finestra di dialogo in cui si definisce il numero massimo. Motivazione: Si tratta di verificare le singole linee guida di programmazione. Molte linee guida di programmazione prevedono un numero massimo di parametri POU. Troppi parametri rendono il codice illeggibile e le POU difficili da testare. Importanza: Media Regola PLCopen: CP23 Esempio Nelle impostazioni del progetto, per la Regola 166, hai definito un numero massimo di 1 per VAR_IN_OUT variabili. FUNCTION_BLOCK FB1\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nVAR_IN_OUT\n xInOut1 : BOOL;\n xInOut2 : BOOL;\nEND_VAR\n Uscita in Messaggi vista: SA0166: Troppe variabili VAR_IN_OUT nel POU 'FB1' " }, 
{ "title" : "SA0167: Istanze di blocchi funzione temporanei ", 
"url" : "_san_rule_sa0167.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0167: Istanze di blocchi funzione temporanei ", 
"snippet" : "Il controllo rileva le istanze del blocco funzione dichiarate come variabili temporanee. Ciò influisce sulle istanze dichiarate in un metodo o in una funzione o come VAR_TEMP , e quindi vengono reinizializzati in ogni ciclo di elaborazione o per ogni chiamata POU. Giustificazione: I blocchi funzione...", 
"body" : "Il controllo rileva le istanze del blocco funzione dichiarate come variabili temporanee. Ciò influisce sulle istanze dichiarate in un metodo o in una funzione o come VAR_TEMP , e quindi vengono reinizializzati in ogni ciclo di elaborazione o per ogni chiamata POU. Giustificazione: I blocchi funzione hanno uno stato che viene solitamente mantenuto su più cicli del PLC. Un'istanza nello stack esiste solo per la durata della chiamata alla funzione. Pertanto, raramente ha senso creare un'istanza come variabile temporanea. In secondo luogo, le istanze dei blocchi funzione sono spesso grandi e richiedono molto spazio nello stack (che di solito è limitato ai controller). In terzo luogo, l'inizializzazione e spesso anche la programmazione di un blocco funzione possono richiedere molto tempo. Importanza: Media Esempio PROGRAM PLC_PRG\nVAR\nEND_VAR\nVAR_TEMP\n yafb: AFB;\nEND_VAR FUNCTION Fun : INT\nVAR_INPUT\nEND_VAR\nVAR\n funafb: AFB;\nEND_VAR\n METHOD METH : INT\nVAR_INPUT\nEND_VAR\nVAR\n methafb: AFB; \/\/ SA0167\nEND_VAR Uscita in Messaggi vista: SA0167: Istanza del blocco funzione temporaneo: 'methafb' " }, 
{ "title" : "SA0168: Incarichi non necessari ", 
"url" : "_san_rule_sa0168.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0168: Incarichi non necessari ", 
"snippet" : "Rileva le assegnazioni alle variabili che non hanno alcun effetto nel codice. Motivazione: Quando i valori vengono assegnati più volte a una variabile senza che la variabile venga valutata tra le assegnazioni, le prime assegnazioni non hanno alcun effetto sul programma. Importanza: Bassa Esempio PRO...", 
"body" : "Rileva le assegnazioni alle variabili che non hanno alcun effetto nel codice. Motivazione: Quando i valori vengono assegnati più volte a una variabile senza che la variabile venga valutata tra le assegnazioni, le prime assegnazioni non hanno alcun effetto sul programma. Importanza: Bassa Esempio PROGRAM PLC_PRG\nVAR\n dwVal1 : DWORD;\n dwVal2 : DWORD;\nEND_VAR\n \/\/ unnecessary assignment\ndwVal1 := 1; \nIF dwVal2 > 100 THEN\n dwVal2 := 0;\n dwVal2 := dwVal2 + 1;\nEND_IF\ndwVal1 := 2; Uscita in Messaggi vista: SA0168: La variabile 'dwVal1' viene assegnata, ma il suo valore non viene mai utilizzato. " }, 
{ "title" : "SA0169: Uscite ignorate ", 
"url" : "_san_rule_sa0169.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0169: Uscite ignorate ", 
"snippet" : "Rileva gli output di metodi e funzioni che non sono specificati quando si chiama il metodo o la funzione. Giustificazione: gli output ignorati possono essere un avviso su un errore non gestito o chiamate a funzioni prive di significato perché i risultati non vengono utilizzati. Importanza: Media Ese...", 
"body" : "Rileva gli output di metodi e funzioni che non sono specificati quando si chiama il metodo o la funzione. Giustificazione: gli output ignorati possono essere un avviso su un errore non gestito o chiamate a funzioni prive di significato perché i risultati non vengono utilizzati. Importanza: Media Esempio FUNCTION Fun1\nVAR_INPUT\n bIn : BOOL;\nVAR_END\nVAR_OUTPUT\n bOut : BOOL;\nEND_VA\n ; PROGRAM PLC_PRG\nVAR\n bValue :BOOl;\nEND_VAR\n Fun1(bIn : TRUE);\n Uscita in Messaggi vista: SA0169: L'uscita 'bOut' viene ignorata quando richiamata " }, 
{ "title" : "SA0170: L'indirizzo di una variabile di uscita non deve essere utilizzato ", 
"url" : "_san_rule_sa0170.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0170: L'indirizzo di una variabile di uscita non deve essere utilizzato ", 
"snippet" : "Rileva le posizioni del codice in cui l'indirizzo di una variabile di uscita ( VAR_OUTPUT , VAR_IN_OUT ) di un blocco funzione. Giustificazione: Non è consentito utilizzare l'indirizzo di un'uscita di un blocco funzione nel modo seguente: Per mezzo del ADR operatore Per mezzo di REF= Eccezione: non ...", 
"body" : "Rileva le posizioni del codice in cui l'indirizzo di una variabile di uscita ( VAR_OUTPUT , VAR_IN_OUT ) di un blocco funzione. Giustificazione: Non è consentito utilizzare l'indirizzo di un'uscita di un blocco funzione nel modo seguente: Per mezzo del ADR operatore Per mezzo di REF= Eccezione: non viene segnalato alcun errore se la variabile di uscita viene utilizzata all'interno dello stesso blocco funzione. Importanza: Media Esempio Blocco funzione FB1 ha il VAR_OUTPUT variabile iOutVal : INT; Il seguente accesso in un'altra POU genera l'errore SA0170: \/\/FB1_inst is of type FB1\naddr1 := ADR(FB1_inst.iOutVal); \/\/SA0170\nrefINT REF= FB1_inst.iOutVal; \/\/SA0179\n Il seguente accesso direttamente all'interno del FB1 il blocco funzione genera anche l'errore: \/\/other is a POINTER TO FB1\nptr := ADR(other^.iOutVal); \/\/SA0170 Il seguente accesso direttamente all'interno del FB1 il blocco funzione non genera errori: \/\/iInputVal is a VAR_INPUT of FB1\niOutVal := iInputVal; \n\/\/ptr is a POINTER TO INT\nptr := ADR(THIS^.iOutVal); \nptr := ADR(iOutVal); Uscita in Messaggi vista: SA0170: Non deve assumere l'indirizzo di una variabile di uscita " }, 
{ "title" : "SA0171: Le enumerazioni devono avere l'attributo 'strict' ", 
"url" : "_san_rule_sa0171.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0171: Le enumerazioni devono avere l'attributo 'strict' ", 
"snippet" : "Rileva dichiarazioni di enumerazioni che non sono fornite con il {attribute 'strict'} attributo. Giustificazione: Il {attribute 'strict'} attributo provoca l'emissione di errori del compilatore se il codice viola le regole di programmazione rigorose per le enumerazioni. Per impostazione predefinita,...", 
"body" : "Rileva dichiarazioni di enumerazioni che non sono fornite con il {attribute 'strict'} attributo. Giustificazione: Il {attribute 'strict'} attributo provoca l'emissione di errori del compilatore se il codice viola le regole di programmazione rigorose per le enumerazioni. Per impostazione predefinita, quando viene creata una nuova enumerazione, alla dichiarazione viene automaticamente assegnato il 'strict' attributo. Per ulteriori informazioni, vedere: Tipo di dati: Enumerazione Importanza: Alta Esempio TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE Uscita in Messaggi vista: SA0171: L'enumerazione deve avere l'attributo 'strict' Nessuna violazione delle regole di programmazione: {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE " }, 
{ "title" : "SA0172: Possibile tentativo di accesso al di fuori dei limiti dell'array ", 
"url" : "_san_rule_sa0172.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0172: Possibile tentativo di accesso al di fuori dei limiti dell'array ", 
"snippet" : "Rileva il possibile accesso a un indice di matrice al di fuori dei limiti della matrice. Spesso l'intervallo dell'indice dell'array viene superato in FOR cicli in cui la variabile indice viene utilizzata per accedere a un indice di matrice. Importanza: Alta Esempio PROGRAM Test VAR_TEMP iIndex: INT;...", 
"body" : "Rileva il possibile accesso a un indice di matrice al di fuori dei limiti della matrice. Spesso l'intervallo dell'indice dell'array viene superato in FOR cicli in cui la variabile indice viene utilizzata per accedere a un indice di matrice. Importanza: Alta Esempio PROGRAM Test\nVAR_TEMP\n iIndex: INT;\n arUSINT: Array[0..10] OF INT;\nEND_VAR\n FOR iIndex := INT#0 TO INT#50 DO\n arUSINT[iIndex] := 0;\nEND_FOR Uscita in Messaggi vista: SA0172: Possibile tentativo di accesso al di fuori dei limiti dell'array " }, 
{ "title" : "SA0175: Operazione sospetta su stringa ", 
"url" : "_san_rule_sa0175.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0175: Operazione sospetta su stringa ", 
"snippet" : "Non sempre abilitare questa regola. Abilitare la regola solo quando necessario per trovare le posizioni nel codice che devono essere verificate durante la conversione alla codifica UTF-8. Controlla se l'opzione progetto Codifica UTF-8 per STRING può essere abilitato. Questo è il caso in cui non veng...", 
"body" : "Non sempre abilitare questa regola. Abilitare la regola solo quando necessario per trovare le posizioni nel codice che devono essere verificate durante la conversione alla codifica UTF-8. Controlla se l'opzione progetto Codifica UTF-8 per STRING può essere abilitato. Questo è il caso in cui non vengono trovate posizioni di codice con operazioni sospette. Quando si passa alla codifica UTF-8, i primi 127 caratteri corrispondono alla codifica ASCII. Tuttavia, tutti gli altri caratteri sono codificati con più di un byte. Ciò può causare un cambiamento nel comportamento durante l'elaborazione delle stringhe. Di conseguenza, una stringa letterale contenente caratteri non ASCII potrebbe allungarsi. Oppure l'accesso a una stringa per indice può accedere all'elemento sbagliato. Infine, può verificarsi anche l'accesso a un offset di byte non valido. Quando la regola è attiva, vengono riportate tutte le posizioni di codice contenenti uno dei seguenti costrutti: Accesso all'indice a una stringa di byte Esempio: str[2] Messaggio: SA0175: Enumerazione con attributo 'strict': operazione sospetta sulla stringa: accesso all'indice '<espressione>' Indirizzo di accesso a stringhe a byte singolo Esempio: ADR(str) Messaggio: SA0175: Enumerazione con attributo 'strict': operazione sospetta sulla stringa: possibile accesso all'indice '<expression>' Richiamo delle funzioni di stringa del Standard libreria, tranne quando si chiama il CONCAT e LEN funzioni Messaggio: SA0175: Enumerazione con attributo 'strict': operazione sospetta sulla stringa: possibile accesso all'indice '<expression>' Byte letterale contenente caratteri non ASCII Esempi: str := '99€';\nstr :='Ä'; Messaggio: SA0175: Operazione sospetta sulla stringa: il letterale '<literal>' contiene caratteri non ASCII " }, 
{ "title" : "SA0180: L'intervallo dell'indice non copre l'intero array ", 
"url" : "_san_rule_sa0180.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ regole \/ SA0180: L'intervallo dell'indice non copre l'intero array ", 
"snippet" : "Rileva matrici con intervallo di indici coperto in modo incompleto Gli array vengono spesso gestiti in cicli, in cui l'indice del ciclo indicizza l'array in modo che tutti i componenti dell'array vengano saltati senza interruzioni. Ciò viene fornito se l'indice del ciclo e l'indice dell'array sono g...", 
"body" : "Rileva matrici con intervallo di indici coperto in modo incompleto Gli array vengono spesso gestiti in cicli, in cui l'indice del ciclo indicizza l'array in modo che tutti i componenti dell'array vengano saltati senza interruzioni. Ciò viene fornito se l'indice del ciclo e l'indice dell'array sono gli stessi in tutte le dimensioni. Se l'intervallo dell'indice non copre completamente l'array, ciò indica componenti non gestiti nell'array. Importanza: media Esempio {attribute 'do-analysis'}\nPROGRAM PLC_PRG\nVAR\n a : INT;\n arWord : ARRAY [0..100] OF WORD;\nEND_VAR\n\/\/Implementation\nFOR a := INT#1 TO INT#100 BY 1 DO \/\/SA0180: Lower range is not reached\n\tarWord[a] := INT_TO_WORD(a);\nEND_FOR;\n;\n Uscita in Messaggi visualizzazione: SA0180: L'intervallo dell'indice non copre l'intero array " }, 
{ "title" : "Metrica ", 
"url" : "_san_reference_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica ", 
"snippet" : "Descrizione dettagliata delle metriche fornite da CODESYS Static Analysis IL Dimensione del codice , Dimensione variabile , Dimensione della pila , E Numero di chiamate le metriche vengono riportate solo per le POU delle librerie integrate nel progetto....", 
"body" : "Descrizione dettagliata delle metriche fornite da CODESYS Static Analysis IL Dimensione del codice , Dimensione variabile , Dimensione della pila , E Numero di chiamate le metriche vengono riportate solo per le POU delle librerie integrate nel progetto. " }, 
{ "title" : "Metrica: Dimensione del codice (numero di byte) ", 
"url" : "_san_reference_metrics.html#UUID-35adc4d5-9253-44d6-f130-aab7171bff69", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Dimensione del codice (numero di byte) ", 
"snippet" : "Dimensione del codice (numero di byte) Categorie: Informativo, Efficienza Numero di byte con cui un blocco funzione contribuisce al codice dell'applicazione Il numero dipende anche dal generatore di codice. Ad esempio, il generatore di codice per i processori ARM generalmente genera più byte rispett...", 
"body" : "Dimensione del codice (numero di byte) Categorie: Informativo, Efficienza Numero di byte con cui un blocco funzione contribuisce al codice dell'applicazione Il numero dipende anche dal generatore di codice. Ad esempio, il generatore di codice per i processori ARM generalmente genera più byte rispetto al generatore di codice per i processori x86. " }, 
{ "title" : "Metrica: Dimensione variabile (numero di byte) ", 
"url" : "_san_reference_metrics.html#UUID-b07882e2-be28-fe1e-eb10-ed5defcf3c74", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Dimensione variabile (numero di byte) ", 
"snippet" : "Dimensione variabile (numero di byte) Categorie : Informativo, Efficienza Dimensione della memoria statica utilizzata dall'oggetto Per i blocchi funzione, questa è la dimensione utilizzata per un'istanza del blocco funzione (che può includere lacune di memoria, a seconda dell'allineamento della memo...", 
"body" : "Dimensione variabile (numero di byte) Categorie : Informativo, Efficienza Dimensione della memoria statica utilizzata dall'oggetto Per i blocchi funzione, questa è la dimensione utilizzata per un'istanza del blocco funzione (che può includere lacune di memoria, a seconda dell'allineamento della memoria). Per programmi, funzioni ed elenchi di variabili globali, questa è la somma delle dimensioni di tutte le variabili statiche. Esempio FUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR La funzione ha 3 variabili statiche di tipo INT (f , g , E h ), ognuno dei quali richiede 2 byte di memoria. Di conseguenza, FUN1 ha una dimensione variabile di 6 byte. " }, 
{ "title" : "Metrica: Dimensione dello stack (numero di byte) ", 
"url" : "_san_reference_metrics.html#UUID-52e032c0-e190-f5c0-344b-e6c04694a3ef", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Dimensione dello stack (numero di byte) ", 
"snippet" : "Dimensione dello stack (numero di byte) Categorie : Informativo, Efficienza, Affidabilità Numero di byte necessari per richiamare una funzione o un blocco funzione Le variabili di ingresso e le variabili di uscita sono allineate alla memoria. Ciò può creare un divario tra queste variabili e le varia...", 
"body" : "Dimensione dello stack (numero di byte) Categorie : Informativo, Efficienza, Affidabilità Numero di byte necessari per richiamare una funzione o un blocco funzione Le variabili di ingresso e le variabili di uscita sono allineate alla memoria. Ciò può creare un divario tra queste variabili e le variabili locali. Questo divario viene conteggiato. I valori restituiti delle funzioni chiamate che non rientrano in un registro vengono inseriti nello stack. Il maggiore di questi valori determina la memoria aggiuntiva allocata, che conta anch'essa. Le funzioni o i blocchi funzionali richiamati all'interno delle POU in questione dispongono di un proprio stack frame. Pertanto, la memoria per tali chiamate non viene conteggiata. A seconda del generatore di codice utilizzato, anche i risultati intermedi dei calcoli utilizzano lo stack. Questi risultati non vengono conteggiati. Esempio \/\/Declaration\nFUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d,e : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR\n\n\/\/Implementation\nc := b;\nd := a;\ne := a+b; Ipotesi: per il calcolo, supporre a CODESYS Control Win che utilizza il generatore di codice x86. L'esempio precedente ha una dimensione del chiamante di 8 byte: 4 byte per i due INT inputs e 4 byte per il valore restituito. Il dispositivo ha un allineamento dello stack di 4 byte, quindi c'è uno spazio di 2 byte. La dimensione del chiamante è 8 byte: tre variabili locali con 2 byte ciascuna più il gap di 2 byte per l'allineamento dello stack. Di conseguenza, la dimensione totale dello stack è di FUN1 è di 16 byte. VAR_STAT non viene memorizzato nello stack e pertanto non aumenta la dimensione dello stack di una POU. " }, 
{ "title" : "Metrica: Numero di chiamate (chiamate) ", 
"url" : "_san_reference_metrics.html#UUID-652fc3dc-10b7-711b-cea7-9b006e6249b5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Numero di chiamate (chiamate) ", 
"snippet" : "Numero di chiamate (chiamate) Categoria : Informativo Numero di chiamate della POU sotto Unità di programma Esempio \/\/Declaration PLC_PRG PROGRAM PLC_PRG VAR myFB : FB1; END_VAR \/\/Implementation myFB(b := FALSE); \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR_INPUT b : BOOL; END_VAR VAR i : INT; END_VAR \/...", 
"body" : "Numero di chiamate (chiamate) Categoria : Informativo Numero di chiamate della POU sotto Unità di programma Esempio \/\/Declaration PLC_PRG\nPROGRAM PLC_PRG\nVAR\n myFB : FB1;\nEND_VAR\n\n\/\/Implementation\nmyFB(b := FALSE); \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR_INPUT\n b : BOOL;\nEND_VAR\nVAR\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH(i);\nIF b THEN\n METH(i*i);\nEND_IF\n \/\/Declaration FB1.METH\nMETHOD METH : BOOL\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := i >= 42; Se PLC_PRG viene chiamato in un'attività, viene conteggiata anche questa chiamata. FB1 ha esattamente una chiamata (in PLC_PRG ). METH ha due chiamate, entrambe in entrata FB1 . " }, 
{ "title" : "Metrica: Numero di chiamate da attività (attività) ", 
"url" : "_san_reference_metrics.html#UUID-3768e9b9-fdef-e8c5-d81a-3ab94c3eed82", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Numero di chiamate da attività (attività) ", 
"snippet" : "Numero di chiamate da attività (attività) Categorie : Manutenibilità, Affidabilità Numero di compiti ( Compiti ) dove il POU specificato sotto Unità di programma è chiamato Nel caso dei blocchi funzione viene contato il numero di task in cui viene chiamato il blocco funzione stesso o qualsiasi blocc...", 
"body" : "Numero di chiamate da attività (attività) Categorie : Manutenibilità, Affidabilità Numero di compiti ( Compiti ) dove il POU specificato sotto Unità di programma è chiamato Nel caso dei blocchi funzione viene contato il numero di task in cui viene chiamato il blocco funzione stesso o qualsiasi blocco funzione nell'albero ereditario del blocco funzione. Per i metodi e le azioni viene visualizzato il numero di task in cui viene richiamato il blocco funzione (principale). Esempio FUNCTION_BLOCK FB\n\/\/... FUNCTION_BLOCK FB2 EXTENDS FB\n\/\/... FUNCTION_BLOCK FB3 EXTENDS FB2\n\/\/... Ogni blocco funzione viene richiamato autonomamente PROGRAM . Ogni PROGRAM ha il suo compito. IL Chiamato nei compiti restituisce la metrica in 1 per FB3 e 2 per FB2 perché le chiamate da FB3 E FB2 vengono contati. La metrica risulta in 3 per FB perché in questo caso le chiamate da FB3 , FB2 , E FB vengono contati. " }, 
{ "title" : "Metrica:Numero di variabili globali utilizzate (globali) ", 
"url" : "_san_reference_metrics.html#UUID-04068c53-4046-0979-468b-866b1a155a8a", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica:Numero di variabili globali utilizzate (globali) ", 
"snippet" : "Numero di variabili globali utilizzate (Globali) Categorie : Manutenibilità, Riutilizzabilità Numero di variabili globali utilizzate nella POU sotto Unità di programma Esempio \/\/GVL VAR_GLOBAL gvla : INT; gvlb : INT; gvlc : INT; END_VAR \/PRG declaration PROGRAM PRG VAR x : INT := GVL.gvlc; y : INT; ...", 
"body" : "Numero di variabili globali utilizzate (Globali) Categorie : Manutenibilità, Riutilizzabilità Numero di variabili globali utilizzate nella POU sotto Unità di programma Esempio \/\/GVL\nVAR_GLOBAL\n gvla : INT;\n gvlb : INT;\n gvlc : INT;\nEND_VAR \/PRG declaration\nPROGRAM PRG\nVAR\n x : INT := GVL.gvlc;\n y : INT;\nEND_VAR\n\n\/\/PRG implementation\nx := GVL.gvla;\ny := GVL.gvla*GVL.gvlb; IL PRG il programma utilizza 3 variabili da GVL : gvla , gvlb , E gvlc . " }, 
{ "title" : "Metrica: Numero di accessi diretti agli indirizzi (IO) ", 
"url" : "_san_reference_metrics.html#UUID-792a6162-1022-f930-dadb-104aa5a51709", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Numero di accessi diretti agli indirizzi (IO) ", 
"snippet" : "Numero di accessi diretti agli indirizzi (IO) Categorie : Riutilizzabilità, Manutenibilità Numero di accessi diretti all'indirizzo ( IO ) nell'implementazione dell'oggetto. Esempio \/\/Declaration PROGRAM PRG VAR xVar : BOOL:= %IX0.0; \/\/ +1 direct address access byVar : BYTE; END_VAR \/\/Implementation ...", 
"body" : "Numero di accessi diretti agli indirizzi (IO) Categorie : Riutilizzabilità, Manutenibilità Numero di accessi diretti all'indirizzo ( IO ) nell'implementazione dell'oggetto. Esempio \/\/Declaration\nPROGRAM PRG\nVAR\n xVar : BOOL:= %IX0.0; \/\/ +1 direct address access\n byVar : BYTE;\nEND_VAR\n\n\/\/Implementation\nxVar := %IX0.0; \/\/ +1 direct address access\n%QX0.0 := xVar; \/\/ +1\n%MX0.1 := xVar; \/\/ +1\n%MB1 := byVar; \/\/ +1 L'esempio ha 5 accessi diretti all'indirizzo. " }, 
{ "title" : "Metrica: Numero di variabili locali (locali) ", 
"url" : "_san_reference_metrics.html#UUID-f738f257-cf3a-1e7c-979e-1d6b4733c2d9", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Numero di variabili locali (locali) ", 
"snippet" : "Numero di variabili locali (Locals) Categorie : Informativo, Efficienza Numero di variabili dichiarate nel VAR zona del POU. Le variabili ereditate non vengono conteggiate. Esempio \/\/Declaration FUNCTION_BLOCK FB VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR i,j,k,l : INT; m,n,o : BOOL; END_VAR Nel blocc...", 
"body" : "Numero di variabili locali (Locals) Categorie : Informativo, Efficienza Numero di variabili dichiarate nel VAR zona del POU. Le variabili ereditate non vengono conteggiate. Esempio \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,j,k,l : INT;\n m,n,o : BOOL;\nEND_VAR\n Nel blocco funzione vengono dichiarate 7 variabili locali. " }, 
{ "title" : "Metrica: Numero di variabili di input (input) ", 
"url" : "_san_reference_metrics.html#UUID-03e01655-9ac0-74f4-3fd7-cf22f23db4f6", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Numero di variabili di input (input) ", 
"snippet" : "Numero di variabili di ingresso (Ingressi) Categorie : Manutenibilità, Riutilizzabilità Limite superiore predefinito per il corrispondente SA0166 regola: 10 Numero di variabili dichiarate in VAR_INPUT dell'unità di programma. Le variabili di input ereditate non vengono conteggiate. Esempi FUNCTION_B...", 
"body" : "Numero di variabili di ingresso (Ingressi) Categorie : Manutenibilità, Riutilizzabilità Limite superiore predefinito per il corrispondente SA0166 regola: 10 Numero di variabili dichiarate in VAR_INPUT dell'unità di programma. Le variabili di input ereditate non vengono conteggiate. Esempi FUNCTION_BLOCK FB\nVAR_INPUT\n i : INT;\n r : REAL;\nEND_VAR\n Nel blocco funzione vengono dichiarate 2 variabili di ingresso: i E r . METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR\n Il metodo ha 2 input: j E l " }, 
{ "title" : "Metrica: Numero di variabili di output (output) ", 
"url" : "_san_reference_metrics.html#UUID-7bba3bc6-748c-311d-7f8c-4878fdce9da0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Numero di variabili di output (output) ", 
"snippet" : "Numero di variabili di uscita (Uscite) Categorie : Manutenibilità, Riutilizzabilità Limite superiore predefinito per il corrispondente SA0166 regola: 10 Numero di variabili in VAR_OUTPUT dell'unità di programma Nel caso dei blocchi funzione, questo è il numero di variabili di uscita personalizzate (...", 
"body" : "Numero di variabili di uscita (Uscite) Categorie : Manutenibilità, Riutilizzabilità Limite superiore predefinito per il corrispondente SA0166 regola: 10 Numero di variabili in VAR_OUTPUT dell'unità di programma Nel caso dei blocchi funzione, questo è il numero di variabili di uscita personalizzate ( VAR_OUTPUT ). Nel caso di metodi e funzioni, questo è il numero di variabili di output personalizzate più uno se hanno un valore restituito. Viene conteggiato anche il valore restituito. Le variabili di output ereditate non vengono conteggiate. Un numero elevato di variabili di output è indice di una violazione del principio di unicità della responsabilità. Esempi FUNCTION_BLOCK FB\nVAR_OUTPUT\n i : INT; \/\/ +1 output\n r : REAL; \/\/ +1 output\nEND_VAR Il blocco funzione ha 2 variabili di uscita: i E r METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR Il metodo ha 3 output: METH , j , E l METHOD METH1 \/\/ +0 outputs (no return type)\nVAR_OUTPUT\n ar : ARRAY[0..10] OF INT; \/\/ +1 output\n l : LREAL; \/\/ +1 output\nEND_VAR IL METH1 il metodo ha 2 output: ar E i " }, 
{ "title" : "Metrica: NOS – Numero di dichiarazioni ", 
"url" : "_san_reference_metrics.html#UUID-82054fe5-816d-0c12-0afa-11dabf2c47b3", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: NOS – Numero di dichiarazioni ", 
"snippet" : "NOS – Numero di dichiarazioni Categoria : Informativo Numero di istruzioni nell'implementazione di un blocco funzione, funzione o metodo Le istruzioni nella dichiarazione, le istruzioni vuote o i pragma non vengono conteggiate. Esempio \/\/Declaration: FUNCTION POU : BOOL VAR_INPUT END_VAR VAR c : INT...", 
"body" : "NOS – Numero di dichiarazioni Categoria : Informativo Numero di istruzioni nell'implementazione di un blocco funzione, funzione o metodo Le istruzioni nella dichiarazione, le istruzioni vuote o i pragma non vengono conteggiate. Esempio \/\/Declaration:\nFUNCTION POU : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n c : INT := 100; \/\/ statements in the declaration are not counted\nEND_VAR\nVAR_OUTPUT\n test : INT;\n i : INT;\nEND_VAR\n\n\/\/Implementation:\nIF TRUE THEN \/\/if statement: +1\n test := 0; \/\/ +1\nEND_IF\n\nWHILE test = 1 DO \/\/while statement: +1\n ; \/\/ empty statements do not add to the statement count\nEND_WHILE\n\nFOR c := 0 TO 10 BY 2 DO \/\/for statement: +1\n i := i+i; \/\/ +1\nEND_FOR\n\n{text 'simple text pragma'} \/\/pragmas are not counted\ntest := 2; \/\/+1 L'esempio ha 6 istruzioni. " }, 
{ "title" : "Metrica: Percentuale di commenti ", 
"url" : "_san_reference_metrics.html#UUID-abd88d31-c33e-db93-0f69-bec1a38795f7", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Percentuale di commenti ", 
"snippet" : "Percentuale di commenti Categoria : Manutenibilità Percentuale di commenti nel codice sorgente Questo numero viene calcolato secondo la seguente formula: Percentuale = 100 * <caratteri nei commenti> \/ <somma dei caratteri nel codice sorgente e dei caratteri nei commenti> Più spazi consecutivi nel co...", 
"body" : "Percentuale di commenti Categoria : Manutenibilità Percentuale di commenti nel codice sorgente Questo numero viene calcolato secondo la seguente formula: Percentuale = 100 * <caratteri nei commenti> \/ <somma dei caratteri nel codice sorgente e dei caratteri nei commenti> Più spazi consecutivi nel codice sorgente vengono conteggiati come uno spazio, il che impedisce un peso elevato del codice sorgente con rientro. Per gli oggetti vuoti (senza codice sorgente e senza commenti), viene restituita una percentuale pari a 0. Esempio Parte della dichiarazione: FUNCTION_BLOCK FB \/\/comments in the declaration are counted, as well\nVAR_TEMP\n hugo : INT;\nEND_VAR Implementazione: hugo := hugo + 1;\n\/\/Declaration: 40 letters non comment; 50 letters comment\n\/\/Implementation: 13 letters non comment; 152 letters comment\n\/\/ 100 * 202 \/ 255 -> 79% comments Il calcolo della percentuale 100 * 202 \/ 255 restituisce 79%. " }, 
{ "title" : "Metrica: Complessità (McCabe) ", 
"url" : "_san_reference_metrics.html#UUID-ea21160c-97be-30d4-7748-0adac68532a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Complessità (McCabe) ", 
"snippet" : "Complessità (McCabe) Categoria : Testabilità Limite superiore consigliato: 10 La complessità ciclomatica secondo McCabe è una misura della leggibilità e testabilità del codice sorgente. Viene calcolato contando il numero di rami binari nel flusso di controllo della POU. Tuttavia, la complessità cicl...", 
"body" : "Complessità (McCabe) Categoria : Testabilità Limite superiore consigliato: 10 La complessità ciclomatica secondo McCabe è una misura della leggibilità e testabilità del codice sorgente. Viene calcolato contando il numero di rami binari nel flusso di controllo della POU. Tuttavia, la complessità ciclomatica penalizza l’elevata ramificazione perché l’elevata ramificazione aumenta il numero di casi di test richiesti per un’elevata copertura del test. Esempio: IF dichiarazione \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nIF b1 THEN \/\/ +1 for the THEN branch\n ;\n ELSIF b2 THEN \/\/ +1 for the THEN branch of the IF inside the else\n ;\nELSE \n IF b3 OR b4 THEN \/\/ +1 for the THEN branch\n ;\n END_IF\nEND_IF Lo snippet di codice ha una complessità ciclomatica pari a 4. Esempio: CASE dichiarazione \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nCASE a OF\n 1:\t; \/\/ +1\n 2:\t; \/\/ +1\n 3,4,5:\t; \/\/ +1\nELSE \/\/ the ELSE statement does not increase the cyclomatic complexity\n ;\nEND_CASE Lo snippet di codice ha una complessità ciclomatica pari a 4. Esempio: Istruzione Loop \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nWHILE b1 DO \/\/ +1 for the WHILE loop\n ;\nEND_WHILE\n\nREPEAT \/\/ +1 for the REPEAT loop\n ;\n UNTIL b2\nEND_REPEAT\n\nFOR a := 0 TO 100 BY 2 DO \/\/ +1 for the REPEAT loop\n ;\nEND_FOR Lo snippet di codice ha una complessità ciclomatica pari a 4. Esempio: Altre affermazioni Anche le seguenti affermazioni aumentano la complessità ciclomatica: \/\/Declaration\nFUNCTION FUN : STRING\nVAR_INPUT\n condition_return : BOOL;\n condition_jmp : BOOL;\nEND_VAR\nVAR\nEND_VAR\n\n\/\/Implementation\n\/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nJMP(condition_jmp) lbl; \/\/Conditional jumps increase the cyclomatic complexity by 1\n\nFUN := 'u';\nRETURN(condition_return); \/\/Conditional returns increase the cyclomatic complexity by 1, too\n\nlbl:\nFUN := 't';\n Lo snippet di codice ha una complessità ciclomatica pari a 3. " }, 
{ "title" : "Metrica: Complessità cognitiva ", 
"url" : "_san_reference_metrics.html#UUID-cd064f18-bd35-1d86-1bd4-2ae3a8fe344f", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Complessità cognitiva ", 
"snippet" : "Complessità cognitiva Categoria : Manutenibilità Limite superiore predefinito per la corrispondente regola SA0178: 20 La complessità cognitiva è una misura della leggibilità e della comprensibilità del codice sorgente introdotto da Sonarsource™ nel 2016. Tuttavia, penalizza l'annidamento pesante del...", 
"body" : "Complessità cognitiva Categoria : Manutenibilità Limite superiore predefinito per la corrispondente regola SA0178: 20 La complessità cognitiva è una misura della leggibilità e della comprensibilità del codice sorgente introdotto da Sonarsource™ nel 2016. Tuttavia, penalizza l'annidamento pesante del flusso di controllo e delle espressioni booleane complesse. La complessità cognitiva viene calcolata solo per le implementazioni di testo strutturato. Gli esempi seguenti mostrano come viene calcolata la complessità cognitiva. IL Mostra complessità cognitiva per l'editor corrente Il comando può essere utilizzato per visualizzare ulteriormente gli incrementi per il testo strutturato. Esempio: Flusso di controllo Le affermazioni che manipolano il flusso di controllo aumentano la complessità cognitiva di 1 IF TRUE THEN \/\/ +1 cognitive complexity\n ;\nEND_IF\n\nWHILE TRUE DO \/\/+1 cognitive complexity\n ;\nEND_WHILE\n\nFOR i := 0 TO 10 BY 1 DO \/\/+1 cognitive complexity\n ;\nEND_FOR\n\nREPEAT \/\/+1 cognitive complexity\n ;\nUNTIL TRUE\nEND_REPEAT Lo snippet di codice ha una complessità cognitiva pari a 4. Esempio: Annidamento del flusso di controllo Quando si annida il flusso di controllo, viene aggiunto un incremento di 1 per ogni livello di annidamento. IF TRUE THEN \/\/+1 cognitive complexity\n WHILE TRUE DO \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n FOR i := 0 TO 10 BY 1 DO \/\/+3 (+1 for the FOR loop itself, +2 for the nesting inside the WHILE and the IF)\n\t\t\t;\n END_FOR\n END_WHILE\n\n REPEAT \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n ;\n UNTIL TRUE\n END_REPEAT\nEND_IF Lo snippet di codice ha una complessità cognitiva pari a 8. Esempio: Espressione booleana Poiché le espressioni booleane svolgono un ruolo importante nella comprensione del codice sorgente, vengono prese in considerazione anche nel calcolo della complessità cognitiva. Comprendere le espressioni booleane associate allo stesso operatore booleano non è così difficile come comprendere un'espressione booleana che contiene operatori booleani alternati. Pertanto, qualsiasi catena di operatori booleani identici in un'espressione aumenta la complessità cognitiva. b := b1; \/\/+0: a simple expression, containing no operators, has no increment\n L'espressione semplice senza operatore ha un incremento pari a 0. b := b1 AND b2; \/\/+1: one chain of AND operators L'espressione con un AND il collegamento ha un incremento di 1. b := b1 AND b2 AND b3; \/\/+1: one more AND, but the number of chains of operators does not change L'espressione ne ha uno in più AND . Ma poiché si tratta dello stesso operatore, il numero della catena formata con operatori identici non cambia. b := b1 AND b2 OR b3; \/\/+2: one chain of AND operators and one chain of OR operators L'espressione ha una catena di AND operatori e una catena di OR operatori. Ciò si traduce in un incremento di 2. b := b1 AND b2 OR b3 AND b4 AND b5; \/\/+3 Lo snippet di codice ha un incremento di 3. b := b1 AND NOT b2 AND b3; \/\/+1: the unary NOT operator is not considered in the cognitive complexity L'operatore unario NOT non è considerato nella complessità cognitiva. Esempio: Altre istruzioni con incremento Il testo strutturato dispone di istruzioni ed espressioni aggiuntive che modificano il flusso di controllo. Le seguenti affermazioni vengono penalizzate con un incremento di complessità cognitiva: aNewLabel:\nx := MUX(i, a,b,c); \/\/+1 for MUX operator\ny := SEL(b, i,j); \/\/+1 for SEL operator\nJMP aNewLabel; \/\/+1 for JMP to label EXIT E RETURN Le affermazioni non aumentano la complessità cognitiva. " }, 
{ "title" : "Metrica: DIT – Profondità dell'albero dell'ereditarietà ", 
"url" : "_san_reference_metrics.html#UUID-c7e1c296-e321-f999-8ed7-9713ebdb50fc", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: DIT – Profondità dell'albero dell'ereditarietà ", 
"snippet" : "DIT – Profondità dell'albero dell'ereditarietà Categoria : Manutenibilità Numero di eredità fino al raggiungimento di un blocco funzione che non estende nessun altro blocco funzione Esempio FUNCTION_BLOCK MyBaseFB \/\/ ... FUNCTION_BLOCK AChildFB EXTENDS MyBaseFB \/\/ ... FUNCTION_BLOCK AGrandChildFB EX...", 
"body" : "DIT – Profondità dell'albero dell'ereditarietà Categoria : Manutenibilità Numero di eredità fino al raggiungimento di un blocco funzione che non estende nessun altro blocco funzione Esempio FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB ha un DIT pari a 0 perché è esso stesso un blocco funzione che non estende nessun altro blocco funzione. Per AChildFB , il DIT è 1 perché è necessario un passaggio per arrivare a MyBaseFB . AGrandChildFB ha un DIT pari a 2: è necessario un passaggio AChildFB e un altro a MyBaseFB . " }, 
{ "title" : "Metrica: NOC – Numero di bambini ", 
"url" : "_san_reference_metrics.html#UUID-04314eaf-28e7-40ea-0aa9-e7f46e79bfa0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: NOC – Numero di bambini ", 
"snippet" : "NOC – Numero di bambini Categorie : Riutilizzabilità, Manutenibilità Numero di blocchi funzione che estendono il blocco funzione base indicato. I blocchi funzione che estendono indirettamente un blocco funzione base non vengono conteggiati. Esempio FUNCTION_BLOCK MyBaseFB \/\/ ... FUNCTION_BLOCK AChil...", 
"body" : "NOC – Numero di bambini Categorie : Riutilizzabilità, Manutenibilità Numero di blocchi funzione che estendono il blocco funzione base indicato. I blocchi funzione che estendono indirettamente un blocco funzione base non vengono conteggiati. Esempio FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB ha solo un (1) oggetto figlio: AChildFB , che a sua volta ha l'unico oggetto figlio, AGrandChildFB . AGrandChildFB non ha oggetti figlio. " }, 
{ "title" : "Metriche: RFC – Risposta per classe ", 
"url" : "_san_reference_metrics.html#UUID-0fcfc138-e361-a392-6fbe-11240e7a6e2a", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metriche: RFC – Risposta per classe ", 
"snippet" : "Risposta per la classe (RFC) Categorie : Manutenibilità, Riutilizzabilità Numero di diversi POU, metodi o azioni che vengono richiamati e che quindi generano una risposta del POU specificato sotto Unità di programma Esempio \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR d,x,y : INT; END_VAR \/\/Implementati...", 
"body" : "Risposta per la classe (RFC) Categorie : Manutenibilità, Riutilizzabilità Numero di diversi POU, metodi o azioni che vengono richiamati e che quindi generano una risposta del POU specificato sotto Unità di programma Esempio \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR\n d,x,y : INT;\nEND_VAR\n\n\/\/Implementation\nx := METH(d+10);\ny := FUN(42, 0.815); \/\/Declaration FB1.METH\nMETHOD METH : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := FUN(CUBE(i), 3.1415); \/\/Declaration CUBE\nFUNCTION CUBE : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nCUBE := i*i*i; \/\/Declaration Function FUN\nFUNCTION FUN : INT\nVAR_INPUT\n a : INT;\n lr : LREAL;\nEND_VAR\n\n\/\/Implementation\nFUN := LREAL_TO_INT(lr*10)*a; Iniziare con FUN E CUBE , queste funzioni hanno un RFC pari a 0 perché nessuna di esse chiama altre funzioni, blocchi funzione o metodi per i propri calcoli. FB1.METH usi FUN E CUBE , che si traduce in un RFC di 2. Il blocco funzione FB1 stesso chiama METH E FUN , che aumenta il suo RFC di 2. Per FB1 occorre tenere conto anche del relativo metodo METH. METH utilizza FUN e CUBE. FUN è già stato aggiunto alla RFC. Pertanto, solo l'uso di CUBE in METH aumenta la RFC per FB1 a 3 " }, 
{ "title" : "Metrica: CBO – Accoppiamento tra oggetti ", 
"url" : "_san_reference_metrics.html#UUID-d98bd2a3-497b-920f-1f11-f4f38973066f", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: CBO – Accoppiamento tra oggetti ", 
"snippet" : "CBO – Accoppiamento tra oggetti Categorie : Manutenibilità, Riutilizzabilità Limite superiore predefinito per la corrispondente regola SA0179: 30 Numero di altri blocchi funzione istanziati e utilizzati in un blocco funzione Un blocco funzione con un elevato accoppiamento tra oggetti è probabile che...", 
"body" : "CBO – Accoppiamento tra oggetti Categorie : Manutenibilità, Riutilizzabilità Limite superiore predefinito per la corrispondente regola SA0179: 30 Numero di altri blocchi funzione istanziati e utilizzati in un blocco funzione Un blocco funzione con un elevato accoppiamento tra oggetti è probabile che sia coinvolto in molti compiti diversi e quindi violi il principio di responsabilità unica. Esempio \/\/ Declaration\nFUNCTION_BLOCK FB_Child EXTENDS FB_Base objects \/\/ +0 for EXTENDS\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i_fb1 : FB1; \/\/ +1 instantiated here\n i_fb2 : FB2; \/\/ +1 instantiated here\nEND_VAR\n\n\/\/Implementation\ni_fb3(); \/\/ +0 instantiated in FB_Base, no increment for call L'estensione di un blocco funzione non aumenta l'accoppiamento tra gli oggetti. i_fb3 è istanziato nell'implementazione di FB_Base e passato a FB_Child ( EXTENDS ). La chiamata FB_Child non aumenta l'accoppiamento tra gli oggetti. Il CBO di FB_Child è 2. " }, 
{ "title" : "Metrica: Complessità di riferimento (Elshof) ", 
"url" : "_san_reference_metrics.html#UUID-a43f74c1-523d-b649-00e5-788c653e5ea1", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Complessità di riferimento (Elshof) ", 
"snippet" : "Complessità di riferimento (Elshof) Categorie : Efficienza, manutenibilità, riusabilità Complessità del flusso dati di una POU La complessità di riferimento viene calcolata secondo la seguente formula: <numero di variabili utilizzate> \/ <numero di accessi alle variabili> Vengono considerati solo gli...", 
"body" : "Complessità di riferimento (Elshof) Categorie : Efficienza, manutenibilità, riusabilità Complessità del flusso dati di una POU La complessità di riferimento viene calcolata secondo la seguente formula: <numero di variabili utilizzate> \/ <numero di accessi alle variabili> Vengono considerati solo gli accessi variabili nella parte di implementazione della POU. Esempio \/\/Declaration\nPROGRAM PRG\nVAR\n i, j : INT;\n k : INT := GVL.m;\n b, c : BOOL;\n myFB : FB;\nEND_VAR\n\n\/\/Implementation\nmyFB(paramA := b); \/\/ +3 accesses (myFB, paramA and b)\ni := j; \/\/ +2 accesses (i and j)\nj := GVL.d; \/\/ +2 accesses (j and GVL.d) Fare riferimento alla complessità nei risultati dello snippet di codice: 6 numero di variabili utilizzate \/7 numero di accessi variabile = 0,85 Attenzione: c E k non vengono utilizzate e pertanto non contano come \"variabili utilizzate\". L'incarico k : INT := GVL.m non viene conteggiato perché fa parte della dichiarazione del programma. " }, 
{ "title" : "Metrica: Mancanza di Coesione dei Metodi – LCOM ", 
"url" : "_san_reference_metrics.html#UUID-068c2765-4709-d4e2-80b6-d173998195a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Mancanza di Coesione dei Metodi – LCOM ", 
"snippet" : "Mancanza di coesione dei metodi – LCOM Mancanza di coesione dei metodi – LCOM Categorie : Manutenibilità, Riutilizzabilità La coesione tra i blocchi funzione, le loro azioni, transizioni e metodi descrive se accedono o meno alle stesse variabili. La mancanza di coesione dei metodi descrive quanto fo...", 
"body" : "Mancanza di coesione dei metodi – LCOM Mancanza di coesione dei metodi – LCOM Categorie : Manutenibilità, Riutilizzabilità La coesione tra i blocchi funzione, le loro azioni, transizioni e metodi descrive se accedono o meno alle stesse variabili. La mancanza di coesione dei metodi descrive quanto fortemente gli oggetti di un blocco funzione sono collegati tra loro. Minore è la mancanza di coesione, più forte è la connessione tra gli oggetti. È probabile che i blocchi funzionali con un'elevata mancanza di coesione siano coinvolti in molti compiti diversi e quindi violino il principio della responsabilità unica. La metrica viene calcolata secondo la seguente formula: MAX(0, <numero di coppie di oggetti senza coesione> - <numero di coppie di oggetti con coesione>) Esempio \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\n a : BOOL;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,b : BOOL;\nEND_VAR\n\n\/\/Implementation\ni := 42;\n\/\/FB.ACT\ni:= 0; \/\/FB.METH Declaration\nMETHOD METH : BOOL\nVAR_INPUT\n\tc : BOOL;\nEND_VAR\n\n\/\/Implementation\nMETH := c;\ni := 1; \/\/FB.SecondMETH Declaration\nMETHOD SecondMETH : INT\nVAR_INPUT\nEND_VAR\n\n\/\/Implementation\nSecondMETH := SEL(c,3,4); Coppie di oggetti senza connessione (4 coppie): FB, FB.ACT FB , FB.METH FB.ACT , FB.SecondMETH FB.METH , FB.SecondMETH Coppie di oggetti con connessione (2 coppie): FB , FB.SecondMETH (entrambi usano c ) FB.ACT , FB.METH (entrambi usano i ) La tabella mostra quali variabili collegano quali oggetti dell'FB: FB FB.ACT FB.METH FB.SecondMETH FB.SecondMETH c 0 0 . FB.METH 0 i . . FB.ACT 0 . . . FB - . . . " }, 
{ "title" : "Metrica: Numero di rami SFC ", 
"url" : "_san_reference_metrics.html#UUID-d74f2703-e85d-ed16-b335-69a4dfd4a8bd", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Numero di rami SFC ", 
"snippet" : "Numero di rami SFC Categorie : Testabilità, Manutenibilità Numero di rami alternativi e paralleli di una POU del linguaggio di implementazione SFC (sequential function chart). Esempio Il frammento di codice sopra in SFC ha 4 rami: 3 rami alternativi e 1 ramo parallelo...", 
"body" : "Numero di rami SFC Categorie : Testabilità, Manutenibilità Numero di rami alternativi e paralleli di una POU del linguaggio di implementazione SFC (sequential function chart). Esempio Il frammento di codice sopra in SFC ha 4 rami: 3 rami alternativi e 1 ramo parallelo " }, 
{ "title" : "Metrica: Numero di passaggi SFC ", 
"url" : "_san_reference_metrics.html#UUID-19d1353f-ebce-6c25-6214-7b3a97c92490", 
"breadcrumbs" : "CODESYS Static Analysis \/ Riferimento: Programmazione \/ Metrica \/ Metrica: Numero di passaggi SFC ", 
"snippet" : "Numero di passaggi SFC Categoria : Manutenibilità Numero di passi in una POU in SFC (diagramma funzionale sequenziale) Vengono contati solo i passi contenuti nella POU programmata in SFC. Non vengono conteggiati i passaggi presenti nelle implementazioni di azioni o transizioni richiamate nelle POU. ...", 
"body" : "Numero di passaggi SFC Categoria : Manutenibilità Numero di passi in una POU in SFC (diagramma funzionale sequenziale) Vengono contati solo i passi contenuti nella POU programmata in SFC. Non vengono conteggiati i passaggi presenti nelle implementazioni di azioni o transizioni richiamate nelle POU. Esempio Lo snippet di codice in SFC ha 10 passaggi. " }
]
$(document).trigger('search.ready');
});