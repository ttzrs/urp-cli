$(document).ready(function () {indexDict['it'] = [{ "title" : "CODESYS Application Composer ", 
"url" : "_ac_start_page.html", 
"breadcrumbs" : "CODESYS Application Composer \/ CODESYS Application Composer ", 
"snippet" : "CODESYS Application Composer è un software per creare in modo efficiente varianti di applicazioni costituite da blocchi funzionali ricorrenti. Sulla base dei moduli, si crea un'applicazione macchina e la si parametrizza. Il programma PLC viene generato automaticamente Migliora la riutilizzabilità e ...", 
"body" : "CODESYS Application Composer è un software per creare in modo efficiente varianti di applicazioni costituite da blocchi funzionali ricorrenti. Sulla base dei moduli, si crea un'applicazione macchina e la si parametrizza. Il programma PLC viene generato automaticamente Migliora la riutilizzabilità e la qualità delle parti dell'applicazione Maggiore efficienza grazie alla generazione automatica di applicazioni da moduli predefiniti Particolarmente adatto per la progettazione semplificata di applicazioni nei settori della fabbrica digitale o dell'industria 4.0 Le applicazioni Digital Factory o Industry 4.0 possono essere pianificate più facilmente Pronto per l'uso immediato grazie ai generatori in dotazione e al concetto di applicazione Videoclip: Automazione degli edifici con CODESYS Application Composer componente aggiuntivo Progetti di esempio È possibile installare e aggiornare CODESYS Application Composer componente aggiuntivo in CODESYS Installer . " }, 
{ "title" : "Panoramica ", 
"url" : "ac_application_composer_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Panoramica ", 
"snippet" : "IL CODESYS Application Composer viene utilizzato per creare applicazioni utilizzando i moduli esistenti. L'utente compone, parametrizza e collega i moduli richiesti per formare un'applicazione completa. Questa configurazione non richiede conoscenze di programmazione del PLC e può quindi essere effet...", 
"body" : "IL CODESYS Application Composer viene utilizzato per creare applicazioni utilizzando i moduli esistenti. L'utente compone, parametrizza e collega i moduli richiesti per formare un'applicazione completa. Questa configurazione non richiede conoscenze di programmazione del PLC e può quindi essere effettuata da tecnici senza esperienza di programmazione. I generatori interni creano applicazioni IEC 61131-3 complete e ben strutturate, inclusa la mappatura e le visualizzazioni degli I\/O. CODESYS Application Composer è costituito da due componenti principali: Editor di moduli, che può essere utilizzato per comporre i moduli software sviluppati con l'editor di dichiarazione dei moduli Editor di dichiarazioni di moduli per lo sviluppo di moduli Esempio di struttura e visualizzazione del modulo CODESYS Application Composer Per ulteriori informazioni sull'editor del modulo, vedere: Editor del moduloPer ulteriori informazioni sull'editor delle dichiarazioni del modulo, vedere: Editor delle dichiarazioni del modulo" }, 
{ "title" : "Editor del modulo ", 
"url" : "ac_module_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo ", 
"snippet" : "Utilizzando gli editor di Application Composer, le istanze del modulo di albero dei moduli può essere configurato e parametrizzato. Gli editor disponibili dell'istanza del modulo si aprono facendo doppio clic sull'oggetto o sul file Modifica oggetto comando dal menu contestuale: Distribuzione HMI Pa...", 
"body" : "Utilizzando gli editor di Application Composer, le istanze del modulo di albero dei moduli può essere configurato e parametrizzato. Gli editor disponibili dell'istanza del modulo si aprono facendo doppio clic sull'oggetto o sul file Modifica oggetto comando dal menu contestuale: Distribuzione HMI Parametri I\/O Informazione Altri redattori: Editor del modulo di estensione Redattore di sequenze IL Confronto progetti Il comando può essere utilizzato anche per le istanze del modulo Application Composer. " }, 
{ "title" : "Distribuzione ", 
"url" : "ac_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Distribuzione ", 
"snippet" : "Questa finestra di dialogo è disponibile solo per le istanze del modulo di primo livello e fornisce le impostazioni dell'applicazione e dell'attività. Finestra di dialogo per le impostazioni di primo livello Applicazione : inserito come destinazione di generazione nell'istanza del modulo di primo li...", 
"body" : "Questa finestra di dialogo è disponibile solo per le istanze del modulo di primo livello e fornisce le impostazioni dell'applicazione e dell'attività. Finestra di dialogo per le impostazioni di primo livello Applicazione : inserito come destinazione di generazione nell'istanza del modulo di primo livello. IL Il pulsante può essere utilizzato per selezionare un'applicazione esistente o creare una nuova applicazione specificando un nome. Se l'applicazione è assegnata al pool POU, allora Mappatura I\/O non è possibile. Nel caso di moduli disaccoppiati che hanno un modulo genitore, viene proposta l'applicazione madre ( [Utilizza l'applicazione principale] ). Compiti standard In questa sezione sono disponibili fino a tre attività predefinite: un'attività con priorità alta, una con priorità media e una con priorità bassa. Il nome e la disponibilità delle attività sono definiti nel modulo stesso e non possono essere modificati (nella finestra di dialogo sopra: Compito del bus di campo E Compito standard ). Oltre alle attività predefinite, l'utente può creare una nuova attività specificando un nome se \" CREATE_IF_MISSING \" è impostato nella dichiarazione del modulo. Il parametro della nuova attività può essere definito nel file Impostazioni del generatore standard . Compiti specifici del modulo : questo campo visualizza informazioni sulle attività specifiche del modulo. " }, 
{ "title" : "I\/O ", 
"url" : "ac_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ I\/O ", 
"snippet" : "Questa finestra di dialogo fornisce informazioni sugli ingressi e sulle uscite del modulo. Ingressi e uscite descrivono la richiesta di I\/O dei moduli e possono essere collegati a quanto segue: Ingressi e uscite dei dispositivi Ingressi e uscite di altre istanze del modulo Espressioni o costanti ST ...", 
"body" : "Questa finestra di dialogo fornisce informazioni sugli ingressi e sulle uscite del modulo. Ingressi e uscite descrivono la richiesta di I\/O dei moduli e possono essere collegati a quanto segue: Ingressi e uscite dei dispositivi Ingressi e uscite di altre istanze del modulo Espressioni o costanti ST (esempio: per scopi di simulazione è possibile collegare gli ingressi del modulo booleano TRUE ) Nella modalità online, il Valore in linea è visibile e viene visualizzato il valore corrente del controller. Panoramica degli I\/O dell'interfaccia del modulo Facendo clic su Mappatura apre la finestra di dialogo di mappatura I\/O: Finestra di dialogo per la mappatura I\/O Canale I\/O : facendo clic su … Il pulsante apre un'altra finestra di dialogo per mappare l'ingresso\/uscita su un I\/O del dispositivo. Espressione ST : questa opzione consente di mappare l'input\/output su un'espressione ST. Facendo clic su Il pulsante apre l'Assistente di input per selezionare una variabile. Collegare al modulo I\/O : Questa opzione può essere utilizzata per mappare l'ingresso\/uscita su un I\/O che non dispone di alcuna connessione. Facendo clic su Il pulsante apre l'Assistente di input per selezionare un modulo. Nessuna connessione : Nessuna mappatura degli ingressi\/uscite. Questa opzione è simile a Connessione mancante , ma non genera il messaggio di avviso. Connessione mancante : Questa opzione è quella predefinita e genera un avviso nella visualizzazione dei messaggi durante la generazione del progetto. Gli I\/O collegati automaticamente dal generatore di dispositivi sono indicati da (AUTO) nella colonna IN\/OUT e sono disabilitati. Se la mappatura viene comunque modificata manualmente, viene visualizzato un avviso che questa azione sovrascriverà la mappatura automatica. Se una connessione generata automaticamente viene sovrascritta da una connessione impostata manualmente, allora questo canale I\/O non viene più considerato nelle operazioni di generazione del dispositivo. " }, 
{ "title" : "HMI ", 
"url" : "ac_hmi.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ HMI ", 
"snippet" : "In questa finestra di dialogo definisci il modello di pagina e le visualizzazioni dei moduli che dovrebbero essere incorporati nella visualizzazione di primo livello. Crea scheda di primo livello : Crea una scheda nel livello più alto della visualizzazione che porta direttamente alla visualizzazione...", 
"body" : "In questa finestra di dialogo definisci il modello di pagina e le visualizzazioni dei moduli che dovrebbero essere incorporati nella visualizzazione di primo livello. Crea scheda di primo livello : Crea una scheda nel livello più alto della visualizzazione che porta direttamente alla visualizzazione di questa istanza del modulo. Tasto di scelta rapida : Con la scorciatoia qui impostata è possibile passare direttamente a questa pagina di visualizzazione. L'impostazione predefinita per la scorciatoia è definita nella dichiarazione del modulo nel file std.Visu sezione. Modello di pagina : Qui è possibile selezionare un modello per la visualizzazione del modulo che verrà utilizzato come sfondo per la visualizzazione. L'elenco a discesa fornisce una selezione di tutte le visualizzazioni definite nella dichiarazione del modulo. Per impostazione predefinita è selezionata la prima visualizzazione nella dichiarazione del modulo. Se NO visualizzazione definita, viene visualizzato \"Nessuno\". Incorpora la visualizzazione : Questa funzione consente di incorporare la visualizzazione dell'istanza del modulo nel successivo modulo sovraordinato ( Prossimo antenato ) o in qualsiasi altra visualizzazione dell'istanza del modulo. Se è definito nel modulo, allora il file %PAGE_VISU% è possibile selezionare il segnaposto. In questo caso, la schermata di visualizzazione creata per l'istanza del modulo è incorporata. È possibile definire più voci. Per informazioni sulla creazione di schermate di visualizzazione, vedere: Generazione di schermate di visualizzazione " }, 
{ "title" : "Parametro ", 
"url" : "ac_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Parametro ", 
"snippet" : "Questa finestra di dialogo mostra tutti i parametri disponibili dell'istanza del modulo che possono essere parametrizzati. Le voci in Parametro , Tipo , Descrizione , minimo , E Massimo sono solo a scopo informativo. È possibile fare doppio clic su Valore campo per modificarlo. Finestra di dialogo d...", 
"body" : "Questa finestra di dialogo mostra tutti i parametri disponibili dell'istanza del modulo che possono essere parametrizzati. Le voci in Parametro , Tipo , Descrizione , minimo , E Massimo sono solo a scopo informativo. È possibile fare doppio clic su Valore campo per modificarlo. Finestra di dialogo dei parametri delle istanze del modulo I valori dei parametri vengono visualizzati in grassetto quando sono stati impostati esplicitamente; altrimenti i caratteri rimangono normali. I parametri modificati possono essere ripristinati al loro valore predefinito mediante Riportare alle condizioni originali comando nel menu contestuale. I parametri in caratteri rossi devono essere impostati dall'utente perché altrimenti verrà visualizzato un errore al momento della creazione. Nella modalità online, il Valore in linea la colonna è visibile e viene visualizzato il valore corrente. Se si modifica il valore del parametro nel file Valore colonna, il valore viene modificato anche sul controller. Usa il Usa i valori online comando per copiare il valore online corrente nel file Valore colonna e di conseguenza utilizzarla come valore del parametro dell'istanza del modulo nell'albero del modulo. In generale, i valori dei parametri vengono visualizzati e modificati nella sintassi dei valori letterali IEC (esempio: valore del parametro di tipo TIME come t#7s35ms . Dopo che un parametro è stato modificato, il file creare il comando deve essere eseguito per creare nuovamente il progetto. Se hai modificato i valori dei parametri nelle istanze del modulo in modalità online, puoi utilizzare il file Valori dei parametri diversi comando per ottenere un elenco dei parametri modificati nel file Messaggi visualizzazione. Facendo doppio clic su questo tipo di messaggio si apre la finestra di dialogo dei parametri per l'istanza del modulo interessata in cui i valori dei parametri modificati sono indicati da una cornice rossa. " }, 
{ "title" : "Informazione ", 
"url" : "ac_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Informazione ", 
"snippet" : "Questa finestra di dialogo delle informazioni visualizza i dettagli su Icona , Nome , Descrizione , Fonte , Versione , Fornitore , E Categoria dell'istanza del modulo. Opzionalmente possono essere visualizzati anche più collegamenti. Facendo clic sui collegamenti si apre la rispettiva applicazione. ...", 
"body" : "Questa finestra di dialogo delle informazioni visualizza i dettagli su Icona , Nome , Descrizione , Fonte , Versione , Fornitore , E Categoria dell'istanza del modulo. Opzionalmente possono essere visualizzati anche più collegamenti. Facendo clic sui collegamenti si apre la rispettiva applicazione. Il contenuto del primo URL viene visualizzato sul lato destro. Affinché i collegamenti vengano visualizzati qui, devono essere definiti nel file MetaData sezione della dichiarazione del modulo. I domini e i siti attendibili sono definiti nell'Applicazione Opzioni del compositore . Se si fa clic su un URL che non è definito come \"attendibile\", nella vista destra si apre una finestra di dialogo. In questa visualizzazione è quindi possibile aggiungere l'URL ai domini o ai siti attendibili. " }, 
{ "title" : "SourceTemplate ", 
"url" : "ac_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ SourceTemplate ", 
"snippet" : "Questa finestra di dialogo definisce quali blocchi funzione dal pool POU vengono copiati nell'applicazione quando il file creare il comando viene eseguito. Per copiare i blocchi funzione, il generatore SourceTemplate deve essere abilitato nel file Configurazione del generatore . La finestra di dialo...", 
"body" : "Questa finestra di dialogo definisce quali blocchi funzione dal pool POU vengono copiati nell'applicazione quando il file creare il comando viene eseguito. Per copiare i blocchi funzione, il generatore SourceTemplate deve essere abilitato nel file Configurazione del generatore . La finestra di dialogo visualizza tutti i blocchi funzione definiti nel file SourceTemplate sezione della dichiarazione del modulo. Fonte-FB : Identificatore dei blocchi funzione da copiare È copiare : TRUE\/FALSE: il blocco funzione viene copiato o non copiato. Se la IsMandatory il parametro è definito come TRUE nella dichiarazione del modulo, il valore non può essere modificato qui. Tipo di FB di origine : Nome del blocco funzione da copiare " }, 
{ "title" : "Editore: ExportDevices ", 
"url" : "ac_export_devices.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Editore: ExportDevices ", 
"snippet" : "Con questo editor è possibile selezionare un file generato dall'esportazione di un dispositivo. Questo dispositivo viene aggiunto all'albero dei dispositivi quando viene generato il progetto. Questo opzione di configurazione è richiesto quando vengono aggiunti dispositivi con proprietà speciali e qu...", 
"body" : "Con questo editor è possibile selezionare un file generato dall'esportazione di un dispositivo. Questo dispositivo viene aggiunto all'albero dei dispositivi quando viene generato il progetto. Questo opzione di configurazione è richiesto quando vengono aggiunti dispositivi con proprietà speciali e quando i dispositivi non possono essere aggiunti dal generatore di dispositivi. Identificatore : Identificatore dalla dichiarazione del modulo File esportato : Selezione di tutti i file definiti nella dichiarazione del modulo Se nella dichiarazione del modulo è definito un solo file, questo file non verrà visualizzato qui. Possono esistere più ExportDevices per ciascun dispositivo. Questi si differenziano per i loro identificatori dalla dichiarazione del modulo e vengono visualizzati qui. " }, 
{ "title" : "Finestra di dialogo: Opzioni: Compositore ", 
"url" : "ac_options.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Finestra di dialogo: Opzioni: Compositore ", 
"snippet" : "Questa finestra di dialogo secondaria del CODESYS La finestra di dialogo delle opzioni fornisce diverse schede per CODESYS Application Composer impostazioni....", 
"body" : "Questa finestra di dialogo secondaria del CODESYS La finestra di dialogo delle opzioni fornisce diverse schede per CODESYS Application Composer impostazioni. " }, 
{ "title" : "Scheda: Generale ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_71025f62d62f3d9cc0a8640e01589d60", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Finestra di dialogo: Opzioni: Compositore \/ Scheda: Generale ", 
"snippet" : "Generale Mostra la selezione di primo livello prima della generazione : è possibile fare clic Compositore → Genera per aprire una finestra di dialogo per la selezione dei moduli di primo livello. È possibile ridurre il tempo necessario per generare l'applicazione deselezionando i moduli che non camb...", 
"body" : "Generale Mostra la selezione di primo livello prima della generazione : è possibile fare clic Compositore → Genera per aprire una finestra di dialogo per la selezione dei moduli di primo livello. È possibile ridurre il tempo necessario per generare l'applicazione deselezionando i moduli che non cambiano più. Editori Tipo di editor dei parametri Visualizzazione del Parametri sul Parametri scheda (editor del modulo). Visualizzazione ad albero : I gruppi di parametri vengono visualizzati nell'editor come struttura ad albero. Visualizzazione a schede : I gruppi di parametri vengono visualizzati nell'editor come singole schede. Scansione Scansione automatica (salvata con il progetto) : IL CODESYS Application Composer cerca automaticamente i moduli esistenti e le istanze dei moduli quando una nuova libreria viene inserita nella vista POU. : IL CODESYS Application Composer cerca i moduli esistenti e le istanze dei moduli solo nei seguenti casi: Dopo aver aperto il progetto Dopo aver inserito un'istanza del modulo nell'albero dei moduli se non è stata eseguita una ricerca Nota: questa impostazione viene salvata con il progetto. Domini attendibili Siti Web affidabili Gli URL in questo elenco possono essere visualizzati sul file Informazione scheda dell'editor del modulo. Requisito: l'URL è definito nella sezione MetaData della dichiarazione del modulo. " }, 
{ "title" : "Scheda: editor di sequenze ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_70cecd07d62f3d9fc0a8640e00b85eda", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Finestra di dialogo: Opzioni: Compositore \/ Scheda: editor di sequenze ", 
"snippet" : "Generale Mostra riferimenti Mostra parametri Mostra la mappatura I\/O Mostra i nomi delle istanze Mostra commento Mostra variabili online : Il rispettivo elemento viene mostrato nel passo del editor di sequenze . Schermo Larghezza del gradino : larghezza dell'intestazione della scheda (in pixel) Valo...", 
"body" : "Generale Mostra riferimenti Mostra parametri Mostra la mappatura I\/O Mostra i nomi delle istanze Mostra commento Mostra variabili online : Il rispettivo elemento viene mostrato nel passo del editor di sequenze . Schermo Larghezza del gradino : larghezza dell'intestazione della scheda (in pixel) Valori validi: 25–500. Distanza del passo (vert.) Distanza tra i passaggi della sequenza (in pixel) Valori validi: 10–100 St. connessione Una connessione Collegamento B Colori delle linee di collegamento tra i passaggi della sequenza I colori di Una connessione E Collegamento B vengono utilizzati dopo una fase di diramazione. Testi Parametri Riferimenti Canali di I\/O Colori per la visualizzazione di testo, parametri, riferimenti e canali I\/O Carattere del testo Il pulsante apre la finestra di dialogo predefinita per l'impostazione del carattere per il testo nell'editor. Carattere di collegamento Il pulsante apre la finestra di dialogo predefinita per l'impostazione del carattere per l'etichettatura dei collegamenti. " }, 
{ "title" : "Redattore di sequenze ", 
"url" : "ac_sequenceeditor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Redattore di sequenze ", 
"snippet" : "L'editor di sequenze è un editor grafico che visualizza e modifica i file albero dei moduli in un diagramma di flusso. Permette di aggiungere ed eliminare moduli o di modificarne le proprietà. L'editor fornisce anche una modalità online, che deve essere utilizzata per tenere traccia dei passaggi del...", 
"body" : "L'editor di sequenze è un editor grafico che visualizza e modifica i file albero dei moduli in un diagramma di flusso. Permette di aggiungere ed eliminare moduli o di modificarne le proprietà. L'editor fornisce anche una modalità online, che deve essere utilizzata per tenere traccia dei passaggi del modulo attivo e dei punti di interruzione del modulo, in modo che possa essere utilizzato per il debug. Il flusso della sequenza stesso (esecuzione e ordine delle sequenze) non è implementato dall'editor. Viene utilizzato solo per visualizzare e modificare l'albero dei moduli. Qualsiasi funzionalità o logica dei passi del modulo deve essere implementata nei blocchi funzione dei moduli come IEC ( CODESYS ) codice del programma Redattore di sequenze L'editor è disponibile per tutti i moduli con la definizione Radice nella sezione mse.Sequence della dichiarazione del modulo. Il contenuto dell'editor corrisponde all'albero dei moduli. Ogni modifica nell'albero dei moduli cambierà l'editor di sequenza e viceversa. Verranno visualizzate solo le istanze del modulo inserite sotto un \" Root \". Il contenuto visualizzato è definito dalle definizioni nella sezione mse.Sequence della loro dichiarazione di modulo. L'aspetto dei passaggi dipende dalla definizione nella dichiarazione del modulo. Oltre alla definizione Root esistono le seguenti tre definizioni: Fare un passo: Parallelo: Ramo: " }, 
{ "title" : "Dati visualizzati nella casella della sequenza ", 
"url" : "ac_sequenceeditor.html#UUID-c7b42e58-c2ec-c00e-5692-55a5d60221bd_d125a077ca9f50ac0a8640e01732ee5_id_ad20551e9b6d77a9c0a865200163ff8b", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Redattore di sequenze \/ Dati visualizzati nella casella della sequenza ", 
"snippet" : "All'interno della casella di ogni passo verranno visualizzati il nome del tipo di modulo e il nome dell'istanza del modulo (opzionale) e l'icona definita. Quest'ultima corrisponde all'icona definita nei metadati del configurazione del modulo . Verranno visualizzati anche i parametri e i canali I\/O d...", 
"body" : "All'interno della casella di ogni passo verranno visualizzati il nome del tipo di modulo e il nome dell'istanza del modulo (opzionale) e l'icona definita. Quest'ultima corrisponde all'icona definita nei metadati del configurazione del modulo . Verranno visualizzati anche i parametri e i canali I\/O dell'istanza del modulo, se definiti nella sezione mse.Sequence . Lo stesso vale per i riferimenti, anche se si distinguono due diversi tipi di riferimenti: Riferimenti generali alle istanze dei moduli Riferimenti di salto, che definiscono un salto all'interno della sequenza. Le istanze del modulo a cui si fa riferimento verranno visualizzate con il relativo percorso nell'albero del modulo (esempio: ..\/..\/WaitTime ). Il verificarsi ..\/ sono scritti in notazione abbreviata (esempio: .\/..\/..\/ diventa 3x[..\/] ). Ad ogni passaggio è possibile aggiungere un commento, che verrà visualizzato separato da una riga. Questo viene salvato separatamente per ogni passaggio (istanza del modulo). Se il testo visualizzato dei nomi dei moduli, dei parametri, dei canali IO o dei riferimenti non rientra nello spazio indicato all'interno del passaggio, il testo verrà spostato su una seconda riga. Se necessario, il testo verrà tagliato. In questo caso, a … sarà aggiunto. In sintesi, per un passo della sequenza è possibile definire fino a un massimo di quattro elenchi\/voci aggiuntivi: Parametri: nome del parametro + valore del parametro Canali I\/O: nome del canale + nome del canale di destinazione Riferimenti: icona, percorso e nome dell'istanza del modulo di riferimento Per i riferimenti ai salti: >> + icona, percorso e nome dell'istanza del modulo di riferimento Commenti: linea orizzontale + commento Per ulteriori informazioni sull'editor di sequenze, consultare i capitoli della guida Lavorare nell'editor di sequenze E Editor di sequenze in modalità online " }, 
{ "title" : "Lavorare con l'editor di sequenze ", 
"url" : "ac_sequenceeditor_edit.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Redattore di sequenze \/ Lavorare con l'editor di sequenze ", 
"snippet" : "Quando il puntatore del mouse viene spostato su un passaggio, questo viene evidenziato in grigio. Quando il puntatore viene spostato sull'estremità vuota di una connessione, viene visualizzato un triangolo grigio. I passaggi possono essere selezionati facendo clic per cambiare il colore del passaggi...", 
"body" : "Quando il puntatore del mouse viene spostato su un passaggio, questo viene evidenziato in grigio. Quando il puntatore viene spostato sull'estremità vuota di una connessione, viene visualizzato un triangolo grigio. I passaggi possono essere selezionati facendo clic per cambiare il colore del passaggio selezionato in rosso. E' possibile anche la selezione multipla dei passi. I passaggi possono essere spostati trascinandoli. Quando il Ctrl viene premuto anche il tasto , i passaggi vengono copiati. Le possibili posizioni di inserimento per i passaggi spostati o copiati sono contrassegnate da una linea tratteggiata rossa. Sposta gli elementi trascinandoli Se si sposta il puntatore del mouse su un elemento di salto la cui destinazione è disponibile nella sequenza attuale, anche il campo di testo del riferimento di salto viene collegato tramite una linea tratteggiata al passo di destinazione indicato. Anche il bersaglio è contrassegnato da un cerchio tratteggiato. Destinazione di salto di un riferimento di salto Modifica con canali I\/O Un doppio clic sul canale I\/O apre la finestra di dialogo di mappatura I\/O, che viene utilizzata anche nell'editor I\/O delle istanze del modulo. Per ulteriori informazioni, vedere: I\/O " }, 
{ "title" : "Comandi dell'editor di sequenze ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_00bbee939046545bc0a8652000fd02ce", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Redattore di sequenze \/ Lavorare con l'editor di sequenze \/ Comandi dell'editor di sequenze ", 
"snippet" : "Un clic con il tasto destro su un passo della sequenza o sul triangolo grigio (passo parallelo vuoto del ramo) fornisce i comandi del menu contestuale disponibili in questa posizione. Oltre alla norma Taglio , copia , E Impasto comandi, il menu fornisce i seguenti comandi: Aggiungi Passo dopo Tutti ...", 
"body" : "Un clic con il tasto destro su un passo della sequenza o sul triangolo grigio (passo parallelo vuoto del ramo) fornisce i comandi del menu contestuale disponibili in questa posizione. Oltre alla norma Taglio , copia , E Impasto comandi, il menu fornisce i seguenti comandi: Aggiungi Passo dopo Tutti i passaggi successivi vengono visualizzati in un comando list. Di conseguenza, vengono aggiunti solo i gradini e i moduli che sarebbero adatti allo slot del modulo in questa posizione. Aggiungi passaggio dopo sottosequenze chiuse Questo comando può essere utilizzato quando è necessario chiudere sottosequenze di rami e sequenze parallele. Il passo inserito viene aggiunto dopo le sottosequenze e non al loro interno. È disponibile solo per le posizioni che hanno sottosequenze chiudibili. Aggiungi un commento Aggiunge un commento al passaggio selezionato. Imposta il riferimento di salto Questo comando è disponibile solo nel menu contestuale di un elemento di salto. È possibile utilizzare il mouse per tracciare una linea rossa sul passaggio di destinazione. Il menu contestuale degli elementi della sequenza selezionati può essere aperto anche con il barra spaziatrice . Menu contestuale di un ramo I passaggi consecutivi sono collegati da frecce. Per l'elemento ramo è possibile definire colori diversi per i due rami. Per ulteriori informazioni, vedere: mse.Sequenza. I colori sono definiti nel CODESYS opzioni ( Redattore di sequenze ). " }, 
{ "title" : "Modificare la posizione sui passaggi della sequenza ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_74415e1a90465440c0a865200120cb10", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Redattore di sequenze \/ Lavorare con l'editor di sequenze \/ Modificare la posizione sui passaggi della sequenza ", 
"snippet" : "Per modificare la posizione di un elemento della sequenza è necessario selezionare e trascinare l'elemento utilizzando il tasto centrale del mouse. È inoltre possibile modificare la disposizione dei parametri all'interno del passo. Modificare la posizione di un passaggio della sequenza Di conseguenz...", 
"body" : "Per modificare la posizione di un elemento della sequenza è necessario selezionare e trascinare l'elemento utilizzando il tasto centrale del mouse. È inoltre possibile modificare la disposizione dei parametri all'interno del passo. Modificare la posizione di un passaggio della sequenza Di conseguenza nell'editor è possibile spostare solo la posizione dell'elemento – non è possibile modificare la posizione all'interno di una sequenza e quindi l'ordine. " }, 
{ "title" : "Modifica parametri\/commenti\/nome istanza\/canali I\/O ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_a585f36190465431c0a8652000ac8cda", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Redattore di sequenze \/ Lavorare con l'editor di sequenze \/ Modifica parametri\/commenti\/nome istanza\/canali I\/O ", 
"snippet" : "Per cambiare a parametro , è necessario fare doppio clic. A seconda del tipo di dati della variabile è possibile modificare il campo oppure selezionare il valore della variabile da una casella di riepilogo (esempio: TRUE O FALSE ). I commenti o i nomi delle istanze possono essere modificati anche fa...", 
"body" : "Per cambiare a parametro , è necessario fare doppio clic. A seconda del tipo di dati della variabile è possibile modificare il campo oppure selezionare il valore della variabile da una casella di riepilogo (esempio: TRUE O FALSE ). I commenti o i nomi delle istanze possono essere modificati anche facendo doppio clic. " }, 
{ "title" : "Modifica dei riferimenti ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_939c29699046541bc0a865200038e978", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Redattore di sequenze \/ Lavorare con l'editor di sequenze \/ Modifica dei riferimenti ", 
"snippet" : "Un riferimento può essere modificato facendo clic con il pulsante destro del mouse. Il menu contestuale fornisce un elenco di riferimenti che possono essere inseriti in questa posizione. Imposta riferimenti In caso di riferimento al salto, il menu contestuale fornisce il Imposta il riferimento di sa...", 
"body" : "Un riferimento può essere modificato facendo clic con il pulsante destro del mouse. Il menu contestuale fornisce un elenco di riferimenti che possono essere inseriti in questa posizione. Imposta riferimenti In caso di riferimento al salto, il menu contestuale fornisce il Imposta il riferimento di salto comando. L'esecuzione di questo comando consente di impostare la destinazione del salto utilizzando il mouse. Sul bersaglio viene tracciata una linea rossa tratteggiata, che può essere impostata facendo clic su di essa. Un riferimento di salto esistente può essere cancellato con il Eliminare dal menu contestuale. Imposta il riferimento di salto " }, 
{ "title" : "Editor di sequenze in modalità online ", 
"url" : "ac_sequenceeditor_onlinemode.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Redattore di sequenze \/ Editor di sequenze in modalità online ", 
"snippet" : "Dopo che l'applicazione ha effettuato l'accesso, l'editor di sequenze passa alla modalità online. L'aspetto dei passi del modulo in modalità online è molto simile alla modalità offline. Vengono visualizzati tutti i passaggi, ma non possono essere selezionati o modificati come nella modalità offline....", 
"body" : "Dopo che l'applicazione ha effettuato l'accesso, l'editor di sequenze passa alla modalità online. L'aspetto dei passi del modulo in modalità online è molto simile alla modalità offline. Vengono visualizzati tutti i passaggi, ma non possono essere selezionati o modificati come nella modalità offline. Questa modalità offre anche la possibilità di visualizzare valori variabili all'interno di un passo. Comandi in modalità online In modalità online, l'editor di sequenze offre due comandi aggiuntivi nel file Compositore menù: Breakpoint attivi al passaggio successivo Centra la vista sui punti di interruzione " }, 
{ "title" : "Passo attivo ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e0ed25b7911507a5c0a8640e003e283b", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Redattore di sequenze \/ Editor di sequenze in modalità online \/ Passo attivo ", 
"snippet" : "Se correttamente dichiarato nel dichiarazione del modulo , il passaggio attivo verrà visualizzato in giallo: Modalità online – Passo attivo...", 
"body" : "Se correttamente dichiarato nel dichiarazione del modulo , il passaggio attivo verrà visualizzato in giallo: Modalità online – Passo attivo " }, 
{ "title" : "Punti di interruzione ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e06ef3f19ba07a7bc0a8652001bdb8af", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Redattore di sequenze \/ Editor di sequenze in modalità online \/ Punti di interruzione ", 
"snippet" : "Se dichiarato correttamente nella dichiarazione del modulo, l'editor consente di impostare dei punti di interruzione. Il punto di interruzione di un passo può essere impostato\/reimpostato da Attiva\/disattiva punto di interruzione comando dal menu contestuale del passo. Un punto di interruzione attiv...", 
"body" : "Se dichiarato correttamente nella dichiarazione del modulo, l'editor consente di impostare dei punti di interruzione. Il punto di interruzione di un passo può essere impostato\/reimpostato da Attiva\/disattiva punto di interruzione comando dal menu contestuale del passo. Un punto di interruzione attivato è indicato da un bordo rosso. Se il punto di interruzione è attivo (la sequenza si interrompe sul punto di interruzione), il passaggio verrà visualizzato in rosso. Modalità online – Punti di interruzione Per ulteriori informazioni, vedere: mse.Sequenza" }, 
{ "title" : "Editor del modulo di estensione ", 
"url" : "ac_editor_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Editor del modulo di estensione ", 
"snippet" : "L'editor dei moduli di estensione serve a definire le estensioni e fornire le quattro Metadati , Parametro, I\/O, E HMI schede. L'editor può essere aperto con un doppio clic sul blocco funzione nel file POU pool (nella directory in base al nome dell'estensione). Gestione degli errori In caso di error...", 
"body" : "L'editor dei moduli di estensione serve a definire le estensioni e fornire le quattro Metadati , Parametro, I\/O, E HMI schede. L'editor può essere aperto con un doppio clic sul blocco funzione nel file POU pool (nella directory in base al nome dell'estensione). Gestione degli errori In caso di errori fatali che impediscono la visualizzazione degli editor, i messaggi di errore verranno visualizzati sul Metadati pagina. Le pagine dell'editor sono disabilitate in modo che non possano reagire a nessun input. Un esempio di questo tipo di errore è la mancanza di un blocco funzione del modulo. " }, 
{ "title" : "Cambia eventi ", 
"url" : "ac_editor_extension_module.html#UUID-91f9cff1-6f9e-ea6b-b3cd-d65abac7523b_ef0072b48b6aa7c0a8640e00080c11_id_4681e6c5b4a5a074c0a8640e01e5e429", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Editor del modulo di estensione \/ Cambia eventi ", 
"snippet" : "Il contenuto degli editor viene aggiornato automaticamente se cambia il blocco funzione, l'elenco di testi, il pool di immagini o la visualizzazione corrispondente. (Gli oggetti menzionati verranno considerati \"corrispondenti\" se si trovano nella stessa cartella del modulo di estensione.)...", 
"body" : "Il contenuto degli editor viene aggiornato automaticamente se cambia il blocco funzione, l'elenco di testi, il pool di immagini o la visualizzazione corrispondente. (Gli oggetti menzionati verranno considerati \"corrispondenti\" se si trovano nella stessa cartella del modulo di estensione.) " }, 
{ "title" : "Metadati ", 
"url" : "ac_metadata_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Editor del modulo di estensione \/ Metadati ", 
"snippet" : "In questa scheda del Editor del modulo di estensione , vengono visualizzate la descrizione e la categoria. I testi visualizzati (tranne la categoria) vengono letti da un elenco di testi. A questo scopo viene utilizzato il linguaggio attualmente utilizzato del sistema di programmazione. Se non è disp...", 
"body" : "In questa scheda del Editor del modulo di estensione , vengono visualizzate la descrizione e la categoria. I testi visualizzati (tranne la categoria) vengono letti da un elenco di testi. A questo scopo viene utilizzato il linguaggio attualmente utilizzato del sistema di programmazione. Se non è disponibile testo in questa lingua, verrà utilizzato il testo predefinito. Se non è stato inserito alcun testo, non verrà visualizzato alcun testo. Come l'elenco dei testi, le immagini vengono lette dal pool di immagini. Finestra di dialogo del modulo di estensione Metadati I pulsanti a destra dei valori visualizzati aprono la riga corrispondente nell'elenco dei testi o nel pool di immagini e consentono quindi la modifica dei testi. Se non è presente testo\/immagine con l'ID corrispondente, verrà creato un nuovo elemento con questo ID. " }, 
{ "title" : "Parametro ", 
"url" : "ac_parameters_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Editor del modulo di estensione \/ Parametro ", 
"snippet" : "Nella scheda del editor del modulo di estensione , i parametri del modulo di estensione sono elencati in una tabella. Finestra di dialogo del modulo di estensione: Parametro IL Id , Variabile , Tipo , E Predefinito le colonne sono di sola lettura. Nel Nome E Descrizione colonne, puoi fare clic sulla...", 
"body" : "Nella scheda del editor del modulo di estensione , i parametri del modulo di estensione sono elencati in una tabella. Finestra di dialogo del modulo di estensione: Parametro IL Id , Variabile , Tipo , E Predefinito le colonne sono di sola lettura. Nel Nome E Descrizione colonne, puoi fare clic sulla riga corrispondente (quando è già selezionata) o su barra spaziatrice per passare direttamente alla riga corrispondente del rispettivo elenco di testi. Il testo visualizzato viene letto dall'elenco testi nella lingua attualmente impostata nel sistema di programmazione. Se questa lingua non è presente nell'elenco dei testi, verrà utilizzato il testo predefinito per la voce. Nella colonna Predefinito verrà visualizzato il valore di inizializzazione del parametro. Questa tabella supporta la selezione multipla di voci e la gestione standard con mouse e tastiera. Tutte le azioni che modificano i parametri possono essere annullate o ripristinate tramite lo standard Disfare E Rifare comandi. IL Taglio , copia , E Impasto le funzioni non sono supportate. È possibile utilizzare i pulsanti freccia o il Alt + ↑ E Alt + ↓ scorciatoie per spostare il parametro selezionato verso l'alto o verso il basso per modificare l'ordine. È possibile utilizzare il pulsante con il X o la norma Del comando per rimuovere i parametri selezionati. Eventuali errori o avvisi relativi ai parametri verranno visualizzati nella parte inferiore dell'elenco dei messaggi. Se viene selezionato un messaggio, il parametro corrispondente verrà selezionato nell'elenco dei parametri sopra. Il pulsante con l'asterisco o il Alt + N la scorciatoia (se la tabella ha il focus) può essere utilizzata per aprire il file Nuovo parametro dialogo: Finestra di dialogo del modulo di estensione: Nuovo parametro Nella parte superiore della finestra di dialogo viene visualizzata una tabella gerarchica con tutte le variabili compatibili del blocco funzione. Per attivare il OK pulsante è necessario selezionare una variabile e un nome univoco Id deve essere inserito. Se la Id non è univoco, viene aggiunto un punto esclamativo rosso con il testo dell'errore. Nei campi Nome E Descrizione è possibile inserire il testo standard che verrà memorizzato nella lista testi associata. Successivamente occorre aggiungere all'elenco dei testi i testi per le singole lingue. Una variabile viene visualizzata se si tratta di una variabile di ingresso di un modulo funzionale o di una variabile locale di una struttura. Una variabile può essere selezionata se ha un tipo primitivo. " }, 
{ "title" : "I\/O ", 
"url" : "ac_io_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Editor del modulo di estensione \/ I\/O ", 
"snippet" : "Questa scheda del editor del modulo di estensione e la finestra di dialogo per la creazione di nuovi I\/O si comportano in modo simile a Parametri scheda. Invece della colonna Predefinito la direzione Dentro fuori dell'ingresso\/uscita viene visualizzato. Finestra di dialogo del modulo di estensione: ...", 
"body" : "Questa scheda del editor del modulo di estensione e la finestra di dialogo per la creazione di nuovi I\/O si comportano in modo simile a Parametri scheda. Invece della colonna Predefinito la direzione Dentro fuori dell'ingresso\/uscita viene visualizzato. Finestra di dialogo del modulo di estensione: I\/O " }, 
{ "title" : "HMI ", 
"url" : "ac_hmi_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Editor del modulo di estensione \/ HMI ", 
"snippet" : "Questa scheda del editor del modulo di estensione consente di definire il visualizzazioni di pagine così come il visualizzazioni incorporate . Entrambi i campi di testo consentono la definizione di più nomi di visualizzazione, separati da virgola. Finestra di dialogo del modulo di estensione: HMI...", 
"body" : "Questa scheda del editor del modulo di estensione consente di definire il visualizzazioni di pagine così come il visualizzazioni incorporate . Entrambi i campi di testo consentono la definizione di più nomi di visualizzazione, separati da virgola. Finestra di dialogo del modulo di estensione: HMI " }, 
{ "title" : "Schermate di visualizzazione ", 
"url" : "f_application_composer_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Schermate di visualizzazione ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Modelli di primo livello ", 
"url" : "ac_toplevel_templates.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Schermate di visualizzazione \/ Modelli di primo livello ", 
"snippet" : "Un modello di primo livello è un modello per la pagina iniziale della visualizzazione generata. Contiene una cornice come segnaposto per le pagine e le schede specifiche dell'utente per passare alle diverse pagine. Facoltativamente sono presenti pulsanti per navigare tra le pagine e una riga di stat...", 
"body" : "Un modello di primo livello è un modello per la pagina iniziale della visualizzazione generata. Contiene una cornice come segnaposto per le pagine e le schede specifiche dell'utente per passare alle diverse pagine. Facoltativamente sono presenti pulsanti per navigare tra le pagine e una riga di stato e indirizzo. Il modello di primo livello può essere selezionato nelle impostazioni del Generatore di visualizzazioni . IL AC_ModuleBase libreria che fa parte dell'installazione standard di CODESYS Application Composer contiene tre modelli di primo livello: AC.GenVisu_Toplevel_Template , AC.Toplevel_Vertical_Template e AC.Toplevel_3S_Vertical_Template . Modelli standard di primo livello Modello di primo livello: AC_Toplevel_3S_Vertical_Template Oltre ai modelli preparati è anche possibile creare modelli di primo livello definiti dall'utente. Elementi dei template di primo livello (1): Navigazione: Su \/ Indietro \/ Avanti (2): cornice per visualizzare le pagine (3): Scheda per la navigazione diretta alle pagine di primo livello (4): riga di stato (5): Riga dell'indirizzo: percorso dell'istanza del modulo visualizzato Gli elementi del modello di visualizzazione sono identificati dai relativi nomi di elemento. Nell'elenco sottostante il nome degli elementi è scritto tra parentesi. Elementi obbligatori del modello [Frame] : Frame principale in cui sono visualizzate le pagine di visualizzazione. Per ottenere i migliori risultati, il tipo di scala del fotogramma dovrebbe essere impostato su \"isotropico\". [Tab_Template_1] , [Tab_Template_2] : due elementi utilizzati per l'aspetto e la disposizione di tutte le schede. Tab_Template_1 definisce la posizione della prima scheda e l'aspetto di tutte le schede. Dalla posizione di Tab_Template_2 verrà calcolata la disposizione delle schede (orizzontale o verticale) e lo spazio tra le schede. Il colore dell'allarme verrà impostato se la gerarchia della pagina visualizzata è al di sotto dell'istanza rappresentata dalla scheda. Se l'elemento è un pulsante, verrà impostata anche la variabile di stato del pulsante. Se l'elemento è una cornice il colore dell'allarme non verrà utilizzato. Invece di ciò, la variabile switch frame sarà impostata su \"1\", se la scheda è selezionata (default 0). Elementi facoltativi del modello [Up] , [Back] , [Forward] : Elementi per la navigazione che possono essere un pulsante o una cornice. Il tipo di elemento può essere un pulsante o una cornice. Nel caso di un frame, il frame deve contenere tre visualizzazioni che devono essere nel seguente ordine: Neutro, Premuto, Disattivato. [Address] : Campo di testo che restituisce il percorso dell'istanza del modulo visualizzato. [Status] : Campo di testo che visualizza il contenuto della variabile stringa globale ac.g_stVisuStatusBar dalla libreria AC_ModuleBase. Questa variabile può essere utilizzata nelle implementazioni del proprio modulo per visualizzare lo stato di una variabile. Tutti gli altri elementi non vengono gestiti in modo specifico dal generatore di visualizzazione. Per la generazione, la visualizzazione del modello copia e modifica la copia. L'originale non è cambiato. Ad eccezione degli elementi di visualizzazione sopra menzionati, il generatore di visualizzazione cerca di non modificare nessun elemento che è stato modificato manualmente. Alla prima generazione della visualizzazione, viene copiato il modello di visualizzazione descritto. Questa copia, finché non viene eliminata dall'utente, verrà modificata solo nelle generazioni successive e non ricopiata. Ciò avviene trattando una visualizzazione di primo livello di un'esecuzione precedente del generatore come se fosse un nuovo modello di visualizzazione (il modello originale non verrà mai modificato), sebbene non venga copiato. Pertanto, se sono presenti schede aggiuntive, queste verranno aggiunte a quelle già esistenti. Tutte le altre proprietà ed elementi non verranno toccati, se possibile, in modo che i pulsanti, le schede, ecc. aggiunti manualmente dall'utente mantengano la loro posizione. L'eliminazione, ad esempio, dei pulsanti di navigazione ne comporta la perdita. Per generarli, la visu di livello superiore deve essere eliminata e rigenerata " }, 
{ "title" : "Allineamento delle linguette ", 
"url" : "ac_toplevel_templates.html#UUID-b04a5efa-11da-0879-903b-e5e3a3f27499_ac_toplevel_templates0", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Schermate di visualizzazione \/ Modelli di primo livello \/ Allineamento delle linguette ", 
"snippet" : "Le schede verranno allineate orizzontalmente da sinistra a destra o verticalmente dall'alto verso il basso. La posizione relativa dell'elemento del modello Tab_Template_1 E Tab_Template_2 definisce l'allineamento: Se la distanza verticale degli elementi è maggiore della distanza orizzontale, gli ele...", 
"body" : "Le schede verranno allineate orizzontalmente da sinistra a destra o verticalmente dall'alto verso il basso. La posizione relativa dell'elemento del modello Tab_Template_1 E Tab_Template_2 definisce l'allineamento: Se la distanza verticale degli elementi è maggiore della distanza orizzontale, gli elementi verranno allineati orizzontalmente, altrimenti verticalmente. In caso di allineamento verticale, tutte le schede ottengono la stessa larghezza, che è la larghezza minima alla quale possono essere visualizzati tutti i nomi delle schede. Nel caso di un allineamento orizzontale, ogni scheda ottiene la larghezza minima che può visualizzare il suo nome. In entrambi i casi l'altezza delle linguette sarà impostata all'altezza del primo modello ( Tab_Template_1 ). Per il posizionamento viene copiato il primo modello e adattato per ogni scheda. Il posizionamento inizia dalla posizione del primo modello: la distanza tra due schede risulta dalla distanza orizzontale o verticale tra i due modelli. Questa distanza può essere anche negativa, in tal caso la scheda successiva si sovrappone alla precedente e la dipinge sopra perché è più avanti. Nel caso dell'allineamento verticale, la generazione viene interrotta con un errore se verso il basso non c'è abbastanza spazio per accogliere tutte le schede. Non viene creata alcuna seconda colonna di schede. In caso di allineamento orizzontale, verrà creata una nuova riga se la scheda successiva non si adatta più orizzontalmente alla visualizzazione. Se ciò accade per la prima tabulazione di una riga, la generazione viene interrotta con un errore. Può succedere che non ci sia abbastanza spazio per la scheda. Nel caso dell'allineamento orizzontale, ciò avviene quando si passa a una nuova riga. Quando sono allineate verticalmente, ciò accade quando la larghezza delle schede è maggiore dello spazio previsto nel modello. In questi casi si cerca di creare più spazio. A causa di questo allineamento automatico degli elementi ci sono quattro casi possibili per disporre le schede: Allineamento orizzontale delle schede: tutte le schede devono essere completamente sopra la cornice Allineamento orizzontale delle schede: tutte le schede devono essere completamente sotto la cornice Allineamento verticale delle linguette: tutte le linguette devono trovarsi completamente sul lato sinistro del telaio Allineamento verticale delle schede: tutte le schede devono trovarsi completamente sul lato destro del telaio Se l'allineamento delle schede non corrisponde alla restrizione di cui sopra verrà creato un messaggio di errore. Se non c'è abbastanza spazio per le schede, la cornice viene ridotta di conseguenza. Tutti gli elementi tra le schede e la cornice vengono spostati. La posizione di un elemento viene interpretata come \"tra schede e cornice\" se non è completamente al di fuori del limite esterno del primo modello di scheda (vedi esempi di disposizione orizzontale di seguito). La creazione della visualizzazione verrà interrotta se la modifica della dimensione del frame portasse a valori negativi. Esempio di elementi tra tabulazioni e frame Esempio per elementi \"esterni\" di schede e frame " }, 
{ "title" : "Generazione di schermate di visualizzazione ", 
"url" : "ac_generating_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Schermate di visualizzazione \/ Generazione di schermate di visualizzazione ", 
"snippet" : "Per le schermate di visualizzazione nell'Application Composer tutti gli elementi di CODESYS V3 così come è possibile utilizzare le schermate di visualizzazione integrate. Inoltre è possibile utilizzare elementi visu (esempio: rettangolo), contrassegnati come segnaposto speciali: Navigazione all'inte...", 
"body" : "Per le schermate di visualizzazione nell'Application Composer tutti gli elementi di CODESYS V3 così come è possibile utilizzare le schermate di visualizzazione integrate. Inoltre è possibile utilizzare elementi visu (esempio: rettangolo), contrassegnati come segnaposto speciali: Navigazione all'interno della visualizzazione La navigazione all'interno della visualizzazione può essere effettuata utilizzando le schede o il file Indietro , Su , E Inoltrare pulsanti di navigazione. Facendo clic con il mouse sugli elementi della scheda si passa direttamente alle schermate di visualizzazione corrispondenti. IL Indietro E Inoltrare i pulsanti permettono di navigare all'interno della cronologia delle schermate visualizzate (analogamente alla navigazione nei browser Internet). IL Su Il pulsante passa al livello successivo superiore. " }, 
{ "title" : "Elementi segnaposto nelle schermate di visualizzazione ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_1d3a1d9285970a30c0a8640e01de1c5b", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Schermate di visualizzazione \/ Generazione di schermate di visualizzazione \/ Elementi segnaposto nelle schermate di visualizzazione ", 
"snippet" : "Gli elementi di visualizzazione standard (ad esempio: rettangoli, immagini) possono essere utilizzati come elementi segnaposto. Durante la generazione della visualizzazione, le visualizzazioni incorporate assegnate verranno disposte in base alla posizione del segnaposto (posizione e dimensione). Spe...", 
"body" : "Gli elementi di visualizzazione standard (ad esempio: rettangoli, immagini) possono essere utilizzati come elementi segnaposto. Durante la generazione della visualizzazione, le visualizzazioni incorporate assegnate verranno disposte in base alla posizione del segnaposto (posizione e dimensione). Specifica La definizione degli elementi segnaposto viene effettuata tramite il nome di istanza dell'elemento. Il nome dell'elemento deve essere PLACEHOLDER_<SUBPATH> . Sintassi di <SUBPATH> : <SUBPATH> ::= <SLOTREF> | <SLOTREF>:<SUBPATH> <SLOTREF> ::= <SLOTNAME> | <SLOTNAME>[<idx>] IL <SLOTNAME> è il nome di destinazione di uno slot (maiuscolo o minuscolo non è rilevante). <idx> è un indice a base zero che può essere utilizzato solo per i multislot. Definisce quale istanza del sottomodulo del multislot deve essere visualizzata. Durante la lettura della definizione del modulo il sistema controlla se i nomi dei segnaposto nelle schermate di visualizzazione sono validi. Se un elemento della schermata di visualizzazione inizia con \" PLACEHOLDER_ \" (maiuscolo o minuscolo non è rilevante), il <SUBPATH> deve iniziare con un riferimento di slot valido. Se è presente un indice, deve essere compatibile con la cardinalità dello slot. Tutti i nomi degli slot del percorso devono essere identificatori IEC validi. Se sono presenti più segnaposto, tutti i percorsi devono essere diversi. Inoltre gli elementi segnaposto non devono avere aree vuote. Se non esiste alcuna istanza del modulo corrispondente a <SUBPATH> di un elemento segnaposto, a questo elemento non verrà assegnata alcuna visualizzazione. Non verrà creato alcun messaggio di errore. Se esiste un'istanza del modulo corrispondente al file <SUBPATH> di un elemento segnaposto, questo elemento verrà incorporato se è definito come visualizzazione dello schermo incorporata per la schermata corrente. Le visualizzazioni incorporate manterranno le proporzioni originali. La dimensione verrà adattata al meglio al segnaposto senza sporgere oltre lo stesso. Esempio di elementi segnaposto Solo le istanze del sottomodulo e le relative istanze del sottomodulo possono essere incorporate utilizzando i segnaposto. Non è possibile incorporare visualizzazioni da altri rami dell'albero del modulo. " }, 
{ "title" : "Controllo del modello di primo livello ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_335369a685ed9d34c0a8652001ab0576", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Schermate di visualizzazione \/ Generazione di schermate di visualizzazione \/ Controllo del modello di primo livello ", 
"snippet" : "Nella schermata di primo livello vengono eseguiti i seguenti controlli: Se il modello di visualizzazione non esiste o se nella sua interfaccia sono definiti input o output, verrà visualizzato un errore. Se manca un elemento obbligatorio verrà visualizzato un errore. Se un elemento di un modello di p...", 
"body" : "Nella schermata di primo livello vengono eseguiti i seguenti controlli: Se il modello di visualizzazione non esiste o se nella sua interfaccia sono definiti input o output, verrà visualizzato un errore. Se manca un elemento obbligatorio verrà visualizzato un errore. Se un elemento di un modello di primo livello è definito ma ha un'area vuota o il tipo di elemento sbagliato, verrà visualizzato un errore. Se i modelli delle schede e la cornice si sovrappongono, verrà visualizzato un errore. Se la posizione del secondo modello di scheda è identica al primo modello o se la sua posizione è sul lato sinistro o sopra il primo modello, verrà visualizzato un errore. In caso di allineamento orizzontale dei tab verrà creato un errore se i tab non sono completamente sopra o sotto la cornice. In caso di allineamento verticale delle linguette verrà creato un errore se le linguette non si trovano completamente a destra o a sinistra della cornice. " }, 
{ "title" : "Creazione delle schermate di visualizzazione ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_85c3e6868b643da6c0a8640e01a0782b", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Schermate di visualizzazione \/ Generazione di schermate di visualizzazione \/ Creazione delle schermate di visualizzazione ", 
"snippet" : "Tutte le schermate di visualizzazione verranno inizialmente create dal comando creare . Con un secondo funzionamento del generatore verranno aggiornati solo i parametri modificati dell'albero dei moduli. Una schermata di visualizzazione creata contiene una cornice che definisce la dimensione della v...", 
"body" : "Tutte le schermate di visualizzazione verranno inizialmente create dal comando creare . Con un secondo funzionamento del generatore verranno aggiornati solo i parametri modificati dell'albero dei moduli. Una schermata di visualizzazione creata contiene una cornice che definisce la dimensione della visualizzazione e che contiene la visualizzazione corrispondente del modulo. Questo frame è in background, tutte le visualizzazioni incorporate saranno organizzate come segue: Tutti gli elementi incorporati sono identificati in modo persistente dall'ID dell'elemento. Se una schermata di visualizzazione esistente viene aggiornata da un nuovo funzionamento del generatore, il sistema cerca l'ID corrispondente. Se questo elemento (ID) esiste verrà aggiornato solo il parametro modificato nella configurazione del modulo. Ad esempio, la posizione rimane invariata e il cambio visualizzazione\/cornice e l'oggetto di visualizzazione utilizzato per la visualizzazione possono cambiare. Le visualizzazioni integrate verranno disposte sullo schermo da sinistra a destra e dall'alto verso il basso. Un elemento segnaposto corrispondente ha una priorità più alta. Infine, entrambi i meccanismi non vengono utilizzati se il telaio con il corrispondente ElementID esiste già durante la generazione. In questo caso la posizione rimane invariata. Le schermate di visualizzazione create nell'ultimo funzionamento del generatore, ma che non esistono nel funzionamento attuale del generatore, verranno cancellate. " }, 
{ "title" : "Ordine di incorporamento degli elementi di visualizzazione ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_b67bb7c98bca4d3bc0a8640e01a07a7d", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Schermate di visualizzazione \/ Generazione di schermate di visualizzazione \/ Ordine di incorporamento degli elementi di visualizzazione ", 
"snippet" : "Nel primo passaggio tutte le visualizzazioni incorporate da next Ancestor sarà organizzato. Questi elementi verranno inseriti nel preordine delle istanze del modulo nell'albero dei moduli. (Prima il primo figlio, poi tutti i suoi sottomoduli, poi il secondo figlio e così via) Successivamente verrann...", 
"body" : "Nel primo passaggio tutte le visualizzazioni incorporate da next Ancestor sarà organizzato. Questi elementi verranno inseriti nel preordine delle istanze del modulo nell'albero dei moduli. (Prima il primo figlio, poi tutti i suoi sottomoduli, poi il secondo figlio e così via) Successivamente verranno inserite tutte le visualizzazioni incorporate nella definizione dell'istanza. Ciò verrà fatto anche nel preordine delle istanze del modulo. " }, 
{ "title" : "Gestore della persistenza ", 
"url" : "ac_pm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza ", 
"snippet" : "Il Persistence Manager è un componente standard dell'Application Composer. Viene utilizzato per gestire i dati rimanenti persistenti. Riconosce tali variabili con certezza attributi nella dichiarazione delle variabili. Quindi è un opzione alternativa al meccanismo VAR PERSISTENTE del sistema di prog...", 
"body" : "Il Persistence Manager è un componente standard dell'Application Composer. Viene utilizzato per gestire i dati rimanenti persistenti. Riconosce tali variabili con certezza attributi nella dichiarazione delle variabili. Quindi è un opzione alternativa al meccanismo VAR PERSISTENTE del sistema di programmazione standard. che gestisce le variabili persistenti in un apposito elenco di variabili globali ( Variabili persistenti ). Questo meccanismo è progettato per l'esecuzione del tempo e l'archiviazione in un'area di memoria rimanente. Al contrario, il Persistence Manager memorizza valori persistenti in un file file esterno e quindi richiede meno risorse di memoria di un controller. Permette di mantenere i valori anche quando le dichiarazioni sono state modificate e consente la modifica esterna dei dati. Questa funzionalità estesa, tuttavia, va a scapito delle prestazioni. A seconda del controllore, la lettura e soprattutto la scrittura di una grande quantità di variabili persistenti può richiedere molto tempo e può bloccare a lungo il rispettivo compito. Dipende quindi dal caso d'uso quale meccanismo è consigliato per stabilire la persistenza dei dati. In certi casi anche l'uso di ricette può essere la soluzione migliore. Per aiutare a prendere una decisione, vedere: Persistenza Il Persistence Manager è un modulo di primo livello e può essere aggiunto all'albero dei moduli utilizzando il comando Aggiungi l'istanza del modulo di primo livello . Sotto il Gestore Persistenza è possibile inserire fino a 64 canali. Nei canali che puoi definire gruppi di persistenza e configurare il loro comportamento di archiviazione in base ai parametri. Ogni canale deve avere un sottomodulo Data Storage , definendo il formato in cui i dati persistenti vengono scritti in un file. Qui definisci il formato in cui i dati persistenti vengono archiviati in un file. Questo file di archivio viene archiviato esternamente, per impostazione predefinita nella directory di installazione del controller. Per le versioni del sistema runtime >= 3.5.8.0 la posizione dei file di archivio viene definita tramite il segnaposto $ac_persistence$ . Gli archivi già esistenti verranno spostati in questa posizione, se si trovano nella directory definita dal segnaposto $PLCLogic$ . Questa directory era la posizione predefinita nelle versioni precedenti del sistema runtime. Per gli archivi situati in entrambe le posizioni, viene emesso un avviso nel registro di sistema runtime. È possibile aggiungere un solo Persistence Manager per applicazione all'albero dei moduli. Se il Persistence Manager viene aggiunto al file POU pool o se all'applicazione viene aggiunto più di un gestore di persistenza, verrà creato un messaggio di errore. Persistence Manager aggiunto all'albero dei moduli Se l'albero dei moduli o i parametri delle istanze dei moduli sono stati modificati, è necessario eseguire un funzionamento del generatore. (Comando: creare) Differenze rispetto al meccanismo \"VAR PERSISTENCE\". I dati persistenti vengono memorizzati in un file esterno. I dati persistenti possono essere scambiati tra progetti. Le variabili persistenti possono essere cancellate dall'applicazione risp. aggiunto all'applicazione senza la perdita dei dati rimanenti. I dati creati dal Persistence Manager possono essere modificati con editor esterni. (Esempio: Blocco note). Guarda anche: Persistenza " }, 
{ "title" : "Modulo Gestore Persistenza ", 
"url" : "ac_pm_persistencemanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Modulo Gestore Persistenza ", 
"snippet" : "Un doppio clic su Gestore della persistenza nodo nell'albero dei moduli o nel file Modifica oggetto Il comando apre gli editor associati. Oltre agli editor standard dei moduli di primo livello (vedi Panoramica ) il Persistence Manager fornisce il file Persistenza scheda. HMI Il Persistence Manager f...", 
"body" : "Un doppio clic su Gestore della persistenza nodo nell'albero dei moduli o nel file Modifica oggetto Il comando apre gli editor associati. Oltre agli editor standard dei moduli di primo livello (vedi Panoramica ) il Persistence Manager fornisce il file Persistenza scheda. HMI Il Persistence Manager fornisce un modello di visualizzazione ( VISU_PersistenceManager ) che può essere aggiunto alla visualizzazione. Finestra di dialogo per le impostazioni dell'HMI Questa pagina fornisce informazioni statistiche sulla lettura e scrittura delle variabili: Pagina di visualizzazione dei dati di persistenza " }, 
{ "title" : "Persistenza ", 
"url" : "ac_pm_persistencemanager_module.html#UUID-87fcb435-c65b-2e65-6037-f61974f5b1d7_e4fa0ddccaa0cf0c0a8640e01493625_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Modulo Gestore Persistenza \/ Persistenza ", 
"snippet" : "Dialogo: Persistenza Nel Persistenza dialog uno o più gruppi possono essere esclusi dalla memorizzazione. Per creare un nuovo gruppo è necessario inserire un nome univoco e aggiungerlo con il Aggiungere pulsante. IL Rimuovere il comando consente di eliminare i gruppi esistenti. Le variabili possono ...", 
"body" : "Dialogo: Persistenza Nel Persistenza dialog uno o più gruppi possono essere esclusi dalla memorizzazione. Per creare un nuovo gruppo è necessario inserire un nome univoco e aggiungerlo con il Aggiungere pulsante. IL Rimuovere il comando consente di eliminare i gruppi esistenti. Le variabili possono essere escluse dall'archiviazione utilizzando l'attributo ac_persist_exclude . Per ulteriori informazioni, vedere: Attributo: 'ac_persist_exclude' " }, 
{ "title" : "Canale di persistenza ", 
"url" : "ac_pm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Canale di persistenza ", 
"snippet" : "Un canale di persistenza definisce le impostazioni di archiviazione per uno o più gruppi di variabili persistenti. Può essere aggiunto a un nodo Persistence Manager utilizzando il comando Aggiungi istanza del sottomodulo . Sotto un nodo Persistence Manager è possibile creare fino a 64 canali. HMI, I...", 
"body" : "Un canale di persistenza definisce le impostazioni di archiviazione per uno o più gruppi di variabili persistenti. Può essere aggiunto a un nodo Persistence Manager utilizzando il comando Aggiungi istanza del sottomodulo . Sotto un nodo Persistence Manager è possibile creare fino a 64 canali. HMI, Informazioni Per informazioni dettagliate su queste finestre di dialogo, vedere quanto segue: I\/O, HMI e Informazione. " }, 
{ "title" : "Persistenza ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Canale di persistenza \/ Persistenza ", 
"snippet" : "Gruppi persistenti In questa finestra di dialogo è possibile definire uno o più gruppi gestiti da questo canale. Per impostazione predefinita, il nome dell'istanza del modulo canale è disponibile nell'elenco. Per creare un nuovo gruppo è necessario inserire un nome univoco e aggiungerlo con il Aggiu...", 
"body" : "Gruppi persistenti In questa finestra di dialogo è possibile definire uno o più gruppi gestiti da questo canale. Per impostazione predefinita, il nome dell'istanza del modulo canale è disponibile nell'elenco. Per creare un nuovo gruppo è necessario inserire un nome univoco e aggiungerlo con il Aggiungere pulsante. Rimuovere può essere utilizzato per eliminare i gruppi selezionati. Le variabili possono essere assegnate ai gruppi tramite l'attributo ac_persist . Per ulteriori informazioni, vedere: Definizione di variabili persistenti, attributo 'ac.persist' Variabili persistenti : Questo elenco mostra tutte le variabili persistenti assegnate a uno dei gruppi di persistenza elencati sopra. " }, 
{ "title" : "Parametro ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Canale di persistenza \/ Parametro ", 
"snippet" : "IL Parametri La scheda fornisce un elenco di opzioni relative alla memorizzazione delle variabili: Parametri dei canali persistenti tRisparmio periodico : Trascorso questo intervallo le variabili vengono memorizzate. Immissione del valore t#0s disattiverà questo salvataggio periodico. xSalva su modi...", 
"body" : "IL Parametri La scheda fornisce un elenco di opzioni relative alla memorizzazione delle variabili: Parametri dei canali persistenti tRisparmio periodico : Trascorso questo intervallo le variabili vengono memorizzate. Immissione del valore t#0s disattiverà questo salvataggio periodico. xSalva su modifica : Se è impostato su TRUE, il valore corrente verrà costantemente confrontato con l'ultimo valore salvato e, se sono diversi, il valore corrente verrà memorizzato. Canali di persistenza, che sono stati impostati xSaveOnChange=FALSE , verranno memorizzati allo spegnimento del controller così come al reset (caldo, freddo, origine). Inoltre, può aver luogo un risparmio periodico. xReadVarsDuringInit : Se è impostato su TRUE , i valori delle variabili persistenti verranno letti durante l'inizializzazione dell'applicazione. Altrimenti vengono caricati nel primo ciclo applicativo. xCompressTags : Se è impostato su TRUE , i percorsi delle istanze delle variabili verranno salvati in un formato compresso. Per ulteriori informazioni, vedere: Formato di archiviazione, archivi compressi . xConsistentCopyInHighPrioTask : Se è impostato su TRUE , le variabili vengono copiate dal task con la priorità più alta e salvate nel task con la priorità più bassa. Questa opzione viene utilizzata per evitare incoerenze dei dati quando le variabili vengono modificate in un'attività ad alta priorità. xConvertVarsWithDifferentType : Se è impostato su TRUE , il canale di persistenza proverà a convertire il valore letto dall'archivio nel tipo di dati di destinazione (se il tipo di dati del valore è diverso da quello di destinazione). In caso di successo, verrà accettato il valore dall'archivio; in caso contrario, il valore verrà rifiutato. Questa funzione supporta le seguenti conversioni: Tipo di dati nell'archivio Tipo di dati di destinazione Descrizione qualsiasi numero intero qualsiasi numero intero solo se il valore rientra nell'intervallo coperto dal tipo di dati corrente qualsiasi numero intero Vero qualsiasi numero intero LReale tutti i tipi di dati Corda Vero LReale Vero QUALSIASI_INT solo se il valore dell'archivio è un numero intero nell'intervallo corretto LReale Vero solo se il valore rientra nell'intervallo coperto da un REAL LReale QUALSIASI_INT solo se il valore dell'archivio è un numero intero nell'intervallo corretto xControllo dell'integrità prima della lettura : Se è impostato su TRUE , viene verificata l'integrità del database. xSeparateArchivePerToplevelInstance : Se impostato su TRUE , viene creato un archivio separato per ogni istanza di primo livello. Il nome di tale archivio è il suo nome (come configurato in DataStorage) seguito dal nome dell'istanza di primo livello: <archive name>_<instance name> oppure <archive name> per tutte le istanze che non si trovano al di sotto di un'istanza di modulo di primo livello (ad esempio: variabili dell'applicazione). Questa opzione è disabilitata per impostazione predefinita. Se si modifica il parametro in seguito ( TRUE <-> FALSE ), il nome dell'archivio verrà cambiato e le variabili persistenti potrebbero andare perse! xMakeDataCRCConsistencyCheck : Se è impostato su TRUE , viene calcolato un valore CRC all'inizio e alla fine dell'operazione di salvataggio. Questi due valori devono essere uguali per completare correttamente l'operazione di salvataggio. uiSavingRetriesIfCRCConsistencyCheckFails : Specifica il numero di volte in cui ripetere la memorizzazione se xMakeDataCRCConsistencyCheckFails è impostato per TRUE e i valori CRC non corrispondono. xLogSaveTimeEnabled : Se è impostato su TRUE , viene registrato il tempo necessario per la scrittura. eAutomaticActionOnlineChange : Comportamento, se e come vengono memorizzati i valori delle variabili durante una modifica online. Nessuno : Nessuno spazio di archiviazione Salva : I valori vengono salvati. In questo modo anche le modifiche alla configurazione vengono acquisite nella memoria di persistenza (ad esempio l'aggiunta o la ridenominazione di variabili). Carico : I valori vengono caricati dalla memoria di persistenza. Pertanto, eventuali inizializzazioni (ad es FB_INIT , IModule.Init e parametri del modulo) vengono sovrascritti dai valori persistenti. Carica e salva : I valori vengono caricati e scritti dalla memoria di persistenza. eAutomaticActionPlcStop : Determina se i valori delle variabili vengono memorizzati durante un reset. Nessuno : Nessuno spazio di archiviazione Salva : I valori vengono salvati. " }, 
{ "title" : "Modulo: archiviazione dei dati ", 
"url" : "ac_pm_storage_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Modulo: archiviazione dei dati ", 
"snippet" : "Archivio dati Il sottomodulo Archivio dati definisce il formato di archiviazione di un canale di persistenza . Scegli uno dei seguenti formati di archiviazione: ASCIIFileStorage : Salvataggio dei valori in formato ASCII in un file. IL ASCIIFileStorage format consente di aprire il file di archivio in...", 
"body" : "Archivio dati Il sottomodulo Archivio dati definisce il formato di archiviazione di un canale di persistenza . Scegli uno dei seguenti formati di archiviazione: ASCIIFileStorage : Salvataggio dei valori in formato ASCII in un file. IL ASCIIFileStorage format consente di aprire il file di archivio in un editor di testo e di modificare i valori. I commenti possono essere aggiunti all'archivio file ASCII. Questi verranno ignorati durante la lettura del file. BinaryFileStorage : Salvataggio dei valori in formato binario in un file. BinaryMemoryStorage :Salvataggio dei valori in formato binario nell'area \"RETAIN\" del compilatore o del dispositivo interessato (esempio: nella NVRAM di tale dispositivo.) PersistentBinaryMemoryStorage : Salvataggio dei valori in formato binario nell'area \"Persistente\" del compilatore o del dispositivo interessato (esempio: nella NVRAM di tale dispositivo.) Sotto il canale di persistenza inserire a Archivio dati modulo del formato desiderato. Se necessario, modificare la configurazione in Parametro scheda: Finestra di dialogo: Informazioni Per informazioni dettagliate su questa finestra di dialogo, vedere: Informazione . " }, 
{ "title" : "Finestra di dialogo: parametri ", 
"url" : "ac_pm_storage_module.html#UUID-1d4190f0-4f49-535e-fe96-bf340f625ee5_aa44ae4cccad1068c0a8640e019d97f0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Modulo: archiviazione dei dati \/ Finestra di dialogo: parametri ", 
"snippet" : "sNomeArchivio Nome del file di archivio Per impostazione predefinita, il segnaposto %CHANNEL_NAME% è definito. Questo segnaposto verrà sostituito dal nome dell'istanza del canale di persistenza superiore. Il nome dell'archivio deve essere univoco, poiché tutti i file di archivio vengono archiviati p...", 
"body" : "sNomeArchivio Nome del file di archivio Per impostazione predefinita, il segnaposto %CHANNEL_NAME% è definito. Questo segnaposto verrà sostituito dal nome dell'istanza del canale di persistenza superiore. Il nome dell'archivio deve essere univoco, poiché tutti i file di archivio vengono archiviati per impostazione predefinita nella directory di installazione del controller. Nota: il percorso di archiviazione predefinito per i file di archivio dipende dalla versione del sistema runtime. Vedere: Panoramica del Gestore della persistenza xDoubleStorage Se attivato ( TRUE ), le variabili vengono memorizzate alternativamente in due archivi diversi ( sArchive1 , sArchive2 ). In caso di file danneggiato (esempio: a causa di uno spegnimento del controller durante la memorizzazione delle variabili), verrà utilizzato il file di backup. Quando il file viene aperto, il Persistence Manager controlla il timestamp di entrambi gli archivi. In assenza di danni verrà utilizzato l'archivio più recente, altrimenti l'altro. udiMaximumFileSize La dimensione massima del file in byte Se 0 è definito, non viene impostato o controllato alcun limite. Quindi la dimensione del file può raggiungere qualsiasi dimensione. daSeparatore Valore ASCII per il separatore tra nome e valore della variabile. udiMemDataSize Dimensione della memoria nell'area variabile \"RETAIN\" creata per l'unità. Il valore viene confrontato con la dimensione dei dati da archiviare. Se il valore è decisamente troppo piccolo viene creato un errore del compilatore. Se è eventualmente troppo piccolo, viene visualizzato un avviso nella visualizzazione dei messaggi. LineEnding Carattere che indica la fine della riga nel file " }, 
{ "title" : "Definizione di variabili persistenti ", 
"url" : "ac_pm_definition_persistent_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Definizione di variabili persistenti ", 
"snippet" : "Le singole variabili così come le istanze della struttura e le istanze dei blocchi funzione possono essere contrassegnate come \"persistenti\" mediante l'uso di attributi. Quando un'istanza viene contrassegnata, tutti i membri di VAR , VAR_INPUT , E VAR_OUTPUT verranno archiviati in modo persistente. ...", 
"body" : "Le singole variabili così come le istanze della struttura e le istanze dei blocchi funzione possono essere contrassegnate come \"persistenti\" mediante l'uso di attributi. Quando un'istanza viene contrassegnata, tutti i membri di VAR , VAR_INPUT , E VAR_OUTPUT verranno archiviati in modo persistente. Nel caso in cui le variabili in a VAR PERSISTENT sono contrassegnate come \"persistenti\", verrà creato un avviso. Inoltre sono disponibili attributi per definire un gruppo di archiviazione predefinito, nonché per escludere variabili particolari dall'archiviazione persistente di strutture o istanze di blocchi funzione. Se la definizione delle variabili persistenti è stata modificata (aggiunta, rimozione, ridenominazione, modifica del tipo di dati) non deve essere eseguita alcuna nuova generazione di codice compositore (comando Genera). Queste modifiche verranno aggiornate automaticamente nelle istanze di Persistent Manager durante la compilazione. Per informazioni sulle possibili conversioni implicite in caso di definizione del tipo di dati modificata, vedere: Parametro Attributo: 'ac_persist_exclude' L'attributo 'ac_persist_exclude' viene utilizzato per escludere una variabile dalla memoria persistente, non importa se i membri nella dichiarazione della struttura o del blocco funzione sono definiti come \"persistenti\". Se non esistono membri persistenti nella dichiarazione verrà creato un errore durante la generazione del codice. Esempio di esclusione di variabili PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_exclude'}\n fb1 : FB;\nEND_VAR " }, 
{ "title" : "Tipi di dati supportati ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_beff9eaed151b190c0a8640e01016617", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Definizione di variabili persistenti \/ Tipi di dati supportati ", 
"snippet" : "Le istanze con i seguenti tipi di dati non possono essere archiviate in modo persistente: MORSO Puntatore Interfacce Costanti Array di tipi di dati non persistenti Tutti gli altri tipi di dati sono supportati. Ciò include enumerazioni, tipi di dati sottointervallo, matrici di matrici e matrici multi...", 
"body" : "Le istanze con i seguenti tipi di dati non possono essere archiviate in modo persistente: MORSO Puntatore Interfacce Costanti Array di tipi di dati non persistenti Tutti gli altri tipi di dati sono supportati. Ciò include enumerazioni, tipi di dati sottointervallo, matrici di matrici e matrici multidimensionali: ARRAY[0..9] OF ARRAY[5..6, 7..8, 9..10] OF INT Tipo di dati: UNIONE Per salvare l'istanza di un'unione in modo persistente, uno dei suoi campi deve essere contrassegnato come \"rappresentante\". Ci sono tre modi possibili: Esattamente un campo nella dichiarazione dell'unione è contrassegnato con l'attributo ac_persist_union_representant (senza valore dell'attributo). Questo campo quindi \"rappresenta\" l'unione. Il suo valore verrà salvato e caricato in modo rappresentativo per l'intera unione. Un campo esatto nella dichiarazione dell'unione è contrassegnato con l'attributo ac_persist – questo definisce allo stesso tempo il rappresentante. L'istanza dell'unione è contrassegnata con l'attributo ac_persist_union_set_representant compreso il valore dell'attributo. Il valore dell'attributo descrive il nome del campo dell'unione che dovrà essere utilizzato come rappresentativo. Questo attributo sovrascrive un esistente ac_persist_union_representant attributo nella dichiarazione dell'unione. Anche gli array di unioni possono essere contrassegnati e fare riferimento agli elementi dell'array. Esempi 'ac_persist_union_representant' TYPE UnionWithRep :\nUNION\n di : DINT ;\n {attribute 'ac_persist_union_representant'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 'ac_persistere' TYPE UnionWithPersist :\nUNION\n di : DINT ;\n {attribute 'ac_persist' := 'TestUnion'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 'ac_persist_union_set_representant' FUNCTION_BLOCK FBTestUnion\nVAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n u2 : UnionWithoutRep ;\nEND_VAR Matrice di unione VAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aElems ARRAY[0..7] OF SomeUnion ;\n\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aaElems ARRAY[0..7] OF ARRAY[0..1] OF SomeUnion ;\nEND_VAR Perché un rappresentante sia valido, deve soddisfare le seguenti regole: Il rappresentante deve avere le stesse dimensioni dell'intero sindacato. Altrimenti i dati completi non verrebbero salvati. Il rappresentante inoltre non deve avere aree di riempimento (aree di dati vuote create dal compilatore per allineare i dati nell'archivio). La scomposizione del rappresentante in tipi di dati primitivi non deve contenere istanze di tipo REAL O LREAL o istanza di tipo STRING O WSTRING . Inoltre il rappresentante deve essere composto da tipi supportati (vedi sopra). Ad esempio il rappresentante può essere di tipo Structure – tuttavia, la struttura stessa non deve contenere Pointer. " }, 
{ "title" : "Attributo: 'ac_persist' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_e844aaa8d151b192c0a8640e01722fe3", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Definizione di variabili persistenti \/ Attributo: 'ac_persist' ", 
"snippet" : "L'attributo ' ac_persist ' può essere utilizzato per Variabili Istanze di strutture Istanze di blocchi funzione Membri delle strutture Membri dei blocchi funzione {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP è il nome del gruppo di persistenza a cui deve essere attribuita l...", 
"body" : "L'attributo ' ac_persist ' può essere utilizzato per Variabili Istanze di strutture Istanze di blocchi funzione Membri delle strutture Membri dei blocchi funzione {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP è il nome del gruppo di persistenza a cui deve essere attribuita la dichiarazione. Deve essere un identificatore IEC valido. Se qui non viene nominato alcun gruppo di persistenza, l'assegnazione verrà eseguita in base all'attributo 'ac_persist_set_default_group' , che in questo caso deve essere definito. Se un'istanza di struttura o un'istanza di blocco funzione è contrassegnata come \"persistente\" e anche almeno un membro nella dichiarazione è contrassegnato come \"persistente\", verrà creato un messaggio di errore. Esempio per un'istanza persistente La variabile t viene assegnato al gruppo di persistenza PROCESS . Tutti i membri verranno archiviati in modo persistente. PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist' := 'PROCESS'}\n t : TON;\nEND_VAR Esempio di membro persistente di un blocco funzione Il membro iNumIOs viene assegnato al gruppo di persistenza CONFIG . Questo membro verrà archiviato in modo persistente per tutte le istanze del blocco funzione (se non esplicitamente soppresso dall'attributo 'ac_persist_exclude' ). FUNCTION_BLOCK FB\nVAR\n {attribute 'ac_persist' := 'CONFIG'}\n iNumIOs : INT := 0;\nEND_VAR " }, 
{ "title" : "Attributo: 'ac_persist_set_default_group' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_4130a661d151b192c0a8640e00b1a163", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Definizione di variabili persistenti \/ Attributo: 'ac_persist_set_default_group' ", 
"snippet" : "Se il nome del gruppo manca nell'attributo 'ac_persist' , UN gruppo predefinito deve essere definito in un'istanza di blocco funzione o di struttura contenente la rispettiva variabile direttamente o indirettamente. Questo è possibile con l'attributo 'ac_persist_set_default_group' . L'attributo può e...", 
"body" : "Se il nome del gruppo manca nell'attributo 'ac_persist' , UN gruppo predefinito deve essere definito in un'istanza di blocco funzione o di struttura contenente la rispettiva variabile direttamente o indirettamente. Questo è possibile con l'attributo 'ac_persist_set_default_group' . L'attributo può essere impostato anche per un membro del blocco funzione. La definizione più interna trovata di 'ac_persist_set_default_group' verrà utilizzato come gruppo predefinito per la variabile. Non è consentito l'uso 'ac_persist_set_default_group' insieme a 'ac_persist' O 'ac_persist_exclude' . In questo caso verrà creato un messaggio di errore durante la generazione del codice. Esempio per un gruppo predefinito FUNCTION_BLOCK FB_Util\nVAR\n {attribute 'ac_persist'} \/\/ no group\n \/\/'ac_persist_set_default_group‘ and 'ac_persist_exclude' not allowed here\n i : INT := 0;\nEND_VAR PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_set_default_group' := 'PROCESS'}\n fbu1 : FB_Util;\n\n {attribute 'ac_persist_set_default_group'´ := 'CONFIG'}\n fbu2 : FB_Util;\nEND_VAR " }, 
{ "title" : "Archivio dati ", 
"url" : "ac_pm_data_storage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Archivio dati ", 
"snippet" : "La memorizzazione delle variabili persistenti può essere attivata in vari modi: Ogni canale di persistenza fornisce un'interfaccia applicativa che può essere utilizzata dall'applicazione per attivare un'archiviazione (vedi Accesso ai dati ). Nei parametri del canale di persistenza un intervallo di t...", 
"body" : "La memorizzazione delle variabili persistenti può essere attivata in vari modi: Ogni canale di persistenza fornisce un'interfaccia applicativa che può essere utilizzata dall'applicazione per attivare un'archiviazione (vedi Accesso ai dati ). Nei parametri del canale di persistenza un intervallo di tempo ( tRisparmio periodico ) può essere definito per la memorizzazione automatica. Il canale di persistenza può essere configurato per memorizzare una variabile ogni volta che il suo valore cambia. Per questo vengono confrontati il valore precedente e il valore corrente; se sono diversi verrà attivata la memorizzazione. Le diverse modalità di archiviazione possono essere utilizzate in parallelo e non si escludono a vicenda. In caso di spegnimento del controller o dopo il \"Reset\" (caldo\/freddo\/origine) i dati vengono memorizzati automaticamente se il parametro xSalva su modifica non è impostato. Per ulteriori informazioni, vedere anche: Modulo: archiviazione dei dati " }, 
{ "title" : "Formato di archiviazione ", 
"url" : "ac_pm_storage_format.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Formato di archiviazione ", 
"snippet" : "Esistono due implementazioni dell'interfaccia IDataStorage disponibile: ASCIIDataStorage E BinaryDataStorage . In entrambi i formati la prima variabile memorizzata è la variabile riservata ___xCompressTags di tipo BOOL . Il suo valore determina se i percorsi delle istanze vengono archiviati compress...", 
"body" : "Esistono due implementazioni dell'interfaccia IDataStorage disponibile: ASCIIDataStorage E BinaryDataStorage . In entrambi i formati la prima variabile memorizzata è la variabile riservata ___xCompressTags di tipo BOOL . Il suo valore determina se i percorsi delle istanze vengono archiviati compressi. Se viene scritto un oggetto di integrità, viene scritto come l'ultima variabile denominata ___Integrity di tipo BOOL con valore TRUE . Tutte le variabili persistenti, tranne queste variabili riservate, vengono archiviate in ordine e ordinate in base al percorso completo dell'istanza. Non importa se i percorsi dell'istanza sono compressi o meno. Se i dati vengono modificati dall'utente, questi deve assicurarsi che venga mantenuto il corretto ordinamento. Archivi compressi I valori delle variabili vengono memorizzati con percorso e nome (nel percorso non c'è né l'applicazione né il nome del dispositivo) in una ortografia compatta per risparmiare risorse e tempo. In ogni caso (compressi o meno) i percorsi delle istanze devono essere ordinati in base al percorso completo dell'istanza. Questo ordinamento è alfabetico, per cui gli indici di array sono ordinati numericamente. Esempi Oggetti Formato compresso Fb1.fb2.fb3.a Fb1.fb2.fb3.a Fb1.fb2.fb3.b <b Fb1.fb2.d <<d Fb4 FB4 " }, 
{ "title" : "Formato ASCII ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_7b30973fd16738e7c0a8640e01455e29", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Formato di archiviazione \/ Formato ASCII ", 
"snippet" : "ASCIIDataStorage scrive nel file il percorso di ogni istanza delle variabili persistenti (possibilmente in formato compresso), il tipo di dati e il valore come stringa. Il nome e la data sono separati da un carattere di tabulazione (può essere modificato tramite parametro codbySeparator ). Quando l'...", 
"body" : "ASCIIDataStorage scrive nel file il percorso di ogni istanza delle variabili persistenti (possibilmente in formato compresso), il tipo di dati e il valore come stringa. Il nome e la data sono separati da un carattere di tabulazione (può essere modificato tramite parametro codbySeparator ). Quando l'archivio viene letto, verrà eseguita una conversione. Pertanto il file può essere modificato esternamente. Le righe devono essere separate da \"\\r\\n\" (convenzione di Windows). Le righe che iniziano con un punto e virgola verranno ignorate durante la lettura: questa riga non verrà aggiunta durante la scrittura dell'archivio. Formato di un file ASCII: {timestamp}\\r\\n\n{instance path}{bySeparator}{Typ}:{value}\\r\\n\n…\n{instance path}{bySeparator}{Typ}:{value}\\r\\n Il timestamp determina l'ora in cui è stata attivata la memorizzazione. È scritto come DATE_AND_TIME letterale (esempio: DT#2012-01-11-15:11:09 ) Esempio di file ASCII Trattamento di REAL E LREAL variabili: I valori delle variabili sono scritti come letterali ST. REAL E LREAL i valori vengono trattati diversamente, perché l'implementazione della conversione in e da frazioni decimali senza perdita di precisione. Tuttavia, per evitare qualsiasi perdita di precisione e per mantenere la leggibilità e la possibilità di modificare il file ASCII, questi valori vengono memorizzati in formato esadecimale. La frazione decimale (inesatta) viene aggiunta dopo il valore esadecimale come commento. Durante la lettura del file sono supportati sia il formato esadecimale che il formato decimale ST. Ciò consente all'utente di modificare la frazione decimale. Il formato esadecimale è definito come segue: F16#{Mantissa}H{Exp} | F16#NaN | F16#+Inf | F16#-Inf\n{Mantissa} ::= {HexNumeral}\n{Exp} ::= {HexNumeral}\n{HexNumeral} ::= [+-]?[1-9A-F][0-9A-F]* Se m è il valore della mantissa e e il valore dell'esponente è superiore al valore del numero m * 16^e . Esempio di valore REAL memorizzato lr1 LREAL:F16#F0H-3 0.05859375 " }, 
{ "title" : "Formato binario ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_602fd614d22a5f95c0a8640e0110d837", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Formato di archiviazione \/ Formato binario ", 
"snippet" : "BinaryDataStorage salva i dati in un formato binario. Il timestamp segue quello (type DATE_AND_TIME ). Successivamente vengono elencate le variabili....", 
"body" : "BinaryDataStorage salva i dati in un formato binario. Il timestamp segue quello (type DATE_AND_TIME ). Successivamente vengono elencate le variabili. " }, 
{ "title" : "Accesso ai dati ", 
"url" : "ac_pm_data_access.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Accesso ai dati ", 
"snippet" : "Il Persistence Manager fornisce fino a 10 istanze di sottomodulo di tipo PersistenceChannel. Ogni canale di persistenza fornisce un'istanza di sottomodulo di tipo DataStorage che è responsabile dell'accesso ai dati. Questa istanza implementa l'interfaccia IDataStorage :...", 
"body" : "Il Persistence Manager fornisce fino a 10 istanze di sottomodulo di tipo PersistenceChannel. Ogni canale di persistenza fornisce un'istanza di sottomodulo di tipo DataStorage che è responsabile dell'accesso ai dati. Questa istanza implementa l'interfaccia IDataStorage : " }, 
{ "title" : "Diagnosi ", 
"url" : "ac_pm_diagnosis.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Diagnosi ", 
"snippet" : "Ogni canale di persistenza ha un sottomodulo che consente l'accesso ai dati (interface IDataStorage ). I seguenti output forniscono informazioni diagnostiche: Produzione Tipo di dati Descrizione xActionOngoing BOOL TRUE se il Persistence Manager legge o scrive dati udiDataMemSize UDINT Dimensione de...", 
"body" : "Ogni canale di persistenza ha un sottomodulo che consente l'accesso ai dati (interface IDataStorage ). I seguenti output forniscono informazioni diagnostiche: Produzione Tipo di dati Descrizione xActionOngoing BOOL TRUE se il Persistence Manager legge o scrive dati udiDataMemSize UDINT Dimensione dei dati persistenti in byte xReadingDone BOOL Lettura dei dati persistenti terminata dtLastReading DT Data e ora dell'ultima lettura uiNumberVarsNotOk UINT Numero di variabili che non sono state lette correttamente uiNumberVarsOk UINT Numero di variabili lette correttamente tTimeForReading TIME Durata del tempo per la lettura dtLastSaving DT Data e ora dell'ultima lettura tTimeForWriting TIME Durata del tempo per la scrittura uiWritingCycles UINT Numero di conservazioni fino all'inizio dell'applicazione Le informazioni sul numero di variabili lette e sul successo della memorizzazione vengono visualizzate anche nel logger del PLC. Registrazione PLC¶ " }, 
{ "title" : "Gestione degli errori ", 
"url" : "ac_pm_error_handling.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Gestore della persistenza \/ Gestione degli errori ", 
"snippet" : "I numeri di errore e le relative stringhe vengono richiamati o confermati tramite le interfacce del modulo standard ( ClearErrors , FirstErrorNumber , GetFirstErrorMessage , LastErrorNumber , GetLastErrorMessage ). Numero errore Descrizione 100 L'elenco dei dati persistenti è cambiato e non corrispo...", 
"body" : "I numeri di errore e le relative stringhe vengono richiamati o confermati tramite le interfacce del modulo standard ( ClearErrors , FirstErrorNumber , GetFirstErrorMessage , LastErrorNumber , GetLastErrorMessage ). Numero errore Descrizione 100 L'elenco dei dati persistenti è cambiato e non corrisponde alla dimensione iniziale 110 Non è possibile creare la memoria (per il confronto o la copia coerente). <ErrorCode SysMemAllocData> . La funzione è disattivata. 120 Non è possibile creare un archivio dati per l'archivio di confronto. La funzione è disattivata. 130 Archiviazione dati non creata per una copia coerente 140 Variabile persistente di tipo String ha una dimensione non valida: <nome della variabile> 150 La variabile persistente non è del tipo supportato: <nome della variabile> 160 Impossibile aprire il database. Lettura interrotta: <descrizione dettagliata dell'errore dell'oggetto database> 170 Impossibile chiudere il database. Lettura interrotta: <descrizione dettagliata dell'errore dell'oggetto database> 190 Impossibile creare il database. Salvataggio interrotto. <descrizione dettagliata dell'errore dell'oggetto database> 200 Impossibile aprire il database. Salvataggio interrotto. <descrizione dettagliata dell'errore dell'oggetto database> 210 Impossibile chiudere il database. <descrizione dettagliata dell'errore dell'oggetto database> 220 Errore durante la scrittura di una voce: <descrizione dettagliata dell'errore dell'oggetto database> 230 Errore durante la lettura dell'ora del sistema " }, 
{ "title" : "DataLog Manager ", 
"url" : "ac_dlm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ DataLog Manager ", 
"snippet" : "Il DataLog Manager è un componente standard dell'Application Composer. Serve per la memorizzazione ciclica di valori variabili in un file. Queste variabili sono contrassegnate con speciale attributi nella dichiarazione della variabile. Per rendere disponibile il modulo è necessario aggiungere il fil...", 
"body" : "Il DataLog Manager è un componente standard dell'Application Composer. Serve per la memorizzazione ciclica di valori variabili in un file. Queste variabili sono contrassegnate con speciale attributi nella dichiarazione della variabile. Per rendere disponibile il modulo è necessario aggiungere il file AC_DataLog biblioteca al direttore della biblioteca. È possibile aggiungere un solo DataLog Manager per applicazione all'albero dei moduli. Il DataLog Manager è un modulo di primo livello e può essere aggiunto all'albero dei moduli utilizzando il file Aggiungi l'istanza del modulo di primo livello comando. Sotto i DataLog Manager è possibile inserire fino a 64 canali. Nei canali è possibile definire gruppi e configurare il loro comportamento di archiviazione tramite parametri. Ogni canale deve avere un sottomodulo di memorizzazione DataLog. Aggiungi DataLog Manager all'albero dei moduli Se l'albero dei moduli o i parametri delle istanze dei moduli sono stati modificati, è necessario eseguire un funzionamento del generatore. (Comando: creare ). A questo scopo il DataLog Generator nel file Configurazione del generatore deve essere attivato. " }, 
{ "title" : "Modulo: DataLog Manager ", 
"url" : "ac_dlm_datalogmanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ DataLog Manager \/ Modulo: DataLog Manager ", 
"snippet" : "DataLog Manager IL Gestore registro dati gestisce la registrazione dei dati delle variabili. Può essere aggiunto all'albero dei moduli sotto l'oggetto più in alto. Questo viene fatto da Aggiungi istanza di primo livello comando e la selezione del file DataLogManager modulo. È possibile aggiungere un...", 
"body" : "DataLog Manager IL Gestore registro dati gestisce la registrazione dei dati delle variabili. Può essere aggiunto all'albero dei moduli sotto l'oggetto più in alto. Questo viene fatto da Aggiungi istanza di primo livello comando e la selezione del file DataLogManager modulo. È possibile aggiungere un solo DataLog Manager per applicazione. Finestra di dialogo: HMI Il DataLog Manager fornisce un modello di visualizzazione ( VISU_DataLogManager ) che può essere aggiunto alla visualizzazione. Per ulteriori informazioni, vedere: HMIIn modalità online questa pagina fornisce informazioni statistiche sulla lettura e scrittura delle variabili. " }, 
{ "title" : "Finestra di dialogo: registrazione dati ", 
"url" : "ac_dlm_datalogmanager_module.html#UUID-5158e4eb-39c1-2002-c9f6-d4d4a1d20765_f45d0fbcc9eecefdc0a8646307e5e8bf_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ DataLog Manager \/ Modulo: DataLog Manager \/ Finestra di dialogo: registrazione dati ", 
"snippet" : "In questa finestra di dialogo è possibile escludere uno o più gruppi dalla memorizzazione. Per impostazione predefinita il DataLogManager viene creato il gruppo. Aggiungere Aggiunta e rimozione di gruppi esclusi dalla memorizzazione. Rimuovere...", 
"body" : "In questa finestra di dialogo è possibile escludere uno o più gruppi dalla memorizzazione. Per impostazione predefinita il DataLogManager viene creato il gruppo. Aggiungere Aggiunta e rimozione di gruppi esclusi dalla memorizzazione. Rimuovere " }, 
{ "title" : "Modulo: Canale DataLog ", 
"url" : "ac_dlm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ DataLog Manager \/ Modulo: Canale DataLog ", 
"snippet" : "Canale di registrazione dati IL Canale di registrazione dati il modulo viene utilizzato per definire i gruppi per l'archiviazione delle variabili. Il modulo può essere aggiunto sotto il file Gestore della registrazione dati nodo. Questo viene fatto da Aggiungi istanza del sottomodulo comando e la se...", 
"body" : "Canale di registrazione dati IL Canale di registrazione dati il modulo viene utilizzato per definire i gruppi per l'archiviazione delle variabili. Il modulo può essere aggiunto sotto il file Gestore della registrazione dati nodo. Questo viene fatto da Aggiungi istanza del sottomodulo comando e la selezione del file Canale di registro dati modulo. È possibile aggiungere fino a 64 canali DataLog. Finestra di dialogo: HMI, Informazioni Per dettagli su queste finestre di dialogo, vedere la pagina della guida HMI , E Informazione " }, 
{ "title" : "Finestra di dialogo: registrazione dati ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ DataLog Manager \/ Modulo: Canale DataLog \/ Finestra di dialogo: registrazione dati ", 
"snippet" : "In questa finestra di dialogo è possibile definire uno o più gruppi gestiti da questo canale. Per impostazione predefinita, il nome dell'istanza del modulo canale è disponibile nell'elenco. Gruppi registrati da questo canale Nuovo Definizione di gruppo La voce viene aggiunta all'elenco utilizzando i...", 
"body" : "In questa finestra di dialogo è possibile definire uno o più gruppi gestiti da questo canale. Per impostazione predefinita, il nome dell'istanza del modulo canale è disponibile nell'elenco. Gruppi registrati da questo canale Nuovo Definizione di gruppo La voce viene aggiunta all'elenco utilizzando il comando Aggiungere comando. Utilizza percorsi di istanze con hash : La voce non viene memorizzata con il percorso completo dell'istanza ma con il valore hash della stringa per risparmiare spazio in memoria. L'assegnazione tra hash e percorso dell'istanza viene salvata in un file separato. Rimuovere Rimuove il gruppo selezionato dall'elenco Variabili registrate Elenco delle variabili assegnate alle liste Queste variabili hanno il {attribute 'ac_datalog' := '<group name>'} attributo. ricaricare Aggiorna l'elenco delle variabili registrate Nota: L'elenco può essere aggiornato solo se il DataLog Generator è attivato. Le variabili possono essere assegnate ai gruppi tramite ac_datalog attributo. IL ac_datalog_isteresi L'attributo definisce l'isteresi che deve essere superata prima che una variabile venga registrata. Esempio VAR\n {attribute 'ac_datalog' := 'DataLogChannel'}\n {attribute 'ac_datalog_hysteresis' := '0.745'}\n rLogVar : REAL;\nEND_VAR " }, 
{ "title" : "Finestra di dialogo: parametri ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ DataLog Manager \/ Modulo: Canale DataLog \/ Finestra di dialogo: parametri ", 
"snippet" : "In questa finestra di dialogo si definiscono i parametri per il salvataggio delle variabili DataLog. Attivare FALSE : Le variabili memorizzate da questo canale non vengono registrate. Risparmia nel primo ciclo TRUE : Tutte le variabili di questo canale verranno registrate nel primo ciclo. Salva cicl...", 
"body" : "In questa finestra di dialogo si definiscono i parametri per il salvataggio delle variabili DataLog. Attivare FALSE : Le variabili memorizzate da questo canale non vengono registrate. Risparmia nel primo ciclo TRUE : Tutte le variabili di questo canale verranno registrate nel primo ciclo. Salva ciclico Tipo di dati TIME : Tutte le variabili di questo canale verranno memorizzate ciclicamente. Il valore T#0s disattiva la registrazione. " }, 
{ "title" : "Modulo: DataLog Storage CSV ", 
"url" : "ac_dlm_storage_csv_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ DataLog Manager \/ Modulo: DataLog Storage CSV ", 
"snippet" : "DataLog Storage CSV Il sotto modulo  DataLogStorage_CSV definisce il formato di archiviazione di a canale DataLog come file CSV. Può essere aggiunto sotto un nodo del canale DataLog Questo viene fatto dal Aggiungi istanza del sotto modulo comando e selezione di DataLogStorage_CSV modulo. Dialogo: In...", 
"body" : "DataLog Storage CSV Il sotto modulo  DataLogStorage_CSV definisce il formato di archiviazione di a canale DataLog come file CSV. Può essere aggiunto sotto un nodo del canale DataLog Questo viene fatto dal Aggiungi istanza del sotto modulo comando e selezione di DataLogStorage_CSV modulo. Dialogo: Informazioni Per informazioni dettagliate su queste finestre di dialogo, consulta la pagina di aiuto in Informazioni . " }, 
{ "title" : "Dialogo: Parametri ", 
"url" : "ac_dlm_storage_csv_module.html#UUID-77b82c47-16c6-5f2f-5d4f-34b67bccf3d3_d1edd6c9f1f1a7c0a864637755e4ae_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ DataLog Manager \/ Modulo: DataLog Storage CSV \/ Dialogo: Parametri ", 
"snippet" : "Nome di archiviazione Nome del file di archiviazione Per impostazione predefinita, il segnaposto %CHANNEL_NAME% è definito. Questo segnaposto verrà sostituito dal nome dell'istanza del canale DataLog superiore. Il nome del file di archiviazione deve essere univoco, poiché per impostazione predefinit...", 
"body" : "Nome di archiviazione Nome del file di archiviazione Per impostazione predefinita, il segnaposto %CHANNEL_NAME% è definito. Questo segnaposto verrà sostituito dal nome dell'istanza del canale DataLog superiore. Il nome del file di archiviazione deve essere univoco, poiché per impostazione predefinita tutti i file di archiviazione sono archiviati nella stessa directory Facoltativamente un segnaposto %DATE% può essere aggiunto per la data di archiviazione. La risoluzione è definita nel parametro Stringa di formato per sostituire %DATE% (vedi sotto). Esempio: Con la specificazione del nome '%CHANNEL_NAME%_AT_%DATE%' , i seguenti risultati relativi al nome di file DataLogChannel_1 canale: Application_DataLogChannel_1_AT_20191211_02-10-30.csv Separatore : Valore ASCII per il separatore tra nome e valore della variabile. Esempio: ',' Dimensione del buffer : Dimensione del buffer interno per l'archiviazione temporanea delle voci. Esempio: 2000 Livello di riempimento del buffer Valore in percentuale. Se il buffer è riempito fino a questo valore, il contenuto del buffer viene scritto nel file CSV. Specificando 0 disattiva il buffering. Una voce nel file ha il seguente formato (con | come separatore): <TimeStamp>|<InstancePath\/Hash>|<Value>[|<TypeClass>] Se l'archiviazione viene eseguita con percorsi con hash, il tipo di dati non viene memorizzato con ogni voce ma solo una volta in un file separato in cui è memorizzato il percorso dell'istanza hash ↔ di assegnazione. La voce in questo file ha il formato: <InstancePath>|<TypeClass>|<Hash> In caso di modifica online, i file non vengono eliminati. Le nuove voci vengono aggiunte. Nel file hash una modifica online è contrassegnata da un timestamp. Pertanto, l'assegnazione del percorso di istanza hash ↔ per le voci prima della modifica online Durante l'inizializzazione dopo un download (nessuna modifica online) i dati e i file hash vengono eliminati. Inclusione di caratteri Aggiungi caratteri che lo racchiudono TRUE : le voci delle stringhe verranno archiviate con l'ambiente circostante. Esempio: valore variabile: File1 , immissione del file: -File1- . FALSE : le stringhe vengono memorizzate senza includere caratteri. Inclusione di caratteri Caratteri usati per racchiudere. Esempio: '-' Stringa di formato per sostituire %DATE% Formato della data utilizzato per sostituire %DATE% che può essere specificato nel parametro Nome di archiviazione (vedi sopra). Esempi: 'yyyyMMdd' , 'yyyyMMdd_hh-mm-ss' LineEnding Carattere che indica la fine della riga nel file " }, 
{ "title" : "Modulo: DataLog Storage SQLite ", 
"url" : "ac_dlm_storage_sqlite_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ DataLog Manager \/ Modulo: DataLog Storage SQLite ", 
"snippet" : "DataLog Storage SQLite Il sottomodulo DataLogStorage_SQLite definisce il formato di archiviazione di a Canale di registrazione dati per un database SQLite. Può essere aggiunto sotto un nodo del canale DataLog. Questo viene fatto da Aggiungi istanza del sottomodulo comando e la selezione del file Dat...", 
"body" : "DataLog Storage SQLite Il sottomodulo DataLogStorage_SQLite definisce il formato di archiviazione di a Canale di registrazione dati per un database SQLite. Può essere aggiunto sotto un nodo del canale DataLog. Questo viene fatto da Aggiungi istanza del sottomodulo comando e la selezione del file DataLogStorage_SQLite modulo. Finestra di dialogo: Informazioni Per informazioni dettagliate su questa finestra di dialogo, vedere: Informazione . " }, 
{ "title" : "Finestra di dialogo: parametri ", 
"url" : "ac_dlm_storage_sqlite_module.html#UUID-63e71af3-388f-498c-6553-5ab20ff603a1_accbd5f8d8b6d029c0a86463569e125f_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ DataLog Manager \/ Modulo: DataLog Storage SQLite \/ Finestra di dialogo: parametri ", 
"snippet" : "Nome dell'archivio : Nome del file di archivio Per impostazione predefinita, il segnaposto %CHANNEL_NAME% è definito. Questo segnaposto verrà sostituito dal nome dell'istanza del canale DataLog superiore. Il nome dell'archivio deve essere univoco, poiché tutti i file di archivio vengono archiviati p...", 
"body" : "Nome dell'archivio : Nome del file di archivio Per impostazione predefinita, il segnaposto %CHANNEL_NAME% è definito. Questo segnaposto verrà sostituito dal nome dell'istanza del canale DataLog superiore. Il nome dell'archivio deve essere univoco, poiché tutti i file di archivio vengono archiviati per impostazione predefinita nella directory di installazione del controller. Tutte le istanze di questo modulo di un'applicazione condividono questo file. Questo file viene inizialmente creato da uno dei moduli di archiviazione. Il nome del file è sempre <ApplicationName>_DataLog.sqlite Numero massimo di voci : Il numero massimo di voci per il database di questa istanza del modulo. Il valore 0 disattiva la funzione. Se si supera il numero massimo, la tabella si comporta come un buffer ad anello e le prime registrazioni verranno sovrascritte. " }, 
{ "title" : "Definizione delle variabili di registrazione ", 
"url" : "ac_dlm_definition_logging_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ DataLog Manager \/ Definizione delle variabili di registrazione ", 
"snippet" : "Le variabili sono contrassegnate per registrazione dati per attributi. ac_datalog [:= group name] : questo attributo assegna la variabile a un gruppo di registrazione. Se la variabile è una variabile strutturata, verranno registrati tutti i membri che possono essere registrati e che non sono esclusi...", 
"body" : "Le variabili sono contrassegnate per registrazione dati per attributi. ac_datalog [:= group name] : questo attributo assegna la variabile a un gruppo di registrazione. Se la variabile è una variabile strutturata, verranno registrati tutti i membri che possono essere registrati e che non sono esclusi. Se non viene impostato alcun nome di gruppo, ciascuna istanza della variabile strutturata deve essere contrassegnata separatamente. ac_datalog_set_default_group : imposta il gruppo di tutti i membri di un'istanza di tipo strutturato che non sono esplicitamente assegnati a un gruppo. ac_datalog_exclude : questo attributo esclude una variabile di tipo dati strutturato dalla registrazione dei dati. ac_datalog_union_representant : questo attributo definisce un rappresentante all'interno di un'UNIONE, che viene utilizzato per la registrazione dei dati. ac_datalog_hysteresis := ‘value‘ : Questo attributo imposta l'isteresi. Il valore deve essere superato per registrare una variabile. Questo attributo viene rispettato solo per i tipi di dati numerici. Se viene utilizzato per tipi di dati non numerici, verrà visualizzato un avviso e il valore verrà ignorato. Troverai una descrizione aggiuntiva ed esempi nella pagina di aiuto del Gestore della persistenza attributi. " }, 
{ "title" : "Generatore di diagnosi del dispositivo ", 
"url" : "ac_device_diagnose_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Generatore di diagnosi del dispositivo ", 
"snippet" : "Il modulo di diagnosi del dispositivo è un componente standard dell'Application Composer, incluso nella libreria AC_DeviceDiagnosis . Il modulo è un modulo di primo livello e può essere aggiunto all'albero dei moduli tramite il comando Aggiungi l'istanza del modulo di primo livello . Modulo di diagn...", 
"body" : "Il modulo di diagnosi del dispositivo è un componente standard dell'Application Composer, incluso nella libreria AC_DeviceDiagnosis . Il modulo è un modulo di primo livello e può essere aggiunto all'albero dei moduli tramite il comando Aggiungi l'istanza del modulo di primo livello . Modulo di diagnosi del dispositivo nell'albero dei moduli Con l'aiuto del modulo di diagnosi del dispositivo viene creata, sulla base della configurazione del dispositivo esistente, una pagina di visualizzazione che rappresenta il PLC e i dispositivi bus di campo collegati in una struttura ad albero. In questa struttura ad albero viene visualizzato lo stato di ciascun componente. Se necessario è possibile richiamare informazioni dettagliate o modificare la modalità operativa dei singoli componenti. Pagina di visualizzazione generata per la diagnosi del dispositivo Diagnosi del dispositivo in modalità online Nella modalità online vengono visualizzati il nome del dispositivo, lo stato e il codice di errore. Lo stato dei dispositivi è mostrato in una combinazione di colori: Verde: il dispositivo ha lo stato \"In esecuzione\" Rosso: il dispositivo non ha lo stato \"In esecuzione\" Finestra di dialogo per modificare lo stato Facendo clic sul dispositivo si apre una finestra in cui è possibile arrestare il dispositivo, ( Fermare ), Ripristina ( Ripristina ) o iniziato ( Inizio) . Quando la finestra di dialogo viene aperta per la prima volta, vengono visualizzate tutte le funzioni. Le funzioni che non sono supportate dall'hardware scompariranno alla prima attivazione. " }, 
{ "title" : "Requisiti ", 
"url" : "ac_device_diagnose_overview.html#UUID-fd01086a-c692-d615-c1cf-d5963632aa4b_ac778b834d585cc0a8640e01a520c3_id_be299b7583c984f0c0a86520016ce88a", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Generatore di diagnosi del dispositivo \/ Requisiti ", 
"snippet" : "I dettagli diagnostici visualizzati provengono dai CAA-Device-Diagnose-FB (Device-FB) creati dai dispositivi. Per generare questi componenti, l'opzione Attiva la diagnosi per i dispositivi deve essere impostato nelle impostazioni del PLC. Questi FB forniscono non solo le normali informazioni sullo s...", 
"body" : "I dettagli diagnostici visualizzati provengono dai CAA-Device-Diagnose-FB (Device-FB) creati dai dispositivi. Per generare questi componenti, l'opzione Attiva la diagnosi per i dispositivi deve essere impostato nelle impostazioni del PLC. Questi FB forniscono non solo le normali informazioni sullo stato visualizzate nella panoramica (sopra), ma anche informazioni dettagliate, visualizzate in una schermata aggiuntiva. Se l'opzione Attiva la diagnosi per i dispositivi non è stato impostato prima della generazione, il processo di generazione viene interrotto e l'opzione viene impostata automaticamente, in modo che l'esecuzione della generazione successiva crei la visualizzazione desiderata. Per generare questa pagina di visualizzazione è necessario attivare il generatore di diagnosi del dispositivo nel Configurazione del generatore . " }, 
{ "title" : "Comandi ", 
"url" : "core_applicationcomposer_composer_home.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi ", 
"snippet" : "I comandi nella categoria comandi Compositore sono forniti con il CODESYS Application Composer . Questi comandi servono principalmente per aggiungere oggetti del compositore al file Albero dei moduli o per modificarli. Inoltre ci sono funzioni per mappare le variabili alla configurazione IO e per co...", 
"body" : "I comandi nella categoria comandi Compositore sono forniti con il CODESYS Application Composer . Questi comandi servono principalmente per aggiungere oggetti del compositore al file Albero dei moduli o per modificarli. Inoltre ci sono funzioni per mappare le variabili alla configurazione IO e per costruire un file CODESYS applicazione. La disponibilità dei comandi dipende dall'oggetto selezionato nell'albero del modulo: verranno selezionati solo i comandi consentiti nella posizione attualmente selezionata. " }, 
{ "title" : "Visualizzazione dedicata del compositore di applicazioni ", 
"url" : "ac_dedicated_view.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Visualizzazione dedicata del compositore di applicazioni ", 
"snippet" : "L'Application Composer fornisce il modo più semplice possibile per creare intere applicazioni ed eseguirle. Dedicato a questi aspetti di semplicità, CODESYS offre una visualizzazione ridotta dell'interfaccia utente. Questa visualizzazione può essere avviata selezionando il profilo \"CODESYS Composer ...", 
"body" : "L'Application Composer fornisce il modo più semplice possibile per creare intere applicazioni ed eseguirle. Dedicato a questi aspetti di semplicità, CODESYS offre una visualizzazione ridotta dell'interfaccia utente. Questa visualizzazione può essere avviata selezionando il profilo \"CODESYS Composer Dedicated\" o tramite il collegamento corrispondente nel file CODESYS voci del menu di avvio. Successivamente una visione ridotta di CODESYS , che fornisce l'accesso solo alle finestre e ai comandi assolutamente necessari per creare un'applicazione funzionante utilizzando il file CODESYS Application Composer Viene visualizzato il compositore di applicazioni. Visualizzazione dedicata del compositore di applicazioni Sono presenti solo finestre per l'albero dei moduli, l'albero dei dispositivi e i messaggi insieme ai comandi per il login\/logout\/esegui\/arresta online e le operazioni del Composer. All'interno di quest'ultima, due comandi sono fortemente legati alla vista \"Application Composer dedicata\": Genera, compila e accedi : Utilizzato per generare codice, compilarlo ed eventualmente accedere al dispositivo e avviare l'applicazione sul dispositivo. Aggiungi libreria moduli al progetto : Utilizzato per aggiungere librerie al Gestore libreria del pool POU, che normalmente non è disponibile nella vista \"Application Composer dedicato\". Qualsiasi libreria aggiunta contenente moduli, rende i moduli disponibili per essere aggiunti nell'albero dei moduli. " }, 
{ "title" : "Albero dei moduli ", 
"url" : "ac_module_tree.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Albero dei moduli ", 
"snippet" : "Oltre all'albero dei dispositivi e all'albero delle POU, Application Composer offre l'albero dei moduli. Questo albero serve per creare o modificare un'applicazione utilizzando i moduli predefiniti. I comandi dell'Application Composer consentono di aggiungere sottomoduli all'albero dei moduli oppure...", 
"body" : "Oltre all'albero dei dispositivi e all'albero delle POU, Application Composer offre l'albero dei moduli. Questo albero serve per creare o modificare un'applicazione utilizzando i moduli predefiniti. I comandi dell'Application Composer consentono di aggiungere sottomoduli all'albero dei moduli oppure di modificarli o eliminarli. La struttura ad albero può essere compressa o espansa. Esempio di albero dei moduli A seconda dell'oggetto selezionato, è possibile aggiungere all'albero moduli compatibili. Questo può essere fatto utilizzando il file comandi nel menu \"Compositore\" o utilizzando il menu contestuale. Le icone degli elementi sono definite nella dichiarazione del modulo. " }, 
{ "title" : "Elementi dell'albero dei moduli ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_a88610fbb413e565c0a8640e00f61f5a", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Albero dei moduli \/ Elementi dell'albero dei moduli ", 
"snippet" : "(1): moduli di primo livello che definiscono le impostazioni dell'applicazione e delle attività (2): Sottomoduli (3): riferimenti di istanza che fanno riferimento a sottomoduli. I riferimenti alle istanze non hanno parametri o I\/O propri. (4): Estensioni che possono essere create senza Application C...", 
"body" : "(1): moduli di primo livello che definiscono le impostazioni dell'applicazione e delle attività (2): Sottomoduli (3): riferimenti di istanza che fanno riferimento a sottomoduli. I riferimenti alle istanze non hanno parametri o I\/O propri. (4): Estensioni che possono essere create senza Application Composer e che consentono di apportare modifiche alla macchina (5): Slot (singolo o multi slot) che può essere obbligatorio o facoltativo " }, 
{ "title" : "Visualizzazione della struttura ad albero ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_8a0710cab44f1a9bc0a8640e00ddf9a1", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Albero dei moduli \/ Visualizzazione della struttura ad albero ", 
"snippet" : "I nodi figli, che vengono visualizzati sotto un'istanza di modulo espanso, verranno visualizzati secondo le seguenti regole, per cui l'ordine di tutti gli slot occupati e non occupati corrisponde sempre all'ordine di dichiarazione della dichiarazione del modulo: Nel caso in cui venga fatto solo rife...", 
"body" : "I nodi figli, che vengono visualizzati sotto un'istanza di modulo espanso, verranno visualizzati secondo le seguenti regole, per cui l'ordine di tutti gli slot occupati e non occupati corrisponde sempre all'ordine di dichiarazione della dichiarazione del modulo: Nel caso in cui venga fatto solo riferimento all'istanza del modulo in questa posizione, non ha figli. Vengono visualizzati tutti gli slot non occupati, ad eccezione degli slot opzionali che sono esplicitamente nascosti. Per gli slot vengono visualizzati il nome del ruolo e il tipo. Gli slot occupati con cardinalità 1 non vengono visualizzati (vengono invece visualizzate le istanze del sottomodulo collegate). L'istanza del sottomodulo collegata sostituisce visivamente lo slot. I sottomoduli opzionali e obbligatori vengono visualizzati nell'albero dei moduli nella posizione degli slot. Il nome del ruolo viene visualizzato tra parentesi dopo il nome dell'istanza del modulo. Le istanze dei sottomoduli di un multislot vengono visualizzate sotto il rispettivo slot. Viene visualizzato il nome del ruolo perché è definito nel nodo principale. Le seguenti proprietà degli slot sono indicate con icone aggiuntive: Slot opzionali Slot obbligatori Slot multipli Riferimenti a istanze di sottomodulo Se un'istanza del modulo viene eliminata, tutti i riferimenti a questa istanza del modulo verranno contrassegnati con un'icona di errore. Se il tipo di un'istanza del modulo viene modificato, tutti i riferimenti a questo modulo con tipo errato verranno contrassegnati con un'icona di errore. A seconda della posizione nell'albero dei moduli il Taglio \/ copia \/ Impasto È possibile utilizzare i comandi del menu contestuale. Gli elementi dell'albero dei moduli possono essere spostati tramite Drag&Drop. Premendo il Ctrl Il tasto durante un'operazione di trascinamento copierà l'elemento. Gli elementi dell'albero dei moduli possono anche essere esportati e importati CODESYS . " }, 
{ "title" : "Finestra di dialogo del modulo ", 
"url" : "ac_module_dialog.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Finestra di dialogo del modulo ", 
"snippet" : "Utilizzando i comandi Aggiungi istanza di primo livello , Aggiungi istanza del sottomodulo , Istanza di riferimento , E Modulo di aggiornamento , si apre una finestra di dialogo non modale. A seconda della posizione nell'albero dei moduli verranno visualizzati tutti i moduli compatibili. Con un dopp...", 
"body" : "Utilizzando i comandi Aggiungi istanza di primo livello , Aggiungi istanza del sottomodulo , Istanza di riferimento , E Modulo di aggiornamento , si apre una finestra di dialogo non modale. A seconda della posizione nell'albero dei moduli verranno visualizzati tutti i moduli compatibili. Con un doppio clic sul modulo o con il pulsante Aggiungi modulo risp. Aggiungi istanza del sottomodulo il modulo selezionato verrà copiato nell'albero dei moduli. Il tasto Aggiungi modulo ( O Modulo di riferimento ) è abilitato solo se è selezionato un modulo compatibile e se lo slot selezionato nella struttura dei moduli non è pieno. Inoltre deve essere inserito un nome valido (con identificatore IEC valido). Il nome dell'oggetto può essere definito solo per le nuove istanze del modulo. Nella finestra di dialogo del Modulo di aggiornamento comando, il nome non può essere modificato. Mostra solo le istanze compatibili : questa opzione filtra, se attivata, le istanze visualizzate, in modo che vengano mostrate solo le istanze compatibili. Se è disattivato vengono mostrate tutte le istanze, dove le istanze compatibili sono evidenziate in grassetto. Applicazione : l'istanza del modulo di primo livello viene generata in questa applicazione. Clic per selezionare un'applicazione esistente. Finestra di dialogo per aggiungere istanze del modulo La finestra di dialogo non è modale. Permette la selezione di altri oggetti nell'albero senza dover chiudere la finestra di dialogo. Gli elementi elencati nella finestra di dialogo e le azioni possibili vengono adattati automaticamente. Il comportamento di questa finestra di dialogo è identico a Aggiungi dispositivo dialogo. " }, 
{ "title" : "Comando: Genera ", 
"url" : "ac_generate.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Genera ", 
"snippet" : "creare Simbolo: Questo comando (categoria \"Compositore\") avvia un processo di compilazione che genera automaticamente il file CODESYS applicazione dall'albero dei moduli e dalle impostazioni del file Configurazione del generatore . I messaggi e gli errori verranno visualizzati nella vista messaggi. ...", 
"body" : "creare Simbolo: Questo comando (categoria \"Compositore\") avvia un processo di compilazione che genera automaticamente il file CODESYS applicazione dall'albero dei moduli e dalle impostazioni del file Configurazione del generatore . I messaggi e gli errori verranno visualizzati nella vista messaggi. Tutti gli oggetti creati dal generatore standard (eccetto gli oggetti attività e le applicazioni) verranno archiviati nella sottocartella dell'applicazione risp. Pool di POU denominato AC_Std E AC_FBs . Se esiste già una cartella con lo stesso nome, verrà creato un nome univoco aggiungendo un suffisso _0 . Blocchi funzione generati Tutti gli oggetti creati da creare i comandi sono contrassegnati da un'icona blu in sovrimpressione. Se l'utente tenta di eliminare, spostare o modificare uno di questi oggetti si aprirà una finestra di dialogo che informa che questa azione potrebbe causare problemi di compilazione. Se l'utente continua, il colore dell'icona in sovrapposizione diventa rosso (vedere blocco funzione AC_PRG_RMP (PRG) nello screenshot qui sopra). Se usi Application Composer insieme a CODESYS SVN : Tutti gli oggetti generati da Composer sono contrassegnati con un Ignore on Commit per SVN. Inoltre SVN passa alla modalità offline per evitare blocchi SVN mentre viene eseguito il comando Costruito. Creazione dell'infrastruttura di comunicazione Definizione: nella seguente descrizione l'applicazione A1 invia all'applicazione A2 (o A2 riceve da A1) se sono soddisfatte le seguenti condizioni: Un'istanza del modulo assegnata all'applicazione A1 fa riferimento a un'istanza del modulo assegnata all'applicazione A2 o viceversa. Un'uscita di un'istanza del modulo assegnata ad A1 è collegata a un'istanza del modulo assegnata ad A2 mediante una connessione I\/O diretta del modulo. Tutti gli oggetti menzionati di seguito verranno creati nella cartella AC_RMP per ogni applicazione creata dal generatore. Verrà creata un'attività di comunicazione. (Tempo di ciclo e priorità in base alle impostazioni della configurazione del generatore). In questa attività verranno chiamate le istanze proxy e verranno lette le variabili FB proxy del modulo mirrorato. scritto. Per ciascuna applicazione che invia all'applicazione corrente, verrà creato un GVL (di invio) e verranno definite le impostazioni di rete. (Protocollo \"UDP\", trasmissione ciclica, checksum, tempo di ciclo secondo le impostazioni, compito di comunicazione). L'\"identificatore della lista\" che deve essere un valore intero compreso tra 1 e 2^15-1 verrà determinato in modo casuale all'inizio della generazione e incrementato di 1 dopo ogni invio GVL. Questo valore è almeno 128 ed è compreso nell'intervallo valido. Se sono presenti riferimenti a moduli tra le applicazioni una variabile di tipo RMPExchangeData verrà creato nel GVL. Il nome della variabile contiene il nome dell'applicazione sorgente e di destinazione. Se un'istanza del modulo definisce le variabili nella sua definizione proxy di cui eseguire il mirroring ( MirrorVar ) ed è referenziato da un'altra istanza del modulo, per ciascuna di queste MirrorVars verrà creata una variabile nel GVL (di invio) dell'istanza del modulo a cui si fa riferimento. Il suo nome contiene il percorso dell'istanza del modulo e il TargetID della corrispondente definizione \"MirrorVar\". Per ciascuna applicazione A2, a cui invia l'applicazione corrente, verrà creata una NVL (di ricezione) e collegata al corrispondente GVL di invio di A2 e all'attività di comunicazione. Un blocco funzione di tipo RMPService verrà istanziato in GVL AC_RMP e inizializzato nella dichiarazione (con attributo init_on_onlchange ). Due matrici di tipo RMPConnection verranno creati che fanno riferimento alle variabili di tipo create RMPExchangeData nelle GVL e nelle NVL. Un programma AC_PRG_RMP verrà creato il blocco funzione di tipo RMPService . Questo programma verrà aggiunto all'attività di comunicazione. Inoltre il valore delle variabili specchiate (\"MirrorVars\") verrà impostato e letto nel file AC_PRG_RMP programma. Ciò significa che il proxy \"MirrorVars\" verrà assegnato alle variabili corrispondenti del GVL (di ricezione). Poi il Main viene chiamato il metodo dell'istanza proxy e infine le variabili corrispondenti del GVL (mittente) del modulo \"MirrorVars\". Ciò avviene in base alla direzione di invio delle istanze del modulo ai proxy. " }, 
{ "title" : "Creazione di istanze di blocchi funzione tramite il generatore standard ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_65e9c9d2b9a5b65fc0a8640e0003897d", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Genera \/ Creazione di istanze di blocchi funzione tramite il generatore standard ", 
"snippet" : "Per ogni istanza del modulo verrà creato un blocco funzione (nella cartella AC_FBs ). Questo blocco funzione deriva dal blocco funzione del modulo. Il blocco funzione contiene variabili di ingresso Istanze di sottomodulo Array di dimensioni configurabili Variabili buffer delle connessioni I\/O dirett...", 
"body" : "Per ogni istanza del modulo verrà creato un blocco funzione (nella cartella AC_FBs ). Questo blocco funzione deriva dal blocco funzione del modulo. Il blocco funzione contiene variabili di ingresso Istanze di sottomodulo Array di dimensioni configurabili Variabili buffer delle connessioni I\/O dirette Array di multislot e riferimenti a istanze Il nome della rispettiva variabile di array viene creato dal prefisso AC_ARRAY_ seguito dal nome della variabile della rispettiva variabile puntatore. Per gli array con dimensione dell'indice variabile (VarArray) il nome può essere sovrascritto dal parametro VarArray.InstName . La parte di implementazione del blocco funzione contiene il comando SUPER^(); che richiama la parte di implementazione del blocco funzione del modulo. Esempio L'istanza del modulo ModuleInstanceA è di tipo ModuleA e relativo blocco funzione ModuleA_FB . Questa istanza ha un'istanza di sottomodulo di tipo ModuleB . L'istanza del modulo ModuleInstanceA è di tipo ModuleA e relativo blocco funzione ModuleA_FB . Questa istanza ha un'istanza di sottomodulo di tipo ModuleB . FUNCTION_BLOCK AC_ModuleInstanceA EXTENDS ModuleA_FB\n\nVAR_INPUT\n Inst_Sub1 : AC_ModuleInstanceB ;\nEND_VAR Il nome del blocco funzione viene creato dal percorso dell'istanza del modulo e dal prefisso AC_ . Il nome della variabile dell'istanza del sottomodulo è creato da un prefisso seguito dal nome della rispettiva istanza del sottomodulo. Ogni blocco funzione viene istanziato una volta, l'istanza FB del modulo di livello superiore direttamente nel GVL, il resto nei blocchi funzione corrispondenti delle istanze padre. Per ogni istanza del modulo referenziato che si trova in un'altra applicazione, verrà creata esattamente un'istanza del blocco funzione dell'FB proxy in un GVL dell'istanza del modulo di riferimento. Il nome dell'istanza proxy è AC_PROXY_<InstanceName> dove <InstanceName> è il nome dell'istanza di destinazione nell'altra applicazione. A tutte le istanze del modulo vengono assegnati indirizzi univoci. Le istanze FB proxy vengono assegnate dagli indirizzi delle istanze del modulo nell'applicazione remota. Il metodo IBaseInstance.Main delle istanze proxy viene richiamato ciclicamente nel task di comunicazione. " }, 
{ "title" : "Creazione dell'applicazione e chiamate di attività ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_c88cdc4bba310f0dc0a8640e0094f683", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Genera \/ Creazione dell'applicazione e chiamate di attività ", 
"snippet" : "Se un modulo viene assegnato a un'applicazione che non esiste, questa applicazione verrà creata. Creazione di attività standard inesistenti TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW La priorità e il tempo di ciclo delle attività vengono impostati in base alle impostazioni del generatore. I...", 
"body" : "Se un modulo viene assegnato a un'applicazione che non esiste, questa applicazione verrà creata. Creazione di attività standard inesistenti TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW La priorità e il tempo di ciclo delle attività vengono impostati in base alle impostazioni del generatore. Inoltre verranno create attività specifiche del modulo con le impostazioni specificate. Creazione di un elenco di variabili globali per livello superiore. In questo GVL verranno create le istanze del modulo che si trovano sotto le istanze del modulo di livello superiore della stessa applicazione. L'elenco delle variabili globali ha il nome definito nel modulo o, se non ha un nome definito, otterrà il nome GVL_MODULE . Il GVL si trova sotto l'applicazione selezionata o nell'albero POU globale. Creazione di un GVL con il nome GVL_ MODULE_TREE per ogni applicazione. Questo elenco contiene variabili per gestire l'albero dei moduli. Il GVL verrà creato nella cartella AC_Std . Creazione del codice di inizializzazione che viene richiamato automaticamente al momento del download e della modifica online: Verrà creata la struttura ad albero. Verranno impostati i valori dei parametri. Verranno assegnati riferimenti e istanze di sottomodulo. Verranno riempiti gli array con dimensione variabile. Verranno impostati i riferimenti alle istanze. Durante il download verranno impostati solo i parametri che non sono impostati sul loro valore predefinito. Durante la modifica online verranno impostati tutti i parametri. Le POU verranno create nella cartella AC_Std . Per ciascun punto di ingresso definito a PROGRAM Verrà creata la POU (linguaggio ST) che contiene le chiamate dei moduli di primo livello. La chiamata di questa nuova POU verrà aggiunta sotto l'attività. Nel caso dell'attività standard i nomi delle POU sono: MODULE_CALL_<TASKNAME>_START MODULE_CALL_<TASKNAME>_END Le POU verranno create nella cartella AC_Std . Per i moduli di primo livello in POU pool le chiamate alle attività verranno create in tutte le applicazioni. " }, 
{ "title" : "Creazione dell'assegnazione I\/O ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_bf24656dba310f0fc0a8640e01fdf5a6", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Genera \/ Creazione dell'assegnazione I\/O ", 
"snippet" : "A seconda del tipo di assegnazione degli I\/O verranno eseguite le seguenti azioni: [Canale I\/O]: nel canale del dispositivo corrispondente verrà aggiunto il nome dell'istanza degli I\/O dell'istanza del modulo. [Espressione ST]: le assegnazioni delle espressioni agli input o degli output alle espress...", 
"body" : "A seconda del tipo di assegnazione degli I\/O verranno eseguite le seguenti azioni: [Canale I\/O]: nel canale del dispositivo corrispondente verrà aggiunto il nome dell'istanza degli I\/O dell'istanza del modulo. [Espressione ST]: le assegnazioni delle espressioni agli input o degli output alle espressioni saranno per tutte le istanze del modulo sotto la stessa istanza di livello superiore. Se sono presenti assegnazioni corrispondenti, per ciascuna istanza di livello superiore viene assegnata una funzione denominata AC_Io_SetInputs_<instance name> O AC_Io_SetOutputs_<instance name> verrà creato. L'attività che definisce input e output sarà identificata dal flag UPDATE-IOS nella descrizione del modulo. Questa attività verrà chiamata \"attività I\/O\" nella seguente descrizione. La funzione per gli ingressi verrà chiamata nel task I\/O prima che venga chiamato il metodo del task dell'istanza del modulo. (Se il task I\/O è un task standard, prima del metodo di avvio.) La funzione per le uscite verrà richiamata nel task I\/O dopo il metodo del task dell'istanza del modulo. (Se l'attività I\/O è un'attività standard, dopo il metodo finale.) [Connessione diretta agli I\/O del modulo, locale]: una variabile buffer di tipo compatibile verrà creata nel blocco funzione dell'istanza dell'ingresso. Il nome della variabile buffer inizia con il prefisso AC_Io_Buffer_ . Le variabili del buffer verranno inizializzate sui valori correnti delle uscite collegate durante l'inizializzazione dell'applicazione. Il generatore gestisce le assegnazioni di input e output come un'assegnazione ST a questa variabile buffer (vedere [Espressione ST]. [Connessioni dirette all'I\/O del modulo, remoto]: per ciascuna uscita collegata a un ingresso di un'istanza del modulo da un'altra applicazione, verrà creata una variabile buffer di tipo compatibile nella corrispondente rete di invio GVL. Il nome della variabile buffer inizia con il prefisso AC_RemoteIo_Buffer_ e sarà costruito dal percorso dell'istanza e dal percorso variabile dell'output. Le variabili buffer verranno inizializzate con l'espressione di inizializzazione della variabile di output, se esiste. Se il valore di questa espressione di inizializzazione non è contenuto nelle informazioni di precompilazione (perché l'espressione utilizza ad esempio: variabili, funzioni e costanti), viene creato un errore. Il generatore gestisce l'assegnazione dell'output come un'assegnazione a questa variabile buffer. L'assegnazione dell'ingresso nell'altra applicazione viene gestita come un'assegnazione dalla variabile corrispondente nel ricevitore NVL (vedi [Espressione ST]). Nota: la sincronizzazione tra il task in cui la variabile di rete verrà aggiornata e il task I\/O del modulo non è ancora stata realizzata. Pertanto è possibile che i valori siano stati scritti in modo incompleto mentre il task I\/O li legge. " }, 
{ "title" : "Comando: Configurazione generatore ", 
"url" : "ac_generator_configuration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Configurazione generatore ", 
"snippet" : "Configurazione del generatore Questo comando (categoria \"Compositore\") apre una finestra di dialogo con tutti i generatori disponibili. In questa finestra di dialogo è possibile abilitare o disabilitare ogni singolo generatore. Un clic sull'icona \"Strumenti\" apre una finestra di dialogo dettagliata ...", 
"body" : "Configurazione del generatore Questo comando (categoria \"Compositore\") apre una finestra di dialogo con tutti i generatori disponibili. In questa finestra di dialogo è possibile abilitare o disabilitare ogni singolo generatore. Un clic sull'icona \"Strumenti\" apre una finestra di dialogo dettagliata con impostazioni specifiche sul generatore attualmente selezionato e abilitato. " }, 
{ "title" : "Generatore di dispositivi ", 
"url" : "ac_generator_configuration.html#UUID-808f4cf5-ae70-df89-d868-14922e672101", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Configurazione generatore \/ Generatore di dispositivi ", 
"snippet" : "Questo generatore tenta di generare i dispositivi necessari e li collega agli IO del modulo, se possibile. Nella versione corrente del plug-in Application Composer, non è disponibile alcuna finestra di dialogo di configurazione per il generatore di dispositivi....", 
"body" : "Questo generatore tenta di generare i dispositivi necessari e li collega agli IO del modulo, se possibile. Nella versione corrente del plug-in Application Composer, non è disponibile alcuna finestra di dialogo di configurazione per il generatore di dispositivi. " }, 
{ "title" : "Generatore di modelli di origine ", 
"url" : "ac_generator_configuration.html#UUID-dcd74dd8-c2bf-daf3-03d2-c4b54ecf55a8", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Configurazione generatore \/ Generatore di modelli di origine ", 
"snippet" : "Questo generatore copia i blocchi funzione esistenti dal file POU pool all'applicazione. I blocchi funzione copiati vengono aggiunti nel file AC_SourceTemplate cartella. In questa cartella la funzione aggiuntiva AC_SourceTemplateInit viene aggiunto anche. Questo blocco funzione viene utilizzato per ...", 
"body" : "Questo generatore copia i blocchi funzione esistenti dal file POU pool all'applicazione. I blocchi funzione copiati vengono aggiunti nel file AC_SourceTemplate cartella. In questa cartella la funzione aggiuntiva AC_SourceTemplateInit viene aggiunto anche. Questo blocco funzione viene utilizzato per inizializzare i blocchi funzione copiati. I blocchi funzione creati possono essere modificati e non vengono sovrascritti da un nuovo funzionamento del generatore. I blocchi funzione non utilizzati vengono rinominati e spostati nel file UnusedSourceTemplate sottocartella. Poi la proroga _unused è aggiunto. Presupposto: il generatore standard deve essere attivato. " }, 
{ "title" : "Generatore standard ", 
"url" : "ac_generator_configuration.html#UUID-a3c9c7e9-e567-6ffc-3f6c-ae4016d57a70", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Configurazione generatore \/ Generatore standard ", 
"snippet" : "Impostazioni predefinite dell'attività Compito ad alta priorità Definizione di priorità e intervallo delle attività definite dall'utente I compiti definiti dall'utente possono essere impostati nell'editor dei moduli di primo livello (vedi Distribuzione). Compito di media priorità Compito a bassa pri...", 
"body" : "Impostazioni predefinite dell'attività Compito ad alta priorità Definizione di priorità e intervallo delle attività definite dall'utente I compiti definiti dall'utente possono essere impostati nell'editor dei moduli di primo livello (vedi Distribuzione). Compito di media priorità Compito a bassa priorità Impostazioni di comunicazione Abilita la comunicazione RMP : Verranno creati gli elementi necessari per la comunicazione RMP. Priorità del compito Priorità del compito RMP Intervallo di attività Intervallo dell'attività RMP Pragma del compilatore GVL Definizione dei pragma del compilatore Questi pragma verranno inseriti prima dei GVL o dei blocchi funzione generati. Blocchi funzione Configurazione dei simboli Crea la configurazione dei simboli : L'oggetto di configurazione del simbolo verrà aggiunto all'applicazione. " }, 
{ "title" : "Generatore di persistenza ", 
"url" : "ac_generator_configuration.html#UUID-e4484f57-2155-dad9-990f-264462e75e1e", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Configurazione generatore \/ Generatore di persistenza ", 
"snippet" : "Il generatore di persistenza legge la configurazione di persistenza dall'albero dei moduli e crea un oggetto di configurazione di persistenza sotto ciascuna applicazione che utilizza la persistenza. Per ulteriori informazioni, vedere anche: Gestore della persistenzaUn'applicazione utilizza la funzio...", 
"body" : "Il generatore di persistenza legge la configurazione di persistenza dall'albero dei moduli e crea un oggetto di configurazione di persistenza sotto ciascuna applicazione che utilizza la persistenza. Per ulteriori informazioni, vedere anche: Gestore della persistenzaUn'applicazione utilizza la funzionalità di persistenza del compositore dell'applicazione se un'istanza di Persistence Manager è mappata a tale applicazione. " }, 
{ "title" : "Generatore di registri dati ", 
"url" : "ac_generator_configuration.html#UUID-0a4d1c9e-c363-489e-e742-4b6d5c1afaa4", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Configurazione generatore \/ Generatore di registri dati ", 
"snippet" : "Il generatore DataLog crea un oggetto di configurazione DataLog dalla configurazione dell'albero del modulo. Questo oggetto verrà aggiunto all'applicazione a cui appartiene l'istanza di Gestore registro dati è mappato. Nella versione attuale di CODESYS Application Composer , non è disponibile alcuna...", 
"body" : "Il generatore DataLog crea un oggetto di configurazione DataLog dalla configurazione dell'albero del modulo. Questo oggetto verrà aggiunto all'applicazione a cui appartiene l'istanza di Gestore registro dati è mappato. Nella versione attuale di CODESYS Application Composer , non è disponibile alcuna finestra di configurazione per il generatore DataLog. " }, 
{ "title" : "Generatore di tendenze ", 
"url" : "ac_generator_configuration.html#UUID-b0155d06-1fc0-2914-55ee-2233ae0d22ee", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Configurazione generatore \/ Generatore di tendenze ", 
"snippet" : "Il generatore di trend legge le definizioni di trend dalle descrizioni dei moduli e crea una configurazione di trend con relative visualizzazioni. Queste visualizzazioni verranno incorporate nelle visualizzazioni esistenti....", 
"body" : "Il generatore di trend legge le definizioni di trend dalle descrizioni dei moduli e crea una configurazione di trend con relative visualizzazioni. Queste visualizzazioni verranno incorporate nelle visualizzazioni esistenti. " }, 
{ "title" : "Generatore di allarmi ", 
"url" : "ac_generator_configuration.html#UUID-62c4fd14-9eaa-46b5-f370-4e36a88614fe", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Configurazione generatore \/ Generatore di allarmi ", 
"snippet" : "Il generatore di allarmi legge le definizioni di allarme dalle descrizioni dei moduli e crea o espande i componenti associati della gestione degli allarmi. Inoltre, viene creata una visualizzazione da un modello. In questa visualizzazione è inserita una tabella allarmi. La visualizzazione verrà aggi...", 
"body" : "Il generatore di allarmi legge le definizioni di allarme dalle descrizioni dei moduli e crea o espande i componenti associati della gestione degli allarmi. Inoltre, viene creata una visualizzazione da un modello. In questa visualizzazione è inserita una tabella allarmi. La visualizzazione verrà aggiunta agli altri modelli di visualizzazione del generatore di visualizzazioni come visualizzazione di primo livello . Modello Modello per la schermata di visualizzazione. Nota: per utilizzare una visualizzazione come modello, è necessario che soddisfi le seguenti condizioni: Un rettangolo con il nome Placeholder_AlarmTable Le variabili bAckVisible , bAckSel , bHistory , E bFreezeScrlPos di tipo BOOL Modello di archiviazione degli allarmi Oggetti di tipo AlarmStorageTemplate , che si trovano nel progetto corrente e nelle librerie di riferimento Il modello selezionato verrà utilizzato per tutte le configurazioni di allarme generate. Crea scheda di primo livello : Verrà creata una scheda di livello superiore per la visualizzazione degli allarmi creati. Il nome definito verrà visualizzato nella scheda di livello superiore. " }, 
{ "title" : "Generatore di diagnosi del dispositivo ", 
"url" : "ac_generator_configuration.html#UUID-eacb5fd7-1329-2790-9483-fe45edbe632a", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Configurazione generatore \/ Generatore di diagnosi del dispositivo ", 
"snippet" : "Questo generatore crea schermate di visualizzazione per la diagnosi del dispositivo. Nelle impostazioni, il modelli di visualizzazione ed è possibile definire il layout delle schermate. Impostazioni del generatore di diagnosi del dispositivo Nella finestra di dialogo è possibile definire i modelli p...", 
"body" : "Questo generatore crea schermate di visualizzazione per la diagnosi del dispositivo. Nelle impostazioni, il modelli di visualizzazione ed è possibile definire il layout delle schermate. Impostazioni del generatore di diagnosi del dispositivo Nella finestra di dialogo è possibile definire i modelli per Visualizzazione di base, Modello PLC, Modello bus, Modello stack, Modello dispositivo padre e Modello dispositivo figlio. Le caselle combinate elencano tutti i modelli di visualizzazione disponibili che corrispondono ai rispettivi tipi di modello. Nella parte inferiore della finestra di dialogo è possibile definire la dimensione minima dello schermo di visualizzazione e lo spazio tra gli elementi di visualizzazione della diagnosi del dispositivo. " }, 
{ "title" : "Generatore di programmi CFC ", 
"url" : "ac_generator_configuration.html#UUID-fdaff0f3-814e-b71a-bcac-a2994393c9ed", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Configurazione generatore \/ Generatore di programmi CFC ", 
"snippet" : "Il generatore CFC viene utilizzato per creare programmi CFC. Rigenerare sempre tutti i pin CFC : : Application Composer tenta sempre di generare tutti gli I\/O dei blocchi funzione per le chiamate FB di istanze del modulo....", 
"body" : "Il generatore CFC viene utilizzato per creare programmi CFC. Rigenerare sempre tutti i pin CFC : : Application Composer tenta sempre di generare tutti gli I\/O dei blocchi funzione per le chiamate FB di istanze del modulo. " }, 
{ "title" : "Generatore di visualizzazioni ", 
"url" : "ac_generator_configuration.html#UUID-a364420f-f798-9fe6-3c1a-b98bc7c07391", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Configurazione generatore \/ Generatore di visualizzazioni ", 
"snippet" : "Questo generatore crea schermate di visualizzazione per il CODESYS Application Composer dalle visualizzazioni disponibili in CODESYS progetto. Nome di primo livello : immettere un nome simbolico per la visualizzazione modello (\"modello di primo livello\"). Modello : L'elenco di selezione offre tutte ...", 
"body" : "Questo generatore crea schermate di visualizzazione per il CODESYS Application Composer dalle visualizzazioni disponibili in CODESYS progetto. Nome di primo livello : immettere un nome simbolico per la visualizzazione modello (\"modello di primo livello\"). Modello : L'elenco di selezione offre tutte le visualizzazioni disponibili (nel progetto e nelle librerie caricate) e compatibili. Se selezioni Predefinito , il modello predefinito dalla libreria AC_Module sarà usato. Se un modello configurato qui nella finestra di dialogo viene successivamente rimosso dal progetto o dalla libreria, rimane disponibile in questa finestra di dialogo. TargetVisu , WebVisu : attivare la rispettiva opzione se il modello di pagina deve essere utilizzato per questa variante di visualizzazione. Larghezza: Larghezza della visualizzazione generata in pixel (valore predefinito: 640, minimo 100, massimo 10000) Altezza: Altezza della visualizzazione generata in pixel (valore predefinito: 480, minimo 100, massimo 10000) Larghezza minima del ToplevelTab : larghezza minima in pixel per le schede di primo livello generate. Se qui viene inserito 0, l'impostazione non viene presa in considerazione. Larghezza massima del ToplevelTab : larghezza massima in pixel delle schede di primo livello generate. Se qui viene inserito 0, l'impostazione non viene presa in considerazione. Per ulteriori informazioni sui modelli di primo livello, vedere: Modelli di primo livelloNumero massimo di clienti: Numero massimo di client in esecuzione parallela (predefinito 8, minimo 1, massimo 128). Ignora il visus generato se SVN è disponibile : Se il progetto è archiviato in Subversion questa opzione deve essere attivata. : CODESYS si assicura che le visualizzazioni generate vengano ignorate in SVN. Altrimenti potrebbero verificarsi dei problemi. Ricrea il visus durante la rigenerazione : : Ad ogni generazione del codice, anche tutte le visualizzazioni vengono rigenerate e le visualizzazioni esistenti vengono sovrascritte. Questa opzione deve essere selezionata se non si desidera che l'utente del modulo apporti modifiche alle visualizzazioni generate dopo la generazione. Se tuttavia fossero ancora necessarie modifiche alle visualizzazioni dopo la generazione, l'opzione dovrebbe essere disattivata. Poi CODESYS cerca di mantenere le modifiche successive anche con le rigenerazioni. Utilizza il nome dell'istanza come predefinito per le schede di primo livello : : invece del percorso completo dell'istanza, nella scheda di livello superiore viene visualizzato solo il nome dell'istanza. Se è presente un errore nella configurazione, viene visualizzato con un'icona del provider di errori e il file OK il pulsante è disabilitato. " }, 
{ "title" : "Comando: Scansione ", 
"url" : "ac_scan.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Scansione ", 
"snippet" : "Scansione Simbolo: Questo comando (categoria \"Composer\") analizza l'intero progetto per le dichiarazioni dei moduli. Normalmente questo comando non è necessario perché CODESYS esegue la scansione automatica del sistema ogni volta che è necessario (esempio: dopo aver installato una nuova libreria)....", 
"body" : "Scansione Simbolo: Questo comando (categoria \"Composer\") analizza l'intero progetto per le dichiarazioni dei moduli. Normalmente questo comando non è necessario perché CODESYS esegue la scansione automatica del sistema ogni volta che è necessario (esempio: dopo aver installato una nuova libreria). " }, 
{ "title" : "Comando: controlla e scansiona tutti gli oggetti del pool ", 
"url" : "_ac_cmd_check_and_scan_all_pool_objects.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: controlla e scansiona tutti gli oggetti del pool ", 
"snippet" : "Controlla e scansiona tutti gli oggetti del pool Funzione : Quando viene richiamato il comando, viene prima controllato il codice IEC di una libreria e poi vengono ricercate le dichiarazioni del modulo. L'esecuzione del test corrisponde al comando LControlla tutti gli oggetti del pool . La ricerca c...", 
"body" : "Controlla e scansiona tutti gli oggetti del pool Funzione : Quando viene richiamato il comando, viene prima controllato il codice IEC di una libreria e poi vengono ricercate le dichiarazioni del modulo. L'esecuzione del test corrisponde al comando LControlla tutti gli oggetti del pool . La ricerca corrisponde al comando Scansione. Chiamata : Compositore menù Requisiti : Il comando è visibile solo quando è aperto un progetto di libreria. " }, 
{ "title" : "Comando: Mappa I\/O ", 
"url" : "ac_map_channels_for_ioconfig.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Mappa I\/O ", 
"snippet" : "Mappa I\/O Simbolo: Questo comando (categoria \"Compositore\") apre una finestra di dialogo per definire la mappatura tra moduli e I\/O configurazione. Dialogo: Mappatura I\/O Sul lato sinistro della finestra di dialogo tutti gli ingressi e le uscite dei moduli vengono visualizzati in una struttura ad al...", 
"body" : "Mappa I\/O Simbolo: Questo comando (categoria \"Compositore\") apre una finestra di dialogo per definire la mappatura tra moduli e I\/O configurazione. Dialogo: Mappatura I\/O Sul lato sinistro della finestra di dialogo tutti gli ingressi e le uscite dei moduli vengono visualizzati in una struttura ad albero secondo albero dei moduli . Sul lato destro c'è la struttura dell'albero dei dispositivi. Le connessioni dei moduli di primo livello alle applicazioni vengono disegnate in base alle impostazioni dei moduli di primo livello. Questa connessione non può essere modificata in questa finestra di dialogo. Gli ingressi vengono visualizzati con una connessione verde e una freccia verde, le uscite vengono visualizzate in rosso. Gli ingressi o le uscite aperti (senza connessione) vengono visualizzati con una linea tratteggiata. Nel caso in cui un'espressione ST sia mappata sull'input resp. uscita, la connessione verrà visualizzata con una \"ST\". I collegamenti tra moduli e dispositivi sono possibili solo da ingresso a ingresso o da uscita a uscita. Inoltre, entrambe le connessioni devono avere un tipo di dati compatibile. I collegamenti tra i moduli sono possibili solo da ingresso a uscite e viceversa. Non sono possibili connessioni tra dispositivi. Per creare una connessione è necessario selezionare l'ingresso o l'uscita aperti. Un segnaposto selezionato viene visualizzato con uno sfondo blu. Gli ingressi e le uscite sono collegati tramite drag and drop. Una destinazione di connessione valida o non valida viene indicata con diversi puntatori del mouse. Le connessioni esistenti verranno cancellate se l'ingresso o l'uscita sono occupati. Se un dispositivo o un modulo è compresso, la connessione verrà disegnata in nero perché probabilmente non è possibile determinare la direzione dei dati. Se viene ulteriormente compresso (ad esempio l'apparecchio sovraordinato), anche i collegamenti verranno nascosti. Questo viene fatto per migliorare la visione d'insieme perché lo spessore della linea può essere ridotto nella zona centrale. Se viene selezionata una connessione sul lato sinistro o destro, il dispositivo corrispondente verrà espanso se è compresso. Le frecce mostrano la direzione dei dati. Un dispositivo compresso mostra sia la freccia verde che quella rossa se il dispositivo utilizza ingressi e uscite. Se sono presenti solo ingressi o uscite, viene visualizzata anche la direzione dei dati. Nella modalità online i valori dei parametri vengono visualizzati sul lato sinistro. I valori non possono essere modificati in questa visualizzazione. Facendo doppio clic su un modulo o dispositivo, nell'editor si apre il rispettivo oggetto. Le connessioni possono anche essere impostate oltre i confini dell'applicazione! Se un'istanza del modulo è mappata al pool POU, le linee di connessione sono disattivate. In questa situazione non è possibile creare mappature IO, ma è possibile eliminare le mappature esistenti. Stampa : Questo comando consente di stampare le mappature I\/O impostate in uno stile panoramica. " }, 
{ "title" : "Comando: Selezione caratteri jolly ", 
"url" : "ac_wildcard_selection.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Selezione caratteri jolly ", 
"snippet" : "Selezione dei caratteri jolly Questo comando (categoria \"Compositore\") apre la finestra di dialogo Assegnazione di caratteri jolly . La parte superiore della finestra di dialogo mostra i caratteri jolly attualmente configurati e i tipi di dispositivo assegnati. Nella parte inferiore della finestra d...", 
"body" : "Selezione dei caratteri jolly Questo comando (categoria \"Compositore\") apre la finestra di dialogo Assegnazione di caratteri jolly . La parte superiore della finestra di dialogo mostra i caratteri jolly attualmente configurati e i tipi di dispositivo assegnati. Nella parte inferiore della finestra di dialogo è rappresentato l'archivio dispositivi, che offre la selezione dei dispositivi installati. È possibile modificare le assegnazioni all'interno della finestra di dialogo. A questo scopo la finestra di dialogo appare anche durante la generazione del dispositivo, quando i caratteri jolly non possono essere assegnati automaticamente ai tipi di dispositivo ed è necessaria l'assegnazione manuale. L'assegnazione dei caratteri jolly ai tipi di dispositivi viene memorizzata all'interno del progetto. Tuttavia puoi anche utilizzare un file XML per salvare le assegnazioni esternamente e ricaricarle da lì. Il file e il percorso di questo file vengono visualizzati nella parte superiore della finestra di dialogo. Dialogo: Assegnazione di caratteri jolly Nuovo : Questo comando consente di creare un nuovo file XML di assegnazione dei caratteri jolly (vuoto). Definire il nome del file e la directory di archiviazione. Salva : questo comando salva esplicitamente l'assegnazione del dispositivo jolly attualmente definita in un file scelto manualmente. A parte questo, le assegnazioni verranno salvate automaticamente nel file attualmente specificato, quando si chiude la finestra di dialogo utilizzando il OK pulsante. Carico : Questo comando consente di caricare un file di assegnazione di caratteri jolly esistente (XML). Nella vista ad albero evidenziata, il file ID dispositivo (nome del modulo) la colonna mostra gli ID dei dispositivi del generatore di dispositivi che utilizzano caratteri jolly. Il nome dell'istanza del modulo che porta questo dispositivo è mostrato tra parentesi. In caso di dispositivo generatore di dispositivi inserito staticamente (definito dalla dichiarazione del modulo Identification e non Wildcard \/ FlexibleWildcard ) un nodo standard Statico viene creato che contiene tutti i dispositivi inseriti staticamente. I dispositivi statici non possono essere modificati. IL Relazioni colonne mostra la relazione tra i dispositivi padre e figlio del generatore di dispositivi. Una linea in grassetto indica una relazione fissa, mentre una linea tratteggiata serve come suggerimento per una relazione. Il suggerimento si basa sulla definizione di ParentID nel Device sezione. I caratteri jolly possono anche essere contrassegnati come vuoti semplicemente selezionandoli e premendo il pulsante Del chiave. Ad esempio, un carattere jolly vuoto potrebbe servire a modificare le relazioni genitore-figlio proposte. I caratteri jolly assegnati vengono visualizzati con uno sfondo verde; carattere jolly non assegnato con un colore di sfondo rosso. Mostra solo la compatibilità con la prima generazione di possibili dispositivi genitori : Se questa opzione è attivata, l'assortimento di dispositivi della visualizzazione dell'archivio dispositivi è ulteriormente limitato a quei dispositivi che sono figli compatibili solo del primo dispositivo genitore. Ciò è definito dal configurazione del modulo . Se non attivati, anche i dispositivi genitori di 2a, 3a, …, nesima generazione vengono trattati come possibili genitori, ampliando l'assortimento di dispositivi mostrato nella vista dell'archivio dispositivi. Regole per l'assegnazione degli immobili Se sul lato sinistro viene selezionato un dispositivo, un canale IO o un'istanza FB, tutte le proprietà di questo dispositivo, canale IO o istanza FB già assegnate verranno contrassegnate con una casella di controllo sul lato destro I dispositivi sul lato sinistro senza proprietà assegnate per i canali IO o le istanze FB verranno visualizzati con uno sfondo rosso, il canale IO o l'istanza FB interessati verranno visualizzati rispettivamente con uno sfondo rosso. I dispositivi a cui sono assegnati tutti i canali I\/O e le istanze FB sono evidenziati in verde, così come i canali I\/O e le istanze FB noti. L'assegnazione prevede anche la non assegnazione di un immobile “impegnativo”. Quest'ultimo può essere ottenuto per un dispositivo completo facendo doppio clic su un nodo del dispositivo per l'intero dispositivo con tutti i suoi canali I\/O e istanze FB. Le proprietà a destra possono essere aggiunte alle proprietà di \"offerta\" del dispositivo, del canale I\/O o dell'istanza FB selezionata a sinistra selezionando la casella. È possibile assegnare qualsiasi numero di proprietà o nessuna a un dispositivo, canale I\/O o istanza FB. Se una proprietà I\/O \"impegnativa\" viene assegnata a un nodo del dispositivo, questa proprietà viene assegnata a tutti i nodi del canale I\/O figlio di questo nodo del dispositivo, ma non alle istanze FB. Allo stesso modo, se a un dispositivo viene assegnata una proprietà InstRef \"impegnativa\", solo alle istanze FB figlio di quel dispositivo viene assegnata quella proprietà. È possibile selezionare contemporaneamente più dispositivi, canali I\/O o istanze FB, a ciascuno dei quali vengono poi assegnate, se possibile, le proprietà selezionate. Le proprietà \"richieste\" sul lato destro che sono offerte almeno da un dispositivo sul lato sinistro verranno visualizzate con uno sfondo verde. Le proprietà \"richieste\" senza corrispondenti proprietà dell'offerta sul lato sinistro verranno visualizzate con uno sfondo rosso. " }, 
{ "title" : "Assegnazione di caratteri jolly ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_342a92346a13602cc0a8640e00a6970a", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Selezione caratteri jolly \/ Assegnazione di caratteri jolly ", 
"snippet" : "Esistono due modi per assegnare un carattere jolly: Nella parte superiore della finestra di dialogo, nella riga del carattere jolly da assegnare, fare clic nel campo in colonna Dispositivi selezionati . Quindi, nell'albero Archivio dispositivi nella parte inferiore della finestra di dialogo, fare do...", 
"body" : "Esistono due modi per assegnare un carattere jolly: Nella parte superiore della finestra di dialogo, nella riga del carattere jolly da assegnare, fare clic nel campo in colonna Dispositivi selezionati . Quindi, nell'albero Archivio dispositivi nella parte inferiore della finestra di dialogo, fare doppio clic sul dispositivo desiderato. Nell'albero Archivio dispositivi nella parte inferiore della finestra di dialogo, selezionare il dispositivo desiderato. Successivamente, nella parte superiore della finestra di dialogo, nella riga del carattere jolly da assegnare, fare doppio clic sul campo nella colonna Dispositivi selezionati . " }, 
{ "title" : "Assegnazione delle proprietà del dispositivo ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_4703909473b5f037c0a8640e01022fbe", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Selezione caratteri jolly \/ Assegnazione delle proprietà del dispositivo ", 
"snippet" : "Il comando Assegnazione delle proprietà del dispositivo apre la rispettiva finestra di dialogo che serve per l'assegnazione offerta proprietà ai dispositivi. Dialogo: Assegnazione delle proprietà del dispositivo Sul lato sinistro della finestra di dialogo sono elencati tutti i dispositivi generati u...", 
"body" : "Il comando Assegnazione delle proprietà del dispositivo apre la rispettiva finestra di dialogo che serve per l'assegnazione offerta proprietà ai dispositivi. Dialogo: Assegnazione delle proprietà del dispositivo Sul lato sinistro della finestra di dialogo sono elencati tutti i dispositivi generati utilizzati nel progetto. I nodi figli di questi dispositivi visualizzano tutti gli ingressi, le uscite (non in grassetto) e i blocchi funzione creati (in grassetto) del tipo di dispositivo corrispondente. Il display sul lato destro elenca tutte le proprietà \"richieste\", che sono definite nelle dichiarazioni dei moduli utilizzati come esigente IO. I nodi figli di queste \"richieste\" corrispondono a tutti gli IO del modulo che richiedono la richiesta dei nodi genitori. La finestra di dialogo di assegnazione delle proprietà viene utilizzata per assegnare le proprietà del lato destro ai dispositivi e ai loro canali IO. Queste assegnazioni verranno salvate in un file aggiuntivo accanto alla descrizione del dispositivo dei dispositivi, che fa riferimento al file aggiuntivo. La finestra di dialogo si apre automaticamente durante la generazione del codice se non tutte le proprietà \"richieste\" degli I\/O del modulo sono soddisfatte con almeno un'assegnazione a un dispositivo che offre queste proprietà. " }, 
{ "title" : "Comando: Rimuovi mappature I\/O ", 
"url" : "ac_remove_connections_to_ios.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Rimuovi mappature I\/O ", 
"snippet" : "Rimuovere le mappature I\/O Questo comando (categoria \"Composer\") rimuove le mappature I\/O. Vengono forniti i seguenti sottocomandi. Tutto generato : Rimuove le mappature generate automaticamente. Rimangono le mappature aggiunte manualmente. Tutto : Rimuove tutte le mappature: mappature generate auto...", 
"body" : "Rimuovere le mappature I\/O Questo comando (categoria \"Composer\") rimuove le mappature I\/O. Vengono forniti i seguenti sottocomandi. Tutto generato : Rimuove le mappature generate automaticamente. Rimangono le mappature aggiunte manualmente. Tutto : Rimuove tutte le mappature: mappature generate automaticamente e mappature aggiunte manualmente. Tutto generato dall'istanza del modulo : Se nell'albero dei moduli è selezionata un'istanza del modulo, è possibile eseguire questo comando. Il comando rimuove le mappature generate automaticamente di questa istanza. Rimangono le mappature aggiunte manualmente. Tutte le istanze del modulo : Se nell'albero dei moduli è selezionata un'istanza del modulo, è possibile eseguire questo comando. Il comando rimuove tutta la mappatura di questa istanza: mappature generate automaticamente e mappature aggiunte manualmente. " }, 
{ "title" : "Comando: Aggiungi istanza del modulo di primo livello ", 
"url" : "ac_add_toplevel_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Aggiungi istanza del modulo di primo livello ", 
"snippet" : "Aggiungi istanza del modulo di primo livello Questo comando (categoria \"Compositore\") apre il file Finestra di dialogo del modulo che offre tutti i moduli di livello superiore che possono essere aggiunti all'albero dei moduli. Non esiste alcuna limitazione al numero di moduli di primo livello che po...", 
"body" : "Aggiungi istanza del modulo di primo livello Questo comando (categoria \"Compositore\") apre il file Finestra di dialogo del modulo che offre tutti i moduli di livello superiore che possono essere aggiunti all'albero dei moduli. Non esiste alcuna limitazione al numero di moduli di primo livello che possono essere aggiunti a un'applicazione. " }, 
{ "title" : "Comando: Aggiungi istanza del sottomodulo ", 
"url" : "ac_add_submodule_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Aggiungi istanza del sottomodulo ", 
"snippet" : "Aggiungi istanza del sottomodulo Questo comando (categoria \"Compositore\") apre il file Finestra di dialogo del modulo che offre tutti i sottomoduli che possono essere aggiunti alla posizione selezionata nell'albero dei moduli. I sottomoduli che offrono slot di riferimento obbligatori consentono di r...", 
"body" : "Aggiungi istanza del sottomodulo Questo comando (categoria \"Compositore\") apre il file Finestra di dialogo del modulo che offre tutti i sottomoduli che possono essere aggiunti alla posizione selezionata nell'albero dei moduli. I sottomoduli che offrono slot di riferimento obbligatori consentono di riempire automaticamente tutti gli slot di riferimento univoci. In questa situazione una finestra di dialogo chiede all'utente se i moduli devono essere referenziati automaticamente o meno. " }, 
{ "title" : "Comando: Istanza del modulo di riferimento ", 
"url" : "ac_reference_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Istanza del modulo di riferimento ", 
"snippet" : "Istanza del modulo di riferimento Questo comando (categoria \"Compositore\") apre il file Finestra di dialogo del modulo che offre tutti i moduli a cui è possibile fare riferimento nella posizione selezionata nell'albero dei moduli....", 
"body" : "Istanza del modulo di riferimento Questo comando (categoria \"Compositore\") apre il file Finestra di dialogo del modulo che offre tutti i moduli a cui è possibile fare riferimento nella posizione selezionata nell'albero dei moduli. " }, 
{ "title" : "Comando: Mostra vista riferimenti modulo ", 
"url" : "ac_module_references_editor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Mostra vista riferimenti modulo ", 
"snippet" : "Mostra vista riferimenti modulo Questo comando (categoria \"Compositore\") apre il file Riferimento del modulo visualizzare e fornisce una panoramica dell'utilizzo delle istanze del modulo nel progetto. Il comando è disponibile nel menu contestuale se un'istanza del modulo è selezionata nell'albero de...", 
"body" : "Mostra vista riferimenti modulo Questo comando (categoria \"Compositore\") apre il file Riferimento del modulo visualizzare e fornisce una panoramica dell'utilizzo delle istanze del modulo nel progetto. Il comando è disponibile nel menu contestuale se un'istanza del modulo è selezionata nell'albero del modulo. La vista viene aggiornata automaticamente se viene selezionata un'altra istanza del modulo o se cambiano i riferimenti dell'istanza attualmente selezionata. " }, 
{ "title" : "Vista: riferimenti al modulo ", 
"url" : "ac_module_references_editor.html#UUID-7a9e7bcf-5b4a-4286-24df-e6cd7795a03a_c2a0935773056bc0a86463423a2ab0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Mostra vista riferimenti modulo \/ Vista: riferimenti al modulo ", 
"snippet" : "App\/Fonte di riferimento I riferimenti sono ordinati per applicazione. Ruolo del riferimento nel suo target Ruolo del riferimento nel suo target...", 
"body" : "App\/Fonte di riferimento I riferimenti sono ordinati per applicazione. Ruolo del riferimento nel suo target Ruolo del riferimento nel suo target " }, 
{ "title" : "Comando: Aggiorna modulo ", 
"url" : "ac_update_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Aggiorna modulo ", 
"snippet" : "Modulo di aggiornamento Questo comando (categoria \"Compositore\") apre il file Finestra di dialogo del modulo . L'albero dei moduli fornisce tutti i moduli compatibili con l'istanza del modulo selezionato nell'albero dei moduli. Il comando consente di aggiornare un'istanza del modulo a un nuovo tipo ...", 
"body" : "Modulo di aggiornamento Questo comando (categoria \"Compositore\") apre il file Finestra di dialogo del modulo . L'albero dei moduli fornisce tutti i moduli compatibili con l'istanza del modulo selezionato nell'albero dei moduli. Il comando consente di aggiornare un'istanza del modulo a un nuovo tipo di modulo. Può anche trattarsi di una nuova versione dello stesso modulo. Durante l'aggiornamento, i dati configurati dell'istanza verranno mantenuti il più possibile: I valori dei parametri esistenti nelle nuove versioni verranno adottati anche se il valore corrente è incompatibile con il nuovo tipo di parametro. Se il valore di un parametro non è impostato esplicitamente nell'istanza, viene utilizzato il valore predefinito del nuovo modulo. Verranno adottate le mappature I\/O esistenti nella nuova versione e che hanno la stessa direzione (ingresso\/uscita) dell'assegnazione nell'istanza. L'assegnazione non deve essere necessariamente dello stesso tipo del nuovo I\/O da adottare. Verranno adottate le assegnazioni di compiti esistenti in entrambe le versioni. Le sottoistanze o i riferimenti degli slot che hanno lo stesso ID slot nel nuovo modulo verranno mantenuti con tutte le sottoistanze e i riferimenti. Ciò si applica anche se il tipo delle sottoistanze o dei riferimenti non corrisponde al nuovo slot o se la cardinalità del nuovo slot non consente tutte le sottoistanze o i riferimenti. Le sottoistanze o i riferimenti di slot che non esistono nel nuovo modulo vengono inseriti sotto un nuovo slot denominato \"Istanze orfane\" o \"Riferimenti orfani\". Questi slot sono identificati da identificatori speciali che non possono verificarsi negli slot normali. Se esiste già uno slot con elementi orfani, verrà utilizzato questo slot. Le sottoistanze o i riferimenti di slot che esistono nel nuovo modulo ma che ora prevedono riferimenti (in caso di sottoistanze) o sottoistanze (in caso di riferimenti) verranno gestiti come sottoistanze risp. indica quale slot non è disponibile nel nuovo modulo. Le informazioni di livello superiore esistenti nell'istanza verranno eliminate se è presente un aggiornamento a un modulo che non è di livello superiore. Se nell'istanza non esistono informazioni di livello superiore, questa verrà creata se il modulo viene aggiornato a un modulo di livello superiore. Dati dell'istanza definiti dalle estensioni: le rispettive estensioni determinano quali dati verranno conservati e quali verranno eliminati. Dovrebbe aderire al principio di ottenere il maggior numero di dati possibile. Se l'ordine degli slot nel nuovo modulo è cambiato, anche l'ordine degli slot sotto l'istanza verrà modificato di conseguenza. Se l'aggiornamento elimina dati (ad esempio valori di parametri, assegnazioni I\/O, slot non vuoti o dati di istanze estese), verrà visualizzato un messaggio che descrive quali oggetti verranno eliminati e consente all'utente di annullare l'aggiornamento. L'aggiornamento di un'istanza può essere annullato con un singolo passaggio di annullamento nell'albero del modulo. " }, 
{ "title" : "Comando: Aggiorna tutte le istanze ", 
"url" : "ac_update_all_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Aggiorna tutte le istanze ", 
"snippet" : "Aggiorna tutte le istanze Questo comando (categoria \"Compositore\") consente di aggiornare tutte le istanze del modulo alle nuove versioni dei moduli con un comando. Questo comando non è disponibile nel menu contestuale. Il comportamento del comando è conforme alla descrizione del file Modulo di aggi...", 
"body" : "Aggiorna tutte le istanze Questo comando (categoria \"Compositore\") consente di aggiornare tutte le istanze del modulo alle nuove versioni dei moduli con un comando. Questo comando non è disponibile nel menu contestuale. Il comportamento del comando è conforme alla descrizione del file Modulo di aggiornamento comando, tuttavia non è possibile un aggiornamento su un altro modulo. " }, 
{ "title" : "Comando: Nascondi slot opzionali vuoti: tutti\/solo selezionati ", 
"url" : "ac_hide_empty_optional_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Nascondi slot opzionali vuoti: tutti\/solo selezionati ", 
"snippet" : "Nascondi slot opzionali vuoti: tutti\/solo selezionati Con questi comandi (categoria \"Compositore\") è possibile nascondere gli slot opzionali vuoti nell'albero dei moduli. A seconda del focus attuale questo si riferisce a tutti i sottomoduli o solo al sottomodulo attualmente selezionato. Gli slot obb...", 
"body" : "Nascondi slot opzionali vuoti: tutti\/solo selezionati Con questi comandi (categoria \"Compositore\") è possibile nascondere gli slot opzionali vuoti nell'albero dei moduli. A seconda del focus attuale questo si riferisce a tutti i sottomoduli o solo al sottomodulo attualmente selezionato. Gli slot obbligatori non possono essere nascosti. Esempio di slot opzionali vuoti Per visualizzare gli slot nascosti, utilizza il file Mostra slot nascosti: tutti\/solo selezionati comando. " }, 
{ "title" : "Comando: Mostra slot nascosti: tutti\/solo selezionati ", 
"url" : "ac_show_hidden_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Mostra slot nascosti: tutti\/solo selezionati ", 
"snippet" : "Mostra slot nascosti: tutti\/solo selezionati Con questi comandi (categoria \"Compositore\") nell'albero dei moduli è possibile rendere nuovamente visibili gli slot che prima erano nascosti. A seconda del focus attuale, questo si riferisce a tutti i sottomoduli o solo al sottomodulo attualmente selezio...", 
"body" : "Mostra slot nascosti: tutti\/solo selezionati Con questi comandi (categoria \"Compositore\") nell'albero dei moduli è possibile rendere nuovamente visibili gli slot che prima erano nascosti. A seconda del focus attuale, questo si riferisce a tutti i sottomoduli o solo al sottomodulo attualmente selezionato. Per nascondere gli slot vedere il Nascondi slot opzionali vuoti: tutti\/solo selezionati comando. " }, 
{ "title" : "Comando: vai al bersaglio ", 
"url" : "ac_go_to_target.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: vai al bersaglio ", 
"snippet" : "Vai a Obiettivo Questo comando (categoria \"Compositore\") è disponibile solo se è selezionato un riferimento al modulo nel file albero dei moduli . Se questo comando viene eseguito, la destinazione del riferimento verrà selezionata nell'albero del modulo....", 
"body" : "Vai a Obiettivo Questo comando (categoria \"Compositore\") è disponibile solo se è selezionato un riferimento al modulo nel file albero dei moduli . Se questo comando viene eseguito, la destinazione del riferimento verrà selezionata nell'albero del modulo. " }, 
{ "title" : "Comando: Crea modulo di estensione ", 
"url" : "_ac_cmd_create_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Crea modulo di estensione ", 
"snippet" : "Crea modulo di estensione Simbolo: Il comando crea un file modulo di estensione per uno slot del sottomodulo. È disponibile solo se nell'albero dei moduli è selezionato uno slot modulo vuoto o un sottomodulo. Il comando apre una finestra di dialogo in cui si definisce se l'estensione deve essere cre...", 
"body" : "Crea modulo di estensione Simbolo: Il comando crea un file modulo di estensione per uno slot del sottomodulo. È disponibile solo se nell'albero dei moduli è selezionato uno slot modulo vuoto o un sottomodulo. Il comando apre una finestra di dialogo in cui si definisce se l'estensione deve essere creata come nuovo modulo (\"Nessuna variazione\") o come variazione di un modulo esistente o di un'istanza di modulo. A questo scopo in un elenco a discesa vengono offerti tutti i moduli adatti allo slot. Ci sono due opzioni: Derivare la variazione Il modulo di estensione deriva dal modulo o dall'istanza del modulo selezionato in Variazione di . Il modulo scelto viene importato tramite IMPORTS al modulo di estensione e il blocco funzione del nuovo modulo deriva dal blocco funzione del modello di modulo. Copia sorgente per Variation Un nuovo modulo di estensione viene creato copiando la dichiarazione completa del modulo compreso il blocco funzione e le relative visualizzazioni dal modulo selezionato in Variazione di (incluso il codice sorgente). Ciò è possibile solo se il modulo selezionato in Variazione di è disponibile nel codice sorgente e non solo come modulo di una libreria compilata. I moduli di estensione servono per aggiungere qualsiasi modifica o estensione specifica dell'utente ai moduli esistenti e predefiniti o alle istanze del modulo. Dopo aver chiuso la finestra di dialogo con OK verrà creata una nuova cartella nel file POU pool con il nome del modulo di estensione. In questa cartella verranno creati i seguenti oggetti (dove <nome> è il nome del modulo di estensione): Caso standard: un blocco funzione con il nome <name> , estendendo la classe \"Moduli\" e implementando l'interfaccia richiesta del tipo di slot. In questo blocco funzione verranno creati tutti i metodi e le proprietà che esistono in un'interfaccia implementata ma che non sono implementati in nessuna classe base. Caso variante: Come nel caso standard, verrà creato un blocco funzione corrispondente. Questo blocco funzione deriva dal blocco funzione del modello di modulo scelto ( Derivare la variazione ) o ne è una copia ( Copia sorgente per Variation ). Un pool di immagini e un elenco di testi (nome IP_<name> O TL_<name> ). Il pool di immagini contiene due icone con identificatore Icon_16 E Icon_32 . L'elenco dei testi contiene la voce Desc , che è riempito con a <name> . Non ci sono lingue nell'elenco dei testi, solo la colonna Standard . Una pagina di visualizzazione vuota Visu_M_<name> , che implementa l'interfaccia richiesta. Se Copia la variazione dalla fonte è selezionato, vengono invece copiate le visualizzazioni del modulo sorgente. All'albero dei moduli verrà aggiunto un modulo di estensione che non ha né parametri né I\/O. Per i metadati verranno utilizzate le immagini, i testi e gli elementi di visualizzazione creati. La categoria è \"Estensione\". Se si tratta di una variante \"derivata\", la dichiarazione del modello di modulo viene inoltre importata tramite IMPORTS . Se si tratta di una variazione \"copiata\", la dichiarazione del modello del modulo viene copiata e adattata in modo tale da utilizzare gli elenchi di testi e i pool di immagini corrispondenti del modulo di estensione. " }, 
{ "title" : "Comando: Crea voci dell'elenco di testi mancanti ", 
"url" : "ac_create_missing_textlist_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Crea voci dell'elenco di testi mancanti ", 
"snippet" : "Crea voci dell'elenco di testi mancanti Questo comando (categoria \"Compositore\") crea automaticamente tutti gli elenchi di testi e le voci di elenchi di testi a cui fa riferimento una dichiarazione di modulo e che non esistono. Il comando è disponibile solo se a editor di dichiarazioni del modulo vi...", 
"body" : "Crea voci dell'elenco di testi mancanti Questo comando (categoria \"Compositore\") crea automaticamente tutti gli elenchi di testi e le voci di elenchi di testi a cui fa riferimento una dichiarazione di modulo e che non esistono. Il comando è disponibile solo se a editor di dichiarazioni del modulo viene aperto con il focus su di esso e l'oggetto esiste nel progetto principale. La funzione funziona solo se non sono presenti errori di sintassi. Gli elenchi di testo verranno creati sotto lo stesso oggetto padre dell'oggetto nell'editor. Con le nuove voci create verrà riempito solo il testo \"predefinito\" (con l'ID). " }, 
{ "title" : "Comando: genera voci mancanti nei pool di immagini ", 
"url" : "ac_create_missing_image_pool_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: genera voci mancanti nei pool di immagini ", 
"snippet" : "Genera voci mancanti nei pool di immagini Il comando genera un pool di immagini di voci definite nella descrizione di un modulo ma che non esistono ancora in un pool di immagini del progetto. Se il pool di immagini non esiste ancora, viene generato nel file POU visualizzare prima. Per impostazione p...", 
"body" : "Genera voci mancanti nei pool di immagini Il comando genera un pool di immagini di voci definite nella descrizione di un modulo ma che non esistono ancora in un pool di immagini del progetto. Se il pool di immagini non esiste ancora, viene generato nel file POU visualizzare prima. Per impostazione predefinita, il comando non è disponibile nel file Compositore menù. Usi il Strumenti → Personalizza finestra di dialogo per aggiungerlo da Compositore categoria di comando al Compositore menù. Il comando sarà quindi visibile nel file Compositore menu quando un modulo è aperto e focalizzato nell'editor. " }, 
{ "title" : "Comando: spostati verso l'alto ", 
"url" : "ac_move_up.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: spostati verso l'alto ", 
"snippet" : "Andare avanti Questo comando (categoria \"Compositore\") può essere utilizzato per modificare la posizione dei moduli nel file albero dei moduli . Questo comando è disponibile solo per elementi multislot (istanze e riferimenti di moduli) e se l'elemento selezionato non è il primo elemento del multislo...", 
"body" : "Andare avanti Questo comando (categoria \"Compositore\") può essere utilizzato per modificare la posizione dei moduli nel file albero dei moduli . Questo comando è disponibile solo per elementi multislot (istanze e riferimenti di moduli) e se l'elemento selezionato non è il primo elemento del multislot. " }, 
{ "title" : "Comando: spostati verso il basso ", 
"url" : "ac_move_down.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: spostati verso il basso ", 
"snippet" : "Abbassati Questo comando (categoria \"Compositore\") può essere utilizzato per modificare la posizione dei moduli nel file albero dei moduli . Questo comando è disponibile solo per elementi multislot (istanze e riferimenti di moduli) e se l'elemento selezionato non è l'ultimo elemento del multislot....", 
"body" : "Abbassati Questo comando (categoria \"Compositore\") può essere utilizzato per modificare la posizione dei moduli nel file albero dei moduli . Questo comando è disponibile solo per elementi multislot (istanze e riferimenti di moduli) e se l'elemento selezionato non è l'ultimo elemento del multislot. " }, 
{ "title" : "Comando: Controlla voci sconosciute ", 
"url" : "ac_check_for_unknown_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Controlla voci sconosciute ", 
"snippet" : "Controlla le voci sconosciute Questo comando (categoria \"Composer\") controlla le dichiarazioni del modulo per le definizioni di sezione sconosciute. Il sottocomando Tutto , che è sempre disponibile, controlla tutte le dichiarazioni dei moduli del progetto. Se una dichiarazione di modulo viene aperta...", 
"body" : "Controlla le voci sconosciute Questo comando (categoria \"Composer\") controlla le dichiarazioni del modulo per le definizioni di sezione sconosciute. Il sottocomando Tutto , che è sempre disponibile, controlla tutte le dichiarazioni dei moduli del progetto. Se una dichiarazione di modulo viene aperta nell'editor, il sottocomando aggiuntivo Nell'editor corrente controlla la dichiarazione del modulo attualmente aperto per definizioni di sezione sconosciute. " }, 
{ "title" : "Comando: genera, compila e accedi ", 
"url" : "ac_generate_compile_login.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: genera, compila e accedi ", 
"snippet" : "Genera, compila e accedi Simbolo: Questo comando (categoria \"Compositore\") esegue diversi comandi con un clic del mouse. Per prima cosa viene creato e compilato il codice. Se possibile, l'applicazione viene registrata nel controller e avviata....", 
"body" : "Genera, compila e accedi Simbolo: Questo comando (categoria \"Compositore\") esegue diversi comandi con un clic del mouse. Per prima cosa viene creato e compilato il codice. Se possibile, l'applicazione viene registrata nel controller e avviata. " }, 
{ "title" : "Comando: aggiungi libreria moduli al progetto ", 
"url" : "ac_add_libraries_to_pou.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: aggiungi libreria moduli al progetto ", 
"snippet" : "Aggiungi libreria moduli al progetto Simbolo: Questo comando (categoria \"Compositore\") apre una finestra di dialogo con il modulo contenente le librerie. Con il OK pulsante le librerie selezionate verranno aggiunte al Gestore Libreria del pool POU. Se la libreria Composer standard AC_ModlueBase manc...", 
"body" : "Aggiungi libreria moduli al progetto Simbolo: Questo comando (categoria \"Compositore\") apre una finestra di dialogo con il modulo contenente le librerie. Con il OK pulsante le librerie selezionate verranno aggiunte al Gestore Libreria del pool POU. Se la libreria Composer standard AC_ModlueBase manca, viene aggiunto automaticamente. Finestra di dialogo per aggiungere librerie di Application Composer La finestra di dialogo fornisce il pulsante Apri Gestore libreria POU che permette di aprire il Gestore della Libreria del POU piscina anche dentro Composer Dedicated visualizzazione. " }, 
{ "title" : "Comando: punti di interruzione attivi per il passaggio successivo ", 
"url" : "ac_active_breakpoints_to_next_step.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: punti di interruzione attivi per il passaggio successivo ", 
"snippet" : "Punti di interruzione attivi al passaggio successivo Questo comando (categoria \"Compositore\") è disponibile solo in modalità online e se la sequenza si è interrotta su un punto di interruzione. Rimuove i punti di interruzione attualmente attivi e ne aggiunge uno nuovo ai passaggi successivi....", 
"body" : "Punti di interruzione attivi al passaggio successivo Questo comando (categoria \"Compositore\") è disponibile solo in modalità online e se la sequenza si è interrotta su un punto di interruzione. Rimuove i punti di interruzione attualmente attivi e ne aggiunge uno nuovo ai passaggi successivi. " }, 
{ "title" : "Comando: Centra la vista sui punti di interruzione ", 
"url" : "ac_center_view_to_breakpoints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Centra la vista sui punti di interruzione ", 
"snippet" : "Centra la vista sui punti di interruzione Questo comando (categoria \"Compositore\") è disponibile solo in modalità online e se la sequenza si è interrotta su un punto di interruzione. Centra la vista dell'Editor di sequenze sui breakpoint attualmente attivi....", 
"body" : "Centra la vista sui punti di interruzione Questo comando (categoria \"Compositore\") è disponibile solo in modalità online e se la sequenza si è interrotta su un punto di interruzione. Centra la vista dell'Editor di sequenze sui breakpoint attualmente attivi. " }, 
{ "title" : "Comando: Creazione di moduli macro ", 
"url" : "ac_create_macro_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Creazione di moduli macro ", 
"snippet" : "Creazione di moduli macro Simbolo: Questo comando (nella categoria \"Compositore\") apre una finestra di dialogo per la generazione di macro moduli. Per utilizzare questo comando, è necessaria una licenza valida per la creazione dichiarazioni del modulo . Il comando è disponibile se è stata selezionat...", 
"body" : "Creazione di moduli macro Simbolo: Questo comando (nella categoria \"Compositore\") apre una finestra di dialogo per la generazione di macro moduli. Per utilizzare questo comando, è necessaria una licenza valida per la creazione dichiarazioni del modulo . Il comando è disponibile se è stata selezionata una sottostruttura nell'albero dei moduli. È possibile utilizzare questo comando per generare un modulo macro dai moduli del sottoalbero. In questo modo è possibile definire quali slot, I\/O e parametri del sottomodulo sono disponibili nel nuovo modulo macro. Metadati Nome Questo è il nome univoco del modulo macro. Descrizione della macro La descrizione viene creata come elenchi di testo. Categoria macro La categoria serve per suddividere i moduli nella finestra di dialogo di inserimento moduli. Slot\/IO\/Parametri Sottostruttura del modulo macro Visualizzazione ad albero di tutti gli oggetti del sottoalbero La struttura mostra anche tutti gli slot, gli I\/O e i parametri della rispettiva istanza del sottomodulo come elementi figlio (carattere in grassetto). Slot per moduli macro Vengono visualizzati tutti gli slot, gli I\/O e i parametri che il tipo di modulo macro dovrebbe includere. Questi elementi provengono direttamente dalla vista ad albero a sinistra. I\/O dei moduli macro Parametri del macromodulo Aggiungi alla macro Questo è attivo se si seleziona uno slot, un I\/O o un parametro nella visualizzazione ad albero a sinistra. Puoi aggiungere gli elementi al modulo macro facendo clic su questo pulsante. Rimuovi dalla macro Questo è attivo se si selezionano slot, I\/O o parametri dalla visualizzazione ad albero a destra. Si rimuovono gli elementi dal modulo macro facendo clic su questo pulsante. Quando si chiude la finestra di dialogo facendo clic OK , CODESYS Application Composer genera una dichiarazione di modulo, un elenco di testi e un pool di immagini per questo modulo macro. Gli oggetti vengono archiviati in una cartella con il nome macro. Ora puoi modificare gli oggetti generati senza restrizioni e indipendentemente dalla generazione. In questo modo è possibile, ad esempio, scambiare l'icona macro nel pool di immagini. " }, 
{ "title" : "Comando: firma tutti i moduli ", 
"url" : "ac_sign_all_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: firma tutti i moduli ", 
"snippet" : "Firma tutti i moduli Questo comando (categoria \"Composer\") consente la firma (rinnovata) di tutti i moduli del pool POU. Questo comando può essere utilizzato per firmare nuovamente tutti i moduli nel file POU piscina. I moduli sviluppati con una licenza valida vengono firmati automaticamente. Questo...", 
"body" : "Firma tutti i moduli Questo comando (categoria \"Composer\") consente la firma (rinnovata) di tutti i moduli del pool POU. Questo comando può essere utilizzato per firmare nuovamente tutti i moduli nel file POU piscina. I moduli sviluppati con una licenza valida vengono firmati automaticamente. Questo comando è destinato a prendere il controllo dei moduli esistenti non firmati delle versioni precedenti di Application Composer. " }, 
{ "title" : "Comando: Vai al modulo FB ", 
"url" : "ac_goto_modul_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Vai al modulo FB ", 
"snippet" : "Vai al modulo FB Il comando (categoria \"Composer\") può essere utilizzato per aprire il blocco funzione del modulo o i suoi metodi nell'editor. È necessario selezionare un modulo nell'albero dei moduli per rendere disponibile questo comando. In modalità offline nell'editor verrà aperta la dichiarazio...", 
"body" : "Vai al modulo FB Il comando (categoria \"Composer\") può essere utilizzato per aprire il blocco funzione del modulo o i suoi metodi nell'editor. È necessario selezionare un modulo nell'albero dei moduli per rendere disponibile questo comando. In modalità offline nell'editor verrà aperta la dichiarazione del tipo di blocco funzione o del metodo del blocco funzione. In modalità online l'istanza del blocco funzione o il metodo dell'istanza del modulo verrà aperto nell'editor. " }, 
{ "title" : "Comando: valori dei parametri diversi ", 
"url" : "ac_differing_parameter_values.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: valori dei parametri diversi ", 
"snippet" : "Valori dei parametri diversi Utilizzare questo comando in modalità online per verificare se i valori dei parametri delle istanze del modulo utilizzate nell'albero del modulo sono stati modificati nel blocco funzione del modulo. In questo caso otterrai un elenco di quelli modificati parametri e delle...", 
"body" : "Valori dei parametri diversi Utilizzare questo comando in modalità online per verificare se i valori dei parametri delle istanze del modulo utilizzate nell'albero del modulo sono stati modificati nel blocco funzione del modulo. In questo caso otterrai un elenco di quelli modificati parametri e delle istanze del modulo interessato nel file Messaggi visualizzazione. Un doppio clic su un messaggio aprirà l'editor dei parametri per l'istanza del modulo interessato. Tutti i parametri con valori diversi in modalità online e in modalità offline dell'applicazione saranno indicati da celle con cornice rossa nelle colonne Valore E Valore in linea . " }, 
{ "title" : "Comando: reimposta il testo delle schede di primo livello ", 
"url" : "ac_reset_text_of_toplevel_tabs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: reimposta il testo delle schede di primo livello ", 
"snippet" : "Reimposta il testo delle schede di primo livello Funzione : questo comando ripristina i testi alle impostazioni predefinite per il file schede di primo livello che sono stati definiti negli editor dei moduli nel file HMI scheda. Facendo clic Compositore → Reimposta il testo delle schede di primo liv...", 
"body" : "Reimposta il testo delle schede di primo livello Funzione : questo comando ripristina i testi alle impostazioni predefinite per il file schede di primo livello che sono stati definiti negli editor dei moduli nel file HMI scheda. Facendo clic Compositore → Reimposta il testo delle schede di primo livello → Tutto reimposta i testi di tutte le schede di primo livello. Facendo clic Compositore → Reimposta il testo delle schede di primo livello → Solo selezionato reimposta solo il testo del modulo selezionato (nel file Moduli visualizzazione). Clic Compositore → Crea per aggiornare l'applicazione. Chiamata : Compositore menù Requisiti : Nel file sono presenti moduli con testo configurato speciale per le schede di livello superiore Moduli visualizzazione. Esempio per un modulo I passaggi seguenti descrivono come impostare e reimpostare il testo per una scheda di primo livello. Il tuo progetto include il Building modulo. Fare doppio clic su Building modulo nel Moduli visualizzazione. Si apre l'editor dei moduli (configuratore dei moduli). Attiva l'opzione Crea scheda di primo livello . Quindi viene visualizzato un campo di input con il testo di livello superiore preimpostato Building . Specificare il testo City hall . Clic Compositore → Crea . Le visualizzazioni del modulo e il file Toplevel la visualizzazione viene creata e archiviata nel file Dispositivi visualizzazione. Fare doppio clic su Toplevel visualizzazione nel Dispositivi visualizzazione. → Salva il progetto. Fare doppio clic su Building modulo nel Moduli visualizzazione. I comandi del Compositore il menu è disponibile. Seleziona il Building modulo. Clic Compositore → Reimposta il testo delle schede di primo livello → Solo selezionato . Il testo viene ripristinato all'impostazione predefinita Building nell'editor del modulo nel campo di input accanto a Crea scheda di primo livello opzione. Clic Compositore → Crea . Le visualizzazioni del modulo e il file Toplevel visualizzazione vengono aggiornate e archiviate nel file Dispositivi visualizzazione. Apri il Toplevel visualizzazione nel Dispositivi visualizzazione. → Esempio per un sottomodulo I passaggi seguenti descrivono come impostare e reimpostare il testo per le schede di primo livello all'interno di una struttura di moduli e sottomoduli. Il tuo progetto include il Building modulo e il Bathroom sottomodulo. Fare doppio clic su Building modulo nel Moduli visualizzazione. Si apre l'editor dei moduli (configuratore dei moduli). Attiva l'opzione Crea scheda di primo livello . Quindi viene visualizzato un campo di input con il testo di livello superiore preimpostato Building . Specificare il testo City hall . Fare doppio clic su Bathroom modulo nel Moduli visualizzazione. Si apre l'editor dei moduli (configuratore dei moduli). Attiva l'opzione Crea scheda di primo livello . Quindi viene visualizzato un campo di input con il testo di livello superiore preimpostato Building.Bathroom . Specificare il testo WC . Clic Compositore → Crea . Le visualizzazioni del modulo e il file Toplevel la visualizzazione viene creata e archiviata nel file Dispositivi visualizzazione. Fare doppio clic su Toplevel visualizzazione nel Dispositivi visualizzazione. → Salva il progetto. Fare doppio clic su Building modulo nel Moduli visualizzazione. I comandi del Compositore il menu è disponibile. Seleziona il Building modulo. Clic Compositore → Reimposta il testo delle schede di primo livello → Tutto . Clic Compositore → Crea . Le visualizzazioni del modulo e il file Toplevel visualizzazione vengono aggiornate e archiviate nel file Dispositivi visualizzazione. Apri il Toplevel visualizzazione nel Dispositivi visualizzazione. → " }, 
{ "title" : "Comando: Crea modulo da FB ", 
"url" : "ac_create_module_from_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Crea modulo da FB ", 
"snippet" : "Crea modulo da FB Questo comando (categoria \"Composer\") crea una descrizione del modulo da un blocco funzione. Vengono creati i seguenti oggetti: Descrizione del modulo con il nome <NameOfTheFB> Pool di immagini con il nome IP_<NameOfTheFB> Elenco di testo con il nome TL_<NameOfTheFB> Interfaccia co...", 
"body" : "Crea modulo da FB Questo comando (categoria \"Composer\") crea una descrizione del modulo da un blocco funzione. Vengono creati i seguenti oggetti: Descrizione del modulo con il nome <NameOfTheFB> Pool di immagini con il nome IP_<NameOfTheFB> Elenco di testo con il nome TL_<NameOfTheFB> Interfaccia con il nome TL_<NameOfTheFB> Io<nomedell'FB>. Questa interfaccia si estende AC.IModule . La descrizione del modulo viene creata secondo le seguenti regole: Tutte le variabili var_input constant sono definiti come parametri del modulo. Ecco gli attributi parameterCategory , parameterMinValue , E parameterMaxValuehere può essere utilizzato per impostare categorie e valori minimi\/massimi. Tutte le variabili numeriche var_output sono definiti come uscite del modulo. Tutte le variabili numeriche var_input sono definiti come ingressi del modulo, a meno che non siano contrassegnati come parte di un multislot. Tutte le variabili var_input di tipo Interface diventano slot singoli, se contrassegnati con il ac_single_slot attributo. Per creare un multi slot una coppia di var_input è richiesto, composto da a Pointer to Interface e una variabile intera. Entrambi devono essere contrassegnati con il 'ac_multi_slot' := '<ID>' attributo, dove il <ID> dei due deve corrispondere. " }, 
{ "title" : "Comando: Crea gestore di persistenza ", 
"url" : "ac_create_persistence_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Crea gestore di persistenza ", 
"snippet" : "Crea gestore di persistenza Questo comando (categoria \"Compositore\") inserisce un file complete Gestore della persistenza con le impostazioni predefinite nell'albero del modulo. Sotto il Persistence Manager c'è un modulo Canale di persistenza e sotto di esso un modulo Archivio dati è inserito. La st...", 
"body" : "Crea gestore di persistenza Questo comando (categoria \"Compositore\") inserisce un file complete Gestore della persistenza con le impostazioni predefinite nell'albero del modulo. Sotto il Persistence Manager c'è un modulo Canale di persistenza e sotto di esso un modulo Archivio dati è inserito. La struttura creata può poi essere modificata ed ampliata a piacere. Questo viene fatto nei parametri del modulo canale di persistenza e il modulo archivio dati . Nell'istanza del modulo di primo livello di Modulo Gestore Persistenza deve essere impostata almeno l'applicazione di destinazione. Prima che l'applicazione venga caricata sul controller, il comando creare deve essere anche eseguito. Il comando aggiunge inoltre tutte le librerie richieste al gestore delle librerie e attiva i generatori associati. " }, 
{ "title" : "Comando: Crea gestore registro dati ", 
"url" : "ac_create_datalog_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Crea gestore registro dati ", 
"snippet" : "Crea gestore registro dati Questo comando (categoria \"Compositore\") inserisce un file complete Gestore registro dati con le impostazioni predefinite nell'albero del modulo. Sotto il DataLog Manager un modulo Canale di registrazione dati e sotto di esso un modulo Archiviazione del registro dati è ins...", 
"body" : "Crea gestore registro dati Questo comando (categoria \"Compositore\") inserisce un file complete Gestore registro dati con le impostazioni predefinite nell'albero del modulo. Sotto il DataLog Manager un modulo Canale di registrazione dati e sotto di esso un modulo Archiviazione del registro dati è inserito. La struttura creata può poi essere modificata ed ampliata a piacere. Questo viene fatto nei parametri del Modulo 'Canale DataLog' e il Modulo 'CSV di archiviazione del registro dati' . Nell'istanza del modulo di primo livello di Modulo Gestione registro dati deve essere impostata almeno l'applicazione di destinazione. Prima che l'applicazione venga caricata sul controller, il comando creare deve essere anche eseguito. Il comando aggiunge inoltre tutte le librerie richieste al gestore delle librerie e attiva i generatori associati. " }, 
{ "title" : "Comando: Ottieni informazioni sulla licenza ", 
"url" : "ac_cmd_get_license_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Comandi \/ Comando: Ottieni informazioni sulla licenza ", 
"snippet" : "Ottieni informazioni sulla licenza Con questo comando (categoria «Compositore»), CODESYS ottiene il numero di istanze del modulo utilizzate nell'albero dei moduli. Viene inoltre richiesto il numero massimo consentito di istanze della licenza corrente. Il risultato viene visualizzato in Messaggi visu...", 
"body" : "Ottieni informazioni sulla licenza Con questo comando (categoria «Compositore»), CODESYS ottiene il numero di istanze del modulo utilizzate nell'albero dei moduli. Viene inoltre richiesto il numero massimo consentito di istanze della licenza corrente. Il risultato viene visualizzato in Messaggi visualizzazione. Per ulteriori informazioni, vedere ???" }, 
{ "title" : "Tutorial ", 
"url" : "f_application_composer_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Tutorial ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Esempi per iniziare ", 
"url" : "f_application_composer_first_steps.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Tutorial \/ Esempi per iniziare ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Esempio di compositore di applicazioni ", 
"url" : "ac_example_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Tutorial \/ Esempi per iniziare \/ Esempio di compositore di applicazioni ", 
"snippet" : "Basato su un piccolo progetto, questo esempio descrive come creare moduli per Application Composer. Alcuni URL in questo tutorial si collegano a pagine della guida che fanno parte di Application Composer. Se non hai installato questo pacchetto questi collegamenti non funzioneranno. Il modulo di esem...", 
"body" : "Basato su un piccolo progetto, questo esempio descrive come creare moduli per Application Composer. Alcuni URL in questo tutorial si collegano a pagine della guida che fanno parte di Application Composer. Se non hai installato questo pacchetto questi collegamenti non funzioneranno. Il modulo di esempio raffigura una stanza con una luce e un interruttore. L'interruttore può essere utilizzato come rubinetto o dimmer. Premendolo più a lungo si oscurerà la luce e spingendolo brevemente la si attiverà. La velocità per la funzione dimmer e il valore massimo della luce possono essere definiti dall'utente. Quando l'interruttore viene premuto più a lungo di un tempo specificato, viene attivata la funzione di attenuazione. L'output della luce è la luminosità. C'è una seconda luce, più semplice, che può essere accesa e spenta solo tramite un secondo interruttore. Progetto di esempio Passaggio 0: preliminari " }, 
{ "title" : "Passaggio 0: preliminari ", 
"url" : "ac_example_s0_preliminaries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Tutorial \/ Esempi per iniziare \/ Passaggio 0: preliminari ", 
"snippet" : "Prima di tutto bisogna creare un nuovo progetto. Scegli dunque Nuovo progetto dal File menu e salvare il nuovo progetto. È necessario aggiungere un Gestore della libreria nel file POU visualizzazione. Poi la biblioteca AC_ModuleBase , che fa parte del CODESYS Application Composer pacchetto, può esse...", 
"body" : "Prima di tutto bisogna creare un nuovo progetto. Scegli dunque Nuovo progetto dal File menu e salvare il nuovo progetto. È necessario aggiungere un Gestore della libreria nel file POU visualizzazione. Poi la biblioteca AC_ModuleBase , che fa parte del CODESYS Application Composer pacchetto, può essere aggiunto al gestore della libreria. Aggiungi libreria \"AC_ModulBase\" Passaggio 1: creazione della \"stanza\" del modulo di primo livello " }, 
{ "title" : "Passaggio 1: creazione della \"stanza\" del modulo di primo livello ", 
"url" : "ac_example_s1_create_toplevel_room.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Tutorial \/ Esempi per iniziare \/ Passaggio 1: creazione della \"stanza\" del modulo di primo livello ", 
"snippet" : "Aggiungi una dichiarazione di modulo e un blocco funzione al file POU piscina. Il blocco funzione viene utilizzato per l'implementazione (programma funzione) del modulo. In questo esempio, al modulo e al blocco funzione viene assegnato il nome Room . Inoltre il blocco funzione deve estendere il tipo...", 
"body" : "Aggiungi una dichiarazione di modulo e un blocco funzione al file POU piscina. Il blocco funzione viene utilizzato per l'implementazione (programma funzione) del modulo. In questo esempio, al modulo e al blocco funzione viene assegnato il nome Room . Inoltre il blocco funzione deve estendere il tipo base AC.Module , che fa parte del AC_ModuleBase libreria e fornisce un'ampia gamma di proprietà e funzionalità. Poiché non vogliamo modificare quest'ultimo, tutte le proprietà e le funzioni create con il blocco funzione possono essere cancellate. Aggiungi blocco funzione e modulo La dichiarazione inizia con la parola chiave MODULE seguito dal nome del modulo e IMPLEMENTED_BY e il nome del blocco funzione che implementa il modulo, che nel caso in questione è il blocco funzione Room. In questo caso specifico, questo è il Room blocco funzione. Nella maggior parte dei casi, la sezione MetaData è dichiarato adesso. Per informazioni dettagliate su tutti i parametri di tutte le sezioni consultare le pagine della guida in Dichiarazione del modulo . Perché Camera è il modulo di primo livello nel nostro esempio, la sezione successiva dichiarata è il Toplevel sezione. Quest'ultimo permette di definire un nome per l'elenco delle variabili globali ( GVL_name ) comprese le istanze dei blocchi funzione di primo livello dopo la generazione. Successivamente è necessario definire almeno un'altra attività nella sezione di primo livello. Questo è Standard_Task in questo esempio, che è definito come a MEDIUM attività e contiene i flag CREATE_IF_MISSING E UPDATE_IOS . Dichiarazione del modulo Room Tutte le icone e le stringhe, utilizzate per la descrizione e i segnaposto delle icone del modulo (parametri Desc , Icon_16 E Icon_32 ) devono essere referenziati da elenchi di testi e pool di immagini. Detto questo, un elenco di testi appropriato TL e pool di immagini IP , che includono tutte le icone e i testi a cui si fa riferimento, devono essere creati e aggiunti al file POU piscina. Creazione di elenchi di testi e pool di immagini Passaggio 2: creazione del sottomodulo \"Switch\" " }, 
{ "title" : "Passaggio 2: creazione del sottomodulo \"Switch\" ", 
"url" : "ac_example_s2_create_sublevel_switch.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Tutorial \/ Esempi per iniziare \/ Passaggio 2: creazione del sottomodulo \"Switch\" ", 
"snippet" : "Il passo successivo è dichiarare un modulo per il cambio della stanza. Anche in questo caso è necessario creare una dichiarazione del modulo e un blocco funzione. Qui vengono chiamati entrambi Switch , dove la dichiarazione deve essere implementata dal blocco funzione. La dichiarazione del modulo di...", 
"body" : "Il passo successivo è dichiarare un modulo per il cambio della stanza. Anche in questo caso è necessario creare una dichiarazione del modulo e un blocco funzione. Qui vengono chiamati entrambi Switch , dove la dichiarazione deve essere implementata dal blocco funzione. La dichiarazione del modulo di Switch non ha bisogno di una sezione di primo livello, perché verrà aggiunta sotto il modulo Light (descritto più avanti) in nessuna posizione di primo livello. Poiché è obbligatorio per tutti i moduli che implementano blocchi funzione, il blocco funzione Switch deve estendersi AC.Module , pure. Nel caso in questione, il blocco funzione implementa anche un'interfaccia ISwitch , che deve essere creato. Questa stessa interfaccia deve implementare l'interfaccia IModule , fornito dalla biblioteca AC_ModuleBase . Tuttavia, l'interfaccia ISwitch rimane \"vuoto\": nessuna proprietà o funzione viene dichiarata. Inoltre l'interruttore necessita di un segnale di ingresso (probabilmente da una fonte esterna\/interruttore fisico) per indicare quando viene toccato. Questo segnale è dichiarato nel IO sezione utilizzando la variabile xIn del blocco funzione che implementa questo modulo. Inoltre è necessario un tempo di riferimento per distinguere le due funzioni dell'interruttore: Pressione dell'interruttore per la durata del tempo tTimer avvia la funzione di regolazione della luminosità: una pressione più breve accende o spegne solo la luce. Questa variabile tTimer (essendo anch'esso parte del blocco funzione di implementazione del modulo) sarà dichiarato come parametro del modulo (sezione Parameters ), che eventualmente potrà essere facilmente modificato durante l'utilizzo del modulo. Dichiarazione del sottomodulo Switch Le variabili referenziate xIn E tTimer sono entrambi definiti come ingressi del blocco funzione Switch , dove il parametro tTimer ottiene un valore predefinito iniziale di 500 ms. Quindi, quando l'utente preme il file Switch per più di 500 ms, la luce verrà attenuata. Dichiarazione nel Switch blocco funzione Anche gli elenchi di testi e il pool di immagini devono essere estesi per includere i testi descrittivi necessari dell'input e del parametro. Voci nell'elenco testi e nel pool di immagini Passaggio 3: creazione del sottomodulo \"Cambia semplice\" " }, 
{ "title" : "Passaggio 3: creazione del sottomodulo \"Cambia semplice\" ", 
"url" : "ac_example_s3_create_sublevel_switchsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Tutorial \/ Esempi per iniziare \/ Passaggio 3: creazione del sottomodulo \"Cambia semplice\" ", 
"snippet" : "Il secondo modulo switch, che vogliamo dichiarare, è semplificato con solo due stati: on e off. Pertanto è necessario creare una dichiarazione del modulo e un blocco funzione, che sono adattati dal \"Dim-Switch\" sopra. Una nuova interfaccia di tipo ISwitchSimple viene utilizzato per il blocco funzion...", 
"body" : "Il secondo modulo switch, che vogliamo dichiarare, è semplificato con solo due stati: on e off. Pertanto è necessario creare una dichiarazione del modulo e un blocco funzione, che sono adattati dal \"Dim-Switch\" sopra. Una nuova interfaccia di tipo ISwitchSimple viene utilizzato per il blocco funzione. Un'altra differenza è che la variabile xIn deve essere dichiarato come variabile BOOL e nessun parametro tTimer è affatto necessario. Passaggio 4: creazione del sottomodulo \"Light\" " }, 
{ "title" : "Passaggio 4: creazione del sottomodulo \"Light\" ", 
"url" : "ac_example_s4_create_sublevel_light.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Tutorial \/ Esempi per iniziare \/ Passaggio 4: creazione del sottomodulo \"Light\" ", 
"snippet" : "Come già fatto in precedenza per il Switch e il SwitchSimple , per il modulo Light , una dichiarazione di modulo Light , un blocco funzione Light e un'interfaccia ILight devono essere creati. Il modulo sarà implementato dal blocco funzione, che a sua volta implementerà l'interfaccia ILight . Per pot...", 
"body" : "Come già fatto in precedenza per il Switch e il SwitchSimple , per il modulo Light , una dichiarazione di modulo Light , un blocco funzione Light e un'interfaccia ILight devono essere creati. Il modulo sarà implementato dal blocco funzione, che a sua volta implementerà l'interfaccia ILight . Per poter aggiungere il Light modulo sotto il nostro Room module, la dichiarazione del modulo di Room deve essere esteso con a Slots sezione. In questa sezione una sottosezione Slot_Multi deve essere creato, che si chiama Lights e potrà contenere moduli del tipo Light . Il numero di luci che possono o devono essere aggiunte ad una stanza è definito dal parametro Cardinality (in questo caso tra 1 e 3 luci). Inoltre vengono dichiarate due variabili: Variable ( pLights , che conterrà le istanze dei blocchi funzione dei moduli Luce aggiunti alla stanza) e Var_Count ( uiNumberOfLights , che verrà riempito con il numero di moduli Luce aggiunti alla stanza). Definizione di sezione Slots Le variabili pLights E uiNumberOfLights devono essere aggiunti al blocco funzione del modulo \"Luci\", dove uiNumberOfLights è un UINT E pLights di tipo POINTER TO ILight Con questa definizione, solo i moduli i cui blocchi funzione implementano anche il file ILight l'interfaccia può essere aggiunta al file Lights fessura. Dichiarazione nel Room blocco funzione Lo stesso concetto di slot utilizzato per Room moduli è ora utilizzato per Light modulo. Di conseguenza, la dichiarazione di Light include uno slot con a Switch , motivo per cui questo slot non è un multi-slot, ma uno slot semplice. Parametri aggiuntivi del Light modulo sono la velocità del dimmer rSpeed e la luminosità massima uiMaxValue . Infine è necessario definire un'uscita che rappresenti la luminosità della luce associata. Tutti i parametri, gli slot e le uscite devono essere aggiunti anche come variabili al blocco funzione di Light modulo. Dichiarazione del modulo Light Dichiarazione del blocco funzione Light Elenco testi e pool di immagini Passaggio 5: creazione del sottomodulo \"Light simple\" " }, 
{ "title" : "Passaggio 5: creazione del sottomodulo \"Light simple\" ", 
"url" : "ac_example_s5_create_sublevel_lightsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Tutorial \/ Esempi per iniziare \/ Passaggio 5: creazione del sottomodulo \"Light simple\" ", 
"snippet" : "La luce semplice, creata ora, funzionerà insieme a un semplice interruttore, ma può essere adattata Light sopra, comunque. Pertanto una nuova dichiarazione di modulo e un nuovo blocco funzione LightSimple devono essere creati. Poiché il blocco funzione implementa semplicemente l'interfaccia ILight ,...", 
"body" : "La luce semplice, creata ora, funzionerà insieme a un semplice interruttore, ma può essere adattata Light sopra, comunque. Pertanto una nuova dichiarazione di modulo e un nuovo blocco funzione LightSimple devono essere creati. Poiché il blocco funzione implementa semplicemente l'interfaccia ILight , sarà possibile aggiungere luci di diverso tipo ad una stanza in un secondo momento. La differenza principale rispetto a Light è che la variabile dello slot deve essere del tipo ISwitchSimple per evitare errori di commutazione, viene inserito sotto a LightSimple modulo. Inoltre l'output di LightSimple sarà di tipo BOOL e prende il nome xSwitchedOn . Passaggio 6: implementazione " }, 
{ "title" : "Passaggio 6: implementazione ", 
"url" : "ac_example_s6_implementation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Tutorial \/ Esempi per iniziare \/ Passaggio 6: implementazione ", 
"snippet" : "Interruttori Per l'implementazione delle funzionalità del modulo Switch usiamo il metodo CallPrioMediumStart da Module sovrascrivendolo con la nostra implementazione. Scegliamo questa funzione, perché il module Room dichiarato a MEDIUM compito, il che implica che il metodo CallPrioMediumStart del bl...", 
"body" : "Interruttori Per l'implementazione delle funzionalità del modulo Switch usiamo il metodo CallPrioMediumStart da Module sovrascrivendolo con la nostra implementazione. Scegliamo questa funzione, perché il module Room dichiarato a MEDIUM compito, il che implica che il metodo CallPrioMediumStart del blocco funzione Switch verrà chiamato ogni ciclo di un compito medio. Le informazioni dettagliate possono essere visualizzate nel progetto di esempio stesso. Tuttavia, la funzionalità principale dell'interruttore è quella di differire tra la funzione tap e quella dim. Dopo aver premuto l'interruttore, verrà avviato un timer con il tempo specificato dal parametro utente. Quando il timer è terminato e l'interruttore non viene rilasciato, viene utilizzata la funzione di attenuazione, indicata dalla variabile xPushLong . La variabile xPush È TRUE , se l'interruttore è appena premuto. Per entrambi xPushLong E xPush le proprietà vengono aggiunte a entrambi i blocchi funzione Switch e l'interfaccia ISwitch , in modo che possano essere utilizzati dal blocco funzione luce genitore. Leggero Ancora una volta, il Light il blocco funzione sovrascrive il metodo CallPrioMediumStart . A seconda delle variabili di ingresso dell'interruttore sottostante, la luce viene regolata su \"on\" o \"off\" o solo commutata. Per il dimmer, il valore di velocità del parametro dichiarato rSpeed si usa. Dopo aver raggiunto il valore di regolazione massimo o minimo, la regolazione viene interrotta. Se la luce è attenuata e si tocca l'interruttore, la luce è accesa. (L'implementazione dettagliata è riportata nel corrispondente progetto di esempio.) Controlla il codice Dopo l'implementazione, le dichiarazioni dovrebbero essere controllate utilizzando il comando Costruire . Se non viene visualizzato alcun errore, le dichiarazioni vanno bene. Passaggio 7: composizione dei moduli " }, 
{ "title" : "Passaggio 7: composizione dei moduli ", 
"url" : "ac_example_s7_composing_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Tutorial \/ Esempi per iniziare \/ Passaggio 7: composizione dei moduli ", 
"snippet" : "Dopo aver scansionato con successo le dichiarazioni, tutti i moduli sono disponibili per un ulteriore utilizzo, in modo da poter comporre un'applicazione di esempio. Pertanto i moduli vengono aggiunti all'albero dei moduli del progetto. Per questo la vista Moduli deve essere aperto. Nel primo passag...", 
"body" : "Dopo aver scansionato con successo le dichiarazioni, tutti i moduli sono disponibili per un ulteriore utilizzo, in modo da poter comporre un'applicazione di esempio. Pertanto i moduli vengono aggiunti all'albero dei moduli del progetto. Per questo la vista Moduli deve essere aperto. Nel primo passaggio il modulo di primo livello Room deve essere aggiunto all'albero. Aggiungi il modulo di primo livello all'albero dei moduli IL Finestra di dialogo del modulo si apre e offre tutti i moduli di primo livello disponibili. In questa finestra di dialogo vengono visualizzate le icone corrispondenti definite nel pool di immagini, nonché i testi degli elenchi di testi. Ora è possibile selezionare il modulo \"Stanza\" e aggiungerlo all'albero dei moduli. Finestra di dialogo: \"Aggiungi modulo\" Ora è possibile aprire l'editor del modulo di primo livello facendo doppio clic Room nell'albero dei moduli. È necessario selezionare un'applicazione di destinazione per la generazione del codice Toplevel scheda. Le attività dichiarate nella dichiarazione del modulo vengono visualizzate nel campo Compiti standard . Impostazioni del modulo \"Stanza\". Analogo ai passaggi sopra il sottomodulo Light può essere aggiunto all'albero dei moduli. A causa della definizione multi-slot nella dichiarazione della stanza, è possibile aggiungere fino a tre luci. I valori per maxLightValue E Speed può essere parametrizzato su Parameters scheda dell'editore del Light modulo. Nell'editor I\/O l'output Brightness è mappato su una variabile locale uiBrightness per il nostro esempio. Impostazioni del modulo \"Luce\". Di seguito il nuovo aggiunto Light , un modulo Switch deve essere aggiunto. Nell'editor di istanze del Switch modulo, sono disponibili tutti i parametri e gli I\/O definiti nella dichiarazione del modulo. Per il nostro esempio la variabile locale xPushSwitch è mappato sulla variabile di input xIn . L'output della luce semplice viene mappato sulla variabile locale xSimpleOn . Impostazioni del modulo \"Cambia\". Nell'ultimo passaggio del nostro esempio a LightSimple con un SwitchSimple vengono aggiunti all'albero dei moduli. L'output della luce semplice viene mappato sulla variabile locale xSimpleOn . L'ingresso del semplice interruttore xPushSimpleSwitch è mappato sulla variabile xPushSimpleSwitch. Esempio di albero dei moduli di composizione Alla fine, il progetto deve essere generato utilizzando il comando creare . Dopo il download su un dispositivo, è possibile testare l'esempio modificando il valore di xPushSwitch . Per attenuare il valore di uiLuminosità dovrebbe aumentare lentamente e toccando si imposta direttamente il suo valore a 0 o al massimo. Mutevole xPushSimpleSwitch commuta direttamente l'uscita della luce corrispondente. Infine va detto che gli ultimi passaggi della composizione dei moduli possono essere eseguiti in qualsiasi combinazione, senza perdere la funzionalità del codice generato. " }, 
{ "title" : "Biblioteca: Meccatronica ", 
"url" : "ac_mechatronics_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor del modulo \/ Tutorial \/ Biblioteca: Meccatronica ", 
"snippet" : "IL Mechatronics La libreria vuole essere un esempio per una semplice (e non completa) implementazione di un'unità meccatronica con esecuzione sequenziale. Non soddisfa tutti i requisiti che potrebbe avere un'applicazione meccatronica completa. Piuttosto, è inteso come punto di ingresso o base per un...", 
"body" : "IL Mechatronics La libreria vuole essere un esempio per una semplice (e non completa) implementazione di un'unità meccatronica con esecuzione sequenziale. Non soddisfa tutti i requisiti che potrebbe avere un'applicazione meccatronica completa. Piuttosto, è inteso come punto di ingresso o base per un'applicazione di questo tipo. Il nucleo essenziale del modello meccatronico proposto si basa sulla seguente struttura di moduli: Esempio di compositore di applicazioni Mechatronics Si presuppone quindi che ogni macchina possa avere diverse subunità meccatroniche (esempio: ciascuna rappresenta una pinza). Tale sottounità si suddivide nuovamente nei suoi attuatori (come l'unità meccanica stessa, anche la sua implementazione funzionale o gestione I\/O) e un program manager. Il program manager ha lo scopo di gestire i diversi stati di una subunità meccatronica, ad esempio la sua Idle O Execute stato. Eventualmente tali stati sono rappresentati da sequenze di programma che controllano gli attuatori o qualsiasi altra cosa necessaria per una corretta esecuzione. A questo punto verranno brevemente descritte nel dettaglio le varie parti. Quando si utilizza la libreria, in molti casi sarà necessario implementare i propri attuatori, fasi di flusso o sequenze di programma, che verranno spiegati anche qui. Attuatori : Tutti i moduli che dovrebbero essere attuatori devono essere implementati da un blocco funzione che a sua volta implementa il IActuator interfaccia. Questa interfaccia non ha metodi o proprietà e viene utilizzata solo per la compatibilità dei moduli (vedere il file IActuator documentazione in biblioteca). Non sono previste restrizioni o regole per l'implementazione dell'attuatore, per cui il movimento o l'attivazione di tale attuatore deve essere eseguito separatamente. Normalmente ciò avviene implementando un modulo a passi sequenziali, che può trattenere gli appositi attuatori in uno slot di riferimento e quindi muovere questi ultimi nel modo desiderato (ad esempio utilizzando interfacce aggiuntive). Passi della sequenza Si consiglia vivamente di eseguire l'implementazione delle fasi di flusso come classi derivate di StepBase blocco funzione. Ciò fornisce tutte le implementazioni di base necessarie di IProgramSequenceStep interfaccia. Vedi il IActuator documentazione in biblioteca. Quando si utilizza la classe base StepBase , è quindi solo necessario implementare il Execute metodo. Quest'ultimo viene poi chiamato ciclicamente dal flusso del programma fino alla variabile xDone della classe base è impostata su TRUE . Inoltre, per una corretta funzionalità, il flag xActive dovrebbe essere impostato su TRUE finché il passaggio è attivo. Tuttavia il collegamento agli attuatori può essere effettuato in qualunque modo, ad esempio tramite le feritoie di riferimento proposte (vedi 1.). Sequenza del programma e gestione del programma Una sequenza di programma è un sottomodulo di un program manager che rappresenta uno stato. Questi stati sono gestiti sotto forma di una macchina a stati OMAC. Le sue implementazioni si basano ancora sul metodo \"Execute\" (per i dettagli vedere l'implementazione nella libreria). Nella maggior parte dei casi, tuttavia, l'implementazione di tale flusso di programma da parte dell'utente non è necessaria. Qui di seguito viene tuttavia brevemente descritto il modo in cui il comportamento della macchina a stati viene implementato nel Program Manager e quindi esegue le sequenze del programma: Esistono due tipi di stati: stati di azione (che terminano con \"ing\") e stati di attesa\/duplici (il resto). Gli stati di attesa vengono terminati da comandi esterni, mentre gli stati di azione vengono eseguiti e terminati automaticamente. I comandi disponibili dipendono dallo stato in cui si trova attualmente il program manager. Una breve panoramica è fornita nel diagramma di stato OMAC: Diagramma OMAC Modulo: MovableBarrier Il modulo MovableBarrier è implementato nel modo seguente: Il blocco funzione corrispondente MovableBarrier implementa l'interfaccia creata IMovableBarrier . Quest'ultima interfaccia definisce i metodi per spostare una barriera, mentre IMovableBarrier stesso implementa l'interfaccia IActuator , in modo che il modulo MovableBarrier è inseribile come attuatore nell'albero dei moduli sotto un'unità meccatronica: Implementazione del modulo MovableBarrier Tuttavia, questo attuatore \"MovableBarrier\" viene spostato dal modulo passo-sequenza MoveBarrierForTime , che a sua volta è implementato nel modo seguente: Implementazione del modulo MoveBarrierForTime Il modulo che implementa il blocco funzione MoveBarrierForTime deriva semplicemente dal blocco funzione di base contenuto nella libreria AC_MEC.StepBase . In questo modo il blocco funzione MoveBarrierForTime implementa già l'interfaccia IProgramSequenceStep . Di conseguenza il modulo MoveBarrierForTime è inseribile come passo di sequenza in una sequenza di programma. L'implementazione funzionale del blocco funzione MoveBarrierForTime è la seguente: definendo uno slot di riferimento per il modulo MoveBarrierForTime , che può contenere un attuatore che implementa l'interfaccia IMovableBarrier , si ottiene un collegamento ad un attuatore \"MovableBarrier\" esistente. Il movimento di questo attuatore avviene infine nel Execute funzione del MoveBarrierForTime blocco funzione, che richiama semplicemente il metodo per spostare (immagineticamente) la calotta protettiva. Questo metodo è fornito dall'attuatore di riferimento, che lo implementa IMovableBarrier . Inoltre la proprietà Done e la variabile xActive sono accoppiati a un TON, in modo che richiami ripetutamente alle funzioni di spostamento di IMovableBarrier vengono eseguite fino allo scadere di un certo tempo (TON), trascorso il quale Done è impostato su TRUE e xActive a FALSO. La proprietà Done fa parte dell'interfaccia IProgramSequenceStep e con ciò comunica alla sequenza del programma sovraordinato che verrà eseguito il passo successivo della sequenza. A parte la tua implementazione dei passaggi della sequenza, il file AC_Mechatronics.library fornisce anche alcuni passaggi pre-implementati, che possono essere utilizzati per operazioni logiche generali. Ad esempio questo significa un passo BranchOnBool viene fornito, che ha due sottosequenze\/rami di passi, che vengono eseguiti in base al valore di una variabile BOOL. Questi passaggi secondari vengono eseguiti in base al valore di una variabile booleana. Inoltre, la biblioteca AC_Mechatronics.library contiene passaggi di flusso per flussi paralleli, salti condizionali o semplici passaggi di attesa e molte altre attività. " }, 
{ "title" : "Editor delle dichiarazioni del modulo ", 
"url" : "ac_module_declaration_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo ", 
"snippet" : "Un modulo rappresenta tipicamente un componente meccatronico ma può anche essere una pura funzione software. Contiene tutti gli aspetti ingegneristici coperti da CODESYS . Un modulo ha un blocco funzione che implementa l'interfaccia IModule dalla biblioteca AC_ModuleBase . Contiene inoltre informazi...", 
"body" : "Un modulo rappresenta tipicamente un componente meccatronico ma può anche essere una pura funzione software. Contiene tutti gli aspetti ingegneristici coperti da CODESYS . Un modulo ha un blocco funzione che implementa l'interfaccia IModule dalla biblioteca AC_ModuleBase . Contiene inoltre informazioni su sottomoduli, parametrizzazione, richiesta di I\/O, assegnazione di compiti e visualizzazioni. I moduli costituiscono il concetto centrale del CODESYS Application Composer . IL CODESYS Application Composer fornisce anche un modello di progetto, che può essere selezionato nel file Nuovo progetto dialogo. Questo modello crea un progetto con un dispositivo, un'applicazione e un gestore della libreria nel pool POU. Quest'ultimo contiene le biblioteche AC_ModuleBase E AC_Persistence . Il modello, che si basa sul progetto ComposerProject.project , può essere modificato se necessario. È memorizzato nella sottocartella \"Modelli\" del file CODESYS directory di installazione. È possibile creare automaticamente un modulo da un blocco funzione esistente. In questo modo, per quanto possibile, le dichiarazioni esistenti vengono trasferite nella dichiarazione del modulo. Per i dettagli vedere la descrizione del Crea modulo da FB comando. Vedere Dichiarazione del modulo per informazioni dettagliate su come sviluppare i moduli. Per informazioni sullo scambio di dati tra diverse applicazioni vedere IRMPService . " }, 
{ "title" : "Dichiarazione del modulo ", 
"url" : "ac_module_declaration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo ", 
"snippet" : "La dichiarazione dei moduli viene eseguita con un proprio linguaggio di descrizione che è simile alla dichiarazione delle variabili nel codice testo strutturato (ST). Sezioni della dichiarazione del modulo Sezione: Metadati Sezione: Livello superiore Sezione: IO Sezione: Parametri Sezione: Slot Sezi...", 
"body" : "La dichiarazione dei moduli viene eseguita con un proprio linguaggio di descrizione che è simile alla dichiarazione delle variabili nel codice testo strutturato (ST). Sezioni della dichiarazione del modulo Sezione: Metadati Sezione: Livello superiore Sezione: IO Sezione: Parametri Sezione: Slot Sezione: Visi Sezione: Procure Sezione: VarArray Sezione: Vincoli Sezione: Rif.Ist Sezione: mse.Sequenza Generatore di dispositivialg.Allarme" }, 
{ "title" : "Formato della dichiarazione del modulo ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_48fab9ed86f6686ac0a8640e00dcb86d", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Formato della dichiarazione del modulo ", 
"snippet" : "Un'intestazione del modulo MODULE<name> inizia la dichiarazione. Questo è seguito da un elenco di \"sezioni\". Ogni sezione è introdotta dalla parola chiave SEC (per \"sezione\") e un nome univoco. La parola chiave END_SEC chiude la sezione. Il contenuto di una sezione contiene un elenco di voci compost...", 
"body" : "Un'intestazione del modulo MODULE<name> inizia la dichiarazione. Questo è seguito da un elenco di \"sezioni\". Ogni sezione è introdotta dalla parola chiave SEC (per \"sezione\") e un nome univoco. La parola chiave END_SEC chiude la sezione. Il contenuto di una sezione contiene un elenco di voci composto da ulteriori sezioni o cosiddette definizioni. Una definizione è composta da un nome e un valore opzionale e termina con un punto e virgola. I commenti possono essere utilizzati come nel codice ST: \"\/\/\"\" per commenti a riga singola e \"(*\" e \"*)\" per commenti su più righe. È possibile utilizzare spazi bianchi (tabulazioni e spazi) e fine riga\/avanzamento riga per separare le parti di una dichiarazione, altrimenti vengono ignorati durante l'ulteriore elaborazione. Come con il codice ST, la distinzione tra maiuscole e minuscole non fa differenza. L'esempio seguente spiega gli elementi di una dichiarazione di modulo 01 MODULE Persistence IMPLEMENTED_BY PersistenceFB\n02 SEC MetaData\n03 NAME := TL.ChannelName ;\n04 DESC := TL.ChannelDesc ;\n05 COLLECTION CATEGORY := ’Persistence’TL.Collection ;\n06 ICON_16 := IP.Channel16 ;\n07 ICON_32 := IP.Channel32 ;\n08 END_SEC\n09 SEC Toplevel\n10 SEC STANDARD_TASK : LOW\n11 NAME := LOW ;\n12 DESC := TL.TaskLow ;\n13 FLAGS := CREATE_IF_MISSING | READONLY ;\n14 END_SEC\n15 GVL_NAME := 'GVL_%InstanceName%' ;\n16 END_SEC Nella riga 01 c'è la definizione del nome del modulo \"Persistenza\". IMPLEMENTED_BY definisce il blocco funzione \"PersitenceFB\" che contiene la logica del modulo. Questo blocco funzione deve derivare da IModule . Nella riga 02 la sezione MetaData inizia e termina con la riga 08. Questa sezione contiene cinque definizioni. La possibilità di sezioni nidificate è mostrata nella sezione Toplevel (righe 09–16) che contiene la sottosezione STANDARD_TASK (riga 10). " }, 
{ "title" : "Sintassi della dichiarazione del modulo ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_819a1c8e627d0b32c0a8640e01623943", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sintassi della dichiarazione del modulo ", 
"snippet" : "In questa sezione verrà spiegata la sintassi e la struttura sintattica consentita per una dichiarazione di modulo. Nello scanner seguente i token verranno scritti in maiuscolo (esempio: ID ). I non terminali della grammatica saranno scritti tra parentesi graffe (esempio: {Entry} ). Analisi lessicale...", 
"body" : "In questa sezione verrà spiegata la sintassi e la struttura sintattica consentita per una dichiarazione di modulo. Nello scanner seguente i token verranno scritti in maiuscolo (esempio: ID ). I non terminali della grammatica saranno scritti tra parentesi graffe (esempio: {Entry} ). Analisi lessicale (scanner) Nel primo passo verranno creati i cosiddetti token (o lessemi) dai caratteri della dichiarazione del modulo (esempio: parole chiave, costanti, identificatori). Gli spazi bianchi e i caratteri newline\/linefeed separano i token, ma altrimenti verranno ignorati. Anche i commenti verranno ignorati per l'ulteriore trattamento della dichiarazione. (I commenti possono essere scritti su una sola riga ( \/\/ \") o commenti su più righe ( (* E *) ) come nel linguaggio ST. I commenti su più righe possono essere nidificati. Fondamentalmente un token ha sempre una lunghezza massima. Per esempio a123 verrà interpretato come un identificatore e non come un identificatore a seguito da un letterale 123 . L'ordine dei token nell'elenco seguente mostra la loro priorità. Ad esempio l'input MODULE verrà intesa come parola chiave e non come identificatore. Elenco di tutti i token disponibili: Parole chiave: MODULE , SEC , END_SEC , IMPORTS , E IMPLEMENTED_BY OP: una sequenza non vuota dei seguenti caratteri: .:,%()[]{}<>|+-*\/@!?^°=\\~ Nota: gli indicatori di commento \/\/ , (* , E *) hanno una priorità più alta rispetto agli operatori. Non può esserci alcun commento all'interno di un operatore, nessun commento può essere, ad esempio: +\/\/+ verrà, secondo la regola della massima lunghezza, interpretato come un operatore e non come + seguito da un commento. LIT: un valore letterale IEC, come viene utilizzato in ST, esempio: 1.4 , tod#12:13:14 . Ciò include i valori letterali booleani TRUE E FALSE (maiuscolo o minuscolo non è rilevante). Nota: letterali non tipizzati con segno negativo ( -1 , -3.2 ) verranno letti come due token, cioè come operatore - seguito da un letterale non tipizzato. Il risultato di questi valori letterali numerici non tipizzati non può mai essere negativo. Letterali digitati ( INT#-34 ) verrà sempre interpretato come un token. ID: un identificatore IEC valido ( [a-zA-Z_][a-zA-Z0-9_]* ), per cui non sono ammesse due sottolineature consecutive. Ciò include, contrariamente a ST, anche le parole chiave di ST (cioè: FUNCTION , INT , EXTENDS ,…) Punto e virgola: il carattere ; Sintassi (parser) La sintassi della dichiarazione del modulo è definita dalla seguente grammatica. µ è una sequenza vuota. {MDecl} ::= MODULE {QID} {ImplSpec} {ImportsSpec} {MBody}\n{ImplSpec} ::= IMPLEMENTED_BY {QID} | µ\n{ImportsSpec} ::= IMPORTS {QID} | µ\n{MBody} ::= {SecList}\n{SecList} ::= {Modifiers} {Sec} {SecList} | µ\n{Sec} ::= SEC {QID} {SecTarget} {EntryList} END_SEC\n{SecTarget} ::= OP(\":\") {QID} | µ\n{Modifiers} ::= OP(\"[\") {ModifierList} OP(\"]\") | µ\n{ModifierList} ::= {QID} OP(\",\") {ModifierList} | {QID}\n{EntryList} ::= {Modifiers} {Entry} {EntryList}\n{Entry} ::= {Sec} | {Def}\n{Def} ::= {QID} OP(\":=\") {ValList} SEMICOLON |\n {QID} SEMICOLON\n{ValList} ::= {Val} {ValList} | {Val}\n{Val} ::= ID | LIT | OP\n{QID} ::= ID | ID OP(\".\") {QID} L'elenco dei valori di definizione ( {ValList} ) deve essere completato con un punto e virgola. Ciò semplifica la grammatica ed evita ambiguità, perché il punto e virgola non può far parte di un valore ( {VAL} ), tranne che all'interno di una stringa letterale. L'operatore di assegnazione ( := ) delle definizioni ( {Def} ) serve anche a evitare ambiguità ( {QID} ) dei nomi e dei valori delle definizioni. Tipi definiti per le definizioni Testo: ID.ID (nome dell'elenco di testi e identificatore dell'elenco di testi) - vedi Localizzazione delle stringhe dell'elenco di testi Immagine: ID.ID (nome del pool di immagini e identificatore del pool di immagini) ID (identificatore IEC) QID (identificatore qualificato): {QID} ::= ID | ID.ID CategoryPath ::= {StringLiteral} | {CategoryPath} Cardinalità: [{MIN} .. {MAX}] | [ {MIN} .. INF [ {MIN} , E {MAX} sono valori letterali interi e non negativi. Se {MAX} != INF , Poi {MIN} <= {MAX} deve applicare. StringLiteral: una stringa letterale IEC può contenere interruzioni di riga. StdTaskFlags ::= {StdTaskFlag} | {StdTaskFlags} StdTaskFlag ::= NONE | CREATE_IF_MISSING | READONLY Letterale: qualsiasi letterale IEC o QID (per costanti Enum) DTBoolFlag: µ (sequenza vuota) | TRUE | FALSE Tipo di slot: SUBMODULE | REFERENCE Pragma: [ {PragmaList} ] {PragmaList} ::= {Pragma} | {Pragma} , {PragmaList} {Pragma} ::= { ( ID | {StringLiteral} | {OP2} )+ } {OP2} : tutti gli operatori tranne {, }, [, ] E , . Percorso istanza: InstancePath ::= {IComp} | {IComp} . {IComp} mit {IComp} ::= ID {ArrayAccess}* e {ArrayAccess} ::= [ {IntList} ] e {IntList} ::= Int | Int , {IntList} Rif.Attività: Attività_Standard. ( Low | Medium | High ) | Custom_Task.ID " }, 
{ "title" : "Percorsi delle istanze ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_e00dd4f26a1882aec0a8652000c0a4ae", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Percorsi delle istanze ", 
"snippet" : "In alcune posizioni nella dichiarazione del modulo è possibile definire percorsi di istanza per indirizzare una variabile di un blocco funzione: per parametri, slot, I\/O, array con dimensioni variabili e riferimenti di istanza. Un percorso di istanza è definito come una sequenza non vuota di compone...", 
"body" : "In alcune posizioni nella dichiarazione del modulo è possibile definire percorsi di istanza per indirizzare una variabile di un blocco funzione: per parametri, slot, I\/O, array con dimensioni variabili e riferimenti di istanza. Un percorso di istanza è definito come una sequenza non vuota di componenti, separati da punti: C1.C2…CN . Un componente deve essere un identificatore IEC o un componente seguito da un'espressione di indice [i1, …, iN] , Dove i1 A iN sono valori interi. I percorsi delle istanze sono sempre relativi al blocco funzione che implementa la logica del modulo. Il primo componente del percorso dell'istanza è un membro ( VAR_INPUT O VAR_OUTPUT , a seconda del caso d'uso) del blocco funzione. In caso di componenti aggiuntivi nel percorso dell'istanza, questi componenti indirizzano la variabile all'interno del membro. Altrimenti viene indirizzato il membro stesso. I percorsi delle istanze possono essere limitati alle variabili di ingresso o di uscita (esempio: per I\/O). Per le strutture queste restrizioni non valgono. Questo tipo di percorsi di istanza sono chiamati percorsi di istanza di input risp. percorsi delle istanze di output. " }, 
{ "title" : "Localizzazione delle stringhe dell'elenco di testi ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_497561d55e22d540c0a8640e01561e3c", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Localizzazione delle stringhe dell'elenco di testi ", 
"snippet" : "I testi nei moduli (esempio: descrizione del modulo, nome, descrizione del parametro) possono essere visualizzati in diverse lingue. Questi testi vengono gestiti in elenchi di testi. Specifica per il nome della lingua: Il nome della lingua è di formato <LanguageCode>[-<Country\/Region>] (esempio: en-...", 
"body" : "I testi nei moduli (esempio: descrizione del modulo, nome, descrizione del parametro) possono essere visualizzati in diverse lingue. Questi testi vengono gestiti in elenchi di testi. Specifica per il nome della lingua: Il nome della lingua è di formato <LanguageCode>[-<Country\/Region>] (esempio: en-US , de-DE ). <LanguageCode> è il nome della lingua secondo ISO 639-1 (esempio: de O en ). <Country\/Region> è un codice paese secondo ISO 3166. Quando si richiama una voce dell'elenco di testi, il sistema cerca innanzitutto il nome completo della lingua. Se non viene trovato nulla, cerca il file <LanguageCode> . Se anche questa ricerca fallisce, verrà utilizzato il testo predefinito. Esempi di nomi di lingue negli elenchi di testi Lingua Nome della lingua Cinese zh-CHS Inglese it-USA francese fr-FR Tedesco de-DE Italiano esso esso giapponese ja-JP portoghese pt-PT russo ru-RU spagnolo es-ES " }, 
{ "title" : "Derivazione delle dichiarazioni dei moduli ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_a596cccf5e22d542c0a8640e019ddff8", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Derivazione delle dichiarazioni dei moduli ", 
"snippet" : "Analogamente all'ereditarietà orientata agli oggetti di un blocco funzione A da un blocco funzione B (\"EXTENDS\") esiste la possibilità di derivare dichiarazioni di moduli utilizzando l'istruzione IMPORTS parola chiave. I modificatori UPDATE E HIDE vengono trattati in modo speciale. Vengono utilizzat...", 
"body" : "Analogamente all'ereditarietà orientata agli oggetti di un blocco funzione A da un blocco funzione B (\"EXTENDS\") esiste la possibilità di derivare dichiarazioni di moduli utilizzando l'istruzione IMPORTS parola chiave. I modificatori UPDATE E HIDE vengono trattati in modo speciale. Vengono utilizzate le seguenti regole: Il nome del modulo importato deve essere specificato con namespace se questo modulo è definito in una libreria diversa. Non sono consentite importazioni cicliche, in particolare un modulo non deve importare se stesso. (Esempio di importazione ciclica: il modulo M_1 importa il modulo M_2, M_2 importa M_3, …, M_N importa nuovamente M_1.) Un modulo derivato può essere definito senza il file IMPLEMENTED_BY direttiva. In questo caso verrà utilizzato il blocco funzione del modulo base. Se un modulo derivato specifica un blocco funzione (tramite l'uso di MPLEMENTED_BY ), questo blocco funzione deve derivare dal blocco funzione del modulo base oppure deve essere identico ad esso. Un modulo derivato eredita tutte le sezioni del modulo base. Può aggiungere nuove sezioni o modificare sezioni esistenti. Una sezione può essere modificata nel modulo derivato utilizzando lo stesso nome e destinazione estesi con il modificatore UPDATE . In questo caso, le sue voci vengono modificate. Tutte le definizioni mancanti della sezione nel modulo derivato verranno riprese dal modulo base. Il modificatore UPDATE E HIDE può essere utilizzato solo se la rispettiva sezione (nome e destinazione) è definita nel modulo base. Al contrario, una sezione definita nel modulo base può essere utilizzata nel modulo derivato solo se ha l'estensione HIDE O UPDATE modificatore. Se c'è solo il HIDE modificatore nella sezione e non UPDATE , allora non sono ammesse definizioni. Alcune voci devono essere modificate nel modulo derivato (esempio: la descrizione). Esempio: MODULE MBase IMPLEMENTED_BY FBBase\nSEC MetaData\n DESC := TL.Desc_Base ;\nEND_SEC\nSEC Parameters\n SEC Param : paramxIn\n Variable := xIn ;\n Name := TL.Param1_Name ;\n Desc := TL.Param1_Desc ;\n END_SEC\nEND_SEC\n\nMODULE MDerived IMPORTS MBase\n[UPDATE] SEC MetaData\n DESC := TL.Desc_Derived ;\nEND_SEC\n[UPDATE] SEC Parameters\n [UPDATE,HIDE] SEC Param : paramIn\n Variable := xIn ;\n DEFAULT := TRUE ;\n END_SEC\nEND_SEC Nell'esempio sopra il parametro paramIn del modulo MBase è nascosto nel modulo derivato MDerived (utilizzando il HIDE modificatore) e allo stesso tempo un nuovo valore predefinito ( TRUE ) è impostato. " }, 
{ "title" : "Note sull'ordine delle sezioni e definizioni ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_87237560fda311e1967bf6fe1c17b04f", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Note sull'ordine delle sezioni e definizioni ", 
"snippet" : "L'ordine delle sezioni direttamente dopo l'intestazione del modulo è irrilevante. All'interno delle sezioni l'ordine può essere molto importante. Ad esempio, l'ordine delle dichiarazioni degli slot definisce l'ordine dei moduli nell'albero dei moduli. L'ordine delle definizioni è sempre irrilevante....", 
"body" : "L'ordine delle sezioni direttamente dopo l'intestazione del modulo è irrilevante. All'interno delle sezioni l'ordine può essere molto importante. Ad esempio, l'ordine delle dichiarazioni degli slot definisce l'ordine dei moduli nell'albero dei moduli. L'ordine delle definizioni è sempre irrilevante. Regole per i moduli derivati relativi all'ordine: Le sezioni dei moduli base sono sempre definite prima delle sezioni del modulo stesso. Se una sezione del modulo base viene modificata mediante l'uso di UPDATE O HIDE , il suo ordine non viene influenzato. Non è possibile per un modulo derivato modificare l'ordine definito nel modulo base. " }, 
{ "title" : "Completamento automatico e \"componenti elenco\" ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_23e0e10e3a0c71c9c0a8640e0040f55b", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Completamento automatico e \"componenti elenco\" ", 
"snippet" : "Quando si inizia a digitare nell'editor del modulo, tutte le definizioni di sezione disponibili\/possibili vengono visualizzate in un menu \"elenco componenti\". Vengono mostrate solo le sezioni e le definizioni significative per la posizione corrente. Anche se alcune voci di sottosezione hanno lo stes...", 
"body" : "Quando si inizia a digitare nell'editor del modulo, tutte le definizioni di sezione disponibili\/possibili vengono visualizzate in un menu \"elenco componenti\". Vengono mostrate solo le sezioni e le definizioni significative per la posizione corrente. Anche se alcune voci di sottosezione hanno lo stesso nome delle voci di sottosezione di altre sezioni, proverà a visualizzare solo le definizioni di sezione corrispondenti. Se Ritorno viene premuto dopo aver completato la prima riga di una sezione, la sezione verrà completata con tutte le definizioni\/sezioni necessarie e il file END_SEC . Dopo le definizioni delle variabili, le variabili di input\/output vengono presentate dalle definizioni dei \"componenti dell'elenco\". I flag o i valori predefiniti vengono presentati anche in una selezione \"elenco componenti\", che mostra i possibili flag\/valori. Dopo le definizioni, che utilizzano voci di elenchi di testi o voci di pool di immagini (esempio: la maggior parte delle volte Desc := ), viene presentato un menu \"Elenco componenti\" che comprende tutti gli elenchi di testi o i pool di immagini disponibili e visibili e le relative voci. Premendo F2 , è possibile aprire il supporto di input corrispondente. " }, 
{ "title" : "Inizializzazione delle istanze del modulo (modifica online) ", 
"url" : "ac_initialization_of_module_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Inizializzazione delle istanze del modulo (modifica online) ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Inizializzazione e reinizializzazione delle istanze dei moduli e delle istanze proxy (modifica online) ", 
"url" : "ac_initialization_of_module_instances.html#UUID-d33dd918-6f7b-5e75-6686-b9d605273b58_index_2", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Inizializzazione delle istanze del modulo (modifica online) \/ Inizializzazione e reinizializzazione delle istanze dei moduli e delle istanze proxy (modifica online) ", 
"snippet" : "Il metodo IBaseInstance.Init(bOnlineChange : BOOL) ) viene chiamato dopo un download o una modifica online per tutte le istanze del modulo di primo livello e per tutte le istanze proxy. I moduli sono responsabili della chiamata a tutte le istanze del modulo gestito, se necessario. Init viene chiamat...", 
"body" : "Il metodo IBaseInstance.Init(bOnlineChange : BOOL) ) viene chiamato dopo un download o una modifica online per tutte le istanze del modulo di primo livello e per tutte le istanze proxy. I moduli sono responsabili della chiamata a tutte le istanze del modulo gestito, se necessario. Init viene chiamato non appena tutti i valori dei parametri, le istanze del modulo gestite e di riferimento sono impostati e le istanze del modulo sono state montate nell'albero del modulo, ma prima che le attività vengano avviate o continuate. L'implementazione standard nel blocco funzione Module chiama tutti i sottomoduli. I metodi IBaseInstance.OnBeforeOnlineChange E IBaseInstance.OnAfterOnlineChange vengono chiamati prima e dopo che la struttura dell'albero dei moduli è stata ricreata e i valori dei parametri sono stati modificati. Inoltre i metodi vengono chiamati prima e dopo che tutti i sottomoduli e i moduli di riferimento sono stati riassegnati, ma prima che le attività vengano (ri)avviate. In contrasto con FB_Init , questo metodo viene chiamato ad ogni modifica online, indipendentemente dal fatto che FB_Exit è stato chiamato in precedenza sulla vecchia istanza. " }, 
{ "title" : "Sezione: Metadati ", 
"url" : "ac_module_fb_sec_metadata.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Metadati ", 
"snippet" : "Metadati La sezione MetaData contiene la descrizione, la categoria e le icone (con dimensioni 16x16 pixel e 32x32 pixel). SEC MetaData \/\/optional: yes, modifier: [UPDATE]] Desc := <description>; \/\/optional: no, type: text Category := <category name>; \/\/optional: no, type: CategoryPath Icon_16 := <ic...", 
"body" : "Metadati La sezione MetaData contiene la descrizione, la categoria e le icone (con dimensioni 16x16 pixel e 32x32 pixel). SEC MetaData \/\/optional: yes, modifier: [UPDATE]]\n Desc := <description>; \/\/optional: no, type: text\n Category := <category name>; \/\/optional: no, type: CategoryPath\n Icon_16 := <icon16 name>; \/\/optional: no, type: image\n Icon_32 := <icon32 name>; \/\/optional: no, type: image\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: IDOrNothing\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Links := ['<link1>','<link2>',...] \/\/optional: Yes, type: UriCollection\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . Specifica: Se la sezione MetaData manca, questo modulo verrà utilizzato come modulo base di cui non è possibile istanziare. Category definisce un argomento per i moduli appartenenti allo stesso argomento. Il personaggio | crea una struttura gerarchica degli elementi nella finestra di dialogo \"Aggiungi modulo\". I personaggi | E newline O carriage return non sono ammessi nei nomi delle strutture. Icon_16 definisce il nome dell'icona con risoluzione 16 x 16 pixel. Le immagini per le icone devono essere definite in un pool di immagini. L'icona Icon_16 viene utilizzato per l'albero dei moduli e l'icona Icon_32 per la finestra di dialogo delle informazioni. Inst_Prefix definisce il prefisso predefinito per i nomi delle istanze FB generate e delle istanze dei sottomoduli. Prefisso vuoto ( Inst_Prefix := ) sono anche possibili, che però potrebbero causare un'intersezione con altri nomi di variabili del blocco funzione. Questa preimpostazione può essere sovrascritta nella sezione Slot . Se deriva da una classe di moduli con IMPORTS , la sezione MetaData deve essere aggiornato se questa sezione esiste nel modulo base. Per fare ciò la sezione deve essere dichiarata con il modificatore UPDATE e la descrizione deve essere ridefinita. Default_Inst_Name può essere utilizzato per definire un nome predefinito per le istanze del modulo che sono figli di questo slot. Ogni modulo aggiunto riceverà questo nome per impostazione predefinita utilizzando la voce dell'elenco di testi definita da \"Default_Inst_Name\". Se esiste un nome predefinito per uno slot padre, questo nome è preferito a quello presente nei metadati del modulo Links definisce un elenco di collegamenti. I collegamenti vengono visualizzati nell'editor del modulo nel file Informazione scheda. Il contenuto del primo URL dell'elenco di collegamenti viene visualizzato nel file Informazione scheda. Esempio SEC MetaData\n Desc := TL.Desc_Drives ;\n Category := 'Mechatronics'|'Drives' ;\n Icon_16 := IP.Drive_Icon_16 ;\n Icon_32 := IP.Drive_Icon_32 ;\n Default_Inst_Name := IDrive ;\n Links := ['file:\/\/\/d:\\Document1.pdf', 'https:\/\/www.codesys.com', 'mailto:info@codesys.com'];\nEND_SEC Category := 'Mechatronics'|'Drives crea la seguente struttura: " }, 
{ "title" : "Sezione: Livello superiore ", 
"url" : "ac_module_fb_sec_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Livello superiore ", 
"snippet" : "Di primo livello I moduli che si trovano al primo livello dell'albero dei moduli sono chiamati moduli di primo livello. A differenza di altri moduli hanno metodi che possono essere richiamati direttamente da uno o più task. I moduli di primo livello contengono la sezione Toplevel . SEC Toplevel \/\/op...", 
"body" : "Di primo livello I moduli che si trovano al primo livello dell'albero dei moduli sono chiamati moduli di primo livello. A differenza di altri moduli hanno metodi che possono essere richiamati direttamente da uno o più task. I moduli di primo livello contengono la sezione Toplevel . SEC Toplevel \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/(optional: no, type: Text)\n Flags:= <flag>; \/\/(optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . Specifica: GVL_Name definisce il nome del GVL in cui verrà dichiarata l'istanza del modulo e tutte le sue sottoistanze. Il segnaposto %Instancename% (L'ortografia maiuscola o minuscola non è rilevante), verrà sostituito dal nome dell'istanza del modulo. Il parametro Default_Application definisce l'assegnazione dell'applicazione per tutte le istanze di questo modulo a un'applicazione specifica. Se è definito un'applicazione predefinita, l'uso di Default_POUPool non è possibile. Il parametro Default_POUPool definisce l'assegnazione dell'applicazione per tutte le istanze di questo modulo al pool POU. Se è definito un pool POU predefinito, l'uso di Default_Application non è possibile. Il parametro Pragmas contiene un elenco di pragma del compilatore, che verranno inseriti prima della dichiarazione delle istanze FB del modulo. La sezione Standard_Task definisce le attività da cui verranno eseguite le chiamate. Per questo sono disponibili tre attività standard: LOW , MEDIUM , E HIGH . Le definizioni di Standard_Task Sono: Name : nome dell'attività predefinito che verrà definito come assegnazione dell'attività dopo la creazione dell'istanza del modulo. Desc : identificatore per la chiamata dell'attività. Dovrebbe essere breve e significativo (esempio: I\/O task ). Flags : I seguenti valori possono essere combinati con | carattere: CREATE_IF_MISSING : l'attività verrà creata se non esiste. READONLY : l'assegnazione dell'attività è di sola lettura e l'utente non può modificarla. UPDATE_IOS : l'attività viene utilizzata per aggiornare gli I\/O. Ogni I\/O può essere sovrascritto da UpdateInTask parametro nel IO sezione. NONE : Nessun flag è impostato. Esempio SEC Standard_Task : MEDIUM\n Name := MainTask ;\n Desc := TL.TaskMedium_Desc ;\n Flags := READONLY | CREATE_IF_MISSING ;\nEND_SEC Utilizzando la sezione Custom_Task un modulo può definire una o più attività personalizzate. Il target della sezione deve essere il nome di un metodo del blocco funzione del modulo. Il metodo non deve avere argomenti (né INPUT , OUTPUT , né INOUT ). Priority : Definisce la priorità dell'attività. Interval : Definisce l'intervallo dell'attività (costante del tipo di dati \"TIME\" o \"LTIME\"). Flags : I seguenti valori possono essere combinati con | carattere: SHARED : Per ragioni di compatibilità, questo flag esiste ancora, ma si presuppone sempre implicitamente che sia impostato. Fondamentalmente significherebbe che se un'attività con le proprietà specificate nel file Custom_Task esiste già, verrà utilizzata questa attività. Ma poiché verrà creata una nuova attività se non esiste alcuna attività esistente con proprietà corrispondenti, questo flag viene reso obsoleto. Il nome dell'attività creata è TASK_<ModuleInstanceName>_<MethodName> . UPDATE_IOS : L'attività verrà utilizzata per aggiornare gli I\/O collegati alle espressioni ST o direttamente agli I\/O del modulo. NONE : Nessun flag è impostato. Non esiste alcuna implementazione predefinita nella classe del modulo per il metodo specificato. Esempio SEC Custom_Task : Method1\n Priority := 7 ;\n CycleTime := t#14ms ;\n Flags := NONE ;\nEND_SEC Esattamente un compito standard o specifico deve avere il file UPDATE_IOS set di bandiere. Alcune regole di base, come vengono generate le attività, devono essere menzionate qui: Se esistono attività standard, che non hanno il file CREATE_IF_MISSING flag impostato, dovrebbe esistere un'attività con il nome e le proprietà specificati delle impostazioni del generatore. Se le proprietà non corrispondono a quella specificata viene visualizzato un messaggio di avviso. Se esistono attività standard, che ha il file CREATE_IF_MISSING flag impostato, viene prima generata un'attività con le proprietà specificate. Ora, ogni volta che le impostazioni del generatore per questa attività vengono modificate, l'attività viene adattata, senza alcun messaggio di avviso. Non sono consentite attività standard di tipo diverso che fanno riferimento allo stesso nome di attività. In questo caso non viene emesso alcun errore. A seconda dello standard configurato, per ogni istanza di livello superiore vengono richiamati i seguenti metodi all'inizio e alla fine dell'attività definita: METHOD CallPrioHighStart: BOOL\nMETHOD CallPrioHighEnd: BOOL\nMETHOD CallPrioMediumStart: BOOL\nMETHOD CallPrioMediumEnd: BOOL\nMETHOD CallPrioLowStart: BOOL\nMETHOD CallPrioLowEnd: BOOL Ogni modulo è responsabile di chiamare le sue istanze di sottomodulo. I riferimenti ai sottomoduli non devono essere richiamati. L'implementazione predefinita nell'FB Module chiama i rispettivi metodi di tutte le istanze del sottomodulo nell'ordine della loro posizione nell'albero del modulo. Il puntatore SUPER offre l'accesso all'istanza del blocco funzione di base. Quindi ad esempio la chiamata SUPER^.CallPrioHighStart() può essere usato per chiamare il metodo Module.CallPrioHighStart() se il blocco funzione si estende Module . In questo modo, l'implementazione in Module si assicurerà che tutti i sottomoduli vengano richiamati. " }, 
{ "title" : "Sezione: IO ", 
"url" : "ac_module_fb_sec_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: IO ", 
"snippet" : "IO La definizione di input e output può essere eseguita in questa sezione. Tutti gli input e output definiti sono disponibili nel file Mappa I\/O . SEC IO \/\/optional: yes, modifier: [UPDATE] SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional...", 
"body" : "IO La definizione di input e output può essere eseguita in questa sezione. Tutti gli input e output definiti sono disponibili nel file Mappa I\/O . SEC IO \/\/optional: yes, modifier: [UPDATE]\n SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\n SEC Output : <output identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\nEND_SEC Per dettagli sulla sintassi dei tipi di definizione vedere: descrizione in Sintassi della dichiarazione del modulo . Specifica: Il parametro Variable definisce il percorso dell'istanza di una variabile di input o di output. Tutti i componenti del percorso per gli input devono essere variabili di input (o variabili locali nelle strutture). Anche tutti i componenti del percorso per gli output devono essere variabili di output (o variabili locali nelle strutture). La variabile deve essere di tipo dati primitivo o di tipo enum. Una variabile può essere parametro e input\/output allo stesso tempo. Una variabile non deve essere utilizzata da due I\/O diversi. L'obiettivo di un input O output La sezione deve identificare in modo univoco l'input o l'output. Non esiste distinzione tra maiuscole e minuscole. Il parametro UpdateInTask determina l'attività per l'aggiornamento degli I\/O. Se manca questo parametro, l'attività con il flag UPDATE_IOS sarà usato. Per i moduli di primo livello verrà creato un errore se l'attività specificata in UpdateInTask non è definito per il modulo. Esempio SEC Io\n SEC Input : uiTemperature\n Variable := uiTemperature ;\n Name := TL_WeatherStation.NAME_iTemperature ;\n Desc := TL_WeatherStation.DESC_iTemperature ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\n SEC Output : uiLigh\n Variable := uiLightnessSouth ;\n Name := TL_WeatherStation.NAME_uiLightnessSouth ;\n Desc := TL_WeatherStation.DESC_uiLightnessSouth ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\nEND_S " }, 
{ "title" : "Sezione: Parametri ", 
"url" : "ac_module_fb_sec_parameters.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Parametri ", 
"snippet" : "Parametri In questa sezione si possono definire tutti i parametri che devono essere disponibili per la parametrizzazione nel Parametri dell'istanza del modulo. SEC Parameters \/\/optional: yes, modifier: [UPDATE] SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <v...", 
"body" : "Parametri In questa sezione si possono definire tutti i parametri che devono essere disponibili per la parametrizzazione nel Parametri dell'istanza del modulo. SEC Parameters \/\/optional: yes, modifier: [UPDATE]\n SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: yes, type: InstancePath\n VariableType := <data type> \/\/optional: yes, type: @JG???IEC-Typ\n Name := <parameter name>; \/\/optional: no, type: text\n Desc := <parameter description>; \/\/optional: no, type: text\n Group := <parameter group name> \/\/optional: yes, type: text\n MustBeSet := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n Default := <default value>; \/\/optional: yes, type: LiteralOrConstant\n Max := <max value>; \/\/Optional: yes, type: LiteralOrConstant\n Min := <min value>; \/\/Optional: yes, type: LiteralOrConstant\n END_SEC\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . Specifica: L'obiettivo della sezione Param deve identificare il parametro in modo univoco. La definizione Variable è un percorso dell'istanza di ingresso relativo al blocco funzione del modulo. Questa variabile memorizzerà il valore del parametro, il suo tipo definisce il tipo di parametro. Se Variable viene dichiarato il parametro VariableType non deve essere definito e verrà ignorato. Il parametro VariableType definisce il tipo IEC della variabile. Se VariableType è dichiarato ma nel file non viene fornita alcuna variabile FB reale esistente Variable definizione, il Default deve esistere una definizione Questo valore deve corrispondere a VariableType . I parametri Name E Desc sono stringhe e devono essere definite in un elenco di testi. I parametri del modulo possono essere tipi ed enumerazioni di base ma non istanze di strutture e matrici. Le variabili parametro devono avere Valori di inizializzazione , che sono definiti nella dichiarazione del blocco funzione. Il parametro facoltativo Default permette di sovrascrivere il valore di inizializzazione. Per l'espressione di inizializzazione e per il valore predefinito sono consentiti valori letterali e costanti del tipo corretto. Ciò include i parametri della libreria. Il parametro facoltativo Group permette di dividere i parametri in gruppi. Ciascun gruppo viene quindi visualizzato come una scheda separata nell'editor del modulo sotto Parametri . Con il parametro facoltativo MustBeSet l'utente può essere costretto a impostare un parametro nell'editor del modulo. Se il parametro non è impostato, viene visualizzato un messaggio di errore. Le definizioni minimo E Massimo consentono di impostare limiti per il valore del parametro. Il controllo di questi limiti è possibile solo per variabili di tipo numerico o temporale. Tutti gli altri tipi di variabile non sono consentiti e genereranno un errore. Esempio SEC Parameters\n SEC Param : InParam1\n Variable := xIn1;\n VariableTyp := BOOL;\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC La variabile xIn1 deve essere definito nella parte dichiarazione del blocco funzione: xIn1 : BOOL := FALSE ; " }, 
{ "title" : "Valori di inizializzazione ", 
"url" : "ac_module_fb_sec_parameters.html#UUID-1cddf7ea-faa7-0b82-e29a-04e9f27653b0_ac_module_fb_sec_parameters0", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Parametri \/ Valori di inizializzazione ", 
"snippet" : "Il valore di inizializzazione è il valore di una variabile definita nell'inizializzazione. Nelle variabili semplici dell'FB questo valore si trova sempre a destra della dichiarazione della variabile: iVar : INT := 17 ; \/\/ Initialisierungswert: 17 In caso di definizione di variabili in strutture è es...", 
"body" : "Il valore di inizializzazione è il valore di una variabile definita nell'inizializzazione. Nelle variabili semplici dell'FB questo valore si trova sempre a destra della dichiarazione della variabile: iVar : INT := 17 ; \/\/ Initialisierungswert: 17 In caso di definizione di variabili in strutture è essenziale l'inizializzazione della struttura: TYPE s : STRUCT\n i1 : INT := 7 ;\n r1 : REAL := 5 ;\nEND_STRUCT END_TYPE Dichiarazione nel modulo FB: structVar : s := (i1 := 2, r1 := 0.0) ; In questo caso il valore di inizializzazione che definisce il valore di structVar.i1 È 2 (e non 7 ). Nelle strutture nidificate devono essere considerate tutte le inizializzazioni nel percorso dal modulo FB alla variabile. L'inizializzazione più esterna della variabile determina il valore. " }, 
{ "title" : "Sezione: Slot ", 
"url" : "ac_module_fb_sec_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Slot ", 
"snippet" : "Slot Questa sezione definisce la disponibilità e il tipo di slot dei moduli nell'albero dei moduli. È possibile definire due diversi tipi di slot. Fessura SEC Slots \/\/optional: yes, modifier: [UPDATE]] SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; ...", 
"body" : "Slot Questa sezione definisce la disponibilità e il tipo di slot dei moduli nell'albero dei moduli. È possibile definire due diversi tipi di slot. Fessura SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Role := <role name>; \/\/optional: no, type: text\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identigier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier> \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . Specifica: La sezione Slot definisce uno slot che consente 0 connessioni o 1 connessione. L'obiettivo della sezione Slot deve identificare il parametro in modo univoco. Di conseguenza, non devono esserci due slot diversi (o Slot O Slot_Multi ) che hanno lo stesso obiettivo. (Le lettere maiuscole\/minuscole non hanno alcuna importanza.) La definizione Variable è un percorso dell'istanza di ingresso relativo al blocco funzione del modulo. Il percorso dell'istanza può riferirsi in tutte le sue componenti solo a variabili di input (per le istanze di struttura anche a variabili locali). Il tipo della variabile indirizzata deve essere un'interfaccia o un tipo FB. Due slot diversi non devono utilizzare la stessa variabile. Role definisce la descrizione del ruolo dello slot. Type definisce il tipo di slot. Il tipo di connessione può assumere i seguenti valori: SUBMODULE : Slot per istanze di sottomodulo. REFERENCE : Slot per le istanze del sottomodulo di riferimento. DECOUPLED : Slot per istanze di moduli \"disaccoppiati\". Guarda anche: Sezione: Disaccoppiato Inst_Prefix è un prefisso utilizzato per il nome della variabile FB generata. Prefisso vuoto ( Inst_Prefix := ; ) è anche possibile, ma potrebbe creare conflitti con altri nomi di variabili del blocco funzione. Può essere specificato solo per SUBMODULE slot di tipo. Optional definisce se è consentito lasciare lo slot aperto o se deve essere collegato. Default_Inst_Name può essere utilizzato per definire un nome predefinito per le istanze del modulo che sono figli di questo slot. Ogni modulo aggiunto riceverà questo nome per impostazione predefinita utilizzando la voce dell'elenco di testi definita da \"Default_Inst_Name\". Il nome predefinito dello slot è preferito a quello dei metadati dei moduli. Pragmas contiene un elenco di pragma del compilatore che vengono inseriti prima delle istanze FB dei sottomoduli. I pragma possono essere utilizzati solo per gli slot gestiti. RegularExpressionParameterId definisce un parametro di tipo STRING\/WSTRING per questo slot. Il valore di questo parametro viene interpretato come espressione regolare e deve corrispondere al nome del sottomodulo inserito. Le sezioni Slot.Default_Allocation E Slot_Multi.Default_Allocation permettono di definire impostazioni predefinite per slot con numero variabile di elementi (Multi_Slot e Slot). Per Slots.Multi_Slot devono essere identificati da obiettivi univoci mentre Slots.Slot non ha target e può averne solo uno Default_Allocation sezione. L'istanza verrà aggiunta in base alla sua posizione all'interno della sezione. Il nome del modulo e il nome dell'istanza seguono la definizione di Slot.DefaultModule E Slot.DefaultName . Se queste definizioni non sono disponibili, le impostazioni di Default_Allocation.Module_Name E Default_Allocation.Instance_Name sarà usato. Si consiglia di utilizzare Default_Allocation.* per gli slot invece di DefaultModule E DefaultName che esiste solo per ragioni di compatibilità. Le impostazioni dell'istanza del modulo predefinita possono essere definite nelle sottosezioni di Default_Allocation : Module_Name definisce il nome del modulo di cui verrà creata automaticamente un'istanza. Se il modulo proviene da una libreria, il nome del modulo deve essere qualificato con namespace. Il parametro è consentito solo per gli slot di tipo SUBMODULE . Le chiamate infinite non sono consentite e creeranno un messaggio di errore (esempio: la dichiarazione del modulo \"A\" contiene il modulo predefinito \"B\"; la dichiarazione del modulo \"B\" contiene il modulo predefinito \"A\"). Instance_Name deve essere specificato ogni volta DefaultModule è specificato, e mai diversamente. Deve essere un identificatore IEC valido utilizzato come nome dell'istanza del modulo predefinita. Il nome non deve iniziare o finire con una sottolineatura ( _ ). I nomi predefiniti di tutti gli slot di una dichiarazione devono essere univoci. (La distinzione tra maiuscole e minuscole non fa differenza.) NotDeletable specifica se il modulo può essere eliminato o meno dall'utente. Se TRUE , il modulo non potrà essere eliminato. Viene visualizzato un messaggio di errore. Se il parametro è FALSE oppure viene omesso, è possibile eliminare il modulo. VisuEmbeddings : Se la Empty il parametro è impostato su TRUE , viene creato un elenco vuoto di visus incorporati per questa istanza del modulo. Se il valore è FALSE , è possibile generare l'elenco desiderato di visualizzazioni incorporate per l'istanza del modulo tramite l'elenco delle visualizzazioni incorporate desiderate nel file Embedding sottosezione. Ogni Embedding sezione deve definire il nome VisuName della vista incorporata desiderata per questo scopo e può specificare proprietà aggiuntive come Target O LinkId di questa vista incorporata. PageVisu : In questa sezione si può scegliere il PageVisu dell'istanza del modulo ( VisuName ). Inoltre si può definire se tale visu crea a TopLevelTap . Il parametro TopLevelTap bisogna dare i valori TRUE E FALSE . IOMappings : Nella sottosezione Mapping è possibile definire i canali I\/O. Gli obiettivi delle sezioni Mapping descrivere il canale I\/O di destinazione. Il valore predefinito può essere impostato su NoMapping o ad un STExpression . Parameters : Nella sottosezione Param il valore Value di ciascun parametro definito nella destinazione della sezione può essere definito. Slot_Multi Utilizzando la sezione Slot_Multi è possibile creare un elenco di sottoistanze e riferimenti. SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot_Multi : <slot name> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Role := <name role>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Pragmas := <pragma list>; \/\/optional: yes, type: Pragmalist\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier>; \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC Specifiche aggiuntive: Var_Count definisce il percorso dell'istanza di ingresso del blocco funzione del modulo. Questa variabile (di tipo Integer) salverà le informazioni sul numero di istanze connesse allo slot. Cardinality definisce il numero minimo e massimo di istanze. IL Slot_Multi.Default_Allocation può essere utilizzata per definire allocazioni predefinite per slot con numero variabile di elementi. Devono essere identificati tramite target univoci. Le istanze vengono inserite nell'ordine delle sezioni. Per il nome del modulo e il nome dell'istanza, le specifiche per Slot.DefaultModule O Slot.DefaultName fare domanda a. Il numero di assegnazioni predefinite non deve superare la cifra superiore. La variabile affrontata da a Slot_Multi la sezione deve essere di tipo POINTER TO <INTERFACE> . Ogni variabile di ingresso di tipo intero può essere indirizzata da Var_Count solo una volta. (Ciò include anche InstRef_Multi.Var_Count E VarArray.Var_Count ). Esempio SEC Slot\n SEC Slot_Multi : subs\n Variable := pSubs;\n Var_Count := uiArraySize;\n Role := TL.Role;\n Cardinality := [2 .. 17];\n Type := SUBMODULE;\n RegularExpressionParameterId := Param_RegEx_Ref;\n SEC Default_Allocation : def1\n Module_Name := Sub1;\n Instance_Name := Submodule;\n END_SEC\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC Tra le altre dichiarazioni, la parte dichiarazione del blocco funzione deve contenere: uiArraySize: UINT; pSubs: POINTER TO ITestModule . Nell'esempio viene definito uno slot che contiene almeno 2 ma al massimo 17 sottoistanze. Verrà creato un array per le sottoistanze e pSubs lo indica. Quando si aggiunge l'istanza, il sottomodulo con nome Submodule di tipo Sub1 verrà aggiunto automaticamente allo slot. " }, 
{ "title" : "Sezione: SourceTemplate ", 
"url" : "ac_module_fb_sec_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: SourceTemplate ", 
"snippet" : "SourceTemplate Le sottosezioni della sez SourceTemplate definisce i blocchi funzione da copiare nel progetto. Nell'editor del modulo vengono elencati i blocchi funzione qui definiti. Lì puoi attivare o disattivare la copia. Guarda anche SourceTemplate SEC std.SourceTemplate SEC SourceFB : <Identifie...", 
"body" : "SourceTemplate Le sottosezioni della sez SourceTemplate definisce i blocchi funzione da copiare nel progetto. Nell'editor del modulo vengono elencati i blocchi funzione qui definiti. Lì puoi attivare o disattivare la copia. Guarda anche SourceTemplate SEC std.SourceTemplate\n SEC SourceFB : <Identifier> \/\/ optional: no\n SourceType := <FunctionBlock>; \/\/ optional: no, type: InstancePath\n Variable := <variable name>; \/\/ optional: no, type: InstancePath\n Default := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n IsMandatory := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n FBVariable := <variable name>; \/\/ optional: yes, type: InstancePath\n DestinationType := <default name>; \/\/ optional: yes, Type: String\/Literal\n END_SEC\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . Specifica: IL Identifier viene utilizzato nell'editor del modulo. Definisce il nome del blocco funzione copiato se DestinationType non è definito. SourceType definisce il blocco funzione da copiare. Variable definisce una variabile di ingresso del blocco funzione del modulo. Deve essere un puntatore ad una classe base della funzione copiata o ad un'interfaccia implementata dal blocco funzione da copiare. Default definisce se il blocco funzione viene copiato per impostazione predefinita per questo modulo. Se manca la definizione, TRUE è impostato. Questa opzione può essere modificata nell'editor del modulo. Se IsMandatory è impostato per TRUE , l'utente non può modificare il file IsToCopy opzione nell'editor del modulo. FBVariable definisce una variabile di ingresso del blocco funzione da copiare. La variabile di input viene quindi istanziata con l'istanza del modulo. Il tipo dell'ingresso è un puntatore a un tipo base del modulo FB o un puntatore all'interfaccia del modulo FB. DestinationType definisce un nome standard per il blocco funzione copiato. Se manca la definizione, viene utilizzata la seguente convenzione di denominazione: <Nome di the istanza del modulo>_<Identificatore>[_<numero progressivo>]. I SourceTemplate specificati vengono copiati nel file AC_SourceTemplate cartella. Vengono istanziati e inizializzati dal modulo FB assegnato. I SourceTemplates, una volta creati, possono essere modificati e non verranno sovrascritti dalle nuove esecuzioni del generatore. I SourceTemplates, che non sono più necessari, vengono rinominati (con l'estensione <_unused > suffisso) e spostato in <UnusedSourceTemplates> cartella. Esempio SEC std.SourceTemplate\n SEC SourceFB : ID_ConnectSwitches\n SourceType := ConnectSwitches;\n Variable := itfConnect;\n FBVariable := pBuilding;\n Default := TRUE;\n IsMandatory := FALSE;\n DestinationType := 'TypeInModuleDescription';\n END_SEC\nEND_SEC " }, 
{ "title" : "Sezione: Visi ", 
"url" : "ac_module_fb_sec_visu.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Visi ", 
"snippet" : "Visi SEC Visu \/\/optional: yes, modifier: [UPDATE] Toplevel_Tab; \/\/optional: yes, type: bool Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: Vis...", 
"body" : "Visi SEC Visu \/\/optional: yes, modifier: [UPDATE]\n Toplevel_Tab; \/\/optional: yes, type: bool\n Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: VisuList\n\n SEC DefaultEmbeddings \/\/optional: yes\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier: [HIDE, UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: literal\n Target := <target name>; \/\/optional: yes, type: literal\n ProxyVisuName := <visu name>; \/\/optional: yes, type: literal\n LinkId := <linkID>; \/\/optional: yes, type: literal\n END_SEC\n END_SEC\n\n SEC Toplevel_Tab_Hotkey \/\/optional: yes\n Hotkey := <keycode>; \/\/optional: no, type: literal\n Modifiers := <modifier>; \/\/optional: yes, modifier: [SHIFT, CONTROL, ALT]\n END_SEC\n\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . Specifica: Toplevel_Tab definisce se la casella di controllo Crea scheda di primo livello nell'editor HMI è attivato o disattivato per impostazione predefinita. Page definisce un elenco di oggetti di visualizzazione disponibili per il modulo. Embedded definisce un elenco di oggetti di visualizzazione disponibili del sottomodulo che verranno incorporati in altre schermate di visualizzazione. Utilizzando il segnaposto %PAGE_VISU% invece del nome della visualizzazione, è possibile incorporare facoltativamente le schermate di visualizzazione generate in altre schermate. Embedded_Proxy definisce un elenco di oggetti di visualizzazione disponibili del modulo. L'elenco viene utilizzato solo se a decoupled module è inserito in a decoupled slot e se non viene creato sotto il controller dell'istanza del modulo padre (come proxy). Per i moduli che importano un altro modulo, il segnaposto %NONE% può essere utilizzato al posto del nome della visualizzazione. Ciò comporta che le visualizzazioni importate vengano nascoste. Questo approccio è possibile per l'elenco delle schermate di visualizzazione nonché per le schermate di visualizzazione (proxy) integrate. Sezione: DefaultEmbeddings : Questa sezione serve per specificare gli incorporamenti predefiniti, che poi appariranno come preconfigurazione sul file HMI scheda di un sottomodulo (simile alla sezione \"Default_Allocation\", vedi Sezione: Slot ). Gli incorporamenti predefiniti desiderati devono essere descritti nelle sottosezioni Embedding . Requisito: l'oggetto di visualizzazione specificato e il proxy devono essere disponibili nell'elenco dei possibili incorporamenti per il modulo (vedere sopra: Embedded E Embedded_Proxy ). Sezione: Toplevel_Tab_Hotkey : questa sezione definisce un tasto di scelta rapida come impostazione predefinita per la pagina di livello superiore. Le scorciatoie da tastiera non devono essere utilizzate più di una volta. Questa impostazione può essere modificata nell'editor del modulo su HMI scheda. Esempio SEC Visu\n Toplevel_Tab ;\n Page := [VISU_CNC_Machine_1, VISU_CNC_Machine_2];\n Embedded := [%PAGE_VISU%];\n SEC DefaultEmbeddings\n SEC Embedding : No1\n VisuName := SubModule_Emb;\n Target := '..\/..\/TopLevel_2';\n END_SEC\n SEC Embedding : No2\n VisuName := SubModule_Emb_2;\n \/\/ProxyVisuName := SubModule_Emb_1;\n Target := '';\/\/ leave empty for next ancestor\n END_SEC\n END_SEC\n SEC Toplevel_Tab_Hotkey\n Hotkey := T;\n Modifiers := SHIFT | CONTROL;\n END_SEC\nEND_SEC Il nome della visualizzazione è il nome del rispettivo oggetto di visualizzazione (senza distinzione tra maiuscole e minuscole). L'oggetto di visualizzazione deve trovarsi nello stesso livello gerarchico del blocco funzione del modulo. Regole per l'interfaccia degli oggetti di visualizzazione: Tutti gli oggetti di visualizzazione e gli oggetti di visualizzazione incorporati possono avere una variabile VAR_IN_OUT con il nome inst , che può essere del tipo del blocco funzione del modulo oppure di una classe base. Il nome della variabile non fa distinzione tra maiuscole e minuscole. VAR_IN_OUT   inst : <MODULE_FB> ; END_VAR In alternativa all'opzione qui descritta con VAR_IN_OUT è possibile utilizzare anche una variabile VAR_INPUT. Questa variabile deve soddisfare i seguenti requisiti: Nome: inst Tipo: interfaccia implementata dal blocco funzione del modulo Gli oggetti di visualizzazione incorporati possono avere due variabili aggiuntive (i nomi delle variabili non fanno distinzione tra maiuscole e minuscole): VAR_INPUT paVisuFB : POINTER TO POINTER TO AC_Visu_Base ; iOwnFrameIndex : INT ; END_VAR Queste variabili devono essere definite insieme; non è consentito definire l'uno senza l'altro. Queste due variabili offrono alle visualizzazioni integrate la possibilità di cambiare il frame centrale nella visualizzazione di livello superiore. paVisuFB è un array di puntatori su AC_Visu_Base instances . Utilizza la variabile di visualizzazione globale CURRENTCLIENTID per accedere all'istanza corretta del client corrente. Il cambio di frame viene eseguito da un'azione ST della forma: paVisuFB[CURRENTCLIENTID]^.uiFrameIdx := iOwnFrameIndex ; iOwnFrameIndex è l'indice che ha l'immagine di visualizzazione del proprio modulo in questo frame di primo livello. (Se il proprio modulo non definisce un'immagine di visualizzazione, questo indice è -1.) Oltre alle variabili sopra menzionate non sono ammesse altre variabili VAR_INPUT, VAR_OUTPUT o VAR_INOUT. IL AC_Visu_Base le istanze forniscono la funzione aggiuntiva GetModuleFrameIndex . Questa funzione restituisce l'indice della schermata di visualizzazione (se presente) nella visualizzazione di primo livello per un'istanza di modulo (vedi IModule In AC_Module_Base.library) . Con questa funzione è possibile passare a qualsiasi schermata di visualizzazione nell'albero delle istanze del modulo. Per abilitare anche la navigazione all'interno del codice di un modulo, l'ambiente del modulo (vedi IModule In AC_Module_Base.library ) possiede un membro, Environment.visus , che corrisponde a quanto sopra menzionato paVisuFB puntatore. Essere in grado di utilizzare la variabile CURRENTCLIENTID , la Biblioteca VisuGlobalClientManager (categoria \"Stagista|Visu\") deve essere aggiunto al progetto. La prima visualizzazione verrà utilizzata come impostazione predefinita. " }, 
{ "title" : "Sezione: Tendenza ", 
"url" : "ac_module_fb_sec_trend.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Tendenza ", 
"snippet" : "Tendenza SEC tre.Trend \/\/optional: yes, modifier: [UPDATE] SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE] Task := <trend task> \/\/optional: yes, type: TimeLiteral CycleTime := <time value> \/\/optional: yes, type: TimeLiteral LimitType := <limit type> \/\/optional: yes, t...", 
"body" : "Tendenza SEC tre.Trend \/\/optional: yes, modifier: [UPDATE]\n SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE]\n Task := <trend task> \/\/optional: yes, type: TimeLiteral\n CycleTime := <time value> \/\/optional: yes, type: TimeLiteral\n LimitType := <limit type> \/\/optional: yes, type: FileLimitType\n LimitMaximum := <max bytes> \/\/optional: yes, type: Literal\n RecordCondition \/\/optional: yes, type: InstanceAccess\n SEC Visu \/\/optional: yes, modifier: [UPDATE]\n VisuPlaceholder \/\/optional: yes, type: StringLiteral\n VisuTemplate := <visu template> \/\/optional: yes, type: StringLiteral\n Target := <path module instance \/\/optional: yes, type: StringLiteral\n END_SEC\n END_SEC\n\n SEC TrendVariable : <variable identifier> \/\/optional: yes, modifier: [UPDATE]\n Variable := <variable name> \/\/optional: yes, type: InstanceAccess\n TrendRecording := <recording name> \/\/optional: no, type: : Id)\n Description := <tooltip> \/\/optional: yes, type: TextRef\n Color := <graph color> \/\/optional: yes, type: Literal\n GraphType := <graph type> \/\/optional: yes, type: GraphType\n LineWidth := <width> \/\/optional: yes, type: Literal\n LineStyle := <line style> \/\/optional: yes, type: LineStyle\n SEC Warning : MIN\/MAX \/\/optional: yes, modifier: [UPDATE]\n Limit := <limit value> \/\/optional: no, type: Literal\n Color := <limit color> \/\/optional: yes, type: Literal\n END_SEC\n END_SEC\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . Specifica: Task : Definisce l'attività per la registrazione del trend. Se non è definita alcuna attività, verrà utilizzata l'attività creata automaticamente da visu trend. CycleTime : Tempo di ciclo della registrazione del trend LimitType : Tipo di limitazione del trend registrato. LimitMaximum : dimensione massima della registrazione del trend in KB (solo con LimitType ==Limite file). RecordCondition : Condizioni di registrazione. La variabile di riferimento deve essere di tipo BOOL. VisuPlaceholder : Segnaposto, sostituito dalla visualizzazione del trend generata. VisuTemplate : Modello per la vista da creare. Il modello deve avere un segnaposto Trend_Placeholder . Può contenere controlli con il seguente identificatore: TrendLegend -> tipo: Legenda TrendTimeRangeSelector -> tipo: Selettore intervallo di tempo TrendDateRangeSelector -> Tipo: selettore intervallo di date Target : percorso relativo all'istanza del modulo in cui verrà incorporata la visualizzazione. Variable : Variabile da registrare. TrendRecording : oggetto TrendRecording a cui appartiene la variabile. Description : Voce dell'elenco di testo, che verrà visualizzata per la variabile come tooltip. Color : Colori del grafico della variabile come codice colore ARGB GraphType : Tipo di grafico LineWithPoints : Linee con punti Cross : Croci StepWithPoints : Passaggi con punti Point : Punti Lines : Linee Step : Passi LinesWithCrosses : Linee con croci \\\\ StepWithCrosses : Gradini con croci LineWidth : Larghezza della linea tracciata. Intervallo di valori: da 1 a 255. LineStyle : Stile linea Solid : Solido Dashed : Tratteggiato Dotted : Punteggiato DashDotted : Trattino punteggiato DashDotDotted : punto tratteggiato Warning : Questa sottosezione deve avere la destinazione MAX O MIN . A seconda dell'obiettivo, il superamento o il superamento del limite attiveranno l'avviso. Limit : Inizio dell'intervallo critico. Color : Colore per l'intervallo critico come codice colore ARGB Esempio SEC tre.Trend\n SEC TrendRecording : TrendSensor\n SEC Visu\n VisuPlaceholder := 'TrendPlaceholder_TrendSensor';\n VisuTemplate := 'AC_Trend.GenTrend_VisuTemplate';\n END_SEC\n CycleTime := t#5s;\n LimitType := Records;\n LimitMaximum := 452;\n END_SEC\n SEC TrendVariable : Value\n Variable := value;\n TrendRecording := TrendSensor;\n Color := 16#FF00FF00;\n SEC Warning : MIN\n Limit := -5;\n Color := 16#FF101020;\n END_SEC\n GraphType := LinesWithCrosses;\n LineWidth := 3;\n END_SEC\nEND_SEC " }, 
{ "title" : "Sezione: Procure ", 
"url" : "ac_module_fb_sec_proxies.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Procure ", 
"snippet" : "Procure La sezione Proxies definisce un blocco funzione che implementa il proxy. Un proxy serve per lo scambio di dati di moduli di diversa applicazione. L'istanza dell'FB proxy rappresenta l'istanza del modulo in un'applicazione remota. SEC Proxies \/\/optional: yes, modifier: [UPDATE] SEC Proxy : <i...", 
"body" : "Procure La sezione Proxies definisce un blocco funzione che implementa il proxy. Un proxy serve per lo scambio di dati di moduli di diversa applicazione. L'istanza dell'FB proxy rappresenta l'istanza del modulo in un'applicazione remota. SEC Proxies \/\/optional: yes, modifier: [UPDATE]\n SEC Proxy : <identifier> \/\/optional: yes, modifier [UPDATE]\n FB := <FB name>; \/\/optional: no, type: QID\n SEC MirrorVar : <identifier> \/\/optional: yes, modifier [UPDATE])\n Variable := <variable name>; \/\/optional: no, type: VarPath\n END_SEC\n SEC ProxyParameter : <target> \/\/ optional: yes, modifier [UPDATE]\n Variable := <InstancePath>; \/\/ optional: no, type: VarPath\n END_SEC\n END_SEC\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . Specifica: Il blocco funzione deve derivare da IBaseInstance . Il blocco funzione deve avere un metodo SetProxyIdentification con la seguente firma, che non è inclusa nell'interfaccia IBaseInstance : SetProxyIdentification(pbyName : POINTER TO BYTE, udiComAddr : UDINT, udiLocalComAddr : UDINT, pEnvironment : MEnv) Il nome dell'istanza passato e l'indirizzo impostato devono essere restituiti dalle proprietà InstanceName , ComAddress , E LocalComAddress . Il blocco funzione non deve derivare da IModule . La sezione MirrorVar consente di eseguire il mirroring di una variabile delle istanze di un modulo nelle sue istanze proxy. Per questo il percorso dell'istanza della variabile deve essere dichiarato nella definizione Variable , che deve essere indicato sotto forma di percorso relativo (all'FB di istanza del modulo). Per la variabile specificata dell'FB di istanza del modulo valgono le seguenti regole: La variabile deve far parte delle Var, degli ingressi o delle uscite dell'FB di istanza del modulo. Deve essere definito nell'FB del modulo e nell'FB proxy Deve essere dello stesso tipo in entrambi gli FB Deve avere un tipo primitivo; quindi per il mirroring non sono consentiti puntatori, interfacce o strutture nel loro insieme, ma solo tipi semplici (numerici, STRING, TIME, ecc.) Se le variabili specificate soddisfano queste condizioni, vengono trasferite automaticamente come parte dell'RMP senza che l'utente debba preoccuparsi ulteriormente del trasferimento. La sezione ProxyParameter permette di definire i parametri per il proxy. Dovrebbero essere presi in considerazione i seguenti punti: L'obiettivo del ProxyParameter deve corrispondere a un parametro target del modulo IL variable del modulo proxy deve corrispondere al tipo della variabile utilizzata per il parametro del modulo. Sono consentiti solo tipi ed enumerazioni primitivi I parametri proxy vengono impostati una volta sul valore configurato nell'istanza del modulo durante la fase di inizializzazione della rispettiva applicazione. Mentre l'applicazione è in esecuzione, queste variabili non vengono rispecchiate nei proxy Il nome del blocco funzione può essere qualificato con un percorso dello spazio dei nomi. Esempio SEC Proxies\n SEC Proxy ProxyFB1\n FB := ProxyModule1;\n SEC MirrorVar : diInput\n Variable := diInput;\n END_SEC\n SEC ProxyParameter : InParam1\n Variable := TL.Input1_Name;\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Sezione: VarArray ", 
"url" : "ac_module_fb_sec_vararray.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: VarArray ", 
"snippet" : "VarArray Il parametro VarArrays permette di creare array con dimensioni configurabili. SEC VarArrays \/\/optional: yes, modifier: [UPDATE]] SEC VarArray : <slot identifier> \/\/optional: yes, modifier [] Variable := <variable name>; \/\/optional: no, type: InstancePath Var_Count := <variable count>; \/\/opt...", 
"body" : "VarArray Il parametro VarArrays permette di creare array con dimensioni configurabili. SEC VarArrays \/\/optional: yes, modifier: [UPDATE]]\n SEC VarArray : <slot identifier> \/\/optional: yes, modifier []\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable count>; \/\/optional: no, type: InstancePath\n Inst_Name := <instance name>; \/\/optional: yes, type: StringLiteral\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Var_Decl_Flags := <Flag1> | <Flag2> | ... ; \/\/optional: yes, type: Flags\n END_SEC\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . Specifica: La definizione Variable è un percorso dell'istanza di ingresso relativo al blocco funzione del modulo. Il tipo di dati è POINTER TO <ELEMTYPE> . <ELEMTYPE> può essere qualsiasi tipo di dati. L'obiettivo di una sezione VarArray deve identificare l'array di variabili in modo univoco. Var_Count definisce il percorso dell'istanza di input di un numero intero Variable del blocco funzione del modulo. Per essere disponibile nell'editor per la configurazione questa variabile deve essere definita come parametro. In alternativa la variabile Var_Count di Slot_Multi o InstRef_Multi possono essere utilizzati per definire questa variabile. Più VarArray possono utilizzare lo stesso Var_Count variabile. Se la dimensione dell'array è 0, non verrà generato alcun array e il puntatore dell'array verrà impostato su 0. Inst_Name definisce il nome della variabile di array creata. Il segnaposto %Instancename% E %VariablePath% (l'ortografia maiuscola o minuscola non è rilevante) verrà sostituito dal nome dell'istanza del modulo risp. il percorso dell'istanza della variabile puntatore. I punti verranno sostituiti da sottolineature. Se la definizione viene omessa, verrà utilizzato il valore predefinito AC_ARRAY_%VariablePath% . si usa. Verrà creato un errore se due diversi VarArray di un modulo hanno lo stesso Inst_Name , che non include il segnaposto %VariablePath% . Pragmas contiene un elenco di pragma del compilatore, che verranno inseriti prima della variabile di array generata. Var_Decl_Flags può essere utilizzato per specificare il tipo di variabile dell'array creato. I possibili flag sono NONE , RETAIN , E PERSISTENT . Questi flag vengono aggiunti alla sezione variabile VAR_INPUT , in cui viene creato l'array. (esempio: per la bandiera RETAIN , VAR_INPUT RETAIN ). Esempio SEC VAR_ARRAYS\n SEC VAR_ARRAY : NameList\n Variable := psNameList;\n Var_Count := uiArraySize;\n END_SEC\n ...\n SEC PARAM : ArraySize\n Variable := uiArraySize;\n Name := TL.ArraySize_Name;\n Desc := TL.ArraySize_Desc;\n END_SEC\nEND_SEC Tra le altre dichiarazioni, la parte dichiarazione del blocco funzione deve contenere: uiArraySize: UINT := 7; psNameList: POINTER TO STRING; . " }, 
{ "title" : "Sezione: Vincoli ", 
"url" : "ac_module_fb_sec_constraints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Vincoli ", 
"snippet" : "Vincoli Questa sezione speciale consente di verificare se ciascuna istanza del modulo viene referenziata almeno una volta. SEC Constraints \/\/optional: yes, modifier: [UPDATE] Referenced_By := <interface name>; \/\/optional: yes, type: QID) Referenced_Cardinality := [<minimum> .. <maximum>]; \/\/optional...", 
"body" : "Vincoli Questa sezione speciale consente di verificare se ciascuna istanza del modulo viene referenziata almeno una volta. SEC Constraints \/\/optional: yes, modifier: [UPDATE]\n Referenced_By := <interface name>; \/\/optional: yes, type: QID)\n Referenced_Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . Specifica: Il parametro Referenced_By serve a verificare se le istanze del modulo fanno riferimento ad altre istanze del modulo. Il valore di ReferencedBy deve essere un'interfaccia che deriva da IModule . Se non importa quale sia il tipo dell'istanza di riferimento, IModule può essere specificato qui. Referenced_Cardinality definisce la frequenza con cui si deve fare riferimento a questo modulo. Se il numero di riferimenti non rientra in questo intervallo, viene prodotto un errore durante la scansione del generatore standard. Esempio SEC Constraints\n Referenced_By := ISpecificModule;\n Referenced_Cardinality := [1 .. 3];\nEND_SEC " }, 
{ "title" : "Sezione: Rif.Ist ", 
"url" : "ac_module_fb_sec_instrefs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Rif.Ist ", 
"snippet" : "Rif. ist La sezione InstRefs definisce i riferimenti alle istanze FB o alle istanze della struttura. SEC InstRefs \/\/optional: yes, modifier: [UPDATE] SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: no, type: InstancePath Desc :...", 
"body" : "Rif. ist La sezione InstRefs definisce i riferimenti alle istanze FB o alle istanze della struttura. SEC InstRefs \/\/optional: yes, modifier: [UPDATE]\n SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n...\n SEC InstRef_Multi : <identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n END_SEC\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . Specifica: Inst_Ref.Variable definisce il percorso dell'istanza di input di una variabile di tipo POINTER TO <T> o di tipo <interface> . ( <T> è qualsiasi struttura o tipo FB) InstRef_Multi.Variable definisce il percorso dell'istanza di input di tipo POINTER TO POINTER TO <T> o di tipo POINTER TO <interface> . ( <T> è qualsiasi struttura o tipo FB) Due voci InstRef o InstRef-Multi diverse non devono utilizzare la stessa variabile. La destinazione deve identificare in modo univoco il riferimento all'istanza. Ciò significa che non devono esistere due diverse dichiarazioni di riferimento all'istanza (sezione InstRef E InstRef_Multi ) con lo stesso target (l'ortografia maiuscola o minuscola non è rilevante). La variabile intera di input definita da Var_Count può essere utilizzato solo una volta alla volta VarCounts Di Slot_Multi O InstRef_Multi . Solo variabili intere definite da Var_Count Di VarArray può essere utilizzato in parallelo a Var_Counts Di Slot_Multi O InstRef_Multi . Esempio SEC InstRef_Multi : Elements\n Variable := piElems ;\n Var_Count := uiArraySize ;\n Desc := TL.Elems_Desc ;\n Cardinality := [1 .. 10] ;\nEND_SEC Tra le altre dichiarazioni, la parte dichiarazione del blocco funzione deve contenere: uiArraySize : UINT; piElems : POINTER TO Interface; piElems punta a un file creato globalmente, inizializzato correttamente ARRAY[0..uiArraySize-1] OF interface O OF POINTER TO <T> , che fa riferimento ai singoli casi. Di conseguenza, è possibile accedere all'i-esimo oggetto tramite piElems[i] . " }, 
{ "title" : "Sezione: mse.Sequenza ", 
"url" : "ac_module_fb_sec_sequence.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: mse.Sequenza ", 
"snippet" : "mse.Sequenza Questa sezione determina le definizioni dell'editor di sequenze. La sezione deve essere presente nella dichiarazione del modulo, affinché l'editor dei moduli offra la scheda aggiuntiva Redattore di sequenze . SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE] Root := TRUE\/FALSE; \/\/opt...", 
"body" : "mse.Sequenza Questa sezione determina le definizioni dell'editor di sequenze. La sezione deve essere presente nella dichiarazione del modulo, affinché l'editor dei moduli offra la scheda aggiuntiva Redattore di sequenze . SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE]\n Root := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Step := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Parallel := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Branch := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n VisibleParams := [<visparam1>, <visparam2>,...]; \/\/optional: yes, type: ID-list\n VisibleIOs := [<visIO1>, <visIO2>,...]; \/\/optional: yes, type: ID-list\n VisibleRefs := [<visref1>, <visref2>,...]; \/\/optional: yes, type: ID-list\n AConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n BConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n OnlineActiveVar := <xActive>; \/\/optional: yes, type: ID\n OnlineBreakpointVar := <xBreakpoint>; \/\/optional: yes, type: ID\n OnlineBreakpointActiveVar := <xAvtiveBreakpoint>; \/\/optional: yes, type: ID\n OnlineWatchVars := [<variable1>, <variable2>,...]; \/\/optional: yes\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . Specifica: Solo una delle definizioni Root , Step , Parallel , O Branch può essere impostato su TRUE per un modulo. A seconda di questa definizione, il modulo viene rappresentato nell'editor di sequenza come uno dei seguenti elementi di sequenza: Radice: Se la sequenza è definita come Root , l'editor dell'istanza del modulo fornisce la scheda aggiuntiva Redattore di sequenze . Per tutte le altre sequenze non viene visualizzato l'editor di sequenze. La larghezza della casella può essere modificata nelle opzioni. Fare un passo: Questo elemento è simile a Root elemento, ma non abilita la scheda aggiuntiva Redattore di sequenze . La casella viene utilizzata per visualizzare e regolare alcune proprietà del modulo, che sono definite nel suo mse.Sequence sezione. Parallelo: Viene visualizzata una sequenza parallela con un cerchio sotto la casella. La casella viene utilizzata per visualizzare e regolare alcune proprietà del modulo, che sono definite nel suo mse.Sequence sezione. Ramo: Un quadrato inclinato sotto la casella indica un ramo. La casella viene utilizzata per visualizzare e regolare alcune proprietà del modulo, che sono definite nel suo mse.Sequence sezione. VisibleParams definisce i parametri disponibili nella casella dell'elemento della sequenza. VisibleIOs definisce gli IO disponibili nella casella dell'elemento della sequenza. VisibleRefs definisce i riferimenti disponibili nella casella dell'elemento della sequenza. AConnectionColor : Le linee di collegamento tra le istanze del modulo dello slot assegnato sono disegnate con il colore di Una connessione . Questo può essere impostato nelle opzioni dell'editor di sequenze. BConnectionColor : Le linee di collegamento tra le istanze del modulo dello slot assegnato sono disegnate con il colore di Collegamento B . Questo può essere impostato nelle opzioni dell'editor di sequenze. OnlineActiveVar : A questo parametro può essere assegnata una variabile booleana, che deve essere dichiarata nel blocco funzione appropriato o in uno dei suoi blocchi funzione di base. In modalità online, se la variabile è impostata su TRUE , il passaggio della sequenza viene visualizzato in giallo. OnlineBreakpointVar : A questo parametro può essere assegnata una variabile booleana, che deve essere dichiarata nel blocco funzione corrispondente o in uno dei suoi blocchi funzione di base. In modalità online il comando Attiva\/disattiva punto di interruzione dal menu contestuale imposta o reimposta un punto di interruzione. Inoltre, imposta la variabile assegnata su TRUE O FALSE Se è impostato su TRUE , il passo nell'editor di sequenze viene visualizzato con un bordo rosso. OnlineBreakpointActiveVar : A questo parametro può essere assegnata una variabile booleana, che deve essere dichiarata nel blocco funzione corrispondente o in uno dei suoi blocchi funzione di base. In modalità online, se la variabile è impostata su TRUE , il passaggio della sequenza viene visualizzato in rosso. OnlineWatchVars : tutte le variabili (con tipo di dati semplice) definite in VAR_INPUT , VAR_OUTPUT , VAR , O VAR_IN_OUT dell'FB (o dei suoi FB di base) possono essere utilizzati come variabili. Tipi di variabili complesse (della forma FBInst.xVariable ecc.) non possono essere utilizzati. Le variabili devono essere inserite in un elenco separato da virgole. Esempio SEC mse.Sequence\n Branch;\n VisibleIOs := [xIn];\n AConnectionColor := [itfSequenceTrue];\n BConnectionColor := [itfSequenceFalse];\n OnlineActiveVar := xActive;\n OnlineBreakpointVar := xBreakpoint;\n OnlineBreakpointActiveVar := xBreakpointActive;\n OnlineWatchVars := [iPartTimeElapsed];\nEND_SEC " }, 
{ "title" : "Sezione: Disaccoppiato ", 
"url" : "ac_module_fb_sec_decoupled.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Disaccoppiato ", 
"snippet" : "Disaccoppiato Questa sezione definisce i \"moduli disaccoppiati\". Si tratta di moduli con le proprietà dei moduli di primo livello, ma possono essere inseriti anche come sottomoduli in appositi slot ( Type:= DECOUPLED ) di altri moduli. I moduli non possono essere \"toplevel\" e \"disaccoppiati\" contemp...", 
"body" : "Disaccoppiato Questa sezione definisce i \"moduli disaccoppiati\". Si tratta di moduli con le proprietà dei moduli di primo livello, ma possono essere inseriti anche come sottomoduli in appositi slot ( Type:= DECOUPLED ) di altri moduli. I moduli non possono essere \"toplevel\" e \"disaccoppiati\" contemporaneamente. I \"moduli disaccoppiati\" vengono generati utilizzando la sezione Decoupled nella dichiarazione del modulo. La sezione Decoupled è quasi identico alla sezione Toplevel ; tuttavia, solo una di queste sezioni è consentita in una dichiarazione di modulo. SEC Decoupled \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Toplevel_Insertable := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/optional: no, type: Text)\n Flags:= <flag>; \/\/optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nel capitolo relativo alla dichiarazione del modulo. Specifica: la specifica della sezione Decoupled corrisponde alla descrizione della sezione Toplevel . Inoltre è possibile definire i seguenti parametri: Toplevel_Insertable definisce se un \"sottomodulo disaccoppiato\" può essere inserito anche in primo livello come un modulo di primo livello. Nota: un \"modulo disaccoppiato\" dovrebbe definire e implementare un rispettivo proxy. Il proxy dovrebbe implementare la stessa interfaccia del \"modulo disaccoppiato\". Se l'istanza del modulo genitore si trova sotto un altro controller come istanza del modulo \"disaccoppiato\", allora l'istanza del modulo \"disaccoppiato\" può comunque essere inserita in questo slot tramite il suo proxy. Guarda anche Dichiarazione del modulo Sezione: Livello superiore " }, 
{ "title" : "Sezione: MacroModulo ", 
"url" : "ac_module_fb_sec_macromodule.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: MacroModulo ", 
"snippet" : "MacroModulo In questa sezione vengono descritti i parametri del MacroModulo. La sezione viene creata automaticamente quando si genera un modulo macro. In alternativa, è possibile inserire manualmente la sezione in una dichiarazione di modulo o modificare una sezione generata automaticamente. SEC Mac...", 
"body" : "MacroModulo In questa sezione vengono descritti i parametri del MacroModulo. La sezione viene creata automaticamente quando si genera un modulo macro. In alternativa, è possibile inserire manualmente la sezione in una dichiarazione di modulo o modificare una sezione generata automaticamente. SEC MacroModule \/\/optional: yes, modifier: None\n SEC Rootmodule : <identifier> \/\/optional: no, modifier: None\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: no, type: text\n New_Desc := <parameter description>; \/\/optional: no, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO ID>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n SEC VisuEmbeddings \/\/optional: yes, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID>; \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <linke ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTab := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: no, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection>; \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters : <identifier> \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value ID>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Submodule : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: yes, type: text\n New_Desc := <parameter description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO Id>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n Instance_Name := <instance name>; \/\/optional: no, type: ID\n SEC VisuEmbeddings \/\/optional: no, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID> \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID> \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTap := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: yes, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression> \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection> \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Reference : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n Referenced_Instance := <instance ID>; \/\/optional: no, type: ID\n END_SEC\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . Specifica: MacroModule : Se questa sezione è definita, allora nessun'altra sezione può apparire all'interno dell'intera dichiarazione del modulo tranne la sezione MetaData . Ogni dichiarazione di modulo con questa sezione è identificata chiaramente come tipo MacroModule. Un'altra sezione MacroModule non è consentito all'interno di una dichiarazione di modulo. Rootmodule : Indica che le seguenti sottosezioni descrivono il sottomodulo radice, che dovrebbe essere 1) la radice di questo tipo MacroModule e 2) inserito come genitore superiore di tutti gli altri sottomoduli del tipo MacroModule. Submodule : Indica che le seguenti sottosezioni descrivono un sottomodulo, che deve essere inserito sotto il sottomodulo radice in un sottoalbero per il tipo MacroModule. MacroParameter : Se questo tipo di sottosezione viene utilizzato in una sezione Submodule O Root , allora può essere indicato che un parametro specifico del sottomodulo definito (o root) dovrebbe esso stesso presentarsi come parametro del modulo macro. Per questo, l'obiettivo della sezione MacroParameter viene utilizzato come nuovo ID parametro per il parametro del modulo macro. Il parametro del sottomodulo dato (o radice) viene quindi definito da Local_ParameterID . Inoltre è possibile creare voci di liste di testo utilizzando le definizioni di New_Name E New_Desc . Queste voci vengono utilizzate per il nome e la descrizione del nuovo parametro del modulo macro anziché per quello del sottomodulo o del parametro root. Tutti gli obiettivi definiti di tutte le sezioni MacroParameter all'interno di un intero modulo macro deve essere chiaro per garantire ID parametri univoci per tutti i parametri del modulo macro. MacroIO : Se questo tipo di sottosezione viene utilizzato nella sezione Submodule O Root , allora si può indicare che un determinato I\/O del sottomodulo definito (o root) dovrebbe esso stesso presentarsi come I\/O del modulo macro. Per questo, l'obiettivo della sezione MacroIO viene utilizzato come nuovo ID I\/O per l'I\/O del modulo macro. L'I\/O del sottomodulo dato (o radice) viene quindi definito da Local_IOID . Inoltre è possibile creare voci di liste di testo utilizzando le definizioni di New_Name E New_Desc . Queste voci vengono utilizzate per il nome e la descrizione del nuovo I\/O del modulo macro invece del sottomodulo o dell'I\/O root. Tutti gli obiettivi definiti di tutte le sezioni MacroIO all'interno di un intero modulo macro deve essere chiaro per garantire ID I\/O univoci per tutti gli I\/O del modulo macro. MacroSlot : Se questa sottosezione viene utilizzata nella sezione Submodule O Root , allora può essere indicato che uno slot specifico del sottomodulo definito (o radice) dovrebbe esso stesso presentarsi come slot del modulo macro. In questo modo è possibile inserire ulteriori istanze del modulo sotto questo slot dell'istanza MacroModule. Per questo, l'obiettivo della sezione MacroSlot viene utilizzato come nuovo ID slot per lo slot del modulo macro. Lo slot del sottomodulo specificato (o radice) viene quindi definito da Local_SlotID . Inoltre è possibile creare una voce in un elenco di testi utilizzando le definizioni New_Role . Questa voce viene utilizzata per il ruolo del nuovo slot del modulo macro anziché quello del sottomodulo o dello slot root. Tutti gli obiettivi definiti di tutte le sezioni MacroSlot all'interno di un intero MacroModule deve essere chiaro per garantire ID slot univoci per tutti gli slot MacroModule. Parent_Instance : Definisce un ID corrispondente a un ID di destinazione di una sezione Rootmodule O Submodule della sezione comprensiva MacroModule . Questa definizione esiste solo all'interno della sezione Submodule . Definisce l'istanza del modulo genitore sotto la quale deve essere inserito il sottomodulo. Questo sottomodulo è descritto nella rispettiva sezione Submodule del MacroModulo. Inoltre, la definizione Parent_Slot è anche richiesto. Parent_Slot : Definisce un ID corrispondente all'ID dello slot situato sotto il tipo di sottomodulo identificato da Parent_Module . Il sottomodulo del tipo MacroModule descritto dalla sezione Submodule è inserito sotto questo slot. Default_Allocation : Questo è identico alla sezione con lo stesso nome sotto le dichiarazioni degli slot ( Slot E Slot_Multi ). Questa sezione definisce sia per il \"modulo root\" che per il \"sottomodulo\" quale tipo di sottomodulo di tipo MacroModule deve essere inserito per quale configurazione di istanza. L'unica differenza è che no Instance_Name può essere definito per Default_Allocation sotto una sezione Rootmodule , ma piuttosto in sezioni Submodule . Il motivo è che le istanze del modulo inserite come \"modulo root\" ricevono il nome dall'istanza MacroModule e quindi non possono essere inserite per \"default\". Reference : Mostra che le seguenti sottosezioni descrivono un riferimento al modulo. Viene generato un riferimento sotto l'istanza del modulo Parent_Instance e la fessura Parent_Slot , facendo riferimento al sottomodulo Referenced_Instance . Come il Parent_Instance , questa istanza di riferimento deve provenire dall'insieme del sottomodulo di istanze del modulo root sotto la stessa sezione MacroModule . La dichiarazione del modulo di tipo MacroModule deve soddisfare le seguenti condizioni: Non deve essere utilizzato IMPLEMENTED_BY O IMPORTS nella sua dichiarazione del modulo. Deve includere la sezione MetaData E MacroModule . Altrimenti non devono essere utilizzate sezioni aggiuntive. Ce ne deve essere almeno uno Rootmodule sezione sotto il Macro_Module sezione. Inoltre, non deve esserci un secondo Rootmodule sezione. Per ciascuno submodule , entrambi i Parent_Instance e il Parent_Slot deve essere definito all'interno MacroModule . Questo deve quindi essere definito come Local_SlotID entro MacroSlot del Parent_Instance . " }, 
{ "title" : "Sezione: Generatore di dispositivi ", 
"url" : "ac_module_fb_sec_devicegenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Generatore di dispositivi ", 
"snippet" : "Generatore di dispositivi La sezione DeviceGenerator serve a definire tutte le impostazioni relative al Device Generator. Contiene le seguenti sottosezioni: Sottosezione: Device : Definizioni per aggiungere dispositivi all'albero dei dispositivi Sottosezione: Parameter : Definizioni per aggiungere o...", 
"body" : "Generatore di dispositivi La sezione DeviceGenerator serve a definire tutte le impostazioni relative al Device Generator. Contiene le seguenti sottosezioni: Sottosezione: Device : Definizioni per aggiungere dispositivi all'albero dei dispositivi Sottosezione: Parameter : Definizioni per aggiungere o modificare i parametri dei dispositivi Sottosezione: Connetti: definizioni per connettere gli IO del modulo agli IO del dispositivo Sottosezione: Wildcards : Definizioni per creare dispositivi \"Wildcard\". Sottosezione: Demand : Definizioni per definire proprietà \"impegnative\". Sottosezione: InstRefMapping : Definizione per connettere i dispositivi creati con il modulo InstRefs. I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . " }, 
{ "title" : "Sottosezione: Dispositivo ", 
"url" : "ac_module_fb_sec_devicegenerator_device.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Generatore di dispositivi \/ Sottosezione: Dispositivo ", 
"snippet" : "IL Device la sottosezione definisce i dispositivi che devono essere aggiunti dal generatore di dispositivi. Esistono diversi tipi di dispositivi generati definiti con le diverse sottosezioni Identification , Wildcard , E FlexibleWildcard . Sintassi: SEC DeviceGenerator \/\/optional: yes, modifier: [UP...", 
"body" : "IL Device la sottosezione definisce i dispositivi che devono essere aggiunti dal generatore di dispositivi. Esistono diversi tipi di dispositivi generati definiti con le diverse sottosezioni Identification , Wildcard , E FlexibleWildcard . Sintassi: SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Device : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n ParentSlotIndex := <slot number>; \/\/optional: yes, type: literal\/integer\n SEC Identification \/\/optional: yes, modifier: [UPDATE]\n Type := <type number>; \/\/optional: no, type: literal\/string\n ID := <ID mumber>; \/\/optional: no, type: literal\/string\n ModuleID := <module ID>; \/\/optional: yes, type: literal\/string\n Version := <version mumber>; \/\/optional: no, type: literal\/string\n SEC SetChildName \/\/optional: yes, modifier: [UPDATE]\n Value := <child name>; \/\/optional: no, type: literal\/string\n ChildIndex := <index number>; \/\/optional: no, type: literal\/string\n END_SEC\n END_SEC\n END_SEC\n SEC ExportDevice \/\/optional: yes, modifier: [UPDATE, HIDE]\n Files :=[<filename1>, <filename2>, ...]; \/\/optional: no, type: string\n END_SEC\nEND_SEC Specifica: IL Device sezione ha un ID di destinazione che la identifica in modo univoco tra gli altri dispositivi generati di un modulo. Questo ID può essere utilizzato per fare riferimento a questo dispositivo. Ciò avviene principalmente nella definizione Parent di altri dispositivi creati o I\/O collegati. IL Parent definizione specifica il dispositivo genitore desiderato sotto il quale deve essere montato il dispositivo creato. Il dispositivo genitore non può essere identificato affatto (la definizione è facoltativa), tramite il suo ID o tramite un parametro. Nel dettaglio, il dispositivo genitore viene poi determinato nel seguente modo: Se no Parent è definito, viene sempre utilizzato il primo genitore disponibile corrispondente e per un vuoto Parent la definizione cerca solo a partire dal primo modulo genitore. Se nessun dispositivo è definito nel modulo genitore diretto stesso, la cronologia dei moduli genitori viene tracciata fino a quando non viene finalmente trovato un dispositivo che corrisponde o viene raggiunto il modulo di livello superiore. In questo caso, se possibile, viene utilizzato il relativo dispositivo di applicazione. Se inoltre viene specificato un ID dispositivo o un parametro come a Parent , la cronologia dei dispositivi principali viene scansionata allo stesso modo, per cui ora vengono presi in considerazione anche i dispositivi del modulo di uscita stesso e anche un possibile dispositivo principale deve avere l'ID corrispondente. Se secondo le regole sopra descritte non viene trovato nessun possibile dispositivo genitore, durante il controllo della generazione viene emesso un errore. ParentSlotIndex : specifica l'indice dello slot (numero) del dispositivo principale in cui è inserito il dispositivo. Ciò è utile quando è necessario il collegamento. IL Identification la sottosezione include la descrizione univoca di un dispositivo da aggiungere. Questo crea un riferimento univoco a questo Device tipo. Le definizioni Type , ID , ModuleID , E Version del Identification sezione identifica in modo univoco un tipo di dispositivo di una versione specifica. Ad esempio, un Master EtherCAT ha la seguente definizione: Type := '64'; ID := '000 0001'; Version := '3.5.1.0'; Se * è definita come la versione, viene sempre utilizzata la versione più recente del dispositivo. Se la ModuleID non viene utilizzata la definizione, nel sistema vengono cercati i dispositivi con DeviceIdentification, altrimenti vengono cercati i dispositivi con identificativo modulo. Se il dispositivo definito non esiste nell'archivio dispositivi, durante il processo di scansione viene già emesso un messaggio di errore corrispondente. Sottosezione: SetChildName con le definizioni di Value E ChildIndex Queste opzioni permettono di specificare il nome che dovrà avere un dispositivo inserito automaticamente. Se lo stesso nome viene utilizzato più di una volta, il nome risultante viene reso univoco aggiungendo un carattere di sottolineatura e un numero. Value : nome desiderato del dispositivo ChildIndex : Indice del dispositivo inserito automaticamente da rinominare Questa sezione offre la possibilità di compilare i campi con l'aiuto dell'Input Assistant. Per fare ciò, posiziona il cursore alla fine della riga successiva Identification e premere Ritorno . Successivamente, l'Assistente di input si apre e offre i canali disponibili. Dopo aver scelto un dispositivo, i parametri corrispondenti vengono trasferiti nella dichiarazione del modulo. Tieni presente che questa funzione è disponibile solo alla fine della sottosezione ( END_SEC ) non è stato ancora inserito. La definizione File contiene un elenco di dispositivi che verranno aggiunti al progetto. Questi dispositivi sono stati configurati manualmente ed esportati in una libreria. Esempio SEC Device : Buskoppler2\n SEC Identification\n Type := '65';\n ID := '2_044C2C5200110000';\n Version := '*';\n END_SEC\nEND_SEC\nSEC Device : KlemmeDigitalOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\n SEC ExportDevices\n Files := [ExtFile.BK5120_1SDO, ExtFile.BK5120_2SDO];\n END_SEC\nEND_SEC Esempio con parametri SEC std.DeviceGenerator\n SEC Device : CANopen_Manager\n Parent := CurrentCAN;\n SEC FlexibleIdentification\n Type := '16';\n ID := '181016';\n Version := '*';\n Maximum := 1;\n END_SEC\n END_SEC\nEND_SEC\nSEC std.Parameters\n SEC Param : CurrentCAN\n Name := TL.CurrentCAN_Name;\n Desc := TL.CurrentCAN_Desc;\n VariableType := wSTRING;\n Default := 'CANBus_0';\n END_SEC\nEND_SEC Esempio di definizione del nome di un dispositivo SEC std.DeviceGenerator\n\tSEC Device : EcoVario\n\t Parent := CanManager;\n\t\tSEC Identification\n\t\t Type := '18';\n\t\t ID := '1619 0001';\n\t\t Version := '*';\n\t\t SEC SetChildName : ChildDevice\n\t\t\t Value := 'ChildName';\n\t\t\t ChildIndex := 0;\n\t\t END_SEC\n\t END_SEC\n END_SEC\n SEC Parameters : EcoVario\n\t SEC AddParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t ParameterName := 'BoolParam';\n\t \tParameterType := 'std:BOOL';\n\t\t ChildIndex := 0;\n\t END_SEC\n\t SEC SetParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t\tElemPath := '';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\t\tSEC SetParameter : bVirtual\n\t\t\tParameterID := '1040';\n\t\t\tElemPath := '';\n\t\t\tConnectorID := '0';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\tEND_SEC\n SEC InstRefMapping : Axis\n\t SEC Demand\n\t Desc := TL.DescAxis;\n\t\t\tProperties := [SM_DRIVE_CAN];\n\t\tEND_SEC\n\tEND_SEC\nEND_SEC\n " }, 
{ "title" : "Sottosezione: Connetti ", 
"url" : "ac_module_fb_sec_devicegenerator_connect.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Generatore di dispositivi \/ Sottosezione: Connetti ", 
"snippet" : "Questa sottosezione della sezione IOMapping serve per connettere gli IO del modulo con gli IO del dispositivo specificati. Questa mappatura viene eseguita senza conoscere l'esatta struttura IO del dispositivo. Per le connessioni dirette si presuppone che l'IO del modulo e l'IO del dispositivo specif...", 
"body" : "Questa sottosezione della sezione IOMapping serve per connettere gli IO del modulo con gli IO del dispositivo specificati. Questa mappatura viene eseguita senza conoscere l'esatta struttura IO del dispositivo. Per le connessioni dirette si presuppone che l'IO del modulo e l'IO del dispositivo specificato siano compatibili SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC IOMapping : <mapping identifier> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Connect \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n END_SEC\n END_SEC\nEND_SEC Specifica: La sezione IO ha una destinazione che corrisponde all'ID di destinazione del modulo IO che verrà collegato. Verrà ricercato questo ID di destinazione nel modulo che contiene la connessione del dispositivo specificato. Se non viene trovato alcun IO del modulo corrispondente, durante la scansione viene emesso un messaggio di errore. La definizione facoltativa Parent fornisce l'ID del dispositivo che verrà cercato per l'IO del dispositivo specificato (ParameterID). Finché non viene trovato, verranno cercati consecutivamente il modulo del dispositivo e la cronologia dei dispositivi genitori. Se non viene trovato l'apparecchio adatto, durante il controllo della generazione viene emesso un messaggio di errore. La sezione Connect contiene tutte le definizioni necessarie per connettere un modulo IO a un dispositivo IO. ParameterID definisce il canale IO ParameterID del dispositivo a cui verrà connesso. Si tenta di trovare questo parametro nei dispositivi specificati dal modulo stesso. Se non viene specificato alcun dispositivo, viene effettuato un tentativo di trovare il parametro nel successivo dispositivo genitore possibile. Quindi il parametro viene collegato agli I\/O del modulo. Se nessuno dei dispositivi generati nella gerarchia dei moduli offre il parametro specificato con questo ParameterID , viene emesso un errore. ElemPath definisce il sottoelemento del parametro del dispositivo (canale I\/O) che verrà collegato agli I\/O del modulo. È anche possibile specificare percorsi, ecc. Il parametro ConnectorID facoltativamente definisce il connettore del dispositivo, di cui HostParameterSet contiene il ParameterID . Se no ConnectorID è specificato, il ParameterID viene cercato sotto il DeviceParameterSet . Questa sezione offre la possibilità di compilare i campi con l'aiuto dell'Input Assistant. Per fare ciò, posiziona il cursore alla fine della riga successiva Connect e premere Ritorno . Successivamente, l'Assistente di input si apre e offre i canali disponibili. Dopo aver scelto un canale, i parametri corrispondenti vengono trasferiti nella dichiarazione del modulo. Tieni presente che questa funzione è disponibile solo alla fine della sottosezione ( END_SEC ) non è stato ancora inserito. Esempio SEC IOMapping: xIn\n SEC Connect\n ParameterID := '33554434';\n ElemPath := '';\n ConnectorID := '1';\n END_SEC\nEND_SEC " }, 
{ "title" : "Sottosezione: Domanda ", 
"url" : "ac_module_fb_sec_devicegenerator_demand.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Generatore di dispositivi \/ Sottosezione: Domanda ", 
"snippet" : "Questa sottosezione di IOMapping consente agli IO del modulo di specificare le proprietà (esempio: 24 V e non 230 V), che dovrebbero essere offerte dagli IO del dispositivo per una connessione corretta. Le proprietà richieste possono essere assegnate come proprietà di \"offerta\" agli IO dei dispositi...", 
"body" : "Questa sottosezione di IOMapping consente agli IO del modulo di specificare le proprietà (esempio: 24 V e non 230 V), che dovrebbero essere offerte dagli IO del dispositivo per una connessione corretta. Le proprietà richieste possono essere assegnate come proprietà di \"offerta\" agli IO dei dispositivi durante la generazione. L'assegnazione viene memorizzata in allegato al file di descrizione del dispositivo. Per la connessione IO automatica del generatore di dispositivi, ciò significa che ciascun modulo IO con proprietà \"richieste\" eseguirà la scansione dei dispositivi generati o dei caratteri jolly dei suoi moduli principali finché non viene trovato un dispositivo e un canale IO, le cui proprietà \"di offerta\" soddisfano i requisiti richieste SEC IOMapping : <target> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n Properties := [<property1>,<property2>,...]; \/\/optional: no, type: IDList\n END_SEC\nEND_SEC Specifica: Le sottosezioni Demand E Connect non possono essere definiti contemporaneamente. Desc definisce una descrizione (localizzata) della connessione richiesta (in un elenco di testo). Properties definisce un elenco di proprietà che descrivono le proprietà richieste dal modulo IO (esempio: [Input24V, Digital]) È possibile definire diverse proprietà che consentono di qualificare gli IO del modulo (esempio: modulo IO che richiedeva solo \"Property1\" e modulo IO che richiedevano \"Proprietà1\", \"Proprietà2\", ecc.). Parent definisce l'ID del dispositivo sotto il quale il canale deve essere connesso. Per gli IO \"richiesti\" sono ammessi anche dispositivi jolly come possibili dispositivi di connessione. SEC std.DeviceGenerator\n SEC IOMapping : xOn\n SEC Demand\n Desc := TL_Rooms.Role_RoomStandard_Lights;\n Properties := [V24Output];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Sottosezione: caratteri jolly ", 
"url" : "ac_module_fb_sec_devicegenerator_wildcard.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Generatore di dispositivi \/ Sottosezione: caratteri jolly ", 
"snippet" : "IL Wildcard la sottosezione viene utilizzata per creare dispositivi jolly per moduli che non sono ancora noti al momento della creazione del modulo. I dispositivi dovrebbero quindi essere flessibili per essere specificati dall'utente prima o durante la generazione. SEC Device : <target> \/\/optional: ...", 
"body" : "IL Wildcard la sottosezione viene utilizzata per creare dispositivi jolly per moduli che non sono ancora noti al momento della creazione del modulo. I dispositivi dovrebbero quindi essere flessibili per essere specificati dall'utente prima o durante la generazione. SEC Device : <target> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Wildcard : <target> \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n END_SEC\nEND_SEC Specifica: IL Identification , Wildcard , E FlexibleWildcard le sottosezioni non possono essere utilizzate contemporaneamente. L'obiettivo della sezione Wildcard determina il tipo del dispositivo jolly. Moduli diversi possono utilizzare dispositivi jolly dello stesso tipo (esempio: \"8 ingressi\"). Tutti i dispositivi jolly dello stesso tipo vengono assegnati allo stesso dispositivo. Desc definisce una descrizione (localizzata) del dispositivo jolly (in un elenco di testo). Parent definisce il dispositivo genitore desiderato. Qui sono possibili anche dispositivi con caratteri jolly, a condizione che siano già assegnati ai dispositivi. Se il dispositivo impostato per il dispositivo jolly non è un dispositivo principale compatibile, viene emesso un errore durante la generazione. Esempio SEC Device : KlemmeAnalogOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\nEND_SEC " }, 
{ "title" : "Sottosezione: Parametro ", 
"url" : "ac_module_fb_sec_devicegenerator_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Generatore di dispositivi \/ Sottosezione: Parametro ", 
"snippet" : "La sezione Parameter con le sottosezioni SetParameter E AddParameter serve per aggiungere o modificare i parametri dei dispositivi. Ciò consente di generare impostazioni specifiche dei dispositivi (esempio: tempo di ciclo). SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC Parameters : <pa...", 
"body" : "La sezione Parameter con le sottosezioni SetParameter E AddParameter serve per aggiungere o modificare i parametri dei dispositivi. Ciò consente di generare impostazioni specifiche dei dispositivi (esempio: tempo di ciclo). SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Parameters : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n SEC SetParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n Value := <value name>; \/\/optional: no, type: literal\/string\n ChildIndex := <device ID>;\n Download := <boolean value> \/\/ opional: yes, type: boolean\n END_SEC\n SEC AddParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ParameterName := <parameter name>; \/\/optional: no, type: literal\/string\n ParameterType := <parameter type>; \/\/optional: no, type: literal\/string\n ChannelType := <channel type>; \/\/optional: yes, type: enum\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n ChildIndex := <device ID>;\n END_SEC\n END_SEC\nEND_SEC Specifica: IL Parameters sezione ha un obiettivo, con il quale il DeviceID del dispositivo di destinazione è definito, il cui parametro deve essere modificato. Il dispositivo di destinazione verrà cercato prima nei dispositivi del modulo e poi nella loro cronologia principale. Sono possibili anche dispositivi jolly o altri dispositivi. Si presuppone che questi dispositivi abbiano il parametro corrispondente o che il parametro corrispondente possa essere aggiunto. Se la scansione non riesce a trovare il dispositivo di destinazione verrà visualizzato un avviso. Gli obiettivi delle sezioni SetParameter E AddParameter definiscono l'ID della rispettiva sezione ma non hanno ulteriore utilizzo. Specifica per la sezione SetParameter : ParameterID definisce il ParameterID del parametro del dispositivo che verrà modificato. ElemPath specifica l'elemento esatto del parametro che verrà modificato. Il parametro ConnectorID facoltativamente definisce il connettore del dispositivo, il cui HostParemeterSet contiene il parametro Id. Se no ConnectorID è specificato, il ParameterID viene cercato in DeviceParameterSet. Value definisce il valore che verrà assegnato all'elemento del parametro specificato. Questo valore deve essere compatibile con il tipo di elemento. Il valore può essere ad esempio un'espressione [paramID] + 2*MODULE_SLOT_INDEX Là [paramID] definisce un ID di destinazione di un parametro, in modo che [paramID] verrà sostituito dal valore del parametro. IL MODULE_SLOT_INDEX La parola chiave viene sostituita dall'indice dello slot che un'istanza del modulo del tipo di modulo definito avrebbe dopo l'inserimento. Se il parametro non può essere trovato nel dispositivo di destinazione, il controllo del generatore creerà avvisi. ChildIndex definisce il dispositivo subordinato sotto il quale il parametro viene aggiunto o impostato. Se questo dispositivo subordinato con l'indice specifico non esiste, durante la generazione viene generato un avviso. Download : Voce facoltativa. Se questa voce ha il valore FALSE , il parametro non verrà scaricato sul dispositivo. È logico utilizzarlo, ad esempio, per disabilitare CheckVendorId per dispositivi CAN, ad esempio. Specifica per la sezione AddParameter : ParameterID definisce il nuovo ID del parametro da aggiungere. Questo deve essere univoco tra gli altri ParametriID del dispositivo di destinazione. Il parametro ConnectorID facoltativamente definisce il connettore del dispositivo, il cui HostParemeterSet contiene il parametro Id da aggiungere. Se non è definito alcun ID connettore, l'ID parametro verrà aggiunto in DeviceParameterSet. ParameterName definisce il nome del parametro aggiunto al dispositivo di destinazione. ParameterType definisce il tipo del parametro aggiunto al dispositivo di destinazione. Questo tipo è denominato secondo la notazione del tipo IEC con il prefisso del tipo. Quindi esempio: std:bool creerà un parametro booleano. Se il parametro non può essere aggiunto, il controllo del generatore creerà degli avvisi. ChannelType definisce il tipo di canale. I valori possibili sono NONE , INPUT , OUTPUT , E OUTPUTREADONLY . ChildIndex definisce il dispositivo subordinato sotto il quale il parametro viene aggiunto o impostato. Se questo dispositivo subordinato con l'indice specifico non esiste, durante la generazione viene generato un avviso. Entrambe le sezioni AddParameter E SetParameter possono essere utilizzati insieme per aggiungere un parametro a un dispositivo e allo stesso tempo assegnargli un valore. Esempio SEC Parameters : Buskoppler1\n SEC AddParameter : ExpertSettings\n ParameterID := '805306368';\n ConnectorID := '1';\n ParameterName := 'ExpertSettings';\n ParameterType := 'std:int';\n ChannelType := OUTPUT;\n END_SEC\n SEC SetParameter : ExpertSettings\n ParameterID := '805306368';\n ElemPath := '';\n ConnectorID := '1';\n Value := dwParameterOffset + 2 * MODULE_SLOT_INDEX;\n END_SEC\n END_SEC " }, 
{ "title" : "Sottosezione: InstRefMapping ", 
"url" : "ac_module_fb_sec_devicegenerator_instrefmapping.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Generatore di dispositivi \/ Sottosezione: InstRefMapping ", 
"snippet" : "Nella sezione InstRefMapping con la sottosezione Demand un modulo InstRef può essere riempito automaticamente con un'istanza FB creata da un dispositivo. SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE] Parent := <target ID>;...", 
"body" : "Nella sezione InstRefMapping con la sottosezione Demand un modulo InstRef può essere riempito automaticamente con un'istanza FB creata da un dispositivo. SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <...>; \/\/optional: no, type: text\n Properties := <...>; \/\/optional: no, type: IDList\n END_SEC\n END_SEC\nEND_SEC Specifica: La sezione superiore InstRefMapping è integrato da un'ulteriore sezione facoltativa Demand . L'obiettivo della sezione superiore InstRefMapping definisce l'ID di un modulo InstRef, che verrà riempito con l'istanza FB. Sono supportati solo InstRef singoli (non InstRef_Multi), poiché è possibile creare solo singole istanze FB di singoli dispositivi. Desc definisce una descrizione localizzata della connessione. Properties definisce un elenco di proprietà che descrivono, ad esempio, i tipi FB richiesti dal modulo InstRef. È possibile definire più proprietà in modo che i singoli InstRef del modulo siano classificati come con gli IO del modulo. Sintassi [<Property1>, <Property2>,...] (esempio: [SoftMotionVirtualDrive, Property2] ). Parent definisce l'ID del dispositivo richiesto, l'istanza FB creata che verrà utilizzata per riempire il modulo InstRefs. Per InstRefs esigenti sono consentiti dispositivi jolly e dispositivi inseriti fissi. Esempio SEC std.InstRefs\n SEC InstRef : axisRef\n Variable := axis_ref;\n Desc := TL.axisref_Desc ;\n END_SEC\nEND_SEC\n\nSEC std.DeviceGenerator\n SEC Device : virtAxis\n SEC Identification\n Type := '1024';\n ID := 'FFFF 0001';\n Version := '*';\n END_SEC\n END_SEC\n SEC InstRefMapping : axisRef\n SEC Demand\n Desc := TL.axisref_Desc;\n Properties := [VirtualAxis];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Regole per i generatori ", 
"url" : "ac_module_fb_sec_devicegenerator_generating_rules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Sezione: Generatore di dispositivi \/ Regole per i generatori ", 
"snippet" : "Regole per la generazione dei dispositivi I dispositivi specificati nei moduli di livello superiore vengono collegati al dispositivo principale che contiene l'applicazione generata. Non verrà creato alcun dispositivo di primo livello. Se non viene specificato alcun ID del dispositivo principale, il ...", 
"body" : "Regole per la generazione dei dispositivi I dispositivi specificati nei moduli di livello superiore vengono collegati al dispositivo principale che contiene l'applicazione generata. Non verrà creato alcun dispositivo di primo livello. Se non viene specificato alcun ID del dispositivo principale, il dispositivo principale corrispondente più recente verrà utilizzato come nuovo oggetto principale. Ciò significa che se un modulo figlio genera un dispositivo, questo dispositivo verrà aggiunto, se possibile, sotto uno dei dispositivi generati del modulo genitore. Se il modulo genitore diretto non ha alcun dispositivo o non genera un dispositivo che possa stare sotto il dispositivo figlio, vengono utilizzati i dispositivi del modulo genitore-genitore e così via. Se non vengono più generati dispositivi principali, viene effettuato un tentativo di generazione nel dispositivo di livello superiore del rispettivo modulo di livello superiore. Se viene offerto più di un dispositivo da un oggetto modulo principale, verrà utilizzato il primo dispositivo compatibile. Guarda anche: Sottosezione: DispositivoIl nome del dispositivo generato è \"ID dispositivo + nome modulo + dispositivo\". Se questo nome è già utilizzato da un dispositivo verrà aggiunto un numero crescente. I dispositivi già creati non verranno eliminati da una nuova generazione; pertanto verranno mantenute le regolazioni manuali delle impostazioni. I parametri aggiuntivi o modificati creati dalla dichiarazione del modulo verranno assegnati ai dispositivi corrispondenti ad ogni esecuzione di generazione. Come tutti gli oggetti creati da Application Composer, i dispositivi aggiuntivi verranno contrassegnati nella struttura dei dispositivi. Se si tenta di modificare o eliminare tale dispositivo, verrà visualizzato un avviso. Questo avvertimento richiama l'attenzione sul fatto che eventuali modifiche apportate alle impostazioni del dispositivo potrebbero andare perse se, ad esempio, la struttura del modulo viene rigenerata dopo la modifica. Regole aggiuntive per la generazione del dispositivo I dispositivi secondari, che vengono aggiunti automaticamente a determinati dispositivi, sono classificati nella stessa istanza del modulo del loro genitore. Ciò significa che quei dispositivi figli vengono trattati come se fossero definiti nella dichiarazione del modulo, che, in effetti, contiene la definizione del loro dispositivo genitore. I dispositivi figli non vengono creati o eliminati in modo indipendente, ma vengono trattati solo insieme ai dispositivi genitori. Se un dispositivo porta con sé connettori espliciti, durante i controlli di compatibilità con altri dispositivi, questi ultimi vengono trattati come se fossero connettori impliciti. In altre parole, tutti i connettori vengono utilizzati per testare la compatibilità con altri dispositivi, in modo che alla fine venga utilizzato solo quel connettore (non importa se esplicito o implicito) che corrisponde al dispositivo genitore e al dispositivo figlio. Esplicitamente come oggetto principale del connettore, implicitamente come parte dell'oggetto principale del dispositivo. " }, 
{ "title" : "Generatore di allarmi ", 
"url" : "ac_alarmgenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Generatore di allarmi ", 
"snippet" : "Il generatore di allarmi fornisce allo sviluppatore del modulo un modo semplice per dotare i moduli esistenti della gestione degli allarmi disponibile in CODESYS . In questo modo vengono generate funzionalità per la gestione completa degli allarmi e la relativa visualizzazione. La nuova dichiarazion...", 
"body" : "Il generatore di allarmi fornisce allo sviluppatore del modulo un modo semplice per dotare i moduli esistenti della gestione degli allarmi disponibile in CODESYS . In questo modo vengono generate funzionalità per la gestione completa degli allarmi e la relativa visualizzazione. La nuova dichiarazione del modulo ( alg.Allarme) implementa questa funzionalità. Qui sono impostate tutte le definizioni necessarie per la gestione degli allarmi. Creazione della visualizzazione Insieme alla generazione dell'allarme viene creata una schermata di visualizzazione allarmi che costituisce un suggerimento per una visualizzazione panoramica (tabella allarmi) degli allarmi presenti nel progetto. Il modello per questa visualizzazione è impostato nelle impostazioni del generatore di allarmi. Se il generatore di visualizzazione è attivo, l'oggetto di visualizzazione creato o riutilizzato viene integrato come scheda nella visualizzazione di livello superiore. " }, 
{ "title" : "Generazione allarmi ", 
"url" : "ac_alarmgenerator.html#UUID-dd47c9b0-4cb3-6491-d721-bbb6aed14278_a4ecc0cda058afc0a8640e004fda36_id_4e1d8099cdf16f9cc0a8640e0073d212", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Generatore di allarmi \/ Generazione allarmi ", 
"snippet" : "Come tutti i generatori del CODESYS Application Composer , questo generatore può essere attivato o disattivato nel Configurazione del generatore . Il generatore esegue i seguenti passaggi: Viene cercato un oggetto di configurazione allarme, in modo che possa essere utilizzato per la generazione succ...", 
"body" : "Come tutti i generatori del CODESYS Application Composer , questo generatore può essere attivato o disattivato nel Configurazione del generatore . Il generatore esegue i seguenti passaggi: Viene cercato un oggetto di configurazione allarme, in modo che possa essere utilizzato per la generazione successiva. Se non esiste alcun oggetto di configurazione allarme, ne viene creato uno nuovo. Sotto l'oggetto Configurazione allarme viene cercato un oggetto di memorizzazione allarme. Se non esiste alcun oggetto di memorizzazione allarmi, viene utilizzato il modello di memorizzazione allarmi. Questo modello è definito nelle impostazioni del generatore di allarmi. Se l'opzione Nessun spazio di archiviazione è selezionato non viene utilizzato alcun modello di memorizzazione degli allarmi e il processo continua senza memorizzazione degli allarmi. Se viene trovato più di un modello, viene visualizzato un messaggio di errore. Nell'oggetto Configurazione allarme vengono cercati gli oggetti della classe allarme che hanno il nome definito in qualsiasi descrizione del modulo sotto la definizione alg.Alarm.SetAlarm.Class . Se vengono trovati gli oggetti della classe di allarme corrispondenti, verranno utilizzati. Se non viene trovata alcuna classe di segnalazione corrispondente, si tenta di crearne una nuova. Ciò presuppone che l'oggetto modello della classe di allarme con il nome corrispondente esista come modello nel pool POU del progetto o in una libreria di riferimento, in modo che possa essere utilizzato come modello della classe di allarme. Se non è disponibile alcun oggetto modello classe allarme corrispondente, viene visualizzato un errore. " }, 
{ "title" : "Sezione: alg.Allarme ", 
"url" : "ac_module_fb_sec_alarm.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Generatore di allarmi \/ Sezione: alg.Allarme ", 
"snippet" : "alg.Allarme La sezione SEC alg.Alarm descrive un allarme del modulo. Un allarme del modulo corrisponde essenzialmente ad un allarme del CODESYS gestione allarmi configurata in un gruppo allarmi. Tuttavia, un allarme del modulo contiene ancora aggiunte specifiche del modulo. Per ulteriori informazion...", 
"body" : "alg.Allarme La sezione SEC alg.Alarm descrive un allarme del modulo. Un allarme del modulo corrisponde essenzialmente ad un allarme del CODESYS gestione allarmi configurata in un gruppo allarmi. Tuttavia, un allarme del modulo contiene ancora aggiunte specifiche del modulo. Per ulteriori informazioni, vedere il Dichiarazione del modulo capitolo e Oggetto: Gruppo Allarme " }, 
{ "title" : "Specifica ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_355d83fb191b4801c0a864637767cb78", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Generatore di allarmi \/ Sezione: alg.Allarme \/ Specifica ", 
"snippet" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE] SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE] Class := <class name>; \/\/optional: no, type: ID Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath Latc...", 
"body" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE]\n SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE]\n Class := <class name>; \/\/optional: no, type: ID\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath\n LatchVar2 := <LatchVariable2>; \/\/optional: yes, type: InstancePath\n Deactivation := <DeactivationVariable>; \/\/optional: yes, type: InstancePath\n PendingTime := <PendingTime>; \/\/optional: yes, type: LiteralOrConstant\n PendingTimeParameter := <string> \/\/optional: no, type: literal\/string\n HigherPrioAlarm := <HigherPrioAlarm_ID>; \/\/optional: yes, type: ID\n ModuleCalls := <ModuleCallFlags>; \/\/optional: yes, type: ModuleCallFlag\n SEC Messages : <alarm identifier> \/\/optional: yes, modifier: [UPDATE]\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n Number := <ColumnNumber>; \/\/optional: no, type: Literal\n END_SEC\n SEC LatchVar <latch var identifier> \/\/optional: yes, modifier [UPDATE]\n LatchVar := <LatchVariable>; \/\/optional: no, type: InstancePath\n Number := <LatchVarNumber> \/\/optional: no, type: LiteralOrConstant\n END_SEC\n SEC UpperLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n UpperExpression := <UpperExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC LowerLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n LowerExpression := <LowerExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC InsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC OutsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC Digital \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n Equal := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n EqualsExpression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Change \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Event \/\/optional: yes, modifier: [UPDATE]\n END_SEC\n END_SEC\nEND_SEC SEC SetAlarm Le sottosezioni di SetAlarm definire tutte le proprietà necessarie o possibili per un allarme. L'obiettivo di SetAlarm identifica l'allarme dagli altri allarmi nel modulo e viene utilizzato per farvi riferimento (principalmente nella definizione HigherPrioAlarm ). Class Nome della classe di allarme con la quale verrà creato l'allarme. Se questa classe di allarme esiste già nell'applicazione, l'allarme verrà creato in questa classe. Se questa classe non esiste viene ricercato un oggetto template classe allarme, che deve essere presente nel file POU visualizzazione. Se non viene trovato alcun oggetto modello di classe di allarme appropriato, viene emesso un errore durante la scansione del modulo. Message ID (del modulo TextListenName.TextListenEintragID ) di una voce dell'elenco testi per il testo dell'allarme Il messaggio a cui fa riferimento l'ID può contenere gli stessi segnaposto del testo in una configurazione di allarme. Ad esempio i segnaposto come LATCH1 O LATCH2 può essere utilizzata Se non è possibile trovare una determinata voce dell'elenco di testi, durante la scansione viene emesso un avviso. Corrisponde a Messaggio impostazione nel Gruppo allarme oggetto. LatchVar1 LatchVar2 Variabili segnaposto Nel caso attuale degli allarmi specifici del modulo, le variabili possono essere specificate solo direttamente dal blocco funzione del modulo (proprio come le variabili vengono specificate nella dichiarazione del modulo, ad esempio, i parametri) Corrisponde alle impostazioni Variabile di blocco 1 \/ Latch variabile 2 per i segnaposto <LATCH1> \/ <LATCH2> nel Gruppo allarme oggetto. Deactivation Variabile di disattivazione ( BOOL ). TRUE : Disattiva l'allarme definito, in cui è possibile utilizzare solo le variabili dei blocchi funzione del modulo. Se il tipo della variabile immessa non lo è BOOL , durante la scansione viene generato un errore Corrisponde a Disattivazione impostazione nel Gruppo allarme oggetto. PendingTime Tempo di attesa minimo. Definisce l'intervallo di tempo prima che l'allarme si attivi effettivamente dopo aver raggiunto i suoi limiti. Esempio: TIME#5S Corrisponde all'impostazione minimo tempo in sospeso nel Gruppo allarme oggetto. PendingTimeParameter Parametro per impostare il tempo minimo di attesa Il valore assegnato al parametro è una stringa che può essere interpretata come tempo. O anche come espressione composta da parametri del modulo e valori letterali temporali. Esempio: TIME#5S 'NoVar' 'WithVar' 'WithVar - NoVar + TIME#5S' HigherPrioAlarm ID degli allarmi con priorità più alta Per identificare l'allarme sotto il quale dovrebbe essere classificato l'allarme attuale, un ID target di a SetAlarm è specificata la sezione per gli allarmi del modulo esistente. Per trovare il SetAlarm sezione con l'ID di destinazione corrispondente, viene eseguita una ricerca gerarchica dal proprio modulo verso l'alto nelle istanze del modulo genitore per abbinare gli ID tra le dichiarazioni di allarme. Se non viene trovato alcun allarme genitore corrispondente, viene emesso un errore durante il controllo del generatore Corrisponde all'impostazione Prezzo più alto. allarme nel Gruppo allarme oggetto. ModuleCalls Per la gestione degli allarmi specifici del modulo, gli FB del modulo possono offrire interfacce specifiche che possono essere richiamate se si verifica un allarme del modulo. I flag definiscono in quali casi ciò accadrà. Disponibile ModuleCallFlags : NONE : Non verranno effettuate chiamate THIS : Verrà effettuata una chiamata per gli allarmi del modulo presente PARENTS : Verrà effettuata una chiamata a tutti i moduli principali del modulo presente ALL : Verrà effettuata una chiamata a tutti i moduli Gli FB del modulo che verranno chiamati da questo flag devono implementare il file IModuleAlarming interfaccia. La chiamata viene eseguita da ConsumeModuleAlarm funzione di questa interfaccia Se la PARENTS è stato impostato un flag per un modulo di livello superiore, viene visualizzato un avviso se viene eseguita una scansione (perché questo flag non esiste per i moduli di livello superiore). SEC Messages La sottosezione gestisce la stessa attività di Message parametro, ma consente più messaggi per un allarme. Per ragioni di compatibilità il (vecchio) parametro Message è ancora valido. Il messaggio può contenere gli stessi segnaposto del testo vero e proprio in una configurazione di allarme. Ciò significa che anche i segnaposto come <LATCH1> E <LATCH2> può essere utilizzata. Se non è possibile trovare una determinata voce dell'elenco di testi, durante la scansione viene emesso un avviso. Messages : testo di allarme sotto forma di voce di un elenco di testi (del formato TextListenName.TextListenEintragID ) Number : Colonna nella tabella degli allarmi in cui viene visualizzato il messaggio. SEC LatchVar Variabili di latch. In questa sezione è possibile definire fino a 10 variabili latch. Se, oltre a questa sezione, LatchVar1 O LatchVar2 è definita, verrà utilizzata la variabile di questa sezione. LatchVar : Variabile di blocco Number : Numero per identificare la variabile latch. SEC UpperLimit SEC LowerLimit Condizioni di allarme per gli allarmi che si attivano se vengono superati i limiti superiori o inferiori. La sezione può verificarsi solo una volta sotto il SEC SetAlarm sezione. In caso contrario verrà emesso un errore durante la scansione. Expression : espressione o valore IEC testato. Nelle espressioni si possono utilizzare variabili locali degli FB del modulo nonché costanti globali. IncludeBorder : TRUE corrisponde a <= ( UpperLimit ) O >= ( LowerLimit ). FALSE corrisponde a < ( UpperLimit ) O > ( LowerLimit ). UpperExpresssion , LowerExpresssion : espressione o valore IEC rispetto al quale Espressione è testato. Nelle espressioni si possono utilizzare variabili locali degli FB del modulo nonché costanti globali. Hysteresis : Isteresi di allarme in %. Corrisponde alle impostazioni Limite superiore \/ Limite inferiore per i tipi di osservazione in Gruppo allarme oggetto. SEC InsideRange SEC OutsideRange Condizioni di allarme per gli allarmi che si attivano se un'espressione è all'interno o all'esterno di un determinato intervallo di valori. La sezione può verificarsi solo una volta sotto il SEC SetAlarm sezione. In caso contrario verrà emesso un errore durante la scansione. Hysteresis : Isteresi di allarme in % Expression : espressione o valore IEC testato. Nelle espressioni si possono utilizzare variabili locali degli FB del modulo nonché costanti globali. AreaLow : Limiti inferiori dell'intervallo (valore o espressione IEC). Nelle espressioni si possono utilizzare variabili locali degli FB del modulo nonché costanti globali. LowIncludeBorder : Questo flag booleano determina se il limite inferiore stesso è compreso nell'intervallo di confronto (corrisponde a <= ) HighIncludeBorder : Questo flag booleano determina se il limite superiore stesso è compreso nell'intervallo di confronto (corrisponde a >= ) AreaHigh : Limiti superiori dell'intervallo (valore o espressione IEC). Nelle espressioni si possono utilizzare variabili locali degli FB del modulo nonché costanti globali. Corrisponde alle impostazioni All'interno del raggio d'azione \/ Fuori portata per i tipi di osservazione in Gruppo allarme oggetto. SEC Digital Allarme che viene generato se due espressioni vengono confrontate tra loro. La sezione può verificarsi solo una volta sotto il SEC SetAlarm sezione. In caso contrario verrà emesso un errore durante la scansione. Expression : espressione o valore IEC testato. Nelle espressioni si possono utilizzare variabili locali degli FB del modulo nonché costanti globali. Equal : TRUE \/ FALSE : L'espressione verrà controllata per verificare l'uguaglianza\/disuguaglianza. EqualsExpression : espressione o valore IEC con cui viene effettuato il controllo Expression . Nelle espressioni si possono utilizzare variabili locali degli FB del modulo nonché costanti globali. Corrisponde al tipo di osservazione Digitale nel Gruppo allarme oggetto. SEC Change Allarme che viene lanciato se un'espressione cambia il suo valore. La sezione può verificarsi solo una volta sotto il SEC SetAlarm sezione. In caso contrario verrà emesso un errore durante la scansione. Expression : espressione o valore IEC di cui viene verificata la presenza di modifiche. Nelle espressioni si possono utilizzare variabili locali degli FB del modulo nonché costanti globali. Corrisponde al tipo di osservazione Modifica nel Gruppo allarme oggetto. SEC Event Determina che la sezione dell'allarme corrente crei un allarme evento. Questo allarme può essere attivato dalla funzione RaiseModuleEvent() dal AC_Alarming biblioteca. " }, 
{ "title" : "Esempio ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_00a4549e191b4801c0a8646366566922", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Generatore di allarmi \/ Sezione: alg.Allarme \/ Esempio ", 
"snippet" : "Intervallo di valori SEC SetAlarm : ValueRange Class := Error; Message := TL.Alarm_Temperature; LatchVar1 := rAlarmValueLow; LatchVar2 := rAlarmValueHigh; ModuleCalls := THIS | PARENTS; SEC Messages : msg2 Message := TL.msg5_Message; Number := 5; END_SEC SEC OutsideRange Expression := 'rValue'; Area...", 
"body" : "Intervallo di valori SEC SetAlarm : ValueRange\n Class := Error;\n Message := TL.Alarm_Temperature;\n LatchVar1 := rAlarmValueLow;\n LatchVar2 := rAlarmValueHigh;\n ModuleCalls := THIS | PARENTS;\n SEC Messages : msg2\n Message := TL.msg5_Message;\n Number := 5;\n END_SEC\n SEC OutsideRange\n Expression := 'rValue';\n AreaLow := 'rAlarmValueLow';\n LowIncludeBorder := TRUE;\n HighIncludeBorder := TRUE;\n AreaHigh := 'rAlarmValueHigh';\n END_SEC\nEND_SEC Sezione: PendingTime SEC alg.Alarm\n\tSEC SetAlarm : NoVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'NoVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : WithVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : SimpleMath\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar - NoVar + TIME#5S';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\t\n\tSEC SetAlarm : NoParam\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTime := TIME#5S;\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\nEND_SEC " }, 
{ "title" : "Generatore di CFC ", 
"url" : "ac_cfc_generator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Generatore di CFC ", 
"snippet" : "Il generatore CFC crea automaticamente programmi CFC che possono contenere richiami di istanze FB dei moduli. I programmi CFC creati possono essere modificati. Le modifiche al programma persistono dopo ripetuti funzionamenti del generatore....", 
"body" : "Il generatore CFC crea automaticamente programmi CFC che possono contenere richiami di istanze FB dei moduli. I programmi CFC creati possono essere modificati. Le modifiche al programma persistono dopo ripetuti funzionamenti del generatore. " }, 
{ "title" : "Sezione: CFCCreazione ", 
"url" : "ac_module_fb_sec_cfccreation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Generatore di CFC \/ Sezione: CFCCreazione ", 
"snippet" : "Creazione CFC Questa sezione contiene tutte le sottosezioni interpretate dal generatore CFC. SEC cfc.CFCCreation SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE] StandardCallTask := <Task type>; \/\/optional: yes, type: ID CustomCallTask := <Task type>; \/\/optional: ye...", 
"body" : "Creazione CFC Questa sezione contiene tutte le sottosezioni interpretate dal generatore CFC. SEC cfc.CFCCreation\n\n SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE]\n StandardCallTask := <Task type>; \/\/optional: yes, type: ID\n CustomCallTask := <Task type>; \/\/optional: yes, type: ID\n ParentFolder := <create folder ID; \/\/optional: yes, type: ID\n END_SEC\n\n SEC CreateCFCModuleCall \/\/optional: yes, modifier [UPDATE]\n PreferredCFCProgram := <CFC program> \/\/optional: yes; type: FB type\n END_SEC\n\n SEC CreateCFCIOCall : <CFC IO call ID> \/\/ optional: yes; modifier [UPDATE]\n FB := <FB name>; \/\/ optional: no; type: FB type\n PreferredCFCProgram := <CFC program> \/\/ optional: yes; type: FB type\n FBInstanceBaseName := AInput; \/\/ optional: yes; type: identifier\n END_SEC\n\n SEC CreateFolder : <folder ID> \/\/optional: yes, modifier [UPDATE]\n ParentFolder := <folder name>; \/\/optional: yes, type: ID\n END_SEC\n\nEND_SEC I dettagli riguardanti la sintassi dei tipi di definizione sono descritti nella sezione Dichiarazione del modulo . " }, 
{ "title" : "Sottosezione: CreaProgrammaCFC ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_bddcc1eb1403f77cc0a8640e01907eda", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Generatore di CFC \/ Sezione: CFCCreazione \/ Sottosezione: CreaProgrammaCFC ", 
"snippet" : "Se una dichiarazione di modulo contiene una sezione cfc.CFCCreation compresa la sottosezione CreateCFCProgram viene creato un programma CFC per il tipo di modulo assegnato. Il programma CFC verrà inserito sotto l'applicazione di destinazione dell'istanza del modulo padre di livello superiore\/disacco...", 
"body" : "Se una dichiarazione di modulo contiene una sezione cfc.CFCCreation compresa la sottosezione CreateCFCProgram viene creato un programma CFC per il tipo di modulo assegnato. Il programma CFC verrà inserito sotto l'applicazione di destinazione dell'istanza del modulo padre di livello superiore\/disaccoppiato immediatamente superiore. La definizione CustomCallTask O StandardCallTask può essere utilizzato per definire il task che richiama il programma CFC da creare. Specifica: L'obiettivo della sezione CreateCFCProgram identifica i programmi CFC di questo tipo di modulo. Fondamentalmente un tipo di modulo può definire e creare più programmi CFC per la sua istanza di modulo. Una definizione per StandardCallTask O CustomCallTask deve esistere, ma è consentita una sola definizione. Per StandardCallTask i tre ID LOW , MEDIUM , E HIGH sono disponibili per definire il compito della successiva istanza del modulo genitore di livello superiore\/disaccoppiato. Per CustomCallTask sono disponibili tutti gli ID di destinazione utilizzati nella rispettiva attività personalizzata dell'istanza del modulo padre di livello superiore\/disaccoppiato successiva. In ParentFolder l'ID di destinazione del CreateFolder è possibile accedere alla sezione Successivamente il programma CFC creato viene aggiunto in questa sottocartella ( CreateFolder ). " }, 
{ "title" : "Sottosezione: CreateCFCModuleCall ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_4225fb301403f77dc0a8640e01bbc228", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Generatore di CFC \/ Sezione: CFCCreazione \/ Sottosezione: CreateCFCModuleCall ", 
"snippet" : "Se una dichiarazione di modulo contiene una sezione cfc.CFCCreation compresa la sottosezione CreateCFCProgram , nel programma CFC dell'istanza del modulo padre immediatamente superiore viene creato un richiamo dell'FB di istanza del modulo per il tipo di modulo assegnato. Specifica: PreferredCFCProg...", 
"body" : "Se una dichiarazione di modulo contiene una sezione cfc.CFCCreation compresa la sottosezione CreateCFCProgram , nel programma CFC dell'istanza del modulo padre immediatamente superiore viene creato un richiamo dell'FB di istanza del modulo per il tipo di modulo assegnato. Specifica: PreferredCFCProgram definisce il programma CFC da utilizzare se sono disponibili più programmi. " }, 
{ "title" : "Sottosezione: CreaCFCIOChiama ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_72ec1fc41403f77ec0a8640e00114156", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Generatore di CFC \/ Sezione: CFCCreazione \/ Sottosezione: CreaCFCIOChiama ", 
"snippet" : "La sezione viene utilizzata per contrassegnare gli I\/O di un tipo di modulo o una dichiarazione di modulo. Per questi I\/O vengono create istanze FB di un tipo definito. Successivamente vengono create le chiamate di queste istanze FB all'interno del programma CFC. Specifica: L'obiettivo del CreateCFC...", 
"body" : "La sezione viene utilizzata per contrassegnare gli I\/O di un tipo di modulo o una dichiarazione di modulo. Per questi I\/O vengono create istanze FB di un tipo definito. Successivamente vengono create le chiamate di queste istanze FB all'interno del programma CFC. Specifica: L'obiettivo del CreateCFCIOCall La sezione definisce l'ID I\/O del modulo per il quale verrà creato un FB I\/O globale. L'FB I\/O creato verrà richiamato in un programma CFC. FB definisce il tipo di blocco funzione che viene istanziato globalmente e richiamato per l'FB I\/O sopra menzionato. PreferredCFCProgram definisce il programma CFC da utilizzare se sono disponibili più programmi. FBInstanceBaseName definisce un \"nome base\" che viene utilizzato per la denominazione degli FB I\/O creati. Se la definizione non esiste, il nome dell'istanza del modulo viene utilizzato per l'istanza di base. " }, 
{ "title" : "Sottosezione: Crea cartella ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_a2dd1e181403f77ec0a8640e013c4468", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Dichiarazione del modulo \/ Generatore di CFC \/ Sezione: CFCCreazione \/ Sottosezione: Crea cartella ", 
"snippet" : "Questa sezione contiene i parametri per creare sottocartelle sotto il file AC_CFC_Programs cartella. Corrispondente a questo a ParentFolder può essere definito in CreateCFCProgram sezione. I programmi CFC vengono quindi generati nella directory creata da CreateFolder sezione. Le cartelle stesse poss...", 
"body" : "Questa sezione contiene i parametri per creare sottocartelle sotto il file AC_CFC_Programs cartella. Corrispondente a questo a ParentFolder può essere definito in CreateCFCProgram sezione. I programmi CFC vengono quindi generati nella directory creata da CreateFolder sezione. Le cartelle stesse possono definire a ParentFolder per specificare ulteriori sottocartelle e sottosottocartelle. Specifica: In ParentFolder l'ID di destinazione del CreateFolder è possibile accedere alla sezione Quindi la directory creata verrà creata in questa sottocartella ( CreateFolder ). Esempio SEC cfc.CFCCreation\n SEC CreateCFCProgram : Standard\n StandardCallTask := MEDIUM;\n ParentFolder := SubFolderUnderFolder;\n END_SEC\n SEC CreateFolder : SubFolderUnderFolder\n ParentFolder := SubFolder;\n END_SEC\nEND_SEC " }, 
{ "title" : "Libreria: AC_ModuleBase ", 
"url" : "ac_library.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase ", 
"snippet" : "La libreria base del modulo AC_ModuleBase fa parte del concetto di modulo di CODESYS Application Composer . Tutti i moduli sviluppati per essere disponibili nel configuratore dell'albero dei moduli devono essere derivati da questa libreria di base. Navigazione al livello superiore La funzione GetTop...", 
"body" : "La libreria base del modulo AC_ModuleBase fa parte del concetto di modulo di CODESYS Application Composer . Tutti i moduli sviluppati per essere disponibili nel configuratore dell'albero dei moduli devono essere derivati da questa libreria di base. Navigazione al livello superiore La funzione GetToplevelRange restituisce un'istanza di intervallo (tipo SiblingRange ) che fornisce l'accesso a tutte le istanze di primo livello. La funzione GetToplevelInstance restituisce il modulo di primo livello che è un antenato dell'istanza specificata. " }, 
{ "title" : "Nome dell'istanza ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f44958df1c1aa580c0a8640e00033aeb", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ Nome dell'istanza ", 
"snippet" : "La proprietà InstanceName della classe base restituisce una stringa che contiene il nome dell'istanza del modulo. Proprietà a IInstanceBase : PROPERTY InstanceName : STRING(255) Valore restituito: nome dell'istanza del modulo Le istanze proxy restituiscono il nome dell'istanza del modulo remoto....", 
"body" : "La proprietà InstanceName della classe base restituisce una stringa che contiene il nome dell'istanza del modulo. Proprietà a IInstanceBase : PROPERTY InstanceName : STRING(255) Valore restituito: nome dell'istanza del modulo Le istanze proxy restituiscono il nome dell'istanza del modulo remoto. " }, 
{ "title" : "Informazioni sul modulo ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_a581c7b51c1aa580c0a8640e012cbe1e", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ Informazioni sul modulo ", 
"snippet" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo : Questa proprietà restituisce un puntatore a un blocco funzione ModuleInfo con metodo PROPERTY ModuleType : STRING(255) . PROPERTY ModuleType : STRING(255) : questa proprietà restituisce il nome del modulo qualificato dallo spazio dei nomi della libreria ...", 
"body" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo : Questa proprietà restituisce un puntatore a un blocco funzione ModuleInfo con metodo PROPERTY ModuleType : STRING(255) . PROPERTY ModuleType : STRING(255) : questa proprietà restituisce il nome del modulo qualificato dallo spazio dei nomi della libreria dei moduli. (Lo spazio dei nomi è relativo al progetto principale.) " }, 
{ "title" : "Percorso dell'istanza ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_247de8bc1c1aa581c0a8640e00b26998", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ Percorso dell'istanza ", 
"snippet" : "La funzione GetInstancePath(IModule) restituisce il percorso dell'istanza di un'istanza del modulo. Il percorso dell'istanza viene creato concatenando i nomi delle istanze di tutti gli antenati, a partire dal modulo di primo livello fino all'istanza specificata. I nomi delle istanze sono separati da...", 
"body" : "La funzione GetInstancePath(IModule) restituisce il percorso dell'istanza di un'istanza del modulo. Il percorso dell'istanza viene creato concatenando i nomi delle istanze di tutti gli antenati, a partire dal modulo di primo livello fino all'istanza specificata. I nomi delle istanze sono separati da punti. Se il nome dell'istanza risultante è più lungo di 255 caratteri, viene restituita una stringa vuota. PROPERTY InstancePath : STRING(255) " }, 
{ "title" : "Navigazione piatta ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_acbf32a81c1aa581c0a8640e0039f1c2", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ Navigazione piatta ", 
"snippet" : "La funzione GetPrevModule(IModule) E GetNextModule(IModule) permette di saltare all'elemento precedente o successivo (se l'albero del modulo è considerato come un elenco semplice di istanze del modulo). I moduli vengono restituiti in profondità, prima del preordine dell'albero dei moduli. I riferime...", 
"body" : "La funzione GetPrevModule(IModule) E GetNextModule(IModule) permette di saltare all'elemento precedente o successivo (se l'albero del modulo è considerato come un elenco semplice di istanze del modulo). I moduli vengono restituiti in profondità, prima del preordine dell'albero dei moduli. I riferimenti ai moduli vengono saltati se non esiste alcun modulo precedente o successivo. In alternativa il blocco funzione DepthFirstRange può essere utilizzato che elenca tutte le istanze a partire da un'istanza specifica. La funzione GetDepthFirstRange restituisce un'istanza di blocco funzione intervallo (di tipo DepthFirstRange ) che elenca l'albero completo, a partire da una determinata istanza. " }, 
{ "title" : "Navigazione gerarchica ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_1e4f5ff21c1aa58ec0a8640e0059614e", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ Navigazione gerarchica ", 
"snippet" : "L'interfaccia IModuleTree permette di navigare nell'albero dei moduli. Un oggetto di questa interfaccia viene fornito a ciascun modulo utilizzando un puntatore a un'istanza di tipo MEnv . Questo puntatore viene passato alla funzione SetIdentification . I riferimenti ai moduli vengono saltati nella n...", 
"body" : "L'interfaccia IModuleTree permette di navigare nell'albero dei moduli. Un oggetto di questa interfaccia viene fornito a ciascun modulo utilizzando un puntatore a un'istanza di tipo MEnv . Questo puntatore viene passato alla funzione SetIdentification . I riferimenti ai moduli vengono saltati nella navigazione. L'ordine dei nodi figlio corrisponde all'ordine delle istanze del modulo nell'albero del modulo. GetParent(itfM : IModule) : IModule : IModule: restituisce l'istanza principale di una determinata istanza del modulo. Per le istanze del modulo di primo livello il valore restituito è 0. GetFirstChild(itfM : IModule) : IModule : Restituisce il primo figlio di una determinata istanza del modulo. Per le istanze del modulo senza figli il valore restituito è 0 NextSibling(itfM : IModule) : IModule : Restituisce il fratello successivo di un'istanza del modulo. Per le istanze del modulo senza ulteriori fratelli restituisce 0. Può essere chiamato anche per istanze di livello superiore. PrevSibling(itfM : IModule) : IModule : Restituisce il fratello precedente di un'istanza del modulo. Per le istanze del modulo senza fratelli precedenti restituisce 0. Può essere chiamato anche per istanze di livello superiore. GetFirstToplevelInstance() : IModule : Restituisce la prima istanza di primo livello dell'albero. Restituisce 0 se l'albero è vuoto. " }, 
{ "title" : "Navigazione verso antenati, fratelli e figli ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f30cbdfc1c1aa58fc0a8640e0098179e", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ Navigazione verso antenati, fratelli e figli ", 
"snippet" : "Il blocco funzione AncestorRange consente di accedere a tutti gli antenati di un'istanza, a partire dall'istanza stessa. Il blocco funzione SiblingRange permette di accedere a tutti i successivi fratelli di un'istanza nell'albero dei moduli, a partire dall'istanza stessa. La funzione GetChildRange r...", 
"body" : "Il blocco funzione AncestorRange consente di accedere a tutti gli antenati di un'istanza, a partire dall'istanza stessa. Il blocco funzione SiblingRange permette di accedere a tutti i successivi fratelli di un'istanza nell'albero dei moduli, a partire dall'istanza stessa. La funzione GetChildRange restituisce un elemento di intervallo (tipo SiblingRange ) di tutti i figli di un'istanza. " }, 
{ "title" : "Protocollo di messaggio affidabile (RMP) ", 
"url" : "ac_reliable_message_protocol.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ Protocollo di messaggio affidabile (RMP) ", 
"snippet" : "Il protocollo di messaggio affidabile viene utilizzato per inviare messaggi da un'istanza del modulo a un'altra. Questa comunicazione può avvenire tra applicazioni. Pertanto viene creata un'istanza del gestore RMP per ciascuna applicazione. Specificazione dell'indirizzamento: Ciascun partner possied...", 
"body" : "Il protocollo di messaggio affidabile viene utilizzato per inviare messaggi da un'istanza del modulo a un'altra. Questa comunicazione può avvenire tra applicazioni. Pertanto viene creata un'istanza del gestore RMP per ciascuna applicazione. Specificazione dell'indirizzamento: Ciascun partner possiede un ID univoco a 32 bit, che consiste in una parola alta (bit 16–31) per l'ID dell'applicazione e una parola bassa (bit 0–15) per l'ID locale. Ogni ID (32 bit) deve essere univoco: le singole parole (low word o high word) dell'ID possono essere utilizzate più di una volta. L'ID dell'applicazione che richiama l'istanza deve essere definito nella parola alta dell'istanza. Convenzioni di denominazione per le variabili: udi<xxx>ID : ID completo del modulo composto da ID applicazione e ID modulo locale ui<xxx>AppID : ID dell'applicazione (16 bit), parola alta dell'ID completo ui<xxx>ModuleID : ID del modulo locale (16 bit), parola bassa dell'ID completo " }, 
{ "title" : "IRMPService ", 
"url" : "ac_rmp_irmpservice.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ IRMPService ", 
"snippet" : "Metodi e proprietà dell'interfaccia IRMPService . Proprietà: LocalAppID PROPERTY LocalAppID : UINT (get) Questa proprietà descrive l'indirizzo dell'applicazione locale. (La parola chiave dell'ID di comunicazione delle istanze del modulo di questa applicazione.)...", 
"body" : "Metodi e proprietà dell'interfaccia IRMPService . Proprietà: LocalAppID PROPERTY LocalAppID : UINT (get) Questa proprietà descrive l'indirizzo dell'applicazione locale. (La parola chiave dell'ID di comunicazione delle istanze del modulo di questa applicazione.) " }, 
{ "title" : "Metodo: IsMessageSent ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_538e8d066de1851ec0a8652001725d6d", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ IRMPService \/ Metodo: IsMessageSent ", 
"snippet" : "METHOD IsMessageSent : BOOL VAR_INPUT uiHandle: UINT; END_VAR Questo metodo controlla se un messaggio che è stato accodato con QueueSendMessage è stato inviato e riconosciuto. uiHandle è l'handle restituito da QueueSendMessage . Per questo verificare l'uso del blocco funzione RMPSendMessage è consig...", 
"body" : "METHOD IsMessageSent : BOOL\nVAR_INPUT\n uiHandle: UINT;\nEND_VAR Questo metodo controlla se un messaggio che è stato accodato con QueueSendMessage è stato inviato e riconosciuto. uiHandle è l'handle restituito da QueueSendMessage . Per questo verificare l'uso del blocco funzione RMPSendMessage è consigliato perché fornisce un'interfaccia di comando standardizzata. " }, 
{ "title" : "Metodo: QueueSendMessage ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_b6b7ed9d6de18513c0a8652000b31074", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ IRMPService \/ Metodo: QueueSendMessage ", 
"snippet" : "METHOD QueueSendMessage : UINT VAR_INPUT udiSenderID: UDINT; udiReceiverID: UDINT; tValidity: TIME; pmdData: POINTER TO ARRAY[0..63] OF BYTE; END_VAR Questo metodo aggiunge un messaggio da inviare nella coda di invio e restituisce un handle. Questo handle può essere utilizzato per verificare se la t...", 
"body" : "METHOD QueueSendMessage : UINT\nVAR_INPUT\n udiSenderID: UDINT;\n udiReceiverID: UDINT;\n tValidity: TIME;\n pmdData: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR Questo metodo aggiunge un messaggio da inviare nella coda di invio e restituisce un handle. Questo handle può essere utilizzato per verificare se la trasmissione ha avuto successo. Un valore restituito di 16#FFFF indica che il buffer è pieno e il messaggio non è stato trasmesso. Un valore restituito di 16#FFFE indica che il modulo ricevitore si trova nella stessa applicazione e che la trasmissione è avvenuta con successo. Per aggiungere un messaggio alla coda di invio utilizzare il blocco funzione RMPSendMessage è consigliato perché fornisce un'interfaccia di comando standardizzata. " }, 
{ "title" : "Metodo: ricevere ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_385683a56de1850cc0a8652000d330da", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ IRMPService \/ Metodo: ricevere ", 
"snippet" : "METHOD Receive : UDINT VAR_INPUT uiReceiverModuleID: UINT; pmd: POINTER TO ARRAY[0..63] OF BYTE; END_VAR Questo metodo viene chiamato da ogni modulo che è in grado di ricevere un messaggio. Prende il messaggio ricevuto più vecchio per uiReceiverID e lo riconosce. Se un messaggio non è disponibile, a...", 
"body" : "METHOD Receive : UDINT\nVAR_INPUT\n uiReceiverModuleID: UINT;\n pmd: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR Questo metodo viene chiamato da ogni modulo che è in grado di ricevere un messaggio. Prende il messaggio ricevuto più vecchio per uiReceiverID e lo riconosce. Se un messaggio non è disponibile, allora 16#FFFFFFFF viene restituito. Ritorna 16#FFFFFFFE se c'è almeno un messaggio in attesa del destinatario, se il messaggio più vecchio è attualmente bloccato da un'attività diversa. In tutti gli altri casi viene restituito l'indirizzo di comunicazione del mittente. " }, 
{ "title" : "RMPSendMessage ", 
"url" : "ac_rmp_sendmessage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ RMPSendMessage ", 
"snippet" : "Questo blocco funzione serve per inviare messaggi a qualsiasi istanza del modulo. L'indirizzo dell'istanza deve essere noto. Il comportamento delle variabili xExecute , xDone , xBusy , E xError è conforme alle “Linee guida per la progettazione delle biblioteche”. Questo documento fa parte del CODESY...", 
"body" : "Questo blocco funzione serve per inviare messaggi a qualsiasi istanza del modulo. L'indirizzo dell'istanza deve essere noto. Il comportamento delle variabili xExecute , xDone , xBusy , E xError è conforme alle “Linee guida per la progettazione delle biblioteche”. Questo documento fa parte del CODESYS installazione standard. " }, 
{ "title" : "FUNCTION_BLOCK: RMPSendMessage ", 
"url" : "ac_rmp_sendmessage.html#UUID-2d1f2b05-610c-bf06-e2fe-18d7e3819bbc_ac_rmp_sendmessage0", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ RMPSendMessage \/ FUNCTION_BLOCK: RMPSendMessage ", 
"snippet" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG VAR_IN_OUT mdData: ARRAY[0..63] OF BYTE; END_VAR VAR_INPUT itfrmp: IRMPService; xExecute: BOOL; udiReceiverID: UDINT; uiSenderModuleID: UINT; tValidity: TIME := t#1s; END_VAR VAR_OUTPUT xDone: BOOL; xBusy: BOOL; xError: BOOL; uiErrorID: UINT; END_VAR T...", 
"body" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG\nVAR_IN_OUT\n mdData: ARRAY[0..63] OF BYTE;\nEND_VAR\nVAR_INPUT\n itfrmp: IRMPService;\n xExecute: BOOL;\n udiReceiverID: UDINT;\n uiSenderModuleID: UINT;\n tValidity: TIME := t#1s;\nEND_VAR\nVAR_OUTPUT\n xDone: BOOL;\n xBusy: BOOL;\n xError: BOOL;\n uiErrorID: UINT;\nEND_VAR Tenere presente che il lavoro del blocco funzione viene concluso con successo non appena viene confermata la ricezione del messaggio nell'RMPService del lato opposto. Ciò non significa necessariamente che il messaggio abbia raggiunto l'interfaccia effettiva del modulo ricevitore. In mdData , i dati da inviare verranno trasferiti. udiReceiverID definisce l'ID del destinatario. rmp definisce l'istanza RMPService locale. tValidity definisce il periodo di convalida del messaggio. Vengono controllate le seguenti cose: La durata fino all'invio del messaggio non deve superare tValidity (altrimenti verrà creato un messaggio di errore). Il tempo necessario per la ricezione del messaggio da parte del destinatario della parte opposta non deve essere superiore tValidity (altrimenti il messaggio verrà cancellato). Potrebbero verificarsi i seguenti errori che verranno restituiti uiErrorID : Il buffer di invio è pieno; si consiglia di inviare nuovamente in un secondo momento. Il messaggio non verrà cancellato dal buffer di invio. I motivi possono essere un trasferimento lento, una connessione interrotta o un buffer di ricezione pieno sul lato opposto. L'applicazione a cui viene inviato il messaggio non è connessa a questa applicazione. In questo caso la trasmissione dei dati non è possibile. " }, 
{ "title" : "Debug ", 
"url" : "ac_rmp_debugging.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Editor delle dichiarazioni del modulo \/ Libreria: AC_ModuleBase \/ Debug ", 
"snippet" : "La variabile globale g_AC_RMP_xDiagLog può essere utilizzato per abilitare il meccanismo di registrazione. Questo meccanismo registra tutti gli eventi di invio e di ricezione e registra la creazione e l'eliminazione di un messaggio in una coda del log standard. Inoltre, tutti gli eventi e gli errori...", 
"body" : "La variabile globale g_AC_RMP_xDiagLog può essere utilizzato per abilitare il meccanismo di registrazione. Questo meccanismo registra tutti gli eventi di invio e di ricezione e registra la creazione e l'eliminazione di un messaggio in una coda del log standard. Inoltre, tutti gli eventi e gli errori imprevisti vengono scritti nel registro standard. " }
]
$(document).trigger('search.ready');
});