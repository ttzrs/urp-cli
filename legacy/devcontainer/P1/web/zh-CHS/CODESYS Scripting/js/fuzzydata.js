$(document).ready(function () {indexDict['zh-CHS'] = [{ "title" : "CODESYS Scripting ", 
"url" : "_script_start_page.html", 
"breadcrumbs" : "CODESYS Scripting \/ CODESYS Scripting ", 
"snippet" : "CODESYS Scripting 允许您自动执行命令或复杂的程序操作 CODESYS ，否则需要手动单击鼠标并在 CODESYS 用户界面。为此，基于 (Iron)Python 的脚本可以从 CODESYS 用户界面（命令或配置的工具栏）或从 Windows 命令行。...", 
"body" : "CODESYS Scripting 允许您自动执行命令或复杂的程序操作 CODESYS ，否则需要手动单击鼠标并在 CODESYS 用户界面。为此，基于 (Iron)Python 的脚本可以从 CODESYS 用户界面（命令或配置的工具栏）或从 Windows 命令行。 " }, 
{ "title" : "编写脚本 CODESYS ", 
"url" : "_script_scripting_with_codesys.html", 
"breadcrumbs" : "CODESYS Scripting \/ 编写脚本 CODESYS ", 
"snippet" : "在中使用脚本功能 CODESYS ，您可以自动执行命令或复杂的程序操作，否则需要手动单击鼠标并在 CODESYS 用户界面。为此，可以创建基于 (Iron)Python 的脚本并从 CODESYS 用户界面（命令或配置的工具栏）或从 Windows 命令行。...", 
"body" : "在中使用脚本功能 CODESYS ，您可以自动执行命令或复杂的程序操作，否则需要手动单击鼠标并在 CODESYS 用户界面。为此，可以创建基于 (Iron)Python 的脚本并从 CODESYS 用户界面（命令或配置的工具栏）或从 Windows 命令行。 " }, 
{ "title" : "用例示例 ", 
"url" : "_script_scripting_with_codesys.html#UUID-77ae130a-b850-0395-99ae-009cc961710d_section-idm4609304796288033359653439539", 
"breadcrumbs" : "CODESYS Scripting \/ 编写脚本 CODESYS \/ 用例示例 ", 
"snippet" : "整合 CODESYS 在自动构建服务器环境中 持续集成 (CI) 持续交付 (CD) 持续测试 与第三方软件集成 代码生成器 创建针对特定机器配置定制的项目 创建文档 库的更新 发布过程中项目信息的设置 自动测试 主要与 CODESYS Test Manager 通过监控 API 输出变量...", 
"body" : "整合 CODESYS 在自动构建服务器环境中 持续集成 (CI) 持续交付 (CD) 持续测试 与第三方软件集成 代码生成器 创建针对特定机器配置定制的项目 创建文档 库的更新 发布过程中项目信息的设置 自动测试 主要与 CODESYS Test Manager 通过监控 API 输出变量 " }, 
{ "title" : "脚本语言、脚本编辑器 ", 
"url" : "_script_scripting_with_codesys.html#UUID-77ae130a-b850-0395-99ae-009cc961710d_section-idm4585068348627233359656664727", 
"breadcrumbs" : "CODESYS Scripting \/ 编写脚本 CODESYS \/ 脚本语言、脚本编辑器 ", 
"snippet" : "这 CODESYS 脚本语言是模块化的，基于 IronPython。为此， CODESYS ScriptEngine 组件将 IronPython 解释器与 CODESYS 开发环境。然后您可以使用广泛的 Python 框架库，其中包括网络中的文件访问等等。 CODESYS 还没有包含自己的 Python 编辑器。使用任何文本编辑器或 Python 编辑器创建脚本。 有关详细信息，请参阅： 创建 Python 脚本...", 
"body" : "这 CODESYS 脚本语言是模块化的，基于 IronPython。为此， CODESYS ScriptEngine 组件将 IronPython 解释器与 CODESYS 开发环境。然后您可以使用广泛的 Python 框架库，其中包括网络中的文件访问等等。 CODESYS 还没有包含自己的 Python 编辑器。使用任何文本编辑器或 Python 编辑器创建脚本。 有关详细信息，请参阅： 创建 Python 脚本 " }, 
{ "title" : "ScriptEngine 的架构，扩展的可能性 ", 
"url" : "_script_scripting_with_codesys.html#UUID-77ae130a-b850-0395-99ae-009cc961710d_section-idm4609304567108833359657280777", 
"breadcrumbs" : "CODESYS Scripting \/ 编写脚本 CODESYS \/ ScriptEngine 的架构，扩展的可能性 ", 
"snippet" : "(Iron)Python 脚本语言用于 CODESYS 允许访问 CODESYS Scripting 用于控制的 API CODESYS 过程。此外，它还允许用户有效地应用 Python 标准库和第三方 Python 模块，以及第三方 .NET 框架库和 .NET 程序集。 用户可以从菜单命令或配置的工具栏中执行脚本 CODESYS 界面或从 Windows 命令行。附加组件，例如 CODESYS Test Manager 还提供了执行脚本的方法。 借助自动化平台 API， ScriptEngine API 可以扩展。这方面的例子是 CODESYS Test Manager 和 CODESYS...", 
"body" : "(Iron)Python 脚本语言用于 CODESYS 允许访问 CODESYS Scripting 用于控制的 API CODESYS 过程。此外，它还允许用户有效地应用 Python 标准库和第三方 Python 模块，以及第三方 .NET 框架库和 .NET 程序集。 用户可以从菜单命令或配置的工具栏中执行脚本 CODESYS 界面或从 Windows 命令行。附加组件，例如 CODESYS Test Manager 还提供了执行脚本的方法。 借助自动化平台 API， ScriptEngine API 可以扩展。这方面的例子是 CODESYS Test Manager 和 CODESYS SVN .两者都提供自己的对象和方法作为脚本 API 的扩展。除此之外 CODESYS Test Manager 允许在测试用例中执行脚本。有关详细信息，请参阅附加组件的相应 API 文档。 注册自动化平台用户将在以下位置找到更多信息 CODESYS 开发者网络。 欲了解更多信息，请参阅： CODESYS 脚本 API " }, 
{ "title" : "执行脚本 ", 
"url" : "_cds_executing_scripts.html", 
"breadcrumbs" : "CODESYS Scripting \/ 执行脚本 ", 
"snippet" : "您可以执行 Python 脚本文件 (<file name>.py)，其中包含一系列用于激活的命令 CODESYS 功能，通过以下方式： 在里面 CODESYS 通过在用户界面中的命令 工具 → 脚本 菜单 来自 CODESYS 通过定制的、配置的工具栏的用户界面 从 Windows 命令行...", 
"body" : "您可以执行 Python 脚本文件 (<file name>.py)，其中包含一系列用于激活的命令 CODESYS 功能，通过以下方式： 在里面 CODESYS 通过在用户界面中的命令 工具 → 脚本 菜单 来自 CODESYS 通过定制的、配置的工具栏的用户界面 从 Windows 命令行 " }, 
{ "title" : "从菜单命令调用脚本 ", 
"url" : "_cds_starting_script_via_menu_command.html", 
"breadcrumbs" : "CODESYS Scripting \/ 执行脚本 \/ 从菜单命令调用脚本 ", 
"snippet" : "要求：有效的 Python 脚本文件 <file name>.py 位于文件系统中。这 CODESYS 用户界面打开。 （可选）要监视脚本中使用的各个命令的处理，请单击 工具 → 脚本 → 启用脚本跟踪 . 在 CODESYS ， 点击 工具 → 脚本 → 执行脚本文件 . 脚本中的语句被执行，如果脚本跟踪被激活，则在消息视图中列出。...", 
"body" : "要求：有效的 Python 脚本文件 <file name>.py 位于文件系统中。这 CODESYS 用户界面打开。 （可选）要监视脚本中使用的各个命令的处理，请单击 工具 → 脚本 → 启用脚本跟踪 . 在 CODESYS ， 点击 工具 → 脚本 → 执行脚本文件 . 脚本中的语句被执行，如果脚本跟踪被激活，则在消息视图中列出。 " }, 
{ "title" : "从命令行启动脚本 ", 
"url" : "_cds_starting_script_via_command_line.html", 
"breadcrumbs" : "CODESYS Scripting \/ 执行脚本 \/ 从命令行启动脚本 ", 
"snippet" : "要求：有效的 Python 脚本文件 <file name>.py 位于文件系统中。 使用命令创建CMD文件 start ， 这 CODESYS 开始， 并且有选择 --运行脚本 调用脚本文件。 还有其他选择，例如 --noUI ，如果 CODESYS 不应打开用户界面。 打开 Windows 窗口 命令提示符 并启动CMD文件。 您可以将带有附加信息的参数传递给脚本。Python 脚本可以使用 sys.argv[] 列表。第一个元素（索引 0）始终是执行的 Python 脚本的名称或路径，后面跟着“实际”参数。（这类似于 argc \/ argv 在 C.) 此外，脚本还可以访问之前设置的环境...", 
"body" : "要求：有效的 Python 脚本文件 <file name>.py 位于文件系统中。 使用命令创建CMD文件 start ， 这 CODESYS 开始， 并且有选择 --运行脚本 调用脚本文件。 还有其他选择，例如 --noUI ，如果 CODESYS 不应打开用户界面。 打开 Windows 窗口 命令提示符 并启动CMD文件。 您可以将带有附加信息的参数传递给脚本。Python 脚本可以使用 sys.argv[] 列表。第一个元素（索引 0）始终是执行的 Python 脚本的名称或路径，后面跟着“实际”参数。（这类似于 argc \/ argv 在 C.) 此外，脚本还可以访问之前设置的环境变量 CODESYS 使用相应的 Python 或 .NET API 启动。 例子 您有一个 CMD 文件（批处理文件） argvtestbat.cmd 包含以下内容（全部在一行上）。 \"C:\\Program Files (x86)\\CODESYS 3.5.17.0\\CODESYS\\Common\\CODESYS.exe\" --profile=\"CODESYS V3.5 SP17\" --runscript=\"D:\\Dokumente\\Scripting\\ArgvTestScript.py\" --scriptargs:'username password 3.14 \"path=\\\"C:\\temp\\\\\\\"\"' --noUI 您有一个匹配的脚本文件 ArgvTestScript.py . from __future__ import print_function\n\nimport sys\nprint(\"sys.argv: \",\n len(sys.argv),\n \" elements:\")\n\nfor arg in sys.argv:\n print(\" - \", arg) 现在当你执行 CMD 文件时， CODESYS 启动并执行脚本而不打开 CODESYS 主窗口。然后 CODESYS 退出： 有关所有可能的命令行参数的完整参考，请参阅命令行界面的帮助页面 CODESYS 在“ --runscript “。 更多信息请参阅： 命令行界面，选项--runscript 有关 Python API 的信息，请参阅： https:\/\/docs.python.org\/2\/library\/os.html#process-parameters 有关 .NET API 的信息，请参阅： https:\/\/msdn.microsoft.com\/de-de\/library\/77zkk0b6%28v=vs.110%29.aspx " }, 
{ "title" : "从工具栏图标调用脚本 ", 
"url" : "_cds_executing_scripts_toolbar.html", 
"breadcrumbs" : "CODESYS Scripting \/ 执行脚本 \/ 从工具栏图标调用脚本 ", 
"snippet" : "您可以在 CODESYS 用户界面最多包含 32 个图标，用于调用脚本文件。为此，您需要一个 ICO 存储图标的文件，以及存储要调用的Python脚本的PY文件。图标的大小应为16x16像素。 在安装目录或程序文件目录下 CODESYS ，您创建一个名为 Script Commands 在该目录中，创建 config.json 配置文件。指定文件中每个图标的呼叫信息概要。这里最多可以配置 16 个图标。您还可以存储 ICO 和 PY 同一目录中的文件。 地点 < CODESYS installation directory>\\ CODESYS \\Script Commands Users\\<u...", 
"body" : "您可以在 CODESYS 用户界面最多包含 32 个图标，用于调用脚本文件。为此，您需要一个 ICO 存储图标的文件，以及存储要调用的Python脚本的PY文件。图标的大小应为16x16像素。 在安装目录或程序文件目录下 CODESYS ，您创建一个名为 Script Commands 在该目录中，创建 config.json 配置文件。指定文件中每个图标的呼叫信息概要。这里最多可以配置 16 个图标。您还可以存储 ICO 和 PY 同一目录中的文件。 地点 < CODESYS installation directory>\\ CODESYS \\Script Commands Users\\<username>\\AppData\\Local\\ CODESYS \\Script Commands 例子 Windows 10 上的默认安装 C:\\Program Files (x86)\\CODESYS 3.5.14.0\\CODESYS\\Script Commands\\\nC:\\Users\\r.smith\\AppData\\Local\\CODESYS\\Script Commands 如果你存储一个 config.json 在每个存储位置具有不同呼叫信息的文件，然后您可以配置多达 32 个不同的图标。 " }, 
{ "title" : "配置文件 ", 
"url" : "_cds_executing_scripts_toolbar.html#UUID-d4730f38-792f-45e5-df0f-405de3b2db0d_id_f3e55a0c9ba7f91c0a864630f70b315_id_601c55ce5de6a292c0a864634fa14fa4", 
"breadcrumbs" : "CODESYS Scripting \/ 执行脚本 \/ 从工具栏图标调用脚本 \/ 配置文件 ", 
"snippet" : "2个图标的配置文件概要 [ { <icon call information> }, { <last icon call information> } ] 通话信息概要 <icon call information> \"Name\": \"<tooltip of the symbol button>\", \"Desc\": \"<description of the symbol button>\", \"Icon\": \"<icon file name>\", \"Path\": \"<path of the script file>\" 通话信息 ¤\"\"Name\"\" 必需的 显示为符号工具提示 例子： ¤\"\"Nam...", 
"body" : "2个图标的配置文件概要 [\n {\n <icon call information>\n },\n {\n <last icon call information>\n }\n] 通话信息概要 <icon call information> \"Name\": \"<tooltip of the symbol button>\",\n\"Desc\": \"<description of the symbol button>\",\n\"Icon\": \"<icon file name>\",\n\"Path\": \"<path of the script file>\" 通话信息 ¤\"\"Name\"\" 必需的 显示为符号工具提示 例子： ¤\"\"Name\": \"Pause\"\" ¤\"\"Desc\"\" 选修的 评论图标 例子： ¤\"\"Desc\": \"Operation pause\"\" 注意：尚未显示在用户界面中 ¤\"\"Icon\"\" 必需的 文件路径： <directory path>\\<icon name>.ico 图标的 例子： ¤\"\"Icon\": \"pause.ico\"\" 提示：如果文件与 config.json 文件，那么文件名就足够了。 ¤\"\"Path\"\" 必需的 Python脚本的路径 <directory path>\\<script name>.ico 例子： ¤\"\"Path\": \"stop.py\"\" 提示：如果文件与 config.json 文件，那么文件名就足够了。 ¤\"\"Params\"\" 注意：这些参数目前未评估。 例子 文件 config.json [\n {\n \"Name\": \"Start\",\n \"Desc\": \"Starts processing\",\n \"Icon\": \"start.ico\",\n \"Path\": \"goon.py\"\n },\n {\n \"Name\": \"Pause\",\n \"Desc\": \"Pause operation\",\n \"Icon\": \"pause.ico\",\n \"Path\": \"stop.py\"\n },\n {\n \"Name\": \"Processing\",\n \"Desc\": \"Process again\",\n \"Icon\": \"VarStatSmall.ico\",\n \"Path\": \"process.py\"\n }\n] 以下文件位于 Script Commands ： config.json\ngoon.py\nstop.py\nprocess.py\nstart.ico\npause.ico\nVarStatSmall.ico " }, 
{ "title" : "为工具栏按钮创建脚本调用 ", 
"url" : "_cds_executing_scripts_toolbar.html#UUID-d4730f38-792f-45e5-df0f-405de3b2db0d_id_f3e55a0c9ba7f91c0a864630f70b315_id_85f8e6225de6a292c0a864634505d8e4", 
"breadcrumbs" : "CODESYS Scripting \/ 执行脚本 \/ 从工具栏图标调用脚本 \/ 为工具栏按钮创建脚本调用 ", 
"snippet" : "创建 Script Commands 存储位置之一中的文件夹。 C:\\Users\\<username>\\AppData\\Local\\CODESYS 在那里创建可执行的 Python 文件。 例子： 文件 copy.py print(\"The script COPY.PY is executed\") 文件 delete.py print(\"The script DELETE.PY is executed\") 创建 ICO 脚本的文件。 例子： Copy_before.ico , Copy_below.ico , CopyAll.ico 创建配置文件 config.json 那里。 文件夹 Use...", 
"body" : "创建 Script Commands 存储位置之一中的文件夹。 C:\\Users\\<username>\\AppData\\Local\\CODESYS 在那里创建可执行的 Python 文件。 例子： 文件 copy.py print(\"The script COPY.PY is executed\") 文件 delete.py print(\"The script DELETE.PY is executed\") 创建 ICO 脚本的文件。 例子： Copy_before.ico , Copy_below.ico , CopyAll.ico 创建配置文件 config.json 那里。 文件夹 Users\\<username>\\AppData\\Local\\CODESYS\\Script Commands 有以下内容： 打开 config.json 并添加概述的呼叫信息。 [\n {\n \"Name\": \"Copy Before\",\n \"Desc\": \"Copy something\",\n \"Icon\": \"Copy_before.ico\",\n \"Path\": \"copy.py\n },\n {\n \"Name\": \"Copy Below\",\n \"Desc\": \"Copy something\",\n \"Icon\": \"Copy_below.ico\",\n \"Path\": \"copy.py\"\n },\n {\n \"Name\": \"Copy All\",\n \"Desc\": \"Copy something\",\n \"Icon\": \"CopyAll.ico\",\n \"Path\": \"copy.py\"\n },\n {\n \"Name\": \"Delete\",\n \"Desc\": \"Delete something\",\n \"Icon\": \"Delete.ico\",\n \"Path\": \"delete.py\"\n }\n] 开始 CODESYS . 脚本文件、配置文件和符号文件在 工具 → 自定义 上的对话框 命令图标 选项卡，在 脚本引擎命令 类别。 打开对话框 工具 → 自定义 然后单击选项卡 工具栏 。 选择那里的空工具栏，然后单击 添加工具栏 按钮。 行编辑器在空工具栏上打开。 输入名称（例如： User defined toolbar ）。 自定义工具栏显示在 CODESYS 窗户。 添加最近导入的命令并关闭对话框。 单击其中一个图标。 以下输出显示在消息视图中。 " }, 
{ "title" : "限制 ", 
"url" : "_script_restrictions.html", 
"breadcrumbs" : "CODESYS Scripting \/ 执行脚本 \/ 限制 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "可重入脚本执行 ", 
"url" : "_script_restrictions.html#UUID-65e6bbcf-fe8b-d8f8-562f-2ca216185111_section-id235160169847221", 
"breadcrumbs" : "CODESYS Scripting \/ 执行脚本 \/ 限制 \/ 可重入脚本执行 ", 
"snippet" : "在 CODESYS ，执行一个 IronPython 脚本可能意味着执行另一个嵌套的 IronPython 脚本。例如，一个脚本通过 执行脚本 命令和 system.commands 接口用于使用不同的脚本再次调用该命令。同样，这种脚本可以调用该命令来创建 CODESYS Test Manager 脚本本身包含脚本测试操作。我们将这些场景称为“可重入脚本执行”。 虽然这些方案通常有效，但它们在消息内存和显示方面受到限制。每次执行新的脚本都会从 脚本 消息类别。换句话说，只有来自最深层嵌套脚本执行的消息才会显示，直到脚本完成。如果脚本是使用控制台消息记录器执行的，这也适用（ noUI ）。...", 
"body" : "在 CODESYS ，执行一个 IronPython 脚本可能意味着执行另一个嵌套的 IronPython 脚本。例如，一个脚本通过 执行脚本 命令和 system.commands 接口用于使用不同的脚本再次调用该命令。同样，这种脚本可以调用该命令来创建 CODESYS Test Manager 脚本本身包含脚本测试操作。我们将这些场景称为“可重入脚本执行”。 虽然这些方案通常有效，但它们在消息内存和显示方面受到限制。每次执行新的脚本都会从 脚本 消息类别。换句话说，只有来自最深层嵌套脚本执行的消息才会显示，直到脚本完成。如果脚本是使用控制台消息记录器执行的，这也适用（ noUI ）。 " }, 
{ "title" : "创建 Python 脚本 ", 
"url" : "_cds_creating_scripts.html", 
"breadcrumbs" : "CODESYS Scripting \/ 创建 Python 脚本 ", 
"snippet" : "Python 是一种动态语言。您可以从简单的线性编程风格（“批处理文件”）开始，然后添加必要且更强大的方法，例如条件、循环、函数、异常、类和模块。该语言的重点是简单而富有表现力的代码。 Python 在运行时更为典型，它使用自动垃圾收集器来保护程序员免受整个系统的意外损坏。 IronPython 是用于 .NET 的 Python 实现，允许完全访问 .NET 框架和类。 IronPython 解释器的实现基于 Python 版本 2.7。 Internet 上有各种免费手册和帮助页面。关于 IronPython 的介绍和详细介绍见以下链接。 http:\/\/forum.codesys.com\/...", 
"body" : "Python 是一种动态语言。您可以从简单的线性编程风格（“批处理文件”）开始，然后添加必要且更强大的方法，例如条件、循环、函数、异常、类和模块。该语言的重点是简单而富有表现力的代码。 Python 在运行时更为典型，它使用自动垃圾收集器来保护程序员免受整个系统的意外损坏。 IronPython 是用于 .NET 的 Python 实现，允许完全访问 .NET 框架和类。 IronPython 解释器的实现基于 Python 版本 2.7。 Internet 上有各种免费手册和帮助页面。关于 IronPython 的介绍和详细介绍见以下链接。 http:\/\/forum.codesys.com\/viewforum.php ：“脚本语言 Python...”区域中的 CODESYS 论坛 特别是对于 CODESYS - 具体问题 还包括一些例子 https:\/\/docs.python.org\/2\/tutorial\/index.html： : Python 官方文档中的 Python 教程 http:\/\/docs.python.org\/release\/2.7\/ : Python 2.7 的官方文档 http:\/\/wiki.python.org\/moin\/BeginnersGuide : 学习 IronPython 的有用手册 http:\/\/wiki.python.org\/moin\/GermanLanguage : 德语帮助页面的链接集合 http:\/\/stackoverflow.com\/ : 编程的一般社区 关于 (Iron)Python 的一般问题，不是 CODESYS -具体的 http:\/\/ironpython.net\/ : IronPython 主页 http:\/\/ironpython.net\/support\/ ：邮件列表、常见问题解答等。 https:\/\/gitter.im\/IronLanguages\/ironpython： : IronPython 开发者的聊天频道 版本与 Python V3.x 不兼容 Python 编程语言将很快在新版本 V3.x 中可用。一些较旧的程序模块已被删除。 CODESYS GmbH 正在计划更新到这个新版本。脚本开发人员应该考虑到这一点并相应地设计他们的脚本，例如使用表达式 from __future__ import print_function .您可以在以下位置找到有关此主题的更多信息 http:\/\/wiki.python.org\/moin\/Python2orPython3 和 http:\/\/docs.python.org\/release\/3.1.2\/whatsnew\/3.0.html " }, 
{ "title" : "Python 入门 CODESYS ", 
"url" : "_cds_python_first_steps.html", 
"breadcrumbs" : "CODESYS Scripting \/ 创建 Python 脚本 \/ Python 入门 CODESYS ", 
"snippet" : "请参阅下面的 Python 脚本的简单应用 CODESYS ： 在任何文本编辑器中，创建一个文本文件 hello.py 内容如下： print(\"Hello, automation!\") 开始 CODESYS 并点击 工具 → 脚本 → 执行脚本文件 .选择文件 hello.py 在文件系统中。 在消息视图中查看结果： 有关不同用例的 Python 脚本的更详细示例 CODESYS ，请参阅以下帮助页面。...", 
"body" : "请参阅下面的 Python 脚本的简单应用 CODESYS ： 在任何文本编辑器中，创建一个文本文件 hello.py 内容如下： print(\"Hello, automation!\") 开始 CODESYS 并点击 工具 → 脚本 → 执行脚本文件 .选择文件 hello.py 在文件系统中。 在消息视图中查看结果： 有关不同用例的 Python 脚本的更详细示例 CODESYS ，请参阅以下帮助页面。 " }, 
{ "title" : "Python 程序员关于 .NET API 文档的提示 ", 
"url" : "_cds_scripting_dotnet_api_docu.html", 
"breadcrumbs" : "CODESYS Scripting \/ 创建 Python 脚本 \/ Python 程序员关于 .NET API 文档的提示 ", 
"snippet" : "当前预发布的脚本接口文档是从底层 .NET 和 C# 源自动生成的。因此，文档中包含了一些 Python 程序员不熟悉的表达式。以下概述提供了一些关于如何从 Python 角度理解这些表达式的提示。 接口是一种契约，它告诉实现接口的类的实例它必须准备哪些成员（方法、属性）。在 IronPython 中，您可以通过从超类继承来在一个类中实现一个或多个 .NET 接口。如果接口需要某个方法但在类定义中不可用，则抛出异常。 （这 DeviceImportFromSvn.py 示例显示了一个实现 ImportReporter 界面。） .NET 中的每个参数和每个方法都是严格类型的。参数类型在参数名称...", 
"body" : "当前预发布的脚本接口文档是从底层 .NET 和 C# 源自动生成的。因此，文档中包含了一些 Python 程序员不熟悉的表达式。以下概述提供了一些关于如何从 Python 角度理解这些表达式的提示。 接口是一种契约，它告诉实现接口的类的实例它必须准备哪些成员（方法、属性）。在 IronPython 中，您可以通过从超类继承来在一个类中实现一个或多个 .NET 接口。如果接口需要某个方法但在类定义中不可用，则抛出异常。 （这 DeviceImportFromSvn.py 示例显示了一个实现 ImportReporter 界面。） .NET 中的每个参数和每个方法都是严格类型的。参数类型在参数名称前用一个空格字符分隔，方法返回值的类型在方法名称前用一个空格字符分隔。定义类（或接口）时，可以使用子类中的实例。没有返回值的方法被标记 void . 您可以重载方法。因此，同名的多个方法可以存在于一个类中。但是，参数的数量或类型必须不同。 IronPython 自动处理被调用的最合适的方法重载。 数据类型 int 对应于从 -2,147,483,648 到 2,147,483,647 的整数。 数据类型 bool 对应 Python 类型 bool ( True 和 False ）。 数据类型 string 对应于 Python 类型 str 或者 unicode ，它们在 IronPython 中是相同的。 这 IDictionary<object, object> 数据类型对应一个普通的 Python 字典。 IronPython 自动在 Python 和 .NET 数据类型之间进行转换。 当一个 T 类型继承自 IBaseObject<T> , 表示这个类型可以被其他插件扩展为额外的成员。此扩展类型作为参数或返回值的实际使用标记为 IExtendedObject<T> . 这 IEnumerable<T> 接口 T type 意味着您可以使用返回的每个 Python 序列（生成器、列表、元组等） T 类型值（或子类）。返回不兼容对象的序列，并在运行时抛出异常。 这 IList<T> 接口 T type 标识一个典型的列表，它保证只包含 type 的元素 T （或子类）。当尝试添加不兼容的对象时，会在运行时引发异常。 这 params T[] name 类型参数的 id T 对应Python机制 *name 对于变量参数列表。 在 Python 中，枚举 ( enum ) 不作为语言结构存在。其目的是为特定目的定义精确数量的常量值，例如星期几。从 IronPython 访问 .NET 枚举可以使用“Name.Member”，例如通过 OnlineChangeOption.Try . 在 Python 中模拟枚举也有不同的方法。 例如，请参阅： http:\/\/pypi.python.org\/pypi\/enum\/ 语法 T name { get; set; } 定义一个属性 name 作为名称和 T 作为类型。如果 set; 丢失，则该属性是只读的。在 Python 中，相应的构造是 @property 装饰师。 " }, 
{ "title" : "Python的基本语法（附示例） ", 
"url" : "_cds_python_basics.html", 
"breadcrumbs" : "CODESYS Scripting \/ 创建 Python 脚本 \/ Python的基本语法（附示例） ", 
"snippet" : "Python 类似于“C 家族”的语言，但有一些显着的差异和独特的属性。 Python 与 C 和 ST 等语言之间最明显的句法差异是 Python 解析器通过缩进识别块结构。没有 BEGIN\/END 或大括号 {} 识别块 IF\/ELSE 条件， FOR 和 WHILE 循环或函数。 评论开头 # 并延伸到行尾。在源代码的第一行和第二行，可以设置一个特殊的标记来声明文件的编码。如果不需要 ASCII 字符，我们建议您使用 UTF-8 作为编码。 出于调试目的，您使用 print 方便输出。随着 % 运算符，您可以实现类似于 C 函数的功能 printf() .输出显示在消息视图中 CODES...", 
"body" : "Python 类似于“C 家族”的语言，但有一些显着的差异和独特的属性。 Python 与 C 和 ST 等语言之间最明显的句法差异是 Python 解析器通过缩进识别块结构。没有 BEGIN\/END 或大括号 {} 识别块 IF\/ELSE 条件， FOR 和 WHILE 循环或函数。 评论开头 # 并延伸到行尾。在源代码的第一行和第二行，可以设置一个特殊的标记来声明文件的编码。如果不需要 ASCII 字符，我们建议您使用 UTF-8 作为编码。 出于调试目的，您使用 print 方便输出。随着 % 运算符，您可以实现类似于 C 函数的功能 printf() .输出显示在消息视图中 CODESYS . 例子： print # encoding:utf-8\n\n# defining a function with the parameter i\ndef do_something(i):\n # if branch\n if i>0:\n print(\"The value is: %i\" % i)\n sum += i\n print(\"The new sum is: %i\" % sum)\n\n # else if (optional, there can be none or several elif branches)\n elif i=0:\n print(\"The sum did not change: %i\" % sum)\n\n # and the final else branch (also optional).\n else:\n handle_error()\n\n# an endless while loop\nwhile True:\n print(\"I got stuck forever!\") 属于同一块的所有内容都必须缩进相同的距离。压痕的大小无关紧要。括号和大括号等元素的优先级高于缩进。因此，以下代码段是完全正确的，即使它是用“糟糕的编程风格”编写的： 示例：缩进 # warning: bad style below. Kids, don't try this at home!\nif foo >= bar:\n print(\"foobar\")\nelse:\n print(\n \"barfoo\"\n) 为避免歧义，您不应在文件中混合使用制表符和空格。 目前，在 Python 3 中混合制表符和空格 gilt 被视为语法错误。 官方 Python 样式指南建议使用四个空格的缩进，并包含一些好的和差的样式示例。 Python 教程提供了编码风格的总结。 Python 是“区分大小写”的，与 C 相似，与 ST 不同。关键字，例如 def , if , else ， 和 while , 必须是小写的（与 ST 规则相反：关键字是大写的）。两个标识符，例如“i”和“I”，也标识了两个不同的变量。 以下关键字在 Python 中是保留的，不允许用作变量、函数等的标识符： and | as | assert | break | class | continue | def | del | elif | else | except | exec | finally | for | from | global | if | import | in | is | lambda | not | or | pass | print | raise | return | try | while | with | yield . Python 3 定义了另外四个关键字： False | None | True | nonlocal .虽然前三个确实是新的，但前三个已经是 Python 2 中预定义的常量，不应用于任何其他目的。 有关更多信息，请参阅： Python 风格指南 和 Python 教程 字典 Python 还具有哈希表类型（也称为“hashmap”）。与列表相反，它可以使用任何元素（例如字符串）进行索引。它的构造函数是 dict() 并且它的文字用大括号声明 {} . 示例脚本 dictionaries.py 创建下面显示的输出。在最后一行，脚本以“KeyError”异常终止： 例子： dictionaries.py from __future__ import print_function\nprint(\"Testing dictionaries\")\n\n# Declare a dictionary with three entries, the third being a list\nd = {1: \"a\", 2: \"b\", \"my list\": [1, 2, 3]}\nprint(d)\n\n# print the value of the key 1\nprint(d[1])\n\n# remove the value with the key \"my list\"\ndel d[\"my list\"]\n\n# Add a value 4 with the key 3\nd[3] = 4\nprint(d)\n\n# The \"get\" method returns the second argument if the key cannot be found.\nprint(d.get(1, 42))\nprint(d.get(23, 42))\n\n# print all keys in the dictionary\nfor key in d:\n print(key)\n\n# index access for unknown keys will throw a \"KeyError\" exception!\nprint(d[23]) 结果输出： 然后在最后一行，脚本终止： 点击 细节 按钮查看堆栈跟踪。在这里你确定行号 27 和未知的钥匙 23 . " }, 
{ "title" : "变量和数据类型 ", 
"url" : "_cds_python_basics.html#UUID-79bbdd07-a0e2-5462-c006-9a8d8e57d7a4_id_a804f43d109a2a7c0a864630646739a_id_09876db5d11f819ac0a86463753788a7", 
"breadcrumbs" : "CODESYS Scripting \/ 创建 Python 脚本 \/ Python的基本语法（附示例） \/ 变量和数据类型 ", 
"snippet" : "Python 是一种功能强大的动态类型语言——所有类型信息都在运行时进行评估。变量持有对对象的引用，并且对象知道它的类型，而不是变量。当程序员试图执行一个不可能的操作时（例如，添加一个整数和一个字符串），Python 在运行时抛出一个异常。 因此，没有变量及其类型的声明。在 Python 中，创建变量只是为了给它们赋值。这在 C 和 ST 中完全不同，其中类型是强的和静态的。每个变量都声明了一个类型，并且在编译时编译器检查该类型和运算符是否被允许。 有关处理变量的信息，请参见以下示例： 示例：变量 # assign the integer 1 to the variable i (also \"...", 
"body" : "Python 是一种功能强大的动态类型语言——所有类型信息都在运行时进行评估。变量持有对对象的引用，并且对象知道它的类型，而不是变量。当程序员试图执行一个不可能的操作时（例如，添加一个整数和一个字符串），Python 在运行时抛出一个异常。 因此，没有变量及其类型的声明。在 Python 中，创建变量只是为了给它们赋值。这在 C 和 ST 中完全不同，其中类型是强的和静态的。每个变量都声明了一个类型，并且在编译时编译器检查该类型和运算符是否被允许。 有关处理变量的信息，请参见以下示例： 示例：变量 # assign the integer 1 to the variable i (also \"creates\" the variable\")\ni = 1\n\n# assign the string \"foobar\" to the variable s\ns = \"foobar\"\n\n# Add 5 to the integer i - this is equivalent to i = i + 5\ni += 5\n# i now holds the integer 6.\n\n# Try to add i and s - this will throw an exception when executed\n# TypeError: unsupported operand type(s) for +: 'int' and 'str'\nresult = i + s\n\n# variables can also be \"undeclared\" by deleting them.\n# Further access to the variable i will throw a NameError exception,\n# as the variable does not exist any more.\ndel i\n\ni += 5 # now throws an exception: NameError: name 'i' is not defined 所有现有变量仅引用一个值。 Python 中没有任何未分配或未初始化的变量。为了表示没有值，Python 提供了一个特殊的对象： None .在 C 或 ST 中，您将使用空指针。它的唯一目的是表达“这里没有价值”，虽然 None 实际上是该类的现有实例 NoneType . " }, 
{ "title" : "数值类型和浮点数 ", 
"url" : "_cds_python_basics.html#UUID-79bbdd07-a0e2-5462-c006-9a8d8e57d7a4_id_a804f43d109a2a7c0a864630646739a_id_bee8f824d11f819ac0a8646326bc8327", 
"breadcrumbs" : "CODESYS Scripting \/ 创建 Python 脚本 \/ Python的基本语法（附示例） \/ 数值类型和浮点数 ", 
"snippet" : "与 IEC 或 C 中的数十种整数类型相比，Python 中只有一种整数类型。 Python 中的整数类型没有固定的大小。相反，它们会根据需要增长，并且仅受可用内存的限制。 例子： Integers.py from __future__ import print_function i = 1 print(i) j = 0x1234 # hex number, is 16#1234 in IEC and 4660 in decimal k = 0o123 # octal number, is 8#123 in IEC and 83 decimal l = 0b101010 # binary nu...", 
"body" : "与 IEC 或 C 中的数十种整数类型相比，Python 中只有一种整数类型。 Python 中的整数类型没有固定的大小。相反，它们会根据需要增长，并且仅受可用内存的限制。 例子： Integers.py from __future__ import print_function\n\ni = 1\nprint(i)\n\nj = 0x1234 # hex number, is 16#1234 in IEC and 4660 in decimal\nk = 0o123 # octal number, is 8#123 in IEC and 83 decimal\nl = 0b101010 # binary number, is 2#101010 in IEC and 42 in decimal\nprint(j, k, l)\n\nm = (2 + 3)*10 # k is 50 now\nprint(m)\n\nn = 10 ** 100 # 10 to the power of 100\nprint(n) 结果输出： Python 中也只有一种浮点类型，类似于 IEC 数据类型 LREAL .它提供 64 位 IEEE 浮点运算。 语法在很大程度上类似于基于 C 的语言： 示例：浮点类型 # A simple float...\na = 123.456\n\n# A float containing the integral value 2\nb = 2.\n\n# Leading zeroes can be left off\nc = .3 # same as 0.3\n\n# Exponential \/ scientific representation\nd = -123e-5 两种特殊情况是 True 和 False ，定义布尔真值的两个常数。它们的行为类似于整数值 0 和 1 , 除非它们被转换为字符串并返回它们的名称。 例子： Booleans.py # booleans behave like integers, except when converted to strings.\n# The built-in function \"type\" can be used to query the type of a value.\nprint(\"True: \", True, type(True))\nprint(\"False: \", False, type(False))\nprint(\"1: \", 1, type(1))\nprint(\"False + 0: \", False + 0, type(False + 0))\nprint(\"True * 5: \", True * 5, type(True * 5)) 结果输出： " }, 
{ "title" : "字符串 ", 
"url" : "_cds_python_basics.html#UUID-79bbdd07-a0e2-5462-c006-9a8d8e57d7a4_id_a804f43d109a2a7c0a864630646739a_id_e6c6288bd11f819ac0a864637420628d", 
"breadcrumbs" : "CODESYS Scripting \/ 创建 Python 脚本 \/ Python的基本语法（附示例） \/ 字符串 ", 
"snippet" : "在 IronPython 中，字符串总是 Unicode 和任意长度。如果将它们包含在 ' 或者 \" .字符串也可以有三引号 \"\"\" 或者 ''' ，它允许多行字符串文字。 与 C 类似，可以通过反斜杠字符排除特殊字符。作为比较，美元符号 ( $ ) 在 IEC 中用于此目的。 还有一些原始字符串具有其他反斜杠规则。当字符串应该有文字反斜杠时，这很实用。示例：Windows 文件路径或正则表达式。 例子： Strings.py # encoding:utf-8 from __future__ import print_function a = \"a simple string\" b = 'an...", 
"body" : "在 IronPython 中，字符串总是 Unicode 和任意长度。如果将它们包含在 ' 或者 \" .字符串也可以有三引号 \"\"\" 或者 ''' ，它允许多行字符串文字。 与 C 类似，可以通过反斜杠字符排除特殊字符。作为比较，美元符号 ( $ ) 在 IEC 中用于此目的。 还有一些原始字符串具有其他反斜杠规则。当字符串应该有文字反斜杠时，这很实用。示例：Windows 文件路径或正则表达式。 例子： Strings.py # encoding:utf-8\nfrom __future__ import print_function\n\na = \"a simple string\"\nb = 'another string'\nc = \"strings may contain 'quotes' of the other type.\"\nd = \"multiple string literals\" ' are concatenated ' '''by the parser'''\ne = \"Escaping: quotes: \\\" \\' backslash: \\\\ newline: \\r\\n ascii code: \\x40\"\nf = \"\"\"triple-quoted strings may contain newlines, \"single\"\n'quotes' and '''multiquotes''' of the other type\"\"\"\ng = \"Üňíçǿđȩ is also possible: 北京, Москва, Αθήνα, القاهرة\"\nh = r\"c:\\raw\\strings\\retain\\backslashes.txt\"\n\n# we iterate over a sequence of all the variables defined above:\nfor i in (a,b,c,d,e,f,g,h):\n print(i) # prints the contents of the variable 结果输出： Python 没有字符类型。字符通过使用长度为 1 的字符串来表示。这样，通过字符串进行迭代，或在字符串中进行索引，将返回单个字符串。 " }, 
{ "title" : "列表和元组（数据集） ", 
"url" : "_cds_python_basics.html#UUID-79bbdd07-a0e2-5462-c006-9a8d8e57d7a4_id_a804f43d109a2a7c0a864630646739a_id_fbd5e6dfd11f819ac0a8646362c2834f", 
"breadcrumbs" : "CODESYS Scripting \/ 创建 Python 脚本 \/ Python的基本语法（附示例） \/ 列表和元组（数据集） ", 
"snippet" : "列表和元组基本上对应于 C 和 IEC 中的数组，但有一些明显的区别： 始终检查索引访问。访问具有无效索引的列表或元组会引发异常。 列表和元组都可以包含不同类型的元素（也可以包含其他列表和元组）。与 C 和 IEC 相比，数组只能包含单一类型的元素。 列表是动态的，可以随时添加、删除或替换元素。 元组是不可更改的：一旦创建了元组，就不能再修改它。 列表是用 list() 构造函数。作为替代方案，您可以使用括号 [] .元组是用 tuple() 构造函数或括号 () . 例子： list_tuples.py from __future__ import print_function print(...", 
"body" : "列表和元组基本上对应于 C 和 IEC 中的数组，但有一些明显的区别： 始终检查索引访问。访问具有无效索引的列表或元组会引发异常。 列表和元组都可以包含不同类型的元素（也可以包含其他列表和元组）。与 C 和 IEC 相比，数组只能包含单一类型的元素。 列表是动态的，可以随时添加、删除或替换元素。 元组是不可更改的：一旦创建了元组，就不能再修改它。 列表是用 list() 构造函数。作为替代方案，您可以使用括号 [] .元组是用 tuple() 构造函数或括号 () . 例子： list_tuples.py from __future__ import print_function\nprint(\"Testing tuples and lists\")\n\n# We define a tuple with the numbers from 1 to 10:\nt = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nprint(\"Tuple:\", t)\n\n# We can access the 6th element of the tuple.\n# As in C, index counting starts with 0.\nprint(\"Element 5:\", t[5])\n\n# Subscription is more powerful using the range syntax:\nprint(\"Range[2:5]:\", t[2:5]) # lower bound is inclusive, upper bound is exclusive.\nprint(\"Range[2::2]:\", t[2::2]) # start with 3rd element, and print every 2nd element.\nprint(\"Range[-3:-1]:\", t[-3:-1]) # Start with the 3rd last element, end just before the last element (upper bound is exclusive)\nprint(\"Range[::-1]:\", t[::-1]) # negative step with - print backwards\n\n# lists are similar to tuples...\nl = [11, 12, 13, \"8\", t] # contains mixed types: 3 integers, a string, and the tuple defined above.\nprint(\"List:\", l)\n\n# ... but elements can be added or removed dynamically.\nl.append(9) # Add a 9 to the list.\nprint(\"List with 9:\", l)\nprint(\"List Range[3:6:2]:\", l[3:6:2]) # print the 4th and 6th element.\n\ndel l[1] # remove the element at index 1, the 12.\nprint(\"Removed[1]:\", l)\ndel l[1:3] # Remove the elements at index 1 and 2, the 13 and the '8'.\nprint(\"Removed[1:3]:\", l) 结果输出： " }, 
{ "title" : "Python 控制结构（附示例） ", 
"url" : "_cds_python_control_structures.html", 
"breadcrumbs" : "CODESYS Scripting \/ 创建 Python 脚本 \/ Python 控制结构（附示例） ", 
"snippet" : "模块和标准库 在 IEC 中，您可以导入库以供其他编写的代码重用。作为一个挂件，在 Python 中有导入模块的可能性。 这 Python 标准库 包含许多用于不同目的的模块，例如： 字符串处理 日期和时间处理 收藏品 穿线 数学函数 文件处理 持久性 压缩和归档 数据库访问 加密服务 网络和互联网访问 发送电子邮件 要创建您自己的模块，请编写一个 Python 文件来定义您要提供的函数和类。将此文件保存到与我们的示例脚本相同的目录中。如果你命名文件 mymodule.py , 然后你可以用 import mymodule . 下面是导入和使用余弦函数和 pi 常数的示例 math 模块： 示...", 
"body" : "模块和标准库 在 IEC 中，您可以导入库以供其他编写的代码重用。作为一个挂件，在 Python 中有导入模块的可能性。 这 Python 标准库 包含许多用于不同目的的模块，例如： 字符串处理 日期和时间处理 收藏品 穿线 数学函数 文件处理 持久性 压缩和归档 数据库访问 加密服务 网络和互联网访问 发送电子邮件 要创建您自己的模块，请编写一个 Python 文件来定义您要提供的函数和类。将此文件保存到与我们的示例脚本相同的目录中。如果你命名文件 mymodule.py , 然后你可以用 import mymodule . 下面是导入和使用余弦函数和 pi 常数的示例 math 模块： 示例：导入数学函数 from math import cos, pi\n\nprint(pi) # prints 3.14159265359\n\nprint(cos(pi)) # prints -1.0 以下包含访问有关操作系统、Python 版本和解释器信息的更多示例： 更多导入示例 import os\nprint(os.environ[\"OS\"])\n\nfrom sys import platform, version, executable\nprint(platform)\nprint(version)\nprint(executable) 有一个特殊的模块 __future__ 用于激活新的语言功能。最重要的是，它在 Python 开发人员引入向后兼容的新功能时使用。这些功能必须用特殊的“ __future__ 进口”。我们在大多数示例脚本中使用的一个示例是激活新的幂语法 print 作为函数而不是语句。 示例：“__future__” # make print() a function instead of a statement\nfrom __future__ import print_function Python 文档提供了完整的 所有的清单 __future__ 进口 . 除了普通的 Python 模块，IronPython 代码还可以访问 .NET 程序集，就好像它们是 Python 模块一样。这将打开访问 .NET 框架类库 和第三方库。下面是一个示例，如何通过 Windows Forms 图书馆： 示例：打开 .NET 对话框 import clr\nclr.AddReference(\"System.Windows.Forms\")\nfrom System.Windows.Forms import MessageBox\n\nMessageBox.Show(\"Hello\") " }, 
{ "title" : "循环 ", 
"url" : "_cds_python_control_structures.html#UUID-41bf35cd-84fc-9964-0f0b-7fb9353165c8_id_b63866f1d12074a2c0a864632ac8f157_id_4f851aacd12e135fc0a8646365f686f8", 
"breadcrumbs" : "CODESYS Scripting \/ 创建 Python 脚本 \/ Python 控制结构（附示例） \/ 循环 ", 
"snippet" : "与 C 和 ST 相比， for Python 中的循环不计算循环变量，而是遍历一个序列。这种序列可以是“字典”、列表、元组、字符串中的字符或文件中的行。 下面的例子展示了一些 for 循环： 示例：loops.py from __future__ import print_function print(\"Enumerating over a simple list:\") for i in (1,2,3,4): print(i, end=\", \") # end= replaces the newline with \", \" print() # but we still need a newli...", 
"body" : "与 C 和 ST 相比， for Python 中的循环不计算循环变量，而是遍历一个序列。这种序列可以是“字典”、列表、元组、字符串中的字符或文件中的行。 下面的例子展示了一些 for 循环： 示例：loops.py from __future__ import print_function\n\nprint(\"Enumerating over a simple list:\")\nfor i in (1,2,3,4):\n print(i, end=\", \") # end= replaces the newline with \", \"\nprint() # but we still need a newline at the end of this case.\n\nprint(\"Enumerating over the characters in a string:\")\nfor i in \"CODESYS\": # characters are representet as strings of length 1.\n print(i, end=\", \")\nprint()\n\nprint(\"Enumerating over the integers 1 to 4:\")\nfor i in range(1, 5): # upper bound is exclusive.\n print(i, end=\", \")\nprint()\n\nprint(\"Enumerating using xrange:\")\nfor i in xrange(5): # xrange is similar to range, but needs less memory for large ranges.\n print(i, end=\", \")\nprint()\n\nprint(\"Enumerating including the item number:\")\nfor i, v in enumerate(\"CODESYS\"):\n print(i, v) 结果输出： 如果您需要除项目之外的索引或编号，那么您应该使用 enumerate 如示例脚本的最后一种情况所示。以下代码被认为是不良风格： 示例：不良风格 text = \"CODESYS\"\n\nfor i in range(len(text)): # BAD STYLE!\n v = text[i] # DON'T TRY THIS AT HOME!\n print(i, v) 除了 for 循环，Python 也有 while 与 C 和 ST 中的循环非常相似的循环： “while”循环示例 i = 0\nwhile i < 3;\n print(i)\n i += 1 注意：这个例子不是很实用。您更有可能使用 for 带范围的循环。 " }, 
{ "title" : "如果别的 ", 
"url" : "_cds_python_control_structures.html#UUID-41bf35cd-84fc-9964-0f0b-7fb9353165c8_id_b63866f1d12074a2c0a864632ac8f157_id_b0e45e92d12e135fc0a8646304f7c02b", 
"breadcrumbs" : "CODESYS Scripting \/ 创建 Python 脚本 \/ Python 控制结构（附示例） \/ 如果别的 ", 
"snippet" : "这 if\/else 构造类似于其他编程语言中的构造。这是一个简短的例子： 示例：“if_else.py” from __future__ import print_function i = int(system.ui.query_string(\"Please enter an integral number...\")) if i < 0: print(\"Your number was negative.\") elif i > 0: print(\"Your numer was positive.\") else: print(\"It seems your number was zero.\") 这 ...", 
"body" : "这 if\/else 构造类似于其他编程语言中的构造。这是一个简短的例子： 示例：“if_else.py” from __future__ import print_function\ni = int(system.ui.query_string(\"Please enter an integral number...\"))\nif i < 0:\n print(\"Your number was negative.\")\nelif i > 0:\n print(\"Your numer was positive.\")\nelse:\n print(\"It seems your number was zero.\") 这 else 分支是可选的，可以有零个、一个或多个 elif 分支机构。 " }, 
{ "title" : "函数、类和方法 ", 
"url" : "_cds_python_control_structures.html#UUID-41bf35cd-84fc-9964-0f0b-7fb9353165c8_id_b63866f1d12074a2c0a864632ac8f157_id_0db30903d12e135fc0a8646353ed05ef", 
"breadcrumbs" : "CODESYS Scripting \/ 创建 Python 脚本 \/ Python 控制结构（附示例） \/ 函数、类和方法 ", 
"snippet" : "Python 允许使用方法定义函数和类。具有方法的类基本上类似于 ST 中的功能块，或 C++、Java 或 C# 等语言中的类。但是，Python 不支持接口。 有关详细信息，请参阅 Python 文档以定义 职能 和 课程 . 示例：函数、类和方法 #defining a function with name sum and two parameters a and b: def sum(a, b): return a + b # we return the sum of a and b. # we can now call the function defined above: prin...", 
"body" : "Python 允许使用方法定义函数和类。具有方法的类基本上类似于 ST 中的功能块，或 C++、Java 或 C# 等语言中的类。但是，Python 不支持接口。 有关详细信息，请参阅 Python 文档以定义 职能 和 课程 . 示例：函数、类和方法 #defining a function with name sum and two parameters a and b:\ndef sum(a, b):\n return a + b # we return the sum of a and b.\n\n# we can now call the function defined above:\nprint(sum(5,7))\n\n# Now we define a class Foo:\nclass Foo:\n # The class gets a method \"bar\".\n # Note: for methods, the first parameter is always \"self\" and\n # points to the current instance. This is similar to \"this\" in\n # ST and other languages.\n def bar(self, a, b):\n print(\"bar(%s,%s)\" % (a,b))\n\n# We create an instance of the class:\nf = Foo()\n\n# We call the method bar on the instance.\nf.bar(\"some\", \"params\") " }, 
{ "title" : "IronPython 和 cPython 的比较 ", 
"url" : "_cds_ironpython_versus_cpython.html", 
"breadcrumbs" : "CODESYS Scripting \/ 创建 Python 脚本 \/ IronPython 和 cPython 的比较 ", 
"snippet" : "IronPython 和“标准”Python（“cPython”）之间存在一些小的差异和不兼容性。有些是 IronPython 中的直接错误，应该在以后的版本中删除。然而，其他的被认为是“实施细节”并将保留。其中一些是非常具有挑战性的话题。 对用户来说最明显的区别是字符串的处理。原始 cPython 有两种不同的字符串类型，用于“字节字符串”和“Unicode 字符串”。这个概念类似于 IEC 中的数据类型 STRING 和 WSTRING。 IronPython 只使用始终支持 Unicode 并在内部使用 UTF-16 的 .NET 字符串。然而，IronPython 实现了一个技巧来向程...", 
"body" : "IronPython 和“标准”Python（“cPython”）之间存在一些小的差异和不兼容性。有些是 IronPython 中的直接错误，应该在以后的版本中删除。然而，其他的被认为是“实施细节”并将保留。其中一些是非常具有挑战性的话题。 对用户来说最明显的区别是字符串的处理。原始 cPython 有两种不同的字符串类型，用于“字节字符串”和“Unicode 字符串”。这个概念类似于 IEC 中的数据类型 STRING 和 WSTRING。 IronPython 只使用始终支持 Unicode 并在内部使用 UTF-16 的 .NET 字符串。然而，IronPython 实现了一个技巧来向程序员隐藏与 cPython 的差异。 （有趣的是：对于新的 Python 版本 3，开发人员完全重新设计了他们的字符串处理。结果是一个更接近 IronPython 的模型。之后总是使用 Unicode 字符串，并且有一个单独的数据类型来处理原始字节） 用 C 编写的 Python 模块无法导入 IronPython，因为 cPython 使用与 IronPython 完全不同的内部数据结构。大多数标准库模块都在 IronPython 中重新实现。但是，一些模块（例如 TK 接口）是不可用的，只要它们没有显式移植到 IronPython。另一方面，IronPython 提供对 .NET 程序集的访问，包括 .NET 框架（如上所示），这足以弥补这一特性。 虽然 cPython 使用引用计数和确定性垃圾收集器来清理循环垃圾，但 IronPython 依赖于非确定性 .NET 垃圾收集器。在大多数情况下，这种差异并不重要。但是，当您从 Python 标准库或 .NET 框架打开文件或其他资源时，您应该确保稍后关闭它们。最好使用 with 使用 Python 上下文管理器或 .NET 的语句 IDisposable 实例。 有关更多信息，请参阅： 内容经理 和 .NET IDisposable " }, 
{ "title" : "使用脚本访问 CODESYS 功能 ", 
"url" : "_cds_access_cds_func_in_python_scripts.html", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 ", 
"snippet" : "所有对象和命令 CODESYS 提供的脚本也可在“ scriptengine \" Python 模块。每当脚本启动时，隐式 <code>from scriptengine import *<\/code> 结果。这样可以轻松访问 CODESYS 。但是，如果您的脚本导入需要访问的模块 CODESYS API，那么这些模块必须导入模块 scriptengine 他们自己。 下表列出了 Python 脚本中可用作入口点的主要对象（类别）。有关入口点的完整文档，请参阅 API 参考文档 CODESYS 脚本引擎： CODESYS 脚本 API 。 对象 描述 system 访问一般 CODESYS 功...", 
"body" : "所有对象和命令 CODESYS 提供的脚本也可在“ scriptengine \" Python 模块。每当脚本启动时，隐式 <code>from scriptengine import *<\/code> 结果。这样可以轻松访问 CODESYS 。但是，如果您的脚本导入需要访问的模块 CODESYS API，那么这些模块必须导入模块 scriptengine 他们自己。 下表列出了 Python 脚本中可用作入口点的主要对象（类别）。有关入口点的完整文档，请参阅 API 参考文档 CODESYS 脚本引擎： CODESYS 脚本 API 。 对象 描述 system 访问一般 CODESYS 功能 例子： 退出 CODESYS 处理通用用户界面 访问消息内存（包括编译器消息） 控制延迟和进度条 projects 访问 CODESYS 项目作为对象树，将三个导航器视图（设备、POU、模块）组合在一个项目树中 还允许加载、创建、保存和关闭项目 对于项目中的大多数对象，都有具有详细功能的特殊方法，例如编译、访问 ST POU、导出、导入、设备配置等。 online 访问在线功能 例子： 登录设备和应用程序 访问数据管理（用户名、密码） 网络扫描的性能 网关管理 librarymanager 允许管理库存储库以及查看、安装和删除库 device_repository 处理设备存储库；导入和导出设备描述 modulerepository 管理 CODESYS Application Composer 模块和 CODESYS Application Composer 存储库 请参阅以下具体示例脚本，了解访问方法 CODESYS 功能。有关详细信息，请参阅 CODESYS 脚本引擎： CODESYS 脚本 API 。 " }, 
{ "title" : "示例：打印当前项目的设备树 ", 
"url" : "_cds_access_cds_func_in_python_scripts.html#UUID-1ff21fc5-3512-c23c-3684-17e0341b37b6", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例：打印当前项目的设备树 ", 
"snippet" : "脚本 PrintDeviceTree.py 是项目导航的示例。它创建了打开项目中所有设备的分层显示输出。 加载包含一些设备对象的项目并执行脚本。 例子： PrintDeviceTree.py # encoding:utf-8 # We enable the new python 3 print syntax from __future__ import print_function # Prints out all devices in the currently open project. print(\"--- Printing the devices of the project: ---...", 
"body" : "脚本 PrintDeviceTree.py 是项目导航的示例。它创建了打开项目中所有设备的分层显示输出。 加载包含一些设备对象的项目并执行脚本。 例子： PrintDeviceTree.py # encoding:utf-8\n# We enable the new python 3 print syntax\nfrom __future__ import print_function\n\n# Prints out all devices in the currently open project.\n\nprint(\"--- Printing the devices of the project: ---\")\n\n# Define the printing function. This function starts with the\n# so called \"docstring\" which is the recommended way to document\n# functions in python.\ndef print_tree(treeobj, depth=0):\n \"\"\" Print a device and all its children\n\n Arguments:\n treeobj -- the object to print\n depth -- The current depth within the tree (default 0).\n\n The argument 'depth' is used by recursive call and\n should not be supplied by the user.\n \"\"\"\n\n # if the current object is a device, we print the name and device identification.\n if treeobj.is_device:\n name = treeobj.get_name(False)\n deviceid = treeobj.get_device_identification()\n print(\"{0}- {1} {2}\".format(\"--\"*depth, name, deviceid))\n\n # we recursively call the print_tree function for the child objects.\n for child in treeobj.get_children(False):\n print_tree(child, depth+1)\n\n# We iterate over all top level objects and call the print_tree function for them.\nfor obj in projects.primary.get_children():\n print_tree(obj)\n\nprint(\"--- Script finished. ---\") 设备树（来自“设备”视图）显示在消息视图中，并且所有非设备对象都被忽略： " }, 
{ "title" : "示例：读取变量 ", 
"url" : "_cds_access_cds_func_in_python_scripts.html#UUID-f04658fd-8f44-9612-db9e-0d0ba4adef9f", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例：读取变量 ", 
"snippet" : "脚本 ReadVariable.py 登录设备并在必要时启动应用程序。然后变量的值 PLC_PRG.iVar1 读取并输出。要尝试该脚本，您需要修改项目路径和变量名称。 例子： ReadVariable.py # encoding:utf-8 from __future__ import print_function # close open project if necessary: if projects.primary: projects.primary.close() # opens project proj = projects.open(r\"D:\\data\\projects\\Amp...", 
"body" : "脚本 ReadVariable.py 登录设备并在必要时启动应用程序。然后变量的值 PLC_PRG.iVar1 读取并输出。要尝试该脚本，您需要修改项目路径和变量名称。 例子： ReadVariable.py # encoding:utf-8\nfrom __future__ import print_function\n\n# close open project if necessary:\nif projects.primary:\n projects.primary.close()\n\n# opens project\nproj = projects.open(r\"D:\\data\\projects\\Ampel.project\")\n\n# set \"Ampel.project\" to active application\napp = proj.active_application\nonlineapp = online.create_online_application(app)\n\n# login to device\nonlineapp.login(OnlineChangeOption.Try, True)\n\n# set status of application to \"run\", if not in \"run\"\nif not onlineapp.application_state == ApplicationState.run:\n onlineapp.start()\n\n# wait 1 second\nsystem.delay(1000)\n\n# read value of iVar1\nvalue = onlineapp.read_value(\"PLC_PRG.iVar1\")\n\n# display value in message view or command line\nprint(value)\n\n# log out from device and close \"Ampel.project\"\nonlineapp.logout()\nproj.close() 在脚本的扩展中 ReadVariable.py ，脚本 MailVariables.py 从配方文件加载变量和表达式，并从控制器读取它们的当前值。然后，这些值被写回到同一个文件。此外，它使用 Python SMTP 库发送一封带有附件的电子邮件，附件中包含所有变量的列表。 要使用该脚本，您需要修改路径、电子邮件地址和 SMTP 服务器的名称以适合您的环境。 例子： MailVariables.py # encoding:utf-8\nfrom __future__ import print_function\n\n# Close current project if necessary and open \"ScriptTest.project\"\nif not projects.primary == None:\n projects.primary.close()\nproject = projects.open(\"D:\\\\Data\\\\projects\\\\scriptTest.project\")\n\n# retrieve active application\napplication = project.active_application\n\n# create online application\nonline_application = online.create_online_application(application)\n\n# login to application.\nonline_application.login(OnlineChangeOption.Try, True)\n\n# start PLC if necessary\nif not online_application.application_state == ApplicationState.run:\n online_application.start()\n\n# wait 2 seconds\nsystem.delay(2000)\n\n# open recipe file to read values.\nrecipe_input_file = open(\"D:\\\\Data\\\\projects\\\\RecipeInput.txt\", \"r\")\n\nwatch_expressions = []\n\nfor watch_expression in recipe_input_file:\n watch_expressions.append(watch_expression.strip())\n\nprint watch_expressions\n\n# read values from the controllerd\nwatch_values = online_application.read_values(watch_expressions)\n\nprint watch_values\n\n# open output file to write values\nrecipe_output_file = open(\"D:\\\\Data\\\\projects\\\\RecipeOutput.txt\", \"w\")\nfor i in range(len(watch_expressions)):\n recipe_output_file.write(watch_expressions[i])\n recipe_output_file.write(\" = \")\n recipe_output_file.write(watch_values[i])\n recipe_output_file.write(\"\\n\")\n\n# Close files\nrecipe_input_file.close()\nrecipe_output_file.close()\n\n# send Email\n# import respective libraries\nimport smtplib\nfrom email.mime.text import MIMEText\n\n#open output file\nrecipe_output_file = open(\"D:\\\\Data\\\\projects\\\\RecipeOutput.txt\", \"r\")\nmail = MIMEText(recipe_output_file.read())\nrecipe_output_file.close()\n\n#email address sender and recipient\nfromm = \"info@example.com\"\nto = \"info@example.com\"\n\n# set sender and recipient\nmail[\"Subject\"] = \"Attention value has changed\"\nmail[\"From\"] = fromm\nmail[\"To\"] = to\n\n# send email\nsmtp = smtplib.SMTP(\"name of smtp server\")\nsmtp.sendmail(fromm, [to], mail.as_string())\nsmtp.quit()\n\n# logout and close application\nonline_application.logout()\nproject.close() " }, 
{ "title" : "示例：创建和编辑 POU ", 
"url" : "_cds_access_cds_func_in_python_scripts.html#UUID-f84d1054-0503-e110-f60f-1bba49668bfc", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例：创建和编辑 POU ", 
"snippet" : "脚本 CreateDut.py 创建对象 MyStruct ， MyAlias ， 和 MyUnion 在 CODESYS 项目。文件夹 DataTypes 已经存在。 例子： CreateDut.py # encoding:utf-8 from __future__ import print_function STRUCT_CONTENT = \"\"\"\\ a : BOOL; b : BIT; c : BIT; \"\"\" UNION_WHOLE = \"\"\"\\ TYPE MyUnion : UNION Zahl : INT; Prozent : MyAlias; Bits : MyStruct; E...", 
"body" : "脚本 CreateDut.py 创建对象 MyStruct ， MyAlias ， 和 MyUnion 在 CODESYS 项目。文件夹 DataTypes 已经存在。 例子： CreateDut.py # encoding:utf-8\nfrom __future__ import print_function\n\nSTRUCT_CONTENT = \"\"\"\\\n a : BOOL;\n b : BIT;\n c : BIT;\n\"\"\"\n\nUNION_WHOLE = \"\"\"\\\nTYPE MyUnion :\nUNION\n Zahl : INT;\n Prozent : MyAlias;\n Bits : MyStruct;\nEND_UNION\nEND_TYPE\n\"\"\"\n\nproj = projects.primary\n\nfolder = proj.find('DataTypes', recursive = True)[0]\n\n# Create a struct DUT and insert the list of variables just into the right\n# place in line two, row 0 (line numbering starts with line 0)\nstruktur = folder.create_dut('MyStruct') # DutType.Structure is the default\nstruktur.textual_declaration.insert(2, 0, STRUCT_CONTENT)\n\n# Alias types get their \"content\" via the base type, which will just end up\n# as one line in the declaration part:\n# TYPE MyAlias : INT (0..100); END_TYPE\nbereich = folder.create_dut('MyAlias', DutType.Alias, \"INT (0..100)\")\n\n# Instead of injecting the variables into the existing declaration,\n# one can also just replace the complete declaration part, including the\n# boilerplate code.\nunion = folder.create_dut('MyUnion', DutType.Union)\nunion.textual_declaration.replace(UNION_WHOLE) " }, 
{ "title" : "示例：用户界面\/与用户的交互 ", 
"url" : "_cds_access_cds_func_in_python_scripts.html#UUID-81a59971-ce41-8511-1635-9da2963bf86c", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例：用户界面\/与用户的交互 ", 
"snippet" : "在某些情况下，脚本必须与用户交互。我们为最常见的交互提供了一些简单的 API。示例脚本 System_UI_Test.py 展示了这方面的所有可能的功能。 例子： System_UI_Test.py # encoding:utf-8 from __future__ import print_function \"\"\"Performs some tests on the messagestore and UI.\"\"\" print(\"Some Error, Warning and Information popups:\") system.ui.error(\"Fatal error: Everythi...", 
"body" : "在某些情况下，脚本必须与用户交互。我们为最常见的交互提供了一些简单的 API。示例脚本 System_UI_Test.py 展示了这方面的所有可能的功能。 例子： System_UI_Test.py # encoding:utf-8\nfrom __future__ import print_function\n\n\"\"\"Performs some tests on the messagestore and UI.\"\"\"\n\nprint(\"Some Error, Warning and Information popups:\")\nsystem.ui.error(\"Fatal error: Everything is OK. :-)\")\nsystem.ui.warning(\"Your bank account is surprisingly low\")\nsystem.ui.info(\"Just for your information: 42\")\n\nprint(\"Now, we ask the user something.\")\nres = system.ui.prompt(\"Do you like this?\", PromptChoice.YesNo, PromptResult.Yes);\nprint(\"The user selected '%s'\" % res)\n\nprint(\"Now, the user can choose between custom options:\")\nres = system.ui.choose(\"Please choose:\", (\"First\", 2, 7.5, \"Something else\"))\nprint(\"The user selected option '%s'\" % str(res)) # res is a tuple\n\nprint(\"Now, the user can choose several options:\")\nres = system.ui.select_many(\"Please select one or more options\", PromptChoice.OKCancel, PromptResult.OK, (\"La Premiere\", \"The Second\", \"Das Dritte\"))\nprint(\"The returned result is: '%s'\" % str(res)) # res is a tuple\n\nprint(\"Now, the user can select files and directories\")\nres = system.ui.open_file_dialog(\"Choose multiple files:\", filter=\"Text files (*.txt)|*.txt|Image Files(*.BMP;*.JPG;*.GIF)|*.BMP;*.JPG;*.GIF|All files (*.*)|*.*\", filter_index = 0, multiselect=True)\nprint(\"The user did choose: '%s'\" % str(res)) # res is a tuple as multiselect is true.\n\nres = system.ui.save_file_dialog(\"Choose a file to save:\", filter=\"Text files (*.txt)|*.txt|Image Files(*.BMP;*.JPG;*.GIF)|*.BMP;*.JPG;*.GIF|All files (*.*)|*.*\", filter_index = 0)\nprint(\"The user did choose: '%s'\" % res)\n\nres = system.ui.browse_directory_dialog(\"Choose a directory\", path=\"C:\\\\\")\nprint(\"The user did choose: '%s'\" % res)\n\nprint(\"Now we query a single line string\")\nres = system.ui.query_string(\"What's your name?\")\nprint(\"Nice to meet you, dear %s.\" % res)\n\nprint(\"Now we query a multi line string\")\nres = system.ui.query_string(\"Please tell me a nice story about your life!\", multi_line=True)\nif (res):\n print(\"Huh, that has been a long text, at least %s characters!\" % len(res))\nelse:\n print(\"Hey, don't be lazy!\")\n " }, 
{ "title" : "示例：操作项目信息对象 ", 
"url" : "_cds_access_cds_func_in_python_scripts.html#UUID-4eec8bcb-93f3-8f78-fc08-e99f12b81f53", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例：操作项目信息对象 ", 
"snippet" : "在脚本中 ProjectInfoExample.py ，我们在 项目信息 对象。最重要的信息项，例如 标题 和 版本 ，具有显式属性。但是，您可以通过 dictionary 语法。例如，推荐用于库项目属性的语法。 下面的示例可能看起来有些不切实际，但在构建服务器中也使用了类似的代码，用于创建、测试并可能发布自动化库项目和其他项目。ScriptEngine 是创建 CI（持续集成）和 CD（持续交付）系统的关键元素之一。 例子： ProjectInfoExample.py # encoding:utf-8 from __future__ import print_function proj = ...", 
"body" : "在脚本中 ProjectInfoExample.py ，我们在 项目信息 对象。最重要的信息项，例如 标题 和 版本 ，具有显式属性。但是，您可以通过 dictionary 语法。例如，推荐用于库项目属性的语法。 下面的示例可能看起来有些不切实际，但在构建服务器中也使用了类似的代码，用于创建、测试并可能发布自动化库项目和其他项目。ScriptEngine 是创建 CI（持续集成）和 CD（持续交付）系统的关键元素之一。 例子： ProjectInfoExample.py # encoding:utf-8\nfrom __future__ import print_function\n\nproj = projects.load(\"D:\\Some.library\")\n\ninfo = proj.get_project_info()\n\n# Set some values\ninfo.company = \"Test Library Ltd\"\ninfo.title = \"Script Test Project\"\ninfo.version = (0, 8, 15, 4711)\ninfo.default_namespace = \"testlibrary\"\ninfo.author = \"Python von Scriptinger\"\n\n# some values recommended in the library toolchain\ninfo.values[\"DefaultNamespace\"] = \"testlibrary\"\ninfo.values[\"Placeholder\"] = \"testlibrary\"\ninfo.values[\"DocFormat\"] = \"reStructuredText\"\n\n# now we set a custom \/ vendor specific value.\ninfo.values[\"SpecialDeviceId\"] = \"PLC0815_4711\"\n\n# Enable generation of Accessor functions, so the IEC\n# application can display the version in an info screen.\ninfo.change_accessor_generation(True)\n\n# And set the library to released\ninfo.released = True;\n\nproj.save() " }, 
{ "title" : "示例：调用外部命令并导入 PLCopenXML 文件 ", 
"url" : "_cds_access_cds_func_in_python_scripts.html#UUID-8c75d2d2-82fd-9c02-b253-f1707f231222", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例：调用外部命令并导入 PLCopenXML 文件 ", 
"snippet" : "示例脚本 DeviceImportFromSVN.py 从外部程序（在本例中为 SVN 客户端）获取 PLCopenXML 文件并将其导入到新创建的 CODESYS 项目。 要使用该脚本，您需要修改环境的路径。 例子： DeviceImportFromSVN.py # encoding:utf-8 # Imports a Device in PLCopenXML from Subversion via command line svn client. # We enable the new python 3 print syntax from __future__ import print_f...", 
"body" : "示例脚本 DeviceImportFromSVN.py 从外部程序（在本例中为 SVN 客户端）获取 PLCopenXML 文件并将其导入到新创建的 CODESYS 项目。 要使用该脚本，您需要修改环境的路径。 例子： DeviceImportFromSVN.py # encoding:utf-8\n# Imports a Device in PLCopenXML from Subversion via command line svn client.\n\n# We enable the new python 3 print syntax\nfrom __future__ import print_function\n\nimport sys, os\n\n# some variable definitions:\nSVNEXE = r\"C:\\Program Files\\Subversion\\bin\\svn.exe\"\nXMLURL = \"file:\/\/\/D:\/testrepo\/testfolder\/TestExport.xml\"\nPROJECT = r\"D:\\test.project\"\n\n# clean up any open project:\nif projects.primary:\n projects.primary.close()\n\n# Fetch the plcopenxml data from subversion.\n# We'll catch the output of the program into the xmldata variable.\n# The 'with' construct automatically closes the open pipe for us.\nwith os.popen('\"' + SVNEXE + '\" cat ' + XMLURL, 'r') as pipe:\n xmldata = pipe.read()\n\n# create a new project:\nproj = projects.create(PROJECT)\n\n# import the data into the project.\nproj.import_xml(xmldata, False)\n\n# and finally save. :-)\nproj.save()\n\nprint(\"--- Script finished. ---\") " }, 
{ "title" : "示例：项目归档 ", 
"url" : "_cds_access_cds_func_in_python_scripts.html#UUID-e9f294e4-f90f-8738-d08a-2671dd2f7140", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例：项目归档 ", 
"snippet" : "功能 open_archive() 和 save_archive() 是用于提取项目存档或将项目另存为项目存档的脚本函数。对于这两个函数， ArchiveCategories 可以指定。 为了这， open_archive() 接受参数 categories_to_extract 。 save_archive() 接受参数 additional_categories 。 ArchiveCategories 是项目档案类别，在以下情况下与项目档案一起提取 open_archive() 或与项目档案一起归档，如果 save_archive() 。...", 
"body" : "功能 open_archive() 和 save_archive() 是用于提取项目存档或将项目另存为项目存档的脚本函数。对于这两个函数， ArchiveCategories 可以指定。 为了这， open_archive() 接受参数 categories_to_extract 。 save_archive() 接受参数 additional_categories 。 ArchiveCategories 是项目档案类别，在以下情况下与项目档案一起提取 open_archive() 或与项目档案一起归档，如果 save_archive() 。 " }, 
{ "title" : "例子： open_archive() ", 
"url" : "_cds_access_cds_func_in_python_scripts.html#UUID-e9f294e4-f90f-8738-d08a-2671dd2f7140_section-id235151955509895", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例：项目归档 \/ 例子： open_archive() ", 
"snippet" : "open_archive() 的各种示例，带有参数 categories_to_extract 介绍如下： 默认行为 ： categories_to_extract=None 如果 categories_to_extract 没有明确指定，则参数设置为 None . 所有类别均从项目档案中拉出并提取。 例子 # Default projects.open_archive(stArchiveFile=r\"D:\\Tests\\Test.projectarchive\", stProjectPath=r\"D:\\Tests\", bOverwrite=True) 空列表 ： categories_to_ex...", 
"body" : "open_archive() 的各种示例，带有参数 categories_to_extract 介绍如下： 默认行为 ： categories_to_extract=None 如果 categories_to_extract 没有明确指定，则参数设置为 None . 所有类别均从项目档案中拉出并提取。 例子 # Default\nprojects.open_archive(stArchiveFile=r\"D:\\Tests\\Test.projectarchive\", stProjectPath=r\"D:\\Tests\", bOverwrite=True) 空列表 ： categories_to_extract=[] 如果参数 categories_to_extract 明确指定了一个空列表，那么就不会从项目档案中提取任何类别。 例子 # Passing empty list\nprojects.open_archive(stArchiveFile=r\"D:\\Tests\\Test.projectarchive\", stProjectPath=r\"D:\\Tests\", bOverwrite=True, categories_to_extract=[]) 多个类别 参数中可以指定多个类别 categories_to_extract 。也仅提取指定的类别。 例子 # Multiple categories\nprojects.open_archive(stArchiveFile=r\"D:\\Tests\\Test.projectarchive\", stProjectPath=r\"D:\\Tests\", bOverwrite=True, categories_to_extract=[ArchiveCategories.libraries, ArchiveCategories.devices]) 可能的错误 如果在 categories_to_extract 目前不存在的 CODESYS 安装时，会显示错误消息。无法提取项目档案，除非安装缺少的类别或从脚本中的参数中删除该类别。 " }, 
{ "title" : "例子： save_archive() ", 
"url" : "_cds_access_cds_func_in_python_scripts.html#UUID-e9f294e4-f90f-8738-d08a-2671dd2f7140_section-id235151982136617", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例：项目归档 \/ 例子： save_archive() ", 
"snippet" : "各种例子 save_archive() 使用参数 additional_categories 介绍如下： 默认行为 如果 additional_categories 如果没有明确设置，则默认类别 CODESYS 界面也已存档。 没有类别 ： additional_categories=None 如果 additional_categories 明确设置为 None 在脚本中，则不会存档任何类别。 多个类别 参数中可以指定多个类别 additional_categories 。只有指定的类别才会被包含在档案中。 例子 # Muliple categories projects.save_arch...", 
"body" : "各种例子 save_archive() 使用参数 additional_categories 介绍如下： 默认行为 如果 additional_categories 如果没有明确设置，则默认类别 CODESYS 界面也已存档。 没有类别 ： additional_categories=None 如果 additional_categories 明确设置为 None 在脚本中，则不会存档任何类别。 多个类别 参数中可以指定多个类别 additional_categories 。只有指定的类别才会被包含在档案中。 例子 # Muliple categories\nprojects.save_archive(path=r\"D:\\Tests\", comment=\"A new project\", additional_files=[], additional_categories=[ArchiveCategories.libraries, ArchiveCategories.devices]) " }, 
{ "title" : "高级示例：从 SVN 调用库并将其安装在 CODESYS 中 ", 
"url" : "_cds_access_cds_func_in_python_scripts.html#UUID-f8dc791e-79b1-01d1-38ab-1ff26c838733", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 高级示例：从 SVN 调用库并将其安装在 CODESYS 中 ", 
"snippet" : "以下示例脚本可以在 CT（持续测试）环境中执行库的调用和安装，以便对其进行测试。除了标准之外， CODESYS ， 这 CODESYS SVN 附加组件还必须使用有效许可证进行安装。 例子 import tempfile if projects.primary: projects.primary.close() tempdir = tempfile.mkdtemp() URL = \"svn:\/\/localhost\/testrepo\/trunk\/SvnTestLibrary\/\" proj = svn.checkout(URL, tempdir, \"testlibrary\", as_library...", 
"body" : "以下示例脚本可以在 CT（持续测试）环境中执行库的调用和安装，以便对其进行测试。除了标准之外， CODESYS ， 这 CODESYS SVN 附加组件还必须使用有效许可证进行安装。 例子 import tempfile\n\nif projects.primary:\n projects.primary.close()\n\ntempdir = tempfile.mkdtemp()\nURL = \"svn:\/\/localhost\/testrepo\/trunk\/SvnTestLibrary\/\"\n\nproj = svn.checkout(URL, tempdir, \"testlibrary\", as_library=True)\nproj.save()\n\nrepo = librarymanager.repositories[0]\nlibrarymanager.install_library(proj.path, repo, True)\n\nproj.close() " }, 
{ "title" : "示例和最佳实践 CODESYS Trace 脚本 API ", 
"url" : "_script_examples_for_scripting_api_of_trace.html", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API ", 
"snippet" : "CODESYS Scripting 从 CODESYS Trace 以下示例旨在补充自动生成的 API 文档 CODESYS Scripting 到 CODESYS Trace 。...", 
"body" : "CODESYS Scripting 从 CODESYS Trace 以下示例旨在补充自动生成的 API 文档 CODESYS Scripting 到 CODESYS Trace 。 " }, 
{ "title" : "创建追踪 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-385ab78d-d675-9432-2788-f934a017beb2", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 创建追踪 ", 
"snippet" : "您可以使用 CODESYS Trace 脚本 API 来创建新的 Trace。 myApplication = projects.primary.find(\"Device\", \"PLC Logic\", \"Application\")[0] traceObject = trace.create(myApplication, \"MyTraceName\") 名为 Task 必须已经存在。如果不存在，则此分配将抛出 ValueError 。 traceObject.task_name = \"Task\" 在脚本中，您可以指定应在哪个任务中执行新创建的跟踪。 myApplication = projects...", 
"body" : "您可以使用 CODESYS Trace 脚本 API 来创建新的 Trace。 myApplication = projects.primary.find(\"Device\", \"PLC Logic\", \"Application\")[0]\ntraceObject = trace.create(myApplication, \"MyTraceName\")\n 名为 Task 必须已经存在。如果不存在，则此分配将抛出 ValueError 。 traceObject.task_name = \"Task\" 在脚本中，您可以指定应在哪个任务中执行新创建的跟踪。 myApplication = projects.primary.find(\"Device\", \"PLC Logic\", \"Application\")[0]\ntraceObjectWithTaskSet = trace.create(myApplication, \"NameOfMySecondTrace\", \"MainTask\")\nassert traceObjectWithTaskSet.task_name == \"MainTask\" " }, 
{ "title" : "查找并验证现有跟踪 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-e069c436-9cb4-91cd-eb89-25d271ebfc04", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 查找并验证现有跟踪 ", 
"snippet" : "要查找现有跟踪，您可以使用 project.find 方法。 对于所有其他对象 IScriptObject 类型， .is_trace_object 等于 FALSE 。 foundObjects = projects.primary.find(\"Device\", \"PLC Logic\", \"Application\", \"MyTraceObject\") expectedTraceObject = foundObjects[0] assert expectedTraceObject.is_trace_object, \"Could not find trace object with the ex...", 
"body" : "要查找现有跟踪，您可以使用 project.find 方法。 对于所有其他对象 IScriptObject 类型， .is_trace_object 等于 FALSE 。 foundObjects = projects.primary.find(\"Device\", \"PLC Logic\", \"Application\", \"MyTraceObject\")\nexpectedTraceObject = foundObjects[0]\nassert expectedTraceObject.is_trace_object, \"Could not find trace object with the expected name\"\n " }, 
{ "title" : "添加和修改跟踪变量 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-1eb4a7bf-03b6-63ce-4945-37dec8f18c74", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 添加和修改跟踪变量 ", 
"snippet" : "这 add_variable() 方法是一种添加新方法的简单方法 ScriptTraceVariable 并在创建过程中设置其属性。 myTrace = projects.primary.find(\"Device\", \"PLC Logic\", \"Application\", \"MyTraceObject\")[0] addedVariable = myTrace.add_trace_variable(variableName=\"PLC_PRG.a1\", graphColor= 0xff000000, graphType=GraphType.LINES, activateMaxWarning=Tru...", 
"body" : "这 add_variable() 方法是一种添加新方法的简单方法 ScriptTraceVariable 并在创建过程中设置其属性。 myTrace = projects.primary.find(\"Device\", \"PLC Logic\", \"Application\", \"MyTraceObject\")[0]\n\naddedVariable = myTrace.add_trace_variable(variableName=\"PLC_PRG.a1\",\n graphColor= 0xff000000,\n graphType=GraphType.LINES,\n activateMaxWarning=True,\n maxWarningArea=9.0,\n maxColor= 0xffff0000)\naddedVariable.enabled = False\n\nfor i in range(2,11):\n newVariable = myTrace.variable_list.add()\n newVariable.variable_name = \"PLC_PRG.a\"+str(i)\n newVariable.graph_type = GraphType.LINES_CROSSES\n\nassert len(myTrace.variable_list) == 10 " }, 
{ "title" : "修改 ScriptTrace 变量列表 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-27bea738-93cd-84ac-0396-64f739218a46", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 修改 ScriptTrace 变量列表 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "删除特定的 ScriptTrace 变量 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-27bea738-93cd-84ac-0396-64f739218a46_id_KopievonBeispieleSnippetsBestPractices-RemovingaspecificScriptTraceVariable", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 修改 ScriptTrace 变量列表 \/ 删除特定的 ScriptTrace 变量 ", 
"snippet" : "在下面的代码片段中，首先找到具有指定名称的变量，然后将其从 ScriptTraceVariableList 。 def remove_variable_by_name(traceObject, variableName): index_to_remove = -1 for variable in traceObject.variable_list: if variable.variable_name == variableName: index_to_remove = traceObject.variable_list.index_of(variable) break if index_to_...", 
"body" : "在下面的代码片段中，首先找到具有指定名称的变量，然后将其从 ScriptTraceVariableList 。 def remove_variable_by_name(traceObject, variableName):\n index_to_remove = -1\n for variable in traceObject.variable_list:\n if variable.variable_name == variableName:\n index_to_remove = traceObject.variable_list.index_of(variable)\n break\n if index_to_remove != -1:\n traceObject.variable_list.remove(index_to_remove) " }, 
{ "title" : "修改录制设置 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-94cde555-71d6-476d-5232-f6ab24e51f0d", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 修改录制设置 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "设置跟踪记录的分辨率 (ms\/µs) ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-94cde555-71d6-476d-5232-f6ab24e51f0d_id_KopievonBeispieleSnippetsBestPractices-Settingtheresolutionmssofthetracerecording", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 修改录制设置 \/ 设置跟踪记录的分辨率 (ms\/µs) ", 
"snippet" : "以下代码片段基于“ 创建追踪“片段。 traceObject.resolution = Resolution.MicroSeconds 使用 Resolution.MilliSeconds 如果您希望基于毫秒进行记录。...", 
"body" : "以下代码片段基于“ 创建追踪“片段。 traceObject.resolution = Resolution.MicroSeconds\n 使用 Resolution.MilliSeconds 如果您希望基于毫秒进行记录。 " }, 
{ "title" : "设置录音条件 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-94cde555-71d6-476d-5232-f6ab24e51f0d_id_KopievonBeispieleSnippetsBestPractices-Settingtherecordcondition", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 修改录制设置 \/ 设置录音条件 ", 
"snippet" : "以下代码片段基于“ 创建追踪“片段。 traceObject.record_condition = \"PLC_PRG.bDoRecord\"...", 
"body" : "以下代码片段基于“ 创建追踪“片段。 traceObject.record_condition = \"PLC_PRG.bDoRecord\"\n " }, 
{ "title" : "设置评论 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-94cde555-71d6-476d-5232-f6ab24e51f0d_id_KopievonBeispieleSnippetsBestPractices-Settingthecomment", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 修改录制设置 \/ 设置评论 ", 
"snippet" : "以下代码片段基于“ 创建追踪“片段。 traceObject.comment = \"This trace records the ...\"...", 
"body" : "以下代码片段基于“ 创建追踪“片段。 traceObject.comment = \"This trace records the ...\"\n " }, 
{ "title" : "设置自动启动选项 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-94cde555-71d6-476d-5232-f6ab24e51f0d_id_KopievonBeispieleSnippetsBestPractices-SettingtheAutoStartoption", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 修改录制设置 \/ 设置自动启动选项 ", 
"snippet" : "以下代码片段基于“ 创建追踪“片段。 traceObject.auto_start = True...", 
"body" : "以下代码片段基于“ 创建追踪“片段。 traceObject.auto_start = True\n " }, 
{ "title" : "设置仅在每第 n 个循环中记录的选项 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-94cde555-71d6-476d-5232-f6ab24e51f0d_id_KopievonBeispieleSnippetsBestPractices-SettingtheoptiontorecordonlyeveryNthcycle", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 修改录制设置 \/ 设置仅在每第 n 个循环中记录的选项 ", 
"snippet" : "以下代码片段基于“ 创建追踪“片段。 traceObject.every_n_cycles = 10...", 
"body" : "以下代码片段基于“ 创建追踪“片段。 traceObject.every_n_cycles = 10\n " }, 
{ "title" : "图表及其变量 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-04c1b9a8-bb14-fbfd-3805-9711ebba973f", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 图表及其变量 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "创建一个包含所有 ScriptTrace 变量的 ScriptTrace 图 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-04c1b9a8-bb14-fbfd-3805-9711ebba973f_id_KopievonBeispieleSnippetsBestPractices-CreateoneScriptTraceDiagramwithallScriptTraceVariable", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 图表及其变量 \/ 创建一个包含所有 ScriptTrace 变量的 ScriptTrace 图 ", 
"snippet" : "以下脚本是创建使用所有变量的简单图表的示例。 首先，创建一个 ScriptTrace 对象和一些 ScriptTrace 变量。 traceObject = projects.primary.find(\"Device\",\"PLC Logic\",\"Application\",\"Trace\")[0] assert traceObject.is_trace_object for i in range(5): traceObject.add_trace_variable(variableName=\"PLC_PRG.a\"+str(i)) 接下来，创建一个 ScriptTrace 图表，然后添加所有 Scr...", 
"body" : "以下脚本是创建使用所有变量的简单图表的示例。 首先，创建一个 ScriptTrace 对象和一些 ScriptTrace 变量。 traceObject = projects.primary.find(\"Device\",\"PLC Logic\",\"Application\",\"Trace\")[0]\nassert traceObject.is_trace_object\nfor i in range(5):\n traceObject.add_trace_variable(variableName=\"PLC_PRG.a\"+str(i))\n 接下来，创建一个 ScriptTrace 图表，然后添加所有 ScriptTrace 变量。 traceDiagram = traceObject.diagrams.add()\nfor traceVar in traceObject.variable_list:\n traceDiagram.add_diagram_variable(traceVar) " }, 
{ "title" : "为每个 ScriptTrace 变量创建一个 ScriptTrace 图 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-04c1b9a8-bb14-fbfd-3805-9711ebba973f_id_KopievonBeispieleSnippetsBestPractices-CreateoneScriptTraceDiagramperScriptTraceVariable", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 图表及其变量 \/ 为每个 ScriptTrace 变量创建一个 ScriptTrace 图 ", 
"snippet" : "以下 Python 方法采用一个 ScriptTrace 对象并为每个 ScriptTrace 变量添加一个图表。 def one_diagram_per_variable(traceObject): assert traceObject.is_trace_object for traceVar in traceObject.variable_list: diagram = traceObject.diagrams.add(traceVar) diagram.name = traceVar.variable_name...", 
"body" : "以下 Python 方法采用一个 ScriptTrace 对象并为每个 ScriptTrace 变量添加一个图表。 def one_diagram_per_variable(traceObject):\n assert traceObject.is_trace_object\n for traceVar in traceObject.variable_list:\n diagram = traceObject.diagrams.add(traceVar)\n diagram.name = traceVar.variable_name\n " }, 
{ "title" : "复制 ScriptTrace 图表的设置 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-40f0cc7b-3dd9-5210-2c81-06f898579f41", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 复制 ScriptTrace 图表的设置 ", 
"snippet" : "以下脚本显示如何修改和复制 ScriptTrace 图表的设置。 traceObject = projects.primary.find(\"Device\",\"PLC Logic\",\"Application\",\"Trace\")[0] assert traceObject.is_trace_object # apply settings for the first diagram traceObject.diagrams[0].y_axis.mode = AxisScaleMode.FixedLength traceObject.diagrams[0].y_axis.range = 10.0 tr...", 
"body" : "以下脚本显示如何修改和复制 ScriptTrace 图表的设置。 \ntraceObject = projects.primary.find(\"Device\",\"PLC Logic\",\"Application\",\"Trace\")[0]\nassert traceObject.is_trace_object\n\n# apply settings for the first diagram\ntraceObject.diagrams[0].y_axis.mode = AxisScaleMode.FixedLength\ntraceObject.diagrams[0].y_axis.range = 10.0\ntraceObject.diagrams[0].y_axis.color = 0xffee0000\ntraceObject.diagrams[0].y_axis.draw_grid = True\ntraceObject.diagrams[0].y_axis.grid_color = 0xffee0000\ntraceObject.diagrams[0].tickmark_fixed_spacing = True\ntraceObject.diagrams[0].tickmark_fixed_distance = 5.0\ntraceObject.diagrams[0].tickmark_fixed_subdivisions = 4\n\n# copy the settings from the first diagrams to all other diagrams\nfor i in range(1,len(traceObject.diagrams))\n traceObject.diagrams[i].y_axis.copy_from(traceObject.diagrams[0])\n " }, 
{ "title" : "在线处理痕迹 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-7cdc3fea-17fb-1c0d-4407-f1812b4b2bd0", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 在线处理痕迹 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "下载并启动 Trace ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-7cdc3fea-17fb-1c0d-4407-f1812b4b2bd0_id_KopievonBeispieleSnippetsBestPractices-Downloadandstarttrace", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 在线处理痕迹 \/ 下载并启动 Trace ", 
"snippet" : "以下代码片段查找 Trace 踪迹 Application 应用程序，下载并启动它。 proj = projects.open(r\"<Path to the project file>\") app = proj.find(\"Device\", \"PLC Logic\", \"Application\")[0] with online.create_online_application(app) as onlineapp: traceObject = proj.find(\"Device\", \"PLC Logic\", \"Application\", \"Trace\")[0] onlineapp.login(O...", 
"body" : "以下代码片段查找 Trace 踪迹 Application 应用程序，下载并启动它。 proj = projects.open(r\"<Path to the project file>\")\napp = proj.find(\"Device\", \"PLC Logic\", \"Application\")[0]\nwith online.create_online_application(app) as onlineapp:\n traceObject = proj.find(\"Device\", \"PLC Logic\", \"Application\", \"Trace\")[0]\n onlineapp.login(OnlineChangeOption.Never, True)\n onlineapp.start()\n editor = traceObject.open_editor()\n editor.download()\n editor.start() " }, 
{ "title" : "将跟踪保存到文件 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-7cdc3fea-17fb-1c0d-4407-f1812b4b2bd0_id_KopievonBeispieleSnippetsBestPractices-Savingtracetoafile", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 在线处理痕迹 \/ 将跟踪保存到文件 ", 
"snippet" : "以下代码片段基于“ 下载并启动 Trace“片段。 必须先停止跟踪，然后才能保存它。这可以通过达到触发条件或通过显式调用 stop() 。 假定跟踪已在运行。 editor.stop() editor.save(r\"<File path to csv file>\")...", 
"body" : "以下代码片段基于“ 下载并启动 Trace“片段。 必须先停止跟踪，然后才能保存它。这可以通过达到触发条件或通过显式调用 stop() 。 假定跟踪已在运行。 editor.stop()\neditor.save(r\"<File path to csv file>\") " }, 
{ "title" : "查询跟踪记录的各种信息 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-7cdc3fea-17fb-1c0d-4407-f1812b4b2bd0_id_KopievonBeispieleSnippetsBestPractices-Querymiscellaneousinformationabouttracerecording", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 在线处理痕迹 \/ 查询跟踪记录的各种信息 ", 
"snippet" : "以下代码片段基于“ 下载并启动 Trace“片段。 假定跟踪已在运行。 print(\"Packet State: {}\".format(editor.get_packet_state())) print(\"Trace started at {} (absolute timestamp)\".format(editor.get_trace_start_timetamp()))...", 
"body" : "以下代码片段基于“ 下载并启动 Trace“片段。 假定跟踪已在运行。 print(\"Packet State: {}\".format(editor.get_packet_state()))\nprint(\"Trace started at {} (absolute timestamp)\".format(editor.get_trace_start_timetamp())) " }, 
{ "title" : "触发器处理 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-c2b239af-af15-efed-b932-7a7dde57e5a0", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 触发器处理 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "配置布尔触发器 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-c2b239af-af15-efed-b932-7a7dde57e5a0_id_KopievonBeispieleSnippetsBestPractices-ConfigureaBOOLtrigger", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 触发器处理 \/ 配置布尔触发器 ", 
"snippet" : "traceObject = proj.find(\"Device\", \"PLC Logic\", \"Application\", \"Trace\")[0] traceObject.trigger_variable = \"PLC_PRG.bVar\" traceObject.trigger_edge = TriggerEdge.Positive traceObject.post_trigger_samples = 20 仅数字触发变量需要触发级别。但是，将触发器明确设置为 None 。 traceObject.trigger_level = None...", 
"body" : "traceObject = proj.find(\"Device\", \"PLC Logic\", \"Application\", \"Trace\")[0]\ntraceObject.trigger_variable = \"PLC_PRG.bVar\"\ntraceObject.trigger_edge = TriggerEdge.Positive\ntraceObject.post_trigger_samples = 20\n 仅数字触发变量需要触发级别。但是，将触发器明确设置为 None 。 traceObject.trigger_level = None " }, 
{ "title" : "配置数字触发器 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-c2b239af-af15-efed-b932-7a7dde57e5a0_id_KopievonBeispieleSnippetsBestPractices-Configureanumerictrigger", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 触发器处理 \/ 配置数字触发器 ", 
"snippet" : "traceObject = proj.find(\"Device\", \"PLC Logic\", \"Application\", \"Trace\")[0] traceObject.trigger_variable = \"PLC_PRG.iTemperature\" traceObject.trigger_edge = TriggerEdge.Positive traceObject.post_trigger_samples = 20 如果触发变量的类型为 REAL 或者 LREAL ，则触发级别也可以指定为浮点数（例如， 80.5 ）。 traceObject.trigger_level = 80...", 
"body" : "traceObject = proj.find(\"Device\", \"PLC Logic\", \"Application\", \"Trace\")[0]\ntraceObject.trigger_variable = \"PLC_PRG.iTemperature\"\ntraceObject.trigger_edge = TriggerEdge.Positive\ntraceObject.post_trigger_samples = 20 如果触发变量的类型为 REAL 或者 LREAL ，则触发级别也可以指定为浮点数（例如， 80.5 ）。 traceObject.trigger_level = 80 " }, 
{ "title" : "等待触发并保存记录的数据 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-c2b239af-af15-efed-b932-7a7dde57e5a0_id_KopievonBeispieleSnippetsBestPractices-Waitingfortriggerandsaverecordeddata", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 触发器处理 \/ 等待触发并保存记录的数据 ", 
"snippet" : "以下代码片段基于“ 下载并启动 Trace“片段和“配置*触发器”。 triggerstate = editor.get_trigger_state() while triggerstate != TriggerState.TriggerReached: system.delay(200) triggerstate = editor.get_trigger_state() editor.save(r\"<File path to csv file>\")...", 
"body" : "以下代码片段基于“ 下载并启动 Trace“片段和“配置*触发器”。 triggerstate = editor.get_trigger_state()\nwhile triggerstate != TriggerState.TriggerReached:\n system.delay(200)\n triggerstate = editor.get_trigger_state()\n\neditor.save(r\"<File path to csv file>\") " }, 
{ "title" : "达到触发器后查询时间戳信息 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-c2b239af-af15-efed-b932-7a7dde57e5a0_id_KopievonBeispieleSnippetsBestPractices-Querytimestampinformationaftertriggerhasbeenreached", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 触发器处理 \/ 达到触发器后查询时间戳信息 ", 
"snippet" : "以下代码片段基于“ 下载并启动 Trace“片段和“配置*触发器”。 print(\"Trigger reached at {} (absolute timestamp)\".format(editor.get_trigger_timetamp())) print(\"Trigger reached at {}\".format(editor.get_trigger_startdate())) print(\"Trace was running {}ms until trigger has been reached\".format(editor.get_trigger_timetamp() - edit...", 
"body" : "以下代码片段基于“ 下载并启动 Trace“片段和“配置*触发器”。 print(\"Trigger reached at {} (absolute timestamp)\".format(editor.get_trigger_timetamp()))\nprint(\"Trigger reached at {}\".format(editor.get_trigger_startdate()))\nprint(\"Trace was running {}ms until trigger has been reached\".format(editor.get_trigger_timetamp() - editor.get_trace_start_timetamp())) " }, 
{ "title" : "达到触发条件后恢复跟踪记录 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-c2b239af-af15-efed-b932-7a7dde57e5a0_id_KopievonBeispieleSnippetsBestPractices-Resumetracerecordingaftertriggerhasbeenreached", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 触发器处理 \/ 达到触发条件后恢复跟踪记录 ", 
"snippet" : "以下代码片段基于“ 下载并启动 Trace“片段和“配置*触发器”。 editor.reset_trigger()...", 
"body" : "以下代码片段基于“ 下载并启动 Trace“片段和“配置*触发器”。 editor.reset_trigger() " }, 
{ "title" : "设备追踪 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-a57fe435-d021-bbe6-c14a-db27f97a934d", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 设备追踪 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "创建 DeviceTrace ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-a57fe435-d021-bbe6-c14a-db27f97a934d_id_KopievonBeispieleSnippetsBestPractices-CreateaDeviceTrace", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 设备追踪 \/ 创建 DeviceTrace ", 
"snippet" : "myDevice = projects.primary.find(\"Device\")[0] devicetrace = trace.create(myDevice, \"DeviceTrace\")...", 
"body" : "myDevice = projects.primary.find(\"Device\")[0]\ndevicetrace = trace.create(myDevice, \"DeviceTrace\") " }, 
{ "title" : "查询设备上的当前跟踪记录 ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-a57fe435-d021-bbe6-c14a-db27f97a934d_id_KopievonBeispieleSnippetsBestPractices-Querycurrenttracerecordingsonthedevice", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 设备追踪 \/ 查询设备上的当前跟踪记录 ", 
"snippet" : "以下代码片段基于“ 创建 DeviceTrace“片段。 traceObject = projects.primary.find(\"Device\", \"DeviceTrace\")[0] 对于应用程序跟踪，结果 get_online_traces 仅包含应用程序的痕迹。 # traceObject = projects.primary.find(\"Device\", \"PLC Logic\", \"Application\", \"Trace\")[0] editor = traceObject.open_editor() for tracepacket in editor.get_online_trace...", 
"body" : "以下代码片段基于“ 创建 DeviceTrace“片段。 traceObject = projects.primary.find(\"Device\", \"DeviceTrace\")[0]\n 对于应用程序跟踪，结果 get_online_traces 仅包含应用程序的痕迹。 # traceObject = projects.primary.find(\"Device\", \"PLC Logic\", \"Application\", \"Trace\")[0]\neditor = traceObject.open_editor()\nfor tracepacket in editor.get_online_traces():\n print(tracepacket) " }, 
{ "title" : "将现有跟踪上传为 DeviceTrace ", 
"url" : "_script_examples_for_scripting_api_of_trace.html#UUID-a57fe435-d021-bbe6-c14a-db27f97a934d_id_KopievonBeispieleSnippetsBestPractices-UploadexistingtracetoDeviceTrace", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 示例和最佳实践 CODESYS Trace 脚本 API \/ 设备追踪 \/ 将现有跟踪上传为 DeviceTrace ", 
"snippet" : "以下代码片段基于“ 创建 DeviceTrace“片段。 traceObject = projects.primary.find(\"Device\", \"DeviceTrace\")[0] editor = traceObject.open_editor() editor.upload_to_device_trace(\"CpuCoreLoad\")...", 
"body" : "以下代码片段基于“ 创建 DeviceTrace“片段。 traceObject = projects.primary.find(\"Device\", \"DeviceTrace\")[0]\neditor = traceObject.open_editor()\neditor.upload_to_device_trace(\"CpuCoreLoad\") " }, 
{ "title" : "消息处理 CODESYS Scripting 脚本 ", 
"url" : "_script_message_handling_with_scripting.html", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 消息处理 CODESYS Scripting 脚本 ", 
"snippet" : "要求 ： CODESYS V3.5 SP17 或更高版本，已安装 CODESYS Scripting 版本 4.2.0.0 准备工作 ：将所需的代码示例复制到文件并以任意名称保存为 Python 脚本。 要执行已保存的 Python 脚本，请按照以下步骤操作： 开始 CODESYS 。 点击 工具 → 脚本 → 执行脚本文件 菜单命令。 在 选择脚本文件 对话框中，选择要执行的Python脚本。 所有输出均显示在 消息 查看 脚本 类别。 术语 Message Service ：自动化平台的功能是显示不同的提示，然后可以根据需要自动处理 Message Key ：通过message servi...", 
"body" : "要求 ： CODESYS V3.5 SP17 或更高版本，已安装 CODESYS Scripting 版本 4.2.0.0 准备工作 ：将所需的代码示例复制到文件并以任意名称保存为 Python 脚本。 要执行已保存的 Python 脚本，请按照以下步骤操作： 开始 CODESYS 。 点击 工具 → 脚本 → 执行脚本文件 菜单命令。 在 选择脚本文件 对话框中，选择要执行的Python脚本。 所有输出均显示在 消息 查看 脚本 类别。 术语 Message Service ：自动化平台的功能是显示不同的提示，然后可以根据需要自动处理 Message Key ：通过message service生成的提示的唯一标识符。并非每个提示都有message key。提示的消息键通常是隐藏的，但可以使用属性 system.log_prompt_details （见下文： 财产：）。 " }, 
{ "title" : "财产： system.script_prompt_handling ", 
"url" : "_script_message_handling_with_scripting.html#UUID-87499b2f-e086-5a74-affa-0d9fb0b6a357_section-id235153315777883", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 消息处理 CODESYS Scripting 脚本 \/ 财产： system.script_prompt_handling ", 
"snippet" : "您可以使用该属性 system.script_prompt_handling 指定是否以及如何自动处理message service提示。 示例 1 价值观 ScriptPromptHandling.LogPrompts 和 ScriptPromptHandling.ForwardUnknownPrompts 被分配。 价值 ScriptPromptHandling.ForwardUnknownPrompts 指定所有没有匹配条目的提示 system.prompt_answers 转发到底层message service。 价值 ScriptPromptHandling.LogPrompts ...", 
"body" : "您可以使用该属性 system.script_prompt_handling 指定是否以及如何自动处理message service提示。 示例 1 价值观 ScriptPromptHandling.LogPrompts 和 ScriptPromptHandling.ForwardUnknownPrompts 被分配。 价值 ScriptPromptHandling.ForwardUnknownPrompts 指定所有没有匹配条目的提示 system.prompt_answers 转发到底层message service。 价值 ScriptPromptHandling.LogPrompts 指定对于所有提示 和 进入 system.prompt_answers 显示在消息视图中，通过该值确认提示。 system.script_prompt_handling = ScriptPromptHandling.LogPrompts | ScriptPromptHandling.ForwardUnknownPrompts 示例 2 价值观 ScriptPromptHandling.LogPrompts 和 ScriptPromptHandling.AlwaysForwardPrompts 被分配。 价值 ScriptPromptHandling.AlwaysForwardPrompts 指定 全部 提示会被转发到底层message service。“system.prompt_answers”中的匹配条目将被忽略。 ScriptPromptHandling.LogPrompts 在这种情况下没有效果，因为 ScriptPromptHandling.AlwaysForwardPrompts 具有最高优先级并覆盖所有其他选项。 system.script_prompt_handling = ScriptPromptHandling.LogPrompts | ScriptPromptHandling.AlwaysForwardUnknown 以下附加条件适用于所有需要额外用户交互（例如，选择复选框）的提示，仅当 ScriptPromptHandling.SuppressPrompts 或者 ScriptPromptHandling.LogPrompt 已设置： 所有没有message key的提示都会转发到底层message service。 所有带有message key的提示都需要输入 system.prompt_answers 。 " }, 
{ "title" : "财产： system.process_script_prompts ", 
"url" : "_script_message_handling_with_scripting.html#UUID-87499b2f-e086-5a74-affa-0d9fb0b6a357_section-id235153379466094", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 消息处理 CODESYS Scripting 脚本 \/ 财产： system.process_script_prompts ", 
"snippet" : "随着 system.process_script_prompts 属性，您可以指定是否通过生成的提示 system.ui 也应该由message handling来处理 CODESYS Scripting 。 示例 1 在以下示例中，处理通过以下方式生成的提示 CODESYS Scripting ，已启用。 当执行此脚本时，生成的message handling提示由 CODESYS Scripting 并将结果显示在消息视图中。 system.process_script_prompts = True system.script_prompt_handling = ScriptPromptH...", 
"body" : "随着 system.process_script_prompts 属性，您可以指定是否通过生成的提示 system.ui 也应该由message handling来处理 CODESYS Scripting 。 示例 1 在以下示例中，处理通过以下方式生成的提示 CODESYS Scripting ，已启用。 当执行此脚本时，生成的message handling提示由 CODESYS Scripting 并将结果显示在消息视图中。 system.process_script_prompts = True\nsystem.script_prompt_handling = ScriptPromptHandling.LogPrompts\nsystem.ui.info(\"my info message\", \"message_key\") 示例 2 在以下示例中，处理通过以下方式生成的提示 CODESYS Scripting ，已禁用。 执行此脚本时，会打开一个信息提示，该提示不会被message handling程序处理 CODESYS Scripting 。 system.process_script_prompts = False\nsystem.script_prompt_handling = ScriptPromptHandling.LogPrompts\nsystem.ui.info(\"my info message\", \"message_key\") " }, 
{ "title" : "财产： system.log_prompt_details ", 
"url" : "_script_message_handling_with_scripting.html#UUID-87499b2f-e086-5a74-affa-0d9fb0b6a357_section-id235153395554342", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 消息处理 CODESYS Scripting 脚本 \/ 财产： system.log_prompt_details ", 
"snippet" : "随着 system.log_prompt_details 属性，您可以指定是否在处理之前在消息视图中显示提示的所有详细信息。如果要将更复杂提示的响应存储在 system.prompt_answers 。由于提示的message key也会输出，因此该方法可用于确定匹配的message key以供使用 system.prompt_answers ， 例如。 示例 1 在以下示例中，记录提示详细信息 已启用 。之后，会生成带有附加选项的提示。 当执行此脚本时，会出现提示，并且有关此提示的所有信息都会显示在消息视图中。 system.log_prompt_details = True system....", 
"body" : "随着 system.log_prompt_details 属性，您可以指定是否在处理之前在消息视图中显示提示的所有详细信息。如果要将更复杂提示的响应存储在 system.prompt_answers 。由于提示的message key也会输出，因此该方法可用于确定匹配的message key以供使用 system.prompt_answers ， 例如。 示例 1 在以下示例中，记录提示详细信息 已启用 。之后，会生成带有附加选项的提示。 当执行此脚本时，会出现提示，并且有关此提示的所有信息都会显示在消息视图中。 system.log_prompt_details = True\nsystem.process_script_prompts = True\noptions = [\"Option 1\", \"Option 2\", \"Option 3\"]\nsystem.ui.select_many(\"my info message\", PromptChoice.OKCancel, PromptResult.Cancel, options, \"message_key\") 示例 2 在以下示例中，记录提示详细信息 禁用 。之后，会生成带有附加选项的提示。 执行此脚本时，会出现提示。消息视图中不显示有关提示的任何信息。 system.log_prompt_details = False\nsystem.process_script_prompts = True\noptions = [\"Option 1\", \"Option 2\", \"Option 3\"]\nsystem.ui.select_many(\"my info message\", PromptChoice.OKCancel, PromptResult.Cancel, options, \"message_key\") " }, 
{ "title" : "财产： system.prompt_answers ", 
"url" : "_script_message_handling_with_scripting.html#UUID-87499b2f-e086-5a74-affa-0d9fb0b6a357_section-id235153404768729", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 消息处理 CODESYS Scripting 脚本 \/ 财产： system.prompt_answers ", 
"snippet" : "随着 system.prompt_answers 属性，您可以指定如何响应特定提示。 这是必要的 当提示不应使用设置的默认值来回答时 对于需要额外用户交互的提示（例如，选择复选框） 仅可存储带有message key的提示的响应。...", 
"body" : "随着 system.prompt_answers 属性，您可以指定如何响应特定提示。 这是必要的 当提示不应使用设置的默认值来回答时 对于需要额外用户交互的提示（例如，选择复选框） 仅可存储带有message key的提示的响应。 " }, 
{ "title" : "没有附加选择选项的提示 ", 
"url" : "_script_message_handling_with_scripting.html#UUID-87499b2f-e086-5a74-affa-0d9fb0b6a357_section-id235153408386325", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 消息处理 CODESYS Scripting 脚本 \/ 没有附加选择选项的提示 ", 
"snippet" : "在下面的例子中，对提示的响应方式 message_key_1 message key应该存储在 system.prompt_answers 。在本例中，所有带有此message key的提示都会被回答 OK 回答道。 当执行此脚本时，会相继生成两个提示。 第一个提示符 message_key_1 message key会自动处理，结果显示在消息视图中。 第二个提示符 message_key_2 显示message key。 system.process_script_prompts = True system.prompt_answers[\"message_key_1\"] = PromptRe...", 
"body" : "在下面的例子中，对提示的响应方式 message_key_1 message key应该存储在 system.prompt_answers 。在本例中，所有带有此message key的提示都会被回答 OK 回答道。 当执行此脚本时，会相继生成两个提示。 第一个提示符 message_key_1 message key会自动处理，结果显示在消息视图中。 第二个提示符 message_key_2 显示message key。 system.process_script_prompts = True\nsystem.prompt_answers[\"message_key_1\"] = PromptResult.OK\nsystem.ui.prompt(\"automatically processed prompt\", PromptChoice.OKCancel, PromptResult.Cancel, message_key=\"message_key_1\")\nsystem.ui.prompt(\"shown prompt\", PromptChoice.OKCancel, PromptResult.Cancel, message_key=\"message_key_2\") " }, 
{ "title" : "带有附加单选的提示 ", 
"url" : "_script_message_handling_with_scripting.html#UUID-87499b2f-e086-5a74-affa-0d9fb0b6a357_section-id235153408756057", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 消息处理 CODESYS Scripting 脚本 \/ 带有附加单选的提示 ", 
"snippet" : "对于需要从可能的选项列表中选择一个选项的提示，应该选择的选项必须存储在 system.prompt_answers 对应message key。 对此有两种选择： 指定所需选项的从零开始的索引 存储类型的委托 MultipleChoiceSelector 示例 1 在以下示例中，索引存储在 system.prompt_answers ，应该用于所有带有 message_key_1 message key。 system.process_script_prompts = True options = [\"Option 1\", \"Option 2\", \"Option 3\"] system.prom...", 
"body" : "对于需要从可能的选项列表中选择一个选项的提示，应该选择的选项必须存储在 system.prompt_answers 对应message key。 对此有两种选择： 指定所需选项的从零开始的索引 存储类型的委托 MultipleChoiceSelector 示例 1 在以下示例中，索引存储在 system.prompt_answers ，应该用于所有带有 message_key_1 message key。 system.process_script_prompts = True\noptions = [\"Option 1\", \"Option 2\", \"Option 3\"]\nsystem.prompt_answers[\"message_key_1\"] = 1\nsystem.ui.choose(\"single choice prompt\", options, message_key=\"message_key_1\") 示例 2 在下面的示例中，类型为 MultipleChoiceSelector 存储在 system.prompt_answers 适用于所有带有 message_key_1 message key。 from System import Array\n\n# filter function\ndef my_filter(choices):\n    return Array.IndexOf(choices, \"Option 2\")\n\nsystem.process_script_prompts = True\noptions = [\"Option 1\", \"Option 2\", \"Option 3\"]\nsystem.prompt_answers[\"message_key_1\"] = MultipleChoiceSelector(my_filter)\nsystem.ui.choose(\"single choice prompt\", options, message_key=\"message_key_1\") " }, 
{ "title" : "带有附加多选的提示 ", 
"url" : "_script_message_handling_with_scripting.html#UUID-87499b2f-e086-5a74-affa-0d9fb0b6a357_section-id23515340912015", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 消息处理 CODESYS Scripting 脚本 \/ 带有附加多选的提示 ", 
"snippet" : "对于需要从可能的选项列表中选择多个选项的提示，应该选择的选项以及提示应该响应的结果必须保存在 system.prompt_answers 对应message key。 对此有两种选择： 指定所需选项的从零开始的索引 存储类型的委托 MultipleChoiceSelector 例子 在以下示例中，元组存储在 system.prompt_answers 其中首先包含 PromptResult 要使用的，其次包含一个类型的委托 PromptChoiceFilter 。 脚本执行时，系统会自动回答提示，并将结果显示在消息视图中。对于各个选项， Boolean 用于指定它们是否已被选中。 # filt...", 
"body" : "对于需要从可能的选项列表中选择多个选项的提示，应该选择的选项以及提示应该响应的结果必须保存在 system.prompt_answers 对应message key。 对此有两种选择： 指定所需选项的从零开始的索引 存储类型的委托 MultipleChoiceSelector 例子 在以下示例中，元组存储在 system.prompt_answers 其中首先包含 PromptResult 要使用的，其次包含一个类型的委托 PromptChoiceFilter 。 脚本执行时，系统会自动回答提示，并将结果显示在消息视图中。对于各个选项， Boolean 用于指定它们是否已被选中。 # filter function\ndef my_filter(choice):\n    return choice in (\"Option 1\", \"Option 3\")\n\nsystem.process_script_prompts = True\noptions = [\"Option 1\", \"Option 2\", \"Option 3\"]\nsystem.prompt_answers[\"message_key_1\"] = (PromptResult.OK, PromptChoiceFilter(my_filter))\nsystem.ui.select_many(\"select many prompt\", PromptChoice.OKCancel, PromptResult.OK, options, message_key=\"message_key_1\") " }, 
{ "title" : "提示附加特定于应用程序的选择选项 ", 
"url" : "_script_message_handling_with_scripting.html#UUID-87499b2f-e086-5a74-affa-0d9fb0b6a357_section-id235153409608051", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 消息处理 CODESYS Scripting 脚本 \/ 提示附加特定于应用程序的选择选项 ", 
"snippet" : "在以下示例中，元组存储在 system.prompt_answers 其中首先包含 PromptResult 要使用的，其次包含一个类型的委托 PromptCustomControlValueProvider 。 例子 下面的例子展示了如何实现和存储这样的委托 system.prompt_answers 。可以通过以下方式读取各个子控件的 ID system.log_prompt_details 。 # filter function def my_filter(control_id):     if control_id = id_1:         return \"value_for_i...", 
"body" : "在以下示例中，元组存储在 system.prompt_answers 其中首先包含 PromptResult 要使用的，其次包含一个类型的委托 PromptCustomControlValueProvider 。 例子 下面的例子展示了如何实现和存储这样的委托 system.prompt_answers 。可以通过以下方式读取各个子控件的 ID system.log_prompt_details 。 # filter function\ndef my_filter(control_id):\n    if control_id = id_1:\n        return \"value_for_id_1\"\n    if control_id = id_2:\n        return \"value_for_id_2\" \n   return None\n\nsystem.prompt_answers[\"message_key_1\"] = (PromptResult.OK, PromptCustomControlValueProvider(my_filter)) " }, 
{ "title" : "限制 ", 
"url" : "_script_restrictions-2000869.html", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 限制 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "可重入脚本执行 ", 
"url" : "_script_restrictions-2000869.html#UUID-2796d574-fbea-140d-c18f-4700f86c503f_section-id235160169847221", 
"breadcrumbs" : "CODESYS Scripting \/ 使用脚本访问 CODESYS 功能 \/ 限制 \/ 可重入脚本执行 ", 
"snippet" : "在 CODESYS ，执行一个 IronPython 脚本可能意味着执行另一个嵌套的 IronPython 脚本。例如，一个脚本通过 执行脚本 命令和 system.commands 接口用于使用不同的脚本再次调用该命令。同样，这种脚本可以调用该命令来创建 CODESYS Test Manager 脚本本身包含脚本测试操作。我们将这些场景称为“可重入脚本执行”。 虽然这些方案通常有效，但它们在消息内存和显示方面受到限制。每次执行新的脚本都会从 脚本 消息类别。换句话说，只有来自最深层嵌套脚本执行的消息才会显示，直到脚本完成。如果脚本是使用控制台消息记录器执行的，这也适用（ noUI ）。...", 
"body" : "在 CODESYS ，执行一个 IronPython 脚本可能意味着执行另一个嵌套的 IronPython 脚本。例如，一个脚本通过 执行脚本 命令和 system.commands 接口用于使用不同的脚本再次调用该命令。同样，这种脚本可以调用该命令来创建 CODESYS Test Manager 脚本本身包含脚本测试操作。我们将这些场景称为“可重入脚本执行”。 虽然这些方案通常有效，但它们在消息内存和显示方面受到限制。每次执行新的脚本都会从 脚本 消息类别。换句话说，只有来自最深层嵌套脚本执行的消息才会显示，直到脚本完成。如果脚本是使用控制台消息记录器执行的，这也适用（ noUI ）。 " }, 
{ "title" : "CODESYS Scripting API ", 
"url" : "_script_api_documentation.html", 
"breadcrumbs" : "CODESYS Scripting \/ CODESYS Scripting API ", 
"snippet" : "CODESYS 脚本 API CODESYS Application Composer 脚本 API CODESYS Communication 脚本API CODESYS Git 脚本API CODESYS Recipes 脚本API CODESYS SVN 脚本 API CODESYS Trace 脚本API CODESYS Visualization 脚本 API CODESYS Visualization Support 脚本API CODESYS Automation Server Connector 脚本 API...", 
"body" : "CODESYS 脚本 API CODESYS Application Composer 脚本 API CODESYS Communication 脚本API CODESYS Git 脚本API CODESYS Recipes 脚本API CODESYS SVN 脚本 API CODESYS Trace 脚本API CODESYS Visualization 脚本 API CODESYS Visualization Support 脚本API CODESYS Automation Server Connector 脚本 API " }, 
{ "title" : "参考：菜单命令 ", 
"url" : "_script_ref_menu_commands.html", 
"breadcrumbs" : "CODESYS Scripting \/ 参考：菜单命令 ", 
"snippet" : "如果 CODESYS Scripting 安装后，您将在菜单中找到菜单命令 工具 , 子菜单 脚本 ....", 
"body" : "如果 CODESYS Scripting 安装后，您将在菜单中找到菜单命令 工具 , 子菜单 脚本 . " }, 
{ "title" : "命令：脚本 - 运行脚本文件 ", 
"url" : "_cds_cmd_execute_script_file.html", 
"breadcrumbs" : "CODESYS Scripting \/ 参考：菜单命令 \/ 命令：脚本 - 运行脚本文件 ", 
"snippet" : "脚本 - 运行脚本文件 象征： 功能 ：该命令打开一个对话框以选择脚本文件 (*.py)，然后执行选定的脚本文件。 称呼 ： 菜单 工具 有关详细信息，请参阅： 编写脚本...", 
"body" : "脚本 - 运行脚本文件 象征： 功能 ：该命令打开一个对话框以选择脚本文件 (*.py)，然后执行选定的脚本文件。 称呼 ： 菜单 工具 有关详细信息，请参阅： 编写脚本 " }, 
{ "title" : "命令：脚本 - 启用脚本跟踪 ", 
"url" : "_cds_cmd_activate_script_tracing.html", 
"breadcrumbs" : "CODESYS Scripting \/ 参考：菜单命令 \/ 命令：脚本 - 启用脚本跟踪 ", 
"snippet" : "脚本 - 启用脚本跟踪 象征： 功能 : 这个命令就是这样做的 CODESYS 在消息窗口中显示脚本文件的所有命令。使用该命令监视和调试脚本。图标周围的蓝框表示该选项已被激活。 称呼 ： 菜单 工具 有关详细信息，请参阅： 编写脚本...", 
"body" : "脚本 - 启用脚本跟踪 象征： 功能 : 这个命令就是这样做的 CODESYS 在消息窗口中显示脚本文件的所有命令。使用该命令监视和调试脚本。图标周围的蓝框表示该选项已被激活。 称呼 ： 菜单 工具 有关详细信息，请参阅： 编写脚本 " }, 
{ "title" : "命令：脚本：脚本 ", 
"url" : "_cds_cmd_scripts.html", 
"breadcrumbs" : "CODESYS Scripting \/ 参考：菜单命令 \/ 命令：脚本：脚本 ", 
"snippet" : "脚本：脚本 功能 ：该命令执行存储在 ScriptDir 文件夹。 称呼 ： 工具 菜单 要求 ： 在下面 C:\\Users\\<user name> \\AppData\\Local\\CODESYS ，您已创建一个名为 ScriptDir 。Python 脚本存储在此文件夹中， .py 文件扩展名。 所有包含在 ScriptDir 文件夹可作为菜单命令执行，并按文件名的字母顺序排序。 脚本列表每10秒刷新一次。 有关详细信息，请参阅以下内容： 编写脚本...", 
"body" : "脚本：脚本 功能 ：该命令执行存储在 ScriptDir 文件夹。 称呼 ： 工具 菜单 要求 ： 在下面 C:\\Users\\<user name> \\AppData\\Local\\CODESYS ，您已创建一个名为 ScriptDir 。Python 脚本存储在此文件夹中， .py 文件扩展名。 所有包含在 ScriptDir 文件夹可作为菜单命令执行，并按文件名的字母顺序排序。 脚本列表每10秒刷新一次。 有关详细信息，请参阅以下内容： 编写脚本 " }
]
$(document).trigger('search.ready');
});