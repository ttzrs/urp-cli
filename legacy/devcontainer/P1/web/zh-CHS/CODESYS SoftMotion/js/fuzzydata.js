$(document).ready(function () {indexDict['zh-CHS'] = [{ "title" : "CODESYS SoftMotion ", 
"url" : "_sm_start_page.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion ", 
"snippet" : "和 CODESYS SoftMotion ，您可以有效地创建 PLC 运动。这范围从简单的单轴运动或凸轮到多维的复杂运动。特别是，除了运动功能之外，还包括流量控制和过程控制的应用属于 CODESYS SoftMotion . 您可以下载 CODESYS SoftMotion 来自  CODESYS Store International  或者  CODESYS Store North America .在那里您还可以找到该产品的数据表。 也可以看看 CODESYS SoftMotion 在里面 CODESYS 论坛...", 
"body" : "和 CODESYS SoftMotion ，您可以有效地创建 PLC 运动。这范围从简单的单轴运动或凸轮到多维的复杂运动。特别是，除了运动功能之外，还包括流量控制和过程控制的应用属于 CODESYS SoftMotion . 您可以下载 CODESYS SoftMotion 来自  CODESYS Store International  或者  CODESYS Store North America .在那里您还可以找到该产品的数据表。 也可以看看 CODESYS SoftMotion 在里面 CODESYS 论坛 " }, 
{ "title" : "许可 ", 
"url" : "_sm_licensing.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ 许可 ", 
"snippet" : "除了一般的 许可软件指标 ，指标定义为 CODESYS SoftMotion 下载过程中会检查这些内容。 这 SoftMotion 指标是在编译期间计算的，当前值仅在之后显示在编辑器中。 确定的值适用于一种应用。当存在多个应用程序时，将各个应用程序的值相加。 团体 公制 确定值 轴数 实轴 度量的值由所使用的实轴和虚拟轴中的较大值定义。 示例：对于 3 个实轴和 4 个虚拟轴，应用程序中的值 = 4。 虚拟轴 轴组数和 CNC 插补器数 轴组 度量值由轴组和 CNC 插补器的总和定义。 示例：对于 2 个轴组和 2 个 CNC 插补器，应用程序中的值 = 4。 数控插补机...", 
"body" : "除了一般的 许可软件指标 ，指标定义为 CODESYS SoftMotion 下载过程中会检查这些内容。 这 SoftMotion 指标是在编译期间计算的，当前值仅在之后显示在编辑器中。 确定的值适用于一种应用。当存在多个应用程序时，将各个应用程序的值相加。 团体 公制 确定值 轴数 实轴 度量的值由所使用的实轴和虚拟轴中的较大值定义。 示例：对于 3 个实轴和 4 个虚拟轴，应用程序中的值 = 4。 虚拟轴 轴组数和 CNC 插补器数 轴组 度量值由轴组和 CNC 插补器的总和定义。 示例：对于 2 个轴组和 2 个 CNC 插补器，应用程序中的值 = 4。 数控插补机 " }, 
{ "title" : "的组成部分 CODESYS SoftMotion ", 
"url" : "_sm_components.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ 的组成部分 CODESYS SoftMotion ", 
"snippet" : "CODESYS SoftMotion 是一个软件包，用作运动控制的开发和运行环境。概述如下： 驱动配置 ：驱动配置提供了一个编辑器，您可以通过以下方式设置驱动硬件的结构和配置。 CODESYS 用户界面。此时，将创建一个 IEC 功能块的实例来表示驱动器。该功能块自动与驱动器通信，无需 IEC 程序员的额外工作。它负责传输更新的数据。 为了控制驱动器，IEC 程序可以通过 SoftMotion 图书馆。或者，您也可以为此开发自己的功能块。设置值（位置、速度、加速度等）由这些功能块循环写入。 注意： CODESYS SoftMotion Light 产品是标准安装的一部分 CODESYS .它提...", 
"body" : "CODESYS SoftMotion 是一个软件包，用作运动控制的开发和运行环境。概述如下： 驱动配置 ：驱动配置提供了一个编辑器，您可以通过以下方式设置驱动硬件的结构和配置。 CODESYS 用户界面。此时，将创建一个 IEC 功能块的实例来表示驱动器。该功能块自动与驱动器通信，无需 IEC 程序员的额外工作。它负责传输更新的数据。 为了控制驱动器，IEC 程序可以通过 SoftMotion 图书馆。或者，您也可以为此开发自己的功能块。设置值（位置、速度、加速度等）由这些功能块循环写入。 注意： CODESYS SoftMotion Light 产品是标准安装的一部分 CODESYS .它提供了控制轴的能力。这样， CODESYS 仅定义目标位置并等待轴控制器的响应。轴控制器负责运动规划。多轴的协调运动 CODESYS 不可能。 凸轮编辑器 ：在凸轮编辑器中，您可以用图形或表格的方式描述凸轮。 CODESYS 由此生成描述凸轮的数据结构的全局实例。这将传递给适用的 POU 可以访问它的应用程序。 数控编辑器 ：在 CNC 编辑器中，您可以生成多维运动。您可以使用文本编辑器（根据 DIN 66025）或图形编辑器创建 CNC 路径。作为文本编辑器的替代方案，您还可以在简化的表格视图中工作。 轴组配置 ：轴组定义多个机械相关轴之间的关系，这些轴共同定位和定向空间中的工具或工具板。使用配置器，您可以选择和配置要使用的运动学。此外，您可以分配 SoftMotion 轴。 这 SM3_Basic 图书馆是所有人的基本图书馆 SoftMotion 应用程序。具体来说，它包含以下内容： 符合 PLCopen 标准的 PLCopen 功能块 通过这些功能块，您可以控制单轴运动或两轴（电动凸轮、电动驱动器）的主\/从运动。 PLCopen 功能未涵盖的其他 FB 帮助功能：例如处理文件或错误消息 这 SM3_CNC 库是基于 SM3_Basic 图书馆。除了用于运动学变换的功能块外，它还提供了生成、执行和显示 CNC 运动所需的所有 POU。它还提供了用于路径预处理和路径重建的功能块。 这 SM3_Robotics 库包含符合 PLCopen 第 4 部分的机器人功能块和附加功能块。包含的 SM3_Transformations 库包含支持的运动学变换。 这 驱动接口 是一部分 SM3_Basic 库并负责IEC程序和驱动器之间的通信。对于支持的驱动器， CODESYS SoftMotion 提供实现此驱动器接口的库。 另请参阅应用示例的描述。 " }, 
{ "title" : "使用 CODESYS RTE V3 和 CODESYS WIN V3 控制器 ", 
"url" : "_sm_rtev3_winv3.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ 使用 CODESYS RTE V3 和 CODESYS WIN V3 控制器 ", 
"snippet" : "在 CODESYS Development System SP20 及更高版本， SoftMotion 控制器 CODESYS SoftMotion RTE V3 和 CODESYS SoftMotion Win V3 不再可用。 CODESYS Control RTE V3 和 CODESYS Control Win 现在使用 V3 控制器。这个 命令：启用 命令用于将标准控制器转换为 SoftMotion 控制器。...", 
"body" : "在 CODESYS Development System SP20 及更高版本， SoftMotion 控制器 CODESYS SoftMotion RTE V3 和 CODESYS SoftMotion Win V3 不再可用。 CODESYS Control RTE V3 和 CODESYS Control Win 现在使用 V3 控制器。这个 命令：启用 命令用于将标准控制器转换为 SoftMotion 控制器。 " }, 
{ "title" : "SoftMotion 多核处理器 ", 
"url" : "_sm_multicore_hint.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ SoftMotion 多核处理器 ", 
"snippet" : "通过将运动任务分布在多个处理器内核上，可以通过以下方式驱动更多轴或轴组 SoftMotion .因此，计算密集型任务，例如 CNC 路径预处理或 CP 运动的机器人路径规划，可以换出到另一个处理器内核。然后总线任务中有更多时间用于其他任务。单核控制器的计算能力不足的事实在机器人的情况下通过路径速度的无法解释的下降得到证明。 系统要求 SM V4.5.1.0 或更高版本 编译器 V3.5.12.0 或更高版本 多核兼容的运行时系统 用法 机器人和 CNC：将规划和总线任务设置到不同的处理器内核 使用不同的总线系统时，将各个总线任务设置到不同的处理器内核 使用多个任务和多个处理器内核时，请注意以下...", 
"body" : "通过将运动任务分布在多个处理器内核上，可以通过以下方式驱动更多轴或轴组 SoftMotion .因此，计算密集型任务，例如 CNC 路径预处理或 CP 运动的机器人路径规划，可以换出到另一个处理器内核。然后总线任务中有更多时间用于其他任务。单核控制器的计算能力不足的事实在机器人的情况下通过路径速度的无法解释的下降得到证明。 系统要求 SM V4.5.1.0 或更高版本 编译器 V3.5.12.0 或更高版本 多核兼容的运行时系统 用法 机器人和 CNC：将规划和总线任务设置到不同的处理器内核 使用不同的总线系统时，将各个总线任务设置到不同的处理器内核 使用多个任务和多个处理器内核时，请注意以下几点： CNC 规划任务中的功能块被允许在 CNC 规划任务中获得新的上升优势 Execute 仅在插值器的特定状态下输入 ( iStatus 输出）。这也适用于单核 首次公开募股_未知 IPO_WAIT IPO_FINISHED IPO_INIT（仅用于首次启动，不适用于重新启动） 相互依赖的轴（轴组、凸轮和 CNC 运动学）的总线任务必须在同一个处理器内核上运行。 " }, 
{ "title" : "CODESYS SoftMotion Drives ", 
"url" : "_sm_f_drive_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SoftMotion 驱动器配置 ", 
"url" : "_sm_f_drive_configuration.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion 驱动器配置 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_sm_overview_drive_configuration.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion 驱动器配置 \/ 概述 ", 
"snippet" : "SoftMotion 驱动器接口是一种标准化接口，可用于在 IEC 程序中链接、配置和寻址驱动器硬件。通过将不同的硬件映射到一个接口，您可以轻松交换驱动器并重复使用 IEC 程序。该接口将驱动器与 I\/O 映射耦合，并负责更新和传输所需的运动数据到驱动器控制。 驱动器接口由以下组件组成： 设备描述 SoftMotion 设备在设备树中的表示 设备描述中引用的库，用于扩展或重载基本功能块 AXIS_REF_SM3 根据具体驱动类型的要求 包含非循环读取和写入数据的功能块的库，用于包装现场总线驱动程序的标准功能 如果你使用 SoftMotion PLC，例如 CODESYS SoftMotion ...", 
"body" : "SoftMotion 驱动器接口是一种标准化接口，可用于在 IEC 程序中链接、配置和寻址驱动器硬件。通过将不同的硬件映射到一个接口，您可以轻松交换驱动器并重复使用 IEC 程序。该接口将驱动器与 I\/O 映射耦合，并负责更新和传输所需的运动数据到驱动器控制。 驱动器接口由以下组件组成： 设备描述 SoftMotion 设备在设备树中的表示 设备描述中引用的库，用于扩展或重载基本功能块 AXIS_REF_SM3 根据具体驱动类型的要求 包含非循环读取和写入数据的功能块的库，用于包装现场总线驱动程序的标准功能 如果你使用 SoftMotion PLC，例如 CODESYS SoftMotion Win ，则基础库会自动链接到库管理器中。这些类型的控制器提供了 SoftMotion 通用轴池 . 您可以在此处插入空闲的驱动单元。 " }, 
{ "title" : "耦合驱动单元 ", 
"url" : "_sm_inserting_connected_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion 驱动器配置 \/ 耦合驱动单元 ", 
"snippet" : "耦合驱动器属于在现场总线拓扑中代表驱动器的设备。这些驱动器的符号有一个小标记，指示相应的现场总线类型。例如，每个标准伺服驱动器都通过现场总线连接到控制器。 使用驱动器时， CODESYS SoftMotion 提供现场总线主站的特定设备描述（“_SoftMotion”后缀）。这些优化了驱动器的基本参数。 对于使用 CODESYS SoftMotion ，必须在驱动器中停用模数处理。模数处理由 CODESYS SoftMotion 在控制器中。如果可能，最大行程范围应设置为 32 位。 添加耦合驱动设备 (EtherCAT) 要求：将 SoftMotion 兼容的控制器插入到项目中。 选择 So...", 
"body" : "耦合驱动器属于在现场总线拓扑中代表驱动器的设备。这些驱动器的符号有一个小标记，指示相应的现场总线类型。例如，每个标准伺服驱动器都通过现场总线连接到控制器。 使用驱动器时， CODESYS SoftMotion 提供现场总线主站的特定设备描述（“_SoftMotion”后缀）。这些优化了驱动器的基本参数。 对于使用 CODESYS SoftMotion ，必须在驱动器中停用模数处理。模数处理由 CODESYS SoftMotion 在控制器中。如果可能，最大行程范围应设置为 32 位。 添加耦合驱动设备 (EtherCAT) 要求：将 SoftMotion 兼容的控制器插入到项目中。 选择 SoftMotion 设备树中的控制器。 在上下文菜单中，单击 添加设备 . 在里面 添加设备 对话框，选择 现场总线 → EtherCAT → 主站 → EtherCAT 主站 SoftMotion 设备。 点击 添加设备 按钮。 设备被添加到设备树中。这 添加设备 对话框保持打开状态。 选择您刚刚添加到设备树中的设备。 在里面 添加设备 对话框中，选择一个 SoftMotion 从站 ( 现场总线 → EtherCAT → 从站 → <SoftMotion 驱动器> ）。 点击 添加设备 按钮。 设备被添加到设备树中。 双击设备会打开相应的设备编辑器。 " }, 
{ "title" : "编码器轴 ", 
"url" : "_sm_encoder_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion 驱动器配置 \/ 编码器轴 ", 
"snippet" : "编码器轴用于将编码器值转换为 SoftMotion 轴，该轴可用作主轴 MC_CamIn ， MC_GearIn ，以及其他主\/从功能块。 编码器轴可以代表来自驱动单元的附加编码器。在这种情况下，它们被配置为设备树中现场总线设备下的特殊编码器轴。或者，可以免费使用编码器 通用轴池 也可以使用模拟输入作为编码器轴。 有关更多信息，请参阅： 免费编码器属性 与逻辑轴类似，编码器轴是 “只读” 的。它们仅提供位置和速度值。不能命令他们采取任何行动 编码器轴的轴状态始终为 standstill 。 这是运动控制第 1 部分的 PLCOpen 的状态，最为匹配。根据状态图，这种状态意味着轴已准备就绪且没...", 
"body" : "编码器轴用于将编码器值转换为 SoftMotion 轴，该轴可用作主轴 MC_CamIn ， MC_GearIn ，以及其他主\/从功能块。 编码器轴可以代表来自驱动单元的附加编码器。在这种情况下，它们被配置为设备树中现场总线设备下的特殊编码器轴。或者，可以免费使用编码器 通用轴池 也可以使用模拟输入作为编码器轴。 有关更多信息，请参阅： 免费编码器属性 与逻辑轴类似，编码器轴是 “只读” 的。它们仅提供位置和速度值。不能命令他们采取任何行动 编码器轴的轴状态始终为 standstill 。 这是运动控制第 1 部分的 PLCOpen 的状态，最为匹配。根据状态图，这种状态意味着轴已准备就绪且没有错误。此外，PLC 指挥的所有动作在轴上均不处于活动状态 请注意，以前 CODESYS SoftMotion 版本 4.18.0.0 编码器轴处于状态 power_off 。但是，什么时候 MC_Power 是来找他们的，他们处于一个状态 standstill 。 编码器轴的零位置可以通过以下公式进行偏移 MC_SetPosition 。 主\/从功能块始终使用编码器轴的实际值。 编码器轴下方的逻辑轴可用于死区时间补偿。 使用编码器轴时，无需调用 MC_Power ，而且它对编码器轴的行为没有区别 CODESYS SoftMotion 版本 4.18.0.0 及更高版本。 " }, 
{ "title" : "插入自由驱动单元 ", 
"url" : "_sm_f_free_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion 驱动器配置 \/ 插入自由驱动单元 ", 
"snippet" : "自由驱动单元不会与设备树中的其他设备永久耦合。它们被插入到下面的设备树中 SoftMotion 通用驱动池 ....", 
"body" : "自由驱动单元不会与设备树中的其他设备永久耦合。它们被插入到下面的设备树中 SoftMotion 通用驱动池 . " }, 
{ "title" : "驱动控制“Drive_PosControl” ", 
"url" : "_sm_drive_controller_drive_poscontrol.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion 驱动器配置 \/ 插入自由驱动单元 \/ 驱动控制“Drive_PosControl” ", 
"snippet" : "随着 Drive_PosControl 驱动控制，可以让一个轴的位置控制 CODESYS 继续运行。要求是由设定速度控制并返回其当前位置的设备。例如，这可以是具有位置反馈的速度控制设备（变频器）。 添加驱动控制 要求：将 SoftMotion 控制器插入到项目中。 在设备树中，选择 SoftMotion 通用轴池 . 在上下文菜单中，单击 添加设备 . 在里面 添加设备 对话框，选择 SoftMotion 驱动器 → 位置控制驱动器 → SMC_Drive_PosControl 设备。 点击 添加设备 按钮。 设备被添加到设备树中。 双击设备打开相应的设备编辑器。 有关详细信息，请参阅： 标签...", 
"body" : "随着 Drive_PosControl 驱动控制，可以让一个轴的位置控制 CODESYS 继续运行。要求是由设定速度控制并返回其当前位置的设备。例如，这可以是具有位置反馈的速度控制设备（变频器）。 添加驱动控制 要求：将 SoftMotion 控制器插入到项目中。 在设备树中，选择 SoftMotion 通用轴池 . 在上下文菜单中，单击 添加设备 . 在里面 添加设备 对话框，选择 SoftMotion 驱动器 → 位置控制驱动器 → SMC_Drive_PosControl 设备。 点击 添加设备 按钮。 设备被添加到设备树中。 双击设备打开相应的设备编辑器。 有关详细信息，请参阅： 标签：常规" }, 
{ "title" : "逻辑驱动器 ", 
"url" : "_sm_drive_controller_logical_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion 驱动器配置 \/ 插入自由驱动单元 \/ 逻辑驱动器 ", 
"snippet" : "您可以将逻辑驱动器添加到任何类型的驱动器单元。逻辑驱动器的轴反映其主轴的运动，同时它代表一个独立实例。 这允许在其上执行以下指令而不影响主轴。 MC_SetPosition ：将位置设置为定义的值（例如：0） MC_TouchProbe ：保存触发信号的当前轴位置 MC_AbortTrigger ：停用之前使用 MC_TouchProbe 一种应用是通过多个加工站的传送带。通过外部信号（例如光栅）检测组件的位置，并将轴设置到定义的位置（测头功能）。逻辑驱动器提供过滤信号的能力。因此，逻辑驱动器也可以与提供噪声信号的编码器一起使用。 添加逻辑驱动器 要求：将 SoftMotion 控制器插入到项...", 
"body" : "您可以将逻辑驱动器添加到任何类型的驱动器单元。逻辑驱动器的轴反映其主轴的运动，同时它代表一个独立实例。 这允许在其上执行以下指令而不影响主轴。 MC_SetPosition ：将位置设置为定义的值（例如：0） MC_TouchProbe ：保存触发信号的当前轴位置 MC_AbortTrigger ：停用之前使用 MC_TouchProbe 一种应用是通过多个加工站的传送带。通过外部信号（例如光栅）检测组件的位置，并将轴设置到定义的位置（测头功能）。逻辑驱动器提供过滤信号的能力。因此，逻辑驱动器也可以与提供噪声信号的编码器一起使用。 添加逻辑驱动器 要求：将 SoftMotion 控制器插入到项目中。 在设备树中选择一个驱动单元。 在上下文菜单中，单击 添加设备 . 在里面 添加设备 对话框，选择 SoftMotion 驱动器 → 虚拟驱动器 → SM_Drive_Logical 设备。 点击 添加设备 按钮。 设备被添加到设备树中。 双击设备打开相应的设备编辑器。 " }, 
{ "title" : "虚拟驱动器 ", 
"url" : "_sm_drive_controller_virtual_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion 驱动器配置 \/ 插入自由驱动单元 \/ 虚拟驱动器 ", 
"snippet" : "虚拟驱动器是软件中的模拟驱动器。有了这个，您可以在没有连接硬件的情况下测试您的程序或实现扩展功能。这些类型的功能包括，例如，控制轴运动的超驰和空间中机器人的手动笛卡尔方法。 有关详细信息，请参阅： 使用虚拟时间轴控制凸轮驱动器虚拟驱动器使用先前周期的设定位置来计算循环开始时位置、速度和加速度等实际值，从而模拟物理驱动器。需要物理驱动器的功能，例如 MC_TouchProbe 在驱动器中或使用中 SMC_SetControllerMode ，不支持。 添加虚拟驱动器 要求：将 SoftMotion 控制器插入到项目中。 在设备树中，选择 SoftMotion 通用轴池 . 在上下文菜单中，单击 ...", 
"body" : "虚拟驱动器是软件中的模拟驱动器。有了这个，您可以在没有连接硬件的情况下测试您的程序或实现扩展功能。这些类型的功能包括，例如，控制轴运动的超驰和空间中机器人的手动笛卡尔方法。 有关详细信息，请参阅： 使用虚拟时间轴控制凸轮驱动器虚拟驱动器使用先前周期的设定位置来计算循环开始时位置、速度和加速度等实际值，从而模拟物理驱动器。需要物理驱动器的功能，例如 MC_TouchProbe 在驱动器中或使用中 SMC_SetControllerMode ，不支持。 添加虚拟驱动器 要求：将 SoftMotion 控制器插入到项目中。 在设备树中，选择 SoftMotion 通用轴池 . 在上下文菜单中，单击 添加设备 . 在里面 添加设备 对话框，选择 SoftMotion 驱动器 → 虚拟驱动器 → SM_Drive_Virtual 设备。 点击 添加设备 按钮。 设备被添加到设备树中。 双击设备打开相应的设备编辑器。 " }, 
{ "title" : "免费编码器 ", 
"url" : "_sm_drive_controller_free_encoder.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion 驱动器配置 \/ 插入自由驱动单元 \/ 免费编码器 ", 
"snippet" : "使用 免费编码器 用于集成未永久耦合到 I\/O 或硬件的编码器。 添加免费编码器 在设备树中，选择 SoftMotion 通用轴池 . 在上下文菜单中，单击 添加设备 . 在里面 添加设备 对话框，选择 SoftMotion 驱动器 → 自由编码器 → SMC_FreeeEncoder 设备。 点击 添加设备 按钮。 设备被添加到设备树中。 打开编码器 编辑 . 使设置适应硬件并设置位宽和缩放。 将编码器的输入值分配给 <FREE_ENCODER_AXIS>.diEncoderPosition 多变的。这可以作为 IEC 代码或通过映射输入数据的内存来实现。 在现场总线初始化期间，该输入可能会...", 
"body" : "使用 免费编码器 用于集成未永久耦合到 I\/O 或硬件的编码器。 添加免费编码器 在设备树中，选择 SoftMotion 通用轴池 . 在上下文菜单中，单击 添加设备 . 在里面 添加设备 对话框，选择 SoftMotion 驱动器 → 自由编码器 → SMC_FreeeEncoder 设备。 点击 添加设备 按钮。 设备被添加到设备树中。 打开编码器 编辑 . 使设置适应硬件并设置位宽和缩放。 将编码器的输入值分配给 <FREE_ENCODER_AXIS>.diEncoderPosition 多变的。这可以作为 IEC 代码或通过映射输入数据的内存来实现。 在现场总线初始化期间，该输入可能会产生无效值。您可以使用 b延迟激活 输入以禁用输入的评估，直到有效值可用。 现在您可以像使用驱动器一样使用编码器了。 有关更多信息，请参阅： 编码器轴" }, 
{ "title" : "以编程方式创建坐标区 ", 
"url" : "_sm_programmatic_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion 驱动器配置 \/ 插入自由驱动单元 \/ 以编程方式创建坐标区 ", 
"snippet" : "也可以通过编程方式创建以下空闲驱动单元： 斧头 SMC_VIRTUAL_AXIS 无需将其添加到设备树中即可创建虚拟轴 有关更多信息，请参阅以下内容： 虚拟驱动器SMC_Logical_axis 无需将其添加到设备树中即可创建逻辑轴。 有关更多信息，请参阅以下内容： 逻辑驱动器SMC_FreeEncod 无需将其添加到设备树中即可创建编码器轴 有关更多信息，请参阅以下内容： 免费编码器...", 
"body" : "也可以通过编程方式创建以下空闲驱动单元： 斧头 SMC_VIRTUAL_AXIS 无需将其添加到设备树中即可创建虚拟轴 有关更多信息，请参阅以下内容： 虚拟驱动器SMC_Logical_axis 无需将其添加到设备树中即可创建逻辑轴。 有关更多信息，请参阅以下内容： 逻辑驱动器SMC_FreeEncod 无需将其添加到设备树中即可创建编码器轴 有关更多信息，请参阅以下内容： 免费编码器" }, 
{ "title" : "支持的驱动器 ", 
"url" : "_sm_drives_supported_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 支持的驱动器 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "支持的驱动器：EtherCAT ", 
"url" : "_sm_drives_supported_drives_ethercat.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 支持的驱动器 \/ 支持的驱动器：EtherCAT ", 
"snippet" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control...", 
"body" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control Techniques Mentor Control Techniques Unidrive M Copley Accelnet Danfoss ISD 520 Delta ASDA A2 Delta ASDA A3 Delta ASDA B3 Delta R1-EC5621 Festo CMMP EtherCAT 通用 CiA 402 驱动程序：参见 通用 Cia402 轴的配置Generischer SoE Treiber (auch für mehrachsige Antriebe) Hitachi ADV series Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB H6 KEBA KeDrive D3 Kollmorgen AKD Kollmorgen AKD-N\/C Kollmorgen MKD-N\/C Kollmorgen AKD2G Kollmorgen KED Metronix ARS 2000-Serie Mitsubishi Melservo MR-J5 Mitsubishi Melservo MR-JET Omron G5 Panasonic MINAS A5B Panasonic MINAS A6B Panasonic MINAS A6 MultiDrive Parker compax3 Parker SBC Parker PSD Sanyo Denki RS2 Schneider Electric Lexium32 Schneider Electric Lexium32i Servotronix CDHD Stäubli uniVAL Stöber Posidrive Stöber SD6 Stöber SI6\/SC6 WEG SCA06 Yaskawa Sigma7 series " }, 
{ "title" : "支持的驱动器：CAN ", 
"url" : "_sm_drives_supported_drives_can.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 支持的驱动器 \/ 支持的驱动器：CAN ", 
"snippet" : "能够 Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP 通用 CiA 402 驱动程序：参见 通用 Cia402 轴的配置Infranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schneider Electric Lexium05 Schneider Electric Lexi...", 
"body" : "能够 Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP 通用 CiA 402 驱动程序：参见 通用 Cia402 轴的配置Infranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schneider Electric Lexium05 Schneider Electric Lexium23 Schneider Electric Lexium28 Schneider Electric Lexium32 Schneider Electric Lexium32i Schneider Electric SD-3 " }, 
{ "title" : "用例 ", 
"url" : "_sm_f_use_cases_drive_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用例 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "标准用例 ", 
"url" : "_sm_special_use_cases.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用例 \/ 标准用例 ", 
"snippet" : "这 SM3_Basic 库包含不通过标准设置\/实际值接口与驱动器交互的上级功能块。这些功能块通过读取或写入实例的参数来提供命令或更改驱动器的设置 AXIS_REF_SM3 ....", 
"body" : "这 SM3_Basic 库包含不通过标准设置\/实际值接口与驱动器交互的上级功能块。这些功能块通过读取或写入实例的参数来提供命令或更改驱动器的设置 AXIS_REF_SM3 . " }, 
{ "title" : "重新初始化驱动器 ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_0e9f93f91e8d4c6dc0a8640e01d50c94", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用例 \/ 标准用例 \/ 重新初始化驱动器 ", 
"snippet" : "如果您在运行时更改了驱动器参数，则需要重新初始化驱动器。示例：更改旋转驱动器的缩放系数或模周期。通过致电 smc3_reinitDrive 带有上升边缘的功能块 Execute 输入， wCommuncationState 驱动器的参数被重置，并重复驱动器的整个启动过程。 重新初始化必须等到轴达到所需状态 SMC_COMSTATE_BASE_COM_INITIALIZATION 或更高。否则会输出错误 SMC_RAG_ERROR_AXIS_NOT_INITIALIZED . 如果下级现场总线的通信中断，则不再需要明确的重新初始化 CODESYS SoftMotion 版本 4.18.0.0 及...", 
"body" : "如果您在运行时更改了驱动器参数，则需要重新初始化驱动器。示例：更改旋转驱动器的缩放系数或模周期。通过致电 smc3_reinitDrive 带有上升边缘的功能块 Execute 输入， wCommuncationState 驱动器的参数被重置，并重复驱动器的整个启动过程。 重新初始化必须等到轴达到所需状态 SMC_COMSTATE_BASE_COM_INITIALIZATION 或更高。否则会输出错误 SMC_RAG_ERROR_AXIS_NOT_INITIALIZED . 如果下级现场总线的通信中断，则不再需要明确的重新初始化 CODESYS SoftMotion 版本 4.18.0.0 及更高版本。一旦恢复现场总线通信，轴就会自动重新初始化。在版本 4.18.0.0 之前，在现场总线的通信中断后，明确调用 SMC3_ReinitDrive 是必要的（错误 SMC_DI_GENERAL_COMMUNICATION_ERROR ) 一旦现场总线通信恢复。 可以通过设置来恢复旧的行为 AutoRestart 的输入 SMC_AxisChangeSettings 功能块到 SMC_AXIS_AUTORESTART_MODE.OFF 。 " }, 
{ "title" : "打开和关闭驱动器 ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_bd45abb41e8d4c6dc0a8640e01589872", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用例 \/ 标准用例 \/ 打开和关闭驱动器 ", 
"snippet" : "这 bRegulatorOn 和 bDriveStart 的参数 AXIS_REF_SM3 功能块控制驱动器的性能水平和减速度。访问是通过 MC_Power 功能块。 要释放输出级，您必须设置 bRegulatorOn 的参数 MC_Power 功能块。驱动器通过 bRegulatorRealState 输出。如果驱动器支持，则 bRegulatorOn 在运动过程中重置将立即停用扭矩。在这种情况下，功能块会报告错误并将轴设置为 errorstop 状态。 这 bDriveStart 变量确定是否允许驱动器移动。该参数的当前状态位于 bDriveStartRealState . 如果驱动器支持...", 
"body" : "这 bRegulatorOn 和 bDriveStart 的参数 AXIS_REF_SM3 功能块控制驱动器的性能水平和减速度。访问是通过 MC_Power 功能块。 要释放输出级，您必须设置 bRegulatorOn 的参数 MC_Power 功能块。驱动器通过 bRegulatorRealState 输出。如果驱动器支持，则 bRegulatorOn 在运动过程中重置将立即停用扭矩。在这种情况下，功能块会报告错误并将轴设置为 errorstop 状态。 这 bDriveStart 变量确定是否允许驱动器移动。该参数的当前状态位于 bDriveStartRealState . 如果驱动器支持，则 bDriveStart 参数复位会在运动期间使用配置的斜坡（“QuickStop”）使驱动器减速。之后，只要设置为，驱动器就会在到达的位置停止 bRegulatorOn .轴保持在 stopping 只要“QuickStop”机制处于活动状态（ bDriveStart 输入 = 假）。如果驱动器之前已被功能块移动，那么现在将显示 CommandAborted .这不适用于 MC_Stop 报告错误并将轴设置为 errorstop 状态。 " }, 
{ "title" : "处理机械制动器 ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_6670a1571e8d4c6ec0a8640e01f5eecb", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用例 \/ 标准用例 \/ 处理机械制动器 ", 
"snippet" : "如果驱动器支持，则 eBrakeControl 变量可以通过设置或重置 SMC3_BrakeControl 功能块。三种不同的模式是可能的。 SMC3_BrakeSetState SMC_BRAKE_AUTO ：制动器的状态由驱动器控制。 SMC_BRAKE_OPEN : 制动器打开。 SMC_BRAKE_CLOSE : 制动器关闭。 这 bBrakeClosedRealState 变量报告制动器的当前状态。 从的角度来看 SoftMotion ，控制以及机械制动器的状态不依赖于驱动器的状态或运行运动。...", 
"body" : "如果驱动器支持，则 eBrakeControl 变量可以通过设置或重置 SMC3_BrakeControl 功能块。三种不同的模式是可能的。 SMC3_BrakeSetState SMC_BRAKE_AUTO ：制动器的状态由驱动器控制。 SMC_BRAKE_OPEN : 制动器打开。 SMC_BRAKE_CLOSE : 制动器关闭。 这 bBrakeClosedRealState 变量报告制动器的当前状态。 从的角度来看 SoftMotion ，控制以及机械制动器的状态不依赖于驱动器的状态或运行运动。 " }, 
{ "title" : "更改控制器模式 ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_959f85271e8d4c6ec0a8640e01ed4fcb", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用例 \/ 标准用例 \/ 更改控制器模式 ", 
"snippet" : "随着 smc_setControllerMode 功能块，你可以在不同的控制器模式之间切换。这个 byControllerMode 和 byRealControllerMode 参数来自 AXIS_REF_SM3 代表所需的模式和控制器的当前模式。 可能的值 SMC_nocontrol SoftMotion 不向驱动器发送循环数据。这使得以其他方式控制驱动器成为可能。 SMC_torque 扭矩\/力控制 SMC_velocity 速度控制 SMC_position , 位置控制 写完之后 byControllerMode 变量，将检查当前模式，直到它匹配所需的控制器模式。 该功能块计算设定值，...", 
"body" : "随着 smc_setControllerMode 功能块，你可以在不同的控制器模式之间切换。这个 byControllerMode 和 byRealControllerMode 参数来自 AXIS_REF_SM3 代表所需的模式和控制器的当前模式。 可能的值 SMC_nocontrol SoftMotion 不向驱动器发送循环数据。这使得以其他方式控制驱动器成为可能。 SMC_torque 扭矩\/力控制 SMC_velocity 速度控制 SMC_position , 位置控制 写完之后 byControllerMode 变量，将检查当前模式，直到它匹配所需的控制器模式。 该功能块计算设定值，直到驱动器确认新模式为止。驱动器确认新模式后， bDone 输出已设置并且 SMC_SetControllerMode 不再写入设定值。这必须使用其他功能块来完成。 示例： bDone 输出连接到 Execute 功能块的输入，例如 MC_MoveVelocity ， MC_MoveAbsolute ，或 MC_Halt 。否则，该轴将在模式更改后立即停止。请注意，死区时间用于计算设定位置。有关更多信息，请参阅以下内容： 实际值、设定值和空闲时间。 " }, 
{ "title" : "归位（驱动控制） ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_7fa66d251e8d4c6fc0a8640e00782f3b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用例 \/ 标准用例 \/ 归位（驱动控制） ", 
"snippet" : "在 SoftMotion ，有两种方法可以引用驱动器： 由 PLC 中的控制器参考：此参考是通过调用 SMC_Homing  功能块。参考信号必须是控制单元 I\/O 映射的一部分。在回参考点时，驱动器保持在“位置控制”控制模式。一般来说，这种方法不是特别准确，因为检测位置（当参考开关被激活时）是基于驱动器获得的当前位置。结果，准确性受到通信周期的限制。 通过驱动器中的控制器进行参考：参考开关连接到驱动器。它的位置检测速度更快，精度更高。在驱动器控制的参考路径期间，驱动器处于另一种控制模式，其中驱动器由内部过程控制，并且不遵循控制单元的设定值。当参考路径结束时，驱动器将重置为其原始控制模式。 这...", 
"body" : "在 SoftMotion ，有两种方法可以引用驱动器： 由 PLC 中的控制器参考：此参考是通过调用 SMC_Homing  功能块。参考信号必须是控制单元 I\/O 映射的一部分。在回参考点时，驱动器保持在“位置控制”控制模式。一般来说，这种方法不是特别准确，因为检测位置（当参考开关被激活时）是基于驱动器获得的当前位置。结果，准确性受到通信周期的限制。 通过驱动器中的控制器进行参考：参考开关连接到驱动器。它的位置检测速度更快，精度更高。在驱动器控制的参考路径期间，驱动器处于另一种控制模式，其中驱动器由内部过程控制，并且不遵循控制单元的设定值。当参考路径结束时，驱动器将重置为其原始控制模式。 这 MC_Home  功能块通过设置启动驱动器控制的参考路径 fReference 和 bStartReference .此外，状态 AXIS_REF_SM3 ( wState ） 设定为 homing .当驱动器通过参考路径（意味着它不再遵循控制单元指定的值）时，驱动器将参数设置为 TRUE .为了显示参考路径的结尾，驱动程序设置 bStartReference 和 bStartReferenceRealState 到 FALSE . " }, 
{ "title" : "闩锁 ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_index_14", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用例 \/ 标准用例 \/ 闩锁 ", 
"snippet" : "您可以通过多种方式检测轴的位置，具体取决于驱动器支持的驱动器功能： 驱动器本身检测轴位置（集成或通过打开外部传感器）。因为实际位置是由驱动器本身传送的，所以信号的传送时间最短且精确。 轴的当前位置独立于驱动器确定，并通过输入传输到控制器。控制器输入的发生延迟和应用程序周期使这种方法不太精确。 传输驱动器本身的位置时，通常由相应的驱动器在应用程序中直接处理，具体取决于制造商。要确定这种轴的位置，可以使用 MC_TouchProbe 功能块。它允许将轴位置记录到可配置的触发器和位置窗口内。如果驱动器不传输位置，则必须将其传递给驱动器的设备驱动程序，例如用于控制。 有关详细信息，请参阅： 使用 SM...", 
"body" : "您可以通过多种方式检测轴的位置，具体取决于驱动器支持的驱动器功能： 驱动器本身检测轴位置（集成或通过打开外部传感器）。因为实际位置是由驱动器本身传送的，所以信号的传送时间最短且精确。 轴的当前位置独立于驱动器确定，并通过输入传输到控制器。控制器输入的发生延迟和应用程序周期使这种方法不太精确。 传输驱动器本身的位置时，通常由相应的驱动器在应用程序中直接处理，具体取决于制造商。要确定这种轴的位置，可以使用 MC_TouchProbe 功能块。它允许将轴位置记录到可配置的触发器和位置窗口内。如果驱动器不传输位置，则必须将其传递给驱动器的设备驱动程序，例如用于控制。 有关详细信息，请参阅： 使用 SM_Drive_PosControl 对控制器进行位置控制" }, 
{ "title" : "保持轴位置 ", 
"url" : "_sm_storing_axis_position_persistently.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用例 \/ 保持轴位置 ", 
"snippet" : "具有绝对编码器的轴可以保存位置，以便它在重新启动控制器后保持其先前的位置。不需要进行自控。这个 SMC3_PersistPosition 和 SMC3_PersistPositionLogical 功能块提供保存操作的功能。必要的数据保存在中 SMC3_PersistPosition_Data 和 SMC3_PersistPositionLogical_Data 。 这个 bPositionStored 输出表明内容是否为 PersistentData 已经改变了。这发生在不同的时间，具体取决于持久性的类型。 编码器保留的值范围必须配置为 SMC_PersistPosition.maxPers...", 
"body" : "具有绝对编码器的轴可以保存位置，以便它在重新启动控制器后保持其先前的位置。不需要进行自控。这个 SMC3_PersistPosition 和 SMC3_PersistPositionLogical 功能块提供保存操作的功能。必要的数据保存在中 SMC3_PersistPosition_Data 和 SMC3_PersistPositionLogical_Data 。 这个 bPositionStored 输出表明内容是否为 PersistentData 已经改变了。这发生在不同的时间，具体取决于持久性的类型。 编码器保留的值范围必须配置为 SMC_PersistPosition.maxPersistedValue 输入。对于多圈编码器，该值设置为 16#FFFFFFFFFF 。例如，对于 12 位单圈编码器，该值设置为 2^12 = 40 有关更多信息，请参阅： 数据持久性 通过声明使实例持久化为 VAR_PERSISTENT 或 Application Composer 的 Persistence Manager。 保持逻辑轴的轴位置 要求：轴是合乎逻辑的。 使用 smc3_persistPositionLogic 使逻辑轴的位置保持不变的功能块。仅当上级物理轴的位置保持不变时，这才有效。无法通过这些 FB 使虚拟轴的位置 创建的实例 SMC3_PersistPositionLogical 轴的功能块。 ppl: SM3_BASIC.SMC3_PersistPositionLogical; 实例化一个持久化的数据结构 SMC3_PersistPositionLogical_Data 类型。 ppl_Data: SMC3_PersistPositionLogical_Data; 扩展运动任务的程序，以便调用 SMC3_PersistPositionLogical 实例被实现并且持久化数据类型 SMC3_PersistPositionLogical_Data 传递给它。 " }, 
{ "title" : "使用物理轴保持多圈绝对编码器的轴位置 ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_49c53944c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用例 \/ 保持轴位置 \/ 使用物理轴保持多圈绝对编码器的轴位置 ", 
"snippet" : "要求：轴有一个多圈绝对值编码器。 使用 SMC3_PersistPosition FB 使物理轴的位置保持不变。相应的程序在运动任务中运行。 创建的实例 SMC3_PersistPosition 轴的功能块。 pp: SM3_BASIC.SMC3_PersistPosition; 实例化一个持久化的数据结构 SMC3_PersistPosition_Data 类型。 pp_Data: SM3_BASIC.SMC3_PersistPosition_Data1; 扩展运动任务的程序，以便调用 SMC3_PersistPosition 实例在那里实现。 在 CFC 中实现的调用： 功能块与运动任务一...", 
"body" : "要求：轴有一个多圈绝对值编码器。 使用 SMC3_PersistPosition FB 使物理轴的位置保持不变。相应的程序在运动任务中运行。 创建的实例 SMC3_PersistPosition 轴的功能块。 pp: SM3_BASIC.SMC3_PersistPosition; 实例化一个持久化的数据结构 SMC3_PersistPosition_Data 类型。 pp_Data: SM3_BASIC.SMC3_PersistPosition_Data1; 扩展运动任务的程序，以便调用 SMC3_PersistPosition 实例在那里实现。 在 CFC 中实现的调用： 功能块与运动任务一起循环调用。这 SMC3_PersistPosition 实例在启动操作期间执行已保存位置的恢复。在正常操作中，FB 将实际位置保存在各自的数据结构中。 " }, 
{ "title" : "带物理轴的单圈绝对值编码器轴位保持 ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_a4cc9967c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用例 \/ 保持轴位置 \/ 带物理轴的单圈绝对值编码器轴位保持 ", 
"snippet" : "要求：物理轴有一个单圈绝对值编码器。 使用 smc3_persistPosition 使轴的位置保持不变的功能块。相应的程序在运动任务中运行。只有当轴在关闭和打开控制器之间没有移动任何距离或只有很短的距离（最大为单圈距离的一半）时，才能正确显示位置。例如，您可以使用机械制动器来执行此操作。如果在控制器关闭时轴大幅移动，则其位置不正确。无法通过 FB 进行检查 创建的实例 SMC3_PersistPosition 轴的功能块。 ppst_X: SM3_BASIC.SMC3_PersistPositionSinglturn; 对的持久数据结构进行实例化 SMC3_PersistPosition_D...", 
"body" : "要求：物理轴有一个单圈绝对值编码器。 使用 smc3_persistPosition 使轴的位置保持不变的功能块。相应的程序在运动任务中运行。只有当轴在关闭和打开控制器之间没有移动任何距离或只有很短的距离（最大为单圈距离的一半）时，才能正确显示位置。例如，您可以使用机械制动器来执行此操作。如果在控制器关闭时轴大幅移动，则其位置不正确。无法通过 FB 进行检查 创建的实例 SMC3_PersistPosition 轴的功能块。 ppst_X: SM3_BASIC.SMC3_PersistPositionSinglturn; 对的持久数据结构进行实例化 SMC3_PersistPosition_Data 类型。 ppst_Data_X: SMC3_PersistPositionSingleturn_Data; 扩展运动任务的程序，以便调用 SMC3_PersistPosition 实例已实现，其持久数据结构也已实现 SMC_PersistPosition_Data 类型被传递给它。 " }, 
{ "title" : "模数轴的初始位置检测 ", 
"url" : "_sm_initial_positioning_of_a_rotary_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用例 \/ 模数轴的初始位置检测 ", 
"snippet" : "驱动器或编码器的实际位置以 DWORD 形式传输到控制器。 对于模轴，周期 P 由模值和缩放以增量定义。周期 P 指定旋转中的确切增量数。这意味着位置值 X、X+1*P、X+2*P 等描述了相同的物理位置。当 n 足够大时，位置 X+n*P 超过了 DWORD 的限制。这发生在位置 0x1 00 00 00 00。然后领先位置被剪切，值开始于 0 .如果 P 不是 0x1 00 00 00 00 ，则位置 X 不再描述中断前后相同的物理位置。 如果齿轮比设置为使得周期不是 0x1 0000 0000 ，然后在激活后可以移动旋转轴的位置。 例子 轴从位置开始 0x0 .它位于 0°。一个周期是 ...", 
"body" : "驱动器或编码器的实际位置以 DWORD 形式传输到控制器。 对于模轴，周期 P 由模值和缩放以增量定义。周期 P 指定旋转中的确切增量数。这意味着位置值 X、X+1*P、X+2*P 等描述了相同的物理位置。当 n 足够大时，位置 X+n*P 超过了 DWORD 的限制。这发生在位置 0x1 00 00 00 00。然后领先位置被剪切，值开始于 0 .如果 P 不是 0x1 00 00 00 00 ，则位置 X 不再描述中断前后相同的物理位置。 如果齿轮比设置为使得周期不是 0x1 0000 0000 ，然后在激活后可以移动旋转轴的位置。 例子 轴从位置开始 0x0 .它位于 0°。一个周期是 360°。选择缩放比例，使其对应于 3600000 = 0x36 EE80 增量。 1193 转后，轴停在 0xFFFD 7280=1193*3600000 .再一次完整旋转后，轴到达位置 0x10034 6100 .中断时，前导 1 被截断，位置 0x34 6100 形成了。如果将轴移回原位 0x0 ，则轴在位置 16.7296° 处停止。因此，立场 0x0 对应位置0°、16.7296°等，视实际中断而定。 如果您选择了缩放以实现上述效果，并且如果在程序开始时无法或需要归位，那么您可以通过 SMC3_PersistPosition 功能块。您在这里使用绝对值编码器。 " }, 
{ "title" : "Cia402 轴 ", 
"url" : "_sm_cia402_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cia402 轴 ", 
"snippet" : "欲了解更多信息，请参阅 添加...", 
"body" : "欲了解更多信息，请参阅 添加 " }, 
{ "title" : "通用 Cia402 轴的配置 ", 
"url" : "_sm_drives_generic_cia402_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cia402 轴 \/ 通用 Cia402 轴的配置 ", 
"snippet" : "CODESYS SoftMotion 各种驱动器提供驱动程序。如果您正在使用的 Cia402 驱动器没有特定的驱动程序可用，则可以使用通用 Cia402 轴 但是，通用轴的兼容性和行为在很大程度上取决于相应驱动器中Cia402的实现。实际上，已经表明，不同的制造商对Cia402标准的解释不同，特别是在错误处理和限位开关支持方面 因此，不能保证通用 Cia402 轴在特定驱动器上始终正确或完全运行。 通用 CiA402 驱动程序最多支持 8 个轴，以防驱动器的设备描述未指定数字。否则，支持设备描述中定义的轴数。 CANopen : 可能的轴数取决于 EDS 文件中逻辑设备的配置文件 ( 1000...", 
"body" : "CODESYS SoftMotion 各种驱动器提供驱动程序。如果您正在使用的 Cia402 驱动器没有特定的驱动程序可用，则可以使用通用 Cia402 轴 但是，通用轴的兼容性和行为在很大程度上取决于相应驱动器中Cia402的实现。实际上，已经表明，不同的制造商对Cia402标准的解释不同，特别是在错误处理和限位开关支持方面 因此，不能保证通用 Cia402 轴在特定驱动器上始终正确或完全运行。 通用 CiA402 驱动程序最多支持 8 个轴，以防驱动器的设备描述未指定数字。否则，支持设备描述中定义的轴数。 CANopen : 可能的轴数取决于 EDS 文件中逻辑设备的配置文件 ( 1000H 对象和 67FFH + X * 800H ， 在哪里 X = 逻辑设备的数量）。有关详细信息，请参阅 CANopen CiA301 标准。 EtherCAT ：可能的轴数取决于 ESI 文件中定义的 CiA402 通道 (CoE DS402Channels)。 设备制造商需要对 EDS 或 ESI 文件进行改编。 " }, 
{ "title" : "调试时使用的对象 ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e06c925bc32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cia402 轴 \/ 通用 Cia402 轴的配置 \/ 调试时使用的对象 ", 
"snippet" : "调试时，如果设备支持以下对象，则会访问这些对象。 目的 读\/写访问 (M) 必す信号 (O) 可选 评论 0x1000:0 读 M 较低的值必须是 402。否则取消。 0x1018:1 读 O 0x1018:2 读 O 0x1018:3 读 O 0x1018:4 读 O 0x6502:0 读 O 0x605A:0 读 O 0x60C2:1 写 如果参数 Set60C2 = TRUE 0x60C2:2 写 如果参数 Set60C2 = TRUE 0x6076:0 读 O...", 
"body" : "调试时，如果设备支持以下对象，则会访问这些对象。 目的 读\/写访问 (M) 必す信号 (O) 可选 评论 0x1000:0 读 M 较低的值必须是 402。否则取消。 0x1018:1 读 O 0x1018:2 读 O 0x1018:3 读 O 0x1018:4 读 O 0x6502:0 读 O 0x605A:0 读 O 0x60C2:1 写 如果参数 Set60C2 = TRUE 0x60C2:2 写 如果参数 Set60C2 = TRUE 0x6076:0 读 O " }, 
{ "title" : "运行中使用的对象 ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7dfc492c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cia402 轴 \/ 通用 Cia402 轴的配置 \/ 运行中使用的对象 ", 
"snippet" : "根据所使用的功能，在操作期间使用以下对象： 0x603F:00 , 0x6040:00 , 0x6041:00 , 0x6060:00 , 0x6061:00 , 0x6062:00 , 0x6064:00 , 0x606B:00 , 0x606C:00 , 0x6074:00 , 0x6077:00 , 0x6078:00 , 0x607C:00 , 0x60B1:00 , 0x60B2:00, 0x60B8:00 0x60B9:00 , 0x60BA:00 , 0x60BB:00 , 0x60BC:00 , 0x60BD:00 , 0x60F4:00 ....", 
"body" : "根据所使用的功能，在操作期间使用以下对象： 0x603F:00 , 0x6040:00 , 0x6041:00 , 0x6060:00 , 0x6061:00 , 0x6062:00 , 0x6064:00 , 0x606B:00 , 0x606C:00 , 0x6074:00 , 0x6077:00 , 0x6078:00 , 0x607C:00 , 0x60B1:00 , 0x60B2:00, 0x60B8:00 0x60B9:00 , 0x60BA:00 , 0x60BB:00 , 0x60BC:00 , 0x60BD:00 , 0x60F4:00 . " }, 
{ "title" : "高级配置 ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7e012b4c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cia402 轴 \/ 通用 Cia402 轴的配置 \/ 高级配置 ", 
"snippet" : "您需要选择 显示通用设备配置编辑器 选项中的 选项 – 设备编辑器 对话框，以便显示带有参数的选项卡。 您可以使用以下参数来微调 CiA402 状态图的流程。 CiA402 参数 描述 _readVelocityFactor_6096 TRUE : 速度系数（物体） 6096 ) 被读取并用于转换速度单位。 FALSE : 未读取速度系数。速度单位假定为每秒增量 _bImmediateDisabling TRUE ： 什么时候 bRegulator 被重置为 FALSE ，将驱动器的状态从 Operation enabled 直接到 Switch on disabled 。 FALSE ：通过...", 
"body" : "您需要选择 显示通用设备配置编辑器 选项中的 选项 – 设备编辑器 对话框，以便显示带有参数的选项卡。 您可以使用以下参数来微调 CiA402 状态图的流程。 CiA402 参数 描述 _readVelocityFactor_6096 TRUE : 速度系数（物体） 6096 ) 被读取并用于转换速度单位。 FALSE : 未读取速度系数。速度单位假定为每秒增量 _bImmediateDisabling TRUE ： 什么时候 bRegulator 被重置为 FALSE ，将驱动器的状态从 Operation enabled 直接到 Switch on disabled 。 FALSE ：通过“Switched on”和“Ready to switch on”切换状态，使驱动器有机会执行快速停止并正确处理制动器。 注意：如果此选项设置为 FALSE , 然后可以使用位掩码微调立即禁用关闭的状态 _dwStatesImmediateDisabling . _bForbidReenableDuringDisabling 仅在以下情况下相关 _bImmediateDisabling = FALSE . TRUE ：驱动器被逐步禁用，直到驱动器发出信号 Ready to switch on 在处理新的启用命令之前。 dwStatesImmediateDisabling 仅在以下情况下相关 _bImmediateDisabling = FALSE . 立即禁用打开的状态的位掩码。 位 0：正常操作 第 1 位：快速停止 位 2：外部快速停止 位 3：归位 示例：假设 _bImmediateDisabling = FALSE ， 价值 2#0110 表示仅针对“正常操作”和“归位”状态关闭立即禁用。对于状态“Quickstop”和“External Quickstop”，立即禁用已打开。 _uiPreHomingWait 状态机在状态中等待的周期数 PRE_HOMING 在通过设置位开始归位过程之前 4 的控制字。 _uiPostHomingWait 状态机停留的周期数 HOMING_DONE 在切换回“正常操作”之前。 _uiHomingMinCycles 开始时的循环次数 HOMING ，其中完成位（状态字的位 10\/12）被忽略。 _uiWaitCyclesForStateSwitch 系统等待驱动器执行状态更改命令的周期数。如果驱动器出现故障，系统将切换回 SWITCH_ON_DISABLED 。 _bPreHomingWaitBit12Clear TRUE : 进去等候 PRE_HOMING 直到状态字的位 12 在开始回原点之前被驱动器清除（在设置控制字的位 4 之前）。 请注意，在任何情况下，状态机都停留在 PRE_HOMING 至少 _uiPreHomingCycles . _bCheckBit10PostHoming TRUE ： 切换到 HOMING_DONE 如果状态字的第 12 位和第 10 位都是 TRUE （如 CiA-402 中所述）。 FALSE ：忽略第 10 位；仅使用位 12。 _bCheckOpMode TRUE ：检查是否 0x6061 显示设置的值 0x6060 启用轴时。 FALSE ：省略此项勾选，设置运行模式后立即启用。 _abyControllerMode 这 ARRAY[0..7] OF BYTE 包含操作模式（对象 0x6060 ）对应于 AXIS_REF_SM3.byOperationMode 。 （指数 0,3 = 位置；指数 1 = 速度；指数 2 = 扭矩） _bCheckBit12InPositionMode TRUE : AxisIsReadyForMotion 检查 CSP 或 IP 中的位 12。 FALSE : AxisIsReadyForMotion 不检查位 12。 _bDoHaltWhenStopInterruptsHome TRUE ： 什么时候 MC_Stop 中断，用控制字的第 8 位中止归位。 FALSE ：不设置第 8 位，直接切换运行模式。 _bCheckBit13InHomingMode TRUE ： 在 HOMING_ACTIVE , wStatusWord.13 = TRUE 导致错误停止和 wControlWord.8 := TRUE （根据 _bDoHaltWhenStopInterruptsHome ) _bSetControlBit4InCSP TRUE : 将状态字的第 4 位也设置为 CSP 模式。一些驱动器需要这样做，尽管它不是标准的。 _uiHomingWaitListeningBits101213 在状态 HOMING_ACTIVE , 在从设置第 4 位开始的这个周期数期间不要监听第 10、12 和 13 位。（某些驱动器需要一些时间来重置这些位）。 _bRegulatorOnRequiresVoltageEnabled 是否需要状态字的第 4 位（电压使能） TRUE 以便 bRegulatorRealState = TRUE （默认值： FALSE ). _bDriveStartRequiresOperationEnabled 状态字的第 2 位（操作使能）是否需要 TRUE 以便 bDriveStartRealState = TRUE （默认值： TRUE ). _modeOfOperation_Torque 这个 ModeOfOperation 用于控制器模式 torque 。必须表现得像循环同步扭矩模式 _modeOfOperation_Velocity 这个 ModeOfOperation 用于控制器模式 velocity 。必须表现得像循环同步速度模式 _modeOfOperation_Position 这个 ModeOfOperation 用于控制器模式 position 。其行为必须与循环同步位置模式类似 _bStayInSwitchOnDisabled FALSE : 自动过渡到 SWITCH_ON_DISABLED 到 READY_TO_SWITCH_ON 如果有，则执行 MC_Power.bDriveStart 是 TRUE 或者快速停止选项代码 ( object 0x605A:00 ) 大于 4。 没错：从 SWITCH_ON_DISABLED 到 READY_TO_SWITCH_ON 只有在以下情况下才会完成 MC_Power.bRegulatorOn 是 TRUE 。 " }, 
{ "title" : "触摸探头 ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087437140543", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cia402 轴 \/ 通用 Cia402 轴的配置 \/ 触摸探头 ", 
"snippet" : "这个 MC_TouchProbe 功能块需要 TRIGGER_REF 作为输入。 TRIGGER_REF.iTriggerNumber 对于通用 Cia402 轴具有以下含义： trigger_ref.itriggerNumber 意思 0 触摸探头 1，正极 1 触摸探头 1，负极 2 触摸探头 2，正极 3 触摸探头 2，负极...", 
"body" : "这个 MC_TouchProbe 功能块需要 TRIGGER_REF 作为输入。 TRIGGER_REF.iTriggerNumber 对于通用 Cia402 轴具有以下含义： trigger_ref.itriggerNumber 意思 0 触摸探头 1，正极 1 触摸探头 1，负极 2 触摸探头 2，正极 3 触摸探头 2，负极 " }, 
{ "title" : "错误诊断：无法通过以下方式打开驱动器 MC_Power ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087440495495", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cia402 轴 \/ 通用 Cia402 轴的配置 \/ 错误诊断：无法通过以下方式打开驱动器 MC_Power ", 
"snippet" : "通用轴需要状态词中的以下位才能返回 MC_Power.Status = TRUE : 位 0（准备开机） 位 1（已开启） 位 2（操作已启用） 位 5（快速停止） 第 12 位 但是，并非每个驱动器都设置位 12。如果驱动器未设置该位，则 _bCheckBit12InPositionMode 通用轴的参数可以设置为 FALSE 。...", 
"body" : "通用轴需要状态词中的以下位才能返回 MC_Power.Status = TRUE : 位 0（准备开机） 位 1（已开启） 位 2（操作已启用） 位 5（快速停止） 第 12 位 但是，并非每个驱动器都设置位 12。如果驱动器未设置该位，则 _bCheckBit12InPositionMode 通用轴的参数可以设置为 FALSE 。 " }, 
{ "title" : "触摸探头 ", 
"url" : "_sm_touch_probe.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cia402 轴 \/ 触摸探头 ", 
"snippet" : "带有 Cia402 配置文件的驱动器有时支持选择触摸探头源。无法通过设置源 MC_TouchProbe 功能块。默认情况下，使用属于触摸探头的数字输入。 更改来源： 手动写入触摸探针对象 0x60B8 为此，你需要致电 MC_WriteParameter 带有 ParameterNumber = 10184 。这对应于 CiA 402 对象 0x60B8 。 如果输出 MC_WriteParameter.Done = TRUE ，然后你可以命令 MC_TouchProbe 像往常一样的功能块。 只有来自对象的比特 0x60B8 已设置，可以通过以下方式定义 MC_TouchProbe （由 ）...", 
"body" : "带有 Cia402 配置文件的驱动器有时支持选择触摸探头源。无法通过设置源 MC_TouchProbe 功能块。默认情况下，使用属于触摸探头的数字输入。 更改来源： 手动写入触摸探针对象 0x60B8 为此，你需要致电 MC_WriteParameter 带有 ParameterNumber = 10184 。这对应于 CiA 402 对象 0x60B8 。 如果输出 MC_WriteParameter.Done = TRUE ，然后你可以命令 MC_TouchProbe 像往常一样的功能块。 只有来自对象的比特 0x60B8 已设置，可以通过以下方式定义 MC_TouchProbe （由 ）。其余位保留步骤 1 中的值（表示为 ): 物体的位数 0x60b8 触摸探头 2 触摸探头 1 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 关于对象 0x60d0 的注意事项 在触摸探针物体中 0x60B8 ，你可以指定来源，以便通过对象进行解析 0x60D0 。这对应于位组合 10 b 用于比特 3 ， 2 或者 11 ， 10 物体的 0x60B8 。在这种情况下，你需要写入对象 0x60D0 在执行之前 MC_TouchProbe 。为此，你需要使用 MC_WriteParameter 功能块，其中 ParameterNumber 使用以下方法计算 SMC_ParameterNumber_CoE 函数。 " }, 
{ "title" : "实际值、设定值和空闲时间 ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 实际值、设定值和空闲时间 ", 
"snippet" : "本页回答了何时接收和发送实际值和设定值以及它们与死区时间有何关系的问题。为简单起见，我们将重点放在位置上，但同样适用于其他值，例如速度或扭矩。我们还专注于 EtherCAT。其他现场总线的行为类似。（请注意，我们假设默认和推荐配置为 FrameAtTaskStart = TRUE 。）...", 
"body" : "本页回答了何时接收和发送实际值和设定值以及它们与死区时间有何关系的问题。为简单起见，我们将重点放在位置上，但同样适用于其他值，例如速度或扭矩。我们还专注于 EtherCAT。其他现场总线的行为类似。（请注意，我们假设默认和推荐配置为 FrameAtTaskStart = TRUE 。） " }, 
{ "title" : "实际值何时收到？ ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054861776368", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 实际值、设定值和空闲时间 \/ 实际值何时收到？ ", 
"snippet" : "The actual position ( <DriveA>.fActPosition ) is received at the beginning of the current bus task cycle. It is the actual position of the drive at the time of the previous EtherCAT SYNC event. 在总线任务周期 i 中，收到在前一总线任务周期 i-1 中发送的 EtherCAT 帧。该帧包含驱动器在 SYNC 事件 i-2 时锁定的实际位置...", 
"body" : "The actual position ( <DriveA>.fActPosition ) is received at the beginning of the current bus task cycle. It is the actual position of the drive at the time of the previous EtherCAT SYNC event. 在总线任务周期 i 中，收到在前一总线任务周期 i-1 中发送的 EtherCAT 帧。该帧包含驱动器在 SYNC 事件 i-2 时锁定的实际位置 " }, 
{ "title" : "设定值何时发送？ ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862001312", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 实际值、设定值和空闲时间 \/ 设定值何时发送？ ", 
"snippet" : "在当前总线任务周期 i 中计算的设定值将在下一个总线任务周期 i+1 中发送到驱动器，并在 SYNC 事件 i+1 时由驱动器应用。参见上图。...", 
"body" : "在当前总线任务周期 i 中计算的设定值将在下一个总线任务周期 i+1 中发送到驱动器，并在 SYNC 事件 i+1 时由驱动器应用。参见上图。 " }, 
{ "title" : "空闲时间是多少，如何估计，如何使用？ ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862210917", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 实际值、设定值和空闲时间 \/ 空闲时间是多少，如何估计，如何使用？ ", 
"snippet" : "通常，每当需要在驱动器到达某个位置时执行动作时，死区时间就很重要。停机时间对于精确确定给定时间的驱动位置也很重要。示例包括高速涂胶，或使用连接到 PLC 的高精度数字输入在 PLC 中执行触摸探针。...", 
"body" : "通常，每当需要在驱动器到达某个位置时执行动作时，死区时间就很重要。停机时间对于精确确定给定时间的驱动位置也很重要。示例包括高速涂胶，或使用连接到 PLC 的高精度数字输入在 PLC 中执行触摸探针。 " }, 
{ "title" : "死亡时间的定义 ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862962511", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 实际值、设定值和空闲时间 \/ 空闲时间是多少，如何估计，如何使用？ \/ 死亡时间的定义 ", 
"snippet" : "死区时间是驱动器实际到达 PLC 发送的设定位置所花费的时间。这意味着这是两者之间的时间间隔 fActPosition 还有 fSetPosition ，在当前总线任务周期开始时。死区时间可以在通用驱动器编辑器中配置 ( 标签：常规) 或者使用 mc_WriteParameter 参数编号为 1070 的功能块 ( fSetActTimeLagCycles ）。 死机时间是以下时间的总和： 将设定位置发送到驱动器所需的时间 驱动控制器到达设定位置所需的时间 从驱动器接收实际位置所花费的时间...", 
"body" : "死区时间是驱动器实际到达 PLC 发送的设定位置所花费的时间。这意味着这是两者之间的时间间隔 fActPosition 还有 fSetPosition ，在当前总线任务周期开始时。死区时间可以在通用驱动器编辑器中配置 ( 标签：常规) 或者使用 mc_WriteParameter 参数编号为 1070 的功能块 ( fSetActTimeLagCycles ）。 死机时间是以下时间的总和： 将设定位置发送到驱动器所需的时间 驱动控制器到达设定位置所需的时间 从驱动器接收实际位置所花费的时间 " }, 
{ "title" : "死亡时间的估计 ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054864599382", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 实际值、设定值和空闲时间 \/ 空闲时间是多少，如何估计，如何使用？ \/ 死亡时间的估计 ", 
"snippet" : "死机时间可以用以下公式来估算 smc_estimateDeadTime 功能块。驱动器应以恒定速度移动，并应使用多个死区时间测量值的中位数或平均 或者，可以使用追踪编辑器估算失效时间。有关更多信息，请参阅以下内容： 确定系统的死区时间...", 
"body" : "死机时间可以用以下公式来估算 smc_estimateDeadTime 功能块。驱动器应以恒定速度移动，并应使用多个死区时间测量值的中位数或平均 或者，可以使用追踪编辑器估算失效时间。有关更多信息，请参阅以下内容： 确定系统的死区时间" }, 
{ "title" : "死区时间的使用 ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054865995483", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 实际值、设定值和空闲时间 \/ 空闲时间是多少，如何估计，如何使用？ \/ 死区时间的使用 ", 
"snippet" : "死区时间用于以下功能。如果您正在使用这些函数中的任何一个并且需要高精度，请务必确定和配置死区时间。 将控制器模式切换到控制器模式时 SMC_position 有关更多信息，请参阅以下内容： 标准用例在控制器模式下 SMC_velocity 根据实际位置和设定速度计算设定位置 在控制器模式下 SMC_torque 根据实际位置和实际速度计算设定位置 如果开启了软件位置延迟监控 在 SMC_GetTravelTime 如果是输入，则为功能块 ValueSource 有价值 MC_SOURCE.ACT 在 SMC_DigitalCamSwitch_HighPrecision 如果是输入，则为功能块 ...", 
"body" : "死区时间用于以下功能。如果您正在使用这些函数中的任何一个并且需要高精度，请务必确定和配置死区时间。 将控制器模式切换到控制器模式时 SMC_position 有关更多信息，请参阅以下内容： 标准用例在控制器模式下 SMC_velocity 根据实际位置和设定速度计算设定位置 在控制器模式下 SMC_torque 根据实际位置和实际速度计算设定位置 如果开启了软件位置延迟监控 在 SMC_GetTravelTime 如果是输入，则为功能块 ValueSource 有价值 MC_SOURCE.ACT 在 SMC_DigitalCamSwitch_HighPrecision 如果是输入，则为功能块 ValueSource 有价值 MC_SOURCE.ACT 在 SMC_ETC_InterpolateAxisPosition 功能块（基于 PLC 的触摸探头） " }, 
{ "title" : "例子 ", 
"url" : "_sm_drives_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例子 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "使用 SM_Drive_PosControl 对控制器进行位置控制 ", 
"url" : "_sm_example_poscontrol.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例子 \/ 使用 SM_Drive_PosControl 对控制器进行位置控制 ", 
"snippet" : "见 PosControl.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 在大多数情况下，伺服控制接管驱动器的位置控制，以及功率控制和转速控制。但是，在某些用例中，控制器会接管轴的位置控制。此示例演示了速度控制设备（例如，带有位置反馈的变频器）如何通过以下方式进行位置控制 CODESYS SoftMotion . 要求是一个由设定的速度控制并返回其当前位置的设备。在此示例中，10V 模拟输出端子 EL4031 与用作变频器速度设定值的信号一起使用。编码器端子 EL5101 用于位置反馈。...", 
"body" : "见 PosControl.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 在大多数情况下，伺服控制接管驱动器的位置控制，以及功率控制和转速控制。但是，在某些用例中，控制器会接管轴的位置控制。此示例演示了速度控制设备（例如，带有位置反馈的变频器）如何通过以下方式进行位置控制 CODESYS SoftMotion . 要求是一个由设定的速度控制并返回其当前位置的设备。在此示例中，10V 模拟输出端子 EL4031 与用作变频器速度设定值的信号一起使用。编码器端子 EL5101 用于位置反馈。 " }, 
{ "title" : "通过 SM_Drive_PosControl 控制轴位置 ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_7bfb9b9f2d9ce618c0a8646335ff28dd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例子 \/ 使用 SM_Drive_PosControl 对控制器进行位置控制 \/ 通过 SM_Drive_PosControl 控制轴位置 ", 
"snippet" : "添加位置控制轴类型 SM_Drive_PosControl 以下 SoftMotion 通用轴池 在设备树中。 将模拟端子 (EL4031) 和编码器 (EL5101) 的端子添加到设备树中。 设备树： 必须从制造商处下载并安装现场总线设备的设备描述。 打开 SM_Drive_PosControl 编辑器中的设备并使用值指定通用参数 Modulo 360.0 在 一般的 标签。 点击 缩放\/映射 标签。电机每转的增量数取自编码器的数据表。在这个例子中， 4096 增量 (1) 是电机转一圈。因为您在应用程序中使用角度，所以您指定值 360 (2) 对于 申请单位 . 设置： 切换到 SoftM...", 
"body" : "添加位置控制轴类型 SM_Drive_PosControl 以下 SoftMotion 通用轴池 在设备树中。 将模拟端子 (EL4031) 和编码器 (EL5101) 的端子添加到设备树中。 设备树： 必须从制造商处下载并安装现场总线设备的设备描述。 打开 SM_Drive_PosControl 编辑器中的设备并使用值指定通用参数 Modulo 360.0 在 一般的 标签。 点击 缩放\/映射 标签。电机每转的增量数取自编码器的数据表。在这个例子中， 4096 增量 (1) 是电机转一圈。因为您在应用程序中使用角度，所以您指定值 360 (2) 对于 申请单位 . 设置： 切换到 SoftMotion 驱动器：位置控制回路 选项卡并指定以下参数： D 2.0 死区时间决定了接收到的实际位置（编码器）相移到轴的设定位置的周期数。死区时间取决于应用的组件，并且必须通过反复试验来确定。 Kp 0.0 比例常数是位置误差（设定位置与实际位置之间的偏差）乘以稍后添加到设定速度的系数。现在将此值设置为 0 .稍后您将通过实验确定该值。 Bit width: 16 根据使用的组件接收实际值的位宽，可以设置为 16、24 或 32 位值。将值设置为 16 因为使用的组件产生的位置为 UINT . max 关闭位置误差监控开关。如有必要，您可以重新打开它。选中该复选框并指定最大允许滞后。如果在操作期间超过该值，则轴进入错误状态。 δ\/δt 该参数的值为 1，仅在非常特殊的情况下才应更改。它定义了设定速度和位置推导之间的关系。取值范围是 0 到 1： 0 ： 的价值 fSetVelocity 用作源。 1 ：设定位置的数值推导用作来源。 控制回路： 现在您设置发送到执行器的速度值。为此，您必须知道应用单位的最大速度和传输数据的相应原始值。在这个例子中，最大速度是通过输出值来实现的 16#7FFF ，这对应于每秒 10 圈的速度。根据设置，这也对应于每秒 3600 度。 设置： " }, 
{ "title" : "变量到输入和输出的映射 ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_869c8e3e2852db2ec0a8640e00c42e8b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例子 \/ 使用 SM_Drive_PosControl 对控制器进行位置控制 \/ 变量到输入和输出的映射 ", 
"snippet" : "将带有轴数据的变量映射到 I\/O 模块。轴的可用循环数据位于数据结构中 in 和 out .您可以在输入和输出设备的设备编辑器中以编程方式或直接建立此连接。 将输出（设定速度）连接到 EL4031 设备。在编辑器中打开设备并单击 EtherCAT I\/O 映射 标签。分配变量 out.iSetVelocity 轴的输出。在 32 位输出的情况下， out.diSetVelocity 用来。 映射： 以同样的方式进行位置输入。在编辑器中打开EL5101设备，将位置输入值设置为 in.wActPosition .对于 32 位输入，将值设置为 in.dwActPosition .映射： 为使控制使...", 
"body" : "将带有轴数据的变量映射到 I\/O 模块。轴的可用循环数据位于数据结构中 in 和 out .您可以在输入和输出设备的设备编辑器中以编程方式或直接建立此连接。 将输出（设定速度）连接到 EL4031 设备。在编辑器中打开设备并单击 EtherCAT I\/O 映射 标签。分配变量 out.iSetVelocity 轴的输出。在 32 位输出的情况下， out.diSetVelocity 用来。 映射： 以同样的方式进行位置输入。在编辑器中打开EL5101设备，将位置输入值设置为 in.wActPosition .对于 32 位输入，将值设置为 in.dwActPosition .映射： 为使控制使能、快速停止和限位开关动作，相应的输入 SMC_PosControlInput 必须由驱动器的值定义。的输出 SMC_PosControlOutput 必须传输到驱动器（参见下面的说明）。例如，如果驱动器不支持快速停止，则 SM_Drive_PosControl.in.bDriveStartRealState := TRUE 必须设置和 SM_Drive_PosControl.out.bDriveStart 可以忽略。在这个例子中， bDriveStartRealState 和 bRegulatorRealState 必须在应用程序中设置。 SM_Drive_PosControl.in.bDriveStartRealState := TRUE;\nSM_Drive_PosControl.in.bRegulatorRealState := TRUE; " }, 
{ "title" : "确定系统的死区时间 ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_section-idm43260109050006", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例子 \/ 使用 SM_Drive_PosControl 对控制器进行位置控制 \/ 确定系统的死区时间 ", 
"snippet" : "现在设置轴的在线模式并设置控制参数。 请注意，轴可能会失去控制。因此，您必须采取相应的安全预防措施。 然后尝试在没有位置控制的情况下操作轴。 fKp 已设置为 0.0，并且缩放设置已验证。将轴切换到 MC_Power 并开始 MC_MoveVelocity .轴现在以 1 U\/s 的编程速度移动。在出现偏差的情况下，您必须相应地更正缩放比例。 结束运动，例如 MC_MoveRelative , 并启动跟踪功能。 通过测量设定位置和实际位置之间的时间差来确定系统的死机时间。 在 MC_MoveRelative ，设置最大速度和大加速度。开始采样跟踪 MC_MoveRelative .现在确定设定...", 
"body" : "现在设置轴的在线模式并设置控制参数。 请注意，轴可能会失去控制。因此，您必须采取相应的安全预防措施。 然后尝试在没有位置控制的情况下操作轴。 fKp 已设置为 0.0，并且缩放设置已验证。将轴切换到 MC_Power 并开始 MC_MoveVelocity .轴现在以 1 U\/s 的编程速度移动。在出现偏差的情况下，您必须相应地更正缩放比例。 结束运动，例如 MC_MoveRelative , 并启动跟踪功能。 通过测量设定位置和实际位置之间的时间差来确定系统的死机时间。 在 MC_MoveRelative ，设置最大速度和大加速度。开始采样跟踪 MC_MoveRelative .现在确定设定位置的开始运动与实际位置的第一反应之间的时间差。 痕迹： 确定死机时间 D ，将此时差除以周期时间（D = 时差\/循环时间）。 SoftMotion Drive：位置控制 选项卡，在控制回路中指定此值 D 。 现在尝试确定 fKp . 的正确设置。为此，请更改观察列表中变量 <drive>.controller.fKp 的值。 设置 fKp 变为一个较小的数字（例如，0.0001），然后逐步增加该值。使用采样轨迹检查每次变化的行为。一旦检测到波动，就达到了上限。现在减小其值 fKp 增加大约 10%，然后在 SoftMotion Drive：位置控制 控制回路中的选项卡 Kp 。 现在你可以使用轴了。 " }, 
{ "title" : "功能块 SMC_PosControlInput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_666f8939fd0b11e3b1f5b5a0173eacdc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例子 \/ 使用 SM_Drive_PosControl 对控制器进行位置控制 \/ 功能块 SMC_PosControlInput ", 
"snippet" : "图书馆： SM3_Drive_PosControl 输入 (VAR_INPUT) 姓名 数据类型 初始值 描述 bLimitPos BOOL 正向限位开关（仅限有限轴） 自从那 SoftMotion 版本 4.12.0.0，限位开关监控在默认情况下处于启用状态。对于旧版本，必须通过设置手动启用此 bHWLimitEnable 到 TRUE 。这通常是通过写入相应的参数号来完成 1206 通过以下方式 MC_WriteBoolParameter 。 TRUE ：限位开关未启动 FALSE ：限位开关启动 bLimitNeg BOOL 负向限位开关 TRUE ：限位开关未启动 FALSE ：限位开...", 
"body" : "图书馆： SM3_Drive_PosControl 输入 (VAR_INPUT) 姓名 数据类型 初始值 描述 bLimitPos BOOL 正向限位开关（仅限有限轴） 自从那 SoftMotion 版本 4.12.0.0，限位开关监控在默认情况下处于启用状态。对于旧版本，必须通过设置手动启用此 bHWLimitEnable 到 TRUE 。这通常是通过写入相应的参数号来完成 1206 通过以下方式 MC_WriteBoolParameter 。 TRUE ：限位开关未启动 FALSE ：限位开关启动 bLimitNeg BOOL 负向限位开关 TRUE ：限位开关未启动 FALSE ：限位开关启动 wActPosition WORD 当前位置（实际位置）为 16 位值 dwActPosition DWORD 当前位置（实际位置）为 32 位值 bExternalError BOOL 外部错误 bRegulatorRealState BOOL TRUE : 轴被控制 bDriveStartRealState BOOL FALSE : 轴入 Quick Stop dwEncoderCounterModulo DWORD 0 bDelayActivation BOOL TRUE ： 只要 bDelayActivation 是 TRUE , SM3_Drive_PosControl 不切换到通讯状态 100 . 用例：值保持在 TRUE 直到应用的编码器产生有效的位置值。 " }, 
{ "title" : "功能块：SMC_PosControlOutput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_60809817bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例子 \/ 使用 SM_Drive_PosControl 对控制器进行位置控制 \/ 功能块：SMC_PosControlOutput ", 
"snippet" : "图书馆： SM3_Drive_PosControl 输出 (VAR_OUTPUT) 姓名 数据类型 初始值 描述 bRegulatorOnIn BOOL TRUE : 应该控制轴。 bDriveStart BOOL FALSE ：轴应执行快速停止。 diSetVelocity DINT 设定速度 iSetVelocity INT 设定速度...", 
"body" : "图书馆： SM3_Drive_PosControl 输出 (VAR_OUTPUT) 姓名 数据类型 初始值 描述 bRegulatorOnIn BOOL TRUE : 应该控制轴。 bDriveStart BOOL FALSE ：轴应执行快速停止。 diSetVelocity DINT 设定速度 iSetVelocity INT 设定速度 " }, 
{ "title" : "功能块：SMC_SetPosControlParams ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_6080e639bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例子 \/ 使用 SM_Drive_PosControl 对控制器进行位置控制 \/ 功能块：SMC_SetPosControlParams ", 
"snippet" : "图书馆： SM3_Drive_PosControl 改变一个参数 SM3_Drive_PosControl 轴 输入 (VAR_INPUT) 姓名 数据类型 初始值 描述 Axis AXIS_REF_POSCONTROL 轴参考 bExecute BOOL TRUE ：激活功能块的执行 fKp LREAL -1 滞后的比例增益 小于 0 的值将被忽略。 fPartVelPilotControl LREAL -1 速度控制系数 fSetPosition 0：无速度先导控制； 1：直接输出 fSetVelocity .小于 0 的值将被忽略。 fDeadTime LREAL -1 之间的周期时间滞...", 
"body" : "图书馆： SM3_Drive_PosControl 改变一个参数 SM3_Drive_PosControl 轴 输入 (VAR_INPUT) 姓名 数据类型 初始值 描述 Axis AXIS_REF_POSCONTROL 轴参考 bExecute BOOL TRUE ：激活功能块的执行 fKp LREAL -1 滞后的比例增益 小于 0 的值将被忽略。 fPartVelPilotControl LREAL -1 速度控制系数 fSetPosition 0：无速度先导控制； 1：直接输出 fSetVelocity .小于 0 的值将被忽略。 fDeadTime LREAL -1 之间的周期时间滞后 fSetPosition 和 fActPositioin 该值不得为 0。小于 0 的值将被忽略。 fMaxPositionDiff LREAL -1 最大位置滞后 0 禁用最大位置滞后的检查。小于 0 的值将被忽略。 输出 (VAR_OUTPUT) 姓名 数据类型 初始值 描述 bDone BOOL 功能块的执行已结束。 bError BOOL TRUE : 功能块中发生错误。 ErrorID SMC_ERROR 错误识别 例子 轴驱动参数 SM_Drive_PosControl 设置。 PROGRAM PLC_PRG\nVAR\n fbSetPosControlParams : SMC_SetPosControlParams;\nEND_VAR\n\nfbSetPosControlParams.fKp := 1;\nfbSetPosControlParams.fPartVelPilotControl :=0;\nfbSetPosControlParams.fDeadTime :=0.1;\nfbSetPosControlParams.fMaxPositionDiff :=1;\n\nfbSetPosControlParams(Axis:= SM_Drive_PosControl, bExecute:= TRUE); " }, 
{ "title" : "用户界面 ", 
"url" : "_sm_drives_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用户界面 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：添加 SoftMotion CiA402 轴 ", 
"url" : "_sm_cmd_add_softmotion_cia402_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用户界面 \/ 命令：添加 SoftMotion CiA402 轴 ", 
"snippet" : "添加 SoftMotion CiA402轴 功能 ：该命令添加了一个通用的 SoftMotion 设备树中现场总线从站下方的 CiA402 轴。 称呼 : 项目 菜单;设备树中设备对象的上下文菜单 要求 : 在设备树中，选择支持该驱动器的设备。示例：EtherCAT 从机或 CAN 驱动器的 ESI 文件包含它是 Cia402 轴的条目 ( ProfileNo 402 ）。 该命令会插入一个通用的 Cia402 轴。有关更多信息，请参阅以下内容： 通用 Cia402 轴的配置...", 
"body" : "添加 SoftMotion CiA402轴 功能 ：该命令添加了一个通用的 SoftMotion 设备树中现场总线从站下方的 CiA402 轴。 称呼 : 项目 菜单;设备树中设备对象的上下文菜单 要求 : 在设备树中，选择支持该驱动器的设备。示例：EtherCAT 从机或 CAN 驱动器的 ESI 文件包含它是 Cia402 轴的条目 ( ProfileNo 402 ）。 该命令会插入一个通用的 Cia402 轴。有关更多信息，请参阅以下内容： 通用 Cia402 轴的配置 " }, 
{ "title" : "命令：添加 SoftMotion 伺服轴 ", 
"url" : "_sm_cmd_add_softmotion_sercos_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用户界面 \/ 命令：添加 SoftMotion 伺服轴 ", 
"snippet" : "添加 SoftMotion 伺服轴 功能 : 命令增加了一个通用的 SoftMotion Sercos 模块下方的 Sercos 轴。 称呼 ： 项目 菜单; Sercos Slave 的上下文菜单 要求 ：在设备树中选择了合适的 Sercos 从站。 Sercos 轴不再支持 SoftMotion 版本 4.17.0.0 及更高版本。 此命令用于任何伺服驱动器使用 CODESYS SoftMotion .驱动器只需支持 Sercos 标准。 CODESYS 使用标准驱动程序与设备进行通信。驱动器是否与设备一起工作的方式取决于设备本身的实现。因此，无法保证驱动程序如何与设备一起工作。 通用 S...", 
"body" : "添加 SoftMotion 伺服轴 功能 : 命令增加了一个通用的 SoftMotion Sercos 模块下方的 Sercos 轴。 称呼 ： 项目 菜单; Sercos Slave 的上下文菜单 要求 ：在设备树中选择了合适的 Sercos 从站。 Sercos 轴不再支持 SoftMotion 版本 4.17.0.0 及更高版本。 此命令用于任何伺服驱动器使用 CODESYS SoftMotion .驱动器只需支持 Sercos 标准。 CODESYS 使用标准驱动程序与设备进行通信。驱动器是否与设备一起工作的方式取决于设备本身的实现。因此，无法保证驱动程序如何与设备一起工作。 通用 Sercos 驱动程序支持多达八个轴的多轴设备。 " }, 
{ "title" : "命令：添加 SoftMotion 国企轴 ", 
"url" : "_sm_cmd_add_softmotion_soe_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用户界面 \/ 命令：添加 SoftMotion 国企轴 ", 
"snippet" : "添加 SoftMotion SoE 轴 功能 : 命令增加了一个通用的 SoftMotion EtherCAT 从站下方的 SoE 轴。 称呼 ： 项目 菜单;从站的上下文菜单 要求 ：在设备树中选择了合适的 EtherCAT 从站。 此命令用于任何伺服驱动器使用 CODESYS SoftMotion .伺服驱动器只需支持 SoE 标准。 CODESYS 使用标准驱动程序与设备进行通信。驱动器是否与设备一起工作的方式取决于设备本身的实现。因此，无法保证驱动程序如何与设备一起工作。 通用 SoE 驱动程序支持最多八个轴的多轴设备。...", 
"body" : "添加 SoftMotion SoE 轴 功能 : 命令增加了一个通用的 SoftMotion EtherCAT 从站下方的 SoE 轴。 称呼 ： 项目 菜单;从站的上下文菜单 要求 ：在设备树中选择了合适的 EtherCAT 从站。 此命令用于任何伺服驱动器使用 CODESYS SoftMotion .伺服驱动器只需支持 SoE 标准。 CODESYS 使用标准驱动程序与设备进行通信。驱动器是否与设备一起工作的方式取决于设备本身的实现。因此，无法保证驱动程序如何与设备一起工作。 通用 SoE 驱动程序支持最多八个轴的多轴设备。 " }, 
{ "title" : "SoftMotion 驱动器 ", 
"url" : "_sm_f_reference_object_sm_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用户界面 \/ SoftMotion 驱动器 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "标签：常规 ", 
"url" : "_sm_edt_drive_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用户界面 \/ SoftMotion 驱动器 \/ 标签：常规 ", 
"snippet" : "轴类型和设置 轴类型 虚拟模式 ：驱动器被类似于虚拟驱动单元的仿真所取代。当有耦合驱动器时，这不会对现场总线设备产生任何影响。它们照常运行，无需向物理设备发送或接收消息。 注意：您也可以通过 IEC 代码设置和重置驱动器的虚拟模式 SMC3_ReinitDrive 功能块。 模数 : 驱动器在不限制运行范围的情况下无休止地转动（例如：皮带驱动器）。 模值 [u] ：一个周期的值（模周期） 该值保存在 fPositionPeriod 的参数 AXIS_REF_SM3 功能块。 注意：如果您选择 模数 驱动器类型，然后是产品 fPositionPeriod * dwRatioTechUnitsDe...", 
"body" : "轴类型和设置 轴类型 虚拟模式 ：驱动器被类似于虚拟驱动单元的仿真所取代。当有耦合驱动器时，这不会对现场总线设备产生任何影响。它们照常运行，无需向物理设备发送或接收消息。 注意：您也可以通过 IEC 代码设置和重置驱动器的虚拟模式 SMC3_ReinitDrive 功能块。 模数 : 驱动器在不限制运行范围的情况下无休止地转动（例如：皮带驱动器）。 模值 [u] ：一个周期的值（模周期） 该值保存在 fPositionPeriod 的参数 AXIS_REF_SM3 功能块。 注意：如果您选择 模数 驱动器类型，然后是产品 fPositionPeriod * dwRatioTechUnitsDenom 必须是整数。 有限 ：驱动器有一个固定的工作区（例如：一个线性驱动器）。 软件限位开关 活性 ：位置值受下限限制 消极的 和上限 积极的 . 消极的 : 负限值的输入字段 积极的 : 正限值的输入字段 马达类型 扶轮社 : 中的设置 缩放 适用于旋转马达。 线性 : 中的设置 缩放 适用于直线电机。（无齿轮和电机转速的简化配置） 速度斜坡类型 定义运动生成单轴和主\/从模块的速度曲线： 注意：坡道类型 Sin² 和 二次曲线（平滑） 不支持机器人。 梯形 : 梯形速度曲线（每个分段的加速度恒定） Sin² ：由 sin² 函数定义的速度分布（具有恒定的加速度曲线）。 二次的 : 梯形加速度曲线，带有加力限制 二次曲线（平滑） : 喜欢 二次的 但是会生成一个没有跳跃的混蛋配置文件。 识别 身份证 整数标识符。每个驱动器都应该是唯一的。例如，在 PLC 日志中使用此标识符以便在发生错误时识别驱动器。 死亡时间 周期 两者之间的循环中断时间 fActPosition 还有 fSetPosition 在这个周期的开始时 动态极限 考虑了 PLCOpen 第 4 部分 POU 中的极限值。此外，它们由名为的库 POU 使用 SMC_ControlAxisBy* 用于检测跳跃。 速度 [u\/s] 速度、加速度、减速和加速度极限值 加速 [u\/s²] 减速 [u\/s²] 混蛋 [u\/s³] 监控和错误反应 软件限制 已激活 : 位置值受下限限制 负面的 和上限 阳性 。 负面的 : 负极限值的输入字段 阳性 : 正极限值的输入字段 软件错误反应 软件错误的原因 到达软件限位开关 超过允许的最大软件延迟 对于有限轴：32 位溢出过多 MC_Power.bRegulatorOn = FALSE 在主动运动期间（错误： SMC_FB_ACTIVE_AXIS_DISABLED ) 运动功能块，带有 Busy=TRUE 未调用（错误： SMC_FB_WASNT_CALLED_DURING_MOTION ) 对于软件错误反应， 减速 ， 马克斯。距离 ，并考虑了动态极限的减速。减速也是根据最大距离计算的。这些减速值中的最高值用于误差斜坡 减速 [u\/s²] : 错误斜坡的减速 最大距离 [u] 可选 发生错误后，驱动器必须在该距离内处于停顿状态。 位置延迟监控 系统对检测到的延迟的响应。 当设定位置和补偿后的实际位置之间的差异超过延迟限制时，就会检测到延迟。外推的实际位置按以下公式计算 extrapolated actual position := actual position + actual velocity * cycle time * Axis.fSetActTimeLagCycles 该值是轴的实际位置，由死区时间补偿。 注意：如果您正在监视延迟，则应确定并输入空闲时间。有关描述，请参阅以下章节： 实际值、设定值和空闲时间。 注意：延迟监控不适用于虚拟驱动器。 已停用 没有回应 延迟监控已停用。 禁用驱动器 这个 bRegulatorOn bit 被迫这样做 FALSE （比较一下 MC_Power 输入），它首先强制驱动器减速，然后停用驱动器（取决于驱动器的实现）。 快停 这个 bDriveStart bit 被迫这样做 FALSE （比较一下 MC_Power 输入），这会迫使驱动器执行快速停止。 保持启用状态 驱动器保持开启状态，但所有跑步动作都会突然停止。 延迟限制 : 控制器中的延迟监控 驱动器中也可以存在独立监控，但未在此对话框中进行配置。 在线的 要求：PLC 处于在线模式。 变量表 带有变量名称的驱动变量列表， 设定值 和 当前值 地位 显示 SoftMotion 驱动器的当前状态 通讯设置 显示当前通讯状态 错误 轴误差 FB错 uiDrive接口错误 驱动器接口错误 有关详细信息，请参阅： 确定系统的死区时间例子 下图展示了不同斜坡类型的效果。位置以绿色绘制，速度以蓝色绘制，加速度以红色绘制。 梯形 速度是部分线性和连续的，而部分恒定的加速度表示跳跃。 罪² 速度曲线中的中断被平滑（通过使用 sin² 函数而不是线）以减少加速度的跳跃。 用户不能限制这种斜坡类型的加加速度。仅当运动开始时加速度不为零且中断的减速和加速斜坡无法无缝继续时，设置的最大加加速度才有效。然后，考虑到加加速度限制，在当前运动开始之前，加速度减小到零。与梯形速度曲线相比，在这种情况下减速需要更多时间。 二次方 加速度是部分线性和连续的，并且加速度有跳跃。速度由二次段和线性段组成。 二次（平滑） 二次斜坡类型的线性加速度斜坡被一个“平滑”函数取代，在开始和结束时斜率值为零。因此，加加速度也是连续的。 注意：如果运动被中断，则可能导致挺举中断。 有关更多信息，请参阅： 动作中断" }, 
{ "title" : "选项卡：缩放\/映射 ", 
"url" : "_sm_edt_drive_scaling_mapping.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用户界面 \/ SoftMotion 驱动器 \/ 选项卡：缩放\/映射 ", 
"snippet" : "在此选项卡上，您可以定义技术单位（例如，毫米或度）和驱动单位（增量）之间的关系。根据设备描述，设置选项会简化显示（参数 bHiresMode = TRUE ），和\/或线性电机的缩放也是可能的（参数 IsLinearMotor = TRUE ）。如有必要，您还可以影响循环传输的驱动对象到 IEC 变量的映射。 缩放 反转方向 : 转向相反。电机获得具有相反符号的指定值。 精度（十进制） 要求：设备描述指定了一个简化的配置对话框（参数 bHiresMode = TRUE ）。在这种情况下，隐藏设置获得默认值 1 . 要缩放和传输的增量的用户单位的小数位数。例如， 3 对应精度为 10 3 . 增量...", 
"body" : "在此选项卡上，您可以定义技术单位（例如，毫米或度）和驱动单位（增量）之间的关系。根据设备描述，设置选项会简化显示（参数 bHiresMode = TRUE ），和\/或线性电机的缩放也是可能的（参数 IsLinearMotor = TRUE ）。如有必要，您还可以影响循环传输的驱动对象到 IEC 变量的映射。 缩放 反转方向 : 转向相反。电机获得具有相反符号的指定值。 精度（十进制） 要求：设备描述指定了一个简化的配置对话框（参数 bHiresMode = TRUE ）。在这种情况下，隐藏设置获得默认值 1 . 要缩放和传输的增量的用户单位的小数位数。例如， 3 对应精度为 10 3 . 增量 <=> 电机转数 对应于给定电机圈数的增量数。可以看到参数 配置 设备编辑器的选项卡。 电机转 <=> 齿轮输出转 对应于给定齿轮输出圈数的电机圈数。 齿轮输出在应用中转动 <=> 个单位 与应用中的一个单位相对应的齿轮输出圈数。 综合配置示例 在示例配置中，对电机转动具有 3600 增量的驱动器进行缩放，以便应用程序的技术单位是直角度数。 映射 注意：这些参数不适用于 Drive_PosControl。 自动映射 ：影响驱动器的 IEC 参数会自动映射到设备的相应输入和输出。禁用该选项后，可以手动编辑映射。为此，将输入和输出的地址或类型更改为根据设备描述文件创建的显示参数列表。 " }, 
{ "title" : "标签：调试 ", 
"url" : "_sm_edt_drive_commisioning.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用户界面 \/ SoftMotion 驱动器 \/ 标签：调试 ", 
"snippet" : "您可以通过此页面上的按钮移动驱动器。驱动器可能会发生意外动作。 采取一切必要的安全预防措施。 此选项卡用于调试物理驱动器时的测试目的。它仅在以下情况下可用 在线配置模式 已启用。在这种模式下，开发系统连接到设备；但是，不必下载应用程序。 在线的 要求：PLC 处于在线模式。 变量表 带有变量名称的驱动变量列表， 设定值 和 当前值 地位 显示 SoftMotion 驱动器的当前状态 通讯设置 显示当前通讯状态 错误 轴误差 FB错 uiDrive接口错误 驱动器接口错误...", 
"body" : "您可以通过此页面上的按钮移动驱动器。驱动器可能会发生意外动作。 采取一切必要的安全预防措施。 此选项卡用于调试物理驱动器时的测试目的。它仅在以下情况下可用 在线配置模式 已启用。在这种模式下，开发系统连接到设备；但是，不必下载应用程序。 在线的 要求：PLC 处于在线模式。 变量表 带有变量名称的驱动变量列表， 设定值 和 当前值 地位 显示 SoftMotion 驱动器的当前状态 通讯设置 显示当前通讯状态 错误 轴误差 FB错 uiDrive接口错误 驱动器接口错误 " }, 
{ "title" : "操作元件 ", 
"url" : "_sm_edt_drive_commisioning.html#UUID-44ff80c7-7f0e-b818-51b8-af95752bbbbd_id_b3c83ad0f91194c0a8646325634a44_id_063bbc9a58bd11e68fa9d28177272265", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用户界面 \/ SoftMotion 驱动器 \/ 标签：调试 \/ 操作元件 ", 
"snippet" : "操作元件 力量 驱动器已通电（与 MC_Power ）。 错误重置 发生错误后重置驱动器（与 MC_Reset ）。 开始归位 驱动器以驱动器中设置的参数执行归位（比较 MC_Home ）。 跑步 通过 < 和 > 开关，驱动器可以根据指定的值向前和向后移动 距离 , 速度 , 加速 , 减速 ， 和 混蛋 （与之比较 MC_Inch ）。 读写 对于指定的驱动参数，当前 价值 从 PLC 读取并显示。在 准备值 ，您可以通过小按钮指定一个新值并写入驱动器中的参数（与 MC_ReadParameter , MC_WriteParameter ）。...", 
"body" : "操作元件 力量 驱动器已通电（与 MC_Power ）。 错误重置 发生错误后重置驱动器（与 MC_Reset ）。 开始归位 驱动器以驱动器中设置的参数执行归位（比较 MC_Home ）。 跑步 通过 < 和 > 开关，驱动器可以根据指定的值向前和向后移动 距离 , 速度 , 加速 , 减速 ， 和 混蛋 （与之比较 MC_Inch ）。 读写 对于指定的驱动参数，当前 价值 从 PLC 读取并显示。在 准备值 ，您可以通过小按钮指定一个新值并写入驱动器中的参数（与 MC_ReadParameter , MC_WriteParameter ）。 " }, 
{ "title" : "选项卡：SoftMotion Drive – 位置控制 ", 
"url" : "_sm_edt_drive_poscontrol_position_control_loop.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用户界面 \/ SoftMotion 驱动器 \/ 选项卡：SoftMotion Drive – 位置控制 ", 
"snippet" : "在此选项卡上，设置位置控制的参数。 另请注意示例  使用 SM_Drive_PosControl 对控制器进行位置控制. 位置控制回路 设置位置 设置位置值 D 死区时间决定了接收到的实际位置（编码器）相移到轴的设定位置的周期数。死区时间取决于应用的组件，并且必须通过反复试验来确定。 有关详细信息，请参阅： 确定系统的死区时间实际位置 实际位置值 位宽 根据使用的组件接收实际值的位宽，可以设置为 16、24 或 32 位值。 最大限度 : 位置误差监控被激活。 输入最大允许滞后 如果在操作期间超过该值，则轴进入错误状态。 Kp 比例常数是位置误差（设定位置与实际位置之间的偏差）乘以稍后添加到设...", 
"body" : "在此选项卡上，设置位置控制的参数。 另请注意示例  使用 SM_Drive_PosControl 对控制器进行位置控制. 位置控制回路 设置位置 设置位置值 D 死区时间决定了接收到的实际位置（编码器）相移到轴的设定位置的周期数。死区时间取决于应用的组件，并且必须通过反复试验来确定。 有关详细信息，请参阅： 确定系统的死区时间实际位置 实际位置值 位宽 根据使用的组件接收实际值的位宽，可以设置为 16、24 或 32 位值。 最大限度 : 位置误差监控被激活。 输入最大允许滞后 如果在操作期间超过该值，则轴进入错误状态。 Kp 比例常数是位置误差（设定位置与实际位置之间的偏差）乘以稍后添加到设定速度的系数。 设定速度 设置速度值 速度输出的缩放 fActPosition 和速度输出方向相反 ：如果速度输出和当前位置具有相反的方向，则可以通过激活该选项来更正。 应用 [tu\/s] 最小和最大速度值（以应用为单位），例如每秒 3600 转。 产值 发送到执行器的最小和最大输出值（例如 16#7FFF）。 " }, 
{ "title" : "选项卡：逻辑轴 ", 
"url" : "_sm_edt_drive_logical_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用户界面 \/ SoftMotion 驱动器 \/ 选项卡：逻辑轴 ", 
"snippet" : "轴型 模数 : 驱动器在不限制运行范围的情况下无休止地转动（例如：皮带驱动器）。 模数设置 模值 : 一个周期的值 该值保存在 fPositionPeriod 的参数 AXIS_REF_SM3 功能块。 注意：如果您选择 模数 驱动器类型，然后是产品 fPositionPeriod * dwRatioTechUnitsDenom 必须是整数。 有限 ：驱动器有一个固定的工作区（例如：一个线性驱动器）。 消极的 : 负限值的输入字段 积极的 : 正限值的输入字段 掌握参考价值 放 ：主站的设定值用作逻辑轴和死区时间补偿的输入。 实际的 ：主站的实际值用作逻辑轴和死区时间补偿的输入。 时间偏移 相...", 
"body" : "轴型 模数 : 驱动器在不限制运行范围的情况下无休止地转动（例如：皮带驱动器）。 模数设置 模值 : 一个周期的值 该值保存在 fPositionPeriod 的参数 AXIS_REF_SM3 功能块。 注意：如果您选择 模数 驱动器类型，然后是产品 fPositionPeriod * dwRatioTechUnitsDenom 必须是整数。 有限 ：驱动器有一个固定的工作区（例如：一个线性驱动器）。 消极的 : 负限值的输入字段 积极的 : 正限值的输入字段 掌握参考价值 放 ：主站的设定值用作逻辑轴和死区时间补偿的输入。 实际的 ：主站的实际值用作逻辑轴和死区时间补偿的输入。 时间偏移 相对于主值的时间偏移 循环次数 必须在此时间跨度内外推设定值 输入数据过滤器 通过滤波器，可以使用 PT1 滤波器平滑编码器的位置和速度值。 位置 用作 PT1 滤波器时间常数的周期数。 取值范围：[0..999.9] 值 0：不执行过滤（返回原始值）。 滤波后的返回值是 PT1 滤波位置信号和使用速度信号的附加位置外推的组合。外推本身也使用 PT1 滤波器来减轻噪声并自动选择适当的时间常数： 如果只过滤设定值或轴发送速度信号，则外推 PT1 的时间常数与位置 PT1 过滤器的时间常数相同。 否则，使用启发式方法： T Extrapolate = (T Pos + T Dead ) * T Pos \/ T Cycle T Extrapolate : 来自 PT1 外推滤波器的时间常数 T Pos : 来自 PT1 位置滤波器的时间常数 T Cycle :  周期 T Dead : 死区时间补偿，使用相对于逻辑轴主值的时间偏移   n Shift  和周期时间   T Cycle : T Dead = n Shift * T Cycle 速度 用作 PT1 滤波器时间常数的周期数。 取值范围：[0..999.9] 值 0：不执行过滤（返回原始值）。 滤波后的返回值是 PT1 滤波后的速度信号和使用加速度信号的附加速度外推的组合。请注意，仅当轴发送速度信号或应过滤设定点时才使用外推。外推本身也使用 PT1 滤波器来减轻噪声并自动选择适当的时间常数： T Extrapolate = (T Vel + T Dead ) * T Vel \/ T Cycle 和 T Extrapolate : 来自 PT1 外推滤波器的时间常数 T Vel : 来自 PT1 速度滤波器的时间常数 T Cycle :  周期 T Dead : 死区时间补偿，使用相对于逻辑轴主值的时间偏移  n Shift  和周期时间  T Cycle : T Dead = n Shift * T Cycle 逻辑轴的速度信号（ fActVelocity ): 情况1： 掌握参考价值 = 放 fSetVelocity 主轴的速度用作逻辑轴速度信号的原始值。 案例二： 掌握参考价值 = 实际的 并且没有来自主轴的速度信号。 过滤后的逻辑轴位置的数值导数（ fActPosition ) 用作逻辑轴速度信号的原始值。 案例三： 掌握参考价值 = 实际的 和来自主轴的速度信号。 速度信号用作逻辑轴速度信号的原始值。 对该原始信号执行速度过滤。这意味着如果配置了默认值 usiFilterDepthVelocity = 0 , 然后这个信号原封不动地传递给 fActVelocity . 在情况 2 中，也可以使用未过滤位置的数值导数 ( fActPosition 主轴）。已选择过滤位置，因为在这种情况下 fActVelocity 逻辑轴的匹配 fActPosition 在没有速度过滤的默认配置中。 对于速度，滤波器延迟的外推仅在情况 1 和情况 3 中执行。在情况 2 中，这在数值上不稳定，或者需要对加速度进行过多滤波才有意义。 逻辑轴的加速度（ fActAcceleration ) 情况1： 掌握参考价值 = 放 fSetAcceleration 主轴的加速度用于逻辑轴的加速度信号。 案例二： 掌握参考价值 = 实际的 和来自主轴的速度信号。 逻辑轴的过滤速度的数值导数（ fActVelocity ) 用于逻辑轴的加速度信号。 案例三： 掌握参考价值 = 实际的 并且没有来自主轴的速度信号。 价值 0 用于逻辑轴的加速度信号，因为对噪声位置进行两次微分会导致无法使用的结果。 逻辑轴的冲击 ( fActJerk ) 逻辑轴的急动度 ( fActJerk ） 或者是 情况1： 掌握参考价值 = 放 fSetJerk 主轴的 jerk 信号用于逻辑轴。 案例二： 掌握参考价值 = 实际的 价值 0 用于逻辑轴的加加速度信号，因为对噪声位置信号进行 3 次微分会导致无法使用的结果。 不对加速度和加加速度信号执行死区时间补偿。 逻辑轴的所有设定值（位置、速度、加速度和加加速度）与实际值相对应。 写入值 写入值 输入数据过滤器 和 时间偏移 在 PLC 上。 鉴别 ID 逻辑轴的唯一 ID 在线的 要求：PLC 处于在线模式。 变量表 带有变量名称的驱动变量列表， 设定值 和 当前值 地位 显示 SoftMotion 驱动器的当前状态 通讯设置 显示当前通讯状态 错误 轴误差 FB错 uiDrive接口错误 驱动器接口错误 " }, 
{ "title" : "标签：编码器 ", 
"url" : "_sm_edt_drive_free_encoder_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 用户界面 \/ SoftMotion 驱动器 \/ 标签：编码器 ", 
"snippet" : "通用编码器设置 模数 在模数驱动器中，必须激活此选项，并且 模值 指定的。 : 驱动器在不限制运行范围的情况下无休止地转动（例如：皮带驱动器）。 这 模数设置 窗口显示： 模值 : 模值的输入字段 该值保存在 fPositionPeriod 的参数 AXIS_REF_SM3 功能块。 注意：如果您选择 模数 驱动器类型，然后是产品 fPositionPeriod * dwRatioTechUnitsDenom 必须是整数。 有限 : 驱动是有限的。 位宽 适当位宽的列表框 缩放 定义设备发送的整数位置值的转换； IEC 应用中使用的增量和技术单位。 反转方向 ：编码器接收到带有相反符号的指定值...", 
"body" : "通用编码器设置 模数 在模数驱动器中，必须激活此选项，并且 模值 指定的。 : 驱动器在不限制运行范围的情况下无休止地转动（例如：皮带驱动器）。 这 模数设置 窗口显示： 模值 : 模值的输入字段 该值保存在 fPositionPeriod 的参数 AXIS_REF_SM3 功能块。 注意：如果您选择 模数 驱动器类型，然后是产品 fPositionPeriod * dwRatioTechUnitsDenom 必须是整数。 有限 : 驱动是有限的。 位宽 适当位宽的列表框 缩放 定义设备发送的整数位置值的转换； IEC 应用中使用的增量和技术单位。 反转方向 ：编码器接收到带有相反符号的指定值，因此以相反的旋转方向旋转。 增量 < = > 编码器旋转 数量 增量 对应完成的数量 编码器旋转 应用中的编码器旋转 <=> 单位 数量 编码器转数 对应于 申请单位 在线的 要求：PLC 处于在线模式。 变量表 带有变量名称的驱动变量列表， 设定值 和 当前值 地位 显示 SoftMotion 驱动器的当前状态 通讯设置 显示当前通讯状态 错误 轴误差 FB错 uiDrive接口错误 驱动器接口错误 " }, 
{ "title" : "CODESYS Softmotion Basic ", 
"url" : "_sm_basic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_sm_overview_basic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 概述 ", 
"snippet" : "CODESYS Softmotion Basic 为各个轴的运动控制提供功能块接口。该接口基于 PLCopen 规范“运动控制功能块第 1 部分 V2.0”。轨迹规划在 CODESYS 控制器。功能范围从移动到目标位置或速度，到叠加两个运动和同步运动，再到通过虚拟齿轮和凸轮。运动命令可以以循环精度进行缓冲和中止，也可以通过超控减速或停止并恢复。...", 
"body" : "CODESYS Softmotion Basic 为各个轴的运动控制提供功能块接口。该接口基于 PLCopen 规范“运动控制功能块第 1 部分 V2.0”。轨迹规划在 CODESYS 控制器。功能范围从移动到目标位置或速度，到叠加两个运动和同步运动，再到通过虚拟齿轮和凸轮。运动命令可以以循环精度进行缓冲和中止，也可以通过超控减速或停止并恢复。 " }, 
{ "title" : "入门 CODESYS Softmotion Basic ", 
"url" : "_sm_basic_first_steps.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 入门 CODESYS Softmotion Basic ", 
"snippet" : "使用以下方式对运动进行编程 CODESYS Softmotion Basic ，需要在设备树中配置至少一个轴。这包括设置轴类型（ 模数 或者 有限 )、速度斜坡类型、软件限位开关和错误反应。 支持的移动类型的概述可以在 单轴运动 章节。 有关如何编程单轴运动的信息，请参阅 控制单轴的运动 章节。 有关凸轮基本使用的更多信息，请参阅 使用虚拟时间轴控制凸轮驱动器 章节。 有关缓冲、混合和叠加运动的信息，请参阅 指挥多个动作 部分。 有关详细信息，请参阅：For more information, see: 大致的了解 凸轮章节： 在凸轮之间切换从应用程序在线创建凸轮： 凸轮的数据结构章节： 使用...", 
"body" : "使用以下方式对运动进行编程 CODESYS Softmotion Basic ，需要在设备树中配置至少一个轴。这包括设置轴类型（ 模数 或者 有限 )、速度斜坡类型、软件限位开关和错误反应。 支持的移动类型的概述可以在 单轴运动 章节。 有关如何编程单轴运动的信息，请参阅 控制单轴的运动 章节。 有关凸轮基本使用的更多信息，请参阅 使用虚拟时间轴控制凸轮驱动器 章节。 有关缓冲、混合和叠加运动的信息，请参阅 指挥多个动作 部分。 有关详细信息，请参阅：For more information, see: 大致的了解 凸轮章节： 在凸轮之间切换从应用程序在线创建凸轮： 凸轮的数据结构章节： 使用 MC_SetOverride 进行动态调整" }, 
{ "title" : "管理功能块 ", 
"url" : "_sm_administrative_fbs.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 管理功能块 ", 
"snippet" : "管理功能块用于查询信息或更改特定设置。但是，它们永远不会触发运动。 物理驱动器（此后称为驱动器）表示为 CODESYS SoftMotion 按软件对象 AXIS_REF_SM3 （此处称为轴）。根据所使用的管理功能块的不同，执行要么在驱动器上，要么在轴上执行，要么在两者上执行。 功能块 MC_Power 控制驱动器的功率级 MC_Reset 重置轴错误和驱动器错误 MC_SetPosition 将轴的坐标系移动到任何值；例如，这可能有助于参考。 SMC3_BrakeControl 当驱动器支持此功能时，控制机械制动器 SMC3_BrakeStatus 读取机械制动器的当前状态 SMC_Cha...", 
"body" : "管理功能块用于查询信息或更改特定设置。但是，它们永远不会触发运动。 物理驱动器（此后称为驱动器）表示为 CODESYS SoftMotion 按软件对象 AXIS_REF_SM3 （此处称为轴）。根据所使用的管理功能块的不同，执行要么在驱动器上，要么在轴上执行，要么在两者上执行。 功能块 MC_Power 控制驱动器的功率级 MC_Reset 重置轴错误和驱动器错误 MC_SetPosition 将轴的坐标系移动到任何值；例如，这可能有助于参考。 SMC3_BrakeControl 当驱动器支持此功能时，控制机械制动器 SMC3_BrakeStatus 读取机械制动器的当前状态 SMC_ChangeDynamicLimits 设置轴的动态极限（速度、加速度、减速、加速度和扭矩） 有关更多信息，请参阅以下内容：中的动态限制 标签：常规SMC_ChangeAxisScalingLinear 更改线性轴的缩放比例 SMC_ChangeAxisScalingRotary 更改旋转轴的缩放比例 SMC_SetForecast 设置 预报 轴的 SMC_GetForecast 返回轴的设定预测 SMC_GetTravelTime 返回轴到达特定位置的时间。这在结合使用时特别有用 预报。 SMC_SetAdditionalConversionFactors 转换设置其他因子。例如，扭矩系数可用于考虑变速箱 SMC_SetControllerMode 当驱动器支持此功能时，为轴设置不同的操作模式 SMC_SetMovementType 将虚拟轴的运动类型设置为 有限的 或者 模数 有关更多信息，请参阅以下内容： 标签：常规。 SMC_SetRampType 设置轴的速度斜坡类型 有关更多信息，请参阅以下内容： 速度斜坡类型 在 标签：常规 章节 SMC_SetSoftwareLimits 设置有限轴的位置限制以及发生错误时的相应反应 有关更多信息，请参阅以下内容： 软件限位开关 和 软件错误反应 在 标签：常规 章节 MC_TouchProbe 在触发定义的触发事件时返回驱动位置 MC_AbortTrigger 中止使用触发事件的函数（例如： MC_TouchProbe ) SMC_ReadFBError 返回轴的功能块错误存储器中最旧的条目。例如，此信息可用于在可视化中显示。 SMC_ClearFBError 从轴的功能块错误存储器中删除最早的条目。 SMC_ReadSetPosition 返回轴的设定位置 SMC_ReadSetValues 返回设定位置、设置速度、设置加速度和设置加速度。什么时候 预报 已启用，将来也可以查询数据。 有关更多信息，请参阅以下内容： smc_setForecast MC_ReadActualPosition 返回驱动器的实际位置 MC_ReadActualVelocity 返回驱动器的实际速度 MC_ReadActualTorque 返回驱动器的实际扭矩或实际力 MC_ReadAxisError 从驱动器读取错误 MC_ReadStatus 读取轴的当前状态 SMC_CheckAxisCommunication 返回轴的通信状态 SMC_CheckLimits 检查当前设定值是否超过轴的设定动态极限 有关更多信息，请参阅以下内容： smc_changeDynamicLimits 和 动态极限 在 标签：常规SMC_GetTrackingError 返回轴的延迟（轴的设定位置与驱动器的实际位置之间的差异） SMC_InPosition 返回延迟是否在可配置范围内 SMC_MeasureDistance 返回自区块启动以来轴行进的距离。这对于模数轴特别有用 MC_ReadBoolParameter 从轴或驱动器读取布尔值 MC_ReadParameter 从轴或驱动器读取一个值 MC_WriteBoolParameter 将布尔值写入轴或驱动器 MC_WriteParameter 向轴或驱动器写入一个值 诊断功能块 SMC_AxisDiagnosticLog 写入轴的设定值和实际值（位置、速度和加速度），然后循环驱动到文件中。这有助于诊断其他工具中的错误和运动顺序。 SMC_GetMaxSetVelocity 记录轴设定速度的最大值。此功能块可用于诊断目的。 SMC_GetMaxSetAccDec 记录轴设定加速度的最大值。此功能块可用于诊断目的。 坚持 SMC3_PersistPosition 使用绝对编码器保持轴的位置 有关 “Persist” 的更多信息，请参阅以下内容： 保持轴位置SMC3_PersistPositionLogical 保持逻辑轴的位置 有关逻辑轴的更多信息，请参阅以下内容： 逻辑驱动器" }, 
{ "title" : "单轴运动 ", 
"url" : "_sm_basic_single_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 单轴运动 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_sm_overview_single_axis_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 单轴运动 \/ 概述 ", 
"snippet" : "CODESYS SoftMotion 区分仅作用于单个轴的运动和两个轴同步的运动（例如，通过电子凸轮或虚拟齿轮）。后者在 双轴同步运动 帮助页面。 基本上，仅作用于单个轴的运动块可细分为以下几类： 运动块 堵塞 描述 MC_MoveAbsolute 执行到指定位置的移动 MC_MoveRelative 相对于当前位置执行指定距离的移动 MC_MoveAdditive 执行相对于另一个运动的最后命令目标位置的指定距离的运动（例如，从 MC_MoveAbsolute ） MC_MoveSuperimposed 除了另一个活动移动之外，还执行指定相对距离的移动（例如，从 MC_MoveAbsolut...", 
"body" : "CODESYS SoftMotion 区分仅作用于单个轴的运动和两个轴同步的运动（例如，通过电子凸轮或虚拟齿轮）。后者在 双轴同步运动 帮助页面。 基本上，仅作用于单个轴的运动块可细分为以下几类： 运动块 堵塞 描述 MC_MoveAbsolute 执行到指定位置的移动 MC_MoveRelative 相对于当前位置执行指定距离的移动 MC_MoveAdditive 执行相对于另一个运动的最后命令目标位置的指定距离的运动（例如，从 MC_MoveAbsolute ） MC_MoveSuperimposed 除了另一个活动移动之外，还执行指定相对距离的移动（例如，从 MC_MoveAbsolute ）。活动运动不会被中止。 MC_MoveVelocity 以指定速度执行连续运行的运动 SMC_MoveContinuousAbsolute 执行到指定位置的移动。在这种情况下，将以定义的速度到达目标位置，然后保持该速度。 SMC_MoveContinuousRelative 相对于当前位置执行指定距离的移动。在这种情况下，以定义的速度到达目标位置，然后保持该速度。 MC_Jog 只要轴向前或向后移动，就以指定的速度执行连续运行的运动 SMC_Inch 只要轴向前或向后移动，就相对于当前位置执行指定距离的移动 停止运动 堵塞 描述 MC_Halt 执行受控停止，中断任何活动的运动，并使轴停止。 MC_Halt 适用于正常运行条件，因为停止可以被新的运动中断。此外，停止后可以更轻松地恢复运行，因为轴仍处于运行状态。 MC_Stop 执行受控停止，中断任何活动的运动，并使轴停止。 MC_Stop 适用于紧急情况，因为停止不能被新的运动打断。停止后，轴处于停止状态，因此不接受任何新的运动。只有在停止完成后，新的运动才可能再次发生，并且 Execute 输入设置为 FALSE 。 MC_HaltSuperImposed 执行受控停止 SuperImposed 运动。在此过程中，底层运动不会中止 归巢 堵塞 描述 MC_Home 启动驱动器控制轴的归位。操作及其参数取决于驱动器和制造商。 SMC_Homing 开始对控制器控制的轴进行归位 MC_SetPosition 不移动轴，而只移动零点。这样，该块可以用于参考。此外，还可以在活动运动期间调用该块。 特殊机芯 堵塞 描述 SMC_FollowPosition 写入轴的设定位置。这可用于将您自己计算的轨迹传递到轴。 SMC_FollowVelocity 写入轴的设定速度。这可用于将您自己计算的轨迹传递到轴。 SMC_FollowPositionVelocity 写入轴的设定位置和速度。这可用于将您自己计算的轨迹传递到轴。 SMC_FollowSetValues 选择性地写入轴的设定位置、速度、加速度、加速度和\/或设定目标扭矩。这可用于将您自己计算的轨迹传递给轴。 SMC_SetTorque 写入轴的设定扭矩。根据轴的操作模式，该值可用于扭矩前馈控制或作为轴应施加的扭矩。 " }, 
{ "title" : "动作中断 ", 
"url" : "_sm_interrupt_single_axis_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 单轴运动 \/ 动作中断 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "单轴运动中断 ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_section-idm234855926060424", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 单轴运动 \/ 动作中断 \/ 单轴运动中断 ", 
"snippet" : "单轴运动，例如 mc_move绝对值 ，可以随时被其他动作打断。这可以是向其他位置的移动，也可以是最大速度、加速度发生变化，也可以是使用相同动作类型和相同位置的猛冲。中断的实现方式是速度不会跳跃。对于所有二次斜坡类型，加速度也没有跳跃 在特定情况下，由于运动中止，轴的反转是不可避免的： 如果是新的目标位置 MC_MoveAbsolute 存在于当前减速距离结束之前 如果对中止的运动使用较小的最大减速和\/或较小的最大加速度，这反过来又会将减速距离延长到目标位置以外 如果 SMC_MoveContinuousAbsolute 或者 SMC_MoveContinuousRelative 与 EndV...", 
"body" : "单轴运动，例如 mc_move绝对值 ，可以随时被其他动作打断。这可以是向其他位置的移动，也可以是最大速度、加速度发生变化，也可以是使用相同动作类型和相同位置的猛冲。中断的实现方式是速度不会跳跃。对于所有二次斜坡类型，加速度也没有跳跃 在特定情况下，由于运动中止，轴的反转是不可避免的： 如果是新的目标位置 MC_MoveAbsolute 存在于当前减速距离结束之前 如果对中止的运动使用较小的最大减速和\/或较小的最大加速度，这反过来又会将减速距离延长到目标位置以外 如果 SMC_MoveContinuousAbsolute 或者 SMC_MoveContinuousRelative 与 EndVelocity 如果不反转，就无法从当前轴状态到达 当坡道打字时 sin² 和 二次方（平滑） 使用时，即使似乎没有必要，也可以在中断期间发生逆转。（也就是说，即使上面列出的原因不适用。请参阅下面的解释。）然后，尽管新目标位置不在旧目标位置之前，但它可能会被超越。即使最大减速和最大加速度没有改变（甚至增加），并且与中止的运动相比，最终速度没有改变，也可能会发生这种情况。在这种情况下，以下规则适用： 对于梯形和二次斜坡类型，绝不会出现任何过度移动的情况。 对于 sin² 斜坡类型，当新的目标位置以及加速和减速的极限值等于旧值时，不会出现超速行驶。 在所有其他情况下，可能会出现超额旅行的情况 sin² 和 二次方（平滑） 坡道类型。 的解释 sin² 斜坡类型：中止的运动以新的 sin² 速度斜坡开始，这意味着加速度从 0 开始并逐渐增加或减少。如果中止时轴的加速度不等于 0，则在 sin² 速度斜坡开始时，加速度会跳至 0。这可能导致超速行驶，因为增加或减少加速度需要时间 的解释 二次曲线（平滑） 坡道类型：同样的解释也适用 sin² ，而是为了猛冲而不是加速。 关于覆盖的注意事项 基于上述解释，使用 MC_SetOverride 和 sin² 和 二次曲线（平滑） 不推荐使用坡道类型 " }, 
{ "title" : "减速阶段中断 ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_id_fbc677d73098ed1c0a86463411e7edd_id_b5d8fdf3fc0362bfc0a8658d00b6a52e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 单轴运动 \/ 动作中断 \/ 减速阶段中断 ", 
"snippet" : "单轴运动，例如 MC_MoveAbsolute , 可以随时被其他动作打断。这可以是移动到另一个位置或速度或加速度的变化。基本上，运动的中断是由另一个人以没有速度跳跃的方式实现的。对于所有坡道类型（除了 梯形 )，加速度也没有跳跃。当斜坡类型 罪² 和 二次（平滑） 使用时，在中断期间可能会发生反转，并且起初似乎没有必要（见解释）。然后越过新的目标位置，尽管它不在旧的目标位置之前。这可能发生在以下情况： 如果为取消运动设置了比以前更小的最大减速度值 在这种情况下，到新目标位置的可用减速距离可能太短（对于所有斜坡类型）。 因此，对于 二次方 和 二次（平滑） 当为 jerk 设置较低的最大值时的...", 
"body" : "单轴运动，例如 MC_MoveAbsolute , 可以随时被其他动作打断。这可以是移动到另一个位置或速度或加速度的变化。基本上，运动的中断是由另一个人以没有速度跳跃的方式实现的。对于所有坡道类型（除了 梯形 )，加速度也没有跳跃。当斜坡类型 罪² 和 二次（平滑） 使用时，在中断期间可能会发生反转，并且起初似乎没有必要（见解释）。然后越过新的目标位置，尽管它不在旧的目标位置之前。这可能发生在以下情况： 如果为取消运动设置了比以前更小的最大减速度值 在这种情况下，到新目标位置的可用减速距离可能太短（对于所有斜坡类型）。 因此，对于 二次方 和 二次（平滑） 当为 jerk 设置较低的最大值时的斜坡类型 但是，如果这些最大值保持不变（或增加），则适用以下规则： 为了 梯形 和 二次方 坡道类型，永远不会有任何超车。 为了 罪² 斜坡类型，当新的目标位置和加速度和减速度的限制值等于旧值时不会超程。 在所有其他情况下，可能会出现超程 罪² 和 二次（平滑） 坡道类型。 " }, 
{ "title" : "双轴同步运动 ", 
"url" : "_sm_basic_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_sm_overview_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 概述 ", 
"snippet" : "本节概述一个轴与另一个轴同步移动的运动（取决于时间或位置）。 凸轮：根据驱动器（主驱动器），另一个驱动器（从驱动器）应执行任何类型的定义运动。有关更多信息，请参阅： 凸轮使用定义的传动比实现两个轴的同步 MC_GearIn ， MC_GearOut ， 和 MC_齿轮在位置 。有关这些功能的更多信息，请参阅相应功能块的文档。 主轴和从轴之间的相位偏移使用 MC_Phasing 。有关此功能的更多信息，请参阅功能块的文档。 使用以下方法补偿机械部件（例如，在变速箱中）之间的间隙 SMC_间隙补偿 。有关此功能的更多信息，请参阅功能块的文档。...", 
"body" : "本节概述一个轴与另一个轴同步移动的运动（取决于时间或位置）。 凸轮：根据驱动器（主驱动器），另一个驱动器（从驱动器）应执行任何类型的定义运动。有关更多信息，请参阅： 凸轮使用定义的传动比实现两个轴的同步 MC_GearIn ， MC_GearOut ， 和 MC_齿轮在位置 。有关这些功能的更多信息，请参阅相应功能块的文档。 主轴和从轴之间的相位偏移使用 MC_Phasing 。有关此功能的更多信息，请参阅功能块的文档。 使用以下方法补偿机械部件（例如，在变速箱中）之间的间隙 SMC_间隙补偿 。有关此功能的更多信息，请参阅功能块的文档。 " }, 
{ "title" : "凸轮 ", 
"url" : "_sm_f_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_sm_overview_synch_movements_2_axis_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 概述 ", 
"snippet" : "这 SoftMotion cam 集成在用户界面中 CODESYS 在凸轮编辑器中，凸轮和挺杆可以以图形或表格形式实现。一旦为相应的应用程序生成代码，就会创建 IEC 程序可以访问的全局数据结构（“凸轮数据”）。为此， SM3_Basic 插入 SoftMotion 驱动器时也会自动链接到项目中。 有关详细信息，请参阅：For more information, see: 的定义 和 如何创建凸轮...", 
"body" : "这 SoftMotion cam 集成在用户界面中 CODESYS 在凸轮编辑器中，凸轮和挺杆可以以图形或表格形式实现。一旦为相应的应用程序生成代码，就会创建 IEC 程序可以访问的全局数据结构（“凸轮数据”）。为此， SM3_Basic 插入 SoftMotion 驱动器时也会自动链接到项目中。 有关详细信息，请参阅：For more information, see: 的定义 和 如何创建凸轮" }, 
{ "title" : "的定义 SoftMotion 凸轮 ", 
"url" : "_sm_cam_definition_softmotion_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 的定义 SoftMotion 凸轮 ", 
"snippet" : "凸轮描述了一个驱动器（从站）对另一个驱动器（主站）的功能依赖性。该关系由将定义的主值范围映射到从值的连续函数（或曲线）描述。更准确地说：在将主轴分成合适的段后，这些函数的图形可以在每个区间上用一条线或一个 5 次多项式表示。 例子 在凸轮图中，主值应用于水平轴，从属值应用于垂直轴。 在示例中，主值介于 0 和 360 之间。此范围分为三个区间： (1) 第一个区间：[0, 140] (2) 第二个区间：[140, 280] (3) 第三个区间：[280, 360] 函数（图形）在第一个和第三个区间是线性的，它的图形显示为一条线。结果，它的一阶导数（斜率）是常数，所有高阶导数都是 0。 在第二个...", 
"body" : "凸轮描述了一个驱动器（从站）对另一个驱动器（主站）的功能依赖性。该关系由将定义的主值范围映射到从值的连续函数（或曲线）描述。更准确地说：在将主轴分成合适的段后，这些函数的图形可以在每个区间上用一条线或一个 5 次多项式表示。 例子 在凸轮图中，主值应用于水平轴，从属值应用于垂直轴。 在示例中，主值介于 0 和 360 之间。此范围分为三个区间： (1) 第一个区间：[0, 140] (2) 第二个区间：[140, 280] (3) 第三个区间：[280, 360] 函数（图形）在第一个和第三个区间是线性的，它的图形显示为一条线。结果，它的一阶导数（斜率）是常数，所有高阶导数都是 0。 在第二个区间中，图形由 5 次多项式描述。因此，它的一阶导数是一个 4 次多项式，它的二阶导数（曲率）是一个 3 次多项式，它的三阶导数是一个 2 次多项式，等等。 当函数根据主站的位置描述从站的运动时，它的一阶导数对应于从站的速度，二阶导数对应于它的加速度。 当您牢记这种物理解释时，很明显映射必须是连续的。这意味着它的图形不允许有任何跳跃。特别是，连续性也必须在两个间隔相交的每个点处实现。此外，一阶和二阶导数通常也需要连续性。 （实际上，区间起点和终点的这三个连续性条件决定了插入两条直线段之间的 5 次多项式的系数。 此外，您可以在凸轮的任何位置添加挺杆（二进制开关）。这样，您可以创建仅包含挺杆的凸轮表。然后从位置在整个主值范围内设置为零。 " }, 
{ "title" : "已定义的区段类型概述 ", 
"url" : "_sm_overview_segment_types.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 已定义的区段类型概述 ", 
"snippet" : "CODESYS SoftMotion 为凸轮提供各种分段类型。 视情况而定 编译格式 ，仅支持部分区段类型： XYVA：仅限 Line 和 Poly5。 区段：支持所有区段类型。 区段类型 参数 曲线 Poly7 边界条件 主职位 奴隶位置 从属速度 从属加速 奴隶混蛋 Poly5 边界条件 主职位 奴隶位置 从属速度 从属加速 ModifiedSine 边界条件 主职位 奴隶位置 从属速度 分段参数 任一拐点参数 α (0≤α≤1) 或者加速度参数 C 一个 * （最大减速） Line 边界条件 主职位 奴隶位置 InclinedSine 边界条件 主职位 奴隶位置 分段类型的选择取决于应用...", 
"body" : "CODESYS SoftMotion 为凸轮提供各种分段类型。 视情况而定 编译格式 ，仅支持部分区段类型： XYVA：仅限 Line 和 Poly5。 区段：支持所有区段类型。 区段类型 参数 曲线 Poly7 边界条件 主职位 奴隶位置 从属速度 从属加速 奴隶混蛋 Poly5 边界条件 主职位 奴隶位置 从属速度 从属加速 ModifiedSine 边界条件 主职位 奴隶位置 从属速度 分段参数 任一拐点参数 α (0≤α≤1) 或者加速度参数 C 一个 * （最大减速） Line 边界条件 主职位 奴隶位置 InclinedSine 边界条件 主职位 奴隶位置 分段类型的选择取决于应用程序，因为每种类型都有特殊的动态特性。根据运动任务（例如，停留 — 恒定速度），有多种适用的分段类型。 下表提供了概述： 居住 (v=0, a=0) 恒定速度 (v­­≠0, a=0) 逆转 (v=0, a≠0) 运动 (v≠0, a≠0) 居住 (v=0, a=0) Line Poly5\/7 InclinedSine ModifiedSine Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 恒定速度 (v≠0, a=0) Poly5\/7 ModifiedSine Line Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 逆转 (v=0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 运动 (v≠0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 " }, 
{ "title" : "凸轮编辑器的结构 ", 
"url" : "_sm_cam_editor_layout.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 凸轮编辑器的结构 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_sm_overview_synch_movements_2_axis_cam_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 凸轮编辑器的结构 \/ 概述 ", 
"snippet" : "双击打开凸轮编辑器 凸轮 设备树中的对象。 该编辑器由以下选项卡组成： 标签：凸轮 选项卡：在此编辑器中，您可以使用图形编辑器创建凸轮路径。在这里，您可以显示和修改从动位置、从动速度、从动加速度和从动加加速度。在图形编辑器中，您可以非常快速地识别出何时对高加速度的运动进行编程。 凸轮表 选项卡：在此编辑器中，基点以表格形式显示。在这里，您可以指定精确的位置和速度。 挺杆 选项卡：在此编辑器中，您可以在图表中对挺杆（开关点）进行编程。此显示提供了挺杆顺序的非常好的概览。 挺杆台 tab：在此编辑器中，切换点以表格形式呈现。在这里，您可以指定确切的切换点。 这些选项卡分为一个编辑器，以及一个 工具...", 
"body" : "双击打开凸轮编辑器 凸轮 设备树中的对象。 该编辑器由以下选项卡组成： 标签：凸轮 选项卡：在此编辑器中，您可以使用图形编辑器创建凸轮路径。在这里，您可以显示和修改从动位置、从动速度、从动加速度和从动加加速度。在图形编辑器中，您可以非常快速地识别出何时对高加速度的运动进行编程。 凸轮表 选项卡：在此编辑器中，基点以表格形式显示。在这里，您可以指定精确的位置和速度。 挺杆 选项卡：在此编辑器中，您可以在图表中对挺杆（开关点）进行编程。此显示提供了挺杆顺序的非常好的概览。 挺杆台 tab：在此编辑器中，切换点以表格形式呈现。在这里，您可以指定确切的切换点。 这些选项卡分为一个编辑器，以及一个 工具箱 查看和 特性 看法。 使用凸轮编辑器的程序示例 " }, 
{ "title" : "标签：凸轮 ", 
"url" : "_sm_obj_cam_table_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 凸轮编辑器的结构 \/ 标签：凸轮 ", 
"snippet" : "在此图形编辑器中，定义了凸轮图。您可以随时在图形编辑器和备用表格编辑器 ( 标签：凸轮表）。 编辑器中显示四张图形的曲线： 从机位置（黑色） 从动速度（蓝色） 从站加速（绿色） 奴隶混蛋（黄色） 所有四个坐标系的水平轴显示主值的范围 ([0,360])。位置图中的垂直轴显示凸轮属性中定义的值范围。速度、加速度和加加速度的垂直轴会自动缩放。 为新插入的凸轮分配默认值。它由四个点组成，将图细分为三个部分：[0,120]、[120,240] 和 [240,360]。凸轮图的每个间隔部分都是 Poly5 类型（5 次多项式）。 您可以编辑所有曲线。由于速度、加速度和加速度是派生曲线，因此其中一个图表的...", 
"body" : "在此图形编辑器中，定义了凸轮图。您可以随时在图形编辑器和备用表格编辑器 ( 标签：凸轮表）。 编辑器中显示四张图形的曲线： 从机位置（黑色） 从动速度（蓝色） 从站加速（绿色） 奴隶混蛋（黄色） 所有四个坐标系的水平轴显示主值的范围 ([0,360])。位置图中的垂直轴显示凸轮属性中定义的值范围。速度、加速度和加加速度的垂直轴会自动缩放。 为新插入的凸轮分配默认值。它由四个点组成，将图细分为三个部分：[0,120]、[120,240] 和 [240,360]。凸轮图的每个间隔部分都是 Poly5 类型（5 次多项式）。 您可以编辑所有曲线。由于速度、加速度和加速度是派生曲线，因此其中一个图表的变化也会影响其他 您可以通过移动水平分隔条来更改图表的高度。 看法： 工具箱 选择 使用此工具在表中选择一行。 按 删除选定的点 德尔 钥匙。 添加点 使用此工具添加新点。单击图中的插入点。然后自动调整图形，使其曲线穿过新插入的点。 “属性”视图 X 从轴的 X 位置 Y 从轴的 Y 位置 V 从轴速度 A 从轴的加速度 J 从轴抖动 有关更多信息，请参阅： 属性 – 凸轮 和 如何创建凸轮" }, 
{ "title" : "标签：凸轮表 ", 
"url" : "_sm_obj_cam_table_cam_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 凸轮编辑器的结构 \/ 标签：凸轮表 ", 
"snippet" : "作为图形编辑器的替代方案，您还可以在凸轮表中定义凸轮图 ( 凸轮 标签）。您可以随时在表格编辑器和图形编辑器之间切换。 表格的第一行总是包含主站的开始位置（和相关的从站值），最后一行总是结束位置。中间的线交替定义线段和点。 插入新行 删除选定的片段 X 从轴的 X 位置 Y 从轴的 Y 位置 V 从轴速度 A 从轴的加速度 J 从轴抖动 段类型 Line : 线 Poly5 : 5 度多项式 Poly7 : 7 度多项式 inclinedSine : 倾斜的正弦线 ModifiedSine : 修改后的正弦线 Lambda 修改后的正弦线的拐点参数 加速度参数 修改后的正弦线的最大延迟参数 以...", 
"body" : "作为图形编辑器的替代方案，您还可以在凸轮表中定义凸轮图 ( 凸轮 标签）。您可以随时在表格编辑器和图形编辑器之间切换。 表格的第一行总是包含主站的开始位置（和相关的从站值），最后一行总是结束位置。中间的线交替定义线段和点。 插入新行 删除选定的片段 X 从轴的 X 位置 Y 从轴的 Y 位置 V 从轴速度 A 从轴的加速度 J 从轴抖动 段类型 Line : 线 Poly5 : 5 度多项式 Poly7 : 7 度多项式 inclinedSine : 倾斜的正弦线 ModifiedSine : 修改后的正弦线 Lambda 修改后的正弦线的拐点参数 加速度参数 修改后的正弦线的最大延迟参数 以下值来自相应段的值。它们不能被修改。 分钟（位置） 从站位置最小值 最大（位置） 从站位置最大值 最大（速度） 从站速度的最大值，基于主轴 最大（加速度） 从站加速度的最大值，基于主轴 看法： 工具箱 选择 使用此工具在表中选择一行。 按 删除选定的点 德尔 钥匙。 有关更多信息，请参阅： 属性 – 凸轮 和 如何创建凸轮" }, 
{ "title" : "标签： 推杆 ", 
"url" : "_sm_obj_cam_table_tappets.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 凸轮编辑器的结构 \/ 标签： 推杆 ", 
"snippet" : "在此图形编辑器中，定义了挺杆路径。挺杆路径根据主位置定义一个或多个挺杆。在编辑器窗口的上边缘，水平轴接近主位置的范围。各个挺杆路径如下。 您可以随时在图形编辑器和备用表格编辑器 ( 挺杆台）。 挺杆路径的“Track ID” 推杆路径的所有推杆均指同一个推杆开关（BOOL 类型的变量）。 看法： 工具箱 选择 使用此工具选择挺杆。您可以将选定的挺杆拖到另一个位置。 您可以通过单击挺杆的相关端来修改挺杆的开\/关属性 越线。 按 删除选定的挺杆 德尔 钥匙。 使用此工具添加新挺杆。单击路径中的插入点。 “属性”视图 如果挺杆从主动轴的位置沿正（增加主动值）或负方向传递，则将其分配给结果。 X 挺杆...", 
"body" : "在此图形编辑器中，定义了挺杆路径。挺杆路径根据主位置定义一个或多个挺杆。在编辑器窗口的上边缘，水平轴接近主位置的范围。各个挺杆路径如下。 您可以随时在图形编辑器和备用表格编辑器 ( 挺杆台）。 挺杆路径的“Track ID” 推杆路径的所有推杆均指同一个推杆开关（BOOL 类型的变量）。 看法： 工具箱 选择 使用此工具选择挺杆。您可以将选定的挺杆拖到另一个位置。 您可以通过单击挺杆的相关端来修改挺杆的开\/关属性 越线。 按 删除选定的挺杆 德尔 钥匙。 使用此工具添加新挺杆。单击路径中的插入点。 “属性”视图 如果挺杆从主动轴的位置沿正（增加主动值）或负方向传递，则将其分配给结果。 X 挺杆的位置 正传 打开\/关闭属性 无动作 切换到开 切换到关闭 倒置 否定通过 打开\/关闭属性 无动作 切换到开 切换到关闭 倒置 挺杆属性的可能组合表 挺杆符号 正传 否定通过 无动作 无动作 切换到开 无动作 切换到关闭 无动作 无动作 切换到开 无动作 切换到关闭 切换到开 切换到关闭 切换到开 切换到关闭 切换到关闭 切换到开 切换到关闭 切换到关闭 倒置 无动作 无动作 倒置 切换到开 倒置 倒置 切换到开 倒置 切换到关闭 切换到关闭 倒置 倒置 倒置 有关更多信息，请参阅： 如何定义开关点" }, 
{ "title" : "挺杆台 标签 ", 
"url" : "_sm_obj_cam_table_tappet_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 凸轮编辑器的结构 \/ 挺杆台 标签 ", 
"snippet" : "在此表格中，您还可以配置挺杆路径作为图形编辑器的替代方案 ( 标签： 推杆）。挺杆路径根据主位置定义一个或多个挺杆。在表中，定义各挺杆路径的行列在定义挺杆路径的每行下方。 您可以随时在表格编辑器和图形编辑器之间切换。 插入新挺杆 删除挺杆 曲目编号 挺杆路径ID 推杆路径的所有推杆均指同一个推杆开关（BOOL 类型的变量）。 X 挺杆的位置 正传 打开\/关闭属性 无动作 切换到开 切换到关闭 倒置 否定通过 打开\/关闭属性 无动作 切换到开 切换到关闭 倒置 看法： 特性 如果挺杆从主动轴的位置沿正（增加主动值）或负方向传递，则将其分配给结果。 X 挺杆的位置 正传 打开\/关闭属性 无动作 切...", 
"body" : "在此表格中，您还可以配置挺杆路径作为图形编辑器的替代方案 ( 标签： 推杆）。挺杆路径根据主位置定义一个或多个挺杆。在表中，定义各挺杆路径的行列在定义挺杆路径的每行下方。 您可以随时在表格编辑器和图形编辑器之间切换。 插入新挺杆 删除挺杆 曲目编号 挺杆路径ID 推杆路径的所有推杆均指同一个推杆开关（BOOL 类型的变量）。 X 挺杆的位置 正传 打开\/关闭属性 无动作 切换到开 切换到关闭 倒置 否定通过 打开\/关闭属性 无动作 切换到开 切换到关闭 倒置 看法： 特性 如果挺杆从主动轴的位置沿正（增加主动值）或负方向传递，则将其分配给结果。 X 挺杆的位置 正传 打开\/关闭属性 无动作 切换到开 切换到关闭 倒置 否定通过 打开\/关闭属性 无动作 切换到开 切换到关闭 倒置 有关更多信息，请参阅： 如何定义开关点" }, 
{ "title" : "如何创建凸轮 ", 
"url" : "_sm_cam_creating_a_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 如何创建凸轮 ", 
"snippet" : "创建凸轮的步骤通过一个示例应用程序进行了说明，该示例应用程序描述了一个具有八个槽（45° 分割）的转台。在内部，有一个通过超声波熔合的组件。旋转工作台转动后，焊接工具由直线驱动器送入。焊接完成后，直线轴返回，转台继续转动。 工作步骤 转台转动 45°（持续时间：400 毫秒）。 焊头向下移动 250 毫米的垂直轴（持续时间：200 毫秒）。 开始焊接（持续时间：1200 ms）。 焊头向上移动 250 毫米的垂直轴（持续时间：200 毫秒）。 总时间为 2000 ms 的循环时间。 该应用程序通过连续运行（模数）的虚拟主轴实现。轴的最终值根据 2000 ms 的循环时间进行投影。转台以凸轮形式...", 
"body" : "创建凸轮的步骤通过一个示例应用程序进行了说明，该示例应用程序描述了一个具有八个槽（45° 分割）的转台。在内部，有一个通过超声波熔合的组件。旋转工作台转动后，焊接工具由直线驱动器送入。焊接完成后，直线轴返回，转台继续转动。 工作步骤 转台转动 45°（持续时间：400 毫秒）。 焊头向下移动 250 毫米的垂直轴（持续时间：200 毫秒）。 开始焊接（持续时间：1200 ms）。 焊头向上移动 250 毫米的垂直轴（持续时间：200 毫秒）。 总时间为 2000 ms 的循环时间。 该应用程序通过连续运行（模数）的虚拟主轴实现。轴的最终值根据 2000 ms 的循环时间进行投影。转台以凸轮形式实现（模数；最终值：45°）。垂直轴也作为凸轮实现（受限；最终值：300 mm）。焊接过程由挺杆控制。 设置凸轮的属性 选择 轮盘 设备树中的凸轮。 点击 特性 在里面 看法 菜单或上下文菜单中。 选择 凸轮 标签。 指定以下值： 主起始位置 : 0 主端位置 : 2000 从站起始位置 : 0 从站终端位置 : 45 平稳过渡 ： （已禁用） 点击 行 退出对话框。确认更改凸轮对象的对话框。 更改值 纵轴 以同样的方式拍摄： 主起始位置 : 0 主端位置 : 2000 从站起始位置 : 0 从站终端位置 : 300 平稳过渡 ： （启用） 点击 行 退出对话框。确认更改凸轮对象的对话框。 " }, 
{ "title" : "将凸轮添加到设备树 ", 
"url" : "_sm_cam_creating_a_cam.html#UUID-7c227a8f-47be-4a95-ca96-f0cd1d78635d_id_edb85f246cc9d9f4c0a8646368ed3bd6_id_fa86c256038b2152c0a864632d864483", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 如何创建凸轮 \/ 将凸轮添加到设备树 ", 
"snippet" : "要求：选择了一个 SoftMotion 控制器。 在设备树中，选择 应用 目的。 点击 项目→添加对象→凸轮表 . 指定名称 轮盘 对于凸轮并单击 行 . 该对象被插入到设备树中。凸轮编辑器打开。 插入另一个名为 纵轴 ....", 
"body" : "要求：选择了一个 SoftMotion 控制器。 在设备树中，选择 应用 目的。 点击 项目→添加对象→凸轮表 . 指定名称 轮盘 对于凸轮并单击 行 . 该对象被插入到设备树中。凸轮编辑器打开。 插入另一个名为 纵轴 . " }, 
{ "title" : "如何更改凸轮路径 ", 
"url" : "_sm_cam_changing_the_course.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 如何更改凸轮路径 ", 
"snippet" : "这些说明使用来自 如何创建凸轮 章节来演示如何更换凸轮。...", 
"body" : "这些说明使用来自 如何创建凸轮 章节来演示如何更换凸轮。 " }, 
{ "title" : "使用图形编辑器更改路径 ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_0e7e8ac72c554f26c0a86463347ccca5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 如何更改凸轮路径 \/ 使用图形编辑器更改路径 ", 
"snippet" : "打开 轮盘 cam 在编辑器中。 这 凸轮 选项卡可见。 选择 120 处的点并按删除键 ( 德尔 ）。同时删除 240 处的点。 选择 添加点 工具从 工具箱 看法。 当您将鼠标指针移入编辑器时，它会变成十字准线。 点击附近 主位 400 和 从站位置 上图中的 45（从站位置）。 从动位置的曲线发生变化。速度、加速度和加加速度的曲线也会发生变化。 通过单击选择新插入的点。 将该点拖动到另一个位置。 从动位置的曲线作相应调整。 更改 X 和 是 属性分别为 400 和 45 的精确值。 以同样的方式，将主位置2000处的点的X值更改为45。 选择 选择 工具从 工具箱 看法。 选择第二个曲线...", 
"body" : "打开 轮盘 cam 在编辑器中。 这 凸轮 选项卡可见。 选择 120 处的点并按删除键 ( 德尔 ）。同时删除 240 处的点。 选择 添加点 工具从 工具箱 看法。 当您将鼠标指针移入编辑器时，它会变成十字准线。 点击附近 主位 400 和 从站位置 上图中的 45（从站位置）。 从动位置的曲线发生变化。速度、加速度和加加速度的曲线也会发生变化。 通过单击选择新插入的点。 将该点拖动到另一个位置。 从动位置的曲线作相应调整。 更改 X 和 是 属性分别为 400 和 45 的精确值。 以同样的方式，将主位置2000处的点的X值更改为45。 选择 选择 工具从 工具箱 看法。 选择第二个曲线元素（介于 400 和 2000 之间）。 更改 细分类型 财产 线 . 在图形编辑器中检查曲线。 展示： " }, 
{ "title" : "用凸轮表改变路径 ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_a888a2ff556a11e6abf6d2d0503b3e46", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 如何更改凸轮路径 \/ 用凸轮表改变路径 ", 
"snippet" : "打开 纵轴 cam 在编辑器中。 这 凸轮 选项卡可见。 选择 凸轮表 标签。 点击 符号删除 120 处的点。同时删除 240 处的点。 点击 象征。 在 (1000\/150) 处插入一个新点和一个新段。 再加两点。 更改以下点的值 X \/ Y： 第 1 点： 0 \/ 0 第 2 点： 400 \/ 0 第 3 点： 600 \/ 250 第 4 点： 1800 \/ 250 第 5 点： 2000 \/ 0 从动位置的曲线发生变化。速度、加速度和加加速度的曲线也会发生变化。 在凸轮表中，更改 细分类型 第一和第三段的 线 . 在图形编辑器中检查曲线。 展示： 在实践中，不同凸轮的曲线经常被定义为重...", 
"body" : "打开 纵轴 cam 在编辑器中。 这 凸轮 选项卡可见。 选择 凸轮表 标签。 点击 符号删除 120 处的点。同时删除 240 处的点。 点击 象征。 在 (1000\/150) 处插入一个新点和一个新段。 再加两点。 更改以下点的值 X \/ Y： 第 1 点： 0 \/ 0 第 2 点： 400 \/ 0 第 3 点： 600 \/ 250 第 4 点： 1800 \/ 250 第 5 点： 2000 \/ 0 从动位置的曲线发生变化。速度、加速度和加加速度的曲线也会发生变化。 在凸轮表中，更改 细分类型 第一和第三段的 线 . 在图形编辑器中检查曲线。 展示： 在实践中，不同凸轮的曲线经常被定义为重叠，以节省循环时间。在上面的示例中，垂直轴可能在转台仍在运动时已经开始运动（例如，在 X:350 处）。 " }, 
{ "title" : "如何定义开关点 ", 
"url" : "_sm_cam_defining_tappets.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 如何定义开关点 ", 
"snippet" : "根据主位置使用开关点触发事件。例如，这可以是输出的设置或功能块的调用。 这些说明使用来自 如何创建凸轮 章节来演示如何定义开关点。在此示例中，挺杆启动和停止焊接过程。 打开 纵轴 cam 在编辑器中。 这 凸轮 选项卡可见。 选择 标签： 推杆. 在里面 工具箱 查看，选择 添加挺杆 工具。 当您将鼠标指针移入编辑器时，它会变成十字准线。 单击位置 600 附近的主位置下方。 将推杆插入推杆路径 1。 选择挺杆。 在“属性”视图中更改挺杆的值。 X : 600 正传 ： 打开 否定通过 ： 无动作 在 X: 1800 处将另一个挺杆插入挺杆路径 1。 X : 1800 正传 ： 关掉 否定通过...", 
"body" : "根据主位置使用开关点触发事件。例如，这可以是输出的设置或功能块的调用。 这些说明使用来自 如何创建凸轮 章节来演示如何定义开关点。在此示例中，挺杆启动和停止焊接过程。 打开 纵轴 cam 在编辑器中。 这 凸轮 选项卡可见。 选择 标签： 推杆. 在里面 工具箱 查看，选择 添加挺杆 工具。 当您将鼠标指针移入编辑器时，它会变成十字准线。 单击位置 600 附近的主位置下方。 将推杆插入推杆路径 1。 选择挺杆。 在“属性”视图中更改挺杆的值。 X : 600 正传 ： 打开 否定通过 ： 无动作 在 X: 1800 处将另一个挺杆插入挺杆路径 1。 X : 1800 正传 ： 关掉 否定通过 ： 无动作 检查结果。 您还可以更改的值 正面传球 和 负通过 通过单击相应的末端 十字准线。 请注意，您还可以在 挺杆台 标签。此编辑器为您提供相同的选项，但以表格形式。 " }, 
{ "title" : "通过编程创建凸轮 ", 
"url" : "_sm_basic_cam_programmatic_creation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 通过编程创建凸轮 ", 
"snippet" : "作为 CODESYS SoftMotion 版本 4.17.0.0， CamBuilder 功能块提供了在 IEC 应用程序中直接以编程方式创建凸轮的接口。 有关详细信息，请参阅示例： 通过编程创建凸轮...", 
"body" : "作为 CODESYS SoftMotion 版本 4.17.0.0， CamBuilder 功能块提供了在 IEC 应用程序中直接以编程方式创建凸轮的接口。 有关详细信息，请参阅示例： 通过编程创建凸轮" }, 
{ "title" : "使用 CamBuilder 功能块（自 SM 4.17.0.0 起） ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4552813176932834337885510319", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 通过编程创建凸轮 \/ 使用 CamBuilder 功能块（自 SM 4.17.0.0 起） ", 
"snippet" : "在设备树中创建凸轮对象时，默认创建以下凸轮： 凸轮由三个五次多项式组成，具有以下四个边界值： X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 要以编程方式创建此凸轮， CamBuilder 功能块首先声明： VAR camBuilder : SMCB.CamBuilder; END_VAR 在实现部分， CamBuilder 实例必须先初始化。三个类型的段 Poly5 然后可以使用 Append 方法： camBuilder.Init(); camBuilder.Append( SMCB.Poly5( SMCB.BoundImplicit...", 
"body" : "在设备树中创建凸轮对象时，默认创建以下凸轮： 凸轮由三个五次多项式组成，具有以下四个边界值： X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 要以编程方式创建此凸轮， CamBuilder 功能块首先声明： VAR\n camBuilder : SMCB.CamBuilder;\nEND_VAR 在实现部分， CamBuilder 实例必须先初始化。三个类型的段 Poly5 然后可以使用 Append 方法： camBuilder.Init();\n \ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(120, 120, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(240, 240, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(360, 360))); 多项式通过左边界条件和右边界条件定义。在本例中， BoundImplicit 函数始终用于左边界。因此，将应用前一段的右边界条件。如果 BoundImplicit 函数用作第一个段的左边界，那么它从零开始：在这个例子中，Poly5 段位于 (X, Y, V, A) = (0, 0, 0, 0)。 当 MC_CamTableSelect 和 MC_CamIn 使用功能块，凸轮定义在 CamBuilder 最后必须将功能块转换为 MC_CamRef 。有两种方法可以执行此操作，具体取决于调用 CamBuilder 的位置 在总线任务中调用 CamBuilder： 首先，声明部分必须通过相应的实例进行扩展： VAR\n    ...\n    camRef : MC_CAM_REF;\n    aCamSegments : ARRAY[1..3] OF SMC_CAM_SEGMENT;\nEND_VAR 然后是函数块实例 MC_CAM_REF 使用初始化和写入 Write 的方法 CamBuilder 功能块。 SMCB.InitCamRef(camRef, ADR(aCamSegments), XSIZEOF(aCamSegments));\ncamBuilder.Write(camRef); 在另一项任务（多任务、多核）中调用 CamBuilder： 首先，在 GVL 中创建 Cam 的多任务\/多核安全实例，总线任务和 CamBuilder 任务均可访问该实例。 VAR_GLOBAL\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR 然后，从总线任务开始在另一个任务中创建摄像头。 为了确定总线任务中何时在另一个任务中写入新摄像头，程序会记住 CamId 在 STATE_INIT_ONLINE_TABLE_MULTITASK 在创建摄像头之前。 然后，在另一个任务中开始创建摄像头 STATE_START_CREATE_ONLINE_TABLE_MULTITASK 州。 然后，将创建的摄像头读入 STATE_READ_ONLINE_TABLE_MULTITASK 州。 PROGRAM BUS_TASK\nVAR\n    state : UDINT;\n    error : SMC_ERROR;\n    camIdBeforeCreate : UDINT;\n    camSegments: ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    camRef: MC_CAM_REF;\nEND_VAR\nVAR CONSTANT\n    STATE_INIT_ONLINE_TABLE_MULTITASK : UDINT := 0;\n    STATE_START_CREATE_ONLINE_TABLE_MULTITASK : UDINT := 10;\n    STATE_READ_ONLINE_TABLE_MULTITASK : UDINT := 20;\n    STATE_ERROR : UDINT := 1000;\nEND_VAR\n\n\nCASE state OF\nSTATE_INIT_ONLINE_TABLE_MULTITASK:\n    camIdBeforeCreate := GVL.safeCam.CamId;\n\n    state := STATE_START_CREATE_ONLINE_TABLE_MULTITASK;\n\nSTATE_START_CREATE_ONLINE_TABLE_MULTITASK:\n    CamBuilderTask.BuildCam := TRUE;\n\n    state := STATE_READ_ONLINE_TABLE_MULTITASK;\n\nSTATE_READ_ONLINE_TABLE_MULTITASK:\n    IF CamBuilderTask.Error THEN\n        error := CamBuilderTask.ErrorId;\n        state := state + STATE_ERROR;\n    ELSIF GVL.safeCam.CamId <> camIdBeforeCreate THEN\n        error := GVL.safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n        IF error = SMC_NO_ERROR THEN\n            state := state + 10;\n        ELSE\n            state := state + STATE_ERROR;\n        END_IF\n    END_IF\nEND_CASE 在 CamBuilder 任务中，多任务\/多核安全摄像头是通过调用编写的 CamBuilder.WriteMulticoreSafe() : PROGRAM CamBuilderTask\nVAR_INPUT\n    BuildCam : BOOL;\nEND_VAR\nVAR_OUTPUT\n    Error : BOOL;\n    ErrorId : SMC_ERROR;\nEND_VAR\nVAR\n    camBuilder : SMCB.CamBuilder;\nEND_VAR\n\nIF BuildCam THEN\n    BuildCam := FALSE;\n\n    camBuilder.Init();\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(120, 120, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(240, 240, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(360, 360)));\n     \n Error := camBuilder.IsErrorPending(errorID=> ErrorId);\n\n    IF NOT Error THEN\n        ErrorId := camBuilder.WriteMulticoreSafe(GVL.safeCam);\n        Error := ErrorId <> SMC_NO_ERROR;\n    END_IF\nEND_IF " }, 
{ "title" : "隐式和显式边界条件 ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930557874", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 通过编程创建凸轮 \/ 使用 CamBuilder 功能块（自 SM 4.17.0.0 起） \/ 隐式和显式边界条件 ", 
"snippet" : "隐式边界条件定义为 BoundImplicit 确保与相邻段的过渡尽可能平稳。为此，需要使用 Bound 方法。因此，如果某段的左边界条件是隐式的，则前一段的右边界条件必须是显式的。相反，如果右边界条件是隐式的，则后一段的左边界条件必须是显式的。 最常见的用例大概是仅明确指定段的右边界条件，如上例所示。由于隐式左边界条件，段过渡自动尽可能平滑，并且定义区域中没有间隙。以下示例是一个简单的案例，偏离此方法是有帮助的： 从属轴应以恒定速度从位置 20 移动到 100： camBuilder.Append( SMCB.Line( SMCB.Bound(20, 20), SMCB.Bound(100,...", 
"body" : "隐式边界条件定义为 BoundImplicit 确保与相邻段的过渡尽可能平稳。为此，需要使用 Bound 方法。因此，如果某段的左边界条件是隐式的，则前一段的右边界条件必须是显式的。相反，如果右边界条件是隐式的，则后一段的左边界条件必须是显式的。 最常见的用例大概是仅明确指定段的右边界条件，如上例所示。由于隐式左边界条件，段过渡自动尽可能平滑，并且定义区域中没有间隙。以下示例是一个简单的案例，偏离此方法是有帮助的： 从属轴应以恒定速度从位置 20 移动到 100： camBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100))); 在此之前和之后， Poly5 段用于加速和减速： camBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.BoundImplicit()));\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(120, 120, 0))); 以此方式定义的凸轮在 Poly5 段中具有不必要的加速和减速阶段（速度以蓝色表示）： 为了避免这种情况，只需调整类型段中的主位置即可 Line （例如左边界从 20 到 30，右边界从 100 到 90）： ...\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(30, 20),\n SMCB.Bound(90, 100)));\n... 无需调整字型 Poly5 因为它们会根据使用定义的边界条件自动尽可能平滑地添加到线段 BoundImplicit 功能。 " }, 
{ "title" : "错误处理 ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930649954", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 通过编程创建凸轮 \/ 使用 CamBuilder 功能块（自 SM 4.17.0.0 起） \/ 错误处理 ", 
"snippet" : "这 Append 方法 CamBuilder 功能块返回 TRUE 当成功添加段时，返回 FALSE 如果发生错误。发生错误后，无法再添加任何段，并且 CamBuilder 功能块必须使用重新初始化 Init 方法。可以使用 IsErrorPending 方法： camBuilder.IsErrorPending(errorId=> errorId);...", 
"body" : "这 Append 方法 CamBuilder 功能块返回 TRUE 当成功添加段时，返回 FALSE 如果发生错误。发生错误后，无法再添加任何段，并且 CamBuilder 功能块必须使用重新初始化 Init 方法。可以使用 IsErrorPending 方法： camBuilder.IsErrorPending(errorId=> errorId); " }, 
{ "title" : "手动创建数据结构 MC_CAM_REF（SM 4.17.0.0 之前） ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4565212026644834337937734299", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 通过编程创建凸轮 \/ 手动创建数据结构 MC_CAM_REF（SM 4.17.0.0 之前） ", 
"snippet" : "建议使用 SM3_CamBuilder 图书馆 CODESYS SoftMotion 4.17.0.0。...", 
"body" : "建议使用 SM3_CamBuilder 图书馆 CODESYS SoftMotion 4.17.0.0。 " }, 
{ "title" : "凸轮的数据结构 ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793858538", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 通过编程创建凸轮 \/ 手动创建数据结构 MC_CAM_REF（SM 4.17.0.0 之前） \/ 凸轮的数据结构 ", 
"snippet" : "在项目编译时，创建的凸轮数据将在内部转换为全局变量列表。通过单击 显示生成的代码 在凸轮编辑器中，您可以显示自动创建的全局变量。 每个凸轮由数据结构表示 MC_CAM_REF 。您可以通过 IEC 程序或预处理函数和功能块访问此数据结构。它可通过 SM3_Basic 图书馆。 描述凸轮的功能块也可由 IEC 程序在运行时生成或填充。 例子 数据结构定义： TYPE mySMC_CAMTable_LREAL_10000_2 : STRUCT Table: ARRAY[0..9999] OF ARRAY[0..1] OF LREAL; (* set all scaling definitions ...", 
"body" : "在项目编译时，创建的凸轮数据将在内部转换为全局变量列表。通过单击 显示生成的代码 在凸轮编辑器中，您可以显示自动创建的全局变量。 每个凸轮由数据结构表示 MC_CAM_REF 。您可以通过 IEC 程序或预处理函数和功能块访问此数据结构。它可通过 SM3_Basic 图书馆。 描述凸轮的功能块也可由 IEC 程序在运行时生成或填充。 例子 数据结构定义： TYPE mySMC_CAMTable_LREAL_10000_2 :\nSTRUCT\n Table: ARRAY[0..9999] OF ARRAY[0..1] OF LREAL;\n (* set all scaling definitions to 0 and 1\n result: all values of the table are not scaled *)\n fEditorMasterMin: REAL := 0;\n fEditorMasterMax: REAL := 1;\n fEditorSlaveMin: REAL := 0;\n fEditorSlaveMax: REAL := 1;\n fTableMasterMin: REAL := 0;\n fTableMasterMax: REAL := 1;\n fTableSlaveMin: REAL := 0;\n fTableSlaveMax: REAL := 1;\nEND_STRUCT\nEND_TYPE 实例化数据结构： Cam: MC_CAM_REF;\nCam_PointArray : mySMC_CAMTable_LREAL_10000_2; 计算凸轮： Cam.byType:=2;\nCam.byVarType:=6;\nCam.nTappets:=0;\nCam.strCAMName:='myCAM';\nCam.pce:= ADR(CAM_PointArray);\nFOR i:=0 TO 9999 DO\n (* example cam: master 0..360, slave 0..100,\n constant velocity *)\n Cam_PointArray.Table[i][0]:=UDINT_TO_LREAL(I)\/10000 * 360; (* X *)\n Cam_PointArray.Table[i][1]:=UDINT_TO_LREAL(I)\/10000 * 100; (* Y *)\nEND_FOR\nCam.nElements:=10000\nCam.xStart:=0.0;\nCam.xEnd:=360.0; " }, 
{ "title" : "手动生成的凸轮 ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793936406", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 通过编程创建凸轮 \/ 手动创建数据结构 MC_CAM_REF（SM 4.17.0.0 之前） \/ 手动生成的凸轮 ", 
"snippet" : "无需使用凸轮编辑器即可在 IEC 程序中创建凸轮。 例子 宣言： VAR i: INT; CAM: MC_CAM_REF := ( byType:=2, (* non-equidistant *) byVarType:=2, (* UINT *) nElements:=128, xStart:=0, xEnd:=360); Table: SMC_CAMTable_UINT_128_2 := ( fEditorMasterMin := 0, fEditorMasterMax := 360, fTableMasterMin := 0, fTableMasterMax := 6000, fEdito...", 
"body" : "无需使用凸轮编辑器即可在 IEC 程序中创建凸轮。 例子 宣言： VAR\ni: INT;\nCAM: MC_CAM_REF := (\n byType:=2, (* non-equidistant *)\n byVarType:=2, (* UINT *)\n nElements:=128,\n xStart:=0,\n xEnd:=360);\nTable: SMC_CAMTable_UINT_128_2 := (\n fEditorMasterMin := 0, fEditorMasterMax := 360,\n fTableMasterMin := 0, fTableMasterMax := 6000,\n fEditorSlaveMin := 0, fEditorSlaveMax := 360,\n fTableSlaveMin := 0, fTableSlaveMax := 6000);\nEND_VAR 执行： (* Create cam disk (example straight line); unambiguous *)\nFOR i:=0 TO 127 DO\n Table.Table[i][0] := Table.Table[i][1] := REAL_TO_UINT(i \/ 127.0 * 6000);\nEND_FOR\n(* Link pointer; must be done in every cycle! *)\nCAM.pce := ADR(Table); 生成的凸轮可以在 MC_CamTableSelect 功能块及其输出再次用于 MC_CamIn 。 " }, 
{ "title" : "编译凸轮定义 ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793975398", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 通过编程创建凸轮 \/ 手动创建数据结构 MC_CAM_REF（SM 4.17.0.0 之前） \/ 编译凸轮定义 ", 
"snippet" : "在编译时，类型变量 MC_CAM_REF 为凸轮创建。它们包括凸轮每个部分的描述。这种数据结构被传递给 MC_凸轮表选择 功能块。结构是 SM3_Basic 图书馆。...", 
"body" : "在编译时，类型变量 MC_CAM_REF 为凸轮创建。它们包括凸轮每个部分的描述。这种数据结构被传递给 MC_凸轮表选择 功能块。结构是 SM3_Basic 图书馆。 " }, 
{ "title" : "在凸轮之间切换 ", 
"url" : "_sm_cam_switch_between_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 在凸轮之间切换 ", 
"snippet" : "基本上，您可以随时在不同的凸轮之间切换。但是，您应该考虑以下几点： 在凸轮编辑器中，从站的位置被唯一地定义为凸轮函数的函数值。该函数定义在主值范围内，可表示如下： SlavePosition = CAM( MasterPosition ) 由于主驱动器的当前位置通常偏离主值范围，因此您必须在凸轮函数的定义范围内缩放主位置以表示有效参数： SlavePosition = CAM( MasterScale*MasterPosition + MasterOffset ) 以类似的方式，如果凸轮在模式下开始，则必须缩放功能值（从位置） Absolute 会导致跳跃： SlavePosition = S...", 
"body" : "基本上，您可以随时在不同的凸轮之间切换。但是，您应该考虑以下几点： 在凸轮编辑器中，从站的位置被唯一地定义为凸轮函数的函数值。该函数定义在主值范围内，可表示如下： SlavePosition = CAM( MasterPosition ) 由于主驱动器的当前位置通常偏离主值范围，因此您必须在凸轮函数的定义范围内缩放主位置以表示有效参数： SlavePosition = CAM( MasterScale*MasterPosition + MasterOffset ) 以类似的方式，如果凸轮在模式下开始，则必须缩放功能值（从位置） Absolute 会导致跳跃： SlavePosition = SlaveScale*CAM( MasterPosition ) + SlaveOffset 您可能必须同时应用这两个缩放值，这会导致以下结果： Slaveposition = SlaveScale*CAM( MasterScale*Masterposition + MasterOffset ) + SlaveOffset 缩放和偏移参数的适当值可能因周期而异。 凸轮之间的切换可以通过三种方式完成： 通过第二个实例启动第二个凸轮 MC_CamIn 和 BufferMode = MC_BUFFER_MODE.Buffered ， StartMode = relative ， MasterAbsolute = FALSE ， 和 SlaveAbsolute = FALSE 。 作为 CODESYS SoftMotion 版本 4.17.0.0 通过分配启动新凸轮 MC_CamIn.CamTableID 到新凸轮（不重新启动 MC_CamIn 需要功能块）。 如果以下几点适用于您的用例，则建议使用此变体： 以下所有凸轮都应相对执行 MasterAbsolute = FALSE 或者 SlaveAbsolute = FALSE . 新凸轮应该正好在前一个凸轮的末尾开始。 没有更改其他参数（例如： SlaveOffset ）。 跳转，在以下示例中对周期性凸轮和 SlaveAbsolute = FALSE ， 做 不是 应用于此变体，因为下一个凸轮正好放置在前一个凸轮的末端位置。 仅当在前一个凸轮报告时在同一循环中完成到新凸轮的切换时，新凸轮才会准确放置在前一个凸轮的末尾 EndOfProfile = TRUE . 通过重新启动新凸轮来启动 MC_CamIn 功能块。 如果必须为新凸轮的正确功能更改参数（例如， SlaveOffset 从下面的例子）。以下示例的限制适用。 例子 在以下示例中，它从 CAM1 到 CAM2 ： CAM1 由一个 5 阶多项式和两个线段组成。 CAM2 由两条线段和一个 5 阶多项式组成。 在两个凸轮之间切换时，应考虑以下事项： 为防止跳跃，第一个凸轮终点处的速度和加速度值应与第二个凸轮起点处的值一致。在这个例子中，这个条件是满足的，因为相同的速度（=1）和加速度（=0）被分配到终点 CAM1 和起点 CAM2 . 您可以启动第二个凸轮 Relative 当您将从站的起始位置定义为 0 时的模式。但是，第一个凸轮必须在 non-periodic 模式。否则，如果 CAM1 是周期性的，那么 Relative 设置会导致跳转。 放大率显示从 CAM1 到 CAM2 .蓝线标记在主位置对凸轮功能的评估 x1 和 x2 . 现在，我们来看看不利的情况 periodic ： MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=TRUE); 该调用在主位置开始评估凸轮 x1 , 小于 master 的结束位置 CAM1 .然后 CAM1 默认情况下进行评估并产生点 1 作为奴隶的位置。 CAM(x2, CAM1, PERIODIC:=TRUE); 为了模块的后续调用，主位置 x2 超出主值范围 CAM1 ，其界限用绿色虚线标记，与点的横轴一致 3p 。因此， EndOfProfile 已设置。因为 CAM1 开始于 periodic 模式，其重新启动发生在值范围的末尾，最终产生点 2p 作为模块调用的结果。 CAM(EXECUTE:=FALSE); 切换到新凸轮 CAM(x2, CAM2, PERIODIC:=TRUE); 主位的二次评价 x2 .这一次，新 CAM2 被评估。后 CAM2 开始于 Relative 模式，当前从站位置（ 2p ) 作为偏移量添加到 cam 函数的图像中 CAM2 .这会将其图形的起点移动到该点 3p 及其在主位置的评估 x2 产生点 4p ，因此是不利的跳跃。 选择 non-periodic 模式以防止跳跃： MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=FALSE); 该调用在主位置开始评估凸轮 x1 , 小于 master 的结束位置 CAM1 .然后 CAM1 默认情况下进行评估，并将点 1 作为从站的位置。 CAM(x2, CAM1, PERIODIC:=FALSE); 为了模块的后续调用，主位置 x2 超出主值范围 CAM1 ，其界限用绿色虚线标记，与点的水平轴一致 3n 。因此， EndOfProfile 已设置。因为 CAM1 开始于 non-periodic 模式，从属位置（ 2n ）分配给主位置 x2 与到达值范围末尾时从站的位置相同 CAM1 （ 3n ）。 CAM(EXECUTE:=FALSE); 切换到新凸轮。 CAM(x2, CAM2, PERIODIC:=FALSE); 主位的二次评价 x2 .这一次，新 CAM2 被评估。后 CAM2 开始于 Relative 模式，当前从站位置（ 2n ) 作为偏移量添加到 cam 函数的图像中 CAM2 .这会将其图形的起点移动到该点 3n 及其在主位置的评估 x2 产生点 4n ，它在通过点的特定线上 1 和 3n . 启动凸轮 Absolute 模式下，您必须确保从站处于适当的起始位置。如果主站的取值范围与从站的周期一致，那么无论凸轮是否周期性，凸轮之间的切换都没有任何复杂性。 在上面的例子中，你可以开始 CAM2 在 Absolute 主从周期与主控值范围一致时的模式 CAM2 （每个都是 360°）。 如果不是，例如从机的周期是 270° （由浅蓝色线表示），然后 Absolute 如果不采取其他措施，则不允许使用该选项。 在这种情况下，从站切换时从站处于 90° CAM1 到 CAM2 .开始 CAM2 在 Absolute 模式会导致跳转到 0°（由灰线表示）。 但是，可以通过将从属偏移设置为 90° 的适当值来防止跳跃。 " }, 
{ "title" : "周期凸轮 ", 
"url" : "_sm_basic_periodic_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ 周期凸轮 ", 
"snippet" : "凸轮可以重复运行，当 Periodic 输入 MC_CamTableSelect 功能块设置为 TRUE 。然后凸轮在到达终点位置后自动重新启动。如果此输入 FALSE ，然后 EndOfProfile 输出变量 MC_CamIn 功能块设置为 TRUE 当主机到达终点位置时，从机暂停在当前位置。 注意，离开主值范围后凸轮活动不会停止。当主驱动器重新进入主值范围时，从驱动器将再次跟随凸轮板。 行为的情况下 Slave.EndPosition <> Slave.StartPosition ：功能块 MC_CamIn 在一个周期结束时计算内部偏移。在后续周期中，凸轮将根据此偏移进行移动，以便其继续...", 
"body" : "凸轮可以重复运行，当 Periodic 输入 MC_CamTableSelect 功能块设置为 TRUE 。然后凸轮在到达终点位置后自动重新启动。如果此输入 FALSE ，然后 EndOfProfile 输出变量 MC_CamIn 功能块设置为 TRUE 当主机到达终点位置时，从机暂停在当前位置。 注意，离开主值范围后凸轮活动不会停止。当主驱动器重新进入主值范围时，从驱动器将再次跟随凸轮板。 行为的情况下 Slave.EndPosition <> Slave.StartPosition ：功能块 MC_CamIn 在一个周期结束时计算内部偏移。在后续周期中，凸轮将根据此偏移进行移动，以便其继续停留在从动装置的当前位置，从而防止发生跳跃。 对于周期性凸轮，您可以激活 平稳过渡 选项。这用于防止从一个周期过渡到另一个周期时发生跳跃。然后从动装置在结束位置的速度和加速度与在起始位置的速度和加速度相同。周期和进给以从动装置缩放的单位来测量。即使您没有选择 平稳过渡 选项，凸轮可以连续运行。在这种情况下，您的任务是确保过渡的一致性得到充分满足。 " }, 
{ "title" : "“在线凸轮编辑器”可视化元素 ", 
"url" : "_sm_cam_visu_elem_online_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ “在线凸轮编辑器”可视化元素 ", 
"snippet" : "在线摄像头编辑器是一个可视化模板，用于在可视化中显示摄像头。使用此元素，你可以在在线模式下修改摄像头。 可视化元素在可视化模板中可用 ( smc_visu_camEditor ) 的 SM3_Basic_Visu 图书馆。你可以在可视化编辑器中找到它 工具箱 在 sm3_Basic_Visu 标签。 这个 SMC_Visu_CamEditor 通过框架插入到可视化中。 有关此可视化元素的更多信息，请参阅： 可视化元素：框架 。 除了框架元素的属性外，此模板还包含以下属性： 财产 描述 SafeCam 对待编辑摄像头的引用 显示位置 用于打开和关闭位置曲线显示的布尔变量 显示速度 用于打开和关闭...", 
"body" : "在线摄像头编辑器是一个可视化模板，用于在可视化中显示摄像头。使用此元素，你可以在在线模式下修改摄像头。 可视化元素在可视化模板中可用 ( smc_visu_camEditor ) 的 SM3_Basic_Visu 图书馆。你可以在可视化编辑器中找到它 工具箱 在 sm3_Basic_Visu 标签。 这个 SMC_Visu_CamEditor 通过框架插入到可视化中。 有关此可视化元素的更多信息，请参阅： 可视化元素：框架 。 除了框架元素的属性外，此模板还包含以下属性： 财产 描述 SafeCam 对待编辑摄像头的引用 显示位置 用于打开和关闭位置曲线显示的布尔变量 显示速度 用于打开和关闭速度曲线显示的布尔变量 显示加速 用于打开和关闭加速度曲线显示的布尔变量 ShowJerk 用于打开和关闭加速度曲线显示的布尔变量 显示所选区段 布尔变量，用于打开和关闭选定片段的突出显示 要编辑的摄像头通过以下实例传输 SMCB.CAM_REF_MULTICORE_SAFE 功能块。 PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR " }, 
{ "title" : "在线模式下的凸轮编辑器 ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_id_ba4cc02c6ccda90bc0a864637badf4e0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ “在线凸轮编辑器”可视化元素 \/ 在线模式下的凸轮编辑器 ", 
"snippet" : "在在线模式下，可以在图表中选择凸轮的各个分段。右侧的区段编辑器可用于添加和删除分段，以及调整所选分段的边界条件 (1) 负载摄像头 将配置的摄像头加载到编辑器中 (2) 保存摄像头 保存编辑后的摄像头 (3) 状态栏 显示状态消息 (4) 区段选择 可以使用箭头选择线段。可以通过列表框更改区段类型。 (5) 主职位 分段左右边缘的主位置 (6) 从属位置 分段左右边缘的从属位置。 (7) 从机速度 分段左右边缘的从属速度。所有区段类型均不可编辑。 (8) 从机加速 分段左右边缘的从属加速度。所有区段类型均不可编辑。 (9) 奴隶混蛋 那个奴隶在片段的左右边缘混蛋。所有区段类型均不可编辑。 (1...", 
"body" : "在在线模式下，可以在图表中选择凸轮的各个分段。右侧的区段编辑器可用于添加和删除分段，以及调整所选分段的边界条件 (1) 负载摄像头 将配置的摄像头加载到编辑器中 (2) 保存摄像头 保存编辑后的摄像头 (3) 状态栏 显示状态消息 (4) 区段选择 可以使用箭头选择线段。可以通过列表框更改区段类型。 (5) 主职位 分段左右边缘的主位置 (6) 从属位置 分段左右边缘的从属位置。 (7) 从机速度 分段左右边缘的从属速度。所有区段类型均不可编辑。 (8) 从机加速 分段左右边缘的从属加速度。所有区段类型均不可编辑。 (9) 奴隶混蛋 那个奴隶在片段的左右边缘混蛋。所有区段类型均不可编辑。 (10) Lambda 参数 修改后的正弦线的 Lambda 参数。 (11) 分裂 将选定区段分成两个分段。 (12) 删除 删除所选分段。 " }, 
{ "title" : "在应用程序中使用创建的摄像头 ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_section-idm234870310600632", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 双轴同步运动 \/ 凸轮 \/ “在线凸轮编辑器”可视化元素 \/ 在应用程序中使用创建的摄像头 ", 
"snippet" : "您可以使用使用创建的摄像头 SMC_Visu_CamEditor 通过调用应用程序中的可视化元素 GetCopy 的方法 CAM_REF_MULTICORE_SAFE 实例。 PROGRAM PLC_PRG VAR     safeCam : SMCB.CAM_REF_MULTICORE_SAFE;     camRef : MC_CAM_REF;     camSegments : ARRAY[0..99] OF SMC_CAM_SEGMENT;     error : SMC_ERROR; END_VAR IF safeCam.CamId <> oldCamId THEN     erro...", 
"body" : "您可以使用使用创建的摄像头 SMC_Visu_CamEditor 通过调用应用程序中的可视化元素 GetCopy 的方法 CAM_REF_MULTICORE_SAFE 实例。 PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\n    camRef : MC_CAM_REF;\n    camSegments : ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    error : SMC_ERROR;\nEND_VAR\n\nIF safeCam.CamId <> oldCamId THEN\n     error :=\n         safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n oldCamId := safeCam.CamId;\nEND_IF 该程序首先检查是否已创建新摄像头（ CamId <> oldCamID ）。如果是，则使用创建此摄像头的副本 GetCopy 方法。如果电话返回 SMC_NO_ERROR ，然后 camRef 的实例 MC_CAM_REF 功能块可以与 SoftMotion 凸轮功能块一起使用 MC_CamTableSelect 和 MC_CamIn 。这个 GetCopy 呼叫是任务安全的，因此不必从 Visu 任务中拨出。 " }, 
{ "title" : "指挥多个动作 ", 
"url" : "_sm_basic_mulitple_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_sm_overview_mulitple_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 \/ 概述 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "缓冲模式 ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844820766", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 \/ 概述 \/ 缓冲模式 ", 
"snippet" : "有些功能块有一个 BufferMode 输入用于控制运动的时间顺序。缓冲模式定义功能块是在非缓冲模式（“中止”，标准行为）下工作，还是在缓冲模式（“缓冲”）下工作。这两种模式之间的区别在于它们开始操作的时间： “非缓冲模式”：即使中断了另一个运动，运动命令也会立即生效。命令运动的缓冲区将被删除。 “缓冲模式”：移动命令等待，直到当前功能块设置其输出 Done （或者 InPosition ， 或者 InVelocity 等）。缓冲模式还用于定义速度曲线在动作过渡时应如何表现。 BufferMode 输入是 MC_BUFFER_MODE 类型的 ENUM。 Aborting 无缓冲的默认模式。功...", 
"body" : "有些功能块有一个 BufferMode 输入用于控制运动的时间顺序。缓冲模式定义功能块是在非缓冲模式（“中止”，标准行为）下工作，还是在缓冲模式（“缓冲”）下工作。这两种模式之间的区别在于它们开始操作的时间： “非缓冲模式”：即使中断了另一个运动，运动命令也会立即生效。命令运动的缓冲区将被删除。 “缓冲模式”：移动命令等待，直到当前功能块设置其输出 Done （或者 InPosition ， 或者 InVelocity 等）。缓冲模式还用于定义速度曲线在动作过渡时应如何表现。 BufferMode 输入是 MC_BUFFER_MODE 类型的 ENUM。 Aborting 无缓冲的默认模式。功能块立即启动并中止活动运动。命令在轴上立即生效。 Buffered 最后一个命令的运动完成后，功能块立即启动。这里不进行混合。新的运动以达到结束条件时前一个运动的速度开始（ Done ， InVelocity ， InEndVelocity ， InGear ， InSync ， EndOfProfile 等）。如果前一个动作是 MC_MoveAbsolute 或者 MC_MoveRelative ，则新的运动从静止状态开始。 BlendingLow 最后一个命令的运动完成后，该功能块立即启动。轴在运动之间不会停止，而是以两个运动命令中较低的速度通过第一个运动的终点位置。 BlendingPrevious 最后一个命令运动完成后，该功能块立即启动。轴在运动之间不会停止，而是以第一个运动命令的速度通过第一个运动的终点位置。 BlendingNext 最后一个命令运动完成后，该功能块立即启动。轴在运动之间不会停止，而是以第二个运动命令的速度通过第一个运动的终点位置。 BlendingHigh 最后一个命令运动完成后，该功能块立即启动。轴在运动之间不会停止，而是以两个运动命令中较高的速度通过第一个运动的终点位置。 " }, 
{ "title" : "支持的功能块 ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844838676", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 \/ 概述 \/ 缓冲模式 \/ 支持的功能块 ", 
"snippet" : "所有可以指定为缓冲\/混合命令的功能块都有以下输入和输出： BufferMode 输入 （ MC_BUFFER_MODE 类型） Active 输出： （ BOOL 类型） 当功能块切换到状态时，命令被接受 Busy 在发出新的动作指令之后。 功能块 可以定义为缓冲\/混合命令 可以跟随缓冲\/混合命令 激活下一个缓冲\/混合 FB 的相关信号 MC_Power 不 不 MC_Home 不 不 MC_Stop 不 不 MC_Halt 不 不 MC_MoveAbsolute MC_MoveRelative 是的 是的 Done MC_MoveAdditive 不 是的 （ Buffered 仅有的） D...", 
"body" : "所有可以指定为缓冲\/混合命令的功能块都有以下输入和输出： BufferMode 输入 （ MC_BUFFER_MODE 类型） Active 输出： （ BOOL 类型） 当功能块切换到状态时，命令被接受 Busy 在发出新的动作指令之后。 功能块 可以定义为缓冲\/混合命令 可以跟随缓冲\/混合命令 激活下一个缓冲\/混合 FB 的相关信号 MC_Power 不 不 MC_Home 不 不 MC_Stop 不 不 MC_Halt 不 不 MC_MoveAbsolute MC_MoveRelative 是的 是的 Done MC_MoveAdditive 不 是的 （ Buffered 仅有的） Done MC_MoveSuperImposed MC_HaltSuperImposed 不 不 有关详细信息，请参阅：For more information, see: MC_MoveSuperImposed 和 MC_HaltSuperImposed 的行为MC_MoveVelocity 是的 是的 （ Buffered 仅有的） InVelocity SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative 不 是的 （ Buffered 仅有的） InEndVelocity MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile 不 是的 （ Buffered 仅有的） Done MC_CamIn 是（只有 Buffered 和 BlendingPrevious ) 是的，如果是定期的（仅 Buffered ） EndOfProfile MC_CamOut 不 是的 （ Buffered 仅有的） Done MC_GearIn 是的 （ BlendingPrevious 仅有的） 是的 （ Buffered 仅有的） InGear MC_GearOut 不 是的 （ Buffered 仅有的） Done MC_GearInPos 是的 （ BlendingPrevious 仅有的） 是的 （ Buffered 仅有的） InSync SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues 不 不 SMC_SetTorque 不 不 MC_Phasing 不 不 MC_Jog SMC_Inch 不 不 当使用缓冲模式命令移动时，不应使用这些功能块 Buffered 或者 Blending* . 慢跑和指令动作可能会互相干扰。 SMC_BacklashCompensation 不 不 SMC_TrackAxis 不 不 SMC_TrackSetValues 不 不 注意 MC_GearInPos 和 MC_GearIn ：其他缓冲模式的行为如下 BlendingPrevious 很难建立。主要问题是这些功能块的速度可能随时根据主轴而变化。因为混合效果最好，因为混合速度越早越好，所以只有 BlendingPrevious 受支持。 如果是 BlendingPrevious 主轴的方向也可以随时改变。这意味着，只有在混合完成时，从轴对于 MC_GearInPos 应具有的方向才为人所知。但是，我们需要在混合开始时就确定混合运动的方向。这就是为什么第一个运动既定义了混合速度，又定义了方向，而不管后续运动定义的方向如何 MC_GearIn(Pos) 。 " }, 
{ "title" : "缓冲运动情况下的行为 ", 
"url" : "_sm_buffermode_buffered_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 \/ 缓冲运动情况下的行为 ", 
"snippet" : "当一个缓冲运动被命令后 MC_MoveAbsolute 或者 MC_MoveRelative ，缓冲的运动在前一个运动报告的同一周期中处于活动状态 Done 并达到速度 0。但是，缓冲运动的插补直到下一个循环才开始，因此循环结束时轴的速度等于 0。 当命令缓冲移动后 MC_CamIn ，缓冲运动在前一个运动报告的同一周期内处于活动状态 EndOfProfile . 缓冲运动的插补在此循环中立即开始。...", 
"body" : "当一个缓冲运动被命令后 MC_MoveAbsolute 或者 MC_MoveRelative ，缓冲的运动在前一个运动报告的同一周期中处于活动状态 Done 并达到速度 0。但是，缓冲运动的插补直到下一个循环才开始，因此循环结束时轴的速度等于 0。 当命令缓冲移动后 MC_CamIn ，缓冲运动在前一个运动报告的同一周期内处于活动状态 EndOfProfile . 缓冲运动的插补在此循环中立即开始。 " }, 
{ "title" : "混合情况下的行为 ", 
"url" : "_sm_buffermode_blending.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 \/ 混合情况下的行为 ", 
"snippet" : "混合行为的基本性质 CODESYS SoftMotion 是在混合期间轴沿与缓冲运动期间相同的位置移动。唯一的区别是沿这些位置的速度。 这对于简单的情况是显而易见的。请参阅以下示例： 在某些情况下，轴独立于缓冲模式移动相同位置的特性会影响两个运动之间的有效混合速度。例如，如果修改上述示例，使第二个运动的最大速度过高，以至于无法在混合位置达到，就会出现这种情况。根据 PLCopen 中描述的规则，混合速度应为 500 u\/s。但是，为了在位置 100 u 处达到此速度，轴必须反转，沿负方向移动到小于 0 u 的位置，然后加速到 500 u\/s。相反，在这种情况下，有效混合速度限制为在没有反转和位...", 
"body" : "混合行为的基本性质 CODESYS SoftMotion 是在混合期间轴沿与缓冲运动期间相同的位置移动。唯一的区别是沿这些位置的速度。 这对于简单的情况是显而易见的。请参阅以下示例： 在某些情况下，轴独立于缓冲模式移动相同位置的特性会影响两个运动之间的有效混合速度。例如，如果修改上述示例，使第二个运动的最大速度过高，以至于无法在混合位置达到，就会出现这种情况。根据 PLCopen 中描述的规则，混合速度应为 500 u\/s。但是，为了在位置 100 u 处达到此速度，轴必须反转，沿负方向移动到小于 0 u 的位置，然后加速到 500 u\/s。相反，在这种情况下，有效混合速度限制为在没有反转和位置超调的情况下可以达到的最大速度。在此示例中，最大速度为 447 u\/s。 有效混合速度的以下规则源于缓冲模式不会改变驱动位置的属性： 如果在没有位置超调的情况下无法达到混合速度，则有效混合速度是下一个可以在没有超调的情况下达到的速度（参见上面的示例）。 注意：有效混合速度可以高于或低于混合速度。 如果第二次运动开始时的方向与第一次运动的方向相反，则有效混合速度设置为 0。这可以防止位置在第一次运动的方向上超出其目标位置。 如果第二次运动的路径太短，无法从搅拌速度减速到静止，则调整有效搅拌速度。它设置为允许在第二次运动路径上安全制动到静止的最大速度。 在模轴的情况下，输入的影响 Direction 的 MC_MoveAbsolute 不受混合到第二乐章的影响。这意味着第一个运动的目标位置始终处于相同的模周期内，无论是否跟随混合运动。 在模数轴和类型的第二运动的情况下 MC_MoveAbsolute ，混合速度不影响第二次运动目标位置的模周期，当 Direction = fastest 用来。这意味着无论是否用 Buffered 或者 Blending . " }, 
{ "title" : "混合过程中的加速、减速和抖动 ", 
"url" : "_sm_buffermode_blending.html#UUID-60273b62-3ad5-7014-3fa9-e2fa61f7a008_section-idm235068399508112", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 \/ 混合情况下的行为 \/ 混合过程中的加速、减速和抖动 ", 
"snippet" : "缓冲模式 ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext ）的第二个动作决定了达到运动起始位置的速度。 相比之下，混合期间的最大加速度、减速和最大加速度始终是第一个动作的值。其原因是，例如，如果第二个动作的最大延迟小于第一个动作的最大延迟并且使用较小的延迟，则可能会超过第一个动作的目标位置。...", 
"body" : "缓冲模式 ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext ）的第二个动作决定了达到运动起始位置的速度。 相比之下，混合期间的最大加速度、减速和最大加速度始终是第一个动作的值。其原因是，例如，如果第二个动作的最大延迟小于第一个动作的最大延迟并且使用较小的延迟，则可能会超过第一个动作的目标位置。 " }, 
{ "title" : "从连续或同步运动中缓冲\/混合 ", 
"url" : "_sm_buffermode_continuous_motion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 \/ 从连续或同步运动中缓冲\/混合 ", 
"snippet" : "根据 PLCopen，混合缓冲模式决定了第一次运动结束时的速度。 在某些情况下，速度已经完全由第一个动作决定。当第一个运动是以下类型之一时，就是这种情况： 连续移动（ MC_MoveVelocity , SMC_MoveContinuousRelative ， 或者 SMC_MoveContinuousAbsolute ) 同步运动（ MC_CamIn , MC_GearIn ， 或者 MC_GearInPos ) 在这些情况下， CODESYS SoftMotion 仅支持 Buffered 和 Aborting 缓冲模式。使用其中一种混合缓冲区模式会导致 FB 错误（ SMC_BLENDI...", 
"body" : "根据 PLCopen，混合缓冲模式决定了第一次运动结束时的速度。 在某些情况下，速度已经完全由第一个动作决定。当第一个运动是以下类型之一时，就是这种情况： 连续移动（ MC_MoveVelocity , SMC_MoveContinuousRelative ， 或者 SMC_MoveContinuousAbsolute ) 同步运动（ MC_CamIn , MC_GearIn ， 或者 MC_GearInPos ) 在这些情况下， CODESYS SoftMotion 仅支持 Buffered 和 Aborting 缓冲模式。使用其中一种混合缓冲区模式会导致 FB 错误（ SMC_BLENDING_NOT_SUPPORTED_BY_PREVIOUS_MOVEMENT) . 当后续缓冲命令变为有效时，输出 CommandAborted 被设定为 TRUE 上一个运动命令。此外，“Inxxx”输出（例如， InVelocity 为了 MC_MoveVelocity 或者 InGear 为了 MC_GearIn ）和输出 Busy 设置为一个周期。这与 PLCopen 第 2.4.1 节不同，其中 CommandAborted 和“Inxxx”以及 Busy 是互相排斥的。 " }, 
{ "title" : "运动功能块的执行顺序 ", 
"url" : "_sm_buffermode_execution_order.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 \/ 运动功能块的执行顺序 ", 
"snippet" : "当命令缓冲运动或混合运动时，命令后续运动的功能块实例不能早于命令前一个运动的功能块实例执行。 如果违反此订单，则出现新的错误 SMC_FB_WASNT_CALLED_DURING_MOTION 被报告并且轴切换到状态 Errorstop 。 例子 movement1(); movement2(); 正确的执行顺序 执行 movement1() 执行 movement2() 立刻 movement1() 活跃 无效的执行顺序 执行 movement2() 执行 movement1() 立刻 movement2() 活跃 这导致 SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT...", 
"body" : "当命令缓冲运动或混合运动时，命令后续运动的功能块实例不能早于命令前一个运动的功能块实例执行。 如果违反此订单，则出现新的错误 SMC_FB_WASNT_CALLED_DURING_MOTION 被报告并且轴切换到状态 Errorstop 。 例子 movement1();\nmovement2(); 正确的执行顺序 执行 movement1() 执行 movement2() 立刻 movement1() 活跃 无效的执行顺序 执行 movement2() 执行 movement1() 立刻 movement2() 活跃 这导致 SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT 错误。 " }, 
{ "title" : "使用一个功能块实例控制多个运动 ", 
"url" : "_sm_buffermode_one_fb.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 \/ 使用一个功能块实例控制多个运动 ", 
"snippet" : "单个功能块实例（例如，来自 MC_MoveAbsolute ）不能用于控制多个缓冲\/混合运动，只要它是 Busy 。 当功能块实例 Busy ，此实例的新缓冲或混合移动命令会导致错误 SMC_MORE_THAN_ONE_MOVEMENT_PER_INSTANCE 。 为了在短时间内指挥同一类型的多个缓冲或混合运动，需要多个功能模块实例。...", 
"body" : "单个功能块实例（例如，来自 MC_MoveAbsolute ）不能用于控制多个缓冲\/混合运动，只要它是 Busy 。 当功能块实例 Busy ，此实例的新缓冲或混合移动命令会导致错误 SMC_MORE_THAN_ONE_MOVEMENT_PER_INSTANCE 。 为了在短时间内指挥同一类型的多个缓冲或混合运动，需要多个功能模块实例。 " }, 
{ "title" : "发生错误时的行为 ", 
"url" : "_sm_basic_behavior_error.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 \/ 发生错误时的行为 ", 
"snippet" : "如果发生轴错误（例如，轴切换到状态 Errorstop )，活动的运动将与所有其他接受的运动一起报告错误。 如果在活动运动的功能块中出现 FB 错误，则以后接受的所有运动也会报告错误。这与第 2.2.2 节的 PLCopen 形成对比，后者在 FB 错误后将继续执行后续命令。...", 
"body" : "如果发生轴错误（例如，轴切换到状态 Errorstop )，活动的运动将与所有其他接受的运动一起报告错误。 如果在活动运动的功能块中出现 FB 错误，则以后接受的所有运动也会报告错误。这与第 2.2.2 节的 PLCopen 形成对比，后者在 FB 错误后将继续执行后续命令。 " }, 
{ "title" : "MC_MoveSuperImposed 和 MC_HaltSuperImposed 的行为 ", 
"url" : "_sm_buffermode_movesuperimposed.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 \/ MC_MoveSuperImposed 和 MC_HaltSuperImposed 的行为 ", 
"snippet" : "如果 MC_MoveSuperImposed 或者 MC_HaltSuperImposed 处于活动状态，并且底层移动被中止，那么 MC_MoveSuperImposed \/ MC_HaltSuperImposed 也被中止。 如果底层移动没有被取消，但另一个移动与模式 Buffered 或者命令其中一种 Blending-BufferMode，其行为如下： MC_MoveSuperImposed \/ MC_HaltSuperImposed 混合开始或新移动生效时不会被取消。相反， MC_MoveSuperImposed \/ MC_HaltSuperImposed 继续在后台运行直至完成。...", 
"body" : "如果 MC_MoveSuperImposed 或者 MC_HaltSuperImposed 处于活动状态，并且底层移动被中止，那么 MC_MoveSuperImposed \/ MC_HaltSuperImposed 也被中止。 如果底层移动没有被取消，但另一个移动与模式 Buffered 或者命令其中一种 Blending-BufferMode，其行为如下： MC_MoveSuperImposed \/ MC_HaltSuperImposed 混合开始或新移动生效时不会被取消。相反， MC_MoveSuperImposed \/ MC_HaltSuperImposed 继续在后台运行直至完成。 " }, 
{ "title" : "作为 CODESYS SoftMotion 版本 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439539337338", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 \/ MC_MoveSuperImposed 和 MC_HaltSuperImposed 的行为 \/ 作为 CODESYS SoftMotion 版本 4.17.0.0 ", 
"snippet" : "当 MC_MoveAbsolute 配置了缓冲模式或命令了混合模式，则最终位置是配置的位置之和 MC_MoveAbsolute 并且距离配置为 MC_MoveSuperImposed \/ MC_HaltSuperImposed . 是否 MC_MoveSuperImposed \/ MC_HaltSuperImposed 仍处于活动状态。即使叠加移动完成后，叠加距离仍会保留。一旦命令中止移动，叠加距离就会重置。...", 
"body" : "当 MC_MoveAbsolute 配置了缓冲模式或命令了混合模式，则最终位置是配置的位置之和 MC_MoveAbsolute 并且距离配置为 MC_MoveSuperImposed \/ MC_HaltSuperImposed . 是否 MC_MoveSuperImposed \/ MC_HaltSuperImposed 仍处于活动状态。即使叠加移动完成后，叠加距离仍会保留。一旦命令中止移动，叠加距离就会重置。 " }, 
{ "title" : "前 CODESYS SoftMotion 版本 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439540497353", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 指挥多个动作 \/ MC_MoveSuperImposed 和 MC_HaltSuperImposed 的行为 \/ 前 CODESYS SoftMotion 版本 4.17.0.0 ", 
"snippet" : "如果 MC_MoveAbsolute 分配缓冲模式或混合模式时被命令，而 MC_MoveSuperImposed \/ MC_HaltSuperImposed 处于活动状态，则最终位置取决于 MC_MoveSuperImposed \/ MC_HaltSuperImposed 在 MC_MoveAbsolute 处于活动状态。如果 MC_MoveSuperImposed \/ MC_HaltSuperImposed 此时仍处于活动状态，则最终位置是 MC_MoveAbsolute 以及距离 MC_MoveSuperImposed \/ MC_HaltSuperImposed . 另一方面，如果 MC_...", 
"body" : "如果 MC_MoveAbsolute 分配缓冲模式或混合模式时被命令，而 MC_MoveSuperImposed \/ MC_HaltSuperImposed 处于活动状态，则最终位置取决于 MC_MoveSuperImposed \/ MC_HaltSuperImposed 在 MC_MoveAbsolute 处于活动状态。如果 MC_MoveSuperImposed \/ MC_HaltSuperImposed 此时仍处于活动状态，则最终位置是 MC_MoveAbsolute 以及距离 MC_MoveSuperImposed \/ MC_HaltSuperImposed . 另一方面，如果 MC_MoveSuperImposed \/ MC_HaltSuperImposed 此时不再处于活动状态，则最终位置为 MC_MoveAbsolute 没有距离 MC_MoveSuperImposed \/ MC_HaltSuperImposed 以类似的方式，所得速度 MC_MoveVelocity 取决于 MC_MoveSuperImposed \/ MC_HaltSuperImposed 什么时候 MC_MoveVelocity 活跃。 下面的曲线显示了 MC_MoveSuperImposed （ 晚餐 功能块）与混合缓冲模式的三个绝对运动并行 BlendingHigh 。第一和第二次运动的速度均为 100 u\/s， ma0 和 ma1 功能块。 ma2 功能块命令第三个运动的速度为 120 u\/s。第一个目标位置为 10 u，第二个为 25 u，第三个为 40 u。叠加运动的速度为 20，距离为 10。最终位置为 50 u：最后一个绝对运动的位置加上 MC_MoveSuperimposed 。 " }, 
{ "title" : "数字开关点 ", 
"url" : "_sm_digital_switches.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 数字开关点 ", 
"snippet" : "CODESYS SoftMotion 为创建数字开关点提供了各种选项。本节概述了各自的优缺点。...", 
"body" : "CODESYS SoftMotion 为创建数字开关点提供了各种选项。本节概述了各自的优缺点。 " }, 
{ "title" : "应用程序示例 ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632666072", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 数字开关点 \/ 应用程序示例 ", 
"snippet" : "例如，根据轴的位置开启胶枪，需要数字开关点。在以下示例中，胶枪应将粘合剂从位置 90 到位置 120 施加到产品上。 胶枪在开启和涂胶之间有一段延迟。这同样适用于关闭。因此，需要进行开\/关补偿，这样胶枪在位置 90 之前打开 50 毫秒，在位置 120 之前关闭 50 毫秒...", 
"body" : "例如，根据轴的位置开启胶枪，需要数字开关点。在以下示例中，胶枪应将粘合剂从位置 90 到位置 120 施加到产品上。 胶枪在开启和涂胶之间有一段延迟。这同样适用于关闭。因此，需要进行开\/关补偿，这样胶枪在位置 90 之前打开 50 毫秒，在位置 120 之前关闭 50 毫秒 " }, 
{ "title" : "功能块概述 ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632773598", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 数字开关点 \/ 功能块概述 ", 
"snippet" : "功能块 多个开关点 开\/关补偿 预测 高精度（时间分辨率高于循环时间） 数据基础 注意 SMC_DigitalCamSwitch_HighPrecision 1 2 设置位置或实际位置 需要更高的时间精度时很有用。除了该功能块外，还需要高精度的数字输出卡才能进行高精度操作。这种组合使得即使在更高的循环时间下也能以高时间精度切换输出。 有关使用功能块的更多信息，请参阅以下内容：示例 使用 MC_DigitalCamSwitch_HighPrecision。 SMC_GetTravelTime 2 设置位置或实际位置 如果是单独的版本，则很有用 DigitalCamSwitch 应该实现功能块（例...", 
"body" : "功能块 多个开关点 开\/关补偿 预测 高精度（时间分辨率高于循环时间） 数据基础 注意 SMC_DigitalCamSwitch_HighPrecision 1 2 设置位置或实际位置 需要更高的时间精度时很有用。除了该功能块外，还需要高精度的数字输出卡才能进行高精度操作。这种组合使得即使在更高的循环时间下也能以高时间精度切换输出。 有关使用功能块的更多信息，请参阅以下内容：示例 使用 MC_DigitalCamSwitch_HighPrecision。 SMC_GetTravelTime 2 设置位置或实际位置 如果是单独的版本，则很有用 DigitalCamSwitch 应该实现功能块（例如，因为需要额外的函数）。 MC_DigitalCamSwitch 3 设置位置或实际位置 如果周期精确的时间分辨率足够，则很有用。 SMC_GetTappetValue 设置位置或实际位置 保留这些功能块仅出于兼容性考虑。对于当前和未来的项目，应使用其他更高级的功能块。 SMC_CamRegister 设置位置或实际位置 1 精确。使用预测数据。 2 预测必须通过以下方式来设定 SMC_SetForecast 功能块。有关预测的更多信息，请参阅以下内容： 预报。 3 只能通过推断 " }, 
{ "title" : "使用 MC_SetOverride 进行动态调整 ", 
"url" : "_sm_adjust_dynamics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 使用 MC_SetOverride 进行动态调整 ", 
"snippet" : "主动运动和未来运动的动态（速度、加速度和加加速度）可以通过使用进行调整 MC_SetOverride 。动态调整始终意味着与最初命令的运动相比有所减少（不允许大于 1 的因子）。这允许机器操作员暂时停止运动（ VelFactor = 0 ）或以减少的动态值执行它，例如检查新的运动序列。 动力学的适应 MC_SetOverride 由此产生的轨迹调整直接在同一周期内生效。这样做的要求是 MC_SetOverride 在活动运动功能块之前调用。 有关更多信息，另请参阅示例 SoftMotion 轴的速度覆盖。...", 
"body" : "主动运动和未来运动的动态（速度、加速度和加加速度）可以通过使用进行调整 MC_SetOverride 。动态调整始终意味着与最初命令的运动相比有所减少（不允许大于 1 的因子）。这允许机器操作员暂时停止运动（ VelFactor = 0 ）或以减少的动态值执行它，例如检查新的运动序列。 动力学的适应 MC_SetOverride 由此产生的轨迹调整直接在同一周期内生效。这样做的要求是 MC_SetOverride 在活动运动功能块之前调用。 有关更多信息，另请参阅示例 SoftMotion 轴的速度覆盖。 " }, 
{ "title" : "支持的功能块 ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4626631011382434026679825113", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 使用 MC_SetOverride 进行动态调整 \/ 支持的功能块 ", 
"snippet" : "功能块 支持： MC_SetOverride 评论 MC_Stop -- MC_Stop 是紧急停止，应始终尽快执行。因此，动态因素 MC_SetOverride 对运动没有任何影响。 MC_Halt ✓ 速度因子没有影响。 MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_Jog SMC_Inch ✓ SMC_Homing ✓ SMC_Cont...", 
"body" : "功能块 支持： MC_SetOverride 评论 MC_Stop -- MC_Stop 是紧急停止，应始终尽快执行。因此，动态因素 MC_SetOverride 对运动没有任何影响。 MC_Halt ✓ 速度因子没有影响。 MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_Jog SMC_Inch ✓ SMC_Homing ✓ SMC_ControlAxisByPos SMC_ControlAxisByPosVel SMC_ControlAxisByVel O 动态因素只有在以下情况下才会产生影响： bAvoidGaps 功能被激活并检测到跳转。的因素 MC_SetOverride 考虑停止和随后的绝对运动以缩小差距。 MC_Home -- 回原点由驱动器独立执行，因此动态因素 MC_SetOverride 没有影响。 MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- 我们建议使用 MC_CamIn 而不是这些功能块。 MC_CamIn O 一旦运动同步，动态因素就不再产生影响（ MC_CamIn.InSync = TRUE ）。 MC_CamOut -- MC_CamOut 没有可调节的动态限制，应保持当前速度。的动态因素 MC_SetOverride 因此没有效果。 MC_GearIn O 一旦运动同步，动态因素就不再产生影响（ MC_GearIn.InGear = TRUE ）。在斜坡加速过程中，仅考虑加速度和冲击系数。速度因子的变化（尤其是 VelFactor=0 ）被忽略。 MC_GearInPos -- 相比之下 MC_GearIn ，它没有可配置的斜坡运动。因此，动态因素 MC_SetOverride 没有效果。 SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- 这些功能块写入轴的设定值（例如， fSetPosition ）。不应修改这些值。因此，动态因素 MC_SetOverride 没有效果。 MC_Phasing O 一旦运动同步，动态因素就不再产生影响（ MC_Phasing.Done = TRUE ）。在斜坡加速过程中，仅考虑加速度和冲击系数。速度因子的变化（尤其是 VelFactor=0 ）被忽略。 SMC_BacklashCompensation -- 动态因素对同步运动没有影响。因此，该功能块忽略了动态因素 MC_SetOverride 。 " }, 
{ "title" : "通过改变动态因素来超越目标位置或目标速度 ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469374918434026680028303", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 使用 MC_SetOverride 进行动态调整 \/ 通过改变动态因素来超越目标位置或目标速度 ", 
"snippet" : "如果在主动运动期间加速因子和\/或急动度因子减小，则可能暂时超过目标位置或目标速度。这可能会导致机器损坏。 和 SMC_MoveContinuousAbsolute 和 SMC_MoveContinuousRelative ，速度因子的变化也可能导致超出限制或导致逆转。更多详细信息可以在两个功能块的文档中找到。...", 
"body" : "如果在主动运动期间加速因子和\/或急动度因子减小，则可能暂时超过目标位置或目标速度。这可能会导致机器损坏。 和 SMC_MoveContinuousAbsolute 和 SMC_MoveContinuousRelative ，速度因子的变化也可能导致超出限制或导致逆转。更多详细信息可以在两个功能块的文档中找到。 " }, 
{ "title" : "速度曲线对使用 MC_SetOverride 的影响 ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469646968034026680341439", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 使用 MC_SetOverride 进行动态调整 \/ 速度曲线对使用 MC_SetOverride 的影响 ", 
"snippet" : "通常建议使用 MC_SetOverride 以及轴的梯形或二次速度曲线。在某些情况下，二次平滑和 sin² 速度曲线对重启或中断运动的反应不佳 动作中断）。由于更改超控等同于在极限变更后重新开始运动，因此将这些速度曲线与下限结合使用时，也可能会超过命令极限 MC_SetOverride 。...", 
"body" : "通常建议使用 MC_SetOverride 以及轴的梯形或二次速度曲线。在某些情况下，二次平滑和 sin² 速度曲线对重启或中断运动的反应不佳 动作中断）。由于更改超控等同于在极限变更后重新开始运动，因此将这些速度曲线与下限结合使用时，也可能会超过命令极限 MC_SetOverride 。 " }, 
{ "title" : "MC_SetOverride 对轴组协调运动的影响 ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm456655390848963402668059106", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 使用 MC_SetOverride 进行动态调整 \/ MC_SetOverride 对轴组协调运动的影响 ", 
"snippet" : "与轴组的协调运动（例如， MC_MoveLinearAbsolute ) 考虑设置的覆盖 MC_SetOverride 在运动规划期间针对每个轴。反过来， MC_GroupSetOverride 覆盖轴组中每个轴的覆盖。...", 
"body" : "与轴组的协调运动（例如， MC_MoveLinearAbsolute ) 考虑设置的覆盖 MC_SetOverride 在运动规划期间针对每个轴。反过来， MC_GroupSetOverride 覆盖轴组中每个轴的覆盖。 " }, 
{ "title" : "预报 ", 
"url" : "_sm_basic_forecast.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 预报 ", 
"snippet" : "预测功能可用于查询有关轴未来运动的信息。预测的一个重要应用是确定到达某个位置所需的时间（类似于触发功能）。另一个应用是确定轴在给定时间的位置和速度。这样，当执行器打开时，例如当胶合喷嘴打开时，可以补偿死区时间。它还可用于精确控制具有死区的执行器，例如根据未来 100 毫秒的轴速度控制胶合输出 要实现这些应用程序，您可以使用 SMC_获取旅行时间 和 读取设置值 配置预测持续时间后的功能块 SMC_设置预测 。 有关使用示例，请参阅： 单轴运动预测...", 
"body" : "预测功能可用于查询有关轴未来运动的信息。预测的一个重要应用是确定到达某个位置所需的时间（类似于触发功能）。另一个应用是确定轴在给定时间的位置和速度。这样，当执行器打开时，例如当胶合喷嘴打开时，可以补偿死区时间。它还可用于精确控制具有死区的执行器，例如根据未来 100 毫秒的轴速度控制胶合输出 要实现这些应用程序，您可以使用 SMC_获取旅行时间 和 读取设置值 配置预测持续时间后的功能块 SMC_设置预测 。 有关使用示例，请参阅： 单轴运动预测" }, 
{ "title" : "具有预测功能的运动功能块 ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm2344331274012", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 预报 \/ 具有预测功能的运动功能块 ", 
"snippet" : "以下概述显示了哪些功能块支持预测功能。 功能块 预报 MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- MC_CamIn ✓...", 
"body" : "以下概述显示了哪些功能块支持预测功能。 功能块 预报 MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- MC_CamIn ✓ MC_CamOut ✓ MC_GearIn ✓ MC_GearOut ✓ MC_GearInPos ✓ SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- SMC_SetTorque -- MC_Phasing ✓ MC_Jog SMC_Inch ✓ SMC_BacklashCompensation ✓ " }, 
{ "title" : "启用预测功能 ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433129890703", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 预报 \/ 启用预测功能 ", 
"snippet" : "默认情况下，预测功能处于禁用状态。这意味着 SMC_ReadSetValues 仅对 TimeOffset 0 秒（当前任务周期开始）和任务间隔（当前任务周期结束）之间，以及 SMC_GetTravelTime 仅对本周期内到达的位置返回有效时间。 这 SMC_设置预测 功能块用于配置所需的预测持续时间和 SMC_获取预测 功能块用于读取。 笔记： 预测持续时间可以随时更改。 避免不必要地过长的预测持续时间，因为预测计算会消耗计算时间。选择适合您的应用的最小值。 如果您使用主\/从功能块（例如 MC_CamIn )，则主轴和从轴都必须启用预测。...", 
"body" : "默认情况下，预测功能处于禁用状态。这意味着 SMC_ReadSetValues 仅对 TimeOffset 0 秒（当前任务周期开始）和任务间隔（当前任务周期结束）之间，以及 SMC_GetTravelTime 仅对本周期内到达的位置返回有效时间。 这 SMC_设置预测 功能块用于配置所需的预测持续时间和 SMC_获取预测 功能块用于读取。 笔记： 预测持续时间可以随时更改。 避免不必要地过长的预测持续时间，因为预测计算会消耗计算时间。选择适合您的应用的最小值。 如果您使用主\/从功能块（例如 MC_CamIn )，则主轴和从轴都必须启用预测。 " }, 
{ "title" : "呼叫顺序 ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130424909", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 预报 \/ 呼叫顺序 ", 
"snippet" : "为了使预测功能产生最佳结果，必须确保以正确的顺序调用主\/从功能块。这适用于 MC_CamIn ， MC_GearIn ， MC_GearInPos ， MC_Phasing ， SMC_BacklashCompensation ， 和 SMC_TrackAxis . 主轴运动功能块应在主\/从功能块之前调用。 即使没有预测，当调用顺序正确时，轨迹也会更好。当顺序错误时，从站移动会延迟一个周期。 为了 MC_SetOverride ，该功能块也应在轴的运动功能块之前调用。通过更改倍率，轴的运动会在同一任务循环中发生改变。因此，之前根据预测确定的值将失去其有效性。下次将再次确定这些值。 SMC_Ge...", 
"body" : "为了使预测功能产生最佳结果，必须确保以正确的顺序调用主\/从功能块。这适用于 MC_CamIn ， MC_GearIn ， MC_GearInPos ， MC_Phasing ， SMC_BacklashCompensation ， 和 SMC_TrackAxis . 主轴运动功能块应在主\/从功能块之前调用。 即使没有预测，当调用顺序正确时，轨迹也会更好。当顺序错误时，从站移动会延迟一个周期。 为了 MC_SetOverride ，该功能块也应在轴的运动功能块之前调用。通过更改倍率，轴的运动会在同一任务循环中发生改变。因此，之前根据预测确定的值将失去其有效性。下次将再次确定这些值。 SMC_GetTravelTime 或者 SMC_ReadSetValues 叫做。 " }, 
{ "title" : "缓冲模式 ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130652478", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 预报 \/ 缓冲模式 ", 
"snippet" : "预测功能不仅限于单个运动，还扩展到所有以混合或缓冲模式控制的后续运动。 当在轴上执行中止运动时，它会改变此任务循环中轴的运动。因此，之前根据预测确定的值将失去其有效性。下次重新确定它们 SMC_GetTravelTime 或者 SMC_ReadSetValues 叫做。...", 
"body" : "预测功能不仅限于单个运动，还扩展到所有以混合或缓冲模式控制的后续运动。 当在轴上执行中止运动时，它会改变此任务循环中轴的运动。因此，之前根据预测确定的值将失去其有效性。下次重新确定它们 SMC_GetTravelTime 或者 SMC_ReadSetValues 叫做。 " }, 
{ "title" : "有效预测\/限制 ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130869747", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 预报 \/ 有效预测\/限制 ", 
"snippet" : "理想情况下，有效可用预测时长等于配置的预测时长。但是，有些因素可能会导致有效预测比配置的预测时长短。 当执行主\/从运动时，从站的有效预测是主机的有效预测与从站的配置预测中的最小者。 对于逻辑轴和编码器轴，有效预测始终为 0。 如果主动运动功能块不支持预测功能，那么有效预测也为0。 在所有其他情况下，有效预测与配置的预测相同。...", 
"body" : "理想情况下，有效可用预测时长等于配置的预测时长。但是，有些因素可能会导致有效预测比配置的预测时长短。 当执行主\/从运动时，从站的有效预测是主机的有效预测与从站的配置预测中的最小者。 对于逻辑轴和编码器轴，有效预测始终为 0。 如果主动运动功能块不支持预测功能，那么有效预测也为0。 在所有其他情况下，有效预测与配置的预测相同。 " }, 
{ "title" : "诊断 ", 
"url" : "_sm_basic_error_diagnosis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 诊断 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "常见错误 ", 
"url" : "_sm_basic_common_errors.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 诊断 \/ 常见错误 ", 
"snippet" : "本页描述了使用时常见的错误 CODESYS Softmotion Basic 、错误原因以及纠正错误可能采取的措施。有关所有可能的错误及其简要说明的列表，请参阅库文档： SMC_错误 错误代码 描述和原因 操作 SMC_DI_AXIS_ERROR 驱动器报告了错误。 可能的原因： 位置滞后 限位开关 过载（I²t 误差） 检查驱动器报告了哪种错误。可以从驱动器的显示屏（如果有）读取错误，也可以使用 MC_ReadAxisError 功能块。 SMC_AXIS_ERROR_DURING_MOTION 驱动器报告了错误。在运动过程中，活动运动块返回此错误。 查看针对错误的操作 SMC_DI_AXI...", 
"body" : "本页描述了使用时常见的错误 CODESYS Softmotion Basic 、错误原因以及纠正错误可能采取的措施。有关所有可能的错误及其简要说明的列表，请参阅库文档： SMC_错误 错误代码 描述和原因 操作 SMC_DI_AXIS_ERROR 驱动器报告了错误。 可能的原因： 位置滞后 限位开关 过载（I²t 误差） 检查驱动器报告了哪种错误。可以从驱动器的显示屏（如果有）读取错误，也可以使用 MC_ReadAxisError 功能块。 SMC_AXIS_ERROR_DURING_MOTION 驱动器报告了错误。在运动过程中，活动运动块返回此错误。 查看针对错误的操作 SMC_DI_AXIS_ERROR 。 SMC_FB_WASNT_CALLED_DURING_MOTION 控制有效运动的功能块尚未在当前循环中被调用。 可能的原因： 缓冲动作或混合动作的调用顺序不正确。不得在命令前一个动作的功能块实例之前调用后续动作的功能块实例 作为 SoftMotion 版本 4.15.0.0，此错误的日志消息包含受影响功能块的实例路径。 在应用程序中，检查功能块未被循环调用的原因。 修复该调用，以便它能循环执行（至少在块正在使用时）。 SMC_BLOCKING_MC_STOP_WASNT_CALLED 在主动停止期间，相关功能块 MC_Stop 在当前周期中未被调用。 查看针对错误的操作 SMC_FB_WASNT_CALLED_DURING_MOTION 。 SMC_AXIS_NOT_READY_FOR_MOTION 该轴尚未准备好使用，无法执行所需的运动。 可能的原因： 轴未处于相应运动的操作状态（例如， power_off 或者 errorstop ）。 轴处于错误状态并且所有缓冲运动都会返回此错误。 轴线位于 stopping 状态（在活动 MC_Stop ) 并命令进行新的中止运动。 检查轴的状态： 轴是否处于运行状态 MC_Power ？ 轴是否在 errorstop 状态？如果是，则确定轴错误并进行纠正。 轴状态是否与命令的运动相匹配？例如， MC_CamOut 仅当轴处于同步移动状态时才可指令。 SMC_FB_CALLED_FROM_WRONG_TASK 这 SoftMotion 该块是从与轴的总线任务不对应的任务中调用的。 因为 SoftMotion 块更改轴中的值，如果从总线任务以外的任务进行调用，则会出现不一致的状态。这会导致未定义的错误，此错误可防止这种情况发生。 检查日志：受影响的轴和块实例已记录。 从不正确的任务中删除呼叫。 SMC_DI_FIELDBUS_LOST_SYNCRONICITY 使用时发生 EtherCAT 如果从控制器到驱动器的帧没有按时（在定义的时间窗口（“SyncWindow”）内）接收到或者根本没有接收到，则使用分布式时钟。 可能的原因： 实时问题： 任务抖动过高。 任务优先级 EtherCAT 任務太低。 其他现场总线（例如， Modbus ）或除了控制任务（例如，文件访问）之外的冗长操作 EtherCAT 任务 Modbus 在另一个任务中执行，但它使用的 I\/O 通道也在 EtherCAT 任务。 尤其是 Linux 操作系统，系统的配置（例如 IRQ 优先级） 与 EtherCAT 从属：连接中断、电磁兼容性（EMC）问题等。 检查行为的原因。以下功能可以帮助您： 这 状态页面 的 EtherCAT 掌握 EtherCAT 任务的周期和抖动时间分析 任务配置 针对实时问题可能采取的措施： 优化实时。为此，请按照中的说明进行操作 性能优化 增加循环时间 EtherCAT 任务。 增加 DCInSyncWindow 的 EtherCAT 大师。请参阅： IoDrvEtherCAT.DCInSyncWindow (PROP) 使能够 FrameAtTaskStart 为了 EtherCAT 大师。请参阅： IoDrvEtherCAT.FrameAtTaskStart (PROP) 如果驱动器可以处理同步问题，则可以通过以下方式禁用同步检查 SMC_Set_ETC_DCSyncSupervision 。 SMC_DI_SWLIMITS_EXCEEDED 轴沿正或负软件限位开关方向移动，并将以当前动态超过该限位开关。由于所需的制动距离也包括在计算中，因此在实际限位开关位置之前也会触发错误。 检查在此位置范围内是否需要移动。 如果需要，调整负向和\/或正向软件限位开关位置。请参见 标签：常规SMC_DI_HWLIMITS_EXCEEDED 正或负硬件限位开关已触发，并且轴沿此限位开关的方向移动。 检查运动的指令位置。这不应超出硬件限位开关的位置。 如果运动正常，则检查硬件限位开关的信号。 SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT 没有主动运动，但是设定速度不等于零，并且轴处于遵循设定值的运行状态。 可能的原因： 使用时 MC_PositionProfile ， MC_VelocityProfile ， 或者 MC_AccelerationProfile ，轴必须在此运动结束时停止，或者必须在同一周期内命令后续运动。否则将返回此错误。 检查问题原因： 缓冲和混合动作的调用顺序不正确：调整调用顺序。有关更多信息，请参阅 运动功能块的执行顺序。 MC_PositionProfile ， MC_VelocityProfile ， 或者 MC_AccelerationProfile 已使用，但最后未达到静止状态：相应地调整配置文件，以便最后达到静止状态。或者改为使用 凸轮，它们涵盖了与这些功能块类似的用例，但更加灵活且更易于使用。 " }, 
{ "title" : "表现 ", 
"url" : "_sm_diagnosis_performance.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 诊断 \/ 表现 ", 
"snippet" : "使用的 POU AXIS_REF_SM3 功能块总是检查它们是否被总线循环任务调用。可以通过编译器定义对时间关键的应用程序禁用此检查 SM3_DISABLE_TASK_CHECKS ....", 
"body" : "使用的 POU AXIS_REF_SM3 功能块总是检查它们是否被总线循环任务调用。可以通过编译器定义对时间关键的应用程序禁用此检查 SM3_DISABLE_TASK_CHECKS . " }, 
{ "title" : "例子 ", 
"url" : "_sm_basic_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "单轴运动 ", 
"url" : "_sm_basic_examples_single_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 单轴运动 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "控制单轴的运动 ", 
"url" : "_sm_example_single_axis_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 单轴运动 \/ 控制单轴的运动 ", 
"snippet" : "见 PLCopenSingle.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 此示例演示如何通过 PLCopen 标准化功能块控制驱动器。 插入一个名为的虚拟驱动器 Drive 在下面的设备树中 SoftMotion 通用轴池 . 创建一个 MOTION_PRG ST中的程序。 PROGRAM MOTION_PRG VAR iStatus: INT; Power: MC_Power; MoveAbsolute: MC_MoveAbsolute; p:REAL:=100; END_VAR CASE iStatus ...", 
"body" : "见 PLCopenSingle.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 此示例演示如何通过 PLCopen 标准化功能块控制驱动器。 插入一个名为的虚拟驱动器 Drive 在下面的设备树中 SoftMotion 通用轴池 . 创建一个 MOTION_PRG ST中的程序。 PROGRAM MOTION_PRG\nVAR\n iStatus: INT;\n Power: MC_Power;\n MoveAbsolute: MC_MoveAbsolute;\n p:REAL:=100;\nEND_VAR\n\nCASE iStatus OF\n\n\/\/ initialization of the axis\n0:\n Power(Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE, Axis:=Drive);\n IF Power.Status THEN\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis to position p by use of the MC_MoveAbsolute function block\n1:\n MoveAbsolute(Execute:=TRUE, Position:= p, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis back to position 0 by use of the MC_MoveAbsolute function block:\n2:\n MoveAbsolute(Execute:=TRUE, Position:= 0, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := 1;\n END_IF 将 MOTION_PRG 程序的调用添加到任务中 主要任务 . 设备树： 将项目下载到控制器并启动它。 打开 驾驶 编辑器中的虚拟轴。 在里面 在线的 的一部分 一般的 选项卡，您会看到轴运动。 " }, 
{ "title" : "使用可视化模板控制 CFC 中单轴的运动 ", 
"url" : "_sm_example_single_axis_visu_template.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 单轴运动 \/ 使用可视化模板控制 CFC 中单轴的运动 ", 
"snippet" : "见 PLCopenSingle2.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 也可以使用任何其他 IEC 实现语言代替 ST，例如此处的 CFC。该语言演示了功能块的启动和中断机制。此外，功能块的不同启动模式 MC_MoveAbsolute 可以测试旋转轴。 插入一个名为的虚拟驱动器 Drive 在下面的设备树中 SoftMotion 通用轴池 . 双击对象以打开其编辑器。 将参数更改为周期为 360° 的旋转驱动器。 轴型 : 模数 模值 [u] : 360.0 创建一个 MOTION_PRG CFC 中的程...", 
"body" : "见 PLCopenSingle2.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 也可以使用任何其他 IEC 实现语言代替 ST，例如此处的 CFC。该语言演示了功能块的启动和中断机制。此外，功能块的不同启动模式 MC_MoveAbsolute 可以测试旋转轴。 插入一个名为的虚拟驱动器 Drive 在下面的设备树中 SoftMotion 通用轴池 . 双击对象以打开其编辑器。 将参数更改为周期为 360° 的旋转驱动器。 轴型 : 模数 模值 [u] : 360.0 创建一个 MOTION_PRG CFC 中的程序。插入功能块 MC_Power , MC_MoveAbsolute ， 和 MC_MoveVelocity . 通常建议初始化功能块输入。这样您就不必在启动此测试应用程序时一次又一次地指定这些值。 PROGRAM MOTION_PRG\nVAR\n mcp: MC_Power := (Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n mcmv: MC_MoveVelocity :=(Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\n mcma: MC_MoveAbsolute := (Position:=180, Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\nEND_VAR 氟氯化碳： 添加调用 MOTION_PRG 程序到任务 主要任务 . 添加一个 可视化 反对申请。 放置可视化模板 VISU_NEW_MC_MoveAbsolute , VISU_NEW_MC_MoveVelocity , VISU_NEW_MC_Power ， 和 旋转驱动 在可视化编辑器中。将这些链接到功能块实例 MOTION_PRG . 可视化： 构建项目并将其下载到 PLC。启动项目。 在编辑器中打开可视化。点击 使能够 输入（MC_Power）然后 执行 输入 (MC_Move_Absolute)。 驱动器旋转。 打开 驾驶 编辑器中的虚拟轴。 在里面 在线的 的一部分 一般的 选项卡，您会看到轴运动。 试验这些功能块的参数。更改参数并观察行为。 " }, 
{ "title" : "单轴运动预测 ", 
"url" : "_sm_basic_example_forecast.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 单轴运动 \/ 单轴运动预测 ", 
"snippet" : "这 BasicMotion_Forecast.project 示例项目位于安装目录中 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 此示例显示如何定义轴的预测以获取有关未来轴状态的信息。 在本例中，在轴上执行到位置 10 的绝对运动。通过在轴上设置 300 毫秒的预测，您可以在应用程序中提前了解轴何时以及以何种动态移动到位置 8。 有关轴预测的更多信息，请参阅： 预报...", 
"body" : "这 BasicMotion_Forecast.project 示例项目位于安装目录中 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 此示例显示如何定义轴的预测以获取有关未来轴状态的信息。 在本例中，在轴上执行到位置 10 的绝对运动。通过在轴上设置 300 毫秒的预测，您可以在应用程序中提前了解轴何时以及以何种动态移动到位置 8。 有关轴预测的更多信息，请参阅： 预报" }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768266588", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 单轴运动 \/ 单轴运动预测 \/ 应用程序的结构 ", 
"snippet" : "该应用程序包括一个 PLC_PRG 程序和一个 Trace 。 PLC程序 虚拟轴在 STATE_POWER_DRIVE 状态。然后 SMC_SetForecast 功能块用于定义轴的 300 毫秒预测 STATE_SET_FORECAST 州。 SMC_GetForecast 功能块可用于读取轴的设定预测。 在里面 STATE_MOVE_TO_POSITION 状态，执行到位置 10 的绝对移动。 SMC_GetTravelTime 功能块也启动。该功能块用于读取轴到达位置 8 的时间。 SMC_ReadSetValues 功能块用于确定位置 8 处的动态。可以将时间偏移传递给该功能块，以便...", 
"body" : "该应用程序包括一个 PLC_PRG 程序和一个 Trace 。 PLC程序 虚拟轴在 STATE_POWER_DRIVE 状态。然后 SMC_SetForecast 功能块用于定义轴的 300 毫秒预测 STATE_SET_FORECAST 州。 SMC_GetForecast 功能块可用于读取轴的设定预测。 在里面 STATE_MOVE_TO_POSITION 状态，执行到位置 10 的绝对移动。 SMC_GetTravelTime 功能块也启动。该功能块用于读取轴到达位置 8 的时间。 SMC_ReadSetValues 功能块用于确定位置 8 处的动态。可以将时间偏移传递给该功能块，以便读取轴的动态。在我们的例子中，我们传递轴到达位置 8 所需的持续时间。 痕迹 您可以使用轨迹来跟踪虚拟轴的移动。记录轴的当前位置、速度和加速度。还显示到达位置 8 的持续时间以及轴在此位置的动态。 请注意 SMC_GetTravelTime 相对于循环的开始指定。轴的设定值对应于循环结束时的设定值。 " }, 
{ "title" : "调试 ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768283734", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 单轴运动 \/ 单轴运动预测 \/ 调试 ", 
"snippet" : "构建应用程序并将其下载到控制器。 启动跟踪和应用程序。 在轨迹中，您可以跟踪虚拟轴的移动。注意到位置 8 的持续时间以及位置 8 处的动态。...", 
"body" : "构建应用程序并将其下载到控制器。 启动跟踪和应用程序。 在轨迹中，您可以跟踪虚拟轴的移动。注意到位置 8 的持续时间以及位置 8 处的动态。 " }, 
{ "title" : "双轴同步运动 ", 
"url" : "_sm_basic_synch_movements_2_axis_example.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 双轴同步运动 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "电子齿轮、相位偏移和齿轮间隙补偿 ", 
"url" : "_sm_basic_example_synchronized_motion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 双轴同步运动 \/ 电子齿轮、相位偏移和齿轮间隙补偿 ", 
"snippet" : "查看 BasicMotion_SynchronizedMotion.project 安装目录中的示例 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 此示例说明如何将电子变速箱与相位偏移和齿轮间隙补偿结合使用。...", 
"body" : "查看 BasicMotion_SynchronizedMotion.project 安装目录中的示例 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 此示例说明如何将电子变速箱与相位偏移和齿轮间隙补偿结合使用。 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 双轴同步运动 \/ 电子齿轮、相位偏移和齿轮间隙补偿 \/ 应用程序的结构 ", 
"snippet" : "该应用程序由一个简单的状态机组成 PLC_PRG 程序和跟踪，您可以使用它轻松追踪功能块的功能。 使用 MC_Power 。 (STATE_POWER ） 启动同步运动，并使主轴在位置 0 和位置 100 之间连续移动（ STATE_COMMAND_POS_0 和 STATE_COMMAND_POS_1 ）。...", 
"body" : "该应用程序由一个简单的状态机组成 PLC_PRG 程序和跟踪，您可以使用它轻松追踪功能块的功能。 使用 MC_Power 。 (STATE_POWER ） 启动同步运动，并使主轴在位置 0 和位置 100 之间连续移动（ STATE_COMMAND_POS_0 和 STATE_COMMAND_POS_1 ）。 " }, 
{ "title" : "用法 ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 双轴同步运动 \/ 电子齿轮、相位偏移和齿轮间隙补偿 \/ 用法 ", 
"snippet" : "主轴（轨迹图中的黑色）以每秒 50 个单位的最大速度在位置 0 和位置 100 之间连续来回移动。 电子变速箱（ MC_GearIn ）的齿轮比为 2:3，将主机芯转换为 Slave0 轴（轨迹图中为绿色）。齿轮产生的最大速度为每秒 75 个单位。 然后，相位偏移（ MC_Phasing ）30个单位应用于 Slave1 轴（轨迹图中的橙色）。速度与 Slave0 轴，除斜坡阶段外。 最后，采用齿轮间隙补偿，使运动达到 Drive 轴（轨迹图中的蓝色）。为了演示目的，齿轮间隙设置为不切实际的 5 个单位的高值。该图显示了运动开始时以及每次运动方向反转时的补偿运动。...", 
"body" : "主轴（轨迹图中的黑色）以每秒 50 个单位的最大速度在位置 0 和位置 100 之间连续来回移动。 电子变速箱（ MC_GearIn ）的齿轮比为 2:3，将主机芯转换为 Slave0 轴（轨迹图中为绿色）。齿轮产生的最大速度为每秒 75 个单位。 然后，相位偏移（ MC_Phasing ）30个单位应用于 Slave1 轴（轨迹图中的橙色）。速度与 Slave0 轴，除斜坡阶段外。 最后，采用齿轮间隙补偿，使运动达到 Drive 轴（轨迹图中的蓝色）。为了演示目的，齿轮间隙设置为不切实际的 5 个单位的高值。该图显示了运动开始时以及每次运动方向反转时的补偿运动。 " }, 
{ "title" : "GearInPos（飞锯） ", 
"url" : "_sm_basic_example_gearinpos.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 双轴同步运动 \/ GearInPos（飞锯） ", 
"snippet" : "查看 BasicMotion_GearInPos.project 安装目录中的示例 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 此示例说明如何使用 MC_GearInPos 实现飞锯。对于这个项目，我们建议安装 CODESYS Depictor ，可以将应用程序显示为 3D 动画。（未经许可的免费版本足以做到这一点。）...", 
"body" : "查看 BasicMotion_GearInPos.project 安装目录中的示例 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 此示例说明如何使用 MC_GearInPos 实现飞锯。对于这个项目，我们建议安装 CODESYS Depictor ，可以将应用程序显示为 3D 动画。（未经许可的免费版本足以做到这一点。） " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4565133330038434227193133829", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 双轴同步运动 \/ GearInPos（飞锯） \/ 应用程序的结构 ", 
"snippet" : "该应用程序由一个状态机组成 PLC_PRG 程序，3D 表示（场景， DepictorCalculation 程序）、简单的工件模拟（ SimulateWorkpiece 您可以通过它轻松了解功能块的效果。 PLC_PRG中的流程如下： 使用 MC_Power 。 （ STATE_POWER ） 等待光栅检测到工件。（ STATE_WAIT_FOR_WORKPIECE ） 一旦光栅检测到工件，将锯子平行于传送带传送的从动装置就会与传送带上的工件同步（由 Master 轴）。 （ STATE_WAIT_FOR_SYNC ） 当达到同步时，锯子垂直于工件向前和向后移动一次。（ STATE_MOVE...", 
"body" : "该应用程序由一个状态机组成 PLC_PRG 程序，3D 表示（场景， DepictorCalculation 程序）、简单的工件模拟（ SimulateWorkpiece 您可以通过它轻松了解功能块的效果。 PLC_PRG中的流程如下： 使用 MC_Power 。 （ STATE_POWER ） 等待光栅检测到工件。（ STATE_WAIT_FOR_WORKPIECE ） 一旦光栅检测到工件，将锯子平行于传送带传送的从动装置就会与传送带上的工件同步（由 Master 轴）。 （ STATE_WAIT_FOR_SYNC ） 当达到同步时，锯子垂直于工件向前和向后移动一次。（ STATE_MOVE_TOOL_0\/1 ） 将从动装置移至静止位置并从 2 处重新开始该过程。（ STATE_MOVE_TO_REST ） " }, 
{ "title" : "坐标系统和尺寸 ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4627667581768034227193767932", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 双轴同步运动 \/ GearInPos（飞锯） \/ 坐标系统和尺寸 ", 
"snippet" : "坐标系原点在传送带中心，Z轴指向上方，X轴指向传送带运动方向，从传送带看，Y轴指向远离锯子的方向。 传送带和工件的尺寸、光栅的位置以及锯与工件同步运行的位置都作为常量存储在 GVL Const 。...", 
"body" : "坐标系原点在传送带中心，Z轴指向上方，X轴指向传送带运动方向，从传送带看，Y轴指向远离锯子的方向。 传送带和工件的尺寸、光栅的位置以及锯与工件同步运行的位置都作为常量存储在 GVL Const 。 " }, 
{ "title" : "用法 ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm458752582335683422719410462", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 双轴同步运动 \/ GearInPos（飞锯） \/ 用法 ", 
"snippet" : "启动应用程序。在 场景 描绘器对象，在轨迹中，您可以看到主设备（传送带上的工件）和从设备（锯子）之间的同步是如何执行的。...", 
"body" : "启动应用程序。在 场景 描绘器对象，在轨迹中，您可以看到主设备（传送带上的工件）和从设备（锯子）之间的同步是如何执行的。 " }, 
{ "title" : "凸轮 ", 
"url" : "_sm_basic_examples_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "交替凸轮 ", 
"url" : "_sm_example_changing_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 交替凸轮 ", 
"snippet" : "见 PLCopenMultiCAM.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 此示例演示如何使用两个交替凸轮创建凸轮运动。该程序在 ST 中实现并执行与“使用虚拟时间轴的凸轮驱动控制”示例相同的操作。在第一个凸轮结束时， MC_CamIn 功能块设置 EndOfProfile 输出。这样，另一个曲线表就赋值给了 MC_CamTableSelect 和 MC_CamIn 重新启动。...", 
"body" : "见 PLCopenMultiCAM.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 此示例演示如何使用两个交替凸轮创建凸轮运动。该程序在 ST 中实现并执行与“使用虚拟时间轴的凸轮驱动控制”示例相同的操作。在第一个凸轮结束时， MC_CamIn 功能块设置 EndOfProfile 输出。这样，另一个曲线表就赋值给了 MC_CamTableSelect 和 MC_CamIn 重新启动。 " }, 
{ "title" : "使用虚拟时间轴控制凸轮驱动器 ", 
"url" : "_sm_example_drive_control_virtual_time_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 使用虚拟时间轴控制凸轮驱动器 ", 
"snippet" : "见 PLCopenMulti.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 此示例演示如何在线性驱动器上实现周期性凸轮。该示例还演示了如何使用挺杆功能。 插入一个名为 Example 在下面的设备树中 应用 .在编辑器中打开凸轮。 定义一个挺杆 挺杆 标签。 X ： 8.0 正传 ： Invert 否定通过 ： Invert 插入一个名为的虚拟驱动器 Drive 在下面的设备树中 SoftMotion 通用轴池 .对于这个轴，选择轴类型 模数 模值为 360 . 插入另一个名为的虚拟驱动器 Virtual .对于...", 
"body" : "见 PLCopenMulti.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 此示例演示如何在线性驱动器上实现周期性凸轮。该示例还演示了如何使用挺杆功能。 插入一个名为 Example 在下面的设备树中 应用 .在编辑器中打开凸轮。 定义一个挺杆 挺杆 标签。 X ： 8.0 正传 ： Invert 否定通过 ： Invert 插入一个名为的虚拟驱动器 Drive 在下面的设备树中 SoftMotion 通用轴池 .对于这个轴，选择轴类型 模数 模值为 360 . 插入另一个名为的虚拟驱动器 Virtual .对于该轴，选择 模数 轴类型，模值为 10 . 创建一个 MOTION_PRG CFC 中的程序。 PROGRAM MOTION_PRG\nVAR\n power1, power2: MC_Power;\n TableSelect: MC_CamTableSelect;\n CamIn: MC_CamIn;\n Tappet: SMC_GetTappetValue;\n MoveVirtual: MC_MoveVelocity;\nEND_VAR 插入一个框元素并分配变量 power1 到它。 box 元素用于开启 Drive . 按如下方式配置输入： 轴 ： Drive 使能够 ： TRUE bRegulatorOn ： TRUE 驱动器启动 TRUE 插入一个框元素并分配变量 power2 到它。 box 元素用于开启 Virtual 驾驶。 按如下方式配置输入： 轴 ： Virtual 使能够 ： TRUE bRegulatorOn ： TRUE 驱动器启动 TRUE 插入一个框元素并分配变量 MoveVirtual 到它。 box 元素用于移动虚拟母版。 按如下方式配置输入： 轴 ： Virtual 执行 ： power2.Status 速度 ： 2 加速 10 减速 10 方向 positive 插入一个框元素并分配变量 TableSelect 到它。 box 元素用于选择凸轮。 按如下方式配置输入： 掌握 ： Virtual 奴隶 ： Drive 凸轮表 ： Example 执行 TRUE 定期 TRUE 绝对大师 TRUE 从绝对 TRUE 插入一个框元素并分配变量 CamIn 到它。框元素实现选定的凸轮盘。 按如下方式配置输入： 掌握 ： Virtual 奴隶 ： Drive 执行 power1.Status 主偏移量 ： 0 从偏移 ： 0 大师级缩放 ： 1 从机缩放 ： 1 启动模式 ： absolute 凸轮表ID ： TableSelect.CamTableID 速度差异 ： 1 加速 ： 1 减速 ： 1 挺杆滞后 ： 1 插入一个框元素并分配变量 Tappet 到它。框元素检查凸轮开关的设置。 按如下方式配置输入： 挺杆 ： CamIn.Tappets 身份证 ： 1 初始值 FALSE bSetInitValueAtReset ： FALSE 挺杆被定义为反向挺杆。因此，它的值每 10 秒更改一次。 示例项目提供了用于检查各个功能块和轴位置的可视化。 添加调用 MOTION_PRG 程序到任务 主要任务 . 将项目下载到控制器并启动它。 有关更多信息，请参阅： MC_Power MC_CamTableSelect MC_CamIn SMC_GetTapetValue MC_MoveVelocity " }, 
{ "title" : "通过编程创建凸轮 ", 
"url" : "_sm_basic_example_cam_programmatic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 通过编程创建凸轮 ", 
"snippet" : "这 BasicMotion_CreateCamTableOnline.project 示例项目位于安装目录中 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 该示例说明如何使用 IEC 代码创建和使用摄像头。这里涵盖了以下几点： 使用 IEC 代码再次创建在摄像头编辑器中创建的摄像头。 在一种情况下，凸轮盘是在总线任务中生成的。 在另一种情况下，凸轮盘是在单独的任务中生成的。 然后，所有三个凸轮都使用相同的主轴和不同的从轴运行。三个奴隶的动作是相同的。 在 IEC 代码中生成的凸轮显示在可视化中。 有关以编程方式创建凸轮的更多信息，请参阅： 通过编程创...", 
"body" : "这 BasicMotion_CreateCamTableOnline.project 示例项目位于安装目录中 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 该示例说明如何使用 IEC 代码创建和使用摄像头。这里涵盖了以下几点： 使用 IEC 代码再次创建在摄像头编辑器中创建的摄像头。 在一种情况下，凸轮盘是在总线任务中生成的。 在另一种情况下，凸轮盘是在单独的任务中生成的。 然后，所有三个凸轮都使用相同的主轴和不同的从轴运行。三个奴隶的动作是相同的。 在 IEC 代码中生成的凸轮显示在可视化中。 有关以编程方式创建凸轮的更多信息，请参阅： 通过编程创建凸轮" }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 通过编程创建凸轮 \/ 应用程序的结构 ", 
"snippet" : "该应用程序由以下组件组成： CamOffline 在摄像头编辑器中创建的摄像头，应使用 IEC 代码再次创建。 PLC_PRG 该程序由一个简单的状态机组成，逻辑上由三个部分组成。在第一和第二部分中，使用 IEC 代码创建了一个凸轮。在第三部分中，运行先前创建的摄像头和离线创建的相同摄像头。 第1部分： 在第一种状态下 STATE_CREATE_ONLINE_TABLE ，以 IEC 代码创建凸轮。 SMCB凸轮生成器 功能块来自 SM3_CamBuilder 为此，我们使用库。添加了三个段：一个 Poly5 元素，后面跟着一个 Line 元素，然后是另一个 Poly5 元素。Builder ...", 
"body" : "该应用程序由以下组件组成： CamOffline 在摄像头编辑器中创建的摄像头，应使用 IEC 代码再次创建。 PLC_PRG 该程序由一个简单的状态机组成，逻辑上由三个部分组成。在第一和第二部分中，使用 IEC 代码创建了一个凸轮。在第三部分中，运行先前创建的摄像头和离线创建的相同摄像头。 第1部分： 在第一种状态下 STATE_CREATE_ONLINE_TABLE ，以 IEC 代码创建凸轮。 SMCB凸轮生成器 功能块来自 SM3_CamBuilder 为此，我们使用库。添加了三个段：一个 Poly5 元素，后面跟着一个 Line 元素，然后是另一个 Poly5 元素。Builder 生成一个 在线摄像头 凸轮。从此时起，凸轮以 IEC 代码创建，可以像 CamOffline 在凸轮编辑器中离线创建的凸轮。 第2部分： 在 STATE_INIT_ONLINE_TABLE_MULTITASK ， STATE_START_CREATE_ONLINE_TABLE_MULTITASK ，以及 STATE_READ_ONLINE_TABLE_MULTITASK 状态，摄像头的创建在另一个任务中开始，然后被读取。 第 3 部分： 在 STATE_POWER_DRIVES 状态，主轴和三个从轴的虚拟轴被初始化。然后使用以下命令选择凸轮 MC_CamTableSelect 在 STATE_SELECT_TABLE 状态并在决赛中执行 STATE_MOVEMENT 州。使用以下方法移动主轴 MC_MoveVelocity 并用作三个凸轮的主摄像头。 MultitaskCamBuilder 一种生成凸轮的程序，如第 1 部分所述 PLC_PRG 。这里唯一的区别是使用了摄像头的多任务\/多核安全变体 GVL 此处实例化了摄像头的多任务\/多核安全变体。 Visualization 可视化包含 SMC_Visu_CamDisplayer 用于显示摄像头的元素。第 1 部分中生成的凸轮 PLC_PRG 显示出来。 CamDisplayerSettings 用于显示摄像头的其他元素 Visualization Trace 您可以使用跟踪来跟踪虚拟轴的移动。记录主轴的当前位置，以及三个从轴的位置、速度和加速度。 " }, 
{ "title" : "调试 ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 通过编程创建凸轮 \/ 调试 ", 
"snippet" : "构建应用程序并将其下载到控制器。 启动跟踪和应用程序。 观察采样轨迹。 在可视化中显示生成的摄像头...", 
"body" : "构建应用程序并将其下载到控制器。 启动跟踪和应用程序。 观察采样轨迹。 在可视化中显示生成的摄像头 " }, 
{ "title" : "使用 MC_DigitalCamSwitch_HighPrecision ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 使用 MC_DigitalCamSwitch_HighPrecision ", 
"snippet" : "这个例子 BasicMotion_DigitalCamSwitch_HighPrecision.project 位于安装目录中 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 此示例说明如何使用的输出 SMC_DigitalCamSwitch_HighPrecision 以高时间分辨率控制数字输出。以 Beckhoff 的 EL2258 和 EL2252 终端为例。 示例中未包含 Beckhoff 的设备描述。您可以直接从供应商处下载这些文件并将其安装到设备存储库中。要运行该示例，你需要一个 EK1100 总线耦合器、一个 EL2258 终端和一个 EL...", 
"body" : "这个例子 BasicMotion_DigitalCamSwitch_HighPrecision.project 位于安装目录中 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 此示例说明如何使用的输出 SMC_DigitalCamSwitch_HighPrecision 以高时间分辨率控制数字输出。以 Beckhoff 的 EL2258 和 EL2252 终端为例。 示例中未包含 Beckhoff 的设备描述。您可以直接从供应商处下载这些文件并将其安装到设备存储库中。要运行该示例，你需要一个 EK1100 总线耦合器、一个 EL2258 终端和一个 EL2252 终端 此示例是根据 EL2258 的 0017 修订版和 EL2252 的 0020 修订版开发和测试的。它仅作为一个例子。我们不保证正确性。源代码在使用前必须经过测试。如有必要，必须将其修改为终端的其他版本。 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856510750361", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 使用 MC_DigitalCamSwitch_HighPrecision \/ 应用程序的结构 ", 
"snippet" : "该应用程序包含一个 Main 程序， DigitalCamSwitch_EL2258 和 DigitalCamSwitch_EL2252 功能块，以及带有 EL2258 和 EL2252 输出端子的 EK1100 总线耦合器。 这个 DigitalCamSwitch_EL2258 和 DigitalCamSwitch_EL2252 功能块是示例的重要部分。他们展示了如何使用 Events 的输出 SMC_DigitalCamSwitch_HighPrecision 对数字输出进行编程。应将功能块理解为可以适应其他硬件的示例。...", 
"body" : "该应用程序包含一个 Main 程序， DigitalCamSwitch_EL2258 和 DigitalCamSwitch_EL2252 功能块，以及带有 EL2258 和 EL2252 输出端子的 EK1100 总线耦合器。 这个 DigitalCamSwitch_EL2258 和 DigitalCamSwitch_EL2252 功能块是示例的重要部分。他们展示了如何使用 Events 的输出 SMC_DigitalCamSwitch_HighPrecision 对数字输出进行编程。应将功能块理解为可以适应其他硬件的示例。 " }, 
{ "title" : "DigitalCamSwitch_EL2258 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856513787236", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 使用 MC_DigitalCamSwitch_HighPrecision \/ 应用程序的结构 \/ DigitalCamSwitch_EL2258 ", 
"snippet" : "该功能块的工作原理如下： 该功能块在上升沿处初始化 Enable 输入。 STATE_INIT_0 和 STATE_INIT_1 各州， OutputBufferReset 写入 EL2258 终端的信号然后 aLastEventIds 数组已初始化。每个轨道上次处理的事件的 ID 保存在此数组中。这样可以防止事件多次传输到终端。 初始化后 ( STATE_ACTIVE ），所有曲目依次处理，并对每条轨道执行以下逻辑： 检查 EL2258 终端是否已经接受了最后的命令事件 ( ChannelsIn[channel].OutputOrderFeedback = ChannelsOut[chann...", 
"body" : "该功能块的工作原理如下： 该功能块在上升沿处初始化 Enable 输入。 STATE_INIT_0 和 STATE_INIT_1 各州， OutputBufferReset 写入 EL2258 终端的信号然后 aLastEventIds 数组已初始化。每个轨道上次处理的事件的 ID 保存在此数组中。这样可以防止事件多次传输到终端。 初始化后 ( STATE_ACTIVE ），所有曲目依次处理，并对每条轨道执行以下逻辑： 检查 EL2258 终端是否已经接受了最后的命令事件 ( ChannelsIn[channel].OutputOrderFeedback = ChannelsOut[channel].OutputOrderCounter ）。 循环浏览赛道的所有事件。只有那些事件是 ToggleEventId 大于上次处理的 ID，将进一步考虑。（查询 EventId_GreaterThan(event^.ToggleEventId, aLastEventIds[channel]) ) 参见 “活动顺序注意事项” 部分。 转换 Duration 将事件写入 EtherCAT 时间戳并相应地写入 ChannelsOut[channel].OutputEventState 和 ChannelsOut[channel].OutputEventTime 输出。 在最多 5 个事件后中止处理。 如果发现至少一个事件，则通知终端存在新事件 ( ChannelsOut[channel].OutputOrderCounter := ChannelsOut[channel].OutputOrderCounter + 1 ）。 关于活动顺序的备注 事件由返回 SMC_DigitalCamSwitch_HighPrecision 数组中每条轨道的功能块。这个 SwitchNumber 还有一个 ToggleEventId 将针对每个事件返回。这个 ToggleEventId 是独一无二的，每首曲目都是上升的。 有关更多信息，请参阅： SMC_CAMSWITCH 切换事件 。 在示例中， aLastEventIds[trackNo] 数组存储每首曲目 ToggleEventId 最后一次传输到终端是在之前的函数块调用中。因为 ToggleEventIds 按升序排列，下次调用将确切知道哪些事件仍需要传输。 仍有两个细节需要考虑： 因为不知道在哪里 ToggleEventId 活动开始了， valid 标志保存在中 EventId ID 之外的数据类型。对于 EventId_GreaterThan 对比，这个 valid 相应地考虑了标志。 这个 ToggleEventIds 有 32 位数据类型 UDINT 因此，原则上可能会因运行时间长或开关频率高而溢出。然后，该值从 2^32-1 变回 0。比较函数 EventId_GreaterThan 还考虑了 32 位溢出。 PDO 映射 EL2258 这个 ChannelsOut 和 ChannelsIn 的输出 DigitalCamSwitch_EL2258 功能块连接到 EL2258 终端的相应输入\/输出通道。下图显示了频道 1 的映射。频道 2 类似；仅在访问时才有 ChannelsOut 和 ChannelsIn 索引是 2，而不是 1。 " }, 
{ "title" : "DigitalCamSwitch_EL2252 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434780928", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 使用 MC_DigitalCamSwitch_HighPrecision \/ 应用程序的结构 \/ DigitalCamSwitch_EL2252 ", 
"snippet" : "基本原理等同于 DigitalCamSwitch_EL2258 。区别在于信号的写入方式，因为 EL2252 终端只能对一个活动事件进行编程。 首先，函数块在中初始化 STATE_INIT 。 然后 STATE_CHECK_FOR_EVENT 检查事件是否来自 SMC_DigitalCamSwitch_HighPrecision 功能块处于待处理状态。 如果事件可用，则必须在两个周期内对该事件进行编程： 输出和 EtherCAT 时间戳是在第一个周期中写入的。这个 Activate 输出设置为 0。 在第二个周期中， Activate 输出设置为 3 英寸 STATE_ACTIVATE_EVE...", 
"body" : "基本原理等同于 DigitalCamSwitch_EL2258 。区别在于信号的写入方式，因为 EL2252 终端只能对一个活动事件进行编程。 首先，函数块在中初始化 STATE_INIT 。 然后 STATE_CHECK_FOR_EVENT 检查事件是否来自 SMC_DigitalCamSwitch_HighPrecision 功能块处于待处理状态。 如果事件可用，则必须在两个周期内对该事件进行编程： 输出和 EtherCAT 时间戳是在第一个周期中写入的。这个 Activate 输出设置为 0。 在第二个周期中， Activate 输出设置为 3 英寸 STATE_ACTIVATE_EVENT_IN_EL2252 。这将在终端中激活该事件 在 STATE_WAIT_UNTIL_THE_INPUTS_MATCH_THE_OUTPUTS ，然后系统会等到事件被执行。来自的信号 Feedback 终端的输入用于此目的。 PDO 映射 EL2252 " }, 
{ "title" : "Main ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434889277", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 使用 MC_DigitalCamSwitch_HighPrecision \/ 应用程序的结构 \/ Main ", 
"snippet" : "在主程序中，配置了四台交换机（每条轨道上两台）。这些曲目也有不同的开\/关补偿 OnComp ， OffComp ): 该程序包括必要的功能块调用，用于激活轴的预测并以 180°\/s (*) 的速度持续移动，以及 SMC_DigitalCamSwitch_HighPrecision ， DigitalCamSwitch_EL2258 ，以及 DigitalCamSwitch_EL2252 。在开始运动之前，现场总线必须完全通电。否则无法将事件传输到终端。 (*) 选择持续运动是为了使示例简单明了。但是， SMC_DigitalCamSwitch_HighPrecision 功能块适用于所有类型的...", 
"body" : "在主程序中，配置了四台交换机（每条轨道上两台）。这些曲目也有不同的开\/关补偿 OnComp ， OffComp ): 该程序包括必要的功能块调用，用于激活轴的预测并以 180°\/s (*) 的速度持续移动，以及 SMC_DigitalCamSwitch_HighPrecision ， DigitalCamSwitch_EL2258 ，以及 DigitalCamSwitch_EL2252 。在开始运动之前，现场总线必须完全通电。否则无法将事件传输到终端。 (*) 选择持续运动是为了使示例简单明了。但是， SMC_DigitalCamSwitch_HighPrecision 功能块适用于所有类型的动作。例如，它还提供加速阶段或凸轮期间的精确时间戳 " }, 
{ "title" : "调试 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856511865803", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 使用 MC_DigitalCamSwitch_HighPrecision \/ 调试 ", 
"snippet" : "生成应用程序并将其下载到控制器。 启动应用程序。...", 
"body" : "生成应用程序并将其下载到控制器。 启动应用程序。 " }, 
{ "title" : "导出和导入摄像头 ", 
"url" : "_sm_example_cams_export_import.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 导出和导入摄像头 ", 
"snippet" : "这个 BasicMotion_CamExportAndImport.project 示例项目位于的安装目录中 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 该示例说明如何导出和导入摄像头。...", 
"body" : "这个 BasicMotion_CamExportAndImport.project 示例项目位于的安装目录中 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 该示例说明如何导出和导入摄像头。 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm235085906313629", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 导出和导入摄像头 \/ 应用程序的结构 ", 
"snippet" : "该应用程序包含 PLC_PRG 程序和 CamEditor 凸轮。 PLC_PRG 该程序由一个简单的状态机组成，其中一个凸轮是在 IEC 代码中创建的 STATE_CREATE_CAM 州。有关更多信息，请参阅以下内容： 通过编程创建凸轮。 然后将此摄像头导出到 STATE_EXPORT_CAM 状态使用 smc_WriteCam 功能块然后导入到 STATE_START_IMPORT_CAM 状态使用 smc_ReadCam 功能块。 CamEditor 凸轮起初没有任何意义，因为它没有在应用程序中使用。导出的摄像头来自 PLC_PRG 可以导入到摄像头编辑器中。这是一个手动步骤，将在下一...", 
"body" : "该应用程序包含 PLC_PRG 程序和 CamEditor 凸轮。 PLC_PRG 该程序由一个简单的状态机组成，其中一个凸轮是在 IEC 代码中创建的 STATE_CREATE_CAM 州。有关更多信息，请参阅以下内容： 通过编程创建凸轮。 然后将此摄像头导出到 STATE_EXPORT_CAM 状态使用 smc_WriteCam 功能块然后导入到 STATE_START_IMPORT_CAM 状态使用 smc_ReadCam 功能块。 CamEditor 凸轮起初没有任何意义，因为它没有在应用程序中使用。导出的摄像头来自 PLC_PRG 可以导入到摄像头编辑器中。这是一个手动步骤，将在下一节中介绍。 " }, 
{ "title" : "调试 ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm23508590648994", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 凸轮 \/ 导出和导入摄像头 \/ 调试 ", 
"snippet" : "生成应用程序并将其下载到控制器。 启动应用程序。 这个 PLC_PRG 程序生成摄像头并将其导出到 PlcLogic 控制器的目录。 您也可以在凸轮编辑器中显示和编辑导出的凸轮。为此，请打开 CamEditor cam 并使用 cam 导入摄像头 读取凸轮在线文件 命令。 进行更改后，可以使用导出修改后的摄像头 写入凸轮在线文件 命令。该摄像头可以通过以下方式读入 IEC 代码 SMC_ReadCAM 功能块并在应用程序中使用。...", 
"body" : "生成应用程序并将其下载到控制器。 启动应用程序。 这个 PLC_PRG 程序生成摄像头并将其导出到 PlcLogic 控制器的目录。 您也可以在凸轮编辑器中显示和编辑导出的凸轮。为此，请打开 CamEditor cam 并使用 cam 导入摄像头 读取凸轮在线文件 命令。 进行更改后，可以使用导出修改后的摄像头 写入凸轮在线文件 命令。该摄像头可以通过以下方式读入 IEC 代码 SMC_ReadCAM 功能块并在应用程序中使用。 " }, 
{ "title" : "SoftMotion 轴的速度覆盖 ", 
"url" : "_sm_example_override.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ SoftMotion 轴的速度覆盖 ", 
"snippet" : "这 BasicMotion_Override.project 这里描述的示例项目位于安装目录中 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 此示例显示如何定义 SoftMotion 轴的速度覆盖。 有关覆盖的更多信息，请参阅： 使用 MC_SetOverride 进行动态调整...", 
"body" : "这 BasicMotion_Override.project 这里描述的示例项目位于安装目录中 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 此示例显示如何定义 SoftMotion 轴的速度覆盖。 有关覆盖的更多信息，请参阅： 使用 MC_SetOverride 进行动态调整" }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4552520462032034028650702932", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ SoftMotion 轴的速度覆盖 \/ 应用程序的结构 ", 
"snippet" : "该应用程序包含一个 PLC_PRG 程序和一个 Trace 。 PLC_PRG 该程序由一个简单的状态机组成。在第一种状态下 STATE_POWER ，虚拟轴 Drive 已初始化。在第二种状态下 STATE_COMMAND_MOVEMENT ，速度倍率设置为 0.5，以便轴的运动仅以半速执行。然后使用执行一个运动 MC_MoveAbsolute 到位置 10。功能块中指定的最大速度为 20 单位\/秒。 由于在虚拟轴中设置了速度倍率，因此以最大 10 单位\/秒的速度执行运动。 一旦在位置 5 完成一半的运动，速度倍率就会减小到 0.25 STATE_CHANGE_OVERRIDE 状态。轴减速...", 
"body" : "该应用程序包含一个 PLC_PRG 程序和一个 Trace 。 PLC_PRG 该程序由一个简单的状态机组成。在第一种状态下 STATE_POWER ，虚拟轴 Drive 已初始化。在第二种状态下 STATE_COMMAND_MOVEMENT ，速度倍率设置为 0.5，以便轴的运动仅以半速执行。然后使用执行一个运动 MC_MoveAbsolute 到位置 10。功能块中指定的最大速度为 20 单位\/秒。 由于在虚拟轴中设置了速度倍率，因此以最大 10 单位\/秒的速度执行运动。 一旦在位置 5 完成一半的运动，速度倍率就会减小到 0.25 STATE_CHANGE_OVERRIDE 状态。轴减速至 5 单位\/秒，并以此速度执行其余的运动。 虚拟轴的有效倍率系数（速度、加速度和加加速度）也会在程序中读取。这 SMC_GetOverride 功能块用于此目的。 痕迹 轨迹可用于跟踪虚拟轴的运动。记录轴的当前指定位置、速度和加速度以及活动速度倍率。 " }, 
{ "title" : "调试 ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4563439233780834028650966211", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ SoftMotion 轴的速度覆盖 \/ 调试 ", 
"snippet" : "构建应用程序并将其下载到控制器。 启动跟踪和应用程序。 在轨迹中，您可以跟踪虚拟轴的运动。...", 
"body" : "构建应用程序并将其下载到控制器。 启动跟踪和应用程序。 在轨迹中，您可以跟踪虚拟轴的运动。 " }, 
{ "title" : "基于距离的坡度 ", 
"url" : "_sm_axis_based_ramp_in.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 基于距离的坡度 ", 
"snippet" : "这 BasicMotion_CamIn_StartModes.project 此处描述的示例项目位于 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 目录。 此示例说明如何使用 StartMode 输入 MC_CamIn 功能块。此输入用于配置从轴如何与主轴同步，当 MC_CamIn 已开始。 基本上，有三种可能的方法： 从动轴立即跟随凸轮和主轴指定的轨迹。根据从动轴的启动状态，这可能导致从动轴的位置、速度和\/或加速度发生跳跃。 StartMode ： absolute ， relative 从属轴尽快同步，同时保持预定义的速度、加速度、减速度和冲击限值。...", 
"body" : "这 BasicMotion_CamIn_StartModes.project 此处描述的示例项目位于 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 目录。 此示例说明如何使用 StartMode 输入 MC_CamIn 功能块。此输入用于配置从轴如何与主轴同步，当 MC_CamIn 已开始。 基本上，有三种可能的方法： 从动轴立即跟随凸轮和主轴指定的轨迹。根据从动轴的启动状态，这可能导致从动轴的位置、速度和\/或加速度发生跳跃。 StartMode ： absolute ， relative 从属轴尽快同步，同时保持预定义的速度、加速度、减速度和冲击限值。 StartMode ： ramp_in ， ramp_in_pos ， ramp_in_neg 凸轮中指定了主位置，从轴应遵循凸轮和主轴指定的轨迹。同步发生在与主轴的可配置距离上。 StartMode ： ramp_in_dist 有关 MC_CamIn 功能块的更多信息，请参见： MC_CamIn (FB) " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4561064201451234280796827706", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 基于距离的坡度 \/ 应用程序的结构 ", 
"snippet" : "该应用程序包括一个 PLC_PRG 程序和跟踪。此外，还有四个虚拟轴：主轴 Master 和三个从动轴 SlaveAbsolute ， SlaveRampIn ， 和 SlaveRampInDist .还有摄像头 Cam 。 在里面 PLC_PRG 程序，三个实例 MC_CamIn 执行时 StartMode input 设置不同： ciSlaveAbsolute 和 StartMode = absolute ciSlaveRampIn 和 StartMode = ramp_in ciSlaveRampInDist 和 StartMode = ramp_in_dist 功能块实例控制相应的虚拟...", 
"body" : "该应用程序包括一个 PLC_PRG 程序和跟踪。此外，还有四个虚拟轴：主轴 Master 和三个从动轴 SlaveAbsolute ， SlaveRampIn ， 和 SlaveRampInDist .还有摄像头 Cam 。 在里面 PLC_PRG 程序，三个实例 MC_CamIn 执行时 StartMode input 设置不同： ciSlaveAbsolute 和 StartMode = absolute ciSlaveRampIn 和 StartMode = ramp_in ciSlaveRampInDist 和 StartMode = ramp_in_dist 功能块实例控制相应的虚拟轴 SlaveAbsolute ， SlaveRampIn ， 和 SlaveRampInDist 主轴以恒定速度移动，使用 MC_MoveVelocity 实例。 三个从动轴的轨迹和 Active 和 InSync 产出 MC_CamIn 可以在跟踪中追踪实例。 全部 MC_CamIn 当主轴超过位置 40 时启动实例： 这 SlaveAbsolute 轴立即跳转到凸轮定义的设定值。相应的 MC_CamIn 实例立即 Active 和 InSync 。 这 SlaveRampIn 轴同步，同时保持命令的动态限制。相应的 MC_CamIn 实例立即 Active . 从主位置 ~114 ，从轴按照凸轮和主轴指定的轨迹运动， MC_CamIn 实例报告 InSync 。 这 SlaveRampInDist 轴首先保持静止，直到主轴接近 MasterSyncPosition 120 至 MasterStartDistance 共 60 个配置 MC_CamIn instance 。然后同步开始，并且 MC_CamIn 实例报告 Active . 当主轴到达 MasterSyncPosition 的 120 ，从轴按照凸轮和主轴指定的轨迹运动， MC_CamIn 实例报告 InSync 。 " }, 
{ "title" : "调试 ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4602846053456034280814845985", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例子 \/ 基于距离的坡度 \/ 调试 ", 
"snippet" : "构建应用程序并将其下载到控制器。 启动跟踪和应用程序。 在跟踪中，您可以追踪虚拟轴的移动。...", 
"body" : "构建应用程序并将其下载到控制器。 启动跟踪和应用程序。 在跟踪中，您可以追踪虚拟轴的移动。 " }, 
{ "title" : "用户界面 ", 
"url" : "_sm_basic_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 用户界面 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "凸轮 ", 
"url" : "_sm_basic_user_interface_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 用户界面 \/ 凸轮 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "属性 – 凸轮 对话 ", 
"url" : "_sm_dlg_properties_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 用户界面 \/ 凸轮 \/ 属性 – 凸轮 对话 ", 
"snippet" : "功能 ：使用此对话框定义凸轮的全局变量。 方面 主开始\/结束位置 主站的开始和结束位置定义了主站值的范围，因此也定义了凸轮水平轴的刻度。默认设置以角度为单位，以 0 和 360 作为限制值。 从站开始\/结束位置 关联的从位置由为凸轮定义的图形类型确定。然而，曲线描绘的段（这也是垂直轴的比例）可以由此处给出的从站的开始和结束位置定义。 时期 这些设置会影响凸轮编辑器和凸轮表中的工作。根据这些参数，当终点发生变化时，从动起点会自动调整，反之亦然。此调整可优化周期过渡，使其尽可能平稳无抖动。 平稳过渡 ：位置、速度和加速度的值会自动调整。 奴隶时期 指示从属周期何时机械重复。那么主周期开始和结束的从...", 
"body" : "功能 ：使用此对话框定义凸轮的全局变量。 方面 主开始\/结束位置 主站的开始和结束位置定义了主站值的范围，因此也定义了凸轮水平轴的刻度。默认设置以角度为单位，以 0 和 360 作为限制值。 从站开始\/结束位置 关联的从位置由为凸轮定义的图形类型确定。然而，曲线描绘的段（这也是垂直轴的比例）可以由此处给出的从站的开始和结束位置定义。 时期 这些设置会影响凸轮编辑器和凸轮表中的工作。根据这些参数，当终点发生变化时，从动起点会自动调整，反之亦然。此调整可优化周期过渡，使其尽可能平稳无抖动。 平稳过渡 ：位置、速度和加速度的值会自动调整。 奴隶时期 指示从属周期何时机械重复。那么主周期开始和结束的从位置可能会偏离该值的一个整数倍。 此值仅在以下情况下有效 平稳过渡 复选框被选中。 连续性要求 在编辑凸轮时，激活这些曲线连续性选项不会产生任何影响。但是，它会提示连续性检查，并将任何违规行为报告给消息视图 ( 计算机辅助制造 类别）。无法编辑位置曲线中的跳跃。默认设置还要求速度和加速度连续。您可以清除这些选项，例如在仅由线性段组成的曲线的特殊情况下。但是，这可能会导致位置曲线中断。默认情况下，不会对跳跃进行加加速度（四阶导数）测试。 位置 ：检查曲线是否有跳跃。 速度 加速 混蛋 编译格式 编译时， MC_CAM_REF 结构变量生成。根据以下选项描述凸轮： 多项式 (XYVA) 单个点的多项式描述，包括主位置、从位置、从速度和从加速度。 一维点阵 从站位置一维表 二维点阵 复合主\/从位置的二维表 元素 一维或二维点数组的元素数量。此数组已在中创建 SM3_Basic 对于标准案例 128 和 256 。如果您键入另一个值，则需要在应用程序中创建结构。有关此问题，请参阅以下示例。 细分市场 标准编译格式；支持所有段类型 包含 720 个元素的数组示例 TYPE SMC_CAMTable_LREAL_720_2 :\nSTRUCT\n Table: ARRAY[0..719] OF ARRAY[0..1] OF LREAL;\n fEditorMasterMin, fEditorMasterMax: REAL;\n fEditorSlaveMin, fEditorSlaveMax: REAL;\n fTableMasterMin, fTableMasterMax: REAL;\n fTableSlaveMin, fTableSlaveMax: REAL;\nEND_STRUCT\nEND_TYPE 有关更多信息，请参阅： 如何创建凸轮" }, 
{ "title" : "命令：显示生成的代码 ", 
"url" : "_sm_cmd_cam_display_generated_code.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 用户界面 \/ 凸轮 \/ 命令：显示生成的代码 ", 
"snippet" : "显示生成的代码 功能 : 命令打开 生成的代码 显示所代表凸轮的 IEC 初始化代码的对话框。 称呼 ： 凸轮 菜单 要求 ：凸轮编辑器已打开并显示凸轮。 不显示已生成的代码 细分市场 编译格式。不再需要生成的代码，因为可以使用 CamBuilder API 以更好的方式以编程方式生成摄像头 对话框：生成的代码 示例：IEC 初始化代码 {attribute 'linkalways'} VAR_GLOBAL Cam_A: ARRAY[0..3] OF SMC_CAMXYVA := [ (dX := 0, dY := 0, dV := 0, dA := 0), (dX := 120, dY :=...", 
"body" : "显示生成的代码 功能 : 命令打开 生成的代码 显示所代表凸轮的 IEC 初始化代码的对话框。 称呼 ： 凸轮 菜单 要求 ：凸轮编辑器已打开并显示凸轮。 不显示已生成的代码 细分市场 编译格式。不再需要生成的代码，因为可以使用 CamBuilder API 以更好的方式以编程方式生成摄像头 对话框：生成的代码 示例：IEC 初始化代码 {attribute 'linkalways'}\n\nVAR_GLOBAL\nCam_A: ARRAY[0..3] OF SMC_CAMXYVA := [\n (dX := 0, dY := 0, dV := 0, dA := 0),\n (dX := 120, dY := 120, dV := 1, dA := 0),\n (dX := 240, dY := 240, dV := 1, dA := 0),\n (dX := 360, dY := 360, dV := 0, dA := 0)];\nCam: MC_CAM_REF := (nElements := 4, byType := 3, xStart := 0, xEnd := 360, nTappets := 0, strCAMName := 'Cam', pce := ADR(Cam_A), xPartofLM := TRUE);\nEND_VAR " }, 
{ "title" : "命令：从 ASCII 表中读取凸轮数据 ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 用户界面 \/ 凸轮 \/ 命令：从 ASCII 表中读取凸轮数据 ", 
"snippet" : "从 ASCII 表中读取凸轮数据 功能 : 命令读取一个 ASCII 文件。 称呼 ： 凸轮 菜单 要求 ：凸轮编辑器已打开。 读取时，文件数据被解释为凸轮的 X\/Y 值。这 点数 对话框打开，以便您可以减少插值点的数量。然后将确定的点插入凸轮并显示在编辑器中。 这 将凸轮数据写入 ASCII 表 命令创建一个适当的 TXT 文件。...", 
"body" : "从 ASCII 表中读取凸轮数据 功能 : 命令读取一个 ASCII 文件。 称呼 ： 凸轮 菜单 要求 ：凸轮编辑器已打开。 读取时，文件数据被解释为凸轮的 X\/Y 值。这 点数 对话框打开，以便您可以减少插值点的数量。然后将确定的点插入凸轮并显示在编辑器中。 这 将凸轮数据写入 ASCII 表 命令创建一个适当的 TXT 文件。 " }, 
{ "title" : "点数 对话 ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html#UUID-dc22ffbd-b76b-ca74-a92b-235fbf0143cb_id_d53fe1240e8dd1c0a8640e0032565c_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 用户界面 \/ 凸轮 \/ 命令：从 ASCII 表中读取凸轮数据 \/ 点数 对话 ", 
"snippet" : "点数 用于插值的点数。 预设：根据读取文件中存储的 X\/Y 值的数量。例子： 256 您可以减小预设值以确定具有较少插补点的凸轮。在确定插值点时，它们的 X 值等距分布。 由于使用 5 次多项式对凸轮进行插补，因此大量的插补点可能会导致振荡。...", 
"body" : "点数 用于插值的点数。 预设：根据读取文件中存储的 X\/Y 值的数量。例子： 256 您可以减小预设值以确定具有较少插补点的凸轮。在确定插值点时，它们的 X 值等距分布。 由于使用 5 次多项式对凸轮进行插补，因此大量的插补点可能会导致振荡。 " }, 
{ "title" : "命令：将凸轮数据写入 ASCII 表 ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 用户界面 \/ 凸轮 \/ 命令：将凸轮数据写入 ASCII 表 ", 
"snippet" : "将凸轮数据写入 ASCII 表 功能 : 该命令创建一个 ASCII 文件 （ TXT 扩展）在开发系统上。活动凸轮的指定数量的 X\/Y 值保存在此文件中。默认对话框首先打开，然后 点数 对话。 称呼 ： 凸轮 菜单 要求 ：凸轮编辑器已打开并显示凸轮。...", 
"body" : "将凸轮数据写入 ASCII 表 功能 : 该命令创建一个 ASCII 文件 （ TXT 扩展）在开发系统上。活动凸轮的指定数量的 X\/Y 值保存在此文件中。默认对话框首先打开，然后 点数 对话。 称呼 ： 凸轮 菜单 要求 ：凸轮编辑器已打开并显示凸轮。 " }, 
{ "title" : "点数 对话 ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html#UUID-b84e5af8-679e-916c-e8a6-2358c4cccb5c_id_c2bdaa8241199e2c0a8640e018c7af7_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 用户界面 \/ 凸轮 \/ 命令：将凸轮数据写入 ASCII 表 \/ 点数 对话 ", 
"snippet" : "ASCII 表不包含有关凸轮的任何信息。 点数 保存在文件中并以曲线形状表示的 X\/Y 值的数量。为此，将 X 曲线等距分割并确定相应的 Y 值。...", 
"body" : "ASCII 表不包含有关凸轮的任何信息。 点数 保存在文件中并以曲线形状表示的 X\/Y 值的数量。为此，将 X 曲线等距分割并确定相应的 Y 值。 " }, 
{ "title" : "命令：读取凸轮在线文件 ", 
"url" : "_sm_cmd_cam_read_online_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 用户界面 \/ 凸轮 \/ 命令：读取凸轮在线文件 ", 
"snippet" : "读取凸轮在线文件 功能 : 该命令读取带有凸轮数据的外部文件。文件扩展名是 CAM .凸轮显示在凸轮编辑器中。 称呼 ： 凸轮 菜单 要求 ：凸轮编辑器已打开。 这 写入凸轮在线文件 命令在中创建一个适当的文件 CAM 格式。...", 
"body" : "读取凸轮在线文件 功能 : 该命令读取带有凸轮数据的外部文件。文件扩展名是 CAM .凸轮显示在凸轮编辑器中。 称呼 ： 凸轮 菜单 要求 ：凸轮编辑器已打开。 这 写入凸轮在线文件 命令在中创建一个适当的文件 CAM 格式。 " }, 
{ "title" : "命令：写入凸轮在线文件 ", 
"url" : "_sm_cmd_cam_write_online_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 用户界面 \/ 凸轮 \/ 命令：写入凸轮在线文件 ", 
"snippet" : "写入凸轮在线文件 功能 : 该命令创建一个文件 ( CAM 延期）。该文件包含在编辑器中处于活动状态的凸轮的数据。 称呼 ： 凸轮 菜单 要求 ：凸轮编辑器已打开并显示凸轮。 凸轮数据由凸轮描述以及凸轮的位置和类型组成。 一种 CAM 文件可以通过编辑器读取 读取凸轮在线文件 命令。 此外，一个实例 SMC_ReadCAM 功能块可以读取文件，以便在运行时将凸轮表加载到应用程序中。 有关详细信息，请参阅：For more information, see: 凸轮的数据结构...", 
"body" : "写入凸轮在线文件 功能 : 该命令创建一个文件 ( CAM 延期）。该文件包含在编辑器中处于活动状态的凸轮的数据。 称呼 ： 凸轮 菜单 要求 ：凸轮编辑器已打开并显示凸轮。 凸轮数据由凸轮描述以及凸轮的位置和类型组成。 一种 CAM 文件可以通过编辑器读取 读取凸轮在线文件 命令。 此外，一个实例 SMC_ReadCAM 功能块可以读取文件，以便在运行时将凸轮表加载到应用程序中。 有关详细信息，请参阅：For more information, see: 凸轮的数据结构" }, 
{ "title" : "CODESYS SoftMotion 数控系统 ", 
"url" : "_sm_f_cnc.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "编辑 ", 
"url" : "_sm_f_cnc_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_sm_overview_cnc_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ 概述 ", 
"snippet" : "在 CNC 编辑器中，您可以根据 DIN 66025 的 CNC 语言在表格编辑器或文本编辑器中实现复杂的多维运动。此外，编辑器还提供以下内容： 用于显示路径的图形编辑器 图形编辑器的工具箱 查看所选路径元素的属性...", 
"body" : "在 CNC 编辑器中，您可以根据 DIN 66025 的 CNC 语言在表格编辑器或文本编辑器中实现复杂的多维运动。此外，编辑器还提供以下内容： 用于显示路径的图形编辑器 图形编辑器的工具箱 查看所选路径元素的属性 " }, 
{ "title" : "CNC 编辑器基础知识 ", 
"url" : "_sm_cnc_edt_basics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ CNC 编辑器基础知识 ", 
"snippet" : "使用 DIN 66025，您最多可以创建 9 维路径。其中三个维度不是线性插值的。在 X\/Y\/Z 中，您可以对直线、圆弧、椭圆、抛物线和样条曲线进行编程。提供了另外八个附加轴。其中，五个是线性插值 (P\/Q\/U\/V\/W)，三个是用 3 次多项式 (A\/B\/C) 插值的。对于 CNC 程序中的每个运动程序段，插补器计算运行路径。同时，插值器根据指定的插值计算路径的形状、速度、加速度和加加速度。对于每条编程路径， CODESYS 使用可在 IEC 程序中使用的 CNC 数据自动创建全局数据结构。 为此目的有不同的选择： SMC_CNC_REF ：CNC 程序保存为 G 代码字数组，在应用程序运行时...", 
"body" : "使用 DIN 66025，您最多可以创建 9 维路径。其中三个维度不是线性插值的。在 X\/Y\/Z 中，您可以对直线、圆弧、椭圆、抛物线和样条曲线进行编程。提供了另外八个附加轴。其中，五个是线性插值 (P\/Q\/U\/V\/W)，三个是用 3 次多项式 (A\/B\/C) 插值的。对于 CNC 程序中的每个运动程序段，插补器计算运行路径。同时，插值器根据指定的插值计算路径的形状、速度、加速度和加加速度。对于每条编程路径， CODESYS 使用可在 IEC 程序中使用的 CNC 数据自动创建全局数据结构。 为此目的有不同的选择： SMC_CNC_REF ：CNC 程序保存为 G 代码字数组，在应用程序运行时通过以下方式进行处理： SMC_NCInterpreter 。结果是被描述为一系列 GEOINFO 结构对象的 CNC 路径。通过 SM3_CNC 库中的路径预处理模块（例如：刀具半径校正），可以对这些对象进行编辑、插值、转换以及从驱动器接口传输到硬件以进行通信。 SMC_OUTQUEUE ：CNC 程序作为 GEOINFO 结构对象列表写入数据结构，其名称为 SMC_OUTQUEUE ，然后可以将其直接输入到插值器中。结果，与 SMC_CNC_REF ，不必调用解释器功能块和路径预处理功能块。然而，程序不能在运行时更改，并且在此模式下不能使用 G 代码中的变量。 FILE ：然后将CNC程序作为ASCII文件保存在控制器的文件系统中，逐步读取并执行。这种方法特别适用于不能完全存储在内存中的大型程序。它也适用于用户在编译控制器应用程序后生成的程序。 " }, 
{ "title" : "CNC 编辑器的结构 ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_43423fe2e9a24fa0c0a864632228473f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ CNC 编辑器基础知识 \/ CNC 编辑器的结构 ", 
"snippet" : "CNC 编辑器由以下组件组成： 主编辑器：文本编辑器显示 DIN 66025 程序，或表格编辑器显示 CNC 路径。 图形编辑器：此处显示路径的图形视图。 特性 CNC 元件视图 工具箱 视图：包含用于选择和插入路径元素的工具 当您按下 F6 键，焦点在主编辑器和图形编辑器之间切换。如果在图形编辑器中选择了路径元素，则在文本编辑器或表格编辑器中隐式选择相应的运动块或线。同样，在表格编辑器或文本编辑器中选择的元素也会在图形编辑器中选择。图形编辑器中的更改应用于文本编辑器或表格编辑器，反之亦然。 应用程序范围的 CNC 设置被应用并保存在 数控设置 目的。 对象特定的 CNC 设置被应用并保存在 ...", 
"body" : "CNC 编辑器由以下组件组成： 主编辑器：文本编辑器显示 DIN 66025 程序，或表格编辑器显示 CNC 路径。 图形编辑器：此处显示路径的图形视图。 特性 CNC 元件视图 工具箱 视图：包含用于选择和插入路径元素的工具 当您按下 F6 键，焦点在主编辑器和图形编辑器之间切换。如果在图形编辑器中选择了路径元素，则在文本编辑器或表格编辑器中隐式选择相应的运动块或线。同样，在表格编辑器或文本编辑器中选择的元素也会在图形编辑器中选择。图形编辑器中的更改应用于文本编辑器或表格编辑器，反之亦然。 应用程序范围的 CNC 设置被应用并保存在 数控设置 目的。 对象特定的 CNC 设置被应用并保存在 特性 CNC 对象的对话框。 " }, 
{ "title" : "CNC 编辑器的 SoftMotion 软件组件 ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_92f7df24e9a24fa0c0a864630c4c4560", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ CNC 编辑器基础知识 \/ CNC 编辑器的 SoftMotion 软件组件 ", 
"snippet" : "(1)数控编辑器 (2) IEC程序 (3) 参数 (4) 翻译人员 (5) 地理资讯 (6) 路径预处理 (7) 插值器 (8) 路径点 (9) 笛卡尔坐标 (10) 直接运动学 (11) 特定于机器的转换 (12) 反向运动学 (13) 轴位置 (14) 驱动接口...", 
"body" : "(1)数控编辑器 (2) IEC程序 (3) 参数 (4) 翻译人员 (5) 地理资讯 (6) 路径预处理 (7) 插值器 (8) 路径点 (9) 笛卡尔坐标 (10) 直接运动学 (11) 特定于机器的转换 (12) 反向运动学 (13) 轴位置 (14) 驱动接口 " }, 
{ "title" : "编译 CNC 对象 ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_c0635f14eddc9007c0a8646316c80481", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ CNC 编辑器基础知识 \/ 编译 CNC 对象 ", 
"snippet" : "这 编译模式 添加新 CNC 对象时选择，如有必要，可在 特性 对话框 ( 数控 CNC 对象的选项卡）。取决于 编译模式 ， 一个 SMC_OutQueue 功能块， SMC_CNC_REF 功能块或具有编程 CNC 路径的 ASCII 文件在编译时创建。 如果 从构建中排除 选项被选中 特性 上的对话框 建造 CNC 对象的选项卡，则不会生成 IEC 数据。在编译模式下 文件 ，没有数据下载到控制器。...", 
"body" : "这 编译模式 添加新 CNC 对象时选择，如有必要，可在 特性 对话框 ( 数控 CNC 对象的选项卡）。取决于 编译模式 ， 一个 SMC_OutQueue 功能块， SMC_CNC_REF 功能块或具有编程 CNC 路径的 ASCII 文件在编译时创建。 如果 从构建中排除 选项被选中 特性 上的对话框 建造 CNC 对象的选项卡，则不会生成 IEC 数据。在编译模式下 文件 ，没有数据下载到控制器。 " }, 
{ "title" : "打开一个 CoDeSys V2.3 项目 ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_88cb0aeee9a24fa0c0a864634f00b359", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ CNC 编辑器基础知识 \/ 打开一个 CoDeSys V2.3 项目 ", 
"snippet" : "当你打开一个 CoDeSys V2.3 项目在 CODESYS ，只要使用 SoftMotion 控制器，就会提供一个转换器来执行以下功能： 每个 CNC 程序都被转换成一个具有相同名称和执行类型 DIN 66025 的 CNC 对象。转换后的程序的编译模式、队列大小和开始位置也被用作步抑制的状态。 如果 从构建中排除 在 CNC 程序中选择选项 CoDeSys V2.3 项目，则接受此选项。 这 数控设置 对象是自动生成的。 所有 CNC 对象都列在支持 SoftMotion 的应用程序下方。...", 
"body" : "当你打开一个 CoDeSys V2.3 项目在 CODESYS ，只要使用 SoftMotion 控制器，就会提供一个转换器来执行以下功能： 每个 CNC 程序都被转换成一个具有相同名称和执行类型 DIN 66025 的 CNC 对象。转换后的程序的编译模式、队列大小和开始位置也被用作步抑制的状态。 如果 从构建中排除 在 CNC 程序中选择选项 CoDeSys V2.3 项目，则接受此选项。 这 数控设置 对象是自动生成的。 所有 CNC 对象都列在支持 SoftMotion 的应用程序下方。 " }, 
{ "title" : "创建 CNC 程序 ", 
"url" : "_sm_cnc_creating_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ 创建 CNC 程序 ", 
"snippet" : "在设备树中选择一个应用程序。 点击 项目 → 添加对象 → CNC 程序 . 在中指定名称 添加数控程序 对话框并选择一个 执行 从列表框中： DIN 66025 ：在文本编辑器中创建程序 桌子 ：在表格编辑器中创建程序 选择一个 编译模式 确定编译时的行为： SMC_OutQueue ：在编译时生成一个 SMC_OutQueue 数据结构。通过以下方式授予您全局访问权限 g_CNCQueueManager (SMC_OutQueue)。 SMC_CNC_REF ：程序变量在编译时生成。通过以下方式授予您全局访问权限 g_CNCProgManager (SMC-CNC_REF) 在 IEC 程...", 
"body" : "在设备树中选择一个应用程序。 点击 项目 → 添加对象 → CNC 程序 . 在中指定名称 添加数控程序 对话框并选择一个 执行 从列表框中： DIN 66025 ：在文本编辑器中创建程序 桌子 ：在表格编辑器中创建程序 选择一个 编译模式 确定编译时的行为： SMC_OutQueue ：在编译时生成一个 SMC_OutQueue 数据结构。通过以下方式授予您全局访问权限 g_CNCQueueManager (SMC_OutQueue)。 SMC_CNC_REF ：程序变量在编译时生成。通过以下方式授予您全局访问权限 g_CNCProgManager (SMC-CNC_REF) 在 IEC 程序中。 文件 ：每次登录时下载并更新由 G 代码生成的文件。 PLC 可以通过功能块下载该文件。 您可以更改 执行 和 编译模式 后来在 特性 对话框 ( 数控 CNC 程序的选项卡）。 点击 添加 . CNC 对象被插入设备树并在编辑器中打开。 " }, 
{ "title" : "根据 DIN 66025 编程路径 ", 
"url" : "_sm_cnc_programming_din_66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ 根据 DIN 66025 编程路径 ", 
"snippet" : "SoftMotion 支持部分 CNC 语言 DIN 66025，允许在 CNC 对象的编辑器中对几何路径进行编程。 这 DIN 66025 编辑器 CNC 对象的名称（也：CNC 文本编辑器）用于以 DIN 66025 CNC 语言进行编程。 要求：一个 数控程序 对象打开 DIN 66025 执行。 将光标置于空白行。 在编辑器中逐行输入 G 代码块。 当您输入一个块时（例如： N10 G01 X100 Y100 E100 F100 E-200 )，路径元素立即显示在图形编辑器中。 在这里，您可以使用操作域来更改不同轴上的视图和视图方向。 如果您在图形编辑器中选择路径元素，则其属性将显示在...", 
"body" : "SoftMotion 支持部分 CNC 语言 DIN 66025，允许在 CNC 对象的编辑器中对几何路径进行编程。 这 DIN 66025 编辑器 CNC 对象的名称（也：CNC 文本编辑器）用于以 DIN 66025 CNC 语言进行编程。 要求：一个 数控程序 对象打开 DIN 66025 执行。 将光标置于空白行。 在编辑器中逐行输入 G 代码块。 当您输入一个块时（例如： N10 G01 X100 Y100 E100 F100 E-200 )，路径元素立即显示在图形编辑器中。 在这里，您可以使用操作域来更改不同轴上的视图和视图方向。 如果您在图形编辑器中选择路径元素，则其属性将显示在 特性 看法。 有关更多信息，请参阅： DIN 66025 基础" }, 
{ "title" : "在表格编辑器中编程路径 ", 
"url" : "_sm_cnc_programming_table_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ 在表格编辑器中编程路径 ", 
"snippet" : "要求：一个 数控程序 对象是用 桌子 实现，并且对象在 表格编辑器 ....", 
"body" : "要求：一个 数控程序 对象是用 桌子 实现，并且对象在 表格编辑器 . " }, 
{ "title" : "插入元素 ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f56fa52f4ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ 在表格编辑器中编程路径 \/ 插入元素 ", 
"snippet" : "双击 空的 细胞中的 类型 柱子。从列表框中选择一个元素，然后按 进入 钥匙。 如果它是表中的第一个元素，则使用元素的初始值填充字段。否则，该元素从前一行的元素接收值。 所有其他字段保持灰色阴影，并且元素显示在图形编辑器中。 表格的最后一行是空行，类型为 空的 . 要添加其他元素，您也可以单击 插入元素 命令在表条目的上下文菜单中。...", 
"body" : "双击 空的 细胞中的 类型 柱子。从列表框中选择一个元素，然后按 进入 钥匙。 如果它是表中的第一个元素，则使用元素的初始值填充字段。否则，该元素从前一行的元素接收值。 所有其他字段保持灰色阴影，并且元素显示在图形编辑器中。 表格的最后一行是空行，类型为 空的 . 要添加其他元素，您也可以单击 插入元素 命令在表条目的上下文菜单中。 " }, 
{ "title" : "更改表条目 ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f568c7504ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ 在表格编辑器中编程路径 \/ 更改表条目 ", 
"snippet" : "双击元素的表条目。 该字段是可编辑的或有 列表框的符号。 该元素在图形编辑器中标记为红色。 更改表条目的值。 更改显示在图形编辑器中。 如果单击命令 将值应用于所有元素 在表条目的上下文菜单中，当前值将应用于同一列的所有其他条目。要求：该值可用于相应的元素类型。 无法编辑行号。...", 
"body" : "双击元素的表条目。 该字段是可编辑的或有 列表框的符号。 该元素在图形编辑器中标记为红色。 更改表条目的值。 更改显示在图形编辑器中。 如果单击命令 将值应用于所有元素 在表条目的上下文菜单中，当前值将应用于同一列的所有其他条目。要求：该值可用于相应的元素类型。 无法编辑行号。 " }, 
{ "title" : "删除元素 ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f0684d0502561eafc0a864633d0e8542", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ 在表格编辑器中编程路径 \/ 删除元素 ", 
"snippet" : "选择表格的一行并单击命令 移除元素 在上下文菜单中。 表格的最后一行，类型为 空的 无法删除。...", 
"body" : "选择表格的一行并单击命令 移除元素 在上下文菜单中。 表格的最后一行，类型为 空的 无法删除。 " }, 
{ "title" : "CNC 数据结构和全局访问 ", 
"url" : "_sm_cnc_data_structure_global_access.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ CNC 数据结构和全局访问 ", 
"snippet" : "项目中可用的 CNC 对象编译为类型的功能块 SMC_OUTQUEUE 或者 SMC_CNC_REF . （编译方法时不会发生这种情况 文件 用来。） 编译项目时，创建的 CNC 数据在内部管理 SMC_CNC_Data 功能块。对于编译模式 SMC_OutQueue , 每个 CNC 元素由一个表示 SMC_OUTQUEUE 功能块。对于编译模式 SMC_CNC_REF , CNC 元素表示为 SMC_CNC_REF .在处理 IEC 程序的同时，功能块被实例化并填充有可以在 IEC 程序中处理的值。所有这些 POU 都包含在 SM3_CNC ....", 
"body" : "项目中可用的 CNC 对象编译为类型的功能块 SMC_OUTQUEUE 或者 SMC_CNC_REF . （编译方法时不会发生这种情况 文件 用来。） 编译项目时，创建的 CNC 数据在内部管理 SMC_CNC_Data 功能块。对于编译模式 SMC_OutQueue , 每个 CNC 元素由一个表示 SMC_OUTQUEUE 功能块。对于编译模式 SMC_CNC_REF , CNC 元素表示为 SMC_CNC_REF .在处理 IEC 程序的同时，功能块被实例化并填充有可以在 IEC 程序中处理的值。所有这些 POU 都包含在 SM3_CNC . " }, 
{ "title" : "全球访问 CNC 数据 ", 
"url" : "_sm_cnc_data_structure_global_access.html#UUID-aaee586d-72f4-405c-8bb5-b4b2cb32f52d_id_cb8536efda52bb5c0a8646375871841_id_4fd460ed02599820c0a864633ab223de", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 编辑 \/ CNC 数据结构和全局访问 \/ 全球访问 CNC 数据 ", 
"snippet" : "在初始化期间，生成对象的类型和数量由 CNC 程序确定。所有这些对象都列在隐式声明的全局数据结构中。类型的对象 SMC_OUTQUEUE 列在全局数据对象中 g_CNCQueueManager 与财产 Count 和方法 GetOutQueue(int n) .类型的对象 SMC_CNC_REF 列在全局数据对象中 g_CNCProgManager 与财产 Count 和方法 GetProgram(int n) .用户现在可以在 IEC 程序中访问它。 例子 访问结构的数据对象 SMC_OUTQUEUE PROGRAM CNCManageQueue VAR pCNC_OutQueue : PO...", 
"body" : "在初始化期间，生成对象的类型和数量由 CNC 程序确定。所有这些对象都列在隐式声明的全局数据结构中。类型的对象 SMC_OUTQUEUE 列在全局数据对象中 g_CNCQueueManager 与财产 Count 和方法 GetOutQueue(int n) .类型的对象 SMC_CNC_REF 列在全局数据对象中 g_CNCProgManager 与财产 Count 和方法 GetProgram(int n) .用户现在可以在 IEC 程序中访问它。 例子 访问结构的数据对象 SMC_OUTQUEUE PROGRAM CNCManageQueue\nVAR\n pCNC_OutQueue : POINTER TO SMC_OUTQUEUE;\n n: INT;\n i: INT;\nEND_VAR\n\nn := g_CNCQueueManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_OutQueue := g_CNCQueueManager.GetOutQueue(I);\n (* calculate pCNC_OutQueue *)\nEND_FOR 访问结构的数据对象 SMC_CNC_REF PROGRAM CNCManageRef\nVAR\n pCNC_Ref: POINTER TO SMC_CNC_REF;\n n: INT;\nEND_VAR\n\nn := g_CNCProgManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_Ref := g_CNCProgManager.GetProgram(I);\n (* calculate pCNC_Ref *)\nEND_FOR " }, 
{ "title" : "运动学变换 ", 
"url" : "_sm_f_cnc_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "正向和逆变换 ", 
"url" : "_sm_cnc_forward_backward_transformation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 正向和逆变换 ", 
"snippet" : "CODESYS SoftMotion 为许多流行运动学的数学正向和逆变换提供功能块。 对于每个运动学设计，有两个功能块可用于转换。 POU 命名 SMC_TRAFO_<kinematics> 根据空间位置计算轴位置（逆变换）。 POU 命名 SMC_TRAFOF_<kinematics> 根据轴位置计算空间位置（正向变换）。 您可以快速轻松地将正向变换 POU 的实例链接到可视化模板，以可视化运动学。 SMC_TRAFOV_ 一些逆变换还使用路径速度和路径方向来计算轴速度。这些转换 POU 的名称以 SMC_TRAFOV_ 代替 SMC_TRAFO_ .这些 POU 获得路径切线 ( v ) ...", 
"body" : "CODESYS SoftMotion 为许多流行运动学的数学正向和逆变换提供功能块。 对于每个运动学设计，有两个功能块可用于转换。 POU 命名 SMC_TRAFO_<kinematics> 根据空间位置计算轴位置（逆变换）。 POU 命名 SMC_TRAFOF_<kinematics> 根据轴位置计算空间位置（正向变换）。 您可以快速轻松地将正向变换 POU 的实例链接到可视化模板，以可视化运动学。 SMC_TRAFOV_ 一些逆变换还使用路径速度和路径方向来计算轴速度。这些转换 POU 的名称以 SMC_TRAFOV_ 代替 SMC_TRAFO_ .这些 POU 获得路径切线 ( v ) 和路径速度 ( dVel ) 作为来自插值器的附加输入。他们还返回设定的速度（ dvx\/dvy\/dvz ) 除了设置的位置。优点是驱动器的滞后可以通过速度的输入控制来最小化，只要驱动器支持这种方法。要将设定的速度传输到驱动器，您应该使用 SMC_ControlAxisByPosVel 代替 SMC_ControlAxisByPos 在这种情况下。 有关更多信息，请参阅： SMC_ControlAxisByPos (FB) , SMC_ControlAxisByVel (FB) ， 和 SMC_ControlAxisByPosVel (FB) " }, 
{ "title" : "五轴变换 ", 
"url" : "_sm_trafo_pou_five_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 五轴变换 ", 
"snippet" : "通过 5 轴变换，您可以控制由三个线性空间轴（X、Y、Z）和一个刀头组成的运动学。工具头由两个固定工具的轴组成。一个刀具轴围绕 Z 轴旋转，刀具根据以下方案倾斜其他轴。 参数：长度 dTool = 从加工点（刀尖 = TCP）到回转轴倾角的距离。 通过五个位置值控制 5 轴变换： 处理点 (TCP) 的 X\/Y\/Z 位置包含在 pi.dX, pi.dY, pi.dZ .单位：轴的位置单位。 通过包含在 pi.dB 和 pi.dC .单位：角度。 零位 处理点 (TCP) 位于 ( 0\/0\/-dTool ）。 刀具沿负 Z 轴方向延伸。旋转轴倾角的定位方式是，沿正方向旋转会使刀具沿 X 轴正方向...", 
"body" : "通过 5 轴变换，您可以控制由三个线性空间轴（X、Y、Z）和一个刀头组成的运动学。工具头由两个固定工具的轴组成。一个刀具轴围绕 Z 轴旋转，刀具根据以下方案倾斜其他轴。 参数：长度 dTool = 从加工点（刀尖 = TCP）到回转轴倾角的距离。 通过五个位置值控制 5 轴变换： 处理点 (TCP) 的 X\/Y\/Z 位置包含在 pi.dX, pi.dY, pi.dZ .单位：轴的位置单位。 通过包含在 pi.dB 和 pi.dC .单位：角度。 零位 处理点 (TCP) 位于 ( 0\/0\/-dTool ）。 刀具沿负 Z 轴方向延伸。旋转轴倾角的定位方式是，沿正方向旋转会使刀具沿 X 轴正方向移动。 例子 对于运动 N30，首先指向 X 方向的倾斜轴旋转，并在运动结束时保持在负 X 方向上倾斜。 N0 PB360 PC360 (set axis B and C in modulo mode 360)\nN10 F10 FB100 FC100 (velocity in X\/Y\/Z: 10, in B and C 100)\nN20 G0 X0 Y0 Z0 C0 B30 (start position)\nN30 G1 X20 B-30 (target position) 有关更多信息，请参阅： SMC_TRAFO_5轴（FB） 和 SMC_TRAFOF_5 轴 (FB) " }, 
{ "title" : "龙门系统 ", 
"url" : "_sm_trafo_pou_gantry_system.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 龙门系统 ", 
"snippet" : "龙门系统由两个或三个直角排列的线性轴组成。 由于在龙门系统中不必执行转换，因此用于反向和正向转换的相应模块仅在二维或三维的 X、Y 和 Z 轴上添加一个偏移量。 有关更多信息，请参阅： MC_TRAFO_Gantry2 (FB) SMC_TRAFOF_Gantry2 (FB) SMC_TRAFO_Gantry3 (FB) SMC_TRAFOF_Gantry3 (FB)...", 
"body" : "龙门系统由两个或三个直角排列的线性轴组成。 由于在龙门系统中不必执行转换，因此用于反向和正向转换的相应模块仅在二维或三维的 X、Y 和 Z 轴上添加一个偏移量。 有关更多信息，请参阅： MC_TRAFO_Gantry2 (FB) SMC_TRAFOF_Gantry2 (FB) SMC_TRAFO_Gantry3 (FB) SMC_TRAFOF_Gantry3 (FB) " }, 
{ "title" : "带方向轴的龙门系统 ", 
"url" : "_sm_trafo_pou_gantry_cutter.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 带方向轴的龙门系统 ", 
"snippet" : "“龙门切割机”是一种龙门系统，具有配备切割工具的旋转轴。 带有旋转轴的龙门系统的配置类似于简单的龙门系统。然而，这些系统也有一个连接垂直切割单元的旋转轴。 当您使用带有旋转轴的龙门系统时，您必须使用 SMC_TRAFO<n>_GantryCutter<n> POU 代替 SMC_TRAFO<n>_Gantry<n> .然后控制旋转轴，使其沿当前路径切线定向。 龙门切割机 POU 具有以下附加输入： DriveR : 必须以 360° 周期使用的旋转轴 dOffsetR : 回转轴的偏移量 iDirectionR : 旋转方向 有关更多信息，请参阅： SMC_TRAFO_GantryCutter...", 
"body" : "“龙门切割机”是一种龙门系统，具有配备切割工具的旋转轴。 带有旋转轴的龙门系统的配置类似于简单的龙门系统。然而，这些系统也有一个连接垂直切割单元的旋转轴。 当您使用带有旋转轴的龙门系统时，您必须使用 SMC_TRAFO<n>_GantryCutter<n> POU 代替 SMC_TRAFO<n>_Gantry<n> .然后控制旋转轴，使其沿当前路径切线定向。 龙门切割机 POU 具有以下附加输入： DriveR : 必须以 360° 周期使用的旋转轴 dOffsetR : 回转轴的偏移量 iDirectionR : 旋转方向 有关更多信息，请参阅： SMC_TRAFO_GantryCutter2 (FB) SMC_TRAFOF_GantryCutter2 (FB) SMC_TRAFO_GantryCutter3 (FB) SMC_TRAFOF_GantryCutter3 (FB) 用于逆变换的 POU 还必须包括作为插值器输出的当前路径切线 (v) 的向量。 有关更多信息，请参阅： SMC_TRAFOV_GantryCutter2 (FB) 和 SMC_TRAFOV_GantryCutter3 (FB) " }, 
{ "title" : "带刀具偏移的龙门系统 ", 
"url" : "_sm_trafo_pou_gantry_system_tool.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 带刀具偏移的龙门系统 ", 
"snippet" : "如果刀具的轴有偏移并且与龙门系统的 Z 轴不重合，则刀具的接触点与龙门系统的 X\/Y\/Z 位置不一致。如果 Z 轴不能旋转，那么得到的 X 和 Y 坐标的偏移量是恒定的，可以直接用于标准龙门变换。 如果刀具沿 C 轴旋转（绕 Z），则偏移量不是恒定的，而是取决于 C 轴的位置。在这种情况下，可以选择两个 POU 之一，具体取决于工具的形式： SMC_TRAFO_Gantry2Tool1 和 SMC_TRAFOF_Gantry2Tool1 沿 X 轴旋转的工具点 dAlpha 并且长度为 dToolA . SMC_TRAFO_Gantry2Tool2 和 SMC_TRAFOF_Gantry2To...", 
"body" : "如果刀具的轴有偏移并且与龙门系统的 Z 轴不重合，则刀具的接触点与龙门系统的 X\/Y\/Z 位置不一致。如果 Z 轴不能旋转，那么得到的 X 和 Y 坐标的偏移量是恒定的，可以直接用于标准龙门变换。 如果刀具沿 C 轴旋转（绕 Z），则偏移量不是恒定的，而是取决于 C 轴的位置。在这种情况下，可以选择两个 POU 之一，具体取决于工具的形式： SMC_TRAFO_Gantry2Tool1 和 SMC_TRAFOF_Gantry2Tool1 沿 X 轴旋转的工具点 dAlpha 并且长度为 dToolA . SMC_TRAFO_Gantry2Tool2 和 SMC_TRAFOF_Gantry2Tool2 刀具部分沿 X 轴方向旋转 dAlpha （长度： dToolA ）和部分在旋转的 Y 轴方向（长度： dToolB ）。 在下例的图中，激光在 X 方向和 Y 方向上都有偏移。 除了执行这种一维变换，还可以使用刀具偏移来调制路径。此时，刀具接近直线。这 SMC_ToolCorr 或者 SMC_ToolRadiusCorr 为此使用功能块。这两种方法的区别在于工具点的速度。如果调制是从 SMC_ToolCorr ，则旋转点的速度根据 CNC 程序中的预设值（F，E）进行控制。工具点的速度可以波动。如果使用一维变换，则刀点的速度由 CNC 程序确定。 为了计算工具的方向， SMC_CalcDirectionFromVector 使用 POU。 " }, 
{ "title" : "带固定轴的 H 型龙门架 ", 
"url" : "_sm_trafo_pou_h_gantry_stationary_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 带固定轴的 H 型龙门架 ", 
"snippet" : "运动学配置类似于龙门系统，但轴（驱动器）安装牢固。他们通过皮带移动工具架。 通过改造 SMC_TRAFO_GantryH2 和 SMC_TRAFOF_GantryH2 POU 需要以下轴配置。其他配置可以通过交换 x 和 y 来执行： 这种转换需要特殊的归位：两个轴必须以相同的速度移动。如果运动应该在 X 方向上，那么驱动器 A 和 B 必须移动，而它们必须以相反的速度移动，以实现严格的 X 运动。仅对于 X 移动，它们必须以相反的速度移动。如果找到归位，则使用从前向变换 POU 计算的 X 和 Y 值作为偏移量 ( dOffsetX 和 dOffsetY ）。...", 
"body" : "运动学配置类似于龙门系统，但轴（驱动器）安装牢固。他们通过皮带移动工具架。 通过改造 SMC_TRAFO_GantryH2 和 SMC_TRAFOF_GantryH2 POU 需要以下轴配置。其他配置可以通过交换 x 和 y 来执行： 这种转换需要特殊的归位：两个轴必须以相同的速度移动。如果运动应该在 X 方向上，那么驱动器 A 和 B 必须移动，而它们必须以相反的速度移动，以实现严格的 X 运动。仅对于 X 移动，它们必须以相反的速度移动。如果找到归位，则使用从前向变换 POU 计算的 X 和 Y 值作为偏移量 ( dOffsetX 和 dOffsetY ）。 " }, 
{ "title" : "带固定轴的 T 型龙门架 ", 
"url" : "_sm_trafo_pou_t_gantry_statinary_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 带固定轴的 T 型龙门架 ", 
"snippet" : "这种运动系统类似于 H 龙门系统。这里的驱动器也是固定安装的，刀架通过皮带移动。 执行的转换 SMC_TRAFO_GantryT2 和 SMC_TRAFOF_GantryT2 POU 专为以下驱动星座而设计： 请注意，此转换需要特殊的归位。 如果您在 X 方向上执行移动，则必须以相同的速度移动 A 和 B 驱动器。如果您严格执行 Y 运动，则驱动器必须沿相反方向旋转。如果驱动器找到归位位置，则使用正向变换 POU 计算的 X 和 Y 值作为偏移量 ( dOffsetX 和 dOffsetY ）。 这 SMC_TRAFO_GantryT2_O 和 SMC_TRAFOF_GantryT2_O 功能...", 
"body" : "这种运动系统类似于 H 龙门系统。这里的驱动器也是固定安装的，刀架通过皮带移动。 执行的转换 SMC_TRAFO_GantryT2 和 SMC_TRAFOF_GantryT2 POU 专为以下驱动星座而设计： 请注意，此转换需要特殊的归位。 如果您在 X 方向上执行移动，则必须以相同的速度移动 A 和 B 驱动器。如果您严格执行 Y 运动，则驱动器必须沿相反方向旋转。如果驱动器找到归位位置，则使用正向变换 POU 计算的 X 和 Y 值作为偏移量 ( dOffsetX 和 dOffsetY ）。 这 SMC_TRAFO_GantryT2_O 和 SMC_TRAFOF_GantryT2_O 功能块使用以下星座执行相同的计算： " }, 
{ "title" : "极地系统 ", 
"url" : "_sm_trafo_pou_polar_system.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 极地系统 ", 
"snippet" : "极坐标系统由旋转轴（方向）和线性轴（距离）组成。 直线轴的原点和方向可以通过偏移来改变 dPhi 和 dR . 有关更多信息，请参阅： SMC_TRAFO_Polar (FB) 和 SMC_TRAFOF_Polar (FB)...", 
"body" : "极坐标系统由旋转轴（方向）和线性轴（距离）组成。 直线轴的原点和方向可以通过偏移来改变 dPhi 和 dR . 有关更多信息，请参阅： SMC_TRAFO_Polar (FB) 和 SMC_TRAFOF_Polar (FB) " }, 
{ "title" : "2 关节 SCARA 系统 ", 
"url" : "_sm_trafo_pou_two_jointed_scara.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 2 关节 SCARA 系统 ", 
"snippet" : "这 选择性合规装配机械臂 （SCARA）是一种类似于人类手臂的特殊类型的工业机器人。 SCARA 系统有两个轴和两个自由度。运动仅限于 X\/Y 平面。 有关更多信息，请参阅： SMC_TRAFO_Scara2 (FB) 和 SMC_TRAFOF_Scara2 (FB)...", 
"body" : "这 选择性合规装配机械臂 （SCARA）是一种类似于人类手臂的特殊类型的工业机器人。 SCARA 系统有两个轴和两个自由度。运动仅限于 X\/Y 平面。 有关更多信息，请参阅： SMC_TRAFO_Scara2 (FB) 和 SMC_TRAFOF_Scara2 (FB) " }, 
{ "title" : "3 关节 SCARA 系统 ", 
"url" : "_sm_trafo_pou_three_jointed_scara.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 3 关节 SCARA 系统 ", 
"snippet" : "三关节 SCARA 系统具有第三个轴，允许在恒定方向上运动。与在 2 关节系统中一样，运动仅限于 X\/Y 平面。 有关更多信息，请参阅： SMC_TRAFO_Scara3 (FB) 和 SMC_TRAFOF_Scara3 (FB)...", 
"body" : "三关节 SCARA 系统具有第三个轴，允许在恒定方向上运动。与在 2 关节系统中一样，运动仅限于 X\/Y 平面。 有关更多信息，请参阅： SMC_TRAFO_Scara3 (FB) 和 SMC_TRAFOF_Scara3 (FB) " }, 
{ "title" : "平行运动学 ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 平行运动学 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "带线性轴的三脚架 ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_b6b32d1fbe665307c0a8640e00033022", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 平行运动学 \/ 带线性轴的三脚架 ", 
"snippet" : "该系统具有三个线性驱动器，它们彼此处于定义的角度。驱动器由 3 个带有横动滑块的导轨组成。工具板通过相同长度的连杆连接到横动滑块。一对连杆将工具板保持在同一方向上，与地板平行。运动学可以在三个维度上移动工具板。 这些运动学的正向和逆变换在 SMC_Trafo_Tripod_Lin 和 SMC_TrafoF_Tripod_Lin POU。三脚架的轴角由导轨与垂直轴之间的角度定义（ dAxisAngle ）。 机械要求和坐标系 3 个轴的长度相同。 连杆的长度相同。 连杆对之间的距离对于所有连杆都是相同的。 所有三个驱动器的驱动导轨和垂直轴之间的轴角相同。角度公差在 0° 和 90° 之间。 轴定...", 
"body" : "该系统具有三个线性驱动器，它们彼此处于定义的角度。驱动器由 3 个带有横动滑块的导轨组成。工具板通过相同长度的连杆连接到横动滑块。一对连杆将工具板保持在同一方向上，与地板平行。运动学可以在三个维度上移动工具板。 这些运动学的正向和逆变换在 SMC_Trafo_Tripod_Lin 和 SMC_TrafoF_Tripod_Lin POU。三脚架的轴角由导轨与垂直轴之间的角度定义（ dAxisAngle ）。 机械要求和坐标系 3 个轴的长度相同。 连杆的长度相同。 连杆对之间的距离对于所有连杆都是相同的。 所有三个驱动器的驱动导轨和垂直轴之间的轴角相同。角度公差在 0° 和 90° 之间。 轴定义了滑块上连杆接头之间的点的移动。 XYZ 坐标系是右手坐标系。 X 和 Y 向量是水平的，Z 指向上方。定义原点，使三个运动轴与 XY 平面的交点（下图：点 A）位于位置 [0,0,0] 的圆上。 SMC_TrafoF_Tripod_Lin 功能块的参数化 名称 描述 dInnerRadius 工具板中心到连杆夹持点的距离 dOuterRadius 点 A 是轴与 XY 平面的交点。 dLength 连杆长度 dDistance 一对中两根连杆之间的距离 dRotationOffset 默认情况下，第一个轴的 A 点定义 X 轴。偏移量用于围绕 Z 轴旋转整个结构。在这种情况下，点 A 不再位于 X 轴上。 dOffsetA 偏移量用于将轴的位置值设置为其默认设置零。 dOffsetB dOffsetC 您将在库描述中找到有关其他参数的信息。 " }, 
{ "title" : "带垂直轴的三脚架 ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_74ba1833be665308c0a8640e019694c6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 平行运动学 \/ 带垂直轴的三脚架 ", 
"snippet" : "该系统是上述运动学设计的特殊变体，具有相同的机械要求。角度 dAxisAngle 导轨与垂直轴的夹角为0°，导轨与垂直轴平行。 这些运动学的正向和逆变换在 SMC_Trafo_Tripod_Lin 和 SMC_TrafoF_Tripod_Lin 功能块。三脚架的轴角由导轨与垂直轴之间的角度定义（ dAxisAngle ）。 SMC_TrafoF_Tripod_Lin 功能块的参数化 名称 描述 dInnerRadius 该参数定义了由连接杆与工具板的六个夹持点描述的圆的半径。 dOuterRadius dLength 连杆长度 dDistance 连杆对之间的距离 dRotationOffse...", 
"body" : "该系统是上述运动学设计的特殊变体，具有相同的机械要求。角度 dAxisAngle 导轨与垂直轴的夹角为0°，导轨与垂直轴平行。 这些运动学的正向和逆变换在 SMC_Trafo_Tripod_Lin 和 SMC_TrafoF_Tripod_Lin 功能块。三脚架的轴角由导轨与垂直轴之间的角度定义（ dAxisAngle ）。 SMC_TrafoF_Tripod_Lin 功能块的参数化 名称 描述 dInnerRadius 该参数定义了由连接杆与工具板的六个夹持点描述的圆的半径。 dOuterRadius dLength 连杆长度 dDistance 连杆对之间的距离 dRotationOffset 默认情况下，第一个轴的 A 点定义 X 轴。偏移量用于围绕 Z 轴旋转整个结构。在这种情况下，点 A 不再位于 X 轴上。 dOffsetA 偏移量用于将轴的位置值设置为其默认设置零。 dOffsetB dOffsetC 您将在库描述中找到有关其他参数的信息。 " }, 
{ "title" : "带旋转轴的三脚架 ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_30491f2ca003ef70c0a864631e92f50c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 平行运动学 \/ 带旋转轴的三脚架 ", 
"snippet" : "对于三脚架，运动学由 3 个旋转驱动器实现，这些旋转驱动器通过臂和连杆连接到工具板。 坐标系的原点是 3 个臂都处于水平位置时工具板中心的位置。 这些运动学的正向和逆变换在 SMC_TRAFO_Tripod_Arm 和 SMC_TRAFOF_Tripod_Arm 功能块。 机械要求和坐标系 三个轴的长度相同。 连杆的长度相同。 连杆对之间的距离对于所有连杆都是相同的。 SMC_TrafoF_Tripod_Arm 功能块的参数化 名称 描述 dArmLength1 dArmLength2 dArm1Radius 该参数定义了由驱动器的 3 个点 P 建立的圆的半径。 dStewartRadius...", 
"body" : "对于三脚架，运动学由 3 个旋转驱动器实现，这些旋转驱动器通过臂和连杆连接到工具板。 坐标系的原点是 3 个臂都处于水平位置时工具板中心的位置。 这些运动学的正向和逆变换在 SMC_TRAFO_Tripod_Arm 和 SMC_TRAFOF_Tripod_Arm 功能块。 机械要求和坐标系 三个轴的长度相同。 连杆的长度相同。 连杆对之间的距离对于所有连杆都是相同的。 SMC_TrafoF_Tripod_Arm 功能块的参数化 名称 描述 dArmLength1 dArmLength2 dArm1Radius 该参数定义了由驱动器的 3 个点 P 建立的圆的半径。 dStewartRadius 该参数定义了由连接杆到工具板的 6 个夹持点所描述的圆的半径。 dDistance 一对中两根连杆之间的距离 dOffsetA dOffsetB dOffsetC 您将在库描述中找到有关其他参数的信息。 图像显示所有轴的零位。 （三个上臂是水平的。）MCS 显示在工具板上。 A0、A1 和 A2 轴上的箭头根据右手定则显示驱动器的旋转方向。 机器坐标系 (MCS) 起源 当所有 3 个上臂（与 A0、A1 或 A2 直接连接的那些）都处于水平位置时，定义在工具板的中点 X 从原点，指向远离第一个电机 (A0)，平行于第一个臂的上臂段 Y 由 X 和 Z 确定，因此 MCS 是右手的 Z 与工具板正交 从工具板指向电机方向的点 相应的转换由以下 POU 执行 SMC_TRAFO_Tripod_Arm 和 SMC_TRAFOF_Tripod_Arm ： 示例：3S 三脚架 转换设置 tta:\nSMC_TRAFO_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41,dMaxAngleBallJoint:=60);\nttaf:\nSMC_TRAFOF_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41); " }, 
{ "title" : "4 轴码垛机运动学 ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 4 轴码垛机运动学 ", 
"snippet" : "4 轴码垛机运动学是一种通用机器人类型，经常用于码垛任务。运动系统配备四个受控旋转轴（标记为红色）和第五个机械旋转轴（标记为灰色）。这 SMC_Trafo_4AxisPalletizer 和 SMC_TrafoF_4AxisPalletizer POU 实现了它的正向和逆变换。 笛卡尔坐标系是码垛机的基础。 Z 轴垂直向下指向，X 轴“向前”，即手臂指向轴的零方向的方向。笛卡尔坐标系的原点是关节轴 1 与机器人底面的交点。 对象 数据结构 SMC_TrafoConfig_4AxisPalletizer 和功能块 SMC_Trafo_4AxisPalletizer 和 SMC_TrafoF_4A...", 
"body" : "4 轴码垛机运动学是一种通用机器人类型，经常用于码垛任务。运动系统配备四个受控旋转轴（标记为红色）和第五个机械旋转轴（标记为灰色）。这 SMC_Trafo_4AxisPalletizer 和 SMC_TrafoF_4AxisPalletizer POU 实现了它的正向和逆变换。 笛卡尔坐标系是码垛机的基础。 Z 轴垂直向下指向，X 轴“向前”，即手臂指向轴的零方向的方向。笛卡尔坐标系的原点是关节轴 1 与机器人底面的交点。 对象 数据结构 SMC_TrafoConfig_4AxisPalletizer 和功能块 SMC_Trafo_4AxisPalletizer 和 SMC_TrafoF_4AxisPalletizer 链接到图书馆 SM3_Transformation .有关参数的说明，请在库管理器中搜索这些对象。 " }, 
{ "title" : "轴的定义 ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_945c0811df409256c0a8657d0066458b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 4 轴码垛机运动学 \/ 轴的定义 ", 
"snippet" : "下图显示了四个轴的旋转方向。黑色箭头沿关节轴延伸。旋转方向根据右手定则确定：如果右手拇指沿箭头指向下方，则正旋转方向为手指微弯的方向。例如，从上面看时，轴 0 的正旋转方向是顺时针方向，而轴 1 和 2 则“向前”倾斜以进行正旋转。 运动学配有四个受控的旋转轴（参见红色轴 a0、a1、a2、a3）和第五个机械旋转轴（参见灰色轴 M）。 轴的值范围： 轴 0：]-180°、180°[ 轴 1：[-90°，90°] 轴 2：[-180°，90[ 轴 M：机械旋转轴。没有限制 轴 3：不受限制；范围也可以大于 360°...", 
"body" : "下图显示了四个轴的旋转方向。黑色箭头沿关节轴延伸。旋转方向根据右手定则确定：如果右手拇指沿箭头指向下方，则正旋转方向为手指微弯的方向。例如，从上面看时，轴 0 的正旋转方向是顺时针方向，而轴 1 和 2 则“向前”倾斜以进行正旋转。 运动学配有四个受控的旋转轴（参见红色轴 a0、a1、a2、a3）和第五个机械旋转轴（参见灰色轴 M）。 轴的值范围： 轴 0：]-180°、180°[ 轴 1：[-90°，90°] 轴 2：[-180°，90[ 轴 M：机械旋转轴。没有限制 轴 3：不受限制；范围也可以大于 360° " }, 
{ "title" : "零位和尺寸 ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 4 轴码垛机运动学 \/ 零位和尺寸 ", 
"snippet" : "该图显示了所有轴的零位运动。在零位时，工具坐标系的轴平行于机床坐标系的轴。在配置结构中指定指示的维度 SMC_TrafoConfig_4AxisPalletizer 同时指定所有 a_i 有积极的迹象和所有 d_i 带有负号。参数的名称符合 Denavit-Hartenberg 约定。 关节的 Denavit-Hartenberg 变换 关节偏移 (sigma_i) 关节距离 (d_i) 臂单元长度 (a_i) 扭转 (alpha_i) 1 0° d_1 一个_1 90° 2 -90° 0 a2 0° 3 90° 0 a_3 0° 4 0° 0 a_4 90° 5 0° d_5 0 180°...", 
"body" : "该图显示了所有轴的零位运动。在零位时，工具坐标系的轴平行于机床坐标系的轴。在配置结构中指定指示的维度 SMC_TrafoConfig_4AxisPalletizer 同时指定所有 a_i 有积极的迹象和所有 d_i 带有负号。参数的名称符合 Denavit-Hartenberg 约定。 关节的 Denavit-Hartenberg 变换 关节偏移 (sigma_i) 关节距离 (d_i) 臂单元长度 (a_i) 扭转 (alpha_i) 1 0° d_1 一个_1 90° 2 -90° 0 a2 0° 3 90° 0 a_3 0° 4 0° 0 a_4 90° 5 0° d_5 0 180° " }, 
{ "title" : "G代码编程 ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_67269b93df408f35c0a8657d0178e964", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 4 轴码垛机运动学 \/ G代码编程 ", 
"snippet" : "夹具的位置由 X、Y 和 Z 控制。夹具在垂直方向上的旋转由附加轴 C 控制。角度以度为单位指定。...", 
"body" : "夹具的位置由 X、Y 和 Z 控制。夹具在垂直方向上的旋转由附加轴 C 控制。角度以度为单位指定。 " }, 
{ "title" : "6轴关节机器人 ", 
"url" : "_sm_trafo_pou_six_dof_robot.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 6轴关节机器人 ", 
"snippet" : "具有六个旋转轴和六个自由度 (DoF) 的关节臂机器人的改造。机器人手臂的三个定向轴相交于一点：关节中心。 这 SMC_Trafo_ArticulatedRobot_6DOF 和 SMC_TrafoF_ArticulatedRobot_6DOF 功能块实现了具有六个旋转轴的关节臂机器人的正向和反向转换。在图像中，笛卡尔坐标系在下方标记为 0 轴。z 轴指向下方，x 轴指向工具中心点 (TCP) 的方向。笛卡尔坐标系的原点是交叉轴 0 和机器人底部。 变换对象 数据结构 SMC_TrafoConfig_ArticulatedRobot_6DOF 和 SMC_Trafo_ArticulatedRo...", 
"body" : "具有六个旋转轴和六个自由度 (DoF) 的关节臂机器人的改造。机器人手臂的三个定向轴相交于一点：关节中心。 这 SMC_Trafo_ArticulatedRobot_6DOF 和 SMC_TrafoF_ArticulatedRobot_6DOF 功能块实现了具有六个旋转轴的关节臂机器人的正向和反向转换。在图像中，笛卡尔坐标系在下方标记为 0 轴。z 轴指向下方，x 轴指向工具中心点 (TCP) 的方向。笛卡尔坐标系的原点是交叉轴 0 和机器人底部。 变换对象 数据结构 SMC_TrafoConfig_ArticulatedRobot_6DOF 和 SMC_Trafo_ArticulatedRobot_6DOF 和 SMC_TrafoF_ArticulatedRobot_6DOF 功能块链接到 SM3_CNC . " }, 
{ "title" : "轴的定义 ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_7e060a95379b6b55c0a8640e01f01d63", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 6轴关节机器人 \/ 轴的定义 ", 
"snippet" : "旋转轴由黑色箭头标识。正旋转方向由右手定则给出。例如，当轴 0 向正方向转动时，从上方看，机器人顺时针旋转。 轴被限制在以下范围内： 轴 0、1、3 和 4：]-180°、180°[ 轴 2：[-90°, 180°] 轴 5：不受限制；范围可能大于 360°。...", 
"body" : "旋转轴由黑色箭头标识。正旋转方向由右手定则给出。例如，当轴 0 向正方向转动时，从上方看，机器人顺时针旋转。 轴被限制在以下范围内： 轴 0、1、3 和 4：]-180°、180°[ 轴 2：[-90°, 180°] 轴 5：不受限制；范围可能大于 360°。 " }, 
{ "title" : "归位位置和尺寸 ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 6轴关节机器人 \/ 归位位置和尺寸 ", 
"snippet" : "左图显示了运动学的归位位置，即所有轴都处于零位的位置。在配置结构中指定指示的维度 SMC_TrafoConfig_ArticulatedRobot_6DOF .参数的名称和符号符合 Denavit-Hartenberg 约定。右图显示了附加的 Denavit–Hartenberg 参数 d3 . 笔记： a1、a3、d4 和 d6 必须 >= 0 a2 必须 > 0 (> g_fSMC_CNC_EPS ) d1 必须 <= 0 关节的 Denavit-Hartenberg 变换 关节偏移 (sigma_i) 杠杆偏移 (d_i) 杠杆长度 (a_i) 杠杆旋转 (alpha_i) 1 0° d...", 
"body" : "左图显示了运动学的归位位置，即所有轴都处于零位的位置。在配置结构中指定指示的维度 SMC_TrafoConfig_ArticulatedRobot_6DOF .参数的名称和符号符合 Denavit-Hartenberg 约定。右图显示了附加的 Denavit–Hartenberg 参数 d3 . 笔记： a1、a3、d4 和 d6 必须 >= 0 a2 必须 > 0 (> g_fSMC_CNC_EPS ) d1 必须 <= 0 关节的 Denavit-Hartenberg 变换 关节偏移 (sigma_i) 杠杆偏移 (d_i) 杠杆长度 (a_i) 杠杆旋转 (alpha_i) 1 0° d1 a_1 -90° 2 90° 0 a2 0° 3 0° d3 a_3 90° 4 0° d4 0 90° 5 0° 0 0 -90° 6 0° d6 0 0° " }, 
{ "title" : "编程 ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_9cf41a3c6a5fb376c0a8640e005461c1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 6轴关节机器人 \/ 编程 ", 
"snippet" : "刀具中心位置由X、Y、Z控制。X、Y、Z的单位与参数使用的相同 a_i 和 d_i （例如：毫米）。方向通过 A（偏航）、B（俯仰）和 C（滚动）以度数控制。...", 
"body" : "刀具中心位置由X、Y、Z控制。X、Y、Z的单位与参数使用的相同 a_i 和 d_i （例如：毫米）。方向通过 A（偏航）、B（俯仰）和 C（滚动）以度数控制。 " }, 
{ "title" : "来自的运动学变换功能块的包装器 SM3_Transformation 图书馆 ", 
"url" : "_sm_wrapper_kinematic_fbs.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 运动学变换 \/ 来自的运动学变换功能块的包装器 SM3_Transformation 图书馆 ", 
"snippet" : "这个 SMC_Trafo_Wrapper 和 SMC_Trafof_Wrapper 功能块允许您在中使用运动学 SM3_Transformation CNC 应用程序库。 有关运动学的更多信息 SM3_Transformation 库，请参见以下内容： 运动学可以使用任何实现 MC_KIN_REF_SM3 接口。此外，“位置运动学” 和 “方向运动学” 的组合 有关更多信息，请参阅以下内容： 位置和方向运动学的结合...", 
"body" : "这个 SMC_Trafo_Wrapper 和 SMC_Trafof_Wrapper 功能块允许您在中使用运动学 SM3_Transformation CNC 应用程序库。 有关运动学的更多信息 SM3_Transformation 库，请参见以下内容： 运动学可以使用任何实现 MC_KIN_REF_SM3 接口。此外，“位置运动学” 和 “方向运动学” 的组合 有关更多信息，请参阅以下内容： 位置和方向运动学的结合" }, 
{ "title" : "DIN 66025 中的 CNC 语言 ", 
"url" : "_sm_struct_reference_programming_din66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "DIN 66025 基础 ", 
"url" : "_sm_cnc_din66025_basics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ DIN 66025 基础 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "DIN 66025 程序的结构 ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_c348b29fedfe7b9ec0a86463427bc61d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ DIN 66025 基础 \/ DIN 66025 程序的结构 ", 
"snippet" : "DIN 66025 程序由单独的运动块组成。块号位于每个块的开头。 ['%' <Programmname>] <Satz>{<Satz>} 块的结构如下： N<block number> G<expression> <G code words> N<block number> <G code words> （这 G<expression> 上一块适用） N<block number> M<expression> <G code words> N<block number> <subroutine name> ( <ActualParamList> ) 子程序的附加块结构： SUBPROGRAM...", 
"body" : "DIN 66025 程序由单独的运动块组成。块号位于每个块的开头。 ['%' <Programmname>]\n<Satz>{<Satz>} 块的结构如下： N<block number> G<expression> <G code words> N<block number> <G code words> （这 G<expression> 上一块适用） N<block number> M<expression> <G code words> N<block number> <subroutine name> ( <ActualParamList> ) 子程序的附加块结构： SUBPROGRAM <Name> {<FormalParamList>} <RESTORE_OPT> N<block number> RETURN END_SUBPROGRAM 例子 两条线和一条弧的路径，后跟子程序调用 % MyProgram\nN10 G01 X100 Y100 E100 F100 E-200\nN20 G01 Z40 F20\nN30 G03 X-100 R200 F100\nN40 SubPrg{5} " }, 
{ "title" : "句法 ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_section-idm4580346248046432600861986014", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ DIN 66025 基础 \/ 句法 ", 
"snippet" : "['%' <程序名称>] 标题可选 以 % 开头，后跟以 a 分隔的程序名称 空间 或者 标签 <方块> 该块从右到左逐字处理。 \/ 阶跃抑制 如果一个块以 \/ 开头，并且 CNC ➔ 阶跃抑制 命令被选中，则块不执行。 N<块号> 块编号用作定义跳转目标的标记。 例子： N01 G<表达式> 旅行指挥部 如果一个程序段中没有指定行进指令，则自动补充上一个程序段中的行进指令。 忽略大写和小写。 忽略前导零。所以， G01 = g1 适用 对应路径元素或路径对象 例子： G1 （线性）， G2 （弧） 插入路径对象的速度；原则上对应于设定的路径速度、路径加速度和路径减速度。内插器确保不超过这些限...", 
"body" : "['%' <程序名称>] 标题可选 以 % 开头，后跟以 a 分隔的程序名称 空间 或者 标签 <方块> 该块从右到左逐字处理。 \/ 阶跃抑制 如果一个块以 \/ 开头，并且 CNC ➔ 阶跃抑制 命令被选中，则块不执行。 N<块号> 块编号用作定义跳转目标的标记。 例子： N01 G<表达式> 旅行指挥部 如果一个程序段中没有指定行进指令，则自动补充上一个程序段中的行进指令。 忽略大写和小写。 忽略前导零。所以， G01 = g1 适用 对应路径元素或路径对象 例子： G1 （线性）， G2 （弧） 插入路径对象的速度；原则上对应于设定的路径速度、路径加速度和路径减速度。内插器确保不超过这些限制值。 <G码字> 忽略大写和小写。 G码字 由地址组成（例如 E ) 和一个表达式（例如 100 ; 一起 E100 ) 忽略大写和小写。 忽略前导零。 将单词的编号写入变量 单词的字母是变量名。旅行命令访问它。 所有数字都可以是浮点值。这不适用于 G<expression> 旅行命令， M<expression> M 函数，和 H<expression> 切换点。 块的单词由一个分隔 空间 或者 标签 . <表达式> 看： 表达式() 评论 括号之间的字符被解释为注释。 注意：评论可以通过重新定义 bParenthesesAsComments 输入 ( FB SMC_ReadNCFile2 ) . 两个连续块之间的插值 过渡两个相邻对象时的速度由以下规则确定： 如果两个对象之一是定位 G0 ，则过渡速度 = 0。 如果过渡处两个路径元素的切线之间的角度大于角度公差，则过渡速度 = 0。 否则，过渡速度是两个路径元素的最小指定速度。 通常，行驶指令负责将上次行驶指令的目标位置插补到由当前行驶指令指定的目标位置。第一个运行命令从在解码器或 CNC 编辑器中定义的位置开始。如果未定义此位置，则起点为 X=0、Y=0、Z=0。 " }, 
{ "title" : "行驶指令和相应的路径元素 ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_48e0dea1edfe7b9ec0a8646321fb969d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ DIN 66025 基础 \/ 行驶指令和相应的路径元素 ", 
"snippet" : "旅行指挥部 描述 路径元素 G0 无需工具操作直接移动；直线运动 定位G1 工具操作的直线运动 直线运动G2 圆段或圆，顺时针 弧G3 圆段或圆，逆时针 弧G4 停留时间 停留时间G5 二维基数样条的点 样条G6 抛物线 抛物线G8 椭圆弧或椭圆，顺时针 椭圆G9 椭圆弧或椭圆，逆时针 椭圆G10 3D 基数样条的点 样条G15 切换到 2D 3D 模式G16 通过使用法线向量激活 3D 模式切换到 3D I \/ J \/ K 到飞机 3D 模式G17 通过激活 3D 模式切换到 3D X \/ Y 飞机 3D 模式G18 通过激活 3D 模式切换到 3D Z \/ X 飞机 3D 模式G19 通过...", 
"body" : "旅行指挥部 描述 路径元素 G0 无需工具操作直接移动；直线运动 定位G1 工具操作的直线运动 直线运动G2 圆段或圆，顺时针 弧G3 圆段或圆，逆时针 弧G4 停留时间 停留时间G5 二维基数样条的点 样条G6 抛物线 抛物线G8 椭圆弧或椭圆，顺时针 椭圆G9 椭圆弧或椭圆，逆时针 椭圆G10 3D 基数样条的点 样条G15 切换到 2D 3D 模式G16 通过使用法线向量激活 3D 模式切换到 3D I \/ J \/ K 到飞机 3D 模式G17 通过激活 3D 模式切换到 3D X \/ Y 飞机 3D 模式G18 通过激活 3D 模式切换到 3D Z \/ X 飞机 3D 模式G19 通过激活 3D 模式切换到 3D Y \/ Z 飞机 3D 模式G20 条件跳转 L ， 如果 K <> 0 跳G31 使用解码停止删除剩余距离 探测功能（清除剩余距离）G36 写入值 D 变 O 改变变量的值G37 增量变量 O 按价值 D 改变变量的值G38 激活扩展预处理功能 激活扩展预处理功能G39 停用扩展预处理功能 激活扩展预处理功能G40 刀具半径补偿结束 预处理G41 刀具半径补偿开始，行进方向左侧 预处理G42 刀具半径补偿开始，行进方向右侧 预处理G43 开始校正刀具长度 预处理G50 拐角末端圆角\/平滑 预处理G51 开始对角落进行平滑处理 预处理G52 角球回合开始 预处理G53 结束坐标变换并将解码器坐标系重置为原始位置（=机器坐标系） 移动、旋转和缩放坐标系G54 坐标的绝对变换 移动、旋转和缩放坐标系G55 坐标的相对变换 移动、旋转和缩放坐标系G56 设置 DCS 的当前方向、位置和缩放设置为参考点 移动、旋转和缩放坐标系G60 循环结束抑制 预处理G61 循环抑制开始 预处理G70 平滑附加轴结束 看： SMC_SmoothAddAxes 预处理G71 开始平滑附加轴 看： SMC_SmoothAddAxes 预处理G75 与内插器的时间同步 与内插器的时序同步G90 该坐标 （ X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) 被解释为绝对值。 （这是默认设置。） 模式G91 该坐标 （ X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) 被解释为相对于当前位置的值。 模式G92 跳跃定位 定位G98 轴中点 ( I \/ J \/ K ) 被解释为绝对值。 模式G99 轴中点 ( I \/ J \/ K ) 被解释为相对于起始位置的值。 （这是默认设置。） 模式" }, 
{ "title" : "G码字识别 ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_591ac87c61b577fcc0a8640e0070747c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ DIN 66025 基础 \/ G码字识别 ", 
"snippet" : "A 附加样条轴的目标位置 对于解码器坐标系中的坐标变换，单词包含一个角度。 B C D 补偿刀具半径 G40 —— G42 圆角的刀具距离 G50 - G51 变量值 G36 \/ G37 E 以 [u\/sec 为单位的最大路径加速\/减速 2 ]。值 > 0：加速度；值 < 0：减速 EF 路径加速\/减速 G0 运动 E<axis> 指定的单独加速\/减速 (>0\/<0) <axis> 附加轴 附加轴是 A , B , C , P , Q , U , V , W ，并且 Z 在 2D 模式下。 如果使用此 G 代码，则路径处理程序段 SMC_ExtendedVelocityChecks 必须用于限...", 
"body" : "A 附加样条轴的目标位置 对于解码器坐标系中的坐标变换，单词包含一个角度。 B C D 补偿刀具半径 G40 —— G42 圆角的刀具距离 G50 - G51 变量值 G36 \/ G37 E 以 [u\/sec 为单位的最大路径加速\/减速 2 ]。值 > 0：加速度；值 < 0：减速 EF 路径加速\/减速 G0 运动 E<axis> 指定的单独加速\/减速 (>0\/<0) <axis> 附加轴 附加轴是 A , B , C , P , Q , U , V , W ，并且 Z 在 2D 模式下。 如果使用此 G 代码，则路径处理程序段 SMC_ExtendedVelocityChecks 必须用于限制速度。 F 速度（以 [u\/sec] 为单位）：“进给” FF 速度为 G0 动作 F<axis> 指定附加轴 <axis> 的单独速度 附加轴是 A , B , C , P , Q , U , V , W ，并且 Z 在 2D 模式下。 如果使用此 G 代码，则路径处理程序段 SMC_ExtendedVelocityChecks 必须用于限制速度。 G 路径条件 H 开关点（H 功能） 正：开启 负：关闭 I 圆\/椭圆中点的 X 坐标 G02 \/ G03 \/ G08 \/ G09 抛物线顶点的 X 坐标为 G06 3D 平面函数的法向量 (X) 用于激活扩展预处理功能的参数 G38 \/ G39 在 X 方向上缩放 G54 \/ G55 \/ G56 X 方向的刀具偏置为 G43 J 圆\/椭圆中点的 Y 坐标 G02 \/ G03 \/ G08 \/ G09 抛物线顶点的 Y 坐标 G06 3D 平面函数的法向量 (Y) 用于激活扩展预处理功能的参数 G38 \/ G39 在 Y 方向缩放 G54 \/ G55 \/ G56 Y 方向的刀具偏置 G43 K 主椭圆轴的方向；数学上：0° = O , 90° = N ， 等等。 跳转条件为 G20 M 功能的 dT1 参数值 圆中点的 Z 坐标为 G02 \/ G03 在 3D 模式下 3D 平面函数的法向量 (Z) 用于激活扩展预处理功能的参数 G38 \/ G39 在 Z 方向缩放 G54 \/ G55 \/ G56 Z 方向的刀具偏置 G43 L H 函数的绝对开关位置，从路径元素的起点（如果位置 > 0）测量，或者从路径元素的末端测量（如果位置 < 0）。 跳转目标 G20 M 功能的 dT2 参数值 附加轴数 G70 和 G71 M 机械的附加选项；还有M功能 O H 功能值范围为 [0..1] 的相对开关点位置 变量值 G36 \/ G37 . M 功能参数的数据结构 P 附加线性轴的目标位置 P P<axis><period> 模数轴的配置 如果 Period = 0 适用（例如： PA0 )，则轴的行为是线性的。 PROBE 激活运动的探测功能（清除剩余距离） Q 附加线性轴 Q 的目标位置 R 圆半径替代 I, J 与 G02 \/ G03 取值范围为 [0..1] 的椭圆副\/主轴的长度比，其中 G08 \/ G09 S 线性轴的 S 轮廓 正：开启 负：关闭 轴 3 : Z，如果 Z 处于 2D 模式 7 : 对 8 : 问 9 ：你 10 ：五 11 ：W T 命令特定参数 U 附加线性轴的目标位置 U V 附加线性轴的目标位置 V W 附加线性轴的目标位置 W X 目标位置的 X 坐标 Y 目标位置的 Y 坐标 Z 目标位置的 Z 坐标 " }, 
{ "title" : "3D 模式 ", 
"url" : "_sm_cnc_din66025_3dmode.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 3D 模式 ", 
"snippet" : "G代码 ： G15 , G16 , G17 , G18 , G19 G代码 描述 G15 切换到 2D 模式。对所有其他元素有效 G16 在法线矢量 I\/J\/K 的法线平面中激活 3D 平面功能并切换到 3D 模式 对所有其他元素有效 G17 激活 X\/Y 平面中的 3D 平面功能并切换到 3D 模式 对所有其他元素有效 G18 激活 X\/Z 平面中的 3D 平面功能。切换到 3D 模式 对所有其他元素有效 G19 在 Y\/Z 平面中激活 3D 平面功能。切换到 3D 模式 对所有其他元素有效 三维路径元素用于 3D 模式。在 3D 空间中，您可以设置点并使用 3D 样条连接。您还可以在任何空...", 
"body" : "G代码 ： G15 , G16 , G17 , G18 , G19 G代码 描述 G15 切换到 2D 模式。对所有其他元素有效 G16 在法线矢量 I\/J\/K 的法线平面中激活 3D 平面功能并切换到 3D 模式 对所有其他元素有效 G17 激活 X\/Y 平面中的 3D 平面功能并切换到 3D 模式 对所有其他元素有效 G18 激活 X\/Z 平面中的 3D 平面功能。切换到 3D 模式 对所有其他元素有效 G19 在 Y\/Z 平面中激活 3D 平面功能。切换到 3D 模式 对所有其他元素有效 三维路径元素用于 3D 模式。在 3D 空间中，您可以设置点并使用 3D 样条连接。您还可以在任何空间平面中插入圆弧。与仅使用 X\/Y 坐标的 2.5D 路径元素相比，路径速度和加速度指的是 X\/Y\/Z 坐标中的移动。 Z 轴与 X 轴和 Y 轴的处理方式相同。因此，每个运动都可以在 Z 方向上进行。 3D 模式 该模式不支持椭圆、抛物线和二维样条。发出错误消息。 SMC_CheckVelocities 检查 Z 分量 SMC_ToolCorr 和 SMC_AvoidLoop 产生错误 2.5D 和 3D 之间的主要区别 2.5D 和 3D 之间的主要区别 速度和加速度 (F\/E)： 在 3D 中：定义路径的速度和加速度。 在 2.5D 中：定义路径在 X\/Y 平面上的投影的速度和加速度。 样条 3D：具有无冲击、平滑的 Z 分量 (G10) 2.5D：在 Z 方向未平滑 (G5) 弧 3D：可以在空间中的每个可能平面中定义（G2\/G3 和 G16\/G17\/G18\/G19） 2.5D：仅限于 X\/Y 平面 (G2\/G3) 例子 3D 和 2.5D 的速度比较 N0 G1 X1 Z100 F1 3D 需要大约 100 秒的运动，因为对象的长度包含 Z 分量。 长度 = (1 2 + 100 2 ) 1\/2 速度为 1 时，大约需要 100 秒。 Z 分量的速度约为 1。 在 2.5D 中，运动需要大约 1 秒来计算或长度 = 1。Z 方向上的速度大约为 100。 " }, 
{ "title" : "激活扩展预处理功能 ", 
"url" : "_sm_cnc_din66025_activating_extended_preprocessor_functions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 激活扩展预处理功能 ", 
"snippet" : "G代码 ： G38 , G39 功能 ：这些命令激活和停用扩展预处理功能。 句法 G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> G39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> G码字 描述 <位> 0 到 31 之间的值。功能位的分配留给开发人员。一些功能块，例如 SMC_SmoothMerge 或者 SMC_SmoothBSpline ，有一个输入 wFeatureBit （初始值 0）定义要使用的位。该位保存在变量中 SMC_GeoInfo.dwFeatureF...", 
"body" : "G代码 ： G38 , G39 功能 ：这些命令激活和停用扩展预处理功能。 句法 G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value>\nG39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> G码字 描述 <位> 0 到 31 之间的值。功能位的分配留给开发人员。一些功能块，例如 SMC_SmoothMerge 或者 SMC_SmoothBSpline ，有一个输入 wFeatureBit （初始值 0）定义要使用的位。该位保存在变量中 SMC_GeoInfo.dwFeatureFlags . <参数 1 值> 任何值。值保存在数组中 SMC_GeoInfo.aAdditionalParams : ARRAY[0..MAX_ADDITIONAL_PARAMS-1] OF LREAL . <参数 1 值> <参数 1 值> " }, 
{ "title" : "移动、旋转和缩放坐标系 ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 移动、旋转和缩放坐标系 ", 
"snippet" : "G代码 ： G53 , G54 , G55 , G56 功能 ： G代码命令 G54 ， G55 ， 和 G56 移动、旋转和缩放解释器功能块内部使用的解码器坐标系 SMC_NCInterpreter . 在执行过程中，将计算所有路径元素的坐标变换 SMC_NCInterpreter 功能块实例。 G代码指令 G53 将解码器坐标系重置为原始位置、方向和缩放（对应于机器坐标系）。 您移动和旋转解码器坐标系，以便重复使用相同路径元素的 G 代码，这些元素仅在位置、方向或缩放上有所不同。 旋转和缩放解码器坐标系仅在在线解释器中有效（而不是在 CNC 编辑器中）。...", 
"body" : "G代码 ： G53 , G54 , G55 , G56 功能 ： G代码命令 G54 ， G55 ， 和 G56 移动、旋转和缩放解释器功能块内部使用的解码器坐标系 SMC_NCInterpreter . 在执行过程中，将计算所有路径元素的坐标变换 SMC_NCInterpreter 功能块实例。 G代码指令 G53 将解码器坐标系重置为原始位置、方向和缩放（对应于机器坐标系）。 您移动和旋转解码器坐标系，以便重复使用相同路径元素的 G 代码，这些元素仅在位置、方向或缩放上有所不同。 旋转和缩放解码器坐标系仅在在线解释器中有效（而不是在 CNC 编辑器中）。 " }, 
{ "title" : "MCS 和 DCS 坐标系 ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 移动、旋转和缩放坐标系 \/ MCS 和 DCS 坐标系 ", 
"snippet" : "机器坐标系 (MCS) 由确定其位置和方向的应用运动学定义。 解码器坐标系（DCS）由解释器管理（ SMC_NCInterpreter 功能块实例）。运动命令的所有坐标信息都在此坐标系中进行解释。这会影响运动的目标位置（ X\/Y\/Z ）以及圆弧中点（ I\/J\/K ）或设置有 G15\/G16\/G17\/G18\/G19 。 DCS 使用以下命令进行编程 G53\/G54\/G55\/G56 .您可以相对于机器坐标系旋转、移动和缩放 DCS，因此可以多次调整 G 代码文件中的位置、方向和缩放比例。您可以对相对于 DCS 的路径元素进行编程。例如，对于处于不同位置和方向的相同路径元素，这可能是一个优势。 下图...", 
"body" : "机器坐标系 (MCS) 由确定其位置和方向的应用运动学定义。 解码器坐标系（DCS）由解释器管理（ SMC_NCInterpreter 功能块实例）。运动命令的所有坐标信息都在此坐标系中进行解释。这会影响运动的目标位置（ X\/Y\/Z ）以及圆弧中点（ I\/J\/K ）或设置有 G15\/G16\/G17\/G18\/G19 。 DCS 使用以下命令进行编程 G53\/G54\/G55\/G56 .您可以相对于机器坐标系旋转、移动和缩放 DCS，因此可以多次调整 G 代码文件中的位置、方向和缩放比例。您可以对相对于 DCS 的路径元素进行编程。例如，对于处于不同位置和方向的相同路径元素，这可能是一个优势。 下图显示了一个移位（左）和一个旋转移位（右）。 解释器从其 eOriConv 输入是否 A\/B\/C 被视为附加轴或方向值。路径元素的坐标会相应地进行转换。因此，解释器功能块管理活动坐标系。最初，如果 DCS 既未移位，也未旋转或缩放，则 DCS 对应于 MCS。在生成的 GeoInfo 对象中，弧的起始位置和目标位置以及平面始终相对于 MCS 指定。 SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES 没有指定方向约定。 G 代码字 A\/B\/C 的内容被解释为移位值。 SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYZ 方向约定是标准的 Y 约定（Z、Y'、Z''）。 G 代码字 A\/B\/C 的内容被解释为角度值。 SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYX 方向约定是偏航-俯仰-滚转约定（Z、Y'、X''）。 G 代码字 A\/B\/C 的内容被解释为角度值。 SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.XYZ 方向约定是 XYZ 约定（X、Y'、Z''）。 G 代码字 A\/B\/C 的内容被解释为角度值。 " }, 
{ "title" : "指令 G53、G54、G55、G56 ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 移动、旋转和缩放坐标系 \/ 指令 G53、G54、G55、G56 ", 
"snippet" : "G代码 描述 G53 重置解码器坐标系 DCS 重置为与 MCS 相同的位置和方向。 G54 绝对 DCS 的移位、旋转和缩放 这些值是指 MCS。 如果方向公约是 不是 指定的 （ SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES )，则该命令仅导致沿轴 X\/Y\/Z\/A\/B\/C 和所有附加线性轴 P\/Q\/U\/V\/W 的移位。因此，也可以沿 A\/B\/C 轴编程移位。 如果指定了方向约定，则该命令还会导致沿 X\/Y\/Z 轴和附加线性轴 P\/Q\/U\/V\/W 的偏移。此外，坐标轴被旋转。然后方向约定提供旋转顺序，G 代码字 A\/B\/C 给...", 
"body" : "G代码 描述 G53 重置解码器坐标系 DCS 重置为与 MCS 相同的位置和方向。 G54 绝对 DCS 的移位、旋转和缩放 这些值是指 MCS。 如果方向公约是 不是 指定的 （ SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES )，则该命令仅导致沿轴 X\/Y\/Z\/A\/B\/C 和所有附加线性轴 P\/Q\/U\/V\/W 的移位。因此，也可以沿 A\/B\/C 轴编程移位。 如果指定了方向约定，则该命令还会导致沿 X\/Y\/Z 轴和附加线性轴 P\/Q\/U\/V\/W 的偏移。此外，坐标轴被旋转。然后方向约定提供旋转顺序，G 代码字 A\/B\/C 给出以度为单位的旋转角度。 注意：解码器可以在 -180° 到 +180° 的范围内执行方向旋转。如果您指定了超出此范围的角度，则解码器会转换该值，使其在可执行范围内。只有这样，解码器才会旋转坐标轴。例如，对于 350° 的角度，执行 -10° 的旋转。 G55 相对的 将 DCS 移动、旋转和缩放到其当前位置和方向 因此，这些值是相对于当前 DCS 原点的，并在 DCS 当前坐标轴的方向上进行解释。相对于机器坐标系添加了额外的移位\/旋转。 如果方向约定是 不是 指定，则该命令仅导致沿 X\/Y\/Z\/A\/B\/C 轴和所有附加线性轴 P\/Q\/U\/V\/W 的相对位移。因此，也可以沿 A\/B\/C 轴编程移位。 如果指定了方向约定，则该命令还会导致沿 X\/Y\/Z 轴和附加线性轴 P\/Q\/U\/V\/W 的相对位移。但最重要的是，坐标轴会进一步旋转。然后定向约定提供旋转顺序，G 代码字 A\/B\/C 给出旋转角度。 G56 重置解码器坐标系的参考点 DCS 的当前方向、位置和比例设置为参考。 提示：如果参考点为 X0 Y0 Z0 A0 B0 C0，则 DCS 设置为与当前位置和方向相同。 句法 G53\nG54 X Y Z A B C I J K P Q U V W\nG55 X Y Z A B C I J K P Q U V W\nG56 X Y Z A B C I J K P Q U V W G码字 描述 X Y Z 解码器坐标系围绕其移动的值 A B C 如果输入是 eOriConf = SMC_ORI_CONVENTION.ADDAXES 在 SMC_NCInterpreter ，则该值以相应附加轴偏移的距离为单位给出。因此，该参数定义了解码器坐标系相对于机器坐标系的每个轴的偏移。 如果 eOriConf 输入是 SMC_ORI_CONVENTION.ZYZ ， SMC_ORI_CONVENTION.ZYX ， 或者 SMC_ORI_CONVENTION.XYZ 在 SMC_NCInterpreter ，则提供方向约定。在这种情况下，此处给出的值将自动解释为度数，并确定解码器坐标系的轴相对于机器坐标系的旋转程度。因此，您可以根据方向约定定义主轴的旋转。 注意：在对 DCS 旋转进行编程时，应始终在中指定旋转角度 A\/B\/C 所有三个轴。缺少旋转角度会导致解码时出错（ SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ）。 I 方向缩放 X 例子： 10 扩展 10 倍 J 方向缩放 是 例子： 10 扩展 10 倍 K 方向缩放 Z 例子： 10 扩展 10 倍 P Q U V W 解码器坐标系附加轴围绕其移动的值 " }, 
{ "title" : "转移 DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 移动、旋转和缩放坐标系 \/ 转移 DCS ", 
"snippet" : "设置 eOriConv 输入 SMC_NCInterpreter 功能块实例 SMC_ORI_CONVENTION.ADDAXES 。 DCS 可以移动。旋转是不可能的。 编程 CNC 路径。首先，指定 DCS 的位置偏移。 例子： G54 X10 Y10 Z10 A30 B30 C30 DCS 的 X\/Y\/Z\/A\/B\/C 轴移动。 例子 绝对偏移 N10 G0 X100 Y100 F100 N20 G54 X50 Y50 (Offset auf 50\/50) N30 G1 X0 Y0 (Fahrt nach 50\/50) N40 G54 X100 Y100 (Offset auf 100\/1...", 
"body" : "设置 eOriConv 输入 SMC_NCInterpreter 功能块实例 SMC_ORI_CONVENTION.ADDAXES 。 DCS 可以移动。旋转是不可能的。 编程 CNC 路径。首先，指定 DCS 的位置偏移。 例子： G54 X10 Y10 Z10 A30 B30 C30 DCS 的 X\/Y\/Z\/A\/B\/C 轴移动。 例子 绝对偏移 N10 G0 X100 Y100 F100\nN20 G54 X50 Y50 (Offset auf 50\/50)\nN30 G1 X0 Y0 (Fahrt nach 50\/50)\nN40 G54 X100 Y100 (Offset auf 100\/100)\nN50 G1 X0 Y0 (Fahrt nach 100\/100)\nN60 G53 (Offset auf 0)\nN70 G1 X0 Y0 (Fahrt nach 0\/0) 当前位置作为偏移量 N0 G0 X100 Y100 F100\nN10 G56 X0 Y0 (Aktuelle Position 100\/100 wird 0\/0)\nN20 G1 X10 (Fahrt nach 110\/100)\nN30 G56 X20 Y0 (Aktuelle Position 110\/100 wird 20\/0)\nN40 G1 X0 (Fahrt nach 90\/100) 按值调整偏移量 N0 G54 X10 Y20 Z30 U7 (Offset: X=10, Y=20, Z=30, U=7)\nN10 G55 X-10 U7 (Offset: X=0, Y=20, Z=30, U=14) 两个位置的相同路径元素 N05 G17\nN10 G54 X10 Y10 Z10\nN20 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN30 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN040 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097\nN50 G55 X10 Y10 Z10\nN60 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN70 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN80 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097 " }, 
{ "title" : "移动和旋转 DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_df6926f62eedd311c0a8646378b457e7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 移动、旋转和缩放坐标系 \/ 移动和旋转 DCS ", 
"snippet" : "设置 eOriConv 输入 SMC_NCInterpreter 功能块实例到所需的方向约定（例如， SMC_ORI_CONVENTION.ZYZ ）。 DCS 的 X\/Y\/Z 轴的定向约定和旋转顺序已编程。为了 SMC_ORI_CONVENTION.ZYZ ，旋转顺序是 ZY'Z'' 并且对应于标准的 Y 约定。 注：只要输入 eOriConv 包含方向约定而不是值 SMC_ORI_CONVENTION.ADDAXES , 单词的值 A\/B\/C 解释为 G 代码命令的旋转角度值 G54\/G55\/G56 . 编程 CNC 路径。首先，指定 DCS 的位置偏移和旋转。 例子： G54 X10 Y...", 
"body" : "设置 eOriConv 输入 SMC_NCInterpreter 功能块实例到所需的方向约定（例如， SMC_ORI_CONVENTION.ZYZ ）。 DCS 的 X\/Y\/Z 轴的定向约定和旋转顺序已编程。为了 SMC_ORI_CONVENTION.ZYZ ，旋转顺序是 ZY'Z'' 并且对应于标准的 Y 约定。 注：只要输入 eOriConv 包含方向约定而不是值 SMC_ORI_CONVENTION.ADDAXES , 单词的值 A\/B\/C 解释为 G 代码命令的旋转角度值 G54\/G55\/G56 . 编程 CNC 路径。首先，指定 DCS 的位置偏移和旋转。 例子： G54 X10 Y10 Z10 A30 B30 C30 字的价值 A\/B\/C 提供旋转方向和角度（以度为单位）。坐标系相应地旋转。字的价值 X\/Y\/Z 定义转变。 注意：在对 DCS 旋转进行编程时，应始终在中指定旋转角度 A\/B\/C 所有三个轴。缺少旋转角度会导致解码时出错（ SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ）。 如果 eOriConv 输入 SMC_NCInterpreter 功能块实例包含值 SMC_ORI_CONVENTION.ADDAXES 则无法旋转 DCS。 G54\/G55\/G56 被解释为附加样条轴值。可以进行移位。 例子 方向约定在示例中定义为标准 Y 约定（ eOriConv = SMC_ORI_CONVENTION.ZYZ ）。一般来说对于 G54 ： X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W 在 MCS 中提供绝对值。 G55 ： X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W 在 DCS 中提供一个相对值。 G56 ： X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W 在 DCS 中提供了一个绝对的新值。 G54 绝对定向 N01 G54 X10 A30 B0 C0 G54 导致移位和旋转。位置和方向绝对提供给 MCS。 使用 G55 进行相对定向 N01 G54 X10 A30 B0 C0 (Bezieht sich auf MCS)\nN02 G55 Y10 A0 B30 C0 (Bezieht sich auf das in 01 definierte DCS) G54 导致在 X 方向上移动 10 个单位并绕 Z 轴旋转 30° 绝对到 MCS。在块 02 中，DCS 在旋转的 Y 轴方向上再移动 10 个单位，然后围绕旋转的 Y 轴再旋转 30°。因此，块 02 中的转换是相对于块 01 中的转换。 用 G56 参考当前方向 N01 G01 X10 A10 B90 C10 (Orientierung ist A=10°, B=90°, C=10°)\nN02 G56 A0 B0 C0 (DCS wird auf X=10, A=10°, B=90°, C=10° gesetzt) G56 导致 DCS 的当前方向（在示例中的块 01 中编程）被设置为参考。 示例：弧 N0 G17\nN0 G54 A0 B90 C0 选定的圆形平面相对于 DCS 进行解释。在示例中，X\/Y 平面选择为 G17 然后 DCS 绕 Y 轴旋转 90°。然后在 DCS 中选择的平面和以前一样是 X\/Y 平面。这对应于 MCS 中的 X\/Z 平面。 和 G17 ，选择 X\/Y 平面。然后 DCS 旋转 90°。这导致 X\/Y 平面在 DCS 中像以前一样被激活。这对应于 MCS 中的 X\/Y 平面。 在 2.5D 模式下（ G15 )，仅允许绕 Z 轴旋转。绕其他轴旋转会导致解码器发出错误 ( SMC_DEC_DCS_2D_NOT_IN_XY_PLANE ）因此，MCS 的 X\/Y 平面始终保持设置为 2.5D 模式。 " }, 
{ "title" : "缩放坐标系 ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_52b3763cadb811e79ffc84f8a2d3d270", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 移动、旋转和缩放坐标系 \/ 缩放坐标系 ", 
"snippet" : "如果在不等比例缩放后编程旋转，则可能会发生剪裁。在这种情况下，错误 SMC_DEC_ROTATION_AFFECTS_SCALING 未发行。 必须指定所有三个比例因子或根本不指定。 绝对缩放 句法： G54 I<i> J<j> K<k> 一个坐标系可以在三个空间方向上拉伸或压缩 X\/Y\/Z 彼此独立。您可以为每个方向指定一个因子。为 I 中的 X、J 中的 Y 和 K 中的 Z 指定比例因子。比例因子 > 1 扩展。缩放因子 < 1 进行压缩。 扩展 10 倍： N01 G01 X10 N02 G54 A90 B0 C0 I10 J1 K1 N03 G01 X10 Y20 N04 G01 X...", 
"body" : "如果在不等比例缩放后编程旋转，则可能会发生剪裁。在这种情况下，错误 SMC_DEC_ROTATION_AFFECTS_SCALING 未发行。 必须指定所有三个比例因子或根本不指定。 绝对缩放 句法： G54 I<i> J<j> K<k> 一个坐标系可以在三个空间方向上拉伸或压缩 X\/Y\/Z 彼此独立。您可以为每个方向指定一个因子。为 I 中的 X、J 中的 Y 和 K 中的 Z 指定比例因子。比例因子 > 1 扩展。缩放因子 < 1 进行压缩。 扩展 10 倍： N01 G01 X10\nN02 G54 A90 B0 C0 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 所有目标点在旋转的 X 轴方向上扩展 10 倍。 以下代码生成相同的路径： N01 G01 X10\nN02 G01 X-20 Y100\nN03 G01 X-10 Y50. 如果 I、J 和 K 均未指定，则先前设置的值保持不变： N01 G54 I10 J1 K1\nN02 G54 X1\nN03 G01 X10 使用以下代码实现相同的路径： N01 G01 X101 相对标度 句法： G55 I<i> J<j> K<k> 比例因子 > 1 扩展。缩放因子 < 1 进行压缩。缩放因子相乘。 扩展 100 倍： N01 G54 I10 J1 K1\nN02 G55 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 以下代码导致相同的缩放： N01 G55 I100 J1 K1 圆形缩放 只有当元素在缩放后仍然是圆弧（不是椭圆）时，圆弧的缩放才有效。 有效路径结果： 当所有三个比例因子都相同时 当圆形平面是 DCS 的主要平面之一且对应的两个比例因子为相同值时 " }, 
{ "title" : "镜像坐标系 ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_adba25b098ef7863c0a8646324d700b4", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 移动、旋转和缩放坐标系 \/ 镜像坐标系 ", 
"snippet" : "具有负缩放因子的绝对缩放 I , J ， 或者 K 导致当前坐标系的镜像。 负比例因子 G54 A30 B0 C0 I-1 J1 K1...", 
"body" : "具有负缩放因子的绝对缩放 I , J ， 或者 K 导致当前坐标系的镜像。 负比例因子 G54 A30 B0 C0 I-1 J1 K1 " }, 
{ "title" : "模式 ", 
"url" : "_sm_cnc_din66025_modi.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 模式 ", 
"snippet" : "功能 ：这些命令确定坐标和轴中点是被解释为绝对值还是相对坐标。 G代码 描述 G90 该坐标 （ X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) 被解释为绝对值。 （这是默认设置。） G91 该坐标 （ X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) 被解释为相对于当前位置的值。 G98 轴中点 ( I \/ J \/ K ) 被解释为绝对值。 G99 轴中点 ( I \/ J \/ K ) 被解释为相对于起始位置的值。 （这是默认设置。） 句法 G90 G91 G98 G99 例子 坐标值作为绝对值 插值器移动到 10\/...", 
"body" : "功能 ：这些命令确定坐标和轴中点是被解释为绝对值还是相对坐标。 G代码 描述 G90 该坐标 （ X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) 被解释为绝对值。 （这是默认设置。） G91 该坐标 （ X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) 被解释为相对于当前位置的值。 G98 轴中点 ( I \/ J \/ K ) 被解释为绝对值。 G99 轴中点 ( I \/ J \/ K ) 被解释为相对于起始位置的值。 （这是默认设置。） 句法 G90\nG91\nG98\nG99 例子 坐标值作为绝对值 插值器移动到 10\/10，然后移动到 100\/10。坐标被解释为绝对值。 N0 G90\nN10 G1 X10 Y10 F100 (Startposition)\nN20 G1 X100 (Nächste Position) 坐标值作为相对值 内插器移动到 10\/10，然后移动到 110\/10。坐标被解释为相对值。 N0 G91\nN10 G1 X10 Y10 F100\nN20 G1 X100 坐标值作为 I\/J\/K 中的绝对值 半圆的中点在 150\/0。坐标被解释为绝对值。 N00 G98\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I150 J0 F100 坐标值作为 I\/J\/K 中的相对值 半圆的中点在 150\/0。坐标被解释为相对值。 N00 G99\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I50 J0 F100 有关更多信息，请参阅： 将单个附加轴配置为模轴 (PA\/PB\/...)" }, 
{ "title" : "停留时间 ", 
"url" : "_sm_cnc_din66025_delay.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 停留时间 ", 
"snippet" : "G代码 ： G4 功能 ：该命令使内插器在特定时间内保持在当前位置。 例子 停留时间 N0 G4 T1 内插器暂停一秒钟。...", 
"body" : "G代码 ： G4 功能 ：该命令使内插器在特定时间内保持在当前位置。 例子 停留时间 N0 G4 T1 内插器暂停一秒钟。 " }, 
{ "title" : "开关点（H 功能） ", 
"url" : "_sm_cnc_din66025_hfunction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 开关点（H 功能） ", 
"snippet" : "功能 ：开关点功能或 H 功能激活二进制、路径相关的开关。最多三个开关点（ MAX_SWITCHES ) 可以为每个路径元素处理。 句法 [G-Befehl] H O\/L 首先定义切换点编号H<number>，然后将切换点在路径元素中的位置定义为绝对（L<位置>字）或相对（O<位置>字）。 G码字 描述 H{-}<编号> H函数的数量 如果 H 编号为正，则相应的开关功能打开。如果 H 数为负，则关闭开关功能。 H 数为非零值，范围为 -32768 到 32767。 O<位置> 路径元素中的相对位置 [0…1] 0：元素的开始 1：结束 L<位置> L>0：到起点的距离 L<0：到终点的距离 ...", 
"body" : "功能 ：开关点功能或 H 功能激活二进制、路径相关的开关。最多三个开关点（ MAX_SWITCHES ) 可以为每个路径元素处理。 句法 [G-Befehl] H O\/L 首先定义切换点编号H<number>，然后将切换点在路径元素中的位置定义为绝对（L<位置>字）或相对（O<位置>字）。 G码字 描述 H{-}<编号> H函数的数量 如果 H 编号为正，则相应的开关功能打开。如果 H 数为负，则关闭开关功能。 H 数为非零值，范围为 -32768 到 32767。 O<位置> 路径元素中的相对位置 [0…1] 0：元素的开始 1：结束 L<位置> L>0：到起点的距离 L<0：到终点的距离 图示 在图形编辑器中，您可以使用鼠标沿路径移动开关点。当鼠标移到 H 函数上时，会显示带有 H 函数的 H 编号的工具提示。 对 SMC_Interpolator 功能块 内插器将最后切换的 H 号发送到 iLastSwitch 输出。 iLastSwitch H 功能开启时为正。 这 dwSwitches 输出是位掩码。位数 i 指示当前是否设置了 H 功能 (i+1)。 如果 H 数在 1 到 32 之间，则在插值器中设置相应的位 dwSwitches 输出。 -1 到 -32 之间的负值会重置该位。这 iLastSwitch 输出具有上次运行切换点的编号，即使该值超出 -32 到 32 的范围。 例子 通过相对于元件的位置关闭开关点 2 在元件的第一季度之后，开关点 2 在位置 X=40\/Y=25 处关闭。 N90 G1 X20 Y20\nN100 G1 X100 Y40 H-2 O0.25 使用相对于起点和终点的位置打开和关闭开关点 2 开关点 2 在位置 X=40 处打开，即路径元素起点后 20 个单位。开关点 2 在位置 X=90 处关闭，即终点前 10 个单位。 N90 G1 X20\nN100 G1 X100 H2 L20 H-2 L-10 " }, 
{ "title" : "功能 ", 
"url" : "_sm_cnc_din66025_mfunction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 功能 ", 
"snippet" : "功能 ：M 功能或附加功能在 G 代码插补期间开始动作。 插值器减速到速度 0，将排队的 M 函数的编号发送到输出 wM ，并等待确认 bAcknM 在再次加速之前。与切换点相反，程序保持在当前位置，直到通过设置插补器的输入来确认 M 功能。 如果 SMC_PreAcknowledgeM 执行，然后功能块提前确认 M 功能。如果功能块按时执行，则内插器不会停止，程序将继续执行，就好像 M 指令不存在一样。 M 功能由应用程序实现，而不是由系统定义。 句法 M K L O G码字 描述 M M功能编号，M > 0 注意：数字 65533–65535 保留用于内部功能。 K 数字参数 ( LREA...", 
"body" : "功能 ：M 功能或附加功能在 G 代码插补期间开始动作。 插值器减速到速度 0，将排队的 M 函数的编号发送到输出 wM ，并等待确认 bAcknM 在再次加速之前。与切换点相反，程序保持在当前位置，直到通过设置插补器的输入来确认 M 功能。 如果 SMC_PreAcknowledgeM 执行，然后功能块提前确认 M 功能。如果功能块按时执行，则内插器不会停止，程序将继续执行，就好像 M 指令不存在一样。 M 功能由应用程序实现，而不是由系统定义。 句法 M K L O G码字 描述 M M功能编号，M > 0 注意：数字 65533–65535 保留用于内部功能。 K 数字参数 ( LREAL ) L 数字参数 ( LREAL ) O 带有 O$var$ 类型变量的引用 SMC_M_PARAMETERS 包含其他参数。在应用程序中，通过函数在运行时读取变量的参数值 SMC_GetMParameters .此外，所有参数在解码时评估并保存在数据结构中 SMC_GEOINFO 缓冲区的 SMC_OUTQUEUE .通常，这会在插值器处执行 M 函数之前发生。 这样变量就可以被使用的功能块找到（例如 SMC_ReadNCFile2 ) 在解码时，必须将其添加到其 SMC_VARLIST 与类型 SMC_VARTYPE.SMC_TYPE_USERDEF . 例子 M 带参数 M 功能 10 启动。对于 N90 的程序执行，系统等待直到确认可用。 N90 M10 K100.7 M 带附加参数 M 功能 10 启动。用户定义的数据结构 g_myMParams （数据类型 SMC_M_PARAMETER ) 被引用 O$var$ . g_myMParams 包含附加参数。 K、L 的值以及来自 g_myMParams 可以在 M 功能的路径停止时读取。这是通过调用功能块的实例来完成的 SMC_GetMParameters . N150 M13 O$g_myMParams$ " }, 
{ "title" : "与内插器的时序同步 ", 
"url" : "_sm_cnc_din66025_time_synchronisation_with_interpolator.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 与内插器的时序同步 ", 
"snippet" : "G代码 ： G75 功能 ：该命令阻止解码器的功能块处理 G 代码，直到插值器遍历所有先前的对象。当内插器到达 G75 ，所有队列都是空的，NCDecoder 和所有预处理功能块继续运行。 此函数对于使用变量很有用。解码器在处理相应行时替换变量。但是，根据队列机制，插值器的执行发生在指定时间之后。您可以使用 G75 用于等待和同步变量的评估以及插值器的后续处理。 句法 G75 例子 N10 G1 X100 N20 G75 N30 G1 Y$g_y$ 变量 g_y 可与元素 G1 一起使用且未预先检测。如果 G75 没有插入，那么 NCDecoder 在检测到值之前立即处理第 30 行。 G75...", 
"body" : "G代码 ： G75 功能 ：该命令阻止解码器的功能块处理 G 代码，直到插值器遍历所有先前的对象。当内插器到达 G75 ，所有队列都是空的，NCDecoder 和所有预处理功能块继续运行。 此函数对于使用变量很有用。解码器在处理相应行时替换变量。但是，根据队列机制，插值器的执行发生在指定时间之后。您可以使用 G75 用于等待和同步变量的评估以及插值器的后续处理。 句法 G75 例子 N10 G1 X100\nN20 G75\nN30 G1 Y$g_y$ 变量 g_y 可与元素 G1 一起使用且未预先检测。如果 G75 没有插入，那么 NCDecoder 在检测到值之前立即处理第 30 行。 G75 对 CNC 编辑器或 CNC 编辑器生成的路径没有任何影响 SMC_OutQueue . " }, 
{ "title" : "跳 ", 
"url" : "_sm_cnc_din66025_jump.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 跳 ", 
"snippet" : "G代码 : G20 功能 : 命令执行条件跳转。 句法 G20 L K G码字 描述 L 跳跃目标： 定义的行号（例如： L20 ) 跳转标签 跳转由问号和索引定义（例如： L?4 ）。跳转目标本身的命令由感叹号和相应的索引标识（例如： L!4 ）。跳转目标可以附加到任何 G 代码指令。 当目标线未知时，此跳转用于自动生成的 CNC 程序。 带有未知目标的跳转标签仅适用于在线解码器（不在 CNC 编辑器中）。 要求：带有跳转标签的行必须位于带有跳转命令的行之后。 “跳回”是不可能的。如果未定义“目标行”，则不执行跳转命令之后的命令。 K 健康）状况 如果 K <> 0，则执行跳转。如果未定义 ...", 
"body" : "G代码 : G20 功能 : 命令执行条件跳转。 句法 G20 L K G码字 描述 L 跳跃目标： 定义的行号（例如： L20 ) 跳转标签 跳转由问号和索引定义（例如： L?4 ）。跳转目标本身的命令由感叹号和相应的索引标识（例如： L!4 ）。跳转目标可以附加到任何 G 代码指令。 当目标线未知时，此跳转用于自动生成的 CNC 程序。 带有未知目标的跳转标签仅适用于在线解码器（不在 CNC 编辑器中）。 要求：带有跳转标签的行必须位于带有跳转命令的行之后。 “跳回”是不可能的。如果未定义“目标行”，则不执行跳转命令之后的命令。 K 健康）状况 如果 K <> 0，则执行跳转。如果未定义 K，则使用内部解码器变量。 内部解码器变量的值可以定义为 改变变量的值 命令。此内部变量的默认值为 -1 。 示例：执行跳转直到内部计数器 = 0 十行通过相对模式链接在一起。这导致线移动到 100\/100。 N00 G36 D10 (set counter to 10)\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G37 D-1 (decrement counter)\nN40 G20 L20 (jump, if counter != 0) 示例：在解码时评估跳转条件 要求：变量的行为 bvar 在应用程序中编程。如果 X 轴超过位置 15，则 bvar FALSE 设置。 ( bVar 最初设置为 TRUE .) 在第一个程序循环中，X 位置为 10，程序跳转到第 20 行。循环继续运行，因为条件的评估发生在解码时，内插器尚未启动或忙于处理缓冲区开头的对象。满足此条件并且解码器仅在生成足够多的对象以致缓冲区已满且内插器开始处理后才跳出循环。 在第二次运行中，X 轴尚未到达位置 20。条件不满足且 bVar 未设置为 FALSE 在 IEC 代码中。 N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G20 L20 K$bvar$ (jump, if counter != 0) 示例：插入时序同步 G75 执行内插器的定时同步。 G75 暂停解码器处理，直到内插器和机械装置到达各自的位置。 N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN25 G75\nN30 G20 L20 K$x$ (jump, if counter != 0) 有关更多信息，请参阅： 与内插器的时序同步示例：跳转到跳转标签 注意：跳转到跳转标签仅在在线解码器中起作用（不在 CNC 编辑器中）。 N0 G16 F100 E100 E-100\nN10 G20 L?4 \/\/unconditional jump to the unknown target with index 4\nN15 G20 L60\nN20 G1 X1\nN30 G1 X1 L!5 \/\/resolution unknown jump target with index 5\nN40 G1 Z1 L!4 \/\/resolution unknown jump target with index 4\nN50 G20 L15\nN55 G1 Y1\nN60 G0 X0 Y0 Z0 " }, 
{ "title" : "弧 ", 
"url" : "_sm_cnc_din66025_arc.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 弧 ", 
"snippet" : "G代码 ： G2 , G3 功能 ：该命令从当前位置沿圆形路径插入一个圆弧到目标位置。 G2 顺时针移动和 G3 逆时针移动。 弧定义如下： 半径法 目标坐标+半径：目标坐标在X\/Y\/Z 中定义。曲线由半径 R 定义。 中点法 目标坐标+中点坐标：目标坐标定义为X\/Y\/Z。曲线由中点坐标 I\/J\/K 定义。中点坐标位于起点和终点的垂直平分线上。如果不是这种情况，则会自动更正中点坐标。偏差不得大于 10%。 开口角度法 开角+中点坐标：开角定义为T，中点坐标定义为I\/J\/K。目标位置是自动计算的。 不一致的参数会导致走一条线而不是走一圈。示例：如果半径小于起点和目标之间距离的一半，则无法校正偏差...", 
"body" : "G代码 ： G2 , G3 功能 ：该命令从当前位置沿圆形路径插入一个圆弧到目标位置。 G2 顺时针移动和 G3 逆时针移动。 弧定义如下： 半径法 目标坐标+半径：目标坐标在X\/Y\/Z 中定义。曲线由半径 R 定义。 中点法 目标坐标+中点坐标：目标坐标定义为X\/Y\/Z。曲线由中点坐标 I\/J\/K 定义。中点坐标位于起点和终点的垂直平分线上。如果不是这种情况，则会自动更正中点坐标。偏差不得大于 10%。 开口角度法 开角+中点坐标：开角定义为T，中点坐标定义为I\/J\/K。目标位置是自动计算的。 不一致的参数会导致走一条线而不是走一圈。示例：如果半径小于起点和目标之间距离的一半，则无法校正偏差。如果定义的起点和目标位置的中点具有不同的距离，也会出现这种情况。 句法 G2 X Y Z R A B C P Q U V W F E H L\/O D S\nG2 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG2 I J K T A B C P Q U V W F E H L\/O D S\nG3 X Y Z R A B C P Q U V W F E H L\/O D S\nG3 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG3 I J K T A B C P Q U V W F E H L\/O D S G码字 描述 X Y Z 笛卡尔坐标轴的目标位置 R 圆半径 I J K 圆中点坐标 T 开启角度（度） A B C P Q U V W 附加轴的目标位置 F E 路径速度、路径加减速 H L\/O 开关点 D 刀具半径 S 个人资料 图示 ：圆弧由黑色端点表示。选择元素时可以移动端点。 3D 模式下的圆弧 在 3D 模式下，系统通过 G15-G19 定义的插补平面定义圆弧。 例子 X\/Z 平面上的一个半圆和 X\/Y 平面上的一个半圆 N10 G1 X100 Y100\nN15 G18\nN20 G2 X200 R50\nN25 G17\nN30 G3 X100 R50 " }, 
{ "title" : "半径法 ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_535707857cba3404c0a86463692656db", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 弧 \/ 半径法 ", 
"snippet" : "您可以使用半径方法生成 < 180° 的圆弧。半径法对两条圆弧有效。一个比半圆小，一个比半圆大。系统始终使用较小的弧。 例子 半圆 N10 G1 X100 Y100 F100 N20 G2 X200 Y100 R50 使用带 I\/J\/K 的中点法生成张角大于 180° 的圆弧。半径方法是唯一的，除非圆的起点和终点相同。这定义了一个空圆或一个完整的圆。在这种情况下，系统会插入一个完整的圆。...", 
"body" : "您可以使用半径方法生成 < 180° 的圆弧。半径法对两条圆弧有效。一个比半圆小，一个比半圆大。系统始终使用较小的弧。 例子 半圆 N10 G1 X100 Y100 F100\nN20 G2 X200 Y100 R50 使用带 I\/J\/K 的中点法生成张角大于 180° 的圆弧。半径方法是唯一的，除非圆的起点和终点相同。这定义了一个空圆或一个完整的圆。在这种情况下，系统会插入一个完整的圆。 " }, 
{ "title" : "中点法 ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_7dc8851b7cba3404c0a864637c8195be", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 弧 \/ 中点法 ", 
"snippet" : "如果使用中点法，则可以区分坐标 I\/J\/K 是相对的还是绝对的。如果 I , J ， 和 K 未正确指定，则不可能出现圆弧，系统将其替换为一条线。如果正确，则中点与起点或终点之间的距离相同。 例子 与半径法相同的半圆；通过相对中点指定 N10 G1 X100 Y100 F100 N15 G99 N20 G2 X200 Y100 I50 J0 与半径法相同的半圆；通过绝对中点指定 N10 G1 X100 Y100 F100 N15 G98 N20 G2 X200 Y100 I150 J100...", 
"body" : "如果使用中点法，则可以区分坐标 I\/J\/K 是相对的还是绝对的。如果 I , J ， 和 K 未正确指定，则不可能出现圆弧，系统将其替换为一条线。如果正确，则中点与起点或终点之间的距离相同。 例子 与半径法相同的半圆；通过相对中点指定 N10 G1 X100 Y100 F100\nN15 G99\nN20 G2 X200 Y100 I50 J0 与半径法相同的半圆；通过绝对中点指定 N10 G1 X100 Y100 F100\nN15 G98\nN20 G2 X200 Y100 I150 J100 " }, 
{ "title" : "开口角度法 ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_955d99e37cba3404c0a864634d5c784c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 弧 \/ 开口角度法 ", 
"snippet" : "如果您通过张角 T 定义圆，则最多允许三个完整的圆 (T ≤ 1080)。 开角法适用于大于 180°的圆弧。 例子 与半径法相同的半圆；通过张角指定 N10 G1 X100 Y100 N15 G99 N20 G2 I50 J0 T180 螺旋（两个完整的圆圈） N10 G1 X100 Y100 N15 G99 N20 G2 I50 J0 T720...", 
"body" : "如果您通过张角 T 定义圆，则最多允许三个完整的圆 (T ≤ 1080)。 开角法适用于大于 180°的圆弧。 例子 与半径法相同的半圆；通过张角指定 N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T180 螺旋（两个完整的圆圈） N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T720 " }, 
{ "title" : "椭圆 ", 
"url" : "_sm_cnc_din66025_ellipse.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 椭圆 ", 
"snippet" : "G代码 ： G8 , G9 功能 ：该命令通过目标坐标X\/Y、椭圆中点I\/J、椭圆主轴方向K、主轴和副轴之间的长度比R指定椭圆弧。 句法 G8 X Y Z R I J K A B C P Q U V W F E H L\/O D S G9 X Y Z R I J K A B C P Q U V W F E H L\/O D S G码字 描述 X Y Z 笛卡尔坐标轴的目标位置 R 主轴和副轴之间的长度比 R。 范围： 0 < R <= 1 仅当椭圆弧不是由主轴的端点、中点和斜率唯一定义时，才使用 R。当两个端点与主轴的距离相同时，就会出现这种情况。然后，两个端点与次轴的距离必须相同。否则，没有椭圆...", 
"body" : "G代码 ： G8 , G9 功能 ：该命令通过目标坐标X\/Y、椭圆中点I\/J、椭圆主轴方向K、主轴和副轴之间的长度比R指定椭圆弧。 句法 G8 X Y Z R I J K A B C P Q U V W F E H L\/O D S\nG9 X Y Z R I J K A B C P Q U V W F E H L\/O D S G码字 描述 X Y Z 笛卡尔坐标轴的目标位置 R 主轴和副轴之间的长度比 R。 范围： 0 < R <= 1 仅当椭圆弧不是由主轴的端点、中点和斜率唯一定义时，才使用 R。当两个端点与主轴的距离相同时，就会出现这种情况。然后，两个端点与次轴的距离必须相同。否则，没有椭圆穿过这些点，系统会用直线替换椭圆 I J 中点 K 椭圆主轴的方向（以度为单位） 0：X轴方向 90：Y轴方向 -90：与Y轴方向相反 A B C P Q U V W 附加轴的目标位置 F E 路径速度、路径加减速 H L\/O 开关点 D 刀具半径 S 个人资料 椭圆是一个 2.5D 对象。这意味着椭圆始终属于 X\/Y 平面。不支持其他平面中的椭圆。 例子 N10 G0 X100 Y100 F100\nN15 G98\nN20 G8 X200 Y100 I150 J100 K45 R0.5 " }, 
{ "title" : "直线运动 ", 
"url" : "_sm_cnc_din66025_line.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 直线运动 ", 
"snippet" : "G代码 ： G1 功能 ：该定位指令执行直线插补。直线插补将插补点从当前位置移动到直线上定义的目标坐标。所有轴同时到达那里。必须为线的描述定义目标坐标 (X\/Y\/Z)。 除了空间运动之外，您还可以为附加轴 A\/B\/C\/P\/Q\/U\/V\/W 指定目标位置，这些轴与笛卡尔目标坐标同时到达。 两个连续的相同位置总是会导致运动停止在该位置。当后续路径稳定连接并且可以不间断地行驶时，也会发生停止。 句法 G1 X Y Z A B C P Q U V W F E H L\/O D S G码字 描述 X Y Z 笛卡尔坐标轴的目标位置 A B C P Q U V W 附加轴的目标位置 F E 路径速度、路径加减...", 
"body" : "G代码 ： G1 功能 ：该定位指令执行直线插补。直线插补将插补点从当前位置移动到直线上定义的目标坐标。所有轴同时到达那里。必须为线的描述定义目标坐标 (X\/Y\/Z)。 除了空间运动之外，您还可以为附加轴 A\/B\/C\/P\/Q\/U\/V\/W 指定目标位置，这些轴与笛卡尔目标坐标同时到达。 两个连续的相同位置总是会导致运动停止在该位置。当后续路径稳定连接并且可以不间断地行驶时，也会发生停止。 句法 G1 X Y Z A B C P Q U V W F E H L\/O D S G码字 描述 X Y Z 笛卡尔坐标轴的目标位置 A B C P Q U V W 附加轴的目标位置 F E 路径速度、路径加减速 H L\/O 开关点 D 刀具半径 S 个人资料 例子 线性插值 刀具定位在起始位置 0\/0\/0（预设），然后以速度 1、加速度 10 和减速度 20 直线移动到目标位置 1\/2\/3。同时，方向轴 A 以 180 度行进： N010 G01 X1 Y2 Z3 A180 F1 E10 E-20 开始位置 起始位置 50\/50\/50，线性插补从 50\/50\/50 到 64\/30\/0，进给 100 N000 G92 X50 Y50 Z50 F100\nN010 G01 X64 Y30 Z0 " }, 
{ "title" : "抛物线 ", 
"url" : "_sm_cnc_din66025_parabel.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 抛物线 ", 
"snippet" : "G代码 ： G6 功能 ：该命令内插一条由端点 X\/Y\/Z 和顶点 I\/J 的坐标定义的抛物线。顶点是元素的切线与起点和终点的连接线平行的点。 抛物线是始终位于 X\/Y 平面中的 2.5D 对象。不支持其他平面上的抛物线。 句法 G6 X Y Z I J A B C P Q U V W F E H L\/O D S G码字 描述 X Y Z 笛卡尔坐标轴的目标位置 I J 抛物线的顶点 A B C P Q U V W 附加轴的目标位置 F E 路径速度、路径加减速 H L\/O H函数 D 刀具半径 S 个人资料 例子 N010 G00 X100 Y200 Z0 F100 N020 G98 N03...", 
"body" : "G代码 ： G6 功能 ：该命令内插一条由端点 X\/Y\/Z 和顶点 I\/J 的坐标定义的抛物线。顶点是元素的切线与起点和终点的连接线平行的点。 抛物线是始终位于 X\/Y 平面中的 2.5D 对象。不支持其他平面上的抛物线。 句法 G6 X Y Z I J A B C P Q U V W F E H L\/O D S G码字 描述 X Y Z 笛卡尔坐标轴的目标位置 I J 抛物线的顶点 A B C P Q U V W 附加轴的目标位置 F E 路径速度、路径加减速 H L\/O H函数 D 刀具半径 S 个人资料 例子 N010 G00 X100 Y200 Z0 F100\nN020 G98\nN030 G06 X-100 Y200 Z00 I0 J0 " }, 
{ "title" : "定位 ", 
"url" : "_sm_cnc_din66025_positioning.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 定位 ", 
"snippet" : "G代码 ： G0 , G92 功能 ：这些命令定位工具。 G0 命令沿直线快速定位到定义的位置（通常无需刀具操作）。 G92 立即设置位置。结果是还会在轴上执行跳转。如果 SMC_ControlAxisByPos.bAvoidGaps:=TRUE 已设置，则不执行跳转。取而代之的是，所有轴都在最短的距离内单独移动到目标位置。可以在路径的开头插入 G92 以设置起始位置 在一系列 G92 指令中，最后一个先执行。前面的就跳过了。如果插入一个坐标相同的 G1 程序段，则跳转执行一个循环。如果跳转命令的位置之间的路径不重要，但应尽可能快地移动指定位置，则这是一个优势。这 SMC_ControlAxi...", 
"body" : "G代码 ： G0 , G92 功能 ：这些命令定位工具。 G0 命令沿直线快速定位到定义的位置（通常无需刀具操作）。 G92 立即设置位置。结果是还会在轴上执行跳转。如果 SMC_ControlAxisByPos.bAvoidGaps:=TRUE 已设置，则不执行跳转。取而代之的是，所有轴都在最短的距离内单独移动到目标位置。可以在路径的开头插入 G92 以设置起始位置 在一系列 G92 指令中，最后一个先执行。前面的就跳过了。如果插入一个坐标相同的 G1 程序段，则跳转执行一个循环。如果跳转命令的位置之间的路径不重要，但应尽可能快地移动指定位置，则这是一个优势。这 SMC_ControlAxisByPos* 功能块检测到指定值的跳转，暂停内插器，并尽可能快地单独内插每个轴。 两个连续的相同位置总是会导致运动停止在该位置。当后续路径稳定连接并且可以不停止行驶时，也会发生停止。 有关更多信息，请参阅以下内容的库文档 Direct Axis Control 句法 G0 X Y Z A B C P Q U V W F FF E EF H L\/O S\nG92 X Y Z A B C P Q U V W H L\/O G码字 描述 X Y Z 笛卡尔坐标轴的目标位置 A B C P Q U V W 附加轴的目标位置 E 路径加减速 EF 路径加减速只针对 G0 运动。如果设置为 EF <> 0，则 G0 运动不考虑在 E 中定义的值。 F 路径速度 FF 仅用于 G0 运动的速度。如果设置为 FF <> 0，则 G0 运动不考虑 F 中定义的值。 H L\/O H函数 S 个人资料 图示 在图形编辑器中，G0 命令用绿线表示。 G92 指令不直接表示。它们只是移动后续元素的起点。定位命令只能在 CNC 文本编辑器或表格编辑器中插入。它们可以在图形编辑器中移动。 例子 使用定义进给的线性插补定位 N0 G92 X10 Y10 Sets the start position at 10\/10\nN10 G1 X20 F10 Linear interpolation to 20\/10 with feed 10\nN20 G0 Y20 F100 Linear positioning to 20\/20 with feed 100 不同的定位方式 N0 G92 X100 Y100 F100 Sets the position at 100\/100\nN10 G1 X100 Y100 Saves the output of this position for one cycle\nN20 G92 X50 Y100 Sets the position suddenly to 50\/100 以定义的路径速度定位 N1 G0 X1000 Y0 FF1000 EF10000 EF-10000 Positioning with velocity 1000\nN2 G1 Y100 F100 E100 E-100 Interpolating positioning with velocity 100\nN3 G0 X0 Y0 Positioning with velocity 1000\nN4 G0 X1000 FF0 EF0 Positioning with velocity 100 because FF and FE are reset; thus the values in F and E are used. " }, 
{ "title" : "样条 ", 
"url" : "_sm_cnc_din66025_spline.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 样条 ", 
"snippet" : "G代码 ： G5 , G10 功能 ：该命令使用样条插值路径元素，以便从前一个路径元素到下一个路径元素的过渡相互融合而不会中断。同时，计算系统中的样条线段，使前一个路径元素的结束切线与样条的开始切线一致。同样，样条的端点切线与后续路径元素一致。 功能 ：该命令为给定位置创建一条样条线段。从前一个路径元素到后一个路径元素的过渡位置连续且相切。 句法 G5 X Y Z A B C P Q U V W F E H L\/O D S G10 X Y Z A B C P Q U V W F E H L\/O D S G码字 描述 X Y Z 笛卡尔坐标轴的目标位置 A B C P Q U V W 附加轴的目...", 
"body" : "G代码 ： G5 , G10 功能 ：该命令使用样条插值路径元素，以便从前一个路径元素到下一个路径元素的过渡相互融合而不会中断。同时，计算系统中的样条线段，使前一个路径元素的结束切线与样条的开始切线一致。同样，样条的端点切线与后续路径元素一致。 功能 ：该命令为给定位置创建一条样条线段。从前一个路径元素到后一个路径元素的过渡位置连续且相切。 句法 G5 X Y Z A B C P Q U V W F E H L\/O D S\nG10 X Y Z A B C P Q U V W F E H L\/O D S G码字 描述 X Y Z 笛卡尔坐标轴的目标位置 A B C P Q U V W 附加轴的目标位置 F E 路径速度、路径加减速 H L\/O 开关点 D 刀具半径 S 个人资料 多个连续的样条线段连接如下： 起点切线 如果存在带有刀具操作的路径元素（例如：G1、G2、G3、G8、G9），则路径元素的结束切线用作样条的起始切线。 如果刀具操作中没有可用的路径元素（例如 G0、G92、M），则起点和第一个样条点之间的连接线用作起点切线。 样条中间的切线 相邻的点是相连的。该点的切线与这条连接线（绿线）平行。 端切线 如果存在带有刀具操作的路径元素（例如：G1、G2、G3、G8、G9），则路径元素的起始切线将用作样条线的结束切线。 如果刀具操作中没有可用的路径元素（例如，G0、G92、M），则终点和第一个样条点之间的连接线用作终点切线。 例子 带圆形样条的楼梯轮廓 N0 G0 X0 Y0 Z0 F100 (Startposition)\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40 带双花键的圆形轮廓 N0 G0 X0 Y0 F100 (Startposition)\nN5 G1 X5 Y0\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN21 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40\nN45 G1 X0 Y40 X20 Y20 的样条点存在两次。这样，样条被中断并重新开始。这是由该点切线的定义方法决定的。起点和终点由前后线段的起点切线定义。 " }, 
{ "title" : "预处理 ", 
"url" : "_sm_cnc_din66025_preprocessor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 预处理 ", 
"snippet" : "G代码 : G40, G41, G42, G43, G50, G51, G52, G60, G61, G70, G71 功能 : 命令激活预处理模块，例如 SMC_SmoothPath , SMC_RoundPath , SMC_AvoidLoop , SMC_ToolCorr , SMC_ToolLengthCorr ， 和 SMC_ToolRadiusCorr . 如果 显示预处理路径 选项，则编辑的路径在图形编辑器中可见。 句法 G40 G41 D G42 D G50 G51 D G52 D G60 G61 G码字 描述 D 刀具半径或叠加半径 G51\/G52 . 对于 4.18.0.0...", 
"body" : "G代码 : G40, G41, G42, G43, G50, G51, G52, G60, G61, G70, G71 功能 : 命令激活预处理模块，例如 SMC_SmoothPath , SMC_RoundPath , SMC_AvoidLoop , SMC_ToolCorr , SMC_ToolLengthCorr ， 和 SMC_ToolRadiusCorr . 如果 显示预处理路径 选项，则编辑的路径在图形编辑器中可见。 句法 G40\nG41 D\nG42 D\nG50\nG51 D\nG52 D\nG60\nG61 G码字 描述 D 刀具半径或叠加半径 G51\/G52 . 对于 4.18.0.0 之前的版本：角度舍入\/平滑 ( G51\/G52 ) 和刀具半径校正 ( G41\/G42 ) 可以相互影响，因为两个预处理都会解释 G 代码中的每个 D 字。例如，当角度舍入以 D=5 开始时，如果半径为 1 的刀具半径校正处于活动状态，则刀具半径校正也使用半径为 5 对于版本 4.18.0.0 及更高版本：角度四舍五入\/平滑 ( G51\/G52 ) 和刀具半径校正 ( G41\/G42 ) 可以同时使用而不会相互影响。以下行为适用于此。 用于刀具半径校正 ( G41\/G42 )：默认情况下，使用的 “工具” 半径为 SMC_ToolRadiusCorr 是 0。如果在 G 字之后指定 D 字 G41\/G42 ，然后功能块调整 “工具” 半径并考虑在内。如果未指定任何值，则使用当前设置的 “工具” 半径。 用于角度倒圆\/平滑 ( G51\/G52 )：默认情况下，使用的 “平滑” 半径为 SMC_Round\/SmoothPath 是 0。如果在任何 G 字之后指定了 D 字（除了 G36\/G37\/G40\/G41\/G42 ）或单独使用（例如， N00 D5 ），那么这会影响当前的 “平滑” 半径，并被考虑在内 SMC_Round\/SmoothPath 功能块。 刀具校正命令 G代码 描述 G40 刀具半径补偿结束 G41 从工件左侧开始刀具半径补偿 G42 从工件右侧开始刀具半径补偿 G43 刀具长度补偿开始。 要修正的刀具偏置由参数指定 I, J K （为了 X, Y, Z ）。通过将参数设置为零来禁用刀具长度补偿。在激活或停用之后，执行斜进或斜出。 有关更多详细信息，请参阅： SMC_ToolLengthCorr 注意：刀具长度在有效刀具半径补偿期间不得更改，因为它会破坏路径。 刀具长度校正 (G43) 仅在在线解码器中起作用（不在 CNC 编辑器中）。 用于角度舍入和角度平滑的命令 G代码 描述 G50 圆角末端和平滑 G51 开始角度平滑 SMC_SmoothPath G52 通过以下方式开始圆角 SMC_RoundPath G70 附加轴的平滑结束 SMC_SmoothAddAxes G71 通过以下方式开始平滑附加轴 SMC_SmoothAddAxes 循环抑制命令 G代码 描述 G60 循环抑制功能结束 G61 通过以下方式启动循环抑制功能 SMC_AvoidLoop 示例：角度平滑 N0 G51 D10 F100\nN10 G01 X$g_x$ Y0 F50 E30 E-30\nN20 G01 X0 Y$g_y$\nN30 G01 X0 Y0\nN40 G50 " }, 
{ "title" : "附加样条轴 A、B、C ", 
"url" : "_sm_cnc_din66025_additional_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 附加样条轴 A、B、C ", 
"snippet" : "G码字 ： A , B , C 函数 : 使用 A ， B ，以及 C 来定义其他样条轴的目标位置。这些轴类似于 P ， Q ， U ， V ，以及 W 。 P ， Q ， U ，以及 V 是线性插值的， A ， B ，以及 C 使用三度多项式进行插值。 使用 A ， B ，或 C 不包括使用附加轴 U ， V ，以及 W 因为 U ， V ，以及 W 定义梯度。 斧头 A ， B ，或 C 可使用第 3、4 或 5 位进行选择 wAxis 的输入 SMC_limitDynam 或者 wAddAxis 的 smc_checkforLimits 。 这个 smc_smoothPath ， smc...", 
"body" : "G码字 ： A , B , C 函数 : 使用 A ， B ，以及 C 来定义其他样条轴的目标位置。这些轴类似于 P ， Q ， U ， V ，以及 W 。 P ， Q ， U ，以及 V 是线性插值的， A ， B ，以及 C 使用三度多项式进行插值。 使用 A ， B ，或 C 不包括使用附加轴 U ， V ，以及 W 因为 U ， V ，以及 W 定义梯度。 斧头 A ， B ，或 C 可使用第 3、4 或 5 位进行选择 wAxis 的输入 SMC_limitDynam 或者 wAddAxis 的 smc_checkforLimits 。 这个 smc_smoothPath ， smc_smoothMerg ， smc_smoothbspline ，以及 smc_recomputeABCSLOPES 功能块自动确定附加轴的斜率。这意味着 U ， V ，或 W 不是必需的。 实施例1 G代码 N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X100 A100 P100 线性附加轴 P 线性插入到行进路径中。因此，它的时间曲线返回路径速度的曲线。 附加样条轴 A 作为多项式函数进行插值。 实施例2 使用样条函数是必要的，尤其是在使用具有恒定切线过渡的路径时，插值器不必将其减速到速度 0： G代码 N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X50 A40 P40\nN30 G1 X100 A100 P100 在线性情况下，您会看到速度跳跃，因为 40 个单位的附加轴在第一部分中的 50 个路径单位上运行，而附加轴的 60 个单位在第二个部分中的 50 个路径单位上运行。因为路径速度仅在路径笛卡尔空间之后定义 (XYZ)，所以 X 中的恒定速度会导致 P 中的速度跳跃： 样条轴显示以下轮廓： 实施例3 A、B、C 轴在终点位置的斜率可由 U、V、W 字定义。坡度的单位是空间中每个路径单位的附加轴的路径单位。 G代码 N10 G0 X0 A0 F10 E30 E-30\nN20 G1 X100 A100 U1.5\nN30 G1 X200 A200 U0 适用用户编程的 A 轴斜率 (U=2)，因为该程序包含之间的连续过渡 N20 和 N30 。因此，对于 X=100，A 轴位置的增长速度是路径长度的两倍 " }, 
{ "title" : "使用多个对象平滑附加轴运动 ", 
"url" : "_sm_cnc_din66025_smooth_additional_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 使用多个对象平滑附加轴运动 ", 
"snippet" : "G代码 ： G70 , G71 功能 ： G71 开始和 G70 结束在 L 中给定的附加轴上的运动平滑并在多个对象上传播。 句法 G70 L4 G71 L4 G码字 附加轴 L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W...", 
"body" : "G代码 ： G70 , G71 功能 ： G71 开始和 G70 结束在 L 中给定的附加轴上的运动平滑并在多个对象上传播。 句法 G70 L4\nG71 L4 G码字 附加轴 L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W " }, 
{ "title" : "将单个附加轴配置为模轴 (PA\/PB\/...) ", 
"url" : "_sm_cnc_din66025_define_additional_axis_modulo.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 将单个附加轴配置为模轴 (PA\/PB\/...) ", 
"snippet" : "功能： 对于 A、B、C、P、Q、U、V 和 W 轴，可以通过设置字来指定模周期 PA , PB , PC 等。默认情况下， PA , PB 等的值为 0，表示轴是线性的。如果将附加轴配置为模数轴，则始终插入从起始位置到目标位置的最短距离。对于 360 的模周期，从起始位置 270 到目标位置 45 的行程如下：在正方向（过去 360）总共 135 个单位，而不是在负方向 225 个单位，如线性时间线. 插值器的位置输出可以在区间 [0..period limit[. （例如，对于 360 的模周期，400 而不是 40。）位置通过跟随 POU 移动到模范围，例如 SMC_ControlAxi...", 
"body" : "功能： 对于 A、B、C、P、Q、U、V 和 W 轴，可以通过设置字来指定模周期 PA , PB , PC 等。默认情况下， PA , PB 等的值为 0，表示轴是线性的。如果将附加轴配置为模数轴，则始终插入从起始位置到目标位置的最短距离。对于 360 的模周期，从起始位置 270 到目标位置 45 的行程如下：在正方向（过去 360）总共 135 个单位，而不是在负方向 225 个单位，如线性时间线. 插值器的位置输出可以在区间 [0..period limit[. （例如，对于 360 的模周期，400 而不是 40。）位置通过跟随 POU 移动到模范围，例如 SMC_ControlAxisByPos ， 或者 SMC_FollowPosition . 例子 通过模数模式对轴进行旋转控制 在块 30 中，轴 A 沿正方向移动 90°，从 270° 到 360°=0°。 N10 PA360 (A axis has a period of 360 degree)\nN20 G92 A270 (Set the position of A axis to 270)\nN30 G1 A0 " }, 
{ "title" : "使用变量 ", 
"url" : "_sm_cnc_din66025_usage_of_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 使用变量 ", 
"snippet" : "句法 $<Variablenname>$ 变量和表达式的有效 IEC 基本类型： INT , SINT , USINT , UINT , DINT , UDINT , BYTE , WORD , DWORD , REAL ， 和 LREAL .例外情况包括 M 函数的 O 参数（它需要一个类型为 SMC_M_PARAMETERS ） 和 G36\/G37 （其中也允许字符串变量）。 可以为所有字定义变量或表达式，除了 N 个字（块号）。 IEC 表达式和变量仅在在线解码器 POU 中被它们的当前值替换。这发生在解码行时，这是在插值器中处理元素之前的一段时间。 离线模式下的变量值在 变量的离线值 ...", 
"body" : "句法 $<Variablenname>$ 变量和表达式的有效 IEC 基本类型： INT , SINT , USINT , UINT , DINT , UDINT , BYTE , WORD , DWORD , REAL ， 和 LREAL .例外情况包括 M 函数的 O 参数（它需要一个类型为 SMC_M_PARAMETERS ） 和 G36\/G37 （其中也允许字符串变量）。 可以为所有字定义变量或表达式，除了 N 个字（块号）。 IEC 表达式和变量仅在在线解码器 POU 中被它们的当前值替换。这发生在解码行时，这是在插值器中处理元素之前的一段时间。 离线模式下的变量值在 变量的离线值 对话。您可以通过 CNC → 设置变量 命令或 变量 CNC 对象属性中的按钮。 在离线模式下使用全局变量 在全局变量列表中声明变量。 至少在一个位置使用 CNC 编辑器中的变量。 执行 CNC → 设置变量 命令。 这 变量的离线值 对话框打开。 在表中指定所需的值。 例子 VAR_GLOBAL\n rVal_x1: REAL:=100;\n rVal_y1: REAL:=50;\nEND_VAR\n\n\/\/ CNC-Editor\nN0 G01 X$rVal_x1$ Y0 F50 E30 E-30\nN10 G01 X0 Y$rVal_y1$\nN20 G01 X0 Y0 在线模式下的行为 当解码器 POU 将程序作为程序变量在线处理时 SMC_CNC_REF , 可以使用变量。变量在解码器处理相应行时被替换。在在线读取的 G 代码程序中使用变量需要额外的准备 SMC_VARLIST .如果 CNC 程序编译为 SMC_OUTQUEUE ，则变量机制不起作用。这是因为路径是离线生成的，并作为应用程序的不可更改的数据结构传递。在这种情况下，编辑器将变量替换为其离线值以在离线模式下显示。 有关更多信息，请参阅： CNC 数据结构和全局访问" }, 
{ "title" : "改变变量的值 ", 
"url" : "_sm_cnc_din66025_change_variable_values.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 改变变量的值 ", 
"snippet" : "G代码 ： G36 , G37 功能 ：命令更改变量的值。 G36 将指定值写入变量。 G37 将变量增加指定的值。 O$var$ 定义被编辑的变量。 D 定义写入的值 G36 或添加 G37 .例如，该命令用于条件跳转所需的循环计数器。 句法 G36 O D G37 O D G36 的 G 代码字 描述 O 写入的变量。如果 O 未定义，则使用内部解码器变量。此内部变量的默认值为 -1 。 内部变量可用于 跳 命令。 D 新变量值 G37 的 G 代码字 O 递增的变量。如果 O 未定义，则使用内部解码器变量。 D 增量 例子 编程计数器（如果路径是在线处理的） 这 g_i 全局变量设置为 ...", 
"body" : "G代码 ： G36 , G37 功能 ：命令更改变量的值。 G36 将指定值写入变量。 G37 将变量增加指定的值。 O$var$ 定义被编辑的变量。 D 定义写入的值 G36 或添加 G37 .例如，该命令用于条件跳转所需的循环计数器。 句法 G36 O D\nG37 O D G36 的 G 代码字 描述 O 写入的变量。如果 O 未定义，则使用内部解码器变量。此内部变量的默认值为 -1 。 内部变量可用于 跳 命令。 D 新变量值 G37 的 G 代码字 O 递增的变量。如果 O 未定义，则使用内部解码器变量。 D 增量 例子 编程计数器（如果路径是在线处理的） 这 g_i 全局变量设置为 5。 N1000 G36 O$g_i$ D5 线路 1010 和 1020 行驶了五次。 N1000 G36 O$g_i$ D5\nN1010 G1 X100 F100 E100 E-100\nN1020 G1 X0\nN1030 G37 O$g_i$ D-1\nN1040 G20 L1010 K$g_i$ 该机制仅在路径在线处理时起作用，因为只有这样才能使用变量。该机制在 CNC 编辑器中不起作用。 为离线模式编程计数器 要离线使用编辑器，请通过以下方式不指定变量 O .然后是类型的隐式解码器变量 INT 用来。但是，只有一个变量可用。您不能编写任何嵌套跳转或循环。 使用字符串变量 您可以在 G 代码中的 O 字中使用字符串变量。此外，可以通过命令将字符串值分配并插入到此变量中 G36 和 G37 . 例子 N10 G36 O$strTest$ D'Name' 这 strTest 变量获取名称值。 N20 G37 O$strTest$ D'=Test' 价值 =Test 被添加到变量 strTest . 如果在 CNC 程序中使用字符串变量，并且如果 CNC 程序（在 IEC 程序中）是通过 SMC_ReadNCFile 功能块，则必须在 IEC 程序中为字符串保留缓冲区。否则报错 SMV_RNCF_NO_STRINGBUFFER 发生。这 SMC_StringBuffer 功能块可用于此目的。 CNC 程序的每个字符串在功能块实例中都需要自己的空间 SMC_StringBuffer ，即使同一个字符串出现多次。 下面的声明可以缓冲 32 个字符串，例如： sb: SMC_StringBuffer(uiBufferSize := 32); 功能块实例 sb 作为指针传递给 pStringBuffer 的输入 SMC_ReadNCFile 实例。 " }, 
{ "title" : "子程序 ", 
"url" : "_sm_cnc_din66025_subprograms.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 子程序 ", 
"snippet" : "功能 : 子程序的调用 经常重复执行的任务，例如型腔铣削、钻孔和换刀，可以替换为 G 代码子程序并从那里调用。在调用过程中，可以将参数传递给子程序。数据类型 BOOL , LREAL ， 和 STRING 允许用于此目的。 如果使用子程序，则必须使用功能块 SMC_ReadNCFile2 和 SMC_NCInterpreter 代替 SMC_ReadNCFile 和 SMC_NCDecoder . 子程序仅在在线解码器中工作（不在 CNC 编辑器中）。 每个子程序都存储在一个单独的文件中。这些文件保存在控制器的一个或多个子目录中。他们必须有文件扩展名 .cnc .文件名必须与子程序的名称相对应...", 
"body" : "功能 : 子程序的调用 经常重复执行的任务，例如型腔铣削、钻孔和换刀，可以替换为 G 代码子程序并从那里调用。在调用过程中，可以将参数传递给子程序。数据类型 BOOL , LREAL ， 和 STRING 允许用于此目的。 如果使用子程序，则必须使用功能块 SMC_ReadNCFile2 和 SMC_NCInterpreter 代替 SMC_ReadNCFile 和 SMC_NCDecoder . 子程序仅在在线解码器中工作（不在 CNC 编辑器中）。 每个子程序都存储在一个单独的文件中。这些文件保存在控制器的一个或多个子目录中。他们必须有文件扩展名 .cnc .文件名必须与子程序的名称相对应并且小写。示例：子程序名称“钻孔”-> 文件名 drill.cnc . 注意子程序的文件名必须小写。 POU SMC_ReadNCFile2 有一个输入 aSubProgramDirs : ARRAY[0..4] OF STRING(174) .除此之外，最多可以指定五个子目录。它们按照给定的顺序进行扫描。如果多个目录中存在同名的子程序，则查找具有数组中索引最低的目录的子程序。子程序名称转换为小写。 例子 aSubProgramDirs = ['subprograms\/user', 'subprograms\/system', ''] 子程序 DrillA1 首先在文件中扫描 subprograms\/user\/drilla1.cnc .如果此文件不存在，则继续搜索 subprograms\/system\/drilla1.cnc . 可以通过变量间接调用子程序（更准确地说，通过类型表达式 STRING ）。表达式（以及任何变量查找）在解释器到达行的预处理时被评估 - 通常在 G 代码中使用变量的情况下。在这种情况下，参数的类型检查仅在解释器到达该行时才进行，而不是在解析期间进行，就像静态调用的情况一样。 子程序不能在 CNC 编辑器中离线创建。 子程序调用的最大嵌套深度 4.18.0.0 版本之前：子程序调用的最大嵌套深度限制为 14。 版本 4.18.0.0 及更高版本：嵌套深度现在仅受内存限制。可以使用库参数更改最大值 SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPTH 。 " }, 
{ "title" : "调用的语法 ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 子程序 \/ 调用的语法 ", 
"snippet" : "子程序调用是 G 代码中的特殊程序段，仅由程序段号和调用组成。不允许添加额外的词。 N<SentenceNo> <Name> <BracketOpen> <ActualParamList> <BracketClosed> N<SentenceNo> DYNCALL <BracketOpen> <SubNameExp> [, <ActualParamListNotEmpty] <BracketClosed> <SubNameExp> : An expression with exactly one value of type STRING <ActualParamList> ::= Empty ...", 
"body" : "子程序调用是 G 代码中的特殊程序段，仅由程序段号和调用组成。不允许添加额外的词。 N<SentenceNo> <Name> <BracketOpen> <ActualParamList> <BracketClosed>\nN<SentenceNo> DYNCALL <BracketOpen> <SubNameExp> [, <ActualParamListNotEmpty] <BracketClosed>\n\n<SubNameExp> : An expression with exactly one value of type STRING\n<ActualParamList> ::= Empty | <ActualParamListNotEmpty>\n<ActualParamListNotEmpty> ::= <ActualParamValue> | <ActualParamValue>, <ActualParamListNotEmpty> <Name> 有效的 IEC 标识符，最少 3 个字符，最多 80 个字符。它必须对应于定义子程序的文件名（不带扩展名）。大写或小写对子程序名称无关紧要。人物 [a-zA-Z0-9_] 是允许的。 以下关键字对名称无效： RETURN,\\\\ IF,\\\\ ELSE,\\\\ END_IF,\\\\ CASE,\\\\ END_CASE,\\\\ FOR,\\\\ END_FOR,\\\\ WHILE,\\\\ END_WHILE, REPEAT,\\\\ UNTIL,\\\\ END_REPEAT . <ActualParamList> 必须与子程序定义的参数值数量完全相同（请参阅“声明的语法”）。每个参数值的类型必须与声明一致。 <BracketOpen>\/<BracketClosed> 出于兼容性原因，在默认设置中使用大括号代替括号 SMC_ReadNCFile2 和子程序调用和声明。括号在 G 代码中有效用于注释。 功能块 SMC_ReadNCFile2 有一个模式（ bParenthesesAsComments input) 其中括号不是注释。相反，多行注释是用 (* 并关闭 *) .在这种新模式中，大括号和圆括号均可用于子程序调用和声明。 <ActualParamValue> 变量、文字或任何表达式 例子 N10 SUB1()\nN20 DRILL(10.0)\nN30 SUB2(5, \"Text\", 2.5)\nN40 G36 O#SUBNAME D'DRILL' % Indirect call via local variable\nN40 DYNCALL(#SUBNAME, 2) % equivalent to N40 DRILL(2)\nN50 DYNCALL($SUBNAME$, 2, 4) % Indirect call via IEC variable " }, 
{ "title" : "声明的语法 ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 子程序 \/ 声明的语法 ", 
"snippet" : "子程序必须保存在单独的文件中。第一行（既非空行也非注释行）必须包含子程序的声明。以下语法适用： SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT> <Inhalt Unterprogramm> END_SUBPROGRAM <FormalParamList> ::= Empty | <FormalParamListNotEmpty> <FormalParamListNoEmpty> ::= <FormalParam> | <FormalParam> , <FormalParamListN...", 
"body" : "子程序必须保存在单独的文件中。第一行（既非空行也非注释行）必须包含子程序的声明。以下语法适用： SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT>\n<Inhalt Unterprogramm>\nEND_SUBPROGRAM\n\n<FormalParamList> ::= Empty | <FormalParamListNotEmpty>\n<FormalParamListNoEmpty> ::= <FormalParam> | <FormalParam> , <FormalParamListNotEmpty>\n<FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String with a maximum length of 255 bytes\n<RESTORE_OPT> ::= RESTORE_MODES <ParamName> 名称的长度最多为 80 个字符（不包括前缀 # ）。 RESTORE_MODES 如果指定了此关键字，则返回到调用程序时将恢复以下模态状态（设置为调用时的值）： 主动 G 代码 相对\/绝对模式（G90\/G91、G98\/G99） 圆平面和2D\/3D模式 解码器坐标系（包括缩放） 进给率（路径轴和附加轴）、快进速度、最大加速度和减速度（路径轴和附加轴） 特征标志和通用参数 (G38) 刀具半径（D字） 刀具偏置 (G43) S型材（S字） 以下模态状态不会恢复： 解码器\/解释器的当前位置以及当前的基数样条状态。该位置包括整个结构 SMC_POSINFO （即 X、Y、Z、方向和所有附加轴）。 路径预处理 POU（G40-G43、G50-G52、G60-G61、G70-G71）的状态（开\/关） 附加轴的模数设置 (PA, PB, …) 注意：不管这个关键字是什么，当从子程序返回到调用程序时，隐式计数器变量（G36、G37）被恢复。 例子 SUBPROGRAM SUB1() ; no formal parameters\nSUBPROGRAM DRILL(#depth : LREAL)\nSUBPROGRAM SUB2(#a : LREAL, #b : STRING, #c : LREAL)\nSUBPROGRAM SRM1() RESTORE_MODES " }, 
{ "title" : "返回的语法 ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 子程序 \/ 返回的语法 ", 
"snippet" : "返回要么在子程序文本的末尾（在 END_SUBPROGRAM ) 或明确使用以下语法： N<block number> RETURN ....", 
"body" : "返回要么在子程序文本的末尾（在 END_SUBPROGRAM ) 或明确使用以下语法： N<block number> RETURN . " }, 
{ "title" : "在子程序中使用形参 ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_ba614a0b6544562fc0a864631e9ee966", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 子程序 \/ 在子程序中使用形参 ", 
"snippet" : "形式参数的值可以在子程序中通过 #<ParamName> . 形式参数的数量限制为 21。 例子 SUBPROGRAM SUB(#Param1 : LREAL) N10 G01 X#Param1...", 
"body" : "形式参数的值可以在子程序中通过 #<ParamName> . 形式参数的数量限制为 21。 例子 SUBPROGRAM SUB(#Param1 : LREAL)\nN10 G01 X#Param1 " }, 
{ "title" : "调用堆栈的显示 ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 子程序 \/ 调用堆栈的显示 ", 
"snippet" : "口译员（ SMC_NCInterpreter ) 的输出包含 10 个最活跃的程序\/子程序： aActivePrograms : ARRAY[0..9] OF STRING .第一个条目（ aActivePrograms[0] ) 是当前解释的程序\/子程序。第二个条目（ aActivePrograms[1] ) 是调用程序\/子程序等。如果没有调用程序，则对应的字符串为空。 也可以在插值时显示调用堆栈。这 SMC_DisplayNCCallstack POU 以与解释器相同的格式显示活动程序\/子程序，只是稍后（即运行时）。这样做时，解释器输出 CallstackInfo (SMC_NCCalls...", 
"body" : "口译员（ SMC_NCInterpreter ) 的输出包含 10 个最活跃的程序\/子程序： aActivePrograms : ARRAY[0..9] OF STRING .第一个条目（ aActivePrograms[0] ) 是当前解释的程序\/子程序。第二个条目（ aActivePrograms[1] ) 是调用程序\/子程序等。如果没有调用程序，则对应的字符串为空。 也可以在插值时显示调用堆栈。这 SMC_DisplayNCCallstack POU 以与解释器相同的格式显示活动程序\/子程序，只是稍后（即运行时）。这样做时，解释器输出 CallstackInfo (SMC_NCCallstackInfo) 并将插值器传递给它 VAR_IN_OUT 变量。 SMC_NCCallstackInfo 存储所有调用堆栈更改，包括相应的 SMC_GeoInfo 对象编号，在环形缓冲区中。此时，这将解释时间和插值时间之间可存储的调用堆栈更改次数限制为 128。 由于环形缓冲区不满足多任务标准， SMC_DisplayNCCallstack 必须从解释器任务中调用。 示例程序 CNC 实例 07：使用表达式和子程序显示了插值时调用堆栈的显示示例。 " }, 
{ "title" : "表达式 ", 
"url" : "_sm_cnc_din66025_expressions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 表达式 ", 
"snippet" : "功能 ： 在 4.4.0.0 及更高版本中，可以使用数学、布尔和字符串表达式。这 SMC_ReadNCFile2 和 SMC_NCInterpreter 为此必须使用功能块（而不是 SMC_ReadNCFile 和 SMC_NCDecoder ）。 表达式仅适用于在线解码器（不适用于 CNC 编辑器）。 原则上，表达式可以在 G 代码中的两个位置使用： 作为 G 字的值（一个 G 字由一个地址和一个值组成，例如“G1”） 作为子程序调用的传递参数...", 
"body" : "功能 ： 在 4.4.0.0 及更高版本中，可以使用数学、布尔和字符串表达式。这 SMC_ReadNCFile2 和 SMC_NCInterpreter 为此必须使用功能块（而不是 SMC_ReadNCFile 和 SMC_NCDecoder ）。 表达式仅适用于在线解码器（不适用于 CNC 编辑器）。 原则上，表达式可以在 G 代码中的两个位置使用： 作为 G 字的值（一个 G 字由一个地址和一个值组成，例如“G1”） 作为子程序调用的传递参数 " }, 
{ "title" : "语法 – 常规 ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_42546a9cc18a4349c0a86463750fefea", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 表达式 \/ 语法 – 常规 ", 
"snippet" : "表达式可以包含以下元素： 数字和字符串文字 全局和局部变量 中缀运算符和函数 逗号和括号 同样，圆括号（如果不用于标识注释）和大括号可用于构造表达式。这意味着表达式 (1 + 2} * 3 被允许。 功能块 SMC_ReadNCFile2 有一个新模式（ bParenthesesAsComments input) 其中括号不是注释。相反，多行注释分别用“(*”和“*)”打开和关闭。在这种新模式中，大括号和圆括号均可用于表达式。 仅当以下情况时才需要 G 地址后的空格 SMC_ReadNCFile2 不会将其识别为独立令牌（例如： X abs{-2} 代替 Xabs{-2}. ）。 与 ST 相...", 
"body" : "表达式可以包含以下元素： 数字和字符串文字 全局和局部变量 中缀运算符和函数 逗号和括号 同样，圆括号（如果不用于标识注释）和大括号可用于构造表达式。这意味着表达式 (1 + 2} * 3 被允许。 功能块 SMC_ReadNCFile2 有一个新模式（ bParenthesesAsComments input) 其中括号不是注释。相反，多行注释分别用“(*”和“*)”打开和关闭。在这种新模式中，大括号和圆括号均可用于表达式。 仅当以下情况时才需要 G 地址后的空格 SMC_ReadNCFile2 不会将其识别为独立令牌（例如： X abs{-2} 代替 Xabs{-2}. ）。 与 ST 相比，单位置函数不一定必须用括号调用（例如： sin 3 ）。 解析时，每个部分表达式都被指定为以下三种类型之一：BOOL、LREAL 或 STRING。因此，每个中缀运算符和每个函数都需要一个特定的参数类型序列，不合规（错误类型、太少或太多参数）将返回错误。 限制： 块编号必须是数字文字。 出于严格的技术原因，跳转标记 ( x 在 L!x ) 不得包含任何局部变量。 有关更多信息，请参阅： 跳， 使用变量" }, 
{ "title" : "例子 ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_5b6258e8c18a4349c0a864632640e903", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 表达式 \/ 例子 ", 
"snippet" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}} N02 G1 X$var$ + sin{pi + 3 * #locvar} N03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}}...", 
"body" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}}\nN02 G1 X$var$ + sin{pi + 3 * #locvar}\nN03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}} " }, 
{ "title" : "支持的运算符和函数 ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_da2d0ac5c18a4349c0a864637cb30dc8", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 表达式 \/ 支持的运算符和函数 ", 
"snippet" : "中缀运算符 特点 类型 参数 优先级 MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , LREAL 10 <> BOOL STRING , STRING 10 > BOOL ...", 
"body" : "中缀运算符 特点 类型 参数 优先级 MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , LREAL 10 <> BOOL STRING , STRING 10 > BOOL LREAL , LREAL 10 < BOOL LREAL , LREAL 10 >= BOOL LREAL , LREAL 10 <= BOOL LREAL , LREAL 10 AND BOOL BOOL , BOOL 6 XOR BOOL BOOL , BOOL 5 OR BOOL BOOL , BOOL 4 职能 特点 类型 参数 - LREAL LREAL ABS LREAL LREAL MAX LREAL LREAL , LREAL MIN LREAL LREAL , LREAL NOT BOOL BOOL TRUE BOOL FALSE BOOL SIN LREAL LREAL COS LREAL LREAL TAN LREAL LREAL ASIN LREAL LREAL ACOS LREAL LREAL ATAN LREAL LREAL EXP LREAL LREAL LN LREAL LREAL SQRT LREAL LREAL EXPT LREAL LREAL , LREAL FLOOR LREAL LREAL CEIL LREAL LREAL PI LREAL LEN LREAL STRING CONCAT STRING STRING , STRING " }, 
{ "title" : "定义自己的函数 ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_fca8916cc18a4349c0a8646350db2bd3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 表达式 \/ 定义自己的函数 ", 
"snippet" : "可以添加您自己的功能或覆盖现有的实现。 （解析 G 代码时，首先在用户函数中搜索函数。） 必须实现 smc_nc_iFunction 接口，并且必须将相应 POU 的全局实例传输到 SMC_ReadNCFile2 或者 SMC_ReadNCFromStream 通过结构 SMC_NC_GFunctionTable 。 枚举 SMC_GVar_Type 用于返回类型和参数类型。包含在那里的条目 T_OTHER 可以用作类型的占位符。解析时，系统会检查所有与 a 对应的参数 T_OTHER 在签名中具有相同的类型。类型无关紧要。 有关更多信息，请参阅： 特定于用户的 G 代码函数...", 
"body" : "可以添加您自己的功能或覆盖现有的实现。 （解析 G 代码时，首先在用户函数中搜索函数。） 必须实现 smc_nc_iFunction 接口，并且必须将相应 POU 的全局实例传输到 SMC_ReadNCFile2 或者 SMC_ReadNCFromStream 通过结构 SMC_NC_GFunctionTable 。 枚举 SMC_GVar_Type 用于返回类型和参数类型。包含在那里的条目 T_OTHER 可以用作类型的占位符。解析时，系统会检查所有与 a 对应的参数 T_OTHER 在签名中具有相同的类型。类型无关紧要。 有关更多信息，请参阅： 特定于用户的 G 代码函数" }, 
{ "title" : "错误处理 ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 表达式 \/ 错误处理 ", 
"snippet" : "在可能的情况下，在语法错误中发布有缺陷令牌的确切位置及其长度。错误位置列于 SMC_ReadNCFile2.errorPos ....", 
"body" : "在可能的情况下，在语法错误中发布有缺陷令牌的确切位置及其长度。错误位置列于 SMC_ReadNCFile2.errorPos . " }, 
{ "title" : "局部变量 ", 
"url" : "_sm_cnc_din66025_local_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 局部变量 ", 
"snippet" : "每个 G 代码文件都可以声明局部变量。对于主程序，必须在最开始插入声明；对于子程序，直接在子程序声明之后。 局部变量仅在声明它们的程序或子程序中可见。 （无动态范围） 局部变量仅在在线解码器中起作用（不在 CNC 编辑器中）。 局部变量的数量 4.18.0.0 版之前：每个子程序和主程序中的局部变量的数量限制为 21 个。 版本 4.18.0.0 及更高版本：局部变量的数量仅受内存限制。可以使用库参数更改最大值 SMC_CNC_LibParams.MAX_SUBPROGRAM_PARAMS 。 有关更多信息，请参阅： 库参数 声明的语法 语法类似于用于声明子程序参数的语法。每个块可以声明一个变...", 
"body" : "每个 G 代码文件都可以声明局部变量。对于主程序，必须在最开始插入声明；对于子程序，直接在子程序声明之后。 局部变量仅在声明它们的程序或子程序中可见。 （无动态范围） 局部变量仅在在线解码器中起作用（不在 CNC 编辑器中）。 局部变量的数量 4.18.0.0 版之前：每个子程序和主程序中的局部变量的数量限制为 21 个。 版本 4.18.0.0 及更高版本：局部变量的数量仅受内存限制。可以使用库参数更改最大值 SMC_CNC_LibParams.MAX_SUBPROGRAM_PARAMS 。 有关更多信息，请参阅： 库参数 声明的语法 语法类似于用于声明子程序参数的语法。每个块可以声明一个变量。该块不以 N 字开头。变量可以在声明时提供一个可选的初始值。否则，它会根据数据类型（ LREAL: 0, BOOL: FALSE, STRING: ‘‘ ）。 声明的语法： LET <FormalParam> [:= <InitialValue>] . <FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String mit maximaler Länge von 255 Bytes <InitialValue> : 具有与变量匹配的值和类型的表达式。表达式也可以使用局部变量（并且在子程序中使用子程序的参数），但仅限于在程序代码中声明的那些。 例子 • LET #x : LREAL (* Variable #x, Typ LREAL, Initialwert 0 *)\n• LET #y : LREAL := #x + 1 (* Variable #y, Typ LREAL, Initialwert #x+1 = 1 *)\n• LET #b : BOOL := #x >= #y (* Variable #b, Typ BOOL, Initialwert FALSE *) 与子程序参数一样，局部变量不区分大小写。 （两个都 #x 和 #X 表示同一个变量。）在一个程序\/子程序中声明的所有局部变量的名称必须不同。它们必须与子程序的形参名称不同。 局部变量可以像子程序的参数一样在 G 代码中使用。 例子 • N10 G01 X#x Y#y\n• N20 G20 L10 K#b " }, 
{ "title" : "探测功能（清除剩余距离） ", 
"url" : "_sm_probe_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ DIN 66025 中的 CNC 语言 \/ 探测功能（清除剩余距离） ", 
"snippet" : "G 代码 : G31 \/任何移动命令以及 PROBE 单词 函数 : 探测功能（清除剩余距离）是一种特殊动作，一旦发出信号就会中止（ PROBE ) 正在等待中。G 代码的其余部分从运动中止的位置继续，而不是从机芯的编程结束位置 探测功能（清除剩余距离）会在下一动作之前隐式停止解码（类似于 G75 ）。只有在接收到信号后，G 代码的解码才会继续。典型的用例包括测量刀具长度（移入开关）或移动到方块上。 探测功能（清除剩余距离）可以激活任意数量的运动，例如直线和圆弧。为此，只有 PROBE 必须将单词添加到 G 代码中。 G31 是具有探测功能（清除剩余距离）的线性运动，默认探针编号为 1。这个默...", 
"body" : "G 代码 : G31 \/任何移动命令以及 PROBE 单词 函数 : 探测功能（清除剩余距离）是一种特殊动作，一旦发出信号就会中止（ PROBE ) 正在等待中。G 代码的其余部分从运动中止的位置继续，而不是从机芯的编程结束位置 探测功能（清除剩余距离）会在下一动作之前隐式停止解码（类似于 G75 ）。只有在接收到信号后，G 代码的解码才会继续。典型的用例包括测量刀具长度（移入开关）或移动到方块上。 探测功能（清除剩余距离）可以激活任意数量的运动，例如直线和圆弧。为此，只有 PROBE 必须将单词添加到 G 代码中。 G31 是具有探测功能（清除剩余距离）的线性运动，默认探针编号为 1。这个默认值可以用 PROBE 字覆盖 每个动作最多只能有一个动作 PROBE 字。 使用探测功能的运动（清除剩余距离）不支持 H 函数（触发器）。 使用探测功能的移动（清除剩余距离）不支持诸如拐角平滑、刀具半径校正等路径预处理。 探测编号必须为正数。 如果在使用探测功能（清除剩余距离）运动处理过程中未收到探测信号，则插值会在运动结束时停止，出现错误。 接收到探测信号时，首先需要停止插值器。其中一个输入 bSlow_Stop ， bQuick_Stop ，或 bEmergency_Stop 可以用于此目的。插值停止后，即可确认探测功能（清除剩余距离）。为此，将上升优势应用于 SMC_Interpolator.bAcknProbe 输入。 语法 G31 X Y Z A B C P Q U V W F E S PROBE\nG1\/2\/3\/8\/9 X Y Z A B C P Q U V W F E S PROBE G 代码 Word 描述 X Y Z 笛卡尔轴的目标位置 A B C P Q U V W 附加轴的目标位置 F E 路径速度、路径加速\/减速 S S 个人资料 PROBE 探测编号必须为正数。 例子 线性运动 使用探测功能（清除剩余距离）和默认探头编号为 1 的线性运动 N010 G31 X100 圆周运动 使用探测功能（清除剩余距离）和 7 号探头进行圆周运动 N010 G02 X100 R50 PROBE 7 有关更多信息，请参阅示例： CNC 示例 16：探测功能（清除剩余距离）(G31)" }, 
{ "title" : "路径预处理和队列大小 ", 
"url" : "_sm_preprocessing_queuesize.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 路径预处理和队列大小 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "G 代码处理的流水线 ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103127844091", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 路径预处理和队列大小 \/ G 代码处理的流水线 ", 
"snippet" : "从文件中读取 G 代码时，在开始加工之前读取和处理整个文件通常是不切实际的。对于某些应用程序，G 代码文件可能有几十万甚至数百万行。一次全部读取将花费很长时间，还需要大量内存。 而代之的是，G 代码是逐行读取的，但每个时间点的内存中只保留一小部分（几百行）。这部分保存在队列中，即按照 “先进先出” 原则工作的数据结构中：生成功能块向队列中添加元素。消费函数块按照插入元素的顺序读取和删除元素。 该图显示了 G 代码在系统中的流动。首先，从文件中读取 G 代码，然后由解释器转换为所谓的 GeoInfo 元素。这些元素由路径预处理功能块处理，最后进行插值。标有 “GeoInfo” 的部分代表队列。如...", 
"body" : "从文件中读取 G 代码时，在开始加工之前读取和处理整个文件通常是不切实际的。对于某些应用程序，G 代码文件可能有几十万甚至数百万行。一次全部读取将花费很长时间，还需要大量内存。 而代之的是，G 代码是逐行读取的，但每个时间点的内存中只保留一小部分（几百行）。这部分保存在队列中，即按照 “先进先出” 原则工作的数据结构中：生成功能块向队列中添加元素。消费函数块按照插入元素的顺序读取和删除元素。 该图显示了 G 代码在系统中的流动。首先，从文件中读取 G 代码，然后由解释器转换为所谓的 GeoInfo 元素。这些元素由路径预处理功能块处理，最后进行插值。标有 “GeoInfo” 的部分代表队列。如果有多个路径预处理器（例如 SMC_SmoothPath ， SMC_ToolRadiusCorr ，或 SMC_AvoidLoop ) 被使用，然后它们也通过队列连接。 " }, 
{ "title" : "建议的队列大小 ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128036484", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 路径预处理和队列大小 \/ 建议的队列大小 ", 
"snippet" : "根据经验，对于大多数队列，16 个元素的大小是合适的。之前的最后一个队列 SMC_Interpolator 功能块（通常是路径预处理功能块之前的队列） SMC_CheckVelocities ) 应该有更高的队列大小 — 对于大多数应用程序来说，100 个元素是一个很好的起点。 为了了解这些规则并知道何时偏离这些规则，我们来看看队列大小的影响： 延迟 处理时间：队列越大，最初填满队列所需的时间就越长。这个 SMC_Interpolator 函数块会等到最后一个队列被填满后才开始插值。对于延迟，队列总大小（所有队列大小的总和）是相关的。 LookaHead 插值器的：插值器之前的最后一个队列的大...", 
"body" : "根据经验，对于大多数队列，16 个元素的大小是合适的。之前的最后一个队列 SMC_Interpolator 功能块（通常是路径预处理功能块之前的队列） SMC_CheckVelocities ) 应该有更高的队列大小 — 对于大多数应用程序来说，100 个元素是一个很好的起点。 为了了解这些规则并知道何时偏离这些规则，我们来看看队列大小的影响： 延迟 处理时间：队列越大，最初填满队列所需的时间就越长。这个 SMC_Interpolator 函数块会等到最后一个队列被填满后才开始插值。对于延迟，队列总大小（所有队列大小的总和）是相关的。 LookaHead 插值器的：插值器之前的最后一个队列的大小 SMC_Interpolator 确定插值的前景。计算轨迹时，插值器只能计划直到前瞻结束。如果前向太小，则插值器可能无法达到全路径速度。根据路径速度和元素长度，100 个元素是一个不错的起点，但是对于高速度和\/或较短的元素，可能需要更大的队列大小 对... 的影响 特定的功能块 : 功能块，例如 SMC_AvoidLoop 或者 SMC_SmoothMerge 需要一定大小的传入队列才能有效工作。例如，要检测 G 代码中的循环，此循环必须先放入队列 SMC_AvoidLoop 。有关详细信息，请查看路径处理管道中功能块的文档。 " }, 
{ "title" : "调用处理功能块 ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128219711", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 路径预处理和队列大小 \/ 调用处理功能块 ", 
"snippet" : "如上所述，插值仅在所有队列都填满后才开始。这会在开始加工时导致初始延迟。除了减少队列总大小外，还有另一种方法可以减少这种延迟。 路径预处理功能块通常在循环后台任务中调用，如以下示例所示 CNC实例03：在线进行路径预处理。为了减少延迟，程序调用 SMC_ReadNCFile2 ， SMC_NCInterpreter ，并且可以在循环中调用路径预处理器。根据应用程序和任务优先级的不同，每次任务调用多次执行程序（例如 100 次）或在一定时间跨度（例如 5 毫秒）后终止循环可能就足够了。...", 
"body" : "如上所述，插值仅在所有队列都填满后才开始。这会在开始加工时导致初始延迟。除了减少队列总大小外，还有另一种方法可以减少这种延迟。 路径预处理功能块通常在循环后台任务中调用，如以下示例所示 CNC实例03：在线进行路径预处理。为了减少延迟，程序调用 SMC_ReadNCFile2 ， SMC_NCInterpreter ，并且可以在循环中调用路径预处理器。根据应用程序和任务优先级的不同，每次任务调用多次执行程序（例如 100 次）或在一定时间跨度（例如 5 毫秒）后终止循环可能就足够了。 " }, 
{ "title" : "例子 ", 
"url" : "_sm_cnc_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CNC实例01：直接生成OutQueue ", 
"url" : "_sm_example_cnc_1.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC实例01：直接生成OutQueue ", 
"snippet" : "见 CNC01_direct.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 这个例子显示了一个有两个轴的 CNC 程序。以定义的速度和加速度接近 X\/Y 平面中的四个位置。程序在路径上设置了两个路径切换点。该程序通过使用直接写入数据结构 SMC_OutQueue 编译模式。 调试 编译并启动创建的程序。程序一执行 CNC 运动 Execute 插值器的输入已设置。程序完全运行后，您可以通过新的上升沿重新启动它。 请注意也显示在插值功能块的可视化中的路径开关的功能。...", 
"body" : "见 CNC01_direct.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 这个例子显示了一个有两个轴的 CNC 程序。以定义的速度和加速度接近 X\/Y 平面中的四个位置。程序在路径上设置了两个路径切换点。该程序通过使用直接写入数据结构 SMC_OutQueue 编译模式。 调试 编译并启动创建的程序。程序一执行 CNC 运动 Execute 插值器的输入已设置。程序完全运行后，您可以通过新的上升沿重新启动它。 请注意也显示在插值功能块的可视化中的路径开关的功能。 " }, 
{ "title" : "在 CNC 编辑器中创建 NC 程序 ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_0decf30fe1170213c0a864632e7a1fa2", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC实例01：直接生成OutQueue \/ 在 CNC 编辑器中创建 NC 程序 ", 
"snippet" : "创建一个 CNCdirect 项目与 SoftMotion 控制器。 插入一个 数控程序 命名的对象 Example . 选择 执行 Din66025 和 编译方式 SMC_OutQueue . 指定以下运动块： 数控编辑器：...", 
"body" : "创建一个 CNCdirect 项目与 SoftMotion 控制器。 插入一个 数控程序 命名的对象 Example . 选择 执行 Din66025 和 编译方式 SMC_OutQueue . 指定以下运动块： 数控编辑器： " }, 
{ "title" : "创建驱动接口和 PLC 配置 ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_502a86c7e1170213c0a864631de910a9", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC实例01：直接生成OutQueue \/ 创建驱动接口和 PLC 配置 ", 
"snippet" : "定义具有两个线性驱动器的驱动器结构如下： 插入两个虚拟驱动器 X_Drive 和 Y_Drive 以下 SoftMotion 通用轴池 . 设置 轴型 参数为 Finite (1). 配置编辑器：...", 
"body" : "定义具有两个线性驱动器的驱动器结构如下： 插入两个虚拟驱动器 X_Drive 和 Y_Drive 以下 SoftMotion 通用轴池 . 设置 轴型 参数为 Finite (1). 配置编辑器： " }, 
{ "title" : "创建 IEC 程序 ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_2840ecebe1170213c0a8646360b1cd08", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC实例01：直接生成OutQueue \/ 创建 IEC 程序 ", 
"snippet" : "添加新的 CFC 程序 IPO 到应用程序并配置一个间隔为 3 ms 的循环任务。 激活驱动器 MC_Power 功能块。 POU： 插入 SMC_Interpolator 宝。该功能块将由 GEOINFO 对象定义的路径转换为离散的路径点。功能块在输入端接收创建的 CNC 程序的地址 poqDataIn .然后必须将 IEC 任务循环时间写入输入 dwIpoTime .您可以在输入处将这些指定为常量值 dwIpoTime 或者你可以使用变量 dwCycle PLC 配置中的轴组结构。这样做的好处是，当您更改任务循环时间时，会自动将正确的时间用作内插器输入。 宝： 在本例中，将控制龙门系统。为...", 
"body" : "添加新的 CFC 程序 IPO 到应用程序并配置一个间隔为 3 ms 的循环任务。 激活驱动器 MC_Power 功能块。 POU： 插入 SMC_Interpolator 宝。该功能块将由 GEOINFO 对象定义的路径转换为离散的路径点。功能块在输入端接收创建的 CNC 程序的地址 poqDataIn .然后必须将 IEC 任务循环时间写入输入 dwIpoTime .您可以在输入处将这些指定为常量值 dwIpoTime 或者你可以使用变量 dwCycle PLC 配置中的轴组结构。这样做的好处是，当您更改任务循环时间时，会自动将正确的时间用作内插器输入。 宝： 在本例中，将控制龙门系统。为此，插入一个反向和正向转换功能块的实例。 SM_Trafo 图书馆。正向转换功能块包含驱动器作为输入。逆变换功能块必须包含插值器的设置位置。示例中的正向转换仅用于可视化。 功能块实例： 功能块的输出（轴坐标）必须写入驱动器。这是通过 SMC_ControlAxisByPos 功能块。由于应用程序不保证内插器的输出是恒定的（例如，路径结束于起点以外的点），请激活间隙避免（ bAvoidGaps , fGapVelocity , fGapAcceleration , fGapDeceleration ）。然后连接 StopIpo 输出到 bEmergency_Stop 内插器的输入并连接内插器的输出 iStatus 到轴控制功能块的相应输入。 使用 CFC 进行编程时，请注意功能块的正确顺序。 氟氯化碳： " }, 
{ "title" : "创建操作界面和测试界面 ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC实例01：直接生成OutQueue \/ 创建操作界面和测试界面 ", 
"snippet" : "将两个可视化对象链接到新的可视化：插值器模板和转换模板。您需要使用占位符将它们链接到相应的功能块实例（此处： Ipo.smci 和 Ipo.trafof ）。...", 
"body" : "将两个可视化对象链接到新的可视化：插值器模板和转换模板。您需要使用占位符将它们链接到相应的功能块实例（此处： Ipo.smci 和 Ipo.trafof ）。 " }, 
{ "title" : "CNC 实例 02：带变量的在线解码 ", 
"url" : "_sm_example_cnc_2.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 02：带变量的在线解码 ", 
"snippet" : "见 CNC02_online.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 该示例显示了如何 使用变量 解码 CNC 程序。 调试 编译并启动创建的程序。程序一执行 CNC 运动 Execute 解码器和内插器的输入已设置。如果更改全局变量的值，则在重新启动解码器并相应地调整路径时将使用它们。监控功能 Append 解码器的输入也是如此。...", 
"body" : "见 CNC02_online.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 该示例显示了如何 使用变量 解码 CNC 程序。 调试 编译并启动创建的程序。程序一执行 CNC 运动 Execute 解码器和内插器的输入已设置。如果更改全局变量的值，则在重新启动解码器并相应地调整路径时将使用它们。监控功能 Append 解码器的输入也是如此。 " }, 
{ "title" : "在 CNC 编辑器中创建 NC 程序 ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_4c86ec04e529c0bcc0a864636a6ae1dc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 02：带变量的在线解码 \/ 在 CNC 编辑器中创建 NC 程序 ", 
"snippet" : "创建一个 CNCOnline 程序与 SoftMotion 控制器。 创建一个全局变量列表并声明两个变量。 VAR_GLOBAL g_x: REAL:=100; g_y:REAL:=50; END_VAR 插入一个 数控程序 命名的对象 Example . 选择 执行 Din66025 和 编译模式 SMC_CNC_REF .此模式是必需的，因为您在程序中使用了变量。 指定以下运动块： 数控编辑器：...", 
"body" : "创建一个 CNCOnline 程序与 SoftMotion 控制器。 创建一个全局变量列表并声明两个变量。 VAR_GLOBAL\n g_x: REAL:=100;\n g_y:REAL:=50;\nEND_VAR 插入一个 数控程序 命名的对象 Example . 选择 执行 Din66025 和 编译模式 SMC_CNC_REF .此模式是必需的，因为您在程序中使用了变量。 指定以下运动块： 数控编辑器： " }, 
{ "title" : "创建驱动接口和 PLC 配置 ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_7e9d1704e529c0bcc0a8646343b60bbd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 02：带变量的在线解码 \/ 创建驱动接口和 PLC 配置 ", 
"snippet" : "定义驱动结构（例如 CNCdirect ）。...", 
"body" : "定义驱动结构（例如 CNCdirect ）。 " }, 
{ "title" : "创建 IEC 程序 ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3989abe9e529c0bcc0a864630f20ee19", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 02：带变量的在线解码 \/ 创建 IEC 程序 ", 
"snippet" : "添加名为的 POU (CFC) Path 到应用程序。 OUTQUEUE 的 NC 程序解码和速度检查发生在 Path 程序。 打电话 SMC_CheckVelocities 是必须的。 氟氯化碳： 添加名为的 POU (CFC) Ipo 到应用程序。 这个程序几乎与 CNCdirect 示例项目。但是，插补器的数据输入与 CNC 程序名称（ ADR(Example) )，但是到路径预处理功能块的 OutQueue 输出 ( checkVel.poqDataOut ）。...", 
"body" : "添加名为的 POU (CFC) Path 到应用程序。 OUTQUEUE 的 NC 程序解码和速度检查发生在 Path 程序。 打电话 SMC_CheckVelocities 是必须的。 氟氯化碳： 添加名为的 POU (CFC) Ipo 到应用程序。 这个程序几乎与 CNCdirect 示例项目。但是，插补器的数据输入与 CNC 程序名称（ ADR(Example) )，但是到路径预处理功能块的 OutQueue 输出 ( checkVel.poqDataOut ）。 " }, 
{ "title" : "为路径预处理创建任务 ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3014d45de529c0bcc0a86463617895a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 02：带变量的在线解码 \/ 为路径预处理创建任务 ", 
"snippet" : "因为你选择了编译模式 SMC_CNC_REF ，必须在IEC程序中进行解码和路径预处理。这个计算很耗时。它不必在插值器循环中执行，因为每次解码器调用都会生成一个路径对象，并且该对象通常用于许多插值器调用。您应该将此操作替换为优先级较低且调用频率较低的任务。 创建一个 PathTask 任务。 定义以下参数： 优先事项 : 10 间隔 : T#30ms 添加 Path POU 到任务。 “路径任务”任务 底层机制： 在慢速任务中，最初每个周期大约生成一个 GEOINFO 对象。该对象存储在解码器功能块的 OUTQUEUE 结构中。如果 OUTQUEUE 已满，则慢任务的功能块将暂停，直到 OUT...", 
"body" : "因为你选择了编译模式 SMC_CNC_REF ，必须在IEC程序中进行解码和路径预处理。这个计算很耗时。它不必在插值器循环中执行，因为每次解码器调用都会生成一个路径对象，并且该对象通常用于许多插值器调用。您应该将此操作替换为优先级较低且调用频率较低的任务。 创建一个 PathTask 任务。 定义以下参数： 优先事项 : 10 间隔 : T#30ms 添加 Path POU 到任务。 “路径任务”任务 底层机制： 在慢速任务中，最初每个周期大约生成一个 GEOINFO 对象。该对象存储在解码器功能块的 OUTQUEUE 结构中。如果 OUTQUEUE 已满，则慢任务的功能块将暂停，直到 OUTQUEUE 不再满为止。一旦快速任务处理第一个 GEOINFO 对象并将其从 OUTQUEUE 中删除，就会发生这种情况。 然后慢任务的功能块再次激活并填充 OUTQUEUE 结构。 在快速任务中，来自 OUTQUEUE 结构的路径点， DataIn 输入指向，在每个循环中被计算和处理。因为一个 GEOINFO 对象通常由多个路径点组成，所以在第一个 GEOINFO 对象被内插器自动处理和删除之前需要几个周期。 由于 GEOINFO 对象的处理持续几个周期而不是它的创建，因此慢任务的调用频率可以低于快速任务。 但是，必须选择任务时间，以便在慢速任务的最后一个 OUTQUEUE 中始终存储足够的 GEOINFO 对象，从而防止发生任何数据欠载。当没有更多 GEOINFO 对象可用于来自 DataIn 的内插器，并且尚未到达路径末端时，就会发生这种情况。在这种情况下，内插器会减慢速度并停止，直到新的数据元素再次可用。 " }, 
{ "title" : "创建操作界面和测试界面 ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 02：带变量的在线解码 \/ 创建操作界面和测试界面 ", 
"snippet" : "可视化对应于 CNCdirect.project 示例项目。将附加模板添加到新功能块 ( SMC_NCDecoder 和 SMC_CheckVelocities ）。也为全局变量创建一个显示 g_x 和 g_y 以便您可以在以后调试时检查它们的功能。...", 
"body" : "可视化对应于 CNCdirect.project 示例项目。将附加模板添加到新功能块 ( SMC_NCDecoder 和 SMC_CheckVelocities ）。也为全局变量创建一个显示 g_x 和 g_y 以便您可以在以后调试时检查它们的功能。 " }, 
{ "title" : "CNC实例03：在线进行路径预处理 ", 
"url" : "_sm_example_cnc_3.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC实例03：在线进行路径预处理 ", 
"snippet" : "见 CNC03_prepro.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 该示例显示了如何在 PLC 上在线执行路径预处理。 延长 CNC02_online 带有一个路径预处理器的项目。那么运动的角度 CNConline 项目通过样条曲线进行舍入。这是通过 SMC_平滑路径 功能块。 扩展 CNC 程序：在前面的程序中添加元素 G51\/G50 . 点击 CNC → 显示预处理路径 这样通过路径预处理创建的样条曲线就会显示在编辑器中，如下面的屏幕截图所示。 展示： 在不使用变量的情况下，您可以将这种形式的程序编译...", 
"body" : "见 CNC03_prepro.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 该示例显示了如何在 PLC 上在线执行路径预处理。 延长 CNC02_online 带有一个路径预处理器的项目。那么运动的角度 CNConline 项目通过样条曲线进行舍入。这是通过 SMC_平滑路径 功能块。 扩展 CNC 程序：在前面的程序中添加元素 G51\/G50 . 点击 CNC → 显示预处理路径 这样通过路径预处理创建的样条曲线就会显示在编辑器中，如下面的屏幕截图所示。 展示： 在不使用变量的情况下，您可以将这种形式的程序编译为队列并将其直接输入到插值器中。但是，由于变量可用，您必须自己执行解码和角度平滑。 声明一个新的功能块类型 SMC_SmoothPath .在解码器之后调用它。 像往常一样将内插器功能块的数据输入设置为 poqDataOut 的输出 CheckVelocities 功能块。 必须为输入声明一个新缓冲区 SMC_SmoothPath.pbyBufferOutQueue . 氟氯化碳： 调试 编译并启动创建的程序。与之前的程序相比，该程序不再在 NC 程序的角度处停止，因为路径的角度已经通过路径预处理消除了扭结。 " }, 
{ "title" : "CNC 示例 04：使用表格编辑器对 CNC 进行编程 ", 
"url" : "_sm_example_cnc_4.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 示例 04：使用表格编辑器对 CNC 进行编程 ", 
"snippet" : "见 CNC04_table.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 在这个项目中，功能 CNC03_prepro.project 示例项目使用表格编辑器进行编程。与...对比 CNC03_prepro.project ，此项目中未使用 IEC 变量。相反，它是用固定值计算的。否则，功能是相同的。...", 
"body" : "见 CNC04_table.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 在这个项目中，功能 CNC03_prepro.project 示例项目使用表格编辑器进行编程。与...对比 CNC03_prepro.project ，此项目中未使用 IEC 变量。相反，它是用固定值计算的。否则，功能是相同的。 " }, 
{ "title" : "CNC 示例 05：从文件创建 CNC ", 
"url" : "_sm_example_cnc_5.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 示例 05：从文件创建 CNC ", 
"snippet" : "见 CNC05_File.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 通过此示例项目，您可以了解如何从存储在 PLC 上的 ASCII 文件中读取 G 代码程序。当 G 代码程序非常大时，使用这种文件是有意义的。 该项目的功能类似于 CNC02_online.project 示例项目。但是，G 代码程序是从 ASCII 文件中读取的。没有使用变量，处理顺序与 CNC02_online.project 示例项目。 可以确定以下差异： 附加虚拟驱动器（z 轴） 功能块 smoothpath 不需要 从文件中读取 G...", 
"body" : "见 CNC05_File.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 通过此示例项目，您可以了解如何从存储在 PLC 上的 ASCII 文件中读取 G 代码程序。当 G 代码程序非常大时，使用这种文件是有意义的。 该项目的功能类似于 CNC02_online.project 示例项目。但是，G 代码程序是从 ASCII 文件中读取的。没有使用变量，处理顺序与 CNC02_online.project 示例项目。 可以确定以下差异： 附加虚拟驱动器（z 轴） 功能块 smoothpath 不需要 从文件中读取 G 代码 在线预处理（见 CNC02_online.project ) " }, 
{ "title" : "CNC 实例 06：使用 Path3D SoftMotion 数控 ", 
"url" : "_sm_example_cnc_6.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 06：使用 Path3D SoftMotion 数控 ", 
"snippet" : "见 CNC06_File_3DPath.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 这个例子扩展了前面的例子 CNC05_File .它演示了 Path3D 可视化元素的可能应用 CODESYS SoftMotion 数控。 将程序 CNC_File 扩展为 CNC_File_Path3D 打开 图书馆经理 并添加 SM3_CNC_Visu 图书馆。 创建一个实例 SMC_PathCopierFile 在 CNC_PreparePath 并在路径处理开始时调用它（ iState=0 ）。 编程： 在里面 可视化...", 
"body" : "见 CNC06_File_3DPath.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 这个例子扩展了前面的例子 CNC05_File .它演示了 Path3D 可视化元素的可能应用 CODESYS SoftMotion 数控。 将程序 CNC_File 扩展为 CNC_File_Path3D 打开 图书馆经理 并添加 SM3_CNC_Visu 图书馆。 创建一个实例 SMC_PathCopierFile 在 CNC_PreparePath 并在路径处理开始时调用它（ iState=0 ）。 编程： 在里面 可视化 可视化，将之前使用的位置图形显示替换为 路径3D 元素。 更改属性 路径3D 元素： 路径描述 → 路径数据 (VisuStruct3DTrack) ： CNC_prepare_path.pcf.vs3dt 插入 框架 可视化元素。 参考 控制面板 从可视化 VisuElem3DPath 图书馆。该元素用于控制元素的相机位置。 在声明中 CNC_PreparePath 程序，创建一个实例 VisuStruct3DControl ( VisuElem3DPath 图书馆）： vc: VisuStruct3DControl; . 该实例形成了 Path3D 元素和相机控制面板之间的数据接口。 更改属性 路径3D 元素： 相机控制→控制数据结构（VisuStruct3DControl） ： CNC_PreparePath.vc 更改属性 控制面板 元素： 参考 → VisuElem3DPath.ControlPanel → vc ： CNC_PreparePath.vc 编译、下载并启动应用程序。 Path3D 元素显示路径。您可以从面板控制摄像机位置。 添加一个实例 SMC_PositionTracker 功能块在 CNC 程序。创建用于跟踪当前轨迹（最后行驶的位置）的内存。 pt: SMC_PositionTracker; pointbuffer_pt: ARRAY [0..1000] OF VisuStruct3DPathPoint; 插入实例调用： SMC_PositionTracker 进入 Interpolation 行动 氟氯化碳： 将路径数据链接到 Path3D 元素。更改属性 路径3D 元素： 路径描述 → 路径数据 (VisuStruct3DTrack) ： CNC.pt.vs3dt 上网并启动应用程序。 Path3D 元素也显示路径的最后一个内插路径。 配置其他属性 路径3D .例如，将处理后的路径元素配置为灰色显示： 突出显示→突出显示颜色 ： Gray 示例项目：“3D 路径生成器” " }, 
{ "title" : "CNC 实例 07：使用表达式和子程序 ", 
"url" : "_sm_example_cnc_7.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 07：使用表达式和子程序 ", 
"snippet" : "见 CNC07_Subprogram.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 这个例子演示了如何调用一个  子程序 从 CNC 文件以及使用 表达 在 CNC 运动指令中。 在里面 CNC 程序，驱动器首先被打开，就像在其他例子中一样。这 CNC_PreparePath 程序使用 SMC_ReadNCFile2 用于读取 CNC 文件的功能块。 SMC_ReadNCFile2 创建 SMC_ReadNCFile POU 并扩展它以支持子程序和表达式。 数控程序 CNC2Main.cnc 是通过 SMC_NC...", 
"body" : "见 CNC07_Subprogram.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 这个例子演示了如何调用一个  子程序 从 CNC 文件以及使用 表达 在 CNC 运动指令中。 在里面 CNC 程序，驱动器首先被打开，就像在其他例子中一样。这 CNC_PreparePath 程序使用 SMC_ReadNCFile2 用于读取 CNC 文件的功能块。 SMC_ReadNCFile2 创建 SMC_ReadNCFile POU 并扩展它以支持子程序和表达式。 数控程序 CNC2Main.cnc 是通过 SMC_NCInterpreter 功能块。 SMC_NCInterpreter 创建 SMC_NCDecoder POU 并通过对子例程和表达式的支持对其进行了扩展。 该项目包含两个 CNC 程序：主程序 CNC2Main.cnc 和子程序 CNC2.cnc .主程序传值 25 在里面 #RADIUS 子程序的参数。在子程序中，表达式 X#RADIUS*2 用于计算圆形路径。 主程序 N0 G01 X$g_x$ Y0 F50 E30 E-30\nN10 G01 X0 Y$g_y$\nN20 CNC2{25}\nN30 G01 X0 Y-200 子程序 SUBPROGRAM CNC2{#RADIUS : LREAL}\nN010 G91\nN020 G02 X#RADIUS*2 Y0 R#RADIUS Z2.5 F100 E-100 E100\nN030 G02 X-#RADIUS*2 Y0 R#RADIUS Z7.5\nEND_SUBPROGRAM " }, 
{ "title" : "CNC 实例 08：附加轴的使用 ", 
"url" : "_sm_example_external_axes_usage.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 08：附加轴的使用 ", 
"snippet" : "见 CNC08_AdditionalAxes.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 这个例子扩展了 CNC01_direct.projekt 中描述的项目 CNC实例01：直接生成OutQueue.它演示了如何使用附加轴。与 CNC 示例 01 一样，以定义的速度和加速度逼近 X\/Y 平面中的四个位置。此外，附加轴 A 在每次运动期间运行。程序在路径上设置了两个路径切换点。...", 
"body" : "见 CNC08_AdditionalAxes.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 这个例子扩展了 CNC01_direct.projekt 中描述的项目 CNC实例01：直接生成OutQueue.它演示了如何使用附加轴。与 CNC 示例 01 一样，以定义的速度和加速度逼近 X\/Y 平面中的四个位置。此外，附加轴 A 在每次运动期间运行。程序在路径上设置了两个路径切换点。 " }, 
{ "title" : "在编辑器中编辑 CNC 程序 ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4510557821784033079793683298", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 08：附加轴的使用 \/ 在编辑器中编辑 CNC 程序 ", 
"snippet" : "打开 CNC01_direct.project 安装目录下的项目 CODESYS . 在工程中，打开CNC程序 Example . 将附加轴 A 的位置添加到行进命令中： 数控编辑器 N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30 N10 G02 X84.9 Y84.6 A40 R100 H12 L10 N20 G01 X 6.6 Y25.7 A60 H-1 O0.8 N30 G03 X54.6 Y49.7 A80 R100...", 
"body" : "打开 CNC01_direct.project 安装目录下的项目 CODESYS . 在工程中，打开CNC程序 Example . 将附加轴 A 的位置添加到行进命令中： 数控编辑器 N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30\nN10 G02 X84.9 Y84.6 A40 R100 H12 L10\nN20 G01 X 6.6 Y25.7 A60 H-1 O0.8\nN30 G03 X54.6 Y49.7 A80 R100 " }, 
{ "title" : "创建驱动器接口和 PLC 配置 ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758202758433079807306962", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 08：附加轴的使用 \/ 创建驱动器接口和 PLC 配置 ", 
"snippet" : "插入一个额外的虚拟驱动器 A_Drive 以下 SoftMotion 通用轴池 . 设置参数如下：...", 
"body" : "插入一个额外的虚拟驱动器 A_Drive 以下 SoftMotion 通用轴池 . 设置参数如下： " }, 
{ "title" : "编辑 IEC 程序 ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758311412833079809057524", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 08：附加轴的使用 \/ 编辑 IEC 程序 ", 
"snippet" : "打开 CFC 程序 Ipo . 激活之前添加的驱动器 A_Drive 与 MC_Power 功能块。 在这个例子中，一个简单的方向轴（ A_Drive ) 应使用附加轴 A 进行控制。因此，不再需要转换模块。插补器的设定位置直接对应于驱动器的设定位置，并通过 SMC_POSINFO 选择器与 SMC_ControlAxisByPos 功能块。应用程序不保证插值器的输出是连续的。例如，附加轴的位置结束于与开始不同的点。因此，您应该激活间隙避免（ bAvoidGaps , fGapVelocity , fGapAcceleration ， 和 fGapDeceleration ）。然后连接 bSt...", 
"body" : "打开 CFC 程序 Ipo . 激活之前添加的驱动器 A_Drive 与 MC_Power 功能块。 在这个例子中，一个简单的方向轴（ A_Drive ) 应使用附加轴 A 进行控制。因此，不再需要转换模块。插补器的设定位置直接对应于驱动器的设定位置，并通过 SMC_POSINFO 选择器与 SMC_ControlAxisByPos 功能块。应用程序不保证插值器的输出是连续的。例如，附加轴的位置结束于与开始不同的点。因此，您应该激活间隙避免（ bAvoidGaps , fGapVelocity , fGapAcceleration ， 和 fGapDeceleration ）。然后连接 bStopIpo 输出到 bEmergency_Stop 插值器的输入和连接插值器的输出 iStatus 到轴控制功能块的各个输入端。 最重要的是，在使用 CFC 编程时要注意功能块的正确顺序。 " }, 
{ "title" : "调试 ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4584880865328033079813143466", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 08：附加轴的使用 \/ 调试 ", 
"snippet" : "编译并启动创建的程序。程序一执行 CNC 运动 Execute 已设置插值器的输入。程序完全运行后，您可以应用新的上升沿重新启动它。 在 CNC 程序执行过程中，注意附加轴 A 的位置（ piSetPosition.dA )，这显示在插值 POU 的可视化中。...", 
"body" : "编译并启动创建的程序。程序一执行 CNC 运动 Execute 已设置插值器的输入。程序完全运行后，您可以应用新的上升沿重新启动它。 在 CNC 程序执行过程中，注意附加轴 A 的位置（ piSetPosition.dA )，这显示在插值 POU 的可视化中。 " }, 
{ "title" : "CNC 实例 09：使用刀具长度校正 ", 
"url" : "_sm_example_tool_correction_usage.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 09：使用刀具长度校正 ", 
"snippet" : "见 CNC09_ToolLengthCorr.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 这个例子演示了如何使用 SMC_ToolLengthCorr 用于补偿刀具长度的 POU。 有关刀具长度校正主题的更多信息，请参见： 预处理...", 
"body" : "见 CNC09_ToolLengthCorr.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 这个例子演示了如何使用 SMC_ToolLengthCorr 用于补偿刀具长度的 POU。 有关刀具长度校正主题的更多信息，请参见： 预处理" }, 
{ "title" : "应用 ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm458488080921763308005489139", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 09：使用刀具长度校正 \/ 应用 ", 
"snippet" : "例如，Gantry3 运动学与添加的方向轴 ( AxisA ) 可以绕 Z 轴旋转。在 Z 方向上长度为 2 个单位的刀具依次连接到定向轴。 应该运行一个简单的 CNC 程序。这作为外部存储在项目中 CNC.cnc 文件，可以用文本编辑器打开。在 CNC 程序中，刀具长度修正首先通过 G 代码激活 G43 .这 I , J ， 和 K 为此，参数对应于 X、Y 和 Z 方向的偏移量。接下来，在 XY 平面中移动到三个点。在移动到最后一点的过程中，附加轴 A 也旋转了 90 度。 N000 G43 I0 J0 K2 (Activate tool length correction with to...", 
"body" : "例如，Gantry3 运动学与添加的方向轴 ( AxisA ) 可以绕 Z 轴旋转。在 Z 方向上长度为 2 个单位的刀具依次连接到定向轴。 应该运行一个简单的 CNC 程序。这作为外部存储在项目中 CNC.cnc 文件，可以用文本编辑器打开。在 CNC 程序中，刀具长度修正首先通过 G 代码激活 G43 .这 I , J ， 和 K 为此，参数对应于 X、Y 和 Z 方向的偏移量。接下来，在 XY 平面中移动到三个点。在移动到最后一点的过程中，附加轴 A 也旋转了 90 度。 N000 G43 I0 J0 K2 (Activate tool length correction with tool offset X=0 Y=0 Z=2)\nN010 G01 X10 F10 E100 E-100\nN020 G03 Y10 R5N030 G01 X0 A90 该应用程序由多个部分组成。在里面 CNC_PreparePath 程序，CNC程序 CNC.cnc 作为文件从控制器导入并进行预处理。在里面 CNC 程序中，首先打开驱动器，与其他示例一样。然后执行先前读取的 CNC 程序的插补。在每个循环中，插值器输出一个设定位置 (piSetPosition ) 和刀具的当前偏移量 (adToolLength ）。这 SMC_ToolLengthCorr POU 需要此信息来补偿指定的刀具长度。然后将补偿后的位置转换并最终通过 SMC_ControlAxisByPos POU。 该程序几乎与其他示例相同。只有 SMC_ToolLengthCorr POU 已插入插值器之后和变换之前，以便处理插值器输出的设定位置。 " }, 
{ "title" : "调试 ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm4590758219934433080059282556", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 实例 09：使用刀具长度校正 \/ 调试 ", 
"snippet" : "编译并启动创建的程序。程序执行 CNC 运动，只要 CNC_PreparePath.xStart 输入已设置。您可以点击 开始 按钮以在应用程序或可视化中设置此变量。程序完全运行后，您可以应用新的上升沿重新启动它。 在 CNC 程序执行期间，注意插补器的输出 ( piSetPosition , adToolLength ) 和补偿位置 ( piOut ） 的 SMC_ToolLengthCorr 宝。 注：旋转 AxisA 在 CNC 程序的最后一次移动期间，对本例中的补偿笛卡尔位置没有（附加）影响，因为刀具在 Z 方向上只有一个偏移量。如果在 X 和 Y 方向的刀具偏移（在 CNC 文件中，...", 
"body" : "编译并启动创建的程序。程序执行 CNC 运动，只要 CNC_PreparePath.xStart 输入已设置。您可以点击 开始 按钮以在应用程序或可视化中设置此变量。程序完全运行后，您可以应用新的上升沿重新启动它。 在 CNC 程序执行期间，注意插补器的输出 ( piSetPosition , adToolLength ) 和补偿位置 ( piOut ） 的 SMC_ToolLengthCorr 宝。 注：旋转 AxisA 在 CNC 程序的最后一次移动期间，对本例中的补偿笛卡尔位置没有（附加）影响，因为刀具在 Z 方向上只有一个偏移量。如果在 X 和 Y 方向的刀具偏移（在 CNC 文件中，在应用程序文件夹中的控制器上）添加组件，则 AxisA 在最后一次移动期间将对补偿位置产生额外影响。 " }, 
{ "title" : "读取插值器的状态 ", 
"url" : "_sm_example_state_interpolator.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 读取插值器的状态 ", 
"snippet" : "参见 CNC13_ReadInterpolatorState.project 的安装目录中的示例项目 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 该示例项目显示了如何读取 CNC 插值器的状态。该状态用于在机器和解码器坐标中显示机器的位置...", 
"body" : "参见 CNC13_ReadInterpolatorState.project 的安装目录中的示例项目 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 该示例项目显示了如何读取 CNC 插值器的状态。该状态用于在机器和解码器坐标中显示机器的位置 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234546899564", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 读取插值器的状态 \/ 应用程序的结构 ", 
"snippet" : "该结构是数控应用的典型结构。G 代码在后台任务中读取。插值是在总线任务中执行的 在插值过程中， SMC_ReadAdditionalIpoState 函数块被调用。 插值一开始， Valid 输出是 TRUE 。插值器的位置始终以机器坐标系 (MCS) 输出，然后使用当前的解码器坐标系 (DCS) 进行转换并在可视化中输出 SMC_V3_Set(pos_MCS, ipo.piSetPosition.dX, ipo.piSetPosition.dY, ipo.piSetPosition.dZ); readState(     Enable:= TRUE,     ipo:= ipo); IF r...", 
"body" : "该结构是数控应用的典型结构。G 代码在后台任务中读取。插值是在总线任务中执行的 在插值过程中， SMC_ReadAdditionalIpoState 函数块被调用。 插值一开始， Valid 输出是 TRUE 。插值器的位置始终以机器坐标系 (MCS) 输出，然后使用当前的解码器坐标系 (DCS) 进行转换并在可视化中输出 SMC_V3_Set(pos_MCS, ipo.piSetPosition.dX, ipo.piSetPosition.dY, ipo.piSetPosition.dZ);\n\nreadState(\n    Enable:= TRUE,\n    ipo:= ipo);\n\nIF readState.Valid THEN\n    SMC_PosInfo_Trf_Inverse(\n        piOut:= piMCS_to_DCS,\n        piIn:= readState.State.DCS,\n        eOriConv:= readState.State.OriConv);\n\n SMC_PosInfo_Trf_Apply(\n        vDst:= pos_DCS,\n        piTrf:= piMCS_to_DCS,\n        vSrc:= pos_MCS,\n        eOriConv:= readState.State.OriConv);\nEND_IF 有关解码器坐标系的更多信息，请参阅以下内容： 移动、旋转和缩放坐标系。 " }, 
{ "title" : "调试 ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234714771807", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 读取插值器的状态 \/ 调试 ", 
"snippet" : "生成应用程序并将其下载到控制器。 打开可视化。 启动应用程序，然后按 开始 可视化按钮。 您可以在 MCS 和 DCS 中跟踪 X 和 Y 坐标的移动。...", 
"body" : "生成应用程序并将其下载到控制器。 打开可视化。 启动应用程序，然后按 开始 可视化按钮。 您可以在 MCS 和 DCS 中跟踪 X 和 Y 坐标的移动。 " }, 
{ "title" : "路径预处理功能块的实现 ", 
"url" : "_sm_example_cnc14_path_preprocessing.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 路径预处理功能块的实现 ", 
"snippet" : "参见 CNC14_PathPreprocessing.project 的安装目录中的示例项目 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 该示例项目展示了如何实现新的路径预处理功能块。 路径预处理通常用于修改从 G 代码中读取的路径。这允许实现刀具半径校正或拐角平滑等功能。但是，也可以将特定计算机或应用程序的特定功能集成为路径预处理 有关路径预处理的更多信息，请参阅以下内容： 路径预处理和队列大小。 有关如何使用路径预处理功能块的示例，请参阅以下内容： CNC实例03：在线进行路径预处理。...", 
"body" : "参见 CNC14_PathPreprocessing.project 的安装目录中的示例项目 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 该示例项目展示了如何实现新的路径预处理功能块。 路径预处理通常用于修改从 G 代码中读取的路径。这允许实现刀具半径校正或拐角平滑等功能。但是，也可以将特定计算机或应用程序的特定功能集成为路径预处理 有关路径预处理的更多信息，请参阅以下内容： 路径预处理和队列大小。 有关如何使用路径预处理功能块的示例，请参阅以下内容： CNC实例03：在线进行路径预处理。 " }, 
{ "title" : "限制切线变化 ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234576416031", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 路径预处理功能块的实现 \/ 限制切线变化 ", 
"snippet" : "该示例显示了 2D 切割应用程序。应使用刀子沿着 G 代码定义的路径进行切割。这个 SMC_TRAFO_GantryCutter2 变换用于根据路径的当前切线来确定刀的角度。 挑战在于刀具不能旋转得太快，否则切口将不干净。在示例项目中，通过新创建的路径预处理功能块解决了刀具角速度的限制 LimitTangentVelocity 。它改变路径上的进给速率，使切线的变化速度不超过可配置的最大值 G 代码是一个带有平滑边角的简单矩形。 轨迹显示了执行结果：C 轴的速度以橙色显示，它对应于刀的旋转速度。按照规定，它限制为 45°\/s。...", 
"body" : "该示例显示了 2D 切割应用程序。应使用刀子沿着 G 代码定义的路径进行切割。这个 SMC_TRAFO_GantryCutter2 变换用于根据路径的当前切线来确定刀的角度。 挑战在于刀具不能旋转得太快，否则切口将不干净。在示例项目中，通过新创建的路径预处理功能块解决了刀具角速度的限制 LimitTangentVelocity 。它改变路径上的进给速率，使切线的变化速度不超过可配置的最大值 G 代码是一个带有平滑边角的简单矩形。 轨迹显示了执行结果：C 轴的速度以橙色显示，它对应于刀的旋转速度。按照规定，它限制为 45°\/s。 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234546899564", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 路径预处理功能块的实现 \/ 应用程序的结构 ", 
"snippet" : "该结构是数控应用的典型结构。G 代码在后台任务中读取，路径预处理也在此处进行。插值是在总线任务中执行的 这个 LimitTangentVelocity 功能块显示路径预处理功能块的必要步骤和状态。 基本原理是函数块读取、处理，然后写入路径元素（类型 SMC_GEOINFO ) 来自输入队列 ( poqDataIn ) 到输出队列 ( poqDataOut ）。元素将从输入队列中移除。 更改进给速率的逻辑位于第 102—138 行中。辅助功能 ComputeMaxCurvature 计算给定路径元素上可能出现的最大曲率。 \/\/ Our velocity limitation comes here...", 
"body" : "该结构是数控应用的典型结构。G 代码在后台任务中读取，路径预处理也在此处进行。插值是在总线任务中执行的 这个 LimitTangentVelocity 功能块显示路径预处理功能块的必要步骤和状态。 基本原理是函数块读取、处理，然后写入路径元素（类型 SMC_GEOINFO ) 来自输入队列 ( poqDataIn ) 到输出队列 ( poqDataOut ）。元素将从输入队列中移除。 更改进给速率的逻辑位于第 102—138 行中。辅助功能 ComputeMaxCurvature 计算给定路径元素上可能出现的最大曲率。 \/\/ Our velocity limitation comes here. This modifies an element from the\n\/\/ input queue and copies the modified element to the output queue.\n\/\/ Finally, the element is removed from the input queue\n\nm_geo := pgeo^; \/\/ Copy the element\n \/\/ Note: the feature flags set in the G-Code with G38\/G39 can be queried\n \/\/ by reading pgo^.dwFeatureFlags, like this:\n IF (SHR(m_geo.dwFeatureFlags, featureFlag) AND 1) = 1 THEN\n     \/\/ feature is turned on\n\n     ok := ComputeMaxCurvature(m_geo, kappa=> kappa_max);\n     IF NOT ok THEN\n         \/\/ Curvature cannot be computed\n         m_state := STATE_ERROR;\n         ErrorID := SMC_INVALID_PARAMETER;\n         OnExit();\n         RETURN;\n     END_IF\n\n     \/\/ Compute maximum allowed path velocity based on maximum curvature\n     \/\/ and maximum allowed angular velocity\n     IF kappa_max = 0 THEN\n         \/\/ No curvature, no limitation necessary\n         vel := m_geo.dVel;\n     ELSE\n         vel := m_maxAngularVelocity_rad \/ kappa_max;\n     END_IF\n\n     IF velMin < 0 OR vel < velMin THEN\n         velMin := vel;\n     END_IF\n\n     \/\/ Set new maximum velocity for the element\n     m_geo.dVel := MIN(m_geo.dVel, vel);\n ELSE\n     \/\/ feature is turned off\n END_IF " }, 
{ "title" : "调试 ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234584108811", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 路径预处理功能块的实现 \/ 调试 ", 
"snippet" : "生成应用程序并将其下载到控制器。 启动应用程序。 打开跟踪记录并将其下载到控制器。 写下值 TRUE 到变量 Path.bExecute 和 PLC_PRG.bStart 。 您可以在跟踪中跟踪 G 代码的处理情况。...", 
"body" : "生成应用程序并将其下载到控制器。 启动应用程序。 打开跟踪记录并将其下载到控制器。 写下值 TRUE 到变量 Path.bExecute 和 PLC_PRG.bStart 。 您可以在跟踪中跟踪 G 代码的处理情况。 " }, 
{ "title" : "大型 G 代码文件的预处理 ", 
"url" : "_sm_example_large_c_code.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 大型 G 代码文件的预处理 ", 
"snippet" : "这个 CNC15_LargeGCode.project 示例项目位于的安装目录中 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 该示例项目显示了如何处理大型 G 代码文件。由于超大文件在 CAD\/CAM 系统的输出中特别常见，因此本案例以示例为例 CAD\/CAM 系统通常生成包含数十万行的 G 代码文件。它们由非常短的线性段组成（ G1 ），通常在 100 微米到一毫米之间。这些短的线性段描绘工件的轮廓。它们不能形成一条平坦的道路。切线通常在线性段之间跳转 该示例说明如何在恒定的内存要求下高效地读取这些大文件，以及如何在由这么多短线性段组成的路径上实现...", 
"body" : "这个 CNC15_LargeGCode.project 示例项目位于的安装目录中 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 该示例项目显示了如何处理大型 G 代码文件。由于超大文件在 CAD\/CAM 系统的输出中特别常见，因此本案例以示例为例 CAD\/CAM 系统通常生成包含数十万行的 G 代码文件。它们由非常短的线性段组成（ G1 ），通常在 100 微米到一毫米之间。这些短的线性段描绘工件的轮廓。它们不能形成一条平坦的道路。切线通常在线性段之间跳转 该示例说明如何在恒定的内存要求下高效地读取这些大文件，以及如何在由这么多短线性段组成的路径上实现平滑的速度曲线。在预处理 G 代码时重建了工件的原始轮廓 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231424931037", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 大型 G 代码文件的预处理 \/ 应用程序的结构 ", 
"snippet" : "该结构是数控应用的典型结构。G 代码在后台任务中读取 PathTask ），路径预处理也在这里进行。插值是在总线任务中执行的 ( MainTask ）。...", 
"body" : "该结构是数控应用的典型结构。G 代码在后台任务中读取 PathTask ），路径预处理也在这里进行。插值是在总线任务中执行的 ( MainTask ）。 " }, 
{ "title" : "读取大文件 ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425324995", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 大型 G 代码文件的预处理 \/ 读取大文件 ", 
"snippet" : "为了缩短 G 代码处理开始时的延迟，在后台任务中使用了循环。为简单起见，使用计数器来表示中止条件。根据应用程序、G 代码和 PLC 性能，其他中止条件（例如计时器）可能有用。当路径队列已满时，循环将在达到此中止条件之前结束 \/\/ Set this value depending on your other tasks, PLC performance, and G-Code counter := 25; WHILE counter > 0 AND       (poqDataOut = 0 OR_ELSE (NOT poqDataOut^.bFull AND NOT poqDataOut^.b...", 
"body" : "为了缩短 G 代码处理开始时的延迟，在后台任务中使用了循环。为简单起见，使用计数器来表示中止条件。根据应用程序、G 代码和 PLC 性能，其他中止条件（例如计时器）可能有用。当路径队列已满时，循环将在达到此中止条件之前结束 \/\/ Set this value depending on your other tasks, PLC performance, and G-Code\ncounter := 25;\n\nWHILE counter > 0 AND\n      (poqDataOut = 0 OR_ELSE (NOT poqDataOut^.bFull AND NOT poqDataOut^.bEndOfList))\nDO\n     <Read G-Code and process it>\n\n     counter := counter - 1;\nEND_WHILE 通过管道铺设在 预处理 ，即使是非常大的 G 代码文件也可以在不变的内存要求下读取。选择的队列大小要足够大，以便对应的功能块进行足够的预测。 的输出队列 SMC_NCInterpreter 也是的输入队列 smc_smoothMerg 。总共为输出队列保留了 128+3 个元素。3 是预 SMC_OutQueue 还有 128 个可用作预测 SMC_SmoothMerge 。 SMC_SmoothMerge 将最多 128 个短线性段合并为一个样条。 的输出队列 SMC_SmoothMerge 也是的输入队列 smc_smoothPath 。 SMC_SmoothPath 需要至少 2 个元素，外加 3 个元素的储备作为预测。如果 M 函数位于两个平滑元素之间，则根据 M 函数的数量需要更多元素 的输出队列 SMC_SmoothMerge 也是的输入队列 SMC_Interpolator 。对 100 个元素的预测适用于大多数应用。有关更多信息，请参阅以下内容： 路径预处理和队列大小。 \/\/\/ Buffer of the interpreter, lookahead for SMC_SmoothMerge\naBufIp : ARRAY[0..130] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothMerge\naBufSmm : ARRAY[0..15] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothPath, lookahead for SMC_Interpolator\naBufSmp : ARRAY[0..99] OF SMC_GeoInfo; " }, 
{ "title" : "线性段的预处理 ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425764624", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 大型 G 代码文件的预处理 \/ 线性段的预处理 ", 
"snippet" : "这个 SMC_SmoothMerge 功能块可确保在许多非常短的线性段上保持平滑的速度曲线。它将尽可能多的连续线性段组合成一个样条，同时保持规定的公差。在此示例中，X 和 Y 的最大偏差为 0.1 mm（ PARAMETERS.piMaxDifference ）。 这些图显示了分步处理： 读取短线性片段 使用以下命令将多个线性段组合成样条曲线 SMC_SmoothMerge 。 在样条曲线之间进行平滑处理 SMC_SmoothPath 因为，如上所示，样条彼此之间没有切向连接。...", 
"body" : "这个 SMC_SmoothMerge 功能块可确保在许多非常短的线性段上保持平滑的速度曲线。它将尽可能多的连续线性段组合成一个样条，同时保持规定的公差。在此示例中，X 和 Y 的最大偏差为 0.1 mm（ PARAMETERS.piMaxDifference ）。 这些图显示了分步处理： 读取短线性片段 使用以下命令将多个线性段组合成样条曲线 SMC_SmoothMerge 。 在样条曲线之间进行平滑处理 SMC_SmoothPath 因为，如上所示，样条彼此之间没有切向连接。 " }, 
{ "title" : "调试 ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425998344", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 大型 G 代码文件的预处理 \/ 调试 ", 
"snippet" : "生成应用程序并将其下载到控制器。 打开跟踪记录并将其下载到控制器。 启动应用程序。 您可以跟踪 G 代码的处理情况。...", 
"body" : "生成应用程序并将其下载到控制器。 打开跟踪记录并将其下载到控制器。 启动应用程序。 您可以跟踪 G 代码的处理情况。 " }, 
{ "title" : "CNC 示例 16：探测功能（清除剩余距离）(G31) ", 
"url" : "_sm_example_cnc_16.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 示例 16：探测功能（清除剩余距离）(G31) ", 
"snippet" : "参见 CNC16_G31.project 的安装目录中的示例项目 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 该示例项目显示了如何使用探测功能（清除剩余距离）。 在示例中，机器沿 X 方向移动，直到到达光障 X=50 。一旦到达光障，机器就必须停止。剩余的 G 代码必须从该位置开始处理...", 
"body" : "参见 CNC16_G31.project 的安装目录中的示例项目 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 该示例项目显示了如何使用探测功能（清除剩余距离）。 在示例中，机器沿 X 方向移动，直到到达光障 X=50 。一旦到达光障，机器就必须停止。剩余的 G 代码必须从该位置开始处理 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224424924168", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 示例 16：探测功能（清除剩余距离）(G31) \/ 应用程序的结构 ", 
"snippet" : "该结构是数控应用的典型结构。G 代码在后台任务中读取 PathTask ）。此任务中还完成了路径预处理。插值是在总线任务中执行的 ( MainTask ）。 使用以下 G 代码。在方块中 N10 ，可以进行快速定位 X = 20 。然后，使用 G31（探测功能：清除剩余路径）进行移动 X = 100 。最后，在方块中 N30 ，进行线性运动的作用是 X = 20, Y = 50 。 N10 G0 X20 F100 E1000 E-1000 N20 G31 X100 N30 G1 X20 Y50 插值器和解释器之间的交互对于探测功能（清除剩余路径）尤其重要。 解释器解码 G 代码并从中生成一条直...", 
"body" : "该结构是数控应用的典型结构。G 代码在后台任务中读取 PathTask ）。此任务中还完成了路径预处理。插值是在总线任务中执行的 ( MainTask ）。 使用以下 G 代码。在方块中 N10 ，可以进行快速定位 X = 20 。然后，使用 G31（探测功能：清除剩余路径）进行移动 X = 100 。最后，在方块中 N30 ，进行线性运动的作用是 X = 20, Y = 50 。 N10 G0 X20 F100 E1000 E-1000\nN20 G31 X100\nN30 G1 X20 Y50 插值器和解释器之间的交互对于探测功能（清除剩余路径）尤其重要。 解释器解码 G 代码并从中生成一条直线 X=20 到 X=100 用于区块 N20 。然后它停止解码。 插值器执行线性运动，同时输出探头数作为输出 udiActProbe 。对于 G31，样本数始终为 1 在应用程序中，插值器使用以下命令停止 bQuick_Stop 一旦驱动器超出位置 X=50 。（这模拟了光障。 在总线任务中， SMC_SetInterpreterStartPosition 功能块用于连续复制机器的当前位置。 在 PathTask ，则将起始位置分配给输入 SMC_NCInterpreter.piStartPosition : inter(\n    sentences:= read.sentences,\n    bExecute:= read.bExecute,\n    nSizeOutQueue:= SIZEOF(bufIpo),\n    pbyBufferOutQueue:= ADR(bufIpo),\n    piStartPosition:= Main.setStart.StartPos); 插值器一停止， bAcknProbe 输入用于确认 G31 命令。在实际应用中，此时还应检查轴是否已实际到达停止位置。这个 smc_inPosition 可以使用功能块来执行此操作。 这会导致解释器恢复解码，但更新了起始位置，因此以下内容会阻塞 N30 是从位置开始的 X=55.5 。 下图说明了这些步骤。括号中的数字是指上述过程中的相应步骤。 " }, 
{ "title" : "调试 ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224425037675", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 示例 16：探测功能（清除剩余距离）(G31) \/ 调试 ", 
"snippet" : "生成应用程序并将其下载到控制器。 打开跟踪记录并将其下载到控制器。 启动应用程序并打开可视化。...", 
"body" : "生成应用程序并将其下载到控制器。 打开跟踪记录并将其下载到控制器。 启动应用程序并打开可视化。 " }, 
{ "title" : "CNC 示例 17：从字符串中读取 G 代码 ", 
"url" : "_sm_example_cnc_17.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 示例 17：从字符串中读取 G 代码 ", 
"snippet" : "参见 CNC17_ReadGCodeFromStrings.project CODESYS 安装目录下的示例项目 ..\\CODESYS SoftMotion\\Examples 。 该示例项目展示了如何使用 smc_stringStream2 从字符串中读取 G 代码。 这个例子可以看作是一个起点，用于从其他来源读取 G 代码，例如通过网络通信（套接字）。在这种情况下，需要实现一个功能块来实现 SMC_ITextStream 接口并读取文本（例如，从套接字读取）。这与方法类似 SMC_StringStream2 实现此接口以从字符串中读取 G 代码。...", 
"body" : "参见 CNC17_ReadGCodeFromStrings.project CODESYS 安装目录下的示例项目 ..\\CODESYS SoftMotion\\Examples 。 该示例项目展示了如何使用 smc_stringStream2 从字符串中读取 G 代码。 这个例子可以看作是一个起点，用于从其他来源读取 G 代码，例如通过网络通信（套接字）。在这种情况下，需要实现一个功能块来实现 SMC_ITextStream 接口并读取文本（例如，从套接字读取）。这与方法类似 SMC_StringStream2 实现此接口以从字符串中读取 G 代码。 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224424924168", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 示例 17：从字符串中读取 G 代码 \/ 应用程序的结构 ", 
"snippet" : "该结构是数控应用的典型结构。G 代码在后台任务中读取 PathTask ），路径预处理也在这里进行。插值是在总线任务中执行的 在 Path 程序， SMC_ReadNCFromStream 功能块用于读取 G 代码。出于技术原因，不仅仅是类型的直播 SMC_StringStream2 被传递给这个函数块，但也传递给一个大小取决于参数的数组 SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPTH 。数组中的第一个流用于主程序，而其他流用于可能的子程序调用 一开始，主程序被加载到数组的第一个流中： \/\/ Load G-Code into first strea...", 
"body" : "该结构是数控应用的典型结构。G 代码在后台任务中读取 PathTask ），路径预处理也在这里进行。插值是在总线任务中执行的 在 Path 程序， SMC_ReadNCFromStream 功能块用于读取 G 代码。出于技术原因，不仅仅是类型的直播 SMC_StringStream2 被传递给这个函数块，但也传递给一个大小取决于参数的数组 SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPTH 。数组中的第一个流用于主程序，而其他流用于可能的子程序调用 一开始，主程序被加载到数组的第一个流中： \/\/ Load G-Code into first stream\naStringStream[0].Init(sProgramName) ;\naStringStream[0].AppendData(sGCode) ;\naStringStream[0].SetEndOfData() ; 然后，一切准备就绪，可以读取常用的 G 代码程序。该示例还显示了如何支持子程序调用。 为此，必须创建一个函数块来实现 SMC_INCLookup 接口。此功能块负责在读取子程序时返回子程序的 G 代码 SMC_ReadNCFromStream 。这个 Lookup 方法接收子程序的名称并使用 G 代码初始化传入流： METHOD LookUp : SMC_ERROR\nVAR_IN_OUT CONSTANT\n    programName : STRING;\nEND_VAR\nVAR_INPUT\n    stream : SMC_ITextStream;\nEND_VAR\nVAR\n    i : UDINT ;\n    pStringStream : POINTER TO SMC_StringStream2 ;\nEND_VAR 此示例搜索子程序数组。该数组定义在 Path 编程为 VAR_INPUT : \/\/ The table of subprograms.\n aSubs : ARRAY[0..0] OF SubProgram := [\n            (stName := 'SUB1',\n             stContent := '\nSUBPROGRAM SUB1{#p1 : LREAL, #p2 : LREAL, #p3 : LREAL}\nN10 G1 X#p1\nN20 G1 X#p2\nN30 G1 X#p3\nEND_SUBPROGRAM')\n        ] ; 在 Lookup ，对数组进行迭代，直到找到名称匹配的子程序： i := 0 ;\nWHILE i < nNumSPs DO\n IF psp[i].stName = programName THEN\n IF NOT __QUERYPOINTER(stream, pStringStream) OR_ELSE\n pStringStream = 0\n THEN\n \/\/ A stream of the wrong type has been passed by SMC_ReadNCFromStream.\n LookUp := SMC_CNC_INTERNAL_ERROR ;\n ELSE\n pStringStream^.Init(sName := psp[i].stName) ;\n LookUp := pStringStream^.AppendData(psp[i].stContent) ;\n pStringStream^.SetEndOfData() ;\n END_IF\n RETURN ;\n END_IF\n\n i := i + 1 ;\nEND_WHILE\n \n\/\/ No subprogram with name programName has been found in the array psp.\nLookUp := SMC_RNCF_SUBPROGRAM_FILE_NOT_FOUND ; " }, 
{ "title" : "调试 ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224425037675", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 示例 17：从字符串中读取 G 代码 \/ 调试 ", 
"snippet" : "生成应用程序并将其下载到控制器。 打开可视化。 按 开始 开始 G 代码处理。...", 
"body" : "生成应用程序并将其下载到控制器。 打开可视化。 按 开始 开始 G 代码处理。 " }, 
{ "title" : "CNC 示例 10：编程动态 CNC 路径 ", 
"url" : "_sm_example_dynamic_path.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ CNC 示例 10：编程动态 CNC 路径 ", 
"snippet" : "见 CNC10_DynamicPath.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 此示例展示了如何在运行时直接在应用程序中创建 CNC 路径，而不是使用来自 CNC 程序对象或文件的 G 代码。这种传统的CNC程序编译时，路径数据存放在一个 SMC_CNC_Data 数据结构类型。然后根据编译模式将此内部数据编译为特定的全局数据结构（ SMC_CNC_REF 或者 SMC_OutQueue ). 在编译模式下 SMC_CNC_REF ，数据存储在一个数组中 SMC_GEOINFO 元素。应用程序代码中的数组通...", 
"body" : "见 CNC10_DynamicPath.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 此示例展示了如何在运行时直接在应用程序中创建 CNC 路径，而不是使用来自 CNC 程序对象或文件的 G 代码。这种传统的CNC程序编译时，路径数据存放在一个 SMC_CNC_Data 数据结构类型。然后根据编译模式将此内部数据编译为特定的全局数据结构（ SMC_CNC_REF 或者 SMC_OutQueue ). 在编译模式下 SMC_CNC_REF ，数据存储在一个数组中 SMC_GEOINFO 元素。应用程序代码中的数组通常传递给功能块实例 SMC_NCDecoder .在运行时，数据在那里被解码并存储在一个全局数据结构中 SMC_OUTQUEUE .然后可以调用路径预处理功能块。 在编译模式下 SMC_OutQueue , 一个全局数据结构 ( SMC_OUTQUEUE ) 生成 直接地 .应用程序代码中的这个数据结构被传递给插值器（ SMC_Interpolator FB 实例）。功能块 SMC_NCDecoder 不叫。 在编译模式 文件 ，数据存储在文件中。数据存储为类型元素的数组 SMC_GEOINFO 并对应编译模式下生成的数据 SMC_CNC_REF . 您可以编写一个应用程序代码来实例化类型为 SMC_OUTQUEUE 在运行时并为其赋值。编写在运行时动态生成的 CNC 路径。您可以将数据结构传递给其他功能块实例（例如传递给路径预处理功能块或功能块 SMC_Interpolator ）。 编程 这 CNCDynamicPath 示例项目位于安装目录 CODESYS .示例项目是从 CNConline 项目。它包括 Path 程序而不是图形编程 Example 小路。类型的数据结构 SMC_OUTQUEUE 是动态生成的。 宣言： 声明一个类型的数据结构 SMC_OUTQUEUE .数据结构包含 CNC 路径数据并动态填充。 例子： QUEUE 为具有所需数量的路径分配内存 SMC_GEOINFO 元素。 例子： BUF 声明一个类型的变量 SMC_GEOINFO 与初始步骤。 例子： GEO 执行： 数据类型的数组元素 SMC_GEOINFO 对应于 CNC 代码中的路径元素。必须对每个元素执行以下步骤才能将元素添加到 SMC_OUTQUEUE ： 每个数组元素都有一个起始位置，对应于前一个数组元素的结束位置。 例子： GEO.piStartPos.dX := 0; 或者 GEO.piStartPos := GEO.piDestPos; 确定每个数组元素的移动类型。 例子： GEO.iMoveType := CCLW; 或者 GEO.iMoveType := LIN; 设置运动类型的参数。并非所有运动类型都需要这样做。 示例：对于圆弧（运动类型：CCLW），需要设置以下位置： geoinfo_A[i].dP1 := 200; geoinfo_A[i].dP2 := 100; geoinfo_A[i].dP3 := 50; geoinfo_A[i].dT1 := 0; geoinfo_A[i].dT2 := 90; 插入结束位置的计算。 SMC_CalcEndPnt(ADR(GEO)); 插入对象长度的计算。 SMC_CalcLengthGeo(ADR(GEO)); 将对象保存在 QUEUE ： SMC_AppendObj(POQ:=ADR(QUEUE), PGI:=ADR(GEO)); 完全创建路径后，必须设置结束标记： QUEUE-bEndOfList = TRUE; 然后，当调用路径预处理功能块时，需要设置起始位或结束位 InternMark . 例子 带有两个路径元素的 CNC 路径 在这个例子中，数组没有用 X\/Y 位置定义。如果这应该是一个具有两个路径元素的示例，那么这些数组每个都必须有两个元素。 例如，从示例项目派生： xp:ARRAY[1..2] OF REAL:= [100,50]; yp:ARRAY[1..2] OF REAL:= [0,100]; PROGRAM Path\nVAR\n iState : INT;\n QUEUE : SMC_OUTQUEUE;\n BUF : ARRAY[0..49] OF SMC_GEOINFO;\n \/\/ Memory allocation\n GEO : SMC_GEOINFO:=(dT1:=0, dT2:=1, dToolRadius:=0, dVel:=100, dVel_End:=100, dAccel:=200, dDecel:=500, iObj_Nr:=0);\n \/\/ Initial path element\n n : INT := 0;\n QUEUE.nSize := SIZEOF(BUF);\nEND_VAR\n\nCASE iState OF\n0:\n QUEUE.pbyBuffer := ADR(BUF[0]);\n \/\/ Initialize QUEUE\n SMC_SetQueueCapacity(ADR(QUEUE), SIZEOF(BUF));\n iState := iState + 1;\n\n1:\n \/\/ Fill QUEUE\n WHILE NOT QUEUE.bFull DO\n \/\/ When QUEUE is full, wait until it has been processed by the following FBs\n n := n + 1;\n GEO.iSourceLine_No := n;\n GEO.piStartPos := GEO.piDestPos;\n \/\/ Copying last destination\n GEO.iMoveType := LIN;\n \/\/ Generating linear movement\n GEO.iObjNo := GEO.iObjNo + 1;\n \/\/ Calculating number\n GEO.piDestPos.dX := xp[n];\n \/\/ Generatint position\n GEO.piDestPos.dY := yp[n];\n SMC_CalcLengthGeo(pg := ADR(GEO));\n \/\/ Calculating length of object with the help of the standard function\n SMC_AppendObj(poq:=ADR(QUEUE), pgi:=ADR(GEO));\n \/\/ Appending object to QUEUE\n IF n = SIZEOF(xp)\/SIZEOF(xp[1]) THEN\n \/\/ All target positions processed\n QUEUE.bEndOfList := TRUE;\n n := 0;\n iState := 2;\n EXIT;\n END_IF\n END_WHILE\n\n2:\n \/\/Done\n ;\nEND_CASE\n\nCheckVel(bExecute:=TRUE , poqDataIn:=ADR(queue)); \/\/ Preprocessing 如果 SMC_OUTQUEUE 数据结构填充有 SMC_GEOINFO 数据和数据结构元素被设置为 bFULL = TRUE ，那么我们不建议进一步分配 SMC_GEOINFO 数据。在这种情况下，路径的创建在运行时被中断，直到路径的第一个元素 SMC_OUTQUEUE 数据结构在插值器中处理。只有这样才能插入另一个元素。 通过分配足够的内存来避免这种中断。见变量 BUF . 如果数据结构 SMC_OUTQUEUE 在第一次执行后重新填充，然后是插值器和所有预处理功能块（例如： SMC_CheckVelocities ) 必须在上升沿重新启动 Execute . " }, 
{ "title" : "使用块搜索 ", 
"url" : "_sm_example_using_block_search.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 使用块搜索 ", 
"snippet" : "程序段搜索允许在中断后继续插补。停止位置最先行进，路径从此位置原样行进。为此，必须扩展执行插值的程序和执行路径预处理的程序。 例子 中断的铣头会停止行程。修复后，路径可以继续块搜索。 通过以下方式扩展应用程序 保存预处理位置的插补任务中的功能块实例 缩短路径元素的路径任务中的功能块实例 有关详细信息，请参阅：SMC_BlockSearchSavePos、SMC_BlockSearchPos 和 SMC_BlockSearch 使用块搜索 的一个实例 SMC_BlockSearch 必须在与剩余路径预处理相同的任务中调用功能块，通常直接在 SMC_CheckVelocities 功能块。如果上升...", 
"body" : "程序段搜索允许在中断后继续插补。停止位置最先行进，路径从此位置原样行进。为此，必须扩展执行插值的程序和执行路径预处理的程序。 例子 中断的铣头会停止行程。修复后，路径可以继续块搜索。 通过以下方式扩展应用程序 保存预处理位置的插补任务中的功能块实例 缩短路径元素的路径任务中的功能块实例 有关详细信息，请参阅：SMC_BlockSearchSavePos、SMC_BlockSearchPos 和 SMC_BlockSearch 使用块搜索 的一个实例 SMC_BlockSearch 必须在与剩余路径预处理相同的任务中调用功能块，通常直接在 SMC_CheckVelocities 功能块。如果上升沿存在于 bExecute ，然后执行块搜索。启动后，将运行保存的位置，并且从该位置开始运行路径不变。 声明一个实例 SMC_BlockSearch 路径预处理执行的程序中的功能块。 bs: SMC_BlockSearch; 实现触发 bExecute 的输入 SMC_BlockSearch 实例。 之前保存的位置 SMC_BlockSearchSavePos 功能块必须作为 epos 的输入 SMC_BlockSearch 功能块。 示例：路径预处理中的块搜索 PROGRAM CNC_PreparePath\n...\nVAR\n bs: SMC_BlockSearch;\nEND_VAR\n...\nbs(\n ePos:=CNC.bssp.ePos ,\n bExecute:=rncf.bExecuteDecoder ,\n bAbort:= ,\n bAppend:= ,\n poqDataIn:=ncd.poqDataOut ,\n bStartFromSavedPos:=CNC.bssp.bPositionStored ,\n nSizeOutQueue:=SIZEOF(agiBufBlockSearch) ,\n pbyBufferOutQueue:=ADR(agiBufBlockSearch) ,\n bDone=> ,\n bBusy=> ,\n bError=> ,\n wErrorID=> ,\n poqDataOut=> ); 这 bStartFromSavedPos 输入也可以通过控制变量激活。可以在取消后激活控制变量，以便在上次保存的位置再次继续。 " }, 
{ "title" : "保存预处理位置 ", 
"url" : "_sm_example_using_block_search.html#UUID-c7e93ecd-388f-baf1-4162-0ba994d84585_id_defc89f86dbffeecc0a86463490ce87e_id_04188a3f3bea4adbc0a8640e000b4984", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 使用块搜索 \/ 保存预处理位置 ", 
"snippet" : "您可以使用 SMC_BlockSearchSavePos 用于根据命令保存当前位置的功能块。此时，功能块的实例必须运行在插值器的任务中。示例中的插补器程序名为“CNC”。 声明一个实例 SMC_BlockSearchSavePos 插值执行的程序中的功能块。 bssp: SMC_BlockSearchSavePos; 连接 ipo 的输入 SMC_BlockSearchSavePos 实例到插值器实例。 连接 bExecute 取消 CNC 程序时应用程序中设置的控制变量的输入（例如，如果 bAbort SMC_Interpolator 实例的输入已设置）。位置存储在 ePos 输出用于块搜索...", 
"body" : "您可以使用 SMC_BlockSearchSavePos 用于根据命令保存当前位置的功能块。此时，功能块的实例必须运行在插值器的任务中。示例中的插补器程序名为“CNC”。 声明一个实例 SMC_BlockSearchSavePos 插值执行的程序中的功能块。 bssp: SMC_BlockSearchSavePos; 连接 ipo 的输入 SMC_BlockSearchSavePos 实例到插值器实例。 连接 bExecute 取消 CNC 程序时应用程序中设置的控制变量的输入（例如，如果 bAbort SMC_Interpolator 实例的输入已设置）。位置存储在 ePos 输出用于块搜索，如下所示 SMC_BlockSearc .中断后， bExecute 必须在上升沿复位。 例子 执行插值的程序的一部分 SMC_BlockSearchSavePos CFC 中的功能块。 " }, 
{ "title" : "带令牌修饰符的 readncFile2 ", 
"url" : "_sm_example_readncfile2_token_modifier.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 带令牌修饰符的 readncFile2 ", 
"snippet" : "这个 CNC12_TokenModifier.project 示例项目位于的安装目录中 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 此示例说明如何在导入期间修改 G 代码，以便将路径速度单位（F 字）从 mm\/min 转换为 mm\/s。这是通过插入 G 代码来完成的 1\/60.0 * 读取 F 字的 G 代码时，在速度值之前。 F6000 然后变成 F 1\/60.0 * 6000 ，稍后由 SMC_NCInterpreter 功能块到 F100 。在简单的情况下，你可以跳过乘法 1\/60 然后只需调整值（例如，从 6000 到 100 ）。但是，乘法...", 
"body" : "这个 CNC12_TokenModifier.project 示例项目位于的安装目录中 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 此示例说明如何在导入期间修改 G 代码，以便将路径速度单位（F 字）从 mm\/min 转换为 mm\/s。这是通过插入 G 代码来完成的 1\/60.0 * 读取 F 字的 G 代码时，在速度值之前。 F6000 然后变成 F 1\/60.0 * 6000 ，稍后由 SMC_NCInterpreter 功能块到 F100 。在简单的情况下，你可以跳过乘法 1\/60 然后只需调整值（例如，从 6000 到 100 ）。但是，乘法更为通用，因为它在使用变量时也起作用 F $SPEED$ 变成 F 1\/60.0 * $SPEED$ 。 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818233271", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 带令牌修饰符的 readncFile2 \/ 应用程序的结构 ", 
"snippet" : "与CNC应用程序一样，该应用程序包括路径处理（ CNC_PreparePath 程序）和插值（ CNC 程序）。由于插值与其他示例没有区别，因此此处不作进一步讨论 在低优先级中，每隔 20 毫秒循环调用路径处理 PathTask 。在高优先级中，每 4 毫秒循环调用插值 MotionTask 。后台任务 VISU_TASK 是为可视化定义的。 您可以开始处理可视化中的 G 代码。G 代码和机器的移动（3D 龙门架）显示在可视化的右侧...", 
"body" : "与CNC应用程序一样，该应用程序包括路径处理（ CNC_PreparePath 程序）和插值（ CNC 程序）。由于插值与其他示例没有区别，因此此处不作进一步讨论 在低优先级中，每隔 20 毫秒循环调用路径处理 PathTask 。在高优先级中，每 4 毫秒循环调用插值 MotionTask 。后台任务 VISU_TASK 是为可视化定义的。 您可以开始处理可视化中的 G 代码。G 代码和机器的移动（3D 龙门架）显示在可视化的右侧 " }, 
{ "title" : "G 代码 ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818432406", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 带令牌修饰符的 readncFile2 \/ G 代码 ", 
"snippet" : "CNC_PathSpeed N10 G01 X1000 F6000 N20 Y1000 在这个 G 代码中，以方块为单位的路径速度 N10 设置为 F6000 到 6000 毫米\/分钟。但是，CNC 功能块期望路径速度以 mm\/s 为单位。命令进行两次线性运动，首先是 X=1000 然后到 X=1000, Y=1000 。...", 
"body" : "CNC_PathSpeed N10 G01 X1000 F6000\nN20 Y1000 在这个 G 代码中，以方块为单位的路径速度 N10 设置为 F6000 到 6000 毫米\/分钟。但是，CNC 功能块期望路径速度以 mm\/s 为单位。命令进行两次线性运动，首先是 X=1000 然后到 X=1000, Y=1000 。 " }, 
{ "title" : "代币处理 ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819460923", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 带令牌修饰符的 readncFile2 \/ 代币处理 ", 
"snippet" : "这个 SMC_ReadNCFile2 和 SMC_ReadNCFromStream 功能块提供了在读取 G 代码时执行您自己的转换的能力。这里我们使用的是 SMC_ITokenModifier 接口，通过传递 aTokenModifier 输入。 此接口适用于 “令牌”。这些是 G 代码的基本部分，开始处理时将 G 代码文本细分为 示例 N50 G36 O$plc_variable$ D'TextTest' X-1 (Comment) 此 G 代码细分如下： 文本 SMC_TOKENTYPE SMC_TOKENVALUE N identifer stValue = 'N' 50 number ...", 
"body" : "这个 SMC_ReadNCFile2 和 SMC_ReadNCFromStream 功能块提供了在读取 G 代码时执行您自己的转换的能力。这里我们使用的是 SMC_ITokenModifier 接口，通过传递 aTokenModifier 输入。 此接口适用于 “令牌”。这些是 G 代码的基本部分，开始处理时将 G 代码文本细分为 示例 N50 G36 O$plc_variable$ D'TextTest' X-1 (Comment) 此 G 代码细分如下： 文本 SMC_TOKENTYPE SMC_TOKENVALUE N identifer stValue = 'N' 50 number fValue = 50.0 G identifer stValue = 'G' 36 number fValue = 36.0 O identifer stValue = 'O' $plc_variable$ variable stValue = 'plc_variable' D identifer stValue = 'D' 'TextTest' strLiteral stValue = 'TextTest' X identifer stValue = 'X' - operator stValue = '-' 1 number fValue = 1.0 不需要进一步处理的信息（例如空白字符、换行符和注释）不会出现在标记列表中。 当 SMC_ITokenModifier 接口已实现，可以通过添加新令牌，删除令牌和更改令牌的值来调整令牌列表。 该接口定义了两种方法： Start ：功能块的初始化。内部状态已重置。 Call : 处理 G 代码时调用此方法。可以从输入队列中读取和删除令牌，然后将其添加到输出队列中。 " }, 
{ "title" : "实施 ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819739016", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 带令牌修饰符的 readncFile2 \/ 实施 ", 
"snippet" : "PLC_PRG 中的处理流程如下所示： 所有令牌都从输入队列移到输出队列。 如果检测到 F 字，则有两个新标记， 1\/60 和 * ，在 “F” 的标记之后和速度值的标记之前添加。 这个 Call 方法包含处理令牌的逻辑。首先将令牌从输入队列中移出会很有帮助（ tokensIn ) 到临时队列 ( m_tmpQueue )，在那里处理它们，然后将它们移到输出队列 ( tokensOut ）。临时队列并不是调整路径速度的绝对必要条件，但在更复杂的情况下，它可以简化程序结构。 方法：打电话 起初，系统在 STATE_RUNNING 状态直到处理可以开始（当输入队列中有令牌并且输出队列中仍有空间时）...", 
"body" : "PLC_PRG 中的处理流程如下所示： 所有令牌都从输入队列移到输出队列。 如果检测到 F 字，则有两个新标记， 1\/60 和 * ，在 “F” 的标记之后和速度值的标记之前添加。 这个 Call 方法包含处理令牌的逻辑。首先将令牌从输入队列中移出会很有帮助（ tokensIn ) 到临时队列 ( m_tmpQueue )，在那里处理它们，然后将它们移到输出队列 ( tokensOut ）。临时队列并不是调整路径速度的绝对必要条件，但在更复杂的情况下，它可以简化程序结构。 方法：打电话 起初，系统在 STATE_RUNNING 状态直到处理可以开始（当输入队列中有令牌并且输出队列中仍有空间时）。 IF NOT SMC_NC_CanProcessTokens(tokensIn, tokensOut) THEN\n    \/\/ Wait until processing can proceed\n    RETURN;\nEND_IF 然后将令牌从输入队列移到临时队列。 IF m_tmpQueue.IsEmpty() THEN\n    \/\/ Move the next token from the in-queue to the tmp-queue.\n  pt := tokensIn.GetFromStart(0);\n    m_tmpQueue.Append(pt^);\n    tokensIn.RemoveFirst();\nEND_IF 实际处理是在中完成的 ConvertSpeed 方法。 IF NOT m_tmpQueue.IsEmpty() THEN\n    \/\/ The actual processing is done here\n    ConvertSpeed();\nEND_IF 在方法结束时，令牌从临时队列移动到输出队列。 方法：ConvertSpeed 检查临时队列中的第一个令牌。 如果标识符的值为 F 找到了，然后再添加两个代币：数字 1\/60.0 和操作员 * 。 （选择临时队列大小的方法是，除了输入队列中的一个令牌之外，队列中还能容纳另外两个令牌）。 tk := m_tmpQueue.GetFromStart(0)^;\n\nIF tk.tokenType = SMC_TokenType.identifier THEN\n tk.GetString(pbyString => pby, iSize => iSize);\n \/\/ 70 = ASCII code for F (path velocity)\n IF iSize = 1 AND pby^ = 70 THEN\n \/\/ Insert the number 1\/60\n SMC_Token_InitNumber(\n tk:= tkNumber,\n value:= 1\/60.0,\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkNumber);\n\n \/\/ Insert operator '*' for multiplication\n SMC_Token_InitOperator(\n tk:= tkOperator,\n value:= '*',\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkOperator);\n END_IF\nEND_IF " }, 
{ "title" : "调试 ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869820021001", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 带令牌修饰符的 readncFile2 \/ 调试 ", 
"snippet" : "生成应用程序并将其下载到控制器。 启动应用程序，切换到可视化，然后按 Start 。...", 
"body" : "生成应用程序并将其下载到控制器。 启动应用程序，切换到可视化，然后按 Start 。 " }, 
{ "title" : "特定于用户的 G 代码函数 ", 
"url" : "_sm_custom_g_code_functions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 特定于用户的 G 代码函数 ", 
"snippet" : "这个 CNC11_CustomFunctions.project 示例项目位于的安装目录中 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 此示例说明如何创建自己的函数以用于 G 代码中的表达式。 有关 G 代码中表达式和函数的更多信息，请参阅： 表达式。在这里，您将找到默认支持的所有运算符和函数的列表。 该示例定义了 SEL 操作符来自 IEC 61131-3，因此也可以在 G 代码中使用。...", 
"body" : "这个 CNC11_CustomFunctions.project 示例项目位于的安装目录中 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 此示例说明如何创建自己的函数以用于 G 代码中的表达式。 有关 G 代码中表达式和函数的更多信息，请参阅： 表达式。在这里，您将找到默认支持的所有运算符和函数的列表。 该示例定义了 SEL 操作符来自 IEC 61131-3，因此也可以在 G 代码中使用。 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867931475267", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 特定于用户的 G 代码函数 \/ 应用程序的结构 ", 
"snippet" : "与CNC应用程序一样，该应用程序包括路径处理（ CNC_PreparePath 程序）和插值（ CNC 程序）。由于插值与其他示例没有区别，因此此处将不进一步讨论该主题 在低优先级中，每隔 20 毫秒循环调用路径处理 PathTask 。在高优先级中，每 4 毫秒循环调用插值 MotionTask 。后台任务 VISU_TASK 是为可视化定义的。 在可视化中，您可以开始处理 G 代码并设置变量的值 $LONGLINE$ 。G 代码和机器的移动（3D 龙门架）显示在可视化的右侧...", 
"body" : "与CNC应用程序一样，该应用程序包括路径处理（ CNC_PreparePath 程序）和插值（ CNC 程序）。由于插值与其他示例没有区别，因此此处将不进一步讨论该主题 在低优先级中，每隔 20 毫秒循环调用路径处理 PathTask 。在高优先级中，每 4 毫秒循环调用插值 MotionTask 。后台任务 VISU_TASK 是为可视化定义的。 在可视化中，您可以开始处理 G 代码并设置变量的值 $LONGLINE$ 。G 代码和机器的移动（3D 龙门架）显示在可视化的右侧 " }, 
{ "title" : "G 代码 ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867932695176", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 特定于用户的 G 代码函数 \/ G 代码 ", 
"snippet" : "数控 LET #WIDTH : LREAL N10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110) N20 F50 E100 E-100 N30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2 N40 Y-#WIDTH N50 X-#WIDTH Z-#WIDTH\/2 N60 Y#WIDTH N70 X0 Y0 Z0 第 1 行：局部变量的声明 #WIDTH 类型的 LREAL 。 第 2 行，区块 N10：赋值 SEL($LONGLINE$, 40, 110) 到变量 #WIDTH 。如果 PLC 变量的值 $LONGLINE$ 是 TRUE ，则表达...", 
"body" : "数控 LET #WIDTH : LREAL\nN10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110)\nN20 F50 E100 E-100\nN30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2\nN40 Y-#WIDTH\nN50 X-#WIDTH Z-#WIDTH\/2\nN60 Y#WIDTH\nN70 X0 Y0 Z0 第 1 行：局部变量的声明 #WIDTH 类型的 LREAL 。 第 2 行，区块 N10：赋值 SEL($LONGLINE$, 40, 110) 到变量 #WIDTH 。如果 PLC 变量的值 $LONGLINE$ 是 TRUE ，则表达式的值为 110；否则为 40。 在以下几行中，遍历一个在 Z 方向上有额外移动的矩形；矩形一边的长度为 2*#WIDTH 。 " }, 
{ "title" : "的实施 SEL 函数 ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867935164437", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 特定于用户的 G 代码函数 \/ 的实施 SEL 函数 ", 
"snippet" : "要创建用户定义的函数，你需要编写一个函数块来实现 SMC_NC_IFunction 接口。 有关更多信息，请参阅： smc_nc_iFunction 。 该接口定义了两种方法： GetSignature 。此处返回函数参数的返回类型、计数和类型。在此示例中， SEL 函数返回类型为的值 T_OTHER 并有 3 个类型的参数 T_BOOL ， T_OTHER ，以及 T_OTHER 。 T_OTHER 代表任何类型（要么 T_BOOL ， T_LREAL ，或 T_STRING ]。的所有 3 次出现 T_OTHER 必须具有相同的类型。 METHOD GetSignature VAR_OUT...", 
"body" : "要创建用户定义的函数，你需要编写一个函数块来实现 SMC_NC_IFunction 接口。 有关更多信息，请参阅： smc_nc_iFunction 。 该接口定义了两种方法： GetSignature 。此处返回函数参数的返回类型、计数和类型。在此示例中， SEL 函数返回类型为的值 T_OTHER 并有 3 个类型的参数 T_BOOL ， T_OTHER ，以及 T_OTHER 。 T_OTHER 代表任何类型（要么 T_BOOL ， T_LREAL ，或 T_STRING ]。的所有 3 次出现 T_OTHER 必须具有相同的类型。 METHOD GetSignature\nVAR_OUTPUT\n    resultType : SMC_GVar_Type;\n    nNumArguments : UDINT;\n    pType : POINTER TO SMC_GVar_Type;\nEND_VAR\nVAR    argTypes : ARRAY[0..2] OF SMC_GVar_Type :=\n        [SMC_GVar_Type.T_BOOL,\n         SMC_GVar_Type.T_OTHER,\n         SMC_GVar_Type.T_OTHER];\nEND_VAR\n\nresultType := SMC_GVAR_Type.T_OTHER;\nnNumArguments := 3;\npType := ADR(argTypes); Call ：处理 G 代码时调用此方法。参数是通过传递的 pa 输入。这个表情 pa[0].argValue.bValue 用于访问第一个参数的布尔值。取决于第二个参数的类型 pa[1].argType ，结果是返回值 result.argType 然后分支成一个 CASE 语句。 METHOD Call\nVAR_IN_OUT\n    result : SMC_NC_GArgument;\nEND_VAR\nVAR_INPUT\n    pa : POINTER TO SMC_NC_GArgument;\nEND_VA\nRVAR_OUTPUT\n    eError : SMC_ERROR;\nEND_VAR\nVAR\n    g : BOOL;\nEND_VAR\n\ng := pa[0].argValue.bValue;\n\nresult.argType := pa[1].argType;\n\nCASE result.argType OF\nSMC_GVAR_Type.T_BOOL:\n    result.argValue.bValue := SEL(g, pa[1].argValue.bValue, pa[2].argValue.bValue);\n\nSMC_GVAR_Type.T_STRING:\n    result.argValue.sValue := SEL(g, pa[1].argValue.sValue, pa[2].argValue.sValue);\n\nSMC_GVAR_Type.T_LREAL:\n    result.argValue.fValue := SEL(g, pa[1].argValue.fValue, pa[2].argValue.fValue);\n\nELSE\n    eError := SMC_INVALID_PARAMETER;\nEND_CASE " }, 
{ "title" : "的配置 SMC_ReadNCFile2 ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867956933133", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 特定于用户的 G 代码函数 \/ 的配置 SMC_ReadNCFile2 ", 
"snippet" : "的一个实例 CNC_Sel 函数块是在 GVL_CNCFunctions 全局变量列表。 一个数组 aCNCFunctions 长度为 1 的使用功能块的名称和实例进行初始化。然后将该数组链接到表中 funTable 类型的 SMC_NC_GFunctionTable 。 aCNCFunctions : ARRAY[0..0] OF SMC_NC_GFunction :=     [(stName:= 'SEL', iFunc:= GVL_CNCFunctions.g_Sel)]; funTable : SMC_NC_GFunctionTable :=     (numFunctions:= ...", 
"body" : "的一个实例 CNC_Sel 函数块是在 GVL_CNCFunctions 全局变量列表。 一个数组 aCNCFunctions 长度为 1 的使用功能块的名称和实例进行初始化。然后将该数组链接到表中 funTable 类型的 SMC_NC_GFunctionTable 。 aCNCFunctions : ARRAY[0..0] OF SMC_NC_GFunction :=\n    [(stName:= 'SEL', iFunc:= GVL_CNCFunctions.g_Sel)];\n\nfunTable : SMC_NC_GFunctionTable :=\n    (numFunctions:= 1,     pFunction:= ADR(aCNCFunctions)) ; 最后，将此表传递给 SMC_ReadNCFile2 功能块： rncf2 : SMC_ReadNCFile2 := (bParenthesesAsComments:= FALSE);\n\n[...]\n\nrncf2(\n    bExecute:= TRUE,\n    sFileName:= sFileName,\n    pCustomFunTable:= ADR(funTable),\n    pvl:= ADR(varList)); " }, 
{ "title" : "调试 ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867960408693", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 例子 \/ 特定于用户的 G 代码函数 \/ 的配置 SMC_ReadNCFile2 \/ 调试 ", 
"snippet" : "生成应用程序并将其下载到控制器。 启动应用程序，切换到可视化，然后按 Start 。你可以使用 Longline 用于设置变量值的单选按钮 $LONGLINE$ 在 G 代码中 TRUE 或者 FALSE 。...", 
"body" : "生成应用程序并将其下载到控制器。 启动应用程序，切换到可视化，然后按 Start 。你可以使用 Longline 用于设置变量值的单选按钮 $LONGLINE$ 在 G 代码中 TRUE 或者 FALSE 。 " }, 
{ "title" : "用户界面 ", 
"url" : "_sm_cnc_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：分析动力学 ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：分析动力学 ", 
"snippet" : "分析动力学 功能 ：该命令开始对编辑器中激活的 CNC 路径进行动力学分析。同时根据时间确定CNC路径的位置、速度、加速度、加加速度的量纲，并在时间图上显示出来。 动力学分析 对话。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 为了对 CNC 路径进行动力学分析，其路径预处理的计算中不得有任何错误。 有关更多信息，请参阅： 显示预处理路径...", 
"body" : "分析动力学 功能 ：该命令开始对编辑器中激活的 CNC 路径进行动力学分析。同时根据时间确定CNC路径的位置、速度、加速度、加加速度的量纲，并在时间图上显示出来。 动力学分析 对话。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 为了对 CNC 路径进行动力学分析，其路径预处理的计算中不得有任何错误。 有关更多信息，请参阅： 显示预处理路径" }, 
{ "title" : "动力学分析 对话 ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html#UUID-172573a8-7bc5-69ee-931b-3074ace95453_id_f14ff69a244133a5c0a8640e0144954d_id_72da7ed158aa22a9c0a864637a09d164", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：分析动力学 \/ 动力学分析 对话 ", 
"snippet" : "对话框中的设置专门用于显示动力学分析，对 CNC 程序或 CNC 设置没有影响。 在动力学分析中，位置、速度、加速度和加加速度等维度的时间曲线是为所行进的整个路径确定的。时间图显示在同一时间轴上的对话框中。使用对话框的设置（预设或保存）。 位置图 所选轴的位置曲线（黑色） 红色圆圈；表示路径元素的开始 标记的工具提示提供有关相应 G 代码或表格中行号的信息。 速度图 选定轴的速度曲线（蓝色） 加速度图 所选轴的加速度曲线（绿色） 急动图 所选轴的急动曲线（橙色） 设置在关闭时保存并在下次打开对话框时使用。例如，缩放因子仅使曲线的一部分可见。 放大时间曲线的一部分 选择： 控制 + + 控制 +...", 
"body" : "对话框中的设置专门用于显示动力学分析，对 CNC 程序或 CNC 设置没有影响。 在动力学分析中，位置、速度、加速度和加加速度等维度的时间曲线是为所行进的整个路径确定的。时间图显示在同一时间轴上的对话框中。使用对话框的设置（预设或保存）。 位置图 所选轴的位置曲线（黑色） 红色圆圈；表示路径元素的开始 标记的工具提示提供有关相应 G 代码或表格中行号的信息。 速度图 选定轴的速度曲线（蓝色） 加速度图 所选轴的加速度曲线（绿色） 急动图 所选轴的急动曲线（橙色） 设置在关闭时保存并在下次打开对话框时使用。例如，缩放因子仅使曲线的一部分可见。 放大时间曲线的一部分 选择： 控制 + + 控制 + 鼠标滚轮 缩小时间曲线 选择： 控制 + —— 控制 + 鼠标滚轮 放大时间曲线以显示整个 CNC 路径 轴 轴的选择： X , Y , Z , A , B , C , A1(P) , A2(Q) , A3 (U) , A4(V) , A5(W) , A6 ， 或者 小路 预设： X 轴 小路 轴：显示路径位置、路径速度、路径加速度和路径加加速度 循环时间 [µs] 价值 dwIpoTime 的输入 SMC_Interpolator 功能块 预设：值 循环时间 [µs] 在对象 数控设置 （标签 预插值 ) 速度模式 的价值 iVelMode 的输入 SMC_Interpolator 功能块 梯形 梯形速度剖面 乙状结肠 喜欢 梯形 ，但上升沿或下降沿被同一表面的 sin² 函数取代。 在这种速度模式下，超过限制值大约为 π\/2。 Sigmoid 有限 喜欢 乙状结肠 ，但插入路径的持续时间与速度模式中的长度相同 梯形 . 默认 二次方 带加加速度限制的梯形加速度曲线 加加速度达到最大值 最大加速度 [u\/s³] .这导致二次速度分布。位置分布由三次多项式组成。结果是速度剖面由抛物线组成，加速度由线性段组成，加加速度由水平线段组成。 最大加速度 [u\/s³] 混蛋限制 " }, 
{ "title" : "命令：从 DXF 文件导入 ", 
"url" : "_sm_cmd_cnc_dxf_import.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：从 DXF 文件导入 ", 
"snippet" : "从 DXF 文件导入 功能 ：该命令打开默认对话框。选择文件后， 导入 DXF 文件 对话框打开，用于配置将 DXF 文件导入 CNC 编辑器。 称呼 ： 数控 菜单 要求 : CNC 对象在编辑器中打开。 文件导入时 DXF 标准的限制 SPLINE 元素没有完全导入。这些基本样条仅读取和定位控制点。 不支持外部引用。 （这些是对其他 DXF 文件的引用 BLOCK 元素。） 仅当椭圆存在于 X\/Y 平面时才受支持。 圆弧（元素 ARC ) 和圆圈 (元素 CIRCLE ) 仅当所有空间轴的缩放比例相等时才受支持（元素的参数 41、42 和 43 INSERT ）。这也影响元素 POLYLI...", 
"body" : "从 DXF 文件导入 功能 ：该命令打开默认对话框。选择文件后， 导入 DXF 文件 对话框打开，用于配置将 DXF 文件导入 CNC 编辑器。 称呼 ： 数控 菜单 要求 : CNC 对象在编辑器中打开。 文件导入时 DXF 标准的限制 SPLINE 元素没有完全导入。这些基本样条仅读取和定位控制点。 不支持外部引用。 （这些是对其他 DXF 文件的引用 BLOCK 元素。） 仅当椭圆存在于 X\/Y 平面时才受支持。 圆弧（元素 ARC ) 和圆圈 (元素 CIRCLE ) 仅当所有空间轴的缩放比例相等时才受支持（元素的参数 41、42 和 43 INSERT ）。这也影响元素 POLYLINE 和 LWPOLYLINE 其中包括弧（参数 bulge 不等于 0 ）。 块引用（元素 INSERT ) 仅当缩放矩阵不是镜像时才支持。 （缩放因子的乘积必须为正。） 不支持区域元素、多边形网格和多面网格。实体元素 ( SOLID , ...) 也不支持。 要素 MLINE （多行）， RAY , XLINE ， 和 LEADER （引线）不受支持。 要素 TEXT , MTEXT ， 和 DIMENSION 不支持。 线宽、颜色和样式以及有关元素可见性的信息都将被忽略。 二进制 DXF 文件（文件扩展名 DXB ) 不受支持。 不支持的元素在导入时被忽略（隐式）。 " }, 
{ "title" : "导入 DXF 文件 对话 ", 
"url" : "_sm_cmd_cnc_dxf_import.html#UUID-ceb47740-324e-76a2-abd9-2d1fa27e1a26_id_fde6e1824400e36c0a8640e013dba7a_id_754451675df6e481c0a8646326153262", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：从 DXF 文件导入 \/ 导入 DXF 文件 对话 ", 
"snippet" : "图层 技术图纸的所有图层；根据 DXF 文件中的数据确定 ：将导入图层。 最大间隙尺寸 几何元素的端点之间的距离，直到这些点被视为互连。根据 DXF 文件中的数据确定。 例子： 0.001 在 CNC 路径上预览 所选 DXF 文件的数据以其导入 CNC 编辑器的方式显示。选择用于查看的图层也会被考虑在内。 例子： 看法 切换预览窗口中考虑的图层。 x\/y 平面；选择观看 x\/z-平面 y\/z 平面 按钮 ' 进口 ' 数据被加载到 CNC 编辑器中，并替换现有的 CNC 程序。块编号是自动分配的。 CNC 对象保留其名称。...", 
"body" : "图层 技术图纸的所有图层；根据 DXF 文件中的数据确定 ：将导入图层。 最大间隙尺寸 几何元素的端点之间的距离，直到这些点被视为互连。根据 DXF 文件中的数据确定。 例子： 0.001 在 CNC 路径上预览 所选 DXF 文件的数据以其导入 CNC 编辑器的方式显示。选择用于查看的图层也会被考虑在内。 例子： 看法 切换预览窗口中考虑的图层。 x\/y 平面；选择观看 x\/z-平面 y\/z 平面 按钮 ' 进口 ' 数据被加载到 CNC 编辑器中，并替换现有的 CNC 程序。块编号是自动分配的。 CNC 对象保留其名称。 " }, 
{ "title" : "命令：CNC 信息 ", 
"url" : "_sm_cmd_cnc_info.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：CNC 信息 ", 
"snippet" : "数控信息 功能 : 命令打开 关于程序 <名称> 的 CNC 信息 对话。 称呼 ： 数控 菜单 对象的上下文菜单（类型 数控程序 ) 要求 : CNC 程序在编辑器中打开。 生成的代码 对话 该对话框显示当前 CNC 程序的 IEC 初始化代码，具体取决于功能块的编译模式 SMC_OutQueue 或者 SMC_CNC_REF . 示例：IEC 初始化代码 {attribute 'linkalways'} VAR_GLOBAL {attribute 'init_on_onlchange'} {attribute 'init_on_onlchange'} Example : SMC_CNC_R...", 
"body" : "数控信息 功能 : 命令打开 关于程序 <名称> 的 CNC 信息 对话。 称呼 ： 数控 菜单 对象的上下文菜单（类型 数控程序 ) 要求 : CNC 程序在编辑器中打开。 生成的代码 对话 该对话框显示当前 CNC 程序的 IEC 初始化代码，具体取决于功能块的编译模式 SMC_OutQueue 或者 SMC_CNC_REF . 示例：IEC 初始化代码 {attribute 'linkalways'}\nVAR_GLOBAL\n {attribute 'init_on_onlchange'}\n {attribute 'init_on_onlchange'}\n Example : SMC_CNC_REF := (nElements := 22, strProgramName := 'Example', piStartPosition := (iFrameNo:=0, wAuxData:=7, wSProfile:=0, dX:=0, dY:=0, dZ:=0, dA:=0, dB:=0, dC:=0, dA1:=0, dA2:=0, dA3:=0, dA4:=0, dA5:=0, dA6:=0), pgc := ADR(Example_D), xPartofLM := TRUE);\n {attribute 'blobinit'}\n {attribute 'init_on_onlchange'}\n Example_D : ARRAY[0..21] OF SMC_GCODE_WORD := [\n {p 35184372088832 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 70, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 69, fValue:=100, diValue:=100),\n {p 35184372088832 }\n (byLetter := 69, fValue:=-100, diValue:=-100),\n {p 35184372088832 }\n (byLetter := 128, fValue:=1, diValue:=1),\n {p 36283883716609 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 36835250143233 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 38486665068545 }\n (byLetter := 88, pAdr := ADR(g_x), byVarType := ANY_TO_BYTE(__TYPEOF(g_x) + 32)),\n {p 36291399909377 }\n (byLetter := 89, fValue:=0, diValue:=0),\n {p 36842766336001 }\n (byLetter := 70, fValue:=50, diValue:=50),\n {p 36844913819649 }\n (byLetter := 69, fValue:=30, diValue:=30),\n {p 37396817117185 }\n (byLetter := 69, fValue:=-30, diValue:=-30),\n {p 35184372088832 }\n (byLetter := 128, fValue:=2, diValue:=2),\n {p 36833639530498 }\n (byLetter := 78, fValue:=10, diValue:=10),\n {p 36835787014146 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683906 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 38488812552194 }\n (byLetter := 89, pAdr := ADR(g_y), byVarType := ANY_TO_BYTE(__TYPEOF(g_y) + 32)),\n {p 35184372088832 }\n (byLetter := 128, fValue:=3, diValue:=3),\n {p 36833639530499 }\n (byLetter := 78, fValue:=20, diValue:=20),\n {p 36835787014147 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683907 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 36289789296643 }\n (byLetter := 89, fValue:=0, diValue:=0)];\nEND_VAR " }, 
{ "title" : "<名称> 程序的 CNC 信息 对话 ", 
"url" : "_sm_cmd_cnc_info.html#UUID-ad8caf78-e0cf-3500-0750-16c2eb5fabe7_id_dc9afe4124423d69c0a8640e01f781e8_id_fc2c1e2959841990c0a864630e5a26e5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：CNC 信息 \/ <名称> 程序的 CNC 信息 对话 ", 
"snippet" : "该对话框提供有关指定 CNC 程序的信息。 节目名称 例子： Workpiece_1 功能块版本 例子： 4.2.0.0 行数 例子： 5 对象数 例子： 3 路径长度 [单位] 例子： 261.803398874992 持续时间 [s] 穿过预处理路径的时间（以秒为单位） 例子： 10.158 要求：路径预处理无错误且成功生成插值点 显示生成的代码 这 生成的代码 对话框打开。 要求：程序没有错误。...", 
"body" : "该对话框提供有关指定 CNC 程序的信息。 节目名称 例子： Workpiece_1 功能块版本 例子： 4.2.0.0 行数 例子： 5 对象数 例子： 3 路径长度 [单位] 例子： 261.803398874992 持续时间 [s] 穿过预处理路径的时间（以秒为单位） 例子： 10.158 要求：路径预处理无错误且成功生成插值点 显示生成的代码 这 生成的代码 对话框打开。 要求：程序没有错误。 " }, 
{ "title" : "命令：从 ASCII 文件加载程序 ", 
"url" : "_sm_cmd_cnc_load_program_from_ascii_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：从 ASCII 文件加载程序 ", 
"snippet" : "从 ASCII 文件加载程序 功能 : 命令加载一个 ASCII 将带有 CNC 程序数据的文件导入 CNC 编辑器。 CNC 对象保留其名称。 称呼 ： 数控 菜单 要求 : CNC 对象在编辑器中打开。 该命令打开用于搜索文件系统的默认对话框。过滤器必须设置为 CNC、GCODE 或 TXT。所选文件被加载到激活的 CNC 编辑器中。任何现有的 CNC 程序都会被覆盖（在另一个查询之后）。...", 
"body" : "从 ASCII 文件加载程序 功能 : 命令加载一个 ASCII 将带有 CNC 程序数据的文件导入 CNC 编辑器。 CNC 对象保留其名称。 称呼 ： 数控 菜单 要求 : CNC 对象在编辑器中打开。 该命令打开用于搜索文件系统的默认对话框。过滤器必须设置为 CNC、GCODE 或 TXT。所选文件被加载到激活的 CNC 编辑器中。任何现有的 CNC 程序都会被覆盖（在另一个查询之后）。 " }, 
{ "title" : "命令：移动程序 ", 
"url" : "_sm_cmd_cnc_move_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：移动程序 ", 
"snippet" : "移动程序 功能 : 命令打开 翻译向量 用于配置 CNC 路径移动的对话框。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。...", 
"body" : "移动程序 功能 : 命令打开 翻译向量 用于配置 CNC 路径移动的对话框。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 " }, 
{ "title" : "约束 ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_e69692297289ca8ec0a864631a178469", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：移动程序 \/ 约束 ", 
"snippet" : "在以下条件下可以移动 CNC 路径： 没有使用 A、B 或 C 轴的 变量...", 
"body" : "在以下条件下可以移动 CNC 路径： 没有使用 A、B 或 C 轴的 变量 " }, 
{ "title" : "翻译向量 对话 ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：移动程序 \/ 翻译向量 对话 ", 
"snippet" : "所有轴坐标中的平移向量 X 默认： 1.0000000 Y Z P Q U V W 好的 这将移动 CNC 路径。此外，在第一条定位指令之前，在CNC 程序中插入一个G0 指令（相对定位指令）和平移矢量的坐标。定位指令为 G1、G2、G3、G5、G6、G8、G9、G10、G11、G92。 如果 G54、G55 或 G56 指令移动 CNC 程序中的坐标系，则在这些指令中调整参数。直到 G53 的程序段都不需要任何进一步的调整。 如果 G56 指令是第一个定位指令，则仅调整该指令。 块编号是自动分配的。...", 
"body" : "所有轴坐标中的平移向量 X 默认： 1.0000000 Y Z P Q U V W 好的 这将移动 CNC 路径。此外，在第一条定位指令之前，在CNC 程序中插入一个G0 指令（相对定位指令）和平移矢量的坐标。定位指令为 G1、G2、G3、G5、G6、G8、G9、G10、G11、G92。 如果 G54、G55 或 G56 指令移动 CNC 程序中的坐标系，则在这些指令中调整参数。直到 G53 的程序段都不需要任何进一步的调整。 如果 G56 指令是第一个定位指令，则仅调整该指令。 块编号是自动分配的。 " }, 
{ "title" : "命令：重新编号 CNC 程序 ", 
"url" : "_sm_cmd_cnc_renumber_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：重新编号 CNC 程序 ", 
"snippet" : "重新编号 CNC 程序 象征： 功能 ：该命令刷新CNC 程序中的程序行编号。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 编号从 0 开始并按 10 递增。没有块编号的每个块都会收到一个编号。 G20 程序段中的 L 代码已更正。...", 
"body" : "重新编号 CNC 程序 象征： 功能 ：该命令刷新CNC 程序中的程序行编号。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 编号从 0 开始并按 10 递增。没有块编号的每个块都会收到一个编号。 G20 程序段中的 L 代码已更正。 " }, 
{ "title" : "命令：反转方向 ", 
"url" : "_sm_cmd_cnc_reverse_direction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：反转方向 ", 
"snippet" : "反转方向 功能 ：该命令反转 CNC 程序并以相反的顺序设置路径元素。 CNC 程序的程序段号也会自动复位。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 约束 在以下条件下可以反转 CNC 路径： 如果 CNC 程序选择了预处理，则 G41\/G42 程序段在反向程序中处理：G41 变为 G42，G42 变为 G41。修正的方向也颠倒了。 如果 CNC 程序包含用张角定义的圆弧（2D 元素的参数 K 或 3D 元素的参数 T），则该命令不会生成精确的反向圆弧。 如果通过以下方式编写 CNC 路径，则无法反转。 什么时候不倒车 使用轴 A、B 或 C 使用变量 调用步骤抑制...", 
"body" : "反转方向 功能 ：该命令反转 CNC 程序并以相反的顺序设置路径元素。 CNC 程序的程序段号也会自动复位。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 约束 在以下条件下可以反转 CNC 路径： 如果 CNC 程序选择了预处理，则 G41\/G42 程序段在反向程序中处理：G41 变为 G42，G42 变为 G41。修正的方向也颠倒了。 如果 CNC 程序包含用张角定义的圆弧（2D 元素的参数 K 或 3D 元素的参数 T），则该命令不会生成精确的反向圆弧。 如果通过以下方式编写 CNC 路径，则无法反转。 什么时候不倒车 使用轴 A、B 或 C 使用变量 调用步骤抑制 " }, 
{ "title" : "命令：旋转程序 ", 
"url" : "_sm_cmd_cnc_rotate_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：旋转程序 ", 
"snippet" : "轮换计划 功能 : 命令打开 旋转参数 配置 CNC 路径旋转的对话框。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。...", 
"body" : "轮换计划 功能 : 命令打开 旋转参数 配置 CNC 路径旋转的对话框。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 " }, 
{ "title" : "约束 ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_45841f775e56fd50c0a864632eb28d67", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：旋转程序 \/ 约束 ", 
"snippet" : "在以下条件下可以旋转 CNC 路径： 没有使用 A、B 或 C 轴的 变量...", 
"body" : "在以下条件下可以旋转 CNC 路径： 没有使用 A、B 或 C 轴的 变量 " }, 
{ "title" : "旋转参数 对话 ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：旋转程序 \/ 旋转参数 对话 ", 
"snippet" : "角度（度） 旋转角度（以度为单位） 旋转轴 . 例子： 给定的 绕 Z 轴旋转 X 轴指向右侧，Y 轴指向下方。观察方向与旋转轴相反（右手定则）。 对于负值，顺时针旋转。对于正值，逆时针旋转。 旋转轴 只有当 CNC 路径的元素都是 3D 元素时，才能选择旋转轴。 如果以下元素之一的 CNC 路径包括： G5样条 抛物线 椭圆 二维圆弧 旋转轴由参数定义 X , 是 ， 和 Z . 默认： X : 0, 是 : 0, Z : 1 --> 绕Z轴旋转 X 默认： 0.00000 Y 默认： 0.00000 Z 默认： 1.00000 好的 执行旋转。块编号是自动分配的。...", 
"body" : "角度（度） 旋转角度（以度为单位） 旋转轴 . 例子： 给定的 绕 Z 轴旋转 X 轴指向右侧，Y 轴指向下方。观察方向与旋转轴相反（右手定则）。 对于负值，顺时针旋转。对于正值，逆时针旋转。 旋转轴 只有当 CNC 路径的元素都是 3D 元素时，才能选择旋转轴。 如果以下元素之一的 CNC 路径包括： G5样条 抛物线 椭圆 二维圆弧 旋转轴由参数定义 X , 是 ， 和 Z . 默认： X : 0, 是 : 0, Z : 1 --> 绕Z轴旋转 X 默认： 0.00000 Y 默认： 0.00000 Z 默认： 1.00000 好的 执行旋转。块编号是自动分配的。 " }, 
{ "title" : "命令：缩放程序 ", 
"url" : "_sm_cmd_cnc_scale_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：缩放程序 ", 
"snippet" : "规模计划 功能 : 命令打开 规模计划 配置 CNC 路径缩放的对话框。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。...", 
"body" : "规模计划 功能 : 命令打开 规模计划 配置 CNC 路径缩放的对话框。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 " }, 
{ "title" : "约束 ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_1320e28c7289c9f2c0a864633d064770", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：缩放程序 \/ 约束 ", 
"snippet" : "在以下条件下可以缩放 CNC 路径： 没有使用 A、B 或 C 轴的 变量...", 
"body" : "在以下条件下可以缩放 CNC 路径： 没有使用 A、B 或 C 轴的 变量 " }, 
{ "title" : "规模计划 对话 ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：缩放程序 \/ 规模计划 对话 ", 
"snippet" : "缩放因子 默认： 0.001 条件：缩放因子 >= 1e-3 对于比例因子 > 1，它被放大。 轴 ：轴被缩放。 D（刀具半径） : 刀具半径 D 被缩放。 好的 执行缩放。块编号是自动分配的。...", 
"body" : "缩放因子 默认： 0.001 条件：缩放因子 >= 1e-3 对于比例因子 > 1，它被放大。 轴 ：轴被缩放。 D（刀具半径） : 刀具半径 D 被缩放。 好的 执行缩放。块编号是自动分配的。 " }, 
{ "title" : "命令：滚动路径视图 ", 
"url" : "_sm_cmd_cnc_scroll_path_view.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：滚动路径视图 ", 
"snippet" : "滚动路径视图 功能 ：该命令激活和取消激活 CNC 路径的滚动。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 如果激活滚动，则 CNC 路径的视图在图形编辑器中滚动和放大，以便在 CNC 程序中选择的路径元素完全可见。...", 
"body" : "滚动路径视图 功能 ：该命令激活和取消激活 CNC 路径的滚动。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 如果激活滚动，则 CNC 路径的视图在图形编辑器中滚动和放大，以便在 CNC 程序中选择的路径元素完全可见。 " }, 
{ "title" : "命令：设置变量 ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：设置变量 ", 
"snippet" : "设置变量 功能 : 命令打开 变量的离线值 对话。 CNC 程序的变量可以在此处定义为离线模式。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。...", 
"body" : "设置变量 功能 : 命令打开 变量的离线值 对话。 CNC 程序的变量可以在此处定义为离线模式。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 " }, 
{ "title" : "变量的离线值 对话 ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html#UUID-101f0c28-cef6-51dc-ec33-33b8d27ee9c8_id_c97aba1d244400ffc0a8640e01a5ad6c_id_d54502d95df6e2f6c0a8646351ba116d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：设置变量 \/ 变量的离线值 对话 ", 
"snippet" : "多变的 CNC程序的变量 例子： G_X 如果变量以灰色斜体显示，则它没有在 CNC 程序中使用。 价值 配置的离线值 例子： 100 设置为在线值 这些值将被应用程序中当前分配的值覆盖。 要求：该命令在应用程序运行且 CNC 编辑器处于在线模式时可用。然后可以加载在线值。 好的 如果这些值有效，则将它们应用到 CNC 程序中并刷新编辑器的路径。...", 
"body" : "多变的 CNC程序的变量 例子： G_X 如果变量以灰色斜体显示，则它没有在 CNC 程序中使用。 价值 配置的离线值 例子： 100 设置为在线值 这些值将被应用程序中当前分配的值覆盖。 要求：该命令在应用程序运行且 CNC 编辑器处于在线模式时可用。然后可以加载在线值。 好的 如果这些值有效，则将它们应用到 CNC 程序中并刷新编辑器的路径。 " }, 
{ "title" : "命令：显示端点 ", 
"url" : "_sm_cmd_cnc_show_end_points.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：显示端点 ", 
"snippet" : "显示终点 功能 ：该命令激活和取消激活 CNC 路径点的显示。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 如果显示被激活，则所有路径元素都提供有端点。...", 
"body" : "显示终点 功能 ：该命令激活和取消激活 CNC 路径点的显示。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 如果显示被激活，则所有路径元素都提供有端点。 " }, 
{ "title" : "命令：显示网格 ", 
"url" : "_sm_cmd_cnc_show_grid.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：显示网格 ", 
"snippet" : "显示网格 象征： 功能 ：该命令激活和取消激活图形编辑器中网格的显示。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 缩放系数决定了网格线的间距。扩展路径决定了网格大小。...", 
"body" : "显示网格 象征： 功能 ：该命令激活和取消激活图形编辑器中网格的显示。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 缩放系数决定了网格线的间距。扩展路径决定了网格大小。 " }, 
{ "title" : "命令：显示插值点 ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：显示插值点 ", 
"snippet" : "显示插值点 象征： 功能 ：该命令激活和取消激活插值点的显示。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 如果激活插补点显示，则 CNC 路径显示插补点。 在 CNC 设置对话框中设置的循环时间 ( 预插值 tab)，用于确定插值点。此外，该功能还决定是否在编辑器中通过预处理显示 CNC 路径。...", 
"body" : "显示插值点 象征： 功能 ：该命令激活和取消激活插值点的显示。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 如果激活插补点显示，则 CNC 路径显示插补点。 在 CNC 设置对话框中设置的循环时间 ( 预插值 tab)，用于确定插值点。此外，该功能还决定是否在编辑器中通过预处理显示 CNC 路径。 " }, 
{ "title" : "在图形编辑器中显示 ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html#UUID-043dd64e-e07a-5e2b-2f1d-fc2a843ef4b7_id_be380e1242fa185c0a8640e005adee9_id_d6d5fcd172c9c53cc0a864633c37464d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：显示插值点 \/ 在图形编辑器中显示 ", 
"snippet" : "插值点以垂直于运动方向的线显示。线的长度与当前路径速度成正比。这使得粗略估计速度行为成为可能。 更大的距离和更长的线路 高速 更短的距离和更短的线路 低速 红色的 内插器减速。 绿 内插器被加速。 灰色的 内插器具有恒定的速度。...", 
"body" : "插值点以垂直于运动方向的线显示。线的长度与当前路径速度成正比。这使得粗略估计速度行为成为可能。 更大的距离和更长的线路 高速 更短的距离和更短的线路 低速 红色的 内插器减速。 绿 内插器被加速。 灰色的 内插器具有恒定的速度。 " }, 
{ "title" : "命令：步进抑制 ", 
"url" : "_sm_cmd_cnc_step_suppression.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：步进抑制 ", 
"snippet" : "阶跃抑制 象征： 功能 ：该命令激活和取消激活阶跃抑制。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 CNC 程序执行为 DIN66025。 如果激活步抑制，则 CNC 程序中以 \/ 被忽略。 如果 CNC 程序以表格形式执行，则该命令不可用。...", 
"body" : "阶跃抑制 象征： 功能 ：该命令激活和取消激活阶跃抑制。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 CNC 程序执行为 DIN66025。 如果激活步抑制，则 CNC 程序中以 \/ 被忽略。 如果 CNC 程序以表格形式执行，则该命令不可用。 " }, 
{ "title" : "命令：将程序写入 ASCII 文件 ", 
"url" : "_sm_cmd_cnc_write_program_to_ascii_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：将程序写入 ASCII 文件 ", 
"snippet" : "将程序写入 ASCII 文件 功能 ：该命令打开用于将文件保存到文件系统的默认对话框。 CNC 程序可以保存为 ASCII 文件。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 姓名 默认值：CNC 对象的名称 例子： cncSpiral_A 文件类型 文件扩展名： TXT , GCODE , CNC...", 
"body" : "将程序写入 ASCII 文件 功能 ：该命令打开用于将文件保存到文件系统的默认对话框。 CNC 程序可以保存为 ASCII 文件。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 姓名 默认值：CNC 对象的名称 例子： cncSpiral_A 文件类型 文件扩展名： TXT , GCODE , CNC " }, 
{ "title" : "命令：显示预处理路径 ", 
"url" : "_sm_cmd_cnc_show_preprocessed_path.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 命令：显示预处理路径 ", 
"snippet" : "显示预处理路径 象征： 功能 ：该命令激活和取消激活带预处理的 CNC 路径的显示。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 如果显示处于活动状态，则路径经过预处理显示，原始路径在背景中以浅灰色显示。 预处理配置在 数控设置 对话框 ( 路径预处理 标签）。显示在那里配置的预处理。然后您可以模拟不同功能块（串联）对预处理的影响。 该命令对代码生成没有任何影响。 即使在编译 CNC 程序时生成了 SMC_OutQueue 文件结构，该命令对文件内容也没有任何影响。编译时总是考虑预处理。...", 
"body" : "显示预处理路径 象征： 功能 ：该命令激活和取消激活带预处理的 CNC 路径的显示。 称呼 ： 数控 菜单 要求 : CNC 路径在编辑器中打开。 如果显示处于活动状态，则路径经过预处理显示，原始路径在背景中以浅灰色显示。 预处理配置在 数控设置 对话框 ( 路径预处理 标签）。显示在那里配置的预处理。然后您可以模拟不同功能块（串联）对预处理的影响。 该命令对代码生成没有任何影响。 即使在编译 CNC 程序时生成了 SMC_OutQueue 文件结构，该命令对文件内容也没有任何影响。编译时总是考虑预处理。 " }, 
{ "title" : "数控程序 目的 ", 
"url" : "_sm_f_reference_object_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 数控程序 目的 ", 
"snippet" : "数控程序...", 
"body" : "数控程序 " }, 
{ "title" : "概述 ", 
"url" : "_sm_f_reference_object_cnc_program-1561724.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 数控程序 目的 \/ 概述 ", 
"snippet" : "CODESYS 提供在两种不同的编辑器中创建 CNC 程序的功能：DIN 66025 编辑器和表格编辑器。两个编辑器都显示编程路径的图形视图。 尽管可以在编辑器之间交换编程，但这可能会导致信息丢失。 各个编辑器提供不同的元素处理。 元素 DIN 66025 编辑器 表格编辑器 定位 X X 线 X X 弧 X X 椭圆 X X 样条 X X 快速定位 X X 功能 X X 抛物线 X 使用变量 X 跳 X 坐标偏移 X 阶跃抑制 X 停留时间 X 与内插器的时序同步 X 有关更多信息，请参阅： 表格编辑器 和 DIN 66025 编辑器...", 
"body" : "CODESYS 提供在两种不同的编辑器中创建 CNC 程序的功能：DIN 66025 编辑器和表格编辑器。两个编辑器都显示编程路径的图形视图。 尽管可以在编辑器之间交换编程，但这可能会导致信息丢失。 各个编辑器提供不同的元素处理。 元素 DIN 66025 编辑器 表格编辑器 定位 X X 线 X X 弧 X X 椭圆 X X 样条 X X 快速定位 X X 功能 X X 抛物线 X 使用变量 X 跳 X 坐标偏移 X 阶跃抑制 X 停留时间 X 与内插器的时序同步 X 有关更多信息，请参阅： 表格编辑器 和 DIN 66025 编辑器" }, 
{ "title" : "表格编辑器 ", 
"url" : "_sm_obj_cnc_program_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 数控程序 目的 \/ 表格编辑器 ", 
"snippet" : "在表格编辑器中，路径命令列在表格中。在 表格编辑器 选项卡，在 数控设置 ，您可以自定义此表的列。这 数控设置 作为设备树中的一个对象。 默认情况下，所选路径元素的属性显示在表格的右侧。这些不能在那里编辑。 选择一条线时，将在图形编辑器中绘制相应的运动路径。元素类型确定可以更改路径元素的哪些特定属性。不可编辑的参数以阴影显示。按 F6 键将焦点切换到图形编辑器并返回。 有关此编辑器支持的元素的概述，请参见“对象 CNC 程序”一章。 有关更多信息，请参阅： 在表格编辑器中编程路径 和 图形编辑器...", 
"body" : "在表格编辑器中，路径命令列在表格中。在 表格编辑器 选项卡，在 数控设置 ，您可以自定义此表的列。这 数控设置 作为设备树中的一个对象。 默认情况下，所选路径元素的属性显示在表格的右侧。这些不能在那里编辑。 选择一条线时，将在图形编辑器中绘制相应的运动路径。元素类型确定可以更改路径元素的哪些特定属性。不可编辑的参数以阴影显示。按 F6 键将焦点切换到图形编辑器并返回。 有关此编辑器支持的元素的概述，请参见“对象 CNC 程序”一章。 有关更多信息，请参阅： 在表格编辑器中编程路径 和 图形编辑器" }, 
{ "title" : "DIN 66025 编辑器 ", 
"url" : "_sm_obj_cnc_program_din66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 数控程序 目的 \/ DIN 66025 编辑器 ", 
"snippet" : "在该编辑器中，您可以根据 DIN 66025 将路径元素指定为 CNC 程序。默认情况下，所选路径元素的属性显示在右侧。但是，它们不能在那里修改。 选择一条线时，将在图形编辑器中绘制相应的运动路径。按 F6 键将焦点切换到图形编辑器并返回。 有关此编辑器支持的元素的概述，请参见“对象 CNC 程序”一章。 请注意，当解释器处理块时，在解码器模块中评估全局变量的引用。这可能会在物体行进之前提前几个周期发生。 有关更多信息，请参阅： 根据 DIN 66025 编程路径 和 数控设置...", 
"body" : "在该编辑器中，您可以根据 DIN 66025 将路径元素指定为 CNC 程序。默认情况下，所选路径元素的属性显示在右侧。但是，它们不能在那里修改。 选择一条线时，将在图形编辑器中绘制相应的运动路径。按 F6 键将焦点切换到图形编辑器并返回。 有关此编辑器支持的元素的概述，请参见“对象 CNC 程序”一章。 请注意，当解释器处理块时，在解码器模块中评估全局变量的引用。这可能会在物体行进之前提前几个周期发生。 有关更多信息，请参阅： 根据 DIN 66025 编程路径 和 数控设置" }, 
{ "title" : "图形编辑器 ", 
"url" : "_sm_obj_cnc_program_graphical.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 数控程序 目的 \/ 图形编辑器 ", 
"snippet" : "图形编辑器位于 CNC 表格编辑器和 DIN 66025 编辑器的下部。该编辑器用于显示已编程的 CNC 程序。 编辑器提供了修改和扩展路径的工具。 编辑器的结构 (1)：符合 DIN 66025 的表格编辑器或编辑器 (2)：属性视图：显示所选路径元素的属性 (3)：图形编辑器 (4)：控制面板：用于控制摄像机位置和查看方向的元素 (5)：修改路径的工具 关于使用图形编辑器的注意事项 选定的路径元素显示为红色。 定位指令（G0）和开关点功能以绿色显示。 如果元素的端点是可移动的，则它会显示为一个黑色的小圆圈。 起点和终点切线显示为灰色。 所选路径元素的当前位置显示在状态栏中。 注意用于缩放和...", 
"body" : "图形编辑器位于 CNC 表格编辑器和 DIN 66025 编辑器的下部。该编辑器用于显示已编程的 CNC 程序。 编辑器提供了修改和扩展路径的工具。 编辑器的结构 (1)：符合 DIN 66025 的表格编辑器或编辑器 (2)：属性视图：显示所选路径元素的属性 (3)：图形编辑器 (4)：控制面板：用于控制摄像机位置和查看方向的元素 (5)：修改路径的工具 关于使用图形编辑器的注意事项 选定的路径元素显示为红色。 定位指令（G0）和开关点功能以绿色显示。 如果元素的端点是可移动的，则它会显示为一个黑色的小圆圈。 起点和终点切线显示为灰色。 所选路径元素的当前位置显示在状态栏中。 注意用于缩放和移动整个路径的 CNC 菜单命令。 注意安装中包含的示例程序 CODESYS SoftMotion . " }, 
{ "title" : "工具 ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_0ffa6b2d9c1625bec0a8646341693b76", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 数控程序 目的 \/ 图形编辑器 \/ 工具 ", 
"snippet" : "您可以使用工具在图形编辑器中修改和扩展运动路径。更改在文本编辑器和表格编辑器中同时可见。 选择 ：此工具选择一个点或一个路径元素。然后该元素显示为红色，起点为蓝色。图形编辑器中的鼠标指针变为指针。 线 : 添加或插入新行。图形编辑器中的鼠标指针变为十字。 插入圆（顺时针） ：添加或插入新圆弧（顺时针）。图形编辑器中的鼠标指针变为十字。 插入圆（逆时针） ：添加或插入新圆弧（逆时针）。图形编辑器中的鼠标指针变为十字。 样条 ：添加或插入新的样条点。图形编辑器中的鼠标指针变为十字。...", 
"body" : "您可以使用工具在图形编辑器中修改和扩展运动路径。更改在文本编辑器和表格编辑器中同时可见。 选择 ：此工具选择一个点或一个路径元素。然后该元素显示为红色，起点为蓝色。图形编辑器中的鼠标指针变为指针。 线 : 添加或插入新行。图形编辑器中的鼠标指针变为十字。 插入圆（顺时针） ：添加或插入新圆弧（顺时针）。图形编辑器中的鼠标指针变为十字。 插入圆（逆时针） ：添加或插入新圆弧（逆时针）。图形编辑器中的鼠标指针变为十字。 样条 ：添加或插入新的样条点。图形编辑器中的鼠标指针变为十字。 " }, 
{ "title" : "相机位置和观察方向 ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_05ff18059c1625bec0a864634ba4f71d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 数控程序 目的 \/ 图形编辑器 \/ 相机位置和观察方向 ", 
"snippet" : "您可以使用鼠标以任何方式修改程序路径上的位置和相机视角。 鼠标左键 按下 + 鼠标移动：沿显示平面中的轴移动相机位置。 鼠标右键 按下 + 鼠标移动：在 CNC 程序上旋转视图。 控制 + 鼠标滚轮 ：更改缩放系数。...", 
"body" : "您可以使用鼠标以任何方式修改程序路径上的位置和相机视角。 鼠标左键 按下 + 鼠标移动：沿显示平面中的轴移动相机位置。 鼠标右键 按下 + 鼠标移动：在 CNC 程序上旋转视图。 控制 + 鼠标滚轮 ：更改缩放系数。 " }, 
{ "title" : "用于显示控制的操作面板 ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_4693d34dba46042bc0a864633b130501", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 数控程序 目的 \/ 图形编辑器 \/ 用于显示控制的操作面板 ", 
"snippet" : "在图形编辑器的左上角，一个操作面板提供了用于更改路径视图的各种命令。在此过程中不会修改路径。相反，仅更改相机位置和相机视角。 您可以通过单击黑色箭头折叠控制面板以最大化编辑器工作区的大小。再次单击可展开控制面板。 控制面板提供以下用于设置方向、位置和缩放的命令。 放大 缩小 更改摄像机间距（顺时针） 改变相机间距（逆时针） 改变相机偏航（顺时针） 改变相机偏航（逆时针） 旋转相机（顺时针） 旋转相机（逆时针） 向上移动相机 向左移动相机 向右移动相机 向下移动相机 将视图方向设置为负 z 轴并重新缩放 将视图方向设置为 x 轴并重新缩放 将视图方向设置为 y 轴并重新缩放...", 
"body" : "在图形编辑器的左上角，一个操作面板提供了用于更改路径视图的各种命令。在此过程中不会修改路径。相反，仅更改相机位置和相机视角。 您可以通过单击黑色箭头折叠控制面板以最大化编辑器工作区的大小。再次单击可展开控制面板。 控制面板提供以下用于设置方向、位置和缩放的命令。 放大 缩小 更改摄像机间距（顺时针） 改变相机间距（逆时针） 改变相机偏航（顺时针） 改变相机偏航（逆时针） 旋转相机（顺时针） 旋转相机（逆时针） 向上移动相机 向左移动相机 向右移动相机 向下移动相机 将视图方向设置为负 z 轴并重新缩放 将视图方向设置为 x 轴并重新缩放 将视图方向设置为 y 轴并重新缩放 " }, 
{ "title" : "对话框：CNC 属性 ", 
"url" : "_sm_dlg_cnc_program_properties.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 数控程序 目的 \/ 对话框：CNC 属性 ", 
"snippet" : "象征： 功能 : 该对话框提供参数 数控程序 目的。 称呼 ： 查看 → 属性 命令;对象的上下文菜单 要求 ：CNC 对象在设备树中被选中。 应用程序范围的 CNC 设置保存在 数控设置 目的。...", 
"body" : "象征： 功能 : 该对话框提供参数 数控程序 目的。 称呼 ： 查看 → 属性 命令;对象的上下文菜单 要求 ：CNC 对象在设备树中被选中。 应用程序范围的 CNC 设置保存在 数控设置 目的。 " }, 
{ "title" : "标签：常规 ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_e398c87e5062d26bc0a86520014051d1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 数控程序 目的 \/ 对话框：CNC 属性 \/ 标签：常规 ", 
"snippet" : "更改 CNC 对象的名称。...", 
"body" : "更改 CNC 对象的名称。 " }, 
{ "title" : "标签：访问控制 ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_6f1287e45062d25bc0a865200009f33d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 数控程序 目的 \/ 对话框：CNC 属性 \/ 标签：访问控制 ", 
"snippet" : "在此指定用户组的权限。 有关更多信息，请参阅： 属性 - 访问控制...", 
"body" : "在此指定用户组的权限。 有关更多信息，请参阅： 属性 - 访问控制 " }, 
{ "title" : "标签：构建 ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_18be1ff163875181c0a865ca014256df", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 数控程序 目的 \/ 对话框：CNC 属性 \/ 标签：构建 ", 
"snippet" : "激活选项以从构建中排除 CNC 对象。然后不生成 IEC 数据。但是，可以将 G 代码保存为 ASCII 文件。要在运行时读取此类文件，您可以使用以下功能块 SM3_CNC 图书馆。 有关更多信息，请参阅： 属性 - 访问控制...", 
"body" : "激活选项以从构建中排除 CNC 对象。然后不生成 IEC 数据。但是，可以将 G 代码保存为 ASCII 文件。要在运行时读取此类文件，您可以使用以下功能块 SM3_CNC 图书馆。 有关更多信息，请参阅： 属性 - 访问控制 " }, 
{ "title" : "数控 标签 ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 数控程序 目的 \/ 对话框：CNC 属性 \/ 数控 标签 ", 
"snippet" : "执行 DIN66025 ：运动路径以 CNC 语言 DIN 66025 定义。 桌子 ：运动路径通过表格的参数化来定义。 编译方式 编译时的行为 SMC_OutQueue : 编译时生成 SMC_OutQueue 数据结构。您通过以下方式获得全球访问权限 g_CNCQueueManager . SMC_CNC_REF : 程序变量在编译时生成。您通过以下方式获得全球访问权限 g_CNCProgManager . 文件 ：每次登录都会下载并更新G代码生成的文件。 PLC 可以通过功能块下载该文件。每次登录应用程序时，G 代码文件都会更新。这意味着每次登录时都会覆盖 PLC 上的文件。 文档名称 ...", 
"body" : "执行 DIN66025 ：运动路径以 CNC 语言 DIN 66025 定义。 桌子 ：运动路径通过表格的参数化来定义。 编译方式 编译时的行为 SMC_OutQueue : 编译时生成 SMC_OutQueue 数据结构。您通过以下方式获得全球访问权限 g_CNCQueueManager . SMC_CNC_REF : 程序变量在编译时生成。您通过以下方式获得全球访问权限 g_CNCProgManager . 文件 ：每次登录都会下载并更新G代码生成的文件。 PLC 可以通过功能块下载该文件。每次登录应用程序时，G 代码文件都会更新。这意味着每次登录时都会覆盖 PLC 上的文件。 文档名称 要求： 编译方式 被设定为 文件 . 默认： $ObjectName$.cnc .该默认值是一个占位符，在登录时由 CNC 对象的对象名称（有效文件名）替换。文件名中只允许使用字符 [a-zA-Z0-9$_.]。文件名字段不得为空或以点开头或结尾。此外，点不必是文件名中路径的一部分。 队列大小 [元素] 默认值：100 大小设置不影响生成的大小 SMC_OutQueue 数据结构（选择此模式时）。的大小 SMC_OutQueue 仅由路径对象的数量决定。但是，该参数设置预处理 FB 的缓冲区大小（例如， SMC_NCDecoder , SMC_RoundPath ) 在内部使用并定义前瞻缓冲区的大小。 默认值 速度 (F) [u\/s] 当速度值（在“F”字中）未在 CNC 程序中设置时使用该值。以每秒路径单位为单位。取值范围：[0, 1e9]。默认值：0 加速度 (E+) [u\/s²] 当加速度值（在“E”字中为正值）未设置时使用该值。以每秒平方的路径单位为单位。值范围：]0, 1e9]。 默认值：100 减速度 (E-) [u\/s²] 当减速度值（在带有负值的“E”字中）未设置时使用该值。以每秒平方的路径单位为单位。值范围：]0, 1e9]。 默认值：100 快进 (G0) 的默认值 速度 (FF) [u\/s] 当速度的进给值（在“FF”字中）未在 CNC 程序中设置时使用该值。以每秒路径单位为单位。取值范围：[0, 1e9]。 默认值：0 加速度 (EF+) [u\/s²] 当加速度的进给值（在“EF+”字中为正值）未设置时使用该值。以每秒平方的路径单位为单位。取值范围：[0, 1e9]。 默认值：0 减速度 (EF-) [u\/s²] 当减速的进给值（在带有负值的“EF-”字中）未设置时使用该值。以每秒平方的路径单位为单位。取值范围：[0, 1e9]。 默认值：0 3D 模式 要求：实施 DIN66025 , 翻译模式 CNC_REF ， 和 输出队列 ：3D 模式是默认值。 变量的离线值 变量 ：如果定义了离线值，则 变量的离线值 对话框打开。在此对话框中，显示了也可以编辑的变量。 开始位置 默认值：0 精确 路径的精度（以技术单位表示）。此值指定从 G 代码读取的位置的精度。例如，如果 G 代码指定为 3 位小数，则精度应设置为 0.001 个单位。精度不得为负数。例如，此值用于路径预处理，例如 SMC_ToolRadiusCorr 和 SMC_AvoidLoop 。 " }, 
{ "title" : "对象：CNC 设置 ", 
"url" : "_sm_obj_cnc_settings.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 对象：CNC 设置 ", 
"snippet" : "数控设置 象征： 该对象中的设置对应用程序的所有 CNC 对象都有效。该对象将添加到应用程序的设备树中，或者在将 CNC 对象添加到应用程序时自动生成。对象在每个应用程序中只能存在一次并且不能重命名。 在对象的编辑器中，可以为路径预处理模块、预插补和 CNC 表格编辑器指定设置。你可以删除 数控设置 对象仅当应用程序下方不存在 CNC 对象时。 仅对特定 CNC 程序有效的设置保存在 设置 CNC 程序的对话框。...", 
"body" : "数控设置 象征： 该对象中的设置对应用程序的所有 CNC 对象都有效。该对象将添加到应用程序的设备树中，或者在将 CNC 对象添加到应用程序时自动生成。对象在每个应用程序中只能存在一次并且不能重命名。 在对象的编辑器中，可以为路径预处理模块、预插补和 CNC 表格编辑器指定设置。你可以删除 数控设置 对象仅当应用程序下方不存在 CNC 对象时。 仅对特定 CNC 程序有效的设置保存在 设置 CNC 程序的对话框。 " }, 
{ "title" : "选项卡：路径预处理器 ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_de809dbaa55775c9c0a8646311985883", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 对象：CNC 设置 \/ 选项卡：路径预处理器 ", 
"snippet" : "在此选项卡上，通过选择功能块对路径预处理进行编程。 可用的功能块 所有可用功能块的列表 活动功能块实例 所选功能块实例的列表 列表中的位置定义了处理顺序并且可以更改。 一个功能块可以在列表中多次实例化。 范围 打开 <所选活动功能块实例>的参数编辑器 对话 替代方法：双击活动的功能块实例 将功能块的实例添加到 活动功能块实例 在 活动功能块实例 删除选定的功能块实例 以浅灰色斜体显示的功能块的功能块实例无法删除。 将选定的活动功能块实例向上移动一行 替代方案：按 转移 + 向上箭头 将选定的活动功能块实例向下移动一行 替代方案：按 转移 + 向下箭头 <所选活动功能块实例>的参数编辑器 对话 ...", 
"body" : "在此选项卡上，通过选择功能块对路径预处理进行编程。 可用的功能块 所有可用功能块的列表 活动功能块实例 所选功能块实例的列表 列表中的位置定义了处理顺序并且可以更改。 一个功能块可以在列表中多次实例化。 范围 打开 <所选活动功能块实例>的参数编辑器 对话 替代方法：双击活动的功能块实例 将功能块的实例添加到 活动功能块实例 在 活动功能块实例 删除选定的功能块实例 以浅灰色斜体显示的功能块的功能块实例无法删除。 将选定的活动功能块实例向上移动一行 替代方案：按 转移 + 向上箭头 将选定的活动功能块实例向下移动一行 替代方案：按 转移 + 向下箭头 <所选活动功能块实例>的参数编辑器 对话 该对话框用于显示和更改所选实例的输入。并非所有输入都是可见的。 斯帕特1 所选活动功能块实例的参数名称 斯帕特2 用于设置值的列表框 斯帕特3 参数说明 " }, 
{ "title" : "选项卡：预插值 ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_9a258724a55775c9c0a8646350128da9", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 对象：CNC 设置 \/ 选项卡：预插值 ", 
"snippet" : "周期时间 µs 插值时间 初始值：20000 速度模式 梯形 : 梯形的速度曲线 S形 : 速度曲线类似于梯形曲线，但使用 sin² 函数代替线性速度斜坡 Sigmoid 有限 ：速度曲线类似于 sigmoidal 曲线，但要考虑加速和减速的限制 二次方 : 具有梯形形状的加速度曲线，如定义的加加速度限制 最大加加速度 .由此产生的二次速度分布也被认为是一条 S 曲线。 二次（平滑） : 像 二次方 模式，但会生成一个没有跳跃的混蛋曲线。 最大加速度 [u\/s³] 加加速度绝对值的限制 仅用于二次速度剖面 调用插补器的各个任务的插补时间和循环时间必须与 CNC 编辑器和在线应用程序的相同行为相...", 
"body" : "周期时间 µs 插值时间 初始值：20000 速度模式 梯形 : 梯形的速度曲线 S形 : 速度曲线类似于梯形曲线，但使用 sin² 函数代替线性速度斜坡 Sigmoid 有限 ：速度曲线类似于 sigmoidal 曲线，但要考虑加速和减速的限制 二次方 : 具有梯形形状的加速度曲线，如定义的加加速度限制 最大加加速度 .由此产生的二次速度分布也被认为是一条 S 曲线。 二次（平滑） : 像 二次方 模式，但会生成一个没有跳跃的混蛋曲线。 最大加速度 [u\/s³] 加加速度绝对值的限制 仅用于二次速度剖面 调用插补器的各个任务的插补时间和循环时间必须与 CNC 编辑器和在线应用程序的相同行为相匹配。 " }, 
{ "title" : "选项卡：表格编辑器 ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_section-idm43260108321858", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion 数控系统 \/ 用户界面 \/ 对象：CNC 设置 \/ 选项卡：表格编辑器 ", 
"snippet" : "表格编辑器的列及其顺序在此选项卡上定义。 表格列 所有可用属性的列表 ：该属性在表格编辑器中可见。 此列表中的顺序决定了表格编辑器中的行顺序。 将所选属性向上移动一行 将所选属性向下移动一行...", 
"body" : "表格编辑器的列及其顺序在此选项卡上定义。 表格列 所有可用属性的列表 ：该属性在表格编辑器中可见。 此列表中的顺序决定了表格编辑器中的行顺序。 将所选属性向上移动一行 将所选属性向下移动一行 " }, 
{ "title" : "CODESYS SoftMotion Robotics ", 
"url" : "_sm_f_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_sm_overview_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 概述 ", 
"snippet" : "CODESYS SoftMotion Robotics 为机器人的运动控制提供了功能块接口，该接口基于 PLCopen 规范“运动控制功能块第 4 部分”。复杂的运动序列可以由简单的点对点或连续的路径运动组成，例如直线或圆弧。各个运动之间可以进行可配置的混合（例如，基于距离或速度）。速度、加速度和急动限制（包括各个轴和路径上的）均被考虑在内。 轨迹规划在线完成 CODESYS 控制器，与运动执行并行。可以在处理时添加新动作，而无需停止机器人。 交付范围包括不同标准机器人的运动学模型，从简单的龙门架到 Delta 和 SCARA 机器人以及典型的六轴工业机器人。特殊机器的自定义运动学模型可以以 ...", 
"body" : "CODESYS SoftMotion Robotics 为机器人的运动控制提供了功能块接口，该接口基于 PLCopen 规范“运动控制功能块第 4 部分”。复杂的运动序列可以由简单的点对点或连续的路径运动组成，例如直线或圆弧。各个运动之间可以进行可配置的混合（例如，基于距离或速度）。速度、加速度和急动限制（包括各个轴和路径上的）均被考虑在内。 轨迹规划在线完成 CODESYS 控制器，与运动执行并行。可以在处理时添加新动作，而无需停止机器人。 交付范围包括不同标准机器人的运动学模型，从简单的龙门架到 Delta 和 SCARA 机器人以及典型的六轴工业机器人。特殊机器的自定义运动学模型可以以 IEC 61131-3 功能块的形式链接。同样，动态模型可以通过接口使用，以限制发生的力和扭矩，并启用扭矩前馈控制。 其他功能块用于轻松实现典型用例。这包括与移动坐标系同步、中断和恢复运动，或通过触发器控制高精度数字输出。 " }, 
{ "title" : "入门 ", 
"url" : "_sm_robotics_first_steps.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 入门 ", 
"snippet" : "要为机器人的轴运动编程，您首先需要在项目中的应用程序下方创建一个轴组。有关此的更多信息，请参阅： 如何创建轴组. 您可以使用所需的运动学配置创建的轴组。在设备下方插入真实或虚拟轴，并将这些轴链接到轴组。有关更多信息，请参阅帮助页面 运动学： 轴心国位置和方向运动学的结合旋转接头和模数轴值范围超过 360° 的旋转轴创建和配置轴后如何创建轴控制程序的示例如下所示： 如何创建控制轴组的程序有关如何实现各种运动控制要求的信息，请参阅其他帮助页面 运动控制 . 缓冲和混合动作轴组的点动运动的中断和继续与移动坐标系同步配置工具偏移可在此处找到了解特定运动如何执行的背景信息： CP 运动的方向插值对于高级...", 
"body" : "要为机器人的轴运动编程，您首先需要在项目中的应用程序下方创建一个轴组。有关此的更多信息，请参阅： 如何创建轴组. 您可以使用所需的运动学配置创建的轴组。在设备下方插入真实或虚拟轴，并将这些轴链接到轴组。有关更多信息，请参阅帮助页面 运动学： 轴心国位置和方向运动学的结合旋转接头和模数轴值范围超过 360° 的旋转轴创建和配置轴后如何创建轴控制程序的示例如下所示： 如何创建控制轴组的程序有关如何实现各种运动控制要求的信息，请参阅其他帮助页面 运动控制 . 缓冲和混合动作轴组的点动运动的中断和继续与移动坐标系同步配置工具偏移可在此处找到了解特定运动如何执行的背景信息： CP 运动的方向插值对于高级用户： 扭矩限制和扭矩前馈控制创建自定义运动学" }, 
{ "title" : "轴组 ", 
"url" : "_sm_robotics_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 轴组 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "如何创建轴组 ", 
"url" : "_sm_creating_an_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 轴组 \/ 如何创建轴组 ", 
"snippet" : "将对象添加到设备树 以下步骤描述了如何创建和配置轴组。 创建一个新的标准项目 CODESYS Control 。对于 POU PLC_PRG ，选择CFC实现语言。 在设备树中，打开设备的上下文菜单 设备 对象并选择 启用软动作 命令。 A SoftMotion 通用轴池 对象被插入到下面 设备 。 在设备树中，选择 SoftMotion 通用轴池 .在上下文菜单中，单击 添加设备 . 这 添加设备 对话框打开。 选择 SM_驱动器_虚拟 设备。将设备名称指定为“DriveX”。 以同样的方式，再插入两个名为“DriveY”和“DriveZ”的驱动器。 在设备树中，打开 应用 对象并单击 项目...", 
"body" : "将对象添加到设备树 以下步骤描述了如何创建和配置轴组。 创建一个新的标准项目 CODESYS Control 。对于 POU PLC_PRG ，选择CFC实现语言。 在设备树中，打开设备的上下文菜单 设备 对象并选择 启用软动作 命令。 A SoftMotion 通用轴池 对象被插入到下面 设备 。 在设备树中，选择 SoftMotion 通用轴池 .在上下文菜单中，单击 添加设备 . 这 添加设备 对话框打开。 选择 SM_驱动器_虚拟 设备。将设备名称指定为“DriveX”。 以同样的方式，再插入两个名为“DriveY”和“DriveZ”的驱动器。 在设备树中，打开 应用 对象并单击 项目 → 添加对象 → 轴组 . 插入指定名称的对象 轴集团 。 这 轴组 对象插入到应用程序下方。轴组配置器打开。 在配置编辑器中，单击 选择运动学 按钮。 这 选择运动学 对话框打开，其中包含所有可用运动学配置及其描述的列表。 选择 TRAFO.Kin_Gantry3 运动学配置。 所选运动配置的配置编辑器打开。 在里面 映射到轴 参数组，将轴映射到项目中使用的驱动器。为此，请指定值 DriveX 在里面 X 输入字段，值 DriveY 在里面 是 输入字段和值 DriveZ 在里面 是 输入字段。您还可以使用输入助手 选择驱动器或将其从设备树拖到输入字段中。 有关更多信息，请参阅： 轴组编辑器" }, 
{ "title" : "轴组编辑器 ", 
"url" : "_sm_obj_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 轴组 \/ 轴组编辑器 ", 
"snippet" : "象征： 在编辑部 轴组 对象，选择基本运动学类型和方向运动学。只有在基本运动学支持的情况下，才能选择定向运动学。此外，您将运动系统的轴映射到项目中的驱动器。 运动学 选择运动学 改变运动学 打开支持的所有运动学的列表 CODESYS 当您选择一种运动学类型时，列表右侧的框中会显示一个简短的描述。 选择一种运动学类型后，您可以在编辑器中修改相应的参数。 定向运动学 选择运动学 改变运动学 打开支持的所有方向运动的列表 CODESYS 当您选择一种运动学类型时，列表右侧的框中会显示一个简短的描述。 选择一种运动学类型后，您可以在编辑器中修改相应的参数。 轴映射 根据所选的运动系统，您可以将运动系统...", 
"body" : "象征： 在编辑部 轴组 对象，选择基本运动学类型和方向运动学。只有在基本运动学支持的情况下，才能选择定向运动学。此外，您将运动系统的轴映射到项目中的驱动器。 运动学 选择运动学 改变运动学 打开支持的所有运动学的列表 CODESYS 当您选择一种运动学类型时，列表右侧的框中会显示一个简短的描述。 选择一种运动学类型后，您可以在编辑器中修改相应的参数。 定向运动学 选择运动学 改变运动学 打开支持的所有方向运动的列表 CODESYS 当您选择一种运动学类型时，列表右侧的框中会显示一个简短的描述。 选择一种运动学类型后，您可以在编辑器中修改相应的参数。 轴映射 根据所选的运动系统，您可以将运动系统的轴映射到项目中的驱动器。 其他轴 添加轴 为附加轴添加配置字段。该项目的驱动器在此配置字段中输入。 任务 总线循环任务 轴的总线循环任务，如果轴已经被映射 此处无法更改设置。 规划任务 用于规划 CP 任务的任务 插入第一个轴组时会自动创建规划任务。不应配置看门狗，因为执行时间可能会有很大波动。 有关详细信息，请参阅：For more information, see: 规划任务的配置如果删除此任务，则会向消息视图发出错误。要创建新任务，请单击 项目 → 创建计划任务 。 有关更多信息，请参阅： 如何创建轴组" }, 
{ "title" : "轴心国 ", 
"url" : "_sm_robotics_state_machine.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 轴组 \/ 轴心国 ", 
"snippet" : "下图显示了轴组的可能状态以及状态之间的转换。 单个轴的错误总是指向轴组 GroupErrorStop 状态。 如果轴组切换至 GroupMoving ，则所有轴都切换为 SynchronizedMotion 。 如果轴组从 GroupMoving 到 GroupStandby ，则所有轴都切换为 standstill 。 如果轴组从 GroupMoving 到 GroupErrorStop ，则所有轴都切换为 GroupErrorStop 。 如果轴组在 GroupStandby ，那么各个轴不一定都在 standstill 因为它们可以通过单轴运动功能块来控制，例如 MC_Jog . 如果运...", 
"body" : "下图显示了轴组的可能状态以及状态之间的转换。 单个轴的错误总是指向轴组 GroupErrorStop 状态。 如果轴组切换至 GroupMoving ，则所有轴都切换为 SynchronizedMotion 。 如果轴组从 GroupMoving 到 GroupStandby ，则所有轴都切换为 standstill 。 如果轴组从 GroupMoving 到 GroupErrorStop ，则所有轴都切换为 GroupErrorStop 。 如果轴组在 GroupStandby ，那么各个轴不一定都在 standstill 因为它们可以通过单轴运动功能块来控制，例如 MC_Jog . 如果运动因错误而终止，则所有缓冲的后续运动都将中止， CommandAborted 。 只要轴组遵循动态坐标系，它就会停留在 GroupMoving 。 轴组在 GroupMoving 当且仅当该组以协调的方式移动（通过第 4 部分中的一个运动块）。切换自 GroupMoving 到 GroupStandby 在最后一次位置更改后一个周期完成。 " }, 
{ "title" : "规划任务的配置 ", 
"url" : "_sm_configuration_planning_task.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 轴组 \/ 规划任务的配置 ", 
"snippet" : "轴组的运动规划在单独的任务中完成，该任务在插入轴组时自动创建，名称为“SoftMotion_PlanningTask”。默认情况下，此规划任务与总线任务在同一个处理器核心上运行。在多核系统上，建议将它们定位在单独的核心上。根据规划任务是否在其自己的核心上运行，需要对其进行不同的配置。 单核 如果规划任务与总线任务在同一个核上运行，则应将其配置为具有低实时优先级的自由运行任务。默认情况下是这种情况。规划任务会自动创建为优先级为 15 的自由运行任务。 多核 在多核系统上，规划任务应在具有最高优先级（0）的单独核心上运行。任务类型应设置为循环，任务间隔应设置为较低值（例如 2 毫秒）。 使用这些设...", 
"body" : "轴组的运动规划在单独的任务中完成，该任务在插入轴组时自动创建，名称为“SoftMotion_PlanningTask”。默认情况下，此规划任务与总线任务在同一个处理器核心上运行。在多核系统上，建议将它们定位在单独的核心上。根据规划任务是否在其自己的核心上运行，需要对其进行不同的配置。 单核 如果规划任务与总线任务在同一个核上运行，则应将其配置为具有低实时优先级的自由运行任务。默认情况下是这种情况。规划任务会自动创建为优先级为 15 的自由运行任务。 多核 在多核系统上，规划任务应在具有最高优先级（0）的单独核心上运行。任务类型应设置为循环，任务间隔应设置为较低值（例如 2 毫秒）。 使用这些设置，规划任务将经常超出其任务间隔。这是可以预料的，不是问题。选择任务设置是为了确保在运行后立即再次调用规划任务。这样，专用核心就可以尽可能多地用于运动规划。 有关任务配置的详细信息，请参阅： 任务配置 对象：任务配置 对象：任务 " }, 
{ "title" : "运动学 ", 
"url" : "_sm_robotics_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_sm_overview_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 概述 ", 
"snippet" : "机器人技术中最重要的任务之一是沿着预定义的路径移动工具（例如工具板或焊枪）。要做到这一点， CODESYS SoftMotion Robotics 计算机器人的各个关节需要如何移动，以使刀尖——刀具中心点 (TCP) ——沿着指令路径朝着所需的方向移动。运动学或运动学变换是这种计算的基础。它实现了从接头位置到 TCP 位置和 TCP 方向的转换，反之亦然。 计算规则因所使用的机器人类型而异。 CODESYS SoftMotion Robotics 包括适用于众多标准机器人的可配置运动学。 有关更多信息，请参阅： 运动学包括 运动学分为定位和定向运动学，可以将其组合在一起。 有关更多信息，请参阅...", 
"body" : "机器人技术中最重要的任务之一是沿着预定义的路径移动工具（例如工具板或焊枪）。要做到这一点， CODESYS SoftMotion Robotics 计算机器人的各个关节需要如何移动，以使刀尖——刀具中心点 (TCP) ——沿着指令路径朝着所需的方向移动。运动学或运动学变换是这种计算的基础。它实现了从接头位置到 TCP 位置和 TCP 方向的转换，反之亦然。 计算规则因所使用的机器人类型而异。 CODESYS SoftMotion Robotics 包括适用于众多标准机器人的可配置运动学。 有关更多信息，请参阅： 运动学包括 运动学分为定位和定向运动学，可以将其组合在一起。 有关更多信息，请参阅： 位置和方向运动学的结合可以配置刀具偏移量，该偏移量可以在运行时更改。 有关更多信息，请参阅： 配置工具偏移旋转接头支持无休止旋转的模数轴。 有关更多信息，请参阅： 旋转接头和模数轴对于无法通过提供的运动学之一映射计算规则的特殊机器人类型，您可以以功能块的形式实现自己的运动学。 有关更多信息，请参阅： 创建自定义运动学" }, 
{ "title" : "运动学包括 CODESYS SoftMotion ", 
"url" : "_sm_robotics_cds_sm_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 运动学包括 CODESYS SoftMotion ", 
"snippet" : "龙门系统 姓名 表示 可与定向运动学相联系 附加信息 Gantry2 ✓ Kin_Gantry2 (FB) Gantry3 ✓ Kin_Gantry3 (FB) HGantry2 ✓ Kin_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ Kin_TGantry2 (脸书) 5轴龙门 -- Kin_5Axes（FB） SCARA 系统 姓名 表示 可与定向运动学相联系 附加信息 极性 ✓ Kin_Polar (脸书) 带 Z 轴的极坐标 ✓ Kin_Polar_Z（FB） 带 Z 轴的 Scara2 ✓ Kin_Scara2_Z (脸...", 
"body" : "龙门系统 姓名 表示 可与定向运动学相联系 附加信息 Gantry2 ✓ Kin_Gantry2 (FB) Gantry3 ✓ Kin_Gantry3 (FB) HGantry2 ✓ Kin_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ Kin_TGantry2 (脸书) 5轴龙门 -- Kin_5Axes（FB） SCARA 系统 姓名 表示 可与定向运动学相联系 附加信息 极性 ✓ Kin_Polar (脸书) 带 Z 轴的极坐标 ✓ Kin_Polar_Z（FB） 带 Z 轴的 Scara2 ✓ Kin_Scara2_Z (脸书) 带 Z 轴的 Scara3 -- Kin_Scara3_Z (脸书) 关节型机器人 姓名 表示 可与定向运动学相联系 附加信息 带 3 个旋转轴的关节机器人 ✓ Kin_Pos_RRR（FB） 4轴码垛机 -- Kin_4AxesPalletizer (FB) 6轴关节机器人 -- Kin_ArticulatedRobot_6DOF（FB） 并行系统 姓名 表示 可与定向运动学相联系 附加信息 带旋转轴的两脚架 ✓ Kin_Bipod_Rotary（FB） 带旋转轴的三脚架 ✓ Kin_Tripod_Rotary（FB） 带线性轴的三脚架 ✓ Kin_Tripod_Linear（FB） 方向运动学 姓名 表示 附加信息 C 轴 Kin_CAxis（FB） 带刀具的 C 轴 Kin_CAxis_Tool（FB） 工具 Kin_Tool（FB） Wrist2 Kin_Wrist2（FB） Wrist3 Kin_Wrist3 (FB) " }, 
{ "title" : "位置和方向运动学的结合 ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 位置和方向运动学的结合 ", 
"snippet" : "使用轴组配置器，您可以将位置运动学和方向运动学结合起来。这样，就可以用少量的运动学来配置大量的机器人。 位置运动学的示例包括龙门 ( Kin_Gantry3 ) 和三脚架 ( Kin_Tripod_Lin , Kin_Tripod_Rotary ）。这些运动学可以移动到任何点或位置，但不能执行任意数量的方向。位置运动系统的前坐标系称为法兰坐标系。它定义了定向运动学固定的位置（左图）。 定向运动学的例子是 Kin_CAxis , Kin_Wrist2 ， 和 Kin_Wrist3 .这些运动学可以导致 TCP 的所需方向，但无法到达任何位置（见右图）。 通过结合位置运动学和方向运动学，可以在所需...", 
"body" : "使用轴组配置器，您可以将位置运动学和方向运动学结合起来。这样，就可以用少量的运动学来配置大量的机器人。 位置运动学的示例包括龙门 ( Kin_Gantry3 ) 和三脚架 ( Kin_Tripod_Lin , Kin_Tripod_Rotary ）。这些运动学可以移动到任何点或位置，但不能执行任意数量的方向。位置运动系统的前坐标系称为法兰坐标系。它定义了定向运动学固定的位置（左图）。 定向运动学的例子是 Kin_CAxis , Kin_Wrist2 ， 和 Kin_Wrist3 .这些运动学可以导致 TCP 的所需方向，但无法到达任何位置（见右图）。 通过结合位置运动学和方向运动学，可以在所需方向或相反方向移动任意数量的位置。 关于定制运动学的备注 想要创建自己的位置或方向运动学的用户必须在其运动学功能块中实现以下附加接口： 对于位置运动学：接口 ISMPosition运动学2 用方法 AxesToOrientation 和 GetOrientationImage . AxesToOrientation 是一种“缩写”正向变换，它根据轴值计算法兰坐标系的方向。仅出于效率的原因才需要。例如，无需使用龙门计算任何内容，而是可以返回恒定的方向。 GetOrientationImage 返回法兰坐标系的方向如何改变。该方法仅用于检查定向运动学是否与位置运动学兼容。 对于定向运动学：接口 ISMTool运动学2 用方法 GetPositionFromOrientation2 和 IsCompatibleWithPosKin . GetPositionFromOrientation2 根据所需方向（在 MCS 中）计算法兰坐标系和 TCP 之间的矢量。该计算对于组合运动学的逆变换是必要的。方法 IsCompatibleWithPosKin 检查定向运动学是否与位置运动学兼容。 " }, 
{ "title" : "无效组合 ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_718d71abf014b14bc0a864635271f262", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 位置和方向运动学的结合 \/ 无效组合 ", 
"snippet" : "并非位置运动学和定向运动学的每种组合都是可能的，因为有时无法确定唯一的逆变换。一个例子是具有两个关节的 SCARA 作为位置运动学和 Kin_CAxis_Tool 作为在 X 或 Y 坐标中刀具偏移不为 0 的定向运动学。 SCARA 的法兰坐标系的方向不是恒定的。它相对于 0 位置绕 Z 轴旋转。对于逆变换的计算，这个旋转是未知的，这使得在这种情况下无法清楚地确定轴角度。 可以在运行时检查组合是否可行，因为它取决于运动学的参数化。在这种情况下，错误 SMC_TRAFO_INVALID_COUPLING 发出。...", 
"body" : "并非位置运动学和定向运动学的每种组合都是可能的，因为有时无法确定唯一的逆变换。一个例子是具有两个关节的 SCARA 作为位置运动学和 Kin_CAxis_Tool 作为在 X 或 Y 坐标中刀具偏移不为 0 的定向运动学。 SCARA 的法兰坐标系的方向不是恒定的。它相对于 0 位置绕 Z 轴旋转。对于逆变换的计算，这个旋转是未知的，这使得在这种情况下无法清楚地确定轴角度。 可以在运行时检查组合是否可行，因为它取决于运动学的参数化。在这种情况下，错误 SMC_TRAFO_INVALID_COUPLING 发出。 " }, 
{ "title" : "编程“不可能”方向时的行为 ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_5ba01e61f014b14bc0a86463044fcdf7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 位置和方向运动学的结合 \/ 编程“不可能”方向时的行为 ", 
"snippet" : "在实践中，能够对运动学不可用的方向进行编程通常很有用。作为一个简单的例子，考虑一个 SCARA 机器人，其工具具有一个自由度（绕 Z 轴旋转）。原则上，该机器人只能接受工具垂直向下的方向。 当需要在工件上移动位置时，它很容易从 X\/Y 平面倾斜。用户教导工件，然后编程相对于工件的位置和方向。工件的倾斜导致刀具方向与垂直方向略微倾斜的方向。 我们如何处理这种不可能和无法到达的方向？一种严厉的措施是报告工作空间违规。然而，正如示例所示，这会使编程变得乏味。因此，方向运动学（ Kin_CAxis_Tool 在这个例子中）以这样一种方式实现，即它们假设最接近可实现的方向。在这个例子中，这意味着命令的方...", 
"body" : "在实践中，能够对运动学不可用的方向进行编程通常很有用。作为一个简单的例子，考虑一个 SCARA 机器人，其工具具有一个自由度（绕 Z 轴旋转）。原则上，该机器人只能接受工具垂直向下的方向。 当需要在工件上移动位置时，它很容易从 X\/Y 平面倾斜。用户教导工件，然后编程相对于工件的位置和方向。工件的倾斜导致刀具方向与垂直方向略微倾斜的方向。 我们如何处理这种不可能和无法到达的方向？一种严厉的措施是报告工作空间违规。然而，正如示例所示，这会使编程变得乏味。因此，方向运动学（ Kin_CAxis_Tool 在这个例子中）以这样一种方式实现，即它们假设最接近可实现的方向。在这个例子中，这意味着命令的方向以这样一种方式倾斜，即工具直立，并且这个方向被接受。 行为可以简化为以下规则（前提是位置运动学可以在所有三个空间方向上进行定位）： 始终准确地逼近该位置（否则会报告错误）。 如果无法到达，则该方向将“投影”到最近的可访问方向。 投影方向时，刀具方向优先。 之所以出现这里描述的困难，是因为定向运动学没有三个自由度来实现所有所需的定向。情况就是这样 Kin_Wrist2 和 Kin_CAxis ，但不与 Kin_Wrist3 . 当位置运动学也不具有所有空间自由度时，会出现其他困难。 （这在实践中并不经常发生。）一个例子是结合 Kin_Gantry2 , 一个只能定位在 X\/Y 方向的龙门架，并且带有 Kin_Wrist2 ，只有两个自由度的工具。在这种情况下，存在不可能的定向和不可能的位置，因为 Z 坐标已经由刀具长度和定向轴的位置定义。因此，我们建议您不要使用这些类型的组合，而只对可达到的位置进行编程。 " }, 
{ "title" : "运动学配置 ", 
"url" : "_sm_configure_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 运动学配置 ", 
"snippet" : "运动学配置描述了轴组中轴的相互布局。根据运动学的不同，同一个 TCP 位置可以有多种配置。 例如，SCARA 2 显示了两种可能的配置。 轴组有一个活动配置，不一定必须与当前轴位置相对应。如果命令移动，则可以将目标位置转换为轴坐标。使用在命令时有效的配置。 可以使用功能块设置此活动配置 SMC_SetKinConfiguration .在初始化期间以及每次更改运动系统时，轴组都会应用标准配置。所有具有配置的运动学都具有标准配置。 两种配置之间的 CP 移动是不可能的。在这种情况下，定位必须通过 PTP 运动来完成。 当前配置可通过功能块确定 MC_GroupReadActualPosition...", 
"body" : "运动学配置描述了轴组中轴的相互布局。根据运动学的不同，同一个 TCP 位置可以有多种配置。 例如，SCARA 2 显示了两种可能的配置。 轴组有一个活动配置，不一定必须与当前轴位置相对应。如果命令移动，则可以将目标位置转换为轴坐标。使用在命令时有效的配置。 可以使用功能块设置此活动配置 SMC_SetKinConfiguration .在初始化期间以及每次更改运动系统时，轴组都会应用标准配置。所有具有配置的运动学都具有标准配置。 两种配置之间的 CP 移动是不可能的。在这种情况下，定位必须通过 PTP 运动来完成。 当前配置可通过功能块确定 MC_GroupReadActualPosition . " }, 
{ "title" : "为一种运动学设计设置配置 ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b2318eb4acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 运动学配置 \/ 为一种运动学设计设置配置 ", 
"snippet" : "每个具有配置的运动学设计都有自己的用于计算配置数据的 POU。此功能块的名称对应于运动学名称加上后缀 _config . POU 将不同的配置转换为数据类型 ConfigData .此数据类型被传递给功能块 SMC_SetKinConfiguration . 示例：为 SCARA 2 运动学设计设置配置 调用功能块 Kin_Scara2_Z_Config 从图书馆 SM3_Transformation .输入 xElbowRight = 真 功能块产生类型的配置数据 ConfigData . 调用功能块 SMC_SetKinConfiguration 从图书馆 SM3_Robotics .写输...", 
"body" : "每个具有配置的运动学设计都有自己的用于计算配置数据的 POU。此功能块的名称对应于运动学名称加上后缀 _config . POU 将不同的配置转换为数据类型 ConfigData .此数据类型被传递给功能块 SMC_SetKinConfiguration . 示例：为 SCARA 2 运动学设计设置配置 调用功能块 Kin_Scara2_Z_Config 从图书馆 SM3_Transformation .输入 xElbowRight = 真 功能块产生类型的配置数据 ConfigData . 调用功能块 SMC_SetKinConfiguration 从图书馆 SM3_Robotics .写输入 ConfigData 与先前确定的配置数据。 设置 SCARA 2 的活动配置。 VAR\n config: TRAFO.Kin_Scara2_Z_Config;\n skc: SMC_SetKinConfiguration;\nEND_VAR\n\nconfig(xElbowRight := TRUE);\nskc(AxisGroup := Scara2, Execute := TRUE, ConfigData := config.Config); " }, 
{ "title" : "耦合运动学的处理 ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b22c1067acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 运动学配置 \/ 耦合运动学的处理 ", 
"snippet" : "当同时使用位置运动学和定向运动学时，存在耦合运动学。这会通过调用从两种配置中产生“耦合”配置 Kin_Coupled_Config 从图书馆 SM3_Transformation .位置运动学和定向运动学的配置在输入端提供给功能块。 有关更多信息，请参阅： 值范围超过 360° 的旋转轴...", 
"body" : "当同时使用位置运动学和定向运动学时，存在耦合运动学。这会通过调用从两种配置中产生“耦合”配置 Kin_Coupled_Config 从图书馆 SM3_Transformation .位置运动学和定向运动学的配置在输入端提供给功能块。 有关更多信息，请参阅： 值范围超过 360° 的旋转轴" }, 
{ "title" : "配置工具偏移 ", 
"url" : "_sm_configure_tool_offset.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 配置工具偏移 ", 
"snippet" : "您可以通过配置刀具偏置来设置运动的法兰坐标系（XYZ）和运动的 TCP 坐标系（X'Y'Z'）之间的偏移。该刀具偏置作用于所有后续运动。 TCP：工具中心点 刀具偏置由移位指定 v=(x,y,z) 和一个旋转 r=(A,B,C) ZYZ 欧拉角。位移和旋转相对于运动学的法兰坐标系表示。 配置刀具偏移时，它可能与当前运动系统不兼容。因此，刀具偏移可能导致运动系统无法实现方向。在这种情况下，会发出错误并忽略刀具偏移。例如，您可以为运动系统配置 Z 方向的刀具偏移 Kin_Scara2_Z 。另一方面，X 方向或 Y 方向的部件偏移会导致错误。当运动学有这些限制时，它们用 运动学 。...", 
"body" : "您可以通过配置刀具偏置来设置运动的法兰坐标系（XYZ）和运动的 TCP 坐标系（X'Y'Z'）之间的偏移。该刀具偏置作用于所有后续运动。 TCP：工具中心点 刀具偏置由移位指定 v=(x,y,z) 和一个旋转 r=(A,B,C) ZYZ 欧拉角。位移和旋转相对于运动学的法兰坐标系表示。 配置刀具偏移时，它可能与当前运动系统不兼容。因此，刀具偏移可能导致运动系统无法实现方向。在这种情况下，会发出错误并忽略刀具偏移。例如，您可以为运动系统配置 Z 方向的刀具偏移 Kin_Scara2_Z 。另一方面，X 方向或 Y 方向的部件偏移会导致错误。当运动学有这些限制时，它们用 运动学 。 " }, 
{ "title" : "功能块：SMC_GroupSetTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_348cb75b4119d4bfc0a864631ca28fed", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 配置工具偏移 \/ 功能块：SMC_GroupSetTool ", 
"snippet" : "功能块配置输入指定的刀具偏置 ToolOffset （类型 MC_COORD_REF ) 用于轴组。但是，只要轴组处于状态 GroupDisabled 或者 GroupErrorStop , 不 可以配置刀具偏置。 如果工具与当前运动学不兼容，则 POU 发出错误 SMC_AXIS_GROUP_TOOL_OFFSET_INCOMPATIBLE_WITH_KINEMATICS .如果接口也出现此错误 ISMKinematicsWithOrientationImage 尚未针对运动学描述实施。...", 
"body" : "功能块配置输入指定的刀具偏置 ToolOffset （类型 MC_COORD_REF ) 用于轴组。但是，只要轴组处于状态 GroupDisabled 或者 GroupErrorStop , 不 可以配置刀具偏置。 如果工具与当前运动学不兼容，则 POU 发出错误 SMC_AXIS_GROUP_TOOL_OFFSET_INCOMPATIBLE_WITH_KINEMATICS .如果接口也出现此错误 ISMKinematicsWithOrientationImage 尚未针对运动学描述实施。 " }, 
{ "title" : "功能块：SMC_GroupReadTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_c1689be51d4132b4c0a864637c06bdff", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 配置工具偏移 \/ 功能块：SMC_GroupReadTool ", 
"snippet" : "该功能块读取刀具偏置：输出 ToolOffset （类型 MC_COORD_REF ）。在这个过程中，输入 ReadMode 确定是否要读取当前运动的刀具、最后指令的运动或轴组中当前设置的刀具。...", 
"body" : "该功能块读取刀具偏置：输出 ToolOffset （类型 MC_COORD_REF ）。在这个过程中，输入 ReadMode 确定是否要读取当前运动的刀具、最后指令的运动或轴组中当前设置的刀具。 " }, 
{ "title" : "兼容运动学 ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_ff04bb6d41a8190bc0a864635e26fe13", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 配置工具偏移 \/ 兼容运动学 ", 
"snippet" : "并非所有运动学都支持每个刀具偏移。以下列表显示了哪些工具适用于哪些运动学。 运动学 兼容工具 SCARA 2 运动学 Kin_Scara2_Z Z 方向位置偏移和方向偏移的刀具 SCARA 3 运动学 Kin_Scara3_Z 所有工具 极地运动学 Kin_Polar , Kin_Polar_Z Z 方向位置偏移和方向偏移的刀具 三轴关节机器人 Kin_Pos_RRR 方向有偏移的刀具 6轴关节机器人 Kin_ArticulatedRobot_6DOF 所有工具 4轴码垛机 Kin_4AxisPalletizer 所有工具 双脚架 Kin_Bipod_Rotary 所有工具 5轴龙门 Kin_...", 
"body" : "并非所有运动学都支持每个刀具偏移。以下列表显示了哪些工具适用于哪些运动学。 运动学 兼容工具 SCARA 2 运动学 Kin_Scara2_Z Z 方向位置偏移和方向偏移的刀具 SCARA 3 运动学 Kin_Scara3_Z 所有工具 极地运动学 Kin_Polar , Kin_Polar_Z Z 方向位置偏移和方向偏移的刀具 三轴关节机器人 Kin_Pos_RRR 方向有偏移的刀具 6轴关节机器人 Kin_ArticulatedRobot_6DOF 所有工具 4轴码垛机 Kin_4AxisPalletizer 所有工具 双脚架 Kin_Bipod_Rotary 所有工具 5轴龙门 Kin_5Axes 所有工具 龙门系统 所有工具 H型龙门系统 所有工具 T型龙门系统 所有工具 旋转或线性三脚架 所有工具 如果运动系统没有 3 个方向自由度，则可能不是每个刀具偏置都兼容。 " }, 
{ "title" : "对于自定义运动学 ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_6c7b39581d4132b4c0a8646366a3228c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 配置工具偏移 \/ 对于自定义运动学 ", 
"snippet" : "为了将自定义运动与刀具偏移一起使用，您需要实现 ISMKinematicsWithOrientationImage 接口。要为自定义位置运动添加工具偏移，首先必须实现接口 ISMPositionKinematics2 。...", 
"body" : "为了将自定义运动与刀具偏移一起使用，您需要实现 ISMKinematicsWithOrientationImage 接口。要为自定义位置运动添加工具偏移，首先必须实现接口 ISMPositionKinematics2 。 " }, 
{ "title" : "接口：ISMKinematicsWithOrientationImage ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_592ee99f1d4132b4c0a864637bd8a061", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 配置工具偏移 \/ 接口：ISMKinematicsWithOrientationImage ", 
"snippet" : "运动学接口提供方法 GetFlangeOrientationImage 与变量 mR_Flange 数据类型 SMC_Matrix3 ，其中包含法兰的指定方向。因此，该方法返回可能的结果方向 oriInfo 作为数据类型 OrientationSpace . 界面行为 特别是，当法兰在指令方向上的方向已知时， dof = zero 被退回并且 mOriZero 设置为已知方向。 如果方向 R 法兰的形式仅部分已知 R*vU = vRot （在哪里 vU 和 vRot 是已知的单位向量），那么 dof = one 被退回。 mOriZero 设置为可达空间中的方向。 否则， dof = thre...", 
"body" : "运动学接口提供方法 GetFlangeOrientationImage 与变量 mR_Flange 数据类型 SMC_Matrix3 ，其中包含法兰的指定方向。因此，该方法返回可能的结果方向 oriInfo 作为数据类型 OrientationSpace . 界面行为 特别是，当法兰在指令方向上的方向已知时， dof = zero 被退回并且 mOriZero 设置为已知方向。 如果方向 R 法兰的形式仅部分已知 R*vU = vRot （在哪里 vU 和 vRot 是已知的单位向量），那么 dof = one 被退回。 mOriZero 设置为可达空间中的方向。 否则， dof = three 被退回。 如果可以在考虑计算的方向的同时唯一地计算法兰位置，则指定的刀具偏移与运动学兼容。当计算出的方向可以通过运动学实现时，总是会出现这种情况。仅当无法到达所有方向时，刀具偏移才可能不兼容。此外，如果方法 GetFlangeOrientationImage 返回 dof = zero , 那么每个刀具偏置都是兼容的。如果方法返回 dof = one ，则只有刀具位置偏移 v_off 平行于单位向量 vU 是兼容的。在这种情况下， R*v_off = R*vU*x = vRot*x 不依赖于方向矩阵的未知部分 R .这还包括刀具偏移 v_off = 0 （其中 x = 0）。如果 dof = three 返回，则只有在 x\/y\/z 中没有偏移的位置偏移是兼容的。 实施说明 实现接口 ISMOrientationKinematicsWithOriImage2 用于定向运动学。然后可以使用刀具补偿将定向运动学与位置运动学耦合。接口有方法 GetOrientationImage2 与变量 VAR_IN_OUT CONSTANT mR_Flange 数据类型 SMC_Matrix3 ，其中包含法兰的指定方向。 方法返回 csTool 和 oriinfo 与数据类型 OrientationSpace 在定向运动学的基础坐标系中。 此外，该方法返回 bActive 自由度是否 orinfo 活跃（ TRUE ) 或被动 ( FALSE ）。 活动自由度示例： Kin_CAxis .围绕 z 轴的旋转由定向运动学轴控制。 被动自由度示例： Kin_Wrist2 .剩下的自由度是 X\/Y 绕 Z 轴的旋转，Z 轴指向用户编程的方向。 如果在换刀过程中最后指令的运动和新的运动都是 CP 运动（直线运动或旋转运动），则后续运动的缓冲模式从 Blending 或者 Aborting 到 Buffered . 如果在之后配置新的刀具偏置 MC_GroupInterrupt 和之前 MC_GroupContinue ，则旧的刀具偏置用于中断的运动。新的刀具偏置仅用于之后命令的运动。 当运动学改变时（ MC_SetKinTransform )，刀具偏置被复位（不移位，不旋转）。 " }, 
{ "title" : "旋转接头和模数轴 ", 
"url" : "_sm_robotics_rotary_joints_modulo_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 旋转接头和模数轴 ", 
"snippet" : "自 SoftMotion 4.12.0.0 起支持轴组内的模轴。 模数轴仅允许用于运动学的旋转接头。这些是旋转接头 SMKinematicWithInfo.GetAxisProperties 返回值 props.eType = Axis_Type.Rotary .如果模数轴用于线性关节或未实现的运动学 ISMKinematicWithInfo ， 然后 MC_GroupEnable 返回 SMC_MODULO_AXIS_FOR_NON_ROTARY_JOINT 错误。如果使用模数轴并且运动学限制了旋转接头的范围，则 MC_GroupEnable 返回 SMC_MODULO_AXIS_FOR_L...", 
"body" : "自 SoftMotion 4.12.0.0 起支持轴组内的模轴。 模数轴仅允许用于运动学的旋转接头。这些是旋转接头 SMKinematicWithInfo.GetAxisProperties 返回值 props.eType = Axis_Type.Rotary .如果模数轴用于线性关节或未实现的运动学 ISMKinematicWithInfo ， 然后 MC_GroupEnable 返回 SMC_MODULO_AXIS_FOR_NON_ROTARY_JOINT 错误。如果使用模数轴并且运动学限制了旋转接头的范围，则 MC_GroupEnable 返回 SMC_MODULO_AXIS_FOR_LIMITED_ROTARY_JOINT 错误。 仅当模周期为 360° 时才支持模轴。原因是连接到旋转接头的轴必须这样配置，即一个技术单位 [u] 对应一个角度 [°]。一个周期必须对应一个完整的旋转。如果使用周期不是 360° 的模轴，则 MC_GroupEnable 返回 SMC_MODULO_AXIS_PERIOD_NOT_360 错误。 从版本 4.12.0.0 开始， SoftMotion 仅支持 shortest 模式 （ MC_DIRECTION ）。这意味着选择模数轴的距离和方向使其尽可能接近轴的起始位置。例如，如果定向轴在运动开始时位于 a2 = 30°，而在目标位置位于 a2 = 290°，则选择位置 a2 = 290° – 360° = –70° 并且轴移动向负方向移动 100°，而不是向正方向移动 260°。 " }, 
{ "title" : "创建自定义运动学 ", 
"url" : "_sm_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动学 \/ 创建自定义运动学 ", 
"snippet" : "开源工具 wkhtmltopdf 需要从功能块中的注释生成运动学文档。但是，此组件不再包含在 CODESYS 版本 3.5 SP15 及更高版本。 您可以从以下位置下载 DLL https:\/\/wkhtmltopdf.org\/downloads.html .创建一个名为的目录 DocScripting\\3.5.xx.x\\bin 在安装目录下 CODESYS 并保存文件 wkhtmltox.dll 那里。 注意：由于 wkhtmltox.dll 0.12.6 及更高版本默认不再支持图像，您必须使用 0.12.5 或更低版本。 当使用轴组的运动变换实例时，不能再更改实例的输入。 要更改运动学变换的...", 
"body" : "开源工具 wkhtmltopdf 需要从功能块中的注释生成运动学文档。但是，此组件不再包含在 CODESYS 版本 3.5 SP15 及更高版本。 您可以从以下位置下载 DLL https:\/\/wkhtmltopdf.org\/downloads.html .创建一个名为的目录 DocScripting\\3.5.xx.x\\bin 在安装目录下 CODESYS 并保存文件 wkhtmltox.dll 那里。 注意：由于 wkhtmltox.dll 0.12.6 及更高版本默认不再支持图像，您必须使用 0.12.5 或更低版本。 当使用轴组的运动变换实例时，不能再更改实例的输入。 要更改运动学变换的参数化，您必须尽可能使用配置，或创建多个实例。 创建自定义运动学时，您必须遵守以下事项： 运动学由特殊功能块描述，这些功能块可以存储在库中或 POU 项目的视图。 为了 CODESYS 要在配置器中列出运动学，相关的功能块必须实现 MC_KIN_REF_SM3 接口（部分 SM3_Transformation.library ）。 您可以将运动学定义为其他两种运动学的组合。具有连接工具板或工具可能性的运动学也必须实现 ISM位置运动学2 接口。指定工具板或工具的运动学必须实现 ISMToolKinematics2 界面。 如果你只实施 ISMPositionKinematics \/ ISMToolKinematics 代替 ISMPositionKinematics2 \/ ISMToolKinematics2 ，那么“不可用”的方向可能会被错误地处理。 当您还实现接口时 ISMPositionKinematics_Offset , 可以使用定向模式 Axis . 当 POU 具有 sm_kin_libdoc 属性，功能块中指定的注释在配置器中用作运动学的描述。 “重组文本”格式用于此目的。但是请注意，不支持链接。 设计相关参数（例如臂长和角度）作为功能块的 VAR_INPUT 变量创建。您应该注释这些参数，因为注释在配置器中用作描述。如果参数是数字类型，并且其值范围受到限制，则必须提供 sm_kin_param_range 属性。 值范围的语法是 [a .. b] 对于闭区间和 ]a .. b[ 对于开放间隔。组合形式 ]a .. b] 和 [a .. b[ 也是可能的。以此目的， a 和 b 必须是参数类型的适当文字。特殊值 +inf 和 -inf 对于开区间限制是可能的。例子： [0 .. 1] , [1 .. +inf[ , ]-inf .. -5] . 参数可以是任何数字类型或 BOOL .参数应具有用作默认值的初始值。您可以使用可选属性指定参数的单位 sm_kin_param_unit （例如：“rad”、“°”、“deg”）。您应该使用单位“u”来表示长度和距离。驱动器的应用和缩放决定了这些单位是“mm”、“cm”还是“m”。 如果功能块没有可用的库文档，则 FB 元素的注释将作为后备选项显示在相应位置。 配置的语言 CODESYS 是 LibDoc 文档的显示语言。如果本地化在该语言中不可用，则使用库的默认语言。 运动学的轴名称由 FB 属性定义 sm_kin_axes .该属性的值是轴名称列表（例如：“A1、A2、A3”）。 使用 FB 属性指定可选图标 sm_kin_icon .该值在表单中指定 <image pool>.<identifier> .图像池是相对于功能块指定的。 如果您创建一个带有旋转轴的自定义运动学功能块（例如， Kin_Scara3_Z_Config )，那么您应该对这些轴使用周期概念并实现 ISMKinPeriodHandling 界面。对于旋转轴，只有反向运动变换 ( CartesianToAxes ) 负责角度的计算。然后 CODESYS SoftMotion 自动将此角度移动到正确的周期。例如，如果变换计算的角度在]-180°、180°] 范围内，则 CODESYS SoftMotion 如果驱动器的软件边界为 0° .. 360°，则将此角度移动到 [0°, 360°[ 范围内。此外，您应该实施 ISMKinematicsWithConfiguration3 界面。这是确保 CP 运动的运动学无任何问题的唯一方法。 在耦合运动学的位置和方向运动学布局不规则的情况下，您应该实施 ISMCoupledKinematics3 界面。通过这种方式，系统可以检测用于位置或方向运动学的轴是否属于相应的轴编号。 注意：您应该实施 ISMKinematicWithConfigurations2.CPConnectible 方法，在比较时忽略周期设置。然后 CPConnectible 返回值 TRUE ，即使期间设置不同。 所有逆变换都有一个类型的输入 CONFIGDATA 它包含一个字节数组，其中包含有关运动学配置的信息。前向变换具有相应的输出。具有配置的运动学必须实现 ISMKinematicWithConfigurations 界面。这些运动学中的每一个都包含一个功能块，该功能块必须实现 ISMConfigurationData 接口（用于配置数据序列化的函数）。此功能块的名称必须与运动学名称加后缀相同 _config .您可以使用此 FB 修改应用程序中的配置（通过功能块 SMC_SetKinConfiguration 堵塞）。但是，运动学不应包含相应 FB 的任何实例。 有关分步说明，请参阅 自定义运动学 章节。 " }, 
{ "title" : "坐标系 ", 
"url" : "_sm_coordinate_systems.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 坐标系 ", 
"snippet" : "CODESYS SoftMotion Robotics 提供了不同的坐标系，可以在其中控制运动。 轴坐标系 (ACS) 刀具坐标系 (TCS) 世界坐标系 (WCS) 机器坐标系 (MCS) 产品坐标系 (PCS_1、PCS_2) 坐标系 描述 轴坐标系 (ACS) 轴坐标系定义轴空间中的坐标系，其中机器人的每个轴跨越一个维度。因此，可以为机器人的每个轴指定位置。 刀具坐标系 (TCS) 刀具坐标系是笛卡尔坐标系，位于运动学的刀具中心点 (TCP) 上。它的位置和方向取决于机器人的位置。 世界坐标系 (WCS) 世界坐标系是静态笛卡尔坐标系，构成所有后续坐标系的基础。它们是相对于世界坐标系定义...", 
"body" : "CODESYS SoftMotion Robotics 提供了不同的坐标系，可以在其中控制运动。 轴坐标系 (ACS) 刀具坐标系 (TCS) 世界坐标系 (WCS) 机器坐标系 (MCS) 产品坐标系 (PCS_1、PCS_2) 坐标系 描述 轴坐标系 (ACS) 轴坐标系定义轴空间中的坐标系，其中机器人的每个轴跨越一个维度。因此，可以为机器人的每个轴指定位置。 刀具坐标系 (TCS) 刀具坐标系是笛卡尔坐标系，位于运动学的刀具中心点 (TCP) 上。它的位置和方向取决于机器人的位置。 世界坐标系 (WCS) 世界坐标系是静态笛卡尔坐标系，构成所有后续坐标系的基础。它们是相对于世界坐标系定义的。 机器坐标系 (MCS) 机器坐标系是静态笛卡尔坐标系。MCS 相对于物理机器人的位置和方向由运动学定义 这个 mc_set坐标变换 功能块可用于相对于世界坐标系 (WCS) 移动坐标系。 产品坐标系 (PCS_1、PCS_2) 产品坐标系是笛卡尔坐标系，可以由用户定义。它们相对于世界坐标系 (WCS) 表示，可以是静态的，也可以是动态 静态 这个 mc_set坐标变换 功能块可用于移动相对于世界坐标系 (WCS) 的坐标系。 动态 以下功能块可用于定义动态坐标系： mc_setdynCOORD变换 smc_setdyncoordCoordTransfor mc_Track 输送带 mc_track 旋转台 " }, 
{ "title" : "坐标系的初始位置和方向 ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056579261585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 坐标系 \/ 坐标系的初始位置和方向 ", 
"snippet" : "机器人的运动学决定坐标系的初始位置和方向。运动学文档中对此进行了描述 运动学定义了以下内容： 机器坐标系 (MCS) 相对于物理机器人的位置和方向 刀具中心点 (TCP) 相对于 MCS 的位置和方向，因此也是刀具坐标系 (TCS) 机器人的零位置以及各个轴的旋转或移动方向 世界坐标系 (WCS) 和产品坐标系（PCS_1、PCS_2）最初没有移动，并且与机床坐标系相同。...", 
"body" : "机器人的运动学决定坐标系的初始位置和方向。运动学文档中对此进行了描述 运动学定义了以下内容： 机器坐标系 (MCS) 相对于物理机器人的位置和方向 刀具中心点 (TCP) 相对于 MCS 的位置和方向，因此也是刀具坐标系 (TCS) 机器人的零位置以及各个轴的旋转或移动方向 世界坐标系 (WCS) 和产品坐标系（PCS_1、PCS_2）最初没有移动，并且与机床坐标系相同。 " }, 
{ "title" : "多个机器人和工件 ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581220108", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 坐标系 \/ 多个机器人和工件 ", 
"snippet" : "为每个机器人定义坐标系的位置和方向。当多个机器人协同工作时，将世界坐标系 (WCS) 定义为公共基础坐标系可能很有用。基于该坐标系，可以移动单个机器人的机器坐标系（MCS）和产品坐标系（PCS_1、PCS_2）...", 
"body" : "为每个机器人定义坐标系的位置和方向。当多个机器人协同工作时，将世界坐标系 (WCS) 定义为公共基础坐标系可能很有用。基于该坐标系，可以移动单个机器人的机器坐标系（MCS）和产品坐标系（PCS_1、PCS_2） " }, 
{ "title" : "示例 ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581719182", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 坐标系 \/ 示例 ", 
"snippet" : "使用带有两个旋转关节的机器人的示例 ( a0 和 a1 )...", 
"body" : "使用带有两个旋转关节的机器人的示例 ( a0 和 a1 ) " }, 
{ "title" : "运动学 ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582142746", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 坐标系 \/ 示例 \/ 运动学 ", 
"snippet" : "运动学定义机器人的零位置（如下所示）。机床坐标系的原点位于轴的旋转轴上 a0 。当第一个轴的位置时，X 轴指向第一个连接的方向 a0 是 0 。当第一个轴的位置时 Y 轴指向第一个连接的方向 a0 是 +90° 。逆时针旋转对应于旋转的正方向。刀具中心点 (TCP) 位于机器人第二环节的末端（如下所示），构成 TCS 的原点。TCS 的对齐方式是 X 轴沿第二条链路运行...", 
"body" : "运动学定义机器人的零位置（如下所示）。机床坐标系的原点位于轴的旋转轴上 a0 。当第一个轴的位置时，X 轴指向第一个连接的方向 a0 是 0 。当第一个轴的位置时 Y 轴指向第一个连接的方向 a0 是 +90° 。逆时针旋转对应于旋转的正方向。刀具中心点 (TCP) 位于机器人第二环节的末端（如下所示），构成 TCS 的原点。TCS 的对齐方式是 X 轴沿第二条链路运行 " }, 
{ "title" : "轴坐标系 (ACS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582875889", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 坐标系 \/ 示例 \/ 轴坐标系 (ACS) ", 
"snippet" : "运动学已经指定了机器人的零位置和各个轴的旋转方向。因为机器人由两个轴组成 a0 和 a1 ，我们可以指定轴的位置 a0 和 a1 在 ACS 中。 在第一张图片中，我们指定位置（ a0:= 0, a1:= 0 ）。这对应于机器人的零位置。 在第二张图片中，我们指定位置 ( a0:= 90, a1:= 0 ）。从零位置开始，第一轴 a0 已旋转 90° 在正向旋转的方向上。第二轴 a1 保持在零位置。 在第三张图片中，我们指定位置 ( a0:= 90, a1:= -90 ）。从零位置开始，第一轴 a0 已旋转 90° 沿正向旋转（如第二张图像所示）。此外，第二轴 a1 已旋转 90° 在反向旋转...", 
"body" : "运动学已经指定了机器人的零位置和各个轴的旋转方向。因为机器人由两个轴组成 a0 和 a1 ，我们可以指定轴的位置 a0 和 a1 在 ACS 中。 在第一张图片中，我们指定位置（ a0:= 0, a1:= 0 ）。这对应于机器人的零位置。 在第二张图片中，我们指定位置 ( a0:= 90, a1:= 0 ）。从零位置开始，第一轴 a0 已旋转 90° 在正向旋转的方向上。第二轴 a1 保持在零位置。 在第三张图片中，我们指定位置 ( a0:= 90, a1:= -90 ）。从零位置开始，第一轴 a0 已旋转 90° 沿正向旋转（如第二张图像所示）。此外，第二轴 a1 已旋转 90° 在反向旋转方向。 " }, 
{ "title" : "刀具坐标系 (TCS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056583569251", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 坐标系 \/ 示例 \/ 刀具坐标系 (TCS) ", 
"snippet" : "运动学定义了 TCP 和 TCS 的位置和方向。根据我们移动机器人的方式，TCS 的位置和方向也会发生变化...", 
"body" : "运动学定义了 TCP 和 TCS 的位置和方向。根据我们移动机器人的方式，TCS 的位置和方向也会发生变化 " }, 
{ "title" : "世界坐标系 (WCS)、机器坐标系 (MCS) 和产品坐标系 (PCS_1、PCS_2) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056584038831", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 坐标系 \/ 示例 \/ 世界坐标系 (WCS)、机器坐标系 (MCS) 和产品坐标系 (PCS_1、PCS_2) ", 
"snippet" : "在生产车间里，两台机器人站在传送带的左右两侧。机器人应该在传送带上加工产品。我们定义了一个通用的世界坐标系并将其放置在生产车间的左上角。从该坐标系开始，我们确定与机床坐标系和乘积的距离和旋转，并相应地移动坐标系。 在示例中，所有坐标系的对齐方式相同，因此我们只需要移动坐标系即可。左侧机器人的机器坐标系在 Y 方向上移动，右侧机器人的机器坐标系在 X 方向上移动，产品坐标系在 X 方向和 Y 方向上移动...", 
"body" : "在生产车间里，两台机器人站在传送带的左右两侧。机器人应该在传送带上加工产品。我们定义了一个通用的世界坐标系并将其放置在生产车间的左上角。从该坐标系开始，我们确定与机床坐标系和乘积的距离和旋转，并相应地移动坐标系。 在示例中，所有坐标系的对齐方式相同，因此我们只需要移动坐标系即可。左侧机器人的机器坐标系在 Y 方向上移动，右侧机器人的机器坐标系在 X 方向上移动，产品坐标系在 X 方向和 Y 方向上移动 " }, 
{ "title" : "运动控制 ", 
"url" : "_sm_f_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_sm_overview_robotics_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 概述 ", 
"snippet" : "本章介绍机器人的基本运动类型： 跑步 SMC_GroupJog2 PTP 移动（点对点） MC_MoveDirectAbsolute MC_MoveDirectRelative CP 运动（连续路径） MC_MoveLinearAbsolute MC_MoveLinearRelative MC_MoveCircularAbsolute MC_MoveCircularRelative 等待 组等待 停止（见 使用 MC_GroupHalt 或 MC_GroupStop 在路径上停止 和 动作的中断和继续） MC_GroupHalt MC_GroupStop MC_GroupInterrupt 此...", 
"body" : "本章介绍机器人的基本运动类型： 跑步 SMC_GroupJog2 PTP 移动（点对点） MC_MoveDirectAbsolute MC_MoveDirectRelative CP 运动（连续路径） MC_MoveLinearAbsolute MC_MoveLinearRelative MC_MoveCircularAbsolute MC_MoveCircularRelative 等待 组等待 停止（见 使用 MC_GroupHalt 或 MC_GroupStop 在路径上停止 和 动作的中断和继续） MC_GroupHalt MC_GroupStop MC_GroupInterrupt 此外，还解释了与机芯相关的所有重要主题： 缓冲和混合动作与移动坐标系同步外轴同步，转矩前馈控制额外轴动作缓慢或急促时的诊断" }, 
{ "title" : "如何创建控制轴组的程序 ", 
"url" : "_sm_creating_an_axis_group_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 如何创建控制轴组的程序 ", 
"snippet" : "以下说明描述了如何创建用于控制轴组的程序。 要求 ：一个项目已经创建了一个轴组，如 如何创建轴组 章节。 用于控制轴组的程序在 PLC_PRG 以 CFC 为实现语言的 POU。 打开 PLC_PRG 编辑器中的程序。 拖动 盒子 元素到编辑器。 映射功能块 SMC_GroupPower 到盒子里。 根据下图配置功能块。 解释： 该功能块激活轴组的驱动器。 输出 Status 表示控制器使能成功。 创建类型的功能块 MC_GroupEnable . 该功能块将链接轴的控制权转移到 安讯士集团 轴组。 连接 Status 的输出 SMC_GroupPower 功能块到 Execute 输入的 M...", 
"body" : "以下说明描述了如何创建用于控制轴组的程序。 要求 ：一个项目已经创建了一个轴组，如 如何创建轴组 章节。 用于控制轴组的程序在 PLC_PRG 以 CFC 为实现语言的 POU。 打开 PLC_PRG 编辑器中的程序。 拖动 盒子 元素到编辑器。 映射功能块 SMC_GroupPower 到盒子里。 根据下图配置功能块。 解释： 该功能块激活轴组的驱动器。 输出 Status 表示控制器使能成功。 创建类型的功能块 MC_GroupEnable . 该功能块将链接轴的控制权转移到 安讯士集团 轴组。 连接 Status 的输出 SMC_GroupPower 功能块到 Execute 输入的 MC_GroupEnable 功能块。 解释： 当所有轴控制器通电时（ Status = TRUE ），将轴的控制权转移到轴组。 这 Done 输出报告命令成功。 插入一个 MC_MoveDirectAbsolute 用于运行驱动器的功能块。 连接 Done 的输出 MC_GroupEnable 功能块到 Execute 输入的 MC_MoveDirectAbsolute 功能块。 扩展程序如下： 解释： 这 MC_MoveDirectAbsolute 功能块命令 PTP 运动 轴集团 轴组。 在示例中，运动学移动到位置 (X = 10, Y= 20, Z = 30)。该值被映射到 Position 输入通过 SMC_POS_REF 结构。 该位置在机器坐标系 (MCS) 中指定。坐标系是通过以下方式选择的 CoordSystem 输入。 启动程序 如果程序已完整创建并且可以编译且没有错误，则可以将其传输到控制器。 启动 CODESYS Control Win 运行时系统（ CODESYSControlService.exe 程序中的 \"...\\GatewayPLC\" 目录）。 放入 通讯设置 控制器的连接路径。 点击 在线的 → 登录 。 将项目下载到控制器。 点击 调试 → 启动 . 在编辑器中，打开 安讯士集团 目的。 显示轴的位置。 点击 调试 → 开始 。 轴的位置发生变化。 " }, 
{ "title" : "轴组的点动 ", 
"url" : "_sm_cartesian_jogging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 轴组的点动 ", 
"snippet" : "您可以使用 SMC_GroupJog2 在空间中移动轴组的功能块。 这 SMC_GroupJog2 功能块对每个坐标有两个布尔输入，一个输入用于沿该坐标向前移动，一个输入用于向后移动。 不同坐标的布尔输入 SMC_GroupJog2 可以以不同的方式解释。例如，在笛卡尔坐标系、机床坐标系、轴坐标系或工具坐标系中，具体取决于设置的坐标系。使用特殊输入 ABC_as_ACS: BOOL ，X\/Y\/Z 和工具运动系统的轴均可在笛卡尔坐标和轴坐标中同时进行点动。仅当运动系统耦合且位置运动系统实现接口时，才支持“混合”点动 ISMPositionKinematics_Offset . （否则功能块会产生...", 
"body" : "您可以使用 SMC_GroupJog2 在空间中移动轴组的功能块。 这 SMC_GroupJog2 功能块对每个坐标有两个布尔输入，一个输入用于沿该坐标向前移动，一个输入用于向后移动。 不同坐标的布尔输入 SMC_GroupJog2 可以以不同的方式解释。例如，在笛卡尔坐标系、机床坐标系、轴坐标系或工具坐标系中，具体取决于设置的坐标系。使用特殊输入 ABC_as_ACS: BOOL ，X\/Y\/Z 和工具运动系统的轴均可在笛卡尔坐标和轴坐标中同时进行点动。仅当运动系统耦合且位置运动系统实现接口时，才支持“混合”点动 ISMPositionKinematics_Offset . （否则功能块会产生错误。） 在点动模式下，A 围绕配置的坐标系（MCS、WCS、PCS 或 TCS）的 X 轴旋转 TCP。 B 和 C 在同一坐标系中绕 Y 轴和 Z 轴旋转 TCP。但是，这仅适用于 ABC_as_ACS = FALSE . 笛卡尔慢跑开始时 SMC_GroupJog2 功能块接收一个上升沿并设置 Busy 输出。笛卡尔点动导致主动协调运动或运动学轴运动的中断。当点动被运动（坐标轴或运动轴上的运动）中断或位置超出工作空间时，笛卡尔点动结束。点动时，轴限制始终保持在运动系统的轴上。 有关详细信息，请参阅： 慢跑机器人" }, 
{ "title" : "路径不变的 PTP 运动 ", 
"url" : "_sm_robotics_path_invariant_ptp_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 路径不变的 PTP 运动 ", 
"snippet" : "对于 PTP 运动，空间路径取决于运动学，只有起点和终点是固定的。运动是完全同步的，因此所有轴的加速、恒定运动和减速阶段同时开始和结束。 PTP 运动始终是路径不变的，因此适用以下特征： 路径与覆盖无关。 路径与轴的所有动态限制（速度、加速度、减速度和加加速度的限制）无关。唯一的例外是确定截止点 TMStartVelocity 模式。 在 TMCornerDistance 模式，路径与混合类型无关（ BlendingHigh \/ Low \/ Previous \/ Next ）。 路径不会在停止或停止时离开（ MC_GroupHalt \/ MC_GroupStop ）。 路径不会在中断或继续时离...", 
"body" : "对于 PTP 运动，空间路径取决于运动学，只有起点和终点是固定的。运动是完全同步的，因此所有轴的加速、恒定运动和减速阶段同时开始和结束。 PTP 运动始终是路径不变的，因此适用以下特征： 路径与覆盖无关。 路径与轴的所有动态限制（速度、加速度、减速度和加加速度的限制）无关。唯一的例外是确定截止点 TMStartVelocity 模式。 在 TMCornerDistance 模式，路径与混合类型无关（ BlendingHigh \/ Low \/ Previous \/ Next ）。 路径不会在停止或停止时离开（ MC_GroupHalt \/ MC_GroupStop ）。 路径不会在中断或继续时离开（ MC_GroupInterrupt \/ MC_GroupContinue ）。 " }, 
{ "title" : "CP 运动 ", 
"url" : "_sm_robotics_cp_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ CP 运动 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_sm_overview_robotics_motion_control_cp.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ CP 运动 \/ 概述 ", 
"snippet" : "CP 运动（连续路径）由其几何路径给出。在机器人技术中，这些是线性段（ MC_MoveLinearAbsolute 和 MC_MoveLinearRelative ) 和圆弧段 ( MC_MoveCircularAbsolute 和 MC_MoveCircularRelative ）。 可以为 CP 运动指定最大路径速度、最大路径加速度和最大路径加加速度。 如果在两个 CP 运动之间进行混合，并且两个运动位于同一平面，则在混合过程中不会离开该平面。例如，两个连续的直线段始终位于同一平面。 路径的几何形状尚未确定 TCP 的方向如何从起始方向转移到目标方向。这在 CP 运动的方向插值 部分。 C...", 
"body" : "CP 运动（连续路径）由其几何路径给出。在机器人技术中，这些是线性段（ MC_MoveLinearAbsolute 和 MC_MoveLinearRelative ) 和圆弧段 ( MC_MoveCircularAbsolute 和 MC_MoveCircularRelative ）。 可以为 CP 运动指定最大路径速度、最大路径加速度和最大路径加加速度。 如果在两个 CP 运动之间进行混合，并且两个运动位于同一平面，则在混合过程中不会离开该平面。例如，两个连续的直线段始终位于同一平面。 路径的几何形状尚未确定 TCP 的方向如何从起始方向转移到目标方向。这在 CP 运动的方向插值 部分。 CP 的运动总是以相同的方式开始和结束 配置 机器人的。无法通过 CP 移动来更改配置，因为机器人会移动通过一个奇异位置。通过一个奇异位置的移动可能导致轴速度不受限制。您可以使用 路径不变的 PTP 运动 在配置之间切换。 " }, 
{ "title" : "CP 运动的方向插值 ", 
"url" : "_sm_robotics_orientation_interpolation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ CP 运动 \/ CP 运动的方向插值 ", 
"snippet" : "在 CP 运动的情况下，例如 MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute ， 或者 MC_MoveCircularRelative ，可以通过运动的目标位置指定工具的任何目标方向。结果是工具的方向在路径移动期间转换为目标方向，工具的尖端在路径上移动。对于定向插补，无论是轴坐标 (ACS) 还是机器坐标 (MCS)，在哪个坐标系中给出目标定向都没有任何区别。 下图显示了带有同步定向插补的线性插补。红色箭头指示工具在起点和终点的方向。红色虚线表示工具在插补期间如何定位在某些位置。 上面提到的用于路径...", 
"body" : "在 CP 运动的情况下，例如 MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute ， 或者 MC_MoveCircularRelative ，可以通过运动的目标位置指定工具的任何目标方向。结果是工具的方向在路径移动期间转换为目标方向，工具的尖端在路径上移动。对于定向插补，无论是轴坐标 (ACS) 还是机器坐标 (MCS)，在哪个坐标系中给出目标定向都没有任何区别。 下图显示了带有同步定向插补的线性插补。红色箭头指示工具在起点和终点的方向。红色虚线表示工具在插补期间如何定位在某些位置。 上面提到的用于路径移动的功能块具有 OrientationMode 输入。此输入定义了如何将起始方向传递到目标方向。 大圆插补（ SMC_Orientation_Mode.GreatCircle ） 这是默认设置。使用此设置，起始方向也会以最短距离传递到目标方向。最短距离意味着工具在目标方向上旋转，从而使旋转的行进角最小化。 轴方向插补（ SMC_Orientation_Mode.Axis ） 示例 1：大圆插补 考虑具有值范围为 -360° 到 360° 的 C 轴的龙门架。起始方位为 C=179°，目标方位为 C=-175°。大圆插补将 ZYZ 欧拉角 (A,B,C) 的 C 轴与路径上的行进距离成比例地从 179° 沿正方向移动，经过 180° 到 185°，对应于 -175°。在这种情况下，它的总角度为 6°。 示例 2：轴方向插补 再次考虑具有值范围为 -180° 到 180° 的 C 轴的龙门架。起始方位为 C=179°，目标方位为 C=-175°。轴插补将龙门的 C 轴与路径上的行进距离成比例地移动，从负方向 179° 越过 0° 到 -175°，总角度为 354°。 （如果在本例中使用大圆插补，则会发生错误，因为会超出 C 轴的工作空间。） 这两种类型的插值在一些重要特性上有所不同。 在大圆插补中，可以预测刀具方向的变化。在轴插补中，很难预测方向的变化，因为方向轴会根据位置对方向产生不同的影响。轴定向插补与 PTP 运动共享此特性。 （然而，这并不意味着轴定向插补的空间路径难以预测。两种定向插补的路径相同，TCP 始终精确地移动定义的轮廓。） 使用大圆插补时，方向运动学中的奇点无法移动。这可以通过轴插补轻松实现。 在大圆插补中，可能导致违反定位轴的轴限位，如第二个示例所述。因此，在发出命令时，需要确保以最短旋转移动到目标定位时不会违反轴限位。 使用轴插补，可以旋转超过 360°。如果方向轴的工作空间大于 360°，那么您可以移动到例如 540° 的位置，而不是 180° 的位置。这对应于相同的工具方向。使用大圆插补，这是不可能的。到目标方向的最短旋转始终最多对应于 180° 的总角度。 轴定向插补需要由位置运动学和刀具运动学组成的耦合运动学。位置部分必须实现接口 ISMPositionKinematics_Offset2 . 如果运动系统没有任何旋转轴并且它们实现了接口 ISMPositionKinematics ，然后选择的方向模式 ( SMC_Orientation_Mode ) 被忽略。 轴方向插补中的奇点 通过轴定向插补，可以通过定向运动学的奇异点进行路径运动，这可以显着简化编程。为此，位置运动学的奇异性会发生变化。 在大圆弧插补的情况下，如果法兰点 (A3) 位于第一个臂部分定义的线上（如果第二个关节角度为 0°），则 Scara3_Z 具有奇异性。 对于轴方向插补，位置运动学的奇异点会发生变化，因此 TCP 承担法兰点 (A3) 所具有的其他角色。当 TCP（不是法兰点）位于由第一个臂部分定义的线上时，就会出现这种奇点。当指令带有轴方向插补的运动时，检查这个改变的奇异点是否位于运动的起始位置和目标位置之间。如果是，则不接受移动并发出错误。 对于 6 轴关节臂机器人，情况与 Scara3_Z 相当，但可能存在两个奇点。第一种发生在 TCP 位于通过 A2 和 A3 的线路上时。第二个发生在 TCP 位于通过 A1 的线路上时。指挥部还会在这里检查是否没有穿越奇点。 使用轴方向插补移动时，Scara3（或 6 轴关节臂机器人）的配置可能会发生变化。但是，在运动结束时，始终应用机器人在起点时的相同配置。 " }, 
{ "title" : "额外轴 ", 
"url" : "_sm_additional_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 额外轴 ", 
"snippet" : "附加轴是属于轴组但不属于运动学的一部分的轴。它们可以与运动学的协调运动同步移动。额外的轴和运动学的轴开始移动并同时到达目标位置。其他轴运动会被缓冲并与协调运动混合在一起。这同样适用于纯粹的额外轴运动，没有任何运动学运动...", 
"body" : "附加轴是属于轴组但不属于运动学的一部分的轴。它们可以与运动学的协调运动同步移动。额外的轴和运动学的轴开始移动并同时到达目标位置。其他轴运动会被缓冲并与协调运动混合在一起。这同样适用于纯粹的额外轴运动，没有任何运动学运动 " }, 
{ "title" : "与单轴运动相比的差异 ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062102818545", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 额外轴 \/ 与单轴运动相比的差异 ", 
"snippet" : "与使用功能块控制的单轴运动相比的主要区别，例如 MC_MoveAbsolute 或者 MC_MoveRelative 是运动的同步。如果同步不重要，那么使用单轴功能块命令轴可能是有意义的，因为这样轴的移动速度可能会更快。另一个区别是，额外的轴与轴组一起管理。它们通过以下方式启用 SMC_GroupPower 并且错误可以一起重置 MC_GroupReset 。应该注意的是，附加轴的单轴误差将导致轴组错误...", 
"body" : "与使用功能块控制的单轴运动相比的主要区别，例如 MC_MoveAbsolute 或者 MC_MoveRelative 是运动的同步。如果同步不重要，那么使用单轴功能块命令轴可能是有意义的，因为这样轴的移动速度可能会更快。另一个区别是，额外的轴与轴组一起管理。它们通过以下方式启用 SMC_GroupPower 并且错误可以一起重置 MC_GroupReset 。应该注意的是，附加轴的单轴误差将导致轴组错误 " }, 
{ "title" : "控制额外的轴运动 ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062103093337", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 额外轴 \/ 控制额外的轴运动 ", 
"snippet" : "命令其他轴运动时，无论轴组的主运动是绝对运动还是相对运动，您都可以在绝对和相对运动之间进行选择。例如，可以用同步命令相对额外的轴运动 MC_MoveLinearAbsolute 命令。 其他轴运动可通过以下方式控制 AdditionalAxes 轴组的运动功能块的输入。例如，可以按如下方式命令带有相对额外轴运动的绝对 PTP 如果只应移动额外的轴，则长度为 0 的协调移动（例如， MC_MoveDirectRelative 有距离 0 ) 可以与额外的轴运动一起指令。...", 
"body" : "命令其他轴运动时，无论轴组的主运动是绝对运动还是相对运动，您都可以在绝对和相对运动之间进行选择。例如，可以用同步命令相对额外的轴运动 MC_MoveLinearAbsolute 命令。 其他轴运动可通过以下方式控制 AdditionalAxes 轴组的运动功能块的输入。例如，可以按如下方式命令带有相对额外轴运动的绝对 PTP 如果只应移动额外的轴，则长度为 0 的协调移动（例如， MC_MoveDirectRelative 有距离 0 ) 可以与额外的轴运动一起指令。 " }, 
{ "title" : "注意事项 ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062106608843", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 额外轴 \/ 注意事项 ", 
"snippet" : "还支持模轴作为附加轴。它们始终处于操作状态 shortest 用于绝对额外轴运动的模式。 有关更多信息，请参阅以下内容： mc_directionmc_dire 附加轴的最大数量受库参数的限制 MAX_NUM_ADDITIONAL_AXES 来自 SM3_CPKernelDefaults 图书馆。可以在库管理器中更改此参数。 有关如何使用其他轴的示例，请参见以下内容： 在机器人中使用其他轴...", 
"body" : "还支持模轴作为附加轴。它们始终处于操作状态 shortest 用于绝对额外轴运动的模式。 有关更多信息，请参阅以下内容： mc_directionmc_dire 附加轴的最大数量受库参数的限制 MAX_NUM_ADDITIONAL_AXES 来自 SM3_CPKernelDefaults 图书馆。可以在库管理器中更改此参数。 有关如何使用其他轴的示例，请参见以下内容： 在机器人中使用其他轴" }, 
{ "title" : "路径精度的公差 ", 
"url" : "_sm_path_accuracy_tolerances.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 路径精度的公差 ", 
"snippet" : "可以为轴组设置路径精度的公差。如果动态坐标系发生意外移动，这些公差可使轴组赶上该坐标系，而不是因错误而停止 SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED ， SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED ， 或者 SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED 。...", 
"body" : "可以为轴组设置路径精度的公差。如果动态坐标系发生意外移动，这些公差可使轴组赶上该坐标系，而不是因错误而停止 SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED ， SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED ， 或者 SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED 。 " }, 
{ "title" : "概述 ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4560250800668834033944790208", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 路径精度的公差 \/ 概述 ", 
"snippet" : "为什么路径精度需要公差？理想情况下，轴组应完全遵循路径。但是，如果使用动态坐标系（例如，皮带或旋转工作台上的对象，或由另一个轴组指定的坐标系），则在某些情况下无法遵循路径。 示例：机器人应将零件放置在传送带上。传送带以恒定速度移动，但就在机器人到达放置零件的位置之前，传送带意外加速。在这种情况下，放置零件的轨迹已经计算出来，但假设传送带继续以恒定速度移动。因此，剩余的运动现在可能会导致违反机器人轴之一的最大加速度。 在这种情况下，公差很重要。它们允许轴组在指定限制内偏离路径并再次追上坐标系。 路径精度由滤波器控制。过滤器接收计划轨迹（ q_ref ）和最后计算的目标位置（ q_set ）作为输...", 
"body" : "为什么路径精度需要公差？理想情况下，轴组应完全遵循路径。但是，如果使用动态坐标系（例如，皮带或旋转工作台上的对象，或由另一个轴组指定的坐标系），则在某些情况下无法遵循路径。 示例：机器人应将零件放置在传送带上。传送带以恒定速度移动，但就在机器人到达放置零件的位置之前，传送带意外加速。在这种情况下，放置零件的轨迹已经计算出来，但假设传送带继续以恒定速度移动。因此，剩余的运动现在可能会导致违反机器人轴之一的最大加速度。 在这种情况下，公差很重要。它们允许轴组在指定限制内偏离路径并再次追上坐标系。 路径精度由滤波器控制。过滤器接收计划轨迹（ q_ref ）和最后计算的目标位置（ q_set ）作为输入。过滤器的输出是目标位置（ q_set ），它们被传输到驱动器。如果 q_ref 违反轴限制之一，则过滤器离开路径并在不违反轴限制的情况下尽可能接近地遵循计划轨迹。只要之间存在滞后 q_set 和 q_ref 在容差范围内，不会输出任何错误。 路径精度的公差由几个值组成： TCP 的最大滞后（以技术单位表示）（默认值： 1 u ） TCP 的最大方向误差（以角度为单位）（默认值： 1 deg ） 每个轴的最大允许滞后（以轴的技术单位表示）（默认值：无穷大） " }, 
{ "title" : "对行政职能块的影响 ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4579672191731234033944887183", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 路径精度的公差 \/ 对行政职能块的影响 ", 
"snippet" : "位置、速度、加速度和加加速度的值由 SMC_GroupReadSetPosition , SMC_GroupReadSetVelocity , SMC_GroupReadSetAcceleration ， 和 SMC_GroupReadSetJerk 功能块根据规划轨迹计算（ q_ref ）。因此，它们不包含过滤器的贡献。 另一方面，位置、速度和加加速度的实际值 – 由 MC_GroupReadActualPosition , MC_GroupReadActualVelocity ， 和 MC_GroupReadActualAcceleration 功能块 – 根据轴组驱动器的实际位置计算。因...", 
"body" : "位置、速度、加速度和加加速度的值由 SMC_GroupReadSetPosition , SMC_GroupReadSetVelocity , SMC_GroupReadSetAcceleration ， 和 SMC_GroupReadSetJerk 功能块根据规划轨迹计算（ q_ref ）。因此，它们不包含过滤器的贡献。 另一方面，位置、速度和加加速度的实际值 – 由 MC_GroupReadActualPosition , MC_GroupReadActualVelocity ， 和 MC_GroupReadActualAcceleration 功能块 – 根据轴组驱动器的实际位置计算。因此，它们也包含了过滤器的贡献。 返回的路径动态 SMC_GroupReadPathDynamics 和 Source = MC_SOURCE.SET 基于计划轨迹（ q_ref ），因此不受滤波器的影响。 （对于其他值 Source 输入，包括滤波器的贡献） 触发器始终参考计划轨迹（ q_ref ）。返回的时间 MC_GroupReadTrigger 是计划轨迹到达触发点的时间。当过滤器处于活动状态时（ q_ref<>q_set ），轴组通常不会准确到达触发的位置和\/或时间。 注：有动向报告 Done 仅当计划轨迹（ q_ref ) 已到达运动结束，并且滤波器不再（或不再）处于活动状态（即可能的滞后已被消除）。然后设定位置（ q_set ) 对应于运动的目标位置。 " }, 
{ "title" : "设置公差并监控路径偏差 ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4575205545955234033945121691", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 路径精度的公差 \/ 设置公差并监控路径偏差 ", 
"snippet" : "公差可以使用设置 SMC_GroupSetPathTolerance 功能块。 过滤器的状态和当前计划轨迹之间的滞后 q_ref 和设定值 q_set 轴组的监控可以通过 InSync , PositionLag ， 和 OrientationLag 的输出 MC_GroupReadStatus 。 InSync = TRUE 意思是 q_ref = q_set 并且过滤器未激活。 InSync = FALSE 意思是 q_ref<>q_set 并且过滤器处于活动状态。...", 
"body" : "公差可以使用设置 SMC_GroupSetPathTolerance 功能块。 过滤器的状态和当前计划轨迹之间的滞后 q_ref 和设定值 q_set 轴组的监控可以通过 InSync , PositionLag ， 和 OrientationLag 的输出 MC_GroupReadStatus 。 InSync = TRUE 意思是 q_ref = q_set 并且过滤器未激活。 InSync = FALSE 意思是 q_ref<>q_set 并且过滤器处于活动状态。 " }, 
{ "title" : "缓冲和混合动作 ", 
"url" : "_sm_robotics_blending.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 缓冲和混合动作 ", 
"snippet" : "可以用以下方法缓冲移动命令 CODESYS SoftMotion 。对于每个命令动作，可以指定如何缓冲动作，以及如何从前一个动作到新动作进行混合。通过使拐角变圆来调整命令路径，这样路径就可以不停地行驶 运动是否被缓冲以及如何缓冲动作，可以通过以下方式进行配置 BufferMode 运动方块的输入（例如， MC_MoveDirectAbsolute 或者 MC_MoveCircularRelative ）。有关更多信息，请参阅以下内容： mc_buffer_mode 。 这个 TransitionMode 和 TransitionParameter 输入决定圆角的圆角方式。有关更多信息，请参阅以...", 
"body" : "可以用以下方法缓冲移动命令 CODESYS SoftMotion 。对于每个命令动作，可以指定如何缓冲动作，以及如何从前一个动作到新动作进行混合。通过使拐角变圆来调整命令路径，这样路径就可以不停地行驶 运动是否被缓冲以及如何缓冲动作，可以通过以下方式进行配置 BufferMode 运动方块的输入（例如， MC_MoveDirectAbsolute 或者 MC_MoveCircularRelative ）。有关更多信息，请参阅以下内容： mc_buffer_mode 。 这个 TransitionMode 和 TransitionParameter 输入决定圆角的圆角方式。有关更多信息，请参阅以下内容： MC_TRANSITION_MODE 。 有关动作的更多信息，请参阅以下内容： 运动功能块 在混合模式下， TransitionMode 一定不能等于 TMNone 。 两个乐章之间的融合最早始于第一乐章的中途，最晚于第二乐章的中途结束。 如果第一个动作已经计划得太远，那么使用设置的参数可能无法再进行混合。然后混合区域会缩小或无法再进行混合。为了保证成功混合，应在同一周期内命令两个动作。 " }, 
{ "title" : "混合时的路径动态 ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-idm43523137701146", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 缓冲和混合动作 \/ 混合时的路径动态 ", 
"snippet" : "如果在 CP 运动之间（线性段和圆形段之间）进行混合，则应注意在混合过程中可能会超过最大路径加速度和最大路径加速度。混合范围越短，这种效果就越明显。但是，轴的极限（最大轴加速度和最大轴加速度）始终保持不 因此，如果最大路径加速度较低且最大轴加速度较高，则混合时可能会出现过高的加速度。这可以通过以下方式来抵消 AccFactor 例如，通过降低运动的最大轴加速度来输入运动块。...", 
"body" : "如果在 CP 运动之间（线性段和圆形段之间）进行混合，则应注意在混合过程中可能会超过最大路径加速度和最大路径加速度。混合范围越短，这种效果就越明显。但是，轴的极限（最大轴加速度和最大轴加速度）始终保持不 因此，如果最大路径加速度较低且最大轴加速度较高，则混合时可能会出现过高的加速度。这可以通过以下方式来抵消 AccFactor 例如，通过降低运动的最大轴加速度来输入运动块。 " }, 
{ "title" : "的特点 TMStartVelocity ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231378653745", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 缓冲和混合动作 \/ 的特点 TMStartVelocity ", 
"snippet" : "混合点的计算基于理想的速度曲线，该曲线可能偏离实际速度曲线。此时，将在通往混合点的原始路径上模拟减速斜坡，同时模拟加速斜坡并远离混合点。使用编程路径速度和由轴极限得出的估计最大路径速度的最小值作为目标速度。 此外，在直线之间混合时，会考虑直线之间的角度。混合元素的最小曲率半径来自所需的路径速度和估计的动态极限。点 A' 和 B' 由该半径和直线之间的角度轮流产 如果尽管设定系数为 1，但混合过程中运动速度减慢，则增加系数可能会有所帮助。...", 
"body" : "混合点的计算基于理想的速度曲线，该曲线可能偏离实际速度曲线。此时，将在通往混合点的原始路径上模拟减速斜坡，同时模拟加速斜坡并远离混合点。使用编程路径速度和由轴极限得出的估计最大路径速度的最小值作为目标速度。 此外，在直线之间混合时，会考虑直线之间的角度。混合元素的最小曲率半径来自所需的路径速度和估计的动态极限。点 A' 和 B' 由该半径和直线之间的角度轮流产 如果尽管设定系数为 1，但混合过程中运动速度减慢，则增加系数可能会有所帮助。 " }, 
{ "title" : "示例 ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231380207819", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 缓冲和混合动作 \/ 示例 ", 
"snippet" : "在一个小示例应用程序中，应该拾取工件。机器人应首先在工件上方移动，然后向下移动以将其捡起。为了尽可能快地到达工件，不应停止两个动作之间的移动，而应混合移动。在第一个动作结束之前，混合到第二乐章应该开始十个单位。 为了满足要求，必须指挥两次行动。第一乐章（ moveAbove ) 在工件上方和第二动作 ( moveDown ) 向下朝向工件。对于第二乐章，必须定义如何缓冲和混合动作 如下图所示， BlendingHigh 被选为 BufferMode 。这定义了应在第一个动作之后对机芯进行缓冲，然后再进行混合。此外，对于 TransitionMode ， TMCornerDistance 以 1...", 
"body" : "在一个小示例应用程序中，应该拾取工件。机器人应首先在工件上方移动，然后向下移动以将其捡起。为了尽可能快地到达工件，不应停止两个动作之间的移动，而应混合移动。在第一个动作结束之前，混合到第二乐章应该开始十个单位。 为了满足要求，必须指挥两次行动。第一乐章（ moveAbove ) 在工件上方和第二动作 ( moveDown ) 向下朝向工件。对于第二乐章，必须定义如何缓冲和混合动作 如下图所示， BlendingHigh 被选为 BufferMode 。这定义了应在第一个动作之后对机芯进行缓冲，然后再进行混合。此外，对于 TransitionMode ， TMCornerDistance 以 10 个单位的距离进行定义，以将第一动作平滑地融合到第二乐章中。为了设置两个输入 TransitionMode 和 TransitionParameter 恰当地， SMC_CornerDistance 使用功能块。 " }, 
{ "title" : "动作间等待 ", 
"url" : "_sm_robotics_wait.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 动作间等待 ", 
"snippet" : "SoftMotion Robotics 提供在两次动作之间等待特定时间的功能。例如，当机器人需要在开始下一次动作之前在一次动作的目标位置抓取工件时，可能需要等待一段时间。 与运动类似，等待时间通过 SMC_GroupWait 功能块。有关此功能块的详细信息，请参阅： 组等待 。...", 
"body" : "SoftMotion Robotics 提供在两次动作之间等待特定时间的功能。例如，当机器人需要在开始下一次动作之前在一次动作的目标位置抓取工件时，可能需要等待一段时间。 与运动类似，等待时间通过 SMC_GroupWait 功能块。有关此功能块的详细信息，请参阅： 组等待 。 " }, 
{ "title" : "使用 MC_GroupHalt 或 MC_GroupStop 在路径上停止 ", 
"url" : "_sm_robotics_halt_stop.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 使用 MC_GroupHalt 或 MC_GroupStop 在路径上停止 ", 
"snippet" : "这 MC_GroupHalt 和 MC_GroupStop 功能块允许在路径上停止，同时考虑可配置的减速度和冲击极限。停止立即开始。 停止时的减速度和抖动限值可以与活动运动的减速度和抖动限值不同，可以更大也可以更小。只要不偏离路径，它们就会保持不变。例如，在路径中间，可以以较低的减速度平稳停止。然而，在路径末端，减速度至少要足够强，以防止任何超出末端的移动。 之间的区别 MC_GroupHalt 和 MC_GroupStop 主要区别在于 MC_GroupHalt 和 MC_GroupStop 那是一个 MC_GroupStop 不能中止，并且只有在 Execute 输入已重置。 MC_Gro...", 
"body" : "这 MC_GroupHalt 和 MC_GroupStop 功能块允许在路径上停止，同时考虑可配置的减速度和冲击极限。停止立即开始。 停止时的减速度和抖动限值可以与活动运动的减速度和抖动限值不同，可以更大也可以更小。只要不偏离路径，它们就会保持不变。例如，在路径中间，可以以较低的减速度平稳停止。然而，在路径末端，减速度至少要足够强，以防止任何超出末端的移动。 之间的区别 MC_GroupHalt 和 MC_GroupStop 主要区别在于 MC_GroupHalt 和 MC_GroupStop 那是一个 MC_GroupStop 不能中止，并且只有在 Execute 输入已重置。 MC_GroupStop 防止轴组移动。 区别于 MC_GroupInterrupt 相反 MC_GroupHalt 和 MC_GroupStop ， 一个 MC_GroupInterrupt 以短暂延迟启动，没有可配置的减速和冲击限制。而是使用活动运动的限制。在 MC_GroupInterrupt ，中断的运动可以恢复 MC_GroupContinue 。 在...的帮助下 SMC_GroupSaveContinueData ，这也有可能 MC_GroupHalt 和 MC_GroupStop 。更多信息请参见： 动作的中断和继续。 移动坐标系中的运动行为 对于运动 移动坐标系 （例如，当机器人相对于传送带移动时）， MC_GroupHalt 或者 MC_GroupStop 导致绝对停止。因此，它不是相对于移动坐标系停止的。如果没有 MC_GroupHalt 或者 MC_GroupStop 已被命令。 " }, 
{ "title" : "运动规划 ", 
"url" : "_sm_robotics_factor_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 运动规划 ", 
"snippet" : "当命令移动时，例如 MC_MoveLinearAbsolute ，机器人的最终速度取决于以下因素： 为轴组中的每个轴配置的最大速度、加速度和加加速度。（在轴配置中配置）。 上限定义了每个轴允许移动的速度。下面解释的其他限制只能降低有效限制。它们不能超出这些界限。 作为运动功能块的输入提供的最大速度、加速度和加速度。这些上限定义了 TCP 沿路径移动的速度。它们适用于各个轴的限制。 当前覆盖（见 MC_GroupSetOverride ）以及轴组的辅助限制 有关如何组合所有这些限制来计算有效路径和轴限制的描述，请参阅 SMC_GroupSetAncillaryAxisLimits ， SMC_G...", 
"body" : "当命令移动时，例如 MC_MoveLinearAbsolute ，机器人的最终速度取决于以下因素： 为轴组中的每个轴配置的最大速度、加速度和加加速度。（在轴配置中配置）。 上限定义了每个轴允许移动的速度。下面解释的其他限制只能降低有效限制。它们不能超出这些界限。 作为运动功能块的输入提供的最大速度、加速度和加速度。这些上限定义了 TCP 沿路径移动的速度。它们适用于各个轴的限制。 当前覆盖（见 MC_GroupSetOverride ）以及轴组的辅助限制 有关如何组合所有这些限制来计算有效路径和轴限制的描述，请参阅 SMC_GroupSetAncillaryAxisLimits ， SMC_GroupSetAncillaryPathLimits ， 和 SMC_GroupSetAxisLimitFactors 。 机器人的编程路径 例如，当运动混合导致曲率半径非常小时，机器人必须缓慢移动以免超出轴的限制。 这些因素共同决定了路径上的有效最大速度。但是，还有一个因素可能会限制可实现的速度：PLC 的性能。如果性能不足以规划运动，则机器人会以较慢的速度移动。如果由于性能原因，规划算法无法验证加速是否安全，则它将以较慢的速度移动。有关更多信息，请参阅： 表现" }, 
{ "title" : "运动的中断和继续 ", 
"url" : "_sm_robotics_stop_continue_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 运动的中断和继续 ", 
"snippet" : "当轴组在运动时，可以停止运动。这可能是故意停止（ MC_GroupHalt , MC_GroupStop )，或路径上的停顿 ( MC_GroupInterrupt )，或因错误而停止。在所有情况下， CODESYS SoftMotion 提供功能块将轴组移回规划路径并继续。 由于错误而停止运动 如果运动因错误而停止，则轴组的各个轴将单独停止并切换到错误状态。在这个过程中，TCP 离开了规划的路径。现在您可以确认错误、重置轴组并移动到检测到错误的位置。之后，您可以指示轴组继续先前计划的运动。 您使用 SMC_GroupEnableResumeAfterError 功能块，以启用该功能以在发生错...", 
"body" : "当轴组在运动时，可以停止运动。这可能是故意停止（ MC_GroupHalt , MC_GroupStop )，或路径上的停顿 ( MC_GroupInterrupt )，或因错误而停止。在所有情况下， CODESYS SoftMotion 提供功能块将轴组移回规划路径并继续。 由于错误而停止运动 如果运动因错误而停止，则轴组的各个轴将单独停止并切换到错误状态。在这个过程中，TCP 离开了规划的路径。现在您可以确认错误、重置轴组并移动到检测到错误的位置。之后，您可以指示轴组继续先前计划的运动。 您使用 SMC_GroupEnableResumeAfterError 功能块，以启用该功能以在发生错误后恢复编程的运动。必须在总线循环任务中循环调用功能块。每个轴组只能调用此功能块的一个实例。 如果轴组检测到错误并切换到状态 Errorstop ，然后它将已接受的运动和必要的状态信息保存在一个类型为 SMC_AXIS_GROUP_CONTINUE_DATA .然后这个变量包含“继续数据”并作为输入传递 SMC_GroupEnableResumeAfterError . 这使您可以稍后使用 MC_GroupContinue .如果错误是由命令运动引起的（例如，工作空间违规或无效的圆弧半径），则无法通过这种方式解决。移动继续后，这些错误将再次发生。该机制更多地用于单轴错误和其他强制轴组进入错误停止的外部事件。 MC_GroupContinue 要求轴组在继续运动时处于特定位置。在错误后恢复的情况下，该位置是检测到错误时的当前位置。您可以使用 SMC_GroupGetContinuePosition 功能块来获得这个位置。 如果轴组错误不允许继续运动（例如写入继续数据时的内部错误），则 MC_GroupContinue 和 SMC_GroupGetContinuePosition 返回新的错误 ID SMC_AXIS_GROUP_CONTINUE_DATA_NOT_WRITTEN . 如果 MC_GroupStop 发生错误时处于活动状态，然后 MC_GroupStop 运动继续时也会重新激活。轴组已经停止，并且 MC_GroupStop 已删除所有待处理的移动，因此不会发生移动。 发生轴组错误时，活动运动的功能块实例会发出错误（输出 Active 和 Busy 切换到 FALSE ，并输出 Error 切换到 TRUE ）。尚未激活的缓冲或混合运动的功能块实例也会发出错误。重新启动后，所有这些功能块实例都被重置为 Busy \/ Active 并且它们的输出重置为 Error \/ CommandAborted . " }, 
{ "title" : "通过暂停来停止运动 ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_74b10b31cbbdb856c0a8646354735c5f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 运动的中断和继续 \/ 通过暂停来停止运动 ", 
"snippet" : "您可以使用 MC_GroupInterrupt 和 MC_GroupInterruptAt 功能块来中断命令运动的执行。为了 MC_GroupInterrupt ，立即停止执行。为了 MC_GroupInterruptAt ，在特定位置执行停止。然后运动可以在以后继续 MC_GroupContinue . 功能块 MC_GroupInterruptAt 提供输入 SMC_GroupInterruptPositionMvtRel .这指定了相对于运动的中断位置。该运动由其引用 SMC_Movement_Id .运动中的位置由介于 0 和 1 之间的值（实数）定义，其中 0 是运动的开始，1 是结...", 
"body" : "您可以使用 MC_GroupInterrupt 和 MC_GroupInterruptAt 功能块来中断命令运动的执行。为了 MC_GroupInterrupt ，立即停止执行。为了 MC_GroupInterruptAt ，在特定位置执行停止。然后运动可以在以后继续 MC_GroupContinue . 功能块 MC_GroupInterruptAt 提供输入 SMC_GroupInterruptPositionMvtRel .这指定了相对于运动的中断位置。该运动由其引用 SMC_Movement_Id .运动中的位置由介于 0 和 1 之间的值（实数）定义，其中 0 是运动的开始，1 是结束。点 B 和 A 之间的位置被准确解释为好像没有混合。 P 之间的位置 开始 和 B 或 A 和 P 之间 目的地 投影在混合路径上。 错误处理 MC_GroupInterruptAt 当指定的运动 ID 未知时，功能块返回错误。跑步运动不会中断。 如果轴组当前的动态状态不允许在指定的中断位置之前达到静止状态，则 SMC_GroupInterruptAt 表现得一模一样 MC_GroupInterrupt ：立即执行中断，轴组到达指令中断位置后面某处的静止状态。 所有其他错误的处理方式与 MC_GroupInterrupt 完全一样 限制 MC_GroupInterruptAt 只要在中断位置停止的过程尚未开始，就可以通过另一个移动来中止特定位置处的中断。 同一时间在特定位置只能命令一个中断。如果已命令中断，则必须完成或中止该中断，以便可以接受另一个中断。 当你执行 MC_GroupInterrupt 或者 MC_GroupInterruptAt ，首先执行路径不变停止，类似于 MC_GroupHalt .然后轴组的状态（“继续数据”）存储在用户传输的变量中（类型 SMC_AXIS_GROUP_CONTINUE_DATA ）。现在轴组处于状态 GroupStandby 并且可以正常使用。一个典型的例子是轴组被点动。 稍后，您可以使用 MC_GroupContinue 继续中断的执行。为此，请传输保存的“继续数据”。为使其正常工作，轴组的位置必须与执行后的位置相匹配 MC_GroupInterrupt . （看 SMC_GroupGetContinuePosition .) 当跟踪运动被中断时（意味着相对于动态坐标系被命令的运动）， MC_GroupInterrupt 不会完全停止（比如 MC_GroupHalt )，但相对于动态坐标系。例如，如果工件在转台上进行跟踪， MC_GroupInterrupt 相对于工件停止。轴组继续跟随工件。继续数据必须更新 SMC_GroupUpdateContinueData 如果运动系统具有多个周期的旋转轴。之后，运动可以继续 MC_GroupContinue . 类型变量 SMC_AXIS_GROUP_CONTINUE_DATA 不得永久存储或在在线更改期间更改。 使用功能块 SMC_GroupWait ，您可以在两个运动之间的路径上等待可编程的时间。 " }, 
{ "title" : "通过 MC_GroupHalt 或 MC_GroupStop 停止运动 ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_28e8e9a71ed1fa93c0a8646375852228", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 运动的中断和继续 \/ 通过 MC_GroupHalt 或 MC_GroupStop 停止运动 ", 
"snippet" : "运动停止后 MC_GroupHalt 或者 MC_GroupStop , 轴组的运动可以在不丢失任何信息的情况下恢复如下： 调用功能块 SMC_GroupSaveContinueData 打电话之前 MC_GroupHalt 或者 MC_GroupStop .该 POU 保存当前状态、当前位置和调用停止或停止命令时的所有命令动作。这允许稍后从该位置继续运动。注意：这不是轴组到达停止位置后的位置。 版本 4.12.0.0 之前的行为： SMC_GroupSaveContinueData 功能块必须在同一个循环中调用 MC_GroupHalt 或者 MC_GroupStop 叫做。这时候，你必须确...", 
"body" : "运动停止后 MC_GroupHalt 或者 MC_GroupStop , 轴组的运动可以在不丢失任何信息的情况下恢复如下： 调用功能块 SMC_GroupSaveContinueData 打电话之前 MC_GroupHalt 或者 MC_GroupStop .该 POU 保存当前状态、当前位置和调用停止或停止命令时的所有命令动作。这允许稍后从该位置继续运动。注意：这不是轴组到达停止位置后的位置。 版本 4.12.0.0 之前的行为： SMC_GroupSaveContinueData 功能块必须在同一个循环中调用 MC_GroupHalt 或者 MC_GroupStop 叫做。这时候，你必须确保 SMC_GroupSaveContinueData 之前被调用 MC_GroupHalt 或者 MC_GroupStop .否则，中止的运动将从队列中移除。 自版本 4.12.0.0 起的行为： SMC_GroupSaveContinueData 功能块可以随时调用，直到调用后的第一个动作 MC_GroupHalt 或者 MC_GroupStop .继续位置是功能块第一次调用时的当前轴组位置。保存的路径包含在停止\/停止命令之前已接受的所有运动。 为了能够在轴组停止的位置继续路径 MC_GroupHalt 或者 MC_GroupStop , SMC_GroupSaveContinueData 应该在循环中调用 MC_GroupHalt 或者 MC_GroupStop 设置 Done 信号。 只有一个实例 SMC_GroupSaveContinueData 可以按轴组调用。 在暂停\/停止命令之前保存当前状态可能需要几个周期，但保证在任何中断运动之前保存第一个周期中的状态信息。 SMC_GroupSaveContinueData 可以随时调用以保存当前状态，不仅与调用有关 MC_GroupHalt 或者 MC_GroupStop . " }, 
{ "title" : "与单轴运动的相互作用 ", 
"url" : "_sm_additional_axes_single_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 与单轴运动的相互作用 ", 
"snippet" : "轴组的每个轴（包括任何其他轴）也可以通过单轴移动来移动。这不需要将轴从轴组中移除。使用以下规则： 如果轴组在 GroupStandby 状态当在其一个轴上命令单轴运动时，该轴组将保持此状态。 有关更多信息，请参阅以下内容： 轴心国如果轴组在 GroupMoving 状态当单轴运动被命令在其一个轴上进行时，该轴组切换到 GroupError 州。 SMC_AXIS_GROUP_INTERRUPTED_BY_SINGLE_AXIS 已报告并且所有其他轴都已停止。 如果在轴组上命令移动，而单轴运动在其至少一个轴上处于活动状态，则该轴组将进入 GroupError 州。...", 
"body" : "轴组的每个轴（包括任何其他轴）也可以通过单轴移动来移动。这不需要将轴从轴组中移除。使用以下规则： 如果轴组在 GroupStandby 状态当在其一个轴上命令单轴运动时，该轴组将保持此状态。 有关更多信息，请参阅以下内容： 轴心国如果轴组在 GroupMoving 状态当单轴运动被命令在其一个轴上进行时，该轴组切换到 GroupError 州。 SMC_AXIS_GROUP_INTERRUPTED_BY_SINGLE_AXIS 已报告并且所有其他轴都已停止。 如果在轴组上命令移动，而单轴运动在其至少一个轴上处于活动状态，则该轴组将进入 GroupError 州。 " }, 
{ "title" : "与移动坐标系同步 ", 
"url" : "_sm_robotics_dynamic_tracking.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 与移动坐标系同步 ", 
"snippet" : "集成的跟踪功能允许对相对于移动坐标系的运动进行编程。一个典型的用例是从传送带上拾取产品并将其放在不同的传送带上。在为每条皮带定义了一个动态坐标系后，用户可以简单地为相对于这些坐标系的运动提供目标位置。 CODESYS SoftMotion 负责叠加轴组的指令运动和皮带的运动。 典型的跟踪运动包括三个阶段： Tracking in：从另一个坐标系移动到动态坐标系中。到达目标位置后，轴组将跟随动态坐标系运动。 跟踪移动：移动到同一动态坐标系内的不同位置。命令的运动和动态坐标系的运动将被叠加。 Tracking out：从动态坐标系移动到不同的坐标系。到达目标位置后，轴组的运动将不再受动坐标系运动的...", 
"body" : "集成的跟踪功能允许对相对于移动坐标系的运动进行编程。一个典型的用例是从传送带上拾取产品并将其放在不同的传送带上。在为每条皮带定义了一个动态坐标系后，用户可以简单地为相对于这些坐标系的运动提供目标位置。 CODESYS SoftMotion 负责叠加轴组的指令运动和皮带的运动。 典型的跟踪运动包括三个阶段： Tracking in：从另一个坐标系移动到动态坐标系中。到达目标位置后，轴组将跟随动态坐标系运动。 跟踪移动：移动到同一动态坐标系内的不同位置。命令的运动和动态坐标系的运动将被叠加。 Tracking out：从动态坐标系移动到不同的坐标系。到达目标位置后，轴组的运动将不再受动坐标系运动的影响。 " }, 
{ "title" : "定义动态坐标系 ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4599737357387233382157942652", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 与移动坐标系同步 \/ 定义动态坐标系 ", 
"snippet" : "实现动态跟踪应用程序的第一步是定义动态坐标系。 CODESYS SoftMotion 提供四个用于定义动态坐标系的功能块： MC_TrackConveyorBelt ：一个易于使用的功能块，适用于跟踪传送带的常见用例。通过以下方式提供对实际皮带的参考 ConveyorBelt 输入，需要 SoftMotion 类型的轴 AXIS_REF_SM3 . MC_TrackRotaryTable ：一个易于使用的功能块，适用于跟踪转台的常见用例。通过以下方式提供对实际转台的参考 RotaryTable 输入，需要 SoftMotion 类型的轴 AXIS_REF_SM3 . MC_SetDynCoor...", 
"body" : "实现动态跟踪应用程序的第一步是定义动态坐标系。 CODESYS SoftMotion 提供四个用于定义动态坐标系的功能块： MC_TrackConveyorBelt ：一个易于使用的功能块，适用于跟踪传送带的常见用例。通过以下方式提供对实际皮带的参考 ConveyorBelt 输入，需要 SoftMotion 类型的轴 AXIS_REF_SM3 . MC_TrackRotaryTable ：一个易于使用的功能块，适用于跟踪转台的常见用例。通过以下方式提供对实际转台的参考 RotaryTable 输入，需要 SoftMotion 类型的轴 AXIS_REF_SM3 . MC_SetDynCoordTransform ：功能块的工作方式类似于 MC_TrackConveyorBelt 和 MC_TrackRotaryTable , 但是，不是由单个轴控制，而是由一个完整的轴组控制。这允许实现具有多达六个自由度的动态坐标系。 SMC_SetDynCoordTransformEx ：功能块允许实现完全自定义的动态坐标系。 四个功能块中的每一个都有一个 CoordSystem 输入基本上允许给坐标系一个名字，要么 PCS_1 或者 PCS_2 .当命令运动时，坐标系以此名称引用。 " }, 
{ "title" : "命令移动到动态坐标系中的某个位置 ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4620464078688033382158385681", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 与移动坐标系同步 \/ 命令移动到动态坐标系中的某个位置 ", 
"snippet" : "定义动态坐标系后，命令移动到该坐标系中的某个位置很容易。每个运动功能块，例如 MC_MoveLinearAbsolute ， 有个 CoordSystem 输入。此输入必须设置为名称（ PCS_1 或者 PCS_2 ) 赋予动态坐标系。这 Position 然后可以将输入设置为相对于动态坐标系原点的所需位置。执行移动功能块将导致移动到移动坐标系内的位置。一旦到达目标位置，轴组将遵循动态坐标系，同时停留在该相对位置。...", 
"body" : "定义动态坐标系后，命令移动到该坐标系中的某个位置很容易。每个运动功能块，例如 MC_MoveLinearAbsolute ， 有个 CoordSystem 输入。此输入必须设置为名称（ PCS_1 或者 PCS_2 ) 赋予动态坐标系。这 Position 然后可以将输入设置为相对于动态坐标系原点的所需位置。执行移动功能块将导致移动到移动坐标系内的位置。一旦到达目标位置，轴组将遵循动态坐标系，同时停留在该相对位置。 " }, 
{ "title" : "动态坐标系功能块的“InUse”输出 ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4663886345662433382158689616", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 与移动坐标系同步 \/ 动态坐标系功能块的“InUse”输出 ", 
"snippet" : "每个动态坐标系功能块（ MC_TrackConveyorBelt , MC_TrackRotaryTable , MC_SetDynCoordTransform ， 和 SMC_SetDynCoordTransformEx ) 有一个 InUse 输出。不允许在坐标系仍在使用时重新启动功能块，否则会导致错误 SMC_AXIS_GROUP_PCS_STILL_IN_USE .一旦命令移动到坐标系中的某个位置，就会立即使用动态坐标系。它将一直使用，直到到达不同坐标系中的目标位置。...", 
"body" : "每个动态坐标系功能块（ MC_TrackConveyorBelt , MC_TrackRotaryTable , MC_SetDynCoordTransform ， 和 SMC_SetDynCoordTransformEx ) 有一个 InUse 输出。不允许在坐标系仍在使用时重新启动功能块，否则会导致错误 SMC_AXIS_GROUP_PCS_STILL_IN_USE .一旦命令移动到坐标系中的某个位置，就会立即使用动态坐标系。它将一直使用，直到到达不同坐标系中的目标位置。 " }, 
{ "title" : "跟踪运动的轴限制 ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4557758355867233382158929251", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 与移动坐标系同步 \/ 跟踪运动的轴限制 ", 
"snippet" : "轴限制必须考虑坐标系的运动以及相对于坐标系的命令运动。如果为了跟随坐标系需要高轴动力学，则相对于坐标系的运动可能很慢或根本不可能。如果轴组接近运动学的奇点，这甚至可能发生在移动速度相对较慢的坐标系中。 有关详细信息，请参阅： 标签：常规...", 
"body" : "轴限制必须考虑坐标系的运动以及相对于坐标系的命令运动。如果为了跟随坐标系需要高轴动力学，则相对于坐标系的运动可能很慢或根本不可能。如果轴组接近运动学的奇点，这甚至可能发生在移动速度相对较慢的坐标系中。 有关详细信息，请参阅： 标签：常规" }, 
{ "title" : "跟踪时 CP 运动的路径动力学 ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm466388653271043338215917861", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 与移动坐标系同步 \/ 跟踪时 CP 运动的路径动力学 ", 
"snippet" : "必须特别考虑 CP 运动的路径动态。这包括 Velocity ， Acceleration ， Deceleration ， 和 Jerk 输入 MC_MoveLinearAbsolute ， MC_MoveLinearRelative ， MC_MoveCircularAbsolute ， 和 MC_MoveCircularRelative 。如果起始位置和目标位置位于同一动态坐标系中，则路径动态将相对于该坐标系。但是，如果起始位置和结束位置位于不同的坐标系中，则路径动态将由相对于第一个坐标系的动态混合到相对于第二个坐标系的动态。重要的是，路径动态应设置为高于两个坐标系之间动态差异的绝对值。...", 
"body" : "必须特别考虑 CP 运动的路径动态。这包括 Velocity ， Acceleration ， Deceleration ， 和 Jerk 输入 MC_MoveLinearAbsolute ， MC_MoveLinearRelative ， MC_MoveCircularAbsolute ， 和 MC_MoveCircularRelative 。如果起始位置和目标位置位于同一动态坐标系中，则路径动态将相对于该坐标系。但是，如果起始位置和结束位置位于不同的坐标系中，则路径动态将由相对于第一个坐标系的动态混合到相对于第二个坐标系的动态。重要的是，路径动态应设置为高于两个坐标系之间动态差异的绝对值。特别是，当从静态坐标系移动到动态坐标系时，路径动态应设置为高于坐标系动态的绝对值。 无法监控路径速度 SMC_GroupReadPathDynamics 在坐标系之间移动时（在不同的动态坐标系内、外或之间跟踪）。 SMC_GroupReadPathDynamics 计算相对于指定坐标系的路径动力学。在跟踪进出或在动态坐标系之间移动的情况下，这是一个依赖于两个坐标系的运动（起始坐标系和目标坐标系不同）。结果， SMC_GroupReadPathDynamics 功能块不适合计算这些情况下的路径动态。 " }, 
{ "title" : "避免错误 SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED、SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED 或 SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED。 ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4558812953211233382159412375", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 与移动坐标系同步 \/ 避免错误 SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED、SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED 或 SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED。 ", 
"snippet" : "错误 SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED ， SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED ， 或者 SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED 如果无法遵循命令路径而不违反配置的轴限制或路径动态，则会报告此错误。 如果发生此错误，应首先检查轴限制和路径动态是否根据前两节配置。 路径偏差可以通过输出进行监控 PositionLag 和 OrientationLag 的 MC_GroupReadStatus 功能块。 可能的解决方案如下： 增加轴限制。 在跟踪到动态坐标系时增加 ...", 
"body" : "错误 SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED ， SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED ， 或者 SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED 如果无法遵循命令路径而不违反配置的轴限制或路径动态，则会报告此错误。 如果发生此错误，应首先检查轴限制和路径动态是否根据前两节配置。 路径偏差可以通过输出进行监控 PositionLag 和 OrientationLag 的 MC_GroupReadStatus 功能块。 可能的解决方案如下： 增加轴限制。 在跟踪到动态坐标系时增加 CP 运动的路径动态。 减少坐标系的动态。 避免接近运动学奇点的运动，例如通过重新定位机器人。 如果动态坐标系由噪声编码器的输出控制，则可能有助于使用逻辑轴过滤编码器信号。有关详细信息，请参阅  选项卡：逻辑轴. 位置和方向滞后的可接受公差可以使用 SMC_GroupSetPathTolerance 功能块。 " }, 
{ "title" : "值范围超过 360° 的旋转轴 ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 值范围超过 360° 的旋转轴 ", 
"snippet" : "CP 运动时的行为 在 CP 运动期间 ( MC_MoveLinearAbsolute \/ MC_MoveLinearRelative , MC_MoveCircularAbsolute \/ MC_MoveCircularRelative )，旋转轴始终在自动模式下驱动（周期 0）。始终选择轴的周期，以便在轴上没有跳跃。 有可能在 CP 运动结束时，未达到指定的轴值，但由于周期的自动选择，轴将在不同的周期到达。这意味着无法通过所选运动类型到达指定位置。在到达目标位置之前检测到此冲突，轴组停止并发出错误。 示例：您使用带有三个旋转轴 A1、A2 和 A3 的 SCARA 机器人。A3 的数值范围...", 
"body" : "CP 运动时的行为 在 CP 运动期间 ( MC_MoveLinearAbsolute \/ MC_MoveLinearRelative , MC_MoveCircularAbsolute \/ MC_MoveCircularRelative )，旋转轴始终在自动模式下驱动（周期 0）。始终选择轴的周期，以便在轴上没有跳跃。 有可能在 CP 运动结束时，未达到指定的轴值，但由于周期的自动选择，轴将在不同的周期到达。这意味着无法通过所选运动类型到达指定位置。在到达目标位置之前检测到此冲突，轴组停止并发出错误。 示例：您使用带有三个旋转轴 A1、A2 和 A3 的 SCARA 机器人。A3 的数值范围为 -360° 至 +360°。您在轴坐标中示教两个位置。位置 1 = (A1 = 0°, A2 = 90°, A3 = 170°)，位置 2 = (A1 = 10°, A2 = 90°, A3 = -170°)。 然后你命令一个线性运动（ MC_MoveLinear\/MC_MoveAbsolute) ）与方向模式 GreatCircle 。 ACS 中的命令与大圆方向插补的这种组合会产生冲突。为了遵循方向插补，轴 A3 必须从正方向的 170° 移动到 190°。因此，它无法达到所需的目标位置 (-170°)。 注释：在 CP 运动的情况下，旋转轴的周期由所选的插补类型决定。这也意味着轴的目标位置取决于接近目标点的路径。因此，例如，通过混合两个运动，轴到达的周期可能与缓冲运动的情况不同。 有关更多信息，请参阅： CP 运动的方向插值" }, 
{ "title" : "介绍 ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_48a1e2bdb79a4093c0a864631bc39e2b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 值范围超过 360° 的旋转轴 \/ 介绍 ", 
"snippet" : "机器人通常具有值范围超过 360° 的旋转轴。例如，SCARA 机器人的最后一个轴（定向轴 A3）通常可以旋转不止一圈，从大约 -540° 到 540°。 这意味着可以通过多种方式接近相同的位置和方向。以 SCARA 为例，无论最后一个轴是在 -170° 还是 190° (= -170° + 360°)，刀具的方向和位置都是相同的。因此，笛卡尔位置和方向到轴值的转换（运动学逆变换）不是唯一的，而是有几种解决方案。 例如，这可以用于 Pick&Place 应用程序，通过从 170° 移动到 190° 而不是 -170° 来节省时间。 注意：在这些应用中，SCARA 定向轴的运动很快就会成为循环时...", 
"body" : "机器人通常具有值范围超过 360° 的旋转轴。例如，SCARA 机器人的最后一个轴（定向轴 A3）通常可以旋转不止一圈，从大约 -540° 到 540°。 这意味着可以通过多种方式接近相同的位置和方向。以 SCARA 为例，无论最后一个轴是在 -170° 还是 190° (= -170° + 360°)，刀具的方向和位置都是相同的。因此，笛卡尔位置和方向到轴值的转换（运动学逆变换）不是唯一的，而是有几种解决方案。 例如，这可以用于 Pick&Place 应用程序，通过从 170° 移动到 190° 而不是 -170° 来节省时间。 注意：在这些应用中，SCARA 定向轴的运动很快就会成为循环时间的限制因素。 " }, 
{ "title" : "解决歧义 ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_e9620f70b79a4093c0a86463477a7031", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 值范围超过 360° 的旋转轴 \/ 解决歧义 ", 
"snippet" : "如果在轴坐标系 (ACS) 中指定要移动的点，那么每个轴将在目标点中取什么值就很清楚了。另一方面，在笛卡尔指令（A\/B\/C 中的 X\/Y\/Z 位置和方向）中，旋转轴存在这种模糊性。 运动学的配置用于解决这种歧义。对于 SCARA 机器人，配置中已经包含了 SCARA 是否应该以 ElbowRight 或者 ElbowLeft .此外，SCARA 配置还包括设置 nPeriodA3 ，可用于确定应如何解决轴 A3 的歧义。 为此，整个值范围被划分为最大长度为 360° 的周期： 周期 -1 从 -540° 到 -180° 周期 1 从 -180° 到 180° 周期 2 从 180° 到 540...", 
"body" : "如果在轴坐标系 (ACS) 中指定要移动的点，那么每个轴将在目标点中取什么值就很清楚了。另一方面，在笛卡尔指令（A\/B\/C 中的 X\/Y\/Z 位置和方向）中，旋转轴存在这种模糊性。 运动学的配置用于解决这种歧义。对于 SCARA 机器人，配置中已经包含了 SCARA 是否应该以 ElbowRight 或者 ElbowLeft .此外，SCARA 配置还包括设置 nPeriodA3 ，可用于确定应如何解决轴 A3 的歧义。 为此，整个值范围被划分为最大长度为 360° 的周期： 周期 -1 从 -540° 到 -180° 周期 1 从 -180° 到 180° 周期 2 从 180° 到 540° （对于较大的轴取值范围，相应的可能周期数也较多。） 还有一个特殊的价值。如果 nPeriodA3 := 0 设置，然后激活自动解决歧义。对于 PTP 运动，这意味着选择周期以使轴 4 的起始位置和目标位置之间的距离尽可能小。 （下面描述了 CP 运动的行为。） 因此，可以通过相应地设置运动学配置来控制旋转轴模糊度的分辨率（参见 SMC_SetKinConfiguration ）。支持此功能的运动学实现接口 SMKinematicWithConfigurations3 . 这 SMC_GroupReadSetPosition , MC_GroupReadActualPosition ， 和 SMC_GroupTargetPosition 功能块始终输出具有激活的周期自动解析的配置。可以通过读取 ACS 中的位置来读出具有明确设置周期的当前配置，然后通过以下方式将其转换为 MCS： SMC_GroupConvertPosition 。返回的配置已明确设置周期。 有关更多信息，请参阅： 运动学配置" }, 
{ "title" : "外轴同步，转矩前馈控制 ", 
"url" : "_sm_robotics_external_axis_torque_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 外轴同步，转矩前馈控制 ", 
"snippet" : "轴组中的轴的轴值通常在用户编写的应用代码运行完后在循环结束时计算。但是，对于某些应用程序，必须尽快提供这些值才能在应用程序代码中使用它们。这 SMC_组更新 功能块确保属于轴组的所有轴的值立即更新。 一个用例 SMC_GroupUpdate 是不属于轴组的轴的同步。一个例子是 XY 龙门架中 X 轴的第二个驱动器。 前 CODESYS SoftMotion 版本 4.13.0.0： SMC_GroupUpdate 功能块是扭矩前馈控制。当前周期计算出的轴值可用于使用机器人的动态模型计算合适的设定扭矩。 在 CODESYS SoftMotion 版本 4.13.0.0 及更高版本：如果已使用以下...", 
"body" : "轴组中的轴的轴值通常在用户编写的应用代码运行完后在循环结束时计算。但是，对于某些应用程序，必须尽快提供这些值才能在应用程序代码中使用它们。这 SMC_组更新 功能块确保属于轴组的所有轴的值立即更新。 一个用例 SMC_GroupUpdate 是不属于轴组的轴的同步。一个例子是 XY 龙门架中 X 轴的第二个驱动器。 前 CODESYS SoftMotion 版本 4.13.0.0： SMC_GroupUpdate 功能块是扭矩前馈控制。当前周期计算出的轴值可用于使用机器人的动态模型计算合适的设定扭矩。 在 CODESYS SoftMotion 版本 4.13.0.0 及更高版本：如果已使用以下方式将动态模型分配给轴组 SMC_GroupSetDynamics ，则设定的扭矩将自动循环计算，并可用于扭矩前馈控制。 SMC_GroupUpdate 对于此用例来说不再是必需的。有关详细信息，请参阅： 扭矩限制和扭矩前馈控制" }, 
{ "title" : "触发器 ", 
"url" : "_sm_digital_switches-1517880.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 触发器 ", 
"snippet" : "当轴组到达路径上的定义位置时，触发器用于执行操作。例如，点胶机在达到粘合位置时可以开启。触发器还支持时移，因此可以在到达位置之前或之后的精确时间执行操作。例如，这可以用来补偿点胶机的死机时间。为此， CODESYS SoftMotion 提供配置动作触发器，然后持续读取剩余时间直到到达位置的功能。 使用触发器时应注意以下事项： 仅当轴组已接近触发点直至可配置预测的时间时，才能检索到达触发点之前的时间。此预测的配置方式以及设置的影响在 配置应用程序以使用触发器 部分。 使用触发器不会改变轨迹。特别是，轨迹不会减慢以符合配置的预测。例如，如果在 0.01 秒后已经到达运动开始时的触发器位置，则即使...", 
"body" : "当轴组到达路径上的定义位置时，触发器用于执行操作。例如，点胶机在达到粘合位置时可以开启。触发器还支持时移，因此可以在到达位置之前或之后的精确时间执行操作。例如，这可以用来补偿点胶机的死机时间。为此， CODESYS SoftMotion 提供配置动作触发器，然后持续读取剩余时间直到到达位置的功能。 使用触发器时应注意以下事项： 仅当轴组已接近触发点直至可配置预测的时间时，才能检索到达触发点之前的时间。此预测的配置方式以及设置的影响在 配置应用程序以使用触发器 部分。 使用触发器不会改变轨迹。特别是，轨迹不会减慢以符合配置的预测。例如，如果在 0.01 秒后已经到达运动开始时的触发器位置，则即使更高的预测也无法实现提前超过 0.01 秒提供关于到达该点的通知。 有关更多信息，请参阅示例 触发器示例 1：简单示例 和 触发示例2：涂胶过程。 " }, 
{ "title" : "配置应用程序以使用触发器 ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612456003211233798533752147", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 触发器 \/ 配置应用程序以使用触发器 ", 
"snippet" : "配置预测持续时间 预测持续时间决定了计划在未来多久完成。这是由 fPlanningForecastDuration 的参数 SMC_TuneCPKernel 功能块。如何设置该参数取决于应用程序的要求。有两个主要矛盾的要求： 最长的预测持续时间 尽可能低的延迟。开始运动时的延迟会增加，因为必须首先建立预测。此额外延迟的大小主要取决于所使用的控制器的性能，并且通常远低于配置的预测。此外，轴组对中止运动和中断做出反应的延迟会因配置的预测而增加。预测不会有任何影响 MC_GroupHalt 和 MC_GroupStop 。两个功能块始终立即采取行动，且独立于配置的预测。 这 fPlanningFor...", 
"body" : "配置预测持续时间 预测持续时间决定了计划在未来多久完成。这是由 fPlanningForecastDuration 的参数 SMC_TuneCPKernel 功能块。如何设置该参数取决于应用程序的要求。有两个主要矛盾的要求： 最长的预测持续时间 尽可能低的延迟。开始运动时的延迟会增加，因为必须首先建立预测。此额外延迟的大小主要取决于所使用的控制器的性能，并且通常远低于配置的预测。此外，轴组对中止运动和中断做出反应的延迟会因配置的预测而增加。预测不会有任何影响 MC_GroupHalt 和 MC_GroupStop 。两个功能块始终立即采取行动，且独立于配置的预测。 这 fPlanningForecastDuration 的参数 SMC_TuneCPKernel 因此，功能块应设置得尽可能高，但尽可能低。如果不需要预测，则该参数可以保留默认值 0。 由于各种原因，实际可用的预测可能与配置的预测不同，例如，如果最后一个运动已接近结束。当前可用的预测可以通过以下方式进行监控： CurrentPlanningForecast 的输出 MC_GroupReadStatus 。 配置每次运动的最大触发次数 交付时， CODESYS SoftMotion 每个动作最多支持 8 个触发器。如果这个数字还不够，那么 MAX_NUM_TRIGGERS_PER_MOVEMENT 参数可以作为库参数进行更改。这是可能的 图书馆经理 以及各自的编辑 库参数 。为了使用库参数， CODESYS 建议版本 >= SP19。 " }, 
{ "title" : "命令和评估触发器 ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4620348699414433798534144567", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 触发器 \/ 命令和评估触发器 ", 
"snippet" : "有两个功能块可用于命令触发器： SMC_GroupPrepareTrigger 和 SMC_GroupReadTrigger 。 触发器被分配给一个动作。每个单独的触发器都必须使用 SMC_GroupPrepareTrigger 功能块。该位置可以指定为相对、绝对或与平面的交点（请参见 SMC_TriggerPositionType ）。的调用顺序为 SMC_GroupPrepareTrigger 并且各个运动尤其重要，因为准备好的触发器被分配给同一周期中命令的下一个运动。因此，在每次应用中都需要注意以下几点： SMC_GroupPrepareTrigger 总是要在移动功能块之前调用。 触发...", 
"body" : "有两个功能块可用于命令触发器： SMC_GroupPrepareTrigger 和 SMC_GroupReadTrigger 。 触发器被分配给一个动作。每个单独的触发器都必须使用 SMC_GroupPrepareTrigger 功能块。该位置可以指定为相对、绝对或与平面的交点（请参见 SMC_TriggerPositionType ）。的调用顺序为 SMC_GroupPrepareTrigger 并且各个运动尤其重要，因为准备好的触发器被分配给同一周期中命令的下一个运动。因此，在每次应用中都需要注意以下几点： SMC_GroupPrepareTrigger 总是要在移动功能块之前调用。 触发器和相应的运动必须始终在同一周期内发出命令。如果在循环中没有开始任何运动，则准备好的触发器将被丢弃，并且 CommandAborted 的输出 SMC_GroupPrepareTrigger 功能块已设置。 当触发器被分配给一个动作时，可以使用以下命令检索有关触发器的信息 SMC_GroupReadTrigger 。一旦触发器处于可用的预测持续时间内，状态就会更改为 SMC_TRIGGER_STATUS.Active 并且可以读出到达触发之前的时间。该时间始终指当前周期的开始时间。根据触发器何时被触发（到达位置之前、期间或之后），可以在应用程序中以适当的周期执行所需的操作。 当触发器被分配给运动时，它们不能被中止。相反，它们可以被简单地忽略。 如果一个运动被第二个运动中止 MC_BUFFER_MODE.Aborting ，那么分配给第一个动作的触发器也会消失。 " }, 
{ "title" : "混合运动的触发器 ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612455902227233798534431018", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 运动控制 \/ 触发器 \/ 混合运动的触发器 ", 
"snippet" : "对于运动 缓冲和混合动作，触发器被投影到混合路径上。下图定性地示出了从 P1 到 P2 的移动以及后续移动均通过混合进行命令的情况。与第一个运动的混合在 B 点结束，与前一个运动的混合在 A 点开始。蓝色触发器位于 P1 和 B 之间。它被投影到第一个混合运动的后半部分（由蓝线突出显示） 。以同样的方式，位于 A 和 P2 之间的红色触发器被投射到第二个混合运动的前半部分（由红线突出显示）。绿色触发器位于混合区域之外并且不会移动。 当与触发器混合时，有一个关于运动状态和相应触发器的特殊功能。从 P1 移动到 P2 报告的命令功能块 Done 一旦到达A点。但是，与此移动相关的红色触发器保持活动...", 
"body" : "对于运动 缓冲和混合动作，触发器被投影到混合路径上。下图定性地示出了从 P1 到 P2 的移动以及后续移动均通过混合进行命令的情况。与第一个运动的混合在 B 点结束，与前一个运动的混合在 A 点开始。蓝色触发器位于 P1 和 B 之间。它被投影到第一个混合运动的后半部分（由蓝线突出显示） 。以同样的方式，位于 A 和 P2 之间的红色触发器被投射到第二个混合运动的前半部分（由红线突出显示）。绿色触发器位于混合区域之外并且不会移动。 当与触发器混合时，有一个关于运动状态和相应触发器的特殊功能。从 P1 移动到 P2 报告的命令功能块 Done 一旦到达A点。但是，与此移动相关的红色触发器保持活动状态，直到到达其投影到的混合元素上的位置。 " }, 
{ "title" : "扭矩限制和扭矩前馈控制 ", 
"url" : "_sm_torque_limitation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 扭矩限制和扭矩前馈控制 ", 
"snippet" : "的扭矩限制 CODESYS SoftMotion 防止在协调运动期间超过驱动器的扭矩或力的指定限制。除了驱动器的速度、加速度和加加速度的现有限制外，还遵守这些扭矩和力的限制。对此的要求是应用运动学的动态模型，以功能块的形式实现 ISMDynamics 接口来自 SM3_Dynamics 图书馆。基本上，一个 AxesStateToTorque 需要方法，它计算轴的给定状态（对于它们的位置、速度和加速度）所需的扭矩。 除了扭矩限制之外，动态模型还允许计算扭矩前馈控制的设定扭矩。您可以在本章中找到一个应用示例 动态机器人模型....", 
"body" : "的扭矩限制 CODESYS SoftMotion 防止在协调运动期间超过驱动器的扭矩或力的指定限制。除了驱动器的速度、加速度和加加速度的现有限制外，还遵守这些扭矩和力的限制。对此的要求是应用运动学的动态模型，以功能块的形式实现 ISMDynamics 接口来自 SM3_Dynamics 图书馆。基本上，一个 AxesStateToTorque 需要方法，它计算轴的给定状态（对于它们的位置、速度和加速度）所需的扭矩。 除了扭矩限制之外，动态模型还允许计算扭矩前馈控制的设定扭矩。您可以在本章中找到一个应用示例 动态机器人模型. " }, 
{ "title" : "用例 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597660278291233422349551383", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 扭矩限制和扭矩前馈控制 \/ 用例 ", 
"snippet" : "在许多运动学，尤其是串行运动学中，存在多个关节或所有关节的耦合。一个简单的例子是在关节中带有驱动器的双摆，如下所示： 用例 1 用例 2 第一个关节中的驱动器执行 90° 旋转；第二个关节不应移动（用例 1）。假设一个被动的第二关节，很容易想象双摆的第二肢会因为惯性而向左转动。为了防止这种旋转，第二个关节中的驱动器必须向右产生扭矩。因此，第一个驱动器的运动需要来自第二个驱动器的反作用。 存在相反方向的耦合，例如，在第一个驱动器应以恒定速度移动而第二个驱动器缩回双摆的第二个臂的情况下（用例 2）。这减少了双摆相对于第一个关节的惯性矩阵。要获得角动量（惯性矩阵与角速度的乘积），需要增加第一个关节的...", 
"body" : "在许多运动学，尤其是串行运动学中，存在多个关节或所有关节的耦合。一个简单的例子是在关节中带有驱动器的双摆，如下所示： 用例 1 用例 2 第一个关节中的驱动器执行 90° 旋转；第二个关节不应移动（用例 1）。假设一个被动的第二关节，很容易想象双摆的第二肢会因为惯性而向左转动。为了防止这种旋转，第二个关节中的驱动器必须向右产生扭矩。因此，第一个驱动器的运动需要来自第二个驱动器的反作用。 存在相反方向的耦合，例如，在第一个驱动器应以恒定速度移动而第二个驱动器缩回双摆的第二个臂的情况下（用例 2）。这减少了双摆相对于第一个关节的惯性矩阵。要获得角动量（惯性矩阵与角速度的乘积），需要增加第一个关节的角速度。为了保持角速度恒定，需要通过改变第一个驱动器与其旋转方向相反的扭矩来减小角动量。因此，第二个驱动器的运动需要来自第一个驱动器的反应。 没有动态模型，只能将设定位置、设定速度和设定加速度发送到驱动器。在第一种情况下，无论第一个关节是否移动，都会为第二个驱动器定义一个恒定的设定位置。第二个驱动器中的控制单元需要能够处理这样一个事实，即对于相同的设定值，在一种情况下必须产生扭矩，而在另一种情况下则不能。第二种情况下的行为类似。这里，无论第二个关节是否移动，都将相同的恒定设定速度指定给第一个驱动器。在这里，驱动器中的控制单元也需要处理这样一个事实，即必须为相同的设定值生成不同的扭矩。 使用动态模型，可以计算设定扭矩并将其发送到驱动器。在那里它们可以用作控制单元的前馈维度。结果，控制单元接收允许改进控制质量的附加信息。 扭矩限制允许更精确地遵守驱动器的限制。在许多情况下，决定性的不是驱动器速度或加速度的限制，而是转矩的限制。当比较以下运动时，扭矩限制的优点从如上所述的双摆的示例变得清楚：第一驱动器的运动与第二臂缩回和第一驱动器的运动与第二臂伸出。在缩回状态下，关于第一关节的惯性矩阵小于在伸展状态下的惯性矩阵。因此，对于相同的运动（驱动器的相同速度和加速度曲线），伸出状态比缩回状态需要更大的扭矩。如果没有动态模型，则需要设置速度和加速度限制，以便在两种状态下都遵守扭矩限制。这会导致第一驱动器在缩回状态下以比遵守驱动器的扭矩限制所需的速度或加速度更低的速度或加速度移动。使用动态模型，可以配置扭矩限制，在规划运动时将其考虑在内，从而在两种状态下都得到充分利用。 一个稍微复杂的例子是上面描述的第一种情况，其中第一个驱动器正在移动，第二个驱动器应该保持其位置。为了保持其位置，第二个驱动器中所需的扭矩取决于第一个驱动器的运动。如果第一个驱动器加速过快，则原则上可能会违反第二个驱动器的扭矩限制。如果没有动态模型，这只能通过相应地配置第一个驱动器的加速度限制来防止。使用动态模型，可以在规划运动时考虑第二个驱动器的配置扭矩限制，并且可以限制第一个驱动器的加速度。 在更复杂的运动或运动学的情况下，这里描述的耦合效应会与更多的耦合效应结合在一起。动态模型允许将这些联轴器考虑在内，从而产生更好的设定值规格并更好地遵守驱动器的限制。 " }, 
{ "title" : "动态模型的配置 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4510933957710433418427140333", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 扭矩限制和扭矩前馈控制 \/ 动态模型的配置 ", 
"snippet" : "一个功能块形式的现有动态模型，它实现了 ISMDynamics 接口可以通过以下方式分配给轴组 SMC_GroupSetDynamics 功能块。除了动态模型外，功能块还必须用于在机器坐标系中以矢量形式配置重力加速度的方向和大小。...", 
"body" : "一个功能块形式的现有动态模型，它实现了 ISMDynamics 接口可以通过以下方式分配给轴组 SMC_GroupSetDynamics 功能块。除了动态模型外，功能块还必须用于在机器坐标系中以矢量形式配置重力加速度的方向和大小。 " }, 
{ "title" : "考虑负载 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552490173838433418429772624", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 扭矩限制和扭矩前馈控制 \/ 考虑负载 ", 
"snippet" : "可以通过 SMC_GroupSetLoad 功能块并在运行时更改。这 ExecutionMode 功能块的输入可用于定义负载变化何时生效（例如，立即生效或仅在当前运动完成后生效）。 继续 MC_GroupContinue ：继续时，存储在继续数据中的每个运动都会保持最初命令的负载。继续后命令的任何运动使用最后设定的负载。...", 
"body" : "可以通过 SMC_GroupSetLoad 功能块并在运行时更改。这 ExecutionMode 功能块的输入可用于定义负载变化何时生效（例如，立即生效或仅在当前运动完成后生效）。 继续 MC_GroupContinue ：继续时，存储在继续数据中的每个运动都会保持最初命令的负载。继续后命令的任何运动使用最后设定的负载。 " }, 
{ "title" : "变速箱的考虑 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552678559262433422353734728", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 扭矩限制和扭矩前馈控制 \/ 变速箱的考虑 ", 
"snippet" : "设定扭矩是为齿轮箱输出计算的，不会自动转换为驱动器。这 SMC_SetAdditionalConversionFactors 功能块可用于为每个轴的扭矩配置额外的转换系数。变速箱也可以这样考虑。...", 
"body" : "设定扭矩是为齿轮箱输出计算的，不会自动转换为驱动器。这 SMC_SetAdditionalConversionFactors 功能块可用于为每个轴的扭矩配置额外的转换系数。变速箱也可以这样考虑。 " }, 
{ "title" : "单位 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597662777713633422354433707", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 扭矩限制和扭矩前馈控制 \/ 单位 ", 
"snippet" : "力和扭矩及其限制基本上在应用中以牛顿 (N) 或牛顿米 (Nm) 为单位指定。在将设定力或设定扭矩发送到驱动器之前，可以进行重新缩放。为此，CiA 402 标准要求，例如，将设定扭矩以额定扭矩的千分之一（以 mNm 为单位）发送到驱动器。 长度单位在 SoftMotion 中是用户特定的。由于力和扭矩被定义为固定单位（N 或 Nm），因此必须配置从用户特定长度单位到米的转换系数（除非使用米作为长度单位）。这可以通过 SMC_GroupSetUnits 功能块。...", 
"body" : "力和扭矩及其限制基本上在应用中以牛顿 (N) 或牛顿米 (Nm) 为单位指定。在将设定力或设定扭矩发送到驱动器之前，可以进行重新缩放。为此，CiA 402 标准要求，例如，将设定扭矩以额定扭矩的千分之一（以 mNm 为单位）发送到驱动器。 长度单位在 SoftMotion 中是用户特定的。由于力和扭矩被定义为固定单位（N 或 Nm），因此必须配置从用户特定长度单位到米的转换系数（除非使用米作为长度单位）。这可以通过 SMC_GroupSetUnits 功能块。 " }, 
{ "title" : "移动坐标系中的扭矩限制 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552049322772833422354993274", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 扭矩限制和扭矩前馈控制 \/ 移动坐标系中的扭矩限制 ", 
"snippet" : "如果轴组在移动坐标系中移动，那么只有当轴组可以精确地跟随移动坐标系时，才能遵守扭矩限制。如果这是不可能的，并且偏差的公差通过以下方式配置 SMC_GroupSetPathTolerance ，那么在尝试补偿偏差时可能会超出扭矩限制。如果由于偏差超出公差而发生错误，则轴组停止。在此停止期间，也可能超过扭矩限制。在每种情况下都会计算设定的扭矩并将其发送到驱动器。...", 
"body" : "如果轴组在移动坐标系中移动，那么只有当轴组可以精确地跟随移动坐标系时，才能遵守扭矩限制。如果这是不可能的，并且偏差的公差通过以下方式配置 SMC_GroupSetPathTolerance ，那么在尝试补偿偏差时可能会超出扭矩限制。如果由于偏差超出公差而发生错误，则轴组停止。在此停止期间，也可能超过扭矩限制。在每种情况下都会计算设定的扭矩并将其发送到驱动器。 " }, 
{ "title" : "出现错误时的扭矩限制 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4612699285196833422355410226", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 扭矩限制和扭矩前馈控制 \/ 出现错误时的扭矩限制 ", 
"snippet" : "如果在规划期间检测到错误（例如，命令的运动将超出工作区域），则轴组将停止在先前命令的路径上。这样做时，扭矩限制得到遵守。如果无法在路径上停止（例如，因为驱动器报告错误），则也无法遵守扭矩限制。...", 
"body" : "如果在规划期间检测到错误（例如，命令的运动将超出工作区域），则轴组将停止在先前命令的路径上。这样做时，扭矩限制得到遵守。如果无法在路径上停止（例如，因为驱动器报告错误），则也无法遵守扭矩限制。 " }, 
{ "title" : "使用单轴运动和协调运动时的区别 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4483062104566433422355806924", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 扭矩限制和扭矩前馈控制 \/ 使用单轴运动和协调运动时的区别 ", 
"snippet" : "基本上，为属于具有动态模型的轴组的所有轴计算设定扭矩。这既适用于静止状态，也适用于通过单轴运动（例如， MC_MoveAbsolute ) 或通过协调运动遍历整个轴组（例如， MC_MoveDirectAbsolute ). 扭矩限制仅对协调运动有效。这样做的原因是，如上所述，轴的必要扭矩取决于轴组中一些或所有其他轴的位置和运动。因此，只有当轴组的所有轴都可以作为协调运动移动时，才有可能限制扭矩。 一个例外是 SMC_GroupJog 功能块。该功能块不支持扭矩限制。建议使用 SMC_GroupJog2 反而。...", 
"body" : "基本上，为属于具有动态模型的轴组的所有轴计算设定扭矩。这既适用于静止状态，也适用于通过单轴运动（例如， MC_MoveAbsolute ) 或通过协调运动遍历整个轴组（例如， MC_MoveDirectAbsolute ). 扭矩限制仅对协调运动有效。这样做的原因是，如上所述，轴的必要扭矩取决于轴组中一些或所有其他轴的位置和运动。因此，只有当轴组的所有轴都可以作为协调运动移动时，才有可能限制扭矩。 一个例外是 SMC_GroupJog 功能块。该功能块不支持扭矩限制。建议使用 SMC_GroupJog2 反而。 " }, 
{ "title" : "诊断 ", 
"url" : "_sm_robotics_diagnosis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 诊断 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "常见错误 ", 
"url" : "_sm_robotics_errors.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 诊断 \/ 常见错误 ", 
"snippet" : "本页介绍常见的轴组错误、其原因以及纠正错误可能采取的措施。有关所有可能错误的列表及其简要说明，请参阅帮助页面 SMC_ERROR (枚举) 。 错误代码 解释和原因 操作 SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED 轴组无法遵循指令路径，否则会违反轴限制（速度、加速度或急动度）。 此错误通常发生在 追踪 如果动态坐标系意外移动。 当路径经过机器人的奇异位置附近时，也会出现错误。奇异位置发生在不同的...", 
"body" : "本页介绍常见的轴组错误、其原因以及纠正错误可能采取的措施。有关所有可能错误的列表及其简要说明，请参阅帮助页面 SMC_ERROR (枚举) 。 错误代码 解释和原因 操作 SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED 轴组无法遵循指令路径，否则会违反轴限制（速度、加速度或急动度）。 此错误通常发生在 追踪 如果动态坐标系意外移动。 当路径经过机器人的奇异位置附近时，也会出现错误。奇异位置发生在不同的 配置 （例如，当 SCARA 机器人的手臂完全伸展时）。 看 避免错误 SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED、SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED 或 SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED。如果不使用动态坐标系，则确保机器人的路径不会靠近奇异位置。 SMC_CP_QUEUE_UNDERRUN 无法足够快地计算轴组的轨迹（速度曲线），因此轴组必须中止运动。 可能的原因： 性能问题。使用的控制器未提供足够的性能，或者在高优先级任务中计算过多。 不利的任务设置：轨迹的计算被其他任务所取代。 计算密集型命令。例如，如果混合运动被中止运动打断，然后又被中止运动打断，则可能需要更多计算时间。使用跟踪（动态坐标系）也需要更多计算时间。执行 SMC_GroupSaveContinueData 在运动过程中使用多个同时活动的触发器也会增加所需的计算时间。 检查轴组规划任务的任务设置是否选择正确，如果可能，将该任务重新定位到单独专用的CPU核心。 有关详细信息，请参阅：For more information, see: 规划任务的配置在 监控 任务配置选项卡 1 检查高优先级任务是否需要大量计算时间，如果可能的话，将性能密集型计算移至低优先级任务。 使用 SMC_TuneCPKernel 增加计划间隔。 有关详细信息，请参阅：For more information, see: 动作缓慢或急促时的诊断注意：您可以使用性能计数器 SMC_GroupReadPlanningStatistics 来确定这些行动的效果。 有关详细信息，请参阅：For more information, see: 动作缓慢或急促时的诊断SMC_TRAFO_INVALID_CONSTELLATION SMC_AXIS_POSITION_EXCEEDS_POSLIMITS SMC_AXIS_INVERSE_TRAFO_EXCEEDING_POSLIMITS 该路径完全或部分位于机器人工作空间之外。 可能的原因： 运动的起点或终点位于工作空间之外。 根据机器人类型，CP 运动的一部分运动可能超出工作空间。半径过大的圆弧段可能在开始和结束时位于工作空间内，而中间部分则离开工作空间。 当使用跟踪（动态坐标系）时，由于坐标系的移动，先前位于工作空间内的位置可能会随着时间的推移离开工作空间。 注意：报告错误时，轴组不一定靠近问题位置。有可能在轨迹计算过程中发现并报告错误，并且与距离当前位置仍有较大距离的路径段有关。 检查命令的移动并确保它们完全在工作空间内。 使用跟踪时：使用适当的限制以确保轴组不会随着时间的推移而移出工作区。例如，在使用传送带的拾取和放置中，通常的做法是定义一个安全区域，在该区域仍可从传送带拾取零件。零件离开此区域后，轴组不应再移动到该零件。 SMC_CP_CONFIGS_DIFFER SMC_CP_AXIS_ORIENTATION_IPO_CONFIG_DIFFERS CP 运动的起始位置和目标位置位于不同的配置中。 配置的处理在 运动学配置 章节。 使用时 OrientationMode Axis ，参见 CP 运动的方向插值 章节了解有关配置机器人方向部分的详细信息。 可能采取的措施： 确保 CP 运动的起始和结束位置位于相同的配置。 如有必要，使用 SMC_SetKinConfiguration 功能块在开始时设置机器人的配置（之后 MC_GroupEnable ）。 如果需要，使用 PTP 移动在配置之间切换。 " }, 
{ "title" : "表现 ", 
"url" : "_sm_robotics_performance.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 诊断 \/ 表现 ", 
"snippet" : "由于计算占用大量 CPU，因此运动规划在单独的任务中完成。此单独的任务称为规划任务，它与总线任务并行运行。如果 PLC 的性能不足以及时为总线任务规划规划任务中的路径，那么这就是性能问题。 运动规划中的性能问题可能导致 SMC_CP_QUEUE_UNDERRUN 错误，但也可能导致运动不平稳或比预期慢。有关 SMC_CP_QUEUE_UNDERRUN 错误，请参见 常见错误 章节。下面描述了与动作表现相关的问题的诊断。...", 
"body" : "由于计算占用大量 CPU，因此运动规划在单独的任务中完成。此单独的任务称为规划任务，它与总线任务并行运行。如果 PLC 的性能不足以及时为总线任务规划规划任务中的路径，那么这就是性能问题。 运动规划中的性能问题可能导致 SMC_CP_QUEUE_UNDERRUN 错误，但也可能导致运动不平稳或比预期慢。有关 SMC_CP_QUEUE_UNDERRUN 错误，请参见 常见错误 章节。下面描述了与动作表现相关的问题的诊断。 " }, 
{ "title" : "动作缓慢或急促时的诊断 ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm4597696111868834242456592379", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 诊断 \/ 表现 \/ 动作缓慢或急促时的诊断 ", 
"snippet" : "如果没有性能问题，那么每个动作的计划都是这样的： 有效限度 在整个运动过程中达到。例如，考虑一个简单的二维龙门架，有两个轴 X 和 Y 以及从位置 (0,0) 到 (10,-10) 的 PTP 运动。最大轴速度为 20，最大轴加速度为 100，最大轴抖动为 1000。 预期的运动如下： 首先以最大加速度建立加速度，直到达到加速度极限值 100。经过短暂的恒定加速阶段后，加速度再次以最大加速度减小，以便以加速度 0 达到速度极限值 20。经过恒定速度阶段后，减速，以便以速度和加速度 0 达到目标位置。 现实运动偏离该理想曲线可能有两个原因： 由于规划任务中的性能问题，导致规划的运动与理想曲线不符...", 
"body" : "如果没有性能问题，那么每个动作的计划都是这样的： 有效限度 在整个运动过程中达到。例如，考虑一个简单的二维龙门架，有两个轴 X 和 Y 以及从位置 (0,0) 到 (10,-10) 的 PTP 运动。最大轴速度为 20，最大轴加速度为 100，最大轴抖动为 1000。 预期的运动如下： 首先以最大加速度建立加速度，直到达到加速度极限值 100。经过短暂的恒定加速阶段后，加速度再次以最大加速度减小，以便以加速度 0 达到速度极限值 20。经过恒定速度阶段后，减速，以便以速度和加速度 0 达到目标位置。 现实运动偏离该理想曲线可能有两个原因： 由于规划任务中的性能问题，导致规划的运动与理想曲线不符。 规划的运动与理想曲线相对应，但机器人没有按照预期执行。 " }, 
{ "title" : "案例1：规划任务的性能问题 ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433006527711", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 诊断 \/ 表现 \/ 动作缓慢或急促时的诊断 \/ 案例1：规划任务的性能问题 ", 
"snippet" : "如果在规划过程中执行出现问题，那么动作可能看起来会像这样： 这是因为规划任务中的移动规划与公交任务中的执行并行。平均而言，规划任务需要提供与公交任务所需的轨迹一样多的轨迹。如果性能不足以满足这一要求，则移动速度会减慢。这会导致速度曲线呈波浪形。 诊断此类问题的第一个也是最重要的工具是跟踪。除了 fSetPosition ， fSetVelocity ， 和 fSetAcceleration 每个轴的变量， numTimeBudgetExceeded 和 numSlowDownLowIpoQueue 产出 SMC_GroupReadPlanningStatistics 功能块也应该记录。如果这些...", 
"body" : "如果在规划过程中执行出现问题，那么动作可能看起来会像这样： 这是因为规划任务中的移动规划与公交任务中的执行并行。平均而言，规划任务需要提供与公交任务所需的轨迹一样多的轨迹。如果性能不足以满足这一要求，则移动速度会减慢。这会导致速度曲线呈波浪形。 诊断此类问题的第一个也是最重要的工具是跟踪。除了 fSetPosition ， fSetVelocity ， 和 fSetAcceleration 每个轴的变量， numTimeBudgetExceeded 和 numSlowDownLowIpoQueue 产出 SMC_GroupReadPlanningStatistics 功能块也应该记录。如果这些计数器持续增加，则存在性能问题。 类似于 fSetPosition ， fSetVelocity ， 和 fSetAcceleration 变量，还有 fSetJerk 变量表示抖动。需要注意的是，抖动不是总线任务周期内应用的平均抖动（通常预期如此），而是周期结束时的瞬时抖动。因此， FSetJerk 对于诊断性能问题的意义有限。 " }, 
{ "title" : "改善运动的方法 ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm43443300985204", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 诊断 \/ 表现 \/ 动作缓慢或急促时的诊断 \/ 案例1：规划任务的性能问题 \/ 改善运动的方法 ", 
"snippet" : "以下列表包含处理性能问题的步骤： 速度、加速度和加加速度的极限值的调整： 从当前速度减速到静止所需的时间越长，所需的计算能力就越大 因此，速度的有效极限值过高以及加速度和加加速度的有效极限值过低更容易导致性能问题。 尤其是加速度和冲击的极限值不应设置得过低 增加规划任务的优先级，或降低其他任务的优先级（如果其他任务阻碍了规划任务）。规划任务的优先级应仅次于总线任务，为第二高。 如果有多个 CPU 核心可用，则将规划任务分配给专用核心（请参阅 规划任务的配置）。 使用 SMC_TuneCPKernel 增加价值 fPlanningInterval 和\/或 fSyncBufferDuration ...", 
"body" : "以下列表包含处理性能问题的步骤： 速度、加速度和加加速度的极限值的调整： 从当前速度减速到静止所需的时间越长，所需的计算能力就越大 因此，速度的有效极限值过高以及加速度和加加速度的有效极限值过低更容易导致性能问题。 尤其是加速度和冲击的极限值不应设置得过低 增加规划任务的优先级，或降低其他任务的优先级（如果其他任务阻碍了规划任务）。规划任务的优先级应仅次于总线任务，为第二高。 如果有多个 CPU 核心可用，则将规划任务分配给专用核心（请参阅 规划任务的配置）。 使用 SMC_TuneCPKernel 增加价值 fPlanningInterval 和\/或 fSyncBufferDuration 规划参数。 这 fPlanningInterval 参数指定最大规划增量（以秒为单位）。规划任务的循环时间不应永久超过此值。较高的值会降低计算能力，但也可能导致未充分利用速度、加速度和加加速度的设定限值。从起始值 0.016 秒（自 2009 年以来的默认值）开始 CODESYS SoftMotion 从版本4.6.0.0开始，应逐渐增加该值，直到性能可以接受为止。 这 fSyncBufferDuration 参数指定规划任务和总线任务之间的缓冲区大小。规划任务的峰值循环时间不得超过此值。更高的值可以补偿规划任务循环时间的峰值。但与此同时，这也增加了执行中断和中止运动的等待时间。 " }, 
{ "title" : "案例 2：机器人没有按照预期进行规划运动 ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433008452776", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 诊断 \/ 表现 \/ 动作缓慢或急促时的诊断 \/ 案例 2：机器人没有按照预期进行规划运动 ", 
"snippet" : "如果机器人没有按照预期进行规划的运动，则可能是由于以下原因： 控制器实时能力不足 驱动器的控制回路问题 在非实时控制器上，例如 CODESYS Control Win 或基于 Linux 的控制器没有底层 Linux 系统的实时补丁，即使性能足够好，也会出现运动太慢或不稳定的情况。如果总线任务没有在配置的时间范围内按时执行，就会发生这种情况。...", 
"body" : "如果机器人没有按照预期进行规划的运动，则可能是由于以下原因： 控制器实时能力不足 驱动器的控制回路问题 在非实时控制器上，例如 CODESYS Control Win 或基于 Linux 的控制器没有底层 Linux 系统的实时补丁，即使性能足够好，也会出现运动太慢或不稳定的情况。如果总线任务没有在配置的时间范围内按时执行，就会发生这种情况。 " }, 
{ "title" : "改善运动的方法 ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433012326085", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 诊断 \/ 表现 \/ 动作缓慢或急促时的诊断 \/ 案例 2：机器人没有按照预期进行规划运动 \/ 改善运动的方法 ", 
"snippet" : "在任务配置的“监控”选项卡上 1 ，检查总线任务的任务抖动 2 太高。这可能是因为总线任务被具有相同或更高优先级的任务取代，或者因为控制器的实时能力不够强。 如果抖动过高，并且已经确定总线任务具有最高优先级，则控制器的实时性不够。 在这种情况下，请使用实时性更好的控制器。 如果驱动器的控制环路存在问题，则应调整控制环路参数。扭矩前馈控制也可以改善控制环路性能。 有关详细信息，请参阅：For more information, see: 扭矩限制和扭矩前馈控制1 ：建议在上下文菜单中重置任务监控的测量值，因为启动应用程序后的第一个 PLC 循环通常持续时间增加且抖动增加。 2 ：抖动值最高约为 ...", 
"body" : "在任务配置的“监控”选项卡上 1 ，检查总线任务的任务抖动 2 太高。这可能是因为总线任务被具有相同或更高优先级的任务取代，或者因为控制器的实时能力不够强。 如果抖动过高，并且已经确定总线任务具有最高优先级，则控制器的实时性不够。 在这种情况下，请使用实时性更好的控制器。 如果驱动器的控制环路存在问题，则应调整控制环路参数。扭矩前馈控制也可以改善控制环路性能。 有关详细信息，请参阅：For more information, see: 扭矩限制和扭矩前馈控制1 ：建议在上下文菜单中重置任务监控的测量值，因为启动应用程序后的第一个 PLC 循环通常持续时间增加且抖动增加。 2 ：抖动值最高约为 20 us 时非常好，最高约为 100 us 时也很好。根据所用的驱动器，抖动值更高的操作也可能有效。达到总线任务的任务间隔数量级的抖动值可能会导致上述错误模式。 " }, 
{ "title" : "记录信息 ", 
"url" : "_sm_information_logging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 诊断 \/ 记录信息 ", 
"snippet" : "这个 smc_groupEventLogging 功能块是在 SoftMotion 版本 4.18.0.0 中引入的。该功能块可用于为轴组启用日志消息。一旦启用了日志消息，轴组就会将其执行的操作写入 日志 设备的。通过这种方式，可以按时间顺序跟踪轴组的事件。这在调查轴组的问题和意外行为时很有用。 为您的动作、负荷、工具等指定名称，以获取信息丰富的日志消息。 CODESYS SoftMotion 版本 4.18.0.0 及更高版本，一些命令功能块（例如 MC_MoveLinearAbsolute ， SMC_GroupSetTool 和 MC_SetCoordinateTransform ) 已...", 
"body" : "这个 smc_groupEventLogging 功能块是在 SoftMotion 版本 4.18.0.0 中引入的。该功能块可用于为轴组启用日志消息。一旦启用了日志消息，轴组就会将其执行的操作写入 日志 设备的。通过这种方式，可以按时间顺序跟踪轴组的事件。这在调查轴组的问题和意外行为时很有用。 为您的动作、负荷、工具等指定名称，以获取信息丰富的日志消息。 CODESYS SoftMotion 版本 4.18.0.0 及更高版本，一些命令功能块（例如 MC_MoveLinearAbsolute ， SMC_GroupSetTool 和 MC_SetCoordinateTransform ) 已提供新的 Name 输入。 日志记录可能会对性能产生负面影响，因此必须通过启用 SMC_GroupEventLogging 功能块。 在 CODESYS SoftMotion 版本 4.18.0.0，记录与轴组路径相关的消息。 类别 行动 描述 附加信息 运动 运动开始 轴组已开始对运动进行插值。 概述运动结束 轴组已完成对运动的插值。 混合开始 轴组已开始从活动运动混合到下一个动作。 混合结束 轴组已完成混合，并在下一动作中继续插值。 中止开始 轴组已中止当前运动，并正在混合到中止运动。 中止结束 轴组已完成混合并继续对中止运动进行插值。 等待开始了 轴组在当前位置等待。 等待结束 轴组已完成等待。 暂停\/停止启动 轴组已开始在路径上执行暂停\/停止。 暂停\/停止结束 轴组已在路径上执行了暂停\/停止。 工具 附带工具 轴组使用新工具。 配置工具偏移加载 已附上负载 轴组使用新载荷。 扭矩限制和扭矩前馈控制覆盖 轴或路径覆盖已更改 轴或路径覆盖已更改并已由轴组应用。 mc_groupsetOverride (FB) 路径精度 路径已离开 为了避免违反轴极限，轴组已离开命令路径。轴组再次尝试到达命令路径 路径精度的公差路径又到了 轴组再次到达命令路径。 中断—继续 中断开始 轴组已开始执行中断。 运动的中断和继续中断结束 轴组已执行中断并保存了 Continue 数据。 继续开始 轴组已读取 “继续” 数据并开始继续。 " }, 
{ "title" : "例子 ", 
"url" : "_sm_robotics_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "慢跑机器人 ", 
"url" : "_sm_robotics_jogging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 慢跑机器人 ", 
"snippet" : "见 Robotics_Jogging.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 此示例演示如何使用 SMC_GroupJog2 宝。 建议安装 CODESYS Depictor 对于这个例子（免费的演示版就足够了）。或者，您也可以从示例中删除相应的代码部分，以便在没有 Depictor 的情况下使用示例。...", 
"body" : "见 Robotics_Jogging.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 此示例演示如何使用 SMC_GroupJog2 宝。 建议安装 CODESYS Depictor 对于这个例子（免费的演示版就足够了）。或者，您也可以从示例中删除相应的代码部分，以便在没有 Depictor 的情况下使用示例。 " }, 
{ "title" : "应用 ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584875037158433080105006434", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 慢跑机器人 \/ 应用 ", 
"snippet" : "为了演示最一般的情况，该示例具有以下功能： 使用具有奇点的机器人（6 轴关节机器人）。该示例显示您可以通过 ACS 中的奇点移动机器人，然后以不同的配置以笛卡尔方式继续慢跑。 机器人的机器坐标系 (MCS) 相对于世界坐标系 (WCS) 的移动和旋转。通过这种方式，您可以看到慢跑在 MCS 和 WCS 中的不同之处。 相对于法兰 (F) 移动和旋转的工具配置。在下图中，您可以看到工具以及 TCS 相对于法兰 (F) 的移动和旋转。 线性附加轴 Add0 和一个旋转附加轴 Add1 。...", 
"body" : "为了演示最一般的情况，该示例具有以下功能： 使用具有奇点的机器人（6 轴关节机器人）。该示例显示您可以通过 ACS 中的奇点移动机器人，然后以不同的配置以笛卡尔方式继续慢跑。 机器人的机器坐标系 (MCS) 相对于世界坐标系 (WCS) 的移动和旋转。通过这种方式，您可以看到慢跑在 MCS 和 WCS 中的不同之处。 相对于法兰 (F) 移动和旋转的工具配置。在下图中，您可以看到工具以及 TCS 相对于法兰 (F) 的移动和旋转。 线性附加轴 Add0 和一个旋转附加轴 Add1 。 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4576391101379233081218831739", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 慢跑机器人 \/ 应用程序的结构 ", 
"snippet" : "主程序 主程序 PLC_PRG 由一个状态机组成，它 激活轴组（状态 0） 配置工具（状态 5） 配置 MCS（状态 6） 开始慢跑（状态 10） 在状态 20 中，处理慢跑错误并接受移动命令（ 移至位置 可视化中的开关）。 其它状态用于执行移动（60、70）以及处理和确认错误（900、1000）。 根据状态机，所有机器人 POU 和 GroupJog2 程序被循环调用，并对 Depictor 中的 3D 显示进行一些计算。 GroupJog2 程序 该程序包含一个具有以下步骤的状态机： 在状态 10 中，设置 SMC_GroupJog2 的输入并读取机器人轴的配置 (SMC_GroupRea...", 
"body" : "主程序 主程序 PLC_PRG 由一个状态机组成，它 激活轴组（状态 0） 配置工具（状态 5） 配置 MCS（状态 6） 开始慢跑（状态 10） 在状态 20 中，处理慢跑错误并接受移动命令（ 移至位置 可视化中的开关）。 其它状态用于执行移动（60、70）以及处理和确认错误（900、1000）。 根据状态机，所有机器人 POU 和 GroupJog2 程序被循环调用，并对 Depictor 中的 3D 显示进行一些计算。 GroupJog2 程序 该程序包含一个具有以下步骤的状态机： 在状态 10 中，设置 SMC_GroupJog2 的输入并读取机器人轴的配置 (SMC_GroupReadActualPosition)。此配置在轴组 (SMC_SetKinConfiguration) 的状态 20 中完成。 在状态 30 中，系统对点动期间的错误以及点动设置的变化（例如，对改变的坐标系）做出反应。如果有变化，则系统切换回状态 10。 在 Enable 输入的下降沿进入状态 50。微动由 MC_GroupHalt 停止。 " }, 
{ "title" : "调试 ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584880854092833081221538291", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 慢跑机器人 \/ 调试 ", 
"snippet" : "编译并启动创建的程序。您可以使用可视化来运行机器人。您可以定义点动的所有相关设置（例如，点动的坐标系和速度）。 如果您已经安装了 CODESYS Depictor ，那么建议您将窗口与Depictor（ Scene POU) 在可视化窗口旁边。 描绘器代表机器人前端的 TCS（工具坐标系）。此外，TCS 的当前旋转轴显示为紫色。这对于检查不同类型的方向变化很有用（例如，测试 ABC_as_ACS 选项和 TCS 坐标系）。...", 
"body" : "编译并启动创建的程序。您可以使用可视化来运行机器人。您可以定义点动的所有相关设置（例如，点动的坐标系和速度）。 如果您已经安装了 CODESYS Depictor ，那么建议您将窗口与Depictor（ Scene POU) 在可视化窗口旁边。 描绘器代表机器人前端的 TCS（工具坐标系）。此外，TCS 的当前旋转轴显示为紫色。这对于检查不同类型的方向变化很有用（例如，测试 ABC_as_ACS 选项和 TCS 坐标系）。 " }, 
{ "title" : "动作的中断和继续 ", 
"url" : "_sm_robotics_example_stop_continue.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 动作的中断和继续 ", 
"snippet" : "这 Robotics_Interrupt_Continue.project 此处描述的示例项目位于 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 此示例显示了如何使用 SMC_GroupInterrupt 功能块，并在稍后的时间恢复 SMC_GroupContinue 功能块。轴组可以执行中断和继续之间的任意运动。...", 
"body" : "这 Robotics_Interrupt_Continue.project 此处描述的示例项目位于 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 此示例显示了如何使用 SMC_GroupInterrupt 功能块，并在稍后的时间恢复 SMC_GroupContinue 功能块。轴组可以执行中断和继续之间的任意运动。 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4519127872464034232302809299", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 动作的中断和继续 \/ 应用程序的结构 ", 
"snippet" : "该应用程序由一个简单的状态机组成 PLC_PRG 程序和跟踪以便轻松追踪状态转换。 首先，启用轴和轴组。（ STATE_POWER_ON ） 然后，两个动作， moveLinearA 和 moveLinearB ，需要混合。（ STATE_START_MOVING ） 一旦第二个运动开始（混合开始时），运动就会中断。原因可能是检测到工具缺陷。 (STATE_INTERRUPT ） 例如，在正 Z 方向执行相对 PTP 运动，以更换缺陷后的工具。 (STATE_INTERMEDIATE_MOVEMENT ） 恢复前，系统返回到原来运动中断的位置。（ STATE_GET_CONTINUE_POS ...", 
"body" : "该应用程序由一个简单的状态机组成 PLC_PRG 程序和跟踪以便轻松追踪状态转换。 首先，启用轴和轴组。（ STATE_POWER_ON ） 然后，两个动作， moveLinearA 和 moveLinearB ，需要混合。（ STATE_START_MOVING ） 一旦第二个运动开始（混合开始时），运动就会中断。原因可能是检测到工具缺陷。 (STATE_INTERRUPT ） 例如，在正 Z 方向执行相对 PTP 运动，以更换缺陷后的工具。 (STATE_INTERMEDIATE_MOVEMENT ） 恢复前，系统返回到原来运动中断的位置。（ STATE_GET_CONTINUE_POS \/ STATE_MOVE_TO_CONTINUE_POS ） 恢复原来的动作。 (STATE_CONTINUE) " }, 
{ "title" : "用法 ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4586020725065634232302901331", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 动作的中断和继续 \/ 用法 ", 
"snippet" : "编译创建的程序并登录。要跟踪不同的状态，您可以将跟踪下载到控制器。启动应用程序。...", 
"body" : "编译创建的程序并登录。要跟踪不同的状态，您可以将跟踪下载到控制器。启动应用程序。 " }, 
{ "title" : "使用 Pick&Place 对机器人进行编程 ", 
"url" : "_sm_example_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 使用 Pick&Place 对机器人进行编程 ", 
"snippet" : "见 Robotics_PickAndPlace.project 和 Robotics_PickAndPlace_without_Depictor.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 这 Robotics_PickAndPlace.project 项目需要 CODESYS Depictor 要安装的描述器包。该项目以 3D 动画显示运动学。该项目 Robotics_PickAndPlace_without_Depictor.project 在可视化屏幕中显示序列的简化形式。 本章仅涵盖与以下内容相关的对象...", 
"body" : "见 Robotics_PickAndPlace.project 和 Robotics_PickAndPlace_without_Depictor.project 安装目录下的示例项目 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 这 Robotics_PickAndPlace.project 项目需要 CODESYS Depictor 要安装的描述器包。该项目以 3D 动画显示运动学。该项目 Robotics_PickAndPlace_without_Depictor.project 在可视化屏幕中显示序列的简化形式。 本章仅涵盖与以下内容相关的对象 SoftMotion . 该示例由三脚架、转台和传送带组成。 运动机构拾取位于转台上的环。拾取时，运动机构的刀盘与转台同步移动。 然后将环放置在位于传送带上的锥体上。放置时，运动机构与传送带同步移动。 两个按钮位于可视化屏幕上，用于控制序列。当你按下 汽车 按钮，环会自动放下。否则， 玩 按钮出现供您放置戒指。 功能块：MC_TrackConveyorBelt 和 MC_TrackRotaryTable 这 MC_TrackRotaryTable 功能块，在 Ring 功能块，用于确定 PCS_1 部分坐标系。该坐标系是在将环放置在转台上时设置的。 转台坐标系原点 RotaryTableOrigin 是转盘的中点。 Z 轴是转台的旋转轴。 PCS_1 作为输入变量的函数围绕转台坐标系的 Z 轴旋转 RotaryTable .因为轴组在 PCS_1 中移动，所以它跟随工作台的旋转。 行为类似于 MC_TrackConveyorBelt 功能块，在 Cone 功能块。在这种情况下，PCS ( PCS_2 ) 跟随坐标系的 X 轴 ConveyorBeltOrigin . " }, 
{ "title" : "结构 该项目的 ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_9645ebb75a1273b0c0a8640e01c9af58", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 使用 Pick&Place 对机器人进行编程 \/ 结构 该项目的 ", 
"snippet" : "CODESYS SoftMotion 控制器 轴组 三脚架 ：轴组定义运动学和到各个轴的映射 三脚架1 , 三脚架2 ， 和 三脚架3 . DepictorCalculations (PRG) , 环境 (PRG) , 戒指 (FB) ：用于控制完整序列和可视化的程序。除了产品坐标系（PCS_1 和 PCS_2）的定义之外，这些 POU 与理解 PLCopen 块无关。 机器人 (PRG) : 用于控制运动序列的程序。详细说明位于下一段。 可视化 ：用于阐明序列的动画可视化。 三脚架1 , 三脚架2 , 三极管3 ：三脚架的线性轴。 驱动旋转台 ：转台的轴。 传动传送带 ：传送带的轴。...", 
"body" : "CODESYS SoftMotion 控制器 轴组 三脚架 ：轴组定义运动学和到各个轴的映射 三脚架1 , 三脚架2 ， 和 三脚架3 . DepictorCalculations (PRG) , 环境 (PRG) , 戒指 (FB) ：用于控制完整序列和可视化的程序。除了产品坐标系（PCS_1 和 PCS_2）的定义之外，这些 POU 与理解 PLCopen 块无关。 机器人 (PRG) : 用于控制运动序列的程序。详细说明位于下一段。 可视化 ：用于阐明序列的动画可视化。 三脚架1 , 三脚架2 , 三极管3 ：三脚架的线性轴。 驱动旋转台 ：转台的轴。 传动传送带 ：传送带的轴。 " }, 
{ "title" : "机器人 (PRG) 顺序程序的结构 ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_d2b72ec95a1273b5c0a8640e012cc527", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 使用 Pick&Place 对机器人进行编程 \/ 机器人 (PRG) 顺序程序的结构 ", 
"snippet" : "这 Robot (PRG) 程序循环运行。此时，各个步骤的执行取决于 state .在程序结束时，所有使用的功能块的调用都准备好进行运动命令。 三脚架的单轴被激活（功能块 pwA1 , pwA2 ， 和 pwA3 类型 MC_Power ）。 CASE 0 ：等待参与的轴可操作。 CASE 10 ：设置归位；在物理应用中，在此位置执行归位（功能块 spA1 , spA2 ， 和 spA3 类型 MC_SetPosition ）。 CASE 20 : 世界坐标系中机床坐标系的放置（功能块 setCoord 类型 MC_SetCoordinateTransform ）。 CASE 30 ：释放轴组...", 
"body" : "这 Robot (PRG) 程序循环运行。此时，各个步骤的执行取决于 state .在程序结束时，所有使用的功能块的调用都准备好进行运动命令。 三脚架的单轴被激活（功能块 pwA1 , pwA2 ， 和 pwA3 类型 MC_Power ）。 CASE 0 ：等待参与的轴可操作。 CASE 10 ：设置归位；在物理应用中，在此位置执行归位（功能块 spA1 , spA2 ， 和 spA3 类型 MC_SetPosition ）。 CASE 20 : 世界坐标系中机床坐标系的放置（功能块 setCoord 类型 MC_SetCoordinateTransform ）。 CASE 30 ：释放轴组（功能块 enable 类型 MC_GroupEnable . 等待轴组已应用所有值的响应。 CASE 40 到 CASE 130 ：Pick&Place 应用程序：所有运动都可能通过多个实例进行命令 MC_MoveDirectAbsolute , MC_MoveDirectRelative ， 和 MC_MoveLinear 循环调用。上升沿 Execute 这些 POU 在每个状态下的输入导致发出一个新的运动命令，其中输出 bCommandAccepted 表示过程成功。典型的命令链是在下一个运动命令之前询问此输出而产生的。 " }, 
{ "title" : "动态机器人模型 ", 
"url" : "_sm_dynamic_robot_model.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 动态机器人模型 ", 
"snippet" : "见 Robotics_DynamicModel.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 为了限制运动期间的轴扭矩\/力，需要一个动态模型，该模型根据当前轴状态（位置、速度和加速度）计算这些值。本示例包括以下部分： 第 1 部分展示了如何在应用程序中使用现有的动态模型以及一些示例运动的结果。 第 2 部分展示了如何根据 KM Lynch 和 FC Park 所著的《现代机器人》一书中提出的算法为 SCARA 机器人创建动态模型。...", 
"body" : "见 Robotics_DynamicModel.project 安装目录下的示例工程 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples . 为了限制运动期间的轴扭矩\/力，需要一个动态模型，该模型根据当前轴状态（位置、速度和加速度）计算这些值。本示例包括以下部分： 第 1 部分展示了如何在应用程序中使用现有的动态模型以及一些示例运动的结果。 第 2 部分展示了如何根据 KM Lynch 和 FC Park 所著的《现代机器人》一书中提出的算法为 SCARA 机器人创建动态模型。 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4640407923376033369958289569", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 动态机器人模型 \/ 应用程序的结构 ", 
"snippet" : "第 1 部分：在应用程序中使用动态模型 此部分的代码位于 TorqueLimitationDemo 文件夹。 PLC_PRG 是主程序，其中包含触发测试动作的状态机。 可以使用以下方式监控运动 Trace 。 第 2 部分：创建动态机器人模型 动态模型的代码位于 DynModel 文件夹。 DynModel_Scara2_Z 是SCARA机器人的动力学模型。 DynModel_Tests 运行所有测试 Test_DynModel_Scara2_Z 检查常见错误。 动力学模型基于具有两个旋转关节和一个棱柱 Z 轴的 SCARA 机器人。具有动态模型所需尺寸和坐标系的机器人图如下所示： 图中尺寸 ...", 
"body" : "第 1 部分：在应用程序中使用动态模型 此部分的代码位于 TorqueLimitationDemo 文件夹。 PLC_PRG 是主程序，其中包含触发测试动作的状态机。 可以使用以下方式监控运动 Trace 。 第 2 部分：创建动态机器人模型 动态模型的代码位于 DynModel 文件夹。 DynModel_Scara2_Z 是SCARA机器人的动力学模型。 DynModel_Tests 运行所有测试 Test_DynModel_Scara2_Z 检查常见错误。 动力学模型基于具有两个旋转关节和一个棱柱 Z 轴的 SCARA 机器人。具有动态模型所需尺寸和坐标系的机器人图如下所示： 图中尺寸 功能块DynModel_Scara2_Z中样例工程中对应的变量名 h0 baseHeight h1 armOneHeight h2 armTwoHeight h3 zAxisLength h4 zAxisOffset l1 armOneLength l1 armTwoLength " }, 
{ "title" : "第 1 部分：在应用程序中使用动态模型 ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4592064830952033369979173999", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 动态机器人模型 \/ 第 1 部分：在应用程序中使用动态模型 ", 
"snippet" : "在应用程序中使用动态模型需要一个模型来实现 ISMDynamics 的界面 SM3_Dynamics 图书馆。动态模型来自 第 2 部分：创建动态机器人模型 用于此演示。 可以使用将模型分配给轴组 SMC_GroupSetDynamics .此步骤需要设置相对于 MCS 的重力加速度。因为本例中的 SCARA 安装在地板上，所以重力加速度指向正 z0 方向。重力加速度必须以用户单位 u\/s² 指定。由于此示例中的所有长度均以用户单位 m 定义，因此重力加速度也必须以 m\/s² 为单位指定。 SMC_ChangeDynamicLimits 可用于调整每个轴的限制。请注意，必须使用再次启用轴组 M...", 
"body" : "在应用程序中使用动态模型需要一个模型来实现 ISMDynamics 的界面 SM3_Dynamics 图书馆。动态模型来自 第 2 部分：创建动态机器人模型 用于此演示。 可以使用将模型分配给轴组 SMC_GroupSetDynamics .此步骤需要设置相对于 MCS 的重力加速度。因为本例中的 SCARA 安装在地板上，所以重力加速度指向正 z0 方向。重力加速度必须以用户单位 u\/s² 指定。由于此示例中的所有长度均以用户单位 m 定义，因此重力加速度也必须以 m\/s² 为单位指定。 SMC_ChangeDynamicLimits 可用于调整每个轴的限制。请注意，必须使用再次启用轴组 MC_GroupEnable 为了激活新的动态限制。 如果向 TCP 添加额外的质量（例如，机器人拾取的工具或物体），则 SMC_GroupSetLoad 可用于定义负载。 这 PLC_PRG 程序包含上述所有组件并执行两个测试动作： 运动 1 运动 2 从 (a0=0°, a1=0°, a2=0 m) 到 (a0=90°, a1=0°, a2=0,02 m) 的直臂运动： 从 (a0=0°, a1=-120°, a2=0 m) 到 (a0=90°, a1=-120°, a2=0,02 m) 的角度臂运动： 每个运动连续执行三次，边界条件如下： 所有轴的扭矩限制是无限的（unlimited）。 第 2 臂的扭矩限制设置为低于无限移动期间达到的最大扭矩的值。该值被任意设置为 2 Nm . Arm 2 的扭矩限制仍然是 2 Nm ，另外在 TCP 处施加了负载（ mLoad=3 kg , lLoad=0.2 m ): 使用细杆简化了负载的惯量计算： 可以在轨迹中监控运动。运动 1 具有以下结果： 即使在运动 1 期间手臂 2 不移动，手臂 1 的运动也会在加速\/减速期间为手臂 2 产生扭矩。计算出的扭矩被发送到驱动器，并可能改进控制器模式下的控制器回路 SMC_velocity 或者 SMC_position .这也称为转矩前馈控制。 以有限扭矩进行的第二次运行表明，即使 Arm 2 不移动，Arm 2 的扭矩限制也会减慢 Arm 1 的运动。如果没有动态模型，则必须手动减少 Arm 1 的加速度和减速度运动，以防止对第 2 臂施加过大的机械应力。 第三次带负载运行会进一步减慢第 1 臂的运动速度，以免违反第 2 臂的扭矩限制。 使用动态模型的优势是显而易见的。在没有动态模型的情况下防止机械应力过大： 要么必须根据机器人的当前状态设置每个运动的动态限制。 或者所有轴的动态限制都必须降低，这样所有潜在的运动都不会导致任何轴上的机械应力过大。 第一种方法是一项复杂的任务，可能很难计算出合理的限制，而第二种方法导致的运动在大多数情况下并不尽可能快。动态模型不再存在这些缺点，因为机器人总是尽可能快地移动，同时仍然遵守每个轴的机械限制。 运动 2 的结果说明了这些优点： 由于倾斜的臂 2，臂 2 产生的扭矩远低于运动 1。因此，所有三个运行都不会受到轴扭矩的限制。如果使用基于运动 1 的调整动态限制（减少加速度和减速度以免违反手臂 2 的扭矩限制），则该运动会比必要的慢。 " }, 
{ "title" : "第 2 部分：创建动态机器人模型 ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4583105024958433369980945572", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 动态机器人模型 \/ 第 2 部分：创建动态机器人模型 ", 
"snippet" : "本例中创建的模型基于 KM Lynch 和 FC Park 合着的“现代机器人”一书中介绍的开链机器人算法（参见第 8 章“开链动力学”）。这个算法的解释超出了这个例子的范围。相反，该示例侧重于如何定义算法的输入值。 简化 为了使这个例子更容易理解，做了一些简化： 臂长 l1 和 l2 （旋转轴之间的距离）用作它们各自的总臂长。 质心始终位于每个连杆的几何中心。 计算细杆的臂和 Z 轴的空间惯性矩阵。 动态模型要求 为了在 SoftMotion 应用程序中使用动态模型，该模型必须实现 ISMDynamics 接口 SM3_Dynamics 图书馆。 动态模型的零位、坐标系、正旋转方向理论上都可...", 
"body" : "本例中创建的模型基于 KM Lynch 和 FC Park 合着的“现代机器人”一书中介绍的开链机器人算法（参见第 8 章“开链动力学”）。这个算法的解释超出了这个例子的范围。相反，该示例侧重于如何定义算法的输入值。 简化 为了使这个例子更容易理解，做了一些简化： 臂长 l1 和 l2 （旋转轴之间的距离）用作它们各自的总臂长。 质心始终位于每个连杆的几何中心。 计算细杆的臂和 Z 轴的空间惯性矩阵。 动态模型要求 为了在 SoftMotion 应用程序中使用动态模型，该模型必须实现 ISMDynamics 接口 SM3_Dynamics 图书馆。 动态模型的零位、坐标系、正旋转方向理论上都可以偏离运动学模型。但是，必须考虑这些差异，并且为了简化动态模型，因此建议使用运动学模型的定义。 由于动态模型必须计算以 Nm 为单位的扭矩值和以 N 为单位的力，因此它必须将长度的用户单位 u 转换为 SI 单位 m。转换因子可以设置为 SMC_GroupSetUnits 并包含在 addParams 输入 ISMDynamics.AxesStateToTorque .此示例仅使用 m 作为长度，因此可以忽略转换因子。 模型的几何和动态数据的规范 KM Lynch 和 FC Park 在“现代机器人”一书中介绍的算法的 IEC 实现（参见第 8 章“开放链动力学”）需要以下输入值： 当机器人处于起始位置时每个连杆的质心位置。该位置在前一个链接的坐标系中指定（第一个链接是相对于基础坐标系指定的）。 每个连杆的空间惯性矩阵和质量，以各自的连杆框架表示。 各关节的螺丝轴，以基架表示。 质心位置 各连杆质心位置的框架如下： 关联 框架 手臂 1 手臂 1 的质心，以基本坐标系 x 表示 0 , 是 0 , z 0 : 请注意，绕 x0 轴旋转了 180°。 手臂 2 Arm 2 的质心，在 Arm 1 的坐标系中表示： Z轴 在 Arm 2 的坐标系中表示的 Z 轴质心： 工具中心点 (TCP) 一个额外的框架来处理 TCP 处的任意负载（例如，通过工具、产品或两者的组合），以 Z 轴的坐标系表示： 空间惯性矩阵 空间惯性值必须在相应的链接框架中表示。由于框架定义在质心，空间惯性可以用 3x3 旋转惯性矩阵和物体的质量来表示。 通过使用细杆作为关节进行简化，转动惯量矩阵的分量如下： 关联 空间惯性矩阵 第 1 臂，第 2 臂 手臂 1 和手臂 2 及其相应的质量 m1 和 m2 , 和长度 l1 和 l2 : Z轴 螺旋轴 所有关节的螺旋轴必须相对于基本坐标系 x 表示 0 , 是 0 , z 0 . 关联 螺杆轴 手臂 1 想象一个转盘以 1 rad\/s 的角速度沿正方向围绕关节 1 旋转。 在基础坐标系中表示，这是围绕z的正向旋转 0 -轴根据右手法则： 因为Arm 1的旋转轴等于基础坐标系的中心，所以线速度为零： 手臂 2 同样，想象一个转盘以 1 rad\/s 的角速度正向围绕关节 2 旋转，如下图所示，它显示在机械臂 1 的顶视图中： 对于 Arm 1，角速度为： 该图显示了由此产生的线速度 v 2,y , 指向负 y 0 方向并且等于 v 2,y =-ω 2,z * l 1个 . Z轴 Z 轴是棱柱轴，适用以下规则： 角速度矢量 ω 为零。 线速度矢量是正平移方向上的单位矢量。 这导致以下向量，以基本坐标系 x 表示 0 , 是 0 , z 0 : 测试 现在可以测试动态模型，因为所有模型参数都已定义。本节包括模型的一些基本测试。 检查丝杠轴 螺杆轴 S 具有角速度 ω 和线速度 v 可以表示为一个元素 se(3) : 正向转型 T 可以用螺旋轴执行 S , 末端执行器框架 M 对于机器人的零位置，以及关节角度 θ 每个关节： 示例项目已经包含一个求解该方程的函数（请参阅 SMC_OpenChainKinematics_SolveForward ).有关详细信息，请参阅 KM Lynch 和 FC Park 合着的《现代机器人》一书。 使用正向变换方程，现在可以使用已知轴位置运行测试并检查变换是否导致预期结果。 检查静止时的扭矩计算 要检查质心位置框架，您可以手动计算给定轴位置的静止轴扭矩，并将其与模型计算的值进行比较。由于此示例基于安装在地板上的 SCARA 机器人，因此所有静止轴位置都将导致相同的驱动器扭矩或力： 联合的 产生的扭矩\/力 手臂 1 因为 Arm 1 是旋转轴，所以结果是扭矩： M1=0 Nm . 手臂 2 因为 Arm 2 是旋转轴，所以结果是扭矩： M2=0 Nm . Z轴 因为 Z 轴是棱柱轴，所以结果是一个力： F3=m3*g N 重力加速度 g . " }, 
{ "title" : "自定义运动学 ", 
"url" : "_sm_example_custom_robotics_kinematic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 自定义运动学 ", 
"snippet" : "见 PLCopenSingle2.project 示例项目和 CustomKinematics.library 安装目录下的库 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples. 此示例描述如何使用自定义运动学变换创建库 ( Gantry3C ）以及如何在项目中使用这个库来控制机器人。 这个 Gantry3C 运动学变换由 3 个带有刀头的线性轴（X、Y 和 Z）组成。刀头由一个额外的轴组成，该轴可承载已安装的刀具。刀头可以绕 Z 轴旋转...", 
"body" : "见 PLCopenSingle2.project 示例项目和 CustomKinematics.library 安装目录下的库 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples. 此示例描述如何使用自定义运动学变换创建库 ( Gantry3C ）以及如何在项目中使用这个库来控制机器人。 这个 Gantry3C 运动学变换由 3 个带有刀头的线性轴（X、Y 和 Z）组成。刀头由一个额外的轴组成，该轴可承载已安装的刀具。刀头可以绕 Z 轴旋转 " }, 
{ "title" : "1.新建一个库项目 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3b0657d06b6990f1c0a8646379b25f1e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 自定义运动学 \/ 1.新建一个库项目 ", 
"snippet" : "创建一个新项目 空库 模板。...", 
"body" : "创建一个新项目 空库 模板。 " }, 
{ "title" : "2. 添加库管理器。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_0125d98b6b6990f1c0a8646339c29917", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 自定义运动学 \/ 2. 添加库管理器。 ", 
"snippet" : "将库管理器添加到 点检装置 视图。添加 SM3_Transformation ， SM3_Math ， 和 SM3_Error 库到库管理器。...", 
"body" : "将库管理器添加到 点检装置 视图。添加 SM3_Transformation ， SM3_Math ， 和 SM3_Error 库到库管理器。 " }, 
{ "title" : "3. 创建 Gantry3C 功能块。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_b156dbec6b6990f1c0a86463322b661a", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 自定义运动学 \/ 3. 创建 Gantry3C 功能块。 ", 
"snippet" : "该功能块实现了接口 MC_KIN_REF_SM3 和 ISMKinematicsWithInfo2 从图书馆 SM3_Transformation .您可以定义一个偏移量作为每个轴的输入。该偏移量在前向变换前减去，在逆向变换后加上。 示例 Gantry3C 具有两个解耦运动学和 KinCoupled ： FUNCTION_BLOCK Custom_Kin_Gantry3 IMPLEMENTS ISMPositionKinematics FUNCTION_BLOCK Custom_Kin_CAxis IMPLEMENTS ISMOrientationKinematics FUNCTION_BLO...", 
"body" : "该功能块实现了接口 MC_KIN_REF_SM3 和 ISMKinematicsWithInfo2 从图书馆 SM3_Transformation .您可以定义一个偏移量作为每个轴的输入。该偏移量在前向变换前减去，在逆向变换后加上。 示例 Gantry3C 具有两个解耦运动学和 KinCoupled ： FUNCTION_BLOCK Custom_Kin_Gantry3 IMPLEMENTS ISMPositionKinematics\nFUNCTION_BLOCK Custom_Kin_CAxis IMPLEMENTS ISMOrientationKinematics\n\nFUNCTION_BLOCK Custom_Kin_Gantry3C EXTENDS Kin_Coupled 提供功能块 Custom_Kin_Gantry3 和 Custom_Kin_CAxis 作为功能块的输入 Kin_Coupled 在初始化期间。现在 Custom_Kin_Gantry3C 成为结合位置和方向运动学的耦合运动学。 " }, 
{ "title" : "4. 实现 MC_KIN_REF_SM3 接口和 NumAxes4 属性的方法。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_f0953a666b6990f1c0a864632a54ddd5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 自定义运动学 \/ 4. 实现 MC_KIN_REF_SM3 接口和 NumAxes4 属性的方法。 ", 
"snippet" : "AxesToCartesian ：正向运动学：根据轴值计算位置和方向。 CartesianToAxes ：反向运动学：根据位置和方向计算轴值。 NumAxes : 运动系统的轴数...", 
"body" : "AxesToCartesian ：正向运动学：根据轴值计算位置和方向。 CartesianToAxes ：反向运动学：根据位置和方向计算轴值。 NumAxes : 运动系统的轴数 " }, 
{ "title" : "5、实现ISMKinematicsWithInfo2和ISMKinematicsWithInfo接口的方法。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_cd5f17f76b6990f1c0a86463705dcfa1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 自定义运动学 \/ 5、实现ISMKinematicsWithInfo2和ISMKinematicsWithInfo接口的方法。 ", 
"snippet" : "GetAxisProperties : 属性，例如轴的类型。可以定义每个轴的限制。 GetKinematicsName : 运动学名称 IsSingularity : 可以忽略此运动学...", 
"body" : "GetAxisProperties : 属性，例如轴的类型。可以定义每个轴的限制。 GetKinematicsName : 运动学名称 IsSingularity : 可以忽略此运动学 " }, 
{ "title" : "6. 指定项目信息。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_2f5ca72b6b6990f1c0a864634f9c8dd7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 自定义运动学 \/ 6. 指定项目信息。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "7. 检查库中是否有编译器错误。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_24eaad936b6990f1c0a864633896924b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 自定义运动学 \/ 7. 检查库中是否有编译器错误。 ", 
"snippet" : "要检查库，请单击 建造 → 检查所有池对象 。...", 
"body" : "要检查库，请单击 建造 → 检查所有池对象 。 " }, 
{ "title" : "8. 在轴组配置器中创建描述。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_51fd948a6c11885ac0a8646354b16b84", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 自定义运动学 \/ 8. 在轴组配置器中创建描述。 ", 
"snippet" : "要创建描述，您首先需要安装 CODESYS Library Documentation Support 附加组件。此插件包含以下说明中必需的 libdoc.exe 程序。 该插件可以通过以下方式安装 CODESYS Installer 。 当 POU 具有属性时 sm_kin_libdoc ，功能块中指定的注释在轴组配置器中用作运动学的描述。为此使用重组的文本格式。 要从轴组编辑器中的功能块注释生成运动学描述，请按以下步骤操作： 包含属性 sm_kin_libdoc 如上图所示。 包括所需的项目属性 文档格式 和 文档语言 （在项目信息对话框中）与库文档相关。 结果： 确保安装目录 CODES...", 
"body" : "要创建描述，您首先需要安装 CODESYS Library Documentation Support 附加组件。此插件包含以下说明中必需的 libdoc.exe 程序。 该插件可以通过以下方式安装 CODESYS Installer 。 当 POU 具有属性时 sm_kin_libdoc ，功能块中指定的注释在轴组配置器中用作运动学的描述。为此使用重组的文本格式。 要从轴组编辑器中的功能块注释生成运动学描述，请按以下步骤操作： 包含属性 sm_kin_libdoc 如上图所示。 包括所需的项目属性 文档格式 和 文档语言 （在项目信息对话框中）与库文档相关。 结果： 确保安装目录 CODESYS 包含 libdoc.exe 可执行文件（目录： ...\\DocScripting\\3.5.xx.0 \\)。 从 0.12.5 或更低版本下载 32 位 wkhtmltox 转换器 https:\/\/wkhtmltopdf.org\/downloads.html .提取 wkhtmltox.dll 文件并将其复制到 ...\\DocScripting\\3.5.xx.0\\bin 在里面 CODESYS 安装目录。 自从 wkhtmltox.dll 0.12.6 及更高版本默认不再支持图像，您必须使用 0.12.5 或更低版本。 创建系统变量 LIBDOC_CODESYS 在 Windows 中。将值设置为文件路径 CODESYS.exe .确保在双引号中指定路径名和配置文件名。 结果： 保存、关闭并重新打开库项目。 点击 文件 → 将项目另存为编译库 . 编译后的库将安装到使用此运动学的项目中。 " }, 
{ "title" : "在项目中使用库 (CustomKinematics_Implementation.project) ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3c747e2a6b6990f1c0a864637a72fb84", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 自定义运动学 \/ 在项目中使用库 (CustomKinematics_Implementation.project) ", 
"snippet" : "该项目演示了如何通过慢跑或命令运动来使用和控制上一节中创建的运动学。 创建一个 CODESYS 标准项目与 CODESYS SoftMotion Win 控制器。 打开库管理器并安装库 CustomKinematics.compiled-library （在上一节中创建）包含运动学 Gantry3C。将库添加到库管理器。 添加轴组对象并选择 KinCustom.Gantry3C 运动学。 结果： 将 4 个虚拟轴添加到 SoftMotion 通用轴池 设备树中的轴池。 （DriveX、Y、Z 和 C） 打开轴组配置器。在里面 映射到轴 部分，将轴映射到它们各自的字段。 结果： 该程序 Prg_...", 
"body" : "该项目演示了如何通过慢跑或命令运动来使用和控制上一节中创建的运动学。 创建一个 CODESYS 标准项目与 CODESYS SoftMotion Win 控制器。 打开库管理器并安装库 CustomKinematics.compiled-library （在上一节中创建）包含运动学 Gantry3C。将库添加到库管理器。 添加轴组对象并选择 KinCustom.Gantry3C 运动学。 结果： 将 4 个虚拟轴添加到 SoftMotion 通用轴池 设备树中的轴池。 （DriveX、Y、Z 和 C） 打开轴组配置器。在里面 映射到轴 部分，将轴映射到它们各自的字段。 结果： 该程序 Prg_Visu 是控制轴组的主程序。当应用程序启动时， Prg_Visu 启动轴组并启用它。此外，它调用所有必要的功能块来控制轴组（点动、线性和 PTP 运动）。所有这些运动都可以通过附加的可视化进行控制。 结果： 功能块： Jog ：此 FB 结合了轴空间和笛卡尔空间中的点动。它使用两个实例 SMC_GroupJog2 。一个用于轴空间，另一个用于笛卡尔空间。此功能块可与可视化模板一起使用 V_RobotPosition_axes 和 V_机器人位置_cart_Jog 在笛卡尔和轴空间中点动任何运动。 结果： FB SMC_TRAFOF_Gantry3C ：此功能块将 Gantry3C 运动学的输入轴值转换为其各自的 TCP 值。此外，轴值已标准化，以便它们可以与可视化模板一起使用 TRAFOF_Gantry3C_YZ 以可视化运动学的运动。 结果： 编译并运行应用程序。打开可视化。您可以在轴空间和笛卡尔空间中点动机器人。还有可视化模板来命令线性或 PTP 运动。 结果： 此处描述的示例讨论了公共功能块中的定位轴和定向轴。许多运动学可以包括两种分离的部分运动学：一种定位运动学（三角架、龙门架等）和一种定向运动学（C 轴、Wrist2、Wrist3 等工具）。两个运动系统在“法兰点”，即定位运动系统的 TCP 处相互连接。定向运动学的特点在于它能够计算从法兰点到耦合运动学 TCP 的矢量。计算仅使用该 TCP 的方向（意味着它独立于定位运动学或独立于法兰点的方向）。反过来，定位运动必须能够仅从法兰点的位置确定其轴位置。它不能取决于法兰点的方向。 在这种情况下，你可以使用如下接口 ISMPositionKinematics 或者 ISMOrientationKinematics 。为了实现这些接口，定义一个功能块来实现 ISMPositionKinematics 以及另一个要实现的功能块 ISMOrientationKinematics .最后定义一个扩展功能块的功能块 Kin_Coupled （从 SM3_Transformation ) 以先前定义的功能块作为输入。 有关更多信息，请参阅： 创建自定义运动学" }, 
{ "title" : "使用 Depictor 可视化轴组 ", 
"url" : "_sm_example_axis_group_depictor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 使用 Depictor 可视化轴组 ", 
"snippet" : "对于这个项目，你还需要 CODESYS Depictor 具有有效许可证的附加组件。 SoftMotion 应用程序由配置为轴组的四个旋转驱动器组成。前三个轴在 X\/Y 平面中移动 TCP，第四个轴在 Z 平面中移动。 该示例演示了如何将 Depictor 与 Kin_Scara3_Z 运动学配置结合使用。您还可以为其他运动学配置自定义相同的程序。 启动和测试程序 您可以在项目的可视化中修改轴值。如果您注释掉活动的移动命令 ( MoveAbs... , ...) 在程序中 PLC_PRG 并去掉第二条移动命令的注释，就可以修改笛卡尔坐标了。 构建项目并将其下载到 PLC。 在您的项目中打开 D...", 
"body" : "对于这个项目，你还需要 CODESYS Depictor 具有有效许可证的附加组件。 SoftMotion 应用程序由配置为轴组的四个旋转驱动器组成。前三个轴在 X\/Y 平面中移动 TCP，第四个轴在 Z 平面中移动。 该示例演示了如何将 Depictor 与 Kin_Scara3_Z 运动学配置结合使用。您还可以为其他运动学配置自定义相同的程序。 启动和测试程序 您可以在项目的可视化中修改轴值。如果您注释掉活动的移动命令 ( MoveAbs... , ...) 在程序中 PLC_PRG 并去掉第二条移动命令的注释，就可以修改笛卡尔坐标了。 构建项目并将其下载到 PLC。 在您的项目中打开 Depictor 对象的编辑器。 切换到可视化并修改轴值或笛卡尔值。在 Depictor 中观察 SCARA 机器人的运动。 " }, 
{ "title" : "创建标准项目 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a87f67372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 使用 Depictor 可视化轴组 \/ 创建标准项目 ", 
"snippet" : "创建一个标准项目 CODESYS SoftMotion Win 控制器和 ST 编程语言。 在中添加库管理器 POU 看法。 打开库管理器并添加库 SM3_Depictor 和 DepictorBase ....", 
"body" : "创建一个标准项目 CODESYS SoftMotion Win 控制器和 ST 编程语言。 在中添加库管理器 POU 看法。 打开库管理器并添加库 SM3_Depictor 和 DepictorBase . " }, 
{ "title" : "添加和参数化轴 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a65c81372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 使用 Depictor 可视化轴组 \/ 添加和参数化轴 ", 
"snippet" : "在对象下方插入四个虚拟轴 SoftMotion 通用轴池 并将轴命名为 Drive1...Drive4。 将轴 Drive1、Drive2、Drive3 和 Drive4 参数化为轴类型 有限 软件端从-180度切换到180度。 配置编辑器： 有关更多信息，请参阅： 虚拟驱动器...", 
"body" : "在对象下方插入四个虚拟轴 SoftMotion 通用轴池 并将轴命名为 Drive1...Drive4。 将轴 Drive1、Drive2、Drive3 和 Drive4 参数化为轴类型 有限 软件端从-180度切换到180度。 配置编辑器： 有关更多信息，请参阅： 虚拟驱动器" }, 
{ "title" : "配置轴组 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5e750372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 使用 Depictor 可视化轴组 \/ 配置轴组 ", 
"snippet" : "在应用程序下方添加一个“KinScara”轴组。为此，请单击 项目 → 添加对象 → 轴组 . 在配置器中，单击 选择运动学 .选择 TRAFO.Kin_Scara3_Z 运动学。 定义参数如下： d臂长1 , d臂长2 , d臂长3 : 500 偏移量A1 , 偏移量A2 , 偏移量A3 , 偏移量Z : 0 按如下方式对轴进行排序： A1 : 驱动器 1 A2 : 驱动器 2 A3 : 驱动器 3 Z : 驱动器 4 注意：您可以将轴直接拖到输入字段中。 有关详细信息，请参阅: 运动学...", 
"body" : "在应用程序下方添加一个“KinScara”轴组。为此，请单击 项目 → 添加对象 → 轴组 . 在配置器中，单击 选择运动学 .选择 TRAFO.Kin_Scara3_Z 运动学。 定义参数如下： d臂长1 , d臂长2 , d臂长3 : 500 偏移量A1 , 偏移量A2 , 偏移量A3 , 偏移量Z : 0 按如下方式对轴进行排序： A1 : 驱动器 1 A2 : 驱动器 2 A3 : 驱动器 3 Z : 驱动器 4 注意：您可以将轴直接拖到输入字段中。 有关详细信息，请参阅: 运动学" }, 
{ "title" : "创建控制器程序 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_26c321018be5c522c0a864636ae45467", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 使用 Depictor 可视化轴组 \/ 创建控制器程序 ", 
"snippet" : "在里面 PLC_PRG 程序，声明实例 MC_Power 所有驱动器的功能块。创建一个 istate 状态图的变量。 VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power; istate: INT; END_VAR 在实现中定义一个状态图。 CASE istate OF 0: 1: 2: END_CASE 激活状态下的所有驱动器 0 . 0: Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE); Pow...", 
"body" : "在里面 PLC_PRG 程序，声明实例 MC_Power 所有驱动器的功能块。创建一个 istate 状态图的变量。 VAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power;\n istate: INT;\nEND_VAR 在实现中定义一个状态图。 CASE istate OF\n 0:\n 1:\n 2:\nEND_CASE 激活状态下的所有驱动器 0 . 0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF 当轴被激活时，启用轴组（从“停用”切换到“待机”）。 VAR\n GroupEnable:MC_GroupEnable;\nEND_VAR\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF 声明并初始化一个变量以保存机器坐标中的设定值。声明两个类型的实例 SMC_POS_REF 以笛卡尔坐标和轴坐标表示 TCP。 VAR\n Frame: MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart: SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis: SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\nEND_VAR\nVAR CONSTANT\n axispos: TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR\n\n2:\n Pos_Cart.c:= Frame; \/\/ To represent the TCP in cartesian coordinates; 声明一个实例 MC_MoveDirectAbsolute 将 SCARA 机器人移动到指定坐标。 VAR\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates\nEND_VAR\n\n2:\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined Axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF 声明一个类型的变量 SMC_GroupReadSetPosition 以直角坐标和轴坐标读取机器人的当前值。 VAR\n Car_pos, Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current axis values\nEND_VAR\n\n2:\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ to read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ to read the current axis values " }, 
{ "title" : "整个PLC_PRG程序 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5721f372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 使用 Depictor 可视化轴组 \/ 整个PLC_PRG程序 ", 
"snippet" : "比较您的程序并添加缺少的程序部分。 宣言 PROGRAM PLC_PRG VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power; istate: INT; GroupEnable:MC_GroupEnable; Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP Pos_Cart:SMC_POS_REF; \/\/ This variable re...", 
"body" : "比较您的程序并添加缺少的程序部分。 宣言 PROGRAM PLC_PRG\nVAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power;\n istate: INT;\n\n GroupEnable:MC_GroupEnable;\n\n Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart:SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis:SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\n\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates (PTP)\n\n Car_pos,Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current position of the TCP in Cartesian and Axis Coordinates and display it on the visu\n\n scara_Config:trafo.Kin_Scara3_Z_Config; \/\/ To set the configuration of the SCARA_3_Z\n kin_Config:SMC_SetKinConfiguration; \/\/ To set the defined configuration of SCARA_3_Z to the axis group used\n nPeriod:DINT:=0; \/\/ SCARA_3_Z Period\n Xelbow:BOOL:=TRUE;\n\nEND_VAR\nVAR CONSTANT\n axispos : TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR 执行 CASE istate OF\n\n0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF\n\n2:\n scara_Config(xElbowRight:=Xelbow, nPeriodA3:=nPeriod);\n kin_Config(AxisGroup:=KinScara,ConfigData:=scara_Config.Config, Execute:=TRUE);\n Pos_Cart.c:=Frame; \/\/ To represent the TCP in cartesian coordinates\n\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ read the current position in Axis coordinates\n\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF\nEND_CASE " }, 
{ "title" : "创建一个Depictor程序 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_8f044cf9373811e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 使用 Depictor 可视化轴组 \/ 创建一个Depictor程序 ", 
"snippet" : "在应用程序下方添加一个新的“程序”类型的“Depic”POU。为此，请单击 项目 → 添加对象 → POU . 声明一个类型的变量 SM3_Depictor.SMC_R_Scara3_Z_Data .声明一个变量 LrSize 类型 LREAL 并将变量初始化为 100。 VAR ScaraTrafo : SM3_Depictor.SMC_R_Scara3_Z_Data; LrSize:LREAL:=100; END_VAR 在实现中插入对功能块的调用。 ScaraTrafo(AxisGroup:=KinScara, trf:=KinScara.trafo); 将“Depic” POU 添加到...", 
"body" : "在应用程序下方添加一个新的“程序”类型的“Depic”POU。为此，请单击 项目 → 添加对象 → POU . 声明一个类型的变量 SM3_Depictor.SMC_R_Scara3_Z_Data .声明一个变量 LrSize 类型 LREAL 并将变量初始化为 100。 VAR\n ScaraTrafo : SM3_Depictor.SMC_R_Scara3_Z_Data;\n LrSize:LREAL:=100;\nEND_VAR 在实现中插入对功能块的调用。 ScaraTrafo(AxisGroup:=KinScara, trf:=KinScara.trafo); 将“Depic” POU 添加到 主要任务 . " }, 
{ "title" : "配置描述符 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a523fe372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 使用 Depictor 可视化轴组 \/ 配置描述符 ", 
"snippet" : "在应用程序下方添加一个“Depictor”对象。为此，请单击 项目 → 添加对象 → 描绘器 . 双击对象。 选择 姿势 Depictor 树中的元素。 点击 描绘器 → 添加元素 . 这 盒子 元素添加在姿势下方。 选择 插图参考。 元素属性中的选项。 点击 按钮。 选择 SMC_R_Depictor_Scara3_Z 从对象 SM3_Depictor 图书馆。 定义接口变量如下： 脸书 : Depic.ScaraTrafo lrZ_ : Drive1.fSetPosition 最小 : 10 最大 ：-50 大小 ：Depic.LrSize 显示平面 : 0...", 
"body" : "在应用程序下方添加一个“Depictor”对象。为此，请单击 项目 → 添加对象 → 描绘器 . 双击对象。 选择 姿势 Depictor 树中的元素。 点击 描绘器 → 添加元素 . 这 盒子 元素添加在姿势下方。 选择 插图参考。 元素属性中的选项。 点击 按钮。 选择 SMC_R_Depictor_Scara3_Z 从对象 SM3_Depictor 图书馆。 定义接口变量如下： 脸书 : Depic.ScaraTrafo lrZ_ : Drive1.fSetPosition 最小 : 10 最大 ：-50 大小 ：Depic.LrSize 显示平面 : 0 " }, 
{ "title" : "创建可视化 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a460ad372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 使用 Depictor 可视化轴组 \/ 创建可视化 ", 
"snippet" : "创建一个可视化屏幕，在其中可以显示和修改笛卡尔坐标和轴坐标。 在应用程序下方添加一个“可视化”对象。为此，请单击 项目 → 添加对象 → 可视化 . 在编辑器中打开可视化。 插入一个 长方形 可视化元素 (1)。 更改元素的属性。 文本 → 文本 : %s 文本变量 → 文本变量 ： PLC_PRG.Car_pos.Position.c.X 输入配置 → OnMouseDown → 写入变量 输入类型 ： VisuDialogs.Numpad 使用另一个变量 ： PLC_PRG.Frame.X 插入另一个 盒子 可视化元素。 更改元素 (2) 和 (3) 的属性。 文本 → 文本 : %s 文...", 
"body" : "创建一个可视化屏幕，在其中可以显示和修改笛卡尔坐标和轴坐标。 在应用程序下方添加一个“可视化”对象。为此，请单击 项目 → 添加对象 → 可视化 . 在编辑器中打开可视化。 插入一个 长方形 可视化元素 (1)。 更改元素的属性。 文本 → 文本 : %s 文本变量 → 文本变量 ： PLC_PRG.Car_pos.Position.c.X 输入配置 → OnMouseDown → 写入变量 输入类型 ： VisuDialogs.Numpad 使用另一个变量 ： PLC_PRG.Frame.X 插入另一个 盒子 可视化元素。 更改元素 (2) 和 (3) 的属性。 文本 → 文本 : %s 文本变量 → 文本变量 ： PLC_PRG.Car_pos.Position.c.Y 或者 PLC_PRG.Car_pos.Position.c.Z 输入配置 → OnMouseDown → 写入变量 输入类型 ： VisuDialogs.Numpad 使用另一个变量 ： PLC_PRG.Frame.Y 和 PLC_PRG.Frame.Z 更改元素 (4)、(5) 和 (6) 的属性。 文本 → 文本 : %s 文本变量 → 文本变量 ： PLC_PRG.Frame.A 或者 PLC_PRG.Frame.B 或者 PLC_PRG.Frame.C 更改元素 (7)、(8)、(9) 和 (10) 的属性。 文本 → 文本 : %s 文本变量 → 文本变量 ： PLC_PRG.Axis_pos.Position.a.a0 或者 PLC_PRG.Axis_pos.Position.a.a1 或者 PLC_PRG.Axis_pos.Position.a.a2 或者 PLC_PRG.Axis_pos.Position.a.a3 输入配置 → OnMouseDown → 写入变量 输入类型 ： VisuDialogs.Numpad 使用另一个变量 ： PLC_PRG.Pos_Axis.a.a0 和 PLC_PRG.Pos_Axis.a.a1 和 PLC_PRG.Pos_Axis.a.a2 和 PLC_PRG.Pos_Axis.a.a3 使用以下标签标记可视化元素 标签 元素。 " }, 
{ "title" : "触发器示例 1：简单示例 ", 
"url" : "_sm_example_digital_switches1.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 触发器示例 1：简单示例 ", 
"snippet" : "这 Robotics_Trigger.project 这里描述的示例项目位于安装目录中 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 触发器用于准确找出轴组何时到达命令路径上的特定点。例如，该信息可用于在正确的时间打开或关闭工具。此示例显示如何在运动中发出单个触发器命令，然后循环读取。在此基础上， 触发示例2：涂胶过程 项目展示了一个真实的示例应用程序。...", 
"body" : "这 Robotics_Trigger.project 这里描述的示例项目位于安装目录中 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 触发器用于准确找出轴组何时到达命令路径上的特定点。例如，该信息可用于在正确的时间打开或关闭工具。此示例显示如何在运动中发出单个触发器命令，然后循环读取。在此基础上， 触发示例2：涂胶过程 项目展示了一个真实的示例应用程序。 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_example_digital_switches1.html#UUID-69fc12d0-622f-ba4d-33ec-32604b337f95_section-idm4609369968113633803655575311", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 触发器示例 1：简单示例 \/ 应用程序的结构 ", 
"snippet" : "该应用程序由两个程序组成： Main_PRG 在公交车上运行的任务和 Planning_PRG 在轴组规划任务中运行。此外，还有一个跟踪。 主_PRG ： 这 Main_PRG 程序包含应用程序的主状态机。前两个状态用于初始化和打开驱动器和轴组。在里面 STATE_COMMAND_MOVEMENT_WITH_TRIGGER 状态，首先使用来自的实例准备触发器 SMC_GroupPrepareTrigger 功能块。位置相对指定为0.6。结果，触发器被放置在指定移动完成 60% 的位置。准备好的触发器被分配给下一个命令的运动。在此示例中，到位置 (X=20, Y=10) 的线性移动由 MC_Mo...", 
"body" : "该应用程序由两个程序组成： Main_PRG 在公交车上运行的任务和 Planning_PRG 在轴组规划任务中运行。此外，还有一个跟踪。 主_PRG ： 这 Main_PRG 程序包含应用程序的主状态机。前两个状态用于初始化和打开驱动器和轴组。在里面 STATE_COMMAND_MOVEMENT_WITH_TRIGGER 状态，首先使用来自的实例准备触发器 SMC_GroupPrepareTrigger 功能块。位置相对指定为0.6。结果，触发器被放置在指定移动完成 60% 的位置。准备好的触发器被分配给下一个命令的运动。在此示例中，到位置 (X=20, Y=10) 的线性移动由 MC_MoveLinearAbsolute 。 prepTrigger.PositionType := SMC_TriggerPositionType.MvtRelative;\nprepTrigger.Position.MvtPosition := 0.6;\nprepTrigger(AxisGroup:= AxisGroup, Execute:= TRUE);\n \nmoveLinear(AxisGroup:= AxisGroup, Execute:= prepTrigger.Prepared); 在下一个状态 STATE_ENABLE_READ_TRIGGER ，一个实例 SMC_GroupReadTrigger 启动以读取命令触发器的状态。与触发器的链接是通过以下方式建立的 TriggerId 由返回 SMC_GroupPrepareTrigger 。 readTrigger.TriggerId := prepTrigger.TriggerId;\nreadTrigger.Enable := TRUE; 在里面 STATE_CHECK_TRIGGER state，最终循环检查触发器的状态。立刻 SMC_GroupReadTrigger 报告 Active 作为状态，可以读取到达触发之前的持续时间。持续时间始终指当前周期的开始。因此，如果持续时间小于循环时间（在本例中为 0.004 秒），则在当前循环中达到触发： IF readTrigger.TriggerInfo.status = SMC_TRIGGER_STATUS.Active THEN\n IF readTrigger.TriggerInfo.triggerTime <= 0.004 THEN\n triggerFired := TRUE;\n ...\n END_IF\nEND_IF 规划_PRG 在里面 Planning_PRG 计划，计划的预测持续时间是通过以下方式配置的 SMC_TuneCPKernel 功能块。这 SMC_GroupReadTrigger 当触发达到预测持续时间时，功能块可以输出。在示例中，预测持续时间设置为 0.1 秒。因此，该国的现状 SMC_GroupReadTrigger 功能块更改为 Active 轴组到达触发前 0.1 秒，并从此开始输出有效持续时间。 tuneCpKernel(AxisGroup:= axisGroup, Execute:= TRUE, fPlanningForecastDuration:= 0.1); 痕迹 跟踪可用于跟踪 SMC_GroupReadTrigger 功能块。 在第一个图中，您可以看到从 (X=0, Y=0) 到 (X=20, Y=10) 执行了一次移动。触发器位于机芯上的相对位置0.6处，即(X=12，Y=6)处。 第二张图显示了该值 triggerTime 输出来自 SMC_GroupReadTrigger 。由于规划的预测持续时间为0.1s，该值会跳至0.1s，然后线性下降，直到在位置（X=12，Y=6）处达到值0。 第三张图显示了值 triggerFired 中设置的变量 STATE_CHECK_TRIGGER 的状态 Main_PRG 一旦轴组距离触发器小于 0.004 秒。 " }, 
{ "title" : "触发示例2：涂胶过程 ", 
"url" : "_sm_example_digital_switches2.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 触发示例2：涂胶过程 ", 
"snippet" : "这 Robotics_Trigger_Advanced.project 这里描述的示例项目位于安装目录中 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 触发器可用于在路径上的特定位置执行操作，例如打开和关闭涂胶喷嘴。 该示例包括以下组件： 配置有保证的轨迹预测 fPlanningForecastDuration 参数来自 SMC_TuneCPKernel 功能块。 不同触发器的命令。这里，使用了所有三种定义路径位置的可用方法（参见 SMC_TriggerPositionType ）。 使用具有时移功能的触发器。示例应用程序包含 TriggerWith...", 
"body" : "这 Robotics_Trigger_Advanced.project 这里描述的示例项目位于安装目录中 CODESYS 在下面 ..\\CODESYS SoftMotion\\Examples 。 触发器可用于在路径上的特定位置执行操作，例如打开和关闭涂胶喷嘴。 该示例包括以下组件： 配置有保证的轨迹预测 fPlanningForecastDuration 参数来自 SMC_TuneCPKernel 功能块。 不同触发器的命令。这里，使用了所有三种定义路径位置的可用方法（参见 SMC_TriggerPositionType ）。 使用具有时移功能的触发器。示例应用程序包含 TriggerWithTimeShift 功能块，它可以通过时间偏移（更早和更晚）对到达路径位置做出反应。 这些组件显示在粘合过程的示例应用程序中。执行下图中红色显示的运动（使用混合）。 触发器已在绿色标记的位置定义： 位置1：到达该位置前0.05秒打开涂胶装置。 位置 1：到达该位置时打开紫外灯。 位置2：到达该位置后，将供胶容器填满。 位置3：关闭涂胶装置，到达该位置前0.05秒停止向供胶容器注胶。 位置 3：到达该位置 1.5 秒后关闭紫外灯 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4589008317470433803801762921", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 触发示例2：涂胶过程 \/ 应用程序的结构 ", 
"snippet" : "该应用程序由以下部分组成。 GlueApplication ：该程序包含示例应用程序，展示如何使用触发器进行粘合过程。 Planning_PRG ：在此程序中，配置了轨迹预测。 TriggerWithTimeShift ：该功能块包含时移触发器的逻辑，并用于 GlueApplication 示例程序。 Trace ：轨迹显示了轴的动态以及各轴的输出 GlueApplication 由触发器切换的程序。...", 
"body" : "该应用程序由以下部分组成。 GlueApplication ：该程序包含示例应用程序，展示如何使用触发器进行粘合过程。 Planning_PRG ：在此程序中，配置了轨迹预测。 TriggerWithTimeShift ：该功能块包含时移触发器的逻辑，并用于 GlueApplication 示例程序。 Trace ：轨迹显示了轴的动态以及各轴的输出 GlueApplication 由触发器切换的程序。 " }, 
{ "title" : "预测的配置 ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4570491496867233803803206327", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 触发示例2：涂胶过程 \/ 预测的配置 ", 
"snippet" : "如果您想在达到触发之前尽早做出反应，例如 0.05 秒之前，那么 fPlanningForecastDuration 来自 SMC_ 的参数 SMC_TuneCPKernel 功能块必须设置为至少 0.05 秒。由于该参数对延迟有直接影响，因此其值不应大于必要的值（请参阅文档 f规划预测持续时间 ）。注意 SMC_TuneCPKernel 必须在 SoftMotion 规划任务。因此，配置不在主程序中执行 GlueApplication ，但在 Planning_PRG 程序。 在此示例应用程序中，需要在到达某个位置之前最早 0.05 秒评估触发器。为此，参数 fPlanningForecas...", 
"body" : "如果您想在达到触发之前尽早做出反应，例如 0.05 秒之前，那么 fPlanningForecastDuration 来自 SMC_ 的参数 SMC_TuneCPKernel 功能块必须设置为至少 0.05 秒。由于该参数对延迟有直接影响，因此其值不应大于必要的值（请参阅文档 f规划预测持续时间 ）。注意 SMC_TuneCPKernel 必须在 SoftMotion 规划任务。因此，配置不在主程序中执行 GlueApplication ，但在 Planning_PRG 程序。 在此示例应用程序中，需要在到达某个位置之前最早 0.05 秒评估触发器。为此，参数 fPlanningForecastDuration =0.05 设置为 Planning_PRG 程序。 " }, 
{ "title" : "功能块：TriggerWithTimeShift ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4609369977958433803803968971", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 触发示例2：涂胶过程 \/ 功能块：TriggerWithTimeShift ", 
"snippet" : "这 TriggerWithTimeShift 功能块提供了使用触发器的简化界面。此外，还可以定义时移，以便触发器可以在到达某个位置（正值）之前以及到达某个位置（负值）之后做出反应。根据应用中所需的时间精度，到达触发的反应可能如下： 所需的时间精度 >= 总线任务周期：在这种情况下， TriggerWithTimeShift.TriggerReachedThisCycle 可以使用输出。 所需时间精度 < 总线任务周期：在这种情况下，准确的剩余时间 TriggerWithTimeShift.TriggerTime 直到达到触发即可使用。 在内部， TriggerWithTimeShift 使用 ...", 
"body" : "这 TriggerWithTimeShift 功能块提供了使用触发器的简化界面。此外，还可以定义时移，以便触发器可以在到达某个位置（正值）之前以及到达某个位置（负值）之后做出反应。根据应用中所需的时间精度，到达触发的反应可能如下： 所需的时间精度 >= 总线任务周期：在这种情况下， TriggerWithTimeShift.TriggerReachedThisCycle 可以使用输出。 所需时间精度 < 总线任务周期：在这种情况下，准确的剩余时间 TriggerWithTimeShift.TriggerTime 直到达到触发即可使用。 在内部， TriggerWithTimeShift 使用 SMC_GroupPrepareTrigger 和 SMC_GroupReadTrigger 功能块。 " }, 
{ "title" : "命令触发器 ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4608844104630433803805051855", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 触发示例2：涂胶过程 \/ 命令触发器 ", 
"snippet" : "在里面 GlueApplication 程序、运动和触发器受到命令。调用顺序对于触发器来说特别重要，因为触发器使用 SMC_GroupPrepareTrigger 被分配给同一循环中命令的下一个运动。因此，在每次应用中都需要注意以下几点： 用于命令触发器的功能块始终在运动功能块之前调用。 触发器和相应的运动始终在同一周期内发出命令。 触发器使用以下所有类型 SMC_TriggerPositionType : 位置 1 处的触发器使用相对距离的定义 ( SMC_TriggerPositionType.MvtRelative ）和位置 0.5。由于相应移动的距离为 10，因此触发器位于 X=5 处...", 
"body" : "在里面 GlueApplication 程序、运动和触发器受到命令。调用顺序对于触发器来说特别重要，因为触发器使用 SMC_GroupPrepareTrigger 被分配给同一循环中命令的下一个运动。因此，在每次应用中都需要注意以下几点： 用于命令触发器的功能块始终在运动功能块之前调用。 触发器和相应的运动始终在同一周期内发出命令。 触发器使用以下所有类型 SMC_TriggerPositionType : 位置 1 处的触发器使用相对距离的定义 ( SMC_TriggerPositionType.MvtRelative ）和位置 0.5。由于相应移动的距离为 10，因此触发器位于 X=5 处。 位置 2 处的触发使用以用户单位 u 表示的距离定义（ SMC_TriggerPositionType.MvtDistance ) 和位置 5。因此，触发器也位于 X=5。 位置 3 处的触发器使用与平面 ( SMC_TriggerPositionType.PlaneIntersection ）。该平面已定义为触发器位于 X=5。 GlueApplication 有 EnableGlue , EnableUVLamp ， 和 RefillGlueStorage 输出。这些在适当的触发器处切换 GlueApplication.EvaluateTriggers() 。可以在跟踪中监视和评估这些输出的运动和状态。 " }, 
{ "title" : "在机器人中使用其他轴 ", 
"url" : "_sm_example_additional_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 在机器人中使用其他轴 ", 
"snippet" : "这个 Robotics_AdditionalAxes.project 示例项目显示了如何在机器人技术中配置和使用其他轴。其他轴是与机器人的协调运动同步移动的 该项目位于的安装目录中 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。...", 
"body" : "这个 Robotics_AdditionalAxes.project 示例项目显示了如何在机器人技术中配置和使用其他轴。其他轴是与机器人的协调运动同步移动的 该项目位于的安装目录中 CODESYS 下面 ..\\CODESYS SoftMotion\\Examples 。 " }, 
{ "title" : "应用程序的结构 ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063293414778", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 在机器人中使用其他轴 \/ 应用程序的结构 ", 
"snippet" : "轴组配置在 AxisGroup 对象。使用了具有 3 个轴（两个旋转轴和一个线性 Z 轴）的 SCARA 机器人 下面还添加了另外两个轴 附加轴 并链接到两个轴 DriveAdd1 和 DriveAdd2 。 这个 PLC_PRG 程序包含一个用于程序流的简单状态机。首先，轴组处于启用状态 0 ，然后是 PTP 向位置移动 (X=50, Y=50) 已执行。然后将其混合成直线运动 (X=50, Y=-50) 。 对于第一次机器人运动，轴的移动会随着距离的增加而相对增加 (10, 20) 被指挥。对于第二次机器人运动，附加轴的距离为 (-10, -20) 。 这个 MC_GroupReadAct...", 
"body" : "轴组配置在 AxisGroup 对象。使用了具有 3 个轴（两个旋转轴和一个线性 Z 轴）的 SCARA 机器人 下面还添加了另外两个轴 附加轴 并链接到两个轴 DriveAdd1 和 DriveAdd2 。 这个 PLC_PRG 程序包含一个用于程序流的简单状态机。首先，轴组处于启用状态 0 ，然后是 PTP 向位置移动 (X=50, Y=50) 已执行。然后将其混合成直线运动 (X=50, Y=-50) 。 对于第一次机器人运动，轴的移动会随着距离的增加而相对增加 (10, 20) 被指挥。对于第二次机器人运动，附加轴的距离为 (-10, -20) 。 这个 MC_GroupReadActualPosition 和 MC_GroupReadActualVelocity 功能块用于读取运动学和其他轴的位置和速度。 " }, 
{ "title" : "调试 ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063296617065", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例子 \/ 在机器人中使用其他轴 \/ 调试 ", 
"snippet" : "生成应用程序并将其下载到控制器。 打开跟踪记录并将其下载到控制器。 启动应用程序。 您可以跟踪 X 和 Y 坐标以及轨迹中另外两个轴的移动。...", 
"body" : "生成应用程序并将其下载到控制器。 打开跟踪记录并将其下载到控制器。 启动应用程序。 您可以跟踪 X 和 Y 坐标以及轨迹中另外两个轴的移动。 " }, 
{ "title" : "用户界面 ", 
"url" : "_sm_robotics_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 用户界面 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：创建计划任务 ", 
"url" : "_sm_cmd_create_planning_task.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 用户界面 \/ 命令：创建计划任务 ", 
"snippet" : "功能 ：该命令会自动创建计划任务。规划 CP 运动（例如，线性运动或圆形运动）需要此任务。 称呼 ： 项目 菜单;轴组的上下文菜单 要求 ：该命令仅在轴组未配置规划任务时可用。...", 
"body" : "功能 ：该命令会自动创建计划任务。规划 CP 运动（例如，线性运动或圆形运动）需要此任务。 称呼 ： 项目 菜单;轴组的上下文菜单 要求 ：该命令仅在轴组未配置规划任务时可用。 " }, 
{ "title" : "轴组编辑器 ", 
"url" : "_sm_obj_axis_group-1018069.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 用户界面 \/ 轴组编辑器 ", 
"snippet" : "象征： 在编辑部 轴组 对象，选择基本运动学类型和方向运动学。只有在基本运动学支持的情况下，才能选择定向运动学。此外，您将运动系统的轴映射到项目中的驱动器。 运动学 选择运动学 改变运动学 打开支持的所有运动学的列表 CODESYS 当您选择一种运动学类型时，列表右侧的框中会显示一个简短的描述。 选择一种运动学类型后，您可以在编辑器中修改相应的参数。 定向运动学 选择运动学 改变运动学 打开支持的所有方向运动的列表 CODESYS 当您选择一种运动学类型时，列表右侧的框中会显示一个简短的描述。 选择一种运动学类型后，您可以在编辑器中修改相应的参数。 轴映射 根据所选的运动系统，您可以将运动系统...", 
"body" : "象征： 在编辑部 轴组 对象，选择基本运动学类型和方向运动学。只有在基本运动学支持的情况下，才能选择定向运动学。此外，您将运动系统的轴映射到项目中的驱动器。 运动学 选择运动学 改变运动学 打开支持的所有运动学的列表 CODESYS 当您选择一种运动学类型时，列表右侧的框中会显示一个简短的描述。 选择一种运动学类型后，您可以在编辑器中修改相应的参数。 定向运动学 选择运动学 改变运动学 打开支持的所有方向运动的列表 CODESYS 当您选择一种运动学类型时，列表右侧的框中会显示一个简短的描述。 选择一种运动学类型后，您可以在编辑器中修改相应的参数。 轴映射 根据所选的运动系统，您可以将运动系统的轴映射到项目中的驱动器。 其他轴 添加轴 为附加轴添加配置字段。该项目的驱动器在此配置字段中输入。 任务 总线循环任务 轴的总线循环任务，如果轴已经被映射 此处无法更改设置。 规划任务 用于规划 CP 任务的任务 插入第一个轴组时会自动创建规划任务。不应配置看门狗，因为执行时间可能会有很大波动。 有关详细信息，请参阅：For more information, see: 规划任务的配置如果删除此任务，则会向消息视图发出错误。要创建新任务，请单击 项目 → 创建计划任务 。 有关更多信息，请参阅： 如何创建轴组" }, 
{ "title" : "用户界面 ", 
"url" : "_sm_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ 用户界面 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：启用 SoftMotion ", 
"url" : "_sm_cmd_enable_softmotion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ 用户界面 \/ 命令：启用 SoftMotion ", 
"snippet" : "功能 : 该命令启用组件 SoftMotion 用于选定的控制器，并可以将控制器用作运动控制器。 称呼 ： 项目 菜单;设备树中选定设备的上下文菜单 要求 ：对于所选控制器，未启用 SoftMotion。 该命令导致 SoftMotion 通用轴池 只要对象仍然缺失，设备就会添加到控制器配置之下。最多有一个 SoftMotion 通用轴池 每个 PLC 设备。此外，SoftMotion 库（带有前缀 SM3_ ) 被添加到库管理器。 因此，您可以在所有传统 PLC 上使用 SoftMotion 功能，例如，即使没有许可证，至少在演示模式下也可以调用 SoftMotion 功能块。 自动激活 如...", 
"body" : "功能 : 该命令启用组件 SoftMotion 用于选定的控制器，并可以将控制器用作运动控制器。 称呼 ： 项目 菜单;设备树中选定设备的上下文菜单 要求 ：对于所选控制器，未启用 SoftMotion。 该命令导致 SoftMotion 通用轴池 只要对象仍然缺失，设备就会添加到控制器配置之下。最多有一个 SoftMotion 通用轴池 每个 PLC 设备。此外，SoftMotion 库（带有前缀 SM3_ ) 被添加到库管理器。 因此，您可以在所有传统 PLC 上使用 SoftMotion 功能，例如，即使没有许可证，至少在演示模式下也可以调用 SoftMotion 功能块。 自动激活 如果您的设备已禁用 SoftMotion 并且您在设备下方添加了任何 SoftMotion 对象，则 启用 SoftMotion 命令立即隐式执行。 SoftMotion 对象是凸轮对象、CNC 对象、轴组对象或任何 SoftMotion 轴。 从 SoftMotion PLC 到标准 PLC 的设备更新 如果已启用 SoftMotion 并且已在下方配置设备 SoftMotion 通用轴池 ，那么您无论如何都可以将您的设备更新为标准 PLC。这是因为这些设备即使在更新后仍然可用。例如，您可以从更新 CODESYS SoftMotion RTE 到 CODESYS Control RTE 没有任何损失。 " }, 
{ "title" : "命令：禁用 SoftMotion ", 
"url" : "_sm_cmd_disable_softmotion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ 用户界面 \/ 命令：禁用 SoftMotion ", 
"snippet" : "功能 : 该命令禁用组件 SoftMotion . 称呼 ： 项目 菜单;设备树中选定设备的上下文菜单 要求 ：对于选定的控制器， SoftMotion 是通过命令启用的。 SoftMotion 不能为旨在支持的控制器禁用 SoftMotion （例子： CODESYS SoftMotion Win ）。 该命令导致 SoftMotion 通用轴池 要从控制器配置下方删除的设备。此外，SoftMotion 库（带有前缀 SM3_ ) 从库管理器中删除。 您不能再使用 SoftMotion 功能。...", 
"body" : "功能 : 该命令禁用组件 SoftMotion . 称呼 ： 项目 菜单;设备树中选定设备的上下文菜单 要求 ：对于选定的控制器， SoftMotion 是通过命令启用的。 SoftMotion 不能为旨在支持的控制器禁用 SoftMotion （例子： CODESYS SoftMotion Win ）。 该命令导致 SoftMotion 通用轴池 要从控制器配置下方删除的设备。此外，SoftMotion 库（带有前缀 SM3_ ) 从库管理器中删除。 您不能再使用 SoftMotion 功能。 " }
]
$(document).trigger('search.ready');
});