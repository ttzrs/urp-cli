$(document).ready(function () {indexDict['zh-CHS'] = [{ "title" : "CODESYS Git ", 
"url" : "_git_start_page.html", 
"breadcrumbs" : "CODESYS Git \/ CODESYS Git ", 
"snippet" : "CODESYS Git 使得使用分布式Git版本控制系统成为可能 CODESYS 为了管理版本 CODESYS 项目。 Git的功能可以直接使用 CODESYS 。 您可以下载 CODESYS Git 从 CODESYS 国际商店 或者 CODESYS 北美商店 。您还可以在那里找到该产品的数据表。 发布 CODESYS Git（视频片段）...", 
"body" : "CODESYS Git 使得使用分布式Git版本控制系统成为可能 CODESYS 为了管理版本 CODESYS 项目。 Git的功能可以直接使用 CODESYS 。 您可以下载 CODESYS Git 从 CODESYS 国际商店 或者 CODESYS 北美商店 。您还可以在那里找到该产品的数据表。 发布 CODESYS Git（视频片段） " }, 
{ "title" : "导言 ", 
"url" : "_git_introduction.html", 
"breadcrumbs" : "CODESYS Git \/ 导言 ", 
"snippet" : "的实施 CODESYS Git 以 Git 中的工作和 Git 的术语为基础。安装完成后，菜单栏 CODESYS 将包括 Git 菜单中包含用于初始化 Git 项目和使用链接的 Git 存储库的命令。 有关中使用的一些术语，请参阅以下内容 CODESYS Git 帮忙然后在 CODESYS Git 用户界面。包括相应的标准 Git 命令。 使用 Git 的基础知识是先决条件。有关此的文档，请参阅（例如）： Git Book ， Atlassian Git 存储桶 Git 存储库 ， Git 项目存储 （“工作目录”、“工作树”） 对于纯粹的本地存储库来说 CODESYS Git 项目，我们在这...", 
"body" : "的实施 CODESYS Git 以 Git 中的工作和 Git 的术语为基础。安装完成后，菜单栏 CODESYS 将包括 Git 菜单中包含用于初始化 Git 项目和使用链接的 Git 存储库的命令。 有关中使用的一些术语，请参阅以下内容 CODESYS Git 帮忙然后在 CODESYS Git 用户界面。包括相应的标准 Git 命令。 使用 Git 的基础知识是先决条件。有关此的文档，请参阅（例如）： Git Book ， Atlassian Git 存储桶 Git 存储库 ， Git 项目存储 （“工作目录”、“工作树”） 对于纯粹的本地存储库来说 CODESYS Git 项目，我们在这里使用缩写的 “Git 存储库”。 The Git repository is located in the file system, in the \"Git project storage\", in the subdirectory .git . The objects of the project ( <objecttype>_<ID> ) which are managed in Git are located in the subdirectory project . The object files are located in a directory hierarchy which corresponds to the hierarchy of objects in the CODESYS project. Git 项目存储还包含 Git 管理文件 .gitattribute ， .gitignore ，以及 .apsession 。这个文件 .apsession 用于控制的访问权限 CODESYS Git 存储库中的实例，被 Git 忽略。 可以在项目的 Git 项目存储路径中看到 Git 项目设置 观点。 The configuration settings, which are available in the .git\/config file, can be modified in a CODESYS Git project via a configuration dialog . If there is no global config file in the local user directory from previous Git actions, then the user is prompted to create a configuration when initializing or cloning a project. CODESYS 项目目录 使用以下方法管理的项目 CODESYS Git 也总是存储在普通的 CODESYS 项目目录除了存储在 Git 项目存储中（双重数据管理）。 远程存储库 : 看法: Git 遥控器 git remote 确保您与远程服务器建立了安全连接。有关更多信息，请参阅： CODESYS Git 的安全性 远程存储库是托管在 Internet 上或网络上某个位置的项目的版本。您完全有可能使用 “远程” 存储库，该存储库实际上位于您当前正在使用的同一台计算机（主机）上。 远程存储库通常被命名为 origin 。 A CODESYS 已经在 Git 中在本地 Git 存储库中管理的项目可以链接到中的远程存储库 Git 遥控器 查看 ( git remote ， git remote add ）。 只有在此之后，本地分支才能 “跟踪” 远程分支，并且才能为远程存储库（“上游”）中的本地分支创建等效分支。只有在那之后才能 取 ， 拉 ， 推 ，以及 合并 命令用于在本地 Git 存储库和远程存储库之间交换\/合并提交。 要使用远程存储库执行 Git 操作，通常需要凭据进行身份验证。它们保存在Windows的凭据管理器中。相同的凭据可以用于位于同一主机服务器上的所有远程存储库。有关更多信息，请参阅： 需要证书。 本地分支机构、远程分支机构 看法： Git 分支 git remote git branch 恰好有两种分支：“本地” 和 “远程”。本地分支可以 “跟踪” 一个远程分支。 当地分支机构： Local branches are displayed in the Git Branches Local (<n>) view. Git 存储库的本地默认分支（通常 master ) 是在第一次提交后自动创建的。 CODESYS 项目是使用创建的 git clone ，本地 “主” 分支会自动跟踪同名的远程分支。 本地分支也可以通过复制现有的本地分支或签出远程分支来创建。在最后一种情况下，最近创建的本地分支会自动跟踪远程分支。 远程分支机构： Remote branches are displayed in the Git Branches Remote (<n>) view. They are the existing representatives in the Git repository of the respective branch with the same name in the remote repository. 远程分支机构仅在内部用作通过以下方式进行通信的 “中间位置” 推 \/ 拉 与远程存储库一起使用，不能由用户直接使用。 \" Upstream \" 命令在 Git 分支 当地的 看法 git branch --set-upstream-to <origin\/remote-branch> 这个 上游 设置 操作导致在远程存储库（远程分支）中创建与本地分支相对应的分支。 \" Tracking \", \"远程跟踪分支\" 命令在 Git 分支 看法 git branch --track git checkout 赛道分支 意味着在本地分支和远程分支之间创建链接。 默认案例：当地代表分支机构 master Git 存储库跟踪远程分支 origin\/master 远程存储库的。 当本地分支跟踪远程分支时，可以通过以下方式与远程存储库交换提交 拉 和 推 。 Alternatively, you could also use the Checkout command in the Git Branches Remote (<n>) view to create a local \"tracking\" branch, which is set as \"current\" branch at the same time, for an existing remote branch. The current branch is the one where new commits arrive. Git index 看法： Git 状态 git status The index is a Git-internal intermediate level between the working directory and the Git repository. It allows for selectively marking only a selection of changed objects for a commit. Not all changes have to be checked in as a commit. Objects which are located in the Git index are visible in the Status & Staging view, in the Staged Changes section. Resynchronization and reloading the project Synchronization The CODESYS project in CODESYS is resynchronized with the current state from the Git project storage after each Git operation which performs a change to the Git repository. These operations include the following: 结账 ， 拉 ，以及 合并 分支机构（ Git 分支 查看） 丢弃所有更改 和 回滚所有未暂存的更改 （ 状态和阶段 查看） 通过解决冲突而发生的变化 的重新同步 CODESYS 项目的效果是项目是完全从存储库中重建的。没有尝试更新该项目。 你可以使用 从存储库重建项目 以明确启动重新同步。 另一方面，同步是应用从 CODESYS 项目存储到 Git 项目存储库中。每当在其中进行更改时，就会发生这种情况 CODESYS 项目。对项目进行更改时，仅应用这些更改。重新打开项目后，完整项目将再次应用到 Git 项目存储库并覆盖那里的状态 你可以使用 将项目与 Git 项目存储同步 用于显式启动同步的命令（默认情况下不在 Git 菜单中）。 " }, 
{ "title" : "将项目放入 Git 管理中 ", 
"url" : "_git_setting_up_repositories.html", 
"breadcrumbs" : "CODESYS Git \/ 将项目放入 Git 管理中 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "中的存储库和分支 CODESYS Git ", 
"url" : "_git_setting_up_repositories.html#UUID-45dd2cae-82b0-7a65-3526-e4fdc7369aa4_id_d99ef84311db29bfc0a8646324d30e24-id-73febd7011db29bfc0a86463349a40b7", 
"breadcrumbs" : "CODESYS Git \/ 将项目放入 Git 管理中 \/ 中的存储库和分支 CODESYS Git ", 
"snippet" : "管理一个 CODESYS 在 Git 项目的帮助下 CODESYS Git ，首先使用纯本地的就足够了 Git 存储库 在“项目存储”（工作目录）中，在下文中也称为“Git 存储库”。为了与项目上的其他开发者进行协作，可以将本地 Git 存储库与“ 远程仓库 “每个人都可以访问。 在 Git 中管理的项目的工作首先在本地完成 分支机构 （工作状态）。本地分支可以跟踪远程分支（链接到远程存储库）。远程分支是远程存储库中相应分支的本地 Git 存储库中的现有代表。 你可以使用 移动存储库 命令将 Git 存储库移动到文件系统中的其他位置。 你可以使用 断开与 Git 存储库的连接 命令取消项目与 ...", 
"body" : "管理一个 CODESYS 在 Git 项目的帮助下 CODESYS Git ，首先使用纯本地的就足够了 Git 存储库 在“项目存储”（工作目录）中，在下文中也称为“Git 存储库”。为了与项目上的其他开发者进行协作，可以将本地 Git 存储库与“ 远程仓库 “每个人都可以访问。 在 Git 中管理的项目的工作首先在本地完成 分支机构 （工作状态）。本地分支可以跟踪远程分支（链接到远程存储库）。远程分支是远程存储库中相应分支的本地 Git 存储库中的现有代表。 你可以使用 移动存储库 命令将 Git 存储库移动到文件系统中的其他位置。 你可以使用 断开与 Git 存储库的连接 命令取消项目与 Git 源代码管理的链接。 当设置了加密时 CODESYS 项目（ CODESYS - 项目设置 — 安全 ），Git 存储库（既不是本地存储库也不是远程存储库）不会自动受到相应的保护。 " }, 
{ "title" : "使用 git init 放置一个 CODESYS Git 管理中的项目 ", 
"url" : "_git_setting_up_repositories.html#UUID-45dd2cae-82b0-7a65-3526-e4fdc7369aa4_id_d99ef84311db29bfc0a8646324d30e24-id-e53fbb62a75511ebb64e996906c7fdba", 
"breadcrumbs" : "CODESYS Git \/ 将项目放入 Git 管理中 \/ 使用 git init 放置一个 CODESYS Git 管理中的项目 ", 
"snippet" : "要求： CODESYS Git 已安装。 CODESYS 项目已打开。 文件系统中为 Git 项目存储库准备一个空目录以包含本地 Git 存储库。示例： D:\\git_local\\rep1 在 CODESYS Git ，打开 CODESYS 该项目应置于 Git 管理之下。示例： myproj.project 。 点击 Git → 初始化 Git 存储库 命令。 这个 初始化 Git 存储库 对话框打开。 在对话框中，指定空目录的路径 Git 项目存储 （示例： D:\\git_local\\rep1 ）。在那里创建的 Git 存储库是你的本地 “主存储库”。 如果没有全局的 配置文件 .gitc...", 
"body" : "要求： CODESYS Git 已安装。 CODESYS 项目已打开。 文件系统中为 Git 项目存储库准备一个空目录以包含本地 Git 存储库。示例： D:\\git_local\\rep1 在 CODESYS Git ，打开 CODESYS 该项目应置于 Git 管理之下。示例： myproj.project 。 点击 Git → 初始化 Git 存储库 命令。 这个 初始化 Git 存储库 对话框打开。 在对话框中，指定空目录的路径 Git 项目存储 （示例： D:\\git_local\\rep1 ）。在那里创建的 Git 存储库是你的本地 “主存储库”。 如果没有全局的 配置文件 .gitconfig 在本地用户目录中（例如： C:\\Users\\m.muster )，然后将打开一个对话框提示您为所有人创建基本配置 CODESYS Git 行动。输入某些参数的对话框与通过输入参数的对话框相同 Git 配置 命令。的默认设置 默认分支 是 master 。输入您的用户数据 用户名 和 电子邮件 地址（示例） m.muster ， m.muster@company.com ）。 The objects in the project navigator are provided with blue plus signs (status: \"added\"), and the root node (project name) is provided with an orange square (status: \"changed\"). Git 项目存储路径显示在 Git → 项目设置 观点。 结果，位于项目存储中的 Git 存储库中的项目管理被初始化。 将项目（像往常一样在没有 Git 管理的情况下保存）单独保存 项目目录 （示例： D:\\git_projects\\myproj.project ）。注意：因此，项目文件需要接受双重数据管理。 打开 Git 状态 观点。 未暂存的更改 在下半部分，选择显示的项目对象。然后点击 按钮将其暂存以供提交。 对象移至上方 分阶段更改 。 点击 按钮（提交）。 提交分阶段更改 对话框中，输入提交消息，然后单击 好吧 进行确认。 项目对象的当前状态已提交到本地存储库。 点击 Git → Git 历史记录 命令。 在 历史 视图中，将显示 “master” 的第一次提交，其中包含更多信息。 在项目导航器中，纯绿色圆圈符号 显示在已提交对象的前面和根目录的前面。这意味着项目的状态与其在 Git 存储库中的状态同步。 点击 Git → Git 分支 命令并启用 当地 (1) 过滤。 Git 存储库的默认分支显示为 master (refs\/heads\/master) 。 在文件系统中，转到本地存储库 D:\\git_local\\rep1 。 现在是目录 .git （实际的 Git 存储库）位于此处，其子目录为 project 还有文件 .gitattributes ， .gitignore ，以及 .apsession 。该目录 project 包含的对象 CODESYS 项目。 现在，您仍然可以将项目（必要时）与远程存储库链接。 " }, 
{ "title" : "使用 Clone Git Repository 创建一个新的 CODESYS 项目已经在 Git 管理中 ", 
"url" : "_git_setting_up_repositories.html#UUID-45dd2cae-82b0-7a65-3526-e4fdc7369aa4_id_d99ef84311db29bfc0a8646324d30e24-id-11ad0c1713d3a29ac0a8646340f28253", 
"breadcrumbs" : "CODESYS Git \/ 将项目放入 Git 管理中 \/ 使用 Clone Git Repository 创建一个新的 CODESYS 项目已经在 Git 管理中 ", 
"snippet" : "和 Git 克隆 ，一个新的 CODESYS 项目已创建，在 Git 中进行版本管理。因此，克隆远程存储库会创建新的项目存储（带有 Git 存储库的新工作目录）。 要求： CODESYS Git 已安装。您可以访问远程存储库。 打开 CODESYS Git 。点击 Git → 克隆 Git 存储库 命令。没有时可用 CODESYS 项目已打开。 这个 Git 克隆 对话框打开。 在 来源网址 ，指定要克隆的远程存储库的 URL 或文件路径（例如： D:\\git_remotes\\remote1 ）。 在 Git 存储路径 ，指定用于新 Git 项目存储（新 Git 存储库）的空文件目录（示例： ...", 
"body" : "和 Git 克隆 ，一个新的 CODESYS 项目已创建，在 Git 中进行版本管理。因此，克隆远程存储库会创建新的项目存储（带有 Git 存储库的新工作目录）。 要求： CODESYS Git 已安装。您可以访问远程存储库。 打开 CODESYS Git 。点击 Git → 克隆 Git 存储库 命令。没有时可用 CODESYS 项目已打开。 这个 Git 克隆 对话框打开。 在 来源网址 ，指定要克隆的远程存储库的 URL 或文件路径（例如： D:\\git_remotes\\remote1 ）。 在 Git 存储路径 ，指定用于新 Git 项目存储（新 Git 存储库）的空文件目录（示例： D:\\git_local\\rep1 ）。 在 项目文件 ，指定一个项目目录，其中新的 CODESYS 还应将项目保存在 Git (!) 之外还应保存（示例： D:\\git_projects\\myproj1.project ，双重数据管理！）。 在 项目文件类型 ，选择它应该是标准项目还是库项目。确认对话框。 如果没有全局的 配置文件 .gitconfig 在本地用户目录中（例如： C:\\Users\\m.muster )，然后将打开一个对话框提示您为所有人创建基本配置 CODESYS Git 行动。请参阅上面有关初始化 Git 项目的说明（步骤 4） If the Git option Accept self signed certificate is not selected, then CODESYS Git first checks the certificate for the connection to the server from which the project should be cloned. If the certificate is not trusted, then you will be given the option of allowing the connection after a personal check. 新项目已打开。新的工作目录被创建并自动初始化为 Git 存储库。它首先具有克隆时远程存储库的确切状态。 在 CODESYS 项目，单击 Git → Git 分支 命令。 在 Git 分支 视图，远程分支已经可见。默认情况下，对于远程 “主” 分支，还会创建一个本地 “主” 分支，用于跟踪远程分支。现在，你可以立即开始在这个本地分支机构工作。此外，本地分支机构与 “代表性” 远程分支机构的链接（跟踪）（ origin\/master ) 的新 Git 存储库已经建立。 " }, 
{ "title" : "将项目链接到远程存储库 ", 
"url" : "_git_setting_up_repositories.html#UUID-45dd2cae-82b0-7a65-3526-e4fdc7369aa4_id_d99ef84311db29bfc0a8646324d30e24-id-57b75172176320a3c0a864631b96d43f", 
"breadcrumbs" : "CODESYS Git \/ 将项目放入 Git 管理中 \/ 将项目链接到远程存储库 ", 
"snippet" : "要求：在 Git 中管理项目 CODESYS Git 。现在你想建立一个指向远程仓库的链接，将你的提交与其他人的提交同步。 点击 Git → Git 遥控器 命令。 Git 遥控器 查看，单击 添加 按钮。 这个 添加新的 Git Remote 对话框打开。 指定要链接的远程存储库的路径和名称。示例： 别名 : origin ， 网址 : D:\\git_remote 。 运行 取 命令，然后单击 Git → Git 分支 命令切换到 Git 分支 观点。 访问远程存储库通常需要证书。只有在计算机上找不到有效的凭据时， 需要证书 对话框供您输入。有关更多信息，请参阅： 需要证书。 Select ...", 
"body" : "要求：在 Git 中管理项目 CODESYS Git 。现在你想建立一个指向远程仓库的链接，将你的提交与其他人的提交同步。 点击 Git → Git 遥控器 命令。 Git 遥控器 查看，单击 添加 按钮。 这个 添加新的 Git Remote 对话框打开。 指定要链接的远程存储库的路径和名称。示例： 别名 : origin ， 网址 : D:\\git_remote 。 运行 取 命令，然后单击 Git → Git 分支 命令切换到 Git 分支 观点。 访问远程存储库通常需要证书。只有在计算机上找不到有效的凭据时， 需要证书 对话框供您输入。有关更多信息，请参阅： 需要证书。 Select the Remote (<n>) filter. You see the remote branches. Unselect the Remote (<n>) filter. Select the Local (1) filter. Select the master entry and click Upstream Set . If there is still no remote branch ( origin\/master ) for the selected remote repository, then the following happens: 这个 为分支机构设置上游远程 对话框打开。远程名称 origin 已经预定义了。 点击 好吧 确认参赛作品。 → 那个 追踪 和 当前 已为其选择选项 master 。 追踪的分支机构，名称 ， origin\/master 显示出来。 这意味着远程分支 origin\/master 因为远程存储库是在内部创建的。这仅用作代表：该分支机构不直接进行任何工作。 选择 master 然后点击 推 。 遥控器 (1) 过滤。 现在是代表分支机构 origin\/master 下面 Git 分支 遥控器 (1) 还会显示。来自本地的链接 master 远程存储库是通过其代表建立的 origin\/master 。 In the Git Branches Local (<1>) view, you can now use the Track branch command to link the local branch ( master ) of the Git repository to the new remote branch of the remote repository. " }, 
{ "title" : "最佳实践 ", 
"url" : "_git_best_practises.html", 
"breadcrumbs" : "CODESYS Git \/ 最佳实践 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "何时恢复 Git 项目 CODESYS 编辑项目时崩溃了 ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm457535419458083309225168268", 
"breadcrumbs" : "CODESYS Git \/ 最佳实践 \/ 何时恢复 Git 项目 CODESYS 编辑项目时崩溃了 ", 
"snippet" : "取决于哪种操作 CODESYS 以前崩溃过，你可以选择以下恢复： 通常，你可以在崩溃后重新打开项目。 CODESYS Git 恢复最近一次内部保存的项目状态，并将项目内容重写到 Git 项目存储中。这种 “故障保存” 机制将项目视为 “主” 数据源。如果项目在合并操作期间崩溃，则不应在重新打开后继续工作之前立即保存，而应先丢弃所有更改（git reset--hard）。为此，你可以使用 丢弃所有更改 命令在 状态和阶段 观点。 如果崩溃后无法再成功打开项目（例如，因为完全不兼容的文件最终出现在项目存储中），您可以选择以下恢复选项：从存储库完全重新加载项目。有关更多信息，请参阅： 从存储库重建项...", 
"body" : "取决于哪种操作 CODESYS 以前崩溃过，你可以选择以下恢复： 通常，你可以在崩溃后重新打开项目。 CODESYS Git 恢复最近一次内部保存的项目状态，并将项目内容重写到 Git 项目存储中。这种 “故障保存” 机制将项目视为 “主” 数据源。如果项目在合并操作期间崩溃，则不应在重新打开后继续工作之前立即保存，而应先丢弃所有更改（git reset--hard）。为此，你可以使用 丢弃所有更改 命令在 状态和阶段 观点。 如果崩溃后无法再成功打开项目（例如，因为完全不兼容的文件最终出现在项目存储中），您可以选择以下恢复选项：从存储库完全重新加载项目。有关更多信息，请参阅： 从存储库重建项目" }, 
{ "title" : "将项目转移自 CODESYS SVN 到 CODESYS Git ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm4543860664779233978358194268", 
"breadcrumbs" : "CODESYS Git \/ 最佳实践 \/ 将项目转移自 CODESYS SVN 到 CODESYS Git ", 
"snippet" : "我们强烈建议您在成功将项目转移到 GIT 后不要删除 SVN 存储库，这样在必要时您仍然可以访问它们。 在 CODESYS Git 版本 1.4.0.0 及更高版本，脚本接口可用于从中传输项目 CODESYS SVN 到 CODESYS Git 。 Git 命令 git-svn 不能用来转移 CODESYS 项目来自 CODESYS SVN 到 CODESYS Git 因为 CODESYS Git 使用 .json 文件格式，与二进制文件格式的对比 CODESYS SVN 。 由于存储库结构的不同而提出的评论和建议 CODESYS SVN 和 CODESYS Git 在 CODESYS Git...", 
"body" : "我们强烈建议您在成功将项目转移到 GIT 后不要删除 SVN 存储库，这样在必要时您仍然可以访问它们。 在 CODESYS Git 版本 1.4.0.0 及更高版本，脚本接口可用于从中传输项目 CODESYS SVN 到 CODESYS Git 。 Git 命令 git-svn 不能用来转移 CODESYS 项目来自 CODESYS SVN 到 CODESYS Git 因为 CODESYS Git 使用 .json 文件格式，与二进制文件格式的对比 CODESYS SVN 。 由于存储库结构的不同而提出的评论和建议 CODESYS SVN 和 CODESYS Git 在 CODESYS Git ，一个 Git 存储库只能管理一个 CODESYS 项目。因为一个 SVN 存储库可以包含 CODESYS 项目，传输到时，必须为 SVN 存储库中的每个项目创建单独的 Git 存储库 CODESYS Git 。 建议将 SVN 存储库的各个项目转移到的存储库中 CODESYS Git 在逐个项目的基础上。 不建议将 SVN 存储库拆分成多个 SVN 存储库，因为这可能会导致以后出现问题。 分支和标签存在于 SVN 和 GIT 中，但它们在这两个系统中的设计不同。向... 转账 git-svn 命令不可用，因为此命令不能用于 CODESYS Git （见上文）。 因此，我们只能将 SVN 主干转移到 Git 分支（默认为 “主分支” 或 “主分支”）。如有必要，可以手动将 SVN 标签添加为 Git 标签 " }, 
{ "title" : "将没有历史记录的 SVN 项目转移到 Git ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm4551054095480033979915375444", 
"breadcrumbs" : "CODESYS Git \/ 最佳实践 \/ 将项目转移自 CODESYS SVN 到 CODESYS Git \/ 将没有历史记录的 SVN 项目转移到 Git ", 
"snippet" : "在此过程中，最新版本的 CODESYS 项目首次签出 CODESYS SVN 。然后断开与 SVN 的连接，并使用 Git 存储库 CODESYS Git 已为项目初始化。此过程的缺点是项目的历史记录会丢失，因为只有最新的 SVN 版本被传输到 Git 要求： CODESYS SVN 和 CODESYS Git 安装在 CODESYS 。借助 工具 → 自定义 命令， 提交完成 命令已添加到 Git 集成 中的命令类别 Git 菜单。 打开 CODESYS 你保存在SVN存储库中的项目。 点击 项目 → SVN → 结账 。 该项目的最新版本已签出。 点击 项目 → SVN → 断开项目与 S...", 
"body" : "在此过程中，最新版本的 CODESYS 项目首次签出 CODESYS SVN 。然后断开与 SVN 的连接，并使用 Git 存储库 CODESYS Git 已为项目初始化。此过程的缺点是项目的历史记录会丢失，因为只有最新的 SVN 版本被传输到 Git 要求： CODESYS SVN 和 CODESYS Git 安装在 CODESYS 。借助 工具 → 自定义 命令， 提交完成 命令已添加到 Git 集成 中的命令类别 Git 菜单。 打开 CODESYS 你保存在SVN存储库中的项目。 点击 项目 → SVN → 结账 。 该项目的最新版本已签出。 点击 项目 → SVN → 断开项目与 SVN 的连接 。 在计算机的本地文件目录中创建一个新的空文件夹。 在 CODESYS ，点击 Git → 初始化 Git 存储库 然后在对话框中选择上一步中创建的空文件夹。 点击 Git → 提交完成 。 该项目现在存储在本地 Git 存储库中，必要时可以推送到远程存储库。 " }, 
{ "title" : "手动将带有历史记录的 SVN 项目转移到 Git ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm4577975410139233980281280226", 
"breadcrumbs" : "CODESYS Git \/ 最佳实践 \/ 将项目转移自 CODESYS SVN 到 CODESYS Git \/ 手动将带有历史记录的 SVN 项目转移到 Git ", 
"snippet" : "在此过程中，每个 SVN 修订都是在一个 Git 提交中手动传输的。 要求： CODESYS SVN 和 CODESYS Git 安装在 CODESYS 。借助 工具 → 自定义 命令， 提交完成 命令已添加到 Git 集成 中的命令类别 Git 菜单。 在中创建一个新的空项目 CODESYS 然后给它起个名字，例如， Main Project 。 点击 Git → 初始化 Git 存储库 。 点击 Git → 提交完成 。 点击 Git → 提交 执行空提交。 提交分阶段更改 对话框，选择 允许空提交 选项。 关闭此项目。 点击 项目 → SVN → 结账 查看存储在 SVN 中的项目的所需...", 
"body" : "在此过程中，每个 SVN 修订都是在一个 Git 提交中手动传输的。 要求： CODESYS SVN 和 CODESYS Git 安装在 CODESYS 。借助 工具 → 自定义 命令， 提交完成 命令已添加到 Git 集成 中的命令类别 Git 菜单。 在中创建一个新的空项目 CODESYS 然后给它起个名字，例如， Main Project 。 点击 Git → 初始化 Git 存储库 。 点击 Git → 提交完成 。 点击 Git → 提交 执行空提交。 提交分阶段更改 对话框，选择 允许空提交 选项。 关闭此项目。 点击 项目 → SVN → 结账 查看存储在 SVN 中的项目的所需版本。 点击 项目 → SVN → 断开项目与 SVN 的连接 。在随后的对话框中，保留默认选项，然后单击 好吧 。 保存该项目。 点击 Git → 初始化 Git 存储库 然后在文件目录中选择一个空文件夹（例如： 温度 ）。 点击 Git → 提交完成 。 保存项目并将其关闭。 这个 *.project 可以删除该项目的文件。Git 存储库 Temp 在任何情况下都不得删除该项目。 打开 Main Project 再次进行项目。 点击 Git → 遥控器 打开 遥控器 观点。 在 遥控器 查看，单击 添加 。 添加新遥控器 对话框中，指定 Git 存储库的 URL Temp 并指定，例如 Temp_Remote 作为 别名 。 选择此添加的遥控器，然后单击 取 。 点击 Git → 分支机构 打开 Git 分支 观点。 选择的主分支\/主分支 Main ，点击 赛道分支 。 追踪远程分支机构 对话框中，选择主分支\/主分支 Temp_Remote 在步骤 14 中添加的远程。 对 Git 存储库的主\/主分支执行提取 主要 通过点击 使用期权进行拉动 在 Git 分支 查看并选择 用 “他们的” 来处理冲突 选项作为 合并冲突策略 在 Git Pull 大师 对话框。的默认选项 快进策略 不应更改。 现在点击 Git -→ 提交完成 . 在 提交暂存和未暂存的更改 对话框，选择 修改提交 选项。 本指南开头查看的 SVN 项目的修订版现在存储在 Git 存储库中 主要 作为承诺。 在 遥控器 查看，选择 Temp 遥控并点击 移除 。 保存 Main Project 项目并关闭它。 移除 Git 存储库 Temp 从您的文件目录中。 如果您想将 SVN 项目的另一个版本转移到 Git 存储库，请按照步骤 6 中的说明进行操作，获取 SVN 项目的下一个所需修订版本。 " }, 
{ "title" : "使用脚本将 SVN 项目转移到 Git ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm53402697907264", 
"breadcrumbs" : "CODESYS Git \/ 最佳实践 \/ 将项目转移自 CODESYS SVN 到 CODESYS Git \/ 使用脚本将 SVN 项目转移到 Git ", 
"snippet" : "要求： CODESYS Git 版本 >= 1.4.0.0 以下传输脚本模板如下所示： 1。用于从中转移项目的脚本 CODESYS SVN 到 CODESYS Git 2。用于检查传输期间是否为每个 SVN 修订版创建了相应的 Git 提交的脚 注意事项 未对 SVN 存储库进行任何更改。 这两个脚本都用作模板，您需要对其进行调整以适应相应的要求。...", 
"body" : "要求： CODESYS Git 版本 >= 1.4.0.0 以下传输脚本模板如下所示： 1。用于从中转移项目的脚本 CODESYS SVN 到 CODESYS Git 2。用于检查传输期间是否为每个 SVN 修订版创建了相应的 Git 提交的脚 注意事项 未对 SVN 存储库进行任何更改。 这两个脚本都用作模板，您需要对其进行调整以适应相应的要求。 " }, 
{ "title" : "用于传输 SVN 项目的脚本 ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm4610024336323234027017655364", 
"breadcrumbs" : "CODESYS Git \/ 最佳实践 \/ 将项目转移自 CODESYS SVN 到 CODESYS Git \/ 用于传输 SVN 项目的脚本 ", 
"snippet" : "该脚本传输主干的所有 SVN 修订版 CODESYS SVN 项目到 a 的 “主” 分支 CODESYS Git 项目。 import os import shutil import logging \"\"\" --- inputs --- \"\"\" # URL of the SVN project you want to migrate # only migrate a single project at a time if you have multiple in your SVN repo SVN_REPO_URL = 'svn:\/\/your.svnserver.com\/trunk\/Code...", 
"body" : "该脚本传输主干的所有 SVN 修订版 CODESYS SVN 项目到 a 的 “主” 分支 CODESYS Git 项目。 import os\nimport shutil\nimport logging\n\n\n\"\"\" --- inputs ---\n\"\"\"\n# URL of the SVN project you want to migrate\n# only migrate a single project at a time if you have multiple in your SVN repo\nSVN_REPO_URL = 'svn:\/\/your.svnserver.com\/trunk\/CodesysProjectNr1'\n# Starts migration at this svn revision\nSTARTING_REVISION = 0\n# Directory of the new project with the git repository\nNEW_PROJECT_DIR = 'C:\/CodesysProjects\/CodesysProjectNr1'\n# Name of the new project\nNEW_PROJECT_NAME = 'CodesysProjectNr1'\n# Is the project a library (otherwise will be checked out as a project)\nIS_LIBRARY = False\n# Path to the local git repository of the new project\nNEW_PROJECT_REPO_DIR = 'C:\/CodesysProjects\/CodesysProjectNr1\/repo'\n\n# Path to an EMPTY temporary folder (doesn't have to exist) that can be deleted\nTEMP_PATH = 'C:\/CodesysProjects\/CodesysProjectNr1\/temp'\n\n# Author of the git commits\nAUTHOR_NAME = 'Author Name'\n# E-mail address of the git commits\nAUTHOR_EMAIL = 'Author.Name@e-mail.com'\n\n# Name of the branch that should contain the history\n# Can't be named 'master'\nTARGET_BRANCH_NAME = 'develop'\n# Initial commit messages on the master branch and the target branch\nIC_MSG_MASTER = 'master: Initial commit.'\nIC_MSG_TARGET_BRANCH = 'develop: Initial commit.'\n\n# Removes the newly created project and its repository if the migration fails\nREMOVE_MAIN_PROJECT_ON_FAILURE = True\n\n\ndef get_git_commit_msg(svn_log):\n \"\"\" Returns the commit messages that will be seen in the resulting git history\n Can be customized to ones demands.\n *svn_log* see: https:\/\/content.helpme-codesys.com\/en\/ScriptingEngine\/ScriptSubversion.html#ScriptSubversion.LogInfo\n \"\"\"\n return 'SVN revision %d: %s' % (svn_log.revision, svn_log.message)\n\n\n\"\"\" --- migration script ---\n\"\"\"\n# Type extension of the project (.project \/ .library)\nPROJECT_FILE_TYPE_EXTENSION = '.library' if IS_LIBRARY else '.project'\n# Path to your new Git project\nNEW_MAIN_PROJECT_PATH = os.path.join(NEW_PROJECT_DIR, NEW_PROJECT_NAME + PROJECT_FILE_TYPE_EXTENSION)\n# Name of the temporarily added remote\nTEMP_REMOTE_NAME = 'remote1'\n# Temporary commit message will be overwritten\/amended (put what u like)\nTEMP_COMMIT_MSG = 'TEMP COMMIT: This will be overwritten'\n\n\ndef create_git_project():\n \"\"\" 1. Creates a new project at *NEW_MAIN_PROJECT_PATH*\n 2. Initializes it in git with the repository at *NEW_PROJECT_REPO_DIR*\n 3. Makes an initial commit with the message *IC_MSG_MASTER*\n 4. Creates and switches to the target branch *TARGET_BRANCH_NAME*\n 5. Makes an initial commit on the target branch with the message *IC_MSG_TARGET_BRANCH*\n 6. Saves and closes the project\n \"\"\"\n git_project = projects.create(NEW_MAIN_PROJECT_PATH)\n git_project.git.init(NEW_PROJECT_REPO_DIR)\n git_project.git.commit_complete(IC_MSG_MASTER, AUTHOR_NAME, AUTHOR_EMAIL)\n\n git_project, git_branch = git_project.git.branch_copy(TARGET_BRANCH_NAME, checkout=True)\n git_project.git.commit_complete(IC_MSG_TARGET_BRANCH, AUTHOR_NAME, AUTHOR_EMAIL, bAllowEmptyCommits=True)\n\n git_project.save()\n git_project.close()\n\n\ndef remove_all_children(project):\n \"\"\" Removes all objects that can be removed from the project *project*\n \"\"\"\n children = project.get_children(recursive=True)\n for child in children:\n try:\n child.remove()\n except Exception as ex:\n if not 'Object reference not set to an instance of an object.' == str(ex):\n logging.error(ex)\n\n\ndef create_git_repo_from_svn_revision(svn_log):\n \"\"\" 1. Checks out a project from the SVN server *SVN_REPO_URL*\n 2. Disconnects it from SVN\n 3. Initiates it in git with the repository at *repo_dir*\n 4. Makes a commit with the message *commit_message*\n 4.1 See \"get_git_commit_msg\" to customize the commit message\n 5. Saves and closes the project\n 6. Returns the path of the project and path of the repository\n \"\"\"\n project_path = os.path.join(TEMP_PATH, 'revision_' + str(svn_log.revision) + PROJECT_FILE_TYPE_EXTENSION)\n repo_dir = os.path.join(TEMP_PATH, 'repo_' + str(svn_log.revision))\n commit_message = get_git_commit_msg(svn_log)\n\n temp_project_name = 'revision_%d' % svn_log.revision\n svn_project = svn.checkout(SVN_REPO_URL, TEMP_PATH, temp_project_name, svn_log.revision, as_library=IS_LIBRARY)\n\n svn_project.svn.disconnect()\n svn_project.git.init(repo_dir)\n svn_project.git.commit_complete(commit_message, AUTHOR_NAME, AUTHOR_EMAIL)\n svn_project.save()\n svn_project.close()\n\n return project_path, repo_dir\n\n\ndef magic_git_pull(project, temp_repo_path, svn_log):\n \"\"\" 1. Removes everything from the *project* (to insure svn revision and git commit match exactly)\n 2. Pulls from the repo at *repo_path*\n 4. Commits the changes with the commit message *commit_message*\n 5. Saves and closes the project\n \"\"\"\n remove_all_children(project)\n\n # Temp commit for fake git merge --squash\n project.git.commit_complete(TEMP_COMMIT_MSG, AUTHOR_NAME, AUTHOR_EMAIL, bAllowEmptyCommits=True)\n\n project.git.remote_add(TEMP_REMOTE_NAME, temp_repo_path)\n project.git.fetch(TEMP_REMOTE_NAME)\n project.git.branch_track('refs\/remotes\/%s\/master' % TEMP_REMOTE_NAME, TARGET_BRANCH_NAME)\n\n pull_options = git.get_pull_options()\n pull_options.fast_forward_strategy = GitFastForwardStrategy.NoFastForward\n pull_options.resolve_file_conflict_strategy = GitResolveFileConflictStrategy.Theirs\n project, merge_result = project.git.pull(AUTHOR_NAME, AUTHOR_EMAIL, pull_options)\n\n commit_message = get_git_commit_msg(svn_log)\n project.git.commit_complete(commit_message, AUTHOR_NAME, AUTHOR_EMAIL, bAllowEmptyCommits=True, bAmendCommit=True)\n\n project.git.branch_unset_upstream()\n project.git.remote_remove(TEMP_REMOTE_NAME)\n\n project.save()\n project.close()\n\n\ndef remove_repo(project_path):\n try:\n project = projects.open(project_path)\n project.git.de_init(True)\n project.close()\n except:\n pass\n\n\ndef remove_temp_project(project_path):\n \"\"\" Opens the project at *project_path* and deinitializes its git repository\n This needs to be done because the script can't delete the repository with \"shutil.rmtree\"\n Removes the rest of the contents int the folder at *TEMP_PATH*\n Removes the temporary .project\/.library files and their associated files\n \"\"\"\n remove_repo(project_path)\n try:\n shutil.rmtree(TEMP_PATH)\n os.makedirs(TEMP_PATH)\n except Exception as e:\n logging.error('Failed to delete %s. Reason: %s' % (TEMP_PATH, e))\n\n\ndef main():\n if projects.primary is not None:\n projects.primary.close()\n\n create_git_project()\n\n # get the list of all revision of SVN_REPO_URL\n # oldest to newest\n # starting at revision STARTING_REVISION + 1\n svn_logs = list(reversed(svn.get_log(SVN_REPO_URL)))\n svn_logs_to_migrate = [log for log in svn_logs if STARTING_REVISION <= log.revision]\n assert svn_logs_to_migrate, ('Nothing to migrate. STARTING_REVISION is greater than the newest '\n 'revision in %s') % SVN_REPO_URL\n\n system.prompt_answers['LossOfDataWarning2'] = PromptResult.Yes\n no_project_root_dir_amount = 0\n try:\n for svn_log in svn_logs_to_migrate:\n try:\n temp_project_path, temp_git_repo_path = create_git_repo_from_svn_revision(svn_log)\n\n # pull to your main Git project\n git_project = projects.open(NEW_MAIN_PROJECT_PATH)\n\n magic_git_pull(git_project, temp_git_repo_path, svn_log)\n\n # can be omitted if enough storage space is available (big performance increase)\n # if omitted the folder at \"TEMP_PATH\" needs to be deleted manually\n # needed storage space = (project file size + project git repository size) * revisions\n # example: 255.16 MB = (1.6 KB + 2.55 MB) * 100\n remove_temp_project(temp_project_path)\n except ValueError as ve:\n # Early svn revisions often do not contain a codesys project\n if ('The URL %s is not a project root directory.' % SVN_REPO_URL) == str(ve):\n no_project_root_dir_amount += 1\n if no_project_root_dir_amount < len(svn_logs_to_migrate):\n logging.info(ve)\n continue\n logging.critical(ve)\n raise\n except:\n if REMOVE_MAIN_PROJECT_ON_FAILURE:\n remove_repo(NEW_MAIN_PROJECT_PATH)\n for file in os.listdir(NEW_PROJECT_DIR):\n if file.startswith(NEW_PROJECT_NAME):\n os.remove(os.path.join(NEW_PROJECT_DIR, file))\n raise\n finally:\n system.prompt_answers.clear()\n\n\nif __name__ == '__main__':\n main()\n\n " }, 
{ "title" : "检查传输结果的脚本 ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm53402698265504", 
"breadcrumbs" : "CODESYS Git \/ 最佳实践 \/ 将项目转移自 CODESYS SVN 到 CODESYS Git \/ 检查传输结果的脚本 ", 
"snippet" : "以下脚本执行以下检查： 检查中是否有相应的 Git 提交 CODESYS Git 每次 SVN 版本的中继版本传输后的项目 CODESYS SVN 项目 检查是否 CODESYS SVN 修订版的项目和 CODESYS 相应 Git 提交的项目是相同的 a 的比较 CODESYS 项目基于 CODESYS 进行转移和验证的开发环境。 常用的脚本编写方法 compare_to() 在 CODESYS 在这种情况下表现不如预期。因此，脚本中使用了变通方法。 import os import logging \"\"\" --- inputs --- \"\"\" # URL of the SVN projec...", 
"body" : "以下脚本执行以下检查： 检查中是否有相应的 Git 提交 CODESYS Git 每次 SVN 版本的中继版本传输后的项目 CODESYS SVN 项目 检查是否 CODESYS SVN 修订版的项目和 CODESYS 相应 Git 提交的项目是相同的 a 的比较 CODESYS 项目基于 CODESYS 进行转移和验证的开发环境。 常用的脚本编写方法 compare_to() 在 CODESYS 在这种情况下表现不如预期。因此，脚本中使用了变通方法。 import os\nimport logging\n\n\n\"\"\" --- inputs ---\n\"\"\"\n# URL of the SVN project you want to check the migration for\nSVN_REPO_URL = 'svn:\/\/your.svnserver.com\/trunk\/CodesysProjectNr1'\n# Directory of the project with git repository to check\nPROJECT_DIR = 'C:\/CodesysProjects\/CodesysProjectNr1'\n# Name of the project to check\nPROJECT_NAME = 'CodesysProjectNr1'\n# Is the project a library (otherwise will be checked out as a project)\nIS_LIBRARY = False\n\n# Path to an EMPTY temporary folder (doesn't have to exist) that can be deleted\nTEMP_PATH = 'C:\/CodesysProjects\/CodesysProjectNr1\/temp'\n\n# Name of the branch that should be checked\nTARGET_BRANCH_NAME = 'develop'\n\n\"\"\" --- check script ---\n\"\"\"\n# Type extension of the project (.project \/ .library)\nPROJECT_FILE_TYPE_EXTENSION = '.library' if IS_LIBRARY else '.project'\n# Path to your new Git project\nMAIN_PROJECT_PATH = os.path.join(PROJECT_DIR, PROJECT_NAME + PROJECT_FILE_TYPE_EXTENSION)\n\n\ndef get_revision_from_commit_msg(msg):\n \"\"\" filters out the revision number from the commit message *msg*\n migrated SVN commits in git: git commit = 'SVN revision *revision number*: *svn commit message*'\n if your migrated svn commits in git are different this possibly won't work\n \"\"\"\n s_num = ''\n for c in msg:\n if c.isdigit():\n s_num = s_num + c\n if ':' == c:\n break\n return int(s_num)\n\n\ndef compare_changed_objects_workaround(changed_objects):\n \"\"\" Compares the changed objects in the *changed_objects* list\n by comparing their content\n Returns True if the objects are identical (not changed)\n \"\"\"\n for changed_object in changed_objects:\n if changed_object.left_object is None:\n return False\n if changed_object.right_object is None:\n return False\n if not changed_object.left_object.textual_declaration.text == changed_object.right_object.textual_declaration.text:\n logging.error('Compared objects are not the same:')\n logging.error('left: %s\/%s' %\n (changed_object.left_object.parent.get_name(), changed_object.left_object.get_name()))\n logging.error(changed_object.left_object.textual_declaration.text)\n logging.error('right: %s\/%s' %\n (changed_object.right_object.parent.get_name(), changed_object.right_object.get_name()))\n logging.error(changed_object.right_object.textual_declaration.text)\n logging.error('diff: ' + str(changed_object.differences))\n logging.error('-----------------------------------------------------')\n return False\n return True\n\n\ndef compare_projects(project_one, project_two):\n \"\"\" Compares two projects\n Returns True if they are identical\n \"\"\"\n comparison_result = project_one.compare_to(project_two, flags=ComparisonFlags.IGNORE_PROPERTIES)\n changed_objects = list(comparison_result.get_changed_objects())\n\n if 0 == len(changed_objects):\n return True\n else:\n return compare_changed_objects_workaround(changed_objects)\n\n\ndef main():\n system.prompt_handling = PromptHandling.LogSimplePrompts\n\n if projects.primary is not None:\n projects.primary.close()\n\n git_project = projects.open(MAIN_PROJECT_PATH)\n\n git_project, git_branch = git_project.git.checkout(TARGET_BRANCH_NAME, force=True)\n\n git_logs = list(reversed(list(git_project.git.log())))\n\n system.prompt_answers['LossOfDataWarning2'] = PromptResult.Yes\n\n checks_done = 0\n try:\n for git_log in git_logs:\n if 'SVN revision ' in git_log.message_string:\n git_project, git_null_branch = git_project.git.checkout(git_log.sha_string)\n\n revision = get_revision_from_commit_msg(git_log.message_string)\n\n temp_project = svn.checkout(SVN_REPO_URL, TEMP_PATH, 'revision_' + str(revision), revision,\n as_library=IS_LIBRARY ,as_primary_project=False)\n\n if not compare_projects(git_project, temp_project):\n prompt_message = (\"Revision %d does not equal it's corresponding git commit. \"\n \"Do you want to continue?\") % revision\n logging.error(prompt_message)\n prompt_result = system.ui.prompt(prompt_message, PromptChoice.YesNo, PromptResult.No)\n if PromptResult.No == prompt_result:\n temp_project.close()\n break\n\n checks_done += 1\n temp_project.close()\n finally:\n system.prompt_answers.clear()\n git_project, git_branch = git_project.git.checkout(TARGET_BRANCH_NAME)\n git_project.close()\n\n if checks_done:\n system.ui.prompt('Done', PromptChoice.OK, PromptResult.OK)\n else:\n error_msg = 'No migrated commits found. If you have custom commit messages change this script accordingly.'\n logging.error(error_msg)\n raise Exception(error_msg)\n\n\nif __name__ == '__main__':\n main()\n \n " }, 
{ "title" : "合并冲突，“关系问题” ", 
"url" : "_git_merge_conflicts.html", 
"breadcrumbs" : "CODESYS Git \/ 合并冲突，“关系问题” ", 
"snippet" : "合并操作会合并两个分支的内容，这两个分支有共同的祖先，但发生了不同的变化。有针对性的分支合并主要在 Git 分支 使用 合并 命令。合并操作也包含在拉动操作中。 合并操作期间会检测到源分支和目标分支的不同状态，这称为冲突。合并导致的未经许可的项目结构被确定为 “关系问题”。视设置选项而定， CODESYS Git 尽可能尝试自动解决这些冲突，或者将此解决方案留给用户。 冲突解决后， CODESYS Git 总是试图 重新同步 （从项目存储中重新读取项目）。这是通过关闭在中打开的项目来完成的 CODESYS 然后从存储中创建一个新的。 CODESYS Git 区分了合并时可能发生的两种需要解决的...", 
"body" : "合并操作会合并两个分支的内容，这两个分支有共同的祖先，但发生了不同的变化。有针对性的分支合并主要在 Git 分支 使用 合并 命令。合并操作也包含在拉动操作中。 合并操作期间会检测到源分支和目标分支的不同状态，这称为冲突。合并导致的未经许可的项目结构被确定为 “关系问题”。视设置选项而定， CODESYS Git 尽可能尝试自动解决这些冲突，或者将此解决方案留给用户。 冲突解决后， CODESYS Git 总是试图 重新同步 （从项目存储中重新读取项目）。这是通过关闭在中打开的项目来完成的 CODESYS 然后从存储中创建一个新的。 CODESYS Git 区分了合并时可能发生的两种需要解决的问题： 冲突 : 纯 Git 冲突：一个或多个对象收到了竞争性更改。它可以是对象内容的不同变化。 基本的 “合并冲突策略” 设定在 Git 合并选项 在 Git 分支 观点。根据此设置，要么尽可能运行自动冲突解决方案，朝特定方向采取基本的接受操作，要么手动处理冲突。 如果是手动解决冲突，则冲突对象将按原样显示在 状态和阶段 观点。双击冲突对象会打开比较视图。在比较视图中，源自两个分支的更改并排显示。您可以通过明确接受来清除内容中的差异。如果它们纯粹是命名空间冲突，则需要通过在项目树中重命名或删除来解决它们。单击 “应用” 以解决冲突。之后，先前冲突的对象将自动移至 “暂存更改” 区域。 “关系问题” : 相互竞争的变更导致了无效的项目结构 CODESYS ，这无法由 Git 合并函数处理。可能已使用外部工具在文件系统外部进行了更改。或者从不同的分支同时创建了相同类型和\/或相同名称的对象，然后该对象位于同一个命名空间中 CODESYS 项目。在 a 中不允许这样 CODESYS 项目。或者发生了无效的父\/子对象关系。另一种可能性是，关系问题源于先前的合并，为了能够暂时继续运作，故意忽略了这些 例如，在一台设备下方插入两个警报配置的情况，这是不允许的。 用户必须使用可用的方法（将一个对象合并为另一个对象、删除、重命名或移动）手动更正项目结构，才能恢复一致的项目。 从版本 1.2.0.0 开始，还可以通过现有关系问题进一步处理项目（忽略）。注意：在这种情况下，对项目的更改将在以后的重新同步中丢弃。原因：重新同步操作从忽略关系问题之前保存的文件系统加载项目版本 在 状态和阶段 视图，作为用户，您可以按如下方式检查和编辑冲突： Helpful commands are available in the context menu of a conflicting object. The current selection depends on the situation: 显示所有受影响的对象 \/ 显示这个对象 : 对象或对象将在中突出显示 设备 项目视图。 用他们的解决办法 ：应用源分支的状态。 使用我们的解决方法 ：应用目标分支的状态。 自动解决 : CODESYS Git 试图巩固变更本身。 标记为已解决 ：项目中当前存在的对象已应用并被视为冲突的解决方案。相应的物体已被暂存。 忽略关系问题 ：在下次重新同步之前，关系问题将被忽略。当你只希望能够继续处理项目并且冲突对此无关紧要时，这可能很有用。 双击冲突对象将打开源分支和目标分支内容的比较视图。如果是竞争内容，则可以根据需要将内容从一个分支应用到另一个分支。 在 消息 视图中，您可以双击冲突的错误消息以打开受影响的对象。 " }, 
{ "title" : "使用 Git 脚本接口 ", 
"url" : "_git_using_scripting.html", 
"breadcrumbs" : "CODESYS Git \/ 使用 Git 脚本接口 ", 
"snippet" : "CODESYS Git 为 Git 提供脚本接口。如何使用该接口的示例如下所示。在下面，您还将找到有关许多 Git 操作生成的消息的基于文本的输出 有关更多信息，请参阅： 脚本引擎 API 文档...", 
"body" : "CODESYS Git 为 Git 提供脚本接口。如何使用该接口的示例如下所示。在下面，您还将找到有关许多 Git 操作生成的消息的基于文本的输出 有关更多信息，请参阅： 脚本引擎 API 文档 " }, 
{ "title" : "要求 ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403339456886", 
"breadcrumbs" : "CODESYS Git \/ 使用 Git 脚本接口 \/ 要求 ", 
"snippet" : "要运行以下示例，需要满足以下条件： CODESYS 3.5.19.30 或更高版本 还需要以下组件： CODESYS Library Documentation Support （创建编译后的库） CODESYS Git 1.6.0.0 或更高版本 本地 Git 安装 尽可能使用 SecureString 密码 为了提高安全性，应将密码作为.NET 安全字符串传递。 受影响的 GIT 操作有： clone ， fetch ， pull ， push 可以在 IronPython 中按如下方式创建 SecureStrings。“密码” 本身应该来自一个安全的字符串，而不是像这里的演示那样，在脚本...", 
"body" : "要运行以下示例，需要满足以下条件： CODESYS 3.5.19.30 或更高版本 还需要以下组件： CODESYS Library Documentation Support （创建编译后的库） CODESYS Git 1.6.0.0 或更高版本 本地 Git 安装 尽可能使用 SecureString 密码 为了提高安全性，应将密码作为.NET 安全字符串传递。 受影响的 GIT 操作有： clone ， fetch ， pull ， push 可以在 IronPython 中按如下方式创建 SecureStrings。“密码” 本身应该来自一个安全的字符串，而不是像这里的演示那样，在脚本中使用纯文本。在内部，提供的每个密码都经过安全处理 from System.Security import SecureString \n\n sec_str_password = SecureString()\n for c in \"Passwort\": \n sec_str_password.AppendChar(c) 为了在使用时采取进一步的安全措施 CODESYS Git 参见： CODESYS Git 的安全性 " }, 
{ "title" : "准备 ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403341267380", 
"breadcrumbs" : "CODESYS Git \/ 使用 Git 脚本接口 \/ 准备 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS 图书馆 ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm56806682534762", 
"breadcrumbs" : "CODESYS Git \/ 使用 Git 脚本接口 \/ 准备 \/ CODESYS 图书馆 ", 
"snippet" : "因为不是 CODESYS 库目前在 Git 中管理，源代码是 CODESYS 图书馆是必需的。这个 String Functions.library 来自的图书馆 CODESYS String Libraries 示例中使用了产品。...", 
"body" : "因为不是 CODESYS 库目前在 Git 中管理，源代码是 CODESYS 图书馆是必需的。这个 String Functions.library 来自的图书馆 CODESYS String Libraries 示例中使用了产品。 " }, 
{ "title" : "远程 Git 存储库 ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm566365154713912", 
"breadcrumbs" : "CODESYS Git \/ 使用 Git 脚本接口 \/ 准备 \/ 远程 Git 存储库 ", 
"snippet" : "在本示例中，文件系统中的裸露的 Git 存储库用作远程存储库。 要做好准备，请先删除相应的目录，然后创建一个新目录。 import shutil import os  def prepare_empty_dir(empty_dir_path):     print(\"Prepare empty directory at\", empty_dir_path)     shutil.rmtree(empty_dir_path, ignore_errors=True)     if not(os.path.exists(empty_dir_path) and os.path.isdir(empty_d...", 
"body" : "在本示例中，文件系统中的裸露的 Git 存储库用作远程存储库。 要做好准备，请先删除相应的目录，然后创建一个新目录。 import shutil\nimport os \n\ndef prepare_empty_dir(empty_dir_path):\n    print(\"Prepare empty directory at\", empty_dir_path)\n    shutil.rmtree(empty_dir_path, ignore_errors=True)\n    if not(os.path.exists(empty_dir_path) and os.path.isdir(empty_dir_path)):\n        os.makedirs(empty_dir_path) 然后创建一个空的裸露的 Git 存储库。 import subprocess\ndef create_bare_git_repository(bare_repository_path):\n    print(\"Create bare git repository at\", bare_repository_path)\n    create_bare_repository_cmd = 'cmd \/c \"git -C \\\"' + bare_repository_path + '\\\" init --bare\"'\n    try:\n        retcode = subprocess.call(create_bare_repository_cmd, shell=True)\n        if retcode < 0:\n            raise Exception(\"Creating bare git repository at \" + bare_repository_path + \" failed: \", -retcode)\n        else:\n            print(\"Creating bare git repository at \" + bare_repository_path + \" succeeded.\")\n    except Exception as e:\n        print(\"[ERROR] Creating bare git repository failed: \", e)\n        raise 空的裸露的 Git 存储库中充斥着的内容 CODESYS 图书馆。 def initialize_bare_git_repository(library_path, local_repository_path, bare_repository_path):\n    print(\"Open library:\", library_path)\n    project = projects.open(library_path)\n     \n print(\"Initiate local git repository\")\n    project.git.init(local_repository_path)\n    project.git.commit_complete(\"Create git repo for lib\", \"user\", \"mail@mail\")\n     \n print(\"Push to remote git repository\")\n    origin_remote = project.git.remote_add(\"origin\", bare_repository_path)\n    project.git.branch_set_upstream_to(origin_remote)\n    project.git.push()\n    project.git.de_init(cleanUpFileSystem=True)\n    project.close() 以下脚本执行所描述的函数。 import os\n\ndef main():\n    if projects.primary:\n        projects.primary.close()\n\n    basepath = \"C:\\\\CODESYS_Projects\\\\Git_Scripting_Tutorial\\\\\"\n\n    project_basepath = os.path.join(basepath, \"projects\\\\\")\n    library_file_name = \"ExampleLib1.library\"\n    library_path = os.path.join(project_basepath, library_file_name)\n\n    remote_repo_basepath = os.path.join(basepath, \"remotes\\\\\")\n    remote_repo_directory_name = \"ExampleLib1RemoteRepo\"\n    remote_repo_path = os.path.join(remote_repo_basepath, remote_repo_directory_name)\n\n    local_repo_basepath = os.path.join(basepath, \"repos\\\\\")\n    local_repo_directory_name = \"ExampleLib1LocalRepo\"\n    local_repo_path = os.path.join(local_repo_basepath, local_repo_directory_name)\n\n    print(\"Create and push library to remote git repository\")\n    \n prepare_empty_dir(remote_repo_path)\n    create_bare_git_repository(remote_repo_path)\n    initialize_bare_git_repository(library_path, local_repo_path, remote_repo_path)\n\n    print(\"[Success] All done\")\n\n\nif __name__ == '__main__':\n    main() 以这种方式创建并提供内容的裸露的 Git 存储库用于其他示例。 " }, 
{ "title" : "克隆远程 Git 存储库 ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403354678654", 
"breadcrumbs" : "CODESYS Git \/ 使用 Git 脚本接口 \/ 准备 \/ 克隆远程 Git 存储库 ", 
"snippet" : "执行以下函数 git clone 用于远程 Git 存储库。 def clone_git_repository(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path):     update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFlags.SilentMode     project = git.clone(project_basepath, project_file_name, remote_repo_url_or_path...", 
"body" : "执行以下函数 git clone 用于远程 Git 存储库。 def clone_git_repository(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path):\n    update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFlags.SilentMode    \n project = git.clone(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path, update_flags=update_flags)\n    project.save()\n    return project " }, 
{ "title" : "创建和合并新分支 ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_id_CopyofCODESYSGitScriptingUsage-ErstellenundMergeneinesneuenBranches", 
"breadcrumbs" : "CODESYS Git \/ 使用 Git 脚本接口 \/ 准备 \/ 创建和合并新分支 ", 
"snippet" : "以下辅助函数在 a 中创建了一些新对象 CODESYS 以项目为例。 def add_dut(project): ST_STRUCT_STR = \"\"\"\\ a : BOOL; b : BIT; c : BIT; \"\"\" ST_UNION_STR = \"\"\"\\ TYPE ExampleUnion : UNION Zahl : INT; Prozent : ExampleAlias; Bits : ExampleStruct; END_UNION END_TYPE \"\"\" # Create a struct DUT and insert the list of variables just int...", 
"body" : "以下辅助函数在 a 中创建了一些新对象 CODESYS 以项目为例。 def add_dut(project):\n ST_STRUCT_STR = \"\"\"\\\n a : BOOL;\n b : BIT;\n c : BIT;\n \"\"\"\n\n ST_UNION_STR = \"\"\"\\\n TYPE ExampleUnion :\n UNION\n Zahl : INT;\n Prozent : ExampleAlias;\n Bits : ExampleStruct;\n END_UNION\n END_TYPE\n \"\"\"\n\n # Create a struct DUT and insert the list of variables just into the right\n   # place in line two, row 0 (line numbering starts with line 0)\n   example_dut_struct = project.create_dut('ExampleStruct') # DutType.Structure is the default\n   example_dut_struct.textual_declaration.insert(2, 0, ST_STRUCT_STR) \n\n   # Alias types get their \"content\" via the base type, which will just end up \n   # as one line in the declaration part:    \n # TYPE MyAlias : INT (0..100); END_TYPE \n   example_dut_alias = project.create_dut('ExampleAlias', DutType.Alias, \"INT (0..100)\") \n\n   # Instead of injecting the variables into the existing declaration, \n   # one can also just replace the complete declaration part, including the \n   # boilerplate code.\n   example_dut_union = project.create_dut('ExampleUnion', DutType.Union)\n   example_dut_union.textual_declaration.replace(ST_UNION_STR) 以下辅助函数递增项目信息中的编译版本 CODESYS 项目。 def increment_build_version(project):\n \"\"\"\n Increment build version in project info.\n \"\"\"\n info = project.get_project_info()\n old_version = info.version\n info.version = (old_version.Major, old_version.Minor, old_version.Build + 1, 0)\n project.save() 以下函数首先创建一个新分支并在该分支中进行更改，然后将这些更改合并回主分支。 def copy_branch_and_merge(project):\n current_branch = project.git.branch_show_current()\n print(\"Current branch: \", current_branch.friendly_name)\n project, current_branch = project.git.branch_copy(current_branch, \"new_branch\", checkout=True)\n print(\"Current branch: \", current_branch.friendly_name)\n\n add_dut(project)\n project.git.commit_complete(\"Added DUT\", \"user\", \"mail@mail\")\n\n increment_build_version(project)\n project.git.commit_complete(\"Incremented build version\", \"user\", \"mail@mail\")\n\n project, current_branch = project.git.checkout(\"master\")\n print(\"Current branch: \", current_branch.friendly_name)\n project, merge_result = project.git.merge(\"new_branch\")\n print(\"Merged: \", merge_result.ToString())\n project.save()\n return project 以下脚本将执行 git clone 对于远程 Git 存储库，在项目中进行更改，然后将更改推送到远程 Git 存储库 ( CopyBranchAndMerge.py ）。 def main():\n    if projects.primary: \n       projects.primary.close()\n\n    basepath = \"C:\\\\CODESYS_Projects\\\\Git_Scripting_Tutorial\\\\\"\n\n project_basepath = os.path.join(basepath, \"projects\\\\\")\n    library_file_name = \"ExampleLib1Cloned.library\"\n\n remote_repo_basepath = os.path.join(basepath, \"remotes\\\\\")\n    remote_repo_directory_name = \"ExampleLib1RemoteRepo\"\n    remote_repo_path = os.path.join(remote_repo_basepath, remote_repo_directory_name)\n\n local_repo_basepath = os.path.join(basepath, \"repos\\\\\")\n    local_repo_directory_name = \"ExampleLib1LocalRepo\"\n    local_repo_path = os.path.join(local_repo_basepath, local_repo_directory_name)\n\n print(\"Clone project\")\n    project = clone_git_repository(project_basepath, library_file_name, remote_repo_path, local_repo_path)\n project = copy_branch_and_merge(project)\n project.git.push()\n    project.save()\n    project.git.de_init(cleanUpFileSystem=True)\n    project.save()\n    project.close()\n print(\"[Success] All done\")\n\nif __name__ == '__main__':\n    main()) " }, 
{ "title" : "创建编译后的库 ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403356979728", 
"breadcrumbs" : "CODESYS Git \/ 使用 Git 脚本接口 \/ 准备 \/ 创建编译后的库 ", 
"snippet" : "以下脚本将执行 git clone 对于 CODESYS 来自远程 Git 存储库的源库，然后从中创建编译后的库 ( CreateCompiledLibrary.py ）。 import os class CompileError(Exception): pass def clone_git_repository(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path): update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFla...", 
"body" : "以下脚本将执行 git clone 对于 CODESYS 来自远程 Git 存储库的源库，然后从中创建编译后的库 ( CreateCompiledLibrary.py ）。 import os\n\nclass CompileError(Exception):\n pass\n\ndef clone_git_repository(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path):\n update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFlags.SilentMode\n project = git.clone(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path, update_flags=update_flags)\n project.save()\n return project\n\ndef create_compiled_library(project):\n # requires the CODESYS Library Documentation Support Package!\n project.check_all_pool_objects()\n compile_result_message = system.get_messages(category='{97F48D64-A2A3-4856-B640-75C046E37EA9}')[-1]\n if \"0 errors\" in compile_result_message:\n project.save_as_compiled_library(destination_name=None)\n else:\n raise CompileError(\"Compile failed: \" + compile_result_message)\n return project\n\nbasepath = \"D:\\\\JiraTickets\\\\GIT-145\\\\\"\n\nproject_basepath = os.path.join(basepath, \"projects\\\\\")\n\nremote_repo_basepath = os.path.join(basepath, \"remotes\\\\\")\nremote_repo_directory_name = \"StringFunctions.git\"\nremote_repo_path = os.path.join(remote_repo_basepath, remote_repo_directory_name)\n\nlocal_repo_basepath = os.path.join(basepath, \"repos\\\\\")\nlocal_repo_path = os.path.join(local_repo_basepath, \"StringFunctions.git\")\n\nprint(\"Clone project\")\nproject = clone_git_repository(project_basepath, \"String Functions Cloned.library\", remote_repo_path, local_repo_path)\nproject = create_compiled_library(project)\nproject.git.de_init(cleanUpFileSystem=True)\nproject.close()\n\nprint(\"[Success] All done\") " }, 
{ "title" : "从远程 Git 存储库安装库 ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403357071816", 
"breadcrumbs" : "CODESYS Git \/ 使用 Git 脚本接口 \/ 准备 \/ 从远程 Git 存储库安装库 ", 
"snippet" : "以下脚本将执行 git clone 对于 CODESYS 来自远程 Git 存储库的源库，并将此库安装在当前 Git 存储库中 CODESYS 实例（ InstallLibrary.py ）。 import os def clone_git_repository(project_directory_path, project_file_name, remote_repo_url_or_path, local_repo_path):     update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFlags.SilentMode   ...", 
"body" : "以下脚本将执行 git clone 对于 CODESYS 来自远程 Git 存储库的源库，并将此库安装在当前 Git 存储库中 CODESYS 实例（ InstallLibrary.py ）。 import os\n\ndef clone_git_repository(project_directory_path, project_file_name, remote_repo_url_or_path, local_repo_path):\n    update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFlags.SilentMode\n    project = git.clone(project_directory_path, project_file_name, remote_repo_url_or_path, local_repo_path, update_flags=update_flags)\n    project.save()\n    return project\n\ndef install_library(project):\n    library_repo = librarymanager.repositories[0]\n    librarymanager.install_library(project.path, library_repo, True)\n\ndef main():\n    if projects.primary:\n        projects.primary.close()\n\n     basepath = \"C:\\\\CODESYS_Projects\\\\Git_Scripting_Tutorial\\\\\"\n\n    project_basepath = os.path.join(basepath, \"projects\\\\\")\n    library_file_name = \"ExampleLib1Cloned2.library\"\n\n remote_repo_basepath = os.path.join(basepath, \"remotes\\\\\")\n    remote_repo_directory_name = \"ExampleLib1RemoteRepo\"\n    remote_repo_path = os.path.join(remote_repo_basepath, remote_repo_directory_name)\n\n    local_repo_basepath = os.path.join(basepath, \"repos\\\\\")\n    local_repo_directory_name = \"ExampleLib1LocalRepo\"\n    local_repo_path = os.path.join(local_repo_basepath, local_repo_directory_name)\n\n    print(\"Clone project\")\n    project = clone_git_repository(project_basepath, library_file_name, remote_repo_path, local_repo_path)\n\n print(\"Install library\")\n    install_library(project)\n    project.git.de_init(cleanUpFileSystem=True)\n    project.close()\n\n print(\"[Success] All done\")\n\nif __name__ == '__main__':\n    main() " }, 
{ "title" : "Git 操作的消息输出 ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm234656140725653", 
"breadcrumbs" : "CODESYS Git \/ 使用 Git 脚本接口 \/ 准备 \/ 从远程 Git 存储库安装库 \/ Git 操作的消息输出 ", 
"snippet" : "使用时 CODESYS Git ，大多数命令提供基于文本的输出。跑步时 CODESYS 在命令行中，这是在执行期间自动输出的输出 CODESYS Git 通过脚本驱动程序执行命令。使用时 CODESYS Git 在 CODESYS Development System ，输出也会出现在消息窗口中。 Structure of the messages: Git:<severity>: [<time>] <text> In the user interface of CODESYS Git , the output is reduced to: [<time>] <text> severity :...", 
"body" : "使用时 CODESYS Git ，大多数命令提供基于文本的输出。跑步时 CODESYS 在命令行中，这是在执行期间自动输出的输出 CODESYS Git 通过脚本驱动程序执行命令。使用时 CODESYS Git 在 CODESYS Development System ，输出也会出现在消息窗口中。 Structure of the messages: Git:<severity>: [<time>] <text> In the user interface of CODESYS Git , the output is reduced to: [<time>] <text> severity : 消息类别。类别从纯粹的信息错误到严重 time : 发送消息的确切时间。格式： HH:MM:SS text ：消息的内容。对于标准 Git 命令，其内容对应于命令行命令，该命令将提供与脚本驱动程序调用相同的结果。对于 CODESYS Git 与标准 Git 命令不对应的命令（例如， 从存储库中恢复项目 ），消息文本解释了所执行的操作。 Commands with multiple messages: 对于某些命令（例如 git log )，输出被拆分为多条消息。就以下情况而言 git log ，每个显示的提交都显示在单独的消息中。在这种情况下，为了明确这些消息是其中的一部分 git log 命令，消息中引用了原始命令。 " }, 
{ "title" : "参考，用户界面 ", 
"url" : "_git_f_reference_user_interface.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "视图和对话框 ", 
"url" : "_git_struct_reference_views_dialogs.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "查看：Git 状态和暂存 ", 
"url" : "_git_view_status.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 查看：Git 状态和暂存 ", 
"snippet" : "Git 状态和暂存 符号： 相应的 Git 命令： git status 函数 ：该视图显示自上次提交以来已更改或新建的对象和文件的 Git 状态。可以将更改暂存到此处进行提交并提交。可以直接比较这些更改，并且可以从工作目录中删除自上次提交以来的更改。当合并尝试导致冲突或关系问题时，将在此处的视图中显示。 打电话 : Git → 状态和暂存 菜单 要求 ：打开的项目在 Git 中管理。 标题栏： Branch: <branch name> Last commit: <ID> 受影响的姓名分支 The current status of the branch is prepended. 示例： ...", 
"body" : "Git 状态和暂存 符号： 相应的 Git 命令： git status 函数 ：该视图显示自上次提交以来已更改或新建的对象和文件的 Git 状态。可以将更改暂存到此处进行提交并提交。可以直接比较这些更改，并且可以从工作目录中删除自上次提交以来的更改。当合并尝试导致冲突或关系问题时，将在此处的视图中显示。 打电话 : Git → 状态和暂存 菜单 要求 ：打开的项目在 Git 中管理。 标题栏： Branch: <branch name> Last commit: <ID> 受影响的姓名分支 The current status of the branch is prepended. 示例： 合并 ， 未解决的冲突 或者 未解决的关系问题 单击分支的名称可打开 Git 分支 观点。 单击最后一次提交的 ID 将打开 Git 历史 看法。 视图已刷新。 丢弃所有更改 （ git reset --hard ) 无论在表格中做出何种选择，所有更改都将被丢弃，即使是任何未暂存的更改。该项目将重置为尚未提交所有更改之前的状态。 提交完成 （ git commit complete ) 打开 提交暂存和未暂存的更改 对话框（见下文） 比较这些变化： 双击对象条目可打开单独的对象条目 比较视图 （“Diff”），它显示了对象当前状态之间的差异（ 新... ) 和上次提交的状态 ( 基础... ）。有关详细信息，请参阅下面的 “比较视图”。 在项目导航器中查找受影响的对象： 有关更多信息，请参阅 显示这个对象 和 显示所有受影响的对象 对象条目快捷菜单中的命令。 分阶段更改 的顶部 Git 状态 视图显示了为提交而暂存的已更改对象（Git 索引）。这是组织提交暂存和执行提交的地方 物体 物理路径 Git 项目中更改对象的路径 示例： project\\device\\plc_logic\\application\\plc_prg 当 显示物理路径 的快捷菜单中的选项 物体 列已选中， 物理路径 还会显示包含对象完整路径的列。 示例： project\\device_5aca2685\\plc_logic_b738fa32\\application_0dcb78bb\\plc_prg_33759ca0\\33759ca04 b4e4930a972d2050e97661a.object 对象条目的快捷菜单： 显示这个对象 ：该对象在项目导航器中处于选定状态。 显示所有受影响的对象 ：在受冲突或关系问题影响的对象进入时可用：在项目导航器中选择所有尚未解决冲突的对象。 索引状态 ， 详情 索引中对象的 Git 状态（内部） 可能的状态： : 未改变 ：该对象与 Git 存储库中的当前状态相同。 : 全新 （在索引中）：该对象最近已被添加到索引中。它不存在于 Git 存储库中。 : 已修改 （在索引中）：该对象已与索引中的先前版本相比进行了更改。在这种情况下，响应可以是 commit ( git commit ) 或丢弃更改 ( git reset ）。 可以将更改从索引中删除 ( git reset --mixed ): 取消所选更改（git reset--mixed） 更改可以完全丢弃： 丢弃所有更改 （ git reset --hard ) : 已删除 ：该对象已被删除。 注意：索引中的重置操作可能会覆盖工作目录中对象的内容。 丢弃所有更改 （ git reset --hard ) 无论在表格中做出何种选择，所有更改都将被丢弃，即使是任何未暂存的更改。该项目将重置为尚未提交所有更改之前的状态。 提交完成 打开 提交暂存和未暂存的更改 对话框 提交分阶段的更改（git commit） 打开 提交分阶段更改 对话框 提交时，索引中的所有更改（分阶段更改）都将应用于新的提交。工作目录中的更改（未暂存）未应用 取消所选更改（git reset--mixed） 提交的分阶段更改将重置为 “未暂存”。窗口中的条目已删除。 注意：索引中的重置操作可能会覆盖工作目录中对象的内容。 未暂存的更改 的底部 Git 状态 视图显示自上次提交以来在项目中进行的所有更改，以及尚未暂存提交的更改。它们现在可以上演了。这些可能是对已在 Git 存储库中跟踪的对象的更改，也可以是对仍然 “未跟踪” 的对象所做的更改。尚未通过以下方式在 Git 存储库中注册 “未跟踪” 对象 添加 （ git add ) 或 提交 （ git commit ) 命令。 物体 物理路径 Git 项目中更改对象的路径 示例： project\\device\\plc_logic\\application\\plc_prg 为了可能显示 物理路径 ，参见上文 “分阶段更改”。 工作树状态 ， 详情 工作目录中对象的状态： : 未改变 （在工作目录中）：该对象与索引保持不变。 : 全新 （在工作目录中）：该对象存在于工作目录中，但还不在索引或 Git 存储库中。 : 已删除 （在工作目录中）：该对象不再存在于工作目录中，但会在 Git 存储库（索引）中对其进行跟踪。它已经通过以下方式添加过一次 git add 和\/或 git commit 命令。 : 已修改 （在工作目录中）：索引中的对象已与先前版本相比进行了更改。 ：合并对象时出现冲突或关系问题。在这种情况下，快捷菜单包含以下用于处理冲突的命令： 手动解决 ：打开两个受影响提交的比较视图。 使用 \"ours\" ：应用较新提交（“新”）的状态。 使用 \"theirs\" ：旧提交的状态（ 根据 ） 被申请;被应用。 在处理冲突后提交时，提交消息会自动包含受影响对象的列表。 : 舞台变化 （ git add ) 选定的更改将暂存到提交时并移至 分阶段更改 区域。 : 回滚所有未暂存的更改 (git clean & git checkout ) 中列出的所有更改 未暂存的更改 视图被丢弃。 : 切换所有更改的选择 所有更改的选择处于选中或未选中状态。 " }, 
{ "title" : "对话框：提交分阶段更改 ", 
"url" : "_git_view_status.html#UUID-d928d26b-8202-57f2-233c-383ef01152f6_id_c24a156863171e3cc0a8646329f090c1-id-76eeb06c64c0f307c0a86463133e3737", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 查看：Git 状态和暂存 \/ 对话框：提交分阶段更改 ", 
"snippet" : "符号： 函数 ：在对话框中，您可以启动对已分阶段更改的提交或空的提交。 打电话 : 提交完成 命令在 Git 状态 观点 <user name and email> 提交者的姓名和电子邮件地址存储库的这些凭据可以保存在本地存储库的 .gitconfig 中 记住我 。 CODESYS Git 将自动使用它们进行接下来的相应操作。 承诺 <... 提交的目的地。例子： 提交到分支'refs\/heads\/master' <name of the committer> 姓名 和 电子邮件 提交者的地址 在 CODESYS Git , 对提交人和提交人不作区分.因此，此处已将作者指定为提交者。 提交消...", 
"body" : "符号： 函数 ：在对话框中，您可以启动对已分阶段更改的提交或空的提交。 打电话 : 提交完成 命令在 Git 状态 观点 <user name and email> 提交者的姓名和电子邮件地址存储库的这些凭据可以保存在本地存储库的 .gitconfig 中 记住我 。 CODESYS Git 将自动使用它们进行接下来的相应操作。 承诺 <... 提交的目的地。例子： 提交到分支'refs\/heads\/master' <name of the committer> 姓名 和 电子邮件 提交者的地址 在 CODESYS Git , 对提交人和提交人不作区分.因此，此处已将作者指定为提交者。 提交消息 提交消息（必填） 允许空提交 ：如果项目没有变化，则执行 “空” 提交。空提交被用作历史记录中的一种评论或标记。 " }, 
{ "title" : "对话框：提交暂存和未暂存的更改 ", 
"url" : "_git_view_status.html#UUID-d928d26b-8202-57f2-233c-383ef01152f6_id_c24a156863171e3cc0a8646329f090c1-id-8a99954a5b645d73c0a8646331f25fbc", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 查看：Git 状态和暂存 \/ 对话框：提交暂存和未暂存的更改 ", 
"snippet" : "符号： 函数 ：在对话框中，您可以启动项目中所有更改的提交，从而跳过 “已暂存” 状态。就像在 提交分阶段更改 对话框中，你需要指定提交消息，并提供或确认提交者信息。或者，这里也可以进行空提交。 打电话 : 提交完成 命令在 Git 状态 观点...", 
"body" : "符号： 函数 ：在对话框中，您可以启动项目中所有更改的提交，从而跳过 “已暂存” 状态。就像在 提交分阶段更改 对话框中，你需要指定提交消息，并提供或确认提交者信息。或者，这里也可以进行空提交。 打电话 : 提交完成 命令在 Git 状态 观点 " }, 
{ "title" : "比较视图 ", 
"url" : "_git_view_status.html#UUID-d928d26b-8202-57f2-233c-383ef01152f6_id_c24a156863171e3cc0a8646329f090c1-id-17604f183ce6a486c0a86463069dfb21", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 查看：Git 状态和暂存 \/ 比较视图 ", 
"snippet" : "符号： 函数 ：视图显示提交之间的差异。可以接受或放弃更改 打电话 : 双击中的更改 Git 状态。 查看 请勿在比较视图中进行任何更改。唯一的例外：解决任何冲突。 比较视图的功能和处理方式与用于项目比较的比较视图相对应。 The new status of the object ( new (staged|unstaged ) which is created by the change is compared with the last status of the object in the index ( base (head, <object ID>) for the unstaged...", 
"body" : "符号： 函数 ：视图显示提交之间的差异。可以接受或放弃更改 打电话 : 双击中的更改 Git 状态。 查看 请勿在比较视图中进行任何更改。唯一的例外：解决任何冲突。 比较视图的功能和处理方式与用于项目比较的比较视图相对应。 The new status of the object ( new (staged|unstaged ) which is created by the change is compared with the last status of the object in the index ( base (head, <object ID>) for the unstaged changes. For the staged changes, it is compared with the last status in the repository. 有关更多信息 CODESYS 比较视图，请参见： 项目比较 " }, 
{ "title" : "查看：历史 ", 
"url" : "_git_view_history.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 查看：历史 ", 
"snippet" : "历史 相应的 Git 命令： git log 功能 ：视图显示了对项目对象或其他文件执行的提交的历史记录 Git 存储库 .每次提交都会显示更改信息。提交之间的比较是可能的。您还可以直接从提交中创建新分支。 打电话 : Git → 历史 菜单 要求 ：已经为打开的项目执行了 Git 操作。必须至少存在一个提交。 比较 将选定的提交与其在项目存储中的状态进行比较，更改将显示在 比较视图 。 当选择两个提交时，将对它们进行比较。 图表 分叉和合并的可视化表示 分支机构 在分支上执行的连续提交按时间顺序（从下到上）显示。各个分支彼此相邻排列，可以通过不同的颜色进行区分。 最左边是 “主” 分支，旁边...", 
"body" : "历史 相应的 Git 命令： git log 功能 ：视图显示了对项目对象或其他文件执行的提交的历史记录 Git 存储库 .每次提交都会显示更改信息。提交之间的比较是可能的。您还可以直接从提交中创建新分支。 打电话 : Git → 历史 菜单 要求 ：已经为打开的项目执行了 Git 操作。必须至少存在一个提交。 比较 将选定的提交与其在项目存储中的状态进行比较，更改将显示在 比较视图 。 当选择两个提交时，将对它们进行比较。 图表 分叉和合并的可视化表示 分支机构 在分支上执行的连续提交按时间顺序（从下到上）显示。各个分支彼此相邻排列，可以通过不同的颜色进行区分。 最左边是 “主” 分支，旁边是链接到它的分支。 普通提交由圆圈符号标识，合并提交由方形符号标识。提交的圆圈符号之间的线条显示了它们被分叉或合并的时间 在 Git 工具中分配的 Git 标签以标签图标显示。 对于向共同远程主服务器的提交，包括其名称（例如， origin\/master ）。 留言 提交消息 作者 提交的作者 创作 提交日期 SHA1 “安全哈希算法 1\" SHA1 是一个哈希值，具有提交的唯一 ID 的功能。 将显示上面所选提交的以下信息： 详情 <text of the commit message> SHA1 : “安全哈希算法 1\" SHA1 是一个哈希值，具有提交的唯一 ID 的功能。 作者 变更作者的姓名 提交者 变更提交者的姓名 路径 物理路径 对象在 Git 工作目录中的路径 CODESYS 项目 示例： project\\device\\plc_logic\\application\\plc_prg 当 显示物理路径 的快捷菜单中的选项 物体 列已选中， 物理路径 还会显示包含对象完整路径的列。 示例： project\\device_5aca2685\\plc_logic_b738fa32\\application_0dcb78bb\\plc_prg_33759ca0\\33759ca04 b4e4930a972d2050e97661a.object 物体名称 中对象的名称 CODESYS 项目，或 Git 存储库中其他文件的名称 示例： PLC_PRG ， Device ， .gitattributes 物体类型 中的对象类型 CODESYS 项目或文件类型 示例： DeviceObject ， .gitattributes 有点变化 已经做出的那种改变 示例： Added ， Deleted ， Modified ， Renamed ， Moved 双击更改会打开比较视图，该视图从 状态和分期 看法。新提交的更改（ 新对象 <提交 ID> ） 被展示。该视图仅用于信息目的。信息无法编辑。 你可以使用 通过提交创建分支 在快捷菜单中使用命令直接为选定的提交创建新分支。 " }, 
{ "title" : "查看：Git 分支 ", 
"url" : "_git_view_branches.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 查看：Git 分支 ", 
"snippet" : "Git 分支 符号： 相应的 Git 命令： git branch 函数 ：本地 Git 分支在视图中显示和管理。这些分支可以是已经在跟踪远程分支的分支，也可以是纯粹存在于本地且不包含任何远程存储库链接的分支。 打电话 : Git → 分支 菜单 要求 ：存储库中至少存在一次提交。 视图已刷新。 复制 （ git copy ) 打开 创建新分支 对话框创建新的本地分支作为当前选定本地分支的副本（见上文） 删除 （ git branch -D ) 所选分支将被删除，即使该分支尚未完全合并。 注意：无法删除当前分支。 结账 （ git checkout ) 由于 Checkout 操作，所选分支将...", 
"body" : "Git 分支 符号： 相应的 Git 命令： git branch 函数 ：本地 Git 分支在视图中显示和管理。这些分支可以是已经在跟踪远程分支的分支，也可以是纯粹存在于本地且不包含任何远程存储库链接的分支。 打电话 : Git → 分支 菜单 要求 ：存储库中至少存在一次提交。 视图已刷新。 复制 （ git copy ) 打开 创建新分支 对话框创建新的本地分支作为当前选定本地分支的副本（见上文） 删除 （ git branch -D ) 所选分支将被删除，即使该分支尚未完全合并。 注意：无法删除当前分支。 结账 （ git checkout ) 由于 Checkout 操作，所选分支将成为当前分支。这意味着 Git 操作对该分支的内容进行操作，为此，这些内容被加载到本地 Git 存储库（“工作目录”）中。 未提交的更改会阻止签出。 When dealing with a remote branch – an entry under Remote (<n>) – the following options are possible: 将打开一个对话框，显示以下消息： 本地 “主” 分支已经跟踪了这个远程分支，改为检出该分支。分支名称 “起源\/主 。 In this case, there is already a local remote branch (under Local (<n>) ) which tracks the currently selected remote branch and can therefore Pull and Push with it. Then this local branch is loaded into the working directory for editing. It is possible that the checkout is denied at first, because of inconsistencies caused by local changes made directly in the working directory. With the Force option, these inconsistencies can be accepted initially and the checkout can still be performed. Checking out this remote branch will create a corresponding local tracking branch. This name for the local branch is already used. The operation will most likely fail. 在这种情况下，还没有本地远程分支跟踪当前选定的远程分支。 CODESYS Git 想要创建一个本地分支，但它的名称已经在使用中。随着 原力 选项，仍然可以强制执行该操作。 注意：现有分支将被此覆盖。 尚无本地远程分支。没有追踪信息。此分支现已创建并设置为 “当前”，跟踪已激活。这意味着该分支机构的工作将立即继续。 合并 （ git merge ) 单击该按钮将直接执行该命令。或者，您也可以为其设置选项。为此，请使用 箭头键选择 与选项合并 命令。这 合并分支 对话框打开，您可以在其中选择 选项 这对当前合并操作有效。 合并需要用户的姓名和电子邮件地址。此信息取自 Git 设置。如果这不可能，则会打开一个对话框提示。用户名和电子邮件地址可以在中更改 合并分支 对话框。 当您确认请求（对话框提示）是否确实要提交时，当前选定分支的提交将提交到当前分支。当前分支是其状态现在位于工作目录中的分支。（勾选标记 当前 专栏） 如果合并时发生冲突，则必须先解决冲突。视情况而定合并 选项 ，将运行自动操作或需要手动操作。如果冲突无法自动解决，则会在 Git 状态和暂存 看法。对于第一步中的冲突解决，请注意上下文中提供的上下文菜单命令 状态与分期 看法。另请参阅 合并冲突，“关系问题” 帮助页面。 只要合并操作尚未完成，状态信息 Merging 显示在视图标题和任务栏中。 这个 合并 操作需要用户的姓名和电子邮件地址。此信息取自 Git 项目设置 。如果这不可能，则会打开一个对话框提示。 上游：设置\/清除 git push -u origin local-branch git branch --set-upstream-to <origin\/remote-branch> 打开 为 Branch 设置上游远程 对话框 这里创建了一个与本地分支相对应的分支，并将与该分支的链接设置在链接的远程存储库上（例如，通常命名为 “origin”，位于服务器上）。 赛道分支 git branch --track 打开 追踪远程分支 对话框 在这里，本地分支可以链接到远程存储库（远程分支）的可用代表。这允许交换提交 (Git) 操作 拉 和 推 ) 在本地存储库和远程存储库之间。 拉 （ git pull ) 使用期权进行拉动 跟踪的远程存储库分支的状态是在本地分支中获取的 ( git fetch ) 并与之合并 ( git merge ）。要求：本地分支跟踪远程存储库的远程分支。 这 拉 操作需要用户的姓名和电子邮件地址。此信息取自 Git 设置。如果不可能，则会在对话框中提示他们。 这个 使用期权进行拉动 命令明确打开此对话框以便可以编辑设置。如果 记住我 选项已启用 姓名 和 电子邮件 凭据，则对话框中的设置将保存在 Git 配置文件中 .git\/config 在本地存储库中。 推 （ git push ) 如果所选分支不是跟踪分支，则 推送分支 对话框打开。您可以在此处指定要合并到的远程分支。本地分支的提交被推送到远程存储库中的相应分支。 如果所选分支是跟踪分支，则会立即执行该操作。未打开任何对话框。 比较 将所选分支与项目存储中项目的最后状态进行比较，并将差异显示在 比较视图 。 当选择两个分支时，将对它们进行比较。 筛选分支：本地|远程 By clicking the Local (<n>) and\/or Remote (<n>) buttons, the display of local branches and\/or remote branches (\"representatives\" of the branches located in the remote repository) is enabled or disabled in the table. Table 当前 : ：这是目前正在开展工作的本地分支机构。这个 Checkout 操作用于使分支成为当前分支。工作目录（Git 存储库）包含该分支的确切当前状态。 远程 : ：这是位于远程存储库中的 “远程分支”。此处的条目用作该分支机构的代表（例如， origin\/master 作为远程存储库的代表分支）。 追踪 : : 本地分支跟踪远程分支，因此与其关联以使用 Git 操作交换提交。 姓名 : 分支机构名称 权威名称 : 分支的唯一名称 示例： refs\/heads\/master 远程 : 远程分支引用的远程存储库的名称（通常 origin ) 上游分支权威名称 示例： refs\/heads\/master 追踪的分支名称 : 被跟踪的远程分支的名称 示例： origin\/master 追踪的分支权威名称 : 被跟踪的远程分支的规范名称。示例： remotes\/origin\/master 当分支跟踪远程分支时，以下信息是相关的。注意：只有在出现以下情况时才会刷新此显示屏 取 命令被执行： 提前承诺 : 本地（跟踪）分支上其时间 “提前” 远程分支的提交次数 落后的承诺 ：本地（跟踪）分支落后于远程分支的提交数量。 " }, 
{ "title" : "创建新分支 对话 ", 
"url" : "_git_view_branches.html#UUID-97ba347b-85e1-cc8a-9709-7e25d06325fd_id_c9b5a632b41e5c0a8646364f8237e-id-de5b4ae7906a11eba659cf2e134a78be", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 查看：Git 分支 \/ 创建新分支 对话 ", 
"snippet" : "相应的 Git 命令： git branch --copy 符号： 函数 : 创建一个新的本地分支。 打电话 : 复制 命令在 当地分支机构 查看 要求 ：本地分支已经存在。 源分支 被复制的分支的名称 新分支名称 新分支名称的输入字段 原力 ：如果在签出时有未提交的更改，则默认情况下无法切换分支。但是，这可以通过选定的方式强制执行 原力 选项。 结账 ：新分支在创建时会立即签出，选中时勾选为 当前 。...", 
"body" : "相应的 Git 命令： git branch --copy 符号： 函数 : 创建一个新的本地分支。 打电话 : 复制 命令在 当地分支机构 查看 要求 ：本地分支已经存在。 源分支 被复制的分支的名称 新分支名称 新分支名称的输入字段 原力 ：如果在签出时有未提交的更改，则默认情况下无法切换分支。但是，这可以通过选定的方式强制执行 原力 选项。 结账 ：新分支在创建时会立即签出，选中时勾选为 当前 。 " }, 
{ "title" : "对话框：合并分支 ", 
"url" : "_git_view_branches.html#UUID-97ba347b-85e1-cc8a-9709-7e25d06325fd_section-idm4555057866660833047299804314", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 查看：Git 分支 \/ 对话框：合并分支 ", 
"snippet" : "符号： 函数 ：为当前合并操作设置合并选项。这些选项是在中预定义的 CODESYS 选项，可以在此处针对个别情况进行更改 合并分支 对话框。 打电话 : 合并 中的按钮 分支机构 对话框； 与选项合并 命令 要求 : 在 Git 分支 视图中，选择了一个分支，该分支应合并到当前已签出的分支中。 要合并的分支 在中选择的分支 Git 分支 查看 用户名和电子邮件地址 当文本展开时， 姓名 和 电子邮件 可以更改。 字段的内容是从 Git 设置中预设的 user.name 和 user.email 。如果这些 Git 设置不可用，则用户需要指定值。 Git 合并选项 合并冲突策略 有关更多信息，请...", 
"body" : "符号： 函数 ：为当前合并操作设置合并选项。这些选项是在中预定义的 CODESYS 选项，可以在此处针对个别情况进行更改 合并分支 对话框。 打电话 : 合并 中的按钮 分支机构 对话框； 与选项合并 命令 要求 : 在 Git 分支 视图中，选择了一个分支，该分支应合并到当前已签出的分支中。 要合并的分支 在中选择的分支 Git 分支 查看 用户名和电子邮件地址 当文本展开时， 姓名 和 电子邮件 可以更改。 字段的内容是从 Git 设置中预设的 user.name 和 user.email 。如果这些 Git 设置不可用，则用户需要指定值。 Git 合并选项 合并冲突策略 有关更多信息，请参阅： 选项：Git快进策略 有关更多信息，请参阅： 选项：Git承诺成功 如果合并成功，则生成的更改将自动提交。 " }, 
{ "title" : "查看：Git Remotes ", 
"url" : "_git_view_remotes.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 查看：Git Remotes ", 
"snippet" : "Git 遥控器 符号： 相应的 Git 命令： git remote 功能 ：视图用于管理 远程存储库 , 用于管理 CODESYS 多个用户应该能够工作的项目。单个用户的本地存储库可以建立到共享远程存储库的链接，并在那里同步\/合并他们的提交。 确保您与远程服务器建立了安全连接。有关更多信息，请参阅： CODESYS Git 的安全性 打电话 : Git → 遥控器 菜单 要求 ：项目是在 Git 中打开和管理的。 视图已刷新。 添加 打开 添加新的遥控器 对话框来指定远程存储库 CODESYS 项目应该关联 别名 注意：在 Git 中，远程存储库的常用名称是 origin 。 网址 : 远程...", 
"body" : "Git 遥控器 符号： 相应的 Git 命令： git remote 功能 ：视图用于管理 远程存储库 , 用于管理 CODESYS 多个用户应该能够工作的项目。单个用户的本地存储库可以建立到共享远程存储库的链接，并在那里同步\/合并他们的提交。 确保您与远程服务器建立了安全连接。有关更多信息，请参阅： CODESYS Git 的安全性 打电话 : Git → 遥控器 菜单 要求 ：项目是在 Git 中打开和管理的。 视图已刷新。 添加 打开 添加新的遥控器 对话框来指定远程存储库 CODESYS 项目应该关联 别名 注意：在 Git 中，远程存储库的常用名称是 origin 。 网址 : 远程存储库的 URL 或文件路径 目前支持以下协议：HTTP、HTTPS、本地。 Examples: file:\/\/\/D:\/GitRep\/Remote\/<repository name> , https:\/\/dockerhostpde\/testuser1\/publicproject.git 移除 系统会提示用户是否从项目中删除指向远程存储库的链接。 注意：属于已删除远程存储库的所有远程分支都将被删除。保留本地分支，但不再跟踪已删除的远程分支。此操作无法撤消 重命名 这个 别名 可以更改远程存储库的内容。 设置网址 Opens the Set URL for Remote <remote> dialog Here, the path specification (URL or file path) for the currently used remote repository can be changed. Changing the path information and therefore the link to the remote repository can cause remote branches to disappear. Therefore, the user has to reassign the mappings from local branches to remote branches (tracking). The local branches are not changed. 取 取 （修剪） 远程存储库的本地代表（例如： origin\/master ) 使用所有用户使用的远程存储库的状态进行更新。所有更改均从远程存储库中应用。这些都是远程分支中的新分支和新提交。但是，提交不适用于跟踪分支。 注意：要使用远程分支的当前状态更新本地分支， 拉 还必须在中执行操作 Git 分支 观点。 作为一种选择，你可以获得 提取（修剪） 通过以下方式指挥 按钮。此 fetch 命令的效果是将不再存在于远程存储库中的远程分支从本地存储库中删除。 全权证书 该按钮可打开 编辑凭证 对话框。这个 用户名 和 密码 可以在此处指定和编辑远程存储库的访问权限。 对于选定的远程存储库 ( 远程名称 ），列表框提供每个 网址 存储库可以为此提供证书。然后，可以保存、删除或更改所选 URL 的凭据。建议您将第一个 URL 的凭据存储在列表框中，因为随后它们也可以重复用于 “域” 内的其他项目。有关处理特定域名凭证的详细信息 需要证书。 在对话框中进行编辑取代 Windows 凭据管理器中的编辑。 Note: A PAT (personal access token) is required when working with GitHUb. Then the PAT has to be specified instead of the password. Example of a PAT in GitHub: ghp_WPZP1ijlX4E<xxxxxxxxxxxxxxxxxx> 桌子 姓名 : 远程存储库的别名 网址 远程存储库的 URL 或文件路径 " }, 
{ "title" : "查看：Git 项目设置 ", 
"url" : "_git_view_project_settings.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 查看：Git 项目设置 ", 
"snippet" : "Git 项目设置 函数 ：此视图显示当前的项目设置 CODESYS 项目（“Git 项目”），在 Git 的帮助下进行管理 CODESYS Git 。 打电话 : Git → Git 项目设置 菜单 要求 : 一个 Git 项目已打开。 Git 项目存储路径 Git 项目存储路径（本地 Git 存储库），其中 CODESYS Git 管理项目文件 路径是在什么时候定义的 Git 链接已初始化 ( Git 初始化 要么 Git 克隆 ）。不要与 Git 管理之外的附加存储位置相混淆 CODESYS 项目文件（双重数据管理）。...", 
"body" : "Git 项目设置 函数 ：此视图显示当前的项目设置 CODESYS 项目（“Git 项目”），在 Git 的帮助下进行管理 CODESYS Git 。 打电话 : Git → Git 项目设置 菜单 要求 : 一个 Git 项目已打开。 Git 项目存储路径 Git 项目存储路径（本地 Git 存储库），其中 CODESYS Git 管理项目文件 路径是在什么时候定义的 Git 链接已初始化 ( Git 初始化 要么 Git 克隆 ）。不要与 Git 管理之外的附加存储位置相混淆 CODESYS 项目文件（双重数据管理）。 " }, 
{ "title" : "对话框：需要证书 ", 
"url" : "_git_dlg_credentials_needed.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 对话框：需要证书 ", 
"snippet" : "需要证书 功能 ：该对话框用于提供访问 远程仓库 . 打电话 ：当您要访问受保护的远程存储库时，该对话框将打开 CODESYS Git 。例如，这是通过以下方式完成的 Fetch 命令在 遥控器 观点。 在多次尝试提供正确凭证的服务器失败后，该操作将中止，并显示相应的消息。 确保您与远程服务器建立了安全连接。有关更多信息，请参阅： CODESYS Git 的安全性 通过 Git 服务器远程存储库的凭据可以在 Git 遥控器 看法。您无需切换到 Windows 凭据管理器即可执行此操作。 在 Git 遥控器 视图，您可以通过 Git 服务器更改远程存储库的凭据。您无需切换到 Windows 凭据...", 
"body" : "需要证书 功能 ：该对话框用于提供访问 远程仓库 . 打电话 ：当您要访问受保护的远程存储库时，该对话框将打开 CODESYS Git 。例如，这是通过以下方式完成的 Fetch 命令在 遥控器 观点。 在多次尝试提供正确凭证的服务器失败后，该操作将中止，并显示相应的消息。 确保您与远程服务器建立了安全连接。有关更多信息，请参阅： CODESYS Git 的安全性 通过 Git 服务器远程存储库的凭据可以在 Git 遥控器 看法。您无需切换到 Windows 凭据管理器即可执行此操作。 在 Git 遥控器 视图，您可以通过 Git 服务器更改远程存储库的凭据。您无需切换到 Windows 凭据管理器即可执行此操作。有关处理特定域名凭证的信息，请参阅下文 用户 远程存储库的用户名 密码 远程存储库的密码，可能为空密码 保存 ：凭据会自动保存在 Windows 凭据管理器中。 之后当您再次访问远程存储库时，系统将不再提示您提供凭证。 " }, 
{ "title" : "特定域名证书 ", 
"url" : "_git_dlg_credentials_needed.html#UUID-933ca5ae-45c1-256f-cb97-3e472b5757e0_section-idm234662684414694", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 对话框：需要证书 \/ 特定域名证书 ", 
"snippet" : "远程存储库可以在主机服务器上共享主机名或路径。在这种情况下，为主机 URL 保存的凭据可用于所有具有相同主机名的项目。 示例：与 URL 一起保存的凭证 git:https:\/\/gitlab.com\/user 可以用于带有 URL 的存储库 git:https:\/\/gitlab.com\/user\/project1.git 以及带有 URL 的存储库 git:https:\/\/gitlab.com\/user\/project2.git 因为该 URL 是两个存储库 URL 的一部分。这意味着只需要为多个存储库创建一组证书。...", 
"body" : "远程存储库可以在主机服务器上共享主机名或路径。在这种情况下，为主机 URL 保存的凭据可用于所有具有相同主机名的项目。 示例：与 URL 一起保存的凭证 git:https:\/\/gitlab.com\/user 可以用于带有 URL 的存储库 git:https:\/\/gitlab.com\/user\/project1.git 以及带有 URL 的存储库 git:https:\/\/gitlab.com\/user\/project2.git 因为该 URL 是两个存储库 URL 的一部分。这意味着只需要为多个存储库创建一组证书。 " }, 
{ "title" : "使用存储的凭证 ", 
"url" : "_git_dlg_credentials_needed.html#UUID-933ca5ae-45c1-256f-cb97-3e472b5757e0_section-idm234662700956759", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 对话框：需要证书 \/ 使用存储的凭证 ", 
"snippet" : "在 CODESYS Git ，当执行需要凭据的远程操作时， CODESYS Git 按以下步骤搜索有效的凭证： 从存储库的完整 URL 开始，系统会搜索 URL 的每个部分路径的存储凭据，直到找到一个条目，然后使用该条目进行身份验证。 如果凭据无效，则会打开一个对话框提示，其中包含以下选项： 使用要输入的新凭据覆盖当前凭证 从 Windows 凭据中删除凭据，然后根据当前显示的 URL 再次搜索条目。 如果在此次搜索中未找到有效的凭据，则会打开一个对话框提示您输入最常用的 URL 的凭据。然后，这些凭证将来也可以用于此 URL 下的其他项目。...", 
"body" : "在 CODESYS Git ，当执行需要凭据的远程操作时， CODESYS Git 按以下步骤搜索有效的凭证： 从存储库的完整 URL 开始，系统会搜索 URL 的每个部分路径的存储凭据，直到找到一个条目，然后使用该条目进行身份验证。 如果凭据无效，则会打开一个对话框提示，其中包含以下选项： 使用要输入的新凭据覆盖当前凭证 从 Windows 凭据中删除凭据，然后根据当前显示的 URL 再次搜索条目。 如果在此次搜索中未找到有效的凭据，则会打开一个对话框提示您输入最常用的 URL 的凭据。然后，这些凭证将来也可以用于此 URL 下的其他项目。 " }, 
{ "title" : "双重身份验证 ", 
"url" : "_git_dlg_credentials_needed.html#UUID-933ca5ae-45c1-256f-cb97-3e472b5757e0_section-idm4575047671689634318583574228", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 对话框：需要证书 \/ 双重身份验证 ", 
"snippet" : "连接到 GitHub 或 GitLab 等 Git 平台可能需要双重身份验证。如果是这种情况，那么您首先需要在相应平台中创建 PAT（个人访问令牌），并在 CODESYS Git 在里面 需要凭证 对话框中输入密码或用户名。下表包含为各个 Git 平台创建和使用 PAT 的信息。 Git 平台 身份验证所需信息 创建 PAT 的详细信息 GitHub 用户 ： 用户名 密码 ：PAT（而不是密码） GitHub： PAT GitLab 用户 ：用户名可选（目前忽略） 密码 ：PAT（而不是密码） GitLab：个人访问令牌 Bitbucket User : User name Password...", 
"body" : "连接到 GitHub 或 GitLab 等 Git 平台可能需要双重身份验证。如果是这种情况，那么您首先需要在相应平台中创建 PAT（个人访问令牌），并在 CODESYS Git 在里面 需要凭证 对话框中输入密码或用户名。下表包含为各个 Git 平台创建和使用 PAT 的信息。 Git 平台 身份验证所需信息 创建 PAT 的详细信息 GitHub 用户 ： 用户名 密码 ：PAT（而不是密码） GitHub： PAT GitLab 用户 ：用户名可选（目前忽略） 密码 ：PAT（而不是密码） GitLab：个人访问令牌 Bitbucket User : User name Password : PAT (instead of the password) Bitbucket Support: Create a Repository Access Token " }, 
{ "title" : "对话框：选择 Git 存储库位置 ", 
"url" : "_git_dlg_extract_git_repository.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 对话框：选择 Git 存储库位置 ", 
"snippet" : "选择 Git 存储库位置 函数 ：在此对话框中，在提取存储库时，您可以为该存储库定义新的存储位置 CODESYS 该项目还包含一个 Git 存储库。 打电话 : 文件 → 项目存档 → 提取存档 命令，选择 Git 存储库 对象， 提取 按钮 要求 ：要提取的项目存档包含 Git 存储库。 选择 Git 存储库位置 本地文件系统中 Git 存储库的有效路径 示例： D:\\GIT_LOCAL\\proj_xy 。参见 Git → 项目设置 观点。...", 
"body" : "选择 Git 存储库位置 函数 ：在此对话框中，在提取存储库时，您可以为该存储库定义新的存储位置 CODESYS 该项目还包含一个 Git 存储库。 打电话 : 文件 → 项目存档 → 提取存档 命令，选择 Git 存储库 对象， 提取 按钮 要求 ：要提取的项目存档包含 Git 存储库。 选择 Git 存储库位置 本地文件系统中 Git 存储库的有效路径 示例： D:\\GIT_LOCAL\\proj_xy 。参见 Git → 项目设置 观点。 " }, 
{ "title" : "对话框：Git 项目恢复 ", 
"url" : "_git_dlg_project_recovery.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 对话框：Git 项目恢复 ", 
"snippet" : "Git 项目恢复 函数 : 在对话框中，你可以定义加载时会发生什么 CODESYS 项目无法再访问相应的 Git 存储库。 打电话 : 对话框在中打开 Git 项目时打开 CODESYS 如果找不到保存的 Git 存储库路径或由于其他原因打开项目失败。 文本字段中会显示尝试从存储库加载 Git 项目失败的描述。它包含在消息窗口中查看 Git 消息的注释。 选项 关闭项目 没有更多动作了 从项目中移除 git 连接 Git 项目设置中的 Git 存储库信息已删除。该项目不再由正在保存的 Git 进行管理。 使用现有的存储库路径 该项目新链接到本地文件系统中的有效 Git 存储库。需要在对话框中输...", 
"body" : "Git 项目恢复 函数 : 在对话框中，你可以定义加载时会发生什么 CODESYS 项目无法再访问相应的 Git 存储库。 打电话 : 对话框在中打开 Git 项目时打开 CODESYS 如果找不到保存的 Git 存储库路径或由于其他原因打开项目失败。 文本字段中会显示尝试从存储库加载 Git 项目失败的描述。它包含在消息窗口中查看 Git 消息的注释。 选项 关闭项目 没有更多动作了 从项目中移除 git 连接 Git 项目设置中的 Git 存储库信息已删除。该项目不再由正在保存的 Git 进行管理。 使用现有的存储库路径 该项目新链接到本地文件系统中的有效 Git 存储库。需要在对话框中输入新的存储库路径，并将自动应用于 Git 项目设置 保存项目时。 注意：所选存储库应与项目相匹配。 " }, 
{ "title" : "对话框：选项：Git ", 
"url" : "_git_dlg_options_git.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 视图和对话框 \/ 对话框：选项：Git ", 
"snippet" : "选项：Git 符号： 功能：对话框包含以下设置 CODESYS Git .有关更多信息 CODESYS 选项，请参阅： 对话框：选项 致电：菜单 证书处理 始终接受证书 默认情况下禁用 ：服务器发送的证书即使无效，也始终会被接受。它未标记为可信。 接受自签名证书 默认情况下禁用 ：还接受自签名证书（这些证书通常会被拒绝）。 如果未选择该选项且没有可信证书，则会收到一条错误消息。然后，您可以查看证书的详细信息并决定是否应建立连接。 Git 拉取\/合并选项 Git Pull\/Git 合并 这些选项仅影响 Git 冲突 。 合并冲突策略 选项： 应用自动合并（如果可用） ：只要受影响的对象类型可用，...", 
"body" : "选项：Git 符号： 功能：对话框包含以下设置 CODESYS Git .有关更多信息 CODESYS 选项，请参阅： 对话框：选项 致电：菜单 证书处理 始终接受证书 默认情况下禁用 ：服务器发送的证书即使无效，也始终会被接受。它未标记为可信。 接受自签名证书 默认情况下禁用 ：还接受自签名证书（这些证书通常会被拒绝）。 如果未选择该选项且没有可信证书，则会收到一条错误消息。然后，您可以查看证书的详细信息并决定是否应建立连接。 Git 拉取\/合并选项 Git Pull\/Git 合并 这些选项仅影响 Git 冲突 。 合并冲突策略 选项： 应用自动合并（如果可用） ：只要受影响的对象类型可用，就应使用自动合并功能。 因冲突而失败（请勿合并） ：如果发生冲突，合并操作将中止，并显示错误消息。 让用户解决冲突 : 从根本上讲，冲突必须手动处理。有关更多信息，请参阅： 合并冲突，“关系问题”使用 “我们的” 来处理冲突 : CODESYS Git 合并时应尝试通过始终使用目标分支的内容来解决冲突。 使用 “他们的” 来处理冲突 : CODESYS Git 合并时应尝试通过始终使用源分支的内容来解决冲突。 快进策略 选项： 如果可能，使用快进 : 合并时会自动应用源分支的提交，其时间是在两个分支中已经存在的提交之后。在这种情况下，历史记录中不会创建任何合并提交条目。如果提交不一致，则不会进行快进。 不能快进 仅限快进（否则失败） : 尝试合并总是使用快进策略。如果未满足要求，则合并将失败并显示相应的消息。 快进的典型用例：Pull 承诺成功 : ：如果在没有任何冲突的情况下执行了拉取或合并操作，则还会自动执行提交。如果快进成功，则该选项无效。 消息报告 冗长级别 细节级别的选择： 默认 : 基本信息（例如，带有操作成功信息的命令名称，无详细信息） Verbose ：关于结果和中间步骤的更多信息。有助于在操作中编写脚本，而无需 CODESYS 用户界面。 " }, 
{ "title" : "菜单命令 ", 
"url" : "_git_struct_reference_commands.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：Git 项目设置 ", 
"url" : "_git_cmd_git_project_settings.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：Git 项目设置 ", 
"snippet" : "Git 项目设置 函数 : 该命令会打开 Git 项目设置 观点。该视图显示当前打开的项目的 Git 项目存储（本地存储库）路径。 打电话 : Git 菜单 要求 : 公开赛 CODESYS 项目在 Git 的本地存储库中管理。...", 
"body" : "Git 项目设置 函数 : 该命令会打开 Git 项目设置 观点。该视图显示当前打开的项目的 Git 项目存储（本地存储库）路径。 打电话 : Git 菜单 要求 : 公开赛 CODESYS 项目在 Git 的本地存储库中管理。 " }, 
{ "title" : "命令：状态和暂存 ", 
"url" : "_git_cmd_status_and_staging.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：状态和暂存 ", 
"snippet" : "状态和阶段 符号： （ git status ) 功能 ：该命令打开 Git 状态和暂存 看法。该视图显示自上次提交以来已更改的对象的 Git 状态。在视图中，已为 Git 提交（暂存）准备更改的对象，并将准备好的对象提交到链接的本地 Git 存储库。 打电话 : Git 菜单 要求 : 公开赛 CODESYS 项目在本地 Git 存储库中管理。...", 
"body" : "状态和阶段 符号： （ git status ) 功能 ：该命令打开 Git 状态和暂存 看法。该视图显示自上次提交以来已更改的对象的 Git 状态。在视图中，已为 Git 提交（暂存）准备更改的对象，并将准备好的对象提交到链接的本地 Git 存储库。 打电话 : Git 菜单 要求 : 公开赛 CODESYS 项目在本地 Git 存储库中管理。 " }, 
{ "title" : "命令：分支 ", 
"url" : "_git_cmd_branches.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：分支 ", 
"snippet" : "分支机构 符号： （ git branch ) 功能 ：该命令打开 Git 分支 查看 Git 存储库中工作分支的创建和管理位置。 打电话 : Git 菜单 要求 : 公开赛 CODESYS 项目在本地 Git 存储库中管理。...", 
"body" : "分支机构 符号： （ git branch ) 功能 ：该命令打开 Git 分支 查看 Git 存储库中工作分支的创建和管理位置。 打电话 : Git 菜单 要求 : 公开赛 CODESYS 项目在本地 Git 存储库中管理。 " }, 
{ "title" : "命令：遥控器 ", 
"url" : "_git_cmd_remotes.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：遥控器 ", 
"snippet" : "遥控器 快捷方式： F7 （ git remote ) 功能 ：该命令打开 遥控器 看法。在视图中，远程存储库被管理，这些存储库与本地 Git 存储库一起用于 CODESYS 下的项目 CODESYS Git . 打电话 : Git 菜单 要求 : A CODESYS 项目是在 Git 的本地 Git 存储库中打开和管理的。...", 
"body" : "遥控器 快捷方式： F7 （ git remote ) 功能 ：该命令打开 遥控器 看法。在视图中，远程存储库被管理，这些存储库与本地 Git 存储库一起用于 CODESYS 下的项目 CODESYS Git . 打电话 : Git 菜单 要求 : A CODESYS 项目是在 Git 的本地 Git 存储库中打开和管理的。 " }, 
{ "title" : "命令：历史 ", 
"url" : "_git_cmd_history.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：历史 ", 
"snippet" : "历史 （ git log ) 功能 ：该命令打开 历史 看法。该视图显示存储库中的提交历史记录。 打电话 : Git 菜单 要求 : 公开赛 CODESYS 项目在本地 Git 存储库中管理。...", 
"body" : "历史 （ git log ) 功能 ：该命令打开 历史 看法。该视图显示存储库中的提交历史记录。 打电话 : Git 菜单 要求 : 公开赛 CODESYS 项目在本地 Git 存储库中管理。 " }, 
{ "title" : "命令：Git 初始化 ", 
"url" : "_git_cmd_git_init.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：Git 初始化 ", 
"snippet" : "Git 初始化 （ git init ) 功能 ：该命令打开 初始化 Git 存储库 初始化本地的对话框 Git 存储库 对于公开 CODESYS 项目。在初始化过程中，项目被导入到 Git 中，它会创建一个本地存储库和项目的索引（Git 项目存储）。结果，创建了项目的 Git 工作目录。 打电话 : Git 菜单 要求 : A CODESYS 项目已打开。 当设置了加密时 CODESYS 项目（ CODESYS - 项目设置 — 安全 ），Git 存储库（既不是本地存储库也不是远程存储库）不会自动受到相应的保护。 对话框： 初始化 Git 存储库 本地 Git 目录路径的输入字段 文件系统中...", 
"body" : "Git 初始化 （ git init ) 功能 ：该命令打开 初始化 Git 存储库 初始化本地的对话框 Git 存储库 对于公开 CODESYS 项目。在初始化过程中，项目被导入到 Git 中，它会创建一个本地存储库和项目的索引（Git 项目存储）。结果，创建了项目的 Git 工作目录。 打电话 : Git 菜单 要求 : A CODESYS 项目已打开。 当设置了加密时 CODESYS 项目（ CODESYS - 项目设置 — 安全 ），Git 存储库（既不是本地存储库也不是远程存储库）不会自动受到相应的保护。 对话框： 初始化 Git 存储库 本地 Git 目录路径的输入字段 文件系统中应用于新 Git 项目存储的空目录的路径 示例： D:\\git_local\\rep1 好吧 打开的项目将导入 Git，并为该项目创建本地存储库。 在项目的导航视图中，对象由以下符号标识： 项目的根节点： 该项目的所有其他对象和设备： 相应的 Git 消息显示在消息窗口中。 " }, 
{ "title" : "Command: Git Clone ", 
"url" : "_git_cmd_git_clone.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ Command: Git Clone ", 
"snippet" : "Git Clone ( git clone ) 功能 ：该命令打开 Git 克隆 对话。在对话框的帮助下， 远程仓库 被复制到一个空目录，该目录又成为一个新的本地 Git 存储库。复制操作后，本地存储库包含远程存储库的完整历史记录。 打电话 : Git 菜单 要求 : 中未打开任何项目 CODESYS 。 当设置了加密时 CODESYS 项目（ CODESYS - 项目设置 — 安全 ），Git 存储库（既不是本地存储库也不是远程存储库）不会自动受到相应的保护。 对话框： Git 克隆 克隆自 来源网址 远程存储库的 URL 或文件路径 克隆到 Git 存储路径 的文件目录 Git 项目存储 ...", 
"body" : "Git Clone ( git clone ) 功能 ：该命令打开 Git 克隆 对话。在对话框的帮助下， 远程仓库 被复制到一个空目录，该目录又成为一个新的本地 Git 存储库。复制操作后，本地存储库包含远程存储库的完整历史记录。 打电话 : Git 菜单 要求 : 中未打开任何项目 CODESYS 。 当设置了加密时 CODESYS 项目（ CODESYS - 项目设置 — 安全 ），Git 存储库（既不是本地存储库也不是远程存储库）不会自动受到相应的保护。 对话框： Git 克隆 克隆自 来源网址 远程存储库的 URL 或文件路径 克隆到 Git 存储路径 的文件目录 Git 项目存储 （本地存储库的目录位置）。 示例： D:\\git_local\\rep1 项目文件 项目文件的文件路径 ( 项目目录 ）。注意：项目文件不得与 Git 项目存储位于同一个目录中。 示例： D:\\git_projects\\myproj1.project 项目文件类型 项目 图书馆 与克隆操作相关，您可以使用 从存储库中恢复项目 命令将已存在于 Git 存储库中的项目作为新项目加载 CODESYS 项目。 " }, 
{ "title" : "命令：Git Deinit ", 
"url" : "_git_cmd_git_deinit.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：Git Deinit ", 
"snippet" : "Git Deinit 功能 ：该命令删除整个 Git项目存储 .结果，公开 CODESYS 项目在 Git 中不再可用。 打电话 : Git 菜单 要求 : 有一个 Git 项目存储空间可供打开 CODESYS 项目，因此也是本地存储库。这意味着 Git 初始化 或者 Git 克隆 之前已经运行过了。...", 
"body" : "Git Deinit 功能 ：该命令删除整个 Git项目存储 .结果，公开 CODESYS 项目在 Git 中不再可用。 打电话 : Git 菜单 要求 : 有一个 Git 项目存储空间可供打开 CODESYS 项目，因此也是本地存储库。这意味着 Git 初始化 或者 Git 克隆 之前已经运行过了。 " }, 
{ "title" : "命令：从存储库中恢复项目 ", 
"url" : "_git_cmd_build_project_from_repository.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：从存储库中恢复项目 ", 
"snippet" : "从存储库中恢复项目 函数 : 该命令允许在中重建项目 CODESYS 来自 Git 项目存储（本地存储库）。这样，该操作类似于通过以下方式创建 Git 项目 Git 克隆 （来自远程存储库）。 打电话 ：默认情况下，该命令不在 Git 菜单中。 要求 : 中未打开任何项目 CODESYS 。 该命令会打开 恢复项目 对话框。在这里，您可以指定要恢复的项目的源和目的地。 来源 Git 存储库位置 应从中恢复项目的 Git 存储库的路径 CODESYS 目的地 项目文件 CODESYS 项目存储的文件目录 示例：D:\\proj.project 项目文件类型 : 项目 : 图书馆...", 
"body" : "从存储库中恢复项目 函数 : 该命令允许在中重建项目 CODESYS 来自 Git 项目存储（本地存储库）。这样，该操作类似于通过以下方式创建 Git 项目 Git 克隆 （来自远程存储库）。 打电话 ：默认情况下，该命令不在 Git 菜单中。 要求 : 中未打开任何项目 CODESYS 。 该命令会打开 恢复项目 对话框。在这里，您可以指定要恢复的项目的源和目的地。 来源 Git 存储库位置 应从中恢复项目的 Git 存储库的路径 CODESYS 目的地 项目文件 CODESYS 项目存储的文件目录 示例：D:\\proj.project 项目文件类型 : 项目 : 图书馆 " }, 
{ "title" : "命令：从存储库重建项目 ", 
"url" : "_git_cmd_load_project_from_repository.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：从存储库重建项目 ", 
"snippet" : "从存储库重建项目 函数 : 该命令启动一个 重新同步 该项目的。 打电话 ：默认情况下，该命令不在 Git 菜单中。 要求 ：项目已打开，其版本在 Git 中管理。 CODESYS Git 尝试从 Git 存储库的工作目录中从当前状态重建项目。...", 
"body" : "从存储库重建项目 函数 : 该命令启动一个 重新同步 该项目的。 打电话 ：默认情况下，该命令不在 Git 菜单中。 要求 ：项目已打开，其版本在 Git 中管理。 CODESYS Git 尝试从 Git 存储库的工作目录中从当前状态重建项目。 " }, 
{ "title" : "命令：将项目与 Git 项目存储同步 ", 
"url" : "_git_cmd_synchronize_project.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：将项目与 Git 项目存储同步 ", 
"snippet" : "将项目与 Git 项目存储同步 函数 : A CODESYS 在 Git 管理下的项目将写入 Git 项目存储。 打电话 : Git 菜单 要求 : Git 项目已在中打开 CODESYS 。 同步意味着当前 CODESYS Git 项目存储中的项目会覆盖当前的工作目录。...", 
"body" : "将项目与 Git 项目存储同步 函数 : A CODESYS 在 Git 管理下的项目将写入 Git 项目存储。 打电话 : Git 菜单 要求 : Git 项目已在中打开 CODESYS 。 同步意味着当前 CODESYS Git 项目存储中的项目会覆盖当前的工作目录。 " }, 
{ "title" : "命令：移动存储库 ", 
"url" : "_git_cmd_move_repository.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：移动存储库 ", 
"snippet" : "移动存储库 功能 ：该命令打开 移动 Git 存储库 对话框移动 Git项目存储 将其所有内容放到一个新目录中。所有内容都被移动，并且提交历史记录也被保留。 打电话 : Git 菜单 要求 : 已为打开状态执行了至少一次提交 CODESYS 项目。 对话框： 移动 Git 存储库 将存储库移出 当前路径 项目本地存储库的路径 至 目标路径 移动本地存储库的目标目录 要求：指定的目录必须为空。...", 
"body" : "移动存储库 功能 ：该命令打开 移动 Git 存储库 对话框移动 Git项目存储 将其所有内容放到一个新目录中。所有内容都被移动，并且提交历史记录也被保留。 打电话 : Git 菜单 要求 : 已为打开状态执行了至少一次提交 CODESYS 项目。 对话框： 移动 Git 存储库 将存储库移出 当前路径 项目本地存储库的路径 至 目标路径 移动本地存储库的目标目录 要求：指定的目录必须为空。 " }, 
{ "title" : "命令：比较对象 ", 
"url" : "_git_cmd_compare_object.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：比较对象 ", 
"snippet" : "比较对象 符号 : 函数 : 在中选择的对象 CODESYS 可以将项目树与其上次提交的状态或分阶段状态（索引）进行比较。 打电话 ：在项目导航器中选择的对象的快捷菜单 要求 : Git 项目已在中打开 CODESYS 。 该命令会打开 比较视图 它将项目中对象的当前状态与其上次提交到 Git 存储库的状态或索引中的最后一个状态进行比较。左侧窗口显示项目（更新）中的状态，右侧窗口显示上次提交的状态或上次索引状态。...", 
"body" : "比较对象 符号 : 函数 : 在中选择的对象 CODESYS 可以将项目树与其上次提交的状态或分阶段状态（索引）进行比较。 打电话 ：在项目导航器中选择的对象的快捷菜单 要求 : Git 项目已在中打开 CODESYS 。 该命令会打开 比较视图 它将项目中对象的当前状态与其上次提交到 Git 存储库的状态或索引中的最后一个状态进行比较。左侧窗口显示项目（更新）中的状态，右侧窗口显示上次提交的状态或上次索引状态。 " }, 
{ "title" : "命令：合并两个对象 ", 
"url" : "_git_cmd_merge_two_objects.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：合并两个对象 ", 
"snippet" : "合并两个对象 函数 ：可以合并在项目导航器中选择的两个相同类型的对象。 打电话 ：快捷菜单（如果在项目导航器中选择了对象） 要求 ：这些对象必须是相同的类型。例如，功能块不能与任务配置合并。 The command opens the Merge <object1> in <object2> view. This largely corresponds to the view which is also used to compare objects. There you can explicitly define which contents should be applied from t...", 
"body" : "合并两个对象 函数 ：可以合并在项目导航器中选择的两个相同类型的对象。 打电话 ：快捷菜单（如果在项目导航器中选择了对象） 要求 ：这些对象必须是相同的类型。例如，功能块不能与任务配置合并。 The command opens the Merge <object1> in <object2> view. This largely corresponds to the view which is also used to compare objects. There you can explicitly define which contents should be applied from the merge source (left window) to the merge destination (right window). 要反转合并方向，请使用 切换对象 按钮。因此，这两个对象的显示内容在左右窗口之间交替显示。 合并仅考虑视图中此处显示的对象。它们的子项或属性未被合并或更改。 有关比较视图的更多信息，请参阅： 比较视图" }, 
{ "title" : "命令：通过提交创建分支 ", 
"url" : "_git_cmd_create_branch_from_commit.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：通过提交创建分支 ", 
"snippet" : "通过提交创建分支 符号 : 函数 : 来自中的提交 历史 视图中，将为受影响的项目创建一个新分支，然后该分支可在 分支机构 观点。 打电话 : 中提交条目的快捷菜单 历史 观点 该命令会打开 通过提交创建分支 用于定义新分支的对话框。...", 
"body" : "通过提交创建分支 符号 : 函数 : 来自中的提交 历史 视图中，将为受影响的项目创建一个新分支，然后该分支可在 分支机构 观点。 打电话 : 中提交条目的快捷菜单 历史 观点 该命令会打开 通过提交创建分支 用于定义新分支的对话框。 " }, 
{ "title" : "对话框：通过提交创建分支 ", 
"url" : "_git_cmd_create_branch_from_commit.html#UUID-102fabea-ba95-ff2e-3b37-dc6bdeefb8e0_section-idm4573495381971233102385669569", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：通过提交创建分支 \/ 对话框：通过提交创建分支 ", 
"snippet" : "源代码提交 SHA1 提交的 SHA1（唯一 ID） 留言 提交的提交消息 新分支名称 新分支应在其中显示的名称 分支机构 观点 原力 即使已经存在同名分支，即使存在本地未提交的更改，也会创建新分支。 结账 新分支的签出地址是 分支机构 创建后查看。...", 
"body" : "源代码提交 SHA1 提交的 SHA1（唯一 ID） 留言 提交的提交消息 新分支名称 新分支应在其中显示的名称 分支机构 观点 原力 即使已经存在同名分支，即使存在本地未提交的更改，也会创建新分支。 结账 新分支的签出地址是 分支机构 创建后查看。 " }, 
{ "title" : "命令：Git 配置 ", 
"url" : "_git_cmd_git_config.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 菜单命令 \/ 命令：Git 配置 ", 
"snippet" : "Git 配置 函数 ：该命令会打开一个对话框，用于编辑条目 core ， init ，以及 user 中的部分 .git\/config 配置文件。初始化后，此文件存储在本地 Git 存储库中。 Background: If you clone or initialize a repository and there is no global .gitconfig file exists yet, then you will be asked to configure one initially. You can edit the file again at any time using the...", 
"body" : "Git 配置 函数 ：该命令会打开一个对话框，用于编辑条目 core ， init ，以及 user 中的部分 .git\/config 配置文件。初始化后，此文件存储在本地 Git 存储库中。 Background: If you clone or initialize a repository and there is no global .gitconfig file exists yet, then you will be asked to configure one initially. You can edit the file again at any time using the Git Config command. The global .gitconfig file is located in the user directory by default (example: C:\/Users\/<user name> ). 打电话 : Git 菜单 要求 : 公开赛 CODESYS 项目在 Git 的本地存储库中管理。 对话框 : 编辑你的 git 配置。更改将存储在存储库的配置文件中。 核心 漫长的路径 必须启用此选项才能支持长路径，并且 CODESYS Git 可以正常工作。 初始化 默认分支 Git 存储库的本地默认分支（通常 master ) 是在第一次提交后自动创建的。另请参阅： 导言用户 用户 电子邮件 " }, 
{ "title" : "符号 ", 
"url" : "_git_reference_symbols.html", 
"breadcrumbs" : "CODESYS Git \/ 参考，用户界面 \/ 符号 ", 
"snippet" : "每个对象在索引（分阶段更改）和 Git 存储库 .状态通过相应符号显示在对象的导航器视图中 CODESYS 项目或在 状态和分期 看法。 符号 描述 未改变 （在工作目录中） 该对象与索引保持不变。 已修改 （在工作目录中） 该对象已与索引中的先前版本相比进行了更改。 全新 （在工作目录中） 该对象存在于工作目录中，但还不在索引或本地存储库中。 冲突 或者 关系问题 合并对象时出现冲突或关系问题。 已删除 （在工作目录中） 该对象不存在于工作目录中，但仍存在于索引中。 错误 未分配状态 该符号仅显示在导航器中。 短暂的 临时对象不适用于 Git 存储库。该符号仅显示在导航器中。 尚无法确定 G...", 
"body" : "每个对象在索引（分阶段更改）和 Git 存储库 .状态通过相应符号显示在对象的导航器视图中 CODESYS 项目或在 状态和分期 看法。 符号 描述 未改变 （在工作目录中） 该对象与索引保持不变。 已修改 （在工作目录中） 该对象已与索引中的先前版本相比进行了更改。 全新 （在工作目录中） 该对象存在于工作目录中，但还不在索引或本地存储库中。 冲突 或者 关系问题 合并对象时出现冲突或关系问题。 已删除 （在工作目录中） 该对象不存在于工作目录中，但仍存在于索引中。 错误 未分配状态 该符号仅显示在导航器中。 短暂的 临时对象不适用于 Git 存储库。该符号仅显示在导航器中。 尚无法确定 Git 状态。一旦知道状态，就会显示相应的符号。该符号仅显示在导航器中。 " }, 
{ "title" : "Troubleshooting – \"Unknown error\" ", 
"url" : "_git_troubleshooting.html", 
"breadcrumbs" : "CODESYS Git \/ Troubleshooting – \"Unknown error\" ", 
"snippet" : "The error message \"Unknown error\" appears for a number of errors which CODESYS cannot resolve by itself. However, there are ways for the user to correct some of these errors. In the message dialog with the error message, click the Details button to get more information about the error. See below for...", 
"body" : "The error message \"Unknown error\" appears for a number of errors which CODESYS cannot resolve by itself. However, there are ways for the user to correct some of these errors. In the message dialog with the error message, click the Details button to get more information about the error. See below for instructions on how to handle the respective error: " }, 
{ "title" : "Path too long ", 
"url" : "_git_troubleshooting.html#UUID-5b09f6b2-044d-09e7-27fa-a7ba0d49e5a2_section-idm23463169779052", 
"breadcrumbs" : "CODESYS Git \/ Troubleshooting – \"Unknown error\" \/ Path too long ", 
"snippet" : "This error message can appear if the file paths of the Git project in the file system are too long. To resolve the problem, you need to enable the Long paths option for Git. There are two possible solutions for this: Enable the option in the project via Git Config : In the open project, click the Gi...", 
"body" : "This error message can appear if the file paths of the Git project in the file system are too long. To resolve the problem, you need to enable the Long paths option for Git. There are two possible solutions for this: Enable the option in the project via Git Config : In the open project, click the Git → Git Config command. In the configuration dialog, enable the Long paths option. Click OK to exit the dialog. Close the project and open it again. Enable the option in the .gitconfig file of the user: Open the file C:\\Benutzer\\<user name>\\.gitconfig (example: C:\\Users\\m.muster\\.gitconfig ). Edit the file so that there is an entry longpaths = true in the core area. Then close the project and open it again. [core]    \n longpaths = true " }, 
{ "title" : "Conflict prevents checkout ", 
"url" : "_git_troubleshooting.html#UUID-5b09f6b2-044d-09e7-27fa-a7ba0d49e5a2_section-idm23463173497096", 
"breadcrumbs" : "CODESYS Git \/ Troubleshooting – \"Unknown error\" \/ Conflict prevents checkout ", 
"snippet" : "执行合并的 Git 操作可能会出现此错误 ( git merge\/git pull ）。存储库中可能有修改过的文件，这些文件不属于存储库的一部分 CODESYS 项目。 打开 状态和阶段 观点。检查 “外部” 文件是否列在下面 未暂存的更改 。这意味着在项目中找不到作为对象的文件 设备 或者 POU 观点。 您还可以按如下方式检查文件是否为外部文件：双击文件条目 物体 的专栏 状态与标记 观点。如果错误消息 External objects are not supported in diff view 出现而不是比较视图，则存在外部对象。...", 
"body" : "执行合并的 Git 操作可能会出现此错误 ( git merge\/git pull ）。存储库中可能有修改过的文件，这些文件不属于存储库的一部分 CODESYS 项目。 打开 状态和阶段 观点。检查 “外部” 文件是否列在下面 未暂存的更改 。这意味着在项目中找不到作为对象的文件 设备 或者 POU 观点。 您还可以按如下方式检查文件是否为外部文件：双击文件条目 物体 的专栏 状态与标记 观点。如果错误消息 External objects are not supported in diff view 出现而不是比较视图，则存在外部对象。 " }
]
$(document).trigger('search.ready');
});