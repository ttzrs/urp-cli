$(document).ready(function () {indexDict['zh-CHS'] = [{ "title" : "CODESYS Application Composer ", 
"url" : "_ac_start_page.html", 
"breadcrumbs" : "CODESYS Application Composer \/ CODESYS Application Composer ", 
"snippet" : "CODESYS Application Composer 是一种用于高效创建由循环功能块组成的应用程序变体的软件。 在模块的基础上，您可以创建计算机应用程序并对其进行参数化。PLC 程序由此自动生成。 提高了应用程序部件的可重复使用性和质量 通过从预定义模块自动生成应用程序来提高效率 特别适用于数字工厂或工业 4.0 领域应用的简化项目工程 可以更轻松地规划数字工厂或工业 4.0 应用程序 得益于所提供的发电机和应用理念，可以立即使用 视频片段： 使用楼宇自动化 CODESYS Application Composer 附加组件 示例项目 你可以安装和更新 CODESYS Applicatio...", 
"body" : "CODESYS Application Composer 是一种用于高效创建由循环功能块组成的应用程序变体的软件。 在模块的基础上，您可以创建计算机应用程序并对其进行参数化。PLC 程序由此自动生成。 提高了应用程序部件的可重复使用性和质量 通过从预定义模块自动生成应用程序来提高效率 特别适用于数字工厂或工业 4.0 领域应用的简化项目工程 可以更轻松地规划数字工厂或工业 4.0 应用程序 得益于所提供的发电机和应用理念，可以立即使用 视频片段： 使用楼宇自动化 CODESYS Application Composer 附加组件 示例项目 你可以安装和更新 CODESYS Application Composer 中的附加组件 CODESYS Installer 。 " }, 
{ "title" : "概述 ", 
"url" : "ac_application_composer_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 概述 ", 
"snippet" : "这 CODESYS Application Composer 用于使用现有模块创建应用程序。用户组合、参数化并连接所需的模块以形成完整的应用程序。该配置不需要PLC编程知识，因此可以由没有编程经验的技术人员完成。内部生成器创建完整、结构良好的 IEC 61131-3 应用程序，包括 I\/O 映射和可视化。 CODESYS Application Composer 由两个主要组件组成： 模块编辑器，可用于组合使用模块声明编辑器开发的软件模块 用于开发模块的模块声明编辑器 示例 CODESYS Application Composer 模块树和可视化 有关模块编辑器的更多信息，请参阅： 模块编辑器...", 
"body" : "这 CODESYS Application Composer 用于使用现有模块创建应用程序。用户组合、参数化并连接所需的模块以形成完整的应用程序。该配置不需要PLC编程知识，因此可以由没有编程经验的技术人员完成。内部生成器创建完整、结构良好的 IEC 61131-3 应用程序，包括 I\/O 映射和可视化。 CODESYS Application Composer 由两个主要组件组成： 模块编辑器，可用于组合使用模块声明编辑器开发的软件模块 用于开发模块的模块声明编辑器 示例 CODESYS Application Composer 模块树和可视化 有关模块编辑器的更多信息，请参阅： 模块编辑器有关模块声明编辑器的更多信息，请参阅： 模块声明编辑器" }, 
{ "title" : "模块编辑器 ", 
"url" : "ac_module_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 ", 
"snippet" : "使用应用程序编辑器的编辑器，模块实例 模块树 可以配置和参数化。模块实例的可用编辑器可通过双击对象或 编辑对象 来自上下文菜单的命令： 部署 人机界面 参数 输入\/输出 信息 其他编辑： 扩展模块编辑器 序列编辑器 这 项目比较 命令也可用于 Application Composer 模块实例。...", 
"body" : "使用应用程序编辑器的编辑器，模块实例 模块树 可以配置和参数化。模块实例的可用编辑器可通过双击对象或 编辑对象 来自上下文菜单的命令： 部署 人机界面 参数 输入\/输出 信息 其他编辑： 扩展模块编辑器 序列编辑器 这 项目比较 命令也可用于 Application Composer 模块实例。 " }, 
{ "title" : "部署 ", 
"url" : "ac_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 部署 ", 
"snippet" : "此对话框仅适用于顶级模块实例，并提供应用程序和任务设置。 顶层设置对话框 应用 ：作为顶层模块实例中的生成目标输入。这 按钮可用于选择现有应用程序或通过指定名称创建新应用程序。如果应用程序被分配到POU池，那么 输入\/输出映射 不可能。对于具有父模块的解耦模块，建议使用父应用程序（ [使用家长应用程序] ）。 标准任务 在此部分中，最多提供三个预定义任务 - 一项具有高优先级任务，一项具有中等优先级，一项具有低优先级。任务的名称和可用性在模块本身中定义，无法更改（在上面的对话框中： 现场总线任务 和 标准任务 ）。除了预定义任务之外，用户还可以通过指定名称来创建新任务，如果“ CREATE_I...", 
"body" : "此对话框仅适用于顶级模块实例，并提供应用程序和任务设置。 顶层设置对话框 应用 ：作为顶层模块实例中的生成目标输入。这 按钮可用于选择现有应用程序或通过指定名称创建新应用程序。如果应用程序被分配到POU池，那么 输入\/输出映射 不可能。对于具有父模块的解耦模块，建议使用父应用程序（ [使用家长应用程序] ）。 标准任务 在此部分中，最多提供三个预定义任务 - 一项具有高优先级任务，一项具有中等优先级，一项具有低优先级。任务的名称和可用性在模块本身中定义，无法更改（在上面的对话框中： 现场总线任务 和 标准任务 ）。除了预定义任务之外，用户还可以通过指定名称来创建新任务，如果“ CREATE_IF_MISSING \" 标志在模块声明中设置。新任务的参数可以在 标准发电机设置 。 模块特定任务 ：此字段显示有关模块特定任务的信息。 " }, 
{ "title" : "输入\/输出 ", 
"url" : "ac_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 输入\/输出 ", 
"snippet" : "该对话框提供有关模块输入和输出的信息。输入和输出描述了模块的 I\/O 需求，并且可以连接到以下各项： 设备的输入和输出 其他模块实例的输入和输出 ST 表达式或常量（例如：出于仿真目的，布尔模块输入可以连接到 TRUE ） 在在线模式下， 在线价值 列可见，并显示控制器的当前值。 模块接口I\/O概述 单击 测绘 字段打开 I\/O 映射对话框： I\/O 映射对话框 I\/O 通道 ：单击 …… 按钮打开另一个对话框，将输入\/输出映射到设备 I\/O。 ST-表达 ：此选项允许将输入\/输出映射到 ST 表达式。单击 按钮打开输入助手以选择变量。 连接到模块 I\/O ：此选项可用于将输入\/输出映射到没有...", 
"body" : "该对话框提供有关模块输入和输出的信息。输入和输出描述了模块的 I\/O 需求，并且可以连接到以下各项： 设备的输入和输出 其他模块实例的输入和输出 ST 表达式或常量（例如：出于仿真目的，布尔模块输入可以连接到 TRUE ） 在在线模式下， 在线价值 列可见，并显示控制器的当前值。 模块接口I\/O概述 单击 测绘 字段打开 I\/O 映射对话框： I\/O 映射对话框 I\/O 通道 ：单击 …… 按钮打开另一个对话框，将输入\/输出映射到设备 I\/O。 ST-表达 ：此选项允许将输入\/输出映射到 ST 表达式。单击 按钮打开输入助手以选择变量。 连接到模块 I\/O ：此选项可用于将输入\/输出映射到没有任何连接的 I\/O。单击 按钮打开输入助手以选择模块。 无连接 ：没有输入\/输出映射。该选项类似于 缺少连接 ，但它不会生成警告消息。 缺少连接 ：此选项是默认选项，在生成项目时会在消息视图中生成警告。 由设备生成器自动连接的 I\/O 由 (AUTO) 在 IN\/OUT 列中并且被禁用。如果仍然手动更改映射，则会显示一条警告，指出此操作将覆盖自动映射。 如果自动生成的连接被手动设置的连接覆盖，则在设备生成器操作中不再考虑该 I\/O 通道。 " }, 
{ "title" : "人机界面 ", 
"url" : "ac_hmi.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 人机界面 ", 
"snippet" : "在此对话框中，您可以定义页面模板和应嵌入顶层可视化中的模块可视化。 创建顶级选项卡 ：在可视化的顶层创建一个选项卡，直接导致该模块实例的可视化。 热键 ：通过这里设置的快捷键，可以直接切换到该可视化页面。快捷方式的默认设置在模块声明中定义 std.Visu 部分。 页面模板 ：可以在此处选择模块可视化的模板，用作可视化的背景。下拉列表提供了模块声明中定义的所有可视化的选择。默认情况下会选择模块声明中的第一个可视化。如果 不 定义了可视化，然后显示“无”。 嵌入可视化 ：此函数允许将模块实例的可视化嵌入到下一个上级模块中（ 下一个祖先 ）或模块实例的任何其他可视化。如果在模块中定义了，则 %PA...", 
"body" : "在此对话框中，您可以定义页面模板和应嵌入顶层可视化中的模块可视化。 创建顶级选项卡 ：在可视化的顶层创建一个选项卡，直接导致该模块实例的可视化。 热键 ：通过这里设置的快捷键，可以直接切换到该可视化页面。快捷方式的默认设置在模块声明中定义 std.Visu 部分。 页面模板 ：可以在此处选择模块可视化的模板，用作可视化的背景。下拉列表提供了模块声明中定义的所有可视化的选择。默认情况下会选择模块声明中的第一个可视化。如果 不 定义了可视化，然后显示“无”。 嵌入可视化 ：此函数允许将模块实例的可视化嵌入到下一个上级模块中（ 下一个祖先 ）或模块实例的任何其他可视化。如果在模块中定义了，则 %PAGE_VISU% 可以选择占位符。在这种情况下，嵌入为模块实例生成的创建的可视化屏幕。可以定义多个条目。 有关创建可视化屏幕的信息，请参阅： 生成可视化屏幕 " }, 
{ "title" : "范围 ", 
"url" : "ac_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 范围 ", 
"snippet" : "该对话框显示可参数化的模块实例的所有可用参数。中的条目 范围 , 类型 , 描述 , 最小 ， 和 最大限度 仅供参考。您可以双击 价值 字段进行编辑。 模块实例参数对话框 当明确设置参数值时，参数值会以粗体显示；否则字体保持正常。更改后的参数可以通过以下方式重置为其默认值 重置为默认 上下文菜单中的命令。 红色字体的参数必须由用户设置，否则创建时会显示错误。 在在线模式下， 在线价值 列可见并显示当前值。如果更改参数中的值 价值 列，则控制器上的值也会更改。使用 使用在线价值观 命令将当前在线值复制到 价值 列，并因此将其用作模块树中模块实例的参数值。 一般来说，参数值以 IEC 文字的语法...", 
"body" : "该对话框显示可参数化的模块实例的所有可用参数。中的条目 范围 , 类型 , 描述 , 最小 ， 和 最大限度 仅供参考。您可以双击 价值 字段进行编辑。 模块实例参数对话框 当明确设置参数值时，参数值会以粗体显示；否则字体保持正常。更改后的参数可以通过以下方式重置为其默认值 重置为默认 上下文菜单中的命令。 红色字体的参数必须由用户设置，否则创建时会显示错误。 在在线模式下， 在线价值 列可见并显示当前值。如果更改参数中的值 价值 列，则控制器上的值也会更改。使用 使用在线价值观 命令将当前在线值复制到 价值 列，并因此将其用作模块树中模块实例的参数值。 一般来说，参数值以 IEC 文字的语法显示和编辑（例如：TIME 类型的参数值为 t#7s35ms 。 更改参数后， 产生 必须执行命令才能再次创建项目。 如果您在在线模式下更改了模块实例中的任何参数值，则可以使用 不同的参数值 命令获取更改的参数列表 留言 看法。双击此类消息将打开受影响模块实例的参数对话框，其中更改的参数值由红框指示。 " }, 
{ "title" : "信息 ", 
"url" : "ac_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 信息 ", 
"snippet" : "此信息对话框显示有关 图标 , 姓名 , 描述 , 来源 , 版本 , 提供者 ， 和 类别 模块实例的。 作为一个选项，也可以显示多个链接。单击链接将打开相应的应用程序。第一个 URL 的内容显示在右侧。对于要在此处显示的链接，必须在 MetaData 模块声明部分。 受信任的域和站点在应用程序中定义 作曲家选项 。如果单击未定义为“受信任”的 URL，则会在右侧视图中打开一个对话框。在此视图中，您可以将 URL 添加到受信任的域或站点。...", 
"body" : "此信息对话框显示有关 图标 , 姓名 , 描述 , 来源 , 版本 , 提供者 ， 和 类别 模块实例的。 作为一个选项，也可以显示多个链接。单击链接将打开相应的应用程序。第一个 URL 的内容显示在右侧。对于要在此处显示的链接，必须在 MetaData 模块声明部分。 受信任的域和站点在应用程序中定义 作曲家选项 。如果单击未定义为“受信任”的 URL，则会在右侧视图中打开一个对话框。在此视图中，您可以将 URL 添加到受信任的域或站点。 " }, 
{ "title" : "源模板 ", 
"url" : "ac_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 源模板 ", 
"snippet" : "该对话框定义了当 POU 池中的哪些功能块被复制到应用程序时。 产生 命令被执行。要复制功能块，必须在 发电机配置 。 该对话框显示在中定义的所有功能块 SourceTemplate 模块声明部分。 来源-FB ：要复制的功能块的标识符 就是复制 ：TRUE\/FALSE：复制或不复制功能块。如果 IsMandatory 参数定义为 TRUE 在模块声明中，则此处的值不能更改。 源FB类型 ：要复制的功能块名称...", 
"body" : "该对话框定义了当 POU 池中的哪些功能块被复制到应用程序时。 产生 命令被执行。要复制功能块，必须在 发电机配置 。 该对话框显示在中定义的所有功能块 SourceTemplate 模块声明部分。 来源-FB ：要复制的功能块的标识符 就是复制 ：TRUE\/FALSE：复制或不复制功能块。如果 IsMandatory 参数定义为 TRUE 在模块声明中，则此处的值不能更改。 源FB类型 ：要复制的功能块名称 " }, 
{ "title" : "编辑：出口设备 ", 
"url" : "ac_export_devices.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 编辑：出口设备 ", 
"snippet" : "使用此编辑器，您可以选择由设备导出生成的文件。生成项目时，该设备将添加到设备树中。 这 配置选项 当添加具有特殊属性的设备以及设备生成器无法添加设备时需要。 标识符 : 模块声明中的标识符 导出的文件 ：选择模块声明中定义的所有文件 如果模块声明中只定义了一个文件，则此处不显示该文件。每个设备可以存在多个 ExportDevice。它们通过其标识符与模块声明进行区分并显示在此处。...", 
"body" : "使用此编辑器，您可以选择由设备导出生成的文件。生成项目时，该设备将添加到设备树中。 这 配置选项 当添加具有特殊属性的设备以及设备生成器无法添加设备时需要。 标识符 : 模块声明中的标识符 导出的文件 ：选择模块声明中定义的所有文件 如果模块声明中只定义了一个文件，则此处不显示该文件。每个设备可以存在多个 ExportDevice。它们通过其标识符与模块声明进行区分并显示在此处。 " }, 
{ "title" : "对话框：选项：作曲家 ", 
"url" : "ac_options.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 对话框：选项：作曲家 ", 
"snippet" : "该子对话框的 CODESYS 选项对话框提供了不同的选项卡 CODESYS Application Composer 设置。...", 
"body" : "该子对话框的 CODESYS 选项对话框提供了不同的选项卡 CODESYS Application Composer 设置。 " }, 
{ "title" : "选项卡：常规 ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_71025f62d62f3d9cc0a8640e01589d60", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 对话框：选项：作曲家 \/ 选项卡：常规 ", 
"snippet" : "一般的 在生成之前显示顶层选择 : 您可以点击 作曲家 → 生成 打开一个对话框来选择顶层模块。您可以通过取消选择不再更改的模块来减少生成应用程序的时间。 编辑 参数编辑器类型 显示的 参数 于 参数 选项卡（模块编辑器）。 树视图 ：参数组在编辑器中以树形结构显示。 选项卡视图 ：参数组在编辑器中显示为单个选项卡。 扫描 自动扫描（与项目一起保存） ： 这 CODESYS Application Composer 当新库插入到 POU 视图中时，会自动搜索现有模块和模块实例。 ： 这 CODESYS Application Composer 仅在以下情况下搜索现有模块和模块实例： 打开项目后...", 
"body" : "一般的 在生成之前显示顶层选择 : 您可以点击 作曲家 → 生成 打开一个对话框来选择顶层模块。您可以通过取消选择不再更改的模块来减少生成应用程序的时间。 编辑 参数编辑器类型 显示的 参数 于 参数 选项卡（模块编辑器）。 树视图 ：参数组在编辑器中以树形结构显示。 选项卡视图 ：参数组在编辑器中显示为单个选项卡。 扫描 自动扫描（与项目一起保存） ： 这 CODESYS Application Composer 当新库插入到 POU 视图中时，会自动搜索现有模块和模块实例。 ： 这 CODESYS Application Composer 仅在以下情况下搜索现有模块和模块实例： 打开项目后 如果未执行搜索，则在模块树中插入模块实例后 注意：此设置与项目一起保存。 可信域 值得信赖的网站 该列表中的 URL 可以显示在 信息 模块编辑器的选项卡。要求：URL 在 部分中定义 MetaData 模块声明的。 " }, 
{ "title" : "选项卡：序列编辑器 ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_70cecd07d62f3d9fc0a8640e00b85eda", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 对话框：选项：作曲家 \/ 选项卡：序列编辑器 ", 
"snippet" : "一般的 显示参考文献 显示参数 显示 I\/O 映射 显示实例名称 显示评论 显示在线变量 ：相应的元素显示在步骤中 序列编辑器 。 展示 步宽 ：选项卡标题的宽度（以像素为单位） 有效值：25–500。 步距（垂直） 序列步骤之间的距离（以像素为单位） 有效值：10–100 标准。联系 一个连接 B连接 序列步骤之间的连接线的颜色 的颜色 一个连接 和 B连接 在分支步骤之后使用。 文本 参数 参考 输入\/输出通道 用于显示文本、参数、参考和 I\/O 通道的颜色 文字字体 该按钮打开默认对话框，用于在编辑器中设置文本字体。 链接字体 该按钮打开默认对话框，用于设置标签链接的字体。...", 
"body" : "一般的 显示参考文献 显示参数 显示 I\/O 映射 显示实例名称 显示评论 显示在线变量 ：相应的元素显示在步骤中 序列编辑器 。 展示 步宽 ：选项卡标题的宽度（以像素为单位） 有效值：25–500。 步距（垂直） 序列步骤之间的距离（以像素为单位） 有效值：10–100 标准。联系 一个连接 B连接 序列步骤之间的连接线的颜色 的颜色 一个连接 和 B连接 在分支步骤之后使用。 文本 参数 参考 输入\/输出通道 用于显示文本、参数、参考和 I\/O 通道的颜色 文字字体 该按钮打开默认对话框，用于在编辑器中设置文本字体。 链接字体 该按钮打开默认对话框，用于设置标签链接的字体。 " }, 
{ "title" : "序列编辑器 ", 
"url" : "ac_sequenceeditor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 序列编辑器 ", 
"snippet" : "序列编辑器是一个图形编辑器，用于显示和编辑序列 模块树 在流程图中。它允许添加和删除模块或修改其属性。该编辑器还提供在线模式，用于跟踪活动模块步骤和模块断点，以便可用于调试。 序列流本身（序列的执行和顺序）不是由编辑器实现的。这仅用于显示和编辑模块树。模块步骤的任何功能或逻辑都必须在模块的功能块中实现，如 IEC ( CODESYS ) 程序代码 序列编辑器 该编辑器可用于具有定义的所有模块 根 在该部分 mse.Sequence 模块声明的。编辑器的内容对应于模块树。模块树中的每次修改都会更改序列编辑器，反之亦然。仅显示插入在“”下方的模块实例 Root \" 实例。它们的显示内容由 部分中的...", 
"body" : "序列编辑器是一个图形编辑器，用于显示和编辑序列 模块树 在流程图中。它允许添加和删除模块或修改其属性。该编辑器还提供在线模式，用于跟踪活动模块步骤和模块断点，以便可用于调试。 序列流本身（序列的执行和顺序）不是由编辑器实现的。这仅用于显示和编辑模块树。模块步骤的任何功能或逻辑都必须在模块的功能块中实现，如 IEC ( CODESYS ) 程序代码 序列编辑器 该编辑器可用于具有定义的所有模块 根 在该部分 mse.Sequence 模块声明的。编辑器的内容对应于模块树。模块树中的每次修改都会更改序列编辑器，反之亦然。仅显示插入在“”下方的模块实例 Root \" 实例。它们的显示内容由 部分中的定义定义 mse.Sequence 他们的模块声明。 步骤的外观取决于模块声明中的定义。除了定义之外 Root 存在以下三种定义： 步： 平行线： 分支： " }, 
{ "title" : "序列框中显示的数据 ", 
"url" : "ac_sequenceeditor.html#UUID-c7b42e58-c2ec-c00e-5692-55a5d60221bd_d125a077ca9f50ac0a8640e01732ee5_id_ad20551e9b6d77a9c0a865200163ff8b", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 序列编辑器 \/ 序列框中显示的数据 ", 
"snippet" : "在每个步骤的框中，将显示模块类型的名称和模块实例的名称（可选）以及定义的图标。后者对应于元数据中定义的图标 模块配置 。模块实例的参数和 I\/O 通道也将显示，如果在 部分中定义的话 mse.Sequence 。这同样适用于引用，尽管区分了两种不同类型的引用： 对模块实例的一般引用 跳转引用，定义序列内的跳转。 引用的模块实例将及其在模块树中的相对路径显示（例如： ..\/..\/WaitTime ）。正在发生的 ..\/ 以缩写符号书写（例如： .\/..\/..\/ 变成 3x[..\/] ）。 可以将注释添加到每个步骤中，注释将显示为以行分隔。这是为每个步骤（模块实例）单独保存的。 如果模块名称、参数...", 
"body" : "在每个步骤的框中，将显示模块类型的名称和模块实例的名称（可选）以及定义的图标。后者对应于元数据中定义的图标 模块配置 。模块实例的参数和 I\/O 通道也将显示，如果在 部分中定义的话 mse.Sequence 。这同样适用于引用，尽管区分了两种不同类型的引用： 对模块实例的一般引用 跳转引用，定义序列内的跳转。 引用的模块实例将及其在模块树中的相对路径显示（例如： ..\/..\/WaitTime ）。正在发生的 ..\/ 以缩写符号书写（例如： .\/..\/..\/ 变成 3x[..\/] ）。 可以将注释添加到每个步骤中，注释将显示为以行分隔。这是为每个步骤（模块实例）单独保存的。 如果模块名称、参数、IO 通道或引用的显示文本不适合步骤内的给定空间，则文本将换行到第二行。如果需要，文本将被剪切。在这种情况下，一个 … 将被添加。 总之，最多可以为序列步骤定义四个附加列表\/条目： 参数：参数名+参数值 I\/O通道：通道名称+通道目标名称 引用：引用的模块实例的图标、路径和名称 跳转参考： >> + 引用模块实例的图标、路径和名称 注释：横线+注释 有关序列编辑器的更多信息，请参阅帮助章节中的 在序列编辑器中工作 和 在线模式下的序列编辑器 " }, 
{ "title" : "使用序列编辑器 ", 
"url" : "ac_sequenceeditor_edit.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 序列编辑器 \/ 使用序列编辑器 ", 
"snippet" : "当鼠标指针移动到步骤上时，该步骤会以灰色突出显示。当指针移动到连接的空端时，会显示一个灰色三角形。可以通过单击将所选步骤的颜色更改为红色来选择步骤。步骤的多重选择也是可能的。 可以通过拖放来移动步骤。当。。。的时候 控制键 键也被按下，步骤被复制。移动或复制步骤的可能插入位置用红色虚线标记。 通过拖放移动元素 当鼠标指针移到目标在当前序列中可用的跳转元素上时，跳转引用的文本字段也会通过虚线连接到指定的目标步骤。目标也用虚线圆圈标记。 跳转参考的跳转目标 使用 I\/O 通道进行编辑 双击 I\/O 通道可打开 I\/O 映射对话框，该对话框也可在模块实例的 I\/O 编辑器中使用。有关更多信息，请参阅...", 
"body" : "当鼠标指针移动到步骤上时，该步骤会以灰色突出显示。当指针移动到连接的空端时，会显示一个灰色三角形。可以通过单击将所选步骤的颜色更改为红色来选择步骤。步骤的多重选择也是可能的。 可以通过拖放来移动步骤。当。。。的时候 控制键 键也被按下，步骤被复制。移动或复制步骤的可能插入位置用红色虚线标记。 通过拖放移动元素 当鼠标指针移到目标在当前序列中可用的跳转元素上时，跳转引用的文本字段也会通过虚线连接到指定的目标步骤。目标也用虚线圆圈标记。 跳转参考的跳转目标 使用 I\/O 通道进行编辑 双击 I\/O 通道可打开 I\/O 映射对话框，该对话框也可在模块实例的 I\/O 编辑器中使用。有关更多信息，请参阅： 输入\/输出 " }, 
{ "title" : "序列编辑器的命令 ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_00bbee939046545bc0a8652000fd02ce", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 序列编辑器 \/ 使用序列编辑器 \/ 序列编辑器的命令 ", 
"snippet" : "右键单击序列步骤或灰色三角形（分支的空平行步骤）可提供该位置可用的上下文菜单命令。除了标准之外 切 , 复制 ， 和 粘贴 命令，菜单提供以下命令： 添加步骤之后 任何后续步骤都显示在列表命令中。因此，仅添加适合该位置的模块插槽的步骤和模块。 在闭合子序列后添加步骤 当需要关闭分支子序列和并行序列时，可以使用该命令。插入的步骤添加在子序列之后，而不是添加在子序列内。它仅适用于具有可关闭子序列的位置。 添加评论 向选定的步骤添加注释。 设置跳转参考 此命令仅在跳转元素的上下文菜单中可用。可以使用鼠标在目标步骤上画一条红线。 所选序列元素的上下文菜单也可以使用以下命令打开 空格键 。 分支的上下文...", 
"body" : "右键单击序列步骤或灰色三角形（分支的空平行步骤）可提供该位置可用的上下文菜单命令。除了标准之外 切 , 复制 ， 和 粘贴 命令，菜单提供以下命令： 添加步骤之后 任何后续步骤都显示在列表命令中。因此，仅添加适合该位置的模块插槽的步骤和模块。 在闭合子序列后添加步骤 当需要关闭分支子序列和并行序列时，可以使用该命令。插入的步骤添加在子序列之后，而不是添加在子序列内。它仅适用于具有可关闭子序列的位置。 添加评论 向选定的步骤添加注释。 设置跳转参考 此命令仅在跳转元素的上下文菜单中可用。可以使用鼠标在目标步骤上画一条红线。 所选序列元素的上下文菜单也可以使用以下命令打开 空格键 。 分支的上下文菜单 连续的步骤用箭头连接。对于分支元素，可以为两个分支定义不同的颜色。有关更多信息，请参阅： mse序列。颜色定义在 CODESYS 选项 （ 序列编辑器 ）。 " }, 
{ "title" : "更改序列步骤上的位置 ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_74415e1a90465440c0a865200120cb10", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 序列编辑器 \/ 使用序列编辑器 \/ 更改序列步骤上的位置 ", 
"snippet" : "要更改序列元素的位置，必须使用鼠标中键选择并拖动该元素。步骤内参数的排列也可以更改。 更改序列步骤的位置 因此，只能在编辑器中移动元素的位置 - 更改序列中的位置，因此无法更改顺序。...", 
"body" : "要更改序列元素的位置，必须使用鼠标中键选择并拖动该元素。步骤内参数的排列也可以更改。 更改序列步骤的位置 因此，只能在编辑器中移动元素的位置 - 更改序列中的位置，因此无法更改顺序。 " }, 
{ "title" : "更改参数\/注释\/实例名称\/I\/O 通道 ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_a585f36190465431c0a8652000ac8cda", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 序列编辑器 \/ 使用序列编辑器 \/ 更改参数\/注释\/实例名称\/I\/O 通道 ", 
"snippet" : "要改变一个 范围 ，必须双击它。根据变量的数据类型，可以编辑字段或从列表框中选择变量值（例如： TRUE 或者 FALSE ）。 注释或实例名称也可以通过双击来更改。...", 
"body" : "要改变一个 范围 ，必须双击它。根据变量的数据类型，可以编辑字段或从列表框中选择变量值（例如： TRUE 或者 FALSE ）。 注释或实例名称也可以通过双击来更改。 " }, 
{ "title" : "编辑参考文献 ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_939c29699046541bc0a865200038e978", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 序列编辑器 \/ 使用序列编辑器 \/ 编辑参考文献 ", 
"snippet" : "可以通过右键单击参考来编辑参考。上下文菜单提供了可以插入到此位置的引用列表。 设置参考 在跳转引用的情况下，上下文菜单提供 设置跳转参考 命令。执行此命令允许使用鼠标设置跳转目标。一条红色虚线指向目标，可以通过单击它来设置。可以使用以下命令删除现有的跳转引用 删除 从上下文菜单中。 设置跳转参考...", 
"body" : "可以通过右键单击参考来编辑参考。上下文菜单提供了可以插入到此位置的引用列表。 设置参考 在跳转引用的情况下，上下文菜单提供 设置跳转参考 命令。执行此命令允许使用鼠标设置跳转目标。一条红色虚线指向目标，可以通过单击它来设置。可以使用以下命令删除现有的跳转引用 删除 从上下文菜单中。 设置跳转参考 " }, 
{ "title" : "在线模式下的序列编辑器 ", 
"url" : "ac_sequenceeditor_onlinemode.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 序列编辑器 \/ 在线模式下的序列编辑器 ", 
"snippet" : "应用程序登录后，序列编辑器切换到在线模式。在线模式下模块步骤的外观与离线模式非常相似。所有步骤都会显示，但无法像离线模式一样选择或修改。此模式还提供了在步骤内显示变量值的可能性。 在线模式下的命令 在在线模式下，序列编辑器在 作曲家 菜单： 下一步的活动断点 断点的中心视图...", 
"body" : "应用程序登录后，序列编辑器切换到在线模式。在线模式下模块步骤的外观与离线模式非常相似。所有步骤都会显示，但无法像离线模式一样选择或修改。此模式还提供了在步骤内显示变量值的可能性。 在线模式下的命令 在在线模式下，序列编辑器在 作曲家 菜单： 下一步的活动断点 断点的中心视图 " }, 
{ "title" : "主动步数 ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e0ed25b7911507a5c0a8640e003e283b", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 序列编辑器 \/ 在线模式下的序列编辑器 \/ 主动步数 ", 
"snippet" : "如果在 模块声明 ，活动步骤将显示为黄色： 在线模式 – 主动步骤...", 
"body" : "如果在 模块声明 ，活动步骤将显示为黄色： 在线模式 – 主动步骤 " }, 
{ "title" : "断点 ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e06ef3f19ba07a7bc0a8652001bdb8af", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 序列编辑器 \/ 在线模式下的序列编辑器 \/ 断点 ", 
"snippet" : "如果在模块声明中正确声明，编辑器允许您设置断点。步骤的断点可以通过以下方式设置\/重置 切换断点 该步骤的上下文菜单中的命令。激活的断点由红色边框指示。如果断点处于活动状态（序列在断点处停止），则该步骤将显示为红色。 在线模式 – 断点 有关更多信息，请参阅： mse序列...", 
"body" : "如果在模块声明中正确声明，编辑器允许您设置断点。步骤的断点可以通过以下方式设置\/重置 切换断点 该步骤的上下文菜单中的命令。激活的断点由红色边框指示。如果断点处于活动状态（序列在断点处停止），则该步骤将显示为红色。 在线模式 – 断点 有关更多信息，请参阅： mse序列" }, 
{ "title" : "扩展模块编辑器 ", 
"url" : "ac_editor_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 扩展模块编辑器 ", 
"snippet" : "扩展模块的编辑器用于定义扩展并提供四个 元数据 , 范围, 输入\/输出， 和 人机界面 选项卡。双击功能块即可打开编辑器 POU 池（根据扩展名的给定目录）。 错误处理 如果发生严重错误而禁止显示编辑器，则错误消息将显示在 元数据 页。编辑器页面被禁用，因此它们无法对任何输入做出反应。此类错误的一个示例是缺少模块功能块。...", 
"body" : "扩展模块的编辑器用于定义扩展并提供四个 元数据 , 范围, 输入\/输出， 和 人机界面 选项卡。双击功能块即可打开编辑器 POU 池（根据扩展名的给定目录）。 错误处理 如果发生严重错误而禁止显示编辑器，则错误消息将显示在 元数据 页。编辑器页面被禁用，因此它们无法对任何输入做出反应。此类错误的一个示例是缺少模块功能块。 " }, 
{ "title" : "变更事件 ", 
"url" : "ac_editor_extension_module.html#UUID-91f9cff1-6f9e-ea6b-b3cd-d65abac7523b_ef0072b48b6aa7c0a8640e00080c11_id_4681e6c5b4a5a074c0a8640e01e5e429", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 扩展模块编辑器 \/ 变更事件 ", 
"snippet" : "如果相应的功能块、文本列表、图像池或可视化发生变化，编辑器的内容会自动更新。 （如果提到的对象与扩展模块位于同一文件夹中，则它们将被视为“对应”。）...", 
"body" : "如果相应的功能块、文本列表、图像池或可视化发生变化，编辑器的内容会自动更新。 （如果提到的对象与扩展模块位于同一文件夹中，则它们将被视为“对应”。） " }, 
{ "title" : "元数据 ", 
"url" : "ac_metadata_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 扩展模块编辑器 \/ 元数据 ", 
"snippet" : "在此选项卡上 扩展模块编辑器 ，显示描述和类别。显示的文本（类别除外）是从文本列表中读取的。为此应用编程系统当前使用的语言。如果该语言没有可用的文本，则将使用默认文本。如果根本没有文本输入，则不会显示任何文本。 与文本列表一样，图像也是从图像池中读取的。 扩展模块对话框 元数据 显示值右侧的按钮可打开文本列表或图像池中的相应行，从而允许更改文本。如果没有具有相应 ID 的文本\/图像，则会创建具有该 ID 的新元素。...", 
"body" : "在此选项卡上 扩展模块编辑器 ，显示描述和类别。显示的文本（类别除外）是从文本列表中读取的。为此应用编程系统当前使用的语言。如果该语言没有可用的文本，则将使用默认文本。如果根本没有文本输入，则不会显示任何文本。 与文本列表一样，图像也是从图像池中读取的。 扩展模块对话框 元数据 显示值右侧的按钮可打开文本列表或图像池中的相应行，从而允许更改文本。如果没有具有相应 ID 的文本\/图像，则会创建具有该 ID 的新元素。 " }, 
{ "title" : "范围 ", 
"url" : "ac_parameters_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 扩展模块编辑器 \/ 范围 ", 
"snippet" : "在选项卡上 扩展模块编辑器 ，扩展模块的参数列于表中。 扩展模块对话框： 范围 这 ID , 多变的 , 类型 ， 和 默认 列是只读的。在里面 姓名 和 描述 列中，您可以单击相应的行（如果已选择）或 空格键 直接跳转到相应文本列表的相应行。使用当前为编程系统设置的语言从文本列表中读取显示的文本。如果文本列表中缺少该语言，则将使用该条目的默认文本。在专栏中 默认 将显示参数的初始化值。 该表支持条目的多重选择以及使用鼠标和键盘的标准处理。所有更改参数的操作都可以通过标准撤消或重做 撤消 和 重做 命令。这 切 , 复制 ， 和 粘贴 不支持函数。 您可以使用箭头按钮或 替代 + ↑ 和 替代...", 
"body" : "在选项卡上 扩展模块编辑器 ，扩展模块的参数列于表中。 扩展模块对话框： 范围 这 ID , 多变的 , 类型 ， 和 默认 列是只读的。在里面 姓名 和 描述 列中，您可以单击相应的行（如果已选择）或 空格键 直接跳转到相应文本列表的相应行。使用当前为编程系统设置的语言从文本列表中读取显示的文本。如果文本列表中缺少该语言，则将使用该条目的默认文本。在专栏中 默认 将显示参数的初始化值。 该表支持条目的多重选择以及使用鼠标和键盘的标准处理。所有更改参数的操作都可以通过标准撤消或重做 撤消 和 重做 命令。这 切 , 复制 ， 和 粘贴 不支持函数。 您可以使用箭头按钮或 替代 + ↑ 和 替代 + ↓ 用于向上或向下移动所选参数以更改顺序的快捷方式。 您可以使用该按钮 X 或标准 德尔 命令删除选定的参数。 参数的任何错误或警告将显示在消息列表的底部。如果选择一条消息，则会在上面的参数列表中选择相应的参数。 带星号的按钮或 替代 + n 快捷方式（如果表格具有焦点）可用于打开 新参数 对话： 扩展模块对话框： 新参数 在对话框的上部显示一个层次结构表，其中包含功能块的所有兼容变量。 要激活 好的 按钮必须选择一个变量并且是唯一的 ID 必须输入。如果 ID 不唯一，则添加一个带有错误文本的红色感叹号。 在田野里 姓名 和 描述 可以输入标准文本，该文本将存储在关联的文本列表中。然后，必须将各种语言的文本添加到文本列表中。 如果变量是功能模块的输入变量或结构体的局部变量，则显示该变量。如果变量具有原始类型，则可以选择该变量。 " }, 
{ "title" : "输入\/输出 ", 
"url" : "ac_io_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 扩展模块编辑器 \/ 输入\/输出 ", 
"snippet" : "该选项卡的 扩展模块编辑器 用于创建新 I\/O 的对话框的行为与 参数 标签。而不是柱子 默认 方向 进出 显示输入\/输出的信息。 扩展模块对话框： 输入\/输出...", 
"body" : "该选项卡的 扩展模块编辑器 用于创建新 I\/O 的对话框的行为与 参数 标签。而不是柱子 默认 方向 进出 显示输入\/输出的信息。 扩展模块对话框： 输入\/输出 " }, 
{ "title" : "人机界面 ", 
"url" : "ac_hmi_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 扩展模块编辑器 \/ 人机界面 ", 
"snippet" : "该选项卡的 扩展模块编辑器 允许定义 页面可视化 以及 嵌入式可视化 。两个文本字段都允许定义多个可视化名称，以逗号分隔。 扩展模块对话框： 人机界面...", 
"body" : "该选项卡的 扩展模块编辑器 允许定义 页面可视化 以及 嵌入式可视化 。两个文本字段都允许定义多个可视化名称，以逗号分隔。 扩展模块对话框： 人机界面 " }, 
{ "title" : "可视化屏幕 ", 
"url" : "f_application_composer_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 可视化屏幕 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "顶级模板 ", 
"url" : "ac_toplevel_templates.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 可视化屏幕 \/ 顶级模板 ", 
"snippet" : "顶级模板是生成的可视化的起始页面的模板。它包含一个框架作为用户特定页面和选项卡的占位符以切换到不同的页面。 （可选）有用于导航到页面的按钮以及状态和地址行。可以在设置中选择顶级模板 可视化生成器 。 这 AC_ModuleBase 库是标准安装的一部分 CODESYS Application Composer 包含三个顶级模板： AC.GenVisu_Toplevel_Template 、AC.Toplevel_Vertical_Template 和 AC.Toplevel_3S_Vertical_Template 。 标准顶层模板 顶层模板： AC_Toplevel_3S_Vertical_...", 
"body" : "顶级模板是生成的可视化的起始页面的模板。它包含一个框架作为用户特定页面和选项卡的占位符以切换到不同的页面。 （可选）有用于导航到页面的按钮以及状态和地址行。可以在设置中选择顶级模板 可视化生成器 。 这 AC_ModuleBase 库是标准安装的一部分 CODESYS Application Composer 包含三个顶级模板： AC.GenVisu_Toplevel_Template 、AC.Toplevel_Vertical_Template 和 AC.Toplevel_3S_Vertical_Template 。 标准顶层模板 顶层模板： AC_Toplevel_3S_Vertical_Template 除了准备好的模板之外，还可以创建用户定义的顶级模板。 顶级模板的元素 (1)：导航：向上\/后退\/前进 (2)：框架显示页面 (3)：用于直接导航至顶级页面的选项卡 (4)：状态行 (5): 地址行：显示的模块实例的实例路径 可视化模板的元素由其元素名称来标识。在下面的列表中，元素的名称写在括号中。 模板的强制元素 [Frame] ：显示可视化页面的主框架。为了获得最佳效果，框架的比例类型应设置为“各向同性”。 [Tab_Template_1] , [Tab_Template_2] ：两个元素，用于所有选项卡的外观和排列。 Tab_Template_1 定义第一个选项卡的位置和所有选项卡的外观。将根据 Tab_Template_2 的位置计算选项卡的排列（水平或垂直）以及选项卡之间的间隙。如果显示页面的层次结构低于选项卡代表的实例，则会设置警报颜色。如果该元素是按钮，则还将设置按钮状态变量。如果元素是框架，则不会使用警报颜色。相反，如果选择了选项卡，则开关框架变量将设置为“1”（默认为 0）。 模板的可选元素 [Up] , [Back] , [Forward] ：导航元素，可以是按钮或框架。元素类型可以是按钮或框架。如果是框架，框架必须包含三个可视化效果，且必须按以下顺序排列：中性、按下、停用。 [Address] ：输出所显示模块实例的实例路径的文本字段。 [Status] ：显示全局字符串变量内容的文本字段 ac.g_stVisuStatusBar 来自库 AC_ModuleBase。该变量可以在自己的模块实现中使用来显示变量的状态。 所有其他元素都不是由可视化生成器专门处理的。对于生成，模板可视化会复制并修改副本。原件没有改变。 除了上述可视化元素之外，可视化生成器尝试不更改任何已手动更改的元素。在第一次可视化生成时，复制所描述的可视化模板。这个副本只要不被用户删除，就只会在未来的生成运行中被修改而不会重新复制。这是通过将早期生成器运行的顶级可视化视为新的可视化模板（原始模板永远不会更改）来完成的，尽管它没有被复制。因此，如果有其他选项卡，这些选项卡将添加到现有选项卡中。如果可能的话，所有其他属性和元素都不会被触及，以便用户手动添加的按钮、选项卡等将保持其位置。 删除例如导航按钮会导致它们丢失。要生成这些，必须删除并重新生成顶层 visu " }, 
{ "title" : "选项卡的对齐方式 ", 
"url" : "ac_toplevel_templates.html#UUID-b04a5efa-11da-0879-903b-e5e3a3f27499_ac_toplevel_templates0", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 可视化屏幕 \/ 顶级模板 \/ 选项卡的对齐方式 ", 
"snippet" : "选项卡将从左到右水平对齐或从上到下垂直对齐。模板元素的相对位置 Tab_Template_1 和 Tab_Template_2 定义对齐方式：如果元素的垂直距离大于水平距离，则元素将水平对齐，否则垂直对齐。 在垂直对齐的情况下，所有选项卡的宽度相同，这是所有选项卡名称可以显示的最小宽度。在水平对齐的情况下，每个选项卡都会获得可以显示其名称的最小宽度。在这两种情况下，选项卡的高度都将设置为第一个模板的高度（ Tab_Template_1 ）。 对于放置，将复制第一个模板并针对每个选项卡进行调整。 放置从第一个模板的位置开始 - 两个选项卡之间的距离由两个模板之间的水平或垂直距离决定。该距离也可以...", 
"body" : "选项卡将从左到右水平对齐或从上到下垂直对齐。模板元素的相对位置 Tab_Template_1 和 Tab_Template_2 定义对齐方式：如果元素的垂直距离大于水平距离，则元素将水平对齐，否则垂直对齐。 在垂直对齐的情况下，所有选项卡的宽度相同，这是所有选项卡名称可以显示的最小宽度。在水平对齐的情况下，每个选项卡都会获得可以显示其名称的最小宽度。在这两种情况下，选项卡的高度都将设置为第一个模板的高度（ Tab_Template_1 ）。 对于放置，将复制第一个模板并针对每个选项卡进行调整。 放置从第一个模板的位置开始 - 两个选项卡之间的距离由两个模板之间的水平或垂直距离决定。该距离也可以为负值，在这种情况下，下一个选项卡会与前一个选项卡重叠并在其上绘制，因为它更靠前。在垂直对齐的情况下，如果向下没有足够的空间来容纳所有选项卡，则生成会中止并出现错误。不会创建第二列选项卡。在水平对齐的情况下，如果下一个选项卡不再水平适合可视化效果，将创建一个新行。如果该行的第一个选项卡发生这种情况，则生成会因错误而中止。 可能会出现没有足够的空间容纳选项卡的情况。在水平对齐的情况下，换行时会发生这种情况。垂直对齐时，当选项卡的宽度大于模板中为其提供的空间时，就会发生这种情况。在这些情况下，人们会尝试创造更多的空间。由于元素的这种自动对齐，有四种可能的情况来排列选项卡： 选项卡水平对齐：所有选项卡必须完全位于框架上方 选项卡水平对齐：所有选项卡必须完全位于框架下方 选项卡垂直对齐：所有选项卡必须完全位于框架的左侧 选项卡垂直对齐：所有选项卡必须完全位于框架的右侧 如果选项卡的对齐方式与上述限制不匹配，则会创建错误消息。 如果没有足够的空间容纳选项卡，则框架会相应缩小。选项卡和框架之间的所有元素都会移动。如果元素的位置没有完全超出第一个选项卡模板的外部限制，则该位置被解释为“选项卡和框架之间”（请参阅下面的水平排列示例）。 如果修改框架大小会导致负值，则可视化的创建将中止。 选项卡和框架之间的元素示例 选项卡和框架“外部”的元素示例 " }, 
{ "title" : "生成可视化屏幕 ", 
"url" : "ac_generating_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 可视化屏幕 \/ 生成可视化屏幕 ", 
"snippet" : "对于应用程序编辑器中的可视化屏幕，所有元素 CODESYS V3 以及可以使用嵌入式可视化屏幕。此外，可以使用标记为特殊占位符的 visu 元素（例如：矩形）： 可视化中的导航 可视化中的导航可以通过使用选项卡或 后退 , 向上 ， 和 向前 导航按钮。鼠标单击选项卡元素会直接切换到相应的可视化屏幕。这 后退 和 向前 按钮可用于在显示屏幕的历史记录中进行导航（类似于 Internet 浏览器中的导航）。这 向上 按钮切换到下一个更高级别。...", 
"body" : "对于应用程序编辑器中的可视化屏幕，所有元素 CODESYS V3 以及可以使用嵌入式可视化屏幕。此外，可以使用标记为特殊占位符的 visu 元素（例如：矩形）： 可视化中的导航 可视化中的导航可以通过使用选项卡或 后退 , 向上 ， 和 向前 导航按钮。鼠标单击选项卡元素会直接切换到相应的可视化屏幕。这 后退 和 向前 按钮可用于在显示屏幕的历史记录中进行导航（类似于 Internet 浏览器中的导航）。这 向上 按钮切换到下一个更高级别。 " }, 
{ "title" : "可视化屏幕中的占位符元素 ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_1d3a1d9285970a30c0a8640e01de1c5b", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 可视化屏幕 \/ 生成可视化屏幕 \/ 可视化屏幕中的占位符元素 ", 
"snippet" : "标准可视化元素（例如：矩形、图像）可以用作占位符元素。生成可视化时，分配的嵌入式可视化将排列在占位符位置（位置和大小）。 规格 占位符元素的定义是通过元素的实例名称来完成的。元素的名称必须是 PLACEHOLDER_<SUBPATH> 。语法为 <SUBPATH> ： <SUBPATH> ::= <SLOTREF> | <SLOTREF>:<SUBPATH> <SLOTREF> ::= <SLOTNAME> | <SLOTNAME>[<idx>] 这 <SLOTNAME> 是插槽的目标名称（大小写无关）。 <idx> 是一个从零开始的索引，只能用于多槽。它定义应显示多槽的哪个子模块实例。 在读...", 
"body" : "标准可视化元素（例如：矩形、图像）可以用作占位符元素。生成可视化时，分配的嵌入式可视化将排列在占位符位置（位置和大小）。 规格 占位符元素的定义是通过元素的实例名称来完成的。元素的名称必须是 PLACEHOLDER_<SUBPATH> 。语法为 <SUBPATH> ： <SUBPATH> ::= <SLOTREF> | <SLOTREF>:<SUBPATH> <SLOTREF> ::= <SLOTNAME> | <SLOTNAME>[<idx>] 这 <SLOTNAME> 是插槽的目标名称（大小写无关）。 <idx> 是一个从零开始的索引，只能用于多槽。它定义应显示多槽的哪个子模块实例。 在读取模块定义时，系统会检查可视化屏幕中的占位符名称是否有效。如果可视化屏幕的元素以“ PLACEHOLDER_ “（大小写无关）， <SUBPATH> 必须以有效的插槽引用开始。如果存在索引，则它必须与槽基数兼容。路径的所有插槽名称必须是有效的 IEC 标识符。如果有多个占位符，则所有路径必须不同。此外，占位符元素不得有空白区域。 如果不存在相应的模块实例 <SUBPATH> 如果是占位符元素，则不会将任何可视化分配给该元素。不会创建错误消息。 如果存在相应的模块实例 <SUBPATH> 占位符元素的一个元素，如果该元素被定义为当前屏幕的嵌入屏幕可视化，则该元素将被嵌入。 嵌入式可视化将保持其原始纵横比。尺寸将以最佳方式适应占位符，而不会超出占位符。 占位符元素示例 只能使用占位符嵌入子模块实例及其子模块实例。无法从模块树的其他分支嵌入可视化。 " }, 
{ "title" : "检查顶层模板 ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_335369a685ed9d34c0a8652001ab0576", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 可视化屏幕 \/ 生成可视化屏幕 \/ 检查顶层模板 ", 
"snippet" : "在顶层屏幕上执行以下检查： 如果可视化模板不存在或者其界面中定义了输入或输出，则会显示错误。 如果缺少必需元素，将显示错误。 如果定义了顶级模板的元素，但它有空白区域或错误的元素类型，则会显示错误。 如果选项卡模板和框架重叠，则会显示错误。 如果第二个选项卡模板的位置与第一个模板相同或者位于第一个模板的左侧或上方，则会显示错误。 在选项卡水平对齐的情况下，如果选项卡未完全位于框架上方或下方，则会产生错误。 在垂直对齐选项卡的情况下，如果选项卡未完全位于框架的右侧或左侧，则会产生错误。...", 
"body" : "在顶层屏幕上执行以下检查： 如果可视化模板不存在或者其界面中定义了输入或输出，则会显示错误。 如果缺少必需元素，将显示错误。 如果定义了顶级模板的元素，但它有空白区域或错误的元素类型，则会显示错误。 如果选项卡模板和框架重叠，则会显示错误。 如果第二个选项卡模板的位置与第一个模板相同或者位于第一个模板的左侧或上方，则会显示错误。 在选项卡水平对齐的情况下，如果选项卡未完全位于框架上方或下方，则会产生错误。 在垂直对齐选项卡的情况下，如果选项卡未完全位于框架的右侧或左侧，则会产生错误。 " }, 
{ "title" : "创建可视化屏幕 ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_85c3e6868b643da6c0a8640e01a0782b", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 可视化屏幕 \/ 生成可视化屏幕 \/ 创建可视化屏幕 ", 
"snippet" : "所有可视化屏幕最初将由命令创建 产生 。当第二个生成器运行时，仅更新模块树中已更改的参数。 创建的可视化屏幕包含一个框架，该框架定义可视化的大小并保存模块的相应可视化。该框架位于后台，所有嵌入的可视化将按如下方式排列： 所有嵌入元素均由元素 ID 永久标识。如果新的发电机运行更新了现有的可视化屏幕，系统将搜索相应的 ID。如果此元素 (ID) 存在，则仅更新模块配置中更改的参数。例如，位置保持不变，而可视化\/框架开关和用于显示的可视化对象可以改变。 嵌入的可视化将在屏幕上从左到右、从上到下排列。匹配的占位符元素具有更高的优先级。最后，如果框架具有相应的，则两种机制都不会使用 ElementID...", 
"body" : "所有可视化屏幕最初将由命令创建 产生 。当第二个生成器运行时，仅更新模块树中已更改的参数。 创建的可视化屏幕包含一个框架，该框架定义可视化的大小并保存模块的相应可视化。该框架位于后台，所有嵌入的可视化将按如下方式排列： 所有嵌入元素均由元素 ID 永久标识。如果新的发电机运行更新了现有的可视化屏幕，系统将搜索相应的 ID。如果此元素 (ID) 存在，则仅更新模块配置中更改的参数。例如，位置保持不变，而可视化\/框架开关和用于显示的可视化对象可以改变。 嵌入的可视化将在屏幕上从左到右、从上到下排列。匹配的占位符元素具有更高的优先级。最后，如果框架具有相应的，则两种机制都不会使用 ElementID 在生成时已经存在。在这种情况下，位置保持不变。 在上次生成器运行中创建但当前生成器运行中不存在的可视化屏幕将被删除。 " }, 
{ "title" : "可视化元素的嵌入顺序 ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_b67bb7c98bca4d3bc0a8640e01a07a7d", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 可视化屏幕 \/ 生成可视化屏幕 \/ 可视化元素的嵌入顺序 ", 
"snippet" : "第一步中嵌入的所有可视化 next Ancestor 将会安排。这些元素将按照模块树中模块实例的前序插入。 （首先是第一个子模块，然后是其所有子模块，然后是第二个子模块，依此类推） 之后，将插入由实例定义嵌入的所有可视化。这也将在模块实例的预排序中完成。...", 
"body" : "第一步中嵌入的所有可视化 next Ancestor 将会安排。这些元素将按照模块树中模块实例的前序插入。 （首先是第一个子模块，然后是其所有子模块，然后是第二个子模块，依此类推） 之后，将插入由实例定义嵌入的所有可视化。这也将在模块实例的预排序中完成。 " }, 
{ "title" : "持久化管理器 ", 
"url" : "ac_pm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 ", 
"snippet" : "持久性管理器是应用程序编辑器的标准组件。它用于管理持久剩余数据。它通过某些方式识别这些变量 属性 在变量声明中。所以它是一个 VAR PERSISTENT 机制的替代选项 标准编程系统。它管理特殊全局变量列表中的持久变量（ 持久变量 ）。该机制是为时间性能和剩余内存区域中的存储而设计的。相反，持久性管理器将持久性值存储在 外部文件 因此对控制器的内存资源的要求更少。即使声明已修改，它也可以保留值，并且允许对数据进行外部编辑。然而，这种扩展功能是以性能为代价的。根据控制器的不同，大量持久变量的读取（尤其是写入）可能会花费大量时间，并且可能会长时间阻塞相应的任务。 因此，建议使用哪种机制来建立数据...", 
"body" : "持久性管理器是应用程序编辑器的标准组件。它用于管理持久剩余数据。它通过某些方式识别这些变量 属性 在变量声明中。所以它是一个 VAR PERSISTENT 机制的替代选项 标准编程系统。它管理特殊全局变量列表中的持久变量（ 持久变量 ）。该机制是为时间性能和剩余内存区域中的存储而设计的。相反，持久性管理器将持久性值存储在 外部文件 因此对控制器的内存资源的要求更少。即使声明已修改，它也可以保留值，并且允许对数据进行外部编辑。然而，这种扩展功能是以性能为代价的。根据控制器的不同，大量持久变量的读取（尤其是写入）可能会花费大量时间，并且可能会长时间阻塞相应的任务。 因此，建议使用哪种机制来建立数据持久性取决于用例。对于某些情况，甚至使用食谱也可能是最好的解决方案。为了帮助做出决定，请参阅： 坚持 持久性管理器是一个顶级模块，可以使用以下命令添加到模块树中 添加顶级模块实例 。 在持久性管理器下方，您最多可以插入 64 个通道。在频道中您可以定义 持久性组 并通过参数配置它们的存储行为。每个通道必须有一个子模块 Data Storage ，定义将持久数据写入文件的格式。您可以在此处定义持久数据在文件中的存储格式。该存档文件存储在外部，默认存储在控制器的安装目录中。 对于运行时系统版本 >= 3.5.8.0，存档文件的位置通过占位符定义 $ac_persistence$ 。如果在占位符定义的目录中找到已有的存档，则它们将被移动到此位置 $PLCLogic$ 。该目录是以前的运行时系统版本中的默认位置。对于位于这两个位置的存档，将向运行时系统日志发出警告。 每个应用程序只能将一个持久性管理器添加到模块树中。如果将持久性管理器添加到 POU 池，或者如果将多个持久性管理器添加到应用程序，则会创建一条错误消息。 将持久性管理器添加到模块树中 如果模块树或模块实例的参数已更改，则必须执行生成器运行。 （命令： 产生） 与“VAR PERSISTENCE”机制的差异 持久数据存储在外部文件中。 持久数据可以在项目之间交换。 持久变量可以从应用程序中删除。添加到应用程序而不会丢失剩余数据。 持久性管理器创建的数据可以使用外部编辑器进行修改。 （例如：记事本）。 也可以看看： 坚持 " }, 
{ "title" : "持久性管理模块 ", 
"url" : "ac_pm_persistencemanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 持久性管理模块 ", 
"snippet" : "双击 持久化管理器 模块树中的节点或 编辑对象 命令打开关联的编辑器。除了顶级模块的标准编辑器（参见 概述 ）持久性管理器提供 坚持 标签。 人机界面 持久性管理器提供了一个可视化模板（ VISU_PersistenceManager ）可以将其添加到可视化中。 HMI 设置对话框 该页面提供变量读写的统计信息： 持久性数据的可视化页面...", 
"body" : "双击 持久化管理器 模块树中的节点或 编辑对象 命令打开关联的编辑器。除了顶级模块的标准编辑器（参见 概述 ）持久性管理器提供 坚持 标签。 人机界面 持久性管理器提供了一个可视化模板（ VISU_PersistenceManager ）可以将其添加到可视化中。 HMI 设置对话框 该页面提供变量读写的统计信息： 持久性数据的可视化页面 " }, 
{ "title" : "坚持 ", 
"url" : "ac_pm_persistencemanager_module.html#UUID-87fcb435-c65b-2e65-6037-f61974f5b1d7_e4fa0ddccaa0cf0c0a8640e01493625_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 持久性管理模块 \/ 坚持 ", 
"snippet" : "对话： 坚持 在里面 坚持 对话框可以将一个或多个组从存储中排除。要创建新组，必须输入唯一名称并添加 添加 按钮。这 消除 命令允许删除现有组。 可以使用属性从存储中排除变量 ac_persist_exclude 。 有关更多信息，请参阅： 属性：“ac_persist_exclude”...", 
"body" : "对话： 坚持 在里面 坚持 对话框可以将一个或多个组从存储中排除。要创建新组，必须输入唯一名称并添加 添加 按钮。这 消除 命令允许删除现有组。 可以使用属性从存储中排除变量 ac_persist_exclude 。 有关更多信息，请参阅： 属性：“ac_persist_exclude” " }, 
{ "title" : "持久化通道 ", 
"url" : "ac_pm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 持久化通道 ", 
"snippet" : "持久性通道定义一组或多组持久性变量的存储设置。可以使用以下命令将其添加到 Persistence Manager 节点 添加子模块实例 。在持久性管理器节点下，最多可以创建 64 个通道。 人机界面、信息 有关这些对话框的详细信息，请参阅以下内容： 输入\/输出， 人机界面 和 信息。...", 
"body" : "持久性通道定义一组或多组持久性变量的存储设置。可以使用以下命令将其添加到 Persistence Manager 节点 添加子模块实例 。在持久性管理器节点下，最多可以创建 64 个通道。 人机界面、信息 有关这些对话框的详细信息，请参阅以下内容： 输入\/输出， 人机界面 和 信息。 " }, 
{ "title" : "坚持 ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 持久化通道 \/ 坚持 ", 
"snippet" : "持久组 在此对话框中，可以定义由该通道管理的一个或多个组。默认情况下，通道模块实例的实例名称在列表中可用。要创建新组，必须输入唯一名称并添加 添加 按钮。 消除 可用于删除选定的组。 可以通过属性将变量分配给组 ac_persist 。欲了解更多信息，请参阅： 持久变量、属性的定义 'ac.persist' 持久变量 ：此列表显示分配给上面列出的持久性组之一的所有持久性变量。...", 
"body" : "持久组 在此对话框中，可以定义由该通道管理的一个或多个组。默认情况下，通道模块实例的实例名称在列表中可用。要创建新组，必须输入唯一名称并添加 添加 按钮。 消除 可用于删除选定的组。 可以通过属性将变量分配给组 ac_persist 。欲了解更多信息，请参阅： 持久变量、属性的定义 'ac.persist' 持久变量 ：此列表显示分配给上面列出的持久性组之一的所有持久性变量。 " }, 
{ "title" : "范围 ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 持久化通道 \/ 范围 ", 
"snippet" : "这 参数 选项卡提供与变量存储相关的选项列表： 持久通道参数 t定期保存 ：经过此间隔后，变量将被存储。输入值 t#0s 将关闭此定期保存。 x保存更改 ：如果设置为TRUE，当前值将不断与上次保存的值进行比较，如果不同，则存储当前值。已设置的持久化通道 xSaveOnChange=FALSE ，将在控制器关闭以及重置（热、冷、原点）时存储。此外，可以进行定期保存。 xReadVarsDuringInit ：如果设置为 TRUE ，将在应用程序初始化期间读取持久变量值。否则，它们将在第一个应用程序周期中加载。 x压缩标签 ：如果设置为 TRUE ，变量的实例路径将以压缩格式保存。欲了解更多信息...", 
"body" : "这 参数 选项卡提供与变量存储相关的选项列表： 持久通道参数 t定期保存 ：经过此间隔后，变量将被存储。输入值 t#0s 将关闭此定期保存。 x保存更改 ：如果设置为TRUE，当前值将不断与上次保存的值进行比较，如果不同，则存储当前值。已设置的持久化通道 xSaveOnChange=FALSE ，将在控制器关闭以及重置（热、冷、原点）时存储。此外，可以进行定期保存。 xReadVarsDuringInit ：如果设置为 TRUE ，将在应用程序初始化期间读取持久变量值。否则，它们将在第一个应用程序周期中加载。 x压缩标签 ：如果设置为 TRUE ，变量的实例路径将以压缩格式保存。欲了解更多信息，请参阅： 存储格式、压缩档案 。 xConstantCopyInHighPrioTask ：如果设置为 TRUE ，变量从最高优先级任务复制并保存在较低优先级任务中。该选项用于避免在高优先级任务中更改变量时出现数据不一致。 xConvertVarsWithDifferentType ：如果设置为 TRUE ，持久化通道将尝试将从归档中读取的值转换为目标数据类型（如果该值的数据类型与目标的数据类型不同）。如果成功，存档中的值将被接受；如果不是，该值将被拒绝。该函数支持以下转换： 存档中的数据类型 目标数据类型 描述 任意整数 任意整数 仅当该值在当前数据类型覆盖的范围内时 任意整数 真实的 任意整数 真实 所有数据类型 细绳 真实的 真实 真实的 任意_INT 仅当归档值是正确范围内的整数时 真实 真实的 仅当该值在 REAL 覆盖的范围内时 真实 任意_INT 仅当归档值是正确范围内的整数时 x阅读前完整性检查 ：如果设置为 TRUE ，检查数据库的完整性。 xSeparateArchivePerToplevelInstance : 当设置为 TRUE 时，将为每个顶层实例创建一个单独的存档。此类存档的名称为其自身名称（与数据存储中的配置一致），后跟顶层实例的名称： <archive name>_<instance name> ；对于所有不低于顶层模块实例的实例（例如：应用程序变量），则为 <archive name> 。此选项默认禁用。 如果事后修改参数（ TRUE <-> FALSE ），存档名称将被更改，持久变量可能会丢失！ xMakeDataCRC一致性检查 ：如果设置为 TRUE ，在保存操作的开始和结束时计算 CRC 值。这两个值必须相同才能成功完成保存操作。 uiSavingRetriesIfCRCConsistencyCheckFails ：指定重复存储的次数 xMakeDataCRCConsistencyCheck失败 被设定为 TRUE 并且 CRC 值不匹配。 xLogSaveTime启用 ：如果设置为 TRUE ，记录写入所需的时间。 e自动操作在线更改 ：在线更改期间变量值是否存储以及如何存储的行为。 没有任何 ：无存储 节省 : 值被保存。因此，对配置的更改也会被接管到持久性内存中（例如添加或重命名变量）。 加载 ：从持久性内存加载值。因此，可能的初始化（例如 FB_INIT , IModule.Init 和模块参数）被持久值覆盖。 加载并保存 ：从持久性内存中加载和写入值。 eAutomaticActionPlcStop ：确定复位期间是否存储变量值。 没有任何 ：无存储 节省 : 值被保存。 " }, 
{ "title" : "模块：数据存储 ", 
"url" : "ac_pm_storage_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 模块：数据存储 ", 
"snippet" : "数据存储 子模块 数据存储 定义了 存储格式 的一个 持久通道 。 选择以下存储格式之一： ASCIIFileStorage ：将值以 ASCII 格式保存在文件中。 这 ASCIIFileStorage 格式允许在文本编辑器中打开存档文件并修改值。可以将注释添加到 ASCII 文件存档中。读取文件时这些将被忽略。 BinaryFileStorage ：将值以二进制格式保存在文件中。 BinaryMemoryStorage ：以二进制格式将值保存到编译器或相关设备的“RETAIN”区域（例如：保存到此类设备的 NVRAM）。 PersistentBinaryMemoryStorage ：以二进...", 
"body" : "数据存储 子模块 数据存储 定义了 存储格式 的一个 持久通道 。 选择以下存储格式之一： ASCIIFileStorage ：将值以 ASCII 格式保存在文件中。 这 ASCIIFileStorage 格式允许在文本编辑器中打开存档文件并修改值。可以将注释添加到 ASCII 文件存档中。读取文件时这些将被忽略。 BinaryFileStorage ：将值以二进制格式保存在文件中。 BinaryMemoryStorage ：以二进制格式将值保存到编译器或相关设备的“RETAIN”区域（例如：保存到此类设备的 NVRAM）。 PersistentBinaryMemoryStorage ：以二进制格式将值保存到编译器或相关设备的“持久”区域（例如：保存到此类设备的 NVRAM）。 在持久性通道下方插入一个 数据存储 所需格式的模块。如果需要的话，修改配置 范围 标签： 对话框：信息 有关此对话框的详细信息，请参阅： 信息 。 " }, 
{ "title" : "对话框：参数 ", 
"url" : "ac_pm_storage_module.html#UUID-1d4190f0-4f49-535e-fe96-bf340f625ee5_aa44ae4cccad1068c0a8640e019d97f0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 模块：数据存储 \/ 对话框：参数 ", 
"snippet" : "s档案名称 归档文件的名称 默认情况下占位符 %CHANNEL_NAME% 被定义为。该占位符将替换为上级持久通道的实例名称。存档名称必须是唯一的，因为所有存档文件默认存储在控制器的安装目录中。 注意：存档文件的默认存储位置取决于运行时系统版本。看： 持久性管理器概述 x双存储 如果激活（ TRUE ），变量交替存储在两个不同的档案中（ sArchive1 , sArchive2 ）。如果文件损坏（例如：由于在存储变量期间控制器关闭），将使用备份文件。打开文件时，持久性管理器会检查两个存档的时间戳。如果没有损坏，将使用较新的存档，否则使用另一个存档。 udi最大文件大小 最大文件大小（以字节为...", 
"body" : "s档案名称 归档文件的名称 默认情况下占位符 %CHANNEL_NAME% 被定义为。该占位符将替换为上级持久通道的实例名称。存档名称必须是唯一的，因为所有存档文件默认存储在控制器的安装目录中。 注意：存档文件的默认存储位置取决于运行时系统版本。看： 持久性管理器概述 x双存储 如果激活（ TRUE ），变量交替存储在两个不同的档案中（ sArchive1 , sArchive2 ）。如果文件损坏（例如：由于在存储变量期间控制器关闭），将使用备份文件。打开文件时，持久性管理器会检查两个存档的时间戳。如果没有损坏，将使用较新的存档，否则使用另一个存档。 udi最大文件大小 最大文件大小（以字节为单位） 如果 0 已定义，未设置或检查任何限制。所以文件大小可以达到任意大小。 通过分隔符 变量名称和值之间的分隔符的 ASCII 值。 udiMem数据大小 为模块创建的“RETAIN”变量区域中的存储器大小。 该值与要存储的数据的大小进行比较。如果该值确实太小，则会创建编译器错误。如果它可能太小，消息视图中会显示警告。 LineEnding 表示文件中行尾的字符 " }, 
{ "title" : "持久变量的定义 ", 
"url" : "ac_pm_definition_persistent_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 持久变量的定义 ", 
"snippet" : "单个变量以及结构实例和功能块实例可以通过使用属性来标记为“持久”。当一个实例被标记后，该实例的所有成员 VAR , VAR_INPUT ， 和 VAR_OUTPUT 将被持久存储。如果 a 中的变量 VAR PERSISTENT 部分被标记为“持久”，将创建一个警告。 此外，还有用于定义默认存储组以及从结构或功能块实例的持久存储中排除特定变量的属性。 如果持久变量的定义已被修改（添加、删除、重命名、更改数据类型），则不必执行新的 Composer 代码生成（命令生成）。这些更改将在编译期间自动更新到持久管理器实例中。 有关修改数据类型定义时可能的隐式转换的信息，请参阅： 范围 属性：'ac_p...", 
"body" : "单个变量以及结构实例和功能块实例可以通过使用属性来标记为“持久”。当一个实例被标记后，该实例的所有成员 VAR , VAR_INPUT ， 和 VAR_OUTPUT 将被持久存储。如果 a 中的变量 VAR PERSISTENT 部分被标记为“持久”，将创建一个警告。 此外，还有用于定义默认存储组以及从结构或功能块实例的持久存储中排除特定变量的属性。 如果持久变量的定义已被修改（添加、删除、重命名、更改数据类型），则不必执行新的 Composer 代码生成（命令生成）。这些更改将在编译期间自动更新到持久管理器实例中。 有关修改数据类型定义时可能的隐式转换的信息，请参阅： 范围 属性：'ac_persist_exclude' 属性 'ac_persist_exclude' 用于从持久存储中排除变量，无论结构或功能块声明中的成员是否定义为“持久”。如果声明中不存在持久成员，则会在代码生成期间创建错误。 排除变量的示例 PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_exclude'}\n fb1 : FB;\nEND_VAR " }, 
{ "title" : "支持的数据类型 ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_beff9eaed151b190c0a8640e01016617", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 持久变量的定义 \/ 支持的数据类型 ", 
"snippet" : "以下数据类型的实例无法持久存储： 少量 指针 接口 常数 非持久数据类型的数组 支持所有其他数据类型。这包括枚举、子范围数据类型、数组的数组和多维数组： ARRAY[0..9] OF ARRAY[5..6, 7..8, 9..10] OF INT 数据类型： 联盟 要持久保存联合实例，其字段之一必须标记为“代表性”。有以下三种可能的方式： 联合声明中恰好有一个字段用该属性标记 ac_persist_union_representant （没有属性值）。该字段“代表”联合。它的值将代表整个联合进行保存和加载。 联合声明中的确切一个字段用属性标记 ac_persist – 这同时定义了代表。 联合...", 
"body" : "以下数据类型的实例无法持久存储： 少量 指针 接口 常数 非持久数据类型的数组 支持所有其他数据类型。这包括枚举、子范围数据类型、数组的数组和多维数组： ARRAY[0..9] OF ARRAY[5..6, 7..8, 9..10] OF INT 数据类型： 联盟 要持久保存联合实例，其字段之一必须标记为“代表性”。有以下三种可能的方式： 联合声明中恰好有一个字段用该属性标记 ac_persist_union_representant （没有属性值）。该字段“代表”联合。它的值将代表整个联合进行保存和加载。 联合声明中的确切一个字段用属性标记 ac_persist – 这同时定义了代表。 联合的实例用属性标记 ac_persist_union_set_representant 包括属性值。属性值描述了用作代表的联合字段的名称。该属性会覆盖现有的 ac_persist_union_representant 联合声明中的属性。联合数组也可以被标记并引用数组的元素。 例子 'ac_persist_union_representant' TYPE UnionWithRep :\nUNION\n di : DINT ;\n {attribute 'ac_persist_union_representant'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 'ac_persist' TYPE UnionWithPersist :\nUNION\n di : DINT ;\n {attribute 'ac_persist' := 'TestUnion'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 'ac_persist_union_set_representant' FUNCTION_BLOCK FBTestUnion\nVAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n u2 : UnionWithoutRep ;\nEND_VAR 联合数组 VAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aElems ARRAY[0..7] OF SomeUnion ;\n\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aaElems ARRAY[0..7] OF ARRAY[0..1] OF SomeUnion ;\nEND_VAR 代表要有效，必须满足以下规则： 代表的人数必须与整个工会的人数相同。否则将无法保存完整的数据。该代表也不能有任何填充区域（编译器创建的空数据区域，用于对齐存储中的数据）。 原始数据类型中代表的分解不得包含类型的实例 REAL 或者 LREAL 或类型的实例 STRING 或者 WSTRING 。 此外，代表必须由受支持的类型组成（见上文）。例如，代表可以是类型 Structure – 但是，结构本身不能包含指针。 " }, 
{ "title" : "属性：'ac_persist' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_e844aaa8d151b192c0a8640e01722fe3", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 持久变量的定义 \/ 属性：'ac_persist' ", 
"snippet" : "属性 ' ac_persist ' 可用于 变量 结构实例 功能块实例 结构成员 功能块成员 {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP 是的名字 持久组 声明应分配给该对象。它必须是有效的 IEC 标识符。如果这里没有命名持久组，将根据属性进行分配 'ac_persist_set_default_group' ，在这种情况下必须定义。 如果结构实例或功能块实例被标记为“持久”，并且声明中的至少一个成员也被标记为“持久”，则会创建一条错误消息。 持久实例的示例 变量 t 被分配到持久组 PROCE...", 
"body" : "属性 ' ac_persist ' 可用于 变量 结构实例 功能块实例 结构成员 功能块成员 {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP 是的名字 持久组 声明应分配给该对象。它必须是有效的 IEC 标识符。如果这里没有命名持久组，将根据属性进行分配 'ac_persist_set_default_group' ，在这种情况下必须定义。 如果结构实例或功能块实例被标记为“持久”，并且声明中的至少一个成员也被标记为“持久”，则会创建一条错误消息。 持久实例的示例 变量 t 被分配到持久组 PROCESS 。所有成员都将被持久存储。 PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist' := 'PROCESS'}\n t : TON;\nEND_VAR 功能块的持久成员的示例 会员 iNumIOs 被分配到持久组 CONFIG 。该成员将为功能块的所有实例永久存储（如果没有通过属性显式抑制） 'ac_persist_exclude' ）。 FUNCTION_BLOCK FB\nVAR\n {attribute 'ac_persist' := 'CONFIG'}\n iNumIOs : INT := 0;\nEND_VAR " }, 
{ "title" : "属性：'ac_persist_set_default_group' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_4130a661d151b192c0a8640e00b1a163", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 持久变量的定义 \/ 属性：'ac_persist_set_default_group' ", 
"snippet" : "如果属性中缺少组名称 'ac_persist' ， A 默认组 必须在直接或间接包含相应变量的功能块实例或结构实例中定义。这可以通过属性实现 'ac_persist_set_default_group' 。还可以为功能块的成员设置该属性。最里面找到的定义 'ac_persist_set_default_group' 将用作变量的默认组。 不允许使用 'ac_persist_set_default_group' 和...一起 'ac_persist' 或者 'ac_persist_exclude' 。在这种情况下，代码生成期间将创建一条错误消息。 默认组的示例 FUNCTION_BLOCK FB...", 
"body" : "如果属性中缺少组名称 'ac_persist' ， A 默认组 必须在直接或间接包含相应变量的功能块实例或结构实例中定义。这可以通过属性实现 'ac_persist_set_default_group' 。还可以为功能块的成员设置该属性。最里面找到的定义 'ac_persist_set_default_group' 将用作变量的默认组。 不允许使用 'ac_persist_set_default_group' 和...一起 'ac_persist' 或者 'ac_persist_exclude' 。在这种情况下，代码生成期间将创建一条错误消息。 默认组的示例 FUNCTION_BLOCK FB_Util\nVAR\n {attribute 'ac_persist'} \/\/ no group\n \/\/'ac_persist_set_default_group‘ and 'ac_persist_exclude' not allowed here\n i : INT := 0;\nEND_VAR PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_set_default_group' := 'PROCESS'}\n fbu1 : FB_Util;\n\n {attribute 'ac_persist_set_default_group'´ := 'CONFIG'}\n fbu2 : FB_Util;\nEND_VAR " }, 
{ "title" : "数据存储 ", 
"url" : "ac_pm_data_storage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 数据存储 ", 
"snippet" : "持久变量的存储可以通过多种方式触发： 每个 持久通道 提供一个应用程序接口，应用程序可以使用该接口来触发存储（请参阅 数据存取 ）。 在持久通道的参数中，时间间隔（ t定期保存 ) 可以定义为自动存储。 持久化通道可以配置为在变量值发生变化时存储该变量。为此，比较先前值和当前值；如果它们不同，则会触发存储。 不同的存储方式可以并行使用，并且它们并不互相排斥。 如果控制器关闭或“重置”（热\/冷\/原点）后，如果参数 x保存更改 未设置。 有关更多信息，另请参阅： 模块：数据存储...", 
"body" : "持久变量的存储可以通过多种方式触发： 每个 持久通道 提供一个应用程序接口，应用程序可以使用该接口来触发存储（请参阅 数据存取 ）。 在持久通道的参数中，时间间隔（ t定期保存 ) 可以定义为自动存储。 持久化通道可以配置为在变量值发生变化时存储该变量。为此，比较先前值和当前值；如果它们不同，则会触发存储。 不同的存储方式可以并行使用，并且它们并不互相排斥。 如果控制器关闭或“重置”（热\/冷\/原点）后，如果参数 x保存更改 未设置。 有关更多信息，另请参阅： 模块：数据存储 " }, 
{ "title" : "存储格式 ", 
"url" : "ac_pm_storage_format.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 存储格式 ", 
"snippet" : "该接口有两种实现方式 IDataStorage 可用的： ASCIIDataStorage 和 BinaryDataStorage 。 在这两种格式中，存储的第一个变量是保留变量 ___xCompressTags 类型的 BOOL 。它的值确定实例路径是否以压缩方式存储。如果写入完整性对象，则将其写入名为最后一个变量 ___Integrity 类型的 BOOL 有价值 TRUE 。除了这些保留变量之外的所有持久变量都按顺序存储并按其完整实例路径排序。实例路径是否压缩并不重要。 如果用户修改了数据，他必须确保保持正确的排序顺序。 压缩档案 变量值与路径和名称（在路径中既没有应用程序也没有设备名称...", 
"body" : "该接口有两种实现方式 IDataStorage 可用的： ASCIIDataStorage 和 BinaryDataStorage 。 在这两种格式中，存储的第一个变量是保留变量 ___xCompressTags 类型的 BOOL 。它的值确定实例路径是否以压缩方式存储。如果写入完整性对象，则将其写入名为最后一个变量 ___Integrity 类型的 BOOL 有价值 TRUE 。除了这些保留变量之外的所有持久变量都按顺序存储并按其完整实例路径排序。实例路径是否压缩并不重要。 如果用户修改了数据，他必须确保保持正确的排序顺序。 压缩档案 变量值与路径和名称（在路径中既没有应用程序也没有设备名称）一起以紧凑的拼写存储，以节省资源和时间。 在任何情况下（压缩与否），实例路径都必须按完整实例路径的顺序排序。此排序顺序是按字母顺序排列的，因此数组索引按数字顺序排序。 例子 对象 压缩格式 Fb1.fb2.fb3.a Fb1.fb2.fb3.a Fb1.fb2.fb3.b <b Fb1.fb2.d <<d Fb4 FB4 " }, 
{ "title" : "ASCII 格式 ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_7b30973fd16738e7c0a8640e01455e29", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 存储格式 \/ ASCII 格式 ", 
"snippet" : "ASCIIDataStorage 将持久变量的每个实例路径（可能以压缩格式）、数据类型和值作为字符串写入文件中。名称和日期由制表符分隔（可以通过参数更改 codbySeparator ）。当读取存档时，将执行转换。因此可以从外部修改该文件。行必须用“\\r\\n”分隔（Windows 约定）。以分号开头的行在读取时将被忽略 - 写入存档时不会添加该行。 ASCII 文件的格式： {timestamp}\\r\\n {instance path}{bySeparator}{Typ}:{value}\\r\\n … {instance path}{bySeparator}{Typ}:{value}\\r\\n 时...", 
"body" : "ASCIIDataStorage 将持久变量的每个实例路径（可能以压缩格式）、数据类型和值作为字符串写入文件中。名称和日期由制表符分隔（可以通过参数更改 codbySeparator ）。当读取存档时，将执行转换。因此可以从外部修改该文件。行必须用“\\r\\n”分隔（Windows 约定）。以分号开头的行在读取时将被忽略 - 写入存档时不会添加该行。 ASCII 文件的格式： {timestamp}\\r\\n\n{instance path}{bySeparator}{Typ}:{value}\\r\\n\n…\n{instance path}{bySeparator}{Typ}:{value}\\r\\n 时间戳决定了存储被触发的时间。它被写为 DATE_AND_TIME 文字（例如： DT#2012-01-11-15:11:09 ） ASCII 文件示例 治疗 REAL 和 LREAL 变量： 变量的值被写为 ST 文字。 REAL 和 LREAL 值的处理方式不同，因为执行与小数之间的转换不会损失准确性。然而，为了避免任何准确性损失并保持可读性和修改 ASCII 文件的可能性，这些值以十六进制格式存储。 （不精确的）十进制小数作为注释添加在十六进制值后面。读取文件时，支持十六进制格式以及ST十进制格式。这允许用户修改小数部分。 十六进制格式定义如下： F16#{Mantissa}H{Exp} | F16#NaN | F16#+Inf | F16#-Inf\n{Mantissa} ::= {HexNumeral}\n{Exp} ::= {HexNumeral}\n{HexNumeral} ::= [+-]?[1-9A-F][0-9A-F]* 如果 m 是尾数的值， e 指数的值与数字的值之比为 m * 16^e 。 存储 REAL 值的示例 lr1 LREAL:F16#F0H-3 0.05859375 " }, 
{ "title" : "二进制格式 ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_602fd614d22a5f95c0a8640e0110d837", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 存储格式 \/ 二进制格式 ", 
"snippet" : "BinaryDataStorage 以二进制格式保存数据。时间戳如下（类型 DATE_AND_TIME ）。之后列出变量。...", 
"body" : "BinaryDataStorage 以二进制格式保存数据。时间戳如下（类型 DATE_AND_TIME ）。之后列出变量。 " }, 
{ "title" : "数据存取 ", 
"url" : "ac_pm_data_access.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 数据存取 ", 
"snippet" : "Persistence Manager 提供最多 10 个 PersistenceChannel 类型的子模块实例。每个持久化通道提供一个类型的子模块实例 DataStorage 它负责数据访问。该实例实现了接口 IDataStorage ：...", 
"body" : "Persistence Manager 提供最多 10 个 PersistenceChannel 类型的子模块实例。每个持久化通道提供一个类型的子模块实例 DataStorage 它负责数据访问。该实例实现了接口 IDataStorage ： " }, 
{ "title" : "诊断 ", 
"url" : "ac_pm_diagnosis.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 诊断 ", 
"snippet" : "每个 持久通道 有一个允许数据访问的子模块（接口 IDataStorage ）。以下输出提供诊断信息： 输出 数据类型 描述 xActionOngoing BOOL TRUE 如果持久性管理器读取或写入数据 udiDataMemSize UDINT 持久数据的数据大小（以字节为单位） xReadingDone BOOL 持久数据读取完成 dtLastReading DT 最后一次阅读的日期和时间 uiNumberVarsNotOk UINT 未正确读取的变量数量 uiNumberVarsOk UINT 已正确读取的变量数 tTimeForReading TIME 阅读时长 dtLastSavi...", 
"body" : "每个 持久通道 有一个允许数据访问的子模块（接口 IDataStorage ）。以下输出提供诊断信息： 输出 数据类型 描述 xActionOngoing BOOL TRUE 如果持久性管理器读取或写入数据 udiDataMemSize UDINT 持久数据的数据大小（以字节为单位） xReadingDone BOOL 持久数据读取完成 dtLastReading DT 最后一次阅读的日期和时间 uiNumberVarsNotOk UINT 未正确读取的变量数量 uiNumberVarsOk UINT 已正确读取的变量数 tTimeForReading TIME 阅读时长 dtLastSaving DT 最后一次阅读的日期和时间 tTimeForWriting TIME 写作时长 uiWritingCycles UINT 申请开始前的存储数量 有关读取的变量数量和存储成功的信息也会显示在 PLC 记录器中。 PLC日志记录¶ " }, 
{ "title" : "错误处理 ", 
"url" : "ac_pm_error_handling.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 持久化管理器 \/ 错误处理 ", 
"snippet" : "错误号和相关字符串通过标准模块接口（ ClearErrors , FirstErrorNumber , GetFirstErrorMessage , LastErrorNumber , GetLastErrorMessage ）。 错误号 描述 100 持久数据列表已更改且与初始大小不匹配 110 无法创建内存（用于比较或一致副本）。 <ErrorCode SysMemAllocData> 。功能已关闭。 120 无法为比较存储创建数据存储。功能已关闭。 130 未为一致性复制创建数据存储 140 类型的持久变量 String 大小无效：<变量名称> 150 持久变量不属于受支持的类型：<变量...", 
"body" : "错误号和相关字符串通过标准模块接口（ ClearErrors , FirstErrorNumber , GetFirstErrorMessage , LastErrorNumber , GetLastErrorMessage ）。 错误号 描述 100 持久数据列表已更改且与初始大小不匹配 110 无法创建内存（用于比较或一致副本）。 <ErrorCode SysMemAllocData> 。功能已关闭。 120 无法为比较存储创建数据存储。功能已关闭。 130 未为一致性复制创建数据存储 140 类型的持久变量 String 大小无效：<变量名称> 150 持久变量不属于受支持的类型：<变量名称> 160 无法打开数据库。读取中止：<数据库对象的详细错误描述> 170 数据库无法关闭。读取中止：<数据库对象的详细错误描述> 190 无法创建数据库。保存中止。 <数据库对象详细错误描述> 200 无法打开数据库。保存中止。 <数据库对象详细错误描述> 210 数据库无法关闭。 <数据库对象详细错误描述> 220 写入条目时出错：<数据库对象的详细错误描述> 230 读取系统时间时出错 " }, 
{ "title" : "数据记录管理器 ", 
"url" : "ac_dlm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 数据记录管理器 ", 
"snippet" : "DataLog Manager 是Application Composer 的标准组件。它用于将变量值循环存储到文件中。这些变量用特殊标记 属性 在变量声明中。 要使该模块可用，您必须添加 AC_DataLog 图书馆交给图书馆管理员。 每个应用程序只能将一个数据日志管理器添加到模块树中。 DataLog Manager 是一个顶级模块，可以使用以下命令将其添加到模块树中： 添加顶级模块实例 命令。 在数据记录管理器下方，您最多可以插入 64 个通道。在通道中，您可以定义组并通过参数配置其存储行为。每个通道必须有一个子模块DataLog存储。 将 DataLog Manager 添加到模块树 ...", 
"body" : "DataLog Manager 是Application Composer 的标准组件。它用于将变量值循环存储到文件中。这些变量用特殊标记 属性 在变量声明中。 要使该模块可用，您必须添加 AC_DataLog 图书馆交给图书馆管理员。 每个应用程序只能将一个数据日志管理器添加到模块树中。 DataLog Manager 是一个顶级模块，可以使用以下命令将其添加到模块树中： 添加顶级模块实例 命令。 在数据记录管理器下方，您最多可以插入 64 个通道。在通道中，您可以定义组并通过参数配置其存储行为。每个通道必须有一个子模块DataLog存储。 将 DataLog Manager 添加到模块树 如果模块树或模块实例的参数已更改，则必须执行生成器运行。 （命令： 产生 ）。为此，数据日志生成器位于 发电机配置 必须激活。 " }, 
{ "title" : "模块：DataLog Manager ", 
"url" : "ac_dlm_datalogmanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 数据记录管理器 \/ 模块：DataLog Manager ", 
"snippet" : "DataLog Manager 这 数据记录管理器 管理变量的数据记录。它可以添加到模块树中最上面的对象下面。这是由 添加顶级实例 命令和选择 数据记录管理器 模块。每个应用程序只能添加一个 DataLog Manager。 对话框：人机界面 DataLog Manager 提供可视化模板（ VISU_DataLogManager ）可以将其添加到可视化中。有关更多信息，请参阅： 人机界面在在线模式下，该页面提供有关变量读写的统计信息。...", 
"body" : "DataLog Manager 这 数据记录管理器 管理变量的数据记录。它可以添加到模块树中最上面的对象下面。这是由 添加顶级实例 命令和选择 数据记录管理器 模块。每个应用程序只能添加一个 DataLog Manager。 对话框：人机界面 DataLog Manager 提供可视化模板（ VISU_DataLogManager ）可以将其添加到可视化中。有关更多信息，请参阅： 人机界面在在线模式下，该页面提供有关变量读写的统计信息。 " }, 
{ "title" : "对话框：数据记录 ", 
"url" : "ac_dlm_datalogmanager_module.html#UUID-5158e4eb-39c1-2002-c9f6-d4d4a1d20765_f45d0fbcc9eecefdc0a8646307e5e8bf_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 数据记录管理器 \/ 模块：DataLog Manager \/ 对话框：数据记录 ", 
"snippet" : "在此对话框中，可以从存储中排除一个或多个组。默认情况下 数据记录管理器 组已创建。 添加 添加和删除从存储中排除的组。 消除...", 
"body" : "在此对话框中，可以从存储中排除一个或多个组。默认情况下 数据记录管理器 组已创建。 添加 添加和删除从存储中排除的组。 消除 " }, 
{ "title" : "模块：数据记录通道 ", 
"url" : "ac_dlm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 数据记录管理器 \/ 模块：数据记录通道 ", 
"snippet" : "数据记录通道 这 数据记录通道 模块用于定义变量存储的组。该模块可以添加到下面 数据记录管理器 节点。这是由 添加子模块实例 命令和选择 数据记录通道 模块。最多可添加 64 个数据记录通道。 对话框：HMI、信息 有关这些对话框的详细信息，请参阅帮助页面 人机界面 ， 和 信息...", 
"body" : "数据记录通道 这 数据记录通道 模块用于定义变量存储的组。该模块可以添加到下面 数据记录管理器 节点。这是由 添加子模块实例 命令和选择 数据记录通道 模块。最多可添加 64 个数据记录通道。 对话框：HMI、信息 有关这些对话框的详细信息，请参阅帮助页面 人机界面 ， 和 信息 " }, 
{ "title" : "对话框：数据记录 ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 数据记录管理器 \/ 模块：数据记录通道 \/ 对话框：数据记录 ", 
"snippet" : "在此对话框中，可以定义由该通道管理的一个或多个组。默认情况下，通道模块实例的实例名称在列表中可用。 此频道记录的群组 新的 群组的定义 该条目通过使用添加到列表中 添加 命令。 使用散列实例路径 ：条目不存储完整的实例路径，而是存储字符串的哈希值，以节省内存空间。哈希和实例路径之间的分配保存在单独的文件中。 消除 从列表中删除选定的组 记录变量 分配给列表的变量列表 这些变量有 {attribute 'ac_datalog' := '<group name>'} 属性。 刷新 更新记录的变量列表 注意：只有激活数据日志生成器后才能更新该列表。 变量可以通过以下方式分配给组 交流数据记录 属性。...", 
"body" : "在此对话框中，可以定义由该通道管理的一个或多个组。默认情况下，通道模块实例的实例名称在列表中可用。 此频道记录的群组 新的 群组的定义 该条目通过使用添加到列表中 添加 命令。 使用散列实例路径 ：条目不存储完整的实例路径，而是存储字符串的哈希值，以节省内存空间。哈希和实例路径之间的分配保存在单独的文件中。 消除 从列表中删除选定的组 记录变量 分配给列表的变量列表 这些变量有 {attribute 'ac_datalog' := '<group name>'} 属性。 刷新 更新记录的变量列表 注意：只有激活数据日志生成器后才能更新该列表。 变量可以通过以下方式分配给组 交流数据记录 属性。这 ac_datalog_hysteresis 属性定义记录变量之前必须超过的滞后。 例子 VAR\n {attribute 'ac_datalog' := 'DataLogChannel'}\n {attribute 'ac_datalog_hysteresis' := '0.745'}\n rLogVar : REAL;\nEND_VAR " }, 
{ "title" : "对话框：参数 ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 数据记录管理器 \/ 模块：数据记录通道 \/ 对话框：参数 ", 
"snippet" : "在此对话框中，定义了保存数据日志变量的参数。 启用 FALSE ：不记录该通道存储的变量。 在第一个周期保存 TRUE ：该通道的所有变量将在第一个周期被记录。 循环保存 数据类型 TIME ：该通道的所有变量将循环存储。价值 T#0s 停用日志记录。...", 
"body" : "在此对话框中，定义了保存数据日志变量的参数。 启用 FALSE ：不记录该通道存储的变量。 在第一个周期保存 TRUE ：该通道的所有变量将在第一个周期被记录。 循环保存 数据类型 TIME ：该通道的所有变量将循环存储。价值 T#0s 停用日志记录。 " }, 
{ "title" : "模块：DataLog Storage CSV ", 
"url" : "ac_dlm_storage_csv_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 数据记录管理器 \/ 模块：DataLog Storage CSV ", 
"snippet" : "DataLog Storage CSV 子模块 数据日志存储_csv 定义 a 的存储格式 DataLog 频道 作为 CSV 文件。可以将其添加到 DataLog 通道节点下方 这是由命令完成的 添加子模块实例 以及模块的选择 DataLogStorage_CSV 。 对话框：信息 有关这些对话框的详细信息，请参阅中的帮助页面 信息 。...", 
"body" : "DataLog Storage CSV 子模块 数据日志存储_csv 定义 a 的存储格式 DataLog 频道 作为 CSV 文件。可以将其添加到 DataLog 通道节点下方 这是由命令完成的 添加子模块实例 以及模块的选择 DataLogStorage_CSV 。 对话框：信息 有关这些对话框的详细信息，请参阅中的帮助页面 信息 。 " }, 
{ "title" : "对话框：参数 ", 
"url" : "ac_dlm_storage_csv_module.html#UUID-77b82c47-16c6-5f2f-5d4f-34b67bccf3d3_d1edd6c9f1f1a7c0a864637755e4ae_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 数据记录管理器 \/ 模块：DataLog Storage CSV \/ 对话框：参数 ", 
"snippet" : "存储名称 存储文件的名称 默认情况下，占位符 %CHANNEL_NAME% 已定义。此占位符将被上级 DataLog 频道的实例名称所取代。存储文件名必须是唯一的，因为所有存储文件都存储在同一个目录中。默认情况下。 （可选）占位符 %DATE% 可以添加为存储日期。分辨率在参数中定义 用于替换 %DATE% 的格式字符串 （见下文）。 示例： 使用名称规范 '%CHANNEL_NAME%_AT_%DATE%' ，以下文件名结果为 DataLogChannel_1 频道: Application_DataLogChannel_1_AT_20191211_02-10-30.csv 分隔符 : AS...", 
"body" : "存储名称 存储文件的名称 默认情况下，占位符 %CHANNEL_NAME% 已定义。此占位符将被上级 DataLog 频道的实例名称所取代。存储文件名必须是唯一的，因为所有存储文件都存储在同一个目录中。默认情况下。 （可选）占位符 %DATE% 可以添加为存储日期。分辨率在参数中定义 用于替换 %DATE% 的格式字符串 （见下文）。 示例： 使用名称规范 '%CHANNEL_NAME%_AT_%DATE%' ，以下文件名结果为 DataLogChannel_1 频道: Application_DataLogChannel_1_AT_20191211_02-10-30.csv 分隔符 : ASCII 值，用于变量名和值之间的分隔符。 示例： ',' 缓冲区大小 : 用于临时存储条目的内部缓冲区的大小。 示例： 2000 缓冲区填充量 以百分比表示的值。 如果缓冲区填充到该值，则缓冲区的内容将写入 CSV 文件。正在指定 0 停用缓冲。 文件中的条目采用以下格式（使用 | 作为分隔符）： <TimeStamp>|<InstancePath\/Hash>|<Value>[|<TypeClass>] 如果使用哈希路径执行存储，则数据类型不会与每个条目一起存储，而只在存储赋值哈希 ↔ 实例路径的单独文件中存储一次。 此文件中的条目格式为： <InstancePath>|<TypeClass>|<Hash> 如果进行在线更改，则不会删除文件。新条目已添加。在哈希文件中，在线更改标有时间戳。因此，仍然可以在在线更改之前为条目分配 hash ↔ 实例路径。 在下载后的初始化期间（无在线更改），数据和哈希文件将被删除。 封闭字符 添加封闭字符 TRUE : 字符串条目将与周围环境一起存储。 示例：变量值： File1 ，文件输入： -File1- 。 FALSE ：存储字符串条目时不包含字符。 封闭字符 用于封闭的字符。 示例： '-' 用于替换 %DATE% 的格式字符串 用于替换的日期格式 %DATE% 可以在参数中指定 存储名称 （见上文）。 示例： 'yyyyMMdd' ， 'yyyyMMdd_hh-mm-ss' LineEnding 表示文件中行尾的字符 " }, 
{ "title" : "模块：DataLog Storage SQLite ", 
"url" : "ac_dlm_storage_sqlite_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 数据记录管理器 \/ 模块：DataLog Storage SQLite ", 
"snippet" : "DataLog Storage SQLite 子模块 数据日志存储_SQLite 定义了a的存储格式 数据记录通道 对于 SQLite 数据库。它可以添加到 DataLog 通道节点下方。这是由 添加子模块实例 命令和选择 数据日志存储_SQLite 模块。 对话框：信息 有关此对话框的详细信息，请参阅： 信息 。...", 
"body" : "DataLog Storage SQLite 子模块 数据日志存储_SQLite 定义了a的存储格式 数据记录通道 对于 SQLite 数据库。它可以添加到 DataLog 通道节点下方。这是由 添加子模块实例 命令和选择 数据日志存储_SQLite 模块。 对话框：信息 有关此对话框的详细信息，请参阅： 信息 。 " }, 
{ "title" : "对话框：参数 ", 
"url" : "ac_dlm_storage_sqlite_module.html#UUID-63e71af3-388f-498c-6553-5ab20ff603a1_accbd5f8d8b6d029c0a86463569e125f_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 数据记录管理器 \/ 模块：DataLog Storage SQLite \/ 对话框：参数 ", 
"snippet" : "存储名称 : 归档文件的名称 默认情况下占位符 %CHANNEL_NAME% 被定义为。该占位符将替换为上级 DataLog 通道的实例名称。存档名称必须是唯一的，因为所有存档文件默认存储在控制器的安装目录中。 应用程序的该模块的所有实例共享该文件。该文件最初由存储模块之一创建。文件名始终是 <ApplicationName>_DataLog.sqlite 最大条目数 : 该模块实例的数据库的最大条目数。 价值 0 停用该功能。如果超过最大数量，该表的行为就像一个环形缓冲区，并且第一个条目将被覆盖。...", 
"body" : "存储名称 : 归档文件的名称 默认情况下占位符 %CHANNEL_NAME% 被定义为。该占位符将替换为上级 DataLog 通道的实例名称。存档名称必须是唯一的，因为所有存档文件默认存储在控制器的安装目录中。 应用程序的该模块的所有实例共享该文件。该文件最初由存储模块之一创建。文件名始终是 <ApplicationName>_DataLog.sqlite 最大条目数 : 该模块实例的数据库的最大条目数。 价值 0 停用该功能。如果超过最大数量，该表的行为就像一个环形缓冲区，并且第一个条目将被覆盖。 " }, 
{ "title" : "记录变量的定义 ", 
"url" : "ac_dlm_definition_logging_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 数据记录管理器 \/ 记录变量的定义 ", 
"snippet" : "变量被标记为 数据记录 通过属性。 ac_datalog [:= group name] ：该属性将变量分配给日志组。如果变量是结构化变量，则将记录所有可以记录且未排除的成员。如果未设置组名称，则必须单独标记结构化变量的每个实例。 ac_datalog_set_default_group ：设置未显式分配给组的结构化类型实例的所有成员的组。 ac_datalog_exclude ：此属性从数据记录中排除结构化数据类型的变量。 ac_datalog_union_representant ：该属性定义 UNION 内的代表，用于数据记录。 ac_datalog_hysteresis := ‘val...", 
"body" : "变量被标记为 数据记录 通过属性。 ac_datalog [:= group name] ：该属性将变量分配给日志组。如果变量是结构化变量，则将记录所有可以记录且未排除的成员。如果未设置组名称，则必须单独标记结构化变量的每个实例。 ac_datalog_set_default_group ：设置未显式分配给组的结构化类型实例的所有成员的组。 ac_datalog_exclude ：此属性从数据记录中排除结构化数据类型的变量。 ac_datalog_union_representant ：该属性定义 UNION 内的代表，用于数据记录。 ac_datalog_hysteresis := ‘value‘ ：该属性设置滞后。必须超过该值才能记录变量。此属性仅适用于数字数据类型。如果用于非数字数据类型，则会显示警告并且该值将被忽略。 您可以在帮助页面上找到附加说明和示例 持久化管理器 属性。 " }, 
{ "title" : "设备诊断生成器 ", 
"url" : "ac_device_diagnose_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 设备诊断生成器 ", 
"snippet" : "设备诊断模块是Application Composer的标准组件，包含在库中 AC_DeviceDiagnosis 。该模块是顶级模块，可以通过命令添加到模块树中 添加顶级模块实例 。 模块树中的设备诊断模块 借助设备诊断模块，基于现有设备配置创建可视化页面，以树形结构描述 PLC 和连接的现场总线设备。在这个树形结构中，显示了每个组件的状态。如有必要，可以调用详细信息或更改单个组件的操作模式。 生成设备诊断的可视化页面 在线模式下的设备诊断 在在线模式下，显示设备名称、状态和错误代码。 设备的状态以颜色方案显示： 绿色：设备状态为“正在运行” 红色：设备状态不为“正在运行” 用于更改状态的对...", 
"body" : "设备诊断模块是Application Composer的标准组件，包含在库中 AC_DeviceDiagnosis 。该模块是顶级模块，可以通过命令添加到模块树中 添加顶级模块实例 。 模块树中的设备诊断模块 借助设备诊断模块，基于现有设备配置创建可视化页面，以树形结构描述 PLC 和连接的现场总线设备。在这个树形结构中，显示了每个组件的状态。如有必要，可以调用详细信息或更改单个组件的操作模式。 生成设备诊断的可视化页面 在线模式下的设备诊断 在在线模式下，显示设备名称、状态和错误代码。 设备的状态以颜色方案显示： 绿色：设备状态为“正在运行” 红色：设备状态不为“正在运行” 用于更改状态的对话框 单击设备会打开一个窗口，可以在其中停止设备，（ 停止 ）， 重置 （ 重置 ）或开始（ 开始） 。第一次打开对话框时，会显示所有功能。硬件不支持的功能将在首次激活时淡出。 " }, 
{ "title" : "要求 ", 
"url" : "ac_device_diagnose_overview.html#UUID-fd01086a-c692-d615-c1cf-d5963632aa4b_ac778b834d585cc0a8640e01a520c3_id_be299b7583c984f0c0a86520016ce88a", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 设备诊断生成器 \/ 要求 ", 
"snippet" : "显示的诊断详细信息来自设备创建的 CAA-Device-Diagnose-FB (device-FB)。要生成这些组件，选项 激活设备诊断 必须在 PLC 设置中进行设置。这些 FB 不仅提供（上述）概览中显示的正常状态信息，还提供附加显示屏中显示的详细信息。如果选项 激活设备诊断 如果在生成之前未设置，则生成过程将中止并自动设置该选项，以便下一次生成运行创建所需的可视化效果。 要生成此可视化页面，必须在 发电机配置 。...", 
"body" : "显示的诊断详细信息来自设备创建的 CAA-Device-Diagnose-FB (device-FB)。要生成这些组件，选项 激活设备诊断 必须在 PLC 设置中进行设置。这些 FB 不仅提供（上述）概览中显示的正常状态信息，还提供附加显示屏中显示的详细信息。如果选项 激活设备诊断 如果在生成之前未设置，则生成过程将中止并自动设置该选项，以便下一次生成运行创建所需的可视化效果。 要生成此可视化页面，必须在 发电机配置 。 " }, 
{ "title" : "命令 ", 
"url" : "core_applicationcomposer_composer_home.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 ", 
"snippet" : "命令类别中的命令 作曲家 都提供了 CODESYS Application Composer 。 这些命令主要用于将composer对象添加到 模块树 或修改它们。此外，还有将变量映射到 IO 配置并构建一个函数 CODESYS 应用。命令的可用性取决于模块树中所选的对象：仅选择当前所选位置允许的命令。...", 
"body" : "命令类别中的命令 作曲家 都提供了 CODESYS Application Composer 。 这些命令主要用于将composer对象添加到 模块树 或修改它们。此外，还有将变量映射到 IO 配置并构建一个函数 CODESYS 应用。命令的可用性取决于模块树中所选的对象：仅选择当前所选位置允许的命令。 " }, 
{ "title" : "应用程序编辑器专用视图 ", 
"url" : "ac_dedicated_view.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 应用程序编辑器专用视图 ", 
"snippet" : "应用程序编辑器提供了一种尽可能简单的方法来创建整个应用程序并运行它们。致力于这种简单性方面， CODESYS 提供用户界面的缩小视图。 可以通过选择配置文件“CODESYS Composer Dedicated”或通过 CODESYS 开始菜单条目。之后缩小视图 CODESYS ，它只提供对使用创建工作应用程序所需的绝对必要的窗口和命令的访问 CODESYS Application Composer 显示了应用程序编辑器。 应用程序编辑器专用视图 只有模块树、设备树和消息窗口以及用于在线登录\/注销\/运行\/停止和 Composer 操作的命令。在后者中，有两个命令与“Application Co...", 
"body" : "应用程序编辑器提供了一种尽可能简单的方法来创建整个应用程序并运行它们。致力于这种简单性方面， CODESYS 提供用户界面的缩小视图。 可以通过选择配置文件“CODESYS Composer Dedicated”或通过 CODESYS 开始菜单条目。之后缩小视图 CODESYS ，它只提供对使用创建工作应用程序所需的绝对必要的窗口和命令的访问 CODESYS Application Composer 显示了应用程序编辑器。 应用程序编辑器专用视图 只有模块树、设备树和消息窗口以及用于在线登录\/注销\/运行\/停止和 Composer 操作的命令。在后者中，有两个命令与“Application Composer 专用”视图密切相关： 生成、编译并登录 ：用于生成代码、编译代码并最终登录设备并启动设备上的应用程序。 将模块库添加到项目中 ：用于将库添加到 POU 池的库管理器中，通常在“Application Composer 专用”视图中不可用。 任何添加的包含模块的库都可以将模块添加到模块树中。 " }, 
{ "title" : "模块树 ", 
"url" : "ac_module_tree.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 模块树 ", 
"snippet" : "除了设备树和 POU 树之外，Application Composer 还提供模块树。该树用于通过使用预定义模块来创建或修改应用程序。应用程序编辑器命令允许将子模块添加到模块树或修改或删除它们。树结构可以折叠或展开。 模块树示例 根据所选对象，可以将兼容模块添加到树中。这可以通过使用来完成 命令 在“Composer”菜单中或使用上下文菜单。 元素的图标在模块声明中定义。...", 
"body" : "除了设备树和 POU 树之外，Application Composer 还提供模块树。该树用于通过使用预定义模块来创建或修改应用程序。应用程序编辑器命令允许将子模块添加到模块树或修改或删除它们。树结构可以折叠或展开。 模块树示例 根据所选对象，可以将兼容模块添加到树中。这可以通过使用来完成 命令 在“Composer”菜单中或使用上下文菜单。 元素的图标在模块声明中定义。 " }, 
{ "title" : "模块树的元素 ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_a88610fbb413e565c0a8640e00f61f5a", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 模块树 \/ 模块树的元素 ", 
"snippet" : "(1)：定义应用程序和任务设置的顶级模块 (2): 子模块 (3)：引用子模块的实例引用。实例引用没有自己的参数或 I\/O。 (4)：无需应用程序编辑器即可创建的扩展，并且允许对机器进行调整 (5): 时隙（单时隙或多时隙），可以是强制的，也可以是可选的...", 
"body" : "(1)：定义应用程序和任务设置的顶级模块 (2): 子模块 (3)：引用子模块的实例引用。实例引用没有自己的参数或 I\/O。 (4)：无需应用程序编辑器即可创建的扩展，并且允许对机器进行调整 (5): 时隙（单时隙或多时隙），可以是强制的，也可以是可选的 " }, 
{ "title" : "树结构的显示 ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_8a0710cab44f1a9bc0a8640e00ddf9a1", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 模块树 \/ 树结构的显示 ", 
"snippet" : "显示在扩展模块实例下的子节点将根据以下规则显示，其中所有占用和未占用插槽的顺序始终与模块声明的声明顺序相对应： 如果仅引用此位置的模块实例，则它没有任何子级。 显示所有未占用的插槽，但显式隐藏的可选插槽除外。对于插槽，会显示角色名称和类型。 不显示基数为 1 的已占用插槽（而是显示连接的子模块实例）。连接的子模块实例在视觉上取代了插槽。 可选和强制子模块显示在模块树中插槽位置处。角色名称显示在模块实例名称后面的括号中。 多插槽的子模块实例显示在相应插槽的下方。显示角色名称，因为它是在父节点中定义的。 插槽的以下属性用附加图标表示： 可选插槽 强制性插槽 多槽位 对子模块实例的引用 如果删除模块...", 
"body" : "显示在扩展模块实例下的子节点将根据以下规则显示，其中所有占用和未占用插槽的顺序始终与模块声明的声明顺序相对应： 如果仅引用此位置的模块实例，则它没有任何子级。 显示所有未占用的插槽，但显式隐藏的可选插槽除外。对于插槽，会显示角色名称和类型。 不显示基数为 1 的已占用插槽（而是显示连接的子模块实例）。连接的子模块实例在视觉上取代了插槽。 可选和强制子模块显示在模块树中插槽位置处。角色名称显示在模块实例名称后面的括号中。 多插槽的子模块实例显示在相应插槽的下方。显示角色名称，因为它是在父节点中定义的。 插槽的以下属性用附加图标表示： 可选插槽 强制性插槽 多槽位 对子模块实例的引用 如果删除模块实例，则对此模块实例的所有引用都将标有错误图标。 如果模块实例的类型发生更改，则所有对该模块的类型错误的引用都将标有错误图标。 根据模块树中的位置 切 \/ 复制 \/ 粘贴 可以使用上下文菜单中的命令。模块树的元素可以通过拖放来移动。按 控制键 拖放操作期间的 键将复制该元素。 模块树的元素也可以导出和导入 CODESYS 。 " }, 
{ "title" : "模块对话框 ", 
"url" : "ac_module_dialog.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 模块对话框 ", 
"snippet" : "通过使用命令 添加顶级实例 , 添加子模块实例 , 参考实例 ， 和 更新模块 ，将打开一个非模式对话框。 根据模块树中的位置，将显示所有兼容模块。双击模块或使用按钮 添加模块 分别。 添加子模块实例 所选模块将被复制到模块树中。 按钮 添加模块 （ 或者 参考模块 ）仅在选择兼容模块且模块树中所选插槽未满时启用。此外，必须输入有效名称（带有有效的 IEC 标识符）。 只能为新模块实例定义对象名称。在对话框中 更新模块 命令，名称不能更改。 仅显示兼容实例 ：此选项激活后会过滤显示的实例，以便仅显示兼容的实例。如果禁用，则会显示所有实例，其中兼容的实例以粗体突出显示。 应用 ：在该应用程序下生...", 
"body" : "通过使用命令 添加顶级实例 , 添加子模块实例 , 参考实例 ， 和 更新模块 ，将打开一个非模式对话框。 根据模块树中的位置，将显示所有兼容模块。双击模块或使用按钮 添加模块 分别。 添加子模块实例 所选模块将被复制到模块树中。 按钮 添加模块 （ 或者 参考模块 ）仅在选择兼容模块且模块树中所选插槽未满时启用。此外，必须输入有效名称（带有有效的 IEC 标识符）。 只能为新模块实例定义对象名称。在对话框中 更新模块 命令，名称不能更改。 仅显示兼容实例 ：此选项激活后会过滤显示的实例，以便仅显示兼容的实例。如果禁用，则会显示所有实例，其中兼容的实例以粗体突出显示。 应用 ：在该应用程序下生成顶层模块实例。点击 选择现有的应用程序。 添加模块实例的对话框 该对话框是非模式的。它允许选择树中的其他对象，而无需关闭对话框。对话框中列出的元素以及可能的操作会自动调整。该对话框的行为与 添加设备 对话。 " }, 
{ "title" : "命令：生成 ", 
"url" : "ac_generate.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成 ", 
"snippet" : "产生 象征： 此命令（类别“Composer”）启动构建过程，自动生成 CODESYS 模块树中的应用程序和设置 发电机配置 。 消息和错误将显示在消息视图中。 标准生成器创建的所有对象（任务对象和应用程序除外）将存储在应用程序的子文件夹中。 POU池命名 AC_Std 和 AC_FBs 。如果已存在同名文件夹，将通过添加后缀创建唯一名称 _0 。 生成的功能块 所有创建的对象 产生 命令标有蓝色覆盖图标。如果用户尝试删除、移动或修改这些对象之一，将打开一个对话框，告知此操作可能会导致编译问题。如果用户继续，覆盖图标的颜色将变为红色（请参阅功能块 AC_PRG_RMP (PRG) 在上面的屏幕...", 
"body" : "产生 象征： 此命令（类别“Composer”）启动构建过程，自动生成 CODESYS 模块树中的应用程序和设置 发电机配置 。 消息和错误将显示在消息视图中。 标准生成器创建的所有对象（任务对象和应用程序除外）将存储在应用程序的子文件夹中。 POU池命名 AC_Std 和 AC_FBs 。如果已存在同名文件夹，将通过添加后缀创建唯一名称 _0 。 生成的功能块 所有创建的对象 产生 命令标有蓝色覆盖图标。如果用户尝试删除、移动或修改这些对象之一，将打开一个对话框，告知此操作可能会导致编译问题。如果用户继续，覆盖图标的颜色将变为红色（请参阅功能块 AC_PRG_RMP (PRG) 在上面的屏幕截图中）。 如果您将 Application Composer 与 CODESYS SVN ： 所有 Composer 生成的对象都标有 Ignore on Commit 对于SVN。此外，SVN 会切换到离线模式，以避免执行内置命令时 SVN 锁定。 创建通信基础设施 定义：在以下描述中，如果满足以下条件，则应用程序 A1 向应用程序 A2 发送（或 A2 从 A1 接收）： 分配给应用程序 A1 的模块实例引用分配给应用程序 A2 的模块实例，反之亦然。 通过使用直接模块 I\/O 连接，将分配给 A1 的模块实例的输出连接到分配给 A2 的模块实例。 下面提到的所有对象都将在该文件夹中创建 AC_RMP 对于生成器创建的每个应用程序。 将创建一个通信任务。 （循环时间和优先级根据发电机配置的设置而定）。在此任务中，将调用代理实例，并分别读取镜像模块代理 FB 变量。书面。 对于发送到当前应用程序的每个应用程序，将创建（发送）GVL 并定义网络设置。 （协议“UDP”、循环传输、校验和、根据设置的循环时间、通信任务）。 “列表标识符”必须是1到2^15-1之间的整数值，将在生成开始时随机确定，并在每次发送GVL后加1。该值至少为 128 并且在有效范围内。如果应用程序之间存在模块引用，则类型变量 RMPExchangeData 将在 GVL 中创建。变量的名称包含源应用程序和目标应用程序的名称。如果模块实例在其代理定义中定义了要镜像的变量（ MirrorVar ）并且从其他模块实例引用，对于每个 MirrorVars，将在引用的模块实例的（发送）GVL 中创建一个变量。它的名称包含模块实例的实例路径和相应“MirrorVar”定义的TargetID。 对于当前应用程序发送到的每个应用程序A2，将创建一个（接收）NVL，并将其连接到A2的相应发送GVL和通信任务。 类型的功能块 RMPService 将被实例化在 GVL AC_RMP 并在声明中初始化（使用属性 init_on_onlchange ）。两个类型的数组 RMPConnection 将创建引用类型的创建变量 RMPExchangeData 在 GVL 和 NVL 中。 一个程序 AC_PRG_RMP 将创建调用类型的功能块 RMPService 。该程序将被添加到通信任务中。此外，镜像变量（“MirrorVars”）的值将在 AC_PRG_RMP 程序。这意味着代理“MirrorVars”将被分配给（接收）GVL 的相应变量。然后 Main 调用代理实例的方法，最后调用“MirrorVars”模块的（发送者）GVL 的相应变量。这是根据模块实例到代理的发送方向发生的。 " }, 
{ "title" : "通过标准生成器创建功能块实例 ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_65e9c9d2b9a5b65fc0a8640e0003897d", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成 \/ 通过标准生成器创建功能块实例 ", 
"snippet" : "对于每个模块实例，将创建一个功能块（在文件夹中 AC_FBs ）。该功能块源自模块功能块。 功能块包含输入变量 子模块实例 可配置大小的数组 直接 I\/O 连接的缓冲区变量 多槽数组和实例引用 各个数组变量的名称由前缀创建 AC_ARRAY_ 后跟相应指针变量的变量名。对于具有可变索引大小的数组 (VarArrays)，名称可以被参数覆盖 VarArray.InstName 。 功能块的实现部分包含命令 SUPER^(); 它调用模块功能块的实现部分。 例子 模块实例 ModuleInstanceA 属于类型 ModuleA 及相关功能块 ModuleA_FB 。该实例有一个类型的子模块实例 ...", 
"body" : "对于每个模块实例，将创建一个功能块（在文件夹中 AC_FBs ）。该功能块源自模块功能块。 功能块包含输入变量 子模块实例 可配置大小的数组 直接 I\/O 连接的缓冲区变量 多槽数组和实例引用 各个数组变量的名称由前缀创建 AC_ARRAY_ 后跟相应指针变量的变量名。对于具有可变索引大小的数组 (VarArrays)，名称可以被参数覆盖 VarArray.InstName 。 功能块的实现部分包含命令 SUPER^(); 它调用模块功能块的实现部分。 例子 模块实例 ModuleInstanceA 属于类型 ModuleA 及相关功能块 ModuleA_FB 。该实例有一个类型的子模块实例 ModuleB 。 模块实例 ModuleInstanceA 属于类型 ModuleA 及相关功能块 ModuleA_FB 。该实例有一个类型的子模块实例 ModuleB 。 FUNCTION_BLOCK AC_ModuleInstanceA EXTENDS ModuleA_FB\n\nVAR_INPUT\n Inst_Sub1 : AC_ModuleInstanceB ;\nEND_VAR 功能块的名称是根据模块实例路径和前缀创建的 AC_ 。 子模块实例的变量名称是根据前缀创建的，后跟相应子模块实例的名称。 每个功能块被实例化一次，顶层模块的FB实例直接在GVL中——其余的在父实例的相应功能块中。 对于位于另一应用程序中的每个引用的模块实例，将在引用模块实例的一个 GVL 中创建恰好一个代理 FB 的功能块实例。代理实例的名称是 AC_PROXY_<InstanceName> 其中 <InstanceName> 是其他应用程序中目标实例的名称。 唯一的地址被分配给所有模块实例。代理 FB 实例由远程应用程序中模块实例的地址分配。 方法 IBaseInstance.Main 代理实例的调用在通信任务中循环调用。 " }, 
{ "title" : "创建应用程序和任务调用 ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_c88cdc4bba310f0dc0a8640e0094f683", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成 \/ 创建应用程序和任务调用 ", 
"snippet" : "如果将模块分配给不存在的应用程序，则将创建该应用程序。 创建不存在的标准任务 TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW 任务的优先级和循环时间根据生成器设置进行设置。此外，将创建具有给定设置的模块特定任务。 每个顶层创建一个全局变量列表。在此 GVL 中，将创建位于同一应用程序的顶级模块实例下的模块实例。全局变量列表有模块中定义的名称，如果没有定义的名称，则获取名称 GVL_MODULE 。 GVL 位于所选应用程序下方或全局 POU 树中。 创建一个名为 GVL GVL_ MODULE_TREE 对于每个应用程序。该列表包含用于管...", 
"body" : "如果将模块分配给不存在的应用程序，则将创建该应用程序。 创建不存在的标准任务 TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW 任务的优先级和循环时间根据生成器设置进行设置。此外，将创建具有给定设置的模块特定任务。 每个顶层创建一个全局变量列表。在此 GVL 中，将创建位于同一应用程序的顶级模块实例下的模块实例。全局变量列表有模块中定义的名称，如果没有定义的名称，则获取名称 GVL_MODULE 。 GVL 位于所选应用程序下方或全局 POU 树中。 创建一个名为 GVL GVL_ MODULE_TREE 对于每个应用程序。该列表包含用于管理模块树的变量。 GVL 将在文件夹中创建 AC_Std 。 创建在下载和在线更改时自动调用的初始化代码： 将创建树结构。 将设置参数值。 将分配引用和子模块实例。 将填充可变大小的数组。 将设置实例参考。 下载时仅设置参数，而不设置为其默认值。在线更改时，将设置所有参数。 POU 将在文件夹中创建 AC_Std 。 对于每个定义的入口点 PROGRAM 将创建 POU（ST 语言），其中包含顶层模块的调用。这个新 POU 的调用将添加到任务下方。对于标准任务，POU 名称为： MODULE_CALL_<TASKNAME>_START MODULE_CALL_<TASKNAME>_END POU 将在文件夹中创建 AC_Std 。 对于顶层模块 POU 将在所有应用程序中创建任务调用池。 " }, 
{ "title" : "创建 I\/O 分配 ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_bf24656dba310f0fc0a8640e01fdf5a6", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成 \/ 创建 I\/O 分配 ", 
"snippet" : "根据 I\/O 分配的类型，将执行以下操作： 【I\/O通道】：在对应的设备通道中会添加模块实例的I\/O的实例名称。 [ST 表达式]：将表达式分配给输入或将输出分配给表达式将针对同一顶级实例下面的所有模块实例。如果有相应的分配，则对于每个顶级实例，都有一个名为 AC_Io_SetInputs_<instance name> 或者 AC_Io_SetOutputs_<instance name> 将被创建。 定义输入和输出的任务将由标志标识 UPDATE-IOS 在模块描述中。在下面的描述中该任务将被称为“I\/O任务”。 在调用模块实例的任务方法之前，将在 I\/O 任务中调用输入函数。 （如果 I...", 
"body" : "根据 I\/O 分配的类型，将执行以下操作： 【I\/O通道】：在对应的设备通道中会添加模块实例的I\/O的实例名称。 [ST 表达式]：将表达式分配给输入或将输出分配给表达式将针对同一顶级实例下面的所有模块实例。如果有相应的分配，则对于每个顶级实例，都有一个名为 AC_Io_SetInputs_<instance name> 或者 AC_Io_SetOutputs_<instance name> 将被创建。 定义输入和输出的任务将由标志标识 UPDATE-IOS 在模块描述中。在下面的描述中该任务将被称为“I\/O任务”。 在调用模块实例的任务方法之前，将在 I\/O 任务中调用输入函数。 （如果 I\/O 任务是标准任务，则在 start 方法之前。）输出函数将在模块实例的任务方法之后的 I\/O 任务中调用。 （如果I\/O任务是标准任务，则在end方法之后。） [直接连接到模块I\/O，本地]：将在输入实例的功能块中创建兼容类型的缓冲区变量。缓冲区变量的名称以前缀开头 AC_Io_Buffer_ 。 在应用程序初始化期间，缓冲区变量将被初始化为所连接输出的当前值。生成器处理输入和输出分配，就像对此缓冲区变量的 ST 分配一样（请参阅 [ST 表达式]。 [直接连接到模块 I\/O，远程]：对于连接到另一个应用程序的模块实例的输入的每个输出，将在相应的发送网络 GVL 中创建具有兼容类型的缓冲区变量。缓冲区变量的名称以前缀开头 AC_RemoteIo_Buffer_ 并将根据实例路径和输出的变量路径构建。缓冲区变量将使用输出变量中的初始化表达式（如果存在）进行初始化。如果预编译信息中不包含此初始化表达式的值（因为该表达式使用示例：变量、函数和常量），则会产生错误。 生成器处理输出分配就像对此缓冲区变量的分配一样。其他应用程序中的输入赋值的处理方式与接收器 NVL 中相应变量的赋值类似（请参阅 [ST 表达式]）。 注：尚未实现需要更新网络变量的任务与模块I\/O 任务之间的同步。因此，当 I\/O 任务读取值时，值的写入可能不完整。 " }, 
{ "title" : "命令：生成器配置 ", 
"url" : "ac_generator_configuration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成器配置 ", 
"snippet" : "发电机配置 此命令（类别“Composer”）将打开一个包含所有可用生成器的对话框。 在此对话框中，可以启用或禁用每个生成器。单击“工具”图标将打开一个详细对话框，其中包含当前选定和启用的生成器的特定设置。...", 
"body" : "发电机配置 此命令（类别“Composer”）将打开一个包含所有可用生成器的对话框。 在此对话框中，可以启用或禁用每个生成器。单击“工具”图标将打开一个详细对话框，其中包含当前选定和启用的生成器的特定设置。 " }, 
{ "title" : "设备生成器 ", 
"url" : "ac_generator_configuration.html#UUID-808f4cf5-ae70-df89-d868-14922e672101", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成器配置 \/ 设备生成器 ", 
"snippet" : "该生成器尝试生成必要的设备并将它们连接到模块 IO（如果可能）。 在当前版本的 Application Composer 插件中，设备生成器没有可用的配置对话框。...", 
"body" : "该生成器尝试生成必要的设备并将它们连接到模块 IO（如果可能）。 在当前版本的 Application Composer 插件中，设备生成器没有可用的配置对话框。 " }, 
{ "title" : "源模板生成器 ", 
"url" : "ac_generator_configuration.html#UUID-dcd74dd8-c2bf-daf3-03d2-c4b54ecf55a8", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成器配置 \/ 源模板生成器 ", 
"snippet" : "该生成器复制现有的功能块 POU 池到应用程序。复制的功能块添加到 AC_SourceTemplate 文件夹。在此文件夹中附加功能 AC_SourceTemplateInit 还添加了。该功能块用于初始化复制的功能块。创建的功能块可以编辑，并且不会被新的生成器运行覆盖。未使用的功能块被重命名并移动到 UnusedSourceTemplate 子文件夹。然后是扩展 _unused 被添加。要求： 必须激活标准生成器。...", 
"body" : "该生成器复制现有的功能块 POU 池到应用程序。复制的功能块添加到 AC_SourceTemplate 文件夹。在此文件夹中附加功能 AC_SourceTemplateInit 还添加了。该功能块用于初始化复制的功能块。创建的功能块可以编辑，并且不会被新的生成器运行覆盖。未使用的功能块被重命名并移动到 UnusedSourceTemplate 子文件夹。然后是扩展 _unused 被添加。要求： 必须激活标准生成器。 " }, 
{ "title" : "标准发电机 ", 
"url" : "ac_generator_configuration.html#UUID-a3c9c7e9-e567-6ffc-3f6c-ae4016d57a70", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成器配置 \/ 标准发电机 ", 
"snippet" : "默认任务设置 高优先级任务 用户定义任务的优先级和间隔的定义 用户定义的任务可以在顶级模块的编辑器中设置（请参阅部署）。 中等优先级任务 低优先级任务 通讯设置 启用 RMP 通信 ：将创建 RMP 通信所需的元素。 任务优先级 RMP 任务的优先级 任务间隔 RMP 任务的任务间隔 编译器编译指示 GVL 编译器编译指示的定义 这些编译指示将插入到生成的 GVL 或功能块之前。 功能块 符号配置 创建符号配置 ：符号配置对象将添加到应用程序中。...", 
"body" : "默认任务设置 高优先级任务 用户定义任务的优先级和间隔的定义 用户定义的任务可以在顶级模块的编辑器中设置（请参阅部署）。 中等优先级任务 低优先级任务 通讯设置 启用 RMP 通信 ：将创建 RMP 通信所需的元素。 任务优先级 RMP 任务的优先级 任务间隔 RMP 任务的任务间隔 编译器编译指示 GVL 编译器编译指示的定义 这些编译指示将插入到生成的 GVL 或功能块之前。 功能块 符号配置 创建符号配置 ：符号配置对象将添加到应用程序中。 " }, 
{ "title" : "持久性生成器 ", 
"url" : "ac_generator_configuration.html#UUID-e4484f57-2155-dad9-990f-264462e75e1e", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成器配置 \/ 持久性生成器 ", 
"snippet" : "持久化生成器从模块树中读取持久化配置，并在每个使用持久化的应用程序下创建一个持久化配置对象。 有关更多信息，另请参阅： 持久化管理器如果持久性管理器实例映射到该应用程序，则该应用程序将使用应用程序编写器持久性功能。...", 
"body" : "持久化生成器从模块树中读取持久化配置，并在每个使用持久化的应用程序下创建一个持久化配置对象。 有关更多信息，另请参阅： 持久化管理器如果持久性管理器实例映射到该应用程序，则该应用程序将使用应用程序编写器持久性功能。 " }, 
{ "title" : "数据记录生成器 ", 
"url" : "ac_generator_configuration.html#UUID-0a4d1c9e-c363-489e-e742-4b6d5c1afaa4", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成器配置 \/ 数据记录生成器 ", 
"snippet" : "DataLog 生成器从模块树配置创建 DataLog 配置对象。该对象将被添加到该实例的应用程序中 数据记录管理器 已映射。在当前版本中 CODESYS Application Composer ，数据日志生成器没有可用的配置对话框。...", 
"body" : "DataLog 生成器从模块树配置创建 DataLog 配置对象。该对象将被添加到该实例的应用程序中 数据记录管理器 已映射。在当前版本中 CODESYS Application Composer ，数据日志生成器没有可用的配置对话框。 " }, 
{ "title" : "趋势发生器 ", 
"url" : "ac_generator_configuration.html#UUID-b0155d06-1fc0-2914-55ee-2233ae0d22ee", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成器配置 \/ 趋势发生器 ", 
"snippet" : "趋势生成器从模块描述中读取趋势定义，并创建具有关联可视化的趋势配置。这些可视化将嵌入到现有的可视化中。...", 
"body" : "趋势生成器从模块描述中读取趋势定义，并创建具有关联可视化的趋势配置。这些可视化将嵌入到现有的可视化中。 " }, 
{ "title" : "警报发生器 ", 
"url" : "ac_generator_configuration.html#UUID-62c4fd14-9eaa-46b5-f370-4e36a88614fe", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成器配置 \/ 警报发生器 ", 
"snippet" : "警报生成器从模块描述中读取警报定义，并创建或扩展警报管理的相关组件。此外，可视化是根据模板创建的。在此可视化中插入了警报表。可视化将添加到可视化生成器的其他可视化模板中，如下所示 顶层可视化 。 模板 可视化屏幕的模板。 注意：要使用可视化作为模板，它必须满足以下条件： 一个带有名字的矩形 Placeholder_AlarmTable 变量 bAckVisible , bAckSel , bHistory ， 和 bFreezeScrlPos 类型的 BOOL 报警存储模板 类型对象 AlarmStorageTemplate ，在当前项目和引用的库中找到 所选模板将用于所有生成的警报配置。 创...", 
"body" : "警报生成器从模块描述中读取警报定义，并创建或扩展警报管理的相关组件。此外，可视化是根据模板创建的。在此可视化中插入了警报表。可视化将添加到可视化生成器的其他可视化模板中，如下所示 顶层可视化 。 模板 可视化屏幕的模板。 注意：要使用可视化作为模板，它必须满足以下条件： 一个带有名字的矩形 Placeholder_AlarmTable 变量 bAckVisible , bAckSel , bHistory ， 和 bFreezeScrlPos 类型的 BOOL 报警存储模板 类型对象 AlarmStorageTemplate ，在当前项目和引用的库中找到 所选模板将用于所有生成的警报配置。 创建顶级选项卡 ：将为创建的警报可视化创建顶级选项卡。 定义的名称将显示在顶级选项卡中。 " }, 
{ "title" : "设备诊断生成器 ", 
"url" : "ac_generator_configuration.html#UUID-eacb5fd7-1329-2790-9483-fe45edbe632a", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成器配置 \/ 设备诊断生成器 ", 
"snippet" : "该生成器创建用于设备诊断的可视化屏幕。在设置中， 可视化模板 并且可以定义屏幕的布局。 设备诊断生成器设置 在该对话框中，可以定义基本可视化、PLC 模板、总线模板、堆栈模板、父设备模板和子设备模板的模板。组合框列出了与相应模板类型匹配的所有可用可视化模板。 在对话框的下部，可以定义可视化屏幕的最小尺寸以及设备诊断可视化元素之间的空间。...", 
"body" : "该生成器创建用于设备诊断的可视化屏幕。在设置中， 可视化模板 并且可以定义屏幕的布局。 设备诊断生成器设置 在该对话框中，可以定义基本可视化、PLC 模板、总线模板、堆栈模板、父设备模板和子设备模板的模板。组合框列出了与相应模板类型匹配的所有可用可视化模板。 在对话框的下部，可以定义可视化屏幕的最小尺寸以及设备诊断可视化元素之间的空间。 " }, 
{ "title" : "CFC 程序生成器 ", 
"url" : "ac_generator_configuration.html#UUID-fdaff0f3-814e-b71a-bcac-a2994393c9ed", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成器配置 \/ CFC 程序生成器 ", 
"snippet" : "CFC 生成器用于创建 CFC 程序。 始终重新生成所有 CFC 引脚 : ：Application Composer 始终尝试为模块实例 FB 调用生成所有功能块 I\/O。...", 
"body" : "CFC 生成器用于创建 CFC 程序。 始终重新生成所有 CFC 引脚 : ：Application Composer 始终尝试为模块实例 FB 调用生成所有功能块 I\/O。 " }, 
{ "title" : "可视化生成器 ", 
"url" : "ac_generator_configuration.html#UUID-a364420f-f798-9fe6-3c1a-b98bc7c07391", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成器配置 \/ 可视化生成器 ", 
"snippet" : "该生成器创建可视化屏幕 CODESYS Application Composer 从可用的可视化 CODESYS 项目。 顶级名称 ：输入可视化的符号名称 模板 （“顶级模板”）。 模板 ：选择列表提供所有可用的（在项目和加载的库中）和兼容的可视化。如果您选择 默认 ，库中的默认模板 AC_Module 将会被使用。如果稍后从项目或库中删除在对话框中配置的模板，则该模板在此对话框中仍然可用。 目标视觉 , 网络可视化 ：如果页面模板应用于此显示变体，则激活相应的选项。 宽度： 生成的可视化的宽度（以像素为单位）（默认值：640，最小 100，最大 10000） 高度： 生成的可视化的高度（以像...", 
"body" : "该生成器创建可视化屏幕 CODESYS Application Composer 从可用的可视化 CODESYS 项目。 顶级名称 ：输入可视化的符号名称 模板 （“顶级模板”）。 模板 ：选择列表提供所有可用的（在项目和加载的库中）和兼容的可视化。如果您选择 默认 ，库中的默认模板 AC_Module 将会被使用。如果稍后从项目或库中删除在对话框中配置的模板，则该模板在此对话框中仍然可用。 目标视觉 , 网络可视化 ：如果页面模板应用于此显示变体，则激活相应的选项。 宽度： 生成的可视化的宽度（以像素为单位）（默认值：640，最小 100，最大 10000） 高度： 生成的可视化的高度（以像素为单位）（默认值：480，最小 100，最大 10000） 最小 ToplevelTab 宽度 ：生成的顶级选项卡的最小宽度（以像素为单位）。如果此处输入 0，则不考虑该设置。 最大顶级选项卡宽度 ：生成的顶级选项卡的最大宽度（以像素为单位）。如果此处输入 0，则不考虑该设置。 有关顶级模板的更多信息，请参阅： 顶级模板最大客户数量： 并行运行客户端的最大数量（默认 8，最小 1，最大 128）。 如果 SVN 可用，则忽略生成的 visus ：如果项目存储在 Subversion 中，则应激活此选项。 : CODESYS 确保生成的可视化在 SVN 中被忽略。否则可能会出现问题。 再生时重新创建visus : ：每次生成代码时，所有可视化也会重新生成，并覆盖现有可视化。如果模块用户不希望在生成后对生成的可视化进行更改，则应选择此选项。但是，如果生成后仍需要对可视化进行更改，则应停用该选项。然后 CODESYS 尝试将后续的变化与再生一起保留。 使用实例名称作为顶级选项卡的默认名称 : ：顶级选项卡中仅显示实例名称，而不是完整的实例路径。 如果配置中有错误，则会显示错误提供程序图标，并且 好的 按钮被禁用。 " }, 
{ "title" : "命令：扫描 ", 
"url" : "ac_scan.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：扫描 ", 
"snippet" : "扫描 象征： 此命令（类别“Composer”）扫描整个项目以查找模块声明。通常不需要这个命令，因为 CODESYS 在需要时自动扫描系统（例如：安装新库后）。...", 
"body" : "扫描 象征： 此命令（类别“Composer”）扫描整个项目以查找模块声明。通常不需要这个命令，因为 CODESYS 在需要时自动扫描系统（例如：安装新库后）。 " }, 
{ "title" : "命令：检查并扫描所有池对象 ", 
"url" : "_ac_cmd_check_and_scan_all_pool_objects.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：检查并扫描所有池对象 ", 
"snippet" : "检查并扫描所有池对象 功能 ：调用该命令时，首先检查库的 IEC 代码，然后搜索模块声明。测试运行对应命令 L检查所有池对象 。搜索对应命令 扫描。 称呼 : 作曲家 菜单 要求 ：该命令仅在库项目打开时可见。...", 
"body" : "检查并扫描所有池对象 功能 ：调用该命令时，首先检查库的 IEC 代码，然后搜索模块声明。测试运行对应命令 L检查所有池对象 。搜索对应命令 扫描。 称呼 : 作曲家 菜单 要求 ：该命令仅在库项目打开时可见。 " }, 
{ "title" : "命令：映射 I\/O ", 
"url" : "ac_map_channels_for_ioconfig.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：映射 I\/O ", 
"snippet" : "映射 I\/O 象征： 此命令（类别“Composer”）打开一个对话框来定义模块和 输入\/输出 配置。 对话： 输入\/输出映射 在对话框的左侧，模块的所有输入和输出都根据以下内容以树形结构显示： 模块树 。右侧是设备树的结构。 顶层模块与应用程序的连接是根据顶层模块的设置绘制的。无法在此对话框中更改此连接。 输入显示为绿色连接和绿色箭头 - 输出显示为红色。 开路输入或输出（无连接）以虚线显示。 如果 ST 表达式映射到输入 resp。输出时，连接将显示为“ST”。 模块和设备之间的连接只能是输入到输入或输出到输出。此外，两个连接必须具有兼容的数据类型。模块之间的连接只能从输入到输出，反之亦然...", 
"body" : "映射 I\/O 象征： 此命令（类别“Composer”）打开一个对话框来定义模块和 输入\/输出 配置。 对话： 输入\/输出映射 在对话框的左侧，模块的所有输入和输出都根据以下内容以树形结构显示： 模块树 。右侧是设备树的结构。 顶层模块与应用程序的连接是根据顶层模块的设置绘制的。无法在此对话框中更改此连接。 输入显示为绿色连接和绿色箭头 - 输出显示为红色。 开路输入或输出（无连接）以虚线显示。 如果 ST 表达式映射到输入 resp。输出时，连接将显示为“ST”。 模块和设备之间的连接只能是输入到输入或输出到输出。此外，两个连接必须具有兼容的数据类型。模块之间的连接只能从输入到输出，反之亦然。设备之间无法连接。 要创建连接，必须选择打开的输入或输出。选定的引脚以蓝色背景显示。输入和输出通过拖放连接。有效或无效的连接目标通过不同的鼠标指针指示。如果输入或输出被占用，现有连接将被删除。 如果设备或模块折叠，连接将被绘制为黑色，因为可能无法确定数据方向。 如果进一步折叠（例如上级设备），则连接也将被隐藏。这样做是为了改善概览，因为可以减少中间区域的线条粗细。 如果选择左侧或右侧的连接，则相应设备在折叠时将展开。 箭头显示数据方向。如果折叠的设备使用输入和输出，则该设备会显示绿色和红色箭头。如果只有输入或输出，还会显示数据方向。 在在线模式下，参数值显示在左侧。在此视图中无法更改这些值。 双击模块或设备，相应的对象将在编辑器中打开。 还可以跨应用程序边界设置连接！ 如果模块实例映射到 POU 池，则连接线将呈灰色显示。在这种情况下，无法创建 IO 映射，但可以删除现有映射。 打印 ：此命令允许以概览方式打印设置的 I\/O 映射。 " }, 
{ "title" : "命令：通配符选择 ", 
"url" : "ac_wildcard_selection.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：通配符选择 ", 
"snippet" : "通配符选择 此命令（类别“Composer”）打开对话框 通配符赋值 。 对话框的上部显示当前配置的通配符和分配的设备类型。对话框的下部显示设备存储库，提供已安装的设备以供选择。您可以在对话框中编辑分配。为此，当通配符无法自动分配给设备类型并且需要手动分配时，该对话框也会在设备生成期间出现。 设备类型的通配符分配存储在项目内。不过，您也可以使用 XML 文件在外部保存作业并从那里重新加载它们。文件和该文件的路径显示在对话框的顶部。 对话： 通配符赋值 新的 ：此命令允许创建新的（空）通配符分配 XML 文件。定义文件名和存储目录。 节省 ：此命令将当前定义的通配符设备分配显式保存到手动选择的文...", 
"body" : "通配符选择 此命令（类别“Composer”）打开对话框 通配符赋值 。 对话框的上部显示当前配置的通配符和分配的设备类型。对话框的下部显示设备存储库，提供已安装的设备以供选择。您可以在对话框中编辑分配。为此，当通配符无法自动分配给设备类型并且需要手动分配时，该对话框也会在设备生成期间出现。 设备类型的通配符分配存储在项目内。不过，您也可以使用 XML 文件在外部保存作业并从那里重新加载它们。文件和该文件的路径显示在对话框的顶部。 对话： 通配符赋值 新的 ：此命令允许创建新的（空）通配符分配 XML 文件。定义文件名和存储目录。 节省 ：此命令将当前定义的通配符设备分配显式保存到手动选择的文件中。除此之外，当使用以下命令关闭对话框时，分配将自动保存在当前指定的文件中 好的 按钮。 加载 ：此命令允许加载现有的通配符分配文件 (XML)。 在突出显示的树视图中， 设备 ID（模块名称） 列显示设备的 ID 设备生成器 使用通配符。带来该设备的模块实例的名称显示在括号中。如果是静态插入的设备生成器设备（由模块声明定义） Identification 并不是 Wildcard \/ FlexibleWildcard ) 标准节点 静止的 创建包含所有静态插入的设备。静态设备无法修改。这 关系 列显示设备生成器的父设备和子设备之间的关系。粗线表示固定关系，虚线表示关系的建议。该建议基于以下定义 ParentID 在里面 Device 部分。 通配符也可以标记为空，只需选择它们并按 德尔 钥匙。例如，这样的空通配符可以用来改变提议的父子关系。 分配的通配符以绿色背景显示；具有红色背景颜色的未分配通配符。 仅显示与第一代可能的父设备的兼容性 ：如果激活此选项，设备存储库视图的设备分类将进一步限制为仅第一个设备父设备的兼容子设备。这是由以下定义的 模块配置 。如果未激活，则第二代、第三代、……、第 n 代的设备父代也将被视为可能的父代，从而扩大设备存储库视图中显示的设备类别。 财产分配规则 如果在左侧选择设备或 IO 通道或 FB 实例，则已分配的该设备或 IO 通道或 FB 实例的所有属性将在右侧标有复选框 左侧未为其 IO 通道或 FB 实例分配属性的设备将以红色背景显示，相关 IO 通道或 FB 实例将分别以红色背景显示。分配了所有 I\/O 通道和 FB 实例的设备以绿色突出显示，已知的 I\/O 通道和 FB 实例也是如此。分配还包括不分配“要求较高”的属性。对于整个设备，后者可以通过双击整个设备及其所有 I\/O 通道和 FB 实例的设备节点来实现。 通过选中该框，可以将右侧的属性添加到左侧选择的设备、I\/O 通道或 FB 实例的“提供”属性中。可以为设备、I\/O 通道或 FB 实例分配任意数量的属性，也可以不分配任何属性。 如果将“要求较高”的 I\/O 属性分配给设备节点，则该属性将分配给该设备节点的所有子 I\/O 通道节点，但不会分配给 FB 实例。同样，如果为设备分配了“要求较高”的 InstRef 属性，则只有该设备的子 FB 实例才会分配该属性。可以同时选择多个设备、I\/O 通道或 FB 实例，然后尽可能将所选属性分配给每个设备、I\/O 通道或 FB 实例。 右侧的“要求”属性至少由左侧的一台设备提供，将以绿色背景显示。左侧没有匹配产品属性的“需求”属性将以红色背景显示。 " }, 
{ "title" : "分配通配符 ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_342a92346a13602cc0a8640e00a6970a", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：通配符选择 \/ 分配通配符 ", 
"snippet" : "有两种分配通配符的方法： 在对话框的上部，在要分配的通配符行中，单击列中的字段 选定的设备 。然后，在对话框下部的设备存储库树中，双击所需的设备。 在对话框下部的设备存储库树中，选择所需的设备。然后，在对话框的上部，在要分配通配符的行中，双击列中的字段 选定的设备 。...", 
"body" : "有两种分配通配符的方法： 在对话框的上部，在要分配的通配符行中，单击列中的字段 选定的设备 。然后，在对话框下部的设备存储库树中，双击所需的设备。 在对话框下部的设备存储库树中，选择所需的设备。然后，在对话框的上部，在要分配通配符的行中，双击列中的字段 选定的设备 。 " }, 
{ "title" : "设备属性分配 ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_4703909473b5f037c0a8640e01022fbe", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：通配符选择 \/ 设备属性分配 ", 
"snippet" : "命令 设备属性分配 打开相应的对话框，用于分配 奉献 设备的属性。 对话： 设备属性分配 对话框的左侧列出了项目中使用的所有生成的设备。这些设备的子节点显示相应设备类型的所有输入、输出（非粗体）和创建的功能块（粗体）。 右侧显示列出了所有“要求较高”的属性，这些属性在所用模块的模块声明中定义为 要求严格 IO。这些“需求”的子节点对应于所有需要其父节点需求的模块IO。 属性分配对话框用于将右侧的属性分配给设备及其 IO 通道。此分配将保存在设备的设备描述旁边的额外文件中，该文件会引用该额外文件。如果模块 IO 的所有“要求”属性不能满足至少一次对提供这些属性的设备的分配，则该对话框会在代码生成...", 
"body" : "命令 设备属性分配 打开相应的对话框，用于分配 奉献 设备的属性。 对话： 设备属性分配 对话框的左侧列出了项目中使用的所有生成的设备。这些设备的子节点显示相应设备类型的所有输入、输出（非粗体）和创建的功能块（粗体）。 右侧显示列出了所有“要求较高”的属性，这些属性在所用模块的模块声明中定义为 要求严格 IO。这些“需求”的子节点对应于所有需要其父节点需求的模块IO。 属性分配对话框用于将右侧的属性分配给设备及其 IO 通道。此分配将保存在设备的设备描述旁边的额外文件中，该文件会引用该额外文件。如果模块 IO 的所有“要求”属性不能满足至少一次对提供这些属性的设备的分配，则该对话框会在代码生成期间自动打开。 " }, 
{ "title" : "命令：删除 I\/O 映射 ", 
"url" : "ac_remove_connections_to_ios.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：删除 I\/O 映射 ", 
"snippet" : "删除 I\/O 映射 此命令（类别“Composer”）删除 I\/O 映射。 提供了以下子命令。 全部生成 ：删除自动生成的映射。手动添加的映射仍然存在。 全部 ：删除所有映射 - 自动生成的映射和手动添加的映射。 模块实例全部生成 ：如果在模块树中选择了模块实例，则可以执行该命令。该命令删除此实例自动生成的映射。手动添加的映射仍然存在。 所有模块实例 ：如果在模块树中选择了模块实例，则可以执行该命令。该命令删除此实例的所有映射 - 自动生成的映射和手动添加的映射。...", 
"body" : "删除 I\/O 映射 此命令（类别“Composer”）删除 I\/O 映射。 提供了以下子命令。 全部生成 ：删除自动生成的映射。手动添加的映射仍然存在。 全部 ：删除所有映射 - 自动生成的映射和手动添加的映射。 模块实例全部生成 ：如果在模块树中选择了模块实例，则可以执行该命令。该命令删除此实例自动生成的映射。手动添加的映射仍然存在。 所有模块实例 ：如果在模块树中选择了模块实例，则可以执行该命令。该命令删除此实例的所有映射 - 自动生成的映射和手动添加的映射。 " }, 
{ "title" : "命令：添加顶级模块实例 ", 
"url" : "ac_add_toplevel_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：添加顶级模块实例 ", 
"snippet" : "添加顶级模块实例 此命令（类别“Composer”）打开 模块对话框 它提供了可以添加到模块树中的所有顶级模块。 可以添加到应用程序的顶级模块的数量没有限制。...", 
"body" : "添加顶级模块实例 此命令（类别“Composer”）打开 模块对话框 它提供了可以添加到模块树中的所有顶级模块。 可以添加到应用程序的顶级模块的数量没有限制。 " }, 
{ "title" : "命令：添加子模块实例 ", 
"url" : "ac_add_submodule_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：添加子模块实例 ", 
"snippet" : "添加子模块实例 此命令（类别“Composer”）打开 模块对话框 它提供了可以添加到模块树中选定位置的所有子模块。 提供强制引用槽的子模块允许自动填充所有明确的引用槽。在这种情况下，会出现一个对话框询问用户是否自动引用模块。...", 
"body" : "添加子模块实例 此命令（类别“Composer”）打开 模块对话框 它提供了可以添加到模块树中选定位置的所有子模块。 提供强制引用槽的子模块允许自动填充所有明确的引用槽。在这种情况下，会出现一个对话框询问用户是否自动引用模块。 " }, 
{ "title" : "命令：参考模块实例 ", 
"url" : "ac_reference_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：参考模块实例 ", 
"snippet" : "参考模块实例 此命令（类别“Composer”）打开 模块对话框 它提供了可以在模块树中选定位置引用的所有模块。...", 
"body" : "参考模块实例 此命令（类别“Composer”）打开 模块对话框 它提供了可以在模块树中选定位置引用的所有模块。 " }, 
{ "title" : "命令：显示模块引用视图 ", 
"url" : "ac_module_references_editor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：显示模块引用视图 ", 
"snippet" : "显示模块参考视图 此命令（类别“Composer”）打开 模块参考 查看并提供项目中模块实例使用情况的概述。如果在模块树中选择了模块实例，则该命令在上下文菜单中可用。 如果选择另一个模块实例或当前所选实例的引用发生更改，则视图会自动更新。...", 
"body" : "显示模块参考视图 此命令（类别“Composer”）打开 模块参考 查看并提供项目中模块实例使用情况的概述。如果在模块树中选择了模块实例，则该命令在上下文菜单中可用。 如果选择另一个模块实例或当前所选实例的引用发生更改，则视图会自动更新。 " }, 
{ "title" : "查看：模块参考 ", 
"url" : "ac_module_references_editor.html#UUID-7a9e7bcf-5b4a-4286-24df-e6cd7795a03a_c2a0935773056bc0a86463423a2ab0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：显示模块引用视图 \/ 查看：模块参考 ", 
"snippet" : "应用程序\/参考来源 参考文献按应用程序排序。 参考在其目标中的作用 参考在其目标中的作用...", 
"body" : "应用程序\/参考来源 参考文献按应用程序排序。 参考在其目标中的作用 参考在其目标中的作用 " }, 
{ "title" : "命令：更新模块 ", 
"url" : "ac_update_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：更新模块 ", 
"snippet" : "更新模块 此命令（类别“Composer”）打开 模块对话框 。模块树提供与模块树中所选模块实例兼容的所有模块。该命令允许将模块实例更新为新的模块类型。这也可以是同一模块的新版本。 更新时，会尽可能保留实例的配置数据： 即使当前值与新参数类型不兼容，也会采用新版本中存在的参数值。如果实例中未显式设置参数值，则使用新模块的默认值。 将采用新版本中存在且与实例中的分配具有相同方向（输入或输出）的 I\/O 映射。该分配不必与要采用的新 I\/O 属于同一类型。 将采用两个版本中存在的任务分配。 新模块中具有相同插槽 ID 的插槽的子实例或引用将与所有子实例和引用一起维护。即使子实例或引用的类型与新槽不...", 
"body" : "更新模块 此命令（类别“Composer”）打开 模块对话框 。模块树提供与模块树中所选模块实例兼容的所有模块。该命令允许将模块实例更新为新的模块类型。这也可以是同一模块的新版本。 更新时，会尽可能保留实例的配置数据： 即使当前值与新参数类型不兼容，也会采用新版本中存在的参数值。如果实例中未显式设置参数值，则使用新模块的默认值。 将采用新版本中存在且与实例中的分配具有相同方向（输入或输出）的 I\/O 映射。该分配不必与要采用的新 I\/O 属于同一类型。 将采用两个版本中存在的任务分配。 新模块中具有相同插槽 ID 的插槽的子实例或引用将与所有子实例和引用一起维护。即使子实例或引用的类型与新槽不匹配，或者新槽的基数不允许所有子实例或引用，这也适用。 新模块中不存在的插槽的子实例或引用将插入到名为“孤立实例”或“孤立引用”的新插槽下方。这些时隙由普通时隙中不会出现的特殊标识符来标识。如果已经存在带有孤立元素的槽，则将使用该槽。 存在于新模块中但现在需要引用（如果是子实例）或子实例（如果是引用）的子实例或插槽引用将分别作为子实例进行处理。引用新模块中不可用的插槽。 如果对非顶级模块进行更新，则实例中存在的顶级信息将被删除。如果实例中不存在顶级信息，则在模块更新为顶级模块时将创建该信息。 由扩展定义的实例数据：相应的扩展决定哪些数据将被保留以及哪些数据将被删除。应坚持获取尽可能多的数据的原则。 如果新模块中的槽位顺序发生了变化，那么实例下方的槽位顺序也会相应调整。 如果更新将删除数据（例如，参数值、I\/O 分配、非空插槽或扩展实例数据），则会显示一条消息，描述将删除哪些对象并允许用户取消更新。 可以通过模块树中的一个撤消步骤来撤消实例的更新。 " }, 
{ "title" : "命令：更新所有实例 ", 
"url" : "ac_update_all_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：更新所有实例 ", 
"snippet" : "更新所有实例 此命令（类别“Composer”）允许使用一个命令将所有模块实例更新为模块的新版本。该命令在上下文菜单中不可用。该命令的行为根据该命令的描述 更新模块 命令，但是无法更新另一个模块。...", 
"body" : "更新所有实例 此命令（类别“Composer”）允许使用一个命令将所有模块实例更新为模块的新版本。该命令在上下文菜单中不可用。该命令的行为根据该命令的描述 更新模块 命令，但是无法更新另一个模块。 " }, 
{ "title" : "命令：隐藏空可选插槽：全部\/仅选定 ", 
"url" : "ac_hide_empty_optional_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：隐藏空可选插槽：全部\/仅选定 ", 
"snippet" : "隐藏空的可选插槽：全部\/仅选定 使用这些命令（类别“Composer”），您可以隐藏模块树中的空可选插槽。根据当前焦点，这指的是所有子模块或仅指当前选定的子模块。无法隐藏强制槽。 空可选槽的示例 要显示隐藏的插槽，请使用 显示隐藏槽位 – 全部\/仅选定 命令。...", 
"body" : "隐藏空的可选插槽：全部\/仅选定 使用这些命令（类别“Composer”），您可以隐藏模块树中的空可选插槽。根据当前焦点，这指的是所有子模块或仅指当前选定的子模块。无法隐藏强制槽。 空可选槽的示例 要显示隐藏的插槽，请使用 显示隐藏槽位 – 全部\/仅选定 命令。 " }, 
{ "title" : "命令：显示隐藏槽位：全部\/仅选定 ", 
"url" : "ac_show_hidden_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：显示隐藏槽位：全部\/仅选定 ", 
"snippet" : "显示隐藏槽位：全部\/仅选定 使用模块树中的这些命令（类别“Composer”），您可以使之前隐藏的任何插槽再次可见。根据当前焦点，这指的是所有子模块或仅指当前选定的子模块。 对于隐藏插槽，请参阅 隐藏空的可选插槽 - 全部\/仅选定 命令。...", 
"body" : "显示隐藏槽位：全部\/仅选定 使用模块树中的这些命令（类别“Composer”），您可以使之前隐藏的任何插槽再次可见。根据当前焦点，这指的是所有子模块或仅指当前选定的子模块。 对于隐藏插槽，请参阅 隐藏空的可选插槽 - 全部\/仅选定 命令。 " }, 
{ "title" : "命令：前往目标 ", 
"url" : "ac_go_to_target.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：前往目标 ", 
"snippet" : "前往目标 该命令（类别“Composer”）仅当在模块参考中选择时才可用。 模块树 。如果执行此命令，将在模块树中选择引用的目标。...", 
"body" : "前往目标 该命令（类别“Composer”）仅当在模块参考中选择时才可用。 模块树 。如果执行此命令，将在模块树中选择引用的目标。 " }, 
{ "title" : "命令：创建扩展模块 ", 
"url" : "_ac_cmd_create_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：创建扩展模块 ", 
"snippet" : "创建扩展模块 象征： 该命令创建一个 扩展模块 用于子模块插槽。仅当在模块树中选择空模块插槽或子模块时，它才可用。 该命令将打开一个对话框，您可以在其中定义是否将扩展创建为新模块（“无变体”）或现有模块或模块实例的变体。为此，下拉列表中提供了适合该插槽的所有模块。 有两种选择： 衍生变异 扩展模块派生自在中选择的模块或模块实例 的变化 。所选模块通过以下方式导入 IMPORTS 扩展模块和新模块的功能块源自模块模板功能块。 复制变体的源 通过复制完整的模块声明（包括功能块和从中选择的模块中的相关可视化）来创建新的扩展模块。 的变化 （包括源代码）。仅当在中选择的模块时，这才是可能的 的变化 在...", 
"body" : "创建扩展模块 象征： 该命令创建一个 扩展模块 用于子模块插槽。仅当在模块树中选择空模块插槽或子模块时，它才可用。 该命令将打开一个对话框，您可以在其中定义是否将扩展创建为新模块（“无变体”）或现有模块或模块实例的变体。为此，下拉列表中提供了适合该插槽的所有模块。 有两种选择： 衍生变异 扩展模块派生自在中选择的模块或模块实例 的变化 。所选模块通过以下方式导入 IMPORTS 扩展模块和新模块的功能块源自模块模板功能块。 复制变体的源 通过复制完整的模块声明（包括功能块和从中选择的模块中的相关可视化）来创建新的扩展模块。 的变化 （包括源代码）。仅当在中选择的模块时，这才是可能的 的变化 在源代码中可用，而不仅仅是作为编译库的模块。 扩展模块用于向现有的和预定义的模块或模块实例添加任何用户特定的修改或扩展。 关闭对话框后 好的 将在中创建一个新文件夹 POU 带有扩展模块名称的池。 在此文件夹中，将创建以下对象（其中 <name> 是扩展模块的名称）： 标准情况：具有名称的功能块 <name> ，扩展“模块”类并实现插槽类型所需的接口。在此功能块中，将创建所有方法和属性，这些方法和属性存在于已实现的接口中，但未在任何基类中实现。 变化情况：与标准情况一样，将创建相应的功能块。该功能块源自所选模块模板功能块（ 衍生变异 ）或者是它的副本（ 复制变体的源 ）。 图像池和文本列表（名称 IP_<name> 或者 TL_<name> ）。图像池包含两个带有标识符的图标 Icon_16 和 Icon_32 。文本列表包含条目 Desc ，其中充满了 <name> 。文本列表中没有语言，只有列 标准 。 空的可视化页面 Visu_M_<name> ，它实现了所需的接口。如果 从源复制变体 选择后，将复制源模块的可视化。 扩展模块将被添加到模块树中，该模块既没有参数也没有 I\/O。对于元数据，将使用创建的图像、文本和可视化元素。类别是“扩展”。如果它是“派生”变体，则模块模板声明还通过以下方式导入 IMPORTS 。如果它是“复制的”变体，则模块模板的声明被复制并以使用扩展模块的相应文本列表和图像池的方式进行调整。 " }, 
{ "title" : "命令：创建缺失的文本列表条目 ", 
"url" : "ac_create_missing_textlist_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：创建缺失的文本列表条目 ", 
"snippet" : "创建缺失的文本列表条目 此命令（类别“Composer”）自动创建所有文本列表和由模块声明引用且不存在的文本列表条目。该命令仅在以下情况下可用 模块声明编辑器 打开时焦点位于该对象上，并且该对象存在于主项目中。该函数仅在没有语法错误的情况下才起作用。文本列表将在与编辑器中的对象相同的父对象下创建。对于新创建的条目，仅填充“默认”文本（带有 ID）。...", 
"body" : "创建缺失的文本列表条目 此命令（类别“Composer”）自动创建所有文本列表和由模块声明引用且不存在的文本列表条目。该命令仅在以下情况下可用 模块声明编辑器 打开时焦点位于该对象上，并且该对象存在于主项目中。该函数仅在没有语法错误的情况下才起作用。文本列表将在与编辑器中的对象相同的父对象下创建。对于新创建的条目，仅填充“默认”文本（带有 ID）。 " }, 
{ "title" : "命令：生成图像池中缺失的条目 ", 
"url" : "ac_create_missing_image_pool_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成图像池中缺失的条目 ", 
"snippet" : "生成图像池中缺失的条目 该命令生成在模块描述中定义但尚不存在于项目的图像池中的条目的图像池。如果镜像池尚不存在，则在 POU 首先查看。 默认情况下，该命令在 作曲家 菜单。您使用 工具 → 自定义 对话框将其添加到 作曲家 命令类别到 作曲家 菜单。 然后该命令将显示在 作曲家 当模块打开并聚焦在编辑器中时的菜单。...", 
"body" : "生成图像池中缺失的条目 该命令生成在模块描述中定义但尚不存在于项目的图像池中的条目的图像池。如果镜像池尚不存在，则在 POU 首先查看。 默认情况下，该命令在 作曲家 菜单。您使用 工具 → 自定义 对话框将其添加到 作曲家 命令类别到 作曲家 菜单。 然后该命令将显示在 作曲家 当模块打开并聚焦在编辑器中时的菜单。 " }, 
{ "title" : "命令：向上移动 ", 
"url" : "ac_move_up.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：向上移动 ", 
"snippet" : "提升 该命令（类别“Composer”）可用于更改模块在 模块树 。此命令仅适用于多槽元素（模块实例和引用）并且所选元素不是多槽的第一个元素。...", 
"body" : "提升 该命令（类别“Composer”）可用于更改模块在 模块树 。此命令仅适用于多槽元素（模块实例和引用）并且所选元素不是多槽的第一个元素。 " }, 
{ "title" : "命令：向下移动 ", 
"url" : "ac_move_down.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：向下移动 ", 
"snippet" : "下移 该命令（类别“Composer”）可用于更改模块在 模块树 。此命令仅适用于多槽元素（模块实例和引用）并且所选元素不是多槽的最后一个元素。...", 
"body" : "下移 该命令（类别“Composer”）可用于更改模块在 模块树 。此命令仅适用于多槽元素（模块实例和引用）并且所选元素不是多槽的最后一个元素。 " }, 
{ "title" : "命令：检查未知条目 ", 
"url" : "ac_check_for_unknown_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：检查未知条目 ", 
"snippet" : "检查未知条目 此命令（类别“Composer”）检查模块声明中是否有未知的节定义。子命令 全部 始终可用，检查项目的所有模块声明。如果在编辑器中打开模块声明，则附加子命令 在当前编辑器中 检查当前打开的模块声明中是否有未知的节定义。...", 
"body" : "检查未知条目 此命令（类别“Composer”）检查模块声明中是否有未知的节定义。子命令 全部 始终可用，检查项目的所有模块声明。如果在编辑器中打开模块声明，则附加子命令 在当前编辑器中 检查当前打开的模块声明中是否有未知的节定义。 " }, 
{ "title" : "命令：生成、编译并登录 ", 
"url" : "ac_generate_compile_login.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：生成、编译并登录 ", 
"snippet" : "生成、编译并登录 象征： 此命令（类别“Composer”）只需单击一下鼠标即可执行多个命令。首先创建并编译代码。如果可能，应用程序将登录到控制器并启动。...", 
"body" : "生成、编译并登录 象征： 此命令（类别“Composer”）只需单击一下鼠标即可执行多个命令。首先创建并编译代码。如果可能，应用程序将登录到控制器并启动。 " }, 
{ "title" : "命令：将模块库添加到项目中 ", 
"url" : "ac_add_libraries_to_pou.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：将模块库添加到项目中 ", 
"snippet" : "将模块库添加到项目中 象征： 此命令（类别“Composer”）打开一个包含库的模块的对话框。随着 好的 按钮，选定的库将被添加到 POU 池的库管理器中。如果标准 Composer 库 AC_ModlueBase 缺少的话，也会自动添加。 添加 Application Composer 库的对话框 对话框提供按钮 打开 POU 库管理器 它允许打开库管理器 POU 泳池也在 Composer Dedicated 看法。...", 
"body" : "将模块库添加到项目中 象征： 此命令（类别“Composer”）打开一个包含库的模块的对话框。随着 好的 按钮，选定的库将被添加到 POU 池的库管理器中。如果标准 Composer 库 AC_ModlueBase 缺少的话，也会自动添加。 添加 Application Composer 库的对话框 对话框提供按钮 打开 POU 库管理器 它允许打开库管理器 POU 泳池也在 Composer Dedicated 看法。 " }, 
{ "title" : "命令：活动断点到下一步 ", 
"url" : "ac_active_breakpoints_to_next_step.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：活动断点到下一步 ", 
"snippet" : "下一步的活动断点 此命令（类别“Composer”）仅在在线模式下且序列已在断点处停止时可用。它会删除当前活动的断点并向以下步骤添加一个新断点。...", 
"body" : "下一步的活动断点 此命令（类别“Composer”）仅在在线模式下且序列已在断点处停止时可用。它会删除当前活动的断点并向以下步骤添加一个新断点。 " }, 
{ "title" : "命令：中心视图到断点 ", 
"url" : "ac_center_view_to_breakpoints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：中心视图到断点 ", 
"snippet" : "中心视图到断点 此命令（类别“Composer”）仅在在线模式下且序列已在断点处停止时可用。它将序列编辑器的视图以当前活动的断点为中心。...", 
"body" : "中心视图到断点 此命令（类别“Composer”）仅在在线模式下且序列已在断点处停止时可用。它将序列编辑器的视图以当前活动的断点为中心。 " }, 
{ "title" : "命令：创建宏模块 ", 
"url" : "ac_create_macro_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：创建宏模块 ", 
"snippet" : "创建宏模块 象征： 此命令（在“Composer”类别中）打开一个用于生成宏模块的对话框。 要使用此命令，您需要有效的许可证来创建 模块声明 。 如果您在模块树中选择了子树，则该命令可用。您可以使用此命令从子树的模块生成宏模块。通过这种方式，您可以定义子模块的哪些插槽、I\/O 和参数在新宏模块中可用。 元数据 姓名 这是宏模块的唯一名称。 宏描述 描述被创建为文本列表。 宏类别 类别用于在模块的插入对话框中对模块进行细分。 插槽\/IO\/参数 宏模块子树 子树所有对象的树视图 该结构还将相应子模块实例的所有插槽、I\/O 和参数显示为子元素（粗体）。 宏模块插槽 这将显示宏模块类型应包括的所有插槽...", 
"body" : "创建宏模块 象征： 此命令（在“Composer”类别中）打开一个用于生成宏模块的对话框。 要使用此命令，您需要有效的许可证来创建 模块声明 。 如果您在模块树中选择了子树，则该命令可用。您可以使用此命令从子树的模块生成宏模块。通过这种方式，您可以定义子模块的哪些插槽、I\/O 和参数在新宏模块中可用。 元数据 姓名 这是宏模块的唯一名称。 宏描述 描述被创建为文本列表。 宏类别 类别用于在模块的插入对话框中对模块进行细分。 插槽\/IO\/参数 宏模块子树 子树所有对象的树视图 该结构还将相应子模块实例的所有插槽、I\/O 和参数显示为子元素（粗体）。 宏模块插槽 这将显示宏模块类型应包括的所有插槽、I\/O 和参数。 这些元素直接来自左侧的树视图。 宏模块 IO 宏模块参数 添加到宏 如果您在左侧的树视图中选择插槽、I\/O 或参数，则此选项处于活动状态。 您可以通过单击此按钮将元素添加到宏模块。 从宏中删除 如果您从右侧的树视图中选择插槽、I\/O 或参数，则此选项处于活动状态。 您可以通过单击此按钮从宏模块中删除元素。 当您通过单击关闭对话框时 好的 , CODESYS Application Composer 为该宏模块生成模块声明、文本列表和图像池。对象存储在具有宏名称的文件夹中。您现在可以不受限制且独立于生成来编辑生成的对象。例如，您可以通过这种方式交换图像池中的宏图标。 " }, 
{ "title" : "命令：签署所有模块 ", 
"url" : "ac_sign_all_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：签署所有模块 ", 
"snippet" : "签署所有模块 此命令（类别“Composer”）允许对 POU 池的所有模块进行（更新）签名。该命令可用于对所有模块进行重新签名 POU 水池。使用有效许可证开发的模块会自动签名。此命令旨在接管 Application Composer 先前版本的现有未签名模块。...", 
"body" : "签署所有模块 此命令（类别“Composer”）允许对 POU 池的所有模块进行（更新）签名。该命令可用于对所有模块进行重新签名 POU 水池。使用有效许可证开发的模块会自动签名。此命令旨在接管 Application Composer 先前版本的现有未签名模块。 " }, 
{ "title" : "命令：转到模块 FB ", 
"url" : "ac_goto_modul_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：转到模块 FB ", 
"snippet" : "转到模块 FB 命令（类别“Composer”）可用于在编辑器中打开模块的功能块或其方法。您必须在模块树中选择一个模块才能使该命令可用。 在离线模式下，功能块类型或功能块方法的声明将在编辑器中打开。在在线模式下，功能块实例或模块实例的方法将在编辑器中打开。...", 
"body" : "转到模块 FB 命令（类别“Composer”）可用于在编辑器中打开模块的功能块或其方法。您必须在模块树中选择一个模块才能使该命令可用。 在离线模式下，功能块类型或功能块方法的声明将在编辑器中打开。在在线模式下，功能块实例或模块实例的方法将在编辑器中打开。 " }, 
{ "title" : "命令：不同的参数值 ", 
"url" : "ac_differing_parameter_values.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：不同的参数值 ", 
"snippet" : "不同的参数值 在在线模式下使用此命令可检查模块树中使用的模块实例的任何参数值是否已在模块功能块中修改。在这种情况下，您将获得修改后的列表 参数 以及相关模块实例的 留言 看法。双击消息将打开相关模块实例的参数编辑器。应用程序的在线模式和离线模式下具有不同值的所有参数将由列中的红框单元格指示 价值 和 在线价值 。...", 
"body" : "不同的参数值 在在线模式下使用此命令可检查模块树中使用的模块实例的任何参数值是否已在模块功能块中修改。在这种情况下，您将获得修改后的列表 参数 以及相关模块实例的 留言 看法。双击消息将打开相关模块实例的参数编辑器。应用程序的在线模式和离线模式下具有不同值的所有参数将由列中的红框单元格指示 价值 和 在线价值 。 " }, 
{ "title" : "命令：重置顶级选项卡的文本 ", 
"url" : "ac_reset_text_of_toplevel_tabs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：重置顶级选项卡的文本 ", 
"snippet" : "重置顶级选项卡的文本 功能 ：此命令将文本重置为默认设置 顶级选项卡 在模块编辑器中定义的 人机界面 标签。点击 Composer → 重置顶级选项卡的文本 → 全部 重置所有顶级选项卡的文本。点击 Composer → 重置顶级选项卡的文本 → 仅选定 仅重置所选模块的文本（在 模块 看法）。点击 作曲家 → 创建 更新应用程序。 称呼 : 作曲家 菜单 要求 ：具有顶级选项卡的特殊配置文本的模块存在于 模块 看法。 模块示例 以下步骤描述如何设置和重置顶级选项卡的文本。 您的项目包括 Building 模块。 双击 Building 模块中的 模块 看法。 模块编辑器（模块配置器）打开。 ...", 
"body" : "重置顶级选项卡的文本 功能 ：此命令将文本重置为默认设置 顶级选项卡 在模块编辑器中定义的 人机界面 标签。点击 Composer → 重置顶级选项卡的文本 → 全部 重置所有顶级选项卡的文本。点击 Composer → 重置顶级选项卡的文本 → 仅选定 仅重置所选模块的文本（在 模块 看法）。点击 作曲家 → 创建 更新应用程序。 称呼 : 作曲家 菜单 要求 ：具有顶级选项卡的特殊配置文本的模块存在于 模块 看法。 模块示例 以下步骤描述如何设置和重置顶级选项卡的文本。 您的项目包括 Building 模块。 双击 Building 模块中的 模块 看法。 模块编辑器（模块配置器）打开。 激活该选项 创建顶级选项卡 。 然后出现一个输入字段，其中包含预设的顶级文本 Building 。 指定文本 City hall 。 点击 作曲家 → 创建 。 模块可视化和 Toplevel 可视化被创建并存储在 设备 看法。 双击 Toplevel 可视化在 设备 看法。 → 保存项目。 双击 Building 模块中的 模块 看法。 的命令 作曲家 菜单可用。 选择 Building 模块。 点击 Composer → 重置顶级选项卡的文本 → 仅选定 。 文本重置为默认设置 Building 在模块编辑器旁边的输入字段中 创建顶级选项卡 选项。 点击 作曲家 → 创建 。 模块可视化和 Toplevel 可视化被更新并存储在 设备 看法。 打开 Toplevel 可视化在 设备 看法。 → 子模块示例 以下步骤描述了如何在模块和子模块的模块结构中设置和重置顶级选项卡的文本。 您的项目包括 Building 模块和 Bathroom 子模块。 双击 Building 模块中的 模块 看法。 模块编辑器（模块配置器）打开。 激活该选项 创建顶级选项卡 。 然后出现一个输入字段，其中包含预设的顶级文本 Building 。 指定文本 City hall 。 双击 Bathroom 模块中的 模块 看法。 模块编辑器（模块配置器）打开。 激活该选项 创建顶级选项卡 。 然后出现一个输入字段，其中包含预设的顶级文本 Building.Bathroom 。 指定文本 WC 。 点击 作曲家 → 创建 。 模块可视化和 Toplevel 可视化被创建并存储在 设备 看法。 双击 Toplevel 可视化在 设备 看法。 → 保存项目。 双击 Building 模块中的 模块 看法。 的命令 作曲家 菜单可用。 选择 Building 模块。 点击 Composer → 重置顶级选项卡的文本 → 全部 。 点击 作曲家 → 创建 。 模块可视化和 Toplevel 可视化被更新并存储在 设备 看法。 打开 Toplevel 可视化在 设备 看法。 → " }, 
{ "title" : "命令：从 FB 创建模块 ", 
"url" : "ac_create_module_from_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：从 FB 创建模块 ", 
"snippet" : "从 FB 创建模块 该命令（类别“Composer”）从功能块创建模块描述。 创建以下对象： 带有名称的模块描述 <NameOfTheFB> 带有名称的图像池 IP_<NameOfTheFB> 带有名称的文本列表 TL_<NameOfTheFB> 界面名称 TL_<NameOfTheFB> 我<FB 名称>。 这个接口扩展了 AC.IModule 。 模块描述根据以下规则创建： 所有变量 var_input constant 被定义为模块参数。那里有属性 parameterCategory , parameterMinValue ， 和 parameterMaxValuehere 可用于设置类...", 
"body" : "从 FB 创建模块 该命令（类别“Composer”）从功能块创建模块描述。 创建以下对象： 带有名称的模块描述 <NameOfTheFB> 带有名称的图像池 IP_<NameOfTheFB> 带有名称的文本列表 TL_<NameOfTheFB> 界面名称 TL_<NameOfTheFB> 我<FB 名称>。 这个接口扩展了 AC.IModule 。 模块描述根据以下规则创建： 所有变量 var_input constant 被定义为模块参数。那里有属性 parameterCategory , parameterMinValue ， 和 parameterMaxValuehere 可用于设置类别和最小\/最大值。 所有数值变量 var_output 被定义为模块输出。 所有数值变量 var_input 定义为模块输入，除非它们被标记为多插槽的一部分。 所有变量 var_input 类型的 Interface 成为单个插槽，如果它们标有 ac_single_slot 属性。 要创建多插槽，请使用一对 var_input 是必需的，由一个 Pointer to Interface 和一个整型变量。两者都必须标有 'ac_multi_slot' := '<ID>' 属性，其中 <ID> 两者必须匹配。 " }, 
{ "title" : "命令：创建持久性管理器 ", 
"url" : "ac_create_persistence_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：创建持久性管理器 ", 
"snippet" : "创建持久性管理器 此命令（类别“Composer”）插入一个完整的 持久化管理器 使用默认设置进入模块树。持久化管理器下面有一个模块 持久化通道 下面是一个模块 数据存储 已插入。 然后可以根据需要更改和扩展创建的结构。这是在模块的参数中完成的 持久通道 和模块 数据存储 。在顶层模块实例中 持久性管理模块 至少必须设置目标应用程序。在将应用程序加载到控制器之前，命令 产生 也必须被执行。 该命令还将所有必需的库添加到库管理器并激活关联的生成器。...", 
"body" : "创建持久性管理器 此命令（类别“Composer”）插入一个完整的 持久化管理器 使用默认设置进入模块树。持久化管理器下面有一个模块 持久化通道 下面是一个模块 数据存储 已插入。 然后可以根据需要更改和扩展创建的结构。这是在模块的参数中完成的 持久通道 和模块 数据存储 。在顶层模块实例中 持久性管理模块 至少必须设置目标应用程序。在将应用程序加载到控制器之前，命令 产生 也必须被执行。 该命令还将所有必需的库添加到库管理器并激活关联的生成器。 " }, 
{ "title" : "命令：创建数据日志管理器 ", 
"url" : "ac_create_datalog_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：创建数据日志管理器 ", 
"snippet" : "创建数据日志管理器 此命令（类别“Composer”）插入一个完整的 数据记录管理器 使用默认设置进入模块树。 DataLog Manager 下面有一个模块 数据记录通道 下面是一个模块 数据记录存储 已插入。 然后可以根据需要更改和扩展创建的结构。这是在参数中完成的 模块“数据记录通道” 和 模块“数据记录存储 CSV” 。在顶层模块实例中 数据记录管理模块 至少必须设置目标应用程序。在将应用程序加载到控制器之前，命令 产生 也必须被执行。 该命令还将所有必需的库添加到库管理器并激活关联的生成器。...", 
"body" : "创建数据日志管理器 此命令（类别“Composer”）插入一个完整的 数据记录管理器 使用默认设置进入模块树。 DataLog Manager 下面有一个模块 数据记录通道 下面是一个模块 数据记录存储 已插入。 然后可以根据需要更改和扩展创建的结构。这是在参数中完成的 模块“数据记录通道” 和 模块“数据记录存储 CSV” 。在顶层模块实例中 数据记录管理模块 至少必须设置目标应用程序。在将应用程序加载到控制器之前，命令 产生 也必须被执行。 该命令还将所有必需的库添加到库管理器并激活关联的生成器。 " }, 
{ "title" : "命令：获取许可证信息 ", 
"url" : "ac_cmd_get_license_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 命令 \/ 命令：获取许可证信息 ", 
"snippet" : "获取许可证信息 使用此命令（“作曲家” 类别）， CODESYS 获取模块树中使用的模块实例的数量。还会查询当前许可证的最大允许实例数。结果显示在 消息 观点。 欲了解更多信息，请参阅 ???...", 
"body" : "获取许可证信息 使用此命令（“作曲家” 类别）， CODESYS 获取模块树中使用的模块实例的数量。还会查询当前许可证的最大允许实例数。结果显示在 消息 观点。 欲了解更多信息，请参阅 ???" }, 
{ "title" : "教程 ", 
"url" : "f_application_composer_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 教程 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "入门示例 ", 
"url" : "f_application_composer_first_steps.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 教程 \/ 入门示例 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "应用程序编写器示例 ", 
"url" : "ac_example_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 教程 \/ 入门示例 \/ 应用程序编写器示例 ", 
"snippet" : "此示例基于一个小型项目，描述了如何为应用程序编辑器创建模块。 本教程中的一些 URL 链接到作为 Application Composer 一部分的帮助页面。如果您尚未安装此软件包，这些链接将不起作用。 该示例模块描绘了一个带有灯和开关的房间。该开关可用作调光器或调光器。长按会使灯光变暗，短按则会切换灯光。调光器功能的速度以及光的最大值可由用户定义。当按下开关超过指定时间时，调光功能将被激活。光的输出就是亮度。还有第二个灯，比较简单，只能通过第二个开关打开和关闭。 示例项目 第 0 步：准备工作...", 
"body" : "此示例基于一个小型项目，描述了如何为应用程序编辑器创建模块。 本教程中的一些 URL 链接到作为 Application Composer 一部分的帮助页面。如果您尚未安装此软件包，这些链接将不起作用。 该示例模块描绘了一个带有灯和开关的房间。该开关可用作调光器或调光器。长按会使灯光变暗，短按则会切换灯光。调光器功能的速度以及光的最大值可由用户定义。当按下开关超过指定时间时，调光功能将被激活。光的输出就是亮度。还有第二个灯，比较简单，只能通过第二个开关打开和关闭。 示例项目 第 0 步：准备工作 " }, 
{ "title" : "第 0 步：准备工作 ", 
"url" : "ac_example_s0_preliminaries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 教程 \/ 入门示例 \/ 第 0 步：准备工作 ", 
"snippet" : "首先必须创建一个新项目。因此选择 新项目 来自 文件 菜单并保存新项目。必须添加库管理器 POU 看法。然后是图书馆 AC_ModuleBase ，这是 CODESYS Application Composer 包，可以添加到库管理器中。 添加库“AC_ModulBase” 第1步：创建顶级模块“Room”...", 
"body" : "首先必须创建一个新项目。因此选择 新项目 来自 文件 菜单并保存新项目。必须添加库管理器 POU 看法。然后是图书馆 AC_ModuleBase ，这是 CODESYS Application Composer 包，可以添加到库管理器中。 添加库“AC_ModulBase” 第1步：创建顶级模块“Room” " }, 
{ "title" : "第1步：创建顶级模块“Room” ", 
"url" : "ac_example_s1_create_toplevel_room.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 教程 \/ 入门示例 \/ 第1步：创建顶级模块“Room” ", 
"snippet" : "添加模块声明和功能块到 POU 水池。功能块用于模块的实现（功能程序）。在此示例中，模块和功能块的名称为 Room 。此外，功能块必须扩展基本类型 AC.Module ，这是 AC_ModuleBase 库并提供广泛的属性和功能。由于我们不想更改后者，因此可以删除使用功能块创建的所有属性和功能。 添加功能块和模块 声明以关键字开头 MODULE 接下来是模块名称和 IMPLEMENTED_BY 以及实现该模块的功能块的名称，对于当前的情况，该名称是功能块 Room。在这个特定的例子中，这是 Room 功能块。在大多数情况下，该部分 MetaData 现在已宣布。有关所有部分的所有参数的详细信息...", 
"body" : "添加模块声明和功能块到 POU 水池。功能块用于模块的实现（功能程序）。在此示例中，模块和功能块的名称为 Room 。此外，功能块必须扩展基本类型 AC.Module ，这是 AC_ModuleBase 库并提供广泛的属性和功能。由于我们不想更改后者，因此可以删除使用功能块创建的所有属性和功能。 添加功能块和模块 声明以关键字开头 MODULE 接下来是模块名称和 IMPLEMENTED_BY 以及实现该模块的功能块的名称，对于当前的情况，该名称是功能块 Room。在这个特定的例子中，这是 Room 功能块。在大多数情况下，该部分 MetaData 现在已宣布。有关所有部分的所有参数的详细信息，请参阅帮助页面 模块声明 。 因为 房间 是我们示例中的顶级模块，声明的下一个部分是 Toplevel 部分。后者允许定义全局变量列表的名称（ GVL_name ）包括生成后顶级功能块的实例。之后，必须在顶层部分至少定义一项任务。这是 Standard_Task 在这个例子中，它被定义为 MEDIUM 任务并包含标志 CREATE_IF_MISSING 和 UPDATE_IOS 。 模块声明 Room 所有图标和字符串，用于模块的描述和图标占位符（参数 Desc , Icon_16 和 Icon_32 ）必须从文本列表和图像池中引用。话虽如此，适当的文本列表 TL 和图像池 IP ，其中包括所有引用的图标和文本，必须创建并添加到 POU 水池。 创建文本列表和图像池 第2步：创建子模块“Switch” " }, 
{ "title" : "第2步：创建子模块“Switch” ", 
"url" : "ac_example_s2_create_sublevel_switch.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 教程 \/ 入门示例 \/ 第2步：创建子模块“Switch” ", 
"snippet" : "下一步是声明一个用于房间开关的模块。同样，必须创建模块声明和功能块。在这里，两者都被称为 Switch ，其中声明必须由功能块实现。模块声明 Switch 不需要顶级部分，因为它将添加到模块下方 Light （稍后描述）没有顶级职位。由于所有模块实现功能块都是强制性的，因此功能块 Switch 必须延长 AC.Module ， 也。对于当前的情况，功能块还实现一个接口 ISwitch ，必须创建它。该接口本身必须实现该接口 IModule ，由图书馆提供 AC_ModuleBase 。然而，该界面 ISwitch 保持“空”——没有声明任何属性或函数。 此外，开关需要输入信号（可能来自外部源\/...", 
"body" : "下一步是声明一个用于房间开关的模块。同样，必须创建模块声明和功能块。在这里，两者都被称为 Switch ，其中声明必须由功能块实现。模块声明 Switch 不需要顶级部分，因为它将添加到模块下方 Light （稍后描述）没有顶级职位。由于所有模块实现功能块都是强制性的，因此功能块 Switch 必须延长 AC.Module ， 也。对于当前的情况，功能块还实现一个接口 ISwitch ，必须创建它。该接口本身必须实现该接口 IModule ，由图书馆提供 AC_ModuleBase 。然而，该界面 ISwitch 保持“空”——没有声明任何属性或函数。 此外，开关需要输入信号（可能来自外部源\/物理开关）来指示何时轻敲。该信号在 IO 使用变量的部分 xIn 实现该模块的功能块。此外，还需要一个参考时间来区分开关的两种功能： 按下开关的持续时间 tTimer 启动调光功能 - 短按仅打开或关闭灯。这个变量 tTimer （也是模块实现功能块的一部分）将被声明为模块的参数（部分 Parameters ），最终可以在使用该模块时轻松编辑。 子模块的声明 Switch 引用的变量 xIn 和 tTimer 都定义为功能块的输入 Switch ，其中参数 tTimer 获取初始默认值 500ms。因此，当用户按下 Switch 超过500ms，灯光将变暗。 声明于 Switch 功能块 此外，文本列表和图像池必须扩展以包括输入和参数所需的描述文本。 文本列表和图像池中的条目 第3步：创建子模块“Switch Simple” " }, 
{ "title" : "第3步：创建子模块“Switch Simple” ", 
"url" : "ac_example_s3_create_sublevel_switchsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 教程 \/ 入门示例 \/ 第3步：创建子模块“Switch Simple” ", 
"snippet" : "我们要声明的第二个开关模块是一个简化的模块，只有两种状态：开和关。因此，必须创建一个模块声明和一个功能块，它们改编自上面的“Dim-Switch”。新的界面类型 ISwitchSimple 用于功能块。另一个区别是，变量 xIn 应声明为 BOOL 变量且无参数 tTimer 是完全需要的。 第四步：创建子模块“Light”...", 
"body" : "我们要声明的第二个开关模块是一个简化的模块，只有两种状态：开和关。因此，必须创建一个模块声明和一个功能块，它们改编自上面的“Dim-Switch”。新的界面类型 ISwitchSimple 用于功能块。另一个区别是，变量 xIn 应声明为 BOOL 变量且无参数 tTimer 是完全需要的。 第四步：创建子模块“Light” " }, 
{ "title" : "第四步：创建子模块“Light” ", 
"url" : "ac_example_s4_create_sublevel_light.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 教程 \/ 入门示例 \/ 第四步：创建子模块“Light” ", 
"snippet" : "正如之前所做的那样 Switch 和 SwitchSimple ，对于模块 Light , 模块声明 Light , 一个功能块 Light 和一个接口 ILight 必须被创建。模块应由功能块实现，功能块本身应实现接口 ILight 。 为了能够添加 Light 我们下面的模块 Room 模块，模块声明 Room 必须用一个扩展 Slots 部分。在本节中有一个小节 Slot_Multi 必须被创建，这被称为 Lights 并且能够容纳该类型的模块 Light 。可以或必须添加到房间的灯的数量由参数定义 Cardinality （在本例中为 1 到 3 个灯）。此外还声明了两个变量： Var...", 
"body" : "正如之前所做的那样 Switch 和 SwitchSimple ，对于模块 Light , 模块声明 Light , 一个功能块 Light 和一个接口 ILight 必须被创建。模块应由功能块实现，功能块本身应实现接口 ILight 。 为了能够添加 Light 我们下面的模块 Room 模块，模块声明 Room 必须用一个扩展 Slots 部分。在本节中有一个小节 Slot_Multi 必须被创建，这被称为 Lights 并且能够容纳该类型的模块 Light 。可以或必须添加到房间的灯的数量由参数定义 Cardinality （在本例中为 1 到 3 个灯）。此外还声明了两个变量： Variable （ pLights ，它将保存添加到房间的灯光模块的功能块实例）和 Var_Count （ uiNumberOfLights ，其中将填充添加到房间的灯光模块的数量）。 节的定义 Slots 变量 pLights 和 uiNumberOfLights 必须添加到模块“Lights”的功能块中，其中 uiNumberOfLights 是一个 UINT 和 pLights 类型的 POINTER TO ILight 根据此定义，只有其功能块也实现了 ILight 接口可以添加到 Lights 投币口。 声明于 Room 功能块 与用于 Room 模块现在用于 Light 模块。结果，声明 Light 包括一个插槽 Switch ，这就是为什么这个插槽不是多插槽，而是简单插槽。的附加参数 Light 模块是调光器的速度 rSpeed 和最大亮度 uiMaxValue 。最后，必须定义代表相关光亮度的输出。所有参数、槽和输出也必须作为变量添加到功能块中 Light 模块。 模块声明 Light 功能块的声明 Light 文本列表和图像池 第5步：创建子模块“Light simple” " }, 
{ "title" : "第5步：创建子模块“Light simple” ", 
"url" : "ac_example_s5_create_sublevel_lightsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 教程 \/ 入门示例 \/ 第5步：创建子模块“Light simple” ", 
"snippet" : "现在创建的简单灯将与一个简单的开关一起工作，但可以改编自 Light 无论如何，上面。因此需要一个新的模块声明和功能块 LightSimple 必须被创建。由于功能块只是实现了接口 ILight ，稍后可以向房间添加不同类型的灯光。主要区别为 Light 也就是说，槽的变量必须是以下类型 ISwitchSimple 为了避免错误地切换到a下 LightSimple 模块。此外，输出 LightSimple 应属于类型 BOOL 并被命名为 xSwitchedOn 。 第六步：实施...", 
"body" : "现在创建的简单灯将与一个简单的开关一起工作，但可以改编自 Light 无论如何，上面。因此需要一个新的模块声明和功能块 LightSimple 必须被创建。由于功能块只是实现了接口 ILight ，稍后可以向房间添加不同类型的灯光。主要区别为 Light 也就是说，槽的变量必须是以下类型 ISwitchSimple 为了避免错误地切换到a下 LightSimple 模块。此外，输出 LightSimple 应属于类型 BOOL 并被命名为 xSwitchedOn 。 第六步：实施 " }, 
{ "title" : "第六步：实施 ", 
"url" : "ac_example_s6_implementation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 教程 \/ 入门示例 \/ 第六步：实施 ", 
"snippet" : "开关 用于模块功能的实现 Switch 我们使用该方法 CallPrioMediumStart 从 Module 通过用我们自己的实现覆盖它。我们选择这个函数，因为该模块 Room 宣布了 MEDIUM 任务，这意味着该方法 CallPrioMediumStart 功能块的 Switch 将被称为中等任务的每个周期。详细信息可以在示例项目本身中看到。然而，开关的主要功能是轻触和调暗功能之间的区别。按下开关后，计时器将按照用户参数中的给定时间启动。当定时器完成并且开关未释放时，使用暗淡功能，由变量指示 xPushLong 。变量 xPush 是 TRUE ，如果刚刚轻按开关。对彼此而言 xPus...", 
"body" : "开关 用于模块功能的实现 Switch 我们使用该方法 CallPrioMediumStart 从 Module 通过用我们自己的实现覆盖它。我们选择这个函数，因为该模块 Room 宣布了 MEDIUM 任务，这意味着该方法 CallPrioMediumStart 功能块的 Switch 将被称为中等任务的每个周期。详细信息可以在示例项目本身中看到。然而，开关的主要功能是轻触和调暗功能之间的区别。按下开关后，计时器将按照用户参数中的给定时间启动。当定时器完成并且开关未释放时，使用暗淡功能，由变量指示 xPushLong 。变量 xPush 是 TRUE ，如果刚刚轻按开关。对彼此而言 xPushLong 和 xPush 属性被添加到两个功能块中 Switch 和界面 ISwitch ，以便可以从父灯光功能块中使用它们。 光 再次， Light 功能块覆盖方法 CallPrioMediumStart 。根据底层开关的输入变量，灯光变暗为“开”或“关”或仅切换。对于调光器，声明参数的速度值 rSpeed 用来。达到最大或最小调光值后，停止调光。如果灯处于调暗状态并且轻按开关，灯就会打开。 （具体实现在对应的示例工程中给出） 检查代码 实施后，应使用命令检查声明 建造 。如果没有显示错误，则声明没问题。 第 7 步：构建模块 " }, 
{ "title" : "第 7 步：构建模块 ", 
"url" : "ac_example_s7_composing_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 教程 \/ 入门示例 \/ 第 7 步：构建模块 ", 
"snippet" : "成功扫描声明后，所有模块都可供进一步使用，以便可以编写示例应用程序。因此，模块将添加到项目的模块树中。为此视图 模块 必须打开。 第一步，顶层模块 Room 必须添加到树中。 将顶级模块添加到模块树中 这 模块对话框 打开并提供所有可用的顶级模块。在此对话框中，显示图像池中定义的相应图标以及文本列表中的文本。现在可以选择模块“Room”并将其添加到模块树中。 对话框：“添加模块” 现在可以通过双击打开顶层模块的编辑器 Room 在模块树中。必须在上选择代码生成的目标应用程序 Toplevel 标签。模块声明中声明的任务显示在字段中 标准任务 。 “房间”模块的设置 类似于子模块上面的步骤 Li...", 
"body" : "成功扫描声明后，所有模块都可供进一步使用，以便可以编写示例应用程序。因此，模块将添加到项目的模块树中。为此视图 模块 必须打开。 第一步，顶层模块 Room 必须添加到树中。 将顶级模块添加到模块树中 这 模块对话框 打开并提供所有可用的顶级模块。在此对话框中，显示图像池中定义的相应图标以及文本列表中的文本。现在可以选择模块“Room”并将其添加到模块树中。 对话框：“添加模块” 现在可以通过双击打开顶层模块的编辑器 Room 在模块树中。必须在上选择代码生成的目标应用程序 Toplevel 标签。模块声明中声明的任务显示在字段中 标准任务 。 “房间”模块的设置 类似于子模块上面的步骤 Light 可以添加到模块树中。由于房间声明中的多槽定义，最多可以添加三个灯。的值 maxLightValue 和 Speed 可以参数化 Parameters 编辑器的选项卡 Light 模块。在 I\/O 编辑器中输出 Brightness 映射到局部变量 uiBrightness 对于我们的例子。 “灯光”模块的设置 下面新添加的 Light ，一个模块 Switch 必须添加。在实例编辑器中 Switch 模块中，模块声明中定义的所有参数和 I\/O 均可用。对于我们的示例，局部变量 xPushSwitch 映射到输入变量 x输入 。简单光的输出映射到局部变量 xSimpleOn 。 “开关”模块的设置 在我们示例的最后一步中 LightSimple 与一个 SwitchSimple 添加到模块树中。简单光的输出映射到局部变量 xSimpleOn 。简单开关量输入 xPushSimpleSwitch 映射到变量 xPushSimpleSwitch。 组合模块树示例 最后，必须使用命令生成项目 产生 。下载到设备后，可以通过更改值来测试示例 xPushSwitch 。对于调光值 用户界面亮度 应缓慢增加，通过点击，其值直接设置为 0 或最大值。改变 xPushSimpleSwitch 直接切换相应灯的输出。 最后必须提到的是，组成模块的最后步骤可以以任何组合方式完成，而不会丢失生成代码的功能。 " }, 
{ "title" : "图书馆：机电一体化 ", 
"url" : "ac_mechatronics_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块编辑器 \/ 教程 \/ 图书馆：机电一体化 ", 
"snippet" : "这 Mechatronics 库旨在成为具有顺序执行功能的机电单元的简单（而非完整）实现的示例。它不能满足完整机电一体化应用程序可能具有的所有要求。相反，它旨在成为此类应用程序的入口点或基础。 所提出的机电一体化模型的核心基于以下模块结构： 应用程序编辑器示例 Mechatronics 因此，假设任何机器都可能有多个机电子单元（例如：每个子单元代表一个夹具）。这样的子单元再次分为其执行器（相当于机械单元本身，也是其功能实现或 I\/O 管理）和程序管理器。程序管理器旨在管理机电电子子单元的不同状态，例如其 Idle 或者 Execute 状态。最终，这些状态由控制执行器或正确执行所需的任何其他内...", 
"body" : "这 Mechatronics 库旨在成为具有顺序执行功能的机电单元的简单（而非完整）实现的示例。它不能满足完整机电一体化应用程序可能具有的所有要求。相反，它旨在成为此类应用程序的入口点或基础。 所提出的机电一体化模型的核心基于以下模块结构： 应用程序编辑器示例 Mechatronics 因此，假设任何机器都可能有多个机电子单元（例如：每个子单元代表一个夹具）。这样的子单元再次分为其执行器（相当于机械单元本身，也是其功能实现或 I\/O 管理）和程序管理器。程序管理器旨在管理机电电子子单元的不同状态，例如其 Idle 或者 Execute 状态。最终，这些状态由控制执行器或正确执行所需的任何其他内容的程序序列来表示。 至此，对各部分进行简要详细介绍。使用该库时，在许多情况下需要实现您自己的执行器、流程步骤或程序序列，这也将在此处进行解释。 执行器 ：所有应该是执行器的模块必须由一个功能块来实现，该功能块又实现 IActuator 界面。该接口没有方法或属性，仅用于模块兼容性（请参阅 IActuator 图书馆中的文档）。对于致动器的实现没有给出任何限制或规则，因此这种致动器的移动或激活必须单独完成。通常，这是通过实现序列步骤模块来完成的，该模块可以将适当的致动器固定在参考槽中，从而以所需的方式移动后者（例如使用附加接口）。 步骤顺序 强烈建议您将流程步骤的实现作为 StepBase 功能块。这提供了所有必要的基本实现 IProgramSequenceStep 界面。请参阅 IActuator 图书馆中的文档。使用基类时 StepBase ，那么只需执行 Execute 方法。然后程序流程循环调用后者，直到变量 xDone 基类的设置为 TRUE 。此外，为了获得正确的功能，该标志 xActive 应设置为 TRUE 只要该步骤处于活动状态。然而，与执行器的连接可以通过任何方式完成，例如通过建议的参考槽（参见 1.）。 程序顺序和程序管理器 程序序列是程序管理器的子模块，代表一种状态。这些状态以 OMAC 状态机的形式进行管理。它的实现再次基于方法“执行”（有关详细信息，请参阅库中的实现）。然而，在大多数情况下，用户不需要执行这样的程序流程。然而，状态机的行为在程序管理器中实现并由此执行程序序列的方式将在这里简要描述： 有两种类型的状态：执行状态（以“ing”结尾）和等待\/双重状态（其余）。等待状态由外部命令结束，而动作状态则自动执行并结束。可用命令取决于程序管理器当前所处的状态。 OMAC 状态图中给出了简短的概述： OMAC图 模块： MovableBarrier 该模块 MovableBarrier 实现方式如下： 对应的功能块 MovableBarrier 实现创建的接口 IMovableBarrier 。后一个接口定义了移动障碍物的方法，而 IMovableBarrier 本身实现接口 IActuator ，使得模块 MovableBarrier 可作为执行器插入机电一体化单元下方的模块树中： 模块的实现 MovableBarrier 然而，这个执行器“MovableBarrier”是由序列步骤模块移动的 MoveBarrierForTime ，它本身是通过以下方式实现的： 模块的实现 MoveBarrierForTime 模块实现功能块 MoveBarrierForTime 只是从库包含的基本功能块派生而来 AC_MEC.StepBase 。由此功能块 MoveBarrierForTime 已经实现了该接口 IProgramSequenceStep 。因此该模块 MoveBarrierForTime 可作为程序序列下的序列步骤插入。功能块的功能实现 MoveBarrierForTime 如下：通过为模块定义一个参考槽 MoveBarrierForTime ，它可以容纳实现接口的执行器 IMovableBarrier ，可以连接到现有的“MovableBarrier”执行器。该执行器的运动最终在 Execute 的功能 MoveBarrierForTime 功能块，它只是调用（如图所示）移动防护罩的方法。该方法由引用的执行器提供，它实现 IMovableBarrier 。此外，该物业 Done 和变量 xActive 耦合到 TON，以便重复调用 的 move 函数 IMovableBarrier 直到经过一定时间 (TON) 后才完成 Done 设置为 TRUE 并且 xActive 为假。该物业 Done 是界面的一部分 IProgramSequenceStep 从而告诉上级程序序列，应执行下一个序列步骤。 除了您自己实现的序列步骤之外， AC_Mechatronics.library 还提供了一些预先实现的步骤，可用于一般的逻辑操作。例如这意味着一步 BranchOnBool 提供了两个子序列\/步骤分支，它们基于 BOOL 变量的值执行。这些子步骤的执行取决于布尔变量的值。此外，图书馆 AC_Mechatronics.library 包含并行流的流程步骤、条件跳转或简单的等待步骤以及更多任务。 " }, 
{ "title" : "模块声明编辑器 ", 
"url" : "ac_module_declaration_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 ", 
"snippet" : "模块通常代表机电组件，但也可以是纯软件功能。它包含了所涵盖的所有工程方面 CODESYS 。 模块有一个功能块，它实现接口 IModule 从图书馆 AC_ModuleBase 。它还包含有关子模块、参数化、I\/O 需求、任务分配和可视化的信息。模块构成了核心概念 CODESYS Application Composer 。 这 CODESYS Application Composer 还提供了模板工程，可以在 新项目 对话。该模板在 POU 池中创建一个包含设备、应用程序和库管理器的项目。后者包含库 AC_ModuleBase 和 AC_Persistence 。模板，基于项目 Compos...", 
"body" : "模块通常代表机电组件，但也可以是纯软件功能。它包含了所涵盖的所有工程方面 CODESYS 。 模块有一个功能块，它实现接口 IModule 从图书馆 AC_ModuleBase 。它还包含有关子模块、参数化、I\/O 需求、任务分配和可视化的信息。模块构成了核心概念 CODESYS Application Composer 。 这 CODESYS Application Composer 还提供了模板工程，可以在 新项目 对话。该模板在 POU 池中创建一个包含设备、应用程序和库管理器的项目。后者包含库 AC_ModuleBase 和 AC_Persistence 。模板，基于项目 ComposerProject.project ，可以根据需要进行修改。它存储在“Templates”子文件夹中 CODESYS 安装目录。 可以从现有功能块自动创建模块。因此，尽可能将现有声明转移到模块声明中。详细信息请参见说明 从 FB 创建模块 命令。 看 模块声明 有关如何开发模块的详细信息。 有关不同应用程序之间数据交换的信息，请参阅 IRMP服务 。 " }, 
{ "title" : "模块声明 ", 
"url" : "ac_module_declaration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 ", 
"snippet" : "模块的声明是使用自己的描述语言完成的，这类似于结构化文本（ST）代码中的变量声明。 模块声明的各个部分 部分：元数据 部分：顶层 部分：IO 部分：参数 部分：插槽 部分： 视觉 部分：代理 部分：VarArray 部分：约束 部分：InstRefs 部分：mse.Sequence 设备生成器alg.Alarm...", 
"body" : "模块的声明是使用自己的描述语言完成的，这类似于结构化文本（ST）代码中的变量声明。 模块声明的各个部分 部分：元数据 部分：顶层 部分：IO 部分：参数 部分：插槽 部分： 视觉 部分：代理 部分：VarArray 部分：约束 部分：InstRefs 部分：mse.Sequence 设备生成器alg.Alarm" }, 
{ "title" : "模块声明的格式 ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_48fab9ed86f6686ac0a8640e00dcb86d", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 模块声明的格式 ", 
"snippet" : "表单的标题 MODULE<name> 开始声明。接下来是“部分”列表。 每个部分都通过关键字进行介绍 SEC （“部分”）和唯一的名称。关键词 END_SEC 关闭该部分。节的内容包含由更多节或所谓的定义组成的条目列表。 定义由名称和可选值组成，并以分号结尾。 注释可以像 ST 代码一样使用：“\/\/”用于单行注释，“(*”和“*)”用于多行注释。空白（制表符和空格）和换行符\/换行符可用于分隔各部分否则在进一步处理过程中它们将被忽略。 与 ST 代码一样，区分大小写没有区别。 以下示例解释了模块声明的元素 01 MODULE Persistence IMPLEMENTED_BY Persiste...", 
"body" : "表单的标题 MODULE<name> 开始声明。接下来是“部分”列表。 每个部分都通过关键字进行介绍 SEC （“部分”）和唯一的名称。关键词 END_SEC 关闭该部分。节的内容包含由更多节或所谓的定义组成的条目列表。 定义由名称和可选值组成，并以分号结尾。 注释可以像 ST 代码一样使用：“\/\/”用于单行注释，“(*”和“*)”用于多行注释。空白（制表符和空格）和换行符\/换行符可用于分隔各部分否则在进一步处理过程中它们将被忽略。 与 ST 代码一样，区分大小写没有区别。 以下示例解释了模块声明的元素 01 MODULE Persistence IMPLEMENTED_BY PersistenceFB\n02 SEC MetaData\n03 NAME := TL.ChannelName ;\n04 DESC := TL.ChannelDesc ;\n05 COLLECTION CATEGORY := ’Persistence’TL.Collection ;\n06 ICON_16 := IP.Channel16 ;\n07 ICON_32 := IP.Channel32 ;\n08 END_SEC\n09 SEC Toplevel\n10 SEC STANDARD_TASK : LOW\n11 NAME := LOW ;\n12 DESC := TL.TaskLow ;\n13 FLAGS := CREATE_IF_MISSING | READONLY ;\n14 END_SEC\n15 GVL_NAME := 'GVL_%InstanceName%' ;\n16 END_SEC 第 01 行定义了模块名称“Persistence”。 IMPLEMENTED_BY 定义包含模块逻辑的功能块“PersitenceFB”。该功能块必须派生自 IModule 。在第 02 行部分 MetaData 从第 08 行开始并结束。本节包含五个定义。嵌套部分的可能性显示在 部分 Toplevel （第 09-16 行）其中包含以下小节 STANDARD_TASK （第 10 行）。 " }, 
{ "title" : "模块声明的语法 ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_819a1c8e627d0b32c0a8640e01623943", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 模块声明的语法 ", 
"snippet" : "在本节中，将解释模块声明的语法和允许的语法结构。 在下面的扫描仪标记中，将以大写字母书写（例如： ID ）。语法的非终结符将写在大括号中（例如： {Entry} ）。 词法分析（扫描仪） 在第一步中，将从模块声明的字符（例如：关键字、常量、标识符）创建所谓的标记（或词位）。 空格以及换行符\/换行符分隔标记，但否则将被忽略。为了进一步处理该声明，评论也将被忽略。 （注释可以写在一行中（ \/\/ \")或多行注释( (* 和 *) ）如 ST 语言。多行注释可以嵌套。 基本上，令牌始终具有最大长度。例如 a123 将被解释为标识符而不是标识符 a 后面跟着一个字面意思 123 。 下面列表中标记的顺序...", 
"body" : "在本节中，将解释模块声明的语法和允许的语法结构。 在下面的扫描仪标记中，将以大写字母书写（例如： ID ）。语法的非终结符将写在大括号中（例如： {Entry} ）。 词法分析（扫描仪） 在第一步中，将从模块声明的字符（例如：关键字、常量、标识符）创建所谓的标记（或词位）。 空格以及换行符\/换行符分隔标记，但否则将被忽略。为了进一步处理该声明，评论也将被忽略。 （注释可以写在一行中（ \/\/ \")或多行注释( (* 和 *) ）如 ST 语言。多行注释可以嵌套。 基本上，令牌始终具有最大长度。例如 a123 将被解释为标识符而不是标识符 a 后面跟着一个字面意思 123 。 下面列表中标记的顺序显示了它们的优先级。例如输入 MODULE 将被理解为关键字而不是标识符。 所有可用代币列表： 关键词： MODULE , SEC , END_SEC , IMPORTS ， 和 IMPLEMENTED_BY OP：以下字符的非空序列： .:,%()[]{}<>|+-*\/@!?^°=\\~ 注：注释标记 \/\/ , (* ， 和 *) 具有比操作员更高的优先级。运算符内部不能有注释，例如： +\/\/+ 将根据最大长度规则解释为运算符而不是 + 随后是一条评论。 LIT：IEC 文字，在 ST 中使用，示例： 1.4 , tod#12:13:14 。这包括布尔文字 TRUE 和 FALSE （大小写无关）。 注意：带负号的无类型文字 ( -1 , -3.2 ) 将被读取为两个标记，即 as 运算符 - 后面跟着一个无类型文字。由此产生的无类型数字文字永远不可能是负数。键入的文字 ( INT#-34 ) 将始终被解释为一个标记。 ID：有效的 IEC 标识符（ [a-zA-Z_][a-zA-Z0-9_]* )，其中不允许有两个连续的下划线。与 ST 不同，这还包括 ST 的关键字（即： FUNCTION , INT , EXTENDS ，……） 分号：字符 ; 语法（解析器） 模块声明的语法由以下语法定义。 µ 是一个空序列。 {MDecl} ::= MODULE {QID} {ImplSpec} {ImportsSpec} {MBody}\n{ImplSpec} ::= IMPLEMENTED_BY {QID} | µ\n{ImportsSpec} ::= IMPORTS {QID} | µ\n{MBody} ::= {SecList}\n{SecList} ::= {Modifiers} {Sec} {SecList} | µ\n{Sec} ::= SEC {QID} {SecTarget} {EntryList} END_SEC\n{SecTarget} ::= OP(\":\") {QID} | µ\n{Modifiers} ::= OP(\"[\") {ModifierList} OP(\"]\") | µ\n{ModifierList} ::= {QID} OP(\",\") {ModifierList} | {QID}\n{EntryList} ::= {Modifiers} {Entry} {EntryList}\n{Entry} ::= {Sec} | {Def}\n{Def} ::= {QID} OP(\":=\") {ValList} SEMICOLON |\n {QID} SEMICOLON\n{ValList} ::= {Val} {ValList} | {Val}\n{Val} ::= ID | LIT | OP\n{QID} ::= ID | ID OP(\".\") {QID} 定义值列表 ( {ValList} ) 必须以分号完成。这简化了语法并避免了歧义，因为分号不能是值的一部分（ {VAL} )，但在字符串文字中除外。 赋值运算符 ( := ）的定义（ {Def} ）也可以避免歧义（ {QID} ) 的定义名称和值。 定义的定义类型 文本：ID.ID（文本列表名称和文本列表标识符）-参见 文本列表字符串的本地化 Image：ID.ID（镜像池名称和镜像池标识符） ID（IEC 标识符） QID（合格标识符）： {QID} ::= ID | ID.ID CategoryPath ::= {StringLiteral} | {CategoryPath} 基数： [{MIN} .. {MAX}] | [ {MIN} .. INF [ {MIN} ， 和 {MAX} 是整数、非负文字。如果 {MAX} != INF ， 然后 {MIN} <= {MAX} 必须申请。 StringLiteral：IEC 字符串文字可能包含换行符。 StdTaskFlags ::= {StdTaskFlag} | StdTaskFlags ::= {StdTaskFlag} | {StdTaskFlags} StdTaskFlag ::= NONE | CREATE_IF_MISSING | READONLY 文字：任何 IEC 文字或 QID（对于枚举常量） DTBoolFlag： µ （空序列）| TRUE | FALSE 插槽类型： SUBMODULE | REFERENCE 编译指示： [ {PragmaList} ] {PragmaList} ::= {Pragma} | {Pragma} , {PragmaList} {Pragma} ::= { ( ID | {StringLiteral} | {OP2} )+ } {OP2} : 除 {, }, [, ] 和 , 。 实例路径： InstancePath ::= {IComp} | {IComp} . {IComp} 麻省理工学院 {IComp} ::= ID {ArrayAccess}* 和 {ArrayAccess} ::= [ {IntList} ] 和 {IntList} ::= Int | Int , {IntList} 任务参考：标准_任务。 （ Low | Medium | High ) | Custom_Task.ID " }, 
{ "title" : "实例路径 ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_e00dd4f26a1882aec0a8652000c0a4ae", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 实例路径 ", 
"snippet" : "在模块声明中的某些位置，可以定义实例路径来寻址功能块的变量：用于参数、槽、I\/O、具有可变大小的数组和实例引用。 实例路径定义为非空的组件序列，用点分隔： C1.C2…CN 。组件必须是 IEC 标识符或后跟索引表达式的组件 [i1, …, iN] ， 在哪里 i1 到 iN 是整数值。 实例路径始终与实现模块逻辑的功能块相关。实例路径的第一个组成部分是成员 ( VAR_INPUT 或者 VAR_OUTPUT ，取决于功能块的用例）。如果实例路径中有其他组件，这些组件将寻址成员内的变量。否则，将针对成员本身进行处理。实例路径可以限制为输入或输出变量（例如：I\/O）。对于结构，这些限制无效。这些...", 
"body" : "在模块声明中的某些位置，可以定义实例路径来寻址功能块的变量：用于参数、槽、I\/O、具有可变大小的数组和实例引用。 实例路径定义为非空的组件序列，用点分隔： C1.C2…CN 。组件必须是 IEC 标识符或后跟索引表达式的组件 [i1, …, iN] ， 在哪里 i1 到 iN 是整数值。 实例路径始终与实现模块逻辑的功能块相关。实例路径的第一个组成部分是成员 ( VAR_INPUT 或者 VAR_OUTPUT ，取决于功能块的用例）。如果实例路径中有其他组件，这些组件将寻址成员内的变量。否则，将针对成员本身进行处理。实例路径可以限制为输入或输出变量（例如：I\/O）。对于结构，这些限制无效。这些实例路径分别称为输入实例路径。输出实例路径。 " }, 
{ "title" : "文本列表字符串的本地化 ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_497561d55e22d540c0a8640e01561e3c", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 文本列表字符串的本地化 ", 
"snippet" : "模块中的文本（例如：模块描述、名称、参数描述）可以用不同语言显示。这些文本在文本列表中进行管理。 语言名称规范： 语言名称的格式 <LanguageCode>[-<Country\/Region>] （例子： en-US , de-DE ）。 <LanguageCode> 是根据 ISO 639-1 的语言名称（示例： de 或者 en ）。 <Country\/Region> 是符合 ISO 3166 的国家\/地区代码。 当检索文本列表条目时，系统首先查找整个语言名称。如果没有找到任何内容，它会查找 <LanguageCode> 。如果此搜索也失败，将使用默认文本。 文本列表中的语言名称示例 语...", 
"body" : "模块中的文本（例如：模块描述、名称、参数描述）可以用不同语言显示。这些文本在文本列表中进行管理。 语言名称规范： 语言名称的格式 <LanguageCode>[-<Country\/Region>] （例子： en-US , de-DE ）。 <LanguageCode> 是根据 ISO 639-1 的语言名称（示例： de 或者 en ）。 <Country\/Region> 是符合 ISO 3166 的国家\/地区代码。 当检索文本列表条目时，系统首先查找整个语言名称。如果没有找到任何内容，它会查找 <LanguageCode> 。如果此搜索也失败，将使用默认文本。 文本列表中的语言名称示例 语言 语言名称 中国人 zh-CHS 英语 en-US 法语 FR-FR 德语 去DE 意大利语 它-IT 日本人 ja-JP 葡萄牙语 PT-PT 俄语 茹-茹 西班牙语 ES-ES " }, 
{ "title" : "派生模块声明 ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_a596cccf5e22d542c0a8640e019ddff8", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 派生模块声明 ", 
"snippet" : "类似于功能块 A 从功能块 B（“EXTENDS”）的面向对象继承，可以通过使用 IMPORTS 关键词。修饰符 UPDATE 和 HIDE 受到特殊对待。 使用以下规则： 如果导入的模块是在不同的库中定义的，则必须使用命名空间指定该模块的名称。 不允许循环导入，特别是模块不得导入自身。 （循环导入的示例：模块 M_1 导入模块 M_2，M_2 导入 M_3，...，M_N 再次导入 M_1。） 无需定义派生模块 IMPLEMENTED_BY 指示。在这种情况下，将使用基本模块的功能块。 如果派生模块指定了功能块（通过使用 MPLEMENTED_BY )，该功能块必须派生自基本模块的功能块或者...", 
"body" : "类似于功能块 A 从功能块 B（“EXTENDS”）的面向对象继承，可以通过使用 IMPORTS 关键词。修饰符 UPDATE 和 HIDE 受到特殊对待。 使用以下规则： 如果导入的模块是在不同的库中定义的，则必须使用命名空间指定该模块的名称。 不允许循环导入，特别是模块不得导入自身。 （循环导入的示例：模块 M_1 导入模块 M_2，M_2 导入 M_3，...，M_N 再次导入 M_1。） 无需定义派生模块 IMPLEMENTED_BY 指示。在这种情况下，将使用基本模块的功能块。 如果派生模块指定了功能块（通过使用 MPLEMENTED_BY )，该功能块必须派生自基本模块的功能块或者必须与其相同。 派生模块继承基本模块的所有部分。它可以添加新部分或修改现有部分。 可以使用使用修饰符扩展的相同名称和目标在派生模块中修改节 UPDATE 。在这种情况下，其条目会发生更改。派生模块中该节的所有缺失定义将从基本模块接管。 修饰符 UPDATE 和 HIDE 仅当在基本模块中定义了相应的部分（名称和目标）时才能使用。相反，在基本模块中定义的节只能在派生模块中使用（如果它具有 HIDE 或者 UPDATE 修饰符。如果只有 HIDE 修饰符在该部分而不是 UPDATE ，则不允许任何定义。 必须更改派生模块中的某些条目（例如：描述）。 例子： MODULE MBase IMPLEMENTED_BY FBBase\nSEC MetaData\n DESC := TL.Desc_Base ;\nEND_SEC\nSEC Parameters\n SEC Param : paramxIn\n Variable := xIn ;\n Name := TL.Param1_Name ;\n Desc := TL.Param1_Desc ;\n END_SEC\nEND_SEC\n\nMODULE MDerived IMPORTS MBase\n[UPDATE] SEC MetaData\n DESC := TL.Desc_Derived ;\nEND_SEC\n[UPDATE] SEC Parameters\n [UPDATE,HIDE] SEC Param : paramIn\n Variable := xIn ;\n DEFAULT := TRUE ;\n END_SEC\nEND_SEC 在上面的例子中，参数 paramIn 模块的 MBase 隐藏在派生模块中 MDerived （通过使用 HIDE 修饰符），同时一个新的默认值（ TRUE ) 已设定。 " }, 
{ "title" : "章节和定义的顺序注释 ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_87237560fda311e1967bf6fe1c17b04f", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 章节和定义的顺序注释 ", 
"snippet" : "模块头后面的各部分的顺序无关紧要。在这些部分中，顺序可能非常重要。例如，槽声明的顺序定义了模块树中模块的顺序。 定义的顺序始终无关紧要。 与顺序相关的派生模块的规则： 基本模块的部分始终在模块本身的部分之前定义。 如果通过使用更改了基本模块的一部分 UPDATE 或者 HIDE ，其顺序不受影响。 派生模块不可能更改基本模块中定义的顺序。...", 
"body" : "模块头后面的各部分的顺序无关紧要。在这些部分中，顺序可能非常重要。例如，槽声明的顺序定义了模块树中模块的顺序。 定义的顺序始终无关紧要。 与顺序相关的派生模块的规则： 基本模块的部分始终在模块本身的部分之前定义。 如果通过使用更改了基本模块的一部分 UPDATE 或者 HIDE ，其顺序不受影响。 派生模块不可能更改基本模块中定义的顺序。 " }, 
{ "title" : "自动完成和“列出组件” ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_23e0e10e3a0c71c9c0a8640e0040f55b", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 自动完成和“列出组件” ", 
"snippet" : "当开始在模块编辑器中键入时，所有可用\/可能的部分定义都会显示在“列表组件”菜单中。仅显示当前位置的有意义的部分和定义。即使某些小节条目与其他节的小节条目具有相同的名称，它也会尝试仅显示匹配的节定义。 如果 返回 完成一个部分的第一行后按下，则该部分将完成所有必要的定义\/部分和 END_SEC 。 在变量定义之后，输入\/输出变量由“列表组件”定义呈现。标志或预定义值也出现在“列表组件”选择中，其显示可能的标志\/值。 定义之后，使用文本列表条目或图像池条目（例如：大多数时候 Desc := ），显示一个“列表组件”菜单，包括所有可用和可见的文本列表或图像池及其条目。 通过按 F2 ，即可打开相应的...", 
"body" : "当开始在模块编辑器中键入时，所有可用\/可能的部分定义都会显示在“列表组件”菜单中。仅显示当前位置的有意义的部分和定义。即使某些小节条目与其他节的小节条目具有相同的名称，它也会尝试仅显示匹配的节定义。 如果 返回 完成一个部分的第一行后按下，则该部分将完成所有必要的定义\/部分和 END_SEC 。 在变量定义之后，输入\/输出变量由“列表组件”定义呈现。标志或预定义值也出现在“列表组件”选择中，其显示可能的标志\/值。 定义之后，使用文本列表条目或图像池条目（例如：大多数时候 Desc := ），显示一个“列表组件”菜单，包括所有可用和可见的文本列表或图像池及其条目。 通过按 F2 ，即可打开相应的输入支持。 " }, 
{ "title" : "模块实例的初始化（在线修改） ", 
"url" : "ac_initialization_of_module_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 模块实例的初始化（在线修改） ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "模块实例和代理实例的初始化和重新初始化（在线更改） ", 
"url" : "ac_initialization_of_module_instances.html#UUID-d33dd918-6f7b-5e75-6686-b9d605273b58_index_2", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 模块实例的初始化（在线修改） \/ 模块实例和代理实例的初始化和重新初始化（在线更改） ", 
"snippet" : "方法 IBaseInstance.Init(bOnlineChange : BOOL) ) 在下载或在线更改所有顶级模块实例和所有代理实例后调用。如果需要，这些模块负责调用所有托管模块实例。 Init 一旦设置了所有参数值、托管和引用的模块实例并且模块实例已安装在模块树中，但在任务启动或继续之前，就会调用。 功能块中的标准实现 Module 调用所有子模块。 方法 IBaseInstance.OnBeforeOnlineChange 和 IBaseInstance.OnAfterOnlineChange 在重新创建模块树结构和更改参数值之前和之后调用。此外，在重新分配所有子模块和引用的模块之前...", 
"body" : "方法 IBaseInstance.Init(bOnlineChange : BOOL) ) 在下载或在线更改所有顶级模块实例和所有代理实例后调用。如果需要，这些模块负责调用所有托管模块实例。 Init 一旦设置了所有参数值、托管和引用的模块实例并且模块实例已安装在模块树中，但在任务启动或继续之前，就会调用。 功能块中的标准实现 Module 调用所有子模块。 方法 IBaseInstance.OnBeforeOnlineChange 和 IBaseInstance.OnAfterOnlineChange 在重新创建模块树结构和更改参数值之前和之后调用。此外，在重新分配所有子模块和引用的模块之前和之后、但在（重新）启动任务之前调用这些方法。 相比之下 FB_Init ，每次在线更改时都会调用此方法，无论是否 FB_Exit 之前已在旧实例上调用过。 " }, 
{ "title" : "部分：元数据 ", 
"url" : "ac_module_fb_sec_metadata.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：元数据 ", 
"snippet" : "元数据 这部分 MetaData 包含描述、类别和图标（尺寸为 16x16 像素和 32x32 像素）。 SEC MetaData \/\/optional: yes, modifier: [UPDATE]] Desc := <description>; \/\/optional: no, type: text Category := <category name>; \/\/optional: no, type: CategoryPath Icon_16 := <icon16 name>; \/\/optional: no, type: image Icon_32 := <icon32 name>; \/\/o...", 
"body" : "元数据 这部分 MetaData 包含描述、类别和图标（尺寸为 16x16 像素和 32x32 像素）。 SEC MetaData \/\/optional: yes, modifier: [UPDATE]]\n Desc := <description>; \/\/optional: no, type: text\n Category := <category name>; \/\/optional: no, type: CategoryPath\n Icon_16 := <icon16 name>; \/\/optional: no, type: image\n Icon_32 := <icon32 name>; \/\/optional: no, type: image\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: IDOrNothing\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Links := ['<link1>','<link2>',...] \/\/optional: Yes, type: UriCollection\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： 如果该部分 MetaData 缺少，该模块将用作无法实例化的基础模块。 Category 为属于同一主题的模块定义一个主题。人物 | 在“添加模块”对话框中创建元素的层次结构。那些角色 | 和 newline 或者 carriage return 不允许出现在结构名称中。 Icon_16 定义分辨率为 16 x 16 像素的图标的名称。图标的图像必须在图像池中定义。图标 Icon_16 用于模块树和图标 Icon_32 用于信息对话框。 Inst_Prefix 定义生成的 FB 实例和子模块实例的名称的默认前缀。空前缀 ( Inst_Prefix := ）也是可能的，但这可能会导致与功能块的其他变量名称相交。该预设可以在 部分中被覆盖 Slot 。 如果从模块类派生 IMPORTS ， 这部分 MetaData 如果基本模块中存在此部分，则必须更新。为此，必须使用修饰符声明该部分 UPDATE 并且必须重新定义描述。 Default_Inst_Name 可用于定义作为此插槽子级的模块实例的默认名称。默认情况下，添加的每个模块都会使用“Default_Inst_Name”定义的文本列表条目获取此名称。如果父插槽有默认名称，则该名称优先于模块元数据中的名称 Links 定义链接列表。链接显示在模块编辑器中 信息 标签。链接列表中第一个URL的内容显示在 信息 标签。 例子 SEC MetaData\n Desc := TL.Desc_Drives ;\n Category := 'Mechatronics'|'Drives' ;\n Icon_16 := IP.Drive_Icon_16 ;\n Icon_32 := IP.Drive_Icon_32 ;\n Default_Inst_Name := IDrive ;\n Links := ['file:\/\/\/d:\\Document1.pdf', 'https:\/\/www.codesys.com', 'mailto:info@codesys.com'];\nEND_SEC Category := 'Mechatronics'|'Drives 创建以下结构： " }, 
{ "title" : "部分：顶层 ", 
"url" : "ac_module_fb_sec_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：顶层 ", 
"snippet" : "Toplevel 位于模块树第一层的模块称为顶级模块。与其他模块相比，它们具有可以直接从一个或多个任务调用的方法。顶级模块包含以下部分 Toplevel 。 SEC Toplevel \/\/optional: yes, modifier: [UPDATE] GVL_Name := <GVL name>; \/\/optional: yes, type: literal Default_Application := <default application>; \/\/optional: yes, type: QID Default_POUPool := <TRUE\/FALSE>; \/\/optional:...", 
"body" : "Toplevel 位于模块树第一层的模块称为顶级模块。与其他模块相比，它们具有可以直接从一个或多个任务调用的方法。顶级模块包含以下部分 Toplevel 。 SEC Toplevel \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/(optional: no, type: Text)\n Flags:= <flag>; \/\/(optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： GVL_Name 定义将在其中声明模块实例及其所有子实例的 GVL 的名称。占位符 %Instancename% （大小写拼写无关），将替换为模块实例的实例名称。 参数 Default_Application 定义此模块的所有实例到特定应用程序的应用程序分配。如果定义了默认应用程序，则使用 Default_POUPool 不可能。 参数 Default_POUPool 定义该模块的所有实例到 POU 池的应用程序分配。如果定义了默认 POU 池，则使用 Default_Application 不可能。 参数 Pragmas 包含编译器编译指示列表，该列表将插入到模块的 FB 实例声明之前。 这部分 Standard_Task 定义将执行调用的任务。为此，可以执行三个标准任务： LOW , MEDIUM ， 和 HIGH 。的定义 Standard_Task 是： Name ：默认任务名称，创建模块实例后将定义为任务分配。 Desc ：任务调用的标识符。这应该简短且有意义（例如： I\/O task ）。 Flags ：以下值可以与 | 特点： CREATE_IF_MISSING ：任务不存在则创建。 READONLY ：任务分配是只读的，用户无法更改它。 UPDATE_IOS ：该任务用于更新I\/O。每个 I\/O 都可以被覆盖 UpdateInTask 中的参数 IO 部分。 NONE ：未设置标志。 例子 SEC Standard_Task : MEDIUM\n Name := MainTask ;\n Desc := TL.TaskMedium_Desc ;\n Flags := READONLY | CREATE_IF_MISSING ;\nEND_SEC 通过使用该部分 Custom_Task 一个模块可以定义一个或多个自定义任务。该节的目标必须是模块功能块的方法名称。该方法不能有参数（也不能有参数） INPUT , OUTPUT ，也不 INOUT ）。 Priority ：定义任务优先级。 Interval ：定义任务间隔（数据类型“TIME”或“LTIME”的常量）。 Flags ：以下值可以与 | 特点： SHARED ：出于兼容性原因，此标志仍然存在，但始终隐式假定已设置。这基本上意味着，如果一个任务具有在 Custom_Task 部分已存在，将使用此任务。但是，由于如果不存在具有匹配属性的现有任务，则会创建一个新任务，因此该标志将变得过时。创建的任务名称为 TASK_<ModuleInstanceName>_<MethodName> 。 UPDATE_IOS ：该任务将用于更新连接到 ST 表达式或直接连接到模块 I\/O 的 I\/O。 NONE ：未设置标志。 模块类中没有指定方法的默认实现。 例子 SEC Custom_Task : Method1\n Priority := 7 ;\n CycleTime := t#14ms ;\n Flags := NONE ;\nEND_SEC 恰好一项标准或特定任务必须具有 UPDATE_IOS 标志设置。 这里要提到一些基本规则，任务是如何生成的： 如果存在标准任务，但没有 CREATE_IF_MISSING 标志设置后，具有指定名称和生成器设置属性的任务应该存在。如果属性与指定的属性不匹配，则会显示一条警告消息。 如果存在标准任务，其中有 CREATE_IF_MISSING 设置标志后，首先生成具有指定属性的任务。现在，每当更改此任务的生成器设置时，都会调整该任务，而不会出现任何警告消息。 不允许引用相同任务名称的不同类型的标准任务。在这种情况下，不会发出错误。 根据配置的标准，在每个顶级实例的定义任务的开始和结束时调用以下方法： METHOD CallPrioHighStart: BOOL\nMETHOD CallPrioHighEnd: BOOL\nMETHOD CallPrioMediumStart: BOOL\nMETHOD CallPrioMediumEnd: BOOL\nMETHOD CallPrioLowStart: BOOL\nMETHOD CallPrioLowEnd: BOOL 每个模块负责调用其子模块实例。不得调用子模块引用。 FB中的默认实现 Module 按照模块树中的位置顺序调用所有子模块实例的相应方法。 SUPER 指针提供对基本功能块实例的访问。因此例如调用 SUPER^.CallPrioHighStart() 可以用来调用方法 Module.CallPrioHighStart() 如果功能块扩展 Module 。这样，执行中 Module 将确保调用所有子模块。 " }, 
{ "title" : "部分：IO ", 
"url" : "ac_module_fb_sec_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：IO ", 
"snippet" : "IO 输入和输出定义可以在本节中完成。所有定义的输入和输出都可以在 映射 I\/O 。 SEC IO \/\/optional: yes, modifier: [UPDATE] SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: no, type: InstancePath Name := <name>; \/\/optional: no, type: text Desc := <description>; \/\/optional: n...", 
"body" : "IO 输入和输出定义可以在本节中完成。所有定义的输入和输出都可以在 映射 I\/O 。 SEC IO \/\/optional: yes, modifier: [UPDATE]\n SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\n SEC Output : <output identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\nEND_SEC 有关定义类型语法的详细信息，请参阅：中的描述 模块声明的语法 。 规格： 参数 Variable 定义输入变量或输出变量的实例路径。 输入路径的所有组件都必须是输入变量（或结构中的局部变量）。输出路径的所有组件也必须是输出变量（或结构中的局部变量）。该变量必须是原始数据类型或枚举数据类型。 变量可以同时是参数和输入\/输出。一个变量不得由两个不同的 I\/O 使用。 的目标 input 或者 output 部分必须唯一标识输入或输出。不区分大小写。 参数 UpdateInTask 确定更新 I\/O 的任务。如果缺少该参数则带有flag的任务 UPDATE_IOS 将会被使用。对于顶级模块，如果指定的任务将产生错误 UpdateInTask 没有为模块定义。 例子 SEC Io\n SEC Input : uiTemperature\n Variable := uiTemperature ;\n Name := TL_WeatherStation.NAME_iTemperature ;\n Desc := TL_WeatherStation.DESC_iTemperature ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\n SEC Output : uiLigh\n Variable := uiLightnessSouth ;\n Name := TL_WeatherStation.NAME_uiLightnessSouth ;\n Desc := TL_WeatherStation.DESC_uiLightnessSouth ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\nEND_S " }, 
{ "title" : "部分：参数 ", 
"url" : "ac_module_fb_sec_parameters.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：参数 ", 
"snippet" : "参数 在本节中，可以定义所有参数，这些参数必须可用于参数化 参数 模块实例的。 SEC Parameters \/\/optional: yes, modifier: [UPDATE] SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: yes, type: InstancePath VariableType := <data type> \/\/optional: yes, type: @JG???IEC-Typ Name...", 
"body" : "参数 在本节中，可以定义所有参数，这些参数必须可用于参数化 参数 模块实例的。 SEC Parameters \/\/optional: yes, modifier: [UPDATE]\n SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: yes, type: InstancePath\n VariableType := <data type> \/\/optional: yes, type: @JG???IEC-Typ\n Name := <parameter name>; \/\/optional: no, type: text\n Desc := <parameter description>; \/\/optional: no, type: text\n Group := <parameter group name> \/\/optional: yes, type: text\n MustBeSet := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n Default := <default value>; \/\/optional: yes, type: LiteralOrConstant\n Max := <max value>; \/\/Optional: yes, type: LiteralOrConstant\n Min := <min value>; \/\/Optional: yes, type: LiteralOrConstant\n END_SEC\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： 本节的目标 Param 必须唯一标识参数。 定义 Variable 是相对于模块功能块的输入实例路径。该变量将存储参数值，其类型定义了参数类型。如果 Variable 声明时，参数 VariableType 不必定义并且将被忽略。 参数 VariableType 定义变量的 IEC 类型。如果 VariableType 已声明，但没有给出实际存在的 FB 变量 Variable 定义，即 Default 定义必须存在。该值必须匹配 VariableType 。 参数 Name 和 Desc 是字符串，必须在文本列表中定义。 模块参数可以是基本类型和枚举，但不能是结构体和数组的实例。 参数变量必须有 初始化值 ，它们在功能块的声明中定义。 可选参数 Default 允许覆盖初始化值。对于初始化表达式和默认值，允许使用正确类型的文字和常量。这包括库参数。 可选参数 Group 允许将参数分组。然后，每个组在模块编辑器中显示为单独的选项卡 参数 。 使用可选参数 MustBeSet 可以强制用户在模块编辑器中设置参数。如果未设置该参数，则会出现错误消息。 定义 最小 和 最大限度 允许设置参数值的限制。仅对于数字类型或时间的变量才可以检查这些限制。所有其他变量类型都是不允许的，并且会产生错误。 例子 SEC Parameters\n SEC Param : InParam1\n Variable := xIn1;\n VariableTyp := BOOL;\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC 变量 xIn1 必须在功能块的声明部分定义： xIn1 : BOOL := FALSE ; " }, 
{ "title" : "初始化值 ", 
"url" : "ac_module_fb_sec_parameters.html#UUID-1cddf7ea-faa7-0b82-e29a-04e9f27653b0_ac_module_fb_sec_parameters0", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：参数 \/ 初始化值 ", 
"snippet" : "初始化值是在初始化时定义的变量的值。在 FB 的简单变量中，该值始终位于变量声明的右侧： iVar : INT := 17 ; \/\/ Initialisierungswert: 17 如果在结构中定义变量，则结构的初始化至关重要： TYPE s : STRUCT i1 : INT := 7 ; r1 : REAL := 5 ; END_STRUCT END_TYPE 模块 FB 中的声明： structVar : s := (i1 := 2, r1 := 0.0) ; 在这种情况下，初始化值定义了 structVar.i1 是 2 （并不是 7 ）。 在嵌套结构中，必须考虑从模块 FB 到变量...", 
"body" : "初始化值是在初始化时定义的变量的值。在 FB 的简单变量中，该值始终位于变量声明的右侧： iVar : INT := 17 ; \/\/ Initialisierungswert: 17 如果在结构中定义变量，则结构的初始化至关重要： TYPE s : STRUCT\n i1 : INT := 7 ;\n r1 : REAL := 5 ;\nEND_STRUCT END_TYPE 模块 FB 中的声明： structVar : s := (i1 := 2, r1 := 0.0) ; 在这种情况下，初始化值定义了 structVar.i1 是 2 （并不是 7 ）。 在嵌套结构中，必须考虑从模块 FB 到变量的路径中的所有初始化。变量的最外层初始化决定了其值。 " }, 
{ "title" : "部分：Slots ", 
"url" : "ac_module_fb_sec_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：Slots ", 
"snippet" : "Slots 本节定义模块树中模块的可用性和插槽类型。可以定义两种不同类型的槽。 投币口 SEC Slots \/\/optional: yes, modifier: [UPDATE]] SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: no, type: InstancePath Role := <role name>; \/\/optional: no, type: text Type := <slot type>; \/\/optio...", 
"body" : "Slots 本节定义模块树中模块的可用性和插槽类型。可以定义两种不同类型的槽。 投币口 SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Role := <role name>; \/\/optional: no, type: text\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identigier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier> \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： 这部分 Slot 定义允许 0 个连接或 1 个连接的插槽。 本节的目标 Slot 必须唯一标识参数。因此，不能有两个不同的插槽（无论 Slot 或者 Slot_Multi ）具有相同的目标。 （大小写无关。） 定义 Variable 是相对于模块功能块的输入实例路径。实例路径在其所有组件中只能引用输入变量（对于结构实例还有局部变量）。寻址变量的类型必须是接口或 FB 类型。两个不同的槽不能使用相同的变量。 Role 定义槽的角色描述。 Type 定义槽类型。连接类型可以具有以下值： SUBMODULE ：子模块实例的插槽。 REFERENCE ：引用子模块实例的插槽。 DECOUPLED ：“解耦”模块实例的插槽。 也可以看看： 部分：解耦 Inst_Prefix 是用于生成的 FB 变量名称的前缀。空前缀 ( Inst_Prefix := ; ) 也是可能的，但可能会与功能块的其他变量名称发生冲突。只能指定用于 SUBMODULE 类型槽。 Optional 定义是否允许插槽保持打开状态或者是否必须连接。 Default_Inst_Name 可用于定义作为此插槽子级的模块实例的默认名称。默认情况下，添加的每个模块都会使用“Default_Inst_Name”定义的文本列表条目获取此名称。插槽的默认名称优先于模块元数据之一。 Pragmas 包含插入在子模块的 FB 实例之前的编译器编译指示列表。指令只能用于托管槽。 RegularExpressionParameterId 为此槽定义 STRING\/WSTRING 类型的参数。该参数的值被解释为正则表达式，并且它必须与插入的子模块的名称匹配。 各部分 Slot.Default_Allocation 和 Slot_Multi.Default_Allocation 允许定义具有可变数量元素的槽的默认设置（Multi_Slots 和 Slots）。为了 Slots.Multi_Slot 它们必须由独特的目标来识别，而 Slots.Slot 没有目标，只能有一个 Default_Allocation 部分。将根据实例在该部分中的位置添加实例。模块名称和实例名称遵循以下定义 Slot.DefaultModule 和 Slot.DefaultName 。如果此定义不可用，则设置 Default_Allocation.Module_Name 和 Default_Allocation.Instance_Name 将会被使用。推荐使用 Default_Allocation.* 用于插槽而不是 DefaultModule 和 DefaultName 仅出于兼容性原因而存在。默认模块实例的设置可以在以下小节中定义 Default_Allocation ： Module_Name 定义将自动创建实例的模块的名称。如果模块来自库，则模块名称必须使用命名空间进行限定。该参数仅允许用于类型为的槽 SUBMODULE 。 不允许无限调用，并且会产生错误消息（例如：模块“A”的声明包含默认模块“B”；模块“B”的声明包含默认模块“A”）。 Instance_Name 必须在任何时候指定 DefaultModule 已指定，并且绝不会以其他方式指定。它必须是一个有效的 IEC 标识符，用作默认模块实例的名称。名称不得以下划线开头或结尾 ( _ ）。声明的所有槽的默认名称必须是唯一的。 （区分大小写没有区别。） NotDeletable 指定用户是否可以删除该模块。如果 TRUE ，则该模块无法删除。显示错误消息。如果参数是 FALSE 或者省略，则可以删除该模块。 VisuEmbeddings ：如果 Empty 参数设置为 TRUE ，然后为此模块实例创建一个空的嵌入visus列表。如果值为 FALSE ，然后可以通过所需的嵌入式可视化列表为模块实例生成所需的嵌入式可视化列表 Embedding 小节。每个 Embedding 部分必须定义名称 VisuName 为此目的所需的嵌入式视觉，并可以指定其他属性，例如 Target 或者 LinkId 这个嵌入式视觉。 PageVisu ：在本节中可以选择模块实例的 PageVisu ( VisuName ）。此外，如果该视觉创建了一个 TopLevelTap 。参数 TopLevelTap 必须给出值 TRUE 和 FALSE 。 IOMappings : 在小节中 Mapping 可以定义I\/O通道。各部分的目标 Mapping 描述目标 I\/O 通道。默认值可以设置为 NoMapping 或到一个 STExpression 。 Parameters : 在小节中 Param 价值 Value 可以定义在该部分的目标中定义的每个参数。 多槽位 通过使用该部分 Slot_Multi 可以创建子实例和引用的列表。 SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot_Multi : <slot name> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Role := <name role>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Pragmas := <pragma list>; \/\/optional: yes, type: Pragmalist\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier>; \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC 附加规格： Var_Count 定义模块功能块的输入实例路径。该变量（Integer 类型）将保存有关连接到该插槽的实例数量的信息。 Cardinality 定义实例的最小和最大数量。 这 Slot_Multi.Default_Allocation 节可用于定义具有可变数量元素的槽的默认分配。必须通过独特的目标来识别它们。实例按部分的顺序插入。对于模块名称和实例名称，规范为 Slot.DefaultModule 或者 Slot.DefaultName 申请。默认分配的数量不得超过最高位数。 由 a 寻址的变量 Slot_Multi 部分必须是类型 POINTER TO <INTERFACE> 。 每个整数类型的输入变量可以通过以下方式寻址 Var_Count 只有一次。 （这还包括 InstRef_Multi.Var_Count 和 VarArray.Var_Count ）。 例子 SEC Slot\n SEC Slot_Multi : subs\n Variable := pSubs;\n Var_Count := uiArraySize;\n Role := TL.Role;\n Cardinality := [2 .. 17];\n Type := SUBMODULE;\n RegularExpressionParameterId := Param_RegEx_Ref;\n SEC Default_Allocation : def1\n Module_Name := Sub1;\n Instance_Name := Submodule;\n END_SEC\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC 在其他声明中，功能块的声明部分必须包含： uiArraySize: UINT; pSubs: POINTER TO ITestModule 。 在该示例中，定义了一个槽来容纳至少 2 个、但最多 17 个子实例。将为子实例创建一个数组， pSubs 指向它。添加实例时具有名称的子模块 Submodule 类型的 Sub1 将自动添加到插槽中。 " }, 
{ "title" : "部分：SourceTemplate ", 
"url" : "ac_module_fb_sec_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：SourceTemplate ", 
"snippet" : "SourceTemplate 节的小节 SourceTemplate 定义要复制到项目中的功能块。 在模块编辑器中，列出了此处定义的功能块。您可以在此处激活或停用复制。 也可以看看 源模板 SEC std.SourceTemplate SEC SourceFB : <Identifier> \/\/ optional: no SourceType := <FunctionBlock>; \/\/ optional: no, type: InstancePath Variable := <variable name>; \/\/ optional: no, type: InstancePath Defaul...", 
"body" : "SourceTemplate 节的小节 SourceTemplate 定义要复制到项目中的功能块。 在模块编辑器中，列出了此处定义的功能块。您可以在此处激活或停用复制。 也可以看看 源模板 SEC std.SourceTemplate\n SEC SourceFB : <Identifier> \/\/ optional: no\n SourceType := <FunctionBlock>; \/\/ optional: no, type: InstancePath\n Variable := <variable name>; \/\/ optional: no, type: InstancePath\n Default := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n IsMandatory := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n FBVariable := <variable name>; \/\/ optional: yes, type: InstancePath\n DestinationType := <default name>; \/\/ optional: yes, Type: String\/Literal\n END_SEC\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： 这 Identifier 在模块编辑器中使用。它定义复制的功能块的名称，如果 DestinationType 没有定义。 SourceType 定义要复制的功能块。 Variable 定义模块功能块的输入变量。它必须是指向被复制函数的基本类或接口的指针，由要复制的功能块实现。 Default 定义是否默认为此模块复制功能块。如果缺少定义， TRUE 已设置。可以在模块编辑器中调整此选项。 如果 IsMandatory 被设定为 TRUE ，用户无法更改 IsToCopy 模块编辑器中的选项。 FBVariable 定义要复制的功能块的输入变量。然后使用模块实例实例化输入变量。输入的类型是指向模块FB的基本类型的指针或指向模块FB的接口的指针。 DestinationType 为复制的功能块定义标准名称。如果缺少定义，则使用以下命名约定：<Name of the 模块实例>_<标识符>[_<连续编号>]。 将指定的 SourceTemplates 复制到 AC_SourceTemplate 文件夹。它们由分配的模块 FB 实例化和初始化。 SourceTemplates 一旦创建，就可以编辑，并且不会被更新的生成器运行覆盖。不再需要的 SourceTemplates 被重命名（使用 <_unused > 后缀）并移至 <UnusedSourceTemplates> 文件夹。 例子 SEC std.SourceTemplate\n SEC SourceFB : ID_ConnectSwitches\n SourceType := ConnectSwitches;\n Variable := itfConnect;\n FBVariable := pBuilding;\n Default := TRUE;\n IsMandatory := FALSE;\n DestinationType := 'TypeInModuleDescription';\n END_SEC\nEND_SEC " }, 
{ "title" : "部分： Visu ", 
"url" : "ac_module_fb_sec_visu.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分： Visu ", 
"snippet" : "Visu SEC Visu \/\/optional: yes, modifier: [UPDATE] Toplevel_Tab; \/\/optional: yes, type: bool Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: Vis...", 
"body" : "Visu SEC Visu \/\/optional: yes, modifier: [UPDATE]\n Toplevel_Tab; \/\/optional: yes, type: bool\n Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: VisuList\n\n SEC DefaultEmbeddings \/\/optional: yes\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier: [HIDE, UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: literal\n Target := <target name>; \/\/optional: yes, type: literal\n ProxyVisuName := <visu name>; \/\/optional: yes, type: literal\n LinkId := <linkID>; \/\/optional: yes, type: literal\n END_SEC\n END_SEC\n\n SEC Toplevel_Tab_Hotkey \/\/optional: yes\n Hotkey := <keycode>; \/\/optional: no, type: literal\n Modifiers := <modifier>; \/\/optional: yes, modifier: [SHIFT, CONTROL, ALT]\n END_SEC\n\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： Toplevel_Tab 定义复选框是否 创建顶级选项卡 默认情况下，HMI 编辑器中的激活或禁用。 Page 定义模块可用可视化对象的列表。 Embedded 定义将嵌入其他可视化屏幕中的子模块的可用可视化对象的列表。 使用占位符 %PAGE_VISU% 代替可视化名称，生成的可视化屏幕可以选择性地嵌入到其他屏幕中。 Embedded_Proxy 定义模块的可用可视化对象的列表。该列表仅在以下情况下使用： decoupled module 被插入到一个 decoupled slot 如果它不是在其父模块实例的控制器下创建的（作为代理）。 对于导入另一个模块的模块，占位符 %NONE% 可以用来代替可视化名称。这会导致导入的可视化被隐藏。这种方法适用于可视化屏幕列表以及嵌入式（代理）可视化屏幕。 部分： DefaultEmbeddings ：此部分用于默认嵌入的规范，然后它将作为预配置出现在 人机界面 子模块的选项卡（类似于“Default_Allocation”部分，请参阅 部分：老虎机 ）。所需的默认嵌入将在小节中描述 Embedding 。 要求：指定的可视化对象和代理必须在模块的可能嵌入列表中可用（参见上文： Embedded 和 Embedded_Proxy ）。 部分： Toplevel_Tab_Hotkey ：此部分将热键定义为顶层页面的默认设置。键盘快捷键不得多次使用。可以在模块编辑器中调整此设置 人机界面 标签。 例子 SEC Visu\n Toplevel_Tab ;\n Page := [VISU_CNC_Machine_1, VISU_CNC_Machine_2];\n Embedded := [%PAGE_VISU%];\n SEC DefaultEmbeddings\n SEC Embedding : No1\n VisuName := SubModule_Emb;\n Target := '..\/..\/TopLevel_2';\n END_SEC\n SEC Embedding : No2\n VisuName := SubModule_Emb_2;\n \/\/ProxyVisuName := SubModule_Emb_1;\n Target := '';\/\/ leave empty for next ancestor\n END_SEC\n END_SEC\n SEC Toplevel_Tab_Hotkey\n Hotkey := T;\n Modifiers := SHIFT | CONTROL;\n END_SEC\nEND_SEC 可视化名称是相应可视化对象的名称（不区分大小写）。可视化对象必须与模块功能块处于同一层级。 可视化对象的接口规则： 所有可视化对象和嵌入式可视化对象都可以有一个名称为 VAR_IN_OUT 的变量 inst ，它可以是模块功能块的类型或基类的类型。变量名不区分大小写。 VAR_IN_OUT   inst : <MODULE_FB> ; END_VAR 作为此处描述的 VAR_IN_OUT 选项的替代方案，还可以使用 VAR_INPUT 变量。该变量必须满足以下要求： 姓名： inst 类型：模块功能块实现的接口 嵌入式可视化对象可以有两个附加变量（变量名称不区分大小写）： VAR_INPUT paVisuFB : POINTER TO POINTER TO AC_Visu_Base ; iOwnFrameIndex : INT ; END_VAR 这些变量必须一起定义；不允许只定义一个而没有另一个。这两个变量使嵌入式可视化能够切换顶层可视化中的中心框架。 paVisuFB 是一个指针数组 AC_Visu_Base instances 。使用全局可视化变量 CURRENTCLIENTID 访问当前客户端的正确实例。帧切换由以下形式的 ST 操作执行： paVisuFB[CURRENTCLIENTID]^.uiFrameIdx := iOwnFrameIndex ; iOwnFrameIndex 是本模块的可视化图像在该顶层框架中的索引。 （如果自己的模块没有定义可视化图像，则该索引为-1。） 除了上面提到的变量之外，不允许使用其他 VAR_INPUT、VAR_OUTPUT 或 VAR_INOUT 变量。 这 AC_Visu_Base 实例提供附加功能 GetModuleFrameIndex 。此函数返回模块实例的顶级可视化中可视化屏幕（如果存在）的索引（请参阅 IModule 在 AC_Module_Base.library) 。通过此功能，您可以跳转到模块实例树中的任何可视化屏幕。为了还启用模块代码内的导航，模块的环境（请参阅 IModule 在 AC_Module_Base.library )拥有一名会员， Environment.visus ，对应于上面提到的 paVisuFB 指针。 能够使用变量 CURRENTCLIENTID ， 图书馆 VisuGlobalClientManager （类别“Intern|Visu”）必须添加到项目中。 第一个可视化将用作默认设置。 " }, 
{ "title" : "部分：Trend ", 
"url" : "ac_module_fb_sec_trend.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：Trend ", 
"snippet" : "Trend SEC tre.Trend \/\/optional: yes, modifier: [UPDATE] SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE] Task := <trend task> \/\/optional: yes, type: TimeLiteral CycleTime := <time value> \/\/optional: yes, type: TimeLiteral LimitType := <limit type> \/\/optional: yes, type...", 
"body" : "Trend SEC tre.Trend \/\/optional: yes, modifier: [UPDATE]\n SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE]\n Task := <trend task> \/\/optional: yes, type: TimeLiteral\n CycleTime := <time value> \/\/optional: yes, type: TimeLiteral\n LimitType := <limit type> \/\/optional: yes, type: FileLimitType\n LimitMaximum := <max bytes> \/\/optional: yes, type: Literal\n RecordCondition \/\/optional: yes, type: InstanceAccess\n SEC Visu \/\/optional: yes, modifier: [UPDATE]\n VisuPlaceholder \/\/optional: yes, type: StringLiteral\n VisuTemplate := <visu template> \/\/optional: yes, type: StringLiteral\n Target := <path module instance \/\/optional: yes, type: StringLiteral\n END_SEC\n END_SEC\n\n SEC TrendVariable : <variable identifier> \/\/optional: yes, modifier: [UPDATE]\n Variable := <variable name> \/\/optional: yes, type: InstanceAccess\n TrendRecording := <recording name> \/\/optional: no, type: : Id)\n Description := <tooltip> \/\/optional: yes, type: TextRef\n Color := <graph color> \/\/optional: yes, type: Literal\n GraphType := <graph type> \/\/optional: yes, type: GraphType\n LineWidth := <width> \/\/optional: yes, type: Literal\n LineStyle := <line style> \/\/optional: yes, type: LineStyle\n SEC Warning : MIN\/MAX \/\/optional: yes, modifier: [UPDATE]\n Limit := <limit value> \/\/optional: no, type: Literal\n Color := <limit color> \/\/optional: yes, type: Literal\n END_SEC\n END_SEC\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： Task ：定义趋势记录的任务。如果未定义任务，则将使用由可视趋势自动创建的任务。 CycleTime ：趋势记录的周期时间 LimitType ：记录趋势的限制类型。 LimitMaximum ：趋势记录的最大大小，以 KB 为单位（仅适用于 LimitType ==文件限制）。 RecordCondition ：记录条件。引用的变量必须是 BOOL 类型。 VisuPlaceholder ：占位符，由生成的趋势可视化替换。 VisuTemplate ：要创建的视觉模板。模板必须有占位符 Trend_Placeholder 。它可以保存具有以下标识符的控件： TrendLegend -> 类型：图例 TrendTimeRangeSelector -> 类型：时间范围选择器 TrendDateRangeSelector -> 类型：日期范围选择器 Target ：将嵌入可视化的模块实例的相对路径。 Variable ：要记录的变量。 TrendRecording ：变量所属的 TrendRecording 对象。 Description ：文本列表条目，将作为工具提示为变量显示。 Color ：变量图形的颜色，作为 ARGB 颜色代码 GraphType ：图表类型 LineWithPoints ：带点的线 Cross ： 十字架 StepWithPoints ：有积分的步骤 Point ： 积分 Lines : 线路 Step ： 脚步 LinesWithCrosses ：带十字线 \\\\ StepWithCrosses ：带有十字的台阶 LineWidth ：绘制线的宽度。值范围：1 至 255。 LineStyle ：线条样式 Solid ： 坚硬的 Dashed : 虚线 Dotted ： 点状 DashDotted : 虚线点 DashDotDotted ：点划线 Warning ：此小节必须有目标 MAX 或者 MIN 。根据目标，溢出或欠载将触发警告。 Limit ：临界范围的开始。 Color ：临界范围的颜色为 ARGB 颜色代码 例子 SEC tre.Trend\n SEC TrendRecording : TrendSensor\n SEC Visu\n VisuPlaceholder := 'TrendPlaceholder_TrendSensor';\n VisuTemplate := 'AC_Trend.GenTrend_VisuTemplate';\n END_SEC\n CycleTime := t#5s;\n LimitType := Records;\n LimitMaximum := 452;\n END_SEC\n SEC TrendVariable : Value\n Variable := value;\n TrendRecording := TrendSensor;\n Color := 16#FF00FF00;\n SEC Warning : MIN\n Limit := -5;\n Color := 16#FF101020;\n END_SEC\n GraphType := LinesWithCrosses;\n LineWidth := 3;\n END_SEC\nEND_SEC " }, 
{ "title" : "部分：代理 ", 
"url" : "ac_module_fb_sec_proxies.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：代理 ", 
"snippet" : "Proxies 这部分 Proxies 定义一个实现代理的功能块。 代理服务器用于不同应用模块之间的数据交换。代理 FB 的实例代表远程应用程序中的模块实例。 SEC Proxies \/\/optional: yes, modifier: [UPDATE] SEC Proxy : <identifier> \/\/optional: yes, modifier [UPDATE] FB := <FB name>; \/\/optional: no, type: QID SEC MirrorVar : <identifier> \/\/optional: yes, modifier [UPDATE]) Vari...", 
"body" : "Proxies 这部分 Proxies 定义一个实现代理的功能块。 代理服务器用于不同应用模块之间的数据交换。代理 FB 的实例代表远程应用程序中的模块实例。 SEC Proxies \/\/optional: yes, modifier: [UPDATE]\n SEC Proxy : <identifier> \/\/optional: yes, modifier [UPDATE]\n FB := <FB name>; \/\/optional: no, type: QID\n SEC MirrorVar : <identifier> \/\/optional: yes, modifier [UPDATE])\n Variable := <variable name>; \/\/optional: no, type: VarPath\n END_SEC\n SEC ProxyParameter : <target> \/\/ optional: yes, modifier [UPDATE]\n Variable := <InstancePath>; \/\/ optional: no, type: VarPath\n END_SEC\n END_SEC\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： 功能块必须派生自 IBaseInstance 。 功能块必须有一个方法 SetProxyIdentification 具有以下签名，该签名不包含在接口中 IBaseInstance : SetProxyIdentification(pbyName : POINTER TO BYTE, udiComAddr : UDINT, udiLocalComAddr : UDINT, pEnvironment : MEnv) 传递的实例名称和设置的地址必须从属性中返回 InstanceName , ComAddress ， 和 LocalComAddress 。 功能块不得派生自 IModule 。 这部分 MirrorVar 允许将模块实例的变量镜像到其代理实例。为此，必须在定义中声明变量的实例路径 Variable ，必须以相对（相对于模块实例 FB）路径的形式进行说明。以下规则适用于模块实例 FB 的指定变量： 该变量必须是模块实例 FB 的变量、输入或输出的一部分。 它必须在模块 FB 以及代理 FB 中定义 两个 FB 中的类型必须相同 它必须有一个原始类型；因此，不允许将指针、接口或结构作为一个整体进行镜像，而只允许简单类型（数字、字符串、时间等） 如果指定的变量满足这些条件，它们将作为 RMP 的一部分自动传输，用户无需再担心传输问题。 这部分 ProxyParameter 允许定义代理参数。应考虑以下几点： 的目标 ProxyParameter 必须对应模块的参数目标 这 variable 代理模块的变量类型必须与模块参数使用的变量类型匹配。仅允许原始类型和枚举 在相应应用程序的初始化阶段，代理参数一次性设置为模块实例中配置的值。当应用程序运行时，这些变量不会镜像到代理中 功能块的名称可以用命名空间路径限定。 例子 SEC Proxies\n SEC Proxy ProxyFB1\n FB := ProxyModule1;\n SEC MirrorVar : diInput\n Variable := diInput;\n END_SEC\n SEC ProxyParameter : InParam1\n Variable := TL.Input1_Name;\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "部分：VarArray\ns ", 
"url" : "ac_module_fb_sec_vararray.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：VarArray\ns ", 
"snippet" : "VarArrays 参数 VarArrays 允许创建具有可配置大小的数组。 SEC VarArrays \/\/optional: yes, modifier: [UPDATE]] SEC VarArray : <slot identifier> \/\/optional: yes, modifier [] Variable := <variable name>; \/\/optional: no, type: InstancePath Var_Count := <variable count>; \/\/optional: no, type: InstancePath Inst_Name := <inst...", 
"body" : "VarArrays 参数 VarArrays 允许创建具有可配置大小的数组。 SEC VarArrays \/\/optional: yes, modifier: [UPDATE]]\n SEC VarArray : <slot identifier> \/\/optional: yes, modifier []\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable count>; \/\/optional: no, type: InstancePath\n Inst_Name := <instance name>; \/\/optional: yes, type: StringLiteral\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Var_Decl_Flags := <Flag1> | <Flag2> | ... ; \/\/optional: yes, type: Flags\n END_SEC\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： 定义 Variable 是相对于模块功能块的输入实例路径。数据类型是 POINTER TO <ELEMTYPE> 。 <ELEMTYPE> 可以是任何数据类型。 一个部分的目标 VarArray 必须唯一标识变量数组。 Var_Count 定义整数的输入实例路径 Variable 模块功能块的。为了在编辑器中可用以进行配置，必须将该变量定义为参数。或者变量 Var_Count Slot_Multi 或 InstRef_Multi 可用于定义该变量。多个 VarArray 可以使用相同的 Var_Count 多变的。如果数组大小为0，则不会生成数组，并且数组的指针将设置为0。 Inst_Name 定义创建的数组变量的名称。占位符 %Instancename% 和 %VariablePath% （大小写拼写无关）将被替换为模块实例的实例名称。指针变量的实例路径。点将被下划线替代。如果省略定义则使用默认值 AC_ARRAY_%VariablePath% 。用来。 如果模块的两个不同的 VarArray 具有相同的值，则会产生错误 Inst_Name ，其中不包括占位符 %VariablePath% 。 Pragmas 包含编译器编译指示列表，它将插入到生成的数组变量之前。 Var_Decl_Flags 可用于指定创建的数组的变量类型。可能的标志是 NONE , RETAIN ， 和 PERSISTENT 。这些标志被添加到变量部分 VAR_INPUT ，其中创建了数组。 （例如：对于标志 RETAIN , VAR_INPUT RETAIN ）。 例子 SEC VAR_ARRAYS\n SEC VAR_ARRAY : NameList\n Variable := psNameList;\n Var_Count := uiArraySize;\n END_SEC\n ...\n SEC PARAM : ArraySize\n Variable := uiArraySize;\n Name := TL.ArraySize_Name;\n Desc := TL.ArraySize_Desc;\n END_SEC\nEND_SEC 在其他声明中，功能块的声明部分必须包含： uiArraySize: UINT := 7; psNameList: POINTER TO STRING; 。 " }, 
{ "title" : "部分：约束 ", 
"url" : "ac_module_fb_sec_constraints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：约束 ", 
"snippet" : "约束条件 这个特殊部分允许检查每个模块实例是否至少被引用一次。 SEC Constraints \/\/optional: yes, modifier: [UPDATE] Referenced_By := <interface name>; \/\/optional: yes, type: QID) Referenced_Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality END_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： 参数 Referenced_By 用于检查模块实例是否...", 
"body" : "约束条件 这个特殊部分允许检查每个模块实例是否至少被引用一次。 SEC Constraints \/\/optional: yes, modifier: [UPDATE]\n Referenced_By := <interface name>; \/\/optional: yes, type: QID)\n Referenced_Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： 参数 Referenced_By 用于检查模块实例是否被其他模块实例引用。的价值 ReferencedBy 必须是一个派生自的接口 IModule 。如果引用实例的类型并不重要， IModule 可以在这里指定。 Referenced_Cardinality 定义必须引用该模块的频率。如果参考数不在该范围内，则标准生成器的扫描时会产生错误。 例子 SEC Constraints\n Referenced_By := ISpecificModule;\n Referenced_Cardinality := [1 .. 3];\nEND_SEC " }, 
{ "title" : "部分：InstRefs ", 
"url" : "ac_module_fb_sec_instrefs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：InstRefs ", 
"snippet" : "研究所参考文献 这部分 InstRefs 定义对 FB 实例或结构实例的引用。 SEC InstRefs \/\/optional: yes, modifier: [UPDATE] SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: no, type: InstancePath Desc := <description>; \/\/optional: no, type: text Optional := TRUE\/...", 
"body" : "研究所参考文献 这部分 InstRefs 定义对 FB 实例或结构实例的引用。 SEC InstRefs \/\/optional: yes, modifier: [UPDATE]\n SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n...\n SEC InstRef_Multi : <identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n END_SEC\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： Inst_Ref.Variable 定义类型变量的输入实例路径 POINTER TO <T> 或类型 <interface> 。 （ <T> 是任何结构或FB类型） InstRef_Multi.Variable 定义类型的输入实例路径 POINTER TO POINTER TO <T> 或类型 POINTER TO <interface> 。 （ <T> 是任何结构或FB类型） 两个不同的 InstRef 或 InstRef-Multi 条目不得使用相同的变量。 目标必须唯一标识实例引用。这意味着不能存在两个不同的实例引用声明（部分 InstRef 和 InstRef_Multi ) 具有相同的目标（大小写拼写不相关）。 输入整型变量定义为 Var_Count 总共只能使用一次 VarCounts 的 Slot_Multi 或者 InstRef_Multi 。仅由以下定义的整型变量 Var_Count 的 VarArray 可以并行使用 Var_Counts 的 Slot_Multi 或者 InstRef_Multi 。 例子 SEC InstRef_Multi : Elements\n Variable := piElems ;\n Var_Count := uiArraySize ;\n Desc := TL.Elems_Desc ;\n Cardinality := [1 .. 10] ;\nEND_SEC 在其他声明中，功能块的声明部分必须包含： uiArraySize : UINT; piElems : POINTER TO Interface; piElems 指向全局创建的、正确初始化的 ARRAY[0..uiArraySize-1] OF interface 或者 OF POINTER TO <T> ，它指向各个实例。结果，第 i 个对象可以通过以下方式访问： piElems[i] 。 " }, 
{ "title" : "部分：mse.Sequence ", 
"url" : "ac_module_fb_sec_sequence.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：mse.Sequence ", 
"snippet" : "mse序列 本节确定序列编辑器的定义。该部分必须出现在模块声明中，以便模块编辑器提供附加选项卡 序列编辑器 。 SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE] Root := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag Step := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag Parallel := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag Branch := TRUE\/FALSE; \/\/optiona...", 
"body" : "mse序列 本节确定序列编辑器的定义。该部分必须出现在模块声明中，以便模块编辑器提供附加选项卡 序列编辑器 。 SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE]\n Root := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Step := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Parallel := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Branch := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n VisibleParams := [<visparam1>, <visparam2>,...]; \/\/optional: yes, type: ID-list\n VisibleIOs := [<visIO1>, <visIO2>,...]; \/\/optional: yes, type: ID-list\n VisibleRefs := [<visref1>, <visref2>,...]; \/\/optional: yes, type: ID-list\n AConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n BConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n OnlineActiveVar := <xActive>; \/\/optional: yes, type: ID\n OnlineBreakpointVar := <xBreakpoint>; \/\/optional: yes, type: ID\n OnlineBreakpointActiveVar := <xAvtiveBreakpoint>; \/\/optional: yes, type: ID\n OnlineWatchVars := [<variable1>, <variable2>,...]; \/\/optional: yes\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： 只有其中一种定义 Root , Step , Parallel ， 或者 Branch 对于模块可以设置为 TRUE。根据此定义，模块在序列编辑器中表示为以下序列元素之一： 根： 如果序列定义为 Root ，模块实例的编辑器提供附加选项卡 序列编辑器 。对于所有其他序列，不显示序列编辑器。可以在选项中更改框的宽度。 步： 该元素类似于 Root 元素，但不启用附加选项卡 序列编辑器 。该框用于显示和调整模块的某些属性，这些属性在其中定义 mse.Sequence 部分。 平行线： 平行序列显示为框下方有一个圆圈。该框用于显示和调整模块的某些属性，这些属性在其中定义 mse.Sequence 部分。 分支： 框下方的倾斜方块表示分支。该框用于显示和调整模块的某些属性，这些属性在其中定义 mse.Sequence 部分。 VisibleParams 定义序列元素框中可用的参数。 VisibleIOs 定义序列元素框中可用的 IO。 VisibleRefs 定义序列元素框中可用的引用。 AConnectionColor ：所分配插槽的模块实例之间的连接线以插槽的颜色绘制。 一个连接 。这可以在序列编辑器的选项中设置。 BConnectionColor ：所分配插槽的模块实例之间的连接线以插槽的颜色绘制。 B连接 。这可以在序列编辑器的选项中设置。 OnlineActiveVar ：该参数可以分配一个布尔变量，该变量必须在适当的功能块或其基本功能块之一中声明。在在线模式下，如果变量设置为 TRUE ，序列步骤显示为黄色。 OnlineBreakpointVar ：该参数可以分配一个布尔变量，该变量必须在相应的功能块或其基本功能块之一中声明。在线模式下命令 切换断点 从上下文菜单设置或重置断点。此外，它将分配的变量设置为 TRUE 或者 FALSE 如果设置为 TRUE ，序列编辑器中的步骤以红色边框显示。 OnlineBreakpointActiveVar ：该参数可以分配一个布尔变量，该变量必须在相应的功能块或其基本功能块之一中声明。在在线模式下，如果变量设置为 TRUE ，序列步骤显示为红色。 OnlineWatchVars ：定义在下面的所有变量（具有简单数据类型） VAR_INPUT , VAR_OUTPUT , VAR ， 或者 VAR_IN_OUT FB（或其基础FB）的值可以用作此处的变量。复杂变量类型（形式为 FBInst.xVariable 等）无法使用。变量应输入以逗号分隔的列表中。 例子 SEC mse.Sequence\n Branch;\n VisibleIOs := [xIn];\n AConnectionColor := [itfSequenceTrue];\n BConnectionColor := [itfSequenceFalse];\n OnlineActiveVar := xActive;\n OnlineBreakpointVar := xBreakpoint;\n OnlineBreakpointActiveVar := xBreakpointActive;\n OnlineWatchVars := [iPartTimeElapsed];\nEND_SEC " }, 
{ "title" : "部分：解耦 ", 
"url" : "ac_module_fb_sec_decoupled.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：解耦 ", 
"snippet" : "解耦 本节定义“解耦模块”。这些模块具有顶级模块的属性，但它们也可以作为子模块插入到特定的插槽中（ Type:= DECOUPLED ）其他模块。模块不能同时处于“顶层”和“解耦”状态。 “解耦模块”是使用以下部分生成的 Decoupled 在模块声明中。这部分 Decoupled 与该部分几乎相同 Toplevel ;但是，模块声明中只允许使用这些部分之一。 SEC Decoupled \/\/optional: yes, modifier: [UPDATE] GVL_Name := <GVL name>; \/\/optional: yes, type: literal Default_Appli...", 
"body" : "解耦 本节定义“解耦模块”。这些模块具有顶级模块的属性，但它们也可以作为子模块插入到特定的插槽中（ Type:= DECOUPLED ）其他模块。模块不能同时处于“顶层”和“解耦”状态。 “解耦模块”是使用以下部分生成的 Decoupled 在模块声明中。这部分 Decoupled 与该部分几乎相同 Toplevel ;但是，模块声明中只允许使用这些部分之一。 SEC Decoupled \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Toplevel_Insertable := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/optional: no, type: Text)\n Flags:= <flag>; \/\/optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC 有关定义类型语法的详细信息在模块声明一章中进行了描述。 规格：截面的规格 Decoupled 对应于该部分的描述 Toplevel 。此外，还可以定义以下参数： Toplevel_Insertable 定义“解耦子模块”是否也可以像顶级模块一样插入顶级。 注意：“解耦模块”应该定义并实现相应的代理。代理应该实现与“解耦模块”相同的接口。如果父模块实例作为“解耦”模块实例位于另一个控制器下，则“解耦”模块实例仍然可以通过其代理插入到该插槽中。 也可以看看 模块声明 部分：顶层 " }, 
{ "title" : "部分：宏模块 ", 
"url" : "ac_module_fb_sec_macromodule.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：宏模块 ", 
"snippet" : "宏模块 本节介绍宏模块的参数。该部分是在您生成宏模块时自动创建的。作为替代方案，您可以手动将该部分插入模块声明中或编辑自动生成的部分。 SEC MacroModule \/\/optional: yes, modifier: None SEC Rootmodule : <identifier> \/\/optional: no, modifier: None SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None Local_ParameterID := <parameter ID>; \/\/optional: no, type...", 
"body" : "宏模块 本节介绍宏模块的参数。该部分是在您生成宏模块时自动创建的。作为替代方案，您可以手动将该部分插入模块声明中或编辑自动生成的部分。 SEC MacroModule \/\/optional: yes, modifier: None\n SEC Rootmodule : <identifier> \/\/optional: no, modifier: None\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: no, type: text\n New_Desc := <parameter description>; \/\/optional: no, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO ID>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n SEC VisuEmbeddings \/\/optional: yes, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID>; \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <linke ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTab := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: no, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection>; \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters : <identifier> \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value ID>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Submodule : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: yes, type: text\n New_Desc := <parameter description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO Id>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n Instance_Name := <instance name>; \/\/optional: no, type: ID\n SEC VisuEmbeddings \/\/optional: no, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID> \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID> \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTap := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: yes, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression> \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection> \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Reference : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n Referenced_Instance := <instance ID>; \/\/optional: no, type: ID\n END_SEC\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 规格： MacroModule ：如果定义了该节，则整个模块声明中除该节外不允许出现其他节 MetaData 。此部分的每个模块声明都明确标识为 MacroModule 类型。另一段 MacroModule 模块声明中不允许使用。 Rootmodule ：表示以下小节描述根子模块，它应该是 1) 此类型 MacroModule 的根，2) 作为 MacroModule 类型的所有其他子模块的顶级父级插入。 Submodule ：表示以下小节描述了一个子模块，该子模块应插入到 MacroModule 类型的子树中的根子模块下。 MacroParameter ：如果在一个section中使用了这种subsection Submodule 或者 Root ，那么可以指示所定义的子模块（或根）的特定参数本身应该作为宏模块的参数出现。为此，本节的目标 MacroParameter 用作宏模块参数的新参数ID。然后给定子模块（或根）的参数定义为 Local_ParameterID 。此外，可以使用以下定义创建文本列表条目 New_Name 和 New_Desc 。这些条目用于新宏模块参数的名称和描述，而不是子模块或根参数的名称和描述。所有部分的所有定义目标 MacroParameter 整个宏模块内必须清晰，以确保所有宏模块参数的参数 ID 唯一。 MacroIO ：如果在section中使用了这种小节 Submodule 或者 Root ，则可以指示所定义的子模块（或根）的特定 I\/O 本身应该作为宏模块的 I\/O 出现。为此，本节的目标 MacroIO 用作宏模块 I\/O 的新 I\/O ID。然后给定子模块（或根）的 I\/O 定义为 Local_IOID 。此外，可以使用以下定义创建文本列表条目 New_Name 和 New_Desc 。这些条目用于新宏模块 I\/O（而不是子模块或根 I\/O）的名称和描述。所有部分的所有定义目标 MacroIO 整个宏模块内的 I\/O ID 必须清晰，以确保所有宏模块 I\/O 具有唯一的 I\/O ID。 MacroSlot ：如果本节中使用了该小节 Submodule 或者 Root ，则可以指示所定义的子模块（或根）的特定槽本身应该作为宏模块的槽出现。这样，可以将其他模块实例插入到 MacroModule 实例的该插槽下方。为此，本节的目标 MacroSlot 用作宏模块插槽的新插槽 ID。然后给定子模块（或根）的插槽定义为 Local_SlotID 。此外，可以使用定义创建文本列表条目 New_Role 。该条目用于新宏模块插槽的角色，而不是子模块或根插槽的角色。所有部分的所有定义目标 MacroSlot 整个宏模块内的内容必须清晰，以确保所有宏模块插槽的插槽 ID 唯一。 Parent_Instance : 定义一个ID对应一个section的目标ID Rootmodule 或者 Submodule 包围部分的 MacroModule 。该定义仅存在于该部分中 Submodule 。它定义了应在其下方插入子模块的父模块实例。该子模块由相应部分描述 Submodule 的宏模块。此外，定义 Parent_Slot 也是必需的。 Parent_Slot ：定义与位于由 标识的子模块类型下的插槽 ID 相对应的 ID Parent_Module 。本节描述的 MacroModule 类型的子模块 Submodule 插入此插槽下方。 Default_Allocation ：这与插槽声明下的同名部分相同（ Slot 和 Slot_Multi ）。本节为“根模块”和“子模块”定义了应为哪个实例配置插入哪种 MacroModule 类型的子模块。唯一的区别是没有 Instance_Name 可以定义为 Default_Allocation 在一个部分下 Rootmodule ，而是在部分下 Submodule 。原因是作为“根模块”插入的模块实例从 MacroModule 实例接收其名称，因此不能通过“默认”输入。 Reference ：表明以下小节描述了模块参考。模块实例下方生成引用 Parent_Instance 和插槽 Parent_Slot ，引用子模块 Referenced_Instance 。作为 Parent_Instance ，该引用的实例必须源自同一节下面的根模块实例的子模块集合 MacroModule 。 MacroModule 类型的模块声明必须满足以下条件： 不得使用 IMPLEMENTED_BY 或者 IMPORTS 在其模块声明中。 它必须包括该部分 MetaData 和 MacroModule 。否则，不得使用附加部分。 必须至少有一个 Rootmodule 下面的部分 Macro_Module 部分。而且，绝对不能有第二次 Rootmodule 部分。 对于每个 submodule ， 这俩 Parent_Instance 和 Parent_Slot 必须定义在 MacroModule 。这必须被定义为 Local_SlotID 之内 MacroSlot 的 Parent_Instance 。 " }, 
{ "title" : "部分：设备生成器 ", 
"url" : "ac_module_fb_sec_devicegenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：设备生成器 ", 
"snippet" : "设备生成器 这部分 DeviceGenerator 用于定义与设备生成器相关的所有设置。它包含以下小节： 小节： Device ：将设备添加到设备树的定义 小节： Parameter ：添加或修改设备参数的定义 小节：连接：将模块 IO 连接到设备 IO 的定义 小节： Wildcards ：创建“通配符”设备的定义。 小节： Demand ：定义“要求高”的属性。 小节： InstRefMapping ：定义将创建的设备与模块 InstRefs 连接。 有关定义类型语法的详细信息，请参阅 部分 模块声明 。...", 
"body" : "设备生成器 这部分 DeviceGenerator 用于定义与设备生成器相关的所有设置。它包含以下小节： 小节： Device ：将设备添加到设备树的定义 小节： Parameter ：添加或修改设备参数的定义 小节：连接：将模块 IO 连接到设备 IO 的定义 小节： Wildcards ：创建“通配符”设备的定义。 小节： Demand ：定义“要求高”的属性。 小节： InstRefMapping ：定义将创建的设备与模块 InstRefs 连接。 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 " }, 
{ "title" : "小节：设备 ", 
"url" : "ac_module_fb_sec_devicegenerator_device.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：设备生成器 \/ 小节：设备 ", 
"snippet" : "这 Device 小节定义了设备生成器要添加的设备。生成的设备有多种类型，它们是用不同的小节定义的 Identification , Wildcard ， 和 FlexibleWildcard 。 句法： SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC Device : <target ID> \/\/optional: yes, modifier [UPDATE] Parent := <target ID>; \/\/optional: yes, type: ID ParentSlotIndex := <slot number>...", 
"body" : "这 Device 小节定义了设备生成器要添加的设备。生成的设备有多种类型，它们是用不同的小节定义的 Identification , Wildcard ， 和 FlexibleWildcard 。 句法： SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Device : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n ParentSlotIndex := <slot number>; \/\/optional: yes, type: literal\/integer\n SEC Identification \/\/optional: yes, modifier: [UPDATE]\n Type := <type number>; \/\/optional: no, type: literal\/string\n ID := <ID mumber>; \/\/optional: no, type: literal\/string\n ModuleID := <module ID>; \/\/optional: yes, type: literal\/string\n Version := <version mumber>; \/\/optional: no, type: literal\/string\n SEC SetChildName \/\/optional: yes, modifier: [UPDATE]\n Value := <child name>; \/\/optional: no, type: literal\/string\n ChildIndex := <index number>; \/\/optional: no, type: literal\/string\n END_SEC\n END_SEC\n END_SEC\n SEC ExportDevice \/\/optional: yes, modifier: [UPDATE, HIDE]\n Files :=[<filename1>, <filename2>, ...]; \/\/optional: no, type: string\n END_SEC\nEND_SEC 规格： 这 Device 部分有一个目标 ID，可在模块的其他生成的设备中唯一标识该部分。该 ID 可用于引用该设备。这主要是在定义中完成的 Parent 其他创建的设备或连接的 I\/O。 这 Parent 定义指定要在其下安装创建的设备的所需父设备。 父设备根本无法通过其 ID 或参数来识别（定义是可选的）。 具体地，然后通过以下方式确定父设备： 如果不 Parent 完全定义后，始终使用第一个匹配的可用父级，并且对于空的 Parent 定义仅从第一个父模块开始搜索。如果直接父模块本身没有定义设备，则跟踪父模块的历史记录，直到最终有匹配的设备或到达顶层模块。在这种情况下，如果可能的话，则使用其应用装置。 另外，如果将设备 ID 或参数指定为 Parent ，以相同的方式扫描父设备的历史记录，由此输出模块本身的设备现在也被考虑在内，并且可能的父设备也必须具有相应的ID。 如果根据上述规则找不到可能的父设备，则在代检查期间输出错误。 ParentSlotIndex ：指定设备插入的父设备的插槽索引（编号）。当需要插入时这很有用。 这 Identification 小节包括要添加的设备的唯一描述。这将创建对此的唯一引用 Device 类型。 定义 Type , ID , ModuleID ， 和 Version 的 Identification 部分唯一标识特定版本的设备类型。例如，EtherCAT 主站具有以下定义： Type := '64'; ID := '000 0001'; Version := '3.5.1.0'; 如果 * 定义为版本，始终使用设备的最新版本。如果 ModuleID 如果不使用定义，则系统将搜索具有 DeviceIdentification 的设备，否则将搜索具有模块标识的设备。 如果设备存储库中不存在定义的设备，则在扫描过程中已发出相应的错误消息。 小节： SetChildName 与定义 Value 和 ChildIndex 这些选项允许您指定自动插入的设备应具有的名称。如果同一名称使用多次，则通过附加下划线和数字来使生成的名称唯一。 Value ：所需的设备名称 ChildIndex ：要重命名的自动插入设备的索引 此部分提供了在输入助手的帮助下填写字段的可能性。为此，请将光标放在行尾之后 Identification 并按 返回 。然后，输入助手将打开并提供可用的频道。选择设备后，相应的参数将传输到模块声明中。请注意，此功能仅在小节结束时可用（ END_SEC ) 尚未输入。 定义 文件 包含将添加到项目中的设备列表。这些设备是手动配置并导出到库中的。 例子 SEC Device : Buskoppler2\n SEC Identification\n Type := '65';\n ID := '2_044C2C5200110000';\n Version := '*';\n END_SEC\nEND_SEC\nSEC Device : KlemmeDigitalOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\n SEC ExportDevices\n Files := [ExtFile.BK5120_1SDO, ExtFile.BK5120_2SDO];\n END_SEC\nEND_SEC 带参数的示例 SEC std.DeviceGenerator\n SEC Device : CANopen_Manager\n Parent := CurrentCAN;\n SEC FlexibleIdentification\n Type := '16';\n ID := '181016';\n Version := '*';\n Maximum := 1;\n END_SEC\n END_SEC\nEND_SEC\nSEC std.Parameters\n SEC Param : CurrentCAN\n Name := TL.CurrentCAN_Name;\n Desc := TL.CurrentCAN_Desc;\n VariableType := wSTRING;\n Default := 'CANBus_0';\n END_SEC\nEND_SEC 定义设备名称的示例 SEC std.DeviceGenerator\n\tSEC Device : EcoVario\n\t Parent := CanManager;\n\t\tSEC Identification\n\t\t Type := '18';\n\t\t ID := '1619 0001';\n\t\t Version := '*';\n\t\t SEC SetChildName : ChildDevice\n\t\t\t Value := 'ChildName';\n\t\t\t ChildIndex := 0;\n\t\t END_SEC\n\t END_SEC\n END_SEC\n SEC Parameters : EcoVario\n\t SEC AddParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t ParameterName := 'BoolParam';\n\t \tParameterType := 'std:BOOL';\n\t\t ChildIndex := 0;\n\t END_SEC\n\t SEC SetParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t\tElemPath := '';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\t\tSEC SetParameter : bVirtual\n\t\t\tParameterID := '1040';\n\t\t\tElemPath := '';\n\t\t\tConnectorID := '0';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\tEND_SEC\n SEC InstRefMapping : Axis\n\t SEC Demand\n\t Desc := TL.DescAxis;\n\t\t\tProperties := [SM_DRIVE_CAN];\n\t\tEND_SEC\n\tEND_SEC\nEND_SEC\n " }, 
{ "title" : "小节：连接 ", 
"url" : "ac_module_fb_sec_devicegenerator_connect.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：设备生成器 \/ 小节：连接 ", 
"snippet" : "本节的这个小节 IOMapping 用于将模块 IO 与指定设备 IO 连接。这种映射是在不知道设备的确切 IO 结构的情况下完成的。对于直接连接，假设模块IO和指定设备IO兼容 SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC IOMapping : <mapping identifier> \/\/optional: yes, modifier: [UPDATE] Parent := <target ID>; \/\/optional: yes, type: ID SEC Connect \/\/optional: yes, mod...", 
"body" : "本节的这个小节 IOMapping 用于将模块 IO 与指定设备 IO 连接。这种映射是在不知道设备的确切 IO 结构的情况下完成的。对于直接连接，假设模块IO和指定设备IO兼容 SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC IOMapping : <mapping identifier> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Connect \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n END_SEC\n END_SEC\nEND_SEC 规格： 这部分 IO 有一个与将要连接的模块 IO 的目标 ID 相对应的目标。将在包含指定设备连接的模块中搜索该目标 ID。如果找不到匹配的模块 IO，则扫描期间会发出错误消息。 可选定义 Parent 给出将搜索指定设备 IO 的设备 ID (ParameterID)。直到找到为止，将连续搜索该设备的模块和父设备的历史记录。如果找不到合适的设备，则在生成检查期间会发出错误消息。 这部分 Connect 包含将模块 IO 连接到设备 IO 所需的所有定义。 ParameterID 定义IO通道 ParameterID 将连接到的设备的名称。尝试在模块本身指定的设备中查找此参数。如果未指定设备，则会尝试在下一个可能的父设备中查找该参数。然后将参数连接到模块 I\/O。如果模块层次结构中没有生成的设备提供指定的参数 ParameterID ，发出错误。 ElemPath 定义将连接到模块 I\/O 的设备参数（I\/O 通道）的子元素。还可以指定路径等。 参数 ConnectorID 可选地定义设备的连接器，其 HostParameterSet 包含 ParameterID 。如果不 ConnectorID 被指定时， ParameterID 在以下搜索 DeviceParameterSet 。 此部分提供了在输入助手的帮助下填写字段的可能性。为此，请将光标放在行尾之后 Connect 并按 返回 。然后，输入助手将打开并提供可用的频道。选择通道后，相应的参数将传输到模块声明中。请注意，此功能仅在小节结束时可用（ END_SEC ) 尚未输入。 例子 SEC IOMapping: xIn\n SEC Connect\n ParameterID := '33554434';\n ElemPath := '';\n ConnectorID := '1';\n END_SEC\nEND_SEC " }, 
{ "title" : "小节：需求 ", 
"url" : "ac_module_fb_sec_devicegenerator_demand.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：设备生成器 \/ 小节：需求 ", 
"snippet" : "本小节 IOMapping 允许模块 IO 指定属性（例如：24V 而不是 230V），这些属性应由设备 IO 提供以实现正确连接。在生成期间，可以将所需属性分配为设备 IO 的“提供”属性。该分配被存储为附加到设备描述文件中。 对于设备生成器的自动IO连接，这意味着每个具有“要求”属性的模块IO将扫描其父模块生成的设备或通配符，直到找到一个设备和IO通道，其“提供”属性满足需要 SEC IOMapping : <target> \/\/optional: yes, modifier: [UPDATE] Parent := <target ID>; \/\/optional: yes, type: I...", 
"body" : "本小节 IOMapping 允许模块 IO 指定属性（例如：24V 而不是 230V），这些属性应由设备 IO 提供以实现正确连接。在生成期间，可以将所需属性分配为设备 IO 的“提供”属性。该分配被存储为附加到设备描述文件中。 对于设备生成器的自动IO连接，这意味着每个具有“要求”属性的模块IO将扫描其父模块生成的设备或通配符，直到找到一个设备和IO通道，其“提供”属性满足需要 SEC IOMapping : <target> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n Properties := [<property1>,<property2>,...]; \/\/optional: no, type: IDList\n END_SEC\nEND_SEC 规格： 各小节 Demand 和 Connect 不能同时定义。 Desc 定义所需连接的（本地化）描述（在文本列表中）。 Properties 定义描述模块 IO 所需属性的属性列表（例如：[Input24V，数字]） 可以定义多个允许限定模块 IO 的属性（例如：仅需要“Property1”和模块的模块 IO）需要“Property1”、“Property2”等的 IO。） Parent 定义通道应连接的设备的 ID。对于“要求较高”的 IO，也允许通配符设备作为可能的连接设备。 SEC std.DeviceGenerator\n SEC IOMapping : xOn\n SEC Demand\n Desc := TL_Rooms.Role_RoomStandard_Lights;\n Properties := [V24Output];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "小节：通配符 ", 
"url" : "ac_module_fb_sec_devicegenerator_wildcard.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：设备生成器 \/ 小节：通配符 ", 
"snippet" : "这 Wildcard subsection 用于为创建模块时未知的模块创建通配符设备。然后，设备应该能够灵活地由用户在生成之前或生成期间指定。 SEC Device : <target> \/\/optional: yes, modifier [UPDATE] Parent := <target ID>; \/\/optional: yes, type: ID SEC Wildcard : <target> \/\/optional: yes, modifier: [UPDATE] Desc := <description>; \/\/optional: no, type: text END_SEC END_...", 
"body" : "这 Wildcard subsection 用于为创建模块时未知的模块创建通配符设备。然后，设备应该能够灵活地由用户在生成之前或生成期间指定。 SEC Device : <target> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Wildcard : <target> \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n END_SEC\nEND_SEC 规格： 这 Identification , Wildcard ， 和 FlexibleWildcard 各小节不能同时使用。 本节的目标 Wildcard 确定通配符设备的类型。不同的模块可以使用相同类型的通配符设备（例如：“8inputs”）。所有相同类型的通配符设备都分配给同一设备。 Desc 定义通配符设备的（本地化）描述（在文本列表中）。 Parent 定义所需的父设备。此处也可以使用通配符设备，前提是它们已分配给设备。如果为通配符设备设置的设备不是兼容的父设备，则在生成过程中会发出错误。 例子 SEC Device : KlemmeAnalogOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\nEND_SEC " }, 
{ "title" : "小节：参数 ", 
"url" : "ac_module_fb_sec_devicegenerator_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：设备生成器 \/ 小节：参数 ", 
"snippet" : "这部分 Parameter 与小节 SetParameter 和 AddParameter 用于添加或修改设备参数。这允许生成设备的特定设置（例如：循环时间）。 SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC Parameters : <parameter name> \/\/optional: yes, modifier: [UPDATE] SEC SetParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE] ParameterID := <param...", 
"body" : "这部分 Parameter 与小节 SetParameter 和 AddParameter 用于添加或修改设备参数。这允许生成设备的特定设置（例如：循环时间）。 SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Parameters : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n SEC SetParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n Value := <value name>; \/\/optional: no, type: literal\/string\n ChildIndex := <device ID>;\n Download := <boolean value> \/\/ opional: yes, type: boolean\n END_SEC\n SEC AddParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ParameterName := <parameter name>; \/\/optional: no, type: literal\/string\n ParameterType := <parameter type>; \/\/optional: no, type: literal\/string\n ChannelType := <channel type>; \/\/optional: yes, type: enum\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n ChildIndex := <device ID>;\n END_SEC\n END_SEC\nEND_SEC 规格： 这 Parameters 部分有一个目标，其中 DeviceID 定义了目标设备的参数，应编辑其参数。将首先在模块的设备中搜索目标设备，然后在其父历史记录中搜索。通配符设备或其他设备也是可能的。假设该设备具有相应的参数或者可以添加相应的参数。如果扫描无法找到目标设备，则会显示警告。 各部分的目标 SetParameter 和 AddParameter 定义相应部分的 Id，但没有进一步的用途。 截面规格 SetParameter : ParameterID 定义了 ParameterID 将要修改的设备的参数。 ElemPath 指定将更改的参数的确切元素。 参数 ConnectorID 可选地定义设备的连接器，其 HostParemeterSet 包含参数 Id。如果不 ConnectorID 被指定时， ParameterID 在 DeviceParameterSet 下搜索。 Value 定义将分配给指定参数的元素的值。该值必须与元素类型兼容。该值可以是一个表达式，例如 [paramID] + 2*MODULE_SLOT_INDEX 那里 [paramID] 定义参数的目标 ID，以便 [paramID] 将被参数值替换。这 MODULE_SLOT_INDEX 关键字被替换为已定义模块类型的模块实例在插入后将具有的槽索引。 如果在目标设备中找不到该参数，则生成器检查将发出警告。 ChildIndex 定义从属设备，在该设备下添加或设置参数。如果该具有特定索引的从属设备不存在，则在生成过程中产生警告。 Download : 可选条目。如果此条目具有值 FALSE ，则参数不会下载到设备。例如，这对于禁用 CheckVendorId 例如，对于 CAN 设备。 截面规格 AddParameter : ParameterID 定义要添加的参数的新 ID。这在目标设备的其他 ParameterID 中必须是唯一的。 参数 ConnectorID 可选地定义设备的连接器，其HostParemeterSet包含要添加的参数Id。如果未定义连接器 ID，则参数 ID 将添加到 DeviceParameterSet 中。 ParameterName 定义添加到目标设备的参数名称。 ParameterType 定义添加到目标设备的参数类型。该类型根据带有类型前缀的 IEC 类型表示法命名。因此示例： std:bool 将创建一个布尔参数。 如果无法添加参数，生成器检查将创建警告。 ChannelType 定义通道的类型。可能的值为 NONE , INPUT , OUTPUT ， 和 OUTPUTREADONLY 。 ChildIndex 定义从属设备，在该设备下添加或设置参数。如果该具有特定索引的从属设备不存在，则在生成过程中产生警告。 两个部分 AddParameter 和 SetParameter 可以一起使用来向设备添加参数并同时为其分配值。 例子 SEC Parameters : Buskoppler1\n SEC AddParameter : ExpertSettings\n ParameterID := '805306368';\n ConnectorID := '1';\n ParameterName := 'ExpertSettings';\n ParameterType := 'std:int';\n ChannelType := OUTPUT;\n END_SEC\n SEC SetParameter : ExpertSettings\n ParameterID := '805306368';\n ElemPath := '';\n ConnectorID := '1';\n Value := dwParameterOffset + 2 * MODULE_SLOT_INDEX;\n END_SEC\n END_SEC " }, 
{ "title" : "小节：InstRefMapping ", 
"url" : "ac_module_fb_sec_devicegenerator_instrefmapping.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：设备生成器 \/ 小节：InstRefMapping ", 
"snippet" : "在本节中 InstRefMapping 与小节 Demand 模块 InstRef 可以自动填充设备创建的 FB 实例。 SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE] Parent := <target ID>; \/\/optional: yes, type: ID SEC Demand \/\/optional: yes, modifier: [UPDATE] Desc := <...>; \/\/op...", 
"body" : "在本节中 InstRefMapping 与小节 Demand 模块 InstRef 可以自动填充设备创建的 FB 实例。 SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <...>; \/\/optional: no, type: text\n Properties := <...>; \/\/optional: no, type: IDList\n END_SEC\n END_SEC\nEND_SEC 规格： 顶部部分 InstRefMapping 由附加可选部分补充 Demand 。顶部部分的目标 InstRefMapping 定义模块InstRef的ID，该ID将被FB实例填充。仅支持单个 InstRef（不支持 InstRef_Multi），因为只能创建单个设备的单个 FB 实例。 Desc 定义连接的本地化描述。 Properties 定义一个属性列表，例如描述模块 InstRef 所需的 FB 类型。可以定义更多属性，以便将单个模块 InstRef 分类为模块 IO。 句法 [<Property1>, <Property2>,...] （例子： [SoftMotionVirtualDrive, Property2] ）。 Parent 定义所需设备的ID，创建的FB实例将用于填充模块InstRefs。对于要求严格的 InstRefs 通配符设备以及固定插入设备是允许的。 例子 SEC std.InstRefs\n SEC InstRef : axisRef\n Variable := axis_ref;\n Desc := TL.axisref_Desc ;\n END_SEC\nEND_SEC\n\nSEC std.DeviceGenerator\n SEC Device : virtAxis\n SEC Identification\n Type := '1024';\n ID := 'FFFF 0001';\n Version := '*';\n END_SEC\n END_SEC\n SEC InstRefMapping : axisRef\n SEC Demand\n Desc := TL.axisref_Desc;\n Properties := [VirtualAxis];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "生成器规则 ", 
"url" : "ac_module_fb_sec_devicegenerator_generating_rules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 部分：设备生成器 \/ 生成器规则 ", 
"snippet" : "设备生成规则 顶级模块中指定的设备被挂接到包含生成的应用程序的父设备下。不会创建任何顶级设备。 如果未指定父设备 ID，则使用最近匹配的父设备作为新的父对象。这意味着如果子模块生成了一个设备，如果可能的话，该设备将被添加到父模块生成的设备之一下。如果直接父模块根本没有设备或者没有生成适合子设备的设备，则使用父-父模块的设备，依此类推。如果不再有生成的父设备，则尝试生成相应顶层模块的顶层设备。如果父模块对象提供了多个设备，则将使用第一个兼容设备。 也可以看看： 小节：设备生成的设备名称为“设备ID+模块名称+设备”。如果设备已使用此名称，则会添加升序数字。 已创建的设备不会被新一代运行删除；因此...", 
"body" : "设备生成规则 顶级模块中指定的设备被挂接到包含生成的应用程序的父设备下。不会创建任何顶级设备。 如果未指定父设备 ID，则使用最近匹配的父设备作为新的父对象。这意味着如果子模块生成了一个设备，如果可能的话，该设备将被添加到父模块生成的设备之一下。如果直接父模块根本没有设备或者没有生成适合子设备的设备，则使用父-父模块的设备，依此类推。如果不再有生成的父设备，则尝试生成相应顶层模块的顶层设备。如果父模块对象提供了多个设备，则将使用第一个兼容设备。 也可以看看： 小节：设备生成的设备名称为“设备ID+模块名称+设备”。如果设备已使用此名称，则会添加升序数字。 已创建的设备不会被新一代运行删除；因此，将保留手动调整设置。 由模块声明创建的附加或修改的参数将在每次生成运行时分配给相应的设备。 与应用程序编辑器创建的所有对象一样，其他设备将在设备树中标记。如果尝试修改或删除此类设备，将会显示警告。此警告提醒您注意以下事实：如果模块结构在更改后重新生成，则对设备设置所做的任何更改都可能会丢失。 设备生成的附加规则 在某些设备下自动添加的子设备与其父设备分类在同一模块实例下。这意味着，这些子设备将被视为在模块声明中定义，而模块声明实际上保存了其父设备的定义。子设备不是独立创建或删除的，而是与其父设备一起处理。 如果设备带有显式连接器，则在对其他设备进行兼容性检查时，后者将被视为隐式连接器。换句话说，所有连接器都用于测试与其他设备的兼容性，因此最终仅使用与父设备和子设备匹配的连接器（无论是显式还是隐式）。显式作为连接器父对象，隐式作为设备父对象的一部分。 " }, 
{ "title" : "警报发生器 ", 
"url" : "ac_alarmgenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 警报发生器 ", 
"snippet" : "警报生成器为模块开发人员提供了一种简单的方法，为现有模块配备警报管理功能 CODESYS 。在此过程中，生成了完整警报管理的功能以及相应的可视化。 新模块声明（ alg.Alarm) 实现了此功能。警报管理所需的所有定义都在那里设置。 创建可视化 与警报生成一起，创建警报可视化屏幕，这是对项目中警报的概览可视化（警报表）的建议。此可视化的模板在警报生成器设置中设置。 如果可视化生成器处于活动状态，则创建或重复使用的可视化对象将作为选项卡集成到顶级可视化中。...", 
"body" : "警报生成器为模块开发人员提供了一种简单的方法，为现有模块配备警报管理功能 CODESYS 。在此过程中，生成了完整警报管理的功能以及相应的可视化。 新模块声明（ alg.Alarm) 实现了此功能。警报管理所需的所有定义都在那里设置。 创建可视化 与警报生成一起，创建警报可视化屏幕，这是对项目中警报的概览可视化（警报表）的建议。此可视化的模板在警报生成器设置中设置。 如果可视化生成器处于活动状态，则创建或重复使用的可视化对象将作为选项卡集成到顶级可视化中。 " }, 
{ "title" : "报警生成 ", 
"url" : "ac_alarmgenerator.html#UUID-dd47c9b0-4cb3-6491-d721-bbb6aed14278_a4ecc0cda058afc0a8640e004fda36_id_4e1d8099cdf16f9cc0a8640e0073d212", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 警报发生器 \/ 报警生成 ", 
"snippet" : "像所有的发电机一样 CODESYS Application Composer ，该发生器可以在 发电机配置 。 生成器执行以下步骤： 搜索报警配置对象，以便下一代使用。如果不存在警报配置对象，则创建一个新的警报配置对象。 在报警配置对象下，查找报警存储对象。如果不存在告警存储对象，则使用告警存储模板。该模板在警报生成器设置中定义。如果选项 无存储空间 选择不使用警报存储模板并且继续该过程而不存储警报。如果找到多个模板，则会显示一条错误消息。 在警报配置对象下搜索具有在定义下的任何模块描述中定义的名称的警报类对象 alg.Alarm.SetAlarm.Class 。如果找到相应的报警类对象，就会...", 
"body" : "像所有的发电机一样 CODESYS Application Composer ，该发生器可以在 发电机配置 。 生成器执行以下步骤： 搜索报警配置对象，以便下一代使用。如果不存在警报配置对象，则创建一个新的警报配置对象。 在报警配置对象下，查找报警存储对象。如果不存在告警存储对象，则使用告警存储模板。该模板在警报生成器设置中定义。如果选项 无存储空间 选择不使用警报存储模板并且继续该过程而不存储警报。如果找到多个模板，则会显示一条错误消息。 在警报配置对象下搜索具有在定义下的任何模块描述中定义的名称的警报类对象 alg.Alarm.SetAlarm.Class 。如果找到相应的报警类对象，就会使用它们。如果没有找到相应的警报类别，则会尝试创建新的警报类别。这就要求工程的POU池或者引用的库中存在相应名称的报警类模板对象作为模板，这样才能作为报警类模板使用。如果没有匹配的报警类模板对象，则会显示错误。 " }, 
{ "title" : "部分：alg.Alarm ", 
"url" : "ac_module_fb_sec_alarm.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 警报发生器 \/ 部分：alg.Alarm ", 
"snippet" : "alg.Alarm 这部分 SEC alg.Alarm 描述模块报警。模块报警本质上对应于 CODESYS 告警组中已配置的告警管理。但是，模块警报仍然包含特定于模块的添加内容。 有关更多信息，请参阅 模块声明 章节和 对象：警报组...", 
"body" : "alg.Alarm 这部分 SEC alg.Alarm 描述模块报警。模块报警本质上对应于 CODESYS 告警组中已配置的告警管理。但是，模块警报仍然包含特定于模块的添加内容。 有关更多信息，请参阅 模块声明 章节和 对象：警报组 " }, 
{ "title" : "规格 ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_355d83fb191b4801c0a864637767cb78", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 警报发生器 \/ 部分：alg.Alarm \/ 规格 ", 
"snippet" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE] SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE] Class := <class name>; \/\/optional: no, type: ID Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath Latc...", 
"body" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE]\n SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE]\n Class := <class name>; \/\/optional: no, type: ID\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath\n LatchVar2 := <LatchVariable2>; \/\/optional: yes, type: InstancePath\n Deactivation := <DeactivationVariable>; \/\/optional: yes, type: InstancePath\n PendingTime := <PendingTime>; \/\/optional: yes, type: LiteralOrConstant\n PendingTimeParameter := <string> \/\/optional: no, type: literal\/string\n HigherPrioAlarm := <HigherPrioAlarm_ID>; \/\/optional: yes, type: ID\n ModuleCalls := <ModuleCallFlags>; \/\/optional: yes, type: ModuleCallFlag\n SEC Messages : <alarm identifier> \/\/optional: yes, modifier: [UPDATE]\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n Number := <ColumnNumber>; \/\/optional: no, type: Literal\n END_SEC\n SEC LatchVar <latch var identifier> \/\/optional: yes, modifier [UPDATE]\n LatchVar := <LatchVariable>; \/\/optional: no, type: InstancePath\n Number := <LatchVarNumber> \/\/optional: no, type: LiteralOrConstant\n END_SEC\n SEC UpperLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n UpperExpression := <UpperExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC LowerLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n LowerExpression := <LowerExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC InsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC OutsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC Digital \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n Equal := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n EqualsExpression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Change \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Event \/\/optional: yes, modifier: [UPDATE]\n END_SEC\n END_SEC\nEND_SEC SEC SetAlarm 的小节 SetAlarm 定义警报所需或可能的所有属性。的目标 SetAlarm 将该报警与模块中的其他报警区分开来，并用于引用该报警（主要在定义中 HigherPrioAlarm ）。 Class 警报类名称，将在该名称下创建警报。 如果应用程序中已存在该警报类，则将在该类下创建警报。如果该类不存在，则搜索报警类模板对象，该对象必须存在于 POU 看法。如果没有找到合适的报警类模板对象，则在扫描模块时会发出错误。 Message ID（格式为 TextListenName.TextListenEintragID ) 报警文本的文本列表条目 ID 引用的消息可以包含与警报配置中的文本相同的占位符。例如占位符，例如 LATCH1 或者 LATCH2 可以使用 如果找不到指定的文本列表条目，则会在扫描期间发出警告。 对应于 信息 设置在 报警组 目的。 LatchVar1 LatchVar2 占位符变量 在当前模块特定报警的情况下，只能直接从模块功能块指定变量（就像在模块声明中为参数指定变量一样） 对应设置 锁存变量1 \/ 锁存变量2 对于占位符 <LATCH1> \/ <LATCH2> 在里面 报警组 目的。 Deactivation 失活变量（ BOOL ）。 TRUE ：停用定义的警报，其中只能使用模块功能块变量。 如果输入的变量类型不是 BOOL ，然后在扫描期间发出错误 对应于 停用 设置在 报警组 目的。 PendingTime 最短的等待时间。定义达到极限后警报实际响起之前的时间量。 例子： TIME#5S 对应设定 分钟。等待时间 在里面 报警组 目的。 PendingTimeParameter 设置最小挂起时间的参数 分配给参数的值是一个可以解释为时间的字符串。或者也可以作为由模块参数和时间文字组成的表达式。 例子： TIME#5S 'NoVar' 'WithVar' 'WithVar - NoVar + TIME#5S' HigherPrioAlarm 高优先级告警ID 为了识别当前警报应该被分类到的警报，一个警报的目标ID SetAlarm 部分是为现有模块警报指定的。为了找到 SetAlarm 具有相应目标 ID 的部分，在父模块实例中从自身模块向上执行分层搜索，以在警报声明中匹配 ID。如果没有找到相应的父报警，则在发电机检查期间会发出错误 对应设定 优先级更高。警报 在里面 报警组 目的。 ModuleCalls 对于特定于模块的报警管理，模块 FB 可以提供特定的接口，在发生模块报警时可以调用这些接口。这些标志定义了在什么情况下会发生这种情况。 可用的 ModuleCallFlags : NONE : 不会发生任何呼叫 THIS ：调用当前模块的报警 PARENTS ：当前模块的所有父模块都会发生调用 ALL ：所有模块都会发生调用 将由该标志调用的模块 FB 必须实现 IModuleAlarming 界面。该调用由 ConsumeModuleAlarm 该接口的功能 如果 PARENTS 为顶级模块设置了标志，如果执行扫描，则会显示警告（因为顶级模块不存在此标志）。 SEC Messages 该小节管理与 Message 参数，但允许一个警报有多个消息。出于兼容性原因，（旧）参数 Message 仍然有效。该消息可以包含与警报配置中的实际文本相同的占位符。这意味着也可以使用占位符，例如 <LATCH1> 和 <LATCH2> 可以使用。如果找不到指定的文本列表条目，则会在扫描期间发出警告。 Messages ：文本列表条目形式的报警文本（形式为 TextListenName.TextListenEintragID ） Number ：报警表中显示消息的列。 SEC LatchVar 锁存变量。此部分最多可以定义 10 个锁存变量。 如果除了本节之外， LatchVar1 或者 LatchVar2 定义后，将使用本节的变量。 LatchVar ：锁存变量 Number ：标识锁存变量的数字。 SEC UpperLimit SEC LowerLimit 超出上限或下限时触发的警报的警报条件。 该部分仅允许在以下出现一次 SEC SetAlarm 部分。如果不是这种情况，扫描期间会发出错误。 Expression ：被测试的IEC表达式或值。在表达式中，可以使用模块 FB 的局部变量以及全局常量。 IncludeBorder : TRUE 对应于 <= （ UpperLimit ） 或者 >= （ LowerLimit ）。 FALSE 对应于 < （ UpperLimit ） 或者 > （ LowerLimit ）。 UpperExpresssion , LowerExpresssion ： IEC 表达式或值 表达 经测试。在表达式中，可以使用模块 FB 的局部变量以及全局常量。 Hysteresis ：报警滞后百分比。 对应设置 上限 \/ 下限 对于观察类型 报警组 目的。 SEC InsideRange SEC OutsideRange 如果表达式位于特定值范围内或之外，则触发警报的警报条件。 该部分仅允许在以下出现一次 SEC SetAlarm 部分。如果不是这种情况，扫描期间会发出错误。 Hysteresis ：报警滞后百分比 Expression ：被测试的IEC表达式或值。在表达式中，可以使用模块 FB 的局部变量以及全局常量。 AreaLow ：范围下限（值或 IEC 表达式）。在表达式中，可以使用模块 FB 的局部变量以及全局常量。 LowIncludeBorder ：该布尔标志决定下限本身是否包含在比较范围内（对应于 <= ） HighIncludeBorder ：这个布尔标志决定上限本身是否包含在比较范围内（对应于 >= ） AreaHigh ：范围上限（值或 IEC 表达式）。在表达式中，可以使用模块 FB 的局部变量以及全局常量。 对应设置 范围内 \/ 范围外 对于观察类型 报警组 目的。 SEC Digital 如果两个表达式相互比较，则会引发警报。 该部分仅允许在以下出现一次 SEC SetAlarm 部分。如果不是这种情况，扫描期间会发出错误。 Expression ：被测试的IEC表达式或值。在表达式中，可以使用模块 FB 的局部变量以及全局常量。 Equal : TRUE \/ FALSE ：将检查表达式是否相等\/不相等。 EqualsExpression ：检查的 IEC 表达式或值 Expression 。在表达式中，可以使用模块 FB 的局部变量以及全局常量。 对应观察类型 数字的 在里面 报警组 目的。 SEC Change 如果表达式更改其值，则会引发警报。 该部分仅允许在以下出现一次 SEC SetAlarm 部分。如果不是这种情况，扫描期间会发出错误。 Expression ：检查更改的 IEC 表达式或值。在表达式中，可以使用模块 FB 的局部变量以及全局常量。 对应观察类型 改变 在里面 报警组 目的。 SEC Event 确定当前报警部分创建事件报警。该警报可以通过以下功能触发 RaiseModuleEvent() 来自 AC_Alarming 图书馆。 " }, 
{ "title" : "例子 ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_00a4549e191b4801c0a8646366566922", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 警报发生器 \/ 部分：alg.Alarm \/ 例子 ", 
"snippet" : "取值范围 SEC SetAlarm : ValueRange Class := Error; Message := TL.Alarm_Temperature; LatchVar1 := rAlarmValueLow; LatchVar2 := rAlarmValueHigh; ModuleCalls := THIS | PARENTS; SEC Messages : msg2 Message := TL.msg5_Message; Number := 5; END_SEC SEC OutsideRange Expression := 'rValue'; AreaLow := 'rAlarmVa...", 
"body" : "取值范围 SEC SetAlarm : ValueRange\n Class := Error;\n Message := TL.Alarm_Temperature;\n LatchVar1 := rAlarmValueLow;\n LatchVar2 := rAlarmValueHigh;\n ModuleCalls := THIS | PARENTS;\n SEC Messages : msg2\n Message := TL.msg5_Message;\n Number := 5;\n END_SEC\n SEC OutsideRange\n Expression := 'rValue';\n AreaLow := 'rAlarmValueLow';\n LowIncludeBorder := TRUE;\n HighIncludeBorder := TRUE;\n AreaHigh := 'rAlarmValueHigh';\n END_SEC\nEND_SEC 部分： PendingTime SEC alg.Alarm\n\tSEC SetAlarm : NoVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'NoVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : WithVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : SimpleMath\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar - NoVar + TIME#5S';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\t\n\tSEC SetAlarm : NoParam\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTime := TIME#5S;\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\nEND_SEC " }, 
{ "title" : "氟氯化碳发生器 ", 
"url" : "ac_cfc_generator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 氟氯化碳发生器 ", 
"snippet" : "CFC 生成器自动创建可包含模块 FB 实例调用的 CFC 程序。可以编辑创建的CFC程序。重复运行生成器后，程序更改仍然存在。...", 
"body" : "CFC 生成器自动创建可包含模块 FB 实例调用的 CFC 程序。可以编辑创建的CFC程序。重复运行生成器后，程序更改仍然存在。 " }, 
{ "title" : "部分：CFCCreation ", 
"url" : "ac_module_fb_sec_cfccreation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 氟氯化碳发生器 \/ 部分：CFCCreation ", 
"snippet" : "CFCCreation 本节包含由 CFC 生成器解释的所有小节。 SEC cfc.CFCCreation SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE] StandardCallTask := <Task type>; \/\/optional: yes, type: ID CustomCallTask := <Task type>; \/\/optional: yes, type: ID ParentFolder := <create folder ID; \/\/optional: ...", 
"body" : "CFCCreation 本节包含由 CFC 生成器解释的所有小节。 SEC cfc.CFCCreation\n\n SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE]\n StandardCallTask := <Task type>; \/\/optional: yes, type: ID\n CustomCallTask := <Task type>; \/\/optional: yes, type: ID\n ParentFolder := <create folder ID; \/\/optional: yes, type: ID\n END_SEC\n\n SEC CreateCFCModuleCall \/\/optional: yes, modifier [UPDATE]\n PreferredCFCProgram := <CFC program> \/\/optional: yes; type: FB type\n END_SEC\n\n SEC CreateCFCIOCall : <CFC IO call ID> \/\/ optional: yes; modifier [UPDATE]\n FB := <FB name>; \/\/ optional: no; type: FB type\n PreferredCFCProgram := <CFC program> \/\/ optional: yes; type: FB type\n FBInstanceBaseName := AInput; \/\/ optional: yes; type: identifier\n END_SEC\n\n SEC CreateFolder : <folder ID> \/\/optional: yes, modifier [UPDATE]\n ParentFolder := <folder name>; \/\/optional: yes, type: ID\n END_SEC\n\nEND_SEC 有关定义类型语法的详细信息，请参阅 部分 模块声明 。 " }, 
{ "title" : "小节：CreateCFCProgram ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_bddcc1eb1403f77cc0a8640e01907eda", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 氟氯化碳发生器 \/ 部分：CFCCreation \/ 小节：CreateCFCProgram ", 
"snippet" : "如果模块声明包含一个节 cfc.CFCCreation 包括本小节 CreateCFCProgram ，将为指定的模块类型创建一个 CFC 程序。 CFC 程序将插入到下一个更高顶级\/解耦父模块实例的目标应用程序下方。定义 CustomCallTask 或者 StandardCallTask 可用于定义调用要创建的 CFC 程序的任务。 规格： 本节的目标 CreateCFCProgram 标识该模块类型的 CFC 程序。基本上，模块类型可以为其模块实例定义和创建多个 CFC 程序。 的定义 StandardCallTask 或者 CustomCallTask 必须存在，但只允许有一个定义。 ...", 
"body" : "如果模块声明包含一个节 cfc.CFCCreation 包括本小节 CreateCFCProgram ，将为指定的模块类型创建一个 CFC 程序。 CFC 程序将插入到下一个更高顶级\/解耦父模块实例的目标应用程序下方。定义 CustomCallTask 或者 StandardCallTask 可用于定义调用要创建的 CFC 程序的任务。 规格： 本节的目标 CreateCFCProgram 标识该模块类型的 CFC 程序。基本上，模块类型可以为其模块实例定义和创建多个 CFC 程序。 的定义 StandardCallTask 或者 CustomCallTask 必须存在，但只允许有一个定义。 为了 StandardCallTask 三个ID LOW , MEDIUM ， 和 HIGH 可用于定义下一个更高顶级\/解耦父模块实例的任务。 为了 CustomCallTask 所有目标 ID 均可用，可用于下一个更高顶级\/解耦父模块实例的相应自定义任务。 在 ParentFolder 的目标 ID CreateFolder 可以进入部分。然后将创建的 CFC 程序添加到该子子文件夹中（ CreateFolder ）。 " }, 
{ "title" : "小节：CreateCFCModuleCall ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_4225fb301403f77dc0a8640e01bbc228", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 氟氯化碳发生器 \/ 部分：CFCCreation \/ 小节：CreateCFCModuleCall ", 
"snippet" : "如果模块声明包含一个节 cfc.CFCCreation 包括本小节 CreateCFCProgram ，将为下一个更高父模块实例的 CFC 程序中分配的模块类型创建模块实例 FB 的调用。 规格： PreferredCFCProgram 定义当有多个程序可用时要使用的 CFC 程序。...", 
"body" : "如果模块声明包含一个节 cfc.CFCCreation 包括本小节 CreateCFCProgram ，将为下一个更高父模块实例的 CFC 程序中分配的模块类型创建模块实例 FB 的调用。 规格： PreferredCFCProgram 定义当有多个程序可用时要使用的 CFC 程序。 " }, 
{ "title" : "小节：CreateCFCIOCall ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_72ec1fc41403f77ec0a8640e00114156", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 氟氯化碳发生器 \/ 部分：CFCCreation \/ 小节：CreateCFCIOCall ", 
"snippet" : "该部分用于标记模块类型或模块声明的 I\/O。对于这些 I\/O，将创建已定义类型的 FB 实例。然后在 CFC 程序中创建对这些 FB 实例的调用。 规格： 的目标 CreateCFCIOCall 部分定义将为其创建全局 I\/O FB 的模块 I\/O ID。创建的 I\/O FB 将在 CFC 程序中调用。 FB 定义全局实例化并为上述 I\/O FB 调用的功能块类型。 PreferredCFCProgram 定义当有多个程序可用时要使用的 CFC 程序。 FBInstanceBaseName 定义一个“基本名称”，用于命名所创建的 I\/O FB。如果定义不存在，则模块实例的名称将用作基本实例。...", 
"body" : "该部分用于标记模块类型或模块声明的 I\/O。对于这些 I\/O，将创建已定义类型的 FB 实例。然后在 CFC 程序中创建对这些 FB 实例的调用。 规格： 的目标 CreateCFCIOCall 部分定义将为其创建全局 I\/O FB 的模块 I\/O ID。创建的 I\/O FB 将在 CFC 程序中调用。 FB 定义全局实例化并为上述 I\/O FB 调用的功能块类型。 PreferredCFCProgram 定义当有多个程序可用时要使用的 CFC 程序。 FBInstanceBaseName 定义一个“基本名称”，用于命名所创建的 I\/O FB。如果定义不存在，则模块实例的名称将用作基本实例。 " }, 
{ "title" : "小节：创建文件夹 ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_a2dd1e181403f77ec0a8640e013c4468", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 模块声明 \/ 氟氯化碳发生器 \/ 部分：CFCCreation \/ 小节：创建文件夹 ", 
"snippet" : "此部分包含用于在下面创建子文件夹的参数 AC_CFC_Programs 文件夹。对应这个a ParentFolder 可以定义在 CreateCFCProgram 部分。然后在创建的目录中生成 CFC 程序 CreateFolder 部分。文件夹本身可以定义一个 ParentFolder 指定更多子文件夹和子子文件夹。 规格： 在 ParentFolder 的目标 ID CreateFolder 可以进入部分。然后创建的目录将在该子文件夹中创建（ CreateFolder ）。 例子 SEC cfc.CFCCreation SEC CreateCFCProgram : Standard Sta...", 
"body" : "此部分包含用于在下面创建子文件夹的参数 AC_CFC_Programs 文件夹。对应这个a ParentFolder 可以定义在 CreateCFCProgram 部分。然后在创建的目录中生成 CFC 程序 CreateFolder 部分。文件夹本身可以定义一个 ParentFolder 指定更多子文件夹和子子文件夹。 规格： 在 ParentFolder 的目标 ID CreateFolder 可以进入部分。然后创建的目录将在该子文件夹中创建（ CreateFolder ）。 例子 SEC cfc.CFCCreation\n SEC CreateCFCProgram : Standard\n StandardCallTask := MEDIUM;\n ParentFolder := SubFolderUnderFolder;\n END_SEC\n SEC CreateFolder : SubFolderUnderFolder\n ParentFolder := SubFolder;\n END_SEC\nEND_SEC " }, 
{ "title" : "库：AC_ModuleBase ", 
"url" : "ac_library.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase ", 
"snippet" : "模块基础库AC_ModuleBase是模块概念的一部分 CODESYS Application Composer 。开发为可在模块树配置器中使用的所有模块都必须从此基本库派生。 导航至顶层 功能 GetToplevelRange 返回一个范围实例（类型 SiblingRange ）它提供对所有顶级实例的访问。功能 GetToplevelInstance 返回作为给定实例的祖先的顶级模块。...", 
"body" : "模块基础库AC_ModuleBase是模块概念的一部分 CODESYS Application Composer 。开发为可在模块树配置器中使用的所有模块都必须从此基本库派生。 导航至顶层 功能 GetToplevelRange 返回一个范围实例（类型 SiblingRange ）它提供对所有顶级实例的访问。功能 GetToplevelInstance 返回作为给定实例的祖先的顶级模块。 " }, 
{ "title" : "实例名称 ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f44958df1c1aa580c0a8640e00033aeb", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ 实例名称 ", 
"snippet" : "该物业 InstanceName 基类的返回一个包含模块实例名称的字符串。 财产在 IInstanceBase : PROPERTY InstanceName : STRING(255) 返回值：模块实例的实例名称 代理实例返回远程模块实例的实例名称。...", 
"body" : "该物业 InstanceName 基类的返回一个包含模块实例名称的字符串。 财产在 IInstanceBase : PROPERTY InstanceName : STRING(255) 返回值：模块实例的实例名称 代理实例返回远程模块实例的实例名称。 " }, 
{ "title" : "模块信息 ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_a581c7b51c1aa580c0a8640e012cbe1e", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ 模块信息 ", 
"snippet" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo ：该属性返回一个指向带有方法的 ModuleInfo 功能块的指针 PROPERTY ModuleType : STRING(255) 。 PROPERTY ModuleType : STRING(255) ：此属性返回由模块库的名称空间限定的模块名称。 （名称空间与主项目相关。）...", 
"body" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo ：该属性返回一个指向带有方法的 ModuleInfo 功能块的指针 PROPERTY ModuleType : STRING(255) 。 PROPERTY ModuleType : STRING(255) ：此属性返回由模块库的名称空间限定的模块名称。 （名称空间与主项目相关。） " }, 
{ "title" : "实例路径 ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_247de8bc1c1aa581c0a8640e00b26998", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ 实例路径 ", 
"snippet" : "功能 GetInstancePath(IModule) 返回模块实例的实例路径。实例路径是通过连接所有祖先的实例名称来构建的，从顶层模块开始一直到给定的实例。实例名称由点分隔。如果生成的实例名称超过 255 个字符，则返回空字符串。 PROPERTY InstancePath : STRING(255)...", 
"body" : "功能 GetInstancePath(IModule) 返回模块实例的实例路径。实例路径是通过连接所有祖先的实例名称来构建的，从顶层模块开始一直到给定的实例。实例名称由点分隔。如果生成的实例名称超过 255 个字符，则返回空字符串。 PROPERTY InstancePath : STRING(255) " }, 
{ "title" : "平面导航 ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_acbf32a81c1aa581c0a8640e0039f1c2", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ 平面导航 ", 
"snippet" : "功能 GetPrevModule(IModule) 和 GetNextModule(IModule) 允许跳转到上一个或下一个元素（如果模块树被视为模块实例的平面列表）。模块按模块树的深度优先预序返回。如果没有上一个或下一个模块，则跳过模块引用。 或者功能块 DepthFirstRange 可以使用它列出从特定实例开始的所有实例。功能 GetDepthFirstRange 返回范围函数块实例（类型为 DepthFirstRange ）它列出了从给定实例开始的完整树。...", 
"body" : "功能 GetPrevModule(IModule) 和 GetNextModule(IModule) 允许跳转到上一个或下一个元素（如果模块树被视为模块实例的平面列表）。模块按模块树的深度优先预序返回。如果没有上一个或下一个模块，则跳过模块引用。 或者功能块 DepthFirstRange 可以使用它列出从特定实例开始的所有实例。功能 GetDepthFirstRange 返回范围函数块实例（类型为 DepthFirstRange ）它列出了从给定实例开始的完整树。 " }, 
{ "title" : "分层导航 ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_1e4f5ff21c1aa58ec0a8640e0059614e", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ 分层导航 ", 
"snippet" : "界面 IModuleTree 允许在模块树中导航。通过使用指向类型实例的指针，向每个模块提供此接口的对象 MEnv 。这个指针被传递给函数 SetIdentification 。导航中会跳过模块引用。子节点的顺序对应于模块树中模块实例的顺序。 GetParent(itfM : IModule) : IModule : IModule: 返回给定模块实例的父实例。对于顶级模块实例，返回值为 0。 GetFirstChild(itfM : IModule) : IModule ：返回给定模块实例的第一个子级。对于没有子级的模块实例，返回值为 0 NextSibling(itfM : IModule...", 
"body" : "界面 IModuleTree 允许在模块树中导航。通过使用指向类型实例的指针，向每个模块提供此接口的对象 MEnv 。这个指针被传递给函数 SetIdentification 。导航中会跳过模块引用。子节点的顺序对应于模块树中模块实例的顺序。 GetParent(itfM : IModule) : IModule : IModule: 返回给定模块实例的父实例。对于顶级模块实例，返回值为 0。 GetFirstChild(itfM : IModule) : IModule ：返回给定模块实例的第一个子级。对于没有子级的模块实例，返回值为 0 NextSibling(itfM : IModule) : IModule ：返回模块实例的下一个同级。对于没有其他同级的模块实例，它返回 0。也可以为顶级实例调用它。 PrevSibling(itfM : IModule) : IModule ：返回模块实例的前一个同级。对于没有先前兄弟的模块实例，它返回 0。它也可以为顶级实例调用。 GetFirstToplevelInstance() : IModule ：返回树的第一个顶级实例。如果树为空，则返回 0。 " }, 
{ "title" : "导航至祖先、兄弟姐妹和孩子 ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f30cbdfc1c1aa58fc0a8640e0098179e", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ 导航至祖先、兄弟姐妹和孩子 ", 
"snippet" : "功能块 AncestorRange 允许访问实例的所有祖先，从实例本身开始。功能块 SiblingRange 允许访问模块树中实例的所有后续同级实例，从实例本身开始。功能 GetChildRange 返回一个范围元素（类型 SiblingRange ) 实例的所有子级。...", 
"body" : "功能块 AncestorRange 允许访问实例的所有祖先，从实例本身开始。功能块 SiblingRange 允许访问模块树中实例的所有后续同级实例，从实例本身开始。功能 GetChildRange 返回一个范围元素（类型 SiblingRange ) 实例的所有子级。 " }, 
{ "title" : "可靠消息协议 (RMP) ", 
"url" : "ac_reliable_message_protocol.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ 可靠消息协议 (RMP) ", 
"snippet" : "可靠消息协议用于将消息从一个模块实例发送到另一个模块实例。这种通信可以在应用程序之间进行。因此，为每个应用程序创建一个 RMP 处理程序实例。 寻址规范： 每个合作伙伴都拥有一个唯一的 32 位 ID，其中包含一个用于应用程序 ID 的高位字（位 16-31）和一个用于本地 ID 的低位字（位 0-15）。 每个 ID（32 位）必须是唯一的 - ID 的单个字（低位字或高位字）可以多次使用。 调用实例的应用程序的ID 必须定义在实例的高位字中。 变量的命名约定： udi<xxx>ID ：模块的完整ID，由应用程序ID和本地模块ID组成 ui<xxx>AppID ：应用ID（16位），完整ID...", 
"body" : "可靠消息协议用于将消息从一个模块实例发送到另一个模块实例。这种通信可以在应用程序之间进行。因此，为每个应用程序创建一个 RMP 处理程序实例。 寻址规范： 每个合作伙伴都拥有一个唯一的 32 位 ID，其中包含一个用于应用程序 ID 的高位字（位 16-31）和一个用于本地 ID 的低位字（位 0-15）。 每个 ID（32 位）必须是唯一的 - ID 的单个字（低位字或高位字）可以多次使用。 调用实例的应用程序的ID 必须定义在实例的高位字中。 变量的命名约定： udi<xxx>ID ：模块的完整ID，由应用程序ID和本地模块ID组成 ui<xxx>AppID ：应用ID（16位），完整ID的高位字 ui<xxx>ModuleID ：本地模块ID（16位），完整ID的低位字 " }, 
{ "title" : "IRMPService ", 
"url" : "ac_rmp_irmpservice.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ IRMPService ", 
"snippet" : "接口的方法和属性 IRMPService 。 属性：LocalAppID PROPERTY LocalAppID : UINT (get) 该属性描述本地应用程序的地址。 （该应用程序的模块实例的通信ID的高位字。）...", 
"body" : "接口的方法和属性 IRMPService 。 属性：LocalAppID PROPERTY LocalAppID : UINT (get) 该属性描述本地应用程序的地址。 （该应用程序的模块实例的通信ID的高位字。） " }, 
{ "title" : "方法：IsMessageSent ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_538e8d066de1851ec0a8652001725d6d", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ IRMPService \/ 方法：IsMessageSent ", 
"snippet" : "METHOD IsMessageSent : BOOL VAR_INPUT uiHandle: UINT; END_VAR 此方法检查是否已排队的消息 QueueSendMessage 已发送并确认。 uiHandle 是返回的句柄 QueueSendMessage 。为此，请检查功能块的使用 RMP发送消息 推荐使用，因为它提供了标准化的命令接口。...", 
"body" : "METHOD IsMessageSent : BOOL\nVAR_INPUT\n uiHandle: UINT;\nEND_VAR 此方法检查是否已排队的消息 QueueSendMessage 已发送并确认。 uiHandle 是返回的句柄 QueueSendMessage 。为此，请检查功能块的使用 RMP发送消息 推荐使用，因为它提供了标准化的命令接口。 " }, 
{ "title" : "方法：QueueSendMessage ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_b6b7ed9d6de18513c0a8652000b31074", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ IRMPService \/ 方法：QueueSendMessage ", 
"snippet" : "METHOD QueueSendMessage : UINT VAR_INPUT udiSenderID: UDINT; udiReceiverID: UDINT; tValidity: TIME; pmdData: POINTER TO ARRAY[0..63] OF BYTE; END_VAR 此方法将要发送的消息添加到发送队列中并返回句柄。该句柄可用于检查传输是否成功。 返回值为 16#FFFF 表示缓冲区已满，消息未发送。返回值为 16#FFFE 表明接收模块在同一个应用中，并且传输成功。 使用功能块将消息添加到发送队列 RMP发送消息 推荐使用，因为它提供了标准化的命令接口。...", 
"body" : "METHOD QueueSendMessage : UINT\nVAR_INPUT\n udiSenderID: UDINT;\n udiReceiverID: UDINT;\n tValidity: TIME;\n pmdData: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR 此方法将要发送的消息添加到发送队列中并返回句柄。该句柄可用于检查传输是否成功。 返回值为 16#FFFF 表示缓冲区已满，消息未发送。返回值为 16#FFFE 表明接收模块在同一个应用中，并且传输成功。 使用功能块将消息添加到发送队列 RMP发送消息 推荐使用，因为它提供了标准化的命令接口。 " }, 
{ "title" : "方式：Receive ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_385683a56de1850cc0a8652000d330da", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ IRMPService \/ 方式：Receive ", 
"snippet" : "METHOD Receive : UDINT VAR_INPUT uiReceiverModuleID: UINT; pmd: POINTER TO ARRAY[0..63] OF BYTE; END_VAR 每个能够接收消息的模块都会调用此方法。它采用最早收到的消息 uiReceiverID 并承认这一点。如果消息不可用，则 16#FFFFFFFF 被返回。它返回 16#FFFFFFFE 是否至少有一条消息在等待接收者，是否最旧的消息当前被另一任务锁定。在所有其他情况下，都会返回发送者的通信地址。...", 
"body" : "METHOD Receive : UDINT\nVAR_INPUT\n uiReceiverModuleID: UINT;\n pmd: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR 每个能够接收消息的模块都会调用此方法。它采用最早收到的消息 uiReceiverID 并承认这一点。如果消息不可用，则 16#FFFFFFFF 被返回。它返回 16#FFFFFFFE 是否至少有一条消息在等待接收者，是否最旧的消息当前被另一任务锁定。在所有其他情况下，都会返回发送者的通信地址。 " }, 
{ "title" : "RMPSendMessage ", 
"url" : "ac_rmp_sendmessage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ RMPSendMessage ", 
"snippet" : "该功能块用于向任何模块实例发送消息。实例的地址必须已知。 变量的行为 xExecute , xDone , xBusy ， 和 xError 符合《图书馆设计指南》。本文档是 CODESYS 标准安装。...", 
"body" : "该功能块用于向任何模块实例发送消息。实例的地址必须已知。 变量的行为 xExecute , xDone , xBusy ， 和 xError 符合《图书馆设计指南》。本文档是 CODESYS 标准安装。 " }, 
{ "title" : "FUNCTION_BLOCK：RMPSendMessage ", 
"url" : "ac_rmp_sendmessage.html#UUID-2d1f2b05-610c-bf06-e2fe-18d7e3819bbc_ac_rmp_sendmessage0", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ RMPSendMessage \/ FUNCTION_BLOCK：RMPSendMessage ", 
"snippet" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG VAR_IN_OUT mdData: ARRAY[0..63] OF BYTE; END_VAR VAR_INPUT itfrmp: IRMPService; xExecute: BOOL; udiReceiverID: UDINT; uiSenderModuleID: UINT; tValidity: TIME := t#1s; END_VAR VAR_OUTPUT xDone: BOOL; xBusy: BOOL; xError: BOOL; uiErrorID: UINT; END_VAR 请...", 
"body" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG\nVAR_IN_OUT\n mdData: ARRAY[0..63] OF BYTE;\nEND_VAR\nVAR_INPUT\n itfrmp: IRMPService;\n xExecute: BOOL;\n udiReceiverID: UDINT;\n uiSenderModuleID: UINT;\n tValidity: TIME := t#1s;\nEND_VAR\nVAR_OUTPUT\n xDone: BOOL;\n xBusy: BOOL;\n xError: BOOL;\n uiErrorID: UINT;\nEND_VAR 请注意，一旦对方的RMPService 中消息的接收被确认，该功能块的工作就成功完成。这并不一定意味着消息已经到达实际的接收器模块接口。 在 mdData ，将传输要发送的数据。 udiReceiverID 定义接收者的ID。 rmp 定义本地 RMPService 实例。 tValidity 定义消息的有效期。检查以下事项： 消息发送之前的持续时间不得超过 tValidity （否则将创建错误消息）。 消息被对方接收者收到的持续时间，不得超过 tValidity （否则该消息将被删除）。 可能会出现以下错误并会返回 uiErrorID : 发送缓冲区已满；建议稍后再发送。 该消息不会从发送缓冲区中删除。原因可能是传输缓慢、连接中断或对方的接收缓冲区已满。 消息发送到的应用程序未连接到该应用程序。在这种情况下，不可能传输数据。 " }, 
{ "title" : "调试 ", 
"url" : "ac_rmp_debugging.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 模块声明编辑器 \/ 库：AC_ModuleBase \/ 调试 ", 
"snippet" : "全局变量 g_AC_RMP_xDiagLog 可用于启用日志记录机制。该机制记录所有发送事件和接收事件，并将消息的创建和删除记录到标准日志的队列中。 此外，所有意外事件和错误都会写入标准日志。...", 
"body" : "全局变量 g_AC_RMP_xDiagLog 可用于启用日志记录机制。该机制记录所有发送事件和接收事件，并将消息的创建和删除记录到标准日志的队列中。 此外，所有意外事件和错误都会写入标准日志。 " }
]
$(document).trigger('search.ready');
});