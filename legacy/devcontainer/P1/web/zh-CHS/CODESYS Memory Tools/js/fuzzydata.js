$(document).ready(function () {indexDict['zh-CHS'] = [{ "title" : "CODESYS Memory Tools ", 
"url" : "_memtools_f_codesys_memory_tools.html", 
"breadcrumbs" : "CODESYS Memory Tools \/ CODESYS Memory Tools ", 
"snippet" : "这 CODESYS Memory Tools 提供显示应用程序当前控制器内存的功能 CODESYS , 以及对于 CODESYS Memory Tools -定义的内存一致性检查。 你可以下载 CODESYS Memory Tools 来自 CODESYS 商店 或者 CODESYS 商店北美 。您还可以在那里找到该产品的数据表。...", 
"body" : "这 CODESYS Memory Tools 提供显示应用程序当前控制器内存的功能 CODESYS , 以及对于 CODESYS Memory Tools -定义的内存一致性检查。 你可以下载 CODESYS Memory Tools 来自 CODESYS 商店 或者 CODESYS 商店北美 。您还可以在那里找到该产品的数据表。 " }, 
{ "title" : "显示核心转储，检查内存 ", 
"url" : "_memtools_displaying_checking_memory.html", 
"breadcrumbs" : "CODESYS Memory Tools \/ 显示核心转储，检查内存 ", 
"snippet" : "当。。。的时候 CODESYS Memory Tools 安装包， CODESYS 可以在线模式下显示来自 PLC 的核心转储。在里面 记忆 查看，您配置要显示的应用程序和内存区域。 你也可以执行 CODESYS -定义的内存一致性检查并将结果打印到消息视图。 例子 以下核心转储（来自 CODESYS Control Win ) 显示左侧内存的十六进制地址。数据在中间以十六进制表示法显示，在右侧显示为文本。任何不能用可显示字符表示的数据都显示为一个点 ( . ）。 0x04D7789C: 0000 301E 1C2C DE04 0000 0000 0000 0000 0000 0000 ..0...", 
"body" : "当。。。的时候 CODESYS Memory Tools 安装包， CODESYS 可以在线模式下显示来自 PLC 的核心转储。在里面 记忆 查看，您配置要显示的应用程序和内存区域。 你也可以执行 CODESYS -定义的内存一致性检查并将结果打印到消息视图。 例子 以下核心转储（来自 CODESYS Control Win ) 显示左侧内存的十六进制地址。数据在中间以十六进制表示法显示，在右侧显示为文本。任何不能用可显示字符表示的数据都显示为一个点 ( . ）。 0x04D7789C: 0000 301E 1C2C DE04 0000 0000 0000 0000 0000 0000 ..0..,Þ.............\n0x04D778B0: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ....................\n0x04D778C4: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 .................... 内存转储中显示的字节可以被覆盖并将更改写入 PLC。 CODESYS 不检查是否允许更改。如果您进行粗心的更改，您可能会导致应用程序崩溃。 您可以定义核心转储的绝对起始地址，例如通过从指针变量中指定地址值。您还可以通过定义范围和偏移量来指定相对于 PLC 内存区域的起始地址。在内存显示中，您可以浏览相邻的内存段或将核心转储保存到文件中。您可以覆盖十六进制的数据并将更改传输到 PLC。工具栏中提供了相关的命令。 比如当你单步进入应用程序进行错误检查时， CODESYS 不断刷新核心转储的视图。 当您将光标设置在十六进制数据中时，您可以右键单击将该数据的地址复制到剪贴板（ 复制地址 命令）。 " }, 
{ "title" : "选择应用程序 ", 
"url" : "_memtools_displaying_checking_memory.html#UUID-556e1064-f0d2-c781-df40-375f3bc6876e_id_dfe811f957023c0a8646369fff183_id_31cecfe4d6b111e48c99d9d7fb3a7ef1", 
"breadcrumbs" : "CODESYS Memory Tools \/ 显示核心转储，检查内存 \/ 选择应用程序 ", 
"snippet" : "要求：将一个或多个应用程序加载到 PLC。您已登录到核心转储的应用程序。您可以通过右键单击设备树中的应用程序来使用非活动应用程序登录。 点击 查看 → 内存 . 这 记忆 应用程序的视图打开。 按照以下部分所述调用所需的内存视图。定义绝对起始地址，例如使用来自指针变量的值，或通过指定内存区域（区域\/偏移量）。 在里面 应用 字段，选择另一个登录的应用程序来检索该应用程序的核心转储。...", 
"body" : "要求：将一个或多个应用程序加载到 PLC。您已登录到核心转储的应用程序。您可以通过右键单击设备树中的应用程序来使用非活动应用程序登录。 点击 查看 → 内存 . 这 记忆 应用程序的视图打开。 按照以下部分所述调用所需的内存视图。定义绝对起始地址，例如使用来自指针变量的值，或通过指定内存区域（区域\/偏移量）。 在里面 应用 字段，选择另一个登录的应用程序来检索该应用程序的核心转储。 " }, 
{ "title" : "通过变量定义核心转储的起始地址 ", 
"url" : "_memtools_displaying_checking_memory.html#UUID-556e1064-f0d2-c781-df40-375f3bc6876e_id_dfe811f957023c0a8646369fff183_id_3a007034d6b111e48c99d9d7fb3a7ef1", 
"breadcrumbs" : "CODESYS Memory Tools \/ 显示核心转储，检查内存 \/ 通过变量定义核心转储的起始地址 ", 
"snippet" : "要求：PLC 上加载了应用程序并且您已登录。您希望将特定变量的地址指定为核心转储的起始地址。 点击 查看 → 显示内存视图 . 这 记忆 视图打开。 指定变量的地址 区域 .直接单击地址（例如从指针变量的值中读取）或通过输入助手选择变量 . 这 绝对 选项自动设置。 CODESYS 将核心转储显示为变量地址周围的绝对范围。...", 
"body" : "要求：PLC 上加载了应用程序并且您已登录。您希望将特定变量的地址指定为核心转储的起始地址。 点击 查看 → 显示内存视图 . 这 记忆 视图打开。 指定变量的地址 区域 .直接单击地址（例如从指针变量的值中读取）或通过输入助手选择变量 . 这 绝对 选项自动设置。 CODESYS 将核心转储显示为变量地址周围的绝对范围。 " }, 
{ "title" : "通过指定内存区域来设置核心转储的起始地址 ", 
"url" : "_memtools_displaying_checking_memory.html#UUID-556e1064-f0d2-c781-df40-375f3bc6876e_id_dfe811f957023c0a8646369fff183_id_954d74e5d6ba11e48c99d9d7fb3a7ef1", 
"breadcrumbs" : "CODESYS Memory Tools \/ 显示核心转储，检查内存 \/ 通过指定内存区域来设置核心转储的起始地址 ", 
"snippet" : "要求：在 PLC 上加载了应用程序并且您已登录。您希望指定特定内存区域的起始地址加上偏移量作为核心转储的起始地址。 点击 查看 → 显示内存视图 . 这 记忆 视图打开。 在 区域 , 选择 0区 选项。可选择区域的列表取决于设备。 在 抵消 ，指定起始地址的所需偏移量。例子： ” 512 ”。 注意：该字段不能为空。如果您不想要偏移量，请设置该值 0 . CODESYS 显示从内存开始的核心转储 Area 0 + 512。...", 
"body" : "要求：在 PLC 上加载了应用程序并且您已登录。您希望指定特定内存区域的起始地址加上偏移量作为核心转储的起始地址。 点击 查看 → 显示内存视图 . 这 记忆 视图打开。 在 区域 , 选择 0区 选项。可选择区域的列表取决于设备。 在 抵消 ，指定起始地址的所需偏移量。例子： ” 512 ”。 注意：该字段不能为空。如果您不想要偏移量，请设置该值 0 . CODESYS 显示从内存开始的核心转储 Area 0 + 512。 " }, 
{ "title" : "编辑数据 ", 
"url" : "_memtools_displaying_checking_memory.html#UUID-556e1064-f0d2-c781-df40-375f3bc6876e_id_dfe811f957023c0a8646369fff183_id_f71d64f41a199e94c0a864636ed3271a", 
"breadcrumbs" : "CODESYS Memory Tools \/ 显示核心转储，检查内存 \/ 编辑数据 ", 
"snippet" : "可以覆盖内存转储中显示的字节并将更改写入 PLC。 CODESYS 不检查是否允许更改。如果您进行粗心的更改，您可能会导致应用程序崩溃。 要求：在 PLC 上加载了一个应用程序并且您已登录。 执行上述说明“通过指定内存区域定义起始地址”中的步骤 1-3。 在核心转储的十六进制数据区域中，单击一个字节并输入一个新值。 覆盖任何先前值的新值用红色标记。 点击 . CODESYS 将数据传输到 PLC。...", 
"body" : "可以覆盖内存转储中显示的字节并将更改写入 PLC。 CODESYS 不检查是否允许更改。如果您进行粗心的更改，您可能会导致应用程序崩溃。 要求：在 PLC 上加载了一个应用程序并且您已登录。 执行上述说明“通过指定内存区域定义起始地址”中的步骤 1-3。 在核心转储的十六进制数据区域中，单击一个字节并输入一个新值。 覆盖任何先前值的新值用红色标记。 点击 . CODESYS 将数据传输到 PLC。 " }, 
{ "title" : "为活动应用程序执行内存检查 ", 
"url" : "_memtools_displaying_checking_memory.html#UUID-556e1064-f0d2-c781-df40-375f3bc6876e_id_dfe811f957023c0a8646369fff183_id_03e6d87c6a2e9076c0a8640e0141e50c", 
"breadcrumbs" : "CODESYS Memory Tools \/ 显示核心转储，检查内存 \/ 为活动应用程序执行内存检查 ", 
"snippet" : "要求：您已登录到 PLC 上的活动应用程序。 点击 调试 → 检查活动应用程序的内存 . 存储器经受各种测试。结果被发送到消息视图中 记忆工具 类别。双击消息打开 记忆 查看突出显示相应内存位置的位置。...", 
"body" : "要求：您已登录到 PLC 上的活动应用程序。 点击 调试 → 检查活动应用程序的内存 . 存储器经受各种测试。结果被发送到消息视图中 记忆工具 类别。双击消息打开 记忆 查看突出显示相应内存位置的位置。 " }, 
{ "title" : "参考 ", 
"url" : "_mem_reference.html", 
"breadcrumbs" : "CODESYS Memory Tools \/ 参考 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令 ", 
"url" : "_mem_ref_commands.html", 
"breadcrumbs" : "CODESYS Memory Tools \/ 参考 \/ 命令 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：检查活动应用程序的内存 ", 
"url" : "_memtools_cmd_check_memory_for_active_application.html", 
"breadcrumbs" : "CODESYS Memory Tools \/ 参考 \/ 命令 \/ 命令：检查活动应用程序的内存 ", 
"snippet" : "检查活动应用程序的内存 功能 : 命令启动 内存检查 对于活跃的应用程序。 称呼 ： 调试 菜单 要求 ： 这 CODESYS Memory Tools 包已安装。该应用程序处于在线模式。 检查活动应用程序的内存区域是否有以下内容： 检查结果显示在消息视图中。违反测试标准的行为被列为警告。 警告 ID（如果未满足检查标准） 检查标准 MC0001 BOOL 变量必须是 0 或者 1 在记忆中。 MC0002 枚举变量只能采用枚举中定义的值。 MC0003 子范围类型的变量只能采用子范围内的值。 MC0004 所有字符串必须以零结尾。 MC0005 指针必须始终指向对齐正确的地址。 指针必须指向...", 
"body" : "检查活动应用程序的内存 功能 : 命令启动 内存检查 对于活跃的应用程序。 称呼 ： 调试 菜单 要求 ： 这 CODESYS Memory Tools 包已安装。该应用程序处于在线模式。 检查活动应用程序的内存区域是否有以下内容： 检查结果显示在消息视图中。违反测试标准的行为被列为警告。 警告 ID（如果未满足检查标准） 检查标准 MC0001 BOOL 变量必须是 0 或者 1 在记忆中。 MC0002 枚举变量只能采用枚举中定义的值。 MC0003 子范围类型的变量只能采用子范围内的值。 MC0004 所有字符串必须以零结尾。 MC0005 指针必须始终指向对齐正确的地址。 指针必须指向地址与类型粒度对齐的内存位置，或者是 0 或者 -1 。 MC0006 指针必须指向应用程序中的内存。 项目中的函数指针必须指向由管理的内存 CODESYS Memory Tools 。 指向库 POU 或外部 POU 的函数指针不包括在内，因为它们可能位于外部存储器中。 MC0007 指针必须引用正确类型的变量（例如，当 POINTER TO STRING 指向 a REAL ）。 MC0008 编译器结构的内部一致性 函数指针地址必须内部一致。 MC0009 编译器结构的内部一致性 接口变量和函数表指针必须在内部保持一致。 MC0010 编译器结构的内部一致性 MC0011 自下载以来，下载的代码必须没有变化。 编译的 POU 的代码必须保持不变。 注意：带有断点的编译 POU 不在检查范围内，因为代码是在运行时针对这些断点进行操作的。 MC0012 自下载以来，常量的值不得发生变化。 常量块类型的变量 ( STRUCT ， ARRAY 等）必须与其初始化值保持不变。 MC0013 编译器结构的内部一致性 MC0014 编译器结构的内部一致性 双击消息打开 记忆 查看相应位置以橙色突出显示的位置。 这 记忆 也可以通过以下方式打开视图 查看 → 内存 命令。 可以通过以下方式限制检查 'memory check' 属性。 " }, 
{ "title" : "命令：显示内存视图 ", 
"url" : "_memtools_cmd_show_memory_view.html", 
"breadcrumbs" : "CODESYS Memory Tools \/ 参考 \/ 命令 \/ 命令：显示内存视图 ", 
"snippet" : "显示内存视图 功能 ：该命令打开 记忆 看法。 称呼 ： 看法 菜单 要求 ： 这 CODESYS Memory Tools 包已安装。应用程序处于联机模式。 这 记忆 视图显示特定应用程序的内存映射。 有关更多信息，请参阅： 当您在内存检查后双击消息视图中发出的警告时，该视图也会打开——通过 调试 → 检查活动应用程序的内存 命令。...", 
"body" : "显示内存视图 功能 ：该命令打开 记忆 看法。 称呼 ： 看法 菜单 要求 ： 这 CODESYS Memory Tools 包已安装。应用程序处于联机模式。 这 记忆 视图显示特定应用程序的内存映射。 有关更多信息，请参阅： 当您在内存检查后双击消息视图中发出的警告时，该视图也会打开——通过 调试 → 检查活动应用程序的内存 命令。 " }, 
{ "title" : "视图：内存 ", 
"url" : "_memtools_cmd_show_memory_view.html#UUID-25f41884-1314-9f3d-2dc2-cc6757cd4497_id_a4cdd909d25f1f50c0a8646308bf0f7b_id_725558b1547511e4a6e1e82144977cd0", 
"breadcrumbs" : "CODESYS Memory Tools \/ 参考 \/ 命令 \/ 命令：显示内存视图 \/ 视图：内存 ", 
"snippet" : "此视图显示在线模式下应用程序的内存映射。 应用 为显示的内存视图选择应用程序。您必须在 PLC 上登录到此应用程序。它不必是“活动应用程序”。 区域 绝对 : 直接完整地分配内存地址。地址显示在输入字段中。 区域 <i> ：PLC 的存储区，起始于 Area 0 . 地址 核心转储的绝对起始地址 要求： 绝对 被选中在 区域 输入字段。 抵消 所选内存区域的地址偏移量（以字节为单位），例如 0x0200 , 16#0200 ， 要么 512 （十进制数）。 要求：选择一个内存区域 区域 （例子： 0区 ）。 CODESYS Memory Tools 提供当前使用的所有内存范围。 查找变量的地址...", 
"body" : "此视图显示在线模式下应用程序的内存映射。 应用 为显示的内存视图选择应用程序。您必须在 PLC 上登录到此应用程序。它不必是“活动应用程序”。 区域 绝对 : 直接完整地分配内存地址。地址显示在输入字段中。 区域 <i> ：PLC 的存储区，起始于 Area 0 . 地址 核心转储的绝对起始地址 要求： 绝对 被选中在 区域 输入字段。 抵消 所选内存区域的地址偏移量（以字节为单位），例如 0x0200 , 16#0200 ， 要么 512 （十进制数）。 要求：选择一个内存区域 区域 （例子： 0区 ）。 CODESYS Memory Tools 提供当前使用的所有内存范围。 查找变量的地址 ：输入辅助打开以选择 IEC 变量。选择变量时， CODESYS Memory Tools 用变量地址保留起始地址。 加载\/刷新内存视图 显示上一个内存段 ：导航到上一个内存段。 显示下一个内存段 ：导航到下一个内存段。 警告： CODESYS Memory Tools 不检查是否允许更改。如果您进行粗心的更改，您可能会导致应用程序崩溃。 将更改下载到 PLC ： CODESYS 将新数据传输到 PLC。 要求：您已覆盖内存视图中的至少一个字节。 将核心转储保存到文件 : 对话框 将内存内容保存为二进制文件 打开。选择一个位置。 列 核心转储的十六进制显示的列数。每列显示两个字节。为了 汽车 ，调整列数以适应窗口大小。数据以其 ASCII 表示形式显示在右侧。 来自应用程序的变量的内存位置以绿色突出显示。当未被设备抑制时，也会显示纯代码存储区。对于应用程序 POU，它们以蓝色突出显示。 “已编译”库或隐式代码中的符号不会以颜色突出显示。 当您将鼠标光标悬停在显示的内存位置上时，工具提示会显示更多信息，例如变量名称和数据类型。 如果在内存检查后从消息视图中打开了内存视图，则相应的内存位置以橙色突出显示。 " }, 
{ "title" : "命令：打开内存扫描 ", 
"url" : "_mem_cmd_open_memory_scan.html", 
"breadcrumbs" : "CODESYS Memory Tools \/ 参考 \/ 命令 \/ 命令：打开内存扫描 ", 
"snippet" : "打开内存扫描 函数 : 该命令会打开 内存扫描 观点。在此视图中，可以在内存或部分内存中搜索特定的文字值。检测到的内存位置显示在视图中，其中包含有关内存区域和内存位置的信息。 打电话 : 查看 菜单 要求 : CODESYS Memory Tools 已安装。 应用程序已连接到控制器。 查看： 内存扫描 价值 要搜索的值。 值类型 值的数据类型 如果数据类型与指定值不匹配，则显示为 警告标志。 内存扫描选项 区域 要搜索的内存区域 对齐 搜索的内存校准 只会检查可被该值整除的地址。...", 
"body" : "打开内存扫描 函数 : 该命令会打开 内存扫描 观点。在此视图中，可以在内存或部分内存中搜索特定的文字值。检测到的内存位置显示在视图中，其中包含有关内存区域和内存位置的信息。 打电话 : 查看 菜单 要求 : CODESYS Memory Tools 已安装。 应用程序已连接到控制器。 查看： 内存扫描 价值 要搜索的值。 值类型 值的数据类型 如果数据类型与指定值不匹配，则显示为 警告标志。 内存扫描选项 区域 要搜索的内存区域 对齐 搜索的内存校准 只会检查可被该值整除的地址。 " }, 
{ "title" : "命令：查看内存使用情况 ", 
"url" : "_mem_cmd_view_memory_usage.html", 
"breadcrumbs" : "CODESYS Memory Tools \/ 参考 \/ 命令 \/ 命令：查看内存使用情况 ", 
"snippet" : "查看内存使用情况 函数 : 该命令会打开 内存使用情况 观点。此视图显示所选应用程序的内存使用情况。 打电话 : 查看 菜单 要求 : CODESYS Memory Tools 已安装。 应用程序已连接到控制器。 查看：内存使用情况 应用程序 包含当前位于所连接控制器上的应用程序的列表框。 刷新所选应用程序的视图 打开默认的 另存为 对话框将显示的内存使用情况另存为 *.csv 计算机文件系统中的文件。...", 
"body" : "查看内存使用情况 函数 : 该命令会打开 内存使用情况 观点。此视图显示所选应用程序的内存使用情况。 打电话 : 查看 菜单 要求 : CODESYS Memory Tools 已安装。 应用程序已连接到控制器。 查看：内存使用情况 应用程序 包含当前位于所连接控制器上的应用程序的列表框。 刷新所选应用程序的视图 打开默认的 另存为 对话框将显示的内存使用情况另存为 *.csv 计算机文件系统中的文件。 " }, 
{ "title" : "属性：'memory_check' ", 
"url" : "_memtools_pragma_attribute_memory_check_ignore.html", 
"breadcrumbs" : "CODESYS Memory Tools \/ 参考 \/ 属性：'memory_check' ", 
"snippet" : "该属性限制了 内存检查 ，您通过 检查活动应用程序的内存 命令。与价值 ignore ，它从检查中排除单个变量或 POU 签名的所有变量。 插入位置： 在单变量声明的上面一行 在 POU 的声明部分上方的行中 句法 ： {attribute 'memory_check' := 'ignore'} 例子 没有一个变量来自 FB_01 在内存检查中考虑功能块。 {attribute 'memory_check' := 'ignore'} FUNCTION_BLOCK FB_01 VAR strVar : STRING; iBOOL : BOOL; END_VAR...", 
"body" : "该属性限制了 内存检查 ，您通过 检查活动应用程序的内存 命令。与价值 ignore ，它从检查中排除单个变量或 POU 签名的所有变量。 插入位置： 在单变量声明的上面一行 在 POU 的声明部分上方的行中 句法 ： {attribute 'memory_check' := 'ignore'} 例子 没有一个变量来自 FB_01 在内存检查中考虑功能块。 {attribute 'memory_check' := 'ignore'}\nFUNCTION_BLOCK FB_01\nVAR\n strVar : STRING;\n iBOOL : BOOL;\nEND_VAR " }
]
$(document).trigger('search.ready');
});