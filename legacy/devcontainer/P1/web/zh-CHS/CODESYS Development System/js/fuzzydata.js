$(document).ready(function () {indexDict['zh-CHS'] = [{ "title" : "CODESYS Development System ", 
"url" : "_cds_start_page.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS Development System ", 
"snippet" : "这 CODESYS Development System 是用于控制器和自动化技术的 IEC 61131-3 编程工具。编程系统有 32 位和 64 位版本。 您可以下载 CODESYS Development System 来自 CODESYS Store International  或来自 CODESYS Store North America .在那里您还可以找到该产品的数据表。...", 
"body" : "这 CODESYS Development System 是用于控制器和自动化技术的 IEC 61131-3 编程工具。编程系统有 32 位和 64 位版本。 您可以下载 CODESYS Development System 来自 CODESYS Store International  或来自 CODESYS Store North America .在那里您还可以找到该产品的数据表。 " }, 
{ "title" : "概述 ", 
"url" : "_cds_development_system.html", 
"breadcrumbs" : "CODESYS Essentials \/ 概述 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS - 使用帮助 ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm4562692390587232647961086548", 
"breadcrumbs" : "CODESYS Essentials \/ 概述 \/ CODESYS - 使用帮助 ", 
"snippet" : "这 CODESYS - 帮助应该帮助你 CODESYS Development System 使用简单有效。在这里，您可以快速找到问题的答案和问题的解决方案。 每个帮助组件都由一个概念和一个参考部分组成。 在概念部分，我们详细解释了创建一个 CODESYS -项目是相关的。这些概念由说明补充，您将在其中逐步获得所需的结果。 参考部分是完整的用户界面和编程参考指南 CODESYS . 在里面 CODESYS -选项决定你是否想要 CODESYS - 离线帮助或 CODESYS -想要使用在线帮助。 您可以直接从用户界面访问上下文相关帮助 CODESYS Development System 称呼...", 
"body" : "这 CODESYS - 帮助应该帮助你 CODESYS Development System 使用简单有效。在这里，您可以快速找到问题的答案和问题的解决方案。 每个帮助组件都由一个概念和一个参考部分组成。 在概念部分，我们详细解释了创建一个 CODESYS -项目是相关的。这些概念由说明补充，您将在其中逐步获得所需的结果。 参考部分是完整的用户界面和编程参考指南 CODESYS . 在里面 CODESYS -选项决定你是否想要 CODESYS - 离线帮助或 CODESYS -想要使用在线帮助。 您可以直接从用户界面访问上下文相关帮助 CODESYS Development System 称呼。当你在 CODESYS 将光标定位在对象、菜单命令或编程元素上，然后按 F1 按 ，出现相关帮助页面。或者，您可以使用菜单命令 帮助 利用。搜索是全文搜索。索引搜索仅在 CODESYS - 离线帮助可能。 搜索运营商以获取离线帮助 AND 例如，自动使用会导致输入搜索词 Device Diagnosis 与键入相同的搜索结果 Device AND Diagnosis 占位符 * 会自动使用。标志 * 不能作为通配符输入，因为在这种情况下它直接在字符之后 * 被搜索。 " }, 
{ "title" : "CODESYS 系统概览 ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm4564593995971232647965283006", 
"breadcrumbs" : "CODESYS Essentials \/ 概述 \/ CODESYS 系统概览 ", 
"snippet" : "IEC 61131-3 编程工具 CODESYS Development System 形成了核心 CODESYS -用于工业自动化技术任务的软件平台。借助额外的集成解决方案，例如运动控制、可视化和现场总线连接，一个系统即可满足通常的实际需求。...", 
"body" : "IEC 61131-3 编程工具 CODESYS Development System 形成了核心 CODESYS -用于工业自动化技术任务的软件平台。借助额外的集成解决方案，例如运动控制、可视化和现场总线连接，一个系统即可满足通常的实际需求。 " }, 
{ "title" : "功能 ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm4564593977048032647968557534", 
"breadcrumbs" : "CODESYS Essentials \/ 概述 \/ 功能 ", 
"snippet" : "免费的 CODESYS Development System 是用于具有控制任务的自动化设备的 IEC 61131-3 编程平台。它为您的开发工作提供了多种便捷的工程功能： 请参阅此在线帮助： 使用助手（向导）进行项目配置 创建和配置项目界面自定义 自定义界面根据 IEC 61131-3 创建具有许多标准功能的专业控制应用程序 程序申请使用所有 IEC 61131-3 语言的鼠标和键盘进行方便的编程 FBD、KOP、IL、ST、AS 的相应编辑器，以及变体 CFC 和扩展 CFC 编程语言和编辑器用于输入和配置各种数据的输入支持 使用输入辅助支持面向对象的编程 真正的面向对象编程符合 6113...", 
"body" : "免费的 CODESYS Development System 是用于具有控制任务的自动化设备的 IEC 61131-3 编程平台。它为您的开发工作提供了多种便捷的工程功能： 请参阅此在线帮助： 使用助手（向导）进行项目配置 创建和配置项目界面自定义 自定义界面根据 IEC 61131-3 创建具有许多标准功能的专业控制应用程序 程序申请使用所有 IEC 61131-3 语言的鼠标和键盘进行方便的编程 FBD、KOP、IL、ST、AS 的相应编辑器，以及变体 CFC 和扩展 CFC 编程语言和编辑器用于输入和配置各种数据的输入支持 使用输入辅助支持面向对象的编程 真正的面向对象编程符合 61131-3 第 3 版所有 IEC 61131-3 语言可能无需额外工具 将程序模块继承到类似的应用程序部分，以减少开发时间和错误 面向对象编程不是必须的：可以根据需要使用和混合使用函数式或面向对象的编程。 面向对象编程综合项目比较，也适用于图形编辑器 比较项目易于重用应用程序代码的库概念 使用库调试和在线属性以优化应用程序代码并加快测试和调试 测试和调试用于许多 CPU 平台的集成编译器以优化控制器的性能 编译器版本编译选项保护控制器的源代码和操作的安全属性 保护和保存项目保护应用程序设备用户管理的处理管理包和许可证来自不同制造商的设备的现场总线支持和编程 配置 I\/O 链接无需离开产品框架即可扩展和定制 管理包和许可证除此之外： 用于进一步自动化任务的无缝集成工具，例如 CODESYS Visualization , CODESYS SoftMotion 和 CODESYS Application Composer 还要注意在附加包的帮助下扩展功能的可能性，可以通过 CODESYS Store International 准备好。 " }, 
{ "title" : "设置用户界面的语言 ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm4562692385747232647971307357", 
"breadcrumbs" : "CODESYS Essentials \/ 概述 \/ 设置用户界面的语言 ", 
"snippet" : "在对话中 选项 → 国际设置 您可以设置开发系统的用户界面在下次启动时应该出现的国家语言。您可以单独指定帮助的国家语言。 如果你 CODESYS 通过命令行，您可以通过参数指定界面的语言。...", 
"body" : "在对话中 选项 → 国际设置 您可以设置开发系统的用户界面在下次启动时应该出现的国家语言。您可以单独指定帮助的国家语言。 如果你 CODESYS 通过命令行，您可以通过参数指定界面的语言。 " }, 
{ "title" : "版权和商标 ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm456459407124003264797233218", 
"breadcrumbs" : "CODESYS Essentials \/ 概述 \/ 版权和商标 ", 
"snippet" : "所有人的权利 CODESYS - 帮助提到的公司和公司名称以及商品和产品名称都与各自的公司。保留技术更改。此帮助或其部分内容只能在与 CODESYS GmbH 复制或重复使用。...", 
"body" : "所有人的权利 CODESYS - 帮助提到的公司和公司名称以及商品和产品名称都与各自的公司。保留技术更改。此帮助或其部分内容只能在与 CODESYS GmbH 复制或重复使用。 " }, 
{ "title" : "白皮书：从用户的角度进行模块化 ", 
"url" : "_cds_codesys_modularization.html", 
"breadcrumbs" : "CODESYS Essentials \/ 白皮书：从用户的角度进行模块化 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "引发 ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_66e987b85bec06a3c0a864633232042b", 
"breadcrumbs" : "CODESYS Essentials \/ 白皮书：从用户的角度进行模块化 \/ 引发 ", 
"snippet" : "在 CODESYS 3.5 SP17 我们进行了重大的架构转换。以前，大多数编程系统功能都捆绑在一个内聚的设置中。仅有的 CODESYS SoftMotion 以及付费的附加组件 CODESYS Professional Developer Edition 是分开的。在转换过程中，我们现在将这种模块化继续深入到核心功能中。大多数编程语言编辑器、现场总线配置器和代码生成器现在都外包给他们自己的附加组件。像可视化或图标配置这样的大功能也是如此，举两个例子。重要的基础设施功能，例如用户界面结构（菜单系统、导航器、消息窗口等）、编译器前端以及用于项目处理和与控制器通信的组件仍然是核心。应该注意的是，将...", 
"body" : "在 CODESYS 3.5 SP17 我们进行了重大的架构转换。以前，大多数编程系统功能都捆绑在一个内聚的设置中。仅有的 CODESYS SoftMotion 以及付费的附加组件 CODESYS Professional Developer Edition 是分开的。在转换过程中，我们现在将这种模块化继续深入到核心功能中。大多数编程语言编辑器、现场总线配置器和代码生成器现在都外包给他们自己的附加组件。像可视化或图标配置这样的大功能也是如此，举两个例子。重要的基础设施功能，例如用户界面结构（菜单系统、导航器、消息窗口等）、编译器前端以及用于项目处理和与控制器通信的组件仍然是核心。应该注意的是，将来可能会将更多核心部分移动到单独的附加组件中。 我们将主要使用这种模块化来均衡各个组件的版本周期。过去需要 CODESYS - 将有关新功能和改进的开发集中到每年一个日期 - 即服务包的发布日期。刚刚未完成的功能通常会导致服务包被推迟。明显偏离计划的功能已被推迟一整年。我们希望这种环环相扣既符合我们自己的利益，也符合每个人的利益 CODESYS - 解决用户和独立版本并在未来发布每个附加组件。 为了 CODESYS 用户，有许多明显和重要的优势。 功能在完成后立即发布，并尽快可用。 附加组件的 Beta 版本可以交付给感兴趣的用户，以便及时获得反馈。这样的 beta 版本可以在其他稳定的环境中运行。 可以删除不必要的附加组件，这对空间需求和整体性能都有好处。 当然，这种灵活性被增加的复杂性所抵消。在本白皮书中，我们想描述 存在哪些限制 我们采取了哪些措施来使复杂性可控 我们为典型应用推荐哪种程序 " }, 
{ "title" : "设置 ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_3ce1a2b05bec06a3c0a8646354ca4853", 
"breadcrumbs" : "CODESYS Essentials \/ 白皮书：从用户的角度进行模块化 \/ 设置 ", 
"snippet" : "该设置仍然来自 CODESYS Store International 可以下载完成。已经属于的所有组件 CODESYS 3.5 SP16 和更早版本也包含在当前设置中，即安装后，用户会收到一个熟悉的整体系统，没有任何功能妥协。 我们认为用户应该在自己的时间完成核心系统和附加版本的单独编译，而不是从一开始就处理它。我们还知道，许多用户对整个软件包并不满意，并且可能永远不想进行自定义构建——这是一种完全合法的方法，该工具不会妨碍该方法。...", 
"body" : "该设置仍然来自 CODESYS Store International 可以下载完成。已经属于的所有组件 CODESYS 3.5 SP16 和更早版本也包含在当前设置中，即安装后，用户会收到一个熟悉的整体系统，没有任何功能妥协。 我们认为用户应该在自己的时间完成核心系统和附加版本的单独编译，而不是从一开始就处理它。我们还知道，许多用户对整个软件包并不满意，并且可能永远不想进行自定义构建——这是一种完全合法的方法，该工具不会妨碍该方法。 " }, 
{ "title" : "安装程序 ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_ac5f82f95bec06a3c0a86463303421a1", 
"breadcrumbs" : "CODESYS Essentials \/ 白皮书：从用户的角度进行模块化 \/ 安装程序 ", 
"snippet" : "安装程序将自动安装一个名为的新全局工具 CODESYS Installer 名字。有了它，每个人都可以 CODESYS - 管理安装和相关的附加组件。它是希望积极受益于模块化优势的用户的关键。 随着 CODESYS Installer 可以管理任意数量的独立安装。在每个单独的安装中，可以准确指定哪些附加组件应该是其中的一部分。为了更清楚起见，可以为每个安装指定一个描述性名称。每次安装时，您都可以设置应该报告哪些更新；默认情况下，它设置为“仅发布版本”，但也可以切换到预发布版本或关闭以锁定安装状态。 有关有用功能的更多信息 CODESYS Installer 可以在下面的建议中找到。 在里面 C...", 
"body" : "安装程序将自动安装一个名为的新全局工具 CODESYS Installer 名字。有了它，每个人都可以 CODESYS - 管理安装和相关的附加组件。它是希望积极受益于模块化优势的用户的关键。 随着 CODESYS Installer 可以管理任意数量的独立安装。在每个单独的安装中，可以准确指定哪些附加组件应该是其中的一部分。为了更清楚起见，可以为每个安装指定一个描述性名称。每次安装时，您都可以设置应该报告哪些更新；默认情况下，它设置为“仅发布版本”，但也可以切换到预发布版本或关闭以锁定安装状态。 有关有用功能的更多信息 CODESYS Installer 可以在下面的建议中找到。 在里面 CODESYS 我们有通知中心 CODESYS Installer 连接的。此处显示有关合适更新的消息。所以你不必总是 CODESYS Installer 运行以收到更新通知。 " }, 
{ "title" : "兼容性 ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_0259f7295bec06a3c0a86463648ba988", 
"breadcrumbs" : "CODESYS Essentials \/ 白皮书：从用户的角度进行模块化 \/ 兼容性 ", 
"snippet" : "关键词兼容性隐藏了模块化导致的最大复杂性增加。虽然传统上一直存在线性进步，因此兼容性问题很简单（“新 CODESYS 可以阅读旧项目”），这在高度模块化的环境中要困难得多。 我们做出的决定以及在以下部分中更详细地解释的决定不是基于技术上可行的，而是基于合理可管理的。 项目兼容性 这里的问题是在多大程度上 CODESYS -安装可以用另一个打开一个项目或库 CODESYS - 安装已创建。 我们没有改变这个机制。行为与中的相同 CODESYS - 模块化之前的版本。如果项目中的数据由于是从较新的环境创建而无法使用当前版本读取或解释，则受影响的对象会在导航器中用红叉标记，或者使用 [不完整] （→...", 
"body" : "关键词兼容性隐藏了模块化导致的最大复杂性增加。虽然传统上一直存在线性进步，因此兼容性问题很简单（“新 CODESYS 可以阅读旧项目”），这在高度模块化的环境中要困难得多。 我们做出的决定以及在以下部分中更详细地解释的决定不是基于技术上可行的，而是基于合理可管理的。 项目兼容性 这里的问题是在多大程度上 CODESYS -安装可以用另一个打开一个项目或库 CODESYS - 安装已创建。 我们没有改变这个机制。行为与中的相同 CODESYS - 模块化之前的版本。如果项目中的数据由于是从较新的环境创建而无法使用当前版本读取或解释，则受影响的对象会在导航器中用红叉标记，或者使用 [不完整] （→ 编辑器仍然可以打开）或 [未知] （→ 无法再打开编辑器）。在这两种情况下，项目都无法加载到控制器上（因为可能会导致未定义的程序行为），它只是站立 另存为 可用（以防止意外覆盖原始项目并因此丢失数据）。 多年来，这种行为已经证明了自己。 代码兼容性 这是关于一个人是否拥有 CODESYS - 一个项目的安装总是可以生成与另一个相同的二进制控制代码 CODESYS -安装。简单地说：你能用一个 CODESYS -无需在线更改或下载即可打开安装并登录控制器？ 为此目的，有多达并包括 CODESYS 3.5 SP17 编译版本的概念。我们将启动编译器版本 CODESYS 3.5 移除 SP18。如果您依赖能够在不进行在线更改或下载的情况下登录到带有项目的控制器，那么您必须以完全匹配的方式启动项目 CODESYS - 打开安装。 放弃编译器版本概念的决定有很多重要的论据： 不仅编译器而且所涉及的编程语言编辑器和现场总线配置器都对生成的代码负责。由于这些现在已外包给独立版本的附加组件，原则上不再有统一的包罗万象的编译器版本。从用户的角度来看，我们发现尝试将不同的附加特定编译器版本组合成一种编译器版本配置文件过于复杂。在 CODESYS UML （部分 CODESYS Professional Developer Edition ) 多年来一直有一个单独的语言模型生成版本，但即使有了这个附加组件，这个概念也没有在实践中证明自己，更不用说当前的众多附加组件了。 即使是简单的形式，编译器版本也需要用户提供详细的知识。最晚，更正一个意外设置错误的版本通常是有问题的。有过不好体验的用户，或者根本不相信这个概念的用户，过去已经进行了几次维护安装，以便在维护时能够安全地登录到正在运行的控制器。正如我们将在下面看到的，我们现在为这种情况提供强大的交互式支持。 每个新的编译器版本都会使我们的内部代码库膨胀。一方面，这对性能和安装尺寸有负面影响。另一方面，我们无法测试此代码库中的所有组合。由于编译器版本的维护在一定程度上也容易出错，这与我们不断提高的质量标准直接矛盾。换句话说：我们不能保证以前的编译器版本概念在所有情况下都能可靠地工作，如果我们不得不使这个概念由于模块化而变得更加复杂，我们当然不能。 前面的两个论点可以总结如下： 从用户的角度来看，能够使用我们的工具支持生成合适的版本来维护案例，而根本不需要处理编译器版本，这是很有吸引力的。 运行时系统兼容性 这里的问题是在多大程度上 CODESYS -安装与运行时系统版本兼容。换句话说：你能想出一个新的吗？ CODESYS - 登录旧控制器并使用可用的在线功能？ 我们没有改变相关的机制。原则上，编程系统和运行系统版本可以根据需要组合，但有以下限制： 新的编程系统版本可能会提供旧运行时系统版本尚不支持的功能。在这种情况下，该功能不可用。 如果安全扩展禁止这样做（例如强制用户管理或新型加密算法），较旧的编程系统版本可能无法与较新的运行时系统版本一起使用。 " }, 
{ "title" : "给用户的建议 ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_6e10313e5bec06a3c0a86463310bf8d6", 
"breadcrumbs" : "CODESYS Essentials \/ 白皮书：从用户的角度进行模块化 \/ 给用户的建议 ", 
"snippet" : "当然，本节描述的场景也可以组合使用。我们相信这涵盖了绝大多数与实践相关的案例，并希望使用我们的工具尽可能地支持它们。我们希望在未来继续根据这些用例优化我们的软件。 设想 推荐 工具支持 正在进行的项目的日常开发 这 CODESYS 版本和相关的附加组件应始终保持最新。我们一直致力于大大小小的改进、错误修复和安全更新，因此最新版本始终是最好的版本。几乎没有理由坚持使用旧版本。 这 CODESYS Installer 显示与安装相关的所有可用更新。只需单击几下鼠标，即可下载和安装这些更新。 此外，通过通知中心，它位于 CODESYS 集成为可停靠窗口，还显示可用更新（与当前安装完全匹配）。从这里您...", 
"body" : "当然，本节描述的场景也可以组合使用。我们相信这涵盖了绝大多数与实践相关的案例，并希望使用我们的工具尽可能地支持它们。我们希望在未来继续根据这些用例优化我们的软件。 设想 推荐 工具支持 正在进行的项目的日常开发 这 CODESYS 版本和相关的附加组件应始终保持最新。我们一直致力于大大小小的改进、错误修复和安全更新，因此最新版本始终是最好的版本。几乎没有理由坚持使用旧版本。 这 CODESYS Installer 显示与安装相关的所有可用更新。只需单击几下鼠标，即可下载和安装这些更新。 此外，通过通知中心，它位于 CODESYS 集成为可停靠窗口，还显示可用更新（与当前安装完全匹配）。从这里您可以直接前往 CODESYS Installer 被跳跃，因此它不必一直处于活动状态。 我们提供的所有设置和附加组件都已签名，因此通过互联网下载它们是安全的。我们用相应的（部分交互的）测试方法扩展了 PackageManager。 在团队中的几个人必须使用统一安装的情况下，对正在进行的项目进行日常开发 如上。 团队中的一个人安装可用的更新并对其进行测试。如果发布成功，则在团队中分发新的参考安装。 在里面 CODESYS Installer 现有安装可以导出为描述文件。此文件可用于在另一台机器上创建相同的安装。此机制也可通过命令行使用，因此特别适用于自动化环境。 在受保护的环境中试用最新的附加功能 现有的生产性使用 CODESYS -安装重复。在此，将根据需要安装和更新任何 beta 版本的附加组件。 那些有效使用的 CODESYS - 安装完全不受影响。项目的正常工作不受影响。 这 CODESYS Installer 可以轻松创建现有安装的副本。对于每次安装，您可以选择是否只提供和安装已发布的更新或实验性测试版更新。 以前，每台机器只能安装一次特定的服务包或补丁。自引入安装程序以来，此限制已被取消。 在不更改相关库存项目的情况下维护现有控制器。必须保证无需在线更改或下载即可登录控制器， 这将是一个完全适合该项目的 CODESYS - 安装创建。无需处理编译器版本，就可以保证生成二进制相等的控制代码。 加载项目时，当前项目之间的差异 CODESYS 安装和创建版本，您有机会下载并安装完全适合项目的安装。然后在这个新创建的版本中自动打开项目。 此外，装载时当然也可以选择机器上已经存在的合适的安装。 获取安装 CODESYS Installer 自定义名称。这样，如果您必须管理大量安装，您就不会忘记事情。 为了不经常收到此类特殊兼容性安装的更新建议，默认情况下这些建议与更新频道分开。 旧现有项目的进一步开发 该项目处于当前 CODESYS -安装进一步发展。由于无论如何都会对代码进行更改，因此到期的在线更改或下载是无关紧要的。 CODESYS 仍然可以无损地加载旧项目。如果缺少必要的附加组件，可以直接从项目加载过程中下载并安装它。否则，项目本身和控制器都受到写和下载保护的保护。 " }, 
{ "title" : "兼容性 ", 
"url" : "_rtsl_compatibility.html", 
"breadcrumbs" : "CODESYS Essentials \/ 兼容性 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "兼容性 CODESYS 项目 ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm43404583559002", 
"breadcrumbs" : "CODESYS Essentials \/ 兼容性 \/ 兼容性 CODESYS 项目 ", 
"snippet" : "存储格式 使用案例 支持 在新中加载项目 CODESYS 无数据丢失版本 ✓ 为较老的人保存项目 CODESYS 版本 ✓ 在旧项目中开设新项目 CODESYS 版本 -- 以较新的项目开放的现有项目 CODESYS 版本尽可能长时间地保持在“兼容模式”。只要您仅对不需要任何新功能的项目进行更改，存储格式就保持不变。这就是为什么原来 CODESYS 版本可以继续打开和编辑项目而不会丢失数据。如果您进行的更改需要在项目中保存新数据，那么您将会收到有关这种情况的交互式通知。如果兼容性违规不可接受，您可以选择撤消最后的更改。 您通常可以在较旧的内存版本中打开具有较新内存版本的项目 CODESYS 版...", 
"body" : "存储格式 使用案例 支持 在新中加载项目 CODESYS 无数据丢失版本 ✓ 为较老的人保存项目 CODESYS 版本 ✓ 在旧项目中开设新项目 CODESYS 版本 -- 以较新的项目开放的现有项目 CODESYS 版本尽可能长时间地保持在“兼容模式”。只要您仅对不需要任何新功能的项目进行更改，存储格式就保持不变。这就是为什么原来 CODESYS 版本可以继续打开和编辑项目而不会丢失数据。如果您进行的更改需要在项目中保存新数据，那么您将会收到有关这种情况的交互式通知。如果兼容性违规不可接受，您可以选择撤消最后的更改。 您通常可以在较旧的内存版本中打开具有较新内存版本的项目 CODESYS 版本，但强烈建议不要这样做。能否打开项目取决于旧版本中插件类型的可用性。加载此类项目时会显示相应的消息。 您还可以选择保存旧版本的项目 CODESYS 通过执行 文件 → 另存为 命令。在这种情况下，有关哪些对象受到数据丢失影响的信息将显示在 留言 看法。但是，保存旧版本的项目会影响明确的唯一存储格式。项目没有完全转换，其中编译器版本或类似设置已适应旧版本。 上网行为 使用案例 支持 编译一个用旧版本创建的项目 CODESYS 版本，在新的 CODESYS 版本 ✓ 新版本无需在线修改即可登录。 -- 新的 CODESYS 版本无法为现有项目生成与创建项目的旧版本相同的代码。如果您需要登录正在运行的应用程序而无需在线更改或下载，则需要使用控制器上上次加载的版本打开项目。这 CODESYS Installer 项目分析可帮助您恢复原始版本（如果尚不存在）。 因此，这意味着使用更新的或不同的版本打开项目需要更新项目。这很可能需要重新下载运行时环境。您还需要测试应用程序是否可能因编译器或图形编辑器中的新功能或错误修复而导致行为发生变化。一般来说，会尝试尽量减少新的编译器错误或现有项目的行为更改，以便尽可能减少更新到新版本的工作量。 为了与现有运行时兼容，需要遵守以下几点： 新功能在 CODESYS 通常在设备描述中启用。因此，对于较旧的运行时系统或较旧的设备描述，它们被禁用。 所有外部库的版本都通过设备描述来解析。结果，它们与相应的运行时系统相匹配。 内部库由 CODESYS 版本，与运行时系统的版本无关。 通信服务是根据带有标签的共享格式构建的。运行时系统会忽略未知标签。因此，可以更改通信服务，但编程系统不会期望运行时系统解释新信息。 " }, 
{ "title" : "兼容性 CODESYS 图书馆 ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm43404583586258", 
"breadcrumbs" : "CODESYS Essentials \/ 兼容性 \/ 兼容性 CODESYS 图书馆 ", 
"snippet" : "使用案例 支持 使用在较旧的版本中创建的编译库 CODESYS 版本，在新的 CODESYS 版本。 ✓ 使用在新创建的编译库 CODESYS 版本，在较旧的 CODESYS 版本。 -- 编译库应始终以最低的版本创建 CODESYS 它们需要兼容的版本。老的 CODESYS 版本识别使用较新版本创建的库并拒绝在项目中使用它们。该检查基于库中设置的编译器版本。根据库的内容，存储格式也可以发挥作用。 相同的规则 CODESYS 项目也适用于源库。...", 
"body" : "使用案例 支持 使用在较旧的版本中创建的编译库 CODESYS 版本，在新的 CODESYS 版本。 ✓ 使用在新创建的编译库 CODESYS 版本，在较旧的 CODESYS 版本。 -- 编译库应始终以最低的版本创建 CODESYS 它们需要兼容的版本。老的 CODESYS 版本识别使用较新版本创建的库并拒绝在项目中使用它们。该检查基于库中设置的编译器版本。根据库的内容，存储格式也可以发挥作用。 相同的规则 CODESYS 项目也适用于源库。 " }, 
{ "title" : "的兼容性 CODESYS 运行时系统 ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm4591711893675234040560644037", 
"breadcrumbs" : "CODESYS Essentials \/ 兼容性 \/ 的兼容性 CODESYS 运行时系统 ", 
"snippet" : "不过不建议使用旧版本 CODESYS 以及更新版本的运行时系统。这种兼容性尚未经过明确测试。由于较新的运行时系统中的安全修正，可能与较旧的系统不兼容 CODESYS 版本。 为了与现有运行时版本兼容，需要遵守以下几点： 新功能在 CODESYS 通常在设备描述中启用。因此，这些版本对于较旧的运行时系统或较旧的设备描述被禁用。 所有外部库的版本都通过设备描述来解析。结果，它们与相应的运行时系统相匹配。 内部库由 CODESYS 版本，与运行时系统的版本无关。 通信服务是根据带有标签的共享格式构建的。运行时系统会忽略未知标签。因此，可以更改通信服务，但编程系统不会期望运行时系统解释新信息。...", 
"body" : "不过不建议使用旧版本 CODESYS 以及更新版本的运行时系统。这种兼容性尚未经过明确测试。由于较新的运行时系统中的安全修正，可能与较旧的系统不兼容 CODESYS 版本。 为了与现有运行时版本兼容，需要遵守以下几点： 新功能在 CODESYS 通常在设备描述中启用。因此，这些版本对于较旧的运行时系统或较旧的设备描述被禁用。 所有外部库的版本都通过设备描述来解析。结果，它们与相应的运行时系统相匹配。 内部库由 CODESYS 版本，与运行时系统的版本无关。 通信服务是根据带有标签的共享格式构建的。运行时系统会忽略未知标签。因此，可以更改通信服务，但编程系统不会期望运行时系统解释新信息。 " }, 
{ "title" : "设备描述的兼容性 – 运行系统 ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm4622937043899234045846685577", 
"breadcrumbs" : "CODESYS Essentials \/ 兼容性 \/ 设备描述的兼容性 – 运行系统 ", 
"snippet" : "使用案例 支持 登录期间接受较旧版本的设备描述和较新的运行时系统。 ✓ 不接受较新版本的设备描述和较旧的运行系统，因此登录被拒绝。 -- 现有项目必须在现有运行时系统上运行，即使使用较新的系统也是如此 CODESYS 版本。这可以通过不更改项目中的设备描述并使用与运行时系统版本匹配的现有版本来实现。如果设备描述的版本和运行时系统没有太大差异或不兼容，也可以登录运行时系统： 设备描述包含外部库的列表，其外部函数在运行时系统中实现。库的相应版本在库占位符列表中指定。该列表由设备制造商定义。 占位符列表应仅包含其相应运行时组件在运行时系统中可用的库。 可以配置设备描述和运行时系统之间的兼容性范围。这...", 
"body" : "使用案例 支持 登录期间接受较旧版本的设备描述和较新的运行时系统。 ✓ 不接受较新版本的设备描述和较旧的运行系统，因此登录被拒绝。 -- 现有项目必须在现有运行时系统上运行，即使使用较新的系统也是如此 CODESYS 版本。这可以通过不更改项目中的设备描述并使用与运行时系统版本匹配的现有版本来实现。如果设备描述的版本和运行时系统没有太大差异或不兼容，也可以登录运行时系统： 设备描述包含外部库的列表，其外部函数在运行时系统中实现。库的相应版本在库占位符列表中指定。该列表由设备制造商定义。 占位符列表应仅包含其相应运行时组件在运行时系统中可用的库。 可以配置设备描述和运行时系统之间的兼容性范围。这意味着如果版本不匹配，您将无法登录控制器。设备制造商可以通过运行时系统中的以下设置来选择此范围（请参阅 SysTargetItf.h 运行时系统）： SYSTARGETKEY_INT_TARGET_VERSION_MASK “TargetVersionMask”：指定用于检查目标版本与设备描述的兼容性的掩码的设置。仅检查掩码中的有效数字。 SYSTARGETKEY_INT_TARGET_VERSION_COMPATIBILITY_MASK “TargetVersionCompatibilityMask”：指定兼容性掩码的设置，用于检查目标版本与设备描述的兼容性。接受低于目标版本或相同版本的设备描述。更高版本的设备描述被拒绝。 当前示例 CODESYS CODESYS 版本 CODESYS 控制版本 设备描述版本 受到推崇的 限制 评论 3.5.19.0 3.5.19.0 3.5.19.0 是的，最佳 -- 这是最佳组合。 3.5.19.0 3.5.12.0 3.5.12.0 是的 -- 这是一个典型的兼容性案例。 3.5.19.0 3.5.12.0 3.5.10.0 不，但有可能 登录控制器时警告 DevDesc 不匹配 这是可能的，因为 DevDesc 比控制器的版本旧。 3.5.19.0 3.5.12.0 3.5.19.0 不 无法访问控制器 默认情况下，这会被拒绝，因为 DevDesc 和运行时系统彼此不兼容。 3.5.19.0 3.5.10.0 3.5.10.30 不 无法访问控制器 这是可能的，因为 DevDesc 在3.5.10.x的兼容范围内。 一个老的例子 CODESYS CODESYS 版本 CODESYS 控制版本 设备描述版本 受到推崇的 限制 评论 3.5.17.0 3.5.19.0 3.5.19.0 不 由于运行时系统中的安全修正，可能会出现不兼容性。 所有外部库的集合必须在以下位置可用 CODESYS 。外部库中可能使用了较新的 IEC 语言资源，从而导致编译错误。 3.5.17.0 3.5.19.0 3.5.17.0 不，但有可能 由于运行时系统中的安全修正，可能会出现不兼容性。 " }, 
{ "title" : "启动项目+保留-运行系统的兼容性 ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm4482671035296034045851594374", 
"breadcrumbs" : "CODESYS Essentials \/ 兼容性 \/ 启动项目+保留-运行系统的兼容性 ", 
"snippet" : "使用案例 支持 较新的运行时系统会加载较旧的启动项目。 ✓ 较旧的运行时系统会加载较新的启动项目。 -- 必须能够从主版本内的运行时系统加载现有的引导项目。根据目标的类型指定检查现有引导项目（ VendorID , DeviceID ，以及 DeviceVersion 自 V3.5.8.0 起）加载前。 从保存的保留文件中保留变量（ <application>.ret ）或来自 SRAM 的数据必须始终兼容。每个保留区域的校验和保存在单独的文件中。相同的校验和保存在引导项目中。该校验和由编译器根据保留数据生成，是保留区域中所有变量及其各自类型的标识。如果保留数据的校验和与启动项目中的校验和不匹...", 
"body" : "使用案例 支持 较新的运行时系统会加载较旧的启动项目。 ✓ 较旧的运行时系统会加载较新的启动项目。 -- 必须能够从主版本内的运行时系统加载现有的引导项目。根据目标的类型指定检查现有引导项目（ VendorID , DeviceID ，以及 DeviceVersion 自 V3.5.8.0 起）加载前。 从保存的保留文件中保留变量（ <application>.ret ）或来自 SRAM 的数据必须始终兼容。每个保留区域的校验和保存在单独的文件中。相同的校验和保存在引导项目中。该校验和由编译器根据保留数据生成，是保留区域中所有变量及其各自类型的标识。如果保留数据的校验和与启动项目中的校验和不匹配，那么您可以在运行时系统中使用多个选项来选择行为。您可以在 [CmpApp] 的部分 cfg 文件： Bootproject.RetainMismatch.Init = 1 ：启动项目已加载并保留已初始化。 Bootproject.RetainMismatch.Exception = 1 ：启动项目已加载，但应用程序仍处于停止状态，并设置为异常状态。这种情况可以通过手动重置来纠正。 无设置 [DEFAULT] ：启动项目未加载，并且错误消息添加到记录器中。 在运行时系统版本 3.5.7.0 及更低版本中，校验和是根据应用程序的整个数据计算的。在较新的版本中，校验和仅根据保留区域中的数据计算。这意味着保留数据可以加载到具有较新版本的引导项目中，即使项目已更改，只要这些更改不涉及对保留数据的任何更改。 " }, 
{ "title" : "CODESYS 配置 ", 
"url" : "_cds_struct_configuring_development_system.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 ", 
"snippet" : "您可以自定义的行为、外观、菜单组成和窗口布局 CODESYS Development System 单独配置。在菜单中 工具 您将找到用于自定义界面和设置 CODESYS -选项。 有关更多信息，请参阅： 定制 和 选项...", 
"body" : "您可以自定义的行为、外观、菜单组成和窗口布局 CODESYS Development System 单独配置。在菜单中 工具 您将找到用于自定义界面和设置 CODESYS -选项。 有关更多信息，请参阅： 定制 和 选项" }, 
{ "title" : "CODESYS - 设置选项 ", 
"url" : "_cds_configuring_dev_sys_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ CODESYS - 设置选项 ", 
"snippet" : "您可以更改的行为和外观 CODESYS Development System 在对话框的各个选项卡中 选项 配置。选择命令后打开对话框 工具 → 选项 .您可以在此处为各种编辑器和功能进行默认设置。这些设置是 CODESYS - 广泛有效。 这些设置存储在您本地系统上的当前用户配置文件中。与用户或机器（计算机）相关的选项设置可以导出到 xml 文件以传输到其他系统。 从 V3.5 SP13 检查 CODESYS 首次启动开发系统时是否已安装旧版本。如果是这样，您将获得对话框 导入向导 采用旧版本的设置 CODESYS -选项。...", 
"body" : "您可以更改的行为和外观 CODESYS Development System 在对话框的各个选项卡中 选项 配置。选择命令后打开对话框 工具 → 选项 .您可以在此处为各种编辑器和功能进行默认设置。这些设置是 CODESYS - 广泛有效。 这些设置存储在您本地系统上的当前用户配置文件中。与用户或机器（计算机）相关的选项设置可以导出到 xml 文件以传输到其他系统。 从 V3.5 SP13 检查 CODESYS 首次启动开发系统时是否已安装旧版本。如果是这样，您将获得对话框 导入向导 采用旧版本的设置 CODESYS -选项。 " }, 
{ "title" : "自定义界面 ", 
"url" : "_cds_struct_userinterface_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 ", 
"snippet" : "CODESYS 为您提供根据您的需要单独调整用户界面的可能性。您可以自由安排窗口以及菜单和命令的可见性。...", 
"body" : "CODESYS 为您提供根据您的需要单独调整用户界面的可能性。您可以自由安排窗口以及菜单和命令的可见性。 " }, 
{ "title" : "自定义菜单 ", 
"url" : "_cds_customizing_menu.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 \/ 自定义菜单 ", 
"snippet" : "您可以使用菜单中的命令 CODESYS 根据您的需要调整用户界面。您可以通过配置对话框隐藏或添加菜单。 添加命令 选择命令 工具 → 自定义 . 对话框打开 调整 .选项卡 菜单 可见。 打开要添加新命令的菜单的菜单树。 选择空图标 . 点击按钮 添加命令 . 对话 添加命令 打开。 所有命令都在对话框中分组。 选择要添加的命令。点击 行 . 新命令将添加到菜单树中。 使用按钮更改菜单顺序中的位置 向上 和 向下 .点击 添加连字符 , 如果您想用连字符分隔单个命令。点击 OK 关于对话 调整 关闭。 新命令现在在菜单中可用。...", 
"body" : "您可以使用菜单中的命令 CODESYS 根据您的需要调整用户界面。您可以通过配置对话框隐藏或添加菜单。 添加命令 选择命令 工具 → 自定义 . 对话框打开 调整 .选项卡 菜单 可见。 打开要添加新命令的菜单的菜单树。 选择空图标 . 点击按钮 添加命令 . 对话 添加命令 打开。 所有命令都在对话框中分组。 选择要添加的命令。点击 行 . 新命令将添加到菜单树中。 使用按钮更改菜单顺序中的位置 向上 和 向下 .点击 添加连字符 , 如果您想用连字符分隔单个命令。点击 OK 关于对话 调整 关闭。 新命令现在在菜单中可用。 " }, 
{ "title" : "删除菜单\/命令 ", 
"url" : "_cds_customizing_menu.html#UUID-656ba63d-6853-57f4-0629-dca5d51e2842_id_a7314d76c3527bdc0a8640e005fa62d_id_0da504cb13c911e4a98d91f1d473d70d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 \/ 自定义菜单 \/ 删除菜单\/命令 ", 
"snippet" : "选择命令 工具 → 自定义 . 对话框打开 调整 .选项卡 菜单 可见。 选择菜单树中的菜单或菜单下方的命令。 点击 消除 . 菜单或命令从菜单树中删除。 点击按钮 行 . 对话框关闭并调整菜单。...", 
"body" : "选择命令 工具 → 自定义 . 对话框打开 调整 .选项卡 菜单 可见。 选择菜单树中的菜单或菜单下方的命令。 点击 消除 . 菜单或命令从菜单树中删除。 点击按钮 行 . 对话框关闭并调整菜单。 " }, 
{ "title" : "添加菜单 ", 
"url" : "_cds_customizing_menu.html#UUID-656ba63d-6853-57f4-0629-dca5d51e2842_id_a7314d76c3527bdc0a8640e005fa62d_id_4406632d13cd11e4a98d91f1d473d70d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 \/ 自定义菜单 \/ 添加菜单 ", 
"snippet" : "选择命令 工具 → 自定义 . 对话框打开 调整 .选项卡 菜单 可见。 滚动到菜单树的底部。 选择空图标 . 点击 添加弹出菜单 . 对话 添加弹出菜单 打开。 在框中输入 默认文本 输入新菜单的名称。 如果您不需要本地化，请转到步骤 9。 点击 添加语言 . 打开所有可用语言的选择。 选择您想要的语言。 该语言被添加到语言列表中。 在字段中单击 文本 并在那里输入与语言相关的文本。 点击 行 . 新菜单添加到菜单树的末尾。 使用按钮更改菜单顺序中的位置 向上 和 向下 .点击按钮 行 关于对话 调整 关闭。 在菜单中有可用命令之前，新菜单不会出现。...", 
"body" : "选择命令 工具 → 自定义 . 对话框打开 调整 .选项卡 菜单 可见。 滚动到菜单树的底部。 选择空图标 . 点击 添加弹出菜单 . 对话 添加弹出菜单 打开。 在框中输入 默认文本 输入新菜单的名称。 如果您不需要本地化，请转到步骤 9。 点击 添加语言 . 打开所有可用语言的选择。 选择您想要的语言。 该语言被添加到语言列表中。 在字段中单击 文本 并在那里输入与语言相关的文本。 点击 行 . 新菜单添加到菜单树的末尾。 使用按钮更改菜单顺序中的位置 向上 和 向下 .点击按钮 行 关于对话 调整 关闭。 在菜单中有可用命令之前，新菜单不会出现。 " }, 
{ "title" : "自定义工具栏 ", 
"url" : "_cds_customizing_toolbar.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 \/ 自定义工具栏 ", 
"snippet" : "您可以使用工具栏 CODESYS 根据您的需要调整用户界面。您可以通过配置对话框隐藏或添加工具栏。 添加命令 选择命令 工具 → 自定义 . 对话框打开 调整 . 选择标签 工具栏 . 打开要添加新命令的工具栏。 选择空图标 . 点击按钮 添加命令 . 对话 添加命令 打开。 所有命令都在对话框中分组。 选择要添加的命令。点击 行 . 新命令添加到工具栏下方。 使用按钮更改工具栏中的位置 向上 和 向下 .点击按钮 添加连字符 , 如果您想用连字符分隔单个命令。点击按钮 行 关于对话 调整 关闭。 新命令在工具栏上可用。...", 
"body" : "您可以使用工具栏 CODESYS 根据您的需要调整用户界面。您可以通过配置对话框隐藏或添加工具栏。 添加命令 选择命令 工具 → 自定义 . 对话框打开 调整 . 选择标签 工具栏 . 打开要添加新命令的工具栏。 选择空图标 . 点击按钮 添加命令 . 对话 添加命令 打开。 所有命令都在对话框中分组。 选择要添加的命令。点击 行 . 新命令添加到工具栏下方。 使用按钮更改工具栏中的位置 向上 和 向下 .点击按钮 添加连字符 , 如果您想用连字符分隔单个命令。点击按钮 行 关于对话 调整 关闭。 新命令在工具栏上可用。 " }, 
{ "title" : "删除工具栏\/命令 ", 
"url" : "_cds_customizing_toolbar.html#UUID-91e60a2c-10a6-5255-018c-837339d7f7f0_id_e1e156c804c48c0a8640e01354a59_id_0da504cb13c911e4a98d91f1d473d70d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 \/ 自定义工具栏 \/ 删除工具栏\/命令 ", 
"snippet" : "选择命令 工具 → 自定义 . 对话框打开 调整 . 选择标签 工具栏 . 选择工具栏或工具栏下方的命令。 点击按钮 消除 . 工具栏或命令被删除。 点击按钮 行 . 对话框关闭，工具栏或命令被删除。...", 
"body" : "选择命令 工具 → 自定义 . 对话框打开 调整 . 选择标签 工具栏 . 选择工具栏或工具栏下方的命令。 点击按钮 消除 . 工具栏或命令被删除。 点击按钮 行 . 对话框关闭，工具栏或命令被删除。 " }, 
{ "title" : "添加工具栏 ", 
"url" : "_cds_customizing_toolbar.html#UUID-91e60a2c-10a6-5255-018c-837339d7f7f0_id_e1e156c804c48c0a8640e01354a59_id_4406632d13cd11e4a98d91f1d473d70d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 \/ 自定义工具栏 \/ 添加工具栏 ", 
"snippet" : "选择命令 工具 → 自定义 . 对话框打开 调整 . 选择标签 工具栏 . 选择最后一个（空的）工具栏。 点击按钮 添加工具栏 . 光标在空白工具栏中闪烁。 输入名称。 使用按钮更改工具栏的顺序 向上 和 向下 .点击按钮 行 关于对话 调整 关闭。 CODESYS 在工具栏中有可用命令之前，不会显示新工具栏。...", 
"body" : "选择命令 工具 → 自定义 . 对话框打开 调整 . 选择标签 工具栏 . 选择最后一个（空的）工具栏。 点击按钮 添加工具栏 . 光标在空白工具栏中闪烁。 输入名称。 使用按钮更改工具栏的顺序 向上 和 向下 .点击按钮 行 关于对话 调整 关闭。 CODESYS 在工具栏中有可用命令之前，不会显示新工具栏。 " }, 
{ "title" : "自定义命令图标 ", 
"url" : "_cds_customizing_command_icons.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 \/ 自定义命令图标 ", 
"snippet" : "CODESYS 允许您将自定义图标分配给命令。 选择命令 工具 → 自定义 . 对话框打开 调整 . 选择标签 命令图标 . 在左侧概览中选择类别 帮助 . 此类别的所有命令都出现在右半部分。 选择命令 信息 . 点击按钮 分派 . 用于选择图标文件 (*.ico) 的对话框打开。 选择一个图标文件。 点击按钮 打开 . 该图标被分配给选定的命令。 点击 行 ....", 
"body" : "CODESYS 允许您将自定义图标分配给命令。 选择命令 工具 → 自定义 . 对话框打开 调整 . 选择标签 命令图标 . 在左侧概览中选择类别 帮助 . 此类别的所有命令都出现在右半部分。 选择命令 信息 . 点击按钮 分派 . 用于选择图标文件 (*.ico) 的对话框打开。 选择一个图标文件。 点击按钮 打开 . 该图标被分配给选定的命令。 点击 行 . " }, 
{ "title" : "自定义键盘快捷键 ", 
"url" : "_cds_customizing_keyboard_shortcuts.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 \/ 自定义键盘快捷键 ", 
"snippet" : "CODESYS 使您能够使用键盘快捷键直接调用命令。您可以自定义或扩展预定义的键盘快捷键。 自定义键盘快捷键 选择命令 工具 → 自定义 . 对话框打开 调整 . 选择标签 键盘 . 在左侧概览中选择类别 帮助 . 此类别的所有命令都出现在右半部分。 选择命令 搜索 . 在字段中单击 键盘快捷键的按键 . 按 控制 + 切换 + 小号 . CODESYS 将键盘快捷键插入字段。 点击按钮 分派 . 键盘快捷键分配给命令。 点击 行 . 你可以命令 搜索 现在使用键盘快捷键 控制 + 切换 + 小号 称呼。 如需更多帮助，请参阅： 键盘快捷键， Windows™ 快捷方式...", 
"body" : "CODESYS 使您能够使用键盘快捷键直接调用命令。您可以自定义或扩展预定义的键盘快捷键。 自定义键盘快捷键 选择命令 工具 → 自定义 . 对话框打开 调整 . 选择标签 键盘 . 在左侧概览中选择类别 帮助 . 此类别的所有命令都出现在右半部分。 选择命令 搜索 . 在字段中单击 键盘快捷键的按键 . 按 控制 + 切换 + 小号 . CODESYS 将键盘快捷键插入字段。 点击按钮 分派 . 键盘快捷键分配给命令。 点击 行 . 你可以命令 搜索 现在使用键盘快捷键 控制 + 切换 + 小号 称呼。 如需更多帮助，请参阅： 键盘快捷键， Windows™ 快捷方式" }, 
{ "title" : "更改窗口排列 ", 
"url" : "_cds_changing_window_layout.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 \/ 更改窗口排列 ", 
"snippet" : "您可以更改不同窗口的排列方式 CODESYS 轻松适应您的个人需求。 通过标题栏或选项卡拖动窗口。 将显示箭头符号，指示可能的位置。例子： 使用鼠标将窗口拖到箭头符号之一上。 目标位置显示为蓝色阴影区域。 松开鼠标左键。 窗口被插入到选定的目标区域。 也可以开窗外的 CODESYS - 放置编程接口。 有关更多信息，请参阅： 更改窗口大小...", 
"body" : "您可以更改不同窗口的排列方式 CODESYS 轻松适应您的个人需求。 通过标题栏或选项卡拖动窗口。 将显示箭头符号，指示可能的位置。例子： 使用鼠标将窗口拖到箭头符号之一上。 目标位置显示为蓝色阴影区域。 松开鼠标左键。 窗口被插入到选定的目标区域。 也可以开窗外的 CODESYS - 放置编程接口。 有关更多信息，请参阅： 更改窗口大小" }, 
{ "title" : "更改窗口大小 ", 
"url" : "_cds_changing_window_size.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 \/ 更改窗口大小 ", 
"snippet" : "将鼠标悬停在两个窗口或视图之间的分界线上。 光标变为双端箭头。 使用鼠标将分割线拖动到所需位置。 您可以通过拖动边框线来调整分离窗口的大小。 有关更多信息，请参阅： 更改窗口排列...", 
"body" : "将鼠标悬停在两个窗口或视图之间的分界线上。 光标变为双端箭头。 使用鼠标将分割线拖动到所需位置。 您可以通过拖动边框线来调整分离窗口的大小。 有关更多信息，请参阅： 更改窗口排列" }, 
{ "title" : "隐藏\/显示窗口 ", 
"url" : "_cds_autohiding_windows.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 \/ 隐藏\/显示窗口 ", 
"snippet" : "取消隐藏窗口 单击隐藏窗口的选项卡。 禁用该选项 窗口→隐藏 . 或单击按钮执行此操作 在视图的右上角。 该窗口将永久显示。...", 
"body" : "取消隐藏窗口 单击隐藏窗口的选项卡。 禁用该选项 窗口→隐藏 . 或单击按钮执行此操作 在视图的右上角。 该窗口将永久显示。 " }, 
{ "title" : "隐藏窗口 ", 
"url" : "_cds_autohiding_windows.html#UUID-71d9107d-d831-5182-3e56-78ee9398c5e6_id_c1fb11d67be31b3fc0a8640e016f13ae_id_1657629d7c432017c0a8640e00b2156d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 \/ 隐藏\/显示窗口 \/ 隐藏窗口 ", 
"snippet" : "如果您隐藏一个窗口，它只会在用户界面中显示为一个选项卡。如果您将鼠标移到此选项卡上，该窗口将自动出现。 单击要隐藏的窗口。 激活选项 窗口→隐藏 . 或单击按钮执行此操作 在视图的右上角。 该窗口是隐藏的，只能通过主窗口侧边的一个小标签可见。 将鼠标指针悬停在选项卡上。 只要鼠标指针停留在选项卡上，窗口就会显示。...", 
"body" : "如果您隐藏一个窗口，它只会在用户界面中显示为一个选项卡。如果您将鼠标移到此选项卡上，该窗口将自动出现。 单击要隐藏的窗口。 激活选项 窗口→隐藏 . 或单击按钮执行此操作 在视图的右上角。 该窗口是隐藏的，只能通过主窗口侧边的一个小标签可见。 将鼠标指针悬停在选项卡上。 只要鼠标指针停留在选项卡上，窗口就会显示。 " }, 
{ "title" : "在窗口之间切换 ", 
"url" : "_cds_switching_windows.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 自定义界面 \/ 在窗口之间切换 ", 
"snippet" : "您可以直接在当前打开的视图和编辑器窗口之间切换。 同时按下按钮 控制 和 标签 .持有 控制 按下按钮。 所有活动视图和编辑器的概览随即打开。 持有 控制 使用箭头键选择窗口时按下的键。 让他们 控制 按钮释放。 选定的视图或选定的编辑器被激活。...", 
"body" : "您可以直接在当前打开的视图和编辑器窗口之间切换。 同时按下按钮 控制 和 标签 .持有 控制 按下按钮。 所有活动视图和编辑器的概览随即打开。 持有 控制 使用箭头键选择窗口时按下的键。 让他们 控制 按钮释放。 选定的视图或选定的编辑器被激活。 " }, 
{ "title" : "安装 CODESYS 离线帮助 ", 
"url" : "_cds_installing_offlinehelp.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 安装 CODESYS 离线帮助 ", 
"snippet" : "这个 CODESYS Development System 在线帮助可以作为离线帮助进行安装。离线帮助包括在线帮助的所有帮助内容，以下出版物除外： 所有库文档 可以在库管理器中离线读取这些内容。 libdev摘要 CODESYS Development System 脚本 API 您可以通过帮助门户的起始页面安装离线帮助，也可以直接通过以下方式安装离线帮助 CODESYS Installer 。 您可以使用激活离线帮助 使用离线帮助而不是在线帮助 中的选项 工具 → 选项 → 帮帮我 菜单。 有关更多信息，请参阅： 使用自己的内容扩展 CODESYS 离线帮助。...", 
"body" : "这个 CODESYS Development System 在线帮助可以作为离线帮助进行安装。离线帮助包括在线帮助的所有帮助内容，以下出版物除外： 所有库文档 可以在库管理器中离线读取这些内容。 libdev摘要 CODESYS Development System 脚本 API 您可以通过帮助门户的起始页面安装离线帮助，也可以直接通过以下方式安装离线帮助 CODESYS Installer 。 您可以使用激活离线帮助 使用离线帮助而不是在线帮助 中的选项 工具 → 选项 → 帮帮我 菜单。 有关更多信息，请参阅： 使用自己的内容扩展 CODESYS 离线帮助。 " }, 
{ "title" : "使用自己的内容扩展 CODESYS 离线帮助 ", 
"url" : "_cds_extending_offlinehelp.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 安装 CODESYS 离线帮助 \/ 使用自己的内容扩展 CODESYS 离线帮助 ", 
"snippet" : "这个 CODESYS Development System 提供使用您自己的帮助页面扩展离线帮助的功能。新的帮助页面可以添加到任何结构中，也可以在目录中的任何位置添加。 此外，还可以在添加的帮助页面上显示整个目录。还支持切换语言和搜索内容 集成 HTML 页面的要求是安装 CODESYS 离线帮助。这个 CODESYS 离线帮助可以通过以下方式安装 帮助门户 或者 CODESYS Installer 。 扩展需要以下文件 HTML 格式的帮助页面 帮助页面存储在目录 C:\\ProgramData\\CODESYS\\Offline Help\\<language> . 配置文件: <name>-pr...", 
"body" : "这个 CODESYS Development System 提供使用您自己的帮助页面扩展离线帮助的功能。新的帮助页面可以添加到任何结构中，也可以在目录中的任何位置添加。 此外，还可以在添加的帮助页面上显示整个目录。还支持切换语言和搜索内容 集成 HTML 页面的要求是安装 CODESYS 离线帮助。这个 CODESYS 离线帮助可以通过以下方式安装 帮助门户 或者 CODESYS Installer 。 扩展需要以下文件 HTML 格式的帮助页面 帮助页面存储在目录 C:\\ProgramData\\CODESYS\\Offline Help\\<language> . 配置文件: <name>-productinfo.json 用于产品帮助概述 配置文件存储在目录中 C:\\ProgramData\\CODESYS\\Offline Help\\de\\js 。 配置文件： <name>-toc.json 用于新页面的插入位置 配置文件存储在目录中 C:\\ProgramData\\CODESYS\\Offline Help\\de\\js 。 配置文件: <name>-search.json ，用于将新内容包含到搜索中 配置文件存储在目录中 C:\\ProgramData\\CODESYS\\Offline Help\\de\\js 。 此文件是可选的。 三个配置文件的 <name> 前缀必须相同。 这些档案 fuzzydata.js ， productsinfo.js ，以及 toc.js 是离线帮助的标准配置文件。开始之后 CODESYS ，json 文件中的内容已集成到标准配置文件 (*.js) 中。原始配置文件保存在中 backup 目录。 " }, 
{ "title" : "创建配置文件 ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm43473870969756", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 安装 CODESYS 离线帮助 \/ 使用自己的内容扩展 CODESYS 离线帮助 \/ 创建配置文件 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "产品帮助概述的配置文件 <name>-productinfo.json ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm450371129061464", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 安装 CODESYS 离线帮助 \/ 使用自己的内容扩展 CODESYS 离线帮助 \/ 创建配置文件 \/ 产品帮助概述的配置文件 <name>-productinfo.json ", 
"snippet" : "此文件在产品帮助的概述页面上创建条目。 title 显示的产品名称和版本 url 链接页面 children 无意义；未评估 示例 [ { \"title\": \"3rd Party, V1.2.3.4\", \"url\": \"3rd_new_pub.html\", \"children\": [] } ]...", 
"body" : "此文件在产品帮助的概述页面上创建条目。 title 显示的产品名称和版本 url 链接页面 children 无意义；未评估 示例 [\n {\n \"title\": \"3rd Party, V1.2.3.4\",\n \"url\": \"3rd_new_pub.html\",\n \"children\": []\n }\n] " }, 
{ "title" : "新帮助页面插入位置的配置文件 <name>-toc.json ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm471214354880041", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 安装 CODESYS 离线帮助 \/ 使用自己的内容扩展 CODESYS 离线帮助 \/ 创建配置文件 \/ 新帮助页面插入位置的配置文件 <name>-toc.json ", 
"snippet" : "此文件定义了新页面集成到帮助中的位置。 url 要插入的页面的 HTML 名称 text 插入的页面的名称。此名称显示在目录中 insert_after 在与指定帮助页面相同的级别上插入新页面 append_below 在指定帮助页面下方插入一个新页面作为最后一个子页面。 如果 \/ 指定字符而不是 HTML 名称，新页面将添加到目录的顶层。 children 添加其他子页面 占位符： * 产品的起始页的 HTML 名称中有一个内部 ID，该标识可以更改。为确保在更改后也能找到这些页面，占位符 * 在这些情况下，应使用作身份证。 示例 1 帮助页面 3rd_new_pub.html 作为兄弟页面...", 
"body" : "此文件定义了新页面集成到帮助中的位置。 url 要插入的页面的 HTML 名称 text 插入的页面的名称。此名称显示在目录中 insert_after 在与指定帮助页面相同的级别上插入新页面 append_below 在指定帮助页面下方插入一个新页面作为最后一个子页面。 如果 \/ 指定字符而不是 HTML 名称，新页面将添加到目录的顶层。 children 添加其他子页面 占位符： * 产品的起始页的 HTML 名称中有一个内部 ID，该标识可以更改。为确保在更改后也能找到这些页面，占位符 * 在这些情况下，应使用作身份证。 示例 1 帮助页面 3rd_new_pub.html 作为兄弟页面插入到帮助页面之后 1064796-311627-codesys-redundancy.html 。 [\n { \"url\": \"3rd_new_pub.html\",\n \"text\": \"New Publication\",\n \"insert_after\": \"1064796-311627-codesys-redundancy.html\"\n }\n] 示例 2 除了示例 1 之外，还插入了两个子页面 New Publication 页面。 [\n { \"url\": \"3rd_new_pub.html\",\n \"text\": \"New Publication\",\n \"children\": [\n {\n \"url\": \"3rd_new_pub_topic1.html\",\n \"text\": \"New Publication - Chapter 1\"\n },\n {\n \"url\": \"3rd_new_pub_topic2.html\",\n \"text\": \"New Publication - Chapter 2\"\n }\n ],\n \"insert_after\": \"1064796-311627-codesys-redundancy.html\"\n }\n] 示例 3 产品的起始页的 HTML 名称中有一个内部 ID，该标识可以更改。为确保在更改后也能找到这些页面，占位符 * 在这些情况下，应使用作身份证。 与示例 2 类似，但使用占位符用于 Insert_after 页面。 [\n { \"url\": \"3rd_new_pub.html\",\n \"text\": \"New Publication\",\n \"children\": [\n {\n \"url\": \"3rd_new_pub_topic1.html\",\n \"text\": \"New Publication - Chapter 1\"\n },\n {\n \"url\": \"3rd_new_pub_topic2.html\",\n \"text\": \"New Publication - Chapter 2\"\n }\n ],\n \"insert_after\": \"*-codesys-redundancy.html\"\n }\n] 示例 4 帮助页面 3rd_new_pub.html 并插入了两个子页面作为帮助页面下方的最后一个子页面 *-codesys-softmotion.html 。 [\n { \"url\": \"3rd_new_pub.html\",\n \"text\": \"New Publication\",\n \"children\": [\n {\n \"url\": \"3rd_new_pub_topic1.html\",\n \"text\": \"New Publication - Chapter 1\"\n },\n {\n \"url\": \"3rd_new_pub_topic2.html\",\n \"text\": \"New Publication - Chapter 2\"\n }\n ],\n \"append_below\": \"*-codesys-softmotion.html\"\n }\n] 示例 5 此配置添加了帮助页面 3rd_toplevel.html 目录末尾的顶层。 [\n {\n \"url\": \"3rd_toplevel.html\",\n \"text\": \"Kapitel Toplevel\",\n \"append_below\": \"\/\"\n }\n] 示例 6 此示例显示了具有不同插入位置的配置。 [\n {\n \"url\": \"3rd_new_pub.html\"\n, \"text\": \"New Publication\",\n \"children\": [\n {\n \"url\": \"3rd_new_pub_topic1.html\",\n \"text\": \"New Publication - Chapter 1\"\n },\n {\n \"url\": \"3rd_new_pub_topic2.html\",\n \"text\": \"New Publication - Chapter 2\"\n }\n ],\n \"insert_after\": \"*-codesys-git.html\"\n },\n {\n \"url\": \"3rd_add_child.html\",\n \"text\": \"Kapitel Geschwister\",\n \"insert_after\": \"_pbdp_cmd_scan_devices.html\"\n },\n {\n \"url\": \"3rd_toplevel.html\",\n \"text\": \"Chapter Toplevel\",\n \"append_below\": \"\/\"\n }\n] " }, 
{ "title" : "搜索的配置文件 <name>-search.json ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm4251855645307457", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 安装 CODESYS 离线帮助 \/ 使用自己的内容扩展 CODESYS 离线帮助 \/ 创建配置文件 \/ 搜索的配置文件 <name>-search.json ", 
"snippet" : "此配置包含页面的完整帮助文本。 title 章节的标题；以搜索命中结果的形式显示 url 找到的页面的 HTML 名称 breadcrumbs 该页面的痕迹。显示在搜索结果中 snippet 找到的页面的简短文本。显示在搜索结果中 body 帮助页面的全文，包括标题 [ { \"title\": \"Chapter 1, \"url\": \"3rd_chapter1.html\", \"breadcrumbs\": \"3rdParty - Offline help \/ Chapter 1\", \"snippet\": \"Lorem ipsum dolor sit amet...\", \"body\": \"Chapte...", 
"body" : "此配置包含页面的完整帮助文本。 title 章节的标题；以搜索命中结果的形式显示 url 找到的页面的 HTML 名称 breadcrumbs 该页面的痕迹。显示在搜索结果中 snippet 找到的页面的简短文本。显示在搜索结果中 body 帮助页面的全文，包括标题 [\n {\n \"title\": \"Chapter 1,\n \"url\": \"3rd_chapter1.html\",\n \"breadcrumbs\": \"3rdParty - Offline help \/ Chapter 1\",\n \"snippet\": \"Lorem ipsum dolor sit amet...\",\n \"body\": \"Chapter 1. Lorem ipsum dolor sit amet, consetetur sadipscing elitr,\n sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam \n erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. \n Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor \n sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam \n nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam \n voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita \n kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet\"\n },\n {\n \"title\": \"Chapter 2\",\n \"url\": \"3rd_chapter2.html\",\n \"breadcrumbs\": \"3rdParty - Offline help \/ Chapter 2\",\n \"snippet\": \"Lorem ipsum dolor sit amet...\",\n \"body\": \"Chapter 2. Lorem ipsum dolor sit amet, consetetur sadipscing elitr,\n sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam \n erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. \n Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor \n sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam \n nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam \n voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita \n kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet\"\n }\n] " }, 
{ "title" : "自定义 HTML 页面 ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm234730211407826", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 安装 CODESYS 离线帮助 \/ 使用自己的内容扩展 CODESYS 离线帮助 \/ 自定义 HTML 页面 ", 
"snippet" : "其他帮助页面必须采用 HTML 格式。为确保目录、语言切换和搜索字段也显示在新添加的页面上，新页面必须嵌入到 HTML 框架中 模板文件 TemplateOfflineHelp_Simple.html 可以在子目录中找到 C:\\ProgramData\\CODESYS\\Offline Help\\Templates 安装离线帮助后。此模板用作其他 HTML 页面的框架。 需要进行以下修改： 在浏览器占位符中插入选项卡的名称 {{TITLE}} 。这通常是帮助页面的标题。 <title>{{TITLE}}<\/title> 在占位符中插入附加帮助页面的全部内容 {{CONTENT}} 。 <!-- P...", 
"body" : "其他帮助页面必须采用 HTML 格式。为确保目录、语言切换和搜索字段也显示在新添加的页面上，新页面必须嵌入到 HTML 框架中 模板文件 TemplateOfflineHelp_Simple.html 可以在子目录中找到 C:\\ProgramData\\CODESYS\\Offline Help\\Templates 安装离线帮助后。此模板用作其他 HTML 页面的框架。 需要进行以下修改： 在浏览器占位符中插入选项卡的名称 {{TITLE}} 。这通常是帮助页面的标题。 <title>{{TITLE}}<\/title> \n 在占位符中插入附加帮助页面的全部内容 {{CONTENT}} 。 <!-- Place main content here -->\n{{CONTENT}} \n 如果新页面的设计应该是 CODESYS 帮助，然后是现有样式表类 CODESYS 必须使用离线帮助。该模板 TemplateOfflineHelp_Full.html 显示了这些修改的示例。 " }, 
{ "title" : "通过软件包安装帮助页面 ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm234730226436619", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 配置 \/ 安装 CODESYS 离线帮助 \/ 使用自己的内容扩展 CODESYS 离线帮助 \/ 通过软件包安装帮助页面 ", 
"snippet" : "软件包通常用于扩展离线帮助。 示例：将数据存储在包中 中的示例条目 package.manifest 文件 <Component> <General> <Id>1<\/Id> <Name>Offline Help Files<\/Name> <Description>Offline help files for 3rd party product<\/Description> <Selectable>false<\/Selectable> <SelectedByDefault>true<\/SelectedByDefault> <\/General> <Items> <Folder> <TargetFol...", 
"body" : "软件包通常用于扩展离线帮助。 示例：将数据存储在包中 中的示例条目 package.manifest 文件 <Component>\n <General>\n <Id>1<\/Id>\n <Name>Offline Help Files<\/Name>\n <Description>Offline help files for 3rd party product<\/Description>\n <Selectable>false<\/Selectable>\n <SelectedByDefault>true<\/SelectedByDefault>\n <\/General>\n <Items>\n <Folder>\n <TargetFolder>%REPOSITORY_LOCATION%<\/TargetFolder>\n <Path>Offline Help<\/Path>\n <\/Folder>\n <\/Items>\n<\/Component>\n " }, 
{ "title" : "您的第一个 CODESYS 程序 ", 
"url" : "_cds_tutorial_refrigerator_control.html", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "准备 ", 
"url" : "_cds_tutorial_refrigerator_control-1852840.html", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 准备 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "在你开始之前 ", 
"url" : "_cds_tutorial_refrigerator_control-1852840.html#UUID-37040273-01ac-3f6e-080f-c300763700a5_id_ad860c2982c38315c0a8640e0192efdf_id_1acf960483fd46f8c0a8640e01c47574", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 准备 \/ 在你开始之前 ", 
"snippet" : "数据安全： 为了最大限度地降低数据安全漏洞的风险，我们建议采取以下组织和技术措施： 避免从开放网络和互联网访问 PLC 和控制网络。 使用 VPN 进行远程访问。 安装防火墙。 如果您想在 Web 上发布可视化效果，请设置密码以防止未经授权的访问。 使用最新版本的网关服务器和 Web 服务器。 正在安装 CODESYS 安装包括开发系统和 CODESYS 网关和 CODESYS Control Win ，可在 Windows 任务栏中访问其服务。这三个程序是模拟计算机上的控制器所必需的。...", 
"body" : "数据安全： 为了最大限度地降低数据安全漏洞的风险，我们建议采取以下组织和技术措施： 避免从开放网络和互联网访问 PLC 和控制网络。 使用 VPN 进行远程访问。 安装防火墙。 如果您想在 Web 上发布可视化效果，请设置密码以防止未经授权的访问。 使用最新版本的网关服务器和 Web 服务器。 正在安装 CODESYS 安装包括开发系统和 CODESYS 网关和 CODESYS Control Win ，可在 Windows 任务栏中访问其服务。这三个程序是模拟计算机上的控制器所必需的。 " }, 
{ "title" : "你的第一个项目的内容 ", 
"url" : "_cds_tutorial_refrigerator_control-1852840.html#UUID-37040273-01ac-3f6e-080f-c300763700a5_id_ad860c2982c38315c0a8640e0192efdf_id_95ee254f8863349ec0a8640e00ddaa4f", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 准备 \/ 你的第一个项目的内容 ", 
"snippet" : "在本教程中，您将对一个简单的冰箱控制器进行编程。除了您将在此处逐步创建的示例项目外，完成的项目还包含包含操作和诊断的完整可视化。完成的 RefrigeratorControl.projectarchive 项目可以在中找到 CODESYS 中的安装目录 Projects 目录。 与传统冰箱一样，温度由用户通过旋转控制器指定。 冰箱使用传感器确定实际温度。当温度过高时，冰箱以可调的延迟启动压缩机。 压缩机冷却直至达到所需温度，减去 1 度的滞后。滞后旨在防止实际温度在设定温度附近波动过大，这将导致压缩机不断地自行关闭和开启 当门打开时，冰箱内的灯会亮起。当门打开时间过长时，会发出蜂鸣声 如果尽管...", 
"body" : "在本教程中，您将对一个简单的冰箱控制器进行编程。除了您将在此处逐步创建的示例项目外，完成的项目还包含包含操作和诊断的完整可视化。完成的 RefrigeratorControl.projectarchive 项目可以在中找到 CODESYS 中的安装目录 Projects 目录。 与传统冰箱一样，温度由用户通过旋转控制器指定。 冰箱使用传感器确定实际温度。当温度过高时，冰箱以可调的延迟启动压缩机。 压缩机冷却直至达到所需温度，减去 1 度的滞后。滞后旨在防止实际温度在设定温度附近波动过大，这将导致压缩机不断地自行关闭和开启 当门打开时，冰箱内的灯会亮起。当门打开时间过长时，会发出蜂鸣声 如果尽管电机长时间处于活动状态，但压缩机仍未达到设定温度，则蜂鸣器会发出稳定的声音信号。 工程： 冷却活动由应用程序的主程序控制。信号管理由另一个 POU 控制。所需的标准功能块可在 Standard 图书馆。由于在此示例项目中没有连接任何物理温度传感器和物理执行器，因此您还将编写一个程序来模拟温度的升高和降低。这将允许您随后在联机模式下监视冰箱控制器的操作。 供所有 POU 使用的变量需要在全局变量列表中定义。 " }, 
{ "title" : "正在启动 CODESYS Development System ", 
"url" : "_cds_tutorial_refrigerator_control-1852840.html#UUID-37040273-01ac-3f6e-080f-c300763700a5_id_ad860c2982c38315c0a8640e0192efdf_id_17e8e10183fd46f9c0a8640e017b2032", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 准备 \/ 正在启动 CODESYS Development System ", 
"snippet" : "你已经安装了 CODESYS Development System 并用它启动了 CODESYS <current version>” 默认配置文件。开发系统的框架窗口随标准菜单栏打开：尚未打开任何项目。...", 
"body" : "你已经安装了 CODESYS Development System 并用它启动了 CODESYS <current version>” 默认配置文件。开发系统的框架窗口随标准菜单栏打开：尚未打开任何项目。 " }, 
{ "title" : "创建项目并选择 PLC 设备 ", 
"url" : "_cds_tutorial_refrigerator_create.html", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 创建项目并选择 PLC 设备 ", 
"snippet" : "选择命令 文件 → 新项目 . 在窗口中选择 模板 模板 默认项目 . 输入项目的名称和位置，然后单击按钮 行 . 对话 默认项目 出现输入设备类型和主程序的实现语言。 从列表中选择 设备 入口 CODESYS Control Win . 从列表中选择 PLC_PRG 输入 入口 连续功能图 (CFC) 并点击按钮 行 . 该项目将在 CODESYS - 框架窗口打开。 在框架窗口的左侧，在视图中 设备 ，您将看到“设备树”，一个标题为 设备 .先前选择的 PLC 设备使用默认名称 设备 安装。 在对象下 PLC逻辑 已经挂了对象 应用 供您编写的应用程序。 应用 已经包含主程序的对象 PLC...", 
"body" : "选择命令 文件 → 新项目 . 在窗口中选择 模板 模板 默认项目 . 输入项目的名称和位置，然后单击按钮 行 . 对话 默认项目 出现输入设备类型和主程序的实现语言。 从列表中选择 设备 入口 CODESYS Control Win . 从列表中选择 PLC_PRG 输入 入口 连续功能图 (CFC) 并点击按钮 行 . 该项目将在 CODESYS - 框架窗口打开。 在框架窗口的左侧，在视图中 设备 ，您将看到“设备树”，一个标题为 设备 .先前选择的 PLC 设备使用默认名称 设备 安装。 在对象下 PLC逻辑 已经挂了对象 应用 供您编写的应用程序。 应用 已经包含主程序的对象 PLC_PRG 和 图书馆管理员 . 这 图书馆管理员 已经包含库 IoStandard 和 Standard . IoStandard 是 I\/O 配置所必需的。图书馆 Standard 包含由 IEC 61131-3 标准描述的所有功能和功能块。 对象挂在设备树的末尾 任务配置 与 MainTask , 处理 PLC_PRG 控制。以下 任务配置 例如，您可以稍后插入对象以进行可视化。 除了图书馆 IoStandard 和 Standard 您需要此示例项目的库 Util ： 双击对象 图书馆管理员 在设备树中。 库管理器在其编辑器中打开。 单击编辑器标题 添加库 并在全文搜索字段中键入“Util”。 从搜索结果中选择图书馆 Util 并确认选择 行 . 图书馆 Util 已添加到库管理器中，并且库的块可供您用于项目。 " }, 
{ "title" : "在项目中对控制器应用程序进行编程 ", 
"url" : "_cds_tutorial_refrigerator_program.html", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 在项目中对控制器应用程序进行编程 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "声明全局变量 ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_a9dca56f886334a3c0a8640e00c68270", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 在项目中对控制器应用程序进行编程 \/ 声明全局变量 ", 
"snippet" : "首先，声明要在整个应用程序中使用的变量。为此，请在下面创建一个全局变量列表 应用程序 : 选择 Application 输入并点击 添加对象 → 全局变量列表 在上下文菜单中。更改默认名称 GVL 到 Glob_Var 并点击 添加 确认。 这 Glob_Var 对象显示如下 Application 。GVL 编辑器在设备树的右侧打开。 当文本视图打开时，它已经包含关键字 VAR_GLOBAL 和 END_VAR 。对于我们的示例，单击 编辑器右侧栏上的按钮可激活表格视图。 出现一个空行。光标位于 姓名 柱子。 在快捷菜单中，单击 插入 。 打开一个输入字段。同时， 范围 VAR_GLOBAL...", 
"body" : "首先，声明要在整个应用程序中使用的变量。为此，请在下面创建一个全局变量列表 应用程序 : 选择 Application 输入并点击 添加对象 → 全局变量列表 在上下文菜单中。更改默认名称 GVL 到 Glob_Var 并点击 添加 确认。 这 Glob_Var 对象显示如下 Application 。GVL 编辑器在设备树的右侧打开。 当文本视图打开时，它已经包含关键字 VAR_GLOBAL 和 END_VAR 。对于我们的示例，单击 编辑器右侧栏上的按钮可激活表格视图。 出现一个空行。光标位于 姓名 柱子。 在快捷菜单中，单击 插入 。 打开一个输入字段。同时， 范围 VAR_GLOBAL 还有 数据类型 BOOL 会自动输入到该行中。 指定 rTempActual 在 姓名 场地。 双击 数据类型 柱子。 现在可以编辑该字段，并且 按钮显示。 点击 按钮，然后选择 输入助手 。 这个 输入助手 对话框打开。 选择数据类型 REAL 并点击 好的 。 在中输入一个数值 初始化 列（示例： 8.0 ）。 以相同的方式声明以下变量： 姓名 数据类型 初始化 评论 rTempActual REAL 8.0 实际温度 rTempSet REAL 8.0 设定温度 xDoorOpen BOOL FALSE 门的状态 timAlarmThreshold TIME T#30S 压缩机运行后发出信号的时间 timDoorOpenThreshold TIME T#10S 开门后会发出信号的时间 xCompressor BOOL FALSE 控制信号 xSignal BOOL FALSE 控制信号 xLamp BOOL FALSE 状态消息 " }, 
{ "title" : "在 CFC 编辑器中创建冷却控制的主程序 ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_d0ec117487fb0b44c0a8640e01a8d70a", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 在项目中对控制器应用程序进行编程 \/ 在 CFC 编辑器中创建冷却控制的主程序 ", 
"snippet" : "现在，您将在 main 中描述应用程序的主要功能 PLC_PRG POU，默认情况下创建。当实际温度高于设定温度加上滞后时，压缩机被激活并冷却。当实际温度低于设定温度减去滞后时，压缩机关闭 要使用 CFC 实现语言描述此功能，请执行以下步骤： 在设备树中，双击 PLC_PRG 。 CFC 编辑器在中打开 PLC_PRG 选项卡。声明编辑器以文本或表格形式出现在图形编辑器区域的上方。这个 工具箱 视图在右边。 在 工具箱 查看，选择 输入 元素并将其拖动到下方的 CFC 编辑器中 PLC_PRG 选项卡。 无名条目 ??? 已插入。 在 CFC 编辑器中，单击 ??? 在输入处，然后单击 打开输...", 
"body" : "现在，您将在 main 中描述应用程序的主要功能 PLC_PRG POU，默认情况下创建。当实际温度高于设定温度加上滞后时，压缩机被激活并冷却。当实际温度低于设定温度减去滞后时，压缩机关闭 要使用 CFC 实现语言描述此功能，请执行以下步骤： 在设备树中，双击 PLC_PRG 。 CFC 编辑器在中打开 PLC_PRG 选项卡。声明编辑器以文本或表格形式出现在图形编辑器区域的上方。这个 工具箱 视图在右边。 在 工具箱 查看，选择 输入 元素并将其拖动到下方的 CFC 编辑器中 PLC_PRG 选项卡。 无名条目 ??? 已插入。 在 CFC 编辑器中，单击 ??? 在输入处，然后单击 打开输入助手。 变量 类别，选择 rTempActual 变量在下面 应用程序 → Glob_Var 。这是引用全局变量的 rTempActual 这里。 输入名称是 Glob_Var.rTempActual 。 与步骤 3 一样，使用全局变量的名称创建另一个输入 Glob_Var.rTempSet 。 创建另一个输入，然后单击 ??? 然后用名字替换它们 rHysteresis 。 因为这不是已知变量的名称， 自动申报 对话框打开。该名称已在对话框中使用。 在 自动申报 对话框，指定 类型 作为 REAL 和 初始化 作为 1 。点击 好吧 按钮。 变量 rHysteresis 出现在声明编辑器中。 在 工具箱 查看，选择 阻止 元素并将其拖动到下方的 CFC 编辑器中 PLC_PRG 选项卡。 POU 在 CFC 编辑器中打开。 替换 ??? 和 ADD 。 POU 会添加与其连接的所有输入。 连接 Glob_Var.rTempSet 输入到 ADD POU。为此，请单击输入的输出引脚并将其拖动到输入引脚的上方 ADD POU。 以同样的方式，连接输入 rHysteresis 使用较低的输入值 ADD POU。 两个输入 rHysteresis 和 Glob_Var.rTempSet 现在添加者 ADD 。 要在编辑器中移动元素，请单击元素中的空白区域或单击框架，这样该元素即被选中（红色边框，红色突出显示）。将元素拖动到所需位置。 在右边创建另一个 POU ADD POU。它的目的是比较 Glob_Var.rTempActual 总和为 Glob_Var.rTempSet 和 rHysteresis 。分配 GT 函数（大于）到 POU。 这个 GT POU 的工作原理如下： IF (upper input > lower input) THEN output := TRUE; 连接输入 Glob_Var.rTempActual 到输入的上方 GT POU。 连接输出 ADD POU 到较低的输入端 GT POU。 现在使用方块元素在右边创建一个功能块 GT POU 根据输入条件启动和停止压缩机（设置 — 重置）。指定名字 SR 在 ??? 领域。按回车键关闭 POU 上方的打开输入字段 SR_0 ）。 这个 自动申报 对话框打开。 用名称声明变量 SR_0 和数据类型 SR 。点击 好吧 按钮。 这个 SR POU 来自 Standard 库已实例化。 SR 用于定义 THEN 在 GT POU 的输出处。输入 SET1 和 RESET 出现。 连接右侧的输出引脚 GT POU 到 SET1 的输入 SR_0 POU。 SR 可以从中设置布尔变量 FALSE 到 TRUE 然后又回来了。当条件处于输入 SET1 满意，布尔变量设置为 TRUE 。当条件为时，变量将再次重置 RESET 很满意。我们示例中的布尔（全局）变量是 Glob_Var.xCompressor 。 创建一个 输出 元素并将其分配给全局变量 Glob_Var.xCompressor 。在两者之间拖动一条连接线 Glob_Var.xCompressor 和输出引脚 Q1 的 SR 。 现在指定压缩机应再次关闭的条件（在本例中， RESET SR POU 的输入会得到 TRUE 信号）。为此，请制定与上述条件相反的条件。 SUB （减法）和 LT （少于）用于执行此操作的 POU。 结果是以下 CFC 图表： " }, 
{ "title" : "在梯形图编辑器中创建用于信号管理的 POU ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_43984f578f71eb8bc0a8640e0046480b", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 在项目中对控制器应用程序进行编程 \/ 在梯形图编辑器中创建用于信号管理的 POU ", 
"snippet" : "在另一个 POU 中，您现在将实现警报蜂鸣器以及开启和关闭灯泡的信号管理。梯形图 (LD) 实现语言适合于此。 在自己的网络中处理以下每个信号： 当压缩机因温度过高而运行时间过长时，会发出连续的声音信号。 当门打开时间过长时，会发出间歇性信号。 只要门开着，灯就会亮。 在设备树中，在 Application 对象，创建一个类型的 POU 对象 程序 使用 梯子（LD2） 实现语言。 将程序命名为 Signals 。 这个 Signals 程序列在设备树旁边 PLC_PRG 。梯形图编辑器将在中打开 Signals 选项卡。声明编辑器出现在上部， 工具箱 向右看。梯形图包含一个空网络。 网络中创...", 
"body" : "在另一个 POU 中，您现在将实现警报蜂鸣器以及开启和关闭灯泡的信号管理。梯形图 (LD) 实现语言适合于此。 在自己的网络中处理以下每个信号： 当压缩机因温度过高而运行时间过长时，会发出连续的声音信号。 当门打开时间过长时，会发出间歇性信号。 只要门开着，灯就会亮。 在设备树中，在 Application 对象，创建一个类型的 POU 对象 程序 使用 梯子（LD2） 实现语言。 将程序命名为 Signals 。 这个 Signals 程序列在设备树旁边 PLC_PRG 。梯形图编辑器将在中打开 Signals 选项卡。声明编辑器出现在上部， 工具箱 向右看。梯形图包含一个空网络。 网络中创建程序，这样，当压缩机运行时间过长而未达到指定温度时，就会发出声音信号。为此，请插入 TON 接下来的步骤中计时 POU。它将布尔信号切换为 TRUE 在指定的时间之后。 在 工具箱 查看，拖动 阻止 元素并将其拖放到空网络中到可用的插入位置。 该模块显示为一个包含输入和输出的方框。 双击三个问号 ( ??? ) 在区块中，然后单击 线条编辑器中的符号。 这个 输入助手 对话框打开。 在 输入助手 对话框，在 标准功能块 类别，在 标准 库，选择 TON 计时器 然后点击 好吧 。 现在在块的行编辑器中，它显示了功能块的名称 TON ，按 Enter 键。 这个 TON POU 与其输入和输出一起显示。 要删除 EN 输入和 ENO 输出，选择方块并单击 EN\/ENO → EN 在上下文菜单中。 现在这个方块只有 IN 和 PT 输入和 Q 和 ET 输出。 双击块正上方的三个问号[???]，输入 TON_0 作为实例名称，然后按 Enter 键。 您已经确认了实例名称。这个 自动申报 对话框打开。 点击 好吧 确认对话框。 现在插入 TON POU 实例化的名称 TON_0 。 对模块进行编程，使其在压缩机开始运行后立即激活。首先拖动 Contact 来自的梯子元素 工具箱 前面的视图 IN 区块的输入。双击三个问号，然后在行编辑器中单击该图标 ( ）。在输入助手中，现在选择已经声明的全局变量 x压缩机 然后点击 好吧 。 变量名 Glob_Var.xCompressor 显示在联系人上方。 当你开始在输入位置键入变量名时，你将自动获得所有变量的列表，其名称以键入的字符开头，此时可以使用。此帮助是中的默认设置 CODESYS 智能编码的选项。 插入要激活的信号。为此，请将 线圈 从 工具箱 看法， 梯子 类别， Q 输出 TON 块。指定名称 Glob_Var.xSignal 对于线圈。 定义从 POU 激活开始的时间段 TON_0 直到信号响起。此定义通过变量进行 Glob_Var.timAlarmThreshold ，为此目的，您可以在输入处插入 PT 的 TON_0 。为此，单击输入引脚左侧的细边框并输入变量名称。 按回车键。 这个 自动申报 对话框打开。 点击 好吧 确认对话框。 新声明的变量显示在声明部分。 选择 TON POU 并点击 移除未使用的引脚 在上下文菜单中。 未使用的输出 ET 已移除。 在 LD 的第二个网络中，进行编程，使门打开时间过长时会间歇性地发出信号。 用鼠标拖动 网络 元素来自 工具箱 查看网络 1 下方的插入点。 带有该号码的空网络 2 出现。 就像在第一个网络中一样，实现 TON POU 用于按时间控制激活信号。这次是由全局变量触发的 Glob_Var.xDoorOpen 在输入处 IN 。在输入处 PT ，添加全局变量 Glob_Var.timDoorOpenThreshold 。 来自 Util 库，添加一个 BLINK 输出端的 POU Q 的 TON 在此网络中使用 POU 并使用名称对其进行实例化 Blink_0 。 这个 BLINK_0 POU 对信号转发进行计时 Q 因此 Glob_Var.xSignal 。 首先，拖动两个 联系我们 元素来自 工具箱 查看 OUT U 的输出。分配变量 TON_1.Q 输出后直接与联系人联系 Q 和全局变量 Glob_Var.xDoorOpen 致第二个联系人。 插入 线圈 两个联系人之后的元素并分配全局变量 Glob_Var.xSignal 对它来说。 声明局部变量 timSignalTime : TIME := T#1S; 然后在输入处插入这个变量 TIMELOW 和 TIMEHIGH 。循环时间为 1 秒 TRUE 并且 1 秒为 FALSE 。 选择 TON POU 并点击 移除未使用的引脚 在上下文菜单中。 未使用的输出 ET 已被移除。 在第三个网络中，进行编程，使灯在门打开时一直亮着。添加一个附加网络和一个触点。分配变量 GlobVar.xDoorOpen 致聯絡人。 插入的触点直接通向线圈。在触点右侧添加线圈并分配全局变量 Glob_Var.xLamp 到线圈上。 CODESYS 接一个地处理 LD 的网络。现在，在网络 1 的末尾安装一个跳转到网络 3 的程序，以确保只执行网络 1 或仅执行网络 2： 当您将鼠标指针悬停在网络左上角第三行时，信息 <在此处插入跳转> 出现。双击此位置并输入 门打开了： 作为行编辑器中的跳转标签。 选择网络 1. 从 工具箱 看法， 梯形图 类别，拖动 跳 元素到插入位置，前面有一个三角形标记 Glob_Var.xSignal 线圈。 出现跳跃元素。跳转目的地仍指定为 ??? 。 双击三个问号 [???]，然后单击行编辑器中的图标 ( ）。在 输入助手 对话框中，选择 DoorIsOpen 从可能的标签标识符中单击 好的 确认。 网络 3 的标签已实现。 现在 LD 程序如下所示： " }, 
{ "title" : "在主程序中调用 “Signals” 程序 ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_8af1792b87fb0b44c0a8640e0066c163", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 在项目中对控制器应用程序进行编程 \/ 在主程序中调用 “Signals” 程序 ", 
"snippet" : "在我们的程序示例中，主程序 PLC_PRG 应该打电话给 Signals 信号处理程序。 在设备树中，双击 PLC_PRG 。 这个 PLC_PRG 程序在编辑器中打开。 在 工具箱 查看，拖动 阻止 向编辑器添加元素 PLC_PRG 。 双击三个问号 [???]然后点击 线条编辑器中的符号。 输入助手 对话框，在 POU\/程序和函数调用 类别，选择 Signals 编程，然后单击 好吧 进行确认。...", 
"body" : "在我们的程序示例中，主程序 PLC_PRG 应该打电话给 Signals 信号处理程序。 在设备树中，双击 PLC_PRG 。 这个 PLC_PRG 程序在编辑器中打开。 在 工具箱 查看，拖动 阻止 向编辑器添加元素 PLC_PRG 。 双击三个问号 [???]然后点击 线条编辑器中的符号。 输入助手 对话框，在 POU\/程序和函数调用 类别，选择 Signals 编程，然后单击 好吧 进行确认。 " }, 
{ "title" : "为模拟创建 ST POU ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_9629e45ee440acc7c0a8640e0130c013", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 在项目中对控制器应用程序进行编程 \/ 为模拟创建 ST POU ", 
"snippet" : "由于此示例项目中的应用程序未链接到物理传感器和执行器，因此您还需要编写一个程序来模拟温度的升高和降低。这将允许您随后在联机模式下监视冰箱控制器的操作。 您使用结构化文本创建仿真程序。 该程序会增加温度，直到主程序启动 PLC_PRG 确定已超过设定温度。然后程序激活压缩器。然后，仿真程序降低温度，直到主程序再次禁用压缩机 在设备树中，右键单击 应用程序 对象，然后添加一个类型为 POU 的对象 程式 和 结构化文本 (ST) 实现语言。将 POU 命名为 Simulation 。 在 ST 编辑器中实现以下代码： 声明部分： PROGRAM Simulation VAR TON_1: TON;...", 
"body" : "由于此示例项目中的应用程序未链接到物理传感器和执行器，因此您还需要编写一个程序来模拟温度的升高和降低。这将允许您随后在联机模式下监视冰箱控制器的操作。 您使用结构化文本创建仿真程序。 该程序会增加温度，直到主程序启动 PLC_PRG 确定已超过设定温度。然后程序激活压缩器。然后，仿真程序降低温度，直到主程序再次禁用压缩机 在设备树中，右键单击 应用程序 对象，然后添加一个类型为 POU 的对象 程式 和 结构化文本 (ST) 实现语言。将 POU 命名为 Simulation 。 在 ST 编辑器中实现以下代码： 声明部分： PROGRAM Simulation\nVAR\n TON_1: TON; \/\/The temperature is decreased on a time delay, when the comepressor has been activated\n P_Cooling: TIME:=T#500MS;\n xReduceTemp: BOOL; \/\/Signal for dereasing the temperature\n TON_2: TON; \/\/The temperature is increased on a time delay\n P_Environment: TIME:=T#2S; \/\/Delay time when the door is closed\n P_EnvironmentDoorOpen: TIME:=T#1S; \/\/Delay time when the door is open\n xRaiseTemp: BOOL; \/\/Signal for increasing the temperature\n timTemp: TIME; \/\/Delay time\n iCounter: INT;\nEND_VAR\n\n 实现部分： iCounter := iCounter + 1; \/\/ No function, just for demonstration purposes.\n\n\/\/ After the compressor has been activated due to TempActual being too high, the temperature decreases.\n\/\/ The temperature is decremented by 0.1°C per cycle after a delay of P_Cooling\nIF Glob_VAR.xCompressor THEN\n TON_1(IN:= Glob_Var.xCompressor, PT:= P_Cooling, Q=>xReduceTemp);\n IF xReduceTemp THEN\n Glob_Var.rTempActual := Glob_Var.rTempActual-0.1;\n TON_1(IN:=FALSE);\n END_IF\nEND_IF\n\n\/\/If the door is open, the warming occurs faster; SEL selects P_EnvironmentDoorOpen\ntimTemp:=SEL(Glob_Var.xDoorOpen, P_Environment, P_EnvironmentDoorOpen);\n\n\/\/If the compressor is not in operation, then the cooling chamber becomes warmer.\n\/\/The temperature is incremented by 0.1°C per cycle after a delay of tTemp\nTON_2(IN:= TRUE, PT:= timTemp, Q=>xRaiseTemp);\nIF xRaiseTemp THEN\n Glob_Var.rTempActual := Glob_Var.rTempActual + 0.1;\n TON_2(IN:=FALSE);\nEND_IF 我们建议您使用可视化来方便操作和监控整个控制器程序。使用创建的可视化效果 CODESYS 可视化安装在本教程的已完成示例项目中，该项目随附于 CODESYS 标准安装 ( Projects 目录）。你可以将这个项目下载到控制器并启动它，看看它与可视化协同工作。启动时， Live_Visu 首先是冰箱的表示，它无需输入任何数据即可重现仿真程序的操作。但是，您可以通过单击开\/关开关来打开和关闭门。可以通过旋转控制的指针来调整默认温度。在本教程中，我们将不介绍可视化的创建。的帮助中计划了相应的教程 CODESYS 可视化。 " }, 
{ "title" : "定义要在任务配置中执行的程序 ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_d442fec087abb4e8c0a8640e01bf3087", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 在项目中对控制器应用程序进行编程 \/ 定义要在任务配置中执行的程序 ", 
"snippet" : "默认任务配置包含对主程序的调用 PLC_PRG 。对于我们的示例项目，您还需要添加调用 Simulation 程序。 在设备树中，拖动 Simulation 进入 MainTask 下方 任务配置 。 这个 Simulation 程序已插入任务配置。 要查看任务配置，请双击 MainTask 打开编辑器的入口。 在编辑器下部的表格中，您可以看到任务调用的 POU： PLC_PRG （默认输入）和 Simulation 。任务的呼叫类型是 循环的 间隔为 20 毫秒。在联机模式下，任务将在每个周期执行两个 POU 一次...", 
"body" : "默认任务配置包含对主程序的调用 PLC_PRG 。对于我们的示例项目，您还需要添加调用 Simulation 程序。 在设备树中，拖动 Simulation 进入 MainTask 下方 任务配置 。 这个 Simulation 程序已插入任务配置。 要查看任务配置，请双击 MainTask 打开编辑器的入口。 在编辑器下部的表格中，您可以看到任务调用的 POU： PLC_PRG （默认输入）和 Simulation 。任务的呼叫类型是 循环的 间隔为 20 毫秒。在联机模式下，任务将在每个周期执行两个 POU 一次 " }, 
{ "title" : "定义与 PLC 通信的 “活动应用程序” ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_6e4db14b8d0ab976c0a8640e01f0c733", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 在项目中对控制器应用程序进行编程 \/ 定义与 PLC 通信的 “活动应用程序” ", 
"snippet" : "的名字 Application 以粗体显示在 设备 观点。这意味着此应用程序被设置为 “活动应用程序”。然后，与控制器的通信指的是此应用程序。 当项目中只有一个应用程序时，它会自动成为活动应用程序。如果您的应用程序尚未激活，请按如下方式将其激活： 在的上下文菜单中 Application ，点击 设置活动应用程序 。 应用程序 现在以粗体显示在 设备 观点。...", 
"body" : "的名字 Application 以粗体显示在 设备 观点。这意味着此应用程序被设置为 “活动应用程序”。然后，与控制器的通信指的是此应用程序。 当项目中只有一个应用程序时，它会自动成为活动应用程序。如果您的应用程序尚未激活，请按如下方式将其激活： 在的上下文菜单中 Application ，点击 设置活动应用程序 。 应用程序 现在以粗体显示在 设备 观点。 " }, 
{ "title" : "调试应用程序 ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_section-idm43264932442274", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 在项目中对控制器应用程序进行编程 \/ 调试应用程序 ", 
"snippet" : "当你输入代码时， CODESYS 通过在相关文本下方使用红色波浪下划线立即提醒您出现语法错误。检查结果也显示在消息视图中。如有必要，单击 查看 → 消息 打开消息视图。消息显示在 预编译 消息类别。您可以选择一条消息，然后按 F4 键跳到代码中的相应点。将应用程序下载到控制器后，将对应用程序进行更多测试。 之后，只能将无错误的应用程序下载到控制器。...", 
"body" : "当你输入代码时， CODESYS 通过在相关文本下方使用红色波浪下划线立即提醒您出现语法错误。检查结果也显示在消息视图中。如有必要，单击 查看 → 消息 打开消息视图。消息显示在 预编译 消息类别。您可以选择一条消息，然后按 F4 键跳到代码中的相应点。将应用程序下载到控制器后，将对应用程序进行更多测试。 之后，只能将无错误的应用程序下载到控制器。 " }, 
{ "title" : "建立与 PLC 的连接 ", 
"url" : "_cds_tutorial_refrigerator_connect.html", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 建立与 PLC 的连接 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "启动网关服务器和 PLC ", 
"url" : "_cds_tutorial_refrigerator_connect.html#UUID-959c9499-66d7-f48b-def1-3422e79004c0_id_ad860c2982c38315c0a8640e0192efdf_id_98135acc87abb4e9c0a8640e0103f1cb", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 建立与 PLC 的连接 \/ 启动网关服务器和 PLC ", 
"snippet" : "检查访问选项以控制 在任何情况下都不得从 Internet 或不可信网络访问控件！尤其是控制器的编程端口在任何情况下都不能不受 Internet 保护（通常是 UDP 端口 1740..1743 和 TCP 端口 1217 + 11740 或控制器特定端口）！但是，如果必须启用从 Internet 的访问，则必须选择一种安全的方法来连接到控制器（例如 VPN）。 有关更多信息，另请参阅： 设备用户管理的处理启动网关服务器： 默认情况下，与 CODESYS 还有程序 GatewaySysTray 已安装。您可以使用此程序与网关服务器进行通信。网关服务器在系统启动时作为服务自动启动。检查Windo...", 
"body" : "检查访问选项以控制 在任何情况下都不得从 Internet 或不可信网络访问控件！尤其是控制器的编程端口在任何情况下都不能不受 Internet 保护（通常是 UDP 端口 1740..1743 和 TCP 端口 1217 + 11740 或控制器特定端口）！但是，如果必须启用从 Internet 的访问，则必须选择一种安全的方法来连接到控制器（例如 VPN）。 有关更多信息，另请参阅： 设备用户管理的处理启动网关服务器： 默认情况下，与 CODESYS 还有程序 GatewaySysTray 已安装。您可以使用此程序与网关服务器进行通信。网关服务器在系统启动时作为服务自动启动。检查Windows任务栏是否有程序图标 包含。网关服务器未运行时，图标如下所示： .在这种情况下，您可以通过单击符号和命令打开网关菜单 启动网关 选择。 启动 PLC： 默认情况下，与 CODESYS 还有程序 CODESYS ControlSysTray 已安装。通过这个程序，您可以使用 CODESYS 通信控制服务。为了防止未经授权的访问， CODESYS V3.5 SP2 控制服务不再在系统启动时自动启动。按如下方式启动 PLC： 用鼠标单击打开 Windows 任务栏中的 PLC 菜单并选择命令 启动PLC . PLC 运行时，图标变为 .启动时出现的对话框通知您启动的 PLC 允许编程访问。请务必遵守上述安全说明！ " }, 
{ "title" : "对于第一个通信配置：添加网关 ", 
"url" : "_cds_tutorial_refrigerator_connect.html#UUID-959c9499-66d7-f48b-def1-3422e79004c0_id_ad860c2982c38315c0a8640e0192efdf_id_0617e29387abb4ebc0a8640e01437431", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 建立与 PLC 的连接 \/ 对于第一个通信配置：添加网关 ", 
"snippet" : "双击条目 Device ( CODESYS Control Win ) 在视图中 设备 . 在记事本中 Device 选项卡出现 沟通 . 如果这是您的第一个通信配置 CODESYS V3，您现在需要定义本地网关服务器。如果您之前定义了网关服务器，它将出现在选项卡上 沟通 显示。在这种情况下，您现在可以与 指定通信通道 继续前进。 网关服务器将使用 CODESYS -提供安装。 选择命令 网关 → 添加新网关 . 对话 网关 出现。 在输入字段中输入 姓 输入网关的符号名称。 从列表中选择 司机 入口 TCP\/IP 出去。 双击该行的右列 IP地址 并在输入字段中输入 localhost 一。...", 
"body" : "双击条目 Device ( CODESYS Control Win ) 在视图中 设备 . 在记事本中 Device 选项卡出现 沟通 . 如果这是您的第一个通信配置 CODESYS V3，您现在需要定义本地网关服务器。如果您之前定义了网关服务器，它将出现在选项卡上 沟通 显示。在这种情况下，您现在可以与 指定通信通道 继续前进。 网关服务器将使用 CODESYS -提供安装。 选择命令 网关 → 添加新网关 . 对话 网关 出现。 在输入字段中输入 姓 输入网关的符号名称。 从列表中选择 司机 入口 TCP\/IP 出去。 双击该行的右列 IP地址 并在输入字段中输入 localhost 一。 点击按钮 行 . 网关将出现在选项卡中 沟通 (1) 设备编辑器。如果网关运行正常，网关图形上会出现一个绿色的实心圆圈： " }, 
{ "title" : "指定通信通道 ", 
"url" : "_cds_tutorial_refrigerator_connect.html#UUID-959c9499-66d7-f48b-def1-3422e79004c0_id_ad860c2982c38315c0a8640e0192efdf_id_50186f59d1ccca7dc0a8640e0152059e", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ 建立与 PLC 的连接 \/ 指定通信通道 ", 
"snippet" : "现在定义设备的通信通道，然后通过设置的网关使用。为此，请打开选项卡 沟通 设备编辑器通过双击条目 设备 在设备树中。 点击按钮 浏览网络 在本地网络中搜索所有可用设备。 对话 选择设备 (1) 将显示您可以建立连接的所有设备的列表。 在树中选择具有您计算机名称的条目。 点击 行 . 该频道现在处于活动状态并位于选项卡上 沟通 相关信息出现在设备图形下方。 选择所需的设备并单击 行 . 您将收到一个消息框，其中包含有关设备必须进行用户管理但尚未激活的信息。系统将询问您是否要立即激活用户管理。您将被告知，在这种情况下，您必须创建一个新的管理员用户，然后以该用户身份登录。 关闭查询 是的 . 这 添...", 
"body" : "现在定义设备的通信通道，然后通过设置的网关使用。为此，请打开选项卡 沟通 设备编辑器通过双击条目 设备 在设备树中。 点击按钮 浏览网络 在本地网络中搜索所有可用设备。 对话 选择设备 (1) 将显示您可以建立连接的所有设备的列表。 在树中选择具有您计算机名称的条目。 点击 行 . 该频道现在处于活动状态并位于选项卡上 沟通 相关信息出现在设备图形下方。 选择所需的设备并单击 行 . 您将收到一个消息框，其中包含有关设备必须进行用户管理但尚未激活的信息。系统将询问您是否要立即激活用户管理。您将被告知，在这种情况下，您必须创建一个新的管理员用户，然后以该用户身份登录。 关闭查询 是的 . 这 添加设备用户 对话框打开以创建初始设备管理员。 定义设备管理员的凭据： 姓 和 密码 .激活选项 密码可由用户更改 .加入我们 行 离开。 对话 设备用户登录 打开。 输入在上一步中定义的设备管理员凭据。 设置到控制器的连接路径。 现在所有的通信动作都完全指向这个通道。当您在项目中有多个沟通渠道时，请记住这一点。 " }, 
{ "title" : "PLC上的应用 ", 
"url" : "_cds_tutorial_refrigerator_app.html", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ PLC上的应用 ", 
"snippet" : "在运行时运行单个周期 要求：应用程序已加载到控制器上并正在运行。 与上面的步骤一样，再次观察线 iCounter := iCounter + 1; 在节目中 Simulation . 按 控制 + F5 或选择命令 调试 → 单周期 运行一个循环。 处理运行 1 个周期并在断点处再次停止。 iCounter 增加了 1。 多按几次 控制 + F5 查看单个周期。然后再按 F5 . 程序再次运行，没有停止，也没有强制值。变量 temp 又有价值了 1s .再次出现在状态栏中 ....", 
"body" : "在运行时运行单个周期 要求：应用程序已加载到控制器上并正在运行。 与上面的步骤一样，再次观察线 iCounter := iCounter + 1; 在节目中 Simulation . 按 控制 + F5 或选择命令 调试 → 单周期 运行一个循环。 处理运行 1 个周期并在断点处再次停止。 iCounter 增加了 1。 多按几次 控制 + F5 查看单个周期。然后再按 F5 . 程序再次运行，没有停止，也没有强制值。变量 temp 又有价值了 1s .再次出现在状态栏中 . " }, 
{ "title" : "将应用程序加载到 PLC ", 
"url" : "_cds_tutorial_refrigerator_app.html#UUID-2ce2cf20-ee9b-44c0-e254-1b4cf5ee6953_id_ad860c2982c38315c0a8640e0192efdf_id_ac03476587abb4eec0a8640e0119358c", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ PLC上的应用 \/ 将应用程序加载到 PLC ", 
"snippet" : "要求：应用程序编译时没有错误。 有关更多信息，请参阅： 检查应用程序是否有错误 选择命令 在线 → 登录 . 将打开一个对话框提示，询问是否应将应用程序下载到控制器。 点击 是的 . 应用程序被加载到控制器上。窗口中控制器和应用程序的条目 设备 以绿色突出显示。物体背后 应用 站立 Stop .控制器的当前状态出现在任务栏中： ....", 
"body" : "要求：应用程序编译时没有错误。 有关更多信息，请参阅： 检查应用程序是否有错误 选择命令 在线 → 登录 . 将打开一个对话框提示，询问是否应将应用程序下载到控制器。 点击 是的 . 应用程序被加载到控制器上。窗口中控制器和应用程序的条目 设备 以绿色突出显示。物体背后 应用 站立 Stop .控制器的当前状态出现在任务栏中： . " }, 
{ "title" : "启动应用程序 ", 
"url" : "_cds_tutorial_refrigerator_app.html#UUID-2ce2cf20-ee9b-44c0-e254-1b4cf5ee6953_id_ad860c2982c38315c0a8640e0192efdf_id_9709c503975dfa4dc0a8640e0120e452", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ PLC上的应用 \/ 启动应用程序 ", 
"snippet" : "如果到目前为止您已完全按照教程进行操作，您现在可以启动应用程序 应用 在 PLC 上 设备 （ CODESYS Control Win ） 利用。 在窗口中单击鼠标右键 设备 在物体上 应用 并在上下文菜单中选择命令 开始 出去。 程序正在运行。窗口中控制器和应用程序的条目 设备 以绿色突出显示。物体背后 应用 站立 run .控制器的当前状态出现在任务栏中： ....", 
"body" : "如果到目前为止您已完全按照教程进行操作，您现在可以启动应用程序 应用 在 PLC 上 设备 （ CODESYS Control Win ） 利用。 在窗口中单击鼠标右键 设备 在物体上 应用 并在上下文菜单中选择命令 开始 出去。 程序正在运行。窗口中控制器和应用程序的条目 设备 以绿色突出显示。物体背后 应用 站立 run .控制器的当前状态出现在任务栏中： . " }, 
{ "title" : "运行时监控和一次性写入变量值 ", 
"url" : "_cds_tutorial_refrigerator_app.html#UUID-2ce2cf20-ee9b-44c0-e254-1b4cf5ee6953_id_ad860c2982c38315c0a8640e0192efdf_id_2af116343d0211e59bd5bc6c9609cd9d", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ PLC上的应用 \/ 运行时监控和一次性写入变量值 ", 
"snippet" : "在下文中您将查看各个程序块中变量值的“监控”并暂停 CODESYS 一次在控制器上输出一个特定的变量值。 您可以在块编辑器的在线视图或监控列表中查看应用程序变量的实际值。在此处的示例中，我们将自己限制为在块编辑器中进行监视。 要求：应用程序正在控制器上运行。 双击打开对象 PLC_PRG , Signals , Simulation 和 Glob_Var 设备树中编辑器的在线视图。 在每个视图的声明部分出现在表中的表达式列中 值得 (3) 控制器上变量 (1) 的实际值（见图）。 实现部分的监控取决于实现语言：在非布尔变量的情况下，值总是在标识符右侧的矩形字段中。在 ST 编辑器中，这也适用于...", 
"body" : "在下文中您将查看各个程序块中变量值的“监控”并暂停 CODESYS 一次在控制器上输出一个特定的变量值。 您可以在块编辑器的在线视图或监控列表中查看应用程序变量的实际值。在此处的示例中，我们将自己限制为在块编辑器中进行监视。 要求：应用程序正在控制器上运行。 双击打开对象 PLC_PRG , Signals , Simulation 和 Glob_Var 设备树中编辑器的在线视图。 在每个视图的声明部分出现在表中的表达式列中 值得 (3) 控制器上变量 (1) 的实际值（见图）。 实现部分的监控取决于实现语言：在非布尔变量的情况下，值总是在标识符右侧的矩形字段中。在 ST 编辑器中，这也适用于布尔变量。我们将此显示称为“在线监控”。在图形编辑器中，布尔变量的值由输出连接线的颜色表示：黑色表示 FALSE , 蓝色为 TRUE ： 考虑改变各个构建块中的变量值。例如，参见 GVL Glob_Var ，模拟程序的处理如何改变 rTempActual 和 xCompressor 改变。 控制器上标签值的一次性设置： 把重点放在GVL的在线视图上 Glob_Var . 要指定新的目标值，请双击打印输出 rTempSet 进入专栏 准备值 (2)。 将打开一个输入字段。 穿值 9 并离开输入字段。 要表示门已打开，请单击表达式 xDoorOpen 1x 在现场 准备值 .价值 TRUE 被输入。再点击 3 次可以看到你有准备好的值 FALSE ，然后返回空白，然后返回 TRUE 可以切换。 到准备值 TRUE 要向变量写入一次，请按 控制 + F7 . 两个值分别在列中 值得 (3) 转让。变量 xDoorOpen 现在不再改变它的值，目标温度现在是 9 度。变量 timTemp 值的变化 1s ，因为冰箱门现在“打开”并且加热完成 Simulation 比以前更快（ 2s ) 应该发生。 " }, 
{ "title" : "在运行时设置断点和单步执行 ", 
"url" : "_cds_tutorial_refrigerator_app.html#UUID-2ce2cf20-ee9b-44c0-e254-1b4cf5ee6953_id_ad860c2982c38315c0a8640e0192efdf_id_79bd3dd53f6511e58d96f7ece25b7bb8", 
"breadcrumbs" : "CODESYS Essentials \/ 您的第一个 CODESYS 程序 \/ PLC上的应用 \/ 在运行时设置断点和单步执行 ", 
"snippet" : "“调试”：要检查某些代码点的变量值以进行故障排除。为此，您可以为处理定义断点并启动指令的逐步执行。 要求：应用程序已加载到控制器上并正在运行。 双击打开 Simulation 编辑器中的程序。 将光标放在代码行 iCounter := iCoutner + 1; 并按下 F9 符号出现在代码行的前面 .它表示在该行设置了一个断点。图标立即变为 .黄色箭头始终指向要处理的下一条指令。出现在任务栏中 代替 . 查看变量的值 iCounter 在线监控或程序的声明部分 Simulation . 变量值不再改变。处理在断点处停止。 按 F5 ，它再次开始处理。 程序在 1 个循环后再次在断点处停止。 ...", 
"body" : "“调试”：要检查某些代码点的变量值以进行故障排除。为此，您可以为处理定义断点并启动指令的逐步执行。 要求：应用程序已加载到控制器上并正在运行。 双击打开 Simulation 编辑器中的程序。 将光标放在代码行 iCounter := iCoutner + 1; 并按下 F9 符号出现在代码行的前面 .它表示在该行设置了一个断点。图标立即变为 .黄色箭头始终指向要处理的下一条指令。出现在任务栏中 代替 . 查看变量的值 iCounter 在线监控或程序的声明部分 Simulation . 变量值不再改变。处理在断点处停止。 按 F5 ，它再次开始处理。 程序在 1 个循环后再次在断点处停止。 iCounter 增加了 1。 按 F8 执行下一个处理步骤。 返回 在行尾 iCounter := iCounter + 1; 指令以黄色突出显示。 再按一次 F8 执行下一个处理步骤。 处理跳转到编辑器 PLC_PRG .反复按 F8 显示如何逐步运行程序。要执行的语句再次用黄色箭头标记。 要关闭断点并返回正常处理，请将光标再次放在代码行上并按 F9 .然后按 F5 让应用程序重新进入模式 带去。 " }, 
{ "title" : "创建和配置项目 ", 
"url" : "_cds_struct_project_creation.html", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "什么是项目？ ", 
"url" : "_cds_struct_project_creation.html#UUID-642975ca-6900-fd18-91a2-987103ac341d_section-idm4534107013289632649624131016", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 什么是项目？ ", 
"snippet" : "什么是项目？ 项目包含创建控制器程序（“应用程序”）所需的对象： 纯 POU 示例：程序、功能块、功能和 GVL 也需要能够在 PLC 上运行应用程序的对象 示例：任务配置、库管理器、符号配置、设备配置、可视化和外部文件 在一个项目中，您可以编写多个应用程序并连接多个控制器设备。 CODESYS 管理特定于设备和特定于应用程序的 POU 设备 看法 （” 设备树 \")，以及项目范围内的 POU POU 看法。 对于项目的创建，有一些模板已经包含特定的对象。 项目的基本配置和信息在 项目设置 和 项目信息 .例如： 编译器设置 用户管理 作者 关于项目文件的数据 这 项目环境 为项目的版本兼容性...", 
"body" : "什么是项目？ 项目包含创建控制器程序（“应用程序”）所需的对象： 纯 POU 示例：程序、功能块、功能和 GVL 也需要能够在 PLC 上运行应用程序的对象 示例：任务配置、库管理器、符号配置、设备配置、可视化和外部文件 在一个项目中，您可以编写多个应用程序并连接多个控制器设备。 CODESYS 管理特定于设备和特定于应用程序的 POU 设备 看法 （” 设备树 \")，以及项目范围内的 POU POU 看法。 对于项目的创建，有一些模板已经包含特定的对象。 项目的基本配置和信息在 项目设置 和 项目信息 .例如： 编译器设置 用户管理 作者 关于项目文件的数据 这 项目环境 为项目的版本兼容性提供配置对话框。 您将项目另存为文件系统中的文件。或者，您可以将其与项目相关的文件和信息组合到项目存档中。也可以将文件保存在源代码控制系统中，例如 SVN。 每个项目都包含有关 CODESYS 创建它的版本。当你在另一个版本中打开它时， CODESYS 将通知您有关文件格式、库版本等可能或必要的更新。 您可以比较、导入\/导出项目，并为它们创建文档。 您可以保护项目不被更改，甚至完全保护它不被读取。通过使用用户管理，您可以有选择地控制对项目的访问，甚至对项目中的单个对象的访问。有关更多信息，请参阅： 保护和保存项目" }, 
{ "title" : "创建标准项目 ", 
"url" : "_cds_creating_standard_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 创建标准项目 ", 
"snippet" : "点击 文件 → 新项目 ，然后 项目 → 标准项目 模板。指定名称（例如： myProject ) 和文件系统中的位置。 这 标准项目 对话框打开。 选择其中之一 CODESYS Control Win 从标准设备 设备 列表，然后选择 结构化文本 (ST) 来自 PLC_PRG 输入 列表。然后点击 行 . 项目名称 myProject 列在开发系统主窗口的标题栏中。在设备树中创建以下结构（ 设备 看法）。 根据所选的 PLC，还可能显示其他设备节点。 PLC 总是自动显示 PLC逻辑 子节点。它下面的基础对象是： 图书馆经理 和一个 任务配置 .任务配置定义了 MainTask 用于处理标...", 
"body" : "点击 文件 → 新项目 ，然后 项目 → 标准项目 模板。指定名称（例如： myProject ) 和文件系统中的位置。 这 标准项目 对话框打开。 选择其中之一 CODESYS Control Win 从标准设备 设备 列表，然后选择 结构化文本 (ST) 来自 PLC_PRG 输入 列表。然后点击 行 . 项目名称 myProject 列在开发系统主窗口的标题栏中。在设备树中创建以下结构（ 设备 看法）。 根据所选的 PLC，还可能显示其他设备节点。 PLC 总是自动显示 PLC逻辑 子节点。它下面的基础对象是： 图书馆经理 和一个 任务配置 .任务配置定义了 MainTask 用于处理标准 POU PLC_PRG . 库管理器已经包含 Standard.library 带有可在以后编程时使用的基本 POU（例如，计数器、计时器和字符串函数）。 现在当你填写 PLC_PRG 使用无错误代码，您可以将其下载到控制器并执行它，而无需任何其他编程对象。 在 SP13 及更高版本中， 完整性检查 项目设置在 项目→项目设置→安全 为新的标准项目自动激活。有关如何保护项目的详细信息，请参阅“保护和保存项目”一章。 有关更多信息，请参阅： 您的第一个 CODESYS 程序 " }, 
{ "title" : "添加对象 ", 
"url" : "_cds_adding_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 添加对象 ", 
"snippet" : "要求：项目已打开。至少顶 <项目名称> 节点存在于 设备 查看（“设备树”）并在 POU 看法。 以下说明演示了有关如何在项目中创建对象的一些选项。 在设备树或 POU 树中，选择一个条目，例如 应用 目的。 点击 项目 → 添加对象 . 根据所选条目， CODESYS 提供可以选择的合适对象。 例如，选择 POU 对象和在 添加 POU 打开，选择 程序 键入 结构化文本 (ST) 作为实现语言和“ prog \"作为名称。 点击后 添加 , CODESYS 插入一个 编 下面的程序对象 应用 在设备树中。 在树中，选择一个对象并单击 特性 在上下文菜单中。 这 特性 对话框打开，其中包含与对...", 
"body" : "要求：项目已打开。至少顶 <项目名称> 节点存在于 设备 查看（“设备树”）并在 POU 看法。 以下说明演示了有关如何在项目中创建对象的一些选项。 在设备树或 POU 树中，选择一个条目，例如 应用 目的。 点击 项目 → 添加对象 . 根据所选条目， CODESYS 提供可以选择的合适对象。 例如，选择 POU 对象和在 添加 POU 打开，选择 程序 键入 结构化文本 (ST) 作为实现语言和“ prog \"作为名称。 点击后 添加 , CODESYS 插入一个 编 下面的程序对象 应用 在设备树中。 在树中，选择一个对象并单击 特性 在上下文菜单中。 这 特性 对话框打开，其中包含与对象相关的类别。例如，如果您使用用户管理，则可以在此处限制对对象的访问。 在树中，选择要在其下方创建文件夹以保存特定对象的条目。 注意：您不能创建自己的文件夹来构造设备节点和设备对象的布局。 在上下文菜单中，单击 新增文件夹 并在打开的对话框中定义新文件夹的名称。点击 行 . 文件夹显示在树中。 在树中，选择一个对象并将其拖动到树中的另一个位置，例如文件夹。 不要选择设备树中的对象，而是将焦点设置在设备树中的任何空闲位置 CODESYS 用户界面。点击 项目 → 添加对象 然后，例如，单击 文本列表 目的。 这 文本列表 对象被插入 POU 看法。 " }, 
{ "title" : "更改编译器版本 ", 
"url" : "_cds_changing_compiler_version.html", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 更改编译器版本 ", 
"snippet" : "在当前项目中用于生成用于目标设备的代码的编译器版本在项目设置中定义。 编译器版本独立于 CODESYS 版本。因此，恒定的应用程序代码是从具有相同编译器版本的源代码生成的，即使这是从不同的编译器版本完成的 CODESYS 版本。 注意 不更新 设置在 编译器版本 的选项卡 项目环境 对话框：如果选择此选项并且您打开一个较旧的项目， 最新 编译器版本还是用的，那么 CODESYS 继续使用项目中最后使用的编译器版本。这也适用于在新环境中定义另一个“当前”版本时。 打开未设置最新编译器版本的项目时， 项目环境 对话框打开，并带有相应的通知和直接更新的选项。 要求：项目已打开。 点击 项目 → 项目...", 
"body" : "在当前项目中用于生成用于目标设备的代码的编译器版本在项目设置中定义。 编译器版本独立于 CODESYS 版本。因此，恒定的应用程序代码是从具有相同编译器版本的源代码生成的，即使这是从不同的编译器版本完成的 CODESYS 版本。 注意 不更新 设置在 编译器版本 的选项卡 项目环境 对话框：如果选择此选项并且您打开一个较旧的项目， 最新 编译器版本还是用的，那么 CODESYS 继续使用项目中最后使用的编译器版本。这也适用于在新环境中定义另一个“当前”版本时。 打开未设置最新编译器版本的项目时， 项目环境 对话框打开，并带有相应的通知和直接更新的选项。 要求：项目已打开。 点击 项目 → 项目设置 然后 编译选项 标签。 选择所需的 修复版本 并点击 行 . 更改立即生效。 有关更多信息，请参阅： 生成应用程序代码" }, 
{ "title" : "打开一个 V3 项目 ", 
"url" : "_cds_opening_project_v3.html", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 打开一个 V3 项目 ", 
"snippet" : "在 CODESYS ，您可以打开使用不同安装创建的项目、库项目或项目档案。打开项目时，会自动检查活动安装是否适合加载项目。此时，可以检测到缺陷，例如缺少附加组件或已弃用的安装。您可以纠正这些缺陷。然后，您可以使用合适的安装加载项目。 可以采取以下措施来纠正缺陷： 更新现有附加组件并安装缺少的附加组件 开始另一个适合该项目的安装 安装一个额外的 CODESYS 具有合适状态的版本...", 
"body" : "在 CODESYS ，您可以打开使用不同安装创建的项目、库项目或项目档案。打开项目时，会自动检查活动安装是否适合加载项目。此时，可以检测到缺陷，例如缺少附加组件或已弃用的安装。您可以纠正这些缺陷。然后，您可以使用合适的安装加载项目。 可以采取以下措施来纠正缺陷： 更新现有附加组件并安装缺少的附加组件 开始另一个适合该项目的安装 安装一个额外的 CODESYS 具有合适状态的版本 " }, 
{ "title" : "加载具有合适安装的项目 ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_a6d2d494801711eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 打开一个 V3 项目 \/ 加载具有合适安装的项目 ", 
"snippet" : "要求：在开发系统上， CODESYS 存在已使用相同或相似安装保存的项目。 点击 文件 → 打开项目 . 这 打开项目 对话框打开以从您的开发系统的文件系统中选择一个文件。 设置文件过滤器并在 打开项目 对话。 点击 行 确认对话框。 项目被加载并显示在 设备树 看法。...", 
"body" : "要求：在开发系统上， CODESYS 存在已使用相同或相似安装保存的项目。 点击 文件 → 打开项目 . 这 打开项目 对话框打开以从您的开发系统的文件系统中选择一个文件。 设置文件过滤器并在 打开项目 对话。 点击 行 确认对话框。 项目被加载并显示在 设备树 看法。 " }, 
{ "title" : "加载具有合适安装的项目 ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_8aa0891b801411eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 打开一个 V3 项目 \/ 加载具有合适安装的项目 ", 
"snippet" : "在这种情况下， 项目考察 向导将指导您完成可能的操作。 在你现在的 CODESYS 安装，打开上次使用不同安装（不同版本和\/或更多附加组件）保存的项目。 CODESYS 中断加载操作并在项目检查向导中为您提供信息和合适的选项（ 项目检查 - 概述 对话框）以允许加载。 如果项目保存为 CODESYS 版本 3.5.19.0 或更高版本，则 细节 将显示按钮以打开 差异 对话。在这里您可以看到保存项目时安装了哪些附加组件，以及它们在当前安装中是否可用以及如何可用。 选择两个基本选项之一： 选项1： 该项目仍处于开发阶段。我想在此版本中打开它并且不介意可能会生成不同的代码。 您使用不合适的版本加载...", 
"body" : "在这种情况下， 项目考察 向导将指导您完成可能的操作。 在你现在的 CODESYS 安装，打开上次使用不同安装（不同版本和\/或更多附加组件）保存的项目。 CODESYS 中断加载操作并在项目检查向导中为您提供信息和合适的选项（ 项目检查 - 概述 对话框）以允许加载。 如果项目保存为 CODESYS 版本 3.5.19.0 或更高版本，则 细节 将显示按钮以打开 差异 对话。在这里您可以看到保存项目时安装了哪些附加组件，以及它们在当前安装中是否可用以及如何可用。 选择两个基本选项之一： 选项1： 该项目仍处于开发阶段。我想在此版本中打开它并且不介意可能会生成不同的代码。 您使用不合适的版本加载项目，并接受由于缺少组件而导致代码更改或损失的可能性。对于仍处于开发阶段的项目，这可能是一个可接受的选择。 选项 2： 该项目已经部署在机器\/设备上。我想生成完全相同的代码，因此需要无需任何更改即可登录的可能性。 当项目代码在任何情况下都不得更改时，此选项是必需的。该向导应确保安装合适。 因此，该向导首先扫描计算机以查找其他合适的现有安装。如果它找到合适的安装，那么您可以选择其中之一并启动它，而不是当前打开的安装。 如果向导没有找到合适的安装，则会提供下载并运行合适的安装程序。列出了必需的和可选的附加组件。您可以相应地配置下载，然后通过 CODESYS Installer . 如果您选择选项 1： 后 下一个 ，您仍然可以选择稍后安装缺少的附加组件以编辑项目的所有对象。在这种情况下，向导会检查必要的附加设置是否可用并启动 CODESYS Installer 在下一步中。 如果您在没有安装此后安装的情况下打开项目，则无法编辑受缺少加载项影响的对象。缺少的加载项数量显示在项目的状态栏中。 如果您选择选项 2： 后 下一个 ， 这 项目考察——选择 对话框打开。在下面 使用其他安装 ，向导会显示计算机上适合继续使用该项目的其他可用安装。如果找不到合适的安装，则可以选择 下载并设置新安装 . 对于这两个选项，您可以拥有 CODESYS Installer 在下一步中执行必要的安装。 有关详细信息，请参阅： 打开项目" }, 
{ "title" : "加载写保护项目 ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_d7efcbbf801411eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 打开一个 V3 项目 \/ 加载写保护项目 ", 
"snippet" : "此外，您可以加载和读取写保护的项目。只有在保存文件时，您才必须指定一个合适的位置，在该位置您具有必要的写入权限。...", 
"body" : "此外，您可以加载和读取写保护的项目。只有在保存文件时，您才必须指定一个合适的位置，在该位置您具有必要的写入权限。 " }, 
{ "title" : "加载具有访问限制的项目 ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_43f091b9801511eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 打开一个 V3 项目 \/ 加载具有访问限制的项目 ", 
"snippet" : "仅当您拥有访问凭据（例如用户名和密码）时，才能加载受限项目。...", 
"body" : "仅当您拥有访问凭据（例如用户名和密码）时，才能加载受限项目。 " }, 
{ "title" : "使用安全密钥加载项目 ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_364abf3a125f0850c0a864632cca4d5c", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 打开一个 V3 项目 \/ 使用安全密钥加载项目 ", 
"snippet" : "您选择了一个受安全密钥保护的项目。如果安全密钥未插入计算机，则会提示您将其插入。否则 CODESYS 在没有任何保护信息的情况下打开项目。...", 
"body" : "您选择了一个受安全密钥保护的项目。如果安全密钥未插入计算机，则会提示您将其插入。否则 CODESYS 在没有任何保护信息的情况下打开项目。 " }, 
{ "title" : "加载项目的备份 ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_8a9d06a8801411eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 打开一个 V3 项目 \/ 加载项目的备份 ", 
"snippet" : "备份是在 自动保存 项目选项被选中。什么时候 CODESYS 更改后未正确结束，将项目保存为备份。 选择项目后， 自动保存备份 加载时首先打开对话框。在那里你可以处理备份。...", 
"body" : "备份是在 自动保存 项目选项被选中。什么时候 CODESYS 更改后未正确结束，将项目保存为备份。 选择项目后， 自动保存备份 加载时首先打开对话框。在那里你可以处理备份。 " }, 
{ "title" : "更新项目环境 ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_8a9a6e94801411eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 打开一个 V3 项目 \/ 更新项目环境 ", 
"snippet" : "这 项目环境 当有更新的编译器版本、可视化配置文件或 SoftMotion 版本可用时，对话框将打开。该对话框会通知您当前状态并提供更新选项。 例如，对于使用非常旧的版本创建的项目 V3 ，将显示有关如何替换特定对象以继续使用项目的信息。根据您是保留项目原样还是在最新条件下继续开发，您执行或不执行更新。 项目环境的更新具有只能执行登录的效果 和 下载或 和 在线更改。 有关更多信息，请参阅： 加载和保存 和 打开项目...", 
"body" : "这 项目环境 当有更新的编译器版本、可视化配置文件或 SoftMotion 版本可用时，对话框将打开。该对话框会通知您当前状态并提供更新选项。 例如，对于使用非常旧的版本创建的项目 V3 ，将显示有关如何替换特定对象以继续使用项目的信息。根据您是保留项目原样还是在最新条件下继续开发，您执行或不执行更新。 项目环境的更新具有只能执行登录的效果 和 下载或 和 在线更改。 有关更多信息，请参阅： 加载和保存 和 打开项目" }, 
{ "title" : "打开 V2.3 项目 ", 
"url" : "_cds_opening_project_v23.html", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 打开 V2.3 项目 ", 
"snippet" : "A CoDeSys V2.3 项目只能使用 32 位版本进行转换 CODESYS V3 。为此，需要将 CODESYS V2.3 Converter 软件包必须安装在 CODESYS V3 。该软件包可在 CODESYS Store International 。 如果您使用的是 64 位版本 CODESYS V3 ，那么您还需要安装32位版本进行转换。转换完成后，您可以在以下位置打开项目 CODESYS 64 位。 要求：您已安装并启动 CODESYS V3 。这 CODESYS V2.3 Converter 附加组件已安装。 点击 文件 → 打开项目 . 在里面 打开项目 对话框，单击任意...", 
"body" : "A CoDeSys V2.3 项目只能使用 32 位版本进行转换 CODESYS V3 。为此，需要将 CODESYS V2.3 Converter 软件包必须安装在 CODESYS V3 。该软件包可在 CODESYS Store International 。 如果您使用的是 64 位版本 CODESYS V3 ，那么您还需要安装32位版本进行转换。转换完成后，您可以在以下位置打开项目 CODESYS 64 位。 要求：您已安装并启动 CODESYS V3 。这 CODESYS V2.3 Converter 附加组件已安装。 点击 文件 → 打开项目 . 在里面 打开项目 对话框，单击任意 CoDeSys V2.3 文件系统中的项目或项目存档。对于搜索，您可以在对话框的右下角设置文件过滤器。 如果另一个项目仍然打开， CODESYS 指示您相应地关闭它。在那之后 CoDeSys V2.3 转换器自动启动。 V2.3 转换器检查项目是否可以无错误地编译。如果是这样，那么它会自动处理项目。 笔记： 如果项目包含具有转换器无法解析的占位符变量的可视化对象，则相应的可视化将显示为一个组来代替可视化引用。 设备转换：当在要打开的项目中引用了一个设备（目标系统）并且没有为该设备定义转换规则时，则 设备转换 对话框打开。在此处指定转换器是否以及如何将先前的设备引用替换为当前设备引用。 为了替换，转换器在转换项目的设备树中添加了新设备来代替旧设备。 库转换：如果在要打开的项目中引用了一个尚未定义转换规则的库，则 库参考转换 对话框打开。在此处指定转换器是否以及如何将现有库引用替换为当前库引用。 如果您选择缺少项目信息的库，则 输入项目信息 对话框打开以指定此信息。 转换器加载适配的项目。注意：最近定义的库引用可以在位于 POUs 视图的全局库管理器中找到。 " }, 
{ "title" : "重复使用时的限制 CoDeSys V2.3 项目在 CODESYS ", 
"url" : "_cds_opening_project_v23.html#UUID-4e701e8c-8cef-c597-c237-6d5f8cdd2ba8_id_cd2852f2ff014e88c0a8640e006c37ac_id_1347abe6017bb94ac0a8640e0130ddc2", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 打开 V2.3 项目 \/ 重复使用时的限制 CoDeSys V2.3 项目在 CODESYS ", 
"snippet" : "汇编 该项目必须是可编译的，没有错误 CoDeSys V2.3 .笔记： CODESYS Stills 发出警告 V3 编译时。这些是由隐式转换引起的，这可能导致信息丢失（例如通过符号更改）。 CODESYS V3 根据 switch 变量检查“case”语句： CASE USINT OF INT 未签入 CoDeSys V2.3 , 但导入时会发出错误消息 V3 . 控制器配置 这 控制器配置 一个 CoDeSys V2.3 项目无法导入 V3 .您必须重新创建设备配置并重新声明控制器配置中使用的变量。 网络变量 对于网络变量， CODESYS 创建 V3 GVL 对象并导入变量声明。但是，...", 
"body" : "汇编 该项目必须是可编译的，没有错误 CoDeSys V2.3 .笔记： CODESYS Stills 发出警告 V3 编译时。这些是由隐式转换引起的，这可能导致信息丢失（例如通过符号更改）。 CODESYS V3 根据 switch 变量检查“case”语句： CASE USINT OF INT 未签入 CoDeSys V2.3 , 但导入时会发出错误消息 V3 . 控制器配置 这 控制器配置 一个 CoDeSys V2.3 项目无法导入 V3 .您必须重新创建设备配置并重新声明控制器配置中使用的变量。 网络变量 对于网络变量， CODESYS 创建 V3 GVL 对象并导入变量声明。但是，不会导入网络属性。请参阅网络变量交换的描述。 图书馆 库中使用的所有变量和常量也必须在库中声明。必须可以在 CoDeSys V2.3 没有错误。 句法和语义限制，因为 CoDeSys V2.3 FUNCTIONBLOCK 不是有效的关键字，而不是 FUNCTION_BLOCK . TYPE （结构声明）后面必须跟一个“:”。 ARRAY 初始化** 必须有括号。 INI 不再支持（您必须在代码中用 Init 方法替换它）。 在函数调用中，不再可能将显式参数分配与隐式参数分配混合在一起。因此可以更改参数输入分配的顺序： fun(formal1 := actual1, actual2); \/\/ -> error message fun(formal2 := actual2, formal1 := actual1); \/\/ same semantics as the following line: fun(formal1 := actual1, formal2 := actual2); CoDeSys V2.3 pragma 不会被转换。他们在 V3 . 这 TRUNC 运算符现在转换为数据类型 DINT 代替 INT . CODESYS 自动为 a 添加相应的类型转换 CoDeSys V2.3 进口。 可视化 占位符及其替换 占位符： PLC_PRG.$LocalVar$.aArr[0] VAR_INPUT: localVar: MyStruct; 用法： localVar.aArr[0] 代换： localVar := PLC_PRG.myStructVar 占位符： $Var$.aArr[0] VAR_INPUT: Var : MyStruct; 用法： Var.aArr[0] 代换： Var := PLC_PRG.myStructVar 占位符： PLC_PRG.myStructVar.aArr[$Index$] VAR_INPUT: Index : INT; 用法： PLC_PRG.myStructVar.aArr[Index] 代换： Index := 0 有问题的占位符 文本中的占位符 文本： $axle$-Axis 更正： localVar : STRING; 文本： %s-Axis 文本变量： localVar 占位符仅描述变量名的一部分 axis$axis$spur$spur$.fActPosition 更正： 只定义一个占位符 axis$axis$spur$spur$ 占位符。 axis_spur : MyFunctionBlock; 然后直接调用相应的功能块实例。 axis_spur := PLC_PRG.axis1spur2; 占位符被表达式替换 $Expression$ -> PLC_PRG.var1 + PLC_PRG.var2 更正： 您必须将表达式传输到辅助变量，然后将此辅助变量作为实例传输。 占位符描述程序名称：$Program$.bToggle - PLC_PRG.bToggle D 转换器无法将这种形式的设置占位符转移到 V3 .但是，您很少会在实践中使用它。 占位符被不同的类型替换： $Var$ -> 替换 1： PLC_PRG.n (INT) -> 替换 2： PLC_PRG.st （细绳） 更正： 为此在界面中定义两个不同的占位符。 可视化位于库中。当您在那里使用可视化时，您可以稍后从任何所需项目中替换占位符。 更正： 在这里你必须更换 TYPE_NONE 数据类型手动。但是，您也可以将库集成到项目中并正确替换占位符。如果您现在导入此项目，则数据类型也会在库中正确确定。 不可导入元素 趋势，ActiveX：导入是不可能的，因为实现有很大不同。在 V3 ，发出相应的警告，需要进行相应的人工复制。 编程语言：ST、IL、FBD 无限制 编程语言：LD CODESYS 以这样的方式导入具有并行分支的功能块，即每个分支都重复分支之前的部分。这对应于生成的代码 CoDeSys V2.3 为并行分支创建。 编程语言：SFC 用户显式声明的步变量必须在 SFC 编辑器中本地声明。您不能将它们声明为 VAR_INPUT、VAR_OUTPUT 或 VAR_INOUT，因为 CODESYS 无法自动调整呼叫。说明：步骤不再使用布尔变量来管理内部状态 V3 , 也是类型的结构 SFCStepType . 标识符：以下标识符不能以下划线字符开头： 树中 IEC 动作的名称 在 IEC 关联列表中调用的变量 已编程的转换名称 解释： 在 V3 , 隐含变量 CODESYS 为动作创建的下划线字符作为前缀。将产生带有双下划线字符的无效标识符。 编程语言：CFC 大箱子：大箱子的布局可能会因进口而失去质量。这些框可能彼此重叠太多。 （计划更正。） 宏：不能导入宏。 （计划更正。） " }, 
{ "title" : "配置项目 ", 
"url" : "_cds_struct_configuring_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 配置项目 ", 
"snippet" : "您可以配置您的 CODESYS 以下对话框中的项目： 项目设置 ：编辑器行为、编译器、用户管理等的常规设置。 项目信息 ：具有个性化、独特信息的项目标识设置 项目环境 : 定义应该使用哪些版本的外部和内部模块，目的是它们是最新的并且相互兼容...", 
"body" : "您可以配置您的 CODESYS 以下对话框中的项目： 项目设置 ：编辑器行为、编译器、用户管理等的常规设置。 项目信息 ：具有个性化、独特信息的项目标识设置 项目环境 : 定义应该使用哪些版本的外部和内部模块，目的是它们是最新的并且相互兼容 " }, 
{ "title" : "检索和编辑项目信息 ", 
"url" : "_cds_querying_and_editing_project_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 配置项目 \/ 检索和编辑项目信息 ", 
"snippet" : "您可以使用 项目信息 对象检索有关您的项目和相关文件的信息，并编辑某些信息。 该对象包含有关信息 文件属性 元信息，例如供应商、标题或作者 带键的属性 统计数据 许可 签名：这种对翻译库进行签名的方式已被弃用，出于安全原因，仅在需要与旧版本兼容时才应使用。如果使用此方法，那么稍后您可以使用公钥令牌来验证库是否最后由库供应商签名。因此，作为库供应商，您必须将所使用的公钥提供给客户，例如在文档中。 CODESYS 将项目信息保存为项目中的对象。当您将项目转移到另一个系统时， 项目信息 对象随它一起转移。不需要项目存档。 您可以使用属性键通过功能块从外部访问项目信息。对于库项目，您还可以查询有关许可...", 
"body" : "您可以使用 项目信息 对象检索有关您的项目和相关文件的信息，并编辑某些信息。 该对象包含有关信息 文件属性 元信息，例如供应商、标题或作者 带键的属性 统计数据 许可 签名：这种对翻译库进行签名的方式已被弃用，出于安全原因，仅在需要与旧版本兼容时才应使用。如果使用此方法，那么稍后您可以使用公钥令牌来验证库是否最后由库供应商签名。因此，作为库供应商，您必须将所使用的公钥提供给客户，例如在文档中。 CODESYS 将项目信息保存为项目中的对象。当您将项目转移到另一个系统时， 项目信息 对象随它一起转移。不需要项目存档。 您可以使用属性键通过功能块从外部访问项目信息。对于库项目，您还可以查询有关许可的信息。 " }, 
{ "title" : "编辑元信息 ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_a57d0cffe98711e48c1bfcee0714ea73", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 配置项目 \/ 检索和编辑项目信息 \/ 编辑元信息 ", 
"snippet" : "点击 项目→项目信息 . 这 项目信息 对话框打开。 点击 概括 标签。 在输入字段中指定您的数据（例如： 0.0.0.1 在里面 版本 输入字段）。 CODESYS 为每个给定值创建一个带有键的属性并在 特性 标签。对于图书馆项目， CODESYS 稍后仍使用库存储库中的属性和排序。 如果您选择 CODESYS 为这些属性创建功能块，然后您可以通过编程方式访问这些属性。...", 
"body" : "点击 项目→项目信息 . 这 项目信息 对话框打开。 点击 概括 标签。 在输入字段中指定您的数据（例如： 0.0.0.1 在里面 版本 输入字段）。 CODESYS 为每个给定值创建一个带有键的属性并在 特性 标签。对于图书馆项目， CODESYS 稍后仍使用库存储库中的属性和排序。 如果您选择 CODESYS 为这些属性创建功能块，然后您可以通过编程方式访问这些属性。 " }, 
{ "title" : "创建用于访问属性的函数 ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_036ad17de80511e4ab86a4571214df94", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 配置项目 \/ 检索和编辑项目信息 \/ 创建用于访问属性的函数 ", 
"snippet" : "点击 项目→项目信息 . 这 项目信息 对话框打开。 选择 自动生成“项目信息”POU 选项。 例子 要求：定义了以下属性。 Schlüssel = nProp1 Typ= Zahl Wert= 333 选择 自动生成“项目信息”POU 选项。 声明一个 DINT 类型变量。 例子： showprop : DINT; 调用函数 GetNumberProperty ： showprop := GetNumberProperty(\"nProp1\"); 您被授予访问应用程序中的值的权限。 注意：使用 自动生成“项目信息”POU 仅当运行时支持 WSTRING 数据类型。如果不是这种情况，那么您可以应...", 
"body" : "点击 项目→项目信息 . 这 项目信息 对话框打开。 选择 自动生成“项目信息”POU 选项。 例子 要求：定义了以下属性。 Schlüssel = nProp1\nTyp= Zahl\nWert= 333 选择 自动生成“项目信息”POU 选项。 声明一个 DINT 类型变量。 例子： showprop : DINT; 调用函数 GetNumberProperty ： showprop := GetNumberProperty(\"nProp1\"); 您被授予访问应用程序中的值的权限。 注意：使用 自动生成“项目信息”POU 仅当运行时支持 WSTRING 数据类型。如果不是这种情况，那么您可以应用 自动生成“图书馆信息”POU 选项。您至少可以在应用程序中使用以这种方式创建的函数来访问属性。这些函数未在运行时注册。 " }, 
{ "title" : "授权图书馆项目 ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_cded5ad3e81111e4ab86a4571214df94", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 配置项目 \/ 检索和编辑项目信息 \/ 授权图书馆项目 ", 
"snippet" : "如果您的项目是库项目，那么您可以在此处激活正在使用的库许可。这 ” CODESYS 安全密钥”用作加密狗。 要求：项目为图书馆项目。 点击 项目→项目信息 . 这 项目信息 对话框打开。 点击 许可 标签。 选择 激活加密狗许可 选项。 指定加密狗数据 公司代码 , 产品代码 , 激活网址 ， 和 激活邮件 . 该库已获得许可。...", 
"body" : "如果您的项目是库项目，那么您可以在此处激活正在使用的库许可。这 ” CODESYS 安全密钥”用作加密狗。 要求：项目为图书馆项目。 点击 项目→项目信息 . 这 项目信息 对话框打开。 点击 许可 标签。 选择 激活加密狗许可 选项。 指定加密狗数据 公司代码 , 产品代码 , 激活网址 ， 和 激活邮件 . 该库已获得许可。 " }, 
{ "title" : "已弃用：签署库项目 – 仅用于与 CODESYS < 3.5 SP15 – 在版本中 CODESYS V3 SP17 及更高版本，仅适用于已在 项目信息——签约 对话 ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_4f7ee481fe1211e49fce83667d100c0a", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 配置项目 \/ 检索和编辑项目信息 \/ 已弃用：签署库项目 – 仅用于与 CODESYS < 3.5 SP15 – 在版本中 CODESYS V3 SP17 及更高版本，仅适用于已在 项目信息——签约 对话 ", 
"snippet" : "作为 CODESYS V3 SP15 , 库签名始终基于证书。要执行这种签名，请参阅有关 将项目另存为编译库 命令。与不推荐使用的签名相比，使用中的设置 项目信息 – 签约 对话框中，整个库都使用证书进行签名。 如果您仍然需要为图书馆项目签署 CODESYS 版本 < V3 SP15 出于兼容性原因，请按以下步骤操作： 要求：您有一个带有关联令牌的可用私钥文件。在库项目的项目信息中，一个库与一个 CODESYS 版本 < V3 SP15 设置在 概括 标签。 点击 项目→项目信息 . 这 项目信息 对话框打开。 点击 签约 标签。 选择 激活签名 选项。 指定私钥文件的内存位置。 CODESY...", 
"body" : "作为 CODESYS V3 SP15 , 库签名始终基于证书。要执行这种签名，请参阅有关 将项目另存为编译库 命令。与不推荐使用的签名相比，使用中的设置 项目信息 – 签约 对话框中，整个库都使用证书进行签名。 如果您仍然需要为图书馆项目签署 CODESYS 版本 < V3 SP15 出于兼容性原因，请按以下步骤操作： 要求：您有一个带有关联令牌的可用私钥文件。在库项目的项目信息中，一个库与一个 CODESYS 版本 < V3 SP15 设置在 概括 标签。 点击 项目→项目信息 . 这 项目信息 对话框打开。 点击 签约 标签。 选择 激活签名 选项。 指定私钥文件的内存位置。 CODESYS 自动输入令牌 公钥令牌 . 例子： 427A5701DA3CF3CF 点击 文件 → 将项目另存为编译库 . 库项目保存为扩展名为的文件 *.library .您将在库详细信息中的库存储库或库管理器中看到令牌，并可以将其与库供应商发布的令牌进行比较。通过这种方式，您可以检查库是否实际上来自所需的供应商。 " }, 
{ "title" : "创建私钥文件 ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_62a1c2fde5fb82e1c0a8640e0154acb5", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 配置项目 \/ 检索和编辑项目信息 \/ 创建私钥文件 ", 
"snippet" : "点击 项目 → 项目信息 . 点击 签约 标签。 点击 创建私钥文件 按钮。 这 创建私钥文件 对话框打开。 选择一个安全的位置，例如 D:\\for lib developers only\\mycomp_libkey.libpk 并退出对话框 保存 ....", 
"body" : "点击 项目 → 项目信息 . 点击 签约 标签。 点击 创建私钥文件 按钮。 这 创建私钥文件 对话框打开。 选择一个安全的位置，例如 D:\\for lib developers only\\mycomp_libkey.libpk 并退出对话框 保存 . " }, 
{ "title" : "配置项目设置 ", 
"url" : "_cds_struct_setting_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 创建和配置项目 \/ 配置项目 \/ 配置项目设置 ", 
"snippet" : "您可以配置影响 CODESYS 和某些编辑在 项目设置 目的。这些设置在整个项目中都有效，并立即应用于活动编辑器。您还可以使用 项目 → 项目设置 命令来访问对象的对话框。 CODESYS 将项目设置保存为项目中的对象。然后，当您将项目转移到另一个系统时， 项目设置 对象随它一起转移。不需要项目存档。...", 
"body" : "您可以配置影响 CODESYS 和某些编辑在 项目设置 目的。这些设置在整个项目中都有效，并立即应用于活动编辑器。您还可以使用 项目 → 项目设置 命令来访问对象的对话框。 CODESYS 将项目设置保存为项目中的对象。然后，当您将项目转移到另一个系统时， 项目设置 对象随它一起转移。不需要项目存档。 " }, 
{ "title" : "导出和传输项目 ", 
"url" : "_cds_struct_project_export_transfer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 导出和传输项目 ", 
"snippet" : "导出和导入功能可用于交换数据 CODESYS 与其他程序的项目。 项目文件 (*.project) 或项目存档 (*.projectarchive) 的副本用于交换 CODESYS 项目之间 CODESYS 开发系统。...", 
"body" : "导出和导入功能可用于交换数据 CODESYS 与其他程序的项目。 项目文件 (*.project) 或项目存档 (*.projectarchive) 的副本用于交换 CODESYS 项目之间 CODESYS 开发系统。 " }, 
{ "title" : "导出和导入项目 ", 
"url" : "_cds_project_export_import.html", 
"breadcrumbs" : "CODESYS Essentials \/ 导出和传输项目 \/ 导出和导入项目 ", 
"snippet" : "CODESYS 提供用于从文件导出和导入对象的命令。有两种方法可以做到这一点： 导出和导入 CODESYS XML 文件 (*.export) 这种格式完全兼容 CODESYS 项目格式。对象以机器可解析的 XML 格式存储。 以 PLCopen 格式 (*.xml) 导出和导入 XML 文件 您可以使用这种格式在程序之间交换信息，例如程序编辑器或文档工具。 PLCopen XML 定义了一个元素的子集 CODESYS 承认。因此，不能保证 100% 的兼容性。...", 
"body" : "CODESYS 提供用于从文件导出和导入对象的命令。有两种方法可以做到这一点： 导出和导入 CODESYS XML 文件 (*.export) 这种格式完全兼容 CODESYS 项目格式。对象以机器可解析的 XML 格式存储。 以 PLCopen 格式 (*.xml) 导出和导入 XML 文件 您可以使用这种格式在程序之间交换信息，例如程序编辑器或文档工具。 PLCopen XML 定义了一个元素的子集 CODESYS 承认。因此，不能保证 100% 的兼容性。 " }, 
{ "title" : "导出项目 ", 
"url" : "_cds_project_export_import.html#UUID-4276a4a2-07e1-df8e-2521-15e4d85eb49f_id_a282cbda3e76d3c0a8640e001b04d0_id_6b64e742dada2534c0a8640e0069c11e", 
"breadcrumbs" : "CODESYS Essentials \/ 导出和传输项目 \/ 导出和导入项目 \/ 导出项目 ", 
"snippet" : "要求：一个项目在 CODESYS . 点击 项目 -> 导出 或者 项目 -> 导出 PLCopenXML . 选择导出对象 出口 对话框或 导出 PLCopenXML 对话。 点击 行 . 指定文件名和位置。点击 保存 ....", 
"body" : "要求：一个项目在 CODESYS . 点击 项目 -> 导出 或者 项目 -> 导出 PLCopenXML . 选择导出对象 出口 对话框或 导出 PLCopenXML 对话。 点击 行 . 指定文件名和位置。点击 保存 . " }, 
{ "title" : "导入项目 ", 
"url" : "_cds_project_export_import.html#UUID-4276a4a2-07e1-df8e-2521-15e4d85eb49f_id_a282cbda3e76d3c0a8640e001b04d0_id_243afeac184815f7c0a8640e00616fed", 
"breadcrumbs" : "CODESYS Essentials \/ 导出和传输项目 \/ 导出和导入项目 \/ 导入项目 ", 
"snippet" : "要求：一个项目在 CODESYS . 点击 项目 -> 导入 或者 项目 -> 导入 PLCopenXML . 选择导入对象 进口 对话框或 导入 PLCopenXML 对话。 将打开一个对话框并显示可以在此位置插入的对象的树结构。 在树形结构中选择可以导入对象的对象。 选择对象并单击 行 . 对象被添加到现有对象树中。 有关更多信息，请参阅： PLCopenXML...", 
"body" : "要求：一个项目在 CODESYS . 点击 项目 -> 导入 或者 项目 -> 导入 PLCopenXML . 选择导入对象 进口 对话框或 导入 PLCopenXML 对话。 将打开一个对话框并显示可以在此位置插入的对象的树结构。 在树形结构中选择可以导入对象的对象。 选择对象并单击 行 . 对象被添加到现有对象树中。 有关更多信息，请参阅： PLCopenXML" }, 
{ "title" : "转移项目 ", 
"url" : "_cds_project_transfer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 导出和传输项目 \/ 转移项目 ", 
"snippet" : "如果您想将项目传输到另一台计算机并从那里连接到同一个 PLC 而无需在线更改或下载，请注意以下几点。 确保项目只需要修复版本的库（接口库除外）、可视化配置文件和编译器。 确保引导应用程序是最新的。 然后创建一个在另一台计算机上解压的存储库。...", 
"body" : "如果您想将项目传输到另一台计算机并从那里连接到同一个 PLC 而无需在线更改或下载，请注意以下几点。 确保项目只需要修复版本的库（接口库除外）、可视化配置文件和编译器。 确保引导应用程序是最新的。 然后创建一个在另一台计算机上解压的存储库。 " }, 
{ "title" : "将项目转移到另一个系统 ", 
"url" : "_cds_project_transfer.html#UUID-ed2bc292-0880-13a7-2fde-3d254ec1acb6_id_a747b06714334ffc0a8640e011c1820_id_3621759901828743c0a8640e00ee49c5", 
"breadcrumbs" : "CODESYS Essentials \/ 导出和传输项目 \/ 转移项目 \/ 将项目转移到另一个系统 ", 
"snippet" : "要求：在计算机“PC1”上打开一个项目，您将其传输到另一台计算机“PC2”并从那里再次连接到同一控制器。 确保项目中仅包含具有修复版本的库（例外：纯接口库）。为此，请打开 图书馆经理 并检查所有带有“*”而不是修复版本号的条目。 在编译器版本 3.5.18.0 及更高版本中，库配置文件在占位符解析中被忽略。配置文件中包含的库自动成为自由占位符。将库配置文件包含在存储库中的选项不再可用。 确保在项目设置中设置了修复编译器版本。要检查这一点，请单击 项目 → 项目设置 然后 编译器选项 类别。 确保在项目设置中定义了修复可视化配置文件。要检查这一点，请单击 项目 → 项目设置 然后 可视化配置文件...", 
"body" : "要求：在计算机“PC1”上打开一个项目，您将其传输到另一台计算机“PC2”并从那里再次连接到同一控制器。 确保项目中仅包含具有修复版本的库（例外：纯接口库）。为此，请打开 图书馆经理 并检查所有带有“*”而不是修复版本号的条目。 在编译器版本 3.5.18.0 及更高版本中，库配置文件在占位符解析中被忽略。配置文件中包含的库自动成为自由占位符。将库配置文件包含在存储库中的选项不再可用。 确保在项目设置中设置了修复编译器版本。要检查这一点，请单击 项目 → 项目设置 然后 编译器选项 类别。 确保在项目设置中定义了修复可视化配置文件。要检查这一点，请单击 项目 → 项目设置 然后 可视化配置文件 类别。 确保当前打开的应用程序与当前在 PLC 上使用的应用程序相同。这意味着“启动应用程序”必须与编程系统中的项目相同。为此，请检查编程系统窗口标题栏中的项目名称： 如果名称后显示星号，则表示项目已更改但尚未保存。那么应用程序和启动应用程序可能不匹配。 在这种情况下，首先创建一个（新的）引导应用程序。这取决于 PLC 和应用程序属性，这是否在加载（下载）应用程序时自动发生。要显式创建，请单击 在线 → 创建启动应用程序 .然后点击 在线 → 登录 和 在线 → 下载 执行下载。 之后，单击 调试 → 开始 在控制器上启动应用程序。 现在，所需的应用程序正在 PLC 上运行，您稍后要在 PC2 上从同一项目再次连接到该 PLC。 创建项目存档：单击 文件 → 项目存档 → 保存\/发送存档 .在里面 项目档案 对话框，同时选择以下信息： 下载信息文件 图书馆简介 参考设备 引用的库 可视化配置文件 将项目存档保存到可从 PC2 访问的位置。 注销控制器：要执行此操作，请单击 在线 → 注销 .在从 PC2 重新连接之前，您可以毫不犹豫地停止和重新启动 PLC。 将存储库提取到 PC2：单击 文件→项目存档→提取存档 并打开上面保存的存档。在里面 提取项目档案 对话框中，在创建存档时选择与上述相同的信息。 打开项目并重新登录到 PLC“xy”。 CODESYS 不需要任何在线更改或下载；该项目正在运行。 " }, 
{ "title" : "比较项目 ", 
"url" : "_cds_struct_project_comparison.html", 
"breadcrumbs" : "CODESYS Essentials \/ 比较项目 ", 
"snippet" : "您可以将当前打开的项目与另一个项目（参考项目）进行比较。检测内容、属性或访问权限的差异并在比较视图中显示。 点击 项目→比较 打开 项目比较 对话框供您配置和运行比较。然后结果显示在 项目比较 - 差异 查看对象在树结构中的对齐位置。指示与相应参考对象的差异的对象由颜色和符号标识。这是您检测内容、属性或访问权限是否不同的方式。 对于内容的差异，您也可以打开详细 项目比较 - <对象名称> 差异 查看以放大对象。在详细比较视图中，显示对象和参考对象的内容或对齐它们的源代码。检测到的差异被标记。以前打开的视图不会关闭。这样，除了项目比较视图之外，您还可以打开任意数量的比较视图并阅读它们。 您可以将...", 
"body" : "您可以将当前打开的项目与另一个项目（参考项目）进行比较。检测内容、属性或访问权限的差异并在比较视图中显示。 点击 项目→比较 打开 项目比较 对话框供您配置和运行比较。然后结果显示在 项目比较 - 差异 查看对象在树结构中的对齐位置。指示与相应参考对象的差异的对象由颜色和符号标识。这是您检测内容、属性或访问权限是否不同的方式。 对于内容的差异，您也可以打开详细 项目比较 - <对象名称> 差异 查看以放大对象。在详细比较视图中，显示对象和参考对象的内容或对齐它们的源代码。检测到的差异被标记。以前打开的视图不会关闭。这样，除了项目比较视图之外，您还可以打开任意数量的比较视图并阅读它们。 您可以将检测到的来自参考项目的差异接受到当前项目中。这只能从参考项目到打开的项目中。为此，您需要激活当前项目中应该接受的差异（例如在代码中） , ， 或者 活动比较视图中用于接受的命令。这些位置以黄色突出显示。请注意，任何其他打开的比较视图都处于非活动状态（写保护、只读）。因此，您只能在一个比较视图中激活要接受的差异。退出活动比较视图时，如果您确认激活接受的差异实际上已接受到当前项目中，则修改当前项目。 退出活动比较视图时，如果您确认激活接受的差异实际上已被接受到当前项目中，则当前项目将被修改。 要完全退出项目比较，请关闭项目比较视图。 " }, 
{ "title" : "创建比较视图 ", 
"url" : "_cds_creating_project_differences.html", 
"breadcrumbs" : "CODESYS Essentials \/ 比较项目 \/ 创建比较视图 ", 
"snippet" : "要求：您对当前项目进行了更改，并希望将其与上次保存的版本进行比较。同时，您添加了更多 POU、删除了 POU、更改了 POU 中的某些代码行或对象属性。 点击 项目→比较 这 项目比较 对话框打开。 指定参考项目的路径，例如，您当前项目的最后保存版本的路径。 离开 忽略空格 启用比较选项。 点击 行 . CODESYS 打开比较视图。 标题： 项目比较 - 差异 比较当前项目和参考项目的设备树，更改的对象以颜色突出显示。 在参考项目树（右）中，选择一个以蓝色突出显示的对象。此对象不再包含在当前项目中。 点击 接受单身 . CODESYS 在当前项目的树中添加对象（左）。该行以黄色突出显示。这 ...", 
"body" : "要求：您对当前项目进行了更改，并希望将其与上次保存的版本进行比较。同时，您添加了更多 POU、删除了 POU、更改了 POU 中的某些代码行或对象属性。 点击 项目→比较 这 项目比较 对话框打开。 指定参考项目的路径，例如，您当前项目的最后保存版本的路径。 离开 忽略空格 启用比较选项。 点击 行 . CODESYS 打开比较视图。 标题： 项目比较 - 差异 比较当前项目和参考项目的设备树，更改的对象以颜色突出显示。 在参考项目树（右）中，选择一个以蓝色突出显示的对象。此对象不再包含在当前项目中。 点击 接受单身 . CODESYS 在当前项目的树中添加对象（左）。该行以黄色突出显示。这 符号显示在中间一列。 在当前项目树（左）中，选择一个以绿色突出显示的对象。该对象不包含在参考项目中。 点击 接受单身 . CODESYS 再次从当前项目的树中移除对象（左）。该行以黄色突出显示。这 符号显示在中间一列。 如果 CODESYS 已检测到包含在当前项目和参考项目中的对象的内容发生变化，则以红色文本指示。然后可以双击对象切换到对象的详细比较视图。 关闭比较视图并回答 是的 关于是否应该保存所做的更改的问题。 更改将在项目中生效。 有关更多信息，请参阅： 打开详细比较视图" }, 
{ "title" : "打开详细比较视图 ", 
"url" : "_cds_creating_editing_detail_differences.html", 
"breadcrumbs" : "CODESYS Essentials \/ 比较项目 \/ 打开详细比较视图 ", 
"snippet" : "需求：例如用户修改了当前项目的POU中的代码。您已通过单击执行了项目比较 项目 → 比较 .项目比较视图显示此 POU 在项目树的对齐中以红色突出显示。 双击对齐的 POU 版本的行。 比较视图切换到 POU 的详细比较视图。修改后的代码行以灰色突出显示并以红色书写。 点击 . 有变化的代码行（红色）由两行扩展：插入的行（左，绿色）和删除的行（右，蓝色）。 点击 再次。 代码行再次标记为已修改。 将鼠标指针移动到标记为已修改的代码行并单击 接受单身 . 参考项目中的代码行被激活以接受当前项目。 如果可用，请单击 添加第三个视图。 第三个视图出现在两个视图下方，对比了当前对象和引用对象的代码。这...", 
"body" : "需求：例如用户修改了当前项目的POU中的代码。您已通过单击执行了项目比较 项目 → 比较 .项目比较视图显示此 POU 在项目树的对齐中以红色突出显示。 双击对齐的 POU 版本的行。 比较视图切换到 POU 的详细比较视图。修改后的代码行以灰色突出显示并以红色书写。 点击 . 有变化的代码行（红色）由两行扩展：插入的行（左，绿色）和删除的行（右，蓝色）。 点击 再次。 代码行再次标记为已修改。 将鼠标指针移动到标记为已修改的代码行并单击 接受单身 . 参考项目中的代码行被激活以接受当前项目。 如果可用，请单击 添加第三个视图。 第三个视图出现在两个视图下方，对比了当前对象和引用对象的代码。这显示了您为解决当前对象和参考对象之间的差异而执行的操作的结果。对于这些操作，详细比较视图的任务栏中提供了额外的按钮。有关详细信息，请参阅： 查看：项目比较 - <对象名称> 差异. 点击 . 打开整个项目的项目比较视图。它是写保护的（只读），以防止您激活差异以供接受。树视图上方以黄色突出显示的链接也表明了这一点。 点击链接： 项目比较视图是只读的，因为另一个视图中有未提交的更改。单击此处切换到修改后的视图。 详细比较视图再次打开。未确认的更改以黄色突出显示。 点击 在视图的选项卡上并确认应保存更改。 详细项目视图关闭，POU 被覆盖。现在它对应于参考项目的 POU。项目视图再次处于活动状态，以便您可以继续进行项目比较。 如果您不单击链接，但单击 而是关闭项目比较视图的编辑器，然后您还将确认接受对当前项目的更改。接受细节更改，然后完全关闭项目比较。 有关更多信息，请参阅： 创建比较视图" }, 
{ "title" : "保护和保存项目 ", 
"url" : "_cds_struct_project_protection_storage.html", 
"breadcrumbs" : "CODESYS Essentials \/ 保护和保存项目 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "项目保护 ", 
"url" : "_cds_struct_project_protection_storage.html#UUID-d82983fe-0a1b-1735-b6e6-87e3d8fe682b_section-idm234759364725429", 
"breadcrumbs" : "CODESYS Essentials \/ 保护和保存项目 \/ 项目保护 ", 
"snippet" : "有关项目保护，请参阅以下帮助页面： 保护源代码...", 
"body" : "有关项目保护，请参阅以下帮助页面： 保护源代码 " }, 
{ "title" : "归档、保存 ", 
"url" : "_cds_struct_project_protection_storage.html#UUID-d82983fe-0a1b-1735-b6e6-87e3d8fe682b_section-idm4654689522251232654637501867", 
"breadcrumbs" : "CODESYS Essentials \/ 保护和保存项目 \/ 归档、保存 ", 
"snippet" : "在将项目文件保存到文件系统之前，为项目文件提供所需的保护；往上看。对于只读项目文件，您将获得各种选项，以便您仍然可以保存文件，具体取决于写保护的类型。 如果项目应该稍后在旧版本中打开 CODESYS 版本，那么为这个版本保存项目是有意义的，因为 CODESYS 然后将立即通知您可能的数据丢失。 如果要保存库项目，请参阅 创建库的指南 .还要考虑在库存储库中直接安装库的可能性。 如果您想在另一台计算机上继续使用项目，不仅要保存项目文件，还要创建一个 项目档案 从所有相关的辅助文件。 您可以进行设置，以便在每次保存项目时创建该项目的备份副本。此外，您可以配置 CODESYS，以便项目通常以特定时间...", 
"body" : "在将项目文件保存到文件系统之前，为项目文件提供所需的保护；往上看。对于只读项目文件，您将获得各种选项，以便您仍然可以保存文件，具体取决于写保护的类型。 如果项目应该稍后在旧版本中打开 CODESYS 版本，那么为这个版本保存项目是有意义的，因为 CODESYS 然后将立即通知您可能的数据丢失。 如果要保存库项目，请参阅 创建库的指南 .还要考虑在库存储库中直接安装库的可能性。 如果您想在另一台计算机上继续使用项目，不仅要保存项目文件，还要创建一个 项目档案 从所有相关的辅助文件。 您可以进行设置，以便在每次保存项目时创建该项目的备份副本。此外，您可以配置 CODESYS，以便项目通常以特定时间间隔自动保存。有关更多信息，请参阅： 加载和保存如果您想将项目保存在 源代码管理系统 ，考虑相应的附加组件 CODESYS .例如，支持到 SVN 的链接。 " }, 
{ "title" : "保存项目 ", 
"url" : "_cds_saving_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 保护和保存项目 \/ 保存项目 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "以相同名称保存项目 ", 
"url" : "_cds_saving_project.html#UUID-1bc9d9ae-6670-3dc0-ea69-bcf82769aa81_id_dcaaa6487a164c0a8640e003a1189_id_1d675998b906498cc0a8640e01be26b4", 
"breadcrumbs" : "CODESYS Essentials \/ 保护和保存项目 \/ 保存项目 \/ 以相同名称保存项目 ", 
"snippet" : "要求：项目已打开。项目文件没有写保护。 点击 文件 → 保存项目 。 CODESYS 以当前项目名称保存项目文件，该名称显示在主窗口的标题栏中。如果项目自上次保存后已更改，则项目名称带有星号。如果设置在 CODESYS 中的选项 加载和保存 类别，那么也会制作一个备份副本。 存储格式 项目的存储格式是项目的配置文件 CODESYS Development System 用于在项目创建或修改后保存项目。该配置文件包含了本插件所有插件的版本信息 CODESYS 安装以及包含在此的所有附加组件 CODESYS 安装。 当使用以下命令保存项目时 保存项目 命令后，存储格式不会自动更新。 仅在以下情况下...", 
"body" : "要求：项目已打开。项目文件没有写保护。 点击 文件 → 保存项目 。 CODESYS 以当前项目名称保存项目文件，该名称显示在主窗口的标题栏中。如果项目自上次保存后已更改，则项目名称带有星号。如果设置在 CODESYS 中的选项 加载和保存 类别，那么也会制作一个备份副本。 存储格式 项目的存储格式是项目的配置文件 CODESYS Development System 用于在项目创建或修改后保存项目。该配置文件包含了本插件所有插件的版本信息 CODESYS 安装以及包含在此的所有附加组件 CODESYS 安装。 当使用以下命令保存项目时 保存项目 命令后，存储格式不会自动更新。 仅在以下情况下更新存储格式： 您可以使用以下命令保存项目 将项目另存为 命令，然后您在中选择不同的存储格式 另存为类型 列表框。 项目已在以下位置打开 CODESYS 安装的存储格式与项目不同： 如果那么 是否要将项目的存储格式更新为<存储格式> 当您编辑此项目时，对话框将打开，然后单击 是的 继续并单击 保存项目 保存项目。 项目的存储格式显示在 项目 → 项目信息 ，在 文件 标签。 " }, 
{ "title" : "以不同的名称或存储格式保存项目 ", 
"url" : "_cds_saving_project.html#UUID-1bc9d9ae-6670-3dc0-ea69-bcf82769aa81_id_dcaaa6487a164c0a8640e003a1189_id_e0e08580b906498dc0a8640e00285d64", 
"breadcrumbs" : "CODESYS Essentials \/ 保护和保存项目 \/ 保存项目 \/ 以不同的名称或存储格式保存项目 ", 
"snippet" : "要求：项目已打开。 点击 文件 → 将项目另存为 。 这 保存项目 对话框打开。 选择文件系统中的位置和所需的 文件类型 （项目文件或库文件）和所需的存储版本。如果您想稍后在旧版本中打开项目，那么精确保存此版本是有意义的，因为您将在消息视图中立即收到有关可能丢失数据的通知。 如果项目文件没有写保护，那么 CODESYS 将其保存在选定的路径中。否则，您将被告知如何进行。 如果当前项目包含未包含在所需内存格式中的附加组件，则 扩展配置文件 对话框打开。 选择插件扩展内存格式，以便保存插件数据。 要永久保存内存格式，请单击 保存个人信息 并在中指定一个名称 输入个人资料名称 对话。 在里面 扩展配...", 
"body" : "要求：项目已打开。 点击 文件 → 将项目另存为 。 这 保存项目 对话框打开。 选择文件系统中的位置和所需的 文件类型 （项目文件或库文件）和所需的存储版本。如果您想稍后在旧版本中打开项目，那么精确保存此版本是有意义的，因为您将在消息视图中立即收到有关可能丢失数据的通知。 如果项目文件没有写保护，那么 CODESYS 将其保存在选定的路径中。否则，您将被告知如何进行。 如果当前项目包含未包含在所需内存格式中的附加组件，则 扩展配置文件 对话框打开。 选择插件扩展内存格式，以便保存插件数据。 要永久保存内存格式，请单击 保存个人信息 并在中指定一个名称 输入个人资料名称 对话。 在里面 扩展配置文件 对话框，选择 使用保存的配置文件 选项并单击 是的 . CODESYS 使用保存的配置文件和新的存储格式保存项目。新的存储格式显示在 项目 → 项目信息 , 文件 标签。 " }, 
{ "title" : "保存只读项目 ", 
"url" : "_cds_saving_project.html#UUID-1bc9d9ae-6670-3dc0-ea69-bcf82769aa81_id_dcaaa6487a164c0a8640e003a1189_id_00663280b906498fc0a8640e01c6ebb3", 
"breadcrumbs" : "CODESYS Essentials \/ 保护和保存项目 \/ 保存项目 \/ 保存只读项目 ", 
"snippet" : "要求：已打开一个只读项目。 点击 文件 → 保存项目 。 如果写保护被分配在 CODESYS ，然后它将在主窗口的右上角以一条线显示。根据当前情况，您将获得以下一项或多项操作，以便您仍然可以保存项目： 在磁盘上以不同的文件名保存项目 ：始终出现并持续到 保存项目 对话框，至于 将项目另存为 命令 退出只读模式 ：显示，如果 以只读方式打开 打开项目时选择了选项 从磁盘上的项目中删除只读属性 ：如果项目文件在本地文件系统中打开时提供了“只读”属性，则显示 删除项目信息中的“已发布”标识 ：仅当当前设置了此属性时才显示 如果写保护被分配之外 CODESYS 在文件系统中项目文件的属性中，当您尝试以...", 
"body" : "要求：已打开一个只读项目。 点击 文件 → 保存项目 。 如果写保护被分配在 CODESYS ，然后它将在主窗口的右上角以一条线显示。根据当前情况，您将获得以下一项或多项操作，以便您仍然可以保存项目： 在磁盘上以不同的文件名保存项目 ：始终出现并持续到 保存项目 对话框，至于 将项目另存为 命令 退出只读模式 ：显示，如果 以只读方式打开 打开项目时选择了选项 从磁盘上的项目中删除只读属性 ：如果项目文件在本地文件系统中打开时提供了“只读”属性，则显示 删除项目信息中的“已发布”标识 ：仅当当前设置了此属性时才显示 如果写保护被分配之外 CODESYS 在文件系统中项目文件的属性中，当您尝试以相同的名称和路径保存时，您将获得以下选项： 另存为 ：您可以使用不同的名称保存 将项目另存为 命令。 覆盖 ：从项目文件中删除写保护，文件以其现有名称保存。 单击主窗口右上角指示写保护的行。 您仍然可以用来保存项目的当前选项显示在选择菜单中。 选择提供的选项之一并执行任何必要的操作。 点击 文件 → 保存项目 或者 文件 → 将项目另存为 。 可以保存项目。 " }, 
{ "title" : "自动保存项目；创建备份副本 ", 
"url" : "_cds_saving_project.html#UUID-1bc9d9ae-6670-3dc0-ea69-bcf82769aa81_id_dcaaa6487a164c0a8640e003a1189_id_87e64193d38533efc0a8640e01f1fc6f", 
"breadcrumbs" : "CODESYS Essentials \/ 保护和保存项目 \/ 保存项目 \/ 自动保存项目；创建备份副本 ", 
"snippet" : "要求：项目已打开。 点击 工具 → 选项 和 加载和保存 类别。 这 加载和保存 对话框打开。 激活 创建备份副本 选项。 选择 每……分钟自动保存一次 选项并选择时间间隔。 点击 行 关闭 选项 对话。 每次保存项目时， CODESYS 还会创建一个名为 <project name>.backup . CODESYS 以指定的时间间隔自动将项目保存到文件中 <project name>.autosave 在项目目录中。如果您在开发系统不定期关闭后再次打开项目，则该文件将作为用户上次保存的文件的替代文件提供给您。 有关更多信息，请参阅： 对话框：选项 - 加载和保存 和 保护和保存项目...", 
"body" : "要求：项目已打开。 点击 工具 → 选项 和 加载和保存 类别。 这 加载和保存 对话框打开。 激活 创建备份副本 选项。 选择 每……分钟自动保存一次 选项并选择时间间隔。 点击 行 关闭 选项 对话。 每次保存项目时， CODESYS 还会创建一个名为 <project name>.backup . CODESYS 以指定的时间间隔自动将项目保存到文件中 <project name>.autosave 在项目目录中。如果您在开发系统不定期关闭后再次打开项目，则该文件将作为用户上次保存的文件的替代文件提供给您。 有关更多信息，请参阅： 对话框：选项 - 加载和保存 和 保护和保存项目" }, 
{ "title" : "保存\/发送项目存档 ", 
"url" : "_cds_saving_project_archive.html", 
"breadcrumbs" : "CODESYS Essentials \/ 保护和保存项目 \/ 保存\/发送项目存档 ", 
"snippet" : "您可以配置项目存档，然后将其保存在文件系统中或直接通过电子邮件发送。 要发送，请按照以下指南直至第 9 点。在此处单击 发送 按钮而不是 保存 从那里打开默认的电子邮件程序。在那里会自动创建一封新电子邮件，其中包含附件中的项目存档。 要求：项目已打开。 点击 文件 → 项目存档 → 保存\/发送存档 . 这 项目档案 对话框打开。 选中要保存在存档中的每个对象旁边的复选框。 由于专有技术保护， CODESYS 不会自动将未受保护的库（意味着它们不像“编译库”那样存在）接受到项目存档中。如果您在要包含的信息列表中明确选择此类库，您将收到相应的警告。 要向存档添加更多文件，请单击 附加文件 . 这 ...", 
"body" : "您可以配置项目存档，然后将其保存在文件系统中或直接通过电子邮件发送。 要发送，请按照以下指南直至第 9 点。在此处单击 发送 按钮而不是 保存 从那里打开默认的电子邮件程序。在那里会自动创建一封新电子邮件，其中包含附件中的项目存档。 要求：项目已打开。 点击 文件 → 项目存档 → 保存\/发送存档 . 这 项目档案 对话框打开。 选中要保存在存档中的每个对象旁边的复选框。 由于专有技术保护， CODESYS 不会自动将未受保护的库（意味着它们不像“编译库”那样存在）接受到项目存档中。如果您在要包含的信息列表中明确选择此类库，您将收到相应的警告。 要向存档添加更多文件，请单击 附加文件 . 这 附加文件 对话框打开。 点击 添加 . 选择文件并单击 打开 . 这些文件被添加到附加文件列表中。 点击 行 . 点击 评论 . 对话框 评论 打开。 输入评论并点击 行 . 点击 保存 按钮。 选择位置和文件名，然后单击 保存 . 项目存档保存在文件目录中。 有关更多信息，请参阅： 命令：将项目另存为 和 保存项目" }, 
{ "title" : "将项目链接到源代码控制系统 ", 
"url" : "_cds_keeping_project_in_sourcecode_management.html", 
"breadcrumbs" : "CODESYS Essentials \/ 保护和保存项目 \/ 将项目链接到源代码控制系统 ", 
"snippet" : "链接您的 CODESYS 项目到源代码控制系统，请考虑以下选项： 这 CODESYS SVN 附加组件提供直接链接到 SVN 数据库的能力。您可以在 CODESYS Store International 并在包管理器的帮助下安装它。 使用时查看对应帮助 CODESYS SVN ....", 
"body" : "链接您的 CODESYS 项目到源代码控制系统，请考虑以下选项： 这 CODESYS SVN 附加组件提供直接链接到 SVN 数据库的能力。您可以在 CODESYS Store International 并在包管理器的帮助下安装它。 使用时查看对应帮助 CODESYS SVN . " }, 
{ "title" : "本地化项目 ", 
"url" : "_cds_struct_project_localization.html", 
"breadcrumbs" : "CODESYS Essentials \/ 本地化项目 ", 
"snippet" : "当您创建和链接本地化文件时，您可以用不同的语言显示您的项目。本地化文件对应于 GNU gettext 系统。本地化模板文件的格式是 *.pot (Portable Object Template)，本地化文件来自 *.po (Portable Object) 是翻译后生成的。 该项目可以本地化为不同的语言。但是，只能在原始版本中进行编辑。 您可以配置项目中本地化的文本信息类别。然后将这些文本导出到翻译模板中。这个模板是一个pot格式的文件（例如： project_1.pot ）。您生成格式为的本地化文件 *.po （例子： de.po, en.po, es.po )，可以使用相应的外部翻译工具...", 
"body" : "当您创建和链接本地化文件时，您可以用不同的语言显示您的项目。本地化文件对应于 GNU gettext 系统。本地化模板文件的格式是 *.pot (Portable Object Template)，本地化文件来自 *.po (Portable Object) 是翻译后生成的。 该项目可以本地化为不同的语言。但是，只能在原始版本中进行编辑。 您可以配置项目中本地化的文本信息类别。然后将这些文本导出到翻译模板中。这个模板是一个pot格式的文件（例如： project_1.pot ）。您生成格式为的本地化文件 *.po （例子： de.po, en.po, es.po )，可以使用相应的外部翻译工具自动进行，也可以使用中性文本编辑器手动进行。您可以将 *.po 文件重新导入 CODESYS 并将它们用于本地化。 使用项目本地化的命令位于 项目 → 项目本地化 菜单。 切换本地化，添加和删除本地化文件 需求：所有需要的语言都通过导入对应的方式存放在项目中 *.po 文件。该项目已打开。 点击 项目 → 项目本地化 → 管理本地化 . 这 管理本地化 对话框打开。所有存储的本地化文件 *-<language>.po 出现在 文件 ，以及条目 <原版> . 选择所需的语言并单击 交换机本地化 按钮。 项目以所选语言显示。当您选择 <原版> ，项目以原始的、未本地化的版本显示，并且无法编辑。 可选：定义默认本地化，切换本地化 选择一种可用的本地化并激活 默认本地化 选项。 点击 项目 → 项目本地化 → 切换本地化 在默认本地化和原始版本之间切换本地化。默认情况下，此命令也可通过 工具栏上的按钮。 有关更多信息，请参阅： 命令：切换本地化 和 命令：管理本地化 " }, 
{ "title" : "创建本地化模板 ", 
"url" : "_cds_struct_project_localization.html#UUID-994c8b2e-49d4-9de2-c694-8c1b4b85461a_id_b853c50bc4d5ff73c0a8640e009b2d8a_id_4fc598d1c536a795c0a8640e00012b41", 
"breadcrumbs" : "CODESYS Essentials \/ 本地化项目 \/ 创建本地化模板 ", 
"snippet" : "要求：项目已打开。 点击 项目 → 项目本地化 → 创建本地化模板 . 这 创建本地化模板 对话框打开。 激活应包含在本地化模板中的文本信息类别。 职位信息 也可以包含在模板中。对于每个要翻译的文本，指定其在项目中的位置。选择要在翻译模板中显示的位置：仅找到第一个位置、找到所有位置或无。 点击 产生 按钮。 对话框打开以保存 *.pot 文件到文件系统。保存本地化模板。然后您可以在翻译工具中处理文件并生成本地化文件 <language>.po 使用所需的语言。...", 
"body" : "要求：项目已打开。 点击 项目 → 项目本地化 → 创建本地化模板 . 这 创建本地化模板 对话框打开。 激活应包含在本地化模板中的文本信息类别。 职位信息 也可以包含在模板中。对于每个要翻译的文本，指定其在项目中的位置。选择要在翻译模板中显示的位置：仅找到第一个位置、找到所有位置或无。 点击 产生 按钮。 对话框打开以保存 *.pot 文件到文件系统。保存本地化模板。然后您可以在翻译工具中处理文件并生成本地化文件 <language>.po 使用所需的语言。 " }, 
{ "title" : "本地化模板格式：文件 *.pot ", 
"url" : "_cds_struct_project_localization.html#UUID-994c8b2e-49d4-9de2-c694-8c1b4b85461a_id_b853c50bc4d5ff73c0a8640e009b2d8a_id_653b77f4c56ecbd9c0a8640e01a43f78", 
"breadcrumbs" : "CODESYS Essentials \/ 本地化项目 \/ 本地化模板格式：文件 *.pot ", 
"snippet" : "在第一行中，指定了在生成模板时为翻译选择的文本类别： 示例：选择了所有 4 个类别： #: Content:Comments|Identifiers|Names|Strings 然后将要翻译的每个文本以如下示例的形式分段： 例子 #: D:\\Projects\\p1.project\\Project_Settings:1 msgid \"Project Settings\" msgstr \"\" 第 1 行：作为源代码参考显示的位置信息。仅当生成翻译文件时已配置此项时才显示。 第 2 行：未翻译的文本作为条目 msgid （例子： msgid \"Project Settings\" ）。 第 3 行：翻译...", 
"body" : "在第一行中，指定了在生成模板时为翻译选择的文本类别： 示例：选择了所有 4 个类别： #: Content:Comments|Identifiers|Names|Strings 然后将要翻译的每个文本以如下示例的形式分段： 例子 #: D:\\Projects\\p1.project\\Project_Settings:1\nmsgid \"Project Settings\"\nmsgstr \"\" 第 1 行：作为源代码参考显示的位置信息。仅当生成翻译文件时已配置此项时才显示。 第 2 行：未翻译的文本作为条目 msgid （例子： msgid \"Project Settings\" ）。 第 3 行：翻译的占位符： msgstr \"\" .在单直引号之间，翻译在 *.po 文件必须以相应的语言插入。 " }, 
{ "title" : "本地化文件格式： *-<language>.po ", 
"url" : "_cds_struct_project_localization.html#UUID-994c8b2e-49d4-9de2-c694-8c1b4b85461a_id_b853c50bc4d5ff73c0a8640e009b2d8a_id_659fed17c536a796c0a8640e017333a5", 
"breadcrumbs" : "CODESYS Essentials \/ 本地化项目 \/ 本地化文件格式： *-<language>.po ", 
"snippet" : "您可以生成一个 *.po 使用翻译工具创建文件，或使用基于 *.pot 文件。为此，您可以将文件扩展名从 *.pot 到 *.po 并根据 *.po 标准格式。 必须在文件的元数据中以常用语言环境代码的形式指定语言（例如： \"Language: de\" 为德语。然后在直引号之间插入单个文本的翻译 msgstr \"\" 条目。 例子 \"Language: de\\n\" #: Content:Names #: D:\\projects\\p1.project\\Project_Settings:1 msgid \"Project Settings\" msgstr \"Projekteinstellungen\"...", 
"body" : "您可以生成一个 *.po 使用翻译工具创建文件，或使用基于 *.pot 文件。为此，您可以将文件扩展名从 *.pot 到 *.po 并根据 *.po 标准格式。 必须在文件的元数据中以常用语言环境代码的形式指定语言（例如： \"Language: de\" 为德语。然后在直引号之间插入单个文本的翻译 msgstr \"\" 条目。 例子 \"Language: de\\n\"\n#: Content:Names\n#: D:\\projects\\p1.project\\Project_Settings:1\nmsgid \"Project Settings\"\nmsgstr \"Projekteinstellungen\" " }, 
{ "title" : "导入本地化文件\/本地化项目 ", 
"url" : "_cds_struct_project_localization.html#UUID-994c8b2e-49d4-9de2-c694-8c1b4b85461a_id_b853c50bc4d5ff73c0a8640e009b2d8a_id_aa02f6d3c536a798c0a8640e01fb3258", 
"breadcrumbs" : "CODESYS Essentials \/ 本地化项目 \/ 导入本地化文件\/本地化项目 ", 
"snippet" : "要求：对于您的项目，本地化文件（ <language>.po ) 是根据翻译模板生成的 *.pot .该项目已打开。 点击 项目 → 项目本地化 → 管理本地化 . 点击 添加 按钮。 这 打开本地化文件 出现选择一个对话框 *.po 文件系统中的文件。 选择一个本地化文件（例如： <project name>-de.po ）。 对话框关闭，受影响的文本以相应的语言出现在项目中。例如，如果您指定翻译 msgstr \"Main program\" 对于英文本地化文件中的 POU 名称“PLC_PRG”，则在设备树中显示对象名称“Main program”。 同样，您可以导入其他语言目标的本地化文件...", 
"body" : "要求：对于您的项目，本地化文件（ <language>.po ) 是根据翻译模板生成的 *.pot .该项目已打开。 点击 项目 → 项目本地化 → 管理本地化 . 点击 添加 按钮。 这 打开本地化文件 出现选择一个对话框 *.po 文件系统中的文件。 选择一个本地化文件（例如： <project name>-de.po ）。 对话框关闭，受影响的文本以相应的语言出现在项目中。例如，如果您指定翻译 msgstr \"Main program\" 对于英文本地化文件中的 POU 名称“PLC_PRG”，则在设备树中显示对象名称“Main program”。 同样，您可以导入其他语言目标的本地化文件。 " }, 
{ "title" : "创建项目模板 ", 
"url" : "_cds_create_project_template.html", 
"breadcrumbs" : "CODESYS Essentials \/ 创建项目模板 ", 
"snippet" : "您可以创建自己的项目模板，可以在 模板 面积 新项目 创建新项目时的对话框（ *.project 或者 *.library ）。您还可以定义项目模板是否应包含在 项目 和 图书馆 对话框中默认显示的文件夹或您自己创建的文件夹。这些文件夹显示在 新项目 对话中的 类别 区域。 在 CODESYS Development System ，创建一个项目，作为其他项目的模板。 将项目保存在 Templates 安装目录的文件夹 CODESYS 。 在文本编辑器中，创建一个新的模板文件 <template name>.template 。 根据以下示例文件编辑此文件： <?xml version=\"1....", 
"body" : "您可以创建自己的项目模板，可以在 模板 面积 新项目 创建新项目时的对话框（ *.project 或者 *.library ）。您还可以定义项目模板是否应包含在 项目 和 图书馆 对话框中默认显示的文件夹或您自己创建的文件夹。这些文件夹显示在 新项目 对话中的 类别 区域。 在 CODESYS Development System ，创建一个项目，作为其他项目的模板。 将项目保存在 Templates 安装目录的文件夹 CODESYS 。 在文本编辑器中，创建一个新的模板文件 <template name>.template 。 根据以下示例文件编辑此文件： <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<ProjectTemplate>\t\n <Name>\t\n <DefaultString>Test_Project_Template<\/DefaultString>\t\n <LocalizedString Culture=\"de\">Test_Projekttemplate<\/LocalizedString>\t\n <\/Name>\t\n\n <Folder>\t\t\n <DefaultString>Projects<\/DefaultString>\t\t\n <LocalizedString Culture=\"de\">Projekte<\/LocalizedString>\t\n <\/Folder>\t\n\n <Description>\n\t<DefaultString>A project with a GVL<\/DefaultString>\t\n\t<LocalizedString Culture=\"de\">Ein Projekt mit einer GVL<\/LocalizedString>\t\n <\/Description>\t\n\n <DefaultFileName>\t\t\n <DefaultString>Test Project<\/DefaultString>\t\t\n <LocalizedString Culture=\"de\">Testprojekt<\/LocalizedString>\t\n <\/DefaultFileName>\t\n\n <Extension>.project<\/Extension>\t\n <TemplatePath>TemplateTest.project<\/TemplatePath>\n<\/ProjectTemplate> 不同标签的内容： Name ：项目模板的名称，显示在 模板 面积 新项目 对话。 Folder ：保存项目模板的文件夹名称。显示在 类别 面积 新项目 对话。 如果指定不存在的文件夹名称，那么将创建具有该名称的新文件夹。 Description ：项目模板说明 描述显示在 新项目 选择模板时的对话框。 DefaultFileName ：新项目的默认名称。名称显示在 姓名 领域的 新项目 对话框并可在那里进行编辑。 Extension ： .project ：此模板用于创建 CODESYS 项目 .project 。 .library ：此模板用于创建库项目 .library 。 TemplatePath ：模板项目的文件路径 ..\/Templates 安装目录 CODESYS 例子： TemplateTest.project ： 这 TemplateTest.project 模板项目位于 ..\/Templates 目录。 Library_Template\/CODESYS_Template.library ： 这 CODESYS_Template.library 模板项目位于 ..\/Templates\/Library_Template 目录。 如果文本 CODESYS 应以 CODESYS 界面，然后使用 LocalizedString （见上面的例子）。 保存创建的模板文件（ .template ）并将其存储在 ..\/Templates 安装目录的文件夹。 现在当你打开 CODESYS 并点击 文件 → 新项目 ，您刚刚创建的项目模板将在 新项目 新项目的对话框。 " }, 
{ "title" : "配置 I\/O 链接 ", 
"url" : "_cds_struct_io_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 ", 
"snippet" : "在设备对象的帮助下，您可以在您的设备中以树形结构映射要控制的硬件 CODESYS 项目。这使得硬件和应用程序的链接易于处理。 在设备对象的配置编辑器中，您可以配置之间的通信设置 CODESYS 和控制器，最重要的是 I\/O 映射。 I\/O 映射是控制器的输入和输出与应用程序变量的链接。 根据设备，可以通过“在线用户管理”控制运行时对控制对象的访问，您可以在 CODESYS Development System .此外，与控制器的通信取决于当前的“安全设置”。...", 
"body" : "在设备对象的帮助下，您可以在您的设备中以树形结构映射要控制的硬件 CODESYS 项目。这使得硬件和应用程序的链接易于处理。 在设备对象的配置编辑器中，您可以配置之间的通信设置 CODESYS 和控制器，最重要的是 I\/O 映射。 I\/O 映射是控制器的输入和输出与应用程序变量的链接。 根据设备，可以通过“在线用户管理”控制运行时对控制对象的访问，您可以在 CODESYS Development System .此外，与控制器的通信取决于当前的“安全设置”。 " }, 
{ "title" : "设备树和设备编辑器 ", 
"url" : "_cds_device_tree_device_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 设备树和设备编辑器 ", 
"snippet" : "设备编辑器 您可以配置之间的通信设置 CODESYS 和标签上的目标设备 设备编辑器 .双击设备树中的设备对象以打开编辑器。 编辑器包括通用选项卡和特定选项卡。它的标题包含设备名称。 有关更多信息，请参阅： 配置设备和 I\/O 映射...", 
"body" : "设备编辑器 您可以配置之间的通信设置 CODESYS 和标签上的目标设备 设备编辑器 .双击设备树中的设备对象以打开编辑器。 编辑器包括通用选项卡和特定选项卡。它的标题包含设备名称。 有关更多信息，请参阅： 配置设备和 I\/O 映射" }, 
{ "title" : "设备树 ", 
"url" : "_cds_device_tree_device_editor.html#UUID-7bc193e4-b97a-a4e3-f11d-5776c956d246_id_e039ebc3920863bc0a8640e01ade420_id_855d3ce2ce443b2fc0a8640e00ffb1ef", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 设备树和设备编辑器 \/ 设备树 ", 
"snippet" : "在里面 设备 查看（也称为“设备树”），您可以根据目标设备组织应用程序。在此视图中，您可以查看 PLC 硬件和现场总线系统、配置硬件通信和分配应用程序。 设备树的根节点是一个符号节点条目： <项目名称> . 为一个或多个 PLC（也称为“目标系统”）在此节点下方插入设备对象。每个设备对象代表一个特定的硬件组件，例如控制器、现场总线、总线耦合器、驱动器、I\/O 模块或监视器。添加对象时，添加助手会通过提供本地设备存储库中的所有可能设备来帮助您。 如果您已经连接到控制器网络，则可以扫描硬件以查找可用设备并将它们保存到当前配置中的设备树中。 为了在设备树中创建设备对象（映射到控制硬件环境），适用特定...", 
"body" : "在里面 设备 查看（也称为“设备树”），您可以根据目标设备组织应用程序。在此视图中，您可以查看 PLC 硬件和现场总线系统、配置硬件通信和分配应用程序。 设备树的根节点是一个符号节点条目： <项目名称> . 为一个或多个 PLC（也称为“目标系统”）在此节点下方插入设备对象。每个设备对象代表一个特定的硬件组件，例如控制器、现场总线、总线耦合器、驱动器、I\/O 模块或监视器。添加对象时，添加助手会通过提供本地设备存储库中的所有可能设备来帮助您。 如果您已经连接到控制器网络，则可以扫描硬件以查找可用设备并将它们保存到当前配置中的设备树中。 为了在设备树中创建设备对象（映射到控制硬件环境），适用特定规则（见下文）。应用程序对象和设备对象的分层布局定义了其他对象的范围，例如库和 GVL。 有可编程设备和严格参数化设备。设备类型定义了设备树中可能的插入点以及可以在设备下方插入的对象的选择。可编程设备自动获得额外的 PLC逻辑 设备对象下方的节点，严格用于组织目的。在该节点下方，插入设备编程所需的对象（例如，应用程序和 GVL 或文本列表）。 每个设备都由设备描述定义，并且必须安装在本地系统上才能插入到设备树中。设备描述文件定义了可配置性、可编程性和与其他设备的可能连接的设备属性。 这 POU 视图包括可在整个项目中使用的对象。用于特定应用程序的编程对象必须插入到应用程序对象的下方 设备 查看（设备树）。 请注意让活动应用程序在“模拟设备”上运行的选项，这是开发系统中默认提供的。目前，此模拟选项可用于 CODESYS Control Win 目标系统。在仿真模式下，您还可以在没有硬件的情况下测试应用程序的在线功能。点击 在线 → 模拟 启用模拟模式。 请注意通过以下方式建立与设备的连接的选项 在线配置模式 应用程序的命令，而无需事先加载应用程序。这对于 I\/O 系统的初始调试很有用，因为在编程和下载实际应用程序之前，您可以在 PLC 配置中使用它来引用和测试 I\/O。 设备树示例： (1) 可编程设备（带应用程序） (2) 符号设备名称 (3) 设备类型，在设备描述中定义 (4) 纯参数化设备 设备树中的设备条目由符号、树中可编辑的符号设备名称和设备类型（设备描述中定义的设备名称）组成。 所有具有总线周期设置的设备以及用于任意数量的总线周期任务的任务也标有 符号。对于带有此符号的任务和设备，还会显示工具提示。对于任务，工具提示会显示所使用的设备。对于设备，工具提示显示任务 在对话框中配置设备通信、参数和 IO 映射 设备编辑器 .通过双击设备对象打开此编辑器。 " }, 
{ "title" : "在设备树中排列和配置对象的规则和程序 ", 
"url" : "_cds_device_tree_device_editor.html#UUID-7bc193e4-b97a-a4e3-f11d-5776c956d246_id_e039ebc3920863bc0a8640e01ade420_id_67d7c878777219b2c0a8640e01e97928", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 设备树和设备编辑器 \/ 在设备树中排列和配置对象的规则和程序 ", 
"snippet" : "在设备树中排列和配置对象的规则和程序 插入对象 要插入设备对象，请单击 添加设备 或者 插入设备 通过右键单击设备树。对于其他对象，单击 添加对象 . CODESYS 始终在树中当前选定的位置提供合适的对象。示例：PROFIBUS DP 从站的模块只能插入相应的从站对象下方，应用程序只能插入可编程设备下方。设备对象的选择还取决于设备存储库中安装了哪些设备。 以下建议和规则适用于对象的名称： 大小不得超过 80 个字符。超过 80 个字符会生成编译器警告。 只允许使用字母数字字符和下划线。 第一个字符必须是字母或下划线。 你只能 插入设备对象 在正下方的水平 <项目名称> 根节点。如果您选择其他...", 
"body" : "在设备树中排列和配置对象的规则和程序 插入对象 要插入设备对象，请单击 添加设备 或者 插入设备 通过右键单击设备树。对于其他对象，单击 添加对象 . CODESYS 始终在树中当前选定的位置提供合适的对象。示例：PROFIBUS DP 从站的模块只能插入相应的从站对象下方，应用程序只能插入可编程设备下方。设备对象的选择还取决于设备存储库中安装了哪些设备。 以下建议和规则适用于对象的名称： 大小不得超过 80 个字符。超过 80 个字符会生成编译器警告。 只允许使用字母数字字符和下划线。 第一个字符必须是字母或下划线。 你只能 插入设备对象 在正下方的水平 <项目名称> 根节点。如果您选择其他对象类型，例如文本列表，则 CODESYS 自动将其插入 POU 视图（项目全局池）。 插入应用程序 您可以插入一个 应用 对象仅低于 PLC逻辑 节点（可编程设备）。所有应用程序必须为每个设备唯一命名。在每个应用程序下方，您可以插入更多编程所需的对象，例如 POU、DUT、GVL 或可视化。 在每个应用程序下方，您必须插入任务配置并配置相应的程序调用（来自特定于应用程序的 POU，或来自 POU 看法）。 如果设备正下方存在多个应用程序，则需要为设备的 I\/O 处理定义设置。这包括应用程序的变量 CODESYS 用于与目标系统通信。设置是在 PLC 设置 设备编辑器的选项卡。 应用程序和范围的分层布局：您可以在另一个应用程序下方添加一个应用程序。我们将生成的构造命名为：“父应用程序”-“子应用程序”。在这种情况下，以下情况适用：子应用程序可以访问父应用程序中的对象，但不能访问其他方向。这样做的原因是子应用程序应该始终是可移动或可交换的，而不会影响父应用程序。 笔记 更改父应用程序后，执行在线更改时，会从控制器中删除子应用程序。 插入设备 CODESYS 在树中插入一个设备对象作为节点。如果在设备描述中定义了节点，则会自动插入它们。一个子节点也可以代表一个可编程设备。树中设备对象的顺序（从上到下）：对于每个级别，可编程设备（PLC 逻辑）首先列出，然后按字母顺序列出其他类型。 更新设备 已插入设备树的设备可以被同一设备的另一个版本或另一种类型的设备替换（ 更新设备 ）。如果可能，设备下方的配置树是可用的。 移动和删除对象 您可以使用标准命令 切 , 复制 , 粘贴 ， 和 删除 在对象上，或将对象拖到另一个位置。当您复制对象时，新对象将获得相同的名称和递增的编号。 网络扫描（当前硬件） 默认情况下，具有扫描功能的设备编辑器支持在设备树中创建 PLC 配置。扫描当前硬件环境，并在对话框中显示检测到的模块。从那里，您可以将所需的设备直接保存到设备树中。见 扫描设备 命令。 有关更多信息，请参阅： 在设备树中映射硬件结构" }, 
{ "title" : "在线模式下的设备树 ", 
"url" : "_cds_device_tree_device_editor.html#UUID-7bc193e4-b97a-a4e3-f11d-5776c956d246_id_e039ebc3920863bc0a8640e01ade420_id_1bf1cadc777219b4c0a8640e00127639", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 设备树和设备编辑器 \/ 在线模式下的设备树 ", 
"snippet" : "在在线模式下，设备条目前的符号指示设备状态。 ：PLC 已连接，应用程序正在运行，设备正在运行，正在交换数据。这 在停止中刷新 I\/O 上的复选框 PLC 设置 可以选择或清除选项卡。 ：PLC 已连接并在 停止 ;和 在停止中刷新 I\/O 上的复选框 PLC 设置 选项卡被清除。 ：设备不交换数据；总线错误、无配置或仿真模式。 ：设备在试用模式下运行 30 分钟。这段时间过去后，试用模式将结束，现场总线将终止数据交换。 ：设备已配置，但未完全运行。没有数据交换。示例案例：CANopen 设备在启动和预运行模式下。 ：冗余模式已激活。现场总线主站没有发送任何数据，因为另一个主站处于活动状态。 ...", 
"body" : "在在线模式下，设备条目前的符号指示设备状态。 ：PLC 已连接，应用程序正在运行，设备正在运行，正在交换数据。这 在停止中刷新 I\/O 上的复选框 PLC 设置 可以选择或清除选项卡。 ：PLC 已连接并在 停止 ;和 在停止中刷新 I\/O 上的复选框 PLC 设置 选项卡被清除。 ：设备不交换数据；总线错误、无配置或仿真模式。 ：设备在试用模式下运行 30 分钟。这段时间过去后，试用模式将结束，现场总线将终止数据交换。 ：设备已配置，但未完全运行。没有数据交换。示例案例：CANopen 设备在启动和预运行模式下。 ：冗余模式已激活。现场总线主站没有发送任何数据，因为另一个主站处于活动状态。 ：在设备存储库中找不到设备描述。 ：设备本身正在运行，但子设备未运行或有诊断消息。由于设备树折叠，子设备不可见。 ：灰色感叹号：诊断未决。但是，错误的原因已不存在或已解决。此符号可以与此列表中的各种其他符号一起出现。 ：红色感叹号：设备未运行或诊断未决。错误原因仍然存在。此符号可以与此列表中的各种其他符号一起出现。 所有连接的设备和应用程序的名称都以绿色突出显示： 在仿真模式下运行的设备名称以斜体显示： . 附加诊断信息位于 地位 相应设备编辑器的选项卡。 如果您在目标设备上的设备描述比项目中的更新时登录，则会打开一个警告提示，可能会取消该过程。 有关更多信息，请参阅： 命令：确认诊断，子树确认诊断 和 将应用程序下载到 PLC" }, 
{ "title" : "POU 颜色的含义 ", 
"url" : "_cds_device_tree_device_editor.html#UUID-7bc193e4-b97a-a4e3-f11d-5776c956d246_section-idm234735523635194", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 设备树和设备编辑器 \/ POU 颜色的含义 ", 
"snippet" : "设备树中 POU 的名称有时会以不同的颜色显示。 这些颜色具有以下含义： 黑色：默认颜色；无具体含义 灰色：在代码生成后显示，表示项目中未使用 POU 蓝色：生成代码后以及项目已下载一次时显示。与控制器上的 POU 相比，POU 已更改，将包含在下次下载中 蓝绿色：POU 有 从编译中排除 属性集。...", 
"body" : "设备树中 POU 的名称有时会以不同的颜色显示。 这些颜色具有以下含义： 黑色：默认颜色；无具体含义 灰色：在代码生成后显示，表示项目中未使用 POU 蓝色：生成代码后以及项目已下载一次时显示。与控制器上的 POU 相比，POU 已更改，将包含在下次下载中 蓝绿色：POU 有 从编译中排除 属性集。 " }, 
{ "title" : "在设备树中映射硬件结构 ", 
"url" : "_cds_mapping_hardware_in_device_tree.html", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 在设备树中映射硬件结构 ", 
"snippet" : "您将您控制的硬件与您的应用程序映射到 设备 查看（设备树）。为此，将设备对象插入此树结构中，该树结构表示网络中的物理设备，直到层次结构反映控制器网络。例如，设备对象是 PLC 对象、现场总线对象或逻辑设备。...", 
"body" : "您将您控制的硬件与您的应用程序映射到 设备 查看（设备树）。为此，将设备对象插入此树结构中，该树结构表示网络中的物理设备，直到层次结构反映控制器网络。例如，设备对象是 PLC 对象、现场总线对象或逻辑设备。 " }, 
{ "title" : "在设备树中使用现场总线映射标准控制器 ", 
"url" : "_cds_mapping_hardware_in_device_tree.html#UUID-ae97416f-7f9b-10e7-4389-bfe2604cc6e5_id_f9c9ce5177757233c0a8640e003c07f9_id_b09bd7f45a802de8c0a8640e0116665b", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 在设备树中映射硬件结构 \/ 在设备树中使用现场总线映射标准控制器 ", 
"snippet" : "下面您将映射包含标准 PLC 和标准现场总线的硬件。 点击 文件 → 新项目 . 在里面 新项目 对话框，选择 标准项目 模板。 在里面 标准项目 对话框，选择 CODESYS Control Win 设备。 CODESYS 插入 Device ( CODESYS Control Win ) 对象在根节点下方的设备树中，在其下方 PLC逻辑 节点，它总是提供一个可编程设备对象。一个 应用 对象存在于其下方，并且 图书馆经理 , PLC_PRG ， 和 任务配置 对象存在于其下方。 选择 Device 输入并点击 添加设备 在上下文菜单中。 这 添加设备 对话框提供您系统上安装的设备的选择。 “...", 
"body" : "下面您将映射包含标准 PLC 和标准现场总线的硬件。 点击 文件 → 新项目 . 在里面 新项目 对话框，选择 标准项目 模板。 在里面 标准项目 对话框，选择 CODESYS Control Win 设备。 CODESYS 插入 Device ( CODESYS Control Win ) 对象在根节点下方的设备树中，在其下方 PLC逻辑 节点，它总是提供一个可编程设备对象。一个 应用 对象存在于其下方，并且 图书馆经理 , PLC_PRG ， 和 任务配置 对象存在于其下方。 选择 Device 输入并点击 添加设备 在上下文菜单中。 这 添加设备 对话框提供您系统上安装的设备的选择。 “安装在系统上”意味着 CODESYS 已收到相应硬件的设备描述。因此，您可以在项目中使用设备对象和关联的配置编辑器。 选择提供的 PLC 之一（例如： CAN总线 ) 并单击 添加设备 按钮。 这 CAN总线 对象显示在下面缩进的设备树中 Device ( CODESYS ）。这 添加设备 对话框保持打开状态。现在，当您选择新的 CAN总线 条目，它会自动提供可在其下插入的对象。 例如，选择 CANopen 设备 来自 本地设备 类别。 CANopen_Device 被缩进插入 CAN总线 在设备树中。 您想在之前添加的设备上添加不同的设备吗？选择设备条目并单击 更新设备 在上下文菜单中。 这 更新设备 对话框打开。它对应于 添加设备 以前使用的对话框。您可以选择另一个设备，然后将其插入树中以代替前一个设备。 " }, 
{ "title" : "扫描当前硬件并将设备应用到项目中 ", 
"url" : "_cds_mapping_hardware_in_device_tree.html#UUID-ae97416f-7f9b-10e7-4389-bfe2604cc6e5_id_f9c9ce5177757233c0a8640e003c07f9_id_00318a175a802de8c0a8640e017d9869", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 在设备树中映射硬件结构 \/ 扫描当前硬件并将设备应用到项目中 ", 
"snippet" : "您可以确定硬件环境网络中的设备（扫描）并将找到的设备应用到项目的设备树中。 如果扫描功能在 PLC 中永久实现，则无需进一步准备即可执行扫描。以此目的， CODESYS 建立与控制器的临时连接。如果在库中提供扫描功能，则必须将包含该库的设备插入设备树中并执行对控制器的登录。只有在此之后，才能将库放置在控制器上，使扫描成为可能。 扫描是通过 扫描设备 命令。它指的是当前在设备树中选择并链接到项目的控制器。例如，您可以选择一个插入的 PROFINET IO 控制器并使用该命令来确定分配给它的 I\/O 设备和 I\/O 模块。 要求：您的项目具有设备配置。通讯设置正确。网关和硬件正在运行。 在设备树中...", 
"body" : "您可以确定硬件环境网络中的设备（扫描）并将找到的设备应用到项目的设备树中。 如果扫描功能在 PLC 中永久实现，则无需进一步准备即可执行扫描。以此目的， CODESYS 建立与控制器的临时连接。如果在库中提供扫描功能，则必须将包含该库的设备插入设备树中并执行对控制器的登录。只有在此之后，才能将库放置在控制器上，使扫描成为可能。 扫描是通过 扫描设备 命令。它指的是当前在设备树中选择并链接到项目的控制器。例如，您可以选择一个插入的 PROFINET IO 控制器并使用该命令来确定分配给它的 I\/O 设备和 I\/O 模块。 要求：您的项目具有设备配置。通讯设置正确。网关和硬件正在运行。 在设备树中选择一个控制器对象。 在上下文菜单中，单击 扫描设备 . CODESYS 建立与硬件的连接。这 扫描设备 对话框打开。根据设备的类型，它提供不同的功能。但是，始终会出现一个表格，显示在硬件中找到的设备：设备名称、设备类型、站名称等。有关此内容的更多信息，请参阅相应设备编辑器的帮助。 为了使列表仅显示您在项目的设备配置中尚未找到的设备，请选择 显示与项目的差异 选项。 要将设备应用到项目的设备树中，请选择表中的条目并单击 复制到项目 按钮。如果您不选择条目，则会应用找到的所有设备。 相应的条目被插入到设备树中。 " }, 
{ "title" : "在控制器的帮助下检查控制器配置 在线配置模式 命令 ", 
"url" : "_cds_mapping_hardware_in_device_tree.html#UUID-ae97416f-7f9b-10e7-4389-bfe2604cc6e5_section-idm53263079816560", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 在设备树中映射硬件结构 \/ 在控制器的帮助下检查控制器配置 在线配置模式 命令 ", 
"snippet" : "和 CODESYS 您可以测试目标系统的 I\/O 和现场总线的正确接线，而无需为控制器开发实际应用程序并将其加载到控制器中。这对于初始调试阶段很有趣。为此使用“简单在线组态模式”。如果控制器上已经存在应用程序，那么作为一个选项，如果设备支持，您也可以使用“高级在线配置模式”。这使您无需从受影响的应用程序登录即可读取设备参数 CODESYS . 简单的在线配置模式 您可以使用 在线配置模式 设备树中 PLC 对象的上下文菜单中的命令，以创建隐式应用程序。 CODESYS 自动将应用程序下载到 PLC 并通过应用程序自动初始化所有 I\/O。该应用程序名为 HiddenOnlineConfigMod...", 
"body" : "和 CODESYS 您可以测试目标系统的 I\/O 和现场总线的正确接线，而无需为控制器开发实际应用程序并将其加载到控制器中。这对于初始调试阶段很有趣。为此使用“简单在线组态模式”。如果控制器上已经存在应用程序，那么作为一个选项，如果设备支持，您也可以使用“高级在线配置模式”。这使您无需从受影响的应用程序登录即可读取设备参数 CODESYS . 简单的在线配置模式 您可以使用 在线配置模式 设备树中 PLC 对象的上下文菜单中的命令，以创建隐式应用程序。 CODESYS 自动将应用程序下载到 PLC 并通过应用程序自动初始化所有 I\/O。该应用程序名为 HiddenOnlineConfigModeApp .它显示在 PLC 的设备编辑器中 应用 标签。您可以使用它来操作具有以下功能的 I\/O，就像在正常在线模式下一样： 读取 I\/O 写输出 诊断（在树和状态页面上） 扫描（当前硬件） 交互式在线功能，如果支持（例如，编写异步消息） I\/O 映射中的写入和强制 在在线配置模式下，写入和强制 I\/O 映射 对话框的工作方式与它在真实在线模式下的工作方式不同。 CODESYS 插入后立即将输出写入 I\/O 映射表。没有 准备值 柱子。而是在双击后直接更改初始值 当前值 柱子。 借助简单的在线配置模式测试 I\/O 访问 要求：您已创建一个标准项目，其中包含您已配置 I\/O 映射的设备配置。在程序 POU 中，您对硬件的输入或输出进行读或写访问，以检查它们的接线。在通讯设置中配置与硬件 PLC 的连接。 PLC 正在运行。 在设备树中选择 PLC 对象。 例如， CODESYS Control Win 在设备树中选择设备。 在上下文菜单中，单击 在线配置模式 . CODESYS 连接到控制器，树中的 PLC 对象被赋予绿色背景。 在设备树中，双击 PLC 对象以打开设备编辑器。选择 应用 标签。 点击 刷新列表 按钮。 这 HiddenOnlineConfigModeApp 应用程序显示在 PLC上的应用 窗户。 启动您的程序并检查输入和输出的行为。 高级在线配置模式（参数模式） 如果控制器上已经存在实际应用，并且设备支持“高级在线配置模式”，则作为选项，您也可以选择“参数模式”后 在线配置模式 命令。然后，您可以在控制器上读取实际应用程序的参数，而无需执行标准登录，并且 - 如果缺少编译信息 - 必须再次下载该应用程序。可以看到参数 配置 设备编辑器的选项卡。参数模式防止意外更改控制器上的数据；应用程序保持不变。只有在驱动程序支持的情况下才能写入参数。 设置读取设备参数的参数模式 要求：目标设备上已经有一个或多个应用程序。目标设备支持高级在线配置模式。您已打开包含这些应用程序的项目。您希望无需登录控制器即可查看设备参数。在通讯设置中配置与硬件 PLC 的连接。 PLC 正在运行。 在设备树中选择 PLC 对象。 在上下文菜单中，单击 在线配置模式 . CODESYS 连接到控制器，树中的 PLC 对象被赋予绿色背景。这 选择配置模式 对话框打开，显示 PLC 上的应用程序。 选择所需的应用程序并单击 参数模式 按钮。 CODESYS 检查项目中的应用程序是否与 PLC 上的应用程序相对应。 如果 CODESYS 不报错应用不匹配，然后打开 配置 PLC 设备编辑器的选项卡。 您可以读取设备参数。 " }, 
{ "title" : "配置设备和 I\/O 映射 ", 
"url" : "_cds_configuring_devices_mapping_ios.html", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 配置设备和 I\/O 映射 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "配置设备 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_UUID-d1d98d5b-c218-8b08-a4d5-9eb8af6cbbe3", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 配置设备和 I\/O 映射 \/ 配置设备 ", 
"snippet" : "您可以在相关设备编辑器中配置插入设备树的设备对象。可能性取决于设备描述。这 ” 通用设备编辑器 \" 提供由设备特定选项卡根据需要补充的选项卡。 要求：您已经打开了一个标准项目，其设备树中有一个标准 PLC，并且在其下方插入了一个现场总线设备对象。 在项目的设备树中双击标准 PLC 的设备对象。 这 <设备名称> 编辑器在主窗口中打开 CODESYS 窗户。这 通讯设置 选项卡在前台。更改到其他选项卡以便为控制器进行配置设置。请参阅通用设备编辑器的帮助页面。 双击项目设备树中的现场总线设备对象。 这 <现场总线设备名称> 编辑器在主窗口中打开 CODESYS 窗户。特定选项卡可用，具体取决于设备...", 
"body" : "您可以在相关设备编辑器中配置插入设备树的设备对象。可能性取决于设备描述。这 ” 通用设备编辑器 \" 提供由设备特定选项卡根据需要补充的选项卡。 要求：您已经打开了一个标准项目，其设备树中有一个标准 PLC，并且在其下方插入了一个现场总线设备对象。 在项目的设备树中双击标准 PLC 的设备对象。 这 <设备名称> 编辑器在主窗口中打开 CODESYS 窗户。这 通讯设置 选项卡在前台。更改到其他选项卡以便为控制器进行配置设置。请参阅通用设备编辑器的帮助页面。 双击项目设备树中的现场总线设备对象。 这 <现场总线设备名称> 编辑器在主窗口中打开 CODESYS 窗户。特定选项卡可用，具体取决于设备。有关配置选项，请参见相应设备编辑器的帮助页面。如果 显示通用设备配置视图 选项被选中 工具 → 选项 ， 在里面 设备编辑器 类别，然后另请参阅通用设备编辑器提供的选项卡。 " }, 
{ "title" : "读取 PLC 参数文件进行配置 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_6d2a082e744f3da1c0a8640e00aa0acb", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 配置设备和 I\/O 映射 \/ 读取 PLC 参数文件进行配置 ", 
"snippet" : "如果 PLC 的配置参数已被其他设备更改，例如通过可视化，配置文件 IoConfig.par 在控制器上创建。根据设备，在线模式下设备编辑器的参数对话框中可能有一个按钮，用于将当前参数写入此类文件。为了同时更新项目中更改的参数，您可以在线模式下读取参数文件。 要求：您有一个带设备树的标准项目，其中硬件环境与设备树中的 PLC 和可参数化设备映射。在控制器上有一个文件 IoConfig.par , 其中设备参数先前与当前值一起保存。 添加 读取 PLC 参数文件到配置 命令从界面菜单 设备 中的类别 工具 → 自定义 对话。 在设备树中选择 PLC 设备对象并打开上下文菜单。 点击 读取 PLC...", 
"body" : "如果 PLC 的配置参数已被其他设备更改，例如通过可视化，配置文件 IoConfig.par 在控制器上创建。根据设备，在线模式下设备编辑器的参数对话框中可能有一个按钮，用于将当前参数写入此类文件。为了同时更新项目中更改的参数，您可以在线模式下读取参数文件。 要求：您有一个带设备树的标准项目，其中硬件环境与设备树中的 PLC 和可参数化设备映射。在控制器上有一个文件 IoConfig.par , 其中设备参数先前与当前值一起保存。 添加 读取 PLC 参数文件到配置 命令从界面菜单 设备 中的类别 工具 → 自定义 对话。 在设备树中选择 PLC 设备对象并打开上下文菜单。 点击 读取 PLC 参数文件到配置 . CODESYS 自动建立与控制器的连接并从 par-file 中读取参数。这些在带有设备参数的选项卡上相应更新。 " }, 
{ "title" : "有关 I\/O 映射的一般信息 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_UUID-38bf2ccb-2c3b-2bd8-ca28-36065308260f", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 配置设备和 I\/O 映射 \/ 有关 I\/O 映射的一般信息 ", 
"snippet" : "是否可以将 I\/O 映射配置到项目变量甚至整个功能块取决于设备类型。配置 I\/O 映射意味着将设备的输入和输出通道与项目的变量链接起来。我们也使用“ 映射 “ 为了这。 一般注意以下关于设备输入和输出到变量的映射 CODESYS ： 您没有对映射到输入的变量的写访问权。 您只能将现有变量映射到一个输入。 您可以直接在 I\/O 映射中生成新的全局隐式变量并将它们映射到设备通道。 结构的内存布局由设备指定。 您可以更改 I\/O 映射中的地址和固定值。 对于分配给 I\/O 通道的每个变量 选项卡：<设备名称> I\/O 映射对话框，您可以在应用程序编译期间生成“强制变量”（参见下文）。使用这些变量，例...", 
"body" : "是否可以将 I\/O 映射配置到项目变量甚至整个功能块取决于设备类型。配置 I\/O 映射意味着将设备的输入和输出通道与项目的变量链接起来。我们也使用“ 映射 “ 为了这。 一般注意以下关于设备输入和输出到变量的映射 CODESYS ： 您没有对映射到输入的变量的写访问权。 您只能将现有变量映射到一个输入。 您可以直接在 I\/O 映射中生成新的全局隐式变量并将它们映射到设备通道。 结构的内存布局由设备指定。 您可以更改 I\/O 映射中的地址和固定值。 对于分配给 I\/O 通道的每个变量 选项卡：<设备名称> I\/O 映射对话框，您可以在应用程序编译期间生成“强制变量”（参见下文）。使用这些变量，例如在工厂调试期间，您可以通过可视化\/HMI 在输入或输出上强制设置一个值。 I\/O 映射中的更改可以通过在线更改传输到控制器。 如果使用指向设备输入的指针，则该访问被认为是写访问，例如 pTest := ADR(input); .生成代码时，这会导致编译器警告：“ ...invalid assignment target \"。如果你需要这种构造，你必须先复制输入值 input 到具有写访问权限的变量。 I\/O 地址也可以通过 IEC 代码中的“AT 声明”与变量链接。但是，由于设备配置经常会再次更改，我们建议您仅在设备编辑器中进行分配。 如果您使用 AT 声明，请注意以下事项： AT 声明只能用于局部或全局变量，不能用于功能块的输入或输出变量。 不能为 AT 声明生成 I\/O 的隐式“强制变量”（见下文）。 如果您使用带有结构变量或功能块变量的 AT 声明，所有实例都将访问相同的内存位置。这对应于在诸如“C”之类的经典编程语言中使用“静态变量”。 如果使用指向设备输入的指针，则访问（例如， pTest := ADR(input); ) 适用于写访问。生成代码时，这会导致编译器警告：“ ...invalid assignment target ”。 如果您需要这种构造，则必须首先复制输入值（ input ) 到具有写访问权限的变量。 作为替代方案，您可以使用 AT 声明将变量分配给编程代码中的地址。但是，考虑到设备配置可能发生的变化，我们建议您仅在设备编辑器中进行分配。 您可以将设备的 I\/O 映射配置导出到 csv 文件或从这样的文件中导入。 有关更多信息，请参阅： 将 I\/O 映像导出为 CSV有关更多信息，请参阅： 为强制 I\/O 生成隐式变量" }, 
{ "title" : "将设备输入与现有项目变量链接（“映射”） ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_999010aa744f3da6c0a8640e0038614a", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 配置设备和 I\/O 映射 \/ 将设备输入与现有项目变量链接（“映射”） ", 
"snippet" : "要求：支持 I\/O 映射配置的设备 CODESYS 插入到项目的设备树中。在 I\/O 映射 在设备编辑器中的选项卡中，您将获得设备输入和输出通道的表格显示以及地址和数据类型的规范。 映射“太大”的数据类型 如果大于字节的数据类型的变量映射到字节地址，则该变量的值将被截断为字节大小。用于监控变量值 I\/O 映射 对话框，这意味着，在地址的“根”元素中，将显示项目中当前变量的值。字节的当前单个位值连续显示在其下方的位元素中，但这可能不足以用于整个变量值。 如果 UNION 在映射对话框中由 I\/O 通道表示，则取决于设备是否也可以映射到“根”元素。 例如，在 POU 中，声明一个变量 xBool4...", 
"body" : "要求：支持 I\/O 映射配置的设备 CODESYS 插入到项目的设备树中。在 I\/O 映射 在设备编辑器中的选项卡中，您将获得设备输入和输出通道的表格显示以及地址和数据类型的规范。 映射“太大”的数据类型 如果大于字节的数据类型的变量映射到字节地址，则该变量的值将被截断为字节大小。用于监控变量值 I\/O 映射 对话框，这意味着，在地址的“根”元素中，将显示项目中当前变量的值。字节的当前单个位值连续显示在其下方的位元素中，但这可能不足以用于整个变量值。 如果 UNION 在映射对话框中由 I\/O 通道表示，则取决于设备是否也可以映射到“根”元素。 例如，在 POU 中，声明一个变量 xBool4 类型的 BOOL 您想通过它从应用程序访问目标设备的输入。 要打开设备编辑器，请双击设备树中的设备对象，然后单击 <设备名称> I\/O 映射 标签。 观察 多变的 显示设备输入的列 通道和设备输出 频道，仍然可以按组织排序 节点，取决于设备。我们假设有一个设备输入类型 BYTE .它显示在其下方的各个位地址（位通道） BYTE 节点。 注意：映射结构化变量时，编辑器会阻止您同时输入结构变量（例如： %QB0 ) 和单个结构元素（例如： %QB0.1 和 QB0.2 ）。因此，如果在映射表中有一个带有位通道条目子树的主条目，则适用以下情况： 然后您可以在主条目的行或子元素的行中指定一个变量（位通道)，但不是两者兼而有之。 您现在可以使用合适类型的变量占用整个通道，或者使用合适类型的变量占用其各个位通道地址 BOOL 或者 BIT .首先，双击一个位输入通道 变量 柱子。 将打开一个输入字段。 为了在通道上放置现有变量，您必须输入所需的项目变量和完整路径。按 打开输入助手。例如，选择变量 Application.PLC_PRG.xBool4 宣布于 PLC_PRG . 变量被插入。这 符号显示在 映射 柱子。现在地址被划掉了。这并不意味着该地址不再可用，因为现有变量的值是在另一个内存空间中管理的。但是：为了避免在写入值时出现歧义，您不应使用其他变量占用地址，尤其是在输出的情况下。 注意：对于编译器版本 V3.5 SP11 及更高版本，在映射到现有变量时，变量的初始化值会自动用作默认值。您可以编辑 默认值 仅当您映射到新创建的变量或未指定映射时才使用字段。在旧版本中，用户必须明确指定默认值和初始化值相同。 再次删除变量赋值。点击频道根目录， BYTE 节点。再次使用输入助手选择变量 Application.PLC_PRG.byte_gotodevice . 变量被插入，主通道的所有位地址都被划掉，你不应该额外占用它们。 " }, 
{ "title" : "将设备输入映射到最近创建的项目变量 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_4032bba9628111e8accba0875c639f65", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 配置设备和 I\/O 映射 \/ 将设备输入映射到最近创建的项目变量 ", 
"snippet" : "在下文中，您会将设备输出映射到一个全局隐式变量，您最近为此直接在 I\/O 映射 对话。 这 I\/O 映射 因此，对话框是声明全局变量的另一个地方。 要求：支持 I\/O 映射配置的设备 CODESYS 插入到项目的设备树中。在 I\/O 映射 在设备编辑器中的选项卡中，您将看到设备输入和输出通道的表格显示以及地址和数据类型的规范。 要打开设备编辑器，请双击设备树中的设备对象，然后单击 <设备名称> I\/O 映射 标签。 单击映射表中的通道条目 多变的 列以打开输入字段。 指定一个简单的名称（不带“ . \") 用于新变量（例如： myBool ）。 CODESYS 将变量创建为项目中的隐式全局变量，...", 
"body" : "在下文中，您会将设备输出映射到一个全局隐式变量，您最近为此直接在 I\/O 映射 对话。 这 I\/O 映射 因此，对话框是声明全局变量的另一个地方。 要求：支持 I\/O 映射配置的设备 CODESYS 插入到项目的设备树中。在 I\/O 映射 在设备编辑器中的选项卡中，您将看到设备输入和输出通道的表格显示以及地址和数据类型的规范。 要打开设备编辑器，请双击设备树中的设备对象，然后单击 <设备名称> I\/O 映射 标签。 单击映射表中的通道条目 多变的 列以打开输入字段。 指定一个简单的名称（不带“ . \") 用于新变量（例如： myBool ）。 CODESYS 将变量创建为项目中的隐式全局变量，并将其直接分配给通道地址。因此，在这种情况下，地址不会像映射到现有变量的情况那样出现 . " }, 
{ "title" : "将设备与功能块实例链接 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_4bb85fcf744f3da7c0a8640e01facbb6", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 配置设备和 I\/O 映射 \/ 将设备与功能块实例链接 ", 
"snippet" : "如果设备支持，您可以将整个功能块映射到输入或输出通道。例如，这使您可以计算信号变化的频率或缩放通道值以进行维护。 在这里，您将设备输出通道映射到功能块。在此示例中，模块缩放通道输出值。 要求：项目中链接了具有支持 FB 映射的数字输出的设备。有一个功能块 Scale_Output_Int 通过以下实现。功能块本身和处理通道输出的输出参数之前的属性很重要。 {attribute 'io_function_block'} FUNCTION_BLOCK Scale_Output_Int VAR_INPUT iInput : INT; iNumerator : INT; iDenominator : ...", 
"body" : "如果设备支持，您可以将整个功能块映射到输入或输出通道。例如，这使您可以计算信号变化的频率或缩放通道值以进行维护。 在这里，您将设备输出通道映射到功能块。在此示例中，模块缩放通道输出值。 要求：项目中链接了具有支持 FB 映射的数字输出的设备。有一个功能块 Scale_Output_Int 通过以下实现。功能块本身和处理通道输出的输出参数之前的属性很重要。 {attribute 'io_function_block'}\nFUNCTION_BLOCK Scale_Output_Int\nVAR_INPUT\n iInput : INT;\n iNumerator : INT;\n iDenominator : INT :=1;\n iOffset : INT := 0;\nEND_VAR\nVAR_OUTPUT\n {attribute 'io_function_block_mapping'}\n iOutput : INT;\nEND_VAR\nVAR\nEND_VAR\nIF iDenominator <> 0 THEN\n iOutput := TO_INT(TO_DINT(iInput) * TO_DINT(iNumerator) \/ TO_DINT(iDenominator)) + iOffset; 打开 I\/O 映射 设备模块的选项卡。双击应连接到功能块的输出。点击 为 IO 通道添加 FB 按钮。 这 选择功能块 对话框打开。在左侧，您至少可以看到功能块 Scale_Output_int 以下 应用 节点。项目中链接的包含相应功能块的库也将显示以供选择。 选择 POU myScaleOutputInt . 点击后 行 , 功能块参数的路径 iOutput 在里面 多变的 在映射对话框中输入。该路径包含应用程序名称、设备通道名称和选定的 FB 输出（例如： App1.Out_4_Int_myScale_Output_Int_1.iOutput ）。 选择频道并点击 转到实例 按钮。 焦点切换到 <设备名称> IEC 对象 选项卡和为新 IEC 对象创建的条目 Out_4_Int_myScale_Output_Int_1 .在此在线模式的视图中，您可以看到参数的当前值 iOutput 对于频道 Out_4_Int 由 FB 缩放。您还可以像在其他监视视图中一样写入和强制该值。 有关更多信息，请参阅： 选项卡：'<设备名称> IEC 对象 和 io_function_block, io_function_block_mapping" }, 
{ "title" : "更改和修复 I\/O 映射中的地址值 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_0f670058744f3da8c0a8640e01f6b4b2", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 配置设备和 I\/O 映射 \/ 更改和修复 I\/O 映射中的地址值 ", 
"snippet" : "您可以更改整个通道的地址值（但不能更改通道的单个子元素！） <设备名称> I\/O 映射 标签。这使您可以根据指定的机器配置调整寻址并保留地址值，即使模块布局发生变化。默认情况下，布局的更改会导致地址值的自动调整。 要求：您的项目具有 I\/O 映射。请参阅上面帮助页面的相应部分。 要打开设备编辑器，请双击设备树中的设备对象，然后单击 <设备名称> I\/O 映射 标签。 单击映射表中的通道条目 地址 列以打开输入字段。这仅适用于通道的“根”地址，而不适用于其特定的子元素。 因此，更改表中通道的顶部地址条目，例如从 QB0 到 QB1 .退出输入字段。 地址值已更改。这 符号显示在地址前。表示地址是...", 
"body" : "您可以更改整个通道的地址值（但不能更改通道的单个子元素！） <设备名称> I\/O 映射 标签。这使您可以根据指定的机器配置调整寻址并保留地址值，即使模块布局发生变化。默认情况下，布局的更改会导致地址值的自动调整。 要求：您的项目具有 I\/O 映射。请参阅上面帮助页面的相应部分。 要打开设备编辑器，请双击设备树中的设备对象，然后单击 <设备名称> I\/O 映射 标签。 单击映射表中的通道条目 地址 列以打开输入字段。这仅适用于通道的“根”地址，而不适用于其特定的子元素。 因此，更改表中通道的顶部地址条目，例如从 QB0 到 QB1 .退出输入字段。 地址值已更改。这 符号显示在地址前。表示地址是固定的。通道子元素的地址也相应改变。如果您现在在设备树中使用输入\/输出通道更改设备对象在其他设备对象中的位置， CODESYS 不会像没有修复的情况那样使这些地址适应新的顺序。 要撤消手动更改或修复，请再次打开地址值的输入字段，删除地址条目并按 Enter 键。 CODESYS 将相关地址和后续地址重置为更改前的值并删除 象征。 有关更多信息，请参阅： 地址" }, 
{ "title" : "I\/O 变量更新的配置 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_1bb5439b6f5b4e88c0a8640e00b2518b", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 配置设备和 I\/O 映射 \/ I\/O 变量更新的配置 ", 
"snippet" : "根据您在项目中连接的设备， CODESYS 以不同方式更新应用于其输入和输出的变量。您可以在 I\/O 映射 对话。...", 
"body" : "根据您在项目中连接的设备， CODESYS 以不同方式更新应用于其输入和输出的变量。您可以在 I\/O 映射 对话。 " }, 
{ "title" : "在在线模式下监控 I\/O 映射中的变量 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_e1f8bef86f5b4e89c0a8640e00daea27", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 配置设备和 I\/O 映射 \/ 在在线模式下监控 I\/O 映射中的变量 ", 
"snippet" : "要求：您已使用包含 I\/O 映射的设备配置正确编译了应用程序。相关的硬件和总线系统正在运行。您已通过 在线 → 登录 命令并已加载并启动应用程序。 打开 I\/O 映射 设备编辑器中 PLC 的选项卡。要打开编辑器，请双击设备树中的设备对象。 映射表现在还包含 当前值 和 新价值 列。 如果结构变量映射到地址的“根”元素 1 , CODESYS 在线模式下此行不显示值。例如，如果一个 DWORD 变量映射到地址，但是，在“根”行和它下面的缩进位通道行中都监视相应的值。 原则上，如果值由多个子元素组成，“根”行中的字段始终为空。 1 \"root\" = 映射对话框中此地址的顶部元素 为列中的条目输入...", 
"body" : "要求：您已使用包含 I\/O 映射的设备配置正确编译了应用程序。相关的硬件和总线系统正在运行。您已通过 在线 → 登录 命令并已加载并启动应用程序。 打开 I\/O 映射 设备编辑器中 PLC 的选项卡。要打开编辑器，请双击设备树中的设备对象。 映射表现在还包含 当前值 和 新价值 列。 如果结构变量映射到地址的“根”元素 1 , CODESYS 在线模式下此行不显示值。例如，如果一个 DWORD 变量映射到地址，但是，在“根”行和它下面的缩进位通道行中都监视相应的值。 原则上，如果值由多个子元素组成，“根”行中的字段始终为空。 1 \"root\" = 映射对话框中此地址的顶部元素 为列中的条目输入某个变量值 新价值 并按下 F7 强迫或 Ctrl + F7 写入值。 与在声明编辑器或监视列表中监视的情况一样，强制变量值显示在列中 当前值 带有前缀的红色 F 符号或书面值。 PLC 代码不使用的输入和输出在在线模式下不会被 PLC 读取，因此显示的值可能不正确。这 当前值 相关的变量以灰色背景显示。 " }, 
{ "title" : "为强制 I\/O 生成隐式变量 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_3a1310c2796cb504c0a8640e01d0e08f", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 配置设备和 I\/O 映射 \/ 为强制 I\/O 生成隐式变量 ", 
"snippet" : "在设备或机器调试期间，可能需要“强制”应用在输入和输出上的值。如果设备支持这一点，您可以为此目的生成特殊的“强制变量”并使用它们，例如在 HMI 可视化中。 要求：设备支持该功能。您有一个项目，其中为设备配置了 I\/O 映射并包含程序对象 PLC_PRG . 打开设备编辑器， PLC 设置 选项卡，双击设备树中的设备对象。 激活选项 为 IO 映射生成力变量 . 按 F11 编译应用程序。 根据以下语法为每个 I\/O 通道创建两个变量，其中通道名称中的空格被下划线替换： <device name>_<channel name>_<IECaddress>_force 类型的 BOOL 用于强制的...", 
"body" : "在设备或机器调试期间，可能需要“强制”应用在输入和输出上的值。如果设备支持这一点，您可以为此目的生成特殊的“强制变量”并使用它们，例如在 HMI 可视化中。 要求：设备支持该功能。您有一个项目，其中为设备配置了 I\/O 映射并包含程序对象 PLC_PRG . 打开设备编辑器， PLC 设置 选项卡，双击设备树中的设备对象。 激活选项 为 IO 映射生成力变量 . 按 F11 编译应用程序。 根据以下语法为每个 I\/O 通道创建两个变量，其中通道名称中的空格被下划线替换： <device name>_<channel name>_<IECaddress>_force 类型的 BOOL 用于强制的激活和停用 <device name>_<channel name>_<IECaddress>_value 用于定义要在通道上强制的值的通道的数据类型 这些变量在类别中的输入助手中可用 变量 \/ IoConfig_Globals_Force_Variables。 您可以在 CODESYS 在编程对象、可视化、符号配置等中。 打开功能块 PLC_PRG ，在执行部分设置焦点并按 F2 . 输入助手打开。变量在类别中可用 变量 \/ IoConfig_Globals_Force_Variables 如上所述。 “强制变量”输入处的上升沿激活使用“值变量”给定的值强制相应的输入或输出。下降沿取消强制。通过将“Force”变量重置为停用 FALSE 是能够强制一个新值的要求。 请注意以下限制。 通过隐式力变量强制仅适用于映射到 I\/O 映射 设备的现有或最近创建的变量。 对于未使用的输入和输出或通过应用程序中的 AT 声明映射到变量的输入和输出，无法通过隐式强制变量进行强制。 您想通过该机制强制使用的 I\/O 通道必须由 CODESYS 在至少一项任务中。 CODESYS 用红色 Force 符号标识监控中的强制输入，而不是强制输入\/输出。强制值仅由 I\/O 驱动程序隐式用于写入设备。 有关更多信息，请参阅： 变量的强制和写入" }, 
{ "title" : "在一个对话框中为多个设备提供 I\/O 映射 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_index_21", 
"breadcrumbs" : "CODESYS Essentials \/ 配置 I\/O 链接 \/ 配置设备和 I\/O 映射 \/ 在一个对话框中为多个设备提供 I\/O 映射 ", 
"snippet" : "有一个表格显示设备的 I\/O 映射以及设备树中插入在其下方的所有子元素的 I\/O 映射。您可以在此处以与在相应设备编辑器的各个映射表中完全相同的方式编辑 I\/O 映射。 要求：在项目的设备树中插入了多个 PLC，每个 PLC 都启用 I\/O 映射配置。 选择设备树的根节点并单击 编辑 I\/O 映射 在上下文菜单中。 这 编辑 I\/O 映射 对话框打开，其中插入项目的所有设备的 I\/O 映射配置显示在表格中。您可以使用与在 I\/O 映射 相关设备编辑器的对话框。 现在选择设备树中的一个控制对象并选择 编辑 I\/O 映射 命令再次在上下文菜单中。 这 编辑 I\/O 映射 对话框现在仅显示在选定对象...", 
"body" : "有一个表格显示设备的 I\/O 映射以及设备树中插入在其下方的所有子元素的 I\/O 映射。您可以在此处以与在相应设备编辑器的各个映射表中完全相同的方式编辑 I\/O 映射。 要求：在项目的设备树中插入了多个 PLC，每个 PLC 都启用 I\/O 映射配置。 选择设备树的根节点并单击 编辑 I\/O 映射 在上下文菜单中。 这 编辑 I\/O 映射 对话框打开，其中插入项目的所有设备的 I\/O 映射配置显示在表格中。您可以使用与在 I\/O 映射 相关设备编辑器的对话框。 现在选择设备树中的一个控制对象并选择 编辑 I\/O 映射 命令再次在上下文菜单中。 这 编辑 I\/O 映射 对话框现在仅显示在选定对象中和下方找到的 I\/O 映射配置的 I\/O 表。 设置一个想要的 筛选 在表格上方的栏中或在 搜索变量 字段以查看此变量在映射中的使用。 在此窗口中的工作方法与在此窗口中描述的方法相同 <设备名称> I\/O 映射 标签。 " }, 
{ "title" : "程序申请 ", 
"url" : "_cds_struct_application_programming.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 ", 
"snippet" : "要创建可以在控制器上运行的应用程序，您需要使用声明和实现代码（源代码）填充 POU，将控制器的 I\/O 链接到应用程序变量并配置任务分配。检查并排除故障后， CODESYS 编译器然后是可以加载到控制器上的应用程序代码。 应用程序 POU 的编程由编程语言编辑器和其他功能支持，例如 文字清单 ， 图片集 ， 警报配置 ， Pragmas 、重构和来自的即用型 POU CODESYS Development System 或图书馆。 有用于语法检查和代码分析、建立数据持久性和加密加载到控制器上的应用程序代码的方法。...", 
"body" : "要创建可以在控制器上运行的应用程序，您需要使用声明和实现代码（源代码）填充 POU，将控制器的 I\/O 链接到应用程序变量并配置任务分配。检查并排除故障后， CODESYS 编译器然后是可以加载到控制器上的应用程序代码。 应用程序 POU 的编程由编程语言编辑器和其他功能支持，例如 文字清单 ， 图片集 ， 警报配置 ， Pragmas 、重构和来自的即用型 POU CODESYS Development System 或图书馆。 有用于语法检查和代码分析、建立数据持久性和加密加载到控制器上的应用程序代码的方法。 " }, 
{ "title" : "分配标识符 ", 
"url" : "_cds_naming_identifiers.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 分配标识符 ", 
"snippet" : "标识符是变量和编程对象的名称，例如程序、功能块、方法等，以及应用程序和项目的其他对象的名称。分配标识符时必须遵循一些规则。此外，还有一些建议可以使标识符统一且有意义。 您在变量声明中分配变量的标识符。您可以在编程对象的声明部分更改这些标识符。添加相应对象时，在对话框中为编程对象和其他对象分配标识符。您可以在对象的属性对话框中更改应用程序或项目的现有对象的标识符。但是，您不能更改每个应用程序或每个项目只能存在一次的对象的标识符，例如标识符 图书馆管理员 和 图像池 . 有关更多信息，请参阅： 标识符名称...", 
"body" : "标识符是变量和编程对象的名称，例如程序、功能块、方法等，以及应用程序和项目的其他对象的名称。分配标识符时必须遵循一些规则。此外，还有一些建议可以使标识符统一且有意义。 您在变量声明中分配变量的标识符。您可以在编程对象的声明部分更改这些标识符。添加相应对象时，在对话框中为编程对象和其他对象分配标识符。您可以在对象的属性对话框中更改应用程序或项目的现有对象的标识符。但是，您不能更改每个应用程序或每个项目只能存在一次的对象的标识符，例如标识符 图书馆管理员 和 图像池 . 有关更多信息，请参阅： 标识符名称" }, 
{ "title" : "UTF-8 编码 ", 
"url" : "_cds_utf8_encoding.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ UTF-8 编码 ", 
"snippet" : "基本 应用在 CODESYS 可以处理各种各样的字符，例如，以各种语言输出错误消息。或者以用户选择的语言显示可视化，该语言接受各种语言、字符或符号的用户输入。 如果不需要全面的字符集，或者不应该更改项目，则仍可以使用以 Latin-1 格式编码的字符串。 字符集表 字符集 代码页码 描述 字符编码 ASCII 20127 128 个字符 适用于英文文本 7 位编码字符 DOS-Latin-1 819, 850 符合 ISO 8859 适用于 Windows 命令行窗口中的西欧语言 8位编码字符 拉丁语-1 28591 符合 ISO-8859-1 通常用于带有 äöüß 但没有 € 或例如没有特...", 
"body" : "基本 应用在 CODESYS 可以处理各种各样的字符，例如，以各种语言输出错误消息。或者以用户选择的语言显示可视化，该语言接受各种语言、字符或符号的用户输入。 如果不需要全面的字符集，或者不应该更改项目，则仍可以使用以 Latin-1 格式编码的字符串。 字符集表 字符集 代码页码 描述 字符编码 ASCII 20127 128 个字符 适用于英文文本 7 位编码字符 DOS-Latin-1 819, 850 符合 ISO 8859 适用于 Windows 命令行窗口中的西欧语言 8位编码字符 拉丁语-1 28591 符合 ISO-8859-1 通常用于带有 äöüß 但没有 € 或例如没有特殊法语字符的 HTML 页面 8位编码字符 Windows 1252 编码 1252 西欧国家的默认 Windows 字符集 Windows 内部使用 UTF-16 格式 包含 ISO 8859-1 和 ISO 8859-15 中的所有字符，但部分编码不同 8位编码字符 统一码 适用于所有可能语言的通用字符集，包括历史语言、盲文、音乐或表情符号 可显示超过 100,000 个字符。 每个字符都有一个数字代码。 与 ASCII 相比，字符的代码点分配和字符的编码是分开的。 数字代码 < 128 与 ASCII 兼容 < 256 的数字代码与 ISO 8859-1 兼容 有关更多信息，请参阅： https:\/\/home.unicode.org\/ 统一码 14.0 144,697 个字符 UTF-16 1200 特殊 Unicode 在某些操作系统（Windows、OS X）和编程语言（Java、.NET）中用于内部字符表示 应该注意的是，不同的计算机体系结构对 4 字节字符进行不同的编码。 UTF-16LE 的小端字节顺序 16 位编码字符 字符被编码为 2 个字节或 4 个字节。 UTF-8 65001 Unicode字符的面向字节的编码格式 最广泛的 用于 GNU\/Linux 和 Unix 操作系统，以及各种 Internet 服务（电子邮件、网络、浏览器） 与前 128 个字符 (0–127) 中的 ASCII 字符兼容 每个字符的 8 位字元组 字符以 1 到 4 个字节的不同长度编码。 " }, 
{ "title" : "UTF-8 输入 CODESYS ", 
"url" : "_cds_utf8_encoding.html#UUID-7e4361ae-d07f-2866-46cf-cabba3de11bf_section-idm4579545478443232896837520979", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ UTF-8 编码 \/ UTF-8 输入 CODESYS ", 
"snippet" : "UTF-8 编码是字符集最全面的编码。因此，建议您为新项目以及现有项目启用 UTF-8 编码以在新环境中使用。 项目范围内的编码 CODESYS 数据类型 编译选项：STRING 的 UTF8 编码 项目范围内使用哪种编码？ STRING 启用 UTF-8 已禁用 Windows 1252 编码（默认 Windows 编码） 拉丁语-1 WSTRING 启用 UTF-16 已禁用 UTF-16 在 CODESYS ， 这 STRING 数据类型可以用 Latin-1 或 UTF-8 格式编码。这 WSTRING 数据类型始终将其字符编码为 UTF-16 中的 Unicode。...", 
"body" : "UTF-8 编码是字符集最全面的编码。因此，建议您为新项目以及现有项目启用 UTF-8 编码以在新环境中使用。 项目范围内的编码 CODESYS 数据类型 编译选项：STRING 的 UTF8 编码 项目范围内使用哪种编码？ STRING 启用 UTF-8 已禁用 Windows 1252 编码（默认 Windows 编码） 拉丁语-1 WSTRING 启用 UTF-16 已禁用 UTF-16 在 CODESYS ， 这 STRING 数据类型可以用 Latin-1 或 UTF-8 格式编码。这 WSTRING 数据类型始终将其字符编码为 UTF-16 中的 Unicode。 " }, 
{ "title" : "以 UTF-8 格式编码单个字符串文字 ", 
"url" : "_cds_utf8_encoding.html#UUID-7e4361ae-d07f-2866-46cf-cabba3de11bf_section-idm4663754559772832898653408592", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ UTF-8 编码 \/ UTF-8 输入 CODESYS \/ 以 UTF-8 格式编码单个字符串文字 ", 
"snippet" : "即使项目范围的编码格式设置为 Latin-1，您也可以将单个文字编码为 UTF-8 格式。为此，请添加 UTF8# 文字的类型前缀。 {attribute 'monitoring_encoding' := 'UTF-8'} strVarUtf8: STRING := UTF8#'你好,世界!ÜüÄäÖö'; 有关详细信息，请参阅： 常量： UTF8#字符串; Pragma 属性： monitoring_encoding...", 
"body" : "即使项目范围的编码格式设置为 Latin-1，您也可以将单个文字编码为 UTF-8 格式。为此，请添加 UTF8# 文字的类型前缀。 {attribute 'monitoring_encoding' := 'UTF-8'}\nstrVarUtf8: STRING := UTF8#'你好,世界!ÜüÄäÖö'; 有关详细信息，请参阅： 常量： UTF8#字符串; Pragma 属性： monitoring_encoding" }, 
{ "title" : "UTF-8 编码的字符串转换 ", 
"url" : "_cds_utf8_encoding.html#UUID-7e4361ae-d07f-2866-46cf-cabba3de11bf_section-idm4525865800604832898698002139", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ UTF-8 编码 \/ UTF-8 输入 CODESYS \/ UTF-8 编码的字符串转换 ", 
"snippet" : "如果您在项目范围内启用了 UTF-8 编码，则可以照常使用字符串转换功能。...", 
"body" : "如果您在项目范围内启用了 UTF-8 编码，则可以照常使用字符串转换功能。 " }, 
{ "title" : "字符串操作 ", 
"url" : "_cds_utf8_encoding.html#UUID-7e4361ae-d07f-2866-46cf-cabba3de11bf_section-idm4524271435323232898709825848", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ UTF-8 编码 \/ UTF-8 输入 CODESYS \/ 字符串操作 ", 
"snippet" : "使用库函数来操作您的字符串。 如果 STRING 变量应该被操纵，那么对 ASCII 格式变量的索引访问通常会导致所需的结果。最好不要使用这种结构。这不仅仅是一种糟糕的编程风格。更糟糕的是，使用 UTF-8 编码，索引访问会导致不必要的字符串操作。 UTF-8 编码仅用于项目范围的配置 如果项目范围的编译选项使用 UTF-8 编码 字符串的 UTF8 编码 已启用。然后，库函数和附加组件也将根据此设置进行定向。 如果您使用单个 UTF-8 编码的字符串，那么您必须确保在使用它们的任何地方都能正确解释它们。例如，如果未选择该设置，则 OPC 服务器中的字符串变量将在传输到客户端之前转换为 UTF...", 
"body" : "使用库函数来操作您的字符串。 如果 STRING 变量应该被操纵，那么对 ASCII 格式变量的索引访问通常会导致所需的结果。最好不要使用这种结构。这不仅仅是一种糟糕的编程风格。更糟糕的是，使用 UTF-8 编码，索引访问会导致不必要的字符串操作。 UTF-8 编码仅用于项目范围的配置 如果项目范围的编译选项使用 UTF-8 编码 字符串的 UTF8 编码 已启用。然后，库函数和附加组件也将根据此设置进行定向。 如果您使用单个 UTF-8 编码的字符串，那么您必须确保在使用它们的任何地方都能正确解释它们。例如，如果未选择该设置，则 OPC 服务器中的字符串变量将在传输到客户端之前转换为 UTF-8。值如 UTF8#'äöü' 那么就会被误解。在可视化中输出字符串时可能会出现类似的问题。 " }, 
{ "title" : "变量声明 ", 
"url" : "_cds_f_declaring_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 ", 
"snippet" : "变量声明：在哪里以及如何？ 你可以在以下位置声明变量： 申报意向书的一部分 这个 声明变量 对话框可以帮助你解决这个问题。 变量列表（GVL 编辑器、NVL 编辑器） I\/O 设备对象的 I\/O 映射配置 有关更多信息，请参阅： 配置设备和 I\/O 映射有关更多信息，请参阅： 变量声明的快捷方式...", 
"body" : "变量声明：在哪里以及如何？ 你可以在以下位置声明变量： 申报意向书的一部分 这个 声明变量 对话框可以帮助你解决这个问题。 变量列表（GVL 编辑器、NVL 编辑器） I\/O 设备对象的 I\/O 映射配置 有关更多信息，请参阅： 配置设备和 I\/O 映射有关更多信息，请参阅： 变量声明的快捷方式" }, 
{ "title" : "语法 ", 
"url" : "_cds_f_declaring_variables.html#UUID-ef4aa32b-23c7-a688-0472-86ee8eb95613_section-idm2347730964863", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 语法 ", 
"snippet" : "<pragma> <scope> <type qualifier>     <identifier> AT <address> : <data type> := <initial value> ; END_VAR <pragma> 重复可选（从不、一次或多次） Pragma 编译指示是一种编译器语句（例如，用于实现内存要求或运行时改进等优化）。 使用指令编译指示<scope> 必填项 范围 VAR VAR_CONFIG 注意：如果在函数块中声明了地址信息不完整的变量（例如， AT %I* )，然后是变量声明中的变量 VAR_CONFIG 必须完全申报。只有完成此操作后，您才能在本地实例中访问这...", 
"body" : "<pragma> <scope> <type qualifier>     <identifier> AT <address> : <data type> := <initial value> ; END_VAR <pragma> 重复可选（从不、一次或多次） Pragma 编译指示是一种编译器语句（例如，用于实现内存要求或运行时改进等优化）。 使用指令编译指示<scope> 必填项 范围 VAR VAR_CONFIG 注意：如果在函数块中声明了地址信息不完整的变量（例如， AT %I* )，然后是变量声明中的变量 VAR_CONFIG 必须完全申报。只有完成此操作后，您才能在本地实例中访问这些变量。 VAR_EXTERNAL VAR_GLOBAL VAR_INPUT VAR_INST VAR_IN_OUT VAR_OUTPUT VAR_STAT VAR_TEMP VARVAR_CONFIGVAR_EXTERNALVAR_GLOBALGVLVAR_INPUTVAR_INSTVAR_IN_OUTVAR_OUTPUTVAR_STATVAR_TEMP<type qualifier> 可选 类型限定符 CONSTANT RETAIN PERSISTENT CONSTANTRETAINPERSISTENT<identifier> 必填项 标识符，变量名 注意：分配标识符时，必须毫无例外地遵守 “标识符指定” 一章中列出的规则。此外，您还将找到统一命名的建议。 标识符名称AT %<address> 可选 地址组成如下： <内存区域> <可选大小前缀> <内存位置> 存储区域细分为输入存储区域、输出存储区域或标志存储区域 ( I ， Q 或者 M ）。 示例 AT %I* \/\/ Incomplete address AT %I7.5 AT %IW0 AT %QX7.5 AT %MD48 配置设备和 I\/O 映射AT声明地址<data type> 必填项 数据类型 基本数据类型 自定义数据类型 功能块 数据类型DUT功能块<initial value> 可选 初始值；初始化为文字、变量或表达式 常量和文字 ST 表达式示例 全局变量列表 GVL {attribute 'qualified_only'}\n{attribute 'linkalways'}\nVAR_GLOBAL CONSTANT\n g_ciMAX_A : INT := 100;\n g_ciSPECIAL : INT := g_ciMAX_A - 10;\nEND_VAR 配置变量 GVL_CONFIG {attribute 'qualified_only'}\nVAR_CONFIG\n \/\/ Generated instance path of variable at incomplete address\n PLC_PRG.fbDoItNow.XLOCINPUT AT %I*: BOOL := TRUE;\nEND_VAR 功能块 FB_DoIt METHOD METH_Last : INT\nVAR_INPUT\n iVar : INT;\nEND_VAR\nVAR_INST\n iLast : INT := 0;\nEND_VAR\n\nMETH_Last := iLast;\niLast := iVar;\n\nFUNCTION_BLOCK FB_DoIt\nVAR_INPUT\n wInput AT %IW0 : WORD; (* Input variable *)\nEND_VAR\nVAR_OUTPUT\n wOutput AT %QW0 : WORD; (* Output variable *)\nEND_VAR\nVAR_IN_OUT\n aData_A : ARRAY[0..1] OF DATA_A; \/\/ Formal variable\nEND_VAR\nVAR_EXTERNAL\n GVL.g_ciMAX_A : INT; \/\/ Declared in object GVL\nEND_VAR\nVAR_STAT\n iNumberFBCalls : INT;\nEND_VAR\nVAR\n iCounter: INT;\n xLocInput AT %I* : BOOL := TRUE; \/\/ VAR_CONFIG\nEND_VAR\n\niNumberFBCalls := iNumberFBCalls + 1; IEC 计划 PLC_PRG PROGRAM PLC_PRG\nVAR\n iLoop: INT;\n iTest: INT;\n fbDoItNow : FB_DoIt;\n iTest_200: INT;\n aData_Now : ARRAY[0..1] OF DATA_A := [(iA_1 := 1, iA_2 := 10, dwA_3 := 16#00FF),(iA_1 := 2, iA_2 := 20, dwA_3 := 16#FF00)];\nEND_VAR\n\niTest := GVL.g_ciMAX_A;\niTest_200 := 2 * GVL.g_ciMAX_A;\nfbDoItNow(aData_A := aData_Now);\nFOR iLoop := 0 TO GVL.g_ciSPECIAL DO\n ;\nEND_FOR " }, 
{ "title" : "变量初始化 ", 
"url" : "_cds_variables_initialization.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 变量初始化 ", 
"snippet" : "所有声明的标准初始化值为 0 。在声明部分，您还可以为每个变量和每种数据类型指定用户定义的初始化值。 用户定义的初始化从赋值运算符开始 := 并由编程语言 ST（结构化文本）的任何有效表达式组成。因此，您可以借助常量、其他变量或函数来定义初始化值。如果使用变量，则还必须对其进行初始化。 默认初始化值 数据类型 初始化 任何数字数据类型 0 每一个指针 0 BOOL FALSE ARRAY OF 每个元素的默认初始化值 结构 如果尚未为声明中的各个元素定义显式值，则该数据类型的默认值是初始化值。 例子 VAR var1:INT := 12; \/\/initialization value 12 x...", 
"body" : "所有声明的标准初始化值为 0 。在声明部分，您还可以为每个变量和每种数据类型指定用户定义的初始化值。 用户定义的初始化从赋值运算符开始 := 并由编程语言 ST（结构化文本）的任何有效表达式组成。因此，您可以借助常量、其他变量或函数来定义初始化值。如果使用变量，则还必须对其进行初始化。 默认初始化值 数据类型 初始化 任何数字数据类型 0 每一个指针 0 BOOL FALSE ARRAY OF 每个元素的默认初始化值 结构 如果尚未为声明中的各个元素定义显式值，则该数据类型的默认值是初始化值。 例子 VAR\n var1:INT := 12; \/\/initialization value 12\n x : INT := 13 + 8; \/\/initalization value defined by an expression of constants\n y : INT := x + fun(4); \/\/initialization value defined by an expression,\n \/\/that contains a function call; notice the order!\n z : POINTER TO INT := ADR(y); \/\/not described in the standard IEC61131-3:\n \/\/ initialization value defined by an adress function;\n \/\/ Notice: In this case the pointer will not be initialized\n \/\/ during an Online Change *)\nEND_VAR 关于初始化顺序的注意事项 首先是常量 从编译器版本 3.5.3.40 开始，函数块中的变量按以下顺序初始化：首先，所有常量按照其声明顺序进行初始化，然后所有其他变量按照其声明顺序进行初始化。 局部变量之前的全局变量 在编译器版本 3.3.2.0 及更高版本中，全局变量列表中的变量始终在 POU 的局部变量之前初始化。 有关更多信息，请参阅： 结构变量的声明和初始化 和 pragma global_init_slot。 " }, 
{ "title" : "使用声明编辑器 ", 
"url" : "_cds_declaration_editor_basics.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 使用声明编辑器 ", 
"snippet" : "声明编辑器用于在变量列表和 POU 中声明变量。 声明编辑器中提供了两个视图。 : 表格视图 : 文本视图 在 工具 → 选项 → 声明编辑器 对话框中，您可以设置是只有文本视图还是只有表格视图可用。或者您是否可以使用编辑器视图右边缘的按钮在两个视图之间切换 如果声明编辑器与编程语言编辑器一起使用，它将作为声明部分显示在 POU 窗口的顶部。...", 
"body" : "声明编辑器用于在变量列表和 POU 中声明变量。 声明编辑器中提供了两个视图。 : 表格视图 : 文本视图 在 工具 → 选项 → 声明编辑器 对话框中，您可以设置是只有文本视图还是只有表格视图可用。或者您是否可以使用编辑器视图右边缘的按钮在两个视图之间切换 如果声明编辑器与编程语言编辑器一起使用，它将作为声明部分显示在 POU 窗口的顶部。 " }, 
{ "title" : "在表格声明编辑器中声明 ", 
"url" : "_cds_declaration_editor_basics.html#UUID-c2687aff-7cd6-bd33-2c3c-16ea3266af11_id_c44c3e624d92f81c0a8640e01901bfe_id_5e92db7bc6203aeec0a8640e00c25a63", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 使用声明编辑器 \/ 在表格声明编辑器中声明 ", 
"snippet" : "在表格声明编辑器中，您可以将变量声明添加到包含以下列的表中： 范围 ， 姓名 ， 地址 ， 数据类型 ， 初始化 ， 评论 ，以及 属性 （pragmas）。 表格视图不需要详细的语法知识。 要求：项目的编程对象（POU 或 GVL）已打开。表格声明编辑器是重点 点击 声明标题中的按钮或单击 插入 在上下文菜单中。 插入变量声明的新行，并打开变量名称的输入字段。 指定有效的变量名。 根据需要双击打开申报行的其他字段，然后从列表框中选择所需的规格，或者借助打开的对话框。 有关更多信息，请参阅： 声明变量...", 
"body" : "在表格声明编辑器中，您可以将变量声明添加到包含以下列的表中： 范围 ， 姓名 ， 地址 ， 数据类型 ， 初始化 ， 评论 ，以及 属性 （pragmas）。 表格视图不需要详细的语法知识。 要求：项目的编程对象（POU 或 GVL）已打开。表格声明编辑器是重点 点击 声明标题中的按钮或单击 插入 在上下文菜单中。 插入变量声明的新行，并打开变量名称的输入字段。 指定有效的变量名。 根据需要双击打开申报行的其他字段，然后从列表框中选择所需的规格，或者借助打开的对话框。 有关更多信息，请参阅： 声明变量" }, 
{ "title" : "在文本声明编辑器中声明 ", 
"url" : "_cds_declaration_editor_basics.html#UUID-c2687aff-7cd6-bd33-2c3c-16ea3266af11_id_c44c3e624d92f81c0a8640e01901bfe_id_e87b1f3952a211e4ac52fce4405945f5", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 使用声明编辑器 \/ 在文本声明编辑器中声明 ", 
"snippet" : "文本编辑器的行为和外观使用中的设置进行配置 工具 → 选项 → 文本编辑器 。这些设置涉及颜色、行号、制表符宽度、缩进等。通常的 Windows 功能可用，必要时还有 IntelliMouse 功能 如果您已打开 POU、GVL 或 NVL 并将焦点设置为文本声明编辑器，则指定变量声明。注意语法。 F2 获取支持，并使用输入助手选择数据类型或关键字。 你可以通过使用作用域或变量类型的快捷方式来避免打字。 有关更多信息，请参阅： 变量声明的快捷方式...", 
"body" : "文本编辑器的行为和外观使用中的设置进行配置 工具 → 选项 → 文本编辑器 。这些设置涉及颜色、行号、制表符宽度、缩进等。通常的 Windows 功能可用，必要时还有 IntelliMouse 功能 如果您已打开 POU、GVL 或 NVL 并将焦点设置为文本声明编辑器，则指定变量声明。注意语法。 F2 获取支持，并使用输入助手选择数据类型或关键字。 你可以通过使用作用域或变量类型的快捷方式来避免打字。 有关更多信息，请参阅： 变量声明的快捷方式" }, 
{ "title" : "支持 自动申报 命令 ", 
"url" : "_cds_declaring_variable.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 支持 自动申报 命令 ", 
"snippet" : "要求：项目的 POU 或 GVL 已打开。 点击 编辑 → 自动申报 命令。 对话框打开。 从列表框中选择变量的所需范围 范围 。 在输入字段中指定变量名称 姓名 。 从中选择所需的数据类型 数据类型 列表框。 如果初始化值偏离标准初始化值，请输入变量的初始化值。 点击 好吧 确认您的输入。 新声明的变量列在您的 POU 的声明部分中。 在声明部分的编译指示的帮助下，你可以影响编译器对声明的处理。 有关更多信息，请参阅： 属性编译指示，命令 声明变量...", 
"body" : "要求：项目的 POU 或 GVL 已打开。 点击 编辑 → 自动申报 命令。 对话框打开。 从列表框中选择变量的所需范围 范围 。 在输入字段中指定变量名称 姓名 。 从中选择所需的数据类型 数据类型 列表框。 如果初始化值偏离标准初始化值，请输入变量的初始化值。 点击 好吧 确认您的输入。 新声明的变量列在您的 POU 的声明部分中。 在声明部分的编译指示的帮助下，你可以影响编译器对声明的处理。 有关更多信息，请参阅： 属性编译指示，命令 声明变量" }, 
{ "title" : "声明数组 ", 
"url" : "_cds_declaring_array.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 声明数组 ", 
"snippet" : "要求：项目的 POU 或 GVL 已打开。 点击 编辑 → 自动声明 命令。 这个 自动申报 对话框打开。 从中选择所需的阵列范围 范围 列表框。 在中为数组指定标识符 姓名 输入字段。 点击 旁边的按钮 数据类型 输入字段并选择 阵列助手 从选择菜单中输入。 在输入字段中 维度 1 ，键入数组第一维度的下限和上限（示例： 1 和 3 ）。 这个领域 结果 显示数组的第一维（示例： ARRAY [1..3] OF ? ）。 在输入字段中 基本类型 ，键入数组的数据类型或使用 输入助手 或者 阵列助手 （示例： DINT ）。 这个 结果 字段现在显示数组的数据类型（示例： ARRAY [1.....", 
"body" : "要求：项目的 POU 或 GVL 已打开。 点击 编辑 → 自动声明 命令。 这个 自动申报 对话框打开。 从中选择所需的阵列范围 范围 列表框。 在中为数组指定标识符 姓名 输入字段。 点击 旁边的按钮 数据类型 输入字段并选择 阵列助手 从选择菜单中输入。 在输入字段中 维度 1 ，键入数组第一维度的下限和上限（示例： 1 和 3 ）。 这个领域 结果 显示数组的第一维（示例： ARRAY [1..3] OF ? ）。 在输入字段中 基本类型 ，键入数组的数据类型或使用 输入助手 或者 阵列助手 （示例： DINT ）。 这个 结果 字段现在显示数组的数据类型（示例： ARRAY [1..3] OF DINT ）。 根据步骤 5 和 6 定义数组的第二和第三维度（示例：维度 2： 1 和 4 ，尺寸 3： 1 和 2 ）。 这个 结果 字段显示具有定义维度的数组： ARRAY [1..3, 1..4, 1..2] OF DINT 。该数组由 3 * 4 * 2 = 24 个元素组成。 在长度可变的数组中，使用星号占位符声明维度限制 ( * ）。长度可变的数组只能用于函数块、方法或函数的 VAR_IN_OUT 声明 长度可变的二维数组示例： aiUnknownLengthData : ARRAY [*,*] OF INT; 点击 好吧 。 在 自动申报 对话框， 数据类型 字段显示数组。 要修改数组的初始化值，请单击 旁边的按钮 初始化值 输入字段。 这个 初始化值 对话框打开。 选择要修改其初始化值的数组元素的行。示例：选择数组组件 [1, 1, 1]。 在列表下方的输入字段中指定所需的初始化值，然后单击按钮 在所选行上使用值 （示例：值 4 ）。 CODESYS 显示所选行的更改初始化值。 点击 好吧 。 在该领域 初始化值 对话的 声明变量 表示 CODESYS 数组的初始化值，例如： [4, 23(0)] . 您可以指定一个可选的 评论 在输入字段中。 点击 好吧 以便结束数组的声明。 CODESYS 将数组的声明添加到编程对象的声明部分。 有关更多信息，请参阅：数据类型 ARRAY OF" }, 
{ "title" : "声明全局变量 ", 
"url" : "_cds_defining_global_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 声明全局变量 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "定义应用程序中可用的全局变量 ", 
"url" : "_cds_defining_global_variables.html#UUID-73312950-d699-07b8-bbc0-46660b31cccc_id_a1822005ba31dc0a8640e004a22fb_id_e022761b24c9bb1bc0a8640e00b1b070", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 声明全局变量 \/ 定义应用程序中可用的全局变量 ", 
"snippet" : "要求：项目已打开。 在项目的设备树中，选择全局变量在其中有效的应用程序。 选择上下文菜单命令 添加对象 → 全局变量列表 . CODESYS 添加了 GVL 在应用程序下的设备树中并在编辑器中打开它。 选择菜单命令 编辑 → 声明变量 . 对话 声明变量 打开。 在选择列表中选择 范围 入口 VAR_GLOBAL . 在框中输入 姓 输入全局变量的名称。 在选择列表中选择 数据类型 一种数据类型。 如果您希望您的变量具有与默认初始化值不同的初始化值，请单击 在田野旁边 初始化值 . 对话 初始化值 打开。 双击单元格 初始化值 变量并输入所需的有效值。 点击 行 . 初始化值显示在对话框中 声...", 
"body" : "要求：项目已打开。 在项目的设备树中，选择全局变量在其中有效的应用程序。 选择上下文菜单命令 添加对象 → 全局变量列表 . CODESYS 添加了 GVL 在应用程序下的设备树中并在编辑器中打开它。 选择菜单命令 编辑 → 声明变量 . 对话 声明变量 打开。 在选择列表中选择 范围 入口 VAR_GLOBAL . 在框中输入 姓 输入全局变量的名称。 在选择列表中选择 数据类型 一种数据类型。 如果您希望您的变量具有与默认初始化值不同的初始化值，请单击 在田野旁边 初始化值 . 对话 初始化值 打开。 双击单元格 初始化值 变量并输入所需的有效值。 点击 行 . 初始化值显示在对话框中 声明变量 显示。 如有必要，激活其中一个 旗帜 . 点击按钮确认您的输入 行 . CODESYS 在 GVL 中插入声明的变量。 全局变量在项目的整个应用程序中都可用。 " }, 
{ "title" : "定义在整个项目中可用的全局变量 ", 
"url" : "_cds_defining_global_variables.html#UUID-73312950-d699-07b8-bbc0-46660b31cccc_id_a1822005ba31dc0a8640e004a22fb_id_b297ff7624c9bb1cc0a8640e01b4eaa9", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 声明全局变量 \/ 定义在整个项目中可用的全局变量 ", 
"snippet" : "选择菜单命令 查看 → POU . 风景 POU 打开。 在视图中选择 POU 具有项目名称的顶部节点并选择上下文菜单命令 添加对象 → 全局变量列表 . CODESYS 添加了 GVL 在视图中 POU 并在记事本中打开它。 选择菜单命令 编辑 → 声明变量 . 对话 声明变量 打开。 在选择列表中选择 范围 入口 VAR_GLOBAL . 在框中输入 姓 输入全局变量的名称。 在选择列表中选择 数据类型 一种数据类型。 如果您希望变量具有与默认初始化值不同的初始化值，请在列中输入 初始化 一。 如有必要，激活其中一个 旗帜 . 点击按钮确认您的输入 行 . CODESYS 在 GVL 中插...", 
"body" : "选择菜单命令 查看 → POU . 风景 POU 打开。 在视图中选择 POU 具有项目名称的顶部节点并选择上下文菜单命令 添加对象 → 全局变量列表 . CODESYS 添加了 GVL 在视图中 POU 并在记事本中打开它。 选择菜单命令 编辑 → 声明变量 . 对话 声明变量 打开。 在选择列表中选择 范围 入口 VAR_GLOBAL . 在框中输入 姓 输入全局变量的名称。 在选择列表中选择 数据类型 一种数据类型。 如果您希望变量具有与默认初始化值不同的初始化值，请在列中输入 初始化 一。 如有必要，激活其中一个 旗帜 . 点击按钮确认您的输入 行 . CODESYS 在 GVL 中插入声明的变量。 全局变量现在在整个项目中都可用。 " }, 
{ "title" : "使用任务局部变量 ", 
"url" : "_cds_define_task_local_global_variable_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 使用任务局部变量 ", 
"snippet" : "任务局部变量是循环一致的。它们只能由一个任务周期中的一个已定义任务写入，而所有其他任务只能读取它们。考虑到任务可以被其他任务打断，也可以同时运行。如果应用程序在具有多核处理器的系统上运行，则周期一致性首先也适用。 因此，当多个任务编辑相同的变量时，使用任务局部全局变量列表是一种自动获得同步（由编译器）的方法。使用普通 GVL 时情况并非如此。多个任务可以在一个周期内同时写入正常的 GVL 变量。 但是请注意，任务局部变量的同步相对耗时且占用大量内存，并不是每个应用程序都适合的方法。请参阅下面的更详细的技术信息和最佳实践建议，以帮助您做出决定。 在里面 CODESYS 项目， 全局变量列表（ta...", 
"body" : "任务局部变量是循环一致的。它们只能由一个任务周期中的一个已定义任务写入，而所有其他任务只能读取它们。考虑到任务可以被其他任务打断，也可以同时运行。如果应用程序在具有多核处理器的系统上运行，则周期一致性首先也适用。 因此，当多个任务编辑相同的变量时，使用任务局部全局变量列表是一种自动获得同步（由编译器）的方法。使用普通 GVL 时情况并非如此。多个任务可以在一个周期内同时写入正常的 GVL 变量。 但是请注意，任务局部变量的同步相对耗时且占用大量内存，并不是每个应用程序都适合的方法。请参阅下面的更详细的技术信息和最佳实践建议，以帮助您做出决定。 在里面 CODESYS 项目， 全局变量列表（tasklocal） 对象可用于定义任务局部变量。从语法上讲，它对应于普通 GVL，但也包含对变量具有写访问权限的任务的信息。这样，在任务周期内，此类 GVL 中的所有变量都不会被其他任务更改。 任务局部变量是复杂变量，其值不能在在线模式下使用 写入值 命令。 在下一节中，您将找到一个简单的示例，该示例展示了任务局部变量的原理和功能：有一个写入程序和一个读取程序。这些程序在不同的任务中运行，但访问任务局部全局变量列表中的相同数据，以便循环一致地处理它。 " }, 
{ "title" : "示例中显示的功能 ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_1bdc324663bd9d69c0a8646318878847", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 使用任务局部变量 \/ 示例中显示的功能 ", 
"snippet" : "可以在下面找到重新编程此示例应用程序的说明。 示例应用程序 (* task-local GVL, object name: \"Tasklocals\" *) VAR_GLOBAL g_diaData : ARRAY [0..99] OF DINT; END_VAR PROGRAM ReadData VAR diIndex : DINT; bTest : BOOL; diValue : DINT; END_VAR bTest := TRUE; diValue := TaskLocals.g_diaData[0]; FOR diIndex := 0 TO 99 DO bTest := bTest A...", 
"body" : "可以在下面找到重新编程此示例应用程序的说明。 示例应用程序 (* task-local GVL, object name: \"Tasklocals\" *)\nVAR_GLOBAL\n g_diaData : ARRAY [0..99] OF DINT;\nEND_VAR\n\nPROGRAM ReadData\nVAR\n diIndex : DINT;\n bTest : BOOL;\n diValue : DINT;\nEND_VAR\nbTest := TRUE;\ndiValue := TaskLocals.g_diaData[0];\nFOR diIndex := 0 TO 99 DO\n bTest := bTest AND (diValue = Tasklocals.g_diaData[diIndex]);\nEND_FOR\n\nPROGRAM WriteData\nVAR\n diIndex : DINT;\n diCounter : DINT;\nEND_VAR\ndiCounter := diCounter + 1;\nFOR diIndex := 0 TO 99 DO\n Tasklocals.g_diaData[diIndex] := diCounter;\nEND_FOR 节目 写入数据 和 读取数据 由不同的任务调用。 节目中 WriteData 变成数组 g_diaData 充满价值观。该程序 ReadData 测试数组的值是否符合预期。如果是这种情况，则变量返回 bTest 因此 TRUE . 被测试的数组数据是关于变量的 g_diaData 在对象 Tasklocals 类型的 Globale Variablenliste (tasklokal) 宣布。这会同步编译器中的数据访问，并保证数据是循环一致的，即使访问程序是从不同的任务中调用的。在示例程序中，这特别意味着变量 test 在节目中 ReadData 总是 TRUE 是。 如果变量 g_diaData 在此示例中仅声明为全局变量列表 test ，即变量 test 在节目中 ReadData , 更多时候 FALSE 递送。因为在这种情况下，两个任务之一 FOR -Loop 可以被其他任务中断，或者两个任务可以同时运行（多核控制器）。因此，当读者阅读列表时，作者可以更改这些值。 " }, 
{ "title" : "申报限制 ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_61f1e5de6a954123c0a86463531788fb", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 使用任务局部变量 \/ 申报限制 ", 
"snippet" : "更改任务局部变量列表中的声明后，无法在线更改应用程序。 声明全局任务局部变量列表时请注意以下事项： 不要通过 AT 声明分配直接地址。 不要映射到 PLC 配置中的本地任务变量。 不要声明指针。 不要声明引用。 不要实例化功能块。 不要同时声明任务局部变量 PERSISTENT 和 RETAIN . 没有写权限的任务中的写访问被编译器报告为错误。但是，不可能确定所有侵犯写作权的地方。编译器只能将静态调用分配给任务。但是，例如，通过指针或接口调用功能块不会分配给任务。这意味着那里也不会记录任何写访问。此外，指针可以指向任务局部变量。通过这种方式，可以在读取任务中操作数据。在这种情况下，也不会发出...", 
"body" : "更改任务局部变量列表中的声明后，无法在线更改应用程序。 声明全局任务局部变量列表时请注意以下事项： 不要通过 AT 声明分配直接地址。 不要映射到 PLC 配置中的本地任务变量。 不要声明指针。 不要声明引用。 不要实例化功能块。 不要同时声明任务局部变量 PERSISTENT 和 RETAIN . 没有写权限的任务中的写访问被编译器报告为错误。但是，不可能确定所有侵犯写作权的地方。编译器只能将静态调用分配给任务。但是，例如，通过指针或接口调用功能块不会分配给任务。这意味着那里也不会记录任何写访问。此外，指针可以指向任务局部变量。通过这种方式，可以在读取任务中操作数据。在这种情况下，也不会发出运行时错误。但是，通过指针访问时更改的值不会复制回变量的公共引用中。 " }, 
{ "title" : "任务局部全局变量的属性和可能的行为 ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_6eb169fa44f608dfc0a864631eeb1091", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 使用任务局部变量 \/ 任务局部全局变量的属性和可能的行为 ", 
"snippet" : "变量位于不同地址的每个任务的列表中。这意味着读取访问： ADR(variable name) 在每个任务中返回不同的地址。 同步机制保证以下内容： 循环一致性 免于锁定状态：任务在任何时候都不会等待另一个任务的动作。 但是，这种方法不能用于确定读任务一定会收到写任务副本的时间点。原则上，副本可以发散。在上面的例子中，不能假设每个写的副本都会被读者编辑一次。例如，读取任务可以处理同一个数组几个周期，或者数组的内容可以在两个周期之间“跳过”一个或多个值。两者都可能发生，必须加以考虑。 写任务可以在每个读任务对公共引用的两次访问之间保持一个周期。这意味着如果 n 读任务存在，写任务 n 周期被延迟到...", 
"body" : "变量位于不同地址的每个任务的列表中。这意味着读取访问： ADR(variable name) 在每个任务中返回不同的地址。 同步机制保证以下内容： 循环一致性 免于锁定状态：任务在任何时候都不会等待另一个任务的动作。 但是，这种方法不能用于确定读任务一定会收到写任务副本的时间点。原则上，副本可以发散。在上面的例子中，不能假设每个写的副本都会被读者编辑一次。例如，读取任务可以处理同一个数组几个周期，或者数组的内容可以在两个周期之间“跳过”一个或多个值。两者都可能发生，必须加以考虑。 写任务可以在每个读任务对公共引用的两次访问之间保持一个周期。这意味着如果 n 读任务存在，写任务 n 周期被延迟到公共参考的下一次更新。 写入任务可以防止读取任务在每个周期中获得读取副本。因此，不可能指定读取任务肯定会收到副本的最大周期数。 特别是，当涉及运行速度非常慢的任务时，这可能会成为问题。假设任务仅每小时运行一次，然后无法访问任务局部变量，则该任务正在使用列表的非常旧的副本。因此，在任务局部变量中插入时间戳是有意义的，读取任务可以使用它来至少确定列表是否是最新的。您可以按如下方式添加时间戳：将类型变量添加到任务局部变量列表 LTIME 而在写作任务中，例如下面的代码： tasklocal.g_timestamp := LTIME(); . " }, 
{ "title" : "最佳实践 ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_201eb4c744f608dfc0a86463690c31a3", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 使用任务局部变量 \/ 最佳实践 ", 
"snippet" : "任务局部变量是为用例“单写者 - 多读者”设计的。在实现将由不同任务调用的代码时，使用任务局部变量非常有用。例如，上面描述的示例应用程序就是这种情况 appTasklocal 当它被几个读取任务扩展时，这些任务都访问相同的数组并使用相同的函数。 任务局部变量在具有多核处理器的系统上特别有用。您无法在这些系统上按优先级同步任务。然后需要其他同步机制。 如果阅读任务必须始终使用变量的最新副本，请不要使用任务局部变量。本地任务变量不适用于此。 类似的问题是“生产者-消费者”问题。当一个任务产生数据而另一个任务处理它时就是这种情况。有了这个星座，更喜欢不同类型的同步。例如，生产者可以使用一个标志来指示...", 
"body" : "任务局部变量是为用例“单写者 - 多读者”设计的。在实现将由不同任务调用的代码时，使用任务局部变量非常有用。例如，上面描述的示例应用程序就是这种情况 appTasklocal 当它被几个读取任务扩展时，这些任务都访问相同的数组并使用相同的函数。 任务局部变量在具有多核处理器的系统上特别有用。您无法在这些系统上按优先级同步任务。然后需要其他同步机制。 如果阅读任务必须始终使用变量的最新副本，请不要使用任务局部变量。本地任务变量不适用于此。 类似的问题是“生产者-消费者”问题。当一个任务产生数据而另一个任务处理它时就是这种情况。有了这个星座，更喜欢不同类型的同步。例如，生产者可以使用一个标志来指示一个新的日期可用。消费者可以使用第二个标志来表明它已经处理了它的数据并且现在正在等待新的输入。两者都可以处理相同的数据。循环复制数据没有开销，消费者不会丢失生产者生成的任何数据。 " }, 
{ "title" : "监控 ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_ce0845ad44f608dfc0a8646329c0a4d8", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 使用任务局部变量 \/ 监控 ", 
"snippet" : "在运行时，内存中有几个可能不同的任务局部变量列表副本。但是，不是所有的值都可以在监控某个仓位的时候显示出来。因此，在线监控、监控列表和可视化中为任务局部变量显示来自公共参考的值。 如果设置断点，则会显示命中断点并因此停止的任务的数据。同时，其他任务继续运行。在某些情况下，可以更改通用副本。但是，在已停止任务的上下文中，值保持不变并按原样显示。你必须意识到这一点。...", 
"body" : "在运行时，内存中有几个可能不同的任务局部变量列表副本。但是，不是所有的值都可以在监控某个仓位的时候显示出来。因此，在线监控、监控列表和可视化中为任务局部变量显示来自公共参考的值。 如果设置断点，则会显示命中断点并因此停止的任务的数据。同时，其他任务继续运行。在某些情况下，可以更改通用副本。但是，在已停止任务的上下文中，值保持不变并按原样显示。你必须意识到这一点。 " }, 
{ "title" : "背景：技术实现 ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_0d2b15ad44f608dfc0a864634268e60b", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 使用任务局部变量 \/ 背景：技术实现 ", 
"snippet" : "对于任务局部变量列表，编译器为每个任务创建一个副本，并为所有任务创建一个公共引用副本。创建一个包含与任务局部变量列表相同的变量的结构。还创建了一个具有这种结构的数组，并为每个任务创建了一个数组维度。因此为每个任务索引一个数组元素。如果现在在代码中访问列表的变量，则实际上访问的是列表的任务本地副本。此外，确定块当前在哪个任务中运行，并相应地对访问进行索引。 例如，代码行 diValue := TaskLocals.g_diaData[0]; 从上面的示例替换： diValue := __TaskLocalVarsArray[__CURRENTTASK.TaskIndex].__g_diarr[0...", 
"body" : "对于任务局部变量列表，编译器为每个任务创建一个副本，并为所有任务创建一个公共引用副本。创建一个包含与任务局部变量列表相同的变量的结构。还创建了一个具有这种结构的数组，并为每个任务创建了一个数组维度。因此为每个任务索引一个数组元素。如果现在在代码中访问列表的变量，则实际上访问的是列表的任务本地副本。此外，确定块当前在哪个任务中运行，并相应地对访问进行索引。 例如，代码行 diValue := TaskLocals.g_diaData[0]; 从上面的示例替换： diValue := __TaskLocalVarsArray[__CURRENTTASK.TaskIndex].__g_diarr[0]; __CURRENTTASK 是一个运算符，ab CODESYS V3.5 SP13 可用于快速确定当前任务索引。 在运行时，任务本地列表的内容在写入任务结束时被复制到公共引用。在阅读任务的情况下，公共引用的内容在开始时被复制到任务本地副本。因此，对于 n 个任务，列表有 n+1 个副本：列表用作公共参考，此外，每个任务都有自己的列表副本。 调度程序控制多个任务的及时执行，从而控制任务切换。调度程序遵循的控制执行时间分配的策略旨在避免阻塞任务。因此，同步机制针对任务局部变量的属性进行了优化，从而避免了阻塞状态（锁定状态），并且一个任务永远不会等待另一个任务的动作。 同步策略： 只要写入任务将副本写回共享引用，任何读取任务都不会获得副本。 只要读取任务从共享引用中获取副本，写入任务就不会写回副本。 " }, 
{ "title" : "创建上述示例应用程序的说明 ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_b297ff7624c9bb1cc0a8640e01b4eaa9", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 变量声明 \/ 使用任务局部变量 \/ 创建上述示例应用程序的说明 ", 
"snippet" : "目标：你想从一个程序开始 ReadData 访问程序访问的相同数据 WriteData 要写。这两个程序应该在不同的任务中运行。您在任务局部变量列表中提供数据，以便以循环一致的方式自动处理它们。 要求：新创建并在编辑器中打开标准项目。 重命名应用程序 Application 在 appTasklocal 大约。 在下面添加 appTasklocal ST中的程序名称 ReadData 添加。 在下面添加 appTasklocal ST中的另一个程序名称 WriteData 添加。 命名默认任务 MainTask 在对象下 Taskkonfiguration 在 Read 大约。 加入对话 配置...", 
"body" : "目标：你想从一个程序开始 ReadData 访问程序访问的相同数据 WriteData 要写。这两个程序应该在不同的任务中运行。您在任务局部变量列表中提供数据，以便以循环一致的方式自动处理它们。 要求：新创建并在编辑器中打开标准项目。 重命名应用程序 Application 在 appTasklocal 大约。 在下面添加 appTasklocal ST中的程序名称 ReadData 添加。 在下面添加 appTasklocal ST中的另一个程序名称 WriteData 添加。 命名默认任务 MainTask 在对象下 Taskkonfiguration 在 Read 大约。 加入对话 配置 任务 Read 通过按钮 添加通话 调用程序 ReadData 添加。 粘贴在对象下 任务配置 添加了另一个名为 Write 并将程序调用添加到此任务 Write 添加。 现在任务配置中有两个任务 Write 和 Read 谁的节目 WriteData 分别 ReadData 称呼。 选择应用程序 appTasklocal 并添加一个类型的对象 全局变量列表（任务本地） 添加。 对话 添加全局变量列表（任务本地）。 打开。 作为名称输入 Tasklocals 一。 从下拉列表中选择 具有写入权限的任务 任务 Write . 在应用程序中使用本地任务变量的对象结构是完整的。您现在可以对上面示例描述中所示的对象进行编码。 " }, 
{ "title" : "在 IEC 中创建源代码 ", 
"url" : "_cds_f_programming_pous.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 在 IEC 中创建源代码 ", 
"snippet" : "源代码： 我们所说的 “源代码” 是指您通过相应的编程语言编辑器插入到 POU 中的实现代码。以下 POU 类型可用于此目的：POU（程序、函数、功能块）、操作、方法、属性和 编程语言： 创建编程模块时，您决定使用哪种实现语言进行编程。除 IEC 语言外，还提供 CFC。 编程语言编辑器： 双击设备树或 POU 树中的对象时，将在相应的编程语言编辑器中打开 POU 进行编辑。然后，POU 将显示在文本 ST 编辑器或 FBD\/LD、SFC 或 CFC 的图形编辑器中。每个编辑器由两个窗口组成：在上方的窗口中，您可以根据设置以文本或表格形式进行声明。在下方的窗口中，插入实现代码。您可以在项目的相...", 
"body" : "源代码： 我们所说的 “源代码” 是指您通过相应的编程语言编辑器插入到 POU 中的实现代码。以下 POU 类型可用于此目的：POU（程序、函数、功能块）、操作、方法、属性和 编程语言： 创建编程模块时，您决定使用哪种实现语言进行编程。除 IEC 语言外，还提供 CFC。 编程语言编辑器： 双击设备树或 POU 树中的对象时，将在相应的编程语言编辑器中打开 POU 进行编辑。然后，POU 将显示在文本 ST 编辑器或 FBD\/LD、SFC 或 CFC 的图形编辑器中。每个编辑器由两个窗口组成：在上方的窗口中，您可以根据设置以文本或表格形式进行声明。在下方的窗口中，插入实现代码。您可以在项目的相应选项卡中配置整个项目中每个编辑器的外观和行为 CODESYS 选项。 有关更多信息，请参阅： 编程语言和编辑器CODESYS LD FBD CODESYS SFC CODESYS CFC " }, 
{ "title" : "结构化文本 (ST)、扩展结构化文本 (ExST) ", 
"url" : "_cds_f_programming_language_st.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 在 IEC 中创建源代码 \/ 结构化文本 (ST)、扩展结构化文本 (ExST) ", 
"snippet" : "ST 编辑器用于以 IEC-61131-3 编程语言结构化文本 (ST) 和扩展结构化文本对 POU 进行编程。扩展结构化文本提供了一些与 IEC-61131-3 标准相关的附加功能。 结构化文本是一种编程语言，可与 C 或 PASCAL 等其他高级语言相媲美，它允许开发复杂的算法。程序代码由以下组合组成 表达 和 指示 ，也可以有条件地执行（IF...THEN...ELSE）或循环执行（WHILE...DO）。 表达式是在计算后返回值的构造。表达式也是运算符和操作数。您还可以将赋值用作表达式。操作数可以是常量、变量、函数调用或其他表达式。 语句控制应如何处理表达式。 对于此文本编辑器，您可以...", 
"body" : "ST 编辑器用于以 IEC-61131-3 编程语言结构化文本 (ST) 和扩展结构化文本对 POU 进行编程。扩展结构化文本提供了一些与 IEC-61131-3 标准相关的附加功能。 结构化文本是一种编程语言，可与 C 或 PASCAL 等其他高级语言相媲美，它允许开发复杂的算法。程序代码由以下组合组成 表达 和 指示 ，也可以有条件地执行（IF...THEN...ELSE）或循环执行（WHILE...DO）。 表达式是在计算后返回值的构造。表达式也是运算符和操作数。您还可以将赋值用作表达式。操作数可以是常量、变量、函数调用或其他表达式。 语句控制应如何处理表达式。 对于此文本编辑器，您可以在对话框中 选项 和 调整 菜单的 工具 对行为、外观和菜单进行各种设置。众所周知的 Windows 功能也可用于此编辑器（例如 IntelliMouse）。 有关更多信息，请参阅： 结构化文本 (ST) 编程" }, 
{ "title" : "ExST - 扩展结构化文本 ", 
"url" : "_cds_f_programming_language_st.html#UUID-c0b48aaa-9e6c-d5d3-e0a2-ddaf98d1688a_section-idm4538086976966432654794828895", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 在 IEC 中创建源代码 \/ 结构化文本 (ST)、扩展结构化文本 (ExST) \/ ExST - 扩展结构化文本 ", 
"snippet" : "扩展结构化文本 (ExST) 是 CODESYS - 有关结构化文本 (ST) 的 IEC 61131-3 标准的特定扩展。 有关更多信息，请参阅： 作业...", 
"body" : "扩展结构化文本 (ExST) 是 CODESYS - 有关结构化文本 (ST) 的 IEC 61131-3 标准的特定扩展。 有关更多信息，请参阅： 作业" }, 
{ "title" : "结构化文本 (ST) 编程 ", 
"url" : "_cds_programming_in_st.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 在 IEC 中创建源代码 \/ 结构化文本 (ST)、扩展结构化文本 (ExST) \/ 结构化文本 (ST) 编程 ", 
"snippet" : "以结构化文本 (ST) 实现语言创建 POU 在设备树中选择一个应用程序。 选择命令 项目→添加对象→POU . 对话 添加 POU 打开。 输入名称并选择 实现语言 结构化文本 (ST) . 点击 添加 . POU 被添加到设备树并在编辑器中打开。 现在在 POU 的上部插入变量声明，在 POU 的下部输入 ST 程序代码。...", 
"body" : "以结构化文本 (ST) 实现语言创建 POU 在设备树中选择一个应用程序。 选择命令 项目→添加对象→POU . 对话 添加 POU 打开。 输入名称并选择 实现语言 结构化文本 (ST) . 点击 添加 . POU 被添加到设备树并在编辑器中打开。 现在在 POU 的上部插入变量声明，在 POU 的下部输入 ST 程序代码。 " }, 
{ "title" : "原则 ", 
"url" : "_cds_programming_in_st.html#UUID-2076ef08-fb89-b7e5-586c-5a99b07f8d18_id_a941afccf6c2c2c0a8640e010636b9_id_dc652380fd1509c7c0a8640e015d35d3", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 在 IEC 中创建源代码 \/ 结构化文本 (ST)、扩展结构化文本 (ExST) \/ 结构化文本 (ST) 编程 \/ 原则 ", 
"snippet" : "您在 ST 编辑器中对编程语言“结构化文本”和“扩展结构化文本”进行编程。程序代码由表达式和语句的组合组成，它们也可以有条件地或循环执行。您需要的每一条指令 ; 锁定。 变量在声明编辑器中声明。...", 
"body" : "您在 ST 编辑器中对编程语言“结构化文本”和“扩展结构化文本”进行编程。程序代码由表达式和语句的组合组成，它们也可以有条件地或循环执行。您需要的每一条指令 ; 锁定。 变量在声明编辑器中声明。 " }, 
{ "title" : "为在线更改配置内存保留 ", 
"url" : "_cds_configuring_memory_reserve.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 为在线更改配置内存保留 ", 
"snippet" : "您可以配置具有内存保留的功能块，以避免在在线更改期间必须将其功能块实例复制到新的内存位置。当您进行声明更改（例如将变量添加到功能块）时，可能会发生这种情况。有了内存保留，这样的在线更改运行速度更快，出现的问题也更少。如果存储空间已用完，则在执行在线更改之前会出现一条消息。 最好在首次将应用程序下载到控制器之前为功能块配置内存保留。如果仅在应用程序已在控制器上时才配置内存保留，则需要进行耗时的在线更改。...", 
"body" : "您可以配置具有内存保留的功能块，以避免在在线更改期间必须将其功能块实例复制到新的内存位置。当您进行声明更改（例如将变量添加到功能块）时，可能会发生这种情况。有了内存保留，这样的在线更改运行速度更快，出现的问题也更少。如果存储空间已用完，则在执行在线更改之前会出现一条消息。 最好在首次将应用程序下载到控制器之前为功能块配置内存保留。如果仅在应用程序已在控制器上时才配置内存保留，则需要进行耗时的在线更改。 " }, 
{ "title" : "为功能块的在线更改配置内存预留 ", 
"url" : "_cds_configuring_memory_reserve.html#UUID-37b7c569-d1f3-f5d0-0328-3e84514c76a6_id_e907096bc90bbc0a8646334d3dfea_id_6b7a234396c8490fc0a86463751c1541", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 为在线更改配置内存保留 \/ 为功能块的在线更改配置内存预留 ", 
"snippet" : "将来对项目的功能块进行重大更改，这可能会导致功能块实例在在线更改期间被复制到其他存储位置。 要求：理想情况下，打开的项目尚未在控制器上。 选择命令 查看 → 为在线更改设置内存保留 . 风景 在线更改的内存保留 打开。 从选择列表中选择项目的应用。 选择命令 创建 → 翻译 . 点击按钮 搜索应用程序 . 在该地区选择 功能块 入口 全部 . 应用程序的所有功能块都显示在视图中。 选择要为其配置内存保留的适当功能块。 如果应用程序尚未在控制器上，则输入字段为 内存储备 （以字节为单位）可编辑。 如果应用程序已经在控制器上，请单击按钮 编辑 在那个地区 允许编辑 . 请注意，如果您更改控制器上已...", 
"body" : "将来对项目的功能块进行重大更改，这可能会导致功能块实例在在线更改期间被复制到其他存储位置。 要求：理想情况下，打开的项目尚未在控制器上。 选择命令 查看 → 为在线更改设置内存保留 . 风景 在线更改的内存保留 打开。 从选择列表中选择项目的应用。 选择命令 创建 → 翻译 . 点击按钮 搜索应用程序 . 在该地区选择 功能块 入口 全部 . 应用程序的所有功能块都显示在视图中。 选择要为其配置内存保留的适当功能块。 如果应用程序尚未在控制器上，则输入字段为 内存储备 （以字节为单位）可编辑。 如果应用程序已经在控制器上，请单击按钮 编辑 在那个地区 允许编辑 . 请注意，如果您更改控制器上已存在的应用程序的内存保留，则必须将所有受影响功能块的实例复制到内存中。 以字节为单位输入内存保留的大小，然后单击 应用于选择 . 输入的字节数显示在字段的表格中 内存储备 显示。 选择命令 创建 → 翻译 然后点击按钮 搜索应用程序 . 在已配置功能块的功能块列表中，信息 尺寸 , 实例数 , 所有实例的额外存储 和 剩余存储量 更新。 如果您现在将应用程序加载到控制器上，则功能块实例会占用所需的内存以及内存预留。因此，可以通过在线更改将功能块的未来主要更改加载到控制器上，而无需复制内存中功能块的所有实例。 " }, 
{ "title" : "用外部实现调用函数模块、函数或方法 ", 
"url" : "_cds_calling_fb_function_method_with_external_implementation.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 用外部实现调用函数模块、函数或方法 ", 
"snippet" : "运行时系统可以包含功能块、功能或方法的实现，例如来自库。如果您在应用程序中使用同名的 POU 和属性 外部实施 在不创建实现的情况下，您可以运行已经存在的实现。您应该注意，您只在外部功能块中声明局部变量。外部函数或方法不能包含局部变量。 应用程序下载期间的搜索 CODESYS 对于每个外部 POU，运行时系统中的相关实现并链接它。 具有属性的对象 外部实施 在视野中 设备 或者 POU 通过加法 (EXT) 标记在对象名称之后。 有关更多信息，请参阅： 建造使用外部实现创建方法 在设备树或 POU 视图中选择一个功能块。 选择 添加对象→方法 并输入运行时系统的关联实现的名称作为名称。结束对话...", 
"body" : "运行时系统可以包含功能块、功能或方法的实现，例如来自库。如果您在应用程序中使用同名的 POU 和属性 外部实施 在不创建实现的情况下，您可以运行已经存在的实现。您应该注意，您只在外部功能块中声明局部变量。外部函数或方法不能包含局部变量。 应用程序下载期间的搜索 CODESYS 对于每个外部 POU，运行时系统中的相关实现并链接它。 具有属性的对象 外部实施 在视野中 设备 或者 POU 通过加法 (EXT) 标记在对象名称之后。 有关更多信息，请参阅： 建造使用外部实现创建方法 在设备树或 POU 视图中选择一个功能块。 选择 添加对象→方法 并输入运行时系统的关联实现的名称作为名称。结束对话 添加 . 方法已创建。 选择方法并在上下文菜单中激活它 特性 . 对话框打开。 选择标签 翻译 . 激活选项 外部实现（运行时系统中的后期链接） . 该方法已声明，您可以实现对该方法的调用。视图中的方法名 设备 或在视野中 POU 是加上 (EXT) 错误。 " }, 
{ "title" : "使用外部实现创建 POU ", 
"url" : "_cds_calling_fb_function_method_with_external_implementation.html#UUID-fff6ac80-1b8a-7912-4b20-ed87a85fdbb5_id_c98ff0280307e532c0a8640e0065769d_id_3b8dd10723c74a66c0a8640e01935197", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 用外部实现调用函数模块、函数或方法 \/ 使用外部实现创建 POU ", 
"snippet" : "选择 项目→添加对象→POU . 启用 功能块 , 方法或 功能 并输入运行时系统的相关实现的名称作为名称。结束对话 添加 . 具有运行时系统 POU 名称的 POU 在视图中 POU 创建的。名字有加法 (EXT) 错误。 选择 POU 并在上下文菜单中激活它 特性 . 对话框打开。 选择标签 翻译 . 激活选项 外部实现（运行时系统中的后期链接） . POU 已声明，您可以实现对 POU 的调用。...", 
"body" : "选择 项目→添加对象→POU . 启用 功能块 , 方法或 功能 并输入运行时系统的相关实现的名称作为名称。结束对话 添加 . 具有运行时系统 POU 名称的 POU 在视图中 POU 创建的。名字有加法 (EXT) 错误。 选择 POU 并在上下文菜单中激活它 特性 . 对话框打开。 选择标签 翻译 . 激活选项 外部实现（运行时系统中的后期链接） . POU 已声明，您可以实现对 POU 的调用。 " }, 
{ "title" : "使用输入辅助 ", 
"url" : "_cds_using_input_assistants.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 使用输入辅助 ", 
"snippet" : "CODESYS 提供的工具和功能可帮助您在创建程序时进行编码。 智能标签功能 通过直接在编程元素上建议适当的命令，智能标签可以更轻松地编写程序代码。当您将光标置于具有智能标记功能的编程元素上时， 符号出现。当你点击 符号，将显示您可以选择的命令。可用的智能标签： 智能标签功能提供了 自动申报 ST 编辑器实现部分中未声明变量的命令。...", 
"body" : "CODESYS 提供的工具和功能可帮助您在创建程序时进行编码。 智能标签功能 通过直接在编程元素上建议适当的命令，智能标签可以更轻松地编写程序代码。当您将光标置于具有智能标记功能的编程元素上时， 符号出现。当你点击 符号，将显示您可以选择的命令。可用的智能标签： 智能标签功能提供了 自动申报 ST 编辑器实现部分中未声明变量的命令。 " }, 
{ "title" : "输入助手 ", 
"url" : "_cds_using_input_assistants.html#UUID-c64e3633-b2dc-8e9f-0533-6676df90609a_id_fbe6a158721888c0a8640e00a479cd_id_10730b9a8290a9e9c0a8640e006261df", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 使用输入辅助 \/ 输入助手 ", 
"snippet" : "输入助手提供所有可以在当前光标位置插入的程序元素。 输入助手 点击对话框 编辑 → 输入助手 或者按下 F2 钥匙。...", 
"body" : "输入助手提供所有可以在当前光标位置插入的程序元素。 输入助手 点击对话框 编辑 → 输入助手 或者按下 F2 钥匙。 " }, 
{ "title" : "对话框：自动声明 ", 
"url" : "_cds_using_input_assistants.html#UUID-c64e3633-b2dc-8e9f-0533-6676df90609a_id_fbe6a158721888c0a8640e00a479cd_id_3879e6752bd7ab84c0a8640e015b3239", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 使用输入辅助 \/ 对话框：自动声明 ", 
"snippet" : "此对话框支持变量的声明。 有关更多信息，请参阅： 声明变量...", 
"body" : "此对话框支持变量的声明。 有关更多信息，请参阅： 声明变量" }, 
{ "title" : "列出组件 ", 
"url" : "_cds_using_input_assistants.html#UUID-c64e3633-b2dc-8e9f-0533-6676df90609a_id_fbe6a158721888c0a8640e00a479cd_id_028146f939ae1e35c0a8640e013e8fd8", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 使用输入辅助 \/ 列出组件 ", 
"snippet" : "“列表组件” 功能是文本编辑器中的输入工具，可帮助您输入有效的标识符。点击激活此功能 工具 → 选项 然后 智能编码 类别。 键入点 (.) 后列出组件 选项。 如果你键入一个点 ( . ) 而不是全局变量，然后打开一个包含所有可用全局变量的列表框。双击列表框中的变量或按，可以在点之后插入选定变量 输入 。 如果你在函数块实例变量或结构变量之后键入一个点 (.) 而不是全局变量，那么 CODESYS 打开一个包含所有全局变量、功能块的所有输入和输出变量或所有结构成员的列表框。 双击列表框中的变量或按，可以在点之后插入选定变量 输入 。 注意：当您还想从函数块实例的局部变量中进行选择时，请选择 ...", 
"body" : "“列表组件” 功能是文本编辑器中的输入工具，可帮助您输入有效的标识符。点击激活此功能 工具 → 选项 然后 智能编码 类别。 键入点 (.) 后列出组件 选项。 如果你键入一个点 ( . ) 而不是全局变量，然后打开一个包含所有可用全局变量的列表框。双击列表框中的变量或按，可以在点之后插入选定变量 输入 。 如果你在函数块实例变量或结构变量之后键入一个点 (.) 而不是全局变量，那么 CODESYS 打开一个包含所有全局变量、功能块的所有输入和输出变量或所有结构成员的列表框。 双击列表框中的变量或按，可以在点之后插入选定变量 输入 。 注意：当您还想从函数块实例的局部变量中进行选择时，请选择 在输入助手中显示所有实例变量 中的选项 CODESYS “智能编码” 类别中的选项。 如果已经访问了列表框的组件（带点），则在下次访问组件时会预先选择最后选定的条目。 当你键入任意字符序列然后按 Ctrl + 太空 ，则会打开一个包含所有可用的 POU 和全局变量的列表框。默认情况下，此列表中第一个以字符序列开头的元素处于选中状态，您可以通过双击该元素或按将其插入 输入 。 与输入字符串的匹配项在列表框中以黄色突出显示。 如果输入的字符串发生变化，则显示的列表框将刷新。 在 ST 编辑器中，您可以按范围筛选显示的列表框： 根据显示的列表框，您可以使用 向右箭头 和 向左箭头 在以下列表框之间切换的快捷键： 所有物品 关键词 全球声明 当地声明 CODESYS 如果在调用函数块、方法或函数时键入 POU 参数的左括号，则会显示工具提示。此工具提示包含有关在 POU 中声明的参数的信息。工具提示将保持打开状态，直到您单击将其关闭或将焦点从当前视图移开。如果您不小心关闭了工具提示，则可以通过按下将其重新打开 Ctrl + 移动 + 太空 。 你可以使用 pragma 属性 隐藏 用于从 “列表组件” 功能中排除变量。 例子 键入结构变量： 调用函数块： 有关更多信息，请参阅： 智能编码" }, 
{ "title" : "简短表单功能 ", 
"url" : "_cds_using_input_assistants.html#UUID-c64e3633-b2dc-8e9f-0533-6676df90609a_id_fbe6a158721888c0a8640e00a479cd_id_cebde498c37bd547c0a864634120c4e4", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 使用输入辅助 \/ 简短表单功能 ", 
"snippet" : "短格式功能允许您在声明编辑器和可以声明变量的文本编辑器中键入变量声明的缩写形式。按下即可使用此功能 Ctrl + 输入 结束声明行。 有关更多信息，请参阅： 变量声明的快捷方式CODESYS 支持以下简短形式： 除行的最后一个标识符外，所有标识符都成为变量标识符。 声明的数据类型由该行的最后一个标识符确定。以下内容适用： b 变成 : BOOL d 变成 : DINT 我 变成 : INT l 变成 : LINT r 变成 : REAL s 变成 : STRING s 8 变成 : STRING(8) 带字符串长度 t 变成 : TIME u 变成 : UINT w 变成 : WORD 如果未...", 
"body" : "短格式功能允许您在声明编辑器和可以声明变量的文本编辑器中键入变量声明的缩写形式。按下即可使用此功能 Ctrl + 输入 结束声明行。 有关更多信息，请参阅： 变量声明的快捷方式CODESYS 支持以下简短形式： 除行的最后一个标识符外，所有标识符都成为变量标识符。 声明的数据类型由该行的最后一个标识符确定。以下内容适用： b 变成 : BOOL d 变成 : DINT 我 变成 : INT l 变成 : LINT r 变成 : REAL s 变成 : STRING s 8 变成 : STRING(8) 带字符串长度 t 变成 : TIME u 变成 : UINT w 变成 : WORD 如果未使用此规则定义数据类型，则该数据类型将自动定义 BOOL ，并且最后一个标识符不用作数据类型（参见示例 1）。 根据声明的类型，每个定义的常量都会成为初始化或字符串长度定义（参见示例 2 和 3）。 地址，例如 %MD12 ，使用 AT 属性自动扩展（参见示例 4）。 分号之后的任何文本 ( ; ) 被转换为注释（参见示例 3）。 该行中的所有其他字符都将被忽略（参见示例 5 中的感叹号）。 例子 简短表格 结果声明 1 A A: BOOL; 2 A B I 2 A, B: INT := 2; 3 ST S 2; A string ST:STRING(2); (* A string *) 4 X %MD12 R 5 Real Number X AT %MD12: REAL := 5.0;(* Real Number *) 5 B ! B: BOOL; " }, 
{ "title" : "使用指令 ", 
"url" : "_cds_using_pragmas.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 使用指令 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "编译指示 CODESYS ", 
"url" : "_cds_using_pragmas.html#UUID-7a6cff73-fd46-0ee8-105d-673d8223ef56_id_f9a5d357efac0a8640e0137aceb_id_83e9bccc5e33ab49c0a8640e01f6b4a9", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 使用指令 \/ 编译指示 CODESYS ", 
"snippet" : "编译指示 (pragma) 是应用程序源代码中用括号括起来的文本。编译指示用于在代码中插入编译器可以执行的特殊语句。这使得编译指示能够影响预编译或编译（代码生成）中一个或多个变量的属性。编译器无法识别的编译指示将被忽略，并视为注释。 编译指示的语句字符串也可以延伸到多行。 有关语法的更多详细信息，请参阅各个 CODESYS 语用。 对于不同的目的有不同的编译指示（例如：初始化变量、监视变量、将变量添加到符号配置、在编译过程中强制显示消息以及变量在特定条件下的行为）。 必须尊重大写和小写字符。...", 
"body" : "编译指示 (pragma) 是应用程序源代码中用括号括起来的文本。编译指示用于在代码中插入编译器可以执行的特殊语句。这使得编译指示能够影响预编译或编译（代码生成）中一个或多个变量的属性。编译器无法识别的编译指示将被忽略，并视为注释。 编译指示的语句字符串也可以延伸到多行。 有关语法的更多详细信息，请参阅各个 CODESYS 语用。 对于不同的目的有不同的编译指示（例如：初始化变量、监视变量、将变量添加到符号配置、在编译过程中强制显示消息以及变量在特定条件下的行为）。 必须尊重大写和小写字符。 " }, 
{ "title" : "语用类别 ", 
"url" : "_cds_using_pragmas.html#UUID-7a6cff73-fd46-0ee8-105d-673d8223ef56_id_f9a5d357efac0a8640e0137aceb_id_3296509035ae4c0cc0a8640e000e65d2", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 使用指令 \/ 语用类别 ", 
"snippet" : "这 CODESYS 编译指示分为以下几类： 消息指令 编译过程中可以显示自定义消息。 属性指令 编译和预编译可能会受到影响。为此，可以使用编译指示来实现不同的目的，例如初始化、监控，或向符号配置添加变量。 条件指令代码生成可以通过条件语句来控制。例如，变量的行为在某些条件下可能会有所不同。 区域编译指示 测试 POU 中的指令 用户定义的指令 在 特性 对话框（ 编译 在“类别”中，您可以声明编译器“定义”，并且可以在编译指示中进行查询。...", 
"body" : "这 CODESYS 编译指示分为以下几类： 消息指令 编译过程中可以显示自定义消息。 属性指令 编译和预编译可能会受到影响。为此，可以使用编译指示来实现不同的目的，例如初始化、监控，或向符号配置添加变量。 条件指令代码生成可以通过条件语句来控制。例如，变量的行为在某些条件下可能会有所不同。 区域编译指示 测试 POU 中的指令 用户定义的指令 在 特性 对话框（ 编译 在“类别”中，您可以声明编译器“定义”，并且可以在编译指示中进行查询。 " }, 
{ "title" : "可能的插入位置 ", 
"url" : "_cds_using_pragmas.html#UUID-7a6cff73-fd46-0ee8-105d-673d8223ef56_id_f9a5d357efac0a8640e0137aceb_id_ed58008b2a97bd5ec0a8640e002167c3", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 使用指令 \/ 可能的插入位置 ", 
"snippet" : "中的语句 CODESYS 并非 C 预处理器指令的一对一实现。您需要像普通语句一样定位编译指示。您不能在表达式中使用编译指示。 您可以插入一个指令，以便编译器在各个位置进行评估。 在声明中 在 POU 的声明头中 您可以在文本编辑器中直接将所需的指令作为单独的行输入，可以作为 POU 的第一行，也可以在变量声明之前输入。 在表格视图中，输入指令时会获得支持。点击 编辑声明标题 命令。在对话框中，单击 属性 按钮并在输入字段中输入所需的指令。 在全局变量列表中 条件指令的限制 仅在 POU 的实现中使用编译指示进行条件编译。在声明中，这些编译指示会被忽略，而不会被求值。 请注意以下例外：带有 p...", 
"body" : "中的语句 CODESYS 并非 C 预处理器指令的一对一实现。您需要像普通语句一样定位编译指示。您不能在表达式中使用编译指示。 您可以插入一个指令，以便编译器在各个位置进行评估。 在声明中 在 POU 的声明头中 您可以在文本编辑器中直接将所需的指令作为单独的行输入，可以作为 POU 的第一行，也可以在变量声明之前输入。 在表格视图中，输入指令时会获得支持。点击 编辑声明标题 命令。在对话框中，单击 属性 按钮并在输入字段中输入所需的指令。 在全局变量列表中 条件指令的限制 仅在 POU 的实现中使用编译指示进行条件编译。在声明中，这些编译指示会被忽略，而不会被求值。 请注意以下例外：带有 project_defined 运算符可以插入到声明中。有关更多信息，请参阅以下内容：IF pragma with project_defined (<global define>)在 POU 的实施中 结构化文本（ST） 在 ST 实现语言中，编译指示属于“语句位置”。有效位置位于实现的开头，另起一行。另一个有效位置位于以分号“ ; \" 或通过以下关键字 END_VAR ， END_IF ， 或者 END_WHILE 。 功能块图（FBD）或梯形图（LD） 在 FBD\/LD\/IL 编辑器的实现语言中，指令的位置与标签的位置相同。您可以像输入标签一样输入指令。为此，请选择命令 FBD\/LD\/IL → 插入标签 。然后，在标签的文本字段中，替换默认文本 Label: 使用所需的编译指示。要使用编译指示和标签，请先指定编译指示，然后再指定标签。 例子 对于条件指令的不正确和正确位置 PROGRAM PRG_ConditionalPragma\nVAR\n strTest : STRING := 'b';\n iResult : INT := 0;\nEND_VAR\n 不正确 {IF defined(DEFINE_A)}\nIF strTest = 'a' THEN\n{ELSE}\nIF strTest = 'b' THEN\n{END_IF}\n iResult := {IF defined(DEFINE_B)} 12; {ELSE} 13; {END_IF}\nEND_IF\n 正确的 {IF defined(DEFINE_A)}\nIF strTest = 'a' THEN\n {IF defined(DEFINE_B)}\n iResult := 16#A;\n {ELSE}\n iResult := 16#AA;\n {END_IF}\nEND_IF\n{ELSE}\nIF strTest = 'b' THEN\n {IF defined(DEFINE_B)}\n iResult := 16#B;\n {ELSE}\n iResult := 16#BB;\n {END_IF}\nEND_IF\n{END_IF} " }, 
{ "title" : "范围 ", 
"url" : "_cds_using_pragmas.html#UUID-7a6cff73-fd46-0ee8-105d-673d8223ef56_section-id235127926588889", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 使用指令 \/ 范围 ", 
"snippet" : "根据指令的类型和内容，它可能会影响以下内容： 后续声明 正是下一个语句 所有后续语句，直到被相应的 pragma 取消 所有后续语句，直到同一个指令使用其他参数执行或到达代码末尾。此处的“代码”指的是声明部分、实现部分、全局变量列表和类型声明。因此，当一个指令单独位于声明部分的第一行，且未被其他指令取代或取消时，该指令将影响整个对象。...", 
"body" : "根据指令的类型和内容，它可能会影响以下内容： 后续声明 正是下一个语句 所有后续语句，直到被相应的 pragma 取消 所有后续语句，直到同一个指令使用其他参数执行或到达代码末尾。此处的“代码”指的是声明部分、实现部分、全局变量列表和类型声明。因此，当一个指令单独位于声明部分的第一行，且未被其他指令取代或取消时，该指令将影响整个对象。 " }, 
{ "title" : "使用库模块 ", 
"url" : "_cds_using_libraries.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 使用库模块 ", 
"snippet" : "库是可以包含在应用程序中的对象的集合。您可以以与直接在项目中定义的对象完全相同的方式使用项目中库中包含的对象。 库可以包含以下对象： 功能块或功能等 POU 接口及其方法和属性 数据类型，例如枚举、结构、别名、联合 全局变量、常量、参数列表 文本列表、图像集合、可视化、可视化元素 外部文件（例如文档） 凸轮表 项目中的库在库管理器中进行管理。您可以通过库存储库的对话框在系统上执行库的先前安装。 有关库构建块和库命名空间的“可见性”的更多信息，请参阅： 库属性帮助页面 使用库构建块 以下指令以示例说明如何使用计数器块 CTUD 从图书馆 Standard 插入你的程序。 在编辑器中打开一个 PO...", 
"body" : "库是可以包含在应用程序中的对象的集合。您可以以与直接在项目中定义的对象完全相同的方式使用项目中库中包含的对象。 库可以包含以下对象： 功能块或功能等 POU 接口及其方法和属性 数据类型，例如枚举、结构、别名、联合 全局变量、常量、参数列表 文本列表、图像集合、可视化、可视化元素 外部文件（例如文档） 凸轮表 项目中的库在库管理器中进行管理。您可以通过库存储库的对话框在系统上执行库的先前安装。 有关库构建块和库命名空间的“可见性”的更多信息，请参阅： 库属性帮助页面 使用库构建块 以下指令以示例说明如何使用计数器块 CTUD 从图书馆 Standard 插入你的程序。 在编辑器中打开一个 POU 并将光标放在声明部分。 输入功能块实例的名称，后跟冒号（例如 iCounter1: ）。 打开用 F2 输入帮助。 在类别中选择 结构化类型 功能块 CTUD 从图书馆 Standard （计数器子文件夹）。 激活选项 粘贴命名空间前缀 . 关闭对话框 行 . 功能块被插入到带有命名空间前缀的声明部分： iCounter1:Standard.CTUD . 有关更多信息，请参阅： 使用库" }, 
{ "title" : "集成 C 模块 ", 
"url" : "_cds_integrating_c_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 集成 C 模块 ", 
"snippet" : "随着 CODESYS C代码集成，用C开发的模块可以作为一个库集成到一个 CODESYS 项目。该模块与在其中实现的 IEC 接口一起作为动态运行时模块存储在库中。此外，用于不同目标系统的模块的多个变体可以存储在库中。 该库像任何其他 IEC 61131-3 库一样显示给用户。当库在应用程序中使用时，则 CODESYS 自动从库中下载合适的模块到控制器并从 CODESYS Control 运行时系统。 应用实例： 重用现有的 C 代码 集成由建模工具生成的代码，例如 Matlab®\/Simulink® 动态集成以 C 代码创建的特定于设备的功能 在下载过程中，应用程序的所有动态模块都被传输并加...", 
"body" : "随着 CODESYS C代码集成，用C开发的模块可以作为一个库集成到一个 CODESYS 项目。该模块与在其中实现的 IEC 接口一起作为动态运行时模块存储在库中。此外，用于不同目标系统的模块的多个变体可以存储在库中。 该库像任何其他 IEC 61131-3 库一样显示给用户。当库在应用程序中使用时，则 CODESYS 自动从库中下载合适的模块到控制器并从 CODESYS Control 运行时系统。 应用实例： 重用现有的 C 代码 集成由建模工具生成的代码，例如 Matlab®\/Simulink® 动态集成以 C 代码创建的特定于设备的功能 在下载过程中，应用程序的所有动态模块都被传输并加载到运行时系统。为此，运行时系统必须支持动态链接。 运行时系统许可证 运行时系统需要一个允许加载 C 模块的许可证。没有此许可证，下载过程中无法链接动态模块，因此下载将中止。 动态模块是引导应用程序的一部分，它们会在控制器重新启动时重新加载并激活。这 重置原点 命令卸载应用程序中的所有 C 代码模块。这 重置冷 和 重置暖 命令不会导致 C 代码模块的重复初始化。 CODESYS 不支持监控C代码文件中的变量，不支持在C源代码中设置断点。 将预编译的运行时模块分配给设备并将它们保存在库中 要求：图书馆（ *.library ) 开于 CODESYS . 点击 查看 → POU . 这 计划书 view 打开并显示库项目及其对象。 选择库项目并单击 项目 → 添加对象 → C 实现的库 . 点击 添加 在里面 添加 C 实现的库 对话。 CODESYS 添加对象 C 实现的库 在视图中 POU 一。 双击对象 C 实现的库 . 对象在其编辑器中打开 点击 添加 在这个编辑器中。 这 选择设备 对话框打开。 在里面 目标文件 输入字段，以格式指定动态可加载模块的名称 *.dll 或者 *.so . 这 *.dll 文件必须在其名称中包含库项目的标题。示例：如果库项目名为 XYlib , 那么 目标文件 必须命名为： <name>_XYlib.dll 在里面 设备 窗口中，选择一个设备的分配 目标文件 . 点击 选择设备 . CODESYS 在编辑器中显示创建的设备文件分配 编译组件 标签。 保存库项目。 有关详细信息，请参阅： C 实现的库" }, 
{ "title" : "以编程方式访问 I\/O ", 
"url" : "_cds_f_assigning_ios.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 以编程方式访问 I\/O ", 
"snippet" : "CODESYS 提供以下用于将项目变量映射到输入、输出和内存地址的功能： 在选项卡中将项目变量分配给输入、输出和内存地址 I\/O 映射 设备编辑 以编程方式访问 I\/O 可变配置 AT声明 我们建议您将项目变量映射到选项卡中的输入、输出和内存地址 I\/O 映射 相应设备的编辑器。...", 
"body" : "CODESYS 提供以下用于将项目变量映射到输入、输出和内存地址的功能： 在选项卡中将项目变量分配给输入、输出和内存地址 I\/O 映射 设备编辑 以编程方式访问 I\/O 可变配置 AT声明 我们建议您将项目变量映射到选项卡中的输入、输出和内存地址 I\/O 映射 相应设备的编辑器。 " }, 
{ "title" : "变量配置 - VAR_CONFIG ", 
"url" : "_cds_variables_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 以编程方式访问 I\/O \/ 变量配置 - VAR_CONFIG ", 
"snippet" : "使用“变量组态”将变量从功能块映射到过程映像。在功能块中声明时，将变量分配给设备的输入\/输出，而无需指定完整地址。稍后在全局变量列表中为应用程序的所有功能块实例集中指定确切地址 VAR_CONFIG -声明。这个全局变量列表与 VAR_CONFIG 声明称为变量配置。 显示直接分配给 I\/O 地址的变量的变化 CODESYS 直接在过程映像中。显示通过变量配置映射的变量的变化 CODESYS 仅在相关任务结束时。 在功能块中声明变量 在功能块中声明变量时，声明关键字之间的变量 VAR 和 END_VAR .这样做时，您将不完整的地址分配给变量。用一个标记这些不完整的地址 * . 句法： <Be...", 
"body" : "使用“变量组态”将变量从功能块映射到过程映像。在功能块中声明时，将变量分配给设备的输入\/输出，而无需指定完整地址。稍后在全局变量列表中为应用程序的所有功能块实例集中指定确切地址 VAR_CONFIG -声明。这个全局变量列表与 VAR_CONFIG 声明称为变量配置。 显示直接分配给 I\/O 地址的变量的变化 CODESYS 直接在过程映像中。显示通过变量配置映射的变量的变化 CODESYS 仅在相关任务结束时。 在功能块中声明变量 在功能块中声明变量时，声明关键字之间的变量 VAR 和 END_VAR .这样做时，您将不完整的地址分配给变量。用一个标记这些不完整的地址 * . 句法： <Bezeichner> AT %<I\\|Q>*:<Datentyp>; 例子 定义了 2 个本地 I\/O 变量：输入变量 xLocIn 和输出变量 xLocOut . FUNCTION_BLOCK locio\nVAR\n xLocIn AT %I*: BOOL := TRUE;\n xLocOut AT %Q*: BOOL;\nEND_VAR 地址最终在全局变量列表中的变量配置中定义。 在用作变量配置的全局变量列表中，输入变量的声明以及关键字之间的确切地址 VAR_CONFIG 和 END_VAR 一。 这 VAR_CONFIG - 必须使用完整的实例路径指定变量，每个 POU 和实例名称用句点分隔。声明必须包含一个地址，其类别（输入\/输出）与功能块中未完全指定的地址（%I*、%Q*）的类别相匹配。数据类型也必须匹配。 句法： <instance variable path> AT %<I\\|Q><location>: <data type>; 如果路径的实例不存在，则会出现错误消息。 CODESYS 如果您使用不完整地址声明的变量没有地址配置，也会引发错误。 例子 下面使用功能模块 locio 上面的例子是在一个程序中： PROGRAM PLC_PRG\nVAR\n locioVar1: locio;\n locioVar2: locio;\nEND_VAR 全局变量列表中的正确变量配置将如下所示，例如： VAR_CONFIG\n PLC_PRG.locioVar1.xLocIn AT %IX1.0 : BOOL;\n PLC_PRG.locioVar1.xLocOut AT %QX0.0 : BOOL;\n PLC_PRG.locioVar2.xLocIn AT %IX1.0 : BOOL;\n PLC_PRG.locioVar2.xLocOut AT %QX0.3 : BOOL;\nEND_VAR " }, 
{ "title" : "创建变量配置 ", 
"url" : "_cds_variables_configuration.html#UUID-6adb8712-3824-d906-67c2-beabb384488e_section-idm4501210518364832656274674828", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 以编程方式访问 I\/O \/ 变量配置 - VAR_CONFIG \/ 创建变量配置 ", 
"snippet" : "要求：您已打开一个项目，该项目具有带有现场设备的控制器配置。该项目包含一个程序，例如 PLC_PRG 和一个功能块，例如 func1 .现场设备具有输入和输出。在声明编辑器的选项中选择文本视图。 将变量分配给功能块中地址不完整的设备 I\/O，然后创建变量配置。 在设备树中，双击功能块，例如 func1 . 块编辑器打开。 在声明部分，在关键字之间键入 VAR 和 END_VAR 一： xLocIn AT %I*: BOOL := TRUE; 到下一行 XLocOut AT %Q*:BOOL; 你有一个输入变量 xLocIn 声明和这个到不完整的输入地址 %I* 分配给现场设备。声明的输出变量的...", 
"body" : "要求：您已打开一个项目，该项目具有带有现场设备的控制器配置。该项目包含一个程序，例如 PLC_PRG 和一个功能块，例如 func1 .现场设备具有输入和输出。在声明编辑器的选项中选择文本视图。 将变量分配给功能块中地址不完整的设备 I\/O，然后创建变量配置。 在设备树中，双击功能块，例如 func1 . 块编辑器打开。 在声明部分，在关键字之间键入 VAR 和 END_VAR 一： xLocIn AT %I*: BOOL := TRUE; 到下一行 XLocOut AT %Q*:BOOL; 你有一个输入变量 xLocIn 声明和这个到不完整的输入地址 %I* 分配给现场设备。声明的输出变量的输出地址不完整 %Q* 分配的。 点击对象 PLC_PRG 在设备树中并插入程序的声明部分 VAR 和 END_VAR 例如，输入以下声明： locioVar1: func; locioVar2: func; 选择对象 应用 在设备树中，选择上下文菜单命令 添加对象 → 全局变量列表 并在对话框中单击 添加全局变量列表 在按钮上 添加 . 全局变量列表被添加到设备树并打开其编辑器。 更改关键字 VAR_GLOBAL 在 VAR_CONFIG 大约。 选择命令 声明 → 添加所有实例路径 . 添加了以下实例路径： PLC_PRG.logioVar1.xLocIn AT %I*;\nPLC_PRG.logioVar2.xLocIN AT %I*;\nPLC_PRG.logioVar1.xLocOut AT %Q*;\nPLC_PRG.logioVar2.xLocOut AT %Q*; 现在替换不完整的地址详细信息 %I* 和 %Q* 带有确切的完整地址。 " }, 
{ "title" : "AT声明 ", 
"url" : "_cds_at_declaration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 以编程方式访问 I\/O \/ AT声明 ", 
"snippet" : "使用清晰的配置编辑器进行 I\/O 映射 我们建议不要按此处所述分配内存地址，因为这可能会导致清晰度降低。 我们建议在配置编辑器中为变量分配内存地址 编辑 I\/O 映像 设备的。 这个 AT 变量声明中的关键字为项目变量分配设备树中配置的控制器的特定输入地址、输出地址或内存地址。 AT 声明可以为地址指定一个有意义的名称。您只能在一处对传入或传出信号进行任何必要的更改，例如在声明中。 您只可以在一个位置（例如，在声明中）对输入或输出信号进行任何必要的更改。 有关更多信息，请参阅： 地址变量声明变量配置 - VAR_CONFIG添加所有实例路径ADR, REFERENCE TO, VAR_IN_O...", 
"body" : "使用清晰的配置编辑器进行 I\/O 映射 我们建议不要按此处所述分配内存地址，因为这可能会导致清晰度降低。 我们建议在配置编辑器中为变量分配内存地址 编辑 I\/O 映像 设备的。 这个 AT 变量声明中的关键字为项目变量分配设备树中配置的控制器的特定输入地址、输出地址或内存地址。 AT 声明可以为地址指定一个有意义的名称。您只能在一处对传入或传出信号进行任何必要的更改，例如在声明中。 您只可以在一个位置（例如，在声明中）对输入或输出信号进行任何必要的更改。 有关更多信息，请参阅： 地址变量声明变量配置 - VAR_CONFIG添加所有实例路径ADR, REFERENCE TO, VAR_IN_OUT" }, 
{ "title" : "语法 ", 
"url" : "_cds_at_declaration.html#UUID-bb5c2ea2-9f57-c62c-fc21-e0a94e35bcb0_section-idm234773736203646", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 以编程方式访问 I\/O \/ AT声明 \/ 语法 ", 
"snippet" : "<变量名> AT % <地址> : <数据类型> ; <变量名> 必填项 % <地址> 必填项 存储区中的地址 % <内存区域编号> <大小前缀> <内存位置> <内存区域前缀> 必填项 I : 输入存储区域 用于存储输入信号和输入的存储区域 用于通过输入驱动器和传感器进行物理输入 Q : 输出存储区域 输出信号和输出的存储区域 通过输出驱动器和执行器进行物理输出 M : 标记存储区域 <大小前缀> 可选 没有大小前缀：位 单位 X : 位 单位 B : 字节 8 位数据宽度 W : 单词 16 位数据宽度 D : Dword 32 位数据宽度 <内存位置> <位置编号 > . <位位置编号>...", 
"body" : "<变量名> AT % <地址> : <数据类型> ; <变量名> 必填项 % <地址> 必填项 存储区中的地址 % <内存区域编号> <大小前缀> <内存位置> <内存区域前缀> 必填项 I : 输入存储区域 用于存储输入信号和输入的存储区域 用于通过输入驱动器和传感器进行物理输入 Q : 输出存储区域 输出信号和输出的存储区域 通过输出驱动器和执行器进行物理输出 M : 标记存储区域 <大小前缀> 可选 没有大小前缀：位 单位 X : 位 单位 B : 字节 8 位数据宽度 W : 单词 16 位数据宽度 D : Dword 32 位数据宽度 <内存位置> <位置编号 > . <位位置编号> 示例： %IB2.4 代表第 3 字节的第 5 位 <位置编号> 必填项 编号取决于目标系统，从 0 开始。 . <位位置编号> 可选 0..7 表示一个字节 <数据类型> 可选 数据类型应与大小前缀相匹配。 例子 VAR \n wInput AT %IW0 : WORD; \nEND_VAR 带有输入字地址规范的变量声明 VAR \n xActuator AT %QW0 : BOOL; \nEND_VAR 布尔变量声明 注意：如果未指定单位地址，则会在内部为布尔变量分配一个字节。值的变化 xActuator 因此影响面积 QX0.0 直到 QX0.7 . VAR\n xSensor AT %IX7.5 : BOOL; \nEND_VAR 明确指定单位地址的布尔变量声明 访问时，仅读取输入位 7.5。 VAR \n xSensor AT %IX* : BOOL; \nEND_VAR 指定地址时，使用占位符代替存放位置 * 指定的。最终地址指定在变量配置中进行。 注意：这在功能块中是可能的。 " }, 
{ "title" : "有用的提示 ", 
"url" : "_cds_at_declaration.html#UUID-bb5c2ea2-9f57-c62c-fc21-e0a94e35bcb0_section-idm234773751522904", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 以编程方式访问 I\/O \/ AT声明 \/ 有用的提示 ", 
"snippet" : "除非您明确指定一位地址，否则布尔变量是按字节分配的。 映射到布尔变量的单个位地址有限制。无法将这些变量与 VAR_IN_OUT ， REFERENCE TO ，或者 ADR 操作员。 将变量分配给地址时，必须考虑以下事项： 您不能写入分配给输入的变量。这会导致编译器错误。 你可以做 AT 声明仅适用于局部和全局变量，不适用于 POU 的输入和输出变量。 你一定不能使用 AT 永久变量列表中的声明。 如果你使用 AT 结构成员或函数块变量的声明，则所有实例使用相同的内存。这相当于在 “C” 等经典编程语言中使用 “静态变量”。 结构的内存布局也取决于目标系统。...", 
"body" : "除非您明确指定一位地址，否则布尔变量是按字节分配的。 映射到布尔变量的单个位地址有限制。无法将这些变量与 VAR_IN_OUT ， REFERENCE TO ，或者 ADR 操作员。 将变量分配给地址时，必须考虑以下事项： 您不能写入分配给输入的变量。这会导致编译器错误。 你可以做 AT 声明仅适用于局部和全局变量，不适用于 POU 的输入和输出变量。 你一定不能使用 AT 永久变量列表中的声明。 如果你使用 AT 结构成员或函数块变量的声明，则所有实例使用相同的内存。这相当于在 “C” 等经典编程语言中使用 “静态变量”。 结构的内存布局也取决于目标系统。 " }, 
{ "title" : "示例 ", 
"url" : "_cds_at_declaration.html#UUID-bb5c2ea2-9f57-c62c-fc21-e0a94e35bcb0_section-idm234773752144233", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 以编程方式访问 I\/O \/ AT声明 \/ 示例 ", 
"snippet" : "PROGRAM PLC_PRG VAR xVar AT %QW0 : BOOL; END_VAR xVar := TRUE; 写变量时 xVar 是的起始内存区域 QX0.0 直到 QX0.7 做作的。...", 
"body" : "PROGRAM PLC_PRG\nVAR\n xVar AT %QW0 : BOOL;\nEND_VAR\nxVar := TRUE; 写变量时 xVar 是的起始内存区域 QX0.0 直到 QX0.7 做作的。 " }, 
{ "title" : "检查语法并分析代码 ", 
"url" : "_cds_f_checking_syntax_and_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 检查语法并分析代码 ", 
"snippet" : "CODESYS 提供有用的功能来检测错误并帮助您创建程序。这 语法检查 早在编程阶段就标记错误并将其输出到消息视图。 这 静态代码分析 在 CODESYS 帮助您遵守其他编码准则并识别容易出错的结构。...", 
"body" : "CODESYS 提供有用的功能来检测错误并帮助您创建程序。这 语法检查 早在编程阶段就标记错误并将其输出到消息视图。 这 静态代码分析 在 CODESYS 帮助您遵守其他编码准则并识别容易出错的结构。 " }, 
{ "title" : "检查语法 ", 
"url" : "_cds_checking_syntax.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 检查语法并分析代码 \/ 检查语法 ", 
"snippet" : "当您键入代码时，预编译运行在 CODESYS 已经做了一些基本的检查。错误在编辑器中以红色圈出，并在消息视图中显示错误消息。 CODESYS 在将应用程序下载到控制器之前，自动从开发系统中编写的源代码生成应用程序代码。在生成应用程序代码之前，检查分配、数据类型和库的可用性。生成应用程序代码时也会分配内存地址。您也可以使用命令显式执行此操作 构建 → 生成代码 或使用按钮 F11 跑步。这允许您在源代码中找到可能的错误，即使控制器尚未连接。 CODESYS 在类别中的消息视图中给出所有错误和警告 翻译 出去。双击错误信息，在编辑器中打开受影响的 POU；故障点被标记。或者，您也可以使用错误消息的...", 
"body" : "当您键入代码时，预编译运行在 CODESYS 已经做了一些基本的检查。错误在编辑器中以红色圈出，并在消息视图中显示错误消息。 CODESYS 在将应用程序下载到控制器之前，自动从开发系统中编写的源代码生成应用程序代码。在生成应用程序代码之前，检查分配、数据类型和库的可用性。生成应用程序代码时也会分配内存地址。您也可以使用命令显式执行此操作 构建 → 生成代码 或使用按钮 F11 跑步。这允许您在源代码中找到可能的错误，即使控制器尚未连接。 CODESYS 在类别中的消息视图中给出所有错误和警告 翻译 出去。双击错误信息，在编辑器中打开受影响的 POU；故障点被标记。或者，您也可以使用错误消息的上下文菜单跳转到错误的位置。 另请注意 想法 在里面 CODESYS -选项。 " }, 
{ "title" : "静态分析代码 ", 
"url" : "_cds_using_static_analysis.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 检查语法并分析代码 \/ 静态分析代码 ", 
"snippet" : "您还可以在代码生成期间对源代码进行静态分析（“linten”）。它确定您的源代码是否遵循您设置的编码准则 - 沿着“lint”分析工具的行。 在对话中 项目设置 在类别下 静态分析灯 启用将被检查的规则。每次生成代码时，检查本身都会自动进行，例如当您运行命令时 构建 → 生成代码 选择。如果检测到与规则的偏差，则将其分类为该类别的错误消息 翻译 显示在消息窗口中。报告的错误有一个前缀： SA<Zahl> . 用于静态代码分析 静态分析灯 仅检查项目的应用程序代码。图书馆被排除在考试之外。 视图中 GVL 的变量 POU 不一定要检查：如果您的项目包含多个应用程序，则仅检查当前活动应用程序下的对...", 
"body" : "您还可以在代码生成期间对源代码进行静态分析（“linten”）。它确定您的源代码是否遵循您设置的编码准则 - 沿着“lint”分析工具的行。 在对话中 项目设置 在类别下 静态分析灯 启用将被检查的规则。每次生成代码时，检查本身都会自动进行，例如当您运行命令时 构建 → 生成代码 选择。如果检测到与规则的偏差，则将其分类为该类别的错误消息 翻译 显示在消息窗口中。报告的错误有一个前缀： SA<Zahl> . 用于静态代码分析 静态分析灯 仅检查项目的应用程序代码。图书馆被排除在考试之外。 视图中 GVL 的变量 POU 不一定要检查：如果您的项目包含多个应用程序，则仅检查当前活动应用程序下的对象。如果您只有一个应用程序，还会检查通用 POUs 池中的对象。 静态分析灯 仅包含在标准开发系统中的一组减少的规则中。安装附加组件时，可以使用一组扩展的规则、额外的命名约定和指标 CODESYS Static Analysis 安装。 " }, 
{ "title" : "从静态分析中排除带有编译指示的实现中的代码行 ", 
"url" : "_cds_using_static_analysis.html#UUID-588186d4-486d-aeee-8a39-77c869f6f9a5_id_fc5b65969af34c0a8640e00fb3e7b_id_07681190e3f611e7be4ba1d6d93507bc", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 检查语法并分析代码 \/ 静态分析代码 \/ 从静态分析中排除带有编译指示的实现中的代码行 ", 
"snippet" : "你可以在 pragma 的帮助下 {analysis ...} 标记代码以便不检查指定的规则。因此，以这种方式标记的代码行不会被静态分析。在测试期间，标记的代码将被忽略。 句法： {analysis <Vorzeichen><Regelnummer>|,<weitere Kombinationen von Vorzeichen und Regelnummern, kommasepariert>} -<Regelnummer> : 关闭规则 SA<rule number> 的检查。 +<Regelnummer> : 激活规则 SA<rule number> 的检查。 排除实现代码 要求：你有对话...", 
"body" : "你可以在 pragma 的帮助下 {analysis ...} 标记代码以便不检查指定的规则。因此，以这种方式标记的代码行不会被静态分析。在测试期间，标记的代码将被忽略。 句法： {analysis <Vorzeichen><Regelnummer>|,<weitere Kombinationen von Vorzeichen und Regelnummern, kommasepariert>} -<Regelnummer> : 关闭规则 SA<rule number> 的检查。 +<Regelnummer> : 激活规则 SA<rule number> 的检查。 排除实现代码 要求：你有对话框 项目设置 启用规则。 添加编译指示 {analysis -<number>} 在包含您第一次不想检查的代码的代码行上方。例如，对于规则 SA0024 代码行是代码片段的第一行，没有根据规则 24 进行检查。 添加编译指示 {analysis +<number>} 在包含第一次不检查的代码的代码行下方。 示例：对于规则 SA0024 上面的代码行是未根据规则 24 检查的代码片段的最后一行。 示例：忽略无类型文字 {analysis -24}\nnTest := 99;\niVar := INT#2;\n{analysis +24} 规则 SA0024：无类型文字 禁用 2 行。尽管代码未更正为： nTest := DINT#99; 示例：忽略多个规则 {analysis -10, -24, -18}\n...\n{analysis +10, +24, +18} SA0010：只有一个组件的数组 SA0018：异常位访问 SA0024：无类型文字 但是，您可以统治 SA0004 ： 对输出的多次写访问 不要通过编译指示禁用。 " }, 
{ "title" : "使用 pragma 从静态分析中排除编程对象 ", 
"url" : "_cds_using_static_analysis.html#UUID-588186d4-486d-aeee-8a39-77c869f6f9a5_id_fc5b65969af34c0a8640e00fb3e7b_id_0765044be3f611e7be4ba1d6d93507bc", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 检查语法并分析代码 \/ 静态分析代码 \/ 使用 pragma 从静态分析中排除编程对象 ", 
"snippet" : "句法： {attribute 'analysis' := '-<rule number>[,<other negative rule numbers, comma-separated>]'} 如果在编程对象的声明部分中包含属性 pragma，则整个编程对象的指定规则都将被排除。如果排除了多个规则，则这些规则必须用带减号和数字的逗号分隔。不需要用于开机的 pragma 语句。 例子 {attribute 'analysis' := '-33, -31'} TYPE LocalData : STRUCT iLocal : INT; uiLocal : UINT; udiLocal : UDINT;...", 
"body" : "句法： {attribute 'analysis' := '-<rule number>[,<other negative rule numbers, comma-separated>]'} 如果在编程对象的声明部分中包含属性 pragma，则整个编程对象的指定规则都将被排除。如果排除了多个规则，则这些规则必须用带减号和数字的逗号分隔。不需要用于开机的 pragma 语句。 例子 {attribute 'analysis' := '-33, -31'}\nTYPE LocalData :\nSTRUCT\n iLocal : INT;\n uiLocal : UINT;\n udiLocal : UDINT;\nEND_STRUCT\nEND_TYPE 结构中使用了规则 SA0033 和 SA0031 LocalData 忽略。 {attribute 'analysis' := '-100'}\nbig: ARRAY[1..10000] OF DWORD; 规则 SA0100 应用于阵列 big 忽略。 " }, 
{ "title" : "方向和导航 ", 
"url" : "_cds_f_orientating_navigating.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 方向和导航 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "使用交叉引用列表查找使用地点 ", 
"url" : "_cds_working_with_the_cross_reference_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 方向和导航 \/ 使用交叉引用列表查找使用地点 ", 
"snippet" : "您可以在所谓的“交叉引用列表”中显示使用符号的位置，即变量、POU（程序、功能块、功能）或 DUT。然后，您可以从列表中直接跳转到项目中的相应位置。 有两种类型的符号使用搜索： 纯文本搜索：在视图中输入 交叉引用列表 手动输入文本（符号名称、占位符）。 搜索具体声明： 你在视野中 交叉引用列表 并从输入帮助中选择声明。 重点是块编辑器中的符号名称，您可以通过上下文菜单命令启动交叉引用搜索。 焦点在符号名称中的块编辑器中，视图 交叉引用列表 是打开的，交叉引用搜索会自动完成。 你在视野中 交叉引用列表 ，它已经列出了多个声明的使用位置，并且您将这些结果限制为特定的声明。 具体符号声明的交叉引用 ...", 
"body" : "您可以在所谓的“交叉引用列表”中显示使用符号的位置，即变量、POU（程序、功能块、功能）或 DUT。然后，您可以从列表中直接跳转到项目中的相应位置。 有两种类型的符号使用搜索： 纯文本搜索：在视图中输入 交叉引用列表 手动输入文本（符号名称、占位符）。 搜索具体声明： 你在视野中 交叉引用列表 并从输入帮助中选择声明。 重点是块编辑器中的符号名称，您可以通过上下文菜单命令启动交叉引用搜索。 焦点在符号名称中的块编辑器中，视图 交叉引用列表 是打开的，交叉引用搜索会自动完成。 你在视野中 交叉引用列表 ，它已经列出了多个声明的使用位置，并且您将这些结果限制为特定的声明。 具体符号声明的交叉引用 要求：在编辑器中打开一个块。 从块编辑器，使用菜单命令 将光标放在声明或实现中的符号标识符（变量、块名称）上。 选择命令 查找符号 → 输出交叉引用 在上下文菜单或菜单中 编辑 . 风景 交叉引用列表 打开并显示变量或 POU 的使用位置。 如果视图 交叉引用列表 已经开通了，你也可以搜索一下具体的使用场所如下： 从块编辑器，自动 激活选项 更改选择时自动更新交叉引用 在 工具 → 选项 在类别中 智能编码 .然后在块的编辑器窗口中选择符号的名称或将光标放在名称上。 根据选择\/光标的位置，交叉引用列表会自动显示相应符号的使用位置。 在交叉引用列表视图中，输入帮助 在视图中输入 交叉引用列表 通过输入帮助 旁边的字段中的符号名称 申报后 一。 交叉引用列表显示了符号的使用位置。 在交叉引用列表视图中，限制为特定声明 当在视野中 交叉引用列表 如果为一个符号列出了多个声明，例如在文本搜索之后，您可以将显示减少到其中之一： 选择具有所需声明的行并单击按钮 或选择上下文菜单命令 将结果限制在当前声明范围内 . 交叉引用列表仅包含所选声明的使用地点。 " }, 
{ "title" : "通过文本搜索符号名称的交叉引用 ", 
"url" : "_cds_working_with_the_cross_reference_list.html#UUID-dc873ea4-cf05-2187-4fed-044a9516d887_id_a4b8449208f4c0a8640e01b561a2_id_23a4d649623b8717c0a86463442f97c6", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 方向和导航 \/ 使用交叉引用列表查找使用地点 \/ 通过文本搜索符号名称的交叉引用 ", 
"snippet" : "先决条件：视图 交叉引用列表 被打开。 在按名称旁边的字段中，输入一个字符串，例如要在项目中查找其使用位置的变量的标识符。 例子： ” iCounter \" 您可以使用通配符“ * \"（任意数量的字符）或 \" ? “（完全是任何字符）与变量标识符的子字符串组合。 利用 ” % ' 如果你想搜索 IEC 地址。 例子： ” %MW8 \", \" %M *” 点击按钮 在项目中开始文本搜索。 风景 交叉引用列表 打开并显示变量的使用位置 iCounter .项目中的声明点和使用点（在下方缩进）始终显示。 双击交叉引用列表中的使用地点。 在编辑器中打开相应的对象并标记使用点。...", 
"body" : "先决条件：视图 交叉引用列表 被打开。 在按名称旁边的字段中，输入一个字符串，例如要在项目中查找其使用位置的变量的标识符。 例子： ” iCounter \" 您可以使用通配符“ * \"（任意数量的字符）或 \" ? “（完全是任何字符）与变量标识符的子字符串组合。 利用 ” % ' 如果你想搜索 IEC 地址。 例子： ” %MW8 \", \" %M *” 点击按钮 在项目中开始文本搜索。 风景 交叉引用列表 打开并显示变量的使用位置 iCounter .项目中的声明点和使用点（在下方缩进）始终显示。 双击交叉引用列表中的使用地点。 在编辑器中打开相应的对象并标记使用点。 " }, 
{ "title" : "查找声明 ", 
"url" : "_cds_goto_definition.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 方向和导航 \/ 查找声明 ", 
"snippet" : "CODESYS 提供了在整个项目中搜索变量或函数的定义点的可能性。包含定义的块在编辑器中打开并标记声明。 查找变量的声明 要求：在编辑器中打开了一个 POU。 将光标放在实现中的标识符上。 选择命令 编辑→查找图标→ 转到定义 . 带有声明的 POU 在编辑器中打开并突出显示变量的定义。如果定义在“已翻译”库中，则在库管理器中打开相应的块。 您可以在离线和在线模式下使用该命令。 例子 以下块包含功能块定义 ( fbinst ), 程序调用 ( prog_y() ) 和函数模块调用 ( fbinst.out ): VAR fbinst:fb1; ivar:INT; END_VAR prog_y(...", 
"body" : "CODESYS 提供了在整个项目中搜索变量或函数的定义点的可能性。包含定义的块在编辑器中打开并标记声明。 查找变量的声明 要求：在编辑器中打开了一个 POU。 将光标放在实现中的标识符上。 选择命令 编辑→查找图标→ 转到定义 . 带有声明的 POU 在编辑器中打开并突出显示变量的定义。如果定义在“已翻译”库中，则在库管理器中打开相应的块。 您可以在离线和在线模式下使用该命令。 例子 以下块包含功能块定义 ( fbinst ), 程序调用 ( prog_y() ) 和函数模块调用 ( fbinst.out ): VAR\n fbinst:fb1;\n ivar:INT;\nEND_VAR\n\nprog_y();\nivar:=prog_y.y;\nres1:=fbinst.out; 当您将鼠标悬停在 prog_y 设置，命令打开程序 prog_y 在他的编辑器中。 当您将鼠标悬停在 fbinst 放置，该命令将焦点设置在行中的声明窗口 fbinst:fb1; 当您将鼠标悬停在 out 设置，命令打开功能块 fb1 在他的编辑器中。 " }, 
{ "title" : "设置和使用书签 ", 
"url" : "_cds_navigating_with_bookmarks.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 方向和导航 \/ 设置和使用书签 ", 
"snippet" : "您可以使用书签来更轻松地浏览长程序。书签可用于除 AS（顺序功能图）以外的所有编程语言编辑器。您可以使用命令直接导航到标记的程序位置。 跳转到项目不同 POU 的书签 具有多个 POU 的项目已打开。在不同的 POU 中设置了几个书签。 选择命令 查看 → 书签 . 风景 书签 打开。 项目的所有书签都在视图中以表格形式列出。 点击按钮 下一个书签 . 在视图中 书签 当前所选书签下方的行中的书签被选中。 带有新选择的表书签的 POU 在编辑器中打开，带有书签的行在 POU 中被选中。 第 2 步，您可以相应地使用按钮 上一个书签 跳转到视图中项目的书签 书签 显示在上面的行中。...", 
"body" : "您可以使用书签来更轻松地浏览长程序。书签可用于除 AS（顺序功能图）以外的所有编程语言编辑器。您可以使用命令直接导航到标记的程序位置。 跳转到项目不同 POU 的书签 具有多个 POU 的项目已打开。在不同的 POU 中设置了几个书签。 选择命令 查看 → 书签 . 风景 书签 打开。 项目的所有书签都在视图中以表格形式列出。 点击按钮 下一个书签 . 在视图中 书签 当前所选书签下方的行中的书签被选中。 带有新选择的表书签的 POU 在编辑器中打开，带有书签的行在 POU 中被选中。 第 2 步，您可以相应地使用按钮 上一个书签 跳转到视图中项目的书签 书签 显示在上面的行中。 " }, 
{ "title" : "设置\/删除书签 ", 
"url" : "_cds_navigating_with_bookmarks.html#UUID-0202ce58-db18-3a3e-3f81-14fcd1a390a5_id_d6f70c1e435e81b4c0a8640e0052ef4f_id_8490bbe5442daf0ac0a8640e00d30cae", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 方向和导航 \/ 设置和使用书签 \/ 设置\/删除书签 ", 
"snippet" : "要求： POU 在编辑器中打开。 将光标放在任何程序行上。 选择命令 编辑 → 书签 → 打开\/关闭书签 . 在程序中此时设置了一个书签。这由书签图标指示 标记。 在程序的不同位置设置多个书签。 将光标放在带有书签的程序行上。 选择命令 编辑→书签→切换书签 . 书签再次被删除。书签图标 将被删除。 或者，您可以在视图中 书签 一个或多个书签通过按钮 清除。为此，相应的书签必须在视图中 书签 被选中。 选择命令 编辑→书签→清除所有书签（活动编辑器） 删除活动 POU 的所有书签。 要从项目中删除所有书签，请选择命令 删除所有书签 .但是，您必须首先通过命令使用此命令 工具 → 自定义 将其粘...", 
"body" : "要求： POU 在编辑器中打开。 将光标放在任何程序行上。 选择命令 编辑 → 书签 → 打开\/关闭书签 . 在程序中此时设置了一个书签。这由书签图标指示 标记。 在程序的不同位置设置多个书签。 将光标放在带有书签的程序行上。 选择命令 编辑→书签→切换书签 . 书签再次被删除。书签图标 将被删除。 或者，您可以在视图中 书签 一个或多个书签通过按钮 清除。为此，相应的书签必须在视图中 书签 被选中。 选择命令 编辑→书签→清除所有书签（活动编辑器） 删除活动 POU 的所有书签。 要从项目中删除所有书签，请选择命令 删除所有书签 .但是，您必须首先通过命令使用此命令 工具 → 自定义 将其粘贴到菜单中以使其可用。 " }, 
{ "title" : "跳转到 POU 中的书签 ", 
"url" : "_cds_navigating_with_bookmarks.html#UUID-0202ce58-db18-3a3e-3f81-14fcd1a390a5_id_d6f70c1e435e81b4c0a8640e0052ef4f_id_d7337afc868e9a56c0a8646360d42081", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 方向和导航 \/ 设置和使用书签 \/ 跳转到 POU 中的书签 ", 
"snippet" : "要求： POU 在编辑器中打开。设置了几个书签。 选择命令 编辑 → 书签 → 下一个书签（活动编辑器） . 根据当前光标位置，光标跳转到下一个书签（向下）。 选择命令 编辑→书签→上一个书签（活动编辑器） . 根据当前光标位置，光标跳转到上一个书签（向上）。...", 
"body" : "要求： POU 在编辑器中打开。设置了几个书签。 选择命令 编辑 → 书签 → 下一个书签（活动编辑器） . 根据当前光标位置，光标跳转到下一个书签（向下）。 选择命令 编辑→书签→上一个书签（活动编辑器） . 根据当前光标位置，光标跳转到上一个书签（向上）。 " }, 
{ "title" : "项目范围内的搜索和替换 ", 
"url" : "_cds_searching_for_strings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 项目范围内的搜索和替换 ", 
"snippet" : "在 Basic Level 您可以在单个对象或整个项目中搜索字符串，如果需要，可以用另一个字符串替换它们。 在菜单中激活 编辑→查找替换 命令 搜索 . 对话框打开 搜索 . 在框中输入 搜索 输入要搜索的字符串。 选择搜索选项。 放入选择列表 搜索 确定要在哪些对象中执行搜索。 点击按钮 继续寻找 . 显示第一个命中。 点击按钮 代替 , 如果你想用另一个替换搜索词。 点击 搜索所有人 ，如果您想了解所有匹配项的概览。...", 
"body" : "在 Basic Level 您可以在单个对象或整个项目中搜索字符串，如果需要，可以用另一个字符串替换它们。 在菜单中激活 编辑→查找替换 命令 搜索 . 对话框打开 搜索 . 在框中输入 搜索 输入要搜索的字符串。 选择搜索选项。 放入选择列表 搜索 确定要在哪些对象中执行搜索。 点击按钮 继续寻找 . 显示第一个命中。 点击按钮 代替 , 如果你想用另一个替换搜索词。 点击 搜索所有人 ，如果您想了解所有匹配项的概览。 " }, 
{ "title" : "重构 ", 
"url" : "_cds_refactoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 重构 ", 
"snippet" : "一般来说，重构是一种在不改变其行为的情况下改进已编写软件的设计的方法。 重构 CODESYS 提供重命名对象和变量名称以及更新块 I\/O 的功能。您可以显示使用重命名对象和变量的所有位置，然后将它们作为一个整体重命名或单独选择。此外，您可以 工具 → 选项 配置是否以及在哪些点 CODESYS 自动提示您重构。...", 
"body" : "一般来说，重构是一种在不改变其行为的情况下改进已编写软件的设计的方法。 重构 CODESYS 提供重命名对象和变量名称以及更新块 I\/O 的功能。您可以显示使用重命名对象和变量的所有位置，然后将它们作为一个整体重命名或单独选择。此外，您可以 工具 → 选项 配置是否以及在哪些点 CODESYS 自动提示您重构。 " }, 
{ "title" : "重命名全局变量 ", 
"url" : "_cds_refactoring.html#UUID-3adbd988-b291-6a98-0f3c-4708bc43fe33_id_adee5e3a92356c0a8640e0027b4e2_id_9f3bc4e7ebcfe0c6c0a8640e00160c38", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 重构 \/ 重命名全局变量 ", 
"snippet" : "要求：您已经打开了一个包含至少一个功能块的项目 脸书 和一个全局变量列表。全局变量列表 GVL 在其编辑器中打开并包含变量的声明，例如 iGlobal . 脸书 用过的 iGlobal . 在项目范围内重命名全局变量 选择全局变量的名称，例如 iGlobal . 在上下文菜单中选择命令 重构 → 重命名 iGlobal . 进入对话 改名 进入输入字段 新名字 输入新名称，例如 iGlobalOK 并点击 行 . 对话 重构 打开。在左侧窗口中，在设备树中，是对象 GVL 和 脸书 标记为红色并以黄色突出显示。在右侧窗口中是 脸书 在其编辑器中打开并 iGlobal 已经在 iGlobalOK...", 
"body" : "要求：您已经打开了一个包含至少一个功能块的项目 脸书 和一个全局变量列表。全局变量列表 GVL 在其编辑器中打开并包含变量的声明，例如 iGlobal . 脸书 用过的 iGlobal . 在项目范围内重命名全局变量 选择全局变量的名称，例如 iGlobal . 在上下文菜单中选择命令 重构 → 重命名 iGlobal . 进入对话 改名 进入输入字段 新名字 输入新名称，例如 iGlobalOK 并点击 行 . 对话 重构 打开。在左侧窗口中，在设备树中，是对象 GVL 和 脸书 标记为红色并以黄色突出显示。在右侧窗口中是 脸书 在其编辑器中打开并 iGlobal 已经在 iGlobalOK 重命名。 点击 行 . 您的项目中没有全局变量 iGlobal .现在到处都是 iGlobalOK . 在项目范围内重命名全局变量（POU 除外） 选择全局变量的名称，例如 iGlobal . 在上下文菜单中选择命令 重构 → 重命名 iGlobal . 进入对话 改名 进入输入字段 新名字 输入新名称，例如 iGlobalTest 并点击 行 . 对话 重构 打开。在左侧窗口中，在设备树中，是对象 GVL 和 脸书 标记为红色并以黄色突出显示。功能模块在右侧窗口 脸书 在其编辑器中打开。代替 iGlobal 是 iGlobalTest 列出。 将光标定位在右侧窗口中并打开上下文菜单。 选择命令 丢弃此对象 并点击 行 . 在您的项目中是全局变量 iGlobal 在 脸书 展示。变量现在位于变量发生的对象中 iGlobalTest 指定的。 错误消息出现在标识符的消息窗口中 iGlobal 没有定义。 " }, 
{ "title" : "添加和删除输入变量 ", 
"url" : "_cds_refactoring.html#UUID-3adbd988-b291-6a98-0f3c-4708bc43fe33_id_adee5e3a92356c0a8640e0027b4e2_id_f328830b85d9e6dcc0a8640e0146b3c8", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 重构 \/ 添加和删除输入变量 ", 
"snippet" : "您可以使用重构命令在 POU 的声明部分添加或删除输入或输出变量。在块的使用点\/调用点更新 CODESYS 因此，您可以接受或拒绝每个使用点。你得到这个对话框 重构 . 要求：你有 POU FCT 在编辑器中打开的函数类型。该函数已经有输入变量 input1 和 input2 和 inputx .她将参加节目 PLC_PRG 和 POU 叫。 把重点放在FCT函数的声明部分。 选择命令 重构 → 添加变量 . 用于声明变量的标准对话框出现。 声明变量 input_3 有范围 VAR_INPUT 和数据类型 INT .关闭对话框 行 . 对话 重构 出现（见下图）。受影响的区域用黄色标记。 (1...", 
"body" : "您可以使用重构命令在 POU 的声明部分添加或删除输入或输出变量。在块的使用点\/调用点更新 CODESYS 因此，您可以接受或拒绝每个使用点。你得到这个对话框 重构 . 要求：你有 POU FCT 在编辑器中打开的函数类型。该函数已经有输入变量 input1 和 input2 和 inputx .她将参加节目 PLC_PRG 和 POU 叫。 把重点放在FCT函数的声明部分。 选择命令 重构 → 添加变量 . 用于声明变量的标准对话框出现。 声明变量 input_3 有范围 VAR_INPUT 和数据类型 INT .关闭对话框 行 . 对话 重构 出现（见下图）。受影响的区域用黄色标记。 (1)+(2) 选择右上角的选项 使用占位符文本添加输入 . (3) 在左侧窗口中，将光标放在具有黄色背景的对象之一上，例如 PLC_PRG .在上下文菜单中选择命令 接受整个项目 将新变量添加到 FCT 在整个项目中添加。 在右侧窗口中可以看到实现部分的变化 PLC_PRG : 占位符 _REFACTOR_ 出现在插入新变量的位置。 关闭对话框 重构 和 行 . 选择命令 编辑 → 查找 .在项目中搜索“_REFACTOR_”以查看受影响的位置并进行相应的编辑。 注意：或者，您可以直接使用所需的初始化值插入新变量，而无需先使用占位符。在这种情况下，请在步骤 4 中选择选项“:.add with the following value”并在其右侧输入值。 CFC 块中具有占位符文本的新变量示例 还要注意通过重构删除变量的能力。 " }, 
{ "title" : "重新排序声明中的变量 ", 
"url" : "_cds_refactoring.html#UUID-3adbd988-b291-6a98-0f3c-4708bc43fe33_id_adee5e3a92356c0a8640e0027b4e2_id_ad60738bbfd811e7ad23a43badec1aad", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 重构 \/ 重新排序声明中的变量 ", 
"snippet" : "在块的声明部分，您可以使用重构来改变声明的顺序。这可以通过范围声明来实现 VAR_INPUT , VAR_OUTPUT 或者 VAR_IN_OUT . 要求：您已打开 POU 的声明部分，其中包含以下声明，例如： VAR_INPUT invar2 : INT; invar1 : INT; in : DUT; bvar : BOOL; invar3 : INT; END_VAR 将光标放在此声明块中，然后按鼠标右键打开上下文菜单。 选择命令 重构 → 重新排序变量 . 对话 改编 出现一个列表 VAR_INPUT -变量。 例如，选择条目 invar1：INT； 并用鼠标将其拖到条目前面 因瓦2...", 
"body" : "在块的声明部分，您可以使用重构来改变声明的顺序。这可以通过范围声明来实现 VAR_INPUT , VAR_OUTPUT 或者 VAR_IN_OUT . 要求：您已打开 POU 的声明部分，其中包含以下声明，例如： VAR_INPUT\n invar2 : INT;\n invar1 : INT;\n in : DUT;\n bvar : BOOL;\n invar3 : INT;\nEND_VAR 将光标放在此声明块中，然后按鼠标右键打开上下文菜单。 选择命令 重构 → 重新排序变量 . 对话 改编 出现一个列表 VAR_INPUT -变量。 例如，选择条目 invar1：INT； 并用鼠标将其拖到条目前面 因瓦2。 . 的声明 invar1 现在是重中之重。 关闭对话框 行 . 对话 重构 出现。受影响的区域用黄色标记。 （见上图） 确认 行 将新订单应用于区块。 " }, 
{ "title" : "更改变量声明并自动应用重构 ", 
"url" : "_cds_refactoring.html#UUID-3adbd988-b291-6a98-0f3c-4708bc43fe33_id_adee5e3a92356c0a8640e0027b4e2_id_86f1778c7d5106b7c0a8646345d4e9bf", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 重构 \/ 更改变量声明并自动应用重构 ", 
"snippet" : "重命名变量（使用自动声明）时，可以通过在声明中重构来支持您。 需求：功能模块 fb_A . 选择命令 工具 → 选项 . 对话 选项 打开。 选择类别 重构 . 在下方激活 自动申报 选项 重命名变量时 和 用于添加或删除变量，或用于更改命名空间 . 双击功能模块 fb_A . 在声明中选择 fb_A 例如一个变量 iA .或者，您可以将光标放在变量前面或变量中。 给 编辑 → 声明变量 一 （ 切换 + F2 ）。 对话 声明变量 打开。该对话框包含以下设置 iA . 更改名称 iA 后 iCounter_A . 选项 使用重构进行更改 出现并被激活。 点击 行 . 对话 重构 将 iA 重...", 
"body" : "重命名变量（使用自动声明）时，可以通过在声明中重构来支持您。 需求：功能模块 fb_A . 选择命令 工具 → 选项 . 对话 选项 打开。 选择类别 重构 . 在下方激活 自动申报 选项 重命名变量时 和 用于添加或删除变量，或用于更改命名空间 . 双击功能模块 fb_A . 在声明中选择 fb_A 例如一个变量 iA .或者，您可以将光标放在变量前面或变量中。 给 编辑 → 声明变量 一 （ 切换 + F2 ）。 对话 声明变量 打开。该对话框包含以下设置 iA . 更改名称 iA 后 iCounter_A . 选项 使用重构进行更改 出现并被激活。 点击 行 . 对话 重构 将 iA 重命名为 iCounterA 打开。受变量重命名影响的所有位置都标记在那里。 结束对话 行 . 更改被接受。 " }, 
{ "title" : "任务配置 ", 
"url" : "_cds_f_task_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 ", 
"snippet" : "在任务配置中，您可以定义一个或多个任务来控制程序 (POU) 对象的流 程式 键入）以及在您的设备上从他们那里调用的 POU。 任务配置 每个应用程序都需要对象。在这里，您可以定义调用程序的时间顺序 任务是您的 IEC 程序按时间顺序排列的流程单位。该任务定义了您的 POU（呼叫层次结构）的调用链 每项任务都需要一个唯一的名称。在任务配置编辑器中，指定要调用的程序列表。这些程序可以是特定于应用程序的，在这种情况下，该程序位于 设备 观点。或者一个程序可以在整个项目中都有效，在这种情况下，该程序位于 POU 观点。这些 POU 在整个项目中进行了实例化。 可以确定任务的优先顺序。优先级与任务类型...", 
"body" : "在任务配置中，您可以定义一个或多个任务来控制程序 (POU) 对象的流 程式 键入）以及在您的设备上从他们那里调用的 POU。 任务配置 每个应用程序都需要对象。在这里，您可以定义调用程序的时间顺序 任务是您的 IEC 程序按时间顺序排列的流程单位。该任务定义了您的 POU（呼叫层次结构）的调用链 每项任务都需要一个唯一的名称。在任务配置编辑器中，指定要调用的程序列表。这些程序可以是特定于应用程序的，在这种情况下，该程序位于 设备 观点。或者一个程序可以在整个项目中都有效，在这种情况下，该程序位于 POU 观点。这些 POU 在整个项目中进行了实例化。 可以确定任务的优先顺序。优先级与任务类型结合使用 您可以配置任务类型： 循环；用于使用循环间隔的时间控制流量。程序调用在周期间隔（任务周期时间）内运行。 随心所欲；适用于没有自己的任务周期的任务 通过事件启动条件（边缘触发）触发事件（内部或外部）。 事件的示例包括全局项目变量的上升趋势或中断。 通过条件触发状态 可以直接将 “启动”、“停止” 和 “重置” 与 POU 项目的执行相结合。 你也可以激活看门狗。 调用堆栈是根据任务配置中的这些设置创建和执行的。 根据各种可能的调用堆栈，可以确定其中哪个最长，内存要求最高（最大调用堆栈）。有关这方面的详细信息，请参阅 堆栈使用情况 选项卡。 " }, 
{ "title" : "规则 ", 
"url" : "_cds_f_task_configuration.html#UUID-36274da0-33e1-95eb-0678-9986502699b8_section-idm234764921910388", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 \/ 规则 ", 
"snippet" : "配置任务的处理顺序规则 当任务条件满足时，任务将启动并处理。 如果多个任务同时满足处理条件，则优先级最高的任务将首先处理。 如果具有相同优先级的多个任务同时满足处理条件，则将首先处理队列中时间最长的任务。 程序调用按照它们在任务配置对话框中出现的顺序进行处理。 如果由于应用程序的设备树、库或 POU 视图中的整个项目中存在同名程序而导致程序调用不是唯一的，则使用应用程序对象下方的程序。 有关更多信息，请参阅： 总线循环任务...", 
"body" : "配置任务的处理顺序规则 当任务条件满足时，任务将启动并处理。 如果多个任务同时满足处理条件，则优先级最高的任务将首先处理。 如果具有相同优先级的多个任务同时满足处理条件，则将首先处理队列中时间最长的任务。 程序调用按照它们在任务配置对话框中出现的顺序进行处理。 如果由于应用程序的设备树、库或 POU 视图中的整个项目中存在同名程序而导致程序调用不是唯一的，则使用应用程序对象下方的程序。 有关更多信息，请参阅： 总线循环任务" }, 
{ "title" : "有用的提示 ", 
"url" : "_cds_interesting_facts_task_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 \/ 有用的提示 ", 
"snippet" : "所有任务共享一个流程映像。 其原因是每项任务使用单独的流程映像会影响性能。 此外，流程映像只能在一项任务中保持一致。这样可以避免所有任务共享一个流程映像时出现不一致的情况 当你开发项目时，你需要确保输入数据 ( VAR_INPUT ) 将在发生冲突时复制到安全位置。这也适用于输出数据 ( VAR_OUTPUT ）。 POU，例如 SysSem 库，提供解决一致性和同步问题的能力。访问其他全局对象（全局变量或 POU）时也会出现一致性问题。当对一个变量进行多次读取和写入时，始终会出现一致性问题。的 POU SysSem 图书馆还可以帮助解决这类冲突。 有关更多信息，请参阅： 库文档 对于 Sys...", 
"body" : "所有任务共享一个流程映像。 其原因是每项任务使用单独的流程映像会影响性能。 此外，流程映像只能在一项任务中保持一致。这样可以避免所有任务共享一个流程映像时出现不一致的情况 当你开发项目时，你需要确保输入数据 ( VAR_INPUT ) 将在发生冲突时复制到安全位置。这也适用于输出数据 ( VAR_OUTPUT ）。 POU，例如 SysSem 库，提供解决一致性和同步问题的能力。访问其他全局对象（全局变量或 POU）时也会出现一致性问题。当对一个变量进行多次读取和写入时，始终会出现一致性问题。的 POU SysSem 图书馆还可以帮助解决这类冲突。 有关更多信息，请参阅： 库文档 对于 SysSem " }, 
{ "title" : "配置任务 ", 
"url" : "_cds_creating_task_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 \/ 配置任务 ", 
"snippet" : "你可以在下面更改任务的设置 任务配置 任务对象编辑器中的对象 配置 选项卡。 当使用创建新项目时 标准项目 模板，一个简单的任务配置已准备就绪 MainTask 任务已经存在。 更改任务 要求：开放项目包含类型为 POU PROGRAM 并且在设备树的应用程序下方插入了带有任务对象的任务配置。 在设备树中，双击下方的任务对象 任务配置 。 这 配置 任务对象的选项卡打开。 在 类型 列表框，选择 循环的 条目。 这个 间隔（例如 t #200ms） 出现输入字段。 在 间隔（例如 t #200ms） 字段，键入值 t#300ms 。 点击 添加通话 按钮。 输入助手打开。 在 输入助手 对话框...", 
"body" : "你可以在下面更改任务的设置 任务配置 任务对象编辑器中的对象 配置 选项卡。 当使用创建新项目时 标准项目 模板，一个简单的任务配置已准备就绪 MainTask 任务已经存在。 更改任务 要求：开放项目包含类型为 POU PROGRAM 并且在设备树的应用程序下方插入了带有任务对象的任务配置。 在设备树中，双击下方的任务对象 任务配置 。 这 配置 任务对象的选项卡打开。 在 类型 列表框，选择 循环的 条目。 这个 间隔（例如 t #200ms） 出现输入字段。 在 间隔（例如 t #200ms） 字段，键入值 t#300ms 。 点击 添加通话 按钮。 输入助手打开。 在 输入助手 对话框，在 程式 类别，选择所需的 POU，然后单击 好吧 关闭对话框。 选定的 POU 将在调用堆栈中列出 配置 选项卡和任务对象下方的设备树中。 从 PLC 执行应用程序时，任务对象中选定的 POU 将按以下间隔循环执行 300 ms 。 " }, 
{ "title" : "随心所欲 IEC 任务 ", 
"url" : "_cds_freewheeling_iec_task.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 \/ 随心所欲 IEC 任务 ", 
"snippet" : "欲的任务是循环执行的，但没有固定的任务周期。从PLC的经典意义上讲，这是一项反复出现的任务。 尽可能频繁地执行死刑。但是，处理不是在固定周期内进行的。您无法为此类任务定义任务周期时间。时间行为是自动选择的，其完成方式是尽可能减少对整个系统的负载。 此外，运行结束后需要等待一段特定的时间，直到再次执行任务。持续时间是最后一个周期持续时间的百分比。 对于随心所欲的任务，没有固定的任务周期时间和固定的时间行为保证。 您可以为随心所欲的任务配置监视程序。...", 
"body" : "欲的任务是循环执行的，但没有固定的任务周期。从PLC的经典意义上讲，这是一项反复出现的任务。 尽可能频繁地执行死刑。但是，处理不是在固定周期内进行的。您无法为此类任务定义任务周期时间。时间行为是自动选择的，其完成方式是尽可能减少对整个系统的负载。 此外，运行结束后需要等待一段特定的时间，直到再次执行任务。持续时间是最后一个周期持续时间的百分比。 对于随心所欲的任务，没有固定的任务周期时间和固定的时间行为保证。 您可以为随心所欲的任务配置监视程序。 " }, 
{ "title" : "逻辑 ", 
"url" : "_cds_freewheeling_iec_task.html#UUID-93812248-fffe-e248-6e0b-fbebee0f762c_section-idm234752771243877", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 \/ 随心所欲 IEC 任务 \/ 逻辑 ", 
"snippet" : "所有随心所欲的 IEC 任务的负载由运行时系统确定，因此该负载不会超过设定的最大处理器负载的一半。 MaxCpuLoadFreewheeling = ((MIN( 100, MaxProcessorload) \/ 2) \/ NumOfFreeWheelingTasks); SleeptimeAfterCycle = CycleTimeFreewheelingTask * ((100 - MaxCpuLoadFreewheeling) \/ 100) if (SleeptimeAfterCycle < 1000) \/\/ Minimum sleeptime of 1ms is mandatory! ...", 
"body" : "所有随心所欲的 IEC 任务的负载由运行时系统确定，因此该负载不会超过设定的最大处理器负载的一半。 MaxCpuLoadFreewheeling = ((MIN( 100, MaxProcessorload) \/ 2) \/ NumOfFreeWheelingTasks);\nSleeptimeAfterCycle = CycleTimeFreewheelingTask * ((100 - MaxCpuLoadFreewheeling) \/ 100)\nif (SleeptimeAfterCycle < 1000) \/\/ Minimum sleeptime of 1ms is mandatory!   \nSleeptimeAfterCycle = 1000; 示例 应用程序的运行时系统按如下方式运行： MaxProcessorload = 80 CycleTime = 20 毫秒 1 个随心所欲的任务 效果 MaxCpuLoadFreewheeling = 40% SleeptimeAfterCycle = 30 毫秒 随心所欲任务的总循环时间 = 50 ms ⇒ 系统其余部分的总CPU负载为60％。 " }, 
{ "title" : "抖动和延迟的定义 ", 
"url" : "_cds_task_configuration_jitter_definitions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 \/ 抖动和延迟的定义 ", 
"snippet" : "在 任务配置 对象，在 监视器 选项卡，您可以在运行时监控单个任务的周期性抖动值。周期性抖动与基于延迟的释放抖动有所区别 请参阅以下定义：...", 
"body" : "在 任务配置 对象，在 监视器 选项卡，您可以在运行时监控单个任务的周期性抖动值。周期性抖动与基于延迟的释放抖动有所区别 请参阅以下定义： " }, 
{ "title" : "周期性抖动 ", 
"url" : "_cds_task_configuration_jitter_definitions.html#UUID-9d6853f6-7ed8-8e80-75a4-2a1962e8fe38_id_f981b089a35bd38cc0a864636d261073_id_af58c92ba43a965cc0a8646374364889", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 \/ 抖动和延迟的定义 \/ 周期性抖动 ", 
"snippet" : "周期性抖动 J 每 是任务周期时间 T 的偏差 每 从所需的任务周期时间开始 T 0 。 J p e r = T p e r − T 0 J_{per}=T_{per}−T_0 所需的（理想）循环时间 T 0 在任务的配置中指定为 间隔 。 在 任务配置 编辑器，在 监视器 选项卡，您可以监控运行时周期性抖动的当前值以及最大值和最小值。 当所有负值的总和 J 每 不等于所有正值的总和 J 每 ，就会出现漂移。...", 
"body" : "周期性抖动 J 每 是任务周期时间 T 的偏差 每 从所需的任务周期时间开始 T 0 。 J p e r = T p e r − T 0 J_{per}=T_{per}−T_0 所需的（理想）循环时间 T 0 在任务的配置中指定为 间隔 。 在 任务配置 编辑器，在 监视器 选项卡，您可以监控运行时周期性抖动的当前值以及最大值和最小值。 当所有负值的总和 J 每 不等于所有正值的总和 J 每 ，就会出现漂移。 " }, 
{ "title" : "延迟 ", 
"url" : "_cds_task_configuration_jitter_definitions.html#UUID-9d6853f6-7ed8-8e80-75a4-2a1962e8fe38_id_f981b089a35bd38cc0a864636d261073_id_fb5ffa33a43a965cc0a8646345523b0d", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 \/ 抖动和延迟的定义 \/ 延迟 ", 
"snippet" : "延迟是两者之间的延迟 调用 既是任务又是实际任务 发布 。...", 
"body" : "延迟是两者之间的延迟 调用 既是任务又是实际任务 发布 。 " }, 
{ "title" : "释放抖动 ", 
"url" : "_cds_task_configuration_jitter_definitions.html#UUID-9d6853f6-7ed8-8e80-75a4-2a1962e8fe38_id_f981b089a35bd38cc0a864636d261073_id_533c636ea43a965cc0a864633ee70d81", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 \/ 抖动和延迟的定义 \/ 释放抖动 ", 
"snippet" : "释放抖动 J r 是有史以来发生的最大和最小延迟 (L) 之间的差异。 J r = L max - L min J_r=L_{\\max}-L_{\\min} 当 L 最大 = L 分钟 ，释放抖动 J r 共 0 个结果。这相当于严格的偏移位移。...", 
"body" : "释放抖动 J r 是有史以来发生的最大和最小延迟 (L) 之间的差异。 J r = L max - L min J_r=L_{\\max}-L_{\\min} 当 L 最大 = L 分钟 ，释放抖动 J r 共 0 个结果。这相当于严格的偏移位移。 " }, 
{ "title" : "堆栈使用率的计算 ", 
"url" : "_cds_calculate_stack_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 \/ 堆栈使用率的计算 ", 
"snippet" : "每个 POU 的堆栈使用量显示在 任务配置 上的对象 堆栈使用情况 选项卡。 堆栈使用量静态计算公式为 CODESYS 使用静态调用堆栈。 计算中包含以下内容： 计算从输入任务的隐式 POU 开始。 对于每个 IEC 程序调用（例如 PLC_PRG ），调用的每个 IEC POU 的堆栈使用量都是递归计算的。POU 的最大堆栈使用量会添加到其自己的本地堆栈使用量中，以确定 POU 的最大堆栈使用量 对于动态调用，堆栈使用率的计算方法如下：确定所有可能实现的堆栈使用量，并假定最大堆栈使用量。这意味着接口方法会考虑所有可能的实现以及函数块方法的所有可能的重写 对于外部呼叫，假定目标设备为其指定的值...", 
"body" : "每个 POU 的堆栈使用量显示在 任务配置 上的对象 堆栈使用情况 选项卡。 堆栈使用量静态计算公式为 CODESYS 使用静态调用堆栈。 计算中包含以下内容： 计算从输入任务的隐式 POU 开始。 对于每个 IEC 程序调用（例如 PLC_PRG ），调用的每个 IEC POU 的堆栈使用量都是递归计算的。POU 的最大堆栈使用量会添加到其自己的本地堆栈使用量中，以确定 POU 的最大堆栈使用量 对于动态调用，堆栈使用率的计算方法如下：确定所有可能实现的堆栈使用量，并假定最大堆栈使用量。这意味着接口方法会考虑所有可能的实现以及函数块方法的所有可能的重写 对于外部呼叫，假定目标设备为其指定的值。如果设备未指定值，则假定为 0。 在递归的情况下，计算会中止。类型属性编译指示的值 estimated-stack-usage 适用于递归调用的代码。如果未指定任何值，则假定为 0。 因此，堆栈使用量只是一个估计值。它可能太高了，因为假设的最低调用路径在运行时从未运行过。但是，它也可能太低，因为递归或外部调用的估计不利 示例 " }, 
{ "title" : "显示堆栈使用情况 ", 
"url" : "_cds_calculate_stack_usage.html#UUID-565541ba-1a57-4d6d-52b6-33ca85bebcdf", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 \/ 堆栈使用率的计算 \/ 显示堆栈使用情况 ", 
"snippet" : "双击 任务配置 对象。 任务配置编辑器打开。 点击 构建 → 生成代码 命令。 点击 堆栈使用情况 选项卡。 该选项卡上的信息已更新。 在下面 任务\/最大调用堆栈 ，按顺序调用的 POU 在最大调用堆栈中显示为假设值。计算出的 POU 堆栈大小显示在 堆栈大小 专栏。 示例 如果堆栈大小以红色显示，则相应的 POU 中可能存在堆栈溢出。你可以识别出你应该在哪里进行更改的 POU。这是调用堆栈中第一个用红色标记的 POU...", 
"body" : "双击 任务配置 对象。 任务配置编辑器打开。 点击 构建 → 生成代码 命令。 点击 堆栈使用情况 选项卡。 该选项卡上的信息已更新。 在下面 任务\/最大调用堆栈 ，按顺序调用的 POU 在最大调用堆栈中显示为假设值。计算出的 POU 堆栈大小显示在 堆栈大小 专栏。 示例 如果堆栈大小以红色显示，则相应的 POU 中可能存在堆栈溢出。你可以识别出你应该在哪里进行更改的 POU。这是调用堆栈中第一个用红色标记的 POU " }, 
{ "title" : "多核 ", 
"url" : "_cds_multi_core.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 \/ 多核 ", 
"snippet" : "任务和 CPU 内核的分配显示在 任务配置 上的对象 选项卡：任务组 选项卡。 当今越来越多的控制器采用具有多个 CPU 内核的处理器。 如果 CODESYS 不使用多核功能的情况下在多核控制器上执行，然后任务的分配由操作系统的调度程序处理。只要一个应用程序是通过多个任务执行的，就会出现这种情况。在这种情况下，你对任务的分配没有直接影响。根据负载平衡的不同，任务还可以在不同的 CPU 内核上运行。 随着 CODESYS 多核功能，IEC 任务本身可以分配给专用 CPU 内核，同时考虑到已获得的 CPU 内核数量。这可以提高性能。为此，IEC 程序应分为多个任务。 有两种基本的不同策略 CODE...", 
"body" : "任务和 CPU 内核的分配显示在 任务配置 上的对象 选项卡：任务组 选项卡。 当今越来越多的控制器采用具有多个 CPU 内核的处理器。 如果 CODESYS 不使用多核功能的情况下在多核控制器上执行，然后任务的分配由操作系统的调度程序处理。只要一个应用程序是通过多个任务执行的，就会出现这种情况。在这种情况下，你对任务的分配没有直接影响。根据负载平衡的不同，任务还可以在不同的 CPU 内核上运行。 随着 CODESYS 多核功能，IEC 任务本身可以分配给专用 CPU 内核，同时考虑到已获得的 CPU 内核数量。这可以提高性能。为此，IEC 程序应分为多个任务。 有两种基本的不同策略 CODESYS 用于在 CPU 内核上分发 IEC 任务： 链接并固定到 CPU 内核的 IEC 任务： 任务总是在这个特定的 CPU 内核上执行。通过分组，可以将多个任务链接到一个 CPU 内核。例如，如果 IEC 程序尚无法同时在多个 CPU 内核上运行，这很有用。 IEC 任务在所有 CPU 内核上执行： 操作系统负责在 CPU 核心上分配一组中的一个或多个任务。 当 IEC 任务分布在 CPU 内核上时，某些变化会导致 IEC 程序中的行为，必须予以考虑。 按优先级处理 IEC 任务已不再是既定的。只有当任务捆绑到一个 CPU 内核时，它们才会按优先级处理 IEC 任务中优先级最高的数据的周期一致性已不再是既定的。因此，如果在周期中值不发生变化，则必须在 IEC 任务周期开始时在本地复制数据。 对于所有任务，都有一个共享的进程映像来运行任务。这个 ReadInputs() 在每个任务开始时调用函数， WriteOutputs() 函数在最后被调用。因此，首次公开募股模式分别适用于每项任务。这些函数读取和写入共享进程映像。进程映像也是物理写入的，只有在调用总线周期任务时才传输数据包。但是，总线循环任务会等待每次调用 WriteOutputs 和 ReadInputs 的任务。这确保了总线周期任务中的数据一致性。 只能将输出分配给一项任务。 可以将输入分配给多个任务，但应避免直接访问。必须通过原子操作将输入写入任务的局部变量。 第二项任务，使用以下内容更新流程映像 ReadInputs() 在执行第一个任务的同时，还会在第一个任务运行时更新其输入。 因此，只有在优先级最高的任务的单核上才能确保任务的数据一致性。 您可以在总线上设置总线周期任务 PLC设定 标签。 您可以显示 I\/O 访问 标签：任务部署 标签。 有关更多信息，请参阅： 总线循环任务对于一致的计数器（增量器、减量器），原子外部库函数 SysCpuAtomicAdd() 应始终使用（有关更多详细信息，请参阅 SysCpuHandling.library ）。 数据一致性 位访问（数据类型） BIT ）在 IEC 程序中的多核 CPU 上不能一致（原子）处理。为此，我们建议您使用外部库函数 SysCpuTestAndSetBit() 。（有关详细信息，请参阅： SysCpuHandling.library ) 宽度不超过 32 位的简单数据类型 ( BOOL ， BYTE ， WORD \/ INT ， DWORD \/ DINT 等）在多核 CPU 上的 IEC 程序中也是一致地（以原子方式）进行处理。 64 位数据类型 ( LINT, LWORD, LREAL) 仅在 64 位系统和多核系统上的 IEC 程序中一致（原子地）处理。为此，您无需采取任何预防措施。 要访问复杂的数据类型 ( STRING ， FB ， STRUCT ，以及 ARRAY ），你需要自己为同步\/一致性做好安排。 在任务配置中，在 变量用法 选项卡，您可以定义 IEC 任务中的变量是否具有读取或写入权限。 在多核系统上，可能会发生“内存重新排序效应”。有关更多信息，请参阅：IEC 操作员： __MemoryBarrier() 。 在跟踪中显示每个处理器内核的处理器负载 在 CODESYS ，你可以在可视化中显示处理器负载情况 设备跟踪 对象。 有关如何在项目中显示设备跟踪的更多信息，请参阅： 访问控制器的所有痕迹 " }, 
{ "title" : "在多个处理器内核上分配任务 ", 
"url" : "_cds_multi_core.html#UUID-3fe3ae5a-9846-6716-c62e-acb89f2bb794_id_bd03ce9b9d30cbc0a864631d9f12af_id_7f76aece9c289dffc0a86463409eb0c2", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 任务配置 \/ 多核 \/ 在多个处理器内核上分配任务 ", 
"snippet" : "要求：您的应用程序中至少定义了两个任务，例如 MainTask （IEC-Task）和 LowTask （IEC-任务）。 打开 任务配置 编辑器中的对象。 切换到选项卡 任务组 . 概述显示了默认值 IEC 任务 任务组。 点击 添加群组 添加新任务组。 这个 NewGroup 群组已添加。 双击群组名称 NewGroup 并将其更改为 LowGroup 。 在 核心 ，选择一项任务（示例 1 ）。 打开任务 LowTask （IEC-Task）在编辑器中。 在 任务组 ，选择新组 LowGroup 。 这个 LowTask 任务现在由处理器核心 1 处理，因为它的组成员是 LowGroup...", 
"body" : "要求：您的应用程序中至少定义了两个任务，例如 MainTask （IEC-Task）和 LowTask （IEC-任务）。 打开 任务配置 编辑器中的对象。 切换到选项卡 任务组 . 概述显示了默认值 IEC 任务 任务组。 点击 添加群组 添加新任务组。 这个 NewGroup 群组已添加。 双击群组名称 NewGroup 并将其更改为 LowGroup 。 在 核心 ，选择一项任务（示例 1 ）。 打开任务 LowTask （IEC-Task）在编辑器中。 在 任务组 ，选择新组 LowGroup 。 这个 LowTask 任务现在由处理器核心 1 处理，因为它的组成员是 LowGroup 。 " }, 
{ "title" : "保护应用程序 ", 
"url" : "_cds_encrypting_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 保护应用程序 ", 
"snippet" : "借助特定于 PLC 的许可证管理及其在应用程序对象属性中的设置，您可以实现引导应用程序的专有技术保护和复制保护。下载代码和启动应用程序可以加密和签名。 有关更多信息，请参阅： 启动应用程序解锁和\/或签名 。...", 
"body" : "借助特定于 PLC 的许可证管理及其在应用程序对象属性中的设置，您可以实现引导应用程序的专有技术保护和复制保护。下载代码和启动应用程序可以加密和签名。 有关更多信息，请参阅： 启动应用程序解锁和\/或签名 。 " }, 
{ "title" : "数据持久化 ", 
"url" : "_cds_f_setting_data_persistence.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 ", 
"snippet" : "变量及其数据的生命周期从创建变量时开始，到删除变量和释放内存时结束。创建、初始化或实例化变量的时间取决于声明的范围。释放内存的时间通常也取决于范围。例如，全局变量的内存通过退出应用程序来释放。 他们可以比平时更长时间地保留数据。中的以下机制 CODESYS 为此目的而提供。 数据保存机制 （一个）： 持久的全局变量列表 用关键字 PERSISTENT RETAIN 重新加载应用程序时，持久变量保留其值。下载、热启动或冷启动后，这些值也会恢复。 (乙): 保留变量 用关键字 RETAIN 保留变量在热启动后保持其值，但在应用程序再次加载、下载或冷启动时不会。 （C）： 持久性管理器变量 的 CO...", 
"body" : "变量及其数据的生命周期从创建变量时开始，到删除变量和释放内存时结束。创建、初始化或实例化变量的时间取决于声明的范围。释放内存的时间通常也取决于范围。例如，全局变量的内存通过退出应用程序来释放。 他们可以比平时更长时间地保留数据。中的以下机制 CODESYS 为此目的而提供。 数据保存机制 （一个）： 持久的全局变量列表 用关键字 PERSISTENT RETAIN 重新加载应用程序时，持久变量保留其值。下载、热启动或冷启动后，这些值也会恢复。 (乙): 保留变量 用关键字 RETAIN 保留变量在热启动后保持其值，但在应用程序再次加载、下载或冷启动时不会。 （C）： 持久性管理器变量 的 CODESYS Application Composer Persistence Manager 变量保存在外部文件中。 (四): 配方变量 配方变量及其值保存在配方文件中。 " }, 
{ "title" : "比较机制 ", 
"url" : "_cds_f_setting_data_persistence.html#UUID-b0f99df2-e083-4576-131a-474b581d2136_section-idm4538086982022432656530449314", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 比较机制 ", 
"snippet" : "哪种机制适用于哪种应用？该表考虑了一些常见的用例。具体示例是指房屋控制。 机制和用例比较 用例 (A) 持久变量 (B) 保留变量 (c) 持久性管理器变量 (D) 配方变量 1 应用程序必须接收设备设置。 示例：电源故障后，房屋控制必须提供有关百叶窗需要升起多长时间的信息。 合适的 1 首选用例 在这种情况下，您还可以使用保留变量而不是持久变量。这对于声明经常更改的变量是有利的。 合适的 首选用例 当变量的声明经常更改时，保留变量是有利的。 合适的 2 有利于没有任何硬件支持的控制器 这是通过特殊功能（例如双文件缓冲）实现的。 可能，但非常麻烦，因此不推荐 2 应用程序还必须在程序更改或扩展...", 
"body" : "哪种机制适用于哪种应用？该表考虑了一些常见的用例。具体示例是指房屋控制。 机制和用例比较 用例 (A) 持久变量 (B) 保留变量 (c) 持久性管理器变量 (D) 配方变量 1 应用程序必须接收设备设置。 示例：电源故障后，房屋控制必须提供有关百叶窗需要升起多长时间的信息。 合适的 1 首选用例 在这种情况下，您还可以使用保留变量而不是持久变量。这对于声明经常更改的变量是有利的。 合适的 首选用例 当变量的声明经常更改时，保留变量是有利的。 合适的 2 有利于没有任何硬件支持的控制器 这是通过特殊功能（例如双文件缓冲）实现的。 可能，但非常麻烦，因此不推荐 2 应用程序还必须在程序更改或扩展后接收值。 2a：稀有扩展 示例：应用程序员在程序中添加了一个新开关并安装了一个新灯。房屋控制必须仍然具有到目前为止已保存的值。 合适的 1 首选用例 合适的 合适的 2 可以，但很麻烦 2b：更自由的更改，包括删除或更改变量的数据类型 房屋控制正在运行并持续存在。如果应用程序程序员使用新功能扩展控件并因此在功能块中使用进一步的持久变量，则必须保留到该点保存的值。例如，程序在 FB 中通过一个变量扩展，该变量控制在特定时间后自动关闭先前不受控制的灯。扩容后，房控必须有所有受控灯的时间可用。 不合适 合适的 在线更改后，保留变量中的数据将尽可能保留。 合适的 ， 越远越好 2 首选用例 如果有文字可能，但很尴尬 2c：应用程序必须在下载后接收值。 合适的 不合适 合适的 合适的 3 应用程序必须能够使用不同的值集。 示例：夏季、冬季和假期的运行设置必须根据需要保存并重新导入。 不合适 不合适 不合适 合适的 首选用例 4 应用程序必须能够使用其他系统的设置。 必须可以将设置传输到使用类似变量的另一个系统。 不合适 不合适 合适的 2 合适的 3 5 应用程序必须提供人类可读的数据。 用户必须能够读取、比较和编辑数据。 不合适 不合适 合适的 2 合适的 3 1 缺点：只有在运行时系统支持此机制并且 NVRam 内存或 UPS 可用时才有可能。优势：速度；推荐用例：1 和 2a 2 缺点：在大量变量（> 10000）的情况下，初始化和关闭需要很长的等待时间。优点：不需要特殊的内存设备；价值保留也适用于更改、扩展或删除。 3 优点：外部可编辑，可转移。缺点：尴尬 " }, 
{ "title" : "调用在线命令时变量的生命周期 ", 
"url" : "_cds_f_setting_data_persistence.html#UUID-b0f99df2-e083-4576-131a-474b581d2136_section-idm4654689529028832656531875814", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 调用在线命令时变量的生命周期 ", 
"snippet" : "菜单中的用户输入 在线的 具有通常寿命的变量 两者都不 RETAIN 仍然 PERSISTENT RETAIN PERSISTENT RETAIN PERSISTENT PERSISTENT RETAIN 命令 在线更改 x x x 命令 重新设置温暖 i x x 命令 冷复位 i i x 命令 加载 i i X 1 命令 重置原点 i i i x ：变量保持其值。 i : 变量被初始化。 1 注意：关于持久化数据的结构，请注意“下载机制”下的信息。...", 
"body" : "菜单中的用户输入 在线的 具有通常寿命的变量 两者都不 RETAIN 仍然 PERSISTENT RETAIN PERSISTENT RETAIN PERSISTENT PERSISTENT RETAIN 命令 在线更改 x x x 命令 重新设置温暖 i x x 命令 冷复位 i i x 命令 加载 i i X 1 命令 重置原点 i i i x ：变量保持其值。 i : 变量被初始化。 1 注意：关于持久化数据的结构，请注意“下载机制”下的信息。 " }, 
{ "title" : "加载引导应用程序时变量的寿命 ", 
"url" : "_cds_f_setting_data_persistence.html#UUID-b0f99df2-e083-4576-131a-474b581d2136_section-idm4501210508424032656532565093", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 加载引导应用程序时变量的寿命 ", 
"snippet" : "正常变量的值会丢失其值并重新初始化。 持久变量的值受到保护 当内存中持久变量的结构与持久数据列表中的结构匹配时。 当持久数据仅被扩展时。在这种情况下，只有最近添加的变量被设置为默认值。 保留变量的值受到保护 当内存中保留变量的结构与持久数据列表中的结构匹配时。 当保留变量与应用程序匹配时（GUID 必须匹配）。 如果在应用启动时不满足retain variables和persistent variables的值恢复要求，就会出现“retain mismatch”。硬件制造商的文档中描述了对这种差异的反应。 有关详细信息，请参阅： 使用持久变量保存数据...", 
"body" : "正常变量的值会丢失其值并重新初始化。 持久变量的值受到保护 当内存中持久变量的结构与持久数据列表中的结构匹配时。 当持久数据仅被扩展时。在这种情况下，只有最近添加的变量被设置为默认值。 保留变量的值受到保护 当内存中保留变量的结构与持久数据列表中的结构匹配时。 当保留变量与应用程序匹配时（GUID 必须匹配）。 如果在应用启动时不满足retain variables和persistent variables的值恢复要求，就会出现“retain mismatch”。硬件制造商的文档中描述了对这种差异的反应。 有关详细信息，请参阅： 使用持久变量保存数据" }, 
{ "title" : "使用持久变量保存数据 ", 
"url" : "_cds_preserve_data_with_persistent_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用持久变量保存数据 ", 
"snippet" : "当应用程序重新加载、下载、热启动或冷启动后，持久变量保持其值。 控制器上需要一个特殊的非易失性存储区来延长使用寿命，例如 NVRAM 或 UPS。将数据备份到此类存储不需要任何额外的时间，这比使用 Persistence Manager 保留数据更具优势。如果控制器不提供硬件支持，则数据通常存储在文件中。如果您正确关闭控制器，数据将被保留。但是，如果发生电源故障或“拔掉插头”，数据将会丢失。...", 
"body" : "当应用程序重新加载、下载、热启动或冷启动后，持久变量保持其值。 控制器上需要一个特殊的非易失性存储区来延长使用寿命，例如 NVRAM 或 UPS。将数据备份到此类存储不需要任何额外的时间，这比使用 Persistence Manager 保留数据更具优势。如果控制器不提供硬件支持，则数据通常存储在文件中。如果您正确关闭控制器，数据将被保留。但是，如果发生电源故障或“拔掉插头”，数据将会丢失。 " }, 
{ "title" : "行为 ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_e6bc7e4a5dd83963c0a8652d0077df17", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用持久变量保存数据 \/ 行为 ", 
"snippet" : "保值 不受控制的终止 通过调用命令热启动 重新设置温暖 调用命令冷启动 冷复位 再次下载应用程序 加载引导应用程序 重新初始化 调用命令 重置原点 因此，仅当您将控制器重置为交付状态时，才会重新初始化持久变量，例如，如果您使用命令 在线 → 重置原点 选择。 另一方面，如果您再次加载应用程序，则尽可能保留持久化数据。这取决于变化的深远程度。更改应用程序名称总是会导致完全重新初始化。对实现的更改永远不会导致重新初始化：数据持久性已完全保留。仅当现有变量是持久的时，当您更改声明以使持久变量列表保持一致时，对声明的更改才会导致新变量的初始化。当您添加新变量或删除现有变量时就是这种情况。如果您编辑和更...", 
"body" : "保值 不受控制的终止 通过调用命令热启动 重新设置温暖 调用命令冷启动 冷复位 再次下载应用程序 加载引导应用程序 重新初始化 调用命令 重置原点 因此，仅当您将控制器重置为交付状态时，才会重新初始化持久变量，例如，如果您使用命令 在线 → 重置原点 选择。 另一方面，如果您再次加载应用程序，则尽可能保留持久化数据。这取决于变化的深远程度。更改应用程序名称总是会导致完全重新初始化。对实现的更改永远不会导致重新初始化：数据持久性已完全保留。仅当现有变量是持久的时，当您更改声明以使持久变量列表保持一致时，对声明的更改才会导致新变量的初始化。当您添加新变量或删除现有变量时就是这种情况。如果您编辑和更改先前声明的持久变量的标识符或数据类型，可能会出现不一致。 " }, 
{ "title" : "下载应用程序或加载引导应用程序时的机制 ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_026b80bfdb38eee2c0a8646329d5dfb6", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用持久变量保存数据 \/ 下载应用程序或加载引导应用程序时的机制 ", 
"snippet" : "如果在持久性编辑器中编辑变量列表，则会导致变量列表不会像编辑器中显示的那样保存，而是在保存之前自动进行后期编辑。 在后处理中，您删除的变量将替换为具有相同内存占用的占位符变量。这意味着以下变量将其地址保留在过程映像中。此外，您添加的任何变量都会移至列表底部。后处理可以抵消可能导致持久性丧失的更改。但是您会创建占用额外内存的间隙。 加载应用程序时，变量列表的 CRC 值和列表的长度（变量数）存储在控制器上。再次加载应用程序时，会将新的测试值与控制器上当前的测试值进行比较。然后连续比较变量列表直到指定的长度。如果您编辑了声明（例如，名称或数据类型），则会重新初始化该变量。否则它的值被保留。再次加载...", 
"body" : "如果在持久性编辑器中编辑变量列表，则会导致变量列表不会像编辑器中显示的那样保存，而是在保存之前自动进行后期编辑。 在后处理中，您删除的变量将替换为具有相同内存占用的占位符变量。这意味着以下变量将其地址保留在过程映像中。此外，您添加的任何变量都会移至列表底部。后处理可以抵消可能导致持久性丧失的更改。但是您会创建占用额外内存的间隙。 加载应用程序时，变量列表的 CRC 值和列表的长度（变量数）存储在控制器上。再次加载应用程序时，会将新的测试值与控制器上当前的测试值进行比较。然后连续比较变量列表直到指定的长度。如果您编辑了声明（例如，名称或数据类型），则会重新初始化该变量。否则它的值被保留。再次加载应用程序时， CODESYS 检查持久性编辑器中声明的变量列表是否仍然与控制器上已有的变量列表一致。 当变量本身没有显着变化时，该机制运行良好。对标识符和数据类型的过度更改会继续导致重新初始化和持久性丢失。因此，如果您预计根据您的应用程序需要频繁更改，则通常不建议使用此类列表。此外，在数据类型更改后发生在线更改的情况下，持久变量的健壮性不如具有正常生命周期的变量。 基本上，一段时间后，您应该清理间隙的变量列表和命令 重新排序列表并清理空白 跑步。但是，在清理之后，列表不再匹配控制器上的列表，并且您触发了所有持久变量的初始化。所有变量的持久性都丢失了。 在 V3.5 SP1 之前的版本中，持久性编辑器中的更改总是会导致重新初始化。 " }, 
{ "title" : "通过配方管理器保存数据 ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_section-idm454453384126563278957291646", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用持久变量保存数据 \/ 通过配方管理器保存数据 ", 
"snippet" : "为了清理全局持久变量列表而不丢失其持久性，您可以使用配方管理器将数据保存在配方中。在配方管理器中生成持久变量列表的所有变量的列表，同时控制器将它们的当前值保存为配方。然后选择命令 重新排序列表并清理空白 然后重新下载。如果你现在的命令 从配方中恢复值 被选中时，配方中保存的值被恢复。...", 
"body" : "为了清理全局持久变量列表而不丢失其持久性，您可以使用配方管理器将数据保存在配方中。在配方管理器中生成持久变量列表的所有变量的列表，同时控制器将它们的当前值保存为配方。然后选择命令 重新排序列表并清理空白 然后重新下载。如果你现在的命令 从配方中恢复值 被选中时，配方中保存的值被恢复。 " }, 
{ "title" : "更改持久变量列表中的现有声明 ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_adb14f80ef92a200c0a8646350a7e5b5", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用持久变量保存数据 \/ 更改持久变量列表中的现有声明 ", 
"snippet" : "如果更改变量的名称或数据类型，这将被解释为新的声明，并导致在下一次在线更改或加载应用程序时重新初始化变量。对于复杂的数据类型，当添加新组件时，或者当您将变量类型从 INT 到 UINT 例如，在使用过的结构的深度。 基本上，复杂的用户定义数据类型不适合在持久变量列表中进行管理，因为即使是很小的更改也会导致变量被所有组件初始化。...", 
"body" : "如果更改变量的名称或数据类型，这将被解释为新的声明，并导致在下一次在线更改或加载应用程序时重新初始化变量。对于复杂的数据类型，当添加新组件时，或者当您将变量类型从 INT 到 UINT 例如，在使用过的结构的深度。 基本上，复杂的用户定义数据类型不适合在持久变量列表中进行管理，因为即使是很小的更改也会导致变量被所有组件初始化。 " }, 
{ "title" : "在实例路径中双重分配内存 ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_91675dcb1796868bc0a864635066dcfe", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用持久变量保存数据 \/ 在实例路径中双重分配内存 ", 
"snippet" : "您可以在功能块或程序中保留全局变量或本地声明的变量。为此，请将关键字添加到声明中 PERSISTENT .此外，在持久化全局变量列表中添加该变量的实例路径。为此，请在持久性编辑器中选择命令 添加所有实例路径 . 通过以下机制保证持久性： 确定在哪些循环任务中访问该变量。 在第一个循环任务结束时（在每个循环中），变量被复制到持久全局变量列表中。 重新启动控制器后，会将值从持久变量复制到普通变量。 这种机制的缺点是在声明点和实例路径点都分配了内存。这个持久变量占据 双倍的 储存空间。此外，数据会在每个周期中复制到两个位置。这可能很耗时，尤其是在涉及大型结构化值时。...", 
"body" : "您可以在功能块或程序中保留全局变量或本地声明的变量。为此，请将关键字添加到声明中 PERSISTENT .此外，在持久化全局变量列表中添加该变量的实例路径。为此，请在持久性编辑器中选择命令 添加所有实例路径 . 通过以下机制保证持久性： 确定在哪些循环任务中访问该变量。 在第一个循环任务结束时（在每个循环中），变量被复制到持久全局变量列表中。 重新启动控制器后，会将值从持久变量复制到普通变量。 这种机制的缺点是在声明点和实例路径点都分配了内存。这个持久变量占据 双倍的 储存空间。此外，数据会在每个周期中复制到两个位置。这可能很耗时，尤其是在涉及大型结构化值时。 " }, 
{ "title" : "持久功能块实例的内存位置 ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_cccc8c251cf2cccdc0a8646315994b40", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用持久变量保存数据 \/ 持久功能块实例的内存位置 ", 
"snippet" : "功能块实例始终完全在内存中。这是必要的，以便相同的代码可以在不同的实例上工作。如果现在功能块中只有一个变量 PERSISTENT 被标记时，功能块实例与所有变量一起完全存储在剩余内存中，尽管只有一个变量被视为持久变量。但是，非易失性存储器的可用程度与主存储器不同。 具有指向 SRAM 中实例的指针作为变量的功能块不存储在安全存储器中。...", 
"body" : "功能块实例始终完全在内存中。这是必要的，以便相同的代码可以在不同的实例上工作。如果现在功能块中只有一个变量 PERSISTENT 被标记时，功能块实例与所有变量一起完全存储在剩余内存中，尽管只有一个变量被视为持久变量。但是，非易失性存储器的可用程度与主存储器不同。 具有指向 SRAM 中实例的指针作为变量的功能块不存储在安全存储器中。 " }, 
{ "title" : "进口于 CoDeSys V2.3 -项目 ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_574bae341796868bc0a86463467e40bc", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用持久变量保存数据 \/ 进口于 CoDeSys V2.3 -项目 ", 
"snippet" : "当你打开 CoDeSys V2.3 将其导入到项目中 CODESYS V3，持久变量的声明不会被保留。您必须修改声明并在单独的持久全局变量列表中重新创建它们。...", 
"body" : "当你打开 CoDeSys V2.3 将其导入到项目中 CODESYS V3，持久变量的声明不会被保留。您必须修改声明并在单独的持久全局变量列表中重新创建它们。 " }, 
{ "title" : "使用保留变量获取数据 ", 
"url" : "_cds_preserve_data_with_retain_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用保留变量获取数据 ", 
"snippet" : "保留变量在热启动后保留其值。但是，具有持久性变量的价值保留程度更高。 控制器上需要一个特殊的非易失性存储区来延长使用寿命，例如 NVRAM 或 UPS。将保留变量保存在这样的内存中不需要任何额外的时间，这比使用 Persistence Manager 保留数据具有优势。如果控制器不提供硬件支持，则数据通常存储在文件中。如果您正确关闭控制器，数据将被保留。但是，如果发生电源故障或“拔掉插头”，数据将会丢失。...", 
"body" : "保留变量在热启动后保留其值。但是，具有持久性变量的价值保留程度更高。 控制器上需要一个特殊的非易失性存储区来延长使用寿命，例如 NVRAM 或 UPS。将保留变量保存在这样的内存中不需要任何额外的时间，这比使用 Persistence Manager 保留数据具有优势。如果控制器不提供硬件支持，则数据通常存储在文件中。如果您正确关闭控制器，数据将被保留。但是，如果发生电源故障或“拔掉插头”，数据将会丢失。 " }, 
{ "title" : "宣言 ", 
"url" : "_cds_preserve_data_with_retain_variables.html#UUID-2a4bd8c7-3a50-60c2-6dd4-d05d5cf2d578_id_f24d7503d14dee35c0a8646344406010_id_803fd478db437037c0a8646355c3075d", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用保留变量获取数据 \/ 宣言 ", 
"snippet" : "要声明保留变量，请将关键字添加到变量声明中 RETAIN 添加。...", 
"body" : "要声明保留变量，请将关键字添加到变量声明中 RETAIN 添加。 " }, 
{ "title" : "行为 ", 
"url" : "_cds_preserve_data_with_retain_variables.html#UUID-2a4bd8c7-3a50-60c2-6dd4-d05d5cf2d578_id_f24d7503d14dee35c0a8646344406010_id_91675dcb1796868bc0a864635066dcfe", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用保留变量获取数据 \/ 行为 ", 
"snippet" : "保值 控制器重启 不受控制的退出（仅适用于 NvRAM 等硬件支持） 调用命令 重新设置温暖 重新初始化 再次下载应用程序 调用命令 冷复位 （相对于持久变量） 调用命令 重置原点 当您重新启动应用程序时，其变量通常使用显式给定的初始值或默认值进行初始化。用关键字标记的变量 RETAIN 标记根据目标系统在单独的内存区域中管理并保留其值。例如，变量受到电源故障的保护。因此，即使在电源故障后，您也可以在制造工厂的计件器上使用保留变量来继续计数。...", 
"body" : "保值 控制器重启 不受控制的退出（仅适用于 NvRAM 等硬件支持） 调用命令 重新设置温暖 重新初始化 再次下载应用程序 调用命令 冷复位 （相对于持久变量） 调用命令 重置原点 当您重新启动应用程序时，其变量通常使用显式给定的初始值或默认值进行初始化。用关键字标记的变量 RETAIN 标记根据目标系统在单独的内存区域中管理并保留其值。例如，变量受到电源故障的保护。因此，即使在电源故障后，您也可以在制造工厂的计件器上使用保留变量来继续计数。 " }, 
{ "title" : "保留功能块实例的内存位置 ", 
"url" : "_cds_preserve_data_with_retain_variables.html#UUID-2a4bd8c7-3a50-60c2-6dd4-d05d5cf2d578_id_f24d7503d14dee35c0a8646344406010_id_cccc8c251cf2cccdc0a8646315994b40", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用保留变量获取数据 \/ 保留功能块实例的内存位置 ", 
"snippet" : "功能块实例在内存中是一体的。这是必要的，以便相同的代码可以在不同的实例上工作。如果现在功能块中的变量具有 RETAIN 标记，然后功能块的每个实例与所有变量一起保存。还有没有像这样标记的功能块的变量。但是，非易失性存储器的可用程度与主存储器不同。 具有指向 SRAM 中实例的指针作为变量的功能块不存储在安全存储器中。...", 
"body" : "功能块实例在内存中是一体的。这是必要的，以便相同的代码可以在不同的实例上工作。如果现在功能块中的变量具有 RETAIN 标记，然后功能块的每个实例与所有变量一起保存。还有没有像这样标记的功能块的变量。但是，非易失性存储器的可用程度与主存储器不同。 具有指向 SRAM 中实例的指针作为变量的功能块不存储在安全存储器中。 " }, 
{ "title" : "进口于 CoDeSys V2.3 -项目 ", 
"url" : "_cds_preserve_data_with_retain_variables.html#UUID-2a4bd8c7-3a50-60c2-6dd4-d05d5cf2d578_id_f24d7503d14dee35c0a8646344406010_id_574bae341796868bc0a86463467e40bc", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用保留变量获取数据 \/ 进口于 CoDeSys V2.3 -项目 ", 
"snippet" : "如果你是 CoDeSys V2.3 -打开项目将其放入 CODESYS 导入 V3，retain 变量的声明被保留，没有任何作用。 有关更多信息，请参阅 RETAIN 和 打开 V2.3 项目...", 
"body" : "如果你是 CoDeSys V2.3 -打开项目将其放入 CODESYS 导入 V3，retain 变量的声明被保留，没有任何作用。 有关更多信息，请参阅 RETAIN 和 打开 V2.3 项目" }, 
{ "title" : "使用 Persistence Manager 变量保留数据 ", 
"url" : "_cds_preserve_data_ac.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用 Persistence Manager 变量保留数据 ", 
"snippet" : "在里面 持久性管理器 在 Application Composer 中，变量是持久管理的。的功能 持久性管理器 不需要控制器上的任何特殊内存来接收值和数据。...", 
"body" : "在里面 持久性管理器 在 Application Composer 中，变量是持久管理的。的功能 持久性管理器 不需要控制器上的任何特殊内存来接收值和数据。 " }, 
{ "title" : "宣言 ", 
"url" : "_cds_preserve_data_ac.html#UUID-bbc6d774-55f9-b4d3-e6de-af462b9c94be_id_a536c64d14eb304c0a864635f20c358_id_4041284cefc6aceec0a864630792390d", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用 Persistence Manager 变量保留数据 \/ 宣言 ", 
"snippet" : "Persistence Manager 中管理的变量位于带有 pragma 的声明中 {attribute 'ac_persist'} 标记。 pragma 导致如此归因的变量在 Application Composer 的 Persistence Manager 中进行管理。即使您更改变量的声明，变量值也会保留，例如，从应用程序中删除一个变量或添加一个新变量。即使您使用适当的转换更改数据类型，该值也会保留。...", 
"body" : "Persistence Manager 中管理的变量位于带有 pragma 的声明中 {attribute 'ac_persist'} 标记。 pragma 导致如此归因的变量在 Application Composer 的 Persistence Manager 中进行管理。即使您更改变量的声明，变量值也会保留，例如，从应用程序中删除一个变量或添加一个新变量。即使您使用适当的转换更改数据类型，该值也会保留。 " }, 
{ "title" : "机制 ", 
"url" : "_cds_preserve_data_ac.html#UUID-bbc6d774-55f9-b4d3-e6de-af462b9c94be_id_a536c64d14eb304c0a864635f20c358_id_c56775d6efc6aceec0a86463532fbcfd", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用 Persistence Manager 变量保留数据 \/ 机制 ", 
"snippet" : "Persistence Manager 的变量与它们的值一起保存在 TXT 格式的外部存档文件中。 应用程序代码由 Persistence Manager 的代码扩展，这导致更大的内存需求。这是以牺牲性能为代价的。此外，读取，尤其是写入大量持久变量可能需要很长时间。结果，正在执行的任务会阻塞执行相应的长时间。...", 
"body" : "Persistence Manager 的变量与它们的值一起保存在 TXT 格式的外部存档文件中。 应用程序代码由 Persistence Manager 的代码扩展，这导致更大的内存需求。这是以牺牲性能为代价的。此外，读取，尤其是写入大量持久变量可能需要很长时间。结果，正在执行的任务会阻塞执行相应的长时间。 " }, 
{ "title" : "功能性 ", 
"url" : "_cds_preserve_data_ac.html#UUID-bbc6d774-55f9-b4d3-e6de-af462b9c94be_id_a536c64d14eb304c0a864635f20c358_id_3a850974d202a5e6c0a8646366306c87", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用 Persistence Manager 变量保留数据 \/ 功能性 ", 
"snippet" : "您可以在 Notepad++ 等外部编辑器中加载和编辑 TXT 文件。 您可以在另一个应用程序中使用文件的持久变量。 您可以通过定义持久性组、将它们分配给变量并使用它们自己的存储和读取行为来配置组来配置持久性变量的行为。...", 
"body" : "您可以在 Notepad++ 等外部编辑器中加载和编辑 TXT 文件。 您可以在另一个应用程序中使用文件的持久变量。 您可以通过定义持久性组、将它们分配给变量并使用它们自己的存储和读取行为来配置组来配置持久性变量的行为。 " }, 
{ "title" : "使用食谱获取数据 ", 
"url" : "_cds_preserve_data_with_recipes.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用食谱获取数据 ", 
"snippet" : "变量在配方管理器中持续管理。配方管理器不需要控制器上的任何特殊内存来接收值和数据。...", 
"body" : "变量在配方管理器中持续管理。配方管理器不需要控制器上的任何特殊内存来接收值和数据。 " }, 
{ "title" : "宣言 ", 
"url" : "_cds_preserve_data_with_recipes.html#UUID-1dbefc8c-9b39-17e5-c1e5-8a6df87d0498_id_b66a4132d14f2b7fc0a864630fe45862_id_c56775d6efc6aceec0a86463532fbcfd", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用食谱获取数据 \/ 宣言 ", 
"snippet" : "配方定义由一组具有值的变量组成，并在对象中定义 食谱经理 创建和编辑并保存为文件。...", 
"body" : "配方定义由一组具有值的变量组成，并在对象中定义 食谱经理 创建和编辑并保存为文件。 " }, 
{ "title" : "功能性 ", 
"url" : "_cds_preserve_data_with_recipes.html#UUID-1dbefc8c-9b39-17e5-c1e5-8a6df87d0498_id_b66a4132d14f2b7fc0a864630fe45862_id_53bd4e7cd202a692c0a8646369dae647", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 使用食谱获取数据 \/ 功能性 ", 
"snippet" : "您可以在多个配方中包含一个变量，每个配方具有不同的值。 在在线模式下，您可以从控制器中读取变量的实际值并将其保存为配方值（设定值）。 你可以使用图书馆 Recipe Management 以编程方式实现配方的创建和处理。 您可以将配方保存并保存为配方文件。...", 
"body" : "您可以在多个配方中包含一个变量，每个配方具有不同的值。 在在线模式下，您可以从控制器中读取变量的实际值并将其保存为配方值（设定值）。 你可以使用图书馆 Recipe Management 以编程方式实现配方的创建和处理。 您可以将配方保存并保存为配方文件。 " }, 
{ "title" : "声明VAR PERSISTENT变量 ", 
"url" : "_cds_setting_up_persistence.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 声明VAR PERSISTENT变量 ", 
"snippet" : "在下文中，您将在持久变量列表和 POU 中声明持久变量。 要求：一个项目是打开的并且包含一个程序 POU。在选项中（菜单命令 工具 → 选项 ) 你在类别中 声明编辑 文本视图的选项被激活。 使用菜单命令添加贴布绣对象 项目 → 添加对象 物体 持久变量 添加。 CODESYS 添加持久变量列表 持久变量 在设备树中的应用程序对象下，编辑器打开。 在记事本之间输入 VAR_GLOBAL PERSISTENT RETAIN 和 END_VAR 变量声明，例如 ivarpersist1 : INT; . 双击设备树中的 POU。 POU 的编辑器打开。 在声明部分，输入以下声明： VAR PERS...", 
"body" : "在下文中，您将在持久变量列表和 POU 中声明持久变量。 要求：一个项目是打开的并且包含一个程序 POU。在选项中（菜单命令 工具 → 选项 ) 你在类别中 声明编辑 文本视图的选项被激活。 使用菜单命令添加贴布绣对象 项目 → 添加对象 物体 持久变量 添加。 CODESYS 添加持久变量列表 持久变量 在设备树中的应用程序对象下，编辑器打开。 在记事本之间输入 VAR_GLOBAL PERSISTENT RETAIN 和 END_VAR 变量声明，例如 ivarpersist1 : INT; . 双击设备树中的 POU。 POU 的编辑器打开。 在声明部分，输入以下声明： VAR PERSISTENT RETAIN ivarpersist2 :INT; END_VAR 选择菜单命令 创建 → 翻译 . 消息窗口打开。什么时候 CODESYS 应用程序已编译且没有错误，关闭消息窗口并继续下一步。否则更正错误并再次选择菜单命令 创建 → 翻译 . 把焦点放在编辑器上 持久变量 .选择菜单命令 声明 → 添加所有实例路径 . CODESYS 将持久变量添加到持久变量列表 持久变量 添加到 POU： \/\/ Instanzpfad der persistenten Variablen erzeugt POU.IVARPERSIST2 : INT " }, 
{ "title" : "将持久变量列表的值保存在配方中 ", 
"url" : "_cds_saving_persistent_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 数据持久化 \/ 将持久变量列表的值保存在配方中 ", 
"snippet" : "要求：一个项目是打开的，并且在一个应用程序对象下有一个带有持久变量声明的持久变量列表。 双击设备树中的控制器并选择选项卡 沟通 . 选择您的网关并单击按钮 浏览网络 . 您的设备在网关树视图中以粗体显示。 选择您的设备并单击按钮 设置活动路径 . 在设备树中选择您的应用程序对象并选择上下文菜单命令 设置活动应用程序 . 应用程序对象以粗体显示。 选择菜单命令 在线 → 登录 . 您的应用程序已登录到控制器，并且设备树中的控制器和应用程序对象具有绿色背景。 双击持久变量列表并选择命令 声明 → 保存配方中的当前值 . CODESYS 在应用程序对象下创建对象 食谱经理 和 持久变量 . 选择菜单...", 
"body" : "要求：一个项目是打开的，并且在一个应用程序对象下有一个带有持久变量声明的持久变量列表。 双击设备树中的控制器并选择选项卡 沟通 . 选择您的网关并单击按钮 浏览网络 . 您的设备在网关树视图中以粗体显示。 选择您的设备并单击按钮 设置活动路径 . 在设备树中选择您的应用程序对象并选择上下文菜单命令 设置活动应用程序 . 应用程序对象以粗体显示。 选择菜单命令 在线 → 登录 . 您的应用程序已登录到控制器，并且设备树中的控制器和应用程序对象具有绿色背景。 双击持久变量列表并选择命令 声明 → 保存配方中的当前值 . CODESYS 在应用程序对象下创建对象 食谱经理 和 持久变量 . 选择菜单命令 在线 → 注销 . 应用程序从控制器中注销。 " }, 
{ "title" : "使用构建块进行隐式检查 ", 
"url" : "_cds_using_pous_for_implicit_check.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 使用构建块进行隐式检查 ", 
"snippet" : "CODESYS 提供实现隐式监控功能的特殊 POU。这些函数在运行时检查数组或子范围类型的边界、指针地址的有效性或被零除。 选择对象 应用 在设备树中。 选择命令 项目 → 添加对象 → POU 进行隐式检查 . 出现对话框 为隐式检查添加 POU . 激活所需的功能。 点击按钮 添加 . 选定的 POU 显示在 应用 插入设备树。 在编辑器中打开 POU。 根据您的要求调整实施建议。 为了保持监控功能的功能，您不得更改声明部分。唯一的例外是您可以添加局部变量。...", 
"body" : "CODESYS 提供实现隐式监控功能的特殊 POU。这些函数在运行时检查数组或子范围类型的边界、指针地址的有效性或被零除。 选择对象 应用 在设备树中。 选择命令 项目 → 添加对象 → POU 进行隐式检查 . 出现对话框 为隐式检查添加 POU . 激活所需的功能。 点击按钮 添加 . 选定的 POU 显示在 应用 插入设备树。 在编辑器中打开 POU。 根据您的要求调整实施建议。 为了保持监控功能的功能，您不得更改声明部分。唯一的例外是您可以添加局部变量。 " }, 
{ "title" : "面向对象编程 ", 
"url" : "_cds_f_object_oriented_programming.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 ", 
"snippet" : "CODESYS 支持使用功能块进行面向对象编程，并为此提供以下功能和对象： 方法 接口 特性 遗产 方法调用、虚函数调用 将功能块定义为其他功能块的扩展...", 
"body" : "CODESYS 支持使用功能块进行面向对象编程，并为此提供以下功能和对象： 方法 接口 特性 遗产 方法调用、虚函数调用 将功能块定义为其他功能块的扩展 " }, 
{ "title" : "扩展功能块 ", 
"url" : "_cds_extending_function_block.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 扩展功能块 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "一般的 ", 
"url" : "_cds_extending_function_block.html#UUID-9227be4c-31f9-73e0-19cf-95ca7326aa82_section-idm4538086976649632656586029339", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 扩展功能块 \/ 一般的 ", 
"snippet" : "功能块的扩展基于面向对象编程中的继承概念。为此，派生功能块“扩展”基本功能块，因此除了其自身的属性外，还接收基本功能块的属性。 功能块的扩展意味着： 派生功能块包含基本功能块定义的所有数据和方法。您可以在任何上下文中使用基本功能块的实例 CODESYS 需要一个基本功能块类型的功能块。 派生功能模块可以覆盖您在基本功能模块中定义的方法。这意味着： 派生功能块可以定义与基本功能块定义的名称、输入和输出相同的方法。 提示：为覆盖从基本块继承的方法、动作、属性和转换提供了以下支持。如果在派生的构建块下方插入方法、操作等，则会出现对话框 添加对象 一个组合框，其中包含基本模块中使用的方法、操作等的选择...", 
"body" : "功能块的扩展基于面向对象编程中的继承概念。为此，派生功能块“扩展”基本功能块，因此除了其自身的属性外，还接收基本功能块的属性。 功能块的扩展意味着： 派生功能块包含基本功能块定义的所有数据和方法。您可以在任何上下文中使用基本功能块的实例 CODESYS 需要一个基本功能块类型的功能块。 派生功能模块可以覆盖您在基本功能模块中定义的方法。这意味着： 派生功能块可以定义与基本功能块定义的名称、输入和输出相同的方法。 提示：为覆盖从基本块继承的方法、动作、属性和转换提供了以下支持。如果在派生的构建块下方插入方法、操作等，则会出现对话框 添加对象 一个组合框，其中包含基本模块中使用的方法、操作等的选择，可以接受它们，然后只相应地调整它们。 派生功能块不得包含与基本功能块使用的名称相同的功能块变量。编译器将此报告为错误。 唯一的例外：如果您在基本功能块中使用变量作为 VAR_TEMP 声明，那么派生的功能块可以定义一个同名的变量。在这种情况下，派生功能块不能再访问基本功能块的变量。 您可以在派生功能块范围内使用基本功能块的变量和方法，方法是使用 SUPER - 直接寻址指针。 不允许多重继承。 例外：一个功能块可以实现多个接口，一个接口可以扩展其他接口。 " }, 
{ "title" : "使用新功能块扩展基本功能块 ", 
"url" : "_cds_extending_function_block.html#UUID-9227be4c-31f9-73e0-19cf-95ca7326aa82_id_bc846ea1a9450c0a8640e0123a187_id_a8817c8cf42e9706c0a8640e013e9a51", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 扩展功能块 \/ 使用新功能块扩展基本功能块 ", 
"snippet" : "要求：当前打开的项目有一个基本功能块，例如 POU_1(FB) , 将增加一个新的功能模块。 选择对象 应用 在设备树中并选择菜单命令 项目→添加对象→POU . 对话 添加 POU 打开。 在输入字段中输入新功能模块的名称 姓 一个，例如 POU_Ex . 选择 功能块 . 选择 先进的 并点击按钮 . 在入口助手中，从类别中选择 功能块 在下面 应用 用作基本功能块的 POU(FB)，例如 POU_1 并点击 行 . 您可以选择拥有一个 访问修饰符 用于组合框中的新功能块。 从组合框中选择 实现语言 例如 结构化文本（ST） 出去。 点击 添加 . CODESYS 添加功能块 POU_Ex...", 
"body" : "要求：当前打开的项目有一个基本功能块，例如 POU_1(FB) , 将增加一个新的功能模块。 选择对象 应用 在设备树中并选择菜单命令 项目→添加对象→POU . 对话 添加 POU 打开。 在输入字段中输入新功能模块的名称 姓 一个，例如 POU_Ex . 选择 功能块 . 选择 先进的 并点击按钮 . 在入口助手中，从类别中选择 功能块 在下面 应用 用作基本功能块的 POU(FB)，例如 POU_1 并点击 行 . 您可以选择拥有一个 访问修饰符 用于组合框中的新功能块。 从组合框中选择 实现语言 例如 结构化文本（ST） 出去。 点击 添加 . CODESYS 添加功能块 POU_Ex 进入设备树并打开编辑器。第一行说： FUNCTION_BLOCK POU_Ex EXTENDS POU_1 功能块 POU_Ex 扩展基本功能块 POU_1 . " }, 
{ "title" : "使用现有功能块扩展基本功能块 ", 
"url" : "_cds_extending_function_block.html#UUID-9227be4c-31f9-73e0-19cf-95ca7326aa82_id_bc846ea1a9450c0a8640e0123a187_id_630b9b97941a86bac0a864632a5ce350", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 扩展功能块 \/ 使用现有功能块扩展基本功能块 ", 
"snippet" : "要求：当前打开的项目有一个基本功能块，例如 POU_1(FB) ，以及另一个功能块，例如 POU_Ex(FB) .功能块 POU_Ex(FB) 还应具备基本功能块的属性。这意味着： POU_Ex(FB) 目标 POU_1(FB) 扩张。 双击设备树中的功能块 POU_Ex(FB) . 功能块的编辑器打开。 展开现有的顶行条目 FUNCTION_BLOCK POU_Ex 和 EXTENDS POU_1 . 功能块 POU_Ex 扩展了基本功能块 POU_1 . 有关更多信息，请参阅： 实现一个接口 和 扩展接口...", 
"body" : "要求：当前打开的项目有一个基本功能块，例如 POU_1(FB) ，以及另一个功能块，例如 POU_Ex(FB) .功能块 POU_Ex(FB) 还应具备基本功能块的属性。这意味着： POU_Ex(FB) 目标 POU_1(FB) 扩张。 双击设备树中的功能块 POU_Ex(FB) . 功能块的编辑器打开。 展开现有的顶行条目 FUNCTION_BLOCK POU_Ex 和 EXTENDS POU_1 . 功能块 POU_Ex 扩展了基本功能块 POU_1 . 有关更多信息，请参阅： 实现一个接口 和 扩展接口" }, 
{ "title" : "生成继承 POU 时的输入支持 ", 
"url" : "_cds_extending_function_block.html#UUID-1d94a1a9-161e-c24e-9497-750a39f396c9", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 扩展功能块 \/ 生成继承 POU 时的输入支持 ", 
"snippet" : "当你进行面向对象的编程并使用继承时 ( EXTENDS  关键字）的 POU，您可以通过以下方式获得支持： 当您在派生自基本 POU 的 POU 下插入操作、属性、方法或转换时， 添加 … 对话框打开。然后名称的输入字段扩展到一个列表框。列表框包含从基本 POU 中可用的动作、属性、方法或转换中进行的有效选择。例如，现在您可以轻松地接受基本 POU 的方法，然后将其调整为 POU 的派生函数。 带有访问修饰符的方法和属性 PRIVATE 此处未列出，因为它们也不是继承的。带有访问修饰符的方法和属性 PUBLIC 接受派生的 POU 时自动获得一个空白的访问修饰符字段，这在功能上意味着相同的事情...", 
"body" : "当你进行面向对象的编程并使用继承时 ( EXTENDS  关键字）的 POU，您可以通过以下方式获得支持： 当您在派生自基本 POU 的 POU 下插入操作、属性、方法或转换时， 添加 … 对话框打开。然后名称的输入字段扩展到一个列表框。列表框包含从基本 POU 中可用的动作、属性、方法或转换中进行的有效选择。例如，现在您可以轻松地接受基本 POU 的方法，然后将其调整为 POU 的派生函数。 带有访问修饰符的方法和属性 PRIVATE 此处未列出，因为它们也不是继承的。带有访问修饰符的方法和属性 PUBLIC 接受派生的 POU 时自动获得一个空白的访问修饰符字段，这在功能上意味着相同的事情。 有关更多信息，请参阅： 财产， 方法， 过渡， 行动， 例子 " }, 
{ "title" : "实现一个接口 ", 
"url" : "_cds_implementing_interface.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 实现一个接口 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "实现一个接口 ", 
"url" : "_cds_implementing_interface.html#UUID-4357ee1b-de95-b6cf-0c34-d4c867466ac7_section-idm4538086982283232656593653643", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 实现一个接口 \/ 实现一个接口 ", 
"snippet" : "接口的实现基于面向对象编程的概念。您还可以通过通用接口以相同的方式使用不同但相似的功能块。 实现接口的功能块必须包含该接口中定义的所有方法和属性（接口方法和接口属性）。这意味着：相应方法或属性的名称、输入和输出必须完全相同。 当您创建一个实现接口的新功能模块时，添加 CODESYS 自动在树中新功能模块下方输入该接口的所有方法和属性。 之后，如果您向接口添加更多方法，则添加 CODESYS 这些方法不会自动添加到相关的功能模块中。对于更新，您必须明确使用命令 实现接口 选择。 在派生功能块的情况下，您必须确保从接口“继承”采用的方法或属性接收所需的实现，或者如果要使用基础中的实现，则将其删除。...", 
"body" : "接口的实现基于面向对象编程的概念。您还可以通过通用接口以相同的方式使用不同但相似的功能块。 实现接口的功能块必须包含该接口中定义的所有方法和属性（接口方法和接口属性）。这意味着：相应方法或属性的名称、输入和输出必须完全相同。 当您创建一个实现接口的新功能模块时，添加 CODESYS 自动在树中新功能模块下方输入该接口的所有方法和属性。 之后，如果您向接口添加更多方法，则添加 CODESYS 这些方法不会自动添加到相关的功能模块中。对于更新，您必须明确使用命令 实现接口 选择。 在派生功能块的情况下，您必须确保从接口“继承”采用的方法或属性接收所需的实现，或者如果要使用基础中的实现，则将其删除。您将收到相应的翻译错误消息或警告，由自动插入的 pragma 属性引发。请查看命令的帮助页面 实现接口 . 您必须先将功能块的接口分配给接口类型的变量，然后才能通过该变量调用方法。 接口类型的变量始终是分配的功能块实例的引用。 接口类型变量是对功能块实例的引用。这样的变量可以引用任何实现该接口的功能块。如果没有对变量进行赋值，则变量包含在线模式下的值 0 . 例子 界面 I1 包含方法 GetName . METHOD GetName : STRING 功能块 A 和 B 每个都实现接口 I1 ： FUNCTION_BLOCK A IMPLEMENTS I1\nFUNCTION_BLOCK B IMPLEMENTS I1 因此，两个功能模块都必须有一个名称为的方法 GetName 和返回类型 STRING 包含。否则编译器会报错。 函数包含接口类型变量的声明 I1 . FUNCTION DeliverName : STRING\nVAR_INPUT\n l_i : I1;\nEND_VAR 接口的功能块 I1 实现，可以分配给这个输入变量。 函数调用示例： DeliverName(l_i := A_instance); \/\/ call with instance of type A\nDeliverName(l_i := B_instance); \/\/ call with instance of type B 调用接口方法： 在这种情况下，这取决于实际类型 l_i 从是否申请 A.GetName 或者 B.GetName 来电。 DeliverName := l_i.GetName(); " }, 
{ "title" : "在新功能模块中实现接口 ", 
"url" : "_cds_implementing_interface.html#UUID-4357ee1b-de95-b6cf-0c34-d4c867466ac7_id_de36840f50d462dc0a8640e016628e4_id_c92d2957f9591e5dc0a8640e00619caf", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 实现一个接口 \/ 在新功能模块中实现接口 ", 
"snippet" : "要求：当前打开的项目至少有一个接口对象。 选择 应用 在设备树中并选择菜单命令 项目→添加对象→POU . 对话 添加 POU 打开。 在输入字段中输入新功能模块的名称 姓 一个，例如 POU_Im . 选择 功能模块 . 选择 实施的 并点击按钮 . 在入口助手中，从类别中选择 接口 以界面为例 ITF1 并点击 行 . 要添加另一个接口，请再次单击 并选择另一个界面。 您可以选择拥有一个 访问修饰符 用于选择列表中的新功能模块。 从下拉列表中选择 实现语言 例如 结构化文本（ST） 出去。 点击 添加 . CODESYS 添加功能块 POU_Ex 进入设备树并打开编辑器。第一行说： FUN...", 
"body" : "要求：当前打开的项目至少有一个接口对象。 选择 应用 在设备树中并选择菜单命令 项目→添加对象→POU . 对话 添加 POU 打开。 在输入字段中输入新功能模块的名称 姓 一个，例如 POU_Im . 选择 功能模块 . 选择 实施的 并点击按钮 . 在入口助手中，从类别中选择 接口 以界面为例 ITF1 并点击 行 . 要添加另一个接口，请再次单击 并选择另一个界面。 您可以选择拥有一个 访问修饰符 用于选择列表中的新功能模块。 从下拉列表中选择 实现语言 例如 结构化文本（ST） 出去。 点击 添加 . CODESYS 添加功能块 POU_Ex 进入设备树并打开编辑器。第一行说： FUNCTION_BLOCK POU_Im IMPLEMENTS ITF1 接口及其方法和属性现在插入到功能块下的设备树中，您现在可以在接口及其方法的实现部分输入程序代码。 " }, 
{ "title" : "在现有功能块中实现接口 ", 
"url" : "_cds_implementing_interface.html#UUID-4357ee1b-de95-b6cf-0c34-d4c867466ac7_id_de36840f50d462dc0a8640e016628e4_id_dce21526b91b0bfbc0a8640e001af42d", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 实现一个接口 \/ 在现有功能块中实现接口 ", 
"snippet" : "要求：当前打开的项目有一个功能块，例如 POU_Im 和至少一个接口对象，例如 ITF1 . 双击设备树中的 POU POU_Ex(FB) . POU 的编辑器打开。 展开现有的顶行条目 FUNCTION_BLOCK POU_Im 和 IMPLEMENTS ITF1 . 功能块 POU_Im 实现接口 ITF1 ....", 
"body" : "要求：当前打开的项目有一个功能块，例如 POU_Im 和至少一个接口对象，例如 ITF1 . 双击设备树中的 POU POU_Ex(FB) . POU 的编辑器打开。 展开现有的顶行条目 FUNCTION_BLOCK POU_Im 和 IMPLEMENTS ITF1 . 功能块 POU_Im 实现接口 ITF1 . " }, 
{ "title" : "扩展接口 ", 
"url" : "_cds_extending_interface.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 扩展接口 ", 
"snippet" : "您可以扩展接口以及功能模块。然后，接口除了自己的之外，还获取基本接口的接口方法和接口属性。 创建一个扩展另一个接口的接口。 选择对象 应用 在设备树中。 选择命令 项目 → 添加对象 → 界面 . 对话 添加接口 打开。 输入新接口的名称。 激活选项 先进的 并点击按钮 . 输入帮助打开。 从类别中选择 接口 选择要被新接口扩展的接口。...", 
"body" : "您可以扩展接口以及功能模块。然后，接口除了自己的之外，还获取基本接口的接口方法和接口属性。 创建一个扩展另一个接口的接口。 选择对象 应用 在设备树中。 选择命令 项目 → 添加对象 → 界面 . 对话 添加接口 打开。 输入新接口的名称。 激活选项 先进的 并点击按钮 . 输入帮助打开。 从类别中选择 接口 选择要被新接口扩展的接口。 " }, 
{ "title" : "方法调用 ", 
"url" : "_cds_method_call.html", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 方法调用 ", 
"snippet" : "为了实现方法调用，实际参数（参数）被传递给接口变量。或者，可以省略参数名称。 根据声明的访问修饰符，方法只能在其自己的命名空间中使用（ INTERNAL )，仅在自己的编程块及其衍生物内 ( PROTECTED ）或仅在您自己的编程块内（ PRIVATE ） 叫做。在 PUBLIC 该方法可以在任何地方调用。 在实现中，方法可以递归地调用自身，或者直接通过 这 指针，或通过指定功能块的局部变量。...", 
"body" : "为了实现方法调用，实际参数（参数）被传递给接口变量。或者，可以省略参数名称。 根据声明的访问修饰符，方法只能在其自己的命名空间中使用（ INTERNAL )，仅在自己的编程块及其衍生物内 ( PROTECTED ）或仅在您自己的编程块内（ PRIVATE ） 叫做。在 PUBLIC 该方法可以在任何地方调用。 在实现中，方法可以递归地调用自身，或者直接通过 这 指针，或通过指定功能块的局部变量。 " }, 
{ "title" : "方法调用作为虚函数调用 ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_933ec828942a17e2c0a86463080c36ba", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 方法调用 \/ 方法调用作为虚函数调用 ", 
"snippet" : "继承会导致虚函数调用。 虚函数调用允许程序源代码中的相同调用在运行时调用不同的方法。 在以下情况下，方法调用是动态绑定的： 您使用指向功能模块的指针调用方法。 例子： pfub^.method 在这种情况下，指针可以指向功能块类型的实例和所有派生功能块的实例。 您调用接口变量的方法。 例子： interface1.method 该接口可以引用实现该接口的功能块的所有实例。 一个方法调用同一个功能模块的另一个方法。在这种情况下，该方法也可以调用同名的派生功能块的方法。 使用对功能模块的引用来调用方法。在这种情况下，引用可以指向功能块类型的实例和所有派生功能块的实例。 你指出 VAR_IN_OUT...", 
"body" : "继承会导致虚函数调用。 虚函数调用允许程序源代码中的相同调用在运行时调用不同的方法。 在以下情况下，方法调用是动态绑定的： 您使用指向功能模块的指针调用方法。 例子： pfub^.method 在这种情况下，指针可以指向功能块类型的实例和所有派生功能块的实例。 您调用接口变量的方法。 例子： interface1.method 该接口可以引用实现该接口的功能块的所有实例。 一个方法调用同一个功能模块的另一个方法。在这种情况下，该方法也可以调用同名的派生功能块的方法。 使用对功能模块的引用来调用方法。在这种情况下，引用可以指向功能块类型的实例和所有派生功能块的实例。 你指出 VAR_IN_OUT - 基本功能块类型的变量到派生 FB 类型的实例。 在这种情况下，变量可以指向功能块类型的实例以及所有派生功能块的实例。 " }, 
{ "title" : "例子 ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_e72629c73f4956dbc0a864635fb6e156", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 方法调用 \/ 例子 ", 
"snippet" : "方法重载 功能块 fub1 和 fub2 扩展功能块 fubbase 并实现接口 interface1 .有方法 method1 和 method2 . PROGRAM PLC_PRG VAR_INPUT b : BOOL; END_VAR VAR pInst : POINTER TO fubbase; instBase : fubbase; inst1 : fub1; inst2 : fub2; instRef : REFERENCE to fubbase; END_VAR IF b THEN instRef REF= inst1; (* reference to fub1 *) pInst...", 
"body" : "方法重载 功能块 fub1 和 fub2 扩展功能块 fubbase 并实现接口 interface1 .有方法 method1 和 method2 . PROGRAM PLC_PRG\nVAR_INPUT\n b : BOOL;\nEND_VAR\n\nVAR pInst : POINTER TO fubbase;\n instBase : fubbase;\n inst1 : fub1;\n inst2 : fub2;\n instRef : REFERENCE to fubbase;\nEND_VAR\n\nIF b THEN\n instRef REF= inst1; (* reference to fub1 *)\n pInst := ADR(instBase);\nELSE\n instRef REF= inst2; (* reference to fub2 *)\n pInst := ADR(inst1);\nEND_IF\npInst^.method1(); (* If b is TRUE, fubbase.method1 will be called, otherwise fub1.method1 is called *)\ninstRef.method1(); (* If b ist TRUE, fub1.method1 will be called, otherwise fub2.method1 is called*) 假如说 fubbase 上面例子中的两种方法 method1 和 method2 包含，覆盖 fub1 method2 ， 但不是 method1 .的呼唤 method1 发生如下： pInst^.method1(); 什么时候 b TRUE 是，调用 CODESYS fubbase.method1 向上，否则 fub1.method1 . " }, 
{ "title" : "额外的出口 ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_72802afb093e52c0c0a8640e0111714b", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 方法调用 \/ 额外的出口 ", 
"snippet" : "根据 IEC 61131-3 标准，方法与正常功能一样，可以声明附加输出。调用该方法时，您将变量分配给其他输出。 您可以在“功能”主题下找到这方面的详细信息。 调用时的语法 <function block name>.<method name>(<first input name> := <value> (, <further input assignments>)+ , <first output name> => <first output variable name> (,<further output assignments>)+ ); 例子 宣言 METHOD PUBLIC DoIt...", 
"body" : "根据 IEC 61131-3 标准，方法与正常功能一样，可以声明附加输出。调用该方法时，您将变量分配给其他输出。 您可以在“功能”主题下找到这方面的详细信息。 调用时的语法 <function block name>.<method name>(<first input name> := <value> (, <further input assignments>)+ , <first output name> => <first output variable name> (,<further output assignments>)+ ); 例子 宣言 METHOD PUBLIC DoIt : BOOL\nVAR_INPUT\n iInput_1 : DWORD;\n iInput_2 : DWORD;\nEND_VAR\nVAR_OUTPUT\n iOutput_1 : INT;\n sOutput_2 : STRING;\nENDVAR 称呼 fbInstance.DoIt(iInput_1 := 1, iInput_2 := 2, iOutput_1 => iLocal_1, sOUtput_2 => sLocal_2); 当方法被调用时，方法输出的值被写入本地声明的输出变量。 " }, 
{ "title" : "即使应用程序处于 STOP 状态也调用方法 ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_7f4f002a7a7c22c7c0a864630de7909a", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 方法调用 \/ 即使应用程序处于 STOP 状态也调用方法 ", 
"snippet" : "可以在设备描述中定义某个功能块实例（库块的）在一个任务周期中总是调用某个方法。如果该方法采用以下示例的输入参数，则它可以工作 CODESYS 当活动应用程序当前处于 STOP 状态时，该方法也会启动： 例子 VAR_INPUT pTaskInfo : POINTER TO DWORD; pApplicationInfo: POINTER TO _IMPLICIT_APPLICATION_INFO; END_VAR (*Now the status of the application can be queried via pApplicationInfo and the instruction...", 
"body" : "可以在设备描述中定义某个功能块实例（库块的）在一个任务周期中总是调用某个方法。如果该方法采用以下示例的输入参数，则它可以工作 CODESYS 当活动应用程序当前处于 STOP 状态时，该方法也会启动： 例子 VAR_INPUT\n pTaskInfo : POINTER TO DWORD;\n pApplicationInfo: POINTER TO _IMPLICIT_APPLICATION_INFO;\nEND_VAR\n\n(*Now the status of the application can be queried via pApplicationInfo and the instructions can be implemented: *)\n\nIF pApplicationInfo^.udState = 1 THEN <instructions> END_IF; " }, 
{ "title" : "递归调用方法 ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_18143ba7942a17e2c0a8646355ab3f2a", 
"breadcrumbs" : "CODESYS Essentials \/ 程序申请 \/ 面向对象编程 \/ 方法调用 \/ 递归调用方法 ", 
"snippet" : "主要使用递归来操作递归数据类型，例如链表。通常，建议在使用递归时要小心。意外的深度递归可能导致堆栈溢出，从而导致机器停止。 在其实现中，方法可以调用自身： 直接通过 这 指针 间接使用基本功能块的本地功能块实例 这种递归调用通常会发出编译器警告。如果带有pragma的方法 {attribute 'estimated-stack-usage' := '<estimated stack size in bytes>'} 提供，编译器警告被抑制。在章节中 属性 'estimated-stack-usage 查看一个实现示例。...", 
"body" : "主要使用递归来操作递归数据类型，例如链表。通常，建议在使用递归时要小心。意外的深度递归可能导致堆栈溢出，从而导致机器停止。 在其实现中，方法可以调用自身： 直接通过 这 指针 间接使用基本功能块的本地功能块实例 这种递归调用通常会发出编译器警告。如果带有pragma的方法 {attribute 'estimated-stack-usage' := '<estimated stack size in bytes>'} 提供，编译器警告被抑制。在章节中 属性 'estimated-stack-usage 查看一个实现示例。 " }, 
{ "title" : "使用控制器网络 ", 
"url" : "_cds_struct_dataexchange.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 ", 
"snippet" : "具有以下功能， CODESYS 支持控制器 (PLC) 之间的通信以及在 PLC 下方插入安全控制器： 图标配置 ：为应用程序中的变量创建 CODESYS 具有特定访问权限的图标。您可以使用这些符号从外部访问变量，例如从 OPC 服务器。 数据源管理器 ：管理连接设置和数据传输到远程设备（数据源） 传输的数据在可视化或本地应用程序中访问的数据源变量中映射。这方面的一个示例是控制远程设备并将设备状态显示为 HMI 应用程序的控制面板。 网络变量 ：网络变量是网络中不同控制器可以访问其值的变量。变量必须在发射器设备和接收器设备中的严格、相同的列表中定义。这些列表分配给应用程序，但可以位于不同的项目...", 
"body" : "具有以下功能， CODESYS 支持控制器 (PLC) 之间的通信以及在 PLC 下方插入安全控制器： 图标配置 ：为应用程序中的变量创建 CODESYS 具有特定访问权限的图标。您可以使用这些符号从外部访问变量，例如从 OPC 服务器。 数据源管理器 ：管理连接设置和数据传输到远程设备（数据源） 传输的数据在可视化或本地应用程序中访问的数据源变量中映射。这方面的一个示例是控制远程设备并将设备状态显示为 HMI 应用程序的控制面板。 网络变量 ：网络变量是网络中不同控制器可以访问其值的变量。变量必须在发射器设备和接收器设备中的严格、相同的列表中定义。这些列表分配给应用程序，但可以位于不同的项目中。 一个 安全控制器 可以插入到设备树中的 PLC 下方。安全控制器与现场设备、控制器网络和开发系统的通信链路通过该控制器进行路由。有关更多信息，请参阅： 下级安全控制器这 数据服务器 对象已过时。 与数据链接 CODESYS 在 SP10 及更高版本中，DataServer 已被具有数据源的数据链接所取代。该功能现已完全删除 CODESYS 3.5 SP17 及更高版本。 如果您想调整现有项目 数据服务器 对象，您可以执行以下操作： 打开现有项目 CODESYS V3.5 SP16，选择数据服务器对象，点击 将数据服务器转换为数据源管理器 在上下文菜单中。数据链接转换为数据源连接后，可以用当前 CODESYS 版本。 有关更多信息，请参阅： 地址结构 和 寻址和路由" }, 
{ "title" : "网络和寻址 ", 
"url" : "_cds_f_networktopology_addressing.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 \/ 网络和寻址 ", 
"snippet" : "分层构建控制网络，使广泛的自配置成为可能。 在 CODESYS ，网络拓扑被映射到唯一的地址，并且路由算法通过结构化地址保持简单。在系统启动期间存在直接和相对寻址以及自动地址确定。...", 
"body" : "分层构建控制网络，使广泛的自配置成为可能。 在 CODESYS ，网络拓扑被映射到唯一的地址，并且路由算法通过结构化地址保持简单。在系统启动期间存在直接和相对寻址以及自动地址确定。 " }, 
{ "title" : "网络拓扑结构 ", 
"url" : "_cds_networktopology.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 \/ 网络和寻址 \/ 网络拓扑结构 ", 
"snippet" : "控制网络拓扑的信息和建议 建议建立一个网络系统，以便以下内容成为可能： 广泛的自配置（地址分配） 对每种通信媒体的透明支持 在不同网络之间传输数据包 路由机制应该非常简单，以至于每个网络节点都可以重新路由数据包，即使它的内存容量很低。因此，避免在运行时使用大量的路由表、复杂的计算或查询。 分层构建控制网络。每个节点可以拥有一个父节点和任意数量的子节点。没有父节点的节点是“顶级”节点。不允许循环，即每个控制网络都具有树结构。 父子关系源于特定网络区域的规范。例如，网络区域可以是本地以太网或串行点对点连接。我们区分主网络（mainnet）和子网络（subnet）。每个节点最多属于一个主网络，其父节...", 
"body" : "控制网络拓扑的信息和建议 建议建立一个网络系统，以便以下内容成为可能： 广泛的自配置（地址分配） 对每种通信媒体的透明支持 在不同网络之间传输数据包 路由机制应该非常简单，以至于每个网络节点都可以重新路由数据包，即使它的内存容量很低。因此，避免在运行时使用大量的路由表、复杂的计算或查询。 分层构建控制网络。每个节点可以拥有一个父节点和任意数量的子节点。没有父节点的节点是“顶级”节点。不允许循环，即每个控制网络都具有树结构。 父子关系源于特定网络区域的规范。例如，网络区域可以是本地以太网或串行点对点连接。我们区分主网络（mainnet）和子网络（subnet）。每个节点最多属于一个主网络，其父节点如果存在也属于该主网络。对于每个节点，可以配置任意数量的子网，节点在每种情况下都充当父节点。 一个网络区域可能只有一个父节点。因此，将一个网络区域同时定义为多个节点的子网的配置是无效的。 " }, 
{ "title" : "寻址和路由 ", 
"url" : "_cds_addressing_routing.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 \/ 网络和寻址 \/ 寻址和路由 ", 
"snippet" : "寻址意味着：控制网络的拓扑被映射到唯一的地址。 一个节点地址是分层组成的： 对于每个网络连接，相关的块驱动程序确定一个本地地址，该地址唯一地标识本地网络中的节点。完整的节点地址形成如下：本地地址被添加到父节点分配的本地网络的子网索引中。反过来，子网索引放在父节点地址的前面。 因此，子网索引的长度（以位为单位）由设备确定。相反，本地地址的长度由网络类型决定。 没有主网络的节点是地址为 0 的顶级节点。主网络不包含父节点的节点同样是顶级节点。它被赋予主网络的本地地址。 在此处查看控制网络的示例： 在示例中，节点的地址以十六进制表示法表示。前 4 位数字代表各自父节点在主网中的地址，例如 0x007...", 
"body" : "寻址意味着：控制网络的拓扑被映射到唯一的地址。 一个节点地址是分层组成的： 对于每个网络连接，相关的块驱动程序确定一个本地地址，该地址唯一地标识本地网络中的节点。完整的节点地址形成如下：本地地址被添加到父节点分配的本地网络的子网索引中。反过来，子网索引放在父节点地址的前面。 因此，子网索引的长度（以位为单位）由设备确定。相反，本地地址的长度由网络类型决定。 没有主网络的节点是地址为 0 的顶级节点。主网络不包含父节点的节点同样是顶级节点。它被赋予主网络的本地地址。 在此处查看控制网络的示例： 在示例中，节点的地址以十六进制表示法表示。前 4 位数字代表各自父节点在主网中的地址，例如 0x007A=122 为了 PLC1 .下一个字节（蓝色字体）为子网索引保留，后跟本地地址（例如： C=12 对于节点 ID 12 ）。地址的结构使得精简路由算法成为可能。例如，路由表是不必要的。信息仅在本地查询：通过它自己的地址和通过父节点的地址。在此基础上，节点可以正确处理数据包： 如果目标地址对应于当前节点的地址，那么这就是接收者。 如果目标地址以当前节点的地址开头，则数据包要么直接用于子节点，要么用于节点的后代，并且必须转发。 在所有其他情况下，接收者不是当前节点的后代，数据包必须转发给它自己的父节点。 相对寻址 是一种特殊情况：相对地址不包含接收者的节点号，而是直接描述从发送者到接收者的路径。原理类似于文件系统中的相对路径：地址由包必须向上传输的步数组成。这些是到相应父节点和从后续路径向下到目标节点的步骤。 相对寻址的优点是如果整个子树移动到整个网络的另一个地方，同一子树中的两个节点可以继续通信。尽管由于这种偏移而必须修改绝对节点寻址，但相对寻址仍然有效。 地址确定 一个节点要知道它自己的地址，它必须要么知道它的父节点的地址，要么知道它是一个顶级节点。为此，节点在启动期间向所有网络设备分派消息以进行地址确定。只要它没有收到对该消息的响应，该节点就认为自己是顶级节点，但会继续搜索可能的父节点。父节点通过宣布其地址来响应。因此，节点将独立完成其地址并将其公布给子网。 地址确定可以在启动期间或在用于编程的 PC 的请求下完成。 " }, 
{ "title" : "地址结构 ", 
"url" : "_cds_address_structures.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 \/ 网络和寻址 \/ 地址结构 ", 
"snippet" : "广播地址 有两种类型的广播 - 全局和本地。全球广播被发送到网络中的所有节点。为此目的保留长度为 0 的空节点地址。 本地广播被发送到网络区域中的所有设备。为此，网络地址的所有位都设置为 1。这在相对地址和绝对地址中都是允许的。 块驱动程序必须能够处理这两种广播地址。这意味着必须解释空网络地址以及位都设置为 1 的网络地址并将其发送给所有相关参与者。...", 
"body" : "广播地址 有两种类型的广播 - 全局和本地。全球广播被发送到网络中的所有节点。为此目的保留长度为 0 的空节点地址。 本地广播被发送到网络区域中的所有设备。为此，网络地址的所有位都设置为 1。这在相对地址和绝对地址中都是允许的。 块驱动程序必须能够处理这两种广播地址。这意味着必须解释空网络地址以及位都设置为 1 的网络地址并将其发送给所有相关参与者。 " }, 
{ "title" : "网络地址 ", 
"url" : "_cds_address_structures.html#UUID-1f5ea387-c992-0bd7-9dee-0f8dc5aae773_id_ea3da72c61131dc0a8640e000e39f6_id_da141d38484f787cc0a8640e00d982a5", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 \/ 网络和寻址 \/ 地址结构 \/ 网络地址 ", 
"snippet" : "网络地址表示网络类型的地址（例如 IP）到控制网络内的逻辑地址的映射。此映射由相应的块驱动程序执行。对于以太网中具有“C 类”IP 地址的所有网络设备，IP 地址的前三个字节都是相同的。因此，IP 地址的最后 8 位足以作为网络地址，因为它们可以在块驱动程序上的两个地址之间进行明确的映射。 对于每个网络连接，节点具有不同的网络地址。不同的网络连接可以具有相同的网络地址，因为每个地址只需在本地是唯一的。 术语：主网中的网络地址通常指定为节点的网络地址，没有指定网络连接。 网络地址的长度以位为单位指定，并且可以由块驱动程序根据需要进行选择。同一网络区域内的所有节点必须使用相同的长度。网络地址由一个...", 
"body" : "网络地址表示网络类型的地址（例如 IP）到控制网络内的逻辑地址的映射。此映射由相应的块驱动程序执行。对于以太网中具有“C 类”IP 地址的所有网络设备，IP 地址的前三个字节都是相同的。因此，IP 地址的最后 8 位足以作为网络地址，因为它们可以在块驱动程序上的两个地址之间进行明确的映射。 对于每个网络连接，节点具有不同的网络地址。不同的网络连接可以具有相同的网络地址，因为每个地址只需在本地是唯一的。 术语：主网中的网络地址通常指定为节点的网络地址，没有指定网络连接。 网络地址的长度以位为单位指定，并且可以由块驱动程序根据需要进行选择。同一网络区域内的所有节点必须使用相同的长度。网络地址由一个字节数组表示，编码方式如下： 网络地址长度：n位 所需字节：b = (n + 7) DIV 8 第一个字节的最低等级的 (n MOD 8) 位和所有其他 (n DIV 8) 位用于网络地址。 网络地址编码示例 长度：11 位 地址：111 1000 1100 " }, 
{ "title" : "节点地址 ", 
"url" : "_cds_address_structures.html#UUID-1f5ea387-c992-0bd7-9dee-0f8dc5aae773_id_ea3da72c61131dc0a8640e000e39f6_id_b9feccb2484f787fc0a8640e00b13107", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 \/ 网络和寻址 \/ 地址结构 \/ 节点地址 ", 
"snippet" : "节点地址表示控制网络中节点的绝对地址，因此在整个“网络树”中是唯一的。地址由最多 15 个地址分量组成，每个分量占 2 个字节。节点在网络层次结构中的位置越低，其地址就越长。 完整的节点地址由前面所有节点的部分地址和节点本身的部分地址组成。每个部分地址由一个或多个地址分量组成。因此，长度始终是 2 个字节的倍数。节点的部分地址由该节点在其主网络中的网络地址和在父节点的情况下主网络的子网索引构成。子索引所需的位由父节点的路由器确定。可以在子网索引和网络地址之间插入填充位，以确保部分地址的长度是 2 个字节的倍数。 特别案例： 没有网络的节点：这意味着主网络中既没有子网索引也没有网络地址。在这种情...", 
"body" : "节点地址表示控制网络中节点的绝对地址，因此在整个“网络树”中是唯一的。地址由最多 15 个地址分量组成，每个分量占 2 个字节。节点在网络层次结构中的位置越低，其地址就越长。 完整的节点地址由前面所有节点的部分地址和节点本身的部分地址组成。每个部分地址由一个或多个地址分量组成。因此，长度始终是 2 个字节的倍数。节点的部分地址由该节点在其主网络中的网络地址和在父节点的情况下主网络的子网索引构成。子索引所需的位由父节点的路由器确定。可以在子网索引和网络地址之间插入填充位，以确保部分地址的长度是 2 个字节的倍数。 特别案例： 没有网络的节点：这意味着主网络中既没有子网索引也没有网络地址。在这种情况下，地址设置为 0x0000。 主网络中没有父节点的节点：在这种情况下，假定子网索引长度为 0。部分地址对应于网络地址，必要时由填充位扩展。 节点地址示例 节点地址始终以十六进制指定。各个地址组件（每种情况下两个字节）由冒号“:”分隔。由于这表示字节数组而不是 16 位值，因此组件不会以 Intel 格式显示。对于手动输入的地址，地址组件中的缺失部分由前导零补充：\" 274 “=” 0274 \"。为了提高易读性，显示还应始终包含前导零。 绝对地址和相对地址 两个节点之间的通信可以基于相对地址或绝对地址。绝对地址与节点地址相同。相对地址指定从发送者到接收者的路径。它们由地址偏移和到接收器的下行路径组成。 （负）地址偏移量描述了一个包在被公共父节点向下传递之前必须在树中向上传递的地址分量的数量。由于节点可以使用由多个组件组成的部分地址，因此要传递的父组件的数量始终等于地址偏移量。这意味着父节点之间的界限不再清晰。出于这个原因，通信伙伴地址的公共起始地址被用作父地址。每个地址分量都被算作一个向上的步骤，与当前的父节点无关。这种假设导致的每个错误都可以被相应的父节点检测到，并且必须由它相应地处理。 在到达公共父节点之后，作为地址组件数组的相对路径像往常一样向下跟随。形式上：接收者的节点地址是通过从发送者的节点地址中去除最后的地址偏移分量并将相对路径附加到剩余地址而形成的。 节点地址的形成示例 在以下示例中，每个地址组件都由一个字母表示；在每种情况下，一个点将节点彼此分开。由于一个节点可以携带多个地址组件，因此示例中的一些地址组件用多个字母表示。 节点 A： a.bc.d.ef.g 节点 B： a.bc.i.j.kl.m 最少共同父母的地址： a.bc A到B的相对地址： -4\/i.j.kl.m 数字 4 来自 4 个组件—— d , e , f 和 g – 它必须向上转发数据包。 为了保证路由的正确运行，每次经过中间节点时都必须调整相对地址。调整地址偏移量就足够了。这始终由父节点完成。如果一个节点从它的一个子网接收到一个数据包，地址偏移量会增加这个子网的地址分量的长度。 如果新地址偏移<0，则数据包必须进一步向上传递。 如果地址偏移量>= 0，则数据包必须从地址偏移量开始传递给本地地址对应相对路径的子节点。但是，首先地址偏移量必须增加子节点本地地址的长度，这样子节点才能看到正确的地址。 如果在共同父节点的确定过程中出现上述错误，则产生一种特殊情况。在这种情况下，实际父节点的地址偏移量为负，但该值大于包起源的子网的部分地址的长度。为了让下一个节点在这种情况下看到正确的相对地址，相关节点必须做以下事情：发现错误，根据前导节点的地址和长度差计算子节点的本地地址，并相应地调整地址偏移量。在这种情况下，地址组件本身也保持不变；只有偏移量被改变。 " }, 
{ "title" : "网络变量 ", 
"url" : "_cds_f_networkvariables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 \/ 网络变量 ", 
"snippet" : "网络变量的值可以在网络中的不同 PLC 之间交换。变量必须在发射器设备和接收器设备中以严格的、相同的列表定义，其中只有一个设备的应用程序可以定义网络变量。这些列表可以在一个或多个项目中。 发送方中的网络变量列表是一个全局变量列表，其中特定的日志和传输参数在其对象属性中定义。通过添加这些属性，您可以从普通的 GVL .您还可以插入一个 网络变量列表（发件人） 当该对象已经设置了这些参数时，该对象直接进入设备树。 接收器中的网络变量列表是 网络变量列表（接收方） 类型。创建一个时，选择服务器的相应网络变量列表。作为替代方案，您可以从从发件人列表生成的导出文件中读取此变量列表。无论如何，在另一个项目...", 
"body" : "网络变量的值可以在网络中的不同 PLC 之间交换。变量必须在发射器设备和接收器设备中以严格的、相同的列表定义，其中只有一个设备的应用程序可以定义网络变量。这些列表可以在一个或多个项目中。 发送方中的网络变量列表是一个全局变量列表，其中特定的日志和传输参数在其对象属性中定义。通过添加这些属性，您可以从普通的 GVL .您还可以插入一个 网络变量列表（发件人） 当该对象已经设置了这些参数时，该对象直接进入设备树。 接收器中的网络变量列表是 网络变量列表（接收方） 类型。创建一个时，选择服务器的相应网络变量列表。作为替代方案，您可以从从发件人列表生成的导出文件中读取此变量列表。无论如何，在另一个项目中定义发件人列表都需要一个导出文件。 网络变量仅在一个方向上作为广播传输：发送方到接收方。但是，设备也可以同时包含发送者和接收者列表。 为了 NetVarUdp 库版本 3.5.7.0 及更高版本，未选择确认传输时不再分配接收器通道。因此，一个硬件设备上的两个控制器之间也可以进行网络变量交换。 如果交换设备应该是发送方和接收方，那么变量列表标识符必须是唯一的，以防止异常操作。变量列表标识符在 特性 一个对话 GVL 目的。 在以下情况下，无法通过网络变量进行数据交换： 如果设备（目标系统）不支持 防火墙阻止通信。 如果另一个客户端或应用程序正在使用在网络变量列表的属性中设置的 UDP 端口 如果每个发送设备和接收设备有多个应用程序使用网络变量列表 只有具有用文字或常量定义的限制的数组才会传输到接收器应用程序。为此目的不允许使用常量表达式。 例子： ” arrVar : ARRAY[0..g_iArraySize-1] OF INT ; “不传输，但” arrVar : ARRAY[0..10] OF INT ; \"被传送。 网络变量的最大大小为 255 字节。网络变量的可能数量是无限的。 如果 GVL 的大小超过网络报文的最大长度，则数据被拆分为多个报文。根据配置，这可能会导致数据不一致。 在通过 UDP 从发送方到接收方传输数据的过程中，每个周期中的以下位置或事件都可能丢失数据： 发送方（网络驱动程序，-堆栈） 路由器 转变 网络冲突 接收器（网络驱动程序，-堆栈） 这就意味着接收方在一个周期内接收到的数据可能不是最新的，而是过时的。 当 PLC 与来自不同版本的开发系统（V2.3， V3 ）。但是，在这种情况下，您不能使用导出\/导入机制来精确匹配发送方和接收方项目中的变量列表。原因是一个变量导出文件（ *.exp ) 从 V2.3 生成的不包括创建接收 NVL 所需的信息量 V3 .没有相应的网络参数配置作为 GVL 文件，您之前从发送方导出了该文件。要获取此文件，您必须在中重新创建 V2.3 NVL V3 第一的。然后你可以生成一个导出文件并在其中创建一个接收NVL V3 基于此。 PLC 之间数据交换的替代方法是使用数据源。与交换网络变量的广播方法相反，定义的点对点连接是在一个应用程序和一个远程数据源之间创建的。 有关更多信息，请参阅： 网络变量" }, 
{ "title" : "配置网络变量交换 ", 
"url" : "_cds_configuring_network_variables_exchange.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 \/ 网络变量 \/ 配置网络变量交换 ", 
"snippet" : "在发送方设备和接收方设备之间交换网络变量需要执行以下步骤：...", 
"body" : "在发送方设备和接收方设备之间交换网络变量需要执行以下步骤： " }, 
{ "title" : "1、在发送端设备中创建网络变量列表并生成导出文件 ", 
"url" : "_cds_configuring_network_variables_exchange.html#UUID-4b2d41ce-8a83-dfc2-9447-e0ddcf072e25_id_e2da966febc27c7c0a8640e00b3ea15_id_31c0f718b4d8cb98c0a8640e01ec7ade", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 \/ 网络变量 \/ 配置网络变量交换 \/ 1、在发送端设备中创建网络变量列表并生成导出文件 ", 
"snippet" : "要求：将应用程序插入已用作发送设备的 PLC 的设备树中。 选择应用程序并插入 网络变量列表（发件人） 目的。在里面 添加网络变量列表（发件人） 对话框，配置以下设置： 网络类型： UDP （例子： \" NVL_Sender ”）。 双击 NVL 对象以打开相应的编辑器并键入网络变量的声明。例子： VAR_GLOBAL iglobvar:INT; bglobvar:BOOL; strglobvar:STRING; END_VAR 右键单击设备树中的 NVL 对象以打开 特性 .在里面 特性 对话框，打开 网络变量 标签。这显示了以下设置： 网络类型：UDP；列表标识符：1；打包变量；循环传输：...", 
"body" : "要求：将应用程序插入已用作发送设备的 PLC 的设备树中。 选择应用程序并插入 网络变量列表（发件人） 目的。在里面 添加网络变量列表（发件人） 对话框，配置以下设置： 网络类型： UDP （例子： \" NVL_Sender ”）。 双击 NVL 对象以打开相应的编辑器并键入网络变量的声明。例子： VAR_GLOBAL iglobvar:INT; bglobvar:BOOL; strglobvar:STRING; END_VAR 右键单击设备树中的 NVL 对象以打开 特性 .在里面 特性 对话框，打开 网络变量 标签。这显示了以下设置： 网络类型：UDP；列表标识符：1；打包变量；循环传输：每 50 ms。 注意：您还可以通过配置其网络变量属性将现有 GVL 转换为网络变量列表。 在里面 特性 的对话框 NVL_发件人 ， 点击 链接到文件 标签。定义文件名 <export>.gvl 以及 GVL 导出文件在文件系统中的位置。选择 编译前导出 选项。 点击 构建 → 构建 编译应用程序。 网络变量列表的导出文件现在位于定义的文件夹中。 " }, 
{ "title" : "2. 在接收设备中创建关联的网络变量列表 ", 
"url" : "_cds_configuring_network_variables_exchange.html#UUID-4b2d41ce-8a83-dfc2-9447-e0ddcf072e25_id_e2da966febc27c7c0a8640e00b3ea15_id_47ffe3b7829f11e3b1f793b077791a22", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 \/ 网络变量 \/ 配置网络变量交换 \/ 2. 在接收设备中创建关联的网络变量列表 ", 
"snippet" : "要求：设备树中存在发送设备和接收设备。具有任务配置的应用程序插入到设备下方。 NVL 或 GVL 在发送方设备下方创建为要发送的网络变量列表。 在设备树中选择接收器的应用，点击 添加对象→网络变量列表（接收者） . 这 添加网络变量列表（接收方） 对话框打开。 在对话框中，选择先前创建的发送设备 NVL 并指定名称（例如： “NVL_Receiver”）。 CODESYS 使用发送者列表中的变量声明自动填充此接收者列表。 注意：作为替代方案，您可以选择 从文件导入 选项并加载先前从发件人列表中生成的导出文件。...", 
"body" : "要求：设备树中存在发送设备和接收设备。具有任务配置的应用程序插入到设备下方。 NVL 或 GVL 在发送方设备下方创建为要发送的网络变量列表。 在设备树中选择接收器的应用，点击 添加对象→网络变量列表（接收者） . 这 添加网络变量列表（接收方） 对话框打开。 在对话框中，选择先前创建的发送设备 NVL 并指定名称（例如： “NVL_Receiver”）。 CODESYS 使用发送者列表中的变量声明自动填充此接收者列表。 注意：作为替代方案，您可以选择 从文件导入 选项并加载先前从发件人列表中生成的导出文件。 " }, 
{ "title" : "3. 测试网络变量交换 ", 
"url" : "_cds_configuring_network_variables_exchange.html#UUID-4b2d41ce-8a83-dfc2-9447-e0ddcf072e25_id_e2da966febc27c7c0a8640e00b3ea15_id_2f77f1a6b4d8cb98c0a8640e01956f55", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 \/ 网络变量 \/ 配置网络变量交换 \/ 3. 测试网络变量交换 ", 
"snippet" : "要求：发送方设备中存在网络变量列表（发送方），接收方设备中存在网络变量列表（接收方），且两个列表具有相同的变量声明。 在发送方设备中的应用程序下方，创建一个递增网络变量的程序。 例子： iglobvar:=iglobvar+1; 配置应用程序任务，以便该程序调用它。 在接收器设备中的应用程序下方，创建一个将此网络变量的值写入本地变量的程序。 例子： ilocalvar:=iglobvar; 配置应用程序任务，以便该程序调用它。 将这两个应用程序下载到控制器并启动它们。 （将应用程序设置为活动、登录、下载和启动） 在两个程序的编辑器的在线视图中，检查 iglobvar 接收者和发送者匹配。...", 
"body" : "要求：发送方设备中存在网络变量列表（发送方），接收方设备中存在网络变量列表（接收方），且两个列表具有相同的变量声明。 在发送方设备中的应用程序下方，创建一个递增网络变量的程序。 例子： iglobvar:=iglobvar+1; 配置应用程序任务，以便该程序调用它。 在接收器设备中的应用程序下方，创建一个将此网络变量的值写入本地变量的程序。 例子： ilocalvar:=iglobvar; 配置应用程序任务，以便该程序调用它。 将这两个应用程序下载到控制器并启动它们。 （将应用程序设置为活动、登录、下载和启动） 在两个程序的编辑器的在线视图中，检查 iglobvar 接收者和发送者匹配。 " }, 
{ "title" : "V2.3 和 V3 PLC 之间的网络变量通讯配置 ", 
"url" : "_cds_configuring_network_variables_exchange.html#UUID-4b2d41ce-8a83-dfc2-9447-e0ddcf072e25_id_e2da966febc27c7c0a8640e00b3ea15_id_ccea919a24784530c0a8640e014650de", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 \/ 网络变量 \/ 配置网络变量交换 \/ V2.3 和 V3 PLC 之间的网络变量通讯配置 ", 
"snippet" : "要求：V2.3 项目中存在一个全局变量列表，其中包含您想要读入的网络变量 V3 项目。在里面 V3 项目中，在 PLC 下方的设备树中，有一个应用程序，其中包含使用变量的程序。 打开 特性 V2.3 项目（发送方）中的 GVL 对话框。 将另一个 PLC 作为具有应用程序和任务的虚拟对象插入到项目中。然后在它下面创建V2.3 GVL，如下： 插入一个 网络变量列表（发件人） 虚拟应用程序下方名为“dummy23”的对象。 右键点击 假人23 打开 特性 对话。点击 网络属性 标签。键入与 V2.3 项目中的 GVL 相同的网络属性。 充满 假人23 具有与 V2.3 GVL 中相同的变量声明。...", 
"body" : "要求：V2.3 项目中存在一个全局变量列表，其中包含您想要读入的网络变量 V3 项目。在里面 V3 项目中，在 PLC 下方的设备树中，有一个应用程序，其中包含使用变量的程序。 打开 特性 V2.3 项目（发送方）中的 GVL 对话框。 将另一个 PLC 作为具有应用程序和任务的虚拟对象插入到项目中。然后在它下面创建V2.3 GVL，如下： 插入一个 网络变量列表（发件人） 虚拟应用程序下方名为“dummy23”的对象。 右键点击 假人23 打开 特性 对话。点击 网络属性 标签。键入与 V2.3 项目中的 GVL 相同的网络属性。 充满 假人23 具有与 V2.3 GVL 中相同的变量声明。 定义导出文件“dummy23.gvl”的位置 链接到文件 的选项卡 特性 为了 假人23 . 将虚拟控制器的应用程序设置为活动并单击 构建 → 生成代码 ( F11 ）。 当应用程序编译成功后， CODESYS 自动创建 dummy23.gvl 导出文件。 将物理 PLC 的应用设置为激活，然后右键打开 添加对象 对话。 选择 网络变量列表（接收方） 并指定一个名称（例如：“NVL_from_23”）。 选择 从文件导入 选项并选择 dummy23.gvl ，这是之前生成的。 查看 NVL_from_23 ，刚刚创建。您必须获得与 V2.3 项目中的发送方 GVL 中相同的变量声明。 有关更多信息，请参阅： 网络变量列表（发件人） 和 网络变量列表（接收方）" }, 
{ "title" : "下级安全控制器 ", 
"url" : "_cds_safety_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用控制器网络 \/ 下级安全控制器 ", 
"snippet" : "如果安全控制器低于标准控制器，则与开发系统的通信和数据交换通过标准控制器运行。安全控制器的通信链路可以中断影响标准控制器的命令的执行。您会为每个这些命令找到关于此的通知。 可能的中断 临时中断：在命令执行期间（例如：下载），与安全控制器的连接首先中断，然后自动重新可用。如果中断时间过长，则输出设备和连接的网络变量接收器安全控制器中可能会发生面向安全的反应。然后在安全控制器中，必须确认相应的通信错误（如果不是自动完成），以结束面向安全的反应。这会影响到其现场设备的连接以及与其他发送器安全控制器的网络变量接收器连接。如果连接的安全控制器带有网络变量发送器，则必须在其他安全控制器中确认通信错误。 永...", 
"body" : "如果安全控制器低于标准控制器，则与开发系统的通信和数据交换通过标准控制器运行。安全控制器的通信链路可以中断影响标准控制器的命令的执行。您会为每个这些命令找到关于此的通知。 可能的中断 临时中断：在命令执行期间（例如：下载），与安全控制器的连接首先中断，然后自动重新可用。如果中断时间过长，则输出设备和连接的网络变量接收器安全控制器中可能会发生面向安全的反应。然后在安全控制器中，必须确认相应的通信错误（如果不是自动完成），以结束面向安全的反应。这会影响到其现场设备的连接以及与其他发送器安全控制器的网络变量接收器连接。如果连接的安全控制器带有网络变量发送器，则必须在其他安全控制器中确认通信错误。 永久中断：命令的执行（例如：删除）导致中断再次被另一个操作（例如：下载）终止。由于中断，输出设备和连接的网络变量接收器安全控制器中可能会发生安全反应。中断结束后，必须在安全控制器中确认相应的通信错误（如果未自动完成），以结束安全反应。 有关更多信息，请参阅： 使用控制器网络" }, 
{ "title" : "将应用程序下载到 PLC ", 
"url" : "_cds_struct_application_transfer_to_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC ", 
"snippet" : "为了将您的应用程序传输到 PLC，必须正确编译程序并且必须设置 PLC 的连接设置。 如果与控制器的通信被加密和\/或仅限于特定用户，则您需要相应的证书和权限。看这里 设备用户管理的处理保护应用程序您可以在对话框中编辑与设备通信的基本安全策略 通讯设置 设备编辑器的选项卡。看这里： 加密通信，更改安全设置当满足这些要求时，应用程序会在登录时下载到 PLC。...", 
"body" : "为了将您的应用程序传输到 PLC，必须正确编译程序并且必须设置 PLC 的连接设置。 如果与控制器的通信被加密和\/或仅限于特定用户，则您需要相应的证书和权限。看这里 设备用户管理的处理保护应用程序您可以在对话框中编辑与设备通信的基本安全策略 通讯设置 设备编辑器的选项卡。看这里： 加密通信，更改安全设置当满足这些要求时，应用程序会在登录时下载到 PLC。 " }, 
{ "title" : "配置与 PLC 的连接 ", 
"url" : "_cds_configuring_connection_to_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC \/ 配置与 PLC 的连接 ", 
"snippet" : "通过网关建立与控制器的连接。此网关可以是您的开发计算机或连接到控制器的另一台网络计算机。这 通讯设置 对话框可用于配置连接路径。当您尝试登录但尚未配置通信设置时，此对话框会自动打开。 如果与控制器的通信通过用户管理进行加密和保护，则您需要相应的证书和凭据来建立与控制器的连接。在这种情况下，请参阅“加密通信和更改安全设置”帮助页面上的相关说明。 要求：项目可以无错误编译。可编程逻辑控制器 (PLC) 插入设备树中。设备需要使用用户管理，但未启用。 在设备树中，选择 PLC 并单击 项目 → 编辑对象 . PLC 在编辑器中打开。 点击 通讯设置 标签。 在菜单栏上，单击 扫描网络 . 这 选择设...", 
"body" : "通过网关建立与控制器的连接。此网关可以是您的开发计算机或连接到控制器的另一台网络计算机。这 通讯设置 对话框可用于配置连接路径。当您尝试登录但尚未配置通信设置时，此对话框会自动打开。 如果与控制器的通信通过用户管理进行加密和保护，则您需要相应的证书和凭据来建立与控制器的连接。在这种情况下，请参阅“加密通信和更改安全设置”帮助页面上的相关说明。 要求：项目可以无错误编译。可编程逻辑控制器 (PLC) 插入设备树中。设备需要使用用户管理，但未启用。 在设备树中，选择 PLC 并单击 项目 → 编辑对象 . PLC 在编辑器中打开。 点击 通讯设置 标签。 在菜单栏上，单击 扫描网络 . 这 选择设备 对话框打开。网络中的所有可用设备都显示在左侧。 选择所需的设备并单击 行 . 将打开一个对话框提示，提示设备需要用户管理，但尚未启用。如果需要，系统会提示您启用用户管理。将显示通知，在这种情况下，您必须创建一个新的管理员帐户，然后以该用户身份登录。 点击 是的 关闭对话框提示。 这 添加设备用户 对话框打开以创建初始设备管理员。 定义凭据（ 名称 和 密码 ) 用于设备管理员。选择 密码可由用户更改 选项。 您必须考虑密码的严重性：在开发系统中，如果您忘记密码，将无法再次访问控制器。 点击 行 关闭对话框。 这 设备用户登录 对话框打开。 为您在上一步中定义的设备管理员指定凭据。 设置 PLC 的连接路径。 您可以将通信设置视图重置为原始视图 CODESYS 设备编辑器的选项 . 有关更多信息，请参阅： 加密通信，更改安全设置" }, 
{ "title" : "加密通信，更改安全设置 ", 
"url" : "_cds_encrypting_communication_changing_security_policy.html", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC \/ 加密通信，更改安全设置 ", 
"snippet" : "数据保护建议 为了将违反数据安全的风险降到最低，我们建议对运行您的应用程序的系统采取以下组织和技术措施。尽可能避免将 PLC 和控制网络暴露于开放网络和 Internet。使用额外的数据链路层进行保护，例如用于远程访问的 VPN。安装防火墙机制。限制授权人员的访问。使用高强度密码。在调试时，更改任何现有的默认密码并定期更改。 使用受支持的安全功能 CODESYS 和相应的控制器，例如加密与控制器的通信和有意限制用户访问。 可以通过设备上的加密和用户管理来保护与设备的通信。您可以更改当前的安全预设 通讯设置 设备编辑器的选项卡。 有关更多信息和说明，请参阅： 使用证书加密通信，更改安全策略 SP...", 
"body" : "数据保护建议 为了将违反数据安全的风险降到最低，我们建议对运行您的应用程序的系统采取以下组织和技术措施。尽可能避免将 PLC 和控制网络暴露于开放网络和 Internet。使用额外的数据链路层进行保护，例如用于远程访问的 VPN。安装防火墙机制。限制授权人员的访问。使用高强度密码。在调试时，更改任何现有的默认密码并定期更改。 使用受支持的安全功能 CODESYS 和相应的控制器，例如加密与控制器的通信和有意限制用户访问。 可以通过设备上的加密和用户管理来保护与设备的通信。您可以更改当前的安全预设 通讯设置 设备编辑器的选项卡。 有关更多信息和说明，请参阅： 使用证书加密通信，更改安全策略 SPS 用户管理 " }, 
{ "title" : "设备用户管理的处理 ", 
"url" : "_cds_handling_user_management_on_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC \/ 设备用户管理的处理 ", 
"snippet" : "有关这方面的信息，请参阅： CODESYS 安全-用户管理\/管理设备的访问权限 使用密码、密码策略、登录锁...", 
"body" : "有关这方面的信息，请参阅： CODESYS 安全-用户管理\/管理设备的访问权限 使用密码、密码策略、登录锁 " }, 
{ "title" : "生成应用程序代码 ", 
"url" : "_cds_creating_application_code_for_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC \/ 生成应用程序代码 ", 
"snippet" : "应用程序代码是 PLC 在您启动应用程序时执行的机器代码。 CODESYS 从开发系统中编写的源代码自动生成应用程序代码。这是在将应用程序下载到控制器之前自动完成的。在生成应用程序代码之前，执行测试以检查分配、数据类型和库的可用性。此外，内存地址是在生成应用程序代码时分配的。 你可以点击 构建 → 生成代码 显式执行此命令。这对于检测源代码中的任何错误很有用，即使 PLC 尚未连接。错误在“构建”类别的消息视图中输出。 如果您已加密应用程序，请考虑以下信息： 如果在线更改后根据请求生成（新）引导应用程序，则引导应用程序在 RAM 中形成，当前代码未加密。 加密应用程序代码 有关更多信息，请参阅...", 
"body" : "应用程序代码是 PLC 在您启动应用程序时执行的机器代码。 CODESYS 从开发系统中编写的源代码自动生成应用程序代码。这是在将应用程序下载到控制器之前自动完成的。在生成应用程序代码之前，执行测试以检查分配、数据类型和库的可用性。此外，内存地址是在生成应用程序代码时分配的。 你可以点击 构建 → 生成代码 显式执行此命令。这对于检测源代码中的任何错误很有用，即使 PLC 尚未连接。错误在“构建”类别的消息视图中输出。 如果您已加密应用程序，请考虑以下信息： 如果在线更改后根据请求生成（新）引导应用程序，则引导应用程序在 RAM 中形成，当前代码未加密。 加密应用程序代码 有关更多信息，请参阅： 保护应用程序" }, 
{ "title" : "显式生成应用程序代码 ", 
"url" : "_cds_creating_application_code_for_plc.html#UUID-5c7fdea2-b927-dd81-e489-7c93454d6804_id_c4ec88dacce7d11bc0a8640e01d44e7d_id_0b4f2b8f2cd5acc8c0a8640e009372af", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC \/ 生成应用程序代码 \/ 显式生成应用程序代码 ", 
"snippet" : "要求：应用程序可以无错误地编译。 点击 构建→ 生成代码 . 生成应用程序代码。有关内存分配的详细信息在消息视图中输出。 有关更多信息，请参阅： 创建引导应用程序...", 
"body" : "要求：应用程序可以无错误地编译。 点击 构建→ 生成代码 . 生成应用程序代码。有关内存分配的详细信息在消息视图中输出。 有关更多信息，请参阅： 创建引导应用程序" }, 
{ "title" : "生成应用程序代码时的消息 ", 
"url" : "_cds_creating_application_code_for_plc.html#UUID-5c7fdea2-b927-dd81-e489-7c93454d6804_id_c4ec88dacce7d11bc0a8640e01d44e7d_id_624175cd2d47e684c0a8640e00e57d65", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC \/ 生成应用程序代码 \/ 生成应用程序代码时的消息 ", 
"snippet" : "当您生成应用程序代码时， CODESYS 在消息视图中输出有关内存分配的信息。由于增量内存构建，重新分配仅适用于新的和更改的 POU 和变量，因此会在内存中形成间隙。在线更改具有相同的效果。这种碎片减少了可用内存的数量。但是，您可以通过单击完全重新分配内存 干净的 并因此增加可用内存量。 语法错误和错误 CODESYS 在代码生成和内存分配期间检测到的信息也会在消息视图中输出（ 建造 类别）。 输出有关内存分配的信息： 生成代码的大小 （以字节为单位）：所有代码段的总和 全局数据的大小 （以字节为单位）：全局变量使用的总内存。除非输入或输出映射到全局变量区域，否则不包括输入和输出。 为代码和数...", 
"body" : "当您生成应用程序代码时， CODESYS 在消息视图中输出有关内存分配的信息。由于增量内存构建，重新分配仅适用于新的和更改的 POU 和变量，因此会在内存中形成间隙。在线更改具有相同的效果。这种碎片减少了可用内存的数量。但是，您可以通过单击完全重新分配内存 干净的 并因此增加可用内存量。 语法错误和错误 CODESYS 在代码生成和内存分配期间检测到的信息也会在消息视图中输出（ 建造 类别）。 输出有关内存分配的信息： 生成代码的大小 （以字节为单位）：所有代码段的总和 全局数据的大小 （以字节为单位）：全局变量使用的总内存。除非输入或输出映射到全局变量区域，否则不包括输入和输出。 为代码和数据分配的总内存大小 （以字节为单位）：分配的总内存由已使用的内存区域加上保留的、尚未用于增量构建和在线更改的内存组成。在第一次构建之后，已经使用的内存大约等于最高使用的地址（见下文）。最大的连续内存间隙（见下文）仍然大致对应于总分配内存的差异。但是，随着增量构建和在线更改数量的增加，内存间隙的数量也会增加，最大的连续内存间隙变得更小。 存储区 <n> : 各个保留存储区的内容： 背景：取决于 PLC 将哪些数据和代码存储在哪些存储区。例如，代码和数据位于同一区域 CODESYS Control Win .对于地址 %I , %M ， 和 %Q , 内存总是保留的，即使变量没有分配给地址。在“清理”应用程序后，内存被完全重新分配。在这种情况下，预定义的“对齐”（通常为 8）可能会导致小间隙。较大的间隙是由于没有“清理”而更改日期导致的，例如通过增加数组区域。在这种情况下，仅重新编译受影响的 POU。此外，在在线更改的情况下，内存仅用于新变量和新代码。先前由已删除的变量和代码保留的内存再次可用。因此，在许多增量构建和在线更改之后可能会出现内存碎片。这会产生许多在某些情况下可能根本无法使用的小间隙。为了明确有多少内存是安全可用的，在代码生成过程中会输出内存区域的“最大连续内存间隙”。 最高使用地址 （字节）：这是整个分配的内存区域中的最高保留地址。在“清理”操作后的第一次构建期间，内存地址按升序输出到变量，同时考虑到对齐（通常为 8 个字节）。因此，此时使用的最高地址大致对应于使用的内存量。分配的其余内存区域仍然完全可用于增量构建和在线更改。 最大的连续内存间隙 （以字节为单位）：这是可用于备份的内存大小。 分配内存中产生的间隙将尽可能用于其他更改。例如，当类型为全局变量时 Byte 添加后，它被放置在内存的第一个空闲字节中。即使是很小的差距也足够了。但是，FB 实例、结构或数组类型的变量或 POU 的代码必须连续存储，因此会占用更多的内存。因此，它们只能分配到最大的连续内存区域。这就是为什么在代码生成期间输出安全可用的“最大连续内存间隙”（以字节为单位），以及它在总内存中的百分比。 为此，另请参阅： 生成应用程序的选项 " }, 
{ "title" : "下载应用程序代码、登录和启动 PLC ", 
"url" : "_cds_loading_application_login_starting.html", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC \/ 下载应用程序代码、登录和启动 PLC ", 
"snippet" : "为了将应用程序的源代码下载到 PLC，您必须使用应用程序登录到 PLC。如果项目中有多个应用程序，则必须先显式切换到正确的应用程序。 当您将应用程序下载到控制器时， CODESYS 执行以下检查： 将 PLC 上的应用程序列表与项目中可用的应用程序进行比较。如果它们不匹配，则会提示您下载尚未在 PLC 上的应用程序或删除现有应用程序。 对于要下载的应用程序中的“外部实现”块， CODESYS 检查这些在 PLC 上是否可用。如果它们不可用，则将消息“未解析的引用”打印到对话框提示和消息视图。然后 CODESYS 比较要下载的应用程序中块的参数（变量）和 PLC 上存在的应用程序中同名块的参数（...", 
"body" : "为了将应用程序的源代码下载到 PLC，您必须使用应用程序登录到 PLC。如果项目中有多个应用程序，则必须先显式切换到正确的应用程序。 当您将应用程序下载到控制器时， CODESYS 执行以下检查： 将 PLC 上的应用程序列表与项目中可用的应用程序进行比较。如果它们不匹配，则会提示您下载尚未在 PLC 上的应用程序或删除现有应用程序。 对于要下载的应用程序中的“外部实现”块， CODESYS 检查这些在 PLC 上是否可用。如果它们不可用，则将消息“未解析的引用”打印到对话框提示和消息视图。然后 CODESYS 比较要下载的应用程序中块的参数（变量）和 PLC 上存在的应用程序中同名块的参数（签名检查）。如果存在任何差异，则将消息“无效签名”打印到对话框提示和消息视图中。 如果在应用程序属性中选择了“下载应用程序信息”选项，则有关应用程序内容的附加信息将下载到 PLC。 如果同一设备存在多个应用程序，请注意 I\/O 映射 对话框包含用于设备 I\/O 映射的应用程序的定义。 注意：如果连接是从 CODESYS 到 PLC 和 CODESYS Automation Server 通过边缘网关连接到 PLC，然后 CODESYS Automation Server 可能会覆盖 PLC 上的本地更改。为此，消息显示在消息视图中 CODESYS 在打开项目后建立与 PLC 的连接时 CODESYS 首次。 有关更多信息，请参阅： 应用程序传输应用程序并启动程序 要求：应用程序没有错误，PLC 的通讯设置正确。该应用程序在 PLC 上尚不存在。应用程序和与控制器的通信未加密。 在设备树中选择所需的应用程序。如果您只有一个应用程序，请跳至步骤 3。 点击 设置活动应用程序 . 应用程序名称以粗体显示。 点击 在线 → 登录 . 对话框提示您是否应在 PLC 上创建应用程序。 点击 是的 确认对话框。 应用程序被下载到控制器。 点击 调试 → 开始 或按 F5 钥匙。 应用程序正在控制器上运行。 " }, 
{ "title" : "创建引导应用程序 ", 
"url" : "_cds_creating_a_boot_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC \/ 创建引导应用程序 ", 
"snippet" : "启动应用程序是应用程序版本，它在控制器打开或启动时自动启动。为此，PLC 上的应用程序必须作为 <application name>.app 文件。 对于在 PLC 上运行的每个应用程序，也可以将启动应用程序保存在那里。 默认情况下， CODESYS 下载应用程序时自动生成引导应用程序并将其传输到 PLC。自动生成的默认设置位于 特性 应用程序对象的 启动应用程序 类别。使用更改的应用程序登录时，仍会提示您是否生成新的引导应用程序。 此外，您可以点击 在线 → 创建启动应用程序 随时在线模式下创建新的启动应用程序。 您也可以在离线模式下创建和保存引导应用程序的本地副本。然后，您可以使用外部工具...", 
"body" : "启动应用程序是应用程序版本，它在控制器打开或启动时自动启动。为此，PLC 上的应用程序必须作为 <application name>.app 文件。 对于在 PLC 上运行的每个应用程序，也可以将启动应用程序保存在那里。 默认情况下， CODESYS 下载应用程序时自动生成引导应用程序并将其传输到 PLC。自动生成的默认设置位于 特性 应用程序对象的 启动应用程序 类别。使用更改的应用程序登录时，仍会提示您是否生成新的引导应用程序。 此外，您可以点击 在线 → 创建启动应用程序 随时在线模式下创建新的启动应用程序。 您也可以在离线模式下创建和保存引导应用程序的本地副本。然后，您可以使用外部工具将此应用程序复制到 PLC。因此，即使没有与 PLC 的连接，您也可以将应用程序传输到 PLC CODESYS . 使用注意事项 CODESYS Control Win 当使用一个 CODESYS Control Win ，应用程序名称也必须包含在配置文件中（ *.cfg ）。 [CmpApp]\nApplication.1=MyApplication " }, 
{ "title" : "在 PLC 上自动且显式地生成引导应用程序 ", 
"url" : "_cds_creating_a_boot_application.html#UUID-c54f0d29-44ff-6993-adb8-9af7e6d0bdf6_id_a0805999879591e6c0a8640e017feaf9_id_8d4ef86a2876f271c0a8640e01324013", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC \/ 创建引导应用程序 \/ 在 PLC 上自动且显式地生成引导应用程序 ", 
"snippet" : "要求：离线模式，您的应用程序编译无误。与 PLC 的连接已配置并且 PLC 正在运行。应用程序处于活动状态。以下步骤演示了这些选项： 点击 在线 → 登录 . 这 <application name>.app 引导应用程序文件在 PLC 上创建，其 CRC 为 <application name>.crc 启动应用程序。 显式点击 在线 → 创建引导应用程序 . PLC 上的文件被新文件替换。 登出。 更改应用程序。重新登录到控制器。 系统会提示您执行在线更改。你看到 更新启动应用程序 同一对话框中的选项。默认情况下禁用。默认设置可以在 特性 应用程序对象的 启动应用程序 类别。 清除该选项并...", 
"body" : "要求：离线模式，您的应用程序编译无误。与 PLC 的连接已配置并且 PLC 正在运行。应用程序处于活动状态。以下步骤演示了这些选项： 点击 在线 → 登录 . 这 <application name>.app 引导应用程序文件在 PLC 上创建，其 CRC 为 <application name>.crc 启动应用程序。 显式点击 在线 → 创建引导应用程序 . PLC 上的文件被新文件替换。 登出。 更改应用程序。重新登录到控制器。 系统会提示您执行在线更改。你看到 更新启动应用程序 同一对话框中的选项。默认情况下禁用。默认设置可以在 特性 应用程序对象的 启动应用程序 类别。 清除该选项并继续登录。 不会创建新的引导应用程序文件。 再次注销。关闭项目。停止 PLC。重新启动控制器。 上面创建的引导应用程序正在 PLC 上运行。 您可以将加密的启动应用程序保存在 PLC 上。应用程序对象的这些设置在 特性 在里面 应用程序构建选项 类别。 有关更多信息，请参阅： 执行在线更改" }, 
{ "title" : "在离线模式下创建启动应用程序 ", 
"url" : "_cds_creating_a_boot_application.html#UUID-c54f0d29-44ff-6993-adb8-9af7e6d0bdf6_id_a0805999879591e6c0a8640e017feaf9_id_ed59e5272876f272c0a8640e0179f8b8", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC \/ 创建引导应用程序 \/ 在离线模式下创建启动应用程序 ", 
"snippet" : "要求：离线模式，您的应用程序编译无误。您想为一个应用程序生成一个启动应用程序并将其保存在文件目录中，以便以后使用外部工具将其复制到 PLC（无需 CODESYS ）。 点击 在线 → 创建引导应用程序 . 将打开一个对话框，用于指定本地文件系统中的位置。 单击保存路径，然后单击 保存 . 如果自上次生成引导应用程序后应用程序已更改，则会提示您为引导应用程序使用新代码。在这种情况下，单击 是的 . 这 另存为 对话框打开。 选择一个目录并单击 保存 . <application name.app> 引导应用程序文件在给定路径中创建。 系统会提示您是否保存引导应用程序的编译信息。 点击 是的 . ...", 
"body" : "要求：离线模式，您的应用程序编译无误。您想为一个应用程序生成一个启动应用程序并将其保存在文件目录中，以便以后使用外部工具将其复制到 PLC（无需 CODESYS ）。 点击 在线 → 创建引导应用程序 . 将打开一个对话框，用于指定本地文件系统中的位置。 单击保存路径，然后单击 保存 . 如果自上次生成引导应用程序后应用程序已更改，则会提示您为引导应用程序使用新代码。在这种情况下，单击 是的 . 这 另存为 对话框打开。 选择一个目录并单击 保存 . <application name.app> 引导应用程序文件在给定路径中创建。 系统会提示您是否保存引导应用程序的编译信息。 点击 是的 . 编译信息作为文件保存到项目目录 <application name>.compileinfo .下次更新应用程序时，可能需要进行在线更改。注意： 构建 → 清理 命令删除此文件。 " }, 
{ "title" : "将源代码下载到 PLC 和从 PLC 下载源代码 ", 
"url" : "_cds_loading_sourcecode_to_from_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC \/ 将源代码下载到 PLC 和从 PLC 下载源代码 ", 
"snippet" : "CODESYS 提供将项目源代码作为项目存档加载到 PLC 的能力。然后，您可以根据需要将此项目存档从 PLC 传输回开发系统。 要求：为受影响的控制器配置连接设置。 从 PLC 加载源代码 点击 文件 → 源码上传 . 这 选择设备 对话框打开。 选择 PLC 发送源代码。点击 行 . 这 提取项目 对话框打开。 选择要提取项目存档的目标目录。点击 提炼 . CODESYS 将项目存档解压缩到目录。 然后系统会提示您打开项目存档。点击 是的 . 项目打开。...", 
"body" : "CODESYS 提供将项目源代码作为项目存档加载到 PLC 的能力。然后，您可以根据需要将此项目存档从 PLC 传输回开发系统。 要求：为受影响的控制器配置连接设置。 从 PLC 加载源代码 点击 文件 → 源码上传 . 这 选择设备 对话框打开。 选择 PLC 发送源代码。点击 行 . 这 提取项目 对话框打开。 选择要提取项目存档的目标目录。点击 提炼 . CODESYS 将项目存档解压缩到目录。 然后系统会提示您打开项目存档。点击 是的 . 项目打开。 " }, 
{ "title" : "将源代码下载到 PLC ", 
"url" : "_cds_loading_sourcecode_to_from_plc.html#UUID-0ad360c5-6f3b-72f6-1bf4-e13ee462c493_id_b468660460c0a8640e01de1e14_id_07ca0313689602ffc0a8640e010017e8", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC \/ 将源代码下载到 PLC 和从 PLC 下载源代码 \/ 将源代码下载到 PLC ", 
"snippet" : "点击 文件 → 源码下载 . 这 选择设备 对话框打开。 选择PLC接收源代码。点击 行 . CODESYS 写 Archive.prj 存档文件到控制器。 你可以点击 在线 → 源下载到连接的设备 将源代码直接下载到连接的设备。 有关更多信息，请参阅： 源码下载...", 
"body" : "点击 文件 → 源码下载 . 这 选择设备 对话框打开。 选择PLC接收源代码。点击 行 . CODESYS 写 Archive.prj 存档文件到控制器。 你可以点击 在线 → 源下载到连接的设备 将源代码直接下载到连接的设备。 有关更多信息，请参阅： 源码下载" }, 
{ "title" : "将应用程序代码分布到不同的内存区域 ", 
"url" : "_cds_mapping_code_in_different_areas.html", 
"breadcrumbs" : "CODESYS Essentials \/ 将应用程序下载到 PLC \/ 将应用程序代码分布到不同的内存区域 ", 
"snippet" : "CODESYS 提供将应用程序代码存储在控制器不同内存区域的能力。要求是您正在使用支持此功能的控制器。对于这些特定的控制器，您的应用程序会自动获取 POU 位置 对象让您将不同的内存区域分配给您的各个 POU。 另请注意特定于制造商或特定于控制器的规范或有关此功能的信息。 要求：应用程序不包含任何编译错误。 在里面 设备 查看，双击 POU 位置 目的。 在打开的对象中，单击 Generate Code 按钮。 应用程序的所有程序块都以各自的对象类型、内存中的当前位置和代码大小显示。 双击条目中的 配置位置 要存储在另一个内存区域中的 POU 列。 将打开一个列表框。 从列表框中选择一个内存区...", 
"body" : "CODESYS 提供将应用程序代码存储在控制器不同内存区域的能力。要求是您正在使用支持此功能的控制器。对于这些特定的控制器，您的应用程序会自动获取 POU 位置 对象让您将不同的内存区域分配给您的各个 POU。 另请注意特定于制造商或特定于控制器的规范或有关此功能的信息。 要求：应用程序不包含任何编译错误。 在里面 设备 查看，双击 POU 位置 目的。 在打开的对象中，单击 Generate Code 按钮。 应用程序的所有程序块都以各自的对象类型、内存中的当前位置和代码大小显示。 双击条目中的 配置位置 要存储在另一个内存区域中的 POU 列。 将打开一个列表框。 从列表框中选择一个内存区域。 点击 干净的 接着 生成代码 . POU 存储在重新配置的内存位置。 " }, 
{ "title" : "测试和调试 ", 
"url" : "_cds_struct_test_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 ", 
"snippet" : "CODESYS 提供用于测试您的应用程序和检测错误的各种选项。即使不连接任何硬件，您也可以在仿真模式下启动应用程序。使用断点和单步执行命令，您可以检查程序的特定部分。通过将值写入变量，您可以影响正在运行的程序。 可以使用命令在不同程度上重置您的应用程序。范围从仅重置非持久变量到将控制器完全重置为出厂设置。...", 
"body" : "CODESYS 提供用于测试您的应用程序和检测错误的各种选项。即使不连接任何硬件，您也可以在仿真模式下启动应用程序。使用断点和单步执行命令，您可以检查程序的特定部分。通过将值写入变量，您可以影响正在运行的程序。 可以使用命令在不同程度上重置您的应用程序。范围从仅重置非持久变量到将控制器完全重置为出厂设置。 " }, 
{ "title" : "在模拟模式下测试 ", 
"url" : "_cds_testing_in_simulation_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 在模拟模式下测试 ", 
"snippet" : "当您没有物理目标设备时，使用仿真模式测试和调试您的程序。在这种模式下，应用程序在模拟设备上启动。 该命令仅在您注销时可用。 要求：您的程序不包含错误（编译器错误消息或编译错误）并且您没有登录。 激活模拟模式。 点击 在线 → 模拟 . 在设备树中，选择 PLC 并在上下文菜单中单击 模拟 . 设备树中的 PLC 名称以斜体显示。在状态行中，“模拟”以红色突出显示。这 模拟 在菜单栏中选择选项。 点击 在线 → 登录 . 首次使用活动应用程序登录时，系统会提示您是否应创建并加载“Sim.<设备名称>.<应用程序名称>”应用程序。点击 是的 确认。 应用程序已登录到控制器。这在设备树中由 PLC ...", 
"body" : "当您没有物理目标设备时，使用仿真模式测试和调试您的程序。在这种模式下，应用程序在模拟设备上启动。 该命令仅在您注销时可用。 要求：您的程序不包含错误（编译器错误消息或编译错误）并且您没有登录。 激活模拟模式。 点击 在线 → 模拟 . 在设备树中，选择 PLC 并在上下文菜单中单击 模拟 . 设备树中的 PLC 名称以斜体显示。在状态行中，“模拟”以红色突出显示。这 模拟 在菜单栏中选择选项。 点击 在线 → 登录 . 首次使用活动应用程序登录时，系统会提示您是否应创建并加载“Sim.<设备名称>.<应用程序名称>”应用程序。点击 是的 确认。 应用程序已登录到控制器。这在设备树中由 PLC 前面的警告标志。 现在您可以检查和更正程序流程。相应的命令在 调试 菜单。 从 PLC 注销并结束仿真模式。 " }, 
{ "title" : "使用断点 ", 
"url" : "_cds_using_breakpoints.html", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 使用断点 ", 
"snippet" : "断点通常用于调试程序。 CODESYS 支持所有 IEC 编辑器中的断点。 您可以在程序的特定位置设置断点以强制停止执行并监视变量值。您可以设置特殊的“数据断点”以在特定变量的值更改时停止程序执行。 断点或数据断点处的暂停可以与其他条件相关联。您还可以将断点和数据断点重新定义为执行特定代码而不是停止程序的“执行点”。 这 断点 view 提供所有已定义断点的概览。它还包括用于处理对多个断点的批量更改的附加命令。 在编辑器中，以下符号标识断点或执行点的状态： : 断点已启用。 : 断点被禁用。 : 断点设置在编辑器中打开的 POU 的另一个实例中。 : 程序在断点处停止。 : 启用有条件的断点。...", 
"body" : "断点通常用于调试程序。 CODESYS 支持所有 IEC 编辑器中的断点。 您可以在程序的特定位置设置断点以强制停止执行并监视变量值。您可以设置特殊的“数据断点”以在特定变量的值更改时停止程序执行。 断点或数据断点处的暂停可以与其他条件相关联。您还可以将断点和数据断点重新定义为执行特定代码而不是停止程序的“执行点”。 这 断点 view 提供所有已定义断点的概览。它还包括用于处理对多个断点的批量更改的附加命令。 在编辑器中，以下符号标识断点或执行点的状态： : 断点已启用。 : 断点被禁用。 : 断点设置在编辑器中打开的 POU 的另一个实例中。 : 程序在断点处停止。 : 启用有条件的断点。 : 带条件的断点被禁用。 ：启用执行点。 : 执行点被禁用。 : 启用有条件的执行点。 : 带条件的执行点被禁用。 ：启用数据断点。 : 数据断点被禁用。 ：程序在数据断点处停止。 ：启用数据执行点。 ：数据执行点被禁用。 ：程序在数据执行点停止。 ：启用有条件的数据执行点。 : 启用带条件的数据断点。 有关更多信息，请参阅： 断点设置数据断点 要求：应用程序处于在线模式并正在运行。 点击 查看 → 断点 . 点击 调试 → 新数据断点 . 在里面 新断点 对话框，在 数据 选项卡，单击 按钮。 在里面 输入助手 对话框 ( 观察变量 选项卡），选择更改时程序应停止的变量。 或者，在 数据 直接在输入行中的选项卡。例子： PLC_PRG.iNumber .要监视的确切字节数指定为 尺寸 .默认情况下，此处会自动设置与数据类型对应的值。您还可以指定要监视的更少字节。 在里面 断点 查看，选择带有数据断点的行并单击 按钮。 该线由 符号（启用数据断点）。当程序到达数据断点时（即选定变量的值发生变化时），程序处理停止。在 POU 的实现部分，下一行用箭头标识 .这在状态行中由 HALT ON BP 状态以红色突出显示。 点击 调试 → 开始 或按 F5 钥匙。 当变量的值再次改变时，程序继续运行并再次停止。 " }, 
{ "title" : "数据断点 ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_2d628f59bea511e09bc3d16902ba108f", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 使用断点 \/ 数据断点 ", 
"snippet" : "数据断点的功能取决于目标系统。目前，数据断点只能通过 CODESYS Control Win . 当特定变量或内存地址的值发生变化时，程序执行会在数据断点处停止。与“正常”断点一样，暂停可以链接到附加条件，或者可以处理特定代码而不是暂停（转换为数据执行点）。 您可以通过以下方式设置数据断点 新数据断点 命令在 调试 菜单或通过 新的 中的按钮 断点 看法。您可以直接指定一个限定变量名或内存地址，以监控其值的变化。 例子 在下面的示例代码中，变量的内存 iNumber 被无意覆盖。但是，变量处的数据断点 iNumber 将检测其值何时发生变化。然后处理在数组访问处以相应的消息停止，这会覆盖变量值...", 
"body" : "数据断点的功能取决于目标系统。目前，数据断点只能通过 CODESYS Control Win . 当特定变量或内存地址的值发生变化时，程序执行会在数据断点处停止。与“正常”断点一样，暂停可以链接到附加条件，或者可以处理特定代码而不是暂停（转换为数据执行点）。 您可以通过以下方式设置数据断点 新数据断点 命令在 调试 菜单或通过 新的 中的按钮 断点 看法。您可以直接指定一个限定变量名或内存地址，以监控其值的变化。 例子 在下面的示例代码中，变量的内存 iNumber 被无意覆盖。但是，变量处的数据断点 iNumber 将检测其值何时发生变化。然后处理在数组访问处以相应的消息停止，这会覆盖变量值： Idx = 7 . 另见下文：“设置数据断点” PROGRAM PLC_PRG\nVAR\n Idx : INT;\n Ary : ARRAY[0..3] OF BYTE;\n iNumber : INT := 55;\nEND_VAR\nFOR idx := 0 TO 6 DO\n Ary[idx] := 0;\nEND_FOR " }, 
{ "title" : "具有多个任务的应用程序中的断点 ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_fc3cb2351b73b0bcc0a8640e006f44cc", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 使用断点 \/ 具有多个任务的应用程序中的断点 ", 
"snippet" : "基本上，不可能同时对多个任务进行调试。当您处理带有断点或单步执行的任务时，断点在其他任务中会被忽略。 如果一个包含断点的 POU 被多个任务使用，那么只有任务（“调试任务”）被暂停，因为它首先到达断点。所有其他任务继续。这 调用堆栈 对话框显示当前暂停的任务。 如果您需要一个断点来只影响一个特定的任务，那么您可以在断点属性中定义它。 断点为每个应用程序单独运行，因此“HALT ON BP”不会影响任何其他应用程序。这也适用于父\/子应用程序，即使断点设置在由多个应用程序使用且其代码仅在 PLC 上定位一次的块中。 “调试任务”调用的 I\/O 不会在断点处暂停更新，即使您选择 在停止时刷新 I\/O...", 
"body" : "基本上，不可能同时对多个任务进行调试。当您处理带有断点或单步执行的任务时，断点在其他任务中会被忽略。 如果一个包含断点的 POU 被多个任务使用，那么只有任务（“调试任务”）被暂停，因为它首先到达断点。所有其他任务继续。这 调用堆栈 对话框显示当前暂停的任务。 如果您需要一个断点来只影响一个特定的任务，那么您可以在断点属性中定义它。 断点为每个应用程序单独运行，因此“HALT ON BP”不会影响任何其他应用程序。这也适用于父\/子应用程序，即使断点设置在由多个应用程序使用且其代码仅在 PLC 上定位一次的块中。 “调试任务”调用的 I\/O 不会在断点处暂停更新，即使您选择 在停止时刷新 I\/O PLC 设置中的复选框。 如果应用程序在 PLC 的断点处停止，则在线更改或下载会导致所有任务停止，这意味着 PLC 将停止。在这种情况下， CODESYS 提示您是否继续登录。 " }, 
{ "title" : "设置单个断点（ST 编辑器中的示例） ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_976c066b2e8311e482de899d4a6249d6", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 使用断点 \/ 设置单个断点（ST 编辑器中的示例） ", 
"snippet" : "要求：应用程序处于在线模式并正在运行。运行模式是 调试 . 在编辑器中，打开以结构化文本 (ST) 编程的 POU。 将光标放在要设置断点的行中。 点击 调试 → 切换断点 或按 F9 钥匙。 这条线用红色标记并由 符号（启用断点）。如果程序在断点处停止，则该行由 符号（在断点处停止）。程序的处理停止。这在状态行中由 HALT ON BP 状态以红色突出显示。 点击 调试 → 开始 或按 F5 钥匙。 该计划继续进行。 设置更多断点并检查断点处的变量值。 将光标放在应删除断点的行中。 点击 调试 → 断点切换 或按 F9 钥匙。 标记消失。断点被删除。...", 
"body" : "要求：应用程序处于在线模式并正在运行。运行模式是 调试 . 在编辑器中，打开以结构化文本 (ST) 编程的 POU。 将光标放在要设置断点的行中。 点击 调试 → 切换断点 或按 F9 钥匙。 这条线用红色标记并由 符号（启用断点）。如果程序在断点处停止，则该行由 符号（在断点处停止）。程序的处理停止。这在状态行中由 HALT ON BP 状态以红色突出显示。 点击 调试 → 开始 或按 F5 钥匙。 该计划继续进行。 设置更多断点并检查断点处的变量值。 将光标放在应删除断点的行中。 点击 调试 → 断点切换 或按 F9 钥匙。 标记消失。断点被删除。 " }, 
{ "title" : "定义断点条件（ST 编辑器中的示例） ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_aae846be2e8311e482de899d4a6249d6", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 使用断点 \/ 定义断点条件（ST 编辑器中的示例） ", 
"snippet" : "在编辑器中，打开以结构化文本 (ST) 编程的 POU。 将光标放在要设置断点的行中。 点击 调试 → 新断点 . 这 新断点 对话框打开。 点击 状况 标签。 点击 当命中数是的倍数时中断 在里面 命中数 列表框。 在右侧字段中指定值“5”。 此外，您可以定义断点何时应该处于活动状态的布尔条件。选择 打破，当真实 复选框。在右侧的文本字段中指定一个布尔变量。 选择 立即启用断点 复选框。 关闭对话框。 该线标记为红色并由 象征。 监控正在运行的程序。只要条件的布尔变量是 FALSE ，断点条件不满足，程序继续运行。如果将变量设置为 TRUE ，则条件满足，程序每 5 次在断点处停止。...", 
"body" : "在编辑器中，打开以结构化文本 (ST) 编程的 POU。 将光标放在要设置断点的行中。 点击 调试 → 新断点 . 这 新断点 对话框打开。 点击 状况 标签。 点击 当命中数是的倍数时中断 在里面 命中数 列表框。 在右侧字段中指定值“5”。 此外，您可以定义断点何时应该处于活动状态的布尔条件。选择 打破，当真实 复选框。在右侧的文本字段中指定一个布尔变量。 选择 立即启用断点 复选框。 关闭对话框。 该线标记为红色并由 象征。 监控正在运行的程序。只要条件的布尔变量是 FALSE ，断点条件不满足，程序继续运行。如果将变量设置为 TRUE ，则条件满足，程序每 5 次在断点处停止。 " }, 
{ "title" : "定义执行点（ST 编辑器中的示例） ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_fb223006da6101d6c0a864630d894b56", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 使用断点 \/ 定义执行点（ST 编辑器中的示例） ", 
"snippet" : "在编辑器中，打开以结构化文本 (ST) 编程的 POU。 将光标放在执行点的位置。 点击 调试 → 新断点 . 这 新断点 对话框打开。 点击 执行点设置 标签。 选择 执行点 选项。 在里面 执行以下代码 字段，指定以下语句： iCounter := iCounter + 1; 在里面 在设备日志中打印一条消息 字段，指定以下文本： Execution point reached {iCounter} 关闭对话框。 当程序到达执行点时，它不会停止，而是执行上面定义的代码。此外。向设备日志发出一条消息。...", 
"body" : "在编辑器中，打开以结构化文本 (ST) 编程的 POU。 将光标放在执行点的位置。 点击 调试 → 新断点 . 这 新断点 对话框打开。 点击 执行点设置 标签。 选择 执行点 选项。 在里面 执行以下代码 字段，指定以下语句： iCounter := iCounter + 1; 在里面 在设备日志中打印一条消息 字段，指定以下文本： Execution point reached {iCounter} 关闭对话框。 当程序到达执行点时，它不会停止，而是执行上面定义的代码。此外。向设备日志发出一条消息。 " }, 
{ "title" : "逐步执行程序 ", 
"url" : "_cds_stepping.html", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 逐步执行程序 ", 
"snippet" : "您可以单步执行应用程序并浏览代码。这对于在运行时检查代码的状态很有用。您可以检查调用过程、跟踪变量值或定位错误。 步进命令在 调试 为此目的的菜单。当您在联机模式下设置断点然后在断点处停止执行时，这些命令变为可用：应用程序处于 停止血压 状态（调试模式）。在调试模式下，当前中断位置以黄色突出显示并标有 文本编辑器中的符号。 切换到调试模式 将您的应用程序下载到控制器。 该应用程序以绿色突出显示。 CODESYS 并且 POU 的编辑器处于在线模式。 在 POU 中，在要检查的代码位置设置断点。 所有断点都列在 断点 看法。 启动应用程序。 应用程序启动并处理代码，直到第一个断点。 现在应用程序...", 
"body" : "您可以单步执行应用程序并浏览代码。这对于在运行时检查代码的状态很有用。您可以检查调用过程、跟踪变量值或定位错误。 步进命令在 调试 为此目的的菜单。当您在联机模式下设置断点然后在断点处停止执行时，这些命令变为可用：应用程序处于 停止血压 状态（调试模式）。在调试模式下，当前中断位置以黄色突出显示并标有 文本编辑器中的符号。 切换到调试模式 将您的应用程序下载到控制器。 该应用程序以绿色突出显示。 CODESYS 并且 POU 的编辑器处于在线模式。 在 POU 中，在要检查的代码位置设置断点。 所有断点都列在 断点 看法。 启动应用程序。 应用程序启动并处理代码，直到第一个断点。 现在应用程序处于调试模式。在设备树中，应用程序被标记为 [在断点处暂停] .状态栏提供有关操作状态的信息： 编辑器在当前中断位置打开。带有活动断点的代码行在程序执行被暂停的地方以黄色突出显示，并由 象征。这条以黄色突出显示的语句尚未执行。 现在您可以选择各种步进命令或显示调用树。 或者，您可以先启动应用程序，然后设置断点。 " }, 
{ "title" : "调试菜单中步进命令的行为 ", 
"url" : "_cds_stepping.html#UUID-a130cd52-c46f-0c6f-6bf8-905f62d6add1_id_b4ea395b460596ffc0a8640e000aa41c_id_228de625e3b1eca0c0a864630c398ee9", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 逐步执行程序 \/ 调试菜单中步进命令的行为 ", 
"snippet" : "调试菜单中步进命令的行为 跨过 命令 执行断点位置的语句。程序执行在 POU 中的下一条语句之前停止。 如果语句包含调用（来自程序、功能块实例、功能、方法或动作），则下级 POU 将在一个步骤中完成处理。 踏入 命令 执行断点位置的语句。程序执行在下一条语句之前停止。 如果语句包含调用（来自程序、功能块实例、函数、方法或动作），则程序执行跳转到该从属 POU。那里的第一条语句被执行并且程序执行在下一条语句之前停止。然后新的当前断点位置在被调用的 POU 中。 走出去 命令 该命令从当前断点位置执行 POU 到 POU 的末尾，然后跳回到调用 POU。程序执行在调用位置（与调用一致）处停止。 如...", 
"body" : "调试菜单中步进命令的行为 跨过 命令 执行断点位置的语句。程序执行在 POU 中的下一条语句之前停止。 如果语句包含调用（来自程序、功能块实例、功能、方法或动作），则下级 POU 将在一个步骤中完成处理。 踏入 命令 执行断点位置的语句。程序执行在下一条语句之前停止。 如果语句包含调用（来自程序、功能块实例、函数、方法或动作），则程序执行跳转到该从属 POU。那里的第一条语句被执行并且程序执行在下一条语句之前停止。然后新的当前断点位置在被调用的 POU 中。 走出去 命令 该命令从当前断点位置执行 POU 到 POU 的末尾，然后跳回到调用 POU。程序执行在调用位置（与调用一致）处停止。 如果当前断点位置在主程序中，则 POU 一直运行到最后。然后程序执行跳回到开头（程序从 POU 中的第一行代码开始）并在那里停止。 运行到光标 命令 首先将光标置于任意代码行，然后执行命令。程序从当前断点位置开始执行，并停在当前光标位置，不执行本行代码。 设置下一条语句 命令 首先将光标设置在任意代码行（也是在当前断点位置之前），然后执行命令。接下来执行用光标标记的语句。中间的所有语句都被忽略和跳过。 显示下一条语句 命令 如果看不到当前断点位置，则执行命令。然后具有当前断点位置的窗口成为焦点，并且断点位置可见。 点击 查看 → 调用堆栈 以完整显示程序处理中当前到达的断点位置的先前调用树。 这 调用堆栈 视图始终显示程序调用结构中块的位置，甚至在编译应用程序之前。 " }, 
{ "title" : "变量的强制和写入 ", 
"url" : "_cds_forcing_values.html", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 变量的强制和写入 ", 
"snippet" : "当前在控制器上运行的应用程序中变量值的异常变化可能导致受控设备的不良行为。 在强制变量值之前评估可能的危险，并采取相应的安全预防措施。根据受控设备的不同，这可能会导致设备或工件损坏，或者人员受伤或死亡。 在 CODESYS , PLC 中的变量值可以在在线模式下更改。在这里，我们区分了强制和写入预先准备好的值。 写作是用 写入值 命令 （ Ctrl + F7 ) 并将变量设置为准备好的值一次。这样，该值可以随时被程序再次覆盖。 强制是用 强制值 命令 （ F7 ) 并永久设置准备好的值。有关更多信息，请参见下文。 可以在不同的地方为强制或写入准备一个值： 声明部分： 准备值 场地 FBD\/LD...", 
"body" : "当前在控制器上运行的应用程序中变量值的异常变化可能导致受控设备的不良行为。 在强制变量值之前评估可能的危险，并采取相应的安全预防措施。根据受控设备的不同，这可能会导致设备或工件损坏，或者人员受伤或死亡。 在 CODESYS , PLC 中的变量值可以在在线模式下更改。在这里，我们区分了强制和写入预先准备好的值。 写作是用 写入值 命令 （ Ctrl + F7 ) 并将变量设置为准备好的值一次。这样，该值可以随时被程序再次覆盖。 强制是用 强制值 命令 （ F7 ) 并永久设置准备好的值。有关更多信息，请参见下文。 可以在不同的地方为强制或写入准备一个值： 声明部分： 准备值 场地 FBD\/LD\/IL编辑器的实现部分：在线监控字段 观看视图： 准备值 场地 有关这方面的说明，请参见下文。如果您想为已经强制的值再次准备一个值，则 准备价值 对话框打开，其中包含处理当前力值的选项。 " }, 
{ "title" : "强制功能 ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_0e7fdcf008c517edc0a8652001320ebf", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 变量的强制和写入 \/ 强制功能 ", 
"snippet" : "准备好的值在任务循环（或在其他任务类型的情况下的处理循环）的开始和结束时设置为相应的变量。 一个任务每个周期的处理顺序如下： 读取输入 强制：在第一次程序调用之前，所有准备好的值都由运行时系统写入变量，无论它们是否被任务使用。 处理 IEC 代码 强制：在最后一次程序调用之后，所有准备好的值都由运行时系统写入变量，无论它们是否被任务使用。 写输出 注意：在处理代码时，强制变量可能会在循环中临时获得不同的值，因为 IEC 代码执行了赋值。然后变量仅在循环结束时再次接收强制值。变量值也可以被客户端在周期中间对应用程序符号的写访问覆盖。对于这种情况，请参阅 访问与 IEC 任务同步的变量 中的选项 ...", 
"body" : "准备好的值在任务循环（或在其他任务类型的情况下的处理循环）的开始和结束时设置为相应的变量。 一个任务每个周期的处理顺序如下： 读取输入 强制：在第一次程序调用之前，所有准备好的值都由运行时系统写入变量，无论它们是否被任务使用。 处理 IEC 代码 强制：在最后一次程序调用之后，所有准备好的值都由运行时系统写入变量，无论它们是否被任务使用。 写输出 注意：在处理代码时，强制变量可能会在循环中临时获得不同的值，因为 IEC 代码执行了赋值。然后变量仅在循环结束时再次接收强制值。变量值也可以被客户端在周期中间对应用程序符号的写访问覆盖。对于这种情况，请参阅 访问与 IEC 任务同步的变量 中的选项 特性 设备对象，或 配置与 IEC 任务的同步 在符号配置中设置。通过这种方式，PLC 处理程序支持的客户端写访问同步可以通过任务循环启用。 强制值标有 象征。 CODESYS 执行强制直到用户通过以下操作之一明确解除它： 的执行 取消强制所有值 命令 释放力操作在 准备价值 对话 退出应用程序 如果注销时强制变量仍然存在，则会打开一个对话框，提示是否应为所有变量解除强制。如果您通过单击响应 不 ，然后在下次登录时再次应用强制值。 " }, 
{ "title" : "强制声明部分 ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_bf7e22b408c5163cc0a865200081e4a1", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 变量的强制和写入 \/ 强制声明部分 ", 
"snippet" : "要求：您的应用程序包含一个带有声明的 POU。该应用程序处于在线模式。 通过选择命令在编辑器中打开 POU 项目 → 编辑对象 . 在编辑器的声明部分，双击第(1)列 准备值 的一个变量。 可以编辑该字段并且可以输入一个值。当它是一个布尔值时，您可以通过单击该字段来更改该值。 对其他变量执行步骤 2。 点击 调试 → 强制值 . 变量值被准备好的值覆盖。这些值标有 象征。 您还可以强制变量中的值 手表 看法。...", 
"body" : "要求：您的应用程序包含一个带有声明的 POU。该应用程序处于在线模式。 通过选择命令在编辑器中打开 POU 项目 → 编辑对象 . 在编辑器的声明部分，双击第(1)列 准备值 的一个变量。 可以编辑该字段并且可以输入一个值。当它是一个布尔值时，您可以通过单击该字段来更改该值。 对其他变量执行步骤 2。 点击 调试 → 强制值 . 变量值被准备好的值覆盖。这些值标有 象征。 您还可以强制变量中的值 手表 看法。 " }, 
{ "title" : "强制执行部分 ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_2f736e9005a0d09ec0a8640e0030151c", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 变量的强制和写入 \/ 强制执行部分 ", 
"snippet" : "要求：应用程序处于在线模式。 通过选择命令在编辑器中打开 POU 项目 → 编辑对象 . 在编辑器的实现部分，双击一个内联监控字段 (1)。 这 准备价值 对话框打开。 在字段中输入新值 为下一次写入或强制操作准备一个新值 . 准备好的值出现在在线监控字段中。 点击 调试 → 强制值 . 变量的值被准备好的值覆盖。这些值标有 象征。...", 
"body" : "要求：应用程序处于在线模式。 通过选择命令在编辑器中打开 POU 项目 → 编辑对象 . 在编辑器的实现部分，双击一个内联监控字段 (1)。 这 准备价值 对话框打开。 在字段中输入新值 为下一次写入或强制操作准备一个新值 . 准备好的值出现在在线监控字段中。 点击 调试 → 强制值 . 变量的值被准备好的值覆盖。这些值标有 象征。 " }, 
{ "title" : "查看和编辑所有强制变量列表 ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_0cd4e3c8f807c8cbc0a8646346df5261", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 变量的强制和写入 \/ 查看和编辑所有强制变量列表 ", 
"snippet" : "要求：应用程序处于在线模式。多个变量是强制的。 点击 查看 → 观看 → 观看所有力量 . 这 观看所有力量 视图打开。它以观察列表的形式包含应用程序的所有当前强制变量。 选择列表中的所有行，然后在视图左上角的列表框中单击 取消强制→取消强制并保留所有选定的值 . 变量是非强制的，它们获得强制之前的值。...", 
"body" : "要求：应用程序处于在线模式。多个变量是强制的。 点击 查看 → 观看 → 观看所有力量 . 这 观看所有力量 视图打开。它以观察列表的形式包含应用程序的所有当前强制变量。 选择列表中的所有行，然后在视图左上角的列表框中单击 取消强制→取消强制并保留所有选定的值 . 变量是非强制的，它们获得强制之前的值。 " }, 
{ "title" : "在 CFC 中强制输入功能块 ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_94214d0432e61124c0a8640e01320552", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 变量的强制和写入 \/ 在 CFC 中强制输入功能块 ", 
"snippet" : "要求：应用程序具有包含功能块的 CFC POU，并且应用程序处于离线模式。 这种强制在内部使用数据断点，因此不同于使用 强制值 命令或 F7 . 强制的价值观 强制功能块输入 命令不响应 观看所有部队 或者 取消强制值 命令。 通过双击树中的对象打开 CFC POU 的编辑器。 登录到目标设备上的应用程序。 使用编译器版本 3.5.11.x 或 3.5.12.x 时，启用所需功能块的“强制性”。在 CFC 中选择 POU 元素并单击 CFC → 为强制准备盒子 . 在 CFC 中，选择 POU 的输入并单击 强制功能块输入 在上下文菜单中。 这 强制值 对话框打开。 为输入设置一个新值。情况下...", 
"body" : "要求：应用程序具有包含功能块的 CFC POU，并且应用程序处于离线模式。 这种强制在内部使用数据断点，因此不同于使用 强制值 命令或 F7 . 强制的价值观 强制功能块输入 命令不响应 观看所有部队 或者 取消强制值 命令。 通过双击树中的对象打开 CFC POU 的编辑器。 登录到目标设备上的应用程序。 使用编译器版本 3.5.11.x 或 3.5.12.x 时，启用所需功能块的“强制性”。在 CFC 中选择 POU 元素并单击 CFC → 为强制准备盒子 . 在 CFC 中，选择 POU 的输入并单击 强制功能块输入 在上下文菜单中。 这 强制值 对话框打开。 为输入设置一个新值。情况下的示例 TON 宝： FALSE 对于布尔输入 IN ， 或者 t#4s 为了 PT 输入（时间）。点击 行 确认。 立即强制设置值。 POU 元素的左上角显示一个绿色圆圈，元素中的输入名称以绿色突出显示。在布尔值的情况下，带有该值的小型监控视图也会在输入处打开。在监控视图中显示强制值，例如在 价值 列，如声明部分。 要删除强制值，请单击 强制功能块输入 再次。在里面 强制值 对话框，选择 移除价值 选项。 强制取消。输入从控制器获取当前值。 有关更多信息，请参阅： 力值 和 写入值" }, 
{ "title" : "重置应用程序 ", 
"url" : "_cds_reset_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 重置应用程序 ", 
"snippet" : "重置应用程序会停止程序并将变量重置为其初始化值。根据重置的类型，保留变量和持久变量也会被重置。 Reset Warm：所有变量都被重置，除了 RETAIN 和 PERSISTENT 变量。 冷重置：所有变量都被重置，除了 PERSISTENT 变量。 重置原点：重置所有变量。 重置源设备：重置所有变量并删除所有应用程序。 以下示例程序和语句阐明了各种复位的功能。 示例程序 宣言 VAR iVar: INT := 0; END_VAR VAR RETAIN iVarRetain: INT :=0; END_VAR VAR PERSISTENT iVarPersistent : INT:= 0; ...", 
"body" : "重置应用程序会停止程序并将变量重置为其初始化值。根据重置的类型，保留变量和持久变量也会被重置。 Reset Warm：所有变量都被重置，除了 RETAIN 和 PERSISTENT 变量。 冷重置：所有变量都被重置，除了 PERSISTENT 变量。 重置原点：重置所有变量。 重置源设备：重置所有变量并删除所有应用程序。 以下示例程序和语句阐明了各种复位的功能。 示例程序 宣言 VAR\n iVar: INT := 0;\nEND_VAR\nVAR RETAIN\n iVarRetain: INT :=0;\nEND_VAR\nVAR PERSISTENT\n iVarPersistent : INT:= 0;\nEND_VAR 执行 iVar := 100;\niVarRetain := 200;\niVarPersistent :=300; 插入 持久变量 应用程序下方的对象并在编辑器中打开它。 执行 构建 → 构建 命令。 执行 声明 → 添加所有实例路径 命令。 插入持久变量的实例路径。 将应用程序下载到控制器。 执行热复位、冷复位和原点复位 要求：示例程序在控制器上运行。 点击 在线 → 登录 切换到在线模式。 监控变量 iVar , iVarRetain ， 和 iVarPersistent . 在里面 在线的 菜单，单击 热复位 。 系统会提示您是否真的要执行该命令。 点击 是的 确认对话框。 应用程序被重置。这 iVar 变量设置为初始化值 0。其他两个变量都保留它们的值。 在里面 在线的 菜单，单击 冷复位。 系统会提示您是否真的要执行该命令。 点击 是的 确认对话框。 应用程序被重置。这 iVar 和 iVarRetain 变量设置为初始化值 0。 iVarPersistent 变量保留其值。 在里面 在线的 菜单，单击 重置原点 。 系统会提示您是否真的要执行该命令。 点击 是的 确认对话框。 应用程序被重置。所有变量都重置为其初始化值。 " }, 
{ "title" : "流量控制 ", 
"url" : "_cds_flowcontrol.html", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 流量控制 ", 
"snippet" : "通过流控制，您可以监控应用程序的处理过程。为 ST、FBD、LD 和 CFC 语言编辑器提供流控制。 使用激活的流量控制， CODESYS 在相应的处理位置和时间显示来自函数调用和操作的变量值和结果。通过这种方式，处理当前循环的代码和网络的确切行以颜色标记。将此与标准监控进行比较，其中 CODESYS 仅提供变量在两个处理周期之间的值。 流控制适用于当前可见的编辑器视图的所有部分。 启用流量控制 只要该功能处于活动状态并且流控制位置（代码的已处理部分）在编辑器视图中可见，就会在状态行中显示。 您可以在声明部分和实现部分写入值。强迫是不可能的。 在当前周期结束时写入值。 当您启用 流量控制 ，应...", 
"body" : "通过流控制，您可以监控应用程序的处理过程。为 ST、FBD、LD 和 CFC 语言编辑器提供流控制。 使用激活的流量控制， CODESYS 在相应的处理位置和时间显示来自函数调用和操作的变量值和结果。通过这种方式，处理当前循环的代码和网络的确切行以颜色标记。将此与标准监控进行比较，其中 CODESYS 仅提供变量在两个处理周期之间的值。 流控制适用于当前可见的编辑器视图的所有部分。 启用流量控制 只要该功能处于活动状态并且流控制位置（代码的已处理部分）在编辑器视图中可见，就会在状态行中显示。 您可以在声明部分和实现部分写入值。强迫是不可能的。 在当前周期结束时写入值。 当您启用 流量控制 ，应用程序的周期时间延长。 什么时候 确认在线模式 在通讯设置中选择 ，开启流控取消操作时会出现对话框提示。 启用流控制后，无法使用断点或单步执行程序。 在不同语言编辑器中显示流控制： 默认情况下， CODESYS 将已处理部分代码的流控位置显示为绿色字段。未处理的代码部分显示为白色。 请注意，未处理的代码位置的显示值是“正常”监控值。这是两个任务周期之间的值。 在网络编辑中， CODESYS 在“流控制颜色”的左边缘用条形标记已处理的网络。 在 LD 中， CODESYS 以绿色显示当前处理的连接线，以灰色显示所有其他连接线。连接的实际值也会显示： TRUE 用粗蓝线， FALSE 用粗黑线表示，未知或模拟值用细黑线表示。这些线的组合显示为虚线。 在 IL 中，对于每个语句 CODESYS 使用两个字段来显示实际值。一个位于具有当前累加器值的运算符的左侧，一个位于具有操作数值的操作数的右侧。 " }, 
{ "title" : "使用调用堆栈确定当前处理位置 ", 
"url" : "_cds_call_stack.html", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 使用调用堆栈确定当前处理位置 ", 
"snippet" : "您可以使用调用堆栈来确定程序流的当前位置。此功能在步入程序时非常有用。 要求：应用程序处于在线模式。程序在断点处停止，或者您正在单步执行。 点击 查看 → 调用堆栈 打开调用堆栈。 调用堆栈打开。该列表显示具有完整调用路径的当前位置。 调用堆栈也可用于离线模式和正常在线模式（不使用调试功能）。在这种情况下，它会在分步执行期间获取最后显示的位置，但它以“灰色”字体显示。...", 
"body" : "您可以使用调用堆栈来确定程序流的当前位置。此功能在步入程序时非常有用。 要求：应用程序处于在线模式。程序在断点处停止，或者您正在单步执行。 点击 查看 → 调用堆栈 打开调用堆栈。 调用堆栈打开。该列表显示具有完整调用路径的当前位置。 调用堆栈也可用于离线模式和正常在线模式（不使用调试功能）。在这种情况下，它会在分步执行期间获取最后显示的位置，但它以“灰色”字体显示。 " }, 
{ "title" : "检查任务列表 ", 
"url" : "_cds_check_task_deployment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 测试和调试 \/ 检查任务列表 ", 
"snippet" : "这 任务列表 设备编辑器的选项卡概述了处理应用程序 I\/O 映射的各个输入和输出的任务以及它们的优先级。您可以在此处检查是否导致无意覆盖值，这可能导致未定义的值。 为应用程序生成代码（例如：单击 构建 → 生成代码 ）。 通过双击设备树中的设备对象打开设备编辑器。点击 任务列表 标签。 您可以看到应用程序的输入和输出以及任务的分配及其优先级。见说明 任务列表 选项卡了解详情。...", 
"body" : "这 任务列表 设备编辑器的选项卡概述了处理应用程序 I\/O 映射的各个输入和输出的任务以及它们的优先级。您可以在此处检查是否导致无意覆盖值，这可能导致未定义的值。 为应用程序生成代码（例如：单击 构建 → 生成代码 ）。 通过双击设备树中的设备对象打开设备编辑器。点击 任务列表 标签。 您可以看到应用程序的输入和输出以及任务的分配及其优先级。见说明 任务列表 选项卡了解详情。 " }, 
{ "title" : "运行时应用 ", 
"url" : "_cds_struct_application_in_operation.html", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 ", 
"snippet" : "当应用程序在 PLC 上运行时， CODESYS 用于监视和更改变量值以及记录和保存其历史记录的开发系统。 还有一些选项可以从 PLC 查询特定信息、查看 PLC 日志、显示核心转储以及监控任务的时序行为。 还要注意在机器的关键状态下通过来自开发系统的在线命令限制对正在运行的应用程序的访问的选项。为此，可以通过 ComponentManager 库的模块使用特定的系统变量。...", 
"body" : "当应用程序在 PLC 上运行时， CODESYS 用于监视和更改变量值以及记录和保存其历史记录的开发系统。 还有一些选项可以从 PLC 查询特定信息、查看 PLC 日志、显示核心转储以及监控任务的时序行为。 还要注意在机器的关键状态下通过来自开发系统的在线命令限制对正在运行的应用程序的访问的选项。为此，可以通过 ComponentManager 库的模块使用特定的系统变量。 " }, 
{ "title" : "价值监控 ", 
"url" : "_cds_f_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 ", 
"snippet" : "在运行时，您可以监控项目中不同位置的编程对象的当前变量值。以下就是我们所说的“监控”。 对象编程编辑器的在线视图：“在线监控” 对象声明编辑器的在线视图 独立于对象，可配置 观察名单 当您设置 {属性“监控”…} pragma，您可以监视函数调用的结果和属性类型对象中的当前变量值。 记录当前变量值的更多选项： 读取并保存 食谱 在时间线上记录值以立即或稍后显示历史记录： 轨迹与趋势...", 
"body" : "在运行时，您可以监控项目中不同位置的编程对象的当前变量值。以下就是我们所说的“监控”。 对象编程编辑器的在线视图：“在线监控” 对象声明编辑器的在线视图 独立于对象，可配置 观察名单 当您设置 {属性“监控”…} pragma，您可以监视函数调用的结果和属性类型对象中的当前变量值。 记录当前变量值的更多选项： 读取并保存 食谱 在时间线上记录值以立即或稍后显示历史记录： 轨迹与趋势 " }, 
{ "title" : "在编程对象中调用监控 ", 
"url" : "_cds_using_monitoring_in_pous.html", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 \/ 在编程对象中调用监控 ", 
"snippet" : "当应用程序在控制器上运行时，变量的实际值会显示在 POU 的编辑器中。这就是监控变量值的方式。 要求： 启用在线监控 选项被选中 工具 → 选项 在里面 文本编辑器 上的类别 监控 标签。 将应用程序下载到控制器并启动它。 点击 调试 → 显示模式 → 十进制 . 设置实际值的显示格式。 单击程序中的编程对象 设备 查看或 POU 看法。 相应的编辑器打开。对于声明和实现，变量的实际值会不断刷新。 监控函数调用的返回值 在 POU 的 ST 编辑器中，当前返回值在调用函数的 POU 的位置显示为内联监控。 必须满足以下条件： 该值可以解释为 4 字节数值。例子： INT , SINT ， 或者...", 
"body" : "当应用程序在控制器上运行时，变量的实际值会显示在 POU 的编辑器中。这就是监控变量值的方式。 要求： 启用在线监控 选项被选中 工具 → 选项 在里面 文本编辑器 上的类别 监控 标签。 将应用程序下载到控制器并启动它。 点击 调试 → 显示模式 → 十进制 . 设置实际值的显示格式。 单击程序中的编程对象 设备 查看或 POU 看法。 相应的编辑器打开。对于声明和实现，变量的实际值会不断刷新。 监控函数调用的返回值 在 POU 的 ST 编辑器中，当前返回值在调用函数的 POU 的位置显示为内联监控。 必须满足以下条件： 该值可以解释为 4 字节数值。例子： INT , SINT ， 或者 LINT . 语用 {attribute 'monitoring' := 'call'} 被插入到函数中。 " }, 
{ "title" : "在声明编辑器中监控 ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_da1e73000e6d11e49893a65c94288ced", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 \/ 在编程对象中调用监控 \/ 在声明编辑器中监控 ", 
"snippet" : "表达式 (1) 的实际值显示在 价值 第 (3) 列。 变量的注释显示在 评论 专栏 (6)。 有关显示评论的逻辑和优先级的更多信息，请参阅： ST 评论您可以在 准备值 (4) 栏目。强制期间，实际值用红色装饰 象征。 可以扩展接口引用的表达式。如果接口指向全局实例，则此全局实例显示为引用下方的第一个条目。之后，如果界面引用发生变化，则显示的引用将被折叠。...", 
"body" : "表达式 (1) 的实际值显示在 价值 第 (3) 列。 变量的注释显示在 评论 专栏 (6)。 有关显示评论的逻辑和优先级的更多信息，请参阅： ST 评论您可以在 准备值 (4) 栏目。强制期间，实际值用红色装饰 象征。 可以扩展接口引用的表达式。如果接口指向全局实例，则此全局实例显示为引用下方的第一个条目。之后，如果界面引用发生变化，则显示的引用将被折叠。 " }, 
{ "title" : "实施中的监控（在线监控） ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_cf62c2c62f969db9c0a8646339d800c9", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 \/ 在编程对象中调用监控 \/ 实施中的监控（在线监控） ", 
"snippet" : "内联监控是在实现中显示当前变量值。 根据实施语言，实施部分可能会出现以下显示： 变量有一个窗口 当前值显示在其名称之后。 如果您为强制或写入的变量准备了值，则它们将在内联监控视图中显示在当前值之后的尖括号中。 强制后，相应的值由 象征。 网络编辑器和 CFC 编辑器 连接线根据其实际布尔值以颜色显示（蓝色表示 TRUE , 黑色表示 FALSE ）。 LD编辑器 触点和线圈元件也有标记。 对于触点和线圈，准备值 ( TRUE 或者 FALSE ) 显示在元素旁边的小视图中。 证监会编辑器 带有值的转换 TRUE 根据其实际布尔值以颜色显示（蓝色表示 TRUE , 黑色表示 FALSE ）。 活...", 
"body" : "内联监控是在实现中显示当前变量值。 根据实施语言，实施部分可能会出现以下显示： 变量有一个窗口 当前值显示在其名称之后。 如果您为强制或写入的变量准备了值，则它们将在内联监控视图中显示在当前值之后的尖括号中。 强制后，相应的值由 象征。 网络编辑器和 CFC 编辑器 连接线根据其实际布尔值以颜色显示（蓝色表示 TRUE , 黑色表示 FALSE ）。 LD编辑器 触点和线圈元件也有标记。 对于触点和线圈，准备值 ( TRUE 或者 FALSE ) 显示在元素旁边的小视图中。 证监会编辑器 带有值的转换 TRUE 根据其实际布尔值以颜色显示（蓝色表示 TRUE , 黑色表示 FALSE ）。 活动步骤以蓝色显示。 强制转换值在实现中显示为红色。 IL 表格编辑器 当前值显示在单独的列中。 在 ST 编辑器中监控 在 LD 编辑器中监控 在 SFC 编辑器中监视 您可以在 工具 → 选项 ， 在里面 文本编辑器 类别，在 监控 标签。 " }, 
{ "title" : "阵列的部分监控 ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_17c4ba57134411e497a3a811bc4d899a", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 \/ 在编程对象中调用监控 \/ 阵列的部分监控 ", 
"snippet" : "扩展数组显示最多 1000 个元素的实际值。但是，这可能会令人困惑。此外，一个数组可以包含超过 1000 个元素。然后限制显示元素的范围是有帮助的。您可以通过以下方式在在线模式下执行此操作。 限制监控范围 要求：应用程序正在运行。它包含一个具有 1000 多个元素的多维数组变量。 例子： arrBig : ARRAY [0..100, -9..10, -19..20] OF INT; 在字段中单击 数据类型 列 arrBig 多变的。 这 监测范围 对话框打开。 指定值 [1, -9, -19] 为了 开始 . 指定值 [1, 10, 20] 为了 结尾 . 800 个数组元素的实际值显示在声...", 
"body" : "扩展数组显示最多 1000 个元素的实际值。但是，这可能会令人困惑。此外，一个数组可以包含超过 1000 个元素。然后限制显示元素的范围是有帮助的。您可以通过以下方式在在线模式下执行此操作。 限制监控范围 要求：应用程序正在运行。它包含一个具有 1000 多个元素的多维数组变量。 例子： arrBig : ARRAY [0..100, -9..10, -19..20] OF INT; 在字段中单击 数据类型 列 arrBig 多变的。 这 监测范围 对话框打开。 指定值 [1, -9, -19] 为了 开始 . 指定值 [1, 10, 20] 为了 结尾 . 800 个数组元素的实际值显示在声明编辑器中。范围仅限于索引的元素 [1, <i>, <j>] i 从 -9 到 10， j 从 -19 到 20。 " }, 
{ "title" : "监视功能块 ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_cc4f35463a9211e9a9a6d1f408c21742", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 \/ 在编程对象中调用监控 \/ 监视功能块 ", 
"snippet" : "当您在在线模式下双击功能块的编辑器视图时，将打开一个对话框，您可以在其中选择查看基本实现或特定实例。 如果选择基本实现，则代码在编辑器中显示，没有当前值。现在在基本实现中设置断点。如果执行在那里停止，则显示程序流中首先处理的实例的当前值。现在您可以逐步遍历所有实例。 如果您选择其中一个实例，则编辑器将打开并显示功能块实例的代码。当前值显示在声明中，如果适用，在实施中显示，并不断更新。...", 
"body" : "当您在在线模式下双击功能块的编辑器视图时，将打开一个对话框，您可以在其中选择查看基本实现或特定实例。 如果选择基本实现，则代码在编辑器中显示，没有当前值。现在在基本实现中设置断点。如果执行在那里停止，则显示程序流中首先处理的实例的当前值。现在您可以逐步遍历所有实例。 如果您选择其中一个实例，则编辑器将打开并显示功能块实例的代码。当前值显示在声明中，如果适用，在实施中显示，并不断更新。 " }, 
{ "title" : "监控属性 ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_089ce320132311e497a3a811bc4d899a", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 \/ 在编程对象中调用监控 \/ 监控属性 ", 
"snippet" : "您可以监控变量 属性对象通过在在线模式下在函数中设置断点。停在那里时，会显示当前值。 除了您自己的值之外，还会自动显示上级实例的变量值。在财产的声明部分， THIS 指向上级实例的指针出现在具有当前数据类型信息和值的第一行。 例子 代码 FUNCTION_BLOCK FB_BaseAlfa VAR iBaseLocal : INT; sBaseLocal : STRING; END_VAR iBaseLocal := iBaseLocal + 1; sBaseLocal := 'Testing Text'; FB_BaseAlfa.PorpBeta.Get iBaseLocal := iBas...", 
"body" : "您可以监控变量 属性对象通过在在线模式下在函数中设置断点。停在那里时，会显示当前值。 除了您自己的值之外，还会自动显示上级实例的变量值。在财产的声明部分， THIS 指向上级实例的指针出现在具有当前数据类型信息和值的第一行。 例子 代码 FUNCTION_BLOCK FB_BaseAlfa\nVAR\n iBaseLocal : INT;\n sBaseLocal : STRING;\nEND_VAR\niBaseLocal := iBaseLocal + 1;\nsBaseLocal := 'Testing Text';\n\nFB_BaseAlfa.PorpBeta.Get\niBaseLocal := iBaseLocal + 1;\nIF iBaseLocal > 0 THEN\n PropBeta := TRUE;\nEND_IF\n\nFB_BaseAlfa.PorpBeta.Set\nIF PropBeta = TRUE THEN\n iBaseLocal := 0;\n sBaseLocal := 'Tested IF';\nEND_IF\n\n\nPROGRAM PLC_PRG\nVAR\n fb_BaseAlfa : FB_BaseAlfa;\nEND_VAR\n\nfb_BaseAlfa();\n\nIF fb_BaseAlfa.PropBeta = TRUE THEN\n xResult := TRUE;\nEND_IF\nIF xReset THEN\n fb_BaseAlfa.PropBeta := TRUE;\n xReset := FALSE;\nEND_IF " }, 
{ "title" : "监视上级编程对象中的属性访问 ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_4c0f3a123aa211e9a9a6d1f408c21742", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 \/ 在编程对象中调用监控 \/ 监视上级编程对象中的属性访问 ", 
"snippet" : "您可以监控下属的值 除了变量值之外，功能块或程序中的属性。 为此，请添加 pragma {attribute 'monitoring' = 'variable'} 或者 {attribute 'monitoring' = 'call'} 到声明中的从属属性对象。如果在运行时打开上级程序实例或功能块实例，则除了当前变量值外，当前属性值也会显示在编辑器中。...", 
"body" : "您可以监控下属的值 除了变量值之外，功能块或程序中的属性。 为此，请添加 pragma {attribute 'monitoring' = 'variable'} 或者 {attribute 'monitoring' = 'call'} 到声明中的从属属性对象。如果在运行时打开上级程序实例或功能块实例，则除了当前变量值外，当前属性值也会显示在编辑器中。 " }, 
{ "title" : "监控方法 ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_86a261815e598a34c0a8640e0001140c", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 \/ 在编程对象中调用监控 \/ 监控方法 ", 
"snippet" : "您可以监控变量 方法对象通过在在线模式期间在方法中设置断点。停在那里时，会显示当前值。 除了您自己的值之外，还会自动显示上级实例的变量值。在方法的声明部分， THIS 指向上级实例的指针与当前数据类型信息和值一起出现在第一行。 例子 代码 FUNCTION_BLOCK FB_BaseAlfa VAR iBaseLocal : INT; sBaseLocal : STRING; END_VAR iBaseLocal := iBaseLocal + 1; sBaseLocal := 'Testing Text'; METHOD MethBaseAlfa : BOOL \/\/ Method of FB...", 
"body" : "您可以监控变量 方法对象通过在在线模式期间在方法中设置断点。停在那里时，会显示当前值。 除了您自己的值之外，还会自动显示上级实例的变量值。在方法的声明部分， THIS 指向上级实例的指针与当前数据类型信息和值一起出现在第一行。 例子 代码 FUNCTION_BLOCK FB_BaseAlfa\nVAR\n iBaseLocal : INT;\n sBaseLocal : STRING;\nEND_VAR\niBaseLocal := iBaseLocal + 1;\nsBaseLocal := 'Testing Text';\n\nMETHOD MethBaseAlfa : BOOL \/\/ Method of FB_BaseAlfa\nVAR_INPUT\nEND_VAR\nVAR\n iMethLocal : INT;\nEND_VAR\niMethLocal := iMethLocal + 1;\n\n\nPROGRAM PLC_PRG\nVAR\n fb_BaseAlfa : FB_BaseAlfa;\nEND_VAR\nfb_BaseAlfa();\nfb_BaseAlfa.MethBaseAlfa(); " }, 
{ "title" : "监控功能 ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_ae89ec4d3f3d11e9beb58b29d367590b", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 \/ 在编程对象中调用监控 \/ 监控功能 ", 
"snippet" : "您可以通过在在线模式下在函数中设置断点来监视函数对象中的变量。停在那里时，会显示当前值。...", 
"body" : "您可以通过在在线模式下在函数中设置断点来监视函数对象中的变量。停在那里时，会显示当前值。 " }, 
{ "title" : "使用观察列表 ", 
"url" : "_cds_using_watchlists.html", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 \/ 使用观察列表 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "什么是观察名单？ ", 
"url" : "_cds_using_watchlists.html#UUID-aa48d044-1dcc-85b4-3abf-5972dd8036a1_id_a81a96006e9d8726c0a8640e01e78912_id_952107db6cf010acc0a8640e01262d4f", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 \/ 使用观察列表 \/ 什么是观察名单？ ", 
"snippet" : "监视列表是用户定义的项目变量列表，这些变量收集在一个视图中，用于监控其值。在在线模式下，您可以在观察列表中写入和强制变量值。监视、写入和强制的处理方式与 申报编辑器在线模式 .您可以自定义浮点值的表示格式 监控选项 . 有四个即用型观察列表（ Watch <n> ) 在项目中可用。点击 查看→ 观看 . 如果表达式是一个接口引用，那么它可以被扩展。如果接口指向全局实例，则此全局实例显示为引用下方的第一个条目。如果接口参考发生变化，则显示的参考将折叠。...", 
"body" : "监视列表是用户定义的项目变量列表，这些变量收集在一个视图中，用于监控其值。在在线模式下，您可以在观察列表中写入和强制变量值。监视、写入和强制的处理方式与 申报编辑器在线模式 .您可以自定义浮点值的表示格式 监控选项 . 有四个即用型观察列表（ Watch <n> ) 在项目中可用。点击 查看→ 观看 . 如果表达式是一个接口引用，那么它可以被扩展。如果接口指向全局实例，则此全局实例显示为引用下方的第一个条目。如果接口参考发生变化，则显示的参考将折叠。 " }, 
{ "title" : "创建和编辑监视列表（离线或在线模式） ", 
"url" : "_cds_using_watchlists.html#UUID-aa48d044-1dcc-85b4-3abf-5972dd8036a1_id_a81a96006e9d8726c0a8640e01e78912_id_706184106cf010aec0a8640e01576f72", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 \/ 使用观察列表 \/ 创建和编辑监视列表（离线或在线模式） ", 
"snippet" : "要求：项目处于在线或离线模式。它包括一个带有声明变量的应用程序，您希望将其添加到四个可能的监视列表之一。 点击 查看 → 观看 → 观看 <n> . 这 Watch <n> 视图打开。它包含一个空白表格行。 双击字段中的 表达 列并键入要监视的变量，手动或使用输入助手。 语法：<设备名称>.<应用程序名称>.<对象名称>.<变量名称> 例子： ” Dev1.App1.PLC_PRG.ivar \" 如果您键入结构化变量的名称，则各个组件将在在线模式下自动显示在其他行中。 定义将使用此列表监视的所有连续变量。您可以通过将项目拖动到新位置来更改顺序。 这 执行点 , 类型 , 地址 , 评论 字段根...", 
"body" : "要求：项目处于在线或离线模式。它包括一个带有声明变量的应用程序，您希望将其添加到四个可能的监视列表之一。 点击 查看 → 观看 → 观看 <n> . 这 Watch <n> 视图打开。它包含一个空白表格行。 双击字段中的 表达 列并键入要监视的变量，手动或使用输入助手。 语法：<设备名称>.<应用程序名称>.<对象名称>.<变量名称> 例子： ” Dev1.App1.PLC_PRG.ivar \" 如果您键入结构化变量的名称，则各个组件将在在线模式下自动显示在其他行中。 定义将使用此列表监视的所有连续变量。您可以通过将项目拖动到新位置来更改顺序。 这 执行点 , 类型 , 地址 , 评论 字段根据变量声明自动填写。表达式前面的符号表示变量的类型：输入变量 ( ), 输出变量 ( ），或“正常”变量（ ）。 在在线模式下，您还可以通过单击创建或编辑监视列表 添加手表 在上下文菜单中。 " }, 
{ "title" : "通过 Add Watch 命令添加变量（在线模式） ", 
"url" : "_cds_using_watchlists.html#UUID-aa48d044-1dcc-85b4-3abf-5972dd8036a1_id_a81a96006e9d8726c0a8640e01e78912_id_efc074136cf010afc0a8640e01cc70f3", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 价值监控 \/ 使用观察列表 \/ 通过 Add Watch 命令添加变量（在线模式） ", 
"snippet" : "要求：项目已打开并正在运行。它包括一个带有声明变量的应用程序，您希望将这些变量添加到可能的观察列表中。 点击 查看 → 观看 <n> 打开监视列表。 将光标放在 POU 的声明或实现部分中的变量上，然后右键单击以选择 添加手表 命令。 将条目添加到所选变量的列表中。 您可以通过这种方式添加其他变量，也可以直接在列表中键入 表达 如上所述的字段（“创建和编辑...”）。 观察名单会立即更新。 如果单击时未打开监视列表 添加手表 对于一个变量，然后它会自动添加到 观看 1 列表。 在监视列表中也可以写入和强制变量值。在联机模式下， 准备值 列也可用。...", 
"body" : "要求：项目已打开并正在运行。它包括一个带有声明变量的应用程序，您希望将这些变量添加到可能的观察列表中。 点击 查看 → 观看 <n> 打开监视列表。 将光标放在 POU 的声明或实现部分中的变量上，然后右键单击以选择 添加手表 命令。 将条目添加到所选变量的列表中。 您可以通过这种方式添加其他变量，也可以直接在列表中键入 表达 如上所述的字段（“创建和编辑...”）。 观察名单会立即更新。 如果单击时未打开监视列表 添加手表 对于一个变量，然后它会自动添加到 观看 1 列表。 在监视列表中也可以写入和强制变量值。在联机模式下， 准备值 列也可用。 " }, 
{ "title" : "带跟踪的数据采样 ", 
"url" : "_cds_f_data_acquiring_with_trace.html", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 带跟踪的数据采样 ", 
"snippet" : "要求： CODESYS Trace 软件包已安装。 您可以使用 痕迹 以与数字采样示波器类似的方式跟踪控制器上变量的值曲线。数据及其历史记录可以显示在跟踪编辑器中。 有关更多信息，请参阅： 代码系统跟踪...", 
"body" : "要求： CODESYS Trace 软件包已安装。 您可以使用 痕迹 以与数字采样示波器类似的方式跟踪控制器上变量的值曲线。数据及其历史记录可以显示在跟踪编辑器中。 有关更多信息，请参阅： 代码系统跟踪 " }, 
{ "title" : "监控任务 ", 
"url" : "_cds_monitoring_running_tasks.html", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 监控任务 ", 
"snippet" : "在在线模式下，您可以显示运行时系统中任务的一些统计值。此信息对于测试时钟周期或解决运行时性能问题非常有用。 切换到在线模式。 在设备树中，选择 任务配置 目的。 点击 项目 → 编辑对象 . 任务配置在编辑器中打开。 点击 监视器 标签。...", 
"body" : "在在线模式下，您可以显示运行时系统中任务的一些统计值。此信息对于测试时钟周期或解决运行时性能问题非常有用。 切换到在线模式。 在设备树中，选择 任务配置 目的。 点击 项目 → 编辑对象 . 任务配置在编辑器中打开。 点击 监视器 标签。 " }, 
{ "title" : "读取 PLC 日志 ", 
"url" : "_cds_reading_plc_log.html", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 读取 PLC 日志 ", 
"snippet" : "CODESYS 提供显示控制器中记录的事件和错误消息的能力。 阅读日志 要求：PLC 正在运行。 在设备树中，选择控制器。 点击 项目 → 编辑对象 . 设备编辑器打开。 点击 日志 标签。 点击 按钮刷新视图。 与控制器的连接已建立。控制器在设备树中以绿色突出显示。 显示控制器的所有日志事件。前置图标指示日志事件的严重性： ： 警告 ： 错误 ： 例外 ： 信息 : 调试 如果您不想查看特定严重性的事件，请单击菜单栏中的相应图标。当您再次单击此图标时，这些日志事件将再次显示。例如，单击 如果您不希望显示具有“错误”严重性的日志事件，请单击菜单栏中的图标。 在里面 在消息中搜索 输入字段，指定...", 
"body" : "CODESYS 提供显示控制器中记录的事件和错误消息的能力。 阅读日志 要求：PLC 正在运行。 在设备树中，选择控制器。 点击 项目 → 编辑对象 . 设备编辑器打开。 点击 日志 标签。 点击 按钮刷新视图。 与控制器的连接已建立。控制器在设备树中以绿色突出显示。 显示控制器的所有日志事件。前置图标指示日志事件的严重性： ： 警告 ： 错误 ： 例外 ： 信息 : 调试 如果您不想查看特定严重性的事件，请单击菜单栏中的相应图标。当您再次单击此图标时，这些日志事件将再次显示。例如，单击 如果您不希望显示具有“错误”严重性的日志事件，请单击菜单栏中的图标。 在里面 在消息中搜索 输入字段，指定搜索词以在列表中查找特定事件。然后你可以使用 和 按钮跳转到颜色编码的搜索结果。 过滤事件 严重性 , 时间戳 , 描述 ， 或者 零件 ，单击相应的列标题。 点击 按钮将显示的日志事件保存到文件中。 " }, 
{ "title" : "使用 PLC Shell 查询信息 ", 
"url" : "_cds_querying_information_via_plc_shell.html", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 使用 PLC Shell 查询信息 ", 
"snippet" : "“PLC外壳”在 CODESYS 是设备编辑器选项卡上基于文本的控制器监视器。您可以在此处输入命令以查询特定信息，以及执行启动、停止或加载应用程序等操作。您还可以直接从 PLC shell 获得可能命令的含义和语法的描述。 可能的命令取决于制造商。命令的范围可以通过扩展 PLC Shell Command Handler 在运行系统中的 C 组件中，或作为 IEC 库或项目中的功能块。 来自 PLC 的响应在选项卡上显示为结果窗口中的字符串。 查询控制器上的应用程序信息 要求：您的项目已连接到控制器（例如： CODESYS Control Win ) 在其上 App1 应用程序正在运行。 双击...", 
"body" : "“PLC外壳”在 CODESYS 是设备编辑器选项卡上基于文本的控制器监视器。您可以在此处输入命令以查询特定信息，以及执行启动、停止或加载应用程序等操作。您还可以直接从 PLC shell 获得可能命令的含义和语法的描述。 可能的命令取决于制造商。命令的范围可以通过扩展 PLC Shell Command Handler 在运行系统中的 C 组件中，或作为 IEC 库或项目中的功能块。 来自 PLC 的响应在选项卡上显示为结果窗口中的字符串。 查询控制器上的应用程序信息 要求：您的项目已连接到控制器（例如： CODESYS Control Win ) 在其上 App1 应用程序正在运行。 双击 CODESYS Control Win 对象以在设备树中打开设备编辑器，然后选择 PLC外壳 标签。 该选项卡显示为一个空窗口。下面是命令行。 点击 按钮。 这 插入标准命令 对话框打开，其中包含命令列表。 选择 ? 命令并单击 执行 按钮。 对话框关闭，并在输出窗口中显示带有可能参数的可用命令列表。它显示了每种情况下命令输入的语法。 点击 再次选择 PID 命令。将以下内容添加到输入行： pid App1 .按回车键。 输出窗口中显示以下内容（GUID 仅作为示例）： pid App1 Project Identification Application: App1 Code GUID:0x08a893c0 Data GUID:0x762d0e90 按下 命令输入行中的按钮。 这 pid App1 命令包含在输入命令的历史记录中。 " }, 
{ "title" : "通过系统变量控制 PLC 运行 ", 
"url" : "_cds_operation_control_via_system_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 通过系统变量控制 PLC 运行 ", 
"snippet" : "您负责在安全应用程序条件下启用运行时系统服务，并仅在关键条件下禁用运行时系统服务。 在运行时，应用程序或设施的状态可能变得敏感，破坏性操作可能危及整个机器或设施。但是，在这种状态下，您可以禁止某些命令并防止危险操作。这 可编程控制器 功能块和 组件管理器 为此目的提供了库。 示例 CODESYS 执行时可以抑制操作的命令： 在线更改 , 下载 启用断点 重置应用程序 , 停止申请 传输数据 强制值 , 写入值 这个 重置原始设备 命令无法停用，因此您无法完全将自己锁定在运行时系统之外。此命令是打开完全锁定的运行时系统的最后一个选项，在该系统中，所有关键操作都处于停用状态。这通常是可以接受的，因...", 
"body" : "您负责在安全应用程序条件下启用运行时系统服务，并仅在关键条件下禁用运行时系统服务。 在运行时，应用程序或设施的状态可能变得敏感，破坏性操作可能危及整个机器或设施。但是，在这种状态下，您可以禁止某些命令并防止危险操作。这 可编程控制器 功能块和 组件管理器 为此目的提供了库。 示例 CODESYS 执行时可以抑制操作的命令： 在线更改 , 下载 启用断点 重置应用程序 , 停止申请 传输数据 强制值 , 写入值 这个 重置原始设备 命令无法停用，因此您无法完全将自己锁定在运行时系统之外。此命令是打开完全锁定的运行时系统的最后一个选项，在该系统中，所有关键操作都处于停用状态。这通常是可以接受的，因为此命令需要设备用户管理中的扩展权限。 CODESYS 如果在应用程序运行时需要当前禁用的运行时服务，将通知您。然后，您可以采取适当的对策来应对。 " }, 
{ "title" : "用于操作控制的 PlcOperationControl 功能块 ", 
"url" : "_cds_operation_control_via_system_variables.html#UUID-b0a8d090-cd03-6673-0ff7-b90ce6118e6a_id_cf02989893c0a8640e0164e374_id_0f29fd87c71811e4be8af5413b027a7b", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 通过系统变量控制 PLC 运行 \/ 用于操作控制的 PlcOperationControl 功能块 ", 
"snippet" : "该功能块用于启用和禁用操作。 财产（财产） 名称 数据类型 初始值 描述 xDisableApplicationOnlineChange BOOL FALSE TRUE : 在线更改被抑制 xDisableApplicationDownload BOOL FALSE TRUE : 下载被抑制 xDisableApplicationStop BOOL FALSE TRUE : 应用程序停止被抑制 xDisableApplicationBP BOOL FALSE TRUE : 禁止设置断点 xDisableApplicationWrite BOOL FALSE TRUE : 禁止写入变量 这也可以...", 
"body" : "该功能块用于启用和禁用操作。 财产（财产） 名称 数据类型 初始值 描述 xDisableApplicationOnlineChange BOOL FALSE TRUE : 在线更改被抑制 xDisableApplicationDownload BOOL FALSE TRUE : 下载被抑制 xDisableApplicationStop BOOL FALSE TRUE : 应用程序停止被抑制 xDisableApplicationBP BOOL FALSE TRUE : 禁止设置断点 xDisableApplicationWrite BOOL FALSE TRUE : 禁止写入变量 这也可以通过 PLCHandler\/IecVarAccess 抑制。 xDisableApplicationForce BOOL FALSE TRUE : 强制变量被抑制 xDisableApplicationReset BOOL FALSE TRUE ：应用程序的重置（不是“重置原点”）被抑制 xDisableAll BOOL FALSE TRUE ：所有操作被抑制 " }, 
{ "title" : "实施运营控制 ", 
"url" : "_cds_operation_control_via_system_variables.html#UUID-b0a8d090-cd03-6673-0ff7-b90ce6118e6a_id_cf02989893c0a8640e0164e374_id_695396c9235ca019c0a8640e003317ec", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 通过系统变量控制 PLC 运行 \/ 实施运营控制 ", 
"snippet" : "要求 编译器版本 >= 3.4.3.0 在设备描述中，PLC 运行控制由系统变量启用。 声明一个实例 PlcOperationControl 功能块（例如， PlcOpCtrl_Inst ）。 PlcOpCtrl_Inst : PlcOperationControl; 通过分配相应的命令来抑制命令 TRUE 属性（例如：“停止应用程序”）。 PlcOpCtrl_Inst.xDIsableApplicationStop := TRUE;...", 
"body" : "要求 编译器版本 >= 3.4.3.0 在设备描述中，PLC 运行控制由系统变量启用。 声明一个实例 PlcOperationControl 功能块（例如， PlcOpCtrl_Inst ）。 PlcOpCtrl_Inst : PlcOperationControl; 通过分配相应的命令来抑制命令 TRUE 属性（例如：“停止应用程序”）。 PlcOpCtrl_Inst.xDIsableApplicationStop := TRUE; " }, 
{ "title" : "备份还原 ", 
"url" : "_cds_restoring_applications_and_rts.html", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 备份还原 ", 
"snippet" : "CODESYS 和 CODESYS 标准运行系统（版本 3.5.8.0 及更高版本）支持在 PLC 上备份特定于应用程序的文件。您可以在 备份还原 通用设备编辑器的选项卡。 备份包括在包含应用程序相关文件和信息文件的 zip 存档中创建和保存文件 meta.info .此备份文件具有扩展名 TBF (=\"Target Backup File\") 并且可以保存在本地文件系统或 PLC 上。 从备份文件恢复软件状态时，以下内容适用： 将打开一个对话框，其中包含 PLC 上受影响文件的列表，您可以停用可选组件。 如果您需要将应用程序置于停止模式以进行保存或恢复，您将收到通知。同样，在不兼容的情况下会...", 
"body" : "CODESYS 和 CODESYS 标准运行系统（版本 3.5.8.0 及更高版本）支持在 PLC 上备份特定于应用程序的文件。您可以在 备份还原 通用设备编辑器的选项卡。 备份包括在包含应用程序相关文件和信息文件的 zip 存档中创建和保存文件 meta.info .此备份文件具有扩展名 TBF (=\"Target Backup File\") 并且可以保存在本地文件系统或 PLC 上。 从备份文件恢复软件状态时，以下内容适用： 将打开一个对话框，其中包含 PLC 上受影响文件的列表，您可以停用可选组件。 如果您需要将应用程序置于停止模式以进行保存或恢复，您将收到通知。同样，在不兼容的情况下会显示消息。 恢复到 PLC 时，用户界面被阻止。 现有文件会在没有警告的情况下被覆盖。 只要至少一个新的引导应用程序是还原的一部分，现有的引导应用程序就会被停用。 从备份文件恢复 要求：已打开一个项目，其中包含在所需设备上运行的应用程序。如上所述，备份文件被保存到本地文件系统。 通过双击设备树中的设备条目打开设备编辑器。点击 备份还原 标签。 点击 恢复 → 从磁盘加载备份文件 . 选择备份文件的默认提示打开 tbf 在本地文件系统中。 选择备份文件并单击 打开 . 这些文件从备份文件中读取并显示在下面的对话框表格中。文件 $PlcLogic$\/Application\/myExternalFile.txt 备份中排除的内容丢失。 点击 恢复 → 将备份恢复到设备 . 将打开一个对话框提示，其中包含有关还原时操作的信息。 点击 行 开始将文件恢复到 PLC 文件系统。 恢复完成后，系统会提示您重新启动 PLC 以激活加载的应用程序。 " }, 
{ "title" : "创建备份文件 ", 
"url" : "_cds_restoring_applications_and_rts.html#UUID-a5724295-15a5-2a21-ffa4-030d2000b46b_id_adae4542f3ceafacc0a8640e00a417a9_id_6dc6a99862ca11e5ba2e95faa584c1c4", 
"breadcrumbs" : "CODESYS Essentials \/ 运行时应用 \/ 备份还原 \/ 创建备份文件 ", 
"snippet" : "要求：已打开一个项目，其中包含在所需设备上运行的应用程序。此外，对于这个例子，一个外部文件 myExternalFile.txt 作为对象插入到应用程序下方。该文件在下载应用程序时被隐式下载到 PLC。 通过双击设备树中的设备条目打开设备编辑器。点击 备份还原 标签。 显示选项卡。它包含一个菜单栏，包括 备份 和 恢复 菜单。 在里面 备份 菜单，点击 从设备读取备份信息 . 如果此时 PLC 未连接，则 CODESYS 打开与设备的临时连接并从 $PlcLogic$ 将 PLC 目录放入标签页下方的表格中。在此示例中，至少将列出以下文件： $PlcLogic$\/Application\/App...", 
"body" : "要求：已打开一个项目，其中包含在所需设备上运行的应用程序。此外，对于这个例子，一个外部文件 myExternalFile.txt 作为对象插入到应用程序下方。该文件在下载应用程序时被隐式下载到 PLC。 通过双击设备树中的设备条目打开设备编辑器。点击 备份还原 标签。 显示选项卡。它包含一个菜单栏，包括 备份 和 恢复 菜单。 在里面 备份 菜单，点击 从设备读取备份信息 . 如果此时 PLC 未连接，则 CODESYS 打开与设备的临时连接并从 $PlcLogic$ 将 PLC 目录放入标签页下方的表格中。在此示例中，至少将列出以下文件： $PlcLogic$\/Application\/Application.app , $PlcLogic$\/Application\/Application.crc ， 和 $PlcLogic$\/Application\/myExternalFile.txt .此外，还列出了其他与项目相关的外部文件，这些文件已插入设备树中应用程序的下方。此外，源代码存档文件 $PlcLogic$\/Archive.prj 如果您为此设置了项目设置（ 隐含在程序下载和在线更改时 ) 作为加载时间。 在表中，清除复选框 $PlcLogic$\/Application\/\/myExternalFile.txt 文件中 积极的 柱子。 在里面 备份 菜单，点击 将备份文件保存到设备 . 这 另存为 对话框打开。文件类型预定义为 备份文件 (*.tbf) . 选择备份文件的位置并单击 保存 . " }, 
{ "title" : "更新 PLC 上的应用程序 ", 
"url" : "_cds_struct_update_application_on_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ 更新 PLC 上的应用程序 ", 
"snippet" : "CODESYS 基本上提供了两个选项将修改后的应用程序传输到控制器：下载和在线更改。 下载会导致重新编译应用程序。在此期间，将执行语法检查，并创建应用程序代码并将其下载到控制器。这会导致正在运行的程序停止。下载是推荐的数据传输方法，因为由于程序停止和重新初始化，始终会创建定义的起始状态。 在在线更改的情况下，仅将修改后的部分重新下载到控制器。正在运行的程序不会为此停止。只有在对应用程序进行微小更改的情况下，您才应该执行在线更改。对于大范围的更改，无法安全地预测程序的行为。有关更多信息，请阅读说明中的注释 在线更改 命令。 登录控制器或脱机编辑对象时， CODESYS 根据控制器上的现有项目检查...", 
"body" : "CODESYS 基本上提供了两个选项将修改后的应用程序传输到控制器：下载和在线更改。 下载会导致重新编译应用程序。在此期间，将执行语法检查，并创建应用程序代码并将其下载到控制器。这会导致正在运行的程序停止。下载是推荐的数据传输方法，因为由于程序停止和重新初始化，始终会创建定义的起始状态。 在在线更改的情况下，仅将修改后的部分重新下载到控制器。正在运行的程序不会为此停止。只有在对应用程序进行微小更改的情况下，您才应该执行在线更改。对于大范围的更改，无法安全地预测程序的行为。有关更多信息，请阅读说明中的注释 在线更改 命令。 登录控制器或脱机编辑对象时， CODESYS 根据控制器上的现有项目检查更改，并在状态栏中显示结果： 程序已修改（完整下载） ：项目更改只能通过下载进行传输。 程序已修改（在线更改） ：项目变更也可以通过在线变更进行转移。 " }, 
{ "title" : "执行在线更改 ", 
"url" : "_cds_performing_an_online_change.html", 
"breadcrumbs" : "CODESYS Essentials \/ 更新 PLC 上的应用程序 \/ 执行在线更改 ", 
"snippet" : "CODESYS 如果您使用控制器上已经存在但自上次下载到编程系统中后已更改的应用程序登录，则会自动为您提供在线更改。对于此操作，仅将修改后的部分重新下载到控制器。在线更改期间，控制器上正在运行的程序不会停止。 在里面 在线更改内存储备 视图，您可以为项目功能块的在线更改配置内存保留。这样，在对功能块进行更改以进行在线更改后，不必将实例变量移动到内存中。 进行在线更改时，请注意说明中的注意事项 在线更改 命令。 在登录状态下执行在线更改（在线模式） 要求：正确设置控制器的连接设置。项目中的应用程序和控制器上的应用程序是相同的。控制器上的项目正在运行。应用程序已登录。 在设备树中选择一个对象。最好...", 
"body" : "CODESYS 如果您使用控制器上已经存在但自上次下载到编程系统中后已更改的应用程序登录，则会自动为您提供在线更改。对于此操作，仅将修改后的部分重新下载到控制器。在线更改期间，控制器上正在运行的程序不会停止。 在里面 在线更改内存储备 视图，您可以为项目功能块的在线更改配置内存保留。这样，在对功能块进行更改以进行在线更改后，不必将实例变量移动到内存中。 进行在线更改时，请注意说明中的注意事项 在线更改 命令。 在登录状态下执行在线更改（在线模式） 要求：正确设置控制器的连接设置。项目中的应用程序和控制器上的应用程序是相同的。控制器上的项目正在运行。应用程序已登录。 在设备树中选择一个对象。最好在此处选择 POU 或 GVL。 点击 项目 → 编辑对象（离线） . 对象在编辑器中打开。 改变对象。例如，您可以在此处声明一个新变量或更改赋值。 点击 在线 → 在线更改 . 将出现一个查询，询问您是否真的要执行在线更改。 点击 是的 确认对话框。 更改被加载到控制器。 " }, 
{ "title" : "登录时执行在线更改 ", 
"url" : "_cds_performing_an_online_change.html#UUID-217fb929-5892-40cb-4dbf-ec7a5f6cf6bd_id_bfc346a7689da61c0a8640e01ee8549_id_89839d86b2bb11e4a177fe5cc7c27ae9", 
"breadcrumbs" : "CODESYS Essentials \/ 更新 PLC 上的应用程序 \/ 执行在线更改 \/ 登录时执行在线更改 ", 
"snippet" : "要求：正确设置控制器的连接设置。项目中的应用程序和控制器上的应用程序是相同的。控制器上的项目正在运行。应用程序已注销。 更改您的应用程序。 点击 在线 → 登录 . 将出现一个对话框，其中包含自上次下载以来应用程序已更改的信息。 点击 细节 按钮。 检查上的详细信息 应用信息 标签。 如果自上次更改后您还没有生成任何代码，则该命令 应用程序不是最新的。现在生成代码？ 出现在对话框的底部边缘。在这种情况下，单击此命令。 你会看到一个 比较视图 对象（标记为红色的对象不同）。 关闭对话框。 选择选项 使用在线更改登录 并点击 行 . 更改被加载到控制器。执行此操作时，控制器上正在运行的程序不会停止...", 
"body" : "要求：正确设置控制器的连接设置。项目中的应用程序和控制器上的应用程序是相同的。控制器上的项目正在运行。应用程序已注销。 更改您的应用程序。 点击 在线 → 登录 . 将出现一个对话框，其中包含自上次下载以来应用程序已更改的信息。 点击 细节 按钮。 检查上的详细信息 应用信息 标签。 如果自上次更改后您还没有生成任何代码，则该命令 应用程序不是最新的。现在生成代码？ 出现在对话框的底部边缘。在这种情况下，单击此命令。 你会看到一个 比较视图 对象（标记为红色的对象不同）。 关闭对话框。 选择选项 使用在线更改登录 并点击 行 . 更改被加载到控制器。执行此操作时，控制器上正在运行的程序不会停止。应用程序已登录。 " }, 
{ "title" : "执行下载 ", 
"url" : "_cds_performing_a_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ 更新 PLC 上的应用程序 \/ 执行下载 ", 
"snippet" : "应用程序的下载导致活动应用程序的编译。在此期间，将执行语法检查，并创建应用程序代码并将其下载到控制器。在下载过程中，控制器上运行的程序停止。 进行下载时，请注意下载说明中的注意事项 下载 命令。 在登录状态下下载（在线模式） 要求：正确设置控制器的连接设置。项目中的应用程序和控制器上的应用程序是相同的。控制器上的项目正在运行。应用程序已登录。 在设备树中选择一个对象。最好在此处选择 POU 或 GVL。 点击 项目 → 编辑对象（离线） . 对象在编辑器中打开。 改变对象。例如，您可以在此处声明一个新变量或更改赋值。 点击 在线 → 下载 . 将出现一个查询，询问您是否真的要执行下载。 点击 ...", 
"body" : "应用程序的下载导致活动应用程序的编译。在此期间，将执行语法检查，并创建应用程序代码并将其下载到控制器。在下载过程中，控制器上运行的程序停止。 进行下载时，请注意下载说明中的注意事项 下载 命令。 在登录状态下下载（在线模式） 要求：正确设置控制器的连接设置。项目中的应用程序和控制器上的应用程序是相同的。控制器上的项目正在运行。应用程序已登录。 在设备树中选择一个对象。最好在此处选择 POU 或 GVL。 点击 项目 → 编辑对象（离线） . 对象在编辑器中打开。 改变对象。例如，您可以在此处声明一个新变量或更改赋值。 点击 在线 → 下载 . 将出现一个查询，询问您是否真的要执行下载。 点击 是的 确认对话框。 停止控制器上正在运行的程序，并将更改加载到控制器。 " }, 
{ "title" : "登录时下载 ", 
"url" : "_cds_performing_a_download.html#UUID-60110cce-40f4-7c41-696d-4ce2dcaf51dd_id_c7d078ef768b6539c0a8640e006bdc72_id_89839d86b2bb11e4a177fe5cc7c27ae9", 
"breadcrumbs" : "CODESYS Essentials \/ 更新 PLC 上的应用程序 \/ 执行下载 \/ 登录时下载 ", 
"snippet" : "要求：正确设置控制器的连接设置。项目中的应用程序和控制器上的应用程序是相同的。控制器上的项目正在运行。应用程序已注销。 更改您的应用程序。 点击 在线 → 登录 . 将出现一个对话框，其中包含自上次下载以来应用程序已更改的信息。 选择 登录下载 选项并单击 行 . 停止控制器上正在运行的程序，并将更改加载到控制器。应用程序已登录。...", 
"body" : "要求：正确设置控制器的连接设置。项目中的应用程序和控制器上的应用程序是相同的。控制器上的项目正在运行。应用程序已注销。 更改您的应用程序。 点击 在线 → 登录 . 将出现一个对话框，其中包含自上次下载以来应用程序已更改的信息。 选择 登录下载 选项并单击 行 . 停止控制器上正在运行的程序，并将更改加载到控制器。应用程序已登录。 " }, 
{ "title" : "将文件复制到 PLC 或从 PLC 复制文件 ", 
"url" : "_cds_copy_files_from_to_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ 将文件复制到 PLC 或从 PLC 复制文件 ", 
"snippet" : "在通用 文件 在设备编辑器的选项卡中，您可以在本地文件系统和 PLC 之间复制文件。 要求：制造商已解锁标签。在设备树中，组态与 PLC 的连接。设备正在运行。 双击设备树中的 PLC 设备对象以打开设备编辑器。 点击 标签：文件 标签。 在 主持人 | 地点 在视图的左侧，设置本地文件系统中文件将被复制到和从中复制的路径。 例子： D:\\FileTransferWithPLC 如有必要，单击 符号在此处创建一个新目录。 文件和目录显示在文件管理器中。点击 按钮刷新显示。 在 运行 在视图的右侧，以相同的方式设置数据传输所需的目录。 CODESYS 显示控制器上的文件。 从文件系统树中选择文件...", 
"body" : "在通用 文件 在设备编辑器的选项卡中，您可以在本地文件系统和 PLC 之间复制文件。 要求：制造商已解锁标签。在设备树中，组态与 PLC 的连接。设备正在运行。 双击设备树中的 PLC 设备对象以打开设备编辑器。 点击 标签：文件 标签。 在 主持人 | 地点 在视图的左侧，设置本地文件系统中文件将被复制到和从中复制的路径。 例子： D:\\FileTransferWithPLC 如有必要，单击 符号在此处创建一个新目录。 文件和目录显示在文件管理器中。点击 按钮刷新显示。 在 运行 在视图的右侧，以相同的方式设置数据传输所需的目录。 CODESYS 显示控制器上的文件。 从文件系统树中选择文件传输所需的文件。多选是可能的。您还可以选择一个目录来传输文件夹中的所有文件。 点击 和 视图的两个部分之间的按钮。 CODESYS 立即将选定的文件复制到另一个文件系统。如果文件在目标目录中不可用，则创建该文件。如果它已经可用并且没有写保护，那么它将被覆盖。然后显示相应的消息。 " }, 
{ "title" : "使用命令行界面 ", 
"url" : "_cds_commandline.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 ", 
"snippet" : "你可以开始了 CODESYS .exe 从命令行使用以下选项和参数。 句法： <installation folder>CODESYS.exe --<Option> 如果您已经使用过 CODESYS Installer 安装多个 CODESYS 您计算机上的实例，那么您需要使用 --additionalfolder 选项来指定要启动的实例。 当路径或选项参数包含空格、破折号或斜杠时，它们必须写在直引号内。...", 
"body" : "你可以开始了 CODESYS .exe 从命令行使用以下选项和参数。 句法： <installation folder>CODESYS.exe --<Option> 如果您已经使用过 CODESYS Installer 安装多个 CODESYS 您计算机上的实例，那么您需要使用 --additionalfolder 选项来指定要启动的实例。 当路径或选项参数包含空格、破折号或斜杠时，它们必须写在直引号内。 " }, 
{ "title" : "选项：--附加文件夹 ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-11c2da71-d4f5-749d-04bf-eeab75652c7e", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--附加文件夹 ", 
"snippet" : "仅适用于使用 CODESYS Installer ： 如果您安装了多个实例 CODESYS 版本并希望从命令行启动其中一个实例，则适用以下内容：除了配置文件外，还需要指定该实例的绝对路径 AddionalFolder\/<instance name> 与 --additionalfolder 选项。 背景： CODESYS Installer 创建一个 AdditionalFolders 安装目录下的子文件夹 CODESYS 文件夹。在此文件夹中，每个文件夹都有一个单独的子文件夹 CODESYS 包含配置文件、插件和 PackageDB 的各个文件的实例。对于第一个安装的实例，子文件夹名为 De...", 
"body" : "仅适用于使用 CODESYS Installer ： 如果您安装了多个实例 CODESYS 版本并希望从命令行启动其中一个实例，则适用以下内容：除了配置文件外，还需要指定该实例的绝对路径 AddionalFolder\/<instance name> 与 --additionalfolder 选项。 背景： CODESYS Installer 创建一个 AdditionalFolders 安装目录下的子文件夹 CODESYS 文件夹。在此文件夹中，每个文件夹都有一个单独的子文件夹 CODESYS 包含配置文件、插件和 PackageDB 的各个文件的实例。对于第一个安装的实例，子文件夹名为 Default 。其他实例将获得安装期间指定的安装名称。 可以看到要指定的绝对路径 --additionalfolder 在 CODESYS Installer 当您单击 改变 相关实例磁贴中的按钮。它被注册为 地点 。 句法： --additionalfolder=<AdditionalFolders\\<instance installation name>> 例子 两个实例 CODESYS 3.5.18.20 已安装在您的计算机上 CODESYS Installer ：一台供服务技术人员使用，一台供开发人员使用。你想运行 Service 实例通过 StartServiceScript.py 来自命令行的脚本。为此，请在命令行上的 --profile 选项后指定 --additionalfolder 选项，如下所示： \"C:\\Program Files (x86)\\CODESYS3.5.18.20\\CODESYS\\Common\\CODESYS.exe\" --profile=\"CODESYS V3.5 SP18 --additionalfolder=\"C:\\Program Files\\CODESYS 3.5.18.20\\CODESYS\\AdditionalFolders\\Service\" --runscript=\"D:\\Dokumente\\Scripting\\StartServiceScript.py\"--scriptargs:'username password 3.14 \"path=\\\"C:\\temp\\\\\\\"\"'–noUI " }, 
{ "title" : "选项：--culture（用户界面的语言） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_6bc8917312a6e013c0a8640e003e6f2f", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--culture（用户界面的语言） ", 
"snippet" : "CODESYS 以指定的语言启动。 句法： --culture=<Culture> <culture> ：典型的语言代码如下：de、en、fr、it、es、zh-CHS。 例子 开始 CODESYS 带有英文的用户界面： CODESYS.exe --culture=en...", 
"body" : "CODESYS 以指定的语言启动。 句法： --culture=<Culture> <culture> ：典型的语言代码如下：de、en、fr、it、es、zh-CHS。 例子 开始 CODESYS 带有英文的用户界面： CODESYS.exe --culture=en " }, 
{ "title" : "选项：--profile ( CODESYS 轮廓） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_30cad0c546e2dc0cc0a8640e00a03b89", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--profile ( CODESYS 轮廓） ", 
"snippet" : "CODESYS 直接使用指定的配置文件启动。你几时开始 CODESYS 如果没有此选项，则 选择个人资料 打开。 句法： --profile=\"<profile name>\" <profile name> ：您必须准确指定配置文件名称，因为它显示在 帮助 → 关于 开发系统的启动画面或计算机的开始菜单中。 例子 CODESYS.exe --culture=de --profile=\"CODESYS V3.6\"...", 
"body" : "CODESYS 直接使用指定的配置文件启动。你几时开始 CODESYS 如果没有此选项，则 选择个人资料 打开。 句法： --profile=\"<profile name>\" <profile name> ：您必须准确指定配置文件名称，因为它显示在 帮助 → 关于 开发系统的启动画面或计算机的开始菜单中。 例子 CODESYS.exe --culture=de --profile=\"CODESYS V3.6\" " }, 
{ "title" : "选项：--compare（开始项目比较） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_2d8f4b0c12a6e014c0a8640e00f5a2e5", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--compare（开始项目比较） ", 
"snippet" : "后 CODESYS 开始，两个比较 CODESYS 项目立即开始。在选项之后，首先指定“当前项目”，然后指定“参考项目”作为参数。 CODESYS 启动并打开 项目比较 - 差异 看法。 句法： --compare=\"<path of project file>\" \"<path of reference project file>\" 例子 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\"...", 
"body" : "后 CODESYS 开始，两个比较 CODESYS 项目立即开始。在选项之后，首先指定“当前项目”，然后指定“参考项目”作为参数。 CODESYS 启动并打开 项目比较 - 差异 看法。 句法： --compare=\"<path of project file>\" \"<path of reference project file>\" 例子 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" " }, 
{ "title" : "选项：--project（打开 CODESYS 项目） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_440832e712a6e015c0a8640e0099773d", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--project（打开 CODESYS 项目） ", 
"snippet" : "CODESYS 启动并打开指定的项目。 句法： --project=\"<path of project file>\" <path of project file> : 项目的文件路径 例子 打开 test 项目： CODESYS.exe --culture=de --project=\"D:\\projects\\test.project\"...", 
"body" : "CODESYS 启动并打开指定的项目。 句法： --project=\"<path of project file>\" <path of project file> : 项目的文件路径 例子 打开 test 项目： CODESYS.exe --culture=de --project=\"D:\\projects\\test.project\" " }, 
{ "title" : "选项：--projectarchive（打开 CODESYS 项目档案） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_33a5dfa012a6e016c0a8640e016367f3", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--projectarchive（打开 CODESYS 项目档案） ", 
"snippet" : "CODESYS 启动，解压指定项目存档，打开项目。 句法： --projectarchive=\"<path of projectarchive file>\" <path of project archive file> : 项目存档的文件路径 例子 提取 test.projectarchive 并在开发系统中打开项目： CODESYS.exe --projectarchive=\"D:\\projects\\test.projectarchive\"...", 
"body" : "CODESYS 启动，解压指定项目存档，打开项目。 句法： --projectarchive=\"<path of projectarchive file>\" <path of project archive file> : 项目存档的文件路径 例子 提取 test.projectarchive 并在开发系统中打开项目： CODESYS.exe --projectarchive=\"D:\\projects\\test.projectarchive\" " }, 
{ "title" : "选项：--runscript（运行脚本） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_878d053246e2dc13c0a8640e0077c63b", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--runscript（运行脚本） ", 
"snippet" : "指定的脚本文件由 CODESYS . --runscript 的命令行选项 --runscript=\"<script file>.py\" CODESYS 运行 <script file>.py 启动时的脚本文件。 您必须提供脚本文件的完整路径。 --scriptargs:'<arg1> <arg2> ... <argn>' 将此选项与 --runscript 选项。它们触发将 <arg1> ... <argn> 参数传递给脚本。参数被传递给 Python 变量 sys.argv . --noUI 将此选项与 --runscript 选项。 这 CODESYS 用户界面未打开。 CODESYS ...", 
"body" : "指定的脚本文件由 CODESYS . --runscript 的命令行选项 --runscript=\"<script file>.py\" CODESYS 运行 <script file>.py 启动时的脚本文件。 您必须提供脚本文件的完整路径。 --scriptargs:'<arg1> <arg2> ... <argn>' 将此选项与 --runscript 选项。它们触发将 <arg1> ... <argn> 参数传递给脚本。参数被传递给 Python 变量 sys.argv . --noUI 将此选项与 --runscript 选项。 这 CODESYS 用户界面未打开。 CODESYS 输出脚本生成的所有错误、警告、编译器报告和命令行消息。脚本消息（1：Severity Text）可以与其他消息（2：Severity FatalError、Error、Warning、Information）与 > 操作员。 --enablescripttracing 将此选项与 --runscript 选项。结果，脚本文件的每个命令都显示在输出中。 --textPrompts 将此选项与 --noUI 选项。结果，在命令行中输出消息服务方法和默认对话框以供用户输入。 如果您不指定 --textPrompts ，然后使用默认值自动确认所有消息服务提示。 在带有“sys.argv”的脚本文件中使用传输参数的示例 start \/b \/wait CODESYS.exe\n--runscript=\"D:\\Script\\ArgvAnd__main__Test.py\"\n--scriptargs:'username password 3.14 \"path=\\\"C:\\temp\\\\\"' 脚本文件： ArgvAnd__main__Test.py from __future__ import print_function\nimport sys\nprint(\"sys.argv: \", len(sys.argv), \" elements:\")\n\nfor arg in sys.argv:\n print(\" - \", arg)\nprint()\nprint(\"__name__: \", __name__) 输出结果： stdout ： sys.argv: 6 elements:\n- D:\\TestScripts\\ArgvAnd__main__Test.py\n- username\n- password\n- 3.14\n- path= \"C:temp\"\n__name__: __main__ 有关更多信息 __name__ 全局变量，请参阅 Python 文档。 消息输出示例 start \/b \/wait CODESYS.exe --runscript=\"D:\\Script\\AmpelTest.py\" --noUI 1>ScriptMessages.txt CODESYS 将脚本生成的所有消息传递给 ScriptMessages.txt 文件。其他消息打印到命令行。 start \/b \/wait CODESYS.exe --runscript=\"D:\\Script\\AmpelTest.py\" --noUI 2>NUL CODESYS 禁止所有消息，脚本消息除外。脚本消息被打印到命令行。 使用 –scriptdebugger 选项的示例 下列 initdebug.py 脚本已成功测试 pydevd - 基于调试器，例如 PyDev \/ LiClipse 和 PyCharm。要使用此脚本，请启动 CODESYS 使用以下命令行： --profile=\"Fanta Development Build\" --scriptdebugger=\"D:\\test\\charmdebug\\initdebug.py\" 文件： initdebug.py ： from _future_ import print_function\nfrom _future_ import unicode_literals\nimport sys\nsys.path.append(r\"D:\\test\\Env2\\Lib\\site-packages\\pycharm-debug.egg\")\nimport pydevd\ndef scriptdebuggersetup():\npydevd.settrace('localhost', port=51234, stdoutToServer=True, stderrToServer=True)\ndef scriptdebuggershutdown():\npydevd.stoptrace() 有关详细信息，请参阅： 使用脚本 和 http:\/\/docs.python.org\/tutorial\/modules.html " }, 
{ "title" : "选项：--ignorewhitespace（在项目比较中忽略空格） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_6bfa2ec346e2dc14c0a8640e0164e212", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--ignorewhitespace（在项目比较中忽略空格） ", 
"snippet" : "如果在选项后面加上这个选项 --compare <project1> <project2> , 然后在项目比较中忽略空格。请注意，语义相关的空间，例如 STRING 文字，仍然被考虑在内。 句法 --compare=\"<path of project file>\" \"<path of reference project file>\" --ignorewhitespace=\"true\"|\"false\" 例子 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" --ignorewhitespace=...", 
"body" : "如果在选项后面加上这个选项 --compare <project1> <project2> , 然后在项目比较中忽略空格。请注意，语义相关的空间，例如 STRING 文字，仍然被考虑在内。 句法 --compare=\"<path of project file>\" \"<path of reference project file>\" --ignorewhitespace=\"true\"|\"false\" 例子 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" --ignorewhitespace=\"true\" " }, 
{ "title" : "选项：--ignorecomments（在项目比较中忽略注释） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_38d685e446e2dc15c0a8640e00aa5b6e", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--ignorecomments（在项目比较中忽略注释） ", 
"snippet" : "如果在选项后面加上这个选项 --compare <project1> <project2> , 然后在项目比较中忽略注释。 句法： --compare=\"<path of project file>\" \"<path of reference project file>\" --ignorecomments=\"true\"|\"false\" 例子 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" --ignorecomments=\"true\"...", 
"body" : "如果在选项后面加上这个选项 --compare <project1> <project2> , 然后在项目比较中忽略注释。 句法： --compare=\"<path of project file>\" \"<path of reference project file>\" --ignorecomments=\"true\"|\"false\" 例子 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" --ignorecomments=\"true\" " }, 
{ "title" : "选项：--ignoreproperties（在项目比较中忽略对象属性） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-ca064d81-741b-2021-8cb8-470e0cb751f2", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--ignoreproperties（在项目比较中忽略对象属性） ", 
"snippet" : "如果在选项后面加上这个选项 --compare <project1> <project2> , 然后在项目比较中忽略对象属性（权限、编译设置、目录、位图等）。 句法： --compare=\"<path of project file>\" \"<path of reference project file>\" --ignoreproperties=\"true\"|\"false\" 例子 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" --ignoreproperties=\"true\"...", 
"body" : "如果在选项后面加上这个选项 --compare <project1> <project2> , 然后在项目比较中忽略对象属性（权限、编译设置、目录、位图等）。 句法： --compare=\"<path of project file>\" \"<path of reference project file>\" --ignoreproperties=\"true\"|\"false\" 例子 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" --ignoreproperties=\"true\" " }, 
{ "title" : "选项：--skipunlicensedplugins（不要加载没有许可证的组件） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_dcd35d41076c4576c0a86463067eecc3", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--skipunlicensedplugins（不要加载没有许可证的组件） ", 
"snippet" : "CODESYS 已启动。在这种情况下，将跳过关于是否仍应加载未经许可的组件的查询。如果是这样，那么 CODESYS 做 不是 静默加载这些组件。 例子 CODESYS.exe –skipunlicensedplugins...", 
"body" : "CODESYS 已启动。在这种情况下，将跳过关于是否仍应加载未经许可的组件的查询。如果是这样，那么 CODESYS 做 不是 静默加载这些组件。 例子 CODESYS.exe –skipunlicensedplugins " }, 
{ "title" : "选项：--signaturethumbprint（用于签署已编译库的证书的指纹） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-caedc225-0247-831c-1ac2-1bc63dca068c", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--signaturethumbprint（用于签署已编译库的证书的指纹） ", 
"snippet" : "如果在选项后面加上这个选项 --project=\"<path of project file>\" ，然后打开项目并传递用于签署编译库的证书的指纹。 句法： --signaturethumbprint=\"<thumbprint of digital signature>\" 例子 CODESYS.exe --project=\"D:\\projects\\test.project\" signaturethumbprint=\"3E96C9B61010CBDC3186021A1CAA64946DDCAAF3\"...", 
"body" : "如果在选项后面加上这个选项 --project=\"<path of project file>\" ，然后打开项目并传递用于签署编译库的证书的指纹。 句法： --signaturethumbprint=\"<thumbprint of digital signature>\" 例子 CODESYS.exe --project=\"D:\\projects\\test.project\" signaturethumbprint=\"3E96C9B61010CBDC3186021A1CAA64946DDCAAF3\" " }, 
{ "title" : "选项：--enforcesignedcompiledlibraries（强制编译库的签名） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-347f5ad2-49b1-cd80-5021-7561cc675234", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--enforcesignedcompiledlibraries（强制编译库的签名） ", 
"snippet" : "如果在选项后面加上这个选项 --project=\"<path of project file>\" ，那么 强制对已编译的库进行签名 选项在项目中启用 安全屏幕 在 用户 标签。 当。。。的时候 安全屏幕 再次打开和关闭时，当前设置将应用到用户选项中，即使没有进行任何活动更改。 句法： --enforcesignedcompiledlibraries 例子 CODESYS.exe --project=\"D:\\projects\\test.library\" --enforcesignedcompiledlibraries...", 
"body" : "如果在选项后面加上这个选项 --project=\"<path of project file>\" ，那么 强制对已编译的库进行签名 选项在项目中启用 安全屏幕 在 用户 标签。 当。。。的时候 安全屏幕 再次打开和关闭时，当前设置将应用到用户选项中，即使没有进行任何活动更改。 句法： --enforcesignedcompiledlibraries 例子 CODESYS.exe --project=\"D:\\projects\\test.library\" --enforcesignedcompiledlibraries " }, 
{ "title" : "选项：--timestampingserverurl（设置时间戳服务器地址） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-2fb9f8ee-c520-7f05-fecd-b242c30821ee", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--timestampingserverurl（设置时间戳服务器地址） ", 
"snippet" : "如果在选项后面加上这个选项 --project=\"<path of project file>\" , 然后是 RFC-3161 时间戳服务器的 Internet 地址 ( 时间戳服务器 ) 在项目中设置 安全屏幕 在 用户 标签。 当。。。的时候 安全屏幕 再次打开和关闭时，当前设置将应用到用户选项中，即使没有进行任何活动更改。 句法： --timestampingserverurl=\"<URL of RFC-3161 timestamping server>\" 例子 CODESYS.exe --timestampingserverurl=\"http:\/\/timestamp.comodoca....", 
"body" : "如果在选项后面加上这个选项 --project=\"<path of project file>\" , 然后是 RFC-3161 时间戳服务器的 Internet 地址 ( 时间戳服务器 ) 在项目中设置 安全屏幕 在 用户 标签。 当。。。的时候 安全屏幕 再次打开和关闭时，当前设置将应用到用户选项中，即使没有进行任何活动更改。 句法： --timestampingserverurl=\"<URL of RFC-3161 timestamping server>\" 例子 CODESYS.exe --timestampingserverurl=\"http:\/\/timestamp.comodoca.com\/rfc3161\" " }, 
{ "title" : "选项：--enableEventLog ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-6910bbcd-f37f-036c-b800-832c97c5578e", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--enableEventLog ", 
"snippet" : "CODESYS 已启动，所有命令执行都记录在 Windows 事件日志中。记录位于 Windows 事件查看器 在下面 应用程序和服务日志 → AP . 第一次使用此选项时， CODESYS 必须以管理员权限启动。 句法： --enableEventLog=\"CommandManager\"...", 
"body" : "CODESYS 已启动，所有命令执行都记录在 Windows 事件日志中。记录位于 Windows 事件查看器 在下面 应用程序和服务日志 → AP . 第一次使用此选项时， CODESYS 必须以管理员权限启动。 句法： --enableEventLog=\"CommandManager\" " }, 
{ "title" : "选项：--ForceDisconnectAfterInactivity ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-6f3de5bf-ac76-9e2f-50b4-e5265686a252", 
"breadcrumbs" : "CODESYS Essentials \/ 使用命令行界面 \/ 选项：--ForceDisconnectAfterInactivity ", 
"snippet" : "为了这 CODESYS session 中，不活动的时间将被设置为指定的时间（以秒为单位），超过该时间后将自动终止与控制器的连接。该选项中指定的值将覆盖在 CODESYS 中的选项 在线的 此类别 CODESYS 会议。 如果该值设置为 0，则在特定时间段不活动后，与控制器的连接不会自动终止。为了这 CODESYS 会话中，这会禁用断开连接选项 CODESYS 选项。 句法： --ForceDisconnectAfterInactivity=\"<value in seconds>\" <value in seconds> : [10, 10800] | 0 例子 300 秒不活动后，与控制器的连...", 
"body" : "为了这 CODESYS session 中，不活动的时间将被设置为指定的时间（以秒为单位），超过该时间后将自动终止与控制器的连接。该选项中指定的值将覆盖在 CODESYS 中的选项 在线的 此类别 CODESYS 会议。 如果该值设置为 0，则在特定时间段不活动后，与控制器的连接不会自动终止。为了这 CODESYS 会话中，这会禁用断开连接选项 CODESYS 选项。 句法： --ForceDisconnectAfterInactivity=\"<value in seconds>\" \n <value in seconds> : [10, 10800] | 0 例子 300 秒不活动后，与控制器的连接将自动终止。 --ForceDisconnectAfterInactivity=\"300\" " }, 
{ "title" : "使用库 ", 
"url" : "_cds_struct_installing_libraries.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用库 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "图书馆资料库 ", 
"url" : "_cds_struct_installing_libraries.html#UUID-9b7dfd17-ac20-bbba-303e-1ac0ef3a80c0_section-idm4531453287164832668319668401", 
"breadcrumbs" : "CODESYS Essentials \/ 使用库 \/ 图书馆资料库 ", 
"snippet" : "这 图书馆存储库 是库和相关元数据在开发系统上的位置。您可以通过库管理器将任何已安装的库链接到您的项目中。此外，这些库安装了版本管理，以便于库更新。 除了预安装的存储库之外，您还可以创建和编辑更多存储库 System 存储库。...", 
"body" : "这 图书馆存储库 是库和相关元数据在开发系统上的位置。您可以通过库管理器将任何已安装的库链接到您的项目中。此外，这些库安装了版本管理，以便于库更新。 除了预安装的存储库之外，您还可以创建和编辑更多存储库 System 存储库。 " }, 
{ "title" : "图书馆经理 ", 
"url" : "_cds_struct_installing_libraries.html#UUID-9b7dfd17-ac20-bbba-303e-1ac0ef3a80c0_section-idm4531453400737632668320099362", 
"breadcrumbs" : "CODESYS Essentials \/ 使用库 \/ 图书馆经理 ", 
"snippet" : "为了能够在应用程序中使用库 POU 中提供的 POU，该库必须集成在 图书馆经理 在项目中。对此的要求是在库存储库中安装库。 库管理器根据库类型和各自的属性显示所有集成库。在库管理器中，您可以从库存储库中添加更多库、删除库和编辑库属性。 库管理器可以插入到 POU 查看或 设备 看法。因此，一个项目可以为每个应用程序都有一个库管理器，以及在项目中的一个库管理器。 POU 查看以在所有应用程序中使用。中集成库的库 POU POU 无论应用程序如何，都可以调用视图。中集成库的库 POU 设备 view 只能在相应的应用程序代码中调用。此外，占位符库在下载时会根据其位置而有所不同。 集成到项目中特定...", 
"body" : "为了能够在应用程序中使用库 POU 中提供的 POU，该库必须集成在 图书馆经理 在项目中。对此的要求是在库存储库中安装库。 库管理器根据库类型和各自的属性显示所有集成库。在库管理器中，您可以从库存储库中添加更多库、删除库和编辑库属性。 库管理器可以插入到 POU 查看或 设备 看法。因此，一个项目可以为每个应用程序都有一个库管理器，以及在项目中的一个库管理器。 POU 查看以在所有应用程序中使用。中集成库的库 POU POU 无论应用程序如何，都可以调用视图。中集成库的库 POU 设备 view 只能在相应的应用程序代码中调用。此外，占位符库在下载时会根据其位置而有所不同。 集成到项目中特定版本的库也有该版本的占位符（占位符库）。您可以定义特殊的占位符分辨率。您还可以使用在设备描述中为设备定义的或存储在库的库存储库中的占位符解析。库管理器会通知您实际的占位符分辨率，并显示下载应用程序时将加载的版本（有效版本）。 当图书馆管理员在 POU 视图集成在所有应用程序中，您可以全局访问其内容。如果集成了占位符库，则仅检查设备描述或库存储库中的占位符解析。 库管理器通常集成在 设备 看法。然后只有它下面的应用程序代码从它调用库 POU。此外，首先检查占位符库的特殊占位符解析。只有在此之后，才会检查设备描述中或源自库存储库的占位符分辨率。 " }, 
{ "title" : "图书馆开发人员信息 ", 
"url" : "_cds_library_development_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用库 \/ 图书馆开发人员信息 ", 
"snippet" : "为了避免一致性问题并为用户提供充分的支持，请务必遵守有关库的创建、引用、加密、保护和文档记录的某些规则。 以下描述仅提供库开发可能性的概述。有关这些主题的更详细描述，请参阅库开发的“LibDevSummary”指南。 有关更多信息，请参阅： 使用库一般的 您可以定义库的类别。然后，这些库将显示在这些类别下方的库存储库中。 有关创建库类别的更多信息，请参阅： 图书馆类别 您可以为库定义命名空间，以便能够明确访问集成对象。通过在 POU 名称前面添加命名空间，访问变得明确： <命名空间>.<变量名> 例子： AC.Module 您可以打开未加密库的 POU ( *.library ) 通过双击库管...", 
"body" : "为了避免一致性问题并为用户提供充分的支持，请务必遵守有关库的创建、引用、加密、保护和文档记录的某些规则。 以下描述仅提供库开发可能性的概述。有关这些主题的更详细描述，请参阅库开发的“LibDevSummary”指南。 有关更多信息，请参阅： 使用库一般的 您可以定义库的类别。然后，这些库将显示在这些类别下方的库存储库中。 有关创建库类别的更多信息，请参阅： 图书馆类别 您可以为库定义命名空间，以便能够明确访问集成对象。通过在 POU 名称前面添加命名空间，访问变得明确： <命名空间>.<变量名> 例子： AC.Module 您可以打开未加密库的 POU ( *.library ) 通过双击库管理器中的相应条目。 您可以创建以下库类型： *.library : 实现库（库的源代码） * .compiled-library , *.compiled-library-v3 : 受保护的图书馆 源代码不再可访问。 *_Itfs.library : 接口库 仅包含用于组件的接口定义的对象（例如，常量、结构或接口）并且不生成任何代码 *_Cnt.library : 容器库 不包含 POU，只包含其他库 因此，用于方便地集成一整套 POU 发布在容器库顶层的库 您可以将外部库集成到应用程序中。外部库在外部编程 CODESYS 使用不同的编程语言（例如：C）。 图书馆保护 源代码保护 当以“compiled-library”格式准备库时，库 POU 的源代码在库集成到项目后不再可见。 签约 在 CODESYS V3 SP15 及更高版本，证书始终用于库项目的签名（ *.compiled-library-v3 ）。可以通过安全屏幕中的设置来强制执行签名。然后，为了生成编译库，您需要一个适合在您的用户配置文件中进行代码签名的证书。 对于必须兼容的库项目 CODESYS < V3 SP15 ( *.compiled-library )，使用私钥和相应的令牌只能进行不太安全的签名。这些不推荐使用的方法仅应出于兼容性原因使用。设置在 项目信息 在 签约 标签。 注意：对于签名库，您应该使用编译器版本 3.5.15.0 或更高版本，因为使用了更好的存储格式。 许可 您可以通过许可证（加密狗或软容器）来保护库。受许可证保护的库可以安装在库存储库中。但是，要在项目中使用，计算机上必须存在有效的许可证。许可证在许可证管理器中进行管理。 库版本 您可以在系统上同时安装多个版本的库。 您可以同时将多个版本的库集成到您的项目中。但是，我们不建议这样做。在这种情况下，每个库 必须 被分配一个唯一的命名空间并访问符号 必须 有资格。 例子： V1.SendBlob , V2.SendBlob 引用的库 您可以将一个库集成到其他库（引用库）中。嵌套可以是任何深度。 您可以定义引用的库是否应在库管理器中可见。 您可以通过库占位符集成引用的库。这样，您就可以避免由于版本依赖性或使用供应商特定库的必要性而可能发生的问题。 " }, 
{ "title" : "将库添加到应用程序 ", 
"url" : "_cds_adding_libraries_to_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用库 \/ 将库添加到应用程序 ", 
"snippet" : "以下说明描述了如何集成例如库 Util 到您的应用程序中以使用其库 POU。 选择库管理器并单击 项目 → 编辑对象 在编辑器中打开它。 库管理器在编辑器中打开。 点击 图书馆 → 添加库 . 这 添加库 对话框打开。 在上面的输入字段中指定“util”作为字符串以搜索库。 图书馆 Util 显示在库视图中。 选择图书馆 Util 并点击 行 关闭对话框。 图书馆 Util 已添加到库管理器。 有关更多信息，请参阅： 使用库模块...", 
"body" : "以下说明描述了如何集成例如库 Util 到您的应用程序中以使用其库 POU。 选择库管理器并单击 项目 → 编辑对象 在编辑器中打开它。 库管理器在编辑器中打开。 点击 图书馆 → 添加库 . 这 添加库 对话框打开。 在上面的输入字段中指定“util”作为字符串以搜索库。 图书馆 Util 显示在库视图中。 选择图书馆 Util 并点击 行 关闭对话框。 图书馆 Util 已添加到库管理器。 有关更多信息，请参阅： 使用库模块" }, 
{ "title" : "将库添加到存储库 ", 
"url" : "_cds_adding_libraries_to_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用库 \/ 将库添加到存储库 ", 
"snippet" : "以下说明描述了如何在库存储库中安装库。 点击 工具 → 图书馆资料库 . 这 图书馆资料库 对话框打开。 点击 安装 按钮。 选择要安装的库。您可以在此处设置文件过滤器。 点击 打开 . 该库被添加到存储库中。现在可以在库管理器中添加库。...", 
"body" : "以下说明描述了如何在库存储库中安装库。 点击 工具 → 图书馆资料库 . 这 图书馆资料库 对话框打开。 点击 安装 按钮。 选择要安装的库。您可以在此处设置文件过滤器。 点击 打开 . 该库被添加到存储库中。现在可以在库管理器中添加库。 " }, 
{ "title" : "导出库文件 ", 
"url" : "_cds_exporting_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用库 \/ 导出库文件 ", 
"snippet" : "您可以从项目的库管理器或库存储库中导出库，然后将其作为文件保存到硬盘。 从库管理器导出 在一个项目中，打开一个 图书馆经理 的应用程序。 在库管理器中选择一个库。 在上下文菜单中，单击“导出”。 这 导出库 对话框打开。 如果所选库在项目中不仅作为编译库链接，而且以“源”格式链接，则两种文件类型都在列表框中 文件类型 .否则，过滤器会自动显示可用类型： *.library 或者 *.compiled-library . 选择文件类型和位置，然后单击 保存 . 从库存储库导出 在里面 工具 菜单，打开 CODESYS 图书馆资料库 . 在已安装库的窗口中选择库版本。 点击 出口 按钮。 这 导出...", 
"body" : "您可以从项目的库管理器或库存储库中导出库，然后将其作为文件保存到硬盘。 从库管理器导出 在一个项目中，打开一个 图书馆经理 的应用程序。 在库管理器中选择一个库。 在上下文菜单中，单击“导出”。 这 导出库 对话框打开。 如果所选库在项目中不仅作为编译库链接，而且以“源”格式链接，则两种文件类型都在列表框中 文件类型 .否则，过滤器会自动显示可用类型： *.library 或者 *.compiled-library . 选择文件类型和位置，然后单击 保存 . 从库存储库导出 在里面 工具 菜单，打开 CODESYS 图书馆资料库 . 在已安装库的窗口中选择库版本。 点击 出口 按钮。 这 导出库 对话框打开。 如“从库管理器导出”的步骤 4 和 5 " }, 
{ "title" : "更新库占位符 ", 
"url" : "_cds_update_library_placeholders.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用库 \/ 更新库占位符 ", 
"snippet" : "如果项目使用占位符库，则可能会在以后加载占位符时不再自动解析占位符。结果，加载操作因错误而终止。您将在消息窗口中收到详细通知。它列出了涉及的库以及受影响的应用程序。此外，该消息提供了一个带有有用命令的快速修复按钮。 命令： 将占位符 <library name> 更新到最新版本 ： 将库的固定版本更新为最新版本 命令： 打开 Library Manager 的“Placeholders”对话框 ： 在此对话框中，您可以编辑占位符的分辨率。有关详细信息，请参阅： 占位符例子 具有未解决的库占位符的项目...", 
"body" : "如果项目使用占位符库，则可能会在以后加载占位符时不再自动解析占位符。结果，加载操作因错误而终止。您将在消息窗口中收到详细通知。它列出了涉及的库以及受影响的应用程序。此外，该消息提供了一个带有有用命令的快速修复按钮。 命令： 将占位符 <library name> 更新到最新版本 ： 将库的固定版本更新为最新版本 命令： 打开 Library Manager 的“Placeholders”对话框 ： 在此对话框中，您可以编辑占位符的分辨率。有关详细信息，请参阅： 占位符例子 具有未解决的库占位符的项目 " }, 
{ "title" : "管理设备 ", 
"url" : "_cds_struct_managing_devices.html", 
"breadcrumbs" : "CODESYS Essentials \/ 管理设备 ", 
"snippet" : "CODESYS 管理已安装的设备 设备存储库 .设备存储库是文件系统中定义的位置，默认情况下定义为系统存储库 CODESYS 使用绝对路径安装。您在 设备存储库 对话。系统通过读取设备描述文件来安装设备。设备的属性在这些文件中定义，涉及可配置性、可编程性以及与其他设备的可能连接。 您可以通过将设备存储库中提供的设备添加到项目的设备树中来使用它们。...", 
"body" : "CODESYS 管理已安装的设备 设备存储库 .设备存储库是文件系统中定义的位置，默认情况下定义为系统存储库 CODESYS 使用绝对路径安装。您在 设备存储库 对话。系统通过读取设备描述文件来安装设备。设备的属性在这些文件中定义，涉及可配置性、可编程性以及与其他设备的可能连接。 您可以通过将设备存储库中提供的设备添加到项目的设备树中来使用它们。 " }, 
{ "title" : "安装设备 ", 
"url" : "_cds_installing_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 管理设备 \/ 安装设备 ", 
"snippet" : "将设备安装在 设备存储库 为了将它包含在您的项目中。 点击 工具 → 设备存储库 . 这 设备存储库 对话框打开。 选择安装位置。 系统存储库 默认设置。 点击 安装 按钮。 这 安装设备说明 对话框打开。 选择设备描述的文件路径。 选择所需设备描述的文件类型过滤器。 列出所选文件类型的所有设备描述。 选择所需的设备描述并单击 打开 . CODESYS 将设备描述添加到设备存储库的匹配类别中。 如果在安装过程中发生错误（例如，缺少设备描述所引用的文件），则 CODESYS 将它们显示在设备存储库对话框的下部。...", 
"body" : "将设备安装在 设备存储库 为了将它包含在您的项目中。 点击 工具 → 设备存储库 . 这 设备存储库 对话框打开。 选择安装位置。 系统存储库 默认设置。 点击 安装 按钮。 这 安装设备说明 对话框打开。 选择设备描述的文件路径。 选择所需设备描述的文件类型过滤器。 列出所选文件类型的所有设备描述。 选择所需的设备描述并单击 打开 . CODESYS 将设备描述添加到设备存储库的匹配类别中。 如果在安装过程中发生错误（例如，缺少设备描述所引用的文件），则 CODESYS 将它们显示在设备存储库对话框的下部。 " }, 
{ "title" : "管理包和许可证 ", 
"url" : "_cds_struct_managing_packages_and_licenses.html", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "许可 CODESYS ", 
"url" : "_cds_struct_managing_packages_and_licenses.html#UUID-68845ac9-5153-8336-6398-73964f8ffc47_section-idm4593467822192032668684730962", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 许可 CODESYS ", 
"snippet" : "除了标准安装 CODESYS , 附加组件也可用，但需收取费用和许可。您从以下位置获得这些产品的许可证 CODESYS GmbH 以票号的形式，您可以使用 CODESYS 许可证管理器。 的 许可证管理器 将许可证信息存储在 USB 硬件加密狗（ CODESYS 加密狗）或存储在本地的软容器中 CodeMeter 控制中心 已经注册。加密狗必须插入您的本地 PC。 在里面 许可证存储库 ，您可以从中央许可证服务器获取每个票号的当前信息。还提供了其他信息，例如许可证是否仍然可以激活或必须退回。 有些插件需要许可证，但它们也可以在没有许可证的情况下使用，但功能有限。在这种情况下，有关缺少许可证的消...", 
"body" : "除了标准安装 CODESYS , 附加组件也可用，但需收取费用和许可。您从以下位置获得这些产品的许可证 CODESYS GmbH 以票号的形式，您可以使用 CODESYS 许可证管理器。 的 许可证管理器 将许可证信息存储在 USB 硬件加密狗（ CODESYS 加密狗）或存储在本地的软容器中 CodeMeter 控制中心 已经注册。加密狗必须插入您的本地 PC。 在里面 许可证存储库 ，您可以从中央许可证服务器获取每个票号的当前信息。还提供了其他信息，例如许可证是否仍然可以激活或必须退回。 有些插件需要许可证，但它们也可以在没有许可证的情况下使用，但功能有限。在这种情况下，有关缺少许可证的消息会出现在插件特定的位置。此类插件（附加组件）的示例： CODESYS Git , CODESYS SVN , CODESYS UML 来自专业开发者版。 网络许可证 : 在当地注册的执照 CodeMeter 控制中心 可以作为网络许可证提供。为此，将本地计算机配置为授权用户可以访问和使用许可证的网络服务器。如果您需要使用此配置，请先打开 CodeMeter 控制中心 然后点击 文件 – 网络管理员 打开 CodeMeter WebAdmin 浏览器。在浏览器中，您会在下面看到当前安装的加密狗或软容器 容器 .在 设置 – 根据 ，您可以将本地计算机设置为基础服务器。另请参阅 WIBU CodeMeter 的当前帮助：例如， 为网络服务器访问许可证设置 CodeMeter . 有关 CodeMeter 的详细信息，请参阅： 威步系统主页 . 启动时检查许可证 CODESYS 开始的时候， CODESYS 检查受许可的插件的选定配置文件。 如果配置文件不包括受许可的插件，则 CODESYS 像往常一样开始，没有消息。 如果配置文件包含需要许可的插件，则 CODESYS 当具有所需许可证的加密狗插入计算机的 USB 端口或注册具有许可证的软容器时，也会启动而没有任何消息。 如果配置文件包含需要许可证但没有加密狗\/软件容器或找不到所需许可证的插件，则在您启动时出现 CODESYS 对话 缺少许可证 .你可以决定是否 CODESYS 应该在没有受影响的插件的情况下启动。 注意：从命令行启动时，如果您指定 --skipunlicensedplugins 命令中的选项。在这种情况下，没有所需许可证的插件将不会自动加载。 运行时模式下的许可证检查 尽管 CODESYS 正在运行，每五分钟检查一次所需的许可证。如果缺少许可证，例如因为在此期间移除了加密狗，则 缺少许可证 对话框打开。对于无需许可证也可以使用的附加组件，功能范围会根据现有或缺少的许可证进行调整。 如果加密狗断开连接，您有以下选择： 再次插入加密狗并按下 重试 ：如果加密狗包含丢失的许可证，那么您可以继续照常工作。 保存当前项目并退出 ： CODESYS 保存项目并关闭。 关闭 ： CODESYS 关闭而不保存项目。 如果您在 CODESYS 插件已加载，然后显示错误消息。 要解决此问题，请再次插入加密狗并按下 Retry 按钮。如果加密狗包含有效的许可证，对话框将关闭，您可以继续照常工作。点击 取消 退出 CODESYS . " }, 
{ "title" : "许可证管理器 ", 
"url" : "_cds_struct_managing_packages_and_licenses.html#UUID-68845ac9-5153-8336-6398-73964f8ffc47_section-idm459346742314563266868591645", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 许可证管理器 ", 
"snippet" : "使用 许可证管理器 在 CODESYS ，您可以在 CODESYS 加密狗或软容器中。软容器是安全密钥（加密狗）的软件对应物。因此，即使不使用安全密钥，硬件许可证也可以链接到个人 PC。 在许可证管理器中，选择 工作站 为您的工作站授予许可并选择 设备 如果您想在您的设备上激活许可证。...", 
"body" : "使用 许可证管理器 在 CODESYS ，您可以在 CODESYS 加密狗或软容器中。软容器是安全密钥（加密狗）的软件对应物。因此，即使不使用安全密钥，硬件许可证也可以链接到个人 PC。 在许可证管理器中，选择 工作站 为您的工作站授予许可并选择 设备 如果您想在您的设备上激活许可证。 " }, 
{ "title" : "包管理器 ", 
"url" : "_cds_struct_managing_packages_and_licenses.html#UUID-68845ac9-5153-8336-6398-73964f8ffc47_section-idm4531453328910432668687302335", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 包管理器 ", 
"snippet" : "CODESYS 提供 包管理器 其功能扩展了标准安装 CODESYS 具有附加功能和配置设置。包管理器背后的概念类似于典型的 Windows 安装机制。 包是带有 *.package 文件扩展名的 ZIP 文件。 可能的封装组件 插件 图书馆 设备描述 供应商说明 简介 信息简介 配置文件更改 文件 用于配置菜单、工具栏、键盘快捷键和视图的扩展 帮助模块 特殊配置文件的完整菜单配置 特殊配置文件的完整工具栏配置 特殊配置文件的完整键盘配置 选项 图书馆简介 你可以比较 校验和 使用来自包供应商的包校验和。 CODESYS 在 细节 包管理器的对话框和 安装 - 许可协议 安装向导的对话框。你这...", 
"body" : "CODESYS 提供 包管理器 其功能扩展了标准安装 CODESYS 具有附加功能和配置设置。包管理器背后的概念类似于典型的 Windows 安装机制。 包是带有 *.package 文件扩展名的 ZIP 文件。 可能的封装组件 插件 图书馆 设备描述 供应商说明 简介 信息简介 配置文件更改 文件 用于配置菜单、工具栏、键盘快捷键和视图的扩展 帮助模块 特殊配置文件的完整菜单配置 特殊配置文件的完整工具栏配置 特殊配置文件的完整键盘配置 选项 图书馆简介 你可以比较 校验和 使用来自包供应商的包校验和。 CODESYS 在 细节 包管理器的对话框和 安装 - 许可协议 安装向导的对话框。你这样做是为了确保你已经安装了一个原始包。 在 V3.5 SP13 及更高版本中， CODESYS 在安装开发系统时检查是否已经安装了旧版本。如果是这种情况，那么当您第一次启动开发系统时，您将看到 导入助手 用于导入旧版本中可用的软件包安装的对话框。 " }, 
{ "title" : "安装和卸载软件包 ", 
"url" : "_cds_installing_package.html", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 安装和卸载软件包 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "使用 CODESYS Installer （默认） ", 
"url" : "_cds_installing_package.html#UUID-98af030d-c9df-9805-ad81-f774bb1247ba_section-idm4675118379435233494746701215", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 安装和卸载软件包 \/ 使用 CODESYS Installer （默认） ", 
"snippet" : "如果 CODESYS Installer 安装在您的计算机上，然后它将用于安装和卸载软件包和附加组件。例如，在这种情况下，它也由 项目检查向导 , 如有必要。 有关安装程序的更多信息，请参阅： CODESYS 安装程序 当对象添加到需要更多附加安装的项目时， CODESYS 响应如下： 相应的消息显示在消息视图中 必需的附加组件 消息类别。 带有文本的黄色突出显示字段 <n> 缺少附加组件 显示在状态栏中。双击该字段打开 必需的附加组件 对话框，其中列出了缺少的附加组件。您可以选择安装后的软件包，然后按 安装 按钮开始 CODESYS Installer ....", 
"body" : "如果 CODESYS Installer 安装在您的计算机上，然后它将用于安装和卸载软件包和附加组件。例如，在这种情况下，它也由 项目检查向导 , 如有必要。 有关安装程序的更多信息，请参阅： CODESYS 安装程序 当对象添加到需要更多附加安装的项目时， CODESYS 响应如下： 相应的消息显示在消息视图中 必需的附加组件 消息类别。 带有文本的黄色突出显示字段 <n> 缺少附加组件 显示在状态栏中。双击该字段打开 必需的附加组件 对话框，其中列出了缺少的附加组件。您可以选择安装后的软件包，然后按 安装 按钮开始 CODESYS Installer . " }, 
{ "title" : "如果 CODESYS Installer 不可用 ", 
"url" : "_cds_installing_package.html#UUID-98af030d-c9df-9805-ad81-f774bb1247ba_section-idm467511829340963349474202387", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 安装和卸载软件包 \/ 如果 CODESYS Installer 不可用 ", 
"snippet" : "如果 CODESYS Installer 未安装在您的计算机上，则 包管理器 直接可用。为此，请参阅以下说明： 要求：您已选择 工具 → 包管理器 命令。这 包管理器 对话框打开。 安装软件包 点击 安装 . 在里面 打开 对话框，从文件目录中选择一个包，然后单击 打开 . 这 检查包签名 对话框打开。 该对话框显示有关是否以及如何对所选包进行签名的信息。有关签署包的更多信息，请参阅工具提示。双击包时，对话框会显示有关包签名的更详细信息。 如果包是自签名或未签名的，您必须选择 允许未签名和自签名包 明确允许安装该软件包的选项。 如果您同意显示的签名，请单击 行 . 安装向导打开。在里面 安装 ...", 
"body" : "如果 CODESYS Installer 未安装在您的计算机上，则 包管理器 直接可用。为此，请参阅以下说明： 要求：您已选择 工具 → 包管理器 命令。这 包管理器 对话框打开。 安装软件包 点击 安装 . 在里面 打开 对话框，从文件目录中选择一个包，然后单击 打开 . 这 检查包签名 对话框打开。 该对话框显示有关是否以及如何对所选包进行签名的信息。有关签署包的更多信息，请参阅工具提示。双击包时，对话框会显示有关包签名的更详细信息。 如果包是自签名或未签名的，您必须选择 允许未签名和自签名包 明确允许安装该软件包的选项。 如果您同意显示的签名，请单击 行 . 安装向导打开。在里面 安装 - 许可协议 对话， CODESYS 还显示 校验和 的包。 当你点击 结束 在安装向导的最后一个对话框中， 1 个挂起的安装 显示在包管理器的下部。包装上标有 象征。 该软件包现在已在您的计算机上解压缩并准备好安装。 关闭所有 CODESYS 实例。 包管理器运行包的安装 CODESYS . 如果您想在安装完成之前查看安装摘要，请单击 下一个 在里面 安装 - 安装完成 对话。要完成安装，然后单击 结束 在里面 安装 - 总结 对话。 如果您想在不看到摘要的情况下完成安装，请单击 结束 在里面 安装 - 安装完成 对话。 如果 CODESYS Package Designer 软件包已安装并且您要安装的软件包需要更新版本的软件包管理器，然后安装向导会报告此情况。您可以在以下位置下载所需版本的包管理器 CODESYS Store International . 卸载软件包 选择包。 点击 卸载 . 向导将打开并指导您完成卸载程序包的过程。 当你点击 结束 在安装向导的最后一个对话框中， 1 个挂起的安装 显示在包管理器的下部。包装上标有 象征。 关闭所有 CODESYS 实例。 包管理器运行卸载 CODESYS 包裹。 在里面 卸载 对话框，点击 结束 完成卸载。 要求：您已点击 工具 → 包管理器 和 包管理器 对话框打开。 " }, 
{ "title" : "产品许可 ", 
"url" : "_cds_installing_license.html", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 产品许可 ", 
"snippet" : "许多 CODESYS 产品受许可证保护，因此您必须在启动产品之前激活它。一种扩展产品功能的附加产品 CODESYS Development System 通常使用工作站许可证激活。许可是通过 CODESYS Development System 安全密钥（加密狗），用于管理工作站的所有许可证。作为替代方案，一些产品将很快支持软容器上的许可。 此外，还有扩展范围的SL产品 CODESYS 控制 SoftPLC 系统。这些系统使用单个设备许可证激活。作为许可证激活文件提供的激活码直接安装在目标上。设备上的许可证管理也可以通过设备中的软容器（如果支持）或连接到设备的加密狗来完成。 在 CODESYS...", 
"body" : "许多 CODESYS 产品受许可证保护，因此您必须在启动产品之前激活它。一种扩展产品功能的附加产品 CODESYS Development System 通常使用工作站许可证激活。许可是通过 CODESYS Development System 安全密钥（加密狗），用于管理工作站的所有许可证。作为替代方案，一些产品将很快支持软容器上的许可。 此外，还有扩展范围的SL产品 CODESYS 控制 SoftPLC 系统。这些系统使用单个设备许可证激活。作为许可证激活文件提供的激活码直接安装在目标上。设备上的许可证管理也可以通过设备中的软容器（如果支持）或连接到设备的加密狗来完成。 在 CODESYS V3.5 SP13及更高版本，本地计算机上的附加产品License，以及单机License，都可以在本地统一管理 CODESYS 许可证管理器。对于具有唯一序列号的设备，如果设备上的许可证信息丢失，License Manager 可以从自动存储的许可证备份文件中重新激活许可证。 如果可能，请通过在线激活而不是离线激活来许可您的产品。 产品订阅的许可证更新是自动完成的。您可以在 许可证管理器 . " }, 
{ "title" : "在线激活 ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_52e8998a938fd111c0a8646342ceb317", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 产品许可 \/ 在线激活 ", 
"snippet" : "激活是可能的 CODESYS Development System 在里面 许可证管理器 对话。这样做的要求是您的开发系统可以访问 Internet。目标系统本身不需要 Internet 访问。 或者，您也可以在我们的网络仓库中激活您的许可证，网址为 https:\/\/license.codesys.com\/index.php 。 WebDepot 在线激活...", 
"body" : "激活是可能的 CODESYS Development System 在里面 许可证管理器 对话。这样做的要求是您的开发系统可以访问 Internet。目标系统本身不需要 Internet 访问。 或者，您也可以在我们的网络仓库中激活您的许可证，网址为 https:\/\/license.codesys.com\/index.php 。 WebDepot 在线激活 " }, 
{ "title" : "容器的选择 ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_section-idm4533120839552033964699368144", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 产品许可 \/ 容器的选择 ", 
"snippet" : "100,000 或更多的固件代码以前用于基于硬件的激活（CmDongles），5,000,000 或更多的固件代码用于基于软件的激活（CmActLicenses 和 CmSoftLicenses）。目前，有新的“通用公司代码”，可使用的范围为 6,000,000 及以上。 “通用公司代码”可以在基于硬件和基于软件的容器中进行编程。 不同集装箱类型的公司代码： 集装箱类型 128-xxx 1xx.xxx = CmDongle 公司代码：只能在 CmDongle（硬件）中导入 5.xxx.xxx = CmActLicense 公司代码：只能作为 CmActLicenses（软件） 集装箱类型 13...", 
"body" : "100,000 或更多的固件代码以前用于基于硬件的激活（CmDongles），5,000,000 或更多的固件代码用于基于软件的激活（CmActLicenses 和 CmSoftLicenses）。目前，有新的“通用公司代码”，可使用的范围为 6,000,000 及以上。 “通用公司代码”可以在基于硬件和基于软件的容器中进行编程。 不同集装箱类型的公司代码： 集装箱类型 128-xxx 1xx.xxx = CmDongle 公司代码：只能在 CmDongle（硬件）中导入 5.xxx.xxx = CmActLicense 公司代码：只能作为 CmActLicenses（软件） 集装箱类型 130-xxx 6.xxx.xxx = 通用公司代码：适用于 CmDongle、CmActLiceneses 和 CmSoftLicenses 如果可能，我们建议使用新的“通用公司代码”，因为该公司代码支持新功能。 " }, 
{ "title" : "离线激活 ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_8604f60bf98a3916c0a8652d01741064", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 产品许可 \/ 离线激活 ", 
"snippet" : "如果您的工作站计算机无法访问 Internet，那么您可以使用许可证激活文件来激活产品。您从 CODESYS 许可证服务器。为此，请从任何可以访问 Internet 的计算机连接到服务器并请求文件。然后，您将任何存储介质上的文件传输到您的工作计算机。该产品像往常一样在那里激活 CODESYS Development System ，适用于工作站许可证和单设备许可证。 如果您有一台可以访问 Internet 的计算机 CODESYS Development System 没有安装，也可以打开 CodeMeter 控制中心 由 Wibu Systems 激活许可证。 此外，对于基于 CODESYS...", 
"body" : "如果您的工作站计算机无法访问 Internet，那么您可以使用许可证激活文件来激活产品。您从 CODESYS 许可证服务器。为此，请从任何可以访问 Internet 的计算机连接到服务器并请求文件。然后，您将任何存储介质上的文件传输到您的工作计算机。该产品像往常一样在那里激活 CODESYS Development System ，适用于工作站许可证和单设备许可证。 如果您有一台可以访问 Internet 的计算机 CODESYS Development System 没有安装，也可以打开 CodeMeter 控制中心 由 Wibu Systems 激活许可证。 此外，对于基于 CODESYS Control Win 或者 CODESYS Control RTE ，您可以直接在目标上激活单个设备许可证。如果您没有具有以下功能的开发系统，这将很有用 CODESYS Development System .然后您可以从 CodeMeter 控制中心 ，或者您可以从浏览器激活许可证。 CodeMeter 安装在基于 Windows 的目标系统上。 这 CodeMeter 控制中心 管理 CodeMeter 服务并包含在 CODESYS 设置。 " }, 
{ "title" : "在本地计算机上在线激活附加许可证 ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_a896b93ef98a374cc0a8652d00afc374", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 产品许可 \/ 在本地计算机上在线激活附加许可证 ", 
"snippet" : "以下说明描述了如何通过加密狗执行许可。通过软容器的许可以相同的方式完成。 要求：您可以访问 Internet，并且 CODESYS Development System 安装在要安装许可证的计算机上。加密狗已连接到您的计算机。 点击 工具 → 许可证管理器 . 向导从 许可证管理器 - 选择目标 对话。 选择 工作站 作为目标并单击 下一个 .在里面 许可证管理器 - 选择容器 对话框，选择 加密狗 选项并单击 下一个 . 这 许可证管理器 对话框打开并显示要在 产品 窗口未获得许可。 选择产品并点击 安装许可证 左下角的按钮。 这 在工作站加密狗 <加密狗 ID> 上安装许可证 - 选择操作...", 
"body" : "以下说明描述了如何通过加密狗执行许可。通过软容器的许可以相同的方式完成。 要求：您可以访问 Internet，并且 CODESYS Development System 安装在要安装许可证的计算机上。加密狗已连接到您的计算机。 点击 工具 → 许可证管理器 . 向导从 许可证管理器 - 选择目标 对话。 选择 工作站 作为目标并单击 下一个 .在里面 许可证管理器 - 选择容器 对话框，选择 加密狗 选项并单击 下一个 . 这 许可证管理器 对话框打开并显示要在 产品 窗口未获得许可。 选择产品并点击 安装许可证 左下角的按钮。 这 在工作站加密狗 <加密狗 ID> 上安装许可证 - 选择操作 向导打开。 选择 激活许可证 操作并点击 下一个 . 这 在 Workstation Dongle <dongle ID> 上安装许可证 – 激活许可证 对话框打开。 指定 票号 您从软件供应商处收到的。 ID 由 5 个块组成，每个块包含 5 个字母数字字符。 选择 许可证服务器 提供激活产品的许可证。您从软件供应商处获得服务器 URL。 点击 下一个 按钮。 与许可证服务器的连接（ http:\/\/license.codesys.com ） 成立。 如果指定的票证仅包含一个许可证，则会在成功完成服务器操作后打开一个对话框以确认激活。 如果指定的票证包含多个许可证，则对话框 安装许可证 - 选择许可证 打开并显示工单中管理的许可证列表。 选择应激活的许可证并单击 下一个 . 成功完成服务器操作后，将打开一个确认激活的对话框。 选择 打开浏览器并选择 许可证中心 互联网页面。 这 许可证管理器 对话框打开。 输入您的许可证号。 点击 搜索 . 点击 下一个 . 与许可证服务器的连接（ http:\/\/license.codesys.com ） 成立。 " }, 
{ "title" : "在本地计算机上脱机激活附加许可证 ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_9c3355c9d43311e7a0b8a97e058b4068", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 产品许可 \/ 在本地计算机上脱机激活附加许可证 ", 
"snippet" : "要求：您要安装附加包的许可证。这 CODESYS Development System 安装在要安装许可证的计算机上。计算机无法访问 Internet。 对于这种方法，首先在目标计算机上创建一个许可证请求文件 CODESYS .然后将此文件复制到具有 Internet 访问权限的计算机上。这 CodeMeter 控制中心 必须安装在这台电脑上。您使用 CODESYS 许可证服务器生成许可证激活文件以在目标计算机上激活。 以下说明描述了如何通过加密狗执行许可。通过软容器的许可以相同的方式完成。 点击 工具 → 许可证管理器 . 这 许可证管理器 向导启动。 选择 工作站 作为目标。点击 下一个 ...", 
"body" : "要求：您要安装附加包的许可证。这 CODESYS Development System 安装在要安装许可证的计算机上。计算机无法访问 Internet。 对于这种方法，首先在目标计算机上创建一个许可证请求文件 CODESYS .然后将此文件复制到具有 Internet 访问权限的计算机上。这 CodeMeter 控制中心 必须安装在这台电脑上。您使用 CODESYS 许可证服务器生成许可证激活文件以在目标计算机上激活。 以下说明描述了如何通过加密狗执行许可。通过软容器的许可以相同的方式完成。 点击 工具 → 许可证管理器 . 这 许可证管理器 向导启动。 选择 工作站 作为目标。点击 下一个 并选择 加密狗 作为容器。点击 下一个 再次。 对话框打开以选择产品和容器。 选择要安装许可证的加密狗。 例子： 本地：CmStick [2-2404696] 点击 安装许可证 . 这 在工作站加密狗 <加密狗 ID> 上安装许可证 - 选择操作 向导打开。 选择 申请许可证 选项并单击 下一个 . 这 在 <computer> 上安装许可证 – 请求许可证 向导打开。 在里面 软件供应商 输入字段，指定提供激活产品许可证的软件供应商的公司代码。您还可以从列表框中选择软件供应商的名称。 指定文件的位置和文件名 上下文文件 ， 例如 CmStick [2-2404696].WibuCmRaC . 点击 结束 . 上下文文件（ *.WibuCmRaC ） 被建造。 将此许可请求文件复制到具有 Internet 访问权限的计算机上。 在这台电脑上，打开 CODESYS 浏览器中的许可证服务器（ http:\/\/license.codesys.com ）。 CODESYS 许可证服务器： 输入许可证编号，然后单击 下一个 . 在随后的对话框中，单击 激活许可证 . 在下一个对话框中，选择许可证的绑定。单击带有 CODESYS 运行时密钥（加密狗）。 将打开以下对话框： 在对话框中，选择许可证容器，例如 2-2404696 .选择 离线许可证转让 . 将打开以下对话框： 选择您在另一台计算机上创建的许可请求文件，然后单击 上传请求并立即继续 . 将打开以下对话框： 将许可证更新文件加载到您的计算机。选择 立即下载许可证更新文件 . 将许可证更新文件复制到目标计算机。 在里面 许可证管理器 对话框，点击 安装许可证 按钮并选择 安装许可证 选项。 这 在 Workstation Dongle <dongle ID> 上安装许可证 – 安装许可证 对话框打开。 在输入字段中指定文件路径。 例子： D:\\Lic\\CmStick [2-2404696].WibuCmRaU 点击 结束 . 许可证更新文件安装在选定的加密狗上。 " }, 
{ "title" : "脱机激活基于 Windows 的运行时 ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_bbe1a04a10ae11e897c3e7cd79b8a53c", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 产品许可 \/ 脱机激活基于 Windows 的运行时 ", 
"snippet" : "您想要为基于 Windows 的运行时安装许可证。 对于这种方法，首先在目标计算机上创建一个许可请求文件 CodeMeter 控制中心 .然后将此文件复制到具有 Internet 访问权限的计算机上。这 CodeMeter 控制中心 必须安装在这台电脑上。您使用 CODESYS 许可证服务器以生成您在目标计算机上激活的许可证激活文件。 初始情况： CODESYS Development System 未安装在要安装许可证的计算机上。计算机无法访问 Internet。 打开 CodeMeter 控制中心 .在工具栏上，双击 系统托盘（通知区域）中的图标。 选择许可证内存 3S-Smart 软件解...", 
"body" : "您想要为基于 Windows 的运行时安装许可证。 对于这种方法，首先在目标计算机上创建一个许可请求文件 CodeMeter 控制中心 .然后将此文件复制到具有 Internet 访问权限的计算机上。这 CodeMeter 控制中心 必须安装在这台电脑上。您使用 CODESYS 许可证服务器以生成您在目标计算机上激活的许可证激活文件。 初始情况： CODESYS Development System 未安装在要安装许可证的计算机上。计算机无法访问 Internet。 打开 CodeMeter 控制中心 .在工具栏上，双击 系统托盘（通知区域）中的图标。 选择许可证内存 3S-Smart 软件解决方案 软件许可证 在许可证概述中。 点击 激活许可证 按钮。 这 厘米FAS 向导打开。 点击 下一个 . 将显示可能的操作列表。 选择 创建许可证请求 并点击 下一个 . 指定许可证请求文件的名称并单击保存 申请 .关闭对话框。 生成许可请求文件。 例子： 32767-4241603201.WibuCmRaC 将此许可请求文件复制到具有 Internet 访问权限的计算机上。 在这台电脑上，打开 CODESYS 浏览器中的许可证服务器。 CODESYS 许可证服务器： 输入许可证编号，然后单击 下一个 . 在随后的对话框中，单击 激活许可证 . 在下一个对话框中，选择许可证的绑定。单击带有 CODESYS 软件密钥（软容器）。 将打开以下对话框： 在对话框中，选择许可证容器。 例子： 32767-4241603201（3S-Smart软件解决方案软件许可证 点击 离线许可证转让 . 将打开以下对话框： 选择您在另一台计算机上创建的许可请求文件，然后单击 上传请求并立即继续 . 将打开以下对话框： 将许可证更新文件加载到您的计算机。点击 立即下载许可证更新文件 . 对话框打开以保存文件。 保存许可证更新文件并将其复制到目标计算机。 打开 CodeMeter 控制中心 . 选择许可证内存 3S-Smart 软件解决方案 软件许可证 在许可证概述中。 点击 激活许可证 按钮。 这 厘米FAS 向导打开。 点击 下一个 . 将显示可能的操作列表。 选择 进口许可证更新 并点击 下一个 . 选择许可证更新文件，例如 128-9754375.WibuCmRaU ，然后单击 申请 . 许可证更新文件安装在选定的加密狗上。 " }, 
{ "title" : "基于 Linux 的系统的离线激活 ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_e15f5a8067cfa551c0a864632160e725", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 产品许可 \/ 基于 Linux 的系统的离线激活 ", 
"snippet" : "您想为基于 Linux 的运行时安装单个许可证。 要求：您的开发系统具有 CODESYS Development System 无法访问 Internet，但已连接到设备。 打开 CODESYS . 创建一个标准项目。 更新设备。 在 CODESYS ， 点击 工具 → 许可证管理器 . 向导从 许可证管理器 - 选择目标 对话。 选择 设备 作为目标并单击 下一个 .在里面 许可证管理器 - 选择容器 对话框，选择 软容器 或者 加密狗 选项并单击 下一个 . 这 许可证管理器 对话框打开。要获得许可的产品显示在 产品 看法。 点击 安装许可证 按钮。在里面 在 <设备> 上安装许可证 – ...", 
"body" : "您想为基于 Linux 的运行时安装单个许可证。 要求：您的开发系统具有 CODESYS Development System 无法访问 Internet，但已连接到设备。 打开 CODESYS . 创建一个标准项目。 更新设备。 在 CODESYS ， 点击 工具 → 许可证管理器 . 向导从 许可证管理器 - 选择目标 对话。 选择 设备 作为目标并单击 下一个 .在里面 许可证管理器 - 选择容器 对话框，选择 软容器 或者 加密狗 选项并单击 下一个 . 这 许可证管理器 对话框打开。要获得许可的产品显示在 产品 看法。 点击 安装许可证 按钮。在里面 在 <设备> 上安装许可证 – 选择操作 对话框，选择 申请许可证 选项并单击 下一个 . 这 在 <设备> 上安装许可证 – 请求许可证 对话框打开。 在里面 软件供应商 输入字段，指定提供激活产品许可证的软件供应商的公司代码。您还可以从列表框中选择软件供应商的名称。 指定文件的位置和文件名 上下文文件 . 例子： CmStick [2-2404696].WibuCmRaC 点击 结束 . 上下文文件（ *.WibuCmRaC ） 被建造。 生成更新文件（ *.WibuCmRaU ) 在浏览器中。 将此许可请求文件复制到具有 Internet 访问权限的计算机上。这 CodeMeter 控制中心 必须安装在这台电脑上。 在这台电脑上，打开 CODESYS 浏览器中的许可证服务器（ http:\/\/license.codesys.com ）。 CODESYS 许可证服务器： 输入许可证编号，然后单击 下一个 . 在随后的对话框中，单击 激活许可证 . 在下一个对话框中，选择许可证的绑定。单击带有 CODESYS 运行时密钥（加密狗）。 将打开以下对话框： 在下一个对话框中，选择许可证容器。 例子： 2-2404696 点击 离线许可证转让 . 将打开以下对话框： 选择您在另一台计算机上创建的许可请求文件，然后单击 上传请求并立即继续 . 将打开以下对话框： 将许可证更新文件加载到您的计算机。点击 立即下载许可证更新文件 . 将许可证更新文件复制到目标计算机。 在里面 许可证管理器 对话框，点击 安装许可证 按钮。 这 在 <设备> 上安装许可证 – 选择操作 向导打开。 选择 安装许可证 选项并单击 下一个 . 在输入字段中，指定许可证激活文件的文件路径。 点击 结束 将许可证转移到软件密钥（软容器）。 许可证处于活动状态。 " }, 
{ "title" : "恢复许可证 ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_7f6761c2468b3986c0a8646345ba6917", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 产品许可 \/ 恢复许可证 ", 
"snippet" : "在 CODESYS V3.5 SP13 及更高版本，许可证备份文件（ *.WibuCmRau ) 在为具有唯一序列号的设备激活工作站许可证时自动创建。该文件存储在您的计算机和许可证服务器上。如果设备上的许可文件丢失，您可以使用许可管理器从该文件恢复许可。 您已激活设备许可证。 在 CODESYS ， 点击 工具 → 许可证管理器 .按照向导使用目标的相应条目：设备和容器（软容器或加密狗），以及相应设备的选择。 在里面 许可证管理器 对话框，点击 附加功能 按钮并选择 恢复许可证 命令。 这 恢复许可证 对话框打开。 输入 票号 获取设备许可证，然后单击 恢复 . CODESYS 搜索保存的许可...", 
"body" : "在 CODESYS V3.5 SP13 及更高版本，许可证备份文件（ *.WibuCmRau ) 在为具有唯一序列号的设备激活工作站许可证时自动创建。该文件存储在您的计算机和许可证服务器上。如果设备上的许可文件丢失，您可以使用许可管理器从该文件恢复许可。 您已激活设备许可证。 在 CODESYS ， 点击 工具 → 许可证管理器 .按照向导使用目标的相应条目：设备和容器（软容器或加密狗），以及相应设备的选择。 在里面 许可证管理器 对话框，点击 附加功能 按钮并选择 恢复许可证 命令。 这 恢复许可证 对话框打开。 输入 票号 获取设备许可证，然后单击 恢复 . CODESYS 搜索保存的许可证备份文件，首先在本地计算机上，然后在许可证中心服务器上。如果找到与设备匹配的文件，则恢复并激活许可证。 " }, 
{ "title" : "控制器产品和设备功能的许可证信息列表 ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_0de8d32402b86f11c0a8646319093e62", 
"breadcrumbs" : "CODESYS Essentials \/ 管理包和许可证 \/ 产品许可 \/ 控制器产品和设备功能的许可证信息列表 ", 
"snippet" : "要求： 这 CODESYS Development System （V3.5 SP15 或更高版本）已打开。 应读取信息的网关和控制器正在运行。 控制器上不存在应用程序。 点击 工具 → 设备许可证阅读器 。 这 选择设备 对话框打开。 双击所需的网关以扫描网络。 如果没有显示网关，则单击 新网关 并在 网关 对话。 选择一个控制器。 点击 行 确认选择。 注意：如果控制器上存在应用程序，则会打开一个对话框，提示是否应从控制器中删除所有应用程序。当你点击 不 在此对话框中，无法读取控制器的许可证信息。这 设备阅读器 命令被中止。 CODESYS 使用所选控制器的产品和设备功能的许可证信息创建列...", 
"body" : "要求： 这 CODESYS Development System （V3.5 SP15 或更高版本）已打开。 应读取信息的网关和控制器正在运行。 控制器上不存在应用程序。 点击 工具 → 设备许可证阅读器 。 这 选择设备 对话框打开。 双击所需的网关以扫描网络。 如果没有显示网关，则单击 新网关 并在 网关 对话。 选择一个控制器。 点击 行 确认选择。 注意：如果控制器上存在应用程序，则会打开一个对话框，提示是否应从控制器中删除所有应用程序。当你点击 不 在此对话框中，无法读取控制器的许可证信息。这 设备阅读器 命令被中止。 CODESYS 使用所选控制器的产品和设备功能的许可证信息创建列表，并将信息显示在 设备阅读器 对话。 " }, 
{ "title" : "使用脚本 ", 
"url" : "_cds_struct_using_scripts.html", 
"breadcrumbs" : "CODESYS Essentials \/ 使用脚本 ", 
"snippet" : "使用脚本功能 CODESYS ，您可以自动执行命令或复杂的程序操作，否则您必须通过鼠标单击和文本输入在 CODESYS 用户界面。您可以从 CODESYS 用户界面（命令或配置的工具栏）或从 Windows 命令行。 请参阅此帮助 CODESYS Scripting ....", 
"body" : "使用脚本功能 CODESYS ，您可以自动执行命令或复杂的程序操作，否则您必须通过鼠标单击和文本输入在 CODESYS 用户界面。您可以从 CODESYS 用户界面（命令或配置的工具栏）或从 Windows 命令行。 请参阅此帮助 CODESYS Scripting . " }, 
{ "title" : "安全 ", 
"url" : "_cds_struct_security.html", 
"breadcrumbs" : "CODESYS Essentials \/ 安全 ", 
"snippet" : "由于控制器和工厂网络的增加，潜在威胁也在迅速上升。因此，您应该仔细考虑所有可能的安全措施。 安全措施对于保护数据和通信渠道免受未经授权的访问是绝对必要的。 有关安全功能的信息和说明，请参见 CODESYS 开发环境和控制器上： 安全...", 
"body" : "由于控制器和工厂网络的增加，潜在威胁也在迅速上升。因此，您应该仔细考虑所有可能的安全措施。 安全措施对于保护数据和通信渠道免受未经授权的访问是绝对必要的。 有关安全功能的信息和说明，请参见 CODESYS 开发环境和控制器上： 安全 " }, 
{ "title" : "参考：编程 ", 
"url" : "_cds_f_reference_programming.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "转换： BOOL ", 
"url" : "_cds_operator_bool_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 转换： BOOL ", 
"snippet" : "BOOL 运算符 BOOL_TO_<type> 将布尔值转换为指定的数据类型并返回类型转换后的值。 调用语法 ： < BOOL_TO_<类型> ( <操作数> ) 操作数 数据类型 描述 变量，文字 BOOL 运算符：BOOL_TO_<type> 操作员 例子 返回值 描述 BOOL_TO___UXINT BOOL_TO___UXINT(TRUE) 1 __UXINT、__XINT、__XWORD BOOL_TO___XINT BOOL_TO___XINT(TRUE) 1 __UXINT、__XINT、__XWORD BOOL_TO___XWORD BOOL_TO___XWINT(TRUE) ...", 
"body" : "BOOL 运算符 BOOL_TO_<type> 将布尔值转换为指定的数据类型并返回类型转换后的值。 调用语法 ： < BOOL_TO_<类型> ( <操作数> ) 操作数 数据类型 描述 变量，文字 BOOL 运算符：BOOL_TO_<type> 操作员 例子 返回值 描述 BOOL_TO___UXINT BOOL_TO___UXINT(TRUE) 1 __UXINT、__XINT、__XWORD BOOL_TO___XINT BOOL_TO___XINT(TRUE) 1 __UXINT、__XINT、__XWORD BOOL_TO___XWORD BOOL_TO___XWINT(TRUE) 1 __UXINT、__XINT、__XWORD BOOL_TO_BIT BOOL_TO___BIT(TRUE) TRUE BIT BOOL_TO_BYTE BOOL_TO_BYTE(TRUE) 1 Integer BOOL_TO_DATE BOOL_TO_DATE(TRUE) D#1970-1-1 第 0 位已设置，但对显示没有影响。 数据类型：DATE BOOL_TO_DINT BOOL_TO_DINT(TRUE) 1 Integer BOOL_TO_DT BOOL_TO_DT(TRUE) DT#1970-01-01-0:0:1 数据类型：DATE BOOL_TO_DWORD BOOL_TO_DWORD(TRUE) 1 Integer BOOL_TO_INT BOOL_TO_INT(TRUE) 1 Integer BOOL_TO_LDATE BOOL_TO_LDATE(TRUE) LD#1970-01-01 第 0 位已设置，但对显示没有影响。 数据类型：DATE BOOL_TO_LDT BOOL_TO_LD(TRUE) DT#1970-01-01-0:0:1 数据类型：DATE BOOL_TO_LINT BOOL_TO_LINT(TRUE) 1 Integer BOOL_TO_LREAL BOOL_TO_LREAL(TRUE) 1 REAL, LREAL BOOL_TO_LTIME BOOL_TO_LTIME(TRUE) LTIME#1NS 数据类型：DATE BOOL_TO_LTOD BOOL_TO_LTOD(TRUE) LTOD#0:0:0.000000001 数据类型：DATE BOOL_TO_LWORD BOOL_TO_LWORD(TRUE) 1 Integer BOOL_TO_REAL BOOL_TO_REAL(TRUE) 1 REAL, LREAL BOOL_TO_SINT BOOL_TO_SINT(TRUE) 1 Integer BOOL_TO_STRING BOOL_TO_STRING(TRUE) 'TRUE' STRING BOOL_TO_TIME BOOL_TO_TIME(TRUE) T#1ms 数据类型：DATE BOOL_TO_TOD BOOL_TO_TOD(TRUE) TOD#0:0:0.001 数据类型：DATE BOOL_TO_UDINT BOOL_TO_UDINT(TRUE) 1 Integer BOOL_TO_UINT BOOL_TO_UINT(TRUE) 1 Integer BOOL_TO_ULINT BOOL_TO_ULINT(TRUE) 1 Integer BOOL_TO_USINT BOOL_TO_ULSINT(TRUE) 1 Integer BOOL_TO_WORD BOOL_TO_WORD(TRUE) 1 Integer BOOL_TO_WSTRING BOOL_TO_WSTRING(TRUE) \"TRUE\" WSTRING" }, 
{ "title" : "例子 ", 
"url" : "_cds_operator_bool_to.html#UUID-2a346bdb-4e90-93fe-7336-6fbb8a8d690a_UUID-7cb488ce-e3ad-80d5-81d9-c44c2ef838fa_id_a353abc1de5f9c0a8640e006e95fc_id_a764924bfc35ef1cc0a8646370e2d8a1", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 转换： BOOL \/ 例子 ", 
"snippet" : "FB_ConvertFromBool ST 中的声明 FUNCTION_BLOCK FB_ConvertFromBool VAR uxiReturn_1: __UXINT; uxiReturn_10: __UXINT; iReturn_2: __XINT; iReturn_20: __XINT; xwReturn_3: __XWORD; xwReturn_30: __XWORD; bitReturn_4: BOOL; bitReturn_40: BOOL; bReturn_6: BYTE; bReturn_60: BYTE; dateReturn_7: DATE; dateReturn_70:...", 
"body" : "FB_ConvertFromBool ST 中的声明 FUNCTION_BLOCK FB_ConvertFromBool\nVAR\n uxiReturn_1: __UXINT;\n uxiReturn_10: __UXINT;\n iReturn_2: __XINT;\n iReturn_20: __XINT;\n xwReturn_3: __XWORD;\n xwReturn_30: __XWORD;\n bitReturn_4: BOOL;\n bitReturn_40: BOOL;\n bReturn_6: BYTE;\n bReturn_60: BYTE;\n dateReturn_7: DATE;\n dateReturn_70: DATE;\n dtReturn_8: DATE_AND_TIME;\n dtReturn_80: DATE_AND_TIME;\n diReturn_9: DINT;\n diReturn_90: DINT;\n dtReturn_10: DATE_AND_TIME;\n dtReturn_100: DATE_AND_TIME;\n dwReturn_11: DWORD;\n dwReturn_110: DWORD;\n iReturn_12: INT;\n iReturn_120: INT;\n liReturn_13: LINT;\n liReturn_130: LINT;\n lrReturn_14: LREAL;\n lrReturn_140: LREAL;\n lwReturn_15: LWORD;\n lwReturn_150: LWORD;\n rReturn_16: REAL;\n rReturn_160: REAL;\n siReturn_17: SINT;\n siReturn_170: SINT;\n sReturn_18: STRING;\n sReturn_180: STRING;\n todReturn_19: TIME_OF_DAY;\n todReturn_190: TIME_OF_DAY;\n timReturn_20: TIME;\n timReturn_200: TIME;\n todReturn_21: TIME_OF_DAY;\n todReturn_210: TIME_OF_DAY;\n udiReturn_22: UDINT;\n udiReturn_220: UDINT;\n uiReturn_23: UINT;\n uiReturn_230: UINT;\n uliReturn_24: ULINT;\n uliReturn_240: ULINT;\n usiReturn_25: USINT;\n usiReturn_250: USINT;\n wReturn_26: WORD;\n wReturn_260: WORD;\n wsReturn_27: WSTRING;\n wsReturn_270: WSTRING;\nEND_VAR\n 在 ST 中的实现 FUNCTION_BLOCK FB_ConvertFromBool\nVAR\nVAR\n uxiReturn_1: __UXINT;\n uxiReturn_10: __UXINT;\n iReturn_2: __XINT;\n iReturn_20: __XINT;\n xwReturn_3: __XWORD;\n xwReturn_30: __XWORD;\n bitReturn_4: BOOL;\n bitReturn_40: BOOL;\n bReturn_6: BYTE;\n bReturn_60: BYTE;\n dateReturn_7: DATE;\n dateReturn_70: DATE;\n dtReturn_8: DATE_AND_TIME;\n dtReturn_80: DATE_AND_TIME;\n diReturn_9: DINT;\n diReturn_90: DINT;\n dtReturn_10: DATE_AND_TIME;\n dtReturn_100: DATE_AND_TIME;\n dwReturn_11: DWORD;\n dwReturn_110: DWORD;\n iReturn_12: INT;\n iReturn_120: INT;\n liReturn_13: LINT;\n liReturn_130: LINT;\n lrReturn_14: LREAL;\n lrReturn_140: LREAL;\n lwReturn_15: LWORD;\n lwReturn_150: LWORD;\n rReturn_16: REAL;\n rReturn_160: REAL;\n siReturn_17: SINT;\n siReturn_170: SINT;\n sReturn_18: STRING;\n sReturn_180: STRING;\n todReturn_19: TIME_OF_DAY;\n todReturn_190: TIME_OF_DAY;\n timReturn_20: TIME;\n timReturn_200: TIME;\n todReturn_21: TIME_OF_DAY;\n todReturn_210: TIME_OF_DAY;\n udiReturn_22: UDINT;\n udiReturn_220: UDINT;\n uiReturn_23: UINT;\n uiReturn_230: UINT;\n uliReturn_24: ULINT;\n uliReturn_240: ULINT;\n usiReturn_25: USINT;\n usiReturn_250: USINT;\n wReturn_26: WORD;\n wReturn_260: WORD;\n wsReturn_27: WSTRING;\n wsReturn_270: WSTRING;\nEND_VAR\n\n\/\/ Return value of operand = TRUE or FALSE\nuxiReturn_1 := BOOL_TO___UXINT(TRUE);\nuxiReturn_10 := BOOL_TO___UXINT(FALSE);\n\niReturn_2 := BOOL_TO___XINT(TRUE);\niReturn_20 := BOOL_TO___XINT(FALSE);\n\nxwReturn_3 := BOOL_TO___XWORD(TRUE);\nxwReturn_30 := BOOL_TO___XWORD(FALSE);\n\nbitReturn_4 := BOOL_TO_BIT(TRUE);\nbitReturn_40 := BOOL_TO_BIT(FALSE);\n\nbReturn_6 := BOOL_TO_BYTE(TRUE);\nbReturn_60 := BOOL_TO_BYTE(FALSE);\n\ndateReturn_7 := BOOL_TO_DATE(TRUE);\ndateReturn_70 := BOOL_TO_DATE(FALSE);\n\ndtReturn_8 := BOOL_TO_DT(TRUE);\ndtReturn_80 := BOOL_TO_DT(FALSE);\n\ndiReturn_9 := BOOL_TO_DINT(TRUE);\ndiReturn_90 := BOOL_TO_DINT(FALSE);\n\ndwReturn_11 := BOOL_TO_DWORD(TRUE);\ndwReturn_110 := BOOL_TO_DWORD(FALSE);\n\niReturn_12 := BOOL_TO_INT(TRUE);\niReturn_120 := BOOL_TO_INT(FALSE);\n\nliReturn_13 := BOOL_TO_LINT(TRUE);\nliReturn_130 := BOOL_TO_LINT(FALSE);\n\nlrReturn_14 := BOOL_TO_LREAL(TRUE);\nlrReturn_140 := BOOL_TO_LREAL(FALSE);\n\nlwReturn_15 := BOOL_TO_LWORD(TRUE);\nlwReturn_150 := BOOL_TO_LWORD(FALSE);\n\nrReturn_16 := BOOL_TO_REAL(TRUE);\nrReturn_160 := BOOL_TO_REAL(FALSE);\n\nsiReturn_17 := BOOL_TO_SINT(TRUE);\nsiReturn_170 := BOOL_TO_SINT(FALSE);\n\nsReturn_18 := BOOL_TO_STRING(TRUE);\nsReturn_180 := BOOL_TO_STRING(FALSE);\n\ntimReturn_20 := BOOL_TO_TIME(TRUE);\ntimReturn_200 := BOOL_TO_TIME(FALSE);\n\ntodReturn_21 := BOOL_TO_TOD(TRUE);\ntodReturn_210 := BOOL_TO_TOD(FALSE);\n\nudiReturn_22 := BOOL_TO_UDINT(TRUE);\nudiReturn_220 := BOOL_TO_UDINT(FALSE);\n\nuiReturn_23 := BOOL_TO_UINT(TRUE);\nuiReturn_230 := BOOL_TO_UINT(FALSE);\n\nuliReturn_24 := BOOL_TO_ULINT(TRUE);\nuliReturn_240 := BOOL_TO_ULINT(FALSE);\n\nusiReturn_25 := BOOL_TO_USINT(TRUE);\nusiReturn_250 := BOOL_TO_USINT(FALSE);\n\nwReturn_26 := BOOL_TO_WORD(TRUE);\nwReturn_260 := BOOL_TO_WORD(FALSE);\n\nwsReturn_27 := BOOL_TO_WSTRING(TRUE);\nwsReturn_270 := BOOL_TO_WSTRING(FALSE); FBD 实现语言 FBD 实现语言 " }, 
{ "title" : "编程语言和编辑器 ", 
"url" : "_cds_struct_reference_programming_languages_and_editors.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 ", 
"snippet" : "在每种情况下，您都在编辑器中为您在创建 POU 时选择的实施语言编写了一个 POU。 CODESYS 为 ST 提供文本编辑器，为 SFC、FBD\/LD\/IL 和 CFC 提供图形编辑器。 双击设备树中的 POU 或在 POU 看法。 每个实现语言编辑器都包含两个子窗口： 在顶部，您在“声明编辑器”中定义声明，具体取决于文本或表格形式的设置。 在底部，您插入相应语言的实现代码。 您可以在整个项目的相应选项卡中配置每个编辑器的外观和行为 CODESYS 选项。...", 
"body" : "在每种情况下，您都在编辑器中为您在创建 POU 时选择的实施语言编写了一个 POU。 CODESYS 为 ST 提供文本编辑器，为 SFC、FBD\/LD\/IL 和 CFC 提供图形编辑器。 双击设备树中的 POU 或在 POU 看法。 每个实现语言编辑器都包含两个子窗口： 在顶部，您在“声明编辑器”中定义声明，具体取决于文本或表格形式的设置。 在底部，您插入相应语言的实现代码。 您可以在整个项目的相应选项卡中配置每个编辑器的外观和行为 CODESYS 选项。 " }, 
{ "title" : "声明编辑器 ", 
"url" : "_cds_edt_declaration_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 声明编辑器 ", 
"snippet" : "在声明编辑器中，您 宣布 变量列表和 POU 中的变量。 如果声明编辑器与 实现语言编辑器 ，然后在实现语言编辑器上方的视图中打开。 声明编辑器提供两种可能的视图：文本 视图和表格 看法。 在 声明编辑器，您可以定义是否仅文本视图或仅表格视图可用，或者是否可以通过编辑器视图右侧的按钮在两个视图之间切换。 当编辑器窗口因文本行过长而出现滚动条时，您可以通过按住鼠标滚轮滚动来滚动 转移 钥匙。按住鼠标滚轮的同时滚动鼠标滚轮可以放大编辑器窗口 控制键 钥匙。 在线模式下的声明编辑器 在在线模式下，您会看到编辑器的表格视图。标头始终包含当前对象路径： <device name>.<applicatio...", 
"body" : "在声明编辑器中，您 宣布 变量列表和 POU 中的变量。 如果声明编辑器与 实现语言编辑器 ，然后在实现语言编辑器上方的视图中打开。 声明编辑器提供两种可能的视图：文本 视图和表格 看法。 在 声明编辑器，您可以定义是否仅文本视图或仅表格视图可用，或者是否可以通过编辑器视图右侧的按钮在两个视图之间切换。 当编辑器窗口因文本行过长而出现滚动条时，您可以通过按住鼠标滚轮滚动来滚动 转移 钥匙。按住鼠标滚轮的同时滚动鼠标滚轮可以放大编辑器窗口 控制键 钥匙。 在线模式下的声明编辑器 在在线模式下，您会看到编辑器的表格视图。标头始终包含当前对象路径： <device name>.<application name>.<object name> .与离线模式相比，该表还包含 价值 和 准备值 列。 这 价值 列显示 PLC 上的实际值，提供监控功能。如果表达式是一个包含超过 1,000 个元素的数组，那么您可以定义要监视的数组索引的范围。为此，请双击 数据类型 打开列 监控区域 对话。在此对话框中，声明的数组范围指定为 有效区域 用于监控。每个阵列最多可以监控 20,000 个元素。您可以通过指定要监视的数组索引的范围来定义 开始 和 结尾 指数。为了在保持相同大小的同时更轻松地移动该区域，可用的滚动条可以结合使用。之间切换 耦合和 未耦合，请单击该栏右侧的符号。在非耦合状态下，您可以根据需要增加或减少要监控的区域的大小。 这 准备值 列包含您指定的值 准备好了 为了 强迫或书写 。 如果你双击一个 准备值 字段，然后您可以明确指定一个值用于写入或强制。对于枚举，将打开一个组合框，您可以从中选择一个值。在布尔变量的情况下，您可以借助 进入 钥匙或 空间 酒吧。 如果表达式（变量）是结构化数据类型，例如功能块的实例或数组变量，则将加号或减号放在前面。 您可以自定义浮点值的表示格式 选项 用于监控。 " }, 
{ "title" : "图形编辑器中的常用功能 ", 
"url" : "_cds_common_functionalities_in_grafic_editors.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 图形编辑器中的常用功能 ", 
"snippet" : "FBD、LD、CFC 和 SFC 的图形编辑器的实现部分在右下角包含一个工具栏： 返回正常编辑模式 鼠标指针变回默认箭头的形状。您可以在编辑器视图中选择和编辑元素。 平移工具 鼠标指针变为两个交叉箭头的形状。您可以单击并拖动编辑器视图中的任意位置以移动 FBD\/LD\/IL 编辑器的可见区域或旋转 CFC 图表。 放大工具 在编辑器视图的右下角打开一个放大的窗口，鼠标指针变为十字形。当您将鼠标指针移到图表上时，放大工具会以 100% 的放大率显示十字下方的图表区域。注意：如果您在视图中单击，则放大工具会关闭，并且该工具包含的图表部分会以 100% 的放大率显示。如果你想保持设置的缩放系数，那么你...", 
"body" : "FBD、LD、CFC 和 SFC 的图形编辑器的实现部分在右下角包含一个工具栏： 返回正常编辑模式 鼠标指针变回默认箭头的形状。您可以在编辑器视图中选择和编辑元素。 平移工具 鼠标指针变为两个交叉箭头的形状。您可以单击并拖动编辑器视图中的任意位置以移动 FBD\/LD\/IL 编辑器的可见区域或旋转 CFC 图表。 放大工具 在编辑器视图的右下角打开一个放大的窗口，鼠标指针变为十字形。当您将鼠标指针移到图表上时，放大工具会以 100% 的放大率显示十字下方的图表区域。注意：如果您在视图中单击，则放大工具会关闭，并且该工具包含的图表部分会以 100% 的放大率显示。如果你想保持设置的缩放系数，那么你应该使用 返回默认编辑模式。 缩放工具 这将打开一个列表框，其中包含一系列缩放因子。单击更多选择 ( ... ) 将打开 飞涨 用于输入其他值的对话框。当前缩放系数始终显示在符号的左侧。 使用滚轮缩放：按住 Ctrl 键并移动滚轮，可以以 10% 为单位更改缩放系数。 每个图形编辑器都有自己的 工具箱 默认情况下位于编辑器视图右侧的视图。工具箱包含您可以拖动到编辑器视图中的插入点的元素。 CODESYS 用菱形、三角形或箭头形状的灰色位置标志突出显示插入点。当您将鼠标指针移到它们上面时，这些标志是绿色的。当您松开鼠标按钮时， CODESYS 在选定位置插入元素。 也可以使用鼠标在编辑器中移动元素。 您可以将 FBD、LD 和 CFC 图形编辑器中的功能块声明拖到编辑器视图中。为此，请选择完整的声明（变量名称和数据类型）并将其拖到编辑器视图中的合适位置。在梯形图中，您还可以将布尔声明拖到编辑器中并将它们作为联系人插入。 " }, 
{ "title" : "结构化文本和扩展结构化文本 (ExST) ", 
"url" : "_cds_st_f_language.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ST 编辑 ", 
"url" : "_cds_edt_st_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ ST 编辑 ", 
"snippet" : "ST 编辑器是一个文本编辑器，用于 执行 结构化文本 (ST) 和扩展结构化文本 (ExST) 中的代码。 行号显示在编辑器的左侧。输入编程元素时，“列表组件”功能（在 CODESYS 选项， 智能编码 类别）和输入助手（ F2 ) 也很有用。当光标放在变量上时， CODESYS 显示带有声明变量信息的工具提示。 可以使用以下组合键进行框选择： 转移 + Alt + 向右箭头 ：所选区域向右扩展一位。 转移 + Alt + 向左箭头 ：所选区域向左扩展一位。 转移 + Alt + 向上箭头 ：选定区域向上扩展一个位置。 转移 + Alt + 向下箭头 ：所选区域向下扩展一位。 当编辑器窗口因文...", 
"body" : "ST 编辑器是一个文本编辑器，用于 执行 结构化文本 (ST) 和扩展结构化文本 (ExST) 中的代码。 行号显示在编辑器的左侧。输入编程元素时，“列表组件”功能（在 CODESYS 选项， 智能编码 类别）和输入助手（ F2 ) 也很有用。当光标放在变量上时， CODESYS 显示带有声明变量信息的工具提示。 可以使用以下组合键进行框选择： 转移 + Alt + 向右箭头 ：所选区域向右扩展一位。 转移 + Alt + 向左箭头 ：所选区域向左扩展一位。 转移 + Alt + 向上箭头 ：选定区域向上扩展一个位置。 转移 + Alt + 向下箭头 ：所选区域向下扩展一位。 当编辑器窗口因文本行过长而出现滚动条时，您可以通过滚动鼠标滚轮的同时按住 转移 钥匙。 按住鼠标滚轮可以放大编辑器窗口 控制键 钥匙。 编辑器的行为（例如括号、鼠标操作、选项卡）和外观在 CODESYS 中的选项 文本编辑器 类别。 要在编辑器中增量搜索字符串，请通过组合键在编辑器底部边缘打开一个输入字段 Ctrl + 转移 + 一世 .一旦您开始输入字符，相应的搜索位置就会在编辑器中以颜色突出显示。找到的匹配数显示在输入字段的右侧。您可以使用箭头键或组合键将光标设置在搜索位置 Alt + 向上翻页 或者 Alt + 向下翻页 . 当您将光标放在符号名称上时，该符号在编辑器中的所有出现位置都会以颜色突出显示。搜索位置对应于 交叉引用列表 .对于非常大的项目，这可能会导致输入延迟。在这种情况下，您可以在文本编辑器的选项中禁用该功能。 CODESYS 在编辑器中输入时已经识别出语法错误，并在 消息视图 ( 预编译 类别）。如果选择了相应的选项 CODESYS 选项 （ 智能编码 类别），则文本中的错误位置也用波浪形红线下划线。 " }, 
{ "title" : "在线模式下的 ST 编辑器 ", 
"url" : "_cds_st_editor_in_online_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 在线模式下的 ST 编辑器 ", 
"snippet" : "在在线模式下， CODESYS 在 ST 编辑器中显示变量和表达式 ( 价值监控）。 这 书写和强迫 变量和表达式以及 调试 功能（断点、单步处理）和 流量控制 也是可能的。 如果你使用作业作为 表达式 在 ST 编程中，一行内不再创建断点位置。...", 
"body" : "在在线模式下， CODESYS 在 ST 编辑器中显示变量和表达式 ( 价值监控）。 这 书写和强迫 变量和表达式以及 调试 功能（断点、单步处理）和 流量控制 也是可能的。 如果你使用作业作为 表达式 在 ST 编程中，一行内不再创建断点位置。 " }, 
{ "title" : "ST 表达式 ", 
"url" : "_cds_st_expressions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ ST 表达式 ", 
"snippet" : "表达式是一种在求值后返回值的构造。 表达式由运算符和操作数组成。在 扩展结构化文本 (ExST) ，您还可以使用赋值作为表达式。 操作数可以是常量、变量、函数调用或其他表达式。 特殊的 ST 表达式还有： 使用权 到 数组变量的元素 结构变量的组成部分 功能块实例或程序的变量 方法调用 例子 2014 常量、字面量 ivar 多变的 fct(a,b) 函数调用 (x*y)\/z 表达 real_var2 := int.var; 在 ExST 中：分配...", 
"body" : "表达式是一种在求值后返回值的构造。 表达式由运算符和操作数组成。在 扩展结构化文本 (ExST) ，您还可以使用赋值作为表达式。 操作数可以是常量、变量、函数调用或其他表达式。 特殊的 ST 表达式还有： 使用权 到 数组变量的元素 结构变量的组成部分 功能块实例或程序的变量 方法调用 例子 2014 常量、字面量 ivar 多变的 fct(a,b) 函数调用 (x*y)\/z 表达 real_var2 := int.var; 在 ExST 中：分配 " }, 
{ "title" : "表达式的求值 ", 
"url" : "_cds_st_expressions.html#UUID-60e5105f-e6ee-c431-74b7-012ca1a132d4_id_d5c8c87f0b362c0a8640e007534c3_id_e52a54881e8f8d57c0a8640e01163600", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ ST 表达式 \/ 表达式的求值 ", 
"snippet" : "表达式的求值是通过处理 运营商 根据具体的绑定规则。 CODESYS 首先处理具有最强绑定的运算符。具有相同结合强度的运算符从左到右处理。 手术 象征 结合强度 包围曝光 ( <表达式> ) 最强结合力 函数调用 <函数名称> ( <参数列表> ) 所有运算符的语法： <操作符> () 求幂 EXPT 否定 互补 - NOT 乘法 分配 模数 * \/ MOD 添加 减法 + - 比较 < , > , <= , >= 平等 不等式 = <> 布尔与 AND , AND_THEN 布尔异或 布尔或 XOR OR , OR_ELSE 最弱结合...", 
"body" : "表达式的求值是通过处理 运营商 根据具体的绑定规则。 CODESYS 首先处理具有最强绑定的运算符。具有相同结合强度的运算符从左到右处理。 手术 象征 结合强度 包围曝光 ( <表达式> ) 最强结合力 函数调用 <函数名称> ( <参数列表> ) 所有运算符的语法： <操作符> () 求幂 EXPT 否定 互补 - NOT 乘法 分配 模数 * \/ MOD 添加 减法 + - 比较 < , > , <= , >= 平等 不等式 = <> 布尔与 AND , AND_THEN 布尔异或 布尔或 XOR OR , OR_ELSE 最弱结合 " }, 
{ "title" : "作业 ", 
"url" : "_cds_st_f_assignments.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 作业 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ST 赋值运算符 ", 
"url" : "_cds_st_operator_assignment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 作业 \/ ST 赋值运算符 ", 
"snippet" : "句法： <operand> := <expression> 此赋值运算符执行与 移动 操作员。...", 
"body" : "句法： <operand> := <expression> 此赋值运算符执行与 移动 操作员。 " }, 
{ "title" : "输出的 ST 赋值运算符 ", 
"url" : "_cds_st_operator_output_assignment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 作业 \/ 输出的 ST 赋值运算符 ", 
"snippet" : "赋值运算符 => 将函数、功能块或方法的输出分配给变量。运算符右侧的位置也可以为空白。 句法 <output> => <variable> 例子 FBcomp_Output1 => bVar1; FBcomp_Output2 => ; FBcom_Output1 和 FB_Output2 是功能块的输出。的价值 FBcom_Output1 分配给变量 bVar1 ....", 
"body" : "赋值运算符 => 将函数、功能块或方法的输出分配给变量。运算符右侧的位置也可以为空白。 句法 <output> => <variable> 例子 FBcomp_Output1 => bVar1;\nFBcomp_Output2 => ; FBcom_Output1 和 FB_Output2 是功能块的输出。的价值 FBcom_Output1 分配给变量 bVar1 . " }, 
{ "title" : "ExST 分配：S= ", 
"url" : "_cds_exst_operator_s.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 作业 \/ ExST 分配：S= ", 
"snippet" : "当 Set 分配的操作数切换到 TRUE ， 然后 TRUE 分配给运算符左侧的变量。变量已设置。 <variable name> S= <operand name> ; 变量和操作数具有数据类型 BOOL . 例子 PROGRAM PLC_PRG VAR xOperand: BOOL := FALSE; xSetVariable: BOOL := FALSE; END_VAR xSetVariable S= xOperand; 当操作数 xOperand 从切换 FALSE 到 TRUE ， 然后 TRUE 也分配给变量 xSetVariable .但是变量保持这个状态，即使操作数继续改变它...", 
"body" : "当 Set 分配的操作数切换到 TRUE ， 然后 TRUE 分配给运算符左侧的变量。变量已设置。 <variable name> S= <operand name> ; 变量和操作数具有数据类型 BOOL . 例子 PROGRAM PLC_PRG\nVAR\n xOperand: BOOL := FALSE;\n xSetVariable: BOOL := FALSE;\nEND_VAR\n\nxSetVariable S= xOperand; 当操作数 xOperand 从切换 FALSE 到 TRUE ， 然后 TRUE 也分配给变量 xSetVariable .但是变量保持这个状态，即使操作数继续改变它的状态。 " }, 
{ "title" : "多项任务 ", 
"url" : "_cds_exst_operator_s.html#UUID-3e454082-8249-f217-17c5-ea427ca5ffa0_id_c050b3abf83e2bc0a8640e009a32a5_id_3abde2ab930da820c0a8646307965b6a", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 作业 \/ ExST 分配：S= \/ 多项任务 ", 
"snippet" : "在代码行内有多个赋值的情况下，单个赋值不是从右到左处理的，而是所有赋值都引用代码行末尾的操作数。 例子 FUNCTION funCompute : BOOL VAR_INPUT xIn : BOOL; END_VAR IF xIn = TRUE THEN funCompute := TRUE; RETURN; END_IF PROGRAM PLC_PRG VAR xSetVariable: BOOL; xResetVariable: BOOL := TRUE; xVar: BOOL; END_VAR xSetVariable S= xResetVariable R= funCompute(xI...", 
"body" : "在代码行内有多个赋值的情况下，单个赋值不是从右到左处理的，而是所有赋值都引用代码行末尾的操作数。 例子 FUNCTION funCompute : BOOL\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nIF xIn = TRUE THEN\n funCompute := TRUE;\n RETURN;\nEND_IF\n\nPROGRAM PLC_PRG\nVAR\n xSetVariable: BOOL;\n xResetVariable: BOOL := TRUE;\n xVar: BOOL;\nEND_VAR\nxSetVariable S= xResetVariable R= funCompute(xIn := xVar); xResetVariable 得到 R= 返回值的赋值 funCompute . xSetVariable 得到 S= ht 返回值的赋值 funCompute ，但不是从 xResetVariable . " }, 
{ "title" : "ExST 分配：R= ", 
"url" : "_cds_exst_operator_r.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 作业 \/ ExST 分配：R= ", 
"snippet" : "当复位分配的操作数切换到 TRUE ， 然后 FALSE 分配给运算符左侧的变量。变量被重置。 <variable name> R= <operand name> ; 变量和操作数具有数据类型 BOOL . 例子 VAR xOperand: BOOL := FALSE; xResetVariable: BOOL := TRUE; END_VAR xResetVariable R= xOperand; 当操作数 xOperand 从切换 FALSE 到 TRUE ， 然后 FALSE 也分配给变量 xResetVariable .但随后变量保持其状态，即使操作数继续改变其状态。...", 
"body" : "当复位分配的操作数切换到 TRUE ， 然后 FALSE 分配给运算符左侧的变量。变量被重置。 <variable name> R= <operand name> ; 变量和操作数具有数据类型 BOOL . 例子 VAR\n xOperand: BOOL := FALSE;\n xResetVariable: BOOL := TRUE;\nEND_VAR\n\nxResetVariable R= xOperand; 当操作数 xOperand 从切换 FALSE 到 TRUE ， 然后 FALSE 也分配给变量 xResetVariable .但随后变量保持其状态，即使操作数继续改变其状态。 " }, 
{ "title" : "多项任务 ", 
"url" : "_cds_exst_operator_r.html#UUID-1891bf0f-9a33-b0eb-d3ff-5838f6d073d1_id_d90635bdac550e0ac0a8640e010769d8_id_e67e66ad930a59e8c0a86463664c9b5c", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 作业 \/ ExST 分配：R= \/ 多项任务 ", 
"snippet" : "在代码行内有多个赋值的情况下，单个赋值不是从右到左处理的，而是所有赋值都引用代码行末尾的操作数。 例子 FUNCTION funCompute : BOOL VAR_INPUT xIn : BOOL; END_VAR IF xIn = TRUE THEN funCompute := TRUE; RETURN; END_IF PROGRAM PLC_PRG VAR xSetVariable: BOOL; xResetVariable: BOOL := TRUE; xVar: BOOL; END_VAR xSetVariable S= xResetVariable R= funCompute(xI...", 
"body" : "在代码行内有多个赋值的情况下，单个赋值不是从右到左处理的，而是所有赋值都引用代码行末尾的操作数。 例子 FUNCTION funCompute : BOOL\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nIF xIn = TRUE THEN\n funCompute := TRUE;\n RETURN;\nEND_IF\n\nPROGRAM PLC_PRG\nVAR\n xSetVariable: BOOL;\n xResetVariable: BOOL := TRUE;\n xVar: BOOL;\nEND_VAR\nxSetVariable S= xResetVariable R= funCompute(xIn := xVar); xResetVariable 得到 R= 返回值的赋值 funCompute . xSetVariable 得到 S= ht 返回值的赋值 funCompute ，但不是从 xResetVariable . " }, 
{ "title" : "ExST 赋值作为表达式 ", 
"url" : "_cds_exst_operator_expression.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 作业 \/ ExST 赋值作为表达式 ", 
"snippet" : "在 ExST ，作为对 IEC 61131-3 标准的扩展， CODESYS 允许使用赋值作为表达式。 例子 int_var1 := int_var2 := int_var3 + 9; (* int_var1 和 int_var2 接收价值 int_var3 + 9 *) real_var1 := real_var2 := int_var; (* real_var1 和 real_var2 获得价值 int_var *) int_var := real_var1 := int_var; (* 赋值错误，数据类型不对应 *) IF b := (i = 1) THEN i := i + 1; EN...", 
"body" : "在 ExST ，作为对 IEC 61131-3 标准的扩展， CODESYS 允许使用赋值作为表达式。 例子 int_var1 := int_var2 := int_var3 + 9; (* int_var1 和 int_var2 接收价值 int_var3 + 9 *) real_var1 := real_var2 := int_var; (* real_var1 和 real_var2 获得价值 int_var *) int_var := real_var1 := int_var; (* 赋值错误，数据类型不对应 *) IF b := (i = 1) THEN i := i + 1; END_IF " }, 
{ "title" : "赋值运算符： REF= ", 
"url" : "_cds_ref_assignment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 作业 \/ 赋值运算符： REF= ", 
"snippet" : "操作员生成一个 参考 （指针）指向一个值。 句法： <variable name> REF= <variable name> ; 例子 refA : REFERENCE TO DUT; B : DUT; C : DUT; A REF= B; \/\/ corresponds to A := ADR(B); A := C; \/\/ corresponds to A^ := C;...", 
"body" : "操作员生成一个 参考 （指针）指向一个值。 句法： <variable name> REF= <variable name> ; 例子 refA : REFERENCE TO DUT;\nB : DUT;\nC : DUT;\n\nA REF= B; \/\/ corresponds to A := ADR(B);\nA := C; \/\/ corresponds to A^ := C; " }, 
{ "title" : "声明 ", 
"url" : "_cds_st_f_instructions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 声明 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ST 声明：IF ", 
"url" : "_cds_st_instruction_if.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 声明 \/ ST 声明：IF ", 
"snippet" : "IF 这 IF 语句用于检查条件，并根据该条件执行后续语句。 条件编码为 表达 返回一个布尔值。如果表达式返回 TRUE , 则条件成立并执行相应的语句 THEN .如果表达式返回 FALSE ，然后是以下条件，它们被标识为 ELSIF , 被评估。如果 ELSIF 条件返回 TRUE ，则语句在相应的之后执行 THEN .如果所有条件都返回 FALSE , 然后语句在之后执行 ELSE . 因此，最多只有一个分支 IF 语句被执行。 ELSIF 分支机构和 ELSE 分支是可选的。 句法 IF <condition> THEN <statements> ( ELSIF <condition>...", 
"body" : "IF 这 IF 语句用于检查条件，并根据该条件执行后续语句。 条件编码为 表达 返回一个布尔值。如果表达式返回 TRUE , 则条件成立并执行相应的语句 THEN .如果表达式返回 FALSE ，然后是以下条件，它们被标识为 ELSIF , 被评估。如果 ELSIF 条件返回 TRUE ，则语句在相应的之后执行 THEN .如果所有条件都返回 FALSE , 然后语句在之后执行 ELSE . 因此，最多只有一个分支 IF 语句被执行。 ELSIF 分支机构和 ELSE 分支是可选的。 句法 IF <condition> THEN\n <statements>\n( ELSIF <condition> THEN\n <statements> )*\n( ELSE\n <statements> )?\nEND_IF;\n\/\/ ( ... )* None, once or several times\n\/\/ ( ... )? Optional 例子 PROGRAM PLC_PRG\nVAR\n iTemp: INT;\n xHeatingOn: BOOL;\n xOpenWindow: BOOL;\nEND_VAR\n\nIF iTemp < 17 THEN\n xHeatingOn := TRUE;\nELSIF iTemp > 25 THEN\n xOpenWindow := TRUE;\nELSE xHeatingOn := FALSE;\nEND_IF; 该程序在运行时运行如下： 对于表达式的评估 iTemp < 17 = TRUE ，执行后续语句，开启加热。对于表达式的评估 iTemp < 17 = FALSE , 随后 ELSIF 状况 iTemp > 25 被评估。如果这是真的，那么中的陈述 ELSIF 执行并打开视图。如果所有条件都满足 FALSE , 然后语句在 ELSE 并且加热被关闭。 " }, 
{ "title" : "ST 声明：FOR ", 
"url" : "_cds_st_instruction_for.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 声明 \/ ST 声明：FOR ", 
"snippet" : "FOR 这 FOR 循环用于执行具有一定重复次数的语句。 句法： FOR <counter> := <start value> TO <end value> {BY <increment> } DO <instructions> END_FOR; 花括号 {} 内的部分是可选的。 CODESYS 执行 <instructions> 只要 <counter> 不大于 - 或在负数的情况下 increment 步小于 - 的 <end value> .这是在执行之前检查的 <instructions> . 每次 <instructions> 语句已执行，计数器 <counter> 按增量自动增加 ...", 
"body" : "FOR 这 FOR 循环用于执行具有一定重复次数的语句。 句法： FOR <counter> := <start value> TO <end value> {BY <increment> } DO\n <instructions>\nEND_FOR; 花括号 {} 内的部分是可选的。 CODESYS 执行 <instructions> 只要 <counter> 不大于 - 或在负数的情况下 increment 步小于 - 的 <end value> .这是在执行之前检查的 <instructions> . 每次 <instructions> 语句已执行，计数器 <counter> 按增量自动增加 <increment> .增量 <increment> 可以有任何整数值。如果不指定增量，则标准增量为 1 . 例子 FOR iCounter := 1 TO 5 BY 1 DO\n iVar1 := iVar1*2;\nEND_FOR;\nErg := iVar1; 如果您已预先配置 iVar1 和 1 , iVar1 有价值 32 在 FOR 循环之后。 结束值 <end value> 不得与计数器的数据类型上限相同。 如果计数器的结束值等于计数器的数据类型的上限，则导致无限循环。例如，一个无限循环会导致上面的例子，如果 iCounter 属于数据类型 SINT 和 <end value> 等于 127 , 因为数据类型 SINT 有上限 127 . 作为 IEC 61131-3 标准的扩展，您可以使用 继续 内的声明 FOR 环形。 " }, 
{ "title" : "ST 声明：CASE ", 
"url" : "_cds_st_instruction_case.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 声明 \/ ST 声明：CASE ", 
"snippet" : "CASE CASE 语句是一种条件控制结构，它使语句或语句的一部分仅在特定条件下执行。通过比较条件和标签来确定执行的部分。 句法： CASE <condition> OF <label-1> : <instruction-1> <label-2> : <instruction-2> <label-3, label-4, label-5> : <instruction-3> <label-6 .. labe-10> : <instruction-4> <label-n> : <instruction-n> ELSE <ELSE-instruction> END_CASE 状况 条件的整数变量 例...", 
"body" : "CASE CASE 语句是一种条件控制结构，它使语句或语句的一部分仅在特定条件下执行。通过比较条件和标签来确定执行的部分。 句法： CASE <condition> OF\n <label-1> : \n <instruction-1>\n <label-2> : \n <instruction-2>\n <label-3, label-4, label-5> : \n <instruction-3>\n <label-6 .. labe-10> : \n <instruction-4>\n <label-n> : \n <instruction-n>\n ELSE <ELSE-instruction>\nEND_CASE 状况 条件的整数变量 例子： iCondition 变量的值与构造中声明的标签进行比较。 CASE 语句中可以使用任意数量的标签（最少：2）。否则，可以使用 IF-THEN-ELSE 结构更清楚地显示该结构。 所有标签必须具有不同的值。 标签-n 与条件具有相同数据类型的常量、文字或常量表达式 充当 CASE 构造中的标签（跳转目标）。 例子： 1 , 5 , c_ONE , c_TWO 如果该值等于 状况 ，则运行下面的语句。 如果该值不等于 状况 ，则忽略相应的语句，系统跳转到下一个标签。 < 标签-n >, < 标签-n1 > 带有多个标签的逗号分隔列表，用作跳转目标 例子： 1, 5 如果其中一个标签符合条件 状况 ，然后运行下面的部分。 < 标签-n1 >..< 标签-n2 > 带下限和上限标签的范围 10..20 如果条件 状况 取以下范围内的值 标签-n1 到 标签-n2 ，然后运行下面的部分。 ELSE 可选，最多一次 默认跳转目标，如果所有先前的标签都跳转到 不要 符合条件。 指令n ELSE指令 语句，或由多个语句组成的语句段 语句始终以分号 ( ; ）。 例子 CASE iCondition OF\n 1, 5, c_ONE, C_TWO: \n bVar1 := TRUE;\n bVar3 := FALSE;\n 2: \n bVar2 := FALSE;\n bVar3 := TRUE;\n 10..20: \n bVar1 := TRUE;\n bVar3 := TRUE;\n ELSE\n bVar1 := NOT bVar1;\n bVar2 := bVar1 OR bVar2;\nEND_CASE " }, 
{ "title" : "ST 声明：WHILE ", 
"url" : "_cds_st_instruction_while.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 声明 \/ ST 声明：WHILE ", 
"snippet" : "WHILE 这 WHILE 循环像 为了 循环以多次执行语句，直到出现中止条件。 a 的中止条件 WHILE 循环是一个布尔表达式。 句法： WHILE <boolean expression> DO <instructions> END_WHILE; CODESYS 反复执行 <instructions> 只要声明 <Boolean expression> 返回真。如果布尔表达式已经 FALSE 在第一次评估时，然后 CODESYS 从不执行语句。如果布尔表达式从不应用该值 FALSE ，然后这些语句会无休止地重复，从而导致运行时错误。 例子 WHILE iCounter <> 0 DO V...", 
"body" : "WHILE 这 WHILE 循环像 为了 循环以多次执行语句，直到出现中止条件。 a 的中止条件 WHILE 循环是一个布尔表达式。 句法： WHILE <boolean expression> DO\n <instructions>\nEND_WHILE; CODESYS 反复执行 <instructions> 只要声明 <Boolean expression> 返回真。如果布尔表达式已经 FALSE 在第一次评估时，然后 CODESYS 从不执行语句。如果布尔表达式从不应用该值 FALSE ，然后这些语句会无休止地重复，从而导致运行时错误。 例子 WHILE iCounter <> 0 DO\n Var1 := Var1*2\n iCounter := iCounter-1;\nEND_WHILE; 您必须使用编程来确保不会导致无限循环。 从某种意义上说 WHILE 和 重复 循环比 FOR 循环更强大，因为您不需要在执行之前知道循环的执行次数。因此，在某些情况下，只能使用这两种循环。但是，如果循环执行的次数是明确的，那么 FOR 最好使用循环以避免无限循环。 作为 IEC 61131-3 标准的扩展，您可以使用 继续 WHILE 循环中的语句。 " }, 
{ "title" : "ST 声明：REPEAT ", 
"url" : "_cds_st_instruction_repeat.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 声明 \/ ST 声明：REPEAT ", 
"snippet" : "REPEAT 这 REPEAT 循环像 尽管 循环，但不同的是 CODESYS 仅在执行循环后检查中止条件。这种行为的后果是 REPEAT 循环至少执行一次，无论中止条件如何。 句法： REPEAT <instructions> UNTIL <boolean expression> END_REPEAT; CODESYS 执行 <instructions> 声明直到 <Boolean expression> 返回真。 如果布尔表达式已经返回 TRUE 在第一次评估中， CODESYS 只执行一次语句。如果布尔表达式从不应用该值 TRUE ，然后这些语句会无休止地重复，从而导致运行时错误。 例子...", 
"body" : "REPEAT 这 REPEAT 循环像 尽管 循环，但不同的是 CODESYS 仅在执行循环后检查中止条件。这种行为的后果是 REPEAT 循环至少执行一次，无论中止条件如何。 句法： REPEAT\n <instructions>\nUNTIL <boolean expression>\nEND_REPEAT; CODESYS 执行 <instructions> 声明直到 <Boolean expression> 返回真。 如果布尔表达式已经返回 TRUE 在第一次评估中， CODESYS 只执行一次语句。如果布尔表达式从不应用该值 TRUE ，然后这些语句会无休止地重复，从而导致运行时错误。 例子 REPEAT\n Var1 := Var1*2;\n iCounter := iCounter-1;\nUNTIL\n iCounter = 0\nEND_REPEAT; 从某种意义上说 WHILE 和 REPEAT 循环比 为了 循环，因为在执行之前不需要知道循环的执行次数。在某些情况下，您只能使用这两种循环。但是，如果循环执行的次数是明确的，那么 FOR 最好使用循环以避免无限循环。 作为 IEC 61131-3 标准的扩展，您可以使用 继续 内的声明 WHILE 环形。 " }, 
{ "title" : "ST 声明：RETURN ", 
"url" : "_cds_st_instruction_return.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 声明 \/ ST 声明：RETURN ", 
"snippet" : "RETURN 使用 RETURN 语句以从功能块中退出。你可以让它依赖于一个 状况 ， 例如。 例子 IF xIsDone THEN RETURN; END_IF; iCounter := iCounter + 1; 如果值 xIsDone 等于 TRUE ，则功能块立即退出，语句 iCounter := iCounter + 1; 不执行。 因为 RETURN statement也支持条件返回，上面的例子也可以这样描述。 RETURN (xIsDone); iCounter := iCounter + 1;...", 
"body" : "RETURN 使用 RETURN 语句以从功能块中退出。你可以让它依赖于一个 状况 ， 例如。 例子 IF xIsDone THEN\n RETURN;\nEND_IF;\n\niCounter := iCounter + 1; 如果值 xIsDone 等于 TRUE ，则功能块立即退出，语句 iCounter := iCounter + 1; 不执行。 因为 RETURN statement也支持条件返回，上面的例子也可以这样描述。 RETURN (xIsDone);\niCounter := iCounter + 1; " }, 
{ "title" : "ST 声明：JMP ", 
"url" : "_cds_st_instruction_jmp.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 声明 \/ ST 声明：JMP ", 
"snippet" : "JMP 这 JMP 语句用于执行无条件跳转到由跳转标签标记的程序行。 句法： <label>: <instructions> JMP <label>; 跳跃标签 <label> 是您放置在程序行开头的任何唯一标识符。在达到 JMP 语句，返回到程序行 <label> 发生。 例子 iVar1 := 0; _label1: iVar1 := iVar1+1; (*instructions*) IF (iVar1 < 10) THEN JMP _label1; END_IF; 您必须使用编程来确保不会导致无限循环。例如，您可以使跳转成为有条件的。...", 
"body" : "JMP 这 JMP 语句用于执行无条件跳转到由跳转标签标记的程序行。 句法： <label>: <instructions>\n\nJMP <label>; 跳跃标签 <label> 是您放置在程序行开头的任何唯一标识符。在达到 JMP 语句，返回到程序行 <label> 发生。 例子 iVar1 := 0;\n\n_label1: iVar1 := iVar1+1;\n\n(*instructions*)\n\nIF (iVar1 < 10) THEN\n JMP _label1;\nEND_IF; 您必须使用编程来确保不会导致无限循环。例如，您可以使跳转成为有条件的。 " }, 
{ "title" : "ST 声明：EXIT ", 
"url" : "_cds_st_instruction_exit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 声明 \/ ST 声明：EXIT ", 
"snippet" : "EXIT 这 EXIT 语句用于 为了 环形， 尽管 循环，或 重复 循环以结束循环，而不管其他中止条件。...", 
"body" : "EXIT 这 EXIT 语句用于 为了 环形， 尽管 循环，或 重复 循环以结束循环，而不管其他中止条件。 " }, 
{ "title" : "EXST 语句：继续 ", 
"url" : "_cds_exst_instruction_continue.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 声明 \/ EXST 语句：继续 ", 
"snippet" : "CONTINUE CONTINUE 是扩展结构化文本 (ExST) 的声明。 该语句在一个内部使用 为了 环形， 尽管 循环，或 重复 循环以便跳转到下一次循环执行的开始处。 例子 FOR Counter:=1 TO 5 BY 1 DO INT1:=INT1\/2; IF INT1=0 THEN CONTINUE; (* to avoid a division by zero *) END_IF Var1:=Var1\/INT1; (* executed, if INT1 is not 0 *) END_FOR; Erg:=Var1;...", 
"body" : "CONTINUE CONTINUE 是扩展结构化文本 (ExST) 的声明。 该语句在一个内部使用 为了 环形， 尽管 循环，或 重复 循环以便跳转到下一次循环执行的开始处。 例子 FOR Counter:=1 TO 5 BY 1 DO\n\nINT1:=INT1\/2;\n\nIF INT1=0 THEN\n\n CONTINUE; (* to avoid a division by zero *)\n\nEND_IF\n\nVar1:=Var1\/INT1; (* executed, if INT1 is not 0 *)\n\nEND_FOR;\n\nErg:=Var1; " }, 
{ "title" : "ST 功能块调用 ", 
"url" : "_cds_st_fb_call.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 声明 \/ ST 功能块调用 ", 
"snippet" : "调用一个 功能块 在意法半导体 句法 <FB instance>(<FB input variable>:=<value or address>\\|, <other FB input variables>); 例子 TMR:TON; TMR (IN:=%OX5, PT:=T#300ms); varA:=TMR.Q; 定时器功能块 TON 被实例化在 TMR:TON 并用参数赋值调用 IN 和 PT . 输出 Q 解决了 TMR.Q 并赋值给变量 varA ....", 
"body" : "调用一个 功能块 在意法半导体 句法 <FB instance>(<FB input variable>:=<value or address>\\|, <other FB input variables>); 例子 TMR:TON;\n\nTMR (IN:=%OX5, PT:=T#300ms);\nvarA:=TMR.Q; 定时器功能块 TON 被实例化在 TMR:TON 并用参数赋值调用 IN 和 PT . 输出 Q 解决了 TMR.Q 并赋值给变量 varA . " }, 
{ "title" : "ST 评论 ", 
"url" : "_cds_st_comment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编程语言和编辑器 \/ 结构化文本和扩展结构化文本 (ExST) \/ 声明 \/ ST 评论 ", 
"snippet" : "评论 描述 例子 单线 有两种标记方式： 以。。开始 \/\/ 并在行尾结束 以。。开始 \/\/\/ 并在行尾结束 在 CODESYS , 这些评论的处理方式相同。 但是，如果库文档是使用 LibDoc 脚本集合创建的，则适用以下情况： 当财产 LibDocContent = DocsOnly 在项目信息中输入，只有注释标记为 \/\/\/ 被处理成图书馆文档。请参阅表下方的示例。 什么时候 LibDocContent = CommentsAndDocs （默认设置）已定义，所有注释都被处理成库文档。 \/\/\/ This is a comment \/\/\/ This is a comment 多行 以。。开始 ...", 
"body" : "评论 描述 例子 单线 有两种标记方式： 以。。开始 \/\/ 并在行尾结束 以。。开始 \/\/\/ 并在行尾结束 在 CODESYS , 这些评论的处理方式相同。 但是，如果库文档是使用 LibDoc 脚本集合创建的，则适用以下情况： 当财产 LibDocContent = DocsOnly 在项目信息中输入，只有注释标记为 \/\/\/ 被处理成图书馆文档。请参阅表下方的示例。 什么时候 LibDocContent = CommentsAndDocs （默认设置）已定义，所有注释都被处理成库文档。 \/\/\/ This is a comment \/\/\/ This is a comment 多行 以。。开始 (* 并以 *) . (* This is a multiline comment *) 嵌套 开始于 (* 并以 *) 。其他评论 (*....*) 可以包含在此评论中。 ( * a:=inst.out; (* comment 1 *) b:=b+1; (* comment 2 *) *) 在联机模式下，注释作为变量信息显示在变量声明的注释列中，当鼠标指针放在变量上方时，也会显示在工具提示中。以下逻辑和优先级排序适用 当评论以开头时 \/\/\/ 在变量之前，显示此注释。 当评论以开头时 \/\/ 或者在里面 (**) 在同一行变量声明之后，显示此注释 当评论以开头时 \/\/ 或者在里面 (**) 在同一行中的变量声明之前，显示此注释 如果评论由于长度而无法在联机模式下完整显示，那么 符号显示在此注释字段中。然后将光标置于该符号上方时，完整的注释将显示在工具提示中 工具提示和 POU 文档的注释 A tooltip in the header of a POU is defined by the following comment:\n \/\/ tooltip text – line 1\n \/\/ tooltip text – line 2\n \/\/ tooltip text – line 3\n\n Afterwards the documentation is defined as follows:\n \/\/\/ reStructuredText 注意：不同的注释类型可用于控制哪些注释应显示在库的文档中，以及哪些注释仅供库开发人员使用。 " }, 
{ "title" : "变量 ", 
"url" : "_cds_struct_reference_variable_types.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 ", 
"snippet" : "变量的范围定义了如何以及在何处使用变量。您在变量声明中定义范围。...", 
"body" : "变量的范围定义了如何以及在何处使用变量。您在变量声明中定义范围。 " }, 
{ "title" : "变量：VAR ", 
"url" : "_cds_vartypes_var.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：VAR ", 
"snippet" : "VAR 局部变量在关键字之间声明 VAR 和 END_VAR 在编程对象的声明部分。您对局部变量具有只读访问权限（外部通过实例路径）。 该变量可以使用属性关键字 ( CONSTANT , RETAIN ， 或者 PERSISTENT ）。 例子 VAR iVar1 : INT; END_VAR...", 
"body" : "VAR searchresult_toplevel 局部变量在关键字之间声明 VAR 和 END_VAR 在编程对象的声明部分。您对局部变量具有只读访问权限（外部通过实例路径）。 该变量可以使用属性关键字 ( CONSTANT , RETAIN ， 或者 PERSISTENT ）。 例子 VAR\n iVar1 : INT;\nEND_VAR " }, 
{ "title" : "变量：VAR_INPUT ", 
"url" : "_cds_vartypes_var_input.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：VAR_INPUT ", 
"snippet" : "VAR_INPUT 输入变量用于功能块的输入。你声明 VAR_INPUT 之间的变量 VAR_INPUT 和 END_VAR POU 声明部分中的关键字。调用时，仅传递值（按值传递）。 该变量可以使用属性关键字 ( CONSTANT , RETAIN ， 或者 PERSISTENT ）。 例子 VAR_INPUT iIn1 : INT; (* 1st input variable *) END_VAR...", 
"body" : "VAR_INPUT 输入变量用于功能块的输入。你声明 VAR_INPUT 之间的变量 VAR_INPUT 和 END_VAR POU 声明部分中的关键字。调用时，仅传递值（按值传递）。 该变量可以使用属性关键字 ( CONSTANT , RETAIN ， 或者 PERSISTENT ）。 例子 VAR_INPUT\n iIn1 : INT; (* 1st input variable *)\nEND_VAR " }, 
{ "title" : "变量：VAR_OUTPUT ", 
"url" : "_cds_vartypes_var_output.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：VAR_OUTPUT ", 
"snippet" : "VAR_OUTPUT 输出变量用于功能块的输出。你声明 VAR_OUTPUT 之间的变量 VAR_OUTPUT 和 END_VAR POU 声明部分的关键字。这个变量的值被返回给调用 POU。您可以在那里检索值并继续使用它们。 可以使用属性关键字（ CONSTANT , RETAIN 要么 PERSISTENT ) 进行扩展。 例子 VAR_OUPUT iOut1 : INT; (*1st output variable *) END_VAR 函数和方法中的输出变量 根据 IEC 61131-3 标准，函数和方法具有附加输出。您必须在调用函数时分配这些额外的输出，如下所示。 例子 fun(iI...", 
"body" : "VAR_OUTPUT 输出变量用于功能块的输出。你声明 VAR_OUTPUT 之间的变量 VAR_OUTPUT 和 END_VAR POU 声明部分的关键字。这个变量的值被返回给调用 POU。您可以在那里检索值并继续使用它们。 可以使用属性关键字（ CONSTANT , RETAIN 要么 PERSISTENT ) 进行扩展。 例子 VAR_OUPUT\n iOut1 : INT; (*1st output variable *)\nEND_VAR 函数和方法中的输出变量 根据 IEC 61131-3 标准，函数和方法具有附加输出。您必须在调用函数时分配这些额外的输出，如下所示。 例子 fun(iIn1 := 1, iIn2 := 2, iOut1 => iLoc1, iOut2 => iLoc2); " }, 
{ "title" : "变量：VAR_IN_OUT ", 
"url" : "_cds_vartypes_var_in_out.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：VAR_IN_OUT ", 
"snippet" : "VAR_IN_OUT 一个 VAR_IN_OUT variable 是一个输入\/输出变量，它是 POU 接口的一部分，用作正式的按引用传递参数。 句法 <keyword> <POU name> VAR_IN_OUT <variable name> : <data type>; END_VAR <keyword> : FUNCTION | FUNCTION_BLOCK | METHOD | PRG 您可以在中声明输入\/输出变量 VAR_IN_OUT POU 中的声明部分 PRG , FUNCTION_BLOCK , METHOD ， 或者 FUNCTION 。这 VAR_IN_OUT 变量可以被...", 
"body" : "VAR_IN_OUT 一个 VAR_IN_OUT variable 是一个输入\/输出变量，它是 POU 接口的一部分，用作正式的按引用传递参数。 句法 <keyword> <POU name>\nVAR_IN_OUT\n <variable name> : <data type>;\nEND_VAR\n\n<keyword> : FUNCTION | FUNCTION_BLOCK | METHOD | PRG 您可以在中声明输入\/输出变量 VAR_IN_OUT POU 中的声明部分 PRG , FUNCTION_BLOCK , METHOD ， 或者 FUNCTION 。这 VAR_IN_OUT 变量可以被读取和写入。 用法 称呼 : 当一个 POU 被调用时，正式的 VAR_IN_OUT variable 接收实际变量（“按引用传递变量”）作为参数。在运行时，传递参数时不会生成副本。相反，形式变量接收对远程传递的实际变量的引用。引用变量在内部包含一个内存地址作为实际值的值（ 作为指针传递 , 调用参考 ）。不能直接指定常量（文字）或位变量作为参数。 POU 内的读\/写访问 : 如果变量被写入 POU 中，那么这会影响传递的变量。退出 POU 时，将保留任何已执行的更改。这意味着一个 POU 使用它的 VAR_IN_OUT 变量就像调用 POU 使用它的变量一样。始终允许读取访问。 远程读\/写访问 ： VAR_IN_OUT 变量 不能 通过远程直接读取或写入 <function block instance name>.<variable name> .这仅适用于 VAR_INPUT 和 VAR_OUTPUT 变量。 传递字符串变量 ：如果将字符串变量作为参数传递，那么实际变量和形式变量应该具有相同的长度。否则，传递的字符串可能会被无意中操作。在以下情况下不会出现此问题 VAR_OUTPUT CONSTANT 参数。 传递位变量 : 位变量不能直接传递给 VAR_IN_OUT 变量，因为它需要一个中间变量。 传递属性 ： 不允许 如果将字符串作为变量或常量传递给形式 VAR_IN_OUT CONSTANT 变量，则字符串自动完全传递。您不必检查字符串长度。 有关更多信息，请参阅： “VAR_IN_OUT CONSTANT”传输变量 例子 传递数组 TYPE DUT_A :\nSTRUCT\n xA: BOOL;\n iB: INT;\nEND_STRUCT\nEND_TYPE\n\nFUNCTION_BLOCK FB_SetArray\nVAR_IN_OUT\n aData_A : ARRAY[0..1] OF DUT_A; \/\/ Formal variable\nEND_VAR\naData_A[0].xA := TRUE;\naData_A[0].iB := 100;\n\nPROGRAM PLC_PRG\nVAR\n fbSetA : FB_SetArray;\n aSpecialData : ARRAY[0..1] OF DUT_A; \/\/ Actual variable\nEND_VAR\nfbSetA(aData_A := aSpecialData); 传递字符串 {attribute 'qualified_only'}\nVAR_GLOBAL\n g_sDEV_STATUS : STRING(25) := 'Device_A';\nEND_VAR\n\nFUNCTION_BLOCK FB_SetStatus\nVAR_IN_OUT\n sDeviceStatus : STRING(25); \/\/ Formal parameter\nEND_VAR\nsDeviceStatus := CONCAT(sDeviceStatus, ' Activ');\n\nPROGRAM PLC_PRG\nVAR\n fbDoB : FB_SetStatus;\nEND_VAR\nfbDoB(sDeviceStatus := GVL.g_sDEV_STATUS); \/\/Call with actual parameter 变量 sDeviceStatus 是 POU 接口的一部分 FB_B .打电话时 fbDoB ，首先将设备名称分配给字符串，然后对字符串进行操作。 传递位变量 VAR_GLOBAL\n xBit0 AT %MX0.1 : BOOL;\n xTemp : BOOL;\nEND_VAR\n\nFUNCTION_BLOCK FB_DoSomething\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nVAR_IN_OUT\n xInOut : BOOL;\nEND_VAR\nIF xIn THEN\n xInOut := TRUE;\nEND_IF\n\nPROGRAM PLC_PRG\nVAR\n xIn : BOOL;\n DoSomething_1 : FB_DoSomething;\n DoSomething_2 : FB_DoSomething;\nEND_VAR\n\n\/\/ The following line of code causes a compiler error:\n\/\/ C0201: Typ 'BIT' is not equal to type 'BOOL' of VAR_IN_OUT 'xInOut'\nDoSomething_1(xIn := xIn, xInOut := xBit0);\n\n\/\/ Workaround\nxTemp := xBit0;\nDoSomething_2(xIn := xIn, xInOut := xTemp);\nxBit0 := xTemp; 程序调用功能块实例 DoSomething_1 和 DoSomething_2 .由于位变量的直接赋值 xBit0 到 VAR_IN_OUT 输入时，会产生编译器错误 DoSomething_1 实例被调用。相反，调用 DoSomething_2 分配中间变量的实例是正确的代码。 " }, 
{ "title" : "转移变量 VAR_IN_OUT CONSTANT ", 
"url" : "_cds_vartypes_var_in_out.html#UUID-32134341-4b6c-acd3-aa57-48bb400d17e2_id_e5c8916dc25ffdfc0a8640e01bbaaae_id_dfbe41aa0aeae611c0a864633d68e93e", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：VAR_IN_OUT \/ 转移变量 VAR_IN_OUT CONSTANT ", 
"snippet" : "一个 VAR_IN_OUT CONSTANT 变量用作常量传递引用参数，一个 STRING 或者 WSTRING 可以传递类型变量或常量（字面量）。该参数可以读取，但不能写入。不允许转让财产。 语法声明 <keyword> <POU name> VAR_IN_OUT CONSTANT <variable name> : <data type>; \/\/ formal parameter END_VAR <keyword> : FUNCTION | FUNCTION_BLOCK | METHOD | PRG VAR_IN_OUT CONSTANT 声明变量时不分配初始化值。 用法 调用 POU 时...", 
"body" : "一个 VAR_IN_OUT CONSTANT 变量用作常量传递引用参数，一个 STRING 或者 WSTRING 可以传递类型变量或常量（字面量）。该参数可以读取，但不能写入。不允许转让财产。 语法声明 <keyword> <POU name>\nVAR_IN_OUT CONSTANT\n <variable name> : <data type>; \/\/ formal parameter\nEND_VAR\n<keyword> : FUNCTION | FUNCTION_BLOCK | METHOD | PRG VAR_IN_OUT CONSTANT 声明变量时不分配初始化值。 用法 调用 POU 时，一个 STRING 或者 WSTRING 可以传递常量变量或文字。因此，不允许写访问。 传递字符串常量的参数：常量的字符串长度可以是任意大小，字符串长度不依赖于 VAR_IN_OUT CONSTANT 变量。 如果 替换常量 选项被选中 项目 → 项目设置 在里面 编译选项 类别，然后传递具有基本数据类型的常量或具有基本数据类型的常量变量的参数会生成编译器错误。 编译器版本 >= 3.5.2.0 支持该变量。 例子 传递字符串常量和字符串变量的参数 FUNCTION funManipulate : BOOL\nVAR_IN_OUT\n sReadWrite : STRING(16); (* Can be read or written here in POU *)\n dwVarReadWrite : DWORD; (* Can be read or written here in POU *)\nEND_VAR\nVAR_IN_OUT CONSTANT\n c_sReadOnly : STRING(16); (* Constant string variable can only be read here in POU *)\nEND_VAR\n\nsReadWrite := 'String_from_POU';\ndwVarReadWrite := STRING_TO_DWORD(c_sReadOnly);\n\nPROGRAM PRG_A\nVAR\n sVarFits : STRING(16);\n sValFits : STRING(16) := '1234567890123456';\n dwVar: DWORD;\nEND_VAR\n\n\/\/ The following line of code causes the compiler error C0417:\n\/\/ C0417: VAR_IN_OUT parameter 'sReadWrite' needs a variable with write access as input.\nfunManipulate(sReadWrite:='1234567890123456', c_sReadOnly:='1234567890123456', dwVarReadWrite := dwVar);\n\n\/\/ Correct code\nfunManipulate(sReadWrite := sValFits, c_sReadOnly := '23', dwVarReadWrite := dwVar);\nfunManipulate(sReadWrite := sVarFits, c_sReadOnly := sValFits, dwVarReadWrite := dwVar); 在代码中，字符串被传递给 funManipulate 通过不同的功能 VAR_IN_OUT 变量。传递字符串文字时，将编译器错误输出到 VAR_IN_OUT 多变的。将常量变量传递给 VAR_IN_OUT CONSTANT 变量，即使传递字符串变量也会生成正确的代码。 " }, 
{ "title" : "变量：VAR_GLOBAL ", 
"url" : "_cds_vartypes_var_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：VAR_GLOBAL ", 
"snippet" : "VAR_GLOBAL 如果在块中声明的局部变量与全局变量同名，则它在块中具有优先权。 对于编译器版本 3.2.0.0 及更高版本， CODESYS 总是在局部 POU 变量之前初始化全局变量。 全局变量是在整个项目中被识别的变量、常量、外部或剩余变量。您在全局变量列表中或在关键字之间的编程对象的声明部分中声明全局变量 VAR_GLOBAL 和 END_VAR . 例子 VAR_GLOBAL g_iVar1 : INT; END_VAR 当您在变量名前加上一个点时，系统会识别一个全局变量（例如： .g_iVar1 ）。...", 
"body" : "VAR_GLOBAL 如果在块中声明的局部变量与全局变量同名，则它在块中具有优先权。 对于编译器版本 3.2.0.0 及更高版本， CODESYS 总是在局部 POU 变量之前初始化全局变量。 全局变量是在整个项目中被识别的变量、常量、外部或剩余变量。您在全局变量列表中或在关键字之间的编程对象的声明部分中声明全局变量 VAR_GLOBAL 和 END_VAR . 例子 VAR_GLOBAL\n g_iVar1 : INT;\nEND_VAR 当您在变量名前加上一个点时，系统会识别一个全局变量（例如： .g_iVar1 ）。 " }, 
{ "title" : "变量：VAR_TEMP ", 
"url" : "_cds_vartypes_var_temp.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：VAR_TEMP ", 
"snippet" : "VAR_TEMP 此功能是 IEC 61131-3 标准的扩展。 您在关键字之间本地声明临时变量 VAR_TEMP 和 END_VAR . VAR_TEMP 只能在程序和功能块中进行声明。 CODESYS 每次调用 POU 时初始化临时变量。 应用程序只能在程序块或功能块的实现部分访问临时变量。 VAR_TEMP iVarTmp1 : INT; (*1st temporary variable *) END_VAR...", 
"body" : "VAR_TEMP 此功能是 IEC 61131-3 标准的扩展。 您在关键字之间本地声明临时变量 VAR_TEMP 和 END_VAR . VAR_TEMP 只能在程序和功能块中进行声明。 CODESYS 每次调用 POU 时初始化临时变量。 应用程序只能在程序块或功能块的实现部分访问临时变量。 VAR_TEMP\n iVarTmp1 : INT; (*1st temporary variable *)\nEND_VAR " }, 
{ "title" : "变量：VAR_STAT ", 
"url" : "_cds_vartypes_var_stat.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：VAR_STAT ", 
"snippet" : "VAR_STAT 此功能是 IEC 61131-3 标准的扩展。 您可以在关键字之间局部声明静态变量 VAR_STAT 和 END_VAR 。静态变量在下载时初始化。 您只能从声明变量的命名空间内访问静态变量（如 C 中的静态变量）。但是当应用程序离开块时，静态变量会保留它们的值。例如，您可以使用静态变量作为函数调用的计数器。 该变量可以使用属性关键字进行扩展（ CONSTANT , RETAIN ， 或者  PERSISTENT ）。 例子 VAR_STAT iVarStat1 : INT; END_VAR...", 
"body" : "VAR_STAT 此功能是 IEC 61131-3 标准的扩展。 您可以在关键字之间局部声明静态变量 VAR_STAT 和 END_VAR 。静态变量在下载时初始化。 您只能从声明变量的命名空间内访问静态变量（如 C 中的静态变量）。但是当应用程序离开块时，静态变量会保留它们的值。例如，您可以使用静态变量作为函数调用的计数器。 该变量可以使用属性关键字进行扩展（ CONSTANT , RETAIN ， 或者  PERSISTENT ）。 例子 VAR_STAT\n iVarStat1 : INT;\nEND_VAR " }, 
{ "title" : "变量：VAR_EXTERNAL ", 
"url" : "_cds_vartypes_var_external.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：VAR_EXTERNAL ", 
"snippet" : "VAR_EXTERNAL 外部变量是“导入”到 POU 中的全局变量。 您在关键字之间声明这些变量 VAR_EXTERNAL 和 END_VAR .如果全局变量不存在，则会打印一条错误消息。 CODESYS 不需要您将全局变量声明为外部变量以便在 POU 中使用它。该关键字仅用于保持符合 IEC 61131-3。 句法 <POU keyword> <POU name> VAR_EXTERNAL <variable name> : <data type>; END_VAR 不允许初始化。 例子 FUNCTION_BLOCK FB_DoSomething VAR_EXTERNAL iVarExt1...", 
"body" : "VAR_EXTERNAL 外部变量是“导入”到 POU 中的全局变量。 您在关键字之间声明这些变量 VAR_EXTERNAL 和 END_VAR .如果全局变量不存在，则会打印一条错误消息。 CODESYS 不需要您将全局变量声明为外部变量以便在 POU 中使用它。该关键字仅用于保持符合 IEC 61131-3。 句法 <POU keyword> <POU name>\nVAR_EXTERNAL\n <variable name> : <data type>;\nEND_VAR 不允许初始化。 例子 FUNCTION_BLOCK FB_DoSomething\nVAR_EXTERNAL\n iVarExt1 : INT; (* 1st external variable *)\nEND_VAR " }, 
{ "title" : "变量：VAR_INST ", 
"url" : "_cds_vartypes_var_inst.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：VAR_INST ", 
"snippet" : "VAR_INST 这 VAR_INST 实例变量只允许在方法中使用。这种变量只能在方法内访问。您可以在方法的声明部分监控实例变量的变量值。 CODESYS 不保存 VAR_INST 方法变量在方法栈中，但在功能块实例的栈中。这意味着 VAR_INST 变量函数与功能块实例的其他变量一样，并且不会在每次调用方法时重新初始化。 该变量可以使用属性关键字 ( CONSTANT , RETAIN ， 或者 PERSISTENT ）。 例子 METHOD meth_last : INT VAR_INPUT iVar : INT; END_VAR VAR_INST iLast : INT := 0; EN...", 
"body" : "VAR_INST 这 VAR_INST 实例变量只允许在方法中使用。这种变量只能在方法内访问。您可以在方法的声明部分监控实例变量的变量值。 CODESYS 不保存 VAR_INST 方法变量在方法栈中，但在功能块实例的栈中。这意味着 VAR_INST 变量函数与功能块实例的其他变量一样，并且不会在每次调用方法时重新初始化。 该变量可以使用属性关键字 ( CONSTANT , RETAIN ， 或者 PERSISTENT ）。 例子 METHOD meth_last : INT\nVAR_INPUT\n iVar : INT;\nEND_VAR\nVAR_INST\n iLast : INT := 0;\nEND_VAR\nmeth_last := iLast;\niLast := iVar; " }, 
{ "title" : "变量：VAR_CONFIG ", 
"url" : "_cds_vartypes_var_config.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：VAR_CONFIG ", 
"snippet" : "VAR_CONFIG 配置变量将完整地址分配给在地址信息不完整的功能块中声明的变量，这些变量应该映射到设备 I\/O。 声明是在全局变量列表中进行的 VAR_CONFIG 和 END_VAR 具有完整实例路径和正确地址的关键字。这种全局变量列表称为“变量配置”。 例子 宣言 xLocIn 不完整的变量 %I* 功能块中的地址。 FUNCTION_BLOCK locio VAR xLocIn AT %I* : BOOL := TRUE; END_VAR 这 locio 功能块用于 PLC_PRG 程序。 PROGRAM PLC_PRG VAR locioVar1 : locio; END_VAR ...", 
"body" : "VAR_CONFIG 配置变量将完整地址分配给在地址信息不完整的功能块中声明的变量，这些变量应该映射到设备 I\/O。 声明是在全局变量列表中进行的 VAR_CONFIG 和 END_VAR 具有完整实例路径和正确地址的关键字。这种全局变量列表称为“变量配置”。 例子 宣言 xLocIn 不完整的变量 %I* 功能块中的地址。 FUNCTION_BLOCK locio\n\nVAR\n xLocIn AT %I* : BOOL := TRUE;\nEND_VAR 这 locio 功能块用于 PLC_PRG 程序。 PROGRAM PLC_PRG\n\nVAR\n locioVar1 : locio;\nEND_VAR 全局变量列表中正确的变量配置如下： VAR_CONFIG\n PLC_PRG.locioVar1.xLocIn AT %IX1.0 : BOOL;\nEND_VAR " }, 
{ "title" : "变量：CONSTANT ", 
"url" : "_cds_vartypes_constant.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：CONSTANT ", 
"snippet" : "CONSTANT 常量变量在全局变量列表或编程对象的声明部分中声明。在实现中，可以通过实例路径以只读方式访问常量变量。 句法 <scope> CONSTANT <identifier> : <data type> := <initial value> ; END_VAR <scope> : VAR | VAR_INPUT | VAR_STAT | VAR_GLOBAL <data type>: <elementary data type> | <user defined data type> | <function block> <initial value> : <literal value...", 
"body" : "CONSTANT 常量变量在全局变量列表或编程对象的声明部分中声明。在实现中，可以通过实例路径以只读方式访问常量变量。 句法 <scope> CONSTANT\n <identifier> : <data type> := <initial value> ;\nEND_VAR\n\n<scope> : VAR | VAR_INPUT | VAR_STAT | VAR_GLOBAL\n<data type>: <elementary data type> | <user defined data type> | <function block>\n<initial value> : <literal value> | <identifier> | <expression> 声明常量变量时始终分配初始化值。那么这个常数就不能再写了。 例子 宣言 VAR CONSTANT\n c_rTAXFACTOR : REAL := 1.19;\nEND_VAR 称呼 rPrice := rValue * c_rTAXFACTOR; 您对实现中的常量变量具有只读访问权限。常量变量位于赋值运算符的右侧。 有关更多信息，请参阅： 操作数" }, 
{ "title" : "变量： VAR_GENERIC CONSTANT ", 
"url" : "_cds_vartypes_var_generic_constant.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量： VAR_GENERIC CONSTANT ", 
"snippet" : "VAR_GENERIC CONSTANT 通用常量变量 泛型常量是中的一个变量 VAR_GENERIC CONSTANT 功能块的范围。该变量仅在声明函数块实例时定义。 允许在方法中使用泛型常量。这在以下情况下可能特别有用 VAR_IN_OUT 或者 VAR_IN_OUT CONSTANT 范围。...", 
"body" : "VAR_GENERIC CONSTANT 通用常量变量 泛型常量是中的一个变量 VAR_GENERIC CONSTANT 功能块的范围。该变量仅在声明函数块实例时定义。 允许在方法中使用泛型常量。这在以下情况下可能特别有用 VAR_IN_OUT 或者 VAR_IN_OUT CONSTANT 范围。 " }, 
{ "title" : "类型声明的语法 ", 
"url" : "_cds_vartypes_var_generic_constant.html#UUID-423cfb9f-ca4e-13fd-6267-abdbf0cb4cff_section-idm234820160791049", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量： VAR_GENERIC CONSTANT \/ 类型声明的语法 ", 
"snippet" : "带有泛型常量的函数块类型声明的语法 FUNCTION_BLOCK <function block name> VAR_GENERIC CONSTANT <generic constant name> : <integer data type> := <initial value> ; \/\/Initial value will be overwritten END_VAR <function block name> 功能块的名称 VAR_GENERIC CONSTANT END_VAR 泛型常量的范围 你可以在中声明任意数量的泛型常量 VAR_GENERIC CONSTANT 范围。 <gene...", 
"body" : "带有泛型常量的函数块类型声明的语法 FUNCTION_BLOCK <function block name>\nVAR_GENERIC CONSTANT\n <generic constant name> : <integer data type> := <initial value> ; \/\/Initial value will be overwritten\nEND_VAR\n\n <function block name> 功能块的名称 VAR_GENERIC CONSTANT END_VAR 泛型常量的范围 你可以在中声明任意数量的泛型常量 VAR_GENERIC CONSTANT 范围。 <generic constant name> 泛型常量的变量名 : <integer data type> 构造哪些类型的泛型常量。 允许使用整数数据类型或整数数据类型的子范围。 示例： maxlen1 : INT := 4; maxlen2 : INT(5..10) := 5; := <initial value> 可选 初始化 编译检查才需要初始值。在运行时，该值被覆盖 通用常量可以在功能块的实现中照常使用。例如，这些常量可用于数组的索引或字符串的长度 " }, 
{ "title" : "变量声明的语法 ", 
"url" : "_cds_vartypes_var_generic_constant.html#UUID-423cfb9f-ca4e-13fd-6267-abdbf0cb4cff_section-idm234820159794331", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量： VAR_GENERIC CONSTANT \/ 变量声明的语法 ", 
"snippet" : "具有指定常量的变量声明（函数块的实例化）的语法 以下选项是可能的： PROGRAM <program name> VAR <fb instance name> : <function block name> < <literal> > ; <fb instance name> : <function block name> <( <expression> )> ; <fb instance name> : ARRAY [ <index start > .. <index end> ] OF <function block name> < <array length> > ; END_VAR 变...", 
"body" : "具有指定常量的变量声明（函数块的实例化）的语法 以下选项是可能的： PROGRAM <program name>\nVAR\n <fb instance name> : <function block name> < <literal> > ;\n <fb instance name> : <function block name> <( <expression> )> ;\n <fb instance name> : ARRAY [ <index start > .. <index end> ] OF <function block name> < <array length> > ;\nEND_VAR\n 变量声明 <scope> END_... 范围 <fb instance name> 变量；功能块实例的名称 : <function block name> 使用功能块键入变量 这是一个带有泛型常量的功能块。 < <literal> > 可选 数据类型分配一个特定的值，该值仅对该功能块实例有效。该值已正式插入 in angle brackets 作为数据类型的后缀。 示例： fbMyString1 : FB_MyString<100&>; 如果 多个 已经为类型定义功能块声明了泛型常量，然后在尖括号中传递了一个以逗号分隔的值列表。每个常量都有一个值。 Example: fbPou : FB_Pou<100, 1000>; <( <expression> )> 可选 数据类型分配一个特定的表达式，该表达式仅对该函数块实例有效。该表达式已插入 in angle brackets 作为数据类型的后缀。表达式本身必须包含在内 在圆括号中 。 圆括号是必要的，因为它允许使用诸如此类的符号 < 或者 > 在表达式中。否则，将无法再保证代码的唯一性 Example: fbMyString2 : FB_MyString<(2 * cconst)>; ARRAY [ <start index start> .. <end index> ] OF <function block name> 可选 使用函数块数组键入变量。数组的长度为： <end index> - <start index> + 1 这是一个带有泛型常量的功能块。常量用作数组索引 示例： arrMyString < <array length> > 为数据类型分配特定的数组长度，该长度尤其对该功能块实例有效。 指定的数组长度作为数据类型的后缀正式插入尖括号中。指定的值必须与起始索引和结束索引定义的数组长度相匹配。 Example: arrMyString : ARRAY[0..5] OF FB_MyString<6>; " }, 
{ "title" : "例子 ", 
"url" : "_cds_vartypes_var_generic_constant.html#UUID-423cfb9f-ca4e-13fd-6267-abdbf0cb4cff_section-idm234820152486478", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量： VAR_GENERIC CONSTANT \/ 例子 ", 
"snippet" : "使用多个泛型常量的示例 FUNCTION_BLOCK FB_Pou VAR_GENERIC CONSTANT lnstring : DINT := 10; numstring : DINT := 100; END_VAR VAR arraystring : ARRAY[0..numstring-1] OF STRING(lnstring); END_VAR ; PROGRAM PLC_PRG VAR fbPou : FB_Pou<100, 1000>; END_VAR 示例：子作用域类型的通用常量 FUNCTION_BLOCK FB_SrString VAR_GENERIC CONSTANT ...", 
"body" : "使用多个泛型常量的示例 FUNCTION_BLOCK FB_Pou\nVAR_GENERIC CONSTANT\n lnstring : DINT := 10;\n numstring : DINT := 100;\nEND_VAR\nVAR\n arraystring : ARRAY[0..numstring-1] OF STRING(lnstring);\nEND_VAR\n; PROGRAM PLC_PRG\nVAR\n fbPou : FB_Pou<100, 1000>;\nEND_VAR 示例：子作用域类型的通用常量 FUNCTION_BLOCK FB_SrString \nVAR_GENERIC CONSTANT\n maxlen2 : INT(5..10) := 5; \/\/subrange data type\nEND_VAR\nVAR\n arrTest : ARRAY[0..maxlen-1] OF BYTE;\nEND_VAR\n; PROGRAM SrMain\nVAR CONSTANT\n cconst: INT(5..10) := 5;\nEND_VAR\nVAR \n fbMyString1 : FB_SrString<5>;\n fbMyString2 : FB_SrString<(2 * cconst)>;\n arrMyString : ARRAY [0..5] OF FB_SrString<6>;\nEND_VAR 示例：带有可参数化数组变量的通用功能块 以下代码演示如何定义可以处理任意长度数组的函数块。该功能块具有通用但长度恒定的数组。“常量” 意味着，尽管每个函数块实例的数组长度各不相同，但在对象的生命周期内它是恒定的。 例如，对于想要实现通用库 POU 的库程序员来说，这种结构是有益的。 FUNCTION_BLOCK FB_MyString \nVAR_GENERIC CONSTANT\n maxlen : UDINT := 1;\nEND_VAR\nVAR\n test : ARRAY[0..maxlen-1] OF BYTE;\nEND_VAR\n; PROGRAM PLC_PRG\nVAR CONSTANT\n cconst: DINT := 1000;\nEND_VAR\nVAR \n fbMyString1 : FB_MyString<100>;\n fbMyString2 : FB_MyString<(2 * cconst)>; \n arrMyString : ARRAY[0..5] OF FB_MyString<6>; \nEND_VAR\n; " }, 
{ "title" : "遗产 ", 
"url" : "_cds_vartypes_var_generic_constant.html#UUID-423cfb9f-ca4e-13fd-6267-abdbf0cb4cff_section-idm4622913801579232886674449065", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量： VAR_GENERIC CONSTANT \/ 遗产 ", 
"snippet" : "函数块可以继承具有泛型常量的基本函数块 ( EXTENDS ）。继承的功能块需要自己的通用常量。然后可以将特定值转移到外部。 语法： FUNCTION_BLOCK <function block name> VAR_GENERIC CONSTANT <generic constant name> : <integer data type> ; END_VAR EXTENDS <function block base> < <generic constant name> > 具有泛型常量的函数块可以实现接口 ( IMPLEMENTS ）。该接口声明了一个属性 ( PROPERTY ) 使用它可以...", 
"body" : "函数块可以继承具有泛型常量的基本函数块 ( EXTENDS ）。继承的功能块需要自己的通用常量。然后可以将特定值转移到外部。 语法： FUNCTION_BLOCK <function block name> \nVAR_GENERIC CONSTANT \n <generic constant name> : <integer data type> ; \nEND_VAR \nEXTENDS <function block base> < <generic constant name> >\n 具有泛型常量的函数块可以实现接口 ( IMPLEMENTS ）。该接口声明了一个属性 ( PROPERTY ) 使用它可以从外部访问指定的值。接口本身不得声明任何泛型常量或局部变量。接口没有实现。 语法： FUNCTION_BLOCK <function block name>\nVAR_GENERIC CONSTANT\n <generic constant name> : <integer data type> ;\nEND_VAR\nIMPLEMENTS <interface name>\n 编码时，确保先插入泛型常量的声明，然后插入 EXTENDS 和 IMPLEMENTS 。这需要一些时间来适应，但原因是泛型常量也可以与基类一起使用 示例 的定义 IString 通用功能块的接口。 It is strongly recommended to define an interface for generic function blocks. The interface should allow the generic function block instance to be used without knowledge of the generic constants. 这个 Length 属性允许访问通用常量。 INTERFACE IString \nMETHOD Append : BOOL \nVAR_INPUT \n strAppend : IString; \nEND_VAR \n\nMETHOD Assign : BOOL\nVAR_INPUT \n stringIn : STRING; \nEND_VAR \n\nMETHOD ToString : STRING\nVAR_INPUT \nEND_VAR \n\nPROPERTY Length : DINT 功能块的声明 FB_MyString 使用通用常量 maxlen FUNCTION_BLOCK FB_MyString \nVAR_GENERIC CONSTANT \n maxlen : UDINT; \nEND_VAR \nIMPLEMENTS IString \n 功能块 FB_LongString 是指定功能块的扩展 FB_MyString 。 FUNCTION_BLOCK FB_LongString EXTENDS FB_MyString<1000> 功能块的声明 FB_MySpecialString 使用通用常量 maxlen2 作为指定功能块的扩展 FB_MyString 。该功能块由该方法扩展 METH_ToLatin 。 FUNCTION_BLOCK FB_MySpecialString \nVAR_GENERIC CONSTANT \n maxlen2 : UDINT:= 1; \nEND_VAR \nEXTENDS FB_MyString<maxlen2>\n METHOD METH_ToLatin : STRING\nVAR_INPUT\nEND_VAR 使用特定常量对功能块进行实例化 PROGRAM PLC_PRG \nVAR CONSTANT \n cconst: DINT := 1000; \nEND_VAR\nVAR \n string1 : FB_MyString<100>;\n string2 : FB_MyString<(2 * cconst)>;\n derived1 : FB_LongString;\n derived2 : FB_MySpecialString<100>;\nEND_VAR \n 通话 string1.METH_Assign ('Welt'); \nstring2.METH_Assign ('Hallo '); \nstring2.METH_Append(string1); \nderived2.METH_ToLatin('Hello World'); " }, 
{ "title" : "变量：PERSISTENT ", 
"url" : "_cds_var_persistent.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：PERSISTENT ", 
"snippet" : "PERSISTENT 持久变量在声明部分声明 VAR_GLOBAL RETAIN PERSISTENT 在持久全局变量列表中。对于标有 PERSISTENT 持久性编辑器之外的关键字，实例路径被添加到那里。 作为 CODESYS V3.3.0.1，一个变量声明 PERSISTENT RETAIN 具有相同的效果 RETAIN PERSISTENT 或者 PERSISTENT . 全局持久变量列表中声明的语法 PersistentVars VAR_GLOBAL PERSISTENT RETAIN <identifier> : <data type> (:= <initialization>)?;...", 
"body" : "PERSISTENT 持久变量在声明部分声明 VAR_GLOBAL RETAIN PERSISTENT 在持久全局变量列表中。对于标有 PERSISTENT 持久性编辑器之外的关键字，实例路径被添加到那里。 作为 CODESYS V3.3.0.1，一个变量声明 PERSISTENT RETAIN 具有相同的效果 RETAIN PERSISTENT 或者 PERSISTENT . 全局持久变量列表中声明的语法 PersistentVars VAR_GLOBAL PERSISTENT RETAIN\n <identifier> : <data type> (:= <initialization>)?;\n <instance path to POU variable>\nEND_VAR POU 中声明的语法 <scope> PERSISTENT RETAIN\n <identifier> : <data type> ( := <initialization> )?; \/\/ ( ... )? : Optional\nEND_VAR\n<scope> : VAR | VAR_INPUT | VAR_OUTPUT | VAR_IN_OUT | VAR_STAT | VAR_GLOBAL 输入、输出或内存地址的分配 AT 不允许使用关键字。 永远不要使用 POINTER TO 持久变量列表中的数据类型。如果再次下载应用程序，它们的地址可能会改变。相应的编译器警告显示在消息窗口中。 如果您经常更改剩余变量的名称或数据类型，那么最好将它们声明为保留变量 RETAIN 仅关键字。 避免插入实例路径，因为在这种情况下会使用两倍的内存并且可能会出现更长的循环时间。相反，在持久变量列表中声明变量。 例子 中的声明 PersistentVars 持久变量列表 {attribute 'qualified_only'}\nVAR_GLOBAL PERSISTENT RETAIN\n g_iCounter : INT;\n \/\/ Generated instance path of persistent variable\n PLC_PRG.fb_A.iPersistentCounter_A: INT;\nEND_VAR 中的声明 FB_A 功能块 FUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR PERSISTENT\n iPersistentCounter_A : INT;\nEND_VAR 中的声明 PLC_PRG 程序 VAR\n fb_A1 : FB_A;\nEND_VAR 可能的申报地点 描述 直接在持久化全局变量列表中 该变量是持久的并且位于受保护的内存区域中。 在持久变量列表中具有实例路径的程序中本地 在持久变量列表中具有实例路径的功能块中本地 该变量是持久的并且位于受保护的内存区域和内存中（双重分配）。 仅在本地程序中 仅在功能块中本地 该变量不是持久的。消息窗口中会显示一条警告。 点击 声明 → 添加所有实例路径 将变量导入持久变量列表。 在函数中本地 这种声明没有任何作用。该变量不是持久的。 在持久性编辑器中，单击 声明 → 添加所有实例路径 如果局部变量被标记为 PERSISTENT . 尽可能避免将变量标记为 PERSISTENT 它们在功能块中声明。这是因为功能块实例完全存储在剩余内存中，而不仅仅是标记的变量。 " }, 
{ "title" : "变量：RETAIN ", 
"url" : "_cds_var_retain.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：RETAIN ", 
"snippet" : "RETAIN 保留变量由关键字声明 RETAIN 在范围内的编程对象中添加 VAR , VAR_INPUT , VAR_OUTPUT , VAR_IN_OUT , VAR_STAT ， 或者 VAR_GLOBAL . 声明的语法 <scope> RETAIN <identifier>: <data type> ( := <initialization> )? \/\/ ( ... )? : Optional END_VAR <scope> : VAR | VAR_INPUT | VAR_OUTPUT | VAR_IN_OUT | VAR_STAT | VAR_GLOBAL 输入、输出或内存地址的分...", 
"body" : "RETAIN 保留变量由关键字声明 RETAIN 在范围内的编程对象中添加 VAR , VAR_INPUT , VAR_OUTPUT , VAR_IN_OUT , VAR_STAT ， 或者 VAR_GLOBAL . 声明的语法 <scope> RETAIN\n <identifier>: <data type> ( := <initialization> )? \/\/ ( ... )? : Optional\nEND_VAR\n<scope> : VAR | VAR_INPUT | VAR_OUTPUT | VAR_IN_OUT | VAR_STAT | VAR_GLOBAL 输入、输出或内存地址的分配 AT 不允许使用关键字。 例子 在 POU 中 VAR RETAIN\n iVarRetain: INT;\nEND_VAR 在 GVL 中 VAR_GLOBAL RETAIN\n g_iVarRetain: INT;\nEND_VAR " }, 
{ "title" : "可能的申报地点 ", 
"url" : "_cds_var_retain.html#UUID-157672b4-f73c-a812-8a3b-bbf486c1ca31_id_d0d24fb1c0a864631c4fb86c_id_574bae341796868bc0a86463467e40bc", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 变量：RETAIN \/ 可能的申报地点 ", 
"snippet" : "在程序中本地 只有变量位于保留内存区域。 使用冗余时，整个程序及其所有数据都位于保留内存区域中。 在全局变量列表中全局 只有变量位于保留内存区域。 使用冗余时，整个全局变量列表及其所有数据都位于保留内存区域中。 在功能块中本地 功能块的整个实例及其所有数据都位于保留内存区域中。只有声明的保留变量受到保护。 在函数中本地 该变量不在保留内存区域中。此声明没有任何效果。 在函数中本地和持久地 该变量不在保留内存区域中。此声明没有任何效果。 尽可能避免使用 RETAIN 标记功能块的变量。...", 
"body" : "在程序中本地 只有变量位于保留内存区域。 使用冗余时，整个程序及其所有数据都位于保留内存区域中。 在全局变量列表中全局 只有变量位于保留内存区域。 使用冗余时，整个全局变量列表及其所有数据都位于保留内存区域中。 在功能块中本地 功能块的整个实例及其所有数据都位于保留内存区域中。只有声明的保留变量受到保护。 在函数中本地 该变量不在保留内存区域中。此声明没有任何效果。 在函数中本地和持久地 该变量不在保留内存区域中。此声明没有任何效果。 尽可能避免使用 RETAIN 标记功能块的变量。 " }, 
{ "title" : "指针：SUPER ", 
"url" : "_cds_pointer_super.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 指针：SUPER ", 
"snippet" : "SUPER 这 SUPER 指针是用于面向对象编程的特殊变量。 SUPER 是功能块的指针，指向生成功能块的基本功能块实例。这 SUPER 指针还允许访问基功能块（基类）的方法的实现。一个 SUPER 指针对每个功能块自动可用。您可以使用 SUPER 仅在方法和相关的功能块实现中。 指针的解引用： SUPER^ 使用 SUPER 指针：随着 SUPER 关键字，您调用的方法在基本类或父类的实例中有效。 例子 英石 SUPER^.METH_DoIt(); FBD\/CFC\/LD 例子 用于 SUPER 和 THIS 指针 FUNCTION_BLOCK FB_Base VAR_OUTPUT iCnt...", 
"body" : "SUPER 这 SUPER 指针是用于面向对象编程的特殊变量。 SUPER 是功能块的指针，指向生成功能块的基本功能块实例。这 SUPER 指针还允许访问基功能块（基类）的方法的实现。一个 SUPER 指针对每个功能块自动可用。您可以使用 SUPER 仅在方法和相关的功能块实现中。 指针的解引用： SUPER^ 使用 SUPER 指针：随着 SUPER 关键字，您调用的方法在基本类或父类的实例中有效。 例子 英石 SUPER^.METH_DoIt(); FBD\/CFC\/LD 例子 用于 SUPER 和 THIS 指针 FUNCTION_BLOCK FB_Base\nVAR_OUTPUT\n iCnt : INT;\nEND_VAR\n\nMETHOD METH_DoIt : BOOL\niCnt := -1;\n\nMETHOD METH_DoAlso : BOOL\nMETH_DoAlso := TRUE;\n\nFUNCTION_BLOCK FB_1 EXTENDS FB_Base\nVAR_OUTPUT\n iBase : INT;\nEND_VAR\n\nTHIS^.METH_DoIt(); \/\/Call of the methods of FB_1\nTHIS^.METH_DoAlso();\n\nSUPER^.METH_DoIt(); \/\/Call of the methods of FB_Base\nSUPER^.METH_DoAlso();\niBase := SUPER^.iCnt;\n\nMETHOD METH_DoIt : BOOL\niCnt := 1111;\nMETH_DoIt := TRUE;\n\nPROGRAM PLC_PRG\nVAR\n myBase : FB_Base;\n myFB_1 : FB_1;\n iTHIS : INT;\n iBase : INT;\nEND_VAR\nmyBase();\niBase := myBase.iCnt;\nmyFB_1();\niTHIS := myFB_1.iCnt; THIS 尚未针对指令列表 (IL) 实现。 " }, 
{ "title" : "指针： THIS ", 
"url" : "_cds_pointer_this.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 指针： THIS ", 
"snippet" : "THIS 这 THIS 指针是用于面向对象编程的特殊变量。 THIS 是一个功能块的指针，指向它自己的功能块实例。一个 THIS 指针对每个功能块自动可用。您可以使用 THIS 仅在方法和功能块中。 THIS 可用于类别中的输入助手中的实现 关键词 . 指针的解引用： THIS^ 的使用 THIS 指针 如果局部变量覆盖方法中的功能块变量，您可以使用 THIS 指针。请参见下面的示例 (1) 如果指向功能块自己的功能块实例的指针被引用以在功能中使用。 （见下例（2）） 例子 英石 THIS^.METH_DoIt(); FBD\/CFC\/LD 例子 这 iVarB 局部变量覆盖 iVarB 功能块...", 
"body" : "THIS 这 THIS 指针是用于面向对象编程的特殊变量。 THIS 是一个功能块的指针，指向它自己的功能块实例。一个 THIS 指针对每个功能块自动可用。您可以使用 THIS 仅在方法和功能块中。 THIS 可用于类别中的输入助手中的实现 关键词 . 指针的解引用： THIS^ 的使用 THIS 指针 如果局部变量覆盖方法中的功能块变量，您可以使用 THIS 指针。请参见下面的示例 (1) 如果指向功能块自己的功能块实例的指针被引用以在功能中使用。 （见下例（2）） 例子 英石 THIS^.METH_DoIt(); FBD\/CFC\/LD 例子 这 iVarB 局部变量覆盖 iVarB 功能块变量。 FUNCTION_BLOCK fbA\nVAR_INPUT\n iVarA: INT;\nEND_VAR\niVarA := 1;\n\nFUNCTION_BLOCK fbB EXTENDS fbA\nVAR_INPUT\n iVarB: INT := 0;\nEND_VAR\niVarA := 11;\niVarB := 2;\n\n METHOD DoIt : BOOL\n VAR_INPUT\n END_VAR\n VAR\n iVarB: INT;\n END_VAR\n iVarB := 22; \/\/ The local variable iVarB is set.\n THIS^.iVarB := 222; \/\/ The function block variable iVarB is set even though iVarB is obscured.\n\nPROGRAM PLC_PRG\nVAR\n MyfbB: fbB;\nEND_VAR\n\nMyfbB(iVarA:=0, iVarB:= 0);\nMyfbB.DoIt(); 例子 函数调用需要引用它自己的实例。 FUNCTION funA\nVAR_INPUT\n pFB: fbA;\nEND_VAR\n...;\n\nFUNCTION_BLOCK fbA\nVAR_INPUT\n iVarA: INT;\nEND_VAR\n...;\n\nFUNCTION_BLOCK fbB EXTENDS fbA\nVAR_INPUT\n iVarB: INT := 0;\nEND_VAR\niVarA := 11;\niVarB := 2;\n\n METHOD DoIt : BOOL\n VAR_INPUT\n END_VAR\n VAR\n iVarB: INT;\n END_VAR\n iVarB := 22; \/\/The local variable iVarB is set.\n funA(pFB := THIS^); \/\/funA is called via THIS^.\n\nPROGRAM PLC_PRG\nVAR\n MyfbB: fbB;\nEND_VAR\nMyfbB(iVarA:=0 , iVarB:= 0);\nMyfbB.DoIt(); THIS 尚未针对指令列表 (IL) 实现。 " }, 
{ "title" : "数据类型：隐式枚举 ", 
"url" : "_cds_datatype_implicit_enumeration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 数据类型：隐式枚举 ", 
"snippet" : "隐式枚举 隐式枚举允许一种简单的方法来声明仅在本地 POU 中有效的新枚举变量。这种类型的变量可以采用在组件列表中声明的有限数量的整数值。 隐式枚举没有数据类型名称或标识符。 宣言 : <variable name> : ( <list of component names> ) := <initialization>; <list of component names> 具有所需数量组件的逗号分隔组件名称列表 每个分量代表一个整数值，从 0 开始。后面的分量的值每次递增 1。 例子： Alfa, Bravo, Charlie, Delta, Echo 也可以将固定值分配给组件。 例子： Ze...", 
"body" : "隐式枚举 隐式枚举允许一种简单的方法来声明仅在本地 POU 中有效的新枚举变量。这种类型的变量可以采用在组件列表中声明的有限数量的整数值。 隐式枚举没有数据类型名称或标识符。 宣言 : <variable name> : ( <list of component names> ) := <initialization>; <list of component names> 具有所需数量组件的逗号分隔组件名称列表 每个分量代表一个整数值，从 0 开始。后面的分量的值每次递增 1。 例子： Alfa, Bravo, Charlie, Delta, Echo 也可以将固定值分配给组件。 例子： Zero, Alfa:=10, Bravo:=20, Charlie:=30, Delta:=40, Echo <initialization> 选修的 初始化值，通常是一个组件 称呼 : 例子 PROGRAM PLC_PRG\nVAR\n iAlphabet : (Alfa, Bravo, Charlie, Delta, Echo) := Echo;\n strText : STRING;\n iNumber : INT;\nEND_VAR CASE iAlphabet OF\n\tAlfa:\n\tstrText := 'A';\n\t\n\tBravo: \n\tstrText := 'B';\n\t\n\tCharlie:\n\tstrText := 'C';\n\t\n\tDelta:\n\tstrText := 'D';\n\t\n\tEcho:\n\tstrText := 'E';\nEND_CASE\niNumber := iAlphabet; " }, 
{ "title" : "内部数据类型 ", 
"url" : "_cds_datatype_implicit_enumeration.html#UUID-839e1fb0-3d1c-7e8f-1286-1f54053bb20b_section-idm4597855524900833552049065596", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 变量 \/ 数据类型：隐式枚举 \/ 内部数据类型 ", 
"snippet" : "使用隐式枚举，在内部创建一个数据类型，其名称遵循以下方案： IMPLICIT_ENUM_ <POU name> _ <variable name> 但是，您不应使用此内部标识符，因为内部标识符始终有可能不同。...", 
"body" : "使用隐式枚举，在内部创建一个数据类型，其名称遵循以下方案： IMPLICIT_ENUM_ <POU name> _ <variable name> 但是，您不应使用此内部标识符，因为内部标识符始终有可能不同。 " }, 
{ "title" : "运算符 ", 
"url" : "_cds_struct_reference_operators.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 ", 
"snippet" : "CODESYS V3 支持所有 IEC 61131-3 运算符。这些运算符在整个项目中都得到隐式识别。除了这些 IEC 运算符之外， CODESYS 还支持一些非IEC 61131-3操作员。 运算符用于块中，例如函数。 有关 ST 运算符的处理顺序（结合强度）的信息，请参阅“ST 表达式”一章。 对于浮点数据类型的运算，计算结果取决于所应用的目标系统硬件。 对于数据类型溢出或下溢的运算，计算结果取决于所应用的目标系统硬件。...", 
"body" : "CODESYS V3 支持所有 IEC 61131-3 运算符。这些运算符在整个项目中都得到隐式识别。除了这些 IEC 运算符之外， CODESYS 还支持一些非IEC 61131-3操作员。 运算符用于块中，例如函数。 有关 ST 运算符的处理顺序（结合强度）的信息，请参阅“ST 表达式”一章。 对于浮点数据类型的运算，计算结果取决于所应用的目标系统硬件。 对于数据类型溢出或下溢的运算，计算结果取决于所应用的目标系统硬件。 " }, 
{ "title" : "数据类型的上溢\/下溢 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4547044759401632680609081132", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 数据类型的上溢\/下溢 ", 
"snippet" : "这 CODESYS 编译器为目标设备生成代码，并始终使用目标设备定义的本机大小计算临时结果。例如，在 x86 和 ARM 系统上至少使用 32 位临时值执行计算，在 x64 系统上始终使用 64 位临时值执行计算。这在计算速度方面提供了相当大的优势，并且通常还会产生所需的结果。但这也意味着在某些情况下数据类型的溢出或下溢不会被截断。 例子 示例 1 此加法的结果不会被截断，并且结果为 dwVar 是 65536 。 VAR wVar : WORD; dwVar: DWORD; END_VAR wVar := 65535; dwVar := wVar + 1; 示例 2 数据类型的上溢和下溢不会...", 
"body" : "这 CODESYS 编译器为目标设备生成代码，并始终使用目标设备定义的本机大小计算临时结果。例如，在 x86 和 ARM 系统上至少使用 32 位临时值执行计算，在 x64 系统上始终使用 64 位临时值执行计算。这在计算速度方面提供了相当大的优势，并且通常还会产生所需的结果。但这也意味着在某些情况下数据类型的溢出或下溢不会被截断。 例子 示例 1 此加法的结果不会被截断，并且结果为 dwVar 是 65536 。 VAR\nwVar : WORD;\ndwVar: DWORD;\nEND_VAR\n\nwVar := 65535;\ndwVar := wVar + 1; 示例 2 数据类型的上溢和下溢不会被截断，结果（ bVar1, bVar2 ）两个比较的结果都是 FALSE 在 32 位和 64 位硬件上。 VAR\nwVar1 : WORD;\nwVar2 : WORD;\nbVar1 : BOOL;\nbVar2 : BOOL;\nEND_VAR\n\nwVar1 := 65535;\nwVar2 := 0;\nbVar1 := (wVar1 + 1) = wVar2;\nbVar2 := (wVar2 - 1) = wVar1; 示例 3 通过分配给 wVar3 ，该值将被截断为目标数据类型 WORD 结果 bvar1 是 TRUE 。 VAR\nwVar1 : WORD;\nwVar2 : WORD;\nwVar3 : WORD;\nbVar1 : BOOL;\nEND_VAR\n\nwVar1 := 65535;\nwVar2 := 0;\nwVar3 := (wVar1 + 1);\nbVar1 := wVar3 = wVar2; 示例 4 为了强制编译器截断临时结果，可以插入转换。 类型转换确保两个比较都是 16 位的，并且结果（ bVar1, bVar2 ）两个比较的 TRUE 。 VAR\nwVar1 : WORD;\nwVar2 : WORD;\nbVar1 : BOOL;\nbVar2 : BOOL;\nEND_VAR\n\nwVar1 := 65535;\nwVar2 := 0;\nbVar1 := TO_WORD(wVar1 + 1) = wVar2;\nbVar2 := TO_WORD(wVar2 - 1) = wVar1; " }, 
{ "title" : "算术运算符 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4547044771580832680618577688", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 算术运算符 ", 
"snippet" : "ADDSUBMULDIVMODMOVEINDEXOFSIZEOFXSIZEOF...", 
"body" : "ADDSUBMULDIVMODMOVEINDEXOFSIZEOFXSIZEOF" }, 
{ "title" : "位串运算符 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4613160039052832680627943345", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 位串运算符 ", 
"snippet" : "ANDORXORNOTAND_THENOR_ELSE...", 
"body" : "ANDORXORNOTAND_THENOR_ELSE" }, 
{ "title" : "移位运算符 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4614490322289632680632942766", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 移位运算符 ", 
"snippet" : "SHLSHRROLROR...", 
"body" : "SHLSHRROLROR" }, 
{ "title" : "选择运算符 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4613159872158432680635250845", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 选择运算符 ", 
"snippet" : "SELMAXMINLIMITMUX...", 
"body" : "SELMAXMINLIMITMUX" }, 
{ "title" : "比较运算符 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4547044751392032680639121857", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 比较运算符 ", 
"snippet" : "比较运算符是比较两个输入（第一个和第二个操作数）的布尔值。 GTLTLEGEEQNE...", 
"body" : "比较运算符是比较两个输入（第一个和第二个操作数）的布尔值。 GTLTLEGEEQNE" }, 
{ "title" : "地址运算符 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4547044729646432680646324029", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 地址运算符 ", 
"snippet" : "ADR内容运营商BITADR...", 
"body" : "ADR内容运营商BITADR" }, 
{ "title" : "呼叫操作员 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4613160098891232680647867881", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 呼叫操作员 ", 
"snippet" : "CAL...", 
"body" : "CAL" }, 
{ "title" : "类型转换运算符 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4613160045062432680609282328", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 类型转换运算符 ", 
"snippet" : "您可以显式调用类型转换运算符。下面描述的类型转换运算符可用于从一种基本类型到另一种基本类型的类型转换，以及重载。从“较大”类型到“较小”类型的转换也是隐式可能的（例如，从 INT 到 BYTE 或来自 DINT 到 WORD ）。 类型转换： <elementary data type> _TO_ another elementary data type> 重载转换： TO_ <elementary data type> 基本数据类型 <elementary data type> = __UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE |...", 
"body" : "您可以显式调用类型转换运算符。下面描述的类型转换运算符可用于从一种基本类型到另一种基本类型的类型转换，以及重载。从“较大”类型到“较小”类型的转换也是隐式可能的（例如，从 INT 到 BYTE 或来自 DINT 到 WORD ）。 类型转换： <elementary data type> _TO_ another elementary data type> 重载转换： TO_ <elementary data type> 基本数据类型 <elementary data type> =\n__UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TOD | UDINT | UINT | ULINT | USINT | WORD 关键词 T ， TIME_OF_DAY 和 DATE_AND_TIME 是数据类型的替代形式 TIME ， TOD ， 和 DT 。 T ， TIME_OF_DAY 和 DATE_AND_TIME 不表示为类型转换命令。 如果类型转换运算符的操作数值超出目标数据类型的值范围，则结果输出取决于处理器类型，因此未定义。例如，当负操作数值从 LREAL 目标数据类型 UINT 。 从较大的数据类型转换为较小的数据类型时，信息可能会丢失。 转换为时的字符串操作 STRING 或者 WSTRING 将类型转换为 STRING 或者 WSTRING ，输入的值作为字符串左对齐，如果太长会被截断。因此，声明类型转换运算符的返回变量 <>_TO_STRING 和 <>_TO_WSTRING 足够长，使得字符串有足够的空间而无需进行任何操作。 REAL, LREALTIME, LTIMEDATE, DT, TOD, LDATE, LDT, LTODSTRING, WSTRINGTRUNCTRUNC_INT" }, 
{ "title" : "数字运算符 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_UUID-078cb7af-b708-bb5b-645f-7aa04bb4e566", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 数字运算符 ", 
"snippet" : "ABSSQRTLNLOGEXPEXPTSINASINCOSACOSTANATAN...", 
"body" : "ABSSQRTLNLOGEXPEXPTSINASINCOSACOSTANATAN" }, 
{ "title" : "命名空间运算符 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_UUID-eaf6bdfd-66b9-ab9a-08fc-829c9410631e", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 命名空间运算符 ", 
"snippet" : "命名空间运算符是从 IEC 61131-3 运算符扩展而来。它们使您能够提供对变量和模块的唯一访问，即使您在项目中多次对变量或模块使用相同的名称。 全局命名空间全局变量列表的命名空间枚举命名空间库命名空间__POOL...", 
"body" : "命名空间运算符是从 IEC 61131-3 运算符扩展而来。它们使您能够提供对变量和模块的唯一访问，即使您在项目中多次对变量或模块使用相同的名称。 全局命名空间全局变量列表的命名空间枚举命名空间库命名空间__POOL" }, 
{ "title" : "多核运算符 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_UUID-2fa16f56-92bc-e076-7c16-e327a025cba1", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 多核运算符 ", 
"snippet" : "处理不同的任务需要同步这些任务。在多核平台上工作时尤其如此。 CODESYS 提供了一些特殊的操作符来支持这种同步。 这些运算符是 IEC-61131-3 的扩展。运算符 TEST_AND_SET 和 __COMPARE_AND_SWAP 用于类似的任务。 TEST_AND_SET__COMPARE_AND_SWAP__XADD...", 
"body" : "处理不同的任务需要同步这些任务。在多核平台上工作时尤其如此。 CODESYS 提供了一些特殊的操作符来支持这种同步。 这些运算符是 IEC-61131-3 的扩展。运算符 TEST_AND_SET 和 __COMPARE_AND_SWAP 用于类似的任务。 TEST_AND_SET__COMPARE_AND_SWAP__XADD" }, 
{ "title" : "其他运营商 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_UUID-953f3232-5824-b4c4-ff29-e4248bf72edd", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 其他运营商 ", 
"snippet" : "__DELETE__ISVALIDREF__NEW__QUERYINTERFACE__QUERYPOINTERINI__TRY, __CATCH, __FINALLY, __ENDTRY__POSITION__POUNAME...", 
"body" : "__DELETE__ISVALIDREF__NEW__QUERYINTERFACE__QUERYPOINTERINI__TRY, __CATCH, __FINALLY, __ENDTRY__POSITION__POUNAME" }, 
{ "title" : "操作员：ADD ", 
"url" : "_cds_operator_add.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：ADD ", 
"snippet" : "ADD IEC 运算符添加变量。 允许的数据类型： __UXINT | __XINT | __XWORD | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TIME_OF_DAY | TOD | UDINT | UINT | ULINT | USINT | WORD 时间数据类型的可能组合 TIME + TIME = TIME TIME + LTIME...", 
"body" : "ADD searchresult_toplevel IEC 运算符添加变量。 允许的数据类型： __UXINT | __XINT | __XWORD | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TIME_OF_DAY | TOD | UDINT | UINT | ULINT | USINT | WORD 时间数据类型的可能组合 TIME + TIME = TIME TIME + LTIME = LTIME LTIME + LTIME = LTIME 日期和时间数据类型的可能组合 TOD + TIME = TOD DT + TIME = DT TOD + LTIME = LTOD DT + LTIME = LDT LTOD + TIME = LTOD LDT + LTIME = LDT LTOD +LTIME = LTOD LDT + LTIME = LDT FBD\/LD 编辑器中的功能：您可以扩展 ADD 具有功能块输入的运算符。附加功能块输入的数量是有限的。 例子 英石 var1 := 7+2+4+7; FBD " }, 
{ "title" : "操作员：MUL ", 
"url" : "_cds_operator_mul.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：MUL ", 
"snippet" : "MUL IEC 运算符用于将变量相乘。 允许的数据类型： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , TIME FBD\/LD 编辑器中的功能：您可以扩展 MUL 具有附加功能块输入的运算符。附加功能块输入的数量是有限的。 例子 英石 var1 := 7*2*4*7; FBD...", 
"body" : "MUL IEC 运算符用于将变量相乘。 允许的数据类型： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , TIME FBD\/LD 编辑器中的功能：您可以扩展 MUL 具有附加功能块输入的运算符。附加功能块输入的数量是有限的。 例子 英石 var1 := 7*2*4*7; FBD " }, 
{ "title" : "运营商：SUB ", 
"url" : "_cds_operator_sub.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：SUB ", 
"snippet" : "SUB IEC 运算符减去变量。 允许的数据类型： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , TIME , LTIME , TIME_OF_DAY (TOD) , LTIME_OF_DAY (LTOD) , DATE , LDATE , DATE_AND_TIME (DT) LDATE_AND_TIME (DT) 时间数据类型的可能组合 TIME - TIME = TIME LTIME - LTIME = LTIME 日期和时间数据...", 
"body" : "SUB IEC 运算符减去变量。 允许的数据类型： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , TIME , LTIME , TIME_OF_DAY (TOD) , LTIME_OF_DAY (LTOD) , DATE , LDATE , DATE_AND_TIME (DT) LDATE_AND_TIME (DT) 时间数据类型的可能组合 TIME - TIME = TIME LTIME - LTIME = LTIME 日期和时间数据类型的可能组合 DATE - DATE = TIME LDATE - LDATE = LTIME TOD - TIME = TOD LTOD - LTIME = LTOD TOD - TOD = TIME LTOD - LTOD = LTIME DT - TIME = DT LDT - LTIME = LDT DT - DT = TIME LDT - LDT = LTIME 消极的 TIME\/LTIME 值未定义。 例子 英石 var1 := 7-2; FBD " }, 
{ "title" : "运算符：DIV ", 
"url" : "_cds_operator_div.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：DIV ", 
"snippet" : "DIV IEC 运算符用于划分变量。 允许的数据类型： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , TIME 根据目标系统，除以零可能会产生不同的结果。 例子 英石 var1 := 8\/2; FBD 1. DIV 块系列，2. 单个 DIV 块，3. 带 EN\/ENO 参数的 DIV POU 请注意，可以使用隐式监视函数在运行时监视除以零 CheckDivInt , CheckDivLint , 检查DivReal ， 和 检查Div...", 
"body" : "DIV IEC 运算符用于划分变量。 允许的数据类型： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , TIME 根据目标系统，除以零可能会产生不同的结果。 例子 英石 var1 := 8\/2; FBD 1. DIV 块系列，2. 单个 DIV 块，3. 带 EN\/ENO 参数的 DIV POU 请注意，可以使用隐式监视函数在运行时监视除以零 CheckDivInt , CheckDivLint , 检查DivReal ， 和 检查DivLReal . " }, 
{ "title" : "运营商：MOD ", 
"url" : "_cds_operator_mod.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：MOD ", 
"snippet" : "MOD IEC 运算符用于模除法。 该函数的结果是除法的非负整数余数。 允许的数据类型： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT 根据目标系统，除以零可能会产生不同的结果。 例子 Var1 中的结果：1 英石 var1 := 9 MOD 2; FBD...", 
"body" : "MOD IEC 运算符用于模除法。 该函数的结果是除法的非负整数余数。 允许的数据类型： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT 根据目标系统，除以零可能会产生不同的结果。 例子 Var1 中的结果：1 英石 var1 := 9 MOD 2; FBD " }, 
{ "title" : "运营商：MOVE ", 
"url" : "_cds_operator_move.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：MOVE ", 
"snippet" : "MOVE IEC 运算符用于将一个变量分配给相应类型的另一个变量。 因为 MOVE 在 CFC、FBD 和 LD 编辑器中可用，您还可以使用那里的 EN\/ENO 功能进行变量分配。 与 EN\/ENO 功能相关的 CFC CODESYS 分配的值 var1 变量为 var2 仅当 en_i is TRUE . 英石 ivar2 := MOVE(ivar1); 对应于： ivar2 := ivar1;...", 
"body" : "MOVE IEC 运算符用于将一个变量分配给相应类型的另一个变量。 因为 MOVE 在 CFC、FBD 和 LD 编辑器中可用，您还可以使用那里的 EN\/ENO 功能进行变量分配。 与 EN\/ENO 功能相关的 CFC CODESYS 分配的值 var1 变量为 var2 仅当 en_i is TRUE . 英石 ivar2 := MOVE(ivar1); 对应于： ivar2 := ivar1; " }, 
{ "title" : "运营商：INDEXOF ", 
"url" : "_cds_operator_indexof.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：INDEXOF ", 
"snippet" : "INDEXOF 运算符是 IEC 61131-3 标准的扩展。 而不是 INDEXOF 运营商 ADR 运算符提供在 CODESYS V3 用于获取 POU 索引处的指针。...", 
"body" : "INDEXOF 运算符是 IEC 61131-3 标准的扩展。 而不是 INDEXOF 运营商 ADR 运算符提供在 CODESYS V3 用于获取 POU 索引处的指针。 " }, 
{ "title" : "操作员：SIZEOF ", 
"url" : "_cds_operator_sizeof.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：SIZEOF ", 
"snippet" : "SIZEOF 在编译器版本 3.5.16.0 及更高版本中， XSIZEOF 应使用运算符而不是此运算符。 运算符是 IEC 61131-3 标准的扩展。 句法 ： <return value> := SIZEOF( <variable name> | <date type name> ); 运算符确定传递的变量或数据类型中所需的字节数。始终返回无符号值。返回值的类型与传递的操作数（变量或数据类型）相适应。 返回值： <return value> 隐式使用的返回值的数据类型 0 <= <return value> <256 USINT 256 <= <return value> < 65536...", 
"body" : "SIZEOF 在编译器版本 3.5.16.0 及更高版本中， XSIZEOF 应使用运算符而不是此运算符。 运算符是 IEC 61131-3 标准的扩展。 句法 ： <return value> := SIZEOF( <variable name> | <date type name> ); 运算符确定传递的变量或数据类型中所需的字节数。始终返回无符号值。返回值的类型与传递的操作数（变量或数据类型）相适应。 返回值： <return value> 隐式使用的返回值的数据类型 0 <= <return value> <256 USINT 256 <= <return value> < 65536 UINT 65536 <= <return value> < 4294967296 UDINT 4294967296 <= <return value> ULINT ST 中的示例 PROGRAM PLC_PRG\nVAR\n\taData_1 : ARRAY[0..4] OF INT;\n\tiReturnValue : INT;\nEND_VAR iReturnValue := SIZEOF(aData_1); (* iReturnValue := USINT#10; *) 结果在 iReturnValue 是 10 . " }, 
{ "title" : "操作员：XSIZEOF ", 
"url" : "_cds_operator_xsizeof.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：XSIZEOF ", 
"snippet" : "XSIZEOF 运算符是 IEC 61131-3 标准的扩展。 这 XSIZEOF 运算符确定传递的变量或数据类型中所需的字节数。 这样做时，总是返回一个无符号值。返回值的数据类型 <return value> 固定如下：类型 ULINT 在 64 位平台上和类型 UDINT 在所有其他平台上。要生成在所有平台上运行的代码，可以使用 __UXINT 数据类型。 句法 ： <return value> := XSIZEOF( <variable> ); ST 中的示例 PROGRAM PLC_PRG VAR uxiReturnValue : __UXINT; (* Datentyp bei 64...", 
"body" : "XSIZEOF 运算符是 IEC 61131-3 标准的扩展。 这 XSIZEOF 运算符确定传递的变量或数据类型中所需的字节数。 这样做时，总是返回一个无符号值。返回值的数据类型 <return value> 固定如下：类型 ULINT 在 64 位平台上和类型 UDINT 在所有其他平台上。要生成在所有平台上运行的代码，可以使用 __UXINT 数据类型。 句法 ： <return value> := XSIZEOF( <variable> ); ST 中的示例 PROGRAM PLC_PRG\nVAR\n uxiReturnValue : __UXINT; (* Datentyp bei 64-bit-Plattformen: ULINT *)\n aData_1 : ARRAY[0..4] OF INT; \nEND_VAR uxiReturnValue := XSIZEOF(aData_1); 结果： uxiReturnValue = 10 在分配给类型变量的情况下 __UXINT , 我们建议您使用 XSIZEOF 运算符而不是 SIZEOF 操作员。这是因为与 XSIZEOF 返回值的数据类型取决于平台。因此，在使用 SIZEOF 运算符时不会出现任何问题。 " }, 
{ "title" : "运营商：NOT ", 
"url" : "_cds_operator_not.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：NOT ", 
"snippet" : "NOT IEC 运算符用于按位 NOT 位操作数。 当相应的输入位产生 0 时，输出位也产生 1，反之亦然。 允许的数据类型： BOOL , BYTE , WORD , DWORD , LWORD 例子 造成 Var1 ： 2#0110_1100 英石 Var1 := NOT 2#1001_0011; FBD...", 
"body" : "NOT IEC 运算符用于按位 NOT 位操作数。 当相应的输入位产生 0 时，输出位也产生 1，反之亦然。 允许的数据类型： BOOL , BYTE , WORD , DWORD , LWORD 例子 造成 Var1 ： 2#0110_1100 英石 Var1 := NOT 2#1001_0011; FBD " }, 
{ "title" : "运算符：AND ", 
"url" : "_cds_operator_and.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：AND ", 
"snippet" : "AND IEC 运算符用于按位 AND 位操作数。 当输入位都产生 1 时，输出位也产生 1；否则为 0。 允许的数据类型： BOOL , BYTE , WORD , DWORD , LWORD 例子 造成 var1: 2#1000_0010 英石 var1 := 2#1001_0011 AND 2#1000_1010; FBD...", 
"body" : "AND searchresult_toplevel IEC 运算符用于按位 AND 位操作数。 当输入位都产生 1 时，输出位也产生 1；否则为 0。 允许的数据类型： BOOL , BYTE , WORD , DWORD , LWORD 例子 造成 var1: 2#1000_0010 英石 var1 := 2#1001_0011 AND 2#1000_1010; FBD " }, 
{ "title" : "运算符：OR ", 
"url" : "_cds_operator_or.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：OR ", 
"snippet" : "OR IEC 运算符用于按位 OR 位操作数。 当至少一个输入位产生 1 时，输出位也产生 1；否则为 0。 允许的数据类型： BOOL , BYTE , WORD , DWORD , LWORD 例子 造成 Var1 ： 2#1001_1011 英石 Var1 := 2#1001_0011 OR 2#1000_1010; FBD...", 
"body" : "OR IEC 运算符用于按位 OR 位操作数。 当至少一个输入位产生 1 时，输出位也产生 1；否则为 0。 允许的数据类型： BOOL , BYTE , WORD , DWORD , LWORD 例子 造成 Var1 ： 2#1001_1011 英石 Var1 := 2#1001_0011 OR 2#1000_1010; FBD " }, 
{ "title" : "运算符：XOR ", 
"url" : "_cds_operator_xor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：XOR ", 
"snippet" : "XOR IEC 运算符用于按位 XOR 位操作数。 当两个输入位中只有一个产生 1 时，输出位也产生 1。当两个输入产生 1 或 0 时，输出产生 0。 允许的数据类型： BOOL , BYTE , WORD , DWORD , LWORD 请注意以下行为 XOR 扩展形式的POU（多于两个输入）：成对比较输入，然后比较相应的结果（按照标准，但不一定按照预期）。 例子 造成 var1 ： 2#0001_1001 英石 var1 := 2#1001_0011 XOR 2#1000_1010; FBD...", 
"body" : "XOR IEC 运算符用于按位 XOR 位操作数。 当两个输入位中只有一个产生 1 时，输出位也产生 1。当两个输入产生 1 或 0 时，输出产生 0。 允许的数据类型： BOOL , BYTE , WORD , DWORD , LWORD 请注意以下行为 XOR 扩展形式的POU（多于两个输入）：成对比较输入，然后比较相应的结果（按照标准，但不一定按照预期）。 例子 造成 var1 ： 2#0001_1001 英石 var1 := 2#1001_0011 XOR 2#1000_1010; FBD " }, 
{ "title" : "运算符：AND_THEN ", 
"url" : "_cds_operator_and_then.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：AND_THEN ", 
"snippet" : "AND_THEN 运算符是 IEC 61131-3 标准的扩展。 这 AND_THEN 运算符仅允许在结构化文本中使用 AND 操作 BOOL 和 BIT 具有短路评估的操作数。这意味着： 当所有操作数产生 TRUE , 操作数的结果也产生 TRUE ;否则 FALSE . 然而， CODESYS 仅当 AND_THEN 运算符是 TRUE .这可以防止空指针出现问题，例如在诸如 IF (ptr <> 0 AND_THEN ptr^ = 99) THEN... . 相比之下， CODESYS 使用时总是计算所有操作数 AND IEC 运营商。...", 
"body" : "AND_THEN 运算符是 IEC 61131-3 标准的扩展。 这 AND_THEN 运算符仅允许在结构化文本中使用 AND 操作 BOOL 和 BIT 具有短路评估的操作数。这意味着： 当所有操作数产生 TRUE , 操作数的结果也产生 TRUE ;否则 FALSE . 然而， CODESYS 仅当 AND_THEN 运算符是 TRUE .这可以防止空指针出现问题，例如在诸如 IF (ptr <> 0 AND_THEN ptr^ = 99) THEN... . 相比之下， CODESYS 使用时总是计算所有操作数 AND IEC 运营商。 " }, 
{ "title" : "运算符：OR_ELSE ", 
"url" : "_cds_operator_or_else.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：OR_ELSE ", 
"snippet" : "OR_ELSE 运算符是 IEC 61131-3 标准的扩展。 这 OR_ELSE 运算符仅允许用于结构化文本中的编程： OR 操作 BOOL 和 BIT 具有短路评估的操作数。这意味着： 当至少一个操作数产生 TRUE , 运算结果也产生 TRUE ;否则 FALSE . 与使用 OR IEC 运算符，用于 OR_ELSE 一旦操作数之一被评估为，则不会立即评估所有其他运算符上的表达式 TRUE . 例子 VAR bEver: BOOL; bX: BOOL; dw: DWORD := 16#000000FF; END_VAR bEver := FALSE; bX := dw.8 OR_ELS...", 
"body" : "OR_ELSE 运算符是 IEC 61131-3 标准的扩展。 这 OR_ELSE 运算符仅允许用于结构化文本中的编程： OR 操作 BOOL 和 BIT 具有短路评估的操作数。这意味着： 当至少一个操作数产生 TRUE , 运算结果也产生 TRUE ;否则 FALSE . 与使用 OR IEC 运算符，用于 OR_ELSE 一旦操作数之一被评估为，则不会立即评估所有其他运算符上的表达式 TRUE . 例子 VAR\n bEver: BOOL;\n bX: BOOL;\n dw: DWORD := 16#000000FF;\nEND_VAR\n\nbEver := FALSE;\nbX := dw.8 OR_ELSE dw.1 OR_ELSE (bEver := TRUE); dw.8 是 FALSE 和 dw.1 是 TRUE .因此，结果 bX 的操作是 TRUE .但是，不执行第三个输入处的表达式，并且 bEver 遗迹 FALSE .另一方面，如果使用标准 OR 操作， bEver 将设置为 TRUE。 " }, 
{ "title" : "运营商：SHL ", 
"url" : "_cds_operator_shl.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：SHL ", 
"snippet" : "SHL IEC 运算符用于将操作数向左按位移位。 erg := SHL (in, n) in : 左移的操作数 n : 要移位的位数 in 向左转 如果 n 超过数据类型宽度，则取决于目标系统如何 BYTE , WORD , DWORD ， 和 LWORD 操作数被填充。目标系统导致填充零或 n MOD <寄存器大小> . 注意位数 CODESYS 用于此操作，由输入变量的数据类型定义 in . 例子 结果为 erg_byte 和 erg_word 是不同的，虽然的值 in_byte 和 in_word 输入变量相同，输入变量的数据类型不同。 英石 PROGRAM shl_st VAR in_...", 
"body" : "SHL IEC 运算符用于将操作数向左按位移位。 erg := SHL (in, n) in : 左移的操作数 n : 要移位的位数 in 向左转 如果 n 超过数据类型宽度，则取决于目标系统如何 BYTE , WORD , DWORD ， 和 LWORD 操作数被填充。目标系统导致填充零或 n MOD <寄存器大小> . 注意位数 CODESYS 用于此操作，由输入变量的数据类型定义 in . 例子 结果为 erg_byte 和 erg_word 是不同的，虽然的值 in_byte 和 in_word 输入变量相同，输入变量的数据类型不同。 英石 PROGRAM shl_st\nVAR\n in_byte : BYTE := 16#45; (* 2#01000101 )\n in_word : WORD := 16#0045; (* 2#0000000001000101 )\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := SHL(in_byte,n); (* Result is 16#14, 2#00010100 *)\nerg_word := SHL(in_word,n); (* Result is 16#0114, 2#0000000100010100 *) FBD " }, 
{ "title" : "运营商：SHR ", 
"url" : "_cds_operator_shr.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：SHR ", 
"snippet" : "SHR IEC 运算符用于将操作数按位右移。 erg := SHR (in, n) in : 向右移动的操作数 n : 要移位的位数 in 向右 如果 n 超过数据类型宽度，则取决于目标系统如何 BYTE , WORD , DWORD ， 和 LWORD 操作数被填充。目标系统导致填充零或 n MOD <寄存器大小> . 例子 英石 PROGRAM shr_st VAR in_byte : BYTE := 16#45; (* 2#01000101 ) in_word : WORD := 16#0045; (* 2#0000000001000101 ) erg_byte : BYTE; erg_...", 
"body" : "SHR IEC 运算符用于将操作数按位右移。 erg := SHR (in, n) in : 向右移动的操作数 n : 要移位的位数 in 向右 如果 n 超过数据类型宽度，则取决于目标系统如何 BYTE , WORD , DWORD ， 和 LWORD 操作数被填充。目标系统导致填充零或 n MOD <寄存器大小> . 例子 英石 PROGRAM shr_st\nVAR\n in_byte : BYTE := 16#45; (* 2#01000101 )\n in_word : WORD := 16#0045; (* 2#0000000001000101 )\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := SHR(in_byte,n); (* Result is 16#11, 2#00010001 *)\nerg_word := SHR(in_word,n); (* Result is 16#0011, 2#0000000000010001 *) FBD " }, 
{ "title" : "操作员：ROL ", 
"url" : "_cds_operator_rol.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：ROL ", 
"snippet" : "ROL IEC 运算符用于将操作数按位向左旋转。 允许的数据类型： BYTE , WORD , DWORD , LWORD erg := ROL (in, n) CODESYS 移动 in n 次向左移动一位，然后将该位从右侧添加到最左侧的位置。 注意位数 CODESYS 用于由数据类型定义的此操作 in 输入变量。如果这是一个常数，那么 CODESYS 使用尽可能小的数据类型。输出变量的数据类型仍然不会影响此操作。 例子 结果为 erg_byte 和 erg_word 根据输入变量的数据类型而有所不同，尽管 in_byte 和 in_word 输入变量相同。 英石 PROGRAM rol_s...", 
"body" : "ROL IEC 运算符用于将操作数按位向左旋转。 允许的数据类型： BYTE , WORD , DWORD , LWORD erg := ROL (in, n) CODESYS 移动 in n 次向左移动一位，然后将该位从右侧添加到最左侧的位置。 注意位数 CODESYS 用于由数据类型定义的此操作 in 输入变量。如果这是一个常数，那么 CODESYS 使用尽可能小的数据类型。输出变量的数据类型仍然不会影响此操作。 例子 结果为 erg_byte 和 erg_word 根据输入变量的数据类型而有所不同，尽管 in_byte 和 in_word 输入变量相同。 英石 PROGRAM rol_st\n\nVAR\n in_byte : BYTE := 16#45;\n in_word : WORD := 6#45;\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := ROL(in_byte,n); (* Result: 16#15 *)\n\nerg_word := ROL(in_word,n); (* Result: 16#0114 *) FBD 伊利诺伊州 " }, 
{ "title" : "运营商：ROR ", 
"url" : "_cds_operator_ror.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：ROR ", 
"snippet" : "ROR IEC 运算符用于将操作数按位向右旋转。 允许的数据类型： BYTE , WORD , DWORD , LWORD erg := ROR(in,n) CODESYS 移动 in n 次向右一位，然后将该位从左侧添加到最右边的位置。 位数 CODESYS 此操作的用途由 in 输入变量。如果这是一个常数，那么 CODESYS 使用尽可能小的数据类型。输出变量的数据类型仍然不会影响此操作。 例子 结果为 erg_byte 和 erg_word 根据输入变量的数据类型而有所不同，尽管 in_byte 和 in_word 输入变量相同。 英石 PROGRAM ror_st VAR in_byt...", 
"body" : "ROR IEC 运算符用于将操作数按位向右旋转。 允许的数据类型： BYTE , WORD , DWORD , LWORD erg := ROR(in,n) CODESYS 移动 in n 次向右一位，然后将该位从左侧添加到最右边的位置。 位数 CODESYS 此操作的用途由 in 输入变量。如果这是一个常数，那么 CODESYS 使用尽可能小的数据类型。输出变量的数据类型仍然不会影响此操作。 例子 结果为 erg_byte 和 erg_word 根据输入变量的数据类型而有所不同，尽管 in_byte 和 in_word 输入变量相同。 英石 PROGRAM ror_st\n\nVAR\n in_byte : BYTE := 16#45;\n in_word : WORD := 16#45;\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := ROR(in_byte,n); (* Result: 16#51 *)\nerg_word := ROR(in_word,n); (* Result: 16#4011 *) FBD " }, 
{ "title" : "运营商：SEL ", 
"url" : "_cds_operator_sel.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：SEL ", 
"snippet" : "SEL IEC 运算符用于按位选择。 OUT := SEL(G, IN0, IN1) 方法： OUT := IN0; 如果 G = FALSE OUT := IN1; 如果 G = TRUE 允许的数据类型 IN0 , …, INn 和 OUT : 任何相同的数据类型 确保在所有三个位置都使用相同类型的变量，尤其是在使用用户定义的数据类型时。编译器检查类型标识并返回任何编译错误。特别不支持将功能块实例分配给接口变量。 G ： BOOL CODESYS 计算一个表达式 IN0 是上游，而不是如果 G TRUE 是。 CODESYS 计算一个表达式 IN1 是上游，而不是如果 G FALSE 是。...", 
"body" : "SEL IEC 运算符用于按位选择。 OUT := SEL(G, IN0, IN1) 方法： OUT := IN0; 如果 G = FALSE OUT := IN1; 如果 G = TRUE 允许的数据类型 IN0 , …, INn 和 OUT : 任何相同的数据类型 确保在所有三个位置都使用相同类型的变量，尤其是在使用用户定义的数据类型时。编译器检查类型标识并返回任何编译错误。特别不支持将功能块实例分配给接口变量。 G ： BOOL CODESYS 计算一个表达式 IN0 是上游，而不是如果 G TRUE 是。 CODESYS 计算一个表达式 IN1 是上游，而不是如果 G FALSE 是。 注意：在图形编程语言的情况下，表达式 IN0 和 IN1 计算独立于 G 输入时 盒子 , 跳 , 返回 , 线支线 ， 或者 边缘检测 先于。 例子 英石 Var1 := SEL(TRUE,3,4); (* Result: 4 *) FBD " }, 
{ "title" : "操作员：MAX ", 
"url" : "_cds_operator_max.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：MAX ", 
"snippet" : "MAX IEC 运算符用于最大值函数。它返回所有输入中的最大值。 OUT := MAX(IN0,IN1,IN2,...) 允许的数据类型：所有 例子 分数：90 英石 Var1 := MAX(30,90,40); Var1 := MAX(40,MAX(90,30)); FBD...", 
"body" : "MAX IEC 运算符用于最大值函数。它返回所有输入中的最大值。 OUT := MAX(IN0,IN1,IN2,...) 允许的数据类型：所有 例子 分数：90 英石 Var1 := MAX(30,90,40);\n\nVar1 := MAX(40,MAX(90,30)); FBD " }, 
{ "title" : "操作员：MIN ", 
"url" : "_cds_operator_min.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：MIN ", 
"snippet" : "MIN IEC 运算符用于最小函数。它产生所有输入中的最小值。 OUT := MIN(IN0,IN1,IN2,...) 允许的数据类型：所有 例子 结果： 30 英石 Var1 := MIN(90,30,40); Var1 := MIN(MIN(90,30),40); FBD...", 
"body" : "MIN IEC 运算符用于最小函数。它产生所有输入中的最小值。 OUT := MIN(IN0,IN1,IN2,...) 允许的数据类型：所有 例子 结果： 30 英石 Var1 := MIN(90,30,40);\n\nVar1 := MIN(MIN(90,30),40); FBD " }, 
{ "title" : "运营商：LIMIT ", 
"url" : "_cds_operator_limit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：LIMIT ", 
"snippet" : "LIMIT IEC 选择运算符用于限制。 OUT := LIMIT(Min, IN, Max) 这意味着： OUT := MIN (MAX (IN, Min), Max) Max 是上限并且 Min 是结果的下限。如果 IN 值高于 Max 上限，然后 LIMIT 产量 Max .如果值 IN 低于 Min 下限，则结果为 Min . 允许的数据类型 IN 和 OUT ： 全部 例子 造成 Var1 ： 80 英石 Var1 := LIMIT(30,90,80);...", 
"body" : "LIMIT IEC 选择运算符用于限制。 OUT := LIMIT(Min, IN, Max) 这意味着： OUT := MIN (MAX (IN, Min), Max) Max 是上限并且 Min 是结果的下限。如果 IN 值高于 Max 上限，然后 LIMIT 产量 Max .如果值 IN 低于 Min 下限，则结果为 Min . 允许的数据类型 IN 和 OUT ： 全部 例子 造成 Var1 ： 80 英石 Var1 := LIMIT(30,90,80); " }, 
{ "title" : "操作员：MUX ", 
"url" : "_cds_operator_mux.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：MUX ", 
"snippet" : "MUX IEC 运算符用作多路复用器。 OUT := MUX(K, IN0,...,INn) 这意味着： OUT = IN_K 允许的数据类型 K ： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , LINT , ULINT UDINT IN0 , …, INn 和 OUT : 任何相同的数据类型 确保在所有三个位置都使用相同类型的变量，尤其是在使用用户定义的数据类型时。编译器检查类型标识并返回任何编译错误。特别不支持将功能块实例分配给接口变量。 MUX 从一组值中选择第 K 个值。第一个值是 K=0。如果 K ...", 
"body" : "MUX IEC 运算符用作多路复用器。 OUT := MUX(K, IN0,...,INn) 这意味着： OUT = IN_K 允许的数据类型 K ： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , LINT , ULINT UDINT IN0 , …, INn 和 OUT : 任何相同的数据类型 确保在所有三个位置都使用相同类型的变量，尤其是在使用用户定义的数据类型时。编译器检查类型标识并返回任何编译错误。特别不支持将功能块实例分配给接口变量。 MUX 从一组值中选择第 K 个值。第一个值是 K=0。如果 K 大于其他输入的数量 (n)，则 CODESYS 传递最后一个值 ( INn ）。 对于运行时优化， CODESYS 仅计算前面的表达式 IN_K .但是，在模拟模式下， CODESYS 计算所有分支。 例子 造成 Var1 ： 30 英石 Var1 := MUX(0,30,40,50,60,70,80); " }, 
{ "title" : "运营商：GT ", 
"url" : "_cds_operator_gt.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：GT ", 
"snippet" : "GT IEC 运算符用于“大于”功能。 操作数允许的数据类型：任何基本数据类型 如果第一个操作数大于第二个操作数，则运算符产生结果 TRUE ;否则 FALSE . 例子 结果：假 英石 VAR1 := 20 > 30; FBD...", 
"body" : "GT IEC 运算符用于“大于”功能。 操作数允许的数据类型：任何基本数据类型 如果第一个操作数大于第二个操作数，则运算符产生结果 TRUE ;否则 FALSE . 例子 结果：假 英石 VAR1 := 20 > 30; FBD " }, 
{ "title" : "操作员：LT ", 
"url" : "_cds_operator_lt.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：LT ", 
"snippet" : "LT IEC 运算符用于“小于”功能。 操作数允许的数据类型：任何基本数据类型 如果第一个操作数小于第二个操作数，则运算符产生结果 TRUE ;否则 FALSE . 例子 结果： TRUE 英石 Var1 := 20 < 30;...", 
"body" : "LT IEC 运算符用于“小于”功能。 操作数允许的数据类型：任何基本数据类型 如果第一个操作数小于第二个操作数，则运算符产生结果 TRUE ;否则 FALSE . 例子 结果： TRUE 英石 Var1 := 20 < 30; " }, 
{ "title" : "操作员：LE ", 
"url" : "_cds_operator_le.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：LE ", 
"snippet" : "LE IEC 运算符用于“小于或等于”功能。 操作数允许的数据类型：任何基本数据类型 如果第一个操作数小于或等于第二个操作数，则运算符产生结果 TRUE ;否则 FALSE . 例子 造成 Var1 ： TRUE 英石 Var1 := 20 <= 30;...", 
"body" : "LE IEC 运算符用于“小于或等于”功能。 操作数允许的数据类型：任何基本数据类型 如果第一个操作数小于或等于第二个操作数，则运算符产生结果 TRUE ;否则 FALSE . 例子 造成 Var1 ： TRUE 英石 Var1 := 20 <= 30; " }, 
{ "title" : "运营商：GE ", 
"url" : "_cds_operator_ge.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：GE ", 
"snippet" : "GE IEC 运算符用于“大于或等于”功能。 操作数允许的数据类型：任何基本数据类型 如果第一个操作数大于或等于第二个操作数，则运算符产生结果 TRUE ;否则 FALSE . 例子 结果： TRUE 英石 VAR1 := 60 >= 40; FBD...", 
"body" : "GE IEC 运算符用于“大于或等于”功能。 操作数允许的数据类型：任何基本数据类型 如果第一个操作数大于或等于第二个操作数，则运算符产生结果 TRUE ;否则 FALSE . 例子 结果： TRUE 英石 VAR1 := 60 >= 40; FBD " }, 
{ "title" : "操作员：EQ ", 
"url" : "_cds_operator_eq.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：EQ ", 
"snippet" : "EQ IEC 运算符比较两个操作数是否相等。 允许所有基本数据类型作为操作数的数据类型。 如果操作数相等，则运算符产生结果 TRUE ;否则 FALSE 。 例子 结果： VAR1 = TRUE 英石： \/\/ 实现 VAR1 := 20 = 20; FBD： 基本数据类型 基本数据类型可在中预定义 CODESYS Development System 。 除了 IEC 61131-3 中描述的数据类型之外，还有 CODESYS - 特定数据类型 BIT , __UXINT , __XINT ， 和 __XWORD 。 基本数据类型： __UXINT | __XINT | __XWORD | B...", 
"body" : "EQ IEC 运算符比较两个操作数是否相等。 允许所有基本数据类型作为操作数的数据类型。 如果操作数相等，则运算符产生结果 TRUE ;否则 FALSE 。 例子 结果： VAR1 = TRUE 英石： \/\/ 实现 VAR1 := 20 = 20; FBD： 基本数据类型 基本数据类型可在中预定义 CODESYS Development System 。 除了 IEC 61131-3 中描述的数据类型之外，还有 CODESYS - 特定数据类型 BIT , __UXINT , __XINT ， 和 __XWORD 。 基本数据类型： \n__UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD " }, 
{ "title" : "运营商：NE ", 
"url" : "_cds_operator_ne.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：NE ", 
"snippet" : "NE IEC 运算符比较两个操作数是否不相等。 允许所有基本数据类型作为操作数的数据类型。 如果操作数不相等，则运算符产生结果 TRUE ;否则 FALSE 。 例子 结果： Var1= FALSE 英石： Var1 := 40 <> 40; FBD： 基本数据类型 基本数据类型可在中预定义 CODESYS Development System 。 除了 IEC 61131-3 中描述的数据类型之外，还有 CODESYS - 特定数据类型 BIT , __UXINT , __XINT ， 和 __XWORD 。 基本数据类型： __UXINT | __XINT | __XWORD | BIT ...", 
"body" : "NE IEC 运算符比较两个操作数是否不相等。 允许所有基本数据类型作为操作数的数据类型。 如果操作数不相等，则运算符产生结果 TRUE ;否则 FALSE 。 例子 结果： Var1= FALSE 英石： Var1 := 40 <> 40; FBD： 基本数据类型 基本数据类型可在中预定义 CODESYS Development System 。 除了 IEC 61131-3 中描述的数据类型之外，还有 CODESYS - 特定数据类型 BIT , __UXINT , __XINT ， 和 __XWORD 。 基本数据类型： \n__UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD " }, 
{ "title" : "运营商：ADR ", 
"url" : "_cds_operator_adr.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：ADR ", 
"snippet" : "ADR 运算符是 IEC 61131-3 标准的扩展。 ADR 产生其参数的 32 位地址（或 64 位地址，如果可能）。您可以将此地址传递给制造商函数或将它们分配给项目中的指针。 句法 VAR <address name> : DWORD | LWORD | POINTER TO < basis data type> | __XWORD ; END_VAR <address name> := ADR( <variable name> ); FUNCTION_BLOCK FB_Adress VAR piAddress1: POINTER TO INT; iVar1 : INT := 5; lw...", 
"body" : "ADR searchresult_toplevel 运算符是 IEC 61131-3 标准的扩展。 ADR 产生其参数的 32 位地址（或 64 位地址，如果可能）。您可以将此地址传递给制造商函数或将它们分配给项目中的指针。 句法 VAR\n <address name> : DWORD | LWORD | POINTER TO < basis data type> | __XWORD ;\nEND_VAR\n\n<address name> := ADR( <variable name> ); FUNCTION_BLOCK FB_Adress\nVAR\n piAddress1: POINTER TO INT;\n iVar1 : INT := 5;\n\n lwAddress2 : LWORD;\n iVar2 : INT := 10;\n\n xwAddress3 : _XWORD;\n iVar3 : INT;\nEND_VAR\npiAddress1 := ADR(iVar1); \/\/ piNumber is assigned to address of iVar1\nlwAddress2 := ADR(iVar2); \/\/ works for 64 bit run time system\nxwAddress3 := ADR(iVar3); \/\/ works for 32 bit and 64 bit systems 不同于 CoDeSys V2.3 , 你可以使用 ADR 具有函数名称、程序名称、功能块名称和方法名称的运算符。所以， ADR 取代 INDEXOF 操作员。 使用函数指针时，请注意可以将函数指针传递给外部库，但不能从内部调用函数指针 CODESYS .要启用系统调用（运行时系统），您必须设置相应的对象属性 ( 建造 选项卡）用于功能对象。 当您使用在线更改时，地址的内容可能会发生变化。因此， 指向 变量可能指向无效的内存区域。为避免出现问题，您应该确保指针的值在每个周期中都更新。 不返回 Pointer-TO 将函数和方法的变量分配给调用者或将它们分配给全局变量。 " }, 
{ "title" : "运营商：内容运营商 ", 
"url" : "_cds_operator_content_operator.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：内容运营商 ", 
"snippet" : "内容运营商 运算符是 IEC 61131-3 标准的扩展。 运算符允许取消引用指针。您将运算符附加为 ^ 到指针标识符。 使用指向地址的指针时，请注意应用在线更改会改变地址的内容。 例子 英石 pt : POINTER TO INT; var_int1 : INT; var_int2 : INT; pt := ADR(var_int1); var_int2 := pt^;...", 
"body" : "内容运营商 运算符是 IEC 61131-3 标准的扩展。 运算符允许取消引用指针。您将运算符附加为 ^ 到指针标识符。 使用指向地址的指针时，请注意应用在线更改会改变地址的内容。 例子 英石 pt : POINTER TO INT;\nvar_int1 : INT;\nvar_int2 : INT;\npt := ADR(var_int1);\nvar_int2 := pt^; " }, 
{ "title" : "运营商：BITADR ", 
"url" : "_cds_operator_bitadr.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：BITADR ", 
"snippet" : "BITADR 运算符是 IEC 61131-3 标准的扩展。 BITADR 产生一个段内的位偏移量 DWORD . 偏移量取决于是否在目标系统设置中选择或清除了“字节寻址”选项。 此中的最高值半字节（4 位） DWORD 定义内存范围。 标记 M ： 16#40000000 输入 I ： 16#80000000 输出 Q ： 16#C0000000 使用指向地址的指针时，请注意应用在线更改会改变地址的内容。 例子 ST 实现语言 VAR xVar AT %IX2.3 : BOOL; dwBitoffset : DWORD; END_VAR dwBitoffset := BITADR(xVar)...", 
"body" : "BITADR searchresult_toplevel 运算符是 IEC 61131-3 标准的扩展。 BITADR 产生一个段内的位偏移量 DWORD . 偏移量取决于是否在目标系统设置中选择或清除了“字节寻址”选项。 此中的最高值半字节（4 位） DWORD 定义内存范围。 标记 M ： 16#40000000 输入 I ： 16#80000000 输出 Q ： 16#C0000000 使用指向地址的指针时，请注意应用在线更改会改变地址的内容。 例子 ST 实现语言 VAR\n xVar AT %IX2.3 : BOOL;\n dwBitoffset : DWORD;\nEND_VAR\n\ndwBitoffset := BITADR(xVar); (* If byte addressing = TRUE, result = 16#80000013; if byte addressing = FALSE, result = 16#80000023 *) " }, 
{ "title" : "操作员：CAL ", 
"url" : "_cds_operator_cal.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：CAL ", 
"snippet" : "CAL IEC 运算符用于调用功能块。 在伊利诺伊州， CAL 调用功能块的实例。 CAL <function block> (<input variable1> := <value>, <input variableN> := <value>) 例子 的召唤 Inst 具有赋值的功能块实例 Par1 和 Par2 输入变量 0 或者 TRUE CAL Inst(Par1 := 0, Par2 := TRUE);...", 
"body" : "CAL IEC 运算符用于调用功能块。 在伊利诺伊州， CAL 调用功能块的实例。 CAL <function block> (<input variable1> := <value>, <input variableN> := <value>) 例子 的召唤 Inst 具有赋值的功能块实例 Par1 和 Par2 输入变量 0 或者 TRUE CAL Inst(Par1 := 0, Par2 := TRUE); " }, 
{ "title" : "操作员：ABS ", 
"url" : "_cds_operator_abs.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：ABS ", 
"snippet" : "ABS IEC 运算符产生一个数字的绝对值。 输入和输出变量和数字常量的允许数据类型：任何数字基本数据类型 例子 造成 i ： 2 英石 i := ABS(-2); FBD...", 
"body" : "ABS IEC 运算符产生一个数字的绝对值。 输入和输出变量和数字常量的允许数据类型：任何数字基本数据类型 例子 造成 i ： 2 英石 i := ABS(-2); FBD " }, 
{ "title" : "运营商：SQRT ", 
"url" : "_cds_operator_sqrt.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：SQRT ", 
"snippet" : "SQRT IEC 运算符产生数字的平方根。 输入变量允许的数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 造成 q ： 4 英石 q := SQRT(16); FBD...", 
"body" : "SQRT IEC 运算符产生数字的平方根。 输入变量允许的数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 造成 q ： 4 英石 q := SQRT(16); FBD " }, 
{ "title" : "操作员：LN ", 
"url" : "_cds_operator_ln.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：LN ", 
"snippet" : "LN IEC 运算符产生一个数字的自然对数。 输入变量允许的数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 造成 q ： 3.80666 英石 q := LN(45); FBD...", 
"body" : "LN IEC 运算符产生一个数字的自然对数。 输入变量允许的数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 造成 q ： 3.80666 英石 q := LN(45); FBD " }, 
{ "title" : "操作员：LOG ", 
"url" : "_cds_operator_log.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：LOG ", 
"snippet" : "LOG IEC 运算符产生一个数字的以 10 为底的对数。 输入变量可以是任何数值基本数据类型，但输出变量必须是数据类型 REAL 或者 LREAL . 例子 造成 q ： 2.49762 英石 q := LOG(314.5); FBD...", 
"body" : "LOG searchresult_toplevel IEC 运算符产生一个数字的以 10 为底的对数。 输入变量可以是任何数值基本数据类型，但输出变量必须是数据类型 REAL 或者 LREAL . 例子 造成 q ： 2.49762 英石 q := LOG(314.5); FBD " }, 
{ "title" : "操作员：EXP ", 
"url" : "_cds_operator_exp.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：EXP ", 
"snippet" : "EXP IEC 算子产生指数函数。 输入变量允许的数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 造成 q ： 7.389056099 英石 q := EXP(2); FBD...", 
"body" : "EXP IEC 算子产生指数函数。 输入变量允许的数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 造成 q ： 7.389056099 英石 q := EXP(2); FBD " }, 
{ "title" : "操作员：EXPT ", 
"url" : "_cds_operator_expt.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：EXPT ", 
"snippet" : "EXPT IEC 运算符将一个数提高到更高的幂，然后将基数的幂返回到指数：power = base 指数 .输入值（参数）是基数和指数。如果底数为零且指数为负数，则幂函数未定义。但是，在这种情况下，行为取决于平台。 句法 EXPT(<base>,<exponent>) 输入值允许的数据类型：数字基本数据类型 ( SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , BYTE , WORD , DWORD ， 和 LWORD ) 返回值允许的数据类型：浮点数类型（ REAL 和 LREAL ) 例子 带文...", 
"body" : "EXPT IEC 运算符将一个数提高到更高的幂，然后将基数的幂返回到指数：power = base 指数 .输入值（参数）是基数和指数。如果底数为零且指数为负数，则幂函数未定义。但是，在这种情况下，行为取决于平台。 句法 EXPT(<base>,<exponent>) 输入值允许的数据类型：数字基本数据类型 ( SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , BYTE , WORD , DWORD ， 和 LWORD ) 返回值允许的数据类型：浮点数类型（ REAL 和 LREAL ) 例子 带文字的幂函数 Var1 := EXPT(7,2); FBD 返回值： Var1 = 49 例子 带变量的幂函数 PROGRAM PLC_PRG\nVAR\n lrPow : LREAL;\n iBase : INT := 2;\n iExponent : INT := 7;\nEND_VAR\n\nlrPow := EXPT(iBase, iExponent); 返回值： lrPow = 128 " }, 
{ "title" : "运营商：SIN ", 
"url" : "_cds_operator_sin.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：SIN ", 
"snippet" : "SIN IEC 运算符产生一个数字的正弦值。 以弧度为单位测量角度的输入变量的允许数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 输入值的允许范围是 -2 63 到 +2 63 .在 x86 和 x64 系统上：如果输入值超出允许范围，则函数返回输入值。 例子 造成 q ： 0.479426 . 英石 q := SIN (0.5); FUP...", 
"body" : "SIN IEC 运算符产生一个数字的正弦值。 以弧度为单位测量角度的输入变量的允许数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 输入值的允许范围是 -2 63 到 +2 63 .在 x86 和 x64 系统上：如果输入值超出允许范围，则函数返回输入值。 例子 造成 q ： 0.479426 . 英石 q := SIN (0.5); FUP " }, 
{ "title" : "运营商：COS ", 
"url" : "_cds_operator_cos.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：COS ", 
"snippet" : "COS IEC 运算符产生一个数字的余弦值。 以弧度为单位测量角度的输入变量的允许数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 输入值的允许范围是 -2 63 到 +2 63 .在 x86 和 x64 系统上：如果输入值超出允许范围，则函数返回输入值。 例子 造成 q ： 0.877583 英石 q := COS(0.5); FBD...", 
"body" : "COS IEC 运算符产生一个数字的余弦值。 以弧度为单位测量角度的输入变量的允许数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 输入值的允许范围是 -2 63 到 +2 63 .在 x86 和 x64 系统上：如果输入值超出允许范围，则函数返回输入值。 例子 造成 q ： 0.877583 英石 q := COS(0.5); FBD " }, 
{ "title" : "操作员：TAN ", 
"url" : "_cds_operator_tan.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：TAN ", 
"snippet" : "TAN IEC 运算符产生一个数字的正切值。 以弧度为单位测量角度的输入变量的允许数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 造成 q ： 0.546302 英石 q := TAN(0.5); FBD...", 
"body" : "TAN IEC 运算符产生一个数字的正切值。 以弧度为单位测量角度的输入变量的允许数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 造成 q ： 0.546302 英石 q := TAN(0.5); FBD " }, 
{ "title" : "运营商：ASIN ", 
"url" : "_cds_operator_asin.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：ASIN ", 
"snippet" : "ASIN IEC 运算符产生一个数字的反正弦值。 输入变量允许的数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 造成 q ： 0.523599 英石 q := ASIN(0,5); FBD...", 
"body" : "ASIN IEC 运算符产生一个数字的反正弦值。 输入变量允许的数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 造成 q ： 0.523599 英石 q := ASIN(0,5); FBD " }, 
{ "title" : "运营商：ACOS ", 
"url" : "_cds_operator_acos.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：ACOS ", 
"snippet" : "ACOS IEC 运算符产生一个数字的反余弦值。该值以弧度计算。 以弧度为单位测量角度的输入变量的允许数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 结果 q：1.0472 英石 q := ACOS(0.5); FBD...", 
"body" : "ACOS IEC 运算符产生一个数字的反余弦值。该值以弧度计算。 以弧度为单位测量角度的输入变量的允许数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 结果 q：1.0472 英石 q := ACOS(0.5); FBD " }, 
{ "title" : "运营商：ATAN ", 
"url" : "_cds_operator_atan.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：ATAN ", 
"snippet" : "ATAN IEC 运算符产生一个数字的反正切值。该值以弧度计算。 以弧度为单位测量角度的输入变量的允许数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 造成 q ： 0.463648 英石 q := ATAN(0.5); FBD...", 
"body" : "ATAN IEC 运算符产生一个数字的反正切值。该值以弧度计算。 以弧度为单位测量角度的输入变量的允许数据类型：任何数字基本数据类型 输出变量允许的数据类型： REAL 和 LREAL 例子 造成 q ： 0.463648 英石 q := ATAN(0.5); FBD " }, 
{ "title" : "运算符：__DELETE ", 
"url" : "_cds_operator_delete.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：__DELETE ", 
"snippet" : "__DELETE 运算符是 IEC 61131-3 标准的扩展。 为了兼容性，编译器版本必须 >= 3.3.2.0。 运算符释放“__NEW”运算符动态生成的实例的内存。这 __DELETE 运算符没有返回值，并且在此操作后操作数设置为零。 要求： 使用动态内存分配 选项被选中 应用程序构建选项 应用程序属性对话框中的选项卡。 __DELETE (<pointer>) 两个任务不应同时调用 __DELETE。您可以使用信号量 (SysSemEnter) 或类似方法来防止 __DELETE 的任何并发调用，或者仅在一个任务中使用 __DELETE（推荐）。 您可以使用信号量 (SysSemEnt...", 
"body" : "__DELETE 运算符是 IEC 61131-3 标准的扩展。 为了兼容性，编译器版本必须 >= 3.3.2.0。 运算符释放“__NEW”运算符动态生成的实例的内存。这 __DELETE 运算符没有返回值，并且在此操作后操作数设置为零。 要求： 使用动态内存分配 选项被选中 应用程序构建选项 应用程序属性对话框中的选项卡。 __DELETE (<pointer>) 两个任务不应同时调用 __DELETE。您可以使用信号量 (SysSemEnter) 或类似方法来防止 __DELETE 的任何并发调用，或者仅在一个任务中使用 __DELETE（推荐）。 您可以使用信号量 (SysSemEnter) 来防止两个任务同时分配内存。因此，广泛使用 __DELETE 导致更高的抖动。 如果 Pointer 引用一个功能块，然后 CODESYS 调用相关的 FB_EXIT 指针设置为零之前的方法。 例子 功能块 FUNCTION_BLOCK FBDynamic\n\nVAR_INPUT\n in1, in2 : INT;\nEND_VAR\n\nVAR_OUTPUT\n out : INT;\nEND_VAR\n\nVAR\n test1 : INT := 1234;\n _inc : INT := 0;\n _dut : POINTER TO DUT;\n neu : BOOL;\nEND_VAR\n\nout := in1 + in2;\n 方法 （ FB_Exit ） METHOD FB_Exit : BOOL\n\nVAR_INPUT\n bInCopyCode : BOOL;\nEND_VAR\n\n__Delete(_dut);\n 方法 （ FB_Init ） METHOD FB_Init : BOOL\n\nVAR_INPUT\n bInitRetains : BOOL;\n bInCopyCode : BOOL;\nEND_VAR\n\n_dut := __NEW(DUT);\n 方法 METHOD INC : INT\n\nVAR_INPUT\nEND_VAR\n\n_inc := _inc + 1;\nINC := _inc;\n 程序 PLC_PRG(PRG)\n\nVAR\n pFB : POINTER TO FBDynamic;\n bInit: BOOL := TRUE;\n bDelete: BOOL;\n loc : INT;\nEND_VAR\n\nIF (bInit) THEN\n pFB := __NEW(FBDynamic);\n bInit := FALSE;\nEND_IF\n\nIF (pFB <> 0) THEN\n pFB^(in1 := 1, in2 := loc, out => loc);\n pFB^.INC();\nEND_IF\n\nIF (bDelete) THEN\n __DELETE(pFB);\nEND_IF " }, 
{ "title" : "运算符：__ISVALIDREF ", 
"url" : "_cds_operator_isvalidref.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：__ISVALIDREF ", 
"snippet" : "__ISVALIDREF 运算符是 IEC 61131-3 标准的扩展。 运算符用于检查引用是否指向有效值。应用程序的描述和示例可以在数据类型的描述中找到 REFERENCE ....", 
"body" : "__ISVALIDREF 运算符是 IEC 61131-3 标准的扩展。 运算符用于检查引用是否指向有效值。应用程序的描述和示例可以在数据类型的描述中找到 REFERENCE . " }, 
{ "title" : "运营商：__NEW ", 
"url" : "_cds_operator_new.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：__NEW ", 
"snippet" : "__NEW 运算符是 IEC 61131-3 标准的扩展。 这 __NEW 运算符保留动态内存以实例化功能块、用户定义的数据类型或标准类型的数组。运算符返回一个匹配的类型指针。 要求：在父应用程序的属性对话框中，在 应用程序构建选项 制表符 使用动态内存分配 选项被选中。 句法 <pointer name> := __NEW( <type> ( , <size> )? ); __DELETE( <pointer name> ); <type> : <function block> | <data unit type> | <standard data type> 运算符生成类型的实例 <typ...", 
"body" : "__NEW 运算符是 IEC 61131-3 标准的扩展。 这 __NEW 运算符保留动态内存以实例化功能块、用户定义的数据类型或标准类型的数组。运算符返回一个匹配的类型指针。 要求：在父应用程序的属性对话框中，在 应用程序构建选项 制表符 使用动态内存分配 选项被选中。 句法 <pointer name> := __NEW( <type> ( , <size> )? );\n__DELETE( <pointer name> );\n\n<type> : <function block> | <data unit type> | <standard data type> 运算符生成类型的实例 <type> 并返回一个指向该实例的指针。然后调用实例的初始化。如果 <type> 是标量标准数据类型，然后是可选操作数 <size> 也被评估。然后操作符生成一个类型的数组 <standard data type> 和大小 <size> .如果分配内存的尝试失败，则 __NEW 返回值 0 . 在赋值中使用运算符 \" := \"; 否则会显示错误消息。 一个功能块或用户定义的数据类型，其实例是动态创建的 __NEW 使用固定的内存区域。这里需要你用 pragma 标记对象 {attribute 'enable_dynamic_creation'} .作为库一部分的功能块不需要它。 如果在在线模式下更改功能块的数据布局，则无法在之后执行在线更改的登录。这是因为功能块实例的内存区域已经失效。当您向功能块添加新变量、删除现有变量或更改变量的数据类型时，您会更改数据布局。 例子 大批 （ DWORD ) PROGRAM PLC_PRG\nVAR\n pdwScalar : POINTER TO DWORD; \/\/Typed pointer\n xInit : BOOL := TRUE;\n xDelete : BOOL;\nEND_VAR\n\nIF (xInit) THEN\n pdwScalar := __NEW(DWORD, 16); \/\/ Allocates memory (16 dwords) and assigns them to pointer pdwScalar\nEND_IF\nIF (xDelete) THEN\n __DELETE(pdwScalar); \/\/ Frees memory of pointer\nEND_IF 功能块 {attribute 'enable_dynamic_creation'}\nFUNCTION_BLOCK FBComputeGamma\nVAR_INPUT\n iAlpha : INT;\n iBeta : INT;\nEND_VAR\nVAR_OUTPUT\n iGamma : INT;\nEND_VAR\nVAR\nEND_VAR\n\niGamma := iAlpha + iBeta;\n\nPROGRAM PLC_PRG\nVAR\n pComputeGamma : POINTER TO FBComputeGamma; \/\/ Typed pointer\n xInit : BOOL := TRUE;\n xDelete : BOOL;\n iResult : INT;\nEND_VAR\n\nIF (xInit) THEN\n pComputeGamma := __NEW(FBComputeGamma); \/\/ Allocates memory\n xInit := FALSE;\nEND_IF\npComputeGamma^.iAlpha := (pComputeGamma^.iAlpha + 1)MOD 100; \/\/ Sets first input of pComputeGamma\npComputeGamma^.iBeta := 10; \/\/ Sets second input of pComputeGamma\npComputeGamma^(); \/\/ Calls the FB pComputeGamma is pointing to\niResult := pComputeGamma^.iGamma; \/\/ Reads output of pComputeGamma\nIF (xDelete) THEN\n __DELETE(pComputeGamma); \/\/ Frees memory\nEND_IF 用户定义的数据类型 (DUT) {attribute 'enable_dynamic_creation'}\nTYPE ABCDATA :\nSTRUCT\n iA, iB, iC, iD : INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n pABCData : POINTER TO ABCDATA; \/\/ Typed pointer\n xInit : BOOL := TRUE;\n xDelete : BOOL;\nEND_VAR\n\nIF (xInit) THEN\n pABCData := __NEW(ABCDATA); \/\/ Allocates memory\n xInit := FALSE;\nEND_IF\nIF (xDelete) THEN\n __DELETE(pABCData); \/\/ Frees memory\nEND_IF 数组（字节） PROGRAM PLC_PRG\nVAR\n pbDataAlpha : POINTER TO BYTE;\n pbDataBeta : POINTER TO BYTE;\n xInit : BOOL := TRUE;\n xDelete : BOOL;\n usiCnt : USINT;\n bTestC: BYTE;\nEND_VAR\n\nIF (xInit) THEN\n pbDataAlpha := __NEW(BYTE, 16); \/\/ Allocates 16 bytes for pbDataAlpha\n pbDataBeta := __NEW(BYTE); \/\/ Allocates memory for pbDataBeta\n xInit := FALSE;\n\n FOR usiCnt := 0 TO 15 DO\n pbDataAlpha[usiCnt] := usiCnt; \/\/ Writes to new array\n END_FOR\n pbDataBeta^:= 16#FF; \/\/ Writes to new data\nEND_IF\n\nbTestC := pbDataAlpha[12]; \/\/ Reads new array by index access\n\nIF (xDelete) THEN \/\/ Frees memory\n __DELETE(pbDataAlpha);\n __DELETE(pbDataBeta);\nEND_IF 我们不建议同时执行两个调用 __NEW 操作员。您可以使用信号量 ( SysSemEnter ) 或类似的技术来防止同时调用 __NEW .然而，这会导致更高的抖动时 __NEW 被广泛应用。 我们建议您致电 __NEW 仅在一项任务中的操作员。 " }, 
{ "title" : "运算符：__QUERYINTERFACE ", 
"url" : "_cds_operator_queryinterface.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：__QUERYINTERFACE ", 
"snippet" : "__QUERYINTERFACE 运算符是 IEC 61131-3 标准的扩展。 在运行时，操作符执行一个接口引用到另一种类型的类型转换。运算符返回一个 BOOL 结果。 TRUE 意思是 CODESYS 已成功执行转换。 __QUERYINTERFACE(<ITF_Source>,<ITF_Dest>); 第一个操作数：接口引用或 FB 接口 第二个操作数：具有所需目标类型的接口引用 显式转换的要求是 ITF_Source 和 ITF_Dest 都来自 Interface __System.IQueryInterface .这个接口是隐式可用的，不需要库。 例子 INTERFACE ItfB...", 
"body" : "__QUERYINTERFACE 运算符是 IEC 61131-3 标准的扩展。 在运行时，操作符执行一个接口引用到另一种类型的类型转换。运算符返回一个 BOOL 结果。 TRUE 意思是 CODESYS 已成功执行转换。 __QUERYINTERFACE(<ITF_Source>,<ITF_Dest>); 第一个操作数：接口引用或 FB 接口 第二个操作数：具有所需目标类型的接口引用 显式转换的要求是 ITF_Source 和 ITF_Dest 都来自 Interface __System.IQueryInterface .这个接口是隐式可用的，不需要库。 例子 INTERFACE ItfBase EXTENDS __System.IQueryInterface\nMETHOD mbase : BOOL\nEND_METHOD\n\nINTERFACE ItfDerived1 EXTENDS ItfBase\nMETHOD mderived1 : BOOL\nEND_METHOD\n\nINTERFACE ItfDerived2 EXTENDS ItfBase\nMETHOD mderived2 : BOOL\nEND_METHOD\n\nFUNCTION_BLOCK FB1 IMPLEMENTS ItfDerived1\nMETHOD mbase : BOOL\n mbase := TRUE;\nEND_METHOD\nMETHOD mderived1 : BOOL\n mderived1 := TRUE;\nEND_METHOD\nEND_FUNCTION_BLOCK\n\nFUNCTION_BLOCK FB2 IMPLEMENTS ItfDerived2\nMETHOD mbase : BOOL\n mbase := FALSE;\nEND_METHOD\nMETHOD mderived2 : BOOL\n mderived2 := TRUE;\nEND_METHOD\nEND_FUNCTION_BLOCK\n\nPROGRAMM POU\nVAR\n inst1 : FB1;\n inst2 : FB2;\n itfbase1 : ItfBase := inst1;\n itfbase2 : ItfBase := inst2;\n itfderived1 : ItfDerived1 := 0;\n itfderived2 : ItfDerived2 := 0;\n xResult1, xResult2, xResult3, xResult4: BOOL;\nEND_VAR\n\n\nxResult1 := __QUERYINTERFACE(itfbase1, itfderived1); \/\/ xResult = TRUE, itfderivedi1 <>0\n \/\/ references the instance inst1\nxResult2 := __QUERYINTERFACE(itfbase1, itfderived2); \/\/ xResult = FALSE, itfderived2 = 0\nxResult3 := __QUERYINTERFACE(itfbase2, itfderived1); \/\/ xResult = FALSE, itfderived1 = 0\nxResult4 := __QUERYINTERFACE(itfbase2, itfderived2); \/\/ xResult = TRUE, itfderived2 <> 0\n \/\/ references the instance inst2 " }, 
{ "title" : "运算符：__QUERYPOINTER ", 
"url" : "_cds_operator_querypointer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：__QUERYPOINTER ", 
"snippet" : "__QUERYPOINTER 运算符是 IEC 61131-3 标准的扩展。 在运行时，操作符可以将功能块的接口引用类型转换为指针。运算符返回一个 BOOL 结果。 TRUE 意思是 CODESYS 已成功执行转换。 为了兼容性，要转换的指针的定义必须是基接口“__SYSTEM.IQueryInterface”的扩展。 __QUERYPOINTER ( <ITF_Source>, <Pointer_Dest> ) 运算符接收接口引用或 FB 实例，其中所需的目标类型作为第一个操作数，指针作为第二个操作数。处理后 __QUERYPOINTER , Pointer_Dest 接收指向 ITF_So...", 
"body" : "__QUERYPOINTER 运算符是 IEC 61131-3 标准的扩展。 在运行时，操作符可以将功能块的接口引用类型转换为指针。运算符返回一个 BOOL 结果。 TRUE 意思是 CODESYS 已成功执行转换。 为了兼容性，要转换的指针的定义必须是基接口“__SYSTEM.IQueryInterface”的扩展。 __QUERYPOINTER ( <ITF_Source>, <Pointer_Dest> ) 运算符接收接口引用或 FB 实例，其中所需的目标类型作为第一个操作数，指针作为第二个操作数。处理后 __QUERYPOINTER , Pointer_Dest 接收指向 ITF_Source 接口引用当前引用的功能块的引用或实例的指针。 Pointer_Dest 没有类型，可以转换为任何类型。你必须确定类型。例如，接口可以提供一个返回类型代码的方法。 " }, 
{ "title" : "运算符：__TRY、__CATCH、__FINALLY、__ENDTRY ", 
"url" : "_cds_operator_try_catch_finally_endtry.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：__TRY、__CATCH、__FINALLY、__ENDTRY ", 
"snippet" : "__TRY, __CATCH, __FINALLY, __ENDTRY 这些运算符是从 IEC 61131-3 标准扩展而来的，它们用于 IEC 代码中的特定异常处理。 句法 __TRY <statements_try> __CATCH(exec) <statements_catch> __FINALLY <statements_finally> __ENDTRY <statements_next> 当声明中的 __Try 运算符抛出异常，应用程序不会停止。相反，它执行下面的语句 __Catch 因此开始异常处理。然后它执行下面的指令 __FINALLY .异常处理以 __ENDTRY .然后...", 
"body" : "__TRY, __CATCH, __FINALLY, __ENDTRY 这些运算符是从 IEC 61131-3 标准扩展而来的，它们用于 IEC 代码中的特定异常处理。 句法 __TRY\n <statements_try>\n__CATCH(exec)\n <statements_catch>\n__FINALLY\n <statements_finally>\n__ENDTRY\n <statements_next> 当声明中的 __Try 运算符抛出异常，应用程序不会停止。相反，它执行下面的语句 __Catch 因此开始异常处理。然后它执行下面的指令 __FINALLY .异常处理以 __ENDTRY .然后应用程序执行下一条语句。 异常的 IEC 变量具有数据类型 __System.ExceptionCode . 例子 如果声明在 __TRY 抛出异常，则程序执行不会停止。相反，中的声明 __CATCH 被执行。因此，在本例中 exc 函数被执行，然后下面的语句 __FINALLY .然后它执行下面的指令 __FINALLY . FUNCTION Tester : UDINT\nVAR_INPUT\n count : UDINT;\nEND_VAR\nVAR_OUTPUT\n strExceptionText : STRING;\nEND_VAR\nVAR\n exc : __SYSTEM.ExceptionCode;\nEND_VAR\n\n__TRY\nTester := tryFun(count := count, testcase := g_testcase); \/\/This instruction is tested. If it produces an exception, the statement under __CATCH is executed first and then the statement under __FINALLY.\n__CATCH(exc)\nHandleException(exc, strExceptionText => strExceptionText);\n__FINALLY\nGVL.g_count := GVL.g_count + 2;\n__ENDTRY 有关更多信息，请参阅： 在处理的异常处停止执行数据类型“__System.ExceptionCode” TYPE ExceptionCode :\n(\n\nRTSEXCPT_UNKNOWN := 16#FFFFFFFF,\nRTSEXCPT_NOEXCEPTION := 16#00000000,\nRTSEXCPT_WATCHDOG := 16#00000010,\nRTSEXCPT_HARDWAREWATCHDOG := 16#00000011,\nRTSEXCPT_IO_CONFIG_ERROR := 16#00000012,\nRTSEXCPT_PROGRAMCHECKSUM := 16#00000013,\nRTSEXCPT_FIELDBUS_ERROR := 16#00000014,\nRTSEXCPT_IOUPDATE_ERROR := 16#00000015,\nRTSEXCPT_CYCLE_TIME_EXCEED := 16#00000016,\nRTSEXCPT_ONLCHANGE_PROGRAM_EXCEEDED := 16#00000017,\nRTSEXCPT_UNRESOLVED_EXTREFS := 16#00000018,\nRTSEXCPT_DOWNLOAD_REJECTED := 16#00000019,\nRTSEXCPT_BOOTPROJECT_REJECTED_DUE_RETAIN_ERROR := 16#0000001A,\nRTSEXCPT_LOADBOOTPROJECT_FAILED := 16#0000001B,\nRTSEXCPT_OUT_OF_MEMORY := 16#0000001C,\nRTSEXCPT_RETAIN_MEMORY_ERROR := 16#0000001D,\nRTSEXCPT_BOOTPROJECT_CRASH := 16#0000001E,\nRTSEXCPT_BOOTPROJECTTARGETMISMATCH := 16#00000021,\nRTSEXCPT_SCHEDULEERROR := 16#00000022,\nRTSEXCPT_FILE_CHECKSUM_ERR := 16#00000023,\nRTSEXCPT_RETAIN_IDENTITY_MISMATCH := 16#00000024,\nRTSEXCPT_IEC_TASK_CONFIG_ERROR := 16#00000025,\nRTSEXCPT_APP_TARGET_MISMATCH := 16#00000026,\nRTSEXCPT_ILLEGAL_INSTRUCTION := 16#00000050,\nRTSEXCPT_ACCESS_VIOLATION := 16#00000051,\nRTSEXCPT_PRIV_INSTRUCTION := 16#00000052,\nRTSEXCPT_IN_PAGE_ERROR := 16#00000053,\nRTSEXCPT_STACK_OVERFLOW := 16#00000054,\nRTSEXCPT_INVALID_DISPOSITION := 16#00000055,\nRTSEXCPT_INVALID_HANDLE := 16#00000056,\nRTSEXCPT_GUARD_PAGE := 16#00000057,\nRTSEXCPT_DOUBLE_FAULT := 16#00000058,\nRTSEXCPT_INVALID_OPCODE := 16#00000059,\nRTSEXCPT_MISALIGNMENT := 16#00000100,\nRTSEXCPT_ARRAYBOUNDS := 16#00000101,\nRTSEXCPT_DIVIDEBYZERO := 16#00000102,\nRTSEXCPT_OVERFLOW := 16#00000103,\nRTSEXCPT_NONCONTINUABLE := 16#00000104,\nRTSEXCPT_PROCESSORLOAD_WATCHDOG := 16#00000105,\nRTSEXCPT_FPU_ERROR := 16#00000150,\nRTSEXCPT_FPU_DENORMAL_OPERAND := 16#00000151,\nRTSEXCPT_FPU_DIVIDEBYZERO := 16#00000152,\nRTSEXCPT_FPU_INEXACT_RESULT := 16#00000153,\nRTSEXCPT_FPU_INVALID_OPERATION := 16#00000154,\nRTSEXCPT_FPU_OVERFLOW := 16#00000155,\nRTSEXCPT_FPU_STACK_CHECK := 16#00000156,\nRTSEXCPT_FPU_UNDERFLOW := 16#00000157,\nRTSEXCPT_VENDOR_EXCEPTION_BASE := 16#00002000,\nRTSEXCPT_USER_EXCEPTION_BASE := 16#00010000\n) UDINT ;\nEND_TYPE " }, 
{ "title" : "运算符：__VARINFO ", 
"url" : "_cds_operator_varinfo.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：__VARINFO ", 
"snippet" : "__VARINFO 运算符是 IEC 61131-3 标准的扩展。 运算符产生有关变量的信息。您可以将信息作为数据结构保存在数据类型的变量中 __SYSTEM.VAR_INFO . 声明中的语法 <name of the info variable> : __SYSTEM.VAR_INFO; \/\/ Data structure for info variable 调用语法 <name of the info variable> := __VARINFO( <variable name> ); \/\/ Call of the operator 例子 FUNCTION_BLOCK FB_Veloci...", 
"body" : "__VARINFO 运算符是 IEC 61131-3 标准的扩展。 运算符产生有关变量的信息。您可以将信息作为数据结构保存在数据类型的变量中 __SYSTEM.VAR_INFO . 声明中的语法 <name of the info variable> : __SYSTEM.VAR_INFO; \/\/ Data structure for info variable 调用语法 <name of the info variable> := __VARINFO( <variable name> ); \/\/ Call of the operator 例子 FUNCTION_BLOCK FB_Velocity\nVAR_INPUT\n rVelocity: REAL := 1.2;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n infoVelocity: __SYSTEM.VAR_INFO; \/\/Info of Velocity\nEND_VAR\n\ninfoVelocity := __VARINFO(rVelocity); \/\/ Gets the info of Velocity locally PROGRAM PLC_PRG\nVAR\n iCounter : INT := 0; \/\/ Counts the calls\n infoCounter : __SYSTEM.VAR_INFO; \/\/Info of Counter\n arrA : ARRAY [1..2, 1..2, 1..2] OF INT := [0, 1, 2, 3, 4, 5, 6, 7]; \/\/ Stores the A data\n infoA : __SYSTEM.VAR_INFO; \/\/Info of A\n fbVel : FB_Velocity;\nEND_VAR\n\niCounter := iCounter + 1;\ninfoCounter := __VARINFO(iCounter);\ninfoA := __VARINFO(arrA);\nfbVel(); 这 iCounter 和 arrA 变量在应用程序代码中被识别。变量信息保存在 infoCounter 和 infoA 变量。此外， FB_Velocity 功能块被实例化。 " }, 
{ "title" : "数据类型：__SYSTEM.VAR_INFO ", 
"url" : "_cds_operator_varinfo.html#UUID-a5c59974-aff9-8df3-9a5d-66a904a67842_id_bfe36bd11d79fbf5c0a86463350fcaac_id_f26a4b1dd3c4781cc0a86463447d5db7", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：__VARINFO \/ 数据类型：__SYSTEM.VAR_INFO ", 
"snippet" : "名称 数据类型 初始化 描述 ByteAddress DWORD 0 变量地址 例子： 16#072E35EC 注意：对于变量的位访问 <variable name>.<bit index> ，给出包含该位的变量的地址。 ByteOffset DWORD 0 变量地址的偏移量（以字节为单位） 例子： 13936 字节 注意：如果变量是全局的，那么偏移量是相对于区域的开始的。如果变量是函数或方法中的局部变量，则偏移量是相对于当前堆栈帧的。如果变量是功能块中的局部变量，则偏移量是相对于功能块实例的。 Area DINT 0 存储区号 Area 在运行时系统中 例子： -1 表示该变量在内存中不是全...", 
"body" : "名称 数据类型 初始化 描述 ByteAddress DWORD 0 变量地址 例子： 16#072E35EC 注意：对于变量的位访问 <variable name>.<bit index> ，给出包含该位的变量的地址。 ByteOffset DWORD 0 变量地址的偏移量（以字节为单位） 例子： 13936 字节 注意：如果变量是全局的，那么偏移量是相对于区域的开始的。如果变量是函数或方法中的局部变量，则偏移量是相对于当前堆栈帧的。如果变量是功能块中的局部变量，则偏移量是相对于功能块实例的。 Area DINT 0 存储区号 Area 在运行时系统中 例子： -1 表示该变量在内存中不是全局的，而是相对于一个实例或堆栈上的 注意：内存区域取决于设备。 BitNr INT 0 位数（以字节为单位） 例子： 16#00FF 字节 注意：如果变量是 不是 整数数据类型，然后： BitNr = -1 = 16#FFFF BitSize INT 0 变量的内存大小（以位为单位） 例子： 16 位 BitAddress UDINT 0 变量的位地址 要求：变量位于输入内存区 I , 输出内存区域 Q , 或标记存储区 M .否则该值未定义。 TypeClass TYPE_CLASS TYPE_BOOL 变量的数据类型类 例子： TYPE_INT , TYPE_ARRAY 注意：对于用户定义的数据类型或功能块实例， TYPE_USERDEF 作为数据类型类输出。 TypeName STRING(79) '' 变量的日期类型名称为 STRING(79) 注意：对于用户定义的数据类型，输出功能块名称或 DUT 名称。 例子： 'INT' , 'ARRAY' NumElements UDINT 0 数组元素的数量 要求：变量具有数据类型 ARRAY . 例子： 8 BaseTypeClass TYPE_CLASS TYPE_BOOL 数组元素的基本数据类型 要求：变量具有数据类型 ARRAY . 例子： TYPE_INT 为了 arrA : ARRAY [1..2,1..2,1..2] OF INT; ElemBitSize UDINT 0 数组元素的内存大小（以位为单位） 要求：变量具有数据类型 ARRAY . 例子： 16 位 arrA : ARRAY [1..2,1..2,1..2] OF INT; MemoryArea MEMORY_AREA MEM_MEMORY 关于内存区域的信息 MEM_GLOBAL : 全局内存区域 示例：在 Area 0 MEM_LOCAL : 本地内存区域 在 Area -1 MEM_MEMORY ：标记存储区 %M 示例：在 16#10 在 Area 1 MEM_INPUT : 输入存储区 %I 示例：在 16#04 在 Area 2 MEM_OUTPUT ：输出存储区 %Q 示例：在 16#08 在 Area 3 MEM_RETAIN : 保留内存区域 示例：在 16#20 在 Area 0 例子： MEM_GLOBAL 注意：内存区域配置取决于设备。 Symbol STRING(39) '' 变量名称为 STRING(39) 例子： 'iCounter' , 'arrA' Comment STRING(79) '' 变量声明的注释 例子： 'Counts the calls' 或者 'Stores the A data' " }, 
{ "title" : "操作员：__CURRENTTASK ", 
"url" : "_cds_operator_currenttask.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 操作员：__CURRENTTASK ", 
"snippet" : "__CURRENTTASK 运算符是 IEC 61131-3 标准的扩展。 在运行时，操作员提供有关当前正在运行的 IEC 任务的信息。 仅在目标系统设置为 memory-layout\\max-stack-size 设置为 > 0 的值。 运算符允许访问具有两个变量的结构。 TaskIndex ：标识任务的从零开始的索引 pTaskInfo : 当前运行任务的详细信息 可以分配给一个 POINTER TO Task_Info2 从图书馆 CmpIecTask 运算符不能用于 POU 的声明。这将导致错误消息。如果当前任务无法确定，则 TaskIndex -1 和 pTaskInfo 为零。 例...", 
"body" : "__CURRENTTASK 运算符是 IEC 61131-3 标准的扩展。 在运行时，操作员提供有关当前正在运行的 IEC 任务的信息。 仅在目标系统设置为 memory-layout\\max-stack-size 设置为 > 0 的值。 运算符允许访问具有两个变量的结构。 TaskIndex ：标识任务的从零开始的索引 pTaskInfo : 当前运行任务的详细信息 可以分配给一个 POINTER TO Task_Info2 从图书馆 CmpIecTask 运算符不能用于 POU 的声明。这将导致错误消息。如果当前任务无法确定，则 TaskIndex -1 和 pTaskInfo 为零。 例子 \/\/Declaration\nVAR\n idx : INT;\n pInfo : POINTER TO Task_Info2;\nEND_VAR\n\n\/\/Program code\n\nidx := __CURRENTTASK.TaskIndex;\npInfo := __CURRENTTASK.pTaskInfo; " }, 
{ "title" : "运算符：__COMPARE_AND_SWAP ", 
"url" : "_cds_operator_compare_and_swap.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：__COMPARE_AND_SWAP ", 
"snippet" : "__COMPARE_AND_SWAP 多核运算符是 IEC 61131-3 标准的扩展。 运算符可用于实现信号量，例如保证对不同任务写入的变量的独占访问。 __COMPARE_AND_SWAP 获取指向数据类型的指针 __XWORD 变量、旧值和新值作为其输入（例如： bMutex := __COMPARE_AND_SWAP(ADR(dwSynch), dwOld, dwNew); ）。新旧值也可以是数据类型 __XWORD 变量。被引用的 __XWORD 变量与旧值进行比较，如果两者相等，则写入新值。该函数的结果是 TRUE 何时可以写入新值。 编译器自动替换数据类型 __XWORD 和 D...", 
"body" : "__COMPARE_AND_SWAP 多核运算符是 IEC 61131-3 标准的扩展。 运算符可用于实现信号量，例如保证对不同任务写入的变量的独占访问。 __COMPARE_AND_SWAP 获取指向数据类型的指针 __XWORD 变量、旧值和新值作为其输入（例如： bMutex := __COMPARE_AND_SWAP(ADR(dwSynch), dwOld, dwNew); ）。新旧值也可以是数据类型 __XWORD 变量。被引用的 __XWORD 变量与旧值进行比较，如果两者相等，则写入新值。该函数的结果是 TRUE 何时可以写入新值。 编译器自动替换数据类型 __XWORD 和 DWORD 在 32 位系统和 LWORD 在 64 位系统上。 这个操作是原子的，所以它不能被另一个任务中断，即使在多核平台上也是如此。 例子 下面的例子展示了一个典型的用法。对类型的独占访问权 STRING 变量，这是通过寻址 pstrOutput 指针，应该实现。 对字符串的访问不是原子的。如果多个任务同时写入同一个字符串，则内容可能不一致。 使用此函数，现在可以在不同的任务中写入相同的 STRING 变量。 FUNCTION ExclusiveStringWrite : BOOL\nVAR_INPUT\n strToWrite : STRING;\n pstrOutput : POINTER TO STRING;\nEND_VAR\nVAR_STAT\n dwSynch : __XWORD;\nEND_VAR\nVAR\n bMutex: BOOL;\nEND_VAR\n\nbMutex:= __COMPARE_AND_SWAP(ADR(dwSynch), 0, 1);\n(* compare with 0 and write 1 as atomic operation *)\nIF bMutex THEN \/\/ bMutex is TRUE if write could be done\n pstrOutput^ := strToWrite; \/\/ Now you can write safely on the string\n dwSynch := 0; \/\/ The __XWORD variable must be reset.\n ExclusiveStringWrite := TRUE; \/\/ Writing was successful\nELSE\n ExclusiveStringWrite := FALSE; \/\/ Writing was not successful\nEND_IF " }, 
{ "title" : "运算符：__XADD ", 
"url" : "_cds_operator_xadd.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：__XADD ", 
"snippet" : "__XADD 多核运算符是 IEC 61131-3 标准的扩展。 该运算符可用于实现原子计数器。如果一个整数变量通过普通加法的方式递增，例如 iTest := iTest + 1; , 那么这个操作不是原子执行的。对变量的另一次访问可能发生在读取和写入变量之间。 如果计数器在多个任务中递增，则计数器结果可能小于计数周期数。因此，如果两个任务一次执行上述代码并且变量先前具有该值 0 , 然后变量可以有值 1 .如果在多个任务中处理数组并且在每个处理周期中都需要数组的唯一索引，则这尤其成问题。 当。。。的时候 __XADD 操作符被调用，它得到一个类型的指针 DINT 变量作为第一个被加数和类型 ...", 
"body" : "__XADD 多核运算符是 IEC 61131-3 标准的扩展。 该运算符可用于实现原子计数器。如果一个整数变量通过普通加法的方式递增，例如 iTest := iTest + 1; , 那么这个操作不是原子执行的。对变量的另一次访问可能发生在读取和写入变量之间。 如果计数器在多个任务中递增，则计数器结果可能小于计数周期数。因此，如果两个任务一次执行上述代码并且变量先前具有该值 0 , 然后变量可以有值 1 .如果在多个任务中处理数组并且在每个处理周期中都需要数组的唯一索引，则这尤其成问题。 当。。。的时候 __XADD 操作符被调用，它得到一个类型的指针 DINT 变量作为第一个被加数和类型 DINT 值作为第二个加法。 __XADD 返回第一个 summand 的旧值，并在同一步骤中将第二个 summand 添加到第一个 summand。 例如，函数调用可能如下所示： diOld := __XADD(ADR(diVar), deAdd); 例子 下面的例子展示了一个典型的用法。一个数组应该由两个任务填充。在此过程中，应使用数组中的所有位置，并且不应覆盖任何位置。 使用此函数，多个任务可以填充一个布尔数组。 FUNCTION WriteToNextArrayPosition : BOOL\nVAR_EXTERNAL\n g_diIndex : DINT; \/\/ Index and array are globally defined and used by multiple tasks\n g_boolArray : ARRAY [0..1000] OF BOOL;\nEND_VAR\nVAR_INPUT\n bToWrite : BOOL;\nEND_VAR\nVAR\n diIndex : DWORD;\nEND_VAR\n\ndiIndex := __XADD(ADR(g_diIndex), 1); \/\/ Returns a unique index\nWriteToNextArrayPosition := FALSE;\nIF (diIndex >= 0 AND diIndex <= 1000) THEN\n g_boolArray[diIndex] := bToWrite; \/\/Writes to unique index\n WriteToNextArrayPosition := TRUE; \/\/ TRUE: Array was not full yet\nEND_IF " }, 
{ "title" : "运算符：__POSITION ", 
"url" : "_cds_operator_position.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：__POSITION ", 
"snippet" : "__POSITION 运算符是 IEC 61131-1 标准的扩展。 在运行时，运算符产生变量在声明部分或 POU 的实现部分中的位置。必须为运算符分配类型的变量 STRING 在声明部分或实现部分。 的结果 __POSITION 声明部分： 'Line <line number> (Decl)' 实现部分： 'Line <line number>, Column <Column number> (Impl)' 例子 PROGRAM PROG1 VAR strPOS : STRING := __POSITION(); \/\/Returns the line number of this decl...", 
"body" : "__POSITION 运算符是 IEC 61131-1 标准的扩展。 在运行时，运算符产生变量在声明部分或 POU 的实现部分中的位置。必须为运算符分配类型的变量 STRING 在声明部分或实现部分。 的结果 __POSITION 声明部分： 'Line <line number> (Decl)' 实现部分： 'Line <line number>, Column <Column number> (Impl)' 例子 PROGRAM PROG1\nVAR\n strPOS : STRING := __POSITION(); \/\/Returns the line number of this declaration\n strlocalPOS : STRING;\nEND_VAR\n\n strlocalPOS := __POSITION(); \/\/Returns row and column number of this assignment " }, 
{ "title" : "运算符：__POUNAME ", 
"url" : "_cds_operator_pouname.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：__POUNAME ", 
"snippet" : "__POUNAME 运算符是 IEC 61131-1 标准的扩展。 在运行时，运算符生成包含运算符的 POU 的名称 __POUNAME .结果是类型 STRING . 的结果 __POUNAME 取决于它在哪里使用 在一个程序中：程序名 在函数名中：函数名 在功能块中：功能块名称 在一个方法中：用 FB 名称限定的方法名称 在属性的 Get\/Set 访问器中：属性名称 + 使用 FB 名称限定的 Get\/Set 在 GVL 中：GVL 名称 在结构中：结构名称 在数据结构中 UNION : 工会名称 例子 PROGRAM PROG1 VAR strPOU : STRING := __POUN...", 
"body" : "__POUNAME 运算符是 IEC 61131-1 标准的扩展。 在运行时，运算符生成包含运算符的 POU 的名称 __POUNAME .结果是类型 STRING . 的结果 __POUNAME 取决于它在哪里使用 在一个程序中：程序名 在函数名中：函数名 在功能块中：功能块名称 在一个方法中：用 FB 名称限定的方法名称 在属性的 Get\/Set 访问器中：属性名称 + 使用 FB 名称限定的 Get\/Set 在 GVL 中：GVL 名称 在结构中：结构名称 在数据结构中 UNION : 工会名称 例子 PROGRAM PROG1\nVAR\n strPOU : STRING := __POUNAME(); \/\/Returns 'PROG1'\n strlocalPOU : STRING;\nEND_VAR\n\nstrlocalPOU := __POUNAME(); \/\/Returns 'PROG1' " }, 
{ "title" : "运算符：TEST_AND_SET ", 
"url" : "_cds_operator_test_and_set.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：TEST_AND_SET ", 
"snippet" : "TEST_AND_SET 多核运算符是 IEC 61131-3 标准的扩展。 运算符可用于实现信号量，例如保证对不同任务写入的变量的独占访问。 TEST_AND_SET 得到一个类型 DWORD 变量作为其输入。必须可以对该变量进行写访问。变量设置为 1 并且之前的值作为结果返回。 该操作是原子的，这意味着它不能被另一个任务中断。这也适用于多核平台。 例如程序中的调用是 dwOldValue := TEST_AND_SET(dw); , 其中变量 dwOldValue 和 dw 必须是数据类型 DWORD . 例子 下面的例子展示了一个典型的用法。对类型的独占访问权 STRING 变量，这是通...", 
"body" : "TEST_AND_SET 多核运算符是 IEC 61131-3 标准的扩展。 运算符可用于实现信号量，例如保证对不同任务写入的变量的独占访问。 TEST_AND_SET 得到一个类型 DWORD 变量作为其输入。必须可以对该变量进行写访问。变量设置为 1 并且之前的值作为结果返回。 该操作是原子的，这意味着它不能被另一个任务中断。这也适用于多核平台。 例如程序中的调用是 dwOldValue := TEST_AND_SET(dw); , 其中变量 dwOldValue 和 dw 必须是数据类型 DWORD . 例子 下面的例子展示了一个典型的用法。对类型的独占访问权 STRING 变量，这是通过寻址 pstrOutput 指针，应该实现。对字符串的访问不是原子的。如果多个任务同时写入同一个字符串，则内容可能不一致。随着 TEST_AND_SET 函数，现在可以编写相同的 STRING 不同任务中的变量。 FUNCTION ExclusiveStringWrite : BOOL\nVAR_INPUT\n strToWrite : STRING;\n pstrOutput : POINTER TO STRING;\nEND_VAR\nVAR_STAT\n dwSynch : DWORD;\nEND_VAR\nVAR\n dwOldValue: DWORD;\nEND_VAR\n\ndwOldValue := TEST_AND_SET(dwSynch); \/\/ Write the 1 and read the old value at the same time\nIF dwOldValue = 0 THEN \/\/ 0 means: no other task is currently writing\n pstrOutput^ := strToWrite; \/\/ Now you can write safely on the string\n dwSynch := 0; \/\/ The DWORD must be reset\n ExclusiveStringWrite := TRUE; \/\/ Writing was successful\nELSE\n ExclusiveStringWrite := FALSE; \/\/ Writing was not successful\nEND_IF " }, 
{ "title" : "运算符：全局命名空间 ", 
"url" : "_cds_operator_namespace_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：全局命名空间 ", 
"snippet" : "全局命名空间 运算符是 IEC 61131-3 标准的扩展。 以点开头的实例路径 . 总是打开一个全局命名空间。如果存在同名的局部变量 <varname> 作为全局变量，那么您将全局变量称为 .<varname> ....", 
"body" : "全局命名空间 运算符是 IEC 61131-3 标准的扩展。 以点开头的实例路径 . 总是打开一个全局命名空间。如果存在同名的局部变量 <varname> 作为全局变量，那么您将全局变量称为 .<varname> . " }, 
{ "title" : "运算符：全局变量列表的命名空间 ", 
"url" : "_cds_operator_namespace_gvl.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：全局变量列表的命名空间 ", 
"snippet" : "全局变量列表的命名空间 运算符是 IEC 61131-3 标准的扩展。 您可以使用全局变量列表 (GVL) 的名称作为列表中定义的变量的命名空间标识符。这使得可以在不同的全局变量列表中使用具有相同名称的变量，并且仍然可以唯一地访问特定变量。您使用一个点 ( . ) 将全局变量列表的名称添加到变量名称之前。 <global variable list name>.<variable> 例子 globlist1.varx := globlist2.varx; 这 globlist1 和 globlist2 全局变量列表每个包含一个 varx 多变的。 CODESYS 复制 varx 全局变量来自 ...", 
"body" : "全局变量列表的命名空间 运算符是 IEC 61131-3 标准的扩展。 您可以使用全局变量列表 (GVL) 的名称作为列表中定义的变量的命名空间标识符。这使得可以在不同的全局变量列表中使用具有相同名称的变量，并且仍然可以唯一地访问特定变量。您使用一个点 ( . ) 将全局变量列表的名称添加到变量名称之前。 <global variable list name>.<variable> 例子 globlist1.varx := globlist2.varx; 这 globlist1 和 globlist2 全局变量列表每个包含一个 varx 多变的。 CODESYS 复制 varx 全局变量来自 globlist2 列出到 varx 在里面 globlist1 列表。 如果您引用了在多个全局变量列表中声明的变量而没有引用前置列表名称，则会打印一条错误消息。 " }, 
{ "title" : "运算符：库命名空间 ", 
"url" : "_cds_operator_namespace_lib.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：库命名空间 ", 
"snippet" : "库命名空间 句法： <library namespace>.<library POU identifier> 例子： LIB_A.FB_A 库块标识符附加到库命名空间（作为由点分隔的前缀），以便对库模块进行唯一且合格的访问。命名空间通常与库名称匹配。 例子 库包含在项目中并包含 FB_A POU。但是，具有相同名称的功能块已在项目本地可用。将库 POU 标识为 LIB_A.FB_A 为了访问库 POU，而不是本地功能块。 var1 := FB_A(in := 12); \/\/ Call of the project function FB_A var2 := LIB_A.FB_A(in := 2...", 
"body" : "库命名空间 句法： <library namespace>.<library POU identifier> 例子： LIB_A.FB_A 库块标识符附加到库命名空间（作为由点分隔的前缀），以便对库模块进行唯一且合格的访问。命名空间通常与库名称匹配。 例子 库包含在项目中并包含 FB_A POU。但是，具有相同名称的功能块已在项目本地可用。将库 POU 标识为 LIB_A.FB_A 为了访问库 POU，而不是本地功能块。 var1 := FB_A(in := 12); \/\/ Call of the project function FB_A\nvar2 := LIB_A.FB_A(in := 22); \/\/ Call of the library function FB_A 您可以为命名空间定义另一个标识符。为此，请在项目信息中指定命名空间（库开发者：创建库项目时）。作为替代方案，您可以在库管理器中为库指定特定的命名空间 特性 对话框（应用程序开发人员：创建应用程序时）。 有关更多信息，请参阅： 使用库" }, 
{ "title" : "运算符 (#) 用于直接访问 ", 
"url" : "_cds_operator_namespace_lib.html#UUID-743ca1a8-1b92-e8be-7a21-610d20d2e0b2_section-idm13349116767826", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：库命名空间 \/ 运算符 (#) 用于直接访问 ", 
"snippet" : "该运算符是 IEC 61131-3 标准的扩展。 功能块的本地组件可能会覆盖具有相同名称的库 POU，这会导致歧义。因此，无法使用通常的命名空间约定进行访问。那么使用 # 运营商强制直接访问。 您可以使用以下语法强制直接访问： 句法： <namespace> # <library POU path> 例子 TYPE Struct1 : STRUCT Standard : Struct2; END_STRUCT END_TYPE TYPE Struct2 : STRUCT Concat : DINT; END_STRUCT END_TYPE {attribute 'qualified_only'...", 
"body" : "该运算符是 IEC 61131-3 标准的扩展。 功能块的本地组件可能会覆盖具有相同名称的库 POU，这会导致歧义。因此，无法使用通常的命名空间约定进行访问。那么使用 # 运营商强制直接访问。 您可以使用以下语法强制直接访问： 句法： <namespace> # <library POU path> 例子 TYPE Struct1 :\nSTRUCT\n\tStandard : Struct2;\nEND_STRUCT\nEND_TYPE TYPE Struct2 :\nSTRUCT\n\tConcat : DINT;\nEND_STRUCT\nEND_TYPE {attribute 'qualified_only'}\nVAR_GLOBAL\n\tStandard : Struct2;\nEND_VAR PROGRAM PLC_PRG\nVAR\n test : _3S_License#Standard#TON;\n str : STRING;\nEND_VAR\n\n\/\/ access to global variable\n_3S_License.Standard.CONCAT := 123;\n\n\/\/ with hashtag access, the library is explicitly addressed \nstr := _3S_License.Standard#CONCAT('test1', '3444');\nstr := Standard#CONCAT('test1', '3444');\nstr := _3S_License#Standard#CONCAT('test1', '3444');\nstr := _3S_License.Standard#CONCAT('test1', '3444');\nstr := CONCAT('test1', Standard#CONCAT('3444', '444'));\nstr := CONCAT('test1', _3S_License.Standard#CONCAT('3444', '444'));\nstr := CONCAT('test1', _3S_License#Standard#CONCAT('3444', '444'));\nstr := Standard#CONCAT('test1', Standard#CONCAT('3444', '444'));\nstr := Standard#CONCAT('test1', _3S_License.Standard#CONCAT('3444', '444'));\nstr := Standard#CONCAT('test1', _3S_License#Standard#CONCAT('3444', '444'));\nstr := Standard#CONCAT('test1', _3S_License#Standard#CONCAT('asdf', 'fdas'));\n " }, 
{ "title" : "运算符：枚举命名空间 ", 
"url" : "_cds_operator_namespace_enum.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：枚举命名空间 ", 
"snippet" : "枚举命名空间 运算符是 IEC 61131-3 标准的扩展。 您可以使用枚举的 TYPE 名称对枚举常量进行唯一访问。这样，您可以在不同的枚举中使用相同的常量名称。 枚举名称前面带有一个点 ( . ）。 <enumeration name>.<constant name> 例子 常数 Blue 是两个枚举的组成部分 Colors 和枚举 Feelings . color := Colors.Blue; \/\/ Access to coomponent Blue in enumeration Colors feeling := Feelings.Blue; \/\/ Acces to componen...", 
"body" : "枚举命名空间 运算符是 IEC 61131-3 标准的扩展。 您可以使用枚举的 TYPE 名称对枚举常量进行唯一访问。这样，您可以在不同的枚举中使用相同的常量名称。 枚举名称前面带有一个点 ( . ）。 <enumeration name>.<constant name> 例子 常数 Blue 是两个枚举的组成部分 Colors 和枚举 Feelings . color := Colors.Blue; \/\/ Access to coomponent Blue in enumeration Colors\n\nfeeling := Feelings.Blue; \/\/ Acces to component Blue in enumeration Feelings " }, 
{ "title" : "运营商：__POOL ", 
"url" : "_cds_operator_pool.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运营商：__POOL ", 
"snippet" : "__POOL 运算符是 IEC 61131-3 标准的扩展。 运算符用于引用在全局 POU 池中管理的对象（在 POU 看法）。操作员直接访问对象 POU 看法。 例子 PROGRAM PLC_PRG VAR svar_pou : STRING; END_VAR svar_pou := __POOL.POU(); 有关更多信息，请参阅： 如何防止阴影...", 
"body" : "__POOL 运算符是 IEC 61131-3 标准的扩展。 运算符用于引用在全局 POU 池中管理的对象（在 POU 看法）。操作员直接访问对象 POU 看法。 例子 PROGRAM PLC_PRG\nVAR\n svar_pou : STRING;\nEND_VAR\n\nsvar_pou := __POOL.POU(); 有关更多信息，请参阅： 如何防止阴影" }, 
{ "title" : "运算符：INI ", 
"url" : "_cds_operator_ini.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 运算符 \/ 运算符：INI ", 
"snippet" : "INI 这 INI 运算符是 CoDeSys V2.3 .该运算符被替换为 FB_Init 方法为 CODESYS V3。但是，您仍然可以在从 CoDeSys V2.3 . 句法 <boolean variable name> := INI ( <FB instance name> , <boolean value> ); \/\/ <boolean value> : TRUE | FALSE 随着 INI 运算符，您可以触发 POU 中使用的功能块实例的保留变量的初始化。 如果运算符的第二个参数是 TRUE ， 然后 CODESYS 初始化功能块中定义的所有保留变量 <FB instance n...", 
"body" : "INI 这 INI 运算符是 CoDeSys V2.3 .该运算符被替换为 FB_Init 方法为 CODESYS V3。但是，您仍然可以在从 CoDeSys V2.3 . 句法 <boolean variable name> := INI ( <FB instance name> , <boolean value> );\n\/\/ <boolean value> : TRUE | FALSE 随着 INI 运算符，您可以触发 POU 中使用的功能块实例的保留变量的初始化。 如果运算符的第二个参数是 TRUE ， 然后 CODESYS 初始化功能块中定义的所有保留变量 <FB instance name> 然后返回 TRUE . ST 中的示例 fbinst 是功能块的实例 fb1 ，其中保留变量 retvar 被定义为。 VAR\n fbinst : fb1;\n b : BOOL;\nEND_VAR\n\nb := INI(fbinst, TRUE);\nivar := fbinst.retvar; (* => retvar is initialized *)\n 示例在 FUP 有关更多信息，请参阅： RETAIN, 使用保留变量获取数据" }, 
{ "title" : "类型转换运算符 ", 
"url" : "_cds_conversion_operators.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 ", 
"snippet" : "边界情况的舍入逻辑取决于目标系统或 FPU（ 浮点单元 ) 的目标系统。例如， -1.5 可以在不同的控制器上进行不同的转换。 捕获值范围溢出应用程序以独立于目标系统的程序代码。 如果类型转换运算符的操作数值超出目标数据类型的值范围，则结果输出取决于处理器类型，因此未定义。例如，当负操作数值从 LREAL 到目标数据类型 UINT . 从较大的数据类型转换为较小的数据类型时，信息可能会丢失。 字符串操作 将类型转换为 STRING 或者 WSTRING ，键入的值作为字符串左对齐，如果太长则截断。因此，为类型转换运算符声明返回变量 <>_TO_STRING 和 <>_TO_WSTRING 足够...", 
"body" : "边界情况的舍入逻辑取决于目标系统或 FPU（ 浮点单元 ) 的目标系统。例如， -1.5 可以在不同的控制器上进行不同的转换。 捕获值范围溢出应用程序以独立于目标系统的程序代码。 如果类型转换运算符的操作数值超出目标数据类型的值范围，则结果输出取决于处理器类型，因此未定义。例如，当负操作数值从 LREAL 到目标数据类型 UINT . 从较大的数据类型转换为较小的数据类型时，信息可能会丢失。 字符串操作 将类型转换为 STRING 或者 WSTRING ，键入的值作为字符串左对齐，如果太长则截断。因此，为类型转换运算符声明返回变量 <>_TO_STRING 和 <>_TO_WSTRING 足够长的字符串有足够的空间而无需任何操作。 " }, 
{ "title" : "类型转换 ", 
"url" : "_cds_conversion_operators.html#UUID-a8ef93c9-c5d6-bfc3-02a3-f7ae8780fbce_UUID-42fbcdfe-e4d8-8424-32d5-eb04a19b62c4_section-idm13452249872816", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 类型转换 ", 
"snippet" : "您可以明确调用类型转换运算符。 下面描述的类型转换运算符可用于从一种基本类型到另一种基本类型的类型转换，以及重载。 从“较大”类型到“较小”类型的转换也是隐式可能的（例如，从 INT 到 BYTE 或来自 DINT 到 WORD ）。...", 
"body" : "您可以明确调用类型转换运算符。 下面描述的类型转换运算符可用于从一种基本类型到另一种基本类型的类型转换，以及重载。 从“较大”类型到“较小”类型的转换也是隐式可能的（例如，从 INT 到 BYTE 或来自 DINT 到 WORD ）。 " }, 
{ "title" : "重载转换 ", 
"url" : "_cds_operator_to_xxx.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 重载转换 ", 
"snippet" : "重载 IEC 61131-3 标准不提供重载函数。 如果要严格按照 IEC 61131-3 进行编程，则需要使用语法的运算符 <输出类型> _TO_ <目标类型> 如以下章节所述。 运算符将值转换为其他数据类型，仅明确指定目标类型（而不指定操作数的输出类型）（重载转换）。 类型转换的规则也适用于重载。 过载不是 IEC 61131-3 规范的一部分。 调用语法 ： <TO_<目标类型> ( <操作数> ) 操作数 数据类型 描述 变量，文字 标准数据类型 数据类型重载运算符：TO_<目标数据类型> 操作员 例子 返回值 描述 TO___UXINT TO___UXINT(123.4) 123 _...", 
"body" : "重载 IEC 61131-3 标准不提供重载函数。 如果要严格按照 IEC 61131-3 进行编程，则需要使用语法的运算符 <输出类型> _TO_ <目标类型> 如以下章节所述。 运算符将值转换为其他数据类型，仅明确指定目标类型（而不指定操作数的输出类型）（重载转换）。 类型转换的规则也适用于重载。 过载不是 IEC 61131-3 规范的一部分。 调用语法 ： <TO_<目标类型> ( <操作数> ) 操作数 数据类型 描述 变量，文字 标准数据类型 数据类型重载运算符：TO_<目标数据类型> 操作员 例子 返回值 描述 TO___UXINT TO___UXINT(123.4) 123 __UXINT、__XINT、__XWORD TO___XINT TO___UXINT(123.4) 123 __UXINT、__XINT、__XWORD TO___XWORD __UXINT、__XINT、__XWORD TO_BIT BIT TO_BOOL TO_BOOL(0.001) TRUE BOOL TO_BYTE Integer TO_DATE 句法： D#yyyy-MM-dd, DATE#yyyy-MM-dd 数据类型：DATE TO_DATE_AND_TIME TO_DT TO_DT(0) DT##1970-1-1-0:0:0 句法： DT#yyyy-MM-dd-hh:mm:ss, DATE_AND_TIME#yyyy-MM-dd-hh:mm:ss 数据类型：DATE TO_DINT Integer TO_DWORD Integer TO_INT TO_INT(4.22) TO_INT(123.4) 4 123 Integer TO_LDATE 句法： LDATE#yyyy-MM-dd 数据类型：DATE TO_LDT 句法： LDT#yyyy-MM-dd-hh:mm:ss.sss 数据类型：DATE TO_LINT Integer TO_LREAL REAL, LREAL TO_LTIME 数据类型：TIME、LTIME TO_LTOD 句法： LTOD#hh:mm:ss.sssssssss 数据类型：DATE TO_LWORD Integer TO_REAL REAL, LREAL TO_SINT Integer TO_STRING TO_STRING(342) '342' STRING TO_TIME TO_TIME(SysTimeGetMs()) 系统时间 数据类型：TIME、LTIME TO_TOD 数据类型：DATE TO_UDINT Integer TO_UINT TO_UINT(D#2019-9-3) 44288 Integer TO_ULINT Integer TO_USINT Integer TO_WORD Integer TO_WSTRING TO_WSTRING('Hello World') \"Hello World!\" WSTRING" }, 
{ "title" : "转换： BOOL ", 
"url" : "_cds_operator_bool_to-2023061.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换： BOOL ", 
"snippet" : "BOOL 运算符 BOOL_TO_<type> 将布尔值转换为指定的数据类型并返回类型转换后的值。 调用语法 ： < BOOL_TO_<类型> ( <操作数> ) 操作数 数据类型 描述 变量，文字 BOOL 运算符：BOOL_TO_<type> 操作员 例子 返回值 描述 BOOL_TO___UXINT BOOL_TO___UXINT(TRUE) 1 __UXINT、__XINT、__XWORD BOOL_TO___XINT BOOL_TO___XINT(TRUE) 1 __UXINT、__XINT、__XWORD BOOL_TO___XWORD BOOL_TO___XWINT(TRUE) ...", 
"body" : "BOOL 运算符 BOOL_TO_<type> 将布尔值转换为指定的数据类型并返回类型转换后的值。 调用语法 ： < BOOL_TO_<类型> ( <操作数> ) 操作数 数据类型 描述 变量，文字 BOOL 运算符：BOOL_TO_<type> 操作员 例子 返回值 描述 BOOL_TO___UXINT BOOL_TO___UXINT(TRUE) 1 __UXINT、__XINT、__XWORD BOOL_TO___XINT BOOL_TO___XINT(TRUE) 1 __UXINT、__XINT、__XWORD BOOL_TO___XWORD BOOL_TO___XWINT(TRUE) 1 __UXINT、__XINT、__XWORD BOOL_TO_BIT BOOL_TO___BIT(TRUE) TRUE BIT BOOL_TO_BYTE BOOL_TO_BYTE(TRUE) 1 Integer BOOL_TO_DATE BOOL_TO_DATE(TRUE) D#1970-1-1 第 0 位已设置，但对显示没有影响。 数据类型：DATE BOOL_TO_DINT BOOL_TO_DINT(TRUE) 1 Integer BOOL_TO_DT BOOL_TO_DT(TRUE) DT#1970-01-01-0:0:1 数据类型：DATE BOOL_TO_DWORD BOOL_TO_DWORD(TRUE) 1 Integer BOOL_TO_INT BOOL_TO_INT(TRUE) 1 Integer BOOL_TO_LDATE BOOL_TO_LDATE(TRUE) LD#1970-01-01 第 0 位已设置，但对显示没有影响。 数据类型：DATE BOOL_TO_LDT BOOL_TO_LD(TRUE) DT#1970-01-01-0:0:1 数据类型：DATE BOOL_TO_LINT BOOL_TO_LINT(TRUE) 1 Integer BOOL_TO_LREAL BOOL_TO_LREAL(TRUE) 1 REAL, LREAL BOOL_TO_LTIME BOOL_TO_LTIME(TRUE) LTIME#1NS 数据类型：DATE BOOL_TO_LTOD BOOL_TO_LTOD(TRUE) LTOD#0:0:0.000000001 数据类型：DATE BOOL_TO_LWORD BOOL_TO_LWORD(TRUE) 1 Integer BOOL_TO_REAL BOOL_TO_REAL(TRUE) 1 REAL, LREAL BOOL_TO_SINT BOOL_TO_SINT(TRUE) 1 Integer BOOL_TO_STRING BOOL_TO_STRING(TRUE) 'TRUE' STRING BOOL_TO_TIME BOOL_TO_TIME(TRUE) T#1ms 数据类型：DATE BOOL_TO_TOD BOOL_TO_TOD(TRUE) TOD#0:0:0.001 数据类型：DATE BOOL_TO_UDINT BOOL_TO_UDINT(TRUE) 1 Integer BOOL_TO_UINT BOOL_TO_UINT(TRUE) 1 Integer BOOL_TO_ULINT BOOL_TO_ULINT(TRUE) 1 Integer BOOL_TO_USINT BOOL_TO_ULSINT(TRUE) 1 Integer BOOL_TO_WORD BOOL_TO_WORD(TRUE) 1 Integer BOOL_TO_WSTRING BOOL_TO_WSTRING(TRUE) \"TRUE\" WSTRING" }, 
{ "title" : "例子 ", 
"url" : "_cds_operator_bool_to-2023061.html#UUID-682020e5-0008-f30f-f004-09c97f2d0715_UUID-7cb488ce-e3ad-80d5-81d9-c44c2ef838fa_id_a353abc1de5f9c0a8640e006e95fc_id_a764924bfc35ef1cc0a8646370e2d8a1", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换： BOOL \/ 例子 ", 
"snippet" : "FB_ConvertFromBool ST 中的声明 FUNCTION_BLOCK FB_ConvertFromBool VAR uxiReturn_1: __UXINT; uxiReturn_10: __UXINT; iReturn_2: __XINT; iReturn_20: __XINT; xwReturn_3: __XWORD; xwReturn_30: __XWORD; bitReturn_4: BOOL; bitReturn_40: BOOL; bReturn_6: BYTE; bReturn_60: BYTE; dateReturn_7: DATE; dateReturn_70:...", 
"body" : "FB_ConvertFromBool ST 中的声明 FUNCTION_BLOCK FB_ConvertFromBool\nVAR\n uxiReturn_1: __UXINT;\n uxiReturn_10: __UXINT;\n iReturn_2: __XINT;\n iReturn_20: __XINT;\n xwReturn_3: __XWORD;\n xwReturn_30: __XWORD;\n bitReturn_4: BOOL;\n bitReturn_40: BOOL;\n bReturn_6: BYTE;\n bReturn_60: BYTE;\n dateReturn_7: DATE;\n dateReturn_70: DATE;\n dtReturn_8: DATE_AND_TIME;\n dtReturn_80: DATE_AND_TIME;\n diReturn_9: DINT;\n diReturn_90: DINT;\n dtReturn_10: DATE_AND_TIME;\n dtReturn_100: DATE_AND_TIME;\n dwReturn_11: DWORD;\n dwReturn_110: DWORD;\n iReturn_12: INT;\n iReturn_120: INT;\n liReturn_13: LINT;\n liReturn_130: LINT;\n lrReturn_14: LREAL;\n lrReturn_140: LREAL;\n lwReturn_15: LWORD;\n lwReturn_150: LWORD;\n rReturn_16: REAL;\n rReturn_160: REAL;\n siReturn_17: SINT;\n siReturn_170: SINT;\n sReturn_18: STRING;\n sReturn_180: STRING;\n todReturn_19: TIME_OF_DAY;\n todReturn_190: TIME_OF_DAY;\n timReturn_20: TIME;\n timReturn_200: TIME;\n todReturn_21: TIME_OF_DAY;\n todReturn_210: TIME_OF_DAY;\n udiReturn_22: UDINT;\n udiReturn_220: UDINT;\n uiReturn_23: UINT;\n uiReturn_230: UINT;\n uliReturn_24: ULINT;\n uliReturn_240: ULINT;\n usiReturn_25: USINT;\n usiReturn_250: USINT;\n wReturn_26: WORD;\n wReturn_260: WORD;\n wsReturn_27: WSTRING;\n wsReturn_270: WSTRING;\nEND_VAR\n 在 ST 中的实现 FUNCTION_BLOCK FB_ConvertFromBool\nVAR\nVAR\n uxiReturn_1: __UXINT;\n uxiReturn_10: __UXINT;\n iReturn_2: __XINT;\n iReturn_20: __XINT;\n xwReturn_3: __XWORD;\n xwReturn_30: __XWORD;\n bitReturn_4: BOOL;\n bitReturn_40: BOOL;\n bReturn_6: BYTE;\n bReturn_60: BYTE;\n dateReturn_7: DATE;\n dateReturn_70: DATE;\n dtReturn_8: DATE_AND_TIME;\n dtReturn_80: DATE_AND_TIME;\n diReturn_9: DINT;\n diReturn_90: DINT;\n dtReturn_10: DATE_AND_TIME;\n dtReturn_100: DATE_AND_TIME;\n dwReturn_11: DWORD;\n dwReturn_110: DWORD;\n iReturn_12: INT;\n iReturn_120: INT;\n liReturn_13: LINT;\n liReturn_130: LINT;\n lrReturn_14: LREAL;\n lrReturn_140: LREAL;\n lwReturn_15: LWORD;\n lwReturn_150: LWORD;\n rReturn_16: REAL;\n rReturn_160: REAL;\n siReturn_17: SINT;\n siReturn_170: SINT;\n sReturn_18: STRING;\n sReturn_180: STRING;\n todReturn_19: TIME_OF_DAY;\n todReturn_190: TIME_OF_DAY;\n timReturn_20: TIME;\n timReturn_200: TIME;\n todReturn_21: TIME_OF_DAY;\n todReturn_210: TIME_OF_DAY;\n udiReturn_22: UDINT;\n udiReturn_220: UDINT;\n uiReturn_23: UINT;\n uiReturn_230: UINT;\n uliReturn_24: ULINT;\n uliReturn_240: ULINT;\n usiReturn_25: USINT;\n usiReturn_250: USINT;\n wReturn_26: WORD;\n wReturn_260: WORD;\n wsReturn_27: WSTRING;\n wsReturn_270: WSTRING;\nEND_VAR\n\n\/\/ Return value of operand = TRUE or FALSE\nuxiReturn_1 := BOOL_TO___UXINT(TRUE);\nuxiReturn_10 := BOOL_TO___UXINT(FALSE);\n\niReturn_2 := BOOL_TO___XINT(TRUE);\niReturn_20 := BOOL_TO___XINT(FALSE);\n\nxwReturn_3 := BOOL_TO___XWORD(TRUE);\nxwReturn_30 := BOOL_TO___XWORD(FALSE);\n\nbitReturn_4 := BOOL_TO_BIT(TRUE);\nbitReturn_40 := BOOL_TO_BIT(FALSE);\n\nbReturn_6 := BOOL_TO_BYTE(TRUE);\nbReturn_60 := BOOL_TO_BYTE(FALSE);\n\ndateReturn_7 := BOOL_TO_DATE(TRUE);\ndateReturn_70 := BOOL_TO_DATE(FALSE);\n\ndtReturn_8 := BOOL_TO_DT(TRUE);\ndtReturn_80 := BOOL_TO_DT(FALSE);\n\ndiReturn_9 := BOOL_TO_DINT(TRUE);\ndiReturn_90 := BOOL_TO_DINT(FALSE);\n\ndwReturn_11 := BOOL_TO_DWORD(TRUE);\ndwReturn_110 := BOOL_TO_DWORD(FALSE);\n\niReturn_12 := BOOL_TO_INT(TRUE);\niReturn_120 := BOOL_TO_INT(FALSE);\n\nliReturn_13 := BOOL_TO_LINT(TRUE);\nliReturn_130 := BOOL_TO_LINT(FALSE);\n\nlrReturn_14 := BOOL_TO_LREAL(TRUE);\nlrReturn_140 := BOOL_TO_LREAL(FALSE);\n\nlwReturn_15 := BOOL_TO_LWORD(TRUE);\nlwReturn_150 := BOOL_TO_LWORD(FALSE);\n\nrReturn_16 := BOOL_TO_REAL(TRUE);\nrReturn_160 := BOOL_TO_REAL(FALSE);\n\nsiReturn_17 := BOOL_TO_SINT(TRUE);\nsiReturn_170 := BOOL_TO_SINT(FALSE);\n\nsReturn_18 := BOOL_TO_STRING(TRUE);\nsReturn_180 := BOOL_TO_STRING(FALSE);\n\ntimReturn_20 := BOOL_TO_TIME(TRUE);\ntimReturn_200 := BOOL_TO_TIME(FALSE);\n\ntodReturn_21 := BOOL_TO_TOD(TRUE);\ntodReturn_210 := BOOL_TO_TOD(FALSE);\n\nudiReturn_22 := BOOL_TO_UDINT(TRUE);\nudiReturn_220 := BOOL_TO_UDINT(FALSE);\n\nuiReturn_23 := BOOL_TO_UINT(TRUE);\nuiReturn_230 := BOOL_TO_UINT(FALSE);\n\nuliReturn_24 := BOOL_TO_ULINT(TRUE);\nuliReturn_240 := BOOL_TO_ULINT(FALSE);\n\nusiReturn_25 := BOOL_TO_USINT(TRUE);\nusiReturn_250 := BOOL_TO_USINT(FALSE);\n\nwReturn_26 := BOOL_TO_WORD(TRUE);\nwReturn_260 := BOOL_TO_WORD(FALSE);\n\nwsReturn_27 := BOOL_TO_WSTRING(TRUE);\nwsReturn_270 := BOOL_TO_WSTRING(FALSE); FBD 实现语言 FBD 实现语言 " }, 
{ "title" : "转换：整数 ", 
"url" : "_cds_operator_convert_integer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换：整数 ", 
"snippet" : "整数 该运算符将整数值转换为目标类型并返回类型转换后的值。如果要转换的数字超出范围限制，则忽略数字的前几个字节。 调用语法 ： <整数类型>_TO_<标准类型> ( <操作数> ) 操作数 数据类型 描述 变量，文字 __UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT |STRING | TI...", 
"body" : "整数 该运算符将整数值转换为目标类型并返回类型转换后的值。如果要转换的数字超出范围限制，则忽略数字的前几个字节。 调用语法 ： <整数类型>_TO_<标准类型> ( <操作数> ) 操作数 数据类型 描述 变量，文字 __UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT |STRING | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD | WSTRING IntegerSTRING, WSTRING运算符：<整数类型>_TO_<标准类型>（矩阵） __UXINT __XINT __XWORD BIT BYTE DINT DWORD INT LINT LWORD SINT UDINT UINT ULINT USINT WORD __UXINT - __XINT_TO___UXINT __XWORD_TO_UXINT BIT_TO___UXINT BYTE_TO___UXINT DINT_TO___UXINT DWORD_TO___UXINT INT_TO___UXINT LINT_TO___UXINT LWORD_TO___UXINT SINT_TO___UXINT UDINT_TO___UXINT UINT_TO___UXINT ULINT_TO___UXINT USINT_TO___XINT WORD_TO___XINT __XINT __UXINT_TO___XINT - __XWORD_TO_XINT BIT_TO___XINT BYTE_TO___XINT DINT_TO___XINT DWORD_TO___XINT INT_TO___XINT LINT_TO___XINT LWORD_TO___XINT SINT_TO___XINT UDINT_TO___XINT UINT_TO___XINT ULINT_TO___XINT USINT_TO___XINT WORD_TO___XINT __XWORD __UXINT_TO___XWORD __XINT_TO___XWORD - BIT_TO___XWORD BYTE_TO___XWORD DINT_TO___XWORD DWORD_TO___XWORD INT_TO___XWORD LINT_TO___XWORD LWORD_TO___XWORD SINT_TO___XWORD UDINT_TO___XWORD UINT_TO___XWORD ULINT_TO___XWORD USINT_TO___XWORD WORD_TO___XWORD BIT __UXINT_TO_BIT __XINT_TO_BIT __XWORD_TO_BIT - BYTE_TO_BIT DINT_TO_BIT DWORD_TO_BIT INT_TO_BIT LINT_TO_BIT LWORD_TO_BIT SINT_TO_BIT UDINT_TO_BIT UINT_TO_BIT ULINT_TO_BIT USINT_TO_BIT WORD_TO_BIT BOOL __UXINT_TO_BOOL __XINT_TO_BOOL __XWORD_TO_BOOL BIT_TO_BOOL BYTE_TO_BOOL DINT_TO_BOOL DWORD_TO_BOOL INT_TO_BOOL LINT_TO_BOOL LWORD_TO_BOOL SINT_TO_BOOL UDINT_TO_BOOL UINT_TO_BOOL ULINT_TO_BOOL USINT_TO_BOOL WORD_TO_BOOL Byte __UXINT_TO_BYTE __XINT_TO_BYTE __XWORD_TO_BYTE BIT_TO_BYTE - DINT_TO_BYTE DWORD_TO_BYTE INT_TO_BYTE LINT_TO_BYTE LWORD_TO_BYTE SINT_TO_BYTE UDINT_TO_BYTE UINT_TO_BYTE ULINT_TO_BYTE USINT_TO_BYTE WORD_TO_BYTE DATE __UXINT_TO_DATE __XINT_TO_DATE __XWORD_TO_DATE BIT_TO_DATE BYTE_TO_DATE DINT_TO_DATE DWORD_TO_DATE INT_TO_DATE LINT_TO_DATE LWORD_TO_DATE SINT_TO_DATE UDINT_TO_DATE UINT_TO_DATE ULINT_TO_DATE USINT_TO_DATE WORD_TO_DATE DINT __UXINT_TO_DINT __XINT_TO_DINT __XWORD_TO_DINT BIT_TO_DINT BYTE_TO_DINT - DWORD_TO_DINT INT_TO_DINT LINT_TO_DINT LWORD_TO_DINT SINT_TO_DINT UDINT_TO_DINT UINT_TO_DINT ULINT_TO_DINT USINT_TO_DINT WORD_TO_DINT DT __UXINT_TO_DT __XINT_TO_DT __XWORD_TO_DT BIT_TO_DT BYTE_TO_DT DINT_TO_DT DWORD_TO_DT INT_TO_DT LINT_TO_DT LWORD_TO_DT SINT_TO_DT UDINT_TO_DT UINT_TO_DT ULINT_TO_DT USINT_TO_DT WORD_TO_DT DWORD __UXINT_TO_DWORD __XINT_TO_DWORD __XWORD_TO_DWORD BIT_TO_DWORD BYTE_TO_DWORD DINT_TO_DWORD - INT_TO_DWORD LINT_TO_DWORD LWORD_TO_DWORD SINT_TO_DWORD UDINT_TO_DWORD UINT_TO_DWORD ULINT_TO_DWORD USINT_TO_DWORD WORD_TO_DWORD INT __UXINT_TO_INT __XINT_TO_INT __XWORD_TO_INT BIT_TO_INT BYTE_TO_INT DINT_TO_INT DWORD_TO_INT - LINT_TO_INT LWORD_TO_INT SINT_TO_INT UDINT_TO_INT UINT_TO_INT ULINT_TO_INT USINT_TO_INT WORD_TO_INT LDATE __UXINT_TO_LDATE __XINT_TO_LDATE __XWORD_TO_LDATE BIT_TO_LDATE BYTE_TO_LDATE DINT_TO_LDATE DWORD_TO_LDATE INT_TO_LDATE LINT_TO_LDATE LWORD_TO_LDATE SINT_TO_LDATE UDINT_TO_LDATE UINT_TO_LDATE ULINT_TO_LDATE USINT_TO_LDATE WORD_TO_LDATE LDT __UXINT_TO_LDT __XINT_TO_LDT __XWORD_TO_LDT BIT_TO_LDT BYTE_TO_LDT DINT_TO_LDT DWORD_TO_LDT INT_TO_LDT LINT_TO_LDT LWORD_TO_LDT SINT_TO_LDT UDINT_TO_LDT UINT_TO_LDT ULINT_TO_LDT USINT_TO_LDT WORD_TO_LDT LINT __UXINT_TO_LINT __XINT_TO_LINT __XWORD_TO_LINT BIT_TO_LINT BYTE_TO_LINT DINT_TO_LINT DWORD_TO_LINT INT_TO_LINT - LWORD_TO_LINT SINT_TO_LINT UDINT_TO_LINT UINT_TO_LINT ULINT_TO_LINT USINT_TO_LINT WORD_TO_LINT LREAL __UXINT_TO_LREAL __XINT_TO_LREAL __XWORD_TO_LREAL BIT_TO_LREAL BYTE_TO_LREAL DINT_TO_LREAL DWORD_TO_LREAL INT_TO_LREAL LINT_TO_LREAL LWORD_TO_LREAL SINT_TO_LREAL UDINT_TO_LREAL UINT_TO_LREAL ULINT_TO_LREAL USINT_TO_LREAL WORD_TO_LREAL LTIME __UXINT_TO_LTIME __XINT_TO_LTIME __XWORD_TO_LTIME BIT_TO_LTIME BYTE_TO_LTIME DINT_TO_LTIME DWORD_TO_LTIME INT_TO_LTIME LINT_TO_LTIME LWORD_TO_LTIME SINT_TO_LTIME UDINT_TO_LTIME UINT_TO_LTIME ULINT_TO_LTIME USINT_TO_LTIME WORD_TO_LTIME LTOD __UXINT_TO_LTOD __XINT_TO_LTOD __XWORD_TO_LTOD BIT_TO_LTOD BYTE_TO_LTOD DINT_TO_LTOD DWORD_TO_LTOD INT_TO_LTOD LINT_TO_LTOD LWORD_TO_LTOD SINT_TO_LTOD UDINT_TO_LTOD UINT_TO_LTOD ULINT_TO_LTOD USINT_TO_LTOD WORD_TO_LTOD LWORD __UXINT_TO_LWORD __XINT_TO_LWORD __XWORD_TO_LWORD BIT_TO_LWORD BYTE_TO_LWORD DINT_TO_LWORD DWORD_TO_LWORD INT_TO_LWORD LINT_TO_LWORD - SINT_TO_LWORD UDINT_TO_LWORD UINT_TO_LWORD ULINT_TO_LWORD USINT_TO_LWORD WORD_TO_LWORD REAL __UXINT_TO_REAL __XINT_TO_REAL __XWORD_TO_REAL BIT_TO_REAL BYTE_TO_REAL DINT_TO_REAL DWORD_TO_REAL INT_TO_REAL LINT_TO_REAL LWORD_TO_REAL SINT_TO_REAL UDINT_TO_REAL UINT_TO_REAL ULINT_TO_REAL USINT_TO_REAL WORD_TO_REAL SINT __UXINT_TO_SINT __XINT_TO_SINT __XWORD_TO_SINT BIT_TO_SINT BYTE_TO_SINT DINT_TO_SINT DWORD_TO_SINT INT_TO_SINT LINT_TO_SINT LWORD_TO_SINT - UDINT_TO_SINT UINT_TO_SINT ULINT_TO_SINT USINT_TO_SINT WORD_TO_SINT STRING __UXINT_TO_STRING __XINT_TO_STRING __XWORD_TO_STRING BIT_TO_STRING BYTE_TO_STRING DINT_TO_STRING DWORD_TO_STRING INT_TO_STRING LINT_TO_STRING LWORD_TO_STRING SINT_TO_STRING UDINT_TO_STRING UINT_TO_STRING ULINT_TO_STRING USINT_TO_STRING WORD_TO_STRING TIME __UXINT_TO_TIME __XINT_TO_TIME __XWORD_TO_TIME BIT_TO_TIME BYTE_TO_TIME DINT_TO_TIME DWORD_TO_TIME INT_TO_TIME LINT_TO_TIME LWORD_TO_TIME SINT_TO_TIME UDINT_TO_TIME UINT_TO_TIME ULINT_TO_TIME USINT_TO_TIME WORD_TO_TIME TOD __UXINT_TO_TOD __XINT_TO_TOD __XWORD_TO_TOD BIT_TO_TOD BYTE_TO_TOD DINT_TO_TOD DWORD_TO_TOD INT_TO_TOD LINT_TO_TOD LWORD_TO_TOD SINT_TO_TOD UDINT_TO_TOD UINT_TO_TOD ULINT_TO_TOD USINT_TO_TOD WORD_TO_TOD UDINT __UXINT_TO_UDINT __XINT_TO_UDINT __XWORD_TO_UDINT BIT_TO_UDINT BYTE_TO_UDINT DINT_TO_UDINT DWORD_TO_UDINT INT_TO_UDINT LINT_TO_UDINT LWORD_TO_UDINT SINT_TO_UDINT - UINT_TO_UDINT ULINT_TO_UDINT USINT_TO_UDINT WORD_TO_UDINT UINT __UXINT_TO_UINT __XINT_TO_UINT __XWORD_TO_UINT BIT_TO_UINT BYTE_TO_UINT DINT_TO_UINT DWORD_TO_UINT INT_TO_UINT LINT_TO_UINT LWORD_TO_UINT SINT_TO_UINT UDINT_TO_UINT - ULINT_TO_UINT USINT_TO_UINT WORD_TO_UINT ULINT __UXINT_TO_ULINT __XINT_TO_ULINT __XWORD_TO_ULINT BIT_TO_ULINT BYTE_TO_ULINT DINT_TO_ULINT DWORD_TO_ULINT INT_TO_ULINT LINT_TO_ULINT LWORD_TO_ULINT SINT_TO_ULINT UDINT_TO_ULINT UINT_TO_ULINT - USINT_TO_ULINT WORD_TO_ULINT USINT __UXINT_TO_USINT __XINT_TO_USINT __XWORD_TO_USINT BIT_TO_USINT BYTE_TO_USINT DINT_TO_USINT DWORD_TO_USINT INT_TO_USINT LINT_TO_USINT LWORD_TO_USINT SINT_TO_USINT UDINT_TO_USINT UINT_TO_USINT ULINT_TO_USINT - WORD_TO_USINT WORD __UXINT_TO_WORD __XINT_TO_WORD __XWORD_TO_WORD BIT_TO_WORD BYTE_TO_WORD DINT_TO_WORD DWORD_TO_WORD INT_TO_WORD LINT_TO_WORD LWORD_TO_WORD SINT_TO_WORD UDINT_TO_WORD UINT_TO_WORD ULINT_TO_WORD USINT_TO_WORD - WSTRING __UXINT_TO_WSTRING __XINT_TO_WSTRING __XWORD_TO_WSTRING BIT_TO_WSTRING BYTE_TO_WSTRING DINT_TO_WSTRING DWORD_TO_WSTRING INT_TO_WSTRING LINT_TO_WSTRING LWORD_TO_WSTRING SINT_TO_WSTRING UDINT_TO_WSTRING UINT_TO_WSTRING ULINT_TO_WSTRING USINT_TO_WSTRING WORD_TO_WSTRING " }, 
{ "title" : "转换为字符串 ", 
"url" : "_cds_operator_convert_integer.html#UUID-c464d72e-00eb-40f2-a434-5347b8dfb565_UUID-b3638e7b-8068-7a4c-97c9-8f7221718057_id_a4835caebc899e35c0a8640e0071a02e_id_be3e4f6f29f3e031c0a8646345a1318e", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换：整数 \/ 转换为字符串 ", 
"snippet" : "将值转换为字符串类型的运算符 STRING 或者 WSTRING 需要一个与目标数据类型匹配的操作数。...", 
"body" : "将值转换为字符串类型的运算符 STRING 或者 WSTRING 需要一个与目标数据类型匹配的操作数。 " }, 
{ "title" : "例子 ", 
"url" : "_cds_operator_convert_integer.html#UUID-c464d72e-00eb-40f2-a434-5347b8dfb565_UUID-b3638e7b-8068-7a4c-97c9-8f7221718057_section-idm4556665049587232791080776043", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换：整数 \/ 例子 ", 
"snippet" : "示例：功能块 – ConvertIntegers 当较大的数据类型转换为较小的数据类型时，会截断更多的高位（前）字节。当较小的数据类型转换为较大的数据类型时，更多的高位字节用零填充。 FB_ConvertIntegersFromInt 的 ST 声明 FUNCTION_BLOCK FB_ConvertIntegersFromInt VAR uxiReturn: __UXINT; xiReturn: __XINT; xwReturn: __XWORD; bitReturn: BIT; xReturn: BOOL; bReturn: BYTE; dateReturn: DATE; diReturn...", 
"body" : "示例：功能块 – ConvertIntegers 当较大的数据类型转换为较小的数据类型时，会截断更多的高位（前）字节。当较小的数据类型转换为较大的数据类型时，更多的高位字节用零填充。 FB_ConvertIntegersFromInt 的 ST 声明 FUNCTION_BLOCK FB_ConvertIntegersFromInt\nVAR\n uxiReturn: __UXINT;\n xiReturn: __XINT;\n xwReturn: __XWORD;\n bitReturn: BIT;\n xReturn: BOOL;\n bReturn: BYTE;\n dateReturn: DATE;\n diReturn: DINT;\n dtReturn: DATE_AND_TIME;\n dwReturn: DWORD;\n liReturn: LINT;\n lrReturn: LREAL;\n lwReturn: LWORD;\n siReturn: SINT;\n sReturn: STRING;\n timReturn: TIME;\n todReturn: TIME_OF_DAY;\n udiReturn: UDINT;\n uiReturn: UINT;\n usiReturn: USINT;\n wReturn: WORD;\n wsReturn: WSTRING;\n uliReturn: ULINT;\nEND_VAR FB_ConvertIntegersFromInt 在 ST 中的实现 uxiReturn := INT_TO___UXINT(127);\nxiReturn := INT_TO___XINT(127);\nxwReturn := INT_TO___XWORD(127);\nbitReturn := INT_TO_BIT(127);\nxReturn := INT_TO_BOOL(127);\nbReturn := INT_TO_BYTE(127);\ndateReturn := INT_TO_DATE(127);\ndiReturn := INT_TO_DINT(127);\ndtReturn := INT_TO_DT(127);\ndwReturn := INT_TO_DWORD(127);\nliReturn := INT_TO_LINT(127);\nlrReturn := INT_TO_LREAL(127);\nlwReturn := INT_TO_LWORD(127);\nsiReturn := INT_TO_SINT(127);\nsReturn := INT_TO_STRING(127);\ntimReturn := INT_TO_TIME(127);\ntodReturn := INT_TO_TOD(127);\nudiReturn := INT_TO_UDINT(127);\nuiReturn := INT_TO_UINT(127);\nuliReturn := INT_TO_ULINT(127);\nusiReturn := INT_TO_USINT(127);\nwReturn := INT_TO_WORD(127);\nwsReturn := INT_TO_WSTRING(127); FB_ConvertIntegersToInt 的 ST 中的声明 FUNCTION_BLOCK FB_ConvertIntegersToInt\nVAR\n iReturn_uxi: INT;\n iReturn_xi: INT;\n iReturn_xw: INT;\n iReturn_bit: INT;\n iReturn_bool: INT;\n iReturn_b: INT;\n iReturn_d: INT;\n iReturn_di: INT;\n iReturn_dt: INT;\n iReturn_dw: INT;\n iReturn_li: INT;\n iReturn_lr: INT;\n iReturn_lw: INT;\n iReturn_r: INT;\n iReturn_si: INT;\n iReturn_s: INT;\n iReturn_tim: INT;\n iReturn_tod: INT;\n iReturn_tod_0: INT;\n iReturn_udi: INT;\n iReturn_ui: INT;\n iReturn_uli: INT;\n iReturn_usi: INT;\n iReturn_w: INT;\n iReturn_ws: INT;\nEND_VAR\n FB_ConvertIntegersToInt 的 ST 实现 FUNCTION_BLOCK FB_ConvertIntegersFromInt\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n uxiReturn: __UXINT;\n xiReturn: __XINT;\n xwReturn: __XWORD;\n bitReturn: BIT;\n xReturn: BOOL;\n bReturn: BYTE;\n dateReturn: DATE;\n diReturn: DINT;\n dtReturn: DATE_AND_TIME;\n dwReturn: DWORD;\n liReturn: LINT;\n lrReturn: LREAL;\n lwReturn: LWORD;\n siReturn: SINT;\n sReturn: STRING;\n timReturn: TIME;\n todReturn: TIME_OF_DAY;\n udiReturn: UDINT;\n uiReturn: UINT;\n usiReturn: USINT;\n wReturn: WORD;\n wsReturn: WSTRING;\n uliReturn: ULINT;\nEND_VAR\n\nuxiReturn := INT_TO___UXINT(127);\nxiReturn := INT_TO___XINT(127);\nxwReturn := INT_TO___XWORD(127);\nbitReturn := INT_TO_BIT(127);\nxReturn := INT_TO_BOOL(127);\nbReturn := INT_TO_BYTE(127);\ndateReturn := INT_TO_DATE(127);\ndiReturn := INT_TO_DINT(127);\ndtReturn := INT_TO_DT(127);\ndwReturn := INT_TO_DWORD(127);\nliReturn := INT_TO_LINT(127);\nlrReturn := INT_TO_LREAL(127);\nlwReturn := INT_TO_LWORD(127);\nsiReturn := INT_TO_SINT(127);\nsReturn := INT_TO_STRING(127);\ntimReturn := INT_TO_TIME(127);\ntodReturn := INT_TO_TOD(127);\nudiReturn := INT_TO_UDINT(127);\nuiReturn := INT_TO_UINT(127);\nuliReturn := INT_TO_ULINT(127);\nusiReturn := INT_TO_USINT(127);\nwReturn := INT_TO_WORD(127);\nwsReturn := INT_TO_WSTRING(127);\n\nFUNCTION_BLOCK FB_ConvertIntegersToInt\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iReturn_uxi: INT;\n iReturn_xi: INT;\n iReturn_xw: INT;\n iReturn_bit: INT;\n iReturn_bool: INT;\n iReturn_b: INT;\n iReturn_d: INT;\n iReturn_di: INT;\n iReturn_dt: INT;\n iReturn_dw: INT;\n iReturn_li: INT;\n iReturn_lr: INT;\n iReturn_lw: INT;\n iReturn_r: INT;\n iReturn_si: INT;\n iReturn_s: INT;\n iReturn_tim: INT;\n iReturn_tod: INT;\n iReturn_tod_0: INT;\n iReturn_udi: INT;\n iReturn_ui: INT;\n iReturn_uli: INT;\n iReturn_usi: INT;\n iReturn_w: INT;\n iReturn_ws: INT;\nEND_VAR\n\niReturn_uxi := __UXINT_TO_INT(18446744073709551615);\niReturn_xi := __XINT_TO_INT(9223372036854775807);\niReturn_xw := __XWORD_TO_INT(16#FFFF_FFFF_FFFF_FFFF);\niReturn_bit := BIT_TO_INT(1);\niReturn_bool := BOOL_TO_INT(TRUE);\niReturn_b := BYTE_TO_INT(2#1111_0000);\niReturn_d := DATE_TO_INT(DATE#2019-9-13);\niReturn_di := DINT_TO_INT(2147483647);\niReturn_dt := DT_TO_INT(DT#1979-1-1-00:00:00);\niReturn_dw := DWORD_TO_INT(16#FFFF_FFFF);\n\/\/ iReturn_i := INT_TO_<>(iData_12);\niReturn_li := LINT_TO_INT(9223372036854775807);\niReturn_lr := LREAL_TO_INT(1.7976931348623157E+30);\niReturn_lw := LWORD_TO_INT(16#FFFF_FFFF_FFFF_FFFF);\niReturn_r := REAL_TO_INT(3.402823E+38);\niReturn_si := SINT_TO_INT(127);\niReturn_s := STRING_TO_INT('127');\niReturn_tim := TIME_TO_INT(T#49D17H2M47S295MS);\niReturn_tod := TOD_TO_INT(TOD#23:59:59.999);\niReturn_tod_0 := TOD_TO_INT(TOD#1:1:1.001);\niReturn_udi := UDINT_TO_INT(4294967295);\niReturn_ui := UINT_TO_INT(65535);\niReturn_uli := ULINT_TO_INT(18446744073709551615);\niReturn_usi := USINT_TO_INT(255);\niReturn_w := WORD_TO_INT(16#FFFF);\niReturn_ws := WSTRING_TO_INT(\"1234567890\");\n\nPROGRAM PLC_PRG\nVAR\n fbConvertIntegersFromInt : FB_ConvertIntegersFromInt;\n fbConvertIntegersToInt : FB_ConvertIntegersToInt;\nEND_VAR\n\nfbConvertIntegersFromInt();\nfbConvertIntegersToInt(); 执行 示例：FBD 中的 ConvertIntegers " }, 
{ "title" : "转换：REAL、LREAL ", 
"url" : "_cds_operator_real_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换：REAL、LREAL ", 
"snippet" : "REAL, LREAL 如果浮点数在目标数据类型的值范围内，则转换在所有系统上以相同的方式进行。 如果浮点数超出范围限制，则不考虑该数字的第一个字节。 运算符将浮点数转换为指定的数据类型并返回类型转换的值。如果适用，转换是四舍五入的。 如果 REAL_TO_<目标类型> 转换时，值首先转换为 UDINT 然后才转换为目标类型。 对于 LREAL_TO_<目标类型> 转换时，值首先转换为 ULINT 然后才转换为目标类型。 调用语法 ： REAL_TO_<目标类型>(<操作数>) ， LREAL_TO_<目标类型>(<操作数>) 操作数 类型 描述 变量或文字 REAL ， LREAL REAL...", 
"body" : "REAL, LREAL 如果浮点数在目标数据类型的值范围内，则转换在所有系统上以相同的方式进行。 如果浮点数超出范围限制，则不考虑该数字的第一个字节。 运算符将浮点数转换为指定的数据类型并返回类型转换的值。如果适用，转换是四舍五入的。 如果 REAL_TO_<目标类型> 转换时，值首先转换为 UDINT 然后才转换为目标类型。 对于 LREAL_TO_<目标类型> 转换时，值首先转换为 ULINT 然后才转换为目标类型。 调用语法 ： REAL_TO_<目标类型>(<操作数>) ， LREAL_TO_<目标类型>(<操作数>) 操作数 类型 描述 变量或文字 REAL ， LREAL REAL, LREAL操作员： REAL\/LREAL_TO_<target type> 运算符：REAL 运算符：LREAL 例子 返回值 REAL_TO___UXINT LREAL_TO___UXINT REAL_TO___UXINT(1.234) LREAL_TO___UXINT(0.987654321) 1 1 __UXINT、__XINT、__XWORD REAL_TO___XINT LREAL_TO___XINT __UXINT、__XINT、__XWORD REAL_TO___XWORD LREAL_TO___XWORD __UXINT、__XINT、__XWORD REAL_TO_BIT LREAL_TO_BIT BIT REAL_TO_BOOL LREAL_TO_BOOL LREAL_TO_BOOL(0.987654321) TRUE BIT REAL_TO_BYTE LREAL_TO_BYTE REAL_TO_BYTE(1.234) LREAL_TO_BYTE(0.987654321) 1 Integer REAL_TO_DATE LREAL_TO_DATE REAL_TO_DATE(1.234) LREAL_TO_DATE(0.987654321) D#1970-1-1 数据类型：DATE REAL_TO_DINT LREAL_TO_DINT REAL_TO_DINT(1.234) 1 Integer REAL_TO_DT LREAL_TO_DT REAL_TO_DT(1.234) D#1970-1-1-0:0:1 数据类型：DATE REAL_TO_DWORD LREAL_TO_DWORD REAL_TO_DWORD(1.234) 32#1 Integer REAL_TO_INT LREAL_TO_INT REAL_TO_INT(-1.5) -2 Integer REAL_TO_LDATE LREAL_TO_LDATE REAL_TO_LDATE(1.234) DT#1970-1-1 在内部，它首先被转换为 ULINT 然后该值以日期形式返回。 REAL_TO_LDT LREAL_TO_LDT LREAL_TO_DT(0.987654321) D#1970-1-1-0:0:1 目标数据类型： LDATE_AND_TIME 数据类型：DATE REAL_TO_LINT LREAL_TO_LINT REAL_TO_LINT(1.234) 1 Integer REAL_TO_LTOD LREAL_TO_LTOD 数据类型：DATE REAL_TO_LREAL - REAL_TO_LREAL(1.234) 1.234 REAL, LREAL REAL_TO_LTIME LREAL_TO_LTIME 在内部，它首先被转换为 ULINT 然后该值将像 ns 中一样返回。 数据类型：TIME、LTIME REAL_TO_LWORD LREAL_TO_LWORD Integer- LREAL_TO_REAL REAL_TO_SINT LREAL_TO_SINT Integer REAL_TO_STRING LREAL_TO_STRING REAL_TO_STRING(1.234) '1.234' STRING REAL_TO_TIME LREAL_TO_TIME REAL_TO_TIME(1.234) T#1ms 在内部，它首先被转换为 ULINT，然后以 ms 为单位返回值。 数据类型：TIME、LTIME REAL_TO_TOD LREAL_TO_TOD REAL_TO_TOD(1.234) TOD#0:0:0.001 在内部，它首先被转换为 UDINT，然后将值作为 TOD 返回。 语法：TOD#hh:mm:ss.sss 数据类型：DATE REAL_TO_UDINT LREAL_TO_UDINT Integer REAL_TO_UINT LREAL_TO_UINT Integer REAL_TO_ULINT LREAL_TO_ULINT Integer REAL_TO_USINT LREAL_TO_USINT Integer REAL_TO__WORD LREAL_TO__WORD REAL_TO_WORD(1.2345678E11) 1 Integer REAL_TO_WSTRING LREAL_TO_WSTRING REAL_TO_WSTRING(1.23456789E11) \"1.234\" WSTRING" }, 
{ "title" : "四舍五入 ", 
"url" : "_cds_operator_real_to.html#UUID-09b58433-72d6-ced4-b25c-4160070bab9d_UUID-66c29c06-37d8-0602-04a7-7b5bcba80db6_id_a34c7ecbeec3bac0a8640e014adbad_id_d62d1f013f678288c0a864631fef9174", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换：REAL、LREAL \/ 四舍五入 ", 
"snippet" : "转换为整数时，操作数向上或向下舍入为整数值。对于小数点后的 1 到 4，数字向下舍入。对于 5 到 9，数字向上取整。然后将四舍五入的数字转换为指定的整数类型。如果四舍五入的值超出整数值范围，则返回未定义的目标系统相关值。那时也可能出现异常错误。...", 
"body" : "转换为整数时，操作数向上或向下舍入为整数值。对于小数点后的 1 到 4，数字向下舍入。对于 5 到 9，数字向上取整。然后将四舍五入的数字转换为指定的整数类型。如果四舍五入的值超出整数值范围，则返回未定义的目标系统相关值。那时也可能出现异常错误。 " }, 
{ "title" : "转换为字符串 ", 
"url" : "_cds_operator_real_to.html#UUID-09b58433-72d6-ced4-b25c-4160070bab9d_UUID-66c29c06-37d8-0602-04a7-7b5bcba80db6_id_a34c7ecbeec3bac0a8640e014adbad_id_6cad15a820cf3bd8c0a864633b32def9", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换：REAL、LREAL \/ 转换为字符串 ", 
"snippet" : "对于浮点数到字符串的转换，尾数的小数位数限制为 6。如果数字 < 1，则尾数为 1 <= m < 10 .如果尾数在逗号后有更多位数，则将其四舍五入到第 6 位，然后进行转换。 对于返回值，字符串变量也可能被声明得太短。在这种情况下，返回字符串在右侧被截断。 例子...", 
"body" : "对于浮点数到字符串的转换，尾数的小数位数限制为 6。如果数字 < 1，则尾数为 1 <= m < 10 .如果尾数在逗号后有更多位数，则将其四舍五入到第 6 位，然后进行转换。 对于返回值，字符串变量也可能被声明得太短。在这种情况下，返回字符串在右侧被截断。 例子 " }, 
{ "title" : "转换：STRING，WSTRING ", 
"url" : "_cds_operator_string_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换：STRING，WSTRING ", 
"snippet" : "STRING, WSTRING 运算符转换字符串 ( STRING 或者 WSTRING ) 转换为指定的目标数据类型并返回类型转换的值。 仅当操作数根据 IEC 61131-3 标准与目标数据类型匹配时，才能进行具有有意义结果的转换。如果操作数的值对应于目标数据类型的有效常量（文字），就会出现这种情况。 可转换字符串包含： 带类型前缀的数字（例如： '16#FFFFFFFF' ) 带有分组字符的数字（例如： '2#1111_1111' ) 注意：不接受国际度量衡分组字符（细空格）。只接受下划线。 浮点数，也是指数表示法（例如： '9.876' 或者 '1.2E-34' ) 注意：浮点数不可转...", 
"body" : "STRING, WSTRING 运算符转换字符串 ( STRING 或者 WSTRING ) 转换为指定的目标数据类型并返回类型转换的值。 仅当操作数根据 IEC 61131-3 标准与目标数据类型匹配时，才能进行具有有意义结果的转换。如果操作数的值对应于目标数据类型的有效常量（文字），就会出现这种情况。 可转换字符串包含： 带类型前缀的数字（例如： '16#FFFFFFFF' ) 带有分组字符的数字（例如： '2#1111_1111' ) 注意：不接受国际度量衡分组字符（细空格）。只接受下划线。 浮点数，也是指数表示法（例如： '9.876' 或者 '1.2E-34' ) 注意：浮点数不可转换。逗号会像后面的字符一样被处理和截断。 带有前缀和大小的时间、时间和日期规范（例如： 'T#2h' , 'DT#2019-9-9-12:30:30.9' ) 无限值（例如： '1.7E+400' ) 附加字符 后 一个数字（例如： '2m' 或者 '3.14' ) 这些被截断。附加字符 前 不允许使用数字。 前面的空格（例如： '3.14' ) 调用语法 ： STRING_TO_<目标类型>(<操作数>) ， WSTRING_TO_<目标类型>(<操作数>) 操作数 数据类型 描述 变量或文字 STRING ， WSTRING STRING, WSTRING铸造操作员： STRING\/WSTRING_TO_<target type> 运算符：STRING 运算符：WSTRING 例子 返回值 描述  STRING_TO___UXINT WSTRING_TO___UXINT __UXINT、__XINT、__XWORD  STRING_TO___XINT WSTRING_TO___XINT __UXINT、__XINT、__XWORD  STRING_TO___XWORD WSTRING_TO___XWORD __UXINT、__XINT、__XWORD  STRING_TO_BIT WSTRING_TO_BIT BIT STRING_TO_BOOL WSTRING_TO_BOOL STRING_TO_BOOL('TRUE') STRING_TO_BOOL('true') WSTRING_TO_BOOL(\"TRUE\") WSTRING_TO_BOOL(\"true\") TRUE BOOL STRING_TO_BYTE WSTRING_TO_BYTE Integer STRING_TO_DATE WSTRING_TO_DATE STRING_TO_DATE('DATE#2019-9-9') WSTRING_TO_DATE(\"DATE#2019-9-9\") D#2019-9-9 句法： D#yyyy-MM-dd 数据类型：DATE STRING_TO_DINT WSTRING_TO_DINT 如果输出数据类型较大，则信息可能会丢失。 Integer STRING_TO_DT WSTRING_TO_DT STRING_TO_DT('DT#2019-9-9-1:1:1.1') WSTRING_TO_DT(\"DT#2019-9-9-1:1:1.1\") DT#2019-9-9-1:1:1 DT#2019-9-9-1:1:1 句法： DT#yyyy-MM-dd-hh:mm:ss 数据类型：DATE STRING_TO_DWORD WSTRING_TO_DWORD Integer STRING_TO_INT WSTRING_TO_INT STRING_TO_INT('123abc') WSTRING_TO_INT(\"123abc\") 123 Integer STRING_TO_LDATE WSTRING_TO_LDATE 句法： LDATE#yyyy-MM-dd 仅显示日期。 数据类型：DATE STRING_TO_LDT WSTRING_TO_LDT 句法： LDT#yyyy-MM-dd-hh:mm:ss.sss 数据类型：DATE STRING_TO_LINT WSTRING_TO_LINT Integer STRING_TO_LREAL WSTRING_TO_LREAL STRING_TO_LREAL('1.7E+308') WSTRING_TO_LREAL(\"1.7E+308\") 1.7000000000000001E+308 REAL, LREAL STRING_TO_LTIME WSTRING_TO_LTIME STRING_TO_LTIME('LTIME#709ms551us615ns') STRING_TO_LTIME('LTIME#1ms') WSTRING_TO_LTIME(\"LTIME#1ms\") LTIME#709ms551us615ns LTIME#1ms 数据类型：TIME、LTIME STRING_TO_LTOD WSTRING_TO_LTOD 句法： LTOD#hh:mm:ss.sssssssss 数据类型：DATE STRING_TO_LWORD WSTRING_TO_LWORD STRING_TO_LWORD('16#0123456789ABCDEF') WSTRING_TO_LWORD(\"16#0123456789ABCDEF\") 81985529216486895 Integer STRING_TO_REAL WSTRING_TO_REAL STRING_TO_REAL('1.234') WSTRING_TO_REAL(\"1.234\") 1.234 从较大的值范围转换时，信息可能会丢失或返回未定义的结果。 REAL, LREAL STRING_TO_SINT WSTRING_TO_SINT Integer- WSTRING_TO_STRING WSTRING_TO_STRING(\"Hello World!\") Hello World! STRING_TO_TIME WSTRING_TO_TIME STRING_TO_TIME('T#5d4h3m2s') WSTRING_TO_TIME(\"T#5d4h3m2s\") T#5d4h3m2s 数据类型：TIME、LTIME STRING_TO_TOD WSTRING_TO_TOD STRING_TO_TOD('TOD#20:15') WSTRING_TO_TOD(\"TOD#20:15\") TOD#20:15:0 数据类型：DATE STRING_TO_UDINT WSTRING_TO_UDINT Integer STRING_TO_UINT WSTRING_TO_UINT Integer STRING_TO_ULINT WSTRING_TO_ULINT STRING_TO_ULINT('615') WSTRING_TO_ULINT(\"615\") 615 Integer STRING_TO_USINT WSTRING_TO_USINT Integer STRING_TO_WORD WSTRING_TO_WORD Integer STRING_TO_WSTRING - STRING_TO_WSTRING('Hello World!') \"Hello World!\" WSTRING" }, 
{ "title" : "转换为布尔值 ", 
"url" : "_cds_operator_string_to.html#UUID-5ac2f0be-631a-851c-bdec-0e60611c4db1_UUID-fa2f799f-42c9-2838-9daf-a4b39b9aca2c_id_f500d27d07eb3bec0a8640e013e049a_id_7a13d4613f6786bbc0a864632e419b0d", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换：STRING，WSTRING \/ 转换为布尔值 ", 
"snippet" : "操作员 STRING_TO_BOOL ：一个值 TRUE 仅当操作数值为 'TRUE' 或者 'true' .另一方面， FALSE 被退回 'True' . 操作员 WSTRING_TO_BOOL ：一个值 TRUE 仅当操作数值为 \"TRUE\" 或者 \"true\" .另一方面， FALSE 被退回 \"True\" ....", 
"body" : "操作员 STRING_TO_BOOL ：一个值 TRUE 仅当操作数值为 'TRUE' 或者 'true' .另一方面， FALSE 被退回 'True' . 操作员 WSTRING_TO_BOOL ：一个值 TRUE 仅当操作数值为 \"TRUE\" 或者 \"true\" .另一方面， FALSE 被退回 \"True\" . " }, 
{ "title" : "例子 ", 
"url" : "_cds_operator_string_to.html#UUID-5ac2f0be-631a-851c-bdec-0e60611c4db1_UUID-fa2f799f-42c9-2838-9daf-a4b39b9aca2c_id_f500d27d07eb3bec0a8640e013e049a_id_817822c5d48a11e9a9c394579cee6999", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换：STRING，WSTRING \/ 例子 ", 
"snippet" : "FB_转换字符串 宣言 FUNCTION_BLOCK FB_ConvertStrings VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR xReturn_0: BOOL; xReturn_1: BOOL; dateReturn: DATE; dtReturn: DATE_AND_TIME; iReturn: INT; lrReturn: LREAL; lrReturn_0: LREAL; lwReturn: LWORD; lwReturn_0: LWORD; lwReturn_1: LWORD; ltReturn: LTIME; ltReturn_0: LTI...", 
"body" : "FB_转换字符串 宣言 FUNCTION_BLOCK FB_ConvertStrings\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n\t xReturn_0: BOOL;\n\txReturn_1: BOOL;\n\tdateReturn: DATE;\n\tdtReturn: DATE_AND_TIME;\n\tiReturn: INT;\n\tlrReturn: LREAL;\n\tlrReturn_0: LREAL;\n\tlwReturn: LWORD;\n\tlwReturn_0: LWORD;\n\tlwReturn_1: LWORD;\n\tltReturn: LTIME;\n\tltReturn_0: LTIME;\n\tltReturn_1: LTIME;\n\tltReturn_2: LTIME;\n\trReturn: REAL;\n\trReturn_0: REAL;\n\ttimReturn: TIME;\n\ttimReturn0: TIME;\n\ttimReturn1: TIME;\n\ttimReturn2: TIME;\n\ttodReturn: TIME_OF_DAY;\n\ttodReturn0: TIME_OF_DAY;\n\ttodReturn1: TIME_OF_DAY;\n\ttodReturn2: TIME_OF_DAY;\n\tuliReturn: ULINT;\n\tuliReturn_0: ULINT;\n\tuliReturn_1: ULINT;\n\twReturn: WORD;\n\twReturn_0: WORD;\n\twReturn_1: WORD;\n\twstrReturn: WSTRING;\n\twstrReturn_0: WSTRING;\n\tdtReturn2: DATE_AND_TIME;\nEND_VAR 执行 FUNCTION_BLOCK FB_ConvertStrings\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n xReturn_0: BOOL;\n xReturn_1: BOOL;\n dateReturn: DATE;\n dtReturn: DATE_AND_TIME;\n iReturn: INT;\n lrReturn: LREAL;\n lrReturn_0: LREAL;\n lwReturn: LWORD;\n lwReturn_0: LWORD;\n lwReturn_1: LWORD;\n ltReturn: LTIME;\n ltReturn_0: LTIME;\n ltReturn_1: LTIME;\n ltReturn_2: LTIME;\n rReturn: REAL;\n rReturn_0: REAL;\n timReturn: TIME;\n timReturn0: TIME;\n timReturn1: TIME;\n timReturn2: TIME;\n todReturn: TIME_OF_DAY;\n todReturn0: TIME_OF_DAY;\n todReturn1: TIME_OF_DAY;\n todReturn2: TIME_OF_DAY;\n uliReturn: ULINT;\n uliReturn_0: ULINT;\n uliReturn_1: ULINT;\n wReturn: WORD;\n wReturn_0: WORD;\n wReturn_1: WORD;\n wstrReturn: WSTRING;\n wstrReturn_0: WSTRING;\nEND_VAR\nxReturn_0 := STRING_TO_BOOL('FALSE');\nxReturn_1 := STRING_TO_BOOL('TRUE');\ndateReturn := STRING_TO_DATE('DATE#2019-9-9');\ndtReturn := STRING_TO_DT('DT#2019-9-9-1:1:1.1');\niReturn := STRING_TO_INT('123abc');\nlrReturn := STRING_TO_LREAL('4.94E-323');\nlrReturn_0 := STRING_TO_LREAL('1.7E+308');\nlwReturn := STRING_TO_LWORD('16#FFFF_FFFF_FFFF_FFFF');\nlwReturn_0 := STRING_TO_LWORD('16#0123456789ABCDEF');\nlwReturn_1 := STRING_TO_LWORD('16#0123456789ABCDEF');\nltReturn := STRING_TO_LTIME('LTIME#213503d23h34m33s709ms551us615ns');\nltReturn_0 := STRING_TO_LTIME('LTIME#0ns');\nltReturn_1 := STRING_TO_LTIME('LTIME#1ms');\nltReturn_2 := STRING_TO_LTIME('LTIME#2s');\nrReturn := STRING_TO_REAL('6.543e21');\nrReturn_0 := STRING_TO_REAL('1.234');\ntimReturn := STRING_TO_TIME('T#5d4h3m2s');\ntimReturn0 := STRING_TO_TIME('TIME#1s');\ntimReturn1 := STRING_TO_TIME('1s');\ntimReturn2 := STRING_TO_TIME('TIME#5s');\ntodReturn := STRING_TO_TOD('TOD#12:0:0.1');\ntodReturn0 := STRING_TO_TOD('TOD#0:0:0.0');\ntodReturn1 := STRING_TO_TOD('20:15');\ntodReturn2 := STRING_TO_TOD('TOD#20:15');\nuliReturn := STRING_TO_ULINT('18446744073709551615');\nuliReturn_0 := STRING_TO_ULINT('1');\nuliReturn_1 := STRING_TO_ULINT('0');\nwReturn := STRING_TO_WORD('16#FFFF_0000');\nwReturn_0 := STRING_TO_WORD('34abc');\nwReturn_1 := STRING_TO_WORD('16#34abc');\nwstrReturn := STRING_TO_WSTRING('Hello World!');\nwstrReturn_0 := STRING_TO_WSTRING('123456789'); ST 实现语言 宣言 FUNCTION_BLOCK FB_ConvertWstrings\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n\txReturn_0: BOOL;\n\txReturn_1: BOOL;\n\tdateReturn: DATE;\n\tdtReturn: DATE_AND_TIME;\n\tiReturn: INT;\n\tlrReturn: LREAL;\n\tlrReturn_0: LREAL;\n\tlwReturn: LWORD;\n\tlwReturn_0: LWORD;\n\tlwReturn_1: LWORD;\n\tltReturn: LTIME;\n\tltReturn_0: LTIME;\n\tltReturn_1: LTIME;\n\tltReturn_2: LTIME;\n\trReturn: REAL;\n\trReturn_0: REAL;\n\ttimReturn: TIME;\n\ttimReturn0: TIME;\n\ttimReturn1: TIME;\n\ttimReturn2: TIME;\n\ttodReturn: TIME_OF_DAY;\n\ttodReturn0: TIME_OF_DAY;\n\ttodReturn1: TIME_OF_DAY;\n\ttodReturn2: TIME_OF_DAY;\n\tuliReturn: ULINT;\n\tuliReturn_0: ULINT;\n\tuliReturn_1: ULINT;\n\twReturn: WORD;\n\twReturn_0: WORD;\n\twReturn_1: WORD;\n\twstrReturn: WSTRING;\n\twstrReturn_0: WSTRING;\nEND_VAR\n 在 ST 中的实现 FUNCTION_BLOCK FB_ConvertWstrings\nVAR\n xReturn_0: BOOL;\n xReturn_1: BOOL;\n dateReturn: DATE;\n dtReturn: DATE_AND_TIME;\n iReturn: INT;\n lrReturn: LREAL;\n lrReturn_0: LREAL;\n lwReturn: LWORD;\n lwReturn_0: LWORD;\n lwReturn_1: LWORD;\n ltReturn: LTIME;\n ltReturn_0: LTIME;\n ltReturn_1: LTIME;\n ltReturn_2: LTIME;\n rReturn: REAL;\n rReturn_0: REAL;\n timReturn: TIME;\n timReturn0: TIME;\n timReturn1: TIME;\n timReturn2: TIME;\n todReturn: TIME_OF_DAY;\n todReturn0: TIME_OF_DAY;\n todReturn1: TIME_OF_DAY;\n todReturn2: TIME_OF_DAY;\n uliReturn: ULINT;\n uliReturn_0: ULINT;\n uliReturn_1: ULINT;\n wReturn: WORD;\n wReturn_0: WORD;\n wReturn_1: WORD;\n wstrReturn: WSTRING;\n wstrReturn_0: WSTRING;\nEND_VAR\n\nxReturn_0 := WSTRING_TO_BOOL(\"FALSE\");\nxReturn_1 := WSTRING_TO_BOOL(\"TRUE\");\ndateReturn := WSTRING_TO_DATE(\"DATE#2019-9-9\");\ndtReturn := WSTRING_TO_DT(\"DT#2019-9-9-1:1:1.1\");\niReturn := WSTRING_TO_INT(\"123abc\");\nlrReturn := WSTRING_TO_LREAL(\"4.94E-323\");\nlrReturn_0 := WSTRING_TO_LREAL(\"1.7E+308\");\nlwReturn := WSTRING_TO_LWORD(\"16#FFFF_FFFF_FFFF_FFFF\");\nlwReturn_0 := WSTRING_TO_LWORD(\"16#0123456789ABCDEF\");\nlwReturn_1 := WSTRING_TO_LWORD(\"16#0123456789ABCDEF\");\nltReturn := WSTRING_TO_LTIME(\"LTIME#213503d23h34m33s709ms551us615ns\");\nltReturn_0 := WSTRING_TO_LTIME(\"LTIME#0ns\");\nltReturn_1 := WSTRING_TO_LTIME(\"LTIME#1ms\");\nltReturn_2 := WSTRING_TO_LTIME(\"LTIME#2s\");\nrReturn := WSTRING_TO_REAL(\"6.543e21\");\nrReturn_0 := WSTRING_TO_REAL(\"1.234\");\ntimReturn := WSTRING_TO_TIME(\"T#5d4h3m2s\");\ntimReturn0 := WSTRING_TO_TIME(\"TIME#1s\");\ntimReturn1 := WSTRING_TO_TIME(\"1s\");\ntimReturn2 := WSTRING_TO_TIME(\"TIME#5s\");\ntodReturn := WSTRING_TO_TOD(\"TOD#12:0:0.1\");\ntodReturn0 := WSTRING_TO_TOD(\"TOD#0:0:0.0\");\ntodReturn1 := WSTRING_TO_TOD(\"20:15\");\ntodReturn2 := WSTRING_TO_TOD(\"TOD#20:15\");\nuliReturn := WSTRING_TO_ULINT(\"18446744073709551615\");\nuliReturn_0 := WSTRING_TO_ULINT(\"1\");\nuliReturn_1 := WSTRING_TO_ULINT(\"0\");\nwReturn := WSTRING_TO_WORD(\"16#FFFF_0000\");\nwReturn_0 := WSTRING_TO_WORD(\"34abc\");\nwReturn_1 := WSTRING_TO_WORD(\"16#34abc\"); FBD 实现语言 " }, 
{ "title" : "时间转换 ", 
"url" : "_cds_operator_time_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 时间转换 ", 
"snippet" : "TIME, LTIME 运算符转换时间值 ( TIME 或者 LIME ) 转换为指定的数据类型并返回此类型转换的值。 调用语法 ： <TIME_TO<目标类型> ( <操作数> ) ， <LTIME_TO<目标类型> ( <操作数> ) 操作数 数据类型 描述 变量或文字 TIME ， LTIME 数据类型：TIME、LTIME转换运算符：TIME\/LTIME_TO_<目标类型> 操作员 操作员 例子 返回值 描述 TIME_TO___UXINT LTIME_TO___UXINT __UXINT、__XINT、__XWORD TIME_TO___XINT LTIME_TO___XINT __...", 
"body" : "TIME, LTIME 运算符转换时间值 ( TIME 或者 LIME ) 转换为指定的数据类型并返回此类型转换的值。 调用语法 ： <TIME_TO<目标类型> ( <操作数> ) ， <LTIME_TO<目标类型> ( <操作数> ) 操作数 数据类型 描述 变量或文字 TIME ， LTIME 数据类型：TIME、LTIME转换运算符：TIME\/LTIME_TO_<目标类型> 操作员 操作员 例子 返回值 描述 TIME_TO___UXINT LTIME_TO___UXINT __UXINT、__XINT、__XWORD TIME_TO___XINT LTIME_TO___XINT __UXINT、__XINT、__XWORD TIME_TO___XWORD LTIME_TO___XWORD __UXINT、__XINT、__XWORD TIME_TO_BIT LTIME_TO_BIT BIT TIME_TO_BOOL LTIME_TO_BOOL TIME_TO_BOOL(T#0MS);\nTIME_TO_BOOL(T#59ms);\nLTIME_TO_BOOL(T#0MS);\nLTIME_TO_BOOL(T#59ms); FALSE TRUE 运营商返回 FALSE 当且仅当操作数的值可以解释为“0”。 BOOL TIME_TO_BYTE LTIME_TO_BYTE Integer TIME_TO_DATE LTIME_TO_DATE LTIME_TO_DATE(LTIME#2us1ns); D#1970-1-1 语法：D#yyyy-MM-dd 数据类型：DATE TIME_TO_DINT LTIME_TO_DINT TIME_TO_DT LTIME_TO_DT TIME_TO_DT(T#5d4h3m2s1ms);\nLTIME_TO_DT(LTIME#2us1ns); D#1970-1-1-0:0:0.000000012 语法：DT#yyyy-MM-dd-hh:mm:ss 数据类型：DATE TIME_TO_DWORD LTIME_TO_DWORD Integer TIME_TO_INT LTIME_TO_INT LTIME_TO_INT(LTIME#2us1ns); 0 Integer TIME_TO_LDATE LTIME_TO_LDATE 语法：LDATE#yyyy-MM-dd 数据类型：DATE TIME_TO_LDT LTIME_TO_LDT 句法： LDT#yyyy-MM-dd-hh:mm:ss.sss 数据类型：DATE TIME_TO_LINT LTIME_TO_LINT Integer TIME_TO_LREAL LTIME_TO_LREAL TIME_TO_LREAL(T#5d4h3m2s1ms); x.x TIME_TO_LTIME - TIME_TO_LTOD LTIME_TO_LTOD 句法： LTOD#hh:mm:ss.sssssssss 数据类型：DATE TIME_TO_LWORD LTIME_TO_LWORD TIME_TO_LWORD(T#5d4h3m2s1ms);\nLTIME_TO_LWORD(LTIME#2us1ns); 0 Integer TIME_TO_REAL LTIME_TO_REAL TIME_TO_REAL(T#1d2h3m4s5ms);\nLTIME_TO_REAL(LTIME#2us1ns); 9.28E+07 0.0 REAL, LREAL TIME_TO_SINT LTIME_TO_SINT Integer TIME_TO_STRING LTIME_TO_STRING TIME_TO_STRING(T#0MS); 'T#0MS' 重要提示：输入的值作为字符串左对齐，如果太长会被截断。因此，声明返回变量时应足够长，以便字符串有足够的空间而无需进行任何操作。 STRING- LTIME_TO_TIME LTIME_TO_TIME(LTIME#2us1ns); T#0ms 数据类型：TIME、LTIME TIME_TO_TOD LTIME_TO_TOD TIME_TO_TOD(T#1d2h3m4s5ms);\nLTIME_TO_TOD(LTIME#2us1ns);\n TOD#2:3:4.005 TOD#0:0:0 数据类型：DATE TIME_TO_UDINT LTIME_TO_UDINT Integer TIME_TO_UINT LTIME_TO_UINT Integer TIME_TO_ULINT LTIME_TO_ULINT TIME_TO_ULINT(T#1d2h3m4s5ms); 93784005 Integer TIME_TO_USINT LTIME_TO_USINT Integer TIME_TO_WORD LTIME_TO_WORD Integer TIME_TO_WSTRING LTIME_TO_WSTRING TIME_TO_WSTRING(T#1d2h3m4s5ms);\nLTIME_TO_WSTRING(T#0US); \"T1d2h3m4s5ms\" \"T#0US\" 输入的值作为字符串左对齐，如果太长会被截断。因此，声明返回变量时应足够长，以使字符串有足够的空间而无需进行任何操作。 WSTRING" }, 
{ "title" : "例子 ", 
"url" : "_cds_operator_time_to.html#UUID-d9d61e4b-1f08-f156-98e7-b50526508425_UUID-05a4d27d-06ae-5b64-4c72-be0a87863b24_id_f415c6acc0350d7c0a8640e00547f10_id_3dd96edd20dc20dcc0a8646366ed7fd7", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 时间转换 \/ 例子 ", 
"snippet" : "ST实现语言 ST 中的声明 FUNCTION_BLOCK FB_ConvertTimeAndDate VAR ltReturn_1: LTIME; lwReturn_2: LWORD; rReturn_3: REAL; strReturn_4: STRING; timReturn_5: TIME; todReturn_6: TIME_OF_DAY; uliReurn_7: ULINT; wstrReturn_8: WSTRING; wstrReturn_80: WSTRING; uliReurn_70: ULINT; todReturn_60: TIME_OF_DAY; timReturn_...", 
"body" : "ST实现语言 ST 中的声明 FUNCTION_BLOCK FB_ConvertTimeAndDate\nVAR\n ltReturn_1: LTIME;\n lwReturn_2: LWORD;\n rReturn_3: REAL;\n strReturn_4: STRING;\n timReturn_5: TIME;\n todReturn_6: TIME_OF_DAY;\n uliReurn_7: ULINT;\n wstrReturn_8: WSTRING;\n wstrReturn_80: WSTRING;\n uliReurn_70: ULINT;\n todReturn_60: TIME_OF_DAY;\n timReturn_50: TIME;\n strReturn_40: STRING;\n rReturn_30: REAL;\n lwReturn_20: LWORD;\n ltReturn_10: LTIME;\n ltReturn_11: LTIME;\n lwReturn_21: LWORD;\n rReturn_31: REAL;\n strReturn_41: STRING;\n timReturn_51: TIME;\n todRedurn_61: TIME_OF_DAY;\n uliReurn_71: ULINT;\n wstrReturn_81: WSTRING;\n ltReturn_12: LTIME;\n xReturn_9: BOOL;\n xReturn_90: BOOL;\n xReturn_91: BOOL;\n xReturn_92: BOOL;\n dateReturn_6: DATE;\n timReturn_60: TIME;\n wReturn_61: WORD;\n todReturn_61: TIME_OF_DAY;\nEND_VAR\n 在 ST 中的实现 FUNCTION_BLOCK FB_ConvertTimeAndDate\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n ltReturn_1: LTIME;\n lwReturn_2: LWORD;\n rReturn_3: REAL;\n strReturn_4: STRING;\n timReturn_5: TIME;\n todReturn_6: TIME_OF_DAY;\n uliReurn_7: ULINT;\n wstrReturn_8: WSTRING;\n wstrReturn_80: WSTRING;\n uliReurn_70: ULINT;\n todReturn_60: TIME_OF_DAY;\n timReturn_50: TIME;\n strReturn_40: STRING;\n rReturn_30: REAL;\n lwReturn_20: LWORD;\n ltReturn_10: LTIME;\n ltReturn_11: LTIME;\n lwReturn_21: LWORD;\n rReturn_31: REAL;\n strReturn_41: STRING;\n timReturn_51: TIME;\n todRedurn_61: TIME_OF_DAY;\n uliReurn_71: ULINT;\n wstrReturn_81: WSTRING;\n ltReturn_12: LTIME;\n xReturn_9: BOOL;\n xReturn_90: BOOL;\n xReturn_91: BOOL;\n xReturn_92: BOOL;\n dateReturn_6: DATE;\n timReturn_60: TIME;\n wReturn_61: WORD;\n todReturn_61: TIME_OF_DAY;\nEND_VAR\n\nltReturn_1 := DT_TO_LTIME(DT#2019-9-9-23:59:59);\nltReturn_10 := DT_TO_LTIME(DT#1970-1-1-0:0:0);\nltReturn_11 := DT_TO_LTIME(DT#1970-1-2-0:0:1);\nltReturn_12 := DT_TO_LTIME(DT#1970-1-3-12:30:30);\n\nlwReturn_2 := TIME_TO_LWORD(T#5D4H2M3S2MS);\nlwReturn_20 := TIME_TO_LWORD(T#0D0H0M0S0MS);\n\nrReturn_3 := TIME_TO_REAL(T#5D4H2M3S2MS);\nrReturn_30 := TIME_TO_REAL(T#0D0H0M0S0MS);\n\nstrREturn_4 := TIME_TO_STRING(T#5D4H2M3S2MS);\nstrREturn_40 := TIME_TO_STRING(T#0D0H0M0S0MS);\n\ntimReturn_5 := TOD_TO_TIME(TOD#23:59:59.999);\ntimReturn_50 := TOD_TO_TIME(TOD#0:0:0.000);\ntimReturn_51 := TOD_TO_TIME(TOD#0:0:0.001);\n\ndateReturn_6 := TOD_TO_DATE(TOD#23:59:59.999);\ntimReturn_60 := TOD_TO_TIME(TOD#0:0:0.000);\nwReturn_61 := TOD_TO_WORD(TOD#0:0:0.001);\n\nuliReurn_7 := DATE_TO_ULINT(D#2019-9-9);\nuliReurn_70 := DATE_TO_ULINT(D#1970-1-1);\nuliReurn_71 := DATE_TO_ULINT(D#1970-1-2);\n\nwstrReturn_8 := DATE_TO_WSTRING(D#2019-9-9);\nwstrReturn_80 := DATE_TO_WSTRING(D#1970-1-1);\nwstrReturn_81 := DATE_TO_WSTRING(D#1970-1-2);\n\nxReturn_9 := DATE_TO_BOOL(D#2019-9-9);\nxReturn_90 := DATE_TO_BOOL(D#1970-1-1);\nxReturn_91 := DATE_TO_BOOL(D#1970-1-2);\nxReturn_92 := DATE_TO_BOOL(D#1970-1-3); FBD 实现语言 " }, 
{ "title" : "转换：DATE、DT、TOD、LDATE、LDT、LTOD ", 
"url" : "_cds_operator_date_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换：DATE、DT、TOD、LDATE、LDT、LTOD ", 
"snippet" : "DATE, DT, TOD, LDATE, LDT, LTOD 运算符将日期和时间值转换为指定的数据类型并返回类型转换的值。 数据类型 DATE 和 DT 在内部使用相同的内存格式并存储为 DWORD .决议为 DATE 是 1 天。决议为 DT 是 1 秒。两者都始于 1970 年 1 月 1 日。 TOD 存储为 DWORD 分辨率为 1 毫秒。 关键词 DT 和 TOD 是数据类型的替代拼写 DATE_AND_TIME 和 TIME_OF_DAY 然而后者并没有映射为类型转换命令。 数据类型 LDATE 和 LDT 和 LTOD 使用 64 位内存格式 LWORD 内部。 调用语法 ： ...", 
"body" : "DATE, DT, TOD, LDATE, LDT, LTOD 运算符将日期和时间值转换为指定的数据类型并返回类型转换的值。 数据类型 DATE 和 DT 在内部使用相同的内存格式并存储为 DWORD .决议为 DATE 是 1 天。决议为 DT 是 1 秒。两者都始于 1970 年 1 月 1 日。 TOD 存储为 DWORD 分辨率为 1 毫秒。 关键词 DT 和 TOD 是数据类型的替代拼写 DATE_AND_TIME 和 TIME_OF_DAY 然而后者并没有映射为类型转换命令。 数据类型 LDATE 和 LDT 和 LTOD 使用 64 位内存格式 LWORD 内部。 调用语法 ： DATE\/DT\/TOD_TO_< 目标类型> ( <操作数> ) 调用语法 ： LDATE\/LDT\/LTOD_TO_< 目标类型> ( <操作数> ) 操作数 数据类型 描述 变量或文字 DATE | DATE_AND_TIME | DT | TIME_OF_DAY | TOD LDATE | LDATE_AND_TIME | LDT | LTIME_OF_DAY | LTOD 数据类型：DATE运算符：DATE\/DT\/TOD_TO_<目标类型> DATE_TO_<类型> DT_TO_<类型> TOD_TO_<类型> 例子 返回值 描述 DATE_TO___UXINT DT_TO___UXINT TOD_TO___XINT __UXINT、__XINT、__XWORD DATE_TO___XINT DT_TO___XINT TOD_TO___XINT __UXINT、__XINT、__XWORD DATE_TO___XWORD DT_TO___XWORD TOD_TO___XWORD __UXINT、__XINT、__XWORD DATE_TO_BIT DT_TO_BIT TOD_TO_BIT BIT DATE_TO_BOOL DT_TO_BOOL TOD_TO_BOOL DATE_TO_BOOL(D#1970-1-1)\nDATE_TO_BOOL(D#2019-9-1)\nDT_TO_BOOL(DT#1970-1-1-0:0:0)\nDT_TO_BOOL(DT#2019-9-1-12:0:0)\nTOD_TO_BOOL(TOD#0:0:0)\nTOD_TO_BOOL(TOD#12:0:0)\n FALSE TRUE FALSE TRUE FALSE TRUE 当且仅当操作数值可以解释为“0”时，运算符才返回 FALSE 。 BOOL DATE_TO_BYTE DT_TO_BYTE DTOD_TO_BYTE Integer- DT_TO_DATE TOD_TO_DATE 分辨率以秒为单位（尽管仅显示日期） DATE_TO_DINT DT_TO_DINT TOD_TO_DINT DATE_TO_DINT(D#1970-1-1)\nDATE_TO_DINT(D#1970-1-2)\nDATE_TO_DINT(D#2019-9-1)\nDT_TO_DINT(DT#1970-1-1-0:0:0)\nDT_TO_DINT(DT#1970-1-1-0:0:1)\nDT_TO_DINT(DT#2019-9-1-12:0:0.0)\nTOD_TO_DINT(TOD#0:0:0)\nTOD_TO_DINT(TOD#12:0:0)\n 0 86400 1567339200 0 1 1567339200 0 43200000 Integer DATE_TO_DT - TOD_TO_DT 数据类型：DATE DATE_TO_DWORD DT_TO_DWORD TOD_TO_DWORD Integer DATE_TO_INT DT_TO_INT TOD_TO_INT Integer DATE_TO_LDATE DT_TO_LDATE TOD_TO_LDATE 数据类型：DATE DATE_TO_LDT DT_TO_LDT TOD_TO_LDT 数据类型：DATE DATE_TO_LINT DT_TO_LINT TOD_TO_LINT Integer DATE_TO_LREAL DT_TO_LREAL TOD_TO_LREAL REAL, LREAL DATE_TO_LTIME DT_TO_LTIME TOD_TO_LTIME 数据类型：DATE DATE_TO_LTOD DT_TO_LTOD TOD_TO_LTOD 数据类型：DATE DATE_TO_LWORD DT_TO_LWORD TOD_TO_LWORD Integer DATE_TO_REAL DT_TO_REAL TOD_TO_REAL REAL, LREAL DATE_TO_SINT DT_TO_SINT TOD_TO_SINT Integer DATE_TO_STRING DT_TO_STRING TOD_TO_STRING DATE_TO_STRING(D#1970-1-1)\nDT_TO_STRING(D#1970-1-1-0:0:1)\nTOD_TO_STRING(12:0:1) 'D#1970-1-1' 'D#1970-1-1-0:0:1' 'TOD#12:0:1' STRING DATE_TO_TIME DT_TO_TIME TOD_TO_TIME 数据类型：DATE DATE_TO_TOD DT_TO_TOD - 数据类型：DATE DATE_TO_UDINT DT_TO_UDINT TOD_TO_UDINT Integer DATE_TO_UINT DT_TO_UINT TOD_TO_UINT Integer DATE_TO_ULINT DT_TO_ULINT TOD_TO_ULINT Integer DATE_TO_USINT DT_TO_USINT TODE_TO_USINT Integer DATE_TO_WORD DT_TO_WORD TOD_TO_WORD Integer DATE_TO_WSTRING DT_TO_WSTRING TOD_TO_WSTRING DATE_TO_WSTRING(D#1970-1-1)\nDT_TO_WSTRING(D#1970-1-1-0:0:1)\nTOD_TO_WSTRING(12:0:1) \"D#1970-1-1\" \"D#1970-1-1-0:0:1\" \"TOD#12:0:0\" WSTRING运算符：LDATE\/LDT\/LTOD_TO_<目标类型> LDATE_TO_<类型> LDT_TO_<类型> LTOD_TO_<类型> 例子 返回值 描述 LDATE_TO___UXINT LDT_TO___UXINT LTOD_TO___XINT __UXINT、__XINT、__XWORD LDATE_TO___XINT LDT_TO___XINT LTOD_TO___XINT __UXINT、__XINT、__XWORD LDATE_TO___XWORD LDT_TO___XWORD LTOD_TO___XWORD __UXINT、__XINT、__XWORD LDATE_TO_BIT LDT_TO_BIT LTOD_TO_BIT BIT LDATE_TO_BOOL LDT_TO_BOOL LTOD_TO_BOOL BOOL LDATE_TO_BYTE LDT_TO_BYTE LTOD_TO_BYTE Integer LDATE_TO_DATE LDT_TO_DATE LTOD_TO_DATE 秒（尽管只显示日期） 数据类型：DATE LDATE_TO_DINT LDT_TO_DINT LTOD_TO_DINT Integer LDATE_TO_DT LDT_TO_DT LTOD_TO_DT 数据类型：DATE LDATE_TO_DWORD LDT_TO_DWORD LTOD_TO_DWORD Integer LDATE_TO_INT LDT_TO_INT LTOD_TO_INT Integer- LDT_TO_LDATE LTOD_TO_LDATE 纳秒（尽管只显示日期） 数据类型：DATE LDATE_TO_LDT - LTOD_TO_LDT 数据类型：DATE LDATE_TO_LINT LDT_TO_LINT LTOD_TO_LINT Integer LDATE_TO_LREAL LDT_TO_LREAL LTOD_TO_LREAL REAL, LREAL LDATE_TO_LTIME LDT_TO_LTIME LTOD_TO_LTIME 数据类型：DATE LDATE_TO_LTOD LDT_TO_LTOD - 数据类型：DATE LDATE_TO_LWORD LDT_TO_LWORD LTOD_TO_LWORD Integer LDATE_TO_REAL LDT_TO_REAL LTOD_TO_REAL REAL, LREAL LDATE_TO_SINT LDT_TO_SINT LTOD_TO_SINT Integer LDATE_TO_STRING LDT_TO_STRING LTOD_TO_STRING STRING LDATE_TO_TIME LDT_TO_TIME LTOD_TO_TIME 数据类型：DATE LDATE_TO_TOD LDT_TO_TOD LTOD_TO_TOD 数据类型：DATE LDATE_TO_UDINT LDT_TO_UDINT LTOD_TO_UDINT Integer LDATE_TO_UINT LDT_TO_UINT LTOD_TO_UINT Integer LDATE_TO_ULINT LDT_TO_ULINT LTOD_TO_ULINT Integer LDATE_TO_USINT LDT_TO_USINT LTOD_TO_USINT Integer LDATE_TO_WORD LDT_TO_WORD LTOD_TO_WORD Integer LDATE_TO_WSTRING LDT_TO_WSTRING LTOD_TO_WSTRING WSTRING" }, 
{ "title" : "转换为字符串 ", 
"url" : "_cds_operator_date_to.html#UUID-4ca6892c-e4a7-a5a0-9012-c85dca949d72_UUID-404aff3f-2280-a807-32f4-4186c7d8a3ae_id_af0e820ad05f2c39c0a8640e01c81eb6_id_05525fb43f678c87c0a864636e32204e", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换：DATE、DT、TOD、LDATE、LDT、LTOD \/ 转换为字符串 ", 
"snippet" : "类型的操作数 DATE , DATE_AND_TIME , TIME_OF_DAY , DT ， 或者 TOD ，它们被传递给操作符进行数据和时间转换，被转换成它们的常量语法（字面量语法）。生成的字符串包含关键字 D# , DT# 或者 TOD# 然后是大小及其数据和时间单位，如 IEC 61131-3 规范中所示。...", 
"body" : "类型的操作数 DATE , DATE_AND_TIME , TIME_OF_DAY , DT ， 或者 TOD ，它们被传递给操作符进行数据和时间转换，被转换成它们的常量语法（字面量语法）。生成的字符串包含关键字 D# , DT# 或者 TOD# 然后是大小及其数据和时间单位，如 IEC 61131-3 规范中所示。 " }, 
{ "title" : "例子 ", 
"url" : "_cds_operator_date_to.html#UUID-4ca6892c-e4a7-a5a0-9012-c85dca949d72_UUID-404aff3f-2280-a807-32f4-4186c7d8a3ae_id_af0e820ad05f2c39c0a8640e01c81eb6_id_f19e7b8120d3eba4c0a864632cdf6b1f", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 转换：DATE、DT、TOD、LDATE、LDT、LTOD \/ 例子 ", 
"snippet" : "FBD 实现语言 控制器处于在线模式以监控变量。...", 
"body" : "FBD 实现语言 控制器处于在线模式以监控变量。 " }, 
{ "title" : "运营商：TRUNC ", 
"url" : "_cds_operator_trunc.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 运营商：TRUNC ", 
"snippet" : "TRUNC IEC 运算符用于转换 REAL 数据类型进入 DINT 数据类型。 只取数字的整数部分。 在 ， 这 TRUNC 运算符转换 REAL 进入 INT .如果导入 V2.3 项目，则 自动替换 TRUNC 和 TRUNC_INT . 如果 不能用 a 表示输入值 DINT 或者 INT , 那么这个函数的结果是未定义的。此类输入值的行为取决于平台。 例子 英石 diVar := TRUNC(1.9); (* Result: 1 *) diVar := TRUNC(-1.4); (* Result: -1 *)...", 
"body" : "TRUNC IEC 运算符用于转换 REAL 数据类型进入 DINT 数据类型。 只取数字的整数部分。 在 ， 这 TRUNC 运算符转换 REAL 进入 INT .如果导入 V2.3 项目，则 自动替换 TRUNC 和 TRUNC_INT . 如果 不能用 a 表示输入值 DINT 或者 INT , 那么这个函数的结果是未定义的。此类输入值的行为取决于平台。 例子 英石 diVar := TRUNC(1.9); (* Result: 1 *)\n\ndiVar := TRUNC(-1.4); (* Result: -1 *) " }, 
{ "title" : "运算符：TRUNC_INT ", 
"url" : "_cds_operator_trunc_int.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 类型转换运算符 \/ 运算符：TRUNC_INT ", 
"snippet" : "TRUNC_INT IEC 运算符用于转换 REAL 数据类型进入 INT 数据类型。 只取数字的整数部分。 TRUNC_INT 对应于 TRUNC 运算符 ，此时导入V2.3项目时自动使用。注意变化函数 TRUNC . 如果 不能用 a 表示输入值 DINT 或者 INT , 那么这个函数的结果是未定义的。此类输入值的行为取决于平台。 例子 英石 iVar := TRUNC_INT(1.9); (* Result: 1 *) iVar := TRUNC_INT(-1.4); (* Result: -1 *)...", 
"body" : "TRUNC_INT IEC 运算符用于转换 REAL 数据类型进入 INT 数据类型。 只取数字的整数部分。 TRUNC_INT 对应于 TRUNC 运算符 ，此时导入V2.3项目时自动使用。注意变化函数 TRUNC . 如果 不能用 a 表示输入值 DINT 或者 INT , 那么这个函数的结果是未定义的。此类输入值的行为取决于平台。 例子 英石 iVar := TRUNC_INT(1.9); (* Result: 1 *)\n\niVar := TRUNC_INT(-1.4); (* Result: -1 *) " }, 
{ "title" : "操作数 ", 
"url" : "_cds_struct_reference_operands.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "常量和文字 ", 
"url" : "_cds_struct_reference_operands.html#UUID-aa359e50-e152-8177-ba90-37d4949fb3ba_section-idm4613159919964832678735357547", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常量和文字 ", 
"snippet" : "常量是不可更改值的标识符。您可以在 POU 中本地声明常量，也可以在全局变量列表中全局声明常量。声明段用关键字扩展 CONSTANT . 常量也是表示基类型值的字符串，例如整数或浮点数（例如， 16#FFFF_FFFF , T#5s ， 或者 -1.234 E-5 ）。为了区分它们，这些常量也称为字面量、字面量常量或未命名常量。有逻辑（ TRUE , FALSE ) 或数字文字 ( 3.1415 , T#5s )，还有字符串文字 ( 'Hello world!' , \"black\" ）。 语法声明 <scope> CONSTANT <identifier> : <data type> := <...", 
"body" : "常量是不可更改值的标识符。您可以在 POU 中本地声明常量，也可以在全局变量列表中全局声明常量。声明段用关键字扩展 CONSTANT . 常量也是表示基类型值的字符串，例如整数或浮点数（例如， 16#FFFF_FFFF , T#5s ， 或者 -1.234 E-5 ）。为了区分它们，这些常量也称为字面量、字面量常量或未命名常量。有逻辑（ TRUE , FALSE ) 或数字文字 ( 3.1415 , T#5s )，还有字符串文字 ( 'Hello world!' , \"black\" ）。 语法声明 <scope> CONSTANT\n <identifier> : <data type> := <initial value> ;\nEND_VAR\n\n<scope> : VAR | VAR_INPUT | VAR_STAT | VAR_GLOBAL\n<data type>: <elementary data type | user defined data type | function block >\n<initial value> : literal value | identifier | expression 允许的初始值： 文字 例子： TRUE , FALSE , 16#FFFF_FFFF 在另一个位置声明的命名常量 由字面量组成的简单表达式，也可以结合简单的运算符，例如 + - * 输入或函数调用不能指定为初始值。 例子 VAR_GLOBAL CONSTANT\n g_ciMAX_A : INT := 100;\n g_ciSPECIAL : INT := g_ciMAX_A - 10;\nEND_VAR 常量只为声明定义。需要分配初始值。在实现中，常量只能被读取，因此总是出现在语句中赋值运算符的右侧。 编译代码时，常量被替换为初始值。还必须能够在编译时计算初始值。 直到运行时才计算结构化或用户定义类型的常量。程序或 GVL 中的结构化常数在程序启动时计算一次。每次调用函数或方法时，都会计算函数或方法中的结构化常量。因此，结构化常量的初始化可以依赖于输入或执行函数调用。 " }, 
{ "title" : "变量 ", 
"url" : "_cds_struct_reference_operands.html#UUID-aa359e50-e152-8177-ba90-37d4949fb3ba_section-idm4613160443185632678735970218", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 变量 ", 
"snippet" : "您可以在 POU 的声明部分或全局变量列表中将变量声明为局部变量。变量的允许位置取决于其数据类型。 有关更多信息，请参阅： 访问数组、结构体和块中的变量 和 变量中的位访问...", 
"body" : "您可以在 POU 的声明部分或全局变量列表中将变量声明为局部变量。变量的允许位置取决于其数据类型。 有关更多信息，请参阅： 访问数组、结构体和块中的变量 和 变量中的位访问" }, 
{ "title" : "其他 ", 
"url" : "_cds_struct_reference_operands.html#UUID-aa359e50-e152-8177-ba90-37d4949fb3ba_section-idm461449035556323267873805769", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 其他 ", 
"snippet" : "有关更多信息，请参阅： 地址 和 职能...", 
"body" : "有关更多信息，请参阅： 地址 和 职能" }, 
{ "title" : "常量\n: BOOL ", 
"url" : "_cds_operands_constant_bool.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常量\n: BOOL ", 
"snippet" : "BOOL BOOL 常量是真值 TRUE (1) 和 FALSE (0)。 有关更多信息，请参阅： BOOL...", 
"body" : "BOOL BOOL 常量是真值 TRUE (1) 和 FALSE (0)。 有关更多信息，请参阅： BOOL" }, 
{ "title" : "常数：数字 ", 
"url" : "_cds_operands_constant_integer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常数：数字 ", 
"snippet" : "数值可以是二进制、八进制、十进制和十六进制数。如果整数值不是十进制数，则必须在整数常量之前写下它的基数，后跟数字符号 (#)。您可以像往常一样使用字母 AF 为数字 10 到 15 输入十六进制数字值。 您可以在数值中使用下划线。 例子： 14 十进制数 2#1001_0011 二进制数 8#67 八进制数 16#A 十六进制数 DINT#16#A1 类型化数据类型 DINT# 和基地 16# 结合 数字文字的可能数据类型： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT...", 
"body" : "数值可以是二进制、八进制、十进制和十六进制数。如果整数值不是十进制数，则必须在整数常量之前写下它的基数，后跟数字符号 (#)。您可以像往常一样使用字母 AF 为数字 10 到 15 输入十六进制数字值。 您可以在数值中使用下划线。 例子： 14 十进制数 2#1001_0011 二进制数 8#67 八进制数 16#A 十六进制数 DINT#16#A1 类型化数据类型 DINT# 和基地 16# 结合 数字文字的可能数据类型： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT 不允许从“较大”类型到“较小”类型的隐式转换。您不能简单地将 DINT 变量用作 INT 变量。为此，您必须使用类型转换功能。 有关更多信息，请参阅： 常量：类型化文字因为数字常量基本上是作为整数值处理的，所以在除法中，您必须以浮点数格式指定常量以避免丢失余数。 示例：除法 1\/10 产量 0 和划分 1.0\/10 产量 0.1 " }, 
{ "title" : "常量: REAL,LREAL ", 
"url" : "_cds_operands_constant_real.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常量: REAL,LREAL ", 
"snippet" : "您可以将浮点数指定为 REAL 和 LREAL 以十进制表示法或带有尾数和指数的指数表示法的常数。根据国际单位制（英语），小数点用作小数分隔符。 指数符号的语法 <significand> e | E <exponent> exponent : -44..38 \/\/ REAL exponent : -324..308 \/\/ LREAL 例子 REAL 文字 7.4 十进制数 7,4 带逗号返回编译器错误 1\/3.0 0.333333343 的小数部分 注意：在整数类型除法的情况下，结果仍然是整数类型。在这种情况下，该值是四舍五入的。例如，1\/3 的结果为 0。 1.64e+009 指数符号 -...", 
"body" : "您可以将浮点数指定为 REAL 和 LREAL 以十进制表示法或带有尾数和指数的指数表示法的常数。根据国际单位制（英语），小数点用作小数分隔符。 指数符号的语法 <significand> e | E <exponent> exponent : -44..38 \/\/ REAL\nexponent : -324..308 \/\/ LREAL 例子 REAL 文字 7.4 十进制数 7,4 带逗号返回编译器错误 1\/3.0 0.333333343 的小数部分 注意：在整数类型除法的情况下，结果仍然是整数类型。在这种情况下，该值是四舍五入的。例如，1\/3 的结果为 0。 1.64e+009 指数符号 -3.402823e+38 最小数 -1E-44 最大负数 1.0E-44 最小正数 3.402823e+38 最大数 LREAL 文字 -1.7976931348623157E+308 最小数 -4.94065645841247E-324 最大负数 4.94065645841247E-324 最小正数 1.7976931348623157E+308 最大数 有关更多信息，请参阅： REAL, LREAL" }, 
{ "title" : "字符串常量 ", 
"url" : "_cds_operands_constant_string.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 字符串常量 ", 
"snippet" : "细绳 字符串常量是用单引号括起来的字符串。字符根据 ISO\/IEC 8859-1 中指定的字符集进行编码。因此，字符串常量可以包含空格和重音字符，因为它们属于该字符集。这也称为字符串文字，或简称为字符串。 然而，当 字符串的 UTF-8 编码 编译选项已启用，字符串文字以 UTF-8 格式解释。此编码与 ASCII 以及 Latin-1 兼容。因此，十六进制代码和控制字符的特殊情况在 UTF-8 中也是有效的。 例子： 'Hello world!' 不检查字符串文字的兼容性。因此，文本编辑器允许输入所有字符。但是，编译器编译未知字符 ? ....", 
"body" : "细绳 字符串常量是用单引号括起来的字符串。字符根据 ISO\/IEC 8859-1 中指定的字符集进行编码。因此，字符串常量可以包含空格和重音字符，因为它们属于该字符集。这也称为字符串文字，或简称为字符串。 然而，当 字符串的 UTF-8 编码 编译选项已启用，字符串文字以 UTF-8 格式解释。此编码与 ASCII 以及 Latin-1 兼容。因此，十六进制代码和控制字符的特殊情况在 UTF-8 中也是有效的。 例子： 'Hello world!' 不检查字符串文字的兼容性。因此，文本编辑器允许输入所有字符。但是，编译器编译未知字符 ? . " }, 
{ "title" : "十六进制代码 ", 
"url" : "_cds_operands_constant_string.html#UUID-53b96aec-6e6d-af8b-2d30-6d54f4f8c3e0_section-idm4640076731518432920988296297", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 字符串常量 \/ 十六进制代码 ", 
"snippet" : "当美元符号 ($) 在字符串文字中时，根据 ISO\/IEC 8859-1 中的编码，以下两个字符被解释为十六进制代码。该代码也对应于 ASCII 代码。此外，请注意特殊情况和控制字符。 十六进制代码 带 $ 代码的字符串 解释 '$<8-bit code>' 8 位代码：根据 ISO\/IEC 8859-1 解释的两位十六进制数 '$41' A '$A9' © '$40' @ '$0D' 控制字符：换行符（对应于'$R'） '$0A' 控制字符：换行符（对应于'$L'和'$N'） 特别案例 带有 $ 代码的字符串 解释 '$L' , ' $l' 控制字符：换行（对应于 '$0A' ) '$N' ...", 
"body" : "当美元符号 ($) 在字符串文字中时，根据 ISO\/IEC 8859-1 中的编码，以下两个字符被解释为十六进制代码。该代码也对应于 ASCII 代码。此外，请注意特殊情况和控制字符。 十六进制代码 带 $ 代码的字符串 解释 '$<8-bit code>' 8 位代码：根据 ISO\/IEC 8859-1 解释的两位十六进制数 '$41' A '$A9' © '$40' @ '$0D' 控制字符：换行符（对应于'$R'） '$0A' 控制字符：换行符（对应于'$L'和'$N'） 特别案例 带有 $ 代码的字符串 解释 '$L' , ' $l' 控制字符：换行（对应于 '$0A' ) '$N' , '$n' 控制字符：换行（对应于 '$0A' ) '$P' , '$p' 控制字符：换页 '$R' , '$r' 控制字符：换行符（对应于 '$0D' ) '$T' , '$t' 控制字符：制表符 '$$' 美元符号： § '$'' 单直引号： ' 常量声明 VAR CONSTANT\n constA : STRING := 'Hello Allgäu';\n constB : STRING := 'Hello Allgäu $21'; \/\/ Hello Allgaeu!\nEND_VAR " }, 
{ "title" : "常量：UTF8# 字符串 ", 
"url" : "_cds_operands_constant_string_utf8.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常量：UTF8# 字符串 ", 
"snippet" : "UTF8#字符串 在编译器版本 >= 3.5.18.0 的情况下，UTF-8 编码的字符串文字可以作为具有基数的单字节字符串 STRING . 句法： UTF8#' <string literal> ' 常量声明 VAR CONSTANT constA : STRING := UTF8#'aäoöuü'; constB : STRING := UTF8#'Hello Allgäu $21'; \/\/ Hello Allgäu! END_VAR 为确保正确监控， 'monitoring_encoding' := 'UTF-8' 可以添加属性。 UTF-8 编码仅用于项目范围的配置 如果项目范围的编...", 
"body" : "UTF8#字符串 在编译器版本 >= 3.5.18.0 的情况下，UTF-8 编码的字符串文字可以作为具有基数的单字节字符串 STRING . 句法： UTF8#' <string literal> ' 常量声明 VAR CONSTANT\n constA : STRING := UTF8#'aäoöuü';\n constB : STRING := UTF8#'Hello Allgäu $21'; \/\/ Hello Allgäu!\nEND_VAR 为确保正确监控， 'monitoring_encoding' := 'UTF-8' 可以添加属性。 UTF-8 编码仅用于项目范围的配置 如果项目范围的编译选项使用 UTF-8 编码 字符串的 UTF8 编码 已启用。然后，库函数和附加组件也将根据此设置进行定向。 如果您使用单个 UTF-8 编码的字符串，那么您必须确保在使用它们的任何地方都能正确解释它们。例如，如果未选择该设置，则 OPC 服务器中的字符串变量将在传输到客户端之前转换为 UTF-8。值如 UTF8#'äöü' 那么就会被误解。在可视化中输出字符串时可能会出现类似的问题。 " }, 
{ "title" : "常数：字符 ", 
"url" : "_cds_operands_constant_character.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常数：字符 ", 
"snippet" : "特点 单个 Unicode 字符的字符文字具有基本类型 UDINT .类型前缀 UCHAR# 以文字作为标识符的前缀。字符文字的数值对应于 Unicode 标准的代码点。 句法： UCHAR#' <single charater> ' 文字 udiChar : UDINT := UCHAR#'ฒ'; \/\/ cp 3603 udiChar_1 : UDINT := UCHAR#'⳧'; \/\/ cp 11495...", 
"body" : "特点 单个 Unicode 字符的字符文字具有基本类型 UDINT .类型前缀 UCHAR# 以文字作为标识符的前缀。字符文字的数值对应于 Unicode 标准的代码点。 句法： UCHAR#' <single charater> ' 文字 udiChar : UDINT := UCHAR#'ฒ'; \/\/ cp 3603\nudiChar_1 : UDINT := UCHAR#'⳧'; \/\/ cp 11495 " }, 
{ "title" : "常数：TIME、LTIME ", 
"url" : "_cds_operands_constant_time.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常数：TIME、LTIME ", 
"snippet" : "您可以使用 TIME 常量来操作标准定时器模块。该常量的大小为 32 位，分辨率以毫秒为单位。 此外，时间常数 LTIME 可用作高分辨率计时器的时间基准。这 LTIME 常量的维度为 64 位，分辨率以纳秒为单位。...", 
"body" : "您可以使用 TIME 常量来操作标准定时器模块。该常量的大小为 32 位，分辨率以毫秒为单位。 此外，时间常数 LTIME 可用作高分辨率计时器的时间基准。这 LTIME 常量的维度为 64 位，分辨率以纳秒为单位。 " }, 
{ "title" : "常数: TIME ", 
"url" : "_cds_operands_constant_time.html#UUID-23174cc0-9514-a362-12b5-3a2a594aefce_id_d7e28b97a6ed17c0a8640e016ca2dd_id_137fbb3719b75a97c0a86463424aa10f", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常数：TIME、LTIME \/ 常数: TIME ", 
"snippet" : "句法 <time keyword> # <length of time> <time keyword> : TIME | time | T | t <length of time> : ( <number of days>d )? ( <number of hours>h )? ( <number of minutes>m )? ( <number of seconds>s )? (<number of milleseconds>ms)? \/\/ ( ...)? Optional 不得更改时间单位的顺序。但是，不需要指定所有单位。允许以大写形式指定单位。 时间单位 D | d ： 天 H | h...", 
"body" : "句法 <time keyword> # <length of time>\n\n<time keyword> : TIME | time | T | t\n<length of time> : ( <number of days>d )? ( <number of hours>h )? ( <number of minutes>m )? ( <number of seconds>s )? (<number of milleseconds>ms)? \/\/ ( ...)? Optional 不得更改时间单位的顺序。但是，不需要指定所有单位。允许以大写形式指定单位。 时间单位 D | d ： 天 H | h ： 小时 M | m ： 分钟 s | s : 秒 MS | ms : 毫秒 例子 更正 ST 分配的时间常数 VAR\n timLength : TIME := T#14ms;\n timLength1 : TIME := T#100s12ms; \/\/ Overflow in the highest unit is allowed.\n timLength2 : TIME := T#12h34m15s;\n timCompare : TIME;\n xIsOK: BOOL;\n\n timLongest := T#49D17H2M47S295MS; \/\/ 4294967295\nEND_VAR\n\nIF timLength < T#15MS THEN\n IF timCompare < timLength1 THEN\n xIsOK := TRUE;\n END_IF;\nEND_IF 使用不当 timIncorrect := t#5m68s; 低位溢出 timIncorrect1 := 15ms; 时间标记 T# 失踪 timIncorrect2 := t#4ms13d; 时间单位顺序不正确 " }, 
{ "title" : "常数：LTIME ", 
"url" : "_cds_operands_constant_time.html#UUID-23174cc0-9514-a362-12b5-3a2a594aefce_id_d7e28b97a6ed17c0a8640e016ca2dd_id_a8919c2919b75a97c0a864635c7068ea", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常数：TIME、LTIME \/ 常数：LTIME ", 
"snippet" : "句法 <long time keyword> # <length of high resolution time> <long time keyword> : LTIME | ltime <length of high resolution time> : <length of time> ( <number of microseconds>us )? ( <number of nanoseconds>ns )? \/\/ ( ...)? Optional 您可以使用相同的单位 LTIME 常数 TIME 常数。您还可以指定微秒和纳秒，因为指定的时间是以更高的时间分辨率计算的。 LTIME 文字在...", 
"body" : "句法 <long time keyword> # <length of high resolution time>\n\n<long time keyword> : LTIME | ltime\n<length of high resolution time> : <length of time> ( <number of microseconds>us )? ( <number of nanoseconds>ns )? \/\/ ( ...)? Optional 您可以使用相同的单位 LTIME 常数 TIME 常数。您还可以指定微秒和纳秒，因为指定的时间是以更高的时间分辨率计算的。 LTIME 文字在内部被视为数据类型 LWORD 因此该值以纳秒为单位解析。 额外的时间单位 US | us : 微秒 NS | ns : 纳秒 正确使用 ST 分配的示例 PROGRAM PLC_PRG\nVAR\n ltimLength := LTIME#1000d15h23m12s34ms2us44ns;\n ltimLength1 := LTIME#3445343m3424732874823ns;\nEND_VAR 有关更多信息，请参阅： 数据类型：TIME、LTIME 和 常量：日期和时间" }, 
{ "title" : "常量：日期和时间 ", 
"url" : "_cds_operands_constant_date.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常量：日期和时间 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "32 位日期规范：DATE ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_615fb5921fe0403dc0a864637afb9922", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常量：日期和时间 \/ 32 位日期规范：DATE ", 
"snippet" : "使用 DATE 关键字 ( D ) 来指定日期。 句法 <date keyword>#<year>-<month>-<day> <date keyword> : DATE | date | D | d <year> : 1970-2106 <month> : 1-12 <day> : 1-31 DATE 文字在内部被视为数据类型 DWORD ，这对应于的上限 DATE#2106-2-7 . 例子 PROGRAM PRG_Date VAR dateStart : DATE := DATE#2018-8-8; dateEnd : DATE := D#2018-8-31; dateCompare: ...", 
"body" : "使用 DATE 关键字 ( D ) 来指定日期。 句法 <date keyword>#<year>-<month>-<day>\n\n<date keyword> : DATE | date | D | d\n<year> : 1970-2106\n<month> : 1-12\n<day> : 1-31 DATE 文字在内部被视为数据类型 DWORD ，这对应于的上限 DATE#2106-2-7 . 例子 PROGRAM PRG_Date\nVAR\n dateStart : DATE := DATE#2018-8-8;\n dateEnd : DATE := D#2018-8-31;\n dateCompare: DATE := date#1996-05-06;\n xIsDuringTheTime: BOOL;\n\n dateEarliest : DATE := d#1970-1-1; \/\/ = 0\n dateLatest : DATE := DATE#2106-2-7; \/\/ = 4294967295\nEND_VAR\n\nIF dateStart < dateCompare THEN\n IF dateCompare < dateEnd THEN\n xIsDuringTheTime := TRUE;\n END_IF;\nEND_IF " }, 
{ "title" : "64 位日期规范：LDATE ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_aac82d911fe0403dc0a8646373b64fb2", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常量：日期和时间 \/ 64 位日期规范：LDATE ", 
"snippet" : "使用 LDATE 关键字 ( LD ) 来指定日期。 句法 <date keyword>#<year>-<month>-<day> <date keyword> : LDATE | ldate | LD | ld <year> : 1677-2262 <month> : 1-12 <day> : 1-31 LDATE 文字在内部被视为数据类型 LWORD ，这对应于的上限 DATE#2554-7-21 . 例子 PROGRAM PRG_Ldate VAR ldateStart : LDATE := LDATE#2018-8-8; ldateEnd : LDATE := ldate#2018-8...", 
"body" : "使用 LDATE 关键字 ( LD ) 来指定日期。 句法 <date keyword>#<year>-<month>-<day>\n\n<date keyword> : LDATE | ldate | LD | ld\n<year> : 1677-2262\n<month> : 1-12\n<day> : 1-31 LDATE 文字在内部被视为数据类型 LWORD ，这对应于的上限 DATE#2554-7-21 . 例子 PROGRAM PRG_Ldate\nVAR\n ldateStart : LDATE := LDATE#2018-8-8;\n ldateEnd : LDATE := ldate#2018-8-31;\n ldateCompare: LDATE := LD#1996-05-06;\n xIsDuringTheTime: BOOL;\n\n ldateEarliest : LDATE := ld#1677-9-22; \/\/ = 0\n ldateLatest : LDATE := LDATE#2262-4-11; \/\/ = 16#7FFFB21D1DB10000\n\n lwValue: LWORD;\nEND_VAR\n\nIF ldateStart < ldateCompare THEN\n IF ldateCompare < ldateEnd THEN\n xIsDuringTheTime := TRUE;\n END_IF;\nEND_IF\nlwValue := LDATE_TO_LWORD(ldateCompare); " }, 
{ "title" : "32 位日期和时间规范：DATE_AND_TIME ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_0042b76a1fe0403dc0a86463723e9a7f", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常量：日期和时间 \/ 32 位日期和时间规范：DATE_AND_TIME ", 
"snippet" : "使用 DATE_AND_TIME 关键字 ( DT ) 来指定日期和时间。 句法 <date and time keyword>#<date and time value> <date and time keyword> : DATE_AND_TIME | date_and_time | DT | dt <date and time value> : <year>-<month>-<day>-<hour>:<minute>:<second> <year> : 1970-2106 <month> : 1-12 <day> : 1-31 <hour> : 0-24 <minute> : 0-59 ...", 
"body" : "使用 DATE_AND_TIME 关键字 ( DT ) 来指定日期和时间。 句法 <date and time keyword>#<date and time value>\n\n<date and time keyword> : DATE_AND_TIME | date_and_time | DT | dt\n<date and time value> : <year>-<month>-<day>-<hour>:<minute>:<second>\n<year> : 1970-2106\n<month> : 1-12\n<day> : 1-31\n<hour> : 0-24\n<minute> : 0-59\n<second> : 0-59 DATE_AND_TIME 文字在内部被视为数据类型 DWORD .时间以秒为单位处理，因此可以采用从 1970 年 1 月 1 日 00:00 到 2106 年 2 月 7 日 06:28:15 的值。 例子 PROGRAM PLC_PRG\nVAR\n dtDate : DATE_AND_TIME := DATE_AND_TIME#1996-05-06-15:36:30;\n dtDate1: DATE_AND_TIME := DT#1972-03-29-00:00:00;\n dtDate2: DATE_AND_TIME := DT#2018-08-08-13:33:20.5;\n\n dtEarliest : DATE_AND_TIME := DATE_AND_TIME#1970-1-1-00:00:00; \/\/ 0\n dtLatest : DATE_AND_TIME := DATE_AND_TIME#2106-2-7-6:28:15; \/\/ 4294967295\nEND_VAR " }, 
{ "title" : "64 位日期和时间规范：LDATE_AND_TIME ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_5d8c31881fe0403dc0a8646357871614", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常量：日期和时间 \/ 64 位日期和时间规范：LDATE_AND_TIME ", 
"snippet" : "使用 LDATE_AND_TIME 关键字 ( LDT ) 来指定日期和时间。 句法 <date and time keyword>#<long date and time value> <date and time keyword> : LDATE_AND_TIME | ldate_and_time | LDT | ldt <date and time value> : <year>-<month>-<day>-<hour>:<minute>:<second> <year> : 1677-2262 <month> : 1-12 <day> : 1-31 <hour> : 0-24 <minu...", 
"body" : "使用 LDATE_AND_TIME 关键字 ( LDT ) 来指定日期和时间。 句法 <date and time keyword>#<long date and time value>\n\n<date and time keyword> : LDATE_AND_TIME | ldate_and_time | LDT | ldt\n<date and time value> : <year>-<month>-<day>-<hour>:<minute>:<second>\n<year> : 1677-2262\n<month> : 1-12\n<day> : 1-31\n<hour> : 0-24\n<minute> : 0-59\n<second> : 0-59 LDATE_AND_TIME#2262-4-10-23:59:59.99999999 LDATE_AND_TIME 字面量在内部被视为数据类型 LWORD 。时间以纳秒为单位进行处理，因此其值可以从 1677 年 9 月 21 日 00:12:43.145 224192 到 2262 23:47:16.854 775807 例子 PROGRAM PLC_PRG\nVAR\n ldtDate : LDATE_AND_TIME := LDATE_AND_TIME#1996-05-06-15:36:30;\n ldtDate1: LDATE_AND_TIME := LDT#1972-03-29-00:00:00;\n ldtDate2: LDATE_AND_TIME := LDT#2018-08-08-13:33:20.5;\n\n dtEarliest : LDT := LDT#1677-9-21-0:12:43.145224192; \/\/ 0\n dtLatest : LDT := LDT#2262-4-11-23:47:16.854775807; \/\/ = 16#7FFFFFFFFFFFFFFF\nEND_VAR " }, 
{ "title" : "32 位时间规范：TIME_OF_DAY ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_cb1ceee71fe0403dc0a86463160d0889", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常量：日期和时间 \/ 32 位时间规范：TIME_OF_DAY ", 
"snippet" : "使用 TIME_OF_DAY 关键字 ( TOD ) 来指定时间。 句法 <time keyword>#<time value> <time keyword> : TIME_OF_DAY | time_of_day | TOD | tod <time value> : <hour>:<minute>:<second> <hour> : 0-23 <minute> : 0-59 <second> : 0.000-59.999 您还可以指定几分之一秒。 TIME_OF_DAY 文字在内部被视为 DWORD 并且该值以毫秒为单位解析。 例子 PROGRAM POU VAR todClockTime ...", 
"body" : "使用 TIME_OF_DAY 关键字 ( TOD ) 来指定时间。 句法 <time keyword>#<time value>\n\n<time keyword> : TIME_OF_DAY | time_of_day | TOD | tod\n<time value> : <hour>:<minute>:<second>\n<hour> : 0-23\n<minute> : 0-59\n<second> : 0.000-59.999 您还可以指定几分之一秒。 TIME_OF_DAY 文字在内部被视为 DWORD 并且该值以毫秒为单位解析。 例子 PROGRAM POU\nVAR\n todClockTime : TIME_OF_DAY := TIME_OF_DAY#15:36:30.123;\n todEarliest : TIME_OF_DAY := TIME_OF_DAY#0:0:0.000;\n todLatest : TOD := TOD#23:59:59.999;\nEND_VAR " }, 
{ "title" : "64 位时间规范：LTIME_OF_DAY ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_89b6b5e319701aa4c0a864633c92579b", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常量：日期和时间 \/ 64 位时间规范：LTIME_OF_DAY ", 
"snippet" : "使用 LTIME_OF_DAY 关键字 ( LTOD ) 来指定时间。 句法 <time keyword>#<time value> <time keyword> : LTIME_OF_DAY | ltime_of_day | LTOD | ltod <time value> : <hour>:<minute>:<second> <hour> : 0-23 <minute> : 0-59 <second> : 0.000-59.999999999 您还可以指定几分之一秒。 LTIME_OF_DAY 文字在内部被视为 LWORD 并且该值以纳秒为单位解析。 例子 PROGRAM POU VAR ...", 
"body" : "使用 LTIME_OF_DAY 关键字 ( LTOD ) 来指定时间。 句法 <time keyword>#<time value>\n\n<time keyword> : LTIME_OF_DAY | ltime_of_day | LTOD | ltod\n<time value> : <hour>:<minute>:<second>\n<hour> : 0-23\n<minute> : 0-59\n<second> : 0.000-59.999999999 您还可以指定几分之一秒。 LTIME_OF_DAY 文字在内部被视为 LWORD 并且该值以纳秒为单位解析。 例子 PROGRAM POU\nVAR\n ltodClockTime : LTIME_OF_DAY := TIME_OF_DAY#15:36:30.123456789;\n todEarliest : TIME_OF_DAY := TIME_OF_DAY#0:0:0;\n todLatest : TOD := TOD#23:59:59.999999999;\nEND_VAR 有关更多信息，请参阅： 数据类型：DATE" }, 
{ "title" : "常量：类型化文字 ", 
"url" : "_cds_operands_constant_typedliterals.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 常量：类型化文字 ", 
"snippet" : "除了 REAL 要么 LREAL - 常量（在这种情况下，总是 LREAL 使用）在使用 IEC 常数进行计算时使用可能的最小数据类型。如果您想使用不同的数据类型，您可以使用类型化文字来执行此操作，而无需显式声明常量。为常量提供定义类型的前缀。 句法 <type> # <literal> <type> 指定所需的数据类型。可能的输入是 BOOL , SINT , USINT , BYTE , INT , UINT , WORD , DINT , UDINT , DWORD , REAL 和 LREAL .您必须将类型大写。 <literal> 指定常数。输入必须到下面 <type> 指定的数据...", 
"body" : "除了 REAL 要么 LREAL - 常量（在这种情况下，总是 LREAL 使用）在使用 IEC 常数进行计算时使用可能的最小数据类型。如果您想使用不同的数据类型，您可以使用类型化文字来执行此操作，而无需显式声明常量。为常量提供定义类型的前缀。 句法 <type> # <literal> <type> 指定所需的数据类型。可能的输入是 BOOL , SINT , USINT , BYTE , INT , UINT , WORD , DINT , UDINT , DWORD , REAL 和 LREAL .您必须将类型大写。 <literal> 指定常数。输入必须到下面 <type> 指定的数据类型匹配。 例子 diVar := DINT#34; 如果 CODESYS 无法在不丢失数据的情况下将常量转换为目标类型，则会发出错误消息。 您可以在可以使用普通常量的任何地方使用类型化常量。 " }, 
{ "title" : "访问数组、结构体和块中的变量 ", 
"url" : "_cds_operands_variables_accessing_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 访问数组、结构体和块中的变量 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "访问数组元素 ", 
"url" : "_cds_operands_variables_accessing_variables.html#UUID-ae836494-8ea7-f000-02ab-8154d9c0ddf6_section-idm4559767227196833962845179725", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 访问数组、结构体和块中的变量 \/ 访问数组元素 ", 
"snippet" : "句法： <数组变量的名称> [ <以逗号分隔的维度索引列表> ] <数组变量的名称> 数组变量的名称 例子： aiCounter 有关更多信息，请参阅： 分配标识符<以逗号分隔的维度索引列表> 每个维度一个索引，以便识别数组的一个元素 例子： 2 索引从索引最小值到索引最大值有效。例子： 0..9 例子 具有 10 个分量的一维数组 \/\/Declaration VAR aiCounter : ARRAY[0..9] OF INT; iLocalVariable : INT; END_VAR \/\/ Implementation iLocalVariable := aiCounter[2]; 具有...", 
"body" : "句法： <数组变量的名称> [ <以逗号分隔的维度索引列表> ] <数组变量的名称> 数组变量的名称 例子： aiCounter 有关更多信息，请参阅： 分配标识符<以逗号分隔的维度索引列表> 每个维度一个索引，以便识别数组的一个元素 例子： 2 索引从索引最小值到索引最大值有效。例子： 0..9 例子 具有 10 个分量的一维数组 \/\/Declaration\nVAR\n aiCounter : ARRAY[0..9] OF INT;\n iLocalVariable : INT;\nEND_VAR\n\n\/\/ Implementation\niLocalVariable := aiCounter[2]; 具有 2 乘以 2 分量的二维数组 \/\/Declaration\nVAR\n aiCardGame : ARRAY[1..2, 3..4] OF INT;\n iLocal_1 : INT;\nEND_VAR\n\n\/\/Implementation\niLocal_1 := aiCardGame[1, 3]; 有关更多信息，请参阅： ARRAY OF" }, 
{ "title" : "访问结构组件 ", 
"url" : "_cds_operands_variables_accessing_variables.html#UUID-ae836494-8ea7-f000-02ab-8154d9c0ddf6_section-idm4559414443915233962845733495", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 访问数组、结构体和块中的变量 \/ 访问结构组件 ", 
"snippet" : "句法： <结构变量名称> 。 <组件名称> <结构变量名称> 例子： sPolygon 有关更多信息，请参阅： 分配标识符<组件名称> 例子： aiStart 例子 \/\/Declaration type TYPE S_POLYGONLINE : STRUCT aiStart : ARRAY[1..2] OF INT := [-99, -99]; aiPoint1 : ARRAY[1..2] OF INT; aiPoint2 : ARRAY[1..2] OF INT; aiPoint3 : ARRAY[1..2] OF INT; aiPoint4 : ARRAY[1..2] OF INT; ai...", 
"body" : "句法： <结构变量名称> 。 <组件名称> <结构变量名称> 例子： sPolygon 有关更多信息，请参阅： 分配标识符<组件名称> 例子： aiStart 例子 \/\/Declaration type\nTYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE\n\n\/\/Declaration structure variable\nVAR\n sPolygon : S_POLYGONLINE;\n iPoint : INT;\nEND_VAR\n\n\/\/Implementation\niPoint := sPolygon.aiPoint1[1];\n 有关更多信息，请参阅： STRUCT" }, 
{ "title" : "访问 POU 中的变量 ", 
"url" : "_cds_operands_variables_accessing_variables.html#UUID-ae836494-8ea7-f000-02ab-8154d9c0ddf6_section-idm4560534545832033962845942743", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 访问数组、结构体和块中的变量 \/ 访问 POU 中的变量 ", 
"snippet" : "句法： <POU名称> 。 <变量名称> <POU名称> 功能块实例的名称（ FUNCTION_BLOCK ）或程序（ PROGRAM ） 例子： fbController 有关更多信息，请参阅： 分配标识符<变量名称> POU 的变量 例子： xStart 例子 FUNCTION_BLOCK FB_Controller VAR_INPUT xStart : BOOL; END_VAR VAR_OUTPUT END_VAR VAR ControlDriveA : S_CONTROL; END_VAR IF xStart = TRUE THEN \/\/Symbolic bit access Con...", 
"body" : "句法： <POU名称> 。 <变量名称> <POU名称> 功能块实例的名称（ FUNCTION_BLOCK ）或程序（ PROGRAM ） 例子： fbController 有关更多信息，请参阅： 分配标识符<变量名称> POU 的变量 例子： xStart 例子 FUNCTION_BLOCK FB_Controller\nVAR_INPUT\n xStart : BOOL;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n ControlDriveA : S_CONTROL;\nEND_VAR\nIF xStart = TRUE THEN\n \/\/Symbolic bit access\n ControlDriveA.bitEnableOperation := TRUE;\nEND_IF\n\nPROGRAM PLC_PRG\n fbController : FB_Controller;\nEND_VAR\nfbController();\nfbController.xStart := TRUE; " }, 
{ "title" : "变量中的位访问 ", 
"url" : "_cds_operands_variables_accessing_bits.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 变量中的位访问 ", 
"snippet" : "只有当处理器可以直接在内存上执行位访问时，才能实现两个任务的并发位访问。所有 x86 和 x64 系统都有用于内存中位访问的命令。 ARM 和 PPC 等系统无法直接访问内存中的位。 如果两个任务同时执行位访问，即使处理器不能直接在内存中执行位访问，则进行如下操作。使用信号量 ( SysSemEnter ) 或类似的技术来防止竞争位访问。但是，最好在任务中执行位访问。 通过索引访问，可以在整数变量中寻址各个位。使用结构变量或功能块实例，可以对各个位进行符号寻址。...", 
"body" : "只有当处理器可以直接在内存上执行位访问时，才能实现两个任务的并发位访问。所有 x86 和 x64 系统都有用于内存中位访问的命令。 ARM 和 PPC 等系统无法直接访问内存中的位。 如果两个任务同时执行位访问，即使处理器不能直接在内存中执行位访问，则进行如下操作。使用信号量 ( SysSemEnter ) 或类似的技术来防止竞争位访问。但是，最好在任务中执行位访问。 通过索引访问，可以在整数变量中寻址各个位。使用结构变量或功能块实例，可以对各个位进行符号寻址。 " }, 
{ "title" : "对位整数变量的索引访问 ", 
"url" : "_cds_operands_variables_accessing_bits.html#UUID-d4f7a63b-4e5a-3f52-3bfa-4b1a24fbc724_id_b340eb5aade07af3c0a8640e00aa8f9e_id_14902e5878de741ec0a8652000b1e877", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 变量中的位访问 \/ 对位整数变量的索引访问 ", 
"snippet" : "您可以寻址整数变量中的各个位。为此，请在变量后面附加一个点和寻址位的索引。位索引可以由任何常数给出。索引是从 0 开始的。 句法 <integer variable name> . <index> <integer data typ> = BYTE | WORD | DWORD | LWORD | SINT | USINT | INT | UINT | DINT | UDINT | LINT | ULINT 例子 在程序中，变量的第三位 wA 设置为变量的值 xB .常数 c_usiENABLE 用作访问变量第三位的索引 iX . 索引访问 PROGRAM PLC_PRG VAR wA : W...", 
"body" : "您可以寻址整数变量中的各个位。为此，请在变量后面附加一个点和寻址位的索引。位索引可以由任何常数给出。索引是从 0 开始的。 句法 <integer variable name> . <index>\n<integer data typ> = BYTE | WORD | DWORD | LWORD | SINT | USINT | INT | UINT | DINT | UDINT | LINT | ULINT 例子 在程序中，变量的第三位 wA 设置为变量的值 xB .常数 c_usiENABLE 用作访问变量第三位的索引 iX . 索引访问 PROGRAM PLC_PRG\nVAR\n wA : WORD := 16#FFFF;\n xB : BOOL := 0;\nEND_VAR\n\n\/\/ Index access in an integer variable\nwA.2 := xB; 结果： wA = 2#1111_1111_1111_1011 = 16#FFFB 常量作为索引 \/\/ GVL declaration\nVAR_GLOBAL CONSTANT\n gc_usiENABLE : USINT := 2;\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n iX : INT := 0;\nEND_VAR\n\n\/\/ Constant as index\niX.gc_usiENABLE := TRUE; \/\/ Third bit in iX is set TRUE 结果： iX = 4 " }, 
{ "title" : "结构变量中的符号位访问 ", 
"url" : "_cds_operands_variables_accessing_bits.html#UUID-d4f7a63b-4e5a-3f52-3bfa-4b1a24fbc724_id_b340eb5aade07af3c0a8640e00aa8f9e_id_747b06aff3f15e7bc0a8646368e7d8a5", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 变量中的位访问 \/ 结构变量中的符号位访问 ", 
"snippet" : "随着 BIT 数据类型，您可以将各个位组合成一个结构，然后单独访问它们。然后使用组件名称对该位进行寻址。 例子 结构的类型声明 TYPE S_CONTROLLER : STRUCT bitOperationEnabled : BIT; bitSwitchOnActive : BIT; bitEnableOperation : BIT; bitError : BIT; bitVoltageEnabled : BIT; bitQuickStop : BIT; bitSwitchOnLocked : BIT; bitWarning : BIT; END_STRUCT END_TYPE 声明和写访问位...", 
"body" : "随着 BIT 数据类型，您可以将各个位组合成一个结构，然后单独访问它们。然后使用组件名称对该位进行寻址。 例子 结构的类型声明 TYPE S_CONTROLLER :\nSTRUCT\n bitOperationEnabled : BIT;\n bitSwitchOnActive : BIT;\n bitEnableOperation : BIT;\n bitError : BIT;\n bitVoltageEnabled : BIT;\n bitQuickStop : BIT;\n bitSwitchOnLocked : BIT;\n bitWarning : BIT;\nEND_STRUCT\nEND_TYPE 声明和写访问位 PROGRAM PLC_PRG\nVAR\n ControlDriveA : S_CONTROLLER;\nEND_VAR\n\n\/\/ Symbolic bit access to bitEnableOperation\nControlDriveA.bitEnableOperation := TRUE; " }, 
{ "title" : "功能块实例中的符号位访问 ", 
"url" : "_cds_operands_variables_accessing_bits.html#UUID-d4f7a63b-4e5a-3f52-3bfa-4b1a24fbc724_id_b340eb5aade07af3c0a8640e00aa8f9e_id_eee44594dd9f930dc0a864637e5e6307", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 变量中的位访问 \/ 功能块实例中的符号位访问 ", 
"snippet" : "在功能块中，您可以为各个位声明变量。 例子 FUNCTION_BLOCK FB_Controller VAR_INPUT bitSwitchOnActive : BIT; bitEnableOperation : BIT; bitVoltageEnabled : BIT; bitQuickStop : BIT; bitSwitchOnLocked : BIT; END_VAR VAR_OUTPUT bitOperationEnabled : BIT; bitError : BIT; bitWarning : BIT; END_VAR VAR END_VAR ; PROGRAM PLC_PRG ...", 
"body" : "在功能块中，您可以为各个位声明变量。 例子 FUNCTION_BLOCK FB_Controller\nVAR_INPUT\n bitSwitchOnActive : BIT;\n bitEnableOperation : BIT;\n bitVoltageEnabled : BIT;\n bitQuickStop : BIT;\n bitSwitchOnLocked : BIT;\nEND_VAR\nVAR_OUTPUT\n bitOperationEnabled : BIT;\n bitError : BIT;\n bitWarning : BIT;\nEND_VAR\nVAR\nEND_VAR\n;\n\nPROGRAM PLC_PRG\nVAR\n fbController : FB_Controller;\nEND_VAR\n\/\/ Symbolic bit access to bitSwitchOnActive\nfbController(bitSwitchOnActive := TRUE); " }, 
{ "title" : "部分变量访问 ", 
"url" : "_cds_partial_access.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 部分变量访问 ", 
"snippet" : "该表达式符合 IEC 61131-3 标准。 对于 IEC 数据类型变量，可以进行部分变量访问 BYTE , WORD , DWORD 或者 LWORD （数据类型 ANY，ANY_ ）。 句法： <变量名称> 。 % <部分类型> <部分索引> 点运算符后面允许有一个空格 ( . ）。百分号后不允许有空格 ( % ) 和部分类型之后。 <变量名称> 的名字 ANY_BIT 类型的变量 BYTE , WORD , DWORD ， 或者 LWORD <部分类型> X 为了 BIT 使用权 B 为了 BYTE 使用权 W 为了 WORD 使用权 D 为了 DWORD 使用权 L 为了 LWORD ...", 
"body" : "该表达式符合 IEC 61131-3 标准。 对于 IEC 数据类型变量，可以进行部分变量访问 BYTE , WORD , DWORD 或者 LWORD （数据类型 ANY，ANY_ ）。 句法： <变量名称> 。 % <部分类型> <部分索引> 点运算符后面允许有一个空格 ( . ）。百分号后不允许有空格 ( % ) 和部分类型之后。 <变量名称> 的名字 ANY_BIT 类型的变量 BYTE , WORD , DWORD ， 或者 LWORD <部分类型> X 为了 BIT 使用权 B 为了 BYTE 使用权 W 为了 WORD 使用权 D 为了 DWORD 使用权 L 为了 LWORD 使用权 进入 __XWORD 也是允许的并且表现得像 DWORD 或者 LWORD 取决于指针的大小。 进入 BOOL 即使 BOOL 数据类型是 ANY_BIT 类型。 <部分索引> 从 0 到索引最大值 有关更多信息，请参阅： 数据类型 ANY，ANY_访问数组、结构体和块中的变量" }, 
{ "title" : "用法 ", 
"url" : "_cds_partial_access.html#UUID-a998d9b0-535e-4892-deb0-bdf9fa13db54_section-idm4642469513468833961518118731", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 部分变量访问 \/ 用法 ", 
"snippet" : "部分访问只能用于非临时变量（用户定义的变量、字段、数组访问或取消引用）。对于临时结果或文字，不允许这样做。 表达式本身不是临时的，可以用作 REFERENCE TO 或作为 ADR 操作员。 例子 \/\/ Implementation PartialVarB := GVL.Variable.%B0; PartialVarX := array[idx].%X0; PartialVarW := tempVariable.%W2; PartialVarD := ptr^.%D2; PartialVarB := variable.%W1.%B1 对于函数调用、索引表达式、文字或属性，部分访问是不可能的。...", 
"body" : "部分访问只能用于非临时变量（用户定义的变量、字段、数组访问或取消引用）。对于临时结果或文字，不允许这样做。 表达式本身不是临时的，可以用作 REFERENCE TO 或作为 ADR 操作员。 例子 \/\/ Implementation\nPartialVarB := GVL.Variable.%B0;\nPartialVarX := array[idx].%X0;\nPartialVarW := tempVariable.%W2;\nPartialVarD := ptr^.%D2;\nPartialVarB := variable.%W1.%B1\n\n 对于函数调用、索引表达式、文字或属性，部分访问是不可能的。 反面例子： FunctionCall().%B0\n(1+index).%B0\n(DWORD#16#12345678).%B0\nProperty.%B0 " }, 
{ "title" : "部分类型的索引最大值 ", 
"url" : "_cds_partial_access.html#UUID-a998d9b0-535e-4892-deb0-bdf9fa13db54_section-idm464701570986723396146942364", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 部分变量访问 \/ 部分类型的索引最大值 ", 
"snippet" : "仅当被调用表达式具有一致类型且部分索引小于或等于最大部分索引时，部分访问才可能。否则会报编译错误。 部分型 接入类型 部分索引的最大值 X BYTE 7 WORD 15 DWORD 31 LWORD 63 B BYTE 0 WORD 1 DWORD 3 LWORD 7 W BYTE 不支持 WORD 0 DWORD 1 LWORD 3 D BYTE 不支持 WORD 不支持 DWORD 0 LWORD 1 L BYTE 不支持 WORD 不支持 DWORD 不支持 LWORD 0...", 
"body" : "仅当被调用表达式具有一致类型且部分索引小于或等于最大部分索引时，部分访问才可能。否则会报编译错误。 部分型 接入类型 部分索引的最大值 X BYTE 7 WORD 15 DWORD 31 LWORD 63 B BYTE 0 WORD 1 DWORD 3 LWORD 7 W BYTE 不支持 WORD 0 DWORD 1 LWORD 3 D BYTE 不支持 WORD 不支持 DWORD 0 LWORD 1 L BYTE 不支持 WORD 不支持 DWORD 不支持 LWORD 0 " }, 
{ "title" : "具有部分访问权限的表达式 ", 
"url" : "_cds_partial_access.html#UUID-a998d9b0-535e-4892-deb0-bdf9fa13db54_section-idm455129619581923396149212589", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 部分变量访问 \/ 具有部分访问权限的表达式 ", 
"snippet" : "部分访问表达式的类型仅取决于 <部分类型> 并且必须使用下表进行选择。 部分型 表达类型 X BIT B BYTE W WORD D DWORD L LWORD...", 
"body" : "部分访问表达式的类型仅取决于 <部分类型> 并且必须使用下表进行选择。 部分型 表达类型 X BIT B BYTE W WORD D DWORD L LWORD " }, 
{ "title" : "地址 ", 
"url" : "_cds_partial_access.html#UUID-a998d9b0-535e-4892-deb0-bdf9fa13db54_section-idm4647015711872033961498739737", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 部分变量访问 \/ 地址 ", 
"snippet" : "允许从部分类型的部分访问表达式创建地址 B , W , D ， 和 L 。 这是 不是 允许从部分类型的部分访问表达式创建地址 X 。 这是 不是 允许分配类型的部分访问表达式 BIT 到一个 VAR_INOUT 多变的。 例子 ADR(var%.B0) referenceVariable REF= var.%W1 反面例子： ADR(var.%X0) ref REF= var.%X0...", 
"body" : "允许从部分类型的部分访问表达式创建地址 B , W , D ， 和 L 。 这是 不是 允许从部分类型的部分访问表达式创建地址 X 。 这是 不是 允许分配类型的部分访问表达式 BIT 到一个 VAR_INOUT 多变的。 例子 ADR(var%.B0)\nreferenceVariable REF= var.%W1\n 反面例子： ADR(var.%X0)\nref REF= var.%X0\n " }, 
{ "title" : "地址 ", 
"url" : "_cds_operands_addresses.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 地址 ", 
"snippet" : "如果使用指向地址的指针，则可以在在线更改期间移动地址的内容。如果使用绝对地址，则地址的内容在在线更改期间不会更改。 句法： % <内存区域编号> <大小前缀> <位置编号 > . <位位置编号> % <地址> 必填项 存储区中的地址 % <内存区域前缀> <大小前缀> <内存位置> <内存区域前缀> 必填项 I : 输入存储区域 用于存储输入信号和输入的存储区域 用于通过输入驱动器和传感器进行物理输入 Q : 输出存储区域 输出信号和输出的存储区域 通过输出驱动器和执行器进行物理输出 M : 标记存储区域 <大小前缀> 可选 没有大小前缀：位 单个位 X : 位 单个位 B : 字节 8 位数...", 
"body" : "如果使用指向地址的指针，则可以在在线更改期间移动地址的内容。如果使用绝对地址，则地址的内容在在线更改期间不会更改。 句法： % <内存区域编号> <大小前缀> <位置编号 > . <位位置编号> % <地址> 必填项 存储区中的地址 % <内存区域前缀> <大小前缀> <内存位置> <内存区域前缀> 必填项 I : 输入存储区域 用于存储输入信号和输入的存储区域 用于通过输入驱动器和传感器进行物理输入 Q : 输出存储区域 输出信号和输出的存储区域 通过输出驱动器和执行器进行物理输出 M : 标记存储区域 <大小前缀> 可选 没有大小前缀：位 单个位 X : 位 单个位 B : 字节 8 位数据宽度 W : 单词 16 位数据宽度 D : Dword 32 位数据宽度 <内存位置> <位置编号 > . <位位置编号> 示例： %IB2.4 代表第 3 字节的第 5 位 <位置编号 > 必填项 编号取决于目标系统，从 0 开始。 . <位位置编号> 可选 0..7 表示一个字节 定义地址时，您使用特定的字符串来表示内存位置和大小。地址标有百分号 ( % )，后跟内存范围前缀、可选大小前缀和内存范围位置。用于寻址内存位置的编号取决于目标系统。 例子 %QX7.5 %Q7.5 输出位的单个位地址 7.5 %IW215 输入字的字地址 215 %QB7 输出字节 7 的字节地址 %MD48 标志存储器中存储器位置 48 处双字的地址 %IW2.5.7.1 输入字的字地址；取决于当前控制器配置的解释 VAR \n wVar AT %IW0 : WORD; \nEND_VAR 带有输入字地址信息的变量声明 VAR \n xActuator AT %QW0 : BOOL; \nEND_VAR 布尔变量声明 注意：对于布尔变量，如果未指定单个位地址，则在内部分配一个字节。值的变化 xActuator 影响范围从 QX0.0 到 QX0.7 . VAR \n xSensor AT %IX7.5 : BOOL; \nEND_VAR 明确指定单个位地址的布尔变量声明 访问时，仅读取输入位 7.5。 " }, 
{ "title" : "记忆位置 ", 
"url" : "_cds_operands_addresses.html#UUID-b62e344d-bf98-39e1-ea00-2b46d5561ef3_id_d533aade45c8fc0a8640e00567983_id_448f942037ed6c03c0a864634fc7f314", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 地址 \/ 记忆位置 ", 
"snippet" : "确保地址有效，如下所示： 要在应用程序中映射有效地址，您首先需要知道流程图像中的所需位置。这意味着适用的内存区域：输入存储器区域 ( I )、输出存储区 ( Q )，或标记存储区域 ( M ）（见上文）。此外，你需要指定所需的大小前缀：位， BYTE ， WORD ， DWORD （见上文： X ， B ， W ， D ) 当前使用的设备配置和设备设置（硬件结构、设备描述、I\/O 设置）起着决定性的作用。 请特别注意采用字节寻址的设备和采用以字为导向的 IEC 寻址设备之间在位地址解释上的差异。 就位地址而言 %IX5.5 ，点之前的数字在字节寻址设备中指向字节 5，在文字寻址设备中寻址单词 ...", 
"body" : "确保地址有效，如下所示： 要在应用程序中映射有效地址，您首先需要知道流程图像中的所需位置。这意味着适用的内存区域：输入存储器区域 ( I )、输出存储区 ( Q )，或标记存储区域 ( M ）（见上文）。此外，你需要指定所需的大小前缀：位， BYTE ， WORD ， DWORD （见上文： X ， B ， W ， D ) 当前使用的设备配置和设备设置（硬件结构、设备描述、I\/O 设置）起着决定性的作用。 请特别注意采用字节寻址的设备和采用以字为导向的 IEC 寻址设备之间在位地址解释上的差异。 就位地址而言 %IX5.5 ，点之前的数字在字节寻址设备中指向字节 5，在文字寻址设备中寻址单词 5。 相比之下，使用字或字节地址寻址与设备类型无关： %IW5 ，始终对单词 5 进行寻址，并使用字节地址 %IB5 总是字节 5。因此，根据大小和寻址模式，您可以使用相同的地址信息寻址不同的存储单元。 下表显示了位、字节、字和双字的字节寻址和以字为导向的 IEC 寻址的比较。它还显示了用于字节寻址的重叠存储区域。参见表格末尾的示例。 关于语法，请注意，IEC 寻址始终以文字为导向。单词编号位于点之前，位数位于点之后。 n = 字节数 用于字节寻址的重叠存储区域示例 D0 包含 B0 - B3 。 W0 包含 B0 和 B1 。 W1 包含 B2 和 B3 。 W2 包含 B4 和 B5 。 W1 ，但也是 D1 ， D2 ，以及 D3 不得用于寻址。这样可以避免重叠 " }, 
{ "title" : "职能 ", 
"url" : "_cds_operands_functions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 操作数 \/ 职能 ", 
"snippet" : "在 ST 中，您可以将函数调用用作操作数。 例子： Result := Fct(7) + 3; TIME(）函数 此函数产生自系统启动以来经过的时间（以毫秒为单位）。 时间戳是 TIME （32 位）数据类型。溢出后，值再次从 0 。 ST 中的示例 systime := TIME();...", 
"body" : "在 ST 中，您可以将函数调用用作操作数。 例子： Result := Fct(7) + 3; TIME(）函数 此函数产生自系统启动以来经过的时间（以毫秒为单位）。 时间戳是 TIME （32 位）数据类型。溢出后，值再次从 0 。 ST 中的示例 systime := TIME(); " }, 
{ "title" : "数据类型 ", 
"url" : "_cds_reference_datatypes.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 ", 
"snippet" : "在编程中，变量由其在目标系统中的名称和内存地址来标识。变量名称是标识符，分配的内存通过该标识符进行寻址。变量的大小由其数据类型决定。这决定了将为变量保留多少内存以及如何解释内存中的值。数据类型还决定允许使用哪些运算符。 功能块也可以实例化。功能块实例像变量一样使用内存。内存需求由功能块决定。 有以下几组数据类型可用： 基本数据类型 基本数据类型预定义在 CODESYS Development System 。 __UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | I...", 
"body" : "在编程中，变量由其在目标系统中的名称和内存地址来标识。变量名称是标识符，分配的内存通过该标识符进行寻址。变量的大小由其数据类型决定。这决定了将为变量保留多少内存以及如何解释内存中的值。数据类型还决定允许使用哪些运算符。 功能块也可以实例化。功能块实例像变量一样使用内存。内存需求由功能块决定。 有以下几组数据类型可用： 基本数据类型 基本数据类型预定义在 CODESYS Development System 。 __UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD 除了 IEC 61131-3 标准中描述的数据类型外，还有 CODESYS 特定数据类型 BIT ， __UXINT ， __XINT ， 和 __XWORD 。 标准数据类型 标准类型（标准数据类型）是一种基本数据类型或字符串数据类型。 __UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT |STRING | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD | WSTRING 整数数据类型 __UXINT | __XINT | __XWORD | BIT | BYTE | DINT | DWORD | INT | LINT | LWORD | SINT | UDINT | UINT | ULINT | USINT | WORD 时间数据类型 TIME ， LTIME 日期和时间数据类型 DATE | DATE_AND_TIME | DT | TIME_OF_DAY | TOD | LDATE | LDATE_AND_TIME | LDT | LTIME_OF_DAY | LTOD IEC 61131-3 标准的扩展 用户定义的数据类型 TYPE有关详细信息，请参阅：For more information, see: 标识符名称" }, 
{ "title" : "数据类型：BOOL ", 
"url" : "_cds_datatype_bool.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：BOOL ", 
"snippet" : "BOOL 类型 价值观 记忆 BOOL TRUE (1), FALSE (0) 8 位...", 
"body" : "BOOL 类型 价值观 记忆 BOOL TRUE (1), FALSE (0) 8 位 " }, 
{ "title" : "整数数据类型 ", 
"url" : "_cds_datatype_integer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 整数数据类型 ", 
"snippet" : "Integer 从较大的数据类型转换为较小的数据类型时，信息可能会丢失。 CODESYS 提供以下整数数据类型。 类型 下限 上限 记忆 BYTE 0 255 8 位 WORD 0 65535 16 位 DWORD 0 4294967295 32 位 LWORD 0 2 64 -1 64 位 SINT -128 127 8 位 USINT 0 255 8 位 INT -32768 32767 16 位 UINT 0 65535 16 位 DINT -2147483648 2147483647 32 位 UDINT 0 4294967295 32 位 LINT -2 63 2 63 -1 64 ...", 
"body" : "Integer 从较大的数据类型转换为较小的数据类型时，信息可能会丢失。 CODESYS 提供以下整数数据类型。 类型 下限 上限 记忆 BYTE 0 255 8 位 WORD 0 65535 16 位 DWORD 0 4294967295 32 位 LWORD 0 2 64 -1 64 位 SINT -128 127 8 位 USINT 0 255 8 位 INT -32768 32767 16 位 UINT 0 65535 16 位 DINT -2147483648 2147483647 32 位 UDINT 0 4294967295 32 位 LINT -2 63 2 63 -1 64 位 ULINT 0 2 64 -1 64 位 有关更多信息，请参阅： 常数：数字" }, 
{ "title" : "数据类型：REAL、LREAL ", 
"url" : "_cds_datatype_real.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：REAL、LREAL ", 
"snippet" : "REAL, LREAL 数据类型 REAL 和 LREAL 是根据 IEEE 754 的浮点类型。当使用十进制数和十进制表示法或指数表示法的浮点数时，浮点类型是必需的。 目标系统 数据类型 最小值数 最大值数 记忆 REAL 1.0E-44 3.402823E+38 32 位 LREAL 4.94065645841247E-324 1.7976931348623157E+308 64 位 例子 PROGRAM PLC_PRG VAR rMax: REAL := 3.402823E+38; \/\/ Largest number rPosMin : REAL := 1.0E-44; \/\/ Small...", 
"body" : "REAL, LREAL searchresult_toplevel 数据类型 REAL 和 LREAL 是根据 IEEE 754 的浮点类型。当使用十进制数和十进制表示法或指数表示法的浮点数时，浮点类型是必需的。 目标系统 数据类型 最小值数 最大值数 记忆 REAL 1.0E-44 3.402823E+38 32 位 LREAL 4.94065645841247E-324 1.7976931348623157E+308 64 位 例子 PROGRAM PLC_PRG\nVAR\n rMax: REAL := 3.402823E+38; \/\/ Largest number\n rPosMin : REAL := 1.0E-44; \/\/ Smallest positve number\n rNegMax: REAL := -1.0E-44; \/\/ Largest negative number\n rMin: REAL := -3.402823E+38; \/\/ Smallest number\n\n lrMax: LREAL := 1.7976931348623157E+308; \/\/ Largest number\n lrPosMin : LREAL := 4.94065645841247E-324; \/\/ Smallest positve number\n lNegMax: LREAL := -4.94065645841247E-324; \/\/ Largest negative number\n lrMin: LREAL := -1.7976931348623157E+308; \/\/ Smallest number\nEND_VAR 支持 LREAL 数据类型取决于使用的目标设备。有关是否为 64 位类型，请参阅相应的文档 LREAL 被转换为 REAL 或保持为 LREAL 编译应用程序时。转换可能会导致信息丢失。 如果值 REAL \/ LREAL number 超出整数的值范围，则从数据类型转换产生未定义的结果 REAL 或者 LREAL 到 SINT , USINT , INT , UINT , DINT , UDINT , LINT ， 或者 ULINT .结果取决于目标系统。也可能出现异常错误。要获得独立于目标系统的代码，应用程序必须捕获超出范围的违规行为。 如果 REAL \/ LREAL number 在整数数据类型的值范围内，则转换在所有系统上以相同的方式进行。 " }, 
{ "title" : "数据类型: STRING ", 
"url" : "_cds_datatype_string.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型: STRING ", 
"snippet" : "STRING 在 Latin-1 编码的情况下，一个 STRING 变量总是每个字符 1 个字节加上一个额外的字节。例如，在标准的情况下，这会导致 81 个字节 STRING(80) 宣言。 在 UTF-8 编码的情况下，一个字符最长可达 4 个字节。但是，字符串的长度始终表示为 STRING 保留的字节数。因此，字符数和字符串长度之间不再存在 1:1 的关系。 这 STRING 数据类型被解释为 Latin-1 或 UTF-8：如果 字符串的 UTF-8 编码 编译选项被启用，然后所有字符串文字都以 UTF-8 格式解释。 宣言： <variable name> : STRING( <siz...", 
"body" : "STRING searchresult_toplevel 在 Latin-1 编码的情况下，一个 STRING 变量总是每个字符 1 个字节加上一个额外的字节。例如，在标准的情况下，这会导致 81 个字节 STRING(80) 宣言。 在 UTF-8 编码的情况下，一个字符最长可达 4 个字节。但是，字符串的长度始终表示为 STRING 保留的字节数。因此，字符数和字符串长度之间不再存在 1:1 的关系。 这 STRING 数据类型被解释为 Latin-1 或 UTF-8：如果 字符串的 UTF-8 编码 编译选项被启用，然后所有字符串文字都以 UTF-8 格式解释。 宣言： <variable name> : STRING( <size> ) := ' <text> '; <variable name> : STRING[ <size> ] := ' <text> '; 这 <size> 内存大小和初始化是可选的。 例子 sVar : STRING(46):= 'This is a string with memory for 46 characters.';\nsVar_µ : STRING[10] := 'µ (Mü)';\nsVar_ß : STRING[10] := 'Eszett'; 数据类型的变量 STRING 可以包含任何字符串。大量的 <size> 在声明期间保留的内存是指字节数，并显示在括号或括号中。如果未定义大小，则默认保留 80 个字符。如果使用对于数据类型而言太长的文字初始化变量，则从右侧相应地截断该文字。 然而，字符串的长度并没有从根本上受到限制。如果您使用库的功能进行字符串操作 Standard 执行后，长度为 255 的字符串将被正确处理。如果您使用库的功能进行字符串操作 StringUtils 运行，您还可以使用更长的字符串（>255 个字符）。 当数据类型的变量 STRING 通过重置应用程序重新初始化，在初始值的终止空字符之后存在的（旧）字符串的内容不会被覆盖。这既适用于使用初始化值进行的初始化，也适用于使用默认初始化值 0 进行的初始化。 在编译器版本 3.5.18.0 及更高版本中，您可以选择字符串的编码格式。您可以在项目范围内指定字符串是以 Latin-1 格式还是 UTF-8 格式解释的。对于 UTF-8 编码，启用 字符串的 UTF8 编码 编译选项。 有关更多信息，请参阅： 编译选项 和 UTF-8 编码在更改编码格式之前，建议使用静态分析规则 SA0175 检查您的代码。 有关详细信息，请参阅： 静态分析灯添加 {attribute 'monitoring_encoding' := 'UTF8'} 变量声明的pragma。然后就可以监听UTF8编码的变量内容了。 有关更多信息，请参阅： monitoring_encoding 语用 " }, 
{ "title" : "数据类型：TIME、LTIME ", 
"url" : "_cds_datatype_time.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：TIME、LTIME ", 
"snippet" : "时间数据类型 TIME 在内部被视为 DWORD 。 如果是 TIME ，这将导致以毫秒为单位的分辨率。 时间数据类型 LTIME 在内部被视为 LWORD 。 如果是 LTIME ，这将导致以纳秒为单位的分辨率。您可以使用数据类型 LTIME 作为高分辨率定时器的时间基准。高分辨率定时器的分辨率为纳秒。 数据类型 下限 上限 记忆 解决 描述 TIME T#0d0h0m0s0ms T#49d17h2m47s295ms 32 位 毫秒 句法： TIME#xDxHxMxSxMS 句法： TIME#xdxhxmxsxms 句法： T#xDxHxMxSxMS 句法： T#xdxhxmxsxms 伦敦...", 
"body" : "时间数据类型 TIME 在内部被视为 DWORD 。 如果是 TIME ，这将导致以毫秒为单位的分辨率。 时间数据类型 LTIME 在内部被视为 LWORD 。 如果是 LTIME ，这将导致以纳秒为单位的分辨率。您可以使用数据类型 LTIME 作为高分辨率定时器的时间基准。高分辨率定时器的分辨率为纳秒。 数据类型 下限 上限 记忆 解决 描述 TIME T#0d0h0m0s0ms T#49d17h2m47s295ms 32 位 毫秒 句法： TIME#xDxHxMxSxMS 句法： TIME#xdxhxmxsxms 句法： T#xDxHxMxSxMS 句法： T#xdxhxmxsxms 伦敦时间 LTIME#0NS LTIME#213503D23H34M33S709MS551US615NS 64 位 纳秒 句法： LTIME#xDxHxMxSxMSxUSxNS 句法： LTIME#xdxhxmxsxmsxusxna 例子 T#1D2H3M4S\nT#49D17H2M47S295MS\nLTIME#1000D15H23M12S34ms2us44ns\nLTIME#213503D23H34M33S709MS551US615NS 有关更多信息，请参阅： 常数：TIME、LTIME， TIME, LTIME" }, 
{ "title" : "数据类型：DATE ", 
"url" : "_cds_datatype_date_and_time_of_day.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：DATE ", 
"snippet" : "数据和时间的数据类型 DATE ， DATE_AND_TIME （ DT ）， 和 TIME_OF_DAY （ TOD ）在内部处理为 DWORD （32 位值）。 数据类型 LDATE , LDATE_AND_TIME ( LDT ）， 和 LTIME_OF_DAY ( LTOD ) 在内部被视为 LWORD （64 位值）。 数据类型 下限 下限 上限 记忆 解决 描述 DATE D#1970-01-01 D#2106-02-07 32 位 秒（虽然只显示日期） 句法： DATE#yyyy-MM-dd 句法： D#yyyy-MM-dd DATE_AND_TIME DT DT#1970-1-...", 
"body" : "数据和时间的数据类型 DATE ， DATE_AND_TIME （ DT ）， 和 TIME_OF_DAY （ TOD ）在内部处理为 DWORD （32 位值）。 数据类型 LDATE , LDATE_AND_TIME ( LDT ）， 和 LTIME_OF_DAY ( LTOD ) 在内部被视为 LWORD （64 位值）。 数据类型 下限 下限 上限 记忆 解决 描述 DATE D#1970-01-01 D#2106-02-07 32 位 秒（虽然只显示日期） 句法： DATE#yyyy-MM-dd 句法： D#yyyy-MM-dd DATE_AND_TIME DT DT#1970-1-1-0:0:0 DT#2106-2-7-6:28:15 32 位 秒 句法： DATE_AND_TIME#yyyy-MM-dd-hh:mm:ss 句法： DT#yyyy-MM-dd-hh:mm:ss TIME_OF_DAY TOD TOD#0:0:0 TOD#23:59:59.999 32 位 毫秒 句法： TIME_OF_DAY#hh:mm:ss 句法： TOD#hh:mm:ss.sss LDATE LD#1677-9-22 LD#1970-01-01 LDATE#2262-4-11 64 位 纳秒（虽然只显示日期） 句法： LDATE#yyyy-MM-dd LDATE_AND_TIME LDT LDT#1677-9-21-0:12:43.145224192 LDT#1970-1-1-0:0:0 LDT#2262-4-11-23:47:16.854775807 64 位 纳秒 句法： LDATE_AND_TIME##yyyy-MM-dd-hh:mm:ss.sssssssss 句法： LDT##yyyy-MM-dd-hh:mm:ss.sssssssss LTIME_OF_DAY LTOD LTOD##0:0:0 LTOD#23:59:59.999999999 64 位 纳秒 句法： LTIME_OF_DAY#hh:mm:ss.sssssssss 句法： LTOD#hh:mm:ss.sssssssss 例子 VAR\n \/\/Date\n dateBottom : DATE := DATE#1970-1-1;\n dateTop : DATE := DATE#2106-2-7;\n dateAppointment : DATE := D#2020-2-7; \/\/ D as data type prohibited\n\n \/\/Date and time\n dtBottom : DATE_AND_TIME := DATE_AND_TIME#1970-1-1-0:0:0;\n dtTop : DT := DATE_AND_TIME#2106-02-07-06:28:15;\n dtAppointment : DT := DT#2020-2-7-12:55:1.234;\n\n \/\/Time of day\n todBottom : TIME_OF_DAY := TIME_OF_DAY#0:0:0;\n todTop : TOD := TIME_OF_DAY#23:59:59.999;\n todAppointment : TOD := TOD#12:3:4.567;\n\n \/\/ Long date\n ldateBottom : LDATE := LDATE#1970-1-1;\n ldateTop : LDATE := LDATE#2106-2-7;\n ldateAppointment : LDATE := LD#2020-2-7; \/\/ LD as data typ prohibited\n\n \/\/ Long date and time\n ldtBottom : LDATE_AND_TIME := LDATE_AND_TIME#1970-1-1-0:0:0;\n ldtTop : LDT := LDATE_AND_TIME#2262-4-10-23:34:33.709551615;\n ldtAppointment : LDT := LDT#2020-2-7-12:55:1.234567891;\n\n \/\/Long time of day\n ltodBottom : LTIME_OF_DAY := LTIME_OF_DAY#0:0:0;\n ltodTop : LTOD := LTIME_OF_DAY#23:59:59.999999999 ;\n ltodAppointment : LTOD := LTOD#12:3:4.567890123;\n\nEND_VAR 有关更多信息，请参阅： 常量：日期和时间 ， DATE, DT, TOD, LDATE, LDT, LTOD" }, 
{ "title" : "数据类型：ANY、ANY_ <类型> ", 
"url" : "_cds_datatype_any.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：ANY、ANY_ <类型> ", 
"snippet" : "ANY，ANY_ <类型> 数据类型 ANY 或者 ANY_ <类型> 用于函数、功能块或方法的接口中，以便输入类型未知或未指定的输入参数：输入变量 ( VAR_INPUT ）具有通用数据类型。 编译器在内部用下面描述的数据结构替换输入变量的类型，从而不直接传递值。相反，指针被传递到实际值，因此只能传递变量。因此，只有在调用时才指定数据类型。因此，可以使用每个具有不同数据类型的参数来调用此类 POU。 文字、替换常量以及函数调用或表达式的结果 不能 传递给输入变量（ VAR_IN_OUT ）。 称呼 语法描述指的是只有一个参数的 POU，参数将传递到该参数。因此，参数的数据类型指定输入变量的通...", 
"body" : "ANY，ANY_ <类型> 数据类型 ANY 或者 ANY_ <类型> 用于函数、功能块或方法的接口中，以便输入类型未知或未指定的输入参数：输入变量 ( VAR_INPUT ）具有通用数据类型。 编译器在内部用下面描述的数据结构替换输入变量的类型，从而不直接传递值。相反，指针被传递到实际值，因此只能传递变量。因此，只有在调用时才指定数据类型。因此，可以使用每个具有不同数据类型的参数来调用此类 POU。 文字、替换常量以及函数调用或表达式的结果 不能 传递给输入变量（ VAR_IN_OUT ）。 称呼 语法描述指的是只有一个参数的 POU，参数将传递到该参数。因此，参数的数据类型指定输入变量的通用数据类型。例如，类型的参数 BYTE, WORD, DWORD, LWORD 可以传递给一个类型 ANY_BIT 输入变量。 函数调用语法： <函数名称> （ <参数> ） 功能块调用语法 <功能块实例的名称> （ <输入变量的名称> := <参数> ） 方法调用的语法 <功能块实例的名称> 。 <方法名称> （ <输入变量的名称> := <参数> ） <参数> 传递变量 例子 PROGRAM PLC_PRG\nVAR\n byValue : BYTE := 16#AB;\n iValue : INT := -1234;\n xResultByte : BOOL;\n xResultInt : BOOL;\n\n fbComputeAnyByte : FB_ComputeAny;\n fbComputeAnyInt : FB_ComputeAny;\n\n fbComputeM1 : FB_ComputeMethod;\n fbComputeM2 : FB_ComputeMethod;\n\n byN : BYTE := 1;\n wBitField1 : WORD := 16#FFFF;\n wBitField2 : WORD := 16#0001;\n xInit : BOOL;\n xResult : BOOL;\nEND_VAR\n\n\/\/Implementation\nxResultByte := funComputeAny(byValue);\nxResultInt := funComputeAny(iValue);\n\nxResult := funGenericCompare(wBitField1, wBitField2);\n\nfbComputeAnyByte(anyInput1 := byValue);\nfbComputeAnyInt(anyInput1 := iValue);\n\nfbComputeM1.methComputeAnny(anyInput1 := byValue);\nfbComputeM2.methComputeAnny(anyInput1 := iValue);\n " }, 
{ "title" : "ANY 和 ANY_ 的内部数据结构 <类型> ", 
"url" : "_cds_datatype_any.html#UUID-08811461-dc3a-9612-9aa1-9d1b22125df5_id_ed37729bef786cc0a8640e01c41bef_id_fd745cdad9e24e11c0a8646350ca1289", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：ANY、ANY_ <类型> \/ ANY 和 ANY_ 的内部数据结构 <类型> ", 
"snippet" : "编译代码时，输入变量 内部 和 ANY 数据类型由以下结构组成。当调用 POU 时（在运行时），参数将传递给引用参数。 TYPE AnyType : STRUCT \/\/ Type of the current parameter typeclass : __SYSTEM.TYPE_CLASS ; \/\/ Pointer to the current parameter pvalue : POINTER TO BYTE; \/\/ Size of the data to which the pointer points diSize : DINT; END_STRUCT END_TYPE 您可以通过该...", 
"body" : "编译代码时，输入变量 内部 和 ANY 数据类型由以下结构组成。当调用 POU 时（在运行时），参数将传递给引用参数。 TYPE AnyType :\nSTRUCT\n \/\/ Type of the current parameter\n typeclass : __SYSTEM.TYPE_CLASS ;\n \/\/ Pointer to the current parameter\n pvalue : POINTER TO BYTE;\n \/\/ Size of the data to which the pointer points\n diSize : DINT;\nEND_STRUCT\nEND_TYPE 您可以通过该结构体访问POU内的输入变量，例如查询传递的值。 例子 这比较两个输入变量是否具有相同的类型和相同的值。 FUNCTION funGenericCompare : BOOL\n\/\/ Declaration\nVAR_INPUT\n any1 : ANY;\n any2 : ANY;\nEND_VAR\nVAR\n pTest : POINTER TO ARRAY [0..100] OF POINTER TO DWORD;\n diCount: DINT;\nEND_VAR\n\n\/\/ Implementation\npTest := ADR(any1);\nGeneric_Compare := FALSE;\nIF any1.typeclass <> any2.typeclass THEN\n RETURN;\nEND_IF\nIF any1.diSize <> any2.diSize THEN\n RETURN;\nEND_IF\n\/\/ Byte comparison\nFOR iCount := 0 TO any1.diSize-1 DO\n IF any1.pvalue[iCount] <> any2.pvalue[iCount] THEN\n RETURN;\n END_IF\nEND_FOR\nGeneric_Compare := TRUE;\nRETURN;\n " }, 
{ "title" : "宣言 ", 
"url" : "_cds_datatype_any.html#UUID-08811461-dc3a-9612-9aa1-9d1b22125df5_id_ed37729bef786cc0a8640e01c41bef_id_5fb6e029d9e24e20c0a864630acc6b04", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：ANY、ANY_ <类型> \/ 宣言 ", 
"snippet" : "语法描述指的是只有一个参数（输入变量）的 POU。 句法 <范围> <POU名称> : <返回值的数据类型> 变量输入 <变量名称> : <通用数据类型> ; END_VAR <范围> 可能的范围： FUNCTION FUNCTION_BLOCK METHOD <POU名称> 项目单元名称 : <返回值的数据类型> 选修的 <变量名称> 输入变量的名称 <通用数据类型> ANY , ANY_BIT , ANY_DATE , ANY_NUM , ANY_REAL , ANY_INT ， 或者 ANY_STRING 例子 FUNCTION funComputeAny : BOOL VAR_INPU...", 
"body" : "语法描述指的是只有一个参数（输入变量）的 POU。 句法 <范围> <POU名称> : <返回值的数据类型> \n变量输入\n <变量名称> : <通用数据类型> ; END_VAR <范围> 可能的范围： FUNCTION FUNCTION_BLOCK METHOD <POU名称> 项目单元名称 : <返回值的数据类型> 选修的 <变量名称> 输入变量的名称 <通用数据类型> ANY , ANY_BIT , ANY_DATE , ANY_NUM , ANY_REAL , ANY_INT ， 或者 ANY_STRING 例子 FUNCTION funComputeAny : BOOL\nVAR_INPUT\n anyInput1 : ANY; \/\/ For valid data type see table\nEND_VAR\n\nFUNCTION_BLOCK FB_ComputeAny\nVAR_INPUT\n anyInput1 : ANY;\nEND_VAR\n\nFUNCTION_BLOCK FB_ComputeMethod\nMETHOD methComputeAnny : BOOL\nVAR_INPUT\n anyInput1 : ANY_INT; \/\/ Valid data types are SINT, INT, DINT, LINT, USINT, UINT, UDINT, ULINT\nEND_VAR 对于编译器版本 > 3.5.1.0，支持表中的通用 IEC 数据类型。 该表表示通用数据类型的层次结构，并提供有关形式参数（声明）的通用数据类型允许参数（调用）的基本数据类型的信息。 形式参数情况下的通用数据类型 实际参数（参数）情况下允许的基本数据类型 ANY ANY_BIT BYTE WORD DWORD LWORD ANY_DATE DATE DATE_AND_TIME , DT TIME_OF_DAY , TOD LDATE LDATE_AND_TIME , LDT LTIME_OF_DAY , LTOD ANY_NUM ANY_REAL REAL , LREAL ANY_INT USINT , UINT , UDINT , ULINT SINT , INT , DINT , LINT ANY_STRING STRING , WSTRING " }, 
{ "title" : "数据类型：WSTRING ", 
"url" : "_cds_datatype_wstring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：WSTRING ", 
"snippet" : "WSTRING 根据 IEC 61131-3 标准，数据类型 WSTRING 遵循 UCS-2 编码。 UCS-2 编码意味着一个字符被编码为完全固定长度的 2 个字节。 UCS-2 包含来自以下代码点的字符 U+0000 至 U+D7FF 并从 U+E000 至 U+FFFF .字符串以 0 . 宣言： <variable name> : WSTRING( <size> ) := \" <text> \" 规模 <size> 确定字符串长度。初始化是用 \"<text>\" 细绳。该字符串用双引号标记为 WSTRING。大小和初始化的规范是可选的。 当数据类型的变量 WSTRING 通过重置应用程序...", 
"body" : "WSTRING searchresult_toplevel 根据 IEC 61131-3 标准，数据类型 WSTRING 遵循 UCS-2 编码。 UCS-2 编码意味着一个字符被编码为完全固定长度的 2 个字节。 UCS-2 包含来自以下代码点的字符 U+0000 至 U+D7FF 并从 U+E000 至 U+FFFF .字符串以 0 . 宣言： <variable name> : WSTRING( <size> ) := \" <text> \" 规模 <size> 确定字符串长度。初始化是用 \"<text>\" 细绳。该字符串用双引号标记为 WSTRING。大小和初始化的规范是可选的。 当数据类型的变量 WSTRING 通过重置应用程序重新初始化，（旧）字符串的可用字节对，它们存在于终止空字之后（ WORD ) 的初始值，不会被覆盖。这既适用于使用初始化值进行的初始化，也适用于使用默认初始化值 0 进行的初始化。 例子 WSTRING 数据类型的字符串每个字符需要 2 个字节。在这种情况下 STRING 数据类型，每个字符只保留 1 个字节。 wsString : WSTRING := \"This is a WSTRING\";\nsString : STRING := 'This is a STRING'; 字符串 wsEmpty 是空字符串。变量 wsMoney 带有欧元符号 (€) 的大小为 10。字符串在 10 个字符后被截断。将汉字（U+7BE6）赋值给变量 wsHan . PROGRAM PRG_Money\nVAR\n wsEmpty : WSTRING := \"\"; \/\/ The empty string\n wsMoney : WSTRING(10) := \"12345678 € 123\"; \/\/ String will be truncated\n wsMoney_2 : WSTRING(10) := \"12345678 €\";\n wsHan : WSTRING(10) := \"篦\"; \/\/ Chinese character U+\/BE6\nEND_VAR " }, 
{ "title" : "数据类型：BIT ", 
"url" : "_cds_datatype_bit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：BIT ", 
"snippet" : "BIT 数据类型 BIT 仅在用于声明结构成员的结构或用于声明变量的功能块中有效。一个 BIT 变量可以有值 TRUE (1) 和 FALSE (0)。在这种情况下，变量只需要一位内存。 因此，您可以通过名称对各个位进行符号寻址。 BIT 连续声明的变量以字节捆绑。通过这种方式，您可以优化内存使用，而不是 BOOL 类型，每个保留 8 位。另一方面，位访问更耗时。因此，您应该使用 BIT 仅当您需要以预定义格式定义数据时才使用数据类型。...", 
"body" : "BIT searchresult_toplevel 数据类型 BIT 仅在用于声明结构成员的结构或用于声明变量的功能块中有效。一个 BIT 变量可以有值 TRUE (1) 和 FALSE (0)。在这种情况下，变量只需要一位内存。 因此，您可以通过名称对各个位进行符号寻址。 BIT 连续声明的变量以字节捆绑。通过这种方式，您可以优化内存使用，而不是 BOOL 类型，每个保留 8 位。另一方面，位访问更耗时。因此，您应该使用 BIT 仅当您需要以预定义格式定义数据时才使用数据类型。 " }, 
{ "title" : "数据类型：__UXINT、__XINT、__XWORD ", 
"url" : "_cds_datatype_uxint_xword.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__UXINT、__XINT、__XWORD ", 
"snippet" : "__UXINT、__XINT、__XWORD 根据目标系统，具有这些特殊数据类型的变量将转换为平台兼容的数据类型。 CODESYS 支持具有 32 位和 64 位宽度的地址寄存器的系统。为了使 IEC 代码尽可能独立于目标系统，您使用伪数据类型 __UXINT , __XINT ， 和 __XWORD .编译器检查哪些目标系统类型是当前的，然后将这些数据类型转换为适当的标准数据类型。 此外，为这些数据类型的变量提供了类型转换运算符。 伪数据类型 64 位平台上的类型转换 32 位平台上的类型转换 __UXINT ULINT UDINT __XINT LINT DINT __XWORD LWOR...", 
"body" : "__UXINT、__XINT、__XWORD 根据目标系统，具有这些特殊数据类型的变量将转换为平台兼容的数据类型。 CODESYS 支持具有 32 位和 64 位宽度的地址寄存器的系统。为了使 IEC 代码尽可能独立于目标系统，您使用伪数据类型 __UXINT , __XINT ， 和 __XWORD .编译器检查哪些目标系统类型是当前的，然后将这些数据类型转换为适当的标准数据类型。 此外，为这些数据类型的变量提供了类型转换运算符。 伪数据类型 64 位平台上的类型转换 32 位平台上的类型转换 __UXINT ULINT UDINT __XINT LINT DINT __XWORD LWORD DWORD " }, 
{ "title" : "数据类型：POINTER TO ", 
"url" : "_cds_datatype_pointer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：POINTER TO ", 
"snippet" : "POINTER TO 指针在运行时存储对象的内存地址，例如变量或功能块实例。 指针声明的语法： <pointer name>: POINTER TO <data type> | <data unit type> | <function block name> ; FUNCTION_BLOCK FB_Point VAR piNumber: POINTER TO INT; iNumber1: INT := 5; iNumber2: INT; END_VAR piNumber := ADR(iNumber1); \/\/ piNumber is assigned to address of iNumbe...", 
"body" : "POINTER TO searchresult_toplevel 指针在运行时存储对象的内存地址，例如变量或功能块实例。 指针声明的语法： <pointer name>: POINTER TO <data type> | <data unit type> | <function block name> ; FUNCTION_BLOCK FB_Point\nVAR\n piNumber: POINTER TO INT;\n iNumber1: INT := 5;\n iNumber2: INT;\nEND_VAR\npiNumber := ADR(iNumber1); \/\/ piNumber is assigned to address of iNumber1\niNumber2 := piNumber^; \/\/ value 5 of iNumber1 is assigned to variable iNumber2 by dereferencing of pointer piNumber 取消引用指针意味着获取指针指向的值。通过附加内容运算符来取消引用指针 ^ 指向指针标识符（例如：， piNumber^ 在上面的例子中）。要将对象的地址分配给指针，地址运算符 ADR 应用于对象： ADR(iNumber1) . 在联机模式下，您可以使用 去参考 从指针跳转到被引用变量的声明位置。 当指针指向 I\/O 输入时，应用写访问。生成代码时，这会导致编译器警告 “<指针名称>”不是有效的分配目标 .例子： pwInput := ADR(wInput); 如果您需要这种构造，则必须首先复制输入值（ wInput ) 到具有写访问权限的变量。 " }, 
{ "title" : "对指针的索引访问 ", 
"url" : "_cds_datatype_pointer.html#UUID-ae92281b-697e-83f6-386d-2290b407c800_id_ca488150a6a89ac0a8640e013d12b7_id_bb51ee8bee2b020bc0a864632ddf450d", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：POINTER TO \/ 对指针的索引访问 ", 
"snippet" : "CODESYS 允许索引访问 [] 类型变量 POINTER TO ，以及数据类型 STRING 或者 WSTRING . 指针指向的数据也可以通过附加括号运算符来访问 [] 指向指针标识符（例如， piData[i] ）。指针的基本数据类型决定了索引组件的数据类型和大小。在这种情况下，对指针的索引访问是通过添加与索引相关的偏移量来算术完成的 i * SIZEOF(<base type>) 到指针的地址。指针同时被隐式取消引用。 计算： piData[i] := (piData + i * SIZEOF(INT))^; 那不是 不是 ： piData[i] != (piData + i)^; ...", 
"body" : "CODESYS 允许索引访问 [] 类型变量 POINTER TO ，以及数据类型 STRING 或者 WSTRING . 指针指向的数据也可以通过附加括号运算符来访问 [] 指向指针标识符（例如， piData[i] ）。指针的基本数据类型决定了索引组件的数据类型和大小。在这种情况下，对指针的索引访问是通过添加与索引相关的偏移量来算术完成的 i * SIZEOF(<base type>) 到指针的地址。指针同时被隐式取消引用。 计算： piData[i] := (piData + i * SIZEOF(INT))^; 那不是 不是 ： piData[i] != (piData + i)^; 索引访问 STRING 当您将索引访问与类型的变量一起使用时 STRING ，您将在索引表达式的偏移量处获得字符。结果是类型 BYTE .例如， sData[i] 返回字符串的第 i 个字符 sData 作为 SINT （ASCII）。 索引访问 WSTRING 当您将索引访问与类型的变量一起使用时 WSTRING ，您将在索引表达式的偏移量处获得字符。结果是类型 WORD .例如， wsData[i] 将字符串的第 i 个字符返回为 INT （统一码）。 指向的引用和指针 BIT 变量是 无效 声明，以及具有基本类型的数组元素 BIT 。 " }, 
{ "title" : "减法指针 ", 
"url" : "_cds_datatype_pointer.html#UUID-ae92281b-697e-83f6-386d-2290b407c800_id_ca488150a6a89ac0a8640e013d12b7_id_d85f8909ea809296c0a8646357089285", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：POINTER TO \/ 减法指针 ", 
"snippet" : "两个指针不同的结果是一个类型的值 DWORD ，即使在 64 位平台上，当指针是 64 位指针时也是如此。 使用引用提供了保证类型安全的优势。指针不是这种情况。 可以在运行时通过隐式监控功能检查指针的内存访问 CheckPointer ....", 
"body" : "两个指针不同的结果是一个类型的值 DWORD ，即使在 64 位平台上，当指针是 64 位指针时也是如此。 使用引用提供了保证类型安全的优势。指针不是这种情况。 可以在运行时通过隐式监控功能检查指针的内存访问 CheckPointer . " }, 
{ "title" : "数据类型：REFERENCE TO ", 
"url" : "_cds_datatype_reference.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：REFERENCE TO ", 
"snippet" : "REFERENCE TO 对于编译器版本 >= V3.3.0.0，引用被初始化（在 0 处）。 如果引用是指设备输入，则该访问被应用为写访问。生成代码时，这会导致编译器警告：\" ...invalid assignment target ”。 例子： rInput REF= Input; 如果您需要这种构造，则必须首先复制输入值（例如： rInput ) 到具有写访问权限的变量。 与参考 REFERENCE 数据类型隐式引用另一个对象。作业是用 REF= 操作员 .访问时，引用被隐式取消引用，因此不需要特殊的内容运算符 ^ 比如指针。 句法 <identifier> : REFERENCE TO...", 
"body" : "REFERENCE TO searchresult_toplevel 对于编译器版本 >= V3.3.0.0，引用被初始化（在 0 处）。 如果引用是指设备输入，则该访问被应用为写访问。生成代码时，这会导致编译器警告：\" ...invalid assignment target ”。 例子： rInput REF= Input; 如果您需要这种构造，则必须首先复制输入值（例如： rInput ) 到具有写访问权限的变量。 与参考 REFERENCE 数据类型隐式引用另一个对象。作业是用 REF= 操作员 .访问时，引用被隐式取消引用，因此不需要特殊的内容运算符 ^ 比如指针。 句法 <identifier> : REFERENCE TO <data type> ;\n<data type>: base type of the reference 有效声明 PROGRAM PLC_PRG\nVAR\n rspeA : REFERENCE TO DUT_SPECIAL;\n pspeA : POINTER TO DUT_SPECIAL;\n speB : DUT_SPECIAL;\nEND_VAR\nrspeA REF= speB; \/\/ Reference rspeA is alias for speB. The code corresponds to pspeA := ADR(speB);\nrspeA := speD; \/\/ The code corresponds to pspeA^ := speD; 无效的声明 ariTest : ARRAY[0..9] OF REFERENCE TO INT;\npriTest : POINTER TO REFERENCE TO INT;\nrriTest : REFERENCE TO REFERENCE TO INT;\nrbitTest : REFERENCE TO BIT; 引用类型不得用作数组、指针或引用的基类型。此外，引用不得引用位变量。这些类型的结构会产生编译器错误。 当通过标识符及其别名同时访问同一存储单元时，程序的可读性会变得困难。 例子： speB 和 rspeA 指向的引用和指针 BIT 变量是 无效 声明，以及具有基本类型的数组元素 BIT 。 例子 当引用被分配时 := ，无论引用是在左侧、右侧还是两侧，始终都会复制值： Ref := value 写入值 value 到参考点指向的位置。用指针表示法： Ref^ := value value := Ref 之后写入引用指向的值 value 。用指针表示法： value := Ref^ Ref1 := Ref2 写入的值 Ref2 指着。在那个位置 Ref1 指着。用指针表示法： Ref1^ := Ref2^ 什么时候 REF= 使用时，始终应用地址，并且左侧必须有一个引用： Ref REF= value : 参考点 value 。用指针表示法： Ref :=ADR(value) Ref1 REF= Ref2 ： Ref1 指向相同的值 Ref2 。用指针表示法： Ref1 := Ref2 Value REF = Ref 导致编译错误 在声明中， REFERENCE TO INT REF= value 表现得像 REFERENCE TO INT := value 。 " }, 
{ "title" : "引用和指针的比较 ", 
"url" : "_cds_datatype_reference.html#UUID-bbf067d0-f5c8-c60a-7bd0-cfeb6b1879c8_id_e9675c6450b1e354c0a8640e011c35ec_id_7cb25b01cab174b8c0a86463367a259c", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：REFERENCE TO \/ 引用和指针的比较 ", 
"snippet" : "与指针相比，引用具有以下优点： 更容易使用： 引用可以直接访问被引用对象的内容，而无需取消引用。 传递值时更精细和更简单的语法： 调用一个功能块，它传递一个没有地址运算符而不是指针的引用 例子： fbDoIt(riInput:=iValue); 代替： fbDoIt_1(piInput:=ADR(iValue)); 类型安全： 分配两个引用时，编译器会检查它们的基类型是否匹配。这在指针的情况下不被检查。...", 
"body" : "与指针相比，引用具有以下优点： 更容易使用： 引用可以直接访问被引用对象的内容，而无需取消引用。 传递值时更精细和更简单的语法： 调用一个功能块，它传递一个没有地址运算符而不是指针的引用 例子： fbDoIt(riInput:=iValue); 代替： fbDoIt_1(piInput:=ADR(iValue)); 类型安全： 分配两个引用时，编译器会检查它们的基类型是否匹配。这在指针的情况下不被检查。 " }, 
{ "title" : "测试参考的有效性 ", 
"url" : "_cds_datatype_reference.html#UUID-bbf067d0-f5c8-c60a-7bd0-cfeb6b1879c8_id_e9675c6450b1e354c0a8640e011c35ec_id_8030529aea123829c0a8646368002330", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：REFERENCE TO \/ 测试参考的有效性 ", 
"snippet" : "您可以使用运算符 __ISVALIDREF 检查引用是否指向有效值（即不等于 0 的值）。 句法 <boolean variable name> := __ISVALIDREF( <reference name> ); <reference name> : 声明的标识符 REFERENCE TO 布尔变量是 TRUE 当引用指向一个有效值时。否则就是 FALSE . PROGRAM PLC_PRG VAR iAlfa : INT; riBravo : REFERENCE TO INT; riCharlie : REFERENCE TO INT; bIsRef_Bravo : BOOL := F...", 
"body" : "您可以使用运算符 __ISVALIDREF 检查引用是否指向有效值（即不等于 0 的值）。 句法 <boolean variable name> := __ISVALIDREF( <reference name> ); <reference name> : 声明的标识符 REFERENCE TO 布尔变量是 TRUE 当引用指向一个有效值时。否则就是 FALSE . PROGRAM PLC_PRG\nVAR\n iAlfa : INT;\n riBravo : REFERENCE TO INT;\n riCharlie : REFERENCE TO INT;\n bIsRef_Bravo : BOOL := FALSE;\n bIsRef_Charlie : BOOL := FALSE;\nEND_VAR\niAlfa := iAlfa + 1;\nriBravo REF= iAlfa;\nriCharlie REF= 0;\nbIsRef_Bravo := __ISVALIDREF(riBravo); (* becomes TRUE, because riBravo references to iAlfa, which is non-zero *)\nbIsRef_Charlie := __ISVALIDREF(riCharlie); (* becomes FALSE, because riCharlie is set to 0 *) 在编译器版本 3.5.7.40 及更高版本中，隐式监控功能 检查指针 作用于类型变量 REFERENCE TO 与指针变量相同。 " }, 
{ "title" : "数据类型：ARRAY OF ", 
"url" : "_cds_datatype_array.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：ARRAY OF ", 
"snippet" : "ARRAY OF 数组是相同数据类型的数据元素的集合。支持固定或可变长度的单维和多维数组。...", 
"body" : "ARRAY OF searchresult_toplevel 数组是相同数据类型的数据元素的集合。支持固定或可变长度的单维和多维数组。 " }, 
{ "title" : "固定长度的一维数组 ", 
"url" : "_cds_datatype_array.html#UUID-ce9d7e29-a882-1174-ca9c-9117bd3cb42b_id_afe6bda193f4f1e8c0a8640e018f0592_id_b5dd0603c8cd5e60c0a864636e8b5a53", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：ARRAY OF \/ 固定长度的一维数组 ", 
"snippet" : "您可以在 POU 的声明部分或全局变量列表中定义数组。 一维数组的声明语法： <variable name> : ARRAY[ <dimension> ] OF <data type> := <initialization> ; <variable name> 数组名称 例子： aiCounter <dimension> 维度（从低到高的索引限制） 例子： 1..100 一维可以有任意数量的索引元素，由索引上限和下限决定。 索引限制是整数；数据类型的最大值 DINT . <data type> 元素的数据类型： 基本数据类型 用户定义的数据类型 功能块 指向的引用和指针 BIT 变量是 无效 ...", 
"body" : "您可以在 POU 的声明部分或全局变量列表中定义数组。 一维数组的声明语法： <variable name> : ARRAY[ <dimension> ] OF <data type> := <initialization> ;\n <variable name> 数组名称 例子： aiCounter <dimension> 维度（从低到高的索引限制） 例子： 1..100 一维可以有任意数量的索引元素，由索引上限和下限决定。 索引限制是整数；数据类型的最大值 DINT . <data type> 元素的数据类型： 基本数据类型 用户定义的数据类型 功能块 指向的引用和指针 BIT 变量是 无效 声明，以及具有基本类型的数组元素 BIT 。 <initialization> 选修的 数组的初始值 10 个整数元素的一维数组 VAR\n aiCounter : ARRAY[0..9] OF INT;\nEND_VAR 索引下限：0 指数上限：9 10 个元素的初始化： aiCounter : ARRAY[0..9] OF INT := [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]; 数据访问 iLocalVariable := aiCounter[2]; 将值 20 分配给局部变量。 " }, 
{ "title" : "定长多维数组 ", 
"url" : "_cds_datatype_array.html#UUID-ce9d7e29-a882-1174-ca9c-9117bd3cb42b_section-idm4611103852920032708558820554", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：ARRAY OF \/ 定长多维数组 ", 
"snippet" : "<variable name> : ARRAY[ <1st dimension> , <next dimensions> ] OF <data type> := <initialization> ; <variable name> [ <index of 1st dimension> , <index of next dimensions> ] <1st dimension> 第一维（从低到高的索引限制） , <next dimensions> 下一个维度（逗号分隔） 数据访问语法 <index of 1st dimension> 第一维的索引限制 , <next dimensions> 下一...", 
"body" : "<variable name> : ARRAY[ <1st dimension> , <next dimensions> ] OF <data type> := <initialization> ;\n <variable name> [ <index of 1st dimension> , <index of next dimensions> ]\n <1st dimension> 第一维（从低到高的索引限制） , <next dimensions> 下一个维度（逗号分隔） 数据访问语法 <index of 1st dimension> 第一维的索引限制 , <next dimensions> 下一个维度的索引限制 二维数组 VAR\n aiCardGame : ARRAY[1..2, 3..4] OF INT;\nEND_VAR 第 1 维：1 到 2（2 个数组元素） 第 2 维：3 到 4（2 个数组元素） 2 * 2 元素的初始化： aiCardGame : ARRAY[1..2, 3..4] OF INT := [2(10),2(20)]; \/\/ Short notation for [10, 10, 20, 20] 数据访问 iLocal_1 := aiCardGame[1, 3]; \/\/ Assignment of 10\niLocal_2 := aiCardGame[2, 4]; \/\/ Assignment of 20 三维数组 VAR\n aiCardGame : ARRAY[1..2, 3..4, 5..6] OF INT;\nEND_VAR 第一维：1 到 2 第 2 维：3 到 4 第 3 维：5 到 6 2 * 2 * 2 = 8 个数组元素 初始化 aiCardGame : ARRAY[1..2, 3..4, 5..6] OF INT := [10, 20, 30, 40, 50, 60, 70, 80]; 数据访问 iLocal_1 := aiCardGame[1, 3, 5]; \/\/ Assignment of 10\niLocal_2 := aiCardGame[2, 3, 5]; \/\/ Assignment of 20\niLocal_3 := aiCardGame[1, 4, 5]; \/\/ Assignment of 30\niLocal_4 := aiCardGame[2, 4, 5]; \/\/ Assignment of 40\niLocal_5 := aiCardGame[1, 3, 6]; \/\/ Assignment of 50\niLocal_6 := aiCardGame[2, 3, 6]; \/\/ Assignment of 60\niLocal_7 := aiCardGame[1, 4, 6]; \/\/ Assignment of 70\niLocal_8 := aiCardGame[2, 4, 6]; \/\/ Assignment of 80 初始化 aiCardGame : ARRAY[1..2, 3..4, 5..6] OF INT := [2(10), 2(20), 2(30), 2(40)]; \/\/ Short notation for [10, 10, 20, 20, 30, 30, 40, 40] 数据访问 iLocal_1 := aiCardGame[1, 3, 5]; \/\/ Assignment of 10\niLocal_2 := aiCardGame[2, 3, 5]; \/\/ Assignment of 10\niLocal_3 := aiCardGame[1, 4, 5]; \/\/ Assignment of 20\niLocal_4 := aiCardGame[2, 4, 5]; \/\/ Assignment of 20\niLocal_5 := aiCardGame[1, 3, 6]; \/\/ Assignment of 30\niLocal_6 := aiCardGame[2, 3, 6]; \/\/ Assignment of 30\niLocal_7 := aiCardGame[1, 4, 6]; \/\/ Assignment of 40\niLocal_8 := aiCardGame[2, 4, 6]; \/\/ Assignment of 40 用户定义结构的三维数组 TYPE DATA_A\nSTRUCT\n iA_1 : INT;\n iA_2 : INT;\n dwA_3 : DWORD;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n aData_A : ARRAY[1..3, 1..3, 1..10] OF DATA_A;\nEND_VAR 数组 aData_A 总共由 3 * 3 * 10 = 90 个数据类型的数组元素组成 DATA_A . 部分初始化 aData_A : ARRAY[1..3, 1..3, 1..10] OF DATA_A \n := [(iA_1 := 1, iA_2 := 10, dwA_3 := 16#00FF),(iA_1 := 2, iA_2 := 20, dwA_3 := 16#FF00),(iA_1 := 3, iA_2 := 30, dwA_3 := 16#FFFF)]; 在示例中，只有前 3 个元素被显式初始化。没有显式分配初始化值的元素在内部使用基本数据类型的默认值进行初始化。这将从元素开始在 0 处初始化结构组件 aData_A[2, 1, 1] . 数据访问 iLocal_1 := aData_A[1,1,1].iA_1; \/\/ Assignment of 1\ndwLocal_2 := aData_A[3,1,1].dwA_3; \/\/ Assignment of 16#FFFF 功能块数组 FUNCTION BLOCK FBObject_A\nVAR\n iCounter : INT;\nEND_VAR\n...\n;\n\nPROGRAM PLC_PRG\nVAR\n aObject_A : ARRAY[1..4] OF FBObject_A;\nEND_VAR 数组 aObject_A 由4个元素组成。每个元素实例化一个 FBObject_A 功能块。 函数调用 aObject_A[2](); 功能块的二维数组 实施 FB_Something 用方法 FB_Init FUNCTION_BLOCK FB_Something\nVAR\n _nId : INT;\n _lrIn : LREAL;\nEND_VAR\n...\n METHOD FB_Init : BOOL\n VAR_INPUT\n bInitRetains : BOOL;\n bInCopyCode : BOOL;\n nId : INT;\n lrIn : LREAL;\n END_VAR\n _nId := nId;\n _lrIn := lrIN; 功能块 FB_Something 有方法 FB_Init 这需要2个参数。 初始化数组的实例化 PROGRAM PLC_PRG\nVAR\n fb_Something_1 : FB_Something(nId := 11, lrIn := 33.44);\n a_Something : ARRAY[0..1, 0..1] OF FB_Something[(nId := 12, lrIn := 11.22), (nId := 13, lrIn := 22.33), (nId := 14, lrIn := 33.55),(nId := 15, lrIn := 11.22)];\nEND_VAR 注意使用隐式监控功能的能力 CheckBounds() 在运行时监视索引限制的维护。 " }, 
{ "title" : "数组数组 ", 
"url" : "_cds_datatype_array.html#UUID-ce9d7e29-a882-1174-ca9c-9117bd3cb42b_id_afe6bda193f4f1e8c0a8640e018f0592_id_b66cd6345f6ee346c0a864636bd344c4", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：ARRAY OF \/ 数组数组 ", 
"snippet" : "“数组数组”的声明是多维数组的另一种语法。一组元素是嵌套的，而不是标注元素的尺寸。嵌套深度是无限的。 声明语法 <variable name> : ARRAY[ <any dimension> ] OF ARRAY[ <any dimension> ] OF <data type> := <initialization> ; 数据访问语法 <variable name> [<index of first array> ] [<index of next array> ] <variable name> 数组名称 例子： aaaiCounter ARRAY[ <any dimension> ] ...", 
"body" : "“数组数组”的声明是多维数组的另一种语法。一组元素是嵌套的，而不是标注元素的尺寸。嵌套深度是无限的。 声明语法 <variable name> : ARRAY[ <any dimension> ] OF ARRAY[ <any dimension> ] OF <data type> := <initialization> ;\n 数据访问语法 <variable name> [<index of first array> ] [<index of next array> ]\n <variable name> 数组名称 例子： aaaiCounter ARRAY[ <any dimension> ] OF ARRAY[ <any dimension> ] OF ARRAY[ <any dimension> ] OF 三层嵌套数组 例子： ARRAY[1..2, 1..3] OF ARRAY[1..3] OF ARRAY[1..4] OF ARRAY[1..5] 嵌套深度是无限的。 <data type> 元素的数据类型： 基本数据类型 用户定义的数据类型 功能块 <initialization> 选修的 嵌套数组的初始值 PROGRAM PLC_PRG\nVAR\n aiPoints : ARRAY[1..2,1..3] OF INT := [1,2,3,4,5,6];\n ai2Boxes : ARRAY[1..2] OF ARRAY[1..3] OF INT := [ [1, 2, 3], [ 4, 5, 6]];\n ai3Boxes : ARRAY[1..2] OF ARRAY[1..3] OF ARRAY[1..4] OF INT := [ [ [1, 2, 3, 4], [5, 6, 7, 8 ], [9, 10, 11, 12] ], [ [13, 14, 15, 16], [ 17, 18, 19, 20], [21, 22, 23, 24] ] ];\n ai4Boxes : ARRAY[1..2] OF ARRAY[1..3] OF ARRAY[1..4] OF ARRAY[1..5] OF INT;\nEND_VAR\n\naiPoints[1, 2] := 1200;\nai2Boxes[1][2] := 1200; 变量 aiPoints 和 ai2Boxes 收集相同的数据元素，但声明的语法与数据访问的语法不同。 " }, 
{ "title" : "可变长度数组 ", 
"url" : "_cds_datatype_array.html#UUID-ce9d7e29-a882-1174-ca9c-9117bd3cb42b_id_afe6bda193f4f1e8c0a8640e018f0592_id_05960a2f604f5f86c0a8646342ab6f03", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：ARRAY OF \/ 可变长度数组 ", 
"snippet" : "在功能块、函数或方法中，您可以在 VAR_IN_OUT 声明部分。 这 LOWER_BOUND 和 UPPER_BOUND 提供运算符用于确定运行时实际使用的数组的索引限制。 仅静态声明的数组（不是通过运算符生成的数组 __NEW ) 可以传递给可变长度的数组。 一维变长数组的声明语法 <variable name> : ARRAY[*] OF <data type> := <initialization> ; <variable name> 数组名称 例子： aMyVariableArray <data type> 元素的数据类型： 基本数据类型 用户定义的数据类型 功能块 <initial...", 
"body" : "在功能块、函数或方法中，您可以在 VAR_IN_OUT 声明部分。 这 LOWER_BOUND 和 UPPER_BOUND 提供运算符用于确定运行时实际使用的数组的索引限制。 仅静态声明的数组（不是通过运算符生成的数组 __NEW ) 可以传递给可变长度的数组。 一维变长数组的声明语法 <variable name> : ARRAY[*] OF <data type> := <initialization> ;\n <variable name> 数组名称 例子： aMyVariableArray <data type> 元素的数据类型： 基本数据类型 用户定义的数据类型 功能块 <initialization> 选修的 数组数组的初始值 可变长度多维数组的声明语法 <variable name> : ARRAY[*, *] OF <data type> := <initialization> ;\n <variable name> 数组名称 例子： aMyVariableArray ARRAY[*, *] 可变长度二维数组的声明 形式上，星号代表可变长度的每个维度。尺寸以逗号分隔。 允许任意数量的可变长度维度。 计算限制指数的运算符语法 LOWER_BOUND( <variable name> , <dimension number> )\nUPPER_BOUND( <variable name> , <dimension number> ) 这 SUM 函数将数组元素的整数值相加并返回计算的总和作为结果。总和是在运行时可用的所有数组元素中计算的。由于数组元素的实际数量只有在运行时才能知道，所以局部变量被声明为可变长度的一维数组。 FUNCTION SUM: INT;\nVAR_IN_OUT\n aiData : ARRAY[*] OF INT;\nEND_VAR\nVAR\n diCounter : DINT;\n iResult : INT;\nEND_VAR\n\niResult := 0;\nFOR diCounter := LOWER_BOUND(aiData, 1) TO UPPER_BOUND(aiData, 1) DO \/\/ Calculates the length of the current array\n iResult := iResult + aiData[diCounter];\nEND_FOR;\nSUM := iResult; " }, 
{ "title" : "用户自定义数据类型：TYPE ", 
"url" : "_cds_datatype_type.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE ", 
"snippet" : "TYPE...", 
"body" : "TYPE " }, 
{ "title" : "数据结构： STRUCT ", 
"url" : "_cds_datatype_structure.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 数据结构： STRUCT ", 
"snippet" : "STRUCT 结构是一种用户定义的数据类型，它将任何数据类型的多个变量组合成一个逻辑单元。在结构中声明的变量称为成员。 你在中声明一个结构的类型 DUT 你在中创建的对象 项目 → 添加对象 → DUT 菜单或应用程序的快捷菜单中。 有关更多信息，请参阅： DUT...", 
"body" : "STRUCT 结构是一种用户定义的数据类型，它将任何数据类型的多个变量组合成一个逻辑单元。在结构中声明的变量称为成员。 你在中声明一个结构的类型 DUT 你在中创建的对象 项目 → 添加对象 → DUT 菜单或应用程序的快捷菜单中。 有关更多信息，请参阅： DUT" }, 
{ "title" : "语法 ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_section-idm234801371238798", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 数据结构： STRUCT \/ 语法 ", 
"snippet" : "TYPE <structure name> STRUCT     <member name> : <data type> := <initialization> ; END_STRUCT END_TYPE <structure name> 此标识符在整个项目中有效，因此您可以像使用标准数据类型一样使用它。 <member name> : <data type> ; 成员声明 随后可以发表任意数量的声明，但至少 2 个。 结构也可以嵌套。这意味着您使用现有结构类型声明结构成员。那么唯一的限制是你不能为变量（结构成员）分配任何地址。这个 AT 这里不允许声明。 := <initialization...", 
"body" : "TYPE <structure name> STRUCT     <member name> : <data type> := <initialization> ; END_STRUCT END_TYPE <structure name> 此标识符在整个项目中有效，因此您可以像使用标准数据类型一样使用它。 <member name> : <data type> ; 成员声明 随后可以发表任意数量的声明，但至少 2 个。 结构也可以嵌套。这意味着您使用现有结构类型声明结构成员。那么唯一的限制是你不能为变量（结构成员）分配任何地址。这个 AT 这里不允许声明。 := <initialization> 可选 类型声明 TYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "类型声明的扩展 ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_id_b2e3e6da93f532b0c0a8640e011c7a1d_id_0f4f7c7b39401232c0a8640e0030157d", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 数据结构： STRUCT \/ 类型声明的扩展 ", 
"snippet" : "另一个结构是从现有结构中声明的。除了自己的成员外，扩展结构还具有与基础结构相同的结构成员。 语法 TYPE <structure name> EXTENDS <base structure> STRUCT     <member declaration> END_STRUCT END_TYPE 示例 类型声明： S_PENTAGON TYPE S_PENTAGON EXTENDS S_POLYGONLINE : STRUCT aiPoint5 : ARRAY[1..2] OF INT; END_STRUCT END_TYPE...", 
"body" : "另一个结构是从现有结构中声明的。除了自己的成员外，扩展结构还具有与基础结构相同的结构成员。 语法 TYPE <structure name> EXTENDS <base structure> STRUCT     <member declaration> END_STRUCT END_TYPE 示例 类型声明： S_PENTAGON TYPE S_PENTAGON EXTENDS S_POLYGONLINE :\nSTRUCT\n aiPoint5 : ARRAY[1..2] OF INT;\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "结构变量的声明和初始化 ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_id_b2e3e6da93f532b0c0a8640e011c7a1d_id_51c8c615dae0fa66c0a8640e0071defa", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 数据结构： STRUCT \/ 结构变量的声明和初始化 ", 
"snippet" : "示例 PROGRAM progLine VAR sPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]); sPentagon : S_PENTAGON := (aiStart:=[0,0], aiPoint1:=[1,1], aiPoint2:=[2,2], aiPoint3:=[3,3], aiPoint4:=[4,4], aiPoint5:=[5,5], aiEnd:=[0,0]); END_V...", 
"body" : "示例 PROGRAM progLine\nVAR\n sPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n sPentagon : S_PENTAGON := (aiStart:=[0,0], aiPoint1:=[1,1], aiPoint2:=[2,2], aiPoint3:=[3,3], aiPoint4:=[4,4], aiPoint5:=[5,5], aiEnd:=[0,0]);\nEND_VAR 不得对变量使用初始化。有关初始化结构数组的示例，请参阅该数据类型的帮助页面 ARRAY OF。 " }, 
{ "title" : "访问结构成员 ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_id_b2e3e6da93f532b0c0a8640e011c7a1d_id_a8aa433778b4bcc1c0a8640e00eb4380", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 数据结构： STRUCT \/ 访问结构成员 ", 
"snippet" : "您可以使用以下语法访问结构成员： <variable name> . <member name> 示例 PROGRAM prog_Polygon VAR sPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]); iPoint : INT; END_VAR \/\/ Assigs 5 to aiPoint iPoint := sPolygon.aiPoint1[1]; 结果： iPoint = 5...", 
"body" : "您可以使用以下语法访问结构成员： <variable name> . <member name> 示例 PROGRAM prog_Polygon\nVAR\n sPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n iPoint : INT;\nEND_VAR \/\/ Assigs 5 to aiPoint\niPoint := sPolygon.aiPoint1[1]; 结果： iPoint = 5 " }, 
{ "title" : "结构变量中的符号位访问 ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_id_b2e3e6da93f532b0c0a8640e011c7a1d_id_d5b32f89e566c6fcc0a8646322497f5b", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 数据结构： STRUCT \/ 结构变量中的符号位访问 ", 
"snippet" : "你可以用数据类型的变量声明一个结构 BIT 将各个位组合成一个逻辑单元。然后，您可以通过名称（而不是位索引）象征性地寻址各个位 语法声明 TYPE <structure name> : STRUCT     <member name> : BIT; END_STRUCT END_TYPE 位访问的语法 <structure name> . <member name> 示例 类型声明 TYPE S_CONTROL : STRUCT bitOperationEnabled : BIT; bitSwitchOnActive : BIT; bitEnableOperation : BIT; bitEr...", 
"body" : "你可以用数据类型的变量声明一个结构 BIT 将各个位组合成一个逻辑单元。然后，您可以通过名称（而不是位索引）象征性地寻址各个位 语法声明 TYPE <structure name> : STRUCT     <member name> : BIT; END_STRUCT END_TYPE 位访问的语法 <structure name> . <member name> 示例 类型声明 TYPE S_CONTROL :\nSTRUCT\n bitOperationEnabled : BIT;\n bitSwitchOnActive : BIT;\n bitEnableOperation : BIT;\n bitError : BIT;\n bitVoltageEnabled : BIT;\n bitQuickStop : BIT;\n bitSwitchOnLocked : BIT;\n bitWarning : BIT;\nEND_STRUCT\nEND_TYPE 位访问 FUNCTION_BLOCK FB_Controller\nVAR_INPUT\n xStart : BOOL;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n ControlDriveA : S_CONTROL;\nEND_VAR\n\nIF xStart = TRUE THEN\n \/\/ Symbolic bit access\n ControlDriveA.bitEnableOperation := TRUE;\nEND_IF\n\nPROGRAM PLC_PRG\n fbController : FB_Controller;\nEND_VAR\n fbController();\nfbController.xStart := TRUE; 有关更多信息，请参阅： 变量中的位访问指向的引用和指针 BIT 变量是 无效 声明，以及具有基本类型的数组元素 BIT 。 " }, 
{ "title" : "枚举 ", 
"url" : "_cds_datatype_enum.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 枚举 ", 
"snippet" : "枚举是一种用户定义的数据类型，由逗号分隔的成员列表（枚举值）组成，用于声明用户定义的变量。 你在 a 中声明一个枚举 DUT 对象，您已经通过单击在项目中创建了该对象 添加对象 。 在应用程序代码中，您可以像使用常量一样使用枚举成员，其标识符 <enumeration name>.<member name> 在项目中全局识别。 有关更多信息，请参阅： DUT...", 
"body" : "searchresult_toplevel 枚举是一种用户定义的数据类型，由逗号分隔的成员列表（枚举值）组成，用于声明用户定义的变量。 你在 a 中声明一个枚举 DUT 对象，您已经通过单击在项目中创建了该对象 添加对象 。 在应用程序代码中，您可以像使用常量一样使用枚举成员，其标识符 <enumeration name>.<member name> 在项目中全局识别。 有关更多信息，请参阅： DUT" }, 
{ "title" : "声明 ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_addb6d4f1efde45ac0a8646363edf874", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 枚举 \/ 声明 ", 
"snippet" : "语法 {attribute 'strict'} TYPE <enumeration name> : (     <member name> := <value> ) <base data type> := <initialization> ; END_TYPE {attribute 'strict'} 可选 该编译指示的效果是按如下所述进行严格的类型测试。 编译指示是可选的，但建议使用。 <enumeration name> 可在代码中用作数据类型的枚举名称 示例： COLOR_BASIC     <member name> := <initial value> 任意数量的成员，但至少有两个成...", 
"body" : "语法 {attribute 'strict'} TYPE <enumeration name> : (     <member name> := <value> ) <base data type> := <initialization> ; END_TYPE {attribute 'strict'} 可选 该编译指示的效果是按如下所述进行严格的类型测试。 编译指示是可选的，但建议使用。 <enumeration name> 可在代码中用作数据类型的枚举名称 示例： COLOR_BASIC     <member name> := <initial value> 任意数量的成员，但至少有两个成员 枚举是圆括号中以逗号分隔的成员名称列表。右括号前的最后一个成员不需要逗号。所有成员都有相同的数据类型。 成员的值自动初始化：从 0 开始，值连续增加 1。您也可以为各个成员显式分配固定的初始值。 示例： yellow := 1 <base data type> 可选 您可以显式分配以下基本数据类型之一： INT | UINT | SINT | USINT | DINT | UDINT | LINT | ULINT | BYTE | WORD | DWORD | LWORD 默认： INT := <initialization> 可选 可以将其中一个成员明确声明为初始成员。 默认：如果未明确指定初始化，则自动使用顶级成员执行初始化。 示例 {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE COLOR_BASIC :\n(\n yellow,\n green,\n blue,\n black\n) \/\/ Basic data type is INT, default initialization for all COLOR_BASIC variables is yellow\n;\nEND_TYPE " }, 
{ "title" : "使用显式基本数据类型的枚举 ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_eeaeeade1efde45ac0a864636eafe5b8", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 枚举 \/ 使用显式基本数据类型的枚举 ", 
"snippet" : "IEC 61131-3 标准的扩展 枚举声明的基本数据类型是 INT 默认情况下。但是，您也可以声明明确基于另一种整数数据类型的枚举 示例 使用基本数据类型的枚举 DWORD TYPE COLOR : ( white := 16#FFFFFF00, yellow := 16#FFFFFF00, green := 16#FF00FF00, blue := 16#FF0000FF, black := 16#88000000 ) DWORD := black ; \/\/ Basic data type is DWORD, default initialization for all COLOR var...", 
"body" : "IEC 61131-3 标准的扩展 枚举声明的基本数据类型是 INT 默认情况下。但是，您也可以声明明确基于另一种整数数据类型的枚举 示例 使用基本数据类型的枚举 DWORD TYPE COLOR :\n(\n white := 16#FFFFFF00,\n yellow := 16#FFFFFF00,\n green := 16#FF00FF00,\n blue := 16#FF0000FF,\n black := 16#88000000\n) DWORD := black\n; \/\/ Basic data type is DWORD, default initialization for all COLOR variables is black\nEND_TYPE " }, 
{ "title" : "严格的编程规则 ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_9f56ad50bcf5b28cc0a8640e01b52258", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 枚举 \/ 严格的编程规则 ", 
"snippet" : "在 CODESYS V3.5 SP7 及更高版本，编译指令 {attribute 'strict'} 声明枚举时会自动添加到第一行。 添加编译指示时会激活严格的编程规则 {attribute 'strict'} 。 以下代码被视为编译器错误： 使用枚举成员的算术运算 例如，枚举变量不能用作计数器变量 FOR 循环。 将不对应于枚举值的常量值分配给枚举成员 将具有另一种数据类型作为枚举的非常量变量赋值给枚举成员 算术运算可能导致将未声明的值分配给枚举成员。更好的编程风格是使用 SWITCH \/ CASE 用于处理成员值的语句。...", 
"body" : "在 CODESYS V3.5 SP7 及更高版本，编译指令 {attribute 'strict'} 声明枚举时会自动添加到第一行。 添加编译指示时会激活严格的编程规则 {attribute 'strict'} 。 以下代码被视为编译器错误： 使用枚举成员的算术运算 例如，枚举变量不能用作计数器变量 FOR 循环。 将不对应于枚举值的常量值分配给枚举成员 将具有另一种数据类型作为枚举的非常量变量赋值给枚举成员 算术运算可能导致将未声明的值分配给枚举成员。更好的编程风格是使用 SWITCH \/ CASE 用于处理成员值的语句。 " }, 
{ "title" : "枚举变量的声明和初始化 ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_c30c45711efde45ac0a864630973c0ee", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 枚举 \/ 枚举变量的声明和初始化 ", 
"snippet" : "语法 <variable name> : <enumeration name> := <initialization> ; 如果使用用户定义的枚举声明枚举变量，则可以使用枚举成员初始化该变量。 示例 PROGRAM PLC_PRG VAR colorCar: COLOR; colorTaxi : COLOR := COLOR.yellow; END_VAR 变量 colorCar 初始化为 COLOR.black 。这是所有类型枚举变量的默认初始化 COLOR 并在类型声明中以这种方式定义。变量 colorTaxi 有自己的初始化。 如果未指定初始化，则初始化值为 0。 示例 PROGRAM ...", 
"body" : "语法 <variable name> : <enumeration name> := <initialization> ; 如果使用用户定义的枚举声明枚举变量，则可以使用枚举成员初始化该变量。 示例 PROGRAM PLC_PRG\nVAR\n colorCar: COLOR;\n colorTaxi : COLOR := COLOR.yellow;\nEND_VAR 变量 colorCar 初始化为 COLOR.black 。这是所有类型枚举变量的默认初始化 COLOR 并在类型声明中以这种方式定义。变量 colorTaxi 有自己的初始化。 如果未指定初始化，则初始化值为 0。 示例 PROGRAM PLC_PRG\nVAR\n cbFlower : COLOR_BASIC;\n cbTree: COLOR_BASIC := COLOR_BASIC.green;\nEND_VAR 变量 cbFlower 初始化为 COLOR_BASIC.yellow 。这是所有类型枚举变量的默认初始化 COLOR_BASIC 。由于枚举声明未指定要初始化的成员，因此系统会自动使用值为 0 的成员进行初始化。这通常是第一个枚举成员。但是，它也可以是另一个不在第一个位置但显式初始化为 0 的成员 变量 cbTree 具有明确的初始化。 如果没有为类型和变量指定任何值，则适用以下规则：如果枚举包含 0 的值，则该值是默认初始化，如果没有，则为列表中的第一个成员。 示例 使用 0 成员进行初始化 TYPE ENUM :\n(\n e1 := 2,\n e2 := 0,\n e3\n)\n;\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n e : ENUM;\nEND_VAR 变量 e 初始化为 ENUM.e2 。 使用第一个成员进行初始化 TYPE ENUM2 :\n(\n e1 := 3,\n e2 := 1,\n e3\n)\n;\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n e2 : ENUM2;\nEND_VAR 变量 e2 初始化为 ENUM.e1 。 " }, 
{ "title" : "对枚举成员的唯一访问权限 ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_fb7c51f31efde45ac0a864636cadf959", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 枚举 \/ 对枚举成员的唯一访问权限 ", 
"snippet" : "IEC 61131-3 标准的扩展 枚举成员也可以作为常量变量使用，标识符为 <enumeration name>.<member name>  。枚举成员在项目中全局识别，且访问方式唯一。因此，一个成员名称可以在不同的枚举中使用。 示例 会员： blue PROGRAM PLC_PRG VAR cbFlower : COLOR_BASIC; colorCar : COLOR; END_VAR (* unambiguous identifiers although the component names are identical *) cbFlower := COLOR_BASIC.blue...", 
"body" : "IEC 61131-3 标准的扩展 枚举成员也可以作为常量变量使用，标识符为 <enumeration name>.<member name>  。枚举成员在项目中全局识别，且访问方式唯一。因此，一个成员名称可以在不同的枚举中使用。 示例 会员： blue PROGRAM PLC_PRG\nVAR\n cbFlower : COLOR_BASIC;\n colorCar : COLOR;\nEND_VAR\n\n(* unambiguous identifiers although the component names are identical *)\ncbFlower := COLOR_BASIC.blue;\ncolorCar := COLOR.blue;\n\n(* invalid code *)\ncbFlower := blue;\ncolorCar := blue; 有关更多信息，请参阅： 枚举命名空间。 " }, 
{ "title" : "数据类型：隐式枚举 ", 
"url" : "_cds_datatype_implicit_enumeration-1853150.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 数据类型：隐式枚举 ", 
"snippet" : "隐式枚举 隐式枚举允许一种简单的方法来声明仅在本地 POU 中有效的新枚举变量。这种类型的变量可以采用在组件列表中声明的有限数量的整数值。 隐式枚举没有数据类型名称或标识符。 宣言 : <variable name> : ( <list of component names> ) := <initialization>; <list of component names> 具有所需数量组件的逗号分隔组件名称列表 每个分量代表一个整数值，从 0 开始。后面的分量的值每次递增 1。 例子： Alfa, Bravo, Charlie, Delta, Echo 也可以将固定值分配给组件。 例子： Ze...", 
"body" : "隐式枚举 隐式枚举允许一种简单的方法来声明仅在本地 POU 中有效的新枚举变量。这种类型的变量可以采用在组件列表中声明的有限数量的整数值。 隐式枚举没有数据类型名称或标识符。 宣言 : <variable name> : ( <list of component names> ) := <initialization>; <list of component names> 具有所需数量组件的逗号分隔组件名称列表 每个分量代表一个整数值，从 0 开始。后面的分量的值每次递增 1。 例子： Alfa, Bravo, Charlie, Delta, Echo 也可以将固定值分配给组件。 例子： Zero, Alfa:=10, Bravo:=20, Charlie:=30, Delta:=40, Echo <initialization> 选修的 初始化值，通常是一个组件 称呼 : 例子 PROGRAM PLC_PRG\nVAR\n iAlphabet : (Alfa, Bravo, Charlie, Delta, Echo) := Echo;\n strText : STRING;\n iNumber : INT;\nEND_VAR CASE iAlphabet OF\n\tAlfa:\n\tstrText := 'A';\n\t\n\tBravo: \n\tstrText := 'B';\n\t\n\tCharlie:\n\tstrText := 'C';\n\t\n\tDelta:\n\tstrText := 'D';\n\t\n\tEcho:\n\tstrText := 'E';\nEND_CASE\niNumber := iAlphabet; " }, 
{ "title" : "内部数据类型 ", 
"url" : "_cds_datatype_implicit_enumeration-1853150.html#UUID-b7c570d8-99e1-924b-7984-9849eebb5a31_section-idm4597855524900833552049065596", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 数据类型：隐式枚举 \/ 内部数据类型 ", 
"snippet" : "使用隐式枚举，在内部创建一个数据类型，其名称遵循以下方案： IMPLICIT_ENUM_ <POU name> _ <variable name> 但是，您不应使用此内部标识符，因为内部标识符始终有可能不同。...", 
"body" : "使用隐式枚举，在内部创建一个数据类型，其名称遵循以下方案： IMPLICIT_ENUM_ <POU name> _ <variable name> 但是，您不应使用此内部标识符，因为内部标识符始终有可能不同。 " }, 
{ "title" : "Alias ", 
"url" : "_cds_datatype_alias.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ Alias ", 
"snippet" : "数据类型别名是用户定义数据类型的声明，用于生成基本类型、数据类型或功能块的替代名称。 你在 a 中声明别名的类型 DUT 你在中创建的对象 项目 → 添加对象 → DUT 菜单或应用程序的快捷菜单中。 有关更多信息，请参阅： DUT...", 
"body" : "searchresult_toplevel 数据类型别名是用户定义数据类型的声明，用于生成基本类型、数据类型或功能块的替代名称。 你在 a 中声明别名的类型 DUT 你在中创建的对象 项目 → 添加对象 → DUT 菜单或应用程序的快捷菜单中。 有关更多信息，请参阅： DUT" }, 
{ "title" : "语法 ", 
"url" : "_cds_datatype_alias.html#UUID-01335fef-6db0-3bdd-bc29-f0b6e4b38b03_section-idm234801418271509", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ Alias \/ 语法 ", 
"snippet" : "TYPE <identifier> : <data type name> ; END_TYPE 允许的类型 <type name> 基本数据类型 具有指定大小的数据类型 功能块 示例 类型变量的别名数据类型 STRING 或者 ARRAY 如果需要特定的长度 声明 TYPE FRAME : ARRAY[0..1499] OF BYTE; END_TYPE TYPE SYMBOL : STRING(512); END_TYPE 打电话 PROGRAM PLC_PRG VAR frameF : FRAME; symbolS : SYMBOL; END_VAR 示例 需要与编译器提供的初始值不同的初...", 
"body" : "TYPE <identifier> : <data type name> ; END_TYPE 允许的类型 <type name> 基本数据类型 具有指定大小的数据类型 功能块 示例 类型变量的别名数据类型 STRING 或者 ARRAY 如果需要特定的长度 声明 TYPE FRAME : ARRAY[0..1499] OF BYTE; END_TYPE\nTYPE SYMBOL : STRING(512); END_TYPE 打电话 PROGRAM PLC_PRG\nVAR\n\tframeF : FRAME;\n\tsymbolS : SYMBOL;\nEND_VAR 示例 需要与编译器提供的初始值不同的初始值的变量的别名数据类型 TYPE INDEX : DINT := -1; END_TYPE 示例 特定类型变量的别名数据类型，应仅应用原始类型值的特定子集 {attribute 'qualified_only'}\nVAR_GLOBAL CONSTANT\n\tc_diMaxRune : DINT := DINT#16#0010FFFF;\nEND_VAR TYPE RUNE : DINT(0..GVL.c_diMaxRune); END_TYPE 示例 来自其他命名空间的类型的别名数据类型 例如，对于来自下级库的类型，该类型应该在当前命名空间中可用。 TYPE ENCODING: SBB.ENCODING; END_TYPE (*ENUM*)\nTYPE RUNE : UTF8.RUNE; END_TYPE (*SUBTYPE*)\nTYPE INFO : STR.IFNFO; END_TYPE (*STRUCT*)\nTYPE IBuilder : SBB.IBuilder; END_TYPE (*INTERFACE*)\nTYPE Tange: SBB.Range; END_TYPE (*FUNCTION_BLOCK*) 这意味着在许多情况下，可以省略容器库，因为所有类型的从属库都会以这种方式成为其自己的库的一部分。 " }, 
{ "title" : "数据结构： UNION ", 
"url" : "_cds_datatype_union.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 数据结构： UNION ", 
"snippet" : "UNION UNION 是用户定义的数据结构，其成员通常具有不同的数据类型和大小。 实例的成员 UNION 所有数据类型都保留相同的内存空间。所有成员具有相同的地址偏移量并共享内存。内存需求由最大的成员决定。 A UNION 变量存储的恰好是一个成员的值。内存包含上次分配的值。这意味着内存得到有效利用。 有关更多信息，请参阅：对象： DUT...", 
"body" : "UNION UNION 是用户定义的数据结构，其成员通常具有不同的数据类型和大小。 实例的成员 UNION 所有数据类型都保留相同的内存空间。所有成员具有相同的地址偏移量并共享内存。内存需求由最大的成员决定。 A UNION 变量存储的恰好是一个成员的值。内存包含上次分配的值。这意味着内存得到有效利用。 有关更多信息，请参阅：对象： DUT" }, 
{ "title" : "类型声明 ", 
"url" : "_cds_datatype_union.html#UUID-77065fbb-1927-c31d-6119-69d4ab77180a_section-idm234800958617735", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 数据结构： UNION \/ 类型声明 ", 
"snippet" : "语法： TYPE <identifier> UNION    <member name> : <data type> := <initialization> ; END_UNION END_TYPE <member name> : <data type> ; 声明基本数据类型的成员 随后可以发表任意数量的声明，但至少 2 个。 := <initialization> 可选 示例 类型声明： U_VAR_12 TYPE U_VAR_12: UNION wVar1: WORD; byVar2 : BYTE; END_UNION END_TYPE 类型声明： U_INT_ID TYPE U_INT_...", 
"body" : "语法： TYPE <identifier> UNION    <member name> : <data type> := <initialization> ; END_UNION END_TYPE <member name> : <data type> ; 声明基本数据类型的成员 随后可以发表任意数量的声明，但至少 2 个。 := <initialization> 可选 示例 类型声明： U_VAR_12 TYPE U_VAR_12:\nUNION\n wVar1: WORD;\n byVar2 : BYTE;\nEND_UNION\nEND_TYPE 类型声明： U_INT_ID TYPE U_INT_ID:\nUNION\n iVar: INT;\n dVar : DINT;\nEND_UNION\nEND_TYPE 类型声明： U_EFFICIENT TYPE U_EFFICIENT\nUNION\n wMember : WORD;\n dwMember : DWORD;\n strMember : STRING := 'A'; \nEND_UNION\nEND_TYPE " }, 
{ "title" : "变量声明 ", 
"url" : "_cds_datatype_union.html#UUID-77065fbb-1927-c31d-6119-69d4ab77180a_section-idm234800997913516", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 数据结构： UNION \/ 变量声明 ", 
"snippet" : "a 的变量的实例化\/声明 UNION 数据类型: <variable name> : <name UNION type> := <initialization> ; := <initialization> 可选 := ( <member name> := <literal> ) 初始化详情： 赋值运算符之后是将初始值赋给圆括号中的成员。 示例 TYPE U_AB: UNION lrA : LREAL; liB : LINT; END_UNION END_TYPE 带初始化的变量声明 PLC_PRG PROGRAM VAR uabVAR_1 : U_AB := (lrA := LREAL#1.5...", 
"body" : "a 的变量的实例化\/声明 UNION 数据类型: <variable name> : <name UNION type> := <initialization> ; := <initialization> 可选 := ( <member name> := <literal> ) 初始化详情： 赋值运算符之后是将初始值赋给圆括号中的成员。 示例 TYPE U_AB:\nUNION\n lrA : LREAL;\n liB : LINT;\nEND_UNION\nEND_TYPE 带初始化的变量声明 PLC_PRG PROGRAM\nVAR\n uabVAR_1 : U_AB := (lrA := LREAL#1.5);\n uabVAR_2 : U_AB := (liB := LINT#1);\nEND_VAR 示例 中的变量声明 PLC_PRG 使用数据类型 U_EFFICIENT PLC_PRG PROGRAM\nVAR\n uefficient_1 : U_EFFICIENT := (strMember := 'A');\nEND_VAR\n 实施： PLC_PRG uefficient_1.wMember := 16#000A;\n 什么时候 uefficient_1 写入变量的成员，这会影响变量的所有成员。 " }, 
{ "title" : "子范围类型 ", 
"url" : "_cds_datatype_subint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 用户自定义数据类型：TYPE \/ 子范围类型 ", 
"snippet" : "子范围 子范围类型是一种数据类型，其值范围是基本类型的子集。 声明中的语法： <variabel name> : <integer type> ( <lower index limit> .. <upper index limit> ) <variable name> 有效的 IEC 标识符 有关详细信息，请参阅：规则和建议 标识符名称<integer data type> 子范围的整数基本数据类型 SINT , USINT , INT , UINT , DINT , UDINT , BYTE , WORD , DWORD , LINT , ULINT , LWORD <lower index...", 
"body" : "子范围 子范围类型是一种数据类型，其值范围是基本类型的子集。 声明中的语法： <variabel name> : <integer type> ( <lower index limit> .. <upper index limit> ) <variable name> 有效的 IEC 标识符 有关详细信息，请参阅：规则和建议 标识符名称<integer data type> 子范围的整数基本数据类型 SINT , USINT , INT , UINT , DINT , UDINT , BYTE , WORD , DWORD , LINT , ULINT , LWORD <lower index limit> 必须与基本数据类型兼容的区域下限常量 下限本身包含在此范围内。 <upper index limit> 必须与基本数据类型兼容的区域上限常量 上限也包含在此范围内。 VAR\n i : INT (-4095..4095);\n ui : UINT (0..10000);\nEND_VAR\n 如果您在声明或实现部分中为不在此范围内的子范围类型分配值，则 CODESYS 发出错误消息。 i:=5000 \/\/Results in an error message 注意：在运行模式下，可以通过使用隐式监控功能来监控子范围类型的范围限制 检查范围签名 和 检查范围无符号 . " }, 
{ "title" : "数据类型：__VECTOR ", 
"url" : "_cds_data_type_vector.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR ", 
"snippet" : "__VECTOR 向量运算仅在 64 位处理器上受本机支持，并且仅在这些处理器上提供性能优势。控制器的数据表提供了有关控制器上使用的处理器的信息。 目前，原生支持带有 SSE2 的 x86\/64 位平台和带有 NEON 的 ARM64 上的向量操作。在所有其他平台上，向量操作都被转换为单独的语句。例如，向量加法然后通过多个单一的加法运算来执行。 处理器的命令集扩展是 SIMD 扩展。 SIMD（单指令多数据）描述了一种计算机体系结构，其中相同类型的多个数据集同时并行处理，因此通过一个命令调用速度更快。例如，在向量运算中，可以同时添加 4 对数字。 句法 <variable name> : __...", 
"body" : "__VECTOR 向量运算仅在 64 位处理器上受本机支持，并且仅在这些处理器上提供性能优势。控制器的数据表提供了有关控制器上使用的处理器的信息。 目前，原生支持带有 SSE2 的 x86\/64 位平台和带有 NEON 的 ARM64 上的向量操作。在所有其他平台上，向量操作都被转换为单独的语句。例如，向量加法然后通过多个单一的加法运算来执行。 处理器的命令集扩展是 SIMD 扩展。 SIMD（单指令多数据）描述了一种计算机体系结构，其中相同类型的多个数据集同时并行处理，因此通过一个命令调用速度更快。例如，在向量运算中，可以同时添加 4 对数字。 句法 <variable name> : __VECTOR[ <vector size> ] OF <element type> := <initialization> ;\n\n<vector size> : 1 |2 | 3 | 4 | 5| 6 | 7| 8\n<element type> : REAL | LREAL\n 变量的初始化是可选的。 矢量数据类型是一个浮点数数组，最多包含 8 个元素。这 __vc<operator name> 运算符可用于此数据类型。您可以使用它们来实现向量操作，而无需额外的函数调用。 索引访问的语法 <variable name>[ <index> ]\n<index> : 0 | 1 | 2| 3 | 4 | 5| 6 | 7 索引向量变量时，您可以访问向量的单个元素。索引从 0 开始，一直到 <vector size> - 1。 PROGRAM PLC_PRG\nVAR\n vcA : __VECTOR[3] OF REAL;\nEND_VAR\n\nvcA[0] := 1.1;\nvcA[1] := 2.2;\nvcA[2] := 3.3; " }, 
{ "title" : "确定最佳向量大小 ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-0af01dd3-fba8-5c57-0513-a55c61c26714", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 确定最佳向量大小 ", 
"snippet" : "使用取决于您的目标系统的最佳向量大小作为向量大小，以便编写最有效的代码。 对于计算机架构通常适合向量处理的目标系统，我们不建议使用任意大小的向量。根据处理器的数据处理类型，存在一个最佳向量大小。使用此数组大小声明的向量将被尽快处理。声明为更大数组的向量在速度上没有优势。声明为较小数组的向量没有充分利用处理器的能力。 您可以在运行时查询最佳大小。您可以在常量中找到信息 Constants.vcOptimalREAL （对于带有 REAL 元素）和 Constants.vcOptimalLREAL （对于带有 LREAL 元素）。常数有 LREAL 数据类型。如果常量返回值 1 作为最优值，这意味...", 
"body" : "使用取决于您的目标系统的最佳向量大小作为向量大小，以便编写最有效的代码。 对于计算机架构通常适合向量处理的目标系统，我们不建议使用任意大小的向量。根据处理器的数据处理类型，存在一个最佳向量大小。使用此数组大小声明的向量将被尽快处理。声明为更大数组的向量在速度上没有优势。声明为较小数组的向量没有充分利用处理器的能力。 您可以在运行时查询最佳大小。您可以在常量中找到信息 Constants.vcOptimalREAL （对于带有 REAL 元素）和 Constants.vcOptimalLREAL （对于带有 LREAL 元素）。常数有 LREAL 数据类型。如果常量返回值 1 作为最优值，这意味着加速矢量处理不适用于目标系统。 PROGRAM PLC_PRG\nVAR\n iOVS_REAL : INT; \/\/ Optimal vector size for REAL eleements\n iOVS_LREAL : INT; \/\/ Optimal vector size for LREAL eleements\nEND_VAR\n\niOVS_REAL := Constants.vcOptimalREAL;\niOVS_LREAL := Constants.vcOptimalLREAL; 加载在 CODESYS Control Win V3 x64 目标系统在运行时返回以下值： " }, 
{ "title" : "运算符：__VCADD ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-f39e8b61-1c8e-f75f-fc5c-a2ab4edf25da", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 运算符：__VCADD ", 
"snippet" : "运算符计算两个向量的和。 句法 <vector variable> := <1st vector operand> __VCADD <2nd vector operand>; 添加 FUNCTION_BLOCK FB_ADD VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3); vcResult : __VECTOR[3] OF REAL; END_VAR vcResult := vcA __VCADD vcB;...", 
"body" : "运算符计算两个向量的和。 句法 <vector variable> := <1st vector operand> __VCADD <2nd vector operand>; 添加 FUNCTION_BLOCK FB_ADD\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\n vcResult : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult := vcA __VCADD vcB; " }, 
{ "title" : "运算符：__VCSUB ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-f310d6e4-89f2-14f1-3296-ddf6afcfffcb", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 运算符：__VCSUB ", 
"snippet" : "运算符计算两个向量之间的差异。 句法 <vector variable> := <vector minuend> __VCSUB <vector subtrahend>; 减法 FUNCTION_BLOCK FB_SUB VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3); vcResult0 : __VECTOR[3] OF REAL; vcResult1 : __VECTOR[3] OF REAL; END_VAR vcResul...", 
"body" : "运算符计算两个向量之间的差异。 句法 <vector variable> := <vector minuend> __VCSUB <vector subtrahend>; 减法 FUNCTION_BLOCK FB_SUB\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\n vcResult0 : __VECTOR[3] OF REAL;\n vcResult1 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := vcA __VCSUB vcB;\nvcResult1 := vcB __VCSUB vcA; " }, 
{ "title" : "运算符：__VCMUL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-55d1650e-3133-2368-d000-e3a75e0d705b", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 运算符：__VCMUL ", 
"snippet" : "运算符计算两个向量或一个标量（浮点数）和一个向量的乘积。 句法 <vector variable> := <1st vector operand> __VCMUL <2nd vector operand> | <scalar operand> __VCMUL <vector operand> | <vector operand> __VCMUL <scalar operand> ; 乘法 FUNCTION_BLOCK FB_MUL VAR rScalar : REAL := 1.1; vcA : __VECTOR[3] OF REAL; vcB : __VECTOR[3] OF REAL; v...", 
"body" : "运算符计算两个向量或一个标量（浮点数）和一个向量的乘积。 句法 <vector variable> := <1st vector operand> __VCMUL <2nd vector operand> | <scalar operand> __VCMUL <vector operand> | <vector operand> __VCMUL <scalar operand> ; 乘法 FUNCTION_BLOCK FB_MUL\nVAR\n rScalar : REAL := 1.1;\n vcA : __VECTOR[3] OF REAL;\n vcB : __VECTOR[3] OF REAL;\n vcResult0 : __VECTOR[3] OF REAL;\n vcResult1 : __VECTOR[3] OF REAL;\n vcResult2 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := vcA __VCMUL vcB;\nvcResult1 := rScalar __VCMUL vcB;\nvcResult2 := vcA __VCMUL 3.3; " }, 
{ "title" : "运算符：__VCDIV ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-77b2ab29-e8c3-1279-603e-d874d377ca91", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 运算符：__VCDIV ", 
"snippet" : "运算符计算两个向量或一个向量和一个标量的商。 句法 <vector variable> := <vector dividend> __VCDIV <vector divisor> | < vector dividend> __VCMUL <scalar divisor> ; 分配 FUNCTION_BLOCK FB_DIV VAR iScalar : INT := 3; rScalar : REAL := 1.5; vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_R...", 
"body" : "运算符计算两个向量或一个向量和一个标量的商。 句法 <vector variable> := <vector dividend> __VCDIV <vector divisor> | < vector dividend> __VCMUL <scalar divisor> ; 分配 FUNCTION_BLOCK FB_DIV\nVAR\n iScalar : INT := 3;\n rScalar : REAL := 1.5;\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\n vcResult0 : __VECTOR[3] OF REAL;\n vcResult1 : __VECTOR[3] OF REAL;\n vcResult2 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := vcA __VCDIV vcB;\n\/\/ ERROR CODE vcResult1 := rScalar __VCDIV vcB;\n\/\/ ERROR CODE vcResult1 := iScalar __VCDIV vcB;\n\/\/ ERROR CODE vcResult1 := 3.3 __VCDIV vcB;\nvcResult2 := vcA __VCDIV 1.5;\nvcResult2 := vcA __VCDIV iScalar;\nvcResult2 := vcA __VCDIV rScalar; " }, 
{ "title" : "运算符：__VCDOT ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-fed81759-f085-d6b5-cffb-5e72db7228c4", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 运算符：__VCDOT ", 
"snippet" : "运算符计算两个向量的点积（标量积）。 句法 <skalar variable> := <1st vector operand> __VCDOT <2nd vector operand> ; 点积 FUNCTION_BLOCK FB_DOT VAR rResult : REAL; vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3); END_VAR rResult := vcA __VCDOT vcB; \/\/ = 18...", 
"body" : "运算符计算两个向量的点积（标量积）。 句法 <skalar variable> := <1st vector operand> __VCDOT <2nd vector operand> ; 点积 FUNCTION_BLOCK FB_DOT\nVAR\n rResult : REAL;\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\nEND_VAR\nrResult := vcA __VCDOT vcB; \/\/ = 18 " }, 
{ "title" : "运算符：__VCSQRT ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-45327657-b65b-af06-a4e5-2d3e69420c0f", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 运算符：__VCSQRT ", 
"snippet" : "运算符计算向量中每个元素的平方根。 句法 <vector variable> := __VCSQRT( <vector operand> ); 平方根 FUNCTION_BLOCK FB_SQRT VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(4, 9, 16); vcResult0 : __VECTOR[3] OF REAL; END_VAR vcResult0 := __VCSQRT(vcA);...", 
"body" : "运算符计算向量中每个元素的平方根。 句法 <vector variable> := __VCSQRT( <vector operand> ); 平方根 FUNCTION_BLOCK FB_SQRT\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(4, 9, 16);\n vcResult0 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := __VCSQRT(vcA); " }, 
{ "title" : "运算符：__VCMAX ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-a9f598fc-3f59-dfd8-7e18-b3d2aab0f705", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 运算符：__VCMAX ", 
"snippet" : "运算符计算两个向量的最大向量。最大值是逐个元素确定的。 句法 <vector variable> := __VCMAX( <1st vector operand>, <2nd vector operand>); 最大向量 FUNCTION_BLOCK FB_MAX VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 6); vcResult0 : __VECTOR[3] OF REAL; END_VAR vcResult0 := __VCM...", 
"body" : "运算符计算两个向量的最大向量。最大值是逐个元素确定的。 句法 <vector variable> := __VCMAX( <1st vector operand>, <2nd vector operand>); 最大向量 FUNCTION_BLOCK FB_MAX\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 6);\n vcResult0 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := __VCMAX(vcA, vcB); " }, 
{ "title" : "运算符：__VCMIN ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-39832f61-8b64-561c-96f3-95f93a92e2aa", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 运算符：__VCMIN ", 
"snippet" : "运算符计算两个向量的最小向量。最小值是逐个元素确定的。 句法 <vector variable> := __VCMIN( <1st vector operand>, <2nd vector operand>); 最小向量示例 FUNCTION_BLOCK FB_MIN VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 6); vcResult0 : __VECTOR[3] OF REAL; END_VAR vcResult0 := __V...", 
"body" : "运算符计算两个向量的最小向量。最小值是逐个元素确定的。 句法 <vector variable> := __VCMIN( <1st vector operand>, <2nd vector operand>); 最小向量示例 FUNCTION_BLOCK FB_MIN\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 6);\n vcResult0 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := __VCMIN(vcA, vcB); " }, 
{ "title" : "运算符：__VCSET_REAL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-fded852c-b429-752f-fdaf-5036b3560478", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 运算符：__VCSET_REAL ", 
"snippet" : "运算符在语句中设置向量的所有元素。元素有 REAL 数据类型。 句法 <vector variable> := __VCSET_REAL( <first literal>, ( < next literal> )+ ) ; ( ... )+ \/\/ number of elements have to match FUNCTION_BLOCK FB_SET VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3); END_VAR vcA :...", 
"body" : "运算符在语句中设置向量的所有元素。元素有 REAL 数据类型。 句法 <vector variable> := __VCSET_REAL( <first literal>, ( < next literal> )+ ) ;\n( ... )+ \/\/ number of elements have to match FUNCTION_BLOCK FB_SET\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\nEND_VAR\nvcA := __VCSET_REAL(4, 4, 4);\nvcB := __VCSET_REAL(1.1, 2.2, 3.3); " }, 
{ "title" : "运算符：__VCSET_LREAL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-b7e3f598-67c3-81cc-c496-d773363bb3d7", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 运算符：__VCSET_LREAL ", 
"snippet" : "运算符在语句中一次设置向量的所有元素。元素有 LREAL 数据类型。 它们可以在变量有效的地方使用，例如实现中的赋值或函数调用中的参数。 句法 <vector variable> := __VCSET_LREAL( <first literal>, ( < next literal> )+ ) ; ( ... )+ \/\/ number of elements have to match FUNCTION_BLOCK FB_SET VAR vclA : __VECTOR[3] OF LREAL := __VCSET_LREAL(3, 3, 3); vclB : __VECTOR[3] OF LR...", 
"body" : "运算符在语句中一次设置向量的所有元素。元素有 LREAL 数据类型。 它们可以在变量有效的地方使用，例如实现中的赋值或函数调用中的参数。 句法 <vector variable> := __VCSET_LREAL( <first literal>, ( < next literal> )+ ) ;\n( ... )+ \/\/ number of elements have to match FUNCTION_BLOCK FB_SET\nVAR\n vclA : __VECTOR[3] OF LREAL := __VCSET_LREAL(3, 3, 3);\n vclB : __VECTOR[3] OF LREAL := __VCSET_LREAL(1, 2, 3);\nEND_VAR\nvclA := __VCSET_LREAL(-1.7976931348623158E+308, 0.0, 1.7976931348623158E+308);\nvclB := __VCSET_LREAL(-1.7976931348623158E+308, 0.0, 1.7976931348623158E+308); " }, 
{ "title" : "运算符：__VCLOAD_REAL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-4cdb7360-779e-c920-db0b-dd01f936bfad", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 运算符：__VCLOAD_REAL ", 
"snippet" : "运算符将任意内存区域解释为向量。这有助于将向量变量连接到现有代码。运算符需要 2 个参数。第一个参数表示向量元素的数量。第二个参数是指向 REAL 数据。 __VCLOAD_REAL(<n>,<ptr>) 读 <n> 连续的 REAL 值 <ptr> 地址。如果少于 <n> 值，那么这可能导致控制器崩溃或读取不需要的内存。 句法 <vector variable> := __VCLOAD_REAL( <vector size>, <pointer to data of type REAL> ) ; <vector size> : 2 | 3 | 4 | 5| 6 | 7| 8 矢量化 FUNC...", 
"body" : "运算符将任意内存区域解释为向量。这有助于将向量变量连接到现有代码。运算符需要 2 个参数。第一个参数表示向量元素的数量。第二个参数是指向 REAL 数据。 __VCLOAD_REAL(<n>,<ptr>) 读 <n> 连续的 REAL 值 <ptr> 地址。如果少于 <n> 值，那么这可能导致控制器崩溃或读取不需要的内存。 句法 <vector variable> := __VCLOAD_REAL( <vector size>, <pointer to data of type REAL> ) ;\n<vector size> : 2 | 3 | 4 | 5| 6 | 7| 8 矢量化 FUNCTION_BLOCK FB_LOAD\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n rData : ARRAY[0..2] OF REAL := [1.234, 5.678, 9.123];\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\nEND_VAR\n\nvcA := __VCLOAD_REAL(3, ADR(rData[0])); " }, 
{ "title" : "运算符：__VCLOAD_LREAL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-0203977d-64f5-da8c-acda-ea013ba688bc", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 运算符：__VCLOAD_LREAL ", 
"snippet" : "运算符将任意内存区域解释为向量。这有助于将向量变量连接到现有代码。运算符需要 2 个参数。第一个参数表示向量元素的数量。第二个参数是指向 LREAL 数据。 __VCLOAD_LREAL (<n>,<ptr>) 读 <n> 在连续的 LREAL 值 <ptr> 地址。如果少于 <n> 值，那么这可能导致控制器崩溃或读取不需要的内存。 句法 <vector variable> := __VCLOAD_LREAL( <vector size>, <pointer to data of type LREAL> ); <number of vector elements> : 1 | 2 | 3 | ...", 
"body" : "运算符将任意内存区域解释为向量。这有助于将向量变量连接到现有代码。运算符需要 2 个参数。第一个参数表示向量元素的数量。第二个参数是指向 LREAL 数据。 __VCLOAD_LREAL (<n>,<ptr>) 读 <n> 在连续的 LREAL 值 <ptr> 地址。如果少于 <n> 值，那么这可能导致控制器崩溃或读取不需要的内存。 句法 <vector variable> := __VCLOAD_LREAL( <vector size>, <pointer to data of type LREAL> );\n<number of vector elements> : 1 | 2 | 3 | 4 | 5| 6 | 7| 8 矢量化 FUNCTION_BLOCK FB_LOAD\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n rData : ARRAY[0..3] OF LREAL := [-1.7976931348623158E+308, 1.6E+308, 1.7E+308, -1.6E+308];\n vcA : __VECTOR[3] OF LREAL := __VCSET_LREAL(1, 2, 3);\nEND_VAR\n\nvcA := __VCLOAD_LREAL(3, ADR(rData[0])); " }, 
{ "title" : "运营商：__VCSTORE ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-883d98ce-208b-793b-46eb-aa5757fa28d1", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：__VECTOR \/ 运营商：__VCSTORE ", 
"snippet" : "运算符将向量的内容保存\/复制到指定的内存地址。元素的数量和类型从向量变量中自动应用。 __VCSTORE(<n>,<ptr>) 写 <n> 在连续值 <ptr> 地址。如果少于 <n> 此地址的值，则这可能导致控制器崩溃或写入不需要的内存。 句法 __VCSTORE( <pointer to data>, <vector variable> ); 保存 FUNCTION_BLOCK FB_STORE VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR rData : ARRAY[0..2] OF REAL := [1, 2, 3]; pData: POINTER ...", 
"body" : "运算符将向量的内容保存\/复制到指定的内存地址。元素的数量和类型从向量变量中自动应用。 __VCSTORE(<n>,<ptr>) 写 <n> 在连续值 <ptr> 地址。如果少于 <n> 此地址的值，则这可能导致控制器崩溃或写入不需要的内存。 句法 __VCSTORE( <pointer to data>, <vector variable> ); 保存 FUNCTION_BLOCK FB_STORE\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n rData : ARRAY[0..2] OF REAL := [1, 2, 3];\n pData: POINTER TO REAL := ADR(rData[0]);\n\n lrData : ARRAY [0..3] OF LREAL := [1, 2, 3, 4];\n plData: POINTER TO LREAL := ADR(lrData[0];\n\n\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL( 1.234, 5.678, 9.123);\n vclA : __VECTOR[4] OF LREAL := __VCSET_LREAL(-1.7976931348623158E+308, 1.6E+308, 1.7E+308, -1.6E+308);\nEND_VAR\n\n__VCSTORE(pData, vcA);\n__VCSTORE(plData, vclA); " }, 
{ "title" : "数据类型：VERSION ", 
"url" : "_cds_datatype_version.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 数据类型 \/ 数据类型：VERSION ", 
"snippet" : "VERSION 这 VERSION 数据类型包含一个结构，其中包含有关项目或库的各种版本信息。如果 自动生成“项目信息” POU 选择权和\/或 自动生成“库信息” POU 选项在项目信息中被激活，那么 GetVersion 与 VERSION 数据类型自动生成 点检装置 视图。可以通过编程方式访问各个结构元素。 类型声明： TYPE VERSION: STRUCT \/\/\/ The major version number. This is typically incremented for significant releases that may include major new feat...", 
"body" : "VERSION 这 VERSION 数据类型包含一个结构，其中包含有关项目或库的各种版本信息。如果 自动生成“项目信息” POU 选择权和\/或 自动生成“库信息” POU 选项在项目信息中被激活，那么 GetVersion 与 VERSION 数据类型自动生成 点检装置 视图。可以通过编程方式访问各个结构元素。 类型声明： TYPE VERSION:\nSTRUCT\n \/\/\/ The major version number. This is typically incremented for significant releases that may include major new features or changes.\n uiMajor : UINT;\n \/\/\/ The minor version number. This is incremented for releases that add smaller features or improvements and may include significant fixes.\n uiMinor : UINT;\n \/\/\/ The service pack number. This is used to indicate updates that usually include bug fixes, performance improvements, and minor feature enhancements.\n uiServicePack : UINT;\n \/\/\/ The patch number. This is incremented for very small changes or bug fixes that do not significantly alter the functionality.\n uiPatch : UINT;\n END_STRUCT\n END_TYPE\n 有关详细信息，请参阅：For more information, see: 创建用于访问项目信息的块的选项" }, 
{ "title" : "编译指示 ", 
"url" : "_cds_struct_reference_pragmas.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 ", 
"snippet" : "Pragma 语句会影响与编译或预编译过程相关的一个或多个变量的属性。为此可以使用各种类别的 pragma。 Pragma 目前仅在文本编辑器中受支持。...", 
"body" : "Pragma 语句会影响与编译或预编译过程相关的一个或多个变量的属性。为此可以使用各种类别的 pragma。 Pragma 目前仅在文本编辑器中受支持。 " }, 
{ "title" : "消息编译指示 ", 
"url" : "_cds_pragma_message.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 消息编译指示 ", 
"snippet" : "消息编译指示生成输出文本，这些文本显示在 消息 编译操作后查看。此外，消息类型 ( 消息 ， 警告 ，或 错误 ) 可以分配。 插入位置：POU 文本编辑器中的单独行或现有行。 4 种类型的消息编译指示 编译指示 代码片段示例 消息类型 {text <literal> } {text 'Hallo Allgäu!'} {text 'Part PLC_PRG has been compiled completely'} 没有类型 输出；定义为字符串字面量 <literal> : Hallo Allgäu! Part PLC_PRG has been compiled completely {in...", 
"body" : "消息编译指示生成输出文本，这些文本显示在 消息 编译操作后查看。此外，消息类型 ( 消息 ， 警告 ，或 错误 ) 可以分配。 插入位置：POU 文本编辑器中的单独行或现有行。 4 种类型的消息编译指示 编译指示 代码片段示例 消息类型 {text <literal> } {text 'Hallo Allgäu!'} {text 'Part PLC_PRG has been compiled completely'} 没有类型 输出；定义为字符串字面量 <literal> : Hallo Allgäu! Part PLC_PRG has been compiled completely {info <literal> } {info 'I01: This is for your information.' } 键入为消息 输出： I01:This is for your information. {warning <literal>} {warning 'W01: This is a warning to you.'} 键入为警告 与属性编译指示不同 'obsolete' ，你可以在本地为当前位置定义这种警告。 警告语用语 {warning <'warning string'>} 仅允许用于 POU、语句和变量等对象。 输出： C0373: W01: This is a warning to you. {error <literal>} {error 'E00: Error has occured.'}\n 键入为错误 输出： E00：出现错误。 在 消息 视图， 错误 ， 警告 ，以及 消息 按钮可用于筛选输出文本。或者你可以使用 下一条消息 和 上一条消息 用于浏览各个消息的命令。 注意 转到来源位置 命令。你可以使用这个命令跳转到源代码中实现编译指示的位置 示例 PROGRAM PLC_PRG\nVAR\n iVar : INT; {info 'Info0: This is for your information.'}\n bVar : BOOL;\n arrTest : ARRAY [0..10] OF INT;\nEND_VAR {text 'Hello Allgäu!'}\n\narrTest[iVar] := arrTest[iVar]+1;\n{warning 'W01: This is a warning'}\niVar := iVar+1;\n{warning 'W02: This is a second warning'}\n\n{text 'Part PLC_PRG has been compiled completely'} 在消息视图中显示： " }, 
{ "title" : "属性编译指示 ", 
"url" : "_cds_f_pragmas_attribute.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 ", 
"snippet" : "属性编译指示影响编译和预编译。它们仅在文本编辑器中受支持。 CODESYS 支持一系列预定义的属性 pragma。此外，您还可以使用用户定义的 pragma，在项目编译之前，您可以借助条件 pragma 进行查询。 属性在声明部分定义。例外：对于没有自己的声明部分的 Action 和 Transition 对象，您可以在实现部分的开头定义属性。 如果您定义自己的属性，请确保它们是唯一的。例如，您可以通过为属性名称添加前缀来执行此操作。设备制造商可以为此使用供应商前缀。...", 
"body" : "属性编译指示影响编译和预编译。它们仅在文本编辑器中受支持。 CODESYS 支持一系列预定义的属性 pragma。此外，您还可以使用用户定义的 pragma，在项目编译之前，您可以借助条件 pragma 进行查询。 属性在声明部分定义。例外：对于没有自己的声明部分的 Action 和 Transition 对象，您可以在实现部分的开头定义属性。 如果您定义自己的属性，请确保它们是唯一的。例如，您可以通过为属性名称添加前缀来执行此操作。设备制造商可以为此使用供应商前缀。 " }, 
{ "title" : "对符号的影响 ", 
"url" : "_cds_pragma_consequences_to_symbols.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 对符号的影响 ", 
"snippet" : "由于属性编译指示，POU 和变量可以改变其相对于符号配置的行为。 有关更多说明，请参阅受影响杂注的帮助页面。 带有属性的编译指示 影响 也可以看看 {attribute 'call_after_global_init_slot' := ' <slot> '} 没有任何 {attribute 'call_after_init'} 没有任何 {attribute 'call_after_online_change_slot' := ' <slot> '} 没有任何 {attribute 'call_before_global_exit_slot' := ' <slot> ' 没有任何 {attri...", 
"body" : "由于属性编译指示，POU 和变量可以改变其相对于符号配置的行为。 有关更多说明，请参阅受影响杂注的帮助页面。 带有属性的编译指示 影响 也可以看看 {attribute 'call_after_global_init_slot' := ' <slot> '} 没有任何 {attribute 'call_after_init'} 没有任何 {attribute 'call_after_online_change_slot' := ' <slot> '} 没有任何 {attribute 'call_before_global_exit_slot' := ' <slot> ' 没有任何 {attribute 'call_on_type_change':= ' comma separated list of referenced function blocks> '} 没有任何 {attribute 'conditionalshow' := ' <some text> '} {attribute 'conditionalshow'} {attribute 'conditionalshow_all_locals' := ' <some text> '} {attribute 'conditionalshow_all_locals'} 装饰变量是隐藏的，因此无法导出。 但是，如果编译库中的源代码文件可用，或者如果 CODESYS 已使用命令行选项启动 conditionalshowsymbols ，那么尽管有编译指示，修饰的变量仍然可见。 conditionalshowconditionalshow_all_locals{attribute 'const_replaced'} {attribute 'const_non_replaced'} 替换的常量在符号配置编辑器中不可用，因此无法导出。 被替换的常数取决于 替换常量 已为所有常量选择编译器选项，以及编译指示是否覆盖单个常量的编译器选项。 const_replaced, const_non_replaced{attribute 'dataflow'} 没有任何 {attribute 'displaymode':= <displaymode> } 不 {attribute 'enable_dynamic_creation'} 没有任何 {attribute 'estimated-stack-usage' := ' <estimated stack size in bytes> '} 没有任何 {attribute 'ExpandFully'} 没有任何 {attribute 'global_init_slot' := '<slot>'} 没有任何 {attribute 'hide'} 变量是隐藏的，因此无法导出。 hide{attribute 'hide_all_locals'} 变量是隐藏的，因此无法导出。 hide_all_locals' {attribute 'initialize_on_call'} 没有任何 {attribute 'init_namespace'} 没有任何 {attribute 'init_on_onlchange' } 没有任何 {attribute 'instance-path'} 没有任何 {attribute 'io_function_block'} {attribute 'io_function_block_mapping'} 没有任何 {attribute 'is_connected' := ' <input variable> '} 没有任何 {attribute 'linkalways'} POU 和库 POU 集成在编译列表中，因此无法导出。 linkalways{attribute 'monitoring' := 'variable'} {attribute 'monitoring' := 'call'} PROPERTY 属性或函数 ( FUNCTION ) 可用作符号。 monitoring{'no_assign' } {'no_assign_warning' } 没有任何 {attribute 'no_check'} 没有任何 {attribute 'no_copy'} 没有任何 {attribute 'no-exit'} 没有任何 {attribute 'no_init'} {attribute 'no-init'} {attribute 'noinit'} 没有任何 {attribute 'no_instance_in_retain'} 没有任何 {attribute 'no_virtual_actions'} 没有任何 {attribute 'pingroup' := ' <group name> '} 没有任何 {attribute 'pin_presentation_order_inputs' := '< input name > '( , <next input name> )* } {attribute 'pin_presentation_order_outputs' := '< output name > '( , <next output name> )* } 没有任何 {attribute 'obsolete' := 'user defined text'} 没有任何 {attribute 'pack_mode' := ' <pack mode value> '} 可能导致故意记忆错位 {attribute 'ProcessValue'} 没有任何 {attribute 'qualified_only'} 没有任何 {attribute 'reflection'} 没有任何 {attribute 'subsequent'} 没有任何 {attribute 'suppress_warning'} 没有任何 suppress_warning{attribute 'symbol' := '<access possibilities>'} 变量导出为符号。 变量仅在符号列表中显示 看法 , 通过属性导出的符号 在符号配置编辑器中选择选项。已使用 pragma 定义的访问权限显示在 属性 柱子。 属性：符号 {attribute 'to_string'} 没有任何 {warning disable <compiler ID> } {warning restore <compiler ID> } 没有任何 " }, 
{ "title" : "自定义属性 ", 
"url" : "_cds_user_defined_attributes.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 自定义属性 ", 
"snippet" : "用户定义的属性是可以应用于 POU、操作、数据类型定义和变量的任何应用程序定义或用户定义的属性。您可以在编译应用程序之前借助条件编译指示查询用户定义的属性。 您可以使用运算符查询具有条件编译指示的用户定义属性 hasattribute . 有关更多信息和示例，请参阅： 条件指令句法： {attribute 'attribute'} POU 和操作 属性 'vision' 功能 乐趣1 {attribute 'vision'} FUNCTION fun1 : INT VAR_INPUT i : INT; END_VAR 变量 'DoCount' 属性为 ivar 多变的： PROGRAM PLC...", 
"body" : "用户定义的属性是可以应用于 POU、操作、数据类型定义和变量的任何应用程序定义或用户定义的属性。您可以在编译应用程序之前借助条件编译指示查询用户定义的属性。 您可以使用运算符查询具有条件编译指示的用户定义属性 hasattribute . 有关更多信息和示例，请参阅： 条件指令句法： {attribute 'attribute'} POU 和操作 属性 'vision' 功能 乐趣1 {attribute 'vision'}\nFUNCTION fun1 : INT\nVAR_INPUT\n i : INT;\nEND_VAR 变量 'DoCount' 属性为 ivar 多变的： PROGRAM PLC_PRG\nVAR\n {attribute 'DoCount'};\n ivar:INT;\n bvar:BOOL;\nEND_VAR 数据类型 属性 'aType' 对于数据类型 DUT_1 ： {attribute 'aType'}\nTYPE DUT_1 :\nSTRUCT\n a:INT;\n b:BOOL;\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "属性：call_after_global_init_slot ", 
"url" : "_cds_pragma_attribute_call_after_global_init_slot.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：call_after_global_init_slot ", 
"snippet" : "call_after_global_init_slot VAR_INPUT 使用该属性的函数或方法中的声明会导致编译错误。原因：在这种情况下，调用时输入变量是未知的，这在在线更改期间隐式发生。 这个 pragma 的效果是所有以这种方式修饰的函数和程序都在全局初始化之后被调用。您通过属性值定义调用顺序。 如果在方法中设置了属性，则确定父功能块的所有实例。在指定的槽中调用所有实例。在这种情况下，您对实例之间的顺序没有影响。 句法 ： {attribute 'call_after_global_init_slot' := '<slot>'} 插入位置 函数和程序声明部分上方的第一行 <slot> ...", 
"body" : "call_after_global_init_slot VAR_INPUT 使用该属性的函数或方法中的声明会导致编译错误。原因：在这种情况下，调用时输入变量是未知的，这在在线更改期间隐式发生。 这个 pragma 的效果是所有以这种方式修饰的函数和程序都在全局初始化之后被调用。您通过属性值定义调用顺序。 如果在方法中设置了属性，则确定父功能块的所有实例。在指定的槽中调用所有实例。在这种情况下，您对实例之间的顺序没有影响。 句法 ： {attribute 'call_after_global_init_slot' := '<slot>'} 插入位置 函数和程序声明部分上方的第一行 <slot> 定义按调用顺序排列的整数值 值越低，调用越早。如果几个功能块的属性排名相同，则它们的调用顺序保持不确定。 有关更多信息，请参阅： Global Init Slots" }, 
{ "title" : "属性：call_after_init ", 
"url" : "_cds_pragma_attribute_call_after_init.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：call_after_init ", 
"snippet" : "call_after_init VAR_INPUT 使用此属性的函数或方法中的声明会导致编译错误。原因：在这种情况下，调用时输入变量是未知的，这在在线更改期间隐式发生。 编译器版本 3.4.1.0 支持此功能。 此 pragma 的效果是在功能块实例初始化后隐式调用方法。出于性能原因，您必须在声明部分上方的第一行中将属性添加到功能块和方法中。 具有此 pragma 的方法在 FB_Init 方法和初始化表达式的变量值在实例声明中有效之后。 句法 ： {attribute 'call_after_init'} 调用：方法和功能块声明部分上方的第一行 例子 定义 {attribute 'call_...", 
"body" : "call_after_init VAR_INPUT 使用此属性的函数或方法中的声明会导致编译错误。原因：在这种情况下，调用时输入变量是未知的，这在在线更改期间隐式发生。 编译器版本 3.4.1.0 支持此功能。 此 pragma 的效果是在功能块实例初始化后隐式调用方法。出于性能原因，您必须在声明部分上方的第一行中将属性添加到功能块和方法中。 具有此 pragma 的方法在 FB_Init 方法和初始化表达式的变量值在实例声明中有效之后。 句法 ： {attribute 'call_after_init'} 调用：方法和功能块声明部分上方的第一行 例子 定义 {attribute 'call_after_init'}\nFUNCTION_BLOCK FB_DoIt\n... <functionblock definition>\n\n{attribute 'call_after_init'}\nMETHOD FB_AfterInit\n... <method definition> 该声明在后续代码处理中实现如下声明： fbDoIt : FB_DoIt := (in1 := 99); 代码处理 fbDoIt.FB_Init();\nfbDoIt.in1 := 99;\nfbDoIt.FB_AfterInit(); 这允许对用户定义的初始化做出反应 FB_AfterInit . " }, 
{ "title" : "属性：call_after_online_change_slot ", 
"url" : "_cds_pragma_attribute_call_after_online_change_slot.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：call_after_online_change_slot ", 
"snippet" : "call_after_online_change_slot VAR_INPUT 使用该属性的函数或方法中的声明会导致编译错误。原因是在这种情况下，调用时输入变量在这种情况下是未知的，这在在线更改期间隐式发生。 由于在线更改期间应用程序无法运行，因此在这种情况下执行的每个代码都会导致抖动。因此，执行代码的范围尽可能小。 这个 pragma 的效果是所有设置了这个属性的函数和程序都在在线更改后被调用。您通过属性定义调用顺序 <slot> . 如果在方法中设置了属性，则确定父功能块的所有实例。在指定的槽中调用所有实例。在这种情况下，您无法影响实例之间的顺序。 句法 ： {attribute 'cal...", 
"body" : "call_after_online_change_slot VAR_INPUT 使用该属性的函数或方法中的声明会导致编译错误。原因是在这种情况下，调用时输入变量在这种情况下是未知的，这在在线更改期间隐式发生。 由于在线更改期间应用程序无法运行，因此在这种情况下执行的每个代码都会导致抖动。因此，执行代码的范围尽可能小。 这个 pragma 的效果是所有设置了这个属性的函数和程序都在在线更改后被调用。您通过属性定义调用顺序 <slot> . 如果在方法中设置了属性，则确定父功能块的所有实例。在指定的槽中调用所有实例。在这种情况下，您无法影响实例之间的顺序。 句法 ： {attribute 'call_after_online_change_slot' := '<slot>'} 插入位置 函数和程序声明部分上方的第一行 <slot> 定义按调用顺序排列的整数值；值越低，调用发生的越早。如果几个功能块的属性排名相同，则它们的调用顺序保持不确定。 " }, 
{ "title" : "属性：call_before_global_exit_slot ", 
"url" : "_cds_pragma_attribute_call_before_global_exit_slot.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：call_before_global_exit_slot ", 
"snippet" : "call_before_global_exit_slot VAR_INPUT 使用该属性的函数或方法中的声明会导致编译错误。原因：在这种情况下，调用时输入变量是未知的，这在在线更改期间隐式发生。 这个 pragma 的效果是所有设置了这个属性的函数和程序都在 GlobalExit . GlobalExit 发生在新下载或重置之前。提供的功能块 FB_Exit 方法受到影响。调用顺序由属性值定义。 如果在方法中设置了属性，则确定父功能块的所有实例。在指定的槽中调用所有实例。在这种情况下，您无法影响实例之间的顺序。 句法 ： {attribute 'call_before_global_exit_...", 
"body" : "call_before_global_exit_slot VAR_INPUT 使用该属性的函数或方法中的声明会导致编译错误。原因：在这种情况下，调用时输入变量是未知的，这在在线更改期间隐式发生。 这个 pragma 的效果是所有设置了这个属性的函数和程序都在 GlobalExit . GlobalExit 发生在新下载或重置之前。提供的功能块 FB_Exit 方法受到影响。调用顺序由属性值定义。 如果在方法中设置了属性，则确定父功能块的所有实例。在指定的槽中调用所有实例。在这种情况下，您无法影响实例之间的顺序。 句法 ： {attribute 'call_before_global_exit_slot' := '<slot>'} 插入位置 函数和程序声明部分上方的第一行 <slot> 定义按调用顺序排列的整数值；值越低，调用发生的越早。如果几个功能块的属性排名相同，则它们的调用顺序保持不确定。 " }, 
{ "title" : "属性：call_on_type_change ", 
"url" : "_cds_pragma_attribute_call_on_type_change.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：call_on_type_change ", 
"snippet" : "call_on_type_change 这个 pragma 的效果是，如果在上级功能块中引用的功能块的数据类型发生变化，则调用修饰的方法。引用可以由指针变量或 REFERENCE TO 多变的。 句法 ： {attribute 'call_on_type_change' := ' <comma-separated names of the referenced function modules> '} 插入位置：方法声明中第一行上方的行 例子 这 FB_A 功能块参考 FB_B 和 FB_C . FUNCTION_BLOCK FB_A VAR var_pt: POINTER TO FB_B; ...", 
"body" : "call_on_type_change 这个 pragma 的效果是，如果在上级功能块中引用的功能块的数据类型发生变化，则调用修饰的方法。引用可以由指针变量或 REFERENCE TO 多变的。 句法 ： {attribute 'call_on_type_change' := ' <comma-separated names of the referenced function modules> '} 插入位置：方法声明中第一行上方的行 例子 这 FB_A 功能块参考 FB_B 和 FB_C . FUNCTION_BLOCK FB_A\nVAR\n var_pt: POINTER TO FB_B;\n var_ref: REFERENCE TO FB_C;\nEND_VAR\n... 这 METH_react_on_type_change 当 FB_B 或 FB_C 的数据类型改变时调用方法。 {attribute 'call_on_type_change' := 'FB_B, FB_C'}\nMETHOD METH_react_on_type_change : INT\nVAR_INPUT\n... " }, 
{ "title" : "属性：conditionalshow ", 
"url" : "_cds_pragma_attribute_conditionalshow.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：conditionalshow ", 
"snippet" : "conditionalshow 编译指示的效果是集成编译库的标识符 <library name>.compiled-library ，用 pragma 修饰，在编写应用程序之前被隐藏。可以调用 POU，但变量在 CODESYS 用户界面。 受影响的功能 图书馆管理 调试 输入助手 “列出组件”功能 监控 符号配置 这在您开发库时很有用。作为库开发人员，您可以使用 pragma 修饰功能块或变量。因此，您可以确定哪些标识符在集成后隐藏在应用程序中。如果您想稍后显示隐藏的标识符，例如为了调试或进一步开发库，您可以重新激活它的可见性。 句法 {attribute 'conditionalshow' ...", 
"body" : "conditionalshow 编译指示的效果是集成编译库的标识符 <library name>.compiled-library ，用 pragma 修饰，在编写应用程序之前被隐藏。可以调用 POU，但变量在 CODESYS 用户界面。 受影响的功能 图书馆管理 调试 输入助手 “列出组件”功能 监控 符号配置 这在您开发库时很有用。作为库开发人员，您可以使用 pragma 修饰功能块或变量。因此，您可以确定哪些标识符在集成后隐藏在应用程序中。如果您想稍后显示隐藏的标识符，例如为了调试或进一步开发库，您可以重新激活它的可见性。 句法 {attribute 'conditionalshow' := ' <some text> '} 插入位置：功能块声明部分的顶行，变量上方 插入位置 函数和程序声明部分上方的第一行 <some text> 选修的 字符串文字，用于通过命令行命令和此文字来控制用这种 pragma 修饰的标识符的可见性 如果在没有文字的情况下指定 pragma，则 CODESYS 开发环境总是隐藏的，无论如何 CODESYS 开始了。 有关这方面的更多帮助，请参阅“库开发摘要”文档。 例子 例如，请参阅“库开发总结”文档。 隐藏变量 FUNCTION_BLOCK FB_DataManager\nVAR\n {attribute 'conditionalshow' := 'Library_Developer'}\n iLocal : INT;\n iCounter : INT;\nEND_VAR 变量 iLocal 是不可见的。 隐藏功能块 {attribute 'conditionalshow' := 'Library_Developer'}\nFUNCTION_BLOCK FB_DataManager\nVAR\n iLocal : INT;\n iCounter : INT;\nEND_VAR 标识符 FB_DataManager , iLocal ， 和 iCounter 是不可见的。 " }, 
{ "title" : "现有源代码文件的可见性 ", 
"url" : "_cds_pragma_attribute_conditionalshow.html#UUID-c2eaf3e2-3d4a-2ddd-b40f-5c12f68a8748_id_a67a86e4255dcc0a8646343179ebe_id_f83478949a10c1e9c0a864630e28568a", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：conditionalshow \/ 现有源代码文件的可见性 ", 
"snippet" : "当源代码文件 <library name>.library 来自集成库的也存在于相同的内存位置（存储库），尽管有编译指示，但标识符是可见的。这与声明中是否指定了属性值无关。...", 
"body" : "当源代码文件 <library name>.library 来自集成库的也存在于相同的内存位置（存储库），尽管有编译指示，但标识符是可见的。这与声明中是否指定了属性值无关。 " }, 
{ "title" : "命令行调用激活可见性 ", 
"url" : "_cds_pragma_attribute_conditionalshow.html#UUID-c2eaf3e2-3d4a-2ddd-b40f-5c12f68a8748_id_a67a86e4255dcc0a8646343179ebe_id_cea44f6f9a10c1e9c0a8646337b3d88a", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：conditionalshow \/ 命令行调用激活可见性 ", 
"snippet" : "您还可以通过启动来启用隐藏变量的可见性而无需源代码文件 CODESYS 使用命令行选项 conditionalshowsymbols .要启用可见性，请指定以逗号分隔的 pragma 的属性值。 句法 codesys.exe --conditionalshowsymbols=\" <some text> ( ,<next text> )* \" 有关更多信息，请参阅： 使用命令行界面codesys.exe --conditionalshowsymbols=\"Library_Developer\" codesys.exe --conditionalshowsymbols=\"Group_A,Group_...", 
"body" : "您还可以通过启动来启用隐藏变量的可见性而无需源代码文件 CODESYS 使用命令行选项 conditionalshowsymbols .要启用可见性，请指定以逗号分隔的 pragma 的属性值。 句法 codesys.exe --conditionalshowsymbols=\" <some text> ( ,<next text> )* \" 有关更多信息，请参阅： 使用命令行界面codesys.exe --conditionalshowsymbols=\"Library_Developer\" codesys.exe --conditionalshowsymbols=\"Group_A,Group_B\" " }, 
{ "title" : "属性对监控和 SmartCoding 的影响 ", 
"url" : "_cds_pragma_attribute_conditionalshow.html#UUID-c2eaf3e2-3d4a-2ddd-b40f-5c12f68a8748_section-idm43395049804922", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：conditionalshow \/ 命令行调用激活可见性 \/ 属性对监控和 SmartCoding 的影响 ", 
"snippet" : "源码库： 行动 属性集 属性未设置 智能编码\/输入助手 方法 可见的 可见的 输入 可见的 不可见 输出 可见的 不可见 监控 输入 可见的 可见的 输出 可见的 可见的 当地的 可见的 可见的 编译库 行动 属性集 属性未设置 智能编码\/输入助手 方法 可见的 可见的 输入 可见的 不可见 输出 可见的 不可见 监控 输入 可见的 不可见 输出 可见的 不可见 当地的 可见的 不可见...", 
"body" : "源码库： 行动 属性集 属性未设置 智能编码\/输入助手 方法 可见的 可见的 输入 可见的 不可见 输出 可见的 不可见 监控 输入 可见的 可见的 输出 可见的 可见的 当地的 可见的 可见的 编译库 行动 属性集 属性未设置 智能编码\/输入助手 方法 可见的 可见的 输入 可见的 不可见 输出 可见的 不可见 监控 输入 可见的 不可见 输出 可见的 不可见 当地的 可见的 不可见 " }, 
{ "title" : "属性：conditionalshow_all_locals ", 
"url" : "_cds_pragma_attribute_conditionalshow_all_locals.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：conditionalshow_all_locals ", 
"snippet" : "conditionalshow_all_locals pragma 的效果是所有 所有本地 用 pragma 修饰的库 POU 的变量对应用程序程序员是隐藏的。集成编译库的 POU <library name>.compiled-library 可以调用，但变量在 Basic Level 用户界面。 影响功能： 图书馆管理 调试 输入助手 “列出组件”功能 监控 符号配置 这在您开发库时很有用。作为库开发人员，您使用 pragma 装饰功能块。因此，您确定它们的标识符在集成后隐藏在应用程序中。如果您想稍后显示这些标识符，例如为了调试或进一步开发库，您可以重新激活它的可见性。 更多信息请参见：“...", 
"body" : "conditionalshow_all_locals pragma 的效果是所有 所有本地 用 pragma 修饰的库 POU 的变量对应用程序程序员是隐藏的。集成编译库的 POU <library name>.compiled-library 可以调用，但变量在 Basic Level 用户界面。 影响功能： 图书馆管理 调试 输入助手 “列出组件”功能 监控 符号配置 这在您开发库时很有用。作为库开发人员，您使用 pragma 装饰功能块。因此，您确定它们的标识符在集成后隐藏在应用程序中。如果您想稍后显示这些标识符，例如为了调试或进一步开发库，您可以重新激活它的可见性。 更多信息请参见：“库开发总结”文档 句法 {attribute 'conditionalshow_all_locals' := ' <some text> ' } 插入位置 功能块声明部分上方的第一行 <some text> 选修的 可选的字符串文字，用于通过命令行命令和此文字来控制用这种 pragma 修饰的标识符的可见性 如果在没有文字的情况下指定 pragma，则 Basic Level 开发环境总是隐藏的，无论如何 Basic Level 开始了。 隐藏所有局部变量 {attribute 'conditionalshow_all_locals' := 'Library_Developer'}\nFUNCTION_BLOCK FB_DataManager\nVAR\n iLocal : INT;\n iCounter : INT;\nEND_VAR 例如，请参阅“库开发总结”文档。 " }, 
{ "title" : "现有源代码文件的可见性 ", 
"url" : "_cds_pragma_attribute_conditionalshow_all_locals.html#UUID-db59833b-7bd9-9489-c20e-ebe370f6ad67_id_a15a9e476e49230dc0a864631ad26c45_id_84ae9f519e37d9d3c0a86463554294a0", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：conditionalshow_all_locals \/ 现有源代码文件的可见性 ", 
"snippet" : "当源代码文件 <library name>.library 来自集成库的也存在于同一内存位置（存储库），尽管有编译指示，库 POU 变量仍然可见。这与声明中是否指定了属性值无关。...", 
"body" : "当源代码文件 <library name>.library 来自集成库的也存在于同一内存位置（存储库），尽管有编译指示，库 POU 变量仍然可见。这与声明中是否指定了属性值无关。 " }, 
{ "title" : "命令行调用激活可见性 ", 
"url" : "_cds_pragma_attribute_conditionalshow_all_locals.html#UUID-db59833b-7bd9-9489-c20e-ebe370f6ad67_id_a15a9e476e49230dc0a864631ad26c45_id_83dd83ba9e37d9d3c0a86463332f087b", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：conditionalshow_all_locals \/ 命令行调用激活可见性 ", 
"snippet" : "您还可以通过启动来启用隐藏变量的可见性而无需源代码文件 Basic Level 使用命令行选项 conditionalshowsymbols .要启用可见性，请指定以逗号分隔的 pragma 的属性值。 句法 codesys.exe --conditionalshowsymbols=\" <some text> ( ,<next text> )* \" 例子 codesys.exe --conditionalshowsymbols=\"Library_Developer\" codesys.exe --conditionalshowsymbols=\"Group_A,Group_B\" 有关更多信息，请参...", 
"body" : "您还可以通过启动来启用隐藏变量的可见性而无需源代码文件 Basic Level 使用命令行选项 conditionalshowsymbols .要启用可见性，请指定以逗号分隔的 pragma 的属性值。 句法 codesys.exe --conditionalshowsymbols=\" <some text> ( ,<next text> )* \" 例子 codesys.exe --conditionalshowsymbols=\"Library_Developer\" codesys.exe --conditionalshowsymbols=\"Group_A,Group_B\" 有关更多信息，请参阅： hide_all_locals, conditionalshow，以及“可见性控制”一章 " }, 
{ "title" : "属性：const_replaced、const_non_replaced ", 
"url" : "_cds_pragma_attribute_const_replaced_non.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：const_replaced、const_non_replaced ", 
"snippet" : "const_replaced, const_non_replaced 这 'const_replaced' 属性具有在代码中替换常量的效果，与 替换常量 编译器选项。该属性仅对标量类型的变量有效，但对数组和结构等复合类型无效。 你插入 pragma {attribute 'const_non_replaced'} 因此，为了明确停用 替换常量 编译器选项。 这具有效果，例如在 符号配置 ，尽管编译器选项，该常量仍然可用并且可以导出。 这 替换常量 中的选项 编译选项 的类别 项目设置 对话框是为整个项目预设的，因为替换常量通常会导致更快的代码和更少的内存使用。 句法 ： {attribute ...", 
"body" : "const_replaced, const_non_replaced 这 'const_replaced' 属性具有在代码中替换常量的效果，与 替换常量 编译器选项。该属性仅对标量类型的变量有效，但对数组和结构等复合类型无效。 你插入 pragma {attribute 'const_non_replaced'} 因此，为了明确停用 替换常量 编译器选项。 这具有效果，例如在 符号配置 ，尽管编译器选项，该常量仍然可用并且可以导出。 这 替换常量 中的选项 编译选项 的类别 项目设置 对话框是为整个项目预设的，因为替换常量通常会导致更快的代码和更少的内存使用。 句法 ： {attribute 'const_replaced'} {attribute 'const_non_replaced'} 插入位置：全局变量声明行上方的行。 例子 常数 iTestCon 和 xTestCon 在符号配置中可用，因为 替换常量 选项停用。 {attribute 'qualified_only'}\nVAR_GLOBAL CONSTANT\n {attribute 'const_non_replaced'}\n iTestCon : INT := 12;\n {attribute 'const_non_replaced'}\n xTestCon : BOOL := TRUE;\n rTestCon : REAL := 1.5;\nEND_VAR\n\nVAR_GLOBAL\n iTestVar : INT := 12;\n xTestVar : BOOL := TRUE;\nEND_VAR " }, 
{ "title" : "属性：dataflow ", 
"url" : "_cds_pragma_attribute_dataflow.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：dataflow ", 
"snippet" : "dataflow 使用此编译指示，您可以控制 FBD\/LD\/IL 编辑器中功能块处理中的数据流。该属性定义与下一个或前一个功能块的连续连接所连接的功能块的输入或输出。 您可以只提供一个输入，而一个输出可以用功能块声明中的属性进行修饰。 对于没有 'dataflow' 属性，数据流是自动确定的：首先，在相同数据类型的输出和输入之间建立连接。始终采用功能块的最高输入或输出变量。如果没有具有匹配数据类型的变量，则顶部输出连接到下一个 POU 的顶部输入。 句法 ： {attribute 'dataflow'} 插入位置 在声明相应变量的行上方的行 'dataflow' 标识连接到前一个或下一个 PO...", 
"body" : "dataflow 使用此编译指示，您可以控制 FBD\/LD\/IL 编辑器中功能块处理中的数据流。该属性定义与下一个或前一个功能块的连续连接所连接的功能块的输入或输出。 您可以只提供一个输入，而一个输出可以用功能块声明中的属性进行修饰。 对于没有 'dataflow' 属性，数据流是自动确定的：首先，在相同数据类型的输出和输入之间建立连接。始终采用功能块的最高输入或输出变量。如果没有具有匹配数据类型的变量，则顶部输出连接到下一个 POU 的顶部输入。 句法 ： {attribute 'dataflow'} 插入位置 在声明相应变量的行上方的行 'dataflow' 标识连接到前一个或下一个 POU 的功能块的输入或输出 这 FB 和前一个功能块使用输入变量连接 i1 .之间的联系 FB 并通过输出变量建立以下功能块 outRes1 . FUNCTION_BLOCK FB\nVAR_INPUT\n r1 : REAL;\n {attribute 'dataflow'}\n i1 : INT;\n i2 : INT;\n r2 : REAL;\nEND_VAR\n\nVAR_OUTPUT\n {attribute 'dataflow'}\n outRes1 : REAL;\n out1 : INT;\n g1 : INT;\n g2 : REAL;\nEND_VAR " }, 
{ "title" : "属性：displaymode ", 
"url" : "_cds_pragma_attribute_displaymode.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：displaymode ", 
"snippet" : "displaymode 编译指示定义单个变量的显示模式。该定义覆盖了监视变量显示的全局设置，该设置通过以下命令进行： 表示 - 二进制、十进制和十六进制 菜单 句法 ： {attribute 'displaymode':= <display mode> } 以下定义是可能的 二进制格式 {attribute 'displaymode':='bin'} {attribute 'displaymode':='binary'} 十进制格式 {attribute 'displaymode':='dec'} {attribute 'displaymode':='decimal'} 十六进制格式 {att...", 
"body" : "displaymode 编译指示定义单个变量的显示模式。该定义覆盖了监视变量显示的全局设置，该设置通过以下命令进行： 表示 - 二进制、十进制和十六进制 菜单 句法 ： {attribute 'displaymode':= <display mode> } 以下定义是可能的 二进制格式 {attribute 'displaymode':='bin'} {attribute 'displaymode':='binary'} 十进制格式 {attribute 'displaymode':='dec'} {attribute 'displaymode':='decimal'} 十六进制格式 {attribute 'displaymode':='hex'} {attribute 'displaymode':='hexadecimal'} 插入位置：声明相应变量的行上方的行。 例子 VAR\n {attribute 'displaymode':='hex'}\n dwVar1: DWORD;\nEND_VAR " }, 
{ "title" : "属性：enable_dynamic_creation ", 
"url" : "_cds_pragma_attribute_enable_dynamic_creation.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：enable_dynamic_creation ", 
"snippet" : "enable_dynamic_creation 这 enable_dynamic_creation 需要编译指示才能使用 __NEW 在功能块的情况下。 句法 ： {attribute 'enable_dynamic_creation'} 插入位置：功能块声明中的第一行。...", 
"body" : "enable_dynamic_creation 这 enable_dynamic_creation 需要编译指示才能使用 __NEW 在功能块的情况下。 句法 ： {attribute 'enable_dynamic_creation'} 插入位置：功能块声明中的第一行。 " }, 
{ "title" : "属性：estimated-stack-usage ", 
"url" : "_cds_pragma_attribute_estimated_stack_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：estimated-stack-usage ", 
"snippet" : "estimated-stack-usage pragma 提供了堆栈大小要求的估计值。 具有递归调用的方法无法通过堆栈检查，因为无法确定堆栈使用情况。结果，发出警告。为防止出现此警告，您可以为该方法提供堆栈大小要求的估计值（以字节为单位）。然后该方法成功通过堆栈检查。 句法 {attribute 'estimated-stack-usage' := ' <estimated stack size in bytes> '} 插入位置：方法声明部分上方的第一行。 例子 {attribute 'estimated-stack-usage' := '127'} \/\/ 127 bytes METHOD ...", 
"body" : "estimated-stack-usage pragma 提供了堆栈大小要求的估计值。 具有递归调用的方法无法通过堆栈检查，因为无法确定堆栈使用情况。结果，发出警告。为防止出现此警告，您可以为该方法提供堆栈大小要求的估计值（以字节为单位）。然后该方法成功通过堆栈检查。 句法 {attribute 'estimated-stack-usage' := ' <estimated stack size in bytes> '} 插入位置：方法声明部分上方的第一行。 例子 {attribute 'estimated-stack-usage' := '127'} \/\/ 127 bytes\nMETHOD PUBLIC DoIt : BOOL\nVAR_INPUT\nEND_VAR 有关更多信息，请参阅： 方法调用" }, 
{ "title" : "递归方法调用 ", 
"url" : "_cds_pragma_attribute_estimated_stack_usage.html#UUID-4670b30e-eb2d-1ea9-9d6e-61159df75c79_id_dd29a4d911bcf410c0a8640e01471f60_id_918a5ded942a17e2c0a8646316297a73", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：estimated-stack-usage \/ 递归方法调用 ", 
"snippet" : "在其实现中，方法可以调用自身，或者直接通过 THIS 指针，或通过分配功能块的局部变量。 使用递归主要用于处理递归数据类型，例如链表。一般来说，我们建议在使用递归时要小心，因为意外的深度递归会导致堆栈溢出和机器停机。 阶乘的计算 以下程序 PLC_PRG 计算一个数的阶乘 FB_Factorial 功能块以不同的方式，每个都有自己的方法。 方法 m_Iterative : 迭代 方法 m_Pragmaed : 带有警告抑制的递归 方法 m_Recursive : 递归 方法 m_Temp : 暂时带有警告抑制 发出警告 m_Recursive 方法而已。 \/\/ Contains the dat...", 
"body" : "在其实现中，方法可以调用自身，或者直接通过 THIS 指针，或通过分配功能块的局部变量。 使用递归主要用于处理递归数据类型，例如链表。一般来说，我们建议在使用递归时要小心，因为意外的深度递归会导致堆栈溢出和机器停机。 阶乘的计算 以下程序 PLC_PRG 计算一个数的阶乘 FB_Factorial 功能块以不同的方式，每个都有自己的方法。 方法 m_Iterative : 迭代 方法 m_Pragmaed : 带有警告抑制的递归 方法 m_Recursive : 递归 方法 m_Temp : 暂时带有警告抑制 发出警告 m_Recursive 方法而已。 \/\/ Contains the data of the factorial calculation of uiNumber\nTYPE FACTORIAL_RESULT :\nSTRUCT\n uiNumber : UINT;\n udiIterative : UDINT;\n udiRecursive : UDINT;\n udiPragmaed : UDINT;\n udiTemp : UDINT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n fb_Factorial_A : FB_Factorial;\n factorial_A : FACTORIAL_RESULT := (uiNumber := 9, udiIterative := 0, udiRecursive := 0, udiPragmaed := 0 );\nEND_VAR\nfb_Factorial_A.p_Number := factorial_A.uiNumber;\nfactorial_A.udiIterative := fb_Factorial_A.m_Iterative();\nfactorial_A.udiRecursive := fb_Factorial_A.m_Recursive(uiN := factorial_A.uiNumber);\nfactorial_A.udiPragmaed := fb_Factorial_A.m_Pragmaed(uiN := factorial_A.uiNumber);\nfactorial_A.udiTemp := fb_Factorial_A.m_Temp(uiN := factorial_A.uiNumber);\n\n\/\/Factorial calculation in different ways\nFUNCTION_BLOCK FB_Factorial\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n uiN : UINT;\n udiIterative : UDINT;\n udiPragmaed : UDINT;\n udiRecursive : UDINT;\nEND_VAR\n\n \/\/ Iterative calculation\n METHOD PUBLIC m_Iterative : UDINT\n VAR\n uiCnt : UINT;\n END_VAR\n m_Iterative := 1;\n IF uiN > 1 THEN\n FOR uiCnt := 1 TO uiN DO\n m_Iterative := m_Iterative * uiCnt;\n END_FOR;\n RETURN;\n ELSE\n RETURN;\n END_IF;\n\n \/\/Recursive calculation with suppressed warning\n {attribute 'estimated-stack-usage' := '99'}\n METHOD PUBLIC m_Pragmaed : UDINT\n VAR_INPUT\n uiN : UINT;\n END_VAR\n VAR\n END_VAR\n m_Pragmaed := 1;\n IF uiN > 1 THEN\n m_Pragmaed := uiN * THIS^.m_Pragmaed(uiN := (uiN - 1));\n RETURN;\n ELSE\n RETURN;\n END_IF;\n \n \/\/Recursive calculation\n METHOD PUBLIC m_Recursive : UDINT\n VAR_INPUT\n uiN : UINT;\n END_VAR\n VAR\n END_VAR\n m_Recursive := 1;\n IF uiN > 1 THEN\n m_Recursive := uiN * THIS^.m_Recursive(uiN := (uiN - 1) );\n RETURN;\n ELSE\n RETURN;\n END_IF;\n \n \/\/ Called by temporary FB instance\n {attribute 'estimated-stack-usage' := '99'}\n METHOD PUBLIC m_Temp : UDINT\n VAR_INPUT\n uiN : UINT;\n END_VAR\n VAR\n fb_Temp : FB_Factorial;\n END_VAR\n m_Temp := 1;\n IF uiN > 1 THEN\n m_Temp := uiN * fb_Temp.m_Temp(uiN := (uiN - 1));\n RETURN;\n ELSE\n RETURN;\n END_IF;\n\nPROPERTY p_Number : UINT\nuiN := p_Number; \/\/Setter method 只有 m_Recursive 程序执行时发出警告。 " }, 
{ "title" : "属性：ExpandFully ", 
"url" : "_cds_pragma_attribute_expandfully.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：ExpandFully ", 
"snippet" : "ExpandFully 此 pragma 的效果是用作引用可视化的输入变量的数组成员在可视化的属性对话框中可见。 句法： {attribute 'ExpandFully'} 插入位置：声明数组的行上方的行。 可视化 视觉 将被插入到可视化内的框架中 visu_main . arr 在界面编辑器中定义为输入变量 视觉 因此稍后可用于在框架的“属性”对话框中进行分配 visu_main . 为了也使各个组件 arr 在此属性对话框中可用，您必须插入 'ExpandFully' 属性直接在前面 arr 在visu的界面编辑器中。在界面编辑器中声明 视觉 ： VAR_INPUT {attribute ...", 
"body" : "ExpandFully 此 pragma 的效果是用作引用可视化的输入变量的数组成员在可视化的属性对话框中可见。 句法： {attribute 'ExpandFully'} 插入位置：声明数组的行上方的行。 可视化 视觉 将被插入到可视化内的框架中 visu_main . arr 在界面编辑器中定义为输入变量 视觉 因此稍后可用于在框架的“属性”对话框中进行分配 visu_main . 为了也使各个组件 arr 在此属性对话框中可用，您必须插入 'ExpandFully' 属性直接在前面 arr 在visu的界面编辑器中。在界面编辑器中声明 视觉 ： VAR_INPUT\n{attribute 'ExpandFully'}\n arr : ARRAY[0..5] OF INT;\nEND_VAR " }, 
{ "title" : "属性：global_init_slot ", 
"url" : "_cds_pragma_attribute_global_init_slot.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：global_init_slot ", 
"snippet" : "global_init_slot pragma 定义了 POU 和全局变量列表的初始化顺序：GVL 或 POU 中的变量从上到下初始化。如果有多个全局变量列表，则不定义初始化顺序。 初始化不适用于字面值的初始化，例如 1 , 'hello' , 3.6 ，或基本数据类型的常量。但是，如果列表之间存在依赖关系，则必须自己定义初始化顺序。您可以将定义的初始化槽分配给 GVL 或 POU 'global_init_slot' 属性。 常量在变量之前初始化，并且与变量的顺序相同。在初始化期间，POU 根据 <slot> 的值进行排序。然后生成初始化常量的代码，然后生成初始化变量的代码。 句法 ： {a...", 
"body" : "global_init_slot pragma 定义了 POU 和全局变量列表的初始化顺序：GVL 或 POU 中的变量从上到下初始化。如果有多个全局变量列表，则不定义初始化顺序。 初始化不适用于字面值的初始化，例如 1 , 'hello' , 3.6 ，或基本数据类型的常量。但是，如果列表之间存在依赖关系，则必须自己定义初始化顺序。您可以将定义的初始化槽分配给 GVL 或 POU 'global_init_slot' 属性。 常量在变量之前初始化，并且与变量的顺序相同。在初始化期间，POU 根据 <slot> 的值进行排序。然后生成初始化常量的代码，然后生成初始化变量的代码。 句法 ： {attribute 'global_init_slot' := '<slot>'} 插入位置 pragma 始终作用于整个 GVL 或 POU，因此它必须位于 VAR_GLOBAL 或 POU 声明。 <slot> 整数值，定义调用顺序中的位置 POU（程序、功能块）的默认值为 50000。GVL 的默认值为 49990。较低的值意味着较早的初始化。 如果为多个 POU 分配了相同的值 'global_init_slot' 属性，则它们的初始化顺序仍未定义。 例子 该项目包括两个全局变量列表 GVL_1 和 GVL_2 ，以及 PLC_PRG 使用两个列表中的变量的程序。 GVL_1 使用变量 B 用于初始化变量 A , 初始化为 GVL_2 和 1000 . GVL_1 VAR_GLOBAL \/\/49990\n A : INT := GVL_2.B*100;\nEND_VAR GVL_2 VAR_GLOBAL \/\/49990\n B : INT := 1000;\n C : INT := 10;\nEND_VAR PLC_PRG PROGRAM PLC_PRG \/\/50000\nVAR\n ivar: INT := GVL_1.A;\n ivar2: INT;\nEND_VAR\n\nivar:=ivar+1;\nivar2:=GVL_2.C; 在这种情况下，编译器会打印一个错误，因为 GVL_2.B 用于初始化 GVL_1.A 前 GVL_2 已初始化。您可以通过使用 global_init_slot 归属于位置 GVL_2 前 GVL_1 在初始化序列中。 在这个例子中， GVL_1 必须至少有一个槽值 49989 才能实现程序内最早的初始化。每个较低的值都具有相同的效果： GVL_2 {attribute 'global_init_slot' := '100'}\nVAR_GLOBAL\n B : INT := 1000;\nEND_VAR 使用 GVL_2.C 在执行部分 PLC_PRG 即使不使用 pragma 也不重要，因为在任何一种情况下，两个 GVL 都在程序之前初始化。 有关更多信息，请参阅： Global Init Slots" }, 
{ "title" : "属性：hide ", 
"url" : "_cds_pragma_attribute_hide.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：hide ", 
"snippet" : "hide 使用编译指示 {attribute 'hide'} 在大多数情况下，隐藏变量和 POU 并不能达到预期的效果。相反，您应该使用 {属性'条件显示'} 。杂注。 pragma 防止用它定义的变量和 POU 显示在 CODESYS 用户界面。因此，您可以有意隐藏这些标识符而不限制访问。这在您开发库时很有用。 影响功能： 图书馆管理 调试 输入助手 “列出组件”功能 监控 符号配置 用 pragma 定义的变量或 POU 在库管理器中既不可见，也不建议在输入助手或“列出组件”功能中。 pragma 防止那些修饰的变量显示在符号配置中。因此，您无法将这些类型的变量导出为符号。这些变量在在线模...", 
"body" : "hide 使用编译指示 {attribute 'hide'} 在大多数情况下，隐藏变量和 POU 并不能达到预期的效果。相反，您应该使用 {属性'条件显示'} 。杂注。 pragma 防止用它定义的变量和 POU 显示在 CODESYS 用户界面。因此，您可以有意隐藏这些标识符而不限制访问。这在您开发库时很有用。 影响功能： 图书馆管理 调试 输入助手 “列出组件”功能 监控 符号配置 用 pragma 定义的变量或 POU 在库管理器中既不可见，也不建议在输入助手或“列出组件”功能中。 pragma 防止那些修饰的变量显示在符号配置中。因此，您无法将这些类型的变量导出为符号。这些变量在在线模式下也是不可见的，因此无法监控它们的值。此外，您不能使用任何调试功能，并且在检查错误时没有任何支持。 如果您，应用程序开发人员，知道隐藏的 POU 和变量的确切实例路径，那么您可以在代码中访问它们。 句法 ： {attribute 'hide'} 插入位置：对于变量，位于声明变量的行上方。对于 POU，在第一行。 隐藏变量 功能块 FB_MyA 包含属性 pragma {attribute 'hide'} 隐藏局部变量 xInvisibleIn . FUNCTION_BLOCK FB_MyA\nVAR_INPUT\n iInA : INT;\n {attribute 'hide'}\n xInvisibleIn : BOOL;\n xInit: BOOL;\nEND_VAR\nVAR_OUTPUT\n iOutA : INT;\nEND_VAR\nVAR\n iCounter : INT;\nEND_VAR 功能块的两个实例 FB_MyA 在主程序中定义。 PROGRAM PLC_PRG\nVAR\n fbMyA1, fbMyA2 : FB_MyA;\n xVar2 : BOOL;\n iVar1 : INT;\n iVar2 : INT;\nEND_VAR\nfbMyA1(iInA := 1, xInit := TRUE, xInvisibleIn := TRUE, iOutA => iVar1);\nfbMyA2(iInA := 1, xInit := TRUE, iOutA => iVar2); 而输入值 fbMyA1 现在实现了“列表组件”功能，在键入时打开 fbMyA1. （在执行部分 PLC_PRG )，显示变量 iInA , xInit ， 和 iOutA ，但不是隐藏变量 xInvisibleIn . 隐藏库 POU FB_A 是库的功能块 HiddenFunctionality 使用默认命名空间 HIDDEN .要对应用程序开发人员隐藏标识符和 POU 代码，请使用属性 pragma 开始声明 POU {attribute 'hide'} .要以相同的方式隐藏从属 POU（动作、方法、属性和转换），也要以它们的声明开头 {attribute 'hide'} . {attribute 'hide'}\nFUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\n iCount : INT;\n iInvisible : INT;\nEND_VAR\n\n{attribute 'hide'}\nMETHOD METH_Count : INT\nVAR_INPUT\nEND_VAR\niCount := iCount + 1;\n\n{attribute 'hide'}\nMETHOD METH_Invisible : BOOL\nVAR_INPUT\nEND_VAR\niInvisible := iInvisible + 1;\n\n{attribute 'hide'}\nPROPERTY PUBLIC prop_iA : INT 对于作为应用程序开发人员的您来说，所有 POU 都是不可见的。仅当您知道实例路径时才能使用它们。 PROGRAM PLC_PRG\nVAR\n fbHidden : HIDDEN.FB_A; \/\/ Hidden function block from library HiddenFunctionality\n iCounter : INT;\nEND_VAR\nfbHidden.METH_Invisible();\niCounter := fbHidden.iInvisible; 在联机模式下，不执行任何监控。 随着 {属性'hide_all_locals'} pragma，您可以隐藏 POU 的所有局部变量。 " }, 
{ "title" : "属性：hide_all_locals ", 
"url" : "_cds_pragma_attribute_hide_all_locals.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：hide_all_locals ", 
"snippet" : "hide_all_locals pragma 防止签名的所有局部变量在“列表组件”功能的显示中、输入助手中或在线模式下的声明部分中可见。此外，这些变量隐藏在符号配置中，因此不能作为符号导出。 pragma 在库 POU 中特别有用，可以对用户隐藏 POU 变量。 受影响的功能 图书馆管理 调试 输入助手 “列出组件”功能 监控 符号配置 句法 ： {attribute 'hide_all_locals'} 插入位置：POU 声明部分上方的第一行 例子 功能块 FB_MyB 使用属性： {attribute 'hide_all_locals'} FUNCTION_BLOCK FB_MyB VAR...", 
"body" : "hide_all_locals pragma 防止签名的所有局部变量在“列表组件”功能的显示中、输入助手中或在线模式下的声明部分中可见。此外，这些变量隐藏在符号配置中，因此不能作为符号导出。 pragma 在库 POU 中特别有用，可以对用户隐藏 POU 变量。 受影响的功能 图书馆管理 调试 输入助手 “列出组件”功能 监控 符号配置 句法 ： {attribute 'hide_all_locals'} 插入位置：POU 声明部分上方的第一行 例子 功能块 FB_MyB 使用属性： {attribute 'hide_all_locals'}\nFUNCTION_BLOCK FB_MyB\nVAR_INPUT\n iInB : INT;\n {attribute 'hide'}\n xInvisibleIn : BOOL;\n xInit: BOOL;\nEND_VAR\nVAR_OUTPUT\n iOutB : INT;\nEND_VAR\nVAR\n iCounter : INT;\n xVar : BOOL;\nEND_VAR 功能块的两个实例 FB_MyB 在主程序中定义。 PROGRAM PLC_PRG\nVAR\n fbMyB1, fbMyB2: FB_MyB;\n iVar3: INT;\n iVar4: INT;\nEND_VAR\n\nfbMyB1(iInB := 2, xInvisibleIn := TRUE, iOutB => iVar3);\nfbMyB2(iInB := 2, iOutB => iVar4);\nIF fbMyB2.iCounter > 100 THEN\n fbMyB2.xInit := TRUE;\nEND_IF 现在，当您将程序下载到控制器、启动它并切换到在线模式时，变量 iInB , xInit , iOutB ， 和 xReset 显示在声明编辑器中。然而，隐藏的局部变量 iCounter 和 xVar 不显示。 " }, 
{ "title" : "属性：initialize_on_call ", 
"url" : "_cds_pragma_attribute_initialize_on_call.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：initialize_on_call ", 
"snippet" : "initialize_on_call pragma 导致功能块的输入变量在功能块的每次调用时被初始化。如果需要一个指针的输入变量受到影响，并且该指针在在线更改期间已被删除，则该变量被初始化为 zero . 句法： {attribute 'initialize_on_call'} 插入位置：始终位于整个功能块的声明部分的第一行，也位于单个输入变量声明的上方。 例子 {attribute 'initialize_on_call'} FUNCTION_BLOCK fb VAR_INPUT {attribute 'initialize_on_call'} pInt : POINTER TO INT :...", 
"body" : "initialize_on_call pragma 导致功能块的输入变量在功能块的每次调用时被初始化。如果需要一个指针的输入变量受到影响，并且该指针在在线更改期间已被删除，则该变量被初始化为 zero . 句法： {attribute 'initialize_on_call'} 插入位置：始终位于整个功能块的声明部分的第一行，也位于单个输入变量声明的上方。 例子 {attribute 'initialize_on_call'}\nFUNCTION_BLOCK fb\nVAR_INPUT\n {attribute 'initialize_on_call'}\n pInt : POINTER TO INT := 0;\n {attribute 'initialize_on_call'}\n iVal : INT := 0;\nEND_VAR " }, 
{ "title" : "属性：init_namespace ", 
"url" : "_cds_pragma_attribute_init_namespace.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：init_namespace ", 
"snippet" : "init_namespace 这个 pragma 的效果是类型的变量 STRING 或者 WSTRING ，在库功能块中用这个 pragma 声明，在项目中使用库的当前命名空间时被初始化。 句法 {attribute 'init_namespace'} 插入位置：库功能块中变量声明行的上方。 功能块 POU 提供了必要的属性： FUNCTION_BLOCK POU VAR_OUTPUT {attribute 'init_namespace'} myStr: STRING; END_VAR 一个实例 fb 功能块 POU 的定义在主程序 PLC_PRG 中： PROGRAM PLC_PRG VA...", 
"body" : "init_namespace 这个 pragma 的效果是类型的变量 STRING 或者 WSTRING ，在库功能块中用这个 pragma 声明，在项目中使用库的当前命名空间时被初始化。 句法 {attribute 'init_namespace'} 插入位置：库功能块中变量声明行的上方。 功能块 POU 提供了必要的属性： FUNCTION_BLOCK POU\nVAR_OUTPUT\n {attribute 'init_namespace'}\n myStr: STRING;\nEND_VAR 一个实例 fb 功能块 POU 的定义在主程序 PLC_PRG 中： PROGRAM PLC_PRG\nVAR\n fb:POU;\n newString: STRING;\nEND_VAR\nnewString := fb.myStr; 这 myStr 变量用当前命名空间初始化（例如： MyLib ）。此值分配给 newString 在主程序中。 " }, 
{ "title" : "属性：init_on_onlchange ", 
"url" : "_cds_pragma_attribute_init_on_onlchange.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：init_on_onlchange ", 
"snippet" : "init_on_onlchange 快速在线更改期间没有初始化代码 由于编译器版本 >= 3.5.0.0，因此对较小的更改执行“快速在线更改”。在快速在线更改期间，仅编译和下载修改后的 POU。特别是，不会生成初始化代码。 对于具有的变量 init_on_onlchange 属性，这也导致 不 正在生成初始化代码。在通常的情况下，这没有影响，因为该属性通常用于用地址初始化变量。但是，在快速在线更改期间，不会发生变量更改其地址的情况。 但是，为了确保 init_on_onlchange 属性应用在整个应用程序代码中，一般对于应用程序你可以使用 no_fast_online_change 编译器定...", 
"body" : "init_on_onlchange 快速在线更改期间没有初始化代码 由于编译器版本 >= 3.5.0.0，因此对较小的更改执行“快速在线更改”。在快速在线更改期间，仅编译和下载修改后的 POU。特别是，不会生成初始化代码。 对于具有的变量 init_on_onlchange 属性，这也导致 不 正在生成初始化代码。在通常的情况下，这没有影响，因为该属性通常用于用地址初始化变量。但是，在快速在线更改期间，不会发生变量更改其地址的情况。 但是，为了确保 init_on_onlchange 属性应用在整个应用程序代码中，一般对于应用程序你可以使用 no_fast_online_change 编译器定义禁用快速在线更改。为此，请在设备树中选择您的应用程序对象并单击 特性 在上下文菜单中。以下 建造 选项卡，添加 no_fast_online_change 编译器定义。 有关详细信息，请参阅： 建造此 pragma 的效果是应用 pragma 的变量在每次在线更改时都会被初始化。 句法： {attribute 'init_on_onlchange' } 插入位置：变量声明行上方的行。 例子 VAR_GLOBAL    \n {attribute 'init_on_onlchange'}    \n g_fastOnlineChange : BOOL := FALSE;\nEND_VAR\n {attribute 'call_after_online_change_slot' := '4567'}\nFUNCTION FUNC_OnlineChangeDetection : BOOL\nVAR_INPUT\nEND_VAR\nVAR\nEND_VAR \n\nIF GVL_OnlineChangeDetection.g_fastOnlineChange THEN    \n \/\/ here you know that you are inside a FastOnlineChange\nEND_IF\n\/\/ reset for next detection\nGVL_OnlineChangeDetection.g_fastOnlineChange := TRUE; " }, 
{ "title" : "属性：instance-path ", 
"url" : "_cds_pragma_attribute_instance_path.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：instance-path ", 
"snippet" : "instance-path pragma 可以应用于本地字符串变量。其效果是这个局部字符串变量按照它所属的POU的设备树路径顺序被初始化。这对于错误消息很有用。 应用 pragma 需要应用属性 ' 反射 ' 到关联的 POU，以及附加属性的应用 ' noinit ' 到 STRING 变量。 句法 ： {attribute 'instance-path'} 插入位置：声明的行上方的行 STRING 多变的。 例子 以下功能块包含属性 'reflection' , 'instance-path' 和 'noinit' . {attribute 'reflection'} FUNCTION_BL...", 
"body" : "instance-path searchresult_toplevel pragma 可以应用于本地字符串变量。其效果是这个局部字符串变量按照它所属的POU的设备树路径顺序被初始化。这对于错误消息很有用。 应用 pragma 需要应用属性 ' 反射 ' 到关联的 POU，以及附加属性的应用 ' noinit ' 到 STRING 变量。 句法 ： {attribute 'instance-path'} 插入位置：声明的行上方的行 STRING 多变的。 例子 以下功能块包含属性 'reflection' , 'instance-path' 和 'noinit' . {attribute 'reflection'}\nFUNCTION_BLOCK POU\nVAR\n {attribute 'instance-path'}\n {attribute 'noinit'}\n str: STRING;\nEND_VAR 一个实例 我的POU 功能块的 POU 在主程序中定义 PLC_PRG ： PROGRAM PLC_PRG\nVAR\n myPOU:POU;\n myString: STRING;\nEND_VAR\nmyPOU();\nmyString:=myPOU.str; 在实例初始化之后 myPOU , 实例 myPOU 的路径赋值给字符串变量 str , 在示例中 PLCWinNT.Application.PLC_PRG.myPOU .该路径在主程序中分配给变量 myString . 您可以根据需要定义字符串的长度（甚至 >255）。但是，您必须考虑如果将字符串分配给数据类型太小的变量，字符串将在末尾被截断。 " }, 
{ "title" : "属性：io_function_block、io_function_block_mapping ", 
"url" : "_cds_pragma_attribute_io_function_block_mapping.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：io_function_block、io_function_block_mapping ", 
"snippet" : "io_function_block, io_function_block_mapping 这 io_function_block 属性的作用是，用它修饰的功能块在设备配置中可用，以分配给 I\/O 映射中的通道。功能块如图所示 选择功能块 对话。 这 'io_function_block_mapping' 属性在这种功能块中具有修饰参数的效果，该参数在将功能块映射到设备通道时自动使用。 您可以为功能块的多个参数提供属性。对于 I\/O 映射，第一个自动使用，其类型与通道匹配（输入、输出、数据类型）。 句法 ： {attribute 'io_function_block'} {attribute '...", 
"body" : "io_function_block, io_function_block_mapping 这 io_function_block 属性的作用是，用它修饰的功能块在设备配置中可用，以分配给 I\/O 映射中的通道。功能块如图所示 选择功能块 对话。 这 'io_function_block_mapping' 属性在这种功能块中具有修饰参数的效果，该参数在将功能块映射到设备通道时自动使用。 您可以为功能块的多个参数提供属性。对于 I\/O 映射，第一个自动使用，其类型与通道匹配（输入、输出、数据类型）。 句法 ： {attribute 'io_function_block'} {attribute 'io_function_block_mapping'} 插入位置：功能块声明中第一行的上方，参数声明的上方。 例子 {attribute 'io_function_block'}\nFUNCTION_BLOCK Scale_Output_Int\nVAR_INPUT\n iInput : INT;\n iNumerator : INT;\n iDenominator : INT :=1;\n iOffset : INT := 0;\nEND_VAR\nVAR_OUTPUT\n {attribute 'io_function_block_mapping'}\n iOutput : INT;\nEND_VAR\n " }, 
{ "title" : "属性：is_connected ", 
"url" : "_cds_pragma_attribute_is_connected.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：is_connected ", 
"snippet" : "is_connected 你使用编译指示 'is_connected' 装饰一个布尔函数块变量，当调用函数模块实例时，该变量提供有关 POU 的关联输入是否有赋值的信息。 使用 pragma 需要使用属性 'reflection' 在受影响的功能块上。 句法 ： {attribute 'is_connected' := '<input variable>'} 例子 在功能块中 FB ，为每个输入变量声明一个局部变量（ in1 和 in2 ) 和属性 'is connected' 每次都在其前面加上输入变量的名称。 func 本身获取 pragma 属性 'reflection' . 调用功能块...", 
"body" : "is_connected 你使用编译指示 'is_connected' 装饰一个布尔函数块变量，当调用函数模块实例时，该变量提供有关 POU 的关联输入是否有赋值的信息。 使用 pragma 需要使用属性 'reflection' 在受影响的功能块上。 句法 ： {attribute 'is_connected' := '<input variable>'} 例子 在功能块中 FB ，为每个输入变量声明一个局部变量（ in1 和 in2 ) 和属性 'is connected' 每次都在其前面加上输入变量的名称。 func 本身获取 pragma 属性 'reflection' . 调用功能块的实例时，局部变量为 TRUE 在分配给它的输入已收到分配的情况下。 {attribute 'reflection'}\nFUNCTION_BLOCK FB\nVAR_INPUT\n in1: INT;\n in2: INT;\nEND_VAR\nVAR\n {attribute 'is_connected' := 'in1'}\n in1_connection_info: BOOL;\n {attribute 'is_connected' := 'in2'}\n in2_connection_info: BOOL;\nEND_VAR 假设：当功能块实例被调用时， in1 接受外部任务，并且 in 2 没有收到任务。这导致以下代码： in1_connection_info := TRUE;\nin2_connection_info := FALSE; " }, 
{ "title" : "属性：linkalways ", 
"url" : "_cds_pragma_attribute_linkalways.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：linkalways ", 
"snippet" : "linkalways 语用 {attribute 'linkalways'} 指示编译器始终在编译信息中包含 POU 或库 POU。在构建期间，POU 被编译并且是应用程序代码的一部分。在下载过程中，POU 被下载到 PLC。 句法 ： {attribute 'linkalways'} 插入位置：POU或库POU的声明部分的第一行 POU 可能在整个项目期间都有效（保存在 POU 查看）或整个应用程序（保存在 设备 看法）。 您还可以选择 始终链接 中的选项 建造 POU 对象属性的选项卡。 例子 这 MoreSymbols GVL 包含 pragma {attribute 'linkalwa...", 
"body" : "linkalways 语用 {attribute 'linkalways'} 指示编译器始终在编译信息中包含 POU 或库 POU。在构建期间，POU 被编译并且是应用程序代码的一部分。在下载过程中，POU 被下载到 PLC。 句法 ： {attribute 'linkalways'} 插入位置：POU或库POU的声明部分的第一行 POU 可能在整个项目期间都有效（保存在 POU 查看）或整个应用程序（保存在 设备 看法）。 您还可以选择 始终链接 中的选项 建造 POU 对象属性的选项卡。 例子 这 MoreSymbols GVL 包含 pragma {attribute 'linkalways'} .在那里声明的变量也是应用程序代码的一部分，不管任何访问。 GVL MoreSymbols {attribute 'linkalways'}\nVAR_GLOBAL\n g_iAlfa: INT;\n g_iBravo: INT;\n g_iCharlie: INT;\nEND_VAR 符号配置也访问编译信息。结果，变量 MoreSymbols 始终提供 GVL 以供选择 符号配置 编辑。 " }, 
{ "title" : "属性：monitoring ", 
"url" : "_cds_pragma_attribute_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：monitoring ", 
"snippet" : "monitoring 此 pragma 的效果是您可以在 IEC 编辑器的在线视图或监视列表中监视属性或函数调用的值。有两个可能的属性值： 'variable' 和 'call' 句法 {attribute 'monitoring' := 'variable'} {attribute 'monitoring' := 'call'}...", 
"body" : "monitoring searchresult_toplevel 此 pragma 的效果是您可以在 IEC 编辑器的在线视图或监视列表中监视属性或函数调用的值。有两个可能的属性值： 'variable' 和 'call' 句法 {attribute 'monitoring' := 'variable'} {attribute 'monitoring' := 'call'} " }, 
{ "title" : "监控编程对象及其属性 ", 
"url" : "_cds_pragma_attribute_monitoring.html#UUID-b1b46724-01c4-546c-fe9d-2236c7c9e2df_id_edeaa3c5d0ed2fac0a8640e00361c29_id_a51754afb92821c6c0a86463317326eb", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：monitoring \/ 监控编程对象及其属性 ", 
"snippet" : "当您插入 pragma {attribute 'monitoring':='call'} 对于监控，您必须注意可能的副作用。如果在属性中实现了其他操作，则可能会出现这些副作用。 语用 {attribute 'monitoring'} 还针对符号配置进行评估。该值只能进行读取访问 'variable' . 在功能块或程序的在线视图中，除了局部变量之外，您还可以监视从属属性。这使您可以监视 Get 和 Set 方法。 插入 pragma {attribute 'monitoring' := 'variable'} 或者 {attribute 'monitoring' := 'call'} 在属性块...", 
"body" : "当您插入 pragma {attribute 'monitoring':='call'} 对于监控，您必须注意可能的副作用。如果在属性中实现了其他操作，则可能会出现这些副作用。 语用 {attribute 'monitoring'} 还针对符号配置进行评估。该值只能进行读取访问 'variable' . 在功能块或程序的在线视图中，除了局部变量之外，您还可以监视从属属性。这使您可以监视 Get 和 Set 方法。 插入 pragma {attribute 'monitoring' := 'variable'} 或者 {attribute 'monitoring' := 'call'} 在属性块的声明中。然后，属性的当前值会自动显示在 IEC 编辑器或监视列表中。 例子 在联机模式下， PLC_PRG 对象显示的值 Minutes ST 编辑器中内联调用位置的属性。这是因为 pragma {attribute 'monitoring' := 'variable'} 位于声明中 Minutes 财产。 仔细检查每个应用程序的哪些属性编译指示适合显示所需的值。这取决于是否在属性内实现了对变量的进一步操作。 语用： {attribute 'monitoring':='variable'} ： 为属性创建一个隐式变量，然后在应用程序调用 Set 或者 Get 方法。最后存储在此变量中的值显示在监控中。 语用： {attribute 'monitoring':='call'} 您只能将此属性用于返回简单数据类型或指针的属性，但不能用于结构化类型。 通过直接调用该属性来读取或写入要监视的值。这意味着运行时的监控服务执行 Get 或者 Set 属性的方法。 使用上下文菜单命令 添加手表 ，将光标当前所在的变量直接应用到在线模式的监控列表中。 不支持强制或写入函数。但是，您可以通过为相应函数添加一个附加输入参数来隐式实现强制，该参数用作内部强制标志。 在紧凑型运行系统中无法进行功能监控。 " }, 
{ "title" : "属性：monitoring_display ", 
"url" : "_cds_pragma_attribute_monitoring_display.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：monitoring_display ", 
"snippet" : "monitoring_display 声明中的这个 pragma 功能块 或一个 结构体 具有指定成员的当前值 ( 财产 oder 变量）也显示在监控中。 然后，功能块或结构成员的值显示在监视功能块或结构类型的变量的顶行中。 句法： {attribute 'monitoring_display' := '<component name>'} 插入位置：声明第一行上方 例子 {attribute 'monitoring_display' := 'stMonitoring'} TYPE ADUT : STRUCT val1: INT; val2: INT; stMonitoring: STRING...", 
"body" : "monitoring_display 声明中的这个 pragma 功能块 或一个 结构体 具有指定成员的当前值 ( 财产 oder 变量）也显示在监控中。 然后，功能块或结构成员的值显示在监视功能块或结构类型的变量的顶行中。 句法： {attribute 'monitoring_display' := '<component name>'} 插入位置：声明第一行上方 例子 {attribute 'monitoring_display' := 'stMonitoring'} \nTYPE ADUT :\nSTRUCT\t\n val1: INT;\t\n val2: INT;\t\n stMonitoring: STRING := 'to be monitored';\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\t\n mydut: ADUT;\n nTest: INT;\nEND_VAR\nnTest:= iCounter + 1;\nmydut.stMonitoring := INT_TO_STRING(nTest);\n " }, 
{ "title" : "属性：monitoring_encoding ", 
"url" : "_cds_pragma_attribute_monitoring_encoding.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：monitoring_encoding ", 
"snippet" : "monitoring_encoding 属性 pragma 允许用于数据类型的变量 STRING 对于别名数据类型 type 的变量 STRING 。该属性的作用是用它标记变量的值，以便在监视期间以 UTF-8 格式解码。 句法 ： {attribute 'monitoring_encoding' := 'UTF8'} 插入位置：变量声明上方 例子 PROGRAM PLC_PRG VAR {attribute 'monitoring.encoding' := 'UTF8'} strDat : STRING := 'abc'; attribute 'monitoring_encoding' :=...", 
"body" : "monitoring_encoding 属性 pragma 允许用于数据类型的变量 STRING 对于别名数据类型 type 的变量 STRING 。该属性的作用是用它标记变量的值，以便在监视期间以 UTF-8 格式解码。 句法 ： {attribute 'monitoring_encoding' := 'UTF8'} 插入位置：变量声明上方 例子 PROGRAM PLC_PRG\nVAR\n {attribute 'monitoring.encoding' := 'UTF8'}\n strDat : STRING := 'abc'; \n attribute 'monitoring_encoding' := 'UTF-8'}\t\n strVarUtf8: STRING := UTF8#'你好,世界!ÜüÄäÖö';\n {attribute 'monitoring_encoding' := 'UTF-8'}\n str1: STRING := UTF8#'AÄyyy';\t\t\n {attribute 'monitoring_encoding' := 'UTF-8'}\t\t\n str2: STRING := UTF8#'AÄxxxÜÜÜ';\t\n\t\t\n strVarUtf8_1: STRING := '你好,世界!ÜüÄäÖö';\n str1_1: STRING := 'AÄyyy';\t\t\t\t\n str2_1: STRING := 'AÄxxxÜÜÜ';\t\t\t\nEND_VAR " }, 
{ "title" : "属性：no_assign、no_assign_warning ", 
"url" : "_cds_pragma_attribute_no_assign.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：no_assign、no_assign_warning ", 
"snippet" : "no_assign, no_assign_warning 语用 'no_assign' 如果将功能块的一个实例分配给同一功能块的另一个实例，则会导致显示编译器错误。如果功能块包含指针并且指针会导致问题，则通常应避免此类分配，因为在赋值期间它们也会被复制。 语用 'no_assign_warning' 结果与编译指示相同 'no_assign' 带有编译器警告而不是编译器错误。 句法 ： {attribute 'no_assign'} 插入位置：功能块声明部分的顶行。 例子 分配包含指针的功能块实例。 在这个例子中，功能块实例的赋值会导致在执行过程中出现问题 fb_exit ： VAR_GLOB...", 
"body" : "no_assign, no_assign_warning 语用 'no_assign' 如果将功能块的一个实例分配给同一功能块的另一个实例，则会导致显示编译器错误。如果功能块包含指针并且指针会导致问题，则通常应避免此类分配，因为在赋值期间它们也会被复制。 语用 'no_assign_warning' 结果与编译指示相同 'no_assign' 带有编译器警告而不是编译器错误。 句法 ： {attribute 'no_assign'} 插入位置：功能块声明部分的顶行。 例子 分配包含指针的功能块实例。 在这个例子中，功能块实例的赋值会导致在执行过程中出现问题 fb_exit ： VAR_GLOBAL\n inst1 : TestFB;\n awsBufferLogFile : ARRAY [0..9] OF WSTRING(66);(* Area: 0, Offset: 0x1304 (4868)*)\n LogFile : SEDL.LogRecord := (sFileName := 'LogFile.log', pBuffer := ADR(awsBufferLogFile), udiMaxEntriesFile := UDINT#10000, udiMaxBuffered := UDINT#10, uiLineSize := UINT#64, wsSep := \" \", xCircular := TRUE, siDateFormat := SINT#0, siTimeFormat := SINT#0);\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n inst2 : TestFB := inst1;\n LogFileNew\nEND_VAR 在这种情况下 LogRecord 管理一个指针列表，在以下情况下执行各种操作 fb_exit .由于分配导致问题，因为 fb_exit 将被执行两次。您应该通过添加属性来防止这种情况 'no_assign' 在功能块的声明中 测试FB ： {attribute 'no_assign'}\nFUNCTION_BLOCK TestFB\nVAR_INPUT\n... 然后显示以下编译器错误： C0328: Assignment not allowed for type TestFB\nC0328: Assignment not allowed for type LogRecord 如果语用 no_assign_warning 用于代替编译指示 no_assign 对于功能块 测试FB ，那么 C0328 消息作为编译器警告发出，而不是编译器错误。 " }, 
{ "title" : "属性：no_check ", 
"url" : "_cds_pragma_attribute_no_check.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：no_check ", 
"snippet" : "no_check pragma 的作用是检查函数 ( 用于隐式检查的 POU) POU 不需要。由于检查功能会影响程序的处理速度，因此将属性应用于已检查或经常调用的功能块会很有用。 您将 pragma 添加到 POU 的声明中。 句法 ： {attribute 'no_check'} 插入位置：POU 声明部分的第一行 该属性还会自动影响 POU 的子对象！ 示例：如果在程序中输入了属性，则对于分配给该程序的操作也不会执行检查功能。...", 
"body" : "no_check pragma 的作用是检查函数 ( 用于隐式检查的 POU) POU 不需要。由于检查功能会影响程序的处理速度，因此将属性应用于已检查或经常调用的功能块会很有用。 您将 pragma 添加到 POU 的声明中。 句法 ： {attribute 'no_check'} 插入位置：POU 声明部分的第一行 该属性还会自动影响 POU 的子对象！ 示例：如果在程序中输入了属性，则对于分配给该程序的操作也不会执行检查功能。 " }, 
{ "title" : "属性：no_copy ", 
"url" : "_cds_pragma_attribute_no_copy.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：no_copy ", 
"snippet" : "no_copy 通常，在线更改需要重新分配 POU 的实例。在此过程中，实例中包含的变量的值被复制。 pragma 防止实例中包含的变量的值在在线更改过程中被复制；相反，该变量会在在线更改过程中重新初始化。这对于指向刚刚被在线更改移动并因此具有更改地址的变量的局部指针变量可能很有用。 句法 ： {attribute 'no_copy'} 您将属性插入到相关变量声明行上方的声明部分。...", 
"body" : "no_copy 通常，在线更改需要重新分配 POU 的实例。在此过程中，实例中包含的变量的值被复制。 pragma 防止实例中包含的变量的值在在线更改过程中被复制；相反，该变量会在在线更改过程中重新初始化。这对于指向刚刚被在线更改移动并因此具有更改地址的变量的局部指针变量可能很有用。 句法 ： {attribute 'no_copy'} 您将属性插入到相关变量声明行上方的声明部分。 " }, 
{ "title" : "属性：no-exit ", 
"url" : "_cds_pragma_attribute_no_exit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：no-exit ", 
"snippet" : "no-exit 该属性抑制调用 FB_Exit 功能块的某个实例的方法。为此，您在功能块实例声明之前的行中插入属性。 句法 ： {attribute 'no-exit'} 方法 FB_exit 被添加到功能块 POU_ex .功能块的两个实例 POU_ex 在主程序中创建 PLC_PRG . PROGRAM PLC_PRG VAR POU1 : POU_ex; {attribute 'no-exit'} POU2 : POU_ex; END_VAR POU1 被调用，POU2 未被调用。...", 
"body" : "no-exit searchresult_toplevel 该属性抑制调用 FB_Exit 功能块的某个实例的方法。为此，您在功能块实例声明之前的行中插入属性。 句法 ： {attribute 'no-exit'} 方法 FB_exit 被添加到功能块 POU_ex .功能块的两个实例 POU_ex 在主程序中创建 PLC_PRG . PROGRAM PLC_PRG\nVAR\n POU1 : POU_ex;\n {attribute 'no-exit'}\n POU2 : POU_ex;\nEND_VAR POU1 被调用，POU2 未被调用。 " }, 
{ "title" : "属性：noinit ", 
"url" : "_cds_pragma_attribute_noinit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：noinit ", 
"snippet" : "noinit 该 pragma 应用于不应被隐式初始化的变量。 句法 ： {attribute 'no_init'} {attribute 'no-init'} {attribute 'noinit'} 插入位置：声明部分相关变量的声明行上方的行。 例子 PROGRAM PLC_PRG VAR iA : INT; {attribute 'no_init'} iB : INT; END_VAR 当关联的应用程序被重置时，整数变量 iA 隐式地重新初始化为 0 ，而变量 iB 保留其当前值。...", 
"body" : "noinit 该 pragma 应用于不应被隐式初始化的变量。 句法 ： {attribute 'no_init'} {attribute 'no-init'} {attribute 'noinit'} 插入位置：声明部分相关变量的声明行上方的行。 例子 PROGRAM PLC_PRG\nVAR\n iA : INT;\n {attribute 'no_init'}\n iB : INT;\nEND_VAR 当关联的应用程序被重置时，整数变量 iA 隐式地重新初始化为 0 ，而变量 iB 保留其当前值。 " }, 
{ "title" : "属性：no_instance_in_retain ", 
"url" : "_cds_pragma_attribute_no_instance_in_retain.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：no_instance_in_retain ", 
"snippet" : "no_instance_in_retain pragma 的效果是用它装饰的功能模块不能被实例化为 RETAIN 多变的。 pragma 防止功能块的实例存储在保留内存中。相反，会显示一条错误消息。 句法 ： {attribute 'no_instance_in_retain'} 插入位置：上方的行 FUNCTION_BLOCK 在功能块的声明部分声明。...", 
"body" : "no_instance_in_retain pragma 的效果是用它装饰的功能模块不能被实例化为 RETAIN 多变的。 pragma 防止功能块的实例存储在保留内存中。相反，会显示一条错误消息。 句法 ： {attribute 'no_instance_in_retain'} 插入位置：上方的行 FUNCTION_BLOCK 在功能块的声明部分声明。 " }, 
{ "title" : "属性：no_virtual_actions ", 
"url" : "_cds_pragma_attribute_no_virtual_actions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：no_virtual_actions ", 
"snippet" : "no_virtual_actions 该指令用于从 SFC 中实现的功能块派生的功能块，并使用该基类的基本 SFC 序列。从中调用的操作表现出与方法相同的虚拟行为。这意味着，基类中操作的实现可以被派生类替换为其自己的特定实现。 如果将编译指示应用于基类，则其操作将受到保护，免于重载。 句法 ： {attribute 'no_virtual_actions'} 插入位置：功能块声明部分顶行 功能块 POU_SFC 是派生函数块的基类 POU_child . 派生类 POU_child 使用特殊变量调用在 SFC 中编写的基类的序列 SUPER 。 该序列的示例性实现仅限于初始步骤，然后是具有链接...", 
"body" : "no_virtual_actions 该指令用于从 SFC 中实现的功能块派生的功能块，并使用该基类的基本 SFC 序列。从中调用的操作表现出与方法相同的虚拟行为。这意味着，基类中操作的实现可以被派生类替换为其自己的特定实现。 如果将编译指示应用于基类，则其操作将受到保护，免于重载。 句法 ： {attribute 'no_virtual_actions'} 插入位置：功能块声明部分顶行 功能块 POU_SFC 是派生函数块的基类 POU_child . 派生类 POU_child 使用特殊变量调用在 SFC 中编写的基类的序列 SUPER 。 该序列的示例性实现仅限于初始步骤，然后是具有链接步骤操作的单个步骤 ActiveAction 。此步骤与链接的步骤操作一起负责输出变量的配置。 an_int := an_int+1; \/\/ Counting the action calls\ntest_act := 'father_action';\nMETH(); \/\/ Call of the method METH in order to set the string variable test_meth 对于派生类 POU_child 步骤操作被替换为特殊实现 ActiveAction 。 Active Action 与原始版本的区别仅在于字符串的赋值 'child_action' 代替 'father_action' 在变量 test_act 。 同样，该方法 METH ，分配字符串 'father_method' 到变量 test_meth 在基类中，被覆盖，以便 test_meth 现在获得值 'child_method' .主程序 PLC_PRG 调用功能块的实例 POU_child ，名为 Child 。正如所料，字符串的值反映了派生类的动作和方法的调用： 然而，现在你把指令 {attribute 'no_virtual_actions'} 在基类前面： {attribute 'no_virtual_actions'}\n\nFUNCTION_BLOCK POU_SFC... 这改变了行为：虽然派生类的实现仍然用于方法 METH ，步骤操作的调用现在会导致操作的调用 ActiveAction 基类的。因此 test_act 现在被赋予了价值 'father_action' ： " }, 
{ "title" : "属性：obsolete ", 
"url" : "_cds_pragma_attribute_obsolete.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：obsolete ", 
"snippet" : "obsolete 此编译指示的效果是，如果项目中使用了数据类型（结构、功能块等），则会在编译期间为数据类型定义显示已定义的警告。例如，这使您能够注意到数据类型不再有效这一事实，例如，接口已更改，并且这也应在项目中实现。 与消息杂注相反，此警告是为数据类型的所有实例集中定义的。 句法 ： {attribute 'obsolete' := 'user defined text'} 插入位置：数据类型定义的行或其上方的一行。 例子 该 pragma 被插入到 FB_I1 功能块： {attribute 'obsolete' := 'Data type FB_I1 not valid'} FUNCTI...", 
"body" : "obsolete searchresult_toplevel 此编译指示的效果是，如果项目中使用了数据类型（结构、功能块等），则会在编译期间为数据类型定义显示已定义的警告。例如，这使您能够注意到数据类型不再有效这一事实，例如，接口已更改，并且这也应在项目中实现。 与消息杂注相反，此警告是为数据类型的所有实例集中定义的。 句法 ： {attribute 'obsolete' := 'user defined text'} 插入位置：数据类型定义的行或其上方的一行。 例子 该 pragma 被插入到 FB_I1 功能块： {attribute 'obsolete' := 'Data type FB_I1 not valid'}\nFUNCTION_BLOCK FB_I1\nVAR_INPUT\n i:INT;\nEND_VAR\n; 如果您使用 FB_I1 作为数据类型，例如在 fbI1 : FB_I1; ，那么编译项目时会出现如下警告： Data type FB_I1 not valid . " }, 
{ "title" : "属性：pingroup ", 
"url" : "_cds_pragma_attribute_pingroup.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：pingroup ", 
"snippet" : "pingroup 此 pragma 的效果是输入引脚或输出引脚（参数）在功能块的声明中分组。在 FBD\/LD 编辑器中，以这种方式定义的引脚组可以在插入的功能块上显示为扩展或缩小的单元。几个组是可能的，并通过它们的名称来区分。 CODESYS 使用项目选项保存每个功能块框的相应状态（减少）。 句法 ： {attribute 'pingroup' := '<group name>'} 插入位置：功能块声明部分中有关输入或输出变量声明上方的行。 例子 定义了两个组： general (i1, out1) 和 group1 (i2, g1) . r1 , r2 , outRes1 和 g2 始终显示...", 
"body" : "pingroup 此 pragma 的效果是输入引脚或输出引脚（参数）在功能块的声明中分组。在 FBD\/LD 编辑器中，以这种方式定义的引脚组可以在插入的功能块上显示为扩展或缩小的单元。几个组是可能的，并通过它们的名称来区分。 CODESYS 使用项目选项保存每个功能块框的相应状态（减少）。 句法 ： {attribute 'pingroup' := '<group name>'} 插入位置：功能块声明部分中有关输入或输出变量声明上方的行。 例子 定义了两个组： general (i1, out1) 和 group1 (i2, g1) . r1 , r2 , outRes1 和 g2 始终显示。 FUNCTION_BLOCK FB\nVAR_INPUT\n r1 : REAL;\n {attribute 'pingroup' := 'general'}\n i1 : INT;\n {attribute 'pingroup' := 'group1'}\n i2 : INT;\n r2 : REAL;\nEND_VAR\nVAR_OUTPUT\n outRes1 : REAL;\n {attribute 'pingroup' := 'general'}\n out1 : INT;\n {attribute 'pingroup' := 'group1'}\n g1 : INT;\n g2 : REAL;\nEND_VAR " }, 
{ "title" : "属性：pin_presentation_order_inputs、pin_presentation_order_outputs ", 
"url" : "_cds_pragma_attribute_pin_presentation_order.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：pin_presentation_order_inputs、pin_presentation_order_outputs ", 
"snippet" : "pin_presentation_order_inputs, pin_presentation_order_outputs 当 {attribute 'pingroup' := '<Group_Name>'} 使用了编译指示。 编译指示在 CFC、FBD 和 LD 图形编辑器中进行评估，导致受影响功能块的输入\/输出顺序按指定显示。您可以通过按所需顺序将输入\/输出的名称分配给属性来对顺序进行编程。 句法： {attribute 'pin_presentation_order_inputs' := ' <first input name> ', ' <next input names> '} {a...", 
"body" : "pin_presentation_order_inputs, pin_presentation_order_outputs 当 {attribute 'pingroup' := '<Group_Name>'} 使用了编译指示。 编译指示在 CFC、FBD 和 LD 图形编辑器中进行评估，导致受影响功能块的输入\/输出顺序按指定显示。您可以通过按所需顺序将输入\/输出的名称分配给属性来对顺序进行编程。 句法： {attribute 'pin_presentation_order_inputs' := ' <first input name> ', ' <next input names> '}\n{attribute 'pin_presentation_order_outputs' := ' <first output name> ', ' <next output names> '} ' <first input name> ', ' <next input names> ' 按所需顺序输入的逗号分隔名称 ' <first output name> ', ' <next output names> ' 按所需顺序以逗号分隔的输出名称 * 所有未指定名称的占位符 如果占位符丢失，则在末尾附加丢失的输入\/输出。 插入位置 功能块声明部分的顶行 例子 {attribute 'pin_presentation_order_inputs' := 'input_2,*,input_1'}\n{attribute 'pin_presentation_order_outputs' := 'output_2, output_1'}\nFUNCTION_BLOCK POU_BASE\nVAR_INPUT\n input_1 : BOOL;\n input_2 : INT;\n input_3 : INT;\n input_4 : INT;\nEND_VAR\nVAR_OUTPUT\n output_1 : BOOL;\n output_2 : INT;\n output_3 : INT;\n output_4 : BOOL;\nEND_VAR\n\nFUNCTION_BLOCK PLC_PRG\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n pouBase_A: POU_BASE;\nEND_VAR 在功能模块实例的表示中 pouBase_A ，编译指示导致输入和输出引脚的以下排列： " }, 
{ "title" : "属性：pack_mode ", 
"url" : "_cds_pragma_attribute_pack_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：pack_mode ", 
"snippet" : "pack_mode pragma 定义了在分配期间如何打包数据结构。该属性必须插入到数据结构之上并影响整个结构的打包。 句法 ： {attribute 'pack_mode' := ' <pack mode value> '} 插入位置：数据结构声明的上方 可能的值 <pack mode value> <打包模式值> 相关包装方式 描述 0 对齐 所有变量都分配给字节地址。没有记忆空白。 1 1 字节对齐 2 2 字节对齐 有 字节地址处的 1 字节变量 可被 2 整除的地址处的 2 字节变量。结果的最大间隙为 1 字节。 可被 2 整除的地址处的 4 字节变量。结果的最大间隙为 1 字节。 ...", 
"body" : "pack_mode pragma 定义了在分配期间如何打包数据结构。该属性必须插入到数据结构之上并影响整个结构的打包。 句法 ： {attribute 'pack_mode' := ' <pack mode value> '} 插入位置：数据结构声明的上方 可能的值 <pack mode value> <打包模式值> 相关包装方式 描述 0 对齐 所有变量都分配给字节地址。没有记忆空白。 1 1 字节对齐 2 2 字节对齐 有 字节地址处的 1 字节变量 可被 2 整除的地址处的 2 字节变量。结果的最大间隙为 1 字节。 可被 2 整除的地址处的 4 字节变量。结果的最大间隙为 1 字节。 可被 2 整除的地址处的 8 字节变量。结果最大间隙为 1 字节。 字符串始终位于字节地址。没有间隙结果。 4 4 字节对齐 有 字节地址处的 1 字节变量 可被 2 整除的地址处的 2 字节变量。结果的最大间隙为 1 字节。 可被 4 整除的地址处的 4 字节变量。结果的最大间隙为 3 字节。 可被 4 整除的地址处的 8 字节变量。结果的最大间隙为 3 字节。 字符串始终位于字节地址。没有间隙结果。 8 8 字节对齐 有 字节地址处的 1 字节变量 可被 2 整除的地址处的 2 字节变量。结果的最大间隙为 1 字节。 可被 4 整除的地址处的 4 字节变量。结果的最大间隙为 3 字节。 可被 8 整除的地址处的 8 个字节变量。结果的最大间隙为 7 个字节。 字符串始终位于字节地址。没有间隙结果。 根据结构的不同，各个模式的内存映射可能没有差异。例如，具有以下结构的内存分布 {attribute 'pack mode' := '4'} pragma 可以对应于 {attribute 'pack mode' := '8'} 。 结构数组 如果将结构组合成数组，则在结构的末尾添加字节，以便对齐下一个结构。 如果 兼容性布局 在符号配置中选择了选项，同时属性 'pack_mode' 在代码中使用，则可能由于无意的内存未对齐而出现问题。 使用时的负面影响 'pack-mode' 未对齐的内存访问可能是使用属性的结果 'pack_mode' .这意味着，例如，一个大小为 4 字节的数据类型位于一个不能被 4 整除的地址。通常，在 32 位系统上，一个 32 位数据类型可以用单内存访问。在某些平台上，例如在 ARM 平台上，仅当此值在内存中对齐时才有可能。在其他平台上，可能可以访问，但执行速度要慢得多。 {attribute 'pack_mode':=1}\n\nTYPE DUT\nSTRUCT\n by1 : BYTE;\n dw1 : DWORD;\nEND_STRUCT\nEND_TYPE 在 ARM 平台上，值 dw1 单次访问无法读取。当尝试直接访问此元素时，ARM 处理器将抛出异常。 假设：执行以下读取访问： dwTest := dut1.dw1; 对于这种访问 DWORD dw1 ，需要四次内存访问，因为每个字节都是单独读取、移位和分离的。该流程与以下示例中的流程有些相同，其中 DWORD 由四个字节的数组生成： dwHelp := bytes[0];\ndwResult := dwHelp;\ndwHelp := bytes[1];\ndwHelp := SHL(dwHelp, 8);\ndwResult := dwResult OR dwHelp;\ndwHelp := bytes[2];\ndwHelp := SHL(dwHelp, 16);\ndwResult := dwResult OR dwHelp;\ndwHelp := bytes[3];\ndwHelp := SHL(dwHelp, 24);\ndwResult := dwResult OR dwHelp; 显然，这种访问比访问一个 DWORD ，它在内存中适当地对齐。 pdw := ADR(dut1.dw1);\ndwTest := pdw^; 但是，当通过指针访问这种成员时，编译器不会生成示例的访问。这意味着以下代码会在 ARM 平台上导致异常。 pdw := ADR(dut1.dw1);\ndwTest := pdw^; 因此，出于性能原因，您应该避免使用未自然对齐的结构。 压缩结构不得包含未压缩结构。 " }, 
{ "title" : "示例 1 ", 
"url" : "_cds_pragma_attribute_pack_mode.html#UUID-c3d2a0b3-c4ff-c0ae-3564-f9f63f4a7e2b_id_a6bc74d60d70a21fc0a8640e001bdb68_id_6090971608ab9666c0a86463041fc5d3", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：pack_mode \/ 示例 1 ", 
"snippet" : "{attribute 'pack_mode' := '1'} TYPE myStruct: STRUCT Enable: BOOL; Counter: INT; MaxSize: BOOL; MaxSizeReached: BOOL; END_STRUCT END_TYPE 数据类型变量的内存范围 myStruct 被分配“对齐”。如果其组件的存储地址 Enable 是 0x0100 ，例如，那么组件 Counter 跟随地址 0x0101 , MaxSize 在地址 0x0103 和 MaxSizeReached 在地址 0x0104 .如果是 'pack_mode':=2 , Counte...", 
"body" : "{attribute 'pack_mode' := '1'}\n\nTYPE myStruct:\nSTRUCT\n Enable: BOOL;\n Counter: INT;\n MaxSize: BOOL;\n MaxSizeReached: BOOL;\n END_STRUCT\nEND_TYPE 数据类型变量的内存范围 myStruct 被分配“对齐”。如果其组件的存储地址 Enable 是 0x0100 ，例如，那么组件 Counter 跟随地址 0x0101 , MaxSize 在地址 0x0103 和 MaxSizeReached 在地址 0x0104 .如果是 'pack_mode':=2 , Counter 会在 0x0102 , MaxSize 在 0x0104 和 MaxSizeReached 在 0x0105 . " }, 
{ "title" : "示例 2 ", 
"url" : "_cds_pragma_attribute_pack_mode.html#UUID-c3d2a0b3-c4ff-c0ae-3564-f9f63f4a7e2b_id_a6bc74d60d70a21fc0a8640e001bdb68_id_c397029808b522b2c0a86463026f3ca1", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：pack_mode \/ 示例 2 ", 
"snippet" : "STRUCT Var1 : BOOL := 16#01; Var2 : BYTE := 16#11; Var3 : WORD := 16#22; Var4 : BYTE := 16#44; Var5 : DWORD := 16#88776655; Var6 : BYTE := 16#99; Var7 : BYTE := 16#AA; Var8 : DWORD := 16#AA; END_TYPE pack_mode = 8 pack_mode = 0 pack_mode = 1 pack_mode = 2 pack_mode = 4 多变的 价值 多变的 价值 多变的 价值 多变的 价值 多变...", 
"body" : "STRUCT\n Var1 : BOOL := 16#01;\n Var2 : BYTE := 16#11;\n Var3 : WORD := 16#22;\n Var4 : BYTE := 16#44;\n Var5 : DWORD := 16#88776655;\n Var6 : BYTE := 16#99;\n Var7 : BYTE := 16#AA;\n Var8 : DWORD := 16#AA;\nEND_TYPE pack_mode = 8 pack_mode = 0 pack_mode = 1 pack_mode = 2 pack_mode = 4 多变的 价值 多变的 价值 多变的 价值 多变的 价值 多变的 价值 0 Var1 01 Var1 01 Var1 01 Var1 01 Var1 01 1 Var2 11 Var2 11 Var2 11 Var2 11 Var2 11 2 Var3 22 Var3 22 Var3 22 Var3 22 Var3 22 3 … 00 … 00 … 00 … 00 … 00 4 Var4 44 Var4 44 Var4 44 Var4 44 Var4 44 5 Var5 55 Var5 55 6 … 66 … 66 Var5 55 7 … 77 … 77 … 66 8 Var5 55 … 88 … 88 … 77 Var5 55 9 … 66 Var6 99 Var6 99 … 88 … 66 10 … 77 Var7 AA Var7 AA Var6 99 … 77 11 … 88 Var8 AA Var8 AA Var7 AA … 88 12 Var6 99 … 00 … 00 Var8 AA Var6 99 13 Var7 AA … 00 … 00 … 00 Var7 AA 14 … 00 … 00 … 00 15 … 00 16 Var8 AA Var8 AA 17 … 00 … 00 18 … 00 … 00 19 … 00 … 00 20 21 22 23 24 25 26 27 28 29 30 31 " }, 
{ "title" : "示例 3 ", 
"url" : "_cds_pragma_attribute_pack_mode.html#UUID-c3d2a0b3-c4ff-c0ae-3564-f9f63f4a7e2b_id_a6bc74d60d70a21fc0a8640e001bdb68_id_7104e54be5bdcfb2c0a864634981a863", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：pack_mode \/ 示例 3 ", 
"snippet" : "STRUCT Var1 : BYTE := 16#01; Var2 : LWORD := 16#11; Var3 : BYTE := 16#22; Var4 : BYTE := 16#44; Var5 : DWORD := 16#88776655; Var6 : BYTE := 16#99; Var7 : BYTE := 16#AA; Var8 : WORD := 16#AA; END_TYPE pack_mode = 8 pack_mode = 0 pack_mode = 1 pack_mode = 2 pack_mode = 4 多变的 价值 多变的 价值 多变的 价值 多变的 价值 多变...", 
"body" : "STRUCT\n Var1 : BYTE := 16#01;\n Var2 : LWORD := 16#11;\n Var3 : BYTE := 16#22;\n Var4 : BYTE := 16#44;\n Var5 : DWORD := 16#88776655;\n Var6 : BYTE := 16#99;\n Var7 : BYTE := 16#AA;\n Var8 : WORD := 16#AA;\nEND_TYPE pack_mode = 8 pack_mode = 0 pack_mode = 1 pack_mode = 2 pack_mode = 4 多变的 价值 多变的 价值 多变的 价值 多变的 价值 多变的 价值 0 Var1 01 Var1 01 Var1 01 Var1 01 Var1 01 1 Var2 11 Var2 11 2 … 00 … 00 Var2 11 3 … 00 … 00 … 00 4 … 00 … 00 … 00 Var2 11 5 … 00 … 00 … 00 … 00 6 … 00 … 00 … 00 … 00 7 … 00 … 00 … 00 … 00 8 Var2 11 … 00 … 00 … 00 … 00 9 … 00 Var3 22 Var3 22 … 00 … 00 10 … 00 Var4 44 Var4 44 Var3 22 … 00 11 … 00 Var5 55 Var5 55 Var4 44 … 00 12 … 00 … 66 … 66 Var5 55 Var3 22 13 … 00 … 77 … 77 … 66 Var4 44 14 … 00 … 88 … 88 … 77 15 … 00 Var6 99 Var6 99 … 88 16 Var3 22 Var7 AA Var7 AA Var6 99 Var5 55 17 Var4 44 Var8 AA Var8 AA Var7 AA … 66 18 … 00 … 00 Var8 AA … 77 19 … 00 … 88 20 Var5 55 Var6 99 21 … 66 Var7 AA 22 … 77 Var8 AA 23 … 88 … 00 24 Var6 99 25 Var7 AA 26 Var8 AA 27 … 00 28 29 30 31 " }, 
{ "title" : "没有的行为 'pack-mode' ", 
"url" : "_cds_pragma_attribute_pack_mode.html#UUID-c3d2a0b3-c4ff-c0ae-3564-f9f63f4a7e2b_id_a6bc74d60d70a21fc0a8640e001bdb68_id_4b241196e5bdcfb2c0a864631282e50a", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：pack_mode \/ 没有的行为 'pack-mode' ", 
"snippet" : "如果 'pack-mode' 不使用，则编译器通常使用打包模式 4 或 8，具体取决于设备描述。在每种情况下，都使用对处理器特别有利的打包模式，以便可以执行内存访问。这也称为自然对齐或数据的自然对齐...", 
"body" : "如果 'pack-mode' 不使用，则编译器通常使用打包模式 4 或 8，具体取决于设备描述。在每种情况下，都使用对处理器特别有利的打包模式，以便可以执行内存访问。这也称为自然对齐或数据的自然对齐 " }, 
{ "title" : "属性：过程值 ", 
"url" : "_cds_pragma_attribute_processvalue.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：过程值 ", 
"snippet" : "ProcessValue 随着 'ProcessValue' 属性，你装饰一个结构的成员。在 CFC 编辑器中，您可以使用 使用属性成员作为输入 命令以便将此结构连接到标量类型的输入。 句法 ： {attribute 'ProcessValue'} 插入位置：受影响的结构成员上方的线。 例子 TYPE QINT : STRUCT Status : STRING; {attribute 'ProcessValue'} Value1 : INT; Value2 : INT; END_STRUCT END_TYPE...", 
"body" : "ProcessValue 随着 'ProcessValue' 属性，你装饰一个结构的成员。在 CFC 编辑器中，您可以使用 使用属性成员作为输入 命令以便将此结构连接到标量类型的输入。 句法 ： {attribute 'ProcessValue'} 插入位置：受影响的结构成员上方的线。 例子 TYPE QINT :\nSTRUCT\n Status : STRING;\n {attribute 'ProcessValue'}\n Value1 : INT;\n Value2 : INT;\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "属性：qualified_only ", 
"url" : "_cds_pragma_attribute_qualified_only.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：qualified_only ", 
"snippet" : "qualified_only 这个 pragma 的效果是全局变量列表的变量只能通过指定全局变量名来寻址，例如 gvl.g_var .这也适用于 Enumeration 类型的变量，有助于避免被误认为是局部变量。 句法 ： {attribute 'qualified_only'} 插入位置：上一行 VAR_GLOBAL 在 GVL 中 例子 全局变量列表 GVL ： {attribute 'qualified_only'} VAR_GLOBAL iVar:INT; END_VAR 例如，在 POU 内 PLC_PRG , 全局变量 iVar 只能使用前缀来寻址 GVL ： GVL.iVar:=...", 
"body" : "qualified_only 这个 pragma 的效果是全局变量列表的变量只能通过指定全局变量名来寻址，例如 gvl.g_var .这也适用于 Enumeration 类型的变量，有助于避免被误认为是局部变量。 句法 ： {attribute 'qualified_only'} 插入位置：上一行 VAR_GLOBAL 在 GVL 中 例子 全局变量列表 GVL ： {attribute 'qualified_only'}\nVAR_GLOBAL\n iVar:INT;\nEND_VAR 例如，在 POU 内 PLC_PRG , 全局变量 iVar 只能使用前缀来寻址 GVL ： GVL.iVar:=5; 相反，以下不完整的变量调用将产生错误： iVar:=5; " }, 
{ "title" : "属性：reflection ", 
"url" : "_cds_pragma_attribute_reflection.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：reflection ", 
"snippet" : "reflection pragma 修饰 POU 以供编译器搜索功能块变量，这些变量用 'instance-path' 属性或 'is_connected' 属性。具有这些类型变量的 POU 需要特殊处理。 编译器只搜索用 'reflection' 对于具有这些属性的变量，因此需要更少的时间。 句法 ： {attribute 'reflection'} 有关更多信息，请参阅： instance-path 和 is_connected...", 
"body" : "reflection pragma 修饰 POU 以供编译器搜索功能块变量，这些变量用 'instance-path' 属性或 'is_connected' 属性。具有这些类型变量的 POU 需要特殊处理。 编译器只搜索用 'reflection' 对于具有这些属性的变量，因此需要更少的时间。 句法 ： {attribute 'reflection'} 有关更多信息，请参阅： instance-path 和 is_connected" }, 
{ "title" : "属性：subsequent ", 
"url" : "_cds_pragma_attribute_subsequent.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：subsequent ", 
"snippet" : "subsequent VAR_TEMP 在具有属性的程序中 'subsequent' 导致编译器错误。 pragma 用于在内存中分配连续的变量。当列表发生变化时，整个变量列表被分配到一个新的内存区域。此编译指示用于程序和全局变量列表。 句法 ： {attribute 'subsequent'} 当列表中的变量限定为 RETAIN ，声明部分的所有变量都存放在内存区域中 RETAIN ....", 
"body" : "subsequent VAR_TEMP 在具有属性的程序中 'subsequent' 导致编译器错误。 pragma 用于在内存中分配连续的变量。当列表发生变化时，整个变量列表被分配到一个新的内存区域。此编译指示用于程序和全局变量列表。 句法 ： {attribute 'subsequent'} 当列表中的变量限定为 RETAIN ，声明部分的所有变量都存放在内存区域中 RETAIN . " }, 
{ "title" : "属性：to_string ", 
"url" : "_cds_pragma_attribute_to_string.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：to_string ", 
"snippet" : "to_string pragma 会影响将枚举组件与 TO_STRING 运算符是输出。如果枚举声明具有 pragma，则枚举组件的名称显示为字符串而不是数值。 句法： {attribute 'to_string'} 插入位置：枚举声明部分上方的第一行。 例子 枚举声明 color ： {attribute 'to_string'} TYPE COLOR: ( red := 0, blue := 1, green := 2 ); END_TYPE 转换为 TO_STRING ： PROGRAM PLC_PRG VAR i_color: COLOR; s_show_color: STRING; ...", 
"body" : "to_string pragma 会影响将枚举组件与 TO_STRING 运算符是输出。如果枚举声明具有 pragma，则枚举组件的名称显示为字符串而不是数值。 句法： {attribute 'to_string'} 插入位置：枚举声明部分上方的第一行。 例子 枚举声明 color ： {attribute 'to_string'}\nTYPE COLOR:\n(\n red := 0,\n blue := 1,\n green := 2\n);\nEND_TYPE 转换为 TO_STRING ： PROGRAM PLC_PRG\nVAR\n i_color: COLOR;\n s_show_color: STRING;\nEND_VAR\ni_color := 1;\ns_show_color := TO_STRING(i_color); 在这种情况下， s_show_color 获取值 'blue' 代替 1 作为转换结果。 " }, 
{ "title" : "属性：suppress_warning ", 
"url" : "_cds_pragma_attribute_suppress_warning.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：suppress_warning ", 
"snippet" : "suppress_warning 该指令的效果是抑制该指令定义中指定的编译器警告。 句法： {attribute 'suppress_warning' := '<warning id1>','<warning id2>',...} 插入点：POU 或 DUT 声明部分上方的行 例子 {attribute 'suppress_warning' := '0125'} TYPE DUT_1 : ( enum_member1 := 0, enum_member2 := 0 ); END_TYPE 警告 C0125 被抑制。...", 
"body" : "suppress_warning 该指令的效果是抑制该指令定义中指定的编译器警告。 句法： {attribute 'suppress_warning' := '<warning id1>','<warning id2>',...} 插入点：POU 或 DUT 声明部分上方的行 例子 {attribute 'suppress_warning' := '0125'}\nTYPE DUT_1 :\n(\n enum_member1 := 0,\n enum_member2 := 0\n);\nEND_TYPE\n 警告 C0125 被抑制。 " }, 
{ "title" : "属性：warning disable, warning restore ", 
"url" : "_cds_pragma_attribute_warning_disable.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 属性编译指示 \/ 属性：warning disable, warning restore ", 
"snippet" : "warning disable , warning restore 这 warning disable 属性具有抑制特定警告的效果。这 warning restore pragma 重新激活被抑制的消息。 此属性可用于每个编译器警告。您可以在 CODESYS Development System 在项目的项目设置中（ 项目 → 项目设置 ， 编译器警告 类别）。 句法 ： {warning disable <compiler ID>} {warning restore <compiler ID>} <compiler ID> : 位于错误或警告消息开头的 ID。 例子 编译器消息： typif...", 
"body" : "warning disable , warning restore 这 warning disable 属性具有抑制特定警告的效果。这 warning restore pragma 重新激活被抑制的消息。 此属性可用于每个编译器警告。您可以在 CODESYS Development System 在项目的项目设置中（ 项目 → 项目设置 ， 编译器警告 类别）。 句法 ： {warning disable <compiler ID>} {warning restore <compiler ID>} <compiler ID> : 位于错误或警告消息开头的 ID。 例子 编译器消息： typify code ...\nC0195: Implicit conversion from unsigned Type 'UINT' to signed Type 'INT' : possible change of sign\nCompile complete -- 0 errors 将编译指示应用于变量声明： VAR\n {warning disable C0195}\n test1 : UINT := -1;\n {warning restore C0195}\n test2 : UINT := -1;\nEND_VAR test1 不生成警告； test2 生成警告。 " }, 
{ "title" : "条件指令 ", 
"url" : "_cds_pragma_conditional.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 ", 
"snippet" : "条件指令的限制 仅在 POU 的实现中使用编译指示进行条件编译。在声明中，这些编译指示会被忽略，而不会被求值。 请注意以下例外：带有 project_defined 运算符可以插入到声明中。有关更多信息，请参阅以下内容：IF pragma with project_defined (<global define>)编译器会在预编译操作和编译操作期间评估这些指令。此操作称为条件编译。ST 实现语言支持这些指令。 这 {IF<expression> } 语句与 {ELSIF<expression> } ， {ELSE} 以及结论 {END_IF} 指示实现中根据指定条件保留或忽略的代码。 <exp...", 
"body" : "条件指令的限制 仅在 POU 的实现中使用编译指示进行条件编译。在声明中，这些编译指示会被忽略，而不会被求值。 请注意以下例外：带有 project_defined 运算符可以插入到声明中。有关更多信息，请参阅以下内容：IF pragma with project_defined (<global define>)编译器会在预编译操作和编译操作期间评估这些指令。此操作称为条件编译。ST 实现语言支持这些指令。 这 {IF<expression> } 语句与 {ELSIF<expression> } ， {ELSE} 以及结论 {END_IF} 指示实现中根据指定条件保留或忽略的代码。 <expression> 是由不同的操作数和运算符组成的整数常量表达式。 编译时， <{IF <expression>} 被求值。如果其返回值为 FALSE ，那么分支将发生在下一个 {ELSIF <expression>} 段和表达式在那里计算，直到一个段返回一个表达式 TRUE 。表达式将依次求值，直到其中一个返回非 0 的值。只有与正表达式关联的这一个代码段才会被编译。其他代码段将被忽略。如果所有表达式都返回 0，则分支发生在 {ELSE} . 如果 {ELSE} 如果缺少 pragma，则可能会发生没有代码段被编译的情况。 句法 代码片段示例 描述 {IF <expression> } {IF defined (DEF0815)}\n{info 'DEF0815 has been defined'}\nCnt0815 := iCnt0815 + 1; 标记在有效的情况下编译的代码段的开头 <expression> 健康）状况。 {ELSIF <expression> } {ELSIF defined (DEF0816)}\n{info 'DEF0815 has been defined'}\niCnt0816 := iCnt0816 + 1; 无、一个或多个） 如果存在有效代码段，则分支标记替代代码段 <expression> 状况 {ELSE} {ELSE}\n{info 'DEF0815 not defined'}\niCnt0 := iCnt0 - 1; 选修的 分支标记了在先前条件不满足时编译的代码段 {END_IF} {END_IF} 标记条件代码段的结束 <expression> defined (DEF0815) 健康）状况 整数表达式在编译时为常量，可以由运算符和操作数组成，例如编译器定义、变量或文字 " }, 
{ "title" : "编译器定义 ", 
"url" : "_cds_pragma_conditional.html#UUID-9d13f749-64d4-ea6e-d526-1046cb95981c_section-idm13512919386826", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 编译器定义 ", 
"snippet" : "编译器定义用作代码中特定状态的标签。可以使用定义的运算符来设置、删除或检查编译器定义。 句法 例子 描述 {define <name> } {define DEF0815} 定义编译器定义 <name> 带有类型 BOOL 编译器定义 <name> 遵守有效标识符的规则。 {define <name> <string> } {define DEF0123 '123'} 定义编译器定义 <name> 并分配字符串文字 <string> 作为一种价值 {undefine <name>} {undefine DEF0815} 删除编译器定义 <name> 因此，该标识符未定义。编译器未定义的编译指示...", 
"body" : "编译器定义用作代码中特定状态的标签。可以使用定义的运算符来设置、删除或检查编译器定义。 句法 例子 描述 {define <name> } {define DEF0815} 定义编译器定义 <name> 带有类型 BOOL 编译器定义 <name> 遵守有效标识符的规则。 {define <name> <string> } {define DEF0123 '123'} 定义编译器定义 <name> 并分配字符串文字 <string> 作为一种价值 {undefine <name>} {undefine DEF0815} 删除编译器定义 <name> 因此，该标识符未定义。编译器未定义的编译指示将被忽略。 或者，您也可以在 POU 的属性中本地定义表达式和编译器定义，或者在上级应用程序的属性中在应用程序范围内定义表达式和编译器定义。 为此，请在设备树中选择 POU 或上级应用程序。在上下文菜单中，点击 特性 然后选择 建造 选项卡中 编译器定义 输入字段，您可以定义一个文字或表达式（例如：DEF0815）。输入字段不需要像 {define } ，而只是一个名字。 您可以指定多个编译器定义，以逗号分隔。 " }, 
{ "title" : "运营商 ", 
"url" : "_cds_pragma_conditional.html#UUID-7d0f412c-5a63-338b-4d5a-f9f63d4bbeb3", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "defined (variable: <variable name> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-56a3dfa0-d8ff-39b2-d406-47873393107c", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ defined (variable: <variable name> ) ", 
"snippet" : "运算符使表达式被赋予值 TRUE 当变量 <variable name> 在当前范围内声明。否则 FALSE 被退回。 示例 要求：两个应用程序 App1 和 App2 存在。变量 g_bTest 被声明在 App1 ，但不在 App2 . {IF defined (variable: g_bTest)} (* the following code is only processed in App2*) g_bTest := x > 300; {END_IF}...", 
"body" : "运算符使表达式被赋予值 TRUE 当变量 <variable name> 在当前范围内声明。否则 FALSE 被退回。 示例 要求：两个应用程序 App1 和 App2 存在。变量 g_bTest 被声明在 App1 ，但不在 App2 . {IF defined (variable: g_bTest)}\n (* the following code is only processed in App2*)\n g_bTest := x > 300;\n{END_IF} " }, 
{ "title" : "defined (<identifier>) ", 
"url" : "_cds_pragma_conditional.html#UUID-e54af038-800e-5327-8957-cece6e7ac986", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ defined (<identifier>) ", 
"snippet" : "运算符使表达式被赋予值 TRUE .要求是标识符 <identifier> 已经通过定义 {define} 声明并且之后没有未定义 {undefine} 陈述。否则 FALSE 被退回。 要求：应用程序 App1 和 App2 存在。这 pdef1 变量由 a 定义 {define} 中的声明 App1 ，但不在 App2 . {IF defined (pdef1)} (* This code is processed in App1 *) {info 'pdef1 defined'} hugo := hugo + SINT#1; {ELSE} (* the following code is...", 
"body" : "运算符使表达式被赋予值 TRUE .要求是标识符 <identifier> 已经通过定义 {define} 声明并且之后没有未定义 {undefine} 陈述。否则 FALSE 被退回。 要求：应用程序 App1 和 App2 存在。这 pdef1 变量由 a 定义 {define} 中的声明 App1 ，但不在 App2 . {IF defined (pdef1)}\n(* This code is processed in App1 *)\n{info 'pdef1 defined'}\n hugo := hugo + SINT#1;\n{ELSE}\n(* the following code is only processed in App2 *)\n{info 'pdef1 not defined'}\n hugo := hugo - SINT#1;\n{END_IF} 这还包括一个消息杂注的示例：仅消息 pdef1 defined 编译应用程序时显示在消息视图中，因为 pdef1 实际上是定义的。讯息 pdef1 not defined 时显示 pdef1 没有定义。 " }, 
{ "title" : "defined (type: <identifier> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-c146e29c-1435-150f-39b5-3565709c5179", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ defined (type: <identifier> ) ", 
"snippet" : "运算符使表达式被赋予值 TRUE 当使用标识符声明数据类型时 <identifier> .否则 FALSE 被退回。 示例 要求：两个应用程序 App1 和 App2 存在。数据类型 DUT 被声明在 App1 ，但不在 App2 . {IF defined (type: DUT)} (* the following code is only processed in App1*) bDutDefined := TRUE; {END_IF}...", 
"body" : "运算符使表达式被赋予值 TRUE 当使用标识符声明数据类型时 <identifier> .否则 FALSE 被退回。 示例 要求：两个应用程序 App1 和 App2 存在。数据类型 DUT 被声明在 App1 ，但不在 App2 . {IF defined (type: DUT)}\n (* the following code is only processed in App1*)\n bDutDefined := TRUE;\n{END_IF} " }, 
{ "title" : "defined (pou: <pou name>) ", 
"url" : "_cds_pragma_conditional.html#UUID-17139d7e-07b4-d059-ab0e-e4045ec20bd0", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ defined (pou: <pou name>) ", 
"snippet" : "运算符使表达式被赋予值 TRUE 当以下具有名称的对象之一 <pou-name> 存在： 功能块 功能 程序 行动 方法 界面 否则 FALSE 被退回。 示例 要求：两个应用程序 App1 和 App2 存在。 POU CheckBounds 存在于 App1 ，但不在 App2 . {IF defined (pou: CheckBounds)} (* the following code is only processed in App1 *) arrTest[CheckBounds(0,i,10)] := arrTest[CheckBounds(0,i,10)] + 1; {ELSE} ...", 
"body" : "运算符使表达式被赋予值 TRUE 当以下具有名称的对象之一 <pou-name> 存在： 功能块 功能 程序 行动 方法 界面 否则 FALSE 被退回。 示例 要求：两个应用程序 App1 和 App2 存在。 POU CheckBounds 存在于 App1 ，但不在 App2 . {IF defined (pou: CheckBounds)}\n (* the following code is only processed in App1 *)\n arrTest[CheckBounds(0,i,10)] := arrTest[CheckBounds(0,i,10)] + 1;\n{ELSE}\n (* the following code is only processed in App2 *)\n arrTest[i] := arrTest[i]+1;\n{END_IF} " }, 
{ "title" : "defined (resource: <identifier>) ", 
"url" : "_cds_pragma_conditional.html#UUID-0a21b728-bc6a-38b2-4fa2-d84b00fc80ee", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ defined (resource: <identifier>) ", 
"snippet" : "尚未实施 运算符使表达式被赋予值 TRUE 如果一个资源对象名为 <identifier> 为申请而存在；否则 FALSE 被退回。 要求：两个应用程序 App1 和 App2 存在。资源对象 glob_var1 的全局变量列表存在于 App1 , 但不是为了 App2 . {IF defined (resource:glob_var1)} (* the following code is only processed in App1 *) gvar_x := gvar_x + ivar; {ELSE} (* the following code is only processed in Ap...", 
"body" : "尚未实施 运算符使表达式被赋予值 TRUE 如果一个资源对象名为 <identifier> 为申请而存在；否则 FALSE 被退回。 要求：两个应用程序 App1 和 App2 存在。资源对象 glob_var1 的全局变量列表存在于 App1 , 但不是为了 App2 . {IF defined (resource:glob_var1)}\n (* the following code is only processed in App1 *)\n gvar_x := gvar_x + ivar;\n{ELSE}\n (* the following code is only processed in App2 *)\n x := x + ivar;\n{END_IF} " }, 
{ "title" : "defined (task: <task name> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-ccc52caa-f156-4e60-c0cd-17886ea9795b", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ defined (task: <task name> ) ", 
"snippet" : "运算符使表达式被赋予值 TRUE 当使用名称定义任务时 <task name> .否则 FALSE 被退回。 句法 { IF defined (task: <task name> } { ELSIF defined (task: <task name> } 例子 {IF defined (task: Task_D)} 例子 要求：两个应用程序 App1 和 App2 存在。任务 PLC_PRG_Task 定义在 App1 ，但不在 App2 . {IF defined (task: PLC_PRG_Task)} (* the following code is only processed i...", 
"body" : "运算符使表达式被赋予值 TRUE 当使用名称定义任务时 <task name> .否则 FALSE 被退回。 句法 { IF defined (task: <task name> }\n{ ELSIF defined (task: <task name> } 例子 {IF defined (task: Task_D)} 例子 要求：两个应用程序 App1 和 App2 存在。任务 PLC_PRG_Task 定义在 App1 ，但不在 App2 . {IF defined (task: PLC_PRG_Task)}\n (* the following code is only processed in App1 *)\n erg := plc_prg.x;\n{ELSE}\n (* the following code is only processed in App2 *)\n erg := prog.x;\n{END_IF} " }, 
{ "title" : "defined (IsLittleEndian) ", 
"url" : "_cds_pragma_conditional.html#UUID-516da2c9-04fd-3845-f55a-087fc2d2aeab", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ defined (IsLittleEndian) ", 
"snippet" : "运算符使表达式被赋予值 FALSE 当 CPU 内存以 Big Endian（摩托罗拉字节顺序）组织时。...", 
"body" : "运算符使表达式被赋予值 FALSE 当 CPU 内存以 Big Endian（摩托罗拉字节顺序）组织时。 " }, 
{ "title" : "defined (IsSimulationMode) ", 
"url" : "_cds_pragma_conditional.html#UUID-3ab4b0b9-4bdc-b8a9-4b97-18745c21d26d", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ defined (IsSimulationMode) ", 
"snippet" : "运算符使表达式被赋予值 TRUE 当应用程序在模拟设备上运行时（在模拟模式下）。 有关更多信息，请参阅： 在模拟模式下测试...", 
"body" : "运算符使表达式被赋予值 TRUE 当应用程序在模拟设备上运行时（在模拟模式下）。 有关更多信息，请参阅： 在模拟模式下测试" }, 
{ "title" : "defined (IsFPUSupported) ", 
"url" : "_cds_pragma_conditional.html#UUID-77021421-79d5-0d58-faff-96b1b4636fcc", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ defined (IsFPUSupported) ", 
"snippet" : "如果表达式返回值 TRUE ，然后代码生成器在计算时生成一个 FPU 代码（用于浮点单元处理器） REAL 价值观。否则会模拟 FPU 操作，这要慢得多。...", 
"body" : "如果表达式返回值 TRUE ，然后代码生成器在计算时生成一个 FPU 代码（用于浮点单元处理器） REAL 价值观。否则会模拟 FPU 操作，这要慢得多。 " }, 
{ "title" : "hasattribute (pou: <pou name>, ' <attribute name> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-5ca43390-2187-c6be-b000-d6a460e76960", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ hasattribute (pou: <pou name>, ' <attribute name> ') ", 
"snippet" : "运算符使表达式被赋予值 TRUE 当属性 <attribute> 在功能块声明部分的第一行指定 <pou name> .否则 FALSE 被退回。 例子 要求：两个应用程序 App1 和 App2 存在。功能 fun1 被声明在 App1 和 App2 .然而，在 App1 它还提供了 pragma {attribute 'vision'} . 在 App1 ： {attribute 'vision'} FUNCTION fun1 : INT VAR_INPUT i : INT; END_VAR VAR END_VAR 在 App2 ： FUNCTION fun1 : INT VAR_INPU...", 
"body" : "运算符使表达式被赋予值 TRUE 当属性 <attribute> 在功能块声明部分的第一行指定 <pou name> .否则 FALSE 被退回。 例子 要求：两个应用程序 App1 和 App2 存在。功能 fun1 被声明在 App1 和 App2 .然而，在 App1 它还提供了 pragma {attribute 'vision'} . 在 App1 ： {attribute 'vision'}\nFUNCTION fun1 : INT\nVAR_INPUT\n i : INT;\nEND_VAR\nVAR\nEND_VAR 在 App2 ： FUNCTION fun1 : INT\nVAR_INPUT\n i : INT;\nEND_VAR\nVAR\nEND_VAR Pragma 声明： {IF hasattribute (pou: fun1, 'vision')}\n (* the following code is only processed in App1 *)\n ergvar := fun1(ivar);\n{END_IF} " }, 
{ "title" : "hasattribute (variable: <variable name> , ' <attribute name> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-acc24196-3e5c-73ec-b19f-e7572000a697", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ hasattribute (variable: <variable name> , ' <attribute name> ') ", 
"snippet" : "运算符使表达式被赋予值 TRUE 当编译指示 {attribute '<attribute>'} 在变量声明之前的行中分配给变量。否则 FALSE 被退回。 例子 要求：两个应用程序 App1 和 App2 存在。变量 g_globalInt 用于 App1 和 App2 ， 但在 App1 属性 'DoCount' 也分配给它。 宣言 g_GlobalInt 在 App1 VAR_GLOBAL {attribute 'DoCount'} g_globalInt : INT; g_multiType : STRING; END_VAR 宣言 g_GlobalInt 在 App2 ： VAR_G...", 
"body" : "运算符使表达式被赋予值 TRUE 当编译指示 {attribute '<attribute>'} 在变量声明之前的行中分配给变量。否则 FALSE 被退回。 例子 要求：两个应用程序 App1 和 App2 存在。变量 g_globalInt 用于 App1 和 App2 ， 但在 App1 属性 'DoCount' 也分配给它。 宣言 g_GlobalInt 在 App1 VAR_GLOBAL\n {attribute 'DoCount'}\n g_globalInt : INT;\n g_multiType : STRING;\nEND_VAR 宣言 g_GlobalInt 在 App2 ： VAR_GLOBAL\n g_globalInt : INT;\n g_multiType : STRING;\nEND_VAR Pragma 声明： {IF hasattribute (variable: g_globalInt, 'DoCount')}\n (* the following code is only processed in App1 *)\n g_globalInt := g_globalInt + 1;\n{END_IF} " }, 
{ "title" : "hasconstanttype( <constant name> , <boolean literal> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-30672799-4e6a-2fbc-3929-5daa20235b68", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ hasconstanttype( <constant name> , <boolean literal> ) ", 
"snippet" : "操作员检查常量是否用 <constant name> , 已被替换。第二个参数（布尔值）控制检查的内容： TRUE : 检查常量是否被替换 FALSE : 检查常量是否未被替换 当相应的情况发生时，运算符返回 TRUE . 句法 { IF hasconstanttype( <constant namne> , <boolean literal> ) } { ELSIF hasconstanttype( <constant namne> , <boolean literal> ) } 例子 {IF hasconstanttype(PLC_PRG.aConst, TRUE)} 常量的自动替换原则上...", 
"body" : "操作员检查常量是否用 <constant name> , 已被替换。第二个参数（布尔值）控制检查的内容： TRUE : 检查常量是否被替换 FALSE : 检查常量是否未被替换 当相应的情况发生时，运算符返回 TRUE . 句法 { IF hasconstanttype( <constant namne> , <boolean literal> ) } { ELSIF hasconstanttype( <constant namne> , <boolean literal> ) } 例子 {IF hasconstanttype(PLC_PRG.aConst, TRUE)} 常量的自动替换原则上取决于以下几点： 编译选项 替换常量 常量类型（例如， STRING 类型永远不会被替换。） 属性的使用 {attribute 'const_non_replaced'} 属性的使用 {attribute 'const_replaced'} 例子 VAR\n iCntMAXIsReplaced: INT;\n xErrorOccured : BOOL;\nEND_VAR\nVAR CONSTANT\n c_iMAX: INT := 99;\nEND_VAR\n\n{IF hasconstanttype(c_iMAX, TRUE)}\n iCntMAXIsReplaced := iCntMAXIsReplaced + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF} " }, 
{ "title" : "hasconstantvalue( <constant name> , <variable name> , <comparison operator> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-f4c0c696-3507-eafb-ef9c-09e853c3e51a", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ hasconstantvalue( <constant name> , <variable name> , <comparison operator> ) ", 
"snippet" : "运算符比较常量的值，该常量用 <constant name> ，与第二个参数的值。第二个参数可以指定为文字 <literal> 或作为变量 <variable name> . 比较运算符 <comparison operator> ： 比...更棒 （ > ) 大于或等于 ( >= ) 等于 （ = ) 不等于 （ <> ) 小于或等于 ( <= ) 少于 （ < ) 句法 { IF hasconstantvalue( <constant name> , <variable name> , <comparison operator> ) { IF hasconstantvalue( <cons...", 
"body" : "运算符比较常量的值，该常量用 <constant name> ，与第二个参数的值。第二个参数可以指定为文字 <literal> 或作为变量 <variable name> . 比较运算符 <comparison operator> ： 比...更棒 （ > ) 大于或等于 ( >= ) 等于 （ = ) 不等于 （ <> ) 小于或等于 ( <= ) 少于 （ < ) 句法 { IF hasconstantvalue( <constant name> , <variable name> , <comparison operator> ) { IF hasconstantvalue( <constant name> , <literal> , <comparison operator> ) { ELSIF hasconstantvalue( <constant name> , <variable name> , <comparison operator> ) { ELSIF hasconstantvalue( <constant name> , <literal> , <comparison operator> ) 例子 {IF hasconstantvalue(PLC_PRG.aConst, 99, >)} {ELSIF hasconstantvalue(PLC_PRG.aConst, GVL.intconst99, =)} 例子 PROGRAM PRG_ConditionConstantValue\nVAR\n iCntMAX: INT;\n iCntGlobalMAX : INT;\n iCntABC: INT;\n iCntGlobalABC : INT;\n xErrorOccured : BOOL;\nEND_VAR\nVAR CONSTANT\n c_iMAX: INT := 999;\n c_sABC: STRING := 'ABC';\n {attribute 'const_non_replaced'}\n c_iNonReplaceable: INT := 888;\nEND_VAR\n\n{IF hasconstantvalue(c_iMAX, 999, =)}\n iCntMAX := iCntMAX + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF}\n\n{IF hasconstantvalue(c_iMAX, GVL.gc_iMAX, =)}\n iCntGlobalMAX := iCntGlobalMAX + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF}\n\n{IF hasconstantvalue(c_sABC, 'ABC', =)}\n iCntABC := iCntMAX + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF}\n{IF hasconstantvalue(c_sABC, GVL.gc_sABC, =)}\n iCntGlobalABC := iCntMAX + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF} " }, 
{ "title" : "hastype (variable: <variable name>, <data type> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-92747db0-9849-d5df-f302-8252875bbffa", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ hastype (variable: <variable name>, <data type> ) ", 
"snippet" : "运算符使表达式被赋予值 TRUE 当变量 <variable> 属于数据类型 <type-spec> .否则 FALSE 被退回。 可能的数据类型： BOOL | BYTE | DATE | DATE_AND_TIME | DT | DINT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTIME_OF_DAY | LTOD | LWORD | REAL | SINT | STRING | TIME | TIME_OF_DAY | TOD | ULINT | UDINT | UINT | USINT...", 
"body" : "运算符使表达式被赋予值 TRUE 当变量 <variable> 属于数据类型 <type-spec> .否则 FALSE 被退回。 可能的数据类型： BOOL | BYTE | DATE | DATE_AND_TIME | DT | DINT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTIME_OF_DAY | LTOD | LWORD | REAL | SINT | STRING | TIME | TIME_OF_DAY | TOD | ULINT | UDINT | UINT | USINT | WORD | WSTRING 例子 要求：两个应用程序 App1 和 App2 存在。变量 g_multitype 被声明在 App1 有数据类型 LREAL ， 在 App2 有数据类型 STRING . {IF (hastype (variable: g_multitype, LREAL))}\n (* the following code is only processed in App1 *)\n g_multitype := (0.9 + g_multitype) * 1.1;\n{ELSIF (hastype (variable: g_multitype, STRING))}\n (* the following code is only processed in App2 *)\n g_multitype := 'this is a multitalent';\n{END_IF} " }, 
{ "title" : "hasvalue (PackMode, ' <pack mode value> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-2d0744fc-1387-4648-5d01-12d8bd56a114", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ hasvalue (PackMode, ' <pack mode value> ') ", 
"snippet" : "检查的包模式取决于设备描述，而不是可以为单个 DUT 指定的编译指示。...", 
"body" : "检查的包模式取决于设备描述，而不是可以为单个 DUT 指定的编译指示。 " }, 
{ "title" : "hasvalue (RegisterSize, ' <register size> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-67a2d0e4-3a2a-3ab9-e96a-c17f6bf3b581", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ hasvalue (RegisterSize, ' <register size> ') ", 
"snippet" : "<register size> : CPU 寄存器的大小（以位为单位） 运算符使表达式返回值 TRUE 当 CPU 寄存器的大小等于 <register size> . 可能的值 <register size> 16 对于 C16x， 64 适用于 X86-64 位 32 适用于 X86-32 位...", 
"body" : "<register size> : CPU 寄存器的大小（以位为单位） 运算符使表达式返回值 TRUE 当 CPU 寄存器的大小等于 <register size> . 可能的值 <register size> 16 对于 C16x， 64 适用于 X86-64 位 32 适用于 X86-32 位 " }, 
{ "title" : "hasvalue (<define-ident>, ' <character string> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-a865c5bf-1e43-4a57-cddc-238d2a436773", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ hasvalue (<define-ident>, ' <character string> ') ", 
"snippet" : "运算符使表达式被赋予值 TRUE 当使用标识符定义变量时 <define-ident> 并且有价值 <char-string> .否则 FALSE 被退回。 示例 要求：两个应用程序 App1 和 App2 存在。变量 test 在应用程序中使用 App1 和 App2 .在 App1 , 它被赋予值 1 .在 App2 , 它被赋予值 2 . {IF hasvalue(test,'1')} (* the following code is only processed in App1 *) x := x + 1; {ELSIF hasvalue(test,'2')} (* the follo...", 
"body" : "运算符使表达式被赋予值 TRUE 当使用标识符定义变量时 <define-ident> 并且有价值 <char-string> .否则 FALSE 被退回。 示例 要求：两个应用程序 App1 和 App2 存在。变量 test 在应用程序中使用 App1 和 App2 .在 App1 , 它被赋予值 1 .在 App2 , 它被赋予值 2 . {IF hasvalue(test,'1')}\n (* the following code is only processed in App1 *)\n x := x + 1;\n{ELSIF hasvalue(test,'2')}\n (* the following code is only processed in App2 *)\n x := x + 2;\n{END_IF} " }, 
{ "title" : "project_defined (<global define>) ", 
"url" : "_cds_pragma_conditional.html#UUID-801188c2-bd31-aef6-8db9-6d83d2d1c459", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ project_defined (<global define>) ", 
"snippet" : "此运算符自起可用 CODESYS V3.5 SP20。 运算符使表达式接收值 TRUE 如果全局定义 <global define> 包含在全局定义列表中 编译选项 项目设置。 运算符被指定为条件 IF 语句，可用于 ST POU 和库的实现部分和声明部分。它们可以通过以下方式与其他定义组合 AND 和 OR 运算符（如果相应位置允许）。 在 POU 的声明部分， IF 与操作员的声明 project_defined (<global define> ) 可以包含以下结构： 变量声明 例子： {If project_defined(define1)} x : DINT; {END_IF} 评论...", 
"body" : "此运算符自起可用 CODESYS V3.5 SP20。 运算符使表达式接收值 TRUE 如果全局定义 <global define> 包含在全局定义列表中 编译选项 项目设置。 运算符被指定为条件 IF 语句，可用于 ST POU 和库的实现部分和声明部分。它们可以通过以下方式与其他定义组合 AND 和 OR 运算符（如果相应位置允许）。 在 POU 的声明部分， IF 与操作员的声明 project_defined (<global define> ) 可以包含以下结构： 变量声明 例子： {If project_defined(define1)}\n x : DINT;\n{END_IF} 评论 属性声明 杂注语句 以下构造是 不是 可能的： 完整的变量声明 例子 {If project_defined(define1)}\nVAR\n x : DINT;\nEND_VAR\n{END_IF} POU 的完整声明 例子： {If project_defined(define1)}\nFUNCTION POU : BOOL\nVAR_INPUT\n x : INT;\nEND_VAR\n{END_IF} 适用范围： VAR_INPUT , VAR_OUTPUT , VAR_IN_OUT " }, 
{ "title" : "NOT <operator> ", 
"url" : "_cds_pragma_conditional.html#UUID-01ae3a3c-e82a-ffd9-c21a-b7e1c89fd024", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ NOT <operator> ", 
"snippet" : "表达式被赋予值 TRUE 当反向值 <operator> 返回值 TRUE . <operator> 可以是本章中描述的运算符之一。 例子 要求：两个应用程序 App1 和 App2 存在。 PLC_PRG1 存在于 App1 和 App2 , 和 POU CheckBounds 只存在于 App1 . {IF defined (pou: PLC_PRG1) AND NOT (defined (pou: CheckBounds))} (* the following code is only processed in App2 *) bANDNotTest := TRUE; {END_IF}...", 
"body" : "表达式被赋予值 TRUE 当反向值 <operator> 返回值 TRUE . <operator> 可以是本章中描述的运算符之一。 例子 要求：两个应用程序 App1 和 App2 存在。 PLC_PRG1 存在于 App1 和 App2 , 和 POU CheckBounds 只存在于 App1 . {IF defined (pou: PLC_PRG1) AND NOT (defined (pou: CheckBounds))}\n (* the following code is only processed in App2 *)\n bANDNotTest := TRUE;\n{END_IF} " }, 
{ "title" : " <operator> AND <operator> ", 
"url" : "_cds_pragma_conditional.html#UUID-2570e549-f9f1-cc69-c881-0a2ce3064cef", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ <operator> AND <operator> ", 
"snippet" : "表达式被赋予值 TRUE 当两个指定的运算符返回时 TRUE . <operator> 可以是本章中描述的运算符之一。 示例 要求：应用程序 App1 和 App2 存在。 PLC_PRG1 存在于 App1 和 App2 , 和 POU CheckBounds 只存在于 App1 . {IF defined (pou: PLC_PRG1) AND (defined (pou: CheckBounds))} (* the following code is only processed in App1 *) bANDTest := TRUE; {END_IF}...", 
"body" : "表达式被赋予值 TRUE 当两个指定的运算符返回时 TRUE . <operator> 可以是本章中描述的运算符之一。 示例 要求：应用程序 App1 和 App2 存在。 PLC_PRG1 存在于 App1 和 App2 , 和 POU CheckBounds 只存在于 App1 . {IF defined (pou: PLC_PRG1) AND (defined (pou: CheckBounds))}\n (* the following code is only processed in App1 *)\n bANDTest := TRUE;\n{END_IF} " }, 
{ "title" : "<operator> OR <operator> ", 
"url" : "_cds_pragma_conditional.html#UUID-f4b44590-7911-5a28-1770-b7fdd2a04b3a", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ <operator> OR <operator> ", 
"snippet" : "表达式返回 TRUE 当两个指定的运算符之一返回时 TRUE . <operator> 可以是此处描述的运算符之一。 例子 要求：两个应用程序 App1 和 App2 存在。 POU PLC_PRG1 存在于 App1 和 App2 , 和 POU CheckBounds 只存在于 App1 . {IF defined (pou: PLC_PRG1) OR (defined (pou: CheckBounds))} (* the following code is only processed in App1 and in App2 *) bORTest := TRUE; {END_IF}...", 
"body" : "表达式返回 TRUE 当两个指定的运算符之一返回时 TRUE . <operator> 可以是此处描述的运算符之一。 例子 要求：两个应用程序 App1 和 App2 存在。 POU PLC_PRG1 存在于 App1 和 App2 , 和 POU CheckBounds 只存在于 App1 . {IF defined (pou: PLC_PRG1) OR (defined (pou: CheckBounds))}\n (* the following code is only processed in App1 and in App2 *)\n bORTest := TRUE;\n{END_IF} " }, 
{ "title" : "(<operator>) ", 
"url" : "_cds_pragma_conditional.html#UUID-59abef5c-3fde-2f82-9803-78934d89e364", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 条件指令 \/ 运营商 \/ (<operator>) ", 
"snippet" : "() 括号中的运算符。...", 
"body" : "() 括号中的运算符。 " }, 
{ "title" : "地区语用语 ", 
"url" : "_cds_pragma_region.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 编译指示 \/ 地区语用语 ", 
"snippet" : "pragma 用于将文本编辑器中的多行组合成一个块。块可以命名。区域编译指示也可以嵌套。 带有区域杂注的代码：展开和折叠视图 该 pragma 可以在 ST 编辑器和所有声明编辑器中使用。可以在选项中自定义语法突出显示。...", 
"body" : "pragma 用于将文本编辑器中的多行组合成一个块。块可以命名。区域编译指示也可以嵌套。 带有区域杂注的代码：展开和折叠视图 该 pragma 可以在 ST 编辑器和所有声明编辑器中使用。可以在选项中自定义语法突出显示。 " }, 
{ "title" : "标识符名称 ", 
"url" : "_cds_identifiers.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 标识符名称 ", 
"snippet" : "变量、常量、函数、功能块、方法和其他对象的标识符指定规则和建议...", 
"body" : "变量、常量、函数、功能块、方法和其他对象的标识符指定规则和建议 " }, 
{ "title" : "规则 ", 
"url" : "_cds_rules.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 标识符名称 \/ 规则 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "变量规则 ", 
"url" : "_cds_rules.html#UUID-dad2255f-3304-d0ef-3f4d-daaa6c691390_section-idm4594042020419234099402926422", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 标识符名称 \/ 规则 \/ 变量规则 ", 
"snippet" : "标识符不得包含空格或特殊字符。 下划线被识别。 例如， A_BCD 和 AB_CD 被视为两个不同的标识符。 不允许有多个连续的下划线。 不区分大小写。 例如， VAR1 和 var1 引用同一个变量。 标识符的长度不受限制。 我们建议您应用 建议 除了变量声明时需要特别考虑的事项之外。通过这样做，您可以在分配名称时获得最佳的协调性。...", 
"body" : "标识符不得包含空格或特殊字符。 下划线被识别。 例如， A_BCD 和 AB_CD 被视为两个不同的标识符。 不允许有多个连续的下划线。 不区分大小写。 例如， VAR1 和 var1 引用同一个变量。 标识符的长度不受限制。 我们建议您应用 建议 除了变量声明时需要特别考虑的事项之外。通过这样做，您可以在分配名称时获得最佳的协调性。 " }, 
{ "title" : "多重使用规则（命名空间） ", 
"url" : "_cds_rules.html#UUID-dad2255f-3304-d0ef-3f4d-daaa6c691390_section-idm4594041991880034099404518269", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 标识符名称 \/ 规则 \/ 多重使用规则（命名空间） ", 
"snippet" : "标识符不能在本地声明两次。 一个标识符可以在全局范围内使用多次。 如果局部变量与全局变量同名，则局部变量在 POU 中具有优先权。 标识符不允许与关键字相同。 示例：范围 VAR_Global 在全局变量列表中声明的变量可以与在另一个 GVL 中定义的变量同名。 CODESYS 提供扩展命名空间或变量范围标准的功能： 全局命名空间运算符 以点开头的实例路径始终打开一个全局命名空间。如果有一个局部变量（例如， ivar ) 与全局变量同名，那么您将全局变量称为 .ivar . 全局变量列表的名称可以为包含变量定义唯一的命名空间。因此，您可以在不同的全局变量列表中声明具有相同名称的变量，并且仍然可...", 
"body" : "标识符不能在本地声明两次。 一个标识符可以在全局范围内使用多次。 如果局部变量与全局变量同名，则局部变量在 POU 中具有优先权。 标识符不允许与关键字相同。 示例：范围 VAR_Global 在全局变量列表中声明的变量可以与在另一个 GVL 中定义的变量同名。 CODESYS 提供扩展命名空间或变量范围标准的功能： 全局命名空间运算符 以点开头的实例路径始终打开一个全局命名空间。如果有一个局部变量（例如， ivar ) 与全局变量同名，那么您将全局变量称为 .ivar . 全局变量列表的名称可以为包含变量定义唯一的命名空间。因此，您可以在不同的全局变量列表中声明具有相同名称的变量，并且仍然可以通过添加列表名称来唯一引用。 例子： globlist1.ivar := globlist2.ivar; (* ivar from GVL globlist2 is copied to ivar in GVL globlist1 *) 在项目中包含的库的全局变量列表中定义的变量可以根据以下语法进行唯一寻址： <name scope library>.< GVL name>.<variable name> 例子： globlist1.ivar := lib1.globlist1.ivar (* ivar from GVL globlist1 in library lib1 is copied to ivar in GVL globlist1 *) 插入库时，您还可以使用库管理器来定义命名空间。这样，您可以通过以下方式对库 POU 或库变量进行唯一引用 <namespace library >.<POU name\\|variable name> .请注意，当库嵌套时，您必须连续引用所有库的命名空间。 示例：如果 Lib1 被引用 Lib0 , 那么 POU func 在 Lib1 由解决 Lib0.Lib1.fun ： ivar := Lib0.Lib1.fun(4, 5); (* return value from func is copied to variable ivar in the project *) " }, 
{ "title" : "反引号标识符 ", 
"url" : "_cds_rules.html#UUID-dad2255f-3304-d0ef-3f4d-daaa6c691390_section-idm4594041889873634099410376242", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 标识符名称 \/ 规则 \/ 反引号标识符 ", 
"snippet" : "通过使用反引号，还可以在标识符中使用通常不允许在标识符中使用的字符，例如特殊字符。锐音重音字符用于反引号： ´ （统一码：U+02CA） 建议使用反引号，以便能够在中使用相同的标识符 CODESYS 与其他编程语言或文档（例如电路图）一样。 两个反引号之间可以使用任何字符，换行符和其他反引号除外。关键字也可以作为反引号之间的标识符。 例子： ´Variable+9´ ´INT´ 反引号是每个标识符的一部分，因此 var1 和 ´var1´ 是两个不同的标识符。 例子 PROGRAM PLC_PRG VAR var1 : INT; ´var1´: INT; END_VAR var1 := var...", 
"body" : "通过使用反引号，还可以在标识符中使用通常不允许在标识符中使用的字符，例如特殊字符。锐音重音字符用于反引号： ´ （统一码：U+02CA） 建议使用反引号，以便能够在中使用相同的标识符 CODESYS 与其他编程语言或文档（例如电路图）一样。 两个反引号之间可以使用任何字符，换行符和其他反引号除外。关键字也可以作为反引号之间的标识符。 例子： ´Variable+9´ ´INT´ 反引号是每个标识符的一部分，因此 var1 和 ´var1´ 是两个不同的标识符。 例子 PROGRAM PLC_PRG\nVAR\n var1 : INT;\n ´var1´: INT;\nEND_VAR\n\nvar1 := var1 + 1;\n´var1´ := 12;\n " }, 
{ "title" : "建议 ", 
"url" : "_cds_recommendation.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 标识符名称 \/ 建议 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "对于变量 ", 
"url" : "_cds_identifiers_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 标识符名称 \/ 建议 \/ 对于变量 ", 
"snippet" : "只要有可能，您应该在应用程序和库中以匈牙利符号命名变量。为每个变量找到一个有意义的简短英文名称作为基本名称，该名称可以由多个单词组成。每个单词的第一个字母大写，其余字母小写。在基本名称前，附加一个小写前缀，以指示变量的数据类型。 例子： iFileSize : INT; 标识符指定建议 数据类型 字首 描述 BOOL x 我们明确推荐 x 作为布尔变量的前缀，以便将它们与数据类型的标识符区分开来 BYTE .前缀表示 IEC 程序员的观点。 b 预订的 BYTE by 位串；不适用于算术运算 WORD w 位串；不适用于算术运算 DWORD dw 位串；不适用于算术运算 LWORD lw 位串...", 
"body" : "只要有可能，您应该在应用程序和库中以匈牙利符号命名变量。为每个变量找到一个有意义的简短英文名称作为基本名称，该名称可以由多个单词组成。每个单词的第一个字母大写，其余字母小写。在基本名称前，附加一个小写前缀，以指示变量的数据类型。 例子： iFileSize : INT; 标识符指定建议 数据类型 字首 描述 BOOL x 我们明确推荐 x 作为布尔变量的前缀，以便将它们与数据类型的标识符区分开来 BYTE .前缀表示 IEC 程序员的观点。 b 预订的 BYTE by 位串；不适用于算术运算 WORD w 位串；不适用于算术运算 DWORD dw 位串；不适用于算术运算 LWORD lw 位串；不适用于算术运算 SINT si 算术整数数据类型，8 位 USINT usi 算术整数数据类型，8 位 INT i 算术整数数据类型，16 位 UINT ui 算术整数数据类型，16 位 DINT di 算术整数数据类型，32 位 UDINT udi 算术整数数据类型，32 位 LINT li 算术整数数据类型，64 位 ULINT uli 算术整数数据类型，64 位 REAL r 算术浮点数据类型，32 位 LREAL lr 算术浮点数据类型，64 位 STRING s 可变长度的单字节字符串（默认设置：80 个字符） WSTRING ws 可变长度的双字节字符串（默认设置：80 个字符） TIME tim 持续时间，32 位 LTIME ltim 持续时间，64 位 TIME_OF_DAY TOD tod 时间，32 位 LTIME_OF_DAY LTOD ltod 一天中的时间，64 位 DATE_AND_TIME DT dt 日期和时间 LDATE_AND_TIME LDT ldt DATE dat d 日历日期 LDATE ldat ld 日历日期 POINTER p ARRAY a 枚举 e 例子 VAR\n bySubIndix: BYTE;\n xFlag: BOOL;\n udiCounter: UDINT;\nEND_VAR 标识符指定建议 描述 例子 嵌套声明 前缀按声明顺序依次附加。 pabyTelegramData: POINTER TO ARRAY [0..7] OF BYTE; 功能块实例 用户定义数据类型的变量 前缀：功能块或数据类型名称的缩写 cansdoReceivedTelegram: CAN_SDOTelegram;\n\nTYPE CAN_SDOTelegram : (* prefix: sdo *)\nSTRUCT\n wIndex: WORD;\n bySubIndex:BYTE;\n byLen:BYTE;\n aby: ARRAY [0..3] OF BYTE;\nEND_STRUCT\nEND_TYPE 局部常数 局部常量变量 字首： c_ , 后跟类型前缀和变量名 VAR CONSTANT\n c_uiSyncID: UINT := 16#80;\nEND_VAR\n 全局变量 附加前缀附加到库前缀。 g_ VAR_GLOBAL\n CAN_g_iText: INT;\nEND_VAR\n 全局常数 全局常量变量 附加前缀附加到库前缀。 gc_ VAR_GLOBAL CONSTANT\n CAN_gc_dwExample: DWORD;\nEND_VAR\n " }, 
{ "title" : "对于变量 CODESYS V3 库 ", 
"url" : "_cds_identifiers_var_v3_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 标识符名称 \/ 建议 \/ 对于变量 CODESYS V3 库 ", 
"snippet" : "对于库中的变量 标识符指定建议 描述 例子 多变的 对应于变量名的描述，除了全局变量和常量不需要库前缀，因为命名空间替换了函数。 g_iTest: INT; \/\/ Declaration CAN.g_iTest; \/\/ Implementation; call in the program...", 
"body" : "对于库中的变量 标识符指定建议 描述 例子 多变的 对应于变量名的描述，除了全局变量和常量不需要库前缀，因为命名空间替换了函数。 g_iTest: INT; \/\/ Declaration CAN.g_iTest; \/\/ Implementation; call in the program " }, 
{ "title" : "对于自定义数据类型 ", 
"url" : "_cds_identifiers_dut.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 标识符名称 \/ 建议 \/ 对于自定义数据类型 ", 
"snippet" : "对于 DUT 标识符指定建议 描述 例子 结构 库前缀后跟下划线和结构的简短、信息性描述 此结构的已创建变量的相关前缀应跟在冒号后面作为注释。 TYPE CAN_SDOTelegram : (* prefix: sdo *) STRUCT wIndex : WORD; bySubIndex : BYTE; byLen : BYTE; abyData: ARRAY [0..3] OF BYTE; END_STRUCT END_TYPE 枚举 库前缀后跟下划线和大写标识符 注：过去 CODESYS 版本，枚举值 > 16#7FFF 导致错误，因为它们没有自动转换为 INT .出于这个原因，总是用正...", 
"body" : "对于 DUT 标识符指定建议 描述 例子 结构 库前缀后跟下划线和结构的简短、信息性描述 此结构的已创建变量的相关前缀应跟在冒号后面作为注释。 TYPE CAN_SDOTelegram : (* prefix: sdo *)\n STRUCT\n wIndex : WORD;\n bySubIndex : BYTE;\n byLen : BYTE;\n abyData: ARRAY [0..3] OF BYTE;\n END_STRUCT\nEND_TYPE\n 枚举 库前缀后跟下划线和大写标识符 注：过去 CODESYS 版本，枚举值 > 16#7FFF 导致错误，因为它们没有自动转换为 INT .出于这个原因，总是用正确的方式声明枚举 INT 价值观。 TYPE CAL_Day :\n(\nCAL_MONDAY,\nCAL_TUESDAY, \nCAL_WEDNESDAY,\nCAL_THURSDAY,\nCAL_SUNDAY\n);\n 宣言： eToday: CAL_DAY; " }, 
{ "title" : "对于自定义数据类型 CODESYS V3 库 ", 
"url" : "_cds_identifiers_dut_v3_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 标识符名称 \/ 建议 \/ 对于自定义数据类型 CODESYS V3 库 ", 
"snippet" : "对于 V3 库中的 DUT 标识符指定建议 描述 例子 被测设备 CODESYS V3 图书馆 命名空间取代了对库前缀的需求。因此，将其省略。枚举值的定义也没有库前缀。 图书馆与 CAL 命名空间： TYPE DAY : ( MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY ); 宣言： eToday: CAL.Day; 在应用程序中的使用 IF eToday = CAL.Day.MONDAY THEN...", 
"body" : "对于 V3 库中的 DUT 标识符指定建议 描述 例子 被测设备 CODESYS V3 图书馆 命名空间取代了对库前缀的需求。因此，将其省略。枚举值的定义也没有库前缀。 图书馆与 CAL 命名空间： TYPE DAY : \n(\nMONDAY,\nTUESDAY,\nWEDNESDAY,\nTHURSDAY,\nFRIDAY,\nSATURDAY,\nSUNDAY\n); 宣言： eToday: CAL.Day; 在应用程序中的使用 IF eToday = CAL.Day.MONDAY THEN " }, 
{ "title" : "对于 POU ", 
"url" : "_cds_identifiers_pous.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 标识符名称 \/ 建议 \/ 对于 POU ", 
"snippet" : "标识符指定建议 描述 例子 功能、功能块、程序 库前缀后跟一个下划线和一个简短、信息丰富的 POU 名称 与变量一样，每个单词的第一个字母都是大写的，所有其他字母都是小写的。我们建议您由动词和名词组成 POU 名称。 对于功能块，已创建实例的相关前缀应跟随名称作为注释。 FUNCTION_BLOCK CAN_SendTelegram (* prefix: canst *) 行动 仅块本身调用的操作，以 prv_ .否则，动作没有前缀。...", 
"body" : "标识符指定建议 描述 例子 功能、功能块、程序 库前缀后跟一个下划线和一个简短、信息丰富的 POU 名称 与变量一样，每个单词的第一个字母都是大写的，所有其他字母都是小写的。我们建议您由动词和名词组成 POU 名称。 对于功能块，已创建实例的相关前缀应跟随名称作为注释。 FUNCTION_BLOCK CAN_SendTelegram (* prefix: canst *) 行动 仅块本身调用的操作，以 prv_ .否则，动作没有前缀。 " }, 
{ "title" : "对于 POU 在 CODESYS V3 库 ", 
"url" : "_cds_identifiers_pou_v3_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 标识符名称 \/ 建议 \/ 对于 POU 在 CODESYS V3 库 ", 
"snippet" : "对于 V3 库块 标识符指定建议 描述 例子 POU 库前缀被省略，因为命名空间替换了库前缀的功能。 FUNCTION_BLOCK SendTelegram (* prefix: canst *) 方法 只有块本身调用的方法，以 prv_ . 否则，方法没有前缀。 界面 界面 I ICANDevice...", 
"body" : "对于 V3 库块 标识符指定建议 描述 例子 POU 库前缀被省略，因为命名空间替换了库前缀的功能。 FUNCTION_BLOCK SendTelegram (* prefix: canst *) 方法 只有块本身调用的方法，以 prv_ . 否则，方法没有前缀。 界面 界面 I ICANDevice " }, 
{ "title" : "对于可视化 ", 
"url" : "_cds_identifiers_visu.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 标识符名称 \/ 建议 \/ 对于可视化 ", 
"snippet" : "可视化对象的名称建议 请注意，可视化与项目中的另一个块的名称不同，因为这可能会在更改可视化时导致问题。...", 
"body" : "可视化对象的名称建议 请注意，可视化与项目中的另一个块的名称不同，因为这可能会在更改可视化时导致问题。 " }, 
{ "title" : "影子规则 ", 
"url" : "_cds_shadowing_rules.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 影子规则 ", 
"snippet" : "在 CODESYS ，通常允许您对不同的元素使用相同的标识符。例如，一个 POU 和一个变量可以命名相同。但是，您应该避免这种做法，以防止混淆。 例子 反例：在以下代码片段中，本地功能块实例与函数同名： 在这种情况下，不清楚程序中调用的是实例还是函数。 FUNCTION YYY : INT ; END_FUNCTION FUNCTION_BLOCK XXX ; END_FUNCTION_BLOCK PROGRAM PLC_PRG VAR YYY : XXX; END_VAR YYY(); END_PROGRAM...", 
"body" : "在 CODESYS ，通常允许您对不同的元素使用相同的标识符。例如，一个 POU 和一个变量可以命名相同。但是，您应该避免这种做法，以防止混淆。 例子 反例：在以下代码片段中，本地功能块实例与函数同名： 在这种情况下，不清楚程序中调用的是实例还是函数。 FUNCTION YYY : INT\n;\nEND_FUNCTION\n\nFUNCTION_BLOCK XXX\n;\nEND_FUNCTION_BLOCK\n\nPROGRAM PLC_PRG\nVAR\n YYY : XXX;\nEND_VAR\nYYY();\nEND_PROGRAM " }, 
{ "title" : "隐藏时的编译器行为 ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_section-idm462806727981763350320566511", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 影子规则 \/ 隐藏时的编译器行为 ", 
"snippet" : "如果相同的标识符用于不同的元素，编译器不会报告任何错误或警告。相反，编译器以特定顺序搜索代码以查找标识符的声明。如果找到声明，则编译器不会在别处搜索任何其他声明。如果确实存在其他声明，那么它们将被编译器“隐藏”。以下部分描述了阴影规则（即编译器在搜索标识符声明时使用的搜索顺序）。 “歧义访问和限定访问”部分提供了防止歧义访问和绕过隐藏规则的方法。...", 
"body" : "如果相同的标识符用于不同的元素，编译器不会报告任何错误或警告。相反，编译器以特定顺序搜索代码以查找标识符的声明。如果找到声明，则编译器不会在别处搜索任何其他声明。如果确实存在其他声明，那么它们将被编译器“隐藏”。以下部分描述了阴影规则（即编译器在搜索标识符声明时使用的搜索顺序）。 “歧义访问和限定访问”部分提供了防止歧义访问和绕过隐藏规则的方法。 " }, 
{ "title" : "如何防止阴影 ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_section-idm4593930303395233503201805458", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 影子规则 \/ 如何防止阴影 ", 
"snippet" : "为确保名称始终唯一，您应该遵循命名约定，例如变量的某些前缀。 有关更多信息，请参阅： 标识符名称可以使用静态代码分析自动检查命名约定 CODESYS .静态代码分析还可以检测名称的重复使用 YYY 并将其报告为错误。 同样通过属性的一致使用 qualified_only 对于枚举和全局变量列表，通过使用合格的库，可以避免非唯一情况。 为了确保 POU 中的同名 POU 设备 当 POU 在 POU 视图被调用，操作符 __POOL 当调用 POU 的名称时，应该在前面加上。 例子： svar_pou := __POOL.POU();...", 
"body" : "为确保名称始终唯一，您应该遵循命名约定，例如变量的某些前缀。 有关更多信息，请参阅： 标识符名称可以使用静态代码分析自动检查命名约定 CODESYS .静态代码分析还可以检测名称的重复使用 YYY 并将其报告为错误。 同样通过属性的一致使用 qualified_only 对于枚举和全局变量列表，通过使用合格的库，可以避免非唯一情况。 为了确保 POU 中的同名 POU 设备 当 POU 在 POU 视图被调用，操作符 __POOL 当调用 POU 的名称时，应该在前面加上。 例子： svar_pou := __POOL.POU(); " }, 
{ "title" : "应用程序中的搜索顺序 ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_id_eb9f3a6f8dc5c0a864633ab16f46_id_ac2947743b785338c0a864635c9601cf", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 影子规则 \/ 应用程序中的搜索顺序 ", 
"snippet" : "当编译器在应用程序的代码中遇到单个标识符时，它会按以下顺序搜索相应的声明： 局部变量 方法的局部变量 功能块、程序或功能以及任何基本功能块中的局部变量 POU 的局部方法 应用程序中的全局变量，如果 qualified_only 声明全局变量的变量列表中未设置属性 应用程序中的全局变量，如果 qualified_only 声明全局变量的变量列表中未设置属性 父应用程序中的全局变量，如果 qualified_only 声明全局变量的变量列表中未设置属性 当库和变量列表都不需要限定访问时，引用库中的全局变量 POU 或类型名称 来自应用程序的 POU 或类型名称（即全局变量列表、功能块等的名称） ...", 
"body" : "当编译器在应用程序的代码中遇到单个标识符时，它会按以下顺序搜索相应的声明： 局部变量 方法的局部变量 功能块、程序或功能以及任何基本功能块中的局部变量 POU 的局部方法 应用程序中的全局变量，如果 qualified_only 声明全局变量的变量列表中未设置属性 应用程序中的全局变量，如果 qualified_only 声明全局变量的变量列表中未设置属性 父应用程序中的全局变量，如果 qualified_only 声明全局变量的变量列表中未设置属性 当库和变量列表都不需要限定访问时，引用库中的全局变量 POU 或类型名称 来自应用程序的 POU 或类型名称（即全局变量列表、功能块等的名称） 来自父应用程序的 POU 或类型名称 POU 或库中的类型名称 图书馆 本地引用的库和由库发布的库的命名空间 计划书 看法 中的全局变量 计划书 看来，除非 qualified_only 属性在声明它们的变量列表中设置 POU 或类型名称 计划书 视图（即全局变量列表、功能块等的名称） 来自的图书馆 计划书 插入到库管理器中的库 POU 视图在项目中所有应用程序的库管理器中以适当的占位符分辨率进行镜像。然后这些库与应用程序中的库形成一个公共命名空间。因此，应用程序中的库不会影响池中的库。 " }, 
{ "title" : "图书馆的检索顺序 ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_id_eb9f3a6f8dc5c0a864633ab16f46_id_6e5cf3e23b785338c0a864631e655a41", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 影子规则 \/ 图书馆的检索顺序 ", 
"snippet" : "当编译器在库的代码中遇到单个标识符时，它会按以下顺序搜索相应的声明： 局部变量 方法的局部变量 功能块、程序或功能以及任何基本功能块中的局部变量 POU 的局部方法 全局变量 本地库中的全局变量，如果 qualified_only 声明全局变量的变量列表中未设置属性 当库和变量列表都不需要合格访问时，引用库中的全局变量 图书馆 来自本地库的 POU 或类型名称（即全局变量列表、功能块等的名称） 来自引用库的 POU 或类型名称 本地引用库和由本地引用库发布的库的命名空间...", 
"body" : "当编译器在库的代码中遇到单个标识符时，它会按以下顺序搜索相应的声明： 局部变量 方法的局部变量 功能块、程序或功能以及任何基本功能块中的局部变量 POU 的局部方法 全局变量 本地库中的全局变量，如果 qualified_only 声明全局变量的变量列表中未设置属性 当库和变量列表都不需要合格访问时，引用库中的全局变量 图书馆 来自本地库的 POU 或类型名称（即全局变量列表、功能块等的名称） 来自引用库的 POU 或类型名称 本地引用库和由本地引用库发布的库的命名空间 " }, 
{ "title" : "模糊访问和合格访问 ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_id_eb9f3a6f8dc5c0a864633ab16f46_id_d382bb6d3b785338c0a86463219183c4", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 影子规则 \/ 模糊访问和合格访问 ", 
"snippet" : "尽管有这些搜索顺序，仍然会出现不明确的访问。例如，当同名变量存在于不需要限定访问的两个全局变量列表中时就是这种情况。这种情况被编译器报告为错误（例如： 暧昧地使用XXX的名字 ). 这种模棱两可的用法可以通过限定访问来实现唯一性，例如通过全局变量列表的名称进行访问（例如： GVL.XXX ）。 合格的访问也总是可以用来避免遮蔽规则。 全局变量列表的名称可用于唯一访问列表中的变量。 库的名称可用于唯一访问库中的元素。 这 THIS 指针用于唯一访问功能块中的变量，即使功能块的方法中存在同名的局部变量。 要随时查找标识符的声明位置，请使用 编辑→浏览→转到定义 命令。如果编译器产生明显晦涩的错误消...", 
"body" : "尽管有这些搜索顺序，仍然会出现不明确的访问。例如，当同名变量存在于不需要限定访问的两个全局变量列表中时就是这种情况。这种情况被编译器报告为错误（例如： 暧昧地使用XXX的名字 ). 这种模棱两可的用法可以通过限定访问来实现唯一性，例如通过全局变量列表的名称进行访问（例如： GVL.XXX ）。 合格的访问也总是可以用来避免遮蔽规则。 全局变量列表的名称可用于唯一访问列表中的变量。 库的名称可用于唯一访问库中的元素。 这 THIS 指针用于唯一访问功能块中的变量，即使功能块的方法中存在同名的局部变量。 要随时查找标识符的声明位置，请使用 编辑→浏览→转到定义 命令。如果编译器产生明显晦涩的错误消息，这将特别有用。 " }, 
{ "title" : "在实例路径中搜索 ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_id_eb9f3a6f8dc5c0a864633ab16f46_id_4094da363b785338c0a864632107d534", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 影子规则 \/ 在实例路径中搜索 ", 
"snippet" : "上述搜索顺序不适用于在实例路径中作为组件存在的标识符或在调用中用作输入的标识符。 对于以下类型的访问 yy.component ，它取决于描述的实体 yy 在哪里声明 component 被搜索。 如果 yy 表示具有结构化数据类型的变量（即，类型 STRUCT 或者 UNION ）， 然后 component 按以下顺序搜索： 功能块的局部变量 基本功能块的局部变量 功能块的方法 基本功能块的方法 如果 yy 表示全局变量列表或程序，则 component 仅在此列表中搜索。 如果 yy 表示库的命名空间，则 component 完全按照上面“在库中的搜索顺序”部分中的描述在此库中搜索。 只...", 
"body" : "上述搜索顺序不适用于在实例路径中作为组件存在的标识符或在调用中用作输入的标识符。 对于以下类型的访问 yy.component ，它取决于描述的实体 yy 在哪里声明 component 被搜索。 如果 yy 表示具有结构化数据类型的变量（即，类型 STRUCT 或者 UNION ）， 然后 component 按以下顺序搜索： 功能块的局部变量 基本功能块的局部变量 功能块的方法 基本功能块的方法 如果 yy 表示全局变量列表或程序，则 component 仅在此列表中搜索。 如果 yy 表示库的命名空间，则 component 完全按照上面“在库中的搜索顺序”部分中的描述在此库中搜索。 只有在第二种情况下，编译器才决定是否允许访问找到的元素（即，变量是否只能在本地访问，或者方法是否是私有的）。如果不允许访问，则会发出错误。 " }, 
{ "title" : "关键词 ", 
"url" : "_cds_keywords.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 关键词 ", 
"snippet" : "在所有编辑器中，您必须将关键字大写，例如表示范围、数据类型或运算符。关键字不能用作变量名。 例子 VAR END_VAR BOOL_TO_INT IF THEN ELSE LTIME MUL XOR PERSISTENT PROGRAM CODESYS 自动检查关键字的正确使用并在您键入时仔细检查错误。 什么时候 CODESYS 创建隐式代码、变量和函数的名称通常以两个下划线“__”开头。自动防止在实现代码中使用双下划线。这消除了内部系统标识符和程序员分配的标识符之间的冲突。 以下关键字用于 CODESYS 导出格式。因此，您不能将它们用作标识符： ACTION END_ACTION END_...", 
"body" : "在所有编辑器中，您必须将关键字大写，例如表示范围、数据类型或运算符。关键字不能用作变量名。 例子 VAR\nEND_VAR\nBOOL_TO_INT\nIF\nTHEN\nELSE\nLTIME\nMUL\nXOR\nPERSISTENT\nPROGRAM CODESYS 自动检查关键字的正确使用并在您键入时仔细检查错误。 什么时候 CODESYS 创建隐式代码、变量和函数的名称通常以两个下划线“__”开头。自动防止在实现代码中使用双下划线。这消除了内部系统标识符和程序员分配的标识符之间的冲突。 以下关键字用于 CODESYS 导出格式。因此，您不能将它们用作标识符： ACTION END_ACTION END_FUNCTION END_FUNCTION_BLOCK END_PROGRAM 其他有效关键字： VAR_ACCESS READ_ONLY READ_WRITE PARAMS " }, 
{ "title" : "方法: FB_Init , FB_Reinit 和 FB_Exit ", 
"url" : "_cds_method_fb_init_fb_reinit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 方法: FB_Init , FB_Reinit 和 FB_Exit ", 
"snippet" : "您可以显式声明方法以影响功能块变量的初始化以及退出功能块时的行为。 隐式方法的返回值类型是 BOOL .该值不由系统评估，但不应更改类型。 FB_Init 总是隐式可用的，它主要用于初始化。对于特定的影响，您还可以显式声明方法并在其中提供带有标准初始化代码的附加代码。 FB_Reinit 必须明确实施。如果此方法存在，则在受影响功能块的实例完成后调用 复制了 .这发生在更改功能块声明（签名更改）后的在线更改期间，以便重新初始化新的实例模块。要重新初始化功能块的基本实现，您必须调用 FB_Reinit 明确地。 FB_Exit 必须明确实施。如果有实现，则在控制器移除功能块实例的代码之前调用该方...", 
"body" : "您可以显式声明方法以影响功能块变量的初始化以及退出功能块时的行为。 隐式方法的返回值类型是 BOOL .该值不由系统评估，但不应更改类型。 FB_Init 总是隐式可用的，它主要用于初始化。对于特定的影响，您还可以显式声明方法并在其中提供带有标准初始化代码的附加代码。 FB_Reinit 必须明确实施。如果此方法存在，则在受影响功能块的实例完成后调用 复制了 .这发生在更改功能块声明（签名更改）后的在线更改期间，以便重新初始化新的实例模块。要重新初始化功能块的基本实现，您必须调用 FB_Reinit 明确地。 FB_Exit 必须明确实施。如果有实现，则在控制器移除功能块实例的代码之前调用该方法（隐式调用）。 下面显示了这些方法在不同操作条件下的一些用例。 " }, 
{ "title" : "“首次下载”操作案例 ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_ee2ec072ce4c52dbc0a864631de40b39", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 方法: FB_Init , FB_Reinit 和 FB_Exit \/ “首次下载”操作案例 ", 
"snippet" : "将应用程序下载到具有出厂设置的 PLC 时，所有变量的内存必须偏移到所需的初始状态。这样，功能块实例的数据区就被分配了所需的值。通过显式实现 FB_Init 对于功能块，您可以在应用程序代码中专门针对这种情况做出反应。通过评估方法参数 bInCopyCode ( FALSE ） 和 bInitRetains ( TRUE )，您可以清楚地检测到这种运行状况。...", 
"body" : "将应用程序下载到具有出厂设置的 PLC 时，所有变量的内存必须偏移到所需的初始状态。这样，功能块实例的数据区就被分配了所需的值。通过显式实现 FB_Init 对于功能块，您可以在应用程序代码中专门针对这种情况做出反应。通过评估方法参数 bInCopyCode ( FALSE ） 和 bInitRetains ( TRUE )，您可以清楚地检测到这种运行状况。 " }, 
{ "title" : "“在线变更”运营案例 ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_11211aface4c52dbc0a864635676a307", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 方法: FB_Init , FB_Reinit 和 FB_Exit \/ “在线变更”运营案例 ", 
"snippet" : "在在线更改范围内，您可以通过方法影响功能块实例的初始化 FB_Exit , FB_Init ， 和 FB_Reinit .在在线更改期间，在离线模式下对应用程序所做的更改将应用于正在运行的 PLC。因此，“旧的”功能块实例被您的“新的兄弟姐妹”尽可能地替换而不会发生意外。如果在登录之前没有对应用程序中的功能块的声明部分进行更改，而只是在实现中，则不会替换数据区域。仅替换代码块。然后方法 FB_Exit , FB_Init ， 和 FB_Reinit 不被调用。 如果您对导致上述复制操作的功能块声明进行了更改，那么您会在在线更改期间收到一条有关“可能的意外影响”的消息。在里面 细节 在消息视图中...", 
"body" : "在在线更改范围内，您可以通过方法影响功能块实例的初始化 FB_Exit , FB_Init ， 和 FB_Reinit .在在线更改期间，在离线模式下对应用程序所做的更改将应用于正在运行的 PLC。因此，“旧的”功能块实例被您的“新的兄弟姐妹”尽可能地替换而不会发生意外。如果在登录之前没有对应用程序中的功能块的声明部分进行更改，而只是在实现中，则不会替换数据区域。仅替换代码块。然后方法 FB_Exit , FB_Init ， 和 FB_Reinit 不被调用。 如果您对导致上述复制操作的功能块声明进行了更改，那么您会在在线更改期间收到一条有关“可能的意外影响”的消息。在里面 细节 在消息视图中，您会看到要复制的所有实例的列表。 在代码中 FB_Init 方法，参数 bInCopyCode ( TRUE ) 可以评估以检测是否正在执行在线更改。 在线更改期间会连续发生以下调用： FB_Exit old_inst.FB_Exit(bInCopyCode := TRUE); 你可以打电话 FB_Exit 退出“旧”实例以触发特定清理任务时 复制操作之前 .这样，您就可以为后续的复制操作准备数据并影响新实例的状态。您可以通知应用程序的其他部分有关内存中位置的未决更改。特别注意类型的变量 POINTER 和 REFERENCE .在线更改后，这些可能不再指代所需的内存位置。接口变量 ( INTERFACE ) 由编译器单独处理，并在在线更改期间进行相应调整。新实例可以应用诸如套接字、文件或其他句柄之类的外部资源，在某些情况下保持不变。在在线更改期间，通常不必对它们进行特殊处理。 （参见“‘重新下载’操作案例”） FB_Init new_inst.FB_Init(bInitRetains := FALSE, bInCopyCode := TRUE); FB_Init 在复制操作之前调用，可用于执行在线更改的特定操作。例如，您可以在内存中的“新”位置相应地初始化变量，或者通知应用程序的其他部分有关内存中特定变量的新位置。 复制操作： copy copy(&old_inst, &new_inst); 现有值保持不变。为此，它们从旧实例复制到新实例中。 FB_Reinit new_inst.FB_Reinit(); 此方法在复制操作之后调用，并且应该为实例的变量设置定义的值。例如，您可以在内存中的“新”位置相应地初始化变量，或者通知应用程序的其他部分有关内存中特定变量的新位置。设计独立于在线更改的实现。也可以随时从应用程序调用该方法，以将功能块实例重置为其原始状态。 随着 {attribute 'no_copy'} 属性，您可以防止在在线更改功能块的单个变量期间复制该属性。它始终保留初始值。 有关更多信息，请参阅： 为在线更改设置内存保留" }, 
{ "title" : "“新下载”操作案例 ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_18382d25ce4c52dbc0a86463733d1d36", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 方法: FB_Init , FB_Reinit 和 FB_Exit \/ “新下载”操作案例 ", 
"snippet" : "下载应用程序时，可以替换 PLC 上的现有应用程序。因此，必须规范为当前功能块提供的内存。您可以使用 FB_Exit 实现此所需步骤的方法。例如，您可以在定义的状态下偏移外部资源（带有套接字和文件句柄）。 您可以通过检查参数是否 bInCopyCode = FALSE 为了 FB_Exit 方法。...", 
"body" : "下载应用程序时，可以替换 PLC 上的现有应用程序。因此，必须规范为当前功能块提供的内存。您可以使用 FB_Exit 实现此所需步骤的方法。例如，您可以在定义的状态下偏移外部资源（带有套接字和文件句柄）。 您可以通过检查参数是否 bInCopyCode = FALSE 为了 FB_Exit 方法。 " }, 
{ "title" : "“开始申请”操作案例 ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_a4a0f73c27f211e6b1abd7715e61fd27", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 方法: FB_Init , FB_Reinit 和 FB_Exit \/ “开始申请”操作案例 ", 
"snippet" : "在应用程序任务的第一个周期之前处理初始分配。 例子 T1 : TON := (PT:=t#500ms); 这些类型的赋值只有在调用之后才会执行 FB_Init .为了控制这些赋值的效果，您可以提供一个功能块或一个功能块的方法 {attribute ‘call_after_init‘} 属性。您必须在功能块主体的声明部分上方和相应方法的声明部分上方添加属性。扩展另一个 POU 的 POU，该 POU 使用 {attribute 'call_after_init'} 属性也必须有属性。为了清楚起见，我们建议用相同的名称、相同的签名和相同的属性覆盖相应的方法。这需要调用 SUPER^.MyInit ...", 
"body" : "在应用程序任务的第一个周期之前处理初始分配。 例子 T1 : TON := (PT:=t#500ms); 这些类型的赋值只有在调用之后才会执行 FB_Init .为了控制这些赋值的效果，您可以提供一个功能块或一个功能块的方法 {attribute ‘call_after_init‘} 属性。您必须在功能块主体的声明部分上方和相应方法的声明部分上方添加属性。扩展另一个 POU 的 POU，该 POU 使用 {attribute 'call_after_init'} 属性也必须有属性。为了清楚起见，我们建议用相同的名称、相同的签名和相同的属性覆盖相应的方法。这需要调用 SUPER^.MyInit .可以无限制地选择方法的名称。 （例外： FB_Init , FB_Reinit ， 和 FB_Exit ）。在处理初始分配之后和启动应用程序任务之前调用该方法。因此，该方法可以对用户输入做出反应。 使用时 FB_Init 或者 {attribute 'call_after_init'} ，记住检测错误 FB_Init 方法或用 {attribute 'call_after_init'} 属性比较繁琐，因为断点的设置可能没有预期的效果。 如果在执行期间达到显式定义的初始化代码，则功能块实例已经通过隐式初始化代码完全初始化。因此，一定不能有 SUPER^.FB_Init 称呼。 FB_Init 取代 INI 运算符用于 CoDeSys V2.3 .这些方法无法与构造函数的设计进行比较，例如 C#、C++ 或 Java。这会对扩展其他功能块的功能块产生影响。 （见下文：“派生功能块”） " }, 
{ "title" : "方法接口 FB_Init ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_484f4ece66da11e7bb4fee5053811542", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 方法: FB_Init , FB_Reinit 和 FB_Exit \/ 方法接口 FB_Init ", 
"snippet" : "METHOD FB_Init : BOOL VAR_INPUT bInitRetains : BOOL; \/\/ TRUE: the retain variables are initialized (reset warm \/ reset cold) bInCopyCode : BOOL; \/\/ TRUE: the instance will be copied to the copy code afterward (online change) END_VAR 您可以在一个 FB_init 方法。然后您必须在功能块实例的声明中设置这些输入。 例子 方法 FB_Init 为了 serialdev...", 
"body" : "METHOD FB_Init : BOOL\nVAR_INPUT\n bInitRetains : BOOL; \/\/ TRUE: the retain variables are initialized (reset warm \/ reset cold)\n bInCopyCode : BOOL; \/\/ TRUE: the instance will be copied to the copy code afterward (online change)\nEND_VAR 您可以在一个 FB_init 方法。然后您必须在功能块实例的声明中设置这些输入。 例子 方法 FB_Init 为了 serialdevice 功能块 METHOD PUBLIC FB_Init : BOOL\nVAR_INPUT\n nbInitRetains : BOOL; \/\/ initializing of retain variable\n bInCopyCode : BOOL; \/\/ instance is copied to copy code\n iCOMnum : INT; \/\/ additional input: number of the COM interface, that is to be observed\nEND_VAR 的实例化 serialdevice 功能块： com1: serialdevice(iCOMnum:=1);\ncom0: serialdevice(iCOMnum:=0); " }, 
{ "title" : "方法接口 FB_Reinit ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_32c7a9d6655911e799f4cbb808a4a9d0", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 方法: FB_Init , FB_Reinit 和 FB_Exit \/ 方法接口 FB_Reinit ", 
"snippet" : "METHOD FB_Reinit : BOOL...", 
"body" : "METHOD FB_Reinit : BOOL " }, 
{ "title" : "方法接口 FB_Exit ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_12190eb0ce4c52dbc0a864635e0a9fea", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 方法: FB_Init , FB_Reinit 和 FB_Exit \/ 方法接口 FB_Exit ", 
"snippet" : "有强制参数 bInCopyCode . METHOD FB_Exit : BOOL VAR_INPUT bInCopyCode : BOOL; \/\/ TRUE: the exit method is called in order to leave the instance which will be copied afterwards (online change). END_VAR...", 
"body" : "有强制参数 bInCopyCode . METHOD FB_Exit : BOOL\nVAR_INPUT\n bInCopyCode : BOOL; \/\/ TRUE: the exit method is called in order to leave the instance which will be copied afterwards (online change).\nEND_VAR " }, 
{ "title" : "派生功能块的行为 ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_b9d7fa100be0aaf3c0a864636c5fb2da", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 方法: FB_Init , FB_Reinit 和 FB_Exit \/ 派生功能块的行为 ", 
"snippet" : "如果一个功能块派生自另一个功能块，则 FB_Init 派生功能块的方法必须定义与 FB_Init 基本功能块的方法。但是，您可以添加更多参数以便为实例设置特殊初始化。 例子 功能块 MainFB , SubFB ， 和 SubSubFB 是相互衍生的。所以， SubFB EXTENDS MainFB 和 SubSubFB EXTENDS SubFB 申请。 方法的调用顺序 FB_Exit 和 FB_Init ： fbSubSubFb.FB_Exit(...); fbSubFb.FB_Exit(...); fbMainFb.FB_Exit(...); fbMainFb.FB_Init(...);...", 
"body" : "如果一个功能块派生自另一个功能块，则 FB_Init 派生功能块的方法必须定义与 FB_Init 基本功能块的方法。但是，您可以添加更多参数以便为实例设置特殊初始化。 例子 功能块 MainFB , SubFB ， 和 SubSubFB 是相互衍生的。所以， SubFB EXTENDS MainFB 和 SubSubFB EXTENDS SubFB 申请。 方法的调用顺序 FB_Exit 和 FB_Init ： fbSubSubFb.FB_Exit(...); fbSubFb.FB_Exit(...); fbMainFb.FB_Exit(...); fbMainFb.FB_Init(...); fbSubFb.FB_Init(...); fbSubSubFb.FB_Init(...); " }, 
{ "title" : "Global Init Slots ", 
"url" : "_cds_global_init_slots.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ Global Init Slots ", 
"snippet" : "投币口 插件\/库 普乌 描述 123 GVLObject __var_persistent_write 将持久变量从持久列表复制到映射的实例路径 199 Compiler __var__retain__read__ 将保留变量从保留区域复制到实例路径（仅适用于目标设置 retain-in-cycle-code ） 200 LanguageModelManager __ValidateLicenseMetrics 发送 AppBasedLicenseMetrics 到设备的运行时系统 500 VisualObject Visu__VisualManager__AfterInitProgram 可...", 
"body" : "投币口 插件\/库 普乌 描述 123 GVLObject __var_persistent_write 将持久变量从持久列表复制到映射的实例路径 199 Compiler __var__retain__read__ 将保留变量从保留区域复制到实例路径（仅适用于目标设置 retain-in-cycle-code ） 200 LanguageModelManager __ValidateLicenseMetrics 发送 AppBasedLicenseMetrics 到设备的运行时系统 500 VisualObject Visu__VisualManager__AfterInitProgram 可视化的初始化（调用所有标记为的初始化 Called within Visu-Initialization ） 500 VisualObject __datasourcesFrameVisualCallTree 可视化与数据源的交互 600 DataSourcesObject __datasourcesUpdateByDefaultCall 数据源初始化 600 DataSourcesObject __datasourcesUpdateByDefaultGVL 数据源初始化 1000 DeviceObject IoGlobalInit__Pou 设备对象实例的初始化 1000 图书馆： Datasource ApplicationV3 Access Logger 该库的日志记录初始化 1000 图书馆： Datasource Symbolic Access Logger 该库的日志记录初始化 1000 图书馆： Datasources Logger 该库的日志记录初始化 1234 ApplicationComposer AC_Init 生成的POU的初始化 1234 ApplicationComposer AC_OnlineChange 重新初始化由 Application Composer 创建的结构\/FB 10000 图书馆： Datasource Symbolic Access GVL_EarlyInit 符号数据源的初始化 20000 图书馆： Alarm Manager AlarmConstants 报警处理初始化 24000 图书馆： VisuElemBase Private_Visu_Globals 可视化的初始化 在 visu 初始化中调用 visu 24000 图书馆： VisuElemBase GVL_NativeElement 可视化的初始化 在 visu 初始化中调用 visu 24000 图书馆： VisuElemBase GVL_TypeInformation 可视化的初始化 24000 图书馆： Visu Interfaces GVL 可视化的初始化 在 visu 初始化中调用 visu 25000 图书馆： VisuElemBase GVL_CommandManager 可视化的初始化 在 visu 初始化中调用 visu 25000 图书馆： VisuElemBase Visu_Globals 可视化的初始化 在 visu 初始化中调用 visu 25000 图书馆： VisuCommandInterface GVL 可视化的初始化 25000 图书馆： RecipeManagement GVL_RecipeManagement_Temp 可视化的初始化 25990 图书馆： VisuElemBase VisuFctDatasourcesResourceEntryAllocatorGet_MBM 可视化的初始化 在 visu 初始化中调用 visu 25990 图书馆： VisuElemBase VisuFctDatasourcesResourceEntryAllocatorGet_SysMem 可视化的初始化 在 visu 初始化中调用 visu 26000 图书馆： VisuElemBase Visu_Resources 可视化的初始化 在 visu 初始化中调用 visu 30000 图书馆： Alarm Manager AlarmGlobals 报警处理初始化 30000 图书馆： Alarm Manager GloballyForAlarmStorage 报警处理初始化（之后必须初始化的部分 _3SStorage ） 30000 图书馆： VisuFPlot GlobalInstances 可视化的初始化 在 visu 初始化中调用 visu 30000 图书馆： VisuTrendStorageAccess GlobalInstances 可视化的初始化 在 visu 初始化中调用 visu 39900 DeviceObject IoConfig_Globals_ModuleList 所有设备（现场总线从站、SoftMotion 轴等）的所有连接器的模块列表 40000 DeviceObject IoConfig_Globals_Mapping 来自所有设备（现场总线从站、SoftMotion 轴等）的映射新变量 40000 TrendRecordingObject __GVL__TrendRecordingManager 趋势记录初始化 40100 DeviceObject IoConfig_Forces_Reset 映射的力变量，如果 为 I\/O 映射生成强制变量 选项已设置 49980 Compiler 全部 VAR_STAT 初始化所有声明的变量 VAR_STAT 49985 Compiler __MemManDefinition 用于动态内存管理的 GVL 必须在“正常”GVL 之前初始化，以确保“正常”GVL 可以依赖于已初始化的动态内存管理。 49990 Compiler 所有 GVL 所有 GVL（全局变量列表）的默认值 50000 Compiler 默认槽位 适用于所有 POU（程序、功能块）的标准插槽 50000 VisualObject Visu__VisualManager__GVL__0 可视化的初始化 在 visu 初始化中调用 visu_generated 50500 VisualObject __VisuInitInstantiation_GVL 可视化的初始化 在 visu 初始化中调用 visu_generated 51000 VisualObject Visu__VisualManager__CommonGVL 可视化的初始化 在 visu 初始化中调用 visu_generated 55000 VisualObject Visu__VisualManager__GVL__2 可视化的初始化 在 visu 初始化中调用 visu_generated 56000 VisualObject __NativeElementUserDefTypesCall 可视化的初始化（HTML5 控件的类型信息） 56000 VisualObject __NativeElementUserDefTypesGVL 可视化的初始化（HTML5 控件的类型信息） 56000 DataSourcesObject __providerSymbolsCall 数据源初始化 56000 DataSourcesObject __providerSymbolsGVL 数据源的初始化 56000 DataSourcesObject __datasourcesSymbolsCall 数据源的初始化 56000 DataSourcesObject __datasourcesSymbolsGVL 数据源初始化 56500 DataSourcesObject __GVL_Datasources_Constants 数据源初始化 57000 DataSourcesObject __datasourcesInstancesCall 数据源初始化 57000 DataSourcesObject __datasourcesInstancesGVL 数据源初始化 58000 DataSourcesObject __GVL_Datasources 数据源初始化 60000 DeviceObject IoConfig_Globals 所有设备（现场总线从站、SoftMotion 轴等）的功能块实例 60000 TrendRecordingObject __GVL__TrendRecording__ + _metaObject.Name 趋势记录初始化 60100 DeviceObject IoConfigRemote_Globals 安全 SIL3 上下文的映射变量 70000 图书馆： VisuElemBase Private_Visu_Globals_LateInit 可视化的初始化 在 visu 初始化中调用 visu_late 70000 图书馆： Visu Utils PublicVariables 可视化的初始化 在 visu 初始化中调用 visu_late 70000 图书馆： Visu Utils 变量 可视化的初始化 在 visu 初始化中调用 visu_late 123456 UnitConversionObject \"__\" + _metaObject.Name + \"_InitPrg 与数据源交互 150000 图书馆： VisuDialogs Dialog_Variables 可视化的初始化 在 visu 初始化中调用 visu 150000 图书馆： VisuDialogs Dialog_Variables_Exp 可视化的初始化 在 visu 初始化中调用 visu 150000 RecipeManObject GVL_RecipeManagement_3300 菜谱初始化 150000 RecipeManObject GVL_RecipeManagement 菜谱初始化 151000 RecipeManObject RecipeManagementInitAfterGlobalInit 菜谱初始化 call_after_online_change_concurrent_slot 1000 200000 图书馆： VisuElemBase GVL_ShutdownCheck 可视化的初始化\/停用 在 visu 初始化中调用 visu " }, 
{ "title" : "错误消息和警告 ", 
"url" : "_cds_struct_reference_errors.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "编译器错误 C0001 ", 
"url" : "_cds_error_c0001.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0001 ", 
"snippet" : "C0001 信息 : 常量“<常量值>”对于类型“<数据类型>”来说太大了 可能的错误原因 : 对于给定的数据类型，类型化常量太大，或者对于每种可能的数据类型，常量都太大。 错误修正 : 对类型化的常量使用较小的常量或适当的数据类型。 错误示例： PROGRAM PLC_PRG VAR test1: INT; test2: INT; test3: LREAL; END_VAR test1 := 12345678912345566991923939292939911; test2 := INT#123456; test3 := 10E500; 信息： C0001：常量 '123456789123...", 
"body" : "C0001 信息 : 常量“<常量值>”对于类型“<数据类型>”来说太大了 可能的错误原因 : 对于给定的数据类型，类型化常量太大，或者对于每种可能的数据类型，常量都太大。 错误修正 : 对类型化的常量使用较小的常量或适当的数据类型。 错误示例： PROGRAM PLC_PRG\nVAR\n test1: INT;\n test2: INT;\n test3: LREAL;\nEND_VAR\n\ntest1 := 12345678912345566991923939292939911;\ntest2 := INT#123456;\ntest3 := 10E500;\n 信息： C0001：常量 '12345678912345566991923939292939911' 对于类型 'ANY_INT' 来说太大 C0001: 常量 'INT#123456' 对于类型 'INT' 来说太大 C0001: 常量 '10E500' 对于类型 'ANY_REAL' 来说太大 " }, 
{ "title" : "编译器错误 C0002 ", 
"url" : "_cds_error_c0002.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0002 ", 
"snippet" : "C0002 信息 : '<operator 1>' 或 '<operator 2>' 预期而不是 '<tag>' 可能的错误原因 : 语法错误 错误修正 : 使用正确的语法。 错误示例： PROGRAM PLC_PRG Fun(1; 信息： C0002: ',' 或 ')' 而不是 ';'...", 
"body" : "C0002 信息 : '<operator 1>' 或 '<operator 2>' 预期而不是 '<tag>' 可能的错误原因 : 语法错误 错误修正 : 使用正确的语法。 错误示例： PROGRAM PLC_PRG\nFun(1;\n 信息： C0002: ',' 或 ')' 而不是 ';' " }, 
{ "title" : "编译器错误 C0003 ", 
"url" : "_cds_error_c0003.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0003 ", 
"snippet" : "C0003 信息 : '<value>' 不是 '<variable>' 的有效位数 可能的错误原因 : 尝试访问超出数据类型范围的位。 错误修正 : 对位访问使用一个位值，该位值小于变量数据类型中的位数。 错误示例： PROGRAM PLC_PRG VAR test1: WORD; test2: BOOL; END_VAR test1 := test2.17; 信息： C0003：“17”不是“w”的有效位数...", 
"body" : "C0003 信息 : '<value>' 不是 '<variable>' 的有效位数 可能的错误原因 : 尝试访问超出数据类型范围的位。 错误修正 : 对位访问使用一个位值，该位值小于变量数据类型中的位数。 错误示例： PROGRAM PLC_PRG\nVAR\n test1: WORD;\n test2: BOOL;\nEND_VAR\n\ntest1 := test2.17;\n 信息： C0003：“17”不是“w”的有效位数 " }, 
{ "title" : "编译器错误 C0004 ", 
"url" : "_cds_error_c0004.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0004 ", 
"snippet" : "C0004 信息 : '<variable>' 不是 '<structure>' 的组成部分 可能的错误原因 : 用“.”访问组件到不是结构化值或不作为结构组件存在的变量。 错误修正 ：访问已定义的组件，或更改数据类型中组件的定义。输入辅助“列出组件”提供了对该位置的所有有效访问。 错误示例： TYPE DUT: STRUCT x, y : INT; END_STRUCT END_TYPE PROGRAM PLC_PRG VAR test1 : DUT; test2 : INT; END_VAR test2 := test1.z; 信息： C0032：类型'未知类型：'test1.z' 无法转...", 
"body" : "C0004 信息 : '<variable>' 不是 '<structure>' 的组成部分 可能的错误原因 : 用“.”访问组件到不是结构化值或不作为结构组件存在的变量。 错误修正 ：访问已定义的组件，或更改数据类型中组件的定义。输入辅助“列出组件”提供了对该位置的所有有效访问。 错误示例： TYPE DUT:\nSTRUCT\n x, y : INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n test1 : DUT;\n test2 : INT;\nEND_VAR\n\ntest2 := test1.z;\n 信息： C0032：类型'未知类型：'test1.z' 无法转换为类型'INT' C0032：类型'未知类型：'test1.z' 无法转换为类型'INT' " }, 
{ "title" : "编译器错误 C0005 ", 
"url" : "_cds_error_c0005.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0005 ", 
"snippet" : "C0005 信息 : 地址“<地址>”中的常量溢出 可能的错误原因 ：地址中至少有一个组件不适合 32 位整数值。 错误修正 ：使用有效的地址表达式。 错误示例： PROGRAM PLC_PRG VAR X: BYTE; END_VAR X := %QB5555555555; 信息： C0005: 地址 '%??' 中的常量溢出...", 
"body" : "C0005 信息 : 地址“<地址>”中的常量溢出 可能的错误原因 ：地址中至少有一个组件不适合 32 位整数值。 错误修正 ：使用有效的地址表达式。 错误示例： PROGRAM PLC_PRG\nVAR\n X: BYTE;\nEND_VAR\n\nX := %QB5555555555;\n 信息： C0005: 地址 '%??' 中的常量溢出 " }, 
{ "title" : "编译器错误 C0006 ", 
"url" : "_cds_error_c0006.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0006 ", 
"snippet" : "C0006 信息 : '<operator>' 预期而不是 '<token>' 可能的错误原因 : 语法错误 错误修正 : 使用正确的语法。 错误示例： PROGRAM PLC_PRG VAR x: INT; bTest : BOOL; END_VAR IF bTest x := 9; END_IF 信息： C0006: 'THEN' 预期而不是 'x'...", 
"body" : "C0006 信息 : '<operator>' 预期而不是 '<token>' 可能的错误原因 : 语法错误 错误修正 : 使用正确的语法。 错误示例： PROGRAM PLC_PRG\nVAR\n x: INT;\n bTest : BOOL;\nEND_VAR\n\nIF bTest\n x := 9;\nEND_IF\n 信息： C0006: 'THEN' 预期而不是 'x' " }, 
{ "title" : "编译器错误 C0007 ", 
"url" : "_cds_error_c0007.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0007 ", 
"snippet" : "C0007 梅尔东 : 期望表达式而不是 '<token>' 可能的错误原因 : 语法错误 错误修正 : 使用正确的语法。 错误示例： PROGRAM PLC_PRG VAR x: INT; bTest : BOOL; END_VAR IF THEN x := 9; END_IF 信息： C0007: 期望表达式而不是 'THEN'...", 
"body" : "C0007 梅尔东 : 期望表达式而不是 '<token>' 可能的错误原因 : 语法错误 错误修正 : 使用正确的语法。 错误示例： PROGRAM PLC_PRG\nVAR\n x: INT;\n bTest : BOOL;\nEND_VAR\n\nIF THEN\n x := 9;\nEND_IF\n 信息： C0007: 期望表达式而不是 'THEN' " }, 
{ "title" : "编译器错误 C0008 ", 
"url" : "_cds_error_c0008.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0008 ", 
"snippet" : "C0008 信息 : 发现意外的文件结尾：“<operator>”、“<operator>”或“<operator>”预期 可能的错误原因 : 语法错误 错误修正 : 使用正确的语法。 错误示例： PROGRAM PLC_PRG VAR x: INT; bTest : BOOL; END_VAR IF bTest THEN x := 9; 信息： C0008：发现意外的文件结尾：预期为“ELSIF”、“ELSE”或“END_IF”...", 
"body" : "C0008 信息 : 发现意外的文件结尾：“<operator>”、“<operator>”或“<operator>”预期 可能的错误原因 : 语法错误 错误修正 : 使用正确的语法。 错误示例： PROGRAM PLC_PRG\nVAR\n x: INT;\n bTest : BOOL;\nEND_VAR\n\nIF bTest THEN\n x := 9;\n 信息： C0008：发现意外的文件结尾：预期为“ELSIF”、“ELSE”或“END_IF” " }, 
{ "title" : "编译器错误 C0009 ", 
"url" : "_cds_error_c0009.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0009 ", 
"snippet" : "C0009 信息 : 发现意外的令牌 '<token>' 可能的错误原因 : 语法错误 错误修正 : 使用正确的语法。 错误示例： PROGRAM PLC_PRG VAR END_VAR END_FOR; 信息： C0009：发现意外的令牌“END_FOR”...", 
"body" : "C0009 信息 : 发现意外的令牌 '<token>' 可能的错误原因 : 语法错误 错误修正 : 使用正确的语法。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nEND_FOR;\n 信息： C0009：发现意外的令牌“END_FOR” " }, 
{ "title" : "编译器错误 C0010 ", 
"url" : "_cds_error_c0010.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0010 ", 
"snippet" : "C0010 信息 : 发现意外的文件结尾: '<token>' 预期 可能的错误原因 : 语法错误 错误修正 : 使用正确的语法。 错误示例： PROGRAM PLC_PRG VAR i: INT; END_VAR FOR i := 0 TO 2 DO ; 信息： C0010：发现意外的文件结尾：预期为“END_FOR”...", 
"body" : "C0010 信息 : 发现意外的文件结尾: '<token>' 预期 可能的错误原因 : 语法错误 错误修正 : 使用正确的语法。 错误示例： PROGRAM PLC_PRG\nVAR\n i: INT;\nEND_VAR\n\nFOR i := 0 TO 2 DO\n;\n 信息： C0010：发现意外的文件结尾：预期为“END_FOR” " }, 
{ "title" : "编译器错误 C0011 ", 
"url" : "_cds_error_c0011.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0011 ", 
"snippet" : "C0011 信息 ：未找到“CASE”标签 可能的错误原因 : CASE 语句中的语法错误。 CASE 语句中的语句未分配给 CASE 标签。 错误修正 ：添加一个 CASE 标签。 错误示例： PROGRAM PLC_PRG VAR i: INT; x: INT; END_VAR CASE i OF x := 9; END_CASE 信息： C0011：未找到“CASE”标签 错误修正： CASE i OF 0: x := 9; END_CASE...", 
"body" : "C0011 信息 ：未找到“CASE”标签 可能的错误原因 : CASE 语句中的语法错误。 CASE 语句中的语句未分配给 CASE 标签。 错误修正 ：添加一个 CASE 标签。 错误示例： PROGRAM PLC_PRG\nVAR\n i: INT;\n x: INT;\nEND_VAR\n\nCASE i OF\n x := 9;\nEND_CASE\n 信息： C0011：未找到“CASE”标签 错误修正： CASE i OF\n0:\n x := 9;\nEND_CASE " }, 
{ "title" : "编译器错误 C0013 ", 
"url" : "_cds_error_c0013.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0013 ", 
"snippet" : "C0013 信息 : 至少需要一个声明。 可能的错误原因 : 在代码中的某些位置至少需要一个语句。例如，在 IF 语句的 THEN 和 ELSE 部分中，或在 FOR 循环的主体中。 错误修正 ：在所选位置添加至少一条语句。写一个空白语句“;”就足够了。 错误示例： PROGRAM PLC_PRG VAR bTest: BOOL; END_VAR IF bTest THEN END_IF 信息： C0013: 至少需要一个语句。...", 
"body" : "C0013 信息 : 至少需要一个声明。 可能的错误原因 : 在代码中的某些位置至少需要一个语句。例如，在 IF 语句的 THEN 和 ELSE 部分中，或在 FOR 循环的主体中。 错误修正 ：在所选位置添加至少一条语句。写一个空白语句“;”就足够了。 错误示例： PROGRAM PLC_PRG\nVAR\n bTest: BOOL;\nEND_VAR\n\nIF bTest THEN\nEND_IF\n 信息： C0013: 至少需要一个语句。 " }, 
{ "title" : "编译器错误 C0015 ", 
"url" : "_cds_error_c0015.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0015 ", 
"snippet" : "C0015 信息 : 预计计数器初始化 可能的错误原因 : FOR 循环中的语法错误。计数器变量未正确初始化。 错误修正 : 注意 FOR 循环的正确语法。 错误示例： PROGRAM PLC_PRG VAR i: INT; END_VAR FOR i TO 10 DO ; END_FOR --> C0015: Zählvariableninitialisierung erwartet 信息： C0015：预期计数器初始化 错误修正： FOR i := 0 TO 10 DO ; END_FOR...", 
"body" : "C0015 信息 : 预计计数器初始化 可能的错误原因 : FOR 循环中的语法错误。计数器变量未正确初始化。 错误修正 : 注意 FOR 循环的正确语法。 错误示例： PROGRAM PLC_PRG\nVAR\n i: INT;\nEND_VAR\n\nFOR i TO 10 DO\n ;\nEND_FOR\n\n--> C0015: Zählvariableninitialisierung erwartet 信息： C0015：预期计数器初始化 错误修正： FOR i := 0 TO 10 DO\n ;\nEND_FOR " }, 
{ "title" : "编译器错误 C0018 ", 
"url" : "_cds_error_c0018.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0018 ", 
"snippet" : "C0018 信息 : <表达式> 不是有效的赋值目标 可能的错误原因 : 没有写权限的表达式在赋值的左边。例子：一个常数。 错误修正 ：仅分配给具有写访问权限的变量。 错误示例： PROGRAM PLC_PRG VAR i: INT; END_VAR VAR CONSTANT j: INT := 0; END_VAR j := i; 信息： C0018: 'j' 不是有效的分配目标...", 
"body" : "C0018 信息 : <表达式> 不是有效的赋值目标 可能的错误原因 : 没有写权限的表达式在赋值的左边。例子：一个常数。 错误修正 ：仅分配给具有写访问权限的变量。 错误示例： PROGRAM PLC_PRG\nVAR\n i: INT;\nEND_VAR\nVAR CONSTANT\n j: INT := 0;\nEND_VAR\n\nj := i;\n 信息： C0018: 'j' 不是有效的分配目标 " }, 
{ "title" : "编译器错误 C0020 ", 
"url" : "_cds_error_c0020.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0020 ", 
"snippet" : "C0020 信息 : '<statement>' 不是有效的语句 可能的错误原因 : 语法错误（例如，字符太少或太多） 错误修正 : 确保语法正确。 错误示例： PROGRAM PLC_PRG VAR x : INT; END_VAR x = 2; 信息： C0020: '(x = 2); ' 不是有效的陈述 错误修正： x := 2;...", 
"body" : "C0020 信息 : '<statement>' 不是有效的语句 可能的错误原因 : 语法错误（例如，字符太少或太多） 错误修正 : 确保语法正确。 错误示例： PROGRAM PLC_PRG\nVAR\n x : INT;\nEND_VAR\n\nx = 2;\n 信息： C0020: '(x = 2); ' 不是有效的陈述 错误修正： x := 2; " }, 
{ "title" : "编译器错误 C0022 ", 
"url" : "_cds_error_c0022.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0022 ", 
"snippet" : "C0022 信息 : '<operator>' 正好需要 '<number of operands>' 操作数 可能的错误原因 : 分配给运算符的操作数过多或过少。 错误修正 ：将所需数量的操作数分配给运算符。 错误示例： PROGRAM PLC_PRG VAR i : INT; pt: POINTER TO INT; END_VAR pt := ADR(i,1); 信息： C0022: 'ADR' 需要正好 '1' 操作数 错误修正： pt := ADR(i);...", 
"body" : "C0022 信息 : '<operator>' 正好需要 '<number of operands>' 操作数 可能的错误原因 : 分配给运算符的操作数过多或过少。 错误修正 ：将所需数量的操作数分配给运算符。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n pt: POINTER TO INT;\nEND_VAR\n\npt := ADR(i,1);\n 信息： C0022: 'ADR' 需要正好 '1' 操作数 错误修正： pt := ADR(i); " }, 
{ "title" : "编译器错误 C0023 ", 
"url" : "_cds_error_c0023.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0023 ", 
"snippet" : "C0023 信息 : '<operator>' 至少需要 '<number of operands>' 操作数 可能的错误原因 : 分配给运算符的操作数太少。 错误修正 ：将所需数量的操作数分配给运算符。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := MUX(30,40); 信息： C0023：“MUX”至少需要“3”个操作数 错误修正： i := MUX(30,40,50);...", 
"body" : "C0023 信息 : '<operator>' 至少需要 '<number of operands>' 操作数 可能的错误原因 : 分配给运算符的操作数太少。 错误修正 ：将所需数量的操作数分配给运算符。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\ni := MUX(30,40);\n 信息： C0023：“MUX”至少需要“3”个操作数 错误修正： i := MUX(30,40,50); " }, 
{ "title" : "编译器错误 C0026 ", 
"url" : "_cds_error_c0026.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0026 ", 
"snippet" : "C0026 信息 : 需要标识符而不是 '<invalid identifier>' 可能的错误原因 : 一个无效的标识符被传递给一个方法。 错误修正 : 使用有效的标识符。 错误示例： METHOD 123 VAR_INPUT END_VAR 信息： C0243：签名中使用的名称与对象名称不同 C0026: 需要标识符而不是“123” 错误修正： METHOD METH123...", 
"body" : "C0026 信息 : 需要标识符而不是 '<invalid identifier>' 可能的错误原因 : 一个无效的标识符被传递给一个方法。 错误修正 : 使用有效的标识符。 错误示例： METHOD 123\nVAR_INPUT\nEND_VAR\n 信息： C0243：签名中使用的名称与对象名称不同 C0026: 需要标识符而不是“123” 错误修正： METHOD METH123 " }, 
{ "title" : "编译器错误 C0027 ", 
"url" : "_cds_error_c0027.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0027 ", 
"snippet" : "C0027 信息 : '(' 之后的字符串大小 可能的错误原因 : 未指定字符串的长度。 错误修正 : 指定括号之间的字符串长度。 错误示例： PROGRAM PLC_PRG VAR str : STRING(); END_VAR 信息： C0027: '(' 之后的字符串大小 C0006: ';' :=, REF=, ( 或 [' 预期而不是 ')' 错误修正： str : STRING(100);...", 
"body" : "C0027 信息 : '(' 之后的字符串大小 可能的错误原因 : 未指定字符串的长度。 错误修正 : 指定括号之间的字符串长度。 错误示例： PROGRAM PLC_PRG\nVAR\n str : STRING();\nEND_VAR\n 信息： C0027: '(' 之后的字符串大小 C0006: ';' :=, REF=, ( 或 [' 预期而不是 ')' 错误修正： str : STRING(100); " }, 
{ "title" : "编译器错误 C0030 ", 
"url" : "_cds_error_c0030.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0030 ", 
"snippet" : "C0030 信息 : 在“AT”而不是“<identifier>”之后需要直接地址 可能的错误原因 : 在“AT”之后分配无效地址或未分配地址。 错误修正 ：指定一个有效的地址。 错误示例： PROGRAM PLC_PRG VAR i AT ABC : INT; END_VAR 信息： C0030：在“AT”而不是“ABC”之后需要直接地址 错误修正： i AT %IW0 : INT;...", 
"body" : "C0030 信息 : 在“AT”而不是“<identifier>”之后需要直接地址 可能的错误原因 : 在“AT”之后分配无效地址或未分配地址。 错误修正 ：指定一个有效的地址。 错误示例： PROGRAM PLC_PRG\nVAR\n i AT ABC : INT;\nEND_VAR\n 信息： C0030：在“AT”而不是“ABC”之后需要直接地址 错误修正： i AT %IW0 : INT; " }, 
{ "title" : "编译器错误 C0031 ", 
"url" : "_cds_error_c0031.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0031 ", 
"snippet" : "C0031 信息 : 需要类型定义而不是“<无数据类型>” 可能的错误原因 : 为标识符分配了无效的类型定义。 错误修正 : 指定一个有效的类型定义。 错误示例： PROGRAM PLC_PRG VAR i : 0; END_VAR 信息： C0031: 需要类型定义而不是“0” 错误修正： i : INT;...", 
"body" : "C0031 信息 : 需要类型定义而不是“<无数据类型>” 可能的错误原因 : 为标识符分配了无效的类型定义。 错误修正 : 指定一个有效的类型定义。 错误示例： PROGRAM PLC_PRG\nVAR\n i : 0;\nEND_VAR\n 信息： C0031: 需要类型定义而不是“0” 错误修正： i : INT; " }, 
{ "title" : "编译器错误 C0032 ", 
"url" : "_cds_error_c0032.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0032 ", 
"snippet" : "C0032 信息 : 类型 '<type 1>' 无法转换为 '<type 2>' 可能的错误原因 ：一个变量被分配给另一个类型不兼容的变量。 错误修正 : 使用类型转换。 错误示例： PROGRAM PLC_PRG VAR test1: INT; test2: STRING; END_VAR test1 := test2; 信息： C0032：“STRING”类型无法转换为“INT”类型 错误修正： test1 := TO_INT(test2);...", 
"body" : "C0032 信息 : 类型 '<type 1>' 无法转换为 '<type 2>' 可能的错误原因 ：一个变量被分配给另一个类型不兼容的变量。 错误修正 : 使用类型转换。 错误示例： PROGRAM PLC_PRG\nVAR\n test1: INT;\n test2: STRING;\nEND_VAR\n\ntest1 := test2;\n 信息： C0032：“STRING”类型无法转换为“INT”类型 错误修正： test1 := TO_INT(test2); " }, 
{ "title" : "编译器警告 C0033 ", 
"url" : "_cds_error_c0033.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0033 ", 
"snippet" : "C0033 信息 : 类型“<指针类型>”可能无法转换为类型“<数据类型>”。 可能的错误原因 : 只有在检查池对象时才会出现此错误。尝试将指针转换为整数。因为库中指针的大小是未知的，所以在使用库时可能会出现错误。 错误修正 ：使用类型 __UXINT 或者 __XWORD 用于使用指针的平台无关计算。 错误示例： PROGRAM PLC_PRG VAR ptr : POINTER TO INT; dw : DWORD; END_VAR dw := ptr; 信息： C0033：类型“POINTER TO INT”可能无法转换为类型“DWORD”。...", 
"body" : "C0033 信息 : 类型“<指针类型>”可能无法转换为类型“<数据类型>”。 可能的错误原因 : 只有在检查池对象时才会出现此错误。尝试将指针转换为整数。因为库中指针的大小是未知的，所以在使用库时可能会出现错误。 错误修正 ：使用类型 __UXINT 或者 __XWORD 用于使用指针的平台无关计算。 错误示例： PROGRAM PLC_PRG\nVAR\n ptr : POINTER TO INT;\n dw : DWORD;\nEND_VAR\n dw := ptr;\n 信息： C0033：类型“POINTER TO INT”可能无法转换为类型“DWORD”。 " }, 
{ "title" : "编译器错误 C0035 ", 
"url" : "_cds_error_c0035.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0035 ", 
"snippet" : "C0035 信息 : 程序名称、功能或功能块实例，而不是 '<invalid function>' 可能的错误原因 : 调用了一个不存在的函数。 错误修正 ：确保只调用存在的程序名称、功能和功能块实例。 错误示例： PROGRAM PLC_PRG VAR END_VAR PLC_PRG.METH1(); METHOD METH VAR_INPUT END_VAR 信息： C0004：“METH1”不是“PLC_PRG”的组件 C0035：需要程序名称、功能或功能块实例而不是“PLC_PRG.METH1” 错误修正： PLC_PRG.METH();...", 
"body" : "C0035 信息 : 程序名称、功能或功能块实例，而不是 '<invalid function>' 可能的错误原因 : 调用了一个不存在的函数。 错误修正 ：确保只调用存在的程序名称、功能和功能块实例。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nPLC_PRG.METH1();\n\nMETHOD METH\nVAR_INPUT\nEND_VAR\n 信息： C0004：“METH1”不是“PLC_PRG”的组件 C0035：需要程序名称、功能或功能块实例而不是“PLC_PRG.METH1” 错误修正： PLC_PRG.METH(); " }, 
{ "title" : "编译器错误 C0036 ", 
"url" : "_cds_error_c0036.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0036 ", 
"snippet" : "C0036 信息 : 无法调用 <type> 类型的对象 可能的错误原因 : 已尝试调用不支持任何调用的对象。 错误修正 : 只能调用函数、功能块、程序、方法和动作。 错误示例： VAR_GLOBAL GVL value : INT; END_VAR PROGRAM PLC_PRG GVL(); 信息： C0036: 无法调用“VAR_GLOBAL”类型的对象...", 
"body" : "C0036 信息 : 无法调用 <type> 类型的对象 可能的错误原因 : 已尝试调用不支持任何调用的对象。 错误修正 : 只能调用函数、功能块、程序、方法和动作。 错误示例： VAR_GLOBAL GVL\n value : INT;\nEND_VAR\nPROGRAM PLC_PRG\nGVL();\n 信息： C0036: 无法调用“VAR_GLOBAL”类型的对象 " }, 
{ "title" : "编译器错误 C0037 ", 
"url" : "_cds_error_c0037.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0037 ", 
"snippet" : "C0037 信息 : '<invalid input>' 不是 '<function name>' 的输入 可能的错误原因 : 在函数调用中定义了一个局部变量。 错误修正 ：将变量声明为输入参数。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := TEST(iVar := 1); FUNCTION TEST : INT VAR iVar : INT; END_VAR 信息： C0037：“iVar”不是“TEST”的输入 错误修正： VAR_INPUT iVar : INT; END_VAR...", 
"body" : "C0037 信息 : '<invalid input>' 不是 '<function name>' 的输入 可能的错误原因 : 在函数调用中定义了一个局部变量。 错误修正 ：将变量声明为输入参数。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni := TEST(iVar := 1);\n\nFUNCTION TEST : INT\nVAR\n iVar : INT;\nEND_VAR\n 信息： C0037：“iVar”不是“TEST”的输入 错误修正： VAR_INPUT\n iVar : INT;\nEND_VAR " }, 
{ "title" : "编译器错误 C0038 ", 
"url" : "_cds_error_c0038.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0038 ", 
"snippet" : "C0038 信息 : '<invalid output>' 不是'<function name>' 的输出 可能的错误原因 ：局部变量在函数调用中作为输出处理。 错误修正 : 将变量声明为输出参数。 错误示例： PROGRAM PLC_PRG VAR i : INT; x : INT; END_VAR i := TEST(iVar => x); FUNCTION TEST : INT VAR iVar : INT; END_VAR 信息： C0038：“iVar”没有“TEST”输出 错误修正： VAR_OUTPUT iVar : INT; END_VAR...", 
"body" : "C0038 信息 : '<invalid output>' 不是'<function name>' 的输出 可能的错误原因 ：局部变量在函数调用中作为输出处理。 错误修正 : 将变量声明为输出参数。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n x : INT;\nEND_VAR\ni := TEST(iVar => x);\n\nFUNCTION TEST : INT\nVAR\n iVar : INT;\nEND_VAR\n 信息： C0038：“iVar”没有“TEST”输出 错误修正： VAR_OUTPUT\n iVar : INT;\nEND_VAR " }, 
{ "title" : "编译器错误 C0039 ", 
"url" : "_cds_error_c0039.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0039 ", 
"snippet" : "C0039 信息 : VAR_IN_OUT '<invalid variable>' 必须在调用 '<function block name>' 时赋值 可能的错误原因 : IN_OUT 变量不会传递给需要 IN_OUT 变量的功能块。 错误修正 ：分配 IN_OUT 变量。 错误示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR inst(); FUNCTION_BLOCK FB VAR_IN_OUT inout : INT; END_VAR 信息： C0039：必须在调用 'FB' 时分配 VAR_IN_OUT 'inout' 错误修正： inst(ino...", 
"body" : "C0039 信息 : VAR_IN_OUT '<invalid variable>' 必须在调用 '<function block name>' 时赋值 可能的错误原因 : IN_OUT 变量不会传递给需要 IN_OUT 变量的功能块。 错误修正 ：分配 IN_OUT 变量。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\ninst();\n\nFUNCTION_BLOCK FB\nVAR_IN_OUT\n inout : INT;\nEND_VAR\n 信息： C0039：必须在调用 'FB' 时分配 VAR_IN_OUT 'inout' 错误修正： inst(inout := i); " }, 
{ "title" : "编译器错误 C0040 ", 
"url" : "_cds_error_c0040.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0040 ", 
"snippet" : "C0040 信息 : 函数 '<function name>' 需要精确的 '<number of inputs>' 输入 可能的错误原因 : 传递给被调用函数的参数过多或过少。 错误修正 : 将与预期一样多的参数传递给函数。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := TEST(1,2); FUNCTION TEST : INT VAR_INPUT IN: INT; END_VAR 信息： C0040：功能“TEST”需要正好“1”输入 错误修正： i := Test(1);...", 
"body" : "C0040 信息 : 函数 '<function name>' 需要精确的 '<number of inputs>' 输入 可能的错误原因 : 传递给被调用函数的参数过多或过少。 错误修正 : 将与预期一样多的参数传递给函数。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni := TEST(1,2);\n\n\nFUNCTION TEST : INT\nVAR_INPUT\n IN: INT;\nEND_VAR\n 信息： C0040：功能“TEST”需要正好“1”输入 错误修正： i := Test(1); " }, 
{ "title" : "编译器错误 C0041 ", 
"url" : "_cds_error_c0041.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0041 ", 
"snippet" : "C0041 信息 : '<function name>' 的 VAR_IN_OUT 参数 '<parameter name>' 需要具有写访问权限的变量作为输入 可能的错误原因 ：传递的参数不是具有写访问权限的变量（例如常量）。 错误修正 : 传递一个对函数具有写访问权限的 VAR_IN_OUT 参数。 错误示例： PROGRAM PLC_PRG VAR i : INT; x : INT; END_VAR i := Test(31415); FUNCTION TEST : INT VAR_IN_OUT in_out: INT; END_VAR 信息： C0041：“TEST”的 VAR_IN_...", 
"body" : "C0041 信息 : '<function name>' 的 VAR_IN_OUT 参数 '<parameter name>' 需要具有写访问权限的变量作为输入 可能的错误原因 ：传递的参数不是具有写访问权限的变量（例如常量）。 错误修正 : 传递一个对函数具有写访问权限的 VAR_IN_OUT 参数。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n x : INT;\nEND_VAR\ni := Test(31415);\n\nFUNCTION TEST : INT\nVAR_IN_OUT\n in_out: INT;\nEND_VAR\n 信息： C0041：“TEST”的 VAR_IN_OUT 参数“in_out”需要具有写访问权限的变量作为输入 错误修正： i := Test(x); " }, 
{ "title" : "编译器错误 C0042（编译器版本 <= 3.4.10） ", 
"url" : "_cds_error_c0042.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0042（编译器版本 <= 3.4.10） ", 
"snippet" : "C0042 信息 ：在函数调用中必须表示所有或没有形式参数 可能的错误原因 ：参数以错误的顺序显式分配给函数。 错误修正 ：使用统一的形式参数或隐式参数。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := Test(iPar1:=2, 5); FUNCTION Test : INT VAR_INPUT iPar1 : INT; iPar2 : INT; END_VAR 信息： C0042：函数调用中必须表示全部或不表示形式参数...", 
"body" : "C0042 信息 ：在函数调用中必须表示所有或没有形式参数 可能的错误原因 ：参数以错误的顺序显式分配给函数。 错误修正 ：使用统一的形式参数或隐式参数。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n i := Test(iPar1:=2, 5);\n\nFUNCTION Test : INT\nVAR_INPUT\n iPar1 : INT;\n iPar2 : INT;\nEND_VAR\n 信息： C0042：函数调用中必须表示全部或不表示形式参数 " }, 
{ "title" : "编译器错误 C0043 ", 
"url" : "_cds_error_c0043.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0043 ", 
"snippet" : "C0043 信息 : 错误的形式参数：'<parameter name>' 应该在这个地方 可能的错误原因 ：参数以错误的顺序显式分配给函数。 错误修正 ：以正确的顺序指定参数。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := Test(iPar2 := 2, 5); FUNCTION Test : INT VAR_INPUT iPar1 : INT; iPar2 : INT; END_VAR 信息： C0043: 错误的形式参数: 'iPar1' 应该在这个地方 C0412：参数“”的多个输入分配 错误修正 ： i := Test(5, iPa...", 
"body" : "C0043 信息 : 错误的形式参数：'<parameter name>' 应该在这个地方 可能的错误原因 ：参数以错误的顺序显式分配给函数。 错误修正 ：以正确的顺序指定参数。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni := Test(iPar2 := 2, 5);\n\n\nFUNCTION Test : INT\nVAR_INPUT\n iPar1 : INT;\n iPar2 : INT;\nEND_VAR\n 信息： C0043: 错误的形式参数: 'iPar1' 应该在这个地方 C0412：参数“”的多个输入分配 错误修正 ： i := Test(5, iPar2 := 2); " }, 
{ "title" : "编译器错误 C0044 ", 
"url" : "_cds_error_c0044.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0044 ", 
"snippet" : "C0044 信息 ：在调用“<功能块名称>”时为参数“<输入变量名称>”分配输入缺失 可能的错误原因 : 尽管没有声明输入变量，但传递了一个参数。 错误修正 : 声明一个输入变量。 错误示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR inst(1); FUNCTION_BLOCK FB VAR_INPUT END_VAR 信息： C0044：在调用“FB”时缺少参数“1”的输入分配 错误修正： Beispiel: VAR_INPUT in : INT; END_VAR...", 
"body" : "C0044 信息 ：在调用“<功能块名称>”时为参数“<输入变量名称>”分配输入缺失 可能的错误原因 : 尽管没有声明输入变量，但传递了一个参数。 错误修正 : 声明一个输入变量。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\ninst(1);\n\n\nFUNCTION_BLOCK FB\nVAR_INPUT\n\nEND_VAR\n 信息： C0044：在调用“FB”时缺少参数“1”的输入分配 错误修正： Beispiel:\nVAR_INPUT\n in : INT;\nEND_VAR " }, 
{ "title" : "编译器错误 C0045 ", 
"url" : "_cds_error_c0045.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0045 ", 
"snippet" : "C0045 信息 ：在这种情况下不允许使用“THIS” 可能的错误原因 ：为了分配给当前实例，THIS 只能用于方法、动作、转换或功能块的主体中。此错误消息出现在所有其他位置。 错误修正 ：仅在允许的上下文中使用 THIS。 错误示例： PROGRAM PLC_PRG VAR test1: INT; END_VAR THIS^.test1 := 19; 信息： C0018: 'THIS^.test1' 不是有效的分配目标 C0062: 'THIS^' 不是结构变量 在这种情况下不允许使用“THIS”...", 
"body" : "C0045 信息 ：在这种情况下不允许使用“THIS” 可能的错误原因 ：为了分配给当前实例，THIS 只能用于方法、动作、转换或功能块的主体中。此错误消息出现在所有其他位置。 错误修正 ：仅在允许的上下文中使用 THIS。 错误示例： PROGRAM PLC_PRG\nVAR\n test1: INT;\nEND_VAR\n\nTHIS^.test1 := 19;\n 信息： C0018: 'THIS^.test1' 不是有效的分配目标 C0062: 'THIS^' 不是结构变量 在这种情况下不允许使用“THIS” " }, 
{ "title" : "编译器错误 C0046 ", 
"url" : "_cds_error_c0046.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0046 ", 
"snippet" : "C0046 信息 : 标识符“<标识符名称>”未定义 可能的错误原因 : 使用了未声明的标识符。 错误修正 ：声明要使用的变量。 错误示例： PROGRAM PLC_PRG VAR END_VAR i := 1; 信息： C0018: 'i' 不是有效的分配目标 C0046: 标识符“i”未定义 错误修正： VAR i : INT; END_VAR...", 
"body" : "C0046 信息 : 标识符“<标识符名称>”未定义 可能的错误原因 : 使用了未声明的标识符。 错误修正 ：声明要使用的变量。 错误示例： PROGRAM PLC_PRG\nVAR\n\nEND_VAR\n\ni := 1;\n 信息： C0018: 'i' 不是有效的分配目标 C0046: 标识符“i”未定义 错误修正： VAR\n i : INT;\nEND_VAR " }, 
{ "title" : "编译器错误 C0047 ", 
"url" : "_cds_error_c0047.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0047 ", 
"snippet" : "C0047 信息 : 无法将带有“[]”的索引应用于“<数据类型>”类型的表达式 可能的错误原因 : 不是数组的数据类型用 '[]' 索引。 错误修正 : 仅当声明为数组时才使用 '[]' 索引数据类型。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR i[1]; 信息： C0047: 无法将带有“[]”的索引应用于“INT”类型的表达式...", 
"body" : "C0047 信息 : 无法将带有“[]”的索引应用于“<数据类型>”类型的表达式 可能的错误原因 : 不是数组的数据类型用 '[]' 索引。 错误修正 : 仅当声明为数组时才使用 '[]' 索引数据类型。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni[1];\n 信息： C0047: 无法将带有“[]”的索引应用于“INT”类型的表达式 " }, 
{ "title" : "编译器错误 C0048 ", 
"url" : "_cds_error_c0048.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0048 ", 
"snippet" : "C0048 信息 : 数组正好需要 '<number>' 索引 可能的错误原因 : 使用数组时指定的索引过多或过少。 错误修正 ：指定与分配给数组的维度一样多的索引。 错误示例： PROGRAM PLC_PRG VAR arr1 : ARRAY[1..2,1..3] OF INT; END_VAR arr1[1] := 5; 信息： C0048: 数组正好需要 2 个索引 错误修正： arr1[1,2] := 5;...", 
"body" : "C0048 信息 : 数组正好需要 '<number>' 索引 可能的错误原因 : 使用数组时指定的索引过多或过少。 错误修正 ：指定与分配给数组的维度一样多的索引。 错误示例： PROGRAM PLC_PRG\nVAR\n arr1 : ARRAY[1..2,1..3] OF INT;\nEND_VAR\narr1[1] := 5;\n 信息： C0048: 数组正好需要 2 个索引 错误修正： arr1[1,2] := 5; " }, 
{ "title" : "编译器错误 C0049 ", 
"url" : "_cds_error_c0049.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0049 ", 
"snippet" : "C0049 信息 : 常量索引 '<index value>' 不在从 '<start index>' 到 '<end index>' 的范围内 可能的错误原因 : 指定了一个超出数组大小的索引。 错误修正 ：仅使用数组大小内的索引。 错误示例： PROGRAM PLC_PRG VAR arr1 : ARRAY[1..2] OF INT; END_VAR arr1[3] := 1; 信息： C0049: 常数索引“3”不在“1”到“2”的范围内 错误修正： arr1[2] := 1;...", 
"body" : "C0049 信息 : 常量索引 '<index value>' 不在从 '<start index>' 到 '<end index>' 的范围内 可能的错误原因 : 指定了一个超出数组大小的索引。 错误修正 ：仅使用数组大小内的索引。 错误示例： PROGRAM PLC_PRG\nVAR\n arr1 : ARRAY[1..2] OF INT;\nEND_VAR\narr1[3] := 1;\n 信息： C0049: 常数索引“3”不在“1”到“2”的范围内 错误修正： arr1[2] := 1; " }, 
{ "title" : "编译器错误 C0050 ", 
"url" : "_cds_error_c0050.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0050 ", 
"snippet" : "C0050 信息 : Bitaccess 需要文字或符号整数常量 可能的错误原因 : 在位访问中没有指定文字或整数常量。 错误修正 ：使用文字或整数常量。 错误示例： PROGRAM PLC_PRG VAR i : INT; x : INT; END_VAR i.x := FALSE; 信息： C0018: 'ix' 不是有效的分配目标 C0050：Bitaccess 需要文字或符号整数常量 错误修正： i := Test(x);...", 
"body" : "C0050 信息 : Bitaccess 需要文字或符号整数常量 可能的错误原因 : 在位访问中没有指定文字或整数常量。 错误修正 ：使用文字或整数常量。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n x : INT;\nEND_VAR\n\ni.x := FALSE;\n 信息： C0018: 'ix' 不是有效的分配目标 C0050：Bitaccess 需要文字或符号整数常量 错误修正： i := Test(x); " }, 
{ "title" : "编译器错误 C0051 ", 
"url" : "_cds_error_c0051.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0051 ", 
"snippet" : "C0051 信息 ：属性值而不是“<值>”应为单字节字符串。 可能的错误原因 ：字符串未按预期出现在显示的位置。 错误修正 ：用字符串替换当前值。 错误示例： PROGRAM PLC_PRG {IF hasattribute(pou: MyPOU, MyAttribute)} {END_IF} 信息： C0051：属性值而不是 MyAttribute 需要单字节字符串。 错误修正： PROGRAM PLC_PRG {IF hasattribute(pou: MyPOU, 'MyAttribute')} {END_IF}...", 
"body" : "C0051 信息 ：属性值而不是“<值>”应为单字节字符串。 可能的错误原因 ：字符串未按预期出现在显示的位置。 错误修正 ：用字符串替换当前值。 错误示例： PROGRAM PLC_PRG\n{IF hasattribute(pou: MyPOU, MyAttribute)}\n{END_IF}\n 信息： C0051：属性值而不是 MyAttribute 需要单字节字符串。 错误修正： PROGRAM PLC_PRG\n{IF hasattribute(pou: MyPOU, 'MyAttribute')}\n{END_IF} " }, 
{ "title" : "编译器错误 C0053 ", 
"url" : "_cds_error_c0053.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0053 ", 
"snippet" : "C0053 信息 : 编译器版本 <version> 已被撤回。请改用更高的编译器版本。 可能的错误原因 : 当前编译器版本不能使用。 错误修正 ：在项目中适配当前编译器版本（项目环境，项目设置）。...", 
"body" : "C0053 信息 : 编译器版本 <version> 已被撤回。请改用更高的编译器版本。 可能的错误原因 : 当前编译器版本不能使用。 错误修正 ：在项目中适配当前编译器版本（项目环境，项目设置）。 " }, 
{ "title" : "编译器错误 C0061 ", 
"url" : "_cds_error_c0061.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0061 ", 
"snippet" : "C0061 信息 ：不允许对函数调用进行 Bitaccess 可能的错误原因 : 对函数执行位访问。 错误修正 ：仅对支持的数据类型使用位访问。 错误示例： PROGRAM PLC_PRG VAR END_VAR Test().2; FUNCTION Test : INT VAR_INPUT END_VAR 信息： C0061：不允许对函数调用进行位访问...", 
"body" : "C0061 信息 ：不允许对函数调用进行 Bitaccess 可能的错误原因 : 对函数执行位访问。 错误修正 ：仅对支持的数据类型使用位访问。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nTest().2;\n\nFUNCTION Test : INT\nVAR_INPUT\n\nEND_VAR\n 信息： C0061：不允许对函数调用进行位访问 " }, 
{ "title" : "编译器错误 C0062 ", 
"url" : "_cds_error_c0062.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0062 ", 
"snippet" : "C0062 信息 : '<variable name>' 不是结构化变量 可能的错误原因 ：不是结构变量的变量被视为结构变量。 错误修正 : 确保变量是结构变量。 错误示例： PROGRAM PLC_PRG VAR pt : PUNKT; i : INT; END_VAR i.x := 1024; TYPE Punkt : STRUCT x : REAL; y : REAL; END_STRUCT END_TYPE 信息： C0018: 'ix' 不是有效的分配目标 C0062：“变量”不是结构变量 错误修正： Beispiel: pt.x := 1024;...", 
"body" : "C0062 信息 : '<variable name>' 不是结构化变量 可能的错误原因 ：不是结构变量的变量被视为结构变量。 错误修正 : 确保变量是结构变量。 错误示例： PROGRAM PLC_PRG\nVAR\n pt : PUNKT;\n i : INT;\nEND_VAR\n\ni.x := 1024;\n\n\nTYPE Punkt :\nSTRUCT\n x : REAL;\n y : REAL;\nEND_STRUCT\nEND_TYPE\n 信息： C0018: 'ix' 不是有效的分配目标 C0062：“变量”不是结构变量 错误修正： Beispiel:\npt.x := 1024; " }, 
{ "title" : "编译器错误 C0064 ", 
"url" : "_cds_error_c0064.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0064 ", 
"snippet" : "C0064 信息 : 取消引用需要一个指针 可能的错误原因 ：不是指针变量的变量被“取消引用”。 错误修正 ：“取消引用”仅作为指针变量的变量。 错误示例： PROGRAM PLC_PRG VAR i : INT; pi : POINTER TO INT; END_VAR i^:=1; 信息： C0018: 'i^' 不是有效的分配目标 C0064：取消引用需要一个指针 错误修正： pi := ADR(i); pi^ := 1;...", 
"body" : "C0064 信息 : 取消引用需要一个指针 可能的错误原因 ：不是指针变量的变量被“取消引用”。 错误修正 ：“取消引用”仅作为指针变量的变量。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n pi : POINTER TO INT;\nEND_VAR\ni^:=1;\n 信息： C0018: 'i^' 不是有效的分配目标 C0064：取消引用需要一个指针 错误修正： pi := ADR(i);\npi^ := 1; " }, 
{ "title" : "编译器错误 C0065 ", 
"url" : "_cds_error_c0065.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0065 ", 
"snippet" : "C0065 信息 : '<name>' 没有全局定义。 可能的错误原因 : 搜索的值不是全局变量、全局 POU 或其他可以全局访问的值。 错误修正 : 将 '<name>' 声明为全局变量。 错误示例： PROGRAM PLC_PRG .someValue := 5; 信息： C0065: 'someValue' 没有全局定义。 错误修正： VAR_GLOBAL someValue : INT; END_VAR...", 
"body" : "C0065 信息 : '<name>' 没有全局定义。 可能的错误原因 : 搜索的值不是全局变量、全局 POU 或其他可以全局访问的值。 错误修正 : 将 '<name>' 声明为全局变量。 错误示例： PROGRAM PLC_PRG\n.someValue := 5;\n 信息： C0065: 'someValue' 没有全局定义。 错误修正： VAR_GLOBAL\n someValue : INT;\nEND_VAR " }, 
{ "title" : "编译器错误 C0066 ", 
"url" : "_cds_error_c0066.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0066 ", 
"snippet" : "C0066 信息 : 无法将类型“<数据类型>”与类型“<数据类型>”进行比较 可能的错误原因 : 比较两种无法相互比较的数据类型。 错误修正 ：仅比较可以相互比较的数据类型。 错误示例： PROGRAM PLC_PRG VAR i : INT; re : REAL; str: STRING; b : BOOL; END_VAR b := i > str; 信息： C0066: 无法将“INT”类型与“STRING”类型进行比较 错误修正： b := i > re;...", 
"body" : "C0066 信息 : 无法将类型“<数据类型>”与类型“<数据类型>”进行比较 可能的错误原因 : 比较两种无法相互比较的数据类型。 错误修正 ：仅比较可以相互比较的数据类型。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n re : REAL;\n str: STRING;\n b : BOOL;\nEND_VAR\n\nb := i > str;\n 信息： C0066: 无法将“INT”类型与“STRING”类型进行比较 错误修正： b := i > re; " }, 
{ "title" : "编译器错误 C0068 ", 
"url" : "_cds_error_c0068.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0068 ", 
"snippet" : "C0068 信息 : 无法对“<数据类型>”类型的对象进行比较 可能的错误原因 : 正在比较无法进行比较的对象。 错误修正 ：仅比较可以比较的数据类型（INT、REAL 等）。 错误示例： PROGRAM PLC_PRG VAR b : BOOL; arr1 : ARRAY [1..2] OF INT; arr2 : ARRAY [1..2] OF INT; END_VAR b := arr1 > arr2; 信息： C0068：无法对“数组 [1..2]”类型的对象进行比较...", 
"body" : "C0068 信息 : 无法对“<数据类型>”类型的对象进行比较 可能的错误原因 : 正在比较无法进行比较的对象。 错误修正 ：仅比较可以比较的数据类型（INT、REAL 等）。 错误示例： PROGRAM PLC_PRG\nVAR\n b : BOOL;\n arr1 : ARRAY [1..2] OF INT;\n arr2 : ARRAY [1..2] OF INT;\nEND_VAR\n\nb := arr1 > arr2;\n 信息： C0068：无法对“数组 [1..2]”类型的对象进行比较 " }, 
{ "title" : "编译器错误 C0069 ", 
"url" : "_cds_error_c0069.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0069 ", 
"snippet" : "C0069 信息 : 无法对“<数据类型>”或“<数据类型>”类型的对象进行比较 可能的错误原因 : 正在比较两个不同的对象，其中无法进行比较。 错误修正 ：仅比较可以比较的数据类型（INT、REAL 等）。 错误示例： PROGRAM PLC_PRG VAR b : BOOL; arr1 : ARRAY [1..2] OF INT; arr2 : ARRAY [1..3] OF INT; END_VAR b := arr1 > arr2; 信息： C0069：无法对“ARRAY [1..2]”或“ARRAY [1..3]”类型的对象进行比较...", 
"body" : "C0069 信息 : 无法对“<数据类型>”或“<数据类型>”类型的对象进行比较 可能的错误原因 : 正在比较两个不同的对象，其中无法进行比较。 错误修正 ：仅比较可以比较的数据类型（INT、REAL 等）。 错误示例： PROGRAM PLC_PRG\nVAR\n b : BOOL;\n arr1 : ARRAY [1..2] OF INT;\n arr2 : ARRAY [1..3] OF INT;\nEND_VAR\n\nb := arr1 > arr2;\n 信息： C0069：无法对“ARRAY [1..2]”或“ARRAY [1..3]”类型的对象进行比较 " }, 
{ "title" : "编译器错误 C0070 ", 
"url" : "_cds_error_c0070.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0070 ", 
"snippet" : "C0070 信息 : 'INI' 操作符需要功能块实例或数据单元类型实例 可能的错误原因 : 功能块实例和 DUT 实例均不适用于 INI 运算符。 错误修正 ：仅将功能块实例或 DUT 实例传递给 INI 操作员。 错误示例： PROGRAM PLC_PRG VAR b : BOOL; inst : FB; END_VAR b := INI(b, TRUE); FUNCTION_BLOCK FB VAR END_VAR 信息： C0070：“INI”操作员需要功能块实例或数据单元类型实例 错误修正： b := INI(inst, TRUE);...", 
"body" : "C0070 信息 : 'INI' 操作符需要功能块实例或数据单元类型实例 可能的错误原因 : 功能块实例和 DUT 实例均不适用于 INI 运算符。 错误修正 ：仅将功能块实例或 DUT 实例传递给 INI 操作员。 错误示例： PROGRAM PLC_PRG\nVAR\n b : BOOL;\n inst : FB;\nEND_VAR\n\nb := INI(b, TRUE);\n\nFUNCTION_BLOCK FB\nVAR\nEND_VAR\n 信息： C0070：“INI”操作员需要功能块实例或数据单元类型实例 错误修正： b := INI(inst, TRUE); " }, 
{ "title" : "编译器错误 C0072 ", 
"url" : "_cds_error_c0072.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0072 ", 
"snippet" : "C0072 信息 : 运算符 '<operator name>' 在类型 '<data type>' 上是不可能的 可能的错误原因 ：运算符应用于不兼容的类型。 错误修正 ：仅在兼容类型上应用运算符。 错误示例： PROGRAM PLC_PRG VAR i : INT; str : STRING; END_VAR str := ABS(str); 信息： C0072: 运算符 'Abs' 不能用于类型 'STRING' 错误修正： i := ABS(i);...", 
"body" : "C0072 信息 : 运算符 '<operator name>' 在类型 '<data type>' 上是不可能的 可能的错误原因 ：运算符应用于不兼容的类型。 错误修正 ：仅在兼容类型上应用运算符。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n str : STRING;\nEND_VAR\n\nstr := ABS(str);\n 信息： C0072: 运算符 'Abs' 不能用于类型 'STRING' 错误修正： i := ABS(i); " }, 
{ "title" : "编译器错误 C0074 ", 
"url" : "_cds_error_c0074.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0074 ", 
"snippet" : "C0074 信息 : 意外的数组初始化 可能的错误原因 : 数组初始化中的语法错误 错误修正 : 更正语法 错误示例： PROGRAM PLC_PRG VAR arr1 : INT := [1,2,3,4,5,6]; END_VAR 信息： C0074：意外的数组初始化 C0032：类型'未知类型：'[1,2,3,4,5,6]' 无法转换为类型'INT' 错误修正： arr1 : ARRAY [1..6] OF INT := [1,2,3,4,5,6];...", 
"body" : "C0074 信息 : 意外的数组初始化 可能的错误原因 : 数组初始化中的语法错误 错误修正 : 更正语法 错误示例： PROGRAM PLC_PRG\nVAR\n arr1 : INT := [1,2,3,4,5,6];\nEND_VAR\n 信息： C0074：意外的数组初始化 C0032：类型'未知类型：'[1,2,3,4,5,6]' 无法转换为类型'INT' 错误修正： arr1 : ARRAY [1..6] OF INT := [1,2,3,4,5,6]; " }, 
{ "title" : "编译器错误 C0075 ", 
"url" : "_cds_error_c0075.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0075 ", 
"snippet" : "C0075 信息 : 数组的初始化器太多 可能的错误原因 : 为数组的大小指定了太多值。 错误修正 ：分配值的数量必须与数组的大小相对应。 错误示例： PROGRAM PLC_PRG VAR arr1 : ARRAY [1..5] OF INT := [1,2,3,4,5,6]; END_VAR 信息： C0075：意外的数组初始化 错误修正： arr1 : ARRAY [1..6] OF INT := [1,2,3,4,5,6];...", 
"body" : "C0075 信息 : 数组的初始化器太多 可能的错误原因 : 为数组的大小指定了太多值。 错误修正 ：分配值的数量必须与数组的大小相对应。 错误示例： PROGRAM PLC_PRG\nVAR\n arr1 : ARRAY [1..5] OF INT := [1,2,3,4,5,6];\nEND_VAR\n 信息： C0075：意外的数组初始化 错误修正： arr1 : ARRAY [1..6] OF INT := [1,2,3,4,5,6]; " }, 
{ "title" : "编译器错误 C0076 ", 
"url" : "_cds_error_c0076.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0076 ", 
"snippet" : "C0076 信息 :意外的结构初始化 可能的错误原因 : 结构初始化中的语法错误 错误修正 : 确保语法正确。 错误示例： PROGRAM PLC_PRG VAR st1 : INT := (p1 := 1); END_VAR 信息： C0076：意外的结构初始化 C0032：类型“STRUCT(p1:=1)”无法转换为类型“INT” C0046：未定义标识符“p1” C0018: 'p1' 不是有效的分配目标 错误修正： st1 : STRUCT1 := (p1:=1,p2:=10);...", 
"body" : "C0076 信息 :意外的结构初始化 可能的错误原因 : 结构初始化中的语法错误 错误修正 : 确保语法正确。 错误示例： PROGRAM PLC_PRG\nVAR\n st1 : INT := (p1 := 1);\nEND_VAR\n 信息： C0076：意外的结构初始化 C0032：类型“STRUCT(p1:=1)”无法转换为类型“INT” C0046：未定义标识符“p1” C0018: 'p1' 不是有效的分配目标 错误修正： st1 : STRUCT1 := (p1:=1,p2:=10); " }, 
{ "title" : "编译器错误 C0077 ", 
"url" : "_cds_error_c0077.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0077 ", 
"snippet" : "C0077 信息 ：未知类型：'<数据类型>' 可能的错误原因 : 声明中的数据类型无效（可能是语法错误） 错误修正 ：仅指定有效的数据类型。 错误示例： PROGRAM PLC_PRG VAR i : INTEGER; END_VAR 信息： C0077：未知类型：“整数” 错误修正： arr1 : ARRAY[1..2] OF STRUCT1 := (p1:=1,p2:=10);...", 
"body" : "C0077 信息 ：未知类型：'<数据类型>' 可能的错误原因 : 声明中的数据类型无效（可能是语法错误） 错误修正 ：仅指定有效的数据类型。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INTEGER;\nEND_VAR\n 信息： C0077：未知类型：“整数” 错误修正： arr1 : ARRAY[1..2] OF STRUCT1 := (p1:=1,p2:=10); " }, 
{ "title" : "编译器错误 C0078 ", 
"url" : "_cds_error_c0078.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0078 ", 
"snippet" : "C0078 信息 ：不支持的类型：'<数据类型>' 可能的错误原因 ：当前设备不支持使用的类型，因此无法使用。 错误修正 : 如果可能，请使用其他类型。例如， REAL 代替 LREAL . 错误示例： PROGRAM PLC_PRG VAR value : LREAL; END_VAR 信息： C0078：不支持的类型：'LREAL' 错误修正： PROGRAM PLC_PRG VAR value : REAL; END_VAR...", 
"body" : "C0078 信息 ：不支持的类型：'<数据类型>' 可能的错误原因 ：当前设备不支持使用的类型，因此无法使用。 错误修正 : 如果可能，请使用其他类型。例如， REAL 代替 LREAL . 错误示例： PROGRAM PLC_PRG\nVAR\n value : LREAL;\nEND_VAR\n 信息： C0078：不支持的类型：'LREAL' 错误修正： PROGRAM PLC_PRG\nVAR\n value : REAL;\nEND_VAR " }, 
{ "title" : "编译器错误 C0080 ", 
"url" : "_cds_error_c0080.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0080 ", 
"snippet" : "C0080 信息 : 功能块“<功能块名称>”必须被实例化才能被访问 可能的错误原因 : 缺少功能块实例化 错误修正 ：实例化功能块。 错误示例： PROGRAM PLC_PRG VAR END_VAR FB(); FUNCTION_BLOCK FB VAR END_VAR 信息： C0080：必须实例化功能块“FB”才能访问 错误修正： VAR inst : FB; END_VAR inst();...", 
"body" : "C0080 信息 : 功能块“<功能块名称>”必须被实例化才能被访问 可能的错误原因 : 缺少功能块实例化 错误修正 ：实例化功能块。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nFB();\n\n\nFUNCTION_BLOCK FB\nVAR\nEND_VAR\n 信息： C0080：必须实例化功能块“FB”才能访问 错误修正： VAR\n inst : FB;\nEND_VAR\ninst(); " }, 
{ "title" : "编译器错误 C0081 ", 
"url" : "_cds_error_c0081.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0081 ", 
"snippet" : "C0081 信息 : Unexpected Pragma: '<pragma name>' 没有匹配 'if' 可能的错误原因 : 使用 pragma 时缺少 IF 条件。 错误修正 : 完成编译指示的 IF 条件。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := 5; {END_IF} 信息： C0081: 意外的 Pragma: 发现 'END_IF' 没有匹配 'if' 错误修正： {IF <expression>} i := 5; {END_IF}...", 
"body" : "C0081 信息 : Unexpected Pragma: '<pragma name>' 没有匹配 'if' 可能的错误原因 : 使用 pragma 时缺少 IF 条件。 错误修正 : 完成编译指示的 IF 条件。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\ni := 5;\n{END_IF}\n 信息： C0081: 意外的 Pragma: 发现 'END_IF' 没有匹配 'if' 错误修正： {IF <expression>}\ni := 5;\n{END_IF} " }, 
{ "title" : "编译器错误 C0082 ", 
"url" : "_cds_error_c0082.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0082 ", 
"snippet" : "C0082 信息 : '<invalid pragma>' 不是 pragma 的有效条件 可能的错误原因 : 使用 pragma 时，在 IF 条件中使用了无效表达式。 错误修正 ：使用有效的编译指示条件。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR {IF abc} i := 5; {END_IF} 信息： C0082: '!!!错误!!!'不是 pragma 的有效条件 错误修正： {IF defined (abc)}...", 
"body" : "C0082 信息 : '<invalid pragma>' 不是 pragma 的有效条件 可能的错误原因 : 使用 pragma 时，在 IF 条件中使用了无效表达式。 错误修正 ：使用有效的编译指示条件。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\n{IF abc}\ni := 5;\n{END_IF}\n 信息： C0082: '!!!错误!!!'不是 pragma 的有效条件 错误修正： {IF defined (abc)} " }, 
{ "title" : "编译器错误 C0084 ", 
"url" : "_cds_error_c0084.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0084 ", 
"snippet" : "C0084 信息 : '<pragma operand>' 不是 pragma 的有效操作数 可能的错误原因 : 语法错误 错误修正 : 使用有效的编译指示操作数。 错误示例： PROGRAM PLC_PRG VAR END_VAR {IF defined(0)} {END_IF} 信息： C0084: 'defined(null)' 不是 pragma 的有效操作数 错误修正： {IF defined (abc)}...", 
"body" : "C0084 信息 : '<pragma operand>' 不是 pragma 的有效操作数 可能的错误原因 : 语法错误 错误修正 : 使用有效的编译指示操作数。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\n{IF defined(0)}\n{END_IF}\n 信息： C0084: 'defined(null)' 不是 pragma 的有效操作数 错误修正： {IF defined (abc)} " }, 
{ "title" : "编译器错误 C0085 ", 
"url" : "_cds_error_c0085.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0085 ", 
"snippet" : "C0085 信息 ：定义预期值而不是“<值>”。 可能的错误原因 : 需要一个字符串，而不是杂注显示位置的当前值。 错误修正 ：用字符串替换当前值。 错误示例： PROGRAM PLC_PRG {IF hasvalue(define, defineValue)} {END_IF} 信息： C0085：定义预期值而不是“defineValue”。 错误修正： PROGRAM PLC_PRG {IF hasvalue(define, '120')} {END_IF}...", 
"body" : "C0085 信息 ：定义预期值而不是“<值>”。 可能的错误原因 : 需要一个字符串，而不是杂注显示位置的当前值。 错误修正 ：用字符串替换当前值。 错误示例： PROGRAM PLC_PRG\n\n{IF hasvalue(define, defineValue)}\n{END_IF}\n 信息： C0085：定义预期值而不是“defineValue”。 错误修正： PROGRAM PLC_PRG\n\n{IF hasvalue(define, '120')}\n{END_IF} " }, 
{ "title" : "编译器错误 C0086 ", 
"url" : "_cds_error_c0086.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0086 ", 
"snippet" : "C0086 信息 : 找不到接口“<接口名称>”的定义 可能的错误原因 : 使用了未定义的接口。 错误修正 : 定义接口。 错误示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB IMPLEMENTS XY VAR END_VAR 信息： C0086: 未找到接口“XY”的定义 错误修正： INTERFACE XY...", 
"body" : "C0086 信息 : 找不到接口“<接口名称>”的定义 可能的错误原因 : 使用了未定义的接口。 错误修正 : 定义接口。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB IMPLEMENTS XY\nVAR\nEND_VAR\n 信息： C0086: 未找到接口“XY”的定义 错误修正： INTERFACE XY " }, 
{ "title" : "编译器错误 C0087 ", 
"url" : "_cds_error_c0087.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0087 ", 
"snippet" : "C0087 信息 : 在接口“<接口名称>”中定义的方法“<方法名称>”没有实现。 可能的错误原因 : 接口指定的方法之一尚未由实现的功能块提供。 错误修正 ：实现接口指定的所有方法。 错误示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR INTERFACE XY METHOD METH1 VAR_INPUT END_VAR FUNCTION_BLOCK FB IMPLEMENTS XY VAR END_VAR METHOD METH2 VAR_INPUT END_VAR 信息： C0087：接口“XY”中定义的方法“METH1”没有实现...", 
"body" : "C0087 信息 : 在接口“<接口名称>”中定义的方法“<方法名称>”没有实现。 可能的错误原因 : 接口指定的方法之一尚未由实现的功能块提供。 错误修正 ：实现接口指定的所有方法。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\nINTERFACE XY\nMETHOD METH1\nVAR_INPUT\nEND_VAR\n\nFUNCTION_BLOCK FB IMPLEMENTS XY\nVAR\nEND_VAR\nMETHOD METH2\nVAR_INPUT\nEND_VAR\n 信息： C0087：接口“XY”中定义的方法“METH1”没有实现 " }, 
{ "title" : "编译器错误 C0089 ", 
"url" : "_cds_error_c0089.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0089 ", 
"snippet" : "C0089 信息 : 接口“{1}”的重写方法“{0}”的接口与声明不匹配 可能的错误原因 : 实现方法的签名与接口中方法的签名不匹配。 错误修正 : 确保声明了相同的返回类型和参数。 错误示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR INTERFACE XY METHOD METH1 VAR_INPUT iPar : INT; END_VAR FUNCTION_BLOCK FB IMPLEMENTS XY VAR END_VAR METHOD METH1 VAR_INPUT END_VAR 信息： C0089：接口“XY”的覆盖方法“METH1”的接口...", 
"body" : "C0089 信息 : 接口“{1}”的重写方法“{0}”的接口与声明不匹配 可能的错误原因 : 实现方法的签名与接口中方法的签名不匹配。 错误修正 : 确保声明了相同的返回类型和参数。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\nINTERFACE XY\nMETHOD METH1\nVAR_INPUT\n iPar : INT;\nEND_VAR\n\nFUNCTION_BLOCK FB IMPLEMENTS XY\nVAR\nEND_VAR\nMETHOD METH1\nVAR_INPUT\nEND_VAR\n 信息： C0089：接口“XY”的覆盖方法“METH1”的接口与声明不匹配 " }, 
{ "title" : "编译器错误 C0090 ", 
"url" : "_cds_error_c0090.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0090 ", 
"snippet" : "C0090 信息 : 找不到基类“<函数名称>”的定义 可能的错误原因 : 指定为基础的功能块不存在或不是功能块。 错误修正 ：使用功能块作为基础。 错误示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB EXTENDS POU VAR END_VAR FUNCTION POU VAR END_VAR 信息： C0090：找不到基类“POU”的定义...", 
"body" : "C0090 信息 : 找不到基类“<函数名称>”的定义 可能的错误原因 : 指定为基础的功能块不存在或不是功能块。 错误修正 ：使用功能块作为基础。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\nFUNCTION_BLOCK FB EXTENDS POU\nVAR\nEND_VAR\n\nFUNCTION POU\nVAR\nEND_VAR\n 信息： C0090：找不到基类“POU”的定义 " }, 
{ "title" : "编译器错误 C0091 ", 
"url" : "_cds_error_c0091.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0091 ", 
"snippet" : "C0091 信息 : 基本功能块列表中的递归：<功能名称> 可能的错误原因 ：基本功能块自行扩展。 错误修正 : 基本功能块列表中的递归是不可能的。 错误示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB EXTENDS FB VAR END_VAR 信息： C0091：基本功能块列表中的递归：FB -> FB...", 
"body" : "C0091 信息 : 基本功能块列表中的递归：<功能名称> 可能的错误原因 ：基本功能块自行扩展。 错误修正 : 基本功能块列表中的递归是不可能的。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB EXTENDS FB\nVAR\nEND_VAR\n 信息： C0091：基本功能块列表中的递归：FB -> FB " }, 
{ "title" : "编译器错误 C0094 ", 
"url" : "_cds_error_c0094.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0094 ", 
"snippet" : "C0094 信息 : 接口“<功能块名称>”的覆盖方法“<方法名称>”的接口与声明不匹配 可能的错误原因 : 第一个接口的方法签名与第二个接口的方法签名不匹配，由第一个接口扩展。 错误修正 ：对齐签名。 错误示例： PROGRAM PLC_PRG VAR xyz : XY2; END_VAR FUNCTION_BLOCK XY METHOD METH1 VAR_INPUT END_VAR FUNCTION_BLOCK XY2 EXTENDS XY METHOD METH1 VAR_INPUT iPar : BOOL; END_VAR 信息： C0094：基 'XY' 的重写方法 'METH1'...", 
"body" : "C0094 信息 : 接口“<功能块名称>”的覆盖方法“<方法名称>”的接口与声明不匹配 可能的错误原因 : 第一个接口的方法签名与第二个接口的方法签名不匹配，由第一个接口扩展。 错误修正 ：对齐签名。 错误示例： PROGRAM PLC_PRG\nVAR\n xyz : XY2;\nEND_VAR\n\nFUNCTION_BLOCK XY\nMETHOD METH1\nVAR_INPUT\nEND_VAR\n\nFUNCTION_BLOCK XY2 EXTENDS XY\nMETHOD METH1\nVAR_INPUT\n iPar : BOOL;\nEND_VAR\n 信息： C0094：基 'XY' 的重写方法 'METH1' 的接口与声明不匹配 " }, 
{ "title" : "编译器错误 C0096 ", 
"url" : "_cds_error_c0096.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0096 ", 
"snippet" : "C0096 信息 : EXTENDS-list 中只能定义一个基本功能块。 可能的错误原因 : 在 EXTENDS 列表中定义了两个或多个基本功能块。 错误修正 : 在 EXTENDS 列表中只定义一个基本功能块。 错误示例： PROGRAM PLC_PRG VAR fb : FB; END_VAR FUNCTION_BLOCK FB EXTENDS FB2, FB3 VAR END_VAR FUNCTION_BLOCK FB2 VAR END_VAR FUNCTION_BLOCK FB3 VAR END_VAR 信息： C0096: EXTENDS 列表中只能定义一个基本功能块。...", 
"body" : "C0096 信息 : EXTENDS-list 中只能定义一个基本功能块。 可能的错误原因 : 在 EXTENDS 列表中定义了两个或多个基本功能块。 错误修正 : 在 EXTENDS 列表中只定义一个基本功能块。 错误示例： PROGRAM PLC_PRG\nVAR\n fb : FB;\nEND_VAR\n\nFUNCTION_BLOCK FB EXTENDS FB2, FB3\nVAR\nEND_VAR\n\nFUNCTION_BLOCK FB2\nVAR\nEND_VAR\n\nFUNCTION_BLOCK FB3\nVAR\nEND_VAR\n 信息： C0096: EXTENDS 列表中只能定义一个基本功能块。 " }, 
{ "title" : "编译器错误 C0097 ", 
"url" : "_cds_error_c0097.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0097 ", 
"snippet" : "C0097 信息 ：在功能块“<功能块名称>”和基础“<基础功能块名称>”中重复定义变量“<变量名称>” 可能的错误原因 : 变量在功能块及其基中以相同的名称声明。 错误修正 : 使用不同的变量名。 错误示例： PROGRAM PLC_PRG VAR fb : FB; END_VAR FUNCTION_BLOCK FB EXTENDS FB2 VAR i : INT; END_VAR FUNCTION_BLOCK FB2 VAR i : INT; END_VAR 信息： C0097：在功能块 'FB' 和基础 'FB2' 中重复定义变量 'i'...", 
"body" : "C0097 信息 ：在功能块“<功能块名称>”和基础“<基础功能块名称>”中重复定义变量“<变量名称>” 可能的错误原因 : 变量在功能块及其基中以相同的名称声明。 错误修正 : 使用不同的变量名。 错误示例： PROGRAM PLC_PRG\nVAR\n fb : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB EXTENDS FB2\nVAR\n i : INT;\nEND_VAR\n\n\nFUNCTION_BLOCK FB2\nVAR\n i : INT;\nEND_VAR\n 信息： C0097：在功能块 'FB' 和基础 'FB2' 中重复定义变量 'i' " }, 
{ "title" : "编译器错误 C0098 ", 
"url" : "_cds_error_c0098.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0098 ", 
"snippet" : "C0098 信息 ：不再支持关键字“FUNCTIONBLOCK”。请改用“FUNCTION_BLOCK”。 可能的错误原因 : 语法错误 错误修正 ：使用关键字“FUNCTION_BLOCK”。 错误示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTIONBLOCK FB VAR END_VAR 信息： C0098：不再支持关键字“FUNCTIONBLOCK”。请改用“FUNCTION_BLOCK”。...", 
"body" : "C0098 信息 ：不再支持关键字“FUNCTIONBLOCK”。请改用“FUNCTION_BLOCK”。 可能的错误原因 : 语法错误 错误修正 ：使用关键字“FUNCTION_BLOCK”。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\nFUNCTIONBLOCK FB\nVAR\nEND_VAR\n 信息： C0098：不再支持关键字“FUNCTIONBLOCK”。请改用“FUNCTION_BLOCK”。 " }, 
{ "title" : "编译器错误 C0099（编译器版本 < 3.5.7.0） ", 
"url" : "_cds_error_c0099.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0099（编译器版本 < 3.5.7.0） ", 
"snippet" : "C0099 信息 ：不再支持本地定义的枚举。请改用 DUT 定义。 可能的错误原因 : 本地枚举声明与不支持此功能的编译器版本一起使用。 错误修正 ：使用更高版本的编译器，或在 DUT 中定义枚举。 错误示例： 错误示例： PROGRAM PLC_PRG VAR localEnumVar : (RED, GREEN, BLUE) := RED; END_VAR 信息： C0099: 不再支持本地定义的枚举。请改用 DUT 定义。...", 
"body" : "C0099 信息 ：不再支持本地定义的枚举。请改用 DUT 定义。 可能的错误原因 : 本地枚举声明与不支持此功能的编译器版本一起使用。 错误修正 ：使用更高版本的编译器，或在 DUT 中定义枚举。 错误示例： 错误示例： PROGRAM PLC_PRG\nVAR\n localEnumVar : (RED, GREEN, BLUE) := RED;\nEND_VAR\n 信息： C0099: 不再支持本地定义的枚举。请改用 DUT 定义。 " }, 
{ "title" : "编译器错误 C0101 ", 
"url" : "_cds_error_c0101.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0101 ", 
"snippet" : "C0101 信息 ：数据递归：'<recursion>' 可能的错误原因 : 两个功能块上的递归数据初始化 错误修正 : 避免数据初始化的递归。 错误示例： PROGRAM PLC_PRG VAR inst0 : FB1; END_VAR FUNCTION_BLOCK FB1 VAR inst1 : FB2; END_VAR FUNCTION_BLOCK FB2 VAR inst2 : FB1; END_VAR 信息： C0101：数据递归：FB1->FB2->FB1...", 
"body" : "C0101 信息 ：数据递归：'<recursion>' 可能的错误原因 : 两个功能块上的递归数据初始化 错误修正 : 避免数据初始化的递归。 错误示例： PROGRAM PLC_PRG\nVAR\n inst0 : FB1;\nEND_VAR\n\nFUNCTION_BLOCK FB1\nVAR\n inst1 : FB2;\nEND_VAR\n\nFUNCTION_BLOCK FB2\nVAR\n inst2 : FB1;\nEND_VAR\n 信息： C0101：数据递归：FB1->FB2->FB1 " }, 
{ "title" : "编译器错误 C0102 ", 
"url" : "_cds_error_c0102.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0102 ", 
"snippet" : "C0102 信息 ：保留内存不足：变量“<变量名称>”，<字节大小>字节。 可能的错误原因 : 使用的保留内存比 PLC 上可用的多。由于增量构建，保留内存也可能过于碎片化。 错误修正 ： 使用 干净的 用于分割内存。这将强制在下一次构建时重新分配所有数据。...", 
"body" : "C0102 信息 ：保留内存不足：变量“<变量名称>”，<字节大小>字节。 可能的错误原因 : 使用的保留内存比 PLC 上可用的多。由于增量构建，保留内存也可能过于碎片化。 错误修正 ： 使用 干净的 用于分割内存。这将强制在下一次构建时重新分配所有数据。 " }, 
{ "title" : "编译器错误 C0103 ", 
"url" : "_cds_error_c0103.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0103 ", 
"snippet" : "C0103 信息 ：保留内存不足：变量“<变量名称>”，<字节大小>字节。 （最大连续内存间隙{2}） 可能的错误原因 : 使用的保留内存比 PLC 上可用的多。由于增量构建，保留内存也可能过于碎片化。 错误修正 ： 使用 干净的 用于分割内存。这将强制在下一次构建时重新分配所有数据。...", 
"body" : "C0103 信息 ：保留内存不足：变量“<变量名称>”，<字节大小>字节。 （最大连续内存间隙{2}） 可能的错误原因 : 使用的保留内存比 PLC 上可用的多。由于增量构建，保留内存也可能过于碎片化。 错误修正 ： 使用 干净的 用于分割内存。这将强制在下一次构建时重新分配所有数据。 " }, 
{ "title" : "编译器错误 C0104 ", 
"url" : "_cds_error_c0104.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0104 ", 
"snippet" : "C0104 信息 ：'全局数据内存不足：变量'<变量名称>'，<字节大小>字节。 可能的错误原因 : 使用的数据内存比 PLC 上的可用内存多。由于增量构建，内存也可能过于碎片化。 错误修正 ： 使用 干净的 用于分割内存。这将强制在下一次构建时重新分配所有数据。...", 
"body" : "C0104 信息 ：'全局数据内存不足：变量'<变量名称>'，<字节大小>字节。 可能的错误原因 : 使用的数据内存比 PLC 上的可用内存多。由于增量构建，内存也可能过于碎片化。 错误修正 ： 使用 干净的 用于分割内存。这将强制在下一次构建时重新分配所有数据。 " }, 
{ "title" : "编译器错误 C0106 ", 
"url" : "_cds_error_c0106.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0106 ", 
"snippet" : "C0106 信息 ：保留内存不足：变量“<变量名称>”，<字节大小>字节。 （最大连续内存间隙<字节大小>字节） 可能的错误原因 ：使用的保留内存多于 PLC 上的可用内存。也有可能是增量编译导致的retain memory过于碎片化。 纠错 ： 使用 干净的 用于对内存进行分段的命令。这将强制所有数据和代码在下一次编译时重新分配。...", 
"body" : "C0106 信息 ：保留内存不足：变量“<变量名称>”，<字节大小>字节。 （最大连续内存间隙<字节大小>字节） 可能的错误原因 ：使用的保留内存多于 PLC 上的可用内存。也有可能是增量编译导致的retain memory过于碎片化。 纠错 ： 使用 干净的 用于对内存进行分段的命令。这将强制所有数据和代码在下一次编译时重新分配。 " }, 
{ "title" : "编译器错误 C0114 ", 
"url" : "_cds_error_c0114.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0114 ", 
"snippet" : "C0114 信息 : 'JMP' 的目标 <跳转标签> 无效 可能的错误原因 : JMP 目标中的语法错误或印刷错误 错误修正 : 更正印刷或语法错误。 错误示例： PROGRAM PLC_PRG VAR END_VAR JMP 0; 信息： C0114：“JMP”的目标 0 无效...", 
"body" : "C0114 信息 : 'JMP' 的目标 <跳转标签> 无效 可能的错误原因 : JMP 目标中的语法错误或印刷错误 错误修正 : 更正印刷或语法错误。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\nJMP 0;\n 信息： C0114：“JMP”的目标 0 无效 " }, 
{ "title" : "编译器错误 C0115 ", 
"url" : "_cds_error_c0115.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0115 ", 
"snippet" : "C0115 信息 : 条件调用的第二个参数 (????ALWAYS CALC???? ) 必须是有效的调用语句。 错误修正 : 在条件????CALC???的第二个参数中指定函数、方法或功能块的调用称呼。 错误示例： PROGRAM PLC_PRG VAR condition : BOOL; END_VAR CALC(condition, 1+2); 信息： C0115：条件调用的第二个参数必须是有效的调用语句。 错误修正： CALC(condition, MyFunction(1,2))...", 
"body" : "C0115 信息 : 条件调用的第二个参数 (????ALWAYS CALC???? ) 必须是有效的调用语句。 错误修正 : 在条件????CALC???的第二个参数中指定函数、方法或功能块的调用称呼。 错误示例： PROGRAM PLC_PRG\nVAR\n condition : BOOL;\nEND_VAR\nCALC(condition, 1+2);\n 信息： C0115：条件调用的第二个参数必须是有效的调用语句。 错误修正： CALC(condition, MyFunction(1,2)) " }, 
{ "title" : "编译器错误 C0116 ", 
"url" : "_cds_error_c0116.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0116 ", 
"snippet" : "C0116 信息 : 标签 '<jump label>' 是重复的 可能的错误原因 : 一个标签被定义多次。 错误修正 ：每个标签只定义一次。 错误示例： PROGRAM PLC_PRG VAR END_VAR JMP label; label: label: 信息： C0116：标签“标签”是重复的...", 
"body" : "C0116 信息 : 标签 '<jump label>' 是重复的 可能的错误原因 : 一个标签被定义多次。 错误修正 ：每个标签只定义一次。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\nJMP label;\nlabel:\n\nlabel:\n 信息： C0116：标签“标签”是重复的 " }, 
{ "title" : "编译器错误 C0117 ", 
"url" : "_cds_error_c0117.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0117 ", 
"snippet" : "C0117 信息 ：在“JMP”语句的范围内没有这样的标签“<jump label>” 可能的错误原因 : 跳转到不存在的标签。 错误修正 ：定义您指定为目标的标签。 错误示例： PROGRAM PLC_PRG VAR END_VAR JMP A; 信息： C0117：在“JMP”声明的范围内没有这样的标签“A”。...", 
"body" : "C0117 信息 ：在“JMP”语句的范围内没有这样的标签“<jump label>” 可能的错误原因 : 跳转到不存在的标签。 错误修正 ：定义您指定为目标的标签。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\nJMP A;\n 信息： C0117：在“JMP”声明的范围内没有这样的标签“A”。 " }, 
{ "title" : "编译器错误 C0118 ", 
"url" : "_cds_error_c0118.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0118 ", 
"snippet" : "C0118 信息 : 标签 '<jump label>' 未被引用。 可能的错误原因 : 定义了一个未引用的跳转标签。 错误修正 ：删除未使用的跳转标签。 错误示例： PROGRAM PLC_PRG VAR END_VAR LABEL: 信息： C0118：尚未引用标签“LABEL”...", 
"body" : "C0118 信息 : 标签 '<jump label>' 未被引用。 可能的错误原因 : 定义了一个未引用的跳转标签。 错误修正 ：删除未使用的跳转标签。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\nLABEL:\n 信息： C0118：尚未引用标签“LABEL” " }, 
{ "title" : "编译器错误 C0119 ", 
"url" : "_cds_error_c0119.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0119 ", 
"snippet" : "C0119 信息 ：功能块或结构的“FB_init”方法需要两个输入 BOOL 类型的“bInitRetains”和“bInCopyCode” 可能的错误原因 ：缺少 BOOL 类型的输入“bInitRetains”和“bInCopyCode”之一或两者。 错误修正 ：定义缺失的输入。 错误示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB METHOD FB_init VAR_INPUT END_VAR 信息： C0119：功能块或结构的“FB_init”方法需要两个输入 BOOL 类型的“bInitRetains”和“b...", 
"body" : "C0119 信息 ：功能块或结构的“FB_init”方法需要两个输入 BOOL 类型的“bInitRetains”和“bInCopyCode” 可能的错误原因 ：缺少 BOOL 类型的输入“bInitRetains”和“bInCopyCode”之一或两者。 错误修正 ：定义缺失的输入。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB\nMETHOD FB_init\nVAR_INPUT\nEND_VAR\n 信息： C0119：功能块或结构的“FB_init”方法需要两个输入 BOOL 类型的“bInitRetains”和“bInCopyCode” 错误修正： METHOD FB_init\nVAR_INPUT\n bInitRetains : BOOL;\n bInCopyCode : BOOL;\nEND_VAR " }, 
{ "title" : "编译器错误 C0120 ", 
"url" : "_cds_error_c0120.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0120 ", 
"snippet" : "C0120 信息 ：功能块或结构的“FB_Exit”方法需要 BOOL 类型的输入“bInCopyCode”。 可能的原因 ：输入 bInCopyCode 类型的 BOOL 不见了。 错误修正 : 定义输入。 错误示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB METHOD FB_exit VAR_INPUT END_VAR 信息： C0120：功能块或结构的“FB_Exit”方法需要 BOOL 类型的输入“bInCopyCode”。 错误修正： METHOD FB_exit VAR_INPUT bInCopyCode ...", 
"body" : "C0120 信息 ：功能块或结构的“FB_Exit”方法需要 BOOL 类型的输入“bInCopyCode”。 可能的原因 ：输入 bInCopyCode 类型的 BOOL 不见了。 错误修正 : 定义输入。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB\nMETHOD FB_exit\nVAR_INPUT\nEND_VAR\n 信息： C0120：功能块或结构的“FB_Exit”方法需要 BOOL 类型的输入“bInCopyCode”。 错误修正： METHOD FB_exit\nVAR_INPUT\n bInCopyCode : BOOL;\nEND_VAR " }, 
{ "title" : "编译器错误 C0122 ", 
"url" : "_cds_error_c0122.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0122 ", 
"snippet" : "C0122 信息 ：在此上下文中不允许使用表达式“SUPER” 可能的错误原因 ：“SUPER^”在派生功能块之外使用。 错误修正 : 仅在功能块中使用“SUPER^”。 错误示例： PROGRAM PLC_PRG VAR END_VAR SUPER^.METH(TRUE, TRUE); 信息： C0122：在此上下文中不允许使用表达式“SUPER”...", 
"body" : "C0122 信息 ：在此上下文中不允许使用表达式“SUPER” 可能的错误原因 ：“SUPER^”在派生功能块之外使用。 错误修正 : 仅在功能块中使用“SUPER^”。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nSUPER^.METH(TRUE, TRUE);\n 信息： C0122：在此上下文中不允许使用表达式“SUPER” " }, 
{ "title" : "编译器错误 C0124 ", 
"url" : "_cds_error_c0124.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0124 ", 
"snippet" : "C0124 信息 ：“初始化”不是枚举的有效初始化 可能的错误原因 : 非 ANY_INT 的数据类型用于枚举初始化。 错误修正 : 仅使用 ANY_INT 进行枚举初始化。 错误示例： PROGRAM PLC_PRG VAR inst : DUT; END_VAR TYPE DUT : ( enum_member := 1.5 ) DWORD; END_TYPE 信息： C0032：“LREAL”类型无法转换为“DUT”类型 C0124：“初始化”不是枚举的有效初始化...", 
"body" : "C0124 信息 ：“初始化”不是枚举的有效初始化 可能的错误原因 : 非 ANY_INT 的数据类型用于枚举初始化。 错误修正 : 仅使用 ANY_INT 进行枚举初始化。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : DUT;\nEND_VAR\n\nTYPE DUT :\n(\n enum_member := 1.5\n) DWORD;\nEND_TYPE\n 信息： C0032：“LREAL”类型无法转换为“DUT”类型 C0124：“初始化”不是枚举的有效初始化 " }, 
{ "title" : "编译器错误 C0125 ", 
"url" : "_cds_error_c0125.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0125 ", 
"snippet" : "C0125 信息 : 常量 <常量值> 被分配给多个枚举。 可能的错误原因 : 将相同的值分配给两个或多个枚举。 错误修正 : 为枚举分配不同的值。 错误示例： PROGRAM PLC_PRG VAR inst : DUT; END_VAR TYPE DUT : ( enum_member := 0, enum_member2 := 0 ); END_TYPE 信息： C0125: 常数 0 分配给多个枚举。...", 
"body" : "C0125 信息 : 常量 <常量值> 被分配给多个枚举。 可能的错误原因 : 将相同的值分配给两个或多个枚举。 错误修正 : 为枚举分配不同的值。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : DUT;\nEND_VAR\n\nTYPE DUT :\n(\n enum_member := 0,\n enum_member2 := 0\n);\nEND_TYPE\n 信息： C0125: 常数 0 分配给多个枚举。 " }, 
{ "title" : "编译器错误 C0126 ", 
"url" : "_cds_error_c0126.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0126 ", 
"snippet" : "C0126 信息 : '<data type>' 类型的变量恰好需要 1 个索引 可能的错误原因 : 多个索引分配给具有一个索引的变量。 错误修正 : 只分配一个索引。 错误示例： PROGRAM PLC_PRG VAR pi : POINTER TO INT; END_VAR pi[0,1] := 0; 信息： C0126：“POINTER TO INT”类型的变量恰好需要 1 个索引 错误修正： pi[0] := 0;...", 
"body" : "C0126 信息 : '<data type>' 类型的变量恰好需要 1 个索引 可能的错误原因 : 多个索引分配给具有一个索引的变量。 错误修正 : 只分配一个索引。 错误示例： PROGRAM PLC_PRG\nVAR\n pi : POINTER TO INT;\nEND_VAR\npi[0,1] := 0;\n 信息： C0126：“POINTER TO INT”类型的变量恰好需要 1 个索引 错误修正： pi[0] := 0; " }, 
{ "title" : "编译器错误 C0130 ", 
"url" : "_cds_error_c0130.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0130 ", 
"snippet" : "C0130 信息 : 对象 '<object name>' 引用时不带括号 '()' 可能的错误原因 : 引用方法时不带括号。 错误修正 : 始终通过括号引用方法。 错误示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR inst.METH1 信息： C0130: 方法 'METH1' 引用不带括号 '()' 错误修正： inst.METH1();...", 
"body" : "C0130 信息 : 对象 '<object name>' 引用时不带括号 '()' 可能的错误原因 : 引用方法时不带括号。 错误修正 : 始终通过括号引用方法。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\ninst.METH1\n 信息： C0130: 方法 'METH1' 引用不带括号 '()' 错误修正： inst.METH1(); " }, 
{ "title" : "编译器错误 C0131 ", 
"url" : "_cds_error_c0131.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0131 ", 
"snippet" : "C0131 信息 : '<value>' 不允许作为 'ADR' 的操作数 可能的错误原因 : 常量作为操作数传递给运算符 ADR。 错误修正 ：仅对 ADR 使用有效的操作数。 错误示例： PROGRAM PLC_PRG VAR i : INT; pt : POINTER TO INT; END_VAR pt := ADR(1); 信息： C0131: '1' 不允许作为 'ADR' 的操作数 错误修正： pt := ADR(i);...", 
"body" : "C0131 信息 : '<value>' 不允许作为 'ADR' 的操作数 可能的错误原因 : 常量作为操作数传递给运算符 ADR。 错误修正 ：仅对 ADR 使用有效的操作数。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n pt : POINTER TO INT;\nEND_VAR\n\npt := ADR(1);\n 信息： C0131: '1' 不允许作为 'ADR' 的操作数 错误修正： pt := ADR(i); " }, 
{ "title" : "编译器错误 C0132 ", 
"url" : "_cds_error_c0132.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0132 ", 
"snippet" : "C0132 信息 : 没有要退出的封闭循环 可能的错误原因 : EXIT 在循环外使用。 错误修正 ：仅在循环内使用 EXIT。 错误示例： PROGRAM PLC_PRG VAR END_VAR EXIT ; 信息： C0132：没有要退出的封闭循环...", 
"body" : "C0132 信息 : 没有要退出的封闭循环 可能的错误原因 : EXIT 在循环外使用。 错误修正 ：仅在循环内使用 EXIT。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nEXIT\n;\n 信息： C0132：没有要退出的封闭循环 " }, 
{ "title" : "编译器错误 C0136 ", 
"url" : "_cds_error_c0136.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0136 ", 
"snippet" : "C0136 信息 : 名称“<变量名称>”的模糊使用 可能的错误原因 ：一个变量在多个 GVL 中声明。 错误修正 ：用所需的 GVL 限定变量。 错误示例： PROGRAM PLC_PRG VAR j : INT := g_i; END_VAR GVL1: VAR_GLOBAL g_i : INT; END_VAR GVL2: VAR_GLOBAL g_i : INT; END_VAR --> C0136: nicht eindeutige Verwendung des Namens 'g_i' 错误修正： Beispiel: j : INT := GVL1.g_i; 发生此错误时，在消息视...", 
"body" : "C0136 信息 : 名称“<变量名称>”的模糊使用 可能的错误原因 ：一个变量在多个 GVL 中声明。 错误修正 ：用所需的 GVL 限定变量。 错误示例： PROGRAM PLC_PRG\nVAR\n j : INT := g_i;\nEND_VAR\n\nGVL1:\nVAR_GLOBAL\n g_i : INT;\nEND_VAR\n\nGVL2:\nVAR_GLOBAL\n g_i : INT;\nEND_VAR\n\n--> C0136: nicht eindeutige Verwendung des Namens 'g_i' 错误修正： Beispiel:\nj : INT := GVL1.g_i; 发生此错误时，在消息视图（C0181）中输出所有多次使用的位置。 " }, 
{ "title" : "编译器错误 C0138 ", 
"url" : "_cds_error_c0138.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0138 ", 
"snippet" : "C0138 信息 : 找不到用于 POU 实例化的匹配 'FB_Init' 方法。 可能的错误原因 ： 不 FB_Init 方法存在接受传递的参数。 错误修正 : 检查哪些参数 FB_Init 必须接收并调整传递的参数。 错误示例： PROGRAM PLC_PRG VAR myPOU : POU(arg1 := 1, arg2 := 2); END_VAR 信息： C0138：没有找到用于 POU 实例化的匹配 'FB_Init' 方法。...", 
"body" : "C0138 信息 : 找不到用于 POU 实例化的匹配 'FB_Init' 方法。 可能的错误原因 ： 不 FB_Init 方法存在接受传递的参数。 错误修正 : 检查哪些参数 FB_Init 必须接收并调整传递的参数。 错误示例： PROGRAM PLC_PRG\nVAR\n myPOU : POU(arg1 := 1, arg2 := 2);\nEND_VAR\n 信息： C0138：没有找到用于 POU 实例化的匹配 'FB_Init' 方法。 " }, 
{ "title" : "编译器错误 C0139 ", 
"url" : "_cds_error_c0139.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0139 ", 
"snippet" : "C0139 信息 : 代码 <code> 无效。这是本意吗？ 可能的错误原因 ：编写的代码在语法上是正确的，但没有做任何事情。 错误修正 : 编写有目的的代码。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR i; 信息： C0139: 代码“i”无效。这是本意吗？...", 
"body" : "C0139 信息 : 代码 <code> 无效。这是本意吗？ 可能的错误原因 ：编写的代码在语法上是正确的，但没有做任何事情。 错误修正 : 编写有目的的代码。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\ni;\n 信息： C0139: 代码“i”无效。这是本意吗？ " }, 
{ "title" : "编译器错误 C0140 ", 
"url" : "_cds_error_c0140.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0140 ", 
"snippet" : "C0140 信息 : 引用赋值只允许给引用类型的变量 可能的错误原因 : 尝试将引用值分配给未定义为引用类型的变量。 错误修正 ：将变量定义为引用类型。 错误示例： PROGRAM PLC_PRG VAR i : INT; I_r : INT; END_VAR I_r REF= i; 信息： C0140：引用分配只允许引用类型的变量 错误修正： I_r : REFERENCE TO INT;...", 
"body" : "C0140 信息 : 引用赋值只允许给引用类型的变量 可能的错误原因 : 尝试将引用值分配给未定义为引用类型的变量。 错误修正 ：将变量定义为引用类型。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n I_r : INT;\nEND_VAR\n\nI_r REF= i;\n 信息： C0140：引用分配只允许引用类型的变量 错误修正： I_r : REFERENCE TO INT; " }, 
{ "title" : "编译器错误 C0141 ", 
"url" : "_cds_error_c0141.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0141 ", 
"snippet" : "C0141 信息 ：引用分配需要具有写访问权限的变量 可能的错误原因 : 一个常量被分配给引用赋值。 错误修正 : 分配一个可写变量。 错误示例： PROGRAM PLC_PRG VAR i : INT; I_r : REFERENCE TO INT; END_VAR I_r REF= 314; 信息： C0141：引用分配需要具有写访问权限的变量 错误修正： I_r REF= i;...", 
"body" : "C0141 信息 ：引用分配需要具有写访问权限的变量 可能的错误原因 : 一个常量被分配给引用赋值。 错误修正 : 分配一个可写变量。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n I_r : REFERENCE TO INT;\nEND_VAR\n\nI_r REF= 314;\n 信息： C0141：引用分配需要具有写访问权限的变量 错误修正： I_r REF= i; " }, 
{ "title" : "编译器错误 C0142 ", 
"url" : "_cds_error_c0142.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0142 ", 
"snippet" : "C0142 信息 : 一个名为 '<variable name>' 的局部变量已在 '<pou name>' 中定义 可能的错误原因 : 相同的变量名被使用了两次。 错误修正 : 使用不同的变量名。 错误示例： PROGRAM PLC_PRG VAR i : INT; i : INT; END_VAR 信息： C0142：名为“i”的局部变量已在“PLC_PRG”中定义...", 
"body" : "C0142 信息 : 一个名为 '<variable name>' 的局部变量已在 '<pou name>' 中定义 可能的错误原因 : 相同的变量名被使用了两次。 错误修正 : 使用不同的变量名。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n i : INT;\nEND_VAR\n 信息： C0142：名为“i”的局部变量已在“PLC_PRG”中定义 " }, 
{ "title" : "编译器错误 C0143 ", 
"url" : "_cds_error_c0143.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0143 ", 
"snippet" : "C0143 信息 : 属性 '<property name>' 不能在此上下文中使用，因为它缺少 get 访问器 可能的错误原因 ：该属性没有获取访问权限。 错误修正 ：确保该属性具有获取访问定义。 错误示例： PROGRAM PLC_PRG VAR i : INT; inst: FB; END_VAR i := inst.Prop; FUNCTION_BLOCK FB VAR END_VAR PROPERTY Prop : INT Set; 信息： C0143：属性 'Prop' 不能在此上下文中使用，因为它缺少 get 访问器...", 
"body" : "C0143 信息 : 属性 '<property name>' 不能在此上下文中使用，因为它缺少 get 访问器 可能的错误原因 ：该属性没有获取访问权限。 错误修正 ：确保该属性具有获取访问定义。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n inst: FB;\nEND_VAR\n\ni := inst.Prop;\n\nFUNCTION_BLOCK FB\nVAR\nEND_VAR\n\nPROPERTY Prop : INT\nSet;\n 信息： C0143：属性 'Prop' 不能在此上下文中使用，因为它缺少 get 访问器 " }, 
{ "title" : "编译器错误 C0144 ", 
"url" : "_cds_error_c0144.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0144 ", 
"snippet" : "C0144 信息 : 只允许在功能块、接口和结构中继承 可能的错误原因 : 试图在不允许继承的对象中使用继承。 错误修正 ： 利用 EXTENDS 仅在功能块、接口和结构中。 错误示例： PROGRAM PLC_PRG VAR inst : DUT_1; END_VAR TYPE DUT: ( enum_member := 0 ); END_TYPE TYPE DUT_1 EXTENDS DUT: ( enum_memberX := 0 ); END_TYPE 信息： C0144：仅允许在功能块、接口和结构中进行继承...", 
"body" : "C0144 信息 : 只允许在功能块、接口和结构中继承 可能的错误原因 : 试图在不允许继承的对象中使用继承。 错误修正 ： 利用 EXTENDS 仅在功能块、接口和结构中。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : DUT_1;\nEND_VAR\n\nTYPE DUT:\n(\n enum_member := 0\n);\nEND_TYPE\n\nTYPE DUT_1 EXTENDS DUT:\n(\n enum_memberX := 0\n);\nEND_TYPE\n 信息： C0144：仅允许在功能块、接口和结构中进行继承 " }, 
{ "title" : "编译器错误 C0145 ", 
"url" : "_cds_error_c0145.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0145 ", 
"snippet" : "C0145 信息 ：接口只能由功能块实现 可能的错误原因 : 试图在功能块之外实现接口。 错误修正 ：仅在功能块中实现接口。 错误示例： PROGRAM PLC_PRG VAR END_VAR POU(); FUNCTION POU IMPLEMENTS ITF VAR END_VAR 信息： C0145：接口只能由功能块实现...", 
"body" : "C0145 信息 ：接口只能由功能块实现 可能的错误原因 : 试图在功能块之外实现接口。 错误修正 ：仅在功能块中实现接口。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nPOU();\n\nFUNCTION POU IMPLEMENTS ITF\nVAR\nEND_VAR\n 信息： C0145：接口只能由功能块实现 " }, 
{ "title" : "编译器错误 C0149 ", 
"url" : "_cds_error_c0149.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0149 ", 
"snippet" : "C0149 信息 : 接口中不允许变量声明 可能的错误原因 : 试图在接口中定义一个变量。 错误修正 : 不要在接口中定义变量。 错误示例： PROGRAM PLC_PRG VAR inst : ITF; END_VAR INTERFACE ITF VAR_INPUT i : INT; END_VAR 信息： C0149: 接口中不允许变量声明...", 
"body" : "C0149 信息 : 接口中不允许变量声明 可能的错误原因 : 试图在接口中定义一个变量。 错误修正 : 不要在接口中定义变量。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : ITF;\nEND_VAR\n\nINTERFACE ITF\nVAR_INPUT\n i : INT;\nEND_VAR\n 信息： C0149: 接口中不允许变量声明 " }, 
{ "title" : "编译器错误 C0161 ", 
"url" : "_cds_error_c0161.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0161 ", 
"snippet" : "C0161 信息 : 数组的边框 <array bound> 不是常数值 可能的错误原因 : 一个变量被指定为一个数组绑定。 错误修正 ：使用常量作为数组边界。 错误示例： PROGRAM PLC_PRG VAR i : INT := 3; arr1 : ARRAY[1..i] OF INT; END_VAR 信息： C0161: 数组的边框“i”不是常数值 错误修正： arr1 : ARRAY[1..3] OF INT;...", 
"body" : "C0161 信息 : 数组的边框 <array bound> 不是常数值 可能的错误原因 : 一个变量被指定为一个数组绑定。 错误修正 ：使用常量作为数组边界。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT := 3;\n arr1 : ARRAY[1..i] OF INT;\nEND_VAR\n 信息： C0161: 数组的边框“i”不是常数值 错误修正： arr1 : ARRAY[1..3] OF INT; " }, 
{ "title" : "编译器错误 C0162 ", 
"url" : "_cds_error_c0162.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0162 ", 
"snippet" : "C0162 信息 : Number <number of array values> 数组初始化不是常数值 可能的错误原因 : 初始化 [Wert1,AnzahlWert2(Wert2)] 仅适用于常数 AnzahlWert2 . 错误修正 : 仅使用常量。 错误示例： PROGRAM PLC_PRG VAR i : INT := 3; arr1 : ARRAY[1..4] OF INT := [1,i(7)]; END_VAR 信息： C0162：数组初始化的数字“i”不是常数值 错误修正： arr1 : ARRAY[1..4] OF INT := [1,3(7)];...", 
"body" : "C0162 信息 : Number <number of array values> 数组初始化不是常数值 可能的错误原因 : 初始化 [Wert1,AnzahlWert2(Wert2)] 仅适用于常数 AnzahlWert2 . 错误修正 : 仅使用常量。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT := 3;\n arr1 : ARRAY[1..4] OF INT := [1,i(7)];\nEND_VAR\n 信息： C0162：数组初始化的数字“i”不是常数值 错误修正： arr1 : ARRAY[1..4] OF INT := [1,3(7)]; " }, 
{ "title" : "编译器错误 C0164 ", 
"url" : "_cds_error_c0164.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0164 ", 
"snippet" : "C0164 信息 : POU <name> 写入输出 <name> 并在多个任务中调用。 可能的错误原因 ：设备设置 codegenerator\\check-multiple-task-output-write 设置并且多个任务访问相同的输出。 错误修正 ：不要调用在多个任务中更改输出的程序。 错误示例： PROGRAM PLC_PRG VAR Output AT %QB7 : BYTE END_VAR Output := 0; 信息： C0164: POU PLC_PRG 写入输出 QB7 并在多个任务中调用。...", 
"body" : "C0164 信息 : POU <name> 写入输出 <name> 并在多个任务中调用。 可能的错误原因 ：设备设置 codegenerator\\check-multiple-task-output-write 设置并且多个任务访问相同的输出。 错误修正 ：不要调用在多个任务中更改输出的程序。 错误示例： PROGRAM PLC_PRG\nVAR\n Output AT %QB7 : BYTE\nEND_VAR\n\nOutput := 0;\n 信息： C0164: POU PLC_PRG 写入输出 QB7 并在多个任务中调用。 " }, 
{ "title" : "编译器错误 C0165 ", 
"url" : "_cds_error_c0165.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0165 ", 
"snippet" : "C0165 信息 : 映射在地址'<address>'上的变量'<variable name>'写在不同的任务中。 可能的错误原因 ：设备设置 codegenerator\\check-multiple-task-output-write 设置并且多个任务访问相同的输出。 错误修正 ：仅在一项固定任务中写入输出。如果多个任务需要为一个输出计算数据，那么您应该尝试通过全局变量将这些信息传递给一个固定任务，然后将数据写入一个输出。 错误示例： PROGRAM PLC_PRG_1 VAR Output AT %QB7 : BYTE; END_VAR Output := 0; PROGRAM PLC_P...", 
"body" : "C0165 信息 : 映射在地址'<address>'上的变量'<variable name>'写在不同的任务中。 可能的错误原因 ：设备设置 codegenerator\\check-multiple-task-output-write 设置并且多个任务访问相同的输出。 错误修正 ：仅在一项固定任务中写入输出。如果多个任务需要为一个输出计算数据，那么您应该尝试通过全局变量将这些信息传递给一个固定任务，然后将数据写入一个输出。 错误示例： PROGRAM PLC_PRG_1\nVAR\n Output AT %QB7 : BYTE;\nEND_VAR\nOutput := 0;\n\nPROGRAM PLC_PRG_2\nVAR\n Output AT %QB7 : BYTE;\nEND_VAR\nOutput := 1;\n 信息： C0165：映射在地址 QB7 上的变量输出被写入不同的任务。 " }, 
{ "title" : "编译器错误 C0168 ", 
"url" : "_cds_error_c0168.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0168 ", 
"snippet" : "C0168 信息 : 'VAR_CONFIG' 声明只允许在 VAR_CONFIG 列表中 可能的错误原因 : 'VAR_CONFIG' 在 VAR_CONFIG 列表之外使用。 错误修正 ：仅在 VAR_CONFIG 列表中使用“VAR_CONFIG”。 错误示例： PROGRAM PLC_PRG VAR_CONFIG i : INT; END_VAR 信息： 信息 : 'VAR_CONFIG' 声明只允许在 VAR_CONFIG 列表中...", 
"body" : "C0168 信息 : 'VAR_CONFIG' 声明只允许在 VAR_CONFIG 列表中 可能的错误原因 : 'VAR_CONFIG' 在 VAR_CONFIG 列表之外使用。 错误修正 ：仅在 VAR_CONFIG 列表中使用“VAR_CONFIG”。 错误示例： PROGRAM PLC_PRG\nVAR_CONFIG\n i : INT;\nEND_VAR\n 信息： 信息 : 'VAR_CONFIG' 声明只允许在 VAR_CONFIG 列表中 " }, 
{ "title" : "编译器错误 C0169 ", 
"url" : "_cds_error_c0169.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0169 ", 
"snippet" : "C0169 信息 : 'VAR_GLOBAL' 声明只允许在全局变量列表中 可能的错误原因 : 'VAR_GLOBAL' 在全局变量列表之外使用。 错误修正 ：仅在全局变量列表中使用“VAR_GLOBAL”。 错误示例： PROGRAM PLC_PRG VAR_GLOBAL i : INT; END_VAR 信息： C0169: 'VAR_GLOBAL' 声明只允许在全局变量列表中...", 
"body" : "C0169 信息 : 'VAR_GLOBAL' 声明只允许在全局变量列表中 可能的错误原因 : 'VAR_GLOBAL' 在全局变量列表之外使用。 错误修正 ：仅在全局变量列表中使用“VAR_GLOBAL”。 错误示例： PROGRAM PLC_PRG\nVAR_GLOBAL\n i : INT;\nEND_VAR\n 信息： C0169: 'VAR_GLOBAL' 声明只允许在全局变量列表中 " }, 
{ "title" : "编译器错误 C0173 ", 
"url" : "_cds_error_c0173.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0173 ", 
"snippet" : "C0173 信息 : '<keyword>' 不允许出现在这个地方 可能的错误原因 ：声明关键字（例如： VAR_INPUT , VAR_OUTPUT ， 或者 VAR ) 在这个位置是不允许的。 错误修正 ：更正声明：输入和输出在类型定义或全局变量列表中没有用处或没有必要。 错误示例： TYPE DUT : STRUCT VAR_INPUT member : INT; END_VAR END_STRUCT END_TYPE 信息： C0173: 'VAR_INPUT' 不允许在这个地方 错误修正： Beispiel: TYPE DUT : STRUCT member : INT; END_S...", 
"body" : "C0173 信息 : '<keyword>' 不允许出现在这个地方 可能的错误原因 ：声明关键字（例如： VAR_INPUT , VAR_OUTPUT ， 或者 VAR ) 在这个位置是不允许的。 错误修正 ：更正声明：输入和输出在类型定义或全局变量列表中没有用处或没有必要。 错误示例： TYPE DUT :\nSTRUCT\n VAR_INPUT\n member : INT;\n END_VAR\nEND_STRUCT\nEND_TYPE\n 信息： C0173: 'VAR_INPUT' 不允许在这个地方 错误修正： Beispiel:\nTYPE DUT :\nSTRUCT\n member : INT;\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "编译器错误 C0174 ", 
"url" : "_cds_error_c0174.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0174 ", 
"snippet" : "C0174 信息 : 这个地方不允许“VAR_TEMP”声明 可能的错误原因 : 'VAR_TEMP' 在程序或功能块之外使用。 错误修正 ：仅在程序和功能块中使用“VAR_TEMP”。 错误示例： PROGRAM PLC_PRG VAR END_VAR FUN(); FUNCTION FUN VAR_TEMP END_VAR 信息： C0174：此位置不允许“VAR_TEMP”声明...", 
"body" : "C0174 信息 : 这个地方不允许“VAR_TEMP”声明 可能的错误原因 : 'VAR_TEMP' 在程序或功能块之外使用。 错误修正 ：仅在程序和功能块中使用“VAR_TEMP”。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nFUN();\n\nFUNCTION FUN\nVAR_TEMP\nEND_VAR\n 信息： C0174：此位置不允许“VAR_TEMP”声明 " }, 
{ "title" : "编译器错误 C0175 ", 
"url" : "_cds_error_c0175.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0175 ", 
"snippet" : "C0175 信息 : 'RETAIN' 或 'PERSISTENT' 不允许在这个地方 可能的错误原因 : 'RETAIN' 或 'PERSISTENT' 在函数中使用。 错误修正 ：在预定位置使用“保留”或“持久”。 错误示例： PROGRAM PLC_PRG VAR END_VAR POU_1(); FUNCTION POU_1 VAR RETAIN END_VAR 信息： C0175: 'RETAIN' 或 'PERSISTENT' 不允许在这个地方...", 
"body" : "C0175 信息 : 'RETAIN' 或 'PERSISTENT' 不允许在这个地方 可能的错误原因 : 'RETAIN' 或 'PERSISTENT' 在函数中使用。 错误修正 ：在预定位置使用“保留”或“持久”。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nPOU_1();\n\nFUNCTION POU_1\nVAR RETAIN\nEND_VAR\n 信息： C0175: 'RETAIN' 或 'PERSISTENT' 不允许在这个地方 " }, 
{ "title" : "编译器错误 C0177 ", 
"url" : "_cds_error_c0177.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0177 ", 
"snippet" : "C0177 信息 ：“<object>”属于“<type>”类型，无法实例化 可能的错误原因 : 试图实例化一个函数。 错误修正 : 只实例化可以实例化的对象。 错误示例： PROGRAM PLC_PRG VAR inst : POU; END_VAR FUNCTION POU VAR END_VAR 信息： C0177：“POU”属于“FUNCTION”类型，无法实例化...", 
"body" : "C0177 信息 ：“<object>”属于“<type>”类型，无法实例化 可能的错误原因 : 试图实例化一个函数。 错误修正 : 只实例化可以实例化的对象。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : POU;\nEND_VAR\n\nFUNCTION POU\nVAR\nEND_VAR\n 信息： C0177：“POU”属于“FUNCTION”类型，无法实例化 " }, 
{ "title" : "编译器错误 C0178 ", 
"url" : "_cds_error_c0178.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0178 ", 
"snippet" : "C0178 信息 : 没有对“<对象名称>”的“VAR_IN_OUT”参数“<参数名称>”的外部访问 可能的错误原因 ：尝试远程访问“VAR_IN_OUT”参数。 错误修正 : 不要远程访问 'VAR_IN_OUT' 参数。 错误示例： PROGRAM PLC_PRG VAR inst : FB; i : INT; END_VAR i := inst.in_out; FUNCTION_BLOCK FB VAR_IN_OUT in_out : INT; END_VAR 信息： C0178: 无法从外部访问“FB”的“VAR_IN_OUT”参数“in_out”...", 
"body" : "C0178 信息 : 没有对“<对象名称>”的“VAR_IN_OUT”参数“<参数名称>”的外部访问 可能的错误原因 ：尝试远程访问“VAR_IN_OUT”参数。 错误修正 : 不要远程访问 'VAR_IN_OUT' 参数。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\n i : INT;\nEND_VAR\ni := inst.in_out;\n\nFUNCTION_BLOCK FB\nVAR_IN_OUT\n in_out : INT;\nEND_VAR\n 信息： C0178: 无法从外部访问“FB”的“VAR_IN_OUT”参数“in_out” " }, 
{ "title" : "编译器错误 C0179 ", 
"url" : "_cds_error_c0179.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0179 ", 
"snippet" : "C0179 信息 ：“<标识符>”不是“功能块”的输出 可能的错误原因 ：功能块实例的初始化不能包含 VAR_IN_OUT 变量。 错误修正 ： 利用 VAR_IN_OUT 仅限功能块调用中的变量。初始化功能块实例时，仅分配功能块的输入。 错误示例： Beispiel: FUNCTION_BLOCK MyFB VAR_IN_OUT inOut : INT; END_VAR PROGRAM PLC_PRG VAR iValue : INT; fb : MyFB := (inOut := iValue); END_VAR 信息： C0179: 'inOut' 不是 'MyFB' 的输出...", 
"body" : "C0179 信息 ：“<标识符>”不是“功能块”的输出 可能的错误原因 ：功能块实例的初始化不能包含 VAR_IN_OUT 变量。 错误修正 ： 利用 VAR_IN_OUT 仅限功能块调用中的变量。初始化功能块实例时，仅分配功能块的输入。 错误示例： Beispiel:\nFUNCTION_BLOCK MyFB\nVAR_IN_OUT\n inOut : INT;\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n iValue : INT;\n fb : MyFB := (inOut := iValue);\nEND_VAR\n 信息： C0179: 'inOut' 不是 'MyFB' 的输出 " }, 
{ "title" : "编译器错误 C0180 ", 
"url" : "_cds_error_c0180.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0180 ", 
"snippet" : "C0180 信息 : 由库 '<library 2>' 定义的模棱两可的命名空间 '<library 1>' 可能的错误原因 : 库 <library 1> 的命名空间不是唯一的。它已用于 <library 2>。 错误修正 : 相应地更改库的命名空间 ( 特性 库管理器中的按钮）。 错误示例： 信息： C0180：由库“标准，3.5.15.0（系统）”定义的模糊命名空间“标准”...", 
"body" : "C0180 信息 : 由库 '<library 2>' 定义的模棱两可的命名空间 '<library 1>' 可能的错误原因 : 库 <library 1> 的命名空间不是唯一的。它已用于 <library 2>。 错误修正 : 相应地更改库的命名空间 ( 特性 库管理器中的按钮）。 错误示例： 信息： C0180：由库“标准，3.5.15.0（系统）”定义的模糊命名空间“标准” " }, 
{ "title" : "编译器错误 C0182 ", 
"url" : "_cds_error_c0182.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0182 ", 
"snippet" : "C0182 信息 : 返回类型仅适用于 FUNCTION 和 METHOD 类型的 POU 可能的错误原因 : 试图在程序中定义返回值。 错误修正 ：仅在方法和函数中定义返回值。 错误示例： 错误示例： PROGRAM PLC_PRG : BOOL VAR END_VAR 信息： C0182：返回类型仅适用于 FUNCTION 和 METHOD 类型的 POU...", 
"body" : "C0182 信息 : 返回类型仅适用于 FUNCTION 和 METHOD 类型的 POU 可能的错误原因 : 试图在程序中定义返回值。 错误修正 ：仅在方法和函数中定义返回值。 错误示例： 错误示例： PROGRAM PLC_PRG : BOOL\nVAR\nEND_VAR\n 信息： C0182：返回类型仅适用于 FUNCTION 和 METHOD 类型的 POU " }, 
{ "title" : "编译器错误 C0183 ", 
"url" : "_cds_error_c0183.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0183 ", 
"snippet" : "C0183 信息 : 全局范围操作 '.'对表达式“<表达式>”无效 可能的错误原因 ： 这 '。'运算符用于访问全局变量。但是，在此位置，它后面不是有效的 IEC 标识符，而是例如“;”之类的字符。或保留的标识符，例如 FUNCTION ，或运算符，例如 TO_STRING . 错误修正 ：对全局变量使用有效的 IEC 标识符。 错误示例： PROGRAM PLC_PRG ... iVar := .FUNCTION; strVar := .TO_STRING; 信息： C0183: 全局范围操作 '.'对表达式“<表达式>”无效 错误修正： 示例：globalValue 在 GVL 中声明。...", 
"body" : "C0183 信息 : 全局范围操作 '.'对表达式“<表达式>”无效 可能的错误原因 ： 这 '。'运算符用于访问全局变量。但是，在此位置，它后面不是有效的 IEC 标识符，而是例如“;”之类的字符。或保留的标识符，例如 FUNCTION ，或运算符，例如 TO_STRING . 错误修正 ：对全局变量使用有效的 IEC 标识符。 错误示例： PROGRAM PLC_PRG\n...\n\niVar := .FUNCTION;\nstrVar := .TO_STRING; 信息： C0183: 全局范围操作 '.'对表达式“<表达式>”无效 错误修正： 示例：globalValue 在 GVL 中声明。 PROGRAM PLC_PRG\niVar := .globalValue; " }, 
{ "title" : "编译器错误 C0185 ", 
"url" : "_cds_error_c0185.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0185 ", 
"snippet" : "C0185 信息 : 无法对函数调用结果执行组件访问“.”、索引访问“[]”或调用“()”。首先将结果分配给帮助变量。 可能的错误原因 ：执行对函数调用结果的组件或索引访问。 错误修正 ：将结果分配给变量以便访问。 错误示例： PROGRAM PLC_PRG VAR it : ITF; END_VAR POU_1()[0].METH1(); FUNCTION POU_1 : ARRAY[0..0] OF ITF INTERFACE ITF METHOD METH1 信息： C0185: 无法对函数调用的结果执行组件访问“.”、索引访问“[]”或调用“()”。首先将结果分配给帮助变量。...", 
"body" : "C0185 信息 : 无法对函数调用结果执行组件访问“.”、索引访问“[]”或调用“()”。首先将结果分配给帮助变量。 可能的错误原因 ：执行对函数调用结果的组件或索引访问。 错误修正 ：将结果分配给变量以便访问。 错误示例： PROGRAM PLC_PRG\nVAR\n it : ITF;\nEND_VAR\n\nPOU_1()[0].METH1();\n\nFUNCTION POU_1 : ARRAY[0..0] OF ITF\n\nINTERFACE ITF\n\nMETHOD METH1\n 信息： C0185: 无法对函数调用的结果执行组件访问“.”、索引访问“[]”或调用“()”。首先将结果分配给帮助变量。 " }, 
{ "title" : "编译器错误 C0186 ", 
"url" : "_cds_error_c0186.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0186 ", 
"snippet" : "C0186 信息 : 无法比较调用返回值的接口。先赋值给变量。 可能的错误原因 ：比较操作应用于函数返回的接口。 错误修正 ：首先将函数调用的结果赋值给一个变量，然后比较变量的值。这也将减少所需的函数调用次数。 错误示例： INTERFACE MyInterface FUNCTION GetInterface : MyInterface PROGRAM PLC_PRG IF GetInterface() <> 0 THEN \/\/ ... END_IF 信息： C0186: 无法比较作为调用返回值的接口。先赋值给变量。 错误修正： PROGRAM PLC_PRG VAR_TEMP tempInt...", 
"body" : "C0186 信息 : 无法比较调用返回值的接口。先赋值给变量。 可能的错误原因 ：比较操作应用于函数返回的接口。 错误修正 ：首先将函数调用的结果赋值给一个变量，然后比较变量的值。这也将减少所需的函数调用次数。 错误示例： INTERFACE MyInterface\n\nFUNCTION GetInterface : MyInterface\n\nPROGRAM PLC_PRG\nIF GetInterface() <> 0 THEN\n \/\/ ...\nEND_IF\n 信息： C0186: 无法比较作为调用返回值的接口。先赋值给变量。 错误修正： PROGRAM PLC_PRG\nVAR_TEMP\n tempInterface : MyInterface;\nEND_VAR\ntempInterface := GetInterface();\nIF tempInterface <> 0 THEN\n \/\/ ...\nEND_IF " }, 
{ "title" : "编译器警告 C0187 ", 
"url" : "_cds_error_c0187.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0187 ", 
"snippet" : "C0187 信息 : 外部引用只适用于功能块、方法、函数和常量全局变量列表。程序 “<程序名\" 的外部引用将被忽略。 可能的错误原因 : 在程序的属性对话框中，在 构建 选项卡， 外部实施 选项已激活。 错误更正 : 停用 外部实施 选项。...", 
"body" : "C0187 信息 : 外部引用只适用于功能块、方法、函数和常量全局变量列表。程序 “<程序名\" 的外部引用将被忽略。 可能的错误原因 : 在程序的属性对话框中，在 构建 选项卡， 外部实施 选项已激活。 错误更正 : 停用 外部实施 选项。 " }, 
{ "title" : "编译器错误 C0188 ", 
"url" : "_cds_error_c0188.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0188 ", 
"snippet" : "C0188 信息 : 设备未安装到系统中。无法生成代码。 可能的错误原因 ：未安装所需的设备。 错误修正 ：在设备库中安装缺少的设备，或者用另一个现有设备替换已经插入设备树的现有设备（ 更新设备 ）。...", 
"body" : "C0188 信息 : 设备未安装到系统中。无法生成代码。 可能的错误原因 ：未安装所需的设备。 错误修正 ：在设备库中安装缺少的设备，或者用另一个现有设备替换已经插入设备树的现有设备（ 更新设备 ）。 " }, 
{ "title" : "编译器错误 C0189 ", 
"url" : "_cds_error_c0189.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0189 ", 
"snippet" : "C0189 信息 : ';'预期而不是 '<token>' 可能的错误原因 : 语法错误 错误修正 : 确保语法正确。 错误示例： PROGRAM PLC_PRG VAR INT END_VAR 信息： C0009：意外的令牌“<令牌>”成立 C0189: ';'预期而不是“INT”...", 
"body" : "C0189 信息 : ';'预期而不是 '<token>' 可能的错误原因 : 语法错误 错误修正 : 确保语法正确。 错误示例： PROGRAM PLC_PRG\nVAR\n INT\nEND_VAR\n 信息： C0009：意外的令牌“<令牌>”成立 C0189: ';'预期而不是“INT” " }, 
{ "title" : "编译器错误 C0190 ", 
"url" : "_cds_error_c0190.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0190 ", 
"snippet" : "C0190 信息 : ';'预期而不是 POU 的结尾 可能的错误原因 : POU 中的语法错误 错误修正 : 确保语法正确。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := 5 信息： C0190: ';'预期而不是 POU 的结尾...", 
"body" : "C0190 信息 : ';'预期而不是 POU 的结尾 可能的错误原因 : POU 中的语法错误 错误修正 : 确保语法正确。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni := 5\n 信息： C0190: ';'预期而不是 POU 的结尾 " }, 
{ "title" : "编译器错误 C0191 ", 
"url" : "_cds_error_c0191.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0191 ", 
"snippet" : "C0191 信息 ：不再支持运算符“INDEXOF”。请改用 ADR。 POU-Name 上的 ADR 返回一个指向函数代码指针的指针。 可能的错误原因 : 使用了过时的运算符'INDEXOF'。 错误修正 ：使用运算符“ADR”。...", 
"body" : "C0191 信息 ：不再支持运算符“INDEXOF”。请改用 ADR。 POU-Name 上的 ADR 返回一个指向函数代码指针的指针。 可能的错误原因 : 使用了过时的运算符'INDEXOF'。 错误修正 ：使用运算符“ADR”。 " }, 
{ "title" : "编译器错误 C0195 ", 
"url" : "_cds_error_c0195.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0195 ", 
"snippet" : "C0195 信息 ：从有符号类型“<数据类型 1>”到无符号类型“<数据类型 2>”的隐式转换：可能更改符号 可能的错误原因 : 隐式转换中可能遗漏了符号冲突。 错误修正 : 仅隐式转换具有相同符号的数据类型。 错误示例： PROGRAM PLC_PRG VAR i : INT; b : UINT; END_VAR b := i; 信息： C0195：从有符号“INT”类型到无符号“UINT”类型的隐式转换：可能更改符号...", 
"body" : "C0195 信息 ：从有符号类型“<数据类型 1>”到无符号类型“<数据类型 2>”的隐式转换：可能更改符号 可能的错误原因 : 隐式转换中可能遗漏了符号冲突。 错误修正 : 仅隐式转换具有相同符号的数据类型。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n b : UINT;\nEND_VAR\n\nb := i;\n 信息： C0195：从有符号“INT”类型到无符号“UINT”类型的隐式转换：可能更改符号 " }, 
{ "title" : "编译器错误 C0196 ", 
"url" : "_cds_error_c0196.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0196 ", 
"snippet" : "C0196 信息 ：从无符号类型“<数据类型 1>”到有符号类型“<数据类型 2>”的隐式转换：可能更改符号 可能的错误原因 : 隐式转换中可能遗漏了符号冲突。 错误修正 : 使用显式转换。 错误示例： PROGRAM PLC_PRG VAR i : INT; b : UINT; END_VAR i := b; 信息： C0196：从无符号类型“UINT”到有符号类型“INT”的隐式转换：可能更改符号...", 
"body" : "C0196 信息 ：从无符号类型“<数据类型 1>”到有符号类型“<数据类型 2>”的隐式转换：可能更改符号 可能的错误原因 : 隐式转换中可能遗漏了符号冲突。 错误修正 : 使用显式转换。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n b : UINT;\nEND_VAR\n\ni := b;\n 信息： C0196：从无符号类型“UINT”到有符号类型“INT”的隐式转换：可能更改符号 " }, 
{ "title" : "编译器错误 C0197 ", 
"url" : "_cds_error_c0197.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0197 ", 
"snippet" : "C0197 信息 ：从“<数据类型 1>”到“<数据类型 2>”的隐式转换：可能丢失信息 可能的错误原因 : 尝试将变量从数据类型 DINT 或 LINT 转换为数据类型 REAL。 错误修正 ：对于 DINT，使用数据类型 LREAL，从 LINT 转换为 LREAL 时，请确保 LINT 的值不超过 LREAL 的容量。 错误示例： PROGRAM PLC_PRG VAR i : DINT; b : REAL; END_VAR b := i; 信息： C0197：从“DINT”到“REAL”的隐式转换：可能丢失信息...", 
"body" : "C0197 信息 ：从“<数据类型 1>”到“<数据类型 2>”的隐式转换：可能丢失信息 可能的错误原因 : 尝试将变量从数据类型 DINT 或 LINT 转换为数据类型 REAL。 错误修正 ：对于 DINT，使用数据类型 LREAL，从 LINT 转换为 LREAL 时，请确保 LINT 的值不超过 LREAL 的容量。 错误示例： PROGRAM PLC_PRG\nVAR\n i : DINT;\n b : REAL;\nEND_VAR\nb := i;\n 信息： C0197：从“DINT”到“REAL”的隐式转换：可能丢失信息 " }, 
{ "title" : "编译器错误 C0198 ", 
"url" : "_cds_error_c0198.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0198 ", 
"snippet" : "C0198 信息 : 字符串常量“<字符串值>”对于目标类型“<数据类型>”来说太长了 可能的错误原因 : 字符串常量的字符太多。 错误修正 ：使用较短的字符串常量或声明较大的字符串。 错误示例： PROGRAM PLC_PRG VAR str : STRING(4) := '12345'; END_VAR 信息： C0198: 字符串常量 '12345' 对于目标类型 'STRING(4)' 来说太长了...", 
"body" : "C0198 信息 : 字符串常量“<字符串值>”对于目标类型“<数据类型>”来说太长了 可能的错误原因 : 字符串常量的字符太多。 错误修正 ：使用较短的字符串常量或声明较大的字符串。 错误示例： PROGRAM PLC_PRG\nVAR\n str : STRING(4) := '12345';\nEND_VAR\n 信息： C0198: 字符串常量 '12345' 对于目标类型 'STRING(4)' 来说太长了 " }, 
{ "title" : "编译器错误 C0199 ", 
"url" : "_cds_error_c0199.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0199 ", 
"snippet" : "C0199 信息 : 接口“<接口名称>”必须被实例化才能被访问 可能的错误原因 : 试图在没有实例化接口的情况下访问接口方法。 错误修正 : 实例化接口。 错误示例： PROGRAM PLC_PRG VAR END_VAR ITF.METH(); INTERFACE ITF METHOD METH VAR_INPUT END_VAR 信息： C0199：必须实例化接口“ITF”才能访问 错误修正： Beispiel: itest: ITF;...", 
"body" : "C0199 信息 : 接口“<接口名称>”必须被实例化才能被访问 可能的错误原因 : 试图在没有实例化接口的情况下访问接口方法。 错误修正 : 实例化接口。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nITF.METH();\n\nINTERFACE ITF\n\nMETHOD METH\nVAR_INPUT\nEND_VAR\n 信息： C0199：必须实例化接口“ITF”才能访问 错误修正： Beispiel:\nitest: ITF; " }, 
{ "title" : "编译器错误 C0201 ", 
"url" : "_cds_error_c0201.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0201 ", 
"snippet" : "C0201 信息 : 类型 '<data type 1>' 不等于类型 '<data type 2>' of VAR_IN_OUT 'Variable' 可能的错误原因 : 作为 VAR_IN_OUT 参数传递给函数的数据类型与其中定义的数据类型不匹配。 错误修正 ：传递具有正确数据类型的变量。 错误示例： PROGRAM PLC_PRG VAR Inst: POU; b : BOOL; END_VAR inst(in_out := b); FUNCTION_BLOCK POU VAR_IN_OUT in_out : INT; END_VAR 信息： C0201：“BOOL”类型不等于 VAR...", 
"body" : "C0201 信息 : 类型 '<data type 1>' 不等于类型 '<data type 2>' of VAR_IN_OUT 'Variable' 可能的错误原因 : 作为 VAR_IN_OUT 参数传递给函数的数据类型与其中定义的数据类型不匹配。 错误修正 ：传递具有正确数据类型的变量。 错误示例： PROGRAM PLC_PRG\nVAR\n Inst: POU;\n b : BOOL;\nEND_VAR\n\ninst(in_out := b);\n\nFUNCTION_BLOCK POU\nVAR_IN_OUT\n in_out : INT;\nEND_VAR\n 信息： C0201：“BOOL”类型不等于 VAR_IN_OUT“变量”的“INT”类型 " }, 
{ "title" : "编译器错误 C0203 ", 
"url" : "_cds_error_c0203.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0203 ", 
"snippet" : "C0203 信息 : 只有结构和功能块可以包含 BIT 类型的变量。 可能的错误原因 : 试图在结构和功能块之外声明一个 BIT 类型的变量。 错误修正 : 仅在结构和功能块中声明 BIT 类型的变量。 错误示例： PROGRAM PLC_PRG VAR b : BIT; END_VAR 信息： C0203：只有结构和功能块可以包含 BIT 类型的变量。...", 
"body" : "C0203 信息 : 只有结构和功能块可以包含 BIT 类型的变量。 可能的错误原因 : 试图在结构和功能块之外声明一个 BIT 类型的变量。 错误修正 : 仅在结构和功能块中声明 BIT 类型的变量。 错误示例： PROGRAM PLC_PRG\nVAR\n b : BIT;\nEND_VAR\n 信息： C0203：只有结构和功能块可以包含 BIT 类型的变量。 " }, 
{ "title" : "编译器错误 C0204 ", 
"url" : "_cds_error_c0204.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0204 ", 
"snippet" : "C0204 信息 : BIT 类型的变量必须在 VAR_INPUT-、VAR_OUTPUT 或 VAR-块中声明 可能的错误原因 : 尝试定义 BIT 类型的变量或作为 VAR_IN_OUT 参数。 错误修正 ：仅在 VAR_INPUT、VAR_OUTPUT 或 VAR 块中定义 BIT 类型的变量。 错误示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB VAR_IN_OUT b : BIT; END_VAR 信息： C0204: BIT 类型的变量必须在 VAR_INPUT-、VAR_OUTPUT 或 VAR-块中声明...", 
"body" : "C0204 信息 : BIT 类型的变量必须在 VAR_INPUT-、VAR_OUTPUT 或 VAR-块中声明 可能的错误原因 : 尝试定义 BIT 类型的变量或作为 VAR_IN_OUT 参数。 错误修正 ：仅在 VAR_INPUT、VAR_OUTPUT 或 VAR 块中定义 BIT 类型的变量。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB\nVAR_IN_OUT\n b : BIT;\nEND_VAR\n 信息： C0204: BIT 类型的变量必须在 VAR_INPUT-、VAR_OUTPUT 或 VAR-块中声明 " }, 
{ "title" : "编译器错误 C0205 ", 
"url" : "_cds_error_c0205.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0205 ", 
"snippet" : "C0205 信息 : POINTER TO BIT 是不允许的 可能的错误原因 : 试图声明一个 POINTER TO BIT。 错误修正 : 不要声明 POINTER TO BIT。 错误示例： PROGRAM PLC_PRG VAR pt : POINTER TO BIT; END_VAR 信息： C0205: POINTER TO BIT 不允许...", 
"body" : "C0205 信息 : POINTER TO BIT 是不允许的 可能的错误原因 : 试图声明一个 POINTER TO BIT。 错误修正 : 不要声明 POINTER TO BIT。 错误示例： PROGRAM PLC_PRG\nVAR\n pt : POINTER TO BIT;\nEND_VAR\n 信息： C0205: POINTER TO BIT 不允许 " }, 
{ "title" : "编译器错误 C0206 ", 
"url" : "_cds_error_c0206.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0206 ", 
"snippet" : "C0206 信息 : BIT 不允许作为数组的基本类型 可能的错误原因 : 尝试声明一个 BIT 数组。 错误修正 : 不要声明 BIT 数组。 错误示例： PROGRAM PLC_PRG VAR arr : ARRAY[1..2] OF BIT; END_VAR 信息： C0206: BIT 不允许作为数组的基本类型...", 
"body" : "C0206 信息 : BIT 不允许作为数组的基本类型 可能的错误原因 : 尝试声明一个 BIT 数组。 错误修正 : 不要声明 BIT 数组。 错误示例： PROGRAM PLC_PRG\nVAR\n arr : ARRAY[1..2] OF BIT;\nEND_VAR\n 信息： C0206: BIT 不允许作为数组的基本类型 " }, 
{ "title" : "编译器错误 C0207 ", 
"url" : "_cds_error_c0207.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0207 ", 
"snippet" : "C0207 信息 : '<identifier>' 没有系统定义 可能的错误原因 : 试图访问一个变量 __SYSTEM 那不存在。 错误修正 ：检查并更正各个变量的指定标识符。 错误示例： PROGRAM PLC_PRG VAR Value : INT; END_VAR Value := __SYSTEM.UnknownVariable; 信息： C0207：“UnkownVariable”没有系统定义...", 
"body" : "C0207 信息 : '<identifier>' 没有系统定义 可能的错误原因 : 试图访问一个变量 __SYSTEM 那不存在。 错误修正 ：检查并更正各个变量的指定标识符。 错误示例： PROGRAM PLC_PRG\nVAR\n Value : INT;\nEND_VAR\nValue := __SYSTEM.UnknownVariable;\n 信息： C0207：“UnkownVariable”没有系统定义 " }, 
{ "title" : "编译器错误 C0208 ", 
"url" : "_cds_error_c0208.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0208 ", 
"snippet" : "C0208 信息 : 'MOD' 没有为 'REAL' 定义 可能的错误原因 : 尝试对类型变量执行模运算 REAL . 错误修正 ：模运算仅适用于类型变量 ANY_INT . 错误示例： PROGRAM PLC_PRG VAR r1 : REAL; END_VAR r1 := r1 MOD 2; 信息： C0208: 'MOD' 未定义为 'REAL'...", 
"body" : "C0208 信息 : 'MOD' 没有为 'REAL' 定义 可能的错误原因 : 尝试对类型变量执行模运算 REAL . 错误修正 ：模运算仅适用于类型变量 ANY_INT . 错误示例： PROGRAM PLC_PRG\nVAR\n r1 : REAL;\nEND_VAR\nr1 := r1 MOD 2;\n 信息： C0208: 'MOD' 未定义为 'REAL' " }, 
{ "title" : "编译器错误 C0209 ", 
"url" : "_cds_error_c0209.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0209 ", 
"snippet" : "C0209 信息 ：您已为设备“<设备名称>”定义了“<编号>”应用程序。最大数量是“<数字>”。因此，您将无法下载所有应用程序。 可能的错误原因 ：某些设备仅支持特定数量的应用程序（设备描述）。如果项目包含更多应用程序，则并非所有应用程序都将下载到设备。 错误修正 ：从您的项目中删除应用程序或使用其他设备。...", 
"body" : "C0209 信息 ：您已为设备“<设备名称>”定义了“<编号>”应用程序。最大数量是“<数字>”。因此，您将无法下载所有应用程序。 可能的错误原因 ：某些设备仅支持特定数量的应用程序（设备描述）。如果项目包含更多应用程序，则并非所有应用程序都将下载到设备。 错误修正 ：从您的项目中删除应用程序或使用其他设备。 " }, 
{ "title" : "编译器错误 C0211 ", 
"url" : "_cds_error_c0211.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0211 ", 
"snippet" : "C0211 信息 : 期望变量声明而不是 <表达式> 可能的错误原因 : 语法错误 错误修正 : 确保语法正确。 错误示例： PROGRAM PLC_PRG VAR VAR END_VAR END_VAR 信息： C0211：需要变量声明而不是 VAR END_VAR...", 
"body" : "C0211 信息 : 期望变量声明而不是 <表达式> 可能的错误原因 : 语法错误 错误修正 : 确保语法正确。 错误示例： PROGRAM PLC_PRG\nVAR\n VAR\n\n END_VAR\nEND_VAR\n 信息： C0211：需要变量声明而不是 VAR END_VAR " }, 
{ "title" : "编译器错误 C0212 ", 
"url" : "_cds_error_c0212.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0212 ", 
"snippet" : "C0212 信息 : 应为 VAR、VAR_INPUT、VAR_OUTPUT 或 VAR_INOUT 而不是 <表达式> 可能的错误原因 : 语法错误 错误修正 : 确保语法正确。 错误示例： PROGRAM PLC_PRG i : INT; 信息： C0212: VAR, VAR_INPUT, VAR_OUTPUT 或 VAR_INOUT 代替 i : INT;...", 
"body" : "C0212 信息 : 应为 VAR、VAR_INPUT、VAR_OUTPUT 或 VAR_INOUT 而不是 <表达式> 可能的错误原因 : 语法错误 错误修正 : 确保语法正确。 错误示例： PROGRAM PLC_PRG\ni : INT;\n 信息： C0212: VAR, VAR_INPUT, VAR_OUTPUT 或 VAR_INOUT 代替 i : INT; " }, 
{ "title" : "编译器错误 C0213 ", 
"url" : "_cds_error_c0213.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0213 ", 
"snippet" : "C0213 消息 : 应使用 VAR_GLOBAL 或 VAR_CONFIG ，而不是 可能的错误原因 : 在全局变量列表 (GVL) 中，在 a 之外有一个变量声明 VAR_GLOBAL 阻止。 错误更正 : 将变量声明移至 VAR_GLOBAL 或者 VAR_CONFIG 阻止。 错误示例 VAR_GLOBAL END_VAR i : INT; 消息： C0213：应使用 VAR_GLOBAL 或 VAR_CONFIG 而不是 i: INT...", 
"body" : "C0213 消息 : 应使用 VAR_GLOBAL 或 VAR_CONFIG ，而不是 可能的错误原因 : 在全局变量列表 (GVL) 中，在 a 之外有一个变量声明 VAR_GLOBAL 阻止。 错误更正 : 将变量声明移至 VAR_GLOBAL 或者 VAR_CONFIG 阻止。 错误示例 VAR_GLOBAL\nEND_VAR\ni : INT; 消息： C0213：应使用 VAR_GLOBAL 或 VAR_CONFIG 而不是 i: INT " }, 
{ "title" : "编译器错误 C0215 ", 
"url" : "_cds_error_c0215.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0215 ", 
"snippet" : "C0215 信息 : 在持久列表中不能直接声明地址 可能的错误原因 : 持久化变量不允许有直接地址。 错误修正 : 删除持久变量列表中的直接地址分配。 错误示例： VAR_GLOBAL PERSISTENT RETAIN directAddressVar AT %QB7 : BYTE; END_VAR 信息： C0215：在持久列表中不能直接声明地址...", 
"body" : "C0215 信息 : 在持久列表中不能直接声明地址 可能的错误原因 : 持久化变量不允许有直接地址。 错误修正 : 删除持久变量列表中的直接地址分配。 错误示例： VAR_GLOBAL PERSISTENT RETAIN\n directAddressVar AT %QB7 : BYTE;\nEND_VAR\n 信息： C0215：在持久列表中不能直接声明地址 " }, 
{ "title" : "编译器错误 C0216 ", 
"url" : "_cds_error_c0216.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0216 ", 
"snippet" : "C0216 信息 ：案例标签重复 可能的错误原因 : 一个 CASE 标签被多次使用。 错误修正 : 每个 CASE 标签只使用一次。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR CASE i OF 1: i := i+1; 1: i := i+2; ELSE i := i+10; END_CASE; --> C0216: Doppelte 'CASE'-Marke 信息： C0216: 案例标签重复...", 
"body" : "C0216 信息 ：案例标签重复 可能的错误原因 : 一个 CASE 标签被多次使用。 错误修正 : 每个 CASE 标签只使用一次。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\nCASE i OF\n 1: i := i+1;\n 1: i := i+2;\nELSE\n i := i+10;\nEND_CASE;\n\n--> C0216: Doppelte 'CASE'-Marke 信息： C0216: 案例标签重复 " }, 
{ "title" : "编译器错误 C0217 ", 
"url" : "_cds_error_c0217.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0217 ", 
"snippet" : "C0217 信息 : 案例标签 <案例标签> 也包含在范围 <案例范围开始> .. <案例范围结束> 可能的错误原因 ：一个 CASE 标签是另一个 CASE 标签范围的一部分。 错误修正 : 确保没有相交。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR CASE i OF 3..5: i := i+2; 4: i := i+2; ELSE i := i+10; END_CASE; 信息： C0217：案例标签 4 也包含在范围 3 .. 5 中...", 
"body" : "C0217 信息 : 案例标签 <案例标签> 也包含在范围 <案例范围开始> .. <案例范围结束> 可能的错误原因 ：一个 CASE 标签是另一个 CASE 标签范围的一部分。 错误修正 : 确保没有相交。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\nCASE i OF\n 3..5: i := i+2;\n 4: i := i+2;\nELSE\n i := i+10;\nEND_CASE;\n 信息： C0217：案例标签 4 也包含在范围 3 .. 5 中 " }, 
{ "title" : "编译器错误 C0218 ", 
"url" : "_cds_error_c0218.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0218 ", 
"snippet" : "C0218 信息 : 'CASE' 标签需要文字或符号整数常量 可能的错误原因 : 尝试使用变量作为 CASE 标签。 错误修正 : 仅使用文字和符号整数常量。 错误示例： PROGRAM PLC_PRG VAR i : INT; a : INT := 2; END_VAR CASE i OF 1: i := i+1; a: i := i+2; ELSE i := i+10; END_CASE; 信息： C0218：“CASE”标签需要文字或符号整数常量...", 
"body" : "C0218 信息 : 'CASE' 标签需要文字或符号整数常量 可能的错误原因 : 尝试使用变量作为 CASE 标签。 错误修正 : 仅使用文字和符号整数常量。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\n a : INT := 2;\nEND_VAR\n\nCASE i OF\n 1: i := i+1;\n a: i := i+2;\nELSE\n i := i+10;\nEND_CASE;\n 信息： C0218：“CASE”标签需要文字或符号整数常量 " }, 
{ "title" : "编译器错误 C0219 ", 
"url" : "_cds_error_c0219.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0219 ", 
"snippet" : "C0219 信息 : case 包含重叠范围 <case range 1 begin> .. <case range 1 end> 和 <case range 2 begin> .. <case range 2 end> 可能的错误原因 : CASE 标记的两个分支具有相同的元素或子集。 错误修正 : 确保没有相交。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR CASE i OF 3..5: i := i+2; 1..4: i := i+2; ELSE i := i+10; END_CASE; 信息： C0219: 'CASE' 包含重叠范围 1 .....", 
"body" : "C0219 信息 : case 包含重叠范围 <case range 1 begin> .. <case range 1 end> 和 <case range 2 begin> .. <case range 2 end> 可能的错误原因 : CASE 标记的两个分支具有相同的元素或子集。 错误修正 : 确保没有相交。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\nCASE i OF\n 3..5: i := i+2;\n 1..4: i := i+2;\nELSE\n i := i+10;\nEND_CASE;\n 信息： C0219: 'CASE' 包含重叠范围 1 .. 4 和 3 .. 5 " }, 
{ "title" : "编译器错误 C0221 ", 
"url" : "_cds_error_c0221.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0221 ", 
"snippet" : "C0221 信息 : 直接地址“<地址>”格式错误 可能的错误原因 ：地址未完全显示。 错误修正 ：确保地址显示正确。 错误示例： PROGRAM PLC_PRG VAR xVar : BOOL; END_VAR; xVar := %IX0; 信息： C0221：直接地址“%IXO”格式错误 错误修正： xVar := %IX0.2;...", 
"body" : "C0221 信息 : 直接地址“<地址>”格式错误 可能的错误原因 ：地址未完全显示。 错误修正 ：确保地址显示正确。 错误示例： PROGRAM PLC_PRG\nVAR\n xVar : BOOL;\nEND_VAR;\nxVar := %IX0;\n 信息： C0221：直接地址“%IXO”格式错误 错误修正： xVar := %IX0.2; " }, 
{ "title" : "编译器错误 C0222 ", 
"url" : "_cds_error_c0222.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0222 ", 
"snippet" : "C0222 信息 : 输出不能是“REFERENCE TO”类型 可能的错误原因 ：尝试定义 REFERENCE TO 作为输出参数。 错误修正 ： 不使用 REFERENCE TO 作为输出参数。 错误示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR 功能块的实现： FUNCTION_BLOCK FB VAR_OUTPUT re : REFERENCE TO INT; END_VAR 信息： C0222：输出不能是“REFERENCE TO”类型...", 
"body" : "C0222 信息 : 输出不能是“REFERENCE TO”类型 可能的错误原因 ：尝试定义 REFERENCE TO 作为输出参数。 错误修正 ： 不使用 REFERENCE TO 作为输出参数。 错误示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n 功能块的实现： FUNCTION_BLOCK FB\nVAR_OUTPUT\n re : REFERENCE TO INT;\nEND_VAR 信息： C0222：输出不能是“REFERENCE TO”类型 " }, 
{ "title" : "编译器错误 C0224 ", 
"url" : "_cds_error_c0224.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0224 ", 
"snippet" : "C0224 信息 : 调用递归: <recursion> 可能的错误原因 : 一个函数调用自己。 错误修正 : 确保函数不是递归的。 错误示例： 错误示例： PROGRAM PLC_PRG VAR END_VAR POU(); FUNCTION POU VAR END_VAR POU(); 信息： C0224：调用递归：POU -> POU...", 
"body" : "C0224 信息 : 调用递归: <recursion> 可能的错误原因 : 一个函数调用自己。 错误修正 : 确保函数不是递归的。 错误示例： 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nPOU();\n\nFUNCTION POU\nVAR\nEND_VAR\n\nPOU();\n 信息： C0224：调用递归：POU -> POU " }, 
{ "title" : "编译器错误 C0225 ", 
"url" : "_cds_error_c0225.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0225 ", 
"snippet" : "C0225 信息 : '<name>' 不是 '<name>' 的实例 可能的错误原因 : 图形编程语言中的功能块已分配有与声明类型不匹配的显式指定类型。 错误修正 : 将显式类型替换为声明部分使用的类型，或从 POU 中删除显式类型的规范。 错误示例： PROGRAM PLC_PRG VAR fbVar : MyFB; END_VAR 信息： C0225：“fbVar”不是“MyFB2”的实例 错误修正： 或者...", 
"body" : "C0225 信息 : '<name>' 不是 '<name>' 的实例 可能的错误原因 : 图形编程语言中的功能块已分配有与声明类型不匹配的显式指定类型。 错误修正 : 将显式类型替换为声明部分使用的类型，或从 POU 中删除显式类型的规范。 错误示例： PROGRAM PLC_PRG\nVAR\n fbVar : MyFB;\nEND_VAR\n 信息： C0225：“fbVar”不是“MyFB2”的实例 错误修正： 或者 " }, 
{ "title" : "编译器错误 C0227 ", 
"url" : "_cds_error_c0227.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0227 ", 
"snippet" : "C0227 信息 : 常量变量<常量名>的初始化不是常量 可能的错误原因 : 常量用变量初始化。 错误修正 : 只用常量值初始化常量。 错误示例： PROGRAM PLC_PRG VAR i : INT; END_VAR VAR CONSTANT k : INT := i; END_VAR 信息： C0227：常量变量“k”的初始化不是常量...", 
"body" : "C0227 信息 : 常量变量<常量名>的初始化不是常量 可能的错误原因 : 常量用变量初始化。 错误修正 : 只用常量值初始化常量。 错误示例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\nVAR CONSTANT\n k : INT := i;\nEND_VAR\n 信息： C0227：常量变量“k”的初始化不是常量 " }, 
{ "title" : "编译器错误 C0228 ", 
"url" : "_cds_error_c0228.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0228 ", 
"snippet" : "C0228 信息 : 常量变量“<常量名>”没有初始值 可能的错误原因 : 常量未初始化。 错误修正 : 初始化常量。 错误示例： PROGRAM PLC_PRG VAR END_VAR VAR CONSTANT k : INT; END_VAR 信息： C0228：常量变量“k”没有初始值 错误修正： k : INT := 1;...", 
"body" : "C0228 信息 : 常量变量“<常量名>”没有初始值 可能的错误原因 : 常量未初始化。 错误修正 : 初始化常量。 错误示例： PROGRAM PLC_PRG\nVAR\nEND_VAR\nVAR CONSTANT\n k : INT;\nEND_VAR\n 信息： C0228：常量变量“k”没有初始值 错误修正： k : INT := 1; " }, 
{ "title" : "编译器错误 C0230 ", 
"url" : "_cds_error_c0230.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0230 ", 
"snippet" : "C0230 信息 : 此处不应出现类型名称“<数据类型>” 可能的错误原因 : 枚举的数据类型名称在无效位置使用。 错误修正 : 检查该位置的数据类型名称是否正确使用。可能有拼写错误。 错误示例： TYPE MyEnum : ( enum_member := 0 ); END_TYPE PROGRAM PLC_PRG VAR value : INT; END_VAR value := MyEnum; MyEnum := value; 信息： 对于 PLC_PRG，错误消息发出 2 次： C0230：此处不应输入名称“MyEnum” 错误修正： value := MyEnum.enum_memb...", 
"body" : "C0230 信息 : 此处不应出现类型名称“<数据类型>” 可能的错误原因 : 枚举的数据类型名称在无效位置使用。 错误修正 : 检查该位置的数据类型名称是否正确使用。可能有拼写错误。 错误示例： TYPE MyEnum :\n(\n enum_member := 0\n);\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n value : INT;\nEND_VAR\nvalue := MyEnum;\nMyEnum := value;\n 信息： 对于 PLC_PRG，错误消息发出 2 次： C0230：此处不应输入名称“MyEnum” 错误修正： value := MyEnum.enum_member;\nMyEnum.enum_member := value; " }, 
{ "title" : "编译器错误 C0232 ", 
"url" : "_cds_error_c0232.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0232 ", 
"snippet" : "C0232 信息 ：预期数组初始化 可能的错误原因 : 一个“数组数组”被初始化，但初始化值不是嵌套的。 错误修正 ：使用嵌套数组初始化，如下例所示。 错误示例： PROGRAM PLC_PRG VAR value : ARRAY[0..2] OF ARRAY[0..2] OF INT := [1,2,3]; END_VAR 信息： C0232：预期数组初始化 错误修正： value : ARRAY[0..2] OF ARRAY[0..2] OF INT := [ [1,2,3], [4,5,6], [7,8,9]];...", 
"body" : "C0232 信息 ：预期数组初始化 可能的错误原因 : 一个“数组数组”被初始化，但初始化值不是嵌套的。 错误修正 ：使用嵌套数组初始化，如下例所示。 错误示例： PROGRAM PLC_PRG\nVAR\n value : ARRAY[0..2] OF ARRAY[0..2] OF INT := [1,2,3];\nEND_VAR\n 信息： C0232：预期数组初始化 错误修正： value : ARRAY[0..2] OF ARRAY[0..2] OF INT := [\n[1,2,3],\n[4,5,6],\n[7,8,9]]; " }, 
{ "title" : "编译器错误 C0233 ", 
"url" : "_cds_error_c0233.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0233 ", 
"snippet" : "C0233 信息 : <数据类型> 的初始化列表预期 可能的错误原因 : 结构类型的数组使用不是结构初始化或变量的元素进行初始化。 错误修正 ：如下例所示，使用结构体初始化或现有变量来初始化结构体数组。 错误示例： PROGRAM PLC_PRG VAR values : ARRAY[0..2] OF COLOR := [1,2,3]; END_VAR 信息： C0233：预期颜色的初始化列表 错误修正： PROGRAM PLC_PRG VAR colorVariable : COLOR := (red:=0, green:=0, blue:=255); value : ARRAY[0..2]...", 
"body" : "C0233 信息 : <数据类型> 的初始化列表预期 可能的错误原因 : 结构类型的数组使用不是结构初始化或变量的元素进行初始化。 错误修正 ：如下例所示，使用结构体初始化或现有变量来初始化结构体数组。 错误示例： PROGRAM PLC_PRG\nVAR\n values : ARRAY[0..2] OF COLOR := [1,2,3];\nEND_VAR\n 信息： C0233：预期颜色的初始化列表 错误修正： PROGRAM PLC_PRG\nVAR\n colorVariable : COLOR := (red:=0, green:=0, blue:=255);\n value : ARRAY[0..2] OF COLOR := [\n colorVariable,\n (red:=255, green:=0, blue:=0),\n (red:=0, green:=255, blue:=0)];\nEND_VAR " }, 
{ "title" : "编译器错误 C0234 ", 
"url" : "_cds_error_c0234.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0234 ", 
"snippet" : "C0234 信息 : __QueryInterface 的第一个操作数必须是接口引用或功能块的实例 可能的错误原因 : 不正确的操作数被传递给操作员 __QueryInterface . 错误修正 ：传递接口引用或功能块的实例。 错误示例： PROGRAM PLC_PRG VAR a : INT; ITFref, ITFref2 : ITF; ITFref2 : ITF2; END_VAR __QueryInterface(a ,ITFref); INTERFACE ITF EXTENDS __SYSTEM.IQueryInterface INTERFACE ITF2 EXTENDS ITF ...", 
"body" : "C0234 信息 : __QueryInterface 的第一个操作数必须是接口引用或功能块的实例 可能的错误原因 : 不正确的操作数被传递给操作员 __QueryInterface . 错误修正 ：传递接口引用或功能块的实例。 错误示例： PROGRAM PLC_PRG\nVAR\n a : INT;\n ITFref, ITFref2 : ITF;\n ITFref2 : ITF2;\nEND_VAR\n\n__QueryInterface(a ,ITFref);\n\nINTERFACE ITF EXTENDS __SYSTEM.IQueryInterface\nINTERFACE ITF2 EXTENDS ITF\n 信息： C0234: __QueryInterface 的第一个操作数必须是接口引用或功能块的实例 错误修正： __QueryInterface(ITFref2, ITFref); " }, 
{ "title" : "编译器错误 C0235 ", 
"url" : "_cds_error_c0235.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0235 ", 
"snippet" : "C0235 信息 : __QueryInterface 的第二个操作数必须是接口引用 可能的错误原因 : 不正确的操作数被传递给操作员 __QueryInterface . 错误修正 : 传递一个接口引用。 错误示例： PROGRAM PLC_PRG VAR a : INT; ITFref, ITFref2 : ITF; ITFref2 : ITF2; END_VAR __QueryInterface(ITFref2, a); INTERFACE ITF EXTENDS __SYSTEM.IQueryInterface INTERFACE ITF2 EXTENDS ITF 信息： C0235:...", 
"body" : "C0235 信息 : __QueryInterface 的第二个操作数必须是接口引用 可能的错误原因 : 不正确的操作数被传递给操作员 __QueryInterface . 错误修正 : 传递一个接口引用。 错误示例： PROGRAM PLC_PRG\nVAR\n a : INT;\n ITFref, ITFref2 : ITF;\n ITFref2 : ITF2;\nEND_VAR\n\n__QueryInterface(ITFref2, a);\n\nINTERFACE ITF EXTENDS __SYSTEM.IQueryInterface\nINTERFACE ITF2 EXTENDS ITF\n 信息： C0235: __QueryInterface 的第二个操作数必须是接口引用 错误修正： __QueryInterface(ITFref2, ITFref); " }, 
{ "title" : "编译器错误 C0236 ", 
"url" : "_cds_error_c0236.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0236 ", 
"snippet" : "C0236 信息 : VAR_EXTERNAL <变量名> 的类型定义错误 可能的错误原因 : 变量声明在 VAR_GLOBAL \/ VAR_EXTERNAL 作为不同的类型。 错误修正 : 使用相同的类型定义 VAR_GLOBAL 和 VAR_EXTERNAL . 错误示例： PROGRAM PLC_PRG VAR_EXTERNAL ig : STRING; END_VAR VAR_GLOBAL ig : INT; END_VAR 信息： C0236: VAR_EXTERNAL ig 的类型定义错误...", 
"body" : "C0236 信息 : VAR_EXTERNAL <变量名> 的类型定义错误 可能的错误原因 : 变量声明在 VAR_GLOBAL \/ VAR_EXTERNAL 作为不同的类型。 错误修正 : 使用相同的类型定义 VAR_GLOBAL 和 VAR_EXTERNAL . 错误示例： PROGRAM PLC_PRG\nVAR_EXTERNAL\n ig : STRING;\nEND_VAR\n\nVAR_GLOBAL\n ig : INT;\nEND_VAR\n 信息： C0236: VAR_EXTERNAL ig 的类型定义错误 " }, 
{ "title" : "编译器错误 C0237 ", 
"url" : "_cds_error_c0237.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0237 ", 
"snippet" : "C0237 信息 : 找不到 VAR_EXTERNAL '<变量名>' 的全局定义 可能的错误原因 : 试图在 VAR_EXTERNAL 不存在于 VAR_GLOBAL . 错误修正 ：确保标识符匹配。 错误示例： PROGRAM PLC_PRG VAR_EXTERNAL i : INT; END_VAR VAR_GLOBAL ig : INT; END_VAR 信息： C0237: 没有找到 VAR_EXTERNAL 'i' 的全局定义...", 
"body" : "C0237 信息 : 找不到 VAR_EXTERNAL '<变量名>' 的全局定义 可能的错误原因 : 试图在 VAR_EXTERNAL 不存在于 VAR_GLOBAL . 错误修正 ：确保标识符匹配。 错误示例： PROGRAM PLC_PRG\nVAR_EXTERNAL\n i : INT;\nEND_VAR\n\nVAR_GLOBAL\n ig : INT;\nEND_VAR\n 信息： C0237: 没有找到 VAR_EXTERNAL 'i' 的全局定义 " }, 
{ "title" : "编译器错误 C0238 ", 
"url" : "_cds_error_c0238.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0238 ", 
"snippet" : "C0238 信息 : VAR_EXTERNAL <变量名> 不允许有初始值 可能的错误原因 : 试图初始化一个变量 VAR_EXTERNAL . 错误修正 : 不要初始化变量 VAR_EXTERNAL . 错误示例： PROGRAM PLC_PRG VAR_EXTERNAL ig : INT := 2; END_VAR VAR_GLOBAL ig : INT; END_VAR 信息： C0238: VAR_EXTERNAL ig 不允许有初始值...", 
"body" : "C0238 信息 : VAR_EXTERNAL <变量名> 不允许有初始值 可能的错误原因 : 试图初始化一个变量 VAR_EXTERNAL . 错误修正 : 不要初始化变量 VAR_EXTERNAL . 错误示例： PROGRAM PLC_PRG\nVAR_EXTERNAL\n ig : INT := 2;\nEND_VAR\n\nVAR_GLOBAL\n ig : INT;\nEND_VAR\n 信息： C0238: VAR_EXTERNAL ig 不允许有初始值 " }, 
{ "title" : "编译器错误 C0239 ", 
"url" : "_cds_error_c0239.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0239 ", 
"snippet" : "C0239 信息 : 接口 <接口名称 1> 不扩展 <接口名称 2> 可能的错误原因 : 使用的接口不扩展另一个接口。 错误修正 : 扩展接口。 错误示例： PROGRAM PLC_PRG VAR ITFref : ITF; ITFref2 : ITF2; END_VAR __QueryInterface(ITFref2,ITFref); INTERFACE ITF INTERFACE ITF2 EXTENDS ITF 信息： C0239：接口 ITF 不扩展 __System.IQueryInterface 错误修正： INTERFACE ITF EXTENDS __System.IQue...", 
"body" : "C0239 信息 : 接口 <接口名称 1> 不扩展 <接口名称 2> 可能的错误原因 : 使用的接口不扩展另一个接口。 错误修正 : 扩展接口。 错误示例： PROGRAM PLC_PRG\nVAR\n ITFref : ITF;\n ITFref2 : ITF2;\nEND_VAR\n\n__QueryInterface(ITFref2,ITFref);\n\nINTERFACE ITF\nINTERFACE ITF2 EXTENDS ITF\n 信息： C0239：接口 ITF 不扩展 __System.IQueryInterface 错误修正： INTERFACE ITF EXTENDS __System.IQueryInterface " }, 
{ "title" : "编译器错误 C0240 ", 
"url" : "_cds_error_c0240.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0240 ", 
"snippet" : "C0240 信息 : __QueryPointer 的第一个操作数必须是接口引用或功能块的实例 可能的错误原因 : 不正确的操作数被传递给操作员 __QueryPointer . 错误修正 ：传递接口引用或功能块的实例。 错误示例： PROGRAM PLC_PRG VAR a : INT; ITFref : ITF; pt : POINTER TO FB; END_VAR __QueryPointer(a,pt); 信息： C0240：__QueryPointer 的第一个操作数必须是接口引用或功能块的实例 错误修正： __QueryPointer (ITFref, pt);...", 
"body" : "C0240 信息 : __QueryPointer 的第一个操作数必须是接口引用或功能块的实例 可能的错误原因 : 不正确的操作数被传递给操作员 __QueryPointer . 错误修正 ：传递接口引用或功能块的实例。 错误示例： PROGRAM PLC_PRG\nVAR\n a : INT;\n ITFref : ITF;\n pt : POINTER TO FB;\nEND_VAR\n\n__QueryPointer(a,pt);\n 信息： C0240：__QueryPointer 的第一个操作数必须是接口引用或功能块的实例 错误修正： __QueryPointer (ITFref, pt); " }, 
{ "title" : "编译器错误 C0241 ", 
"url" : "_cds_error_c0241.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0241 ", 
"snippet" : "C0241 信息 : __QueryPointer 的第二个操作数必须是指针 可能的错误原因 : 不正确的操作数被传递给操作员 __QueryPointer . 错误修正 : 传递一个指针。 错误示例： PROGRAM PLC_PRG VAR b : INT; ITFref : ITF; pt : POINTER TO FB; END_VAR __QueryPointer(ITFref,b); INTERFACE ITF EXTENDS __System.IQueryInterface 信息： C0241: __QueryPointer 的第二个操作数必须是指针 错误修正： __QueryPo...", 
"body" : "C0241 信息 : __QueryPointer 的第二个操作数必须是指针 可能的错误原因 : 不正确的操作数被传递给操作员 __QueryPointer . 错误修正 : 传递一个指针。 错误示例： PROGRAM PLC_PRG\nVAR\n b : INT;\n ITFref : ITF;\n pt : POINTER TO FB;\nEND_VAR\n\n__QueryPointer(ITFref,b);\n\nINTERFACE ITF EXTENDS __System.IQueryInterface\n 信息： C0241: __QueryPointer 的第二个操作数必须是指针 错误修正： __QueryPointer (ITFref, pt); " }, 
{ "title" : "编译器错误 C0242 ", 
"url" : "_cds_error_c0242.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0242 ", 
"snippet" : "C0242 信息 : __DELETE 的操作数必须是指针 可能的错误原因 : 一个不正确的操作数被传递给操作员 __DELETE . 错误修正 : 传递一个指针。 错误示例： PROGRAM PLC_PRG VAR a : INT; pt : POINTER TO INT; END_VAR __DELETE(a); 信息： C0242: __DELETE 的操作数必须是指针 错误修正： __DELETE (pt);...", 
"body" : "C0242 信息 : __DELETE 的操作数必须是指针 可能的错误原因 : 一个不正确的操作数被传递给操作员 __DELETE . 错误修正 : 传递一个指针。 错误示例： PROGRAM PLC_PRG\nVAR\n a : INT;\n pt : POINTER TO INT;\nEND_VAR\n\n__DELETE(a);\n 信息： C0242: __DELETE 的操作数必须是指针 错误修正： __DELETE (pt); " }, 
{ "title" : "编译器错误 C0243 ", 
"url" : "_cds_error_c0243.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0243 ", 
"snippet" : "C0243 信息 : 签名中使用的名称与对象名称不同 可能的错误原因 ：对象名称与代码中使用的名称不同。 错误修正 : 确保名称相同。 错误示例：...", 
"body" : "C0243 信息 : 签名中使用的名称与对象名称不同 可能的错误原因 ：对象名称与代码中使用的名称不同。 错误修正 : 确保名称相同。 错误示例： " }, 
{ "title" : "编译器警告 C0266 ", 
"url" : "_cds_error_c0266.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0266 ", 
"snippet" : "C0266 信息 : 循环退出条件 <condition>' 恒为 FALSE . 可能是无尽循环。 可能的错误原因 : 在一个 FOR 循环，迭代发生在控制变量的整个值范围内。 错误更正 : 根据 IEC 61131 标准，其中的声明 FOR 只有当控制变量的值超过最终值时，才会执行循环。因此，为控制变量使用足够大的类型，该类型可以映射最终值+1 警告示例 PROGRAM PLC_PRG VAR       b : BYTE;       i : INT; END_VAR FOR b := 0 TO 255 BY 1 DO       i := i + 1; END_FOR; 留言 C026...", 
"body" : "C0266 信息 : 循环退出条件 <condition>' 恒为 FALSE . 可能是无尽循环。 可能的错误原因 : 在一个 FOR 循环，迭代发生在控制变量的整个值范围内。 错误更正 : 根据 IEC 61131 标准，其中的声明 FOR 只有当控制变量的值超过最终值时，才会执行循环。因此，为控制变量使用足够大的类型，该类型可以映射最终值+1 警告示例 PROGRAM PLC_PRG\nVAR\n      b : BYTE;\n      i : INT;\nEND_VAR\nFOR b := 0 TO 255 BY 1 DO\n      i := i + 1;\nEND_FOR;\n 留言 C0266：循环退出条件 “b > 255” 常量为 FALSE。可以无限循环。 " }, 
{ "title" : "编译器警告 C0269 ", 
"url" : "_cds_error_c0269.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0269 ", 
"snippet" : "C0269 信息 ：<pointer dereferencing> 指向的实例将重新初始化以进行虚拟函数调用。确保 <pointer dereferencing> 不指向从 <base FB> 派生的类型。 可能的错误原因 ：将派生功能块的地址作为基功能块的地址。 警告示例 FUNCTION_BLOCK FBBase ... FUNCTION_BLOCK FBDerived EXTENDS FBBase ... FUNCTION_BLOCK FB EXTENDS Base_FB ... PROGRAM PLC_PRG VAR       pinst : POINTER TO FBBase;  ...", 
"body" : "C0269 信息 ：<pointer dereferencing> 指向的实例将重新初始化以进行虚拟函数调用。确保 <pointer dereferencing> 不指向从 <base FB> 派生的类型。 可能的错误原因 ：将派生功能块的地址作为基功能块的地址。 警告示例 FUNCTION_BLOCK FBBase\n...\n\nFUNCTION_BLOCK FBDerived EXTENDS FBBase\n...\n\nFUNCTION_BLOCK FB EXTENDS Base_FB\n...\nPROGRAM PLC_PRG\nVAR\n      pinst : POINTER TO FBBase;\n      inst2_2 : FBDerived;\nEND_VAR\npinst := ADR(inst2_2);\npinst^ := inst2_2;\n 指针取消引用会产生以下警告。 信息： C0269: pinst^ 指向的实例将重新初始化以进行虚拟函数调用。确保 pinst^ 不指向从 FBBase 派生的类型。 ： " }, 
{ "title" : "编译器警告 C0298 ", 
"url" : "_cds_error_c0298.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0298 ", 
"snippet" : "C0298 信息 ：由于从“<递归方法名称>”开始的递归调用，堆栈使用量的计算不完整。 可能的原因 ：对于具有递归调用的方法，无法成功执行堆栈检查，因为无法确定堆栈的使用情况。 纠错 ： 使用 estimated-stack-usage 属性为方法提供堆栈大小要求的估计值（以字节为单位）。 错误示例： METHOD PUBLIC m_Recursive : UDINT VAR_INPUT uiN : UINT; END_VAR VAR END_VAR m_Recursive := 1; IF uiN > 1 THEN m_Recursive := uiN * THIS^.m_Recursive...", 
"body" : "C0298 信息 ：由于从“<递归方法名称>”开始的递归调用，堆栈使用量的计算不完整。 可能的原因 ：对于具有递归调用的方法，无法成功执行堆栈检查，因为无法确定堆栈的使用情况。 纠错 ： 使用 estimated-stack-usage 属性为方法提供堆栈大小要求的估计值（以字节为单位）。 错误示例： METHOD PUBLIC m_Recursive : UDINT\n VAR_INPUT\n uiN : UINT;\n END_VAR\n VAR\n END_VAR\n m_Recursive := 1;\n IF uiN > 1 THEN\n m_Recursive := uiN * THIS^.m_Recursive(uiN := (uiN - 1) );\n RETURN;\n ELSE\n RETURN;\n END_IF; 信息： C0298：由于从‘m_Recursive’开始的递归调用，堆栈使用量的计算不完整 纠错： {attribute 'estimated-stack-usage' := '99'} 有关详细信息，请参阅：For more information, see: estimated-stack-usage" }, 
{ "title" : "编译器警告 C0316 ", 
"url" : "_cds_error_c0316.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0316 ", 
"snippet" : "C0316 信息 : 方法“<方法名>\" 已被隐式调用 可能的错误原因 : 那个 FB_Exit 基础功能块的方法在中调用 FB_Exit 派生区块的。 错误更正 : 移除中的呼叫 FB_Exit 方法。 警告示例 FUNCTION_BLOCK Base_FB... METHOD FB_Exit: BOOL VAR_INPUT       bInCopyCode : BOOL; END_VAR FUNCTION_BLOCK FB EXTENDS Base_FB ... METHOD FB_Exit : BOOL VAR_INPUT       bInCopyCode : BOOL; END_V...", 
"body" : "C0316 信息 : 方法“<方法名>\" 已被隐式调用 可能的错误原因 : 那个 FB_Exit 基础功能块的方法在中调用 FB_Exit 派生区块的。 错误更正 : 移除中的呼叫 FB_Exit 方法。 警告示例 FUNCTION_BLOCK Base_FB...\nMETHOD FB_Exit: BOOL\nVAR_INPUT\n      bInCopyCode : BOOL;\nEND_VAR\n\nFUNCTION_BLOCK FB EXTENDS Base_FB\n...\nMETHOD FB_Exit : BOOL\nVAR_INPUT\n      bInCopyCode : BOOL;\nEND_VAR\nSUPER^.FB_Exit(bInCopyCode); \n 中的声明 FB_Exit 方法产生以下警告。 消息： C0316：方法 'fb_exit' 已被隐式调用 " }, 
{ "title" : "编译器错误 C0319 ", 
"url" : "_cds_error_c0319.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0319 ", 
"snippet" : "C0319 信息 : <> 接口库中不允许 当未遵循适用于接口库的规则时，将显示此警告。有关这些规则的详细信息，请参阅： 接口库...", 
"body" : "C0319 信息 : <> 接口库中不允许 当未遵循适用于接口库的规则时，将显示此警告。有关这些规则的详细信息，请参阅： 接口库 " }, 
{ "title" : "编译器警告 C0344 ", 
"url" : "_cds_error_c0344.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0344 ", 
"snippet" : "C0344 信息 : 属性 “<属性名>\" 不支持监控属性，该属性将被忽略 可能的错误原因 : 一个属性有监控属性 'call' 并返回一个结构。 错误更正 : 使用监控属性 'variable' 。 警告示例 TYPE ST_Test :STRUCT       a,b : INT;  END_STRUCT END_TYPE FUNCTION_BLOCK FB_Test ... {attribute 'monitoring' := 'call'} PROPERTY TestProp : ST_Test 财产申报 TestProp 产生以下警告。 消息： C0344：属性 “TestProp”...", 
"body" : "C0344 信息 : 属性 “<属性名>\" 不支持监控属性，该属性将被忽略 可能的错误原因 : 一个属性有监控属性 'call' 并返回一个结构。 错误更正 : 使用监控属性 'variable' 。 警告示例 TYPE ST_Test :STRUCT\n      a,b : INT;  \nEND_STRUCT\nEND_TYPE\n\nFUNCTION_BLOCK FB_Test\n...\n\n{attribute 'monitoring' := 'call'}\nPROPERTY TestProp : ST_Test\n 财产申报 TestProp 产生以下警告。 消息： C0344：属性 “TestProp” 不支持监控属性，将被忽略。 " }, 
{ "title" : "编译器警告 C0351 ", 
"url" : "_cds_error_c0351.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0351 ", 
"snippet" : "C0351 信息 : 属性 <attribute name> 未知，编译器将忽略该属性 可能的错误原因 : 属性名称存在拼写错误。 错误更正 ：如果您使用的是预定义的属性，请确保该属性的拼写正确（在示例中： call_after_init ）。 警告示例 {attribute 'call_after_ini'} PROGRAM PLC_PRG VAR END_VAR 消息： C0351：属性 call_after_ini 未知，编译器将忽略...", 
"body" : "C0351 信息 : 属性 <attribute name> 未知，编译器将忽略该属性 可能的错误原因 : 属性名称存在拼写错误。 错误更正 ：如果您使用的是预定义的属性，请确保该属性的拼写正确（在示例中： call_after_init ）。 警告示例 {attribute 'call_after_ini'}\nPROGRAM PLC_PRG\nVAR\nEND_VAR\n 消息： C0351：属性 call_after_ini 未知，编译器将忽略 " }, 
{ "title" : "编译器警告 C0354 ", 
"url" : "_cds_error_c0354.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0354 ", 
"snippet" : "C0354 信息 : 一种枚举类型（<类型名 1>) 与另一种枚举类型（<类型名 2>) 的比较 可能的错误原因 ：枚举类型用于比较运算符。 错误更正 : 使用预定义的整数数据类型（例如： INT ) 而不是程序代码中的枚举类型。 将枚举变量的值复制到辅助变量中（示例： INT 变量）并在比较运算符中使用辅助变量。 警告示例 {attribute 'qualified_only'} {attribute 'strict'} TYPE ENUM1: (       enum_member1 := 0,       enum_member2 := 1 ); END_TYPE {attribute ...", 
"body" : "C0354 信息 : 一种枚举类型（<类型名 1>) 与另一种枚举类型（<类型名 2>) 的比较 可能的错误原因 ：枚举类型用于比较运算符。 错误更正 : 使用预定义的整数数据类型（例如： INT ) 而不是程序代码中的枚举类型。 将枚举变量的值复制到辅助变量中（示例： INT 变量）并在比较运算符中使用辅助变量。 警告示例 {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE ENUM1:\n(\n      enum_member1 := 0,\n      enum_member2 := 1\n);\nEND_TYPE\n\n{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE ENUM2:\n(\n      enum_member := 0\n);\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n      enum1 : ENUM1;\n      enum2 : ENUM2;\n      i:INT;\nEND_VAR\nenum1 := 0;\nenum2 := 0;\nIF enum1 > enum2 THEN\n      i := 1;\nEND_IF;\n 这个 IF 语句生成以下警告。 消息： C0354：一种枚举类型 (ENUM1) 与另一种枚举类型 (ENUM2) 的比较 " }, 
{ "title" : "编译器警告 C0355 ", 
"url" : "_cds_error_c0355.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0355 ", 
"snippet" : "C0355 留言 : 无法引用单一位。将存储对完整字节的引用。 可能的错误原因 ：尝试确定位的地址。 警告示例 FUNCTION_BLOCK FBVAR       pt : POINTER TO BOOL;       b : BIT; END_VAR pt := ADR(b); 消息： 不能引用单一位。将存储对完整字节的引用。...", 
"body" : "C0355 留言 : 无法引用单一位。将存储对完整字节的引用。 可能的错误原因 ：尝试确定位的地址。 警告示例 FUNCTION_BLOCK FBVAR\n      pt : POINTER TO BOOL;\n      b : BIT;\nEND_VAR\npt := ADR(b); 消息： 不能引用单一位。将存储对完整字节的引用。 " }, 
{ "title" : "编译器警告 C0357 ", 
"url" : "_cds_error_c0357.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0357 ", 
"snippet" : "C0357 留言 : POU '<POU 名称>' 已被标记为过时 <信息文本> 可能的错误原因 : POU 是用该属性装饰的 'obsolete' ，但它仍在程序中使用。 错误更正 : 从 POU 中移除该属性或不再使用它。 警告示例 {attribute 'obsolete':= 'datatype fb not valid!'} FUNCTION_BLOCK FB_Test PROGRAM PLC_PRG VAR       inst : FB_Test; END_VAR 变量的声明 inst 产生以下警告： 消息： C0357：POU 'fb_test' 已被标记为过时：数据类型 fb...", 
"body" : "C0357 留言 : POU '<POU 名称>' 已被标记为过时 <信息文本> 可能的错误原因 : POU 是用该属性装饰的 'obsolete' ，但它仍在程序中使用。 错误更正 : 从 POU 中移除该属性或不再使用它。 警告示例 {attribute 'obsolete':= 'datatype fb not valid!'}\nFUNCTION_BLOCK FB_Test\n\nPROGRAM PLC_PRG\nVAR\n      inst : FB_Test;\nEND_VAR 变量的声明 inst 产生以下警告： 消息： C0357：POU 'fb_test' 已被标记为过时：数据类型 fb 无效！ " }, 
{ "title" : "编译器警告 C0371 ", 
"url" : "_cds_error_c0371.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0371 ", 
"snippet" : "C0371 留言 : 从外部上下文 “<POU 名称>\" 访问 \"<功能块名称>\" 中声明的 VAR_IN_OUT '< 变量名称>' 可能的错误原因 : VAR_IN_OUT POU 中的一个 POU 是通过 POU 的方法访问的。 错误更正 : 要么更改变量的声明，要么删除赋值。 警告示例 FUNCTION_BLOCK FB_Test VAR_IN_OUT       bInOut : BOOL; END_VAR METHOD METH: BOOL VAR       bBool : BOOL; END_VAR bInOut := bBool; 该方法中的赋值会产生以下警告。 消息： C0...", 
"body" : "C0371 留言 : 从外部上下文 “<POU 名称>\" 访问 \"<功能块名称>\" 中声明的 VAR_IN_OUT '< 变量名称>' 可能的错误原因 : VAR_IN_OUT POU 中的一个 POU 是通过 POU 的方法访问的。 错误更正 : 要么更改变量的声明，要么删除赋值。 警告示例 FUNCTION_BLOCK FB_Test\nVAR_IN_OUT\n      bInOut : BOOL;\nEND_VAR\n\nMETHOD METH: BOOL\nVAR\n      bBool : BOOL;\nEND_VAR\nbInOut := bBool; 该方法中的赋值会产生以下警告。 消息： C0371：从外部上下文 “METH” 访问在 “FB_TEST” 中声明的 VAR_IN_OUT “binOUT” " }, 
{ "title" : "编译器警告 C0373 ", 
"url" : "_cds_error_c0373.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0373 ", 
"snippet" : "C0373 留言 : 显示在程序代码中定义的自定义消息 warning pragma。 示例 PROGRAM PLC_PRG VAR END_VAR {warning 'This is a warning'} 这个编译指示会产生以下警告： C0373: This is a warning 有关更多信息，请参阅： 消息编译指示...", 
"body" : "C0373 留言 : 显示在程序代码中定义的自定义消息 warning pragma。 示例 PROGRAM PLC_PRG\nVAR\nEND_VAR\n{warning 'This is a warning'} 这个编译指示会产生以下警告： C0373: This is a warning 有关更多信息，请参阅： 消息编译指示" }, 
{ "title" : "编译器错误 C0380 ", 
"url" : "_cds_error_c0380.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0380 ", 
"snippet" : "C0380 信息 ：运算符 LOWER_BOUND 和 UPPER_BOUND 仅支持可变长度的数组。 可能的错误原因 : 两个运算符 LOWER_BOUND 或 UPPER_BOUND 之一不用于可变长度数组。 错误修正 ：仅对可变长度数组使用运算符 LOWER_BOUND 和 UPPER_BOUND。 对于编译器版本 3.5.14.0 及更高版本，运算符也可用于静态数组。因此，错误 C0380 仅发生在早期编译器版本的情况下。 错误示例： FUNCTION_BLOCK POU VAR_IN_OUT arrin : ARRAY [*] OF INT; END_VAR VAR arrtest ...", 
"body" : "C0380 信息 ：运算符 LOWER_BOUND 和 UPPER_BOUND 仅支持可变长度的数组。 可能的错误原因 : 两个运算符 LOWER_BOUND 或 UPPER_BOUND 之一不用于可变长度数组。 错误修正 ：仅对可变长度数组使用运算符 LOWER_BOUND 和 UPPER_BOUND。 对于编译器版本 3.5.14.0 及更高版本，运算符也可用于静态数组。因此，错误 C0380 仅发生在早期编译器版本的情况下。 错误示例： FUNCTION_BLOCK POU\nVAR_IN_OUT\n arrin : ARRAY [*] OF INT;\nEND_VAR\nVAR\n arrtest : ARRAY [0..5] OF INT;\n test1: DINT;\n test2: DINT;\nEND_VAR\n\ntest1 := UPPER_BOUND(arrin, 1);\ntest2 := UPPER_BOUND(arrtest, 1);\n 信息： C0380：运算符 LOWER_BOUND 和 UPPER_BOUND 仅支持可变长度数组。 " }, 
{ "title" : "编译器错误 C0398 ", 
"url" : "_cds_error_c0398.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0398 ", 
"snippet" : "C0398 信息 : 开发系统没有足够的内存来处理在线更改。请先重新启动应用程序，然后再继续开发。 可能的错误原因 ：开发计算机上没有足够的内存可供编译器使用。 纠错 ：使用64位版本 CODESYS 作为开发环境或大大减少您的大小 CODESYS 项目。...", 
"body" : "C0398 信息 : 开发系统没有足够的内存来处理在线更改。请先重新启动应用程序，然后再继续开发。 可能的错误原因 ：开发计算机上没有足够的内存可供编译器使用。 纠错 ：使用64位版本 CODESYS 作为开发环境或大大减少您的大小 CODESYS 项目。 " }, 
{ "title" : "编译器警告 C0406 ", 
"url" : "_cds_error_c0406.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0406 ", 
"snippet" : "C0406 留言 : 隐式检查函数 “<name of check function>” 被另一个变量或函数隐藏。不会进行检查！解决冲突并清理应用程序以使用检查功能。 可能的错误原因 : POU 的方法与隐式检查函数同名。 错误更正 ：重命名该方法或删除隐式检查函数。 警告示例 \/\/ Automatically generated code: Do not edit FUNCTION CheckBounds: DINT VAR_INPUT       index, lower, upper:DINT; END_VAR FUNCTION_BLOCK TestFB VAR       a:ARRA...", 
"body" : "C0406 留言 : 隐式检查函数 “<name of check function>” 被另一个变量或函数隐藏。不会进行检查！解决冲突并清理应用程序以使用检查功能。 可能的错误原因 : POU 的方法与隐式检查函数同名。 错误更正 ：重命名该方法或删除隐式检查函数。 警告示例 \/\/ Automatically generated code: Do not edit\nFUNCTION CheckBounds: DINT\nVAR_INPUT\n      index, lower, upper:DINT;\nEND_VAR\n\nFUNCTION_BLOCK TestFB\nVAR\n      a:ARRAY [0..1] OF INT;\n      i : INT;\nEND_VAR\na[i] := i;\n\nMETHOD CheckBounds:DINT\nVAR_INPUT\n      index, lower, upper : DINT;\nEND_VAR 中的阵列访问权限 TestFB 功能块产生以下警告。 消息： C0406：隐式检查函数 “CHECKBOUNDS” 被另一个变量或函数隐藏。不会进行检查！解决冲突并清理应用程序以使用检查功能。 " }, 
{ "title" : "编译器错误 C0415 ", 
"url" : "_cds_error_c0415.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0415 ", 
"snippet" : "C0415 一般来说，只有在绝对必要时才应使用持久变量。 信息 ：持久内存不足。变量“<变量名称>”，<count> 字节（最大连续内存间隙 <size>）。编辑持久变量列表可能会产生碎片内存。执行“声明、重新排序列表和清除间隙”命令以压缩持久变量列表。 可能的错误原因 ：开发计算机上没有足够的内存供编译器使用。 持久性内存用于保存下载后应保留其值的变量。这仅在变量类型不变的情况下才有效。因此，应尽可能少地将具有复杂数据类型（例如结构或结构数组）的变量映射到持久区域中。当此类变量发生变化时，持久数据中可能会出现较大的间隙，从而导致此错误。 错误更正 ：以下操作可以修复错误。运行 重新排序列表并...", 
"body" : "C0415 一般来说，只有在绝对必要时才应使用持久变量。 信息 ：持久内存不足。变量“<变量名称>”，<count> 字节（最大连续内存间隙 <size>）。编辑持久变量列表可能会产生碎片内存。执行“声明、重新排序列表和清除间隙”命令以压缩持久变量列表。 可能的错误原因 ：开发计算机上没有足够的内存供编译器使用。 持久性内存用于保存下载后应保留其值的变量。这仅在变量类型不变的情况下才有效。因此，应尽可能少地将具有复杂数据类型（例如结构或结构数组）的变量映射到持久区域中。当此类变量发生变化时，持久数据中可能会出现较大的间隙，从而导致此错误。 错误更正 ：以下操作可以修复错误。运行 重新排序列表并清除空白 命令重新排序持久变量并重新分配内存。然后应重新初始化持久变量。如果您想避免这样做，则可以运行 将当前值保存至配方 命令获取当前值。新下载后，您可以运行 从配方恢复值 命令来恢复值。 有关详细信息，请参阅：命令 重新排序列表并清理空白， 命令 从配方中恢复值" }, 
{ "title" : "编译器警告 C0421 ", 
"url" : "_cds_error_c0421.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0421 ", 
"snippet" : "C0421 留言 : 使用关键字 EXTENDS 用于继承接口，而不是 IMPLEMENTS 可能的错误原因 : 一个接口扩展了另一个接口，但使用 IMPLEMENTS 关键字。 错误更正 : 替换 IMPLEMENTS 关键字带有 EXTENDS 关键字。 警告示例 INTERFACE ITF INTERFACE ITF_1 IMPLEMENTS ITF 接口的声明 ITF_1 产生以下警告。 消息： C0421：使用关键字 EXTENS 来继承接口，而不是 IMPLEMENTS...", 
"body" : "C0421 留言 : 使用关键字 EXTENDS 用于继承接口，而不是 IMPLEMENTS 可能的错误原因 : 一个接口扩展了另一个接口，但使用 IMPLEMENTS 关键字。 错误更正 : 替换 IMPLEMENTS 关键字带有 EXTENDS 关键字。 警告示例 INTERFACE ITF\n\nINTERFACE ITF_1 IMPLEMENTS ITF\n 接口的声明 ITF_1 产生以下警告。 消息： C0421：使用关键字 EXTENS 来继承接口，而不是 IMPLEMENTS " }, 
{ "title" : "编译器警告 C0426 ", 
"url" : "_cds_error_c0426.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0426 ", 
"snippet" : "C0426 留言 : 预计至少会有一份声明 可能的错误原因 : A CASE 语句包含一个空的 CASE 标签。 错误更正 : 移除空白 CASE 为此添加标签或添加语句 CASE 标签。 警告示例 PROGRAM PLC_PRG VAR       nVar:INT; END_VAR CASE nVar OF       1:       2:          nVar := nVar + 1; END_CASE 这个 CASE 标签会生成以下警告。 消息： C0426：预计至少会有一份声明...", 
"body" : "C0426 留言 : 预计至少会有一份声明 可能的错误原因 : A CASE 语句包含一个空的 CASE 标签。 错误更正 : 移除空白 CASE 为此添加标签或添加语句 CASE 标签。 警告示例 PROGRAM PLC_PRG\nVAR\n      nVar:INT;\nEND_VAR\n\nCASE nVar OF\n      1:\n      2:\n         nVar := nVar + 1;\nEND_CASE\n 这个 CASE 标签会生成以下警告。 消息： C0426：预计至少会有一份声明 " }, 
{ "title" : "编译器警告 C0441 ", 
"url" : "_cds_error_c0441.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0441 ", 
"snippet" : "C0441 留言 : 访问未初始化 VAR_IN_OUT 变量 可能的错误原因 : A VAR_IN_OUT 变量用作另一个变量声明的初始值。 错误更正 ：删除初始值并将该值分配给实现部分中的变量。 警告示例 FUNCTION_BLOCK POU VAR_INPUT       i:INT; END_VAR VAR_OUTPUT       b:BOOL := a[i]; END_VAR VAR_IN_OUT       a:ARRAY [1..5] OF BOOL; END_VAR 变量的初始值 b 产生以下警告。 消息： C0441：访问未初始化的 VAR_IN_OUT 变量...", 
"body" : "C0441 留言 : 访问未初始化 VAR_IN_OUT 变量 可能的错误原因 : A VAR_IN_OUT 变量用作另一个变量声明的初始值。 错误更正 ：删除初始值并将该值分配给实现部分中的变量。 警告示例 FUNCTION_BLOCK POU\nVAR_INPUT\n      i:INT;\nEND_VAR\nVAR_OUTPUT\n      b:BOOL := a[i];\nEND_VAR\nVAR_IN_OUT\n      a:ARRAY [1..5] OF BOOL;\nEND_VAR\n 变量的初始值 b 产生以下警告。 消息： C0441：访问未初始化的 VAR_IN_OUT 变量 " }, 
{ "title" : "编译器警告 C0508 ", 
"url" : "_cds_error_c0508.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0508 ", 
"snippet" : "C0508 留言 : 名称“<标识符>\" 标识符 可能的错误原因 ：程序的局部变量与该程序的操作同名。 错误更正 :更改局部变量的名称。 警告示例 FUNCTION_BLOCK FBRead_Var VAR_INPUT END_VAR ... PROGRAM PLC_PRG VAR     read_input : FBRead_Var; END_VAR read_input(); \/\/ Call of the action read_input 变量的声明 read_input 产生以下警告。 消息： C0508：名称 “READ_INPUT” 的用法不明确...", 
"body" : "C0508 留言 : 名称“<标识符>\" 标识符 可能的错误原因 ：程序的局部变量与该程序的操作同名。 错误更正 :更改局部变量的名称。 警告示例 FUNCTION_BLOCK FBRead_Var\nVAR_INPUT\nEND_VAR\n...\n\nPROGRAM PLC_PRG\nVAR\n    read_input : FBRead_Var;\nEND_VAR\nread_input(); \/\/ Call of the action read_input 变量的声明 read_input 产生以下警告。 消息： C0508：名称 “READ_INPUT” 的用法不明确 " }, 
{ "title" : "编译器错误 C0509 ", 
"url" : "_cds_error_c0509.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0509 ", 
"snippet" : "C0509 信息 : 不允许对运算符“__New”进行多次赋值 可能的错误原因 ：在一行代码中，赋值运算符“ := \" 被多次调用 __New 操作员。 错误修正 : 用 __New 运算符在单独的代码行中为每个指向动态分配的内存的指针。 错误示例： PROGRAM PLC_PRG VAR pbAlpha : POINTER TO BYTE; \/\/ Typed pointer to Alpha pbBeta: POINTER TO BYTE; \/\/ Typed pointer to Beta xInit : BOOL := TRUE; xDelete : BOOL; END_VAR IF (x...", 
"body" : "C0509 信息 : 不允许对运算符“__New”进行多次赋值 可能的错误原因 ：在一行代码中，赋值运算符“ := \" 被多次调用 __New 操作员。 错误修正 : 用 __New 运算符在单独的代码行中为每个指向动态分配的内存的指针。 错误示例： PROGRAM PLC_PRG\nVAR\n pbAlpha : POINTER TO BYTE; \/\/ Typed pointer to Alpha\n pbBeta: POINTER TO BYTE; \/\/ Typed pointer to Beta\n xInit : BOOL := TRUE;\n xDelete : BOOL;\nEND_VAR\n\nIF (xInit) THEN\n pbBeta := pbAlpha := __NEW(BYTE); \/\/ Incorrect code for memory allocation\nEND_IF\n\npbBeta := pbAlpha := 16#01;\n\nIF (xDelete) THEN\n __DELETE(pbAlpha); \/\/ Frees memory of pointer\nEND_IF\n 信息： C0509: 不允许对操作员 '__NEW' 进行多次分配 错误修正： PROGRAM PLC_PRG\nVAR\n pbAlpha : POINTER TO BYTE; \/\/ Pointer to Alpha\n pbBeta: POINTER TO BYTE; \/\/ Pointer to Beta\n xInit : BOOL := TRUE;\n xDelete : BOOL;\nEND_VAR\n\nIF (xInit) THEN\n pbAlpha := __NEW(BYTE); \/\/ Allocates memory for Alpha\n pbBeta := __NEW(BYTE); \/\/ Allocates memory for Beta\nEND_IF\n\npbBeta := pbAlpha := 16#01; \/\/ Multiple assignment\n\nIF (xDelete) THEN\n __DELETE(pbAlpha); \/\/ Frees memory of pointer\nEND_IF 有关更多信息，请参阅： __NEW" }, 
{ "title" : "编译器错误 C0511 ", 
"url" : "_cds_error_c0511.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0511 ", 
"snippet" : "C0511 信息 : 功能块“<功能块名称>”是抽象的，不能用作分配的目标。 可能的错误原因 : 一个值被分配给一个抽象功能块。具体功能块可能有不同的类型，因此无法复制。 错误修正 ：为了复制功能块的数据，必须使用具体的功能块。 错误示例： PROGRAM PLC_PRG VAR refAbstract1 : REFERENCE TO AbstractPOU; refAbstract2 : REFERENCE TO AbstractPOU; END_VAR refAbstract1 := refAbstract2; 信息： C0511：功能块“refAbstract1”是抽象的，不能用作分配的...", 
"body" : "C0511 信息 : 功能块“<功能块名称>”是抽象的，不能用作分配的目标。 可能的错误原因 : 一个值被分配给一个抽象功能块。具体功能块可能有不同的类型，因此无法复制。 错误修正 ：为了复制功能块的数据，必须使用具体的功能块。 错误示例： PROGRAM PLC_PRG\nVAR\nrefAbstract1 : REFERENCE TO AbstractPOU;\nrefAbstract2 : REFERENCE TO AbstractPOU;\nEND_VAR\n\nrefAbstract1 := refAbstract2;\n 信息： C0511：功能块“refAbstract1”是抽象的，不能用作分配的目标。 错误修正： 使用参考分配 REF= 分配参考 refAbstract1 到相同的功能块 refAbstract2 . " }, 
{ "title" : "编译器警告 C0513 ", 
"url" : "_cds_error_c0513.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0513 ", 
"snippet" : "C0513 留言 : 不应访问私有属性 <POU 名称> <属性名称> 可能的错误原因 : POU 的财产，其可见性仅限于 POU 和 PRIVATE 关键字，可从 POU 外部访问。 错误更正 : 更改属性的可见性（例如，移除 PRIVATE 关键字）或更改变量的声明。 警告示例 FUNCTION_BLOCK POU VAR_INPUT END_VAR ... PROPERTY PRIVATE Prop : UDINT PROGRAM PLC_PRG VAR       p:POU := STRUCT(Prop := 7); END_VAR 变量的声明 p 产生以下警告。 消息： C0513...", 
"body" : "C0513 留言 : 不应访问私有属性 <POU 名称> <属性名称> 可能的错误原因 : POU 的财产，其可见性仅限于 POU 和 PRIVATE 关键字，可从 POU 外部访问。 错误更正 : 更改属性的可见性（例如，移除 PRIVATE 关键字）或更改变量的声明。 警告示例 FUNCTION_BLOCK POU\nVAR_INPUT\nEND_VAR\n...\n\nPROPERTY PRIVATE Prop : UDINT\n\nPROGRAM\nPLC_PRG\nVAR\n      p:POU := STRUCT(Prop := 7);\nEND_VAR 变量的声明 p 产生以下警告。 消息： C0513：不应访问私有财产 POU 提案 " }, 
{ "title" : "编译器警告 C0514 ", 
"url" : "_cds_error_c0514.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0514 ", 
"snippet" : "C0514 留言 : 不应访问库 <library name> 的内部属性 <POU name>.<property name> 可能的错误原因 : 一个库包含一个带有属性的 POU，其可见性仅限于具有该属性的库 INTERNAL 关键字。该属性可从该库外部访问。 错误更正 : 更改属性的可见性（例如，移除 INTERNAL 关键字）或更改变量的声明。 警告示例 PROGRAM PLC_PRG VAR       p1: MyLib.POU;       somevar1 :INT := p1.Prop; END_VAR 变量的声明 somevar1 产生以下警告： 消息： C0514：不应访...", 
"body" : "C0514 留言 : 不应访问库 <library name> 的内部属性 <POU name>.<property name> 可能的错误原因 : 一个库包含一个带有属性的 POU，其可见性仅限于具有该属性的库 INTERNAL 关键字。该属性可从该库外部访问。 错误更正 : 更改属性的可见性（例如，移除 INTERNAL 关键字）或更改变量的声明。 警告示例 PROGRAM PLC_PRG\nVAR\n      p1: MyLib.POU;\n      somevar1 :INT := p1.Prop;\nEND_VAR 变量的声明 somevar1 产生以下警告： 消息： C0514：不应访问库 myLib 的内部属性 pou.prop，1.0.0.0 (myCompany) " }, 
{ "title" : "编译器警告 C0515 ", 
"url" : "_cds_error_c0515.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0515 ", 
"snippet" : "C0515 留言 : 不应访问受保护的 <POU 名称>.<属性名称> 可能的错误原因 : POU 的财产，其可见性受限 PROTECTED 关键字，可从 POU 或其继承层次结构外部访问。 错误更正 : 更改属性的可见性（例如，移除 PROTECTED 关键字）或更改变量的声明。 警告示例 FUNCTION_BLOCK POU VAR_INPUT END_VAR ... PROPERTY PROTECTED Prop : UDINT PROGRAM PLC_PRG VAR       p:POU := STRUCT(Prop := 7); END_VAR 变量的声明 p 产生以下警告： 消息...", 
"body" : "C0515 留言 : 不应访问受保护的 <POU 名称>.<属性名称> 可能的错误原因 : POU 的财产，其可见性受限 PROTECTED 关键字，可从 POU 或其继承层次结构外部访问。 错误更正 : 更改属性的可见性（例如，移除 PROTECTED 关键字）或更改变量的声明。 警告示例 FUNCTION_BLOCK POU\nVAR_INPUT\nEND_VAR\n...\n\nPROPERTY PROTECTED Prop : UDINT\n\nPROGRAM PLC_PRG\nVAR\n      p:POU := STRUCT(Prop := 7);\nEND_VAR 变量的声明 p 产生以下警告： 消息： C0515：不应访问受保护的属性 pou.prop " }, 
{ "title" : "编译器警告 C0516 ", 
"url" : "_cds_error_c0516.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0516 ", 
"snippet" : "C0516 留言 : 不应访问 <库名> 的 <POU 名> 内部变量 可能的错误原因 : 一个库包含一个带有变量的 POU。POU 的可见性仅限于此库 INTERNAL 关键字。该变量可从该库外部访问。 错误更正 : 更改 POU 的可见性（例如，删除 POU INTERNAL 关键字）或更改变量的声明。 警告示例 PROGRAM PLC_PRG VAR     somevar1 : INT := MyLib.GVL.p.varIn; END_VAR 变量的声明 somevar1 产生以下警告。 消息： C0516：不应访问库 myLib 的内部变量 internalpou.varin，1....", 
"body" : "C0516 留言 : 不应访问 <库名> 的 <POU 名> 内部变量 可能的错误原因 : 一个库包含一个带有变量的 POU。POU 的可见性仅限于此库 INTERNAL 关键字。该变量可从该库外部访问。 错误更正 : 更改 POU 的可见性（例如，删除 POU INTERNAL 关键字）或更改变量的声明。 警告示例 PROGRAM PLC_PRG\nVAR\n    somevar1 : INT := MyLib.GVL.p.varIn;\nEND_VAR 变量的声明 somevar1 产生以下警告。 消息： C0516：不应访问库 myLib 的内部变量 internalpou.varin，1.0.0.0 (myCompany) " }, 
{ "title" : "编译器警告 C0517 ", 
"url" : "_cds_error_c0517.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0517 ", 
"snippet" : "C0517 留言 : 不应访问 <库名> 的 < 对象名> 内部对象 可能的错误原因 : 库包含 POU，其可见性仅限于此库 INTERNAL 关键字。一个 POU SIZEOF 在此库之外使用运算符。 错误更正 : 更改 POU 的可见性（例如，删除 POU INTERNAL 关键字）或更改变量的声明。 警告示例 PROGRAM PLC_PRG VAR     somevar1 : INT := SIZEOF(MyLib.POU); END_VAR 消息： C0517：不应访问库 myLib 的内部对象 POU，1.0.0.0 (myCompany)...", 
"body" : "C0517 留言 : 不应访问 <库名> 的 < 对象名> 内部对象 可能的错误原因 : 库包含 POU，其可见性仅限于此库 INTERNAL 关键字。一个 POU SIZEOF 在此库之外使用运算符。 错误更正 : 更改 POU 的可见性（例如，删除 POU INTERNAL 关键字）或更改变量的声明。 警告示例 PROGRAM PLC_PRG\nVAR\n    somevar1 : INT := SIZEOF(MyLib.POU);\nEND_VAR 消息： C0517：不应访问库 myLib 的内部对象 POU，1.0.0.0 (myCompany) " }, 
{ "title" : "编译器警告 C0525 ", 
"url" : "_cds_error_c0525.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0525 ", 
"snippet" : "C0525 留言 : 在这种情况下 <type> 类型不能有默认值 可能的错误原因 : a 的初始值 VAR_INPUT 具有自定义数据类型。 错误更正 ：移除初始值。 警告示例 FUNCTION Fun: INT VAR_INPUT       iPar : INT;       xPar : BOOL;       aInt : ARRAY [0..1] OF INT := [1, 2]; END_VAR PROGRAM PLC_PRG VAR      aInt:ARRAY [0..1] OF INT := [1, 2]; END_VAR Fun(1, TRUE, aInt); 变量的声...", 
"body" : "C0525 留言 : 在这种情况下 <type> 类型不能有默认值 可能的错误原因 : a 的初始值 VAR_INPUT 具有自定义数据类型。 错误更正 ：移除初始值。 警告示例 FUNCTION Fun: INT\nVAR_INPUT\n      iPar : INT;\n      xPar : BOOL;\n      aInt : ARRAY [0..1] OF INT := [1, 2];\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n     aInt:ARRAY [0..1] OF INT := [1, 2];\nEND_VAR\nFun(1, TRUE, aInt);\n 变量的声明 aInt 在 Fun 函数产生以下警告。 消息： C0525：在此上下文中，INT 的类型 ARRAY [0.. 1] 不能有默认值 " }, 
{ "title" : "编译器警告 C0526 ", 
"url" : "_cds_error_c0526.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0526 ", 
"snippet" : "C0526 留言 : 默认值不是常数 可能的错误原因 : a 的初始值 VAR_INPUT 不使用常量，而是函数调用的结果。 错误更正 ：使用常量作为初始值。 警告示例 FUNCTION F2: INT FUNCTION F1: INT VAR_INPUT       iPar : INT := F2();       xPar : BOOL; END_VAR 变量的声明 iPar 产生以下警告。 消息： C0526：默认值不是常数...", 
"body" : "C0526 留言 : 默认值不是常数 可能的错误原因 : a 的初始值 VAR_INPUT 不使用常量，而是函数调用的结果。 错误更正 ：使用常量作为初始值。 警告示例 FUNCTION F2: INT\n\nFUNCTION F1: INT\nVAR_INPUT\n      iPar : INT := F2();\n      xPar : BOOL;\nEND_VAR 变量的声明 iPar 产生以下警告。 消息： C0526：默认值不是常数 " }, 
{ "title" : "编译器警告 C0533 ", 
"url" : "_cds_error_c0533.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0533 ", 
"snippet" : "C0533 留言 : 的默认值 VAR_OUTPUT 不用于抽象或接口方法 可能的错误原因 : 在抽象 POU 的方法中，初始值被赋给 VAR_OUTPUT 。 对于接口方法和抽象方法，与输入处的初始值相比，输出处的初始值没有影响。 错误更正 : 移除受影响的初始值 VAR_OUTPUT 。 警告示例 FUNCTION_BLOCK ABSTRACT POU METHOD METH: BOOL VAR_INPUT       iPar : INT;       xPar : BOOL; END_VAR VAR_OUTPUT       iOut : INT;       xOut : BOOL ...", 
"body" : "C0533 留言 : 的默认值 VAR_OUTPUT 不用于抽象或接口方法 可能的错误原因 : 在抽象 POU 的方法中，初始值被赋给 VAR_OUTPUT 。 对于接口方法和抽象方法，与输入处的初始值相比，输出处的初始值没有影响。 错误更正 : 移除受影响的初始值 VAR_OUTPUT 。 警告示例 FUNCTION_BLOCK ABSTRACT POU\n\nMETHOD METH: BOOL\nVAR_INPUT\n      iPar : INT;\n      xPar : BOOL;\nEND_VAR\nVAR_OUTPUT\n      iOut : INT;\n      xOut : BOOL := TRUE;\nEND_VAR 变量的声明 xOut 产生以下警告。 消息： C0533：抽象或接口方法中不使用 VAR_OUTPUT 的默认值 " }, 
{ "title" : "编译器警告 C0540 ", 
"url" : "_cds_error_c0540.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0540 ", 
"snippet" : "C0540 留言 : POU '<POU>' 缺少属性 'no_assign' 。变量 '<variable>' 的类型属性为 'no_assign' . 可能的错误原因 : POU X 包含一个变量，其类型 (POU Y) 具有 'no_assign' 属性。POU X 没有 'no_assign' 属性。 错误更正 : 还可以用 POU 来装饰 POU 'no_assign' 属性。 警告示例 {attribute 'no_assign'} FUNCTION_BLOCK FB_NotAssignable VAR       pBool : POINTER TO BOOL; END_VAR ...", 
"body" : "C0540 留言 : POU '<POU>' 缺少属性 'no_assign' 。变量 '<variable>' 的类型属性为 'no_assign' . 可能的错误原因 : POU X 包含一个变量，其类型 (POU Y) 具有 'no_assign' 属性。POU X 没有 'no_assign' 属性。 错误更正 : 还可以用 POU 来装饰 POU 'no_assign' 属性。 警告示例 {attribute 'no_assign'}\nFUNCTION_BLOCK FB_NotAssignable\nVAR\n      pBool : POINTER TO BOOL;\nEND_VAR\n\nFUNCTION_BLOCK FB_WrapperOfNotAssignable\nVAR\n      fbNotAssingable : FB_NotAssignable;\nEND_VAR\n\n 变量的声明 fbNotAssignable 产生以下警告。 消息： C0540：POU 'fb_wrapperOfNotassignable' 的属性 “no_assignable” 缺失。变量 'fbnoTassingable' 的类型由 'no_assign' 错误更正：还要装饰 FB_WrapperOfNotAssignable POU 与 'no_assign' 属性。 " }, 
{ "title" : "编译器警告 C0542 ", 
"url" : "_cds_error_c0542.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0542 ", 
"snippet" : "C0542 信息 : 继承不适用于数据类型“UNION”<数据类型名称>。 可能的错误原因 : 结构化数据类型 ( DUT ) 是从一个 UNION 通过扩展 EXTENDS , 或 UNION 是从一个 DUT .这种派生是不允许的。但是，出于兼容性的原因，仅发出警告。 错误示例： TYPE U_StringExt EXTENDS U_StringBase : UNION str10 : STRING(10); END_UNION END_TYPE TYPE U_StringBase : UNION str20 : STRING(20); END_UNION END_TYPE PROGRAM...", 
"body" : "C0542 信息 : 继承不适用于数据类型“UNION”<数据类型名称>。 可能的错误原因 : 结构化数据类型 ( DUT ) 是从一个 UNION 通过扩展 EXTENDS , 或 UNION 是从一个 DUT .这种派生是不允许的。但是，出于兼容性的原因，仅发出警告。 错误示例： TYPE U_StringExt EXTENDS U_StringBase :\nUNION\n str10 : STRING(10);\nEND_UNION\nEND_TYPE TYPE U_StringBase :\nUNION\n str20 : STRING(20);\nEND_UNION\nEND_TYPE PROGRAM PLC_PRG\nVAR\n uStringExt : U_StringExt;\nEND_VAR\n\nuStringExt.str20 := 'a234567890b234567890'; -> C0542 " }, 
{ "title" : "编译器错误 C0543 ", 
"url" : "_cds_error_c0543.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0543 ", 
"snippet" : "C0543 信息 ： 名字 <keyword> 是 IEC 1131-3 标准中的保留关键字。在以后的版本中会出现错误。 可能的错误原因 : 保留关键字被指定为变量的名称。 错误修正 : 重命名变量。 错误示例： PROGRAM PLC_PRG VAR char : BYTE; END_VAR 信息： C0543：名称“char”是 IEC 1131-3 标准中的保留关键字。在以后的版本中会出现错误。 注意：对于编译库中的违规行为，只会发出一条文本消息（信息）而不是警告。 保留以下关键字： CHAR WCHAR ANY_DERIVED ANY_ELEMENTARY ANY_MAGNITUDE ...", 
"body" : "C0543 信息 ： 名字 <keyword> 是 IEC 1131-3 标准中的保留关键字。在以后的版本中会出现错误。 可能的错误原因 : 保留关键字被指定为变量的名称。 错误修正 : 重命名变量。 错误示例： PROGRAM PLC_PRG\nVAR\n char : BYTE;\nEND_VAR\n 信息： C0543：名称“char”是 IEC 1131-3 标准中的保留关键字。在以后的版本中会出现错误。 注意：对于编译库中的违规行为，只会发出一条文本消息（信息）而不是警告。 保留以下关键字： CHAR WCHAR ANY_DERIVED ANY_ELEMENTARY ANY_MAGNITUDE ANY_SIGNED ANY_DURATION ANY_CHARS ANY_CHARS CHAR_TO TO_CHAR WCHAR_TO TO_WCHAR ATAN2 USING CLASS " }, 
{ "title" : "编译器错误 C0549 ", 
"url" : "_cds_error_c0549.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0549 ", 
"snippet" : "C0549 信息 : 静态变量的初始化 '<variable name>' 不是常量，或者替换常量被禁用。 可能的错误原因： VAR_STAT 和 CONSTANT 声明在功能块声明中一起使用。 这 替换常量 编译选项被禁用。 例子 这 替换常量 编译选项被禁用。 VAR CONSTANT iMaxInst : INT := 2; END_VAR VAR_STAT iIDs : INT := iMaxInst - 1; END_VAR 信息： C0549：静态变量“iIDs”的初始化不是常量，或者替换的常量被禁用。 错误修正 ： 在 项目 → 项目设置 , 在 编译选项 选项卡，启用 替换常量...", 
"body" : "C0549 信息 : 静态变量的初始化 '<variable name>' 不是常量，或者替换常量被禁用。 可能的错误原因： VAR_STAT 和 CONSTANT 声明在功能块声明中一起使用。 这 替换常量 编译选项被禁用。 例子 这 替换常量 编译选项被禁用。 VAR CONSTANT\n iMaxInst : INT := 2;\nEND_VAR\nVAR_STAT\n iIDs : INT := iMaxInst - 1;\nEND_VAR 信息： C0549：静态变量“iIDs”的初始化不是常量，或者替换的常量被禁用。 错误修正 ： 在 项目 → 项目设置 , 在 编译选项 选项卡，启用 替换常量 编译选项。 " }, 
{ "title" : "编译器错误 C0550 ", 
"url" : "_cds_error_c0550.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0550 ", 
"snippet" : "C0550 信息 : 'FUNCTION' ( 'METHOD' ) 的属性 'pack_mode' 不允许 可能的错误原因 : 使用 pragma 属性的函数或方法 {attribute 'pack_mode' := ' <pack mode value>' } 例子 {attribute 'pack_mode' := '2'} METHOD METH : INT VAR_INPUT END_VAR {attribute 'pack_mode' := '1'} FUNCTION FunPacked : DINT VAR_INPUT by1: BYTE; END_VAR VAR by2: BY...", 
"body" : "C0550 信息 : 'FUNCTION' ( 'METHOD' ) 的属性 'pack_mode' 不允许 可能的错误原因 : 使用 pragma 属性的函数或方法 {attribute 'pack_mode' := ' <pack mode value>' } 例子 {attribute 'pack_mode' := '2'}\nMETHOD METH : INT\nVAR_INPUT\nEND_VAR {attribute 'pack_mode' := '1'}\nFUNCTION FunPacked : DINT\nVAR_INPUT\n by1: BYTE;\nEND_VAR\nVAR\n by2: BYTE;\nEND_VAR 信息： C0550: 'METHOD' 的属性 'pack_mode' 不允许 C0550: 'FUNCTION' 的属性 'pack_mode' 不允许 错误修正 ： 删除属性杂注。 有关更多信息，请参阅： pack_mode" }, 
{ "title" : "编译器错误 C0554 ", 
"url" : "_cds_error_c0554.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0554 ", 
"snippet" : "C0554 信息 : 不允许显式调用“<FB 名称>”。 <属性“no_explicit_call”的值> 可能的错误原因 : 一个功能块 no_explicit_call 属性已被调用。 例子 {attribute 'no_explicit_call' := 'Call of this FB is not allowed'} FUNCTION_BLOCK FB1 VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR END_VAR PROGRAM PLC_PRG VAR myFB: FB1; END_VAR myFB(); 信息： C0554：不允许显式调用“FB...", 
"body" : "C0554 信息 : 不允许显式调用“<FB 名称>”。 <属性“no_explicit_call”的值> 可能的错误原因 : 一个功能块 no_explicit_call 属性已被调用。 例子 {attribute 'no_explicit_call' := 'Call of this FB is not allowed'}\nFUNCTION_BLOCK FB1\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\nEND_VAR PROGRAM PLC_PRG\nVAR\n myFB: FB1;\nEND_VAR\n\nmyFB();\n 信息： C0554：不允许显式调用“FB1”。Call of this FB is not allowed。 错误修正 ： 删除属性杂注。 " }, 
{ "title" : "编译器警告 C0555 ", 
"url" : "_cds_error_c0555.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0555 ", 
"snippet" : "C0555 信息 : 字符串文字 <literal> 包含无法显示的字符。可以使用项目选项“字符串的 UTF-8 编码”。 可能的错误原因 : 输入无法转换为 Latin-1 的未知字符。 例子 PROGRAM PLC_PRG VAR str1: STRING(200); str2: STRING := '1 €'; str3: STRING(200) := ' !$\"#$$%&$'()*+,-.\/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'; END_VAR str1 := '...", 
"body" : "C0555 信息 : 字符串文字 <literal> 包含无法显示的字符。可以使用项目选项“字符串的 UTF-8 编码”。 可能的错误原因 : 输入无法转换为 Latin-1 的未知字符。 例子 PROGRAM PLC_PRG\nVAR\n\tstr1: STRING(200);\n\tstr2: STRING := '1 €';\n\tstr3: STRING(200) := ' !$\"#$$%&$'()*+,-.\/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';\nEND_VAR\n\n str1 := '你好,世界';\nstr1 := 'ABC abc 123 äöü ß#~=\" §% \/(!)[]{}\\ ´`^*~°€µ *_-.; 中文字 Ω �';\nstr1 := '1 £';\nstr1 := '1 €';\nstr1 := ' !$\"#$$%&$'()*+,-.\/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'; 信息： C0555：字符串文字“你好，世界”包含无法显示的字符。可以使用项目选项“字符串的 UTF-8 编码”。 更正 ： 选择选项。 有关详细信息，请参阅：对话框： 编译选项 " }, 
{ "title" : "编译器警告 C0561 ", 
"url" : "_cds_error_c0561.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0561 ", 
"snippet" : "C0561 留言 : 调用递归：<POU> -> <POU> 可能的错误原因 ：程序代码包含递归调用。 错误更正 ：如果这是不想要的，请删除递归调用。 警告示例 METHOD METH: BOOL VAR_INPUT END_VAR Recursive(); PROGRAM Recursive VAR END_VAR Recursive(); 正在打电话 Recursive 在 Recursive 程序生成以下警告。 消息： C0561：调用递归：RECURSIVE-> RECURSIVE...", 
"body" : "C0561 留言 : 调用递归：<POU> -> <POU> 可能的错误原因 ：程序代码包含递归调用。 错误更正 ：如果这是不想要的，请删除递归调用。 警告示例 METHOD METH: BOOL\nVAR_INPUT\nEND_VAR\nRecursive();\n\nPROGRAM Recursive\nVAR\nEND_VAR\nRecursive();\n 正在打电话 Recursive 在 Recursive 程序生成以下警告。 消息： C0561：调用递归：RECURSIVE-> RECURSIVE " }, 
{ "title" : "编译器警告 C0564 ", 
"url" : "_cds_error_c0564.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0564 ", 
"snippet" : "C0564 留言 <variable2>：对未初始化变量的引<variable1>用用于初始化。访问未初始化的变量可能会导致意外行为 可能的错误原因 ：对未初始化变量的引用用于初始化另一个变量。 Error correction : Declare<variable1>before variable<variable2>. Example of the warning PROGRAM PLC_PRG VAR       inst : FB := STRUCT(ii := inst2);       inst2 : FBI; END_VAR 变量的初始化 inst 声明时会产生以下警告。 消息：...", 
"body" : "C0564 留言 <variable2>：对未初始化变量的引<variable1>用用于初始化。访问未初始化的变量可能会导致意外行为 可能的错误原因 ：对未初始化变量的引用用于初始化另一个变量。 Error correction : Declare<variable1>before variable<variable2>. Example of the warning PROGRAM PLC_PRG\nVAR\n      inst : FB := STRUCT(ii := inst2);\n      inst2 : FBI;\nEND_VAR\n\n 变量的初始化 inst 声明时会产生以下警告。 消息： C0564：对未初始化变量 inst2 的引用用于初始化 inst。访问未初始化的变量可能会导致意外行为 错误更正：声明变量 inst2 在变量之前 inst 。 PROGRAM PLC_PRG\nVAR\n      inst2 : FBI;\n      inst : FB := STRUCT(ii := inst2);\nEND_VAR " }, 
{ "title" : "编译器警告 C0565 ", 
"url" : "_cds_error_c0565.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0565 ", 
"snippet" : "C0565 信息 ：功能块或结构的“FB_Exit”方法需要 BOOL 类型的输入“bInCopyCode”。 可能的原因 ：输入 bInCopyCode 类型 BOOL 不见了。 更正 : 定义输入。 警告示例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB METHOD FB_exit VAR_INPUT END_VAR 信息： C0565：功能块或结构的“FB_Exit”方法需要 BOOL 类型的输入“bInCopyCode”。 更正： METHOD FB_exit VAR_INPUT bInCopyCode : BOO...", 
"body" : "C0565 信息 ：功能块或结构的“FB_Exit”方法需要 BOOL 类型的输入“bInCopyCode”。 可能的原因 ：输入 bInCopyCode 类型 BOOL 不见了。 更正 : 定义输入。 警告示例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB\nMETHOD FB_exit\nVAR_INPUT\nEND_VAR\n 信息： C0565：功能块或结构的“FB_Exit”方法需要 BOOL 类型的输入“bInCopyCode”。 更正： METHOD FB_exit\nVAR_INPUT\n bInCopyCode : BOOL;\nEND_VAR " }, 
{ "title" : "编译器警告 C0566 ", 
"url" : "_cds_error_c0566.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0566 ", 
"snippet" : "C0566 信息 : 功能块或结构的 FB_ReInit 方法必须没有输入和 BOOL 类型的返回值。 FB_ReInit 不会被自动调用。 可能的原因 : 一个或多个输入被定义为 FB_ReInit . 输出不仅是一个 BOOL 多变的。 更正 ：删除的输入 FB_ReInit 方法。确保 FB_ReInit 方法只有一个输出，这个输出是类型 BOOL . 警告示例 METHOD FB_ReInit : BOOL VAR_INPUT input_var : INT; \/\/C0566: unexpected input for FB_ReInit END_VAR VAR_OUT_PUT out...", 
"body" : "C0566 信息 : 功能块或结构的 FB_ReInit 方法必须没有输入和 BOOL 类型的返回值。 FB_ReInit 不会被自动调用。 可能的原因 : 一个或多个输入被定义为 FB_ReInit . 输出不仅是一个 BOOL 多变的。 更正 ：删除的输入 FB_ReInit 方法。确保 FB_ReInit 方法只有一个输出，这个输出是类型 BOOL . 警告示例 METHOD FB_ReInit : BOOL\nVAR_INPUT \n input_var : INT; \/\/C0566: unexpected input for FB_ReInit\nEND_VAR\n\nVAR_OUT_PUT\n output_var : INT; \/\/C0566: wrong type for output of FB_ReInit\nEND_VAR 更正： METHOD FB_ReInit : BOOL\n\/\/ correction: inputs have been removed\nVAR_OUTPUT\n output_var: BOOL; \/\/ correction: ouput has the correct type\nEND_VAR " }, 
{ "title" : "编译器警告 C0567 ", 
"url" : "_cds_error_c0567.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0567 ", 
"snippet" : "C0567 信息 : 接口 <接口名称 1> 不扩展 __System.IQueryInterface 可能的原因 : 接口库的每个接口都必须扩展 __System.IQueryInterface .使用的接口不扩展 __System.IQueryInterface . 例子 PROGRAM PLC_PRG VAR ITFref : ITF; ITFref2 : ITF2; END_VAR INTERFACE ITF INTERFACE ITF2 EXTENDS ITF 信息： C0567：接口 ITF 不扩展 __System.IQueryInterface 更正： INTERFACE IT...", 
"body" : "C0567 信息 : 接口 <接口名称 1> 不扩展 __System.IQueryInterface 可能的原因 : 接口库的每个接口都必须扩展 __System.IQueryInterface .使用的接口不扩展 __System.IQueryInterface . 例子 PROGRAM PLC_PRG\nVAR\n ITFref : ITF;\n ITFref2 : ITF2;\nEND_VAR\n\nINTERFACE ITF\nINTERFACE ITF2 EXTENDS ITF 信息： C0567：接口 ITF 不扩展 __System.IQueryInterface 更正： INTERFACE ITF EXTENDS __System.IQueryInterface 有关接口库要遵循的所有规则的概述，请参阅： 接口库 " }, 
{ "title" : "编译器警告 C0568 ", 
"url" : "_cds_error_c0568.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0568 ", 
"snippet" : "C0568 信息 : 接口“<功能块名称>”的覆盖方法“<方法名称>”的接口与声明不匹配 可能的原因 : 第一个接口的方法签名与第二个接口中的方法签名不匹配，由第一个扩展。 更正 : 对齐签名。 警告示例： PROGRAM PLC_PRG VAR xyz : XY2; END_VAR FUNCTION_BLOCK XY METHOD METH1 VAR_INPUT END_VAR FUNCTION_BLOCK XY2 EXTENDS XY METHOD METH1 VAR_INPUT iPar : BOOL; END_VAR 信息： C0568：基“XY”的覆盖方法“METH1”的接口与声明不...", 
"body" : "C0568 信息 : 接口“<功能块名称>”的覆盖方法“<方法名称>”的接口与声明不匹配 可能的原因 : 第一个接口的方法签名与第二个接口中的方法签名不匹配，由第一个扩展。 更正 : 对齐签名。 警告示例： PROGRAM PLC_PRG\nVAR\n xyz : XY2;\nEND_VAR\n\nFUNCTION_BLOCK XY\nMETHOD METH1\nVAR_INPUT\nEND_VAR\n\nFUNCTION_BLOCK XY2 EXTENDS XY\nMETHOD METH1\nVAR_INPUT\n iPar : BOOL;\nEND_VAR\n 信息： C0568：基“XY”的覆盖方法“METH1”的接口与声明不匹配 " }, 
{ "title" : "编译器警告 C0569 ", 
"url" : "_cds_error_c0569.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0569 ", 
"snippet" : "C0569 信息 : 在变量 {0} 的 VAR_PERSISTENT 列表中找不到匹配的实例路径。使用命令“添加所有实例路径”将所有实例路径添加到 VAR_PERSISTENT 列表。 可能的错误 ：已在外部声明的持久变量 VAR_PERSISTENT 必须通过以下方式添加列表 添加所有实例路径 这个列表的命令。当在外部声明持久变量后还没有执行此命令时发出警告 VAR_PERSISTENT 列表。 更正 ： 在里面 声明 菜单，点击 添加所有实例路径 . 有关详细信息，请参阅： 添加所有实例路径...", 
"body" : "C0569 信息 : 在变量 {0} 的 VAR_PERSISTENT 列表中找不到匹配的实例路径。使用命令“添加所有实例路径”将所有实例路径添加到 VAR_PERSISTENT 列表。 可能的错误 ：已在外部声明的持久变量 VAR_PERSISTENT 必须通过以下方式添加列表 添加所有实例路径 这个列表的命令。当在外部声明持久变量后还没有执行此命令时发出警告 VAR_PERSISTENT 列表。 更正 ： 在里面 声明 菜单，点击 添加所有实例路径 . 有关详细信息，请参阅： 添加所有实例路径" }, 
{ "title" : "编译器警告 C0571 ", 
"url" : "_cds_error_c0571.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0571 ", 
"snippet" : "C0571 留言 : FB_EXIT 中的实例 VAR_RETAIN 在预热重置期间也会调用，但不是 FB_INIT 。避免使用以下方法保留功能块的声明 FB_EXIT ! 可能的错误原因 : 一个函数块的实例，它有一个 FB_Exit 方法，声明于 VAR_RETAIN 。 错误更正 : 避免使用以下方法保留函数块的声明 FB_EXIT 。 警告示例 FUNCTION_BLOCK POU ... METHOD FB_Exit: BOOL VAR_INPUT       bInCopyCode : BOOL; END_VAR ... FUNCTION_BLOCK POU_1 VAR      ...", 
"body" : "C0571 留言 : FB_EXIT 中的实例 VAR_RETAIN 在预热重置期间也会调用，但不是 FB_INIT 。避免使用以下方法保留功能块的声明 FB_EXIT ! 可能的错误原因 : 一个函数块的实例，它有一个 FB_Exit 方法，声明于 VAR_RETAIN 。 错误更正 : 避免使用以下方法保留函数块的声明 FB_EXIT 。 警告示例 FUNCTION_BLOCK POU\n...\nMETHOD FB_Exit: BOOL\nVAR_INPUT\n      bInCopyCode : BOOL;\nEND_VAR\n...\nFUNCTION_BLOCK POU_1\nVAR\n      inst2 : POU;\nEND_VAR\n...\nPROGRAM PLC_PRG\nVAR\n      myFB : POU_1;\nEND_VAR\nmyFB();\n 变量的声明 myFB 产生以下警告。 消息： C0571：在预热重置期间也会调用 VAR_RETAIN 中实例的 FB_EXIT，但不调用 FB_INIT。避免使用 FB_EXIT 保留功能块的声明 " }, 
{ "title" : "编译器警告 C0572 ", 
"url" : "_cds_error_c0572.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0572 ", 
"snippet" : "C0572 留言 <variable2>：未初始化的变量<variable1>用于初始化。 'global_init_slot' 用于更改初始化顺序的属性。 可能的错误原因 ：对于嵌套结构，当内部结构中存在未初始化的变量时，将发出 C0572 警告，而不是错误 C0268。 警告示例 GVL {attribute 'qualified_only'} VAR_GLOBAL       x : INT := 7;       y : INT := 9; END_VAR TYPE DUT : STRUCT       a : INT;       i : INT := GVL.x; END_STRU...", 
"body" : "C0572 留言 <variable2>：未初始化的变量<variable1>用于初始化。 'global_init_slot' 用于更改初始化顺序的属性。 可能的错误原因 ：对于嵌套结构，当内部结构中存在未初始化的变量时，将发出 C0572 警告，而不是错误 C0268。 警告示例 GVL\n{attribute 'qualified_only'}\nVAR_GLOBAL\n      x : INT := 7;\n      y : INT := 9;\nEND_VAR\n\nTYPE DUT :\nSTRUCT\n      a : INT;\n      i : INT := GVL.x;\nEND_STRUCT\nEND_TYPE\n\nTYPE DUT_1 :\nSTRUCT\n      d : DUT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR CONSTANT " }, 
{ "title" : "编译器警告 C0573 ", 
"url" : "_cds_error_c0573.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0573 ", 
"snippet" : "C0573 留言 : 那个 ABSTRACT 关键字缺失 可能的错误原因 : 对于一种方法 'abstract' 选项是在添加时设置的， ABSTRACT 随后在编辑器中删除了关键字。 错误更正 : 插入 ABSTRACT 关键字回到编辑器中。...", 
"body" : "C0573 留言 : 那个 ABSTRACT 关键字缺失 可能的错误原因 : 对于一种方法 'abstract' 选项是在添加时设置的， ABSTRACT 随后在编辑器中删除了关键字。 错误更正 : 插入 ABSTRACT 关键字回到编辑器中。 " }, 
{ "title" : "编译器错误 C0576 ", 
"url" : "_cds_error_c0040-1853453.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器错误 C0576 ", 
"snippet" : "C0576 信息 : 无法从声明方法之外访问 “<方法名>” 的 VAR_INST '<变量名>' 可能的错误原因 : 正在尝试访问 VAR_INST 声明方法之外的变量。 错误更正： 错误示例： FUNCTION_BLOCK FB_Test ... METHOD TestMethod: BOOL VAR_INST       bInst:BOOL; END_VAR PROGRAM PLC_PRG VAR       fbTest:FB_Test;       bTest:BOOL; END_VAR bTest := fbTest.TestMethod.bInst; 消息： C0576：无法从...", 
"body" : "C0576 信息 : 无法从声明方法之外访问 “<方法名>” 的 VAR_INST '<变量名>' 可能的错误原因 : 正在尝试访问 VAR_INST 声明方法之外的变量。 错误更正： 错误示例： FUNCTION_BLOCK FB_Test\n...\nMETHOD TestMethod: BOOL\nVAR_INST\n      bInst:BOOL;\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n      fbTest:FB_Test;\n      bTest:BOOL;\nEND_VAR\nbTest := fbTest.TestMethod.bInst; \n 消息： C0576：无法从声明方法之外访问 “TestMethod” 的 VAR_INST 'binST' 错误更正： 删除不正确的语句或更改要访问的变量的声明（改为： VAR_INST 对于一种方法， VAR_INPUT 用于功能块）。 " }, 
{ "title" : "编译器警告 C0579 ", 
"url" : "_cds_error_c0579.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：编程 \/ 错误消息和警告 \/ 编译器警告 C0579 ", 
"snippet" : "C0579 信息 : 编译器功能 <名称或编译器功能> 仅支持编译器版本  <版本> 或更新的 可能的错误原因 ：编译器功能在库中使用 强制实现项目兼容性 选项，该选项在当前设置的编译器版本中不可用。 错误更正 ： 删除该功能的使用，或更新到消息中指定的编译器版本。 示例 这个 VAR_GENERIC CONSTANT 范围是在编译器版本 3.5.18.0 中引入的。 如果在当前设置的编译器版本为 3.5.16.0 的库中使用此编译器功能，则” 检查所有泳池对象 ” 命令生成以下错误消息： C0579：只有编译器版本 3.5.18.0 或更高版本支持编译器功能 “通用常量变量” 有关更多信息，...", 
"body" : "C0579 信息 : 编译器功能 <名称或编译器功能> 仅支持编译器版本  <版本> 或更新的 可能的错误原因 ：编译器功能在库中使用 强制实现项目兼容性 选项，该选项在当前设置的编译器版本中不可用。 错误更正 ： 删除该功能的使用，或更新到消息中指定的编译器版本。 示例 这个 VAR_GENERIC CONSTANT 范围是在编译器版本 3.5.18.0 中引入的。 如果在当前设置的编译器版本为 3.5.16.0 的库中使用此编译器功能，则” 检查所有泳池对象 ” 命令生成以下错误消息： C0579：只有编译器版本 3.5.18.0 或更高版本支持编译器功能 “通用常量变量” 有关更多信息，请参阅： VAR_GENERIC CONSTANT" }, 
{ "title" : "参考：用户界面 ", 
"url" : "_cds_f_reference_user_interface.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "通知 ", 
"url" : "_cds_notification.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 通知 ", 
"snippet" : "通知会告诉您重要信息，例如可用更新或安全通知。 打开 通知 查看，您单击 框架窗口右上角的图标 CODESYS .所有收到的通知都显示在此视图中。标记为的通知 读 被删除 CODESYS 从下一个开始的列表中。 新通知及其数量用红色表示 图标。...", 
"body" : "通知会告诉您重要信息，例如可用更新或安全通知。 打开 通知 查看，您单击 框架窗口右上角的图标 CODESYS .所有收到的通知都显示在此视图中。标记为的通知 读 被删除 CODESYS 从下一个开始的列表中。 新通知及其数量用红色表示 图标。 " }, 
{ "title" : "对象 ", 
"url" : "_cds_struct_reference_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 ", 
"snippet" : "中的对象 CODESYS 提供用于创建应用程序的特定功能。示例：应用程序、程序、函数、库管理器、设备和图像池。对象以树结构管理 设备 , POU ， 和 模块 意见。 你可以点击 项目 → 添加对象 命令 插入 相应“树”的对象。插入选项取决于树中的位置。 每个对象都有属性，您可以通过对象上下文菜单中的命令查看和访问这些属性。...", 
"body" : "中的对象 CODESYS 提供用于创建应用程序的特定功能。示例：应用程序、程序、函数、库管理器、设备和图像池。对象以树结构管理 设备 , POU ， 和 模块 意见。 你可以点击 项目 → 添加对象 命令 插入 相应“树”的对象。插入选项取决于树中的位置。 每个对象都有属性，您可以通过对象上下文菜单中的命令查看和访问这些属性。 " }, 
{ "title" : "对象：应用程序 ", 
"url" : "_cds_obj_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：应用程序 ", 
"snippet" : "应用程序 象征： 对象显示为节点 设备树 .它包括控制器程序运行所需的对象。 您可以在下方插入应用程序对象 PLC 逻辑 节点（可编程设备下方）。 在每个应用程序下方，必须有一个 任务配置 您可以在其中配置应用程序的哪个程序将由哪个任务调用以及使用哪些设置。 此外，您还可以将控制器程序的 POU 插入到应用程序下，例如 POU、全局变量列表和库管理器。这些 POU 仅适用于此应用程序。 在 CODESYS 版本 3.5 SP20 及更高版本，添加子应用程序操作 添加对象 命令不再受支持。 应用程序还可以使用项目全局 POU 的实例。您在 POU 看法。这些实例的使用是基于面向对象编程的思想。 ...", 
"body" : "应用程序 象征： 对象显示为节点 设备树 .它包括控制器程序运行所需的对象。 您可以在下方插入应用程序对象 PLC 逻辑 节点（可编程设备下方）。 在每个应用程序下方，必须有一个 任务配置 您可以在其中配置应用程序的哪个程序将由哪个任务调用以及使用哪些设置。 此外，您还可以将控制器程序的 POU 插入到应用程序下，例如 POU、全局变量列表和库管理器。这些 POU 仅适用于此应用程序。 在 CODESYS 版本 3.5 SP20 及更高版本，添加子应用程序操作 添加对象 命令不再受支持。 应用程序还可以使用项目全局 POU 的实例。您在 POU 看法。这些实例的使用是基于面向对象编程的思想。 可以在一个 PLC 设备对象下插入多个应用程序。为此，它们必须具有唯一的名称。 更改“父应用程序”后进行在线更改将从 PLC 中删除“子应用程序”。 当多个应用程序直接位于一个 CODESYS 设备，对于设备的 I\/O 处理，您必须定义应用程序，其变量应用于与目标系统通信。设置是在 PLC 设置 设备编辑器的选项卡。 您要在在线模式下使用的应用程序必须设置为“活动应用程序”（请参阅 应用程序2 在上图中）。 您可以为应用程序设置特殊属性 应用程序构建选项 的选项卡 特性 应用程序对象的对话框。示例：激活动态内存分配 将应用程序下载到 PLC 时，可以包含有关应用程序内容的信息。这也是一个设置 应用程序构建选项 标签。然后稍后您可以将控制器上的应用程序与中的活动应用程序进行比较 CODESYS . 如果您想添加关于作者、版本和个人简短描述的个人信息，您可以修改一般信息中的信息 项目信息 在 信息 的选项卡 特性 对话。 当您要使用应用程序登录目标系统（PLC 或仿真）时，首先会检查 PLC 上当前有哪些应用程序，以及控制器上的应用程序参数是否与项目配置中的参数匹配。相应的消息将通知您有关不匹配和可能的其他操作选项的信息。在此步骤中，您还可以从 PLC 中删除应用程序。 有关更多信息，请参阅： 将应用程序下载到 PLC在 应用 设备编辑器的选项卡，您可以查看设备上当前存在哪些应用程序。在那里，您还可以从目标系统中删除应用程序。您可能还会看到在设备树中没有由单独对象表示的其他应用程序，例如 <application>_symbols.app ，其中包含为应用程序创建的符号列表（请参阅“符号配置”）。 " }, 
{ "title" : "报警管理对象 ", 
"url" : "_cds_obj_alarm_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 报警管理对象 ", 
"snippet" : "可视化帮助中总结了报警管理的帮助页面。因此，在以下对象上寻找帮助： 报警配置 目的 报警等级 目的 报警组 目的 报警存储 目的 远程警报 目的...", 
"body" : "可视化帮助中总结了报警管理的帮助页面。因此，在以下对象上寻找帮助： 报警配置 目的 报警等级 目的 报警组 目的 报警存储 目的 远程警报 目的 " }, 
{ "title" : "对象：图书馆管理员 ", 
"url" : "_cds_obj_library_manager.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：图书馆管理员 ", 
"snippet" : "图书馆经理 象征： 库管理器列出了已集成到项目中以创建应用程序的所有库。它提供有关库类型、其属性和内容的信息。 您可以展开或折叠集成库列表，以及编辑非依赖库的库属性。 库管理器由三个视图组成： 上视图：集成库列表 左下视图：在上视图中选择库的所有模块的树形结构 右下视图：在树中选择的库 POU 的文档 有关更多信息，请参阅： 使用库 和 图书馆开发人员信息...", 
"body" : "图书馆经理 象征： 库管理器列出了已集成到项目中以创建应用程序的所有库。它提供有关库类型、其属性和内容的信息。 您可以展开或折叠集成库列表，以及编辑非依赖库的库属性。 库管理器由三个视图组成： 上视图：集成库列表 左下视图：在上视图中选择库的所有模块的树形结构 右下视图：在树中选择的库 POU 的文档 有关更多信息，请参阅： 使用库 和 图书馆开发人员信息" }, 
{ "title" : "集成库列表 ", 
"url" : "_cds_obj_library_manager.html#UUID-9b9a510b-0925-f73b-58bd-0ea218f5f2d6_id_ad23efddceafc3f3c0a8640e012263e7_id_fc299100cef8fcc5c0a8640e01a9c911", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：图书馆管理员 \/ 集成库列表 ", 
"snippet" : "如果一个库依赖于其他库，那么这些引用的库会自动集成。 以灰色字体显示 使用插件自动将库添加到项目中。 以黑色字体显示 这 添加库 命令用于自动将库添加到项目中。 姓名 以以下语法显示集成库： <占位符名称> = <库名称>、<版本>（<公司>）： <占位符名称> ：当库是占位符库时，占位符名称在a之前 = . <占位符名称> =（未解决） : 占位符库未解析。 <库名称> : 库存储库中用于管理的库的名称 <版本> : 首次集成时引用的版本 (<公司>) ：供应商（可选） 命名空间 用于对库内容进行唯一访问的命名空间 为此目的，它被添加到模块标识符之前： <命名空间>.<库 POU 标识符> ...", 
"body" : "如果一个库依赖于其他库，那么这些引用的库会自动集成。 以灰色字体显示 使用插件自动将库添加到项目中。 以黑色字体显示 这 添加库 命令用于自动将库添加到项目中。 姓名 以以下语法显示集成库： <占位符名称> = <库名称>、<版本>（<公司>）： <占位符名称> ：当库是占位符库时，占位符名称在a之前 = . <占位符名称> =（未解决） : 占位符库未解析。 <库名称> : 库存储库中用于管理的库的名称 <版本> : 首次集成时引用的版本 (<公司>) ：供应商（可选） 命名空间 用于对库内容进行唯一访问的命名空间 为此目的，它被添加到模块标识符之前： <命名空间>.<库 POU 标识符> 命名空间通常与库名称匹配。 注意：如果库有属性 LanguageModelAttribute \"qualified-access-only\" ， 然后你 不得不 通过命名空间访问应用程序代码中的库 POU。强制执行合格（唯一）访问。 您可以在 特性 对话。 有效版本 解析后的库版本 该版本的库在应用程序中使用。 要求：库管理器存在于 设备 查看并选择一个占位符库。 例子： 3.5.10.0 带有工具提示的符号，用于通知所选占位符库的当前分辨率偏离默认值 库管理器位于 设备 看法： 这个占位符被明确地重定向到这个版本（参见占位符对话框）。 库管理器位于 POU 看法： 在“Device_1”设备中，占位符被解析为“VisuElemsAlarms, 1.0.0.0 (System)”。 使用受信任证书签名的库（兼容 CODESYS >= 威力 3.5 SP15 使用受信任的证书签名的库，但至少引用了一个未签名的库 使用私钥和令牌签名的库（兼容 CODESYS >= 威力 3.5 SP15 未签名或使用不受信任或过期证书签名的库 对于不受信任的证书， 信任证书 命令在上下文菜单中提供。 不可用的库或未解析的占位符库 提示：为占位符分配一个可用的库。为此，请单击 命令图标。您可以在此处编辑占位符，例如，分配最新版本或其他库。 定义为可选且当前不可用的库 正在确定状态的图书馆 当前没有有效许可的许可库 由于无法验证其签名（加密）而无法加载的库的库符号 POU 池中由库管理器管理的库 库管理器中的命令 添加库 打开选择库的对话框 提供安装在库存储库中的所有库。 删除库 从项目中删除当前选定的库 特性 打开对话框以显示和编辑当前选定库的属性 细节 打开一个对话框，其中包含当前所选库的详细信息（一般信息、内容、属性、许可证信息） 尝试重新加载库 如果您选择标记为未找到的库，则可以尝试使用此命令再次将其加载到项目中。 下载缺失的库 打开一个对话框，显示库管理器中标记为缺失的库。 下载时， CODESYS 在项目选项中指定的下载服务器中扫描这些库。下载后，它们将自动安装。 只要打开这个对话框，就可以卸载最近安装的库。 占位符 打开 占位符 对话。显示当前分辨率，您可以在那里编辑它们。 库参数 打开 库参数 对话。存在于应用程序的库管理器和 POU 池中的库的参数显示在那里。您可以在此对话框中自定义参数。 图书馆资料库 打开 图书馆存储库 用于安装和卸载库以及用于定义库位置的对话框 图标图例 打开 信息 带有图标图例的对话框，显示集成库列表中的库的当前状态（见上文） 概括 打开 图书馆概要 对话 项目中引用的所有库都显示在对话框中的树结构中，以及引用这些库的那些库。 显示库层次结构中的所有事件并关闭对话框 命令：在库管理器的编辑器中，打开的树形结构中的库被标记为引用或使用该库。要求：选择了一个库。这 信息 对话框随后关闭。 双击库时也会执行此命令。 图书馆的展示 托管图书馆 ：库的名称和版本 出现次数 ：其他库引用此库的位置数 当你点击 + 对于库，引用该库的库将显示在下一层。 信任证书 仅在库管理器中选择的库的上下文菜单中，其中该库已使用不受信任的证书进行签名 该命令将不受信任的证书转换为受信任的证书，并且前面的图标从 至 . 导出库 仅在库管理器中选择的库的上下文菜单中可用 打开用于在文件系统中保存库文件的默认对话框 " }, 
{ "title" : "所选库的所有模块的树结构 ", 
"url" : "_cds_obj_library_manager.html#UUID-9b9a510b-0925-f73b-58bd-0ea218f5f2d6_id_ad23efddceafc3f3c0a8640e012263e7_id_6cd6c4dccef8fcc5c0a8640e01f982cf", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：图书馆管理员 \/ 所选库的所有模块的树结构 ", 
"snippet" : "所选 <library name> 库的内容 与库集成的所有库 POU 都以树状结构列出。 要求：在上视图中选择了一个库。 菜单栏中提供了常用的排序和搜索功能。...", 
"body" : "所选 <library name> 库的内容 与库集成的所有库 POU 都以树状结构列出。 要求：在上视图中选择了一个库。 菜单栏中提供了常用的排序和搜索功能。 " }, 
{ "title" : "在左下方视图中选择的库 POU 的文档 ", 
"url" : "_cds_obj_library_manager.html#UUID-9b9a510b-0925-f73b-58bd-0ea218f5f2d6_id_ad23efddceafc3f3c0a8640e012263e7_id_b14c72af30bf9a91c0a864635d6eb897", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：图书馆管理员 \/ 在左下方视图中选择的库 POU 的文档 ", 
"snippet" : "实现库的文档必须生成一次。这是使用 单击以更新库文档 命令。 标签： 输入\/输出 库 POU 的接口（输入\/输出） 标签： 图形 模块的图形显示 标签： 文档 库 POU 的文档 注意：作为库开发人员，您需要严格注意《库开发指南》中的文档收录规则。 有关更多信息，请参阅： 图书馆发展总结 标签 库参数 要求：库项目包含一个带有库参数的对象。 这 打开配置对话框 命令位于选项卡上。此命令打开 库参数 对话。...", 
"body" : "实现库的文档必须生成一次。这是使用 单击以更新库文档 命令。 标签： 输入\/输出 库 POU 的接口（输入\/输出） 标签： 图形 模块的图形显示 标签： 文档 库 POU 的文档 注意：作为库开发人员，您需要严格注意《库开发指南》中的文档收录规则。 有关更多信息，请参阅： 图书馆发展总结 标签 库参数 要求：库项目包含一个带有库参数的对象。 这 打开配置对话框 命令位于选项卡上。此命令打开 库参数 对话。 " }, 
{ "title" : "对象： DUT ", 
"url" : "_cds_obj_dut.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象： DUT ", 
"snippet" : "DUT DUT（数据单位类型）声明用户特定的数据类型。 符号： DUT 支持文本列表的枚举 你可以在应用程序下方或在 POU 观点。 创建对象时， 添加 DUT 对话框打开。在这里，您可以配置新的数据类型并从结构（结构、枚举、别名和联合）中进行选择 声明用户定义数据类型的语法 TYPE <identifier> : <data type declaration> END_TYPE DUT 构造 用户定义的数据类型声明位于方括号之间 TYPE 和 END_TYPE 。 TYPE <identifier> : STRUCT     <member declaration> END_STRUCT E...", 
"body" : "DUT DUT（数据单位类型）声明用户特定的数据类型。 符号： DUT 支持文本列表的枚举 你可以在应用程序下方或在 POU 观点。 创建对象时， 添加 DUT 对话框打开。在这里，您可以配置新的数据类型并从结构（结构、枚举、别名和联合）中进行选择 声明用户定义数据类型的语法 TYPE <identifier> : <data type declaration> END_TYPE DUT 构造 用户定义的数据类型声明位于方括号之间 TYPE 和 END_TYPE 。 TYPE <identifier> : STRUCT     <member declaration> END_STRUCT END_TYPE 一个结构用以下方法包围其成员 STRUCT 和 END_STRUCT 。可以声明任意数量的成员，但至少要有两个。 STRUCTTYPE <identifier> : (     <list of members> ) <base data type> := <initialization> ; END_TYPE 枚举是圆括号中以逗号分隔的成员名称列表。所有成员都有相同的数据类型。 也可以为枚举分配一个文本列表。这用于本地化枚举的值。因此，该对象还具有本地化视图。 枚举TYPE <identifier> : <data type name> ; END_TYPE 别名是替代标识符。 AliasTYPE <identifier> : UNION     <member declaration> END_UNION END_TYPE 工会将其成员包围为 UNION 和 END_UNION 。它是一种具有多个成员的数据类型，这些成员共享相同的内存位置。 UNION示例 结构声明 S_POLYGONLINE 包括成员的部分初始化 TYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE 结构声明 S_PENTAGON 作为 S_POLYGONLINE TYPE S_PENTAGON EXTENDS S_POLYGONLINE :\nSTRUCT\n aiPoint5 : ARRAY[1..2] OF INT;\nEND_STRUCT\nEND_TYPE 示例 枚举声明 E_TRAFFICSIGNAL {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_TRAFFICSIGNAL :\n(\n eRed,\n eYellow,\n eGreen := 10\n);\nEND_TYPE 本地化视图中支持文本列表的枚举 这个 文字视图 和 本地化视图 按钮位于编辑器的右边缘。单击按钮可在视图之间切换。 示例 别名声明 TYPE A_MESSAGE : STRING[50];\nEND_TYPE 示例 a 的声明 UNION TYPE U_DATA :\nUNION\n lrA : LREAL;\n liA : LINT;\n dwA : DWORD;\nEND_UNION\nEND_TYPE " }, 
{ "title" : "对话框： 添加 DUT ", 
"url" : "_cds_obj_dut.html#UUID-a00e77a7-6296-ccb7-ec7b-23e513eff544_id_c3f3067aba82cc0a8640e00158fd5_id_e443a77ca18a3080c0a8646312bf4a62", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象： DUT \/ 对话框： 添加 DUT ", 
"snippet" : "函数 : 该对话框用于配置新的 DUT 对象（数据单位类型）。 打电话 : 项目 → 添加对象 → DUT 菜单；应用程序对象的快捷菜单 姓名 新品的名字 DUT 数据类型 示例： S_POLYGONLINE 数据类型 结构 创建一个对象，该对象声明一个结构，该结构将具有不同数据类型的多个变量组合成一个逻辑单元 在结构中声明的变量称为成员。 示例： S_POLYGONLINE 高级 : 将现有结构扩展到更多成员 在输入字段中，指定现有结构。现有结构的成员在新结构中自动可用。 示例： S_PENTAGON 枚举 创建一个对象，该对象声明将多个整数常量组合成逻辑单元的枚举 在枚举中声明的常量也称为...", 
"body" : "函数 : 该对话框用于配置新的 DUT 对象（数据单位类型）。 打电话 : 项目 → 添加对象 → DUT 菜单；应用程序对象的快捷菜单 姓名 新品的名字 DUT 数据类型 示例： S_POLYGONLINE 数据类型 结构 创建一个对象，该对象声明一个结构，该结构将具有不同数据类型的多个变量组合成一个逻辑单元 在结构中声明的变量称为成员。 示例： S_POLYGONLINE 高级 : 将现有结构扩展到更多成员 在输入字段中，指定现有结构。现有结构的成员在新结构中自动可用。 示例： S_PENTAGON 枚举 创建一个对象，该对象声明将多个整数常量组合成逻辑单元的枚举 在枚举中声明的常量也称为枚举值。 示例： E_TRAFFICSIGNAL 枚举也可以有文本列表。这用于本地化枚举的值。因此，该对象还具有本地化视图。 添加文本列表支持 : 不支持任何文本列表的枚举 : 枚举，另外存储枚举值的文本列表 文本列表允许您本地化枚举值的名称。 示例： ETL_TRAFFICSIGNAL 注意：对于现有的枚举类型，可以随时添加或删除文本列表支持。 对象快捷菜单中的命令用于此目的： 添加文本列表支持 移除对文本列表的支持 提示：例如，本地化文本可以在可视化中显示。在这种情况下，可视化元素的文本输出显示当前语言中的符号枚举值，而不是数字枚举值。当在中指定了支持文本列表的枚举 文本变量 可视化元素的属性，它获得以下附加属性： < <enumeration name> > . 示例： 在可视化中，使用变量 PLC_PRG.eTrafficLight 类型的 ETL_TRAFFICSIGNAL 。 ETL_TRAFFICSIGNAL 是一个支持文本列表的枚举。然后，可视化元素的属性编辑器中的条目如下所示： PLC_PRG.eTrafficLight <ETL_TRAFFICSIGNAL> . 有关更多信息，另请参阅： 使用文本 提示：当您在应用程序中编辑枚举类型时，关闭应用程序时会打开一个提示，询问是否应自动更新受影响的可视化效果。 别名 创建一个对象，该对象声明一个别名，使用该别名为基本类型、数据类型或函数块声明备用名称 示例： A_MESSAGE 联盟 创建一个对象，该对象声明一个联合体，该联合将具有不同数据类型的多个成员合并为一个逻辑单元 所有成员的偏移量都相同，因此它们占用相同的内存。联盟的内存要求由其 “最大” 成员的内存要求决定。 示例： U_DATA 添加 关闭对话框并创建新对象 该对象显示为 设备树或设备中的符号 POU 观点。当还存储了该对象的文本列表时， 显示符号。 " }, 
{ "title" : "对象：外部文件 ", 
"url" : "_cds_obj_external_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：外部文件 ", 
"snippet" : "外部文件 一个 外部文件 是您添加到项目中的任何文件 POU 查看或 设备 看法。点击 项目 → 添加对象 打开 添加外部文件 对话框并定义文件如何属于项目。 这 下载转移\/在线更改 选项可用于配置外部文件的传输。 当外部文件下载到控制器时，它不会在项目中更新。 有关详细信息，请参阅： 选项卡：同步文件...", 
"body" : "外部文件 一个 外部文件 是您添加到项目中的任何文件 POU 查看或 设备 看法。点击 项目 → 添加对象 打开 添加外部文件 对话框并定义文件如何属于项目。 这 下载转移\/在线更改 选项可用于配置外部文件的传输。 当外部文件下载到控制器时，它不会在项目中更新。 有关详细信息，请参阅： 选项卡：同步文件" }, 
{ "title" : "对话框：添加外部文件 ", 
"url" : "_cds_obj_external_file.html#UUID-df1ad64c-b999-f57c-46aa-2b3f52722fdb_id_b2054b53d955bf7c0a8640e017bbd78_id_559ac53835cd4544c0a8640e01b2e037", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：外部文件 \/ 对话框：添加外部文件 ", 
"snippet" : "文件路径 外部文件的路径 这 按钮打开一个对话框，用于选择本地文件系统中的文件。 姓名 文件的对象名称 CODESYS 如果将其留空，则文件将恢复为以前的名称。 文件处理 确定外部文件如何保存在 CODESYS 项目 记住链接 ：保存Windows文件系统中指向外部文件的文件链接。 注意：如果文件的外部位置发生变化，通过文件链接访问将失败。仅当文件存在于定义的存储位置中时，该文件才在项目中可用。 记住链接并嵌入到项目中 ：保存Windows文件系统中指向外部文件的文件链接。此外，为了提高安全性，该文件的副本存储在项目中。 注意访问行为： 仅当通过链接访问失败时，才能访问项目中的副本。 如果外部...", 
"body" : "文件路径 外部文件的路径 这 按钮打开一个对话框，用于选择本地文件系统中的文件。 姓名 文件的对象名称 CODESYS 如果将其留空，则文件将恢复为以前的名称。 文件处理 确定外部文件如何保存在 CODESYS 项目 记住链接 ：保存Windows文件系统中指向外部文件的文件链接。 注意：如果文件的外部位置发生变化，通过文件链接访问将失败。仅当文件存在于定义的存储位置中时，该文件才在项目中可用。 记住链接并嵌入到项目中 ：保存Windows文件系统中指向外部文件的文件链接。此外，为了提高安全性，该文件的副本存储在项目中。 注意访问行为： 仅当通过链接访问失败时，才能访问项目中的副本。 如果外部文件发生变化，则根据在下面选择的选项处理副本 更改跟踪 . 嵌入到项目中 ：外部文件的副本保存在 Windows 文件系统中。 副本始终可以访问。如果外部文件发生更改，则项目内部副本将不会更新。 当外部文件打开时 CODESYS Development System （ 编辑对象 命令），将创建一个临时文件以供编辑。 更改跟踪 在同时保存了文件链接的项目中保存的副本的更新类型 要求： 记住链接并嵌入到项目中 选项被选中。 自动重新加载文件 ：如果外部文件发生变化，则存储在项目中的副本会自动更新。 提示是否重新加载文件 ：如果外部文件发生更改，则会打开一个对话框提示，让您决定是否应在项目中更新副本。 没做什么 ：虽然外部文件发生变化，但项目中的副本保持不变。 按钮： 显示文件属性 打开默认 <文件名> 的属性 Windows 文件系统中的外部文件对话框 此对话框与 特性 可以从文件的上下文菜单在 Windows 中打开的对话框。 在线办理 在线模式下处理文件 使用下载\/在线更改传输 ：当发生下载和在线更改时，外部文件被下载到控制器并存储在 目标路径 . 注意：插入的外部文件 POU 下载期间视图将传输到项目中的所有控制器。 此选项对库中的外部文件没有影响。通常，这些文件不会被传输。 目标路径（相对于设备上的“$PlcLogic$”） 可以通过以下方式指定目标路径： 为了 $PlcLogic$ 根目录：将输入字段留空 根目录中的单个文件夹（尚不可用） 例子： MySubDirectory 应用程序的文件夹（下面 $PlcLogic$ ) “App123”应用程序示例： App123 应用程序文件夹下的嵌套文件夹结构 例子： App123\/Sub01\/SubSub01 使用另一个可用的占位符，例如用于可视化的占位符： $visu$ 使用可用路径时，请注意大小写。 按钮 添加 插入一个新的 对象（类型 外部文件 ). 有关详细信息，请参阅： 属性 - 外部文件" }, 
{ "title" : "对象：C 实现的库 ", 
"url" : "_cds_obj_c_implemented_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：C 实现的库 ", 
"snippet" : "C 实现的库 象征： 您将对象添加到库项目中 POU 看法。一种 C 实现的库 可以包含多个预编译模块，每个模块都分配给特定的设备。插入的模块在库管理器中不可见。 当您双击对象中的 POU 查看，它会在其编辑器中打开。 编译组件 设备的目标文件 具有已分配模块的设备列表以及以下信息： 设备 , 版本 , 文件名 , 文件大小 添加 打开 选择设备 用于将预编译模块分配给设备并将其添加到 C 实现的库的对话框 可以向这样的对象添加任意数量的模块。将带有此库的具体项目下载到设备时，仅将相应匹配的文件加载到设备中。 消除 删除选定的条目 设备的目标文件 选择设备 目标文件 输入匹配的文件 设备 并且...", 
"body" : "C 实现的库 象征： 您将对象添加到库项目中 POU 看法。一种 C 实现的库 可以包含多个预编译模块，每个模块都分配给特定的设备。插入的模块在库管理器中不可见。 当您双击对象中的 POU 查看，它会在其编辑器中打开。 编译组件 设备的目标文件 具有已分配模块的设备列表以及以下信息： 设备 , 版本 , 文件名 , 文件大小 添加 打开 选择设备 用于将预编译模块分配给设备并将其添加到 C 实现的库的对话框 可以向这样的对象添加任意数量的模块。将带有此库的具体项目下载到设备时，仅将相应匹配的文件加载到设备中。 消除 删除选定的条目 设备的目标文件 选择设备 目标文件 输入匹配的文件 设备 并且可以由操作系统作为动态对象加载 Windows 示例： *.dll Linux 示例： *.so 注意： *.dll 文件必须在其名称中包含库项目的标题。示例：如果库项目名为 XYlib，则 目标文件 必须命名为： <name>_XYlib.dll 设备 小贩 设备列表 选项 按类别分组 ： ：可用设备（最新版本）按类别排序。类别在设备描述文件中定义。 ：可用设备按字母顺序排列在平面结构中。 显示所有版本（仅限专家） ：此外，还可以选择所有其他可用版本的设备。 : 每台设备只有最新版本可供选择。 显示过时的版本 ：此外，还可以选择过时版本的设备。例如，过时的版本来自更新的插件。 ：不显示过时的设备版本。 有关设备的信息 选择设备 预编译的运行时模块 目标文件 分配给选定的 设备 . " }, 
{ "title" : "对象：设备和通用设备编辑器 ", 
"url" : "_cds_f_obj_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 ", 
"snippet" : "设备和通用设备编辑器 象征： 设备对象代表特定的硬件组件（例如：控制器、现场总线节点、总线耦合器、驱动器、I\/O 模块或监视器）。你映射 硬件结构 通过设备对象的布局 设备树 在里面 设备 查看 CODESYS .在设备对象的设备对象配置编辑器中，您还可以将设备的 I\/O 链接到项目变量。 使用 添加设备 要么 插入设备 命令将设备对象插入设备树。 CODESYS 总是在树中的插入位置提供适当的设备。 你打开相应的 设备编辑器 通过双击设备树中的设备对象。编辑器为设备配置提供通用和设备特定选项卡。...", 
"body" : "设备和通用设备编辑器 象征： 设备对象代表特定的硬件组件（例如：控制器、现场总线节点、总线耦合器、驱动器、I\/O 模块或监视器）。你映射 硬件结构 通过设备对象的布局 设备树 在里面 设备 查看 CODESYS .在设备对象的设备对象配置编辑器中，您还可以将设备的 I\/O 链接到项目变量。 使用 添加设备 要么 插入设备 命令将设备对象插入设备树。 CODESYS 总是在树中的插入位置提供适当的设备。 你打开相应的 设备编辑器 通过双击设备树中的设备对象。编辑器为设备配置提供通用和设备特定选项卡。 " }, 
{ "title" : "通用设备编辑器 ", 
"url" : "_cds_edt_device_generic.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 通用设备编辑器 ", 
"snippet" : "通用设备编辑器包含用于 配置 一个PLC设备在 CODESYS .此外，还有特定于设备的选项卡，因此配置编辑器包含许多不同的对话框，具体取决于设备。 编辑器在双击设备对象后打开 设备树 （看法： 设备 ）。 您可以在 In den 中对设备编辑器进行常规设置 CODESYS 选项 在里面 设备编辑器 类别。例如，您可以显示和隐藏通用设备编辑器的选项卡。 设备编辑器被赋予设备的名称。可以包括通用设备编辑器的以下选项卡： 沟通 : 配置开发系统和可编程设备 (PLC) 之间的连接。在严格 I\/O 设备的情况下不可用 应用 ：控制器上的应用程序列表 <设备> 参数 ：设备参数的显示和配置 备份还原 ...", 
"body" : "通用设备编辑器包含用于 配置 一个PLC设备在 CODESYS .此外，还有特定于设备的选项卡，因此配置编辑器包含许多不同的对话框，具体取决于设备。 编辑器在双击设备对象后打开 设备树 （看法： 设备 ）。 您可以在 In den 中对设备编辑器进行常规设置 CODESYS 选项 在里面 设备编辑器 类别。例如，您可以显示和隐藏通用设备编辑器的选项卡。 设备编辑器被赋予设备的名称。可以包括通用设备编辑器的以下选项卡： 沟通 : 配置开发系统和可编程设备 (PLC) 之间的连接。在严格 I\/O 设备的情况下不可用 应用 ：控制器上的应用程序列表 <设备> 参数 ：设备参数的显示和配置 备份还原 : 配置 PLC 上应用程序特定文件的备份和恢复 同步文件 : 应用程序下载时下载到 PLC 的文件列表 文件 ：配置“主机”文件系统和设备之间的文件传输 日志 : PLC 日志文件的显示 PLC 设置 ：I\/O 处理的配置：哪个应用程序、停止状态下的行为、更新、总线周期选项等。 PLC外壳 ：基于文本的控制监视器，用于询问来自控制器的某些信息 <设备> I\/O 映射 ：它显示可用通道，并允许将控制器的输入、输出和内存地址映射到应用程序的变量或整个功能块。 <设备> IEC 对象 ：提供从 IEC 应用程序访问设备的对象列表 用户和组 ：在运行时对设备进行用户管理。 访问权 ：访问设备上的对象和文件的权限。 符号权利 ：单个用户组对设备上符号（符号集）的访问权限。 任务列表 ：分配给任务的所有输入和输出的概览（有助于故障排除）。 状态 ：设备特定的状态和诊断消息。 信息 ：有关设备的一般信息（名称、供应商、版本等） " }, 
{ "title" : "标签：通讯设置 ", 
"url" : "_cds_edt_device_communication_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 标签：通讯设置 ", 
"snippet" : "在通用设备编辑器的此选项卡上，您可以定义 CODESYS 以及您的应用程序应在其上运行的设备。 如果您更喜欢对话框的经典显示模式，请在 CODESYS 选项 在里面 设备编辑器 类别。 您从列表框中选择一个网关和一个目标设备。可能的选择取决于 管理网关 和 管理收藏的设备 对话框（见 网关 菜单）。 也可以直接用IP地址（例如：“192.168.101.109”）、设备地址（例如： [056D] ）或设备名称（例如： MyDevice ）。输入设备后， CODESYS 在网关的网络中搜索设备。 按设备名称搜索的选项需要网络中的唯一设备名称。 网关符号右下角的实心圆圈提供有关连接状态的信息： 红...", 
"body" : "在通用设备编辑器的此选项卡上，您可以定义 CODESYS 以及您的应用程序应在其上运行的设备。 如果您更喜欢对话框的经典显示模式，请在 CODESYS 选项 在里面 设备编辑器 类别。 您从列表框中选择一个网关和一个目标设备。可能的选择取决于 管理网关 和 管理收藏的设备 对话框（见 网关 菜单）。 也可以直接用IP地址（例如：“192.168.101.109”）、设备地址（例如： [056D] ）或设备名称（例如： MyDevice ）。输入设备后， CODESYS 在网关的网络中搜索设备。 按设备名称搜索的选项需要网络中的唯一设备名称。 网关符号右下角的实心圆圈提供有关连接状态的信息： 红色的： CODESYS 无法建立连接。 绿色：连接已建立。 黑色：连接状态未知。 某些通信协议允许定期检查网关，因此无法显示状态。 单击目标设备的实心圆圈开始对该设备进行网络扫描。这仅在尚未扫描网络时才有效。 扫描网络 此按钮打开 选择设备 对话。它列出了所有已配置的网关以及关联的设备。您可以从此列表中选择一个目标设备。如果所选设备的名称是唯一的，则该名称将用于连接设置。否则，应用唯一的设备地址。 显示的参数是在运行时系统的 SystarGet 组件中定义的，本质上代表控制器的类型板。可以使用更改设备名称 设备 → 重命名活动设备 命令。 选项： 隐藏不匹配的设备，按目标 ID 过滤 : ：显示仅限于与项目中配置的当前设备具有相同目标 ID 的设备。 ：显示网络中的所有可用设备。双击某个设备的条目会打开一个对话框，该设备的目标系统 ID 与项目中配置的设备不同。此对话框允许您将项目中设备的设备描述更新为与所选设备匹配的设备描述。注意：此类更新仅适用于具有不同ID的设备，不适用于仅具有不同版本的设备。此更新还要求设备描述已安装在存储库中。 网关 此菜单包括以下命令： 添加新网关 : 打开 网关 用于定义新网关通道的对话框。 管理网关 : 打开 管理网关 对话框概述了所有网关。在这里，您可以添加、删除或编辑条目或更改其顺序。 配置本地网关 : 打开 网关配置 对话。您可以为本地网关配置块驱动程序。 设备 此菜单包括以下命令： 在项目中存储通信设置 ： 将当前设备添加到收藏夹 ：将当前设置的设备添加到收藏设备列表中。 管理收藏的设备 ：打开包含所有首选设备列表的收藏夹对话框。在此对话框中，您可以添加或删除条目或更改它们的顺序。顶部设备是默认设备。 确认在线模式 ： : 出于安全原因， CODESYS 调用以下在线命令时需要您的确认： 力值 ， 写入值 ， 多次加载 ， 释放部队名单 ， 单循环 ， 开始 ， 停下来 。 在项目中存储通信设置 ： ： CODESYS 保存项目中的通信设置，以便在同一台计算机上重复使用。 注意：如果您在另一台计算机上使用该项目，则必须重置活动路径。 ： CODESYS 将通信设置保存在本地安装的选项中，以便在同一台计算机上重复使用。 注意：使用时 CODESYS SVN，应清除该选项以防止阻塞设备对象。 重命名活动设备 ： 打开用于更改设备名称的对话框 : 出于安全考虑， CODESYS 调用以下在线命令时，需要您确认以下内容：Force Values、Write Values、Multiple Loading、Release Force List、Single Cycle、Start、Stop。 ：显示仅限于与项目中配置的当前设备具有相同目标ID的设备。 加密通信 ： ：与该控制器的通信是加密的。需要控制器证书才能登录控制器。如果证书不可用，则会打开一条错误消息，提示是否应显示和安装证书。 如果 强制加密通信 选项被选为 安全级别 在里面 安全屏幕 查看，然后 加密通讯 命令在这里被禁用。 改变沟通政策 打开 改变沟通政策 用于更改通信加密设备设置的对话框。 更改运行时密码策略 打开 更改运行时密码策略 用于更改密码策略和登录锁设置的对话框 安全设定 ：此命令仅在以下情况下可用 CODESYS Security Agent >= 1.3.0.0 已安装。它打开 设备安全设置 对话。显示所连接设备上的当前安全设置。您可以更改设置中的 价值 列并单击 好的 将它们写入设备。 例如，您将在下方找到设备用户管理和密码策略的设置 CmpUserMgr 节点（另见下文）。 对话： 更改运行时安全策略 如果在此对话框中选择了新的通信策略，则控制器上的配置将被更改。 通讯设置 当前政策 显示当前选择的通信加密策略 新政策 新的加密策略列表框 无加密 ：控制器不支持加密通信。 可选加密 ：控制器支持加密和非加密通信。 强制加密 ：控制器仅支持加密通信。 代码签名 当前政策 显示当前在运行时系统中设置的代码签名策略 新政策 全部 ：接受所有类型的应用程序代码 强制签名 ：仅接受签名的应用程序代码（防止从不受信任的来源加载应用程序） 设备用户管理 当前政策 显示当前选择的用户管理策略 新政策 可选用户管理 ：用户有责任在设备上启用用户管理或使设备不受保护。 强制用户管理 ：设备上的用户管理已启用，用户无法禁用。 中的相应条目 安全设置 设备的： CmpUserMgr UserMgmtEnforce 。 允许匿名登录 ：特定的注册组件（例如，OPC UA）无需提供任何凭据即可连接到控制器。即使允许匿名访问 OPC UA，为控制器创建的设备用户管理仍然处于活动状态。 相应条目 安全设置 设备： CmpUserMgr UserMgmt.AllowAnonymous 。 对话框：更改运行时密码策略 当输入新设备用户的密码或更改设备用户的现有密码时，编程系统会事先检查此处配置的运行时系统密码策略。 如果在密码策略中配置了密码的有限有效期，则在该期限过后登录时，系统会提示用户设置新密码。 注意：要在密码到期之前更改密码，用户目前仍需要设备用户管理的读取权限。 密码策略处于活动状态 密码政策已激活 ：默认情况下，该策略处于启用状态。这个 密码设置 可以更改并在创建设备用户管理密码时使用。 中的相应条目 安全设置 的设备位于下方 CmpUserMgr 节点（ UserMgmt.PasswordPolicy.<..> ）。在的配置文件中 CODESYS Control ，这对应于 cmpUserMgr 部分。示例： [CmpUserMgr]\nSECURITY.UserMgmt.PasswordPolicy=ENABLED 密码设置 最小长度 默认设置：8 唯一字符数 默认设置：4 需要小写字母 默认设置：启用 需要大写字母 默认设置：启用 需要数字 默认设置：启用 需要特殊字符 默认设置：启用 不得包含用户名 默认设置：启用 以下密码规则始终适用，即使这些规则被部分或完全禁用： 密码不能为空。 密码不得包含用户名。 密码到期已激活 : 那个 密码到期设置 可以修改并在登录时应用。 中的相应条目 安全设置 设备下方：在 CmpUserMgr 节点（ Password.Expiration.<...> ）。 密码过期设置 ： 范围 : 管理员 ：这些设置适用于拥有管理员权限的用户。 非管理员 ：这些设置适用于所有没有管理员权限的用户。 全部 ：这些设置适用于所有用户。 超时 [天] ：密码的有效期，以天为单位。超过此时间后，将无法再使用以前的密码登录。在这种情况下，系统将立即提示您设置新密码。 登录锁处于活动状态 : 那个 登录锁定设置 在登录时生效。 中的相应条目 安全设置 设备下方：在 CmpUserMgr 节点（ UserLogin.<...> ）。 登录锁定设置 范围 管理员 ：设置适用于具有管理员权限的用户。 非管理员 ：这些设置适用于所有没有管理员权限的用户。 全部 ：设置适用于所有用户。 最大重试次数 ：当超过此处指定的登录尝试次数时，用户将被锁定在指定的时间内 锁定时长 场地。在管理员解除锁定或锁定时间到期之前，用户无法再次登录。 锁定持续时间 [s] ：锁定时间（以秒为单位） 有关解锁锁定用户的信息，请参阅： 设备用户管理的处理" }, 
{ "title" : "通讯设置 - 经典模式 ", 
"url" : "_cds_edt_device_communication_settings.html#UUID-4f041ba7-d0d4-e8fe-3708-a0ef62d6108b_id_a8ca3cbc369b81dc0a8640e012568ee_id_5427e3926f2911e49f48f439849fe1dc", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 标签：通讯设置 \/ 通讯设置 - 经典模式 ", 
"snippet" : "在里面 CODESYS 选项，您可以激活经典模式 工具 → 选项 “设备编辑器”类别中的对话框）。 选择控制器的网络路径 连接的网关通道 从视图的下部选择通道。 查看显示配置的网关通道和网络设备 左侧视图 已配置网关通道与本地网络中连接的设备的树结构： 笔记： CODESYS 将这些条目保存在本地系统上，而不是项目中。 设备条目前面有一个 设备符号。与项目中当前配置的目标 ID 不同的条目以灰色显示。 点击 扫描网络 刷新列表。 注意：如果您在本地系统上创建了第一个项目，则默认情况下本地网关将作为条目列在树中。 CODESYS 在系统引导时自动启动此网关。 网关符号右下角的实心圆圈提供有关连接...", 
"body" : "在里面 CODESYS 选项，您可以激活经典模式 工具 → 选项 “设备编辑器”类别中的对话框）。 选择控制器的网络路径 连接的网关通道 从视图的下部选择通道。 查看显示配置的网关通道和网络设备 左侧视图 已配置网关通道与本地网络中连接的设备的树结构： 笔记： CODESYS 将这些条目保存在本地系统上，而不是项目中。 设备条目前面有一个 设备符号。与项目中当前配置的目标 ID 不同的条目以灰色显示。 点击 扫描网络 刷新列表。 注意：如果您在本地系统上创建了第一个项目，则默认情况下本地网关将作为条目列在树中。 CODESYS 在系统引导时自动启动此网关。 网关符号右下角的实心圆圈提供有关连接状态的信息： 红色的： CODESYS Development System 无法建立连接。 绿色：连接是 已确立的。 黑色：连接状态未知。 注意：某些通信协议允许定期检查网关，因此无法显示状态。 树中的每个设备条目都包含一个符号，后跟 <设备名称> [ 设备地址 ]。在视图的右侧，您还可以看到 目标 ID , 目标名称 , 目标类型，目标供应商 ， 和 目标版本 . 右侧视图 视图左侧所选设备的网关通道信息 在左侧视图中选择网关通道时，显示如下信息： 设备名称 , IP地址 , 港口 , 司机 在左侧视图中选择设备时，将显示以下信息（取决于设备）： 设备名称 , 设备地址 , 通道数 , 块驱动程序 , 序列号 , 加密通信 , 目标供应商 , 目标 ID , 目标名称 , 目标类型 , 目标版本 . 对话框右侧的筛选和排序功能 筛选 您可以减少具有相同设备的显示列表 目标 ID 作为项目中配置的当前设备。 排序顺序 您可以按以下方式对列表进行排序 姓名 要么 设备地址 按字母顺序或升序排列。 对话框右侧的命令按钮 设置活动路径 该命令将选定的通信通道设置为活动的。双击通道树中的条目可以获得相同的结果。 添加网关 该命令打开 网关 对话框，您可以在其中定义网关 CODESYS 应该添加到当前配置中。 添加设备 该命令打开 添加设备 对话。您可以在此处手动定义要插入到树中当前选择的网关条目下的设备。注意功能 扫描网络 也是。 扫描网络 该命令开始搜索本地网络中的可用设备。网关的配置树会相应刷新。 对话框中网关树和设备树上下文菜单中的命令 按地址扫描设备 该命令在网络中搜索具有配置树中给出的唯一地址的设备。 CODESYS 在网关下方显示检测到的具有给定地址的设备。搜索始终适用于所选网关下方或所选条目下方的设备。 按名称扫描设备 该命令在网络中搜索与配置树中给定名称相同的设备。忽略大小写。 CODESYS 在网关下方显示检测到的具有给定名称的设备及其唯一设备地址。搜索始终适用于所选网关下方或所选条目下方的设备。 按 IP 地址扫描设备 该命令在网络中搜索具有配置树中给出的唯一 IP 地址的设备。 CODESYS 在网关下方显示检测到的具有给定地址的设备及其名称。搜索始终适用于所选网关下方或所选条目下方的设备。 发送回声服务 CODESYS 向控制器发送五个回显服务。这些用于测试网络连接，类似于“ping”功能。服务首先在没有有效负载的情况下发送，然后再用有效负载发送。有效载荷的范围取决于 PLC 的通信缓冲区。将打开一个消息视图，其中包含有关平均回显服务延迟和已发送有效负载范围的信息。 删除选定的设备 该命令从通道树中删除选定的设备。 编辑网关 该命令打开 网关 用于编辑所选网关设置的对话框。 配置本地网关 该命令会打开一个用于配置本地网关的对话框。这提供了手动编辑 Gateway.cfg 文件。 对话框下部的选项 不要在项目中存储通信设置 ： CODESYS 将通信设置保存在本地安装的选项中，以便在同一台计算机上重复使用。 注意：使用时 CODESYS SVN，应选择该选项以防止阻塞设备对象。 ： CODESYS 保存项目中的通信设置，以便在同一台计算机上重复使用。 注意：如果您在另一台计算机上使用该项目，则必须重置活动路径。 确认在线模式 : 出于安全原因， CODESYS 调用以下在线命令时需要您的确认： 力值 ， 写入值 ， 多次加载 ， 释放部队名单 ， 单循环 ， 开始 ， 停下来 。 " }, 
{ "title" : "选项卡：参数 ", 
"url" : "_cds_edt_device_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：参数 ", 
"snippet" : "此对话框用于测试目的。其值只能由专家更改。 设备特定参数显示在该选项卡上的表格中 通用设备编辑器 .设备描述定义了您可以在此对话框中编辑的参数。 您可以通过单击列标题按字母升序或降序或默认顺序对条目进行排序。 参数 参数名称，不可编辑 类型 参数的数据类型，不可编辑 价值 初始显示参数的默认值，直接或对应符号名称。不可编辑的参数以浅灰色显示。如果参数是可编辑的，您可以通过双击表格字段打开输入字段、列表框或文件选择对话框并使用它来更改值。 默认值 设备描述定义的参数默认值，不可编辑 单元 值的度量单位（例如：“ms”表示毫秒；不可编辑） 描述 设备描述指定参数的简短描述，不可编辑...", 
"body" : "此对话框用于测试目的。其值只能由专家更改。 设备特定参数显示在该选项卡上的表格中 通用设备编辑器 .设备描述定义了您可以在此对话框中编辑的参数。 您可以通过单击列标题按字母升序或降序或默认顺序对条目进行排序。 参数 参数名称，不可编辑 类型 参数的数据类型，不可编辑 价值 初始显示参数的默认值，直接或对应符号名称。不可编辑的参数以浅灰色显示。如果参数是可编辑的，您可以通过双击表格字段打开输入字段、列表框或文件选择对话框并使用它来更改值。 默认值 设备描述定义的参数默认值，不可编辑 单元 值的度量单位（例如：“ms”表示毫秒；不可编辑） 描述 设备描述指定参数的简短描述，不可编辑 " }, 
{ "title" : "标签：应用程序 ", 
"url" : "_cds_edt_device_applications.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 标签：应用程序 ", 
"snippet" : "在这个选项卡上 通用设备编辑器 您可以查看设备上存在哪些应用程序。根据系统，您可以从设备中删除应用程序或检索有关应用程序的详细信息。 PLC上的应用 通过以下方式找到的应用程序列表 刷新列表 在控制器的最后一次扫描期间 删除 删除所有 有关详细信息，请参阅“从属安全控制器”一章。 注意：如果在 PLC 下方插入了安全控制器，则该命令可以 永久性 中断安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的通信链接。安全现场设备和其他安全控制器可以作为反应进入安全状态。只有当安全控制器通过现场总线连接到主控制器时，与开发系统的连接才会受到影响。 删除列表中选择的应用程序或控制器上所有...", 
"body" : "在这个选项卡上 通用设备编辑器 您可以查看设备上存在哪些应用程序。根据系统，您可以从设备中删除应用程序或检索有关应用程序的详细信息。 PLC上的应用 通过以下方式找到的应用程序列表 刷新列表 在控制器的最后一次扫描期间 删除 删除所有 有关详细信息，请参阅“从属安全控制器”一章。 注意：如果在 PLC 下方插入了安全控制器，则该命令可以 永久性 中断安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的通信链接。安全现场设备和其他安全控制器可以作为反应进入安全状态。只有当安全控制器通过现场总线连接到主控制器时，与开发系统的连接才会受到影响。 删除列表中选择的应用程序或控制器上所有列出的应用程序 细节 打开 细节 对话。它显示了为应用程序定义的信息 信息 对话框的选项卡 特性 . 内容 要求： 下载申请资料 选项被激活在 特性 应用程序对象的 应用程序生成选项 标签。这会触发有关应用程序内容的信息被额外下载到 PLC。 这 内容 按钮打开一个对话框，其中包含有关最新生成的代码与控制器上存在的应用程序代码之间差异的附加信息。不同的 POU 显示在比较视图中。 刷新列表 扫描控制器以查找应用程序并相应地刷新列表。 您可以配置 从设备中删除应用程序 要么 从设备中删除应用程序 中的命令 工具 → 自定义 对话。这些命令对应于 删除 要么 删除所有 纽扣。 " }, 
{ "title" : "标签：备份和恢复 ", 
"url" : "_cds_edt_device_backup_and_restore.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 标签：备份和恢复 ", 
"snippet" : "在通用设备编辑器的此选项卡上，您可以启动 PLC 上应用程序特定文件的备份和恢复。为此，您放置一个打包的备份文件或读回一个。 有关更多信息，请参阅： 备份还原要求：与设备连接的通信设置正确。您要为其执行备份的应用程序存在于控制器上。 菜单栏 备份 该按钮打开一个包含以下命令的菜单： 从设备读取备份信息 ：该命令从 $PlcLogic$ PLC 的目录并将它们显示为选项卡底部的表格。 创建备份文件并保存到磁盘 ： 要求： 从设备读取备份信息 命令用于确定备份相关文件。这些文件位于标签页下方的表格中。 该命令将表集中的文件压缩为 积极的 和 meta.info 信息文件到备份 zip 文件中。文件...", 
"body" : "在通用设备编辑器的此选项卡上，您可以启动 PLC 上应用程序特定文件的备份和恢复。为此，您放置一个打包的备份文件或读回一个。 有关更多信息，请参阅： 备份还原要求：与设备连接的通信设置正确。您要为其执行备份的应用程序存在于控制器上。 菜单栏 备份 该按钮打开一个包含以下命令的菜单： 从设备读取备份信息 ：该命令从 $PlcLogic$ PLC 的目录并将它们显示为选项卡底部的表格。 创建备份文件并保存到磁盘 ： 要求： 从设备读取备份信息 命令用于确定备份相关文件。这些文件位于标签页下方的表格中。 该命令将表集中的文件压缩为 积极的 和 meta.info 信息文件到备份 zip 文件中。文件扩展名为 tbf (=\"目标备份文件\")。 将备份文件保存到设备 ： 要求：备份文件已保存到磁盘。该命令将备份文件保存到 TBF PLC 目录。 恢复 该按钮打开一个包含以下命令的菜单： 从磁盘加载备份文件 ：该命令打开 打开 用于在文件系统中导航以查找已保存的备份文件的对话框。包含的文件列在标签页下部的表格中。 从设备加载备份文件 ：该命令生成在 PLC 上找到的所有备份文件的列表。选择其中一个文件以在标签页上的表格中查看其内容。对于还原操作，您可以停用可选组件并编辑注释。 将备份还原到设备 ：如果当前加载在选项卡上的备份文件的至少一个组件设置为活动，则该命令可用。提示恢复设备上的应用程序状态。用户界面在恢复期间被阻止。您可以取消操作。 目标信息 ID PLC 的 ID（例如： 0000 0001 ) 类型 设备类型（例如： 4096 ) 版本 设备版本（例如： 3.5.8.0 ) 备份信息 文件名 备份文件的存储路径。单击 按钮打开文件系统对话框。例子： PlcLogic$\/Application\/Application.crc 活动文件的大小 （以千字节为单位）表中设置为活动的文件的总大小（例如： 206 KB (210965 bytes) ）。 模式 定义备份的范围： 应用 .应用相关文件打包。 评论 要保存的注释的可选条目 meta.info 文件的备份和文件恢复时读取。 备份文件表 积极的 : 可选文件可以在此处禁用，以便在备份文件中排除。 所需组件在此处显示为带有绿色复选标记（无复选框）。 零件 受影响的组件（例如： file system ) 文件 要备份的组件文件的名称（例如： $PlcLogic$\/Application\/Application.app ) 尺寸 文件大小（以字节为单位）（例如： 43280 ) 需要停止 ：对于组件，应用程序必须在备份和恢复之前停止。将打开一个对话框提示，警告您任何备份或恢复冲突。 " }, 
{ "title" : "选项卡：同步文件 ", 
"url" : "_cds_edt_device_synchronized_files.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：同步文件 ", 
"snippet" : "的选项卡 通用设备编辑器 列出下载应用程序时下载到 PLC 的文件。例如，这些是 外部文件 添加到应用程序中。 仅当为此配置了它们的下载时间并且 Implizite 在 PLC 的编辑器上显示用于应用程序下载的隐式文件 选项被选中 CODESYS 中的选项 设备编辑器 类别。 刷新 刷新视图 下载“按需”文件 仅限内部使用。 文件名 应用程序下的文件名，或隐式传输文件的直接名称（例如： archive.prj ）。 双击文件名打开文件。 主机路径 文件的位置或原始位置（例如： D:\\Proj1\\Files ）。 双击路径以在文件资源管理器中打开目录。 定时 PLC 上文件更新的时间间隔（例如：...", 
"body" : "的选项卡 通用设备编辑器 列出下载应用程序时下载到 PLC 的文件。例如，这些是 外部文件 添加到应用程序中。 仅当为此配置了它们的下载时间并且 Implizite 在 PLC 的编辑器上显示用于应用程序下载的隐式文件 选项被选中 CODESYS 中的选项 设备编辑器 类别。 刷新 刷新视图 下载“按需”文件 仅限内部使用。 文件名 应用程序下的文件名，或隐式传输文件的直接名称（例如： archive.prj ）。 双击文件名打开文件。 主机路径 文件的位置或原始位置（例如： D:\\Proj1\\Files ）。 双击路径以在文件资源管理器中打开目录。 定时 PLC 上文件更新的时间间隔（例如： 应用程序下载\/在线更改后 ）。 信息 与对象相关的附加信息（例如： 对象：外部文件 ）。 提供者 文件的一般来源类型（例如： 外部文件对象 , 源代码下载提供商 ）。 " }, 
{ "title" : "标签：文件 ", 
"url" : "_cds_edt_device_files.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 标签：文件 ", 
"snippet" : "在这个选项卡上 通用设备编辑器 ，您可以在之间传输文件 CODESYS （主机）和PLC。如果通讯设置正确且 PLC 在线，则 CODESYS 在运行期间自动建立与 PLC 的连接 文件传输 ....", 
"body" : "在这个选项卡上 通用设备编辑器 ，您可以在之间传输文件 CODESYS （主机）和PLC。如果通讯设置正确且 PLC 在线，则 CODESYS 在运行期间自动建立与 PLC 的连接 文件传输 . " }, 
{ "title" : "", 
"url" : "_cds_edt_device_files.html#UUID-e9ed7dc5-188b-7cea-31fd-715ea645231c_UUID-aa1b8515-35d0-1cd1-0849-d17b1439fc52", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 标签：文件 \/ ", 
"snippet" : "主机\/运行时 使用标准文件管理器的功能访问主机的文件系统 地点 主机端文件传输的当前目录 打开一个对话框以在设置的路径中创建一个新目录 删除选定的文件或目录 更新设置位置的文件和目录列表 将选定的文件和目录从主机和运行时系统复制到相应的其他文件系统 如果目标目录中尚无文件可用，则创建该文件。如果它已经可用并且没有写保护，那么它会被覆盖。然后显示相应的消息。 : 对应 将文件写入控制器 命令 : 对应 从控制器写入文件 命令 双击文件 使用其 Windows 默认程序打开所选文件 备选方案：选择文件 + 进入 钥匙 示例：TXT 文件在 Windows 记事本中打开 注意：只能在主机端使用 Wi...", 
"body" : "主机\/运行时 使用标准文件管理器的功能访问主机的文件系统 地点 主机端文件传输的当前目录 打开一个对话框以在设置的路径中创建一个新目录 删除选定的文件或目录 更新设置位置的文件和目录列表 将选定的文件和目录从主机和运行时系统复制到相应的其他文件系统 如果目标目录中尚无文件可用，则创建该文件。如果它已经可用并且没有写保护，那么它会被覆盖。然后显示相应的消息。 : 对应 将文件写入控制器 命令 : 对应 从控制器写入文件 命令 双击文件 使用其 Windows 默认程序打开所选文件 备选方案：选择文件 + 进入 钥匙 示例：TXT 文件在 Windows 记事本中打开 注意：只能在主机端使用 Windows 默认程序打开。 默认情况下， 将文件写入控制器 和 从控制器写入文件 命令不包含在任何菜单中。您可以通过 工具 → 自定义 中的对话框 在线的 命令类别。 " }, 
{ "title" : "选项卡：日志 ", 
"url" : "_cds_edt_device_log.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：日志 ", 
"snippet" : "你可以 看法 通用的此选项卡上的 PLC 日志 设备编辑器 。它列出了目标系统上记录的事件。这涉及以下方面： 系统启动和关闭期间的事件（加载的组件，带有版本） 应用程序下载和启动应用程序的加载 自定义条目 来自 I\/O 驱动程序的日志条目 来自数据源的日志条目 这 日志 单击时也会打开选项卡 打开日志页面 。您可以将其配置为菜单命令 定制 对话。...", 
"body" : "你可以 看法 通用的此选项卡上的 PLC 日志 设备编辑器 。它列出了目标系统上记录的事件。这涉及以下方面： 系统启动和关闭期间的事件（加载的组件，带有版本） 应用程序下载和启动应用程序的加载 自定义条目 来自 I\/O 驱动程序的日志条目 来自数据源的日志条目 这 日志 单击时也会打开选项卡 打开日志页面 。您可以将其配置为菜单命令 定制 对话。 " }, 
{ "title" : "", 
"url" : "_cds_edt_device_log.html#UUID-07798ea7-5bf9-767c-956e-9d523915b989_UUID-f8e0ab33-5cb2-7220-fd3c-9c0abaec2c6a", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：日志 \/ ", 
"snippet" : "菜单栏 刷新所有运行时系统组件的日志事件列表 成分 按列表框中选择的运行时系统组件过滤日志事件的显示 例子： CmpApp 显示这些组件中发生的所有事件，例如“ Application [ <name> ] loaded via [OnlineChange] ”。 <所有组件> ：显示所有组件的上报事件 使用更新的日志消息加载下一页 使用较旧的日志消息加载上一页 加载具有最新日志条目的页面并启用自动滚动 : 表示有新的日志消息尚未显示 这也显示在状态栏上 自动滚动：开 . 加载包含最旧日志消息的页面 过滤具有严重性的事件 警告 并通知有多少 蓝色轮廓按钮：显示警告。 过滤具有严重性的事件 错误...", 
"body" : "菜单栏 刷新所有运行时系统组件的日志事件列表 成分 按列表框中选择的运行时系统组件过滤日志事件的显示 例子： CmpApp 显示这些组件中发生的所有事件，例如“ Application [ <name> ] loaded via [OnlineChange] ”。 <所有组件> ：显示所有组件的上报事件 使用更新的日志消息加载下一页 使用较旧的日志消息加载上一页 加载具有最新日志条目的页面并启用自动滚动 : 表示有新的日志消息尚未显示 这也显示在状态栏上 自动滚动：开 . 加载包含最旧日志消息的页面 过滤具有严重性的事件 警告 并通知有多少 蓝色轮廓按钮：显示警告。 过滤具有严重性的事件 错误 并通知有多少 蓝色轮廓按钮：显示错误。 过滤具有严重性的事件 例外 并通知有多少 蓝色轮廓按钮：显示异常。 过滤具有严重性的事件 信息 并通知有多少 蓝色轮廓按钮：显示信息。 过滤具有严重性的事件 调试 并通知有多少 蓝色轮廓按钮：显示调试消息。 在消息中搜索 搜索文本的输入字段 当您在搜索字段中输入一个或多个字符时，记录器消息将以黄色突出显示命中。 跳到下一个命中 跳到上一个命中 记录器 启用记录器以显示其记录的事件 默认情况下， <default logger> 由系统定义设置。例如，这是记录器 PlcLog 为一个 CODESYS Control Win 运行时系统。 .Audit.log ：此记录器显示用户与控制器的所有交互。用户名也会被记录。这些操作包括下载、启动、停止或设置断点等。如果不允许用户执行某些操作，也会记录失败的尝试。 世界标准时间 ：转换下面显示的时间 时间戳 到开发系统的本地时间 转换基于操作系统所在的时区 CODESYS 在跑。 （默认设置） ：显示运行时系统的原始时间戳 如果您更改选项，则会自动转换显示的时间戳。 将列表内容导出到 xml 文件 您可以选择文件名和位置。 导入带有存储在文件系统中的日志消息的 XML 文件 将打开一个单独的窗口以显示日志消息。 带有日志文件的显示窗口 日志消息的表格显示 每页显示一万条日志消息。 严重性 ： 警告 ： 错误 ： 例外 ： 信息 : 调试信息 时间戳 开发系统或运行时系统的日期和时间） 例子： 1\/12\/2007 9:48 描述 活动说明 例子： PLC started 零件 发生报告事件的运行时组件 状态栏 自动滚屏 显示是否启用自动滚动 ( 在 ) 或禁用 ( 离开 ) 在 ：日志列表在发生更改时自动刷新。 离开 ：当有新的日志事件发生时，显示在旁边 离开 .此外， 按钮装饰有 在菜单栏上。 提示：点击 按钮启用 自动滚屏 . 错误检查 对于例外情况 *SOURCEPOSITION* 描述，受影响的功能在编辑器中通过双击或通过 在编辑器中显示源代码 上下文菜单中的命令。光标跳到导致错误的行。当您有以下情况时，您也可以执行此诊断 CODESYS 项目存档，包括下载信息文件和导出的日志文件。 当受影响的功能受到保护时，会出现以下消息：“ <函数名称> 的源代码不可用。 \" 如果一个 VendorException 被报告，则制造商特定的异常错误发生在 CODESYS 运行。有关详细信息，请联系 PLC 制造商。 " }, 
{ "title" : "选项卡：PLC 设置 ", 
"url" : "_cds_edt_device_plc_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：PLC 设置 ", 
"snippet" : "在这个选项卡上 通用设备编辑器 ，您可以对 PLC 的配置进行基本设置，例如输入和输出的处理以及总线循环任务。 申请 I\/O 处理 负责 I\/O 处理的应用程序 PLC 设置 在停止中刷新 I\/O : 输入输出通道的数值在 PLC 运行时也会刷新。 停止 模式。如果看门狗检测到故障，则将输出设置为预定义的默认值。 ：输入和输出通道的值 停止 模式不刷新。 停止时的输出行为 控制器进入时输出通道的处理 停止 模式： 保留值 ：保留当前值。 所有输出为默认值 : 分配由 I\/O 映射产生的默认值。 执行程序 ：输出值的处理由项目中包含的程序控制，该程序在 停止 模式。在右侧的字段中输入程序的名称。...", 
"body" : "在这个选项卡上 通用设备编辑器 ，您可以对 PLC 的配置进行基本设置，例如输入和输出的处理以及总线循环任务。 申请 I\/O 处理 负责 I\/O 处理的应用程序 PLC 设置 在停止中刷新 I\/O : 输入输出通道的数值在 PLC 运行时也会刷新。 停止 模式。如果看门狗检测到故障，则将输出设置为预定义的默认值。 ：输入和输出通道的值 停止 模式不刷新。 停止时的输出行为 控制器进入时输出通道的处理 停止 模式： 保留值 ：保留当前值。 所有输出为默认值 : 分配由 I\/O 映射产生的默认值。 执行程序 ：输出值的处理由项目中包含的程序控制，该程序在 停止 模式。在右侧的字段中输入程序的名称。 始终更新变量 全局定义 I\/O 变量是否在总线循环任务中更新 此设置对从站和模块的 I\/O 变量有效，仅当“ 停用 \"在他们的更新设置中定义。 停用（仅在任务中使用时更新） ：只有在任务中使用 I\/O 变量时才会更新它们。 启用 1（如果未在任何任务中使用，则使用总线循环任务） ：如果总线循环任务中的 I\/O 变量未用于任何其他任务，则更新它们。 启用 2（始终在总线循环任务中） ：总线循环任务的每个循环中的所有变量都被更新，无论它们是否被使用以及它们是否映射到输入或输出通道。 此选项的可用性取决于设备描述。 巴士循环选项 总线循环任务 控制总线周期的任务。默认情况下，输入由设备描述定义的任务。 默认情况下，应用上级总线设备的总线周期设置（使用上级总线的周期设置）。这意味着向上搜索设备树以查找总线循环任务的下一个有效定义。 在您选择“ <未指定> \" 总线循环任务的设置，你应该知道 \" <未指定> \" 表示设备描述中给出的默认设置生效。 因此，您应该检查此说明。使用具有最短周期时间的任务可以被定义为默认值，但使用具有最长周期时间的任务同样可以很好地定义！ 对于现场总线，需要一个固定的循环矩阵来确保确定的行为。因此，请勿使用“ 随心所欲 \" 总线循环任务的类型。 其他设置 I\/O 映射的强制变量 此设置仅在设备支持时可用。 ：在编译应用程序时，会为每个 I\/O 通道创建两个全局变量，这些变量映射到 I\/O 映射 对话。 您可以使用这些变量来强制该通道上的输入或输出值，例如通过 HMI 可视化。 激活设备诊断 ： 这 CAA Device Diagnosis 库集成在项目中。为每个设备生成一个隐式功能块。如果设备已有功能块，则生成扩展功能块（例如：EtherCAT）或添加另一个功能块实例。然后，这包含设备诊断的一般实现。 通过功能块实例，您可以确定应用程序中所有设备的状态并评估错误。此外，该库还包含用于对设备树进行编程编辑的功能。 示例：扫描总线系统的所有子元素，跳转到父元素。 有关更多信息，请参阅： CAA 设备诊断库文档 将 I\/O 警告显示为错误 有关 I\/O 配置的警告显示为错误。 为 I\/O 启用符号访问 ：输入和输出变量 (VAR_INPUT 和 VAR_OUTPUT ) 为设备的 I\/O 通道自动创建。为此，为每个从站创建了一个扩展功能块。基础是从站现有的功能块。这种自动生成的功能块可以直接在应用程序代码中访问。 这种符号访问与手动设置的 I\/O 映射并行工作。 ：不支持访问 I\/O 通道。必须手动设置映射并专门为每个 I\/O 通道分配新的或现有的变量。 " }, 
{ "title" : "选项卡：PLC 外壳 ", 
"url" : "_cds_edt_device_plc_shell.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：PLC 外壳 ", 
"snippet" : "此选项卡的 通用设备编辑器 包括一个基于文本的控制监视器，用于从控制器查询特定信息。您可以为此指定设备相关命令，并在结果窗口中接收来自控制器的响应。 这 PLC外壳 不支持模拟模式。 有关更多信息，请参阅： 使用 PLC Shell 查询信息...", 
"body" : "此选项卡的 通用设备编辑器 包括一个基于文本的控制监视器，用于从控制器查询特定信息。您可以为此指定设备相关命令，并在结果窗口中接收来自控制器的响应。 这 PLC外壳 不支持模拟模式。 有关更多信息，请参阅： 使用 PLC Shell 查询信息" }, 
{ "title" : "", 
"url" : "_cds_edt_device_plc_shell.html#UUID-1cf3dce3-ea3d-52c5-2128-ebac8bef6716_UUID-9403fb45-4885-1a82-e631-65a4038d76bf", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：PLC 外壳 \/ ", 
"snippet" : "标准命令 带有可能参数的命令 描述 ? 可用的 PLC shell 命令列表以及可能的参数和简短描述 getcmdlist 可用 PLC shell 命令的名称列表 mem <memory address> [<size>] 提供已定义内存范围的十六进制转储 这 size 参数是可选的，描述了输出的字节数。默认值：16 例子： mem 16x0422139C 8 reflect 重复给定的命令（用于测试连接） applist 提供所有已加载应用程序的列表 列表中的顺序定义以开头的应用程序索引 0 . pid [<application name> | <application index> ]...", 
"body" : "标准命令 带有可能参数的命令 描述 ? 可用的 PLC shell 命令列表以及可能的参数和简短描述 getcmdlist 可用 PLC shell 命令的名称列表 mem <memory address> [<size>] 提供已定义内存范围的十六进制转储 这 size 参数是可选的，描述了输出的字节数。默认值：16 例子： mem 16x0422139C 8 reflect 重复给定的命令（用于测试连接） applist 提供所有已加载应用程序的列表 列表中的顺序定义以开头的应用程序索引 0 . pid [<application name> | <application index> ] * 提供一个或所有已加载应用程序的 GUID（应用程序索引） pinf [<application name> | <application index>] * 提供项目信息中以下字段的内容：标题、版本、作者和描述。 要求：选项 为属性访问自动创建 POU 在里面 项目信息 对话框被激活。 startprg [<application name> | <application index> ] * 启动给定的应用程序，如果没有给定应用程序，则启动所有加载的应用程序 stopprg [<application name> | <applikation index> ] * 如果没有给出应用程序，则停止给定的应用程序或所有加载的应用程序 resetprg [<applikation name> | <application index> ] * 如果没有给出应用程序，则重置给定的应用程序或所有加载的应用程序 resetprgcold [<application name> | <application index> ] * 执行给定应用程序的冷启动，如果没有给定应用程序，则执行所有加载的应用程序 reload [<application name> | <application index>] * 加载给定应用程序的启动应用程序，如果没有给出应用程序，则加载所有已加载应用程序的启动项目 getprgstat [<application name> | <applikationsindex>] * 提供给定应用程序的程序状态，如果没有给出应用程序，则提供所有已加载应用程序的程序状态 plcload 显示控制器的处理器负载（百分比） rtsinfo 提供有关运行时系统的信息，例如运行时系统的处理器和版本 channelinfo 提供有关通信渠道的信息 rtc-get 通过 DataTime 细绳 rtc-set 通过设置世界时 (UTC) DataTime 字符串（参见 ISO 8601） listpcicards [<vendor ID>] 提供所有 PCI 适配器的列表（或按 <vendor ID> ) gettaskgroups 提供所有任务组、它们的任务和 CPU 内核绑定的列表 cert-getapplist 提供所有注册和使用的证书（组件的 ID 和使用情况） cert-genselfsigned [<number for search result by \"cert-getapplist\"> <expdays=>] 生成自签名证书 证书的有效期可以通过以下方式指定 expdays= . 默认值：365 天 cert-gendhparams <length in bits> 为 Diffie-Hellman 密钥交换生成参数 此操作可能需要几分钟才能完成。 cert-getcertlist [<trust level>] 列出指定信任级别的所有证书 如果未给出信任级别，则列出所有证书。 可能的信任级别 untrusted : 不可信证书 trusted : 值得信赖的证书 own : 控制器证书 quarantine ：无法通过验证确定信任级别（可信、不可信）的证书 因此，传入的连接被拒绝。 cert-createcsr [<number for search result by \"cert-getapplist\">] 为所有应用程序生成 CSR 文件 cert-import <trust level> <file name.cer> 导入指定的证书 cert-export <trust level> [<number of search result by \"cert-getcertlist\">] 导出指定的证书 cert-remove <trust level> <number of search result by \"cert-getcertlist\" or \"all\"> 删除指定的证书 cpuload 显示 CPU 的处理器负载（对于多核，每个处理器核心） gettaskgroups 提供已定义任务组的列表 为每个任务组显示分配的任务。 getmulticoreinfo 显示是否支持多核以及可用处理器内核的数量 sessinfo-list 提供所有当前登录的客户\/用户的列表 sessinfo-getcnt 提供当前登录的客户端\/用户的数量 logsetfilter [<CmpName>...] <FilterValue> 使用十六进制值配置日志过滤器的设置。 loggetfilter [<CmpName>...] 获取指定组件的当前日志过滤器设置。 logdelfilter [<CmpName>...] 删除指定组件的日志过滤器设置。 * 应用程序名称：设备树中应用程序的名称 应用程序索引：来自控制器上所有应用程序列表的结果，您可以使用 应用列表 命令。指数 0 代表列表中的第一个应用程序， 1 第二个，依此类推。 " }, 
{ "title" : "选项卡：<设备名称> I\/O 映射 ", 
"url" : "_cds_edt_device_io_mapping.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：<设备名称> I\/O 映射 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "具有 I\/O 通道的设备 ", 
"url" : "_cds_edt_device_io_mapping.html#UUID-fbea3edd-739b-f693-2a4d-f97a628b9269_id_ebd811526ea50336c0a8640e0138a0ff_id_2fed243abb96eb7ec0a864637b4cf8a3", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：<设备名称> I\/O 映射 \/ 具有 I\/O 通道的设备 ", 
"snippet" : "此选项卡显示在具有 I\/O 通道的设备的设备编辑器中。它显示可用通道，并允许将控制器的输入、输出和内存地址映射到应用程序的变量或整个功能块。您以这种方式创建“I\/O 映射”。 有关更多信息，请参阅： 配置设备和 I\/O 映射负责 I\/O 处理的应用程序在 PLC 设置 标签。 如果设备支持，您可以使用“在线配置模式”。在此模式下，您可以访问硬件的 I\/O，而无需事先将实际应用程序下载到设备。 如果应用程序中未引用 I\/O 通道，则不会更新其值。如果要监控非参考 I\/O 通道，则需要启用 始终更新变量 上的选项 选项卡：PLC 设置.或者，您也可以在 输入输出映射 设备的选项卡。然后启用仅对这一...", 
"body" : "此选项卡显示在具有 I\/O 通道的设备的设备编辑器中。它显示可用通道，并允许将控制器的输入、输出和内存地址映射到应用程序的变量或整个功能块。您以这种方式创建“I\/O 映射”。 有关更多信息，请参阅： 配置设备和 I\/O 映射负责 I\/O 处理的应用程序在 PLC 设置 标签。 如果设备支持，您可以使用“在线配置模式”。在此模式下，您可以访问硬件的 I\/O，而无需事先将实际应用程序下载到设备。 如果应用程序中未引用 I\/O 通道，则不会更新其值。如果要监控非参考 I\/O 通道，则需要启用 始终更新变量 上的选项 选项卡：PLC 设置.或者，您也可以在 输入输出映射 设备的选项卡。然后启用仅对这一个设备及其子设备有效。 映射“太大”的数据类型 如果大于字节的数据类型的变量映射到字节地址，则该变量的值将被截断为字节大小。用于监控变量值 I\/O 映射 对话框，这意味着，在地址的根元素中，将显示项目中当前变量的值。字节的当前单个位值连续显示在其下方的位元素中，但这可能不足以用于整个变量值。 示例 <设备名称> I\/O 映射 CAN 总线从站的选项卡： 该选项卡包含一个用于编辑 I\/O 映射的表格。为输入和输出显示的信息源自设备描述。 找 (1) 要在映射表中搜索的字符串的输入字段 搜索结果以黄色突出显示。 筛选 (2) 带有 I\/O 映射过滤器的列表框显示在映射表中： 显示所有 仅显示输出 仅显示输入 仅显示未映射的变量 仅显示映射变量 仅显示到现有变量的映射 仅显示到新变量的映射 为 IO 通道添加 FB (11) 取决于设备，如果在映射表中选择了通道条目，则可用 打开 选择功能块 用于选择应直接链接到通道的功能块的对话框 转到实例 (12) 如果在映射表中选择了条目，则可用 跳转到相应的条目 <设备名称> IEC 对象 标签 多变的 根据设备，设备的输入和输出显示为节点，并在节点下方缩进显示相关通道，或者根据设备，仅显示隐式创建的设备实例。 符号表示通道类型： ： 输入 ： 输出 双击单元格以打开输入字段。 可能性一：变量已经存在。 指定完整路径：<应用程序名称>.<POU 名称>.<变量名称> 例子： app1.plc_prg.ivar ;输入助手通过 可能性 2：该变量尚不存在。 指定简单名称 作为全局变量在内部自动创建 根据设备，输入或输出可以直接链接到功能块。在这种情况下， 为 IO 通道添加 FB 按钮可以点击。往上看。 映射 (3) 映射类型： : 现有变量 : 新变量 : 映射到功能块实例 渠道 (4) 通道的符号名称。 地址 (5) 通道地址（例如： %IW0 ) 地址删除线：表示您不应再为该地址分配任何变量。原因：尽管此处指定的变量作为现有变量在不同的内存位置进行管理，但在写入值时可能会导致歧义，尤其是在输出时。 : 表示该地址已被编辑修复 如果设备树中设备对象的排列发生变化，那么 CODESYS 不会自动调整此地址。 类型 (6) 通道的数据类型（例如： BOOL ) 设备描述中定义的结构或位字段仅在它们是 IEC 标准的一部分并且在设备描述中被标识为 IEC 数据类型时才会显示。否则表格单元格保持为空。 映射结构化变量时，编辑器会阻止您同时指定结构变量（例如： %QB0 ) 和单个结构元素（例如： %QB0.1 和 QB0.2 ）。因此，如果在映射表中存在一个带有位通道条目子树的主条目，则适用以下情况： 您可以将变量输入到主条目的行中，也可以将变量输入到子元素（位通道）的行中，但不是两者兼而有之。 默认值 适用于频道的参数的默认值：仅在选项时出现 将所有输出设置为默认值 被选中在 PLC 设置 对于停止时输出的行为。 注意：对于编译器版本 V3.5 SP11 及更高版本，在映射到现有变量时，变量的初始化值将自动用作默认值。您可以编辑 默认值 仅当您映射到新创建的变量时才需要字段。在旧版本中，用户必须明确指定默认值和初始化值是相同的。 单元 (7) 参数值的单位（例如： ms 毫秒） 描述 (8) 参数的简短描述 当前值 应用于通道的参数的实际值；仅在在线模式下显示 允许通过在线更改更改默认值，但该值仅在“重置冷”或“重置暖”后应用。 重置映射 (9) CODESYS 将映射设置重置为设备描述文件中定义的默认值。 始终更新变量 (10) 关于更新 I\/O 变量的设备对象定义 默认值在设备描述中定义： 使用父设备设置 ：根据上位设备的设置进行更新。 启用 1（如果未在任何任务中使用，则使用总线循环任务） ： CODESYS 如果总线循环任务中的 I\/O 变量未用于任何其他任务，则更新它们。 启用 2（始终在总线循环任务中） ： CODESYS 更新总线循环任务的每个循环中的所有变量，无论它们是否被使用以及它们是否映射到输入或输出通道。 如果 UNION 在映射对话框中由 I\/O 通道表示，则取决于设备是否也可以映射到根元素。 有关详细信息，请参阅： 现场总线设备和 I\/O 驱动程序" }, 
{ "title" : "带有 I\/O 驱动程序的设备 ", 
"url" : "_cds_edt_device_io_mapping.html#UUID-fbea3edd-739b-f693-2a4d-f97a628b9269_id_ebd811526ea50336c0a8640e0138a0ff_id_d5bd0998ff830339c0a8640e014aab3c", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：<设备名称> I\/O 映射 \/ 带有 I\/O 驱动程序的设备 ", 
"snippet" : "对于带有 I\/O 驱动程序的设备，您可以在此处设置总线循环任务 I\/O 映射 选项卡，如果不应使用常规设置（ PLC 设置 标签）。 巴士循环选项 总线循环任务 列表框提供了在活动应用程序的任务配置中定义的所有任务（例如： 主要任务 .的情况下 使用父总线循环设置 ，将使用父节点的设置。...", 
"body" : "对于带有 I\/O 驱动程序的设备，您可以在此处设置总线循环任务 I\/O 映射 选项卡，如果不应使用常规设置（ PLC 设置 标签）。 巴士循环选项 总线循环任务 列表框提供了在活动应用程序的任务配置中定义的所有任务（例如： 主要任务 .的情况下 使用父总线循环设置 ，将使用父节点的设置。 " }, 
{ "title" : "关于总线循环任务的一般信息 ", 
"url" : "_cds_edt_device_io_mapping.html#UUID-fbea3edd-739b-f693-2a4d-f97a628b9269_id_ebd811526ea50336c0a8640e0138a0ff_id_3c6e4af3bb96eb7ec0a864634fef4137", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：<设备名称> I\/O 映射 \/ 关于总线循环任务的一般信息 ", 
"snippet" : "通常，对于每个 IEC 任务，在每个任务开始时读取使用的输入数据 (1)，并在任务结束时将写入的输出数据传输到 I\/O 驱动程序 (3)。 I\/O 驱动程序中的实现对于 I\/O 数据的额外传输具有决定性意义。它负责实际传输到相应总线系统的时间范围和时间点。 PLC 的总线循环任务可以在 PLC 设置中为所有现场总线全局定义。但是，对于某些现场总线，您可以独立于全局设置进行更改。循环时间最短的任务用作总线循环任务（设置： 未指定 在 PLC 设置中）。在此任务中，消息通常在总线上发送。 其他任务仅从内部缓冲区复制 I\/O 数据，该缓冲区仅与总线周期任务中的物理硬件交换。 (1) 从输入缓冲区读取...", 
"body" : "通常，对于每个 IEC 任务，在每个任务开始时读取使用的输入数据 (1)，并在任务结束时将写入的输出数据传输到 I\/O 驱动程序 (3)。 I\/O 驱动程序中的实现对于 I\/O 数据的额外传输具有决定性意义。它负责实际传输到相应总线系统的时间范围和时间点。 PLC 的总线循环任务可以在 PLC 设置中为所有现场总线全局定义。但是，对于某些现场总线，您可以独立于全局设置进行更改。循环时间最短的任务用作总线循环任务（设置： 未指定 在 PLC 设置中）。在此任务中，消息通常在总线上发送。 其他任务仅从内部缓冲区复制 I\/O 数据，该缓冲区仅与总线周期任务中的物理硬件交换。 (1) 从输入缓冲区读取输入 (2) IEC 任务 \n(3) 将输出写入输出缓冲区 (4) 总线周期 \n(5) 输入缓冲区 (6) 输出缓冲区 \n(7) 将数据复制到\/从总线 \n(9) 总线周期任务，优先级 1，1 ms \n(10) 总线循环任务，优先级 5 \n(11) 总线循环任务，优先级 10，被任务 5 中断 任务使用 这 任务部署 选项卡提供已用 I\/O 通道、设置总线周期任务和通道使用情况的概览。 如果在各种任务中写入输出，则状态未定义，因为在每种情况下都可以覆盖。 如果在不同的任务中使用相同的输入，那么输入可能会在任务处理过程中发生变化。当任务被具有更高优先级的任务中断并导致再次读取过程映像时会发生这种情况。解决方案：在 IEC 任务开始时，将输入变量复制到变量中，然后在其余代码中仅使用局部变量。 结论：在多个任务中使用相同的输入和输出没有任何意义，并且在某些情况下会导致意外反应。 " }, 
{ "title" : "选项卡：'<设备名称> IEC 对象 ", 
"url" : "_cds_edt_device_iec_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：'<设备名称> IEC 对象 ", 
"snippet" : "请注意，手动创建设备对象的另一个实例可能会导致故障。 在通用设备编辑器的此选项卡上，列出了允许从 IEC 应用程序访问设备的“对象”。在在线模式下，这被用作监控视图。 对于隐式创建功能块实例的设备，至少该实例在表中列为对象。例如，此实例可用于重新启动总线或从应用程序查询信息。设备类型决定了这种设备实例是否可用以及它有哪些访问选项。请参阅特殊设备配置的帮助。 与设备的输入或输出链接的功能块实例也显示在此处。功能块到通道的映射在 <设备名称> I\/O 映射 标签。这 转到实例 命令从那里直接将您带到受影响的对象。 此外，您可以在此处的表中创建更多尚未与设备通道链接的对象。 在在线模式下，您可以将 ...", 
"body" : "请注意，手动创建设备对象的另一个实例可能会导致故障。 在通用设备编辑器的此选项卡上，列出了允许从 IEC 应用程序访问设备的“对象”。在在线模式下，这被用作监控视图。 对于隐式创建功能块实例的设备，至少该实例在表中列为对象。例如，此实例可用于重新启动总线或从应用程序查询信息。设备类型决定了这种设备实例是否可用以及它有哪些访问选项。请参阅特殊设备配置的帮助。 与设备的输入或输出链接的功能块实例也显示在此处。功能块到通道的映射在 <设备名称> I\/O 映射 标签。这 转到实例 命令从那里直接将您带到受影响的对象。 此外，您可以在此处的表中创建更多尚未与设备通道链接的对象。 在在线模式下，您可以将 IEC 对象表用作监控视图。它还显示通道中功能块变量的当前值、地址和注释。最后，它提供了写入和强制值的能力。 添加 调整 打开 选择功能块 用于创建新实例或编辑在表中选择的实例的对话框。 ： 删除 删除选定的条目 转到变量 从选中的条目直接跳转到对应的映射 <设备名称> I\/O 映射 标签。 多变的 对象名称由设备名称和功能块名称组成。例子： EL2004_Relay .更改设备名称会立即生效。设备名称后的名称部分可在此处进行编辑。 映射 映射类型，如 <设备名称> I\/O 映射 标签 类型 数据类型：这里是功能块的名称。 价值 准备值 地址 评论 仅在线模式下： 显示通道中变量的当前值、地址和注释 此外，指定写入或强制变量的值的选项。 " }, 
{ "title" : "标签：访问权限 ", 
"url" : "_cds_edt_device_access_rights.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 标签：访问权限 ", 
"snippet" : "数据保护建议 为了将违反数据安全的风险降到最低，我们建议对运行您的应用程序的系统采取以下组织和技术措施。尽可能避免将 PLC 和控制网络暴露于开放网络和 Internet。使用额外的数据链路层进行保护，例如用于远程访问的 VPN，并安装防火墙机制。仅限授权人员访问，并在初始调试期间更改任何现有的默认密码，并定期更改。 有关设备用户管理的概念和使用的详细信息，请参阅 设备用户管理的处理 章节。 在那里，您还将找到有关如何使用编辑器的以下说明： 首次登录控制器进行用户管理编辑查看 在控制器的用户管理中设置新用户 在控制器的用户管理中更改对控制器对象的访问权限 从 *.dum 文件加载用户管理，对其...", 
"body" : "数据保护建议 为了将违反数据安全的风险降到最低，我们建议对运行您的应用程序的系统采取以下组织和技术措施。尽可能避免将 PLC 和控制网络暴露于开放网络和 Internet。使用额外的数据链路层进行保护，例如用于远程访问的 VPN，并安装防火墙机制。仅限授权人员访问，并在初始调试期间更改任何现有的默认密码，并定期更改。 有关设备用户管理的概念和使用的详细信息，请参阅 设备用户管理的处理 章节。 在那里，您还将找到有关如何使用编辑器的以下说明： 首次登录控制器进行用户管理编辑查看 在控制器的用户管理中设置新用户 在控制器的用户管理中更改对控制器对象的访问权限 从 *.dum 文件加载用户管理，对其进行修改，并在离线模式下将其下载到控制器 在此选项卡上，您可以定义设备用户对控制器上对象的设备访问权限。与项目用户管理一样，用户必须至少是一个用户组的成员，并且只有用户组才能被授予某些访问权限。 要求 访问权 要显示的选项卡： 这 显示访问权限页面 必须在 den 中选择选项 CODESYS 中的选项 设备编辑器 类别。 请注意，这 CODESYS 选项可以被设备描述覆盖。 授予用户组访问权限的要求 用于用户管理的组件必须在控制器上可用。这是首要要求。 用户和用户组必须在 用户和组 标签。 对象 在树形结构中，列出了可以在运行时对其执行操作的对象。每个对象都由它们的对象源分配，并在对象组中部分排序。在里面 权利 查看，您可以配置用户组对选定对象的访问选项。 对象源（根节点） 文件系统对象 → 设备 ：在这些对象中，可以将权限授予控制器当前执行目录的文件夹。 运行时对象 → \/ ：在这些对象中，所有在控制器中具有在线访问权限的对象都被管理，因此必须控制权限。 对象的描述位于 对象概述 桌子。 对象组和对象（缩进） 例子： 设备 有子节点 记录器 , 逻辑逻辑 , 设置 , 用户管理 . 权限 通常，子对象从根对象继承权限（ 设备 要么 \/ ）。这意味着如果用户组的权限被拒绝或明确授予父对象，那么这首先会影响所有子对象。 该表适用于当前在树中选择的对象。对于每个用户组，它显示当前为对该对象的可能操作配置的权限。 对对象可能的操作： 添加\/删除 调整 看法 执行 单击对象时，右侧的表格会显示所选对象的可用用户组的访问权限。 这使您可以快速查看： 对象评估哪些访问权限 哪个用户组对哪个对象有哪些有效权限 符号的含义 : 明确授予的访问权限 : 访问权限被明确拒绝 : 通过继承授予的访问权限 : 通过继承拒绝访问权限 : 访问权限未被显式授予或拒绝，也未被父对象继承。无法访问。 无符号：选择了具有不同访问权限的多个对象。 通过单击符号更改权限。 例子 这 记录器 对象上 访问权 选项卡由“记录器”组件创建并控制其访问权限。它位于正下方 设备 运行时对象。 此对象的可能访问权限只能授予 看法 行动。 最初，每个对象都有读取权限。这意味着每个用户都可以读取控制器的“记录器”。如果应拒绝单个用户组的此访问权限 ( 服务 在示例中），则必须明确拒绝对记录器对象的读取访问。 " }, 
{ "title" : "选项卡的工具栏 ", 
"url" : "_cds_edt_device_access_rights.html#UUID-cd3e7f33-8afc-1a1a-14eb-8436f7d0b1e8_UUID-bf0ecbfd-1dbd-5ac2-0f81-c00318625768", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 标签：访问权限 \/ 选项卡的工具栏 ", 
"snippet" : "同步 打开和关闭编辑器与设备上的用户管理之间的同步。 如果按钮未“按下”，则编辑器为空白或包含您从硬盘加载的配置。 当您在编辑器包含尚未与设备同步的用户配置时启用同步时，系统会提示您编辑器内容应该发生什么。选项： 从设备上传并覆盖编辑器内容 ：设备上的配置被加载到编辑器中，覆盖当前内容。 将编辑器内容下载到设备并覆盖那里的用户管理 ：编辑器中的配置被传输到设备并在那里应用。 从磁盘导入 当你点击按钮上的 用户和组 选项卡导入 设备用户管理文件*.dum2 ，选择文件的默认对话框打开以从硬盘驱动器中选择设备用户管理文件。选择文件后， 输入密码 对话框打开。您必须指定导出文件时分配的密码。然后启用...", 
"body" : " 同步 打开和关闭编辑器与设备上的用户管理之间的同步。 如果按钮未“按下”，则编辑器为空白或包含您从硬盘加载的配置。 当您在编辑器包含尚未与设备同步的用户配置时启用同步时，系统会提示您编辑器内容应该发生什么。选项： 从设备上传并覆盖编辑器内容 ：设备上的配置被加载到编辑器中，覆盖当前内容。 将编辑器内容下载到设备并覆盖那里的用户管理 ：编辑器中的配置被传输到设备并在那里应用。 从磁盘导入 当你点击按钮上的 用户和组 选项卡导入 设备用户管理文件*.dum2 ，选择文件的默认对话框打开以从硬盘驱动器中选择设备用户管理文件。选择文件后， 输入密码 对话框打开。您必须指定导出文件时分配的密码。然后启用用户管理。 注意：在 V3.5 SP16 之前， 设备用户管理文件 (*.dum) 使用了不需要任何加密的文件类型。 当你点击按钮上的 访问权 选项卡导入 设备权限管理文件 *.drm ，选择文件的默认对话框打开以从硬盘驱动器中选择相应的文件。对话框中的现有配置被导入的文件覆盖。 导出到磁盘 当你点击按钮上的 用户和组 选项卡，首先是 输入密码 为设备用户管理文件分配密码的对话框打开。注意：稍后导入此文件时必须重复此密码才能在控制器上启用此用户管理。 密码分配对话框关闭后，用于从硬盘选择和导入用户管理配置的默认对话框打开。在这种情况下，文件类型是 设备用户管理文件 (*.dum2) . 注意：在 V3.5 SP16 之前， 设备用户管理文件 (*.dum) 使用了不需要任何加密的文件类型。 当你点击按钮上的 访问权 选项卡，文件类型为 设备权限管理文件 (*.drm) .在这种情况下，保存前不必为文件分配密码。 设备用户 当前登录设备的用户的用户名 " }, 
{ "title" : "对象概述 ", 
"url" : "_cds_edt_device_access_rights.html#UUID-cd3e7f33-8afc-1a1a-14eb-8436f7d0b1e8_id_ef1aea5deb3245c0a8640e00986ced_id_963abee2e14f82aec0a86312370c73c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 标签：访问权限 \/ 对象概述 ", 
"snippet" : "运行时对象 → 设备 Logger 对记录器的在线访问是只读的。因此，只有 看法 可以在此处授予或拒绝访问权限。 PlcLogic 下载期间，所有 IEC 应用程序都会自动作为子对象插入此处。删除应用程序时，该应用程序也会自动移除。 这允许对应用程序的在线访问进行特定控制。访问权限可以集中分配给所有应用程序 PLC逻辑 这 行政人员 和 开发商 用户组可以完全访问 IEC 应用程序。这 服务 和 手表 用户组只有读取权限（例如，对于值的只读监视）。 下表显示了特别是在为 IEC 应用程序授予特定访问权限时受影响的操作。 x ：必须明确设置权限。 - : 权限无关。 应用 手术 访问权 添加\/删...", 
"body" : "运行时对象 → 设备 Logger 对记录器的在线访问是只读的。因此，只有 看法 可以在此处授予或拒绝访问权限。 PlcLogic 下载期间，所有 IEC 应用程序都会自动作为子对象插入此处。删除应用程序时，该应用程序也会自动移除。 这允许对应用程序的在线访问进行特定控制。访问权限可以集中分配给所有应用程序 PLC逻辑 这 行政人员 和 开发商 用户组可以完全访问 IEC 应用程序。这 服务 和 手表 用户组只有读取权限（例如，对于值的只读监视）。 下表显示了特别是在为 IEC 应用程序授予特定访问权限时受影响的操作。 x ：必须明确设置权限。 - : 权限无关。 应用 手术 访问权 添加\/删除 执行 调整 看法 登录 - - - x 创建 x - - - 创建子对象 x - - - 删除 x - - - 下载\/在线更改 x - - - 创建引导应用程序 x - - - 读取变量 - - - x 写变量 - - x x 强制变量 - - x x 设置和删除断点 - x x - 设置下一条语句 - x x - 读取调用堆栈 - - - x 单循环 - x - - 开启流量控制 - x x - 开始\/停止 - x - - 重置 - x - - 恢复保留变量 - x - - 保存保留变量 - - - x PLCShell 只有 调整 此时评估权限。这意味着只有当 调整 已向用户组授予权限，还可以评估 PLC shell 命令。 RemoteConnections 可以在此节点下配置到控制器的其他外部连接。目前，可以在此处配置对 OPCUA 服务器的访问。 Settings 这是对控制器配置设置的在线访问。 Security Settings ：默认情况下，访问 调整 安全设置的权限仅授予管理员。 UserManagement 这是对控制器用户管理的在线访问。默认情况下，读\/写访问权限仅授予管理员。 Access Rights ：选中该对象后，可以在权限管理中配置权限 权利 看法。这意味着您可以配置允许哪个用户组简单地读取权限管理，以及允许哪个用户组更改权限管理。 Groups ：为设备用户管理的每个用户组自动创建一个单独的对象并显示在下方 团体 .选择用户组对象后，可以配置用户组的权限。这意味着您可以配置允许哪个用户组读取或修改用户组（例如，将新用户添加到用户组）。 默认情况下，对象可用于以下用户组： Administrator Developer Service Watch 这允许设置分级或受限的管理员组。例如，可以设置可视化管理员组，只能将现有用户添加到可视化用户组，不能创建新用户，也不能修改现有用户的密码。 Users ：选中该对象时，可以配置用户组对用户的权限。这意味着您可以配置允许哪个用户组读取、修改或添加用户（例如，添加新用户）。 有关详细信息，请参阅： 设备用户管理的处理X509 这控制对 X.509 证书的在线访问。这里区分了两种访问类型： 读 （ 看法 ) 写 （ 调整 ) 每个操作都分配给这两个访问权限之一。每个操作都作为子对象插入 X509 下面。因此，现在可以进一步微调每个操作的访问权限。 文件系统对象 → \/ 控制器执行路径中的所有文件夹都插入到“ \/ \" 文件系统对象。这允许您向文件系统的每个文件夹授予特定权限。 " }, 
{ "title" : "选项卡：用户和组 ", 
"url" : "_cds_edt_device_users_and_groups.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：用户和组 ", 
"snippet" : "数据保护建议 为了将违反数据安全的风险降到最低，我们建议对运行您的应用程序的系统采取以下组织和技术措施。尽可能避免将 PLC 和控制网络暴露于开放网络和 Internet。使用额外的数据链路层进行保护，例如用于远程访问的 VPN，并安装防火墙机制。仅限授权人员访问，并在初始调试期间更改任何现有的默认密码，并定期更改。 在这个选项卡上 通用设备编辑器 ，编辑PLC的设备用户管理。 根据设备的支持方式，您可以定义用户帐户和用户组。结合上的配置 访问权 选项卡，因此您可以在运行时控制对控制对象和文件的访问。 要求：控制器有一个 用户管理 并允许对其进行编辑。您拥有登录数据以便能够登录到控制器。 可以...", 
"body" : "数据保护建议 为了将违反数据安全的风险降到最低，我们建议对运行您的应用程序的系统采取以下组织和技术措施。尽可能避免将 PLC 和控制网络暴露于开放网络和 Internet。使用额外的数据链路层进行保护，例如用于远程访问的 VPN，并安装防火墙机制。仅限授权人员访问，并在初始调试期间更改任何现有的默认密码，并定期更改。 在这个选项卡上 通用设备编辑器 ，编辑PLC的设备用户管理。 根据设备的支持方式，您可以定义用户帐户和用户组。结合上的配置 访问权 选项卡，因此您可以在运行时控制对控制对象和文件的访问。 要求：控制器有一个 用户管理 并允许对其进行编辑。您拥有登录数据以便能够登录到控制器。 可以将项目用户管理中的用户帐户定义应用到设备用户管理中（见下文： 进口 按钮）。 用户 所有当前定义的用户，以及他们下面的用户组成员，都以树状结构列出。 添加 打开 添加用户 用于创建新用户帐户的对话框。有关对话框的说明，请参阅本页下方。 进口 打开 导入用户 对话。 该对话框显示在项目用户管理中定义的所有用户帐户。 选择所需条目并单击 好的 以便将它们导入设备用户管理。注意：不应用密码。 调整 打开 编辑用户 <用户名> 对话 该对话框对应于 添加用户 对话框，您可以更改用户帐户的设置。 ： 删除 删除当前选中用户的账号 团体 所有当前定义的组，以及在它们下面分配给它们的用户，都以树状结构列出。 添加 打开 添加组 对话 定义一个新的组名。从定义的用户列表中，选择属于该组的用户。点击 好的 确认选择。该组显示在树中。 进口 打开 导入用户 对话。 该对话框显示在项目用户管理中定义的所有用户组。 选择所需条目并单击 好的 以便将它们导入设备用户管理。 调整 打开 编辑组 <组名> 对话 该对话框对应于 添加组 您可以在其中更改组定义的对话框。 ： 删除 删除当前选中的组 对话框：添加用户 姓名 新用户的名字 默认组 包含所有已配置用户组的列表框 每个用户必须至少属于一个组。您在此处将其定义为“默认组”。 密码 确认密码 密码强度 密码安全范围从 非常弱 到 很好 隐藏密码 : 输入密码时，密码仅以星号“*”显示。 密码可由用户更改 首次登录时必须更改密码 密码政策 输入新密码后，有效但尚未应用的规则显示为红色。仅当满足密码策略的所有规则时，您才可以单击“确定”按钮确认对话框。有关运行时系统密码策略的更多信息，请参见： 表 34 “" }, 
{ "title" : "选项卡的工具栏 ", 
"url" : "_cds_edt_device_users_and_groups.html#UUID-3317c99f-0df2-8051-6bf2-9a5235658be0_UUID-bf0ecbfd-1dbd-5ac2-0f81-c00318625768", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：用户和组 \/ 选项卡的工具栏 ", 
"snippet" : "同步 打开和关闭编辑器与设备上的用户管理之间的同步。 如果按钮未“按下”，则编辑器为空白或包含您从硬盘加载的配置。 当您在编辑器包含尚未与设备同步的用户配置时启用同步时，系统会提示您编辑器内容应该发生什么。选项： 从设备上传并覆盖编辑器内容 ：设备上的配置被加载到编辑器中，覆盖当前内容。 将编辑器内容下载到设备并覆盖那里的用户管理 ：编辑器中的配置被传输到设备并在那里应用。 从磁盘导入 当你点击按钮上的 用户和组 选项卡导入 设备用户管理文件*.dum2 ，选择文件的默认对话框打开以从硬盘驱动器中选择设备用户管理文件。选择文件后， 输入密码 对话框打开。您必须指定导出文件时分配的密码。然后启用...", 
"body" : " 同步 打开和关闭编辑器与设备上的用户管理之间的同步。 如果按钮未“按下”，则编辑器为空白或包含您从硬盘加载的配置。 当您在编辑器包含尚未与设备同步的用户配置时启用同步时，系统会提示您编辑器内容应该发生什么。选项： 从设备上传并覆盖编辑器内容 ：设备上的配置被加载到编辑器中，覆盖当前内容。 将编辑器内容下载到设备并覆盖那里的用户管理 ：编辑器中的配置被传输到设备并在那里应用。 从磁盘导入 当你点击按钮上的 用户和组 选项卡导入 设备用户管理文件*.dum2 ，选择文件的默认对话框打开以从硬盘驱动器中选择设备用户管理文件。选择文件后， 输入密码 对话框打开。您必须指定导出文件时分配的密码。然后启用用户管理。 注意：在 V3.5 SP16 之前， 设备用户管理文件 (*.dum) 使用了不需要任何加密的文件类型。 当你点击按钮上的 访问权 选项卡导入 设备权限管理文件 *.drm ，选择文件的默认对话框打开以从硬盘驱动器中选择相应的文件。对话框中的现有配置被导入的文件覆盖。 导出到磁盘 当你点击按钮上的 用户和组 选项卡，首先是 输入密码 为设备用户管理文件分配密码的对话框打开。注意：稍后导入此文件时必须重复此密码才能在控制器上启用此用户管理。 密码分配对话框关闭后，用于从硬盘选择和导入用户管理配置的默认对话框打开。在这种情况下，文件类型是 设备用户管理文件 (*.dum2) . 注意：在 V3.5 SP16 之前， 设备用户管理文件 (*.dum) 使用了不需要任何加密的文件类型。 当你点击按钮上的 访问权 选项卡，文件类型为 设备权限管理文件 (*.drm) .在这种情况下，保存前不必为文件分配密码。 设备用户 当前登录设备的用户的用户名 " }, 
{ "title" : "选项卡：符号权限 ", 
"url" : "_cds_edt_device_symbol_rights.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：符号权限 ", 
"snippet" : "在通用设备编辑器的此选项卡上，您可以定义不同用户组（客户端）对控制器上可用的各个符号集的访问权限。 有关更多信息，请参阅： 图标配置 要求：必须在PLC上设置用户管理。将应用程序下载到控制器中，其中定义了符号集 CODESYS 项目。他们拥有登录控制器的访问数据。 在里面 符号集 查看，所有符号集都列在下面 应用 其定义与应用程序一起下载到控制器的节点。 在里面 权利 视图中定义的用户组 用户管理 表中列出了控制器。选择符号集后，您会看到相应用户组对该符号集的访问权限。 ： 授予访问权限; ： 拒绝访问。您可以通过双击该符号来更改访问权限。 点击 按钮将当前访问配置保存到 XML 文件 文件类...", 
"body" : "在通用设备编辑器的此选项卡上，您可以定义不同用户组（客户端）对控制器上可用的各个符号集的访问权限。 有关更多信息，请参阅： 图标配置 要求：必须在PLC上设置用户管理。将应用程序下载到控制器中，其中定义了符号集 CODESYS 项目。他们拥有登录控制器的访问数据。 在里面 符号集 查看，所有符号集都列在下面 应用 其定义与应用程序一起下载到控制器的节点。 在里面 权利 视图中定义的用户组 用户管理 表中列出了控制器。选择符号集后，您会看到相应用户组对该符号集的访问权限。 ： 授予访问权限; ： 拒绝访问。您可以通过双击该符号来更改访问权限。 点击 按钮将当前访问配置保存到 XML 文件 文件类型为 设备符号管理文件 (*.dsm) .点击 按钮从硬盘读取这样的文件。 " }, 
{ "title" : "选项卡：用于确定许可证的软件指标 ", 
"url" : "_cds_edt_device_licensed_software_metrics.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：用于确定许可证的软件指标 ", 
"snippet" : "此环境中的度量是与许可证计算相关的单位“值”（数量）。根据产品的不同，这可以是用户代码的大小（以字节为单位）或轴、I\/O 通道或现场总线实例的数量。 设备编辑器的选项卡显示一个树结构，其中包含可用于应用程序的指标。通过这种方式，您可以查看当前测量值并检查是否下载到控制器的代码数量超出了许可证允许的数量。许可证是为每个控制器颁发的，因此位于控制器上。许可证检查也在此处进行。 指标在下载过程中传输到控制器。单击时它们会刷新 构建 → 生成代码 对于活跃的应用程序。 从设备读取当前指标 从控制器获取和传输指标并将它们显示在 设备价值 柱子。 生成代码来计算指标 必须生成代码才能计算指标。 显示许可证...", 
"body" : "此环境中的度量是与许可证计算相关的单位“值”（数量）。根据产品的不同，这可以是用户代码的大小（以字节为单位）或轴、I\/O 通道或现场总线实例的数量。 设备编辑器的选项卡显示一个树结构，其中包含可用于应用程序的指标。通过这种方式，您可以查看当前测量值并检查是否下载到控制器的代码数量超出了许可证允许的数量。许可证是为每个控制器颁发的，因此位于控制器上。许可证检查也在此处进行。 指标在下载过程中传输到控制器。单击时它们会刷新 构建 → 生成代码 对于活跃的应用程序。 从设备读取当前指标 从控制器获取和传输指标并将它们显示在 设备价值 柱子。 生成代码来计算指标 必须生成代码才能计算指标。 显示许可证 打开 许可证 对话 对话框显示该项目所需的许可证。 在商店中打开所有内容并关闭对话框 命令打开建议的产品 CODESYS Store International 。 如果您想在 CODESYS Store North America ，那么你需要选择 北美 存储在 CODESYS 选项。 指标 每个应用程序的指标类型 项目价值 开发系统中使用的标签数量。该值是在代码生成期间测量的（ 构建 → 生成代码 命令）。 有关计算的详细信息，请参见 值的计算 部分。 注意：如果删除应用程序的编译信息，则这些值将重置为0。 最大限度。允许 根据控制器上的许可证，每个应用程序允许的最大值 设备价值 实际测量值，从控制器读取 注意：要确定这些值，通信必须有效。 " }, 
{ "title" : "值的计算 ", 
"url" : "_cds_edt_device_licensed_software_metrics.html#UUID-f3be4987-31a8-2f1c-3e97-bb89ff6c8b60_section-idm4525765148713633834737187389", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：用于确定许可证的软件指标 \/ 值的计算 ", 
"snippet" : "公制 确定值 用户代码大小 值（以字节为单位） 仅评估用户编程的代码（实现）。未使用 IEC 编译器编译的代码不会被评估。 声明中变量的数量和大小不相关。 对用户开发的 IEC 库进行代码大小评估。标准库、系统库和通信堆栈 CODESYS GmbH 不予评价。 任务组分配 对于任务配置中 IEC 任务组的配置，如果 IEC 任务在不同的 CPU 内核上执行，很多情况下需要“任务组分配”许可证。 不 ： 以下配置不需要许可证： 具有以下属性的已配置任务组 固定 固定核心 顺序固定 （仅一个 IEC 任务） 多个配置的任务组均在同一个 CPU 核心上运行 是的 ： 以下配置需要许可证： 具有以下属...", 
"body" : "公制 确定值 用户代码大小 值（以字节为单位） 仅评估用户编程的代码（实现）。未使用 IEC 编译器编译的代码不会被评估。 声明中变量的数量和大小不相关。 对用户开发的 IEC 库进行代码大小评估。标准库、系统库和通信堆栈 CODESYS GmbH 不予评价。 任务组分配 对于任务配置中 IEC 任务组的配置，如果 IEC 任务在不同的 CPU 内核上执行，很多情况下需要“任务组分配”许可证。 不 ： 以下配置不需要许可证： 具有以下属性的已配置任务组 固定 固定核心 顺序固定 （仅一个 IEC 任务） 多个配置的任务组均在同一个 CPU 核心上运行 是的 ： 以下配置需要许可证： 具有以下属性的已配置任务组 自由浮动 顺序固定 （多个 IEC 任务） 具有属性的多个配置任务组 自由浮动 顺序固定 配置多个任务组，所有任务组都在不同的 CPU 核心上运行 现场总线 , 输入\/输出通道 具有基本数据类型的映射通道数（ BOOL , INT , REAL ，...）。映射复杂数据类型时（ STRUCT , ARRAY )，统计基本数据类型的子元素个数。 如果您选择了 始终更新变量 选项，则计算中将考虑所有通道，无论它们是否分配给特定的 IEC 变量。 CANopen、Modbus、PROFIBUS 实例 使用的该类型的现场总线堆栈实例 对于 Modbus，会计算 RTU 和 TCP 模式客户端的实例。 主站\/控制器或从站\/设备在设备配置中被视为一个实例。设备树中链接到这些主站\/从站的设备不计算在内。这些是通过 I\/O 通道进行计数的。现场总线网关也算作一个实例（例外：CANopen 网关）。 EtherCAT、EtherNet\/IP、PROFINET、SAE J1939 实例 可视化标签数量 看 可视化 – 许可 软运动 看 SoftMotion – 许可 沟通 看 沟通 – 许可 有关基于应用程序的许可证的许可证包的信息，请参阅 CODESYS 商店 。 " }, 
{ "title" : "附加许可证 ", 
"url" : "_cds_edt_device_licensed_software_metrics_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 选项卡：用于确定许可证的软件指标 \/ 附加许可证 ", 
"snippet" : "只有基于应用程序的许可证才会显示在 许可证确定的软件指标 选项卡。您的应用程序可能需要本概述中未包含的附加许可证。 基于应用程序的许可证概述可以在 CODESYS 商店 。 以下列表概述了未显示在 许可证确定的软件指标 选项卡。 软运动 CODESYS SoftMotion Light CODESYS Depictor 可视化 CODESYS HMI SL Unlimited variables for CODESYS HMI SL 图书馆 Object Oriented Alarming Library (100) Object Oriented Alarming Library (200)...", 
"body" : "只有基于应用程序的许可证才会显示在 许可证确定的软件指标 选项卡。您的应用程序可能需要本概述中未包含的附加许可证。 基于应用程序的许可证概述可以在 CODESYS 商店 。 以下列表概述了未显示在 许可证确定的软件指标 选项卡。 软运动 CODESYS SoftMotion Light CODESYS Depictor 可视化 CODESYS HMI SL Unlimited variables for CODESYS HMI SL 图书馆 Object Oriented Alarming Library (100) Object Oriented Alarming Library (200) MsSQL Library SL MySQL Library SL BE KOLLMORGEN s300s700 CAN Dweet Pro Library SL STweep Formatter for CODESYS Janz Tec MQTT library for CODESYS SL JSON HTTP Client Library CODESYS IIoT Libraries SL Python Editor 现场总线 HVAC KNX SL CODESYS BACnet SL CODESYS DNP3 SL CODESYS KNX SL Universal Modbus Client Master SL 协议 IEC 60870-5-104 Server CODESYS OPC DA Server SL CODESYS IO-Link SL 工程 CODESYS Professional Developer Edition ( CODESYS Static Analysis , CODESYS Test Manager , CODESYS Profiler , CODESYS UML , CODESYS Git , CODESYS SVN ) CODESYS Redundancy SL 安全 CODESYS Safety for EtherCAT Safety Module SL " }, 
{ "title" : "标签：任务部署 ", 
"url" : "_cds_edt_device_task_deployment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 标签：任务部署 ", 
"snippet" : "这个子对话框 设备编辑器 显示输入和输出表以及它们对已定义任务的分配。 该信息仅在为应用程序生成代码后才可见。它用于故障排除，因为它显示了在具有不同优先级的多个任务中使用输入或输出的位置。多次使用可能会通过覆盖导致未定义的值。 任务的 I\/O 列表 (1) 输入\/输出通道 (2) 链接设备的所有输入和输出。显示对应于 I\/O 映射 设备编辑器的对话框。 通过双击输入或输出，您可以打开相关的 I\/O 映射编辑器。 <任务名称> (3) 为在 任务配置 .标题包含任务名称和优先级。 任务的优先级从第一列到最后一列递减。一个红十字 出现在由任务写入或读取的输入和输出的框中。此外，任务定义为 总线循环...", 
"body" : "这个子对话框 设备编辑器 显示输入和输出表以及它们对已定义任务的分配。 该信息仅在为应用程序生成代码后才可见。它用于故障排除，因为它显示了在具有不同优先级的多个任务中使用输入或输出的位置。多次使用可能会通过覆盖导致未定义的值。 任务的 I\/O 列表 (1) 输入\/输出通道 (2) 链接设备的所有输入和输出。显示对应于 I\/O 映射 设备编辑器的对话框。 通过双击输入或输出，您可以打开相关的 I\/O 映射编辑器。 <任务名称> (3) 为在 任务配置 .标题包含任务名称和优先级。 任务的优先级从第一列到最后一列递减。一个红十字 出现在由任务写入或读取的输入和输出的框中。此外，任务定义为 总线循环任务 在里面 PLC 设置 设备编辑器在这些点上用蓝色双箭头标记 象征。 鼠标单击标题单元格后，仅显示分配给此任务的 I\/O。 鼠标点击后 输入\/输出通道 单元格，再次显示所有频道。 " }, 
{ "title" : "标签：状态 ", 
"url" : "_cds_edt_device_status.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 标签：状态 ", 
"snippet" : "此选项卡的 通用设备编辑器 显示状态信息，例如“正在运行”或“已停止”，以及来自相应设备的特定诊断消息，以及有关使用的卡和内部总线系统的信息。...", 
"body" : "此选项卡的 通用设备编辑器 显示状态信息，例如“正在运行”或“已停止”，以及来自相应设备的特定诊断消息，以及有关使用的卡和内部总线系统的信息。 " }, 
{ "title" : "标签：信息 ", 
"url" : "_cds_edt_device_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：设备和通用设备编辑器 \/ 标签：信息 ", 
"snippet" : "此选项卡的 通用设备编辑器 显示来自设备描述文件的一般信息：名称、供应商、类别、版本、订单号、描述，必要时提供插图。...", 
"body" : "此选项卡的 通用设备编辑器 显示来自设备描述文件的一般信息：名称、供应商、类别、版本、订单号、描述，必要时提供插图。 " }, 
{ "title" : "对象：GVL – 全局变量列表 ", 
"url" : "_cds_obj_gvl.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：GVL – 全局变量列表 ", 
"snippet" : "GVL 象征： 全局变量列表用于声明、编辑和显示 全局变量 . 你点击 项目→添加对象→全局变量列表 将 GVL 添加到应用程序或项目中。 当您在设备树中的应用程序下方插入 GVL 时，变量将应用于此应用程序。当您在 POUs 查看，变量适用于整个项目。 您可以在 工具 → 选项 对话框，在 声明编辑器 和 文本编辑器 类别。 如果目标系统支持网络功能，那么您可以将 GVL 的变量转换为网络变量，然后使用它们与网络中的其他设备进行数据交换。为此，您必须在 网络变量 的选项卡 特性 对话。...", 
"body" : "GVL 象征： 全局变量列表用于声明、编辑和显示 全局变量 . 你点击 项目→添加对象→全局变量列表 将 GVL 添加到应用程序或项目中。 当您在设备树中的应用程序下方插入 GVL 时，变量将应用于此应用程序。当您在 POUs 查看，变量适用于整个项目。 您可以在 工具 → 选项 对话框，在 声明编辑器 和 文本编辑器 类别。 如果目标系统支持网络功能，那么您可以将 GVL 的变量转换为网络变量，然后使用它们与网络中的其他设备进行数据交换。为此，您必须在 网络变量 的选项卡 特性 对话。 " }, 
{ "title" : "对象：GVL – 全局变量列表（tasklocal） ", 
"url" : "_cds_obj_gvl_tasklocal.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：GVL – 全局变量列表（tasklocal） ", 
"snippet" : "GVL – 全局变量列表（tasklocal） 象征： 全局变量列表（tasklocal）用于全局变量的声明、编辑和显示。对于这个特殊的全局变量列表，列表中声明的变量只能由一个任务写入。所有其他任务只有只读访问权限。这可确保这些变量的值始终保持一致，即使对于多核项目也是如此。 有关更多信息，请参阅： 使用任务局部变量该对象可用于具有相应设备描述的编译器版本 3.5.13.0。 具有写入权限的任务 对变量具有独占写入权限的任务...", 
"body" : "GVL – 全局变量列表（tasklocal） 象征： 全局变量列表（tasklocal）用于全局变量的声明、编辑和显示。对于这个特殊的全局变量列表，列表中声明的变量只能由一个任务写入。所有其他任务只有只读访问权限。这可确保这些变量的值始终保持一致，即使对于多核项目也是如此。 有关更多信息，请参阅： 使用任务局部变量该对象可用于具有相应设备描述的编译器版本 3.5.13.0。 具有写入权限的任务 对变量具有独占写入权限的任务 " }, 
{ "title" : "对象：网络变量列表（发送者） ", 
"url" : "_cds_obj_nvl_send.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：网络变量列表（发送者） ", 
"snippet" : "网络变量列表（发件人） 象征： 网络变量列表（发送者）用于声明和列出应该发送到 网络变量列表（接收方） 另一个设备或网络项目。 您可以通过单击将对象添加到设备树 添加对象→网络变量列表（发送者） 的应用程序。 您可以在 添加网络变量列表（发件人） 对话框或 特性 对象上的对话框 网络变量 标签。 有关更多信息，请参阅： 配置网络变量交换对话框：添加网络变量列表（发件人） 功能 ：此对话框定义发送方 NVL 的网络属性。关闭对话框时， CODESYS 将应用程序的发送者 NVL 添加到设备树中。 称呼 ： 项目 → 添加对象 → 网络变量列表（发送方） 菜单（在设备树中选择应用程序对象时） 该对...", 
"body" : "网络变量列表（发件人） 象征： 网络变量列表（发送者）用于声明和列出应该发送到 网络变量列表（接收方） 另一个设备或网络项目。 您可以通过单击将对象添加到设备树 添加对象→网络变量列表（发送者） 的应用程序。 您可以在 添加网络变量列表（发件人） 对话框或 特性 对象上的对话框 网络变量 标签。 有关更多信息，请参阅： 配置网络变量交换对话框：添加网络变量列表（发件人） 功能 ：此对话框定义发送方 NVL 的网络属性。关闭对话框时， CODESYS 将应用程序的发送者 NVL 添加到设备树中。 称呼 ： 项目 → 添加对象 → 网络变量列表（发送方） 菜单（在设备树中选择应用程序对象时） 该对话框对应于 网络变量 选项卡中的 特性 网络变量列表对象。 " }, 
{ "title" : "对象：网络变量列表（接收者） ", 
"url" : "_cds_obj_nvl_receive.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：网络变量列表（接收者） ", 
"snippet" : "网络变量列表（接收方） 象征： 该对象用于列出接收到的 网络变量 和显示信息：网络和传输信息和发送者。 要将对象添加到应用程序，请单击 添加对象→网络变量列表（接收者） . 网络变量列表（接收器）列出了接收到的网络变量。这些接收到的网络变量，在 网络变量列表（发件人） 另一个设备或项目。您不能在对象编辑器中更改网络变量。 有关更多信息，请参阅： 配置网络变量交换对象编辑器由 2 个部分组成： 列表的发送者信息和传输日志 网络变量声明列表...", 
"body" : "网络变量列表（接收方） 象征： 该对象用于列出接收到的 网络变量 和显示信息：网络和传输信息和发送者。 要将对象添加到应用程序，请单击 添加对象→网络变量列表（接收者） . 网络变量列表（接收器）列出了接收到的网络变量。这些接收到的网络变量，在 网络变量列表（发件人） 另一个设备或项目。您不能在对象编辑器中更改网络变量。 有关更多信息，请参阅： 配置网络变量交换对象编辑器由 2 个部分组成： 列表的发送者信息和传输日志 网络变量声明列表 " }, 
{ "title" : "对话框：添加网络变量列表（接收方） ", 
"url" : "_cds_obj_nvl_receive.html#UUID-25c4fc5e-603f-f0b5-4a4f-e0f17cb6fe13_id_ffc4dc53ee3e2727c0a8640e01e914d6_id_656884cf32951609c0a8640e00d18f44", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：网络变量列表（接收者） \/ 对话框：添加网络变量列表（接收方） ", 
"snippet" : "功能 ：对话框将接收者 NVL 定义为发送者 NVL，并将接收者 NVL 添加到设备树中的应用程序对象中。 称呼 ： 项目→添加对象→网络变量列表（接收方） 菜单（选择应用程序对象时） 任务 控制要接收的变量的当前应用程序的任务 发件人 列表框 项目中另一台设备的可用发送方 NVL 从文件导入 ：如果在另一个项目中定义了必要的发件人 NVL，则需要 为此，所需的发送者 NVL 必须在另一个项目中生成为 GVL 导出文件 *.gvl 在 NVL 的属性对话框中 链接到文件 标签。 从文件导入 文件名在 GVL 导出文件 *.gvl 如果您选择了格式 从文件导入 为了 发件人...", 
"body" : "功能 ：对话框将接收者 NVL 定义为发送者 NVL，并将接收者 NVL 添加到设备树中的应用程序对象中。 称呼 ： 项目→添加对象→网络变量列表（接收方） 菜单（选择应用程序对象时） 任务 控制要接收的变量的当前应用程序的任务 发件人 列表框 项目中另一台设备的可用发送方 NVL 从文件导入 ：如果在另一个项目中定义了必要的发件人 NVL，则需要 为此，所需的发送者 NVL 必须在另一个项目中生成为 GVL 导出文件 *.gvl 在 NVL 的属性对话框中 链接到文件 标签。 从文件导入 文件名在 GVL 导出文件 *.gvl 如果您选择了格式 从文件导入 为了 发件人 " }, 
{ "title" : "对象：持久变量列表 ", 
"url" : "_cds_obj_gvl_persistent.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：持久变量列表 ", 
"snippet" : "持久变量列表 象征： 该对象在声明部分包含全局持久变量的声明 VAR_GLOBAL PERSISTENT RETAIN .. END_VAR .变量存储在特殊的非易失性存储器中。 持久性编辑器以通常的方式将变量显示为列表。显示的列表不会影响变量的持久性行为，而只会影响存储在过程映像内部的列表。那里的列表包含按时间顺序声明的所有变量。您已删除的变量用占位符标记，并继续作为间隙存在。 声明部分还可以包含实例路径，这些路径引用本地声明的持久变量并使用 声明 → 添加所有实例路径 命令。 在决定如何为应用程序设置持久性之前，熟悉本文中描述的用例会很有帮助。 数据持久化 章节。此外，如果您能够区分持久变...", 
"body" : "持久变量列表 象征： 该对象在声明部分包含全局持久变量的声明 VAR_GLOBAL PERSISTENT RETAIN .. END_VAR .变量存储在特殊的非易失性存储器中。 持久性编辑器以通常的方式将变量显示为列表。显示的列表不会影响变量的持久性行为，而只会影响存储在过程映像内部的列表。那里的列表包含按时间顺序声明的所有变量。您已删除的变量用占位符标记，并继续作为间隙存在。 声明部分还可以包含实例路径，这些路径引用本地声明的持久变量并使用 声明 → 添加所有实例路径 命令。 在决定如何为应用程序设置持久性之前，熟悉本文中描述的用例会很有帮助。 数据持久化 章节。此外，如果您能够区分持久变量、保留变量、持久性管理器的变量和配方变量的机制，这将很有帮助。 " }, 
{ "title" : "命令 ", 
"url" : "_cds_obj_gvl_persistent.html#UUID-f626a899-e7ba-9006-b7e2-0aca13999e74_id_cd97ea5ddcd609c0a8640e0075a8ef_id_4d7f128bb7520580c0a8646321d3f70d", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：持久变量列表 \/ 命令 ", 
"snippet" : "持久性编辑器中提供了以下命令： 命令： 声明 → 添加所有实例路径 命令： 声明→重新排序列表和清除差距...", 
"body" : "持久性编辑器中提供了以下命令： 命令： 声明 → 添加所有实例路径 命令： 声明→重新排序列表和清除差距 " }, 
{ "title" : "对象：POU ", 
"url" : "_cds_f_obj_pou.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU ", 
"snippet" : "POU 象征： 类型的对象 POU 是一个“编程组织单元” CODESYS 项目。控制器程序的源代码是用 POU 编写的。 有以下 POU 类型： 程序 功能 功能块 你添加一个 POU 在设备树或 POU 通过查看 项目 → 添加对象 命令。添加 POU 时，您指定 POU 类型和实现语言。 您还可以将其他编程对象（方法、操作等）添加到这些对象。 调用 POU 某些 POU 可以调用其他 POU。不允许递归。 通过命名空间调用 POU 时， CODESYS 扫描项目以查找要按以下顺序调用的 POU： 当前应用 图书馆经理 当前应用程序的 POU 看法 图书馆经理 在里面 POU 看法 如果要...", 
"body" : "POU 象征： 类型的对象 POU 是一个“编程组织单元” CODESYS 项目。控制器程序的源代码是用 POU 编写的。 有以下 POU 类型： 程序 功能 功能块 你添加一个 POU 在设备树或 POU 通过查看 项目 → 添加对象 命令。添加 POU 时，您指定 POU 类型和实现语言。 您还可以将其他编程对象（方法、操作等）添加到这些对象。 调用 POU 某些 POU 可以调用其他 POU。不允许递归。 通过命名空间调用 POU 时， CODESYS 扫描项目以查找要按以下顺序调用的 POU： 当前应用 图书馆经理 当前应用程序的 POU 看法 图书馆经理 在里面 POU 看法 如果要调用应用程序中使用的库中存在的同名 POU 并作为对象 POU 视图，则以下情况适用：没有语法允许您在 POU 仅按其名称查看。在这种情况下，您必须将库从应用程序的库管理器移动到项目的库管理器（在 POU 看法）。之后，您可以在 POU 简单地看它的名字。将命名空间添加到库时，可以调用库的 POU。 “POU”一词也用于 CODESYS 为了 POU 查看在哪里 CODESYS 管理在整个项目中有效的对象。 " }, 
{ "title" : "对话框：添加 POU ", 
"url" : "_cds_f_obj_pou.html#UUID-187a911d-cff8-20fa-f0f6-6a96a4fbedb8_section-idm4612494359414432633791667085", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对话框：添加 POU ", 
"snippet" : "功能 ：该对话框用于根据 IEC 61131-3 标准配置新的 POU。这意味着 POU 可以是程序、功能或功能块。 称呼 ： 项目 → 添加对象 菜单;上下文菜单中 设备 查看（选择应用程序时）；上下文菜单中 POU 看法 姓名 POU 的名称 类型 程序 功能块 扩展 : 基于面向对象编程思想的基本功能模块的规范或选择 指定与 扩展 功能块声明中的关键字 工具 : 基于面向对象编程思想的接口规范或选择 指定与 实施 功能块声明中的关键字 创建 POU 时，会创建通过接口定义的所有方法。 最终的 : 不允许派生访问。这意味着您不能用另一个功能块扩展该功能块。这允许优化代码生成。 抽象的 ：标...", 
"body" : "功能 ：该对话框用于根据 IEC 61131-3 标准配置新的 POU。这意味着 POU 可以是程序、功能或功能块。 称呼 ： 项目 → 添加对象 菜单;上下文菜单中 设备 查看（选择应用程序时）；上下文菜单中 POU 看法 姓名 POU 的名称 类型 程序 功能块 扩展 : 基于面向对象编程思想的基本功能模块的规范或选择 指定与 扩展 功能块声明中的关键字 工具 : 基于面向对象编程思想的接口规范或选择 指定与 实施 功能块声明中的关键字 创建 POU 时，会创建通过接口定义的所有方法。 最终的 : 不允许派生访问。这意味着您不能用另一个功能块扩展该功能块。这允许优化代码生成。 抽象的 ：标识功能块有缺失或不完整的实现，无法实例化 抽象 FB 专门用作基本功能块，实现通常发生在派生的 FB 中。如果创建了非抽象功能块，而后者又扩展了抽象功能块，则抽象基本功能块的所有抽象方法都作为（非抽象）方法添加到新功能块中。 访问说明符 民众 : 对应于无访问说明符的规范 内部的 ：对功能块的访问仅限于命名空间（库）。 方法实现语言 ：当您选择 工具 选项，您可以在此处为所有方法对象选择一种实现语言 CODESYS 通过接口的实现生成。 这 方法实现语言 不依赖于功能块的实现语言。 功能 注：不可用时 顺序功能图 (SFC) 被选为 实现语言 . 返回类型： : 返回值的数据类型 实现语言 POU 的实现语言 " }, 
{ "title" : "对象：程序 ", 
"url" : "_cds_obj_program.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：程序 ", 
"snippet" : "程序 程序是在执行时产生一个或多个值的 POU。程序执行后，直到下一次执行，所有值都保持不变。应用程序中程序的调用顺序在任务对象中定义。 您可以通过单击将对象添加到应用程序或项目中 项目→添加对象→POU .在设备树和 POU 看来，程序 POU 具有 (PRG) 后缀。 程序的编辑器由声明部分和实现部分组成。 声明部分的第一行包含以下声明： PROGRAM <program>...", 
"body" : "程序 searchresult_toplevel 程序是在执行时产生一个或多个值的 POU。程序执行后，直到下一次执行，所有值都保持不变。应用程序中程序的调用顺序在任务对象中定义。 您可以通过单击将对象添加到应用程序或项目中 项目→添加对象→POU .在设备树和 POU 看来，程序 POU 具有 (PRG) 后缀。 程序的编辑器由声明部分和实现部分组成。 声明部分的第一行包含以下声明： PROGRAM <program> " }, 
{ "title" : "调用程序 ", 
"url" : "_cds_obj_program.html#UUID-ad0a9eae-2290-5bff-bc9e-f203219c6d3b_id_f8163f81a1ed20cc0a8640e00f7941f_id_f8fc98ce4f67d6dbc0a8640e01e44c5e", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：程序 \/ 调用程序 ", 
"snippet" : "程序和功能块可以调用程序。函数中不允许程序调用。没有程序实例。 如果一个 POU 调用程序并且程序的值因此而更改，然后这些更改将保留到下一次程序调用。即使下一次调用由另一个 POU 进行，程序的值也会保留。这与调用功能块不同。调用功能块时，只有功能块的相应实例的值会发生变化。仅当 POU 再次调用同一实例时才考虑更改。 您还可以在调用程序时直接设置程序的输入和\/或输出参数。 句法： <program>(<input variable> := <value>, <output value> => <value>): 如果您使用输入助手插入程序调用并且 带参数插入 在输入助手中选择选项，然后 CO...", 
"body" : "程序和功能块可以调用程序。函数中不允许程序调用。没有程序实例。 如果一个 POU 调用程序并且程序的值因此而更改，然后这些更改将保留到下一次程序调用。即使下一次调用由另一个 POU 进行，程序的值也会保留。这与调用功能块不同。调用功能块时，只有功能块的相应实例的值会发生变化。仅当 POU 再次调用同一实例时才考虑更改。 您还可以在调用程序时直接设置程序的输入和\/或输出参数。 句法： <program>(<input variable> := <value>, <output value> => <value>): 如果您使用输入助手插入程序调用并且 带参数插入 在输入助手中选择选项，然后 CODESYS 根据语法向程序调用添加输入和\/或输出参数。 例子 来电： 锥子： 分配参数： 英石： PLC_PRG()\nerg := PLC_PRG.out2; 分配参数： PLC_PRG(in1:=2, out1=>erg); " }, 
{ "title" : "对象：功能块 ", 
"url" : "_cds_obj_function_block.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：功能块 ", 
"snippet" : "功能块 功能块是在执行时产生一个或多个值的 POU。 通过单击将对象添加到应用程序或项目中 项目→添加对象→POU .在设备树或 POU 查看，功能块 POU 具有 (FB) 后缀。 它总是通过作为功能块副本的实例调用功能块。 功能块的编辑器由声明部分和实现部分组成。 输出变量和内部变量的值在执行后保持不变，直到下一次执行。这意味着功能块不必为具有相同输入变量的多次调用返回相同的输出值。 除了 IEC 61131-3 中描述的功能外，您还可以在 CODESYS 面向对象编程的以下功能： 延期 功能块的 执行 接口数 方法 特性 声明部分的第一行包含以下声明： FUNCTION_BLOCK <a...", 
"body" : "功能块 功能块是在执行时产生一个或多个值的 POU。 通过单击将对象添加到应用程序或项目中 项目→添加对象→POU .在设备树或 POU 查看，功能块 POU 具有 (FB) 后缀。 它总是通过作为功能块副本的实例调用功能块。 功能块的编辑器由声明部分和实现部分组成。 输出变量和内部变量的值在执行后保持不变，直到下一次执行。这意味着功能块不必为具有相同输入变量的多次调用返回相同的输出值。 除了 IEC 61131-3 中描述的功能外，您还可以在 CODESYS 面向对象编程的以下功能： 延期 功能块的 执行 接口数 方法 特性 声明部分的第一行包含以下声明： FUNCTION_BLOCK <access specifier> <function block> \\| EXTENDS <function block> \\| IMPLEMENTS <comma-separated list of interfaces> " }, 
{ "title" : "调用功能块 ", 
"url" : "_cds_obj_function_block.html#UUID-bd14b797-a7fe-0201-278a-491e9af37040_id_a70a3a130569cc4fc0a8640e01f8feef_id_fdfeb24e4f64721fc0a8640e01ba60f7", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：功能块 \/ 调用功能块 ", 
"snippet" : "调用总是通过功能块的实例进行的。调用功能块时，只有相应实例的值会发生变化。 实例声明： <instance> : <function block>; 您可以在实现部分访问功能块的变量，如下所示： <instance> . <variable> 请注意以下事项： 您只能从功能块实例外部访问功能块的输入和输出变量，而不能访问内部变量。 对功能块实例的访问仅限于声明该实例的 POU，除非您已全局声明该实例。 您可以在调用实例时将所需的值分配给功能块变量。 例子 访问功能块变量： 功能块 FB1 有输入变量 iVar1 类型 INT 和输出变量 out1 .下面，变量 iVar1 从程序中调用 Pro...", 
"body" : "调用总是通过功能块的实例进行的。调用功能块时，只有相应实例的值会发生变化。 实例声明： <instance> : <function block>; 您可以在实现部分访问功能块的变量，如下所示： <instance> . <variable> 请注意以下事项： 您只能从功能块实例外部访问功能块的输入和输出变量，而不能访问内部变量。 对功能块实例的访问仅限于声明该实例的 POU，除非您已全局声明该实例。 您可以在调用实例时将所需的值分配给功能块变量。 例子 访问功能块变量： 功能块 FB1 有输入变量 iVar1 类型 INT 和输出变量 out1 .下面，变量 iVar1 从程序中调用 Prog . PROGRAM Prog\nVAR\ninst1 : FB1;\nEND_VAR\n\ninst1.iVar1 := 33; (* FB1 is called and the value 33 is assigned to the variable iVar1 *)\n\ninst1(); (* FB1 is called, that's necessary for the following access to the output variable *)\n\nires := inst1.out1 (* the output variable out1 of the FB1 is read *) 在 FBD 中： 调用时分配变量值： 在文本语言 IL 和 ST 中，您可以在调用功能块时直接为输入和\/或输出变量赋值。 将值分配给输入变量 := . 将值分配给输出变量 => . 例子 实例 CMD_TMR 定时器功能块的调用与输入变量的分配 IN 和 PT .然后输出变量 Q 定时器的赋值给变量 A . PROGRAM PLC_PRG\nVAR\n CMD_TMR : TOF;\nEND_VAR\n\nCMD_TMR(IN := %IX5.1, PT := T#100MS);\nA := CMD_TMR.Q; 当您通过 输入助手 并选择 带参数插入 中的选项 输入助手 对话， CODESYS 插入带有所有输入和输出变量的调用。然后您只需插入所需的值分配。在上面的例子中， CODESYS 插入调用如下： CMD_TMR (IN:= ,PT:= , Q=> ) . 您可以使用 '已连接' 局部变量上的属性，以确定在功能块实例中调用时特定输入是否接收外部赋值。 " }, 
{ "title" : "对象：函数 ", 
"url" : "_cds_obj_function.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：函数 ", 
"snippet" : "功能 一个函数是一个 POU 它在执行时只提供一个数据元素，并且在文本语言中的调用可以作为表达式中的运算符出现。数据元素也可以是数组或结构。 通过单击将对象添加到应用程序或项目中 项目→添加对象→POU .在设备树或 POU 看来，功能 POU 有 （乐趣） 后缀。 函数没有内部状态信息，这意味着函数在下一次调用之前不会保存其变量的值。调用具有相同输入变量值的函数始终提供相同的输出值。因此，函数不能使用全局变量和地址。 函数的编辑器由声明部分和实现部分组成。 声明部分的第一行包含以下声明： FUNCTION <function> : <data type> 在此之下，您声明输入和函数变量。 函...", 
"body" : "功能 一个函数是一个 POU 它在执行时只提供一个数据元素，并且在文本语言中的调用可以作为表达式中的运算符出现。数据元素也可以是数组或结构。 通过单击将对象添加到应用程序或项目中 项目→添加对象→POU .在设备树或 POU 看来，功能 POU 有 （乐趣） 后缀。 函数没有内部状态信息，这意味着函数在下一次调用之前不会保存其变量的值。调用具有相同输入变量值的函数始终提供相同的输出值。因此，函数不能使用全局变量和地址。 函数的编辑器由声明部分和实现部分组成。 声明部分的第一行包含以下声明： FUNCTION <function> : <data type> 在此之下，您声明输入和函数变量。 函数的输出变量是函数名。 如果在函数中声明局部变量为 RETAIN ，这没有效果。在这种情况下， CODESYS 发出编译器错误。 您不能在函数调用中混合显式和隐式参数赋值 CODESYS V3 .这意味着您必须在函数调用中仅使用显式或仅使用隐式参数赋值。调用函数时参数赋值的顺序是任意的。 " }, 
{ "title" : "调用函数 ", 
"url" : "_cds_obj_function.html#UUID-031b5d94-7e37-be07-c3ea-2dd9a75bdc3a_id_d8edec4a146076cec0a8640e0081effa_id_f9f95a4f1a50ad0ac0a8640e0134f3b9", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：函数 \/ 调用函数 ", 
"snippet" : "在 ST 中，您可以将函数的调用用作表达式中的操作数。 在 SFC 中，只能在步操作或转移中使用函数调用。 例子 带有声明部分和一行实现代码的函数 函数调用： 英石： result := POU_Funct(5,3,22); 伊利诺伊： FBD：...", 
"body" : "在 ST 中，您可以将函数的调用用作表达式中的操作数。 在 SFC 中，只能在步操作或转移中使用函数调用。 例子 带有声明部分和一行实现代码的函数 函数调用： 英石： result := POU_Funct(5,3,22); 伊利诺伊： FBD： " }, 
{ "title" : "具有附加输出的功能 ", 
"url" : "_cds_obj_function.html#UUID-031b5d94-7e37-be07-c3ea-2dd9a75bdc3a_id_d8edec4a146076cec0a8640e0081effa_id_d39a416b1a50ad0bc0a8640e0141d1c9", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：函数 \/ 具有附加输出的功能 ", 
"snippet" : "根据 IEC 61131-3 标准，函数可以有附加输出。您在关键字之间的函数中声明附加输出 VAR_OUTPUT 和 END_VAR .该函数根据以下语法调用： <function> (<function output variable1> => <output variable 1>, <function output variable n> => <output variable n>) 例子 这 fun 函数用两个输入变量定义 in1 和 in2 .的输出变量 fun 函数被写入本地声明的输出变量 loc1 和 loc2 . fun(in1 := 1, in2 := 2, out1 =>...", 
"body" : "根据 IEC 61131-3 标准，函数可以有附加输出。您在关键字之间的函数中声明附加输出 VAR_OUTPUT 和 END_VAR .该函数根据以下语法调用： <function> (<function output variable1> => <output variable 1>, <function output variable n> => <output variable n>) 例子 这 fun 函数用两个输入变量定义 in1 和 in2 .的输出变量 fun 函数被写入本地声明的输出变量 loc1 和 loc2 . fun(in1 := 1, in2 := 2, out1 => loc1, out2 => loc2); " }, 
{ "title" : "对象：接口 ", 
"url" : "_cds_obj_interface.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：接口 ", 
"snippet" : "界面 象征： 关键词： INTERFACE 接口是面向对象编程的一种手段。物体 ITF 描述了一组方法和属性原型。在这种情况下，原型意味着 方法 和 特性 只包含声明，不包含实现。 这允许以相同方式使用具有共同属性的不同功能块。一个 国际乒联 通过单击将对象添加到应用程序或项目中 项目→添加对象→接口 有关更多信息，请参阅： 实现一个接口添加接口 遗产 姓名 接口名称 先进的 ：扩展您在输入字段中或通过输入助手选择的界面 .这意味着扩展新接口的接口的所有方法在新接口中也可用。 有关更多信息，请参阅： 扩展接口接口支持多重继承。 您可以添加 接口属性 和 接口方法 对象 国际乒联 目的。接口方法...", 
"body" : "界面 象征： 关键词： INTERFACE 接口是面向对象编程的一种手段。物体 ITF 描述了一组方法和属性原型。在这种情况下，原型意味着 方法 和 特性 只包含声明，不包含实现。 这允许以相同方式使用具有共同属性的不同功能块。一个 国际乒联 通过单击将对象添加到应用程序或项目中 项目→添加对象→接口 有关更多信息，请参阅： 实现一个接口添加接口 遗产 姓名 接口名称 先进的 ：扩展您在输入字段中或通过输入助手选择的界面 .这意味着扩展新接口的接口的所有方法在新接口中也可用。 有关更多信息，请参阅： 扩展接口接口支持多重继承。 您可以添加 接口属性 和 接口方法 对象 国际乒联 目的。接口方法可能只包含输入、输出和 VAR_IN_OUT 变量的声明，但没有实现。 为了让程序中也能使用接口，必须有实现这个接口的功能块。 这意味着： 功能块在其声明部分的 IMPLEMENTS 列表中包含接口 功能块包含接口的所有方法和属性原型的实现 一个功能块可以实现一个或多个接口。您可以使用具有相同参数的相同方法，但在不同的功能块中使用不同的实现代码。 请注意以下事项： 您不得在接口中定义变量。接口没有实现部分，也没有动作。只定义了一组方法，您可以在其中只定义输入、输出和 VAR_IN_OUT 变量。 CODESYS 始终将使用接口类型声明的变量视为引用。 实现接口的功能块必须包含接口方法的实现代码。您已完全按照接口中的方法命名方法，并且方法包含与接口中相同的输入、输出和 VAR_IN_OUT 变量。 接口参考和在线更改 编译器版本 < 3.4.1.0 可能会发生以下情况： 如果一个功能块因为添加或删除变量，或者因为变量类型改变而改变了它的数据，那么 CODESYS 将功能块的所有实例复制到新的内存位置。然而，在这种情况下，接口引用不是指新的内存位置，而是指旧的内存位置。 如果编译器版本 >= 3.4.1.0， CODESYS 自动重新寻址接口引用，以便 CODESYS 如果在线更改，还会引用正确的接口。 CODESYS 需要额外的代码和更多的时间，因此可能会出现抖动问题，具体取决于相关对象的数量。所以， CODESYS 显示在执行在线更改之前相关的变量和接口引用的数量，然后您可以决定是否应该执行或中止在线更改。 例子 接口的定义及其在功能块中的使用 您已插入接口 国际乒联 在应用程序下方。接口包含方法 方法1 和 方法2 . 国际乒联 , 方法1 和 方法2 不包含实现代码。您只在方法的声明部分插入所需的变量声明。 如果您随后在实现接口的设备树中插入功能块 国际乒联 , CODESYS 自动也插入方法 方法1 和 方法2 在功能块下。在这里，您可以在方法中实现特定于功能块的代码。 " }, 
{ "title" : "对象：方法 ", 
"url" : "_cds_obj_method.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：方法 ", 
"snippet" : "方法 象征： 关键词： METHOD 方法是 IEC 61131-3 标准的扩展，是面向对象编程的工具，用于数据封装。方法包含声明和实现。但是，与函数不同的是，方法不是独立的 POU，它从属于功能块或程序。方法可以访问上级 POU 的所有有效变量。 您可以在程序或功能块下方添加方法。点击 项目 → 添加对象 → 方法 .然后 添加方法 对话框打开。 您可以使用接口来组织方法。 有关详细信息，请参阅： 实现一个接口当您将方法复制到 POU 下并将其添加到接口下，或将方法移到那里时，包含的实现将自动删除。...", 
"body" : "方法 象征： 关键词： METHOD 方法是 IEC 61131-3 标准的扩展，是面向对象编程的工具，用于数据封装。方法包含声明和实现。但是，与函数不同的是，方法不是独立的 POU，它从属于功能块或程序。方法可以访问上级 POU 的所有有效变量。 您可以在程序或功能块下方添加方法。点击 项目 → 添加对象 → 方法 .然后 添加方法 对话框打开。 您可以使用接口来组织方法。 有关详细信息，请参阅： 实现一个接口当您将方法复制到 POU 下并将其添加到接口下，或将方法移到那里时，包含的实现将自动删除。 " }, 
{ "title" : "宣言 ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_1a9cda980d7f5306c0a86463246390b7", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：方法 \/ 宣言 ", 
"snippet" : "句法： METHOD <access specifier> <method name> : <type of return value> <access specifier> 选修的 访问说明符 根据声明的访问说明符，方法只能在其自己的命名空间内调用（ INTERNAL ), 仅在其自身的 POU 及其衍生品中 ( PROTECTED ), 或者只在它自己的 POU ( PRIVATE ).为了 PUBLIC ，可以从任何地方调用该方法。 <method name> 方法标识符 <type of retur value> 选修的 方法的返回类型 注意：对于没有显式返回类型的方法，第一个声明的输...", 
"body" : "句法： METHOD <access specifier> <method name> : <type of return value> <access specifier> 选修的 访问说明符 根据声明的访问说明符，方法只能在其自己的命名空间内调用（ INTERNAL ), 仅在其自身的 POU 及其衍生品中 ( PROTECTED ), 或者只在它自己的 POU ( PRIVATE ).为了 PUBLIC ，可以从任何地方调用该方法。 <method name> 方法标识符 <type of retur value> 选修的 方法的返回类型 注意：对于没有显式返回类型的方法，第一个声明的输出用作返回值。仅当既未声明返回类型也未声明输出时，方法才不会返回值。但是，在任何一种情况下都不会生成编译器错误。 变量声明（参数）的可能范围 <scope list> 适用范围： VAR_IN_OUT <variable declaration list> END_VAR 对于输入\/输出变量的变量声明 VAR_INPUT <variable declaration list> END_VAR 对于输入的变量声明 VAR_OUTPUT <variable declaration list> END_VAR 对于输出的变量声明 与函数一样，方法可以有额外的输出。调用该方法时，您还需要将参数（变量）传递给其他输出。 VAR <variable declaration list> END_VAR 用于本地目的的变量声明 <variable declaration list> 变量声明 <variable name> : <data type> := <initial value> ; 根据用途分配给范围的以分号分隔的变量（参数）列表。 输入和输入\/输出的变量可以有一个初始值分配给他们 初始值的分配是可选的。但是，如果指定了一个，则在调用该方法时可以省略为此参数传递的参数。这些类型的参数称为可选参数。 方法的变量（参数）包含仅在方法执行期间有效的临时数据（堆栈变量）。每次调用该方法时，都会重新初始化方法中声明和实现的所有变量。 例子 宣言 METHOD PUBLIC DoIt : BOOL\nVAR_INPUT\n iInput_1 : DWORD;\n iInput_2 : DWORD;\n sInput_3 : STRING(12);\nEND_VAR " }, 
{ "title" : "执行 ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_d5a78e4a116f11e8b6e4d1a39d87c360", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：方法 \/ 执行 ", 
"snippet" : "选修的 允许访问功能块实例或程序变量以实现该方法。 这 这 指针允许访问它自己的功能块实例。因此，仅在分配给功能块的方法中才允许使用指针。 一个方法无法访问 VAR_TEMP 值 功能块的变量。 方法可以递归调用自身。 接口方法没有实现 接口方法 可以声明输入、输出和 VAR_IN_OUT 变量，但不包含实现。...", 
"body" : "选修的 允许访问功能块实例或程序变量以实现该方法。 这 这 指针允许访问它自己的功能块实例。因此，仅在分配给功能块的方法中才允许使用指针。 一个方法无法访问 VAR_TEMP 值 功能块的变量。 方法可以递归调用自身。 接口方法没有实现 接口方法 可以声明输入、输出和 VAR_IN_OUT 变量，但不包含实现。 " }, 
{ "title" : "调用方法 ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_7f4f002a7a7c22c7c0a864630de7909a", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：方法 \/ 调用方法 ", 
"snippet" : "调用语法： <return value variable> := <POU name> . <method name> ( <argument passing> ); <return value variable> 返回值的变量 该类型必须与方法的返回类型相匹配。 注意：对于没有显式返回类型的方法，第一个声明的输出用作返回值。仅当既未声明返回类型也未声明输出时，方法才不会返回值。但是，在任何一种情况下都不会生成编译器错误。 <POU name> 安排方法的功能块实例的标识符 <method name> 方法标识符 <argument passing> 带实际参数的逗号分隔列表 一个参数被传递给...", 
"body" : "调用语法： <return value variable> := <POU name> . <method name> ( <argument passing> ); <return value variable> 返回值的变量 该类型必须与方法的返回类型相匹配。 注意：对于没有显式返回类型的方法，第一个声明的输出用作返回值。仅当既未声明返回类型也未声明输出时，方法才不会返回值。但是，在任何一种情况下都不会生成编译器错误。 <POU name> 安排方法的功能块实例的标识符 <method name> 方法标识符 <argument passing> 带实际参数的逗号分隔列表 一个参数被传递给方法的每个参数（变量）： <parameter name> := <actual argument> 每个声明的输入\/输出或输入都分配有实际参数。参数可以是值（文字）、表达式或具有匹配类型的变量。 实际参数（相同类型的变量）分配给每个声明的输出分配。参数必须是具有匹配类型的变量。 可以省略为输入或输入\/输出传递参数。 因此，列表中的参数数量可能少于参数数量（输入范围或输入\/输出）。特别是，如果它是在声明中指定了默认值或初始值的可选参数，则可以省略传递参数。 提示：如果您在调用该方法时从输入助手获得帮助，那么它会通知您现有的初始值。 传递带有名称和赋值运算符的参数规范的参数是可选的。 仅指定参数就足够了。声明中变量的顺序决定了将哪个参数传递给哪个参数。 例子 宣言 METHOD PUBLIC DoIt : BOOL\nVAR_INPUT\n iInput_1 : DWORD;\n iInput_2 : DWORD;\n sInput_3 : STRING(12);\nEND_VAR 通过将参数传递给参数来调用 bFinishedMethod := fbInstance.DoIt(sInput_3 := 'Hello World ', iInput_2 := 16#FFFF, iInput_1 := 16); 当方法被调用时，方法的返回值被分配给一个本地声明的变量。 例子 如果省略输入变量的名称，则参数的赋值将根据声明顺序进行。 宣言 METHOD PUBLIC DoIt : BOOL\nVAR_INPUT\n iInput_1 : DWORD;\n iInput_2 : DWORD;\n sInput_3 : STRING(12);\nEND_VAR\nIF iInput_1 = iInput_2 THEN\n\tDoIt := TRUE; \/\/ explicit return value\nEND_IF\n\n 根据声明中的顺序传递参数进行调用 bFinishedMethod := fbInstance.DoIt( 16, 16#0010,'Hello World '); " }, 
{ "title" : "递归方法调用 ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_421cb3a8093e22bac0a8640e01a50890", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：方法 \/ 递归方法调用 ", 
"snippet" : "在实现中，方法可以调用自身，或者直接通过 这 指针，或通过分配功能块的局部变量。 <return value variable> := <POU name> . <method name> ( <argument passing> ); 直接调用相关功能块实例 THIS 指针 <return value variable> := <POU name> . <method name> ( <argument passing> ); 通过临时实例化相关功能块的方法的局部变量调用 在递归的情况下发出编译器警告 称呼 .如果该方法随 pragma 一起提供 {attribute 'estimated-...", 
"body" : "在实现中，方法可以调用自身，或者直接通过 这 指针，或通过分配功能块的局部变量。 <return value variable> := <POU name> . <method name> ( <argument passing> ); 直接调用相关功能块实例 THIS 指针 <return value variable> := <POU name> . <method name> ( <argument passing> ); 通过临时实例化相关功能块的方法的局部变量调用 在递归的情况下发出编译器警告 称呼 .如果该方法随 pragma 一起提供 {attribute 'estimated-stack-usage' := '<estimated stack size in bytes>'} , 然后编译器警告被抑制。 有关实现示例，请参阅“属性： '估计堆栈使用' “ 章节。 要递归调用方法，仅指定方法名称是不够的。如果仅指定了方法名称，则会发出编译器错误： 期望程序名称、功能或功能块实例而不是 " }, 
{ "title" : "功能块的特殊方法 ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_1c08ae16e567f9b0c0a8640e008b85b9", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：方法 \/ 功能块的特殊方法 ", 
"snippet" : "FB_Init 声明自动隐式，但也可以显式声明 包含功能块的初始化代码，在功能块的声明部分中定义 FB_Reinit 明确声明是必要的。 在复制功能块的实例后调用（如在线更改期间）。它重新初始化新的实例模块。 FB_Exit 明确声明是必要的。 在新下载或重置之前或在所有移动或删除的实例的在线更改期间调用功能块的每个实例。 特性 提供 Set 和\/或 Get 访问器方法。...", 
"body" : "FB_Init 声明自动隐式，但也可以显式声明 包含功能块的初始化代码，在功能块的声明部分中定义 FB_Reinit 明确声明是必要的。 在复制功能块的实例后调用（如在线更改期间）。它重新初始化新的实例模块。 FB_Exit 明确声明是必要的。 在新下载或重置之前或在所有移动或删除的实例的在线更改期间调用功能块的每个实例。 特性 提供 Set 和\/或 Get 访问器方法。 " }, 
{ "title" : "对话： 添加方法 ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_9181172594148571c0a864634fbe4313", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：方法 \/ 对话： 添加方法 ", 
"snippet" : "功能 : 定义对话框关闭时所选 POU 下面的方法。 称呼 ： 项目→添加对象→方法 ;上下文菜单 要求 ：一个程序（ PRG ) 或功能块 ( FUNCTION_BLOCK ) 被选择在 POU 查看或 设备 看法。 在派生功能块下方插入同名方法时，复制在基本功能块下方插入的方法的接口。 姓名 例子： meth_DoIt . 标准方法 FB_Init 和 FB_Exit 如果它们尚未插入 POU 下方，则在列表框中提供。如果是派生功能块，那么列表框也提供了基本功能块的所有方法。 返回类型 返回值的默认数据类型或结构化数据类型 例子： BOOL 实现语言 例子： 结构化文本 (ST) 访问说明...", 
"body" : "功能 : 定义对话框关闭时所选 POU 下面的方法。 称呼 ： 项目→添加对象→方法 ;上下文菜单 要求 ：一个程序（ PRG ) 或功能块 ( FUNCTION_BLOCK ) 被选择在 POU 查看或 设备 看法。 在派生功能块下方插入同名方法时，复制在基本功能块下方插入的方法的接口。 姓名 例子： meth_DoIt . 标准方法 FB_Init 和 FB_Exit 如果它们尚未插入 POU 下方，则在列表框中提供。如果是派生功能块，那么列表框也提供了基本功能块的所有方法。 返回类型 返回值的默认数据类型或结构化数据类型 例子： BOOL 实现语言 例子： 结构化文本 (ST) 访问说明符 控制对数据的访问。 民众 或未指定：访问不受限制。 私人的 ：访问仅限于程序、功能块或 GVL。 该对象被标记为 (private) 在 POU 或设备视图中。声明包含关键字 PRIVATE . 受保护 : 访问仅限于程序、功能块或 GVL 及其派生。声明包含关键字 PROTECTED . 该对象被标记为 (protected) 在 POU 或设备视图中。 内部的 ：对该方法的访问仅限于命名空间（库）。 该对象被标记为 (internal) 在 POU 或设备视图中。声明包含关键字 INTERNAL . 抽象的 ：标识该方法没有实现，并且该实现由派生的FB提供。 添加 在选定对象下方添加一个新方法。 " }, 
{ "title" : "生成继承 POU 时的输入支持 ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_UUID-e3a7d561-c8bd-ff0c-4eda-2e6419e8e10f", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：方法 \/ 对话： 添加方法 \/ 生成继承 POU 时的输入支持 ", 
"snippet" : "当你进行面向对象的编程并使用继承时 ( EXTENDS  关键字）的 POU，您可以通过以下方式获得支持： 当您在派生自基本 POU 的 POU 下插入操作、属性、方法或转换时， 添加 … 对话框打开。然后名称的输入字段扩展到一个列表框。列表框包含从基本 POU 中可用的动作、属性、方法或转换中进行的有效选择。例如，现在您可以轻松地接受基本 POU 的方法，然后将其调整为 POU 的派生函数。 带有访问修饰符的方法和属性 PRIVATE 此处未列出，因为它们也不是继承的。带有访问修饰符的方法和属性 PUBLIC 接受派生的 POU 时自动获得一个空白的访问修饰符字段，这在功能上意味着相同的事情...", 
"body" : "当你进行面向对象的编程并使用继承时 ( EXTENDS  关键字）的 POU，您可以通过以下方式获得支持： 当您在派生自基本 POU 的 POU 下插入操作、属性、方法或转换时， 添加 … 对话框打开。然后名称的输入字段扩展到一个列表框。列表框包含从基本 POU 中可用的动作、属性、方法或转换中进行的有效选择。例如，现在您可以轻松地接受基本 POU 的方法，然后将其调整为 POU 的派生函数。 带有访问修饰符的方法和属性 PRIVATE 此处未列出，因为它们也不是继承的。带有访问修饰符的方法和属性 PUBLIC 接受派生的 POU 时自动获得一个空白的访问修饰符字段，这在功能上意味着相同的事情。 有关更多信息，请参阅： 财产， 方法， 过渡， 行动， 例子 " }, 
{ "title" : "对象：接口方法 ", 
"url" : "_cds_obj_interface_method.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：接口方法 ", 
"snippet" : "接口方法 象征： 该对象用于面向对象的编程。 您添加 接口方法 对象被添加到 界面 通过 项目 → 添加对象 命令。 如果在接口下插入方法，则可以在此添加和实例化变量声明（输入、输出和输入\/输出变量） 方法 . 只有当一个功能块时，程序代码才能添加到方法中 工具 方法所属的接口。 CODESYS 然后将该方法插入功能块下方。...", 
"body" : "接口方法 象征： 该对象用于面向对象的编程。 您添加 接口方法 对象被添加到 界面 通过 项目 → 添加对象 命令。 如果在接口下插入方法，则可以在此添加和实例化变量声明（输入、输出和输入\/输出变量） 方法 . 只有当一个功能块时，程序代码才能添加到方法中 工具 方法所属的接口。 CODESYS 然后将该方法插入功能块下方。 " }, 
{ "title" : "对象：接口属性 ", 
"url" : "_cds_obj_interface_property.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：接口属性 ", 
"snippet" : "接口属性 象征： 接口属性是 IEC 61131-3 标准的扩展，是面向对象编程的工具。接口属性声明访问器方法 Get 和 Set （没有实现代码）。因此，实现一个功能块 界面 也继承了它们的接口属性。 您可以将接口属性添加到接口的设备树中。然后使用访问器方法扩展接口 Get 和 Set .这 Get 访问器用于读取访问。这 Set 访问器用于写访问。您可以删除不需要的访问器。点击 项目→添加对象→接口属性 .添加访问器。这 添加接口属性 对话框打开。 例子 接口属性的声明和实现 Literal_A 界面 itf_A 有财产 Literal_A 使用访问器方法 Get 和 Set . 功能块 ...", 
"body" : "接口属性 象征： 接口属性是 IEC 61131-3 标准的扩展，是面向对象编程的工具。接口属性声明访问器方法 Get 和 Set （没有实现代码）。因此，实现一个功能块 界面 也继承了它们的接口属性。 您可以将接口属性添加到接口的设备树中。然后使用访问器方法扩展接口 Get 和 Set .这 Get 访问器用于读取访问。这 Set 访问器用于写访问。您可以删除不需要的访问器。点击 项目→添加对象→接口属性 .添加访问器。这 添加接口属性 对话框打开。 例子 接口属性的声明和实现 Literal_A 界面 itf_A 有财产 Literal_A 使用访问器方法 Get 和 Set . 功能块 fb_A1 和 fb_A2 实现接口 itf_A 因此继承其接口属性。每个 FB 都有自己的实现。 界面 itf_A INTERFACE itf_A\nVAR\nEND_VAR\nPROPERTY Literal_A : STRING 脸书 fb_A1 FUNCTION_BLOCK fb_A1 IMPLEMENTS itf_A\nVAR\n str_1 : STRING;\n str_2 : STRING;\n iCnt : INT;\nEND_VAR\niCnt := iCnt + 1;\n\nstr_1 := 'Function block A1'; 存取器 fb_A1.Literal_A.Get VAR\nEND_VAR\nLiteral_A := CONCAT (str_1,' and property.'); 存取器 fb_A1.Literal_A.Set VAR\nEND_VAR\nstr_2 := Literal_A; 脸书 fb_A2 FUNCTION_BLOCK fb_A2 IMPLEMENTS itf_A\nVAR\n str_1 : STRING;\n str_2 : STRING;\n iCnt : INT;\nEND_VAR\n\niCnt := iCnt + 1;\nstr_1 := 'Function block A2'; 存取器 fb_A2.Literal_A.Get VAR\nEND_VAR\nLiteral_A := str_1; 存取器 fb_A2.Literal_A.Set VAR\nEND_VAR\nstr_2 := Literal_A; 程序 PLC_PRG PROGRAM PLC_PRG\nVAR\n iCnt : INT;\n my_1 : fb_A1;\n my_2 : fb_A2;\n strName_1 : STRING;\n strName_2: STRING;\nEND_VAR\n\niCnt := iCnt + 1;\nmy_1();\nmy_2();\nstrName_1:= my_1.Literal_A;\nstrName_2:= my_2.Literal_A;\nmy_1.Literal_A := 'Hello 1';\nmy_2.Literal_A := 'World 2'; 这导致以下监控 PLC_PRG 在应用程序运行时： " }, 
{ "title" : "对象：财产 ", 
"url" : "_cds_obj_property.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：财产 ", 
"snippet" : "财产 象征： 关键词： PROPERTY 属性是 IEC 61131-3 标准的扩展，是面向对象编程的工具。 属性用于数据封装，因为它们允许外部访问数据并同时充当过滤器。为此，属性提供了访问器方法 Get 和 Set 它允许对属性下方实例的数据进行读写访问。 您可以在程序、功能块或全局变量列表下方添加带有访问器方法的属性。点击 项目→添加对象→属性 打开 添加属性 对话。 您可以添加一个 接口属性 界面下方。 当您复制插入到 POU 下方的属性并将其添加到接口下方时，或者如果您将属性移到那里，包含的实现将自动删除。 在线模式下监控属性 下列 语用 用于在线模式下监控属性。您将它们插入到属性定义...", 
"body" : "财产 象征： 关键词： PROPERTY 属性是 IEC 61131-3 标准的扩展，是面向对象编程的工具。 属性用于数据封装，因为它们允许外部访问数据并同时充当过滤器。为此，属性提供了访问器方法 Get 和 Set 它允许对属性下方实例的数据进行读写访问。 您可以在程序、功能块或全局变量列表下方添加带有访问器方法的属性。点击 项目→添加对象→属性 打开 添加属性 对话。 您可以添加一个 接口属性 界面下方。 当您复制插入到 POU 下方的属性并将其添加到接口下方时，或者如果您将属性移到那里，包含的实现将自动删除。 在线模式下监控属性 下列 语用 用于在线模式下监控属性。您将它们插入到属性定义的顶部位置： {attribute 'monitoring' := 'variable'} 每次访问该属性时， CODESYS 将实际值保存到变量并显示该变量的值。如果代码中不再对该属性进行访问，则此值可能会过时。 {attribute 'monitoring' := 'call'} 每一次 显示值， CODESYS 调用代码 Get 访问者。如果此代码包含副作用，则监控会执行副作用。 您可以借助以下功能监控属性。 在线监控 要求： 启用在线监控 选项被选中 文本编辑器 的类别 选项 对话。 观察名单 " }, 
{ "title" : "对话框：添加属性 ", 
"url" : "_cds_obj_property.html#UUID-9c407fa5-d8b8-4172-1c22-5219eeec8317_id_b08bdbd0d86c0a8640e00400511_id_bf40a4d8ef1988a5c0a864636ff3b754", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：财产 \/ 对话框：添加属性 ", 
"snippet" : "功能 : 当对话框关闭时，在选定的 POU 下创建一个新属性。 称呼 ： 项目→添加对象→属性 ;上下文菜单 要求 ：一个程序（ PRG ), 一个功能块 ( FUNCTION_BLOCK ) 或全局变量列表 ( GVL ) 被选择在 POU 查看或 设备 看法。 姓名 属性的名称（标识符） 例子： prop_iA 返回类型 返回值的默认类型或结构化类型 例子： INT 实现语言 例子： 结构化文本 (ST) 访问说明符 控制对数据的访问 民众 或未指定 访问不受限制。 私人的 访问仅限于程序、功能块或 GVL。 该对象被标记为 (private) 在 POU 或设备视图中。声明包含关键字 P...", 
"body" : "功能 : 当对话框关闭时，在选定的 POU 下创建一个新属性。 称呼 ： 项目→添加对象→属性 ;上下文菜单 要求 ：一个程序（ PRG ), 一个功能块 ( FUNCTION_BLOCK ) 或全局变量列表 ( GVL ) 被选择在 POU 查看或 设备 看法。 姓名 属性的名称（标识符） 例子： prop_iA 返回类型 返回值的默认类型或结构化类型 例子： INT 实现语言 例子： 结构化文本 (ST) 访问说明符 控制对数据的访问 民众 或未指定 访问不受限制。 私人的 访问仅限于程序、功能块或 GVL。 该对象被标记为 (private) 在 POU 或设备视图中。声明包含关键字 PRIVATE . 受保护 访问仅限于程序、功能块或 GVL 及其派生。 该对象被标记为 (protected) 在 POU 或设备视图中。声明包含关键字 PROTECTED . 内部的 访问仅限于命名空间（库）。 该对象被标记为 (internal) 在 POU 或设备视图中。声明包含关键字 INTERNAL . 抽象的 : 标识该属性没有实现，该实现由派生的FB提供 添加 在选定对象下方和访问器方法下方添加一个新属性 Get 和 Set 注意：当您选择一个属性时，您还可以通过单击显式添加以前删除的访问器 添加对象 . " }, 
{ "title" : "编辑：财产 ", 
"url" : "_cds_obj_property.html#UUID-9c407fa5-d8b8-4172-1c22-5219eeec8317_id_b08bdbd0d86c0a8640e00400511_id_8fff2f78bde26345c0a8640e018af0a1", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：财产 \/ 编辑：财产 ", 
"snippet" : "您可以在编辑器中对数据访问进行编程。代码可以包含额外的局部变量。但是，它不得包含任何额外的输入变量或（与函数或方法相反）输出变量。 例子 功能块 FB_A FUNCTION_BLOCK FB_A VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR iA : INT; END_VAR iA := iA + 1; 财产 prop_iA PROPERTY PUBLIC prop_iA : INT 访问器方法 FB_A.prop_iA.Get prop_iA := iA; 访问器方法 FB_A.prop_iA.Set iA := prop_iA; PROGRAM PLC_...", 
"body" : "您可以在编辑器中对数据访问进行编程。代码可以包含额外的局部变量。但是，它不得包含任何额外的输入变量或（与函数或方法相反）输出变量。 例子 功能块 FB_A FUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\n\niA := iA + 1; 财产 prop_iA PROPERTY PUBLIC prop_iA : INT 访问器方法 FB_A.prop_iA.Get prop_iA := iA; 访问器方法 FB_A.prop_iA.Set iA := prop_iA; PROGRAM PLC_PRG\nVAR\n fbA : FB_A;\n iVar: INT;\nEND_VAR\n\nfbA();\nIF fbA.prop_iA > 500 THEN\n fbA.prop_iA := 0;\nEND_IF\niVar := fbA.prop_iA; " }, 
{ "title" : "获取和设置访问器 ", 
"url" : "_cds_obj_property.html#UUID-9c407fa5-d8b8-4172-1c22-5219eeec8317_id_b08bdbd0d86c0a8640e00400511_id_d1b96520c2a88023c0a8640e00496635", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：财产 \/ 获取和设置访问器 ", 
"snippet" : "的召唤 Set 访问器被写入属性。然后它以与输入参数相同的方式使用。调用 Get 访问器时，将读取该属性。它的使用方式与输出参数相同。在每种情况下，访问都通过访问修饰符（限定符）进行限制。结果，相应地识别对象。 当属性以只读或只写方式访问时，您可以删除不需要的访问器。 您可以通过选择属性并单击来显式添加访问器 添加对象 .一个对话框打开，要么 添加获取访问器 要么 添加设置访问器 .在那里您可以设置实现语言和访问权限。 对话框：添加获取（设置）访问器 实现语言 例子： 结构化文本 (ST) 访问说明符 声明部分的限定符 PUBLIC 或未指定 访问不受限制。 PRIVATE 访问仅限于程序、功...", 
"body" : "的召唤 Set 访问器被写入属性。然后它以与输入参数相同的方式使用。调用 Get 访问器时，将读取该属性。它的使用方式与输出参数相同。在每种情况下，访问都通过访问修饰符（限定符）进行限制。结果，相应地识别对象。 当属性以只读或只写方式访问时，您可以删除不需要的访问器。 您可以通过选择属性并单击来显式添加访问器 添加对象 .一个对话框打开，要么 添加获取访问器 要么 添加设置访问器 .在那里您可以设置实现语言和访问权限。 对话框：添加获取（设置）访问器 实现语言 例子： 结构化文本 (ST) 访问说明符 声明部分的限定符 PUBLIC 或未指定 访问不受限制。 PRIVATE 访问仅限于程序、功能块或 GVL。 该对象被标记为 (private) 在 POU 或设备视图中。声明包含关键字。 PROTECTED 对该属性的访问仅限于程序、功能块或 GVL 及其派生项。声明包含关键字。 该对象被标记为 (protected) 在 POU 或设备视图中。 INTERNAL 对该方法的访问仅限于命名空间（库）。 该对象被标记为 (internal) 在 POU 或设备视图中。声明包含关键字。 添加 添加访问器方法 Get 要么 Set 在所选属性下方。 " }, 
{ "title" : "生成继承 POU 时的输入支持 ", 
"url" : "_cds_obj_property.html#UUID-9c407fa5-d8b8-4172-1c22-5219eeec8317_UUID-e3a7d561-c8bd-ff0c-4eda-2e6419e8e10f", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：财产 \/ 生成继承 POU 时的输入支持 ", 
"snippet" : "当你进行面向对象的编程并使用继承时 ( EXTENDS  关键字）的 POU，您可以通过以下方式获得支持： 当您在派生自基本 POU 的 POU 下插入操作、属性、方法或转换时， 添加 … 对话框打开。然后名称的输入字段扩展到一个列表框。列表框包含从基本 POU 中可用的动作、属性、方法或转换中进行的有效选择。例如，现在您可以轻松地接受基本 POU 的方法，然后将其调整为 POU 的派生函数。 带有访问修饰符的方法和属性 PRIVATE 此处未列出，因为它们也不是继承的。带有访问修饰符的方法和属性 PUBLIC 接受派生的 POU 时自动获得一个空白的访问修饰符字段，这在功能上意味着相同的事情...", 
"body" : "当你进行面向对象的编程并使用继承时 ( EXTENDS  关键字）的 POU，您可以通过以下方式获得支持： 当您在派生自基本 POU 的 POU 下插入操作、属性、方法或转换时， 添加 … 对话框打开。然后名称的输入字段扩展到一个列表框。列表框包含从基本 POU 中可用的动作、属性、方法或转换中进行的有效选择。例如，现在您可以轻松地接受基本 POU 的方法，然后将其调整为 POU 的派生函数。 带有访问修饰符的方法和属性 PRIVATE 此处未列出，因为它们也不是继承的。带有访问修饰符的方法和属性 PUBLIC 接受派生的 POU 时自动获得一个空白的访问修饰符字段，这在功能上意味着相同的事情。 有关更多信息，请参阅： 财产， 方法， 过渡， 行动， 例子 " }, 
{ "title" : "对象： 行动 ", 
"url" : "_cds_obj_action.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象： 行动 ", 
"snippet" : "行动 符号： 您可以向功能块或程序添加动作。每个动作都有一个名字。 操作对象实现了额外的代码，这些代码可以用与上级 POU 的基本实现不同的语言进行编程。行动通常在 SFC 中实施。一个动作没有自己的变量声明。它使用其超坐标基础实现的数据并使用其 VAR ， VAR_INPUT ， VAR_OUTPUT ， VAR_IN_OUT ）。 在面向对象的编程中，可以继承一个功能块及其下属操作。 有关更多信息，请参阅： 生成继承 POU 时的输入支持打电话 语法： <program name> . <action name> ( <parameter passing> ) 或者 <name of fu...", 
"body" : "行动 符号： 您可以向功能块或程序添加动作。每个动作都有一个名字。 操作对象实现了额外的代码，这些代码可以用与上级 POU 的基本实现不同的语言进行编程。行动通常在 SFC 中实施。一个动作没有自己的变量声明。它使用其超坐标基础实现的数据并使用其 VAR ， VAR_INPUT ， VAR_OUTPUT ， VAR_IN_OUT ）。 在面向对象的编程中，可以继承一个功能块及其下属操作。 有关更多信息，请参阅： 生成继承 POU 时的输入支持打电话 语法： <program name> . <action name> ( <parameter passing> ) 或者 <name of function block instance> . <action name> ( <parameter passing> ) <program name> . 可选 带有程序名称的实例路径 当在程序的相应基础实现中调用操作时，指定操作名称就足够了。 <name of function block instance> . 可选 包含功能块实例名称的实例路径 当在功能块的相应基本实现中调用操作时，指定操作名称就足够了。 <action name> 必填项 动作名称 ( <parameter passing> ) 可选 当传递参数时，可以将参数传递给输入和输出变量，方法与传递给相应函数块的方法相同。 参见 功能块操作中可用的变量在上级 POU 中声明。尽管如此，调用操作时可以传递参数。变量（ VAR ， VAR_INPUT ， VAR_OUTPUT ， VAR_IN_OUT ) 可以访问上级程序或函数块实例（与方法调用相反）。 因此，当在图形编辑器中调用操作时，将显示基本 POU 的所有 I\/O。 示例 打电话给 重置 动作 ( Counter 功能块）来自另一个 POU。 功能块的实例化 PROGRAM PLC_PRG\nVAR\n Inst : Counter;\nEND_VAR 打电话给 重置 在伊利诺伊州行动 CAL Inst.Reset(In := FALSE)\nLD Inst.Out\nST ERG 打电话给 重置 在 ST 中行动 Inst.Reset(In := FALSE);\nErg := Inst.out; 打电话给 重置 在 FBD 中执行操作 示例 功能块的声明 FB_Test FUNCTION_BLOCK FB_Test\nVAR_INPUT\n i_xTest : BOOL;\n i_lrTest : LREAL;\nEND_VAR\nVAR_OUTPUT\n q_xTest : BOOL;\n q_lrTest : LREAL;\nEND_VAR\nVAR\n xSet : BOOL;\n xReset : BOOL;\n SR_0 : SR;\n R_TRIG_0 : R_TRIG;\nEND_VAR 的实施 Act_Text 操作（在 FBD 中），可以访问相应功能块的 I\/O 动作通常用于 SFC 实现语言。 " }, 
{ "title" : "插入动作 ", 
"url" : "_cds_obj_action.html#UUID-d3c3a161-09fa-9c3d-d5e0-951656fa2f3d_section-idm234809879408146", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象： 行动 \/ 插入动作 ", 
"snippet" : "添加一个 行动 到带有的功能块或程序 项目 → 添加对象 → 行动 命令并在打开的对话框中定义新操作的属性。 添加动作 姓名 动作名称 实现语言 从包含可用实现语言的列表框中选择...", 
"body" : "添加一个 行动 到带有的功能块或程序 项目 → 添加对象 → 行动 命令并在打开的对话框中定义新操作的属性。 添加动作 姓名 动作名称 实现语言 从包含可用实现语言的列表框中选择 " }, 
{ "title" : "对象：过渡 ", 
"url" : "_cds_obj_transition.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：过渡 ", 
"snippet" : "过渡 象征： 该对象可用作在 SFC 中实现的程序块中的过渡元素。 有关详细信息，请参阅： SFC 元素：步骤和过渡...", 
"body" : "过渡 象征： 该对象可用作在 SFC 中实现的程序块中的过渡元素。 有关详细信息，请参阅： SFC 元素：步骤和过渡 " }, 
{ "title" : "生成继承 POU 时的输入支持 ", 
"url" : "_cds_obj_transition.html#UUID-ec6c8ad0-aa77-27a0-2637-e1d57601e639_UUID-e3a7d561-c8bd-ff0c-4eda-2e6419e8e10f", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU \/ 对象：过渡 \/ 生成继承 POU 时的输入支持 ", 
"snippet" : "当你进行面向对象的编程并使用继承时 ( EXTENDS  关键字）的 POU，您可以通过以下方式获得支持： 当您在派生自基本 POU 的 POU 下插入操作、属性、方法或转换时， 添加 … 对话框打开。然后名称的输入字段扩展到一个列表框。列表框包含从基本 POU 中可用的动作、属性、方法或转换中进行的有效选择。例如，现在您可以轻松地接受基本 POU 的方法，然后将其调整为 POU 的派生函数。 带有访问修饰符的方法和属性 PRIVATE 此处未列出，因为它们也不是继承的。带有访问修饰符的方法和属性 PUBLIC 接受派生的 POU 时自动获得一个空白的访问修饰符字段，这在功能上意味着相同的事情...", 
"body" : "当你进行面向对象的编程并使用继承时 ( EXTENDS  关键字）的 POU，您可以通过以下方式获得支持： 当您在派生自基本 POU 的 POU 下插入操作、属性、方法或转换时， 添加 … 对话框打开。然后名称的输入字段扩展到一个列表框。列表框包含从基本 POU 中可用的动作、属性、方法或转换中进行的有效选择。例如，现在您可以轻松地接受基本 POU 的方法，然后将其调整为 POU 的派生函数。 带有访问修饰符的方法和属性 PRIVATE 此处未列出，因为它们也不是继承的。带有访问修饰符的方法和属性 PUBLIC 接受派生的 POU 时自动获得一个空白的访问修饰符字段，这在功能上意味着相同的事情。 有关更多信息，请参阅： 财产， 方法， 过渡， 行动， 例子 " }, 
{ "title" : "对象：隐式检查的 POU ", 
"url" : "_cds_f_obj_pous_implicit_check.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU ", 
"snippet" : "用于隐式检查的 POU 您可以将这些特殊的 POU 添加到应用程序中，为它们提供隐式监控功能。在运行时，这些函数会检查数组或子范围类型的限制、指针地址的有效性以及除以零。注意：对于已经配备此类监控块的设备，可以通过特殊的隐式库禁用此选项。 这 添加对象 → POU 进行隐式检查 命令用于将其添加到应用程序中。该命令打开 为隐式检查添加 POU 对话框，您可以在其中选择监控功能类型（见下表）。根据监控功能，您必须编辑实现代码或自己从头开始创建。 为防止多次包含，已插入的监控功能在 为隐式检查添加 POU 对话。 有关更多信息，请参阅： 使用构建块进行隐式检查要获得监视功能的特性，请不要编辑声明部...", 
"body" : "用于隐式检查的 POU 您可以将这些特殊的 POU 添加到应用程序中，为它们提供隐式监控功能。在运行时，这些函数会检查数组或子范围类型的限制、指针地址的有效性以及除以零。注意：对于已经配备此类监控块的设备，可以通过特殊的隐式库禁用此选项。 这 添加对象 → POU 进行隐式检查 命令用于将其添加到应用程序中。该命令打开 为隐式检查添加 POU 对话框，您可以在其中选择监控功能类型（见下表）。根据监控功能，您必须编辑实现代码或自己从头开始创建。 为防止多次包含，已插入的监控功能在 为隐式检查添加 POU 对话。 有关更多信息，请参阅： 使用构建块进行隐式检查要获得监视功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 删除隐式监控功能后（例如： Check Bounds ) 从项目中，只能下载，不能在线更改。显示相应的消息。 默认， CODESYS 不会对应用程序中使用的库中的功能块运行隐式检查。但是，您可以通过打开 特性 应用程序对话框并指定编译器定义 checks_in_libs 在里面 编译器定义 场上 建造 标签。此定义影响实现库（ *.library ) 仅，不受保护的库 ( *.compiled-library ）。 您可以使用“no_check”属性来禁用对项目中特殊 POU 的检查。 可用功能 监控功能 类型 检查边界 绑定检查 妥善处理违章行为；此类处理包括设置标志或更改字段索引 CheckDivDInt 部门检查 ： 监控除数以避免被零除 CheckDivLint 检查DivReal 检查DivLReal 检查范围签名 范围检查 ： 在运行时模式下监视子范围类型的范围限制 对数据类型有效 DINT \/ UDINT 检查范围无符号 CheckLRangeSigned L-范围检查 ： 在运行时模式下监视子范围类型的范围限制 对数据类型有效 LINT \/ ULINT CheckLRange无符号 检查指针 指针检查 您负责用实现代码完全填写此函数。请参阅“POU 'CheckPointer'”的帮助页面。该函数应监视传递的指针是否引用了有效的内存地址，以及所引用的内存区域的方向是否与指针所指的变量类型相匹配。如果两个条件都满足，则返回指针。如果没有，那么 CheckPointer 应该完成适当的错误处理。 CheckPointer 监视方式与类型变量相同 REFERENCE TO . " }, 
{ "title" : "POU: CheckBounds ", 
"url" : "_cds_obj_pou_checkbounds.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU: CheckBounds ", 
"snippet" : "CheckBounds 此监视功能的任务是适当地处理边界违规。对违规的反应示例包括设置错误标志和更改数组索引的值。仅对一个变量数组索引执行检查。不正确的常量数组索引会导致编译器错误。 CODESYS 当值被赋值给一个 大批 多变的。 有关更多信息，请参阅： 使用构建块进行隐式检查, 使用构建块进行隐式检查插入函数后，您会在声明和实现部分收到自动生成的代码。见下文。 要获得监视功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 声明部分 \/\/ Automatisch erzeugter Code : NICHT EDITIEREN FUNCTION CheckBounds : DINT ...", 
"body" : "CheckBounds 此监视功能的任务是适当地处理边界违规。对违规的反应示例包括设置错误标志和更改数组索引的值。仅对一个变量数组索引执行检查。不正确的常量数组索引会导致编译器错误。 CODESYS 当值被赋值给一个 大批 多变的。 有关更多信息，请参阅： 使用构建块进行隐式检查, 使用构建块进行隐式检查插入函数后，您会在声明和实现部分收到自动生成的代码。见下文。 要获得监视功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 声明部分 \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckBounds : DINT\nVAR_INPUT\n index, lower, upper: DINT;\nEND_VAR 执行 \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF index < lower THEN\n CheckBounds := lower;\nELSIF index > upper THEN\n CheckBounds := upper;\nELSE\n CheckBounds := index;\nEND_IF\n\n(* It is also possible to set a breakpoint, log messages or e.g. to halt on an exception:\nAdd CmpApp.library, SysExcept.library and SysTypes2_Itf as newest.\nDeclaration:\nVAR\n _pApp : POINTER TO CmpApp.APPLICATION;\n _result : SysTypes.RTS_IEC_RESULT;\nEND_VAR\n\nImplementation:\n_pApp := AppGetCurrent(pResult:=_result);\nIF index < lower THEN\n CheckBounds := lower;\n IF _pApp <> 0 THEN\n AppGenerateException(pApp:=_pApp, ulException:=RtsExceptions.RTSEXCPT_ARRAYBOUNDS);\n END_IF\nELSIF index > upper THEN\n CheckBounds := upper;\n IF _pApp <> 0 THEN\n AppGenerateException(pApp:=_pApp, ulException:=RtsExceptions.RTSEXCPT_ARRAYBOUNDS);\n END_IF\nELSE\n CheckBounds := index;\nEND_IF\n*) 当。。。的时候 检查边界 函数被调用，它接收以下输入参数： index : 数组元素的索引 lower : 数组范围的下限 upper : 数组范围的上限 返回值是数组元素的索引，只要它在有效范围内。如果没有，那么 CODESYS 返回上限或下限，具体取决于违反的阈值。 示例：更正对已定义数组边界之外的数组的访问 在下面的示例程序中，索引未达到定义的下限 a 大批。 PROGRAM PLC_PRG\nVAR\n a: ARRAY[0..7] OF BOOL;\n b: INT:=10;\nEND_VAR\n\na[b]:=TRUE; 在这个例子中， CheckBounds 功能原因 a 将数组范围索引的上限更改为 10 .价值 TRUE 然后分配给元素 a[7] .通过这种方式，该函数更正了有效数组范围之外的数组访问。 示例：违反数组限制时的异常输出。 在应用程序的库管理器中添加以下库： CmpApp.library 和 SysExcept.library 作为占位符库 SysTypes2_Itfs.library 和 总是最新版本 添加一个 检查边界 应用程序下方的对象并修改指定的代码，如下所示。 声明部分 FUNCTION CheckBounds : DINT\nVAR_INPUT\n index, lower, upper: DINT;\nEND_VAR\nVAR\n _pApp : POINTER TO CmpApp.APPLICATION;\n _Result : ISystypes2.RTS_IEC_RESULT;\nEND_VAR 实施部分 \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\n_pApp := AppGetCurrent(pResult := _Result);\nIF index < lower THEN\n CheckBounds := lower;\n IF _pApp <> 0 THEN\n AppGenerateException(pApp := _pApp, ulException := RtsExceptions.RTSEXCPT_ARRAYBOUNDS);\n END_IF\nELSIF index > upper THEN\n CheckBounds := upper;\n IF _pApp <> 0 THEN\n AppGenerateException(pApp:=_pApp, ulException:=RtsExceptions.RTSEXCPT_ARRAYBOUNDS);\n END_IF\nELSE\n CheckBounds := index;\nEND_IF 程序 MAIN_PRG 应用程序下方的对象，其内容如下所示。 PROGRAM MAIN_PRG\nVAR\n xInit : BOOL;\n arData : ARRAY[0..7] OF BYTE;\n i : INT;\n dwAdr : DWORD;\nEND_VAR\n\nIF NOT xInit THEN\n \/\/ Erforderlich für CheckBounds\n xInit := TRUE;\nEND_IF\n\n\/\/ Setze i auf einen Wert > 7 oder < 0\n\/\/ Generiert eine Exception in CheckBounds, Benutzerdefiniert\narData[i] := 11; 当您加载并启动此应用程序时，如果违反数组边界，将引发“异常”。处理停止于 检查边界 以便可以检测到错误的类型。 " }, 
{ "title" : "POU：CheckDivInt ", 
"url" : "_cds_obj_pou_checkdivint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckDivInt ", 
"snippet" : "CheckDivInt...", 
"body" : "CheckDivInt " }, 
{ "title" : "防止被“0”除的功能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivint.html#UUID-072cf6e7-5009-f5d9-a6f2-cfb7ba93eb0e_UUID-4cc55957-06e7-1250-5de0-d97f7051f0e6", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckDivInt \/ 防止被“0”除的功能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"snippet" : "为了防止被零除，您可以使用函数 CheckDivInt , CheckDivLint , CheckDivReal ， 和 CheckDivLReal .如果您在应用程序中包含这些函数，则它们会在代码中的每个除法操作之前调用。 有关更多信息，请参阅： 使用构建块进行隐式检查, 用于隐式检查的 POU要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 CheckDivReal 的默认实现： 声明部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN FUNCTION CheckDivReal : REAL VAR_INPUT di...", 
"body" : "为了防止被零除，您可以使用函数 CheckDivInt , CheckDivLint , CheckDivReal ， 和 CheckDivLReal .如果您在应用程序中包含这些函数，则它们会在代码中的每个除法操作之前调用。 有关更多信息，请参阅： 使用构建块进行隐式检查, 用于隐式检查的 POU要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 CheckDivReal 的默认实现： 声明部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckDivReal : REAL\nVAR_INPUT\n divisor:REAL;\nEND_VAR 实现部分： \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF divisor = 0 THEN\n CheckDivReal:=1;\nELSE\n CheckDivReal:=divisor;\nEND_IF; 这 DIV 运算符使用 CheckDivReal 起到除数的作用。在下面的示例程序中， CheckDivReal 防止除以 0 通过改变除数的隐含值 d 从“0”到 1 在执行除法操作之前。因此，除法结果为 799 . PROGRAM PLC_PRG\nVAR\n erg:REAL;\n v1:REAL:=799;\n d:REAL:=0;\nEND_VAR\nerg:= v1 \/ d; " }, 
{ "title" : "POU：CheckDivLint ", 
"url" : "_cds_obj_pou_checkdivlint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckDivLint ", 
"snippet" : "CheckDivLint...", 
"body" : "CheckDivLint " }, 
{ "title" : "防止被“0”除的功能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivlint.html#UUID-99e0b883-c84e-9caf-1987-091b2733937f_UUID-4cc55957-06e7-1250-5de0-d97f7051f0e6", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckDivLint \/ 防止被“0”除的功能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"snippet" : "为了防止被零除，您可以使用函数 CheckDivInt , CheckDivLint , CheckDivReal ， 和 CheckDivLReal .如果您在应用程序中包含这些函数，则它们会在代码中的每个除法操作之前调用。 有关更多信息，请参阅： 使用构建块进行隐式检查, 用于隐式检查的 POU要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 CheckDivReal 的默认实现： 声明部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN FUNCTION CheckDivReal : REAL VAR_INPUT di...", 
"body" : "为了防止被零除，您可以使用函数 CheckDivInt , CheckDivLint , CheckDivReal ， 和 CheckDivLReal .如果您在应用程序中包含这些函数，则它们会在代码中的每个除法操作之前调用。 有关更多信息，请参阅： 使用构建块进行隐式检查, 用于隐式检查的 POU要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 CheckDivReal 的默认实现： 声明部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckDivReal : REAL\nVAR_INPUT\n divisor:REAL;\nEND_VAR 实现部分： \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF divisor = 0 THEN\n CheckDivReal:=1;\nELSE\n CheckDivReal:=divisor;\nEND_IF; 这 DIV 运算符使用 CheckDivReal 起到除数的作用。在下面的示例程序中， CheckDivReal 防止除以 0 通过改变除数的隐含值 d 从“0”到 1 在执行除法操作之前。因此，除法结果为 799 . PROGRAM PLC_PRG\nVAR\n erg:REAL;\n v1:REAL:=799;\n d:REAL:=0;\nEND_VAR\nerg:= v1 \/ d; " }, 
{ "title" : "POU：CheckDivReal ", 
"url" : "_cds_obj_pou_checkdivreal.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckDivReal ", 
"snippet" : "CheckDivReal...", 
"body" : "CheckDivReal " }, 
{ "title" : "防止被“0”除的功能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivreal.html#UUID-c703e521-3496-9988-34a7-a889e5d5836b_UUID-4cc55957-06e7-1250-5de0-d97f7051f0e6", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckDivReal \/ 防止被“0”除的功能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"snippet" : "为了防止被零除，您可以使用函数 CheckDivInt , CheckDivLint , CheckDivReal ， 和 CheckDivLReal .如果您在应用程序中包含这些函数，则它们会在代码中的每个除法操作之前调用。 有关更多信息，请参阅： 使用构建块进行隐式检查, 用于隐式检查的 POU要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 CheckDivReal 的默认实现： 声明部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN FUNCTION CheckDivReal : REAL VAR_INPUT di...", 
"body" : "为了防止被零除，您可以使用函数 CheckDivInt , CheckDivLint , CheckDivReal ， 和 CheckDivLReal .如果您在应用程序中包含这些函数，则它们会在代码中的每个除法操作之前调用。 有关更多信息，请参阅： 使用构建块进行隐式检查, 用于隐式检查的 POU要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 CheckDivReal 的默认实现： 声明部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckDivReal : REAL\nVAR_INPUT\n divisor:REAL;\nEND_VAR 实现部分： \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF divisor = 0 THEN\n CheckDivReal:=1;\nELSE\n CheckDivReal:=divisor;\nEND_IF; 这 DIV 运算符使用 CheckDivReal 起到除数的作用。在下面的示例程序中， CheckDivReal 防止除以 0 通过改变除数的隐含值 d 从“0”到 1 在执行除法操作之前。因此，除法结果为 799 . PROGRAM PLC_PRG\nVAR\n erg:REAL;\n v1:REAL:=799;\n d:REAL:=0;\nEND_VAR\nerg:= v1 \/ d; " }, 
{ "title" : "POU：CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivlreal.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckDivLReal ", 
"snippet" : "CheckDivLReal...", 
"body" : "CheckDivLReal " }, 
{ "title" : "防止被“0”除的功能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivlreal.html#UUID-84677e37-4182-0e45-f4bf-d23f7f7919b1_UUID-4cc55957-06e7-1250-5de0-d97f7051f0e6", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckDivLReal \/ 防止被“0”除的功能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"snippet" : "为了防止被零除，您可以使用函数 CheckDivInt , CheckDivLint , CheckDivReal ， 和 CheckDivLReal .如果您在应用程序中包含这些函数，则它们会在代码中的每个除法操作之前调用。 有关更多信息，请参阅： 使用构建块进行隐式检查, 用于隐式检查的 POU要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 CheckDivReal 的默认实现： 声明部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN FUNCTION CheckDivReal : REAL VAR_INPUT di...", 
"body" : "为了防止被零除，您可以使用函数 CheckDivInt , CheckDivLint , CheckDivReal ， 和 CheckDivLReal .如果您在应用程序中包含这些函数，则它们会在代码中的每个除法操作之前调用。 有关更多信息，请参阅： 使用构建块进行隐式检查, 用于隐式检查的 POU要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 CheckDivReal 的默认实现： 声明部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckDivReal : REAL\nVAR_INPUT\n divisor:REAL;\nEND_VAR 实现部分： \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF divisor = 0 THEN\n CheckDivReal:=1;\nELSE\n CheckDivReal:=divisor;\nEND_IF; 这 DIV 运算符使用 CheckDivReal 起到除数的作用。在下面的示例程序中， CheckDivReal 防止除以 0 通过改变除数的隐含值 d 从“0”到 1 在执行除法操作之前。因此，除法结果为 799 . PROGRAM PLC_PRG\nVAR\n erg:REAL;\n v1:REAL:=799;\n d:REAL:=0;\nEND_VAR\nerg:= v1 \/ d; " }, 
{ "title" : "POU：CheckRangeSigned ", 
"url" : "_cds_obj_pou_checkrangesigned.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckRangeSigned ", 
"snippet" : "CheckRangeSigned 用于监视 DINT 类型的子范围类型的范围限制的功能 CheckRangeSigned 示例 将值分配给有符号子范围类型的 DINT 变量是自动调用 CheckRangeSigned .该函数将赋值限制在变量声明中定义的子范围内。 ST中函数的默认实现如下： 声明部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN FUNCTION CheckRangeSigned : DINT VAR_INPUT value, lower, upper: DINT; END_VAR 执行： \/\/ Automatisch er...", 
"body" : "CheckRangeSigned 用于监视 DINT 类型的子范围类型的范围限制的功能 CheckRangeSigned 示例 将值分配给有符号子范围类型的 DINT 变量是自动调用 CheckRangeSigned .该函数将赋值限制在变量声明中定义的子范围内。 ST中函数的默认实现如下： 声明部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckRangeSigned : DINT\nVAR_INPUT\n value, lower, upper: DINT;\nEND_VAR 执行： \/\/ Automatisch erzeugter Code : Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF (value < lower) THEN\n CheckRangeSigned := lower;\n ELSEIF(value > upper) THEN\n CheckRangeSigned := upper;\nELSE\n CheckRangeSigned := value;\nEND_VAR " }, 
{ "title" : "监测范围限制 ", 
"url" : "_cds_obj_pou_checkrangesigned.html#UUID-966e7cc4-b54e-471f-136b-0a28b2c4f30a_UUID-2f40e0a8-a491-b3cc-9231-f5c35a224dd7", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckRangeSigned \/ 监测范围限制 ", 
"snippet" : "这 监控功能 负责适当处理违反范围限制的行为。对违规的反应示例包括设置错误标志和更改值。当将值分配给子范围类型变量时，会隐式调用这些函数。 要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 调用该函数时，它接收以下输入参数： value ：应该分配给子范围类型变量的值 lower ：范围下限 upper ：范围上限 只要在有效范围内，返回值就是赋值值。如果不是，则返回上限或下限，具体取决于违反的阈值。 例如，赋值 i := 10*y 被隐式替换为 i := CheckRangeSigned(10*y, -4095, 4095); 如果 y 为“1000”，则“10*1000...", 
"body" : "这 监控功能 负责适当处理违反范围限制的行为。对违规的反应示例包括设置错误标志和更改值。当将值分配给子范围类型变量时，会隐式调用这些函数。 要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 调用该函数时，它接收以下输入参数： value ：应该分配给子范围类型变量的值 lower ：范围下限 upper ：范围上限 只要在有效范围内，返回值就是赋值值。如果不是，则返回上限或下限，具体取决于违反的阈值。 例如，赋值 i := 10*y 被隐式替换为 i := CheckRangeSigned(10*y, -4095, 4095); 如果 y 为“1000”，则“10*1000=10000”未分配给 i 就像在原始代码中一样。而是分配了“4095”的范围上限。 对于 CheckRangeUnsigned 功能。 如果函数不可用，则不会在运行时检查子范围的各个变量。在这种情况下，您可以将介于 -2147483648 和 +2147483648（或 0 和 4294967295 之间）之间的任何值分配给子范围类型 DINT\/UDINT 的变量。您可以将介于 -9223372036854775808 和 +9223372036854775807 之间（或介于 0 和 18446744073709551615 之间）的任何值分配给子范围类型 LINT\/ULINT 的变量。 链接区域监控功能可能导致无限循环。例如，如果 FOR 循环的计数器变量是子范围类型并且循环的计数范围退出定义的子范围，则可能发生无限循环。 无限循环示例： VAR\n ui : UINT (0..10000);\n ...\nEND_VAR FOR ui:=0 TO 10000 DO\n ...\nEND_FOR 程序永远不会退出 FOR 循环，因为监视器功能 CheckRangeSigned 防止 ui 设置为大于 10000 的值。 " }, 
{ "title" : "POU：CheckLRangeSigned ", 
"url" : "_cds_obj_pou_checklrangesigned.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckLRangeSigned ", 
"snippet" : "CheckLRangeSigned 用于监视 LINT 类型的子范围类型的范围限制的功能 有关范围监控的实现示例，请参阅帮助页面 检查范围签名 功能。...", 
"body" : "CheckLRangeSigned 用于监视 LINT 类型的子范围类型的范围限制的功能 有关范围监控的实现示例，请参阅帮助页面 检查范围签名 功能。 " }, 
{ "title" : "监测范围限制 ", 
"url" : "_cds_obj_pou_checklrangesigned.html#UUID-f6d1d4fb-cc77-0cb6-74fc-fe5983251696_UUID-2f40e0a8-a491-b3cc-9231-f5c35a224dd7", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckLRangeSigned \/ 监测范围限制 ", 
"snippet" : "这 监控功能 负责适当处理违反范围限制的行为。对违规的反应示例包括设置错误标志和更改值。当将值分配给子范围类型变量时，会隐式调用这些函数。 要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 调用该函数时，它接收以下输入参数： value ：应该分配给子范围类型变量的值 lower ：范围下限 upper ：范围上限 只要在有效范围内，返回值就是赋值值。如果不是，则返回上限或下限，具体取决于违反的阈值。 例如，赋值 i := 10*y 被隐式替换为 i := CheckRangeSigned(10*y, -4095, 4095); 如果 y 为“1000”，则“10*1000...", 
"body" : "这 监控功能 负责适当处理违反范围限制的行为。对违规的反应示例包括设置错误标志和更改值。当将值分配给子范围类型变量时，会隐式调用这些函数。 要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 调用该函数时，它接收以下输入参数： value ：应该分配给子范围类型变量的值 lower ：范围下限 upper ：范围上限 只要在有效范围内，返回值就是赋值值。如果不是，则返回上限或下限，具体取决于违反的阈值。 例如，赋值 i := 10*y 被隐式替换为 i := CheckRangeSigned(10*y, -4095, 4095); 如果 y 为“1000”，则“10*1000=10000”未分配给 i 就像在原始代码中一样。而是分配了“4095”的范围上限。 对于 CheckRangeUnsigned 功能。 如果函数不可用，则不会在运行时检查子范围的各个变量。在这种情况下，您可以将介于 -2147483648 和 +2147483648（或 0 和 4294967295 之间）之间的任何值分配给子范围类型 DINT\/UDINT 的变量。您可以将介于 -9223372036854775808 和 +9223372036854775807 之间（或介于 0 和 18446744073709551615 之间）的任何值分配给子范围类型 LINT\/ULINT 的变量。 链接区域监控功能可能导致无限循环。例如，如果 FOR 循环的计数器变量是子范围类型并且循环的计数范围退出定义的子范围，则可能发生无限循环。 无限循环示例： VAR\n ui : UINT (0..10000);\n ...\nEND_VAR FOR ui:=0 TO 10000 DO\n ...\nEND_FOR 程序永远不会退出 FOR 循环，因为监视器功能 CheckRangeSigned 防止 ui 设置为大于 10000 的值。 " }, 
{ "title" : "POU: CheckRangeUnsigned ", 
"url" : "_cds_obj_pou_checkrangeunsigned.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU: CheckRangeUnsigned ", 
"snippet" : "CheckRangeUnsigned 用于监视 UDINT 类型的子范围类型的范围限制的功能 有关范围监控的实现示例，请参阅帮助页面 检查范围签名 功能。...", 
"body" : "CheckRangeUnsigned 用于监视 UDINT 类型的子范围类型的范围限制的功能 有关范围监控的实现示例，请参阅帮助页面 检查范围签名 功能。 " }, 
{ "title" : "监测范围限制 ", 
"url" : "_cds_obj_pou_checkrangeunsigned.html#UUID-8eaae037-91f2-889d-1075-c38a20b7f3b4_UUID-2f40e0a8-a491-b3cc-9231-f5c35a224dd7", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU: CheckRangeUnsigned \/ 监测范围限制 ", 
"snippet" : "这 监控功能 负责适当处理违反范围限制的行为。对违规的反应示例包括设置错误标志和更改值。当将值分配给子范围类型变量时，会隐式调用这些函数。 要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 调用该函数时，它接收以下输入参数： value ：应该分配给子范围类型变量的值 lower ：范围下限 upper ：范围上限 只要在有效范围内，返回值就是赋值值。如果不是，则返回上限或下限，具体取决于违反的阈值。 例如，赋值 i := 10*y 被隐式替换为 i := CheckRangeSigned(10*y, -4095, 4095); 如果 y 为“1000”，则“10*1000...", 
"body" : "这 监控功能 负责适当处理违反范围限制的行为。对违规的反应示例包括设置错误标志和更改值。当将值分配给子范围类型变量时，会隐式调用这些函数。 要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 调用该函数时，它接收以下输入参数： value ：应该分配给子范围类型变量的值 lower ：范围下限 upper ：范围上限 只要在有效范围内，返回值就是赋值值。如果不是，则返回上限或下限，具体取决于违反的阈值。 例如，赋值 i := 10*y 被隐式替换为 i := CheckRangeSigned(10*y, -4095, 4095); 如果 y 为“1000”，则“10*1000=10000”未分配给 i 就像在原始代码中一样。而是分配了“4095”的范围上限。 对于 CheckRangeUnsigned 功能。 如果函数不可用，则不会在运行时检查子范围的各个变量。在这种情况下，您可以将介于 -2147483648 和 +2147483648（或 0 和 4294967295 之间）之间的任何值分配给子范围类型 DINT\/UDINT 的变量。您可以将介于 -9223372036854775808 和 +9223372036854775807 之间（或介于 0 和 18446744073709551615 之间）的任何值分配给子范围类型 LINT\/ULINT 的变量。 链接区域监控功能可能导致无限循环。例如，如果 FOR 循环的计数器变量是子范围类型并且循环的计数范围退出定义的子范围，则可能发生无限循环。 无限循环示例： VAR\n ui : UINT (0..10000);\n ...\nEND_VAR FOR ui:=0 TO 10000 DO\n ...\nEND_FOR 程序永远不会退出 FOR 循环，因为监视器功能 CheckRangeSigned 防止 ui 设置为大于 10000 的值。 " }, 
{ "title" : "POU：CheckLRangeUnsigned ", 
"url" : "_cds_obj_pou_checklrangeunsigned.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckLRangeUnsigned ", 
"snippet" : "CheckLRangeUnsigned 用于监视 ULINT 类型的子范围类型的范围限制的功能 有关范围监控的实现示例，请参阅帮助页面 检查范围签名 功能。...", 
"body" : "CheckLRangeUnsigned 用于监视 ULINT 类型的子范围类型的范围限制的功能 有关范围监控的实现示例，请参阅帮助页面 检查范围签名 功能。 " }, 
{ "title" : "监测范围限制 ", 
"url" : "_cds_obj_pou_checklrangeunsigned.html#UUID-8c7f7188-1427-8235-15d4-450140cc7ca9_UUID-2f40e0a8-a491-b3cc-9231-f5c35a224dd7", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU：CheckLRangeUnsigned \/ 监测范围限制 ", 
"snippet" : "这 监控功能 负责适当处理违反范围限制的行为。对违规的反应示例包括设置错误标志和更改值。当将值分配给子范围类型变量时，会隐式调用这些函数。 要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 调用该函数时，它接收以下输入参数： value ：应该分配给子范围类型变量的值 lower ：范围下限 upper ：范围上限 只要在有效范围内，返回值就是赋值值。如果不是，则返回上限或下限，具体取决于违反的阈值。 例如，赋值 i := 10*y 被隐式替换为 i := CheckRangeSigned(10*y, -4095, 4095); 如果 y 为“1000”，则“10*1000...", 
"body" : "这 监控功能 负责适当处理违反范围限制的行为。对违规的反应示例包括设置错误标志和更改值。当将值分配给子范围类型变量时，会隐式调用这些函数。 要获得监控功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 调用该函数时，它接收以下输入参数： value ：应该分配给子范围类型变量的值 lower ：范围下限 upper ：范围上限 只要在有效范围内，返回值就是赋值值。如果不是，则返回上限或下限，具体取决于违反的阈值。 例如，赋值 i := 10*y 被隐式替换为 i := CheckRangeSigned(10*y, -4095, 4095); 如果 y 为“1000”，则“10*1000=10000”未分配给 i 就像在原始代码中一样。而是分配了“4095”的范围上限。 对于 CheckRangeUnsigned 功能。 如果函数不可用，则不会在运行时检查子范围的各个变量。在这种情况下，您可以将介于 -2147483648 和 +2147483648（或 0 和 4294967295 之间）之间的任何值分配给子范围类型 DINT\/UDINT 的变量。您可以将介于 -9223372036854775808 和 +9223372036854775807 之间（或介于 0 和 18446744073709551615 之间）的任何值分配给子范围类型 LINT\/ULINT 的变量。 链接区域监控功能可能导致无限循环。例如，如果 FOR 循环的计数器变量是子范围类型并且循环的计数范围退出定义的子范围，则可能发生无限循环。 无限循环示例： VAR\n ui : UINT (0..10000);\n ...\nEND_VAR FOR ui:=0 TO 10000 DO\n ...\nEND_FOR 程序永远不会退出 FOR 循环，因为监视器功能 CheckRangeSigned 防止 ui 设置为大于 10000 的值。 " }, 
{ "title" : "POU: CheckPointer ", 
"url" : "_cds_obj_pou_checkpointer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：隐式检查的 POU \/ POU: CheckPointer ", 
"snippet" : "CheckPointer 指针监控功能（CheckPointer） 使用此函数可以在运行时模式下监视指针的内存访问。相对于其他 监控功能 , 不存在实施的标准建议 CheckPointer .您必须根据自己的要求定义实现。 这 CheckPointer 函数应该检查传递的指针是否引用了有效的内存地址，以及引用的内存区域的方向是否与指针所指的变量类型匹配。如果两个条件都满足，则返回指针。如果不是，则该函数应完成适当的错误处理。 要获得监视功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 对于 THIS 指针和 SUPER 指针，不会发生隐式监控函数调用。 在编译器版本 3.5.7.40...", 
"body" : "CheckPointer 指针监控功能（CheckPointer） 使用此函数可以在运行时模式下监视指针的内存访问。相对于其他 监控功能 , 不存在实施的标准建议 CheckPointer .您必须根据自己的要求定义实现。 这 CheckPointer 函数应该检查传递的指针是否引用了有效的内存地址，以及引用的内存区域的方向是否与指针所指的变量类型匹配。如果两个条件都满足，则返回指针。如果不是，则该函数应完成适当的错误处理。 要获得监视功能的特性，请不要编辑声明部分。但是，您可以添加局部变量。 对于 THIS 指针和 SUPER 指针，不会发生隐式监控函数调用。 在编译器版本 3.5.7.40 及更高版本中， 检查指针 也影响 REFERENCE 变量与指针变量相同。 模板 宣言： \/\/ Automatically generated code: DO NOT EDIT\nFUNCTION CheckPointer : POINTER TO BYTE\nVAR_INPUT\n ptToTest : POINTER TO BYTE;\n iSize : DINT;\n iGran : DINT;\n bWrite: BOOL;\nEND_VAR 实施：（不完整） \/\/ Not a standard implementation. Insert your code here.\nCheckPointer := ptToTest; 调用该函数时，它接收以下输入参数： ptToTest : 指针的目标地址 iSize : 引用变量的大小；的数据类型 iSize 必须兼容 INT 并覆盖变量的维度范围 iGran ：参考尺寸的粒度；这是引用变量中包含的最大的非结构化数据类型；的数据类型 iGran 必须兼容 INT bWrite ：访问类型（ TRUE = 写访问， FALSE = 读访问）；的数据类型 bWrite 必须 BOOL 当检查结果为正时，返回不变的指针 ( ptToTest ）。 " }, 
{ "title" : "对象：POU 位置 ", 
"url" : "_cds_obj_pou_locations.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU 位置 ", 
"snippet" : "POU 位置 此对象仅适用于特定控制器。它会自动显示在设备树中。无法手动添加或删除对象。 该对象可用于将应用程序的可执行代码映射到控制器的不同代码区域。特别是小型控制器通常具有有限的内部代码区域（闪存）。如果控制器上有一个或多个附加代码区域（例如，外部闪存）可用，则可以专门更改应用程序的代码 POU 的位置。在安全控制器 (SIL2) 的情况下，这也可用于将非安全相关的代码 POU 或整个库移动到该外部存储器中。 如果没有具体要求，则将代码 POU 顺序存储在代码区域（ 默认 ）。这意味着仅当第一个代码区域被填充时，下一个代码 POU 才会存储在下一个区域中。在里面 POU 位置 编辑器，您将...", 
"body" : "POU 位置 此对象仅适用于特定控制器。它会自动显示在设备树中。无法手动添加或删除对象。 该对象可用于将应用程序的可执行代码映射到控制器的不同代码区域。特别是小型控制器通常具有有限的内部代码区域（闪存）。如果控制器上有一个或多个附加代码区域（例如，外部闪存）可用，则可以专门更改应用程序的代码 POU 的位置。在安全控制器 (SIL2) 的情况下，这也可用于将非安全相关的代码 POU 或整个库移动到该外部存储器中。 如果没有具体要求，则将代码 POU 顺序存储在代码区域（ 默认 ）。这意味着仅当第一个代码区域被填充时，下一个代码 POU 才会存储在下一个区域中。在里面 POU 位置 编辑器，您将看到 POU 在内存区域中的当前位置，您可以专门更改它们。尤其是在安全应用的情况下，这对于将所有安全 POU 放入安全内部存储区可能是必要的。 有关更多信息，请参阅： 将应用程序代码分布到不同的内存区域" }, 
{ "title" : "编辑：POU Locations ", 
"url" : "_cds_obj_pou_locations.html#UUID-26ae340b-748e-2b8d-dcb3-138669ca689f_id_d6ed3981f82e321c0a864631448cd76_id_ea2a3b651ff10e9fc0a8646334153b61", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：POU 位置 \/ 编辑：POU Locations ", 
"snippet" : "双击 POU 位置 控制器设备树中的对象打开编辑器。起初，它只获得条目 <应用> .代码生成后，应用程序的所有程序块都显示为相应的对象类型、内存中的当前位置和代码大小。 在里面 配置位置 列，您可以设置除 当前位置 对于每个 POU 或库。 为了将 POU 移动到最近配置的内存位置，您首先必须 干净的 然后 生成代码 再次。 注意类别中的消息 POU 位置 .当无法按预期移动代码 POU 时也会显示此信息。 干净的 删除应用程序的编译信息 对应于 构建 → 清理 菜单命令 这是将 POU 移动到配置的内存位置的要求。 生成代码 开始为应用程序生成代码 对应于 构建 → 生成代码 菜单命令 这是...", 
"body" : "双击 POU 位置 控制器设备树中的对象打开编辑器。起初，它只获得条目 <应用> .代码生成后，应用程序的所有程序块都显示为相应的对象类型、内存中的当前位置和代码大小。 在里面 配置位置 列，您可以设置除 当前位置 对于每个 POU 或库。 为了将 POU 移动到最近配置的内存位置，您首先必须 干净的 然后 生成代码 再次。 注意类别中的消息 POU 位置 .当无法按预期移动代码 POU 时也会显示此信息。 干净的 删除应用程序的编译信息 对应于 构建 → 清理 菜单命令 这是将 POU 移动到配置的内存位置的要求。 生成代码 开始为应用程序生成代码 对应于 构建 → 生成代码 菜单命令 这是将 POU 移动到配置的内存位置的要求。 对象 应用程序的对象，包括引用库中的对象 类型 对象类型 例子： 功能块 , 方法 , 图书馆 当前位置 POU 的当前内存位置： area_<n> 配置位置 POU 在下一次代码生成时移动到的已配置内存位置。可能的值： 默认 : 自动分配区域 区域_<n> : 显式分配的内存区域 (n=number) 代码大小 POU 的代码大小（以字节为单位） " }, 
{ "title" : "对象：项目设置 ", 
"url" : "_cds_obj_project_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：项目设置 ", 
"snippet" : "项目设置 象征： 功能 ：对象包含项目的配置。 称呼 项目 → 项目设置 菜单 双击设备树中的对象 CODESYS 保存 项目设置 直接在项目中。例如，当您将项目传输到另一个系统时， 项目设置 对象随它一起转移。不需要项目存档。 项目设置在整个项目中都有效，并为各种类别提供可能的设置，例如 证监会 要么 用户和组 .可用的类别会有所不同，具体取决于您通过包管理器安装的软件包。...", 
"body" : "项目设置 象征： 功能 ：对象包含项目的配置。 称呼 项目 → 项目设置 菜单 双击设备树中的对象 CODESYS 保存 项目设置 直接在项目中。例如，当您将项目传输到另一个系统时， 项目设置 对象随它一起转移。不需要项目存档。 项目设置在整个项目中都有效，并为各种类别提供可能的设置，例如 证监会 要么 用户和组 .可用的类别会有所不同，具体取决于您通过包管理器安装的软件包。 " }, 
{ "title" : "对象：项目信息 ", 
"url" : "_cds_obj_project_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：项目信息 ", 
"snippet" : "项目信息 象征： 功能 ：对象包含属性、元信息和项目信息。有了这个，您可以检查项目的作者身份和完整性。 称呼 双击设备树中的对象 项目→项目信息 菜单 要求 ： CODESYS 单击时创建对象 项目→项目信息 ，并打开对话框。 CODESYS 将项目信息直接保存在项目中。例如，当您将项目转移到另一个系统时， 项目信息 对象也被转移。您不需要项目存档。 有关更多信息，请参阅： 检索和编辑项目信息...", 
"body" : "项目信息 象征： 功能 ：对象包含属性、元信息和项目信息。有了这个，您可以检查项目的作者身份和完整性。 称呼 双击设备树中的对象 项目→项目信息 菜单 要求 ： CODESYS 单击时创建对象 项目→项目信息 ，并打开对话框。 CODESYS 将项目信息直接保存在项目中。例如，当您将项目转移到另一个系统时， 项目信息 对象也被转移。您不需要项目存档。 有关更多信息，请参阅： 检索和编辑项目信息" }, 
{ "title" : "标签：文件 ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_b48b607558567f4ec0a8640e01c898f6", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：项目信息 \/ 标签：文件 ", 
"snippet" : "该选项卡显示项目文件的属性及其属性。您无法编辑这些属性。它们对应于 Windows Explorer 的文件属性。...", 
"body" : "该选项卡显示项目文件的属性及其属性。您无法编辑这些属性。它们对应于 Windows Explorer 的文件属性。 " }, 
{ "title" : "标签：摘要 ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_c59e7f6558567f53c0a8640e00967a59", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：项目信息 \/ 标签：摘要 ", 
"snippet" : "该选项卡包含项目文件的一般信息和元信息。 CODESYS 使用此信息在 特性 标签。例如，如果名称 Company_A 指定在 公司 ，那么 Company 带有值的键 Company_A 提供在 特性 标签。 如果你 保存 你的项目作为一个库项目，那么你应该注意 图书馆开发者指南 . 对于图书馆项目，一个 公司 ， 一种 标题 , 和一个 版本 必须指定安装库。 公司 公司名称（例如： Company_A ) 标题 项目名称（例如 Automation_A ) 版本 项目的版本（例如： 0.0.0.1 ) 发布 ：激活修改保护 结果：如果您现在编辑项目，则会打开一个对话框提示以确认您是否确实...", 
"body" : "该选项卡包含项目文件的一般信息和元信息。 CODESYS 使用此信息在 特性 标签。例如，如果名称 Company_A 指定在 公司 ，那么 Company 带有值的键 Company_A 提供在 特性 标签。 如果你 保存 你的项目作为一个库项目，那么你应该注意 图书馆开发者指南 . 对于图书馆项目，一个 公司 ， 一种 标题 , 和一个 版本 必须指定安装库。 公司 公司名称（例如： Company_A ) 标题 项目名称（例如 Automation_A ) 版本 项目的版本（例如： 0.0.0.1 ) 发布 ：激活修改保护 结果：如果您现在编辑项目，则会打开一个对话框提示以确认您是否确实要更改项目。如果您通过单击回复此提示一次 是的 ，则不会出现更多的编辑操作提示。 图书馆类别 图书馆项目的类别，您可以根据类别进行排序 图书馆存储库 对话 如果未指定类别，则类别 其他 分配给图书馆。 类别源自一个或多个 XML 格式的外部描述文件。但是，它们也可以源自已创建的库项目。 要求：项目为图书馆项目。 ： 这 图书馆分类 对话框打开，您可以在其中添加库类别。 有关创建库类别的更多信息，请参阅： 图书馆类别 默认命名空间 要求：该项目是一个库项目。 如果您未在此处定义默认命名空间，则库文件的名称将自动应用为命名空间。 占位符 要求：该项目是一个库项目。 用于引用此库的占位符名称 例子： SysMem 根据语法显示通过占位符起作用的引用 #<placeholder name> . 重要提示：无法再更改占位符的名称。因此，强烈建议选择一个别人会选择完全相同的可能性很低的名字。 提示：您可以通过库占位符集成引用的库。这样您就可以避免由于版本依赖性或使用供应商特定库的必要性而可能发生的问题。 作者 项目作者（例如： Arnold Best ) 描述 例子： For internal use only 对话： 图书馆分类 类别列表 分配给图书馆项目的类别列表 它们可以来自多个来源。 指定所有所需类别后，单击 好的 确认。 按钮 添加 这 来自描述文件 和 从其他图书馆 命令出现。 按钮 消除 CODESYS 删除选定的类别。 命令： 来自描述文件 这 选择描述文件 打开对话框供您选择描述文件（ *.libcat.xml ）。该文件包含命令类别。当你点击 打开 , CODESYS 接受类别。 命令： 从其他图书馆 这 选择图书馆 对话框打开，您可以在其中选择一个包含要接受的命令类别的库。当你点击 打开 , CODESYS 接受类别。 按钮 好的 CODESYS 将类别作为项目信息提供并显示在 图书馆分类 场地。 " }, 
{ "title" : "选项卡：属性 ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_8210ee8558567f55c0a8640e01b29160", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：项目信息 \/ 选项卡：属性 ", 
"snippet" : "在此选项卡上，您可以定义可以从用户特定程序外部控制的键。 如果您打开了一个库项目，请注意 图书馆开发者指南 ：《图书馆发展总结》。 如果您打开了一个 符号库 作为一个项目，那么关键 VisuSymbolLibrary = TRUE 必须定义。它将库标识为符号库。 钥匙 钥匙名称 为新密钥指定任何文本字符串，或从 特性 桌子。 类型 键的数据类型 可能的类型： 文本 , 日期 , 数字 , 布尔值 , 版本 价值 允许格式的键值： 文本 : 任意字符串 日期 ：日期的最低输入： 1.1 例子： Friday, January 1, 2016 12:00:00 数字 : Integer32 格式的...", 
"body" : "在此选项卡上，您可以定义可以从用户特定程序外部控制的键。 如果您打开了一个库项目，请注意 图书馆开发者指南 ：《图书馆发展总结》。 如果您打开了一个 符号库 作为一个项目，那么关键 VisuSymbolLibrary = TRUE 必须定义。它将库标识为符号库。 钥匙 钥匙名称 为新密钥指定任何文本字符串，或从 特性 桌子。 类型 键的数据类型 可能的类型： 文本 , 日期 , 数字 , 布尔值 , 版本 价值 允许格式的键值： 文本 : 任意字符串 日期 ：日期的最低输入： 1.1 例子： Friday, January 1, 2016 12:00:00 数字 : Integer32 格式的整数，带或不带符号 例子： -32500 布尔值 ： True 要么 False , 大小写无关 版本 : 最多四位数 例子： 1.1 , 1.0.1.0 添加 将新定义的密钥添加到 特性 桌子 编辑 保存对在 特性 桌子 消除 删除在 特性 桌子 特性 定义为键的属性列表 CODESYS 自动为信息中的信息创建密钥 概括 标签。 单击一个键以在列表上方的输入字段中对其进行编辑。 " }, 
{ "title" : "标签：统计 ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_a4b8c2db58567f55c0a8640e000a1036", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：项目信息 \/ 标签：统计 ", 
"snippet" : "该对话框提供有关项目中单个类型或使用的对象数量的统计信息。...", 
"body" : "该对话框提供有关项目中单个类型或使用的对象数量的统计信息。 " }, 
{ "title" : "标签：许可 ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_65b680f358567f57c0a8640e01071248", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：项目信息 \/ 标签：许可 ", 
"snippet" : "该对话框用于库的许可证保护。 您可以通过这种方式仅保护“编译库”。 变量 激活加密狗许可 ：该库需要具有许可证的加密狗才能使用它。 公司代码 必须从加密狗提供的许可证信息，以便以后使用库 产品代码 激活网址 激活邮件...", 
"body" : "该对话框用于库的许可证保护。 您可以通过这种方式仅保护“编译库”。 变量 激活加密狗许可 ：该库需要具有许可证的加密狗才能使用它。 公司代码 必须从加密狗提供的许可证信息，以便以后使用库 产品代码 激活网址 激活邮件 " }, 
{ "title" : "标签：签名 ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_4f62c3fafb05c6ffc0a8640e019c606c", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：项目信息 \/ 标签：签名 ", 
"snippet" : "此选项卡仅针对已使用此选项卡创建签名的现有库显示。对于新生成的库，此选项卡不再可见。 有关更多信息，请参阅： 检索和编辑项目信息创建证书签名库时（可能从 CODESYS V3 3.5 SP15 ) 和库兼容性 CODESYS < V3 3.5 SP15 未设置，此选项卡上的设置被禁用。在这种情况下，签名是通过必须分配给用户配置文件的证书来完成的。 安全屏幕 . 一种方法，不推荐，但在某些情况下可能需要与版本兼容 < 3.5 SP15 , 是在此对话框中通过供应商特定的一次性密钥对库进行的不太安全的签名。要求：此密钥可作为“ 私钥 “ 文件 （ *.libpk ) 带有关联的令牌。图书馆的用户还...", 
"body" : "此选项卡仅针对已使用此选项卡创建签名的现有库显示。对于新生成的库，此选项卡不再可见。 有关更多信息，请参阅： 检索和编辑项目信息创建证书签名库时（可能从 CODESYS V3 3.5 SP15 ) 和库兼容性 CODESYS < V3 3.5 SP15 未设置，此选项卡上的设置被禁用。在这种情况下，签名是通过必须分配给用户配置文件的证书来完成的。 安全屏幕 . 一种方法，不推荐，但在某些情况下可能需要与版本兼容 < 3.5 SP15 , 是在此对话框中通过供应商特定的一次性密钥对库进行的不太安全的签名。要求：此密钥可作为“ 私钥 “ 文件 （ *.libpk ) 带有关联的令牌。图书馆的用户还必须获得这个密钥，以便能够检查最后的签名是否实际上是由图书馆供应商执行的。 激活签名 ： CODESYS 使用一次性的、供应商特定的密钥对库项目进行签名。 私钥文件 私钥文件的位置 *.libpk （例子： D:\\for lib developers only\\mycomp_libkey.libpk ）。 公钥令牌 例子： 427A5701DA3CF3CF 要求：指定一个私钥文件，并且 CODESYS 已读取并输入令牌。 创建私钥文件 CODESYS 创建一个新的私钥文件。 " }, 
{ "title" : "创建用于访问项目信息的块的选项 ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_0a188ec6fa561b9fc0a8640e0019d8bf", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：项目信息 \/ 创建用于访问项目信息的块的选项 ", 
"snippet" : "自动生成“项目信息”POU 注意：使用此选项创建的函数只有在运行时支持 WSTRING 数据类型。如果不是这种情况，那么您可以使用为项目信息的各个项目自动创建的功能，至少在用于访问属性的应用程序中。这些函数未在运行时注册。 ： CODESYS 创建 POU 的 FUNCTION 输入 POU 视图，允许以编程方式访问应用程序中的项目属性。功能块 GetCompany , GetTitle 和 GetVersion 为属性创建 公司 , 标题 和 版本 . 以下功能块可用于用户定义的属性： GetBooleanProperty ：布尔（真\/假） GetNumberProperty : DINT（...", 
"body" : "自动生成“项目信息”POU 注意：使用此选项创建的函数只有在运行时支持 WSTRING 数据类型。如果不是这种情况，那么您可以使用为项目信息的各个项目自动创建的功能，至少在用于访问属性的应用程序中。这些函数未在运行时注册。 ： CODESYS 创建 POU 的 FUNCTION 输入 POU 视图，允许以编程方式访问应用程序中的项目属性。功能块 GetCompany , GetTitle 和 GetVersion 为属性创建 公司 , 标题 和 版本 . 以下功能块可用于用户定义的属性： GetBooleanProperty ：布尔（真\/假） GetNumberProperty : DINT（数值） GetTextProperty ：WSTRING（字符串） GetTextProperty2 : 指向 WSTRING 的指针（无限长度） GetVersionProperty : VERSION（版本号作为字符串） 注意：不要为标准库激活此选项，因为由于额外的内存要求，这可能会在较小的系统上导致问题。 注意：如果一个库也包含这个项目信息 POU，那么你应该使用操作符 __水池 确保访问此 POU。 自动生成“图书馆信息”POU ： CODESYS 创建 POU 的 FUNCTION 输入 POU 视图，允许以编程方式访问应用程序中的项目属性。 为了 版本 和 发布 属性，创建以下函数： GetLibVersion （版本号为字符串）， GetLibVersionNumber （版本号为数值），和 IsLibReleased （真假）。 注意：这些函数未在运行时注册。该选项可用作替代解决方案是运行时不支持 WSTRING 数据类型，因此不允许您使用使用 自动生成“项目信息”POU 选项。 强制实现项目兼容性 : 当您使用存储库时 将项目另存为 命令，所选格式将被保存。 将项目另存为 再次执行命令，然后默认选择保存的选择。 如果您已激活此选项并添加了需要更新存储格式的对象，则会打开一个对话框。在对话框中，你需要明确确认或取消更新。 如果你点击 是的 ，然后保存项目中的所有更改而不会丢失数据。但是，将来无法再使用最初设置的存储格式打开该项目。新格式被定义为新的强制存储格式。 如果你点击 没有 ，则项目仍与设置的存储格式兼容，但并非所有更改都可以保存。 这个 强制实现项目兼容性 选项对于开发兼容库很有用。同时，这使得使用最新版本的编程系统成为可能。 激活此选项后的影响： 更新存储格式的请求被抑制。 需要保存在项目中的新功能无法使用。对于仅包含文本对象（例如 POU、DUT 和接口）的库的严格开发来说，这不是限制 可以自由选择编译器版本，但无法选择补丁版本。 如果当前选择了最新的编译器版本，则可以选择较旧的编译器版本。 " }, 
{ "title" : "对象：任务配置 ", 
"url" : "_cds_f_reference_task_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务配置 ", 
"snippet" : "任务配置 符号： 该对象用于定义和显示任务配置的基本设置。 的选项卡 任务配置 及其功能： 任务组 : 任务组的定义及其对 CPU 的分配 监视器 ：在联机模式下显示循环时间的状态和当前统计信息 变量用法 ：访问变量的任务及其操作方式概述 堆栈使用情况 : 根据调用层次结构划分的堆栈大小（以字节为单位） 系统事件 : 将 POU 呼叫与系统事件关联 属性 ：显示基本设置 CPU 负载 : 在线模式下 CPU 负载的图形表示...", 
"body" : "任务配置 符号： 该对象用于定义和显示任务配置的基本设置。 的选项卡 任务配置 及其功能： 任务组 : 任务组的定义及其对 CPU 的分配 监视器 ：在联机模式下显示循环时间的状态和当前统计信息 变量用法 ：访问变量的任务及其操作方式概述 堆栈使用情况 : 根据调用层次结构划分的堆栈大小（以字节为单位） 系统事件 : 将 POU 呼叫与系统事件关联 属性 ：显示基本设置 CPU 负载 : 在线模式下 CPU 负载的图形表示 " }, 
{ "title" : "选项卡：任务组 ", 
"url" : "_cds_obj_task_config_task_groups.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务配置 \/ 选项卡：任务组 ", 
"snippet" : "对象： 任务配置 您可以在 任务组 任务组可以分布在各个处理器核心上 多核 系统。 任务 任务组根据策略中定义的策略绑定到处理器核心 核 字段。在 优先事项 列中，任务的优先级按照在相应 IEC 任务的编辑器中配置的方式显示。 添加群组 The button adds a new task group named NewGroup_<no> . Remove Group Deletes the selected task group. Group Name The name can be changed by double-clicking in the field. Core 自由浮动 ：任...", 
"body" : "对象： 任务配置 您可以在 任务组 任务组可以分布在各个处理器核心上 多核 系统。 任务 任务组根据策略中定义的策略绑定到处理器核心 核 字段。在 优先事项 列中，任务的优先级按照在相应 IEC 任务的编辑器中配置的方式显示。 添加群组 The button adds a new task group named NewGroup_<no> . Remove Group Deletes the selected task group. Group Name The name can be changed by double-clicking in the field. Core 自由浮动 ：任务组中的所有 IEC 任务都由操作系统通过负载平衡动态分配到各个处理器核心。这意味着任务通常经常切换执行它们的处理器核心。用户对此没有控制权。 我们建议大多数应用程序使用此设置，因为负载由操作系统自动分配。 顺序固定 ：任务组的所有 IEC 任务都永久绑定到不同的处理器核心。如果处理器核心数少于任务数，则任务将绑定到各个处理器核心，从核心 1 开始，然后继续从核心 2、核心 3 等。如果发生溢出，则继续从核心 0、核心 1 等处理。用户对此没有控制权。 固定 ：任务组的所有 IEC 任务都永久绑定到一个处理器核心。默认情况下，运行时会确定处理器核心。通常使用 Core1。 如果有多个任务组 固定 设置，则每个任务组绑定到不同的处理器核心。这通常从 Core1 开始。 <固定核心数> 任务组的所有 IEC 任务都永久绑定到定义的处理器核心。如果控制器上不存在该处理器核心，则下载过程中会产生错误。 这 顺序固定 ， 固定 ， 和 <固定核心数> 设置有助于获得更确定的抖动时间。这是因为这些设置不受运行时向各个核心动态分配任务的影响。 然而，这会阻止操作系统在各个处理器核心之间分配负载。 因此，我们建议在测试这些设置后再使用这些设置。测试应表明这些设置可以显著改善实时行为。 " }, 
{ "title" : "选项卡：监控 ", 
"url" : "_cds_obj_task_config_monitor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务配置 \/ 选项卡：监控 ", 
"snippet" : "对象： 任务配置 该选项卡显示的状态 CODESYS 在线模式下的任务以及一些周期和周期时间的电流测量。刷新值的时间间隔与监控控制器值的时间间隔相同 有关更多信息，请参阅： 抖动和延迟的定义显示的值可以重置为 0 借助 重置 快捷菜单命令。 任务 任务名称（如任务配置中所定义） 状态 未创建 ：自上次更新以来，该任务尚未启动（尤其是对于事件任务）。 已生成 ：任务在运行时被识别，但尚未运行。 有效 : 任务运行正常。 例外 ：该任务已生成异常状态。 IEC 周期计数 自首次启动应用程序以来执行的实际调用 IEC 代码的循环次数。 结果，这个值对应于代码中的 Hugo 计数器。但是，如果目标系统...", 
"body" : "对象： 任务配置 该选项卡显示的状态 CODESYS 在线模式下的任务以及一些周期和周期时间的电流测量。刷新值的时间间隔与监控控制器值的时间间隔相同 有关更多信息，请参阅： 抖动和延迟的定义显示的值可以重置为 0 借助 重置 快捷菜单命令。 任务 任务名称（如任务配置中所定义） 状态 未创建 ：自上次更新以来，该任务尚未启动（尤其是对于事件任务）。 已生成 ：任务在运行时被识别，但尚未运行。 有效 : 任务运行正常。 例外 ：该任务已生成异常状态。 IEC 周期计数 自首次启动应用程序以来执行的实际调用 IEC 代码的循环次数。 结果，这个值对应于代码中的 Hugo 计数器。但是，如果目标系统不支持计数功能，则该数字将保持在 0 。 周期数 自登录控制器以来执行的周期数，即使任务已进入也是如此 停下来 该号码对应于以下电话 IecTaskCycle2 并且即使在应用程序处于启用状态时也会递增 停下来 。 但是，是否计算应用程序未运行的周期取决于目标系统。在这些情况下， 周期数 可以大于 IEC 周期计数 。 上次循环时间 (µs) 上次测量的循环时间 [µs] 平均循环时间 (µs) 所有周期的平均循环时间 [µs] 马克斯。循环时间 (µs 所有周期的最大测量循环时间 [µs] 最小。循环时间 (µs 所有周期的最小测量周期时间 [µs] 抖动 (µs) 周期性抖动的当前值 [µs] 注意：来自 CODESYS 3.5 SP11 到 SP15，显示周期性抖动的峰值峰值。在早期版本和 SP16 及更高版本中，会显示周期性抖动的当前值 最小。抖动 (µs) 测得的最小周期抖动 [µs] 马克斯。抖动 (µs) 测得的最大周期性抖动 [µs] 核心 当前运行任务的处理器内核的编号 示例： 2 要求：控制器配备多核处理器。 如果 CPU 不是多核 CPU，则该值 -1 显示在这里。 " }, 
{ "title" : "选项卡：变量用法 ", 
"url" : "_cds_obj_task_config_variable_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务配置 \/ 选项卡：变量用法 ", 
"snippet" : "对象： 任务配置 在选项卡中 变量使用 您将获得所有变量及其用途的概览。你看在哪个 任务 变量被访问。 使用时 多核 ，变量的写入权限 (w) 只能在任务中进行，否则会导致不一致。 在快捷菜单中，您可以隐藏单个任务并显示变量的交叉引用列表。 变量 变量的名称 类型 数据类型 计数 访问这些变量的任务数。 <task name> 访问变量（r：读取，w：写入，rw：读\/写）...", 
"body" : "对象： 任务配置 在选项卡中 变量使用 您将获得所有变量及其用途的概览。你看在哪个 任务 变量被访问。 使用时 多核 ，变量的写入权限 (w) 只能在任务中进行，否则会导致不一致。 在快捷菜单中，您可以隐藏单个任务并显示变量的交叉引用列表。 变量 变量的名称 类型 数据类型 计数 访问这些变量的任务数。 <task name> 访问变量（r：读取，w：写入，rw：读\/写） " }, 
{ "title" : "选项卡：堆栈使用情况 ", 
"url" : "_cds_obj_task_config_tab_stack_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务配置 \/ 选项卡：堆栈使用情况 ", 
"snippet" : "堆栈使用情况 任务配置编辑器中的选项卡 这个 堆栈使用情况 选项卡显示每个应用程序、每个任务以及最大调用堆栈中 POU 的当前堆栈使用情况。 显示信息的要求：应用程序代码已生成。这要么在登录控制器时自动完成，要么显式使用 构建 → 生成代码 命令。 覆盖目标设置中的默认堆栈大小 重写堆栈大小 可用堆栈大小 是专家函数。 仅当您激活此处的选项并确认随后出现的消息时，此输入字段才可用。该消息表明可能存在堆栈溢出的风险。可能会出现异常错误。 : 那个 可用堆栈大小 输入字段显示设备描述中当前设置的默认堆栈大小。不允许输入。默认设置。 这个 可用堆栈大小 可以编辑输入字段。你可以在那里指定一个新值或将...", 
"body" : "堆栈使用情况 任务配置编辑器中的选项卡 这个 堆栈使用情况 选项卡显示每个应用程序、每个任务以及最大调用堆栈中 POU 的当前堆栈使用情况。 显示信息的要求：应用程序代码已生成。这要么在登录控制器时自动完成，要么显式使用 构建 → 生成代码 命令。 覆盖目标设置中的默认堆栈大小 重写堆栈大小 可用堆栈大小 是专家函数。 仅当您激活此处的选项并确认随后出现的消息时，此输入字段才可用。该消息表明可能存在堆栈溢出的风险。可能会出现异常错误。 : 那个 可用堆栈大小 输入字段显示设备描述中当前设置的默认堆栈大小。不允许输入。默认设置。 这个 可用堆栈大小 可以编辑输入字段。你可以在那里指定一个新值或将其重置为默认值。 重置为默认值 单击该按钮可重置中的值 可用堆栈大小 到默认的堆栈大小。默认堆栈大小在设备描述中定义。 可用堆栈大小 可用堆栈大小（以字节为单位） 示例： 4,194,304 最大堆栈大小在设备描述中指定。此默认堆栈大小被读取并应用为可用堆栈大小。 您可以更改该值，如果 覆盖目标设置中的默认堆栈大小 选项已激活。 编译器会在编译期间检查应用程序中的最大堆栈使用量，如果可能出现溢出，则根据计算出的大小报告错误。 外部调用的假定堆栈大小 堆栈大小（以字节为单位），假定外部调用运行时系统 示例：如果显示 24，则假定对外部函数的调用使用堆栈上的 24 字节 注意：堆栈使用量的计算结果始终是估计值。 外部调用的堆栈大小的一般估计值在设备描述中指定。该值用于计算。除非已为具有'属性的外部呼叫分配了特殊的估计值， estimated-stack-usage'。在这种情况下，首选特殊值。 任务\/最大调用堆栈 在编译期间确定的调用堆栈（调用层次结构） 提示：如果此视图中的调用堆栈为空，则可以启动编译操作并调用 创建 → 生成代码 命令。然后即可获得有关堆栈使用情况的当前信息。 堆栈大小 每个调用 POU 使用的堆栈大小（以字节为单位） 或者堆栈大小通过任务的调用层次结构加起来 在编译期间，编译器计算最大调用链的最大堆栈使用量。 重要：当 POU 显示为红色时，表示已检测到此 POU 存在堆栈溢出。由于内存溢出，以下 POU 也显示为红色 有关更多信息，请参阅： 堆栈使用率的计算" }, 
{ "title" : "选项卡：系统事件 ", 
"url" : "_cds_obj_task_config_sys_event.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务配置 \/ 选项卡：系统事件 ", 
"snippet" : "对象： 任务配置 在 系统事件 选项卡，您可以定义哪些事件调用哪个函数，以及配置当前是否已激活。当 “系统事件”（而不是任务）应调用项目函数时，您可以使用此选项卡。 添加事件处理器 打开 添加事件处理器 对话框 移除事件处理器 删除选定的列表分配 活动信息 显示来自相应事件库的信息 打开活动功能 为所选任务打开新函数的编辑器 您已经在中选择了新函数的实现语言 添加事件处理器 对话框。 使用以下方法调用事件的函数的映射列表： 姓名 ， 描述 ， 要调用的函数 ，以及 活跃 （启用或禁用配置） 添加事件处理器 向列表中添加一个新分配 “事件-要调用的函数” 事件 可能的选择取决于目标设备。 COD...", 
"body" : "对象： 任务配置 在 系统事件 选项卡，您可以定义哪些事件调用哪个函数，以及配置当前是否已激活。当 “系统事件”（而不是任务）应调用项目函数时，您可以使用此选项卡。 添加事件处理器 打开 添加事件处理器 对话框 移除事件处理器 删除选定的列表分配 活动信息 显示来自相应事件库的信息 打开活动功能 为所选任务打开新函数的编辑器 您已经在中选择了新函数的实现语言 添加事件处理器 对话框。 使用以下方法调用事件的函数的映射列表： 姓名 ， 描述 ， 要调用的函数 ，以及 活跃 （启用或禁用配置） 添加事件处理器 向列表中添加一个新分配 “事件-要调用的函数” 事件 可能的选择取决于目标设备。 CODESYS 使用名称前面的红色符号标记不可用的事件。 所有可能的系统事件列表位于本节末尾。 要调用的函数 函数名 ( POU ，键入 函数 ) 你需要指定名称 新 函数。 CODESYS 确认对话框后，将该函数插入到设备树中。 范围 应用程序 ：该功能可供应用程序使用。 POU ：该功能适用于整个项目。 实现语言 新函数的实现语言 描述 所选事件的简短描述 " }, 
{ "title" : "在线模式下的功能 ", 
"url" : "_cds_obj_task_config_sys_event.html#UUID-c1043114-d606-9162-3795-5a941a24ff08_id_e5ddda49857aab52c0a8640e01f6cda7_id_aca2ec018ac2b258c0a8640e004f986b", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务配置 \/ 选项卡：系统事件 \/ 在线模式下的功能 ", 
"snippet" : "从调用函数到事件的分配列表还包括以下信息： 活动状态 ， 通话次数 ，以及 在线重置 按钮。 活动状态 0 : 未发生错误。 不等于 0 : 错误。你需要查阅相应的运行时文档。 通话次数 显示事件发生或调用关联函数的频率 在线重置 CODESYS 重新初始化事件列表并重置事件\/函数调用的计数器。错误初始化的事件显示为红色状态行...", 
"body" : "从调用函数到事件的分配列表还包括以下信息： 活动状态 ， 通话次数 ，以及 在线重置 按钮。 活动状态 0 : 未发生错误。 不等于 0 : 错误。你需要查阅相应的运行时文档。 通话次数 显示事件发生或调用关联函数的频率 在线重置 CODESYS 重新初始化事件列表并重置事件\/函数调用的计数器。错误初始化的事件显示为红色状态行 " }, 
{ "title" : "可能的系统事件 ", 
"url" : "_cds_obj_task_config_sys_event.html#UUID-c1043114-d606-9162-3795-5a941a24ff08_id_e5ddda49857aab52c0a8640e01f6cda7_id_18ba31b03c03a634c0a8640e01f61238", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务配置 \/ 选项卡：系统事件 \/ 可能的系统事件 ", 
"snippet" : "事件 描述 任务 调试 PrepareStart 在启动应用程序之前致电 沟通任务 没有 StartDone 启动应用程序后调用 沟通任务 没有 PrepareStop 在停止应用程序之前致电 沟通任务 没有 StopDone 停止应用程序后呼叫 沟通任务 没有 PrepareReset 在重置应用程序之前致电 沟通任务 没有 ResetDone 重置应用程序后调用 沟通任务 没有 PrepareOnlineChange 在在线更改应用程序之前致电 沟通任务 没有 OnlineChangeDone 在线更改应用程序后致电 沟通任务 没有 PrepareDownload 在下载应用程序之前致电 ...", 
"body" : "事件 描述 任务 调试 \n PrepareStart\n 在启动应用程序之前致电 沟通任务 没有 \n StartDone\n 启动应用程序后调用 沟通任务 没有 \n PrepareStop\n 在停止应用程序之前致电 沟通任务 没有 \n StopDone\n 停止应用程序后呼叫 沟通任务 没有 \n PrepareReset\n 在重置应用程序之前致电 沟通任务 没有 \n ResetDone\n 重置应用程序后调用 沟通任务 没有 \n PrepareOnlineChange\n 在在线更改应用程序之前致电 沟通任务 没有 \n OnlineChangeDone\n 在线更改应用程序后致电 沟通任务 没有 \n PrepareDownload\n 在下载应用程序之前致电 沟通任务 没有 \n DownloadDone\n 下载应用程序后致电 沟通任务 没有 \n PrepareDelete\n 在删除应用程序之前致电 沟通任务 没有 \n DeleteDone\n 删除应用程序后致电 沟通任务 没有 \n PrepareExit\n 在退出应用程序之前致电 沟通任务 没有 \n ExitDone\n 退出应用程序后致电 沟通任务 没有 \n CodeInitDone\n 事件在代码初始化之后发送。在 Task Safe 部分中调用，仅在进行在线更改时才调用。（例如，在线更改的复制代码在此处执行） 沟通任务 没有 \n Exception\n 如果应用程序上下文中发生异常，则发送该事件。 运行时的异常处理任务，如果运行时不支持异常处理，则为任务本身 视任务而定 \n Login\n 客户端登录到此应用程序 沟通任务 没有 \n Logout\n 从该应用程序注销客户端 沟通任务 没有 \n BeforeReadingInputs\n 在读取输入之前先打电话 IEC 任务 是的 \n AfterReadingInputs\n 读取输入后打电话 IEC 任务 是的 \n BeforeWritingOutputs\n 在写入输出之前调用 IEC 任务 是的 \n AfterWritingOutputs\n 写入输出后调用 IEC 任务 是的 \n DebugLoop\n 如果 IEC 任务在断点处停止，则会循环将事件发送到调试回路。 沟通任务 没有 \n PrepareShutdown\n 事件在下载运行时之前立即发送。 运行时主循环 没有 \n PrepareExitComm\n 在退出通信服务器之前，会在下载期间发送事件。 运行时主循环 没有 \n PrepareExitTasks\n 在退出之前在下载期间发送事件 ( Exit ) 所有任务。 运行时主循环 没有 " }, 
{ "title" : "选项卡：属性 ", 
"url" : "_cds_obj_task_config_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务配置 \/ 选项卡：属性 ", 
"snippet" : "对象： 任务配置 的基本设置 任务配置 由目标系统指定的将显示在选项卡上。例如，任务的最大值和监视程序参数...", 
"body" : "对象： 任务配置 的基本设置 任务配置 由目标系统指定的将显示在选项卡上。例如，任务的最大值和监视程序参数 " }, 
{ "title" : "Tab: CPU Load ", 
"url" : "_cds_obj_task_config_core_deployment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务配置 \/ Tab: CPU Load ", 
"snippet" : "对象： 任务配置 这 CPU 负载 选项卡在在线模式下可用 多核 仅限设备。各个 CPU 的负载显示在跟踪编辑器中。 有关更多信息，请参阅： 访问控制器上的所有跟踪 如果 CODESYS Trace 安装完毕后，您可以通过双击右侧窗口中的图例来打开跟踪配置。此处不可能添加更多变量。...", 
"body" : "对象： 任务配置 这 CPU 负载 选项卡在在线模式下可用 多核 仅限设备。各个 CPU 的负载显示在跟踪编辑器中。 有关更多信息，请参阅： 访问控制器上的所有跟踪 如果 CODESYS Trace 安装完毕后，您可以通过双击右侧窗口中的图例来打开跟踪配置。此处不可能添加更多变量。 " }, 
{ "title" : "Linux 系统上的任务优先级映射 ", 
"url" : "_cds_task_mapping_in_the_linux_system.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务配置 \/ Linux 系统上的任务优先级映射 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "IEC 任务优先级和 Linux 优先级之间的依赖关系 ", 
"url" : "_cds_task_mapping_in_the_linux_system.html#UUID-b85d83f0-ecf3-8513-c7aa-c29a2e7321c1_id_f1373b689f854d9c0a864633626272f_id_4e49477d8a294f1dc0a864636423535f", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务配置 \/ Linux 系统上的任务优先级映射 \/ IEC 任务优先级和 Linux 优先级之间的依赖关系 ", 
"snippet" : "当目标系统在 Linux 中运行时，IEC 任务的特定优先级映射到特定的优先级和调度策略。根据优先级，调度策略 SCHED_FIFO 要么 SCHED_OTHER 如表所示。 IEC 任务优先级 Linux 优先级 Linux（默认） 0（最高实时优先级） 56 ( SCHED_FIFO ) 15（最低实时优先级） 41 ( SCHED_FIFO ) 16（无实时优先级） 0 ( SCHED_OTHER ) 31（无实时优先级） 0 ( SCHED_OTHER )...", 
"body" : "当目标系统在 Linux 中运行时，IEC 任务的特定优先级映射到特定的优先级和调度策略。根据优先级，调度策略 SCHED_FIFO 要么 SCHED_OTHER 如表所示。 IEC 任务优先级 Linux 优先级 Linux（默认） 0（最高实时优先级） 56 ( SCHED_FIFO ) 15（最低实时优先级） 41 ( SCHED_FIFO ) 16（无实时优先级） 0 ( SCHED_OTHER ) 31（无实时优先级） 0 ( SCHED_OTHER ) " }, 
{ "title" : "对象：任务 ", 
"url" : "_cds_f_reference_task.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务 ", 
"snippet" : "任务 符号： 您在对象中配置任务。您可以配置优先级、具有时间行为的类型和监视程序。你也可以添加 PROGRAM 呼叫。 该对象位于设备树下方的设备树中 任务配置 。...", 
"body" : "任务 符号： 您在对象中配置任务。您可以配置优先级、具有时间行为的类型和监视程序。你也可以添加 PROGRAM 呼叫。 该对象位于设备树下方的设备树中 任务配置 。 " }, 
{ "title" : "选项卡：配置 ", 
"url" : "_cds_f_reference_task.html#UUID-f12a90d6-4453-79d4-dbff-668d397ebde9", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务 \/ 选项卡：配置 ", 
"snippet" : "对象： 任务 优先级 可能的值：0.. 31，其中 0 是最高优先级 任务组 已分配 任务组 可以分配给多核中的特定处理器内核 示例： IEC 任务 注意：任务组显示在设备树中任务后的方括号中。 在 Linux 中使用运行时系统时，任务组和优先级之间存在固定的依赖关系。有关更多信息，请参阅： Linux 系统上的任务优先级映射...", 
"body" : "对象： 任务 优先级 可能的值：0.. 31，其中 0 是最高优先级 任务组 已分配 任务组 可以分配给多核中的特定处理器内核 示例： IEC 任务 注意：任务组显示在设备树中任务后的方括号中。 在 Linux 中使用运行时系统时，任务组和优先级之间存在固定的依赖关系。有关更多信息，请参阅： Linux 系统上的任务优先级映射" }, 
{ "title" : "类型 ", 
"url" : "_cds_f_reference_task.html#UUID-f12a90d6-4453-79d4-dbff-668d397ebde9_id_b3ea97b9439f77fc0a8640e009ee507_id_2c355b338a28d370c0a8646340a97328", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务 \/ 选项卡：配置 \/ 类型 ", 
"snippet" : "类型： 循环的 任务的处理是循环完成的。 输入字段： 间隔 必填项 任务重启的时间跨度（任务周期时间） 作为时间定义，格式为 TIME# 示例： t#200ms 作为一个数字 示例： 200 注意：该数字将自动以以下格式显示 TIME# 当输入字段再次聚焦时。 注意：任务与所需任务周期时间的偏差在运行时以周期性抖动的形式显示在 选项卡：监控 选项卡。 间隔的时间单位 如果在中仅指定了数字而不是时间定义 间隔 输入字段，则此处选择的单位决定时间维度。 示例： ms 注意：以 µs 为单位的任务周期时间始终显示为数字。 类型： 事件 任务的处理在事件变量的上升沿开始以事件触发。 输入字段： 事件 ...", 
"body" : "类型： 循环的 任务的处理是循环完成的。 输入字段： 间隔 必填项 任务重启的时间跨度（任务周期时间） 作为时间定义，格式为 TIME# 示例： t#200ms 作为一个数字 示例： 200 注意：该数字将自动以以下格式显示 TIME# 当输入字段再次聚焦时。 注意：任务与所需任务周期时间的偏差在运行时以周期性抖动的形式显示在 选项卡：监控 选项卡。 间隔的时间单位 如果在中仅指定了数字而不是时间定义 间隔 输入字段，则此处选择的单位决定时间维度。 示例： ms 注意：以 µs 为单位的任务周期时间始终显示为数字。 类型： 事件 任务的处理在事件变量的上升沿开始以事件触发。 输入字段： 事件 全局变量（布尔类型） 变量值从 0 切换到 1 后，任务立即启动。 类型： 外部 任务的处理在事件变量的上升沿开始以事件触发。 清单框： 事件 包含目标系统相关事件的列表（布尔类型） 注意：目标系统决定列表框中支持和提供哪些事件。 提示：不要与系统事件混淆 间隔 中的时间定义 TIME# 格式化或作为带有时间单位的数字 注意：仅在事件需要时间定义时可用 类型 自由运行 任务的处理在程序启动时以及运行结束后，在一定等待时间后自动以连续循环方式重新启动 重要：完成运行后，需要等待一定的时间才能再次执行任务。持续时间是最后一个周期持续时间的百分比。 注意：您未定义循环时间。 类型 地位 任务的处理开始时由事件变量触发 输入字段： 事件 全局变量（布尔类型） 当变量具有状态 TRUE ，任务开始自由运行。任务运行直到变量获得值 FALSE 。 注意：变量通常在任务本身中重置。与事件任务不同，这种方式不会错过任何事件。当事件发生时，调度程序必须保存一个旧值，并且该值更改的频率可能比检查的频率更高。因此，如果事件变量更改为 TRUE 仅在短时间内，调度程序可能无法检测到此变化。这可以通过状态任务来避免。状态变量设置为 TRUE 由其他任务执行，并由状态任务重置。这确保每次切换到 TRUE 。 对于现场总线，固定周期矩阵是确保确定行为所必需的。因此，您不应该使用 类型 随心所欲 用于总线循环任务。 请注意处理类型之间的以下区别 状态 和 事件 : 如果给定事件产生 TRUE ，然后是类型为的任务的启动条件 状态 已完成。相比之下，类型为任务的开始 事件 需要从以下位置切换事件 FALSE 到 TRUE 。如果任务调度器的采样率太低，则事件的上升趋势可能不会被注意到 设置任务周期时间时，需要确定当前正在使用哪个总线系统。例如，CAN 总线系统中的任务周期必须与当前设置的波特率和总线中使用的帧数相匹配。此外，为心跳、节点保护和同步设置的时间应始终是任务周期时间的倍数。否则，CAN 帧可能会丢失。 有关更多信息，请参阅： 选项卡：监控" }, 
{ "title" : "看门狗 ", 
"url" : "_cds_f_reference_task.html#UUID-f12a90d6-4453-79d4-dbff-668d397ebde9_section-idm23475286613854", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务 \/ 选项卡：配置 \/ 看门狗 ", 
"snippet" : "定义任务的时间监控。如果目标系统支持高级监视程序配置，则可以在设备描述中预定义以下设置 上限和下限 默认监视器时间 时间以百分比指定 默认监视程序设置取决于设备。 启用 ：监视程序处于活动状态。 如果任务超过了监视程序当前设定的时间，则任务将暂停并显示错误状态（异常）。任务中出现错误的应用程序及其子应用程序也已暂停。这样，受影响应用程序的所有任务也将暂停。然后是当前定义的 灵敏度 也被考虑在内。 如果你激活该选项 更新 I\/O 在 PLC 设置 那么 PLC 的 CODESYS 将输出重置为定义的默认值。 可能的情况： 多次连续超时： 灵敏度：0、1 — 周期 1 出现异常 灵敏度：2 — 周...", 
"body" : "定义任务的时间监控。如果目标系统支持高级监视程序配置，则可以在设备描述中预定义以下设置 上限和下限 默认监视器时间 时间以百分比指定 默认监视程序设置取决于设备。 启用 ：监视程序处于活动状态。 如果任务超过了监视程序当前设定的时间，则任务将暂停并显示错误状态（异常）。任务中出现错误的应用程序及其子应用程序也已暂停。这样，受影响应用程序的所有任务也将暂停。然后是当前定义的 灵敏度 也被考虑在内。 如果你激活该选项 更新 I\/O 在 PLC 设置 那么 PLC 的 CODESYS 将输出重置为定义的默认值。 可能的情况： 多次连续超时： 灵敏度：0、1 — 周期 1 出现异常 灵敏度：2 — 周期 2 中出现异常 灵敏度：n — 周期 n 中的异常 单次超时：如果当前周期的循环时间长于（时间 * 灵敏度），则出现异常。示例：time=T #10ms，灵敏度=5（即一次性任务运行时间超过 50 毫秒即出现异常 时间（例如 t #200ms） 看门狗时间 定义（和 灵敏度 ) 任务的监视器；相应的描述 启用 。 视目标系统而定，如果可能，监视时间跨度以任务间隔的百分比表示。在这种情况下，该设备的列表框被禁用并显示 % 。 灵敏度 数字 定义（与监视器一起）任务的监视程序；描述为 启用 。 使用库中的函数 CmpIecTask.library ，您可以针对特定 PLC 周期停用监视器。这对于因初始化而需要更多时间的周期很有用。 示例 停用\/重新激活监视程序： VAR\nhIecTask : RTS_IEC_HANDLE;\nEND_VAR\n\nhIecTask := IecTaskGetCurrent(0);\nIecTaskDisableWatchdog(hIecTask); \/\/Watchdog disabled\n...\nIecTaskEnableWatchdog(hIecTask); \/\/Watchdog enabled 看门狗在初始化之前被停用 IecTaskDisableWatchDog 循环的其余部分，并在下一个循环中自动重新激活。 看门狗可以在初始化后重新激活 IecTaskEnableWatchDog .然后看门狗已经在周期的剩余时间内重新激活（看门狗时间窗口再次从头开始）。 功能块的初始化发生在 FB_Init 方法不受此影响。但是由于通信超时，有 < 30 秒的限制。自 V3.5 SP18 起不再存在此时间限制，因为在线服务是异步执行的。 当 IEC 任务的执行时间超过监视程序时间时，将触发 IEC 任务的正常监视程序。 当任务根本没有启动时，就会触发 “省略周期” 监视程序。当任务在 < 的最大值内根本不执行任何循环时，就会出现这种情况 时间 * 灵敏度 > 或 <2 * 间隔 >。原因可能是其他任务挤满了人，或者调度程序出现故障，无法再启用 " }, 
{ "title" : "程序调用 ", 
"url" : "_cds_f_reference_task.html#UUID-f12a90d6-4453-79d4-dbff-668d397ebde9_section-idm234752870373128", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：任务 \/ 选项卡：配置 \/ 程序调用 ", 
"snippet" : "POU ( POU 带有类型的对象 PROGRAM ) 由任务连续调用 POU 的调用顺序对应于此处自上而下配置的呼叫顺序。 添加通话 打开输入助手。选择一个 PROGRAM POU。当你点击 好吧 要退出输入助手，它会作为新呼叫添加到下面的列表中。 移除通话 移除通话 更改通话 打开所选呼叫的输入助手。选择另一个 PROGRAM POU。当您单击时，呼叫会发生变化 好吧 退出输入助手。 向上移动 向下移动 在列表中向上或向下移动呼叫的位置。调用顺序在运行时会相应更改。 打开 POU 打开 POU 编辑器，其中包含声明和实现 PROGRAM POU...", 
"body" : "POU ( POU 带有类型的对象 PROGRAM ) 由任务连续调用 POU 的调用顺序对应于此处自上而下配置的呼叫顺序。 添加通话 打开输入助手。选择一个 PROGRAM POU。当你点击 好吧 要退出输入助手，它会作为新呼叫添加到下面的列表中。 移除通话 移除通话 更改通话 打开所选呼叫的输入助手。选择另一个 PROGRAM POU。当您单击时，呼叫会发生变化 好吧 退出输入助手。 向上移动 向下移动 在列表中向上或向下移动呼叫的位置。调用顺序在运行时会相应更改。 打开 POU 打开 POU 编辑器，其中包含声明和实现 PROGRAM POU " }, 
{ "title" : "对象：跟踪 ", 
"url" : "_cds_obj_trace_1.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对象 \/ 对象：跟踪 ", 
"snippet" : "跟踪 象征： 类型的对象 痕迹 用于在一个或多个图表中配置和显示特定于应用程序的跟踪数据。在应用程序运行时，跟踪变量的值曲线，您可以在跟踪编辑器中的 CODESYS 在此期间，记录在控制器上。要求是已将跟踪配置传输到控制器，并且已开始跟踪记录。采样数据传输到开发系统并根据配置以图表形式显示。您可以在跟踪时浏览数据。 欲了解更多信息，请参阅： ..\/CODESYS 跟踪\/_cds_obj_trace.html...", 
"body" : "跟踪 象征： 类型的对象 痕迹 用于在一个或多个图表中配置和显示特定于应用程序的跟踪数据。在应用程序运行时，跟踪变量的值曲线，您可以在跟踪编辑器中的 CODESYS 在此期间，记录在控制器上。要求是已将跟踪配置传输到控制器，并且已开始跟踪记录。采样数据传输到开发系统并根据配置以图表形式显示。您可以在跟踪时浏览数据。 欲了解更多信息，请参阅： ..\/CODESYS 跟踪\/_cds_obj_trace.html " }, 
{ "title" : "菜单命令 ", 
"url" : "_cds_struct_reference_commands.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 ", 
"snippet" : "默认情况下，用户界面中的主要命令 CODESYS 无障碍。如果要自定义菜单配置，请选择命令 工具 → 调整 → 菜单 ....", 
"body" : "默认情况下，用户界面中的主要命令 CODESYS 无障碍。如果要自定义菜单配置，请选择命令 工具 → 调整 → 菜单 . " }, 
{ "title" : "编辑 ", 
"url" : "_cds_f_commands_edit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "标准命令 ", 
"url" : "_cds_cmd_standard_edit_commands.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 标准命令 ", 
"snippet" : "CODESYS 为您提供以下标准命令： ： 撤消 键盘快捷键： 控制 + Z ： 恢复 键盘快捷键： 控制 + 是 ： 切割出 键盘快捷键： 控制 + X ： 复制 键盘快捷键： 控制 + C ： 插入 键盘快捷键： 控制 + 五 ： 熄灭 键盘快捷键： 距离 选择一切 键盘快捷键： 控制 + 一个 命令 插入 并非所有编辑器都支持，或者只能在某些情况下有限使用。在图形编辑器中，仅当粘贴产生正确的结构时才支持该命令。 在对象树中，例如在 POU 或设备窗口中，该命令引用当前选定的对象。可以多选。...", 
"body" : "CODESYS 为您提供以下标准命令： ： 撤消 键盘快捷键： 控制 + Z ： 恢复 键盘快捷键： 控制 + 是 ： 切割出 键盘快捷键： 控制 + X ： 复制 键盘快捷键： 控制 + C ： 插入 键盘快捷键： 控制 + 五 ： 熄灭 键盘快捷键： 距离 选择一切 键盘快捷键： 控制 + 一个 命令 插入 并非所有编辑器都支持，或者只能在某些情况下有限使用。在图形编辑器中，仅当粘贴产生正确的结构时才支持该命令。 在对象树中，例如在 POU 或设备窗口中，该命令引用当前选定的对象。可以多选。 " }, 
{ "title" : "命令：查找，在项目中查找 ", 
"url" : "_cds_cmd_find.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：查找，在项目中查找 ", 
"snippet" : "搜索 , 在项目中搜索 象征： 键盘快捷键： 控制 + F 象征： 键盘快捷键： 控制 + 切换 + F 功能 ：这些命令在项目或项目的一部分中搜索某个字符串。 称呼 ： 菜单 编辑→查找替换 该命令打开对话框 搜索 ，其中输入要搜索的字符串并定义搜索选项。...", 
"body" : "搜索 , 在项目中搜索 象征： 键盘快捷键： 控制 + F 象征： 键盘快捷键： 控制 + 切换 + F 功能 ：这些命令在项目或项目的一部分中搜索某个字符串。 称呼 ： 菜单 编辑→查找替换 该命令打开对话框 搜索 ，其中输入要搜索的字符串并定义搜索选项。 " }, 
{ "title" : "对话：搜索 ", 
"url" : "_cds_cmd_find.html#UUID-dda521c8-7f56-fdfd-8ee1-6c9e2a366507_id_a6c8fe1a8c54f84c0a8640e01eb30dd_id_33f08ba0ec4b8c25c0a864636ff12b4d", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：查找，在项目中查找 \/ 对话：搜索 ", 
"snippet" : "搜索 要搜索的字符串 区分大小写 : 搜索区分大小写。 仅全字 ：只会找到与搜索字符串完全匹配的字符串。 抬头 ：向上遍历指定的搜索空间。 ：向下遍历指定的搜索空间。 使用正则表达式 关于按钮 输入正则表达式时获得支持。 搜索 : 包含要搜索的项目区域的选择列表 活跃的编辑 所有打开的编辑器 选定对象和子对象 整个项目 整个项目和未编译的库 仅选择 ：打开一个对话框，您可以在其中设置要搜索的项目区域（见下文） 继续寻找 开始搜索 所有搜索 所有搜索结果都显示在消息窗口中，其中包含有关对象路径、项目名称、对象名称和对象位置的信息。可能增加的职位： （宣布） = 对象的声明部分， （实施） = 对...", 
"body" : "搜索 要搜索的字符串 区分大小写 : 搜索区分大小写。 仅全字 ：只会找到与搜索字符串完全匹配的字符串。 抬头 ：向上遍历指定的搜索空间。 ：向下遍历指定的搜索空间。 使用正则表达式 关于按钮 输入正则表达式时获得支持。 搜索 : 包含要搜索的项目区域的选择列表 活跃的编辑 所有打开的编辑器 选定对象和子对象 整个项目 整个项目和未编译的库 仅选择 ：打开一个对话框，您可以在其中设置要搜索的项目区域（见下文） 继续寻找 开始搜索 所有搜索 所有搜索结果都显示在消息窗口中，其中包含有关对象路径、项目名称、对象名称和对象位置的信息。可能增加的职位： （宣布） = 对象的声明部分， （实施） = 对象的实现部分 双击列表条目，焦点会跳转到相应对象编辑器中的命中位置。 代替 切换到对话 代替 搜索结果标记的颜色可以在 文本编辑器选项 进行调整。这是使用参数完成的 选择颜色 - 不活跃 在选项卡中 文本区 . " }, 
{ "title" : "用于设置要搜索的对象的对话框 ", 
"url" : "_cds_cmd_find.html#UUID-dda521c8-7f56-fdfd-8ee1-6c9e2a366507_id_a6c8fe1a8c54f84c0a8640e01eb30dd_id_5df2ec8bf5f911e3b101fb023b1f8cd5", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：查找，在项目中查找 \/ 用于设置要搜索的对象的对话框 ", 
"snippet" : "整个项目 搜索项目所有对象中的所有可编辑位置。 整个项目和所有未编译的库 搜索项目的所有对象和链接的非编译库中的所有可编辑位置 在以下对象内 仅搜索此处定义的对象内的可编辑位置： 方案 : 通过命令 保存在电脑上 当前搜索配置保存在指定名称下。所有保存的方案都可以通过选择列表访问（ ） 无障碍。 对象类型 ： : 搜索对象。 名称过滤器 ：要搜索的对象的名称过滤器 可以使用通配符“*”。 示例：过滤器“*CAN*”：搜索名称中包含“CAN”的所有对象。 所有打开的编辑器 搜索当前在窗口中打开的所有编辑器。 活跃的编辑 仅搜索光标所在的编辑器。 仅选择 仅搜索对象中当前选定的文本。...", 
"body" : "整个项目 搜索项目所有对象中的所有可编辑位置。 整个项目和所有未编译的库 搜索项目的所有对象和链接的非编译库中的所有可编辑位置 在以下对象内 仅搜索此处定义的对象内的可编辑位置： 方案 : 通过命令 保存在电脑上 当前搜索配置保存在指定名称下。所有保存的方案都可以通过选择列表访问（ ） 无障碍。 对象类型 ： : 搜索对象。 名称过滤器 ：要搜索的对象的名称过滤器 可以使用通配符“*”。 示例：过滤器“*CAN*”：搜索名称中包含“CAN”的所有对象。 所有打开的编辑器 搜索当前在窗口中打开的所有编辑器。 活跃的编辑 仅搜索光标所在的编辑器。 仅选择 仅搜索对象中当前选定的文本。 " }, 
{ "title" : "命令：替换，在项目中替换 ", 
"url" : "_cds_cmd_replace.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：替换，在项目中替换 ", 
"snippet" : "替换，在项目中替换 象征： 键盘快捷键： 控制 + H 象征： 键盘快捷键： 控制 + 切换 + H 功能 ：这些命令在项目或项目的一部分中搜索某个字符串并替换它。 称呼 ： 菜单 编辑→查找替换 要求 ：应用程序处于在线模式。 该命令打开对话框 代替 ，其中输入要替换的字符串和新的字符串并定义搜索选项。 除了“搜索”对话框中的选项外，还可以进行以下设置： 用。。。来代替 新字符串的输入字段 代替 这会突出显示并替换在编辑器中找到的下一个字符串（逐步替换）。 替换一切 找到的所有字符串都会立即替换，而不会显示在编辑器中。 全部替换后使更改的对象保持打开状态 找到的对象的编辑器保持打开状态。 无...", 
"body" : "替换，在项目中替换 象征： 键盘快捷键： 控制 + H 象征： 键盘快捷键： 控制 + 切换 + H 功能 ：这些命令在项目或项目的一部分中搜索某个字符串并替换它。 称呼 ： 菜单 编辑→查找替换 要求 ：应用程序处于在线模式。 该命令打开对话框 代替 ，其中输入要替换的字符串和新的字符串并定义搜索选项。 除了“搜索”对话框中的选项外，还可以进行以下设置： 用。。。来代替 新字符串的输入字段 代替 这会突出显示并替换在编辑器中找到的下一个字符串（逐步替换）。 替换一切 找到的所有字符串都会立即替换，而不会显示在编辑器中。 全部替换后使更改的对象保持打开状态 找到的对象的编辑器保持打开状态。 无法替换引用的库。 " }, 
{ "title" : "命令：查找下一个 ", 
"url" : "_cds_cmd_find_next.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：查找下一个 ", 
"snippet" : "继续寻找 象征： 键盘快捷键： F3 功能 ：在项目中搜索特定字符串时，该命令在相关编辑器中的位置选择下一个搜索结果。 称呼 ： 菜单 编辑→查找替换 要求 : 你必须使用命令 搜索 或者 代替 开始在项目中搜索特定字符串。 有关更多信息，请参阅： 项目范围内的搜索和替换...", 
"body" : "继续寻找 象征： 键盘快捷键： F3 功能 ：在项目中搜索特定字符串时，该命令在相关编辑器中的位置选择下一个搜索结果。 称呼 ： 菜单 编辑→查找替换 要求 : 你必须使用命令 搜索 或者 代替 开始在项目中搜索特定字符串。 有关更多信息，请参阅： 项目范围内的搜索和替换" }, 
{ "title" : "命令：查找下一个（选择） ", 
"url" : "_cds_cmd_find_next_selected.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：查找下一个（选择） ", 
"snippet" : "进一步搜索（选择） 键盘快捷键： 控制 + F 功能 ：该命令在项目中搜索下一个与当前选择的字符串或光标当前所在的字符串相匹配的字符串。 称呼 ： 菜单 编辑→查找替换 要求 ：您已将光标置于工程中可编辑的字符串中，或者您已选择了可编辑的字符串。 有关更多信息，请参阅： 项目范围内的搜索和替换...", 
"body" : "进一步搜索（选择） 键盘快捷键： 控制 + F 功能 ：该命令在项目中搜索下一个与当前选择的字符串或光标当前所在的字符串相匹配的字符串。 称呼 ： 菜单 编辑→查找替换 要求 ：您已将光标置于工程中可编辑的字符串中，或者您已选择了可编辑的字符串。 有关更多信息，请参阅： 项目范围内的搜索和替换" }, 
{ "title" : "命令：查找上一个 ", 
"url" : "_cds_cmd_find_previous.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：查找上一个 ", 
"snippet" : "搜索上一个 象征： 键盘快捷键： 切换 + F3 功能 ：在项目中搜索特定字符串时，该命令在相关编辑器中的位置选择上一个搜索结果。 称呼 ： 菜单 编辑→查找替换 要求 : 你必须使用命令 搜索 或者 代替 开始在项目中搜索特定字符串。 有关更多信息，请参阅： 设置和使用书签...", 
"body" : "搜索上一个 象征： 键盘快捷键： 切换 + F3 功能 ：在项目中搜索特定字符串时，该命令在相关编辑器中的位置选择上一个搜索结果。 称呼 ： 菜单 编辑→查找替换 要求 : 你必须使用命令 搜索 或者 代替 开始在项目中搜索特定字符串。 有关更多信息，请参阅： 设置和使用书签" }, 
{ "title" : "命令：查找上一个（选择） ", 
"url" : "_cds_cmd_find_previous_selected.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：查找上一个（选择） ", 
"snippet" : "查找上一个（选择） 键盘快捷键： 控制 + 切换 + F3 功能 ：该命令在项目中搜索与当前选择的字符串或光标当前所在的字符串匹配的上一个字符串。 称呼 ： 菜单 编辑→查找替换 要求 ：您已将光标置于工程中可编辑的字符串中，或者您已选择了可编辑的字符串。 有关更多信息，请参阅： 项目范围内的搜索和替换...", 
"body" : "查找上一个（选择） 键盘快捷键： 控制 + 切换 + F3 功能 ：该命令在项目中搜索与当前选择的字符串或光标当前所在的字符串匹配的上一个字符串。 称呼 ： 菜单 编辑→查找替换 要求 ：您已将光标置于工程中可编辑的字符串中，或者您已选择了可编辑的字符串。 有关更多信息，请参阅： 项目范围内的搜索和替换" }, 
{ "title" : "命令：将文件粘贴为文本 ", 
"url" : "_cds_cmd_insert_file_as_text.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：将文件粘贴为文本 ", 
"snippet" : "将文件粘贴为文本 功能 ：该命令将文本文件的内容复制到当前光标位置的活动编辑器中。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 文本编辑器 粘贴到菜单中。 要求 : 文件必须有文件扩展名 .txt 具有。该命令仅在文本编辑器中可用。 许多开发环境和文字处理程序都可以将代码和文本导出为文本文件。可以使用此命令将此文件的内容复制到记事本中。 有关更多信息，请参阅： 文本编辑器...", 
"body" : "将文件粘贴为文本 功能 ：该命令将文本文件的内容复制到当前光标位置的活动编辑器中。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 文本编辑器 粘贴到菜单中。 要求 : 文件必须有文件扩展名 .txt 具有。该命令仅在文本编辑器中可用。 许多开发环境和文字处理程序都可以将代码和文本导出为文本文件。可以使用此命令将此文件的内容复制到记事本中。 有关更多信息，请参阅： 文本编辑器" }, 
{ "title" : "命令：覆盖模式 ", 
"url" : "_cds_cmd_overwrite_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：覆盖模式 ", 
"snippet" : "覆盖模式 键盘快捷键： 插入 功能 ：此命令\\启用覆盖模式。 称呼 ： 菜单 编辑 → 高级 要求 : 文本编辑器已打开。 当改写模式打开时，光标之前的字符会在您键入新字符时被覆盖。当改写模式关闭时，将插入字符并保留光标之前的现有字符。...", 
"body" : "覆盖模式 键盘快捷键： 插入 功能 ：此命令\\启用覆盖模式。 称呼 ： 菜单 编辑 → 高级 要求 : 文本编辑器已打开。 当改写模式打开时，光标之前的字符会在您键入新字符时被覆盖。当改写模式关闭时，将插入字符并保留光标之前的现有字符。 " }, 
{ "title" : "命令：显示空格 ", 
"url" : "_cds_cmd_view_whitespace.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：显示空格 ", 
"snippet" : "显示空间 象征： 功能 : 该命令会显示空格和制表符的控制字符。 称呼 ： 菜单 编辑 → 高级 要求 : 文本编辑器已打开。 CODESYS 用点可视化空格，用箭头可视化制表符。 有关更多信息，请参阅： 文本编辑器...", 
"body" : "显示空间 象征： 功能 : 该命令会显示空格和制表符的控制字符。 称呼 ： 菜单 编辑 → 高级 要求 : 文本编辑器已打开。 CODESYS 用点可视化空格，用箭头可视化制表符。 有关更多信息，请参阅： 文本编辑器" }, 
{ "title" : "命令：显示缩进指南 ", 
"url" : "_cds_cmd_view_indentation_guide.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：显示缩进指南 ", 
"snippet" : "显示缩进指南 功能 ：该命令打开缩进指南。 称呼 ： 菜单 编辑 → 高级 要求 : 文本编辑器已打开。 打开缩进指南时，将为代码中的每个手动缩进插入一条虚线。这使得更容易跟踪代码中的不同级别。可以使用按钮进行手动缩进 标签 插入。 有关更多信息，请参阅： 文本编辑器...", 
"body" : "显示缩进指南 功能 ：该命令打开缩进指南。 称呼 ： 菜单 编辑 → 高级 要求 : 文本编辑器已打开。 打开缩进指南时，将为代码中的每个手动缩进插入一条虚线。这使得更容易跟踪代码中的不同级别。可以使用按钮进行手动缩进 标签 插入。 有关更多信息，请参阅： 文本编辑器" }, 
{ "title" : "命令：转到行 ", 
"url" : "_cds_cmd_go_to_line.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：转到行 ", 
"snippet" : "转到行 功能 ：该命令将光标跳转到代码中定义的行。 称呼 ： 菜单 编辑 → 高级 要求 : 文本编辑器已打开。 该命令打开一个带有输入字段的对话框 电话号码 ....", 
"body" : "转到行 功能 ：该命令将光标跳转到代码中定义的行。 称呼 ： 菜单 编辑 → 高级 要求 : 文本编辑器已打开。 该命令打开一个带有输入字段的对话框 电话号码 . " }, 
{ "title" : "命令：转换为大写 ", 
"url" : "_cds_cmd_make_uppercase.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：转换为大写 ", 
"snippet" : "转换为大写 键盘快捷键： 控制 + 切换 + 你 功能 ：该命令将所选代码中的所有小写字母转换为大写。 称呼 ： 菜单 编辑 → 高级 要求 ：打开文本编辑器并选择代码，或打开声明编辑器并选择变量声明。 有关更多信息，请参阅： 文本编辑器...", 
"body" : "转换为大写 键盘快捷键： 控制 + 切换 + 你 功能 ：该命令将所选代码中的所有小写字母转换为大写。 称呼 ： 菜单 编辑 → 高级 要求 ：打开文本编辑器并选择代码，或打开声明编辑器并选择变量声明。 有关更多信息，请参阅： 文本编辑器" }, 
{ "title" : "命令：转换为小写 ", 
"url" : "_cds_cmd_make_lowercase.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：转换为小写 ", 
"snippet" : "转换为小写 键盘快捷键： 控制 + 你 功能 ：该命令将所选代码中的所有大写字母转换为小写。 称呼 ： 菜单 编辑 → 高级 要求 ：打开文本编辑器并选择代码，或打开声明编辑器并选择变量声明。 有关更多信息，请参阅： 文本编辑器...", 
"body" : "转换为小写 键盘快捷键： 控制 + 你 功能 ：该命令将所选代码中的所有大写字母转换为小写。 称呼 ： 菜单 编辑 → 高级 要求 ：打开文本编辑器并选择代码，或打开声明编辑器并选择变量声明。 有关更多信息，请参阅： 文本编辑器" }, 
{ "title" : "命令：转到匹配的括号 ", 
"url" : "_cds_cmd_go_to_matching_bracket.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：转到匹配的括号 ", 
"snippet" : "转到相关的括号 功能 ：该命令使光标跳转到所选代码括号的另一部分。 称呼 ： 菜单 编辑 → 高级 要求 ：文本编辑器打开，光标位于开始或结束代码括号。当您将光标放在代码括号上时，显示 CODESYS 如果您选择该选项，则为相应的括号着色 匹配括号 在里面 CODESYS - 类别中的项目选项 文本编辑器 ， 标签 文本区 已激活。...", 
"body" : "转到相关的括号 功能 ：该命令使光标跳转到所选代码括号的另一部分。 称呼 ： 菜单 编辑 → 高级 要求 ：文本编辑器打开，光标位于开始或结束代码括号。当您将光标放在代码括号上时，显示 CODESYS 如果您选择该选项，则为相应的括号着色 匹配括号 在里面 CODESYS - 类别中的项目选项 文本编辑器 ， 标签 文本区 已激活。 " }, 
{ "title" : "命令：选择最多对应的括号 ", 
"url" : "_cds_cmd_select_to_matching_bracket.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：选择最多对应的括号 ", 
"snippet" : "最多选择相关的括号 功能 ：该命令选择当前所选代码括号下的整个代码段。 称呼 ： 菜单 编辑 → 高级 要求 ：文本编辑器打开，光标位于开始或结束代码括号。当您将光标放在代码括号上时，显示 CODESYS 如果您选择该选项，则为相应的括号着色 匹配括号 在里面 CODESYS - 类别中的项目选项 文本编辑器 ， 标签 文本区 已激活。 有关更多信息，请参阅： 文本编辑器...", 
"body" : "最多选择相关的括号 功能 ：该命令选择当前所选代码括号下的整个代码段。 称呼 ： 菜单 编辑 → 高级 要求 ：文本编辑器打开，光标位于开始或结束代码括号。当您将光标放在代码括号上时，显示 CODESYS 如果您选择该选项，则为相应的括号着色 匹配括号 在里面 CODESYS - 类别中的项目选项 文本编辑器 ， 标签 文本区 已激活。 有关更多信息，请参阅： 文本编辑器" }, 
{ "title" : "命令：全部展开 ", 
"url" : "_cds_cmd_expand_all.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：全部展开 ", 
"snippet" : "展开一切 功能 ：该命令会展开文本编辑器中的所有缩减代码部分（加号）或交叉引用列表中的源代码，以便再次完整显示代码或所有源代码。 要求 ：文本编辑器处于活动状态并在对话框中 选项 ， 类别 文本编辑器 启用缩进。或者交叉引用列表处于活动状态。 称呼 : 在文本编辑器中：菜单 编辑 → 高级 ， 上下文菜单;在交叉引用列表中：上下文菜单 有关更多信息，请参阅： 文本编辑器...", 
"body" : "展开一切 功能 ：该命令会展开文本编辑器中的所有缩减代码部分（加号）或交叉引用列表中的源代码，以便再次完整显示代码或所有源代码。 要求 ：文本编辑器处于活动状态并在对话框中 选项 ， 类别 文本编辑器 启用缩进。或者交叉引用列表处于活动状态。 称呼 : 在文本编辑器中：菜单 编辑 → 高级 ， 上下文菜单;在交叉引用列表中：上下文菜单 有关更多信息，请参阅： 文本编辑器" }, 
{ "title" : "命令：全部折叠 ", 
"url" : "_cds_cmd_collapse_all.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：全部折叠 ", 
"snippet" : "收起一切 功能 ：该命令同时折叠文本编辑器中所有缩进的代码部分（根节点处的减号）或交叉引用列表中的出现。结果，仅显示代码的顶层或仅显示找到的位置的根节点。 要求 ：文本编辑器处于活动状态并在对话框中 选项 ， 类别 文本编辑器 启用缩进。或者交叉引用列表处于活动状态。 称呼 : 在文本编辑器中：菜单 编辑 → 高级 ， 上下文菜单;在交叉引用列表中：上下文菜单 有关更多信息，请参阅： 文本编辑器...", 
"body" : "收起一切 功能 ：该命令同时折叠文本编辑器中所有缩进的代码部分（根节点处的减号）或交叉引用列表中的出现。结果，仅显示代码的顶层或仅显示找到的位置的根节点。 要求 ：文本编辑器处于活动状态并在对话框中 选项 ， 类别 文本编辑器 启用缩进。或者交叉引用列表处于活动状态。 称呼 : 在文本编辑器中：菜单 编辑 → 高级 ， 上下文菜单;在交叉引用列表中：上下文菜单 有关更多信息，请参阅： 文本编辑器" }, 
{ "title" : "命令：注释掉选定的行 ", 
"url" : "_cds_cmd_comment_out.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：注释掉选定的行 ", 
"snippet" : "注释掉选定的行 象征： 键盘快捷键： 控制 + ○ 功能 : 该命令在所选行的开头插入注释字符 ('\/\/')。 称呼 ： 菜单 编辑 → 高级 ， 上下文菜单 要求 ：光标在 ST 编辑器中执行的一行或在 ST 编辑器中选择了多行。...", 
"body" : "注释掉选定的行 象征： 键盘快捷键： 控制 + ○ 功能 : 该命令在所选行的开头插入注释字符 ('\/\/')。 称呼 ： 菜单 编辑 → 高级 ， 上下文菜单 要求 ：光标在 ST 编辑器中执行的一行或在 ST 编辑器中选择了多行。 " }, 
{ "title" : "命令：从选定的行中删除注释 ", 
"url" : "_cds_cmd_uncomment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：从选定的行中删除注释 ", 
"snippet" : "从选定的行中删除注释 象征 ， 键盘快捷键 CTRL + 一世 功能 ： 称呼 ： 菜单 编辑 -> 先进的 ， 上下文菜单 要求 : 光标在 ST 编辑器中执行的一行或在 ST 编辑器中选择了多行。...", 
"body" : "从选定的行中删除注释 象征 ， 键盘快捷键 CTRL + 一世 功能 ： 称呼 ： 菜单 编辑 -> 先进的 ， 上下文菜单 要求 : 光标在 ST 编辑器中执行的一行或在 ST 编辑器中选择了多行。 " }, 
{ "title" : "命令：启用内联监控 ", 
"url" : "_cds_cmd_toggle_inline_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：启用内联监控 ", 
"snippet" : "启用内联监控 功能 ：该命令启用或禁用“内联监控”功能。其工作原理类似于 文本编辑器 选项，在 文本编辑器 类别。 要求 ：文本编辑器处于活动状态。 称呼 ：文本编辑器的上下文菜单（ 先进的 ） 有关详细信息，请参阅：For more information, see: 价值监控...", 
"body" : "启用内联监控 功能 ：该命令启用或禁用“内联监控”功能。其工作原理类似于 文本编辑器 选项，在 文本编辑器 类别。 要求 ：文本编辑器处于活动状态。 称呼 ：文本编辑器的上下文菜单（ 先进的 ） 有关详细信息，请参阅：For more information, see: 价值监控" }, 
{ "title" : "命令：打开\/关闭书签 ", 
"url" : "_cds_cmd_toggle_bookmark.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：打开\/关闭书签 ", 
"snippet" : "打开\/关闭书签 象征： 键盘快捷键： 控制 + F12 功能 ：该命令设置或删除当前位置的书签。 称呼 ： 菜单 编辑 → 书签 要求 : POU 在编辑器中打开，光标在程序行中。 有关更多信息，请参阅： 设置和使用书签...", 
"body" : "打开\/关闭书签 象征： 键盘快捷键： 控制 + F12 功能 ：该命令设置或删除当前位置的书签。 称呼 ： 菜单 编辑 → 书签 要求 : POU 在编辑器中打开，光标在程序行中。 有关更多信息，请参阅： 设置和使用书签" }, 
{ "title" : "命令：下一个书签（活动编辑器） ", 
"url" : "_cds_cmd_next_bookmark_active_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：下一个书签（活动编辑器） ", 
"snippet" : "下一个书签（活动编辑器） 象征： 键盘快捷键： F12 功能 ：命令跳转到活动编辑器中的下一个书签。 称呼 ： 菜单 编辑 → 书签 要求 : POU 在编辑器中打开，光标在 POU 中。 有关更多信息，请参阅： 设置和使用书签...", 
"body" : "下一个书签（活动编辑器） 象征： 键盘快捷键： F12 功能 ：命令跳转到活动编辑器中的下一个书签。 称呼 ： 菜单 编辑 → 书签 要求 : POU 在编辑器中打开，光标在 POU 中。 有关更多信息，请参阅： 设置和使用书签" }, 
{ "title" : "命令：下一个书签 ", 
"url" : "_cds_cmd_next_bookmark_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：下一个书签 ", 
"snippet" : "下一个书签 象征： 功能 : 命令在视图中跳转 书签 并在项目中下一个书签并打开相应的 POU。书签跳转到的顺序对应于视图表中书签的顺序 书签 . 称呼 ： 按钮 下一个书签 在视图中 书签 默认情况下，该命令不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 书签 粘贴到菜单中。 要求 ： 一个项目已打开。 风景 书签 被打开。 有关更多信息，请参阅： 设置和使用书签...", 
"body" : "下一个书签 象征： 功能 : 命令在视图中跳转 书签 并在项目中下一个书签并打开相应的 POU。书签跳转到的顺序对应于视图表中书签的顺序 书签 . 称呼 ： 按钮 下一个书签 在视图中 书签 默认情况下，该命令不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 书签 粘贴到菜单中。 要求 ： 一个项目已打开。 风景 书签 被打开。 有关更多信息，请参阅： 设置和使用书签" }, 
{ "title" : "命令：上一个书签（活动编辑器） ", 
"url" : "_cds_cmd_previous_bookmark_active_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：上一个书签（活动编辑器） ", 
"snippet" : "上一个书签（活动编辑器） 象征： 键盘快捷键： 切换 + F12 功能 ：该命令跳转到活动编辑器中的上一个书签。 称呼 ： 菜单 编辑 → 书签 POU 在编辑器中打开，光标在 POU 中。 有关更多信息，请参阅： 项目范围内的搜索和替换...", 
"body" : "上一个书签（活动编辑器） 象征： 键盘快捷键： 切换 + F12 功能 ：该命令跳转到活动编辑器中的上一个书签。 称呼 ： 菜单 编辑 → 书签 POU 在编辑器中打开，光标在 POU 中。 有关更多信息，请参阅： 项目范围内的搜索和替换" }, 
{ "title" : "命令：上一个书签 ", 
"url" : "_cds_cmd_previous_bookmark_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：上一个书签 ", 
"snippet" : "上一个书签 象征： 功能 : 命令在视图中跳转 书签 并在项目中到上一个书签并打开相应的 POU。书签跳转到的顺序对应于视图表中书签的顺序 书签 . 称呼 ： 按钮 上一个书签 在视图中 书签 默认情况下，该命令不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 书签 粘贴到菜单中。 要求 ： 一个项目已打开。 风景 书签 被打开。 有关更多信息，请参阅： 设置和使用书签...", 
"body" : "上一个书签 象征： 功能 : 命令在视图中跳转 书签 并在项目中到上一个书签并打开相应的 POU。书签跳转到的顺序对应于视图表中书签的顺序 书签 . 称呼 ： 按钮 上一个书签 在视图中 书签 默认情况下，该命令不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 书签 粘贴到菜单中。 要求 ： 一个项目已打开。 风景 书签 被打开。 有关更多信息，请参阅： 设置和使用书签" }, 
{ "title" : "命令：清除所有书签（活动编辑器） ", 
"url" : "_cds_cmd_clear_all_bookmarks_active_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：清除所有书签（活动编辑器） ", 
"snippet" : "删除所有书签（活动编辑器） 象征： 功能 ：该命令删除活动编辑器中的所有书签。 称呼 ： 菜单 编辑 → 书签 要求 : POU 在编辑器中打开，光标在 POU 中。 有关更多信息，请参阅： 设置和使用书签...", 
"body" : "删除所有书签（活动编辑器） 象征： 功能 ：该命令删除活动编辑器中的所有书签。 称呼 ： 菜单 编辑 → 书签 要求 : POU 在编辑器中打开，光标在 POU 中。 有关更多信息，请参阅： 设置和使用书签" }, 
{ "title" : "命令：删除所有书签 ", 
"url" : "_cds_cmd_clear_all_bookmarks_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：删除所有书签 ", 
"snippet" : "删除所有书签 象征： 功能 ：该命令删除打开项目的所有书签。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 书签 粘贴到菜单中。 要求 : POU 在编辑器中打开，光标在 POU 中。 有关更多信息，请参阅： 设置和使用书签...", 
"body" : "删除所有书签 象征： 功能 ：该命令删除打开项目的所有书签。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 书签 粘贴到菜单中。 要求 : POU 在编辑器中打开，光标在 POU 中。 有关更多信息，请参阅： 设置和使用书签" }, 
{ "title" : "命令：输出交叉引用 ", 
"url" : "_cds_cmd_browse_cross_references.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：输出交叉引用 ", 
"snippet" : "输出交叉引用 象征： 功能 ：该命令显示视图中使用变量的所有位置 交叉引用列表 . 称呼 ： 菜单 编辑 → 查找图标 , 视图中的工具栏 交叉引用列表 要求 : POU 在编辑器中打开，光标在变量中。或者视图 交叉引用列表 已打开且变量在字段中 姓 指定的。 有关更多信息，请参阅： 使用交叉引用列表查找使用地点...", 
"body" : "输出交叉引用 象征： 功能 ：该命令显示视图中使用变量的所有位置 交叉引用列表 . 称呼 ： 菜单 编辑 → 查找图标 , 视图中的工具栏 交叉引用列表 要求 : POU 在编辑器中打开，光标在变量中。或者视图 交叉引用列表 已打开且变量在字段中 姓 指定的。 有关更多信息，请参阅： 使用交叉引用列表查找使用地点" }, 
{ "title" : "命令：输出全局交叉引用 ", 
"url" : "_cds_cmd_browse_global_cross_references.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：输出全局交叉引用 ", 
"snippet" : "输出全局交叉引用 象征： 功能 ：命令显示视图中所有同名变量的使用位置 交叉引用列表 .与命令相反 输出交叉引用 可以是不同的变量。 称呼 ： 菜单 编辑 → 查找图标 , 视图中的工具栏 交叉引用列表 要求 : POU 在编辑器中打开，光标在变量中。或者视图 交叉引用列表 已打开且变量在字段中 姓 指定的。 有关更多信息，请参阅： 使用交叉引用列表查找使用地点...", 
"body" : "输出全局交叉引用 象征： 功能 ：命令显示视图中所有同名变量的使用位置 交叉引用列表 .与命令相反 输出交叉引用 可以是不同的变量。 称呼 ： 菜单 编辑 → 查找图标 , 视图中的工具栏 交叉引用列表 要求 : POU 在编辑器中打开，光标在变量中。或者视图 交叉引用列表 已打开且变量在字段中 姓 指定的。 有关更多信息，请参阅： 使用交叉引用列表查找使用地点" }, 
{ "title" : "命令：输出调用树 ", 
"url" : "_cds_cmd_browse_call_tree.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：输出调用树 ", 
"snippet" : "输出调用树 象征： 功能 : 命令打开视图 调用树 ，它表示构建块及其调用者的调用。 称呼 ： 菜单 编辑 → 查找图标 上下文菜单 要求 : 一个块在编辑器中打开并且光标在一个变量中，或者一个块在视图中 设备 或者 POU 选择。...", 
"body" : "输出调用树 象征： 功能 : 命令打开视图 调用树 ，它表示构建块及其调用者的调用。 称呼 ： 菜单 编辑 → 查找图标 上下文菜单 要求 : 一个块在编辑器中打开并且光标在一个变量中，或者一个块在视图中 设备 或者 POU 选择。 " }, 
{ "title" : "命令：声明变量 ", 
"url" : "_cds_cmd_declare_variable.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：声明变量 ", 
"snippet" : "声明变量 键盘快捷键： 切换 + F2 功能 ：命令打开对话框 声明变量 ，它支持变量的声明。 称呼 ： 菜单 编辑 要求 ：项目的对象或设备在编辑器中打开。 由于自动声明功能而出现对话框 声明变量 同样，当光标位于包含未声明变量名称的 POU 的实现部分中的一行时。作为先决条件，您需要命令 工具 → 选项 选择并在类别中 智能编码 选项 自动声明未知变量（AutoDeclare） 已激活。 该命令通过智能标签功能出现 声明变量 如果您将光标放在 ST 编辑器的实现部分中尚未声明的变量上，这也适用 点击。...", 
"body" : "声明变量 键盘快捷键： 切换 + F2 功能 ：命令打开对话框 声明变量 ，它支持变量的声明。 称呼 ： 菜单 编辑 要求 ：项目的对象或设备在编辑器中打开。 由于自动声明功能而出现对话框 声明变量 同样，当光标位于包含未声明变量名称的 POU 的实现部分中的一行时。作为先决条件，您需要命令 工具 → 选项 选择并在类别中 智能编码 选项 自动声明未知变量（AutoDeclare） 已激活。 该命令通过智能标签功能出现 声明变量 如果您将光标放在 ST 编辑器的实现部分中尚未声明的变量上，这也适用 点击。 " }, 
{ "title" : "对话框：声明变量 ", 
"url" : "_cds_cmd_declare_variable.html#UUID-bcf3934d-34a2-e1ad-d7f7-47aa728ded88_id_a21027ccec5d5fc0a8640e01ff1fb3_id_3fd5849fbf939f94c0a8640e00ee08a5", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：声明变量 \/ 对话框：声明变量 ", 
"snippet" : "范围 尚未声明的变量范围 例子： VAR （局部变量的默认值） 姓 变量名尚未声明 例子： bIsValid 数据类型 例子： BOOL : 列出标准数据类型 输入帮助 ：打开对话框 输入帮助 阵列向导 ：打开对话框 大批 目的 声明新变量的对象 默认情况下，您当前正在编辑的对象。 例子： fbA : 列出可以在其中声明变量的对象 如果对于所选 范围 如果没有可用的对象，则会出现该条目 <创建对象> .如果你看到条目 <创建对象> 选择，对话框打开 添加对象 创建一个合适的对象。 初始化值 例子： FALSE 如果不输入初始化值，变量会自动初始化。 ：打开对话框 初始化值 此过程有助于结构化变...", 
"body" : "范围 尚未声明的变量范围 例子： VAR （局部变量的默认值） 姓 变量名尚未声明 例子： bIsValid 数据类型 例子： BOOL : 列出标准数据类型 输入帮助 ：打开对话框 输入帮助 阵列向导 ：打开对话框 大批 目的 声明新变量的对象 默认情况下，您当前正在编辑的对象。 例子： fbA : 列出可以在其中声明变量的对象 如果对于所选 范围 如果没有可用的对象，则会出现该条目 <创建对象> .如果你看到条目 <创建对象> 选择，对话框打开 添加对象 创建一个合适的对象。 初始化值 例子： FALSE 如果不输入初始化值，变量会自动初始化。 ：打开对话框 初始化值 此过程有助于结构化变量的初始化。 地址 尚未声明的变量的应用程序的内存地址 例子： %IX1.0 注意： 仅适用于以下有效范围： 局部变量 ( VAR ) 全局变量 ( VAR_GLOBAL ) 持久变量 ( PERSISTENT ) 旗帜 属性关键字 CONSTANT : 常量的关键字 RETAIN : 剩余变量的关键字 PERSISTENT : 持久变量的关键字（严格于 RETAIN ) 选定的属性关键字被添加到变量声明中。 评论 例子： New input In1 在表格声明编辑器中，输入的注释显示在列中 评论 , 在变量声明上方的文本声明编辑器中。 使用重构应用更改 ：退出对话框时，变量尚未声明，但对话框首先打开 重构 .在那里您可以进一步编辑您的更改。 该选项出现在以下有效范围内： 输入变量 ( VAR_INPUT ) 输出变量 ( VAR_OUTPUT ) VAR_IN_OUT -变量（输入变量和输出变量） 行 变量被声明并出现在声明中。 例子： VAR RETAIN\n \/\/ New input In1\n xIn1 AT %IX1.0: BOOL := FALSE;\nEND_VAR " }, 
{ "title" : "对话框：数组 ", 
"url" : "_cds_cmd_declare_variable.html#UUID-bcf3934d-34a2-e1ad-d7f7-47aa728ded88_id_a21027ccec5d5fc0a8640e01ff1fb3_id_0d35552abf939f96c0a8640e01838bc5", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：声明变量 \/ 对话框：数组 ", 
"snippet" : "尺寸和基型规格 字段大小的定义（ 方面 ) 通过输入下限和上限以及 基本类型 数组的 您可以直接或借助对话框输入基本类型 输入帮助 或者 大批 当您单击按钮时 点击。 结果 显示定义的数组 CODESYS 仅当您更改了变量的初始化值时才重新初始化变量。...", 
"body" : "尺寸和基型规格 字段大小的定义（ 方面 ) 通过输入下限和上限以及 基本类型 数组的 您可以直接或借助对话框输入基本类型 输入帮助 或者 大批 当您单击按钮时 点击。 结果 显示定义的数组 CODESYS 仅当您更改了变量的初始化值时才重新初始化变量。 " }, 
{ "title" : "对话框：初始化值 ", 
"url" : "_cds_cmd_declare_variable.html#UUID-bcf3934d-34a2-e1ad-d7f7-47aa728ded88_id_a21027ccec5d5fc0a8640e01ff1fb3_id_4086b2105903f5bdc0a864637bd9aa66", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：声明变量 \/ 对话框：初始化值 ", 
"snippet" : "具有名称的变量列表 ( 表达 ), 初始化值 和 数据类型 更改的初始化值以粗体显示。 列表下方的输入字段 输入所选变量的初始化值 将值应用于选定的行 根据输入字段的值更改所选行的初始化值 将所选行重置为默认值 建立默认初始化值 行 CODESYS 接受对话框中的初始化值 声明变量 . 如果要通过此对话框初始化的变量是具有扩展 FB_Init 方法的功能块实例，则在表格上方 初始化值 显示另一个表。此表列出了附加的 FB_Init 参数。含义和操作基本对应下表，区别如下： 必须为所有变量分配初始化值。否则是 行 不可选择。 对于复杂数据类型（结构体、数组），不显示其中包含的组件（类型无法扩展）...", 
"body" : "具有名称的变量列表 ( 表达 ), 初始化值 和 数据类型 更改的初始化值以粗体显示。 列表下方的输入字段 输入所选变量的初始化值 将值应用于选定的行 根据输入字段的值更改所选行的初始化值 将所选行重置为默认值 建立默认初始化值 行 CODESYS 接受对话框中的初始化值 声明变量 . 如果要通过此对话框初始化的变量是具有扩展 FB_Init 方法的功能块实例，则在表格上方 初始化值 显示另一个表。此表列出了附加的 FB_Init 参数。含义和操作基本对应下表，区别如下： 必须为所有变量分配初始化值。否则是 行 不可选择。 对于复杂数据类型（结构体、数组），不显示其中包含的组件（类型无法扩展）。在这种情况下，必须使用适当的变量初始化复杂类型。 使用这种方式配置的 FB_Init 参数，在对话框中 声明变量 初始化值后显示相应的符号。 有关更多信息，请参阅： 方法: 和 AT声明" }, 
{ "title" : "命令：可访问性 ", 
"url" : "_cds_cmd_input_assistant.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：可访问性 ", 
"snippet" : "输入帮助 象征： 键盘快捷键： F2 功能 ：命令打开对话框 输入帮助 ，它支持您在当前光标位置选择可能的编程元素。 称呼 ： 菜单 编辑 ， 上下文菜单 要求 : POU 在编辑器中打开，光标在程序行中。...", 
"body" : "输入帮助 象征： 键盘快捷键： F2 功能 ：命令打开对话框 输入帮助 ，它支持您在当前光标位置选择可能的编程元素。 称呼 ： 菜单 编辑 ， 上下文菜单 要求 : POU 在编辑器中打开，光标在程序行中。 " }, 
{ "title" : "对话框：条目助手 - 选项卡：类别 ", 
"url" : "_cds_cmd_input_assistant.html#UUID-6ebae50a-4bd0-b4f9-9ae7-22fbbd5b58ca_id_ac201b561ba225dc0a8640e00215c1f_id_9b1329a161d157c1c0a8640e00c51282", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：可访问性 \/ 对话框：条目助手 - 选项卡：类别 ", 
"snippet" : "该对话框为您提供了可以在编辑器中当前光标位置插入的所有编程元素。 元素在后面 类别 排序。您可以在类别中 变量 另外一个 筛选 为范围设置，例如 局部变量 , 全局变量 或者 常数 . 结构化视图 ：元素显示在结构树中。你可以看到列 类型 , 地址 和 起源 通过右键单击子菜单中的列标题来隐藏或显示。 ：元素以平面结构显示。 查看文档 ：对话框将环绕框 文件 扩大。 带参数插入 : 有参数的元素，例如函数，被插入到带有这些参数的光标位置。 示例：如果使用功能模块 fb1 ，这是一个输入变量 fb1_in 和一个输出变量 fb1_out 插入“带参数”，它在编辑器中看起来像这样： fb1(fb1...", 
"body" : "该对话框为您提供了可以在编辑器中当前光标位置插入的所有编程元素。 元素在后面 类别 排序。您可以在类别中 变量 另外一个 筛选 为范围设置，例如 局部变量 , 全局变量 或者 常数 . 结构化视图 ：元素显示在结构树中。你可以看到列 类型 , 地址 和 起源 通过右键单击子菜单中的列标题来隐藏或显示。 ：元素以平面结构显示。 查看文档 ：对话框将环绕框 文件 扩大。 带参数插入 : 有参数的元素，例如函数，被插入到带有这些参数的光标位置。 示例：如果使用功能模块 fb1 ，这是一个输入变量 fb1_in 和一个输出变量 fb1_out 插入“带参数”，它在编辑器中看起来像这样： fb1(fb1_in:=>, fb1_out=>) . 粘贴命名空间前缀 : 插入被选中的元素，命名空间在前面 在库块的情况下，如果库属性指定命名空间的规范是强制性的，则不能操作该复选框。 如果您在全局范围内都有具有相同名称和类别的对象（查看 POU ）并分配给应用程序（查看 设备 )，输入帮助中只出现一个条目。用法遵循通常的呼叫优先级（在全局之前适用）。 " }, 
{ "title" : "对话框：条目助手 - 选项卡：文本搜索 ", 
"url" : "_cds_cmd_input_assistant.html#UUID-6ebae50a-4bd0-b4f9-9ae7-22fbbd5b58ca_id_ac201b561ba225dc0a8640e00215c1f_id_03fff56d17a6622cc0a864633a9aeacf", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：可访问性 \/ 对话框：条目助手 - 选项卡：文本搜索 ", 
"snippet" : "您可以在选项卡中搜索特定对象。如果您在搜索字段中输入一个或多个字符，命中窗口会列出名称中包含该搜索字符串的所有对象的名称。双击所需对象以将其插入编辑器中的当前光标位置。 筛选 将搜索限制为特定类别的变量 有关更多信息，请参阅： 使用输入辅助...", 
"body" : "您可以在选项卡中搜索特定对象。如果您在搜索字段中输入一个或多个字符，命中窗口会列出名称中包含该搜索字符串的所有对象的名称。双击所需对象以将其插入编辑器中的当前光标位置。 筛选 将搜索限制为特定类别的变量 有关更多信息，请参阅： 使用输入辅助" }, 
{ "title" : "命令：转到源代码位置 ", 
"url" : "_cds_cmd_go_to_source_position.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：转到源代码位置 ", 
"snippet" : "转到源位置 功能 ：使用该命令可以跳转到源代码中触发消息的位置。 称呼 ： 菜单 编辑 , 消息窗口中消息的上下文菜单 要求 ：在消息窗口中选择了一条消息。 要到达消息窗口中下一条或上一条消息的源文本中的位置，请使用命令 下一条消息 或者 上一条消息 ....", 
"body" : "转到源位置 功能 ：使用该命令可以跳转到源代码中触发消息的位置。 称呼 ： 菜单 编辑 , 消息窗口中消息的上下文菜单 要求 ：在消息窗口中选择了一条消息。 要到达消息窗口中下一条或上一条消息的源文本中的位置，请使用命令 下一条消息 或者 上一条消息 . " }, 
{ "title" : "命令：下一条消息 ", 
"url" : "_cds_cmd_next_message.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：下一条消息 ", 
"snippet" : "下一条消息 键盘快捷键： F4 功能 ：该命令在消息窗口中选择下一条消息。 称呼 ： 菜单 编辑 当到达列表中的最后一条消息时，突出显示会跳回到开头。...", 
"body" : "下一条消息 键盘快捷键： F4 功能 ：该命令在消息窗口中选择下一条消息。 称呼 ： 菜单 编辑 当到达列表中的最后一条消息时，突出显示会跳回到开头。 " }, 
{ "title" : "命令：上一条消息 ", 
"url" : "_cds_cmd_previous_message.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：上一条消息 ", 
"snippet" : "上一条消息 键盘快捷键： 切换 + F4 功能 ：该命令在消息窗口中选择上一条消息。 称呼 ： 菜单 编辑 当到达列表中的第一条消息时，标记会跳回到末尾。...", 
"body" : "上一条消息 键盘快捷键： 切换 + F4 功能 ：该命令在消息窗口中选择上一条消息。 称呼 ： 菜单 编辑 当到达列表中的第一条消息时，标记会跳回到末尾。 " }, 
{ "title" : "命令：转到定义 ", 
"url" : "_cds_cmd_goto_definition.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：转到定义 ", 
"snippet" : "转到定义 象征： 功能 ：该命令显示变量或函数的定义位置。 称呼 ： 菜单 编辑 → 查找图标 要求 : POU 在编辑器中打开，光标位于变量或函数上。 有关更多信息，请参阅： 查找声明...", 
"body" : "转到定义 象征： 功能 ：该命令显示变量或函数的定义位置。 称呼 ： 菜单 编辑 → 查找图标 要求 : POU 在编辑器中打开，光标位于变量或函数上。 有关更多信息，请参阅： 查找声明" }, 
{ "title" : "命令：转到参考 ", 
"url" : "_cds_cmd_goto_reference.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：转到参考 ", 
"snippet" : "去参考 象征： 功能 ：在线模式下，该命令打开当前焦点指针所引用的变量的声明点。 称呼 ： 声明部分或实现代码中的上下文菜单 菜单 编辑 → 查找图标 要求 : 在线操作 一个块在编辑器中打开，光标位于指针上。引用的变量在静态内存中。 如果指针不完全指向变量的开头，则在切换到变量声明时会输出相应的消息。...", 
"body" : "去参考 象征： 功能 ：在线模式下，该命令打开当前焦点指针所引用的变量的声明点。 称呼 ： 声明部分或实现代码中的上下文菜单 菜单 编辑 → 查找图标 要求 : 在线操作 一个块在编辑器中打开，光标位于指针上。引用的变量在静态内存中。 如果指针不完全指向变量的开头，则在切换到变量声明时会输出相应的消息。 " }, 
{ "title" : "命令：转到实例 ", 
"url" : "_cds_cmd_goto_instance.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：转到实例 ", 
"snippet" : "转到实例 象征： 功能 ：该命令在新窗口中打开功能块的实例。 称呼 ： 菜单 编辑 → 查找图标 要求 ：应用程序处于在线模式。 POU 在编辑器中打开，光标位于功能块的实例上。 该命令不适用于临时实例或已翻译库中的实例。 有关更多信息，请参阅： 查找声明...", 
"body" : "转到实例 象征： 功能 ：该命令在新窗口中打开功能块的实例。 称呼 ： 菜单 编辑 → 查找图标 要求 ：应用程序处于在线模式。 POU 在编辑器中打开，光标位于功能块的实例上。 该命令不适用于临时实例或已翻译库中的实例。 有关更多信息，请参阅： 查找声明" }, 
{ "title" : "命令：重构 - 重命名 <…> ", 
"url" : "_cds_cmd_refactoring_rename.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：重构 - 重命名 <…> ", 
"snippet" : "重构 - 重命名 <…> 功能 ：该命令打开一个对话框，用于在整个项目中重命名对象或变量。 称呼 ： 菜单 编辑 → 重构 ， 上下文菜单 要求 : 设备树或视图中的对象 POU 被选中或光标位于编程对象声明部分中的变量标识符之前或之上。 您可以重命名以下内容： 变量 POU GVL的 方法 特性 设备 单位转换编辑器中的变量和单位转换...", 
"body" : "重构 - 重命名 <…> 功能 ：该命令打开一个对话框，用于在整个项目中重命名对象或变量。 称呼 ： 菜单 编辑 → 重构 ， 上下文菜单 要求 : 设备树或视图中的对象 POU 被选中或光标位于编程对象声明部分中的变量标识符之前或之上。 您可以重命名以下内容： 变量 POU GVL的 方法 特性 设备 单位转换编辑器中的变量和单位转换 " }, 
{ "title" : "对话：重命名 ", 
"url" : "_cds_cmd_refactoring_rename.html#UUID-2430b763-4ab5-90f5-a69e-2da0a1ef8661_id_f49c110c42fdcc0a8640e01cee140_id_7c48a1fabf8ddfbec0a8640e0166cc68", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：重构 - 重命名 <…> \/ 对话：重命名 ", 
"snippet" : "当前名称 对象或变量的名称 新名字 新名称的输入字段 如果输入的名称已经存在，请报告 CODESYS 在这个输入字段的正下方。 行 当你在时启用 新名字 输入了一个有效的名称 打开对话框 重构 相应的对象和位置在两个窗口中都用颜色标记。...", 
"body" : "当前名称 对象或变量的名称 新名字 新名称的输入字段 如果输入的名称已经存在，请报告 CODESYS 在这个输入字段的正下方。 行 当你在时启用 新名字 输入了一个有效的名称 打开对话框 重构 相应的对象和位置在两个窗口中都用颜色标记。 " }, 
{ "title" : "对话：重构 ", 
"url" : "_cds_cmd_refactoring_rename.html#UUID-2430b763-4ab5-90f5-a69e-2da0a1ef8661_id_f49c110c42fdcc0a8640e01cee140_id_f64f5fbfa6beea08c0a8640e01fd503b", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：重构 - 重命名 <…> \/ 对话：重构 ", 
"snippet" : "该对话框显示项目中的所有使用场所。 相应的对象和位置在两个窗口中都用颜色标记。 右窗 显示对象内的相应位置 当前名称 发生 左窗 带有相应对象的项目导航树 在这两个窗口中，您都可以指定每个使用点要执行的操作。为此，上下文菜单中提供了以下命令： 放弃此更改 丢弃右侧窗口中的单个更改 接受这个项目 接受受影响对象的所有更改 丢弃此对象 放弃受影响对象中的所有更改 接受整个项目 接受项目中的所有更改 丢弃整个项目 放弃项目中的所有更改 CODESYS 用黄色背景表示接受的更改，用灰色背景表示丢弃的更改。 有关更多信息，请参阅： 重构...", 
"body" : "该对话框显示项目中的所有使用场所。 相应的对象和位置在两个窗口中都用颜色标记。 右窗 显示对象内的相应位置 当前名称 发生 左窗 带有相应对象的项目导航树 在这两个窗口中，您都可以指定每个使用点要执行的操作。为此，上下文菜单中提供了以下命令： 放弃此更改 丢弃右侧窗口中的单个更改 接受这个项目 接受受影响对象的所有更改 丢弃此对象 放弃受影响对象中的所有更改 接受整个项目 接受项目中的所有更改 丢弃整个项目 放弃项目中的所有更改 CODESYS 用黄色背景表示接受的更改，用灰色背景表示丢弃的更改。 有关更多信息，请参阅： 重构" }, 
{ "title" : "命令：重构 - 更新相关端口 ", 
"url" : "_cds_cmd_refactoring_update_referenced_pins.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：重构 - 更新相关端口 ", 
"snippet" : "重构——更新相关端口 该命令目前仅适用于 CFC、FBD、LD 和 IL 编辑器。它是以下的组合 重置连接 和 更新参数 . Symbol: 功能 ：该命令使 I\/O 适应块的所有受影响使用位置中的当前块声明。 称呼 ： 菜单 编辑 → 重构 ， 上下文菜单 要求 ：光标在设备声明的第一行或设备树中的设备名称中。 有关更多信息，请参阅： 重构...", 
"body" : "重构——更新相关端口 该命令目前仅适用于 CFC、FBD、LD 和 IL 编辑器。它是以下的组合 重置连接 和 更新参数 . Symbol: 功能 ：该命令使 I\/O 适应块的所有受影响使用位置中的当前块声明。 称呼 ： 菜单 编辑 → 重构 ， 上下文菜单 要求 ：光标在设备声明的第一行或设备树中的设备名称中。 有关更多信息，请参阅： 重构" }, 
{ "title" : "命令：重构 - 添加变量 ", 
"url" : "_cds_cmd_refactoring_add_variable.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：重构 - 添加变量 ", 
"snippet" : "重构 - 添加变量 象征 ： 功能 ：该命令允许在 POU 中声明一个新变量，并在 POU 的使用点进行相应的自动更新。 称呼 ： 菜单 编辑 → 重构 ， 上下文菜单 要求 : 重点是 POU 的声明部分。 该命令打开用于声明变量的标准对话框。...", 
"body" : "重构 - 添加变量 象征 ： 功能 ：该命令允许在 POU 中声明一个新变量，并在 POU 的使用点进行相应的自动更新。 称呼 ： 菜单 编辑 → 重构 ， 上下文菜单 要求 : 重点是 POU 的声明部分。 该命令打开用于声明变量的标准对话框。 " }, 
{ "title" : "对话：重构 ", 
"url" : "_cds_cmd_refactoring_add_variable.html#UUID-581e76a8-35ca-3ac1-f711-53d8a5822085_id_eaa36acdfe35c86c0a8640e01aae2be_id_f770113be1ae9112c0a8640e01d33576", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：重构 - 添加变量 \/ 对话：重构 ", 
"snippet" : "关闭声明对话框后 行 出现两部分对话框 重构 . 对话的右边部分 声明部分和在其声明中添加变量的 POU 的实现 变更点的颜色编码：新增蓝字黄底声明（一） 对话的左边部分 项目的设备树或 POUs 树 使用 POU 的块的颜色编码：红色字体和黄色背景 (2) 双击 POU 对象后，将打开详细视图。 在决定要应用哪些更改以及在何处应用之前，请从右上角的选择列表 (3) 中选择所需的选项： 使用占位符文本添加输入 默认占位符文本 _REFACTOR_ ;可编辑 此处定义的占位符文本出现在实现代码中新增变量的使用点处。它用于搜索受影响的位置。 添加具有以下值的输入 新变量的初始化值 在更改点的上下文...", 
"body" : "关闭声明对话框后 行 出现两部分对话框 重构 . 对话的右边部分 声明部分和在其声明中添加变量的 POU 的实现 变更点的颜色编码：新增蓝字黄底声明（一） 对话的左边部分 项目的设备树或 POUs 树 使用 POU 的块的颜色编码：红色字体和黄色背景 (2) 双击 POU 对象后，将打开详细视图。 在决定要应用哪些更改以及在何处应用之前，请从右上角的选择列表 (3) 中选择所需的选项： 使用占位符文本添加输入 默认占位符文本 _REFACTOR_ ;可编辑 此处定义的占位符文本出现在实现代码中新增变量的使用点处。它用于搜索受影响的位置。 添加具有以下值的输入 新变量的初始化值 在更改点的上下文菜单中，对话框的左侧和右侧都有接受或拒绝更改的命令。另见命令说明 重构→重命名 . 例子 积木 fun 通过重构接收新的输入变量 input3 带初始化值 1 . 更改具有以下效果： 前： fun(a + b, 3, TRUE);\nfun(input1:= a + b , input2 :=3 , inputx := TRUE); 之后： fun(a + b, 3, 1, TRUE);\nfun(input1:= a + b , input2 :=3 , _REFACTOR_, inputx := TRUE); 积木 fun 通过重构接收新的输入变量 input3 带占位符文本 _REFACTOR_ . 前： inst(input1 := a + b, input2 := 3, inputx := TRUE);\nfun(a + b, 3, TRUE); 之后： inst(input1 := a + b, input2 := 3, input3 := _REFACTOR_, inputx := TRUE);\nfun(a + b, 3, _REFACTOR_, TRUE); 有关更多信息，请参阅： 重构" }, 
{ "title" : "命令：重构 - 删除 <变量> ", 
"url" : "_cds_cmd_refactoring_remove_variable.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：重构 - 删除 <变量> ", 
"snippet" : "重构 - 删除 <变量> 象征： 功能 ：该命令从 POU 和 POU 的所有使用点中删除输入或输出变量。 称呼 ： 菜单 编辑 → 重构 ， 上下文菜单 要求 : 光标在 POU 的声明部分中要删除的变量的标识符中。 该命令首先打开一个对话框，其中包含所需距离的详细信息。确认后出现对话框 重构 .有关对话框的说明，请参见 重构 命令帮助页面 编辑→重构→ 改名 . 当您在对话框中看到更改时 重构 接受，则在受影响的 POU 的使用点删除相应的输入或输出参数。 在 CFC 中，仅移除了已移除的输入或输出与块的连接。进入或退出本身仍保留在图表中。 ST 中的示例 通过“重构”删除 POU 中的输...", 
"body" : "重构 - 删除 <变量> 象征： 功能 ：该命令从 POU 和 POU 的所有使用点中删除输入或输出变量。 称呼 ： 菜单 编辑 → 重构 ， 上下文菜单 要求 : 光标在 POU 的声明部分中要删除的变量的标识符中。 该命令首先打开一个对话框，其中包含所需距离的详细信息。确认后出现对话框 重构 .有关对话框的说明，请参见 重构 命令帮助页面 编辑→重构→ 改名 . 当您在对话框中看到更改时 重构 接受，则在受影响的 POU 的使用点删除相应的输入或输出参数。 在 CFC 中，仅移除了已移除的输入或输出与块的连接。进入或退出本身仍保留在图表中。 ST 中的示例 通过“重构”删除 POU 中的输入变量。 input4 . 在使用点进行自动调整。 拆除前： inst(input1 := a + b, input2 := 3, input4 := 1, input5 := TRUE);\nfun(a + b, 3, 1, TRUE); 距离后： inst(input1 := a + b, input2 := 3, input5 := TRUE);\nfun(a + b, 3, TRUE); 有关更多信息，请参阅： 重构" }, 
{ "title" : "命令：重构 - 重新排序变量 ", 
"url" : "_cds_cmd_refactoring_reorder_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 编辑 \/ 命令：重构 - 重新排序变量 ", 
"snippet" : "重构 - 重新排序变量 象征： 功能 ：该命令允许在声明编辑器中更改当前焦点范围内的变量顺序 VAR_INPUT , VAR_OUTPUT 或者 VAR_IN_OUT . 称呼 ： 菜单 编辑 → 重构 , 声明编辑器中当前焦点范围的上下文菜单 要求 ：重点是在上述范围之一的声明中，其中声明了多个变量。 该命令打开对话框 改编 包含当前关注范围的所有声明的列表。通过用鼠标拖动，您可以将选定的声明向上或向下移动到不同的位置。 有关更多信息，请参阅： 重构...", 
"body" : "重构 - 重新排序变量 象征： 功能 ：该命令允许在声明编辑器中更改当前焦点范围内的变量顺序 VAR_INPUT , VAR_OUTPUT 或者 VAR_IN_OUT . 称呼 ： 菜单 编辑 → 重构 , 声明编辑器中当前焦点范围的上下文菜单 要求 ：重点是在上述范围之一的声明中，其中声明了多个变量。 该命令打开对话框 改编 包含当前关注范围的所有声明的列表。通过用鼠标拖动，您可以将选定的声明向上或向下移动到不同的位置。 有关更多信息，请参阅： 重构" }, 
{ "title" : "文件 ", 
"url" : "_cds_f_commands_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：新项目 ", 
"url" : "_cds_cmd_new_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：新项目 ", 
"snippet" : "新项目 象征： 键盘快捷键： Ctrl + ñ 功能 ：该命令打开 新项目 用于创建新的项目文件。 称呼 ： 文件 菜单...", 
"body" : "新项目 象征： 键盘快捷键： Ctrl + ñ 功能 ：该命令打开 新项目 用于创建新的项目文件。 称呼 ： 文件 菜单 " }, 
{ "title" : "对话框：新项目 ", 
"url" : "_cds_cmd_new_project.html#UUID-6f88f662-6ca0-6f10-4ff7-01e65ed2eded_id_ad7732caf0c41c1c0a8640e00c145e1_id_1e70c84630a111d6c0a8640e0028ba1d", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：新项目 \/ 对话框：新项目 ", 
"snippet" : "功能 : 项目类别和项目模板的选择 称呼 ： 文件 → 新项目 命令 您将获得一个配备特定范围对象的项目，具体取决于所选模板。 类别 图书馆 项目 模板 项目 类别 空项目 仅包含 项目设置 目的 标准项目 包含基本范围的对象和库 向导有助于创建项目。 使用 Application Composer 的标准项目 包含用于使用 Application Composer 的基本对象和库 向导有助于创建项目。 图书馆 类别 CODESYS 容器库 仅包含附加库但没有自己的功能块的库 CODESYS 接口库 仅用于定义软件组件接口的库 因此，它只包含不生成任何代码的对象（例如，常量、结构和接口）。 空...", 
"body" : "功能 : 项目类别和项目模板的选择 称呼 ： 文件 → 新项目 命令 您将获得一个配备特定范围对象的项目，具体取决于所选模板。 类别 图书馆 项目 模板 项目 类别 空项目 仅包含 项目设置 目的 标准项目 包含基本范围的对象和库 向导有助于创建项目。 使用 Application Composer 的标准项目 包含用于使用 Application Composer 的基本对象和库 向导有助于创建项目。 图书馆 类别 CODESYS 容器库 仅包含附加库但没有自己的功能块的库 CODESYS 接口库 仅用于定义软件组件接口的库 因此，它只包含不生成任何代码的对象（例如，常量、结构和接口）。 空库 仅包含 项目设置 目的 外部的 CODESYS 图书馆 特定于目标系统的库 作为运行时系统的一部分实现（在 ANSI C 或 C++ 中） 姓名 要创建的项目名称 将显示默认名称，具体取决于模板。数字后缀确保文件系统中的名称是唯一的。 您可以更改文件名以遵守操作系统文件路径约定。名称中不允许使用点。 CODESYS 自动将相应的文件扩展名添加到所选模板。 地点 新项目文件的存储位置 打开一个对话框来搜索文件系统。 显示以前使用的路径的历史记录。 好的 CODESYS 打开一个新项目。一个错误 输入字段旁边的符号表示缺少数据。当您将鼠标指针悬停在它上面时，会显示一个工具提示，告诉您该做什么。 " }, 
{ "title" : "对话框：标准项目 ", 
"url" : "_cds_cmd_new_project.html#UUID-6f88f662-6ca0-6f10-4ff7-01e65ed2eded_id_ad7732caf0c41c1c0a8640e00c145e1_id_2aa85e4f30a111d8c0a8640e01abeee3", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：新项目 \/ 对话框：标准项目 ", 
"snippet" : "功能 : 创建标准项目的向导 称呼 ： 文件 → 新项目 命令;在里面 新项目 对话框，选择 项目 类别和 标准项目 模板，然后单击 好的 . 设备 带有 PLC 设备的列表框 在设备视图中，所选设备作为对象插入到根节点下方。 PLC_PRG 输入 带有实现语言的列表框 以所选语言创建自动插入的 PLC_PRG 程序。 有关更多信息，请参阅： 创建标准项目...", 
"body" : "功能 : 创建标准项目的向导 称呼 ： 文件 → 新项目 命令;在里面 新项目 对话框，选择 项目 类别和 标准项目 模板，然后单击 好的 . 设备 带有 PLC 设备的列表框 在设备视图中，所选设备作为对象插入到根节点下方。 PLC_PRG 输入 带有实现语言的列表框 以所选语言创建自动插入的 PLC_PRG 程序。 有关更多信息，请参阅： 创建标准项目" }, 
{ "title" : "命令：打开项目 ", 
"url" : "_cds_cmd_open_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：打开项目 ", 
"snippet" : "打开项目 象征： 键盘快捷键： Ctrl + ○ 功能 ：该命令打开加载项目的默认对话框。你可以搜索一个 CODESYS 文件系统中的项目并在开发系统中打开它。 称呼 ： 文件 菜单...", 
"body" : "打开项目 象征： 键盘快捷键： Ctrl + ○ 功能 ：该命令打开加载项目的默认对话框。你可以搜索一个 CODESYS 文件系统中的项目并在开发系统中打开它。 称呼 ： 文件 菜单 " }, 
{ "title" : "对话框：打开项目 ", 
"url" : "_cds_cmd_open_project.html#UUID-8a8b7dbf-6789-e615-a76d-2d52433df19e_id_ec92c4aaf11d53dc0a8640e00e17490_id_f8c83f4b11842681c0a864634a242657", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：打开项目 \/ 对话框：打开项目 ", 
"snippet" : "文件类型 类型 CODESYS 项目加载到开发系统 所有支持的文件 按所有项目过滤 CODESYS 可以加载 提示：例如，您可以选择 PRO 已创建的项目 CoDeSys V2.3 .这些类型的项目也被转换。 project 文件扩展名 按创建的项目过滤 CODESYS V3 projectarchive 文件扩展名 按创建的项目档案过滤 CODESYS V3 library 文件扩展名 按已创建的库项目过滤 CODESYS V3 打开 将选定的项目加载到 CODESYS 注意：取决于您的状态 CODESYS 安装时，可能需要更新或补充安装。如果是这种情况，那么先打开另一个 打开项目 带有安装...", 
"body" : "文件类型 类型 CODESYS 项目加载到开发系统 所有支持的文件 按所有项目过滤 CODESYS 可以加载 提示：例如，您可以选择 PRO 已创建的项目 CoDeSys V2.3 .这些类型的项目也被转换。 project 文件扩展名 按创建的项目过滤 CODESYS V3 projectarchive 文件扩展名 按创建的项目档案过滤 CODESYS V3 library 文件扩展名 按已创建的库项目过滤 CODESYS V3 打开 将选定的项目加载到 CODESYS 注意：取决于您的状态 CODESYS 安装时，可能需要更新或补充安装。如果是这种情况，那么先打开另一个 打开项目 带有安装管理选项的对话框。 " }, 
{ "title" : "对话框：打开项目（需要安装管理时） ", 
"url" : "_cds_cmd_open_project.html#UUID-8a8b7dbf-6789-e615-a76d-2d52433df19e_id_ec92c4aaf11d53dc0a8640e00e17490_id_b8f2d4bb2ffd39eec0a8640e00ffd301", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：打开项目 \/ 对话框：打开项目（需要安装管理时） ", 
"snippet" : "如果说 CODESYS -您要编辑的项目不适合与您当前的安装一起加载，出现以下对话框。在那里您可以确定如何进行。您的安装不合适，例如，如果它不包含附加组件 CODESYS UML 是，所以实现语言中有对象 UML 状态图 不知道，但所选项目包含此类对象。 不合适安装的示例：要打开的项目包含 UML 状态图 实现语言，但安装不包含 CODESYS UML 添加在。 该向导通过以下对话框运行： 项目检查 - 概述 该项目已使用不同版本 <CODESYS version> 保存。 该项目仍处于开发阶段。我想在这个版本中打开它并且不介意可能会生成不同的代码。 点击 下一个 打开 项目检查 - 缺少附加...", 
"body" : "如果说 CODESYS -您要编辑的项目不适合与您当前的安装一起加载，出现以下对话框。在那里您可以确定如何进行。您的安装不合适，例如，如果它不包含附加组件 CODESYS UML 是，所以实现语言中有对象 UML 状态图 不知道，但所选项目包含此类对象。 不合适安装的示例：要打开的项目包含 UML 状态图 实现语言，但安装不包含 CODESYS UML 添加在。 该向导通过以下对话框运行： 项目检查 - 概述 该项目已使用不同版本 <CODESYS version> 保存。 该项目仍处于开发阶段。我想在这个版本中打开它并且不介意可能会生成不同的代码。 点击 下一个 打开 项目检查 - 缺少附加组件 用于决定是否应在打开前添加当前安装中缺少的附加组件的对话框。 该项目已经部署在机器\/设备上。我想生成完全相同的代码，因此需要无需任何更改即可登录的可能性。 结果：将打开或安装兼容版本（如果尚不可用）。 点击 下一个 打开 项目考察——选择 用于切换到另一个安装的对话框。 细节 该按钮仅在项目保存时可用 CODESYS 版本 3.5.19.0 或更高版本。 打开 差异 对话。在这里您可以看到保存项目时安装了哪些附加组件，以及它们在当前安装中是否可用以及如何可用。 项目检查 - 缺少附加组件 该项目包含未安装合适的附加组件的对象 为此版本安装缺少的附加组件并重新启动。 点击 下一个 显示 项目检查 - 附加组件 用于配置附加附加组件安装的对话框。 无论如何继续。无法更改对象。 点击 结束 将在当前安装中打开项目。 限制： 该项目以写保护打开。 该项目包含不可读的未知对象。 该项目无法登录到控制器。 项目检查 - 附加组件 通过以下附加组件扩展当前安装。 显示的缺少的必需加载项和明确选择的可选加载项在单击后安装 结束 确认。为此，关闭 CODESYS Development System 并启动安装程序。 必需的附加组件 , 地位 所需加载项的名称、版本和状态 可能的状态： 失踪 匹配 从 <版本号> 更新到 <版本号> 可选附加组件 , 地位 可选附加组件的名称和版本。这些是项目并非绝对需要的附加组件，但在保存时可用。 项目考察——选择 The dialog opens when the option to open the project in a compatible CODESYS 版本选择在 项目检查 - 概述 .在这里您选择一个不同的、项目兼容的安装。 添加在 附加组件的名称 行动 点击 下一个 将打开 项目检查 - 附加组件 对话。它显示了正在创建的新安装中包含或可以添加的必需和可选附加组件。单击“完成”将关闭 CODESYS Development System 并开始 CODESYS Installer .它执行下载和新安装。 有关更多信息，请参阅： 打开一个 和 打开 V2.3 项目" }, 
{ "title" : "命令：关闭项目 ", 
"url" : "_cds_cmd_close_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：关闭项目 ", 
"snippet" : "关闭项目 功能 ：此命令关闭当前打开的项目。 CODESYS 仍然打开。 称呼 ： 文件菜单 ;此外，当另一个项目仍处于打开状态时，在打开新项目或其他项目时隐含 如果项目包含未保存的更改，则会显示一个对话框提示，询问您是否要保存该项目。 如果您尚未明确保存项目，则会显示一个对话框提示，询问您是否要删除项目文件。...", 
"body" : "关闭项目 功能 ：此命令关闭当前打开的项目。 CODESYS 仍然打开。 称呼 ： 文件菜单 ;此外，当另一个项目仍处于打开状态时，在打开新项目或其他项目时隐含 如果项目包含未保存的更改，则会显示一个对话框提示，询问您是否要保存该项目。 如果您尚未明确保存项目，则会显示一个对话框提示，询问您是否要删除项目文件。 " }, 
{ "title" : "命令：保存项目 ", 
"url" : "_cds_cmd_save_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：保存项目 ", 
"snippet" : "保存项目 象征： 键盘快捷键： Ctrl + 小号 功能 ：该命令保存项目文件。 称呼 ： 文件 菜单 该命令使用显示在主窗口标题栏中的当前项目名称保存项目文件。如果项目自上次保存后已更改，则项目名称带有星号。 如果项目被写保护，则该命令不可用。 以下情况存在写保护： 该项目在项目信息（摘要）中被标识为“已发布”。 打开项目时， 以只读方式打开 选项被选择在 打开项目 对话。 写保护由主窗口右上角的一条线表示。单击此行可显示包含以下可能操作的命令的菜单： 在磁盘上以不同的文件名保存项目 ：单击此选项时，将打开“将文件另存为”对话框。 退出只读模式 ：仅当 以只读方式打开 打开项目时选择了选项 ...", 
"body" : "保存项目 象征： 键盘快捷键： Ctrl + 小号 功能 ：该命令保存项目文件。 称呼 ： 文件 菜单 该命令使用显示在主窗口标题栏中的当前项目名称保存项目文件。如果项目自上次保存后已更改，则项目名称带有星号。 如果项目被写保护，则该命令不可用。 以下情况存在写保护： 该项目在项目信息（摘要）中被标识为“已发布”。 打开项目时， 以只读方式打开 选项被选择在 打开项目 对话。 写保护由主窗口右上角的一条线表示。单击此行可显示包含以下可能操作的命令的菜单： 在磁盘上以不同的文件名保存项目 ：单击此选项时，将打开“将文件另存为”对话框。 退出只读模式 ：仅当 以只读方式打开 打开项目时选择了选项 从磁盘上的项目中删除只读属性 ：仅当项目文件在磁盘上打开时提供了“只读”属性时才显示 删除项目信息中的“已发布”标识 ：仅当当前设置了此属性时才显示 备份副本 可以选择创建项目文件的备份副本。如果 创建备份副本 选项被选中 加载和保存 选项对话框，然后项目也被复制到一个名为 <project name.backup> 每次保存项目时。 有关更多信息，请参阅： 保存项目 和 加载和保存" }, 
{ "title" : "命令：将项目另存为 ", 
"url" : "_cds_cmd_save_project_as.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：将项目另存为 ", 
"snippet" : "将项目另存为 该命令打开用于保存文件的标准 Windows 对话框。可以使用所需的位置和文件类型保存项目。 文件类型 对于普通项目和库项目，此列表框包含可以保存项目的开发系统的各自版本。如果当前项目包含在所选内存格式（配置文件）中不可用的附加组件，则 扩展配置文件 对话框打开。 项目文件（ CODESYS V<版本>) (*.project) ：项目保存为 CODESYS 当前使用或选择的开发系统版本的名为“<项目名称>.project”的项目文件。 库文件 (V<版本>) (*.library) CODESYS ：项目保存为 CODESYS 当前使用或选择的开发系统版本的名为“<项目名称>....", 
"body" : "将项目另存为 该命令打开用于保存文件的标准 Windows 对话框。可以使用所需的位置和文件类型保存项目。 文件类型 对于普通项目和库项目，此列表框包含可以保存项目的开发系统的各自版本。如果当前项目包含在所选内存格式（配置文件）中不可用的附加组件，则 扩展配置文件 对话框打开。 项目文件（ CODESYS V<版本>) (*.project) ：项目保存为 CODESYS 当前使用或选择的开发系统版本的名为“<项目名称>.project”的项目文件。 库文件 (V<版本>) (*.library) CODESYS ：项目保存为 CODESYS 当前使用或选择的开发系统版本的名为“<项目名称>.library”的库文件。 如果您想稍后在旧版本中打开项目，那么精确保存此内存格式是有意义的，因为您将立即收到有关可能的数据丢失的通知。 项目的存储格式显示在项目信息中（ 项目 → 项目信息 , 文件 标签）。 在将项目另存为库之前： 确保已遵循创建库的规则。 如果以后可以在应用程序中配置库提供的全局常量，则必须在参数列表中定义它们。参数列表是一种特殊类型的全局变量列表。 保存项目时，不会自动检查错误。 不同于 CoDeSys V2.3 ，“外部”和“内部”库之间没有区别。现在，在每个单独项目对象的属性中，您可以定义该对象是否应被视为“外部”。 考虑一下创建的库是否应该立即安装在系统库存储库中。如果是这样，那么使用 在库存储库中保存项目并安装 命令。 如果您想保护库项目免受以后的更改，请设置 发布 中的属性 项目信息 对话。当下次尝试保存项目时，将显示一条相应的消息，用户必须通过有意的操作对写保护作出反应。 如果您将项目保存为当前使用的开发系统版本以外的版本，那么您将首先收到有关可能丢失数据的通知。 " }, 
{ "title" : "对话框：扩展配置文件 ", 
"url" : "_cds_cmd_save_project_as.html#UUID-3a5f4010-3111-46e1-90db-bb8388a40eca_id_fa7eae44c8e9c0a8640e018912b9_id_b152c4d5d9ce2c28c0a864637c36b07f", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：将项目另存为 \/ 对话框：扩展配置文件 ", 
"snippet" : "在此对话框中，所选配置文件（内存格式）可以通过当前项目中包含的附加组件进行扩展。配置文件会暂时保存，然后在保存或导出后删除。 添加到个人资料 ：当前配置文件被插件扩展，因此当前项目的插件数据也被保存。 添加在 当前项目的附加组件，不包含在所选内存格式中 版本 的版本 添加在 包含在当前配置文件中 如果安装了多个版本，则可以选择版本。 保存个人信息 打开 输入个人资料名称 对话 在对话框中，指定新配置文件的名称。新配置文件永久保存在 $ProgramData$\/$PRODUCT$\/CustomInformationalProfiles . 使用保存的配置文件 永久保存在的配置文件 保存个人信息 ...", 
"body" : "在此对话框中，所选配置文件（内存格式）可以通过当前项目中包含的附加组件进行扩展。配置文件会暂时保存，然后在保存或导出后删除。 添加到个人资料 ：当前配置文件被插件扩展，因此当前项目的插件数据也被保存。 添加在 当前项目的附加组件，不包含在所选内存格式中 版本 的版本 添加在 包含在当前配置文件中 如果安装了多个版本，则可以选择版本。 保存个人信息 打开 输入个人资料名称 对话 在对话框中，指定新配置文件的名称。新配置文件永久保存在 $ProgramData$\/$PRODUCT$\/CustomInformationalProfiles . 使用保存的配置文件 永久保存在的配置文件 保存个人信息 用于保存或导出当前项目。 有关更多信息，请参阅： 保存项目 和 加载和保存" }, 
{ "title" : "命令：保存项目并安装在库存储库中 ", 
"url" : "_cds_cmd_save_project_and_save_into_library_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：保存项目并安装在库存储库中 ", 
"snippet" : "在库存储库中保存项目并安装 功能 ：该命令将项目保存为“系统”库存储库中的库。 称呼 ： 文件 菜单 随着命令， CODESYS 将项目保存为“系统”库存储库中的库。这是一个将项目保存为库文件的扩展，使用 将项目另存为 命令。该库安装在本地系统上，可立即插入到项目中。...", 
"body" : "在库存储库中保存项目并安装 功能 ：该命令将项目保存为“系统”库存储库中的库。 称呼 ： 文件 菜单 随着命令， CODESYS 将项目保存为“系统”库存储库中的库。这是一个将项目保存为库文件的扩展，使用 将项目另存为 命令。该库安装在本地系统上，可立即插入到项目中。 " }, 
{ "title" : "命令：将项目另存为编译库 ", 
"url" : "_cds_cmd_save_project_as_compiled_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：将项目另存为编译库 ", 
"snippet" : "将项目另存为编译库 功能 ：该命令以加密格式保存库项目。 称呼 ： 文件 菜单 该命令打开用于在文件系统中保存文件的默认对话框。这 编译 CODESYS 图书馆 文件类型已经预设。文件扩展名为 .compiled-library-v3 要么 .compiled-library ( CODESYS < 3.5 SP15 ）。在这种格式下，在项目中使用库时，库 POU 的源代码是不可见的。 如果 强制对已编译的库进行签名 选项被选中 安全屏幕 查看 用户 选项卡，然后在保存库项目时必须提供基于数字证书的签名。当有合适的证书可用时，它会在 安全屏幕 在 用户 选项卡中的 电子签名 部分。在里面 项目...", 
"body" : "将项目另存为编译库 功能 ：该命令以加密格式保存库项目。 称呼 ： 文件 菜单 该命令打开用于在文件系统中保存文件的默认对话框。这 编译 CODESYS 图书馆 文件类型已经预设。文件扩展名为 .compiled-library-v3 要么 .compiled-library ( CODESYS < 3.5 SP15 ）。在这种格式下，在项目中使用库时，库 POU 的源代码是不可见的。 如果 强制对已编译的库进行签名 选项被选中 安全屏幕 查看 用户 选项卡，然后在保存库项目时必须提供基于数字证书的签名。当有合适的证书可用时，它会在 安全屏幕 在 用户 选项卡中的 电子签名 部分。在里面 项目信息 , 在 概括 选项卡，一个 库兼容性 与 CODESYS 版本 >= 3.5 SP15 默认设置。在这种情况下，项目文件与 .compiled-library-v3 当它保存为编译和签名的库时的文件扩展名。如果您仍未在 安全屏幕 ，然后接下来会打开一个对话框提示，供您执行此操作。之后，您可以再次运行保存命令。 在所有其他方面，编译的库文件的行为就像 *.library 文件，因此可以使用相同的步骤安装和引用它们。 我们建议您使用使用证书编译和签名的库。除了保护源代码和未经授权使用库外，还使用了更少的内存，从而缩短了加载时间。 如果您有相应的翻译帮助文件，那么在 CODESYS 五 3.5 SP15 稍后您可以将库文档扩展为其他语言，如下所示： 放置 __lmd__<language>.aux 为新语言创建的文件 <library name>.lmd 目录平行于 <library name>.compiled-library-v3 图书馆项目。 如果文件正确，则在通过 将项目另存为编译库 命令。 示例： standard.lmd 目录与 standard.compiled-library-v3 库文件并包含 __lmd__fr.aux 文件与图书馆文档的法语翻译。编译好的库保存后，库管理器中也提供了法语版的文档。 有关更多信息，请参阅： 图书馆开发人员信息 和 在库存储库中保存项目并安装" }, 
{ "title" : "命令：保存\/发送存档 ", 
"url" : "_cds_cmd_save_send_archive.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：保存\/发送存档 ", 
"snippet" : "保存\/发送存档 功能 ：该命令打开 项目档案 用于配置项目档案的对话框。 称呼 ： 文件 → 项目存档 菜单 存档文件 (*.projectarchive) 包含当前打开的项目中包含和引用的所有文件。它可以保存或作为电子邮件附件发送。作为电子邮件发送对于将所有与项目相关的文件提供给同事非常有帮助。该文件可以简单地通过再次解压 提取档案 命令。 归档功能旨在简单汇总所有与项目相关的文件，而不是存储项目。...", 
"body" : "保存\/发送存档 功能 ：该命令打开 项目档案 用于配置项目档案的对话框。 称呼 ： 文件 → 项目存档 菜单 存档文件 (*.projectarchive) 包含当前打开的项目中包含和引用的所有文件。它可以保存或作为电子邮件附件发送。作为电子邮件发送对于将所有与项目相关的文件提供给同事非常有帮助。该文件可以简单地通过再次解压 提取档案 命令。 归档功能旨在简单汇总所有与项目相关的文件，而不是存储项目。 " }, 
{ "title" : "对话框：项目存档 ", 
"url" : "_cds_cmd_save_send_archive.html#UUID-276bb6db-1861-3b1e-cd2f-bfc223682f8d_id_a9a34c3aeeaced8c0a8640e00146045_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：保存\/发送存档 \/ 对话框：项目存档 ", 
"snippet" : "该对话框显示可以添加到项目存档中的所有类别。在此对话框中，您可以选择 可以将整个类别或类别中的单个对象添加到项目存档中。 条目在列表中显示为红色，需要您注意。将鼠标指针悬停在此库上以获取更多信息。 附加文件 打开 附加文件 对话 在那里你可以使用 添加 按钮添加更多文件。 评论 打开“评论”对话框 在那里，您可以向存档添加评论。 保存 创建存档文件并保存 在随后的对话框中指定位置和存档名称。 发送 创建一个附加到空电子邮件的临时存档文件 成功执行此操作需要正确安装 MAPI（消息应用程序编程接口）。通过显示相应的错误消息来记录任何故障。发送电子邮件后，临时存档会自动删除。...", 
"body" : "该对话框显示可以添加到项目存档中的所有类别。在此对话框中，您可以选择 可以将整个类别或类别中的单个对象添加到项目存档中。 条目在列表中显示为红色，需要您注意。将鼠标指针悬停在此库上以获取更多信息。 \n \n \n \n \n 附加文件 \n \n \n 打开 附加文件 对话 \n 在那里你可以使用 添加 按钮添加更多文件。 \n \n \n \n 评论 \n \n \n 打开“评论”对话框 \n 在那里，您可以向存档添加评论。 \n \n \n \n 保存 \n \n \n 创建存档文件并保存 \n 在随后的对话框中指定位置和存档名称。 \n \n \n \n 发送 \n \n \n 创建一个附加到空电子邮件的临时存档文件 \n 成功执行此操作需要正确安装 MAPI（消息应用程序编程接口）。通过显示相应的错误消息来记录任何故障。发送电子邮件后，临时存档会自动删除。 \n \n " }, 
{ "title" : "命令：提取档案 ", 
"url" : "_cds_cmd_extract_archive.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：提取档案 ", 
"snippet" : "提取档案 功能 ：该命令提取使用该命令创建的存储库 保存\/发送存档 被创建。在此之前，您需要配置应提取存档的哪些内容以及应将其复制到文件系统中的哪些目录。 称呼 ： 文件 → 项目存档 菜单 默认情况下，存档具有 .projectarchive 文件扩展名。 选择存档后， 提取项目档案 对话框打开，您可以在其中配置提取。...", 
"body" : "提取档案 功能 ：该命令提取使用该命令创建的存储库 保存\/发送存档 被创建。在此之前，您需要配置应提取存档的哪些内容以及应将其复制到文件系统中的哪些目录。 称呼 ： 文件 → 项目存档 菜单 默认情况下，存档具有 .projectarchive 文件扩展名。 选择存档后， 提取项目档案 对话框打开，您可以在其中配置提取。 " }, 
{ "title" : "对话框：提取项目存档 ", 
"url" : "_cds_cmd_extract_archive.html#UUID-0b9634c6-9978-893d-8419-d94a07a18d40_UUID-d609574c-71bc-f347-9967-86de00b02f23", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：提取档案 \/ 对话框：提取项目存档 ", 
"snippet" : "提取项目档案 该对话框显示项目存档的内容。您可以取消选择 整个类别或类别中的单个对象以从提取中排除它们。 如果存储库包含 Git 项目和 Git 存储库信息，请务必解压缩存储库信息。否则，如果解压后的 Git 项目链接到与本地已存在的目录同名的存储库，则可能会出现不良影响。 文件路径 提取到存档所在的同一文件夹中 存档被提取到同一目录。 解压到以下文件夹 存档的内容被提取到指定的路径。 先进的 打开 先进的 对话框，您可以在其中定义从存档中提取特殊文件和附加文件的位置。 内容 对象 显示归档的内容，按对象类别结构化 : 对象将被提取。 ：不会提取对象。 评论 创建项目存档时输入的注释 提炼 如...", 
"body" : "提取项目档案 该对话框显示项目存档的内容。您可以取消选择 整个类别或类别中的单个对象以从提取中排除它们。 如果存储库包含 Git 项目和 Git 存储库信息，请务必解压缩存储库信息。否则，如果解压后的 Git 项目链接到与本地已存在的目录同名的存储库，则可能会出现不良影响。 文件路径 提取到存档所在的同一文件夹中 存档被提取到同一目录。 解压到以下文件夹 存档的内容被提取到指定的路径。 先进的 打开 先进的 对话框，您可以在其中定义从存档中提取特殊文件和附加文件的位置。 内容 对象 显示归档的内容，按对象类别结构化 : 对象将被提取。 ：不会提取对象。 评论 创建项目存档时输入的注释 提炼 如果提取的文件与目标目录中的现有文件同名，则会打开一个对话框，提示是否应替换本地文件。该决定可以自动应用于任何其他有冲突的名称。在这种情况下，您必须选择 适用于所有对象和文件 选项。 " }, 
{ "title" : "对话： 先进的 ", 
"url" : "_cds_cmd_extract_archive.html#UUID-0b9634c6-9978-893d-8419-d94a07a18d40_id_e7d1fb8371682c0a8640e01de9372_id_1ab891adf85c11e3ab2595dcbe415eae", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：提取档案 \/ 对话： 先进的 ", 
"snippet" : "存储库 将设备安装到 具有当前可用存储库的列表框 选择存储库 CODESYS 应该安装存档的设备和库。 将库安装到 附加文件 默认情况下，“附加文件”预配置为 不要提取 .您可以通过选择表中的条目并选择以下选项之一来更改此设置： 解压到项目文件夹 项目文件目录 解压到文件夹 自定义目录 不要提取 默认设置...", 
"body" : "存储库 将设备安装到 具有当前可用存储库的列表框 选择存储库 CODESYS 应该安装存档的设备和库。 将库安装到 附加文件 默认情况下，“附加文件”预配置为 不要提取 .您可以通过选择表中的条目并选择以下选项之一来更改此设置： 解压到项目文件夹 项目文件目录 解压到文件夹 自定义目录 不要提取 默认设置 " }, 
{ "title" : "命令：源码下载 ", 
"url" : "_cds_cmd_source_upload.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：源码下载 ", 
"snippet" : "源码下载 功能 ：该命令从控制器加载项目源代码，该代码作为项目存档在控制器上可用。 称呼 ： 文件 菜单 要求 ：必须配置控制器的网络路径。 执行命令后，将打开一个包含网络中所有设备的概览。从此概览中选择一个控制器。在那之后， 提取项目档案 对话框打开，其中包含提取设置。 有关更多信息，请参阅： 将源代码下载到 PLC 和从 PLC 下载源代码...", 
"body" : "源码下载 功能 ：该命令从控制器加载项目源代码，该代码作为项目存档在控制器上可用。 称呼 ： 文件 菜单 要求 ：必须配置控制器的网络路径。 执行命令后，将打开一个包含网络中所有设备的概览。从此概览中选择一个控制器。在那之后， 提取项目档案 对话框打开，其中包含提取设置。 有关更多信息，请参阅： 将源代码下载到 PLC 和从 PLC 下载源代码" }, 
{ "title" : "对话框：提取项目存档 ", 
"url" : "_cds_cmd_source_upload.html#UUID-0bffdb14-f884-fdff-c7f7-9f985d6beb45_UUID-d609574c-71bc-f347-9967-86de00b02f23", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：源码下载 \/ 对话框：提取项目存档 ", 
"snippet" : "提取项目档案 该对话框显示项目存档的内容。您可以取消选择 整个类别或类别中的单个对象以从提取中排除它们。 如果存储库包含 Git 项目和 Git 存储库信息，请务必解压缩存储库信息。否则，如果解压后的 Git 项目链接到与本地已存在的目录同名的存储库，则可能会出现不良影响。 文件路径 提取到存档所在的同一文件夹中 存档被提取到同一目录。 解压到以下文件夹 存档的内容被提取到指定的路径。 先进的 打开 先进的 对话框，您可以在其中定义从存档中提取特殊文件和附加文件的位置。 内容 对象 显示归档的内容，按对象类别结构化 : 对象将被提取。 ：不会提取对象。 评论 创建项目存档时输入的注释 提炼 如...", 
"body" : "提取项目档案 该对话框显示项目存档的内容。您可以取消选择 整个类别或类别中的单个对象以从提取中排除它们。 如果存储库包含 Git 项目和 Git 存储库信息，请务必解压缩存储库信息。否则，如果解压后的 Git 项目链接到与本地已存在的目录同名的存储库，则可能会出现不良影响。 文件路径 提取到存档所在的同一文件夹中 存档被提取到同一目录。 解压到以下文件夹 存档的内容被提取到指定的路径。 先进的 打开 先进的 对话框，您可以在其中定义从存档中提取特殊文件和附加文件的位置。 内容 对象 显示归档的内容，按对象类别结构化 : 对象将被提取。 ：不会提取对象。 评论 创建项目存档时输入的注释 提炼 如果提取的文件与目标目录中的现有文件同名，则会打开一个对话框，提示是否应替换本地文件。该决定可以自动应用于任何其他有冲突的名称。在这种情况下，您必须选择 适用于所有对象和文件 选项。 " }, 
{ "title" : "命令：源上传 ", 
"url" : "_cds_cmd_source_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：源上传 ", 
"snippet" : "源上传 功能 ：该命令将项目源代码作为项目存档加载到控制器。 称呼 ： 文件 菜单 要求 ：必须配置控制器的网络路径。 执行命令后，将打开一个包含网络中所有设备的概览。从此概览中选择一个控制器。在那之后， Archive.prj 项目存档下载到该控制器。稍后，您可以单击 源上传 下载完整的源代码到 CODESYS 开发系统。 如果您已经连接到控制器（在线模式），则 源下载到连接的设备 命令也可用于此操作。 有关更多信息，请参阅： 将源代码下载到 PLC 和从 PLC 下载源代码...", 
"body" : "源上传 功能 ：该命令将项目源代码作为项目存档加载到控制器。 称呼 ： 文件 菜单 要求 ：必须配置控制器的网络路径。 执行命令后，将打开一个包含网络中所有设备的概览。从此概览中选择一个控制器。在那之后， Archive.prj 项目存档下载到该控制器。稍后，您可以单击 源上传 下载完整的源代码到 CODESYS 开发系统。 如果您已经连接到控制器（在线模式），则 源下载到连接的设备 命令也可用于此操作。 有关更多信息，请参阅： 将源代码下载到 PLC 和从 PLC 下载源代码" }, 
{ "title" : "命令：打印 ", 
"url" : "_cds_cmd_print.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：打印 ", 
"snippet" : "打印 象征 ： 功能 ：该命令打开用于打印文档的默认 Windows 对话框。 称呼 ： 文件 菜单...", 
"body" : "打印 象征 ： 功能 ：该命令打开用于打印文档的默认 Windows 对话框。 称呼 ： 文件 菜单 " }, 
{ "title" : "命令：打印预览 ", 
"url" : "_cds_cmd_print_preview.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：打印预览 ", 
"snippet" : "打印预览 功能 ：该命令为当前打开的元素打开打印预览 该命令打开当前打开的元素的打印预览。 称呼 ： 文件 菜单 要求 : 一个对象在编辑器中打开。...", 
"body" : "打印预览 功能 ：该命令为当前打开的元素打开打印预览 该命令打开当前打开的元素的打印预览。 称呼 ： 文件 菜单 要求 : 一个对象在编辑器中打开。 " }, 
{ "title" : "命令：页面设置 ", 
"url" : "_cds_cmd_page_setup.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：页面设置 ", 
"snippet" : "页面设置 象征： 功能 ：该命令打开 页面设置 用于配置项目内容印刷版布局的对话框。 称呼 ： 文件 → 页面设置 菜单...", 
"body" : "页面设置 象征： 功能 ：该命令打开 页面设置 用于配置项目内容印刷版布局的对话框。 称呼 ： 文件 → 页面设置 菜单 " }, 
{ "title" : "命令：最近的项目 ", 
"url" : "_cds_cmd_recent_projects.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：最近的项目 ", 
"snippet" : "最近的项目 功能 ：该命令打开最近使用过的项目列表，您可以选择其中一个打开。 称呼 ： 文件 菜单...", 
"body" : "最近的项目 功能 ：该命令打开最近使用过的项目列表，您可以选择其中一个打开。 称呼 ： 文件 菜单 " }, 
{ "title" : "命令：退出 ", 
"url" : "_cds_cmd_exit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 文件 \/ 命令：退出 ", 
"snippet" : "出口 键盘快捷键： Alt + F4 功能 ：命令退出编程系统。如果打开的项目自上次保存操作以来已更改，则会打开一个对话框，提示是否应保存该项目。 称呼 ： 文件 菜单...", 
"body" : "出口 键盘快捷键： Alt + F4 功能 ：命令退出编程系统。如果打开的项目自上次保存操作以来已更改，则会打开一个对话框，提示是否应保存该项目。 称呼 ： 文件 菜单 " }, 
{ "title" : "观点 ", 
"url" : "_cds_f_commands_view.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "视图中的默认菜单：设备、POU 和模块 ", 
"url" : "_cds_dropdown_menu_in_standard_views.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 视图中的默认菜单：设备、POU 和模块 ", 
"snippet" : "观点 设备 , POU 和 模块 每个都在右上角包含一个按钮 使用以下命令打开菜单： 在记事本中打开 ：在相应的编辑器中打开视图中选择的块 搜索对象 ：打开对话框 搜索对象 对于视图中的对象树 当您开始输入字符串时，当前的搜索结果总是显示名称和路径。带按钮 打开 您可以在关联的编辑器中打开选定的搜索结果。 按类型排序 ：按类型和字母顺序对窗口中的对象进行排序 按名称分类 ：按名称和字母顺序对窗口中的对象进行排序 升序 ：以升序显示上面选择的排序 降序排序 ：按降序显示上面选择的排序 跟踪活动编辑器 ： CODESYS 选择视图对象树中当前活动编辑器中打开的对象。...", 
"body" : "观点 设备 , POU 和 模块 每个都在右上角包含一个按钮 使用以下命令打开菜单： 在记事本中打开 ：在相应的编辑器中打开视图中选择的块 搜索对象 ：打开对话框 搜索对象 对于视图中的对象树 当您开始输入字符串时，当前的搜索结果总是显示名称和路径。带按钮 打开 您可以在关联的编辑器中打开选定的搜索结果。 按类型排序 ：按类型和字母顺序对窗口中的对象进行排序 按名称分类 ：按名称和字母顺序对窗口中的对象进行排序 升序 ：以升序显示上面选择的排序 降序排序 ：按降序显示上面选择的排序 跟踪活动编辑器 ： CODESYS 选择视图对象树中当前活动编辑器中打开的对象。 " }, 
{ "title" : "命令：设备 ", 
"url" : "_cds_cmd_devices.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：设备 ", 
"snippet" : "设备 象征： 键盘快捷键： 老的 + 0 功能 : 命令打开视图 设备 在里面 CODESYS 主窗口。它包含您在其中配置应用程序的项目的“设备树”。 关于按钮 用于在视图的对象树中导航的标准菜单可用。 称呼 ： 菜单 观点 有关更多信息，请参阅： 设备树和设备编辑器...", 
"body" : "设备 象征： 键盘快捷键： 老的 + 0 功能 : 命令打开视图 设备 在里面 CODESYS 主窗口。它包含您在其中配置应用程序的项目的“设备树”。 关于按钮 用于在视图的对象树中导航的标准菜单可用。 称呼 ： 菜单 观点 有关更多信息，请参阅： 设备树和设备编辑器" }, 
{ "title" : "命令：POU ", 
"url" : "_cds_cmd_pous.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：POU ", 
"snippet" : "POU 象征： 键盘快捷键： 老的 + 1 功能 : 命令打开视图 POU 在里面 CODESYS 主窗口。位于此处的块在整个项目中都可用。 称呼 ： 菜单 观点...", 
"body" : "POU 象征： 键盘快捷键： 老的 + 1 功能 : 命令打开视图 POU 在里面 CODESYS 主窗口。位于此处的块在整个项目中都可用。 称呼 ： 菜单 观点 " }, 
{ "title" : "命令：模块 ", 
"url" : "_cds_cmd_modules.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：模块 ", 
"snippet" : "模块 象征： 功能 : 命令打开视图 模块 .他们将在其中 模块 应用程序编辑器的树形结构。 称呼 ： 菜单 观点...", 
"body" : "模块 象征： 功能 : 命令打开视图 模块 .他们将在其中 模块 应用程序编辑器的树形结构。 称呼 ： 菜单 观点 " }, 
{ "title" : "命令：报告 ", 
"url" : "_cds_cmd_messages.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：报告 ", 
"snippet" : "消息 象征： 功能 : 命令打开视图 消息 . 称呼 ： 菜单 观点...", 
"body" : "消息 象征： 功能 : 命令打开视图 消息 . 称呼 ： 菜单 观点 " }, 
{ "title" : "查看：消息 ", 
"url" : "_cds_cmd_messages.html#UUID-119e042d-47fd-099a-1188-ae75ac690d78_id_af63110db5724c0a8640e01487d4a_id_57525bcedefa7c4cc0a8640e01fa4246", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：报告 \/ 查看：消息 ", 
"snippet" : "消息类别 消息按组件或功能分类，并在选择对话框中可用。通过选择类别过滤消息显示。 消息类型 单击消息类型图标以显示或隐藏消息。每个图标旁边显示 CODESYS 已发生的消息数。 ： 错误 ： 警告 ： 信息 删除所选消息类别中的所有消息 删除所有消息类别中的所有消息 描述 带有导致它的对象和对象内的位置的消息文本 双击表中的消息条目以转到源代码位置。 命令图标： 对于未解析的库，列出可用于快速修复报告错误的命令 将占位符“<library>”更新为最新版本 打开 Library Manager 的“Placeholders”对话框 项目 生成消息的项目名称 目的 生成消息的对象 位置 代码中的...", 
"body" : "消息类别 消息按组件或功能分类，并在选择对话框中可用。通过选择类别过滤消息显示。 消息类型 单击消息类型图标以显示或隐藏消息。每个图标旁边显示 CODESYS 已发生的消息数。 ： 错误 ： 警告 ： 信息 删除所选消息类别中的所有消息 删除所有消息类别中的所有消息 描述 带有导致它的对象和对象内的位置的消息文本 双击表中的消息条目以转到源代码位置。 命令图标： 对于未解析的库，列出可用于快速修复报告错误的命令 将占位符“<library>”更新为最新版本 打开 Library Manager 的“Placeholders”对话框 项目 生成消息的项目名称 目的 生成消息的对象 位置 代码中的位置 上下文菜单中的命令 下一条消息 显示下一条消息的源文本位置。 上一条消息 显示上一条消息的源代码位置。 转到源位置 显示所选消息的源文本位置。 " }, 
{ "title" : "命令：元素属性 ", 
"url" : "_cds_cmd_element_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：元素属性 ", 
"snippet" : "项目属性 象征： 功能 : 命令打开视图 项目属性 . 称呼 ： 菜单 观点 使用命令打开当前打开对象的属性视图。此视图仅对少数对象可用，例如可视化和 POU (AS)。 属性显示在结构化表格中。您可以通过单击值字段来更改属性的值。您可以过滤或排序属性视图。...", 
"body" : "项目属性 象征： 功能 : 命令打开视图 项目属性 . 称呼 ： 菜单 观点 使用命令打开当前打开对象的属性视图。此视图仅对少数对象可用，例如可视化和 POU (AS)。 属性显示在结构化表格中。您可以通过单击值字段来更改属性的值。您可以过滤或排序属性视图。 " }, 
{ "title" : "命令：工具 ", 
"url" : "_cds_cmd_tools.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：工具 ", 
"snippet" : "工具 象征： 功能 : 命令打开视图 工具 . 称呼 ： 菜单 观点 使用命令打开当前打开对象的工具视图。默认情况下，您可以在图形编辑器或可视化中使用此视图。它包含您可以拖动到编辑器中的图形编程元素。...", 
"body" : "工具 象征： 功能 : 命令打开视图 工具 . 称呼 ： 菜单 观点 使用命令打开当前打开对象的工具视图。默认情况下，您可以在图形编辑器或可视化中使用此视图。它包含您可以拖动到编辑器中的图形编程元素。 " }, 
{ "title" : "命令：监视列表 - 监视列表 <n> ", 
"url" : "_cds_cmd_view_watch.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：监视列表 - 监视列表 <n> ", 
"snippet" : "观察名单 - 观察名单 <n> 象征： 功能 : 命令打开视图 观察名单 <n> .您可以使用项目中的变量填充监控列表，以便能够在单个视图中在线监控、强制或写入这些变量的值。值“n”可以是 1、2、3 或 4，这意味着您最多可以配置四个监视列表。 称呼 ： 菜单 观点 有关更多信息，请参阅： 使用观察列表...", 
"body" : "观察名单 - 观察名单 <n> 象征： 功能 : 命令打开视图 观察名单 <n> .您可以使用项目中的变量填充监控列表，以便能够在单个视图中在线监控、强制或写入这些变量的值。值“n”可以是 1、2、3 或 4，这意味着您最多可以配置四个监视列表。 称呼 ： 菜单 观点 有关更多信息，请参阅： 使用观察列表" }, 
{ "title" : "命令：监视列表：显示所有部队 ", 
"url" : "_cds_cmd_view_watch_all_forces.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：监视列表：显示所有部队 ", 
"snippet" : "监视列表：显示所有部队 象征： 功能 : 命令打开视图 显示所有力量 ，这是一种特殊形式的观察名单。 称呼 ： 菜单 查看 → 观察列表 → 显示所有力量 要求 ：项目以离线或在线模式打开。 该视图包含当前为强制准备的应用程序的所有变量以及列表中的所有强制变量。在列表中，可能的操作在其他监控列表中也是可能的。此外，在选择列表中还有 解除强制 以下命令： 显示所有力量 以表格形式显示应用程序的所有已强制并准备强制执行的变量 表达 变量名称 数据类型 变量的数据类型 值得 变量的当前强制值 准备值 为强制准备的值 循环开始时覆盖的值 在输入的情况下，在执行用户代码之前，实际值已经被强制值覆盖。所以...", 
"body" : "监视列表：显示所有部队 象征： 功能 : 命令打开视图 显示所有力量 ，这是一种特殊形式的观察名单。 称呼 ： 菜单 查看 → 观察列表 → 显示所有力量 要求 ：项目以离线或在线模式打开。 该视图包含当前为强制准备的应用程序的所有变量以及列表中的所有强制变量。在列表中，可能的操作在其他监控列表中也是可能的。此外，在选择列表中还有 解除强制 以下命令： 显示所有力量 以表格形式显示应用程序的所有已强制并准备强制执行的变量 表达 变量名称 数据类型 变量的数据类型 值得 变量的当前强制值 准备值 为强制准备的值 循环开始时覆盖的值 在输入的情况下，在执行用户代码之前，实际值已经被强制值覆盖。所以这是强制值。 对于输出，这是强制值。 循环结束时覆盖的值 对于输出，这是在循环中计算的值。但是，该值会在循环结束时被强制值覆盖。 对于输入，这是强制值。 取消强制并保留所有选定的值 ：对于列表中所有选定的条目，变量设置为强制值并取消强制。 取消强制并恢复所有选定的值 ：对于列表中的所有选定条目，变量将重置为强制之前的值，并删除强制。 有关更多信息，请参阅： 变量的强制和写入 和 使用观察列表" }, 
{ "title" : "命令：将所有部队添加到监视列表 ", 
"url" : "_cds_cmd_add_all_forces_to_watchlist.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：将所有部队添加到监视列表 ", 
"snippet" : "将所有部队添加到观察名单 功能 ：该命令将当前应用程序的所有当前准备强制或已经强制的变量添加到监控列表中。但是请注意，这仅适用于停靠的监视列表。 称呼 ：视图的上下文菜单 观察名单 要求 ：在线操作，监控列表处于活动状态。 有一个特别的观察名单： 查看所有势力 ，它总是自动显示所有已准备好强制或正在强制的变量。它还提供取消强制的命令。 有关更多信息，请参阅： 监视列表：显示所有部队...", 
"body" : "将所有部队添加到观察名单 功能 ：该命令将当前应用程序的所有当前准备强制或已经强制的变量添加到监控列表中。但是请注意，这仅适用于停靠的监视列表。 称呼 ：视图的上下文菜单 观察名单 要求 ：在线操作，监控列表处于活动状态。 有一个特别的观察名单： 查看所有势力 ，它总是自动显示所有已准备好强制或正在强制的变量。它还提供取消强制的命令。 有关更多信息，请参阅： 监视列表：显示所有部队" }, 
{ "title" : "命令：书签 ", 
"url" : "_cds_cmd_bookmarks.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：书签 ", 
"snippet" : "书签 象征： 功能 : 命令打开视图 书签 . 称呼 ： 菜单 观点 上一个书签 跳转到表格中显示的书签在所选行上方的一行，并在编辑器中打开相应的 POU 下一个书签 跳转到表格中所选行下一行显示的书签，并在编辑器中打开相应的 POU 从表和相应的 POU 中删除选定的书签 项目的书签列表和信息 书签 , 目的 和 位置 您可以使用拖放更改书签的顺序。 双击一行时，打开 CODESYS 相应的 目的 在编辑器中并跳转到该书签。 书签 从 CODESYS 按编号升序分配的书签名称： 书签_0 , 书签_2 等等。 当书签被选中并单击该字段时，它变为可编辑的，您可以更改书签的标签。 目的 设置书签...", 
"body" : "书签 象征： 功能 : 命令打开视图 书签 . 称呼 ： 菜单 观点 上一个书签 跳转到表格中显示的书签在所选行上方的一行，并在编辑器中打开相应的 POU 下一个书签 跳转到表格中所选行下一行显示的书签，并在编辑器中打开相应的 POU 从表和相应的 POU 中删除选定的书签 项目的书签列表和信息 书签 , 目的 和 位置 您可以使用拖放更改书签的顺序。 双击一行时，打开 CODESYS 相应的 目的 在编辑器中并跳转到该书签。 书签 从 CODESYS 按编号升序分配的书签名称： 书签_0 , 书签_2 等等。 当书签被选中并单击该字段时，它变为可编辑的，您可以更改书签的标签。 目的 设置书签的 POU 的名称和工程路径 例子： POU_Add [PLC_1: SPS-Logic: Application] 位置 书签在 POU 中的位置 例子： Zeile3, Spalte 1 (Impl) (Impl) : 在 POU 的实现部分 (Decl) : 在 POU 的声明部分 有关更多信息，请参阅： 设置和使用书签" }, 
{ "title" : "命令：断点 ", 
"url" : "_cds_cmd_breakpoints.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：断点 ", 
"snippet" : "断点 象征： 功能 : 命令打开视图 断点 . 称呼 ： 菜单 观点 该视图向您显示应用程序的所有已定义断点的概览。所有断点命令都在视图中可用。 当前断点表 应用 从列表中选择所需的应用程序。 POU 包含断点的构建块的名称 位置 POU 内的断点位置 文本编辑器：行加列号 图形编辑器：网络或元素编号 “(Impl)”在功能块的情况下表示断点在功能块的实现中，而不是在实例中。 实例路径 断点位置的完整对象路径 任务 断点应在其执行时生效的任务的名称 如果不适用任何限制，则显示“（全部）”。 状况 总是停下来 ：没有定义额外的激活条件 断点始终处于活动状态。 布尔表达式 表达式必须 TRUE 交...", 
"body" : "断点 象征： 功能 : 命令打开视图 断点 . 称呼 ： 菜单 观点 该视图向您显示应用程序的所有已定义断点的概览。所有断点命令都在视图中可用。 当前断点表 应用 从列表中选择所需的应用程序。 POU 包含断点的构建块的名称 位置 POU 内的断点位置 文本编辑器：行加列号 图形编辑器：网络或元素编号 “(Impl)”在功能块的情况下表示断点在功能块的实现中，而不是在实例中。 实例路径 断点位置的完整对象路径 任务 断点应在其执行时生效的任务的名称 如果不适用任何限制，则显示“（全部）”。 状况 总是停下来 ：没有定义额外的激活条件 断点始终处于活动状态。 布尔表达式 表达式必须 TRUE 交付使断点处于活动状态。 命中计数条件 断点何时生效（取决于命中次数）的规范 当前点击数 指定执行期间断点通过（“命中”）的频率 上次更新监视值 显示上次更新监视值的时间 工具栏 新断点 该命令打开对话框 断点属性 . 新数据断点 该命令打开对话框 新断点 . 删除断点 删除断点 不要与停用混淆！ 启用\/禁用断点 在启用和禁用状态之间切换断点或执行点 : 断点已启用。 : 断点被禁用。 : 执行点被激活。 : 执行点被禁用。 ：启用数据断点。 :数据断点被禁用。 ：启用数据执行点。 ：数据执行点被禁用。 与之相反 删除断点 禁用的断点保留在列表中，并且可以再次启用。 特性 对话 断点属性 出现编辑断点参数。对话对应对话 新断点 .在在线模式下，您可以在此处将断点转换为执行点。 转到源代码位置 打开相关块的在线视图 光标位于断点位置。 删除所有断点 清除应用程序的所有断点和执行点 列表已清空。不要与停用混淆！ 启用所有断点 启用所有当前禁用的断点和执行点 禁用所有断点 禁用所有当前启用的断点和执行点 这些点保留在列表中，可以再次激活。 有关更多信息，请参阅： 使用断点" }, 
{ "title" : "命令：交叉引用列表 ", 
"url" : "_cds_cmd_view_cross_reference_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：交叉引用列表 ", 
"snippet" : "交叉引用列表 象征： 功能 : 命令打开视图 交叉引用列表 . 称呼 ： 菜单 观点 ， 或者 编辑→查找符号→输出交叉引用 该视图显示项目中符号的交叉引用列表。符号可以是变量、POU（程序、功能块、函数）或用户定义的数据类型 (DUT)。交叉引用列表基本上提供了两种类型的搜索： 文本搜索：输入符号名称将显示项目中具有该名称的所有符号的交叉引用。如果找到多个具有相同名称的符号，则可以通过上下文菜单将显示限制为单独的声明。 声明搜索：可以使用输入帮助或输入限定路径（例如 Device.Application.PLC_PRG.i 或者 __POOL.POU.a ) 被选中。之后，即使有其他同名符号...", 
"body" : "交叉引用列表 象征： 功能 : 命令打开视图 交叉引用列表 . 称呼 ： 菜单 观点 ， 或者 编辑→查找符号→输出交叉引用 该视图显示项目中符号的交叉引用列表。符号可以是变量、POU（程序、功能块、函数）或用户定义的数据类型 (DUT)。交叉引用列表基本上提供了两种类型的搜索： 文本搜索：输入符号名称将显示项目中具有该名称的所有符号的交叉引用。如果找到多个具有相同名称的符号，则可以通过上下文菜单将显示限制为单独的声明。 声明搜索：可以使用输入帮助或输入限定路径（例如 Device.Application.PLC_PRG.i 或者 __POOL.POU.a ) 被选中。之后，即使有其他同名符号，也只显示使用该符号的地方。 输入框 符号名称（变量名称、块名称、DUT 名称）- 输入选项： 通过按钮的输入帮助选择声明的符号 手动输入符号名称 使用按钮触发搜索 或者 输入 您可以使用通配符“ * \"（任意数量的字符）或 \" ? “（完全是任何字符）与变量标识符的子字符串组合。 利用 ” % ' 如果你想搜索 IEC 地址。 例子： ” %MW8 \", \" %M* \" 使用命令 查找符号 → 输出交叉引用 ，当在编辑器中选择了已声明符号的名称或光标在名称中时。如果在设备树或 POU 池中选择了对象，也可以进行搜索。 当在编辑器中选择了声明符号的名称或光标在名称中时自动 如果在设备树或 POU 池中选择了对象，也可以进行自动搜索。 要求： CODESYS -选项 更改选择时自动更新交叉引用 被激活；类别 智能编码 . 以下条目有效： 变量名，简单的或限定的 例子： ” iVar \", \" PLC_PRG.iVar \" 积木名称 例子： ” PLC_PRG \", \" myFB \" 被测物名称 例子： ” mySTRUCT \" 与通配符“*”（任何字符）或“?”（正好一个字符）组合的字符串 例子： ” iVar *“ 问候 iVar1 , iVar_glob2 , iVar45 等等。 \" iVar? “ 问候 iVar1 , iVar2 , iVarX 等等，但不是 iVar_glob2 , iVar45 等等。 \" %<IEC-Adresse> “： CODESYS 查找分配给该地址的变量并直接访问内存。 例子： ” %QB0 \", %Q0 := 2 打开输入帮助以选择符号 执行搜索 定义要在其中搜索字符串的列 输入框 在选定列中搜索的字符串 位置标记为黄色。没有此字符串的交叉引用被隐藏。 显示先前交叉引用的源位置 , 切换 + F4 显示下一个交叉引用的源位置 , F4 将结果限制在当前声明范围内 当为一个符号找到多个声明时可用 将显示限制为您刚刚在列表中选择的声明 显示所选交叉引用的源位置 焦点跳转到使用符号的位置。 打印交叉引用列表 出现设置打印作业的标准对话框。 找到的交叉引用会显示以下信息： 象征 符号（变量、POU、DUT）的位置根据其声明进行分组。声明点形成根节点，项目中的使用点在下方缩进显示。显示符号在使用时的确切表达。 示例：项目中是否存在全局变量 i 和 POU 中的本地声明变量 i ，然后在对交叉引用进行文本搜索后，两个根节点条目出现在列表中，在它们下方是使用变量的位置 i . 积木 设备名称，DUT 名称；还有，例如，任务配置中的块调用情况下的任务名称 多变的 纯变量名 例子： iVar 使用权 在使用点访问变量的类型： 宣言 \/ 读 \/ 来写 \/ 称呼 指针的特殊情况 一种任务 p := ADR(var1) 会在寻找的时候 var1 作为 Schreiben | Adresse 显示。原因：可能的写访问权限 p 正在找 var1 不显示。也可以通过指针变量进行写访问。 类型 变量的数据类型 地址 IEC 地址（如果分配给变量） 例子： ” AT %QB0 \" 位置 使用点在受影响 POU 的编辑器中的位置，例如行号、网络号、声明部分或实现部分 例子： ” Zeile 1, Spalte 1 (Impl) \" 目的 POU 名称 + 方括号中使用点的完整路径（如果在视图中） 设备 位于 例子： ” PLC_PRG [Device:Plc Logic:Application] \" 评论 如果变量声明中存在，请注释 搜索返回项目中以及附加的未编译库中的所有匹配项。 " }, 
{ "title" : "交叉引用列表上下文菜单中的命令 ", 
"url" : "_cds_cmd_view_cross_reference_list.html#UUID-623fb12f-e68b-767c-3d16-234d22da3a6e_id_aecb6e1644a20ddec0a8640e0091d2ef_id_9e849137def5910dc0a8640e00806466", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：交叉引用列表 \/ 交叉引用列表上下文菜单中的命令 ", 
"snippet" : "显示源位置 ：打开相关块并标记使用位置：根条目的声明，下级子条目的相应使用位置。或者，您可以双击一行。 将结果限制为选定的声明 ：在找到多个声明的情况下，将结果的显示限制为选定的符号声明 展开一切 ：所有单个位置都显示在列表中。 减少一切 : 只有所有出现的根节点出现在列表中。 有关更多信息，请参阅： 使用交叉引用列表查找使用地点...", 
"body" : "显示源位置 ：打开相关块并标记使用位置：根条目的声明，下级子条目的相应使用位置。或者，您可以双击一行。 将结果限制为选定的声明 ：在找到多个声明的情况下，将结果的显示限制为选定的符号声明 展开一切 ：所有单个位置都显示在列表中。 减少一切 : 只有所有出现的根节点出现在列表中。 有关更多信息，请参阅： 使用交叉引用列表查找使用地点" }, 
{ "title" : "命令：在经典视图中输出交叉引用 ", 
"url" : "_cds_cmd_browse_cross_references_classic_view.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：在经典视图中输出交叉引用 ", 
"snippet" : "在经典视图中输出交叉引用 象征： 功能 : 命令打开视图 经典交叉引用列表 . 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 代码导航 粘贴到菜单中。 视图对应视图 交叉引用列表 前 CODESYS V3.5 SP6。...", 
"body" : "在经典视图中输出交叉引用 象征： 功能 : 命令打开视图 经典交叉引用列表 . 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 代码导航 粘贴到菜单中。 视图对应视图 交叉引用列表 前 CODESYS V3.5 SP6。 " }, 
{ "title" : "命令：调用堆栈 ", 
"url" : "_cds_cmd_call_stack.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：调用堆栈 ", 
"snippet" : "调用栈 象征： 功能 : 命令打开视图 调用栈 . 称呼 ： 菜单 观点 当您要单步执行程序时，此视图非常有用。它以完整的调用路径显示当前到达的位置。 应用 控制刚刚到达的程序块的活动应用程序的名称 任务 控制刚刚到达的程序块的任务名称 POU 程序执行所在的程序块名称 列表中的第一行描述了当前的执行位置。它用黄色箭头标记。如果这个位置在一个被另一个调用的 POU 中，第二行描述调用的位置。如果调用者又被另一个构建块调用，则此调用位置在第三行中描述，依此类推。 位置 程序执行所在的程序模块内的位置 文本编辑器中的行号和列号 图形编辑器中的网络或元素编号 实例路径 程序执行所在的实例 当您不使用...", 
"body" : "调用栈 象征： 功能 : 命令打开视图 调用栈 . 称呼 ： 菜单 观点 当您要单步执行程序时，此视图非常有用。它以完整的调用路径显示当前到达的位置。 应用 控制刚刚到达的程序块的活动应用程序的名称 任务 控制刚刚到达的程序块的任务名称 POU 程序执行所在的程序块名称 列表中的第一行描述了当前的执行位置。它用黄色箭头标记。如果这个位置在一个被另一个调用的 POU 中，第二行描述调用的位置。如果调用者又被另一个构建块调用，则此调用位置在第三行中描述，依此类推。 位置 程序执行所在的程序模块内的位置 文本编辑器中的行号和列号 图形编辑器中的网络或元素编号 实例路径 程序执行所在的实例 当您不使用任何调试功能时，调用堆栈也可在离线模式和正常在线模式下使用。在这种情况下，它包含在一个步骤中显示的最后一个位置，但以“灰色”字体显示。 风景 调用树 提供对比 调用栈 随时调用块的信息。 有关更多信息，请参阅： 调用树 和 使用断点" }, 
{ "title" : "命令：调用树 ", 
"url" : "_cds_cmd_view_call_tree.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：调用树 ", 
"snippet" : "调用树 象征： 功能 : 命令打开视图 调用树 . 称呼 ： 菜单 观点 视图中可调用构建块的上下文菜单 设备 或者 POU...", 
"body" : "调用树 象征： 功能 : 命令打开视图 调用树 . 称呼 ： 菜单 观点 视图中可调用构建块的上下文菜单 设备 或者 POU " }, 
{ "title" : "查看：调用树 ", 
"url" : "_cds_cmd_view_call_tree.html#UUID-8ef23822-0953-bda0-f712-59bcfbcff6c2_id_e97c4a78798cce68c0a8646329524733_id_1d4c07637a2363d1c0a86463011a235d", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：调用树 \/ 查看：调用树 ", 
"snippet" : "在编译（翻译）应用程序之前，调用树始终可用。它是调用者和您明确指定的构建块的调用的静态表示。因此，树总是包含 2 个根节点，在这些根节点下，相应的调用序列可以被视为连续缩进的条目。在此树视图中可以快速识别递归调用。 块 (2) 的调用树 (1) 示例 PLC_PRG ： 节点（3）： <POU 名称> 被调用 节点（4）： <POU 名称> 调用 积木名称 程序块的名称 可以手动完成，也可以通过从另一个视图拖动或使用按钮来完成 被输入 选择列表包含最后输入的块名称。 工具栏和键盘控件 ： 寻找积木 CODESYS 搜索在 积木名称 指定的构建块并表示其调用者及其调用。 ： 从输入帮助中获取块 ...", 
"body" : "在编译（翻译）应用程序之前，调用树始终可用。它是调用者和您明确指定的构建块的调用的静态表示。因此，树总是包含 2 个根节点，在这些根节点下，相应的调用序列可以被视为连续缩进的条目。在此树视图中可以快速识别递归调用。 块 (2) 的调用树 (1) 示例 PLC_PRG ： 节点（3）： <POU 名称> 被调用 节点（4）： <POU 名称> 调用 积木名称 程序块的名称 可以手动完成，也可以通过从另一个视图拖动或使用按钮来完成 被输入 选择列表包含最后输入的块名称。 工具栏和键盘控件 ： 寻找积木 CODESYS 搜索在 积木名称 指定的构建块并表示其调用者及其调用。 ： 从输入帮助中获取块 对话 输入帮助 出现选择块调用或实例调用。选择后调用树会自动更新。 ： 显示所选块的源代码位置 CODESYS 跳转到程序源代码中块的使用点。 F4 ： 显示下一个构建块的源代码位置 切换 + F4 ： 显示上一个构建块的源代码位置 调用树中的选择会跳转到调用结构中的下一个或上一个块。同时，相关的源代码位置在各自的编辑器中打开。 注意：双击调用树中的条目也会打开相关的源代码位置。 调用树的表示 象征 <块名称> 被调用 ：该块的调用顺序出现在该节点下。此树结构中的最低条目显示调用的开始。 <block name> 调用 ：来自该块的调用出现在该节点下。此树结构中的最低条目显示调用链的末端。 位置 对于调用树中的根节点：声明的行号（ 声明 ) 块 对于根节点下的调用者或调用：取决于其所在位置的实现语言、行号、列号、网络号 当前在树中选择的条目的上下文菜单 减少一切 除了两个根节点外，调用树中展开的条目被折叠。 显示源代码位置 CODESYS 跳转到程序源代码中块的使用点。 设置为新的根节点 在调用树中选择的条目出现在 积木名称 .树会针对新的根节点自动调整。 与静态相反 调用树 ，它随时提供块的调用信息，是视图 调用栈 旨在在程序的逐步处理过程中提供即时信息。这 调用栈 始终显示刚到达位置的完整调用路径。 有关更多信息，请参阅： 调用栈" }, 
{ "title" : "命令：内存视图 ", 
"url" : "_cds_cmd_memory.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：内存视图 ", 
"snippet" : "内存视图 象征： 功能 ： 在 CODESYS V3.5版本早于SP11的命令打开视图 贮存 . 称呼 ： 菜单 观点 从 SP11 开始，该命令将显示您需要软件包才能使用内存视图的消息 CODESYS Memory Tools 需要安装，在 CODESYS 店铺。安装后可以查看 贮存 关于命令 视图 → 内存视图 打开。...", 
"body" : "内存视图 象征： 功能 ： 在 CODESYS V3.5版本早于SP11的命令打开视图 贮存 . 称呼 ： 菜单 观点 从 SP11 开始，该命令将显示您需要软件包才能使用内存视图的消息 CODESYS Memory Tools 需要安装，在 CODESYS 店铺。安装后可以查看 贮存 关于命令 视图 → 内存视图 打开。 " }, 
{ "title" : "命令：安全屏幕 ", 
"url" : "_cds_cmd_cyber_screen.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：安全屏幕 ", 
"snippet" : "安全屏幕 象征： 功能 : 命令打开视图 安全屏幕 . 称呼 ： 菜单 观点 图标 或者 在状态栏中 如果为数字签名指定了有效证书，则图标为蓝色。如果只为加密通信指定了一个客户端证书，则图标将保持灰色，因为客户端证书不会提高用户的安全性。 看来，以下安全特性 CODESYS 配置并显示： 用户的个人证书 加密通信 IEC项目的加密和签名 下载、在线更改和启动应用程序的加密和签名 安全级别 如果 安全屏幕 再次打开和关闭时，当前设置将应用于用户选项，即使没有进行任何活动更改。 如果附加产品 CODESYS Security Agent 安装，提供视图 安全屏幕 另一个标签： 设备 .它允许配置证...", 
"body" : "安全屏幕 象征： 功能 : 命令打开视图 安全屏幕 . 称呼 ： 菜单 观点 图标 或者 在状态栏中 如果为数字签名指定了有效证书，则图标为蓝色。如果只为加密通信指定了一个客户端证书，则图标将保持灰色，因为客户端证书不会提高用户的安全性。 看来，以下安全特性 CODESYS 配置并显示： 用户的个人证书 加密通信 IEC项目的加密和签名 下载、在线更改和启动应用程序的加密和签名 安全级别 如果 安全屏幕 再次打开和关闭时，当前设置将应用于用户选项，即使没有进行任何活动更改。 如果附加产品 CODESYS Security Agent 安装，提供视图 安全屏幕 另一个标签： 设备 .它允许配置证书以与控制器进行加密通信。 标签：设备 此选项卡仅在安装后才可用 CODESYS Security Agent 附加组件。有关更多信息，请参阅： 安全屏幕：设备 在 CODESYS Security Agent 救命。 " }, 
{ "title" : "标签：用户 ", 
"url" : "_cds_cmd_cyber_screen.html#UUID-b01565e9-8d26-9511-6f6b-c6ddb491ec4a_id_f1b6b5ab8b9c634c0a8646304f94292_id_6b26b715c2e29ee4c0a86463458183bc", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：安全屏幕 \/ 标签：用户 ", 
"snippet" : "加密通信所需的证书和用户的数字签名在此选项卡中配置。您只能在此处指定带有私钥的证书。用户配置文件在用户选项中保存为 XML。 用户资料和证书选择 默认情况下，输入 Windows 登录名作为用户配置文件。 包含现有用户配置文件的选择列表 ：打开对话框 用户资料 在此处输入新用户配置文件的名称。 ：删除选定的用户配置文件 然后，该用户配置文件将不再显示在选择列表中。 电子签名 ：打开对话框 证书选择 用于选择数字签名的证书 可以选择 1 个证书。证书必须带有私钥。 ：删除显示的证书。 可以选择 1 个证书。证书必须带有私钥。 项目文件解密 ：打开对话框 证书选择 用于选择用于解密项目文件的证书 ...", 
"body" : "加密通信所需的证书和用户的数字签名在此选项卡中配置。您只能在此处指定带有私钥的证书。用户配置文件在用户选项中保存为 XML。 用户资料和证书选择 默认情况下，输入 Windows 登录名作为用户配置文件。 包含现有用户配置文件的选择列表 ：打开对话框 用户资料 在此处输入新用户配置文件的名称。 ：删除选定的用户配置文件 然后，该用户配置文件将不再显示在选择列表中。 电子签名 ：打开对话框 证书选择 用于选择数字签名的证书 可以选择 1 个证书。证书必须带有私钥。 ：删除显示的证书。 可以选择 1 个证书。证书必须带有私钥。 项目文件解密 ：打开对话框 证书选择 用于选择用于解密项目文件的证书 可以选择 1 个证书。证书必须带有私钥。 ：删除显示的证书 有关更多信息，请参阅： 证书选择安全级别 启用使用证书以实现高级安全性 强制加密通信 ：如果用户与控件通信，则使用控件的服务器证书进行加密连接建立。然后加密所有通信。 强制项目文件加密 ：用户的所有项目文件都使用证书加密。保存时，项目使用项目设置中的 （对话框 项目设置→安全 ) 指定的证书加密。所选证书将出现在选项卡中 项目 在 项目文件加密 显示。 要打开这个项目，用于加密的带有私钥的证书必须在 项目文件解密 被注册。 强制签署项目文件 ：用户的所有项目文件都使用证书签名。在 电子签名 必须输入带有私钥的证书。 保存项目时，会在项目目录中创建签名文件 <project name>.project.p7s 生成包含签名。 对下载、在线更改和启动应用程序实施加密 ：加载到控制器上的数据必须使用控制器证书加密。 此证书直接显示在应用程序的属性对话框中，选项卡 加密 设置或在选项卡中 项目 ， 区域 启动应用程序、下载和在线更改的加密 . 控制证书位于文件夹中的本地 Windows 证书存储中 PLC证书 .如果您的控制器证书未包含在该文件夹中，则必须首先从控制器加载它们并安装到该文件夹中。这方面的说明可以在“ 控制器证书 ”。 有关更多信息，请参阅： 保护应用程序强制签署下载、在线更改和启动应用程序 ：在线代码，即下载、在线更改和启动应用程序必须使用带有个人密钥的证书进行签名。选择该地区的证书 电子签名 出去。 有关更多信息，请参阅： 保护应用程序强制对已翻译的库进行签名 ： 命令 文件 → 将项目另存为翻译库 创建一个签名库 <library name>.compiled-library-v3 . 要求 存在支持代码签名的私钥证书。 在项目信息中有一个库兼容性> = CODESYS V3 SP15 放。 强制签名库的时间戳 ： 在该领域 时间戳服务器 必须输入生成时间戳的时间戳服务器的 URL。 例子： timestamp.comodoca.com\/rfc3161 有关更多信息，请参阅： 将项目另存为编译库" }, 
{ "title" : "标签：项目 ", 
"url" : "_cds_cmd_cyber_screen.html#UUID-b01565e9-8d26-9511-6f6b-c6ddb491ec4a_id_f1b6b5ab8b9c634c0a8646304f94292_id_eb95a26f13bac6bec0a864635014e693", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：安全屏幕 \/ 标签：项目 ", 
"snippet" : "所有项目特定的设置都在此选项卡中配置。这些项目仅在加载主项目时才处于活动状态。 项目文件加密 技术 ：打开对话框 项目设置→安全 如果您在对话框中更改项目设置 加密 选择然后 证书 激活，您可以通过 选择合适的证书。更多细节可以在对话框的描述中找到 项目设置 - 安全 . 来自共享此项目的用户的证书 列出加密项目文件的证书的区域 启动应用程序、下载和在线更改的加密 控制器的应用列表 双击列表中的应用程序打开对话框 属性 → 加密 .根据设置 安全级别 在选项卡上 用户 的 安全屏幕 打开的属性对话框中提供以下字段： 标签 加密 有活动区域 证书 标签 加密 带选择列表 加密技术 在对话中 属性...", 
"body" : "所有项目特定的设置都在此选项卡中配置。这些项目仅在加载主项目时才处于活动状态。 项目文件加密 技术 ：打开对话框 项目设置→安全 如果您在对话框中更改项目设置 加密 选择然后 证书 激活，您可以通过 选择合适的证书。更多细节可以在对话框的描述中找到 项目设置 - 安全 . 来自共享此项目的用户的证书 列出加密项目文件的证书的区域 启动应用程序、下载和在线更改的加密 控制器的应用列表 双击列表中的应用程序打开对话框 属性 → 加密 .根据设置 安全级别 在选项卡上 用户 的 安全屏幕 打开的属性对话框中提供以下字段： 标签 加密 有活动区域 证书 标签 加密 带选择列表 加密技术 在对话中 属性 → 加密 使用按钮选择 控制证书 启动应用程序、下载和在线更改的加密 出去。更多细节可以在对话框的描述中找到 属性 - 加密 . 控制证书位于文件夹中的本地 Windows 证书存储中 控制器证书 .如果您的控制器证书未包含在该文件夹中，则必须首先从控制器加载它们并安装到该文件夹中。相关说明可在章节中找到 保护和保存项目 - 使用证书加密 . 有关更多信息，请参阅： 保护应用程序有关更多信息，请参阅： 安全开发\/保护源代码 " }, 
{ "title" : "命令：设置在线更改的内存保留 ", 
"url" : "_cds_cmd_memory_reserve_online_change.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：设置在线更改的内存保留 ", 
"snippet" : "为在线更改设置内存保留 功能 : 命令打开视图 在线更改的内存保留 . 称呼 ： 菜单 观点 在视图中，为功能块配置了用于在线更改的内存预留。 搜索应用程序 在选定的应用程序中搜索功能块并将其显示在区域中 功能块 在 更新区域 功能块 , 应用程序重新编译后 更新区域 功能块 在线更改后 带有已打开项目的应用程序的选择列表 选择要在此视图中显示和\/或编辑其功能块的应用程序 功能块 全部 显示所选应用程序的所有功能块。 水池 视图的所有功能块 POU 显示在应用程序中引用的内容。 没有内存储备 显示所有具有 0 字节内存保留的功能块。 <内存保留> 字节 显示所有功能块的字节数 内存储备 显示定...", 
"body" : "为在线更改设置内存保留 功能 : 命令打开视图 在线更改的内存保留 . 称呼 ： 菜单 观点 在视图中，为功能块配置了用于在线更改的内存预留。 搜索应用程序 在选定的应用程序中搜索功能块并将其显示在区域中 功能块 在 更新区域 功能块 , 应用程序重新编译后 更新区域 功能块 在线更改后 带有已打开项目的应用程序的选择列表 选择要在此视图中显示和\/或编辑其功能块的应用程序 功能块 全部 显示所选应用程序的所有功能块。 水池 视图的所有功能块 POU 显示在应用程序中引用的内容。 没有内存储备 显示所有具有 0 字节内存保留的功能块。 <内存保留> 字节 显示所有功能块的字节数 内存储备 显示定义 功能块信息 选择用于配置内存保留的块时，也可以进行多项选择。 功能模块 功能模块名称 尺寸 功能块的大小 功能块实例的大小 以字节指定 实例数 项目中功能块的实例数 内存储备 显示每个功能块实例的内存保留 所有实例的额外存储 产品关闭 实例数 和 内存储备 剩余的内存储备 仍可用作保留的字节数 想法 内存保留（以字节为单位） 所选功能块的内存保留输入字段 以字节指定 要求：应用程序尚未在控件上或您已单击按钮 编辑 在那个地区 允许编辑 允许更改内存保留。 应用于选择 这 内存保留（以字节为单位） 分配给功能模块和表格列 内存储备 将会被更新。 在多选的情况下，输入的值被分配给每个功能块。 在柱子周围 尺寸 , 实例数 , 所有实例的额外存储 和 剩余存储量 要更新，首先选择命令 创建 → 翻译 然后点击按钮 搜索应用程序 . 允许编辑 编辑 输入字段 内存保留（以字节为单位） 变得可编辑。 这个按钮将在 可编辑 改变了。 信息 FB数 应用程序中的功能块总数 所有实例的额外存储 应用程序的所有功能块实例的内存保留总和 以字节指定 有关更多信息，请参阅： 为在线更改配置内存保留" }, 
{ "title" : "命令：主页 ", 
"url" : "_cds_cmd_start_page.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：主页 ", 
"snippet" : "主页 象征： 功能 : 命令打开视图 主页 . 称呼 ： 菜单 观点 该视图包含一些基本命令和最近打开的项目列表。此外，您将 CODESYS 主页显示。 如果您使用代理访问 Internet，您可以使用 CODESYS 类别中的选项 代理设置 订金。然后每次调用主页时都不会提示您输入条目。 通过将鼠标悬停在最近打开的项目列表上，您可以从列表中删除或固定单个项目。固定的项目会保留在此列表中，直到您取消固定它们。 你可以在 CODESYS 类别中的选项 加载和保存 配置此起始页是否应在您使用时自动出现 CODESYS 开始。...", 
"body" : "主页 象征： 功能 : 命令打开视图 主页 . 称呼 ： 菜单 观点 该视图包含一些基本命令和最近打开的项目列表。此外，您将 CODESYS 主页显示。 如果您使用代理访问 Internet，您可以使用 CODESYS 类别中的选项 代理设置 订金。然后每次调用主页时都不会提示您输入条目。 通过将鼠标悬停在最近打开的项目列表上，您可以从列表中删除或固定单个项目。固定的项目会保留在此列表中，直到您取消固定它们。 你可以在 CODESYS 类别中的选项 加载和保存 配置此起始页是否应在您使用时自动出现 CODESYS 开始。 " }, 
{ "title" : "命令：全屏 ", 
"url" : "_cds_cmd_full_screen.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：全屏 ", 
"snippet" : "全屏 象征： 键盘快捷键： 控制 + 切换 + F12 功能 ：该命令切换显示 CODESYS 进入全屏模式。 称呼 ： 菜单 观点 激活命令后，主窗口 CODESYS 以全屏模式显示的用户界面。您可以通过禁用命令或键盘快捷键返回到之前设置的大小 控制 + 切换 + F12 启动。...", 
"body" : "全屏 象征： 键盘快捷键： 控制 + 切换 + F12 功能 ：该命令切换显示 CODESYS 进入全屏模式。 称呼 ： 菜单 观点 激活命令后，主窗口 CODESYS 以全屏模式显示的用户界面。您可以通过禁用命令或键盘快捷键返回到之前设置的大小 控制 + 切换 + F12 启动。 " }, 
{ "title" : "命令：属性 ", 
"url" : "_cds_cmd_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 观点 \/ 命令：属性 ", 
"snippet" : "特性 象征： 功能 ：该命令打开 特性 POU 或设备树中当前选定对象的名称。 称呼 ： 菜单 观点...", 
"body" : "特性 象征： 功能 ：该命令打开 特性 POU 或设备树中当前选定对象的名称。 称呼 ： 菜单 观点 " }, 
{ "title" : "项目 ", 
"url" : "_cds_f_commands_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：添加对象 ", 
"url" : "_cds_cmd_add_object.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：添加对象 ", 
"snippet" : "添加对象 象征： 功能 ：该命令打开一个子菜单，其中的对象取决于视图中的当前位置 设备 或者 POU 包含所有可以插入的对象。 称呼 ： 菜单 项目 , 视图中的上下文菜单 设备 或者 POU 要求 ： 什么时候 CODESYS 要在设备树中插入对象，请选择一个现有对象，在该对象下可以创建新的缩进对象。什么时候 CODESYS 要在 POUs 树中插入对象，请将焦点设置到 POUs 树中的任何空闲点 CODESYS 窗户。 有关更多信息，请参阅： 添加对象...", 
"body" : "添加对象 象征： 功能 ：该命令打开一个子菜单，其中的对象取决于视图中的当前位置 设备 或者 POU 包含所有可以插入的对象。 称呼 ： 菜单 项目 , 视图中的上下文菜单 设备 或者 POU 要求 ： 什么时候 CODESYS 要在设备树中插入对象，请选择一个现有对象，在该对象下可以创建新的缩进对象。什么时候 CODESYS 要在 POUs 树中插入对象，请将焦点设置到 POUs 树中的任何空闲点 CODESYS 窗户。 有关更多信息，请参阅： 添加对象" }, 
{ "title" : "命令：添加文件夹 ", 
"url" : "_cds_cmd_add_folder.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：添加文件夹 ", 
"snippet" : "新增文件夹 象征： 功能 ：该命令打开一个对话框，用于在设备或 POU 视图中定义新文件夹。 称呼 ： 菜单 项目 , 设备或 POU 视图中的上下文菜单 您无法使用自己创建的文件夹来组织设备节点和设备对象的排列。 该命令将文件夹插入到树中当前选定对象的下方。如果未选择任何对象，则添加 CODESYS 位于根节点下方的树顶部的文件夹。...", 
"body" : "新增文件夹 象征： 功能 ：该命令打开一个对话框，用于在设备或 POU 视图中定义新文件夹。 称呼 ： 菜单 项目 , 设备或 POU 视图中的上下文菜单 您无法使用自己创建的文件夹来组织设备节点和设备对象的排列。 该命令将文件夹插入到树中当前选定对象的下方。如果未选择任何对象，则添加 CODESYS 位于根节点下方的树顶部的文件夹。 " }, 
{ "title" : "命令：附加设备 ", 
"url" : "_cds_cmd_add_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：附加设备 ", 
"snippet" : "连接设备 功能 ：命令打开对话框 连接设备 用于选择要插入到当前选定对象下方的设备树中的设备对象。 称呼 : 设备树中设备对象的上下文菜单 要求 ：在设备树中选择了一个对象，可以在其下方插入一个设备对象。...", 
"body" : "连接设备 功能 ：命令打开对话框 连接设备 用于选择要插入到当前选定对象下方的设备树中的设备对象。 称呼 : 设备树中设备对象的上下文菜单 要求 ：在设备树中选择了一个对象，可以在其下方插入一个设备对象。 " }, 
{ "title" : "对话框：附加设备 ", 
"url" : "_cds_cmd_add_device.html#UUID-eb0bed63-ea86-053f-3973-94136b2ff14c_id_bd4a3d10fecdecc0a8640e002b80ee_id_b68e4f085aa0f27fc0a8640e01039101", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：附加设备 \/ 对话框：附加设备 ", 
"snippet" : "功能 ：根据设备树中当前选定的位置，对话框提供了可以在此插入的设备的选择。它还包含上下文菜单中也可用的命令： 附加设备 , 插入装置 , 插入设备 , 更新设备 . 要求 ：设备安装在本地系统的设备存储库中。 如果您打开了对话框，它总是显示与设备树中当前选择的对象相匹配的选择，直到您单击按钮 得出结论 点击。 姓 设备应显示在设备树中的名称 必须是有效的 IEC 标识符 行动 连接设备 CODESYS 在设备树中的选定对象下方插入缩进的选定设备。 插入装置 CODESYS 将选定设备插入到设备树中与其下方选定对象相同的级别。 插入设备 CODESYS 将所选设备插入所选插槽。如果插槽已被占用，...", 
"body" : "功能 ：根据设备树中当前选定的位置，对话框提供了可以在此插入的设备的选择。它还包含上下文菜单中也可用的命令： 附加设备 , 插入装置 , 插入设备 , 更新设备 . 要求 ：设备安装在本地系统的设备存储库中。 如果您打开了对话框，它总是显示与设备树中当前选择的对象相匹配的选择，直到您单击按钮 得出结论 点击。 姓 设备应显示在设备树中的名称 必须是有效的 IEC 标识符 行动 连接设备 CODESYS 在设备树中的选定对象下方插入缩进的选定设备。 插入装置 CODESYS 将选定设备插入到设备树中与其下方选定对象相同的级别。 插入设备 CODESYS 将所选设备插入所选插槽。如果插槽已被占用，则现有模块将被新模块替换。 更新设备 CODESYS 用选中的设备替换设备树中选中的设备。 注意：根据设备，在设备编辑器中已经进行的配置可以被默认值覆盖！ 用于在所有设备中进行全文搜索的字符串 单击此字段使其可编辑。如果输入任何字符串，则只有包含该字符串的设备会显示在下方窗口中。匹配的字符串在这些设备上以黄色突出显示。 制造商 显示可用设备的制造商的选择列表 按类别分组 ：可用设备（最新版本）按类别排序。类别在设备描述文件中定义。 ：可用设备显示为扁平并按字母顺序排序。 显示所有版本（仅供专家使用） ：所有其他可用版本的设备也可供选择。 ：每台设备只有最新版本可供选择。 显示过时的版本 ：设备的过时版本也可供选择。例如，通过更新插件来创建过时的版本。 ：不显示过时的设备版本。 显示通过设备描述文件提供的信息：设备名称、制造商、类别、版本、订单号和简短描述、设备特定位图。 有关更多信息，请参阅： 插入装置 和 插入设备" }, 
{ "title" : "命令：插入设备 ", 
"url" : "_cds_cmd_plug_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：插入设备 ", 
"snippet" : "插入设备 功能 ：命令像命令一样打开 连接设备 对话 连接设备 用于选择要插入到设备树中当前选定插槽的设备对象。 称呼 : 设备树中设备对象插槽的上下文菜单 要求 ：设备对象的槽位在设备树中被选中。 空槽由 图标指示 并标记条目 \"<Empty> (<Empty>)\" 。一个占用的插槽被赋予符号 和设备的名称。 如果插槽被占用，则该命令将现有模块替换为新模块。...", 
"body" : "插入设备 功能 ：命令像命令一样打开 连接设备 对话 连接设备 用于选择要插入到设备树中当前选定插槽的设备对象。 称呼 : 设备树中设备对象插槽的上下文菜单 要求 ：设备对象的槽位在设备树中被选中。 空槽由 图标指示 并标记条目 \"<Empty> (<Empty>)\" 。一个占用的插槽被赋予符号 和设备的名称。 如果插槽被占用，则该命令将现有模块替换为新模块。 " }, 
{ "title" : "命令：查找设备 ", 
"url" : "_cds_cmd_scan_for_devices.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：查找设备 ", 
"snippet" : "搜索设备 功能 ：该命令建立与硬件的临时连接并发现网络上的设备。然后，您可以采用在项目的设备树中找到的设备。 称呼 ： 菜单 项目 , 设备树中设备对象的上下文菜单 要求 ：与控制设备的通信设置正确。网关和 PLC 已启动。该设备支持扫描功能。 以下设备提供扫描功能：EtherCAT Master、EtherNet\/IP Scanner (IEC)、Sercos Master、CANopen Manager、CANopen Manager SIL2、Profinet Controller 和 Profibus DP Master。 如果扫描功能在 PLC 中牢固实施，您可以立即执行设备扫描。如...", 
"body" : "搜索设备 功能 ：该命令建立与硬件的临时连接并发现网络上的设备。然后，您可以采用在项目的设备树中找到的设备。 称呼 ： 菜单 项目 , 设备树中设备对象的上下文菜单 要求 ：与控制设备的通信设置正确。网关和 PLC 已启动。该设备支持扫描功能。 以下设备提供扫描功能：EtherCAT Master、EtherNet\/IP Scanner (IEC)、Sercos Master、CANopen Manager、CANopen Manager SIL2、Profinet Controller 和 Profibus DP Master。 如果扫描功能在 PLC 中牢固实施，您可以立即执行设备扫描。如果扫描功能是在库中实现的，您必须登录一次才能将库加载到控制器上。 该命令引用设备树中选择的主控制器。例如，可以选择已插入的 PROFINET IO 控制器，并且可以使用命令确定分配给它的 I\/O 设备和 I\/O 模块。 运行扫描后，将出现对话框 搜索设备 与找到的设备。 扫描对话框因设备类型而异。请参阅相应设备编辑器的帮助页面。 找到的设备 设备名称、设备类型、地址、站名等 找到的设备信息，取决于网络类型 如果您更改已找到设备列表中的值，该值将以斜体显示。这表明编辑器中的新值在 CODESYS 已更改，但尚未在设备中。一旦您将值加载到设备中，它就会再次正常显示。 显示项目和找到的设备之间差异的值显示为橙色。 如果找到的设备有多个设备描述，则名称以粗体显示。对于不同的现场总线，选择合适的设备描述的方法不同。您可以在相关的现场总线章节中找到这方面的详细信息。 如果未找到设备描述，则会显示消息“注意！在存储库中找不到该设备”。根据总线系统，会显示制造商编号和产品编号等附加信息。如果没有安装的设备描述，则无法将设备插入到项目中。 显示与项目的差异 ：该表还在对话框中显示了已组态的设备（项目设备树中的设备）。 ：该表显示找到的所有设备。不显示配置的设备。 搜索设备 开始新的搜索 复制到项目 表中选择的设备将添加到项目的设备树中。如果未选择任何内容，则接受找到的所有设备。 如果你有 将所有设备复制到项目中 在设备树中插入设备树中已存在的设备，请注意以下事项： 选项卡上的数据 处理数据 和 <…> I\/O 映射 已经存在的设备可以被新插入设备的数据覆盖。 配置的设备 仅当您选择该选项时，对话框的这一部分才可见 显示与项目的差异 已激活。 找到的设备和配置的设备之间的差异以颜色突出显示。以绿色显示的设备两侧相同。以红色显示的设备仅在找到或配置的设备视图中可用。 如果您在两个视图中都选择了一个设备，则找到的设备将插入到所选配置设备的上方。 如果您在两个视图中都选择了一个设备，则找到的设备将插入到所选配置设备的下方。 如果您在两个视图中都选择了一个设备，则配置的设备将替换为找到的设备。 找到的所有设备都将复制到项目中。 选定的已配置设备将被删除。 有关更多信息，请参阅： 在设备树中映射硬件结构" }, 
{ "title" : "命令：更新设备 ", 
"url" : "_cds_cmd_update_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：更新设备 ", 
"snippet" : "更新设备 功能 ：命令像命令一样打开 附加设备 对话 连接设备 选择设备对象。此对象将插入设备树中，而不是当前选定的对象。 称呼 : 设备树中设备对象的上下文菜单 要求 ：在设备树中选择了一个对象，可以在其下方插入一个设备对象。 您可以使用此命令使用不同版本的设备或不同类型的设备，而不是以前的设备。 设备树中使用的符号设备名称保持不变，如果选择了不同的类型，则后面括号中指定的设备类型会发生变化。因此，如果仅更改设备版本，则对象条目将显示为未更改。 如果设备类型没有改变，缩进在受影响设备条目下方的配置树将被保留。在这种情况下，将保留配置设置。报告设备更新导致的配置不一致 CODESYS 下次编译...", 
"body" : "更新设备 功能 ：命令像命令一样打开 附加设备 对话 连接设备 选择设备对象。此对象将插入设备树中，而不是当前选定的对象。 称呼 : 设备树中设备对象的上下文菜单 要求 ：在设备树中选择了一个对象，可以在其下方插入一个设备对象。 您可以使用此命令使用不同版本的设备或不同类型的设备，而不是以前的设备。 设备树中使用的符号设备名称保持不变，如果选择了不同的类型，则后面括号中指定的设备类型会发生变化。因此，如果仅更改设备版本，则对象条目将显示为未更改。 如果设备类型没有改变，缩进在受影响设备条目下方的配置树将被保留。在这种情况下，将保留配置设置。报告设备更新导致的配置不一致 CODESYS 下次编译应用程序时。这也会影响隐含包含的库 CODESYS 在设备更新期间未相应删除。 有关更多信息，请参阅： 连接设备" }, 
{ "title" : "命令：确认诊断，子树确认诊断 ", 
"url" : "_cds_cmd_acknowledge_diagnosis.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：确认诊断，子树确认诊断 ", 
"snippet" : "确认诊断，确认诊断子树 功能 ：该命令确认诊断消息。 称呼 : 设备树中设备对象的上下文菜单 要求 : 项目上线。 命令 确认诊断 确认单个设备的诊断消息。命令 确认子树的诊断 还确认所有从属设备的诊断消息。未决故障的诊断消息由设备对象上的红色感叹号表示。已解决故障的诊断消息由设备对象上的灰色感叹号表示。 有关更多信息，请参阅： 在线模式下的设备树...", 
"body" : "确认诊断，确认诊断子树 功能 ：该命令确认诊断消息。 称呼 : 设备树中设备对象的上下文菜单 要求 : 项目上线。 命令 确认诊断 确认单个设备的诊断消息。命令 确认子树的诊断 还确认所有从属设备的诊断消息。未决故障的诊断消息由设备对象上的红色感叹号表示。已解决故障的诊断消息由设备对象上的灰色感叹号表示。 有关更多信息，请参阅： 在线模式下的设备树" }, 
{ "title" : "命令：编辑对象 ", 
"url" : "_cds_cmd_edit_object.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：编辑对象 ", 
"snippet" : "编辑对象 功能 ：该命令在其编辑器中打开对象。 称呼 ： 菜单 项目 ， 上下文菜单 要求 : 设备树或视图中的对象 POU 被选中。...", 
"body" : "编辑对象 功能 ：该命令在其编辑器中打开对象。 称呼 ： 菜单 项目 ， 上下文菜单 要求 : 设备树或视图中的对象 POU 被选中。 " }, 
{ "title" : "命令：编辑对象 ", 
"url" : "_cds_cmd_edit_object_with.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：编辑对象 ", 
"snippet" : "编辑对象 功能 ：如果一个对象有多个对象可用，该命令将打开一个对话框以选择所需的编辑器。 如果一个对象只有一个编辑器可用，该命令会在该编辑器中打开该对象。 称呼 ： 菜单 项目 ， 上下文菜单 要求 : 设备树或视图中的对象 POU 被选中。 在里面 CODESYS 在标准安装中，没有可以使用多个编辑器的对象。...", 
"body" : "编辑对象 功能 ：如果一个对象有多个对象可用，该命令将打开一个对话框以选择所需的编辑器。 如果一个对象只有一个编辑器可用，该命令会在该编辑器中打开该对象。 称呼 ： 菜单 项目 ， 上下文菜单 要求 : 设备树或视图中的对象 POU 被选中。 在里面 CODESYS 在标准安装中，没有可以使用多个编辑器的对象。 " }, 
{ "title" : "命令：编辑对象（离线）。 ", 
"url" : "_cds_cmd_edit_object_offline.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：编辑对象（离线）。 ", 
"snippet" : "编辑对象（离线）。 功能 ：该命令在其编辑器中离线打开对象。 称呼 ： 菜单 项目 ， 上下文菜单 要求 ：应用程序处于在线模式。设备树或视图中的对象 POU 被选中。 这意味着您还可以在在线模式下编辑对象。然后使用菜单命令传输更改 在线 → 在线更改 或者 在线 → 加载 在控制器上。...", 
"body" : "编辑对象（离线）。 功能 ：该命令在其编辑器中离线打开对象。 称呼 ： 菜单 项目 ， 上下文菜单 要求 ：应用程序处于在线模式。设备树或视图中的对象 POU 被选中。 这意味着您还可以在在线模式下编辑对象。然后使用菜单命令传输更改 在线 → 在线更改 或者 在线 → 加载 在控制器上。 " }, 
{ "title" : "命令：设置活动应用程序 ", 
"url" : "_cds_cmd_set_active_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：设置活动应用程序 ", 
"snippet" : "设置活动应用程序 功能 ：该命令将选定的应用程序设置为“活动应用程序”。 称呼 ： 菜单 项目 , 对象的上下文菜单 应用 要求 ：该项目至少有2个应用程序。所选应用程序未激活。 在线操作始终只影响活动的应用程序。活动应用程序在设备树中以粗体显示。...", 
"body" : "设置活动应用程序 功能 ：该命令将选定的应用程序设置为“活动应用程序”。 称呼 ： 菜单 项目 , 对象的上下文菜单 应用 要求 ：该项目至少有2个应用程序。所选应用程序未激活。 在线操作始终只影响活动的应用程序。活动应用程序在设备树中以粗体显示。 " }, 
{ "title" : "命令：项目信息 ", 
"url" : "_cds_cmd_project_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：项目信息 ", 
"snippet" : "项目信息 象征： 功能 ：命令打开对话框 项目信息 . 称呼 ： 菜单 项目 第一次在项目中运行命令时 CODESYS 物体 项目信息 在。 有关更多信息，请参阅： 检索和编辑项目信息...", 
"body" : "项目信息 象征： 功能 ：命令打开对话框 项目信息 . 称呼 ： 菜单 项目 第一次在项目中运行命令时 CODESYS 物体 项目信息 在。 有关更多信息，请参阅： 检索和编辑项目信息" }, 
{ "title" : "命令：项目设置 ", 
"url" : "_cds_cmd_project_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：项目设置 ", 
"snippet" : "项目设置 象征： 功能 ：命令打开对话框 项目设置 . 称呼 ： 菜单 项目 或双击对象 项目设置 在视图中 POU 要求 : 项目已打开。 有关更多信息，请参阅： 配置项目设置...", 
"body" : "项目设置 象征： 功能 ：命令打开对话框 项目设置 . 称呼 ： 菜单 项目 或双击对象 项目设置 在视图中 POU 要求 : 项目已打开。 有关更多信息，请参阅： 配置项目设置" }, 
{ "title" : "命令：项目环境 ", 
"url" : "_cds_cmd_project_environment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：项目环境 ", 
"snippet" : "项目环境 功能 ：命令打开对话框 项目环境 . 称呼 ： 菜单 项目 要求 : 项目已打开。 该命令用于检查项目中涉及的软件和文件是否是最新的，并允许对其进行更新。...", 
"body" : "项目环境 功能 ：命令打开对话框 项目环境 . 称呼 ： 菜单 项目 要求 : 项目已打开。 该命令用于检查项目中涉及的软件和文件是否是最新的，并允许对其进行更新。 " }, 
{ "title" : "命令：项目本地化 - 创建本地化模板 ", 
"url" : "_cds_cmd_project_loc_create_localization_template.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：项目本地化 - 创建本地化模板 ", 
"snippet" : "项目本地化 - 创建本地化模板 功能 ：命令打开对话框 创建本地化模板 .在这里，您可以在文件格式的翻译模板中定义项目中的哪些文本信息 pot 是要出口的。 称呼 ： 菜单 项目 → 项目本地化 要求 : 项目已打开。...", 
"body" : "项目本地化 - 创建本地化模板 功能 ：命令打开对话框 创建本地化模板 .在这里，您可以在文件格式的翻译模板中定义项目中的哪些文本信息 pot 是要出口的。 称呼 ： 菜单 项目 → 项目本地化 要求 : 项目已打开。 " }, 
{ "title" : "对话框：创建本地化模板 ", 
"url" : "_cds_cmd_project_loc_create_localization_template.html#UUID-7af442ed-2731-3bea-0dd4-611b4d702b7c_id_bf604acce1e6ac0a8640e00e72f04_id_97aec47ead1fa1b9c0a8640e01caaf0d", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：项目本地化 - 创建本地化模板 \/ 对话框：创建本地化模板 ", 
"snippet" : "该对话框用于选择要包含在本地化模板中的文本信息。 包括以下信息 名字 设备树中的对话框标题、对象名称等文本 标识符 变量标识符 例子： Counter 字符串 例子： 'count' 在声明中 strVar: STRING := 'count'; 评论 编程块中的注释文本 位置信息 选择上面选择的文本类别在项目中的哪些位置应该包含在翻译文件中 位置信息位于翻译部分的第一行。例子： #: D:\\Proj1.project\\Project_Settings:1 msgid \"Projekteinstellungen\" msgstr \"\" 全部 : 列出所有找到的文本位置。 首次亮相 : 项目中首先...", 
"body" : "该对话框用于选择要包含在本地化模板中的文本信息。 包括以下信息 名字 设备树中的对话框标题、对象名称等文本 标识符 变量标识符 例子： Counter 字符串 例子： 'count' 在声明中 strVar: STRING := 'count'; 评论 编程块中的注释文本 位置信息 选择上面选择的文本类别在项目中的哪些位置应该包含在翻译文件中 位置信息位于翻译部分的第一行。例子： #: D:\\Proj1.project\\Project_Settings:1 msgid \"Projekteinstellungen\" msgstr \"\" 全部 : 列出所有找到的文本位置。 首次亮相 : 项目中首先出现要翻译的文本的位置包含在翻译文件中。 没有任何 生产 该按钮打开保存文件的对话框。翻译模板保存在类型为的文本文件中 POT Translation Template (*.pot) 创建的。每一代都会创建一个全新的模板文件。 " }, 
{ "title" : "命令：项目本地化 - 管理本地化 ", 
"url" : "_cds_cmd_project_loc_manage_localizations.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：项目本地化 - 管理本地化 ", 
"snippet" : "项目本地化 - 管理本地化 功能 ：命令打开对话框 管理本地化 .在对话框中，选择所需的本地化语言或项目的原始版本。您也可以在此处下载本地化文件 *.<Sprache>.po 包含在项目中或从项目中删除。 称呼 ： 菜单 项目 → 项目本地化 要求 : 项目已打开。...", 
"body" : "项目本地化 - 管理本地化 功能 ：命令打开对话框 管理本地化 .在对话框中，选择所需的本地化语言或项目的原始版本。您也可以在此处下载本地化文件 *.<Sprache>.po 包含在项目中或从项目中删除。 称呼 ： 菜单 项目 → 项目本地化 要求 : 项目已打开。 " }, 
{ "title" : "对话框：管理本地化 ", 
"url" : "_cds_cmd_project_loc_manage_localizations.html#UUID-81e04e1c-4d12-6b2a-71f2-e34de5e21169_id_e115a730acd0bb1dc0a8640e0057d3f1_id_0580deebc55938f3c0a8640e01d8ca60", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：项目本地化 - 管理本地化 \/ 对话框：管理本地化 ", 
"snippet" : "可用的本地化 项目中存在的本地化文件列表 例子： proj1-de.po proj1-en.po <Originalversion> 原始版本始终可用。该项目只能在原始版本中进行编辑。 添加 该按钮打开对话框以选择另一个 po -来自文件系统的文件。 消除 按钮删除左侧选中的那个 po 项目中的文件。 默认本地化 ：当前选择的本地化成为默认本地化。该条目以粗体显示。 改变本地化 使用按钮切换到当前选择的本地化。 行 该项目以国家语言显示，该语言由在文件下选择的文件提供。如果你 <原版> 如果您选择 ，项目将出现在可编辑的非本地化版本中。...", 
"body" : "可用的本地化 项目中存在的本地化文件列表 例子： proj1-de.po proj1-en.po <Originalversion> 原始版本始终可用。该项目只能在原始版本中进行编辑。 添加 该按钮打开对话框以选择另一个 po -来自文件系统的文件。 消除 按钮删除左侧选中的那个 po 项目中的文件。 默认本地化 ：当前选择的本地化成为默认本地化。该条目以粗体显示。 改变本地化 使用按钮切换到当前选择的本地化。 行 该项目以国家语言显示，该语言由在文件下选择的文件提供。如果你 <原版> 如果您选择 ，项目将出现在可编辑的非本地化版本中。 " }, 
{ "title" : "命令：项目本地化 - 切换本地化 ", 
"url" : "_cds_cmd_project_loc_toggle_localization.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：项目本地化 - 切换本地化 ", 
"snippet" : "项目本地化 - 切换本地化 象征： 功能 ：命令在当前设置的项目本地化和<原始版本>之间切换。 称呼 ： 菜单 项目 → 项目本地化 然后在对话框中按 管理本地化 , 或按钮 在工具栏中 要求 : 项目已打开。项目的默认本地化在对话框中 管理本地化 被定义。...", 
"body" : "项目本地化 - 切换本地化 象征： 功能 ：命令在当前设置的项目本地化和<原始版本>之间切换。 称呼 ： 菜单 项目 → 项目本地化 然后在对话框中按 管理本地化 , 或按钮 在工具栏中 要求 : 项目已打开。项目的默认本地化在对话框中 管理本地化 被定义。 " }, 
{ "title" : "命令：文档 ", 
"url" : "_cds_cmd_document_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：文档 ", 
"snippet" : "文档 象征 ： 功能 ：命令打开对话框 记录项目 ，您可以在其中定义项目文档。项目文档是对要打印其内容的打开项目的对象的选择。 称呼 ： 菜单 项目 对话 记录项目 请选择要打印的对象 项目树视图 在视图中，您可以激活或停用每个对象，从而选择或取消选择它进行打印。 默认情况下，所有对象都被选中。 封面 CODESYS 创建标题为“项目文档”和以下信息的封面： 文件：项目的文件名 日期：创建项目文档的日期 简介： CODESYS 项目简介 目录 CODESYS 为项目文档创建目录。 预览 CODESYS 创建并打开项目文档打印输出的预览。 选择 CODESYS 打开一个选择列表，用于选择项目文档...", 
"body" : "文档 象征 ： 功能 ：命令打开对话框 记录项目 ，您可以在其中定义项目文档。项目文档是对要打印其内容的打开项目的对象的选择。 称呼 ： 菜单 项目 对话 记录项目 请选择要打印的对象 项目树视图 在视图中，您可以激活或停用每个对象，从而选择或取消选择它进行打印。 默认情况下，所有对象都被选中。 封面 CODESYS 创建标题为“项目文档”和以下信息的封面： 文件：项目的文件名 日期：创建项目文档的日期 简介： CODESYS 项目简介 目录 CODESYS 为项目文档创建目录。 预览 CODESYS 创建并打开项目文档打印输出的预览。 选择 CODESYS 打开一个选择列表，用于选择项目文档的所有或单个对象类型。 取消选择 CODESYS 打开一个选择列表，用于选择不应包含在项目文档中的所有或单个对象类型。 行 对话 按 打开。 " }, 
{ "title" : "命令：比较 ", 
"url" : "_cds_cmd_project_compare.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：比较 ", 
"snippet" : "比较 象征： 功能 ：命令打开对话框 项目比较 .在此对话框中，您定义与当前项目进行比较的参考项目。通过选项配置比较过程。当对话框关闭时，比较开始并且结果显示在视图中 项目比较 - 差异 显示。 称呼 ： 项目→比较 要求 : 项目已打开。 有关更多信息，请参阅： 比较项目...", 
"body" : "比较 象征： 功能 ：命令打开对话框 项目比较 .在此对话框中，您定义与当前项目进行比较的参考项目。通过选项配置比较过程。当对话框关闭时，比较开始并且结果显示在视图中 项目比较 - 差异 显示。 称呼 ： 项目→比较 要求 : 项目已打开。 有关更多信息，请参阅： 比较项目" }, 
{ "title" : "对话框：项目比较 ", 
"url" : "_cds_cmd_project_compare.html#UUID-f5ea182a-cfb7-3593-8e76-0cea6ad834e6_id_b4ab0feb656a504c0a8640e0049e575_id_63feca2505a112dcc0a8640e0093f4b0", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：比较 \/ 对话框：项目比较 ", 
"snippet" : "将当前打开的项目与 磁盘上的项目 文件系统中参考项目的路径 源代码数据库中的项目 主办： 源代码控制所在主机的名称 港口： 连接到源代码控制的端口号 地点： 参考项目的路径 要求：项目链接到源代码管理（例如 CODESYS SVN ） 连接的。 比较选项： 忽略空格 ：当前项目与参考项目的偏差（仅基于空格）将被忽略。 忽略评论 : 编程代码中的注释被排除在比较之外。 忽略属性 ：从比较中排除对象属性。 行 启动项目比较并将结果放在视图中 项目比较 - 差异 代表...", 
"body" : "将当前打开的项目与 磁盘上的项目 文件系统中参考项目的路径 源代码数据库中的项目 主办： 源代码控制所在主机的名称 港口： 连接到源代码控制的端口号 地点： 参考项目的路径 要求：项目链接到源代码管理（例如 CODESYS SVN ） 连接的。 比较选项： 忽略空格 ：当前项目与参考项目的偏差（仅基于空格）将被忽略。 忽略评论 : 编程代码中的注释被排除在比较之外。 忽略属性 ：从比较中排除对象属性。 行 启动项目比较并将结果放在视图中 项目比较 - 差异 代表 " }, 
{ "title" : "查看：项目比较 - 差异 ", 
"url" : "_cds_cmd_project_compare.html#UUID-f5ea182a-cfb7-3593-8e76-0cea6ad834e6_id_b4ab0feb656a504c0a8640e0049e575_id_b06064bf995011e79187da3a4d206d74", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：比较 \/ 查看：项目比较 - 差异 ", 
"snippet" : "打开对话框时会出现项目比较视图 项目比较 和 行 拆散。 (1) 当前项目的对象树 (2) 参考项目的对象树 (3) 命令 接管块 ， 命令 单独接管 (4) 比较选项 , 在对话框中配置 项目比较 , 比较统计 : 添加、删除、修改的对象 工具栏 切换到详细比较视图 项目比较 - <对象名称> 差异 对于在树中选择的对象 替代方法：双击对象 选择设备树中发现差异的下一个较低对象 选择设备树中找到差异的下一个上层对象 接管块 选择块（具有所有从属对象和单元的选定对象）用于从参考块传输到当前块。 重复点击 接管块 撤销上次使用的效果。 单独接管 该对象被选择用于从参考对象到当前对象的传输。 要求...", 
"body" : "打开对话框时会出现项目比较视图 项目比较 和 行 拆散。 (1) 当前项目的对象树 (2) 参考项目的对象树 (3) 命令 接管块 ， 命令 单独接管 (4) 比较选项 , 在对话框中配置 项目比较 , 比较统计 : 添加、删除、修改的对象 工具栏 切换到详细比较视图 项目比较 - <对象名称> 差异 对于在树中选择的对象 替代方法：双击对象 选择设备树中发现差异的下一个较低对象 选择设备树中找到差异的下一个上层对象 接管块 选择块（具有所有从属对象和单元的选定对象）用于从参考块传输到当前块。 重复点击 接管块 撤销上次使用的效果。 单独接管 该对象被选择用于从参考对象到当前对象的传输。 要求：在对象树中选择的对象具有不同的属性、访问权限或文件夹分配。 打开对话框 接管 详细查询 用颜色和符号显示差异 对象名称与 对象的子对象是不同的。 黑色字体 对象是相同的。 灰色背景 对象不同。 灰色背景+加粗蓝色字体 该对象仅在参考项目中可用。 灰色背景+粗体绿色字体 该对象仅在打开的项目中可用（不在参考对象中）。 灰底+红字+ 对象具有不同的属性。 灰底+红字+ 对象和引用对象的访问权限不同。 灰色背景+粗体红色字体+ 对象的实现是不同的。 如果双击该行，则会出现对象特定的比较视图。 黄色高亮 对象设置为接受。 黄色高亮+ 将参考对象添加到打开的项目已设置。 黄色高亮+ 删除对象（在打开的项目中）已设置。 黄色高亮+ 已设置接受参考项目的属性。 黄色高亮+红色字体+ 参考项目访问权限的接受被激活。 灰色高亮+粗体红色字体+ 设置参考项目实施验收。 显示在视图的底部 比较选项 对话中的人 项目比较 定义的比较选项 比较统计 当前项目与参考项目相比的插入、删除、更改次数 修改 表示两个项目中存在的对象内的差异。 提示 是否要保存在比较视图中所做的更改？ 出现。 是的 ：项目中带有黄色背景的对象的内容、属性或访问权限已更改。然后它们对应于参考项目的那些。然后项目比较视图完全关闭。 " }, 
{ "title" : "查看：项目比较 - <对象名称> 差异 ", 
"url" : "_cds_cmd_project_compare.html#UUID-f5ea182a-cfb7-3593-8e76-0cea6ad834e6_id_b4ab0feb656a504c0a8640e0049e575_id_0c281e3bff98a2e4c0a8646318863ab4", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：比较 \/ 查看：项目比较 - <对象名称> 差异 ", 
"snippet" : "功能 : 详细比较视图 在项目比较视图中调用 选择一个标记为具有不同内容的对象，因此您需要详细了解其内容，然后单击 . 双击对象 工具栏 切换回项目比较视图 选择代码中发现差异的下一行 选择代码中发现差异的下一行 接管块 2 选择块（具有所有从属行）以将参考块传输到当前项目中。 详细比较视图中的块由当前放置光标的单元和具有相同差异标记的所有相关单元组成。单元是线、网络或元素。相关单元例如是一行的后续行。 重复点击 接管块 撤销上次使用的效果。 单独接管 选择该线以接管当前对象中的参考线。 在默认显示（其中不同的单元（行、网络、元素）以红色显示）和不同的显示之间切换 在默认显示（其中不同的单元（...", 
"body" : "功能 : 详细比较视图 在项目比较视图中调用 选择一个标记为具有不同内容的对象，因此您需要详细了解其内容，然后单击 . 双击对象 工具栏 切换回项目比较视图 选择代码中发现差异的下一行 选择代码中发现差异的下一行 接管块 2 选择块（具有所有从属行）以将参考块传输到当前项目中。 详细比较视图中的块由当前放置光标的单元和具有相同差异标记的所有相关单元组成。单元是线、网络或元素。相关单元例如是一行的后续行。 重复点击 接管块 撤销上次使用的效果。 单独接管 选择该线以接管当前对象中的参考线。 在默认显示（其中不同的单元（行、网络、元素）以红色显示）和不同的显示之间切换 在默认显示（其中不同的单元（行、网络、元素）以红色显示）和不同的显示之间切换 它们以红色突出显示并以相同的高度彼此相对放置 根据具体情况，它们在当前打开的项目或参考项目中显示为已删除或已插入。 注意：根据显示的不同，统计中发现的差异将被计为更改，或计为插入和删除！ 详细比较视图中的第三个视图 该按钮打开或关闭当前和参考视图比较下方的第三个视图（见下图）。第三个视图显示了为解决检测到的差异而采取的行动的结果。受影响的行在行首用黄色条标记。 (1) 第三个对比图 (2) 结果 使用右线 行动 (3) 按钮： 使用右线 使用左边的行（当前项目中的实现）。 使用左侧块（当前项目中块的实现）。 使用右行（参考项目中的实现）。 使用正确的块（参考项目中块的实现）。 只有在不直接比较差异时才可用（ ): 在第三个（结果）视图中，左侧线插入右侧线上方。 只有在不直接比较差异时才可用（ ）： 在第三个（结果）视图中，右线插入左线上方。 用颜色和符号显示差异 黑色字体 对象是相同的。 对象名称与 对象的子对象是不同的。 灰色高亮+粗体蓝色字体 该代码仅存在于参考项目中。 灰色高亮+粗体绿色字体 该代码仅存在于当前项目中（不存在于参考项目中）。 黄色高亮 对象设置为接受。 这 您要提交在差异视图中所做的更改吗？ 对话框提示打开。 是的 ：以黄色突出显示的代码已被项目接受。代码对应参考项目。然后关闭详细视图并显示项目视图。您可以继续进行项目比较。 " }, 
{ "title" : "对话：申请 ", 
"url" : "_cds_cmd_project_compare.html#UUID-f5ea182a-cfb7-3593-8e76-0cea6ad834e6_id_b4ab0feb656a504c0a8640e0049e575_id_2299abfeff98a2e4c0a864630c6c353e", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：比较 \/ 对话：申请 ", 
"snippet" : "应该传输哪些元信息？ 访问权限 : 选择继承的权限 接受组 从参考项目继承访问权限的组 如果一个组存在于两个项目中并且具有不同的访问权限，则该组被接受。 例子： Group_A 未接受的组（项目中缺少） 如果该组不存在于任一项目中，则不接受该组。 特性 : 启用继承的属性 要求：参考对象和对象的属性不同。 行 接受设置。...", 
"body" : "应该传输哪些元信息？ 访问权限 : 选择继承的权限 接受组 从参考项目继承访问权限的组 如果一个组存在于两个项目中并且具有不同的访问权限，则该组被接受。 例子： Group_A 未接受的组（项目中缺少） 如果该组不存在于任一项目中，则不接受该组。 特性 : 启用继承的属性 要求：参考对象和对象的属性不同。 行 接受设置。 " }, 
{ "title" : "命令：传输接受的更改 ", 
"url" : "_cds_cmd_commit_accepted_changes.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：传输接受的更改 ", 
"snippet" : "转移接受的更改 象征： 功能 ：该命令将项目比较中采用的差异转移到当前项目。 称呼 ： 项目 → 转移接受的变更 要求 ：采用项目比较的变化。 更改仅复制到项目中。使用此命令不会将它们保存到磁盘。 有关更多信息，请参阅： 打开详细比较视图...", 
"body" : "转移接受的更改 象征： 功能 ：该命令将项目比较中采用的差异转移到当前项目。 称呼 ： 项目 → 转移接受的变更 要求 ：采用项目比较的变化。 更改仅复制到项目中。使用此命令不会将它们保存到磁盘。 有关更多信息，请参阅： 打开详细比较视图" }, 
{ "title" : "命令：导出为 XML ", 
"url" : "_cds_cmd_export.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：导出为 XML ", 
"snippet" : "导出为 XML 功能 ：该命令打开一个对话框，用于将项目对象导出到 XML 文件。 打电话 : 项目 → 出口 菜单...", 
"body" : "导出为 XML 功能 ：该命令打开一个对话框，用于将项目对象导出到 XML 文件。 打电话 : 项目 → 出口 菜单 " }, 
{ "title" : "对话 出口 ", 
"url" : "_cds_cmd_export.html#UUID-776705e8-b094-bcb8-d7f6-5fd436c5781b_id_e897dec0fff2c0a8640e0188145f_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：导出为 XML \/ 对话 出口 ", 
"snippet" : "该对话框列出了设备树、POU 树和模块树中的所有对象 CODESYS 可以出口。 每个子树一个文件 ： CODESYS 为根节点正下方并包含选定对象的每个子树创建一个单独的导出文件。 ： CODESYS 只为所有选定对象创建一个导出文件。 内存版本 该版本应与稍后将导入导出文件的版本相对应。 如果当前项目包含在所选存储格式（配置文件）中不可用的插件或附加组件，则会打开对话框 展开个人资料 .在此对话框中，可以使用附加组件扩展所选配置文件。 有关更多信息，请参阅： 导出和导入项目...", 
"body" : "该对话框列出了设备树、POU 树和模块树中的所有对象 CODESYS 可以出口。 每个子树一个文件 ： CODESYS 为根节点正下方并包含选定对象的每个子树创建一个单独的导出文件。 ： CODESYS 只为所有选定对象创建一个导出文件。 内存版本 该版本应与稍后将导入导出文件的版本相对应。 如果当前项目包含在所选存储格式（配置文件）中不可用的插件或附加组件，则会打开对话框 展开个人资料 .在此对话框中，可以使用附加组件扩展所选配置文件。 有关更多信息，请参阅： 导出和导入项目" }, 
{ "title" : "命令：从 XML 导入 ", 
"url" : "_cds_cmd_import.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：从 XML 导入 ", 
"snippet" : "从 XML 导入 功能 ：该命令打开一个对话框，用于从 XML 文件导入对象。 打电话 : 项目 → 导入 菜单 要求 : 项目已打开。 在导入项目之前， CODESYS 检查项目是否需要未安装的附加组件。如果是这种情况，则会打开一个对话框，其中包含缺少的附加组件。这些可以稍后通过此对话框安装。...", 
"body" : "从 XML 导入 功能 ：该命令打开一个对话框，用于从 XML 文件导入对象。 打电话 : 项目 → 导入 菜单 要求 : 项目已打开。 在导入项目之前， CODESYS 检查项目是否需要未安装的附加组件。如果是这种情况，则会打开一个对话框，其中包含缺少的附加组件。这些可以稍后通过此对话框安装。 " }, 
{ "title" : "对话 进口 ", 
"url" : "_cds_cmd_import.html#UUID-ac71f905-c8c9-883c-f3d4-548c03b37cbc_id_fe172f01dec6b272c0a8640e000bd57a_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：从 XML 导入 \/ 对话 进口 ", 
"snippet" : "该对话框列出了导出文件中的所有对象 CODESYS 此时可以导入。 当前选定的目标对象 在设备树中选择的对象 可插入对象 显示导出文件的所有对象 CODESYS 在所选对象下方 查看内容 以树状结构显示导出文件的内容 有关更多信息，请参阅： 导出和导入项目...", 
"body" : "该对话框列出了导出文件中的所有对象 CODESYS 此时可以导入。 当前选定的目标对象 在设备树中选择的对象 可插入对象 显示导出文件的所有对象 CODESYS 在所选对象下方 查看内容 以树状结构显示导出文件的内容 有关更多信息，请参阅： 导出和导入项目" }, 
{ "title" : "命令：导出 PLCopenXML ", 
"url" : "_cds_cmd_export_plcopenxml.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：导出 PLCopenXML ", 
"snippet" : "导出 PLCopenXML 功能 ：该命令打开一个对话框，用于将项目对象导出为 PLCopen 格式的 XML 文件。 打电话 : 项目 → 出口 菜单 对话框：导出 PLCopenXML 该对话框列出了设备树中的所有对象 CODESYS 根据 PLCopen 格式导出为 XML 文件。 PLCopenXML 模式不允许在同一个变量列表中包含 VAR_GLOBAL 和 VAR_GLOBAL CONSTANT 块。因此，如果要同时导出两者，则必须首先将变量拆分为两个单独的变量列表。 有关更多信息，请参阅： 导出和导入项目...", 
"body" : "导出 PLCopenXML 功能 ：该命令打开一个对话框，用于将项目对象导出为 PLCopen 格式的 XML 文件。 打电话 : 项目 → 出口 菜单 对话框：导出 PLCopenXML 该对话框列出了设备树中的所有对象 CODESYS 根据 PLCopen 格式导出为 XML 文件。 PLCopenXML 模式不允许在同一个变量列表中包含 VAR_GLOBAL 和 VAR_GLOBAL CONSTANT 块。因此，如果要同时导出两者，则必须首先将变量拆分为两个单独的变量列表。 有关更多信息，请参阅： 导出和导入项目" }, 
{ "title" : "命令：导入 PLCopenXML ", 
"url" : "_cds_cmd_import_plcopenxml.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：导入 PLCopenXML ", 
"snippet" : "导入 PLCopenXML 功能 ：该命令打开一个对话框，用于从 PLCopen 格式的 XML 文件中导入对象。 打电话 : 项目 → 导入 菜单 要求 : 项目已打开。...", 
"body" : "导入 PLCopenXML 功能 ：该命令打开一个对话框，用于从 PLCopen 格式的 XML 文件中导入对象。 打电话 : 项目 → 导入 菜单 要求 : 项目已打开。 " }, 
{ "title" : "对话框：导入 PLCopenXML ", 
"url" : "_cds_cmd_import_plcopenxml.html#UUID-30e7f7a4-620a-f8ba-886c-a6ca39fbab9d_id_deccec55c0a8640e00ef38fa_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：导入 PLCopenXML \/ 对话框：导入 PLCopenXML ", 
"snippet" : "该对话框列出了 PLCopen 导出文件中的所有对象 CODESYS 此时可以导入。 当前选定的目标对象 在设备树中选择的对象 可插入条目 显示导出文件的所有对象 CODESYS 在所选对象下方 解决冲突 当导入与现有对象同名的对象时，可以为每个对象解决冲突，如下所示： 替换现有对象 ：项目中存在的对象被导入的对象覆盖。 重命名新对象 : 新对象以更改后的名称导入。字符串 _<no> 附加到名称的末尾。 跳过新对象 : 对象未导入。 选择 打开用于选择对象类型的列表框 取消选择 打开用于取消选择对象类型的列表框 冲突 打开用于解决所有冲突的列表框 显示内容 打开显示 XML 文件对象的对话框 ...", 
"body" : "该对话框列出了 PLCopen 导出文件中的所有对象 CODESYS 此时可以导入。 当前选定的目标对象 在设备树中选择的对象 可插入条目 显示导出文件的所有对象 CODESYS 在所选对象下方 解决冲突 当导入与现有对象同名的对象时，可以为每个对象解决冲突，如下所示： 替换现有对象 ：项目中存在的对象被导入的对象覆盖。 重命名新对象 : 新对象以更改后的名称导入。字符串 _<no> 附加到名称的末尾。 跳过新对象 : 对象未导入。 选择 打开用于选择对象类型的列表框 取消选择 打开用于取消选择对象类型的列表框 冲突 打开用于解决所有冲突的列表框 显示内容 打开显示 XML 文件对象的对话框 PLCopenXML 模式不允许在同一个变量列表中包含 VAR_GLOBAL 和 VAR_GLOBAL CONSTANT 块。因此，如果要同时导出两者，则必须首先将变量拆分为两个单独的变量列表。 有关更多信息，请参阅： 导出和导入项目" }, 
{ "title" : "命令：导出 IEC61131-10 ", 
"url" : "_cds_cmd_export_iec_61131_10.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：导出 IEC61131-10 ", 
"snippet" : "导出 IEC61131-10 建议将此功能仅用于与其他 IDE 交换，因为它仅处理 IEC 61131-10 标准也支持的元素。不支持其他对象（例如 CFC 对象或库管理器）。用于导出\/导入自 CODESYS 到 CODESYS ，因此，我们继续推荐本地导入\/导出，以获得100％的覆盖率。 符号： 函数 ：该命令会打开一个对话框，用于将当前打开的项目导出为 XML 文件格式 *.iec6113110.xml 。这个 出口 对话框显示来自的对象 设备 （ 设备 节点）和 POU （ 泳池对象 节点）视图。所有对象均已选中，可以使用此命令将其导出。在对话框中，可以选择和取消选择单个对象进行导出。 ...", 
"body" : "导出 IEC61131-10 建议将此功能仅用于与其他 IDE 交换，因为它仅处理 IEC 61131-10 标准也支持的元素。不支持其他对象（例如 CFC 对象或库管理器）。用于导出\/导入自 CODESYS 到 CODESYS ，因此，我们继续推荐本地导入\/导出，以获得100％的覆盖率。 符号： 函数 ：该命令会打开一个对话框，用于将当前打开的项目导出为 XML 文件格式 *.iec6113110.xml 。这个 出口 对话框显示来自的对象 设备 （ 设备 节点）和 POU （ 泳池对象 节点）视图。所有对象均已选中，可以使用此命令将其导出。在对话框中，可以选择和取消选择单个对象进行导出。 打电话 ：该命令不包含在任何标准菜单中。你可以通过以下方式添加它 工具 → 自定义 中的对话框 设备 类别。有关更多信息，请参阅： 自定义菜单要求 : 项目已打开。 For more information, see: 导入 IEC-61131-10" }, 
{ "title" : "命令：导入 IEC-61131-10 ", 
"url" : "_cds_cmd_import_iec_61131_10.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：导入 IEC-61131-10 ", 
"snippet" : "导入 IEC-61131-10 建议将此功能仅用于与其他 IDE 交换，因为它仅处理 IEC 61131-10 标准也支持的元素。不支持其他对象（例如 CFC 对象或库管理器）。用于导出\/导入自 CODESYS 到 CODESYS ，因此，我们继续推荐本地导入\/导出，以获得100％的覆盖率。 符号： 函数 ：该命令会打开一个标准对话框，用于导入格式为 XML 文件 IecXchangefiles (*.xml) 。导入时， 导入 对话框打开，它提供了选择和取消选择对象以及处理冲突的功能。视所选对象而定 设备 或者 POU 视图，可以在其中插入的元素列表将在导入对话框中刷新。只要对话框处于打开状...", 
"body" : "导入 IEC-61131-10 建议将此功能仅用于与其他 IDE 交换，因为它仅处理 IEC 61131-10 标准也支持的元素。不支持其他对象（例如 CFC 对象或库管理器）。用于导出\/导入自 CODESYS 到 CODESYS ，因此，我们继续推荐本地导入\/导出，以获得100％的覆盖率。 符号： 函数 ：该命令会打开一个标准对话框，用于导入格式为 XML 文件 IecXchangefiles (*.xml) 。导入时， 导入 对话框打开，它提供了选择和取消选择对象以及处理冲突的功能。视所选对象而定 设备 或者 POU 视图，可以在其中插入的元素列表将在导入对话框中刷新。只要对话框处于打开状态，就可以通过单击 设备 或者 POU 观点。 打电话 ：该命令不包含在任何标准菜单中。你可以通过以下方式添加它 工具 → 自定义 中的对话框 设备 类别。有关更多信息，请参阅： 自定义菜单要求 : 项目已打开。 对话框：导入 内容 可插入的物品 导入文件中所有对象的列表，这些对象可以插入到当前项目中选定对象的下方。可以选择或取消选择单个对象进行导入。 冲突解决 在字段中单击可打开用于更改此元素显示的冲突解决方案的列表框。 要求：元素存在冲突。 导入与现有对象同名的对象时，可以按如下方式解决每个对象的冲突： 替换现有对象 ：项目中存在的对象被导入的对象覆盖。 Rename the new object : The new object is imported with the changed name. A consecutive number _<no> is appended to the name Skip the new object : The object is not imported. 设备 通过单击该字段， 显示按钮。此按钮可用于在中选择其他设备 选择设备 对话框。 附加信息 文件头 内容的标题 显示导入文件信息 选择 此列表框可用于选择所有对象或特定类型的所有对象。 取消选择 此列表框可用于取消选择所有对象或特定类型的所有对象。 冲突 此列表框可用于选择适用于所有存在冲突的对象的冲突解决方案。 要更改特定对象的冲突解决方案，请单击 冲突解决 相应对象的字段。 For more information, see: 导出 IEC61131-10" }, 
{ "title" : "命令：用户管理 - 登录用户 ", 
"url" : "_cds_cmd_usermanagement_logon.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：用户管理 - 登录用户 ", 
"snippet" : "用户管理——注册用户 象征： 功能 ：命令打开对话框 登记 . 称呼 ： 菜单 项目→用户管理 在对话中 登记 指示您要编辑的项目以及具有适当权限的用户帐户的凭据。您也可以从此对话框打开密码管理器。 有关更多信息，请参阅： 为项目和对象配置用户管理和访问权限...", 
"body" : "用户管理——注册用户 象征： 功能 ：命令打开对话框 登记 . 称呼 ： 菜单 项目→用户管理 在对话中 登记 指示您要编辑的项目以及具有适当权限的用户帐户的凭据。您也可以从此对话框打开密码管理器。 有关更多信息，请参阅： 为项目和对象配置用户管理和访问权限 " }, 
{ "title" : "命令：用户管理-注销用户 ", 
"url" : "_cds_cmd_usermanagement_logoff.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：用户管理-注销用户 ", 
"snippet" : "用户管理 - 注销用户 象征： 功能 : 该命令注销当前登录项目的用户。除非当前没有用户登录，否则会在没有对话框或消息的情况下发生这种情况。 称呼 ： 菜单 项目→用户管理 如果用户当前登录到多个项目或链接库（不必是相同的用户帐户），则会出现对话框 注销 .在此对话框中，您可以专门选择要注销当前用户的项目或库项目。 状态栏始终显示当前登录到项目的用户。 双击该字段 当前用户 在状态栏中提供快速访问 登记 - 或者。 注销 -对话。 有关更多信息，请参阅： 为项目和对象配置用户管理和访问权限 和 用户管理——注册用户...", 
"body" : "用户管理 - 注销用户 象征： 功能 : 该命令注销当前登录项目的用户。除非当前没有用户登录，否则会在没有对话框或消息的情况下发生这种情况。 称呼 ： 菜单 项目→用户管理 如果用户当前登录到多个项目或链接库（不必是相同的用户帐户），则会出现对话框 注销 .在此对话框中，您可以专门选择要注销当前用户的项目或库项目。 状态栏始终显示当前登录到项目的用户。 双击该字段 当前用户 在状态栏中提供快速访问 登记 - 或者。 注销 -对话。 有关更多信息，请参阅： 为项目和对象配置用户管理和访问权限 和 用户管理——注册用户" }, 
{ "title" : "命令：用户管理 - 权限 ", 
"url" : "_cds_cmd_usermanagement_rights.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：用户管理 - 权限 ", 
"snippet" : "用户管理 - 权限 功能 ：命令打开对话框 对 . 称呼 ： 菜单 项目→用户管理 在对话中 对 定义哪些用户组可以对哪些项目对象执行哪些操作。 有关更多信息，请参阅： 为项目和对象配置用户管理和访问权限...", 
"body" : "用户管理 - 权限 功能 ：命令打开对话框 对 . 称呼 ： 菜单 项目→用户管理 在对话中 对 定义哪些用户组可以对哪些项目对象执行哪些操作。 有关更多信息，请参阅： 为项目和对象配置用户管理和访问权限 " }, 
{ "title" : "命令：插入设备 ", 
"url" : "_cds_cmd_insert_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：插入设备 ", 
"snippet" : "插入装置 功能 ：命令像命令一样打开 连接设备 对话 连接设备 选择设备对象。该对象插入设备树中与当前选定对象处于同一级别。 称呼 : 设备树中设备对象的上下文菜单 要求 ：在设备树中选择一个对象，在该对象下可以插入同级的设备对象。...", 
"body" : "插入装置 功能 ：命令像命令一样打开 连接设备 对话 连接设备 选择设备对象。该对象插入设备树中与当前选定对象处于同一级别。 称呼 : 设备树中设备对象的上下文菜单 要求 ：在设备树中选择一个对象，在该对象下可以插入同级的设备对象。 " }, 
{ "title" : "命令：生成 EtherCAT XML ", 
"url" : "_cds_cmd_generate_ethercat_xml.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：生成 EtherCAT XML ", 
"snippet" : "生成 EtherCAT XML 该命令不包含在标准菜单中。你可以问他关于对话 工具 → 自定义 从类别 设备 添加。有关更多信息，请参阅： 自定义菜单功能 ：该命令打开用于在本地文件系统中保存文件的标准对话框。您可以为 xml 文件定义名称和位置，其中 CODESYS 应保存当前在设备树中选择的 EtherCAT 主站的 EtherCAT 配置。这可能是操作外部 EtherCAT 堆栈所必需的。 称呼 ：设备树中 EtherCAT 主站设备对象的上下文菜单 有关更多信息，请参阅： 配置 I\/O 链接...", 
"body" : "生成 EtherCAT XML 该命令不包含在标准菜单中。你可以问他关于对话 工具 → 自定义 从类别 设备 添加。有关更多信息，请参阅： 自定义菜单功能 ：该命令打开用于在本地文件系统中保存文件的标准对话框。您可以为 xml 文件定义名称和位置，其中 CODESYS 应保存当前在设备树中选择的 EtherCAT 主站的 EtherCAT 配置。这可能是操作外部 EtherCAT 堆栈所必需的。 称呼 ：设备树中 EtherCAT 主站设备对象的上下文菜单 有关更多信息，请参阅： 配置 I\/O 链接" }, 
{ "title" : "命令：生成 sercos SCI XML ", 
"url" : "_cds_cmd_generate_sercos3_xml.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：生成 sercos SCI XML ", 
"snippet" : "生成 sercos SCI XML 该命令不包含在标准菜单中。你可以问他关于对话 工具 → 自定义 从类别 设备 添加。 功能 ：该命令打开用于在本地文件系统中保存文件的标准对话框。您可以为 xml 文件定义名称和位置，其中 CODESYS 应保存设备树中当前选择的 sercos 主站的配置数据。这可能是操作外部 sercos 堆栈所必需的。 称呼 : 设备树中 sercos 主设备对象的上下文菜单...", 
"body" : "生成 sercos SCI XML 该命令不包含在标准菜单中。你可以问他关于对话 工具 → 自定义 从类别 设备 添加。 功能 ：该命令打开用于在本地文件系统中保存文件的标准对话框。您可以为 xml 文件定义名称和位置，其中 CODESYS 应保存设备树中当前选择的 sercos 主站的配置数据。这可能是操作外部 sercos 堆栈所必需的。 称呼 : 设备树中 sercos 主设备对象的上下文菜单 " }, 
{ "title" : "命令：禁用设备-启用设备 ", 
"url" : "_cds_cmd_disable_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：禁用设备-启用设备 ", 
"snippet" : "禁用设备，启用设备 功能 ：该命令在总线系统中设备的活动和非活动状态之间切换。 称呼 : 设备树中设备对象的上下文菜单 要求 ：项目处于离线模式。总线驱动程序必须支持该功能。 停用的设备将被忽略且未寻址。请注意，对于某些总线系统，停用节点会导致主站停止。 树中停用设备的条目以浅灰色字体显示。登录时，停用的设备也标有红色三角形 标记。...", 
"body" : "禁用设备，启用设备 功能 ：该命令在总线系统中设备的活动和非活动状态之间切换。 称呼 : 设备树中设备对象的上下文菜单 要求 ：项目处于离线模式。总线驱动程序必须支持该功能。 停用的设备将被忽略且未寻址。请注意，对于某些总线系统，停用节点会导致主站停止。 树中停用设备的条目以浅灰色字体显示。登录时，停用的设备也标有红色三角形 标记。 " }, 
{ "title" : "命令：编辑 I\/O 映像 ", 
"url" : "_cds_cmd_edit_io_mapping.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：编辑 I\/O 映像 ", 
"snippet" : "编辑 I\/O 映像 功能 : 命令打开视图 编辑 I\/O 映像 .此视图显示当前选定设备对象的所有 I\/O 映像（“映射”）以及设备树中该对象下附加的所有其他设备对象的 I\/O 映像。 称呼 : 设备树中设备对象的上下文菜单...", 
"body" : "编辑 I\/O 映像 功能 : 命令打开视图 编辑 I\/O 映像 .此视图显示当前选定设备对象的所有 I\/O 映像（“映射”）以及设备树中该对象下附加的所有其他设备对象的 I\/O 映像。 称呼 : 设备树中设备对象的上下文菜单 " }, 
{ "title" : "查看：编辑 I\/O 映像 ", 
"url" : "_cds_cmd_edit_io_mapping.html#UUID-a0e8fdc8-841e-1079-dd03-c917fffbb646_id_a879c3411c826d0c0a8640e019cc157_id_e4690835796ca3e6c0a8640e002c9eba", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：编辑 I\/O 映像 \/ 查看：编辑 I\/O 映像 ", 
"snippet" : "您可以在此对话框中编辑 I\/O 映像，方法与在对话框中相同 I\/O 映射 的各个设备编辑器。其他对话框会立即相应更新。 寻找 映射表中要查找的字符串的输入字段 搜索结果以黄色突出显示。 筛选 映射表中显示的 I\/O 分配筛选器的选择列表 显示所有 仅显示输出 仅显示输入 仅显示非映射变量 仅显示映射变量 仅显示到现有变量的映射 仅显示到新变量的映射 上下文菜单包括以下命令： 将 I\/O 映像导出为 CSV ：用于将设备及其子设备的映射保存到外部文件 为此，请在设备树或映射列表中选择设备。 从 CSV 导入 I\/O 映像 ：用于从先前由导出生成的文件中插入映射 有关更多信息，请参阅： 配置 I\/...", 
"body" : "您可以在此对话框中编辑 I\/O 映像，方法与在对话框中相同 I\/O 映射 的各个设备编辑器。其他对话框会立即相应更新。 寻找 映射表中要查找的字符串的输入字段 搜索结果以黄色突出显示。 筛选 映射表中显示的 I\/O 分配筛选器的选择列表 显示所有 仅显示输出 仅显示输入 仅显示非映射变量 仅显示映射变量 仅显示到现有变量的映射 仅显示到新变量的映射 上下文菜单包括以下命令： 将 I\/O 映像导出为 CSV ：用于将设备及其子设备的映射保存到外部文件 为此，请在设备树或映射列表中选择设备。 从 CSV 导入 I\/O 映像 ：用于从先前由导出生成的文件中插入映射 有关更多信息，请参阅： 配置 I\/O 链接" }, 
{ "title" : "命令：从 CSV 导入 I\/O 映像 ", 
"url" : "_cds_cmd_import_io_mapping_csv.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：从 CSV 导入 I\/O 映像 ", 
"snippet" : "从 CSV 导入 I\/O 映像 功能 ：该命令打开标准对话框以在本地文件系统中打开文件。过滤器基于文件格式 csv 设置为从之前使用命令创建的文件中导入设备的 I\/O 映像配置 将 I\/O 映像导出为 CSV 被出口了。 CODESYS 将配置写入所选设备。 称呼 : 视图中设备对象的上下文菜单 设备 要求 : 带有具有 I\/O 映射配置的设备的项目已打开。设备匹配导出的 csv -文件。 I\/O 映射配置保存在 CSV 文件使用在 Windows 区域设置中定义为列表分隔符（逗号或分号）的分隔符。这些文件可以手动编辑。手动编辑文件时，必须保留此格式才能成功导入。 请注意以下几点： 文件中的条...", 
"body" : "从 CSV 导入 I\/O 映像 功能 ：该命令打开标准对话框以在本地文件系统中打开文件。过滤器基于文件格式 csv 设置为从之前使用命令创建的文件中导入设备的 I\/O 映像配置 将 I\/O 映像导出为 CSV 被出口了。 CODESYS 将配置写入所选设备。 称呼 : 视图中设备对象的上下文菜单 设备 要求 : 带有具有 I\/O 映射配置的设备的项目已打开。设备匹配导出的 csv -文件。 I\/O 映射配置保存在 CSV 文件使用在 Windows 区域设置中定义为列表分隔符（逗号或分号）的分隔符。这些文件可以手动编辑。手动编辑文件时，必须保留此格式才能成功导入。 请注意以下几点： 文件中的条目通过设备名称 (DeviceName) 和通道名称（参数名称）分配给设备的 I\/O 映像。不唯一的参数名称在此文件中连续编号 @<n> 扩大。 没有内容的字段 csv 文件在导入期间被忽略。为了通过导入删除 I\/O 映像中的现有条目，您必须在 csv - 在文件中插入一个空格。 有关更多信息，请参阅： 配置设备和 I\/O 映射" }, 
{ "title" : "命令：将 I\/O 图像导出为 CSV ", 
"url" : "_cds_cmd_export_io_mapping_csv.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：将 I\/O 图像导出为 CSV ", 
"snippet" : "将 I\/O 映像导出为 CSV 功能 ：该命令打开将文件保存到本地文件系统的默认对话框。过滤器设置为 CSV 文件格式。指定名称和存储位置后， CODESYS 将 I\/O 映射配置保存在 CSV 文件使用在 Windows 区域设置中定义为列表分隔符（逗号或分号）的分隔符。 称呼 : 视图中设备对象的上下文菜单 设备 要求 ：在设备树中选择具有 I\/O 映射配置的设备对象。 不唯一的参数名称在此文件中连续编号 @<n> 扩大。 有关更多信息，请参阅： 配置设备和 I\/O 映射...", 
"body" : "将 I\/O 映像导出为 CSV 功能 ：该命令打开将文件保存到本地文件系统的默认对话框。过滤器设置为 CSV 文件格式。指定名称和存储位置后， CODESYS 将 I\/O 映射配置保存在 CSV 文件使用在 Windows 区域设置中定义为列表分隔符（逗号或分号）的分隔符。 称呼 : 视图中设备对象的上下文菜单 设备 要求 ：在设备树中选择具有 I\/O 映射配置的设备对象。 不唯一的参数名称在此文件中连续编号 @<n> 扩大。 有关更多信息，请参阅： 配置设备和 I\/O 映射" }, 
{ "title" : "命令：将 PLC 参数文件读入配置 ", 
"url" : "_cds_cmd_read_plc_parameter_file_to_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：将 PLC 参数文件读入配置 ", 
"snippet" : "将 PLC 参数文件读入配置 功能 ：命令读取配置文件 IoConfig.par 从 PLC 并保存项目中的值。如果 PLC 的参数已被其他设备更改（例如通过可视化），则会创建此类文件。那么这些参数只在PLC的内存中改变，在项目的配置中没有改变。 称呼 : PLC 设备对象的上下文菜单 要求 ：你是对话的指挥者 工具 → 自定义 在用户界面中可用。 有关更多信息，请参阅： 将 PLC 参数文件读入配置...", 
"body" : "将 PLC 参数文件读入配置 功能 ：命令读取配置文件 IoConfig.par 从 PLC 并保存项目中的值。如果 PLC 的参数已被其他设备更改（例如通过可视化），则会创建此类文件。那么这些参数只在PLC的内存中改变，在项目的配置中没有改变。 称呼 : PLC 设备对象的上下文菜单 要求 ：你是对话的指挥者 工具 → 自定义 在用户界面中可用。 有关更多信息，请参阅： 将 PLC 参数文件读入配置 " }, 
{ "title" : "命令：在线配置模式 ", 
"url" : "_cds_cmd_online_configuration_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：在线配置模式 ", 
"snippet" : "在线配置操作 功能 ：该命令用于打开和关闭在线配置模式。打开时，它会建立与 PLC 的连接并在那里加载隐式创建的应用程序 HiddenOnlineConfigModeApp .取决于设备 CODESYS 切换到简单在线配置模式，或出现选择简单在线配置模式和高级在线配置模式的对话框。 称呼 : 设备树中 PLC 对象的上下文菜单 要求 : PLC 设备的通信设置正确设置。 简单的在线配置操作 该命令创建隐式应用程序 HiddenOnlineConfigModeApp 并将其上传到控制器。应用程序自动初始化控制器的所有输入和输出。然后，您可以按如下方式访问 I\/O： 读取 I\/O 写输出 诊断（在...", 
"body" : "在线配置操作 功能 ：该命令用于打开和关闭在线配置模式。打开时，它会建立与 PLC 的连接并在那里加载隐式创建的应用程序 HiddenOnlineConfigModeApp .取决于设备 CODESYS 切换到简单在线配置模式，或出现选择简单在线配置模式和高级在线配置模式的对话框。 称呼 : 设备树中 PLC 对象的上下文菜单 要求 : PLC 设备的通信设置正确设置。 简单的在线配置操作 该命令创建隐式应用程序 HiddenOnlineConfigModeApp 并将其上传到控制器。应用程序自动初始化控制器的所有输入和输出。然后，您可以按如下方式访问 I\/O： 读取 I\/O 写输出 诊断（在设备树和选项卡上 地位 设备编辑器） 扫描（当前硬件） 可用时的在线交互功能（例如编写异步消息） 扩展在线配置模式（参数模式） 如果 PLC 上已有应用程序并且控制器支持它们，则该命令首先打开对话框 设备 ，它显示控制器上的应用程序。您可以使用 按钮退出此对话框 参数操作 连接到 PLC，然后还可以访问设备参数的值，而无需使用实际应用程序登录。 在 I\/O 映像中写入和强制 在选项卡上写入和强制值在在线配置模式下工作 I\/O 映射 与实际在线操作不同。插入后立即将输出写入表中。没有专栏 准备值 ，但是可以直接双击该列后访问初始值 当前值 被改变。 " }, 
{ "title" : "对话框：选择配置模式 ", 
"url" : "_cds_cmd_online_configuration_mode.html#UUID-91bcb393-0216-c2c1-9344-e0347e485d28_id_ec211ca1ba0c0a8640e000c867a_id_ddb7ffbc9269d801c0a8640e000ce2e0", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 项目 \/ 命令：在线配置模式 \/ 对话框：选择配置模式 ", 
"snippet" : "命令后出现对话框 在线配置操作 ，如果设备支持扩展在线配置模式并且实际应用程序已经在控制器上。 参数操作 将项目中的控制器配置与设备上的配置进行比较。如果它们匹配，则构建 CODESYS 建立与 PLC 的连接。与简单的在线配置模式相比，它允许在通用设备编辑器中读取和写入参数（如果驱动程序支持）。在这种情况下，设备上已加载的应用程序保持不变！ 配置模式 CODESYS 切换到“简单在线配置模式”。 有关详细信息，请参阅：通过帮助检查控制器配置 在线配置模式命令...", 
"body" : "命令后出现对话框 在线配置操作 ，如果设备支持扩展在线配置模式并且实际应用程序已经在控制器上。 参数操作 将项目中的控制器配置与设备上的配置进行比较。如果它们匹配，则构建 CODESYS 建立与 PLC 的连接。与简单的在线配置模式相比，它允许在通用设备编辑器中读取和写入参数（如果驱动程序支持）。在这种情况下，设备上已加载的应用程序保持不变！ 配置模式 CODESYS 切换到“简单在线配置模式”。 有关详细信息，请参阅：通过帮助检查控制器配置 在线配置模式命令 " }, 
{ "title" : "创建 ", 
"url" : "_cds_f_commands_build.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 创建 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：生成代码 ", 
"url" : "_cds_cmd_generate_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 创建 \/ 命令：生成代码 ", 
"snippet" : "生成代码 象征： 键盘快捷键： F11 功能 ：该命令开始为活动应用程序生成代码。 称呼 ： 菜单 创建 使用此命令生成代码时，生成的代码与将应用程序加载到控制器时一样；但是，代码不会传输到控制器。对源代码进行了进一步的测试。这使您可以检查代码是否存在编译器无法识别的错误，并在在线使用之前更正它们。 有关更多信息，请参阅： 生成应用程序代码...", 
"body" : "生成代码 象征： 键盘快捷键： F11 功能 ：该命令开始为活动应用程序生成代码。 称呼 ： 菜单 创建 使用此命令生成代码时，生成的代码与将应用程序加载到控制器时一样；但是，代码不会传输到控制器。对源代码进行了进一步的测试。这使您可以检查代码是否存在编译器无法识别的错误，并在在线使用之前更正它们。 有关更多信息，请参阅： 生成应用程序代码" }, 
{ "title" : "命令：清洁 ", 
"url" : "_cds_cmd_clean.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 创建 \/ 命令：清洁 ", 
"snippet" : "清理 功能 ：该命令删除当前活动应用程序的翻译信息。 称呼 ： 菜单 创建 编译信息是在应用程序最后一次下载并保存在文件 (*.compileinfo) 时创建的。 在清理过程之后，受影响的应用程序将无法再进行在线更改。应用程序必须完全重新加载到控制器上。 有关更多信息，请参阅： 清洁一切...", 
"body" : "清理 功能 ：该命令删除当前活动应用程序的翻译信息。 称呼 ： 菜单 创建 编译信息是在应用程序最后一次下载并保存在文件 (*.compileinfo) 时创建的。 在清理过程之后，受影响的应用程序将无法再进行在线更改。应用程序必须完全重新加载到控制器上。 有关更多信息，请参阅： 清洁一切" }, 
{ "title" : "命令：清除所有 ", 
"url" : "_cds_cmd_clean_all.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 创建 \/ 命令：清除所有 ", 
"snippet" : "清洁一切 功能 ：该命令删除项目中所有应用程序的翻译信息。 称呼 ： 菜单 创建 翻译信息是在上次下载应用程序并保存在文件 (*.compileinfo) 时在本地文件系统中创建的。 该命令意味着必须在重新登录之前进行下载。无法再进行在线更改。不同于命令 清理 （仅活动应用程序）生成 CODESYS 所有对象的语言模型，这需要额外的时间。 仔细考虑是否有必要使用该命令。如果您只想重新编译和下载活动应用程序，请使用命令 清理 ....", 
"body" : "清洁一切 功能 ：该命令删除项目中所有应用程序的翻译信息。 称呼 ： 菜单 创建 翻译信息是在上次下载应用程序并保存在文件 (*.compileinfo) 时在本地文件系统中创建的。 该命令意味着必须在重新登录之前进行下载。无法再进行在线更改。不同于命令 清理 （仅活动应用程序）生成 CODESYS 所有对象的语言模型，这需要额外的时间。 仔细考虑是否有必要使用该命令。如果您只想重新编译和下载活动应用程序，请使用命令 清理 . " }, 
{ "title" : "命令：翻译 ", 
"url" : "_cds_cmd_build.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 创建 \/ 命令：翻译 ", 
"snippet" : "翻译 功能 ：该命令启动当前活动应用程序的翻译过程。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 翻译 粘贴到菜单中。 翻译线索 CODESYS 对应用程序的所有对象进行语法检查。但是，在此过程中不会生成任何代码，就像登录目标系统或下载应用程序时的情况一样。如果您想使用修改后的程序登录，编译过程始终会自动执行。 完成验证后显示 CODESYS 类别下的消息窗口中的任何错误消息或警告 翻译 在。 如果程序自上次无错误编译过程以来没有更改，则不会重新编译。出现“应用程序是最新的”消息。如果你还想重复语法检查，你必须使用命令 重新翻译 利用。...", 
"body" : "翻译 功能 ：该命令启动当前活动应用程序的翻译过程。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 翻译 粘贴到菜单中。 翻译线索 CODESYS 对应用程序的所有对象进行语法检查。但是，在此过程中不会生成任何代码，就像登录目标系统或下载应用程序时的情况一样。如果您想使用修改后的程序登录，编译过程始终会自动执行。 完成验证后显示 CODESYS 类别下的消息窗口中的任何错误消息或警告 翻译 在。 如果程序自上次无错误编译过程以来没有更改，则不会重新编译。出现“应用程序是最新的”消息。如果你还想重复语法检查，你必须使用命令 重新翻译 利用。 " }, 
{ "title" : "命令：重新编译 ", 
"url" : "_cds_cmd_rebuild.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 创建 \/ 命令：重新编译 ", 
"snippet" : "重新翻译 功能 ：该命令启动活动应用程序的构建操作，即使上次构建没有错误。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 翻译 粘贴到菜单中。 有关更多信息，请参阅： 翻译...", 
"body" : "重新翻译 功能 ：该命令启动活动应用程序的构建操作，即使上次构建没有错误。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 翻译 粘贴到菜单中。 有关更多信息，请参阅： 翻译" }, 
{ "title" : "命令：生成运行时系统文件 ", 
"url" : "_cds_cmd_generate_runtime_system_files.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 创建 \/ 命令：生成运行时系统文件 ", 
"snippet" : "生成运行时系统文件 功能 ：该命令从当前库项目中生成一个C框架文件和一个M4文件格式的接口文件。这些文件用作创建外部库文件的基础。 称呼 ： 菜单 创建 要求 : 一个库项目已打开。 该命令打开对话框 生成运行时系统文件 . 输出目录 其中的目录 CODESYS 创建运行时系统文件 关于按钮 您可以打开浏览文件系统的标准对话框。 组件名称 图书馆项目名称 您想创建哪些文件？ M4接口文件 : 接口文件 <projectname>Itf.m4 有定义 另请参阅下表，其中列出了支持 M4 导出的 IEC 代码构造。 M4 文件示例： C 存根文件 : 用于在 C 中编程库的框架文件 存根文件示例：...", 
"body" : "生成运行时系统文件 功能 ：该命令从当前库项目中生成一个C框架文件和一个M4文件格式的接口文件。这些文件用作创建外部库文件的基础。 称呼 ： 菜单 创建 要求 : 一个库项目已打开。 该命令打开对话框 生成运行时系统文件 . 输出目录 其中的目录 CODESYS 创建运行时系统文件 关于按钮 您可以打开浏览文件系统的标准对话框。 组件名称 图书馆项目名称 您想创建哪些文件？ M4接口文件 : 接口文件 <projectname>Itf.m4 有定义 另请参阅下表，其中列出了支持 M4 导出的 IEC 代码构造。 M4 文件示例： C 存根文件 : 用于在 C 中编程库的框架文件 存根文件示例： 选项 导出库中包含的引用类型 ：引用的类型包含在导出中。 使用原始类型名称 ：使用来自库项目的类型名称。 " }, 
{ "title" : "支持 M4 导出的 IEC 构造 ", 
"url" : "_cds_cmd_generate_runtime_system_files.html#UUID-4294143b-f9fb-2ec4-7378-d8337c13d93c_section-idm234462007759195", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 创建 \/ 命令：生成运行时系统文件 \/ 支持 M4 导出的 IEC 构造 ", 
"snippet" : "不支持表中未明确列出的所有类型。它们的行为可能会发生变化，但不会被注意到。 IEC 结构和语言含义 导出至 M4 文件 笔记 PROGRAM 不支持 FUNCTION_BLOCK struct 包含所有输入\/输出\/输入输出\/局部变量 此外，还有一个名为 <fb_name>__main 是为了实现 FUNCTION_BLOCK 。 FUNCTION STRUCT 包含所有输入\/输出\/输入输出\/局部变量以及 DEF_API 宏 INTERFACE struct 使用单个实例指针 METHOD 相同 FUNCTION ，命名 <fb_name>__<method_name> ，它使用指针 <fb_n...", 
"body" : "不支持表中未明确列出的所有类型。它们的行为可能会发生变化，但不会被注意到。 IEC 结构和语言含义 导出至 M4 文件 笔记 PROGRAM 不支持 FUNCTION_BLOCK struct 包含所有输入\/输出\/输入输出\/局部变量 此外，还有一个名为 <fb_name>__main 是为了实现 FUNCTION_BLOCK 。 FUNCTION STRUCT 包含所有输入\/输出\/输入输出\/局部变量以及 DEF_API 宏 INTERFACE struct 使用单个实例指针 METHOD 相同 FUNCTION ，命名 <fb_name>__<method_name> ，它使用指针 <fb_name> 作为附加输入 ACTION 相同 METHOD TRANSITION 相同 METHOD ，命名 get<transition_name> PROPERTY 方法对命名 get<prop_name> 和 set<prop_name> GVL 不支持 UNION C-union ENUM #define 对于每个枚举组件 ALIAS 不支持 STRUCT C-struct 支持继承。组件以“平面”形式导出（无结构） CONSTANT #define 对于每个常数 常量不能被显式导出，但如果在其他对象中使用它们，那么它们会被自动导出。 评论 C 评论 带有三个斜杠的注释也会被导出。 预定义数据类型（INT、BOOL、REAL 等） 相应大小的 C 数据类型 以 开头的类型 RTS_IEC 由于它们是在运行时系统的其他地方声明的，因此不会单独导出 ANY 类型 struct __SYSTEM.AnyType 全部 ANY 类型（例如， ANY_INT ， ANY_BIT 等）导出到 C 类型 struct __SYSTEM.AnyType 。 数组 固定大小的 C 数组 任意数量的维度 数组面积可以为负数。 ARRAY[*] 一个指针和一个大小 字符串 具有固定大小的 C 字符数组 " }, 
{ "title" : "命令：检查所有池对象 ", 
"url" : "_cds_cmd_check_all_pool_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 创建 \/ 命令：检查所有池对象 ", 
"snippet" : "检查所有池对象 象征： 键盘快捷键： F11 功能 ：该命令启动翻译运行，即语法检查，用于在 POUs 视图中管理的所有池对象，因此在整个项目中都可用。这在创建库时主要有用。 称呼 ： 菜单 创建 要求 : 一个库项目已打开。 该命令不会导致代码生成。此外，不会在项目目录中创建包含有关编译运行信息的文件。...", 
"body" : "检查所有池对象 象征： 键盘快捷键： F11 功能 ：该命令启动翻译运行，即语法检查，用于在 POUs 视图中管理的所有池对象，因此在整个项目中都可用。这在创建库时主要有用。 称呼 ： 菜单 创建 要求 : 一个库项目已打开。 该命令不会导致代码生成。此外，不会在项目目录中创建包含有关编译运行信息的文件。 " }, 
{ "title" : "命令：为活动应用程序生成代码 ", 
"url" : "_cds_cmd_generate_code_for_active_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 创建 \/ 命令：为活动应用程序生成代码 ", 
"snippet" : "为活动应用程序生成代码 功能 ：该命令为库项目的应用程序生成代码。 称呼 ： 菜单 创建 要求 : 该项目包含一个应用程序。 库项目已打开。 库项目包含一个应用程序。 使用此命令生成代码时，生成的代码与将应用程序加载到控制器时一样；但是，代码不会传输到控制器。对源代码进行了进一步的测试。这使您可以检查代码是否存在编译器无法识别的错误，并在在线使用之前更正它们。 有关更多信息，请参阅： 生成运行时系统文件...", 
"body" : "为活动应用程序生成代码 功能 ：该命令为库项目的应用程序生成代码。 称呼 ： 菜单 创建 要求 : 该项目包含一个应用程序。 库项目已打开。 库项目包含一个应用程序。 使用此命令生成代码时，生成的代码与将应用程序加载到控制器时一样；但是，代码不会传输到控制器。对源代码进行了进一步的测试。这使您可以检查代码是否存在编译器无法识别的错误，并在在线使用之前更正它们。 有关更多信息，请参阅： 生成运行时系统文件" }, 
{ "title" : "命令：检查所有应用程序对象 ", 
"url" : "_cds_cmd_check_all_application_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 创建 \/ 命令：检查所有应用程序对象 ", 
"snippet" : "检查所有应用程序对象 功能 ：该命令为活动应用程序的所有对象启动转换运行，即也为应用程序未使用的 POU 启动转换运行。编译运行后，在未使用对象中发现的错误也会显示在消息窗口中。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 翻译 粘贴到菜单中。 要求 ：打开项目的应用程序处于活动状态。 该命令不会导致代码生成。此外，不会在项目目录中创建包含有关编译运行信息的文件。...", 
"body" : "检查所有应用程序对象 功能 ：该命令为活动应用程序的所有对象启动转换运行，即也为应用程序未使用的 POU 启动转换运行。编译运行后，在未使用对象中发现的错误也会显示在消息窗口中。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 翻译 粘贴到菜单中。 要求 ：打开项目的应用程序处于活动状态。 该命令不会导致代码生成。此外，不会在项目目录中创建包含有关编译运行信息的文件。 " }, 
{ "title" : "命令：检查库兼容性 ", 
"url" : "_cds_cmd_check_library_compatibility.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 创建 \/ 命令：检查库兼容性 ", 
"snippet" : "检查库兼容性 功能 ：该命令开始检查当前打开的库项目是否与该库的最后安装版本兼容（下一个较低的版本号）。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 翻译 粘贴到菜单中。 要求 : 一个库项目已打开。 检查查找方法的实现接口（接口）中的差异。检查后，在以下情况下，消息窗口中会出现错误消息： 添加或删除功能块、功能或方法的输入或输出 更改输入或输出的数据类型 更改方法的已实现接口（接口） 有关更多信息，请参阅： 图书馆开发人员信息...", 
"body" : "检查库兼容性 功能 ：该命令开始检查当前打开的库项目是否与该库的最后安装版本兼容（下一个较低的版本号）。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 翻译 粘贴到菜单中。 要求 : 一个库项目已打开。 检查查找方法的实现接口（接口）中的差异。检查后，在以下情况下，消息窗口中会出现错误消息： 添加或删除功能块、功能或方法的输入或输出 更改输入或输出的数据类型 更改方法的已实现接口（接口） 有关更多信息，请参阅： 图书馆开发人员信息" }, 
{ "title" : "命令：生成反汇编文件 ", 
"url" : "_cds_cmd_generate_disassembly_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 创建 \/ 命令：生成反汇编文件 ", 
"snippet" : "生成反汇编文件 功能 : 该命令从当前项目创建一个反汇编文件 <project name>.asm 并将其保存在项目文件夹的文件目录中。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 调整 从命令类别 翻译 粘贴到菜单中。...", 
"body" : "生成反汇编文件 功能 : 该命令从当前项目创建一个反汇编文件 <project name>.asm 并将其保存在项目文件夹的文件目录中。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 调整 从命令类别 翻译 粘贴到菜单中。 " }, 
{ "title" : "在线的 ", 
"url" : "_cds_f_commands_online.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：选择活动应用程序 ", 
"url" : "_cds_cmd_active_app_selector.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：选择活动应用程序 ", 
"snippet" : "选择活跃的应用程序 象征： 该命令被实现为一个选择列表，您可以使用它来激活应用程序。默认情况下，选择列表位于工具栏上。 功能 ：选择列表显示当前活动的应用程序及其设备路径。 称呼 ：选择列表包含视图下的所有应用程序 设备 被安排。通过单击选择列表中的条目，您可以激活选定的应用程序。 要求 : 该项目有几个应用程序。 例子 如果您使用菜单命令 创建 或者 在线的 调用，然后这些命令作用于活动的应用程序。这显示在选择列表中，并在设备树中以粗体显示。这主要影响命令 构建 → 生成代码 和 在线 → 登录 . 您还可以通过工具栏中的命令图标访问这些命令，其中还包含选择列表。调用命令图标时，它们也会影响...", 
"body" : "选择活跃的应用程序 象征： 该命令被实现为一个选择列表，您可以使用它来激活应用程序。默认情况下，选择列表位于工具栏上。 功能 ：选择列表显示当前活动的应用程序及其设备路径。 称呼 ：选择列表包含视图下的所有应用程序 设备 被安排。通过单击选择列表中的条目，您可以激活选定的应用程序。 要求 : 该项目有几个应用程序。 例子 如果您使用菜单命令 创建 或者 在线的 调用，然后这些命令作用于活动的应用程序。这显示在选择列表中，并在设备树中以粗体显示。这主要影响命令 构建 → 生成代码 和 在线 → 登录 . 您还可以通过工具栏中的命令图标访问这些命令，其中还包含选择列表。调用命令图标时，它们也会影响活动的应用程序。 但是，如果您通过设备对象的上下文菜单调用设备树中的命令，则该命令会影响关联的对象。例如，通过调用 Icon 与设备上未激活的应用程序建立连接。 " }, 
{ "title" : "命令：登录 ", 
"url" : "_cds_cmd_login.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：登录 ", 
"snippet" : "登录 象征： 键盘快捷键： 老的 + F8 功能 ：该命令将应用程序与目标系统（控制器或模拟设备）连接起来，从而建立在线操作。 称呼 ： 菜单 在线的 , 对象的上下文菜单 应用 要求 ：应用程序没有错误，并且配置了通信设置。 如果通信设置不正确，将出现一个对话框。然后就可以直接去 通讯设置 更换控制器。 如果你命令 登录 从在线菜单中，当前活动的应用程序连接到目标系统。如果您从上下文菜单调用命令并在设备树中选择了一个应用程序，则该应用程序用于登录，即使它没有设置为“活动应用程序”。 如果目标设备设置了在线用户管理，登录时会提示输入用户数据。出现此对话框 设备用户登录 . 检查访问选项以控制 ...", 
"body" : "登录 象征： 键盘快捷键： 老的 + F8 功能 ：该命令将应用程序与目标系统（控制器或模拟设备）连接起来，从而建立在线操作。 称呼 ： 菜单 在线的 , 对象的上下文菜单 应用 要求 ：应用程序没有错误，并且配置了通信设置。 如果通信设置不正确，将出现一个对话框。然后就可以直接去 通讯设置 更换控制器。 如果你命令 登录 从在线菜单中，当前活动的应用程序连接到目标系统。如果您从上下文菜单调用命令并在设备树中选择了一个应用程序，则该应用程序用于登录，即使它没有设置为“活动应用程序”。 如果目标设备设置了在线用户管理，登录时会提示输入用户数据。出现此对话框 设备用户登录 . 检查访问选项以控制 在任何情况下都不得从 Internet 或不可信网络访问控件！尤其是控制器的编程端口在任何情况下都不能不受 Internet 保护（通常是 UDP 端口 1740..1743 和 TCP 端口 1217 + 11740 或控制器特定端口）！但是，如果必须启用从 Internet 的访问，则必须选择一种安全的方法来连接到控制器（例如 VPN）。 有关更多信息，请参阅： 设备用户管理的处理如果安全控制器安装在控制器下方，此命令可以使用通信链路 暂时的 打断！ 安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的连接受到影响。作为反应，安全现场设备或其他安全控制器可以进入安全状态。只有当安全控制器通过现场总线连接到主控制器时，与开发系统的连接才会受到影响。 有关详细信息，请参阅“从属安全控制”一章。 登录时可能出现的情况 控制器上提供了比项目中更新的设备描述版本。您将收到一条警告，其中包含取消该过程的选项。 控制器上尚不存在该应用程序：系统将要求您确认下载。 该应用程序已经在控制器上，并且自上次加载以来没有更改。无需与您进行进一步交互即可进行登录。 该应用程序已在控制器上，但自上次下载后已更改。 系统将提示您选择以下选项之一： 在线更改登录（注意“命令”中的在线更改信息 在线更改 \") 登录下载 登录而不做任何更改 此时，您还可以选择更新控制器上的引导应用程序。 控制器上已存在未知版本的应用程序。你会被问到是否 CODESYS 替换这个。 应用程序的一个版本已经在控制器上并且正在运行。你会被问到是否 CODESYS 无论如何登录并覆盖当前正在运行的应用程序。 控制器上的应用程序当前在断点处停止。您已注销并更改了程序： CODESYS 警告您，如果在线更改或下载，PLC 将完全停止。当有多个任务并且只有一个受断点影响时，也会发生这种情况。 用按钮 细节 在上述对话框中，打开对话框 应用信息 . 来自 CODESYS -Version V3.5 SP17 只能是一个控制器的应用程序 CODESYS 要登录的实例。如果一秒钟 CODESYS 实例到同一个控制器的同一个应用程序时，会出现一条错误消息。 有关更多信息，请参阅： 在线更改 和 下级安全控制器" }, 
{ "title" : "对话框：应用程序信息（详细信息） ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_afdfe799069d6517c0a8640e01ead196", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：登录 \/ 对话框：应用程序信息（详细信息） ", 
"snippet" : "该对话框显示与控制器上当前版本相比在编程系统中已更改的应用程序的信息。有两个选项卡： 应用信息 : 的应用属性 IDE中的应用 （集成开发环境=编程系统）是那些 在PLC中的应用 比较：项目名称、上次更改、IDE 版本、作者、描述。另外显示 CODESYS 显示自上次下载以来已更改的对象。 申请内容 : 如果选项 下载申请资料 激活后，PLC (2) 上的应用程序内容可以与编程系统 (1) 中的应用程序内容进行比较。选项 下载申请资料 可以在应用程序属性、类别中找到 翻译 . 如果编程系统中的代码不是最新的，命令会出现在左下角 应用程序不是最新的。现在重新生成代码？ (3)。运行此命令以更新应...", 
"body" : "该对话框显示与控制器上当前版本相比在编程系统中已更改的应用程序的信息。有两个选项卡： 应用信息 : 的应用属性 IDE中的应用 （集成开发环境=编程系统）是那些 在PLC中的应用 比较：项目名称、上次更改、IDE 版本、作者、描述。另外显示 CODESYS 显示自上次下载以来已更改的对象。 申请内容 : 如果选项 下载申请资料 激活后，PLC (2) 上的应用程序内容可以与编程系统 (1) 中的应用程序内容进行比较。选项 下载申请资料 可以在应用程序属性、类别中找到 翻译 . 如果编程系统中的代码不是最新的，命令会出现在左下角 应用程序不是最新的。现在重新生成代码？ (3)。运行此命令以更新应用程序中的源代码。 这些详细信息将帮助您更好地评估当前情况下登录的效果，并做出下载新应用程序的决定。 比较也显示在选项卡的设备编辑器中 应用 通过按钮 内容 显示。 " }, 
{ "title" : "PLC 上的未知应用程序 ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_67cd7a3e1e8ebbd7c0a8640e00b8388e", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：登录 \/ PLC 上的未知应用程序 ", 
"snippet" : "如果控制器上已经有一个或多个不在项目中的应用程序，则打开 CODESYS 包含这些应用程序列表的对话框。您可以指定在加载当前应用程序之前是否应从 PLC 中删除以及应删除哪个应用程序。这也适用于控制器上但已从项目中删除的子应用程序。...", 
"body" : "如果控制器上已经有一个或多个不在项目中的应用程序，则打开 CODESYS 包含这些应用程序列表的对话框。您可以指定在加载当前应用程序之前是否应从 PLC 中删除以及应删除哪个应用程序。这也适用于控制器上但已从项目中删除的子应用程序。 " }, 
{ "title" : "登录前编译项目 ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_e30afcf16bc19572c0a8640e014e4835", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：登录 \/ 登录前编译项目 ", 
"snippet" : "如果应用程序项目自上次修改后尚未编译，则编译 CODESYS 登录前的项目。该操作对应命令 生成代码 处于注销状态。 如果在编译期间发生错误，则会出现一个消息对话框。错误列在消息窗口的类别中 翻译 发布。然后，您可以决定是否要在不将程序加载到控制器的情况下登录。...", 
"body" : "如果应用程序项目自上次修改后尚未编译，则编译 CODESYS 登录前的项目。该操作对应命令 生成代码 处于注销状态。 如果在编译期间发生错误，则会出现一个消息对话框。错误列在消息窗口的类别中 翻译 发布。然后，您可以决定是否要在不将程序加载到控制器的情况下登录。 " }, 
{ "title" : "登录时出错 ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_dbcc3ada1e8ebbd8c0a8640e015a729c", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：登录 \/ 登录时出错 ", 
"snippet" : "如果登录控制器时发生错误，则中断 CODESYS 带有错误消息的加载过程。错误对话框允许您查看错误详细信息。如果发生异常并且日志消息中包含文本 *SOURCEPOSITION*，则可以使用命令 在记事本中显示 在编辑器中显示受影响的功能。光标跳到导致错误的行。...", 
"body" : "如果登录控制器时发生错误，则中断 CODESYS 带有错误消息的加载过程。错误对话框允许您查看错误详细信息。如果发生异常并且日志消息中包含文本 *SOURCEPOSITION*，则可以使用命令 在记事本中显示 在编辑器中显示受影响的功能。光标跳到导致错误的行。 " }, 
{ "title" : "输出有关加载过程的信息 ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_4ba66a1395c4915dc0a8640e0199319f", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：登录 \/ 输出有关加载过程的信息 ", 
"snippet" : "什么时候 CODESYS 登录时将项目加载到控制器上，在消息窗口中输出以下信息： 生成的代码大小 全局数据大小 在控制器上产生的内存需求 受影响的块列表（在线更改的情况下） 您不能在在线模式下更改设备或模块的设置。要更改设备参数，您必须退出应用程序。但是，根据总线系统，可能会有一些特殊参数，您也可以在在线模式下更改这些参数。 保存视图的配置 CODESYS 在联机和脱机模式下彼此分开。此外，无法在操作模式下使用的视图将被关闭。因此，当您登录时，视图会自动更改。...", 
"body" : "什么时候 CODESYS 登录时将项目加载到控制器上，在消息窗口中输出以下信息： 生成的代码大小 全局数据大小 在控制器上产生的内存需求 受影响的块列表（在线更改的情况下） 您不能在在线模式下更改设备或模块的设置。要更改设备参数，您必须退出应用程序。但是，根据总线系统，可能会有一些特殊参数，您也可以在在线模式下更改这些参数。 保存视图的配置 CODESYS 在联机和脱机模式下彼此分开。此外，无法在操作模式下使用的视图将被关闭。因此，当您登录时，视图会自动更改。 " }, 
{ "title" : "命令：登出 ", 
"url" : "_cds_cmd_logoff.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：登出 ", 
"snippet" : "登出 象征： 键盘快捷键： 控制 + F8 功能 ：该命令断开应用程序与目标系统（控制器或模拟设备）的连接，从而返回离线操作。 称呼 ： 菜单 在线的 , 对象的上下文菜单 应用...", 
"body" : "登出 象征： 键盘快捷键： 控制 + F8 功能 ：该命令断开应用程序与目标系统（控制器或模拟设备）的连接，从而返回离线操作。 称呼 ： 菜单 在线的 , 对象的上下文菜单 应用 " }, 
{ "title" : "命令：创建启动应用程序 ", 
"url" : "_cds_cmd_create_boot_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：创建启动应用程序 ", 
"snippet" : "创建启动应用程序 功能 ：该命令创建一个引导应用程序。 称呼 ： 菜单 在线的 启动应用程序是在控制器通电或启动时自动启动的应用程序。 在离线模式下，您可以将启动应用程序保存在任何目录中。以在线模式保存 CODESYS 目标设备上的启动应用程序。文件名是 <Applikationsname>.app . 有关更多信息，请参阅： 创建引导应用程序...", 
"body" : "创建启动应用程序 功能 ：该命令创建一个引导应用程序。 称呼 ： 菜单 在线的 启动应用程序是在控制器通电或启动时自动启动的应用程序。 在离线模式下，您可以将启动应用程序保存在任何目录中。以在线模式保存 CODESYS 目标设备上的启动应用程序。文件名是 <Applikationsname>.app . 有关更多信息，请参阅： 创建引导应用程序" }, 
{ "title" : "命令：加载 ", 
"url" : "_cds_cmd_load.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：加载 ", 
"snippet" : "加载 功能 ：该命令会编译激活的应用程序并随后下载到控制器。 称呼 ： 菜单 在线的 要求 ：应用程序处于在线模式。 用命令引导 CODESYS 执行语法检查并生成应用程序代码。此代码被加载到控制器上。仍然生成 CODESYS 项目目录中的翻译日志 <project name>.<device name>.<application ID>.compileinfo . 加载时，除持久变量外，所有变量都会重新初始化。 如果安全控制器安装在控制器下方，此命令可以使用通信链路 暂时的 打断！ 安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的连接受到影响。作为反应，安全现场设备或其他...", 
"body" : "加载 功能 ：该命令会编译激活的应用程序并随后下载到控制器。 称呼 ： 菜单 在线的 要求 ：应用程序处于在线模式。 用命令引导 CODESYS 执行语法检查并生成应用程序代码。此代码被加载到控制器上。仍然生成 CODESYS 项目目录中的翻译日志 <project name>.<device name>.<application ID>.compileinfo . 加载时，除持久变量外，所有变量都会重新初始化。 如果安全控制器安装在控制器下方，此命令可以使用通信链路 暂时的 打断！ 安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的连接受到影响。作为反应，安全现场设备或其他安全控制器可以进入安全状态。只有当安全控制器通过现场总线连接到主控制器时，与开发系统的连接才会受到影响。 有关更多信息，请参阅： 下级安全控制器的描述 登录 命令描述了登录和下载时可能出现的情况。 如果您尝试在控制器上已安装该应用程序的相同版本时加载该应用程序，则会出现以下消息：“程序未更改。应用程序未加载”。 CODESYS 不会将应用程序加载到 PLC。 在消息类别中的消息窗口中出现加载时 翻译 正在进行的操作的日志（生成代码、执行初始化等）。还输出有关内存区域、代码大小、全局数据和分配内存的信息。与在线更改相比，为清楚起见不再列出更改的块。 " }, 
{ "title" : "命令：在线更改 ", 
"url" : "_cds_cmd_online_change.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：在线更改 ", 
"snippet" : "在线更改 功能 ：该命令用于启动对当前活动应用程序的在线更改。加载时 CODESYS 只有已经在控制器上运行的应用程序的更改部分被重新加载到控制器中。 称呼 ： 菜单 在线的 , 对象的上下文菜单 应用 要求 ：应用程序处于在线模式。 在设备树中选择应用程序时，该命令在上下文菜单中可用。因此，即使该应用程序当前不是“活动”应用程序，您也可以专门针对应用程序进行在线更改。 在线更改会更改正在运行的应用程序并且不会导致重新启动。 确保新的应用程序代码仍然会导致受控系统的预期行为。 根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。 执行在线更改时，不会执行应用程序特定的初始化（例如：...", 
"body" : "在线更改 功能 ：该命令用于启动对当前活动应用程序的在线更改。加载时 CODESYS 只有已经在控制器上运行的应用程序的更改部分被重新加载到控制器中。 称呼 ： 菜单 在线的 , 对象的上下文菜单 应用 要求 ：应用程序处于在线模式。 在设备树中选择应用程序时，该命令在上下文菜单中可用。因此，即使该应用程序当前不是“活动”应用程序，您也可以专门针对应用程序进行在线更改。 在线更改会更改正在运行的应用程序并且不会导致重新启动。 确保新的应用程序代码仍然会导致受控系统的预期行为。 根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。 执行在线更改时，不会执行应用程序特定的初始化（例如：归位），因为机器保留其状态。因此，新的程序代码可能达不到预期的效果。 指针变量保留上一个循环的值。当指针引用其值在在线更改中更改的变量时，该变量将不再产生正确的值。确保在每个周期中重新分配指针。 更改“父应用程序”后，执行在线更改时将从控制器中删除“子应用程序”。 快速在线更改期间没有初始化代码 由于编译器版本 >= 3.5.0.0，因此对较小的更改执行“快速在线更改”。在快速在线更改期间，仅编译和下载修改后的 POU。特别是，不会生成初始化代码。 对于具有的变量 init_on_onlchange 属性，这也导致 不 正在生成初始化代码。在通常的情况下，这没有影响，因为该属性通常用于用地址初始化变量。但是，在快速在线更改期间，不会发生变量更改其地址的情况。 但是，为了确保 init_on_onlchange 属性应用在整个应用程序代码中，一般对于应用程序你可以使用 no_fast_online_change 编译器定义禁用快速在线更改。为此，请在设备树中选择您的应用程序对象并单击 特性 在上下文菜单中。以下 建造 选项卡，添加 no_fast_online_change 编译器定义。 有关详细信息，请参阅： 建造加载列表时 CODESYS 在类别中的消息窗口中 翻译 还有更改的接口、受影响的变量和为其生成新代码的所有块。如果存储位置发生变化，则会出现一个对话框，提醒您可能与指针相关的问题。 在视图中 在线更改的内存保留 可以为项目的功能块配置用于在线更改的内存保留，这样在在线更改期间对功能块进行更改时，不必移动内存中的实例变量。 有关更多信息，请参阅： 为在线更改设置内存保留" }, 
{ "title" : "是什么阻止了在线更改？ ", 
"url" : "_cds_cmd_online_change.html#UUID-cdc45270-a748-554a-175e-be948d7ae781_id_ef254ea5d484e8d4c0a8640e019da19e_id_6e316fe7ee4c1585c0a86463711858ab", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：在线更改 \/ 是什么阻止了在线更改？ ", 
"snippet" : "在 CODESYS ，在执行某些操作后，将无法再对控制器进行在线更改。此后，应用程序始终必须完全重新编译。一个典型的案例是 全部清理 命令删除上次下载时存储的编译信息。但是，此类操作通常会生成您需要确认的警告。 但也有一些“正常”编辑操作会导致在下次登录时无法进行在线更改。因此，在程序 POU 中编辑时需要注意状态栏中的如下符号： .当这个符号变成红色时 , 只能执行到控制器的完整下载。双击符号打开 应用信息 与上次下载的差异列表的对话框。在对话框中，您还可以找到有关哪些更改阻止在线更改的信息。 有关更多信息，请参阅： 命令：登录 阻止在线更改的应用程序不同区域中的操作和更改： 检查功能 激活...", 
"body" : "在 CODESYS ，在执行某些操作后，将无法再对控制器进行在线更改。此后，应用程序始终必须完全重新编译。一个典型的案例是 全部清理 命令删除上次下载时存储的编译信息。但是，此类操作通常会生成您需要确认的警告。 但也有一些“正常”编辑操作会导致在下次登录时无法进行在线更改。因此，在程序 POU 中编辑时需要注意状态栏中的如下符号： .当这个符号变成红色时 , 只能执行到控制器的完整下载。双击符号打开 应用信息 与上次下载的差异列表的对话框。在对话框中，您还可以找到有关哪些更改阻止在线更改的信息。 有关更多信息，请参阅： 命令：登录 阻止在线更改的应用程序不同区域中的操作和更改： 检查功能 激活或删除检查功能 ( CheckBounds , CheckRange , CheckDiv 等等。） 检查函数的接口变化（包括插入和删除局部变量） 任务配置 更改配置设置 项目设置 的变化 编译选项 在该部分 想法 （Unicode、替换常量、登录断点） 的变化 编译器定义 应用程序属性 的变化 目标系统存储设置 （标签 建造 ) 构建块属性 选择权的改变 外部实施 （标签 建造 ) 任务局部全局变量列表 所有更改 功能模块 更改功能模块的基本模块（ EXTENDS FBbase )，包括插入或删除这样一个基本构建块 接口列表中的变化（ IMPLEMENTS ITF ) 例外：在列表末尾添加新接口 数据类型 将变量的数据类型从一种用户定义的数据类型更改为另一种用户定义的数据类型（例如，从 TON 到 TOF ) 将数据类型从用户定义的数据类型更改为基本数据类型（例如从 TON 到 TIME ) 注意：作为一种解决方法，您应该始终在更改数据类型的同时更改变量的名称。然后将变量初始化为新变量并删除旧变量。然后可以进行在线更改。 报警配置 更改警报数据库配置 更改闩锁变量的数量（也会影响数据库中的存储格式） 更改分布式警报的配置 数据源 配置中的所有更改 设备配置 设备树中的更改（也通过命令 更新设备 ) 更改设备配置：在标准情况下，无法在线更改设备参数。但是，可以在设备描述中配置例外。 注意：I\/O 映射到变量可以通过在线更改进行。 可视化 切换叠加功能 V3.5 SP6 之前：微量元素配置变更 注意：以下适用于 V3.5 SP6：在影响可视化或影响应用程序数据的在线更改（例如：插入新变量）的情况下，可视化完全重新初始化。例如，对于 TargetVisu，这意味着可视化关闭并随着起始页再次打开。在 WebvVisu 的情况下，可视化也会在短暂的等待时间后以启动可视化重新启动。 单位换算 插入或删除单位转换对象 趋势 更改变量数或最大变量数 使用描述或特殊行设置更改变量的数量 有关更多信息，请参阅： 执行在线更改 和 init_on_onlchange" }, 
{ "title" : "命令：加载源代码到连接的控制器 ", 
"url" : "_cds_cmd_source_download_connected_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：加载源代码到连接的控制器 ", 
"snippet" : "将源代码加载到连接的控制器 功能 ：该命令将项目的源代码作为项目存档加载到当前连接的控制器上。 称呼 ： 菜单 在线的 要求 ：应用程序处于在线模式。...", 
"body" : "将源代码加载到连接的控制器 功能 ：该命令将项目的源代码作为项目存档加载到当前连接的控制器上。 称呼 ： 菜单 在线的 要求 ：应用程序处于在线模式。 " }, 
{ "title" : "命令：多次下载 ", 
"url" : "_cds_cmd_multiple_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：多次下载 ", 
"snippet" : "多次下载 功能 ：该命令导致项目中包含的应用程序的代码生成和应用程序加载到相应的控制器上。 称呼 ： 菜单 在线的 该命令打开一个包含应用程序列表的对话框。在此对话框中选择要加载的应用程序。之后导致 CODESYS 执行这些应用程序的语法检查并生成相关代码。然后将代码加载到相应的控制器上。在项目目录中生成 CODESYS 带有每个选定应用程序名称的翻译日志 <project name>.<device name>.<application ID>.compileinfo . 如果安全控制器安装在控制器下方，此命令可以使用通信链路 暂时的 打断！ 安全控制器与其他安全控制器（通过安全网络变量）、...", 
"body" : "多次下载 功能 ：该命令导致项目中包含的应用程序的代码生成和应用程序加载到相应的控制器上。 称呼 ： 菜单 在线的 该命令打开一个包含应用程序列表的对话框。在此对话框中选择要加载的应用程序。之后导致 CODESYS 执行这些应用程序的语法检查并生成相关代码。然后将代码加载到相应的控制器上。在项目目录中生成 CODESYS 带有每个选定应用程序名称的翻译日志 <project name>.<device name>.<application ID>.compileinfo . 如果安全控制器安装在控制器下方，此命令可以使用通信链路 暂时的 打断！ 安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的连接受到影响。作为反应，安全现场设备或其他安全控制器可以进入安全状态。只有当安全控制器通过现场总线连接到主控制器时，与开发系统的连接才会受到影响。 有关更多信息，请参阅： 下级安全控制器" }, 
{ "title" : "对话：多次下载 ", 
"url" : "_cds_cmd_multiple_download.html#UUID-bff2081a-a86c-2315-20e6-97bba25d9cab_id_b6ceffd313d207c0a8640e01914b7b_id_f3237677278f5f78c0a8646372db20c9", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：多次下载 \/ 对话：多次下载 ", 
"snippet" : "请选择应用 : 应用选择 应用程序也被加载到不同的控制器上。 向上 , 向下 更改应用程序的下载顺序 应用程序按此列表的顺序加载到控制器上。默认情况下，此列表按字母顺序排序。考虑到应用程序的父子关系。 行 从语法上检查所有选定的应用程序 之后，在下载发生之前，为每个应用程序验证与关联控制器的通信。 在线更改选项 如果控制器上已存在较早版本且与当前版本不同，您有以下选项： 尝试在线更改。如果不能，请下载 默认启用 如果无法完成其中一个应用程序的在线更改，则执行下载。 强制在线更改。如果不可能，中止操作 如果（至少）其中一个应用程序无法完成在线更改，则不执行下载但中止；例如，如果您以前使用过该命令...", 
"body" : "请选择应用 : 应用选择 应用程序也被加载到不同的控制器上。 向上 , 向下 更改应用程序的下载顺序 应用程序按此列表的顺序加载到控制器上。默认情况下，此列表按字母顺序排序。考虑到应用程序的父子关系。 行 从语法上检查所有选定的应用程序 之后，在下载发生之前，为每个应用程序验证与关联控制器的通信。 在线更改选项 如果控制器上已存在较早版本且与当前版本不同，您有以下选项： 尝试在线更改。如果不能，请下载 默认启用 如果无法完成其中一个应用程序的在线更改，则执行下载。 强制在线更改。如果不可能，中止操作 如果（至少）其中一个应用程序无法完成在线更改，则不执行下载但中止；例如，如果您以前使用过该命令 清洁一切 已执行。 始终进行完整下载 将应用程序的所有部分加载到控制器上，而不考虑现有版本 对于控制器上尚不存在的选定应用程序 CODESYS 自动执行下载到相关控制器。 其他选项 删除控制器上所有未包含在项目中的应用程序 ：相应的应用程序被删除。 下载或在线更改后启动所有应用程序 ：应用程序在下载\/在线更改后启动。 不要释放强制变量 ：如果控制器上有一个带有强制变量的应用程序，并且此应用程序的实现同时发生了变化，则不会对此应用程序进行下载。 在窗口 多次下载 - 结果 此应用程序出现以下消息： 错误：因为一个或多个变量被强制而跳过 . 请注意，具有 key 属性的变量 PERSISTENT RETAIN 一般不初始化。但是，如果您更改数据布局，持久变量会自动重新初始化。 有关更多信息，请参阅： 数据持久化下载完成后，所有选定应用程序的列表将按照您配置的下载顺序显示。此外，您将在对话框中收到有关每个应用程序下载成功的信息 多次下载 - 结果 ： 已创建 ：一个新的应用程序已创建并加载到控制器上。 没有改变 ：控制器上已经存在的应用程序没有被改变。 已执行在线更改 ：控制器上已经存在的应用程序被在线更改更改。 已下载 ：控制器上已经存在的应用程序被新创建的应用程序替换。 由于无法在线更改而跳过 : 不能对应用进行在线修改，没有修改。 错误 : 下载此应用程序时出错。如有必要，将显示更多详细信息。 被用户取消 : 操作被用户取消。 有关更多信息，请参阅： 生成应用程序代码" }, 
{ "title" : "命令：重置冷 ", 
"url" : "_cds_cmd_reset_cold.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：重置冷 ", 
"snippet" : "冷复位 功能 ：该命令导致控制器上的活动应用程序冷启动。 称呼 ： 菜单 在线的 要求 ：应用程序处于在线模式。 如果安全控制器安装在控制器下方，此命令可以使用通信链路 暂时的 打断！ 安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的连接受到影响。作为反应，安全现场设备或其他安全控制器可以进入安全状态。只有当安全控制器通过现场总线连接到主控制器时，与开发系统的连接才会受到影响。 有关更多信息，请参阅： 从属安全控制 重启怎么办 冷复位 发生： 应用程序代码保留在控制器上。 变量初始化（用初始化值或默认初始化值0），之前的值丢失。 保留变量被初始化，之前的值丢失。 持久变量保...", 
"body" : "冷复位 功能 ：该命令导致控制器上的活动应用程序冷启动。 称呼 ： 菜单 在线的 要求 ：应用程序处于在线模式。 如果安全控制器安装在控制器下方，此命令可以使用通信链路 暂时的 打断！ 安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的连接受到影响。作为反应，安全现场设备或其他安全控制器可以进入安全状态。只有当安全控制器通过现场总线连接到主控制器时，与开发系统的连接才会受到影响。 有关更多信息，请参阅： 从属安全控制 重启怎么办 冷复位 发生： 应用程序代码保留在控制器上。 变量初始化（用初始化值或默认初始化值0），之前的值丢失。 保留变量被初始化，之前的值丢失。 持久变量保留值。 在代码中设置的断点保持状态（例如启用或禁用）。 申请进入状态 停止 . 顺便说一句，你也可以在调试应用程序时选择命令，并且这个状态 停止血压 站在断点处。然后要么立即执行热启动，要么首先处理当前循环的缺失语句。因此会出现一个消息窗口，您可以在其中选择进一步的行为。但是，仅当运行系统能够在没有先结束循环的情况下重新启动时，才会出现消息窗口。 后 重启 您可以像往常一样操作应用程序，例如，使用命令 调试 → 启动 开始执行。 有关更多信息，请参阅： 热复位 和 重置原点" }, 
{ "title" : "命令：ResetWarm ", 
"url" : "_cds_cmd_reset_warm.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：ResetWarm ", 
"snippet" : "热复位 功能 ：该命令会导致控制器上的活动应用程序热启动。 称呼 ： 菜单 在线的 要求 ：应用程序处于在线模式。 如果安全控制器安装在控制器下方，此命令可以使用通信链路 暂时的 打断！ 安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的连接受到影响。作为反应，安全现场设备或其他安全控制器可以进入安全状态。只有当安全控制器通过现场总线连接到主控制器时，与开发系统的连接才会受到影响。 有关更多信息，请参阅： 下级安全控制器重启怎么办 热复位 发生： 应用程序代码仍然加载在控制器上。 变量被初始化（使用初始化值或默认初始化值 0）。 保留变量保留其值。 持久变量保留值。 在代码中...", 
"body" : "热复位 功能 ：该命令会导致控制器上的活动应用程序热启动。 称呼 ： 菜单 在线的 要求 ：应用程序处于在线模式。 如果安全控制器安装在控制器下方，此命令可以使用通信链路 暂时的 打断！ 安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的连接受到影响。作为反应，安全现场设备或其他安全控制器可以进入安全状态。只有当安全控制器通过现场总线连接到主控制器时，与开发系统的连接才会受到影响。 有关更多信息，请参阅： 下级安全控制器重启怎么办 热复位 发生： 应用程序代码仍然加载在控制器上。 变量被初始化（使用初始化值或默认初始化值 0）。 保留变量保留其值。 持久变量保留值。 在代码中设置的断点保持状态（例如启用或禁用）。 申请进入状态 停止 . 顺便说一句，你也可以在调试应用程序的时候选择命令，并且在这个状态下 停止血压 站在断点处。然后要么立即进行热启动，要么先处理当前循环中仍然缺少的指令。因此会出现一个消息窗口，您可以在其中选择进一步的行为。但是，仅当运行系统能够在没有先结束循环的情况下重新启动时，才会出现消息窗口。 重置后，您可以像往常一样操作应用程序，例如使用命令 调试 → 启动 开始执行。 有关更多信息，请参阅： 重置应用程序 和 冷复位" }, 
{ "title" : "命令：重置原点 ", 
"url" : "_cds_cmd_reset_origin.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：重置原点 ", 
"snippet" : "重置原点 功能 ：该命令导致控制器上的活动应用程序的整体重置。 称呼 ： 菜单 在线的 要求 ：应用程序处于在线模式。 如果安全控制器安装在控制器下方，此命令可以使用通信链路 连续 打断！ 安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的连接受到影响。作为反应，安全现场设备或其他安全控制器可以进入安全状态。只有当安全控制器通过现场总线连接到主控制器时，与开发系统的连接才会受到影响。 有关更多信息，请参阅： 下级安全控制器重启怎么办 重置原点 发生： 申请代码被删除，所以申请没有状态。 变量被删除，值丢失。 保留变量被删除，值丢失。 持久变量被删除，值丢失。 在代码中设置的断...", 
"body" : "重置原点 功能 ：该命令导致控制器上的活动应用程序的整体重置。 称呼 ： 菜单 在线的 要求 ：应用程序处于在线模式。 如果安全控制器安装在控制器下方，此命令可以使用通信链路 连续 打断！ 安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的连接受到影响。作为反应，安全现场设备或其他安全控制器可以进入安全状态。只有当安全控制器通过现场总线连接到主控制器时，与开发系统的连接才会受到影响。 有关更多信息，请参阅： 下级安全控制器重启怎么办 重置原点 发生： 申请代码被删除，所以申请没有状态。 变量被删除，值丢失。 保留变量被删除，值丢失。 持久变量被删除，值丢失。 在代码中设置的断点会丢失。 有关更多信息，请参阅： 使用持久变量保存数据" }, 
{ "title" : "命令：重置源设备 ", 
"url" : "_cds_cmd_reset_origin_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：重置源设备 ", 
"snippet" : "重置源设备 功能 ：该命令打开一个对话框以将设备重置为其原始状态（交付状态）。设备上的所有应用程序、启动应用程序和剩余变量都将被删除。根据设备的版本，可以在此对话框中选择要删除的元素。如果在对话框中取消选择这些元素，它们不会随着重置而被删除并保留在控件上。 默认情况下，选择所有项目并删除所有内容。不可选择的元素通常也会被删除。 称呼 ：设备树中可编程设备的上下文菜单 如果安全控制器安装在控制器下方，此命令可以使用通信链路 连续 打断！ 安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的连接受到影响。作为反应，安全现场设备或其他安全控制器可以进入安全状态。只有当安全控制器通过现...", 
"body" : "重置源设备 功能 ：该命令打开一个对话框以将设备重置为其原始状态（交付状态）。设备上的所有应用程序、启动应用程序和剩余变量都将被删除。根据设备的版本，可以在此对话框中选择要删除的元素。如果在对话框中取消选择这些元素，它们不会随着重置而被删除并保留在控件上。 默认情况下，选择所有项目并删除所有内容。不可选择的元素通常也会被删除。 称呼 ：设备树中可编程设备的上下文菜单 如果安全控制器安装在控制器下方，此命令可以使用通信链路 连续 打断！ 安全控制器与其他安全控制器（通过安全网络变量）、现场设备和开发系统的连接受到影响。作为反应，安全现场设备或其他安全控制器可以进入安全状态。只有当安全控制器通过现场总线连接到主控制器时，与开发系统的连接才会受到影响。 有关更多信息，请参阅： 下级安全控制器重启怎么办 重置源设备 发生： 所有应用程序都与命令相同 重置原点 重启。 该命令创建的所有文件 重置原点 未记录 被删除（来自可视化、警报、配方等的文件） 用户管理被删除。 当前由运行时系统管理的所有证书都将被删除。 重置设备注意事项： 重置设备也会删除此对话框中选择的项目。如果在此对话框中未选择所有显示的对象，则其他对象可能无法再使用或也将被删除。 熄灭 : 执行命令时创建对象 重置源设备 关掉。 目的 过时的物品 熄灭 可以排除 列出的对象取决于控制器的版本。从版本 3.5.16.20 开始，可以从删除过程中排除以下对象： 用户管理 PLC逻辑 证书 " }, 
{ "title" : "命令：注销当前设备用户 ", 
"url" : "_cds_cmd_logoff_current_online_user.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：注销当前设备用户 ", 
"snippet" : "注销当前设备用户 象征： 功能 ：该命令注销当前登录到控制器的用户。什么时候 CODESYS 仍然有与控制器的连接，这将被终止。 称呼 ： 菜单 在线 → 安全 要求 ：应用程序处于在线模式。 访问保护装置 您可以从选项卡管理设备用户管理 用户和组 和 访问权限 设备编辑器。菜单命令 在线 → 安全 为您提供一种额外的简化方法来保护对目标设备的访问。 有关更多信息，请参阅： 设备用户管理的处理...", 
"body" : "注销当前设备用户 象征： 功能 ：该命令注销当前登录到控制器的用户。什么时候 CODESYS 仍然有与控制器的连接，这将被终止。 称呼 ： 菜单 在线 → 安全 要求 ：应用程序处于在线模式。 访问保护装置 您可以从选项卡管理设备用户管理 用户和组 和 访问权限 设备编辑器。菜单命令 在线 → 安全 为您提供一种额外的简化方法来保护对目标设备的访问。 有关更多信息，请参阅： 设备用户管理的处理" }, 
{ "title" : "命令：添加设备用户 ", 
"url" : "_cds_cmd_add_online_user.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：添加设备用户 ", 
"snippet" : "添加设备用户 象征： 功能 ：该命令轻松定义了自动添加到管理员组的新设备用户。 称呼 ： 菜单 在线 → 安全 要求 ：设备支持设备用户管理。您在设备上以用户身份登录。 访问保护装置 您可以从选项卡管理设备用户管理 用户和组 和 访问权限 设备编辑器。菜单命令 在线 → 安全 为您提供一种额外的简化方法来保护对目标设备的访问。 该命令打开对话框 添加设备用户 .您可以在此处指定新用户的访问数据。 该对话框对应于选项卡上的对话框 用户和组 设备编辑器的 用于添加新用户。 请始终使用强密码。应注意以下几点： 密码长度 >= 8 个字符（理想情况下 >= 12） 使用大写和小写 安装数字 使用特殊字...", 
"body" : "添加设备用户 象征： 功能 ：该命令轻松定义了自动添加到管理员组的新设备用户。 称呼 ： 菜单 在线 → 安全 要求 ：设备支持设备用户管理。您在设备上以用户身份登录。 访问保护装置 您可以从选项卡管理设备用户管理 用户和组 和 访问权限 设备编辑器。菜单命令 在线 → 安全 为您提供一种额外的简化方法来保护对目标设备的访问。 该命令打开对话框 添加设备用户 .您可以在此处指定新用户的访问数据。 该对话框对应于选项卡上的对话框 用户和组 设备编辑器的 用于添加新用户。 请始终使用强密码。应注意以下几点： 密码长度 >= 8 个字符（理想情况下 >= 12） 使用大写和小写 安装数字 使用特殊字符 不要在密码中使用现有名称和容易猜到的字符串（“123”、“abc”、“qwerty”等） 执行此操作后，您将无法再使用空的用户名和密码登录！你必须记住密码！ " }, 
{ "title" : "命令：删除设备用户 ", 
"url" : "_cds_cmd_remove_online_user.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：删除设备用户 ", 
"snippet" : "删除设备用户 象征： 功能 ：该命令将用户从目标系统（设备）上的用户管理中删除。 称呼 ： 菜单 在线 → 安全 要求 ：您在设备上以用户身份登录。 访问保护装置 您可以从选项卡管理设备用户管理 用户和组 和 访问权限 设备编辑器。菜单命令 在线 → 安全 为您提供一种额外的简化方法来保护对目标设备的访问。 该命令打开对话框 删除设备用户 .输入要删除的用户的用户名和密码并确认 行 . 执行此操作后，您将无法使用已删除用户的帐户登录！如果用户是目标系统上唯一指定的用户，您将收到无法删除该用户的消息。...", 
"body" : "删除设备用户 象征： 功能 ：该命令将用户从目标系统（设备）上的用户管理中删除。 称呼 ： 菜单 在线 → 安全 要求 ：您在设备上以用户身份登录。 访问保护装置 您可以从选项卡管理设备用户管理 用户和组 和 访问权限 设备编辑器。菜单命令 在线 → 安全 为您提供一种额外的简化方法来保护对目标设备的访问。 该命令打开对话框 删除设备用户 .输入要删除的用户的用户名和密码并确认 行 . 执行此操作后，您将无法使用已删除用户的帐户登录！如果用户是目标系统上唯一指定的用户，您将收到无法删除该用户的消息。 " }, 
{ "title" : "命令：更改设备用户密码 ", 
"url" : "_cds_cmd_change_password_online_user.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：更改设备用户密码 ", 
"snippet" : "更改设备用户密码 象征： 功能 ：该命令更改当前登录到控制器的用户的密码。 称呼 ： 菜单 在线 → 安全 要求 ：您在设备上以用户身份登录。 该命令打开定义新密码的对话框 更改设备用户密码 .您还必须再次输入旧密码。 执行此操作后，您将无法再使用之前的密码登录！ 请始终使用强密码。应注意以下几点： 密码长度 >= 8 个字符（理想情况下 >= 12） 使用大写和小写 安装数字 使用特殊字符 不要在密码中使用现有名称和容易猜到的字符串（“123”、“abc”、“qwerty”等） 有关更多信息，请参阅： 设备用户管理的处理...", 
"body" : "更改设备用户密码 象征： 功能 ：该命令更改当前登录到控制器的用户的密码。 称呼 ： 菜单 在线 → 安全 要求 ：您在设备上以用户身份登录。 该命令打开定义新密码的对话框 更改设备用户密码 .您还必须再次输入旧密码。 执行此操作后，您将无法再使用之前的密码登录！ 请始终使用强密码。应注意以下几点： 密码长度 >= 8 个字符（理想情况下 >= 12） 使用大写和小写 安装数字 使用特殊字符 不要在密码中使用现有名称和容易猜到的字符串（“123”、“abc”、“qwerty”等） 有关更多信息，请参阅： 设备用户管理的处理" }, 
{ "title" : "命令：停止对已处理异常的执行 ", 
"url" : "_cds_cmd_stop_execution_on_handled_exceptions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：停止对已处理异常的执行 ", 
"snippet" : "在处理的异常处停止执行 功能 ：该命令在错误位置停止应用程序，尽管已编程异常处理。 称呼 : 该命令默认不可用，但通过 工具 → 自定义 可配置。该命令在选项卡中 命令图标 在类别中 在线的 . 要求 ：该应用程序包含与操作员一起编程的异常处理 __TRY 和 __CATCH 并且在线。 当您在菜单中输入命令时 在线的 配置并在那里调用它，当前活动的应用程序会受到影响。然后，该命令将支持您进行故障排除。 有关更多信息，请参阅： __TRY, __CATCH, __FINALLY, __ENDTRY 和 菜单...", 
"body" : "在处理的异常处停止执行 功能 ：该命令在错误位置停止应用程序，尽管已编程异常处理。 称呼 : 该命令默认不可用，但通过 工具 → 自定义 可配置。该命令在选项卡中 命令图标 在类别中 在线的 . 要求 ：该应用程序包含与操作员一起编程的异常处理 __TRY 和 __CATCH 并且在线。 当您在菜单中输入命令时 在线的 配置并在那里调用它，当前活动的应用程序会受到影响。然后，该命令将支持您进行故障排除。 有关更多信息，请参阅： __TRY, __CATCH, __FINALLY, __ENDTRY 和 菜单" }, 
{ "title" : "命令：连接设备 ", 
"url" : "_cds_cmd_connect_to_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：连接设备 ", 
"snippet" : "连接到设备 功能 ：该命令与设备树中当前选择的设备建立连接。 称呼 ：设备的上下文菜单 要求 ：在设备树中选择了一个设备。通信设置已正确设置。...", 
"body" : "连接到设备 功能 ：该命令与设备树中当前选择的设备建立连接。 称呼 ：设备的上下文菜单 要求 ：在设备树中选择了一个设备。通信设置已正确设置。 " }, 
{ "title" : "命令：断开与设备的连接 ", 
"url" : "_cds_cmd_disconnect_from_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：断开与设备的连接 ", 
"snippet" : "与设备断开连接 功能 ：该命令断开与设备的现有连接。 称呼 ：设备的上下文菜单 要求 ：在设备树中选择了一个设备。...", 
"body" : "与设备断开连接 功能 ：该命令断开与设备的现有连接。 称呼 ：设备的上下文菜单 要求 ：在设备树中选择了一个设备。 " }, 
{ "title" : "命令：短闪 ", 
"url" : "_cds_cmd_wink.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：短闪 ", 
"snippet" : "短暂闪烁 象征： 功能 ：该命令使连接的控制器的 LED 短暂闪烁。这允许硬件被唯一地识别。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 在线的 粘贴到菜单中。 要求 ：控制器支持该功能，连接参数配置正确。...", 
"body" : "短暂闪烁 象征： 功能 ：该命令使连接的控制器的 LED 短暂闪烁。这允许硬件被唯一地识别。 称呼 ：该命令默认不包含在任何菜单中。您可以使用对话框找到他 工具 → 自定义 从命令类别 在线的 粘贴到菜单中。 要求 ：控制器支持该功能，连接参数配置正确。 " }, 
{ "title" : "命令：模拟 ", 
"url" : "_cds_cmd_simulation.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：模拟 ", 
"snippet" : "模拟 功能 ：该命令将开发系统切换到仿真模式。 称呼 ： 菜单 在线的 在模拟模式下，您可以在“模拟目标设备”上启动和调试活动应用程序。您不需要真正的目标设备来测试应用程序的在线行为。首次登录时，系统会询问您是否应创建和加载应用程序。您无需对模拟设备进行任何通信设置。在模拟模式 CODESYS 控制器在设备树中的条目以斜体显示。 登录成功后，红色三角形 设备树中的符号表示模拟模式。您可以使用相应的在线命令来测试应用程序。 要关闭模拟模式，请先注销控制器，然后再次选择命令 模拟 . 该命令始终会影响活动的应用程序。 这 PLC外壳 不支持模拟模式。...", 
"body" : "模拟 功能 ：该命令将开发系统切换到仿真模式。 称呼 ： 菜单 在线的 在模拟模式下，您可以在“模拟目标设备”上启动和调试活动应用程序。您不需要真正的目标设备来测试应用程序的在线行为。首次登录时，系统会询问您是否应创建和加载应用程序。您无需对模拟设备进行任何通信设置。在模拟模式 CODESYS 控制器在设备树中的条目以斜体显示。 登录成功后，红色三角形 设备树中的符号表示模拟模式。您可以使用相应的在线命令来测试应用程序。 要关闭模拟模式，请先注销控制器，然后再次选择命令 模拟 . 该命令始终会影响活动的应用程序。 这 PLC外壳 不支持模拟模式。 " }, 
{ "title" : "模拟与真实控制器操作之间的差异 ", 
"url" : "_cds_cmd_simulation.html#UUID-1e9f2166-cf60-2911-9295-8053f1f65558_id_fb4e48096e42d9c0a8640e0168cbf5_id_4c9f73c83797cddcc0a864631a9fb9dd", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：模拟 \/ 模拟与真实控制器操作之间的差异 ", 
"snippet" : "模拟 真正的控制 实时行为\/多核 跑进去 CODESYS - 具有正常优先级的进程 单核 -> 更差的实时行为 实时操作系统 单核或多核 建筑广度 模拟 64 位（取决于 CODESYS - 从安装） -> 如果应用程序以前仅使用 32 位运行（例如，当使用 DWORD 作为指针） 32位控制 FPU（舍入误差） 使用PC的FPU FPU异常的不同配置 使用控制器 FPU 或 FPU 仿真 FPU异常的不同配置 处理异常 Windows 运行时系统的异常处理 控制器的异常处理 外部库（Cmp\/Sys\/CAA\/OEM\/...） 实际上只有几个外部 cmp\/syslibs 可用。 与 Embedd...", 
"body" : "模拟 真正的控制 实时行为\/多核 跑进去 CODESYS - 具有正常优先级的进程 单核 -> 更差的实时行为 实时操作系统 单核或多核 建筑广度 模拟 64 位（取决于 CODESYS - 从安装） -> 如果应用程序以前仅使用 32 位运行（例如，当使用 DWORD 作为指针） 32位控制 FPU（舍入误差） 使用PC的FPU FPU异常的不同配置 使用控制器 FPU 或 FPU 仿真 FPU异常的不同配置 处理异常 Windows 运行时系统的异常处理 控制器的异常处理 外部库（Cmp\/Sys\/CAA\/OEM\/...） 实际上只有几个外部 cmp\/syslibs 可用。 与 Embedded 相比，SysLib 也可能更多。 SysLibs 的不同实现\/行为（Windows 与控件的操作系统相比） 下载期间的“未解决的参考错误”将被忽略。应用程序仍然可以加载到控制器上并启动。但是，如果实际调用了缺少的函数，它们会返回无意义的值。 因此，也可以为外部块指定 IEC 实现。然后在模拟中执行这个具有代表性的 IEC 代码。 如果控制器中没有外部库，则下载期间出现“未解决的参考错误” 输入输出驱动 I\/O 配置已创建但未评估。 不执行现场总线堆栈。 I\/O 通道没有更新，也没有发送总线报文。 大多没有限制，但取决于控制的可能性 SoftMotion 驱动程序 所有 SoftMotion 轴都设置为虚拟轴，因此是模拟的。 大多没有限制，但取决于控制的可能性 有关更多信息，请参阅： 在模拟模式下测试" }, 
{ "title" : "命令：操作模式 - 调试、锁定和操作 ", 
"url" : "_cds_cmd_operating_modes.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：操作模式 - 调试、锁定和操作 ", 
"snippet" : "操作模式 - 调试、锁定和操作 功能 ：命令将控制器置于防止项目被意外更改的状态。 称呼 ： 菜单 在线的 例如，您可以使用命令锁定控制器的状态，以防止在您在另一个控制器上编程时该控制器更改状态。 编程结束时，控制器应进入定义的外部可见状态，重启后完全一样。 符号显示在状态栏中 , 和 当前的操作模式。双击其中一个符号会打开一个帮助窗口。 如果控制器支持，您可以将控制器切换到以下操作模式： ： 调试 无限制 ： 锁定 应用程序的当前调试状态被锁定。不能设置更多的断点，也不能强制使用更多的变量。但是，可以写入已设置的变量和断点保持活动状态。 只有应用程序的“RUN”状态保持在操作模式中 锁定 也...", 
"body" : "操作模式 - 调试、锁定和操作 功能 ：命令将控制器置于防止项目被意外更改的状态。 称呼 ： 菜单 在线的 例如，您可以使用命令锁定控制器的状态，以防止在您在另一个控制器上编程时该控制器更改状态。 编程结束时，控制器应进入定义的外部可见状态，重启后完全一样。 符号显示在状态栏中 , 和 当前的操作模式。双击其中一个符号会打开一个帮助窗口。 如果控制器支持，您可以将控制器切换到以下操作模式： ： 调试 无限制 ： 锁定 应用程序的当前调试状态被锁定。不能设置更多的断点，也不能强制使用更多的变量。但是，可以写入已设置的变量和断点保持活动状态。 只有应用程序的“RUN”状态保持在操作模式中 锁定 也可以通过重启控制器获得。 在此状态下，开发人员可以防止自己或其他开发人员更改控制器上的应用程序，例如通过设置或删除断点、强制或更改文件系统。此操作模式有助于防止下载到错误的控制器，例如，如果系统中的多个控制器正在被编程。 ： 可以用了 此操作模式可确保控制器在重新启动后再次加载相同的应用程序，并且调试功能不再处于活动状态。当一个控制被完全编程并且要被接受或者已经是这种情况时，操作模式被设置。 激活操作模式的条件 可以用了 ： 控制器上的每个应用程序都必须有一个引导应用程序。 不得设置活动断点。 所有应用程序都必须正在运行。 不得有强制值。 此外，设备可以设置自己的限制。 操作模式 锁定 和 可以用了 在应用程序和激活操作模式的要求方面有所不同。但是，在这两种操作模式下，运行时系统都会阻止以下操作： 关于申请 下载应用程序 在线更改 强制变量 设置断点 停止申请 重置应用程序 开始申请 删除应用程序 关于控制器的文件传输 将文件下载到控制器 删除控制器上的文件 重命名控制器上的文件 在控制器上创建目录 删除控制器上的目录 重命名控制器上的目录 您可以选择以下操作模式 锁定 和 可以用了 不要切换。 " }, 
{ "title" : "命令：在下载时分配服务器应用程序 ", 
"url" : "_cds_assign_server_app_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 在线的 \/ 命令：在下载时分配服务器应用程序 ", 
"snippet" : "下载时分配服务器应用程序 该命令可用时 CODESYS Automation Server Connector 附加组件已安装。 该命令的描述可以在帮助中找到 CODESYS Automation Server 在 命令：在下载时分配服务器应用程序 ....", 
"body" : "下载时分配服务器应用程序 该命令可用时 CODESYS Automation Server Connector 附加组件已安装。 该命令的描述可以在帮助中找到 CODESYS Automation Server 在 命令：在下载时分配服务器应用程序 . " }, 
{ "title" : "调试 ", 
"url" : "_cds_f_commands_debug.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：开始 ", 
"url" : "_cds_cmd_start.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：开始 ", 
"snippet" : "开始 象征： 键盘快捷键： F5 功能 ：命令启动应用程序（状态 跑步 ）。 称呼 ： 菜单 调试 , 对象的上下文菜单 应用 要求 ：应用程序处于在线模式 停止 . 如果您使用菜单中的命令 调试 调用，它作用于当前活动的应用程序。 有关更多信息，请参阅： 下载应用程序代码、登录和启动 PLC...", 
"body" : "开始 象征： 键盘快捷键： F5 功能 ：命令启动应用程序（状态 跑步 ）。 称呼 ： 菜单 调试 , 对象的上下文菜单 应用 要求 ：应用程序处于在线模式 停止 . 如果您使用菜单中的命令 调试 调用，它作用于当前活动的应用程序。 有关更多信息，请参阅： 下载应用程序代码、登录和启动 PLC" }, 
{ "title" : "命令：停止 ", 
"url" : "_cds_cmd_stop.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：停止 ", 
"snippet" : "停止 象征： 键盘快捷键： 切换 + F8 功能 ：命令停止应用程序（状态 停止 ）。 称呼 ： 菜单 调试 , 对象的上下文菜单 应用 要求 ：应用程序处于在线模式 跑步 . 如果您使用菜单中的命令 调试 调用，它作用于当前活动的应用程序。...", 
"body" : "停止 象征： 键盘快捷键： 切换 + F8 功能 ：命令停止应用程序（状态 停止 ）。 称呼 ： 菜单 调试 , 对象的上下文菜单 应用 要求 ：应用程序处于在线模式 跑步 . 如果您使用菜单中的命令 调试 调用，它作用于当前活动的应用程序。 " }, 
{ "title" : "命令：单循环 ", 
"url" : "_cds_cmd_single_cycle.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：单循环 ", 
"snippet" : "单循环 键盘快捷键： 控制 + F5 功能 ：该命令执行一个周期的活动应用程序。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序处于程序步骤。...", 
"body" : "单循环 键盘快捷键： 控制 + F5 功能 ：该命令执行一个周期的活动应用程序。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序处于程序步骤。 " }, 
{ "title" : "命令：新断点 ", 
"url" : "_cds_cmd_new_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：新断点 ", 
"snippet" : "新断点 象征： 键盘快捷键： 老的 + F7 功能 ：命令打开对话框 断点属性 . 称呼 ： 菜单 调试 要求 ：应用程序必须处于在线模式。 用命令 新断点 在线模式下可以直接在当前光标位置设置新断点。 有关更多信息，请参阅： 使用断点...", 
"body" : "新断点 象征： 键盘快捷键： 老的 + F7 功能 ：命令打开对话框 断点属性 . 称呼 ： 菜单 调试 要求 ：应用程序必须处于在线模式。 用命令 新断点 在线模式下可以直接在当前光标位置设置新断点。 有关更多信息，请参阅： 使用断点" }, 
{ "title" : "命令：新建数据断点 ", 
"url" : "_cds_cmd_new_data_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：新建数据断点 ", 
"snippet" : "新数据断点 象征： 功能 ：命令打开对话框 新断点 . 称呼 ： 菜单 调试 要求 ： 该应用程序处于在线模式。 目标设备的设备描述文件包含“数据断点”功能的条目。目前，数据断点仅适用于 CODESYS Control Win 可能的。 有关更多信息，请参阅： 使用断点...", 
"body" : "新数据断点 象征： 功能 ：命令打开对话框 新断点 . 称呼 ： 菜单 调试 要求 ： 该应用程序处于在线模式。 目标设备的设备描述文件包含“数据断点”功能的条目。目前，数据断点仅适用于 CODESYS Control Win 可能的。 有关更多信息，请参阅： 使用断点" }, 
{ "title" : "命令：编辑断点 ", 
"url" : "_cds_cmd_edit_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：编辑断点 ", 
"snippet" : "编辑断点 象征： 功能 ：命令打开对话框 断点属性 . 称呼 ： 菜单 调试 要求 : 应用程序在线，光标在断点上。 有关更多信息，请参阅： 使用断点...", 
"body" : "编辑断点 象征： 功能 ：命令打开对话框 断点属性 . 称呼 ： 菜单 调试 要求 : 应用程序在线，光标在断点上。 有关更多信息，请参阅： 使用断点" }, 
{ "title" : "命令：启用断点 ", 
"url" : "_cds_cmd_activate_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：启用断点 ", 
"snippet" : "启用断点 功能 : 该命令启用一个禁用的断点。 称呼 ： 菜单 调试 要求 ：应用程序处于联机状态，光标位于停用的断点上。 有关更多信息，请参阅： 使用断点...", 
"body" : "启用断点 功能 : 该命令启用一个禁用的断点。 称呼 ： 菜单 调试 要求 ：应用程序处于联机状态，光标位于停用的断点上。 有关更多信息，请参阅： 使用断点" }, 
{ "title" : "命令：禁用断点 ", 
"url" : "_cds_cmd_deactivate_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：禁用断点 ", 
"snippet" : "禁用断点 功能 ：该命令禁用启用的断点。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，光标位于激活的断点上。 有关更多信息，请参阅： 使用断点...", 
"body" : "禁用断点 功能 ：该命令禁用启用的断点。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，光标位于激活的断点上。 有关更多信息，请参阅： 使用断点" }, 
{ "title" : "命令：切换断点 ", 
"url" : "_cds_cmd_toggle_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：切换断点 ", 
"snippet" : "断点切换 键盘快捷键： F9 功能 ：该命令设置断点或删除现有断点。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式。光标位于断点上。 有关更多信息，请参阅： 使用断点...", 
"body" : "断点切换 键盘快捷键： F9 功能 ：该命令设置断点或删除现有断点。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式。光标位于断点上。 有关更多信息，请参阅： 使用断点" }, 
{ "title" : "命令：程序步骤 ", 
"url" : "_cds_cmd_step_over.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：程序步骤 ", 
"snippet" : "程序步骤 象征： 键盘快捷键： F10 功能 ：该命令执行程序当前所在的语句，并在程序块中的下一条语句之前停止。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序在当前停止位置（调试模式）。 如果要执行的语句包含调用（来自程序、功能块实例、函数、方法或动作），则子块在一步中完全遍历并返回调用。然后它在下一条语句之前停止（在下一行代码上）。 选择命令 一小步 跳入一个从属的构建块，以便在单个步骤中执行它。 有关更多信息，请参阅： 逐步执行程序...", 
"body" : "程序步骤 象征： 键盘快捷键： F10 功能 ：该命令执行程序当前所在的语句，并在程序块中的下一条语句之前停止。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序在当前停止位置（调试模式）。 如果要执行的语句包含调用（来自程序、功能块实例、函数、方法或动作），则子块在一步中完全遍历并返回调用。然后它在下一条语句之前停止（在下一行代码上）。 选择命令 一小步 跳入一个从属的构建块，以便在单个步骤中执行它。 有关更多信息，请参阅： 逐步执行程序" }, 
{ "title" : "命令：单步 ", 
"url" : "_cds_cmd_step_into.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：单步 ", 
"snippet" : "单步 象征： 键盘快捷键： F8 功能 ：该命令执行程序当前所在的语句，并在下一条语句之前停止。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序在当前停止位置（调试模式）。 如果要执行的语句包含调用（来自程序、功能块实例、功能、方法或动作），则跳转到该从属编程块。它的代码出现在它自己的编辑器中。那里的第一条指令被执行，在下一条指令之前它被停止。然后新的当前停止位置在被调用的编程块中。 选择命令 程序步骤 留在当前活动的编程块中并一步完成调用。...", 
"body" : "单步 象征： 键盘快捷键： F8 功能 ：该命令执行程序当前所在的语句，并在下一条语句之前停止。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序在当前停止位置（调试模式）。 如果要执行的语句包含调用（来自程序、功能块实例、功能、方法或动作），则跳转到该从属编程块。它的代码出现在它自己的编辑器中。那里的第一条指令被执行，在下一条指令之前它被停止。然后新的当前停止位置在被调用的编程块中。 选择命令 程序步骤 留在当前活动的编程块中并一步完成调用。 " }, 
{ "title" : "命令：执行直到返回 ", 
"url" : "_cds_cmd_step_out.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：执行直到返回 ", 
"snippet" : "执行返回 象征： 键盘快捷键： 切换 + F10 功能 ：命令执行程序直到下一次返回，然后停止。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序在当前停止位置（调试模式）。 如果当前停止位置在从属编程器中，则一直运行到结束。然后它跳回到调用编程模块中的调用点并停在那里（与调用一致）。 如果当前停止位置在主程序中，则程序段将一直运行到最后。然后它跳回到开头（到程序块中第一行代码的程序开头）并停在那里。 有关更多信息，请参阅： __TRY, __CATCH, __FINALLY, __ENDTRY 和 菜单...", 
"body" : "执行返回 象征： 键盘快捷键： 切换 + F10 功能 ：命令执行程序直到下一次返回，然后停止。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序在当前停止位置（调试模式）。 如果当前停止位置在从属编程器中，则一直运行到结束。然后它跳回到调用编程模块中的调用点并停在那里（与调用一致）。 如果当前停止位置在主程序中，则程序段将一直运行到最后。然后它跳回到开头（到程序块中第一行代码的程序开头）并停在那里。 有关更多信息，请参阅： __TRY, __CATCH, __FINALLY, __ENDTRY 和 菜单" }, 
{ "title" : "命令：运行到光标处 ", 
"url" : "_cds_cmd_run_to_cursor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：运行到光标处 ", 
"snippet" : "运行到光标 象征： 功能 ：该命令将程序运行到光标指示的位置。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序在当前停止位置（调试模式）。您还用光标标记了任何编程块中的任何代码行。 当前停止位置和光标位置之间的语句是一步执行的。然后执行停止在光标位置，该位置成为下一个停止位置。请注意，您放置光标的代码行已到达但未执行。 有关更多信息，请参阅： __TRY, __CATCH, __FINALLY, __ENDTRY 和 菜单...", 
"body" : "运行到光标 象征： 功能 ：该命令将程序运行到光标指示的位置。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序在当前停止位置（调试模式）。您还用光标标记了任何编程块中的任何代码行。 当前停止位置和光标位置之间的语句是一步执行的。然后执行停止在光标位置，该位置成为下一个停止位置。请注意，您放置光标的代码行已到达但未执行。 有关更多信息，请参阅： __TRY, __CATCH, __FINALLY, __ENDTRY 和 菜单" }, 
{ "title" : "命令：设置下一条语句 ", 
"url" : "_cds_cmd_set_next_statement.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：设置下一条语句 ", 
"snippet" : "设置下一条语句 象征： 功能 : 该命令决定了接下来要执行的语句。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序在当前停止位置（调试模式）。您还用光标标记了任何编程块中的任何代码行。 用光标标记的代码行成为当前中断位置，不执行中间的语句或跳转到的语句。 有关更多信息，请参阅： 逐步执行程序...", 
"body" : "设置下一条语句 象征： 功能 : 该命令决定了接下来要执行的语句。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序在当前停止位置（调试模式）。您还用光标标记了任何编程块中的任何代码行。 用光标标记的代码行成为当前中断位置，不执行中间的语句或跳转到的语句。 有关更多信息，请参阅： 逐步执行程序" }, 
{ "title" : "命令：显示下一条语句 ", 
"url" : "_cds_cmd_show_next_statement.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：显示下一条语句 ", 
"snippet" : "显示下一条语句 象征： 功能 ：该命令显示将在下一步中处理的程序语句。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序在当前停止位置（调试模式）。保持位置位于您看不到的代码行上。 该命令使窗口显示当前停止位置，在代码中为黄色并带有图标 被标记，处于活动状态并且停止位置变得可见。当您打开许多编辑器并且保持位置隐藏在非活动编辑器中时，这很有用。 有关更多信息，请参阅： 逐步执行程序...", 
"body" : "显示下一条语句 象征： 功能 ：该命令显示将在下一步中处理的程序语句。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式，程序在当前停止位置（调试模式）。保持位置位于您看不到的代码行上。 该命令使窗口显示当前停止位置，在代码中为黄色并带有图标 被标记，处于活动状态并且停止位置变得可见。当您打开许多编辑器并且保持位置隐藏在非活动编辑器中时，这很有用。 有关更多信息，请参阅： 逐步执行程序" }, 
{ "title" : "命令：强制值 ", 
"url" : "_cds_cmd_force_values.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：强制值 ", 
"snippet" : "力值 键盘快捷键： F7 功能 ：该命令将控制器上的变量值永久设置为预定义值。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式。 在控制器上运行的应用程序中变量值的异常变化可能导致受控系统的不良行为。 在强制变量值之前评估潜在的危险并采取适当的安全预防措施。根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。 使用命令集 CODESYS 控制器上活动应用程序的一个或多个变量永久设置为定义值。 “强制”值由 标记的图标。 有关强制和准备值的工作原理，请参阅“强制和写入变量”联机帮助页。 命令 强制值[所有应用] ，它会影响项目中的所有应用程序，默认情况下不包含在菜单中。 有关更多...", 
"body" : "力值 键盘快捷键： F7 功能 ：该命令将控制器上的变量值永久设置为预定义值。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式。 在控制器上运行的应用程序中变量值的异常变化可能导致受控系统的不良行为。 在强制变量值之前评估潜在的危险并采取适当的安全预防措施。根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。 使用命令集 CODESYS 控制器上活动应用程序的一个或多个变量永久设置为定义值。 “强制”值由 标记的图标。 有关强制和准备值的工作原理，请参阅“强制和写入变量”联机帮助页。 命令 强制值[所有应用] ，它会影响项目中的所有应用程序，默认情况下不包含在菜单中。 有关更多信息，请参阅： 变量的强制和写入 和 使用观察列表" }, 
{ "title" : "命令：写入值 ", 
"url" : "_cds_cmd_write_values.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：写入值 ", 
"snippet" : "写入值 键盘快捷键： 控制 + F7 功能 ：该命令将控制器上的变量值设置为预定义值。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式。 在控制器上运行的应用程序中变量值的异常变化可能导致受控系统的不良行为。 在强制变量值之前评估潜在的危险并采取适当的安全预防措施。根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。 使用该命令，您可以将控制器上活动应用程序的一个或多个变量设置为定义的值。写入在下一个周期开始时发生一次。 您可以按如下方式准备值： 在字段中单击 准备值 在声明部分并输入新值。对于布尔变量，只需单击字段即可更改值。 在 FBD\/LAD\/IL 编辑器的实施部分中单击...", 
"body" : "写入值 键盘快捷键： 控制 + F7 功能 ：该命令将控制器上的变量值设置为预定义值。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式。 在控制器上运行的应用程序中变量值的异常变化可能导致受控系统的不良行为。 在强制变量值之前评估潜在的危险并采取适当的安全预防措施。根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。 使用该命令，您可以将控制器上活动应用程序的一个或多个变量设置为定义的值。写入在下一个周期开始时发生一次。 您可以按如下方式准备值： 在字段中单击 准备值 在声明部分并输入新值。对于布尔变量，只需单击字段即可更改值。 在 FBD\/LAD\/IL 编辑器的实施部分中单击 Inline Monitoring 字段并输入新值。 在字段中单击 准备值 在监控窗口中输入新值。 命令 写值【所有应用】 ，它会影响项目中的所有应用程序，默认情况下不包含在菜单中。 有关更多信息，请参阅： 变量的强制和写入" }, 
{ "title" : "命令：取消强制所有值 ", 
"url" : "_cds_cmd_unforce_all_values.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：取消强制所有值 ", 
"snippet" : "取消强制所有值 键盘快捷键： 老的 + F7 功能 ：该命令重置所有变量的强制。变量从控制器接收它们的实际值。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式。 命令 取消强制列表 功能与此命令相同，但不同之处在于：如果该命令 取消强制列表 如果无法对所有强制变量执行，则不会出现消息。 在控制器上运行的应用程序中变量值的异常变化可能导致受控系统的不良行为。 在强制变量值之前评估潜在的危险并采取适当的安全预防措施。根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。 命令 解除强制 [所有应用程序] ，它会影响项目中的所有应用程序，默认情况下不包含在菜单中。 有关更多信息，请参阅...", 
"body" : "取消强制所有值 键盘快捷键： 老的 + F7 功能 ：该命令重置所有变量的强制。变量从控制器接收它们的实际值。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式。 命令 取消强制列表 功能与此命令相同，但不同之处在于：如果该命令 取消强制列表 如果无法对所有强制变量执行，则不会出现消息。 在控制器上运行的应用程序中变量值的异常变化可能导致受控系统的不良行为。 在强制变量值之前评估潜在的危险并采取适当的安全预防措施。根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。 命令 解除强制 [所有应用程序] ，它会影响项目中的所有应用程序，默认情况下不包含在菜单中。 有关更多信息，请参阅： 力值 和 变量的强制和写入" }, 
{ "title" : "命令：强制<Device.Application>的所有值 ", 
"url" : "_cds_cmd_force_all_values_of_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：强制<Device.Application>的所有值 ", 
"snippet" : "强制<Device.Application>的所有值 功能 ：该命令将所选<Device.Application>的变量的所有值永久设置为预定义值。 称呼 ： 设备树中应用程序的上下文菜单 所选应用程序的 POU 编辑器中的上下文菜单 要求 ：应用程序处于在线模式。 在控制器上运行的应用程序中变量值的异常变化可能导致受控系统的不良行为。 在强制变量值之前评估潜在的危险并采取适当的安全预防措施。根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。 使用命令集 CODESYS 控制器上活动应用程序的一个或多个变量永久设置为定义值。此设置发生在处理循环的开始和结束时。处理顺序：1. 读取...", 
"body" : "强制<Device.Application>的所有值 功能 ：该命令将所选<Device.Application>的变量的所有值永久设置为预定义值。 称呼 ： 设备树中应用程序的上下文菜单 所选应用程序的 POU 编辑器中的上下文菜单 要求 ：应用程序处于在线模式。 在控制器上运行的应用程序中变量值的异常变化可能导致受控系统的不良行为。 在强制变量值之前评估潜在的危险并采取适当的安全预防措施。根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。 使用命令集 CODESYS 控制器上活动应用程序的一个或多个变量永久设置为定义值。此设置发生在处理循环的开始和结束时。处理顺序：1. 读取输入，2. 强制值，3. 过程代码，4. 强制值，5. 写入输出。 您可以按如下方式准备值： 在字段中单击 准备值 在声明部分并输入新值。对于布尔变量，只需单击字段即可更改值。 在 FBD\/LAD\/IL 编辑器的实施部分中单击 Inline Monitoring 字段并输入新值。 在字段中单击 准备值 在监控窗口中输入新值。 “强制”值由 标记的图标。 CODESYS 执行强制，直到用户明确取消强制，如下所示： 命令 取消强制所有值 命令 取消强制 '<Device.Application>' 的所有值 通过对话框取消力 准备价值 从应用程序中注销 命令 强制值[所有应用] ，它会影响项目中的所有应用程序，默认情况下不包含在菜单中。 有关更多信息，请参阅： 变量的强制和写入" }, 
{ "title" : "命令：写入<Device.Application>的所有值 ", 
"url" : "_cds_cmd_write_all_values_of_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：写入<Device.Application>的所有值 ", 
"snippet" : "写入<Device.Application>的所有值 功能 ：该命令将所选<Device.Application>的变量的所有值一次设置为预定义值。 称呼 ： 设备树中应用程序的上下文菜单 所选应用程序的 POU 的编辑器中的上下文菜单 要求 ：应用程序处于在线模式。 在控制器上运行的应用程序中变量值的异常变化可能导致受控系统的不良行为。 在强制变量值之前评估潜在的危险并采取适当的安全预防措施。根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。 使用该命令，您将控制器上选定的 <Device.Application> 的一个或多个变量设置为定义的值。写入在下一个周期开始时发生一次...", 
"body" : "写入<Device.Application>的所有值 功能 ：该命令将所选<Device.Application>的变量的所有值一次设置为预定义值。 称呼 ： 设备树中应用程序的上下文菜单 所选应用程序的 POU 的编辑器中的上下文菜单 要求 ：应用程序处于在线模式。 在控制器上运行的应用程序中变量值的异常变化可能导致受控系统的不良行为。 在强制变量值之前评估潜在的危险并采取适当的安全预防措施。根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。 使用该命令，您将控制器上选定的 <Device.Application> 的一个或多个变量设置为定义的值。写入在下一个周期开始时发生一次。 您可以按如下方式准备值： 单击声明部分的准备值字段并输入新值。对于布尔变量，只需单击字段即可更改值。 在 FBD\/LAD\/IL 编辑器的实施部分中单击 Inline Monitoring 字段并输入新值。 单击监控窗口中的准备值字段并输入新值。 有关更多信息，请参阅： 变量的强制和写入" }, 
{ "title" : "命令：解除<Device.Application>的所有值 ", 
"url" : "_cds_cmd_unforce_all_values_of_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：解除<Device.Application>的所有值 ", 
"snippet" : "解除<Device.Application>的所有值 功能 ：该命令重置所选<Device.Application>的变量的所有值的强制。变量从控制器接收它们的实际值。 称呼 ： 设备树中应用程序的上下文菜单 所选应用程序的 POU 的编辑器中的上下文菜单 要求 ：应用程序处于在线模式。 在控制器上运行的应用程序中变量值的异常变化可能导致受控系统的不良行为。 在强制变量值之前评估潜在的危险并采取适当的安全预防措施。根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。...", 
"body" : "解除<Device.Application>的所有值 功能 ：该命令重置所选<Device.Application>的变量的所有值的强制。变量从控制器接收它们的实际值。 称呼 ： 设备树中应用程序的上下文菜单 所选应用程序的 POU 的编辑器中的上下文菜单 要求 ：应用程序处于在线模式。 在控制器上运行的应用程序中变量值的异常变化可能导致受控系统的不良行为。 在强制变量值之前评估潜在的危险并采取适当的安全预防措施。根据受控系统的不同，可能会损坏系统和工件，或危及人的健康和生命。 " }, 
{ "title" : "命令：切换流量控制模式 ", 
"url" : "_cds_cmd_flowcontrol.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：切换流量控制模式 ", 
"snippet" : "切换流量控制模式 功能 ：该命令启用或禁用流量控制。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式。 在启用流控制的对话框中，可以从列表框中选择要应用流控制的任务。默认情况下， 自动选择任务 选项被选中。在设备树中，所选任务标记为 流量控制 。当流量控制模式使能时， 流控任务 → 选择此任务 和 流控任务 → 自动选择任务 设备树中所有任务的上下文菜单中提供了命令，以便选择另一个任务进行流量控制。 主动过程控制可延长应用程序的运行时间！ 如果选项 确认上线运行 在通信设置中激活，当流量控制打开时会出现一个消息框，通过该消息框仍然可以中止进程。 当流量控制被激活时，断点的使用和程序的逐步处...", 
"body" : "切换流量控制模式 功能 ：该命令启用或禁用流量控制。 称呼 ： 菜单 调试 要求 ：应用程序处于在线模式。 在启用流控制的对话框中，可以从列表框中选择要应用流控制的任务。默认情况下， 自动选择任务 选项被选中。在设备树中，所选任务标记为 流量控制 。当流量控制模式使能时， 流控任务 → 选择此任务 和 流控任务 → 自动选择任务 设备树中所有任务的上下文菜单中提供了命令，以便选择另一个任务进行流量控制。 主动过程控制可延长应用程序的运行时间！ 如果选项 确认上线运行 在通信设置中激活，当流量控制打开时会出现一个消息框，通过该消息框仍然可以中止进程。 当流量控制被激活时，断点的使用和程序的逐步处理是不可能的。 有关更多信息，请参阅： 流量控制" }, 
{ "title" : "命令：表示 - 二进制、十进制和十六进制 ", 
"url" : "_cds_cmd_display_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 调试 \/ 命令：表示 - 二进制、十进制和十六进制 ", 
"snippet" : "表示 - 二进制、十进制和十六进制 功能 ：子菜单命令 描写 用于设置在线监控时数值的显示格式。 称呼 ： 菜单 调试 要求 ：项目处于离线或在线模式。 表示格式“二进制”和“十六进制”是无符号的，“十进制”是有符号的。 有关更多信息，请参阅： 在编程对象中调用监控...", 
"body" : "表示 - 二进制、十进制和十六进制 功能 ：子菜单命令 描写 用于设置在线监控时数值的显示格式。 称呼 ： 菜单 调试 要求 ：项目处于离线或在线模式。 表示格式“二进制”和“十六进制”是无符号的，“十进制”是有符号的。 有关更多信息，请参阅： 在编程对象中调用监控" }, 
{ "title" : "工具 ", 
"url" : "_cds_f_commands_tools.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：包管理器 ", 
"url" : "_cds_cmd_package_manager.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：包管理器 ", 
"snippet" : "包管理器 象征： 功能 ：命令打开对话框 包管理器 ，您可以在其中安装、卸载和管理软件包。 称呼 ： 菜单 工具 您还可以从命令行将包管理器作为独立应用程序调用。 已经安装的包 已安装软件包列表 姓 , 版本 , 安装日期 , 更新信息 , 许可证信息 如果一个包从 CODESYS Store International 起源，标记 CODESYS 它带有红色包图标 而不是黄色图标 . 如果有可用更新，则显示 CODESYS 这在列中有一个条目 更新信息 并带有图标 在。 当一个包要被安装时，标记它 CODESYS 它带有图标 . 当软件包等待卸载时，标志 CODESYS 它带有图标 . 更新...", 
"body" : "包管理器 象征： 功能 ：命令打开对话框 包管理器 ，您可以在其中安装、卸载和管理软件包。 称呼 ： 菜单 工具 您还可以从命令行将包管理器作为独立应用程序调用。 已经安装的包 已安装软件包列表 姓 , 版本 , 安装日期 , 更新信息 , 许可证信息 如果一个包从 CODESYS Store International 起源，标记 CODESYS 它带有红色包图标 而不是黄色图标 . 如果有可用更新，则显示 CODESYS 这在列中有一个条目 更新信息 并带有图标 在。 当一个包要被安装时，标记它 CODESYS 它带有图标 . 当软件包等待卸载时，标志 CODESYS 它带有图标 . 更新 更新列表 安装 打开用于在文件系统中搜索包的标准对话框 文件类型默认为 *.package。 您还可以安装一个包的两个版本。 选择包后，对话框打开 检查包签名 . 带有签名信息的包将显示在对话框中。有关签名的详细信息显示在工具提示中，也显示在双击包时打开的对话框中。 允许未签名和自签名包 : 包应该被安装，尽管它是未签名或自签名的。 选择软件包后，安装向导会出现以下对话框： 安装 - 许可协议 在此对话框中显示 CODESYS 也是 校验和 的包。 仅在包包含许可协议时出现 选择安装类型 这些选项取决于包。 完成安装 ： CODESYS 安装所有组件 典型安装 ： CODESYS 安装包中定义的一组默认组件 定制安装 ： CODESYS 安装在对话框中选择的那些组件 安装 - 目标版本 ：您选择哪些现有目标版本应通过软件包安装进行更新。您必须至少选择一个版本配置文件。 成功完成此对话框后，选定的软件包就可以安装了。为了使软件包的安装自动启动和运行，所有 CODESYS - 实例已关闭。 卸载 卸载选定的包 什么时候 查看版本 未激活，已卸载 CODESYS 所选软件包的所有版本。 什么时候 查看版本 已启用并且您选择了一个顶级包节点，已卸载 CODESYS 所选软件包的所有版本。 什么时候 查看版本 已激活且您已选择单个软件包版本已卸载 CODESYS 正是这个版本。 对话结束后，每个人都必须 CODESYS 关闭实例以开始卸载包。 细节 打开所选包的对话框 细节 使用以下选项卡： 包装详情 姓 ： 包裹名字 版本 校验和 : 包的 SHA-1 校验和 提供者 版权 描述 安装日期 许可协议 安装日志 在后台检查更新 ： CODESYS 每次启动编程系统后自动搜索更新，然后每小时搜索一次。 查看版本 ：显示已安装包的所有版本 你可以 校验和 ， 这 CODESYS 在对话中 细节 并在对话中 安装 - 许可协议 安装向导的包提供程序的包校验和。这可确保您已安装原始软件包。 如果您在与先前版本相同的安装目录中安装更新版本的编程系统，则已安装的软件包的许可信息将被保留，并且 CODESYS 在对话框中显示信息 包管理器 在。 更新 检查更新 在您的系统中搜索 CODESYS Store International 所选软件包的更新 CODESYS 在列中显示找到的更新 更新信息 包裹清单。 下载 使用对话框安装更新包 包下载 在对话中 包下载 为此，请单击按钮 下载并安装 . 评估 提交包裹评估 CODESYS Store International 链接到商店主页 有关更多信息，请参阅： 安装和卸载软件包" }, 
{ "title" : "命令：库存储库 ", 
"url" : "_cds_cmd_library_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：库存储库 ", 
"snippet" : "图书馆存储库 象征： 功能 ：命令打开对话框 图书馆存储库 .在此对话框中，您指定哪些库安装在本地系统上，因此可用于您的应用程序。 称呼 ： 菜单 工具...", 
"body" : "图书馆存储库 象征： 功能 ：命令打开对话框 图书馆存储库 .在此对话框中，您指定哪些库安装在本地系统上，因此可用于您的应用程序。 称呼 ： 菜单 工具 " }, 
{ "title" : "对话框：库存储库 ", 
"url" : "_cds_cmd_library_repository.html#UUID-e51f7153-0441-0423-efa0-7c686a5e982f_id_afbbe45c2ee4c0a8640e008206fd_id_009a224eb32511e3a3e2f1561f0d131d", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：库存储库 \/ 对话框：库存储库 ", 
"snippet" : "地点 显示库文件所在的本地系统目录 这个图书馆 地点 在该地区 已安装的库 列出。 编辑 打开对话框 编辑存储库位置 您只能将空目录用于新存储库。 您还可以使用现有存储库作为存储位置。 这 System 无法编辑存储库。这由斜体条目表示。 对话 编辑存储库位置 存储库列表 地点 和 姓 添加 创建一个新的存储库 打开对话框 存储库的位置 所选目录（输入字段 地点 ) 必须为空或现有的有效存储库。 姓 是符号存储库名称的输入字段。 编辑 打开对话框 存储库的位置 （请参考 添加 ) 消除 将出现一个查询，询问是否应仅从存储库列表中删除条目，或者是否也应从文件系统中删除包含库文件的目录。如果要删除...", 
"body" : "地点 显示库文件所在的本地系统目录 这个图书馆 地点 在该地区 已安装的库 列出。 编辑 打开对话框 编辑存储库位置 您只能将空目录用于新存储库。 您还可以使用现有存储库作为存储位置。 这 System 无法编辑存储库。这由斜体条目表示。 对话 编辑存储库位置 存储库列表 地点 和 姓 添加 创建一个新的存储库 打开对话框 存储库的位置 所选目录（输入字段 地点 ) 必须为空或现有的有效存储库。 姓 是符号存储库名称的输入字段。 编辑 打开对话框 存储库的位置 （请参考 添加 ) 消除 将出现一个查询，询问是否应仅从存储库列表中删除条目，或者是否也应从文件系统中删除包含库文件的目录。如果要删除目录，则必须确认这一点。 已安装的库 树形结构的库列表 每个库的类别、名称、公司和版本的介绍 您可以从前面的图标中看出图书馆是否是数字图书馆 签署或 未签名。 公司 筛选显示库的选择列表 安装 打开对话框 选择图书馆 可能的过滤器： 翻译的 CODESYS 库（*.compiled-library） 已编译 CODESYS 库 (*.compiled-library, *.compiled-library-v3) 库 (*.library) 用于尚未翻译的图书馆项目 所有文件 （*。*） 卸载 卸载选定的库 出口 打开用于将库项目保存到本地文件系统的标准对话框 文件类型是 Library files (*.library) , Compiled library files (*.compiled-library) ， 或者 Compiled library files (*.compiled-library-v3) . 搜索 搜索库和功能块 打开对话框 搜索库 如果在输入字段中输入字符串，则显示 CODESYS 找到匹配的库。 细节 打开所选版本库的对话框 细节 带有图书馆项目信息的详细信息 关于按钮 更多的 在对话中 细节 您还将收到以下信息： 尺寸 : 以字节指定 生成 ： 创立日期 改变了 : 最后修改日期 上次访问 ： 日期 属性 特性 依赖关系 打开所选库的对话框 依赖关系 显示其他库的依赖关系 标题 , 版本 和 公司 为每个库参考显示。根据语法显示通过占位符起作用的引用 #<placeholder name> . 按类别分组 ：按图书馆类别分组 : 按字母排序 类别由外部描述文件“*.libcat.xml”定义。 图书馆简介 库配置文件定义了哪个库版本 CODESYS 在项目中设置特定编译器版本时解析库占位符。 进口 进口一个 *.libraryprofile -文件 如果导入已经包含占位符条目，您将被询问是否 CODESYS 这应该被覆盖。 出口 导出扩展名为“的 xml 文件” .libraryprofile “ 带有所选占位符条目的分配 您也可以只输入一个条目 编译器版本 选择。 占位符分辨率也可以在当前使用的目标设备中定义，甚至可以通过库管理器的占位符对话框中的特定本地规范来定义。 如果要加载编译器版本 < 3.5.18.0 的项目，则最好安装具有合适版本的 CODESYS 并使用它启动项目。 有关更多信息，请参阅： 图书馆经理 和 库参考转换" }, 
{ "title" : "命令：许可证管理器 ", 
"url" : "_cds_cmd_license_manager.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：许可证管理器 ", 
"snippet" : "许可证管理器 象征： 功能 ：该命令打开配置许可证的向导 CODESYS 附加产品。向导首先会启动 许可证管理器 – 选择目标 对话。 称呼 ： 工具 菜单 许可证管理器可以处理 CODESYS 本地计算机上的附加产品以及设备上运行时附加产品的许可证。它既支持在软件容器中安装，也支持在加密狗上安装。 产品订阅的许可证更新将自动完成。您可以在 许可证管理器 。...", 
"body" : "许可证管理器 象征： 功能 ：该命令打开配置许可证的向导 CODESYS 附加产品。向导首先会启动 许可证管理器 – 选择目标 对话。 称呼 ： 工具 菜单 许可证管理器可以处理 CODESYS 本地计算机上的附加产品以及设备上运行时附加产品的许可证。它既支持在软件容器中安装，也支持在加密狗上安装。 产品订阅的许可证更新将自动完成。您可以在 许可证管理器 。 " }, 
{ "title" : "对话框：许可证管理器 – 选择目标 ", 
"url" : "_cds_cmd_license_manager.html#UUID-4c91bfd0-6e5a-4a63-c33f-74e8df7f1048_id_ede5cbc7f814a56fc0a8640e0110cfc6_id_c2501cd1580911e887f0cb8e1905b970", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：许可证管理器 \/ 对话框：许可证管理器 – 选择目标 ", 
"snippet" : "这是许可证管理器向导的启动对话框。在这里您可以决定许可证的安装位置。 工作站 本地计算机 设备 控制器 必须正确配置与此设备的连接才能执行许可操作（ 通信设置 选项卡）。 点击后 下一个 ，您可以决定要管理许可证的容器。...", 
"body" : "这是许可证管理器向导的启动对话框。在这里您可以决定许可证的安装位置。 工作站 本地计算机 设备 控制器 必须正确配置与此设备的连接才能执行许可操作（ 通信设置 选项卡）。 点击后 下一个 ，您可以决定要管理许可证的容器。 " }, 
{ "title" : "对话框：许可证管理器 – 选择容器 ", 
"url" : "_cds_cmd_license_manager.html#UUID-4c91bfd0-6e5a-4a63-c33f-74e8df7f1048_id_ede5cbc7f814a56fc0a8640e0110cfc6_id_427f0789b3f411e3b5a0cccd02e48994", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：许可证管理器 \/ 对话框：许可证管理器 – 选择容器 ", 
"snippet" : "加密狗 必须将相应的加密狗连接到计算机或设备。并非所有设备都支持加密狗。 软容器 CODESYS 安全密钥 相应的软容器必须在 CodeMeter 控制中心注册。 CODESYS 安装提供了一个软容器。 如果您在本地计算机上安装产品 ( 工作站 ），然后 许可证管理器 立即打开，供您选择加密狗或软容器以及后续操作。选择容器类型并点击 下一个 。 如果您正在为控制器授权附加产品，则单击后将首先打开对话框以选择网络中的设备 下一个 。该对话框对应于 通信设置 设备编辑器的选项卡。...", 
"body" : "加密狗 必须将相应的加密狗连接到计算机或设备。并非所有设备都支持加密狗。 软容器 CODESYS 安全密钥 相应的软容器必须在 CodeMeter 控制中心注册。 CODESYS 安装提供了一个软容器。 如果您在本地计算机上安装产品 ( 工作站 ），然后 许可证管理器 立即打开，供您选择加密狗或软容器以及后续操作。选择容器类型并点击 下一个 。 如果您正在为控制器授权附加产品，则单击后将首先打开对话框以选择网络中的设备 下一个 。该对话框对应于 通信设置 设备编辑器的选项卡。 " }, 
{ "title" : "对话框：许可证管理器 – 概述 ", 
"url" : "_cds_cmd_license_manager.html#UUID-4c91bfd0-6e5a-4a63-c33f-74e8df7f1048_id_ede5cbc7f814a56fc0a8640e0110cfc6_id_9842496a67cfbaa3c0a864630673a51d", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：许可证管理器 \/ 对话框：许可证管理器 – 概述 ", 
"snippet" : "许可证 所有已安装的列表 CODESYS 受许可并在计算机或设备上找到的产品。当从容器提供许可证时，容器将显示为许可证列表中的节点。 前置符号表示许可证是否存在于计算机上并且是否有效。 窗口右侧显示所选产品及其相应许可证的以下信息： 姓名 公司 单位计数器 許可證數量 使用期限 特征图 激活时间 到期时间 公司代码 产品代码 描述 安装许可证 打开 在 <计算机> 上安装许可证 – 选择操作 对话： 激活许可证 ：打开 在 <计算机> 上安装许可证 – 激活许可证 对话（更多内容见下文） 申请许可证 ：打开 在 <计算机> 上安装许可证 – 请求许可证 对话（更多内容见下文） 安装许可证 ：打...", 
"body" : "许可证 所有已安装的列表 CODESYS 受许可并在计算机或设备上找到的产品。当从容器提供许可证时，容器将显示为许可证列表中的节点。 前置符号表示许可证是否存在于计算机上并且是否有效。 窗口右侧显示所选产品及其相应许可证的以下信息： 姓名 公司 单位计数器 許可證數量 使用期限 特征图 激活时间 到期时间 公司代码 产品代码 描述 安装许可证 打开 在 <计算机> 上安装许可证 – 选择操作 对话： 激活许可证 ：打开 在 <计算机> 上安装许可证 – 激活许可证 对话（更多内容见下文） 申请许可证 ：打开 在 <计算机> 上安装许可证 – 请求许可证 对话（更多内容见下文） 安装许可证 ：打开 在 <计算机> 上安装许可证 – 安装许可证 对话（更多内容见下文） 附加功能 打开菜单并执行以下操作： 眨眼 ：计算机上相应的许可证加密狗闪烁。 返还许可证 ：打开 返还许可证 （更多内容见下文） 恢复许可证 ：此功能仅在设备许可的情况下可用。打开 恢复许可证 对话（更多内容见下文） 更新容器 ：再次创建包含所有检测到的容器的列表框。 在 <计算机> 上安装许可证 – 激活许可证 当您有互联网连接时，这是通过许可证服务器激活可用许可证的推荐方法。要求：计算机有互联网连接。 票证编号 输入您从软件供应商处收到的票证 ID 的字段 票证 ID 由 5 个区块组成，每个区块包含 5 个字母数字字符。 例子： LYSQ3-ZU93K-24LWC-XGWJ8-5AY7H 许可证服务器 提供激活产品许可证的许可证服务器列表框 您可以从软件供应商处获取服务器 URL。 容器 应安装许可证的容器或加密狗的列表框。 从存储库中选择票证 打开 许可证存储库 对话 下一个 CODESYS 建立与许可证服务器的连接。 如果指定的票证仅包含一个许可证，则会在服务器操作完成后打开一个对话框以确认激活成功。 如果指定的票证包含多个许可证，则 安装许可证 – 选择许可证 对话框打开并显示这些许可证的列表（见下面的说明）。 安装许可证 – 选择许可证 选择要为票证激活的许可证，这些许可证是您在 安装许可证 – 激活许可证 对话 姓名 产品名称 可用的 可用许可证数量 用过的 已使用许可证的数量 全部的 所有已使用和可用许可证的总和 下一个 CODESYS 建立与许可证服务器的连接。服务器操作成功完成后，将打开一个对话框，确认激活。 在 <计算机> 上安装许可证 – 请求许可证 如果计算机没有互联网连接，则可以使用此对话框生成上下文文件。然后，此文件 (WibuCmRaC) 通过支持互联网的计算机传输到许可证服务器。激活完成后，将提供许可证更新文件 (WibuCmRaU) 供下载。 软件供应商 提供产品激活许可证的软件供应商的公司代码的输入字段 或者，您也可以从列表框中选择软件供应商。 容器 应生成上下文文件的容器或加密狗的列表框。 上下文文件 地点和名称 在 <计算机> 上安装许可证 – 安装许可证 如果您在软件激活期间从 Internet 下载了许可证更新文件，则可以使用此对话框在加密狗上安装许可证。为此，请指定所需的容器或加密狗 容器 并在输入字段中指定许可证更新文件的路径 文件 。 返还许可证 如果许可证允许，您可以“返回”它，以便稍后在另一台计算机上重新激活它。 票证编号 用于指定许可的票证 ID 的字段 许可证服务器 用于选择提供激活产品许可证的许可证服务器的列表框 您可以从软件供应商处获取服务器 URL。 加载许可证 用于显示服务器上为给定票证 ID 安装的所有当前许可证的按钮 许可证 窗户 许可证 服务器上指定票证 ID 的可用许可证列表 所选许可证的以下信息显示在右侧窗口旁边： 姓名 激活次数 允许退货 激活类型 激活日期 公司代码 评论 退回许可证 返回所选许可证的按钮 这些可以稍后在另一个系统上重新激活。 安装许可证 – 恢复许可证 激活后，设备许可证将保存到文件 ( *.WibuCmRau ) 在本地计算机上，并在“ CODESYS 中央许可证服务器”。如果丢失，可以从此文件恢复到相同的设备。 此过程仅适用于以 128... 开头并使用 CodeMeter Embedded 的许可证： CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ 对于以 130... 开头的基于 UFC 的较新许可证，请参阅： 备份和恢复 Wibu SL 许可证 票证编号 用于指定已执行许可的票证 ID 的字段 恢复 如果找到相应的许可证备份文件，则许可证将在设备中重新激活。 有关详细信息，请参阅：For more information, see: 许可证库" }, 
{ "title" : "命令：许可证存储库 ", 
"url" : "_cds_cmd_license_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：许可证存储库 ", 
"snippet" : "许可证库 象征： 功能 ：命令打开对话框 许可证库 查看有关单个许可证的信息。 称呼 ： 菜单 工具 要求 ： CODESYS 处于离线或在线模式。 在许可证存储库中，输入票号后，您将从中央许可证服务器收到有关许可证的信息。 您可以从剪贴板粘贴票号或从文本文件中导入票号。 门票 <导入存储库的许可证管理组件票证 ID 列表> 许可证 如果您在工单列表中选择一个条目，许可组件的名称和状态将在此处显示。 : 许可证可用且有效。 : 许可证找到了，但是无效。 : 没有找到许可证。 在对话框的右侧，您将获得有关此许可证的以下信息： 姓 ：要授权的产品名称 项目编号 ：许可证服务器中的文章编号 允许退货...", 
"body" : "许可证库 象征： 功能 ：命令打开对话框 许可证库 查看有关单个许可证的信息。 称呼 ： 菜单 工具 要求 ： CODESYS 处于离线或在线模式。 在许可证存储库中，输入票号后，您将从中央许可证服务器收到有关许可证的信息。 您可以从剪贴板粘贴票号或从文本文件中导入票号。 门票 <导入存储库的许可证管理组件票证 ID 列表> 许可证 如果您在工单列表中选择一个条目，许可组件的名称和状态将在此处显示。 : 许可证可用且有效。 : 许可证找到了，但是无效。 : 没有找到许可证。 在对话框的右侧，您将获得有关此许可证的以下信息： 姓 ：要授权的产品名称 项目编号 ：许可证服务器中的文章编号 允许退货 : 可以停用此许可证，以便可以在另一个系统上再次激活它。 可启用 ：您可以通过许可证管理器激活许可证。 激活次数 : 之前的激活次数 激活日期 : 当前激活日期 集装箱序列号 公司代码 评论 进口车票 出现浏览本地文件系统的标准对话框。如果您打开一个包含一个或多个“票据”（即许可证号）的文本文件，这些将被导入到存储库中。或者，您也可以将剪贴板中的数字粘贴到列表中。 有关更多信息，请参阅： 管理包和许可证 和 许可证管理器" }, 
{ "title" : "命令：设备存储库 ", 
"url" : "_cds_cmd_device_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：设备存储库 ", 
"snippet" : "设备存储库 象征： 功能 ：命令打开对话框 设备存储库 .此对话框用于管理安装在本地系统和系统中的设备。 CODESYS -项目可以集成。 称呼 ： 菜单 工具...", 
"body" : "设备存储库 象征： 功能 ：命令打开对话框 设备存储库 .此对话框用于管理安装在本地系统和系统中的设备。 CODESYS -项目可以集成。 称呼 ： 菜单 工具 " }, 
{ "title" : "对话框：设备存储库 ", 
"url" : "_cds_cmd_device_repository.html#UUID-c7973f6f-9c3e-2045-8831-d042c5a98295_id_ad0cf3f4f3c53320c0a8640e00a42838_id_8c4c14bcb0f111e3bd3cdc72696803d0", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：设备存储库 \/ 对话框：设备存储库 ", 
"snippet" : "您不得手动更改内部设备存储库。 您不得将任何文件复制到存储库或从其他任何地方！您必须始终使用设备存储库对话框来安装或卸载设备！ 地点 显示本地系统上的设备存储库目录 选择列表显示当前配置的存储位置。默认设置 CODESYS 安装的系统存储库。所选位置的设备将出现在范围内 已安装的设备说明 列出。 编辑 打开对话框 更改存储库位置 对话 更改存储库位置 存储库列表 地点 和 姓 添加 创建一个新的存储库 打开对话框 存储库位置 所选目录（输入字段 地点 ) 必须为空或现有的有效存储库。 编辑 打开对话框 存储库位置 （请参考 添加） 消除 将出现一个询问，询问相应的目录是否也应从硬盘中删除。 已...", 
"body" : "您不得手动更改内部设备存储库。 您不得将任何文件复制到存储库或从其他任何地方！您必须始终使用设备存储库对话框来安装或卸载设备！ 地点 显示本地系统上的设备存储库目录 选择列表显示当前配置的存储位置。默认设置 CODESYS 安装的系统存储库。所选位置的设备将出现在范围内 已安装的设备说明 列出。 编辑 打开对话框 更改存储库位置 对话 更改存储库位置 存储库列表 地点 和 姓 添加 创建一个新的存储库 打开对话框 存储库位置 所选目录（输入字段 地点 ) 必须为空或现有的有效存储库。 编辑 打开对话框 存储库位置 （请参考 添加） 消除 将出现一个询问，询问相应的目录是否也应从硬盘中删除。 已安装的设备说明 多级树形结构中的设备描述列表 每个设备描述的介绍与 姓 , 制造商 和 版本 顶部节点代表设备类别，例如控制器、现场总线或逻辑设备。 用于在所有设备中进行全文搜索的字符串 单击此字段使其可编辑。如果输入任何字符串，则只有包含该字符串的设备会显示在下方窗口中。匹配的字符串在这些设备上以黄色突出显示。 制造商 显示可用设备的制造商的选择列表 安装 打开对话框 安装设备说明 对于文件类型“.devdesc.xml”的默认设备 您还可以选择制造商特定的描述文件，例如 PROFIBUS DP 模块的“*gsd”文件、CAN 设备的 *.eds 和 dcf 文件。 如果您选择 行 确认添加 CODESYS 在设备存储库中输入新设备。安装过程中出现错误（例如缺少设备描述引用的文件）。 CODESYS 在设备存储库对话框的下部。 卸载 卸载选定的设备 如果您从设备存储库中删除该设备，则它不再可用于编程系统。 更新设备存储库 更新设备存储库中的所有设备 当新版本的导入插件可用时，某些设备描述可能已过时。受影响的设备标有 符号 标记。该命令将打开一个对话框以确认更新。 下载缺失的描述 当您在项目中使用设备存储库中不存在的设备时出现 运行该命令时，将显示丢失设备的列表。您可以在那里选择合适的设备进行下载。 细节 打开对话框 细节 对于选定的设备描述 该对话框包含来自设备描述文件的附加信息。 安装时复制 CODESYS 设备描述文件和它们引用的任何其他文件到内部存储位置。这意味着对原始文件的更改不再对已安装的设备产生任何影响。要使此类更改生效，您必须重新安装设备。建议修改后更改设备描述的内部版本号。 " }, 
{ "title" : "命令：自定义 ", 
"url" : "_cds_cmd_customize.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：自定义 ", 
"snippet" : "调整 功能 ：命令打开对话框 调整 .在此对话框中，您可以根据自己的要求调整菜单、工具栏和键盘布局。 称呼 ： 菜单 工具 有关更多信息，请参阅： 自定义菜单...", 
"body" : "调整 功能 ：命令打开对话框 调整 .在此对话框中，您可以根据自己的要求调整菜单、工具栏和键盘布局。 称呼 ： 菜单 工具 有关更多信息，请参阅： 自定义菜单" }, 
{ "title" : "命令：选项 ", 
"url" : "_cds_cmd_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：选项 ", 
"snippet" : "选项 功能 ：命令打开对话框 选项 配置 CODESYS -选项。这些选项定义了 CODESYS -用户界面。 CODESYS 将设置保存在本地系统上的当前用户配置文件中。当前配置文件提供默认设置。 称呼 ： 菜单 工具...", 
"body" : "选项 功能 ：命令打开对话框 选项 配置 CODESYS -选项。这些选项定义了 CODESYS -用户界面。 CODESYS 将设置保存在本地系统上的当前用户配置文件中。当前配置文件提供默认设置。 称呼 ： 菜单 工具 " }, 
{ "title" : "命令：导入和导出选项 ", 
"url" : "_cds_cmd_import_export_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：导入和导出选项 ", 
"snippet" : "导入和导出选项 功能 ：命令打开对话框 导入和导出选项 .在这里您可以导出或导入选定的设置 CODESYS - 配置选项。设置导出到具有默认扩展名的 XML 文件 options.xml 保存。 称呼 ： 菜单 工具...", 
"body" : "导入和导出选项 功能 ：命令打开对话框 导入和导出选项 .在这里您可以导出或导入选定的设置 CODESYS - 配置选项。设置导出到具有默认扩展名的 XML 文件 options.xml 保存。 称呼 ： 菜单 工具 " }, 
{ "title" : "对话框：导入和导出选项 ", 
"url" : "_cds_cmd_import_export_options.html#UUID-25bc3cff-9cbf-00c6-2e4e-eb5e83058ec6_id_f16f26eccdc7cec0a864631a9a7d9e_id_290c9402ed02fe4ec0a864633381844a", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：导入和导出选项 \/ 对话框：导入和导出选项 ", 
"snippet" : "导出选定的选项 选择选项 ：在表格中，您可以选择机器（计算机）的类别或应将当前设置导出到 XML 文件的用户相关选项。 文件 : 本地文件系统中导出文件的路径 例子： D:\\system1.options.xml 按钮 ：打开标准对话框以搜索现有文件或在本地文件系统中创建新文件 这 文件类型 Optionenexport (*.options.xml) 是预设的。 导入选定的选项 文件 ：要导入其内容的选项导出文件的路径 按钮 ：打开标准对话框以搜索文件类型 Optionenexport (*.options.xml) 在本地文件系统中 关闭对话框后 行 文件中描述的设置被传输到项目中。 有关...", 
"body" : "导出选定的选项 选择选项 ：在表格中，您可以选择机器（计算机）的类别或应将当前设置导出到 XML 文件的用户相关选项。 文件 : 本地文件系统中导出文件的路径 例子： D:\\system1.options.xml 按钮 ：打开标准对话框以搜索现有文件或在本地文件系统中创建新文件 这 文件类型 Optionenexport (*.options.xml) 是预设的。 导入选定的选项 文件 ：要导入其内容的选项导出文件的路径 按钮 ：打开标准对话框以搜索文件类型 Optionenexport (*.options.xml) 在本地文件系统中 关闭对话框后 行 文件中描述的设置被传输到项目中。 有关更多信息，请参阅： CODESYS" }, 
{ "title" : "命令：导出安装配置 ", 
"url" : "_cds_cmd_export_installation_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：导出安装配置 ", 
"snippet" : "导出安装配置 函数 : 该命令导出当前的配置文件 CODESYS 安装到格式为的文件 .installation-config 。导出文件包含有关版本的信息 CODESYS 以及已安装的插件。 默认情况下，安装配置包含在项目存档中，该存档文件是使用创建的 文件 → 项目档案 → 保存档案 命令。 打电话 : 工具 菜单...", 
"body" : "导出安装配置 函数 : 该命令导出当前的配置文件 CODESYS 安装到格式为的文件 .installation-config 。导出文件包含有关版本的信息 CODESYS 以及已安装的插件。 默认情况下，安装配置包含在项目存档中，该存档文件是使用创建的 文件 → 项目档案 → 保存档案 命令。 打电话 : 工具 菜单 " }, 
{ "title" : "命令：设备许可证读取器 ", 
"url" : "_cds_cmd_device_reader.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 工具 \/ 命令：设备许可证读取器 ", 
"snippet" : "设备许可证阅读器 功能 ：该命令打开标准对话框 选择设备 选择一个控件后，读出该控件的许可证和产品信息。此许可证和产品信息显示在对话框中 设备许可证阅读器 显示。 称呼 ： 菜单 工具 要求 : 控制器上没有应用程序。 如果在控制器上有应用程序时选择了命令，则在对话框中询问用户是否应从控制器中删除所有应用程序。如果用户单击此对话框 不 点击，命令 设备许可证阅读器 取消。 对话 设备许可证阅读器 可用设备功能的状态 产品 CODESYS -产品 例子： SoftMotion 特征 特点 产品 例子： CNC 是一个 特征 从 SoftMotion . 许可证有效\/数量 Yes ：该功能有许可证...", 
"body" : "设备许可证阅读器 功能 ：该命令打开标准对话框 选择设备 选择一个控件后，读出该控件的许可证和产品信息。此许可证和产品信息显示在对话框中 设备许可证阅读器 显示。 称呼 ： 菜单 工具 要求 : 控制器上没有应用程序。 如果在控制器上有应用程序时选择了命令，则在对话框中询问用户是否应从控制器中删除所有应用程序。如果用户单击此对话框 不 点击，命令 设备许可证阅读器 取消。 对话 设备许可证阅读器 可用设备功能的状态 产品 CODESYS -产品 例子： SoftMotion 特征 特点 产品 例子： CNC 是一个 特征 从 SoftMotion . 许可证有效\/数量 Yes ：该功能有许可证。 No : 该功能没有许可证。 数量 : 许可证数量 " }, 
{ "title" : "窗户 ", 
"url" : "_cds_f_commands_window.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：下一个编辑器 ", 
"url" : "_cds_cmd_next_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：下一个编辑器 ", 
"snippet" : "下一位编辑 键盘快捷键： 控制 + F6 功能 ：该命令将焦点从当前活动窗口切换到下一个窗口。 “下一个”窗口是其选项卡位于当前活动窗口右侧的窗口。 称呼 ： 菜单 窗户 要求 : 至少有一个编辑器处于打开状态。...", 
"body" : "下一位编辑 键盘快捷键： 控制 + F6 功能 ：该命令将焦点从当前活动窗口切换到下一个窗口。 “下一个”窗口是其选项卡位于当前活动窗口右侧的窗口。 称呼 ： 菜单 窗户 要求 : 至少有一个编辑器处于打开状态。 " }, 
{ "title" : "命令：前一个编辑器 ", 
"url" : "_cds_cmd_previous_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：前一个编辑器 ", 
"snippet" : "前任编辑 键盘快捷键： 切换 + 控制 + F6 功能 ：该命令将焦点从当前活动窗口切换到前一个窗口。 “上一个”窗口是其选项卡位于当前活动窗口左侧的窗口。 称呼 ： 菜单 窗户 要求 : 至少有一个编辑器处于打开状态。...", 
"body" : "前任编辑 键盘快捷键： 切换 + 控制 + F6 功能 ：该命令将焦点从当前活动窗口切换到前一个窗口。 “上一个”窗口是其选项卡位于当前活动窗口左侧的窗口。 称呼 ： 菜单 窗户 要求 : 至少有一个编辑器处于打开状态。 " }, 
{ "title" : "命令：关闭所有编辑器 ", 
"url" : "_cds_cmd_close_all_editors.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：关闭所有编辑器 ", 
"snippet" : "关闭所有编辑器 象征： 功能 ：该命令关闭所有当前打开的编辑器窗口。 称呼 ： 菜单 窗户 要求 : 至少有一个编辑器处于打开状态。...", 
"body" : "关闭所有编辑器 象征： 功能 ：该命令关闭所有当前打开的编辑器窗口。 称呼 ： 菜单 窗户 要求 : 至少有一个编辑器处于打开状态。 " }, 
{ "title" : "命令：关闭非活动应用程序的所有编辑器 ", 
"url" : "_cds_cmd_close_all_editors_of_inactive_applications.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：关闭非活动应用程序的所有编辑器 ", 
"snippet" : "关闭非活动应用程序的所有编辑器 功能 ：该命令关闭当前非活动应用程序正下方的对象的所有编辑器窗口。 POU 视图对象的编辑器保持打开状态。 称呼 ： 菜单 窗户 要求 ：至少有一个非活动应用程序的编辑器处于打开状态。...", 
"body" : "关闭非活动应用程序的所有编辑器 功能 ：该命令关闭当前非活动应用程序正下方的对象的所有编辑器窗口。 POU 视图对象的编辑器保持打开状态。 称呼 ： 菜单 窗户 要求 ：至少有一个非活动应用程序的编辑器处于打开状态。 " }, 
{ "title" : "命令：重置窗口布局 ", 
"url" : "_cds_cmd_reset_window_layout.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：重置窗口布局 ", 
"snippet" : "重置窗口布局 功能 ：该命令将所有当前打开的窗口和视图重置为其默认位置。您必须在执行命令之前确认该命令。 称呼 ： 菜单 工具...", 
"body" : "重置窗口布局 功能 ：该命令将所有当前打开的窗口和视图重置为其默认位置。您必须在执行命令之前确认该命令。 称呼 ： 菜单 工具 " }, 
{ "title" : "命令：新建水平选项卡组 ", 
"url" : "_cds_cmd_new_horizontal_tab_group.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：新建水平选项卡组 ", 
"snippet" : "新的水平选项卡组 象征： 功能 ：该命令将当前活动窗口移动到现有窗口下方的新的单独选项卡组。 称呼 ： 菜单 窗户 , 选项卡的上下文菜单 要求 : 几个编辑器窗口作为标签页并排排列。 如果您在编辑器中打开另一个对象，它将自动放置在具有焦点的选项卡组中。...", 
"body" : "新的水平选项卡组 象征： 功能 ：该命令将当前活动窗口移动到现有窗口下方的新的单独选项卡组。 称呼 ： 菜单 窗户 , 选项卡的上下文菜单 要求 : 几个编辑器窗口作为标签页并排排列。 如果您在编辑器中打开另一个对象，它将自动放置在具有焦点的选项卡组中。 " }, 
{ "title" : "命令：新建垂直选项卡组 ", 
"url" : "_cds_cmd_new_vertical_tab_group.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：新建垂直选项卡组 ", 
"snippet" : "新的垂直选项卡组 象征： 功能 ：该命令将当前活动窗口移动到现有窗口右侧的一个新的、单独的选项卡组。 称呼 ： 菜单 窗户 , 选项卡的上下文菜单 要求 : 几个编辑器窗口作为标签页并排排列。 如果您在编辑器中打开另一个对象，它将自动放置在具有焦点的选项卡组中。...", 
"body" : "新的垂直选项卡组 象征： 功能 ：该命令将当前活动窗口移动到现有窗口右侧的一个新的、单独的选项卡组。 称呼 ： 菜单 窗户 , 选项卡的上下文菜单 要求 : 几个编辑器窗口作为标签页并排排列。 如果您在编辑器中打开另一个对象，它将自动放置在具有焦点的选项卡组中。 " }, 
{ "title" : "命令：浮动 ", 
"url" : "_cds_cmd_window_float.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：浮动 ", 
"snippet" : "漂浮的 功能 ：该命令用于从框架中取消停靠（固定）到用户界面框架的窗口，并将其作为浮动窗口放置在屏幕上。 称呼 ： 菜单 窗户 要求 ：应用程序处于在线模式。 这个窗口也可以放置在用户界面之外。要将浮动窗口重新绑定到用户界面框架，请使用命令 对接 ....", 
"body" : "漂浮的 功能 ：该命令用于从框架中取消停靠（固定）到用户界面框架的窗口，并将其作为浮动窗口放置在屏幕上。 称呼 ： 菜单 窗户 要求 ：应用程序处于在线模式。 这个窗口也可以放置在用户界面之外。要将浮动窗口重新绑定到用户界面框架，请使用命令 对接 . " }, 
{ "title" : "命令：码头 ", 
"url" : "_cds_cmd_window_dock.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：码头 ", 
"snippet" : "对接 功能 ：该命令用于打开该命令之前的窗口 漂浮的 已取消停靠，现在是屏幕上的一个浮动窗口，用于“停靠”回 UI 框架。 称呼 ： 菜单 窗户...", 
"body" : "对接 功能 ：该命令用于打开该命令之前的窗口 漂浮的 已取消停靠，现在是屏幕上的一个浮动窗口，用于“停靠”回 UI 框架。 称呼 ： 菜单 窗户 " }, 
{ "title" : "命令：隐藏 ", 
"url" : "_cds_cmd_window_autohide.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：隐藏 ", 
"snippet" : "隐藏 键盘快捷键： F7 功能 : 该命令用于“隐藏或显示”一个窗口。 称呼 ： 菜单 窗户 “隐藏”的意思是 CODESYS 该窗口仅在用户界面的框架中显示多个选项卡，并且仅当您将鼠标移到该选项卡上时它才可见。该命令作为一个选项工作，即如果窗口被隐藏，它会出现在菜单中，并且前面有一个复选标记。如果再次单击该命令，则取消勾选并再次显示窗口。...", 
"body" : "隐藏 键盘快捷键： F7 功能 : 该命令用于“隐藏或显示”一个窗口。 称呼 ： 菜单 窗户 “隐藏”的意思是 CODESYS 该窗口仅在用户界面的框架中显示多个选项卡，并且仅当您将鼠标移到该选项卡上时它才可见。该命令作为一个选项工作，即如果窗口被隐藏，它会出现在菜单中，并且前面有一个复选标记。如果再次单击该命令，则取消勾选并再次显示窗口。 " }, 
{ "title" : "命令：下一个窗格 ", 
"url" : "_cds_cmd_next_pane.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：下一个窗格 ", 
"snippet" : "下一个窗格 键盘快捷键： F6 功能 ：此命令将焦点设置到下一个窗格。 称呼 ： 菜单 窗户 要求 : 包含两个或更多窗格的对象已打开。 示例：如果您在 ST 编辑器中打开了一个对象，并且光标在声明窗口中，则该命令将焦点设置到实现部分。...", 
"body" : "下一个窗格 键盘快捷键： F6 功能 ：此命令将焦点设置到下一个窗格。 称呼 ： 菜单 窗户 要求 : 包含两个或更多窗格的对象已打开。 示例：如果您在 ST 编辑器中打开了一个对象，并且光标在声明窗口中，则该命令将焦点设置到实现部分。 " }, 
{ "title" : "命令：上一个窗格 ", 
"url" : "_cds_cmd_previous_pane.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：上一个窗格 ", 
"snippet" : "上一个窗格 键盘快捷键： 切换 + F6 功能 ：此命令将焦点设置到上一个窗格。 称呼 ： 菜单 窗户 要求 : 包含两个或更多窗格的对象已打开。 示例：如果您在 ST 编辑器中打开了一个对象，并且光标在声明窗口中，则该命令将焦点设置到实现部分。...", 
"body" : "上一个窗格 键盘快捷键： 切换 + F6 功能 ：此命令将焦点设置到上一个窗格。 称呼 ： 菜单 窗户 要求 : 包含两个或更多窗格的对象已打开。 示例：如果您在 ST 编辑器中打开了一个对象，并且光标在声明窗口中，则该命令将焦点设置到实现部分。 " }, 
{ "title" : "命令：切换第一个局部视图 ", 
"url" : "_cds_cmd_toggle_first_pane.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：切换第一个局部视图 ", 
"snippet" : "切换第一个局部视图 键盘快捷键： 老的 + F6 功能 ：该命令隐藏\/显示声明窗口。 称呼 ： 菜单 窗户 要求 ：光标位于以下对象之一的编辑器中： POU 过境 方法 获取属性的访问器方法 设置属性的访问器方法 可视化 您还可以使用按钮编辑局部视图 转变。...", 
"body" : "切换第一个局部视图 键盘快捷键： 老的 + F6 功能 ：该命令隐藏\/显示声明窗口。 称呼 ： 菜单 窗户 要求 ：光标位于以下对象之一的编辑器中： POU 过境 方法 获取属性的访问器方法 设置属性的访问器方法 可视化 您还可以使用按钮编辑局部视图 转变。 " }, 
{ "title" : "命令：切换第二个局部视图 ", 
"url" : "_cds_cmd_toggle_second_pane.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：切换第二个局部视图 ", 
"snippet" : "切换第二个局部视图 功能 ：该命令隐藏\/显示部署窗口。 称呼 ： 菜单 窗户 要求 ：光标位于以下对象之一的编辑器中： POU 过境 方法 获取属性的访问器方法 设置属性的访问器方法 可视化 您还可以使用按钮编辑局部视图 转变。...", 
"body" : "切换第二个局部视图 功能 ：该命令隐藏\/显示部署窗口。 称呼 ： 菜单 窗户 要求 ：光标位于以下对象之一的编辑器中： POU 过境 方法 获取属性的访问器方法 设置属性的访问器方法 可视化 您还可以使用按钮编辑局部视图 转变。 " }, 
{ "title" : "命令：窗口 ", 
"url" : "_cds_cmd_window.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：窗口 ", 
"snippet" : "窗户 功能 ：命令打开对话框 窗户 ，它会显示所有打开的对象。您可以在其中激活或关闭窗口。 称呼 ： 菜单 窗户...", 
"body" : "窗户 功能 ：命令打开对话框 窗户 ，它会显示所有打开的对象。您可以在其中激活或关闭窗口。 称呼 ： 菜单 窗户 " }, 
{ "title" : "命令：关闭除此之外的所有编辑器 ", 
"url" : "_cds_cmd_close_all_editor_but_this.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：关闭除此之外的所有编辑器 ", 
"snippet" : "关闭除此之外的所有编辑器 功能 ：此命令关闭除当前窗口之外的所有编辑器窗口。 称呼 : 选项卡的上下文菜单 要求 : 至少有两个对象是打开的。...", 
"body" : "关闭除此之外的所有编辑器 功能 ：此命令关闭除当前窗口之外的所有编辑器窗口。 称呼 : 选项卡的上下文菜单 要求 : 至少有两个对象是打开的。 " }, 
{ "title" : "命令：在导航器中选择对象 ", 
"url" : "_cds_cmd_select_object_in_navigator.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：在导航器中选择对象 ", 
"snippet" : "在导航器中选择对象 功能 ：此命令在设备树中选择活动编辑器的对象。 称呼 : 选项卡的上下文菜单 要求 ：至少有一个对象是打开的。 如果您在设备树中选择该选项，此命令将自动执行 跟踪活动编辑器 启用。...", 
"body" : "在导航器中选择对象 功能 ：此命令在设备树中选择活动编辑器的对象。 称呼 : 选项卡的上下文菜单 要求 ：至少有一个对象是打开的。 如果您在设备树中选择该选项，此命令将自动执行 跟踪活动编辑器 启用。 " }, 
{ "title" : "命令：在导航器中选择父对象 ", 
"url" : "_cds_cmd_select_parent_object_in_navigator.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 命令：在导航器中选择父对象 ", 
"snippet" : "在导航器中选择父对象 功能 ：此命令选择设备树中的父对象。 称呼 : 选项卡的上下文菜单 要求 ：至少有一个对象是打开的。...", 
"body" : "在导航器中选择父对象 功能 ：此命令选择设备树中的父对象。 称呼 : 选项卡的上下文菜单 要求 ：至少有一个对象是打开的。 " }, 
{ "title" : "子菜单命令：窗口 ", 
"url" : "_cds_cmd_window_n.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 窗户 \/ 子菜单命令：窗口 ", 
"snippet" : "功能 ：该命令激活选定的窗口 称呼 ： 菜单 窗户 对于每个打开的编辑器窗口，窗口菜单都包含一个命令 <n><对象名称> ，您可以通过它激活窗口，即将焦点设置在那里。离线模式下，CODESYS在命令后添加扩展名 （离线） .对于功能块，扩展 (Impl) 或 <实例路径 添加。...", 
"body" : "功能 ：该命令激活选定的窗口 称呼 ： 菜单 窗户 对于每个打开的编辑器窗口，窗口菜单都包含一个命令 <n><对象名称> ，您可以通过它激活窗口，即将焦点设置在那里。离线模式下，CODESYS在命令后添加扩展名 （离线） .对于功能块，扩展 (Impl) 或 <实例路径 添加。 " }, 
{ "title" : "帮助 ", 
"url" : "_cds_f_commands_help.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 帮助 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：CODESYS 帮助 ", 
"url" : "_cds_cmd_content.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 帮助 \/ 命令：CODESYS 帮助 ", 
"snippet" : "CODESYS 帮助 象征： 键盘快捷键： 控制 + 切换 + F1 功能 ：该命令打开 CODESYS -帮助。 称呼 ： 菜单 帮助 取决于 使用在线帮助而不是离线帮助 选项，可以打开在线帮助或离线帮助。...", 
"body" : "CODESYS 帮助 象征： 键盘快捷键： 控制 + 切换 + F1 功能 ：该命令打开 CODESYS -帮助。 称呼 ： 菜单 帮助 取决于 使用在线帮助而不是离线帮助 选项，可以打开在线帮助或离线帮助。 " }, 
{ "title" : "命令：有关已安装的第三方软件包的帮助 ", 
"url" : "_cds_cmd_3rd_party_help.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 帮助 \/ 命令：有关已安装的第三方软件包的帮助 ", 
"snippet" : "有关已安装的第三方软件包的帮助 象征： 功能 : 该命令将在文件资源管理器中打开 ...\\Online Help\\<language code>\\ 目录。 称呼 : 帮助 菜单 要求 ：特定于客户的 CHM 帮助文件位于离线 CHM 帮助目录中。 此命令用于使特定于客户的 CHM 帮助文件可从 CODESYS 用户界面访问。然后，可以使用 Windows CHM 查看器打开帮助文件 CODESYS 的标准安装包括其他附加组件，这些附加组件仍然提供旧的 CHM 帮助文件。这些文件也存储在目录  ...\\Online Help\\<language code>\\ 中。只要此目录中没有存储其他客户特定...", 
"body" : "有关已安装的第三方软件包的帮助 象征： 功能 : 该命令将在文件资源管理器中打开 ...\\Online Help\\<language code>\\ 目录。 称呼 : 帮助 菜单 要求 ：特定于客户的 CHM 帮助文件位于离线 CHM 帮助目录中。 此命令用于使特定于客户的 CHM 帮助文件可从 CODESYS 用户界面访问。然后，可以使用 Windows CHM 查看器打开帮助文件 CODESYS 的标准安装包括其他附加组件，这些附加组件仍然提供旧的 CHM 帮助文件。这些文件也存储在目录  ...\\Online Help\\<language code>\\ 中。只要此目录中没有存储其他客户特定的 CHM 文件，该命令就会保持停用状态。 这个 CODESYS CHM 查看器在 SP21 中不再可用。不再可能合并 CHM 文件 可以将其他 HTML 帮助页面集成到 CODESYS 离线帮助。有关更多信息，请参阅： 使用自己的内容扩展 CODESYS 离线帮助" }, 
{ "title" : "命令：CODESYS 主页 ", 
"url" : "_cds_cmd_homepage.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 帮助 \/ 命令：CODESYS 主页 ", 
"snippet" : "CODESYS 主页 功能 ：该命令打开主页 CODESYS GmbH . 称呼 ： 菜单 帮助...", 
"body" : "CODESYS 主页 功能 ：该命令打开主页 CODESYS GmbH . 称呼 ： 菜单 帮助 " }, 
{ "title" : "命令：信息 ", 
"url" : "_cds_cmd_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 帮助 \/ 命令：信息 ", 
"snippet" : "信息 功能 ：该命令会打开一个闪屏，其中包含有关 CODESYS 版本和版权。此外，还提供了有关版本、许可证和致谢的详细信息的按钮。 称呼 ： 菜单 帮助 版本信息 打开对话框 详细版本信息 有一份清单 CODESYS -有关操作系统的组件和信息 许可证信息 打开对话框 许可证信息 插件\/组件 ：要显示许可证信息的插件的选择列表 软件许可证 ：有关所选许可证的信息 插件\/组件 谢谢 对话框：详细版本信息 编程系统 有关编程系统版本的信息 包含以下信息的组件列表 成分 : 组件名称 版本 ：组件的版本 添加在 ：包含组件的附加组件 操作系统 有关操作系统的信息 附加签名信息 所选组件的签名信息 ...", 
"body" : "信息 功能 ：该命令会打开一个闪屏，其中包含有关 CODESYS 版本和版权。此外，还提供了有关版本、许可证和致谢的详细信息的按钮。 称呼 ： 菜单 帮助 版本信息 打开对话框 详细版本信息 有一份清单 CODESYS -有关操作系统的组件和信息 许可证信息 打开对话框 许可证信息 插件\/组件 ：要显示许可证信息的插件的选择列表 软件许可证 ：有关所选许可证的信息 插件\/组件 谢谢 对话框：详细版本信息 编程系统 有关编程系统版本的信息 包含以下信息的组件列表 成分 : 组件名称 版本 ：组件的版本 添加在 ：包含组件的附加组件 操作系统 有关操作系统的信息 附加签名信息 所选组件的签名信息 出口 将详细版本信息导出为文本文件 ( *.txt ) 或任何其他格式 " }, 
{ "title" : "图书馆 ", 
"url" : "_cds_f_commands_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 图书馆 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：添加库 ", 
"url" : "_cds_cmd_add_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 图书馆 \/ 命令：添加库 ", 
"snippet" : "添加库 功能 ：命令打开对话框 添加库 .在此对话框中，您可以将库添加到库管理器，从而将它们集成到您的应用程序中。 称呼 ： 菜单 图书馆 要求 ：库管理器在编辑器中打开。...", 
"body" : "添加库 功能 ：命令打开对话框 添加库 .在此对话框中，您可以将库添加到库管理器，从而将它们集成到您的应用程序中。 称呼 ： 菜单 图书馆 要求 ：库管理器在编辑器中打开。 " }, 
{ "title" : "对话框：添加库 ", 
"url" : "_cds_cmd_add_library.html#UUID-b7d5aeaf-fe0d-cacd-4cbd-07b0b70036cd_id_cab383442a7a332cc0a8640e00d16ef2_id_c6de462e2a8098cdc0a8640e00eeb4e2", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 图书馆 \/ 命令：添加库 \/ 对话框：添加库 ", 
"snippet" : "在库列表上方的行中，您可以通过键入适当的字符串来搜索库名称或库模块。 图书馆 安装在库存储库中的所有库 默认情况下，显示的库按类别分组。 公司 图书馆提供者 先进的 打开扩展对话框 添加库 显示的库按类别分组。 显示的库按字母顺序列出。 某些库可以在设备的设备描述中标记为“列入黑名单”。这些库无法添加到此设备下方的库管理器中。 有关更多信息，请参阅： 图书馆存储库...", 
"body" : "在库列表上方的行中，您可以通过键入适当的字符串来搜索库名称或库模块。 图书馆 安装在库存储库中的所有库 默认情况下，显示的库按类别分组。 公司 图书馆提供者 先进的 打开扩展对话框 添加库 显示的库按类别分组。 显示的库按字母顺序列出。 某些库可以在设备的设备描述中标记为“列入黑名单”。这些库无法添加到此设备下方的库管理器中。 有关更多信息，请参阅： 图书馆存储库" }, 
{ "title" : "命令：尝试重新加载库 ", 
"url" : "_cds_cmd_reload_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 图书馆 \/ 命令：尝试重新加载库 ", 
"snippet" : "尝试重新加载库 功能 ：该命令尝试重新加载选定的库。 称呼 ： 菜单 图书馆 要求 : 选择了加载失败的库。 如果由于某种原因在打开项目时定义的存储库路径中没有可用的库，则 CODESYS 相应的错误消息。 纠正错误后，即库再次正确可用，您可以使用命令重新加载此库，而无需离开项目。 有关更多信息，请参阅： 图书馆存储库...", 
"body" : "尝试重新加载库 功能 ：该命令尝试重新加载选定的库。 称呼 ： 菜单 图书馆 要求 : 选择了加载失败的库。 如果由于某种原因在打开项目时定义的存储库路径中没有可用的库，则 CODESYS 相应的错误消息。 纠正错误后，即库再次正确可用，您可以使用命令重新加载此库，而无需离开项目。 有关更多信息，请参阅： 图书馆存储库" }, 
{ "title" : "命令：属性 ", 
"url" : "_cds_cmd_library_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 图书馆 \/ 命令：属性 ", 
"snippet" : "特性 功能 ：命令打开对话框 特性 在库管理器中选择的库。 称呼 菜单 图书馆 所选库的上下文菜单 象征 在库管理器工具栏中 要求 ：选择了一个库。 此对话框适用于库开发人员。请仅在您对库引用有深入了解并确保遵循库开发人员指南的情况下使用它。 有关更多信息，请参阅： 图书馆开发人员信息...", 
"body" : "特性 功能 ：命令打开对话框 特性 在库管理器中选择的库。 称呼 菜单 图书馆 所选库的上下文菜单 象征 在库管理器工具栏中 要求 ：选择了一个库。 此对话框适用于库开发人员。请仅在您对库引用有深入了解并确保遵循库开发人员指南的情况下使用它。 有关更多信息，请参阅： 图书馆开发人员信息" }, 
{ "title" : "对话框：属性 ", 
"url" : "_cds_cmd_library_properties.html#UUID-15f672ba-ddd7-126d-50f4-2ed64e8a9235_id_addd92672ae0c16bc0a8640e011af5c6_id_6803d930a6c811e4a21c94779d6b67d7", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 图书馆 \/ 命令：属性 \/ 对话框：属性 ", 
"snippet" : "一般的 命名空间 所选库的命名空间 通常与库名称相同，除非在创建库时在项目信息中明确定义。您可以更改（当前打开的）项目的命名空间。 例子： LA 默认 如果没有定义或可能的其他解析，则解析占位符的库 要求：选择的库是库占位符，则设置可用。 注意：从编译器版本 3.5.8.0 开始，适用于在设备描述中有解决方案的库占位符，但在视图的库管理器中 POU 谎言：这个占位符总是根据编译应用程序的设备的描述自动解析。 如果所选库是根据“库开发指南”开发的，则不建议更改以下设置。 版本 强制版本的选择 要求：仅当所选库 不 库占位符，设置可用。 注意：容器和接口库是使用具有相应版本约束的库引用自动创建的。...", 
"body" : "一般的 命名空间 所选库的命名空间 通常与库名称相同，除非在创建库时在项目信息中明确定义。您可以更改（当前打开的）项目的命名空间。 例子： LA 默认 如果没有定义或可能的其他解析，则解析占位符的库 要求：选择的库是库占位符，则设置可用。 注意：从编译器版本 3.5.8.0 开始，适用于在设备描述中有解决方案的库占位符，但在视图的库管理器中 POU 谎言：这个占位符总是根据编译应用程序的设备的描述自动解析。 如果所选库是根据“库开发指南”开发的，则不建议更改以下设置。 版本 强制版本的选择 要求：仅当所选库 不 库占位符，设置可用。 注意：容器和接口库是使用具有相应版本约束的库引用自动创建的。否则，如果可能，不要创建包含强制版本的库引用的库，而是使用占位符引用库。您可以在对话框中使用占位符分辨率 占位符 编辑。 确切版本 ：版本（通过选择列表选择）永久集成在项目中。 注意：强烈建议对容器库使用此选项，并且通常是此类库的默认设置。 始终是最新版本 ：搜索库存储库并包含在那里找到的最新版本。 注意：如果有更新版本的库可用，实际使用的库模块可能会发生变化。强烈建议对接口库使用此选项，并且通常是此类库的默认设置。 能见度 仅允许对所有标识符进行合格访问。 ：库块（和变量）仅在具有前面命名空间路径的项目中调用。 当前项目在另一个项目中被引用为库时 注意：仅当您使用项目创建库并因此打开了库项目时，更改以下设置才有意义。选定的库在新库中被引用。 使项目中的所有 IEC 符号可见，就好像此引用已直接包含在此处一样。 ：所选库使（在项目后期）作为容器库可见引用库顶层（在其顶层）的内容。 要求：您使用库项目创建一个容器库。容器库是不实现自己的构建块，而只引用其他库的库。它捆绑了库。容器库可用于将多个库一起（在一个引用中）包含在一个项目中。对于每个库参考 必须 必须激活此选项。 对库块的符号访问： <Namensraum Containerbibliothek>.<Bausteinname> : 引用库的内容可通过命名空间唯一寻址。路径名由库的名称和它自己的名称（库引用）组成，并放在模块名称的前面。 要求：您使用库项目创建 没有任何 容器库。 不要在依赖树中显示此引用。 ：选定的库不显示为库管理器中的库引用（稍后在项目中）。该库被引用隐藏。 警告：如果由于隐藏库中的错误导致编译错误，调试可能会很困难。 ：所选库显示为（稍后在项目中）作为库引用。 可选（如果缺少库，则不会引发错误）。 ： ：所选库被视为可选库。加载引用该库的项目不会引发错误，即使该库位于库存储库中 不是 可用。 有关更多信息，请参阅： 占位符" }, 
{ "title" : "命令：通配符 ", 
"url" : "_cds_cmd_placeholder.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 图书馆 \/ 命令：通配符 ", 
"snippet" : "占位符 功能 ：命令打开对话框 占位符 .该对话框提供有关所选占位符库的信息，并允许您分配对项目特别有效的分辨率。 编译操作总是针对特定的应用程序完成的。为此，对于库管理器中存在的库条目，必须有实际可用的库。占位符在一个项目的各个库管理器中的解析（应用程序， 计划书 池）是一个复杂的操作。解析结果仅在编译过程中可见，无法从库管理器中的占位符信息中可靠地预先读取。 称呼 ： 菜单 图书馆 象征 在库管理器窗口顶部的工具栏中 在出现有关未解析库的错误消息时使用 Quickfix 命令。 有关详细信息，请参阅： 消息. 在编译器版本 3.5.18.0 及更高版本中，库配置文件在占位符解析中被忽略。占...", 
"body" : "占位符 功能 ：命令打开对话框 占位符 .该对话框提供有关所选占位符库的信息，并允许您分配对项目特别有效的分辨率。 编译操作总是针对特定的应用程序完成的。为此，对于库管理器中存在的库条目，必须有实际可用的库。占位符在一个项目的各个库管理器中的解析（应用程序， 计划书 池）是一个复杂的操作。解析结果仅在编译过程中可见，无法从库管理器中的占位符信息中可靠地预先读取。 称呼 ： 菜单 图书馆 象征 在库管理器窗口顶部的工具栏中 在出现有关未解析库的错误消息时使用 Quickfix 命令。 有关详细信息，请参阅： 消息. 在编译器版本 3.5.18.0 及更高版本中，库配置文件在占位符解析中被忽略。占位符成为“自由占位符”。 要求 ： 在里面 图书馆管理员 一个占位符库被选中。 视图下的占位符库 设备 包括在内，解决如下： 如果在对话框中给占位符库一个特殊的分辨率 占位符 分配，这将被采纳。 如果没有指定特殊分辨率，则检查应用程序的设备描述中是否指定了分辨率。 然后检查是否在库配置文件中指定了分辨率。 中库管理器的占位符表 计划书 看法 结果显示在下面的库管理器中 有效版本 。有关此信息可以在工具提示中找到 图标。如果所有解决步骤均未成功，则该库将被标记为 （未解决） 并且该库不会包含在编译中。 有关更多信息，请参阅： 图书馆开发人员信息使用库图书馆开发人员信息更新库占位符特性LibDev摘要 " }, 
{ "title" : "对话框：占位符 ", 
"url" : "_cds_cmd_placeholder.html#UUID-98becf1f-bedf-8e6a-baab-8f7e3b147e27_id_c70a2add81efc0a8640e016d5a59_id_4450599b767011e6b248ef4427d74153", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 图书馆 \/ 命令：通配符 \/ 对话框：占位符 ", 
"snippet" : "姓 占位符的标识符 图书馆 项目的当前分辨率 双击条目以编辑占位符分辨率。将出现库的可用版本的选择列表。该命令也出现 其他图书馆 . 命令 其他图书馆 对话 搜索库 用于搜索和安装库打开。选择重定向到特定库而不是另一个版本的命令。 信息 占位符解析的类型 由设备描述解决 由许可机制解决 由库配置文件解决 由 <特殊库> 解决 将所有未解决的未绑定占位符设置为最新的可用版本 对于库管理器中仍未解析的占位符库的解析，指定了最新的可用版本。...", 
"body" : "姓 占位符的标识符 图书馆 项目的当前分辨率 双击条目以编辑占位符分辨率。将出现库的可用版本的选择列表。该命令也出现 其他图书馆 . 命令 其他图书馆 对话 搜索库 用于搜索和安装库打开。选择重定向到特定库而不是另一个版本的命令。 信息 占位符解析的类型 由设备描述解决 由许可机制解决 由库配置文件解决 由 <特殊库> 解决 将所有未解决的未绑定占位符设置为最新的可用版本 对于库管理器中仍未解析的占位符库的解析，指定了最新的可用版本。 " }, 
{ "title" : "命令：导出库 ", 
"url" : "_cds_cmd_export_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 图书馆 \/ 命令：导出库 ", 
"snippet" : "导出库 功能 ：此命令用于将库文件保存到磁盘。 称呼 ： 菜单 图书馆 , 库管理器上下文菜单 要求 ：在库管理器中选择了一个库。 该命令打开用于在本地文件系统中保存文件的标准对话框。库文件可以是文件类型 Bibliotheken (*.library) , Übersetzte Bibliotheken (*.compiled-library) 或者 Übersetzte Bibliotheken (*.compiled-library-v3) 具有。 有关更多信息，请参阅： 导出库文件...", 
"body" : "导出库 功能 ：此命令用于将库文件保存到磁盘。 称呼 ： 菜单 图书馆 , 库管理器上下文菜单 要求 ：在库管理器中选择了一个库。 该命令打开用于在本地文件系统中保存文件的标准对话框。库文件可以是文件类型 Bibliotheken (*.library) , Übersetzte Bibliotheken (*.compiled-library) 或者 Übersetzte Bibliotheken (*.compiled-library-v3) 具有。 有关更多信息，请参阅： 导出库文件" }, 
{ "title" : "声明 ", 
"url" : "_cds_f_commands_declarations.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 声明 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：粘贴 ", 
"url" : "_cds_cmd_insert.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 声明 \/ 命令：粘贴 ", 
"snippet" : "插入 象征： 功能 ：该命令在表格声明编辑器中为变量声明插入一个新行，并打开变量名称的输入字段。 称呼 ：表格声明编辑器中的上下文菜单，声明标题中的按钮 要编辑申报行的其他字段，请双击这些字段并从选择列表中选择信息或使用相应的对话框。...", 
"body" : "插入 象征： 功能 ：该命令在表格声明编辑器中为变量声明插入一个新行，并打开变量名称的输入字段。 称呼 ：表格声明编辑器中的上下文菜单，声明标题中的按钮 要编辑申报行的其他字段，请双击这些字段并从选择列表中选择信息或使用相应的对话框。 " }, 
{ "title" : "命令：编辑声明头 ", 
"url" : "_cds_cmd_edit_declaration_header.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 声明 \/ 命令：编辑声明头 ", 
"snippet" : "编辑声明标题 功能 ：命令打开对话框 编辑声明标题 ，在表格声明编辑器中用于配置 POU 的标题。 称呼 ：表格声明编辑器的上下文菜单 要求 ：焦点在表格声明编辑器中。...", 
"body" : "编辑声明标题 功能 ：命令打开对话框 编辑声明标题 ，在表格声明编辑器中用于配置 POU 的标题。 称呼 ：表格声明编辑器的上下文菜单 要求 ：焦点在表格声明编辑器中。 " }, 
{ "title" : "对话框：编辑声明标题 ", 
"url" : "_cds_cmd_edit_declaration_header.html#UUID-45e0a327-995d-f0be-3bd9-68bfcb2d6ac3_id_be8f1f656b67481c0a8640e01948269_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 声明 \/ 命令：编辑声明头 \/ 对话框：编辑声明标题 ", 
"snippet" : "功能 ：在对话框中配置 POU 的表格声明部分的标题。 称呼 ：鼠标单击表格声明编辑器的标题，表格声明编辑器中的上下文菜单 宣言 用于更改 POU 类型的选择列表 程序 FUNCTION_BLOCK 扩展 ：基本功能块的输入字段 实施 ：接口的输入字段 功能 返回类型 具有当前 POU 名称的输入字段 您可以更改 POU 的名称。 重命名时自动调整所有引用 ： 对话 重构 打开。 : 重命名只在 POU 的声明头中生效。 属性 对话 属性 打开以输入属性和编译指示。 有关更多信息，请参阅： 使用声明编辑器...", 
"body" : "功能 ：在对话框中配置 POU 的表格声明部分的标题。 称呼 ：鼠标单击表格声明编辑器的标题，表格声明编辑器中的上下文菜单 宣言 用于更改 POU 类型的选择列表 程序 FUNCTION_BLOCK 扩展 ：基本功能块的输入字段 实施 ：接口的输入字段 功能 返回类型 具有当前 POU 名称的输入字段 您可以更改 POU 的名称。 重命名时自动调整所有引用 ： 对话 重构 打开。 : 重命名只在 POU 的声明头中生效。 属性 对话 属性 打开以输入属性和编译指示。 有关更多信息，请参阅： 使用声明编辑器" }, 
{ "title" : "命令：下移 ", 
"url" : "_cds_cmd_move_down.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 声明 \/ 命令：下移 ", 
"snippet" : "下移 象征： 功能 : 该命令将变量声明下移一行。 称呼 ： 上下文菜单 要求 ：在表格声明编辑器中选择了带有变量声明的行。...", 
"body" : "下移 象征： 功能 : 该命令将变量声明下移一行。 称呼 ： 上下文菜单 要求 ：在表格声明编辑器中选择了带有变量声明的行。 " }, 
{ "title" : "命令：向上移动 ", 
"url" : "_cds_cmd_move_up.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 声明 \/ 命令：向上移动 ", 
"snippet" : "提升 象征： 功能 : 该命令将变量声明向上移动一行。 称呼 ： 上下文菜单 要求 ：在表格声明编辑器中选择了带有变量声明的行。...", 
"body" : "提升 象征： 功能 : 该命令将变量声明向上移动一行。 称呼 ： 上下文菜单 要求 ：在表格声明编辑器中选择了带有变量声明的行。 " }, 
{ "title" : "声明（持久性） ", 
"url" : "_cds_f_commands_declarations_persistence.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 声明（持久性） ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：重新排序列表并清理间隙 ", 
"url" : "_cds_cmd_reorder_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 声明（持久性） \/ 命令：重新排序列表并清理间隙 ", 
"snippet" : "重新排序列表并清理空白 功能 ：该命令清除了在更改持久变量的声明时可能出现的空白。清理减少了内存需求。运行命令时显示 CODESYS 显示一条警告消息，通知用户可能丢失数据。 称呼 ： 菜单 声明 ， 上下文菜单 要求 ：持久性编辑器（持久性变量列表）处于活动状态。 在清理之前，您应该考虑将持久变量的当前值保存在一个配方中（命令 保存配方中的当前值 ）。然后，您可以在下次下载后再次将值传输到控制器。 有关更多信息，请参阅： 数据持久化...", 
"body" : "重新排序列表并清理空白 功能 ：该命令清除了在更改持久变量的声明时可能出现的空白。清理减少了内存需求。运行命令时显示 CODESYS 显示一条警告消息，通知用户可能丢失数据。 称呼 ： 菜单 声明 ， 上下文菜单 要求 ：持久性编辑器（持久性变量列表）处于活动状态。 在清理之前，您应该考虑将持久变量的当前值保存在一个配方中（命令 保存配方中的当前值 ）。然后，您可以在下次下载后再次将值传输到控制器。 有关更多信息，请参阅： 数据持久化" }, 
{ "title" : "命令：保存配方中的当前值 ", 
"url" : "_cds_cmd_save_actual_values_recipe.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 声明（持久性） \/ 命令：保存配方中的当前值 ", 
"snippet" : "保存配方中的当前值 功能 ：该命令在配方管理器中创建一个新的配方定义，并将持久变量的当前值保存在其中。你应该把命令放在命令之前 重新排序列表并清理空白 运行以避免可能的数据丢失。用命令 从配方中恢复值 然后您可以恢复数据。 称呼 ： 菜单 声明 要求 ：应用程序在线并且持久性编辑器（持久性变量列表）处于活动状态。 如果在保存持久变量列表时配方管理器中已经存在具有相应名称的列表，则将当前持久变量排序到此列表中： 新的持久变量被添加到列表中。 不在持久变量列表中的变量将被删除。 因此，可以将其他配方添加到配方管理器中的列表中，这些配方将被保留。但是，如果将新变量添加到列表中，那么它们将被添加到命令...", 
"body" : "保存配方中的当前值 功能 ：该命令在配方管理器中创建一个新的配方定义，并将持久变量的当前值保存在其中。你应该把命令放在命令之前 重新排序列表并清理空白 运行以避免可能的数据丢失。用命令 从配方中恢复值 然后您可以恢复数据。 称呼 ： 菜单 声明 要求 ：应用程序在线并且持久性编辑器（持久性变量列表）处于活动状态。 如果在保存持久变量列表时配方管理器中已经存在具有相应名称的列表，则将当前持久变量排序到此列表中： 新的持久变量被添加到列表中。 不在持久变量列表中的变量将被删除。 因此，可以将其他配方添加到配方管理器中的列表中，这些配方将被保留。但是，如果将新变量添加到列表中，那么它们将被添加到命令的下一次执行中 保存配方中的当前值 关掉。 有关更多信息，请参阅： 去做 " }, 
{ "title" : "命令：从配方中恢复值 ", 
"url" : "_cds_cmd_restore_values_recipe.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 声明（持久性） \/ 命令：从配方中恢复值 ", 
"snippet" : "从配方中恢复值 功能 ：该命令恢复您使用该命令设置的持久变量的值 保存配方中的当前值 保存在食谱中。您通常在命令执行后选择该命令 重新排序列表并清理空白 出去。 称呼 ： 菜单 声明 要求 ：持久性编辑器（持久性变量列表）处于活动状态。该应用程序处于在线模式。 有关更多信息，请参阅： 数据持久化...", 
"body" : "从配方中恢复值 功能 ：该命令恢复您使用该命令设置的持久变量的值 保存配方中的当前值 保存在食谱中。您通常在命令执行后选择该命令 重新排序列表并清理空白 出去。 称呼 ： 菜单 声明 要求 ：持久性编辑器（持久性变量列表）处于活动状态。该应用程序处于在线模式。 有关更多信息，请参阅： 数据持久化" }, 
{ "title" : "命令：添加所有实例路径 ", 
"url" : "_cds_cmd_add_all_instance_paths.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 声明（持久性） \/ 命令：添加所有实例路径 ", 
"snippet" : "添加所有实例路径 功能 ： 当您在持久性编辑器中选择命令时，应用程序会使用关键字搜索持久性变量声明 PERSISTENT 持久性编辑器之外的搜索。对于找到的每个声明，都会在持久性编辑器中添加该变量的实例路径。 当您在变量配置中选择命令时，会为每个具有部分地址的变量添加一个实例路径。应用程序的所有功能块都被考虑在内。 称呼 ： 菜单 声明 ， 上下文菜单 要求 持久性编辑器（全局持久变量列表）处于活动状态或变量配置（全局变量列表与 VAR_CONFIG -声明）是开放的。 应用程序已成功编译。 有关更多信息，请参阅： PERSISTENT 和 RETAIN...", 
"body" : "添加所有实例路径 功能 ： 当您在持久性编辑器中选择命令时，应用程序会使用关键字搜索持久性变量声明 PERSISTENT 持久性编辑器之外的搜索。对于找到的每个声明，都会在持久性编辑器中添加该变量的实例路径。 当您在变量配置中选择命令时，会为每个具有部分地址的变量添加一个实例路径。应用程序的所有功能块都被考虑在内。 称呼 ： 菜单 声明 ， 上下文菜单 要求 持久性编辑器（全局持久变量列表）处于活动状态或变量配置（全局变量列表与 VAR_CONFIG -声明）是开放的。 应用程序已成功编译。 有关更多信息，请参阅： PERSISTENT 和 RETAIN" }, 
{ "title" : "通讯 : 网关 ", 
"url" : "_cds_f_commands_device_communication.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 通讯 : 网关 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：添加新网关 ", 
"url" : "_cds_cmd_add_gateway.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 通讯 : 网关 \/ 命令：添加新网关 ", 
"snippet" : "添加新网关 功能 ：命令打开对话框 网关 ，您可以在其中定义网关通道并将其添加到当前设备配置中。 称呼 ： 菜单 网关 在对话中 沟通 设备编辑器...", 
"body" : "添加新网关 功能 ：命令打开对话框 网关 ，您可以在其中定义网关通道并将其添加到当前设备配置中。 称呼 ： 菜单 网关 在对话中 沟通 设备编辑器 " }, 
{ "title" : "对话：网关 ", 
"url" : "_cds_cmd_add_gateway.html#UUID-38ab0375-8d48-62f3-f65e-4b40ba5a736f_id_d79c74fc3cfb092c0a8640e0168b9f8_id_1bd97f47c406359cc0a8640e007a53f7", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 通讯 : 网关 \/ 命令：添加新网关 \/ 对话：网关 ", 
"snippet" : "姓 网关名称 司机 驱动程序类型，来自选择列表 特定于驱动程序的设置，例如： IP地址、端口 双击指定值后可编辑 参数的简要说明出现在对话框的下部。 注意：您还可以指定 DNS 域地址。这必须随身携带 dns: 开始，例如 dns:MyDynDNSAdress . 该对话框还用于以后编辑项目中的网关条目。 有关更多信息，请参阅： 标签：通讯设置...", 
"body" : "姓 网关名称 司机 驱动程序类型，来自选择列表 特定于驱动程序的设置，例如： IP地址、端口 双击指定值后可编辑 参数的简要说明出现在对话框的下部。 注意：您还可以指定 DNS 域地址。这必须随身携带 dns: 开始，例如 dns:MyDynDNSAdress . 该对话框还用于以后编辑项目中的网关条目。 有关更多信息，请参阅： 标签：通讯设置" }, 
{ "title" : "命令：配置本地网关 ", 
"url" : "_cds_cmd_connect_to_local_gateway.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 通讯 : 网关 \/ 命令：配置本地网关 ", 
"snippet" : "配置本地网关 功能 ：命令打开对话框 网关配置 ，您可以在其中为本地网关进行块驱动程序配置，作为手动编辑配置文件的替代方法 Gateway.cfg . 称呼 ：在对话框中的设备编辑器中时的上下文菜单 沟通 选择了一个网关条目 正确配置网关需要详细的知识。如有疑问，请保持默认配置设置不变！ 启用 Edge Gateway 功能并将 Edge Gateway 连接到 CODESYS Automation Server ，你可以使用 CODESYS Automation Server Connector 或者 CODESYS Service Tool .有关这方面的更多信息，请参阅帮助 CODESY...", 
"body" : "配置本地网关 功能 ：命令打开对话框 网关配置 ，您可以在其中为本地网关进行块驱动程序配置，作为手动编辑配置文件的替代方法 Gateway.cfg . 称呼 ：在对话框中的设备编辑器中时的上下文菜单 沟通 选择了一个网关条目 正确配置网关需要详细的知识。如有疑问，请保持默认配置设置不变！ 启用 Edge Gateway 功能并将 Edge Gateway 连接到 CODESYS Automation Server ，你可以使用 CODESYS Automation Server Connector 或者 CODESYS Service Tool .有关这方面的更多信息，请参阅帮助 CODESYS Automation Server 在“将 Edge 网关连接到服务器并进入 PLC”一章中。另请注意帮助中的“Edge Gateway 的安全声明”。 " }, 
{ "title" : "对话框：网关配置 ", 
"url" : "_cds_cmd_connect_to_local_gateway.html#UUID-113d1b31-e0b0-905d-0a3a-3bc12e9738f0_id_dfde2d61c3f6ec73c0a8640e0083d45e_id_1513b072c607f333c0a8640e00d023da", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 通讯 : 网关 \/ 命令：配置本地网关 \/ 对话框：网关配置 ", 
"snippet" : "对话框中显示的配置树对应当前有效配置文件中的描述 gateway.cfg .它显示所涉及接口的当前设置的参数。对话框中的配置更改，通过 行 导致立即更新配置文件。 如果网关配置文件 gateway.cfg 已更改，必须先停止并重新启动网关才能使更改生效。 添加 带有用于添加接口和设置的命令的菜单 这些命令也可在对话框的上下文菜单中使用。选择取决于选择的条目和已插入的设置： 添加接口 ：选择通过网关进行通信的接口。它被插入到树的顶层。有关可能的块驱动程序接口，请参见下表。 添加配置设置 ：为所选接口选择设置。它被插入到树中的接口下方。要编辑设置的值，请在列中双击打开 态度 一个编辑字段。有关每个...", 
"body" : "对话框中显示的配置树对应当前有效配置文件中的描述 gateway.cfg .它显示所涉及接口的当前设置的参数。对话框中的配置更改，通过 行 导致立即更新配置文件。 如果网关配置文件 gateway.cfg 已更改，必须先停止并重新启动网关才能使更改生效。 添加 带有用于添加接口和设置的命令的菜单 这些命令也可在对话框的上下文菜单中使用。选择取决于选择的条目和已插入的设置： 添加接口 ：选择通过网关进行通信的接口。它被插入到树的顶层。有关可能的块驱动程序接口，请参见下表。 添加配置设置 ：为所选接口选择设置。它被插入到树中的接口下方。要编辑设置的值，请在列中双击打开 态度 一个编辑字段。有关每个块驱动程序接口的可能设置，请参见下表。 熄灭 删除选定的配置设置 向上 , 向下 将选定的配置条目向上或向下移动一个位置 可能的块驱动接口 串口 设备上的串行端口，例如用于根据 RS232 标准在专用 COM 端口上进行数据交换 可能的配置设置： 姓 : 只是象征性的 港口 : 该接口使用的物理串口，例如 COM 5 在 Windows 计算机上 波特率 ： 2400 , 4800 , 9600 , 19200 , 38400 , 57600 , 115200 启用自动寻址 ： （默认 = ) 态度 Local address 被评估。然后，通过串行接口进行通信的两个设备将在开始交换消息之前独立协商它们的地址。如果两个设备的地址相同，则重新协商。在无法明确设置本地地址的情况下（例如物理上独立的设备），此设置很有用。 本地地址 ：仅在以下情况下进行评估 启用自动寻址 被激活 默认值 = 端口的实际值 共享内存 共享内存驱动 可能的设置： 姓 : 只是象征性的 强制地址 : 默认 = -1 (= no forced address ) 例子： 42 意味着驱动程序必须使用此处定义的固定地址，并且地址在从 0 - 255 被给予。当配置中启用了多个共享内存驱动程序时，此设置会很有用。 以太网 UDP\/IP 根据“用户数据报协议”进行数据交换的以太网接口 可能的设置： 姓 : 只是象征性的 港口指数 : 通讯端口号 端口索引在范围内 0 直到 3 . 它们映射到以下以太网端口： 1740 直到 1743 . IP地址 ：默认= 127.0.0.1 当设备上有多个网络接口时，此设置可用于显式设置接口。 例子： 127.0.0.1 代表任何本地网络接口，也称为 localhost 指定的。任何其他地址（例如 10.27.7.72 ) 表示必须在设备上可用的真实 IP 地址。 网络掩码 ：默认 = 255.255.255.0 示例：255.255.252.0 当设备上有多个网络接口时，此设置可用于显式设置接口。 PPP 远程地址 ：默认= 127.0.0.1 例子： 10.13.42.240 在 UDP 接口和使用此处给出的地址指定的节点之间建立逻辑点对点连接 使 UDP 接口以独占方式与该节点通信，并且在网络上不发送任何广播 以太网 TCP\/IP 根据“传输控制协议”进行数据交换的以太网接口 可能的设置： 姓 , 港口 , IP地址 ：以太网 UDP\/IP 见上文 不活动超时 : 默认 = 0 此设置定义时间跨度（以秒为单位），在此之后没有更多数据交换时 TCP 连接关闭。 CAN客户端 姓 : 只是象征性的 其他设置的描述可以直接在对话框中找到。 USB端口 姓 : 只是象征性的 其他设置的描述可以直接在对话框中找到。 有关更多信息，请参阅： 标签：通讯设置" }, 
{ "title" : "其他 ", 
"url" : "_cds_f_commands_miscellaneous.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 其他 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：添加到监视列表 ", 
"url" : "_cds_cmd_add_watch.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 其他 \/ 命令：添加到监视列表 ", 
"snippet" : "加入观看列表 象征： 功能 ：该命令将光标当前所在的变量添加到监控列表中，用于在线监控。 称呼 ：当应用程序在线并且光标位于编辑器中的变量上时，该命令在上下文菜单中可用。 该命令将变量插入到当前打开的监视列表中。如果当前没有打开观察列表，该命令将变量添加到列表 监视器 1 并打开他们的视野。 有关详细信息，请参阅：  使用观察列表 和 价值监控...", 
"body" : "加入观看列表 象征： 功能 ：该命令将光标当前所在的变量添加到监控列表中，用于在线监控。 称呼 ：当应用程序在线并且光标位于编辑器中的变量上时，该命令在上下文菜单中可用。 该命令将变量插入到当前打开的监视列表中。如果当前没有打开观察列表，该命令将变量添加到列表 监视器 1 并打开他们的视野。 有关详细信息，请参阅：  使用观察列表 和 价值监控" }, 
{ "title" : "命令：实现接口 ", 
"url" : "_cds_cmd_implement_interfaces.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 其他 \/ 命令：实现接口 ", 
"snippet" : "实现接口 功能 ：该命令更新功能块的已实现接口。 称呼 : 在设备树中选择功能块 (FB) 时的上下文菜单 要求 : 功能模块实现了你改变的接口。例如，您向接口添加了另一个方法。 在面向对象的编程中，如果您从实现一个或多个接口的基本功能块派生出一个功能块 (FB)，以实现继承，则适用以下情况： 如果你命令 实现接口 对于派生的FB执行，基FB的所有接口方法和接口属性都在派生的FB中以“存根”（未实现）的形式采用。您现在必须确保派生 FB 中的“空”方法\/属性与基础 FB 中实现的方法\/属性不冲突。为了帮助您解决此问题，会发生以下情况：如果有一个方法\/属性的基本实现，它会添加 CODESYS 在...", 
"body" : "实现接口 功能 ：该命令更新功能块的已实现接口。 称呼 : 在设备树中选择功能块 (FB) 时的上下文菜单 要求 : 功能模块实现了你改变的接口。例如，您向接口添加了另一个方法。 在面向对象的编程中，如果您从实现一个或多个接口的基本功能块派生出一个功能块 (FB)，以实现继承，则适用以下情况： 如果你命令 实现接口 对于派生的FB执行，基FB的所有接口方法和接口属性都在派生的FB中以“存根”（未实现）的形式采用。您现在必须确保派生 FB 中的“空”方法\/属性与基础 FB 中实现的方法\/属性不冲突。为了帮助您解决此问题，会发生以下情况：如果有一个方法\/属性的基本实现，它会添加 CODESYS 在受影响的派生接口方法或接口属性的第一行输入编译指示属性 {error..}，这将生成相应的错误消息。如果方法\/属性没有基本实现，则有一个用于警告的 pragma 属性条目。编辑构建块后，您必须在每种情况下显式删除错误杂注属性条目。 有关更多信息，请参阅： 实现一个接口" }, 
{ "title" : "命令：将结果限制为当前声明 ", 
"url" : "_cds_cmd_limit_results_to_current_declaration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 菜单命令 \/ 其他 \/ 命令：将结果限制为当前声明 ", 
"snippet" : "将结果限制在当前声明范围内 功能 ：如果找到多个声明，该命令将折叠交叉引用列表中的显示。它仅显示您在列表中明确选择的声明的结果。 称呼 ： 上下文菜单 要求 ：交叉引用列表处于活动状态。您正在查找的符号的几个声明被列为交叉引用。...", 
"body" : "将结果限制在当前声明范围内 功能 ：如果找到多个声明，该命令将折叠交叉引用列表中的显示。它仅显示您在列表中明确选择的声明的结果。 称呼 ： 上下文菜单 要求 ：交叉引用列表处于活动状态。您正在查找的符号的几个声明被列为交叉引用。 " }, 
{ "title" : "对话框 ", 
"url" : "_cds_struct_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 ", 
"snippet" : "的对话框 CODESYS 用户界面基本上在帮助页面上都有描述 CODESYS 菜单命令或 CODESYS 对象。这 对话框 帮助部分仅包含以下对话框描述： 仅在菜单命令后或在对象编辑器中通过附加的多级调用显示的对话框的描述 由于复杂性而未包含在命令或对象帮助页面中的对话框的描述（多个子对话框）...", 
"body" : "的对话框 CODESYS 用户界面基本上在帮助页面上都有描述 CODESYS 菜单命令或 CODESYS 对象。这 对话框 帮助部分仅包含以下对话框描述： 仅在菜单命令后或在对象编辑器中通过附加的多级调用显示的对话框的描述 由于复杂性而未包含在命令或对象帮助页面中的对话框的描述（多个子对话框） " }, 
{ "title" : "对话框：导入助手 ", 
"url" : "_cds_dlg_import_assistant.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：导入助手 ", 
"snippet" : "导入助手 功能 ：该对话框允许传输 CODESYS 旧版本的选项和软件包安装 CODESYS 已在本地计算机中找到的安装。 称呼 ：对话框在最近安装时打开 CODESYS 版本首次启动并在计算机上安装了旧版本。 程序设置 : 习俗 CODESYS 选项从旧安装转移到新安装。 套餐 ：与旧版本一起安装的软件包 CODESYS 版本被转移到新版本的包管理器。为此，请参阅检测到的软件包安装列表，其中包含有关的详细信息 名称 , 版本 ， 和 安装日期 . 进口 程序设置和\/或选项被传输到当前 CODESYS 版本。 跳过 程序设置和\/或选项不会转移到当前 CODESYS 版本。 有关更多信息，请参阅...", 
"body" : "导入助手 功能 ：该对话框允许传输 CODESYS 旧版本的选项和软件包安装 CODESYS 已在本地计算机中找到的安装。 称呼 ：对话框在最近安装时打开 CODESYS 版本首次启动并在计算机上安装了旧版本。 程序设置 : 习俗 CODESYS 选项从旧安装转移到新安装。 套餐 ：与旧版本一起安装的软件包 CODESYS 版本被转移到新版本的包管理器。为此，请参阅检测到的软件包安装列表，其中包含有关的详细信息 名称 , 版本 ， 和 安装日期 . 进口 程序设置和\/或选项被传输到当前 CODESYS 版本。 跳过 程序设置和\/或选项不会转移到当前 CODESYS 版本。 有关更多信息，请参阅： CODESYS" }, 
{ "title" : "对话框：库引用转换 ", 
"url" : "_cds_dlg_library_reference_conversion.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：库引用转换 ", 
"snippet" : "库参考转换 功能 ：该对话框定义了如何处理对不再可用的库的引用。注意：未定义的库引用可以在位于 POU 看法。 称呼 : 当打开一个 CoDeSys V2.3 项目在 V3 ，当转换器检测到当前不能再使用的库时，对话框打开 CODESYS 版本。 一个 CoDeSys V2.3 项目可以转换为 CODESYS V3 项目仅当 CODESYS V2.3 Converter 包安装在 CODESYS V3 .该软件包可在 CODESYS Store International . 你想让我做什么？ 转换并安装库。 转换器还将库文件转换为新格式。它仍然在项目中被引用。它会自动安装在“其他”类别的库存...", 
"body" : "库参考转换 功能 ：该对话框定义了如何处理对不再可用的库的引用。注意：未定义的库引用可以在位于 POU 看法。 称呼 : 当打开一个 CoDeSys V2.3 项目在 V3 ，当转换器检测到当前不能再使用的库时，对话框打开 CODESYS 版本。 一个 CoDeSys V2.3 项目可以转换为 CODESYS V3 项目仅当 CODESYS V2.3 Converter 包安装在 CODESYS V3 .该软件包可在 CODESYS Store International . 你想让我做什么？ 转换并安装库。 转换器还将库文件转换为新格式。它仍然在项目中被引用。它会自动安装在“其他”类别的库存储库中。如果库没有为安装提供必要的项目信息，那么 输入项目信息 对话框打开以添加要添加的信息。 使用下面已经安装好的库 以前使用的库被另一个库替换。这 浏览 按钮打开一个对话框，用于从本地库存储库中进行选择。 忽略图书馆。引用不会出现在转换后的项目中 库引用将从项目中删除。 为该库引用的所有未来事件记住此映射 在对话框中进行的设置也用于未来的项目转换。 有关更多信息，请参阅： 打开 V2.3 项目" }, 
{ "title" : "对话框：选择功能块 ", 
"url" : "_cds_dlg_select_function_block.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选择功能块 ", 
"snippet" : "选择功能块 功能 ：该对话框用于选择 I\/O 映射的功能块。功能块应映射到在控制器上选择的 I\/O 通道 <设备名称> I\/O 映射 选项卡或在 <设备名称> IEC 对象 标签。 称呼 ： <设备名称> I\/O 映射 标签， 为 I\/O 通道添加 FB 命令按钮 <设备名称> IEC 对象 , 添加 命令按钮 该对话框提供来自活动应用程序的所有功能块以及项目中包含的满足以下要求的库： 该功能块具有 {attribute 'io_function_block'} 属性。 功能块包含与通道类型（输入、输出、数据类型）匹配的输入或输出参数，并且具有 {attribute 'io_function_...", 
"body" : "选择功能块 功能 ：该对话框用于选择 I\/O 映射的功能块。功能块应映射到在控制器上选择的 I\/O 通道 <设备名称> I\/O 映射 选项卡或在 <设备名称> IEC 对象 标签。 称呼 ： <设备名称> I\/O 映射 标签， 为 I\/O 通道添加 FB 命令按钮 <设备名称> IEC 对象 , 添加 命令按钮 该对话框提供来自活动应用程序的所有功能块以及项目中包含的满足以下要求的库： 该功能块具有 {attribute 'io_function_block'} 属性。 功能块包含与通道类型（输入、输出、数据类型）匹配的输入或输出参数，并且具有 {attribute 'io_function_block_mapping'} 属性。 选择提供多个匹配参数的功能块时，仅将第一个自动映射到通道。其他只能手动映射到 <设备名称> I\/O 映射 标签。 功能块映射后，将功能块实例的参数输入到 多变的 映射表的列。那么路径由以下组成： <application name>.<device channel name>_<FB name>_<incremented FB instance number>.<FB parameter name> 例子： App1.Out_4_Int_myScale_Output_Int_1.iOutput 为了 iOutput 的第一个插入实例的参数 myScale_Output 功能块 寻找 用于搜索功能块名称的输入字段 类型 树形结构中与通道类型匹配的功能块 节点：应用程序、库名称 文档 显示在树或库块中选择的库的可用文档 有关更多信息，请参阅： io_function_block, io_function_block_mapping" }, 
{ "title" : "对话框：设备转换 ", 
"url" : "_cds_dlg_device_conversion.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：设备转换 ", 
"snippet" : "设备转换 功能 ：该对话框定义了如何处理对不再可用的设备的引用。 称呼 : 当打开一个 CoDeSys V2.3 项目在 V3 ，当转换器检测到不能再使用的设备的引用时，对话框打开。 一个 CoDeSys V2.3 项目可以转换为 CODESYS V3 项目仅当 CODESYS V2.3 Converter 包安装在 CODESYS V3 .该软件包可在 CODESYS Store International . 你想让我做什么？ 使用以下已安装的设备 CODESYS 用另一个设备替换设备树中先前使用的设备。这 浏览 按钮打开一个对话框，用于从本地设备存储库中进行选择。 忽略设备。所有设备特定...", 
"body" : "设备转换 功能 ：该对话框定义了如何处理对不再可用的设备的引用。 称呼 : 当打开一个 CoDeSys V2.3 项目在 V3 ，当转换器检测到不能再使用的设备的引用时，对话框打开。 一个 CoDeSys V2.3 项目可以转换为 CODESYS V3 项目仅当 CODESYS V2.3 Converter 包安装在 CODESYS V3 .该软件包可在 CODESYS Store International . 你想让我做什么？ 使用以下已安装的设备 CODESYS 用另一个设备替换设备树中先前使用的设备。这 浏览 按钮打开一个对话框，用于从本地设备存储库中进行选择。 忽略设备。所有设备特定对象在新项目中都将不可用 设备条目及其下方插入的所有对象将从设备树中删除。 为该设备的所有未来事件记住此映射 在对话框中进行的设置保存在 CODESYS 选项，在 CoDeSys V2.3 V2.3 转换器 ， 类别。因此，它们也适用于未来的项目转换。 有关更多信息，请参阅： 打开 V2.3 项目" }, 
{ "title" : "对话框：断点属性 ", 
"url" : "_cds_dlg_breakpoint_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：断点属性 ", 
"snippet" : "断点属性 功能 ：该对话框用于显示或更改所选断点的属性 断点 看法。 称呼 ： 断点 看法， 特性 按钮 断点 看法， 新的 按钮， 新断点 命令或 新数据断点 命令 要求 ：在断点列表中选择了一个条目。 该对话框与 新断点 中打开的对话框 调试 菜单通过相应的命令。因此，请参阅帮助中的说明 新断点 对话。...", 
"body" : "断点属性 功能 ：该对话框用于显示或更改所选断点的属性 断点 看法。 称呼 ： 断点 看法， 特性 按钮 断点 看法， 新的 按钮， 新断点 命令或 新数据断点 命令 要求 ：在断点列表中选择了一个条目。 该对话框与 新断点 中打开的对话框 调试 菜单通过相应的命令。因此，请参阅帮助中的说明 新断点 对话。 " }, 
{ "title" : "对话框：权限 ", 
"url" : "_cds_dlg_permissions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：权限 ", 
"snippet" : "权限 功能 ：这里定义了用户组的权限，他们可以对项目中的特定对象执行特定的操作。 称呼 ： 项目→用户管理 命令 在对话框中所做的每个更改都会立即应用。...", 
"body" : "权限 功能 ：这里定义了用户组的权限，他们可以对项目中的特定对象执行特定的操作。 称呼 ： 项目→用户管理 命令 在对话框中所做的每个更改都会立即应用。 " }, 
{ "title" : "行动 ", 
"url" : "_cds_dlg_permissions.html#UUID-a96b28c3-bb7e-e6a6-49a3-ce72aed4d7c5_id_a4aafd27a7b86c0a8640e008b3558_id_bed3192ed33cb005c0a8640e01de9170", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：权限 \/ 行动 ", 
"snippet" : "对项目对象的所有可能操作都列在 行动 .动作分为四类，每个动作下方列出了项目所有当前对象的映射。对于每个“action->object”映射，您可以为每个现有用户组定义权限。 动作类别： 命令 关于执行命令的动作 用户、组和权限 有关配置用户帐户、用户组及其权限的操作 对象类型 有关创建对象类型的操作 项目对象 有关项目对象的查看、修改、删除和子对象处理的操作 详细操作： 执行 执行菜单命令 创建 在项目中创建一个新对象 添加或删除孩子 在现有对象下方添加或删除子对象 调整 在编辑器中修改对象或在相应的编辑器\/对话框中修改用户、组和权限设置 消除 删除或移除对象 看法 在编辑器中打开对象的视图...", 
"body" : "对项目对象的所有可能操作都列在 行动 .动作分为四类，每个动作下方列出了项目所有当前对象的映射。对于每个“action->object”映射，您可以为每个现有用户组定义权限。 动作类别： 命令 关于执行命令的动作 用户、组和权限 有关配置用户帐户、用户组及其权限的操作 对象类型 有关创建对象类型的操作 项目对象 有关项目对象的查看、修改、删除和子对象处理的操作 详细操作： 执行 执行菜单命令 创建 在项目中创建一个新对象 添加或删除孩子 在现有对象下方添加或删除子对象 调整 在编辑器中修改对象或在相应的编辑器\/对话框中修改用户、组和权限设置 消除 删除或移除对象 看法 在编辑器中打开对象的视图 行动的可能目标 这可以是项目的特定对象，也可以是用户、组和权限配置。 " }, 
{ "title" : "权限 ", 
"url" : "_cds_dlg_permissions.html#UUID-a96b28c3-bb7e-e6a6-49a3-ce72aed4d7c5_id_a4aafd27a7b86c0a8640e008b3558_id_c220390986c76268c0a864635794e243", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：权限 \/ 权限 ", 
"snippet" : "所有定义的用户组（“所有者”组除外）都列在 权限 带有用于配置组权限的工具栏。 的确 在操作视图中选择的对选定目标的操作是 的确 为选定的组。 拒绝 在 行动 查看，在选定的目标上是 拒绝 为选定的组。 执行操作的权限，在 行动 看来，在选定的目标上尚未明确定义。然而，动作是 默认授予 .例如，因为相应的权限已被授予父对象。示例：该组具有“myplc”对象的权限。因此，它也默认具有“myplc.pb_1”对象的权限。 在操作视图中展开的针对选定目标的操作未被明确拒绝。但是，默认情况下是拒绝的；例如，因为它已被“父对象”拒绝。 无符号 当前在“操作”视图中选择了多个操作，该组没有相同的权限。 工...", 
"body" : "所有定义的用户组（“所有者”组除外）都列在 权限 带有用于配置组权限的工具栏。 的确 在操作视图中选择的对选定目标的操作是 的确 为选定的组。 拒绝 在 行动 查看，在选定的目标上是 拒绝 为选定的组。 执行操作的权限，在 行动 看来，在选定的目标上尚未明确定义。然而，动作是 默认授予 .例如，因为相应的权限已被授予父对象。示例：该组具有“myplc”对象的权限。因此，它也默认具有“myplc.pb_1”对象的权限。 在操作视图中展开的针对选定目标的操作未被明确拒绝。但是，默认情况下是拒绝的；例如，因为它已被“父对象”拒绝。 无符号 当前在“操作”视图中选择了多个操作，该组没有相同的权限。 工具栏： 授予 对选定目标对象的选定操作被明确授予选定组。 否定 对选定组明确拒绝对选定目标对象的选定操作。 清除 对选定目标对象的选定操作的权限将重置为选定组的默认值。 进出口 使用命令打开菜单 导出所有权限 导出选定的权限 导入权限 导出所有权限 将当前项目的所有操作及其配置的访问权限导出到数据类型的用户特定文件 *.perms 为此， 出口许可 对话框打开，您可以指定文件名并选择文件目录中的位置。默认文件类型是 Permissions (*.perms) . 导出选定的权限 将当前项目的所有选定操作及其配置的访问权限导出到数据类型的用户特定文件 *.perms 为此， 出口许可 对话框打开，您可以指定文件名并选择文件目录中的位置。默认文件类型是 Permissions (*.perms) . 导入权限 一个内容 *.perms 文件与当前项目的操作和权限合并。属于文件但不属于项目的组将被忽略。操作和权限按名称对齐。 如果导入文件的权限与项目中的权限不同，则项目中的权限将被覆盖。 为此， 导入权限 打开供您选择 *.perms 文件系统中的文件。 有关更多信息，请参阅： 为项目和对象配置用户管理和访问权限 " }, 
{ "title" : "对话框：准备值 ", 
"url" : "_cds_dlg_prepare_value.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：准备值 ", 
"snippet" : "准备价值 功能 ：该对话框用于为强制变量准备一个值。 CODESYS 用下一个力执行准备好的动作。 CODESYS 在以下情况下打开对话框： 当您单击 准备值 声明部分中强制变量的字段 当您单击强制变量的内联监控字段时 当您单击 准备值 监控视图中强制变量的字段 为下一次写入或强制操作准备一个新值 值哪个 CODESYS 使用下一个强制操作写入变量 删除具有值的准备工作 CODESYS 删除准备好的值。 释放力，不修改值 CODESYS 保持强制值并结束强制。 CODESYS 用 <Unforce> . 释放力并将变量恢复到强制之前的值 CODESYS 重置强制值并结束强制。变量标记为 <Un...", 
"body" : "准备价值 功能 ：该对话框用于为强制变量准备一个值。 CODESYS 用下一个力执行准备好的动作。 CODESYS 在以下情况下打开对话框： 当您单击 准备值 声明部分中强制变量的字段 当您单击强制变量的内联监控字段时 当您单击 准备值 监控视图中强制变量的字段 为下一次写入或强制操作准备一个新值 值哪个 CODESYS 使用下一个强制操作写入变量 删除具有值的准备工作 CODESYS 删除准备好的值。 释放力，不修改值 CODESYS 保持强制值并结束强制。 CODESYS 用 <Unforce> . 释放力并将变量恢复到强制之前的值 CODESYS 重置强制值并结束强制。变量标记为 <Unforce and restore> . 有关更多信息，请参阅： 力值" }, 
{ "title" : "对话框：新断点 ", 
"url" : "_cds_dlg_new_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：新断点 ", 
"snippet" : "新断点 功能 ：在对话框中，定义新断点或数据断点的设置。它与 断点属性 对话框中使用 断点 看法。 称呼 ： 命令： 调试 → 新断点 命令： 新断点 要求 ：应用程序处于在线模式。...", 
"body" : "新断点 功能 ：在对话框中，定义新断点或数据断点的设置。它与 断点属性 对话框中使用 断点 看法。 称呼 ： 命令： 调试 → 新断点 命令： 新断点 要求 ：应用程序处于在线模式。 " }, 
{ "title" : "标签：条件 ", 
"url" : "_cds_dlg_new_breakpoint.html#UUID-816d639d-e87b-2c62-8afe-4b8f8899c45f_id_b37f8599ca5eabebc0a864630cdc6bd3_id_1c96e8afbc3c9a60c0a864633bdbd9c2", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：新断点 \/ 标签：条件 ", 
"snippet" : "该对话框定义了程序处理应在断点处停止的要求。 使用条件断点会减慢代码执行速度，即使条件不产生 TRUE . 条件断点需要一个 CODESYS 运行时系统 >= V3.5.4.0。 任务 仅在以下任务之一中命中断点时才中断 ： CODESYS 仅当特定任务到达断点时才评估断点。必须激活所需的任务。 例如，您可以定义一个“调试任务”，从而防止同样使用相同 POU 的其他任务在调试时受到影响。 命中数 命中数 总是打破 : 程序总是在这个断点处停止。 替代方案：程序在断点处停止时，如以下定义的那样频繁地到达断点（键入所需的命中计数或从数字列表中选择它）： 当命中数等于 当命中数是 的倍数时中断 当命...", 
"body" : "该对话框定义了程序处理应在断点处停止的要求。 使用条件断点会减慢代码执行速度，即使条件不产生 TRUE . 条件断点需要一个 CODESYS 运行时系统 >= V3.5.4.0。 任务 仅在以下任务之一中命中断点时才中断 ： CODESYS 仅当特定任务到达断点时才评估断点。必须激活所需的任务。 例如，您可以定义一个“调试任务”，从而防止同样使用相同 POU 的其他任务在调试时受到影响。 命中数 命中数 总是打破 : 程序总是在这个断点处停止。 替代方案：程序在断点处停止时，如以下定义的那样频繁地到达断点（键入所需的命中计数或从数字列表中选择它）： 当命中数等于 当命中数是 的倍数时中断 当命中数大于等于 状况 打破，当真实 ： CODESYS 仅在结果产生时评估指定条件并在断点处暂停程序 TRUE .您可以将条件定义为有效的布尔表达式。 例子： x>100 , x[y]=z , a AND b , boolVar " }, 
{ "title" : "标签：数据 ", 
"url" : "_cds_dlg_new_breakpoint.html#UUID-816d639d-e87b-2c62-8afe-4b8f8899c45f_id_b37f8599ca5eabebc0a864630cdc6bd3_id_44f01d14144802b9c0a8640e00e05719", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：新断点 \/ 标签：数据 ", 
"snippet" : "要求：这用于“数据断点”的属性。 数据断点的功能取决于目标系统。目前，数据断点只能通过 CODESYS Control Win . 在选项卡上，指定设置或将设置数据断点的变量或内存地址。 当变量或地址的值改变时中断执行 输入一个合格的变量名 : 选择变量 输入助手 对话框，在 观察变量 类别 例子 多变的： PLC_PRG.fb_DoSth.dwVariable 地址： 16#12A , 0x12A , 129 尺寸 应监视更改的指定变量或内存地址的字节数 当指定新变量或内存地址时，首先会自动设置与数据类型或内存匹配的值。 注意： 尺寸 和计数取决于目标系统。为了 CODESYS Contro...", 
"body" : "要求：这用于“数据断点”的属性。 数据断点的功能取决于目标系统。目前，数据断点只能通过 CODESYS Control Win . 在选项卡上，指定设置或将设置数据断点的变量或内存地址。 当变量或地址的值改变时中断执行 输入一个合格的变量名 : 选择变量 输入助手 对话框，在 观察变量 类别 例子 多变的： PLC_PRG.fb_DoSth.dwVariable 地址： 16#12A , 0x12A , 129 尺寸 应监视更改的指定变量或内存地址的字节数 当指定新变量或内存地址时，首先会自动设置与数据类型或内存匹配的值。 注意： 尺寸 和计数取决于目标系统。为了 CODESYS Control Win ，最多可以定义4个数据断点，最大大小为8字节。 例子： 4 对于数据类型 DWORD 例子： 2 对于数据类型 DWORD ：仅监视变量的前 2 个字节。 " }, 
{ "title" : "选项卡：执行点设置 ", 
"url" : "_cds_dlg_new_breakpoint.html#UUID-816d639d-e87b-2c62-8afe-4b8f8899c45f_id_b37f8599ca5eabebc0a864630cdc6bd3_id_e90f365e144802bbc0a8640e00766226", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：新断点 \/ 选项卡：执行点设置 ", 
"snippet" : "在这里，可以将现有断点或数据断点转换为执行点。 执行点（执行不会在断点处停止） ：断点成为执行点。此时处理不会停止，并且会执行给定的代码。 断点的执行点： 启用， 禁用 数据断点的执行点： 启用， 禁用 执行以下代码 到达执行点时执行的代码 循环结构（For、While）和 IF 或 CASE 表达式是不可能的。 在设备日志中打印一条消息 此选项仅在您选择 在断点中启用日志记录 选项在 项目设置→编译选项 . CODESYS 可以输出变量 {variable name} 消息文本中的占位符。...", 
"body" : "在这里，可以将现有断点或数据断点转换为执行点。 执行点（执行不会在断点处停止） ：断点成为执行点。此时处理不会停止，并且会执行给定的代码。 断点的执行点： 启用， 禁用 数据断点的执行点： 启用， 禁用 执行以下代码 到达执行点时执行的代码 循环结构（For、While）和 IF 或 CASE 表达式是不可能的。 在设备日志中打印一条消息 此选项仅在您选择 在断点中启用日志记录 选项在 项目设置→编译选项 . CODESYS 可以输出变量 {variable name} 消息文本中的占位符。 " }, 
{ "title" : "标签：位置 ", 
"url" : "_cds_dlg_new_breakpoint.html#UUID-816d639d-e87b-2c62-8afe-4b8f8899c45f_id_b37f8599ca5eabebc0a864630cdc6bd3_id_0620c3861dee5ba1c0a8640e0121f47f", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：新断点 \/ 标签：位置 ", 
"snippet" : "要求： 新断点 命令已被执行。 POU 断点所在的活动应用程序的 POU 位置 断点在 POU 中的位置 以行号和列号（文本编辑器）或网络号或元素号的形式输入 实例 在功能块的情况下，您必须定义断点是应该在实现中设置还是在实例中设置。 CODESYS 在实例中设置断点。对于此选项，请选择 实例路径 . CODESYS 在实现中设置断点。 立即启用断点 : 断点已启用。 : 断点被禁用。要稍后启用它，请单击 中的按钮 断点 看法。 有关更多信息，请参阅： 使用断点...", 
"body" : "要求： 新断点 命令已被执行。 POU 断点所在的活动应用程序的 POU 位置 断点在 POU 中的位置 以行号和列号（文本编辑器）或网络号或元素号的形式输入 实例 在功能块的情况下，您必须定义断点是应该在实现中设置还是在实例中设置。 CODESYS 在实例中设置断点。对于此选项，请选择 实例路径 . CODESYS 在实现中设置断点。 立即启用断点 : 断点已启用。 : 断点被禁用。要稍后启用它，请单击 中的按钮 断点 看法。 有关更多信息，请参阅： 使用断点" }, 
{ "title" : "对话框：监控范围 ", 
"url" : "_cds_dlg_monitoring_range.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：监控范围 ", 
"snippet" : "监测范围 功能 ：对话框限制了在监视期间显示其值的数组元素的范围。 称呼 : 点击 数据类型 属于数组变量的列字段。 要求 : POU 处于在线模式并被监控。此外，POU 的一个变量具有 大批 数据类型。 有效范围 被监控的数组元素的范围 一个三维数组的例子： [1..10][-3..3][-10..10] 数组元素的最大数量 数组变量的元素个数 例子： 1470 当您编辑其中一个 开始 , 结尾 ， 或者 1000 个元素的滚动范围 设置，其他两个设置都会自动调整。 开始 显示其值的第一个数组元素的索引 结尾 显示其值的最后一个数组元素的索引 1000 个元素的滚动范围 用于从数组元素集中选...", 
"body" : "监测范围 功能 ：对话框限制了在监视期间显示其值的数组元素的范围。 称呼 : 点击 数据类型 属于数组变量的列字段。 要求 : POU 处于在线模式并被监控。此外，POU 的一个变量具有 大批 数据类型。 有效范围 被监控的数组元素的范围 一个三维数组的例子： [1..10][-3..3][-10..10] 数组元素的最大数量 数组变量的元素个数 例子： 1470 当您编辑其中一个 开始 , 结尾 ， 或者 1000 个元素的滚动范围 设置，其他两个设置都会自动调整。 开始 显示其值的第一个数组元素的索引 结尾 显示其值的最后一个数组元素的索引 1000 个元素的滚动范围 用于从数组元素集中选择范围的滑块 有关更多信息，请参阅： 在编程对象中调用监控" }, 
{ "title" : "对话框：属性 ", 
"url" : "_cds_f_dlg_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 ", 
"snippet" : "特性 该对话框用于配置对象的属性 CODESYS .根据对象，对话框为此目的获得不同的选项卡，每个选项卡都处理一类属性。 称呼 ： 看法 菜单;中对象的上下文菜单 设备 看法， POU 查看，或 模块 看法 某些插件中的对象具有其他属性，这些属性在相应插件的帮助中进行了描述。这些特殊属性可以在以下位置找到： CODESYS Visualization : 可视化对象的属性 CODESYS Visualization Support : 属性:文本列表 CODESYS SFC : 属性：SFC 设置 CODESYS UML : UML 对象的属性 CODESYS CFC : 属性：CFC 执行订...", 
"body" : "特性 该对话框用于配置对象的属性 CODESYS .根据对象，对话框为此目的获得不同的选项卡，每个选项卡都处理一类属性。 称呼 ： 看法 菜单;中对象的上下文菜单 设备 看法， POU 查看，或 模块 看法 某些插件中的对象具有其他属性，这些属性在相应插件的帮助中进行了描述。这些特殊属性可以在以下位置找到： CODESYS Visualization : 可视化对象的属性 CODESYS Visualization Support : 属性:文本列表 CODESYS SFC : 属性：SFC 设置 CODESYS UML : UML 对象的属性 CODESYS CFC : 属性：CFC 执行订单 " }, 
{ "title" : "对话框：属性：一般的 ", 
"url" : "_cds_dlg_properties_common.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：一般的 ", 
"snippet" : "一般的 功能 ：对话框显示有关当前选定对象的一般信息。 称呼 ： 查看 → 属性 命令;对象的上下文菜单， 常见的 类别 要求 ：在设备树或 POU 视图中选择了一个对象。 名称 设备树或 POU 视图中显示的对象名称 对象类型 对象类型（例如，POU、应用程序或接口） 打开用 显示或编辑对象的编辑器类型...", 
"body" : "一般的 功能 ：对话框显示有关当前选定对象的一般信息。 称呼 ： 查看 → 属性 命令;对象的上下文菜单， 常见的 类别 要求 ：在设备树或 POU 视图中选择了一个对象。 名称 设备树或 POU 视图中显示的对象名称 对象类型 对象类型（例如，POU、应用程序或接口） 打开用 显示或编辑对象的编辑器类型 " }, 
{ "title" : "对话框：属性：信息 ", 
"url" : "_cds_dlg_properties_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：信息 ", 
"snippet" : "信息 函数 ：可以在此对话框中定义应用程序特定的属性。 打电话 : 查看 → 属性命令；的快捷菜单 应用程序 对象 要求 : 类型为的对象 应用程序 在设备视图或 POU 视图中处于选中状态。 当项目中有多个应用程序时，这些属性很有用。 作者 应用程序的作者 版本 应用程序的版本（示例： 0.0.0.1 ) 描述 应用程序的描述 重置为项目信息中的值 这些值将重置为项目信息中的值。 有关更多信息，请参阅： 项目信息...", 
"body" : "信息 函数 ：可以在此对话框中定义应用程序特定的属性。 打电话 : 查看 → 属性命令；的快捷菜单 应用程序 对象 要求 : 类型为的对象 应用程序 在设备视图或 POU 视图中处于选中状态。 当项目中有多个应用程序时，这些属性很有用。 作者 应用程序的作者 版本 应用程序的版本（示例： 0.0.0.1 ) 描述 应用程序的描述 重置为项目信息中的值 这些值将重置为项目信息中的值。 有关更多信息，请参阅： 项目信息" }, 
{ "title" : "对话框：属性：启动应用程序 ", 
"url" : "_cds_dlg_properties_boot_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：启动应用程序 ", 
"snippet" : "启动应用程序 功能 ：此选项卡上的设置定义何时以及如何 启动应用程序 是从应用程序创建的。 要求 ：设备支持这些设置。应用程序对象被选中。 称呼 ： 查看 → 属性 命令， 启动应用程序 类别; 特性 在上下文菜单中 在下载时创建隐式启动应用程序 下载应用程序时会自动创建引导应用程序。 在 Online Change 上创建隐式启动应用程序 在线更改期间会自动创建引导应用程序。 在项目关闭时提醒启动应用程序 在关闭项目之前， CODESYS 打开一个对话框提示，询问是否创建（新）引导应用程序。 创建后验证启动应用程序 创建启动应用程序后，一个独立的服务会检查启动应用程序是否已正确创建。 无论此...", 
"body" : "启动应用程序 功能 ：此选项卡上的设置定义何时以及如何 启动应用程序 是从应用程序创建的。 要求 ：设备支持这些设置。应用程序对象被选中。 称呼 ： 查看 → 属性 命令， 启动应用程序 类别; 特性 在上下文菜单中 在下载时创建隐式启动应用程序 下载应用程序时会自动创建引导应用程序。 在 Online Change 上创建隐式启动应用程序 在线更改期间会自动创建引导应用程序。 在项目关闭时提醒启动应用程序 在关闭项目之前， CODESYS 打开一个对话框提示，询问是否创建（新）引导应用程序。 创建后验证启动应用程序 创建启动应用程序后，一个独立的服务会检查启动应用程序是否已正确创建。 无论此处定义的预设如何，您始终可以在登录时显式创建引导应用程序。 " }, 
{ "title" : "对话框：属性：保安 ", 
"url" : "_cds_dlg_properties_encryption.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：保安 ", 
"snippet" : "保安 功能 ：该对话框包含用于加密的应用程序的属性。如果 CODESYS Security Agent 安装，然后您可以启动一个向导，用于加密下载、在线更改和启动应用程序。 称呼 ： 命令： 查看 → 属性 应用程序对象的上下文菜单 使用加密狗的加密不再被归类为安全加密方法。 建议改为使用证书加密。 加密技术 如果 对下载、在线更改和启动应用程序实施加密 选项被选中 安全屏幕 查看中 安全级别 组，则加密技术设置为 使用证书加密 并且不能在此对话框中更改。 有关更多信息，请参阅： 保护应用程序无加密 简单加密 只有当定义的加密狗（许可证密钥）连接到计算机时，您才能将启动应用程序下载到控制器。 ...", 
"body" : "保安 功能 ：该对话框包含用于加密的应用程序的属性。如果 CODESYS Security Agent 安装，然后您可以启动一个向导，用于加密下载、在线更改和启动应用程序。 称呼 ： 命令： 查看 → 属性 应用程序对象的上下文菜单 使用加密狗的加密不再被归类为安全加密方法。 建议改为使用证书加密。 加密技术 如果 对下载、在线更改和启动应用程序实施加密 选项被选中 安全屏幕 查看中 安全级别 组，则加密技术设置为 使用证书加密 并且不能在此对话框中更改。 有关更多信息，请参阅： 保护应用程序无加密 简单加密 只有当定义的加密狗（许可证密钥）连接到计算机时，您才能将启动应用程序下载到控制器。 加密狗由提供 CODESYS GmbH 或由各自的硬件制造商提供。显示公司代码。指定提供的产品代码。 使用许可证管理加密 只有在指定产品代码和固件代码后，您才能将启动应用程序下载到控制器，并且相应的加密狗连接到开发计算机和控制器。您从管理许可证的供应商处收到代码。 使用证书加密 仅当存在有效证书时，您才能将引导应用程序下载到控制器。这 证书 组已启用。请参阅下面的说明。 该选项已被选中，如果 对下载、在线更改和启动应用程序实施加密 选项被选中 用户 的选项卡 安全屏幕 看法。 您还可以选择 数字签名应用程序代码 选项。 用证书签名 只有使用有效证书签名后，您才能将应用程序代码下载到控制器。在这种情况下不需要加密。 证书 注意：如果 对下载、在线更改和启动应用程序实施加密 选项被选中 安全屏幕 查看中 安全级别 组，则加密技术设置为 使用证书加密 并且不能在 特性 对话。 : 这 证书选择 对话框打开。您可以在此处选择已启用下载、在线更改和启动应用程序加密的设备的先前安装的证书。如果多个设备被授权运行此应用程序，则该列表可以包含多个条目。 数字签名应用程序代码 该应用程序使用数字签名进行签名。数字签名的证书在 安全屏幕 查看 用户 标签。 显示所选证书和相应信息的区域 每个证书的信息： 颁发给 由...发出 有效期自 有效期至 指纹 加密向导 此按钮仅在以下情况下可用 CODESYS Security Agent 已安装。它启动具有相同名称的向导。为此，请参阅帮助 CODESYS Security Agent . 有关更多信息，请参阅： 保护和保存项目 和帮助 CODESYS Security Agent " }, 
{ "title" : "对话框：属性：构建 ", 
"url" : "_cds_dlg_properties_build.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：构建 ", 
"snippet" : "建造 象征： 功能 ：对话框包含用于编译（构建操作）对象的选项。 称呼 ： 查看 → 属性 命令;设备树中对象的上下文菜单 名称 描述 从构建中排除 ：这个对象和它的递归子对象不包含在下一个编译操作中。 对象条目以绿色字体显示在 设备 查看或在 POU 看法。 外部实施 （运行时系统中的后期链接） ： CODESYS 编译项目时不会为此对象生成任何代码。只要项目在目标系统上运行，对象就会被链接，前提是它存在于那里（例如，在库中）。 这些对象名称（功能块和方法）的最大长度为 64 个字符。 对象名称附加 (EXT) 在里面 设备 查看或在 POU 看法。 启用系统调用 ：功能的系统调用（运行时系...", 
"body" : "建造 象征： 功能 ：对话框包含用于编译（构建操作）对象的选项。 称呼 ： 查看 → 属性 命令;设备树中对象的上下文菜单 名称 描述 从构建中排除 ：这个对象和它的递归子对象不包含在下一个编译操作中。 对象条目以绿色字体显示在 设备 查看或在 POU 看法。 外部实施 （运行时系统中的后期链接） ： CODESYS 编译项目时不会为此对象生成任何代码。只要项目在目标系统上运行，对象就会被链接，前提是它存在于那里（例如，在库中）。 这些对象名称（功能块和方法）的最大长度为 64 个字符。 对象名称附加 (EXT) 在里面 设备 查看或在 POU 看法。 启用系统调用 ：功能的系统调用（运行时系统）是可能的。 背景：不同于 CoDeSys V2.3 , ADR 算子在 V3 可以与函数名、程序名、功能块名和方法名一起使用。它取代了 INSTANCE_OF 操作员。 但是：不可能从内部调用函数指针 CODESYS . 始终链接 ：对象在编译器中被标记，因此总是包含在编译信息中。这意味着它总是被编译并下载到控制器。 注意：编译指示 {属性“始终链接”} 也可以用来指示编译器总是包含一个对象。 编译器定义 在这里您可以指定“定义”或编译对象的条件（条件编译）。您还可以指定 expr 表达式，用于这些类型的 pragma。多个条目可以作为逗号分隔的列表（请参阅 {define} 声明）。 例子： hello, test:='1' 设备描述中的其他编译器定义 在设备中定义 源自设备描述的编译器定义列表 如果这些编译器定义未在 忽略的定义 场地。 忽略的定义 设备描述中未在构建中使用的编译器定义列表 从 在设备中定义 领域到 忽略的定义 场地 将选定的编译器定义从 忽略的定义 领域到 在设备中定义 场地 编译器定义在构建中使用。 有关更多信息，请参阅： 条件指令" }, 
{ "title" : "对话框：属性：访问控制 ", 
"url" : "_cds_dlg_properties_access_control.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：访问控制 ", 
"snippet" : "访问控制 功能 ：该选项卡用于定义允许哪些用户组对对象执行哪些操作。 称呼 ： 查看 → 属性 命令;上下文菜单， 特性 命令， 访问控制 标签 要求 : 对象被选中 设备 查看或在 POU 看法。 组、操作和权限 显示现有用户组对对象具有以下哪些权限的表： 看法 编辑 消除 添加\/删除孩子 您可以双击权限符号以打开所有可能权限的列表框。 有关更多信息，请参阅： 使用访问权限保护项目中的对象...", 
"body" : "访问控制 功能 ：该选项卡用于定义允许哪些用户组对对象执行哪些操作。 称呼 ： 查看 → 属性 命令;上下文菜单， 特性 命令， 访问控制 标签 要求 : 对象被选中 设备 查看或在 POU 看法。 组、操作和权限 显示现有用户组对对象具有以下哪些权限的表： 看法 编辑 消除 添加\/删除孩子 您可以双击权限符号以打开所有可能权限的列表框。 有关更多信息，请参阅： 使用访问权限保护项目中的对象 " }, 
{ "title" : "对话框：属性 - 外部文件 ", 
"url" : "_cds_dlg_properties_external_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性 - 外部文件 ", 
"snippet" : "属性 - 外部文件 功能 ：所选对象的属性（类型 外部文件  ) 显示在此对话框中。属性最初是在将对象添加到设备树或池时设置的，可以在此属性对话框中进行调整。 称呼 ： 查看 → 属性 命令;对象的上下文菜单 要求 ： 在里面 设备 查看或 计划书 视图，类型的对象 外部文件 被选中。 有关详细信息，请参阅： 外部文件文件处理 确定外部文件如何保存在 CODESYS 项目 记住链接 ：保存Windows文件系统中指向外部文件的文件链接。 注意：如果文件的外部位置发生变化，通过文件链接访问将失败。仅当文件存在于定义的存储位置中时，该文件才在项目中可用。 记住链接并嵌入到项目中 ：保存Window...", 
"body" : "属性 - 外部文件 功能 ：所选对象的属性（类型 外部文件  ) 显示在此对话框中。属性最初是在将对象添加到设备树或池时设置的，可以在此属性对话框中进行调整。 称呼 ： 查看 → 属性 命令;对象的上下文菜单 要求 ： 在里面 设备 查看或 计划书 视图，类型的对象 外部文件 被选中。 有关详细信息，请参阅： 外部文件文件处理 确定外部文件如何保存在 CODESYS 项目 记住链接 ：保存Windows文件系统中指向外部文件的文件链接。 注意：如果文件的外部位置发生变化，通过文件链接访问将失败。仅当文件存在于定义的存储位置中时，该文件才在项目中可用。 记住链接并嵌入到项目中 ：保存Windows文件系统中指向外部文件的文件链接。此外，为了提高安全性，该文件的副本存储在项目中。 注意访问行为： 仅当通过链接访问失败时，才能访问项目中的副本。 如果外部文件发生变化，则根据在下面选择的选项处理副本 当外部文件改变时，则 . 嵌入到项目中 ：外部文件的副本保存在 Windows 文件系统中。 注意：始终访问该副本。如果外部文件发生更改，则不会更新项目内部副本。 当外部文件改变时，则 在同时保存了文件链接的项目中保存的副本的更新类型 要求： 记住链接并嵌入到项目中 选项被选中。 自动重新加载文件 ：如果外部文件发生变化，则更新存储在项目中的副本。 提示是否重新加载文件 ：如果外部文件发生更改，则会打开一个对话框提示，让您决定是否应在项目中更新副本。 没做什么 ：虽然外部文件发生变化，但项目中的副本保持不变。 链接文件 项目中保存的文件链接信息 要求：要么 记住链接 选项或 记住链接并嵌入到项目中 选项被选中。 姓名 , 地点 , 尺寸 , 改变了 有关文件链接的信息 按钮： 显示文件属性 打开默认 <文件名> 的属性 Windows 文件系统中的外部文件对话框 此对话框与 特性 可以从文件的上下文菜单在 Windows 中打开的对话框。 嵌入式文件 有关项目中保存的副本的信息 要求：要么 记住链接并嵌入到项目中 选项或 嵌入到项目中 选项被选中。 尺寸 , 改变了 有关副本的信息（嵌入文件） 更新嵌入文件 : 如果添加到项目中的外部文件在指定的文件路径中发生了变化，那么 CODESYS 更新项目中的嵌入文件。 在线办理 在线模式下处理文件 使用下载\/在线更改传输 ：当发生下载和在线更改时，外部文件被下载到控制器并存储在 目标路径 . 目标路径（相对于设备上的“$PlcLogic$”） 可以通过以下方式指定目标路径： 为了 $PlcLogic$ 根目录：将输入字段留空 根目录中的单个文件夹（尚不可用） 例子： MySubDirectory 应用程序的文件夹（下面 $PlcLogic$ ) “App123”应用程序示例： App123 应用程序文件夹下的嵌套文件夹结构 例子： App123\/Sub01\/SubSub01 使用另一个可用的占位符 可视化示例： $visu$ 使用可用路径时，请注意大小写。 按钮 好的 应用设置 目的 " }, 
{ "title" : "对话框：属性：位图 ", 
"url" : "_cds_dlg_properties_bitmap.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：位图 ", 
"snippet" : "位图 功能 ：该对话框用于定义对象是否获取位图文件（图像文件）以及哪个。位图用于库管理器的图形视图和 工具箱 FBD\/LD\/IL 编辑器的视图。 称呼 ： 查看 → 属性 命令;对象的上下文菜单 要求 ：对象在 设备 查看或 POU 看法。 透明色 此颜色在位图中透明显示。...", 
"body" : "位图 功能 ：该对话框用于定义对象是否获取位图文件（图像文件）以及哪个。位图用于库管理器的图形视图和 工具箱 FBD\/LD\/IL 编辑器的视图。 称呼 ： 查看 → 属性 命令;对象的上下文菜单 要求 ：对象在 设备 查看或 POU 看法。 透明色 此颜色在位图中透明显示。 " }, 
{ "title" : "对话框：属性：应用程序构建选项 ", 
"url" : "_cds_dlg_properties_options_app_generation.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：应用程序构建选项 ", 
"snippet" : "应用程序构建选项 功能 ：对话框包括设置 CODESYS 用于为控制器生成引导应用程序。 称呼 ： 查看 → 属性 命令;应用程序对象的上下文菜单 下载申请资料 此功能需要编译器版本 >=3.5.0.0，运行时系统版本 >= 3.5.0.0。 有关应用程序内容的信息也被下载到控制器。我们建议您保持启用此选项，因为它允许在当前应用程序和控制器上的应用程序之间进行差异检查。比较包括 POU 的数量、数据的数量和内存位置的数量。 要获取有关差异的信息，请单击 细节 在里面 应用 设备编辑器的选项卡。这也在消息视图中，当您将应用程序下载到控制器时，只要它与控制器上存在的应用程序不同，就会打开该消息视图...", 
"body" : "应用程序构建选项 功能 ：对话框包括设置 CODESYS 用于为控制器生成引导应用程序。 称呼 ： 查看 → 属性 命令;应用程序对象的上下文菜单 下载申请资料 此功能需要编译器版本 >=3.5.0.0，运行时系统版本 >= 3.5.0.0。 有关应用程序内容的信息也被下载到控制器。我们建议您保持启用此选项，因为它允许在当前应用程序和控制器上的应用程序之间进行差异检查。比较包括 POU 的数量、数据的数量和内存位置的数量。 要获取有关差异的信息，请单击 细节 在里面 应用 设备编辑器的选项卡。这也在消息视图中，当您将应用程序下载到控制器时，只要它与控制器上存在的应用程序不同，就会打开该消息视图。 异常时停止父应用程序 可用于具有父应用程序的应用程序 动态内存设置 内存是为应用程序动态分配的，例如在使用 __NEW 操作员。在这种情况下，您定义所需的 最大内存大小（字节） . 注意：整个内存不可用于动态创建对象。相反，系统总是将其中的一部分用于管理信息。 有关更多信息，请参阅： 生成应用程序代码" }, 
{ "title" : "对话框：属性： 目标内存设置 ", 
"url" : "_cds_dlg_properties_target_memory_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性： 目标内存设置 ", 
"snippet" : "目标内存设置 功能 ：该对话框允许更改目标设备的内存设置。 称呼 ： 查看 → 属性 命令;应用程序的上下文菜单 要求 ：应用程序在 设备 看法。 覆盖目标内存设置 : 存储在设备描述中的内存设置被指定的值覆盖 输入尺寸 , 输出尺寸 ， 和 内存大小 . 注意：如果目标设备的内存设置发生更改，则无法再登录目标设备上的现有应用程序，也无法进行在线更改。 输入尺寸 输出尺寸 内存大小 用于覆盖内存大小的输入字段 \"memory-layout\\\\input-size\" , \"memory-layout\\\\output-size\" ， 和 \"memory-layout\\\\memory-size\" 存...", 
"body" : "目标内存设置 功能 ：该对话框允许更改目标设备的内存设置。 称呼 ： 查看 → 属性 命令;应用程序的上下文菜单 要求 ：应用程序在 设备 看法。 覆盖目标内存设置 : 存储在设备描述中的内存设置被指定的值覆盖 输入尺寸 , 输出尺寸 ， 和 内存大小 . 注意：如果目标设备的内存设置发生更改，则无法再登录目标设备上的现有应用程序，也无法进行在线更改。 输入尺寸 输出尺寸 内存大小 用于覆盖内存大小的输入字段 \"memory-layout\\\\input-size\" , \"memory-layout\\\\output-size\" ， 和 \"memory-layout\\\\memory-size\" 存储在设备描述中的值 要求： 覆盖目标内存设置 选项被选中。 " }, 
{ "title" : "对话框：属性：网络变量 ", 
"url" : "_cds_dlg_properties_networkvariables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：网络变量 ", 
"snippet" : "网络变量 象征： 功能 ：在此对话框中，为在设备树中选择的变量列表定义网络属性。此外，其中任何被声明为网络变量的变量也是可用的。 称呼 ： 设备树中变量列表的上下文菜单 → 属性 , 网络变量 标签 网络类型 UDP 任务 当前应用程序的任务，它控制要发送的变量 CODESYS 总是在任务循环结束时发送变量。 列表标识符 用于标识网络变量列表 必须是独一无二的 包变量 传输的包（电报）的大小取决于网络类型。如果是 UDP ，一个包是256字节。 ： CODESYS 将要发送的变量捆绑在包中，以尽可能减少要发送的包的数量。对于数组类型或结构化数据类型的变量，这可能导致将变量拆分为多个报文。因此，...", 
"body" : "网络变量 象征： 功能 ：在此对话框中，为在设备树中选择的变量列表定义网络属性。此外，其中任何被声明为网络变量的变量也是可用的。 称呼 ： 设备树中变量列表的上下文菜单 → 属性 , 网络变量 标签 网络类型 UDP 任务 当前应用程序的任务，它控制要发送的变量 CODESYS 总是在任务循环结束时发送变量。 列表标识符 用于标识网络变量列表 必须是独一无二的 包变量 传输的包（电报）的大小取决于网络类型。如果是 UDP ，一个包是256字节。 ： CODESYS 将要发送的变量捆绑在包中，以尽可能减少要发送的包的数量。对于数组类型或结构化数据类型的变量，这可能导致将变量拆分为多个报文。因此，即使变量大小小于包大小，这些变量中也可能出现数据不一致。 ： CODESYS 每个变量生成一个包。 发送校验和 ：为每个变量包提供校验和。接收方检查校验和以确保来自发送方和接收方的变量定义匹配。不接受具有冲突校验和的包。 致谢 ： CODESYS 为每个接收到的数据包发送确认消息。如果发送方在再次发送之前没有收到确认，则将错误写入诊断结构。 注意：对于 NetVarUdp 库版本 3.5.7.0 及更高版本，当未选择确认传输时不再分配接收器通道。因此，一个硬件设备上的两个控制器之间也可以进行网络变量交换。 循环传输 , 间隔 CODESYS 在定义的时间间隔内发送变量。 时间定义示例：“T#70ms” 更改时发送 , 最小间隙 ： CODESYS 仅当变量的值已更改时才发送变量。您可以使用“最小间隙”来定义两次传输之间的最短时间。 发送事件 , 多变的 ： CODESYS 一旦定义的变量产生，就发送变量 TRUE . 设置 特定于协议的设置 可能的条目取决于网络库： 港口 : 端口号 CODESYS 用于与其他网络单元进行数据交换 这 默认值 是“1202”。 您可以随时更改当前值 价值 字段：选择字段，按 空格键 ，并指定值。 警告 ：网络中的其他节点必须定义相同的端口。如果项目中定义了多个 UDP 连接，则所有配置中的端口号都适应该值。 广播广告。 ： 这 默认值 是 255.255.255.255，这意味着将与所有网络单元进行数据交换。 您可以随时更改当前值 价值 字段：选择字段，按 空格键 ，并指定子网的地址或地址范围。 例子： 197.200.100.255 何时应与 IP 地址在“197.200.100.x”范围内的所有节点进行通信 有关更多信息，请参阅： 配置网络变量交换" }, 
{ "title" : "对话框：属性：网络设置 ", 
"url" : "_cds_dlg_properties_network_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：网络设置 ", 
"snippet" : "网络设置 如果设备支持网络功能，则 GNVL（全局网络变量列表）的当前网络设置可以在 特性 对象的对话框。这些是在添加 GNVL 时使用的设置 添加网络变量列表（接收方） 对话。 有关更多信息，请参阅： 配置网络变量交换...", 
"body" : "网络设置 如果设备支持网络功能，则 GNVL（全局网络变量列表）的当前网络设置可以在 特性 对象的对话框。这些是在添加 GNVL 时使用的设置 添加网络变量列表（接收方） 对话。 有关更多信息，请参阅： 配置网络变量交换" }, 
{ "title" : "对话框：属性：链接到文件 ", 
"url" : "_cds_dlg_properties_link_to_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：链接到文件 ", 
"snippet" : "链接到文件 功能 ：对话框定义外部文件与全局变量列表 (GVL) 内容的链接。您可以将 GVL 导出到外部文件或从外部文件导入。 称呼 ： 查看 → 属性 命令; a 的上下文菜单 全局变量列表 目的 文件名 文件路径输入栏 编译前导出 ：在项目的每次编译之前（例如，与 F11 ), CODESYS 保存一个文件 gvl 路径中的扩展名，在 文件名 场地。 编译前导入 : 中指定的导出文件 文件名 在每个项目编译之前自动读取字段。因此，您可以导入从另一个项目导出的 GVL，例如通过网络变量设置通信。...", 
"body" : "链接到文件 功能 ：对话框定义外部文件与全局变量列表 (GVL) 内容的链接。您可以将 GVL 导出到外部文件或从外部文件导入。 称呼 ： 查看 → 属性 命令; a 的上下文菜单 全局变量列表 目的 文件名 文件路径输入栏 编译前导出 ：在项目的每次编译之前（例如，与 F11 ), CODESYS 保存一个文件 gvl 路径中的扩展名，在 文件名 场地。 编译前导入 : 中指定的导出文件 文件名 在每个项目编译之前自动读取字段。因此，您可以导入从另一个项目导出的 GVL，例如通过网络变量设置通信。 " }, 
{ "title" : "对话框：属性：选项 ", 
"url" : "_cds_dlg_properties_options_controller.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：选项 ", 
"snippet" : "选项...", 
"body" : "选项 " }, 
{ "title" : "选项（控制器） ", 
"url" : "_cds_dlg_properties_options_controller.html#UUID-b4ec29e7-91f8-fff3-50ec-7d1a39d7664e_id_efceb58c0a2747d2c0a8640e01d2593a_id_3199fa7b528ae709c0a8640e01bcacf4", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：选项 \/ 选项（控制器） ", 
"snippet" : "功能 ：对话框包含设备对象的监控和登录设置。设备描述决定了哪些选项可用。 称呼 ：设备对象的上下文菜单； 查看 → 属性 选择设备对象时的命令 监测间隔（毫秒） 监测间隔（10–1000 毫秒） 交互式登录模式 此模式用于防止意外登录到另一个控制器。 没有任何 登录时不与用户交互 对应旧版本之前的行为 输入身份证 CODESYS 要求您在登录时提供 ID。 ID 存储在控制器中。没有有效的 ID 是无法登录的。 下次登录时， CODESYS 如果计算机名称、用户名、设备名称和设备地址未更改，则不再要求提供 ID。信息存储在项目选项中。 按键 登录时，会打开一个对话框，提示您按控制器上的一个键。...", 
"body" : "功能 ：对话框包含设备对象的监控和登录设置。设备描述决定了哪些选项可用。 称呼 ：设备对象的上下文菜单； 查看 → 属性 选择设备对象时的命令 监测间隔（毫秒） 监测间隔（10–1000 毫秒） 交互式登录模式 此模式用于防止意外登录到另一个控制器。 没有任何 登录时不与用户交互 对应旧版本之前的行为 输入身份证 CODESYS 要求您在登录时提供 ID。 ID 存储在控制器中。没有有效的 ID 是无法登录的。 下次登录时， CODESYS 如果计算机名称、用户名、设备名称和设备地址未更改，则不再要求提供 ID。信息存储在项目选项中。 按键 登录时，会打开一个对话框，提示您按控制器上的一个键。此操作的超时时间在设备描述中定义。 眨眼（=使 LED 闪烁） 连接的控制器在登录时闪烁。 符号配置 访问与 IEC 任务同步的变量 ： 默认设置;不允许一致访问 : 允许一致访问 只有在您下载所有应用程序并重新启动应用程序到控制器后，该设置才有效。 注意：选择该选项后，该设备上所有 IEC 应用的抖动都会增加。一致访问会中断实时功能。 有关更多信息，请参阅： 设备和通用设备编辑器 和 图标配置 " }, 
{ "title" : "对话框：属性：监控 ", 
"url" : "_cds_dlg_properties_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：属性 \/ 对话框：属性：监控 ", 
"snippet" : "监控 功能 ：该选项卡包含用于监控的选项 过渡 在证监会。 称呼 ：选择一个过渡对象，然后 特性 在上下文菜单中或 查看 → 属性 命令 启用监控 ：为转换创建一个隐式变量，然后在应用程序调用转换方法时始终为其赋予当前属性值。最后存储在此变量中的值显示在监控中。 使用呼叫监控 : 直接调用transition读取要监控的transition。 注意：当您选择此选项时，您必须考虑可能的副作用。如果在过渡中实施了额外的操作，就会出现这些副作用。 有关更多信息，请参阅： monitoring...", 
"body" : "监控 功能 ：该选项卡包含用于监控的选项 过渡 在证监会。 称呼 ：选择一个过渡对象，然后 特性 在上下文菜单中或 查看 → 属性 命令 启用监控 ：为转换创建一个隐式变量，然后在应用程序调用转换方法时始终为其赋予当前属性值。最后存储在此变量中的值显示在监控中。 使用呼叫监控 : 直接调用transition读取要监控的transition。 注意：当您选择此选项时，您必须考虑可能的副作用。如果在过渡中实施了额外的操作，就会出现这些副作用。 有关更多信息，请参阅： monitoring" }, 
{ "title" : "对话框：项目设置 ", 
"url" : "_cds_f_dlg_project_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 ", 
"snippet" : "项目设置 象征： 功能 ：对象包含项目的基本配置。它可以在编辑 项目设置 对话。 称呼 : 双击 项目设置 设备树中的对象； 项目 → 项目设置 命令 CODESYS 将项目设置直接保存在项目中。例如，当您将项目传输到另一个系统时， 项目设置 对象随它一起转移。不需要项目存档。 项目设置在整个项目中都有效，并且根据安装的包，为各种类别提供可能的设置，例如 证监会 或者 用户和组 ....", 
"body" : "项目设置 象征： 功能 ：对象包含项目的基本配置。它可以在编辑 项目设置 对话。 称呼 : 双击 项目设置 设备树中的对象； 项目 → 项目设置 命令 CODESYS 将项目设置直接保存在项目中。例如，当您将项目传输到另一个系统时， 项目设置 对象随它一起转移。不需要项目存档。 项目设置在整个项目中都有效，并且根据安装的包，为各种类别提供可能的设置，例如 证监会 或者 用户和组 . " }, 
{ "title" : "对话框：项目设置：用户和组 ", 
"url" : "_cds_dlg_project_settings_user_groups.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：用户和组 ", 
"snippet" : "用户和组 象征： 功能 ：该对话框用于配置当前项目的用户管理。 称呼 ： 项目 → 项目设置 命令， 用户和组 类别...", 
"body" : "用户和组 象征： 功能 ：该对话框用于配置当前项目的用户管理。 称呼 ： 项目 → 项目设置 命令， 用户和组 类别 " }, 
{ "title" : "标签：用户 ", 
"url" : "_cds_dlg_project_settings_user_groups.html#UUID-2be88356-b96d-20b2-57af-5b575487a87f_id_c4a56f464271c61c0a8640e019890cd_id_bd8ddfdd6488f1d2c0a8640e00905b40", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：用户和组 \/ 标签：用户 ", 
"snippet" : "显示用户及其在组中的成员身份 添加 打开 添加用户 对话 编辑 打开 编辑用户 对话 删除 如果您尝试删除组的最后一个用户，则会出现错误消息，因为组必须至少有一个成员。 添加用户 \/ 编辑用户 用于设置新用户帐户或更改现有用户帐户的输入字段 积极的 ：（默认）您可以使用用户帐户。 ：用户无法登录。如果用户反复尝试使用错误的凭据登录，则可能导致帐户自动停用（见下文：设置）。 会员资格 您定义的所有用户组的列表，除了 每个人 组（每个新用户自动所属的组） <组名>：新用户属于该组。 进出口 导出用户和组 该命令打开用于在本地文件系统中保存文件的默认对话框。您可以将已在项目中定义的用户和组存储到 *...", 
"body" : "显示用户及其在组中的成员身份 添加 打开 添加用户 对话 编辑 打开 编辑用户 对话 删除 如果您尝试删除组的最后一个用户，则会出现错误消息，因为组必须至少有一个成员。 添加用户 \/ 编辑用户 用于设置新用户帐户或更改现有用户帐户的输入字段 积极的 ：（默认）您可以使用用户帐户。 ：用户无法登录。如果用户反复尝试使用错误的凭据登录，则可能导致帐户自动停用（见下文：设置）。 会员资格 您定义的所有用户组的列表，除了 每个人 组（每个新用户自动所属的组） <组名>：新用户属于该组。 进出口 导出用户和组 该命令打开用于在本地文件系统中保存文件的默认对话框。您可以将已在项目中定义的用户和组存储到 *.users XML 格式的文件。 导入用户和组 该命令打开默认对话框以搜索带有 *.users 本地文件系统中的扩展名，以便将用户和组定义读入项目。 " }, 
{ "title" : "标签：组 ", 
"url" : "_cds_dlg_project_settings_user_groups.html#UUID-2be88356-b96d-20b2-57af-5b575487a87f_id_c4a56f464271c61c0a8640e019890cd_id_a09a4f276488f1d3c0a8640e011cd62d", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：用户和组 \/ 标签：组 ", 
"snippet" : "显示组及其成员 组也可以是组的成员。 添加 打开 添加组 对话 编辑 打开 编辑组 对话 删除 删除组时，成员的用户帐户保持不变。 您无法删除 每个人 和 所有者 团体。 有关信息 进出口 按钮，见说明 用户 上面的标签。...", 
"body" : "显示组及其成员 组也可以是组的成员。 添加 打开 添加组 对话 编辑 打开 编辑组 对话 删除 删除组时，成员的用户帐户保持不变。 您无法删除 每个人 和 所有者 团体。 有关信息 进出口 按钮，见说明 用户 上面的标签。 " }, 
{ "title" : "标签：设置 ", 
"url" : "_cds_dlg_project_settings_user_groups.html#UUID-2be88356-b96d-20b2-57af-5b575487a87f_id_c4a56f464271c61c0a8640e019890cd_id_fa0bbb63c47411e3a9c4fffae27ed7af", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：用户和组 \/ 标签：设置 ", 
"snippet" : "以树状结构显示组及其成员 组也可以是组的成员。 最大验证试验次数 ：（默认）如果用户尝试使用错误密码登录的次数达到此处指定的次数，则用户帐户将被禁用。 ：不成功的尝试次数是无限的。 不活动时间后自动注销 : 用户自动登出，如果 CODESYS 在此处指定的时间跨度（以分钟为单位）内，不会从鼠标或键盘注册任何用户操作。 有关更多信息，请参阅： 保护和保存项目...", 
"body" : "以树状结构显示组及其成员 组也可以是组的成员。 最大验证试验次数 ：（默认）如果用户尝试使用错误密码登录的次数达到此处指定的次数，则用户帐户将被禁用。 ：不成功的尝试次数是无限的。 不活动时间后自动注销 : 用户自动登出，如果 CODESYS 在此处指定的时间跨度（以分钟为单位）内，不会从鼠标或键盘注册任何用户操作。 有关更多信息，请参阅： 保护和保存项目" }, 
{ "title" : "对话框：项目设置：库开发 ", 
"url" : "_cds_library_development.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：库开发 ", 
"snippet" : "图书馆开发 符号： 函数 : 的参数配置 检查所有泳池对象 命令。此命令特别用于库，以检查所有对象是否可以正确编译。 打电话 : 项目 → 项目设置 ， 图书馆开发 类别 要求 : 项目已打开。 在应用程序的编译过程中，只有应用程序代码实际直接或间接使用的函数块\/程序\/函数才会被编译。但是， 检查所有泳池对象 命令还会检查未使用的功能块\/程序\/函数。如果可能，应考虑代码中的所有执行路径。 编译器定义要使用 扫描 扫描库的所有功能块\/程序\/函数，然后输入编译器定义，该编译器定义为逗号分隔的列表 编译器定义要使用 概述。 用于级联 {IF defined(...)}-{ELSIF defined(...", 
"body" : "图书馆开发 符号： 函数 : 的参数配置 检查所有泳池对象 命令。此命令特别用于库，以检查所有对象是否可以正确编译。 打电话 : 项目 → 项目设置 ， 图书馆开发 类别 要求 : 项目已打开。 在应用程序的编译过程中，只有应用程序代码实际直接或间接使用的函数块\/程序\/函数才会被编译。但是， 检查所有泳池对象 命令还会检查未使用的功能块\/程序\/函数。如果可能，应考虑代码中的所有执行路径。 编译器定义要使用 扫描 扫描库的所有功能块\/程序\/函数，然后输入编译器定义，该编译器定义为逗号分隔的列表 编译器定义要使用 概述。 用于级联 {IF defined(...)}-{ELSIF defined(...)} 语句，只有定义于 {IF} 已考虑在内。 检查所有泳池对象 要使用的指针大小 如果将 POINTER 变量保存在库的 DWORD 变量中，则该库只能针对 32 位设备进行编译。 要检测并避免此问题，可以指定应为指针大小 检查所有泳池对象 命令。您可以选择以下值： 32 位 64 位 32 位和 64 位 以下示例显示如何使用 检查所有泳池对象 用于检测 64 位指针大小的无效分配的命令： FUNCTION F : INT\nVAR\n               \nptr : POINTER TO BYTE;\n               \nptrSave : DWORD;\nEND_VAR\nptrSave := ptr; 此任务会导致错误 C0032：无法将 “指向字节的指针” 类型转换为 “DWORD” 类型 。 将以下声明用于 ptrSave 为了避免这个错误： ptrSave : __XWORD; 有关更多信息，请参阅： 检查所有池对象" }, 
{ "title" : "对话框：项目设置：编译选项 ", 
"url" : "_cds_dlg_project_settings_compile_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：编译选项 ", 
"snippet" : "编译选项 象征： 功能 ：该对话框用于配置编译器选项。 称呼 ： 项目 → 项目设置 命令， 编译选项 类别 要求 : 项目已打开。 编译器版本 修复版本 显示编译时和加载编译时使用的编译器版本。 可以更新到最新的编译器版本，但无法重置到旧版本。 设置 允许使用 Unicode 字符作为标识符 默认清除，因为在 IEC 标准中不允许在标识符名称中使用 Unicode 字符 某些外语可能需要（例如，亚洲语言） 替换常量 ：（默认）为每个标量常量直接加载值（而不是 STRING , ARRAY ，或结构）。 ： （默认） CODESYS 直接为每个标量常量加载值（因此不适用于 STRING , A...", 
"body" : "编译选项 象征： 功能 ：该对话框用于配置编译器选项。 称呼 ： 项目 → 项目设置 命令， 编译选项 类别 要求 : 项目已打开。 编译器版本 修复版本 显示编译时和加载编译时使用的编译器版本。 可以更新到最新的编译器版本，但无法重置到旧版本。 设置 允许使用 Unicode 字符作为标识符 默认清除，因为在 IEC 标准中不允许在标识符名称中使用 Unicode 字符 某些外语可能需要（例如，亚洲语言） 替换常量 ：（默认）为每个标量常量直接加载值（而不是 STRING , ARRAY ，或结构）。 ： （默认） CODESYS 直接为每个标量常量加载值（因此不适用于 STRING , ARRAY ，或结构）。在线模式下， CODESYS 用一个符号标记常量，该符号附加在声明编辑器或监视视图中的值之前。在这种情况下，无法访问，例如通过 ADR 运算符、强制和写入。 : 可以访问常量，但会延长计算时间。 启用断点记录 对于定义为执行点的断点，您可以在 执行点设置 对话。 CODESYS 当应用程序在执行点停止时，将此文本打印到设备日志。 字符串的 UTF8 编码 : 字符串与 STRING 数据类型在项目范围内以 ASCII 格式编码。对文字的索引访问正常工作。 : 字符串 STRING 数据类型在项目范围内以 UTF-8 格式编码。这适用于每个 STRING 文字，也用于他们的监控。 不建议对 UTF-8 文字进行索引访问，这主要会导致错误。 如果不需要将项目范围编码为 UTF-8 格式，则可以使用 UTF8# 字首。 UTF-8 编码仅用于项目范围的配置 如果项目范围的编译选项使用 UTF-8 编码 字符串的 UTF8 编码 已启用。然后，库函数和附加组件也将根据此设置进行定向。 如果您使用单个 UTF-8 编码的字符串，那么您必须确保在使用它们的任何地方都能正确解释它们。例如，如果未选择该设置，则 OPC 服务器中的字符串变量将在传输到客户端之前转换为 UTF-8。值如 UTF8#'äöü' 那么就会被误解。在可视化中输出字符串时可能会出现类似的问题。 编辑项目定义 打开 编辑项目定义 对话。 编译器警告 最大警告数 指的是警告 CODESYS 打印到消息视图 您可以在中定义显示的编译器警告的选择 项目设置 对话框中，在 编译器警告 类别。 对话： 编辑项目定义 添加项目定义 向表中添加新行。双击该行打开行编辑器并输入新项目定义的标识符。新项目定义必须是有效的 IEC 标识符。 项目定义在整个项目和所有引用的库中均有效。它们不适用于公共接口。 有关项目定义的更多信息，请参阅： project_defined (<global define>)" }, 
{ "title" : "对话框：项目设置：编译器警告 ", 
"url" : "_cds_dlg_project_settings_compile_warnings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：编译器警告 ", 
"snippet" : "编译器警告 象征： 功能 : 该对话框用于选择编译器警告 CODESYS 在编译操作期间显示在消息视图中。 称呼 ： 项目 → 项目设置 命令， 编译器警告 类别 要求 : 项目已打开。 通过单击复选框，可以按如下方式配置各个消息： ：未显示该消息。 ：该消息显示为警告。 该消息显示为错误。无法下载该应用程序。 您可以在 编译选项 对话。 有关更多信息，请参阅： 编译选项...", 
"body" : "编译器警告 象征： 功能 : 该对话框用于选择编译器警告 CODESYS 在编译操作期间显示在消息视图中。 称呼 ： 项目 → 项目设置 命令， 编译器警告 类别 要求 : 项目已打开。 通过单击复选框，可以按如下方式配置各个消息： ：未显示该消息。 ：该消息显示为警告。 该消息显示为错误。无法下载该应用程序。 您可以在 编译选项 对话。 有关更多信息，请参阅： 编译选项" }, 
{ "title" : "对话框：项目设置：源下载 ", 
"url" : "_cds_dlg_project_settings_source_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：源下载 ", 
"snippet" : "源码下载 象征： 功能 ：对话框将源代码的传输和存储定义为一个或多个控制器上的源下载存档。 称呼 ： 项目 → 项目设置 命令， 源码下载 类别 源下载存档是一个名为 Archive.prj . 目标设备 定义项目存档的位置 <控制器名称> 选定的控制器 CODESYS 将项目存档下载到此控制器。要求：项目包含多个控制器。 <项目中的所有设备> CODESYS 将项目存档下载到项目中的所有控制器。 内容 定义项目存档的内容 使用压缩下载 ：项目存档仅包含包含活动应用程序的项目设备。 ：项目存档包含项目中的所有设备。 附加文件 打开 附加文件 对话框，您可以在其中选择更多文件进行下载 定时 定义...", 
"body" : "源码下载 象征： 功能 ：对话框将源代码的传输和存储定义为一个或多个控制器上的源下载存档。 称呼 ： 项目 → 项目设置 命令， 源码下载 类别 源下载存档是一个名为 Archive.prj . 目标设备 定义项目存档的位置 <控制器名称> 选定的控制器 CODESYS 将项目存档下载到此控制器。要求：项目包含多个控制器。 <项目中的所有设备> CODESYS 将项目存档下载到项目中的所有控制器。 内容 定义项目存档的内容 使用压缩下载 ：项目存档仅包含包含活动应用程序的项目设备。 ：项目存档包含项目中的所有设备。 附加文件 打开 附加文件 对话框，您可以在其中选择更多文件进行下载 定时 定义时间 CODESYS 创建项目存档 隐含在程序下载和在线更改时 每次下载应用程序或执行在线更改时， CODESYS 还会在没有任何提示的情况下将项目存档下载到目标设备。 隐式创建引导项目 每次创建启动应用程序时， CODESYS 还会在没有任何提示的情况下将项目存档下载到目标设备。 隐式创建启动项目、下载和在线更改 每次创建启动应用程序、下载应用程序或执行在线更改时， CODESYS 还会在没有任何提示的情况下将项目存档下载到目标设备。 程序下载和在线更改提示 每次下载应用程序或执行在线更改时， CODESYS 打开提示。在那里你可以选择是否 CODESYS 应将项目存档下载到控制器。 仅按需提供 只有当 在线 → 将源代码加载到连接的控制器 命令被调用。在那里你可以选择是否 CODESYS 应将项目存档下载到控制器。 有关更多信息，请参阅： 将源代码下载到 PLC 和从 PLC 下载源代码" }, 
{ "title" : "对话框：项目设置 - 监控 ", 
"url" : "_cds_dlg_project_settings_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置 - 监控 ", 
"snippet" : "监控 象征： 功能 ：该对话框包括用于在监控中显示变量值的设置。 称呼 ： 工具 → 选项 命令， 监控 类别 整数变量的模式 二进制 在线模式下，变量的值以相应的格式显示。 此选项对应于 调试 → 显示模式 命令。 十进制 十六进制 显示位数 显示 REAL 值时在线模式下表示的小数位 注意：这些设置适用于监视列表、声明编辑器的监视和跟踪编辑器。编辑器内联监控的配置在文本编辑器选项中设置。 继承层次结构的结构化显示 ：功能块和结构的继承层次以树状结构显示。变量显示为功能块或声明它们的结构的子节点。 ：表示显示为平面列表。 有关更多信息，请参阅： 标签：监控...", 
"body" : "监控 象征： 功能 ：该对话框包括用于在监控中显示变量值的设置。 称呼 ： 工具 → 选项 命令， 监控 类别 整数变量的模式 二进制 在线模式下，变量的值以相应的格式显示。 此选项对应于 调试 → 显示模式 命令。 十进制 十六进制 显示位数 显示 REAL 值时在线模式下表示的小数位 注意：这些设置适用于监视列表、声明编辑器的监视和跟踪编辑器。编辑器内联监控的配置在文本编辑器选项中设置。 继承层次结构的结构化显示 ：功能块和结构的继承层次以树状结构显示。变量显示为功能块或声明它们的结构的子节点。 ：表示显示为平面列表。 有关更多信息，请参阅： 标签：监控 " }, 
{ "title" : "对话框：项目设置：页面设置 ", 
"url" : "_cds_dlg_project_settings_page_setup.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：页面设置 ", 
"snippet" : "页面设置 象征： 功能 ：对话框定义项目内容的打印版本的布局。该布局用于通过 文件 → 打印 命令和项目文档的打印输出通过 项目 → 文档 命令。 称呼 ： 项目 → 项目设置 命令， 页面设置 类别 您可以配置以下属性的设置： 纸 边距 页眉和页脚 文档 封面 编辑标题 \/ 编辑页脚 页眉和页脚以表格样式构造。您可以配置行和列，并将文本和图像添加到结果单元格。 行跨越 列数 CODESYS 应该合并成一行 列跨越 列数 CODESYS 应该合并成一行 打开可用占位符列表 文本 场地 打印页面时， CODESYS 为占位符提供当前值。...", 
"body" : "页面设置 象征： 功能 ：对话框定义项目内容的打印版本的布局。该布局用于通过 文件 → 打印 命令和项目文档的打印输出通过 项目 → 文档 命令。 称呼 ： 项目 → 项目设置 命令， 页面设置 类别 您可以配置以下属性的设置： 纸 边距 页眉和页脚 文档 封面 编辑标题 \/ 编辑页脚 页眉和页脚以表格样式构造。您可以配置行和列，并将文本和图像添加到结果单元格。 行跨越 列数 CODESYS 应该合并成一行 列跨越 列数 CODESYS 应该合并成一行 打开可用占位符列表 文本 场地 打印页面时， CODESYS 为占位符提供当前值。 " }, 
{ "title" : "对话框：项目设置：安全 ", 
"url" : "_cds_dlg_project_settings_security.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：安全 ", 
"snippet" : "安全 象征： 功能 ：该对话框用于通过密码、加密狗或证书配置项目保护。 称呼 ： 项目 → 项目设置 命令， 安全 类别 如果您丢失了加密密码，那么您将无法再打开该项目。您也无法再恢复它。 没有保护 ：项目文件不受未经授权的访问和数据操纵的保护。 注意：我们强烈建议您使用安全功能。 ： 这 密码 , 加密狗 ， 和 证书 无法选择选项。 完整性检查 创建新项目时，默认启用此选项。 ：项目文件以专有格式存储，每次加载项目时都会检查其完整性。该文件可能与旧版本的开发系统不兼容。 请注意，项目文件未加密。为了更好地保护您的数据，请激活其中一项加密功能。 加密 ： 这 密码 , 加密狗 ， 和 证书 ...", 
"body" : "安全 象征： 功能 ：该对话框用于通过密码、加密狗或证书配置项目保护。 称呼 ： 项目 → 项目设置 命令， 安全 类别 如果您丢失了加密密码，那么您将无法再打开该项目。您也无法再恢复它。 没有保护 ：项目文件不受未经授权的访问和数据操纵的保护。 注意：我们强烈建议您使用安全功能。 ： 这 密码 , 加密狗 ， 和 证书 无法选择选项。 完整性检查 创建新项目时，默认启用此选项。 ：项目文件以专有格式存储，每次加载项目时都会检查其完整性。该文件可能与旧版本的开发系统不兼容。 请注意，项目文件未加密。为了更好地保护您的数据，请激活其中一项加密功能。 加密 ： 这 密码 , 加密狗 ， 和 证书 可选择加密功能。 密码 输入、更改和确认加密密码 当您使用这些设置保存项目时，您必须稍后指定密码才能再次打开该项目，即使它要作为库引用加载也是如此。 加密狗 要求：您已连接 CODESYS 计算机的安全密钥（加密狗）。 添加 ： 这 添加注册加密狗 对话框打开。 已注册的加密狗 已注册加密狗列表框 证书 证书用于加密打开的项目文件的内容。 要求：所有共享项目的用户的证书必须安装在本地内存中。 ： 这 证书选择 对话框打开。 添加注册加密狗 加密狗 所有已连接加密狗的列表框 刷新 CODESYS 刷新列表框。 眨 所选加密狗的 LED 闪烁两秒钟（如果它支持此功能）。 加密狗必须连接到计算机时 CODESYS 加载项目，即使它是作为库引用加载的。 有关更多信息，请参阅： 保护和保存项目" }, 
{ "title" : "对话框：项目设置： 静态分析灯 ", 
"url" : "_cds_dlg_project_settings_stat_analysis_light.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置： 静态分析灯 ", 
"snippet" : "静态分析灯 象征： 功能 ：对话框激活使用轻量级版本执行的检查 CODESYS 每次生成代码时进行静态分析。 称呼 ： 项目 → 项目设置 命令， 静态分析灯 类别 您可以通过使用标记代码从静态代码分析中排除代码行 {analysis ...} 语用或 {attribute 'analysis' := '...'} 语用。 有关更多信息，请参阅： 静态分析代码...", 
"body" : "静态分析灯 象征： 功能 ：对话框激活使用轻量级版本执行的检查 CODESYS 每次生成代码时进行静态分析。 称呼 ： 项目 → 项目设置 命令， 静态分析灯 类别 您可以通过使用标记代码从静态代码分析中排除代码行 {analysis ...} 语用或 {attribute 'analysis' := '...'} 语用。 有关更多信息，请参阅： 静态分析代码" }, 
{ "title" : "额外的编译检查 ", 
"url" : "_cds_dlg_project_settings_stat_analysis_light.html#UUID-bce0b3be-97a6-5ed6-5660-1fba15122580_id_e31a3b0a7345218c0a8640e011b5c22_id_2475103c69e2cf17c0a864637d7f918d", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置： 静态分析灯 \/ 额外的编译检查 ", 
"snippet" : "SA0033：未使用的变量 检测已声明但未在编译程序代码中使用的变量 对于 GVL 变量：如果一个项目中存在多个应用程序，则仅影响当前活动应用程序下方的对象。如果只有一个应用程序，则 POUs 视野也受到影响。 SA0028：重叠的内存区域 检测两个或多个变量保留相同内存的代码行 例如，以下声明会发生这种情况： var1 AT %QB21: INT 和 var2 AT %QD5: DWORD .在这种情况下，两个变量都使用字节 21，这意味着变量的内存范围重叠。 SA0006：来自多个任务的写访问 检测由多个任务写入的变量 SA0004：输出上的多写访问 检测写入多个位置的输出 注意：当输出变...", 
"body" : "SA0033：未使用的变量 检测已声明但未在编译程序代码中使用的变量 对于 GVL 变量：如果一个项目中存在多个应用程序，则仅影响当前活动应用程序下方的对象。如果只有一个应用程序，则 POUs 视野也受到影响。 SA0028：重叠的内存区域 检测两个或多个变量保留相同内存的代码行 例如，以下声明会发生这种情况： var1 AT %QB21: INT 和 var2 AT %QD5: DWORD .在这种情况下，两个变量都使用字节 21，这意味着变量的内存范围重叠。 SA0006：来自多个任务的写访问 检测由多个任务写入的变量 SA0004：输出上的多写访问 检测写入多个位置的输出 注意：当输出变量 ( VAR_IN_OUT ) 被写入不同的分支 IF 和 CASE 陈述。 注意：编译指示不能禁用此规则。 SA0027：标识符的多种用途 检测项目范围内变量或对象 (POU) 的名称\/标识符的多次使用 检测到以下情况： 枚举常量的名称与应用程序中的另一个枚举或包含库中使用的名称相同。 变量的名称与应用程序中的对象名称或集成库的名称相同。 变量的名称与应用程序中枚举中的枚举常量名称或集成库的名称相同。 一个对象的名称与应用程序中另一个对象的名称相同。 变量的名称与方法的名称相同。 对象的名称与上级对象（“父对象”）的名称相同。 SA0167：报告临时 FunctionBlock 实例 检查检测声明为临时变量的功能块实例。这会影响在方法或函数中声明的实例，或者 VAR_TEMP ，因此在每个处理周期或每个 POU 调用中重新初始化。 SA0175：对字符串的可疑操作 默认不活动 检测 UTF-8 编码可疑的代码位置 包括以下结构： 对单字节字符串的索引访问 例子： str[2] 信息： 对字符串的可疑操作：索引访问“<表达式>” 对单字节字符串的地址访问 例子： ADR(str) 信息 : 对字符串的可疑操作：可能的索引访问“<表达式>” 调用标准库的字符串函数 除了 CONCAT 和 LEN 信息： 对字符串的可疑操作：可能的索引访问“<表达式>” 包含非 ASCII 字符的单字节文字 例子： str := '99€'; str := 'Ä'; 信息： 对字符串的可疑操作：文字“<literal>”包含非 ASCII 字符 根据检查结果，建议不要启用 字符串的 UTF8 编码 编译选项。 有关更多信息，请参阅： 编译选项例子 SA0003：空语句 ;\n(* Comment *);\niVar; SA0006：并发访问 FUNCTION_BLOCK ADD_FB\ng_iTemp1 := g_iTemp1 + INT#1; PROGRAM PLC_PRG \/\/controlled by MainTask\ng_iTemp1 := g_iTemp1 + INT#2;\ng_xTemp2 := g_iTemp1 > INT#10; PROGRAM PLC_PRG_1 \/\/controlled by SubTask\ng_iTemp1 := g_iTemp1 - INT#3;\ng_xTemp2 := g_iTemp1 < INT#-10; SA0004：输出上的多写访问 VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW0 : INT ;\nEND_VAR PROGRAM PLC_PRG\nIF iCondition < INT#0 THEN\n g_xVar := TRUE;\n g_iTest := INT#12;\nEND_IF CASE iCondition OF\n INT#1:\n g_xVar := FALSE;\n INT#2:\n g_iTest := INT#11;\n ELSE\n g_xVar := TRUE;\n g_iTest := INT#9;\nEND_CASE SA0006：来自多个任务的写访问 FUNCTION_BLOCK ADD_FB\ng_iTemp1 := g_iTemp1 + INT#1;\n PROGRAM PLC_PRG \/\/ Controlled by MainTask\ng_iTemp1 := g_iTemp1 + INT#2;\ng_xTemp2 := g_iTemp1 > INT#10; PROGRAM PLC_PRG_1 \/\/Controlled by SubTask\ng_iTemp1 := g_iTemp1 - INT#3;\ng_xTemp2 := g_iTemp1 < INT#-10; SA0027：名称的多次使用 PROGRAM PLC_PRG\nVAR\n ton : INT; \/\/ error SA0027\nEND_VAR SA0029：代码中的符号与声明不同 一个 PLC_PRG POU 和一个 fnc (函数) POU 存在于设备树中。 PROGRAM PLC_PRG\nVAR\n iVar:INT;\n _123test_var_: INT;\nEND_VAR\n ivar := iVar + 1; \/\/ notation different to that in the declaration part -> SA0029\n_123TEST_var_ := _123test_var_INT; \/\/ notation different to that in the declaration part -> SA0029\nFnc(); \/\/ notation different to that in the devices tree -> SA0029 SA0167：报告临时 FunctionBlock 实例 PROGRAM PLC_PRG\nVAR\nEND_VAR\nVAR_TEMP\n yafb: AFB;\nEND_VAR\n\n FUNCTION Fun : INT\nVAR_INPUT\nEND_VAR\nVAR\n funafb: AFB;\nEND_VAR METHOD METH: INT\nVAR_INPUT\nEND_VAR\nVAR\n methafb: AFB;\nEND_VAR 有关更多信息，请参阅： 静态分析代码" }, 
{ "title" : "对话框：项目设置：可视化 ", 
"url" : "_cds_dlg_project_settings_visualization.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：可视化 ", 
"snippet" : "可视化 象征： 功能 ：该对话框用于配置 可视化 整个项目中的对象。 称呼 ： 项目 → 项目设置 命令， 可视化 类别 要求 : 项目已打开。...", 
"body" : "可视化 象征： 功能 ：该对话框用于配置 可视化 整个项目中的对象。 称呼 ： 项目 → 项目设置 命令， 可视化 类别 要求 : 项目已打开。 " }, 
{ "title" : "标签：常规 ", 
"url" : "_cds_dlg_project_settings_visualization.html#UUID-a7420fda-c00e-6880-4017-0aae347dbd65_id_ec5a4b10864b2e0c0a8640e008c94e5_id_97bc6eea60007fddc0a8640e010193e0", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：可视化 \/ 标签：常规 ", 
"snippet" : "可视化目录 文本列表文件 包含项目中可用于配置不同语言文本的文本列表的目录 CODESYS 使用目录，例如导入或导出文本列表。 点击后 纽扣 选择目录 对话框打开让您选择文件系统中的目录。 图像文件 包含项目中可用的图像文件的目录 多个文件夹用分号隔开。 CODESYS 使用该目录，例如导入或导出图像文件。 点击后 纽扣 选择目录 对话框打开让您选择文件系统中的目录。 先进的 在所有元素属性中激活属性处理 ：您还可以使用 选择 IEC 变量的那些属性中的属性。然后 CODESYS 编译可视化时为属性处理创建附加代码。 要求：您的 IEC 代码至少包含一个 接口属性 对象类型（一个 。财产）。 ...", 
"body" : "可视化目录 文本列表文件 包含项目中可用于配置不同语言文本的文本列表的目录 CODESYS 使用目录，例如导入或导出文本列表。 点击后 纽扣 选择目录 对话框打开让您选择文件系统中的目录。 图像文件 包含项目中可用的图像文件的目录 多个文件夹用分号隔开。 CODESYS 使用该目录，例如导入或导出图像文件。 点击后 纽扣 选择目录 对话框打开让您选择文件系统中的目录。 先进的 在所有元素属性中激活属性处理 ：您还可以使用 选择 IEC 变量的那些属性中的属性。然后 CODESYS 编译可视化时为属性处理创建附加代码。 要求：您的 IEC 代码至少包含一个 接口属性 对象类型（一个 。财产）。 要求： 可见的 选项被选中。 激活可视化 POU 的隐式检查 ：对可视化 POU 也执行隐式检查。因此，会生成额外的代码，这会增加内存使用量。当内存有限时，应禁用此选项。 " }, 
{ "title" : "选项卡：符号库 ", 
"url" : "_cds_dlg_project_settings_visualization.html#UUID-a7420fda-c00e-6880-4017-0aae347dbd65_id_ec5a4b10864b2e0c0a8640e008c94e5_id_a34bf5cec3c311e388b6f6b960add9a6", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：可视化 \/ 选项卡：符号库 ", 
"snippet" : "可视化符号库 符号库 所有已安装符号库的列表（例如： VisuSymbols ) 积极的 ：在项目中选择符号库， CODESYS 使其在 可视化工具箱 可视化视图。 ：符号库安装在库存储库中，但是 CODESYS 做 不是 使其在 可视化工具箱 可视化视图。 有关更多信息，请参阅： CODESYS Visualization 帮助...", 
"body" : "可视化符号库 符号库 所有已安装符号库的列表（例如： VisuSymbols ) 积极的 ：在项目中选择符号库， CODESYS 使其在 可视化工具箱 可视化视图。 ：符号库安装在库存储库中，但是 CODESYS 做 不是 使其在 可视化工具箱 可视化视图。 有关更多信息，请参阅： CODESYS Visualization 帮助 " }, 
{ "title" : "对话框：项目设置：可视化配置文件 ", 
"url" : "_cds_dlg_project_settings_visualzation_profile.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目设置 \/ 对话框：项目设置：可视化配置文件 ", 
"snippet" : "可视化配置文件 象征： 功能 ：对话框允许设置可视化配置文件。 称呼 ： 项目 → 项目设置 命令， 可视化配置文件 类别 要求 : 项目已打开。 可视化配置文件 具体配置文件 简介 CODESYS 在项目中使用并确定项目中可用的可视化元素 该列表框包含所有以前安装的配置文件。...", 
"body" : "可视化配置文件 象征： 功能 ：对话框允许设置可视化配置文件。 称呼 ： 项目 → 项目设置 命令， 可视化配置文件 类别 要求 : 项目已打开。 可视化配置文件 具体配置文件 简介 CODESYS 在项目中使用并确定项目中可用的可视化元素 该列表框包含所有以前安装的配置文件。 " }, 
{ "title" : "对话框：项目环境 ", 
"url" : "_cds_f_dlg_project_environment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目环境 ", 
"snippet" : "项目环境 功能 ：该对话框用于检查项目中集成的软件和文件是否是最新的。例如， CODESYS 检查选定的编译器并确定是否有更新的版本可用。如果是这样，那么您可以更新相关组件。 称呼 ： 项目 菜单...", 
"body" : "项目环境 功能 ：该对话框用于检查项目中集成的软件和文件是否是最新的。例如， CODESYS 检查选定的编译器并确定是否有更新的版本可用。如果是这样，那么您可以更新相关组件。 称呼 ： 项目 菜单 " }, 
{ "title" : "对话框：项目环境 ：库版本 ", 
"url" : "_cds_dlg_project_environment_library_version.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目环境 \/ 对话框：项目环境 ：库版本 ", 
"snippet" : "库版本 功能 ：对话框显示打开项目的库，有更新的版本可用。 称呼 ： 项目 → 项目环境 命令， 库版本 标签 当您打开包含过时库的项目时，此对话框会自动打开。 该列表显示过时库的名称及其版本、可用版本和计划的操作。 行动 在字段内双击以选择所需的操作。 加载此项目时检查更新 ：每次打开项目时都会进行检查。 : 检查只发生一次。 全部设置为最新 CODESYS 使用最新版本的库。 行 CODESYS 执行选定的操作。...", 
"body" : "库版本 功能 ：对话框显示打开项目的库，有更新的版本可用。 称呼 ： 项目 → 项目环境 命令， 库版本 标签 当您打开包含过时库的项目时，此对话框会自动打开。 该列表显示过时库的名称及其版本、可用版本和计划的操作。 行动 在字段内双击以选择所需的操作。 加载此项目时检查更新 ：每次打开项目时都会进行检查。 : 检查只发生一次。 全部设置为最新 CODESYS 使用最新版本的库。 行 CODESYS 执行选定的操作。 " }, 
{ "title" : "对话框：项目环境: 编译器版本 ", 
"url" : "_cds_dlg_project_environment_compiler_version.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目环境 \/ 对话框：项目环境: 编译器版本 ", 
"snippet" : "编译器版本 功能 ：对话框显示项目的当前编译器版本并提供更新它的选项。 称呼 ： 项目 → 项目环境 命令， 编译器版本 标签 项目中的当前编译器版本 显示打开项目的设置编译器版本 推荐，最新版本 显示最新版本 行动 不更新 ：项目的编译器版本保持不变。 更新到 xxxx ：为项目设置所选的编译器版本。 加载此项目时检查更新 ： CODESYS 每次打开项目时检查新版本。如果是这样，则相应的更新对话框会自动打开。 : 不检查版本。更新对话框不会自动打开。 全部设置为最新 编译器版本设置为最新版本。...", 
"body" : "编译器版本 功能 ：对话框显示项目的当前编译器版本并提供更新它的选项。 称呼 ： 项目 → 项目环境 命令， 编译器版本 标签 项目中的当前编译器版本 显示打开项目的设置编译器版本 推荐，最新版本 显示最新版本 行动 不更新 ：项目的编译器版本保持不变。 更新到 xxxx ：为项目设置所选的编译器版本。 加载此项目时检查更新 ： CODESYS 每次打开项目时检查新版本。如果是这样，则相应的更新对话框会自动打开。 : 不检查版本。更新对话框不会自动打开。 全部设置为最新 编译器版本设置为最新版本。 " }, 
{ "title" : "对话框：项目环境：设备版本 ", 
"url" : "_cds_dlg_project_environment_device_versions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目环境 \/ 对话框：项目环境：设备版本 ", 
"snippet" : "设备版本 功能 ：对话框显示打开项目的设备，有更新的版本可用。 称呼 ： 项目 → 项目环境 命令， 设备版本 标签 当您打开包含过期设备的项目时，此对话框会自动打开。 过时设备的名称及其版本，以及可用的版本和计划的操作 行动 在字段内双击以选择所需的操作。 加载此项目时检查更新 ：每次打开项目时都会进行检查。 : 检查只发生一次。 全部设置为最新 CODESYS 使用最新版本的库。 行 CODESYS 执行选定的操作。...", 
"body" : "设备版本 功能 ：对话框显示打开项目的设备，有更新的版本可用。 称呼 ： 项目 → 项目环境 命令， 设备版本 标签 当您打开包含过期设备的项目时，此对话框会自动打开。 过时设备的名称及其版本，以及可用的版本和计划的操作 行动 在字段内双击以选择所需的操作。 加载此项目时检查更新 ：每次打开项目时都会进行检查。 : 检查只发生一次。 全部设置为最新 CODESYS 使用最新版本的库。 行 CODESYS 执行选定的操作。 " }, 
{ "title" : "对话框：项目环境：可视化配置文件 ", 
"url" : "_cds_dlg_project_environment_visualization_profile.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目环境 \/ 对话框：项目环境：可视化配置文件 ", 
"snippet" : "可视化配置文件 功能 ：对话框显示项目的当前可视化配置文件。可以在此处更新配置文件。 称呼 ： 项目 → 项目环境 命令， 可视化配置文件 标签 项目中的当前可视化配置文件 打开项目的设置可视化配置文件 推荐的最新配置文件 最新版本 行动 不更新 ：项目的可视化配置文件保持不变。 更新到 xxxx ： CODESYS 将项目更新为选定的可视化配置文件。 加载此项目时检查更新 ： CODESYS 每次打开项目时检查新的配置文件。如果是这样，则相应的更新对话框会自动打开。 : 打开项目时不检查配置文件。更新对话框不会自动打开。 全部设置为最新 CODESYS 更新配置文件。 有关更多信息，请参阅：...", 
"body" : "可视化配置文件 功能 ：对话框显示项目的当前可视化配置文件。可以在此处更新配置文件。 称呼 ： 项目 → 项目环境 命令， 可视化配置文件 标签 项目中的当前可视化配置文件 打开项目的设置可视化配置文件 推荐的最新配置文件 最新版本 行动 不更新 ：项目的可视化配置文件保持不变。 更新到 xxxx ： CODESYS 将项目更新为选定的可视化配置文件。 加载此项目时检查更新 ： CODESYS 每次打开项目时检查新的配置文件。如果是这样，则相应的更新对话框会自动打开。 : 打开项目时不检查配置文件。更新对话框不会自动打开。 全部设置为最新 CODESYS 更新配置文件。 有关更多信息，请参阅： CODESYS Visualization 帮助 " }, 
{ "title" : "对话框：项目环境 ：可视化样式 ", 
"url" : "_cds_dlg_project_environment_visualization_style.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目环境 \/ 对话框：项目环境 ：可视化样式 ", 
"snippet" : "可视化样式 功能 ：对话框显示项目的当前可视化样式并提供更新它的选项。 称呼 ： 项目 → 项目环境 命令， 可视化样式 标签 对于当前使用的以下可视化样式，有较新的版本可用 可视化风格 打开项目中设置可视化样式的版本 当前的 当前版本的可视化样式 例子： 3.5.6.0 受到推崇的 可视化风格推荐版本 例子： 3.5.7.0 行动 不更新 ：项目的可视化风格保持不变。 更新到 xxxx ： CODESYS 将项目更新为所选可视化样式的版本。 加载此项目时检查更新 ： CODESYS 每次打开项目时检查新版本。如果是这样，则相应的更新对话框会自动打开。 : 不检查版本。 更新对话框不会自动打开...", 
"body" : "可视化样式 功能 ：对话框显示项目的当前可视化样式并提供更新它的选项。 称呼 ： 项目 → 项目环境 命令， 可视化样式 标签 对于当前使用的以下可视化样式，有较新的版本可用 可视化风格 打开项目中设置可视化样式的版本 当前的 当前版本的可视化样式 例子： 3.5.6.0 受到推崇的 可视化风格推荐版本 例子： 3.5.7.0 行动 不更新 ：项目的可视化风格保持不变。 更新到 xxxx ： CODESYS 将项目更新为所选可视化样式的版本。 加载此项目时检查更新 ： CODESYS 每次打开项目时检查新版本。如果是这样，则相应的更新对话框会自动打开。 : 不检查版本。 更新对话框不会自动打开。 全部设置为最新 CODESYS 更新版本。 有关更多信息，请参阅： 使用可视化样式 " }, 
{ "title" : "对话框：项目环境：可视化符号 ", 
"url" : "_cds_dlg_project_environment_visualization_symbols.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：项目环境 \/ 对话框：项目环境：可视化符号 ", 
"snippet" : "可视化符号 功能 ：该对话框列出了已安装的符号库，并允许您将符号库分配给项目。 称呼 ： 项目 → 项目环境 命令， 可视化符号 标签 要求 ：打开的项目包含一个可视化，并已与编译器版本一起保存 < 3.5.7.0 . CODESYS 识别编译器版本中的符号库 3.5.7.0 和更高。 符号库 所有已安装符号库的列表 积极的 ：为项目选择符号库。 CODESYS 提供了它的符号 可视化工具箱 看法。 ：符号库以前只安装在库存储库中。 有关更多信息，请参阅： CODESYS Visualization ，“在可视化中使用符号库”一章...", 
"body" : "可视化符号 功能 ：该对话框列出了已安装的符号库，并允许您将符号库分配给项目。 称呼 ： 项目 → 项目环境 命令， 可视化符号 标签 要求 ：打开的项目包含一个可视化，并已与编译器版本一起保存 < 3.5.7.0 . CODESYS 识别编译器版本中的符号库 3.5.7.0 和更高。 符号库 所有已安装符号库的列表 积极的 ：为项目选择符号库。 CODESYS 提供了它的符号 可视化工具箱 看法。 ：符号库以前只安装在库存储库中。 有关更多信息，请参阅： CODESYS Visualization ，“在可视化中使用符号库”一章 " }, 
{ "title" : "对话框：选项 ", 
"url" : "_cds_f_dlg_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 ", 
"snippet" : "选项 功能 ：该对话框用于您选择 CODESYS 配置用户界面的行为和外观的选项。 CODESYS 将当前设置存储为本地系统上的默认设置。 称呼 ： 工具 → 选项 命令...", 
"body" : "选项 功能 ：该对话框用于您选择 CODESYS 配置用户界面的行为和外观的选项。 CODESYS 将当前设置存储为本地系统上的默认设置。 称呼 ： 工具 → 选项 命令 " }, 
{ "title" : "对话框：选项：库 ", 
"url" : "_cds_dlg_options_lib.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：库 ", 
"snippet" : "图书馆 象征： 功能 ：该对话框可帮助您管理库参考的映射，这些参考 CODESYS 在旧项目转换期间使用。如果您尚未为特定库存储任何映射，则每次打开集成此库的旧项目时都必须重新定义映射。 称呼 ： 工具 → 选项 命令， 图书馆 类别 映射定义了将项目转换为当前格式后库引用的外观。有三种可能： 您保留参考。这意味着 CODESYS 还将库转换为当前格式 (*.library) 并将其安装在本地库存储库中。 您将一个引用替换为另一个引用。这意味着已安装的库之一替换了集成库。 您删除引用。这意味着转换后的项目不再集成该库。 CODESYS 下次转换旧项目时，会将所有列出的映射应用于旧项目的库引用。...", 
"body" : "图书馆 象征： 功能 ：该对话框可帮助您管理库参考的映射，这些参考 CODESYS 在旧项目转换期间使用。如果您尚未为特定库存储任何映射，则每次打开集成此库的旧项目时都必须重新定义映射。 称呼 ： 工具 → 选项 命令， 图书馆 类别 映射定义了将项目转换为当前格式后库引用的外观。有三种可能： 您保留参考。这意味着 CODESYS 还将库转换为当前格式 (*.library) 并将其安装在本地库存储库中。 您将一个引用替换为另一个引用。这意味着已安装的库之一替换了集成库。 您删除引用。这意味着转换后的项目不再集成该库。 CODESYS 下次转换旧项目时，会将所有列出的映射应用于旧项目的库引用。因此，如果在要转换的项目中再次集成相同的库，则必须重复映射定义。 您可以在最后一行输入新的映射。 源库 转换前集成在项目中的库的路径 双击条目使该字段可编辑，并显示输入帮助按钮。 目标库 转换后要集成到项目中的库的名称和位置 双击条目打开 设置目标库 对话。 对话： 设置目标库 扫描 这 添加库 对话框打开。在那里，您可以从库存储库中选择一个库。该对话框对应于库存储库中的对话框。 忽略。不会导入此库引用。 什么时候 CODESYS 转换项目， CODESYS 总是从项目中删除现有的源库。 " }, 
{ "title" : "对话框：选项：库下载 ", 
"url" : "_cds_dlg_options_lib_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：库下载 ", 
"snippet" : "图书馆下载 象征： 功能 ：该对话框用于配置下载服务器。 称呼 ： 工具 → 选项 命令， 图书馆下载 类别 当你点击 下载缺失的库 在图书馆管理器中， CODESYS 浏览这些下载服务器以查找在库管理器中标记为缺失的库，并使用为代理服务器设置的凭据。 下载服务器 包含库文件的服务器的 URL 双击 （此处输入新的下载服务器） 将打开一个输入字段，您可以在其中指定服务器的 URL 地址。 有关更多信息，请参阅： 图书馆经理 和 代理设置...", 
"body" : "图书馆下载 象征： 功能 ：该对话框用于配置下载服务器。 称呼 ： 工具 → 选项 命令， 图书馆下载 类别 当你点击 下载缺失的库 在图书馆管理器中， CODESYS 浏览这些下载服务器以查找在库管理器中标记为缺失的库，并使用为代理服务器设置的凭据。 下载服务器 包含库文件的服务器的 URL 双击 （此处输入新的下载服务器） 将打开一个输入字段，您可以在其中指定服务器的 URL 地址。 有关更多信息，请参阅： 图书馆经理 和 代理设置" }, 
{ "title" : "对话框：选项 ： CoDeSys V2.3 转换器 ", 
"url" : "_cds_dlg_options_v23_convert.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项 ： CoDeSys V2.3 转换器 ", 
"snippet" : "CoDeSys V2.3 转换器 象征： 功能 ：对话框用于定义映射时转换一个 CoDeSys V2.3 项目。 称呼 ： 工具 → 选项 命令， CoDeSys V2.3 转换器 类别 一个 CoDeSys V2.3 项目可以转换为 CODESYS V3 项目仅当 CODESYS V2.3 Converter 包安装在 CODESYS V3 .该软件包可在 CODESYS Store International . 标签： 设备 转换的设备映射列表和定义 此列表的所有设备映射也将在下一次 CoDeSys V2.3 项目被转换。这消除了在多个项目中使用同一设备时再次创建图像定义的需要。 源设备...", 
"body" : "CoDeSys V2.3 转换器 象征： 功能 ：对话框用于定义映射时转换一个 CoDeSys V2.3 项目。 称呼 ： 工具 → 选项 命令， CoDeSys V2.3 转换器 类别 一个 CoDeSys V2.3 项目可以转换为 CODESYS V3 项目仅当 CODESYS V2.3 Converter 包安装在 CODESYS V3 .该软件包可在 CODESYS Store International . 标签： 设备 转换的设备映射列表和定义 此列表的所有设备映射也将在下一次 CoDeSys V2.3 项目被转换。这消除了在多个项目中使用同一设备时再次创建图像定义的需要。 源设备 双击条目或空白字段以打开 选择源设备 对话。 CODESYS 列出转换器可以处理的所有设备。 目标设备 双击条目或空白字段以打开 选择目标设备 对话。 从下面的已安装设备列表中选择一个目标设备 .点击 行 确认选择。 没有任何 ：源设备在新项目中将不可用。这也意味着不会导入特定于应用程序的对象，例如任务配置。 标签： 可视化 定义处理 CODESYS TargetVisu 和 CODESYS WebVisu 显示变体时 CoDeSys V2.3 项目已打开 目标可视化的导入 网络可视化的导入 列表框 尝试模仿旧行为 ：如果当前使用的设备支持该选项，则该选项可用。该选项的效果是目标可视化或 Web 可视化的新设置与旧项目中的设置尽可能接近。 询问用户一次 ： CODESYS 仅在首次导入“旧”可视化项目时才要求用户定义设置。在那之后， CODESYS 自动为所有其他可视化导入应用设置。 询问用户 ： CODESYS 每次打开“旧”可视化项目时，都会要求用户定义设置。 从设备描述设置 ： CODESYS 根据已安装目标设备的设备描述中的条目配置设置。 尝试模仿旧行为 ：仅当当前使用的设备支持该选项时，该选项才可用。此选项的效果是目标可视化或 Web 可视化的新显示变体设置与旧项目中的设置尽可能接近。 CODESYS TargetVisu 不支持访问 VAR_IN_OUT 变量，因为编译器不支持它。此行为对应于 CoDeSys V2.3 目标可视化。 有关更多信息，请参阅： 打开一个 " }, 
{ "title" : "对话框：选项：调试 ", 
"url" : "_cds_dlg_options_debugging.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：调试 ", 
"snippet" : "调试 象征： 功能 ：此对话框中的选项控制重置后断点是否仍然启用。 称呼 ： 工具 → 选项 命令， 调试 类别 重置后恢复断点 ： 之后 冷复位 或者 重置温暖 命令，所有设置的断点仍然启用。 ： 之后 冷复位 或者 重置温暖 命令后，所有断点均被禁用。...", 
"body" : "调试 象征： 功能 ：此对话框中的选项控制重置后断点是否仍然启用。 称呼 ： 工具 → 选项 命令， 调试 类别 重置后恢复断点 ： 之后 冷复位 或者 重置温暖 命令，所有设置的断点仍然启用。 ： 之后 冷复位 或者 重置温暖 命令后，所有断点均被禁用。 " }, 
{ "title" : "对话框：选项：声明编辑器 ", 
"url" : "_cds_dlg_options_declaration_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：声明编辑器 ", 
"snippet" : "声明编辑器 象征： 功能 ：该对话框用于配置声明编辑器的显示设置。 称呼 ： 工具 → 选项 命令， 声明编辑器 类别 纯文字 声明编辑器的文本视图 仅表格 声明编辑器的表格视图 可在文本和表格之间切换 声明编辑器提供了两个用于在文本视图和表格视图之间切换的按钮。 : 文本视图 : 表格视图 以下选项定义了打开编程对象时出现的默认视图： 总是文字 总是表格 记住最近的设置（每个对象） 记住最近的设置（全局）...", 
"body" : "声明编辑器 象征： 功能 ：该对话框用于配置声明编辑器的显示设置。 称呼 ： 工具 → 选项 命令， 声明编辑器 类别 纯文字 声明编辑器的文本视图 仅表格 声明编辑器的表格视图 可在文本和表格之间切换 声明编辑器提供了两个用于在文本视图和表格视图之间切换的按钮。 : 文本视图 : 表格视图 以下选项定义了打开编程对象时出现的默认视图： 总是文字 总是表格 记住最近的设置（每个对象） 记住最近的设置（全局） " }, 
{ "title" : "对话框：选项：设备描述下载 ", 
"url" : "_cds_dlg_options_dev_descr_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：设备描述下载 ", 
"snippet" : "设备说明下载 象征： 功能 ：该对话框用于配置设备描述的下载服务器地址。 称呼 ： 工具 → 选项 命令， 设备说明下载 类别 下载服务器 包含设备描述的下载服务器列表 默认情况下， 'https:\/\/store.codesys.com\/CODESYSDevs' 输入为下载服务器。 当您单击 下载缺少的设备描述 中的按钮 设备存储库 对话， CODESYS 使用此处指定的服务器和代理服务器的配置凭据。 双击 （此处输入新的下载服务器） 将打开一个输入字段，您可以在其中指定服务器的 URL 地址。 德尔 删除选定的下载服务器 有关更多信息，请参阅： 管理设备 和 代理设置...", 
"body" : "设备说明下载 象征： 功能 ：该对话框用于配置设备描述的下载服务器地址。 称呼 ： 工具 → 选项 命令， 设备说明下载 类别 下载服务器 包含设备描述的下载服务器列表 默认情况下， 'https:\/\/store.codesys.com\/CODESYSDevs' 输入为下载服务器。 当您单击 下载缺少的设备描述 中的按钮 设备存储库 对话， CODESYS 使用此处指定的服务器和代理服务器的配置凭据。 双击 （此处输入新的下载服务器） 将打开一个输入字段，您可以在其中指定服务器的 URL 地址。 德尔 删除选定的下载服务器 有关更多信息，请参阅： 管理设备 和 代理设置" }, 
{ "title" : "对话框：选项：设备编辑器 ", 
"url" : "_cds_dlg_options_device_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：设备编辑器 ", 
"snippet" : "设备编辑器 象征： 功能 ：对话框包括显示设备编辑器的设置。 称呼 ： 工具 → 选项 命令， 设备编辑器 类别...", 
"body" : "设备编辑器 象征： 功能 ：对话框包括显示设备编辑器的设置。 称呼 ： 工具 → 选项 命令， 设备编辑器 类别 " }, 
{ "title" : "标签：查看 ", 
"url" : "_cds_dlg_options_device_editor.html#UUID-e361ad24-5293-3d45-6457-8b1691928017_id_a7d16484a2e9f34c0a8640e0124d84a_id_303e1b31bf1d11e3b5929fc0353aead8", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：设备编辑器 \/ 标签：查看 ", 
"snippet" : "显示通用设备配置视图 ：带有设备参数列表的选项卡在可参数化设备的设备编辑器中可用。 为 IEC 地址创建交叉引用（需要清理） ：为未映射的 I\/O 创建交叉引用。 通讯页面 经典模式 ： 这 沟通 设备编辑器的选项卡显示为拆分窗口，左侧以树状结构显示当前配置的网关通道，右侧显示相关数据和信息。 简单模式 ： 这 沟通 选项卡将按照帮助中相应章节的说明显示。 通过自定义扩展也可以使用其他模式。 在 PLC 的编辑器上显示用于应用程序下载的隐式文件 ： 这 同步文件 选项卡在设备编辑器中可用。在下载应用程序时将同步文件下载到 PLC。这些可以是已添加到应用程序的外部文件，也可以是诸如源代码存档之类...", 
"body" : "显示通用设备配置视图 ：带有设备参数列表的选项卡在可参数化设备的设备编辑器中可用。 为 IEC 地址创建交叉引用（需要清理） ：为未映射的 I\/O 创建交叉引用。 通讯页面 经典模式 ： 这 沟通 设备编辑器的选项卡显示为拆分窗口，左侧以树状结构显示当前配置的网关通道，右侧显示相关数据和信息。 简单模式 ： 这 沟通 选项卡将按照帮助中相应章节的说明显示。 通过自定义扩展也可以使用其他模式。 在 PLC 的编辑器上显示用于应用程序下载的隐式文件 ： 这 同步文件 选项卡在设备编辑器中可用。在下载应用程序时将同步文件下载到 PLC。这些可以是已添加到应用程序的外部文件，也可以是诸如源代码存档之类的隐式文件。 显示访问权限页面 ： 这 访问权限 选项卡在设备编辑器中可用。 注意：根据设备的不同，设备描述可能会覆盖此设置。 " }, 
{ "title" : "对话框：选项：帮助 ", 
"url" : "_cds_dlg_options_help.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：帮助 ", 
"snippet" : "帮助 象征： 功能 ：对话框定义是否 CODESYS 在线帮助或 CODESYS 调用帮助时会打开脱机帮助。 称呼 ： 工具 → 选项 命令， 帮助 类别 使用离线帮助而不是在线帮助 : 那个 CODESYS 离线帮助在以下情况下打开 CODESYS 有人拨打求救电话。 : 那个 CODESYS 在线帮助在以下情况下打开 CODESYS 有人打电话求助。...", 
"body" : "帮助 象征： 功能 ：对话框定义是否 CODESYS 在线帮助或 CODESYS 调用帮助时会打开脱机帮助。 称呼 ： 工具 → 选项 命令， 帮助 类别 使用离线帮助而不是在线帮助 : 那个 CODESYS 离线帮助在以下情况下打开 CODESYS 有人拨打求救电话。 : 那个 CODESYS 在线帮助在以下情况下打开 CODESYS 有人打电话求助。 " }, 
{ "title" : "对话框：选项：智能编码 ", 
"url" : "_cds_dlg_options_smart_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：智能编码 ", 
"snippet" : "智能编码 象征： 功能 ：该对话框用于配置使编码更容易的设置。 称呼 ： 工具 → 选项 命令， 智能编码 类别 自动声明未知变量（AutoDeclare） ： 这 声明变量 当您在实现语言编辑器中键入未声明的标识符然后单击离开输入行时，将打开对话框。 为了在 ST 编辑器中也可以使用 AutoDeclare 功能， 为 ST 编辑器启用 选项也必须被选中。 为 ST 编辑器启用 要求： 自动声明未知变量（AutoDeclare） 选项被选中。 : 在 ST 编辑器中也可以使用 AutoDeclare 功能。 ：自动声明功能在 ST 编辑器中不可用。 在输入助手中显示所有实例变量 ： 这 列出...", 
"body" : "智能编码 象征： 功能 ：该对话框用于配置使编码更容易的设置。 称呼 ： 工具 → 选项 命令， 智能编码 类别 自动声明未知变量（AutoDeclare） ： 这 声明变量 当您在实现语言编辑器中键入未声明的标识符然后单击离开输入行时，将打开对话框。 为了在 ST 编辑器中也可以使用 AutoDeclare 功能， 为 ST 编辑器启用 选项也必须被选中。 为 ST 编辑器启用 要求： 自动声明未知变量（AutoDeclare） 选项被选中。 : 在 ST 编辑器中也可以使用 AutoDeclare 功能。 ：自动声明功能在 ST 编辑器中不可用。 在输入助手中显示所有实例变量 ： 这 列出组件 function 还允许您选择功能块实例的局部变量。 ： 这 列出组件 function 允许您仅选择功能块实例的输入变量和输出变量。 在输入助手中显示系统库中的符号 系统库会自动插入库管理器并以浅灰色显示。 ：输入助手提供符号，例如全局变量、数据类型和功能块。 ：系统库的符号在输入助手中不可用。 键入点 (.) 后列出组件 ：启用 列出组件 功能 当您键入一个点 ( . ) 在某个位置 CODESYS 需要一个标识符，打开一个列表框，提供可能的代码。 键入时立即列出组件 要求： 键入点 (.) 后列出组件 选项被选中。 ：当您键入代码时，会打开一个列表框，提供可能的标识符和运算符。 使用命名空间插入 ： CODESYS 在标识符之前添加命名空间。 自动将关键字转换为大写（自动套用格式） ： CODESYS 自动以大写显示所有关键字。 在交叉参考视图中自动列出选择 ：交叉引用列表自动显示当前选择或光标所在位置的变量、POU 和 DUT 的引用。 下划线编辑器中的错误 : 不正确或未知的程序代码带有下划线。 此选项用于启用或禁用预编译功能。 应该注意的是，并非所有错误都能在预编译阶段被识别，因为在此阶段不会生成任何代码。 无法识别的错误尤其是在分配数据时发生的错误，例如当数据的可用内存耗尽时。 此外，在预编译阶段，还可能发生与生成代码无关的错误。 已报告但生成代码时无关的错误的一个示例：在任何地方都未使用的功能块中报告的问题。如果没有该函数块类型的实例，则编译器对该功能块不感兴趣，但编辑器中仍会显示下划线错误。 突出显示符号 ：光标所在的所有符号在编辑器中都以颜色突出显示。因此，可以快速检测到编辑器中的交叉引用。 最大并行度 可用于预编译处理的并行线程数列表框 CODESYS 从 CPU 核心数中检测显示的线程数。只有在特殊情况下才应更改此默认数字。 " }, 
{ "title" : "对话框：选项：国际设置 ", 
"url" : "_cds_dlg_options_int_set.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：国际设置 ", 
"snippet" : "国际设置 象征： 功能 ：该对话框用于配置用户界面和帮助中的语言。 称呼 ： 工具 → 选项 命令， 国际设置 类别...", 
"body" : "国际设置 象征： 功能 ：该对话框用于配置用户界面和帮助中的语言。 称呼 ： 工具 → 选项 命令， 国际设置 类别 " }, 
{ "title" : "对话框：选项：加载和保存 ", 
"url" : "_cds_dlg_options_load_save.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：加载和保存 ", 
"snippet" : "加载和保存 象征： 功能 ：对话框包含行为的设置 CODESYS 加载或保存项目时。 称呼 ： 工具 → 选项 命令， 加载和保存 类别 创建备份文件 ：每次保存项目时， CODESYS 保存 <project name>.backup 除了文件 <project name>.project 文件。您可以重命名备份文件并在编程系统中打开它。 每……分钟自动保存一次 ： CODESYS 以指定的时间间隔自动将项目保存在 <project name>.autosave 文件，您可以在编程系统不定期关闭后重新加载该文件。 当项目定期关闭或保存时， CODESYS 删除 .autosave 文件。在程...", 
"body" : "加载和保存 象征： 功能 ：对话框包含行为的设置 CODESYS 加载或保存项目时。 称呼 ： 工具 → 选项 命令， 加载和保存 类别 创建备份文件 ：每次保存项目时， CODESYS 保存 <project name>.backup 除了文件 <project name>.project 文件。您可以重命名备份文件并在编程系统中打开它。 每……分钟自动保存一次 ： CODESYS 以指定的时间间隔自动将项目保存在 <project name>.autosave 文件，您可以在编程系统不定期关闭后重新加载该文件。 当项目定期关闭或保存时， CODESYS 删除 .autosave 文件。在程序不正常终止的情况下， CODESYS 保持 .autosave 文件。当您打开一个与之关联的项目时 .autosave 档案 自动保存备份 对话框打开。在此对话框中，您可以选择是否打开 .autosave 文件或用户上次保存的项目版本。 构建前保存 CODESYS 在每次构建操作之前自动保存项目。 创建项目恢复信息 要求： 无保护 选项或 完整性检查 在项目设置中选择选项 安全 类别。这意味着项目不会受到未经授权的访问和数据操作的保护，并且在加载项目时不会进行完整性检查。 ：如果项目在编辑过程中崩溃，那么下次打开项目时，会打开一个提示，询问您是否要恢复未保存的数据并创建新的项目文件。如果你点击 是的 ，然后打开另一个对话框。在此对话框中，您可以选择是要打开恢复的项目还是打开项目比较。此项目比较显示上次保存的项目和恢复的项目之间的差异。 注意：项目还原会在进行更改时记录硬盘上的所有更改。如果在此操作过程中硬盘发生电源故障或硬盘错误，那么最后的更改可能会丢失。 高级设置 这 高级设置 对话框打开。 启动时 启动画面的列表框 CODESYS ： 显示起始页 : 起始页 CODESYS 被陈列。 加载最后加载的项目 显示“打开项目”对话框 显示“新建项目”对话框 显示空环境 新闻页面 通过以下方式打开的 URL 帮助 → CODESYS 主页 命令 默认情况下， http:\/\/www.codesys.com\/startpage 在这里指定。 对话： 高级设置 项目压缩 等级 要求： 没有保护 选项在项目设置中被选中 安全 类别。这意味着项目不受未经授权的访问和数据操纵的保护，并且在加载项目时没有完整性检查。 保存项目时使用的压缩级别的列表框： 最小压缩 - 最佳速度（推荐） 中等压缩 - 中等速度 大多数压缩 - 最差的速度 加载行为 编辑项目时，库和编译信息会在后台加载。 有关更多信息，请参阅： 保护和保存项目" }, 
{ "title" : "对话框：选项：监控 ", 
"url" : "_cds_dlg_options_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：监控 ", 
"snippet" : "监控 象征： 功能 ：该对话框包括用于在监控中显示变量值的设置。 称呼 ： 工具 → 选项 命令， 监控 类别 整数变量的模式 二进制 在线模式下，变量的值以相应的格式显示。 此选项对应于 调试 → 显示模式 命令。 十进制 十六进制 浮点变量 显示位数 显示 REAL 值时在线模式下表示的小数位 注意：这些设置适用于监视列表、声明编辑器的监视和跟踪编辑器。编辑器内联监控的配置在文本编辑器选项中设置。 有关更多信息，请参阅： 标签：监控...", 
"body" : "监控 象征： 功能 ：该对话框包括用于在监控中显示变量值的设置。 称呼 ： 工具 → 选项 命令， 监控 类别 整数变量的模式 二进制 在线模式下，变量的值以相应的格式显示。 此选项对应于 调试 → 显示模式 命令。 十进制 十六进制 浮点变量 显示位数 显示 REAL 值时在线模式下表示的小数位 注意：这些设置适用于监视列表、声明编辑器的监视和跟踪编辑器。编辑器内联监控的配置在文本编辑器选项中设置。 有关更多信息，请参阅： 标签：监控 " }, 
{ "title" : "对话框：选项 - 在线 ", 
"url" : "_cds_dlg_options_online.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项 - 在线 ", 
"snippet" : "在线的 象征： 功能 ：在此对话框中，可以强制断开与控制器的连接，并且可以设置终止与控制器的连接之前的不活动时间。 称呼 ： 不活动一段时间后强制断开与设备的连接 ：在该对话框中指定的时间（以秒为单位）后终止与控制器的连接。 <数字> 秒 默认值：1800 秒 取值范围：[10, 10800] 这里设置的时间被保存，也就是说关闭重新打开后仍然设置这个值 CODESYS 。 有关更多信息，请参阅： 选项：--ForceDisconnectAfterInactivity...", 
"body" : "在线的 象征： 功能 ：在此对话框中，可以强制断开与控制器的连接，并且可以设置终止与控制器的连接之前的不活动时间。 称呼 ： 不活动一段时间后强制断开与设备的连接 ：在该对话框中指定的时间（以秒为单位）后终止与控制器的连接。 <数字> 秒 默认值：1800 秒 取值范围：[10, 10800] 这里设置的时间被保存，也就是说关闭重新打开后仍然设置这个值 CODESYS 。 有关更多信息，请参阅： 选项：--ForceDisconnectAfterInactivity" }, 
{ "title" : "对话框：选项：PLCopenXML ", 
"url" : "_cds_dlg_options_plcopenxml.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：PLCopenXML ", 
"snippet" : "PLCopenXML 象征： 功能 ：对话框包含行为的设置 CODESYS 在 PLCopenXML 的情况下 出口 或者 进口 . 称呼 ： 工具 → 选项 命令， PLCopenXML 类别 PLCopenXML 导出设置 另外将声明导出为纯文本 默认情况下， CODESYS 根据 PLCopenXML 方案将声明部分拆分为单独的变量，因此会丢失格式和一些注释信息。 ：保留格式和注释。 CODESYS 将导出的声明部分的纯文本写入 PLCopenXML 文件，因此扩展了 PLCopenXML 方案。 导出文件夹结构 ： CODESYS 如果文件夹包含选定对象之一，也会导出这些文件夹。这是一...", 
"body" : "PLCopenXML 象征： 功能 ：对话框包含行为的设置 CODESYS 在 PLCopenXML 的情况下 出口 或者 进口 . 称呼 ： 工具 → 选项 命令， PLCopenXML 类别 PLCopenXML 导出设置 另外将声明导出为纯文本 默认情况下， CODESYS 根据 PLCopenXML 方案将声明部分拆分为单独的变量，因此会丢失格式和一些注释信息。 ：保留格式和注释。 CODESYS 将导出的声明部分的纯文本写入 PLCopenXML 文件，因此扩展了 PLCopenXML 方案。 导出文件夹结构 ： CODESYS 如果文件夹包含选定对象之一，也会导出这些文件夹。这是一个 CODESYS - PLCopenXML 方案的特定扩展。 PLCopenXML 导入设置 导入文件夹结构 ：如果导入文件包含有关对象文件夹结构的信息，则 CODESYS 也导入了这个结构。 ： CODESYS 导入没有结构的对象。 有关更多信息，请参阅： 导出和导入项目" }, 
{ "title" : "对话框：选项：代理设置 ", 
"url" : "_cds_dlg_options_proxy_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：代理设置 ", 
"snippet" : "代理设置 象征： 功能 ：该对话框用于存储当前使用的代理服务器的身份验证数据 CODESYS 访问互联网。 称呼 ： 工具 → 选项 命令， 代理设置 类别 要求 ：通过代理服务器在网络中访问 Internet。 输入代理凭据 双击打开一个对话框，提示输入代理服务器的用户名和密码。 CODESYS 使用凭据建立与库和设备描述的下载服务器的连接，与 CODESYS ，并且对于 查看 → 起始页 命令。 要求：如果您的计算机或网络可以通过代理服务器访问 Internet，则该按钮可用。...", 
"body" : "代理设置 象征： 功能 ：该对话框用于存储当前使用的代理服务器的身份验证数据 CODESYS 访问互联网。 称呼 ： 工具 → 选项 命令， 代理设置 类别 要求 ：通过代理服务器在网络中访问 Internet。 输入代理凭据 双击打开一个对话框，提示输入代理服务器的用户名和密码。 CODESYS 使用凭据建立与库和设备描述的下载服务器的连接，与 CODESYS ，并且对于 查看 → 起始页 命令。 要求：如果您的计算机或网络可以通过代理服务器访问 Internet，则该按钮可用。 " }, 
{ "title" : "对话框：选项：重构 ", 
"url" : "_cds_dlg_options_refactoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：重构 ", 
"snippet" : "重构 象征： 功能 ：该对话框用于定义项目中建议进行自动重构的操作。重构功能可帮助您进行改进。 称呼 ： 工具 → 选项 命令， 重构 类别...", 
"body" : "重构 象征： 功能 ：该对话框用于定义项目中建议进行自动重构的操作。重构功能可帮助您进行改进。 称呼 ： 工具 → 选项 命令， 重构 类别 " }, 
{ "title" : "建议重构以下操作 ", 
"url" : "_cds_dlg_options_refactoring.html#UUID-1bedf43c-55f6-693f-ef62-59657cb1e67e_id_d71dbe1a61c0a8640e00abed65_id_0152096f7d12ab0bc0a864637db0450e", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：重构 \/ 建议重构以下操作 ", 
"snippet" : "自动申报 当您调用 AutoDeclare ( 转移 + F2 ) 来更改声明中变量的名称，选中的 通过重构应用更改 显示选项。然后 重构 对话框打开，您可以在整个项目中更改变量。 添加或删除变量，或更改范围 : 你删除名字 声明变量 对话框并单击 行 关闭对话框。然后 重构 对话框打开以删除整个项目中的变量。 关于重命名变量 ：您在 声明变量 对话框并单击 行 关闭对话框。然后 重构 对话框打开以重命名整个项目中的变量。 请参阅：“重构”一章，“更改变量声明并自动应用重构” 单位转换编辑器 关于重命名单位转换 ：在单位转换编辑器中更改转换名称时，系统会提示您是否 CODESYS 重命名时应执...", 
"body" : "自动申报 当您调用 AutoDeclare ( 转移 + F2 ) 来更改声明中变量的名称，选中的 通过重构应用更改 显示选项。然后 重构 对话框打开，您可以在整个项目中更改变量。 添加或删除变量，或更改范围 : 你删除名字 声明变量 对话框并单击 行 关闭对话框。然后 重构 对话框打开以删除整个项目中的变量。 关于重命名变量 ：您在 声明变量 对话框并单击 行 关闭对话框。然后 重构 对话框打开以重命名整个项目中的变量。 请参阅：“重构”一章，“更改变量声明并自动应用重构” 单位转换编辑器 关于重命名单位转换 ：在单位转换编辑器中更改转换名称时，系统会提示您是否 CODESYS 重命名时应执行“自动重构”。 映射编辑器 关于重命名变量 ：在设备编辑器中更改变量名称时（ I\/O 映射 选项卡），系统会提示您是否 CODESYS 重命名时应执行“自动重构”。 航海家 关于重命名对象 ：当您在设备树或 POU 视图中更改对象的名称时，系统会提示您是否 CODESYS 重命名时应执行“自动重构”。 表格声明编辑器 关于重命名变量 ：在表格声明编辑器中更改变量名称时，系统会提示您是否 CODESYS 重命名时应执行“自动重构”。 UML 类图 支持重构的选项（意味着整个项目中的 IEC 代码适应）在类图编辑器中所做的更改 关于添加或删除变量 ：当您在 VAR_INPUT , VAR_OUTPUT ， 和 VAR_INOUT 类图中的部分。 重命名 POU : 在类图中重命名 POU 时支持重构。 关于重命名变量或属性 ：在类图中重命名变量或属性时支持重构。 注意：如果 跳过重构预览 在 UML 选项中选择选项，然后在项目中的所有相关位置执行重构，而无需事先显示在 重构 对话框，视情况而定。有关详细信息，请参阅：“对话框'选项' - 'UML'”帮助 CODESYS UML 有关更多信息，请参阅： 重构" }, 
{ "title" : "对话框：选项：序列编辑器 ", 
"url" : "_cds_dlg_options_seq_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：序列编辑器 ", 
"snippet" : "序列编辑器 象征： 功能 ：对话框包含 序列编辑器 . 称呼 ： 工具 → 选项 命令， 序列编辑器 类别 一般的 元素的选择 CODESYS 显示在序列编辑器的序列步骤中 外貌 定义序列步骤的外观和序列步骤之间的连接线，以及用于 文本 , 参数 , 参考 ， 和 输入\/输出通道 一个连接 分支步骤后连接线颜色的选择 B 连接 分支步骤后连接线颜色的选择（替代分支）...", 
"body" : "序列编辑器 象征： 功能 ：对话框包含 序列编辑器 . 称呼 ： 工具 → 选项 命令， 序列编辑器 类别 一般的 元素的选择 CODESYS 显示在序列编辑器的序列步骤中 外貌 定义序列步骤的外观和序列步骤之间的连接线，以及用于 文本 , 参数 , 参考 ， 和 输入\/输出通道 一个连接 分支步骤后连接线颜色的选择 B 连接 分支步骤后连接线颜色的选择（替代分支） " }, 
{ "title" : "对话框：选项：文本编辑器 ", 
"url" : "_cds_dlg_options_text_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：文本编辑器 ", 
"snippet" : "文本编辑器 象征： 功能 ：对话框包含用于显示文本编辑器并在其中工作的设置。 称呼 ： 工具 → 选项 命令， 文本编辑器 类别...", 
"body" : "文本编辑器 象征： 功能 ：对话框包含用于显示文本编辑器并在其中工作的设置。 称呼 ： 工具 → 选项 命令， 文本编辑器 类别 " }, 
{ "title" : "标签：主题 ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_b87761b04ff2cdecc0a8640e00bac4c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：文本编辑器 \/ 标签：主题 ", 
"snippet" : "在此选项卡上，您可以在 ST 编辑器的界面设计中设置所需的“主题”。 主题 文本编辑器的颜色主题 所选主题显示在 预览 窗户。可用的配色方案存储在安装目录中 Themes 文件夹。...", 
"body" : "在此选项卡上，您可以在 ST 编辑器的界面设计中设置所需的“主题”。 主题 文本编辑器的颜色主题 所选主题显示在 预览 窗户。可用的配色方案存储在安装目录中 Themes 文件夹。 " }, 
{ "title" : "标签：编辑 ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_eafa9d684ff2cdefc0a8640e00d4f909", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：文本编辑器 \/ 标签：编辑 ", 
"snippet" : "撤消次数 您可以应用的最大编辑步骤数 编辑→撤消 命令 折叠式的 通过缩进定义代码的结构 当您选择缩进时，您可以通过在每个部分的第一行前面的加号和减号来展开或折叠缩进部分。 缩进 ： CODESYS 将所有相对于前一行缩进的行组合成一个缩进单元。 显式 ：您使用应组合在一个缩进单元中的注释显式标记代码段：带有三个左大括号“{{{”的注释必须在该段之前，并且带有三个右大括号“}}}”的注释必须在段之后。注释可以包含附加文本。例子： 自动换行 柔软的 : 当为 0 指定时，在编辑器窗口的边缘发生换行 换行边距 . 难的 : 换行出现在指定的字符数之后 换行边距 . 标签宽度 字符数 保持标签 ： ...", 
"body" : "撤消次数 您可以应用的最大编辑步骤数 编辑→撤消 命令 折叠式的 通过缩进定义代码的结构 当您选择缩进时，您可以通过在每个部分的第一行前面的加号和减号来展开或折叠缩进部分。 缩进 ： CODESYS 将所有相对于前一行缩进的行组合成一个缩进单元。 显式 ：您使用应组合在一个缩进单元中的注释显式标记代码段：带有三个左大括号“{{{”的注释必须在该段之前，并且带有三个右大括号“}}}”的注释必须在段之后。注释可以包含附加文本。例子： 自动换行 柔软的 : 当为 0 指定时，在编辑器窗口的边缘发生换行 换行边距 . 难的 : 换行出现在指定的字符数之后 换行边距 . 标签宽度 字符数 保持标签 ： CODESYS 不会破坏您通过 标签 键，之后进入各个空间。 缩进宽度 如果您选择了 聪明的 或者 智能代码完成 为了 自动缩进 选项，然后 CODESYS 在行首插入空格数。 自动缩进 没有任何 堵塞 ：新行自动应用上一行的缩进。 聪明的 ：包含关键字的行之后的行（例如， VAR ) 自动缩进指定 Indent width . 智能代码完成 : 缩进 聪明的 选项，但是 CODESYS 还插入结束关键字（例如， END_VAR ）。 " }, 
{ "title" : "选项卡：文本区域 ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_69e944a24ff2cdf1c0a8640e01db5766", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：文本编辑器 \/ 选项卡：文本区域 ", 
"snippet" : "突出显示当前行 ：光标所在行高亮显示。 匹配括号 ：当光标位于一行代码中括号之前或之后时，相应的右括号或左括号会用一个框架标记。 行尾标记 ：每个编辑器行的结尾在该行的最后一个字符（包括空格）之后用一个小破折号标记。 包装指南 ：选择软或硬换行时，定义的换行位置以垂直线显示。 字体 单击该字段将打开用于配置字体的默认对话框。...", 
"body" : "突出显示当前行 ：光标所在行高亮显示。 匹配括号 ：当光标位于一行代码中括号之前或之后时，相应的右括号或左括号会用一个框架标记。 行尾标记 ：每个编辑器行的结尾在该行的最后一个字符（包括空格）之后用一个小破折号标记。 包装指南 ：选择软或硬换行时，定义的换行位置以垂直线显示。 字体 单击该字段将打开用于配置字体的默认对话框。 " }, 
{ "title" : "标签：边距 ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_1e6959244ff2cdf1c0a8640e01e6af9e", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：文本编辑器 \/ 标签：边距 ", 
"snippet" : "文本编辑器窗口左边距的设置，它与输入区域用一条竖线隔开 行号 ：编辑器的声明部分和实现部分在左边编号，每部分都从1开始。 突出显示当前行 ：光标所在行的行号高亮显示。 显示括号范围 ：括号包括打开和关闭结构的关键字之间的行（例如， IF 和 END_IF ）。 When the option is selected and the cursor is positioned before, after, or in one of the keywords of a construct, the bracket area is displayed with a square bracket in ...", 
"body" : "文本编辑器窗口左边距的设置，它与输入区域用一条竖线隔开 行号 ：编辑器的声明部分和实现部分在左边编号，每部分都从1开始。 突出显示当前行 ：光标所在行的行号高亮显示。 显示括号范围 ：括号包括打开和关闭结构的关键字之间的行（例如， IF 和 END_IF ）。 When the option is selected and the cursor is positioned before, after, or in one of the keywords of a construct, the bracket area is displayed with a square bracket in the margin. 鼠标动作 您可以为每个指定的鼠标操作或鼠标\/键盘组合分配以下操作之一。 CODESYS 当您将鼠标移动到括号区域标题前面的加号或减号时执行选定的操作： 没有任何 ：鼠标动作不会触发动作。 选择折叠 ： CODESYS 选择括号区域的所有行。 切换折叠 ： CODESYS 打开或关闭括号区域，或者如果有嵌套括号，则为第一层括号区域。 切换完全折叠 ： CODESYS 打开或关闭嵌套的括号区域的所有级别。 " }, 
{ "title" : "标签：监控 ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_0ca52533c15411e3a290e57e01b702a2", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项 \/ 对话框：选项：文本编辑器 \/ 标签：监控 ", 
"snippet" : "显示监控字段的设置 启用在线监控 ：在线模式下显示变量后的监控字段 显示位数 监控字段中浮点数的显示位数 示例：值：12.345；显示位数：3；显示：12.3 字符串长度 监控字段中字符串变量值的最大长度...", 
"body" : "显示监控字段的设置 启用在线监控 ：在线模式下显示变量后的监控字段 显示位数 监控字段中浮点数的显示位数 示例：值：12.345；显示位数：3；显示：12.3 字符串长度 监控字段中字符串变量值的最大长度 " }, 
{ "title" : "对话框：自定义 ", 
"url" : "_cds_f_dlg_customize.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：自定义 ", 
"snippet" : "定制 该对话框包含用于配置用户界面的选项卡。 您可以随时使用 重启 按钮重置 CODESYS 默认设置。...", 
"body" : "定制 该对话框包含用于配置用户界面的选项卡。 您可以随时使用 重启 按钮重置 CODESYS 默认设置。 " }, 
{ "title" : "对话框：自定义：菜单 ", 
"url" : "_cds_dlg_customize_menu.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：自定义 \/ 对话框：自定义：菜单 ", 
"snippet" : "菜单 功能 ：通过此对话框，您可以定义用户界面的结构和内容。 称呼 ： 工具 → 自定义 命令， 菜单 标签 当你点击 行 要关闭对话框，更改会显示在 CODESYS 用户界面。 菜单 显示当前定义的菜单、子菜单和包含的命令 CODESYS 标识菜单或子菜单的标题 象征。从上到下的布局对应后面显示的布局 CODESYS 菜单。 添加命令 选择命令时可以选择 在所选命令上方添加命令 打开 添加命令 对话 使用 添加命令 对话框以选择一个或多个命令。 左部分：类别列表 右侧部分：所选类别中的命令列表 添加分隔符 在所选命令上方插入分隔符 添加弹出菜单 在所选菜单、子菜单或命令上方添加弹出菜单 打开...", 
"body" : "菜单 功能 ：通过此对话框，您可以定义用户界面的结构和内容。 称呼 ： 工具 → 自定义 命令， 菜单 标签 当你点击 行 要关闭对话框，更改会显示在 CODESYS 用户界面。 菜单 显示当前定义的菜单、子菜单和包含的命令 CODESYS 标识菜单或子菜单的标题 象征。从上到下的布局对应后面显示的布局 CODESYS 菜单。 添加命令 选择命令时可以选择 在所选命令上方添加命令 打开 添加命令 对话 使用 添加命令 对话框以选择一个或多个命令。 左部分：类别列表 右侧部分：所选类别中的命令列表 添加分隔符 在所选命令上方插入分隔符 添加弹出菜单 在所选菜单、子菜单或命令上方添加弹出菜单 打开 添加弹出菜单 对话 编辑弹出菜单 打开 添加弹出菜单 对话 重启 将整个菜单重置为默认设置 加载 从存储的文件（<文件名>.opt.menu）加载设置 添加弹出菜单 CODESYS 仅当菜单包含至少一个命令时，才在菜单栏中显示新菜单。 默认文本 当本地化可用时选择此选项。 本地化文本 语言和本地化文本列表 添加语言 打开语言的列表框 CODESYS 在 本地化文本 区域。使用 文本 列以指定本地化文本。 有关更多信息，请参阅： 自定义菜单" }, 
{ "title" : "对话框：自定义：命令图标 ", 
"url" : "_cds_dlg_customize_command_icon.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：自定义 \/ 对话框：自定义：命令图标 ", 
"snippet" : "命令图标 功能 ：通过此对话框，您可以定义菜单命令的图标。 称呼 ： 工具 → 自定义 命令， 命令图标 标签 命令图标 分配 打开一个对话框，您可以在其中选择新图标 (*.ico) 消除 删除自定义图标 默认图标再次处于活动状态。 重启 将所有命令图标重置为默认设置 加载 从存储的文件（<文件名>.opt.keyb）加载设置 保存 将当前设置保存到文件（<文件名>.opt.keyb） 有关更多信息，请参阅： 自定义命令图标...", 
"body" : "命令图标 功能 ：通过此对话框，您可以定义菜单命令的图标。 称呼 ： 工具 → 自定义 命令， 命令图标 标签 命令图标 分配 打开一个对话框，您可以在其中选择新图标 (*.ico) 消除 删除自定义图标 默认图标再次处于活动状态。 重启 将所有命令图标重置为默认设置 加载 从存储的文件（<文件名>.opt.keyb）加载设置 保存 将当前设置保存到文件（<文件名>.opt.keyb） 有关更多信息，请参阅： 自定义命令图标" }, 
{ "title" : "对话框：自定义 - 工具栏 ", 
"url" : "_cds_dlg_customize_toolbar.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：自定义 \/ 对话框：自定义 - 工具栏 ", 
"snippet" : "工具栏 功能 ：使用此对话框，您可以创建新工具栏或自定义现有工具栏。 称呼 ： 工具 → 自定义 命令， 工具栏 标签 当你点击 行 要关闭对话框，更改会显示在 CODESYS 用户界面。 工具栏 显示当前定义的工具栏 CODESYS 按照它们在工具栏上出现的顺序列出每个工具栏下方的相关命令。 双击列表中的工具栏会切换到编辑模式。 添加工具栏 选择工具栏时可以选择 CODESYS 在所选工具栏上方添加一个工具栏，并将光标定位在新工具栏的名称字段中。 添加命令 当您选择工具栏下方的命令或空白命令条目时可以选择 在所选命令上方添加命令 打开 添加命令 对话 使用 添加命令 对话框以选择一个或多个命...", 
"body" : "工具栏 功能 ：使用此对话框，您可以创建新工具栏或自定义现有工具栏。 称呼 ： 工具 → 自定义 命令， 工具栏 标签 当你点击 行 要关闭对话框，更改会显示在 CODESYS 用户界面。 工具栏 显示当前定义的工具栏 CODESYS 按照它们在工具栏上出现的顺序列出每个工具栏下方的相关命令。 双击列表中的工具栏会切换到编辑模式。 添加工具栏 选择工具栏时可以选择 CODESYS 在所选工具栏上方添加一个工具栏，并将光标定位在新工具栏的名称字段中。 添加命令 当您选择工具栏下方的命令或空白命令条目时可以选择 在所选命令上方添加命令 打开 添加命令 对话 使用 添加命令 对话框以选择一个或多个命令。 左部分：类别列表 右侧部分：所选类别中的命令列表 添加分隔符 在所选命令上方插入分隔符 隐藏 隐藏选定的工具栏 CODESYS 用户界面 展示 在 CODESYS 用户界面 重启 将工具栏重置为默认设置 加载 从存储的文件（<文件名>.opt.tbar）加载设置 有关更多信息，请参阅： 自定义工具栏" }, 
{ "title" : "对话框：自定义 - 键盘 ", 
"url" : "_cds_dlg_customize_keyboard.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：自定义 \/ 对话框：自定义 - 键盘 ", 
"snippet" : "键盘 功能 ：使用此对话框，您可以定义命令的快捷方式（快速访问键或键盘组合）。 打电话 : 工具 → 自定义 命令， 键盘 选项卡 选项卡： 键盘 所选命令的快捷方式 所选命令的键盘快捷键 列表框可以包含多个命令的快捷方式。 按快捷键 所选字段快捷方式的输入字段 允许的组合包括 Ctrl , Alt , 转移 , 和其他键。你点击 分配 将录制的快捷方式分配给选定的命令。 当前使用的快捷方式 分配给当前定义的快捷方式的命令 重启 将快捷方式重置为默认设置 加载 从存储的文件加载设置 <file name>.opt.keyb 有关更多信息，请参阅： 自定义键盘快捷键， 键盘快捷键，以及 Wind...", 
"body" : "键盘 功能 ：使用此对话框，您可以定义命令的快捷方式（快速访问键或键盘组合）。 打电话 : 工具 → 自定义 命令， 键盘 选项卡 选项卡： 键盘 所选命令的快捷方式 所选命令的键盘快捷键 列表框可以包含多个命令的快捷方式。 按快捷键 所选字段快捷方式的输入字段 允许的组合包括 Ctrl , Alt , 转移 , 和其他键。你点击 分配 将录制的快捷方式分配给选定的命令。 当前使用的快捷方式 分配给当前定义的快捷方式的命令 重启 将快捷方式重置为默认设置 加载 从存储的文件加载设置 <file name>.opt.keyb 有关更多信息，请参阅： 自定义键盘快捷键， 键盘快捷键，以及 Windows™ 快捷方式" }, 
{ "title" : "对话框：证书选择 ", 
"url" : "_cds_dlg_certificate_selection.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：证书选择 ", 
"snippet" : "证书选择 象征： 功能 ：该对话框用于选择用于加密、解密和数字签名的证书。 称呼 ： 安全屏幕 看法， 用户 标签 查看 → 属性 命令， 加密 选项卡，当 应用 在设备树中被选中 项目 → 项目设置 命令， 安全 类别...", 
"body" : "证书选择 象征： 功能 ：该对话框用于选择用于加密、解密和数字签名的证书。 称呼 ： 安全屏幕 看法， 用户 标签 查看 → 属性 命令， 加密 选项卡，当 应用 在设备树中被选中 项目 → 项目设置 命令， 安全 类别 " }, 
{ "title" : "对话框：证书选择 ", 
"url" : "_cds_dlg_certificate_selection.html#UUID-e72f57e4-30c1-3979-3c7c-8789f178b99d_id_fbfcef7f68cc8d6c0a864630f88b355_id_66ae7b16c2e29ee4c0a8646372161059", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：证书选择 \/ 对话框：证书选择 ", 
"snippet" : "在对话框中选择的证书的用途取决于调用位置： 通话地点： 安全屏幕 看法， 用户 标签 数字签名证书 项目文件解密证书 加密通信证书 通话地点： 查看 → 属性 申请的 共享加密下载和启动应用程序的设备证书 通话地点： 项目 → 项目设置 , 安全 类别 项目加密证书 在表格中列出所选证书 为每个选定的 X.509 证书显示以下属性： 颁发给 由...发出 有效期自 有效期至 指纹 ：SHA1指纹 双击条目打开 证书 与 一般的 标签， 细节 选项卡，以及 认证路径 标签。在选项卡中，您将找到对 Windows 帮助的参考，其中包含有关对话框的更多信息。 将选定的可用证书添加到选定证书的列表中 ...", 
"body" : "在对话框中选择的证书的用途取决于调用位置： 通话地点： 安全屏幕 看法， 用户 标签 数字签名证书 项目文件解密证书 加密通信证书 通话地点： 查看 → 属性 申请的 共享加密下载和启动应用程序的设备证书 通话地点： 项目 → 项目设置 , 安全 类别 项目加密证书 在表格中列出所选证书 为每个选定的 X.509 证书显示以下属性： 颁发给 由...发出 有效期自 有效期至 指纹 ：SHA1指纹 双击条目打开 证书 与 一般的 标签， 细节 选项卡，以及 认证路径 标签。在选项卡中，您将找到对 Windows 帮助的参考，其中包含有关对话框的更多信息。 将选定的可用证书添加到选定证书的列表中 删除列表中选择的证书 本地 Windows 证书存储中的可用证书 双击条目打开 证书 与 一般的 标签， 细节 选项卡，以及 认证路径 标签。在选项卡中，您将找到对 Windows 帮助的参考，其中包含有关对话框的更多信息。 证书图标 : 带有私钥的证书 : 不受信任的证书 有关更多信息，请参阅： 安全屏幕" }, 
{ "title" : "对话框：库参数 ", 
"url" : "_cds_dlg_library_parameter.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参考：用户界面 \/ 对话框 \/ 对话框：库参数 ", 
"snippet" : "库参数 应用程序的库管理器和 POU 池中存在的库的库参数显示在此对话框中。可以在此对话框中更改参数值。此外，还可以导出和导入参数。 出口 打开 Export Library Parameters 用于选择要导出的参数列表的对话框。为每个参数列表生成一个 CSV 文件。 进口 打开用于选择要导入的参数列表的对话框 重置 （工具栏） 将所有参数重置为其默认值 值（可编辑） 参数的值。您可以编辑该值。 默认值 库中定义的参数的默认值 重置 通过单击该图标，您可以将单个参数、参数列表中的所有参数或所有参数列表中的所有参数重置为其默认值。...", 
"body" : "库参数 应用程序的库管理器和 POU 池中存在的库的库参数显示在此对话框中。可以在此对话框中更改参数值。此外，还可以导出和导入参数。 出口 打开 Export Library Parameters 用于选择要导出的参数列表的对话框。为每个参数列表生成一个 CSV 文件。 进口 打开用于选择要导入的参数列表的对话框 重置 （工具栏） 将所有参数重置为其默认值 值（可编辑） 参数的值。您可以编辑该值。 默认值 库中定义的参数的默认值 重置 通过单击该图标，您可以将单个参数、参数列表中的所有参数或所有参数列表中的所有参数重置为其默认值。 " }, 
{ "title" : "键盘快捷键 ", 
"url" : "_cds_shortcuts.html", 
"breadcrumbs" : "CODESYS Essentials \/ 键盘快捷键 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "默认键盘快捷键 ", 
"url" : "_cds_shortcuts.html#UUID-5d1e0bf4-8c51-7fbb-189a-4bb7f0ecc719", 
"breadcrumbs" : "CODESYS Essentials \/ 键盘快捷键 \/ 默认键盘快捷键 ", 
"snippet" : "什么时候 CODESYS Development System 首次安装，默认设置以下按键组合。 您可以自定义默认快捷键以满足您的个人要求。 默认键盘快捷键位于 工具 → 自定义 菜单，在 键盘 选项卡。您可以为其中列出的任何命令指定键盘快捷键，也可以将其删除或更改。 有关详细信息，请参阅： 自定义键盘快捷键图标 命令 捷径 描述 类别 查看 菜单： 观点设备 Alt + 0 打开 设备 观点 全屏 Ctrl + Shift + F12 这个 全屏 命令在全屏模式和窗口模式之间切换 POU Alt + 1 打开 POU 观点 模块 Alt + 2 打开 模块 查看 消息 Alt + 3 打开 ...", 
"body" : "什么时候 CODESYS Development System 首次安装，默认设置以下按键组合。 您可以自定义默认快捷键以满足您的个人要求。 默认键盘快捷键位于 工具 → 自定义 菜单，在 键盘 选项卡。您可以为其中列出的任何命令指定键盘快捷键，也可以将其删除或更改。 有关详细信息，请参阅： 自定义键盘快捷键图标 命令 捷径 描述 类别 查看 菜单： 观点设备 Alt + 0 打开 设备 观点 全屏 Ctrl + Shift + F12 这个 全屏 命令在全屏模式和窗口模式之间切换 POU Alt + 1 打开 POU 观点 模块 Alt + 2 打开 模块 查看 消息 Alt + 3 打开 消息 查看 类别 CFC 菜单： CFC 全选 Ctrl + Shift + A 选择 CFC 编辑器中的所有内容 重置引脚 Ctrl + U 重置盒子的大头针 插入输出 Ctrl + A 新输出 插入盒 Ctrl + Shift + B 新盒子 从输入助手插入框 Ctrl + B 打开输入助手 从输入助手插入带有 EN\/ENO 的框 Ctrl + Shift + E 打开输入助手 插入输入 Ctrl + Q 否定 Ctrl + N 插入跳转 Ctrl + L 切换 S\/R\/Ref\/None Ctrl + M 类别 文件 菜单： 文件出口 Alt + F4 退出 CODESYS Development System 新项目 Ctrl + N 打开项目 Ctrl + O 保存项目 Ctrl + S 类别 FBD\/LD 菜单： FBD\/LD 删除 IL 行 Ctrl + Del 边缘检测 Ctrl + E 在选定的框输入或输出之前 插入盒 Ctrl + B 最后在选定的网络中 带 EN\/ENO 的插入盒 Ctrl + Shift + E 插入分支 Ctrl + Shift + V 在选定的线路上 插入线圈 Ctrl + A 插入联系人 Ctrl + K 插入触点（右） Ctrl + D 平行插入触点（上图） Ctrl + P 平行插入触点（下） Ctrl + R 插入作业 Ctrl + A 插入边缘检测 Ctrl + E 插入空盒子 Ctrl + Shift + B 插入网络 Ctrl + I 插入网络（下） Ctrl + T 插入输入 Ctrl + Q 插入跳转 Ctrl + L 否定 Ctrl + N 粘贴在上面 Ctrl + H 粘贴在下面 Ctrl + F 向右粘贴（之后） Ctrl + G 设置输出连接 Ctrl + W 设置\/重置 Ctrl + M 切换网络评论状态 Ctrl + O 更新参数 Ctrl + U 查看功能框图 Ctrl + 1 以指令列表的形式查看 Ctrl + 3 查看为梯形图逻辑 Ctrl + 2 类别 声明 菜单： 声明 插入 Ins 插入类别 窗口 菜单： 窗户关闭编辑器 Ctrl + F4 前任编辑 Ctrl + Shift + F6 下一位编辑 Ctrl + F6 上一个窗格 Shift + F6 下一个窗格 F6 切换第一个窗格 Alt + F6 类别 断点 菜单： 调试切换断点 F9 步入 F8 走出去 Shift + F10 越过 F10 类别 帮帮我 帮助内容 Ctrl + Shift + F1 类别 智能编码 输入助手 F2 输入帮助自动声明 Shift + F2 声明变量类别 梯子 (LD2) 菜单： 梯子 超越评论 Ctrl + O 插入块 Ctrl + B 开关沿检测 Ctrl + E 插入联系人 Ctrl + K 插入线圈 Ctrl + A 插入输入 Ctrl + Shift + I 插入输出 Ctrl + Shift + O 插入ST块 Ctrl + Shift + S 否定 Ctrl + N 插入网络 Ctrl + I 开关设置\/重置修改器 Ctrl + M 插入跳转 Ctrl + L 插入回车 Ctrl + R EN Ctrl + Shift + E 添加或移除 EN 输入 ENQ Ctrl + Shift + N 添加 EN0 输入 开放并行分支 Ctrl + P 关闭并行分支 Ctrl + Shift + P 类别 书签 菜单： 编辑 → 书签 下一个书签（活动编辑器） F12 下一个书签（活动编辑器）上一个书签（活动编辑器） Shift + F12 上一个书签（活动编辑器）切换书签 Ctrl + F12 打开\/关闭书签类别“消息视图” 下一条消息 F4 下一条消息上一条消息 Shift + F4 上一条消息类别 在线 在线的调试强制值 F7 力值登录 Alt + F8 登出 Ctrl + F8 单周期 Ctrl + F5 开始 F5 停止 Shift + F8 Unforce Values [主动申请] Alt + F7 写入值 [活动应用程序] Ctrl + F7 类别 浏览项目 转到定义 Ctrl + Shift + D 转到定义显示交叉引用 Ctrl + Shift + X 输出交叉引用类别 撤消\/重做 标准命令撤消 Ctrl + Z 恢复 Ctrl + Y 类别 查找\/替换 编辑代替 Ctrl + H 在项目中替换 Ctrl + Shift + H 寻找 Ctrl + F 在项目中查找 Ctrl + Shift + F 查找上一个 Shift + F3 查找上一个（已选择） Ctrl + Shift + F3 找下一个 F3 查找下一个（已选择） Ctrl + F3 类别 文本编辑器 结构化文本和扩展结构化文本 (ExST)增量搜索的切换字段 Ctrl + Shift + I 小写 Ctrl + U 转换为小写变成大写 Ctrl + Shift + U 转换为大写覆盖模式 Ins 覆盖模式注释掉选定的行 Ctrl + O 注释掉选定的行取消注释所选行 Ctrl + I 从选定的行中删除注释类别 构建 生成代码 F11 生成代码类别 剪贴板 标准命令复制 Ctrl + Ins 切 Ctrl + X 删除 Del 插入 Ctrl + V 选择全部 Ctrl + A " }, 
{ "title" : "ST 编辑器中的快捷方式 ", 
"url" : "_cds_shortcuts.html#UUID-f3d4b715-919a-f02b-f433-3a0754c935f4", 
"breadcrumbs" : "CODESYS Essentials \/ 键盘快捷键 \/ ST 编辑器中的快捷方式 ", 
"snippet" : "ST 编辑器 按键组合 移动 + Alt + → 将 IEC 代码的矩形选择范围向右扩展。 提示：使用矩形选择来更改代码的缩进。 移动 + Alt + ← 将 IEC 代码的矩形选择范围向左扩展 移动 + Alt + ↑ 向上扩展 IEC 代码的矩形选择范围 移动 + Alt + ↓ 向下扩展 IEC 代码的矩形选择范围 移动 + → 将选择范围向右扩展一个字符 移动 + ← 将选择范围向左扩展一个字符 移动 + ↑ 将选择范围向上扩展一行 移动 + ↓ 将选择范围向下扩展一行 移动 + 滚动鼠标滚轮 沿滚动条滚动 IEC 代码 如果无法再在窗口中显示代码，则会自动提供滚动条。 Ctrl + ...", 
"body" : "ST 编辑器 按键组合 移动 + Alt + → 将 IEC 代码的矩形选择范围向右扩展。 提示：使用矩形选择来更改代码的缩进。 移动 + Alt + ← 将 IEC 代码的矩形选择范围向左扩展 移动 + Alt + ↑ 向上扩展 IEC 代码的矩形选择范围 移动 + Alt + ↓ 向下扩展 IEC 代码的矩形选择范围 移动 + → 将选择范围向右扩展一个字符 移动 + ← 将选择范围向左扩展一个字符 移动 + ↑ 将选择范围向上扩展一行 移动 + ↓ 将选择范围向下扩展一行 移动 + 滚动鼠标滚轮 沿滚动条滚动 IEC 代码 如果无法再在窗口中显示代码，则会自动提供滚动条。 Ctrl + 滚动鼠标滚轮 放大和缩小 IEC 代码 Ctrl + 移动 + 我 打开字符串增量搜索对话框 指定字符串。此字符串用于过滤。所有匹配项均突出显示。 Alt + 向上翻页 Alt + 向下翻页 跳转到 IEC 代码中下一个突出显示的匹配项 仅当增量搜索对话框打开时，快捷键才处于活动状态。 " }, 
{ "title" : "变量声明的快捷方式 ", 
"url" : "_cds_shortcuts.html#UUID-b084a34b-4c9b-2f23-7f63-b00a45a8774d", 
"breadcrumbs" : "CODESYS Essentials \/ 键盘快捷键 \/ 变量声明的快捷方式 ", 
"snippet" : "在文本声明编辑器中，您可以使用快捷方式声明变量以免打字。 在一行代码中指定缩写形式，然后按下完成操作 Ctrl + 输入 。然后，该行代码将自动完成。您可以缩短范围的规范，也可以缩短变量声明。 有关更多信息，请参阅 “简短表单功能” 部分： 使用输入辅助范围 范围短 按下后 Ctrl + 输入 ，已完成至 v VAR ev END_VAR vi VAR_INPUT vo VAR_OUTPUT vio VAR_IN_OUT 用简写形式声明变量 <简短声明> + Ctrl + Enter 简短声明是对带有缩进、最后分号和注释的完整变量声明的补充。 在一行代码中，首先指定变量名称，并在空格后指定数据...", 
"body" : "在文本声明编辑器中，您可以使用快捷方式声明变量以免打字。 在一行代码中指定缩写形式，然后按下完成操作 Ctrl + 输入 。然后，该行代码将自动完成。您可以缩短范围的规范，也可以缩短变量声明。 有关更多信息，请参阅 “简短表单功能” 部分： 使用输入辅助范围 范围短 按下后 Ctrl + 输入 ，已完成至 v VAR ev END_VAR vi VAR_INPUT vo VAR_OUTPUT vio VAR_IN_OUT 用简写形式声明变量 <简短声明> + Ctrl + Enter 简短声明是对带有缩进、最后分号和注释的完整变量声明的补充。 在一行代码中，首先指定变量名称，并在空格后指定数据类型、地址、初始化和注释的缩写（均为可选）。按下完成输入 Ctrl + 输入 。然后添加缩写条目 <变量名> % <地址><数据类型的简称><初始化> ; <注释> 简短声明的选项 <变量名> 指定至少一个变量名。 您还可以指定多个由空格分隔的变量名称。逗号是自动添加的 % <地址> 可选 简短地址由 AT 声明 。 <数据类型的简称> 可选 默认数据类型为 BOOL 。如果未指定数据类型，则 BOOL 已添加。 可能的短表单，方括号中包含完整语法 b （ : BOOL ) d （ : DINT ) i （ := INT) l （ : LINT ) r （ : REAL ) s （ : STRING ) s 8 （ : STRING(8) 带字符串长度 t （ : TIME ) u （ : UINT ) w （ : WORD ) <初始化> 可选 指定与数据类型匹配的文字。 该选项补充到 :=  <literal> ; <注释> 可选 例子 简短声明 按下后 Ctrl + 输入 ，已完成至 xStart xStart : BOOL; xStop b xStop : BOOL; xSensor %IX7.5 xSensor AT %IX7.5: BOOL; diMax d 999 diMax: DINT; iMaxLoop i 100 iMaxLoop : INT := 100; liBigLoop l liBigLoop : LINT; rRadius r rRadius : REAL; strStateInProgress s 32 ; State in progress strStateInProgress : STRING(32); \/\/ State in Progress tMaxTime t tMaxTime : TIME; uiCounter u uiCounter : UINT; wFilter w 16#aaaa wFilter : WORD := 16#AAAA; Error_1 Error_2 Error_3 i ; Error codes Error_1, Error_2, Error_3 : INT; \/\/ Error codes " }, 
{ "title" : "Windows™ 快捷方式 ", 
"url" : "_cds_shortcuts.html#UUID-f952bfa4-6c2c-721d-4fad-ddafaad7c598", 
"breadcrumbs" : "CODESYS Essentials \/ 键盘快捷键 \/ Windows™ 快捷方式 ", 
"snippet" : "Windows™ 键盘快捷键通常由以下机构支持 CODESYS 。 使用以下键盘快捷键在以下内容中导航： 设备 视图， POU 视图、库管理器（在内容中）、任务配置、输入助手、交叉引用列表、 可视化工具箱 视图、属性、可视化标签视图、趋势记录、跟踪配置或存储库。 上面列出的视图中的对象标有 下方有更多物体时的符号。此时可以扩展视图。对象标有 下方没有其他物体时的符号。视图已完全展开。 有用的Windows导航快捷方式 键盘区域 钥匙 程序 效果 数字键盘 * 在树视图中，选择一个标有 符号。然后按 * 钥匙。 树视图中位于所选对象或文件夹下方的所有内容都将展开。 数字键盘 箭头键 + → 在树...", 
"body" : "Windows™ 键盘快捷键通常由以下机构支持 CODESYS 。 使用以下键盘快捷键在以下内容中导航： 设备 视图， POU 视图、库管理器（在内容中）、任务配置、输入助手、交叉引用列表、 可视化工具箱 视图、属性、可视化标签视图、趋势记录、跟踪配置或存储库。 上面列出的视图中的对象标有 下方有更多物体时的符号。此时可以扩展视图。对象标有 下方没有其他物体时的符号。视图已完全展开。 有用的Windows导航快捷方式 键盘区域 钥匙 程序 效果 数字键盘 * 在树视图中，选择一个标有 符号。然后按 * 钥匙。 树视图中位于所选对象或文件夹下方的所有内容都将展开。 数字键盘 箭头键 + → 在树视图中，选择一个标有 符号。然后按 + 或者 → 钥匙。 该节点标有 符号。 对象或文件夹已展开。 数字键盘 - 在树视图中，选择一个标有 符号。然后按 - 钥匙。 该文件夹或元素已折叠。 数字键盘 箭头键 \/ ← 在树视图中，选择一个标有 符号。然后按 \/ 或者 ← 钥匙。 所选对象或文件夹下方的所有内容都已折叠。 箭头键 ↓ 在树视图中，选择一个节点。然后按 ↓ 钥匙。 选择向下移动。 箭头键 ↑ 在树视图中，选择一个节点。然后按 ↑ 钥匙。 选择向上移动。 当您使用带有数字键盘上的按键的快捷键时，请确保启用数字键盘。 缩放 键盘区域 快捷方式 效果 数字键盘（数字键盘） Ctrl + + 放大 数字键盘（数字键盘） Ctrl + - 缩小 " }, 
{ "title" : "现场总线支持 ", 
"url" : "f_device_editors.html", 
"breadcrumbs" : "CODESYS Essentials \/ 现场总线支持 ", 
"snippet" : "CODESYS 支持链接到常见的现场总线类型。 有关使用设备的一般信息，请参阅： 设备树和设备编辑器有关将设备用于特定现场总线类型的特殊信息，请参阅有关该特定现场总线类型的帮助。 对于使用 Hilscher GmbH 的 cifX 卡（带有相应的 IEC 库）， CODESYS 配置文件（ .cfg ) 必须使用以下条目进行扩展： Component. <next free number> =CmpHilscherCIFX...", 
"body" : "CODESYS 支持链接到常见的现场总线类型。 有关使用设备的一般信息，请参阅： 设备树和设备编辑器有关将设备用于特定现场总线类型的特殊信息，请参阅有关该特定现场总线类型的帮助。 对于使用 Hilscher GmbH 的 cifX 卡（带有相应的 IEC 库）， CODESYS 配置文件（ .cfg ) 必须使用以下条目进行扩展：\n Component. <next free number> =CmpHilscherCIFX " }, 
{ "title" : "设备诊断 ", 
"url" : "_cds_device_diagnosis.html", 
"breadcrumbs" : "CODESYS Essentials \/ 现场总线支持 \/ 设备诊断 ", 
"snippet" : "CODESYS 提供通用和特定于现场总线的功能块，用于对连接的设备进行诊断。 总线特定诊断 有关总线特定的诊断选项，请参见各个现场总线的诊断章节。 有关更多信息，请参阅： PROFINET 诊断 CANbus 诊断 EtherCAT 诊断...", 
"body" : "CODESYS 提供通用和特定于现场总线的功能块，用于对连接的设备进行诊断。 总线特定诊断 有关总线特定的诊断选项，请参见各个现场总线的诊断章节。 有关更多信息，请参阅： PROFINET 诊断 CANbus 诊断 EtherCAT 诊断 " }, 
{ "title" : "一般诊断 ", 
"url" : "_cds_device_diagnosis.html#UUID-72f58fb2-a1cc-a2fd-a40b-f4a3fa8ca139_id_daf5ed59161447ec0a864634c91a40a_id_6d82803d91777a29c0a864635f481699", 
"breadcrumbs" : "CODESYS Essentials \/ 现场总线支持 \/ 设备诊断 \/ 一般诊断 ", 
"snippet" : "无论现场总线如何，您都可以对设备进行诊断。从功能块 CAA Device Diagnosis 为此目的提供了库。 在使用这些功能块之前，您必须选择 启用设备诊断 PLC 设置中的选项。这引起 CODESYS 自动创建诊断功能块的实例。这些功能块可用于您的诊断。 专门使用自动生成的诊断功能块实例。不要创建自己的实例。 有关更多信息，请参阅： 选项卡：PLC 设置图书馆：CAA DeviceDiagnosis 设备树和设备编辑器...", 
"body" : "无论现场总线如何，您都可以对设备进行诊断。从功能块 CAA Device Diagnosis 为此目的提供了库。 在使用这些功能块之前，您必须选择 启用设备诊断 PLC 设置中的选项。这引起 CODESYS 自动创建诊断功能块的实例。这些功能块可用于您的诊断。 专门使用自动生成的诊断功能块实例。不要创建自己的实例。 有关更多信息，请参阅： 选项卡：PLC 设置图书馆：CAA DeviceDiagnosis 设备树和设备编辑器" }, 
{ "title" : "现场总线设备和 I\/O 驱动程序 ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html", 
"breadcrumbs" : "CODESYS Essentials \/ 现场总线支持 \/ 现场总线设备和 I\/O 驱动程序 ", 
"snippet" : "在设备树中配置的每个现场总线设备的技术基础是 I\/O 驱动程序。 I\/O 驱动程序是现场总线堆栈、IEC 应用程序和 IDE 之间的链接。驱动程序根据设备配置数据配置现场总线堆栈。它显示诊断，为 IEC 应用程序提供 API，并负责 I\/O 映射（参见“I\/O 映射”一章）。 本章简要概述了 I\/O 驱动设备的基本功能，但不讨论具体总线系统的细节。此外，还提供了一些配置建议。 多个 I\/O 驱动程序和任务（故障排除） 如果必须同步来自多个任务以及可能跨多个 I\/O 驱动程序实例的 I\/O 数据的一致访问，则在某些情况下可能会在总线和应用程序任务之间发生不希望的相互干扰。 例如，当一般系统负载较...", 
"body" : "在设备树中配置的每个现场总线设备的技术基础是 I\/O 驱动程序。 I\/O 驱动程序是现场总线堆栈、IEC 应用程序和 IDE 之间的链接。驱动程序根据设备配置数据配置现场总线堆栈。它显示诊断，为 IEC 应用程序提供 API，并负责 I\/O 映射（参见“I\/O 映射”一章）。 本章简要概述了 I\/O 驱动设备的基本功能，但不讨论具体总线系统的细节。此外，还提供了一些配置建议。 多个 I\/O 驱动程序和任务（故障排除） 如果必须同步来自多个任务以及可能跨多个 I\/O 驱动程序实例的 I\/O 数据的一致访问，则在某些情况下可能会在总线和应用程序任务之间发生不希望的相互干扰。 例如，当一般系统负载较高或实时关键现场总线系统的 I\/O 数据与慢速阻塞本地总线系统的 I\/O 数据一起用于同一任务时，就会出现这种情况. 如果使用特别实时关键的现场总线（EtherCAT、Profinet、CAN）发生意外的通信干扰，则应首先检查任务监控是否存在周期时间中的非常大的抖动或异常值（最大值与平均值相比）价值）。任务列表提供了有关在不同任务中使用 I\/O 数据的详细信息。 可以避免在同一个任务中使用来自不同总线系统的 I\/O 数据，或者减少 I\/O 任务的数量。 有关更多信息，请参阅： 标签：任务部署" }, 
{ "title" : "总线循环任务 ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_28c562449569c838c0a8646342ae39cb", 
"breadcrumbs" : "CODESYS Essentials \/ 现场总线支持 \/ 现场总线设备和 I\/O 驱动程序 \/ 总线循环任务 ", 
"snippet" : "总线循环任务是 I\/O 驱动程序在其上下文中执行的 IEC 任务。一些 I\/O 驱动程序使用多个任务：通常一个实时关键任务（具有高优先级），用于传输 I\/O 数据，另一个具有低优先级的任务用于评估诊断和执行非循环服务等任务的总线系统。 对于实时关键总线系统，必须确保在此总线任务的上下文中不会执行任何操作，因为执行时间会中断总线时钟。 可以在 I\/O 驱动设备的 I\/O 映射对话框中配置总线任务。请注意，默认情况下会继承父设备的设置。如果此设备是 PLC，则其 PLC 设置适用于总线循环任务。 如果未设置上述设置，则使用循环时间最短的任务。这样，非实时 I\/O 驱动程序可能会在实时关键驱动程序的...", 
"body" : "总线循环任务是 I\/O 驱动程序在其上下文中执行的 IEC 任务。一些 I\/O 驱动程序使用多个任务：通常一个实时关键任务（具有高优先级），用于传输 I\/O 数据，另一个具有低优先级的任务用于评估诊断和执行非循环服务等任务的总线系统。 对于实时关键总线系统，必须确保在此总线任务的上下文中不会执行任何操作，因为执行时间会中断总线时钟。 可以在 I\/O 驱动设备的 I\/O 映射对话框中配置总线任务。请注意，默认情况下会继承父设备的设置。如果此设备是 PLC，则其 PLC 设置适用于总线循环任务。 如果未设置上述设置，则使用循环时间最短的任务。这样，非实时 I\/O 驱动程序可能会在实时关键驱动程序的任务上下文中意外执行，从而中断其通信。要诊断这些通信问题，建议检查任务监控。 有关更多信息，请参阅： 选项卡：PLC 设置" }, 
{ "title" : "I\/O 映射 ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_a15ed2aa9569c838c0a864637ae138e7", 
"breadcrumbs" : "CODESYS Essentials \/ 现场总线支持 \/ 现场总线设备和 I\/O 驱动程序 \/ I\/O 映射 ", 
"snippet" : "I\/O 驱动程序的一个基本功能是更新 I\/O 映射。这意味着将总线系统的 I\/O 数据映射到 IEC 应用程序的变量（反之亦然）。 输入\/输出数据通过双向复制和转换操作从总线系统的内部存储器映像循环映射到分配给 %I 和 %Q 地址的 IEC 变量。 在 I\/O 驱动程序内部，对于此 I\/O 映像使用符号名称还是对 %I 和 %Q 地址的“直接”访问没有区别。为了应用程序的可维护性，建议使用有意义的变量名称（例如：变量“TemperatureReactor”而不是“%IW117”访问）。 I\/O 映射的更新可以设置为 始终更新变量 （全球在 PLC 设置 或单独为 I\/O 映射对话框中的每个设...", 
"body" : "I\/O 驱动程序的一个基本功能是更新 I\/O 映射。这意味着将总线系统的 I\/O 数据映射到 IEC 应用程序的变量（反之亦然）。 输入\/输出数据通过双向复制和转换操作从总线系统的内部存储器映像循环映射到分配给 %I 和 %Q 地址的 IEC 变量。 在 I\/O 驱动程序内部，对于此 I\/O 映像使用符号名称还是对 %I 和 %Q 地址的“直接”访问没有区别。为了应用程序的可维护性，建议使用有意义的变量名称（例如：变量“TemperatureReactor”而不是“%IW117”访问）。 I\/O 映射的更新可以设置为 始终更新变量 （全球在 PLC 设置 或单独为 I\/O 映射对话框中的每个设备）： 禁用： 仅映射应用程序中使用的 I\/O 数据。 这可以通过避免复制操作来提高性能，但如果 I\/O 映射对话框中的 I\/O 数据未更新（这些值随后变灰），则可能会导致混乱。建议对已完成开发的应用程序进行此设置。 启用 1： 所有数据均已更新。 启用 2： 此选项的可用性取决于设备描述。 注意：仅用于特殊情况下的生产用途。 结果，可能会出现不一致的 I\/O 数据，因为总线周期任务读取\/写入此数据，而应用程序代码在其他任务中使用它。 有关更多信息，请参阅： 选项卡：<设备名称> I\/O 映射" }, 
{ "title" : "I\/O 数据的一致性 ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_8f4981b79569c838c0a8646301a3da14", 
"breadcrumbs" : "CODESYS Essentials \/ 现场总线支持 \/ 现场总线设备和 I\/O 驱动程序 \/ I\/O 数据的一致性 ", 
"snippet" : "编程系统允许 IEC 应用程序使用并行执行的多个任务（用于可视化、现场总线或其他 POU）。应用程序代码可以通过映射的 IEC 变量从这些任务的上下文中访问 I\/O 数据。通过从不同的任务访问相同的数据，可能会出现不一致或损坏的数据（例如，由于写入访问中断）。 I\/O 驱动程序通过为执行任务周期的每个任务提供所有使用的 I\/O 数据的一致映射（可以说是快照）来确保数据一致性。 因此，像以下示例中的代码不会导致问题：（注意“DIV by ZERO”） IF(inputData <> 0) THEN \/\/ inputData is mapped to %I x := y \/ inputData; ...", 
"body" : "编程系统允许 IEC 应用程序使用并行执行的多个任务（用于可视化、现场总线或其他 POU）。应用程序代码可以通过映射的 IEC 变量从这些任务的上下文中访问 I\/O 数据。通过从不同的任务访问相同的数据，可能会出现不一致或损坏的数据（例如，由于写入访问中断）。 I\/O 驱动程序通过为执行任务周期的每个任务提供所有使用的 I\/O 数据的一致映射（可以说是快照）来确保数据一致性。 因此，像以下示例中的代码不会导致问题：（注意“DIV by ZERO”） IF(inputData <> 0) THEN \/\/ inputData is mapped to %I\n x := y \/ inputData; \/\/ This will never result in DIV_BY_ZERO Exception\nEND_IF \/\/ inputData is not updated by bus cycle during execution of POU 随着 始终更新变量 选项设置为 启用 2 – 始终处于总线循环任务中 ，这个机制被覆盖了。因此，应用程序代码必须考虑到这一点。 " }, 
{ "title" : "服务 ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_06856b5b9569c838c0a864632fe4dc2e", 
"breadcrumbs" : "CODESYS Essentials \/ 现场总线支持 \/ 现场总线设备和 I\/O 驱动程序 \/ 服务 ", 
"snippet" : "除了基本功能外，一些 I\/O 驱动程序还提供可以从 IDE 调用的服务，例如设备扫描功能或设备地址设置。...", 
"body" : "除了基本功能外，一些 I\/O 驱动程序还提供可以从 IDE 调用的服务，例如设备扫描功能或设备地址设置。 " }, 
{ "title" : "一般建议 ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_597a65569569c838c0a864636c5a9a3d", 
"breadcrumbs" : "CODESYS Essentials \/ 现场总线支持 \/ 现场总线设备和 I\/O 驱动程序 \/ 一般建议 ", 
"snippet" : "设置： PLC 设置 ： 停止中的 I\/O 更新： 即使应用程序停止，总线周期也会继续，例如当应用程序处于调试断点时。通过这种方式，与现场设备的通信得以保持并且可以立即继续而不会中断。 PLC 设置 ： 始终更新变量 被设定为 启用 1 – 如果未在任何任务中使用，则使用总线循环任务 ： 在应用程序的开发过程中，查看所有 I\/O 数据的值很有用。 任务配置： 特别是对于 Profinet、EtherCAT 或 CAN 等实时关键现场总线系统，它们依赖于维持精确的发送\/接收时钟，建议使用具有高优先级的单独总线循环任务。对于不太实时关键的任务（例如，可视化），应选择比总线循环任务低得多的优先级。 ...", 
"body" : "设置： PLC 设置 ： 停止中的 I\/O 更新： 即使应用程序停止，总线周期也会继续，例如当应用程序处于调试断点时。通过这种方式，与现场设备的通信得以保持并且可以立即继续而不会中断。 PLC 设置 ： 始终更新变量 被设定为 启用 1 – 如果未在任何任务中使用，则使用总线循环任务 ： 在应用程序的开发过程中，查看所有 I\/O 数据的值很有用。 任务配置： 特别是对于 Profinet、EtherCAT 或 CAN 等实时关键现场总线系统，它们依赖于维持精确的发送\/接收时钟，建议使用具有高优先级的单独总线循环任务。对于不太实时关键的任务（例如，可视化），应选择比总线循环任务低得多的优先级。 为了以尽可能小的偏移量实现最大的 I\/O 吞吐量，可以在现场总线系统的总线任务中执行单独的 POU。但是，这些必须满足实时性要求：例如，不能执行文件访问或阻塞套接字函数，而只能执行输出数据的计算。 " }, 
{ "title" : "总线循环任务 ", 
"url" : "_cds_buscycle_task.html", 
"breadcrumbs" : "CODESYS Essentials \/ 现场总线支持 \/ 总线循环任务 ", 
"snippet" : "通常，对于每个 IEC 任务，在每个任务开始时读取使用的输入数据 (1)，并在任务结束时将写入的输出数据传输到 I\/O 驱动程序 (3)。 I\/O 驱动程序中的实现对于 I\/O 数据的额外传输具有决定性意义。它负责实际传输到相应总线系统的时间范围和时间点。 PLC 的总线循环任务可以在 PLC 设置中为所有现场总线全局定义。但是，对于某些现场总线，您可以独立于全局设置进行更改。循环时间最短的任务用作总线循环任务（设置： 未指定 在 PLC 设置中）。在此任务中，消息通常在总线上发送。 其他任务仅从内部缓冲区复制 I\/O 数据，该缓冲区仅与总线周期任务中的物理硬件交换。 (1) 从输入缓冲区读取...", 
"body" : "通常，对于每个 IEC 任务，在每个任务开始时读取使用的输入数据 (1)，并在任务结束时将写入的输出数据传输到 I\/O 驱动程序 (3)。 I\/O 驱动程序中的实现对于 I\/O 数据的额外传输具有决定性意义。它负责实际传输到相应总线系统的时间范围和时间点。 PLC 的总线循环任务可以在 PLC 设置中为所有现场总线全局定义。但是，对于某些现场总线，您可以独立于全局设置进行更改。循环时间最短的任务用作总线循环任务（设置： 未指定 在 PLC 设置中）。在此任务中，消息通常在总线上发送。 其他任务仅从内部缓冲区复制 I\/O 数据，该缓冲区仅与总线周期任务中的物理硬件交换。 (1) 从输入缓冲区读取输入 (2) IEC 任务 (3) 将输出写入输出缓冲区 (4) 总线周期 (5) 输入缓冲器 (6) 输出缓冲器 (7) 向\/从总线复制数据 (9) 总线循环任务，优先级 1，1 ms (10) 总线循环任务，优先级 5 (11) 总线循环任务，优先级 10，被任务 5 中断 任务使用 这 任务部署 选项卡提供已用 I\/O 通道、设置总线周期任务和通道使用情况的概览。 如果在各种任务中写入输出，则状态未定义，因为在每种情况下都可以覆盖。 如果在各种任务中使用相同的输入，则输入可能会在任务处理过程中发生变化。当任务被优先级较高的任务中断并导致再次读取进程映像时，就会发生这种情况。补救措施：在 IEC 任务开始时，将输入变量复制到变量中，然后仅使用其余代码中的局部变量。 结论：在多个任务中使用相同的输入和输出没有任何意义，并且在某些情况下会导致意外反应。 有关更多信息，请参阅： 任务配置的公交车循环任务 CANopen 经理 的公交车循环任务 EtherCAT 的公交车循环任务 Sercos 的公交车循环任务 EtherNet\/IP 的公交车循环任务 PROFIBUS " }, 
{ "title" : "对 I\/O 通道的符号访问 ", 
"url" : "_cds_symbolic_access_io_channels.html", 
"breadcrumbs" : "CODESYS Essentials \/ 现场总线支持 \/ 对 I\/O 通道的符号访问 ", 
"snippet" : "您可以通过专门生成的功能块直接访问设备的 I\/O 通道，而无需为每个设备和每个通道手动设置映射。 自动生成 输入和输出以 I\/O 通道的名称组合成一个功能块。如果可能，扩展设备描述中定义的基本块。 通道名称对应于显示在设备编辑器中的名称 选项卡：<设备名称> I\/O 映射 在列 渠道 被指定。 以这种方式创建的输入和输出变量也显示在输入助手中。 如果 I\/O 通道是结构化的或枚举的，那么它们的功能块也相应地结构化。因此，生成的功能块包含结构化的输入和输出或枚举。 对于具有相同名称的通道，后缀 _<X> 附加到功能块的输入或输出。 如果设备没有自己的 I\/O 通道（例如：EK1100 从站），则...", 
"body" : "您可以通过专门生成的功能块直接访问设备的 I\/O 通道，而无需为每个设备和每个通道手动设置映射。 自动生成 输入和输出以 I\/O 通道的名称组合成一个功能块。如果可能，扩展设备描述中定义的基本块。 通道名称对应于显示在设备编辑器中的名称 选项卡：<设备名称> I\/O 映射 在列 渠道 被指定。 以这种方式创建的输入和输出变量也显示在输入助手中。 如果 I\/O 通道是结构化的或枚举的，那么它们的功能块也相应地结构化。因此，生成的功能块包含结构化的输入和输出或枚举。 对于具有相同名称的通道，后缀 _<X> 附加到功能块的输入或输出。 如果设备没有自己的 I\/O 通道（例如：EK1100 从站），则不会创建功能块。 " }, 
{ "title" : "启用自动映射 ", 
"url" : "_cds_symbolic_access_io_channels.html#UUID-0a064dd1-3562-5c32-2219-21a759dad045_section-idm4536908457891232946602093636", 
"breadcrumbs" : "CODESYS Essentials \/ 现场总线支持 \/ 对 I\/O 通道的符号访问 \/ 启用自动映射 ", 
"snippet" : "在里面 设备 查看，打开顶部设备。在设备编辑器中，选择 PLC 设置 标签。 在下面 其他设置 ，有 为 I\/O 启用符号访问 选项。 选中复选框。 生成的功能块实例显示在 IEC 对象 设备的选项卡。 对于每个 I\/O 通道，现在会自动创建和实例化一个（通常是扩展的）功能块。这使您可以立即直接访问。您可以通过功能块的变量访问 I\/O 通道。 例子： EtherCAT Slave 新功能块扩展了现有功能块。这 EL1008 功能块实例列在设备编辑器下方 EtherCAT IEC 对象 标签。 这 DrvEthercatLib.ETCSlave_Diag 功能块扩展为 EL1008_FB 并获取...", 
"body" : "在里面 设备 查看，打开顶部设备。在设备编辑器中，选择 PLC 设置 标签。 在下面 其他设置 ，有 为 I\/O 启用符号访问 选项。 选中复选框。 生成的功能块实例显示在 IEC 对象 设备的选项卡。 对于每个 I\/O 通道，现在会自动创建和实例化一个（通常是扩展的）功能块。这使您可以立即直接访问。您可以通过功能块的变量访问 I\/O 通道。 例子： EtherCAT Slave 新功能块扩展了现有功能块。这 EL1008 功能块实例列在设备编辑器下方 EtherCAT IEC 对象 标签。 这 DrvEthercatLib.ETCSlave_Diag 功能块扩展为 EL1008_FB 并获取输出变量 Input_<n> . 功能块： EL1008_FB 示例：没有定义基本块的设备 如果设备描述中没有定义可以扩展的功能块，则生成一个新的功能块。例如， Generic_XN1AI 功能块实例列在设备编辑器下方 IEC 对象 标签。 新功能块： Generic_XN_1AI_F 示例：CANopen 这 BK5120_FB 功能块，它扩展了现有的 _3SCOS.CANRemoteDevice 根据设备描述生成功能块。这 BK5120 功能块实例在设备编辑器中列出 CANopen IEC 对象 标签。 功能块： BK5120_FB " }, 
{ "title" : "在线模式 ", 
"url" : "_cds_symbolic_access_io_channels.html#UUID-0a064dd1-3562-5c32-2219-21a759dad045_section-idm4536908379939232946873025889", 
"breadcrumbs" : "CODESYS Essentials \/ 现场总线支持 \/ 对 I\/O 通道的符号访问 \/ 在线模式 ", 
"snippet" : "在在线模式下，数据通过现有功能进行更新。但是，只有那些实际使用的生成变量会被更新。或者如果 始终更新变量 选项已启用。 如果同时以符号方式和通过 I\/O 映射访问通道，则会发出编译器警告。...", 
"body" : "在在线模式下，数据通过现有功能进行更新。但是，只有那些实际使用的生成变量会被更新。或者如果 始终更新变量 选项已启用。 如果同时以符号方式和通过 I\/O 映射访问通道，则会发出编译器警告。 " }, 
{ "title" : "图书馆 ", 
"url" : "f_libraries.html", 
"breadcrumbs" : "CODESYS Essentials \/ 图书馆 ", 
"snippet" : "库用于准备在应用程序中使用的 POU 和函数。除了帮助中提供的描述外，还请始终查看库中包含的文档。 要在项目中使用库，请参阅： 使用库要创建您自己的库，请按照 图书馆开发者指南 ....", 
"body" : "库用于准备在应用程序中使用的 POU 和函数。除了帮助中提供的描述外，还请始终查看库中包含的文档。 要在项目中使用库，请参阅： 使用库要创建您自己的库，请按照 图书馆开发者指南 . " }, 
{ "title" : "创建库的指南 ", 
"url" : "_cds_guidelines_for_creating_libraries.html", 
"breadcrumbs" : "CODESYS Essentials \/ 图书馆 \/ 创建库的指南 ", 
"snippet" : "图书馆 必须根据特定规则创建以避免兼容性问题。 主要项目包括： 选择一个有意义的库名称（必需） 使用模板确保一致性（可选） 尽可能使用熟悉且统一的项目结构（可选） 注册一个唯一的库命名空间（必需） 输入所有项目信息（必填） 应用正确的方法来正确引用其他库（必需） 设计智能外部和内部接口（必填） 实施用户友好的错误处理（必需） 应用正确的方法（保护）进行部署（必需） 应用一致的命名约定以获得干净的代码（可选） 修改现有库时，请考虑与以前版本的接口兼容性。 在开发库时遵循这些准则 CODESYS ：《图书馆发展总结》。...", 
"body" : "图书馆 必须根据特定规则创建以避免兼容性问题。 主要项目包括： 选择一个有意义的库名称（必需） 使用模板确保一致性（可选） 尽可能使用熟悉且统一的项目结构（可选） 注册一个唯一的库命名空间（必需） 输入所有项目信息（必填） 应用正确的方法来正确引用其他库（必需） 设计智能外部和内部接口（必填） 实施用户友好的错误处理（必需） 应用正确的方法（保护）进行部署（必需） 应用一致的命名约定以获得干净的代码（可选） 修改现有库时，请考虑与以前版本的接口兼容性。 在开发库时遵循这些准则 CODESYS ：《图书馆发展总结》。 " }, 
{ "title" : "此帮助请求没有帮助页面。 ", 
"url" : "_cds_f_development_system_introduction.html", 
"breadcrumbs" : "CODESYS Essentials \/ 此帮助请求没有帮助页面。 ", 
"snippet" : "单击此处转到帮助门户的起始页。...", 
"body" : "单击此处转到帮助门户的起始页。 " }
]
$(document).trigger('search.ready');
});