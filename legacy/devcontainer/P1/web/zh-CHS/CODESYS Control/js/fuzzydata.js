$(document).ready(function () {indexDict['zh-CHS'] = [{ "title" : "CODESYS Control ", 
"url" : "_rtsl_start_page.html", 
"breadcrumbs" : "CODESYS Control \/ CODESYS Control ", 
"snippet" : "您可以安装 CODESYS Control for <device> SL 各种工业设备上的运行时系统。因此，您可以通过以下方式对设备进行编程和控制： 符合 IEC 61131-3 的统一编程 CODESYS Development System 下载、管理和执行由编译的应用程序代码 CODESYS 从内部调试控制应用程序 CODESYS 处理 I\/O 系统和现场总线 可选组件的执行，例如 CODESYS TargetVisu , CODESYS WebVisu , CODESYS SoftMotion CNC + 机器人和 OPC UA 服务器...", 
"body" : "您可以安装 CODESYS Control for <device> SL 各种工业设备上的运行时系统。因此，您可以通过以下方式对设备进行编程和控制： 符合 IEC 61131-3 的统一编程 CODESYS Development System 下载、管理和执行由编译的应用程序代码 CODESYS 从内部调试控制应用程序 CODESYS 处理 I\/O 系统和现场总线 可选组件的执行，例如 CODESYS TargetVisu , CODESYS WebVisu , CODESYS SoftMotion CNC + 机器人和 OPC UA 服务器 " }, 
{ "title" : "安全通告 ", 
"url" : "_rtsl_start_page.html#UUID-421e9fc4-30bc-da26-ebd8-4038f3d434c1_section-idm4550391658761633048843474945", 
"breadcrumbs" : "CODESYS Control \/ CODESYS Control \/ 安全通告 ", 
"snippet" : "在任何情况下都不得通过互联网访问控制器。特别是，控制器的编程端口在任何情况下都不得在没有保护的情况下从 Internet 访问。 下面列出了所有运行时系统最重要的端口号。默认情况下，它们由系统分配，但可以通过以下配置进行修改： 1740..1743：网关和运行时系统中的 UDP 块驱动程序 11740..11743：网关和运行时系统中的 TCP 块驱动程序 1217：连接网关 CODESYS 到网关 8080： CODESYS 网络服务器 443： CODESYS 网络服务器 (SSL) * * 9090：用于 BeagleBone 4840： CODESYS OPC UA 服务器 22：与目...", 
"body" : "在任何情况下都不得通过互联网访问控制器。特别是，控制器的编程端口在任何情况下都不得在没有保护的情况下从 Internet 访问。 下面列出了所有运行时系统最重要的端口号。默认情况下，它们由系统分配，但可以通过以下配置进行修改： 1740..1743：网关和运行时系统中的 UDP 块驱动程序 11740..11743：网关和运行时系统中的 TCP 块驱动程序 1217：连接网关 CODESYS 到网关 8080： CODESYS 网络服务器 443： CODESYS 网络服务器 (SSL) * * 9090：用于 BeagleBone 4840： CODESYS OPC UA 服务器 22：与目标建立 SSH 连接（通过 Linux 安装\/更新基于 SL 的运行时） CODESYS 编程系统 如果仍然必须能够从 Internet 进行访问，则必须选择一种安全的方法来连接到 PLC（例如：VPN）。 因为运行时系统允许访问 PC，所以它们必须配备相应的用户和权限管理。 您可以将产品下载到 CODESYS Control 来自 CODESYS 国际商店 或者 CODESYS 商店北美 。您还可以在那里找到该产品的数据表。 CODESYS Deploy Tool " }, 
{ "title" : "产品概览 ", 
"url" : "_rtsl_product_overview.html", 
"breadcrumbs" : "CODESYS Control \/ 产品概览 ", 
"snippet" : "有关系统需求和交付范围的信息 CODESYS Control for <device> SL 产品可以在 CODESYS Store International : 可以在以下位置找到运行时系统的许可证 CODESYS Store International .没有有效许可证，所有运行时系统的运行时间限制为 2 小时。...", 
"body" : "有关系统需求和交付范围的信息 CODESYS Control for <device> SL 产品可以在 CODESYS Store International : 可以在以下位置找到运行时系统的许可证 CODESYS Store International .没有有效许可证，所有运行时系统的运行时间限制为 2 小时。 " }, 
{ "title" : "独立于硬件的运行时系统 ", 
"url" : "_rtsl_product_overview.html#UUID-da861021-6b3f-718d-ac40-c1e7e9f72bd8_section-idm4613712476080033169570967262", 
"breadcrumbs" : "CODESYS Control \/ 产品概览 \/ 独立于硬件的运行时系统 ", 
"snippet" : "CODESYS Control Win SL CODESYS Control RTE SL CODESYS Control for Linux SL CODESYS Control for Linux ARM\/ARM64 CODESYS Virtual Control SL CODESYS Virtual Safe Control SL...", 
"body" : "CODESYS Control Win SL CODESYS Control RTE SL CODESYS Control for Linux SL CODESYS Control for Linux ARM\/ARM64 CODESYS Virtual Control SL CODESYS Virtual Safe Control SL " }, 
{ "title" : "特定于硬件的运行时系统 ", 
"url" : "_rtsl_product_overview.html#UUID-da861021-6b3f-718d-ac40-c1e7e9f72bd8_section-idm4589278258244833169573395522", 
"breadcrumbs" : "CODESYS Control \/ 产品概览 \/ 特定于硬件的运行时系统 ", 
"snippet" : "CODESYS Control for Beaglebone SL CODESYS Control for Raspberry PI SL CODESYS Control for PFC100 SL CODESYS Control for PFC200 SL CODESYS Control for emPC-A\/iMX6 SL CODESYS Control for WAGO Touch Panels 600 SL CODESYS Control for PLCnext SL CODESYS Control RTE SL (for Beckhoff CX)...", 
"body" : "CODESYS Control for Beaglebone SL CODESYS Control for Raspberry PI SL CODESYS Control for PFC100 SL CODESYS Control for PFC200 SL CODESYS Control for emPC-A\/iMX6 SL CODESYS Control for WAGO Touch Panels 600 SL CODESYS Control for PLCnext SL CODESYS Control RTE SL (for Beckhoff CX) " }, 
{ "title" : "边缘网关 ", 
"url" : "_rtsl_product_overview.html#UUID-da861021-6b3f-718d-ac40-c1e7e9f72bd8_section-idm4544772720513633169577754493", 
"breadcrumbs" : "CODESYS Control \/ 产品概览 \/ 边缘网关 ", 
"snippet" : "这 CODESYS Edge Gateway 是一个扩展 CODESYS 连接的网关 CODESYS Automation Server 和 CODESYS 本地网络中的控制器。 CODESYS Edge Gateway for Linux CODESYS Edge Gateway for Windows...", 
"body" : "这 CODESYS Edge Gateway 是一个扩展 CODESYS 连接的网关 CODESYS Automation Server 和 CODESYS 本地网络中的控制器。 CODESYS Edge Gateway for Linux CODESYS Edge Gateway for Windows " }, 
{ "title" : "基于 Linux 的运行时系统 ", 
"url" : "_rtsl_linux_runtime_systems.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "入门 ", 
"url" : "_rtsl_first_steps.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 ", 
"snippet" : "在本章中，您将学习如何使用调试设备 CODESYS Control SL 运行时，从小规模开始 CODESYS 应用程序，并对控制器进行许可。...", 
"body" : "在本章中，您将学习如何使用调试设备 CODESYS Control SL 运行时，从小规模开始 CODESYS 应用程序，并对控制器进行许可。 " }, 
{ "title" : "准备 ", 
"url" : "_rtsl_preparation_linux.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 准备 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "控制器 ", 
"url" : "_rtsl_preparation_linux.html#UUID-6cfdd13d-15e9-2ce9-6bfc-ddfaec59e7f5_section-idm234655601003053", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 准备 \/ 控制器 ", 
"snippet" : "要求：控制器上必须安装最新的 Linux 操作系统（例如 Debian 或 Ubuntu），并且必须安装和激活 SSH 服务器。 要检查 SSH 服务器是否处于活动状态，请在控制器上执行以下命令： sudo systemctl status ssh 当 SSH 服务器处于活动状态时，输出应如下所示： ssh.service - OpenBSD Secure Shell server Loaded: loaded (\/lib\/systemd\/system\/ssh.service; enabled; preset: enabled) Active: active (running) since [...", 
"body" : "要求：控制器上必须安装最新的 Linux 操作系统（例如 Debian 或 Ubuntu），并且必须安装和激活 SSH 服务器。 要检查 SSH 服务器是否处于活动状态，请在控制器上执行以下命令： sudo systemctl status ssh 当 SSH 服务器处于活动状态时，输出应如下所示： ssh.service - OpenBSD Secure Shell server \n Loaded: loaded (\/lib\/systemd\/system\/ssh.service; enabled; preset: enabled) \n Active: active (running) since [...] \n Docs: man:sshd(8) \n man:sshd_config(5) \n Main PID: 741 (sshd) \n Tasks: 1 (limit: 18876) \n Memory: 10.4M \n CPU: 12.778s \n CGroup: \/system.slice\/ssh.service \n └─741 \"sshd: \/usr\/sbin\/sshd -D [listener] 0 of 10-100 startups\" 如果未激活 SSH 服务器，则可以使用以下命令永久激活服务器： sudo systemctl enable ssh 。然后检查该服务是否如上所述处于活动状态。 如果你想使用 CODESYS Virtual Control for Linux SL ，则还必须安装以下软件的最新版本： Python3 Docker 或 Podman 有关如何在 Debian 上安装 Docker 的说明，请参阅 在 Debian 上安装 Docker 引擎 。 " }, 
{ "title" : "CODESYS 开发环境 ", 
"url" : "_rtsl_preparation_linux.html#UUID-6cfdd13d-15e9-2ce9-6bfc-ddfaec59e7f5_section-idm234655602655537", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 准备 \/ CODESYS 开发环境 ", 
"snippet" : "使用 CODESYS Installer 安装最新版本的 CODESYS Development System 还有 CODESYS 要在其中使用运行时系统的控制器的软件包。 你至少需要以下软件包： l CODESYS Control SL Deploy Tool CODESYS Control 代表 ，例如 CODESYS Control for Linux ARM ....", 
"body" : "使用 CODESYS Installer 安装最新版本的 CODESYS Development System 还有 CODESYS 要在其中使用运行时系统的控制器的软件包。 你至少需要以下软件包： l CODESYS Control SL Deploy Tool CODESYS Control 代表 ，例如 CODESYS Control for Linux ARM . " }, 
{ "title" : "正在安装 CODESYS Control for <device> SL 打包进去 CODESYS ", 
"url" : "_rtsl_preparation_linux.html#UUID-6cfdd13d-15e9-2ce9-6bfc-ddfaec59e7f5_section-idm43465561410290", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 准备 \/ 正在安装 CODESYS Control for <device> SL 打包进去 CODESYS ", 
"snippet" : "启动 CODESYS Development System 。 点击 工具 → CODESYS 安装程序 。 这个 CODESYS 安装程序 对话框打开。 在下面 附加组件 ，点击 浏览 。 选择运行时产品的软件包。 软件包已安装：运行时包、库、设备描述和示例项目存储在开发系统中。 根据产品的不同，运行时系统包在  ..\\user\\<user name>\\CODESYS Control for <device> 文件夹中以 Debian 或 IPK 运行时系统文件的形式提供。...", 
"body" : "启动 CODESYS Development System 。 点击 工具 → CODESYS 安装程序 。 这个 CODESYS 安装程序 对话框打开。 在下面 附加组件 ，点击 浏览 。 选择运行时产品的软件包。 软件包已安装：运行时包、库、设备描述和示例项目存储在开发系统中。 根据产品的不同，运行时系统包在  ..\\user\\<user name>\\CODESYS Control for <device> 文件夹中以 Debian 或 IPK 运行时系统文件的形式提供。 " }, 
{ "title" : "安装操作系统 ", 
"url" : "_rtsl_linux_install_operating_system.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 准备 \/ 安装操作系统 ", 
"snippet" : "为了安装 CODESYS Control for <device> SL 在您的设备或硬件上，您需要一个 Linux 操作系统。 注意制造商特定的说明。 根据厂商主页的说明，在设备的存储卡上安装Linux操作系统。 操作系统安装在存储卡上。 使用存储卡启动设备。 操作系统正在运行并可以使用。...", 
"body" : "为了安装 CODESYS Control for <device> SL 在您的设备或硬件上，您需要一个 Linux 操作系统。 注意制造商特定的说明。 根据厂商主页的说明，在设备的存储卡上安装Linux操作系统。 操作系统安装在存储卡上。 使用存储卡启动设备。 操作系统正在运行并可以使用。 " }, 
{ "title" : "特定于设备的设置 ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm4599163518809633054177648631", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 准备 \/ 安装操作系统 \/ 特定于设备的设置 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "BeagleBone ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417852438", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 准备 \/ 安装操作系统 \/ 特定于设备的设置 \/ BeagleBone ", 
"snippet" : "如果 BeagleBone 通过 USB 电缆直接连接到您的本地系统，则默认 IP 地址为 192.168.7.2 ....", 
"body" : "如果 BeagleBone 通过 USB 电缆直接连接到您的本地系统，则默认 IP 地址为 192.168.7.2 . " }, 
{ "title" : "PFC100\/200 ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417882662", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 准备 \/ 安装操作系统 \/ 特定于设备的设置 \/ PFC100\/200 ", 
"snippet" : "确保 WAGO 控制器已通电并连接到您的网络。连接控制器和控制器的网线 CODESYS 工程平台必须插入X1插座。 X2 插座用于现场总线。 使用以太网现场总线时，必须将 PFC100\/200 的以太网接口设置为“分离”。在浏览器中输入设备的 IP 地址。 设备的“基于 Web 的管理”页面打开。 点击 联网 → TCP-IP 菜单命令。 如果系统提示您提供用户登录数据，请输入用户名 admin 和密码 wago . 在 开关配置 , 选择 分开的 选项并单击 提交 确认。 关闭浏览器。 关于基于 Web 的管理的注意事项： 在当前版本的 CODESYS Control for PFC100\/...", 
"body" : "确保 WAGO 控制器已通电并连接到您的网络。连接控制器和控制器的网线 CODESYS 工程平台必须插入X1插座。 X2 插座用于现场总线。 使用以太网现场总线时，必须将 PFC100\/200 的以太网接口设置为“分离”。在浏览器中输入设备的 IP 地址。 设备的“基于 Web 的管理”页面打开。 点击 联网 → TCP-IP 菜单命令。 如果系统提示您提供用户登录数据，请输入用户名 admin 和密码 wago . 在 开关配置 , 选择 分开的 选项并单击 提交 确认。 关闭浏览器。 关于基于 Web 的管理的注意事项： 在当前版本的 CODESYS Control for PFC100\/200 （菜单项：“大容量存储”）。 中的许可信息 信息 → 控制器详情 → 许可证信息 菜单项指的是预安装的 WAGO 控制器，而不是 CODESYS Control for PFC100\/200 。 防火墙设置（ PLC运行时 和 PLC WebVisu ) 也指预装的 WAGO 控制器，而不是 CODESYS Control for PFC100\/200 . 如果防火墙应该配置为 CODESYS Control for PFC100\/200 , 然后可以使用“用户过滤器”进行手动配置。 有关网络适配器的信息： 对于基于以太网的现场总线，运行时自动使用第二个网络接口（“X2”或“br1”）。所用网络接口的以太网适配器和 EtherCAT 配置器中的设置被覆盖。 " }, 
{ "title" : "Raspberry Pi ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417928746", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 准备 \/ 安装操作系统 \/ 特定于设备的设置 \/ Raspberry Pi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "配置树莓派 ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm41652708964375", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 准备 \/ 安装操作系统 \/ 特定于设备的设置 \/ Raspberry Pi \/ 配置树莓派 ", 
"snippet" : "执行 sudo raspi-config 在控制台或通过 SSH 命令（例如，使用 Putty 工具）。 注意：从 Debian 版本 8（“Jessie”）开始，还有一个具有相同设置的图形配置界面。 配置工具启动。 选择 1 Expand Filesystem 命令。 可选的： 选择 8 Advanced Options 命令并为 Raspberry Pi 指定一个唯一的名称。 可选的： 选择 5 Enable Camera 命令。 相机正在运行。 退出配置工具并重新启动。...", 
"body" : "执行 sudo raspi-config 在控制台或通过 SSH 命令（例如，使用 Putty 工具）。 注意：从 Debian 版本 8（“Jessie”）开始，还有一个具有相同设置的图形配置界面。 配置工具启动。 选择 1 Expand Filesystem 命令。 可选的： 选择 8 Advanced Options 命令并为 Raspberry Pi 指定一个唯一的名称。 可选的： 选择 5 Enable Camera 命令。 相机正在运行。 退出配置工具并重新启动。 " }, 
{ "title" : "激活 I²C、SPI 和 1-Wire 外设接口 ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417928748", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 准备 \/ 安装操作系统 \/ 特定于设备的设置 \/ Raspberry Pi \/ 激活 I²C、SPI 和 1-Wire 外设接口 ", 
"snippet" : "编辑 \/boot\/config.txt 使用文本编辑器创建文件（例如，使用 sudo nano \/boot\/config.txt ).注意权限。 检查您的配置并在必要时进行调整。 包含以下行（并且未注释掉 # ): dtparam=i2c_arm=on dtparam=spi=on dtoverlay=w1-gpio-pullup,pullup=1 注：I²C、SPI 和 1-Wire 外设接口是可选的。...", 
"body" : "编辑 \/boot\/config.txt 使用文本编辑器创建文件（例如，使用 sudo nano \/boot\/config.txt ).注意权限。 检查您的配置并在必要时进行调整。 包含以下行（并且未注释掉 # ): dtparam=i2c_arm=on\ndtparam=spi=on\ndtoverlay=w1-gpio-pullup,pullup=1 注：I²C、SPI 和 1-Wire 外设接口是可选的。 " }, 
{ "title" : "启动相机 ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm46610835857494", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 准备 \/ 安装操作系统 \/ 特定于设备的设置 \/ Raspberry Pi \/ 启动相机 ", 
"snippet" : "执行 sudo raspi-config 在控制台或通过 SSH 命令（例如，使用 Putty 工具）。 选择 5 Enable Camera 命令。 执行以下命令： sudo apt-get update sudo apt-get dist-upgrade sudo rpi-update git clone https:\/\/github.com\/silvanmelchior\/RPi_Cam_Web_Interface.git cd RPi_Cam_Web_Interface chmod u+x RPi_Cam_Web_Interface_Installer.sh .\/RPi_Cam_Web_...", 
"body" : "执行 sudo raspi-config 在控制台或通过 SSH 命令（例如，使用 Putty 工具）。 选择 5 Enable Camera 命令。 执行以下命令： sudo apt-get update\nsudo apt-get dist-upgrade\nsudo rpi-update\ngit clone https:\/\/github.com\/silvanmelchior\/RPi_Cam_Web_Interface.git\ncd RPi_Cam_Web_Interface\nchmod u+x RPi_Cam_Web_Interface_Installer.sh\n.\/RPi_Cam_Web_Interface_Installer.sh install 启动网络浏览器并打开 http:\/\/<network address> . 如果安装成功，RPi Cam Control 用户界面将加载，您可以使用相机。 " }, 
{ "title" : "建立连接 ", 
"url" : "_rtsl_establish_connection_linux.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 建立连接 ", 
"snippet" : "要求：操作系统已安装在控制器上。如果不是这种情况，请按照中的步骤操作 安装操作系统 章节。 以下说明描述如何确定 Linux 设备的网络地址，以便将部署工具连接到该设备。...", 
"body" : "要求：操作系统已安装在控制器上。如果不是这种情况，请按照中的步骤操作 安装操作系统 章节。 以下说明描述如何确定 Linux 设备的网络地址，以便将部署工具连接到该设备。 " }, 
{ "title" : "检测网络地址 ", 
"url" : "_rtsl_establish_connection_linux.html#UUID-8282f374-6dd3-23b6-eb03-311464e44f1b_section-idm43466295058734", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 建立连接 \/ 检测网络地址 ", 
"snippet" : "使用检测网络地址 CODESYS 通过网络 开始 CODESYS 。 点击 工具 → 部署控制 SL 命令。 这个 沟通 视图打开。 在 Port <port> 旁边，单击 Scan 按钮。 这个 可用设备 对话框列出了网络中可用设备的 IP 地址。 识别您的设备。 使用设备检测网络地址 要求：您的设备有键盘、鼠标和显示器的连接。 登录。 打开控制台并执行 ip a s 命令。 返回网络地址。 使用 Windows 通过网络检测网络地址 要求：您的设备在网络中有一个已知且唯一的名称（例如：“BeagleBoneBlack”）。 打开 Windows 命令提示符。 执行 ping 命令显示设备名...", 
"body" : "使用检测网络地址 CODESYS 通过网络 开始 CODESYS 。 点击 工具 → 部署控制 SL 命令。 这个 沟通 视图打开。 在 Port <port> 旁边，单击 Scan 按钮。 这个 可用设备 对话框列出了网络中可用设备的 IP 地址。 识别您的设备。 使用设备检测网络地址 要求：您的设备有键盘、鼠标和显示器的连接。 登录。 打开控制台并执行 ip a s 命令。 返回网络地址。 使用 Windows 通过网络检测网络地址 要求：您的设备在网络中有一个已知且唯一的名称（例如：“BeagleBoneBlack”）。 打开 Windows 命令提示符。 执行 ping 命令显示设备名称（默认：BeagleBoneBlack）。 返回网络地址。 下一步是在控制器上安装运行时系统。 " }, 
{ "title" : "连接到目标系统 ", 
"url" : "_rtsl_establish_connection_linux.html#UUID-8282f374-6dd3-23b6-eb03-311464e44f1b_section-idm43466297829590", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 建立连接 \/ 连接到目标系统 ", 
"snippet" : "与目标系统的连接是后续安装镜像和软件包以及创建和管理实例的必要条件。 点击 工具 → 部署控制 SL 命令。 这个 部署控制 SL 对象打开。 在 沟通 选项卡上，配置与目标设备的连接设置。指定目标系统的 IP 地址或先单击 扫描 按钮显示网络上所有可用的 IP 地址。然后指定端口。 支持以下方法登录目标系统： 凭证：用户名和密码 基于密钥的身份验证。有关更多信息，请参阅： 使用公钥认证连接...", 
"body" : "与目标系统的连接是后续安装镜像和软件包以及创建和管理实例的必要条件。 点击 工具 → 部署控制 SL 命令。 这个 部署控制 SL 对象打开。 在 沟通 选项卡上，配置与目标设备的连接设置。指定目标系统的 IP 地址或先单击 扫描 按钮显示网络上所有可用的 IP 地址。然后指定端口。 支持以下方法登录目标系统： 凭证：用户名和密码 基于密钥的身份验证。有关更多信息，请参阅： 使用公钥认证连接" }, 
{ "title" : "设备的默认凭证 ", 
"url" : "_rtsl_establish_connection_linux.html#UUID-8282f374-6dd3-23b6-eb03-311464e44f1b_section-idm43466298221944", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 建立连接 \/ 设备的默认凭证 ", 
"snippet" : "此处列出了默认凭证。如果您遇到问题，请查看制造商的主页以获取相关设备的证书。 用户 密码 树莓派 pi raspberry BeagleBone root 空白 IOT2000 已配置的设备凭证 PFC100\/200 root wago PLCnext admin 印在控制器上 WAGO TP600 root wago empc-a-imx6 已配置的设备凭证...", 
"body" : "此处列出了默认凭证。如果您遇到问题，请查看制造商的主页以获取相关设备的证书。 用户 密码 树莓派 pi raspberry BeagleBone root 空白 IOT2000 已配置的设备凭证 PFC100\/200 root wago PLCnext admin 印在控制器上 WAGO TP600 root wago empc-a-imx6 已配置的设备凭证 " }, 
{ "title" : "在控制器上安装运行时 ", 
"url" : "_rtsl_install_runtime_on_controller.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 在控制器上安装运行时 ", 
"snippet" : "要求： 这个 工具 → 部署控制 SL 命令已执行，与设备的连接已建立。如果不是这种情况，请按照中的步骤操作 建立连接 章节。 所需控制器的插件（示例： CODESYS Control for Linux ARM64 ) 安装在 CODESYS Development System 。...", 
"body" : "要求： 这个 工具 → 部署控制 SL 命令已执行，与设备的连接已建立。如果不是这种情况，请按照中的步骤操作 建立连接 章节。 所需控制器的插件（示例： CODESYS Control for Linux ARM64 ) 安装在 CODESYS Development System 。 " }, 
{ "title" : "基于封装的控制器 ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm234664620258912", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 在控制器上安装运行时 \/ 基于封装的控制器 ", 
"snippet" : "以下说明描述了如何在 Linux 设备上安装运行时系统。 打开 部署 选项卡。 在 产品 列表框中，选择所需的产品。 在 版本 列表框中，选择所需的版本。 点击 安装 按钮。 选定的运行时系统已安装在设备上。控制器会自动重启。不需要手动重启。 要卸载软件包，请按以下步骤操作： 在 已安装的软件包 部分，选择相应的条目。 如果控制器正在运行，请将其停止，然后单击 按钮。 在下一个对话框中，单击 是的 。 该软件包已卸载。 通过测试示例项目来验证安装，该示例项目包含在 CODESYS 包裹。...", 
"body" : "以下说明描述了如何在 Linux 设备上安装运行时系统。 打开 部署 选项卡。 在 产品 列表框中，选择所需的产品。 在 版本 列表框中，选择所需的版本。 点击 安装 按钮。 选定的运行时系统已安装在设备上。控制器会自动重启。不需要手动重启。 要卸载软件包，请按以下步骤操作： 在 已安装的软件包 部分，选择相应的条目。 如果控制器正在运行，请将其停止，然后单击 按钮。 在下一个对话框中，单击 是的 。 该软件包已卸载。 通过测试示例项目来验证安装，该示例项目包含在 CODESYS 包裹。 " }, 
{ "title" : "基于容器的控制器 ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm234664621921259", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 在控制器上安装运行时 \/ 基于容器的控制器 ", 
"snippet" : "以下步骤向您展示如何管理镜像和实例。...", 
"body" : "以下步骤向您展示如何管理镜像和实例。 " }, 
{ "title" : "管理镜像 ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm43466462476384", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 在控制器上安装运行时 \/ 基于容器的控制器 \/ 管理镜像 ", 
"snippet" : "要配置虚拟产品（例如，运行时实例或网关实例），目标设备上必须存在相应的映像。 When installing CODESYS Virtual Control for Linux SL , images are copied to the C:\\Users\\<user>\\CODESYS Virtual Control for Linux SL\\Delivery\\ directory as an archive with the extension .tar.gz . Installing an image 打开 部署 选项卡。 在 产品 列表框中，选择所需的虚拟产品。 在 版本 列表框中，选择所...", 
"body" : "要配置虚拟产品（例如，运行时实例或网关实例），目标设备上必须存在相应的映像。 When installing CODESYS Virtual Control for Linux SL , images are copied to the C:\\Users\\<user>\\CODESYS Virtual Control for Linux SL\\Delivery\\ directory as an archive with the extension .tar.gz . Installing an image 打开 部署 选项卡。 在 产品 列表框中，选择所需的虚拟产品。 在 版本 列表框中，选择所需的版本。 点击 安装 按钮。 图像被传输到目标系统并列在 已安装的映像 部分。 与非虚拟产品相比，没有自动启动。对于虚拟产品，必须首先在上创建实例 操作 选项卡。 从目标系统中删除镜像 在 部署 选项卡，在 管理镜像 区域，选择相应的图像并单击 按钮，然后选择 删除 命令。 当镜像被实例使用时，无法将其删除。 " }, 
{ "title" : "管理虚拟实例 ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm43466462511166", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 在控制器上安装运行时 \/ 基于容器的控制器 \/ 管理虚拟实例 ", 
"snippet" : "目标系统上的实例在 操作 选项卡。 配置的某些值无法更改。 无法更改正在运行的实例的配置。 创建和配置新实例 点击 按钮。 这个 添加新实例 对话框打开。 在 姓名 ，请指定一个唯一的名称。名称只能由字母数字字符和字符 .-_ 。但是，角色 .-_ 一定不能从头开始。 可选：在 筛选 列表框中，选择图像的类型（例如： 运行时系统 或者 网关 ）。 可用图像列表将缩减为所选类型的图像。 然后选择相应的 图片 。然后点击 好吧 。 新实例显示在 VPLC 部分。 选择实例来配置新创建的实例。所选实例的设置显示在右侧 设置 部分。 在本节中，您可以查看和编辑此实例的所有设置。 有关更多信息，请参阅：...", 
"body" : "目标系统上的实例在 操作 选项卡。 配置的某些值无法更改。 无法更改正在运行的实例的配置。 创建和配置新实例 点击 按钮。 这个 添加新实例 对话框打开。 在 姓名 ，请指定一个唯一的名称。名称只能由字母数字字符和字符 .-_ 。但是，角色 .-_ 一定不能从头开始。 可选：在 筛选 列表框中，选择图像的类型（例如： 运行时系统 或者 网关 ）。 可用图像列表将缩减为所选类型的图像。 然后选择相应的 图片 。然后点击 好吧 。 新实例显示在 VPLC 部分。 选择实例来配置新创建的实例。所选实例的设置显示在右侧 设置 部分。 在本节中，您可以查看和编辑此实例的所有设置。 有关更多信息，请参阅： 配置： 删除实例 注意：无法删除已启动的实例。 在 操作 选项卡，选择实例。 点击 按钮，然后选择 删除选定内容 命令。 所选实例、该实例的配置和启动项目将被删除。 这个 清除 命令停止并删除所有实例、配置和任何 CODESYS 目标设备上存在的图像。 " }, 
{ "title" : "启动运行时系统 ", 
"url" : "_rtsl_start_runtime.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 启动运行时系统 ", 
"snippet" : "笔记 : 必须在您的 PC 上安装有效许可证才能运行运行时系统。如果没有，则控制器将以功能齐全但有时间限制的演示模式启动。 对于运行时系统，这些是设备许可证。您在许可证管理器中激活这些许可证。 有关详细信息，请参阅： 产品许可 点击 工具 → 部署控制 SL 命令。 这个 部署控制 SL 选项卡打开。 选择 操作 选项卡并选择所需的条目。您只能选择一个条目。 点击 启动选定项 命令。 控制器已启动，列表将刷新以显示新状态。 将网关实例包含在 CODESYS Automation Server ，网关实例可以在维护模式下启动。 如果您正确配置了的实例 CODESYS Virtual Contro...", 
"body" : "笔记 : 必须在您的 PC 上安装有效许可证才能运行运行时系统。如果没有，则控制器将以功能齐全但有时间限制的演示模式启动。 对于运行时系统，这些是设备许可证。您在许可证管理器中激活这些许可证。 有关详细信息，请参阅： 产品许可 点击 工具 → 部署控制 SL 命令。 这个 部署控制 SL 选项卡打开。 选择 操作 选项卡并选择所需的条目。您只能选择一个条目。 点击 启动选定项 命令。 控制器已启动，列表将刷新以显示新状态。 将网关实例包含在 CODESYS Automation Server ，网关实例可以在维护模式下启动。 如果您正确配置了的实例 CODESYS Virtual Control for Linux SL ，那么你现在可以连接到这个实例了。有关更多信息，请参阅： 建立与实例的连接。 " }, 
{ "title" : "下载并启动 CODESYS 控制器上的应用 ", 
"url" : "_rtsl_load_and_start_application.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 下载并启动 CODESYS 控制器上的应用 ", 
"snippet" : "注意事项 CODESYS Virtual Control for Linux SL 要求：存在 “虚拟边缘网关” 的运行实例。为此，请安装当前的镜像 CODESYS Virtual Edge Gateway for Linux ，创建一个新实例，然后启动它。 有关更多信息，请参阅： 在控制器上安装运行时——虚拟控制器 在 CODESYS , 创建一个标准项目：点击 文件 → 新建项目 .在里面 新项目 对话框，选择 标准项目 模板并指定名称和位置。然后在 标准项目 对话框，选择相应的控制器。 在设备树中（ 设备 视图）的新项目，现在有一个控制器条目（ 设备 （...） ), 下面是一个带有 P...", 
"body" : "注意事项 CODESYS Virtual Control for Linux SL 要求：存在 “虚拟边缘网关” 的运行实例。为此，请安装当前的镜像 CODESYS Virtual Edge Gateway for Linux ，创建一个新实例，然后启动它。 有关更多信息，请参阅： 在控制器上安装运行时——虚拟控制器 在 CODESYS , 创建一个标准项目：点击 文件 → 新建项目 .在里面 新项目 对话框，选择 标准项目 模板并指定名称和位置。然后在 标准项目 对话框，选择相应的控制器。 在设备树中（ 设备 视图）的新项目，现在有一个控制器条目（ 设备 （...） ), 下面是一个带有 POU ( PLC_PRG (PRG) 和一个任务 主要任务 调用 PLC_PRG）。 在 PLC_PRG ，编写一个简单的程序（例如，一个计数器）。 PROGRAM PLC_PRG\nVAR\n iCount: INT;\nEND_VAR\n\niCount := iCount+1; 建立与控制器的连接。为此，请使用 通讯设置 设备编辑器的选项卡。您可以通过双击打开它 设备 （...） 设备树中的条目。 通常，网关现在已经处于活动状态。如果不是这样，则检查状态并在必要时明确启动网关。然后，在 沟通 选项卡，单击 扫描网络 命令。 这个 选择设备 对话框打开，显示检测到的设备。如果找不到您的控制器，请确保它已正确安装和启动。 选择检测到的控制器并单击 好的 . 如果找不到控制器，请检查以下内容： 在 通讯设置 选项卡，在 设备 → 选项 菜单，禁用 按目标 ID 过滤网络扫描 选项。 如果您的设备现在显示，那么您有一个不正确的 TargetID .你的组件 SysTargetOEM 可能没有正确加载。 您的设备是否已连接到您的网络？ 默认情况下，通过 UDP 与您的设备进行通信。当您使用这种通信方法时，您的设备必须与您的主机位于同一子网中。两个设备都需要完全相同的配置网络掩码。 在启动时，您可以检查运行时系统消息的网络设置。例如，它们应该如下所示： 1287759127: Cmp=CmpBlkDrvUdp, Class=1, Error=0, Info=6, pszInfo=Network interface: <ipaddress>192.168.101.41<\/ipaddress> <subnetmask>255.255.252.0<\/subnetmask> CODESYS 尝试在此目标系统上进行身份验证并获取通信通道。连接已建立。 点击 在线 → 登录 命令。 确认下载应用程序的对话框打开。 执行下载并启动应用程序。该应用程序在您的设备上处理。 在里面 PLC_PRG 程序，检查计数器是否正在运行。 " }, 
{ "title" : "授权控制器 ", 
"url" : "_rtsl_license_controller_linux.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 授权控制器 ", 
"snippet" : "许可用例 CODESYS Control 运行时产品： 本地许可 经营许可证 CODESYS Control 产品位于设备本身上。 网络许可 经营许可证 CODESYS Control 产品位于网络中的设备上。多个控制器可以联系此中央设备以获取 CODESYS 执照。 这 CODESYS Network License Server 为此需要产品。 当前，只能将网络许可证用于 CODESYS Virtual Control SL 。为此，必须在中配置许可证服务器的 IP 地址 许可证服务器 相应实例中的字段。...", 
"body" : "许可用例 CODESYS Control 运行时产品： 本地许可 经营许可证 CODESYS Control 产品位于设备本身上。 网络许可 经营许可证 CODESYS Control 产品位于网络中的设备上。多个控制器可以联系此中央设备以获取 CODESYS 执照。 这 CODESYS Network License Server 为此需要产品。 当前，只能将网络许可证用于 CODESYS Virtual Control SL 。为此，必须在中配置许可证服务器的 IP 地址 许可证服务器 相应实例中的字段。 " }, 
{ "title" : "获取许可证 ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234389354567343", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 授权控制器 \/ 获取许可证 ", 
"snippet" : "您可以下载 CODESYS Control 产品来自 CODESYS 国际商店 或者 CODESYS 北美商店 。...", 
"body" : "您可以下载 CODESYS Control 产品来自 CODESYS 国际商店 或者 CODESYS 北美商店 。 " }, 
{ "title" : "本地许可 ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm4588328499004833054120306755", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 授权控制器 \/ 本地许可 ", 
"snippet" : "许可证可以安装在 USB 加密狗或软容器上。使用软容器时，许可证在激活期间锁定到设备，并且只能在此设备上激活或恢复。 要求：开发系统具备 CODESYS Development System 可以访问互联网并连接到设备。 打开 CODESYS . 创建一个标准项目。 更新设备树中的设备。 点击 工具 → 许可证管理器 打开 CODESYS 许可证管理器。 选择 设备 在向导中，然后选择 加密狗 或者 软容器 ，取决于设备。 这 选择设备 对话框打开。 选择相应的设备。 这 许可证管理器 对话框打开。 容器 显示设备上的软容器或安全密钥的名称。在 产品 窗户。 选择 安装许可证 左下角的动作。 ...", 
"body" : "许可证可以安装在 USB 加密狗或软容器上。使用软容器时，许可证在激活期间锁定到设备，并且只能在此设备上激活或恢复。 要求：开发系统具备 CODESYS Development System 可以访问互联网并连接到设备。 打开 CODESYS . 创建一个标准项目。 更新设备树中的设备。 点击 工具 → 许可证管理器 打开 CODESYS 许可证管理器。 选择 设备 在向导中，然后选择 加密狗 或者 软容器 ，取决于设备。 这 选择设备 对话框打开。 选择相应的设备。 这 许可证管理器 对话框打开。 容器 显示设备上的软容器或安全密钥的名称。在 产品 窗户。 选择 安装许可证 左下角的动作。 这 在 <目标设备> <容器名称> 上安装许可证 – 选择操作 向导启动。 选择 激活许可证 选项。指定 工单编号 然后点击 下一个 . 许可证已激活。 " }, 
{ "title" : "网络许可 ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234367072936383", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 授权控制器 \/ 网络许可 ", 
"snippet" : "这 CODESYS Network License Server 产品允许网络许可 CODESYS 产品，例如基于 Linux 的 CODESYS Control SL 运行时来自 CODESYS Store International 。 这 CODESYS Network License Server 基于网络模式下的WIBU CodeMeter运行时，并为基于Web的管理框架“Cockpit”提供支持（参见： https:\/\/cockpit-project.org\/） 。 要使用网络许可证服务器，您首先需要使用 CODESYS Installer 来安装 CODESYS Network ...", 
"body" : "这 CODESYS Network License Server 产品允许网络许可 CODESYS 产品，例如基于 Linux 的 CODESYS Control SL 运行时来自 CODESYS Store International 。 这 CODESYS Network License Server 基于网络模式下的WIBU CodeMeter运行时，并为基于Web的管理框架“Cockpit”提供支持（参见： https:\/\/cockpit-project.org\/） 。 要使用网络许可证服务器，您首先需要使用 CODESYS Installer 来安装 CODESYS Network License Server 附加组件。然后，您可以使用将产品安装到设备上 部署 选项卡。 有关更多信息，请参阅： 选项卡：部署。 " }, 
{ "title" : "网络许可的特点 ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234373994123211", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 授权控制器 \/ 网络许可 \/ 网络许可的特点 ", 
"snippet" : "这 安装 命令安装 CODESYS Network License Server （包括WIBU CodeMeter Runtime）。 如果目标系统上尚未安装 Cockpit 框架，则会显示以下消息： 如果目标系统上已经安装了 Cockpit 框架，则只有 CODESYS 安装 Cockpit 插件即可运行 CODESYS Network License Server 。 这 开始 和 停止 命令被禁用，因为服务不需要停止或启动。 这 开放式驾驶舱 命令在默认浏览器中打开Linux设备的基于Web的管理。...", 
"body" : "这 安装 命令安装 CODESYS Network License Server （包括WIBU CodeMeter Runtime）。 如果目标系统上尚未安装 Cockpit 框架，则会显示以下消息： 如果目标系统上已经安装了 Cockpit 框架，则只有 CODESYS 安装 Cockpit 插件即可运行 CODESYS Network License Server 。 这 开始 和 停止 命令被禁用，因为服务不需要停止或启动。 这 开放式驾驶舱 命令在默认浏览器中打开Linux设备的基于Web的管理。 " }, 
{ "title" : "激活网络许可证 ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234373989651141", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 授权控制器 \/ 网络许可 \/ 激活网络许可证 ", 
"snippet" : "要激活许可证 CODESYS Network License Server ，请按照下列步骤操作： 点击 开放式驾驶舱 按钮在浏览器中打开基于 Web 的管理 为此，请使用正常的 Linux 登录。 点击 CODESYS WBM （1）→ CODESYS 许可 （2）按钮。 复制序列号（1）。 在 序列号 （2）领域。 在 票 字段（3）。 点击 激活票证 按钮。 在页面底部，检查概览以查看所需的文章和产品代码（作为票证的一部分）是否已安装在网络许可证服务器上。 默认情况下， CODESYS Network License Server 软件包创建了一个许可证容器，您可以在其中安装许可证。如果...", 
"body" : "要激活许可证 CODESYS Network License Server ，请按照下列步骤操作： 点击 开放式驾驶舱 按钮在浏览器中打开基于 Web 的管理 为此，请使用正常的 Linux 登录。 点击 CODESYS WBM （1）→ CODESYS 许可 （2）按钮。 复制序列号（1）。 在 序列号 （2）领域。 在 票 字段（3）。 点击 激活票证 按钮。 在页面底部，检查概览以查看所需的文章和产品代码（作为票证的一部分）是否已安装在网络许可证服务器上。 默认情况下， CODESYS Network License Server 软件包创建了一个许可证容器，您可以在其中安装许可证。如果要创建新容器，请按以下步骤操作： 复制 *.WibuCmLif 文件来自 CODESYS Network License Server 到您的计算机（例如，使用 SSH 客户端或 SCP）。 在基于 Web 的管理中，点击 浏览 按钮 创建新容器 部分并选择您之前保存的文件。 点击 创造 按钮。 在页面底部，检查概述以查看新容器是否已创建。 如果出现错误，您可以在 日志 页。 " }, 
{ "title" : "使用网络许可证 ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234460444116218", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 授权控制器 \/ 网络许可 \/ 使用网络许可证 ", 
"snippet" : "为了使控制器能够使用先前配置的许可证服务器，必须在配置中输入该服务器。为此，必须将以下设置添加到 [CmpCodeMeter] 部分 \/etc\/codesyscontrol\/CODESYSControl_User.cfg 文件： EnableNetLicenses=1 LicenseServer.1=<IP1> LicenseServer.2=<IP2>...", 
"body" : "为了使控制器能够使用先前配置的许可证服务器，必须在配置中输入该服务器。为此，必须将以下设置添加到 [CmpCodeMeter] 部分 \/etc\/codesyscontrol\/CODESYSControl_User.cfg 文件： EnableNetLicenses=1\nLicenseServer.1=<IP1>\nLicenseServer.2=<IP2> " }, 
{ "title" : "备份和恢复 CODESYS 许可证 ", 
"url" : "_rtsl_backup_restore_wibu.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 ", 
"snippet" : "这些说明不适用于来自的产品 CODESYS Virtual Control SL 产品系列。...", 
"body" : "这些说明不适用于来自的产品 CODESYS Virtual Control SL 产品系列。 " }, 
{ "title" : "Codemeter 嵌入式许可证 ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4622936815712034049201310732", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 嵌入式许可证 ", 
"snippet" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ 备份和恢复许可证...", 
"body" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ 备份和恢复许可证 " }, 
{ "title" : "备份许可证 ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4641146992569634049209836102", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 嵌入式许可证 \/ 备份许可证 ", 
"snippet" : "建立连接从 CODESYS 到您的控制器。 在设备树中，选择您的控制器并打开 文件 标签。 在右侧窗口中，单击刷新图标 ( ）。 将显示控制器上可用的文件。 在左侧窗口中，选择要存储备份的目录。 在右侧窗口中，选择 cmact_许可证 目录并单击 按钮。 您的许可目录的备份副本将在您的计算机上创建。 检查备份副本是否已成功创建。...", 
"body" : "建立连接从 CODESYS 到您的控制器。 在设备树中，选择您的控制器并打开 文件 标签。 在右侧窗口中，单击刷新图标 ( ）。 将显示控制器上可用的文件。 在左侧窗口中，选择要存储备份的目录。 在右侧窗口中，选择 cmact_许可证 目录并单击 按钮。 您的许可目录的备份副本将在您的计算机上创建。 检查备份副本是否已成功创建。 " }, 
{ "title" : "恢复许可证 ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm451020213344483404921010438", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 嵌入式许可证 \/ 恢复许可证 ", 
"snippet" : "请注意，执行步骤 6 中的以下说明时可能会丢失数据。因此，请仔细阅读这些说明。 建立连接从 CODESYS 到您的控制器。 在设备树中，选择您的控制器并打开 文件 标签。 在右侧窗口中，单击刷新图标 ( ）。 将显示控制器上可用的文件。 在右侧窗口中选择目标目录。这必须是顶级目录（ 存储位置 ： \/ ） 在左侧窗口中，选择之前在计算机上创建的备份副本，然后单击 按钮。 备份副本将复制到您的控制器。 如果同名目录已存在，系统将提示您覆盖其中包含的所有文件。 注意：如果选择“是”，则所有与备份目录中同名的文件都将从现有目录中删除。名称相同并不一定意味着内容相同。因此，请确保您不会意外覆盖所需的文件...", 
"body" : "请注意，执行步骤 6 中的以下说明时可能会丢失数据。因此，请仔细阅读这些说明。 建立连接从 CODESYS 到您的控制器。 在设备树中，选择您的控制器并打开 文件 标签。 在右侧窗口中，单击刷新图标 ( ）。 将显示控制器上可用的文件。 在右侧窗口中选择目标目录。这必须是顶级目录（ 存储位置 ： \/ ） 在左侧窗口中，选择之前在计算机上创建的备份副本，然后单击 按钮。 备份副本将复制到您的控制器。 如果同名目录已存在，系统将提示您覆盖其中包含的所有文件。 注意：如果选择“是”，则所有与备份目录中同名的文件都将从现有目录中删除。名称相同并不一定意味着内容相同。因此，请确保您不会意外覆盖所需的文件。 成功传输备份副本后重新启动控制器。 " }, 
{ "title" : "Codemeter 运行时许可证 ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4592433740225634049202010617", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 运行时许可证 ", 
"snippet" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL...", 
"body" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL " }, 
{ "title" : "备份许可证 ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4582704430054434049230836628", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 运行时许可证 \/ 备份许可证 ", 
"snippet" : "使用 CodeMeter Runtime 时，无需创建备份。...", 
"body" : "使用 CodeMeter Runtime 时，无需创建备份。 " }, 
{ "title" : "恢复许可证 ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4548752769854434049231197546", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 运行时许可证 \/ 恢复许可证 ", 
"snippet" : "恢复许可证 创建许可证请求文件 在 CODESYS ，打开许可证管理器。 在接下来的两个对话框中，选择 设备 和 软质容器 。 建立连接从 CODESYS 到要恢复许可证的控制器。 点击 安装许可证 ， 选择 申请许可证 ，然后单击 下一个 。 如果 软件供应商 字段为空，则可以使用公司代码。“检索公司代码” 部分描述了如何检索公司代码。 选择应安装许可证的容器，然后选择应在计算机上保存许可证请求文件的位置。点击 结束 。 下载许可证更新文件 打开 许可证中心 WebDepot 并指定您要恢复的票证 ID。点击 下一个 。 点击 恢复许可证 。 在右下角，单击 基于文件的许可证传输 。 （如果...", 
"body" : " 恢复许可证 创建许可证请求文件 在 CODESYS ，打开许可证管理器。 在接下来的两个对话框中，选择 设备 和 软质容器 。 建立连接从 CODESYS 到要恢复许可证的控制器。 点击 安装许可证 ， 选择 申请许可证 ，然后单击 下一个 。 如果 软件供应商 字段为空，则可以使用公司代码。“检索公司代码” 部分描述了如何检索公司代码。 选择应安装许可证的容器，然后选择应在计算机上保存许可证请求文件的位置。点击 结束 。 下载许可证更新文件 打开 许可证中心 WebDepot 并指定您要恢复的票证 ID。点击 下一个 。 点击 恢复许可证 。 在右下角，单击 基于文件的许可证传输 。 （如果页面显示 直接许可转让 ，那么您已经位于正确的页面上）。 上传之前创建的许可证请求文件，然后单击 上传请求并立即继续 。 点击 立即下载许可证更新文件 并将文件保存到您的计算机。 安装许可证更新 在 CODESYS ，打开许可证管理器。 在接下来的两个对话框中，选择 设备 和 软质容器 。 建立连接从 CODESYS 到要恢复许可证的控制器。 点击 安装许可证 ， 选择 安装许可证 ，然后单击 下一个 。 选择要安装License的容器，选择之前下载的更新文件（扩展名： .WibuCmRaU ）。 点击 结束 。 几秒钟后，许可证将出现在许可证管理器中。 " }, 
{ "title" : "检索公司代码 ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4641146913656034049243306333", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 运行时许可证 \/ 检索公司代码 ", 
"snippet" : "打开 许可证中心 WebDepot 并指定您要恢复的票证 ID。点击 下一个 。 点击 恢复许可证 。 在右下角，单击 基于文件的许可证传输 。 复制第一点中提供的公司代码。...", 
"body" : "打开 许可证中心 WebDepot 并指定您要恢复的票证 ID。点击 下一个 。 点击 恢复许可证 。 在右下角，单击 基于文件的许可证传输 。 复制第一点中提供的公司代码。 " }, 
{ "title" : "配置和扩展 ", 
"url" : "_rtsl_configure_and_extend.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Control Extension Package ", 
"url" : "_rtsl_extension.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_rtsl_extension_overview.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 概述 ", 
"snippet" : "这 CODESYS Control Extension Package 提供许多不同的选项和接口来将您自己的程序连接到 Linux 运行时系统和 IEC 应用程序。 例如，这允许您控制 PLC、响应来自 PLC 的事件，或将您自己的功能添加到 PLC 或 IEC 应用程序。 有关最重要的接口和功能的概述，请参见下文。注意：“从 PLC 外部”仍然意味着您在 Linux 系统上。这些接口仅在 Linux 系统上可用，在其他设备上不可用，但仍在运行时系统进程之外。 外部事件任务：您可以自己控制 IEC 任务的执行时间（从 PLC 外部）。 事件机制：您可以在 PLC 外部对 IEC 应用程序的事件...", 
"body" : "这 CODESYS Control Extension Package 提供许多不同的选项和接口来将您自己的程序连接到 Linux 运行时系统和 IEC 应用程序。 例如，这允许您控制 PLC、响应来自 PLC 的事件，或将您自己的功能添加到 PLC 或 IEC 应用程序。 有关最重要的接口和功能的概述，请参见下文。注意：“从 PLC 外部”仍然意味着您在 Linux 系统上。这些接口仅在 Linux 系统上可用，在其他设备上不可用，但仍在运行时系统进程之外。 外部事件任务：您可以自己控制 IEC 任务的执行时间（从 PLC 外部）。 事件机制：您可以在 PLC 外部对 IEC 应用程序的事件做出反应（例如：启动\/停止\/异常）。 访问 PLC 外壳：您可以在 PLC 外部访问 PLC shell。 START\/STOP 开关：您可以通过非常简单的方式连接自己的启动\/停止开关（PLC 外部）。 调用外部函数：您可以非常轻松地调用在 PLC 外部实现的您自己的功能。 链接您自己的 I\/O：您可以轻松地将自己的 I\/O（例如：本地）连接到 PLC 外部。 扩展 SDK：您可以非常轻松地在 C 代码中实现自己的函数，然后可以从 IEC 应用程序中使用这些函数。 将数据保留在共享内存中：您可以通过控制器中的 SHM 连接应用程序的保留数据。 有关所采取的安全措施以及与安全相关的通知的概述，请参阅： 安全机制. 这些新机制和接口主要基于基于 Linux 标准资源（文件、套接字或类似资源）的进程分离。 除其他外，使用“unix 域套接字”，因此可以独立于技术（Python、C 等）实现“远程终端”。 连接自己的 C 代码（扩展 SDK）是一个例外，因为这里编译的 C 代码以动态运行时系统组件（共享对象）的形式直接添加到 CODESYS 运行时系统并执行。有关更多信息，请参阅： 扩展 SDK . 示例位于 CODESYS Control Extension Package 的安装目录下。默认为： C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\Examples 。 " }, 
{ "title" : "安全机制 ", 
"url" : "_rtsl_extension_security.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 安全机制 ", 
"snippet" : "扩展 API 提供了全面的选项来影响运行时系统。因此，用户必须注意必要的安全措施。 为了 CODESYS Control Extension Package 4.4.0.0 及更高版本， codesysuser 安装包时创建组。扩展 API 的某些功能要求使用它们的 Linux 用户是 codesysuser 团体。您可以使用以下命令将具有管理员权限的用户添加到该组（例如）： $ sudo adduser $USER codesysuser 这种方法背后的原因是机制使用 \/var\/run\/codesysextension\/ 和 \/var\/opt\/codesysextension\/ 工作目录。这...", 
"body" : "扩展 API 提供了全面的选项来影响运行时系统。因此，用户必须注意必要的安全措施。 为了 CODESYS Control Extension Package 4.4.0.0 及更高版本， codesysuser 安装包时创建组。扩展 API 的某些功能要求使用它们的 Linux 用户是 codesysuser 团体。您可以使用以下命令将具有管理员权限的用户添加到该组（例如）： $ sudo adduser $USER codesysuser 这种方法背后的原因是机制使用 \/var\/run\/codesysextension\/ 和 \/var\/opt\/codesysextension\/ 工作目录。这些有 770 权限并分配给 codesysuser 团体。这确保了未经授权的用户不会干扰运行时系统。 全体成员 codesysuser 组可以影响运行时系统。 以下机制基于 Unix 域套接字 (UDS)： 外部事件任务 事件机制 访问 PLC 外壳 调用外部函数 链接您自己的 I\/O IEC 程序员有必要为这些机制查询相应功能块的错误代码并做出适当的反应（例如：建立或终止连接）。 为了防止工作负载攻击，Unix 对等体 ( ü 尼克斯 D 主 小号 ocets) 需要至少具有与 IEC 任务本身相同或更高的优先级。 UDS 对等点是提供的示例或使用扩展 API 功能的用户创建的程序。 这个优先级不是任务配置中显示的优先级 CODESYS .在Linux系统上可以通过以下方式确定 htop .这是一个与分配的 IEC 任务同名的任务 CODESYS . 这 PLC外壳 需要“匿名用户”。如果启用，则无法跟踪哪个 Linux 用户使用了 PLC shell。 由于进程分离，新的接口 CODESYS Control Extension Package 不提供用户认证的能力（从 CODESYS Development System ）。无法为 IEC 用户分配相应的 Linux 用户或用户名。 因此，在考虑 IEC 应用程序的安全性时，不仅要考虑 IEC 用户，还要考虑和管理 Linux 用户。 只有授权用户才能对运行时系统的 Linux 系统具有管理访问权限。 在使用进程分离的接口的情况下，不能排除数据在系统上未加密传递。这意味着具有系统管理权限的攻击者可以记录它们。 " }, 
{ "title" : "外部事件任务 ", 
"url" : "_rtsl_extension_external_event_task.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 外部事件任务 ", 
"snippet" : "“外部事件任务”机制可用于通过外部事件触发任务。 “Unix Domain Sockets”用于进程分离。根据用户为外部事件选择的名称，相应的套接字文件位于目标系统上： \/var\/run\/codesyscontrolapi\/eventtasks\/<EventName>.sock...", 
"body" : "“外部事件任务”机制可用于通过外部事件触发任务。 “Unix Domain Sockets”用于进程分离。根据用户为外部事件选择的名称，相应的套接字文件位于目标系统上： \/var\/run\/codesyscontrolapi\/eventtasks\/<EventName>.sock " }, 
{ "title" : "创建“外部事件”类型的任务 ", 
"url" : "_rtsl_extension_external_event_task.html#UUID-3c54739a-5fc2-8bad-4ca3-572d189df031_fe5af4cc6c60dcbcc0a8646324da24c1_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 外部事件任务 \/ 创建“外部事件”类型的任务 ", 
"snippet" : "创建外部事件。 在设备树中，选择 任务配置 并在上下文菜单中单击 管理外部事件 (1)。在里面 管理外部事件 对话框 (2)，添加新事件。名称不得包含空格或特殊字符。 → 将任务配置为新的外部事件任务： 在里面 任务配置 列表框中，选择一个任务。在里面 类型 列表框，选择最近可用的 外部的 任务类型 (3)。分配所需的 外部事件 (4)到任务。 → 提供的示例项目 外部事件任务项目 包含上述配置。该任务分配给 MYEVENT1 外部事件和文件 \/var\/opt\/codesyscontrolapi\/eventtasks\/MYEVENT1.sock 是在系统上创建的。 使用“socat”命令行工具...", 
"body" : "创建外部事件。 在设备树中，选择 任务配置 并在上下文菜单中单击 管理外部事件 (1)。在里面 管理外部事件 对话框 (2)，添加新事件。名称不得包含空格或特殊字符。 → 将任务配置为新的外部事件任务： 在里面 任务配置 列表框中，选择一个任务。在里面 类型 列表框，选择最近可用的 外部的 任务类型 (3)。分配所需的 外部事件 (4)到任务。 → 提供的示例项目 外部事件任务项目 包含上述配置。该任务分配给 MYEVENT1 外部事件和文件 \/var\/opt\/codesyscontrolapi\/eventtasks\/MYEVENT1.sock 是在系统上创建的。 使用“socat”命令行工具，您可以非常轻松地操作这个界面，例如使用以下命令： $ socat - UNIX-CLIENT:\/var\/opt\/codesyscontrolapi\/eventtasks\/MYEVENT1.sock 这会在终端窗口中建立一个套接字连接，并允许您将单独的消息发送到套接字。 每条消息都会触发在 PLC 中配置的任务。消息的内容与触发外部事件无关。消息长度指定为 1 个字节。 仅作为 Linux 的成员使用该接口 codesyscontrolapi 用户组 是的 流程分离 是的 " }, 
{ "title" : "事件机制 ", 
"url" : "_rtsl_extension_event_mechanism.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 事件机制 ", 
"snippet" : "运行时系统使用“事件”来传达诸如 PLC 的启动\/停止\/复位、异常发生等事件。使用“事件机制”，可以在触发选定事件后立即接收消息。 转发以下与应用程序相关的事件： EVT_StartDone EVT_StopDone EVT_ResetDone EVT_ExitDone EVT_AllBootprojectsLoaded EVT_CmpApp_Exception EVT_StateChanged EVT_CmpDevice_InteractiveLogin EVT_CmpMgr_LicenseState SysGraphic_EVT_OpenKeyboard SysGraphic_EVT_Cl...", 
"body" : "运行时系统使用“事件”来传达诸如 PLC 的启动\/停止\/复位、异常发生等事件。使用“事件机制”，可以在触发选定事件后立即接收消息。 转发以下与应用程序相关的事件： EVT_StartDone EVT_StopDone EVT_ResetDone EVT_ExitDone EVT_AllBootprojectsLoaded EVT_CmpApp_Exception EVT_StateChanged EVT_CmpDevice_InteractiveLogin EVT_CmpMgr_LicenseState SysGraphic_EVT_OpenKeyboard SysGraphic_EVT_CloseKeyboard 交付的 uds_events.py 样品提供 CODESYS_EventHandler 实现事件注册的类。 这个类需要 eventid 以及 componentid of 要注册的事件，存储在 liEvents 列表： liEvents = {\n \"CmpApp_EVT_StartDone\" : (0x00000002, 0x10000 + 2),\n \"CmpApp_EVT_StopDone\" : (0x00000002, 0x10000 + 4),\n \"CmpApp_EVT_ResetDone\" : (0x00000002, 0x10000 + 6),\n \"CmpApp_EVT_ExitDone\" : (0x00000002, 0x10000 + 15),\n \"CmpApp_EVT_AllBootprojectsLoaded\" : (0x00000002, 0x10000 + 25),\n \"CmpApp_EVT_CmpApp_Exception\" : (0x00000002, 0x00080000 + 28),\n \"CmpApp_EVT_StateChanged\" : (0x00000002,0x10000 + 43),\n \"CmpDevice_EVT_CmpDevice_InteractiveLogin\" : (0x0000000E, 0x00010000+ 1),\n \"CmpMgr_EVT_LicenseState\" : (0x00000001, 0x00010000 + 9),\n \"SysGraphic_EVT_OpenKeyboard\" : (0x00000142, 0x00010000 + 1),\n \"SysGraphic_EVT_CloseKeyboard\" : (0x00000142, 0x00010000 + 2,\n} 此外，必须指定一个回调函数，该函数将在事件发生时调用： def callbackfunction_start(componentid, eventid):\n print(\"Start event occured\") 在里面 Main , 事件注册如下，并指定必要的回调函数： componentid, eventid = liEvents[\"CmpApp_EVT_StartDone\"]\nmyEventHandler_Start = CODESYS_EventHandler(componentid, eventid, callbackfunction_start)\nmyEventHandler_Start.start() 现在回调函数 callbackfunction_start 运行时系统更改为 Start 后立即调用。 底层机制如下图所示： 接口的使用仅作为 Linux 的成员 codesysuser 用户组 是的 流程分离 是的 " }, 
{ "title" : "访问 PLC 外壳 ", 
"url" : "_rtsl_extension_accessing_plc_shell.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 访问 PLC 外壳 ", 
"snippet" : "扩展 API 允许外部访问 PLC 外壳。对于此函数，使用 “Unix 域套接字”，运行时系统使用该套接字接收传入命令并发送相应的响应。相应的套接字文件是 \/var\/opt\/codesyscontrolapi\/plcshell.sock 。 对于此功能，运行时系统需要允许“匿名用户”。允许匿名登录是通过 通讯设置 在设备的 改变沟通政策 对话框（1）： 允许匿名登录 选项 (2)。...", 
"body" : "扩展 API 允许外部访问 PLC 外壳。对于此函数，使用 “Unix 域套接字”，运行时系统使用该套接字接收传入命令并发送相应的响应。相应的套接字文件是 \/var\/opt\/codesyscontrolapi\/plcshell.sock 。 对于此功能，运行时系统需要允许“匿名用户”。允许匿名登录是通过 通讯设置 在设备的 改变沟通政策 对话框（1）： 允许匿名登录 选项 (2)。 " }, 
{ "title" : "例子 ", 
"url" : "_rtsl_extension_accessing_plc_shell.html#UUID-f4776bb8-9dd5-0306-cfe0-2ef01425a6f9_e67b71746d20c0a8646363fbfe36_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 访问 PLC 外壳 \/ 例子 ", 
"snippet" : "要求 运行时系统已允许“匿名用户”。 您已登录 Linux 系统。 您的用户已分配到 codesyscontrolapi 组。 通过终端手动访问 运行以下命令。 $ socat - UNIX-CLIENT:\/var\/opt\/codesyscontrolapi\/plcshell.sock 现在您可以在终端中执行 PLC shell 的命令了 示例脚本 复制 plcshell.py 从提供的示例到 Linux 系统。 运行脚本。 Python 脚本使用 PLC shell 顺序执行一系列命令，并演示了 PLC shell 在 Python 中的使用。 有关更多信息，请参阅： 选项卡：<设备名称> ...", 
"body" : "要求 运行时系统已允许“匿名用户”。 您已登录 Linux 系统。 您的用户已分配到 codesyscontrolapi 组。 通过终端手动访问 运行以下命令。 $ socat - UNIX-CLIENT:\/var\/opt\/codesyscontrolapi\/plcshell.sock 现在您可以在终端中执行 PLC shell 的命令了 示例脚本 复制 plcshell.py 从提供的示例到 Linux 系统。 运行脚本。 Python 脚本使用 PLC shell 顺序执行一系列命令，并演示了 PLC shell 在 Python 中的使用。 有关更多信息，请参阅： 选项卡：<设备名称> PLC 外壳 仅将该接口作为 Linux 用户组的成员使用 codesyscontrolapi 是的 流程分离 是的 " }, 
{ "title" : "START\/STOP 开关 ", 
"url" : "_rtsl_extension_start_stop_switch.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ START\/STOP 开关 ", 
"snippet" : "START\/STOP 开关代表一个物理开关，可用于将 PLC 设置为启动或停止状态。 如果该文件，则此机制处于活动状态 \/var\/opt\/codesyscontrolapi\/runstop.switch 存在。注意：与扩展包的其他功能不同，文件位于 \/var\/opt\/codesyscontrolapi\/ 被查询。此文件不是由运行时系统创建的。如果要使用 START\/STOP 功能，则需要创建该文件。当内容为 runstop.switch 是 \"RUN “，PLC 已启动。当内容不同时，PLC 设置为停止。 循环读取切换文件。 PLC 可以在运行时停止和启动。 如果 runstop.switch...", 
"body" : "START\/STOP 开关代表一个物理开关，可用于将 PLC 设置为启动或停止状态。 如果该文件，则此机制处于活动状态 \/var\/opt\/codesyscontrolapi\/runstop.switch 存在。注意：与扩展包的其他功能不同，文件位于 \/var\/opt\/codesyscontrolapi\/ 被查询。此文件不是由运行时系统创建的。如果要使用 START\/STOP 功能，则需要创建该文件。当内容为 runstop.switch 是 \"RUN “，PLC 已启动。当内容不同时，PLC 设置为停止。 循环读取切换文件。 PLC 可以在运行时停止和启动。 如果 runstop.switch 文件在运行时被删除，然后组件失去其功能并且 PLC 启动。 限制：已在硬件中内置 START\/STOP 开关的基于 Linux 的 SL 产品不支持此机制。其中包括以下产品： CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for WAGO Touch Panel 600 仅作为 Linux 的成员使用该接口 codesyscontrolapi 用户组 是的 流程分离 是的 " }, 
{ "title" : "调用外部函数 ", 
"url" : "_rtsl_extension_calling_external_function.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 调用外部函数 ", 
"snippet" : "此机制可用于通过 Unix 域套接字调用 IEC 应用程序中的外部函数。这允许您创建自己的功能。同时，实现了流程分离。作为 IEC 的一个接口， EXTAPI.UDSExternalFunction 功能块提供在 ExtensionAPI 库。在 Python 中， ExternalFunctionBase 类用于此目的，在提供的示例中提供。 还使用此示例解释了该机制的使用。该示例包含一个 IEC 项目，其中实现了外部函数的调用。该示例还包含被调用函数的实现 myExternalFunction 在Python中。 CODESYS Control Extension Package 安装完成后...", 
"body" : "此机制可用于通过 Unix 域套接字调用 IEC 应用程序中的外部函数。这允许您创建自己的功能。同时，实现了流程分离。作为 IEC 的一个接口， EXTAPI.UDSExternalFunction 功能块提供在 ExtensionAPI 库。在 Python 中， ExternalFunctionBase 类用于此目的，在提供的示例中提供。 还使用此示例解释了该机制的使用。该示例包含一个 IEC 项目，其中实现了外部函数的调用。该示例还包含被调用函数的实现 myExternalFunction 在Python中。 CODESYS Control Extension Package 安装完成后，您可以在以下目录中找到 UDSExternalCallExample.project 示例和 Python 脚本 uds_external_function.py ： C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalCall . " }, 
{ "title" : "示例，IEC 应用 ", 
"url" : "_rtsl_extension_calling_external_function.html#UUID-a1f120f1-d7f7-9c1c-f2c1-f02f0f73aa23_c32c4ba6c484ae1c0a864634bce6538_id_da88391a8bc94ccdc0a864631f91843d", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 调用外部函数 \/ 示例，IEC 应用 ", 
"snippet" : "在里面 UDSExternalCallExample.project 示例项目，一个新的 myExternalFunction 功能块被创建。这扩展了 EXTAPI.UDSExternalFunction 具有输入和输出类型的 FB DINT .其他数据类型也是可以的。一开始要传入Python中要调用的函数的名字。这个地址必须是唯一的。 以下代码用于添加接口外部函数的输入： Result := THIS^.AddParameter('parameterIn1', 'DINT', TO_STRING(diIn1)); 然后使用以下代码调用外部函数： Result := THIS^.Call();...", 
"body" : "在里面 UDSExternalCallExample.project 示例项目，一个新的 myExternalFunction 功能块被创建。这扩展了 EXTAPI.UDSExternalFunction 具有输入和输出类型的 FB DINT .其他数据类型也是可以的。一开始要传入Python中要调用的函数的名字。这个地址必须是唯一的。 以下代码用于添加接口外部函数的输入： Result := THIS^.AddParameter('parameterIn1', 'DINT', TO_STRING(diIn1)); 然后使用以下代码调用外部函数： Result := THIS^.Call(); 以下代码用于查询Python实现的函数的返回值： Result := THIS^.GetParameter('parameterOut', 'DINT', ADR(sValue)); 参数的类型 string .因此，它必须转换为所需的数据类型。 " }, 
{ "title" : "示例，Python 脚本 ", 
"url" : "_rtsl_extension_calling_external_function.html#UUID-a1f120f1-d7f7-9c1c-f2c1-f02f0f73aa23_c32c4ba6c484ae1c0a864634bce6538_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 调用外部函数 \/ 示例，Python 脚本 ", 
"snippet" : "为扩展 API 提供的 Python 示例需要 Python 3.0。 包含的 uds_external_function.py 样品提供 ExternalFunctionBase 类，它为此功能提供与运行时系统的 Unix 域套接字通信。 这 myExternalFunction 示例中实现的类扩展了 ExternalFunctionBase 类。 Call() 函数是必需的，从IEC的机制中调用。输入和输出参数以字符串元组的形式传递。 例子： {'parameterIn1': ('DINT', '11'), 'parameterIn2': ('DINT', '22')} 在示例中， Cal...", 
"body" : "为扩展 API 提供的 Python 示例需要 Python 3.0。 包含的 uds_external_function.py 样品提供 ExternalFunctionBase 类，它为此功能提供与运行时系统的 Unix 域套接字通信。 这 myExternalFunction 示例中实现的类扩展了 ExternalFunctionBase 类。 Call() 函数是必需的，从IEC的机制中调用。输入和输出参数以字符串元组的形式传递。 例子： {'parameterIn1': ('DINT', '11'), 'parameterIn2': ('DINT', '22')} 在示例中， Call() 函数实现了两个输入参数的简单相加： def Call(self, dictParams):\n in1 = int(dictParams['parameterIn1'][1])\n in2 = int(dictParams['parameterIn2'][1])\n\n dictRetParams = {}\n dictRetParams['parameterOut'] = 'DINT', in1 + in2\n\n return dictRetParams 将脚本 uds_external_function.py （安装 CODESYS Control Extension Package 后位于目录 C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalCall 中）复制到目标设备。 运行脚本 uds_external_function.py 。 然后启动 UDSExternalCallExample.project 示例项目位于 CODESYS 。 可以看到项目调用了 myExternalFunction() 添加了Python脚本的函数和两个输入参数。 接口的使用仅作为 Linux 的成员 codesysuser 用户组 是的 流程分离 是的 " }, 
{ "title" : "链接您自己的 I\/O ", 
"url" : "_rtsl_extension_connecting_user_ios.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 链接您自己的 I\/O ", 
"snippet" : "借助此功能，本地 I\/O 可以连接到控制器并在 IEC 应用程序中使用。...", 
"body" : "借助此功能，本地 I\/O 可以连接到控制器并在 IEC 应用程序中使用。 " }, 
{ "title" : "编辑设备描述 ", 
"url" : "_rtsl_extension_connecting_user_ios.html#UUID-13dba825-3390-b677-ab9e-c88d5217ab74_a82230b6c3b57c1c0a86463472f7ec5_id_f93f1df46d57d55ac0a864632a96c684", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 链接您自己的 I\/O \/ 编辑设备描述 ", 
"snippet" : "在提供的示例 UDSIoDrvExample.project 中，根据设备描述创建了两个输入和输出。输入和输出通过 Unix 域套接字连接。您可以在 CODESYS 子目录 CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalIoDrv . 要定义您自己的输入和输出，设备描述文件 SocketUnixIOTemplate.devdesc.xml 必须适应。一个 XML parameter 必须为每个输入和输出定义元素。 ParameterId 在设备描述文件中必须是唯一的。我们建议简单地按升序编号，没有间隙。例如：10...", 
"body" : "在提供的示例 UDSIoDrvExample.project 中，根据设备描述创建了两个输入和输出。输入和输出通过 Unix 域套接字连接。您可以在 CODESYS 子目录 CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalIoDrv . 要定义您自己的输入和输出，设备描述文件 SocketUnixIOTemplate.devdesc.xml 必须适应。一个 XML parameter 必须为每个输入和输出定义元素。 ParameterId 在设备描述文件中必须是唯一的。我们建议简单地按升序编号，没有间隙。例如：1000 1001 1002 等等：输入从 1000 开始编号，输出从 2000 开始编号。 如果修改了设备描述，则必须将其重新安装在设备存储库中，以便在项目中可用。 <Parameter ParameterId=\"1000\" type=\"std:DWORD\">\n <Attributes channel=\"input\"\/>\n <Default\/>\n <Name name=\"local:in1\">\/Namne>\n<\/Parameter> 名称 描述 参数 ID 调用输入或输出的唯一 ID 类型 定义输入或输出的宽度。它是通过指定适当宽的数据类型来完成的，例如 std:BYTE , std:WORD , std:DWORD ， 或者 std:LWORD .其他简单数据类型也是允许的。 属性通道 input 或者 output 姓名 姓名 相应输入或输出的名称 此外，必须分配设备 ID，其定义在 <DeviceIdentification> . 0x0001 8000 到 0x0001 80FF 的范围是为此目的提供的，以避免与现有设备发生冲突。 设备描述和底层 I\/O 驱动程序不应在一个 PLC 下多次实例化，因为模块的顺序不固定。这可能导致 I\/O 驱动程序无法确保分配。 " }, 
{ "title" : "Python 示例 ", 
"url" : "_rtsl_extension_connecting_user_ios.html#UUID-13dba825-3390-b677-ab9e-c88d5217ab74_a82230b6c3b57c1c0a86463472f7ec5_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 链接您自己的 I\/O \/ Python 示例 ", 
"snippet" : "在 Python 示例中 uds_io_driver.py ，接收输出并写入设备的输入。输入参数（IEC输出）作为字符串元组传递（ paramType , paramValue ) 以设备描述的参数ID为索引。 驱动程序可以处理数据类型 USINT , UINT , UDINT ， 和 ULINT .其他数据类型必须转换为合适的数据类型。 例子： （ '2000': ('UDINT', '11'), '2001': ('UDINT', '22')} .输出参数格式相同。 同样对于对等体，“输出”\/输出参数仍然是要由 IEC 应用程序“向外”传输的输出值（例如，写出到真实的 GPIO）。这 UD...", 
"body" : "在 Python 示例中 uds_io_driver.py ，接收输出并写入设备的输入。输入参数（IEC输出）作为字符串元组传递（ paramType , paramValue ) 以设备描述的参数ID为索引。 驱动程序可以处理数据类型 USINT , UINT , UDINT ， 和 ULINT .其他数据类型必须转换为合适的数据类型。 例子： （ '2000': ('UDINT', '11'), '2001': ('UDINT', '22')} .输出参数格式相同。 同样对于对等体，“输出”\/输出参数仍然是要由 IEC 应用程序“向外”传输的输出值（例如，写出到真实的 GPIO）。这 UDS_IODriver_0 示例中实现的类扩展了 ExternalFunctionBase 类。类的名称来源于 UDS_IODriver_ 后跟按升序排列的实例索引。 Call() 函数是必需的，从 IEC 的机制中调用。现在可以在此处评估 IEC 输出并且可以传输 IEC 输入。 接口的使用仅作为 Linux 的成员 codesysuser 用户组 是的 流程分离 是的 " }, 
{ "title" : "将数据保留在共享内存中 ", 
"url" : "_rtsl_extension_retains_in_shared_memory.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 将数据保留在共享内存中 ", 
"snippet" : "某些产品不包括从控制器中的应用程序保留数据的自动连接（由于缺乏普遍有效的存储选项）。但是，运行时系统中存在一种通过共享内存 (SHM) 连接的现有机制，该机制可用于此目的，并具有相应的配置。 例如，可以通过以下方式使用 CODESYS Control SL 产品： CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control for Raspberry Pi CODESYS Control for BeagleBone 版本说明：最低版本 CODE...", 
"body" : "某些产品不包括从控制器中的应用程序保留数据的自动连接（由于缺乏普遍有效的存储选项）。但是，运行时系统中存在一种通过共享内存 (SHM) 连接的现有机制，该机制可用于此目的，并具有相应的配置。 例如，可以通过以下方式使用 CODESYS Control SL 产品： CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control for Raspberry Pi CODESYS Control for BeagleBone 版本说明：最低版本 CODESYS Control SL 产品为 V4.4.0.0 ( CODESYS Control 版本 3.5.17.30) 基本上，“保留”是通过 SHM 通过以下设置启用的 \/etc\/CODESYSControl_User.cfg 在目标设备上： [CmpApp]\n RetainType.Applications=InSHM [CmpRetain]\n Retain.SHM.Size=0x1FFFF ; Total size of remanent memory in bytes\n Retain.SHM.Name=MyRetainMemory ; Optional (Default: \"RetainMemory\") 重新启动后，运行时系统会在下面创建一个配置名称为的共享内存文件 \/dev\/shm .通过映射此文件，可以将内存重定向到任何非易失性文件，例如，通过以下命令： sudo touch \/dev\/shm\/MyRetainMemory\nsudo mount -o bind \/var\/opt\/MyRetainMemory \/dev\/shm\/MyRetainMemory 根据 PLC 应用程序中设置的循环时间循环访问该文件。因此，不应将 SHM 文件重定向到基于闪存的文件系统中的文件，否则存在内存被破坏的风险。 " }, 
{ "title" : "扩展 SDK ", 
"url" : "_rtsl_extension_extension_sdk.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 扩展 SDK ", 
"snippet" : "使用扩展 SDK，您可以在 C 中实现自己的函数并从 IEC 应用程序中调用它们。 对于这种连接，C 代码以单独的动态组件的形式集成到运行时系统中（ shared object ）。 有两种方法包括： 在控制器上准备：动态组件已配置为 CODESYS 运行时系统（一个 shared object 存在并在 Linux 系统上配置）。然后，只需要相应的 IEC 库。 以带有集成动态组件的 IEC 库的形式。 Linux 系统本身不需要准备任何东西。使用 IEC 库时，动态组件会自动添加到 CODESYS 运行时系统和使用。 在这两种情况下，用户都必须能够创建一个 shared object 适用...", 
"body" : "使用扩展 SDK，您可以在 C 中实现自己的函数并从 IEC 应用程序中调用它们。 对于这种连接，C 代码以单独的动态组件的形式集成到运行时系统中（ shared object ）。 有两种方法包括： 在控制器上准备：动态组件已配置为 CODESYS 运行时系统（一个 shared object 存在并在 Linux 系统上配置）。然后，只需要相应的 IEC 库。 以带有集成动态组件的 IEC 库的形式。 Linux 系统本身不需要准备任何东西。使用 IEC 库时，动态组件会自动添加到 CODESYS 运行时系统和使用。 在这两种情况下，用户都必须能够创建一个 shared object 适用于运行时系统的架构（x64\/ARM6\/ARM7\/AARCH64）。扩展SDK支持您创建这种动态组件 (shared object ）。 下面介绍如何为这两种变体创建库和动态组件。 " }, 
{ "title" : "开发环境 ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_3742f1416db55357c0a864630d1ff3cd", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 扩展 SDK \/ 开发环境 ", 
"snippet" : "开发环境 打开 CODESYS 并创建一个新库。 设置库的标题（ 项目信息 , 概括 选项卡）并以相同的名称保存库。 添加所需的功能并将其标记为 外部实施 . 在项目导航器中功能的上下文菜单中，单击 特性 .在 建造 选项卡，选择 外部实施 . 注意：函数必须包含“ _cext “ 在名字里。 现在生成 *c 和 *m4 文件： 点击 构建 → 生成运行时系统文件 . 选择 M4接口文件 和 C 存根文件 . 选择保存位置。...", 
"body" : "开发环境 打开 CODESYS 并创建一个新库。 设置库的标题（ 项目信息 , 概括 选项卡）并以相同的名称保存库。 添加所需的功能并将其标记为 外部实施 . 在项目导航器中功能的上下文菜单中，单击 特性 .在 建造 选项卡，选择 外部实施 . 注意：函数必须包含“ _cext “ 在名字里。 现在生成 *c 和 *m4 文件： 点击 构建 → 生成运行时系统文件 . 选择 M4接口文件 和 C 存根文件 . 选择保存位置。 " }, 
{ "title" : "Linux ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_8bf074606db55357c0a864636bb48d02", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 扩展 SDK \/ Linux ", 
"snippet" : "将 Extension SDK 复制到具有目标系统相应编译环境的 Linux 系统中。 默认情况下，您可以在以下位置找到扩展 SDK： C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\ExtensionSDK . 在以下步骤中，该目录将被称为 <SDK DIR> 。 创建一个新文件夹，您可以在其中创建 C 实现。这个文件夹在下面 <PROJECT DIR> . 导航 <PROJECT DIR> 并运行： $ make -f <SDKDIR>\/makefile ne...", 
"body" : "将 Extension SDK 复制到具有目标系统相应编译环境的 Linux 系统中。 默认情况下，您可以在以下位置找到扩展 SDK： C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\ExtensionSDK . 在以下步骤中，该目录将被称为 <SDK DIR> 。 创建一个新文件夹，您可以在其中创建 C 实现。这个文件夹在下面 <PROJECT DIR> . 导航 <PROJECT DIR> 并运行： $ make -f <SDKDIR>\/makefile newproject 将您在开发环境中创建的 *c 和 *m4 文件复制到 <PROJECT DIR> . 实现 C 中的函数。 创建共享对象： $ make all 这 shared object 生成并位于 <PROJECT DIR>\/out\/libCmpMyTest.so . 因此，您创建了一个动态组件，现在可以通过您的 IEC 库从 IEC 应用程序调用该组件。有关构建过程的详细信息（ make ) 也可以在 makefile 和 README file 在扩展 SDK 中。 现在决定使用以下两种方法之一来包含该组件： " }, 
{ "title" : "包括动态组件 ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_section-idm234821879525116", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 扩展 SDK \/ 包括动态组件 ", 
"snippet" : "您可以通过以下选项来包含该组件：...", 
"body" : "您可以通过以下选项来包含该组件： " }, 
{ "title" : "在目标设备上包含动态组件 ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_e85c7db98c25e844c0a864634a8e2492", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 扩展 SDK \/ 包括动态组件 \/ 在目标设备上包含动态组件 ", 
"snippet" : "此方法允许您将以前在 C 中创建的共享对象包含到运行时系统中。用户不需要额外的系统权限，并且可以使用熟悉的方法将库推广到设备。 将上面创建的共享对象复制到运行时系统。 将共享对象复制到 \/usr\/lib\/ 或系统在其中找到库的等效库目录。 停止运行时系统（例如： $ sudo \/etc\/init.d\/codesyscontrol stop ) 打开 \/etc\/CODESYSControl_User.cfg 具有管理员权限： $ sudo nano \/etc\/CODESYSControl_User.cfg 在里面 [ComponentManager] 部分，添加创建的共享对象： [Compone...", 
"body" : "此方法允许您将以前在 C 中创建的共享对象包含到运行时系统中。用户不需要额外的系统权限，并且可以使用熟悉的方法将库推广到设备。 将上面创建的共享对象复制到运行时系统。 将共享对象复制到 \/usr\/lib\/ 或系统在其中找到库的等效库目录。 停止运行时系统（例如： $ sudo \/etc\/init.d\/codesyscontrol stop ) 打开 \/etc\/CODESYSControl_User.cfg 具有管理员权限： $ sudo nano \/etc\/CODESYSControl_User.cfg 在里面 [ComponentManager] 部分，添加创建的共享对象： [ComponentManager]\nComponent.1=CmpFirstTest\nComponent.2=CmpSomeOtherComponent\n... 注：编号为增量编号，不得与现有组件冲突。 启动运行时系统： $ sudo \/etc\/init.d\/codesyscontrol start 现在您可以检查组件是否已加载： $ cat \/tmp\/codesyscontrol.log " }, 
{ "title" : "在 IEC 库中包含动态组件 ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_4cf431216db55357c0a86463621d9489", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 扩展 SDK \/ 包括动态组件 \/ 在 IEC 库中包含动态组件 ", 
"snippet" : "使用“C 代码集成”功能将动态组件添加到 IEC 库。有关详细信息，请参阅 C 代码集成 在一般帮助中。 打开 IEC 库。 在 POU , 添加一个 C 实现的库 目的。 在这个对象中，添加一个 设备的目标文件 ： 选择之前构建的动态组件（文件）并添加它。 指定合适的组件名称。 选择合适的设备。 现在，当将此库与所选设备一起使用时，动态组件会自动添加到运行时系统中，并且可以使用库的 POU 调用。...", 
"body" : "使用“C 代码集成”功能将动态组件添加到 IEC 库。有关详细信息，请参阅 C 代码集成 在一般帮助中。 打开 IEC 库。 在 POU , 添加一个 C 实现的库 目的。 在这个对象中，添加一个 设备的目标文件 ： 选择之前构建的动态组件（文件）并添加它。 指定合适的组件名称。 选择合适的设备。 现在，当将此库与所选设备一起使用时，动态组件会自动添加到运行时系统中，并且可以使用库的 POU 调用。 " }, 
{ "title" : "其他 ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Extension Package \/ 扩展 SDK \/ 其他 ", 
"snippet" : "限制： 使用扩展 SDK，只能包含 C 代码。 调试器不能用于检查或调试 C 代码（例如，在编程系统中）。 C 代码不能与运行时系统或 IEC 应用程序“交互”。这意味着： 无法自动访问 IEC 应用程序的变量。 无法访问运行时系统的功能。但是，通过将变量传递给用 C 代码实现的函数，当然可以访问 IEC 应用程序的变量 by reference （例如，通过 POINTER ）。 接口的使用仅作为 Linux 的成员 codesysuser 用户组 不 流程分离 不...", 
"body" : "限制： 使用扩展 SDK，只能包含 C 代码。 调试器不能用于检查或调试 C 代码（例如，在编程系统中）。 C 代码不能与运行时系统或 IEC 应用程序“交互”。这意味着： 无法自动访问 IEC 应用程序的变量。 无法访问运行时系统的功能。但是，通过将变量传递给用 C 代码实现的函数，当然可以访问 IEC 应用程序的变量 by reference （例如，通过 POINTER ）。 接口的使用仅作为 Linux 的成员 codesysuser 用户组 不 流程分离 不 " }, 
{ "title" : "产品特定配置 ", 
"url" : "_rtsl_product_configuration_linux.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "BeagleBone ", 
"url" : "_rtsl_linux_beaglebone.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ BeagleBone ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "配置 CAN\/串行 Cape ", 
"url" : "_rtsl_linux_rbp_can_capes.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ BeagleBone \/ 配置 CAN\/串行 Cape ", 
"snippet" : "各种海角（扩展板）可用于 BeagleBone Black 以扩展功能范围。 Cape 已插入扩展槽 BeagleBone Black 并且本身提供了一个额外的扩展槽。 A BeagleBone Black 最多可以扩展四个斗篷。 本章介绍了一般配置 BeagleBone Black 它通过 CAN 协议进行扩展。 扩展 cape 的要求是内核版本 4.1。其他内核版本的描述可能略有不同。 您可以在命令行中使用以下命令来确定内核版本（例如，通过 SSH 连接）： uname -a uname -r...", 
"body" : "各种海角（扩展板）可用于 BeagleBone Black 以扩展功能范围。 Cape 已插入扩展槽 BeagleBone Black 并且本身提供了一个额外的扩展槽。 A BeagleBone Black 最多可以扩展四个斗篷。 本章介绍了一般配置 BeagleBone Black 它通过 CAN 协议进行扩展。 扩展 cape 的要求是内核版本 4.1。其他内核版本的描述可能略有不同。 您可以在命令行中使用以下命令来确定内核版本（例如，通过 SSH 连接）： uname -a uname -r " }, 
{ "title" : "安装斗篷 ", 
"url" : "_rtsl_linux_rbp_installing_capes.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ BeagleBone \/ 配置 CAN\/串行 Cape \/ 安装斗篷 ", 
"snippet" : "将匹配的斗篷安装在 BeagleBone Black 如 Cape 用户手册中所述。 供电给 BeagleBone Black 。 使用以下命令检查连接： cat \/sys\/devices\/platform\/bone_capemgr\/slots 例如，您会得到以下输出： Mon 0: P---L- 0 cape-CBB-Serial,r01,Logic Supply,cape-CBB-Serial 1: PF---- -1 2: PF---- -1 3: PF---- -1 或者，您也可以按如下方式检查内核显示： dmesg | grep cape 输出应如下所示： ... [3.719868...", 
"body" : "将匹配的斗篷安装在 BeagleBone Black 如 Cape 用户手册中所述。 供电给 BeagleBone Black 。 使用以下命令检查连接： cat \/sys\/devices\/platform\/bone_capemgr\/slots 例如，您会得到以下输出： Mon\n0: P---L- 0 cape-CBB-Serial,r01,Logic Supply,cape-CBB-Serial\n1: PF---- -1\n2: PF---- -1\n3: PF---- -1 或者，您也可以按如下方式检查内核显示： dmesg | grep cape 输出应如下所示： ...\n\n[3.719868] bone_capemgr bone_capemgr: Baseboard: 'A335BNLT,000B,1614BBBK0256'\n[3.719904] bone_capemgr bone_capemgr: compatible-baseboard=ti,beaglebone-black - #slots=4\n[3.762237] bone_capemgr bone_capemgr: slot #0: 'cape-CBB-Serial,r01,Logic Supply,cape-CBB-Serial'\n[3.818178] bone_capemgr bone_capemgr: slot #1: No cape found\n[3.878171] bone_capemgr bone_capemgr: slot #2: No cape found\n[3.938165] bone_capemgr bone_capemgr: slot #3: No cape found\n[3.944194] bone_capemgr bone_capemgr: initialized OK.\n[3.963568] bone_capemgr bone_capemgr: slot #0: dtbo 'cape-CBB-Serial-r01.dtbo' loaded; overlay id #0\n\n... 此输出显示已检测到 cape 并加载了相应的设备树覆盖。 " }, 
{ "title" : "配置和测试 CAN 接口 ", 
"url" : "_rtsl_linux_bbb_configuring_can.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ BeagleBone \/ 配置 CAN\/串行 Cape \/ 配置和测试 CAN 接口 ", 
"snippet" : "测试 CAN 要直接从命令行测试 CAN，您可以对 Debian 软件包使用“can-utils”： 安装 Debian 软件包： sudo apt-get install can-utils 发送 CAN 消息： cansend can0 5A1#ABCDABCD 接收 CAN 报文： candump can0...", 
"body" : "测试 CAN 要直接从命令行测试 CAN，您可以对 Debian 软件包使用“can-utils”： 安装 Debian 软件包： sudo apt-get install can-utils 发送 CAN 消息： cansend can0 5A1#ABCDABCD 接收 CAN 报文： candump can0 " }, 
{ "title" : "配置 CAN ", 
"url" : "_rtsl_linux_bbb_configuring_can.html#UUID-efad06fa-f9d6-75e9-4a70-c5faf6598419_id_c96cb9d2e581efc0a86463263b6289-id-749f3d54d353c531c0a864631cb78ab4", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ BeagleBone \/ 配置 CAN\/串行 Cape \/ 配置和测试 CAN 接口 \/ 配置 CAN ", 
"snippet" : "如果 DCAN0 用于 BeagleBone Black ，那么它与 I2C-2 功能冲突。因此，DCAN1 通常与 P9 引脚 24 (Rx) 和 P9 引脚 26 (Tx) 一起使用。 要求：您已连接到 BeagleBone Black 通过 SSH 客户端，例如使用“Putty”。 要手动配置和测试 CAN，请使用以下命令： sudo modprobe can sudo modprobe can-dev sudo modprobe can-raw 以下命令加载内核模块（可能必须为不同的硬件加载不同的模块）： sudo modprobe c_can_platform 可能必须为不同的硬件加...", 
"body" : "如果 DCAN0 用于 BeagleBone Black ，那么它与 I2C-2 功能冲突。因此，DCAN1 通常与 P9 引脚 24 (Rx) 和 P9 引脚 26 (Tx) 一起使用。 要求：您已连接到 BeagleBone Black 通过 SSH 客户端，例如使用“Putty”。 要手动配置和测试 CAN，请使用以下命令： sudo modprobe can\nsudo modprobe can-dev\nsudo modprobe can-raw 以下命令加载内核模块（可能必须为不同的硬件加载不同的模块）： sudo modprobe c_can_platform 可能必须为不同的硬件加载不同的模块。 将运行 CAN cape 所需的所有驱动程序输入文件“ ..\/etc\/modules ”。 例子： can\ncan-dev\ncan-raw 现在可以使用Linux机制“socketcan”了。默认情况下，这是支持的 CODESYS Control for BeagleBone 。 内核模块会在以下情况下自动加载 BeagleBone Black 已启动。 设置波特率： sudo ip link set can0 up type can bitrate 125000 激活界面： sudo ifconfig can0 up CAN 接口已配置。 " }, 
{ "title" : "配置和测试 UART ", 
"url" : "_rtsl_linux_rbp_configuring_uarts.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ BeagleBone \/ 配置 CAN\/串行 Cape \/ 配置和测试 UART ", 
"snippet" : "测试 UART 在交互式 Python shell 中执行以下 Python 片段，或创建一个扩展名为 .py 的小文本文件并使用 Python 解释器执行它： import serial import time uart2_file='\/dev\/ttyO2' baud=115200 ser = serial.Serial(uart2_file, baud) while True: ser.write(\"Testing\") time.sleep(1) UART2 波特率为 115200 打开并发送 Testing 每秒串。 您现在可以连接串行电缆并检查 PC 上的输出（例如，使用 Putty）...", 
"body" : "测试 UART 在交互式 Python shell 中执行以下 Python 片段，或创建一个扩展名为 .py 的小文本文件并使用 Python 解释器执行它： import serial\nimport time\nuart2_file='\/dev\/ttyO2'\nbaud=115200\nser = serial.Serial(uart2_file, baud)\nwhile True:\n ser.write(\"Testing\")\n time.sleep(1) UART2 波特率为 115200 打开并发送 Testing 每秒串。 您现在可以连接串行电缆并检查 PC 上的输出（例如，使用 Putty）。 " }, 
{ "title" : "配置 UART ", 
"url" : "_rtsl_linux_rbp_configuring_uarts.html#UUID-b5665400-7f51-ce43-e2ec-127a0725936a_id_be9f181d33627c4c0a8646366c6b2ff-id-4c119c87d346da4ec0a86463175a71c5", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ BeagleBone \/ 配置 CAN\/串行 Cape \/ 配置和测试 UART \/ 配置 UART ", 
"snippet" : "此 Cape（UART2 和 UART4）上的串行接口（也称为 UART）可以从 \/dev\/ttyO2 和 \/dev\/ttyO4 设备。 如果您想自己从外部访问串行端口 CODESYS ，然后参考相应的 Linux 文档。 如果你想从中访问 UART CODESYS ，然后在文件中指定 SysCom 配置 CODESYSControl.cfg : [SysCom] Linux.Devicefile=\/dev\/ttyO 可以为配置条目编制索引。 示例： Linux.Devicefile.7=\/dev\/usb0 这创造 \/dev\/usb0 映射到 COM7。...", 
"body" : "此 Cape（UART2 和 UART4）上的串行接口（也称为 UART）可以从 \/dev\/ttyO2 和 \/dev\/ttyO4 设备。 如果您想自己从外部访问串行端口 CODESYS ，然后参考相应的 Linux 文档。 如果你想从中访问 UART CODESYS ，然后在文件中指定 SysCom 配置 CODESYSControl.cfg : [SysCom]\nLinux.Devicefile=\/dev\/ttyO 可以为配置条目编制索引。 示例： Linux.Devicefile.7=\/dev\/usb0 这创造 \/dev\/usb0 映射到 COM7。 " }, 
{ "title" : "已知问题 ", 
"url" : "_rtsl_linux_bbb_problems.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ BeagleBone \/ 配置 CAN\/串行 Cape \/ 已知问题 ", 
"snippet" : "串口 RS485 使用给定 CAN\/Serial cape 的 RS485 时，使用 RS485 收发器时出现问题。由于 Linux 驱动程序无法在发送和接收模式之间来回切换，因此应用程序可能无法按预期工作。 详细说明： BeagleBone Black(OMAP) 的串行驱动程序不支持 RS-485 所需的发送\/接收切换（DE\/RE 或 RTS）。相反，它具有 RS485 模式，该模式使用永久分配的 GPIO 引脚来检查 DE\/RE 线，并且与串行标准驱动程序相比，它具有修改的结构 (serial_rs485 结构)。您必须在相应的 devtty 文件上使用 ioctl 才能将串行驱动程序置...", 
"body" : "串口 RS485 使用给定 CAN\/Serial cape 的 RS485 时，使用 RS485 收发器时出现问题。由于 Linux 驱动程序无法在发送和接收模式之间来回切换，因此应用程序可能无法按预期工作。 详细说明： BeagleBone Black(OMAP) 的串行驱动程序不支持 RS-485 所需的发送\/接收切换（DE\/RE 或 RTS）。相反，它具有 RS485 模式，该模式使用永久分配的 GPIO 引脚来检查 DE\/RE 线，并且与串行标准驱动程序相比，它具有修改的结构 (serial_rs485 结构)。您必须在相应的 devtty 文件上使用 ioctl 才能将串行驱动程序置于 RS-485 模式并告诉它需要使用哪个引脚。此外，您必须注意 GPIO 模式下引脚的多路复用。 " }, 
{ "title" : "使用 GPIO 和模拟输入 ", 
"url" : "_rtsl_linux_bbb_gpios_analog_inputs.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ BeagleBone \/ 使用 GPIO 和模拟输入 ", 
"snippet" : "本章介绍使用 I\/O 映射时的限制 BeagleBone Black 访问 GPIO 和模拟输入。...", 
"body" : "本章介绍使用 I\/O 映射时的限制 BeagleBone Black 访问 GPIO 和模拟输入。 " }, 
{ "title" : "访问 P8\/P9 上的引脚 ", 
"url" : "_rtsl_linux_bbb_access_pins.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ BeagleBone \/ 使用 GPIO 和模拟输入 \/ 访问 P8\/P9 上的引脚 ", 
"snippet" : "P8 和 P9 插头可以访问许多 GPIO 和模拟输入。但是，并非所有这些默认情况下都可以免费使用。 HDMI 和 Linux 设备树标准“插槽”使用一些用于 HDMI、eMMC 和 MCASP0 的引脚。以下列表显示了哪些引脚可用作 GPIO 或模拟输入，以及哪些引脚已被系统使用。 注意输入和输出的不同允许电压和电流。 插头 P9 头针 引脚名称 CODESYS 支持 系统使用 P9_01 GND 不 不 P9_02 接地 不 不 P9_03 DC_3.3V 不 不 P9_04 DC_3.3V 不 不 P9_05 VDD_5V 不 不 P9_06 VDD_5V 不 不 P9_07 SYS_5...", 
"body" : "P8 和 P9 插头可以访问许多 GPIO 和模拟输入。但是，并非所有这些默认情况下都可以免费使用。 HDMI 和 Linux 设备树标准“插槽”使用一些用于 HDMI、eMMC 和 MCASP0 的引脚。以下列表显示了哪些引脚可用作 GPIO 或模拟输入，以及哪些引脚已被系统使用。 注意输入和输出的不同允许电压和电流。 插头 P9 头针 引脚名称 CODESYS 支持 系统使用 P9_01 GND 不 不 P9_02 接地 不 不 P9_03 DC_3.3V 不 不 P9_04 DC_3.3V 不 不 P9_05 VDD_5V 不 不 P9_06 VDD_5V 不 不 P9_07 SYS_5V 不 不 P9_08 SYS_5V 不 不 P9_09 PWR_BUT 不 不 P9_10 SYS_RESETn 不 不 P9_11 UART4_RXD 是的 不 P9_12 GPIO1_28 是的 不 P9_13 UART4_TXD 是的 不 P9_14 EHRPWM1A 是的 不 P9_15 GPIO1_16 是的 不 P9_16 EHRPWM1B 是的 不 P9_17 I2C1_SCL 不 PINMUX I 2 C P9_18 I2C1_SDA 不 PINMUX I 2 C P9_19 I2C2_SCL 不 PINMUX I 2 C P9_20 I2C2_SDA 不 PINMUX I 2 C P9_21 UART2_TXD 是的 不 P9_22 UART2_RXD 是的 不 P9_23 GPIO1_17 是的 不 P9_24 UART1_TXD 是的 不 P9_25 GPIO3_21 不 MCASPO P9_26 UART1_RXD 是的 不 P9_27 GPIO3_19 是的 不 P9_28 SPI1_CS0 不 MCASP0 P9_29 SPI1_D0 不 MCASP0 P9_30 SPI1_D1 不 MCASP0 P9_31 SPI1_SCLK 不 MCASP0 P9_32 VADC 不 不 P9_33 AIN4 是的 不 P9_34 接地 不 不 P9_35 AIN6 是的 不 P9_36 AIN5 是的 不 P9_37 AIN2 是的 不 P9_38 AIN3 是的 不 P9_39 AIN0 是的 不 P9_40 AIN1 是的 不 P9_41 GPIO0_20 是的 不 P9_42 GPIO0_7 是的 不 P9_43 接地 不 不 P9_44 接地 不 不 P9_45 接地 不 不 P9_46 接地 不 不 插头 P8 头针 引脚名称 CODESYS 支持 系统使用 P8_01 地线 不 不 P8_02 地线 不 不 P8_03 GPIO1_6 不 eMMC P8_04 GPIO1_7 不 eMMC P8_05 GPIO1_2 不 eMMC P8_06 GPIO1_3 不 eMMC P8_07 定时器4 是的 不 P8_08 定时器7 是的 不 P8_09 定时器5 是的 不 P8_10 定时器6 是的 不 P8_11 GPIO1_13 是的 不 P8_12 GPIO1_12 是的 不 P8_13 EHRPWM2B 是的 不 P8_14 GPIO0_26 是的 不 P8_15 GPIO1_15 是的 不 P8_16 GPIO1_14 是的 不 P8_17 GPIO0_27 是的 不 P8_18 GPIO2_1 是的 不 P8_19 EHRPWM2A 是的 不 P8_20 GPIO1_31 不 eMMC P8_21 GPIO1_30 不 eMMC P8_22 GPIO1_5 不 eMMC P8_23 GPIO1_4 不 eMMC P8_24 GPIO1_1 不 eMMC P8_25 GPIO1_0 不 eMMC P8_26 GPIO1_29 是的 不 P8_27 GPIO2_22 不 HDMI P8_28 GPIO2_24 不 HDMI P8_29 GPIO2_23 不 HDMI P8_30 GPIO2_25 不 HDMI P8_31 UART5_CTSN 不 HDMI P8_32 UART5_RTSN 不 HDMI P8_33 UART4_RTSN 不 HDMI P8_34 UART3_RTSN 不 HDMI P8_35 UART4_CTSN 不 HDMI P8_36 UART3_CTSN 不 HDMI P8_37 UART5_TXD 不 HDMI P8_38 UART5_TXD 不 HDMI P8_39 GPIO2_12 不 HDMI P8_40 GPIO2_13 不 HDMI P8_41 GPIO2_10 不 HDMI P8_42 GPIO2_11 不 HDMI P8_43 GPIO2_8 不 HDMI P8_44 GPIO2_9 不 HDMI P8_45 GPIO2_6 不 HDMI P8_46 GPIO2_7 不 HDMI " }, 
{ "title" : "配置外部存储设备 ", 
"url" : "_rtsl_linux_bbb_external_storage.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ BeagleBone \/ 配置外部存储设备 ", 
"snippet" : "您可以配置 BeagleBone Black 访问 USB 存储设备或 µSD 卡 CODESYS Control for BeagleBone 。特定 USB 存储设备或 µSD 卡的兼容性取决于硬件。然而，从理论上讲，每个 USB 存储设备或 µSD 卡都应与 BeagleBone Black 。 访问 USB 存储设备或 µSD 卡 配置 Linux 以进行自动挂载 Debian 提供了一个包来处理自动安装可插拔存储介质。该软件包也可以安装在您的 BeagleBone Black 。 从 Debian 目录安装 usbmount 包： command> sudo apt-get inst...", 
"body" : "您可以配置 BeagleBone Black 访问 USB 存储设备或 µSD 卡 CODESYS Control for BeagleBone 。特定 USB 存储设备或 µSD 卡的兼容性取决于硬件。然而，从理论上讲，每个 USB 存储设备或 µSD 卡都应与 BeagleBone Black 。 访问 USB 存储设备或 µSD 卡 配置 Linux 以进行自动挂载 Debian 提供了一个包来处理自动安装可插拔存储介质。该软件包也可以安装在您的 BeagleBone Black 。 从 Debian 目录安装 usbmount 包： command> sudo apt-get install usbmount 该设备必须连接到 Internet 并进行配置，以便它可以访问 Debian 服务器。 访问 USB 存储设备 连接 USB 存储设备时，usbautomount 会自动创建 \/media\/usb 文件夹，您可以在其中访问 USB 存储设备上的文件。这 CODESYS 配置控制运行时系统，以便 USB 存储设备在可用时自动显示。连接 USB 存储设备时，将其添加到 \/media\/usb 文件夹。在 CODESYS ， 这 $USB$ 占位符可用于访问此文件夹。有两种方法可以做到这一点： 您可以使用文件传输 CODESYS Development System 访问 $USB$ 占位符。 您可以使用库 CAA_File 从您的 IEC 应用程序访问这些相同的文件。 请注意，文件可能无法访问，因为介质是可插拔的。因此，检查 CAAFileOpen 的结果。 " }, 
{ "title" : "Raspberry Pi ", 
"url" : "_rtsl_linux_raspberry.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi ", 
"snippet" : "用这个 Raspberry Pi 使用 Raspbian 操作系统，您可以从 树莓派基金会 。 这 Raspberry Pi 是为测试和教学目的而开发的。不建议用于工业用途！ 树莓派入门 具有多核功能的运行时可用 Raspberry Pi 版本 2。...", 
"body" : "用这个 Raspberry Pi 使用 Raspbian 操作系统，您可以从 树莓派基金会 。 这 Raspberry Pi 是为测试和教学目的而开发的。不建议用于工业用途！ 树莓派入门 具有多核功能的运行时可用 Raspberry Pi 版本 2。 " }, 
{ "title" : "驱动程序的开发 ", 
"url" : "_rtsl_linux_rbp_driver_development.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 驱动程序的开发 ", 
"snippet" : "有很多设备可以连接到 Raspberry Pi 。 CODESYS Control for Raspberry Pi 仅支持一小部分可用硬件。如果您想将不受支持的设备连接到您的 Raspberry Pi ，然后你就可以编写自己的I\/O驱动程序了。为此，您需要一些配置和编程技能。 基本上，您可以采取以下方法通过系统接口连接和操作附加设备 I 2 C、SPI（串行外设接口）或 1-Wire。 实现功能块 (FB) 功能块处理数据到现有或新变量的映射，并确保数据的循环一致性。为此，请手动声明接口并在程序中调用实例。 使用设备描述实现功能块 (FB) 然后你可以添加一个特殊的设备到 CODESYS 设...", 
"body" : "有很多设备可以连接到 Raspberry Pi 。 CODESYS Control for Raspberry Pi 仅支持一小部分可用硬件。如果您想将不受支持的设备连接到您的 Raspberry Pi ，然后你就可以编写自己的I\/O驱动程序了。为此，您需要一些配置和编程技能。 基本上，您可以采取以下方法通过系统接口连接和操作附加设备 I 2 C、SPI（串行外设接口）或 1-Wire。 实现功能块 (FB) 功能块处理数据到现有或新变量的映射，并确保数据的循环一致性。为此，请手动声明接口并在程序中调用实例。 使用设备描述实现功能块 (FB) 然后你可以添加一个特殊的设备到 CODESYS 设备树并对其进行配置。 实现 I\/O 驱动程序 这些和其他方法在开源中进行了描述 CODESYS 锻造 平台在 驱动程序 → I\/O 驱动程序 菜单。 " }, 
{ "title" : "配置运行时 ", 
"url" : "_rtsl_linux_rbp_configure_runtime.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 配置运行时 ", 
"snippet" : "CODESYS Control for Raspberry Pi 自版本 V3.5 SP14 起还支持多核硬件（ Raspberry Pi 2和 Raspberry Pi 3）。运行时系统可以以三种不同的模式运行： 多核 64 位 (Aarch64)：此模式在 64 位模式下使用支持多核的运行时，并且必须使用针对其优化的设备描述来运行。 多核 32 位 (ARMv7)：此模式在 32 位模式下使用支持多核的运行时，并且必须使用针对其优化的设备描述来运行。 默认：此模式适用于所有 Raspberry Pi 变体并与早期版本兼容 CODESYS Control for Raspberry Pi （...", 
"body" : "CODESYS Control for Raspberry Pi 自版本 V3.5 SP14 起还支持多核硬件（ Raspberry Pi 2和 Raspberry Pi 3）。运行时系统可以以三种不同的模式运行： 多核 64 位 (Aarch64)：此模式在 64 位模式下使用支持多核的运行时，并且必须使用针对其优化的设备描述来运行。 多核 32 位 (ARMv7)：此模式在 32 位模式下使用支持多核的运行时，并且必须使用针对其优化的设备描述来运行。 默认：此模式适用于所有 Raspberry Pi 变体并与早期版本兼容 CODESYS Control for Raspberry Pi （包括设备描述）。它不支持 CODESYS 多核功能。 安装树莓派运行时系统时，会自动预先选择模式。您可以在日志窗口中查看选择了哪种模式。要更改模式，请先在服务列表中选择树莓派运行时系统。在短暂的加载时间后，当前的运行时架构将显示在右侧 您可以通过以下方式选择所需的架构 Runtime system architecture 列表框。点击 保存 将零钱转移到设备上。 可以使用的模式还取决于所使用的操作系统映像。如果使用纯64位图像，则只能使用64位模式。如果您使用纯 32 位图像，则只能选择 32 位模式。根据所使用的硬件（Raspberry PI 2B、PI 3、PI 4 等），仅支持选定的模式。 （参见工具提示）。 如果要切换模式，则必须确保在项目中配置了匹配的设备描述。否则无法再与控制器通信。切换后无法再加载控制器上现有的引导应用程序。它们必须使用匹配的设备描述再次下载到控制器。 " }, 
{ "title" : "示例项目 ", 
"url" : "_rtsl_linux_rbp_examples.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 ", 
"snippet" : "以下示例项目位于安装目录中（示例 C:\\Users\\<Name>\\ CODESYS Control for Raspberry Pi \\3.5.11.0\\Examples ）。...", 
"body" : "以下示例项目位于安装目录中（示例 C:\\Users\\<Name>\\ CODESYS Control for Raspberry Pi \\3.5.11.0\\Examples ）。 " }, 
{ "title" : "配置 WebVisu ", 
"url" : "_rtsl_linux_rbp_examples_webvisu.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置 WebVisu ", 
"snippet" : "该项目： WebVisu.project 包含一个应用程序，该应用程序具有创建的用户界面 CODESYS Visualization . 打开 WebVisu.project 项目。 在设备树中，双击 设备 . 在 通讯设置 ， 点击 扫描网络 . 如果设备与您的开发 PC 在同一网络上，则显示您的设备以供选择。 选择连接线并单击 在线 → 登录 . 该应用程序已下载到您的 Raspberry Pi。 启动程序（例如：按 F5 钥匙）。 打开任何浏览器（可能在智能手机上）并指定地址 <network address>:8080\/webvisu.htm . 在浏览器中，您会看到在项目中创建的用户...", 
"body" : "该项目： WebVisu.project 包含一个应用程序，该应用程序具有创建的用户界面 CODESYS Visualization . 打开 WebVisu.project 项目。 在设备树中，双击 设备 . 在 通讯设置 ， 点击 扫描网络 . 如果设备与您的开发 PC 在同一网络上，则显示您的设备以供选择。 选择连接线并单击 在线 → 登录 . 该应用程序已下载到您的 Raspberry Pi。 启动程序（例如：按 F5 钥匙）。 打开任何浏览器（可能在智能手机上）并指定地址 <network address>:8080\/webvisu.htm . 在浏览器中，您会看到在项目中创建的用户界面。 " }, 
{ "title" : "配置摄像头模块 ", 
"url" : "_rtsl_linux_rbp_examples_camera.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置摄像头模块 ", 
"snippet" : "可视化相机图像 这 CameraStream.project 项目包含一个带有 WebVisu 用户界面的应用程序，它显示摄像机实时流或仅显示单个图像。 要求：树莓派相机扩展硬件已连接并激活。 根据版本 RPi_Cam_Web_Interface 和包含的 Apache 安装，默认位置可能是 ..\/var\/www\/ 或者 ..\/var\/www\/html\/ .该位置在应用程序中使用 PLC_PRG 在第 3 行，你必须相应地调整它。 打开 Camera.project 项目并更新它。 在设备树中，双击 设备 . 设备编辑器打开。 在 通讯设置 ， 点击 扫描网络 . 如果您的 Raspberry...", 
"body" : "可视化相机图像 这 CameraStream.project 项目包含一个带有 WebVisu 用户界面的应用程序，它显示摄像机实时流或仅显示单个图像。 要求：树莓派相机扩展硬件已连接并激活。 根据版本 RPi_Cam_Web_Interface 和包含的 Apache 安装，默认位置可能是 ..\/var\/www\/ 或者 ..\/var\/www\/html\/ .该位置在应用程序中使用 PLC_PRG 在第 3 行，你必须相应地调整它。 打开 Camera.project 项目并更新它。 在设备树中，双击 设备 . 设备编辑器打开。 在 通讯设置 ， 点击 扫描网络 . 如果您的 Raspberry Pi 和开发系统在同一网络上，则会显示您的 Raspberry Pi 以供选择。 选择它并单击 在线 → 登录 . 该应用程序已下载到您的 Raspberry Pi。 启动程序（按 F5 钥匙）。 打开任何浏览器（可能在智能手机上）并指定地址 <network address>:8080\/webvisu.htm . 项目的用户界面打开。顶部显示摄像机的实时流，下方显示最后一帧。当您单击按钮时，框架将被更新。 " }, 
{ "title" : "保存相机图像 ", 
"url" : "_rtsl_linux_rbp_examples_camera.html#UUID-7ae4b070-9730-d58c-9609-58bda5038aa4_id_fa1d2aa65ca341bec0a864637b1b4eb2-id-919df6bb9f68aed4c0a864630c86131d", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置摄像头模块 \/ 保存相机图像 ", 
"snippet" : "要求：树莓派相机扩展硬件已连接并激活。 这 Camera.project 项目包含一个应用程序，该应用程序控制 Raspberry Pi 相机模块，拍摄单个图像并将它们保存为文件。 在某些型号上，预装 RPi Cam Control 应用程序必须被禁用。为此，请打开浏览器并指定 http:\/\/<network address> .配置页面打开。执行 stop camera 在那里指挥。 打开 Camera.project 项目并更新它。 在设备树中，双击 设备 . 设备编辑器打开。 在 通讯设置 ， 点击 扫描网络 . 如果您的 Raspberry Pi 和开发系统在同一网络上，则会显示您的 ...", 
"body" : "要求：树莓派相机扩展硬件已连接并激活。 这 Camera.project 项目包含一个应用程序，该应用程序控制 Raspberry Pi 相机模块，拍摄单个图像并将它们保存为文件。 在某些型号上，预装 RPi Cam Control 应用程序必须被禁用。为此，请打开浏览器并指定 http:\/\/<network address> .配置页面打开。执行 stop camera 在那里指挥。 打开 Camera.project 项目并更新它。 在设备树中，双击 设备 . 设备编辑器打开。 在 通讯设置 ， 点击 扫描网络 . 如果您的 Raspberry Pi 和开发系统在同一网络上，则会显示您的 Raspberry Pi 以供选择。 选择它并单击 在线 → 登录 . 该应用程序已下载到您的 Raspberry Pi。 启动程序（按 F5 钥匙）。 设置 xTakePicture 可变为 TRUE . 摄像头拍照并保存到本地文件系统中的名称下 Picture.jpg . 您可以在设备编辑器中复制图像文件 文件 到您的开发系统。点击 刷新文件视图的符号。 " }, 
{ "title" : "配置 GPIO ", 
"url" : "_rtsl_linux_rbp_examples_gpio.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置 GPIO ", 
"snippet" : "这 GPIO.project 项目包含一个带有免费 GPIO 的应用程序，该应用程序带有一个配置了 I\/O 映像的设备编辑器。数字输入和输出也在那里定义。 在设备编辑器中，在 GPIO 输入\/输出图像 选项卡，一个 DWORD 为每个输入和输出声明变量。这 Bit<X> 包含的值 GPIO<X> . 在示例中， GPIO18 被定义为输出。它被分配了一个闪烁的信号在 PLC_PRG 程序。可视化显示输入的值并允许设置输出。 Raspberry Pi B+ 型号变体有一个单独的扩展设备描述。为了使用 GPIO B+\/Pi2 设备描述而不是 GPIO A\/B ， 点击 更新设备 在上下文菜单中选择...", 
"body" : "这 GPIO.project 项目包含一个带有免费 GPIO 的应用程序，该应用程序带有一个配置了 I\/O 映像的设备编辑器。数字输入和输出也在那里定义。 在设备编辑器中，在 GPIO 输入\/输出图像 选项卡，一个 DWORD 为每个输入和输出声明变量。这 Bit<X> 包含的值 GPIO<X> . 在示例中， GPIO18 被定义为输出。它被分配了一个闪烁的信号在 PLC_PRG 程序。可视化显示输入的值并允许设置输出。 Raspberry Pi B+ 型号变体有一个单独的扩展设备描述。为了使用 GPIO B+\/Pi2 设备描述而不是 GPIO A\/B ， 点击 更新设备 在上下文菜单中选择 GPIO B+\/Pi2 对话框中的设备类型。 根据加载的驱动程序，某些 GPIO 可能会永久分配给其他功能，因此不可用。 " }, 
{ "title" : "配置 PiFace 数字 ", 
"url" : "_rtsl_linux_rbp_examples_piface.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置 PiFace 数字 ", 
"snippet" : "使用 PiFace 控制和显示模块进行控制和操作 要求：已连接 PiFace 控制和显示扩展硬件。 这 PiFaceDisplayAndControl.project 除了具有 8 个数字输入和输出的 Raspberry PiFace 数字 I\/O 硬件之外，该项目还包含一个控制两行文本显示的应用程序，以便配置应用程序参数。 您可以通过 SPI 端口 1 访问 PiFace 控制和显示板 \/dev\/spidev0.1 在 SPI Master 中配置。 将设备添加到设备树时，会创建一个 FB 实例，该实例提供用于控制设备的各种方法和属性。此外，返回按钮的状态。位 0 到 7 bySwitche...", 
"body" : "使用 PiFace 控制和显示模块进行控制和操作 要求：已连接 PiFace 控制和显示扩展硬件。 这 PiFaceDisplayAndControl.project 除了具有 8 个数字输入和输出的 Raspberry PiFace 数字 I\/O 硬件之外，该项目还包含一个控制两行文本显示的应用程序，以便配置应用程序参数。 您可以通过 SPI 端口 1 访问 PiFace 控制和显示板 \/dev\/spidev0.1 在 SPI Master 中配置。 将设备添加到设备树时，会创建一个 FB 实例，该实例提供用于控制设备的各种方法和属性。此外，返回按钮的状态。位 0 到 7 bySwitches 输出代表以下按钮： 在示例项目中 PiFace_Control_Display FB 被传递给 ParamListPiFace 实现参数编辑器的FB。在其查看模式下，您可以通过导航按钮 (6\/7) 滚动查看参数列表。按导航键（5），可以详细查看第一行的参数。按下按钮 4 退出详细视图。再次按下 5 进入编辑模式。在那里，您可以使用按钮 0 和 1 更改允许范围内的值。使用按钮 2 存储该值。按下按钮 4 退出编辑模式。 " }, 
{ "title" : "控制 PiFace 数字 I\/O 硬件 ", 
"url" : "_rtsl_linux_rbp_examples_piface.html#UUID-c604b911-bae8-3ccf-0ad8-13b30c6d647a_id_a539525ca8913fc0a864630d69208b-id-9f45924d66a164bcc0a864631b646b6a", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置 PiFace 数字 \/ 控制 PiFace 数字 I\/O 硬件 ", 
"snippet" : "要求：已连接 PiFace Digital 扩展硬件。 这 PiFace.project 项目包含一个控制具有 8 个数字输入和输出的 Raspberry PiFace 数字 I\/O 硬件的应用程序。 打开 PiFace.project 项目并更新它。 在设备树中，双击 Device . 设备编辑器打开。 在 通讯设置 选项卡，单击 扫描网络 . 如果您的 Raspberry Pi 和开发系统在同一网络上，则会显示您的 Raspberry Pi 以供选择。 选择它并单击 在线 → 登录 . 该应用程序已下载到您的 Raspberry Pi。 启动程序（按 F5 钥匙）。 当您按下 S1 按钮时...", 
"body" : "要求：已连接 PiFace Digital 扩展硬件。 这 PiFace.project 项目包含一个控制具有 8 个数字输入和输出的 Raspberry PiFace 数字 I\/O 硬件的应用程序。 打开 PiFace.project 项目并更新它。 在设备树中，双击 Device . 设备编辑器打开。 在 通讯设置 选项卡，单击 扫描网络 . 如果您的 Raspberry Pi 和开发系统在同一网络上，则会显示您的 Raspberry Pi 以供选择。 选择它并单击 在线 → 登录 . 该应用程序已下载到您的 Raspberry Pi。 启动程序（按 F5 钥匙）。 当您按下 S1 按钮时，K0 继电器输出以一秒的时间延迟切换。当您按下 S2 按钮时，K1 立即切换。 K1 在 S2 释放后保持半秒。 另请注意，您可以通过相应地调整设备树中 PiFace 设备上的设备参数来使用多个实例（可通过跳线 JP1、JP2 更改硬件地址）。 这 Raspberry SPI_PiFace 启用连接的库可作为源代码提供给他们。它可以用作其他连接的示例。 这 Raspberry Pi Peripherals 库是通过 SPI 进行通信的基础。它们的界面都记录在帮助和库管理器中。 " }, 
{ "title" : "通过 I\/O 驱动程序控制 PiFace Digital 模块 ", 
"url" : "_rtsl_linux_rbp_examples_piface.html#UUID-c604b911-bae8-3ccf-0ad8-13b30c6d647a_id_a539525ca8913fc0a864630d69208b-id-24768c9d66a164bcc0a864631df6fefb", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置 PiFace 数字 \/ 通过 I\/O 驱动程序控制 PiFace Digital 模块 ", 
"snippet" : "要求：已连接 PiFace Digital 扩展硬件。 这 PiFaceIoDrv.project 项目包含一个应用程序，该应用程序控制具有 8 个数字输入和输出的 Raspberry PiFace 数字 I\/O 硬件。但是使用 I\/O 驱动程序而不是隐式 FB 实例。 I\/O 驱动程序通过过程映像以控制器的常用方式实现输入和输出的交换。 这 IoDrvPiFace 库包含 I\/O 驱动程序作为源代码。...", 
"body" : "要求：已连接 PiFace Digital 扩展硬件。 这 PiFaceIoDrv.project 项目包含一个应用程序，该应用程序控制具有 8 个数字输入和输出的 Raspberry PiFace 数字 I\/O 硬件。但是使用 I\/O 驱动程序而不是隐式 FB 实例。 I\/O 驱动程序通过过程映像以控制器的常用方式实现输入和输出的交换。 这 IoDrvPiFace 库包含 I\/O 驱动程序作为源代码。 " }, 
{ "title" : "配置我 2 C ", 
"url" : "_rtsl_linux_rbp_examples_i2c.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置我 2 C ", 
"snippet" : "要求：通过 I²C 连接特殊硬件。 这 I2CExample.project 项目包含一个应用程序，它控制通过 I²C 连接的各种芯片和分线器。 连接硬件： Adafruit 16 通道\/12 位 PWM SRF02（超声波距离传感器） Drotek IMU 9DOF - MPU9150（陀螺仪、加速度计、磁力仪） 这 Raspberry I2C <name> 启用连接的库可作为源代码提供给您。它们可以用作其他连接的示例。 这 Raspberry Pi Peripherals 库是通过 I²C 进行通信的基础。它们的界面都记录在帮助和库管理器中。...", 
"body" : "要求：通过 I²C 连接特殊硬件。 这 I2CExample.project 项目包含一个应用程序，它控制通过 I²C 连接的各种芯片和分线器。 连接硬件： Adafruit 16 通道\/12 位 PWM SRF02（超声波距离传感器） Drotek IMU 9DOF - MPU9150（陀螺仪、加速度计、磁力仪） 这 Raspberry I2C <name> 启用连接的库可作为源代码提供给您。它们可以用作其他连接的示例。 这 Raspberry Pi Peripherals 库是通过 I²C 进行通信的基础。它们的界面都记录在帮助和库管理器中。 " }, 
{ "title" : "配置 A\/D 转换器 MPC3008 ", 
"url" : "_rtsl_linux_rbp_examples_mcp3008.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置 A\/D 转换器 MPC3008 ", 
"snippet" : "要求：特殊硬件通过 SPI 连接。 这 MCP3008_Temperature.project 项目包含一个应用程序，该应用程序通过 SPI 读取连接到 A\/D 转换器芯片 (MCP3008) 的模拟温度传感器 (LM35)。 MCP3008 可以评估 8 个模拟通道，但在本例中只使用了一个。 测试配置： 这 SPI_MCP3008 启用连接的库可作为源代码提供给他们。它可以用作其他连接的示例。 这 Raspberry Pi Peripherals 库是通过 SPI 进行通信的基础。它们的界面都记录在帮助和库管理器中。...", 
"body" : "要求：特殊硬件通过 SPI 连接。 这 MCP3008_Temperature.project 项目包含一个应用程序，该应用程序通过 SPI 读取连接到 A\/D 转换器芯片 (MCP3008) 的模拟温度传感器 (LM35)。 MCP3008 可以评估 8 个模拟通道，但在本例中只使用了一个。 测试配置： 这 SPI_MCP3008 启用连接的库可作为源代码提供给他们。它可以用作其他连接的示例。 这 Raspberry Pi Peripherals 库是通过 SPI 进行通信的基础。它们的界面都记录在帮助和库管理器中。 " }, 
{ "title" : "配置端口扩展器 MCP23S17 ", 
"url" : "_rtsl_linux_rbp_examples_mcp23s17.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置端口扩展器 MCP23S17 ", 
"snippet" : "要求：特殊硬件通过SPI连接。 这 MCP23S17.project 项目包含一个应用程序，其中端口扩展芯片 (MCP23S17) 已通过 SPI 连接。 在设备编辑器中，您可以配置哪些 GPIO 引脚用作输入或输出。您还可以为输入激活上拉电阻。根据地址 IO 引脚的分配，必须相应地配置硬件地址。...", 
"body" : "要求：特殊硬件通过SPI连接。 这 MCP23S17.project 项目包含一个应用程序，其中端口扩展芯片 (MCP23S17) 已通过 SPI 连接。 在设备编辑器中，您可以配置哪些 GPIO 引脚用作输入或输出。您还可以为输入激活上拉电阻。根据地址 IO 引脚的分配，必须相应地配置硬件地址。 " }, 
{ "title" : "配置 1-Wire ", 
"url" : "_rtsl_linux_rbp_examples_1_wire.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置 1-Wire ", 
"snippet" : "要求：已连接 1 线温度传感器。 这 OneWire.project 项目包含一个检测通过 1-Wire 连接的设备的应用程序。此外，还控制了一个 DS18B20 型温度传感器。在这种情况下，1-Wire 数据线连接到 GPIO4。 您可以使用引导应用程序来检测 ID。 示例应用程序的功能： 在网络中搜索 1-Wire 设备并在可视化中显示检测到的设备的 ID 如果检测到的设备中有 ID 配置正确的 DS18B20，则测量并显示传感器温度。 通过 1-Wire 进行数据交换非常耗时。与此同时，任务被阻止。对于时间要求严格的应用，将 1-Wire 现场总线设备的应用分配给另一个任务。您可以在设备...", 
"body" : "要求：已连接 1 线温度传感器。 这 OneWire.project 项目包含一个检测通过 1-Wire 连接的设备的应用程序。此外，还控制了一个 DS18B20 型温度传感器。在这种情况下，1-Wire 数据线连接到 GPIO4。 您可以使用引导应用程序来检测 ID。 示例应用程序的功能： 在网络中搜索 1-Wire 设备并在可视化中显示检测到的设备的 ID 如果检测到的设备中有 ID 配置正确的 DS18B20，则测量并显示传感器温度。 通过 1-Wire 进行数据交换非常耗时。与此同时，任务被阻止。对于时间要求严格的应用，将 1-Wire 现场总线设备的应用分配给另一个任务。您可以在设备编辑器中分配任务 任务列表 标签。 " }, 
{ "title" : "配置伺服电机 ", 
"url" : "_rtsl_linux_rbp_examples_softmotion_servo.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置伺服电机 ", 
"snippet" : "要求：Adafruit 16 通道\/12 位 PWM 板通过 I²C 连接，模型伺服连接到其第一个 PWM 通道。 这 SoftMotion Servo Example.project 项目包含一个应用程序，其中 CODESYS SoftMotion 与模型伺服电机配合使用。通过 I²C 连接的扩展板 (Adafruit ID 815) 用作通信接口。 打开 SoftMotion Servo Example.project 项目并更新它。 在设备树中，双击 设备 . 设备编辑器打开。 在 通讯设置 ， 点击 扫描网络 . 如果您的 Raspberry Pi 和开发系统在同一网络上，则会显示您的...", 
"body" : "要求：Adafruit 16 通道\/12 位 PWM 板通过 I²C 连接，模型伺服连接到其第一个 PWM 通道。 这 SoftMotion Servo Example.project 项目包含一个应用程序，其中 CODESYS SoftMotion 与模型伺服电机配合使用。通过 I²C 连接的扩展板 (Adafruit ID 815) 用作通信接口。 打开 SoftMotion Servo Example.project 项目并更新它。 在设备树中，双击 设备 . 设备编辑器打开。 在 通讯设置 ， 点击 扫描网络 . 如果您的 Raspberry Pi 和开发系统在同一网络上，则会显示您的 Raspberry Pi 以供选择。 选择它并单击 在线 → 登录 . 该应用程序已下载到您的 Raspberry Pi。 启动程序（按 F5 钥匙）。 伺服电机开始从左到右稳定旋转。这 PLC_PRG 在 SFC 中实施的程序对此负责。它打开轴，然后在指定为终端位置的 -60 和 +60 位置之间移动它 SM_Drive_Servo 轴配置。 位置预设通过 PWM 接口传输，与建模伺服系统一样。 1 到 2 毫秒长的高电平脉冲以固定频率传输（默认值：50 Hz；Adafruit PWM SoftMotion 设备的参数）。 1 ms 代表下端位置，2 ms 代表上端位置。运动范围因电机类型而异。如果电机以角度控制，则必须测量运动范围。为此，驱动到末端位置（在示例中为 -60、+60）并在配置屏幕中输入测量位置： 打开任何浏览器（可能在智能手机上）并指定地址 <network address>:8080\/webvisu.htm . 可视化打开并显示生成的指定位置。你可以控制速度。 " }, 
{ "title" : "配置 EtherCAT ", 
"url" : "_rtsl_linux_rbp_examples_ethercat.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置 EtherCAT ", 
"snippet" : "要求： 带有 Beckhoff EL2008 设备的 Beckhoff EK1100 连接到以太网适配器。 这 EtherCAT.project 项目包含一个控制 EtherCAT 现场总线设备的应用程序。八个可用输出被激活。 如果您将 Raspberry Pi 的 LAN 端口用于 EtherCAT 现场总线，则需要备用编程接口。使用 USB Wifi 适配器，例如 Edimax N150。 打开 EtherCAT.project 项目并更新它。 在设备树中，双击 设备 . 设备编辑器打开。 在 通讯设置 ， 点击 扫描网络 . 如果您的 Raspberry Pi 和开发系统在同一网络上，则...", 
"body" : "要求： 带有 Beckhoff EL2008 设备的 Beckhoff EK1100 连接到以太网适配器。 这 EtherCAT.project 项目包含一个控制 EtherCAT 现场总线设备的应用程序。八个可用输出被激活。 如果您将 Raspberry Pi 的 LAN 端口用于 EtherCAT 现场总线，则需要备用编程接口。使用 USB Wifi 适配器，例如 Edimax N150。 打开 EtherCAT.project 项目并更新它。 在设备树中，双击 设备 . 设备编辑器打开。 在 通讯设置 ， 点击 扫描网络 . 如果您的 Raspberry Pi 和开发系统在同一网络上，则会显示您的 Raspberry Pi 以供选择。 选择它并单击 在线 → 登录 . 该应用程序已下载到您的 Raspberry Pi。 启动程序（按 F5 钥匙）。 EL2008 终端的输出然后连续变化。 " }, 
{ "title" : "配置 OPC UA ", 
"url" : "_rtsl_linux_rbp_examples_opc_ua.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置 OPC UA ", 
"snippet" : "这 OPCUA.project 项目包含一个应用程序，其中配置变量以访问 OPC UA 客户端。为此，两个变量 PLC_PRG 对象已发布在 符号配置 目的。 在合适的 OPC UA 客户端中，例如 Unified Automation UaExpert，您可以通过 URL 连接到您的 RaspberryPi opc.tcp:\/\/<network address>:4840 .在客户端中，显示其符号（已发布的变量）并显示当前值。如果在符号配置中授予写入权限，则您可以写入符号。...", 
"body" : "这 OPCUA.project 项目包含一个应用程序，其中配置变量以访问 OPC UA 客户端。为此，两个变量 PLC_PRG 对象已发布在 符号配置 目的。 在合适的 OPC UA 客户端中，例如 Unified Automation UaExpert，您可以通过 URL 连接到您的 RaspberryPi opc.tcp:\/\/<network address>:4840 .在客户端中，显示其符号（已发布的变量）并显示当前值。如果在符号配置中授予写入权限，则您可以写入符号。 " }, 
{ "title" : "配置感知 HAT ", 
"url" : "_rtsl_linux_rbp_examples_sense_hat.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ Raspberry Pi \/ 示例项目 \/ 配置感知 HAT ", 
"snippet" : "要求：您需要 Raspberry Pi Sense HAT 附加板。 A Raspberry Pi 连接的 Sense HAT 附加板配备了加速度、温度和气压传感器，以及陀螺仪和磁力计传感器。因此，例如，您可以创建一个气象站。 该项目 SenseHat.project 提供用于操作 Sense HAT 附加板的应用程序。 示例应用程序的功能： 传感器数据的测量和显示 传感器的控制 通过操纵杆控制 用户界面：...", 
"body" : "要求：您需要 Raspberry Pi Sense HAT 附加板。 A Raspberry Pi 连接的 Sense HAT 附加板配备了加速度、温度和气压传感器，以及陀螺仪和磁力计传感器。因此，例如，您可以创建一个气象站。 该项目 SenseHat.project 提供用于操作 Sense HAT 附加板的应用程序。 示例应用程序的功能： 传感器数据的测量和显示 传感器的控制 通过操纵杆控制 用户界面： " }, 
{ "title" : "PLCnext ", 
"url" : "_rtsl_plcnext.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ PLCnext ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "特定应用说明 ", 
"url" : "_rtsl_plcnext_hints.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ PLCnext \/ 特定应用说明 ", 
"snippet" : "为了优化特殊用例，我们推荐以下应用程序\/配置设置。...", 
"body" : "为了优化特殊用例，我们推荐以下应用程序\/配置设置。 " }, 
{ "title" : "用例配置： PROFINET ", 
"url" : "_rtsl_plcnext_hints.html#UUID-1e21ef99-5642-2ae9-585e-0f712913f733_section-idm4605464568745633478907338798", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ PLCnext \/ 特定应用说明 \/ 用例配置： PROFINET ", 
"snippet" : "使用时 PROFINET ，您应该遵守以下说明： 尽可能使用的多核特性 CODESYS . 执行此操作时，请使用核心 0 PROFINET 任务。 如果可能，请使用单独的网络适配器 PROFINET 联系。 如果您想确保即使应用程序停止，现场总线也能继续发送和接收帧，则启用 在 Stop 中刷新 I\/O PLC 设置中的选项。...", 
"body" : "使用时 PROFINET ，您应该遵守以下说明： 尽可能使用的多核特性 CODESYS . 执行此操作时，请使用核心 0 PROFINET 任务。 如果可能，请使用单独的网络适配器 PROFINET 联系。 如果您想确保即使应用程序停止，现场总线也能继续发送和接收帧，则启用 在 Stop 中刷新 I\/O PLC 设置中的选项。 " }, 
{ "title" : "用户案例配置：Axioline ", 
"url" : "_rtsl_plcnext_hints.html#UUID-1e21ef99-5642-2ae9-585e-0f712913f733_section-idm458155578255363347890799443", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ PLCnext \/ 特定应用说明 \/ 用户案例配置：Axioline ", 
"snippet" : "使用 Axioline 时，您应该遵守以下说明： 尽可能使用的多核特性 CODESYS . 这样做时，将核心 1 用于 Axioline 任务和总线周期任务。 PLCNext 控制器的某些 Axioline 模块具有称为“PDI 对象”的附加信息。您可以通过以下方式访问此信息 IoDrvPLCNextAxioLib.PdiRead 和 IoDrvPLCNextAxioLib.PdiWrite ....", 
"body" : "使用 Axioline 时，您应该遵守以下说明： 尽可能使用的多核特性 CODESYS . 这样做时，将核心 1 用于 Axioline 任务和总线周期任务。 PLCNext 控制器的某些 Axioline 模块具有称为“PDI 对象”的附加信息。您可以通过以下方式访问此信息 IoDrvPLCNextAxioLib.PdiRead 和 IoDrvPLCNextAxioLib.PdiWrite . " }, 
{ "title" : "CODESYS Virtual Control for Linux SL ", 
"url" : "_rtsl_codesys_virtual_for_linux_control_sl.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ CODESYS Virtual Control for Linux SL ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概述 ", 
"url" : "_rtsl_virtual_control_sl_overview.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ CODESYS Virtual Control for Linux SL \/ 概述 ", 
"snippet" : "这 CODESYS Virtual Control for Linux SL 附加组件可用于管理虚拟运行时和网关实例。 虚拟运行时系统基于 Docker 或 Podman 容器技术构建。 例如，Docker 区分镜像和容器。映像是容器的模板，该容器运行与系统其余部分封装的进程。封装使得在同一系统上同时运行多个容器成为可能，而与硬件无关。 CODESYS Virtual Control for Linux SL 使用这些功能来提供独立于硬件的控制器。 您将找到有关如何使用“运行时部署”工具将映像传输到目标系统、从映像创建实例以及管理这些实例的说明。 基于容器的控制器启动运行时系统建立与实例的连接...", 
"body" : "这 CODESYS Virtual Control for Linux SL 附加组件可用于管理虚拟运行时和网关实例。 虚拟运行时系统基于 Docker 或 Podman 容器技术构建。 例如，Docker 区分镜像和容器。映像是容器的模板，该容器运行与系统其余部分封装的进程。封装使得在同一系统上同时运行多个容器成为可能，而与硬件无关。 CODESYS Virtual Control for Linux SL 使用这些功能来提供独立于硬件的控制器。 您将找到有关如何使用“运行时部署”工具将映像传输到目标系统、从映像创建实例以及管理这些实例的说明。 基于容器的控制器启动运行时系统建立与实例的连接 CODESYS Virtual Control SL " }, 
{ "title" : "建立与实例的连接 ", 
"url" : "_rtsl_extablish_connection_to_instance.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ CODESYS Virtual Control for Linux SL \/ 建立与实例的连接 ", 
"snippet" : "建立与运行时实例的直接连接 端口转发允许您直接连接到运行时实例。除了运行时实例之外，这不需要任何其他实例。 要求 用于直接通信的运行时实例的端口（ 11740 ) 必须转发。 笔记： 这不是运行时实例的默认配置，但实例需要在之后进行配置。 无法在同一目标设备上对同一端口进行多次配置。但是，您可以将下一个空闲端口用于第二个运行时实例。例子： 11741:11740 存在已配置且可访问的网关。该网关不必位于同一网络上。 上 沟通 选项卡中，选择一个活动网关。 然后，在要连接的设备一侧，输入运行时实例的主机系统的 IP 地址，然后输入转发端口。 标签： 沟通 : 目标设备上的网关实例 您可以使用网关...", 
"body" : "建立与运行时实例的直接连接 端口转发允许您直接连接到运行时实例。除了运行时实例之外，这不需要任何其他实例。 要求 用于直接通信的运行时实例的端口（ 11740 ) 必须转发。 笔记： 这不是运行时实例的默认配置，但实例需要在之后进行配置。 无法在同一目标设备上对同一端口进行多次配置。但是，您可以将下一个空闲端口用于第二个运行时实例。例子： 11741:11740 存在已配置且可访问的网关。该网关不必位于同一网络上。 上 沟通 选项卡中，选择一个活动网关。 然后，在要连接的设备一侧，输入运行时实例的主机系统的 IP 地址，然后输入转发端口。 标签： 沟通 : 目标设备上的网关实例 您可以使用网关实例来建立 CODESYS 连接到您的运行时实例。 要求： 用于网关通信的网关实例端口（ 1217 ) 必须转发。这是网关实例的默认配置。 网关和运行时实例必须位于同一容器网络上。这是默认配置。 现在，要连接到正在运行的实例，请创建一个新的 CODESYS 项目与 CODESYS Virtual Control for Linux SL 设备。 创建一个新的网关。对于新网关，指定您的主机的 IP 地址，其中 CODESYS Virtual Control for Linux SL 正在运行于 IP地址 的领域 网关 对话。 选择新网关并运行网络扫描。 将显示已配置和已启动的运行时实例。 " }, 
{ "title" : "配置： CODESYS Virtual Control for Linux SL ", 
"url" : "_rtsl_reference.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ CODESYS Virtual Control for Linux SL \/ 配置： CODESYS Virtual Control for Linux SL ", 
"snippet" : "为实例设置选项 配置 价值 描述 自动启动 TRUE 或者 FALSE 设备启动\/启动时自动启动实例。依赖关系已解决，实例将按正确的顺序启动。 能力 以逗号分隔的列表，例如： cap_sys_admin, cap_sched, cap_chown, cap_ipc_lock 目标设备上实例的权限。 为了实现实时合规，需要进行预先选择。 有关 Docker 设置，请参阅： Docker 文档：运行时权限和 Linux 功能 依赖关系 字符串 以逗号分隔的当前实例所依赖的实例列表。因此，此处列出的实例是事先启动的，以便共享内存可用。如果指定的实例不存在，则会发出错误消息。 Inst_B,Inst_...", 
"body" : "为实例设置选项 配置 价值 描述 自动启动 TRUE 或者 FALSE 设备启动\/启动时自动启动实例。依赖关系已解决，实例将按正确的顺序启动。 能力 以逗号分隔的列表，例如： cap_sys_admin, cap_sched, cap_chown, cap_ipc_lock 目标设备上实例的权限。 为了实现实时合规，需要进行预先选择。 有关 Docker 设置，请参阅： Docker 文档：运行时权限和 Linux 功能 依赖关系 字符串 以逗号分隔的当前实例所依赖的实例列表。因此，此处列出的实例是事先启动的，以便共享内存可用。如果指定的实例不存在，则会发出错误消息。 Inst_B,Inst_C 如果当前实例（例如， Inst_A ) 以开头 开始选中 命令，然后显示一条警告，指出 Inst_B 和 Inst_C 也必须开始。确认这一点后，将首先启动这两个实例，然后 Instance_A 实例。 主机名 字符串 实例的网络名称 默认值是实例名称。 图片 字符串 用于实例的图像 IPC 字符串 基本上，所有值也在 Docker 文档 因为该字段是允许的。 仅当该字段包含 container: 前缀。根据Docker文档，这是为了使用现有的共享内存（“加入”）。必须在以此命名的实例上创建此共享内存 container: 使用 shareable 关键字。为了确保共享内存在实例启动时可用，必须在之后输入的实例上定义相应的依赖关系 container: 前缀。 可共享 无 container:Inst_first 许可证服务器 字符串 许可证服务器的 IP 地址 在以逗号分隔的列表中指定 示例： 192.168.0.1,10.0.0.1,172.17.0.2 坐骑 以逗号分隔的列表 将实例装载到主机。 待在语法中指定 Host path:Instance path 注意事项： 路径是绝对的。 主机路径包含实例名称。对于默认挂载（data\/conf），不得更改此路径 网络 字符串 将实例挂载到主机上的网络。 参见： Docker 文档：网络设置 注意：只能指定一个网络。 Docker networks allow containers to communicate with each other. If the configured Docker network does not exist yet, then a new one will be created. The IP address of the respective instance within this network can be configured via the Nic field. For more information about Docker networks, see the Docker documentation . 尼克 字符串 专门分配给实例的目标系统的网络适配器的配置。当应使用基于以太网的现场总线时，需要此配置 以下格式用于配置： <Nic>\/<IP>\/<network mask>,<Nic2>\/<IP2>\/<network mask2>,... 可以使用逗号分隔的列表指定多个网络适配器。 示例： 所需的配置 “不错” 配置 NIC : eno1 IP : 192.168.0.100 面具： 255.255.255.0 → \/24 eno1\/192.168.0.100\/24 NIC : eno1 IP :- 面具：- NIC2 : eno2 IP2 : 192.168.0.100 口罩 2： 255.255.248.0 → \/21 eno1,eno2\/102.168.0.100\/21 NIC : eno1 IP :- 面具：- NIC2 : eno2 IP2 :- 口罩 2:- eno1,2eno2 注意事项： 一个适配器只能分配给一个实例。 因此，该适配器在目标系统上也不再可用。 需要指定 IP 地址和相应的网络掩码。 网络掩码使用后缀（例如：“\/24” 或 “\/21”）指定。 无法为适配器分配多个 IP 地址。 端口 以逗号分隔的列表，例如： 1217:1217, 8081:8080 运行时实例使用的端口 待在语法中指定 HostPort:InstancePort （以逗号分隔的列表） 注意：不能多次分配主机端口。 有关常见用例或端口，请参阅： CODESYS Control示例： Gateway 1217. Webvisu (https) 443, OPC UA 4840 产品类型 Runtime \/ Gateway 产品类型：运行时或网关 此值无法更改。 科技 Docker \/ Podman 目标系统上使用的容器技术 此值无法更改。 下一步在维护模式下启动 TRUE 或者 FALSE Only for CODESYS Virtual Edge Gateway for Linux and CODESYS Edge Gateway for Linux This setting determines whether or not the Edge Gateway is started in maintenance mode. In this mode, a connection between the Edge Gateway and the Automation Server can be configured using the CODESYS Automation Server Connector . 只能在安全的环境中使用此模式。 此模式在 30 分钟后、网关重新启动时或配置完成后停用。 " }, 
{ "title" : "CODESYS TargetVisu for Linux SL ", 
"url" : "_rtsl_target_visu_for_linux.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ CODESYS TargetVisu for Linux SL ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "配置 CODESYS TargetVisu for Linux SL ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234374412744104", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ CODESYS TargetVisu for Linux SL \/ 配置 CODESYS TargetVisu for Linux SL ", 
"snippet" : "默认情况下，目标可视化在启动时会显示多个对话框，以获取与控制器建立连接所需的信息。此信息已保存，以后可以通过配置目标可视化来修改或删除。 您也可以在首次开始可视化之前定义这些参数。之后，启动可视化时不再显示对话框 设置 应用程序 运行可视化的应用程序的名称 CODESYS 密码 的密码 CODESYS 可视化项登录控制器时使用的用户。 CODESYS 用户 可视化项登录控制器时使用的用户名。 主机名 可视化所连接的 PLC 的主机名。该名称可以在大多数 Linux 发行版上使用 hostname 命令。要连接到当前目标设备上的控制器，必须在此处定义此 PLC 的主机名。 下次启动时请求设置 设...", 
"body" : "默认情况下，目标可视化在启动时会显示多个对话框，以获取与控制器建立连接所需的信息。此信息已保存，以后可以通过配置目标可视化来修改或删除。 您也可以在首次开始可视化之前定义这些参数。之后，启动可视化时不再显示对话框 设置 应用程序 运行可视化的应用程序的名称 CODESYS 密码 的密码 CODESYS 可视化项登录控制器时使用的用户。 CODESYS 用户 可视化项登录控制器时使用的用户名。 主机名 可视化所连接的 PLC 的主机名。该名称可以在大多数 Linux 发行版上使用 hostname 命令。要连接到当前目标设备上的控制器，必须在此处定义此 PLC 的主机名。 下次启动时请求设置 设置已重置，目标可视化将在下次启动时在相应的对话框中请求所有信息。 " }, 
{ "title" : "自动启动 ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234374413098957", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ CODESYS TargetVisu for Linux SL \/ 自动启动 ", 
"snippet" : "重新启动目标设备后，目标可视化将自动打开。加载所有模块并显示应用程序可能需要一分钟的时间。首次与 PLC 建立连接时，可能需要更长时间，因为可视化中使用的资产必须首次传输。...", 
"body" : "重新启动目标设备后，目标可视化将自动打开。加载所有模块并显示应用程序可能需要一分钟的时间。首次与 PLC 建立连接时，可能需要更长时间，因为可视化中使用的资产必须首次传输。 " }, 
{ "title" : "前 CODESYS TargetVisu for Linux SL 版本 4.13.0.0 ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234461986157731", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ CODESYS TargetVisu for Linux SL \/ 自动启动 \/ 前 CODESYS TargetVisu for Linux SL 版本 4.13.0.0 ", 
"snippet" : "自动启动由 .desktop 文件。有两种方法可以安装该包： 保存 codesysvisualization.desktop 归档 \/etc\/xdg\/autostart\/ 将启动脚本附加到 ~\/.xinitrc 或者 \/etc\/X11\/xinit 如果您的系统上不存在这些目录，或者您不使用它们，则需要自己配置自动启动。启动和停止脚本位于 \/opt\/codesysvisualization\/scripts 。有关目录结构的详细信息，请参阅： https:\/\/content.helpme-codesys.com\/de\/CODESYS 控制\/_rtsl_linux_installation_with...", 
"body" : "自动启动由 .desktop 文件。有两种方法可以安装该包： 保存 codesysvisualization.desktop 归档 \/etc\/xdg\/autostart\/ 将启动脚本附加到 ~\/.xinitrc 或者 \/etc\/X11\/xinit 如果您的系统上不存在这些目录，或者您不使用它们，则需要自己配置自动启动。启动和停止脚本位于 \/opt\/codesysvisualization\/scripts 。有关目录结构的详细信息，请参阅： https:\/\/content.helpme-codesys.com\/de\/CODESYS 控制\/_rtsl_linux_installation_without_pm.html CODESYS TargetVisu for Linux SL 不会改变当前 Linux 账户的登录行为。如果您的 Linux 账户已停用自动登录，则仍需要身份验证才能启动可视化。 " }, 
{ "title" : "在 CODESYS TargetVisu for Linux SL 版本 4.13.0.0 及更高版本 ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234461987255572", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 产品特定配置 \/ CODESYS TargetVisu for Linux SL \/ 自动启动 \/ 在 CODESYS TargetVisu for Linux SL 版本 4.13.0.0 及更高版本 ", 
"snippet" : "自动启动是通过 systemd 。单元文件位于 ~\/.config\/systemd\/user\/codesysvisualization.service 。要自行配置自动启动，您可以使用 systemctl --user disable codesysvisualization 或者修改单元文件并重新加载 systemctl --user daemon-reload 。...", 
"body" : "自动启动是通过 systemd 。单元文件位于 ~\/.config\/systemd\/user\/codesysvisualization.service 。要自行配置自动启动，您可以使用 systemctl --user disable codesysvisualization 或者修改单元文件并重新加载 systemctl --user daemon-reload 。 " }, 
{ "title" : "CODESYS Virtual Safe Control for Linux SL ", 
"url" : "_rtsl_codesys_virtual_for_linux_control_sl-1825956.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Control for Linux SL ", 
"snippet" : "这个 CODESYS Virtual Safe Control for Linux SL 是一个独立于硬件、功能安全的控制器，它作为与功能并行的独立运行时系统运行 CODESYS Virtual Control SL 控制器。 请注意，本文档仅供参考。有关安全和认证的限制和信息，请参阅安全手册 H1 – SafetyManual.pdf 。 在操作时 CODESYS Virtual Safe Control for Linux SL ，必须遵守安全白皮书的安全要求。 有关更多信息，请参阅： CODESYS 安全白皮书 有关安全关键应用程序开发的更多信息，请使用 CODESYS ，参见： 安全手...", 
"body" : "这个 CODESYS Virtual Safe Control for Linux SL 是一个独立于硬件、功能安全的控制器，它作为与功能并行的独立运行时系统运行 CODESYS Virtual Control SL 控制器。 请注意，本文档仅供参考。有关安全和认证的限制和信息，请参阅安全手册 H1 – SafetyManual.pdf 。 在操作时 CODESYS Virtual Safe Control for Linux SL ，必须遵守安全白皮书的安全要求。 有关更多信息，请参阅： CODESYS 安全白皮书 有关安全关键应用程序开发的更多信息，请使用 CODESYS ，参见： 安全手册  H1 – SafetyManual.pdf 》，保存在 ..\/<user>\/CODESYS Virtual Safe Control Linux SL\/Delivery\/Manuals \n目录中 CODESYS Safety Extension 有关如何初始设置的说明 CODESYS Virtual Safe Control for Linux SL 场景中描述了 “安全屋” 场景：vPLC + vSafe + ProfiSafe + 时间提供商 + 许可证服务器。 " }, 
{ "title" : "时间戳异常 ", 
"url" : "_rtsl_timestamp_exceptions.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Control for Linux SL \/ 时间戳异常 ", 
"snippet" : "下一节描述了验证安全控制器的时间行为时可能发生的错误。需要一个独立的第二时基来验证时间行为。...", 
"body" : "下一节描述了验证安全控制器的时间行为时可能发生的错误。需要一个独立的第二时基来验证时间行为。 " }, 
{ "title" : "不同的时间戳 ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm234959765203734", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Control for Linux SL \/ 时间戳异常 \/ 不同的时间戳 ", 
"snippet" : "三个时间戳用于验证安全控制器的时间行为。 Remote Timestamp ：从时间提供者计算机获取的时间戳。 Sample Timestamp ：收货时在当地拍摄的时间戳。 Local Timestamp ：应用程序运行时在本地获取的时间戳。...", 
"body" : "三个时间戳用于验证安全控制器的时间行为。 Remote Timestamp ：从时间提供者计算机获取的时间戳。 Sample Timestamp ：收货时在当地拍摄的时间戳。 Local Timestamp ：应用程序运行时在本地获取的时间戳。 " }, 
{ "title" : "可能的错误消息 ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm234959951496687", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Control for Linux SL \/ 时间戳异常 \/ 可能的错误消息 ", 
"snippet" : "时间提供者的所有错误都返回四个十六进制数值。这些是以微秒为单位的时间值。它们具有以下含义： 值 1：最后两次之间的时间 Local Timestamps 值 2：最后两次之间的时间 Remote Timestamps 值 3：最后两次之间的时间 Sample Timestamps 值 4：从收到最后一封邮件之间的时间 Remote Timestamps 并评估这个时间戳 值的顺序对应于错误消息中的顺序。 时间验证期间可能有 3 条错误消息。以下是导致此错误的检查、发生的错误以及错误的一些可能原因的描述。仅将发生的第一个错误记录在 标签日志 因为此错误发生后 IEC 应用程序已停止。 为了更详细...", 
"body" : "时间提供者的所有错误都返回四个十六进制数值。这些是以微秒为单位的时间值。它们具有以下含义： 值 1：最后两次之间的时间 Local Timestamps 值 2：最后两次之间的时间 Remote Timestamps 值 3：最后两次之间的时间 Sample Timestamps 值 4：从收到最后一封邮件之间的时间 Remote Timestamps 并评估这个时间戳 值的顺序对应于错误消息中的顺序。 时间验证期间可能有 3 条错误消息。以下是导致此错误的检查、发生的错误以及错误的一些可能原因的描述。仅将发生的第一个错误记录在 标签日志 因为此错误发生后 IEC 应用程序已停止。 为了更详细地分析错误的原因，可以查看错误消息中输出的四个十六进制数值。 " }, 
{ "title" : "消息： Plausibility check of the local timestamp to the cycle time ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm43495995265356", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Control for Linux SL \/ 时间戳异常 \/ 可能的错误消息 \/ 消息： Plausibility check of the local timestamp to the cycle time ", 
"snippet" : "检查： 比较设定的循环时间和自上一个周期以来的实际经过时间。这个 Local Timestamp 是用来做这个。 错误： 内部时间测量在每个周期中进行，显示经过的时间（根据计算机的内部时钟）与设定的周期时间偏差超过5％。 常见原因： 安全应用程序的调度存在问题。...", 
"body" : "检查： 比较设定的循环时间和自上一个周期以来的实际经过时间。这个 Local Timestamp 是用来做这个。 错误： 内部时间测量在每个周期中进行，显示经过的时间（根据计算机的内部时钟）与设定的周期时间偏差超过5％。 常见原因： 安全应用程序的调度存在问题。 " }, 
{ "title" : "消息： Plausibility check of the remote timestamp to the cycle time ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm43495995331862", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Control for Linux SL \/ 时间戳异常 \/ 可能的错误消息 \/ 消息： Plausibility check of the remote timestamp to the cycle time ", 
"snippet" : "检查： 将设定的周期时间与最后两个周期之间的周期进行比较 Sample Timestamps 。这个 Sample Timestamp 已使用。 始终使用周期内收到的最后一个有效时间戳。之前的将被丢弃。这意味着无效的时间戳不会立即导致系统错误 错误： 没有新的 Remote Timestamp 已收到超过一个周期。 常见原因： 时间提供者关闭或已停止 控制器和时间提供者之间没有网络连接 网络故障 严重的日程安排问题...", 
"body" : "检查： 将设定的周期时间与最后两个周期之间的周期进行比较 Sample Timestamps 。这个 Sample Timestamp 已使用。 始终使用周期内收到的最后一个有效时间戳。之前的将被丢弃。这意味着无效的时间戳不会立即导致系统错误 错误： 没有新的 Remote Timestamp 已收到超过一个周期。 常见原因： 时间提供者关闭或已停止 控制器和时间提供者之间没有网络连接 网络故障 严重的日程安排问题 " }, 
{ "title" : "消息： Plausibility check of remote timestamp to local timestamp ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm43495995376508", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Control for Linux SL \/ 时间戳异常 \/ 可能的错误消息 \/ 消息： Plausibility check of remote timestamp to local timestamp ", 
"snippet" : "检查： 比较最后两次之间的间隔 Sample Timestamps 已使用以及最后两次之间的间隔 Remote Timestamps 使用的。这个 Sample Timestamp 还有 Remote Timestamp 被使用。 错误： 最后两者之间的间隔之差 Sample Timestamps 以及最后两者之间的间隔 Remote Timestamps 大于 5% 的允许容差。 常见原因： 时间提供商的日程安排问题 线程接收时间戳的调度问题 传输网络（交换机等）的延迟...", 
"body" : "检查： 比较最后两次之间的间隔 Sample Timestamps 已使用以及最后两次之间的间隔 Remote Timestamps 使用的。这个 Sample Timestamp 还有 Remote Timestamp 被使用。 错误： 最后两者之间的间隔之差 Sample Timestamps 以及最后两者之间的间隔 Remote Timestamps 大于 5% 的允许容差。 常见原因： 时间提供商的日程安排问题 线程接收时间戳的调度问题 传输网络（交换机等）的延迟 " }, 
{ "title" : "应用程序启动 ", 
"url" : "_rtsl_application_start.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Control for Linux SL \/ 应用程序启动 ", 
"snippet" : "对于 CODESYS Virtual Safe Control 因此，启动应用程序的启动必须得到用户的确认。 在 CODESYS Safety Extension 版本 4.3.0.0 及更高版本，新状态 ( waiting for confirmation ) 显示在项目树和活动应用程序的状态中。 和 CODESYS Safety Extension 低于 4.3.0.0 版本时，不显示状态，既不显示在设备树中，也不会显示在状态中。但是，可以从安全控制器的日志中获取状态。 这个 启动 BootApp 功能块用于确认下载的启动应用程序的启动 启动启动应用程序的条件： FB 输出的当前值 Saf...", 
"body" : "对于 CODESYS Virtual Safe Control 因此，启动应用程序的启动必须得到用户的确认。 在 CODESYS Safety Extension 版本 4.3.0.0 及更高版本，新状态 ( waiting for confirmation ) 显示在项目树和活动应用程序的状态中。 和 CODESYS Safety Extension 低于 4.3.0.0 版本时，不显示状态，既不显示在设备树中，也不会显示在状态中。但是，可以从安全控制器的日志中获取状态。 这个 启动 BootApp 功能块用于确认下载的启动应用程序的启动 启动启动应用程序的条件： FB 输出的当前值 SafeApplication.BootAppConfirmation 必须转移到 StartBootApp 功能块。 必须指定 clientID。客户端 ID 在运行时系统的 CFG 文件中定义。 标准应用程序的默认设置： 16#ED387206 。 客户端 ID、固件版本、appID 和值 SafeApplication.BootAppConfirmtion 必须发送到控制器。这是用完成的 StartBootApp 功能块。 有关更多信息，请参阅： CODESYS 安全扩展 。 " }, 
{ "title" : "CODESYS Virtual Safe Time Provider ", 
"url" : "_rtsl_virtual_safe_time_provider.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Time Provider ", 
"snippet" : "这 CODESYS Virtual Safe Time Provider 是一个标准接口，用户可以使用它将第二个外部时间基准传输到 CODESYS Virtual Safe Control 。 该实现是作为客户端完成的，它必须在另一个具有独立时间基准的系统上运行。...", 
"body" : "这 CODESYS Virtual Safe Time Provider 是一个标准接口，用户可以使用它将第二个外部时间基准传输到 CODESYS Virtual Safe Control 。 该实现是作为客户端完成的，它必须在另一个具有独立时间基准的系统上运行。 " }, 
{ "title" : "安装 ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964887312564", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Time Provider \/ 安装 ", 
"snippet" : "这 CODESYS Virtual Safe Time Provider SL 是通过 CODESYS Control SL Deploy Tool 更多信息请参见： “安全屋” 场景：vPLC + vSafe + ProfiSafe + 时间提供商 + 许可证服务器。 这 CODESYS Virtual Safe Time Provider SL 不能与 CODESYS Virtual Safe Control SL。...", 
"body" : "这 CODESYS Virtual Safe Time Provider SL 是通过 CODESYS Control SL Deploy Tool 更多信息请参见： “安全屋” 场景：vPLC + vSafe + ProfiSafe + 时间提供商 + 许可证服务器。 这 CODESYS Virtual Safe Time Provider SL 不能与 CODESYS Virtual Safe Control SL。 " }, 
{ "title" : "功能 ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964887538634", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Time Provider \/ 功能 ", 
"snippet" : "这 Time Provider 作为 CODESYS Virtual Safe Control SL 并以定义的时间间隔通过网络将时间戳作为消息发送。 然后，该消息可以被各种接收器接收和评估（ CODESYS Virtual Safe Control l SL，冗余 Time Provider ）。 这 CODESYS Virtual Safe Control SL 以定义的周期时间运行应用程序，其中来自外部计时器的至少一个时间戳必须到达。 发送间隔 Time Provider 应配置为小于应用程序周期时间的一半。 为了提高由于网络或调度问题导致的稳定性 Time Provider 因此 CO...", 
"body" : "这 Time Provider 作为 CODESYS Virtual Safe Control SL 并以定义的时间间隔通过网络将时间戳作为消息发送。 然后，该消息可以被各种接收器接收和评估（ CODESYS Virtual Safe Control l SL，冗余 Time Provider ）。 这 CODESYS Virtual Safe Control SL 以定义的周期时间运行应用程序，其中来自外部计时器的至少一个时间戳必须到达。 发送间隔 Time Provider 应配置为小于应用程序周期时间的一半。 为了提高由于网络或调度问题导致的稳定性 Time Provider 因此 CODESYS Virtual Safe Control SL， Time Provider 可以冗余执行。 有两种类型可区分。 " }, 
{ "title" : "Time Provider 冗余 ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm43496653769816", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Time Provider \/ 功能 \/ Time Provider 冗余 ", 
"snippet" : "如果是 Time Provider 冗余，两个 Time Provider 实例运行在两个独立的主机上。一个实例充当主动发送方，另一个实例被动监视时间戳的发送。 要使用该功能，两个 Time Provider 实例已启动，冗余参数必须设置为 TRUE 在这两种情况下。 一旦主动实例的时间戳发送出现延迟或未发生，被动实例将立即接管发送，并使用主动实例的最后一个已知偏移量。这意味着 CODESYS Virtual Safe Control SL. 两个实例必须运行在同一个网络。只有这样，被动实例才能监控主动实例发送的消息。 如果一个活跃 Time Provider 在网络中检测到总线上的另一个活动...", 
"body" : "如果是 Time Provider 冗余，两个 Time Provider 实例运行在两个独立的主机上。一个实例充当主动发送方，另一个实例被动监视时间戳的发送。 要使用该功能，两个 Time Provider 实例已启动，冗余参数必须设置为 TRUE 在这两种情况下。 一旦主动实例的时间戳发送出现延迟或未发生，被动实例将立即接管发送，并使用主动实例的最后一个已知偏移量。这意味着 CODESYS Virtual Safe Control SL. 两个实例必须运行在同一个网络。只有这样，被动实例才能监控主动实例发送的消息。 如果一个活跃 Time Provider 在网络中检测到总线上的另一个活动实例，则具有最高优先级 IP 地址的实例保持活动状态，而所有其他实例进入被动模式。 " }, 
{ "title" : "网络冗余 ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm43496653810142", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Time Provider \/ 功能 \/ 网络冗余 ", 
"snippet" : "在网络冗余的情况下， Time Provider 每个实例都使用自己的网络，而 Time Provider 冗余。尽管如此，对于被动 Time Provider 实例从活动实例接收消息，以便在发生延迟或故障时接管发送。 网络冗余尚未实现。...", 
"body" : "在网络冗余的情况下， Time Provider 每个实例都使用自己的网络，而 Time Provider 冗余。尽管如此，对于被动 Time Provider 实例从活动实例接收消息，以便在发生延迟或故障时接管发送。 网络冗余尚未实现。 " }, 
{ "title" : "配置 ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964888427036", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Time Provider \/ 配置 ", 
"snippet" : "选项 描述 默认值 -a\/--address 目标 IP 地址 127.0.0.1（本地主机） -p\/--port 目标端口 60000 -c\/--cycletime 发送间隔 Time Provider 时间戳（单位：毫秒） 3 -P\/--priority SCHED_FIFO 调度优先级 55 -C\/--cpu_pin CPU 固定 所有线程都固定到定义的 CPU，从值 0 开始。 0 -r\/--redundancy 冗余模式 禁用后， Time Provider 立即发送时间戳。 启用后， Time Provider 仅在没有其他更高优先级时发送 Time Provider 正在发送。 ...", 
"body" : "选项 描述 默认值 -a\/--address 目标 IP 地址 127.0.0.1（本地主机） -p\/--port 目标端口 60000 -c\/--cycletime 发送间隔 Time Provider 时间戳（单位：毫秒） 3 -P\/--priority SCHED_FIFO 调度优先级 55 -C\/--cpu_pin CPU 固定 所有线程都固定到定义的 CPU，从值 0 开始。 0 -r\/--redundancy 冗余模式 禁用后， Time Provider 立即发送时间戳。 启用后， Time Provider 仅在没有其他更高优先级时发送 Time Provider 正在发送。 有关更多信息，请参阅以下内容： Time Provider已禁用 -s\/--syslog 记录 syslog 到 \/dev\/log 已禁用 --stat_print_time 诊断间隔（秒） 60 IP 地址的默认值为 127.0.0.1（localhost）。此值仅用于调试和测试。 Time Provider 提供独立的时基，因此不能在本地操作。如果使用默认值，则 Time Provider 发出警告。 " }, 
{ "title" : "诊断 ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964888678287", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ CODESYS Virtual Safe Time Provider \/ 诊断 ", 
"snippet" : "评估页面上的时间戳时可能发生的错误 CODESYS Virtual Safe Control SL： 配置的端口已被使用。 如果配置的端口已被使用且无法打开，则会发出以下消息： Could not open port <Port number> it is already in use! 活动实例中的时间戳发送延迟或未发生。 如果主动发送者的时间戳被延迟或未发送，并且被动 Time Provider 实例接管发送，则发出以下诊断消息： Started sending: take over from higher priority time provider <priority> 当优先级较高的...", 
"body" : "评估页面上的时间戳时可能发生的错误 CODESYS Virtual Safe Control SL： 配置的端口已被使用。 如果配置的端口已被使用且无法打开，则会发出以下消息： Could not open port <Port number> it is already in use! 活动实例中的时间戳发送延迟或未发生。 如果主动发送者的时间戳被延迟或未发送，并且被动 Time Provider 实例接管发送，则发出以下诊断消息： Started sending: take over from higher priority time provider <priority> 当优先级较高的 Time Provider 实例再次可用并接管前一个被动实例的发送，发出以下消息： Stopped sending: higher priority time provider is active: <priority> 时间戳的循环统计（活动实例\/发送者） 发送的时间戳的统计信息按配置的间隔发出（ -stat_print_time 选项）以微秒 [us] 为精度。将发出最小和最大发送间隔，以及配置时间段内的平均值： Statistics: min: <minimum sending interval>, max: <maximum sending interval>, avg: <average sending interval> - send time interval 时间戳的循环统计（被动实例\/接收者） 由于被动实例接收主动实例发送的时间戳，因此可以评估接收到的信息以用于诊断目的。 统计数据按配置的时间间隔发布（ -stat_print_time 选项）以微秒[us]和百分比[%]为精度。会输出最小和最大间隔，以及配置时间段内的平均值： Statistics: min: <minimum deviation>, max: <maximum deviation>, avg: <average deviation> - remote to sample time deviation Statistics: min: <minimum sample interval>, max: <maximum sample interval>, avg: <average sample interval> - sample time interval Statistics: min: <minimum remote interval>, max: <maximum remote interval>, avg: <average remote interval> - remote time interval 丢失消息计数器 如果活动实例未发送时间戳，则计数器递增并输出： Statistics: lost messages: <number of lost messages> " }, 
{ "title" : "性能优化 ", 
"url" : "_rtsl_performance_optimization_linux.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 性能优化 ", 
"snippet" : "在此页面上，我们将向您展示如何设置您的设备， CODESYS Virtual Control SL 和您的应用程序，以便您实现最佳性能。 我们为您提供可用于检查和评估系统当前状态的工具。 我们建议执行以下程序。按指定的顺序完成这些步骤。如果当前步骤没有达到所需的优化程度，那么继续下一步是没有意义的。 检查硬件设置 Linux配置 CODESYS 运行时系统配置 IEC 应用程序每个步骤之后，检查最后的更改是否不会对之前步骤的优化产生负面影响。 在正常负载下达到所需的性能后，您可以选择在高负载下执行测试 stress-ng 或者 iperf 。 您可以在以下网站上找到更多信息： Linux基金会...", 
"body" : "在此页面上，我们将向您展示如何设置您的设备， CODESYS Virtual Control SL 和您的应用程序，以便您实现最佳性能。 我们为您提供可用于检查和评估系统当前状态的工具。 我们建议执行以下程序。按指定的顺序完成这些步骤。如果当前步骤没有达到所需的优化程度，那么继续下一步是没有意义的。 检查硬件设置 Linux配置 CODESYS 运行时系统配置 IEC 应用程序每个步骤之后，检查最后的更改是否不会对之前步骤的优化产生负面影响。 在正常负载下达到所需的性能后，您可以选择在高负载下执行测试 stress-ng 或者 iperf 。 您可以在以下网站上找到更多信息： Linux基金会 力努创公司 " }, 
{ "title" : "检查硬件 ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4640115908976034154363059654", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 性能优化 \/ 检查硬件 ", 
"snippet" : "不要对控制器的处理器核心使用共享缓存。 如果您的目标设备使用基于以太网的现场总线，请为其使用物理适配器。不要使用交换机架构。...", 
"body" : "不要对控制器的处理器核心使用共享缓存。 如果您的目标设备使用基于以太网的现场总线，请为其使用物理适配器。不要使用交换机架构。 " }, 
{ "title" : "设置 Linux ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm43415437655754", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 性能优化 \/ 设置 Linux ", 
"snippet" : "使用实时内核。 我们建议使用 RT 抢占内核（ https:\/\/rt.wiki.kernel.org ）适用于您的 Linux 系统。对于 Debian 和 Ubuntu 发行版，您会发现 RT 内核是一个软件包，您可以使用以下命令轻松安装它： apt 命令。有关详细信息，请参阅您的发行版的手册。 在 Debian 系统上 sudo apt-get install linux-image-rt-amd64 检查您正在使用哪个内核 uname -a 命令。例如。 避免在系统上使用窗口管理器、GUI\/X 服务器或类似工具。 使用这些工具可能会影响系统的实时功能，从而导致 IEC 应用程序出现高抖动...", 
"body" : "使用实时内核。 我们建议使用 RT 抢占内核（ https:\/\/rt.wiki.kernel.org ）适用于您的 Linux 系统。对于 Debian 和 Ubuntu 发行版，您会发现 RT 内核是一个软件包，您可以使用以下命令轻松安装它： apt 命令。有关详细信息，请参阅您的发行版的手册。 在 Debian 系统上 sudo apt-get install linux-image-rt-amd64 检查您正在使用哪个内核 uname -a 命令。例如。 避免在系统上使用窗口管理器、GUI\/X 服务器或类似工具。 使用这些工具可能会影响系统的实时功能，从而导致 IEC 应用程序出现高抖动。 测试 使用“rt-tools”： 安装“rt-tools”： sudo apt install rt-tests 开始“循环测试”： sudo cyclictest -p 99 -t -m 这 man cyclictest 命令向您显示更多命令行选项，您可以使用它们更好地测量系统的更多或特定性能方面。 使用“循环测试”确定的值是否可以被视为“良好”取决于您的硬件。如果您使用的是功能非常强大的处理器（例如 Intel Core i7），那么您的最大值应该为低 1 位数字。如果您使用旧的 ARM 处理器，那么 100 可能是一个不错的结果。 优化选项 更改每个设置或设置组合后，您应该运行 “cyclictest” 程序来验证更改的有效性。 这些设置不是永久性的，因此必须在系统启动或重新启动后重置。 禁用CPU节能模式。 禁用超线程。 您可以使用以下命令禁用超线程（示例）： echo off | sudo tee \/sys\/devices\/system\/cpu\/smt\/control 尽可能禁用 CPU 频率缩放和切换。 例如，将最小和最大 CPU 频率设置为相同（固定）值。 禁用 Linux 内核的实时限制机制，因为这可能会导致系统抖动。 有关更多信息，请参阅： Linux 基金会：日程安排 — RT 节流 您可以使用以下命令禁用实时限制（示例）： echo -1 > \/proc\/sys\/kernel\/sched_rt_runtime_us 检查并更改调度\/缩放调节器。 检查使用的调度\/缩放调节器： cat \/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_governor 更改使用的调度\/缩放调节器（如 root\/admin ） 到 Performance : echo \"performance\" > \/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_governor\n# set it for all available cores:\necho \"performance\" > \/sys\/devices\/system\/cpu\/cpu1\/cpufreq\/scaling_governor\necho \"performance\" > \/sys\/devices\/system\/cpu\/cpu2\/cpufreq\/scaling_governor\necho \"performance\" > \/sys\/devices\/system\/cpu\/cpu3\/cpufreq\/scaling_governor 请注意，每次系统启动时都必须重置缩放调节器。您也可以通过内核配置来设置它。 这 intel_pstate 内核驱动程序会使正确的设置变得更加困难。因此，您应该使用 cpufreq-info 命令来检查您的配置。 您还可以使用诸如 cpu-freq-utils 。这可能会干扰 Intel pstate 驱动程序。这些驱动程序通常需要不同的方法来设置 CPU 频率。 有关更多信息，请参阅： https:\/\/www.kernel.org\/doc\/Documentation\/cpu-freq\/governors.txt 禁用 HyperV 在 BIOS 中（如果有）。 " }, 
{ "title" : "配置 CODESYS 运行时系统 ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4554832147912034154456684842", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 性能优化 \/ 配置 CODESYS 运行时系统 ", 
"snippet" : "创建一个测试应用程序，大致描述您想要优化系统的应用程序（根据所需的资源、所需的性能和项目规模）。 您可以迭代地执行此操作：首先创建一个非常粗略的近似值，然后对其进行扩展以越来越接近实际应用程序。 测试 当应用程序运行时，检查任务配置。打开 任务配置 并选择 监视器 标签。 分钟。抖动 (μs) \/ 最大抖动（微秒） 这些值应尽可能接近“cycletest”程序确定的值。详细信息在章节中描述 设置 Linux。 有关抖动和延迟的更多信息，请参阅： 抖动和延迟的定义 有关监控选项卡的更多信息，请参阅： 选项卡：监控 平均周期时间（微秒）\/最大周期时间周期时间 (µs) 周期时间 (µs) 最大周期...", 
"body" : "创建一个测试应用程序，大致描述您想要优化系统的应用程序（根据所需的资源、所需的性能和项目规模）。 您可以迭代地执行此操作：首先创建一个非常粗略的近似值，然后对其进行扩展以越来越接近实际应用程序。 测试 当应用程序运行时，检查任务配置。打开 任务配置 并选择 监视器 标签。 分钟。抖动 (μs) \/ 最大抖动（微秒） 这些值应尽可能接近“cycletest”程序确定的值。详细信息在章节中描述 设置 Linux。 有关抖动和延迟的更多信息，请参阅： 抖动和延迟的定义 有关监控选项卡的更多信息，请参阅： 选项卡：监控 平均周期时间（微秒）\/最大周期时间周期时间 (µs) 周期时间 (µs) 最大周期不应接近配置的周期时间。一旦系统遇到高负载，这就会导致问题。 始终保持周期时间尽可能短。 优化选项 更改每个设置或设置组合后，应运行“循环测试”程序来验证更改的有效性。 将长时间运行的任务拆分为多个较小的任务。 运行时，最高优先级任务的最大循环时间不应达到配置的循环时间。如果无法避免这种情况，则应增加配置的周期时间以确保一致的执行时间。 启动现场总线系统（例如 EtherCAT 或 PROFINET）时，启动周期可能会导致 CPU 负载稍高。在这种情况下，在启动应用程序后不久监控 CPU 负载是有意义的。 以下选项无法更改 CODESYS Virtual Control SL ，但需要在主机上配置： 设置值 DisableCpuDmaLatency 至 1： [SysCpuHandling]\nLinux.DisableCpuDmaLatency=1 请注意，这是运行时版本 4.11.0.0 的默认设置。 要检查您的运行时版本，请单击 附加功能 → 更新Linux → 系统 → 系统信息 。 检查实时内核是否真正被使用。 从版本 4.11.0.0 开始，您可以使用 PLC shell 命令 rt-get kernelinfo 检查这个。 如果您有旧版本，那么您可以直接在命令行上使用以下命令执行此操作 uname -a 。 如果实时内核没有被使用，那么你需要从头开始。 " }, 
{ "title" : "配置 IEC 应用程序 ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4633380190436834154474610871", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 性能优化 \/ 配置 IEC 应用程序 ", 
"snippet" : "本节涉及您的实际应用。 测试 您可以使用上一步中的测试 配置 CODESYS 运行时系统 测试您的 IEC 应用程序。 优化选项 更改每个设置或设置组合后，应运行“循环测试”程序来验证更改的有效性。 您可以使用 多核 特色于 CODESYS 。 确定任务的正确优先级。重要的任务应该有更高的优先级。 IEC任务优先级和Linux线程优先级的映射： IEC 任务优先级 Linux优先级 -- 88（SCHED_FIFO） -- 57（SCHED_FIFO） 0（最高实时优先级） 56（SCHED_FIFO） 15（最低实时优先级） 41（SCHED_FIFO） 16（非实时优先） 0 (SCHED...", 
"body" : "本节涉及您的实际应用。 测试 您可以使用上一步中的测试 配置 CODESYS 运行时系统 测试您的 IEC 应用程序。 优化选项 更改每个设置或设置组合后，应运行“循环测试”程序来验证更改的有效性。 您可以使用 多核 特色于 CODESYS 。 确定任务的正确优先级。重要的任务应该有更高的优先级。 IEC任务优先级和Linux线程优先级的映射： IEC 任务优先级 Linux优先级 -- 88（SCHED_FIFO） -- 57（SCHED_FIFO） 0（最高实时优先级） 56（SCHED_FIFO） 15（最低实时优先级） 41（SCHED_FIFO） 16（非实时优先） 0 (SCHED_OTHER) 31（非实时优先） 0 (SCHED_OTHER) -- 0 (SCHED_OTHER) 传统的 Linux 系统上，大多数中断 (IRQ) 和内核工作程序的优先级为 Linux 50。使用上述优先级（高负载）可能会导致系统功能（网络\/存储）无法按预期运行 您可以在相应的任务配置中配置任务的优先级。 如果在执行此处提到的所有步骤后仍未达到所需的性能，那么您可以查看以下部分： 现场总线特定信息[针对专家] – 其他工具和主题" }, 
{ "title" : "现场总线特定信息 ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4494465964555234154489740927", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 性能优化 \/ 现场总线特定信息 ", 
"snippet" : "测试 检查 Send Time \/ Recv Time EtherCAT 状态页面上的值。 配备 Intel Core i7 处理器和良好适配器的 x64 CPU 的时间应该少于 10μs。 具有集成芯片的 ARM 处理器将具有约 50μs 或更长的时间。 检查 Send Time \/ Recv Time PROFINET 状态页上的值。 配备 Intel Core i7 处理器和良好适配器的 x64 CPU 的时间应该少于 10μs。 具有集成芯片的 ARM 处理器将具有约 50μs 或更长的时间。 优化选项 要对优先级和所需的 IRQ 进行排序，您可以使用 PLC shell 命令 irq...", 
"body" : "测试 检查 Send Time \/ Recv Time EtherCAT 状态页面上的值。 配备 Intel Core i7 处理器和良好适配器的 x64 CPU 的时间应该少于 10μs。 具有集成芯片的 ARM 处理器将具有约 50μs 或更长的时间。 检查 Send Time \/ Recv Time PROFINET 状态页上的值。 配备 Intel Core i7 处理器和良好适配器的 x64 CPU 的时间应该少于 10μs。 具有集成芯片的 ARM 处理器将具有约 50μs 或更长的时间。 优化选项 要对优先级和所需的 IRQ 进行排序，您可以使用 PLC shell 命令 irq-list 和 irq-set-prio 。 这些命令使用正常的 Linux 优先级，而不是 IEC 优先级。 这种优化在以下情况下是不可能的 CODESYS Virtual Control SL ，而是在主机系统上。 为设备使用单独的网络适配器。 有关更多信息，请参阅： EtherCAT 工业以太网 以太网\/IP CAN总线、CANopen " }, 
{ "title" : "[针对专家] – 其他工具和主题 ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm464011317245123415449146407", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 配置和扩展 \/ 性能优化 \/ [针对专家] – 其他工具和主题 ", 
"snippet" : "本节中描述的工具和选项仅适用于高级用户，需要您自己研究，因为要采取的措施在很大程度上取决于相关系统。因此，我们无法为您提供任何具体的解决方案。 KernelShark \/ 内核跟踪 如果您发现性能问题的原因在于调度，则可以选择此程序。借助“内核跟踪”，您可以查看您的任务是否被另一个任务、另一个服务或中断中断。 trace-cmd record -p function 您可以使用 KernelShark 检查生成的 trace.dat 文件。 一般来说，调度问题可以分为两类： 取代\/抢占 如果不需要中断或阻止执行的任务，则禁用它。 提高您的任务的优先级或降低其他任务的优先级。 切换到不同的 CP...", 
"body" : "本节中描述的工具和选项仅适用于高级用户，需要您自己研究，因为要采取的措施在很大程度上取决于相关系统。因此，我们无法为您提供任何具体的解决方案。 KernelShark \/ 内核跟踪 如果您发现性能问题的原因在于调度，则可以选择此程序。借助“内核跟踪”，您可以查看您的任务是否被另一个任务、另一个服务或中断中断。 trace-cmd record -p function 您可以使用 KernelShark 检查生成的 trace.dat 文件。 一般来说，调度问题可以分为两类： 取代\/抢占 如果不需要中断或阻止执行的任务，则禁用它。 提高您的任务的优先级或降低其他任务的优先级。 切换到不同的 CPU 核心。 使用上一章中描述的程序检查更改的有效性。 执行时间处理时间 参见下文：“内核函数跟踪” 内核函数跟踪 如果您确定代码执行时间太长，那么您可以使用此工具来查明问题。 如果执行时间太长的函数在您自己的代码中，那么您需要对其进行优化。 如果执行时间太长的函数在内核中，那么您可以尝试使用另一个内核函数来实现所需的功能。或者，您也可以将配置参数传递给内核驱动程序以减少执行时间。 如果这些选项都不能解决问题，那么您可能需要使用更强大的硬件。 查看以下几点并检查它们是否是实现性能目标的正确工具： PREEMPT_FULL 独立CPU rcu_nocbs rcu_nocb_poll 无软锁定 中断平衡禁用 kernel.sched_rt_runtime_us " }, 
{ "title" : "用例 ", 
"url" : "_rtsl_use_cases_linux.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "使用公钥认证连接 ", 
"url" : "_rtsl_linux_public_key_authentification.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 使用公钥认证连接 ", 
"snippet" : "SSH 允许连接到安全、加密和经过身份验证的控制器。这允许您在安全设置中执行控制器的远程管理。 可以通过提供凭据（用户名和密码）来完成身份验证。您还可以使用基于密钥的身份验证（公钥身份验证）来选择更强大的方法。用户使用密钥登录控制器。密钥由公钥和私钥组成。这种密钥对比密码更难泄露。 日志记录操作检查控制器的公钥是否与开发系统的私钥匹配。在这种情况下，无需使用密码即可授予访问权限。 您创建用于 CODESYS 基于Windows的开发系统。您可以选择指定密码，以便进一步提高公钥认证的安全性。您可以将公钥复制到一个甚至多个控制器，这可能是可取的，例如，在由多个控制器组成的机器上。私钥始终保留在开发...", 
"body" : "SSH 允许连接到安全、加密和经过身份验证的控制器。这允许您在安全设置中执行控制器的远程管理。 可以通过提供凭据（用户名和密码）来完成身份验证。您还可以使用基于密钥的身份验证（公钥身份验证）来选择更强大的方法。用户使用密钥登录控制器。密钥由公钥和私钥组成。这种密钥对比密码更难泄露。 日志记录操作检查控制器的公钥是否与开发系统的私钥匹配。在这种情况下，无需使用密码即可授予访问权限。 您创建用于 CODESYS 基于Windows的开发系统。您可以选择指定密码，以便进一步提高公钥认证的安全性。您可以将公钥复制到一个甚至多个控制器，这可能是可取的，例如，在由多个控制器组成的机器上。私钥始终保留在开发系统中，在任何情况下都不得共享。 永远不要共享私钥。 " }, 
{ "title" : "创建 SSH 密钥 ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4635616815128032538919569496", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 使用公钥认证连接 \/ 创建 SSH 密钥 ", 
"snippet" : "首先在 Windows 中创建一个由私钥和公钥组成的 SSH 密钥。 安装开源“PuTTY”工具。 不同的应用程序位于 C:\\Program Files (x86)\\PuTTY . 打开“PuTTYgen”工具。 将打开以下对话框。 选择 RSA 选项并单击 产生 按钮。 开始创建密钥。 同时，在进度条下方的空闲空间中移动鼠标，直到创建密钥。 将打开以下对话框： 如果需要，您可以在 密钥密码 和 确认密码 . 如果您已分配密码，则密钥也受到保护。每次使用密钥登录控制器时都需要密码 CODESYS .将密码短语保密，以便只有授权人员知道。 点击 保存私钥 按钮并指定文件名（例如： service...", 
"body" : "首先在 Windows 中创建一个由私钥和公钥组成的 SSH 密钥。 安装开源“PuTTY”工具。 不同的应用程序位于 C:\\Program Files (x86)\\PuTTY . 打开“PuTTYgen”工具。 将打开以下对话框。 选择 RSA 选项并单击 产生 按钮。 开始创建密钥。 同时，在进度条下方的空闲空间中移动鼠标，直到创建密钥。 将打开以下对话框： 如果需要，您可以在 密钥密码 和 确认密码 . 如果您已分配密码，则密钥也受到保护。每次使用密钥登录控制器时都需要密码 CODESYS .将密码短语保密，以便只有授权人员知道。 点击 保存私钥 按钮并指定文件名（例如： serviceuser.ppk ）。 点击 保存 . 私有 PPK 密钥已创建。 点击 转换 → 导出 OpenSSH 密钥 命令。 指定文件名（例如： serviceuser.openssh ）。 创建私有 OPENSSH 密钥。 在里面 用于粘贴到 OpenSSH 授权密钥文件中的公钥 文本字段，现在选择整个字符串。 在 上下文菜单 ，点击 复制 字符串复制到剪贴板并将其粘贴到文本文件中。命名文本文件（示例： serviceuser.pub ）。 私人 PUB 密钥已创建。 将密钥移动到开发计算机上合适的，甚至可能是隐藏的位置。或者将文件保存在与开发系统一起使用的 U 盘上。 例如，私钥和公钥现在位于 D:\\PLCs\\BeagleBone\\Keys 目录。 确保私钥始终保留在开发系统上。绝对不能共享私钥。 " }, 
{ "title" : "将公钥复制到控制器 ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4635616712388832538922040216", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 使用公钥认证连接 \/ 将公钥复制到控制器 ", 
"snippet" : "复制公钥（例如： serviceuser.pub ) 到控制器。注意供应商信息。...", 
"body" : "复制公钥（例如： serviceuser.pub ) 到控制器。注意供应商信息。 " }, 
{ "title" : "将私钥链接到 CODESYS ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4570645292920032538924011205", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 使用公钥认证连接 \/ 将私钥链接到 CODESYS ", 
"snippet" : "打开 CODESYS 然后单击 工具 → 部署控制 SL 命令。 在 沟通 选项卡，展开 基于密钥的登录 部分。 点击 添加密钥文件 按钮。 文件选择对话框打开。 选择所需的私钥（OPENSSH 文件）。 例子： serviceuser.openssh 点击 行 确认对话框。 对话框关闭。现在 CODESYS 有私钥。 您还可以在选项中链接私钥，在 运行时部署工具 类别。...", 
"body" : "打开 CODESYS 然后单击 工具 → 部署控制 SL 命令。 在 沟通 选项卡，展开 基于密钥的登录 部分。 点击 添加密钥文件 按钮。 文件选择对话框打开。 选择所需的私钥（OPENSSH 文件）。 例子： serviceuser.openssh 点击 行 确认对话框。 对话框关闭。现在 CODESYS 有私钥。 您还可以在选项中链接私钥，在 运行时部署工具 类别。 " }, 
{ "title" : "使用 SSH 密钥的基于密钥的登录 ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4570645233654432538931011655", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 使用公钥认证连接 \/ 使用 SSH 密钥的基于密钥的登录 ", 
"snippet" : "使用 SSH 密钥登录控制器。 点击 工具 → 部署控制 SL 命令。 这 运行时部署工具 打开。 选择 基于密钥的SSH登录 选项。 一个列表框提供了所有已知的键 CODESYS . 选择所需的键 serviceuser.openssh . 在相应的输入字段中指定用户名和密码，必要时还要指定密码。 点击 扫描 按钮。 扫描网络以查找匹配的控制器。显示搜索结果。 从控制器列表中选择所需的一个。 例如，单击 系统信息 . 控制器上的 SSH 服务器检查私钥是否与公钥匹配。在这种情况下，您已通过身份验证并登录。之后，执行命令并显示控制器的系统信息 CODESYS ....", 
"body" : "使用 SSH 密钥登录控制器。 点击 工具 → 部署控制 SL 命令。 这 运行时部署工具 打开。 选择 基于密钥的SSH登录 选项。 一个列表框提供了所有已知的键 CODESYS . 选择所需的键 serviceuser.openssh . 在相应的输入字段中指定用户名和密码，必要时还要指定密码。 点击 扫描 按钮。 扫描网络以查找匹配的控制器。显示搜索结果。 从控制器列表中选择所需的一个。 例如，单击 系统信息 . 控制器上的 SSH 服务器检查私钥是否与公钥匹配。在这种情况下，您已通过身份验证并登录。之后，执行命令并显示控制器的系统信息 CODESYS . " }, 
{ "title" : "在没有包管理器的情况下安装 SL 产品 ", 
"url" : "_rtsl_linux_installation_without_pm.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 在没有包管理器的情况下安装 SL 产品 ", 
"snippet" : "SL 产品的更新工具在后台将安装包（.deb 或 .ipk）复制到目标设备，然后进行安装。这需要在目标设备上安装软件包管理器（dpkg 或 ipkg）。如果未安装包管理器，则更新工具无法安装运行时系统。 但是，如果需要，仍然可以手动安装软件包。对于通用产品，这在下面使用 CODESYS Control​ for Linux 以 V4.7.0.0 为例。 CODESYS Control 不支持具有（部分）写保护文件系统的设备。 如果您的设备具有写保护文件系统，并且您在安装或启动产品时遇到问题，请检查禁用写保护后问题是否仍然出现。...", 
"body" : "SL 产品的更新工具在后台将安装包（.deb 或 .ipk）复制到目标设备，然后进行安装。这需要在目标设备上安装软件包管理器（dpkg 或 ipkg）。如果未安装包管理器，则更新工具无法安装运行时系统。 但是，如果需要，仍然可以手动安装软件包。对于通用产品，这在下面使用 CODESYS Control​ for Linux 以 V4.7.0.0 为例。 CODESYS Control 不支持具有（部分）写保护文件系统的设备。 如果您的设备具有写保护文件系统，并且您在安装或启动产品时遇到问题，请检查禁用写保护后问题是否仍然出现。 " }, 
{ "title" : "在目标设备上手动安装运行时系统 ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4590635748291233589649632523", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 在没有包管理器的情况下安装 SL 产品 \/ 在目标设备上手动安装运行时系统 ", 
"snippet" : "安装后 CODESYS Control​ for Linux 软件包，所需的文件位于 Windows 电脑上： <user>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.deb 或者 <user>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.ipk <user>\/CODESYS Control for Linux SL\/Dependency\/code...", 
"body" : "安装后 CODESYS Control​ for Linux 软件包，所需的文件位于 Windows 电脑上： <user>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.deb 或者 <user>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.ipk <user>\/CODESYS Control for Linux SL\/Dependency\/codemeter-lite_<Version>.deb （用于许可） 将这些文件复制到目标设备。 打开包装： $ ar -x codesyscontrol_linux_<Version> 创建了以下文件： control.tar.gz ：包含软件包管理器在安装或卸载前后运行的脚本。这与手动安装无关。 data.tar.gz ：包含运行时系统二进制文件、库、启动脚本和配置 debian-binary : 指定 .deb 包的版本。这与手动安装无关。 打开包装 data.tar.gz 文件。事先为此创建一个新文件夹： $ mkdir data\n$ tar -xf data.tar.gz -C data 在 data\/ ，您现在将找到对运行时系统的操作很重要的文件： data\n├── etc\n│ ├── default\n│ │ └── codesyscontrol\n│ ├── init.d\n│ │ └── codesyscontrol\n│ └── codesyscontrol\n│ ├── 3S.dat\n│ ├── CODESYSControl.cfg\n│ └── CODESYSControl_User.cfg\n├── opt\n│ └── codesys\n│ ├── bin\n│ │ └── codesyscontrol.bin\n│ ├── lib\n│ │ ├── libCmpHilscherCIFX.so\n│ │ └── libSysPci.so\n│ └── scripts\n│ ├── init-functions\n│ ├── init-vars\n│ ├── PlcWink.sh\n│ └── rts_set_baud.sh\n├── usr\n│ └── share\n│ └── doc\n│ └── codesyscontrol\n│ └── copyright\n└── var\n └── opt\n └── codesys\n ├── bacstac.ini\n ├── cmact_licenses\n └── .SoftContainer_CmRuntime.wbb 现在包管理器（dpkg 或 ipkg）通常会将此目录结构复制到系统的根目录。这必须在没有包管理器的情况下手动完成： 更改为 data\/ 目录所在的 data.tar.gz 文件被解压： $ cd data\/ 将各个目录复制到目标的相应根目录： 如果您犯了错误，那么此步骤可能会使您的目标设备无法使用，您将不得不重置它。 $ sudo cp -r etc\/* \/etc\n$ sudo cp -r opt\/* \/opt\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var 现在包管理器将执行一些安装后步骤来完成安装。手动执行这些步骤： $ sudo chmod a+rw \/etc\/codesyscontrol\/CODESYSControl.cfg\n$ sudo chmod a+rw \/etc\/codesyscontrol\/CODESYSControl_User.cfg 如果 codesysuser 目标设备上尚不存在群组，然后将其添加。 $ groupadd codesysuser 该组用于扩展 API。有关详细信息，请参阅： 安全机制运行时系统现已安装。但是，它仍然需要 Codemeter 运行时环境。 " }, 
{ "title" : "在目标设备上手动安装 Codemeter 运行时环境 ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4590635833291233589649827584", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 在没有包管理器的情况下安装 SL 产品 \/ 在目标设备上手动安装 Codemeter 运行时环境 ", 
"snippet" : "安装 CODESYS Control SL 软件包后，.deb 软件包会保存在 <User>\/CODESYS Control für Linux SL\/Dependency\/codemeter-lite_<Version>.deb 中。 还将此 .deb 包复制到目标系统上新创建的空文件夹中。 解压 Debian 软件包。 $ ar -x codemeter-lite_<Version>.deb 这 control.tar.gz , data.tar.gz , debian-binary ，并且 _gpgorigin 文件被提取。 打开包装 data.tar.gz 文件到新创建的文件夹中。 $...", 
"body" : "安装 CODESYS Control SL 软件包后，.deb 软件包会保存在 <User>\/CODESYS Control für Linux SL\/Dependency\/codemeter-lite_<Version>.deb 中。 还将此 .deb 包复制到目标系统上新创建的空文件夹中。 解压 Debian 软件包。 $ ar -x codemeter-lite_<Version>.deb 这 control.tar.gz , data.tar.gz , debian-binary ，并且 _gpgorigin 文件被提取。 打开包装 data.tar.gz 文件到新创建的文件夹中。 $ mkdir data\n$ tar -xf data.tar.gz -C data 之后，二进制文件和其他文件（例如库和脚本）可在 data\/ : data\n├── etc\n│ ├── init.d\n│ │ ├── codemeter\n│ │ └── codemeter-webadmin\n│ └── wibu\n│ └── CodeMeter\n│ └── Server.ini\n├── lib\n│ ├── systemd\n│ │ └── system\n│ │ ├── codemeter.service\n│ │ └── codemeter-webadmin.service\n│ └── udev\n│ └── rules.d\n│ └── 60-codemeter-lite.rules\n├── usr\n│ ├── bin\n│ │ ├── cmu\n│ │ └── codemeter-info\n│ ├── lib\n│ │ └── x86_64-linux-gnu\n│ │ ├── jni\n│ │ │ ├── libwibucmJNI64.so -> libwibucmJNI.so\n│ │ │ └── libwibucmJNI.so\n│ │ ├── libwibucmlin64-4.so -> libwibucm.so\n│ │ ├── libwibucmlin64.so -> libwibucm.so\n│ │ ├── libwibucmlin.so -> libwibucm.so\n│ │ └── libwibucm.so\n│ ├── sbin\n│ │ ├── CmWebAdmin\n│ │ └── CodeMeterLin\n│ └── share\n│ ├── bash-completion\n│ │ └── completions\n│ │ └── cmu\n│ ├── doc\n│ │ ├── CodeMeter\n│ │ │ ├── OpenSource_en.pdf\n│ │ │ └── README\n│ │ └── codemeter-lite\n│ │ ├── changelog.gz\n│ │ └── copyright\n│ └── man\n│ └── man1\n│ └── codemeter-info.1.gz\n└── var\n ├── lib\n │ └── CodeMeter\n │ ├── Backup\n │ ├── CmAct\n │ ├── CmCloud\n │ ├── NamedUser\n │ └── WebAdmin\n └── log\n └── CodeMeter 更改为 data\/ 目录所在的 data.tar.gz 文件被解压： $ cd data\/ 现在将整个目录复制到目标设备的根目录： 如果您犯了错误，那么此步骤可能会使您的目标设备无法使用，您将不得不重置它。 $ sudo cp -r etc\/* \/etc\n$ sudo cp -r lib\/* \/lib\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var 现在，Codemeter 包将执行一些安装后步骤来完成安装。手动执行这些步骤： $ sudo udevadm trigger -vn --subsystem-match=usb --attr-match=idVendor=064f | xargs -rn1 -d\\\\n udevadm trigger -b\n$ sudo mkdir -p \"\/etc\/systemd\/system\/multi-user.target.wants\/\"\n$ sudo ln -sT \/lib\/systemd\/system\/codemeter.service \/etc\/systemd\/system\/multi-user.target.wants\/codemeter.service 现在你需要使用以下命令设置 Codemeter 服务（启动为 root )： CodemeterLin -x\n Codemeter Lite 和运行时系统的安装现已完成。 " }, 
{ "title" : "手动安装边缘网关： ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4604985458336033589650100426", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 在没有包管理器的情况下安装 SL 产品 \/ 手动安装边缘网关： ", 
"snippet" : "您可以按照与运行时系统和 Codemeter 相同的方式安装边缘网关。 在 Windows PC 上，包存储在 <user>\/CODESYS Edge Gateway for Linux\/Delivery\/codesysedge_edgeamd64_<Version>.deb . 将 Debian 软件包复制到目标设备上的一个新的空文件夹中。 解压 Debian 软件包： $ ar -x codesysedge_edgeamd64_<Version>.deb 文件 control.tar.gz , data.tar.gz 和 debian-binary 被提取。 打开包装 data.tar.g...", 
"body" : "您可以按照与运行时系统和 Codemeter 相同的方式安装边缘网关。 在 Windows PC 上，包存储在 <user>\/CODESYS Edge Gateway for Linux\/Delivery\/codesysedge_edgeamd64_<Version>.deb . 将 Debian 软件包复制到目标设备上的一个新的空文件夹中。 解压 Debian 软件包： $ ar -x codesysedge_edgeamd64_<Version>.deb 文件 control.tar.gz , data.tar.gz 和 debian-binary 被提取。 打开包装 data.tar.gz 将文件放入新创建的文件夹中： $ mkdir data\n$ tar -xf data.tar.gz -C data 之后，二进制文件和其他文件（例如库和脚本）可在 data\/ : data\n├── etc\n│ ├── default\n│ │ └── codesysedge\n│ ├── init.d\n│ │ └── codesysedge\n│ └── codesysedge\n│ ├── Gateway.cfg\n│ ├── GatewayvControl.cfg\n│ └── Gateway_User.cfg\n├── opt\n│ └── codesysedge\n│ ├── bin\n│ │ └── codesysedge.bin\n│ ├── lib\n│ └── scripts\n│ ├── rts_set_baud.sh\n│ └── startup.sh\n├── usr\n│ └── share\n\n│ └── doc\n│ └── codesysedge\n│ └── copyright\n└── var\n └── opt\n └── codesysedge 更改为 data\/ 目录所在的 data.tar.gz 文件被解压： $ cd data\/ 现在将整个目录复制到目标设备的根目录： 如果您犯了错误，那么此步骤可能会使您的目标设备无法使用，您将不得不重置它。 $ sudo cp -r etc\/* \/etc\n$ sudo cp -r opt\/* \/opt\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var 再次执行包管理器的后处理步骤： $ chmod a+rw \/etc\/codesysedge\/Gateway.cfg\n$ chmod a+rw \/etc\/codesysedge\/Gateway_User.cfg 边缘网关现已安装。 " }, 
{ "title" : "启动 Codemeter、运行时系统和边缘网关 ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4554611316182433589650574679", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 在没有包管理器的情况下安装 SL 产品 \/ 启动 Codemeter、运行时系统和边缘网关 ", 
"snippet" : "现在可以启动已安装的包： Codemeter $ sudo \/usr\/sbin\/CodeMeterLin 您可以使用以下命令启动 Codemeter -v 标志以获得扩展输出。 随着输入 -Help ，您将获得有关更多功能的帮助。 运行时系统和边缘网关 $ sudo \/etc\/init.d\/codesyscontrol start $ sudo \/etc\/init.d\/codesysedge start...", 
"body" : "现在可以启动已安装的包： Codemeter $ sudo \/usr\/sbin\/CodeMeterLin 您可以使用以下命令启动 Codemeter -v 标志以获得扩展输出。 随着输入 -Help ，您将获得有关更多功能的帮助。 运行时系统和边缘网关 $ sudo \/etc\/init.d\/codesyscontrol start\n$ sudo \/etc\/init.d\/codesysedge start " }, 
{ "title" : "正在安装 CODESYS TargetVisu for Linux SL 没有包管理器 ", 
"url" : "_rtsl_targetvisu_installation_without_pm.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 正在安装 CODESYS TargetVisu for Linux SL 没有包管理器 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "在目标设备上手动安装运行时系统 ", 
"url" : "_rtsl_targetvisu_installation_without_pm.html#UUID-b70db7d9-478d-5a8c-9e0b-7e2599f42fe7_section-idm4590635748291233589649632523", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 正在安装 CODESYS TargetVisu for Linux SL 没有包管理器 \/ 在目标设备上手动安装运行时系统 ", 
"snippet" : "安装后 CODESYS Control​ for Linux 软件包，所需的文件位于 Windows 电脑上： <user>\/CODESYS TargetVisu for Linux SL\/Delivery\/visualization<architecture>\/codesysvisualization_visualizationamd64_4.13.0.0_amd64.deb 将这些文件复制到目标设备。 打开包装： $ ar -x codesyscontrol_linux_<Version> 创建了以下文件： control.tar.gz ：包含软件包管理器在安装或卸载前后运行的脚本。这与手...", 
"body" : "安装后 CODESYS Control​ for Linux 软件包，所需的文件位于 Windows 电脑上： <user>\/CODESYS TargetVisu for Linux SL\/Delivery\/visualization<architecture>\/codesysvisualization_visualizationamd64_4.13.0.0_amd64.deb 将这些文件复制到目标设备。 打开包装： $ ar -x codesyscontrol_linux_<Version> 创建了以下文件： control.tar.gz ：包含软件包管理器在安装或卸载前后运行的脚本。这与手动安装无关。 data.tar.gz ：包含运行时系统二进制文件、库、启动脚本和配置 debian-binary : 指定 .deb 包的版本。这与手动安装无关。 打开包装 data.tar.gz 文件。事先为此创建一个新文件夹： $ mkdir data\n$ tar -xf data.tar.gz -C data 在 data\/ ，您现在将找到对运行时系统的操作很重要的文件： data\n├── etc\n│ └── codesysvisualization\n│ ├── CODESYSVisualization.cfg\n│ ├── CODESYSVisualizationTV.cfg\n│ └── CODESYSVisualization_User.cfg\n├── opt\n│ └── codesysvisualization\n│ ├── bin\n│ │ └── codesysvisualization.bin\n│ └── codesysvisualization.service\n├── usr\n│ └── share\n│ └── doc\n│ └── codesysvisualization\n│ └── copyright\n└── var \n └── opt \n └── codesysvisualization\n 现在，包管理器 (dpkg) 通常会将此目录结构复制到系统的根目录中。这必须在没有包管理器的情况下手动完成： 更改为 data\/ 目录所在的 data.tar.gz 文件被解压： $ cd data\/ 将各个目录复制到目标的相应根目录： 如果您犯了错误，那么此步骤可能会使您的目标设备无法使用，您将不得不重置它。 $ sudo cp -r etc\/* \/etc\n$ sudo cp -r opt\/* \/opt\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var 现在包管理器将执行一些安装后步骤来完成安装。手动执行这些步骤： $ sudo chmod a+rw \/etc\/codesysvisualization\/CODESYSVisualization.cfg\n$ sudo chmod a+rw \/etc\/codesysvisualization\/CODESYSVisualization_User.cfg 如果 codesysvisualization 目标设备上尚不存在群组，然后将其添加。 $ groupadd codesysvisualization 创建其他文件夹并准备服务。 $ mkdir -p .config\/systemd\/user\/\n$ cp \/opt\/codesysvisualization\/codesysvisualization.service .config\/systemd\/user\/\n$ mkdir -p .config\/systemd\/user\/graphical.target.wants\/\n$ ln -s .config\/systemd\/user\/codesysvisualization.service .config\/systemd\/user\/graphical.target.wants\/. 设置目录的权限和用户。 $ sudo chmod -R u+x \/etc\/codesysvisualization\/\n$ sudo chmod 740 \/opt\/codesysvisualization\/bin\/codesysvisualization.bin\n$ sudo chmod 640 ~\/.config\/systemd\/user\/codesysvisualization.service\n$ sudo chmod -R 640 \/var\/opt\/codesysvisualization\/\n$ sudo chmod -R u+X \/var\/opt\/codesysvisualization\/\n$ sudo chmod 640 \/usr\/share\/doc\/codesysvisualization\/copyright\n$ sudo chown --recursive <USER> \/var\/opt\/codesysvisualization\n$ sudo chown --recursive <USER> \/opt\/codesysvisualization\/\n$ sudo chown --recursive <USER> \/etc\/codesysvisualization\/\n$ sudo chown --recursive <USER> .config\/systemd\/ " }, 
{ "title" : "在没有包管理器的情况下安装许可证服务器 ", 
"url" : "_rtsl_licenseserver_installation_without_pm.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 在没有包管理器的情况下安装许可证服务器 ", 
"snippet" : "要求：设备上安装了 Codemeter Runtime。 有关在不使用包管理器的情况下安装 Codemeter 的更多信息，请参阅： 在目标设备上手动安装 Codemeter 运行时环境CODESYS WBM 只能与驾驶舱一起使用。您的计算机还必须同时连接到目标设备和互联网。...", 
"body" : "要求：设备上安装了 Codemeter Runtime。 有关在不使用包管理器的情况下安装 Codemeter 的更多信息，请参阅： 在目标设备上手动安装 Codemeter 运行时环境CODESYS WBM 只能与驾驶舱一起使用。您的计算机还必须同时连接到目标设备和互联网。 " }, 
{ "title" : "如果 Cockpit 未安装且\/或无法安装： ", 
"url" : "_rtsl_licenseserver_installation_without_pm.html#UUID-9309cb91-08d3-fde6-39f2-4317ba0b2561_section-idm234676479498753", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 在没有包管理器的情况下安装许可证服务器 \/ 如果 Cockpit 未安装且\/或无法安装： ", 
"snippet" : "您需要手动设置许可证服务器、创建软容器并导入许可证。 设置许可证服务器 停止 Codemeter： sudo \/etc\/init.d\/codemeter stop 切换到网络服务器。 为此，你需要设置值 IsNetworkServer 到 1 英寸 \/etc\/wibu\/CodeMeter\/Server.ini : IsNetworkServer=1 保存更改并启动 Codemeter： sudo \/etc\/init.d\/codemeter start 创建软容器 检查软容器是否已经存在： cmu -x | grep 'FC=6000437' 如果列出了某个条目，则可以跳过此部分，因为软容器已经...", 
"body" : "您需要手动设置许可证服务器、创建软容器并导入许可证。 设置许可证服务器 停止 Codemeter： sudo \/etc\/init.d\/codemeter stop 切换到网络服务器。 为此，你需要设置值 IsNetworkServer 到 1 英寸 \/etc\/wibu\/CodeMeter\/Server.ini : IsNetworkServer=1 保存更改并启动 Codemeter： sudo \/etc\/init.d\/codemeter start 创建软容器 检查软容器是否已经存在： cmu -x | grep 'FC=6000437' 如果列出了某个条目，则可以跳过此部分，因为软容器已经存在。 解压许可证服务器 Debian 软件包。 此包通常包含在 CODESYS 许可证服务器的软件包。这包含一个文件 .UFC_SoftContainer_CmRuntime.WibuCmLif 在 \/opt\/codesyslicenseserver\/bin 。将其传输到许可证服务器应运行的设备上。 创建软容器： cmu --import --file .UFC_SoftContainer_CmRuntime.WibuCmLif 检查命令是否 cmu -x | grep 'FC=6000437' 返回一个条目。 导入许可证 使用这个命令 cmu -x 检测应进口许可证的软容器的序列号。 Create the context file: cmu -c 6000437 -s <serial number> --file <file name>.WibuCmRaC Transfer the context file to a device with Internet access. 打开地址 https:\/\/license.codesys.com\/ 然后输入牌照的号码。点击 下一页 和 激活许可证 在下一页上。 然后选择所需的容器类型。 点击 基于文件的许可证转移 链接在下一页的右侧。 上传之前生成的上下文文件，然后单击 立即开始激活 。 下载许可证更新文件并将该文件传输到将充当许可证服务器的设备上。 Import the file: cmu --import --file <file name>.WibuCmRaU The license is now activated. " }, 
{ "title" : "If Cockpit is installed ", 
"url" : "_rtsl_licenseserver_installation_without_pm.html#UUID-9309cb91-08d3-fde6-39f2-4317ba0b2561_section-idm234676479776826", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 在没有包管理器的情况下安装许可证服务器 \/ If Cockpit is installed ", 
"snippet" : "复制的文件 CODESYS WBM 进入系统： 解压 Debian 软件包 codesyswbmbase 并复制位于中的文件 \/usr\/share\/cockpit\/codesys_wbm 到系统上同一路径中的同名目录。 解压 Debian 软件包 codesyswbmlicensing 并复制位于中的文件 \/usr\/share\/cockpit\/codesys_wbm\/codesys_licensing 到系统上同一路径中的同名目录。 重启驾驶舱： systemctl restart cockpit.socket 现在，您应该能够通过浏览器在端口 9090 上访问 Cockpit 界面，并使用以...", 
"body" : "复制的文件 CODESYS WBM 进入系统： 解压 Debian 软件包 codesyswbmbase 并复制位于中的文件 \/usr\/share\/cockpit\/codesys_wbm 到系统上同一路径中的同名目录。 解压 Debian 软件包 codesyswbmlicensing 并复制位于中的文件 \/usr\/share\/cockpit\/codesys_wbm\/codesys_licensing 到系统上同一路径中的同名目录。 重启驾驶舱： systemctl restart cockpit.socket 现在，您应该能够通过浏览器在端口 9090 上访问 Cockpit 界面，并使用以下命令在那里执行许可流程 CODESYS WBM。 " }, 
{ "title" : "“虚拟游乐场” 场景：vPLC + 许可证服务器 + 边缘网关 ", 
"url" : "_rtsl_scenario_virtual_playground.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ “虚拟游乐场” 场景：vPLC + 许可证服务器 + 边缘网关 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "要求 ", 
"url" : "_rtsl_scenario_virtual_playground.html#UUID-135a713b-cb33-fd0c-80cc-22d356b14153_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ “虚拟游乐场” 场景：vPLC + 许可证服务器 + 边缘网关 \/ 要求 ", 
"snippet" : "硬件 还需要以下设备： 台式电脑配备 CODESYS 已安装 Linux PC（安装了 Docker 或 Podman、Python3 和 SSH 访问权限），此处称为 “Linux 主机 PC”。 以下附加产品必须安装在台式电脑上（使用 CODESYS 已安装）： CODESYS Virtual Edge Gateway for Linux 。 CODESYS Virtual Control for Linux SL CODESYS License Server for Linux SL...", 
"body" : "硬件 还需要以下设备： 台式电脑配备 CODESYS 已安装 Linux PC（安装了 Docker 或 Podman、Python3 和 SSH 访问权限），此处称为 “Linux 主机 PC”。 以下附加产品必须安装在台式电脑上（使用 CODESYS 已安装）： CODESYS Virtual Edge Gateway for Linux 。 CODESYS Virtual Control for Linux SL CODESYS License Server for Linux SL " }, 
{ "title" : "Linux 主机 ", 
"url" : "_rtsl_scenario_virtual_playground.html#UUID-135a713b-cb33-fd0c-80cc-22d356b14153_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ “虚拟游乐场” 场景：vPLC + 许可证服务器 + 边缘网关 \/ Linux 主机 ", 
"snippet" : "执行命令 工具 → 部署控制 SL 并建立与 Linux 主机 PC 的连接 ( 沟通 选项卡）。 有关更多信息，请参阅： 建立连接安装以下软件包\/映像的最新版本 ( 部署 选项卡）： CODESYS Virtual Edge Gateway for Linux CODESYS Virtual Control for Linux SL CODESYS License Server for Linux SL 有关更多信息，请参阅： Installing an image许可证服务器也可以在不同的主机系统上安装和运行（要求：Linux 操作系统）。从 Linux 主机 PC 到许可证服务器的通信通...", 
"body" : "执行命令 工具 → 部署控制 SL 并建立与 Linux 主机 PC 的连接 ( 沟通 选项卡）。 有关更多信息，请参阅： 建立连接安装以下软件包\/映像的最新版本 ( 部署 选项卡）： CODESYS Virtual Edge Gateway for Linux CODESYS Virtual Control for Linux SL CODESYS License Server for Linux SL 有关更多信息，请参阅： Installing an image许可证服务器也可以在不同的主机系统上安装和运行（要求：Linux 操作系统）。从 Linux 主机 PC 到许可证服务器的通信通过 TCP\/IP 协议进行 创建所需的实例并对其进行配置。 inux 主机 PC 上需要网关和 PLC 的实例。 操作 选项卡，按如下方式创建实例： 为网关安装实例 在 VPLC 部分，单击 按钮。 这个 添加新实例 对话框打开。 在 姓名 字段，指定名称（例如： vGateway ）。 在 筛选 列表框，选择 网关 价值。 选择适用于 Linux 的 CODESYS 虚拟边缘网关镜像的最新版本。 然后点击 好吧 。 新实例列在 VPLC 部分。 安装 vPLC 的实例 在 VPLC 部分，单击 按钮。 这个 添加新实例 对话框打开。 在 姓名 字段，指定名称（例如： vPLC1 ）。 在 筛选 列表框，选择 运行时间 价值。 选择最新版本的 CODESYS Virtual Control for Linux SL 图片。 然后点击 好吧 。 新实例列在 VPLC 部分。 在下面 许可证服务器 ，指定许可证服务器的 IP 地址。在显示的示例中，这是 Linux 主机 PC 的 IP 地址。 点击 保存 确认更改。 这些设置应用于 Linux 主机 PC 上。 可选：对其他 vPLC 实例重复这些步骤。 更多信息请参阅 “创建实例”。 启动虚拟实例。 在 VPLC 部分，单击 全部启动 按钮启动所有实例。 在 州 列中，所有虚拟实例的状态更改为 跑步 。 从现在起，可以像普通 PLC 一样通过以下方式访问和编程正在运行的虚拟 PLC 实例 CODESYS 。连接是通过已设置的 “vGateway” 建立的 如果没有有效的许可证，PLC 将在演示模式（2 小时运行时间）下运行。 " }, 
{ "title" : "安装许可证 ", 
"url" : "_rtsl_scenario_virtual_playground.html#UUID-135a713b-cb33-fd0c-80cc-22d356b14153_section-idm234664177345706", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ “虚拟游乐场” 场景：vPLC + 许可证服务器 + 边缘网关 \/ Linux 主机 \/ 安装许可证 ", 
"snippet" : "运行 PLC 的许可证可以从以下地址获得 CODESYS Store International 并安装在许可证服务器上。 有关更多信息，请参阅： 激活网络许可证...", 
"body" : "运行 PLC 的许可证可以从以下地址获得 CODESYS Store International 并安装在许可证服务器上。 有关更多信息，请参阅： 激活网络许可证" }, 
{ "title" : "场景：使用 VLAN 进行虚拟控制 ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：使用 VLAN 进行虚拟控制 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "要求 ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：使用 VLAN 进行虚拟控制 \/ 要求 ", 
"snippet" : "场景 成功设置 “虚拟游乐场” 场景：vPLC + 许可证服务器 + 边缘网关至少两个实例 CODESYS Virtual Control for Linux SL （在这个例子中， vPLC1 和 vPLC2 ) 硬件 支持 VLAN 的交换机 现场总线设备（基于以太网），例如 Profinet...", 
"body" : "场景 成功设置 “虚拟游乐场” 场景：vPLC + 许可证服务器 + 边缘网关至少两个实例 CODESYS Virtual Control for Linux SL （在这个例子中， vPLC1 和 vPLC2 ) 硬件 支持 VLAN 的交换机 现场总线设备（基于以太网），例如 Profinet " }, 
{ "title" : "配置交换机 ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：使用 VLAN 进行虚拟控制 \/ 配置交换机 ", 
"snippet" : "如果您的设备配置不正确，则可能会无法访问该设备。 将适配器（应在其中定义 VLAN）连接到交换机。在本示例中，向以下适配器添加了两个 VLAN 接口： enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000     link\/ether f0:b2:b9:11:b8:b3 brd ff:ff:ff:ff:ff:ff     inet 192.168.2.2\/24 brd 192.168.2.255 scope global noprefixroute enp1s0 ...", 
"body" : "如果您的设备配置不正确，则可能会无法访问该设备。 将适配器（应在其中定义 VLAN）连接到交换机。在本示例中，向以下适配器添加了两个 VLAN 接口： enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\n    link\/ether f0:b2:b9:11:b8:b3 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.2.2\/24 brd 192.168.2.255 scope global noprefixroute enp1s0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::2e96:178c:586a:b97b\/64 scope link noprefixroute\n       valid_lft forever preferred_lft forever 打开交换机的配置界面。有关如何打开接口和凭证的说明，请参阅供应商的说明。 登录后，打开 VLAN 的配置页面。如果您的交换机支持不同的协议，则选择 802.1Q VLAN 。 在 Port Config 页面，配置 Link Type 先前连接的端口为 Trunk 。 将所有现场总线设备连接到交换机。 在 VLAN Config 页面，添加两个新 VLAN。在本示例中，您使用的是 VLAN ID 100 和 200。添加先前连接的端口并配置为 Trunk 到每个 VLAN。将现场总线设备的端口添加到每个 VLAN 在以下示例配置中，控制器与交换机的连接是在端口 14 上建立的。这个 Link Type 此端口的已配置为 Trunk 。现场总线设备分别连接到端口 11 和端口 12 VLAN ID 描述 端口 100 VLAN 100 11, 14 200 VLAN 200 12, 14 " }, 
{ "title" : "配置 VLAN 接口 ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm234821994565272", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：使用 VLAN 进行虚拟控制 \/ 配置 VLAN 接口 ", 
"snippet" : "在永久更改网络配置之前，应测试设置并根据需要进行修改。 创建类型为的新适配器 VLAN 。 该命令的格式如下： sudo ip link add link <physical_adapter> name <virtual_adapter_name> type vlan id <vlan_id> 惯例是将 VLAN ID 附加到虚拟适配器的名称中。对于上面显示的适配器和交换机配置，命令如下所示： sudo ip link add link enp1s0 name enp1s0.100 type vlan id 100 替换 enp1s0 以及系统上带有值的 VLAN ID。 现在当你跑的时候 i...", 
"body" : "在永久更改网络配置之前，应测试设置并根据需要进行修改。 创建类型为的新适配器 VLAN 。 该命令的格式如下： sudo ip link add link <physical_adapter> name <virtual_adapter_name> type vlan id <vlan_id> 惯例是将 VLAN ID 附加到虚拟适配器的名称中。对于上面显示的适配器和交换机配置，命令如下所示： sudo ip link add link enp1s0 name enp1s0.100 type vlan id 100 替换 enp1s0 以及系统上带有值的 VLAN ID。 现在当你跑的时候 ip a ，你应该看到类似以下的输出： enp1s0.100@enp1s0: <BROADCAST,MULTICAST,PROMISC> mtu 1500 qdisc noop state DOWN group default qlen 1000 同时对第二个 VLAN 执行此命令。 " }, 
{ "title" : "测试配置 ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm234822002492998", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：使用 VLAN 进行虚拟控制 \/ 测试配置 ", 
"snippet" : "打开 CODESYS Control SL Deploy Tool 并与您的控制器建立连接。 有关更多信息，请参阅： 建立连接。 切换到 操作 选项卡，然后选择 vPLC1 实例。 在右侧的配置视图中，单击 Nic 直线，然后在右边缘单击 按钮。 Nic 配置对话框打开。 在可用适配器列表中，单击 enp1s0.100 然后选择 映射到实例 选项。 如有必要，配置 IP 地址和网络掩码。网络掩码采用 CIDR 表示法的格式（例如： 24 ）。 有关更多信息，请参阅： https:\/\/en.wikipedia.org\/wiki\/Classless_Inter-Domain_Routing 点击 ...", 
"body" : "打开 CODESYS Control SL Deploy Tool 并与您的控制器建立连接。 有关更多信息，请参阅： 建立连接。 切换到 操作 选项卡，然后选择 vPLC1 实例。 在右侧的配置视图中，单击 Nic 直线，然后在右边缘单击 按钮。 Nic 配置对话框打开。 在可用适配器列表中，单击 enp1s0.100 然后选择 映射到实例 选项。 如有必要，配置 IP 地址和网络掩码。网络掩码采用 CIDR 表示法的格式（例如： 24 ）。 有关更多信息，请参阅： https:\/\/en.wikipedia.org\/wiki\/Classless_Inter-Domain_Routing 点击 好吧 和 保存 按钮。 选择 vPLC2 实例并使用执行步骤 3-6 enp1s0.200 适配器。 在控制器上启动实例和网关。 有关更多信息，请参阅： 启动运行时系统一个小型应用程序加载到两个实例上，以检查网络的功能。有关更多信息，请参阅： 下载并启动 " }, 
{ "title" : "保留适配器配置 ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm234821994914623", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：使用 VLAN 进行虚拟控制 \/ 保留适配器配置 ", 
"snippet" : "如果你的配置正确，你仍然需要永久保存。有关如何永久保存交换机配置的说明，请参阅供应商的说明。两个实例的配置 vPLC1 和 vPLC2 已经持续存在了。在这里你只需要设置 自动启动 设置为 是的 。 以下步骤介绍如何在控制器上配置两个 VLAN 适配器，以便它们在系统启动时可用。 这些设置可能会对您的系统造成损害。 创建所有重要文件的备份。 复制所有事先修改过的文件，这样您就可以轻松撤消更改。 打开 \/etc\/network\/interfaces 在编辑器中（例如： sudo nano \/etc\/network\/interfaces ）。 添加以下几行（修改控制器的适配器名称和 VLAN ID...", 
"body" : "如果你的配置正确，你仍然需要永久保存。有关如何永久保存交换机配置的说明，请参阅供应商的说明。两个实例的配置 vPLC1 和 vPLC2 已经持续存在了。在这里你只需要设置 自动启动 设置为 是的 。 以下步骤介绍如何在控制器上配置两个 VLAN 适配器，以便它们在系统启动时可用。 这些设置可能会对您的系统造成损害。 创建所有重要文件的备份。 复制所有事先修改过的文件，这样您就可以轻松撤消更改。 打开 \/etc\/network\/interfaces 在编辑器中（例如： sudo nano \/etc\/network\/interfaces ）。 添加以下几行（修改控制器的适配器名称和 VLAN ID）： # enp1s0.100 vlan (vPLC1)\nauto enp1s0.100\niface enp1s0.100 inet dhcp\n    vlan-raw-device enp1s0\n# enp1s0.200 vlan (vPLC2)\nauto enp1s0.200\niface enp1s0.200 inet dhcp\n    vlan-raw-device enp1s0 有关此文件的更多信息，请参阅： https:\/\/wiki.debian.org\/NetworkConfiguration 重启系统或执行命令 sudo systemctl restart networking 以使更改生效。 这种配置方法在 Debian 12 上进行了测试。您可能需要为设备或操作系统选择不同的方法才能永久保存配置 其他例子是 netplan ( https:\/\/netplan.readthedocs.io\/en\/stable\/structure-id\/ ) 或网络管理器 ( https:\/\/networkmanager.dev\/ ）。控制器的相应说明可以在相应的文档中找到。 " }, 
{ "title" : "“使用现场总线进行虚拟” 场景：vPLC + 许可证服务器 + 边缘网关 + 现场总线 ", 
"url" : "_rtsl_scenario_virtual_fieldbus.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ “使用现场总线进行虚拟” 场景：vPLC + 许可证服务器 + 边缘网关 + 现场总线 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "要求 ", 
"url" : "_rtsl_scenario_virtual_fieldbus.html#UUID-8d90cd73-67b3-e75d-2d43-8f604bccd457_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ “使用现场总线进行虚拟” 场景：vPLC + 许可证服务器 + 边缘网关 + 现场总线 \/ 要求 ", 
"snippet" : "场景 成功设置 “虚拟游乐场” 场景：vPLC + 许可证服务器 + 边缘网关硬件 还需要以下设备： 现场总线设备（基于以太网），例如 Profinet。...", 
"body" : "场景 成功设置 “虚拟游乐场” 场景：vPLC + 许可证服务器 + 边缘网关硬件 还需要以下设备： 现场总线设备（基于以太网），例如 Profinet。 " }, 
{ "title" : "配置现场总线 ", 
"url" : "_rtsl_scenario_virtual_fieldbus.html#UUID-8d90cd73-67b3-e75d-2d43-8f604bccd457_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ “使用现场总线进行虚拟” 场景：vPLC + 许可证服务器 + 边缘网关 + 现场总线 \/ 配置现场总线 ", 
"snippet" : "将用于现场总线连接的以太网适配器分配给虚拟 PLC 实例，如下所示： 在 VPLC 部分，选择所需的 vPLC 实例，然后单击 停止选中 。 PLC 的状态更改为 “已停止”。相应的设置显示在 设置 。 在下面 尼克 ，选择用于现场总线连接的 Linux 主机 PC 的网络适配器。如有必要，分配 IP 地址和网络掩码。 点击 保存 确认更改。 这些设置应用于 Linux 主机 PC 上。 点击 启动选定项 启动 vPLC 实例。 PLC 的状态更改为 “正在运行”。 网络适配器现在仅分配给已配置的 vPLC，在 Linux 主机 PC 上不再可用。现在可以通过以下方式配置和照常使用现场总线 C...", 
"body" : "将用于现场总线连接的以太网适配器分配给虚拟 PLC 实例，如下所示： 在 VPLC 部分，选择所需的 vPLC 实例，然后单击 停止选中 。 PLC 的状态更改为 “已停止”。相应的设置显示在 设置 。 在下面 尼克 ，选择用于现场总线连接的 Linux 主机 PC 的网络适配器。如有必要，分配 IP 地址和网络掩码。 点击 保存 确认更改。 这些设置应用于 Linux 主机 PC 上。 点击 启动选定项 启动 vPLC 实例。 PLC 的状态更改为 “正在运行”。 网络适配器现在仅分配给已配置的 vPLC，在 Linux 主机 PC 上不再可用。现在可以通过以下方式配置和照常使用现场总线 CODESYS 。 " }, 
{ "title" : "“安全屋” 场景：vPLC + vSafe + ProfiSafe + 时间提供商 + 许可证服务器 ", 
"url" : "_rtsl_scenario_safe_house.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ “安全屋” 场景：vPLC + vSafe + ProfiSafe + 时间提供商 + 许可证服务器 ", 
"snippet" : "以下页面上的文档仅供参考。有关限制和安全或认证信息，请查阅您正在编程的设备制造商的安全文档。...", 
"body" : "以下页面上的文档仅供参考。有关限制和安全或认证信息，请查阅您正在编程的设备制造商的安全文档。 " }, 
{ "title" : "要求 ", 
"url" : "_rtsl_scenario_safe_house.html#UUID-8c70494a-5eac-cd26-0994-8e503c1ca9ab_section-idm234653932399925", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ “安全屋” 场景：vPLC + vSafe + ProfiSafe + 时间提供商 + 许可证服务器 \/ 要求 ", 
"snippet" : "场景： 此场景的要求是成功设置 “使用现场总线进行虚拟” 场景：vPLC + 许可证服务器 + 边缘网关 + 现场总线。 硬件 还需要以下设备： 台式电脑配备 CODESYS Development System 已安装 安装了虚拟边缘网关、虚拟 PLC 1 和许可证服务器的 Linux 主机 PC 还需要以下附加设备： 时间提供者的主机，在图中命名为 Linux Host PC 2。此主机的要求：必须安装 Linux 操作系统和 Docker 并配置 SSH。 Real-time capable network to the Linux Host PC to ensure determini...", 
"body" : "场景： 此场景的要求是成功设置 “使用现场总线进行虚拟” 场景：vPLC + 许可证服务器 + 边缘网关 + 现场总线。 硬件 还需要以下设备： 台式电脑配备 CODESYS Development System 已安装 安装了虚拟边缘网关、虚拟 PLC 1 和许可证服务器的 Linux 主机 PC 还需要以下附加设备： 时间提供者的主机，在图中命名为 Linux Host PC 2。此主机的要求：必须安装 Linux 操作系统和 Docker 并配置 SSH。 Real-time capable network to the Linux Host PC to ensure deterministic transmission of data packages. 附加产品 CODESYS 虚拟安全控制 SL 必须安装在台式电脑上。 " }, 
{ "title" : "Linux 主机 PC 2 ", 
"url" : "_rtsl_scenario_safe_house.html#UUID-8c70494a-5eac-cd26-0994-8e503c1ca9ab_section-idm2346539369198", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ “安全屋” 场景：vPLC + vSafe + ProfiSafe + 时间提供商 + 许可证服务器 \/ Linux 主机 PC 2 ", 
"snippet" : "在 Linux 主机 PC 2 上，设置时间提供商。 时间提供器将当前时间发送到已配置的目的地，可用于提供虚拟安全控制 SL 所需的第二次时间。 执行命令 工具 → 部署控制 SL 并建立与 Linux 主机 PC 2 的连接 ( 沟通 选项卡）。 有关更多信息，请参阅： 建立连接安装以下镜像的最新版本 ( 部署 选项卡）： CODESYS 虚拟安全时间提供商 有关更多信息，请参阅： Installing an image点击 部署 选项卡。 在 产品 列表框，选择 CODESYS 虚拟安全时间提供商 SL 。 在 版本 列表框中，选择最新版本。 点击 安装 按钮。 CODESYS 虚拟安全时...", 
"body" : "在 Linux 主机 PC 2 上，设置时间提供商。 时间提供器将当前时间发送到已配置的目的地，可用于提供虚拟安全控制 SL 所需的第二次时间。 执行命令 工具 → 部署控制 SL 并建立与 Linux 主机 PC 2 的连接 ( 沟通 选项卡）。 有关更多信息，请参阅： 建立连接安装以下镜像的最新版本 ( 部署 选项卡）： CODESYS 虚拟安全时间提供商 有关更多信息，请参阅： Installing an image点击 部署 选项卡。 在 产品 列表框，选择 CODESYS 虚拟安全时间提供商 SL 。 在 版本 列表框中，选择最新版本。 点击 安装 按钮。 CODESYS 虚拟安全时间提供商 SL 图像显示在 已安装的映像 部分。 创建所需的实例。 在 Linux 主机 PC 2 上，需要时间提供者实例，您可以按如下方式在 操作 选项卡： 在 VPLC 部分，单击 按钮。 这个 添加新实例 对话框打开。 请指定 timeprovider 作为名字。 在 筛选 列表框，选择 Safety Timeprovider 。 选择最新版本的 CODESYS Virtual Safe Timeprovider SL 图片，然后点击 好吧 。 新实例列在 VPLC 部分。 配置实例： 必须将目标 IP 地址和目标端口配置为 timeprovider 实例。目标是 vHost 和端口 60000 默认情况下。 通用命令： -e TARGET_IP= [Linux 主机 PC 的 IP 或主机名] -e TARGET_PORT = 60000 60000 是虚拟安全控制 SL 从计时器接收外部时间源的默认端口。 自动启动 是的 什么时候 是的 选中后，每次启动系统时都会自动启动实例。 在 VPLC 部分，单击 timeprovider 实例。 的设置 timeprovider 实例显示在右侧。 TARGET_IP 和 TARGET_PORT 已经在 GenericCommands 下使用值预先分配了 vSafePLC1 和 60000 。 更改 TARGET_IP 到 Linux 主机 PC 的主机名或 IP 地址 1. 有关更多信息，请参阅： 检测网络地址在 自动启动 列表框，将值更改为 是的 。 点击 保存 按钮来保存更改。 有关更多信息，请参阅： 创建和配置新实例启动实例。 启动 timeprovider 通过在中进行选择来实现实例 VPLC 部分，然后单击 启动选定项 按钮。 在 州 列，所有实例的状态更改为 跑步 。 " }, 
{ "title" : "Linux 主机 ", 
"url" : "_rtsl_scenario_safe_house.html#UUID-8c70494a-5eac-cd26-0994-8e503c1ca9ab_section-idm234653987267355", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ “安全屋” 场景：vPLC + vSafe + ProfiSafe + 时间提供商 + 许可证服务器 \/ Linux 主机 ", 
"snippet" : "在 Linux 主机 PC 上，设置 CODESYS Virtual Safe Control for Linux SL 。 执行命令 工具 → 部署控制 SL 并建立与 Linux 主机 PC 2 的连接 ( 沟通 选项卡）。 切换到 操作 选项卡。 安装以下镜像的最新版本 ( 部署 选项卡）： CODESYS 虚拟安全控制 SL 创建所需的实例。 在 Linux 主机 PC 1 上，需要 vsafePLC 实例，您可以按如下方式在 操作 选项卡： 在 VPLC 部分，单击 按钮。 这个 添加新实例 对话框打开。 请指定 vSafePLC 作为名字。 在 筛选 列表框，选择 安全运行系统 。...", 
"body" : "在 Linux 主机 PC 上，设置 CODESYS Virtual Safe Control for Linux SL 。 执行命令 工具 → 部署控制 SL 并建立与 Linux 主机 PC 2 的连接 ( 沟通 选项卡）。 切换到 操作 选项卡。 安装以下镜像的最新版本 ( 部署 选项卡）： CODESYS 虚拟安全控制 SL 创建所需的实例。 在 Linux 主机 PC 1 上，需要 vsafePLC 实例，您可以按如下方式在 操作 选项卡： 在 VPLC 部分，单击 按钮。 这个 添加新实例 对话框打开。 请指定 vSafePLC 作为名字。 在 筛选 列表框，选择 安全运行系统 。 然后选择最新版本的 CODESYS Virtual Safe Control for Linux SL 图片。 然后点击 好吧 。 新实例列在 VPLC 部分。 连同您在上一个场景中在此设备上创建的实例一起，以下实例现在应该在 VPLCs 部分： 实例 州 产品 虚拟网关 已停止 网关 vPLC 已停止 运行时系统 vSAFEPLC 已停止 安全运行系统 检查以下条目是否可用 Services 部分： 产品 州 适用于 Linux 的 CODESYS 许可证服务器 SL 跑步 在重新配置之前，单击 全部停止 按钮停止实例。 所有实例的状态都更改为 已停止 。 在 VPLC 部分，单击 vSafePLC 实例。 的设置 vSafePLC 实例显示在右侧。 配置 vSafePLC 实例如下： 端口： 60000:60000 \/udp 这是虚拟安全控制 SL 从时间提供者接收外部时间源的默认端口 Ipc: 容器：vPLC 访问 vPLC 实例的 IPC 命名空间，以便在这两个实例之间进行通信。 依赖关系： vPLC 必须先启动 vPLC，因为这会创建此实例想要加入的 IPC 命名空间。依赖关系将确保正确的起始顺序。 在 VPLC 部分，单击 vPLC 实例。 vsafePLC 实例的设置显示在右侧。 配置 vPLC 实例如下： IPC: 可共享 为该容器创建 IPC 命名空间，可供其他容器使用。在这种情况下，vsafePLC 实例应加入以进行这两个实例之间的通信 启动实例。 在 VPLC 部分，单击 全部启动 按钮启动所有实例。 在 州 列，所有实例的状态更改为 跑步 。 检查配置。 为确保时间提供者的时间按照所需和配置到达 vSafePLC，可以在实例日志中进行检查。 要执行此操作，请选择 vSafePLCs 中的实例 VPLC 部分。 在 行动 右上角的部分，单击 显示日志 按钮。 这个 运行时系统日志 窗口打开。 这条消息 External Time Provider found 存在于日志中。 所有必需的设备现已准备就绪。中描述了创建项目和集成 ProfiSafe 的后续步骤 CODESYS 安全扩展 文档。 " }, 
{ "title" : "场景：“虚拟冗余”：一个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 ", 
"url" : "_rtsl_scenario_virtual_redundancy.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：“虚拟冗余”：一个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "要求 ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：“虚拟冗余”：一个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 \/ 要求 ", 
"snippet" : "场景 成功设置 “虚拟游乐场” 场景：vPLC + 许可证服务器 + 边缘网关至少有两个 vPLC 的场景。...", 
"body" : "场景 成功设置 “虚拟游乐场” 场景：vPLC + 许可证服务器 + 边缘网关至少有两个 vPLC 的场景。 " }, 
{ "title" : "容器网络的配置： ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：“虚拟冗余”：一个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 \/ 容器网络的配置： ", 
"snippet" : "为确保冗余功能，所用的控制器必须具有静态 IP 地址。如果 IP 地址发生变化，则无法自动重新建立与设备的连接。 必须通过所使用的容器引擎直接配置网络。为此，请通过 SSH 连接到您的 Linux 主机。 在终端中输入以下命令（IP地址、子网和网络名称可以自由选择）。 docker network create --subnet=192.168.5.0\/24 mynetwork...", 
"body" : "为确保冗余功能，所用的控制器必须具有静态 IP 地址。如果 IP 地址发生变化，则无法自动重新建立与设备的连接。 必须通过所使用的容器引擎直接配置网络。为此，请通过 SSH 连接到您的 Linux 主机。 在终端中输入以下命令（IP地址、子网和网络名称可以自由选择）。 docker network create --subnet=192.168.5.0\/24 mynetwork " }, 
{ "title" : "实例的配置 ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm23496702624416", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：“虚拟冗余”：一个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 \/ 实例的配置 ", 
"snippet" : "现在您需要为 vPLC 实例指定一个单独的 IP 地址并分配网络。 虚拟 PLC 1： 通用命令 --ip 192.168.5.1 实例的静态 IP 地址。通用命令 --ip 仅当实例位于具有相应子网的容器网络中时才允许。 网络 mynetwork 已配置实例的容器网络 虚拟 PLC 2： 通用命令： --ip 192.168.5。 2 实例的静态 IP 地址。通用命令 --ip 仅当实例位于具有相应子网的容器网络中时才允许。 网络： mynetwork 已配置实例的容器网络 然后还需要将虚拟边缘网关添加到网络中。 虚拟边缘网关： 网络 mynetwork 已配置实例的容器网络...", 
"body" : "现在您需要为 vPLC 实例指定一个单独的 IP 地址并分配网络。 虚拟 PLC 1： 通用命令 --ip 192.168.5.1 实例的静态 IP 地址。通用命令 --ip 仅当实例位于具有相应子网的容器网络中时才允许。 网络 mynetwork 已配置实例的容器网络 虚拟 PLC 2： 通用命令： --ip 192.168.5。 2 实例的静态 IP 地址。通用命令 --ip 仅当实例位于具有相应子网的容器网络中时才允许。 网络： mynetwork 已配置实例的容器网络 然后还需要将虚拟边缘网关添加到网络中。 虚拟边缘网关： 网络 mynetwork 已配置实例的容器网络 " }, 
{ "title" : "启动虚拟实例 ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm234967029997363", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：“虚拟冗余”：一个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 \/ 启动虚拟实例 ", 
"snippet" : "在 虚拟PLC 部分，点击 全部开始 按钮。配置的虚拟实例的状态更改为 Running 。 对于冗余功能，请按照说明进行操作 入门指南 – 配置冗余系统...", 
"body" : "在 虚拟PLC 部分，点击 全部开始 按钮。配置的虚拟实例的状态更改为 Running 。 对于冗余功能，请按照说明进行操作 入门指南 – 配置冗余系统 " }, 
{ "title" : "场景：“虚拟冗余”：两个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm234968298823991", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：“虚拟冗余”：一个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 \/ 场景：“虚拟冗余”：两个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "要求 ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43496829968904", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：“虚拟冗余”：一个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 \/ 场景：“虚拟冗余”：两个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 \/ 要求 ", 
"snippet" : "设想 成功设置 场景：“虚拟冗余”：一个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 场景。 硬件 还需要以下设备： 用于其他 vPLC 的主机，图中名为 Linux 主机 PC 2。此主机的要求 必须安装Linux操作系统和Docker并配置SSH。 实时网络可与 Linux 主机 PC 连接，确保时间敏感数据包的确定性传输。 两个系统上实例的额外配置。有关更多信息，请参阅： 实例的配置必须为相应主机上的两个实例进行以下内容配置。 端口 1205:1205 这是冗余通信的默认端口。您也可以在项目的冗余配置界面中更改此端口。但请注意，更改端口时也必须在相应实例的配置中进行。...", 
"body" : "设想 成功设置 场景：“虚拟冗余”：一个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 场景。 硬件 还需要以下设备： 用于其他 vPLC 的主机，图中名为 Linux 主机 PC 2。此主机的要求 必须安装Linux操作系统和Docker并配置SSH。 实时网络可与 Linux 主机 PC 连接，确保时间敏感数据包的确定性传输。 两个系统上实例的额外配置。有关更多信息，请参阅： 实例的配置必须为相应主机上的两个实例进行以下内容配置。 端口 1205:1205 这是冗余通信的默认端口。您也可以在项目的冗余配置界面中更改此端口。但请注意，更改端口时也必须在相应实例的配置中进行。 " }, 
{ "title" : "启动虚拟实例 ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43496830001058", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ 场景：“虚拟冗余”：一个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 \/ 场景：“虚拟冗余”：两个系统上的 vPLC + vPLC + 许可证服务器 + 边缘网关 \/ 要求 \/ 启动虚拟实例 ", 
"snippet" : "在 虚拟PLC 部分，点击 全部开始 按钮。配置的虚拟实例的状态更改为 Running 。 对于冗余功能，请按照说明进行操作 入门指南 – 配置冗余系统...", 
"body" : "在 虚拟PLC 部分，点击 全部开始 按钮。配置的虚拟实例的状态更改为 Running 。 对于冗余功能，请按照说明进行操作 入门指南 – 配置冗余系统 " }, 
{ "title" : "CODESYS TargetVisu for Linux SL ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ CODESYS TargetVisu for Linux SL ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "用例 ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412002576", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ CODESYS TargetVisu for Linux SL \/ 用例 ", 
"snippet" : "CODESYS TargetVisu for Linux SL 是一个独立的小型运行时系统，用于管理可视化的显示。 CODESYS TargetVisu for Linux SL 涵盖以下用例： CODESYS TargetVisu for Linux SL 可以通过不同的方式配置： 作为连接到另一个控制器的远程 TargetVisu 作为直接在控制器上运行的本地 TargetVisu 此用例不适合具有实时需求的控制器。 有关详细信息，请参阅：For more information, see: 性能优化与经典的目标可视化相比， CODESYS TargetVisu for Linux SL ...", 
"body" : "CODESYS TargetVisu for Linux SL 是一个独立的小型运行时系统，用于管理可视化的显示。 CODESYS TargetVisu for Linux SL 涵盖以下用例： CODESYS TargetVisu for Linux SL 可以通过不同的方式配置： 作为连接到另一个控制器的远程 TargetVisu 作为直接在控制器上运行的本地 TargetVisu 此用例不适合具有实时需求的控制器。 有关详细信息，请参阅：For more information, see: 性能优化与经典的目标可视化相比， CODESYS TargetVisu for Linux SL 具有以下优点： 各个过程是相互独立的。可视化中的错误不会自动导致机器停止运行。 由于可视化需要的组件较少，因此消耗的资源也较少。 所有沟通均通过 CODESYS 通信协议，因此是安全的。 " }, 
{ "title" : "要求 ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412127657", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ CODESYS TargetVisu for Linux SL \/ 要求 ", 
"snippet" : "为了能够使用 CODESYS TargetVisu for Linux SL ，您的系统必须满足以下要求： 系统上需要安装以下库： libqt6core6 libqt6gui6 libqt6widgets6 libqt6network6 libqt6svg6 libqt6webenginewidgets6 libqt6webenginecore6 libqt6webenginequick6 libqt6webview6 libqt6webviewquick6 libqt6qmlworkerscript6 libqt6quickshapes6 libqt6quickcontrols2-6 lib...", 
"body" : "为了能够使用 CODESYS TargetVisu for Linux SL ，您的系统必须满足以下要求： 系统上需要安装以下库： libqt6core6 libqt6gui6 libqt6widgets6 libqt6network6 libqt6svg6 libqt6webenginewidgets6 libqt6webenginecore6 libqt6webenginequick6 libqt6webview6 libqt6webviewquick6 libqt6qmlworkerscript6 libqt6quickshapes6 libqt6quickcontrols2-6 libqt6quickcontrols2impl6 libqt6quicktemplates2-6 必须在系统上安装桌面环境，例如： Xfce KDE gnome lxde 需要将物理显示器连接到目标设备。 尚未测试与 X-Forwarding 或类似程序的使用。 需要安装 Qt 6.4.2 或更高版本（例如至少 Debian 12 或 Ubuntu 23.10）。 " }, 
{ "title" : "使用 CODESYS TargetVisu for Linux SL 在项目中 ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412333472", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ CODESYS TargetVisu for Linux SL \/ 使用 CODESYS TargetVisu for Linux SL 在项目中 ", 
"snippet" : "为了使用 CODESYS TargetVisu for Linux SL ，您需要禁用 支持客户端动画和原生元素叠加 可视化管理器中的选项。 在设备树中，选择可视化管理器。 插入 远程目标视觉 位于其下方的物体。 在设备编辑器中打开远程 TargetVisu 并在那里定义所需的启动可视化。...", 
"body" : "为了使用 CODESYS TargetVisu for Linux SL ，您需要禁用 支持客户端动画和原生元素叠加 可视化管理器中的选项。 在设备树中，选择可视化管理器。 插入 远程目标视觉 位于其下方的物体。 在设备编辑器中打开远程 TargetVisu 并在那里定义所需的启动可视化。 " }, 
{ "title" : "安装 CODESYS TargetVisu for Linux SL 在目标设备上 ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412538107", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ CODESYS TargetVisu for Linux SL \/ 安装 CODESYS TargetVisu for Linux SL 在目标设备上 ", 
"snippet" : "点击 工具 → 部署控制 SL 菜单命令。 这个 部署控制 SL 选项卡打开。 建立与控制器的连接。 有关更多信息，请参阅： 连接到目标系统点击 部署 选项卡。 在 产品 列表框，选择 CODESYS TargetVisu for Linux SL 产品。 在 版本 列表框中，选择所需的版本。 点击 安装 按钮。 用于安装的帐户 CODESYS TargetVisu for Linux SL 必须与登录设备时使用的帐户相同。 CODESYS 检查是否已安装所有必需的库，以及 Qt 是否至少有上述指定的版本。在使用目标可视化之前，必须重新启动目标设备一次。...", 
"body" : "点击 工具 → 部署控制 SL 菜单命令。 这个 部署控制 SL 选项卡打开。 建立与控制器的连接。 有关更多信息，请参阅： 连接到目标系统点击 部署 选项卡。 在 产品 列表框，选择 CODESYS TargetVisu for Linux SL 产品。 在 版本 列表框中，选择所需的版本。 点击 安装 按钮。 用于安装的帐户 CODESYS TargetVisu for Linux SL 必须与登录设备时使用的帐户相同。 CODESYS 检查是否已安装所有必需的库，以及 Qt 是否至少有上述指定的版本。在使用目标可视化之前，必须重新启动目标设备一次。 " }, 
{ "title" : "故障排除 ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374413199442", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 用例 \/ CODESYS TargetVisu for Linux SL \/ 故障排除 ", 
"snippet" : "前 CODESYS TargetVisu for Linux SL 版本 4.13.0.0 本地登录失败 如果安装后登录时显示黑屏，然后再次显示登录屏幕，则可能存在错误 DISPLAY 已设置的环境变量。要检查这个，你可以清除 登录时设置 X 显示 + 用户 目标可视化配置对话框中的选项 CODESYS 。如果之后可以登录到目标设备，请检查的输出 echo $DISPLAY 。在中输入此值 \/etc\/default\/codesysvisualization 为了价值 XDISPLAY 然后再试一次。...", 
"body" : "前 CODESYS TargetVisu for Linux SL 版本 4.13.0.0 本地登录失败 如果安装后登录时显示黑屏，然后再次显示登录屏幕，则可能存在错误 DISPLAY 已设置的环境变量。要检查这个，你可以清除 登录时设置 X 显示 + 用户 目标可视化配置对话框中的选项 CODESYS 。如果之后可以登录到目标设备，请检查的输出 echo $DISPLAY 。在中输入此值 \/etc\/default\/codesysvisualization 为了价值 XDISPLAY 然后再试一次。 " }, 
{ "title" : "故障排除 ", 
"url" : "_rtsl_troubleshooting.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "编程系统\/IDE\/ Deploy Tool ", 
"url" : "_rtsl_toubleshooting_deploytool.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool ", 
"snippet" : "以下章节提供了解决基于 Linux 的 SL 产品的问题的说明，以及 CODESYS Development System 或者 Deploy Tool 。这个 Deploy Tool 是一个插件，可用于在 Linux 系统上安装基于 Linux 的 SL 产品。...", 
"body" : "以下章节提供了解决基于 Linux 的 SL 产品的问题的说明，以及 CODESYS Development System 或者 Deploy Tool 。这个 Deploy Tool 是一个插件，可用于在 Linux 系统上安装基于 Linux 的 SL 产品。 " }, 
{ "title" : "产品的安装以错误结束。 ", 
"url" : "_rtsl_toubleshooting_deploytool1.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 产品的安装以错误结束。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "要求 ", 
"url" : "_rtsl_toubleshooting_deploytool1.html#UUID-11b462c5-1f28-10cc-d2e1-e6130d87abc3_section-idm234790470711208", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 产品的安装以错误结束。 \/ 要求 ", 
"snippet" : "这个 CODESYS 安装包括特定产品 CODESYS 包装（及其依赖产品）。您可以在中概述已安装的产品 CODESYS Installer 在已安装的插件列表中。...", 
"body" : "这个 CODESYS 安装包括特定产品 CODESYS 包装（及其依赖产品）。您可以在中概述已安装的产品 CODESYS Installer 在已安装的插件列表中。 " }, 
{ "title" : "故障排除 ", 
"url" : "_rtsl_toubleshooting_deploytool1.html#UUID-11b462c5-1f28-10cc-d2e1-e6130d87abc3_section-idm234790470799509", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 产品的安装以错误结束。 \/ 故障排除 ", 
"snippet" : "安装过程中的错误可能是由目标设备引起的。常见错误是只读文件系统和过时或缺少依赖关系。 所有产品都希望其包裹存放在 CODESYS Installer 在安装插件时将其存储。 这个 Deploy Tool 对每个已安装的产品执行以下步骤： 停止运行时进程。 保存旧的配置文件。 删除现有软件包。 转移新包裹。 下面列出了其他特定产品的检查，其中 Deploy Tool 性能取决于产品。然后，软件包管理器尝试安装新传输的软件包： BeagleBoneBlack 不执行任何其他步骤或检查。 Edge Gateway 这个 Deploy Tool 检查设备是否具有 armv4、armv5 或 armv6...", 
"body" : "安装过程中的错误可能是由目标设备引起的。常见错误是只读文件系统和过时或缺少依赖关系。 所有产品都希望其包裹存放在 CODESYS Installer 在安装插件时将其存储。 这个 Deploy Tool 对每个已安装的产品执行以下步骤： 停止运行时进程。 保存旧的配置文件。 删除现有软件包。 转移新包裹。 下面列出了其他特定产品的检查，其中 Deploy Tool 性能取决于产品。然后，软件包管理器尝试安装新传输的软件包： BeagleBoneBlack 不执行任何其他步骤或检查。 Edge Gateway 这个 Deploy Tool 检查设备是否具有 armv4、armv5 或 armv6 架构。通过执行命令读取该值 uname -m 。 emPC 不执行任何其他步骤或检查。 IOT2000 不执行任何其他步骤或检查。 许可证服务器 这个 Deploy Tool 尝试安装当前版本的 Codemeter。如果 Codemeter 或 Codemeter Lite 安装的版本与预期版本相同或更新 Deploy Tool ，则不会对系统进行任何更改。如果需要升级或更改，则在对系统进行任何更改之前，将打开一个对话框提示您同意。如果您同意，则将删除当前安装的 Codemeter 版本并安装当前版本。 CODESYS 如果系统上未安装 Codemeter，则无法使用适用于 Linux SL 的许可证服务器。 这个 Deploy Tool 还允许您安装名为 “Cockpit” 的可选插件。这使得 CODESYS 将使用 WBM，这有助于在目标设备上激活许可证。您可以拒绝此选项，安装过程将继续进行。如果您同意，并且在安装Cockpit软件包时出现错误，则安装过程将中止 Linux SL LinuxARM SL LinuxARM64 SL 这个 Deploy Tool 尝试安装当前版本的 Codemeter。如果 Codemeter 或 Codemeter Lite 安装的版本与预期版本相同或更新 Deploy Tool ，则不会对系统进行任何更改。如果需要升级或更改，则在对系统进行任何更改之前，将打开一个对话框提示您同意。如果您同意，则将删除当前安装的 Codemeter 版本，改为安装当前版本 请注意，如果系统上未安装 Codemeter，则无法使用这些产品。 Safe Control 不执行任何其他步骤或检查。 SafeTimeProvider 不执行任何其他步骤或检查。 PFC100 PFC200 在 4.15 版本之前： 这个 Deploy Tool 尝试安装 EntropyHelper 软件包。产品期望包裹存放在 CODESYS Installer 安装插件时将其存储。如果软件包未列出、未找到或安装失败，则不会安装该产品。 TP600 不执行任何其他步骤或检查。 PLCNext 这个 Deploy Tool 尝试使用以下命令读取固件版本： cat \/etc\/plcnext\/arpversion | head -1 | cut -f2 -d' ' | cut -f-3 -d '.' 如果无法读取版本，则安装中止。 这个 Deploy Tool 在本地搜索 codesys-arp PLCnext 打包成与固件匹配的版本。软件包已安装。如果找不到软件包或安装失败，则产品的安装将中止。 Raspberry Pi 安装软件包后，将定义要使用的运行时类型。类型取决于系统上可用的装载机。按照 “” 中的说明检索装载机 用户空间架构” 章节。如果未找到加载器，则使用 armv6l 变体。以下列表显示了各个变体： 64 位多核：aarch64 32 位多核：ARMv7 标准（无多核）：ARMv6 根据您的系统，您可以在 Deploy Tool 安装产品后。 TargetVisualization 不执行任何其他步骤或检查。 Virtual Control Virtual Edge Virtual Safe Virtual SafeTimeProvider 你的设备上必须安装 Python 3.9 或更高版本以及 Docker 或 Podman。 " }, 
{ "title" : "与目标设备的连接失败。 ", 
"url" : "_rtsl_toubleshooting_deploytool2.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 与目标设备的连接失败。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "要求 ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790221847662", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 与目标设备的连接失败。 \/ 要求 ", 
"snippet" : "目标设备上的 SSH 服务器在已知端口（例如端口 22）上运行。 目标设备的正确 IP 地址是已知的。可以通过 IP 地址对目标设备执行 ping...", 
"body" : "目标设备上的 SSH 服务器在已知端口（例如端口 22）上运行。 目标设备的正确 IP 地址是已知的。可以通过 IP 地址对目标设备执行 ping " }, 
{ "title" : "故障排除 ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790223645865", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 与目标设备的连接失败。 \/ 故障排除 ", 
"snippet" : "其他问题，例如网络速度慢或网络错误，也可能导致连接中断。 连接到目标设备后， Deploy Tool 读取一些系统参数以确定哪些包和函数可用。检查目标设备的以下方面：...", 
"body" : "其他问题，例如网络速度慢或网络错误，也可能导致连接中断。 连接到目标设备后， Deploy Tool 读取一些系统参数以确定哪些包和函数可用。检查目标设备的以下方面： " }, 
{ "title" : "用户空间架构 ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790227601997", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 与目标设备的连接失败。 \/ 故障排除 \/ 用户空间架构 ", 
"snippet" : "这个 Deploy Tool 检测目标设备上的可用加载器。可用的加载器决定可以执行哪些二进制文件。为此， Deploy Tool 执行以下命令： ls -la \/lib*\/ld-linux* 如果输出包含以下任何值，则相应的架构被视为可用：x86-64、i386、x32、armhf、aarch64。 对于版本 4.14.0.0： 如果找不到这些值，则连接将断开。 对于 4.15.0.0 及更高版本： 如果找不到这些值，那么 Deploy Tool 打印一条日志消息，指出未检测到 Userland 架构。然后检查以下参数。但是，这不应导致断开连接...", 
"body" : "这个 Deploy Tool 检测目标设备上的可用加载器。可用的加载器决定可以执行哪些二进制文件。为此， Deploy Tool 执行以下命令： ls -la \/lib*\/ld-linux* 如果输出包含以下任何值，则相应的架构被视为可用：x86-64、i386、x32、armhf、aarch64。 对于版本 4.14.0.0： 如果找不到这些值，则连接将断开。 对于 4.15.0.0 及更高版本： 如果找不到这些值，那么 Deploy Tool 打印一条日志消息，指出未检测到 Userland 架构。然后检查以下参数。但是，这不应导致断开连接 " }, 
{ "title" : "设备架构 ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790234401598", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 与目标设备的连接失败。 \/ 故障排除 \/ 设备架构 ", 
"snippet" : "这个 Deploy Tool 检查目标设备上哪个 CPU 可用。为此， Deploy Tool 执行以下命令： lscpu | grep ^Architecture: 如果输出包含以下任何值，则使用相应的架构：x86_64、i686、aarch64、arch64、armv7l、armv6l。 如果输出不包含任何这些值，则命令 cat \/proc\/cpuinfo | grep '^model name' 被处决。 cat \/proc\/cpuinfo | grep '^model name' 如果输出包含以下任何值，则使用相应的架构：x86_64、i686、aarch64、arch64、armv7...", 
"body" : "这个 Deploy Tool 检查目标设备上哪个 CPU 可用。为此， Deploy Tool 执行以下命令： lscpu | grep ^Architecture: 如果输出包含以下任何值，则使用相应的架构：x86_64、i686、aarch64、arch64、armv7l、armv6l。 如果输出不包含任何这些值，则命令 cat \/proc\/cpuinfo | grep '^model name' 被处决。 cat \/proc\/cpuinfo | grep '^model name' 如果输出包含以下任何值，则使用相应的架构：x86_64、i686、aarch64、arch64、armv7l、armv6l。 如果输出不包含任何这些值，则会打印一条日志消息。 " }, 
{ "title" : "容器引擎 ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790244053777", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 与目标设备的连接失败。 \/ 故障排除 \/ 容器引擎 ", 
"snippet" : "这个 Deploy Tool 检查目标设备上有哪些容器引擎可用。为此， Deploy Tool 执行以下命令： which docker 如果退出代码为 0，则将 Docker 识别为引擎。 which podman 如果退出代码为 0，则将 Podman 识别为引擎。 两个容器引擎的同时使用尚未经过测试，因此不完全支持。结果，这可能会导致问题。...", 
"body" : "这个 Deploy Tool 检查目标设备上有哪些容器引擎可用。为此， Deploy Tool 执行以下命令： which docker 如果退出代码为 0，则将 Docker 识别为引擎。 which podman 如果退出代码为 0，则将 Podman 识别为引擎。 两个容器引擎的同时使用尚未经过测试，因此不完全支持。结果，这可能会导致问题。 " }, 
{ "title" : "容器架构 ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm2347902491793", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 与目标设备的连接失败。 \/ 故障排除 \/ 容器架构 ", 
"snippet" : "这个 Deploy Tool 检查容器引擎可以执行哪些架构。为此， Deploy Tool 根据检测到的引擎执行以下命令： docker info 如果 Architecture: 输出包含以下任何值，则使用相应的架构：x86_64、aarch64、arch64、armv7l、armv6l。 如果找不到这些值，则会打印一条日志消息。 podman info 如果 arch: 输出包含以下任何值，则使用相应的架构：amd64、aarch64、armv7l、armv6l、armv6l。 如果找不到这些值，则会打印一条日志消息。...", 
"body" : "这个 Deploy Tool 检查容器引擎可以执行哪些架构。为此， Deploy Tool 根据检测到的引擎执行以下命令： docker info 如果 Architecture: 输出包含以下任何值，则使用相应的架构：x86_64、aarch64、arch64、armv7l、armv6l。 如果找不到这些值，则会打印一条日志消息。 podman info 如果 arch: 输出包含以下任何值，则使用相应的架构：amd64、aarch64、armv7l、armv6l、armv6l。 如果找不到这些值，则会打印一条日志消息。 " }, 
{ "title" : "初始化进程 ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790249419828", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 与目标设备的连接失败。 \/ 故障排除 \/ 初始化进程 ", 
"snippet" : "这个 Deploy Tool 检查目标设备上有哪些初始化进程可用。为此， Deploy Tool 执行以下命令： systemctl > \/dev\/null 2>&1 ; echo $? 如果退出代码为 0 且输出包含 0，则 systemd 被识别为可用的初始化进程。 ls \/etc\/init.d > \/dev\/null 2>&1 ; echo $? 如果退出代码为 0 且输出包含 0，则 initd 被识别为可用的初始化进程。...", 
"body" : "这个 Deploy Tool 检查目标设备上有哪些初始化进程可用。为此， Deploy Tool 执行以下命令： systemctl > \/dev\/null 2>&1 ; echo $? 如果退出代码为 0 且输出包含 0，则 systemd 被识别为可用的初始化进程。 ls \/etc\/init.d > \/dev\/null 2>&1 ; echo $? 如果退出代码为 0 且输出包含 0，则 initd 被识别为可用的初始化进程。 " }, 
{ "title" : "包管理器 ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790249681867", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 与目标设备的连接失败。 \/ 故障排除 \/ 包管理器 ", 
"snippet" : "这个 Deploy Tool 检查目标设备上有哪些软件包管理器可用。为此， Deploy Tool 执行以下命令： which dpkg > \/dev\/null 2>&1; echo $? 如果退出代码为 0 且输出包含 0，则 dpkg 已注册为可用的包管理器。 which ipkg > \/dev\/null 2>&1; echo $? 如果退出代码为 0 且输出包含 0，则 ipkg 已注册为可用的包管理器。 which opkg > \/dev\/null 2>1; echo $? 如果退出代码为 0 且输出包含 0，则 opkg 已注册为可用的包管理器。 对于 4.15 及更高版本： whi...", 
"body" : "这个 Deploy Tool 检查目标设备上有哪些软件包管理器可用。为此， Deploy Tool 执行以下命令： which dpkg > \/dev\/null 2>&1; echo $? 如果退出代码为 0 且输出包含 0，则 dpkg 已注册为可用的包管理器。 which ipkg > \/dev\/null 2>&1; echo $? 如果退出代码为 0 且输出包含 0，则 ipkg 已注册为可用的包管理器。 which opkg > \/dev\/null 2>1; echo $? 如果退出代码为 0 且输出包含 0，则 opkg 已注册为可用的包管理器。 对于 4.15 及更高版本： which rpm > \/dev\/null 2>1; echo $? 如果退出代码为 0 且输出包含 0，则 rpm 已注册为可用的包管理器。 如果产品和您的系统支持 dpkg 和 ipkg 或者 opkg ，那么 dpkg 已使用。 " }, 
{ "title" : "巨蟒蛇 ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790250012792", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 与目标设备的连接失败。 \/ 故障排除 \/ 巨蟒蛇 ", 
"snippet" : "这个 Deploy Tool 检查目标设备上是否有 Python 可用。为此， Deploy Tool 执行以下命令： python3 -v 如果退出代码为 0 且版本大于 3.9，则将 Python 识别为已安装。...", 
"body" : "这个 Deploy Tool 检查目标设备上是否有 Python 可用。为此， Deploy Tool 执行以下命令： python3 -v 如果退出代码为 0 且版本大于 3.9，则将 Python 识别为已安装。 " }, 
{ "title" : "无法选择要安装在目标设备上的产品。 ", 
"url" : "_rtsl_toubleshooting_deploytool3.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 无法选择要安装在目标设备上的产品。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "要求 ", 
"url" : "_rtsl_toubleshooting_deploytool3.html#UUID-492eba96-8c2f-b3cd-6935-f8dd7506d72f_section-idm23478724692167", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 无法选择要安装在目标设备上的产品。 \/ 要求 ", 
"snippet" : "这个 CODESYS 安装包括特定产品 CODESYS 包装（及其依赖产品）。您可以在中概述已安装的产品 CODESYS Installer 在已安装的插件列表中。...", 
"body" : "这个 CODESYS 安装包括特定产品 CODESYS 包装（及其依赖产品）。您可以在中概述已安装的产品 CODESYS Installer 在已安装的插件列表中。 " }, 
{ "title" : "故障排除 ", 
"url" : "_rtsl_toubleshooting_deploytool3.html#UUID-492eba96-8c2f-b3cd-6935-f8dd7506d72f_section-idm234787250012849", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ 编程系统\/IDE\/ Deploy Tool \/ 无法选择要安装在目标设备上的产品。 \/ 故障排除 ", 
"snippet" : "您可以通过以下方式选择产品 Deploy Tool 仅当目标设备满足本产品的要求（可用架构、软件包管理器、初始化流程等）时。 每个产品都需要匹配的 Userland 架构、软件包管理器和初始化进程（除非另有说明， initd 为必填项）。 有关更多信息，请参阅： 故障排除。 以下列表显示了各个产品的检查内容： 产品 BeagleBoneBlack 的输出 cat \/proc\/cpuinfo | grep '^model name\\|^Hardware' 必须包含 ARMv7 和 Generic AM33XX 。 Edge Gateway PLCNext 控制器上使用时，PLCNext Edge...", 
"body" : "您可以通过以下方式选择产品 Deploy Tool 仅当目标设备满足本产品的要求（可用架构、软件包管理器、初始化流程等）时。 每个产品都需要匹配的 Userland 架构、软件包管理器和初始化进程（除非另有说明， initd 为必填项）。 有关更多信息，请参阅： 故障排除。 以下列表显示了各个产品的检查内容： 产品 BeagleBoneBlack 的输出 cat \/proc\/cpuinfo | grep '^model name\\|^Hardware' 必须包含 ARMv7 和 Generic AM33XX 。 Edge Gateway PLCNext 控制器上使用时，PLCNext Edge Gateway 插件必须在你的 Windows 计算机上可用。（它应该位于 plcNext 目录中 命令的输出 uname -m 不得包含 uarmv4 ， uarmv5 ，或 uarmv6 。 emPC eth0 或者 eth1 必须有以开头的 MAC 地址 00:90:E9 。 IOT2000 eth0 或者 eth1 必须有以开头的 MAC 地址 E0:DC:A0 。 License Server 无需额外支票 LinuxARM SL und LinuxARM64 SL 匹配的 Userland 架构必须可用 ( armhf 或者 aarch64 ）。 Safe Control 需要 32 位 AMD 架构 (i386) SafeTimeProvider 需要 64 位 AMD 架构 (x86-64) 和 Python 的可用性。 有关如何检查此项的说明，请参阅” 的 “Python” 部分 与目标设备的连接失败。” 章节。 Linux SL 需要 64 位 AMD 架构 (x86-64) PFC100 PFC200 TP600 需要 ipkg 或者 opkg 和 32 位 ARM 架构 ( armhf ) PLCNext 需要路径 \/etc\/plcnext\/arpversion 要存在 Raspberry Pi cat \/proc\/cpuinfo | grep ^Model | awk -F':' '{print $2}' 必须包含 “覆盆子”。 TargetVisualization 必须安装以下软件包。 libqt6core6 libqt6gui6 libqt6widgets6 libqt6network6 libqt6svg6 libqt6webenginewidgets6 libqt6webenginecore6 名称必须完全匹配。安装的软件包由以下命令确定： 命令 dpkg -l <package> | awk '\/<package>\/ {print }' 的输出必须包含所有软件包的 ii 。 libqt6core6 必须作为 6.4.2 或更高版本安装。版本由以下命令确定： dpkg -s libqt6core6 | grep '^Version:' | grep -o -E '\\b[0-9]+\\.[0-9]+\\.[0-9]+\\b' Virtual Control Virtual Edge Virtual Safe Virtual SafeTimeProvider Python 必须可用。 有关如何检查此项的说明，请参阅” 的 “Python” 部分 与目标设备的连接失败。” 章节。 必须安装 Podman 或 Docker，并且必须有与可用容器架构相匹配的可用镜像。 Virtual SafeTimeProvider x86-64 用户空间架构和 Python 必须可用。 有关如何检查此项的说明，请参阅” 的 “Python” 部分 与目标设备的连接失败。” 章节。 Virtual Safe i386 用户空间架构和 Python 必须可用。 有关如何检查此项的说明，请参阅” 的 “Python” 部分 与目标设备的连接失败。” 章节。 Virtual Control Virtual Edge 需要一个 Userland 架构 x86-64、ARMHF 或 ARM64，并且 Python 必须可用。 有关如何检查此项的说明，请参阅” 的 “Python” 部分 与目标设备的连接失败。” 章节。 " }, 
{ "title" : "Linux 目标 ", 
"url" : "_rtsl_toubleshooting_linuxtarget.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ Linux 目标 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "IEC 应用程序中的奇怪行为 ", 
"url" : "_rtsl_toubleshooting_linuxtarget_stange.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ Linux 目标 \/ IEC 应用程序中的奇怪行为 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "要求 ", 
"url" : "_rtsl_toubleshooting_linuxtarget_stange.html#UUID-15af7838-c568-6bc8-9b0d-6c5ba94f66cf_section-idm234790740254336", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ Linux 目标 \/ IEC 应用程序中的奇怪行为 \/ 要求 ", 
"snippet" : "你正在使用一个 CODESYS 运行时间。...", 
"body" : "你正在使用一个 CODESYS 运行时间。 " }, 
{ "title" : "故障排除 ", 
"url" : "_rtsl_toubleshooting_linuxtarget_stange.html#UUID-15af7838-c568-6bc8-9b0d-6c5ba94f66cf_section-idm234790740478094", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ Linux 目标 \/ IEC 应用程序中的奇怪行为 \/ 故障排除 ", 
"snippet" : "如果你观察到奇怪的行为，那么你应该检查运行时记录器是否提供了有价值的提示或信息。这个 CODESYS 运行时记录器有一种按类别过滤消息的机制。这个 调试 默认情况下，类别未启用。启用此类别可查找异常行为或意外症状的原因。 有全局和特定组件的日志过滤器。您可以在运行时日志文件中查看所有可能的特定组件过滤器的详细列表。按如下所述使用过滤器。 与之相关的症状 可能的基于组件的日志过滤器 许可 CmpCodeMeter IEC 任务\/时机（更高级别） CmpIecTask IEC 任务\/时机（低级） CmpSchedule ， SysTask IEC 应用程序（通用） CmpApp ， CmpIecT...", 
"body" : "如果你观察到奇怪的行为，那么你应该检查运行时记录器是否提供了有价值的提示或信息。这个 CODESYS 运行时记录器有一种按类别过滤消息的机制。这个 调试 默认情况下，类别未启用。启用此类别可查找异常行为或意外症状的原因。 有全局和特定组件的日志过滤器。您可以在运行时日志文件中查看所有可能的特定组件过滤器的详细列表。按如下所述使用过滤器。 与之相关的症状 可能的基于组件的日志过滤器 许可 CmpCodeMeter IEC 任务\/时机（更高级别） CmpIecTask IEC 任务\/时机（低级） CmpSchedule ， SysTask IEC 应用程序（通用） CmpApp ， CmpIecTask IEC 应用程序（存储器） SysMem 套接字通信 SysSocket 以太网通信 SysEthernet 文件\/文件夹 SysFile ， SysDir 不要同时启用所有调试类别，因为这会使发现实际问题变得困难。逐步进行并禁用 “无关紧要” 的过滤器，以更好地了解问题 启用 调试 通过 PLC 外壳进行消息类别（适用于运行时版本 >= SP20）。 打开你的 CODESYS 投影并将其连接到控制器。 双击设备树中的控制器，打开 PLC 外壳。 输入 “？“在 shell 中查看所有可能的命令。 使用 logsetfilter ， loggetfilter ，以及 logdelfilter 写入、读取和删除过滤器的命令。您可以对整个运行时使用全局调试过滤器，也可以对特定组件使用过滤器。 要全局读取当前日志类别，请执行以下操作： loggetfilter 可能会返回以下输出： Logger.0.Filter : 0x0000000F 要全局设置当前日志类别，请执行以下操作： logsetfilter 0xffffffff 读取特定组件的当前日志类别（例如， CmpCodeMeter ): loggetfilter CmpCodeMeter 要为特定组件（例如 CmpCodeMeter）设置当前日志类别，请执行以下操作： logsetfilter CmpCodeMeter 0xffffffff 通过运行时配置文件启用记录器类别（适用于较早的运行时版本） 示例：通过 SSH 连接和文本编辑器 通过部署工具停止运行时间。 连接到您的目标系统（例如，通过 putty 或其他 SSH 客户端）。 使用文本编辑器打开运行时环境的用户特定配置文件（例如， nano ): sudo nano \/etc\/codesyscontrol\/CODESYSControl_User.cfg 找到 CmpLog 分区并设置过滤器。 设置全局过滤器 示例： Logger.0.Filter=0xFFFFFFFFFF 启用所有调试消息 设置特定组件的过滤器 [CmpLog]\nCmpCodeMeter.Filter=0xFFFFFFFF\nSysTask.Filter=0xFFFFFFFF 保存并关闭该文件。 使用部署工具重新启动运行时。 " }, 
{ "title" : "IEC 应用程序 ", 
"url" : "_rtsl_toubleshooting_iec.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "IEC 应用程序依赖于信号量。 ", 
"url" : "_rtsl_toubleshooting_iec_semaphores.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ IEC 应用程序依赖于信号量。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "要求 ", 
"url" : "_rtsl_toubleshooting_iec_semaphores.html#UUID-0421c326-6af8-0336-eb1f-9f6120d597b5_section-idm234795575934472", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ IEC 应用程序依赖于信号量。 \/ 要求 ", 
"snippet" : "你有一个基于 Linux 或 Windows 的运行时版本 >= SP20。...", 
"body" : "你有一个基于 Linux 或 Windows 的运行时版本 >= SP20。 " }, 
{ "title" : "故障排除 ", 
"url" : "_rtsl_toubleshooting_iec_semaphores.html#UUID-0421c326-6af8-0336-eb1f-9f6120d597b5_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ IEC 应用程序依赖于信号量。 \/ 故障排除 ", 
"snippet" : "如果您在运行 IEC 应用程序或使用您的应用程序进行操作时发现死锁或信号量挂起 CODESYS 运行时，这可能是由信号量锁或死锁引起的。 运行时版本 SP20 及更高版本（Linux 和 Windows）能够帮助提供信号量诊断功能。这种诊断可以帮助找到信号量或处理有问题信号量的相关任务之间的相互作用 你需要在配置文件中启用此功能： [SysSem] SemEnterDiagnosis=1 这可能会严重影响应用程序（以及运行时间）的性能和时间。 仅用于诊断目的。 请勿在生产系统中使用。 输出将如下所示： 在这个例子中， MainTask_1 保存信号量几毫秒，并且 MainTask 尝试访问此信...", 
"body" : "如果您在运行 IEC 应用程序或使用您的应用程序进行操作时发现死锁或信号量挂起 CODESYS 运行时，这可能是由信号量锁或死锁引起的。 运行时版本 SP20 及更高版本（Linux 和 Windows）能够帮助提供信号量诊断功能。这种诊断可以帮助找到信号量或处理有问题信号量的相关任务之间的相互作用 你需要在配置文件中启用此功能： [SysSem]\nSemEnterDiagnosis=1 这可能会严重影响应用程序（以及运行时间）的性能和时间。 仅用于诊断目的。 请勿在生产系统中使用。 输出将如下所示： 在这个例子中， MainTask_1 保存信号量几毫秒，并且 MainTask 尝试访问此信号量。 " }, 
{ "title" : "IEC 应用程序无法再打开任何文件句柄。 ", 
"url" : "_rtsl_toubleshooting_iec_filehandles.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ IEC 应用程序无法再打开任何文件句柄。 ", 
"snippet" : "在更改系统上文件句柄的限制之前，应紧急考虑 Linux 系统上所有服务的后果。相反，我们建议找出泄漏的原因。...", 
"body" : "在更改系统上文件句柄的限制之前，应紧急考虑 Linux 系统上所有服务的后果。相反，我们建议找出泄漏的原因。 " }, 
{ "title" : "故障排除 ", 
"url" : "_rtsl_toubleshooting_iec_filehandles.html#UUID-4043602f-b92d-ba82-ffe1-5d6eea5cf6f5_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ IEC 应用程序无法再打开任何文件句柄。 \/ 故障排除 ", 
"snippet" : "文件句柄泄漏可能会导致以下影响： 许可证状态丢失。一段时间后，WIBU 许可证会失效 无法打开新文件。 Linux 进程的默认行为是允许最大数量的打开文件句柄。当一个进程达到这个限制时，就不能再打开新文件了。 你可以使用控制台命令检查系统的极限值： ulimit -n Linux 中的每个进程都有进程 ID，内核提供有关其文件\/文件夹系统中每个进程的详细信息 procfs 。这使您可以轻松确定一个进程在任何给定时间拥有的文件句柄的数量。 我们建议采取以下步骤来调查可能的文件句柄泄漏： 查找的进程 ID CODESYS 运行时环境。 您可以使用标准的 Linux 工具来查找进程 ID CODES...", 
"body" : "文件句柄泄漏可能会导致以下影响： 许可证状态丢失。一段时间后，WIBU 许可证会失效 无法打开新文件。 Linux 进程的默认行为是允许最大数量的打开文件句柄。当一个进程达到这个限制时，就不能再打开新文件了。 你可以使用控制台命令检查系统的极限值： ulimit -n Linux 中的每个进程都有进程 ID，内核提供有关其文件\/文件夹系统中每个进程的详细信息 procfs 。这使您可以轻松确定一个进程在任何给定时间拥有的文件句柄的数量。 我们建议采取以下步骤来调查可能的文件句柄泄漏： 查找的进程 ID CODESYS 运行时环境。 您可以使用标准的 Linux 工具来查找进程 ID CODESYS 运行时环境： htop 通常在第一列 (PID) 中显示进程 ID。 top 通常在第一列 (PID) 中显示进程 ID。 你可以组合 ps 和 grep 用于快速搜索的命令： ps aux | grep codesyscontrol 记下进程 ID，并在以下使用占位符 <pid> 的命令中使用它。 检查和监控文件句柄。 现在列出中的条目 procfs 查看运行时进程的文件句柄。 sudo ls -la \/proc\/<pid>\/fd\/ 这可能如下所示 如果文件句柄是 “真实” 文件，则可以看到路径。其他文件句柄可能是套接字或类似的句柄。 如果一个接一个地多次执行此命令，则可以观察文件句柄的数量是否在增加，以及哪些文件处于打开状态。 这个 watch 命令会创建一个视图，该视图每 2 秒更新一次。 watch sudo ls -la \/proc\/<pid>\/fd\/ 这些操作可以帮助您监控打开的句柄，从而找出哪些文件可能参与文件句柄泄漏。 " }, 
{ "title" : "我的 IEC 应用程序的内存消耗正在增加。 ", 
"url" : "_rtsl_toubleshooting_iec_memory.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ 我的 IEC 应用程序的内存消耗正在增加。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "准备工作： ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234795798419608", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ 我的 IEC 应用程序的内存消耗正在增加。 \/ 准备工作： ", 
"snippet" : "你需要一个运行时系统，其中 CmpMemGC 组件已启用并处于活动状态。您可以在运行时日志中检查此组件是否已加载。...", 
"body" : "你需要一个运行时系统，其中 CmpMemGC 组件已启用并处于活动状态。您可以在运行时日志中检查此组件是否已加载。 " }, 
{ "title" : "故障排除 ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ 我的 IEC 应用程序的内存消耗正在增加。 \/ 故障排除 ", 
"snippet" : "如果您在 IEC 应用程序运行一段时间后发现奇怪的影响（例如许可证状态丢失或无法分配新内存），则这可能是内存泄漏造成的。 你应该调查这些影响并找到问题的根源。...", 
"body" : "如果您在 IEC 应用程序运行一段时间后发现奇怪的影响（例如许可证状态丢失或无法分配新内存），则这可能是内存泄漏造成的。 你应该调查这些影响并找到问题的根源。 " }, 
{ "title" : "CODESYS 存储设备追踪 ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234796058905879", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ 我的 IEC 应用程序的内存消耗正在增加。 \/ 故障排除 \/ CODESYS 存储设备追踪 ", 
"snippet" : "此功能在运行时系统版本 SP19（SL 版本 4.9.0.0）及更高版本中可用。它可以很容易地使用： 在运行时环境中启用该设置。 通过以下方式停止运行时间 Deploy Tool 。 通过以下方式连接到目标系统 putty 或者其他 SSH 客户端。 使用文本编辑器（例如 nano）打开运行时环境的配置文件： sudo nano \/etc\/codesyscontrol\/CODESYSControl.cfg 在 CmpMemGC 部分，添加条目 EnableMemTrace=1 。 [CmpMemGC] EnableMemTrace=1 保存并关闭该文件。 通过以下方式重新启动运行时 Deplo...", 
"body" : "此功能在运行时系统版本 SP19（SL 版本 4.9.0.0）及更高版本中可用。它可以很容易地使用： 在运行时环境中启用该设置。 通过以下方式停止运行时间 Deploy Tool 。 通过以下方式连接到目标系统 putty 或者其他 SSH 客户端。 使用文本编辑器（例如 nano）打开运行时环境的配置文件： sudo nano \/etc\/codesyscontrol\/CODESYSControl.cfg 在 CmpMemGC 部分，添加条目 EnableMemTrace=1 。 [CmpMemGC]\nEnableMemTrace=1 保存并关闭该文件。 通过以下方式重新启动运行时 Deploy Tool 。 将设备跟踪添加到您的 CODESYS 项目（出现此问题的地方）。 在设备树中，右键单击该设备。 点击 添加对象 → 设备跟踪 。 这个 设备跟踪 对象插入控制器下方。 这个 设备跟踪 显示选项卡。 点击 追踪 → 上传追踪 命令。 这个 设备 “codesys_control_for_Linux_SL” 的在线跟踪 对话框打开。 如果你找不到 memgcTrace 输入，则步骤 1 中的设置未正确设置。如果您的控制器不支持该机制，则使用以下两个选项之一进行诊断。 选择 memgcTrace 输入并单击 上传并关闭对话框 。 内存跟踪 ( MemGCTrace ) 已添加到 DeviceTrace 。 有关更多信息，请参阅： 命令：上传跟踪 " }, 
{ "title" : "CODESYS 图书馆：SysMem ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234796059265431", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ 我的 IEC 应用程序的内存消耗正在增加。 \/ 故障排除 \/ CODESYS 图书馆：SysMem ", 
"snippet" : "您还可以通过编程方式访问内部信息。您可以通过 IEC 库函数访问所有分配的 RAM \/堆内存的当前概览 SysMem.SysMemGetCurrentHeapSize() 该值可用于观察当前的堆大小。您可以查看此值或将其写入跟踪。 这可以帮助您确定分配的内存的增加是否是基于时间的 IEC 应用程序中的某些其他事件。...", 
"body" : "您还可以通过编程方式访问内部信息。您可以通过 IEC 库函数访问所有分配的 RAM \/堆内存的当前概览 SysMem.SysMemGetCurrentHeapSize() 该值可用于观察当前的堆大小。您可以查看此值或将其写入跟踪。 这可以帮助您确定分配的内存的增加是否是基于时间的 IEC 应用程序中的某些其他事件。 " }, 
{ "title" : "Linux 命令行 ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234796059607787", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ 我的 IEC 应用程序的内存消耗正在增加。 \/ 故障排除 \/ Linux 命令行 ", 
"snippet" : "如果您有权访问 Linux 控制台（例如，通过 SSH 客户端），则还可以检查内存行为。 有多种工具和命令可以实现此目的： htop\/top 这些是用于分析 Linux 系统上的进程（和线程）的图形工具。 几乎所有 Linux 发行版都提供这些工具，因此您可以通过以下方式轻松安装它们 apt 或者 dnf 或者发行版的包管理。 htop  # or  top 这两个工具都可用于在树视图中查看线程并分析 CODESYS 运行时进程及其线程。每个 IEC 任务都是 pthread 在运行时进程中。 在 htop 工具中，您可以通过以下方式自定义视图 F2 （设置菜单）：我们建议您启用 Tree v...", 
"body" : "如果您有权访问 Linux 控制台（例如，通过 SSH 客户端），则还可以检查内存行为。 有多种工具和命令可以实现此目的： htop\/top 这些是用于分析 Linux 系统上的进程（和线程）的图形工具。 几乎所有 Linux 发行版都提供这些工具，因此您可以通过以下方式轻松安装它们 apt 或者 dnf 或者发行版的包管理。 htop \n# or \ntop 这两个工具都可用于在树视图中查看线程并分析 CODESYS 运行时进程及其线程。每个 IEC 任务都是 pthread 在运行时进程中。 在 htop 工具中，您可以通过以下方式自定义视图 F2 （设置菜单）：我们建议您启用 Tree view 和 Show custom thread names 选项。 在上方区域，您可以使用组合键启用树视图 移动 + V 因此可以查看每个线程的 CPU 使用率\/内存使用情况。这可以帮助您确定分配的内存的增加是否与 IEC 应用程序中的某些其他事件有关，或者您是否存在内存泄漏 " }, 
{ "title" : "安全运行时在日志文件中显示计时错误。 ", 
"url" : "_rtsl_toubleshooting_iec_safety.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ 安全运行时在日志文件中显示计时错误。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "准备工作： ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795798419608", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ 安全运行时在日志文件中显示计时错误。 \/ 准备工作： ", 
"snippet" : "你正在运行一个 CODESYS Safe Control SL 或 CODESYS Virtual Safe Control SL 与 CODESYS Safe Time Provider 。...", 
"body" : "你正在运行一个 CODESYS Safe Control SL 或 CODESYS Virtual Safe Control SL 与 CODESYS Safe Time Provider 。 " }, 
{ "title" : "故障排除 ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ 安全运行时在日志文件中显示计时错误。 \/ 故障排除 ", 
"snippet" : "如果您遇到上报的问题 CODESYS Safe Control SL 运行时环境并提及时序问题（来自 CmpSIL3 组件），那么你可能会在安全时间网络中遇到计时问题，你应该对此进行调查。 日志消息可能如下所示： #### Exception: ID: 0x40000066 <p0>0xb633<\/p0> <p1>0xbcdd<\/p1> <p2>0xbce1<\/p2> <p3>0xb2fd<\/p3> <p4>0x0<\/p4> 异常错误具有以下含义： 0x40000065 : 异常频道 x：周期时间本地时间戳的真实性检查 0x40000066 : 异常渠道 x：对循环时间的远程时间戳进行可信性检...", 
"body" : "如果您遇到上报的问题 CODESYS Safe Control SL 运行时环境并提及时序问题（来自 CmpSIL3 组件），那么你可能会在安全时间网络中遇到计时问题，你应该对此进行调查。 日志消息可能如下所示： #### Exception: ID: 0x40000066 <p0>0xb633<\/p0> <p1>0xbcdd<\/p1> <p2>0xbce1<\/p2> <p3>0xb2fd<\/p3> <p4>0x0<\/p4> 异常错误具有以下含义： 0x40000065 : 异常频道 x：周期时间本地时间戳的真实性检查 0x40000066 : 异常渠道 x：对循环时间的远程时间戳进行可信性检查 0x40000067 : 异常频道 x：将远程时间戳与本地时间戳进行可信性检查 安全时间网络（之间 CODESYS Safe Time Provider 还有 CODESYS Safe Control 运行时环境）对稳定性和实时性的要求与现场总线网络（例如 EtherCAT 或 Profinet）相同。 " }, 
{ "title" : "使用追踪 tcpdump ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795897227037", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ 安全运行时在日志文件中显示计时错误。 \/ 故障排除 \/ 使用追踪 tcpdump ", 
"snippet" : "您可以使用 Linux 命令行轻松创建跟踪 tcpdump 工具。如果您已经熟悉 Wireshark 或硬件跟踪设备，则也可以使用它来创建跟踪 你需要遵循的基本步骤： 确定要跟踪的网络适配器。 找出要跟踪的内容（内容、包类型、日志等），以缩小跟踪范围。 有用的命令 安装 tcpdump （取决于您的发行版\/软件包管理） 例如，基于 Debian\/Ubuntu 的 “apt”： sudo apt install tcpdump 基于红帽的 “YUM\/DNF”： sudo yum install tcpdump 你可以看到所有可用的网络适配器 tcpdump 可以监控： > tcpdump -D ...", 
"body" : "您可以使用 Linux 命令行轻松创建跟踪 tcpdump 工具。如果您已经熟悉 Wireshark 或硬件跟踪设备，则也可以使用它来创建跟踪 你需要遵循的基本步骤： 确定要跟踪的网络适配器。 找出要跟踪的内容（内容、包类型、日志等），以缩小跟踪范围。 有用的命令 安装 tcpdump （取决于您的发行版\/软件包管理） 例如，基于 Debian\/Ubuntu 的 “apt”： sudo apt install tcpdump 基于红帽的 “YUM\/DNF”： sudo yum install tcpdump 你可以看到所有可用的网络适配器 tcpdump 可以监控： > tcpdump -D \n1.eno1 [Up, Running, Connected]\n2.any (Pseudo-device that captures on all interfaces) [Up, Running]\n3.lo [Up, Running, Loopback] 可以运行 tcpdump 作为普通用户。如果你想这样做，请阅读 tcpdump 更多细节的文档。 tcpdump 命令行参数 有关所有可能命令的详细信息 tcpdump 可以在 tcpdump 手册页： https:\/\/www.tcpdump.org\/manpages\/tcpdump.1.html 或者打电话 tcpdump : > tcpdump --help \n\ntcpdump version 4.99.3\nlibpcap version 1.10.3 (with TPACKET_V3)\nOpenSSL 3.0.15 3 Sep 2024\nUsage: tcpdump [-AbdDefhHIJKlLnNOpqStuUvxX#] [ -B size ] [ -c count ] [--count]\n                [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]\n                [ -i interface ] [ --immediate-mode ] [ -j tstamptype ]\n                [ -M secret ] [ --number ] [ --print ] [ -Q in|out|inout ]\n                [ -r file ] [ -s snaplen ] [ -T type ] [ --version ]\n                [ -V file ] [ -w file ] [ -W filecount ] [ -y datalinktype ]\n                [ --time-stamp-precision precision ] [ --micro ] [ --nano ]\n                [ -z postrotate-command ] [ -Z user ] [ expression ] 最重要的标志和过滤器： 旗帜（短\/长） 描述 -D --list-interfaces 返回系统上可用的网络接口列表，其中 tcpdump 命令可以捕获数据包 -i <interface> --interface <interface> 查询接口并返回以下信息： 链路层类型列表 时间戳类型列表 编译过滤器表达式的结果 -c <Count> 接收或读取一定数量的 <count> 数据包后终止查询 -n 防止将地址（主机地址、端口号等）转换为名称 -A 以 ASCII 格式输出每个数据包（减去其链路级标头） -x 解析时，除了每个数据包的标头外，还会以十六进制打印每个数据包的数据（减去链路级标头） -s <snaplen> --snapshot-length=<snaplen> 从每个数据包中使用 <snaplen> 字节的数据，而不是默认值 262144 字节 -w <file> Writes the raw data packets to a file instead of analyzing and printing them -t 防止在每个转储行中输出时间戳 -tt 返回每条转储行中的时间戳，以自 1970 年 1 月 1 日 00:00:00（UTC）以来的秒数以及自该时间以来的几分之一秒为秒 -ttt 打印增量（微秒或纳秒）分辨率，具体取决于 --time-stamp-precision 选项）在每条转储行的当前行和上一行之间。默认设置是以微秒为单位的分辨率 -tttt 每条转储线上打印一个时间戳，如小时、分钟、秒和午夜以来的几分之一秒。输出前面有日期 -v 输出其他信息（详细） 追踪包裹 在控制台上简单捕获和输出： > sudo tcpdump -i <interfacename>\n\n# e.g. with interface \"eno1\":\n> sudo tcpdump -i eno1 捕获并输出为兼容 WireShark 的文件 > sudo tcpdump -i <interfacename> -w <file>\n \n# e.g.\n> sudo tcpdump -i eno1 -w myfirsttrace.pcap 然后是文件 myfirsttrace.pcap 可以在 Wireshark 中打开。 .pcap 是 Wireshark 跟踪文件的默认文件扩展名。） 示例 > sudo tcpdump -i eno1 -w myfirsttrace.cap -s 200 udp port 60000 " }, 
{ "title" : "调查\/分析 ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795898218432", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 故障排除 \/ IEC 应用程序 \/ 安全运行时在日志文件中显示计时错误。 \/ 故障排除 \/ 调查\/分析 ", 
"snippet" : "创建跟踪后，必须对其进行分析。这可以通过 tcpdump 来完成，也可以使用 Wireshark 以图形方式 在安全控制 SL 的主机（时间提供者通信的接收端）上记录跟踪，如上面的示例所示。 然后使用 Wireshark 打开 *.pcap 文件。它看起来像这样： 您会注意到，包裹的发送间隔通常为 1 毫秒（包裹之间的时差）。（参见数据包编号 58 及以下内容。） 一种典型的问题情况 CODESYS Safe Control SL 将发出异常\/问题，因为在编号为 74 的数据包中可以看到定时：此数据包是在前一个数据包之后大约 2 毫秒收到的，因此延迟约为 1 毫秒。这是不可接受的 CODESY...", 
"body" : "创建跟踪后，必须对其进行分析。这可以通过 tcpdump 来完成，也可以使用 Wireshark 以图形方式 在安全控制 SL 的主机（时间提供者通信的接收端）上记录跟踪，如上面的示例所示。 然后使用 Wireshark 打开 *.pcap 文件。它看起来像这样： 您会注意到，包裹的发送间隔通常为 1 毫秒（包裹之间的时差）。（参见数据包编号 58 及以下内容。） 一种典型的问题情况 CODESYS Safe Control SL 将发出异常\/问题，因为在编号为 74 的数据包中可以看到定时：此数据包是在前一个数据包之后大约 2 毫秒收到的，因此延迟约为 1 毫秒。这是不可接受的 CODESYS Safe Control SL 是一种可靠且具有实时性的时间戳。 减少延迟的行动 找出问题在接收方或发送方是否可见。你必须同时考虑接收方 ( CODESYS Safe Control 主机）和发送方（ CODESYS Safe Time Provider 主机）。 总体而言，提高这种时间戳通信的实时能力和稳健性。为此，您可以从该网络中移除其他干扰通信和负载（仅用于安全时间戳 通过配置相应 IRQ（网络驱动程序）的进程优先级，提高发送和接收性能。 如果您无法进一步改进，并且您的安全流程允许，则可以延长循环时间 CODESYS Safe Time Provider （发送时间戳）。 " }, 
{ "title" : "参考 ", 
"url" : "_rtsl_reference_linux.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 参考 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：部署控制 SL ", 
"url" : "_rtsl_cmd_deploy_control_sl.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 参考 \/ 命令：部署控制 SL ", 
"snippet" : "函数 : 该命令会打开 沟通 ， 部署 ，以及 操作 选项卡。 打电话 : 工具 菜单 有关更多信息，请参阅： 选项卡：部署标签：沟通选项卡：操作...", 
"body" : "函数 : 该命令会打开 沟通 ， 部署 ，以及 操作 选项卡。 打电话 : 工具 菜单 有关更多信息，请参阅： 选项卡：部署标签：沟通选项卡：操作" }, 
{ "title" : "选项卡：部署 ", 
"url" : "_rtsl_dlg_deploy_deployment.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 参考 \/ 选项卡：部署 ", 
"snippet" : "安装和部署产品 产品 要安装的产品 选择产品后，安装的 CODESYS 包裹显示在选项卡的下半部分。仅显示可以安装在当前连接的设备上的软件包。 版本 要安装的所选产品的版本。如果已安装产品的选定版本，则列表框右侧会显示一条消息。 安装 开始安装 已安装的软件包 产品 包裹的产品名称 版本 软件包的版本 已安装的映像 产品 关联产品（运行时、安全运行时、边缘网关、时间提供商） 图像版本 图像的版本 建筑 图像的架构。当控制器和容器引擎支持多个架构时，这很重要。 使用者 使用此图像的实例列表...", 
"body" : "安装和部署产品 产品 要安装的产品 选择产品后，安装的 CODESYS 包裹显示在选项卡的下半部分。仅显示可以安装在当前连接的设备上的软件包。 版本 要安装的所选产品的版本。如果已安装产品的选定版本，则列表框右侧会显示一条消息。 安装 开始安装 已安装的软件包 产品 包裹的产品名称 版本 软件包的版本 已安装的映像 产品 关联产品（运行时、安全运行时、边缘网关、时间提供商） 图像版本 图像的版本 建筑 图像的架构。当控制器和容器引擎支持多个架构时，这很重要。 使用者 使用此图像的实例列表 " }, 
{ "title" : "标签：沟通 ", 
"url" : "_rtsl_dlg_deploy_communication.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 参考 \/ 标签：沟通 ", 
"snippet" : "登录 IP 地址 您要连接的控制器的 IP 地址。 或者，也可以在这里使用控制器的主机名。如果主机名和 IP 地址都未知，则可以使用显示可用设备 扫描 命令。然后可以通过 MAC 地址找到该设备。 如果这些信息都未知，则需要直接连接到控制器以找出主机名或 IP 地址。 端口 您连接的端口 扫描 打开 可用设备 对话框这将显示网络中的可见设备。 用户名 您用来登录控制器的账户 密码 您用于登录的账户的密码 状态 当前连接状态 连接 使用上面指定的参数建立与控制器的连接 断开连接 断开当前连接 基于密钥的登录 基于密钥的 SSH 登录 : 允许使用所选的 SSH 密钥 密码短语 可选；所选 SSH...", 
"body" : "登录 IP 地址 您要连接的控制器的 IP 地址。 或者，也可以在这里使用控制器的主机名。如果主机名和 IP 地址都未知，则可以使用显示可用设备 扫描 命令。然后可以通过 MAC 地址找到该设备。 如果这些信息都未知，则需要直接连接到控制器以找出主机名或 IP 地址。 端口 您连接的端口 扫描 打开 可用设备 对话框这将显示网络中的可见设备。 用户名 您用来登录控制器的账户 密码 您用于登录的账户的密码 状态 当前连接状态 连接 使用上面指定的参数建立与控制器的连接 断开连接 断开当前连接 基于密钥的登录 基于密钥的 SSH 登录 : 允许使用所选的 SSH 密钥 密码短语 可选；所选 SSH 密钥的密码 密钥文件 包含已配置的 SSH 密钥的列表框 添加密钥文件 打开 运行时部署工具 选项。你可以在那里添加 SSH 密钥。 设备信息 重启 重新启动控制器 对话框： 可用设备 顶部输入字段 筛选 IP 或 MAC 地址 取消 关闭对话框 再次扫描 再次启动扫描过程 好吧 当从列表中选择一个条目时，其 IP 地址将插入到 IP 地址 外部对话框中的字段。 " }, 
{ "title" : "选项卡：操作 ", 
"url" : "_rtsl_dlg_deploy_operation.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Linux 的运行时系统 \/ 参考 \/ 选项卡：操作 ", 
"snippet" : "服务 全部启动 启动所有列出的服务 全部停止 停止所有列出的服务 启动选定项 启动所选服务 停止选中 停止所选服务 产品 服务的名称 州 服务的当前状态 刷新 获取所有元素的最新状态并刷新表格 重复 根据当前选定的服务创建新实例 出口 创建 ZIP 格式的导出文件。这包含当前选定的实例。 导入 打开用于导入先前生成的导出文件的对话框 VPLC 全部启动 启动所有列出的 VPLC 全部停止 停止所有列出的 VPLC 启动选定项 启动选定的 VPLC 停止选中 停止选定的 VPLC 实例 VPLC 的名称 州 VPLC 的状态 产品 VPLC 的类型（运行时、安全运行时、边缘网关、时间提供商） 依...", 
"body" : "服务 全部启动 启动所有列出的服务 全部停止 停止所有列出的服务 启动选定项 启动所选服务 停止选中 停止所选服务 产品 服务的名称 州 服务的当前状态 刷新 获取所有元素的最新状态并刷新表格 重复 根据当前选定的服务创建新实例 出口 创建 ZIP 格式的导出文件。这包含当前选定的实例。 导入 打开用于导入先前生成的导出文件的对话框 VPLC 全部启动 启动所有列出的 VPLC 全部停止 停止所有列出的 VPLC 启动选定项 启动选定的 VPLC 停止选中 停止选定的 VPLC 实例 VPLC 的名称 州 VPLC 的状态 产品 VPLC 的类型（运行时、安全运行时、边缘网关、时间提供商） 依赖关系 所选实例所依赖的其他实例。这些其他实例在所选实例之前启动，在选定实例之后停止。 打开 添加新实例 对话框 删除单个或所有实例。 无法删除正在运行的实例。“清除” 会删除所有实例和已安装的映像 刷新所有元素的当前状态 行动 根据所选元素，会显示不同的命令。 显示日志 显示相应元素的日志 禁用启动应用程序 禁用运行时的启动应用程序 打开 WBM 打开 CODESYS 浏览器中的基于 Web 的管理 设置 所选元素所有选项的动态列表。有关选项的详细描述可以在本章中找到 配置和扩展保存 一旦更改设置并且在配置中未检测到错误，该命令就会启用。 添加新实例 姓名 新实例的名称 筛选 筛选可用图像列表 图片 可用图像列表 好吧 当选择了图像并指定了有效名称时启用。创建并显示新实例。 取消 关闭对话框；不做任何更改。 配置 Nic 可用适配器 系统上当前可用的适配器。当适配器已经映射到一个实例时，此列表中会显示一个简短的注释。 映射到实例 确定此适配器是否映射到当前选定的实例 适配器 无法修改显示所选适配器的名称 知识产权 容器中此适配器的 IP 地址。指定此值时，还必须指定掩码。 面具 容器中此适配器的网络掩码。指定此值时，还必须指定 IP 地址。 " }, 
{ "title" : "基于 Windows 的运行时系统 ", 
"url" : "_rtsl_windows_runtime_systems.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "入门 ", 
"url" : "_rtsl_first_steps_win.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 ", 
"snippet" : "在本章中，您将学习如何使用 CODESYS 控制 SL runtime，从小做起 CODESYS 应用程序，并许可控制器。...", 
"body" : "在本章中，您将学习如何使用 CODESYS 控制 SL runtime，从小做起 CODESYS 应用程序，并许可控制器。 " }, 
{ "title" : "在控制器上安装运行时 ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 在控制器上安装运行时 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "安装 CODESYS Control RTE ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc_section-idm43305899023692", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 在控制器上安装运行时 \/ 安装 CODESYS Control RTE ", 
"snippet" : "可执行文件 Setup_CODESYSControlRTE<32|64>V3.<version>setup.exe 安装包中在下文中称为“setup”。安装程序会安装包中包含的所有可用驱动程序。安装程序确定要安装的平台类型并修改配置文件 CODESYSControl.cfg 自动（在您确认后）。 默认情况下，工作目录 CODESYS Control RTE 是 C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 . 要求： 您知道要安装的系统中的 CPU 内核数 CODESYS Control RTE .您已在您的系统上执行了上述准备工作。 （您的 CPU 的...", 
"body" : "可执行文件 Setup_CODESYSControlRTE<32|64>V3.<version>setup.exe 安装包中在下文中称为“setup”。安装程序会安装包中包含的所有可用驱动程序。安装程序确定要安装的平台类型并修改配置文件 CODESYSControl.cfg 自动（在您确认后）。 默认情况下，工作目录 CODESYS Control RTE 是 C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 . 要求： 您知道要安装的系统中的 CPU 内核数 CODESYS Control RTE .您已在您的系统上执行了上述准备工作。 （您的 CPU 的确切名称显示在 Windows 控制面板的“系统”对话框中。有了这些信息，您可以使用 Internet 来研究物理 CPU 内核的数量。） 另请注意有关硬件配置的信息： 硬件配置-建议将安装包加载到您的计算机。 CODESYS Control RTE 可在 CODESYS Store International 作为单一许可证版本。 执行文件开始安装 CODESYS Control RTE <32|64> <version>.exe .使用默认设置按照向导进行操作，直到 多核 CPU 使用率 显示对话框。 结果： 安装向导会尝试检测系统中的物理处理器内核总数 核心总数 .检查此信息并在必要时进行更正。在 核心 RTE , 定义应专门为 CODESYS Control RTE 任务。因此，这些内核不再适用于 Windows（“AMP”模式）。 注意：已经指定的数字（例如： 6 ) 只是设置的建议。通常，安装程序可以正确检测系统的物理 CPU 内核数。 Windows 显示的 CPU 核心也可以是不适合在其上运行实时系统的“逻辑”CPU 核心（“超线程核心”）。也请按照说明进行操作： BIOS 设置必须禁用超线程！ .超线程等 CPU 功能会对实时行为产生负面影响。 稍后您必须在对话框中确认设置应该通过更改系统的引导配置为 RTE 保留一个 CPU 核心。这样做时，引导选项 numproc 设置为 <物理处理器数量减去 1 >。点击 下一个 确认指定的核心数。 然后你会看到 启动选项将改变 对话框，其中包含有关 PC 引导配置的显着更改的信息。 点击 下一个 继续 设置引导选项？ 对话。 结果： 在里面 设置引导选项 对话框，您决定安装程序是否应将以下更改应用于系统的启动配置： Windows 可用的 CPU 内核数量限制；通过引导选项“ numproc “ 至 <number of physical cores> - 1 . 停用处理器功能“数据执行保护”。 停用处理器功能“物理地址扩展 (PAE)”。 处理器功能“数据执行保护”和“PAE”不一定非要停用。通过手动编辑启动配置，您可以仅限制 Windows 的核心数。但是，这种配置未经测试 CODESYS . 引导选项 numproc 在此配置中，RTE 的功能是绝对必要的。因此，如果您在此处决定安装程序不应设置此选项，则您必须手动激活该选项。 如果设置应应用刚才描述的更改，则单击 是的 . 如果您想稍后手动执行这些更改，请单击 不 . 点击 下一个 继续 RTE 的目标类型 对话。 结果： 带版本 CODESYS 3.5 SP17，不再需要区分设备类型“Control”和“Softmotion”。设备类型“控制”还包括以前为 SoftMotion 设备保留的全部功能。现在仅出于兼容性原因才存在区别。对于新项目，我们建议使用“Control”。 在里面 RTE 的目标类型 对话框，选择要安装的 RTE 类型： CODESYS 控制 RTE 或者 CODESYS SoftMotion RTE . 安装类型取决于您的应用程序和许可证。仅当您已购买并想要使用 CODESYS SoftMotion RTE 执照。如果不是，则 RTE 将以限时演示模式启动。下一个 选择功能 对话框，您仍然可以更改要安装的实际功能的选择： CODESYS SoftMotion RTE 和 Windows 版 CodeMeter® . 您可以在两者之间手动切换 CODESYS Control RTE 稍后通过编辑配置文件输入 CODESYSControl.cfg .通过在配置文件中输入以下行来执行此操作 CODESYSControl.cfg : [SysTarget] TargetType=0x1006 DeviceName=CODESYS SoftmotionRTE V3 通过删除这些条目（或在前面加上分号），您会得到 CODESYS Control RTE 再次。 在里面 选择功能 对话框，选择要安装的功能。 如果要访问请打开防火墙 CODESYS Control RTE 来自其他计算机。这是必要的，例如，与 CODESYS , CODESYS OPC，以及在使用基于以太网的现场总线时。 结果： 其中一个执行步骤会提示时间是否准确 CODESYS Control RTE 应该通过创建和激活硬件配置文件来增加。如果您确认这一点，则选择电源选项“高性能”（控制面板 -> 电源选项）并将 CPU 速率设置为 100%。 安装成功结束后， 符号显示在屏幕的状态栏中。你可以打开 CODESYS Control RTE 右键单击菜单。 配置文件 CODESYSControl.cfg 自动适应。 检查当前设备描述是否为 CODESYS Control RTE 安装在你的 CODESYS Development System .此安装需要使用 CODESYS Control RTE 和 CODESYS . （开发系统不一定位于运行 RTE 的目标系统上。） 如果您必须重新安装设备描述，例如因为需要进行后续更改，请打开 CODESYS 设备存储库并执行 安装 命令。用于适配 RTE 的描述文件 ( .devdesc.xml ) 由安装目录中的安装程序生成 Others . 您必须在安装结束时执行所需的重新启动。 有关详细信息，请参阅： 安装设备 " }, 
{ "title" : "调整配置 CODESYS Control RTE ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc_section-idm43305899148826", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 在控制器上安装运行时 \/ 安装 CODESYS Control RTE \/ 调整配置 CODESYS Control RTE ", 
"snippet" : "要求：您已按照上述说明执行了安装。您已安装 CODESYS . 以下选项是可能的： 使用安装后可用配置的设备：继续按照下面的说明“开始 CODESYS Control RTE ”。 适配本地安装的配置 CODESYS Control RTE ： 点击 CODESYS Control RTE 象征 在 PC 的系统托盘中。点击 PLC配置 在里面 CODESYS Control RTE 菜单打开配置编辑器。根据需要编辑设置。 使用 CODESYS Control RTE 安装在远程 PC 上。点击 CODESYS Control RTE 象征 在 PC 的系统托盘中。在里面 CODESYS Co...", 
"body" : "要求：您已按照上述说明执行了安装。您已安装 CODESYS . 以下选项是可能的： 使用安装后可用配置的设备：继续按照下面的说明“开始 CODESYS Control RTE ”。 适配本地安装的配置 CODESYS Control RTE ： 点击 CODESYS Control RTE 象征 在 PC 的系统托盘中。点击 PLC配置 在里面 CODESYS Control RTE 菜单打开配置编辑器。根据需要编辑设置。 使用 CODESYS Control RTE 安装在远程 PC 上。点击 CODESYS Control RTE 象征 在 PC 的系统托盘中。在里面 CODESYS Control RTE 菜单，点击 远程PLC .在打开的对话框中，配置远程 PLC 的连接设置。 配置保存在配置文件中 CODESYSControl.cfg 在目录中 C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 . " }, 
{ "title" : "安装 CODESYS Control Win ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc_section-idm4555504420804833058987427815", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 在控制器上安装运行时 \/ 安装 CODESYS Control Win ", 
"snippet" : "安装成功后， CODESYS Control Win 在您的计算机上作为服务运行。您可以通过以下方式进行安装： 您已经安装了 CODESYS Development System .结果，一个 CODESYS Control Win 您的 PC 上安装了限时版本。 您已下载 CODESYS Control Win 来自 CODESYS 存储并运行安装文件以进行安装。...", 
"body" : "安装成功后， CODESYS Control Win 在您的计算机上作为服务运行。您可以通过以下方式进行安装： 您已经安装了 CODESYS Development System .结果，一个 CODESYS Control Win 您的 PC 上安装了限时版本。 您已下载 CODESYS Control Win 来自 CODESYS 存储并运行安装文件以进行安装。 " }, 
{ "title" : "启动运行时系统 ", 
"url" : "_rtsl_start_runtime-1816376.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 启动运行时系统 ", 
"snippet" : "笔记 : 必须在您的 PC 上安装有效许可证才能运行运行时系统。如果没有，则控制器将以功能齐全但有时间限制的演示模式启动。 对于运行时系统，这些是设备许可证。您在许可证管理器中激活这些许可证。 有关详细信息，请参阅： 产品许可...", 
"body" : "笔记 : 必须在您的 PC 上安装有效许可证才能运行运行时系统。如果没有，则控制器将以功能齐全但有时间限制的演示模式启动。 对于运行时系统，这些是设备许可证。您在许可证管理器中激活这些许可证。 有关详细信息，请参阅： 产品许可 " }, 
{ "title" : "CODESYS Control RTE ", 
"url" : "_rtsl_start_runtime-1816376.html#UUID-065101d1-259a-9d21-37c7-74cc493827e0_section-idm43463171121528", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 启动运行时系统 \/ CODESYS Control RTE ", 
"snippet" : "开始 CODESYS Control RTE 通过命令 启动 PLC 在 CODESYS Control RTE 菜单 ( ）。 如果系统任务栏中的符号不可用，请确保安装正确。双击该文件 CODESYSControlRTESysTray.exe 在的安装目录中 CODESYS Control RTE ，可以在系统任务栏中手动开始显示用户界面。 系统任务栏中的符号更改为 启动后 CODESYS Control RTE 。 以下说明描述了如何创建简单的 CODESYS 要在上运行的应用程序 CODESYS Control RTE 。...", 
"body" : "开始 CODESYS Control RTE 通过命令 启动 PLC 在 CODESYS Control RTE 菜单 ( ）。 如果系统任务栏中的符号不可用，请确保安装正确。双击该文件 CODESYSControlRTESysTray.exe 在的安装目录中 CODESYS Control RTE ，可以在系统任务栏中手动开始显示用户界面。 系统任务栏中的符号更改为 启动后 CODESYS Control RTE 。 以下说明描述了如何创建简单的 CODESYS 要在上运行的应用程序 CODESYS Control RTE 。 " }, 
{ "title" : "CODESYS Control Win ", 
"url" : "_rtsl_start_runtime-1816376.html#UUID-065101d1-259a-9d21-37c7-74cc493827e0_section-idm43463171151726", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 启动运行时系统 \/ CODESYS Control Win ", 
"snippet" : "就以下情况而言 CODESYS Control Win ，这是设备许可证。您可以在许可证管理器中激活此许可证。 有关更多信息，请参阅： 产品许可 自动启动： 如果 CODESYS Control Win 应该在系统启动时自动启动，然后你需要按如下方式配置服务：打开Windows 服务 计算机开始菜单中的系统对话框。在列表中，选择服务 CODESYS Control Win V3 然后打开 属性 快捷菜单中的对话框。 将军 选项卡，设置 起始类型 到 自动 。 手动启动： 在系统栏中，右键单击 符号或 符号，然后单击 启动 PLC 在菜单中。如果系统栏中缺少该符号，请确保安装正确且系统栏中的显示...", 
"body" : "就以下情况而言 CODESYS Control Win ，这是设备许可证。您可以在许可证管理器中激活此许可证。 有关更多信息，请参阅： 产品许可 自动启动： 如果 CODESYS Control Win 应该在系统启动时自动启动，然后你需要按如下方式配置服务：打开Windows 服务 计算机开始菜单中的系统对话框。在列表中，选择服务 CODESYS Control Win V3 然后打开 属性 快捷菜单中的对话框。 将军 选项卡，设置 起始类型 到 自动 。 手动启动： 在系统栏中，右键单击 符号或 符号，然后单击 启动 PLC 在菜单中。如果系统栏中缺少该符号，请确保安装正确且系统栏中的显示已启动。附加说明：双击该文件 CODESYSControlSysTray.exe 在的安装目录中 GatewayPLC ，可以在系统任务栏中手动开始显示用户界面。 成功启动后， CODESYS Control Win 系统栏中的符号更改为 或者 。 " }, 
{ "title" : "下载并启动 CODESYS 控制器上的应用 ", 
"url" : "_rtsl_load_and_start_application_win.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 下载并启动 CODESYS 控制器上的应用 ", 
"snippet" : "要求：控制器已启动。 在 CODESYS , 创建一个标准项目：点击 文件 → 新建项目 .在里面 新项目 对话框，选择 标准项目 模板并指定名称和位置。然后在 标准项目 对话框，选择相应的控制器。 在设备树中（ 设备 视图）的新项目，现在有一个控制器条目（ 设备 （...） ), 下面是一个带有 POU ( PLC_PRG (PRG) 和一个任务 主要任务 调用 PLC_PRG）。 在 PLC_PRG ，编写一个简单的程序（例如，一个计数器）。 PROGRAM PLC_PRG VAR iCount: INT; END_VAR iCount := iCount+1; 建立与控制器的连接。为此，...", 
"body" : "要求：控制器已启动。 在 CODESYS , 创建一个标准项目：点击 文件 → 新建项目 .在里面 新项目 对话框，选择 标准项目 模板并指定名称和位置。然后在 标准项目 对话框，选择相应的控制器。 在设备树中（ 设备 视图）的新项目，现在有一个控制器条目（ 设备 （...） ), 下面是一个带有 POU ( PLC_PRG (PRG) 和一个任务 主要任务 调用 PLC_PRG）。 在 PLC_PRG ，编写一个简单的程序（例如，一个计数器）。 PROGRAM PLC_PRG\nVAR\n iCount: INT;\nEND_VAR\n\niCount := iCount+1; 建立与控制器的连接。为此，请使用 通讯设置 设备编辑器的选项卡。您可以通过双击打开它 设备 （...） 设备树中的条目。 通常，网关现在已经处于活动状态。如果不是这种情况，则检查状态并在必要时显式启动网关。然后点击 扫描网络 在 沟通 标签。 这 选择设备 对话框打开，显示检测到的设备。如果找不到您的控制器，请确保它已正确安装并启动。 选择检测到的控制器并单击 好的 . 如果找不到控制器，请检查以下内容： 在 通讯设置 选项卡，在 设备 → 选项 菜单，禁用 按目标 ID 过滤网络扫描 选项。 如果您的设备现在显示，那么您有一个不正确的 TargetID .你的组件 SysTargetOEM 可能没有正确加载。 您的设备是否已连接到您的网络？ 默认情况下，通过 UDP 与您的设备进行通信。当您使用这种通信方法时，您的设备必须与您的主机位于同一子网中。两个设备都需要完全相同的配置网络掩码。 在启动时，您可以检查运行时系统消息的网络设置。例如，它们应该如下所示： 1287759127: Cmp=CmpBlkDrvUdp, Class=1, Error=0, Info=6, pszInfo=Network interface: <ipaddress>192.168.101.41<\/ipaddress> <subnetmask>255.255.252.0<\/subnetmask> CODESYS 尝试在此目标系统上进行身份验证并获取通信通道。连接已建立。 点击 在线 → 登录 . 确认下载应用程序的对话框打开。 执行下载并启动应用程序。该应用程序在您的设备上处理。 在里面 PLC_PRG 程序，检查计数器是否正在运行。 " }, 
{ "title" : "授权控制器 ", 
"url" : "_rtsl_license_controller_win.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 授权控制器 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "获取许可证 ", 
"url" : "_rtsl_license_controller_win.html#UUID-3805d9ea-0c7b-2463-7ef4-1d99d0c4e100_section-idm234389354567343", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 授权控制器 \/ 获取许可证 ", 
"snippet" : "您可以下载 CODESYS Control 产品来自 CODESYS 国际商店 或者 CODESYS 北美商店 。...", 
"body" : "您可以下载 CODESYS Control 产品来自 CODESYS 国际商店 或者 CODESYS 北美商店 。 " }, 
{ "title" : "本地许可 ", 
"url" : "_rtsl_license_controller_win.html#UUID-3805d9ea-0c7b-2463-7ef4-1d99d0c4e100_section-idm4588328499004833054120306755", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 授权控制器 \/ 本地许可 ", 
"snippet" : "许可证可以安装在 USB 加密狗或软容器上。使用软容器时，许可证在激活期间锁定到设备，并且只能在此设备上激活或恢复。 要求：开发系统具备 CODESYS Development System 可以访问互联网并连接到设备。 打开 CODESYS . 创建一个标准项目。 更新设备树中的设备。 点击 工具 → 许可证管理器 打开 CODESYS 许可证管理器。 选择 设备 在向导中，然后选择 加密狗 或者 软容器 ，取决于设备。 这 选择设备 对话框打开。 选择相应的设备。 这 许可证管理器 对话框打开。 容器 显示设备上的软容器或安全密钥的名称。在 产品 窗户。 选择 安装许可证 左下角的动作。 ...", 
"body" : "许可证可以安装在 USB 加密狗或软容器上。使用软容器时，许可证在激活期间锁定到设备，并且只能在此设备上激活或恢复。 要求：开发系统具备 CODESYS Development System 可以访问互联网并连接到设备。 打开 CODESYS . 创建一个标准项目。 更新设备树中的设备。 点击 工具 → 许可证管理器 打开 CODESYS 许可证管理器。 选择 设备 在向导中，然后选择 加密狗 或者 软容器 ，取决于设备。 这 选择设备 对话框打开。 选择相应的设备。 这 许可证管理器 对话框打开。 容器 显示设备上的软容器或安全密钥的名称。在 产品 窗户。 选择 安装许可证 左下角的动作。 这 在 <目标设备> <容器名称> 上安装许可证 – 选择操作 向导启动。 选择 激活许可证 选项。指定 工单编号 然后点击 下一个 . 许可证已激活。 " }, 
{ "title" : "备份和恢复 CODESYS 许可证 ", 
"url" : "_rtsl_backup_restore_wibu_win.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 ", 
"snippet" : "这些说明不适用于以下产品 CODESYS 虚拟控制产品系列。...", 
"body" : "这些说明不适用于以下产品 CODESYS 虚拟控制产品系列。 " }, 
{ "title" : "Codemeter 嵌入式许可证 ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4622936815712034049201310732", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 嵌入式许可证 ", 
"snippet" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ 备份和恢复许可证...", 
"body" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ 备份和恢复许可证 " }, 
{ "title" : "备份许可证 ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4641146992569634049209836102", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 嵌入式许可证 \/ 备份许可证 ", 
"snippet" : "建立连接从 CODESYS 到您的控制器。 在设备树中，选择您的控制器并打开 文件 标签。 在右侧窗口中，单击刷新图标 ( ）。 将显示控制器上可用的文件。 在左侧窗口中，选择要存储备份的目录。 在右侧窗口中，选择 cmact_许可证 目录并单击 按钮。 您的许可目录的备份副本将在您的计算机上创建。 检查备份副本是否已成功创建。...", 
"body" : "建立连接从 CODESYS 到您的控制器。 在设备树中，选择您的控制器并打开 文件 标签。 在右侧窗口中，单击刷新图标 ( ）。 将显示控制器上可用的文件。 在左侧窗口中，选择要存储备份的目录。 在右侧窗口中，选择 cmact_许可证 目录并单击 按钮。 您的许可目录的备份副本将在您的计算机上创建。 检查备份副本是否已成功创建。 " }, 
{ "title" : "恢复许可证 ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm451020213344483404921010438", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 嵌入式许可证 \/ 恢复许可证 ", 
"snippet" : "请注意，执行步骤 6 中的以下说明时可能会丢失数据。因此，请仔细阅读这些说明。 建立连接从 CODESYS 到您的控制器。 在设备树中，选择您的控制器并打开 文件 标签。 在右侧窗口中，单击刷新图标 ( ）。 将显示控制器上可用的文件。 在右侧窗口中选择目标目录。这必须是顶级目录（ 存储位置 ： \/ ） 在左侧窗口中，选择之前在计算机上创建的备份副本，然后单击 按钮。 备份副本将复制到您的控制器。 如果同名目录已存在，系统将提示您覆盖其中包含的所有文件。 注意：如果选择“是”，则所有与备份目录中同名的文件都将从现有目录中删除。名称相同并不一定意味着内容相同。因此，请确保您不会意外覆盖所需的文件...", 
"body" : "请注意，执行步骤 6 中的以下说明时可能会丢失数据。因此，请仔细阅读这些说明。 建立连接从 CODESYS 到您的控制器。 在设备树中，选择您的控制器并打开 文件 标签。 在右侧窗口中，单击刷新图标 ( ）。 将显示控制器上可用的文件。 在右侧窗口中选择目标目录。这必须是顶级目录（ 存储位置 ： \/ ） 在左侧窗口中，选择之前在计算机上创建的备份副本，然后单击 按钮。 备份副本将复制到您的控制器。 如果同名目录已存在，系统将提示您覆盖其中包含的所有文件。 注意：如果选择“是”，则所有与备份目录中同名的文件都将从现有目录中删除。名称相同并不一定意味着内容相同。因此，请确保您不会意外覆盖所需的文件。 成功传输备份副本后重新启动控制器。 " }, 
{ "title" : "Codemeter 运行时许可证 ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4592433740225634049202010617", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 运行时许可证 ", 
"snippet" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL...", 
"body" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL " }, 
{ "title" : "备份许可证 ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4582704430054434049230836628", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 运行时许可证 \/ 备份许可证 ", 
"snippet" : "使用 CodeMeter Runtime 时，无需创建备份。...", 
"body" : "使用 CodeMeter Runtime 时，无需创建备份。 " }, 
{ "title" : "恢复许可证 ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4548752769854434049231197546", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 运行时许可证 \/ 恢复许可证 ", 
"snippet" : "恢复许可证 创建许可证请求文件 在 CODESYS ，打开许可证管理器。 在接下来的两个对话框中，选择 设备 和 软质容器 。 建立连接从 CODESYS 到要恢复许可证的控制器。 点击 安装许可证 ， 选择 申请许可证 ，然后单击 下一个 。 如果 软件供应商 字段为空，则可以使用公司代码。如何检索公司代码在“检索公司代码”部分中进行了描述。 选择应安装许可证的容器，然后选择应在计算机上保存许可证请求文件的位置。点击 结束 。 下载许可证更新文件 打开 许可证中心 WebDepot 并指定您要恢复的票证 ID。点击 下一个 。 点击 恢复许可证 。 在右下角，单击 基于文件的许可证传输 。 ...", 
"body" : " 恢复许可证 创建许可证请求文件 在 CODESYS ，打开许可证管理器。 在接下来的两个对话框中，选择 设备 和 软质容器 。 建立连接从 CODESYS 到要恢复许可证的控制器。 点击 安装许可证 ， 选择 申请许可证 ，然后单击 下一个 。 如果 软件供应商 字段为空，则可以使用公司代码。如何检索公司代码在“检索公司代码”部分中进行了描述。 选择应安装许可证的容器，然后选择应在计算机上保存许可证请求文件的位置。点击 结束 。 下载许可证更新文件 打开 许可证中心 WebDepot 并指定您要恢复的票证 ID。点击 下一个 。 点击 恢复许可证 。 在右下角，单击 基于文件的许可证传输 。 （如果页面显示 直接许可转让 ，那么您已经位于正确的页面上）。 上传之前创建的许可证请求文件，然后单击 上传请求并立即继续 。 点击 立即下载许可证更新文件 并将文件保存到您的计算机。 安装许可证更新 在 CODESYS ，打开许可证管理器。 在接下来的两个对话框中，选择 设备 和 软质容器 。 建立连接从 CODESYS 到要恢复许可证的控制器。 点击 安装许可证 ， 选择 安装许可证 ，然后单击 下一个 。 选择要安装License的容器，选择之前下载的更新文件（扩展名： .WibuCmRaU ）。 点击 结束 。 几秒钟后，许可证将出现在许可证管理器中。 " }, 
{ "title" : "检索公司代码 ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4641146913656034049243306333", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 入门 \/ 备份和恢复 CODESYS 许可证 \/ Codemeter 运行时许可证 \/ 检索公司代码 ", 
"snippet" : "打开 许可证中心 WebDepot 并指定您要恢复的票证 ID。点击 下一个 。 点击 恢复许可证 。 在右下角，单击 基于文件的许可证传输 。 复制第一点中提供的公司代码。...", 
"body" : "打开 许可证中心 WebDepot 并指定您要恢复的票证 ID。点击 下一个 。 点击 恢复许可证 。 在右下角，单击 基于文件的许可证传输 。 复制第一点中提供的公司代码。 " }, 
{ "title" : "配置和扩展 ", 
"url" : "_rtsl_configure_and_extend-1816377.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Control Win V3 ", 
"url" : "_rtsl_windows_win_v3.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Win V3 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "添加动态组件 ", 
"url" : "_rtsl_windows_win_v3_dynamic_components.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Win V3 \/ 添加动态组件 ", 
"snippet" : "CODESYS Control Win 通过配置文件（ CODESYSControl.cfg ）。 安装路径中的cfg文件包含对实际配置文件的引用 CODESYSControl.cfg 在工作目录中： [SysFile] Windows.WorkingDirectory=C:\\ProgramData\\CODESYS\\CODESYSControlWinV3x64\\801BFF8C 在工作目录的 cfg 文件中，您可以输入所需的附加组件（驱动程序）。然后这些总是在 CODESYS Control Win 重新启动。 您在该部分中输入一个新组件 [ComponentManager] .重要的是在所有...", 
"body" : "CODESYS Control Win 通过配置文件（ CODESYSControl.cfg ）。 安装路径中的cfg文件包含对实际配置文件的引用 CODESYSControl.cfg 在工作目录中： [SysFile]\nWindows.WorkingDirectory=C:\\ProgramData\\CODESYS\\CODESYSControlWinV3x64\\801BFF8C 在工作目录的 cfg 文件中，您可以输入所需的附加组件（驱动程序）。然后这些总是在 CODESYS Control Win 重新启动。 您在该部分中输入一个新组件 [ComponentManager] .重要的是在所有组件条目的数量中没有丢失的条目。 [ComponentManager]\n...\nComponent.6=SysCpuBreakpoints\nComponent.7=<Neue Komponente>\n... 请参阅下面您可以添加哪些组件。 " }, 
{ "title" : "支持可选的现场总线适配器 ", 
"url" : "_rtsl_windows_win_v3_dynamic_components.html#UUID-8ec48f4e-4fbf-ff18-64cb-d07a65c567cc_id_e00e47aa45e147ec0a8646334522c52-id-035992cdebec2318c0a8646340efc345", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Win V3 \/ 添加动态组件 \/ 支持可选的现场总线适配器 ", 
"snippet" : "CmpHilscherCIFX 司机 该组件支持 Hilscher 的 NetX PC 卡。为此，您只需在配置文件中输入组件“CmpHilscherCIFX” CODESYS Control Win 如下： [ComponentManager] Component.<n>=CmpHilscherCIFX 然后安装适配器后，您只需要安装驱动程序 SysDrv3S.sys 启动操作系统时。这位于 CODESYS 安装目录在 $\\GatewayPLC\\Driver 对于 32 位 Windows 操作系统，或在 $\\GatewayPLC\\Driver\\x64 对于 64 位 Windows 操作系统...", 
"body" : "CmpHilscherCIFX 司机 该组件支持 Hilscher 的 NetX PC 卡。为此，您只需在配置文件中输入组件“CmpHilscherCIFX” CODESYS Control Win 如下： [ComponentManager]\nComponent.<n>=CmpHilscherCIFX 然后安装适配器后，您只需要安装驱动程序 SysDrv3S.sys 启动操作系统时。这位于 CODESYS 安装目录在 $\\GatewayPLC\\Driver 对于 32 位 Windows 操作系统，或在 $\\GatewayPLC\\Driver\\x64 对于 64 位 Windows 操作系统。 注意：Hilscher 配置器 SyCon 或 SYCON.net 和 Hilscher 驱动程序不得并行运行 CODESYS . CmpSoftingProfibus 司机 如果您想使用 Softing Industrial Automation GmbH 的 PROFIBUS 主站 USB 接口适配器，则需要此组件 CODESYS 在 IEC 应用程序中。它表示运行时系统和 Softing 的专有驱动程序之间的接口，我们的驱动程序库使用它 IoDrvSoftingPROFIusb .在 CODESYS ，当您添加设备时，此库会自动集成到库管理器中 PROFIusb 在设备树中。因此，您可以使用和配置 CODESYS Windows PC 上的运行系统作为 PROFIBUS 主站。有关更多信息，请参阅： 为 PROFIBUS 添加 USB 接口 CmpBACnet 司机 当您想使用 BACnet IP 链接时需要该组件 CODESYS Control Win .配置文件中需要以下条目： [ComponentManager]\nComponent.<n>=CmpBACnet CmpPCANBasicDrv 司机 该组件通过PCAN基础API实现Peak CAN硬件的链接。有关安装说明，请参阅联机帮助。不需要配置文件条目。 CmpCAACanL2 司机 该组件提供了一个独立于硬件的接口，用于发送和接收 CAN 消息。可选配置文件条目： [CmpCAACanL2]\n;If setting PersistentBaudrate is enabled (0: disabled; 1: enabled)\n;the baudrate will be stored into Net.X.DefaultBaudrate (where X equals NetId) when opening the driver.\nPersistentBaudrate=1\n;Default baudrate for CAN network 0. This baudrate will be used when the network is opened (e.g from CmpBlkDrvCan or CANopen) with the baudrate set to 0.\nNet.0.DefaultBaudrate=1000 在配置文件中，可以为每个 CAN 网络（物理 CAN 连接）保存一个标准波特率。 CL2 功能时始终使用此标准波特率 DriverOpenH 以波特率调用 0 驱动程序还没有打开。如果缺少此配置文件条目，则在引用的情况下会发出错误，因为波特率未知。 该条目在与功能连接时特别有用 PersistenBaudrate 默认情况下禁用。如果 PersistentBaudrate=1 ， 然后 CODESYS 使用函数 CmpSettings 以每次调用的特定波特率将此波特率写入配置文件 DriverOpenH .这具有的效果，例如，条目 Net.0.DefaultBaudrate 被改变。这在控制器通过 CAN 块驱动程序进行通信时特别有用。如果波特率是 0 ( 0.Baud rate = 0 ） 在 CmpBlkDrvCanServer ，则用户可以通过在工程中更改波特率、下载应用程序、重启控制器等方式来更改块驱动通信的波特率。 CmpCAASdoClient 司机 该组件实现 CANopen SDO 客户端协议。可选配置条目： [CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity 您可以在此处减少块传输中每个周期发送的 CAN 消息数量。当控制器在同一 ID 的一系列许多 CAN 帧出现问题时，这是必要的。但是，这也限制了性能，导致块传输需要更多时间。 CmpCAASDO服务器 司机 该组件实现 CANopen SDO 服务器协议。可选配置文件条目： [CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity 此处可以减少块传输中每个周期发送的 CAN 消息数量。 CmpEL6751CanDrv 司机 该组件实现了 Beckhoff EL6751 CAN\/EtherCAT 网关终端的链接。由于组件实现了 CAN 微型驱动程序，因此您可以使用 CANL2 组件和所有 CODESYS 基于 CAN 的堆栈。不需要配置文件条目。 CmpNetXCanDlDrv 司机 该组件是 NetX CAN 适配器的 CAN 微型驱动程序。有了这个驱动程序， CODESYS Control Win 可以使用来自的 CAN 库 CODESYS GmbH 通过 NetX 适配器。 的配置文件中组件的配置 CODESYS Control Win : [CmpNetXCanDlDrv]\nMaxNumberOfCanNetworks=0..n -> number of the CAN networks (number of the NetIds)\nNetId.0.Channel=0 -> mapping of the NetId onboard nad NetX channels (see CmpHilscherCIFX)\nNetId.0.Board=0\n\n[ComponentManager]\n...\nComponent.6=CmpHilscherCIFX\nComponent.7=CmpNetXCanDlDrv\n... " }, 
{ "title" : "可选的通讯渠道 ", 
"url" : "_rtsl_windows_win_v3_dynamic_components.html#UUID-8ec48f4e-4fbf-ff18-64cb-d07a65c567cc_id_e00e47aa45e147ec0a8646334522c52-id-8aa5b4ef9fc59bd9c0a8646351124931", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS Control Win V3 \/ 添加动态组件 \/ 可选的通讯渠道 ", 
"snippet" : "CmpBlkDrvCanClient 司机 该组件实现了一个 CODESYS 用于通信的块驱动程序 CODESYS 网关与 CODESYS 控制器通过 CAN（服务通信）。通过 CANopen SDO 协议（“分段”或“块传输”）建立通信。组件 CmpBlkDrvCanClient 网关端以及 Peak 的 CAN 硬件（例如，PCAN USB 加密狗）都需要。 网关配置文件中的一个典型配置如下： [ComponentManager] Component.1=CmpBlkDrvCANClient Component.2=CmpCAASdoClient Component.3=CmpCAACan...", 
"body" : "CmpBlkDrvCanClient 司机 该组件实现了一个 CODESYS 用于通信的块驱动程序 CODESYS 网关与 CODESYS 控制器通过 CAN（服务通信）。通过 CANopen SDO 协议（“分段”或“块传输”）建立通信。组件 CmpBlkDrvCanClient 网关端以及 Peak 的 CAN 硬件（例如，PCAN USB 加密狗）都需要。 网关配置文件中的一个典型配置如下： [ComponentManager]\nComponent.1=CmpBlkDrvCANClient\nComponent.2=CmpCAASdoClient\nComponent.3=CmpCAACanL2\nComponent.4=CmpPCANBasicDrv\n\n[CmpBlkDrvCanClient]\nCycleTimeMs=1\nNumChannels=1 ; Number of block driver instances\n0.Name=BlkDrvCanClient\n0.NetId=0 ; CANbus Network Id (0..n)\n0.Baudrate=1000 ; CANbus Baudrate in kbit\/s\n0.NodeId=1 ; unique NodeId of Gateway\n0.BlockTransfer=1 ; Use block transfer for more performance\n\n[CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity\n[CmpBlkDrvCanClient]\nCycleTimeMs=1\nNumChannels=1 ; Number of block driver instances\n0.Name=BlkDrvCanClient\n0.NetId=0 ; CANbus Network Id (0..n)\n0.Baudrate=1000 ; CANbus Baudrate in kbit\/s\n0.NodeId=1 ; unique NodeId of Gateway\n0.BlockTransfer=1 ; Use block transfer for more performance\n\n[CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity CmpBlkDrvCanServer 司机 该组件实现了一个 CODESYS 用于通信的块驱动程序 CODESYS 网关与 CODESYS 控制器通过 CAN（服务通信）。通过 CANopen SDO 协议（“分段”或“块传输”）建立通信。组件 CmpBlkDrvCanServer 需要在控制器端以及相应的 CAN 微型驱动程序。控制器配置文件中的典型配置如下： [Components]\nComponent.1=CmpAnyCANMiniDriverComponent ; TODO: Replace component name by your CAN Mini driver component\nComponent.2=CmpBlkDrvCanServer\n[Components]\nComponent.1=CmpAnyCANMiniDriverComponent ; TODO: Replace component name by your CAN Mini driver component\nComponent.2=CmpBlkDrvCanServer\n\n[CmpCAACanL2]\n;If setting PersistentBaudrate is enabled (0: disabled; 1: enabled)\n;the baudrate will be stored into Net.X.DefaultBaudrate (where X equals NetId)\n;when opening the driver.\nPersistentBaudrate=1\n;Default baudrate for CAN network 0. This baudrate will be used when the network \n;is opened (e.g from CmpBlkDrvCan or CANopen) with the baudrate set to 0.\nNet.0.DefaultBaudrate=1000\n\n[CmpBlkDrvCanServer]\nCycleTimeMs=1\n0.NetId=0\n0.Baudrate=0 ; 0 means: use setting from CmpCAACanL2 section\n0.NodeId=10\n\n[CmpCAASdoServer]\nMaxSegmentsPerCycle=0 ;for block upload: maximum of sent segments per cycle\n;0 means infinity " }, 
{ "title" : "CODESYS 控制 RTE V3 ", 
"url" : "_rtsl_windows_rts_v3.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "TCP\/UDP 协议处理程序 (SysSocketLwIP) ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp-protocol_handler.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ TCP\/UDP 协议处理程序 (SysSocketLwIP) ", 
"snippet" : "从版本 3.5.16.0 开始，TCP\/UDP 堆栈集成在 CODESYS Control RTE . 过去，基于以太网的现场总线经常出现问题，这些问题基于 Windows 的协议栈（= 协议处理程序）（例如：EtherNet\/IP、ModbusTCP）。这些现场总线无法可靠地满足实时系统的期望。 随着内部协议栈的引入，SysEthernet 网络适配器驱动程序（ CmpEt100Drv , CmpEt1000Drv , CmpRTL813xMpd , CmpRTL8169Mpd , CmpCX5000Mpd ) 不再由 SysEthernet （或通过 IoDrvEtherCAT 和 IoD...", 
"body" : "从版本 3.5.16.0 开始，TCP\/UDP 堆栈集成在 CODESYS Control RTE . 过去，基于以太网的现场总线经常出现问题，这些问题基于 Windows 的协议栈（= 协议处理程序）（例如：EtherNet\/IP、ModbusTCP）。这些现场总线无法可靠地满足实时系统的期望。 随着内部协议栈的引入，SysEthernet 网络适配器驱动程序（ CmpEt100Drv , CmpEt1000Drv , CmpRTL813xMpd , CmpRTL8169Mpd , CmpCX5000Mpd ) 不再由 SysEthernet （或通过 IoDrvEtherCAT 和 IoDrvProfinet ).现在，它们也由 TCP\/UDP（用于直接 IP 通信的协议栈）寻址。 " }, 
{ "title" : "配置 ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp_configuration.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ TCP\/UDP 协议处理程序 (SysSocketLwIP) \/ 配置 ", 
"snippet" : "运行时系统要使用集成的TCP\/UDP协议栈，需要在RTE的组件列表中配置相应的网卡驱动。 RTE配置文件中的驱动 CODESYSControl_User.cfg 必须在段中输入 [ComponentManager] .此处所有可能的条目都已通过 RTE 的设置进行了预配置，并且可以在 PLC 配置 → 组件管理器 菜单或删除“;”在行的开头。 （Intel 的所有 10\/100\/1000 Mbit 网络适配器的示例： Component.xy=CmpEt1000Drv ) 不需要进行其他设置。网络适配器配置由 Windows 采用和使用。对于受影响的适配器，还必须在 Windows 设备管理器...", 
"body" : "运行时系统要使用集成的TCP\/UDP协议栈，需要在RTE的组件列表中配置相应的网卡驱动。 RTE配置文件中的驱动 CODESYSControl_User.cfg 必须在段中输入 [ComponentManager] .此处所有可能的条目都已通过 RTE 的设置进行了预配置，并且可以在 PLC 配置 → 组件管理器 菜单或删除“;”在行的开头。 （Intel 的所有 10\/100\/1000 Mbit 网络适配器的示例： Component.xy=CmpEt1000Drv ) 不需要进行其他设置。网络适配器配置由 Windows 采用和使用。对于受影响的适配器，还必须在 Windows 设备管理器中安装一个 SysEthernet 网络适配器驱动程序 可用的动态组件）。 网络适配器的驱动程序向内部协议栈注册，并在运行时决定是内部协议栈还是 Windows 必须用于所应用的协议。 " }, 
{ "title" : "协议栈的日志输出 ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp_log.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ TCP\/UDP 协议处理程序 (SysSocketLwIP) \/ 协议栈的日志输出 ", 
"snippet" : "日志输出是用户监控集成协议栈行为的唯一途径。 通过设置日志过滤器，记录器中写入的输出比默认设置提供的要多。为此，价值 Logger.0.Filter 设定为 0xFFFFFFFF 在 RTE 的配置文件中 CODESYSControl_User.cfg , 在段 [CmpLog] . 以下日志输出及其原因可以分配给集成的 TCP\/UDP 协议栈： *** SysSocketlwIP -> No network-adapter for LwIP available! 没有加载任何网络适配器驱动程序，因为它们要么不存在于配置（组件列表）中，要么没有通过 Windows 设备管理器为至少一个网络适配...", 
"body" : "日志输出是用户监控集成协议栈行为的唯一途径。 通过设置日志过滤器，记录器中写入的输出比默认设置提供的要多。为此，价值 Logger.0.Filter 设定为 0xFFFFFFFF 在 RTE 的配置文件中 CODESYSControl_User.cfg , 在段 [CmpLog] . 以下日志输出及其原因可以分配给集成的 TCP\/UDP 协议栈： *** SysSocketlwIP -> No network-adapter for LwIP available! 没有加载任何网络适配器驱动程序，因为它们要么不存在于配置（组件列表）中，要么没有通过 Windows 设备管理器为至少一个网络适配器安装。 *** SysSocketlwIP -> x network-adapters for LwIP available. 至少一个网络适配器可供集成协议栈使用。 *** SysSocketlwIP -> Switched to Winsock, use of unknown adapter! Winsock: 0xxxxxxxx . 冒号后带有句柄地址的套接字被传递到 Windows 的 IP 堆栈以供进一步使用。在大多数情况下，原因是 SysSockBind 或 SysSockSendTo 调用了内部协议栈未知的适配器地址，例如 127.0.0.1 (localhost) 或 0.0.0.0 (ANY_ADDR)。 启动运行时系统时，此类日志的输出是正常的，因为内部组件（例如 OPC UA 服务器、Web 服务器或 CmpBlkDrvTcp 链接到 localhost\/ANY_ADDR）。 *** Error: SysSocketlwIP driver -> local receive buffer overrun. 如果运行时系统非常繁忙（例如，由于 IEC 任务消耗了总可用计算能力的 80% 或 90% 以上），则可能会发生接收到的以太网帧无法在接收之前被协议栈及时评估的情况缓冲区已满。在 UDP 的情况下，此数据会丢失并且重复取决于上层协议。对于 TCP 连接，提供块重复。 其他 *** Error… 不应出现日志输出，如有必要，应向支持团队报告。 " }, 
{ "title" : "协议栈的通信任务 ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp_communication_task.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ TCP\/UDP 协议处理程序 (SysSocketLwIP) \/ 协议栈的通信任务 ", 
"snippet" : "内部协议栈需要自己的任务来处理许多 UDP 和 TCP\/IP 任务。此任务在运行时系统初始化时立即创建，优先级为 55，对应于 IEC 任务优先级 23。具有较高优先级的 IEC 任务不受 UDP\/TCP 通信的影响。在某些情况下，优先级较低的 IEC 任务会受到 UDP\/TCP 通信的影响。 有意设置优先级是为了让应用程序开发人员能够不因低优先级、耗时的任务而中断（现场总线）通信。或者定义比时间准确的沟通更重要的任务。...", 
"body" : "内部协议栈需要自己的任务来处理许多 UDP 和 TCP\/IP 任务。此任务在运行时系统初始化时立即创建，优先级为 55，对应于 IEC 任务优先级 23。具有较高优先级的 IEC 任务不受 UDP\/TCP 通信的影响。在某些情况下，优先级较低的 IEC 任务会受到 UDP\/TCP 通信的影响。 有意设置优先级是为了让应用程序开发人员能够不因低优先级、耗时的任务而中断（现场总线）通信。或者定义比时间准确的沟通更重要的任务。 " }, 
{ "title" : "检查时间行为 ", 
"url" : "_rtsl_windows_rte_v3_check_timing_rte.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 检查时间行为 ", 
"snippet" : "创建一个简单的标准项目 CODESYS . 将唯一任务配置为 1ms 循环时间。 将计数器变量编程为类型 DWORD 计算周期。 因此，您会立即检测到第 1000 位是否大约每秒增加一次，正如我们在本例中所希望的那样。 在联机模式下，打开 监控 选项卡中的 任务配置 . 您会看到由 RTE 计算的抖动时间。在正常系统中，这些波动为 ±100 μs。 如果硬件配备了串行或并行端口，那么您可以使用 SysPort.library 对上述项目中这些端口的各个引脚的输出进行编程。然后你可以检查时间行为 CODESYS Control RTE 非常精确地通过示波器。 如果您有一个带有数字 I\/O 的 E...", 
"body" : "创建一个简单的标准项目 CODESYS . 将唯一任务配置为 1ms 循环时间。 将计数器变量编程为类型 DWORD 计算周期。 因此，您会立即检测到第 1000 位是否大约每秒增加一次，正如我们在本例中所希望的那样。 在联机模式下，打开 监控 选项卡中的 任务配置 . 您会看到由 RTE 计算的抖动时间。在正常系统中，这些波动为 ±100 μs。 如果硬件配备了串行或并行端口，那么您可以使用 SysPort.library 对上述项目中这些端口的各个引脚的输出进行编程。然后你可以检查时间行为 CODESYS Control RTE 非常精确地通过示波器。 如果您有一个带有数字 I\/O 的 EtherCAT 从站，那么您也可以使用这些 I\/O 通过示波器执行非常好的测量。 有关更多信息，请参阅： 在特殊平台上配置实时行为 和 标签：监控 " }, 
{ "title" : "在特殊平台上配置实时行为 ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 在特殊平台上配置实时行为 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "的实时行为 CODESYS Control RTE 在特殊平台上 ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-904131440f59a05ac0a864633beb1ad4", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 在特殊平台上配置实时行为 \/ 的实时行为 CODESYS Control RTE 在特殊平台上 ", 
"snippet" : "的时间行为 CODESYS Control RTE 取决于CPU时钟的一致性和前端总线的周期。通过 BIOS 和 Windows 中的特定设置，您可以修改时间行为以适应不同平台的条件。...", 
"body" : "的时间行为 CODESYS Control RTE 取决于CPU时钟的一致性和前端总线的周期。通过 BIOS 和 Windows 中的特定设置，您可以修改时间行为以适应不同平台的条件。 " }, 
{ "title" : "BIOS 中的设置 ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-24bd95e00f59a05ac0a8646332b0218d", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 在特殊平台上配置实时行为 \/ BIOS 中的设置 ", 
"snippet" : "对于优化时间行为，只能给出一般性建议 CODESYS Control RTE 因为大多数平台都有不同类型的 BIOS。...", 
"body" : "对于优化时间行为，只能给出一般性建议 CODESYS Control RTE 因为大多数平台都有不同类型的 BIOS。 " }, 
{ "title" : "Windows 中的设置 ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-6c4e42d628502216c0a864630d4e6b2f", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 在特殊平台上配置实时行为 \/ Windows 中的设置 ", 
"snippet" : "建议：电源方案应始终设置为“ 始终开启 ”。 自动更新 ：对于工业控制器，更新应始终手动执行，因为 PC 可能会在没有任何用户提示的情况下通过自动机制重新启动。...", 
"body" : "建议：电源方案应始终设置为“ 始终开启 ”。 自动更新 ：对于工业控制器，更新应始终手动执行，因为 PC 可能会在没有任何用户提示的情况下通过自动机制重新启动。 " }, 
{ "title" : "针对“APIC”（单处理器和多处理器）和“AMP”（单个 CPU 内核上的 RTE 操作）的调整 ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-3cbaa0b1908b4745c0a86463315e2cd5", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 在特殊平台上配置实时行为 \/ 针对“APIC”（单处理器和多处理器）和“AMP”（单个 CPU 内核上的 RTE 操作）的调整 ", 
"snippet" : "对平台具体特征的一般适应是由 CmpDrvSchedulerAMP 和 CmpDrvSchedulerAPIC 组件（自 Windows 7 停产以来不再相关）。 默认情况下， CmpDrvSchedulerAMP 从安装程序安装 CODESYS Control RTE . CmpDrvSchedulerAPIC 仅出于兼容性原因仍然包括在内，并且只能在旧的 Windows 7 PC 上手动安装。 一般来说， CODESYS Control RTE 只能在具有多个处理器内核的 PC 上运行（ CmpDrvSchedulerAMP ).唯一的例外是 Windows 平台“Windows 7（32...", 
"body" : "对平台具体特征的一般适应是由 CmpDrvSchedulerAMP 和 CmpDrvSchedulerAPIC 组件（自 Windows 7 停产以来不再相关）。 默认情况下， CmpDrvSchedulerAMP 从安装程序安装 CODESYS Control RTE . CmpDrvSchedulerAPIC 仅出于兼容性原因仍然包括在内，并且只能在旧的 Windows 7 PC 上手动安装。 一般来说， CODESYS Control RTE 只能在具有多个处理器内核的 PC 上运行（ CmpDrvSchedulerAMP ).唯一的例外是 Windows 平台“Windows 7（32 位）”。这 CmpDrvSchedulerAPIC 仍然只能在这个平台上使用。有了这个组件， CODESYS Control RTE 可以使用时间分片与 Windows 共享 CPU 核心 0。 启动时执行复杂的测试 CODESYS Control RTE 第一次为了将时钟速度缩放到微秒。此消息的结果保存在 Windows 注册表中： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\CmpDrvSchedulerAMP\\Params 或者 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\CmpDrvSchedulerAPIC\\Params , 值 SetClocksPerUS 和 SetCountsPerMS . 每次 CODESYS Control RTE 启动时，当第一次启动时测量得到的值可以从注册表中读取时，不再进行测量。如果在系统中进行的调整（例如，BIOS 中的节能设置）导致 CPU 时钟因测量而改变，则必须从 Windows 注册表中删除这些值。只有这样，时钟速率才会重新调整，当 CODESYS Control RTE 又开始了。 有关详细信息，请参阅： 硬件配置-建议" }, 
{ "title" : "调试 Hilscher CIFX 卡 ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 调试 Hilscher CIFX 卡 ", 
"snippet" : "以下是安装 Hilscher CIFX 网卡的步骤 CODESYS Control RTE 描述。该过程独立于所使用的现场总线系统。 支持以下带有 CIFX 的现场总线： PROFINET 控制器和 PROFINET -设备 PROFIBUS 师父和 PROFIBUS 控制器 netX-CAN EtherNet\/IP 扫描器...", 
"body" : "以下是安装 Hilscher CIFX 网卡的步骤 CODESYS Control RTE 描述。该过程独立于所使用的现场总线系统。 支持以下带有 CIFX 的现场总线： PROFINET 控制器和 PROFINET -设备 PROFIBUS 师父和 PROFIBUS 控制器 netX-CAN EtherNet\/IP 扫描器 " }, 
{ "title" : "安装 Windows 驱动程序 ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-3b8953bc0e40fc79c0a8646325dd6b8e", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 调试 Hilscher CIFX 卡 \/ 安装 Windows 驱动程序 ", 
"snippet" : "当您使用 Hilscher 卡操作时 CODESYS Control RTE 运行时系统，那么您不得使用为网络适配器提供的 Hilscher 驱动程序。如果你使用 CODESYS Control RTE 使用 NetX，则需要安装 SysDrv3s.sys ( SysDrv3S 子目录），随 RTE 安装包提供。...", 
"body" : "当您使用 Hilscher 卡操作时 CODESYS Control RTE 运行时系统，那么您不得使用为网络适配器提供的 Hilscher 驱动程序。如果你使用 CODESYS Control RTE 使用 NetX，则需要安装 SysDrv3s.sys ( SysDrv3S 子目录），随 RTE 安装包提供。 " }, 
{ "title" : "NetX 固件和 NetX 引导加载程序 ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-82e7a36597005e19c0a864632973a990", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 调试 Hilscher CIFX 卡 \/ NetX 固件和 NetX 引导加载程序 ", 
"snippet" : "NetX 固件和 NetX 引导加载程序与安装包一起提供，位于子文件夹中 HilscherCIFX\\Firmware 安装后。...", 
"body" : "NetX 固件和 NetX 引导加载程序与安装包一起提供，位于子文件夹中 HilscherCIFX\\Firmware 安装后。 " }, 
{ "title" : "添加组件 ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-6d2a7e991eb48aa8c0a86463368630e2", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 调试 Hilscher CIFX 卡 \/ 添加组件 ", 
"snippet" : "在里面 CODESYS Control RTE 菜单，点击 PLC 配置 . 在对话框中，切换到 组件管理器 标签。 添加可选组件 CmpHilscherCIFX 并点击 行 确认。...", 
"body" : "在里面 CODESYS Control RTE 菜单，点击 PLC 配置 . 在对话框中，切换到 组件管理器 标签。 添加可选组件 CmpHilscherCIFX 并点击 行 确认。 " }, 
{ "title" : "使用“CODESYSControl.cfg”配置 RTE ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-a4398f680e40fc88c0a864635dd4fc93", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 调试 Hilscher CIFX 卡 \/ 使用“CODESYSControl.cfg”配置 RTE ", 
"snippet" : "配置文件 CODESYSControl.cfg 位于安装目录中。 添加组件 CmpHilscherCifX ： [ComponentManager] ...Component.x=CmpHilscherCIFX ... 在细分 CmpHilscherCIFX ，根据CIFX卡的数量激活对应的行（去掉行首的“;”）。 ... [CmpHilscherCIFX] ;TraceLevel=0xFFFFFFFF Device.0.BootloaderFilePath=... (see image) Device.0.Channel.0.FirmwareFile=... TraceLevel ：激活 C...", 
"body" : "配置文件 CODESYSControl.cfg 位于安装目录中。 添加组件 CmpHilscherCifX ： [ComponentManager]\n...Component.x=CmpHilscherCIFX\n... 在细分 CmpHilscherCIFX ，根据CIFX卡的数量激活对应的行（去掉行首的“;”）。 ...\n[CmpHilscherCIFX]\n;TraceLevel=0xFFFFFFFF\nDevice.0.BootloaderFilePath=... (see image)\nDevice.0.Channel.0.FirmwareFile=...\n\n TraceLevel ：激活 CODESYS 记录器中的其他调试任务 BootloaderFilePath ：每个 NetX 控制器的 NetX 引导加载程序的文件路径和文件名。相对路径从安装目录开始。也可以使用绝对路径。如果您使用多个 NetX 控制器，则必须指定多个文件路径。 ...\nDevice.0.BootloaderFilePath=NXCIF50-RTE.bin\nDevice.1.BootloaderFilePath=NXCIF50-RTE.bin\n... Device.X.Channel.X.FirmwareFile ：每个适配器和每个通道的 NetX 固件的文件路径和文件名。相对路径从安装目录开始。也可以使用绝对路径。最重要的是只使用“通道 0”。如果您使用多个 NetX 芯片，则必须指定多个文件路径。 ...\nDevice.0.Channel.0.FirmwareFile=cifxdpm.nxf\nDevice.1.Channel.0.FirmwareFile=cifxdpm.nxf\n... 结果： " }, 
{ "title" : "启动运行时系统 ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-b219f19c0e40fc88c0a864630469e13f", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 调试 Hilscher CIFX 卡 \/ 启动运行时系统 ", 
"snippet" : "通过单击启动运行时系统 启动 PLC 在 SysTray 菜单中 CODESYS Control RTE . 一旦运行时系统运行，条目 CmpHilscherCIFX 出现在运行时系统记录器中。您会看到条目中的 日志 设备编辑器对话框 CODESYS ，以及在 LogPLCxx.csv 文件中 CODESYS Control RTE 目录。 检查以下内容： 组件 CmpHilscherCIFX 必须已加载。 工具包版本 CmpHilscherCIFX 必须显示组件。 固件已加载。记录器会通知固件的名称和版本。 如果你设置 TraceLevel 到 0xFFFFFFFF , 然后信息从 CmpH...", 
"body" : "通过单击启动运行时系统 启动 PLC 在 SysTray 菜单中 CODESYS Control RTE . 一旦运行时系统运行，条目 CmpHilscherCIFX 出现在运行时系统记录器中。您会看到条目中的 日志 设备编辑器对话框 CODESYS ，以及在 LogPLCxx.csv 文件中 CODESYS Control RTE 目录。 检查以下内容： 组件 CmpHilscherCIFX 必须已加载。 工具包版本 CmpHilscherCIFX 必须显示组件。 固件已加载。记录器会通知固件的名称和版本。 如果你设置 TraceLevel 到 0xFFFFFFFF , 然后信息从 CmpHilscherCIFX 对于每个已配置的 NetX 通道。 有关更多信息，请参阅： 标签：日志 " }, 
{ "title" : "创建一个 CODESYS 具有 I\/O 配置的项目 ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-1f474e4c0e40fc88c0a8646300249b0e", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 调试 Hilscher CIFX 卡 \/ 创建一个 CODESYS 具有 I\/O 配置的项目 ", 
"snippet" : "现在您可以创建一个简单的 CODESYS 带有正在运行的现场总线的项目： 在中创建一个新的标准项目 CODESYS .选择设备 CODESYS Control RTE 创建时。 在设备树中添加 CIFX-PB 现场总线主站。 双击设备树中的条目，打开现场总线主站的配置对话框。切换到 NetX 配置 标签。设置的值 投币口 和 NetX 通讯频道 使它们与配置文件中的设备号相同 CODESYSControl.cfg .将这些值与运行时系统的记录器条目进行比较。 构建应用程序。将应用程序下载到控制器并启动它。 设备树的每个节点现在都必须标记为绿色。...", 
"body" : "现在您可以创建一个简单的 CODESYS 带有正在运行的现场总线的项目： 在中创建一个新的标准项目 CODESYS .选择设备 CODESYS Control RTE 创建时。 在设备树中添加 CIFX-PB 现场总线主站。 双击设备树中的条目，打开现场总线主站的配置对话框。切换到 NetX 配置 标签。设置的值 投币口 和 NetX 通讯频道 使它们与配置文件中的设备号相同 CODESYSControl.cfg .将这些值与运行时系统的记录器条目进行比较。 构建应用程序。将应用程序下载到控制器并启动它。 设备树的每个节点现在都必须标记为绿色。 " }, 
{ "title" : "常问问题 ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-d19e04ada023b398c0a8646370386558", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 调试 Hilscher CIFX 卡 \/ 常问问题 ", 
"snippet" : "设备树中的现场总线主站不是绿色的。我怎样才能找到问题？ 打开 PLC 的配置编辑器（ 通讯设置 也可以在此编辑器中找到），切换到 日志 选项卡，然后单击绿色箭头。 CODESYS 加载并显示来自 PLC 的所有记录器条目。然后您可以搜索错误和异常。 有未解决的引用。 如果应用程序中存在未解析的引用，则未加载运行时系统组件或加载了不正确的版本。检查 CODESYS 记录器。组件 CmpHilscherCIFX 必须已加载。 如果 CmpHilscherCIFX 尚未加载，则在组件中输入 CODESYSControl.cfg 文件。 如果 CmpHilscherCIFX 已加载，则可能使用了已弃用...", 
"body" : "设备树中的现场总线主站不是绿色的。我怎样才能找到问题？ 打开 PLC 的配置编辑器（ 通讯设置 也可以在此编辑器中找到），切换到 日志 选项卡，然后单击绿色箭头。 CODESYS 加载并显示来自 PLC 的所有记录器条目。然后您可以搜索错误和异常。 有未解决的引用。 如果应用程序中存在未解析的引用，则未加载运行时系统组件或加载了不正确的版本。检查 CODESYS 记录器。组件 CmpHilscherCIFX 必须已加载。 如果 CmpHilscherCIFX 尚未加载，则在组件中输入 CODESYSControl.cfg 文件。 如果 CmpHilscherCIFX 已加载，则可能使用了已弃用的版本。在这种情况下，通过重新安装 RTE 来更新整个运行时系统。 TraceLevel 已激活，但找不到新条目 CmpHilscherCIFX 零件。 这意味着运行时找不到 NetX 适配器或芯片。检查适配器是否正确插入并安装相应的驱动程序。有关更多信息，请参见上文： 安装 Windows 驱动程序. " }, 
{ "title" : "硬件配置-建议 ", 
"url" : "_rtsl_windows_rte_v3_examples_hints.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 硬件配置-建议 ", 
"snippet" : "您可能必须调整 BIOS 设置才能使 CODESYS Control RTE 以最佳的低抖动在各自的平台上运行。请参阅以下调整示例，这些示例仅应视为建议。 应始终禁用以下 BIOS 设置： HT（使用英特尔 CPU 进行超线程；使用 AMD CPU 进行同步多线程） VT（英特尔 CPU 的虚拟化技术；适用于 AMD CPU 的 AMD-V） 在Windows 10或更高版本中，VT使Windows本身在虚拟环境中启动，因此，即使Windows没有使用CPU内核，RTE也无法启动CPU内核。 因此，禁用此 BIOS 选项的另一种方法是禁用 Windows 的 “虚拟机平台” 功能或 “Wind...", 
"body" : "您可能必须调整 BIOS 设置才能使 CODESYS Control RTE 以最佳的低抖动在各自的平台上运行。请参阅以下调整示例，这些示例仅应视为建议。 应始终禁用以下 BIOS 设置： HT（使用英特尔 CPU 进行超线程；使用 AMD CPU 进行同步多线程） VT（英特尔 CPU 的虚拟化技术；适用于 AMD CPU 的 AMD-V） 在Windows 10或更高版本中，VT使Windows本身在虚拟环境中启动，因此，即使Windows没有使用CPU内核，RTE也无法启动CPU内核。 因此，禁用此 BIOS 选项的另一种方法是禁用 Windows 的 “虚拟机平台” 功能或 “Windows 虚拟机管理程序平台” 功能。最后，禁用 VT 选项是 BIOS 是更好的选择。 导致周期性 SMI 的传统 USB 或其他 BIOS 功能。 SMI 是系统管理中断，可使整个系统停止几十或数百微秒。 可导致频率变化的英特尔或 AMD 处理器的节能选项（例如英特尔 CPU 的 EIST，或适用于 AMD CPU 的 Cool'n'Quiet） 定期自测或记忆力测试 “睡眠模式” 起着决定性作用（ACPI术语中的 “C状态”）。“C” 后面的数字越大表示睡眠状态越低。在睡眠模式下，处理器不仅会降低电压和时钟速度，还会停用缓存和服务中的整个区域。在 BIOS 中，造成这种情况的选项通常被称为 “C 状态”。 英特尔的 “SpeedStep” 或 AMD 的 “PowerNow” 有时被称为 “EIST”，在这种情况下必须将其禁用。 如果 BIOS 未涵盖处理器设置的检查或配置，或者该选项不可用，则可以在 Internet 上找到相应的工具。例子： RightMark CPU CPU-Z (CPUID) RM Clock 电源选项，例如 快速启动 或者 休眠 在任何情况下都不允许。 " }, 
{ "title" : "可用的动态组件 ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 可用的动态组件 ", 
"snippet" : "可选组件用于适配 CODESYS Control RTE 到特定的硬件。您还可以将这些组件加载到配置中 组件管理器 的选项卡 PLC配置 对话。有关详细信息，请参阅： 对话框：系统配置 - 组件管理器...", 
"body" : "可选组件用于适配 CODESYS Control RTE 到特定的硬件。您还可以将这些组件加载到配置中 组件管理器 的选项卡 PLC配置 对话。有关详细信息，请参阅： 对话框：系统配置 - 组件管理器" }, 
{ "title" : "适配硬件平台 ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-80961508ba9b6b22c0a8646354292cdd", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 可用的动态组件 \/ 适配硬件平台 ", 
"snippet" : "在多核处理器上， CmpDrvSchedulerAMP 始终由设置初始化。这会将 RTE 的执行卸载到 Windows 未使用的 CPU 内核。在 Windows 64 位或 Windows 版本 > 7 上，只有通过这种方式才能进行实时操作。因此，安装程序将通过引导选项将 Windows 的执行限制为第一个 <number of physical available cores - 1> 个核心 numproc .必须完全放弃超线程内核。安装程序识别平台并自动输入所需的驱动程序作为 RTE cfg 文件中的第一个组件。这绝对不能改变。 当应用硬件的速度确定时，驱动程序会在第一次启动时保存测量...", 
"body" : "在多核处理器上， CmpDrvSchedulerAMP 始终由设置初始化。这会将 RTE 的执行卸载到 Windows 未使用的 CPU 内核。在 Windows 64 位或 Windows 版本 > 7 上，只有通过这种方式才能进行实时操作。因此，安装程序将通过引导选项将 Windows 的执行限制为第一个 <number of physical available cores - 1> 个核心 numproc .必须完全放弃超线程内核。安装程序识别平台并自动输入所需的驱动程序作为 RTE cfg 文件中的第一个组件。这绝对不能改变。 当应用硬件的速度确定时，驱动程序会在第一次启动时保存测量结果。这些作为它们的名称保存在系统服务的路径中 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Service 在关键 Params .在所有后续系统启动时，从注册表中读取确定的值。当缺少值时，将再次进行测量。 " }, 
{ "title" : "支持可选的现场总线适配器 ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-db3e9d0eba9b6b22c0a86463246ec925", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 可用的动态组件 \/ 支持可选的现场总线适配器 ", 
"snippet" : "CmpEt1000Drv 司机 该驱动直接支持 Pro1000 - 来自英特尔的兼容芯片组。要使用该组件，您必须在 Windows 的设备管理器中将英特尔的原始驱动程序替换为该驱动程序。继续如下： 打开 Windows 设备管理器。 右键单击选定的 Pro1000 网络适配器，然后单击命令 更新驱动软件 . 手动选择驱动程序并将路径指定为 <RTE installation directory>\\CmpET1000MPD . 如果设备管理器拒绝安装驱动，请按 <删除> 键，并删除对应的 inf 和 pnf 目录中的文件 <SystemRoot>\\inf .笔记： SystemRoot 通常是 ...", 
"body" : "CmpEt1000Drv 司机 该驱动直接支持 Pro1000 - 来自英特尔的兼容芯片组。要使用该组件，您必须在 Windows 的设备管理器中将英特尔的原始驱动程序替换为该驱动程序。继续如下： 打开 Windows 设备管理器。 右键单击选定的 Pro1000 网络适配器，然后单击命令 更新驱动软件 . 手动选择驱动程序并将路径指定为 <RTE installation directory>\\CmpET1000MPD . 如果设备管理器拒绝安装驱动，请按 <删除> 键，并删除对应的 inf 和 pnf 目录中的文件 <SystemRoot>\\inf .笔记： SystemRoot 通常是 ” C:Windows ”。 这 信息 此处使用的文件被广泛命名 net557*.inf \/ pnf 或者 net559*.inf \/ pnf .注意：如果参考 Pro1000 在里面 inf 文件，那么它通常是正确的文件。这 pnf 文件始终与 inf 文件。 然后当系统重新启动时，Windows 无法再自动安装驱动程序。硬件管理器已启动，驱动程序已启动 <RTE installation directory>\\CmpET1000MPD 被转移到它。 您还必须启用文件中的运行时组件 CODESYSControl_User.cfg : Component.<subsequent number>=CmpEt1000Drv CmpEt100Drv 司机 注意：此驱动程序仅出于兼容性目的而提供。无法再购买硬件。 该驱动直接支持 Pro100 - 来自英特尔的兼容芯片组。要使用该组件，您必须在 Windows 的设备管理器中将英特尔的原始驱动程序替换为该驱动程序。继续如下： 打开 Windows 设备管理器。 右键单击选定的 Pro100 网络适配器，然后单击命令 更新驱动软件 . 手动选择驱动程序并将路径指定为 <RTE installation directory>\\CmpET100MPD . 如果设备管理器拒绝安装驱动，请按 <删除> 键，并删除对应的 inf 和 pnf 目录中的文件 <SystemRoot>\\inf .笔记： SystemRoot 通常是 ” C:\\Windows ”。 这 信息 此处使用的文件被广泛命名 net557*.inf \/ pnf 或者 net559*.inf \/ pnf .注意：如果参考 Pro100 在里面 inf 文件，那么它通常是正确的文件。这 pnf 文件始终与 inf 文件。 然后当系统重新启动时，Windows 无法再自动安装驱动程序。硬件管理器已启动，驱动程序已启动 <RTE installation directory>\\CmpET100MPD 被转移到它。 您还必须启用文件中的运行时组件 CODESYSControl_User.cfg : Component.<subsequent number>=CmpEt100Drv CmpSJACanDrv 司机 CmpSJACanDrv 是基于 CAN 控制器的 CAN 硬件通用驱动程序 SJA1000 或兼容的控制器。直接支持 Peak、Ixxat（被动 CAN 适配器）和 Automata 的 PCI 适配器。 安装好适配器后，可以从目录中选择安装对应的驱动 W2K_XP_Drivers （在 RTE 安装目录中）。为此，请使用上方直接显示的向导 发现新硬件 ，或者使用Windows的设备管理器（上下文菜单：命令 更新驱动软件 ）。您可以通过在上述目录之一中手动选择驱动程序和导航来安装所需的驱动程序。该设备位于类别“ 3S compatible devices ”。 注意：不得安装制造商的原始驱动程序。 司机 CmpSJACanDrv 也可以解决 SJA1000 控制器固定在硬件上。这些板载 CAN 控制器的属性可以通过配置文件中的条目传递给驱动程序 CODESYS Control RTE 在该部分 [CmpSJACanDrv] .可能的条目： NumDevices=1 <number of SJAs> ;Number of SJAs, that are configured in the following>\n;(optional: <DisableRetain=1> The driver is told that it should\n; not create any retain entry in the cfg file, even if a CAN adapter is equipped with NVRAM.)\n0.Address=<physical address of the SJA1000> \n0.Interrupt=<interrupt vector of the SJA1000>\n0.IntEdgeTrig=<0 or 1. 0 hardware dependent>\n0.XtalFrequency=<frequency> ;normally 16000000Hz, 24000000Hz is also a possible variant\n0.BusType=<bus type> ;depending on the type of switching of the SJA, \n;1 for ISA, 3 for PCI, 0 for memory\n0.Alignment=<alignment> ;normally 1, hardware dependent\n0.Name=<any name>\n.OutputCtrl=<valid values:e.g. 0xFE, 4C, 1A> ;Depends on the CAN switching\n0.PortAddress=<port address> ;This address is written one time for \n;initializing the CAN switching.\n0.PortValue=<vlaue> ;The value that is written for the initialization. CmpNetXCanDlDrv 司机 此组件是用于 NetX CAN 适配器的 CAN 微型驱动程序。有了这个司机， CODESYS Control RTE 可以使用来自的 CAN 库 CODESYS GmbH 通过 NetX 适配器。 CmpNetXCanDlDrv 只能与 CmpHilscherCIFX 您必须在其上加载 CAN 固件（主站或从站）。使用主设备还是从设备都没有关系，因为 CmpNetXCanDlDrv 仅使用适配器的 CAN 驱动程序接口。该协议由 3S CAN 库管理。 配置文件中组件的配置 CODESYS Control RTE ： [CmpNetXCanDlDrv]MaxNumberOfCanNetworks=0..n -> number of the CAN networks (number of the NetIds)\nNetId.0.Channel=0 -> mapping of the NetId onboard nad NetX channels (see CmpHilscherCIFX)\nNetId.0.Board=0 CmpRTL81x9Mpd 司机 注意：此驱动程序仅出于兼容性目的而提供。无法再购买硬件。 该驱动直接支持 Realtek RTL8139 （和兼容的）以太网控制器。组合芯片组 8100 和 8110 也兼容。安装也类似于 CmpEt100Drv . CmpRTL8169Mpd 司机 以同样的方式 CmpRTL81x9Mpd ;对于上述的千兆变体 Realtek 以太网控制器。 CmpServos3Master 司机 该驱动程序支持 SERCOS III PCI adapter 700353x0 来自自动机。安装适配器后，从 W2K_XP_Drivers\\Automata_SERCOS3 . CmpHilscherCIFX 司机 该驱动程序支持 Hilscher 的 CifX 卡。 安装卡后，您可以安装 Hilscher 提供的驱动程序或 SysDrv3S . （在供货范围内 CODESYS Control Win 适用于 Windows 的运行时系统 CODESYS GmbH ）。 指定组件中的 cfg 文件的 CODESYS Control RTE .这可以通过编辑器或通过 PLC配置 对话。生成 [CmpHilscherCIFX] 部分也是如此。驱动程序需要以下条目（示例）： Device.0.BootloaderFilePath=NXCIF50-RTE.bin\nDevice.0.Channel.0.FirmwareFile=cifxdpm.nxf 在这个例子中， 0 在 Device.0 如果使用多个，则为适配器的从 0 开始的索引。 Channel 总是紧随其后 0 因为赫优讯的所有 PCI 适配器都只支持一个通道。 包含引导加载程序或固件的文件随 Hilscher 的 CifX 卡一起提供。您必须将它们放在根文件目录中 CODESYS Control RTE .您可能还必须调整配置文件中的文件名或条目。 有关更多信息，请参阅： 调试 Hilscher CIFX 卡 " }, 
{ "title" : "NVRAM PCI 插件适配器 ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-70a6f7c2ba9b6b22c0a86463083c7758", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 可用的动态组件 \/ NVRAM PCI 插件适配器 ", 
"snippet" : "CmpPciRetain 司机 此驱动程序允许使用 NVRAM 作为 PCI 适配器上的保留内存。要求： NVRAM 可以通过 PCI 寄存器中的物理地址直接访问，并且支持所有范围的访问，例如字节、字和双字访问。 您可以使用配置文件中的以下条目来配置组件 CoDeSysControl.cfg 的 CODESYS Control RTE 在该部分 [CmpPciRetain] ： VendorID , DeviceID , SubDeviceID , SubVendorID : PCI 设备的标识。 AddressIndex ：PCI地址寄存器（ BAR0 – BAR5 )，其中包含 NVRAM...", 
"body" : "CmpPciRetain 司机 此驱动程序允许使用 NVRAM 作为 PCI 适配器上的保留内存。要求： NVRAM 可以通过 PCI 寄存器中的物理地址直接访问，并且支持所有范围的访问，例如字节、字和双字访问。 您可以使用配置文件中的以下条目来配置组件 CoDeSysControl.cfg 的 CODESYS Control RTE 在该部分 [CmpPciRetain] ： VendorID , DeviceID , SubDeviceID , SubVendorID : PCI 设备的标识。 AddressIndex ：PCI地址寄存器（ BAR0 – BAR5 )，其中包含 NVRAM 的物理基地址。默认值： 0 . MemorySize ：可用 NVRAM 的大小（以字节为单位）。默认值： 0x80000 (512 KB)。 AddrOffset : NVRAM 相对于使用的地址寄存器的移动。 请参阅所用 PCI 适配器的文档以了解 AddressIndex , MemorySize ， 和 AddrOffset . 四个 ID 的默认值标识 Siemens NanoBox PC 中的 MRAM 设备。 " }, 
{ "title" : "Beckhoff CX5xxx 特定组件 ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-821f92efba9b6b32c0a8646353736f59", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ 可用的动态组件 \/ Beckhoff CX5xxx 特定组件 ", 
"snippet" : "CmpCX5000Mpd 司机 这是一个 Windows 网络驱动程序。它只能用于 CXxxxx Beckhoff PC 具有 CX5000 通讯处理器。 如果设置 CODESYS Control RTE 在一个执行 CXxxxx PC，然后是驱动程序 CmpCX5000Mpd 会自动安装并添加到组件列表中（在 cfg 文件中）。 附加信息和手动安装： 例外：CX-IPC 默认安装为“Windows7 嵌入式标准”。这包括带有硬件 ID 的 PCI 设备的 Beckhoff 驱动程序 VendorID = SubVendorID = 0x15ec 和 DeviceID = SubDeviceI...", 
"body" : "CmpCX5000Mpd 司机 这是一个 Windows 网络驱动程序。它只能用于 CXxxxx Beckhoff PC 具有 CX5000 通讯处理器。 如果设置 CODESYS Control RTE 在一个执行 CXxxxx PC，然后是驱动程序 CmpCX5000Mpd 会自动安装并添加到组件列表中（在 cfg 文件中）。 附加信息和手动安装： 例外：CX-IPC 默认安装为“Windows7 嵌入式标准”。这包括带有硬件 ID 的 PCI 设备的 Beckhoff 驱动程序 VendorID = SubVendorID = 0x15ec 和 DeviceID = SubDeviceID = 0x5000 .安装后 CODESYS Control RTE , 你可以用驱动替换这个驱动 CmpCX5000Mpd.sys .在这种情况下，使用函数 更新驱动软件 在 Windows 控制面板中： 打开 Windows 设备管理器。搜索Beckhoff的系统设备，右键点击，然后执行命令 更新驱动软件 . 在向导中，选择 手动搜索驱动软件 选项并单击 有磁盘 . 选择 inf 安装目录下的文件 CODESYS Control RTE （子目录 CmpCX5000Mpd ）。 确认是否应安装驱动程序的任何提示。 Windows 安装一个名为 CX5000 driver for CODESYS Ethernet . 在配置文件中手动指定驱动 CoDeSysControl.cfg （安装目录 CODESYS Control RTE ）： 例子： Component.3=CmpCX5000Mpd . 然后下载一个 CODESYS 使用 EtherCAT 的项目不应再显示未解析的引用。 CmpCXSecUPS 司机 该驱动程序只能在 Beckhoff 的 CX5000 或 CX5100 系列的“嵌入式 PC”上使用。 该组件监控一个引脚，该引脚监控通信任务的低优先级循环调用中的电源状态。 如果检测到电源故障，则应用程序将停止并将保留数据保存在文件中（通常 Application.ret ). 注意：保存保留数据时存在以下限制： 根据 PLC 的当前负载，可能会延迟电源故障的检测。 根据 PC 的负载，断电后可用于保存数据的时间会有所不同。 由于这些限制，您必须使用已完成的应用程序测试保留数据的存储。此外，建议在应用程序启动时检查剩余变量的有效性。 该组件没有任何配置选项。您只需将它们添加到控制器的组件列表中。 有关更多信息，请参阅： RTE 的注册表项 " }, 
{ "title" : "RTE 的注册表项 ", 
"url" : "_rtsl_windows_rte_v3_registry_entries.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ CODESYS 控制 RTE V3 \/ RTE 的注册表项 ", 
"snippet" : "的行为 CODESYS Control RTE 可以在 Windows 注册表编辑器（Windows 注册表）中进行部分配置。下表提供了有关在缺少值时使用的值和相应默认值的信息。这些值的一部分只能在 PLC 配置 的对话 CODESYS Control RTE . 所有值都位于注册表中的路径 HKEY_LOCAL_MACHINE\\SOFTWARE\\3S-Smart Software Solutions GmbH\\CODESYS SP\\3SRTE3 ，或者当在表中的名称之前指定键时是相对的。 名称 类型 意义 默认值 AutoStartPLC DWORD 0 或者 1 ： 和 1 ，PLC由系统...", 
"body" : "的行为 CODESYS Control RTE 可以在 Windows 注册表编辑器（Windows 注册表）中进行部分配置。下表提供了有关在缺少值时使用的值和相应默认值的信息。这些值的一部分只能在 PLC 配置 的对话 CODESYS Control RTE . 所有值都位于注册表中的路径 HKEY_LOCAL_MACHINE\\SOFTWARE\\3S-Smart Software Solutions GmbH\\CODESYS SP\\3SRTE3 ，或者当在表中的名称之前指定键时是相对的。 名称 类型 意义 默认值 AutoStartPLC DWORD 0 或者 1 ： 和 1 ，PLC由系统服务自动启动。 0 AllowSetAppConfiguration DWORD 0 或者 1 ：确定用户是否可以使用对话框来设置 应用 配置对话框。 1 AllowSetCMConfiguration DWORD 0 订单 1 : <与上一条相同> 1 AllowSetFileConfiguration DWORD 0 订单 1 : <与上一条相同> 1 AllowSetLoggerConfiguration DWORD 0 订单 1 : <与上一条相同> 1 AllowSetSchedConfiguration DWORD 双字 0 订单 1 : <与上一条相同> 1 AllowSetTargetConfiguration DWORD 0 订单 1 : <与上一条相同> 1 CallBuffersize DWORD 异步函数调用的缓冲区大小（从 Windows 执行的所有函数调用（例如，文件服务或套接字函数）。应用程序需要的同时调用越多，出于性能原因，该缓冲区应该越大。 65536 CfgFile STRING 这个值直接指向的配置文件 CODESYS Control RTE . <安装路径 CODESYS Control RTE > DisablePlcAutoStart DWORD 该值由内部使用 PLC 配置 对话。此变量可以手动更改，例如，仅当配置对话框崩溃并且变量不再写入时 0 自动地。 0 ShowAppConfiguration DWORD 0 或者 1 ：确定用户是否可以查看 应用 选项卡中的 PLC 配置 对话。 1 ShowCMConfiguration DWORD 0 订单 1 : <与上一条相同> 1 ShowFileConfiguration DWORD 0 订单 1 : <与上一条相同> 1 ShowLoggerConfiguration DWORD 0 订单 1 : <与上一条相同> 1 ShowSchedConfiguration DWORD 0 订单 1 : <与上一条相同> 1 ShowTargetConfiguration DWORD 0 订单 1 : <与上一条相同> 1 LastExit DWORD 0 或者 1 用于控制最后一次退出 RTE 是否成功。 1 Path STRING 该值指向的目录是文件系统的根路径 CODESYS Control RTE . <安装路径 CODESYS Control RTE > SysTrayLocalPort DWORD 在“SysTray”和系统服务之间进行本地通信的 TCP\/IP 端口 CODESYS Control RTE . 15965 SysTrayRemoteAddr DWORD 双字 应使用的“SysTray”管理的远程系统的 IP 地址 CODESYS Control RTE . 0 SysTrayRemotePort DWORD 与...一样 SysTrayLocalPort ;对于远程系统。 15965 SysTrayUseRemotePLC DWORD 0 或者 1 : 判断是本地 PC 还是 CODESYS Control RTE 应在另一台 PC（远程系统）上进行处理。 0 KernelVersion STRING 版本 CODESYS Control RTE 上次在这台 PC 上启动。每次都写 CODESYS Control RTE 开始。 <版本号> VersionSrv STRING 系统服务的版本 CODESYS Control RTE .应始终与内核的版本相同，但出于测试目的手动将内核或系统服务替换为另一个版本的手动补丁除外。 <版本号> IO Driverpool KEY 该键中的所有子键都显示在可用组件的列表框中 PLC 配置 对话。 StackSizePerTask DWORD 需要时每个任务的堆栈大小（复杂函数调用的无法解释的崩溃）。 0x6000 (24 KB) CreateBluescreenOnFirstException DWORD 发生的第一个异常应该会生成蓝屏死机（因此会生成用于诊断目的的核心转储。 内核内存 应在 Windows 系统设置中选择 启动和恢复 . 0 有关更多信息，请参阅： 在特殊平台上配置实时行为 " }, 
{ "title" : "性能优化 ", 
"url" : "_rtsl_performance_realtime_windows.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ 性能优化 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "“软实时”行为 CODESYS Control Win ", 
"url" : "_rtsl_performance_realtime_windows.html#UUID-260b1b52-f206-9ca7-1cd0-920e224c4997_section-idm43415804467536", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 配置和扩展 \/ 性能优化 \/ “软实时”行为 CODESYS Control Win ", 
"snippet" : "这 CODESYS Control Win 在Windows上作为“实时”进程运行，但这并不等同于PLC的硬实时要求。延迟和抖动时间在几毫秒的范围内。特殊情况下，也可能是几十毫秒。这种延迟取决于许多因素，例如 Windows 内核中的负载、网络负载、使用不利或过时的驱动程序以及计算机的性能。 这些延误使得 CODESYS Control Win 不适合典型的运动应用。 一般来说，必须根据实际应用程序的功能和限制来验证实际应用程序的要求。 CODESYS Control Win 在特定的 PC 上。由于边界条件众多，不可能对预期的最大抖动时间进行一般性说明。...", 
"body" : "这 CODESYS Control Win 在Windows上作为“实时”进程运行，但这并不等同于PLC的硬实时要求。延迟和抖动时间在几毫秒的范围内。特殊情况下，也可能是几十毫秒。这种延迟取决于许多因素，例如 Windows 内核中的负载、网络负载、使用不利或过时的驱动程序以及计算机的性能。 这些延误使得 CODESYS Control Win 不适合典型的运动应用。 一般来说，必须根据实际应用程序的功能和限制来验证实际应用程序的要求。 CODESYS Control Win 在特定的 PC 上。由于边界条件众多，不可能对预期的最大抖动时间进行一般性说明。 " }, 
{ "title" : "参考 ", 
"url" : "_rtsl_reference_windows.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "对话框 ", 
"url" : "_rtsl_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 对话框 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "对话框：选项 - 运行时部署工具 ", 
"url" : "_rtsl_dlg_options_runtime_deploy_tool.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 对话框 \/ 对话框：选项 - 运行时部署工具 ", 
"snippet" : "象征： 功能 ：该对话框允许访问开发系统的文件系统以管理 SSH 私钥。 称呼 ： 工具 → 选项 菜单， 运行时部署工具 类别 要求 ：只有至少一个对话框才可用 CODESYS SL 产品已安装。在 工具 → 包管理器 ，您可以看到安装了哪些产品。 SSH 密钥 钥匙 充当私钥的 OPENSSH 文件的名称 例子： serviceuser.openssh 注意：仅显示已检查正确性的密钥文件。 小路 SSH 密钥的位置 例子： D:\\PLCs\\Keys\\serviceuser.openssh 添加 打开文件管理对话框 您可以在此处选择带有私钥的密钥文件（OPENSSH 文件）。该文件链接到 运...", 
"body" : "象征： 功能 ：该对话框允许访问开发系统的文件系统以管理 SSH 私钥。 称呼 ： 工具 → 选项 菜单， 运行时部署工具 类别 要求 ：只有至少一个对话框才可用 CODESYS SL 产品已安装。在 工具 → 包管理器 ，您可以看到安装了哪些产品。 SSH 密钥 钥匙 充当私钥的 OPENSSH 文件的名称 例子： serviceuser.openssh 注意：仅显示已检查正确性的密钥文件。 小路 SSH 密钥的位置 例子： D:\\PLCs\\Keys\\serviceuser.openssh 添加 打开文件管理对话框 您可以在此处选择带有私钥的密钥文件（OPENSSH 文件）。该文件链接到 运行时部署工具 . 提示：将开发计算机上的私钥保存到合适的或秘密的位置。 注意：切勿共享私钥。 消除 删除指向所选密钥文件的链接 行 接受设置并关闭对话框 取消 关闭对话框 " }, 
{ "title" : "对话框：系统配置 - 诊断 ", 
"url" : "_rtsl_dlg_system_config_diagnosis.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 对话框 \/ 对话框：系统配置 - 诊断 ", 
"snippet" : "称呼 ： CODESYS Control RTE 状态栏中的菜单 这 系统配置 对话框打开第一个 诊断 标签。它包含有关来自控制器的各种状态和 ID 的信息。...", 
"body" : "称呼 ： CODESYS Control RTE 状态栏中的菜单 这 系统配置 对话框打开第一个 诊断 标签。它包含有关来自控制器的各种状态和 ID 的信息。 " }, 
{ "title" : "对话框：系统配置 - 目标 ", 
"url" : "_rtsl_dlg_system_config_target.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 对话框 \/ 对话框：系统配置 - 目标 ", 
"snippet" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 目标 标签 已安装的固定名称 CODESYS Control RTE 可以指定在 目标名称 .默认情况下，PLC 使用运行它的计算机的名称进行报告。...", 
"body" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 目标 标签 已安装的固定名称 CODESYS Control RTE 可以指定在 目标名称 .默认情况下，PLC 使用运行它的计算机的名称进行报告。 " }, 
{ "title" : "对话框：系统配置 - 文件 ", 
"url" : "_rtsl_dlg_system_config_file.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 对话框 \/ 对话框：系统配置 - 文件 ", 
"snippet" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 文件 标签 不同文件类型的默认位置 CODESYS Control RTE 可以在这里配置。 文件 相对文件路径 RTE 工作目录的相对路径（ C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 ）。 要存储在此文件路径中的文件（例如 *.app、*.crc） 应保存在文件路径中的文件类型。逗号分隔的列表（例如： *.app, *.crc )...", 
"body" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 文件 标签 不同文件类型的默认位置 CODESYS Control RTE 可以在这里配置。 文件 相对文件路径 RTE 工作目录的相对路径（ C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 ）。 要存储在此文件路径中的文件（例如 *.app、*.crc） 应保存在文件路径中的文件类型。逗号分隔的列表（例如： *.app, *.crc ) " }, 
{ "title" : "对话框：系统配置 - 调度程序 ", 
"url" : "_rtsl_dlg_system_config_scheduler.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 对话框 \/ 对话框：系统配置 - 调度程序 ", 
"snippet" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 调度器 标签 运行时系统的任务调度程序设置位于此处。它们会影响负载监控的执行方式以及超出限值时的行为。只有在特殊要求时才需要更改这些设置。 处理器负载 最大限度。处理器负载 系统负载限制 在此 CPU 负载中，要么引发异常，要么启动时间片。 更改此设置可能会导致控制器出现故障（异常）。 有关更多信息，请参阅： CODESYS Control V3 运行时系统文档...", 
"body" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 调度器 标签 运行时系统的任务调度程序设置位于此处。它们会影响负载监控的执行方式以及超出限值时的行为。只有在特殊要求时才需要更改这些设置。 处理器负载 最大限度。处理器负载 系统负载限制 在此 CPU 负载中，要么引发异常，要么启动时间片。 更改此设置可能会导致控制器出现故障（异常）。 有关更多信息，请参阅： CODESYS Control V3 运行时系统文档 " }, 
{ "title" : "对话框：系统配置 - 记录器 ", 
"url" : "_rtsl_dlg_system_config_logger.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 对话框 \/ 对话框：系统配置 - 记录器 ", 
"snippet" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 记录器 标签 设置位于此处，用于将来自 PLC 的日志消息保存在一个或多个文件中。 标准记录仪 使能够 ：下载时会隐式生成引导应用程序，但不会将项目下载到内存中。 后端文件 使能够 ： ：在工作目录中创建一个或多个带有日志消息的文件（ C:\\ProgramData\\CODESYS\\CODESYSControlRTE ）。如有必要，将覆盖最旧的文件。 最大限度。文件 ：最大文件数。 0 表示没有文件被覆盖并且所有日志条目都被归档。 最大限度。文件大小 ：文件的最大大小。 最大限度。条目 ：文件中的最大日志条目数。 有关更多信息...", 
"body" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 记录器 标签 设置位于此处，用于将来自 PLC 的日志消息保存在一个或多个文件中。 标准记录仪 使能够 ：下载时会隐式生成引导应用程序，但不会将项目下载到内存中。 后端文件 使能够 ： ：在工作目录中创建一个或多个带有日志消息的文件（ C:\\ProgramData\\CODESYS\\CODESYSControlRTE ）。如有必要，将覆盖最旧的文件。 最大限度。文件 ：最大文件数。 0 表示没有文件被覆盖并且所有日志条目都被归档。 最大限度。文件大小 ：文件的最大大小。 最大限度。条目 ：文件中的最大日志条目数。 有关更多信息，请参阅： 标签：日志 " }, 
{ "title" : "对话框：系统配置 - 应用程序 ", 
"url" : "_rtsl_dlg_system_config_application.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 对话框 \/ 对话框：系统配置 - 应用程序 ", 
"snippet" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 应用 标签 此处为 PLC 的应用程序组件进行设置。 引导应用程序 下载时创建 ：下载时会隐式生成引导应用程序。 仅在下载时存储 ：下载时会隐式生成引导应用程序，但不会将项目下载到内存中。 （仅适用于特殊应用） 保留不匹配行为 保留数据损坏时 PLC 行为的选项： 不要加载 ：未加载引导应用程序。 加载异常 ：启动应用程序已加载，但未启动。抛出异常。 加载和初始化保留 ：启动应用程序在下载后加载和初始化。 使引导应用程序无效 如果控制器未正确退出，则有关引导应用程序失效的选项： 绝不 ：启动应用程序永远不会失效。 通过设置 ...", 
"body" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 应用 标签 此处为 PLC 的应用程序组件进行设置。 引导应用程序 下载时创建 ：下载时会隐式生成引导应用程序。 仅在下载时存储 ：下载时会隐式生成引导应用程序，但不会将项目下载到内存中。 （仅适用于特殊应用） 保留不匹配行为 保留数据损坏时 PLC 行为的选项： 不要加载 ：未加载引导应用程序。 加载异常 ：启动应用程序已加载，但未启动。抛出异常。 加载和初始化保留 ：启动应用程序在下载后加载和初始化。 使引导应用程序无效 如果控制器未正确退出，则有关引导应用程序失效的选项： 绝不 ：启动应用程序永远不会失效。 通过设置 ：引导应用程序在 PLC 的配置文件中被声明为无效（ *.cfg ）。 通过重命名 ： 这 *.app 启动应用程序的文件被重命名，导致启动应用程序无效。 保留类型 保存保留文件的选项 CODESYS Control RTE ： 没有任何 ：数据不保存，PLC 不能使用任何保留数据。 SRAM ：PLC 可以使用物理的非易失性存储器来保留数据。 停电时 ：保留数据在控制器关闭时保存到文件中。为此，系统必须配备 UPS。然后电源故障也包括在内。 持久力 启用后，强制值在控制器重新启动后也会保留。 有关更多信息，请参阅： 创建引导应用程序 " }, 
{ "title" : "对话框：系统配置 - 组件管理器 ", 
"url" : "_rtsl_dlg_system_config_component_manager.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 对话框 \/ 对话框：系统配置 - 组件管理器 ", 
"snippet" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 组件管理器 标签 此处管理默认情况下不由 PLC 加载的其他组件。 有关更多信息，请参阅以下内容： 可用的动态组件组件管理器 PLC 配置路径 PLC 文件系统的根路径。例子： C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 附加组件 可在此处输入\/选择默认不被 PLC 下载的组件。...", 
"body" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 组件管理器 标签 此处管理默认情况下不由 PLC 加载的其他组件。 有关更多信息，请参阅以下内容： 可用的动态组件组件管理器 PLC 配置路径 PLC 文件系统的根路径。例子： C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 附加组件 可在此处输入\/选择默认不被 PLC 下载的组件。 " }, 
{ "title" : "对话框：系统配置 - 启动 ", 
"url" : "_rtsl_dlg_system_config_startup.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 对话框 \/ 对话框：系统配置 - 启动 ", 
"snippet" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 启动 标签 选择有关启动的选项之一 CODESYS Control RTE ： 启动 开机时启动RTE基础系统服务 系统服务（显示名称“ 3S RTE Service V3 \") 是在启动系统时自动启动的，这样在用户登录之前就可以使用该服务。 使用基本系统服务启动 PLC PLC 在系统服务启动时启动。与第一个选项一起，在 PC 启动后立即启动 PLC。 不加载引导应用程序 PLC 也不会为自动启动加载其引导应用程序。...", 
"body" : "称呼： CODESYS Control RTE 状态栏中的菜单，然后 启动 标签 选择有关启动的选项之一 CODESYS Control RTE ： 启动 开机时启动RTE基础系统服务 系统服务（显示名称“ 3S RTE Service V3 \") 是在启动系统时自动启动的，这样在用户登录之前就可以使用该服务。 使用基本系统服务启动 PLC PLC 在系统服务启动时启动。与第一个选项一起，在 PC 启动后立即启动 PLC。 不加载引导应用程序 PLC 也不会为自动启动加载其引导应用程序。 " }, 
{ "title" : "命令 ", 
"url" : "_rtsl_commands.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 命令 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "系统托盘中的菜单 ", 
"url" : "_rtsl_cmd_menu.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 命令 \/ 系统托盘中的菜单 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Control ", 
"url" : "_rtsl_cmd_menu.html#UUID-dc0920ec-91e3-5d46-7959-a04fb4357af3_section-idm4616768769337633167655660684", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 命令 \/ 系统托盘中的菜单 \/ CODESYS Control ", 
"snippet" : "访问用户界面 CODESYS Control Win 通过以下方式授予您 PC 系统托盘（“Systray”）中的符号。 右键单击 使用以下命令打开菜单的符号： 启动PLC ：开启 PLC。状态栏中的符号变为 . 注意：如果系统启动时要自动开启PLC，则需要在服务的属性中设置相应的启动选项。有关详细信息，请参阅帮助页面“安装和入门”。 停止PLC ：关闭 PLC。符号变为 . 退出 PLC 控制 ：结束系统托盘中用户菜单的可用性。符号被移除，但 PLC 继续运行。负责显示系统托盘的可执行文件是 CODESYSControlSysTray.exe .它位于子目录中的安装目录中 GatewayPL...", 
"body" : "访问用户界面 CODESYS Control Win 通过以下方式授予您 PC 系统托盘（“Systray”）中的符号。 右键单击 使用以下命令打开菜单的符号： 启动PLC ：开启 PLC。状态栏中的符号变为 . 注意：如果系统启动时要自动开启PLC，则需要在服务的属性中设置相应的启动选项。有关详细信息，请参阅帮助页面“安装和入门”。 停止PLC ：关闭 PLC。符号变为 . 退出 PLC 控制 ：结束系统托盘中用户菜单的可用性。符号被移除，但 PLC 继续运行。负责显示系统托盘的可执行文件是 CODESYSControlSysTray.exe .它位于子目录中的安装目录中 GatewayPLC 的 CODESYS Control Win . 关于 ：显示有关已安装的版本信息 CODESYS Control Win " }, 
{ "title" : "CODESYS Control RTE ", 
"url" : "_rtsl_cmd_menu.html#UUID-dc0920ec-91e3-5d46-7959-a04fb4357af3_section-idm4544772591294433167656742159", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 命令 \/ 系统托盘中的菜单 \/ CODESYS Control RTE ", 
"snippet" : "访问用户界面 CODESYS Control RTE 通过 PC 系统托盘（“Systray”）中的符号授予您。 右键单击 使用以下命令打开菜单的符号： 启动PLC ：开启 PLC。符号变为 . 停止PLC ：关闭 PLC。符号变为 . 退出 PLC 控制 ：控制的 CODESYS Control RTE 不再可能通过系统托盘。符号被移除，但 PLC 继续运行。 PLC配置 ：打开 系统配置 对话。不同的选项卡包括诊断信息和配置设置 CODESYS Control RTE . 远程PLC ：打开 远程配置 对话。通过启用或禁用 控制远程 PC，而不是本地 选项，您可以确定是否使用远程或本地 P...", 
"body" : "访问用户界面 CODESYS Control RTE 通过 PC 系统托盘（“Systray”）中的符号授予您。 右键单击 使用以下命令打开菜单的符号： 启动PLC ：开启 PLC。符号变为 . 停止PLC ：关闭 PLC。符号变为 . 退出 PLC 控制 ：控制的 CODESYS Control RTE 不再可能通过系统托盘。符号被移除，但 PLC 继续运行。 PLC配置 ：打开 系统配置 对话。不同的选项卡包括诊断信息和配置设置 CODESYS Control RTE . 远程PLC ：打开 远程配置 对话。通过启用或禁用 控制远程 PC，而不是本地 选项，您可以确定是否使用远程或本地 PC 上的 PLC。因此，菜单命令 启动PLC , 停止PLC ， 和 PLC配置 指的是本地 PC 或网络上到达的 PC。对于远程 PC，指定 目标电脑地址 , 端口号 , 和一个 暂停 连接的值（以毫秒为单位）（ 远程超时 [毫秒] ). 关于 ：显示有关已安装的版本信息 CODESYS Control RTE " }, 
{ "title" : "命令：更新 Edge Gateway ", 
"url" : "_rtsl_cmd_update_edge_gateway.html", 
"breadcrumbs" : "CODESYS Control \/ 基于 Windows 的运行时系统 \/ 参考 \/ 命令 \/ 命令：更新 Edge Gateway ", 
"snippet" : "功能 ：该命令打开 边缘网关 看法。在视图中，您可以安装、启动和停止 Edge Gateway 包（DEB 文件）。此外，在系统和运行时级别提供功能，支持您进行调试和应用程序开发。 称呼 ： 工具 菜单 登录信息 用户名 Linux计算机的用户名和密码 密码 选择目标 IP地址 目标设备的 IP 地址或名称 例子： 192.168.99.39 扫描 打开 扫描边缘网关 对话 当前连接在网络中并与设备类型相对应的所有设备都在此处列出，并带有 IP 地址和各自的 MAC 地址（在括号中）。设备类型由 MAC 地址标识。 例子： 192.168.123.123(BB:27:EB:FA:98:52) ...", 
"body" : "功能 ：该命令打开 边缘网关 看法。在视图中，您可以安装、启动和停止 Edge Gateway 包（DEB 文件）。此外，在系统和运行时级别提供功能，支持您进行调试和应用程序开发。 称呼 ： 工具 菜单 登录信息 用户名 Linux计算机的用户名和密码 密码 选择目标 IP地址 目标设备的 IP 地址或名称 例子： 192.168.99.39 扫描 打开 扫描边缘网关 对话 当前连接在网络中并与设备类型相对应的所有设备都在此处列出，并带有 IP 地址和各自的 MAC 地址（在括号中）。设备类型由 MAC 地址标识。 例子： 192.168.123.123(BB:27:EB:FA:98:52) CODESYS Edge Gateway for Linux 包裹 版本 要安装的 Edge Gateway 的版本和架构 例子： V3.5.15.0 (amd64) 安装 在设置的版本和体系结构中启动 Edge Gateway 软件包的安装操作。 消除 删除当前在 Linux 设备 然后你可以安装任何版本。 包目录 Edge Gateway 打包的文件夹（ *.deb ） 位于。 附加包 安装 在 PLC 上安装额外的 Linux 软件包或更新现有的软件包 示例：Wibu CodeMeter 运行时包。您可以从 Wibu Systems 主页下载该软件包并使用此命令在 PLC 上安装或更新它。 管理 打开一个对话框，显示所有已安装的包和附加信息 您可以在此对话框中卸载单个软件包。 系统 系统信息 打开 系统信息<用户名>@IP地址 对话 例子： 系统信息root@192.168.123.123 重启目标 在 PLC 上重新启动系统 Edge Gateway 开始 启动 Edge Gateway 停止 停止 Edge Gateway " }
]
$(document).trigger('search.ready');
});