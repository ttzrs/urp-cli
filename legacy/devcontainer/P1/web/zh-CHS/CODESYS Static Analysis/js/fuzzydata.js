$(document).ready(function () {indexDict['zh-CHS'] = [{ "title" : "CODESYS Static Analysis ", 
"url" : "_san_start_page.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis ", 
"snippet" : "和 CODESYS Static Analysis ，可以使用定义的规则、命名约定或度量来执行 IEC 源代码的检查。因此，可能的开发问题的迹象会突出显示，并且可以在现场测试之前识别和纠正错误。这可以在应用程序开发和错误检查期间节省大量时间。 在 CODESYS Static Analysis ，已经实现了 100 多个规则（其中一些可以参数化）。可以组合这些规则来创建自定义规则集。在某些规则中，包括“PLCopen编码指南”中定义的规则集。您还可以为每种可能的数据类型定义命名约定，然后检查其合规性。此外，还有 20 多个可用指标，如果定期计算，可以分析底层源代码并提供负面趋势和偏离质量目标的...", 
"body" : "和 CODESYS Static Analysis ，可以使用定义的规则、命名约定或度量来执行 IEC 源代码的检查。因此，可能的开发问题的迹象会突出显示，并且可以在现场测试之前识别和纠正错误。这可以在应用程序开发和错误检查期间节省大量时间。 在 CODESYS Static Analysis ，已经实现了 100 多个规则（其中一些可以参数化）。可以组合这些规则来创建自定义规则集。在某些规则中，包括“PLCopen编码指南”中定义的规则集。您还可以为每种可能的数据类型定义命名约定，然后检查其合规性。此外，还有 20 多个可用指标，如果定期计算，可以分析底层源代码并提供负面趋势和偏离质量目标的指示。 您可以下载 CODESYS Static Analysis 从 CODESYS 国际商店 或者 CODESYS 北美商店 。您还可以在那里找到该产品的数据表。该产品须获得许可。 网络研讨会 CODESYS Static Analysis 如果 CODESYS Static Analysis 安装但未激活许可证，然后是一个具有以下功能的简化界面 Static Analysis Light 被展示。 作为替代方案 CODESYS Static Analysis , CODESYS Development System 提供了 Static Analysis Light 添加在。该附加组件自动成为 CODESYS 什么时候 不 CODESYS Static Analysis 已安装。 " }, 
{ "title" : "Static Analysis Light ", 
"url" : "_san_start_page.html#UUID-cc139654-e7d3-fe83-903e-e33f8fd0a5ec_section-idm452529692233763389020840932", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis \/ Static Analysis Light ", 
"snippet" : "Static Analysis Light 功能集非常有限，仅提供 7 项编译检查。该产品是免费提供的。您可以在中单独启用编译检查 项目 → 项目设置 菜单中，在 静态分析灯 类别。 欲了解更多信息，请参阅： 项目设置：静态分析光...", 
"body" : "Static Analysis Light 功能集非常有限，仅提供 7 项编译检查。该产品是免费提供的。您可以在中单独启用编译检查 项目 → 项目设置 菜单中，在 静态分析灯 类别。 欲了解更多信息，请参阅： 项目设置：静态分析光 " }, 
{ "title" : "概述 ", 
"url" : "_san_overview.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 概述 ", 
"snippet" : "仅对当前项目中的应用程序代码进行静态分析。不分析库及其源代码。 CODESYS Static Analysis 在实施过程中帮助您编写更好、更易读的代码，并识别冲突或不受支持的程序部分。特别是，揭示了潜在的错误来源。例如，识别仍包含测试代码的位置。或者发现在取消引用之前未检查 0 的指针。或者（与 SA0119 规则）分析使用面向对象的位置并移植到另一个不支持面向对象的开发环境，从而使其不可能。这样就可以保证代码的可移植性。 对于静态分析根据预编译信息报告的错误，支持立即错误处理（“Quickfix”）。这使您可以快速查找并修复分析期间报告的代码中的位置。 为了提高源代码的可读性，您可以定义命...", 
"body" : "仅对当前项目中的应用程序代码进行静态分析。不分析库及其源代码。 CODESYS Static Analysis 在实施过程中帮助您编写更好、更易读的代码，并识别冲突或不受支持的程序部分。特别是，揭示了潜在的错误来源。例如，识别仍包含测试代码的位置。或者发现在取消引用之前未检查 0 的指针。或者（与 SA0119 规则）分析使用面向对象的位置并移植到另一个不支持面向对象的开发环境，从而使其不可能。这样就可以保证代码的可移植性。 对于静态分析根据预编译信息报告的错误，支持立即错误处理（“Quickfix”）。这使您可以快速查找并修复分析期间报告的代码中的位置。 为了提高源代码的可读性，您可以定义命名约定并检查合规性。 此外，为了评估代码的质量，您可以查看从源代码确定的指标。示例包括作为代码可测试性度量的 McCabe 度量，或作为源代码可读性和可维护性度量的认知复杂性。静态分析中执行的数据流分析基于恒定传播原理。 随着 创建 → 执行静态分析 菜单命令，您显式激活静态分析。 在里面 设置 对话框中，您可以启用每次代码编译后自动执行的静态分析。 你用 编译指示语句 从分析中排除单个部分或代码块。 在里面 规则 对话框中，您可以了解配置了哪些规则、如何激活它们以及何时对相应规则运行检查。您可以在那里激活与您相关的规则。 在里面 静态分析设置 对话框中，您可以按照声明中的预期为每个数据类型分配一个前缀。报告偏差。 在里面 静态分析设置：指标 对话框中，您激活与您相关的指标。 随着 显示当前编辑者的认知复杂性 命令后，确定的增量将在活动编辑器中逐行显示。 这 显示当前编辑器的恒定传播值 命令详细分析活动编辑器中的数据流并按路径显示它。在此基础上，代码改进是可能的。 有关更多信息，请参阅： 规则, 指标， 和 编译指示和属性" }, 
{ "title" : "配置和运行静态分析 ", 
"url" : "_san_configuring_and_running.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 配置和运行静态分析 ", 
"snippet" : "使用下面的基本示例项目，您将找到配置和运行静态分析的最重要的步骤和选项。 要求： CODESYS Static Analysis 已安装。...", 
"body" : "使用下面的基本示例项目，您将找到配置和运行静态分析的最重要的步骤和选项。 要求： CODESYS Static Analysis 已安装。 " }, 
{ "title" : "示例项目 ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-5b7b70fe166a598dc0a864631da88a82", 
"breadcrumbs" : "CODESYS Static Analysis \/ 配置和运行静态分析 \/ 示例项目 ", 
"snippet" : "如果要重现示例项目，请创建一个标准项目并将 POU 插入设备树中的应用程序下方。然后配置连接到本地的通信设置 CODESYS Control Win 。 FUNCTION_BLOCK fb1 VAR_INPUT iVar_fb1in1 : INT; ivar_fb1in2 : INT; rVar_fb1in3 : REAL; END_VAR VAR_OUTPUT iVar_fb1out:INT; END_VAR VAR P_fSampleProperty : INT; rVar : REAL; PRO : BOOL; END_VAR iVar_fb1out:=iVar_fb1in1 + 1; ...", 
"body" : "如果要重现示例项目，请创建一个标准项目并将 POU 插入设备树中的应用程序下方。然后配置连接到本地的通信设置 CODESYS Control Win 。 FUNCTION_BLOCK fb1\nVAR_INPUT\n iVar_fb1in1 : INT;\n ivar_fb1in2 : INT;\n rVar_fb1in3 : REAL;\nEND_VAR\nVAR_OUTPUT\n iVar_fb1out:INT;\nEND_VAR\nVAR\n P_fSampleProperty : INT;\n rVar : REAL;\n PRO : BOOL;\nEND_VAR\n iVar_fb1out:=iVar_fb1in1 + 1; FUNCTION_BLOCK fb2\nVAR_INPUT\n iVar_fb2in:INT;\nEND_VAR\nVAR_OUTPUT\n iVar_fb2out:INT;\nEND_VAR\nVAR\nEND_VAR\n iVar_fb2out:=iVar_fb2in - 1; PROGRAM PLC_PRG\nVAR\n fb1_inst: fb1;\n fb2_inst: fb2;\nEND_VAR fb1_inst(iVar_fb1in1 := 99);\nfb2_inst(iVar_fb2in := 22);\nfb2_inst(iVar_fb2in := 1); " }, 
{ "title" : "检查是否遵守规则 ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9641312f166a598dc0a864630126d291", 
"breadcrumbs" : "CODESYS Static Analysis \/ 配置和运行静态分析 \/ 检查是否遵守规则 ", 
"snippet" : "点击 构建→静态分析→设置 .切换到 规则 标签 . 将显示一个列表，其中包含所有可能的规则检查。它们按主题类别以树形结构组织。 “规则编号”添加在括号中（例如： 未使用的变量 (33) 在类别中 未使用的对象 ）。 单击第一行的复选框几次（ 规则 节点）。 单击切换激活状态。整个树中的复选框带有红色或橙色复选标记，或者根本没有复选标记。 这样，激活所有带有红色复选标记的条目。这意味着 CODESYS Static Analysis 应将检测到的任何违反规则的行为报告为错误。 点击 构建 → 静态分析 → 运行静态分析 。 在消息视图中报告错误。消息文本标有 并以错误号“SA<rule num...", 
"body" : "点击 构建→静态分析→设置 .切换到 规则 标签 . 将显示一个列表，其中包含所有可能的规则检查。它们按主题类别以树形结构组织。 “规则编号”添加在括号中（例如： 未使用的变量 (33) 在类别中 未使用的对象 ）。 单击第一行的复选框几次（ 规则 节点）。 单击切换激活状态。整个树中的复选框带有红色或橙色复选标记，或者根本没有复选标记。 这样，激活所有带有红色复选标记的条目。这意味着 CODESYS Static Analysis 应将检测到的任何违反规则的行为报告为错误。 点击 构建 → 静态分析 → 运行静态分析 。 在消息视图中报告错误。消息文本标有 并以错误号“SA<rule number>”开头。 双击该消息 SA0033：未使用的变量“iVar_fb2out” 。 焦点移至功能块声明部分 fb2 并选择相关变量。该变量已声明，但未使用。这在规则 33 中进行了检查（ 未使用的变量 ）。代码中，相关位置用波浪线下划线表示。 要测试分析的自动执行，请单击 构建 → 静态分析 → 设置 .在 设置 选项卡，选择 编译后自动进行静态分析 选项。点击 好的 退出对话框。 点击 在线→登录 。 对话框提示存在编译错误。代码分析报告的错误再次显示在消息视图中。 点击 构建 → 静态分析 → 设置 。切换到 规则 标签。现在清除对话框中的所有规则。在里面 未使用的对象 类别，显式激活规则 SA0035 ( 未使用的输入变量 (35) ）带有橙色复选标记以报告“警告”。请参阅规则文本的工具提示： 该规则对应于以下 PLCopen 规则： CP24 ）。点击 好的 退出对话框。 点击 构建 → 生成代码 。 分析是自动执行的。在消息视图中，报告了两个错误 静态分析消息 类别： § SA0035：未使用的输入“iVar_fb1in2” § SA0035：未使用的输入“iVar_fb1in3” 双击消息并注释或删除声明。再次进行代码分析。 不显示错误消息。 " }, 
{ "title" : "检查是否符合定义的命名约定 ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-d64b88b5166a598dc0a864632e22b38d", 
"breadcrumbs" : "CODESYS Static Analysis \/ 配置和运行静态分析 \/ 检查是否符合定义的命名约定 ", 
"snippet" : "点击 构建 → 静态分析 → 设置 。切换到 命名约定 标签。 您会看到一个树形结构的表，该表分为可扩展的变量类别和程序块。 展开 变量的前缀 – 类型前缀 类别，并且在 字首 列，指定 I 为了 智力 (14) 。 展开 POU 的前缀 – POU 类型的前缀 类别。在里面 字首 列，指定 prog 为了 计划 (122) 和 fb 为了 功能块 (103) 。 选择 前缀后的第一个字符应该是大写字母 选项。清除所有其他选项。 点击 构建 → 静态分析 → 运行静态分析 。 错误信息： NC0102：名称“PLC_PRG”无效：需要前缀“prog” 因为 PLC_PRG 没有所需的前缀 前缀...", 
"body" : "点击 构建 → 静态分析 → 设置 。切换到 命名约定 标签。 您会看到一个树形结构的表，该表分为可扩展的变量类别和程序块。 展开 变量的前缀 – 类型前缀 类别，并且在 字首 列，指定 I 为了 智力 (14) 。 展开 POU 的前缀 – POU 类型的前缀 类别。在里面 字首 列，指定 prog 为了 计划 (122) 和 fb 为了 功能块 (103) 。 选择 前缀后的第一个字符应该是大写字母 选项。清除所有其他选项。 点击 构建 → 静态分析 → 运行静态分析 。 错误信息： NC0102：名称“PLC_PRG”无效：需要前缀“prog” 因为 PLC_PRG 没有所需的前缀 前缀后的第一个字符应为大写：'ivar_fb1in2' 因为 ivar_fb1in2 : INT; 是在 fb1 。 NC0014：无效的变量名称 P_fSampleProperty：需要前缀“i” 因为这个整型变量没有所需的前缀。 " }, 
{ "title" : "检查禁用符号 ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-7e83abe1166a598dc0a86463714e1dc5", 
"breadcrumbs" : "CODESYS Static Analysis \/ 配置和运行静态分析 \/ 检查禁用符号 ", 
"snippet" : "点击 构建→静态分析→设置 .切换到 禁止符号 标签 . 行编辑器允许指定不应在代码中使用的字符串。 例如，双击空白行并输入无效字符串 PRO 直接地。双击下一个空白行，然后单击 按钮打开输入助手。从 标准类型 ， 选择 真实的 .点击 行 退出对话框。 点击 构建 → 静态分析 → 运行静态分析 。 错误消息 Forbidden symbol 'REAL' 和 Forbidden symbol 'PRO' 显示在消息视图中。双击消息文本可跳转到相关代码行。...", 
"body" : "点击 构建→静态分析→设置 .切换到 禁止符号 标签 . 行编辑器允许指定不应在代码中使用的字符串。 例如，双击空白行并输入无效字符串 PRO 直接地。双击下一个空白行，然后单击 按钮打开输入助手。从 标准类型 ， 选择 真实的 .点击 行 退出对话框。 点击 构建 → 静态分析 → 运行静态分析 。 错误消息 Forbidden symbol 'REAL' 和 Forbidden symbol 'PRO' 显示在消息视图中。双击消息文本可跳转到相关代码行。 " }, 
{ "title" : "显示指标 ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ 配置和运行静态分析 \/ 显示指标 ", 
"snippet" : "CODESYS Static Analysis 对代码执行选定的测试，您可以在视图中显示结果。 点击 构建→静态分析→设置 .切换到 指标 标签 . 这些指标 CODESYS Static Analysis 适用于代码列于表中。 对于本例，激活 输入变量的数量 metric 并指定允许的值范围：下限 1 和上限 2 。 例如，激活更多指标 代码大小 和 通话次数 。 点击 构建 → 静态分析 → 查看标准指标 。 该视图包括一个表格，其中每个表格都有一行 节目单位 的示例程序。对于每个激活的指标，有一列显示测量值。超出设置中定义的值范围的值会以红色突出显示。就本具体示例而言，这至少是 PLC_...", 
"body" : "CODESYS Static Analysis 对代码执行选定的测试，您可以在视图中显示结果。 点击 构建→静态分析→设置 .切换到 指标 标签 . 这些指标 CODESYS Static Analysis 适用于代码列于表中。 对于本例，激活 输入变量的数量 metric 并指定允许的值范围：下限 1 和上限 2 。 例如，激活更多指标 代码大小 和 通话次数 。 点击 构建 → 静态分析 → 查看标准指标 。 该视图包括一个表格，其中每个表格都有一行 节目单位 的示例程序。对于每个激活的指标，有一列显示测量值。超出设置中定义的值范围的值会以红色突出显示。就本具体示例而言，这至少是 PLC_PRG\/输入 字段，因为该 POU 中的输入变量数量大于定义的上限 2 。 " }, 
{ "title" : "ST 代码中违反规则的快速修复 ", 
"url" : "_san_fix_errors_quickly.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ ST 代码中违反规则的快速修复 ", 
"snippet" : "在里面 静态分析设置 对话框，在 规则 选项卡，您可以启用 ST 代码的规则。根据预编译信息检查这些规则的合规性。不需要显式调用静态分析来检测任何此类违反规则的行为。在预编译期间和成功编译之后，在活动的 ST 编辑器中检查是否符合规则。当发生违反规则时，它会立即在 ST 编辑器中以波浪下划线显示。此外，在消息视图中，错误消息或警告列在 预编译 看法。 有关说明，请参阅： 检查是否符合定义的命名约定您可以在 ST 编辑器中找到 Quickfix，方法是单击带有波浪下划线的代码，然后单击灯泡符号 ，或在消息视图中通过 错误消息行中的按钮。在每种情况下，都会向您提供用于处理规则违规的相应命令。 对于...", 
"body" : "在里面 静态分析设置 对话框，在 规则 选项卡，您可以启用 ST 代码的规则。根据预编译信息检查这些规则的合规性。不需要显式调用静态分析来检测任何此类违反规则的行为。在预编译期间和成功编译之后，在活动的 ST 编辑器中检查是否符合规则。当发生违反规则时，它会立即在 ST 编辑器中以波浪下划线显示。此外，在消息视图中，错误消息或警告列在 预编译 看法。 有关说明，请参阅： 检查是否符合定义的命名约定您可以在 ST 编辑器中找到 Quickfix，方法是单击带有波浪下划线的代码，然后单击灯泡符号 ，或在消息视图中通过 错误消息行中的按钮。在每种情况下，都会向您提供用于处理规则违规的相应命令。 对于 Quickfix，提供了以下命令，每个命令都取决于错误： 忽略错误\/警告 该命令用于自动将 pragma 或属性插入代码中，这不包括对这行代码的相应规则的检查。 全局忽略 <programming object name> 的错误\/警告 该命令用于在编程对象的声明部分的开头自动插入一个属性。然后排除对该编程对象的相应规则的检查。 带有有关如何更改 ST 代码以避免违反规则的建议的命令 (Quickfix)。例子： SA0168: 删除分配 'enum1 := 5' 关闭检查 该命令用于关闭设置中对应规则的检查。 您可以撤消调用任何命令的效果。为此，首先单击 设备 查看（或 POU 看法）。然后 撤消 命令已启用。 " }, 
{ "title" : "启用规则 ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-1cca77b1336bf579c0a8646302e5e6f3", 
"breadcrumbs" : "CODESYS Static Analysis \/ ST 代码中违反规则的快速修复 \/ 启用规则 ", 
"snippet" : "点击 构建→静态分析→设置 .切换到 规则 标签。 将显示一个列表，其中包含所有可能的规则检查。它们按主题类别以树状结构组织。 “规则编号”添加在括号中。您可以过滤规则、按选项对其进行排序或在列表中显示它们。 点击 结构化展示 筛选 （ 符号），然后选择 按执行时刻构建 选项。 下面列出了预编译期间也可以检查的规则 在预编译期间和编译成功后执行 节点。这些是由复选标记标识的规则 预编译 柱子。在左侧的列中，您现在可以启用检查规则。 单击规则 (168) 行中的复选框，使状态从“红色复选标记”变为“黄色复选标记”到“无复选标记”。 红色复选标记表示规则违规作为错误消息发出。黄色复选标记表示将违反...", 
"body" : "点击 构建→静态分析→设置 .切换到 规则 标签。 将显示一个列表，其中包含所有可能的规则检查。它们按主题类别以树状结构组织。 “规则编号”添加在括号中。您可以过滤规则、按选项对其进行排序或在列表中显示它们。 点击 结构化展示 筛选 （ 符号），然后选择 按执行时刻构建 选项。 下面列出了预编译期间也可以检查的规则 在预编译期间和编译成功后执行 节点。这些是由复选标记标识的规则 预编译 柱子。在左侧的列中，您现在可以启用检查规则。 单击规则 (168) 行中的复选框，使状态从“红色复选标记”变为“黄色复选标记”到“无复选标记”。 红色复选标记表示规则违规作为错误消息发出。黄色复选标记表示将违反规则作为警告发出。没有复选标记表示该规则未被选中。 现在检查启用的规则。在违规的情况下，它们会在代码中标记并显示在消息视图中。 " }, 
{ "title" : "在消息视图中显示规则违规 ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8f3e8ec3336bf579c0a86463654e2139", 
"breadcrumbs" : "CODESYS Static Analysis \/ ST 代码中违反规则的快速修复 \/ 在消息视图中显示规则违规 ", 
"snippet" : "点击 查看 → 消息 . 消息视图打开。 在消息视图的列表框中，选择 预编译 类别。 在此类别中，仅显示规则违规，这些违规是在预编译期间和成功编译后检测到的，并且可以使用 Quickfix 解决。这 按钮提供了相应的命令。...", 
"body" : "点击 查看 → 消息 . 消息视图打开。 在消息视图的列表框中，选择 预编译 类别。 在此类别中，仅显示规则违规，这些违规是在预编译期间和成功编译后检测到的，并且可以使用 Quickfix 解决。这 按钮提供了相应的命令。 " }, 
{ "title" : "执行快速修复 ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8a9adfb3336bf579c0a8646308d0b385", 
"breadcrumbs" : "CODESYS Static Analysis \/ ST 代码中违反规则的快速修复 \/ 执行快速修复 ", 
"snippet" : "在设置中，启用了规则 168，并且在 ST 编辑器中显示了违反规则的情况。 要求：ST 代码中至少一行有波浪下划线，并且相应的 SA 编号显示在消息视图中。 单击带有波浪下划线的代码行。 这 符号显示。 单击灯泡符号。 将打开一个窗口，其中包含用于错误处理的菜单命令。 您想修复错误。因此，您单击命令 赋值 'enum1 := GVL.CONST' . 现在代码行会自动更改，如命令中所示。错误已修复。 第三个命令包含有关如何通过更改代码来修复错误的建议，具体取决于违反规则的情况。 通过单击 消息视图的错误消息行中的按钮。...", 
"body" : "在设置中，启用了规则 168，并且在 ST 编辑器中显示了违反规则的情况。 要求：ST 代码中至少一行有波浪下划线，并且相应的 SA 编号显示在消息视图中。 单击带有波浪下划线的代码行。 这 符号显示。 单击灯泡符号。 将打开一个窗口，其中包含用于错误处理的菜单命令。 您想修复错误。因此，您单击命令 赋值 'enum1 := GVL.CONST' . 现在代码行会自动更改，如命令中所示。错误已修复。 第三个命令包含有关如何通过更改代码来修复错误的建议，具体取决于违反规则的情况。 通过单击 消息视图的错误消息行中的按钮。 " }, 
{ "title" : "对一行代码禁用规则检查 ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-107e44f0336bf579c0a8646347e7d5cc", 
"breadcrumbs" : "CODESYS Static Analysis \/ ST 代码中违反规则的快速修复 \/ 对一行代码禁用规则检查 ", 
"snippet" : "在设置中，启用了规则 168，并且在 ST 编辑器中显示了违反规则的情况。 要求：ST 代码中至少一行有波浪下划线，并且相应的 SA 编号显示在消息视图中。 单击带有波浪下划线的代码行。 这 符号显示。 单击灯泡符号。 将打开一个窗口，其中包含用于错误处理的菜单命令。 您不想修复错误。因此，您单击命令 忽略错误\/警告 . 现在，该行代码会自动提供编译指示。编译指示用于防止检查受影响规则的行。不会发出错误消息或警告。 对受影响的代码行禁用规则检查的命令也可以通过 消息视图中错误消息行中的按钮。...", 
"body" : "在设置中，启用了规则 168，并且在 ST 编辑器中显示了违反规则的情况。 要求：ST 代码中至少一行有波浪下划线，并且相应的 SA 编号显示在消息视图中。 单击带有波浪下划线的代码行。 这 符号显示。 单击灯泡符号。 将打开一个窗口，其中包含用于错误处理的菜单命令。 您不想修复错误。因此，您单击命令 忽略错误\/警告 . 现在，该行代码会自动提供编译指示。编译指示用于防止检查受影响规则的行。不会发出错误消息或警告。 对受影响的代码行禁用规则检查的命令也可以通过 消息视图中错误消息行中的按钮。 " }, 
{ "title" : "禁用一个编程对象的规则检查 ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-6dee377f336bf579c0a8646357b65fa8", 
"breadcrumbs" : "CODESYS Static Analysis \/ ST 代码中违反规则的快速修复 \/ 禁用一个编程对象的规则检查 ", 
"snippet" : "在设置中，启用了规则 168，并且在 ST 编辑器中显示了违反规则的情况。 要求：ST 代码中至少一行有波浪下划线，并且相应的 SA 编号显示在消息视图中。 单击带有波浪下划线的代码行。 这 符号显示。 单击灯泡符号。 将打开一个窗口，其中包含用于错误处理的菜单命令。 您不希望使用指定规则检查编程对象。因此，您单击第二个命令 全局忽略 PLC_PRG 的错误\/警告 . 对象的声明现在自动提供一个属性。该属性用于防止为对象检查受影响的规则。不发出错误消息或警告。 忽略消息的命令也可以通过 消息视图中错误消息行中的按钮。...", 
"body" : "在设置中，启用了规则 168，并且在 ST 编辑器中显示了违反规则的情况。 要求：ST 代码中至少一行有波浪下划线，并且相应的 SA 编号显示在消息视图中。 单击带有波浪下划线的代码行。 这 符号显示。 单击灯泡符号。 将打开一个窗口，其中包含用于错误处理的菜单命令。 您不希望使用指定规则检查编程对象。因此，您单击第二个命令 全局忽略 PLC_PRG 的错误\/警告 . 对象的声明现在自动提供一个属性。该属性用于防止为对象检查受影响的规则。不发出错误消息或警告。 忽略消息的命令也可以通过 消息视图中错误消息行中的按钮。 " }, 
{ "title" : "一般禁用规则检查 ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ ST 代码中违反规则的快速修复 \/ 一般禁用规则检查 ", 
"snippet" : "在设置中，启用了规则 168，并且在 ST 编辑器中显示了违反规则的情况。 要求：ST 代码中至少一行有波浪下划线，并且相应的 SA 编号显示在消息视图中。 单击带有波浪下划线的代码行。 这 符号显示。 单击灯泡符号。 将打开一个窗口，其中包含用于错误处理的菜单命令。 您不想再检查显示的规则。因此，您单击第四个命令 关闭检查 . 该规则在静态分析设置中被禁用。 点击 构建→静态分析→设置 .切换到 规则 标签。 规则 168 已禁用。 全局禁用检查的命令也可以通过 消息视图中错误消息行中的按钮。...", 
"body" : "在设置中，启用了规则 168，并且在 ST 编辑器中显示了违反规则的情况。 要求：ST 代码中至少一行有波浪下划线，并且相应的 SA 编号显示在消息视图中。 单击带有波浪下划线的代码行。 这 符号显示。 单击灯泡符号。 将打开一个窗口，其中包含用于错误处理的菜单命令。 您不想再检查显示的规则。因此，您单击第四个命令 关闭检查 . 该规则在静态分析设置中被禁用。 点击 构建→静态分析→设置 .切换到 规则 标签。 规则 168 已禁用。 全局禁用检查的命令也可以通过 消息视图中错误消息行中的按钮。 " }, 
{ "title" : "定义命名约定 ", 
"url" : "_san_define_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定义命名约定 ", 
"snippet" : "在里面 静态分析设置 对话框，在 命名约定 选项卡，定义您将在代码中遵循的命名约定。您可以根据其范围和限定符为 POU、变量和数据类型的标识符定义前缀。 然后，您可以让静态分析检查命名约定的合规性。 有关说明，请参阅： 检查是否符合定义的命名约定...", 
"body" : "在里面 静态分析设置 对话框，在 命名约定 选项卡，定义您将在代码中遵循的命名约定。您可以根据其范围和限定符为 POU、变量和数据类型的标识符定义前缀。 然后，您可以让静态分析检查命名约定的合规性。 有关说明，请参阅： 检查是否符合定义的命名约定" }, 
{ "title" : "定义前缀 ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-291ced2808fb693bc0a8646323d0819d", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定义命名约定 \/ 定义前缀 ", 
"snippet" : "在里面 静态分析设置 对话框，在 命名约定 选项卡，在输入字段中定义命名约定 字首 柱子。 字符字面量 例子： PRG_ 在 POU 的前缀 , POU 类型的前缀 , 程序 (102) 每个条目有多个文字，用逗号分隔 句法： <prefix> ( , <next prefix> )* 例子： PRG_, PRG 在 POU 的前缀 , POU 类型的前缀 , 程序 (102) 正则表达式 正则表达式 它定义了一组前缀 句法： @ <expression> 例子： @x[a-dA-D] 定义一个以 x , 紧接着是集合中的一个字符 a-dA-D @[A-Za-z][A-Za-z][A-Za-z...", 
"body" : "在里面 静态分析设置 对话框，在 命名约定 选项卡，在输入字段中定义命名约定 字首 柱子。 字符字面量 例子： PRG_ 在 POU 的前缀 , POU 类型的前缀 , 程序 (102) 每个条目有多个文字，用逗号分隔 句法： <prefix> ( , <next prefix> )* 例子： PRG_, PRG 在 POU 的前缀 , POU 类型的前缀 , 程序 (102) 正则表达式 正则表达式 它定义了一组前缀 句法： @ <expression> 例子： @x[a-dA-D] 定义一个以 x , 紧接着是集合中的一个字符 a-dA-D @[A-Za-z][A-Za-z][A-Za-z][A-Za-z0-9] 定义一个由四个字符组成的前缀：前三个字符是字母，第四个字符也可以是数字。 " }, 
{ "title" : "定义可组合数据类型的前缀 ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e9a24404c19ad708c0a86463215af896", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定义命名约定 \/ 定义可组合数据类型的前缀 ", 
"snippet" : "以下数据类型基于标准数据类型、现有数据类型或功能块： 指针： POINTER TO <basic type> 参考： REFERENCE TO <basic type> 大批： ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> 这些数据类型可以嵌套和相互组合。当。。。的时候 可组合数据类型的递归前缀 选项被选中时，静态分析期望此类可组合数据类型的变量递归组合前缀。前缀遵循声明并对应于为基本数据类型定义的命名约定。 例子 已设置以下命名约定： i 在 变量的前缀 , 情报 (26) p 在 变量的前缀 , 指针...", 
"body" : "以下数据类型基于标准数据类型、现有数据类型或功能块： 指针： POINTER TO <basic type> 参考： REFERENCE TO <basic type> 大批： ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> 这些数据类型可以嵌套和相互组合。当。。。的时候 可组合数据类型的递归前缀 选项被选中时，静态分析期望此类可组合数据类型的变量递归组合前缀。前缀遵循声明并对应于为基本数据类型定义的命名约定。 例子 已设置以下命名约定： i 在 变量的前缀 , 情报 (26) p 在 变量的前缀 , 指针 (26) ref 在 变量的前缀 , 参考 (27) struct 在 变量的前缀 , 结构 (32) 可组合数据类型的递归前缀 选项： 以下代码违反了命名约定并且难以阅读。 PROGRAM plc1\nVAR\n var1 : ARRAY[100..110] OF ARRAY[30..50] OF ARRAY[6..7] OF BOOL;\n var2 : ARRAY[1..3] OF INT;\n var3 : REFERENCE TO INT;\n iVar4 : INT;\n iVar5 : INT;\n var6 : ARRAY[1..3] OF INT := [11, 22, 33];\n var7 : POINTER TO ARRAY[1..3] OF INT;\n var8 : REFERENCE TO INT;\n var9 : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n var0 : ARRAY[0..3] OF S_POLYGONLINE; \/\/ S_POLYGONLINE is a already defined structure\nEND_VAR\n\niVar4 := iVar4 + 1;\nvar8 REF= iVar4;\nvar1[100][30][6] := TRUE;\nvar9.aiPoint1[1] := 99;\nvar7 := ADR(var6);\nvar6[2] := 44;\niVar5 := var7^[2];\nvar0[0] := var9; 静态分析报告以下违反命名约定的情况： NC0102：无效名称“plc1”：预期前缀“PRG_” NC0014：无效的变量名“var0”：预期的前缀“astruct” NC0014：无效的变量名“var1”：预期的前缀“aaax” NC0014：无效的变量名称“var2”：预期的前缀“ai” NC0014：无效的变量名“var3”：预期的前缀“refi” NC0014：无效的变量名“var6”：预期的前缀“ai” NC0014：无效的变量名“var7”：预期的前缀“pai” NC0014：无效的变量名“var8”：预期的前缀“refi” NC0014：无效的变量名“var9”：预期的前缀“结构” " }, 
{ "title" : "定义别名变量的前缀 ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9f66c39a945e11eab0a0b46479d263a5", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定义命名约定 \/ 定义别名变量的前缀 ", 
"snippet" : "您可以为数据类型的变量定义前缀 别名 作为占位符的文字 {datatype} .然后静态分析需要基本数据类型的前缀而不是占位符。 这 结合范围前缀和数据类型前缀 选项对前缀的使用没有影响 {datatype} . 例子 已设置以下命名约定： s 在 变量的前缀 , 类型的前缀 , 字符串（）19 A_{datatype} 在 变量的前缀 , 别名 (33) 代码 TYPE A_MESSAGE : STRING[50]; \/\/ base data type is STRING END_TYPE VAR A_sMessage_N1 : A_MESSAGE := 'Robot is running....", 
"body" : "您可以为数据类型的变量定义前缀 别名 作为占位符的文字 {datatype} .然后静态分析需要基本数据类型的前缀而不是占位符。 这 结合范围前缀和数据类型前缀 选项对前缀的使用没有影响 {datatype} . 例子 已设置以下命名约定： s 在 变量的前缀 , 类型的前缀 , 字符串（）19 A_{datatype} 在 变量的前缀 , 别名 (33) 代码 TYPE A_MESSAGE : STRING[50]; \/\/ base data type is STRING\nEND_TYPE\n\nVAR\n A_sMessage_N1 : A_MESSAGE := 'Robot is running.';\n A_s_Message_N2 : A_MESSAGE := 'Robot has been finished.';\n As_Message_N3 : A_MESSAGE := 'Robot has been stopped.';\n AsMessage_N4 : A_MESSAGE := 'Error 3 has been occured.';\nEND_VAR 静态分析报告以下违反命名约定： NC0033：无效的变量名称“As_Message_N3”：预期的前缀“A_s” NC0033：无效的变量名称“AsMessage_N4”：预期的前缀“A_s” " }, 
{ "title" : "为属性定义前缀 ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e0cda739c19ad708c0a864636e955ca0", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定义命名约定 \/ 为属性定义前缀 ", 
"snippet" : "您可以为数据类型的 POU 定义前缀 PROPERTY 作为占位符的文字 {datatype} .然后静态分析需要属性的返回数据类型的前缀而不是占位符。 这 结合范围前缀和数据类型前缀 选项对占位符的使用没有影响 {datatype} . 例子 已设置以下命名约定： fb 在 变量的前缀 , 类型的前缀 , 功能块实例 FB_ 在 POU 的前缀 , POU 类型的前缀 , 功能块 (103) prop_{datatype} 在 POU 的前缀 , POU 类型的前缀 , 物业 (107) 代码 FUNCTION_BLOCK blocka \/\/ Invalid function block n...", 
"body" : "您可以为数据类型的 POU 定义前缀 PROPERTY 作为占位符的文字 {datatype} .然后静态分析需要属性的返回数据类型的前缀而不是占位符。 这 结合范围前缀和数据类型前缀 选项对占位符的使用没有影响 {datatype} . 例子 已设置以下命名约定： fb 在 变量的前缀 , 类型的前缀 , 功能块实例 FB_ 在 POU 的前缀 , POU 类型的前缀 , 功能块 (103) prop_{datatype} 在 POU 的前缀 , POU 类型的前缀 , 物业 (107) 代码 FUNCTION_BLOCK blocka \/\/ Invalid function block name\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC vara : INT \/\/ Invalid property name, return data type is INT\nGet\n vara := iA;\nSet\niA := vara;\n\nPROGRAM plc1\nVAR\n var10 : blocka; \/\/ Invalid variable name of typ function block\n iVar11: INT;\nEND_VAR\n\nvar10();\nIF var10.vara > 500 THEN\n var10.vara := 0;\nEND_IF\niVar11 := var10.vara; 静态分析报告以下违反命名约定： NC0102：无效名称“plc1”：预期前缀“PRG_” NC0031：无效的变量名“var10”：预期的前缀“fb” NC0103：无效的变量名“blocka”：预期的前缀“FB_” NC0107：无效的变量名“blocka.vara”：预期的前缀“prop_i” 根据命名约定编码 FUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC prop_iA : INT\nGet\n prop_iA := iA;\nSet\n iA := prop_iA;\n\nPROGRAM PRG_PLC1\nVAR\n fbA : FB_A;\n iVar11: INT;\nEND_VAR\n\nfbA();\nIF fbA.prop_iA > 500 THEN\n fbA.prop_iA := 0;\nEND_IF\niVar11 := fbA.prop_iA; " }, 
{ "title" : "定义结构的前缀 ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-ed64228609104c08c0a864630c58c86b", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定义命名约定 \/ 定义结构的前缀 ", 
"snippet" : "您可以在项目中为结构定义一个通用前缀 DUT 的前缀 , 结构 (151) .你也可以给一个结构一个特殊的前缀。然后，特殊前缀将覆盖一般前缀。 特殊前缀在结构的数据类型声明中用 pragma 定义 {attribute 'nameprefix' := <special prefix> '} .然后以这个前缀开始这个结构的所有变量 <special prefix> . 例子 已设置以下命名约定： struct 在 变量的前缀 , 结构 (32) S_ 在 DUT 的前缀 , 结构 (151) 可组合数据类型的递归前缀 ： 代码 TYPE S_POLYGONLINE : STRUCT aiStar...", 
"body" : "您可以在项目中为结构定义一个通用前缀 DUT 的前缀 , 结构 (151) .你也可以给一个结构一个特殊的前缀。然后，特殊前缀将覆盖一般前缀。 特殊前缀在结构的数据类型声明中用 pragma 定义 {attribute 'nameprefix' := <special prefix> '} .然后以这个前缀开始这个结构的所有变量 <special prefix> . 例子 已设置以下命名约定： struct 在 变量的前缀 , 结构 (32) S_ 在 DUT 的前缀 , 结构 (151) 可组合数据类型的递归前缀 ： 代码 TYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE\n\n{attribute 'nameprefix' := 'penta'} \/\/ Pragma to define a special prefix\nTYPE S_PENTA EXTENDS S_POLYGONLINE :\nSTRUCT\n aiPoint5 : ARRAY[1..2] OF INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PRG_Compute\nVAR\n structPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n structPentagon : S_PENTAGON := (aiStart:=[0,0], aiPoint1:=[1,1], aiPoint2:=[2,2], aiPoint3:=[3,3], aiPoint4:=[4,4], aiPoint5:=[5,5]);\n structLine0 : S_PENTA;\n pentaLine1 : S_PENTA;\n iXPoint: INT;\n aPoint0: ARRAY [1..2] OF INT;\n aPoint1: ARRAY [1..2] OF INT;\nEND_VAR\n\niXPoint := structPolygon.aiPoint1[1];\naPoint0 := structLine0.aiEnd;\naiPoint1 := pentaLine1.aiEnd; 静态分析报告以下违反命名约定： 无效的变量名“structLine0”：预期的前缀“penta” " }, 
{ "title" : "提供其他 CODESYS Static Analysis 具有命名约定的项目 ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定义命名约定 \/ 提供其他 CODESYS Static Analysis 具有命名约定的项目 ", 
"snippet" : "将命名约定保存在 CSA 文件中。您可以在其他地方加载和使用此文件 CODESYS Static Analysis 项目。 保存到文件 点击 构建→静态分析→设置 . 点击 保存 按钮。 文件选择对话框打开。在那里，您可以将命名约定存储在具有文件扩展名 CSA 的任何名称下的文件中。 使用命名约定加载文件 点击 构建→静态分析→设置 . 点击 加载 按钮。 文件选择对话框打开。选择下面显示的 CSA 文件之一。...", 
"body" : "将命名约定保存在 CSA 文件中。您可以在其他地方加载和使用此文件 CODESYS Static Analysis 项目。 保存到文件 点击 构建→静态分析→设置 . 点击 保存 按钮。 文件选择对话框打开。在那里，您可以将命名约定存储在具有文件扩展名 CSA 的任何名称下的文件中。 使用命名约定加载文件 点击 构建→静态分析→设置 . 点击 加载 按钮。 文件选择对话框打开。选择下面显示的 CSA 文件之一。 " }, 
{ "title" : "检测代码克隆 ", 
"url" : "_san_find_code_clone.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 检测代码克隆 ", 
"snippet" : "要求： CODESYS Static Analysis 已安装。 A CODESYS 项目已开放。该项目至少在两个编程对象中包含相同的代码块。 点击  构建 → 静态分析 → 检测克隆 。 这 克隆检测结果 视图打开。 点击 结果 . 检测到的代码克隆在窗口中显示为树形视图。 如果除了相同的代码克隆之外，还存在有偏差的代码克隆，则这些子节点在树视图中以颜色突出显示。 在树形视图中，选择一个子节点的两个代码克隆，然后单击 显示选定的克隆 按钮。 包含此重复代码的两个编程对象在编辑器中打开并显示在视图的上部。 相同的代码克隆以浅黄色突出显示，有偏差的代码克隆，例如变量名 ivar3 和 ivarx...", 
"body" : "要求： CODESYS Static Analysis 已安装。 A CODESYS 项目已开放。该项目至少在两个编程对象中包含相同的代码块。 点击  构建 → 静态分析 → 检测克隆 。 这 克隆检测结果 视图打开。 点击 结果 . 检测到的代码克隆在窗口中显示为树形视图。 如果除了相同的代码克隆之外，还存在有偏差的代码克隆，则这些子节点在树视图中以颜色突出显示。 在树形视图中，选择一个子节点的两个代码克隆，然后单击 显示选定的克隆 按钮。 包含此重复代码的两个编程对象在编辑器中打开并显示在视图的上部。 相同的代码克隆以浅黄色突出显示，有偏差的代码克隆，例如变量名 ivar3 和 ivarx 在本例中，以红色突出显示。 从编程对象的相同代码克隆创建函数 POU_1 ，首先在树形视图中双击代码克隆所在行 目的 POU_1 . 编程对象 POU_1 在编辑器中打开，并在实现部分突出显示包含重复代码的四行。 当您单击 提取功能 命令在突出显示的代码块的上下文菜单中，代码块是从 POU_1 并从中创建一个新方法。实现部分的代码块 POU_1 由方法的调用自动替换。 在第二个编程对象中，您必须手动删除代码重复并替换方法的调用。 在以后的版本中，将扩展该功能，以便从两个编程对象中自动提取重复的代码块，并且可以用正确的函数调用替换它。 " }, 
{ "title" : "不断传播 ", 
"url" : "_san_constant_propagation.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 不断传播 ", 
"snippet" : "随着 CODESYS Static Analysis 版本V5.0.0.0，代码的分析基于常量传播。恒定传播的结果用于各种检查。例如，它检查指针是否不等于 0，或者数组索引是否超出有效范围。 只需了解静态分析的工作原理及其局限性，您就可以有效地支持静态分析。...", 
"body" : "随着 CODESYS Static Analysis 版本V5.0.0.0，代码的分析基于常量传播。恒定传播的结果用于各种检查。例如，它检查指针是否不等于 0，或者数组索引是否超出有效范围。 只需了解静态分析的工作原理及其局限性，您就可以有效地支持静态分析。 " }, 
{ "title" : "不断传播 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078132035233833484992758", 
"breadcrumbs" : "CODESYS Static Analysis \/ 不断传播 \/ 不断传播 ", 
"snippet" : "静态分析尝试根据变量的用途来确定变量的值。 例子 PROGRAM PLC_PRG \/\/Declaration VAR x: INT; bTest: BOOL; END_VAR \/\/Implementation x := 99; IF x < 100 THEN bTest := TRUE; END_IF 在第 1 行的实现中，常量传播记录了值 99 对于变量 x 使用该值进行进一步分析。然后分析发现以下表达式 IF - 语句常量 TRUE 是。...", 
"body" : "静态分析尝试根据变量的用途来确定变量的值。 例子 PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT;\n bTest: BOOL;\nEND_VAR \/\/Implementation\nx := 99;\nIF x < 100 THEN\n bTest := TRUE;\nEND_IF 在第 1 行的实现中，常量传播记录了值 99 对于变量 x 使用该值进行进一步分析。然后分析发现以下表达式 IF - 语句常量 TRUE 是。 " }, 
{ "title" : "局部执行恒定传播 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4525765239721633833551650952", 
"breadcrumbs" : "CODESYS Static Analysis \/ 不断传播 \/ 不断传播 \/ 局部执行恒定传播 ", 
"snippet" : "仅在功能块中本地确定值。输入的传递方式无关紧要。函数调用的结果也是无关紧要的。 例子 FUNCTION Func : BOOL \/\/Declaration VAR_INPUT bText : BOOL; END_VAR \/\/Implementation IF bTest THEN Func := OtherFunc(TRUE); END_IF 即使参数 bTest 被设定为 TRUE 在每次调用时，这对恒定传播没有影响。即使 OtherFunc(TRUE) 总是返回 TRUE ，这对恒定传播没有影响。...", 
"body" : "仅在功能块中本地确定值。输入的传递方式无关紧要。函数调用的结果也是无关紧要的。 例子 FUNCTION Func : BOOL\n\/\/Declaration\nVAR_INPUT\n bText : BOOL;\nEND_VAR \/\/Implementation\nIF bTest THEN\n Func := OtherFunc(TRUE);\nEND_IF 即使参数 bTest 被设定为 TRUE 在每次调用时，这对恒定传播没有影响。即使 OtherFunc(TRUE) 总是返回 TRUE ，这对恒定传播没有影响。 " }, 
{ "title" : "只有临时变量才有初始值。 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505885763755233833526533567", 
"breadcrumbs" : "CODESYS Static Analysis \/ 不断传播 \/ 不断传播 \/ 只有临时变量才有初始值。 ", 
"snippet" : "程序和功能块中的静态局部变量没有假定的初始值。这些变量保留上次调用时的值，因此原则上可以是“任何值”。 函数中的局部变量和临时变量在每次调用时都有一个初始值。常数传播用这个初始值进行计算。 例子 PROGRAM PLC_PRG \/\/Declaration VAR x: INT := 6; bTest: BOOL; END_VAR VAR_TEMP y : INT := 8; END_VAR bText := x < y; 变量 y 每次都会被执行 PLC_PRG 值为 8。变量 x 但也不一定。因此，恒定传播仅用于 y 假设一个值，但不是为了 x 。 建议声明始终先写入然后读取的变量作为临时变...", 
"body" : "程序和功能块中的静态局部变量没有假定的初始值。这些变量保留上次调用时的值，因此原则上可以是“任何值”。 函数中的局部变量和临时变量在每次调用时都有一个初始值。常数传播用这个初始值进行计算。 例子 PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT := 6;\n bTest: BOOL;\nEND_VAR\nVAR_TEMP\n y : INT := 8;\nEND_VAR bText := x < y; 变量 y 每次都会被执行 PLC_PRG 值为 8。变量 x 但也不一定。因此，恒定传播仅用于 y 假设一个值，但不是为了 x 。 建议声明始终先写入然后读取的变量作为临时变量。 " }, 
{ "title" : "常数传播确定数值数据类型的值范围。 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078129465633833541363136", 
"breadcrumbs" : "CODESYS Static Analysis \/ 不断传播 \/ 不断传播 \/ 常数传播确定数值数据类型的值范围。 ", 
"snippet" : "为了降低复杂性，为每个变量确定了具有上限和下限的值范围。 例子 PROGRAM PLC_PRG VAR x: INT := 6; bTest: BOOL; y : INT; END_VAR \/\/Implementation IF bTest THEN x := 1; ELSSE x := 100; END_IF IF x = 77 THEN y := 13; END_IF 这里取值范围 [1..100] 是为变量确定的 x 。结果，在第 7 行，比较 x = 77 不被识别为常量表达式，因为 77 是在数值范围之内。...", 
"body" : "为了降低复杂性，为每个变量确定了具有上限和下限的值范围。 例子 PROGRAM PLC_PRG\nVAR\n x: INT := 6;\n bTest: BOOL;\n y : INT; \nEND_VAR\n \/\/Implementation\nIF bTest THEN\n x := 1;\nELSSE\n x := 100;\nEND_IF\nIF x = 77 THEN\n y := 13;\nEND_IF 这里取值范围 [1..100] 是为变量确定的 x 。结果，在第 7 行，比较 x = 77 不被识别为常量表达式，因为 77 是在数值范围之内。 " }, 
{ "title" : "重复出现的复杂表达式不会被识别为同一变量。 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4581954142281633833566535545", 
"breadcrumbs" : "CODESYS Static Analysis \/ 不断传播 \/ 不断传播 \/ 重复出现的复杂表达式不会被识别为同一变量。 ", 
"snippet" : "复杂表达式可能没有分配值。如果这样的表达式多次出现，那么引入辅助变量会很有帮助。 例子 PROGRAM PLC_PRG VAR x: DINT; py : POINTER TO INT; y : INT; testArray : ARRAY [0..4] OF DINT; END_VAR \/\/Implementation IF py^ >= 0 AND py^<= 4 THEN x := testArray[py^]; END_IF y := py^; IF y <= 0 AND y <=4 THEN x := testArray[y]; END_IF 在第 2 行，尽管检查了指针指向的区域，...", 
"body" : "复杂表达式可能没有分配值。如果这样的表达式多次出现，那么引入辅助变量会很有帮助。 例子 PROGRAM PLC_PRG\nVAR\n x: DINT;\n py : POINTER TO INT;\n y : INT; \n testArray : ARRAY [0..4] OF DINT; \nEND_VAR\n \/\/Implementation\nIF py^ >= 0 AND py^<= 4 THEN\n x := testArray[py^];\nEND_IF\ny := py^;\nIF y <= 0 AND y <=4 THEN\n x := testArray[y];\nEND_IF 在第 2 行，尽管检查了指针指向的区域，但由于可能通过指针访问某个值，因此会发出错误。如果首先将该值复制到局部变量中并检查其范围，则常量传播可以确定该变量的值范围，并允许访问第 7 行的数组。 " }, 
{ "title" : "分枝 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078204272033833577361725", 
"breadcrumbs" : "CODESYS Static Analysis \/ 不断传播 \/ 不断传播 \/ 分枝 ", 
"snippet" : "对于分支，单独计算各个分支。然后将各个范围中的值范围组合起来形成新的值范围。 例子 \/\/Implementation IF func(TRUE) THEN x := 1; ELSE x := 10; END_IF IF func(FALSE) THEN y := x; ELSE Y := 2*x; END_IF 6号线， x 有范围 [1..10] 。第 11 行之后， y 有取值范围 [1..20] ;这是两个值范围并集的结果 [1..10] 和 [2..20] 。...", 
"body" : "对于分支，单独计算各个分支。然后将各个范围中的值范围组合起来形成新的值范围。 例子 \/\/Implementation\nIF func(TRUE) THEN\n x := 1;\nELSE \n x := 10;\nEND_IF\n\nIF func(FALSE) THEN\n y := x;\nELSE\n Y := 2*x;\nEND_IF 6号线， x 有范围 [1..10] 。第 11 行之后， y 有取值范围 [1..20] ;这是两个值范围并集的结果 [1..10] 和 [2..20] 。 " }, 
{ "title" : "状况 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505886343398433833583258632", 
"breadcrumbs" : "CODESYS Static Analysis \/ 不断传播 \/ 不断传播 \/ 状况 ", 
"snippet" : "例子 条件可以限制代码块中变量的值范围。可以组合多个条件。互斥条件也可能导致空值范围。 IF y > 0 AND y < 10 THEN x := y; ELSE x:= 0; END_IF IF x < 0 THEN i := 99; END_IF y 的取值范围 [1..9] 第 2 行。这会得出值范围 [0..9] 为了 x 第6行。结合条件 x < 0 ，这会导致一组空的可能值 x 第 8 行。该代码无法访问。静态分析将报告该情况 x < 0 总是返回 FALSE 在此刻。...", 
"body" : "例子 条件可以限制代码块中变量的值范围。可以组合多个条件。互斥条件也可能导致空值范围。 IF y > 0 AND y < 10 THEN\n x := y;\nELSE\n x:= 0;\nEND_IF\nIF x < 0 THEN\n i := 99;\nEND_IF y 的取值范围 [1..9] 第 2 行。这会得出值范围 [0..9] 为了 x 第6行。结合条件 x < 0 ，这会导致一组空的可能值 x 第 8 行。该代码无法访问。静态分析将报告该情况 x < 0 总是返回 FALSE 在此刻。 " }, 
{ "title" : "循环播放 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4649940201660833833593476437", 
"breadcrumbs" : "CODESYS Static Analysis \/ 不断传播 \/ 不断传播 \/ 循环播放 ", 
"snippet" : "常量传播将循环代码，直到循环中变量的值不再改变。假设循环可以运行任意次。到目前为止确定的值与之前的值相结合。在循环内改变的变量具有连续增长的范围。这里，常数传播并不采用所有可能的范围值，而是仅使用代码中出现的限制以及值 0、1、2、3 和 10，因为这些通常是相关的。 例子 描述该过程的最简单方法是通过示例： PROGRAM PLC_PRG VAR x: DINT; i : DINT; y : DINT; END_VAR \/\/Implementation x := 0; y := 0; FOR i := 0 TO 5 DO x := x + 1; y := i; END_FOR 常量传播了解有...", 
"body" : "常量传播将循环代码，直到循环中变量的值不再改变。假设循环可以运行任意次。到目前为止确定的值与之前的值相结合。在循环内改变的变量具有连续增长的范围。这里，常数传播并不采用所有可能的范围值，而是仅使用代码中出现的限制以及值 0、1、2、3 和 10，因为这些通常是相关的。 例子 描述该过程的最简单方法是通过示例： PROGRAM PLC_PRG\nVAR\n x: DINT;\n i : DINT;\n y : DINT;\nEND_VAR \/\/Implementation\nx := 0;\ny := 0;\nFOR i := 0 TO 5 DO\n x := x + 1;\n y := i;\nEND_FOR 常量传播了解有关循环的以下信息： i , x ， 和 y 在第一次执行循环开始时为 0。条件 i <= 5 适用于循环中的代码。条件 i > 5 适用于循环后的代码。 对于循环中变量的值，常数传播确定以下值： i x y [0..5] [0..MAXDINT] [0..5] 具体来说，经过以下中间步骤： 经过 i x y 1 0 [0..1] 0 i 初始化为0； y 总是获得与 i 相同的值。 2 [0..1] [0..2] [0..1] 6 [0..5] [0..6] [0..5] 一、范围 [0..6] 实际上计算的是 i 。然而，据了解， i < 5 是一个条件。因此，循环中代码的值仅限于该值。 7 [0..5] [0..7] [0..5] 10 [0..5] [0..10] [0..5] x 越来越多地增加。从 10 ，但是，该值被“四舍五入”为 MAXINT 。 11 [0..5] [0..MAXDINT] [0..5] MAXDINT + 1 结果是 MAXDINT 截至11日 从第11遍开始，循环中的值不会改变。传播结束。 此外， i = 6 适用于该循环之后的代码。范围 [0..6] 在循环中确定，并与条件结合 i > 5 ，结果恰好是值 6。 " }, 
{ "title" : "参考：用户界面 ", 
"url" : "_san_f_reference_user_interface.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令 ", 
"url" : "_san_struct_reference_commands.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "命令：提取函数 ", 
"url" : "_san_cmd_extract_function.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：提取函数 ", 
"snippet" : "提取功能 功能 ：该命令打开 提取功能配置 对话。 该命令从 ST 编辑器中提取选定的代码，并创建一个包含该代码的新方法或函数。 ST 编辑器中受影响的代码被正确的调用替换。当从功能块或功能块的子项中提取代码时，会从代码中创建一个新方法。当从程序或函数中提取代码时，会从代码中创建一个新函数。 在这种情况下还要注意： 检测代码克隆称呼 ： 上下文菜单： 重构 要求 ：当所选代码包含一个或多个语句时： 所选代码不包含任何编译错误。 所选代码位于 ST POU 的实现部分。 所选代码不包含任何退出跳转 退出跳转的示例包括： 使用 RETURN 退出封闭功能 使用 CONTINUE 或者 EXIT 退...", 
"body" : "提取功能 功能 ：该命令打开 提取功能配置 对话。 该命令从 ST 编辑器中提取选定的代码，并创建一个包含该代码的新方法或函数。 ST 编辑器中受影响的代码被正确的调用替换。当从功能块或功能块的子项中提取代码时，会从代码中创建一个新方法。当从程序或函数中提取代码时，会从代码中创建一个新函数。 在这种情况下还要注意： 检测代码克隆称呼 ： 上下文菜单： 重构 要求 ：当所选代码包含一个或多个语句时： 所选代码不包含任何编译错误。 所选代码位于 ST POU 的实现部分。 所选代码不包含任何退出跳转 退出跳转的示例包括： 使用 RETURN 退出封闭功能 使用 CONTINUE 或者 EXIT 退出包含代码的循环 您可以撤消 提取功能 通过将光标定位在设备树中并单击在您的项目中创建的命令 编辑→撤消 . 提取功能配置 对话 名称 最近创建的函数或方法的名称 可以更改默认名称。 返回值 如果有多个输出和\/或输入\/输出参数，则确定函数的返回值 参数 显示可用的 POU 配置参数是否用作输入、输出或输入\/输出变量 : 输入变量 ：输出变量 ：输入\/输出变量 所做的更改 名称 , 返回值 ， 或者 范围 被撤消。 上代码窗口 最近创建的呼叫位置代码 下代码窗口 最近创建的函数或方法的代码 行 ST POU 中接受显示的代码更改并关闭对话框。 取消 显示的代码更改被拒绝并关闭对话框。 " }, 
{ "title" : "命令：反转 IF 语句 ", 
"url" : "_san_cmd_invert_if_statement.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：反转 IF 语句 ", 
"snippet" : "反转 IF 语句 功能 ：该命令反转 IF 声明不改变语义 IF 陈述。条件被否定。中的陈述 THEN 和 ELSE 分支被交换。所有评论均被保留。 称呼 ：上下文菜单下 重构 命令 要求：光标位于任意位置 之内 一个 IF 陈述。 否定规则 表达 否定表达 描述 < >= “小于”的比较变为“大于”，反之亦然。 <= > “小于或等于”的比较变为“大于”，反之亦然。 = <> “等于”的比较变成“不等于”，反之亦然。 <表达1> AND <表达2> ( NOT <表达1> ) OR ( NOT <表达2> ) 根据德摩根的否定 AND 操作员 <表达1> OR <表达2> (NOT <表达1...", 
"body" : "反转 IF 语句 功能 ：该命令反转 IF 声明不改变语义 IF 陈述。条件被否定。中的陈述 THEN 和 ELSE 分支被交换。所有评论均被保留。 称呼 ：上下文菜单下 重构 命令 要求：光标位于任意位置 之内 一个 IF 陈述。 否定规则 表达 否定表达 描述 < >= “小于”的比较变为“大于”，反之亦然。 <= > “小于或等于”的比较变为“大于”，反之亦然。 = <> “等于”的比较变成“不等于”，反之亦然。 <表达1> AND <表达2> ( NOT <表达1> ) OR ( NOT <表达2> ) 根据德摩根的否定 AND 操作员 <表达1> OR <表达2> (NOT <表达1> ) AND (NOT <表达2> ) 根据德摩根的否定 OR 操作员 <表达> NOT <表达> 标准否定 NOT <表达> <表达> 没有双 NOT 表达 a (*评论*) = b a (*评论*) <> b 评论被保留。这尤其适用于交换操作数 例子 PROGRAM Inversion1\nVAR\n xA, xB, xC : BOOL;\n iVar : INT;\nEND_VAR iVar := 0;\nIF NOT(xA AND xB AND xC) THEN\n\tiVar:= 1; (* IF 1 *)\nELSE\n\tiVar := iVar + 1; (* ELSE counter*)\nEND_IFiVar := 0;\n 调用具有相同语义的反转逻辑命令后的代码： iVar := 0;\nIF (xA AND xB AND xC) THEN\n iVar := iVar + 1; (* ELSE counter*)\nELSE\n iVar:= 1; (* IF 1 *)\nEND_IF " }, 
{ "title" : "命令：显示当前编辑器的恒定传播值 ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：显示当前编辑器的恒定传播值 ", 
"snippet" : "显示当前编辑器的恒定传播值 象征： 功能 ：该命令启动静态代码分析，并计算当前编辑器中代码不断传播的测量值。打开的对话框显示结果。列出分析的代码并显示确定的测量值。 称呼 : 构建 → 静态分析 菜单 要求 ：在编辑器中打开 ST 实现语言的编程对象。 有关更多信息，请参阅： 不断传播...", 
"body" : "显示当前编辑器的恒定传播值 象征： 功能 ：该命令启动静态代码分析，并计算当前编辑器中代码不断传播的测量值。打开的对话框显示结果。列出分析的代码并显示确定的测量值。 称呼 : 构建 → 静态分析 菜单 要求 ：在编辑器中打开 ST 实现语言的编程对象。 有关更多信息，请参阅： 不断传播" }, 
{ "title" : "对话：不断传播的结果 ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html#UUID-948900c6-97a3-c88d-ff29-bca9a5de0d7b_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：显示当前编辑器的恒定传播值 \/ 对话：不断传播的结果 ", 
"snippet" : "例子...", 
"body" : "例子 " }, 
{ "title" : "命令：运行静态分析 ", 
"url" : "_san_cmd_run_static_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：运行静态分析 ", 
"snippet" : "运行静态分析 象征： 功能 ：该命令启动活动应用程序的静态分析，并在表格中显示所有 POU 的指标。 称呼 ： 构建 → 静态分析 菜单 在代码分析过程中， CODESYS Static Analysis 生成代码就像 构建 → 生成代码 命令。分析结果显示为错误 和警告 在消息视图中（ 建造 类别）。数字是指对应的 规则 因为它们是在项目设置中定义的。显示消息的语法是 SA<规则编号>:<规则文本> ....", 
"body" : "运行静态分析 象征： 功能 ：该命令启动活动应用程序的静态分析，并在表格中显示所有 POU 的指标。 称呼 ： 构建 → 静态分析 菜单 在代码分析过程中， CODESYS Static Analysis 生成代码就像 构建 → 生成代码 命令。分析结果显示为错误 和警告 在消息视图中（ 建造 类别）。数字是指对应的 规则 因为它们是在项目设置中定义的。显示消息的语法是 SA<规则编号>:<规则文本> . " }, 
{ "title" : "命令：设置 ", 
"url" : "_san_cmd_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：设置 ", 
"snippet" : "设置 功能 ：该命令打开 静态分析设置 对话。 称呼 ： 构建 → 静态分析 菜单 要求 ： 包裹 CODESYS Static Analysis 已安装。 一个项目已打开。...", 
"body" : "设置 功能 ：该命令打开 静态分析设置 对话。 称呼 ： 构建 → 静态分析 菜单 要求 ： 包裹 CODESYS Static Analysis 已安装。 一个项目已打开。 " }, 
{ "title" : "命令：查看标准指标 ", 
"url" : "_san_cmd_view_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：查看标准指标 ", 
"snippet" : "查看标准指标 象征： 功能 ：该命令启动活动应用程序的静态代码分析。然后计算所有编程块的默认指标并将其显示在表格中 标准指标 标签。 称呼 : 构建 → 静态分析 菜单 有关更多信息，请参阅： 显示指标指标...", 
"body" : "查看标准指标 象征： 功能 ：该命令启动活动应用程序的静态代码分析。然后计算所有编程块的默认指标并将其显示在表格中 标准指标 标签。 称呼 : 构建 → 静态分析 菜单 有关更多信息，请参阅： 显示指标指标" }, 
{ "title" : "选项卡：标准指标 ", 
"url" : "_san_cmd_view_standard_metrics.html#UUID-c2310f81-c613-bf67-ba1e-4f10694a38a1_section-idm4622240725232033866114829692", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：查看标准指标 \/ 选项卡：标准指标 ", 
"snippet" : "例子 在里面 静态分析设置：指标 对话框中，您可以更改指标的配置。您可以禁用指标的计算。您还可以为特定指标定义限制值。 如果值超出配置的上限和下限，则表中的字段将以红色突出显示。 表的上下文菜单中提供了以下命令： 计算 更新值 复制表 将表复制到剪贴板 分隔符是一个制表符。 打印表 打开默认对话框以设置打印作业 导出表 将表导出到 CSV 文件 分隔符是分号。 基维亚特图 要求：至少启用三个已定义上限和下限的指标。 将所选功能块的指标表示为雷达图 这可以根据给定标准可视化 POU 代码的质量。 每个度量都被描述为一个轴，其原点位于中心（值 0），向外辐射成三个同心环区域。内环区域表示低于为度量...", 
"body" : "例子 在里面 静态分析设置：指标 对话框中，您可以更改指标的配置。您可以禁用指标的计算。您还可以为特定指标定义限制值。 如果值超出配置的上限和下限，则表中的字段将以红色突出显示。 表的上下文菜单中提供了以下命令： 计算 更新值 复制表 将表复制到剪贴板 分隔符是一个制表符。 打印表 打开默认对话框以设置打印作业 导出表 将表导出到 CSV 文件 分隔符是分号。 基维亚特图 要求：至少启用三个已定义上限和下限的指标。 将所选功能块的指标表示为雷达图 这可以根据给定标准可视化 POU 代码的质量。 每个度量都被描述为一个轴，其原点位于中心（值 0），向外辐射成三个同心环区域。内环区域表示低于为度量定义的下限的值范围。外圈代表高于上限的数值范围。指标的轴均匀分布在圆圈周围。 轴上各个指标的当前值由一条线连接。在理想情况下，整条线路位于中间区域。 配置 打开表格以选择所需的指标 这对应于项目设置中的表。 打开POU 打开带有 POU 的编辑器 例子 五个指标的 Kiviat 图示例 度量的名称显示在相应轴的末尾，POU 的名称显示在图表的右上角。 " }, 
{ "title" : "命令：计算并导出标准指标 ", 
"url" : "_san_calculate_and_export_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：计算并导出标准指标 ", 
"snippet" : "计算并导出标准指标 功能：直接计算并导出标准指标，无需在编辑器中显示指标表。在标准文件对话框中为 CSV 导出文件指定合适的名称。 呼叫：默认情况下，该命令在任何菜单中均不可用。 或者，您也可以使用 显示标准指标 命令在编辑器中显示指标。除此之外，编辑器还提供了 导出表 上下文命令。 自定义菜单 提供命令 点击 工具 → 自定义 。 这 菜单 选项卡打开。首先，您需要定义命令的菜单位置。在这种情况下，选择下面的项目是有意义的 构建 → 静态分析 菜单。 选择所需的位置并单击 添加命令 按钮。 所有命令都列在 添加命令 对话。 选择 静态分析 类别在左侧，然后所需的命令在右侧。点击 好的 关闭对...", 
"body" : "计算并导出标准指标 功能：直接计算并导出标准指标，无需在编辑器中显示指标表。在标准文件对话框中为 CSV 导出文件指定合适的名称。 呼叫：默认情况下，该命令在任何菜单中均不可用。 或者，您也可以使用 显示标准指标 命令在编辑器中显示指标。除此之外，编辑器还提供了 导出表 上下文命令。 自定义菜单 提供命令 点击 工具 → 自定义 。 这 菜单 选项卡打开。首先，您需要定义命令的菜单位置。在这种情况下，选择下面的项目是有意义的 构建 → 静态分析 菜单。 选择所需的位置并单击 添加命令 按钮。 所有命令都列在 添加命令 对话。 选择 静态分析 类别在左侧，然后所需的命令在右侧。点击 好的 关闭对话框。然后点击 好的 再次关闭 定制 对话。 这 计算并导出标准指标 命令现在可以在 构建 → 静态分析 菜单。 " }, 
{ "title" : "命令：检测克隆 ", 
"url" : "_san_cmd_find_clones.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：检测克隆 ", 
"snippet" : "检测克隆 功能 ：命令扫描打开的程序代码 CODESYS 复制代码的项目，然后打开 克隆检测结果 查看以显示检测到的克隆代码块。在这个过程中，只有大于特定大小的代码块才被认为是克隆。非常小的代码块不会显示为克隆。 在这种情况下，还要注意 提取功能 和 检测代码克隆 指示。 称呼 ： 构建 → 静态分析 菜单 静态分析 上下文菜单 要求 ： 这 CODESYS Static Analysis 项目已打开。 如果两个代码位置具有以下属性，则它们被视为克隆： 相同的结构组成 变量具有相同的数据类型。 变量名可能不同（例外：组件访问）。但是，在代码中多次包含的标识符必须在两个代码位置的相同位置。 文字...", 
"body" : "检测克隆 功能 ：命令扫描打开的程序代码 CODESYS 复制代码的项目，然后打开 克隆检测结果 查看以显示检测到的克隆代码块。在这个过程中，只有大于特定大小的代码块才被认为是克隆。非常小的代码块不会显示为克隆。 在这种情况下，还要注意 提取功能 和 检测代码克隆 指示。 称呼 ： 构建 → 静态分析 菜单 静态分析 上下文菜单 要求 ： 这 CODESYS Static Analysis 项目已打开。 如果两个代码位置具有以下属性，则它们被视为克隆： 相同的结构组成 变量具有相同的数据类型。 变量名可能不同（例外：组件访问）。但是，在代码中多次包含的标识符必须在两个代码位置的相同位置。 文字具有相同的数据类型。 字面量可能不同。在代码中多次出现的文字必须出现在两个代码位置的相同位置。 克隆检测结果 看法 概括 选项卡显示搜索结果 找到的克隆代码序列数 比较的语句数 克隆代码中的语句数 克隆比例 ：指定为百分比： 克隆代码中的语句数 \/ 比较的语句数 结果 该选项卡在树视图中显示代码克隆，并提供命令和过滤器选项。 将重复项集中第一次出现的重复项作为根节点。子节点的背景颜色表示代码是不同的还是完全相同的。相同的颜色表示“相同的代码”。树视图的内容按重复代码的语句数降序排列。 上的命令和过滤器 结果 标签 子节点\/克隆 代码块中的子节点（语句）数 如果子节点数小于 20，则不考虑代码克隆。 过滤对象 输入字段 目的 ，通过它过滤克隆列表 显示选定的克隆 要求：选中同一个父节点的两个子节点。 两个编程对象都显示在视图的上部以供比较。在此过程中，代码重复突出显示，差异（例如，不同的变量名称）以不同的颜色突出显示。 代码克隆列表 列 描述 子节点\/克隆 目的 位置 双击一个子节点会打开相应的编程对象，复制的代码块会在那里被选中。 " }, 
{ "title" : "命令：显示当前编辑器的认知复杂性 ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：显示当前编辑器的认知复杂性 ", 
"snippet" : "显示当前编辑者的认知复杂性 象征： 功能 ：该命令启动静态代码分析，并计算当前编辑器中代码认知复杂度的测量值。打开的对话框会显示结果并在标题中指定测量值总和。列出并显示分析的代码以及检测到的复杂性。 称呼 : 构建 → 静态分析 菜单 要求 ：在编辑器中打开 ST 实现语言的编程对象。...", 
"body" : "显示当前编辑者的认知复杂性 象征： 功能 ：该命令启动静态代码分析，并计算当前编辑器中代码认知复杂度的测量值。打开的对话框会显示结果并在标题中指定测量值总和。列出并显示分析的代码以及检测到的复杂性。 称呼 : 构建 → 静态分析 菜单 要求 ：在编辑器中打开 ST 实现语言的编程对象。 " }, 
{ "title" : "对话框：<POU 名称> 的认知复杂性：<计算的测量值> ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html#UUID-315a7cbe-83be-ba91-4d86-234b9f3e6fc3_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：显示当前编辑器的认知复杂性 \/ 对话框：<POU 名称> 的认知复杂性：<计算的测量值> ", 
"snippet" : "例子...", 
"body" : "例子 " }, 
{ "title" : "命令：运行静态分析并导出到 SARIF 文件 ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：运行静态分析并导出到 SARIF 文件 ", 
"snippet" : "运行静态分析并导出到 SARIF 文件 符号： 函数 ：此命令启动静态代码分析并将结果保存到 SARIF 文件中。 称呼 : 构建 → 静态分析 菜单 一个 SARIF 文件 (” 静态分析结果交换格式 “) 是机器可读的 JSON 文件，文件扩展名为” *.sarif.json ” 由静态分析创建，用于以标准格式存储结果。 SARIF 是 OASIS 标准。这意味着各种工具和平台可以使用它来交换和处理分析结果。...", 
"body" : "运行静态分析并导出到 SARIF 文件 符号： 函数 ：此命令启动静态代码分析并将结果保存到 SARIF 文件中。 称呼 : 构建 → 静态分析 菜单 一个 SARIF 文件 (” 静态分析结果交换格式 “) 是机器可读的 JSON 文件，文件扩展名为” *.sarif.json ” 由静态分析创建，用于以标准格式存储结果。 SARIF 是 OASIS 标准。这意味着各种工具和平台可以使用它来交换和处理分析结果。 " }, 
{ "title" : "命令行命令 ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html#UUID-b1a6530c-4103-8c37-7a9e-f6ad763d2402_section-idm235003337576496", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：运行静态分析并导出到 SARIF 文件 \/ 命令行命令 ", 
"snippet" : "该命令也可以通过以下方式自动执行 CODESYS Scripting 。批处理命令 [\"staticanalysis\", \"runandexportosarif\"] 接受以下参数。 论点： --sariffile --sariffile=<path to output>; 指定应写入生成的 SARIF 文件的路径。如果您未指定路径，则文件将保存在当前项目的文件夹中。 论点： --rulesfile --rulesfile=<patch to CSA file>; 指定应用于静态分析的 CSA 文件的路径。如果未指定路径，则使用当前配置。 Python 脚本中的调用示例 system.comma...", 
"body" : "该命令也可以通过以下方式自动执行 CODESYS Scripting 。批处理命令 [\"staticanalysis\", \"runandexportosarif\"] 接受以下参数。 论点： --sariffile --sariffile=<path to output>; 指定应写入生成的 SARIF 文件的路径。如果您未指定路径，则文件将保存在当前项目的文件夹中。 论点： --rulesfile --rulesfile=<patch to CSA file>; 指定应用于静态分析的 CSA 文件的路径。如果未指定路径，则使用当前配置。 Python 脚本中的调用示例 system.commands[\"staticanalysis\", \"runandexportosarif\"].execute(\"--sariffile=result.sarif\", \"--rulesfile=rules.csa\") " }, 
{ "title" : "命令：格式 ", 
"url" : "_san_cmd_format.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 命令 \/ 命令：格式 ", 
"snippet" : "格式 调试模式 仅当您的 CODESYS 实例以调试模式启动。 为此，请使用以下命令行调用启动您的实例： codesys.exe --debug 功能 ：该命令根据配置的规则格式化ST对象 CODESYS 选项以提高代码的可读性。 称呼 : 上下文菜单下 重构 菜单 要求：ST 编辑器已打开并且光标位于声明或实现内。 有关更多信息，请参阅： 自动格式化程序...", 
"body" : "格式 调试模式 仅当您的 CODESYS 实例以调试模式启动。 为此，请使用以下命令行调用启动您的实例： codesys.exe --debug 功能 ：该命令根据配置的规则格式化ST对象 CODESYS 选项以提高代码的可读性。 称呼 : 上下文菜单下 重构 菜单 要求：ST 编辑器已打开并且光标位于声明或实现内。 有关更多信息，请参阅： 自动格式化程序" }, 
{ "title" : "对话框 ", 
"url" : "_san_struct_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 对话框 ", 
"snippet" : "对于配置静态代码分析的对话框，单击 构建→静态分析→设置 .要求：一个 CODESYS 项目必须打开。...", 
"body" : "对于配置静态代码分析的对话框，单击 构建→静态分析→设置 .要求：一个 CODESYS 项目必须打开。 " }, 
{ "title" : "对话框：静态分析设置：设置 ", 
"url" : "_san_dlg_settings_static_analysis_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 对话框 \/ 对话框：静态分析设置：设置 ", 
"snippet" : "设置 功能 ：在对话框中，选择自动 静态分析 ，并将静态分析的项目设置保存或加载为 CSA 文件。 项目 → 项目设置 菜单， 静态分析 类别， 打开配置对话框 关联 构建→静态分析→设置 菜单 要求 ： 这 CODESYS Static Analysis 包已安装。 一个项目已打开。 自动执行静态分析 ： CODESYS Static Analysis 在每次代码生成时自动执行代码检查（例如，当 构建 → 生成代码 命令执行或在下载之前执行。 ：代码检查不会自动执行，但可以通过 构建 → 静态分析 → 运行静态分析 命令。 加载 打开 加载静态分析配置 对话框，用于选择静态分析的项目设置作为...", 
"body" : "设置 功能 ：在对话框中，选择自动 静态分析 ，并将静态分析的项目设置保存或加载为 CSA 文件。 项目 → 项目设置 菜单， 静态分析 类别， 打开配置对话框 关联 构建→静态分析→设置 菜单 要求 ： 这 CODESYS Static Analysis 包已安装。 一个项目已打开。 自动执行静态分析 ： CODESYS Static Analysis 在每次代码生成时自动执行代码检查（例如，当 构建 → 生成代码 命令执行或在下载之前执行。 ：代码检查不会自动执行，但可以通过 构建 → 静态分析 → 运行静态分析 命令。 加载 打开 加载静态分析配置 对话框，用于选择静态分析的项目设置作为文件系统中的 CSA 文件。当您单击 打开 按钮，加载选定的 CSA 文件。 保存 打开 保存静态分析配置 用于保存所有项目设置的对话框 静态分析 类别作为文件系统中的 CSA 文件。 " }, 
{ "title" : "对话框：静态分析设置： 规则 ", 
"url" : "_san_dlg_settings_sa_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 对话框 \/ 对话框：静态分析设置： 规则 ", 
"snippet" : "规则 功能 ：在对话框中选择 规则 在项目源代码的静态分析过程中检查。 有关更多信息，请参阅： 配置和运行静态分析称呼 ： 项目 → 项目设置 菜单， 静态分析 类别， 打开配置对话框 关联 构建→静态分析→设置 菜单 要求 ： 这 CODESYS Static Analysis 包已安装。 一个项目已打开。 此选项卡显示可以在静态分析期间检查的所有规则的树结构。默认情况下，除了 SA0016、SA0024、SA0073、SA0101、SA0105、SA0106、SA0133、SA0134、SA0150、SA0162 以及所有“严格的 IEC 规则”之外，所有规则都被激活。 每条规则都有一个唯...", 
"body" : "规则 功能 ：在对话框中选择 规则 在项目源代码的静态分析过程中检查。 有关更多信息，请参阅： 配置和运行静态分析称呼 ： 项目 → 项目设置 菜单， 静态分析 类别， 打开配置对话框 关联 构建→静态分析→设置 菜单 要求 ： 这 CODESYS Static Analysis 包已安装。 一个项目已打开。 此选项卡显示可以在静态分析期间检查的所有规则的树结构。默认情况下，除了 SA0016、SA0024、SA0073、SA0101、SA0105、SA0106、SA0133、SA0134、SA0150、SA0162 以及所有“严格的 IEC 规则”之外，所有规则都被激活。 每条规则都有一个唯一的编号。检查规则并检测到违规时，规则编号和错误描述将显示在 建造 类别格式如下： SA<规则编号> ，其中“SA”代表“静态分析”（例如：“SA003”代表规则 3）。 可用规则列表可以通过特定插件进行扩展。 筛选 要搜索的字符串的输入字段 规则按类别分组。 按重要性构建 : 排序依据 重要性高 , 重要性 中等 ， 和 重要性低 默认 ：规则的默认结构 CODESYS Static Analysis ：规则显示为平面列表。通过单击相应的列标题，可以按规则编号、激活\/停用、规则特定配置或重要性对列表进行排序。 在对话框中激活的某些规则可以通过应用 语用 . 单击复选框时，设置在 , ， 和 . 当您激活或停用父节点时，所有子规则也将分别激活或停用。 列 规则 带有规则编号的规则列表 规则检查 : 不检查规则。 ：如果检查结果是肯定的，那么一个错误（ ) 用于在消息视图中发出静态分析。 : 如果检查结果是肯定的，则警告 ( ) 用于在消息视图中发出静态分析。 预编译 : 可以在预编译期间检查的规则由复选标记标识（ ）在本专栏中。这意味着输入代码时已经检查了规则。 这些规则可以立即修复错误（快速修复）。您可以直接在受影响的代码位置执行自动、即时的错误处理。 : 未标记的规则仅在成功编译后才进行检查。 规则特定配置 对于某些规则，您可以双击该字段以打开特定于规则的对话框来配置规则。 重要性 ： 规则的重要性： 3颗红星：高 2 颗橙色星：中 1 颗灰色星：低 " }, 
{ "title" : "对话框：静态分析设置 - 命名约定 ", 
"url" : "_san_dlg_settings_sa_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 对话框 \/ 对话框：静态分析设置 - 命名约定 ", 
"snippet" : "静态分析设置 – 命名约定 功能 ：在对话框中，您 定义 变量的数据类型和范围的前缀，以及 POU 和用户定义的数据类型 (DUT) 的前缀。静态分析检查 遵守 与命名约定。当未遵守约定时，静态分析会在 留言 看法。有关更多信息，请参阅： 配置和运行静态分析称呼 ： 项目 → 项目设置 菜单， 静态分析 类别， 打开配置对话框 关联 构建→静态分析→设置 菜单 要求 ： 这 CODESYS Static Analysis 包已安装。 一个项目已打开。 错误消息以下列格式显示： NC <prefix of convention number> : <message text> . NC 代表“命...", 
"body" : "静态分析设置 – 命名约定 功能 ：在对话框中，您 定义 变量的数据类型和范围的前缀，以及 POU 和用户定义的数据类型 (DUT) 的前缀。静态分析检查 遵守 与命名约定。当未遵守约定时，静态分析会在 留言 看法。有关更多信息，请参阅： 配置和运行静态分析称呼 ： 项目 → 项目设置 菜单， 静态分析 类别， 打开配置对话框 关联 构建→静态分析→设置 菜单 要求 ： 这 CODESYS Static Analysis 包已安装。 一个项目已打开。 错误消息以下列格式显示： NC <prefix of convention number> : <message text> . NC 代表“命名约定”。例如，错误消息 NC0102：名称无效… 表示违反 POU 类型的命名约定 102 PROGRAM . 您可以使用 'naming' 用于停用个人命名约定的 pragma 身份标识 .标识符可以以任何东西开头，不一定以前缀开头。 筛选 要搜索的字符串的输入字段 具有命名约定的表 名称 可以定义前缀的节点和元素。 每个元素后括号中的数字（例如， 程序 (102) ) 是在不符合命名约定的情况下报告的前缀约定编号。 字首 前缀的输入字段 可以通过逗号分隔指定多个前缀。 例子： POU 的前缀 , PROGRAM (102) ： prog, PRG_ POU 的前缀 , FUNCTION (103) ： fun, FUN_ 正则表达式 (RegEx) 也可以用于前缀。为此，一个 @ 必须放在前面。 例子： 名字必须以 x 并且可能包含范围中的一个字符 a-dA-D ： @x[a-dA-D] . 对于类型的变量 别名 和 POU 类型 财产 , 前缀可以用占位符定义 {datatype} . 变量的前缀 可以根据数据类型或范围定义前缀的所有变量的组织节点。 POU 的前缀 可以定义前缀的所有 POU 类型和方法范围的组织节点 DUT 的前缀 可以为其定义前缀的 DUT 数据类型（结构、枚举、别名或联合）的组织节点 自定义类型的前缀 特殊自定义类型的组织节点（特别是来自库的那些） 您可以使用约定扩展列表：单击其下方的空白区域。在里面 输入助手 对话框，指定自定义类型的名称或选择自定义类型。 要删除约定，选择它并按 德尔 钥匙。 注意：这些约定优先于使用属性定义的前缀 {attribute 'nameprefix' := '<prefix>'} . 选项 前缀后的第一个字符应该是大写字母 : 定义前缀后变量名的第一个字符不是大写字母时，静态分析会报错。 结合范围前缀和数据类型前缀 ：作为其命名空间，变量必须具有定义的前缀，后跟为其数据类型定义的前缀。 示例：定义了以下前缀： g_ 为了 VAR_GLOBAL ， 和 r 对于数据类型 真实的 . 代码分析报告没有前缀的全局 REAL 变量的错误 g_r . ：如果为变量指定了命名空间的约定，则考虑这些约定。因此，任何数据类型约定都会被忽略。 示例：定义了以下前缀： g_ 为了 VAR_GLOBAL ， 和 r 对于数据类型 真实的 . 代码分析仅报告全局错误 REAL 没有前缀的变量 g_ . 可组合数据类型的递归前缀 : 组合数据类型的变量必须具有遵循定义的命名约定的复合前缀。 例子： ppiVariable : POINTER TO POINTER TO INT; 前缀 p 为数据类型的变量定义 POINTER , 和前缀 I 为数据类型定义 INT . 静态分析报告所有类型变量的错误 POINTER TO POINTER TO INT 没有前缀的 ppi . refaiVar : REFERENCE TO ARRAY[1..3] OF INT; 前缀 ref 为数据类型定义 REFERENCE TO , 前缀 a 对于一个数组，以及前缀 I 对于数据类型 INT . 静态分析报告所有类型变量的错误 REFERENCE TO ARRAY[1..3] OF INT 没有前缀的 refai . 例子 以下命名约定大部分对应于在 CODESYS 对于“标识符”。 例子 命名约定 (1) 参考标准 POU TON .因此，特殊库 POU 的声明会检查前缀“ton_”。单击空格 (2) 以插入更多命名约定。 " }, 
{ "title" : "对话框：静态分析设置：指标 ", 
"url" : "_san_dlg_settings_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 对话框 \/ 对话框：静态分析设置：指标 ", 
"snippet" : "静态分析设置：指标 象征： 功能 ：配置指标，以便在 查看标准指标 命令被执行。 称呼 ： 项目 → 项目设置 菜单， 静态分析 类别， 打开配置对话框 关联 构建 → 静态分析 → 设置 菜单 要求 ： 这 CODESYS Static Analysis 安装包。 一个项目已打开。 有关更多信息，请参阅： 配置和运行静态分析指标 全部可选 指标 都显示在列中。 积极的 : 为每个 POU 显示度量标准 标准指标 查看以下 构建 → 静态分析 → 查看标准指标 命令。 ：指标不显示在 标准指标 查看以下 构建 → 静态分析 → 查看标准指标 命令。 下限 显示指标的较低值 上限 显示指标的上限...", 
"body" : "静态分析设置：指标 象征： 功能 ：配置指标，以便在 查看标准指标 命令被执行。 称呼 ： 项目 → 项目设置 菜单， 静态分析 类别， 打开配置对话框 关联 构建 → 静态分析 → 设置 菜单 要求 ： 这 CODESYS Static Analysis 安装包。 一个项目已打开。 有关更多信息，请参阅： 配置和运行静态分析指标 全部可选 指标 都显示在列中。 积极的 : 为每个 POU 显示度量标准 标准指标 查看以下 构建 → 静态分析 → 查看标准指标 命令。 ：指标不显示在 标准指标 查看以下 构建 → 静态分析 → 查看标准指标 命令。 下限 显示指标的较低值 上限 显示指标的上限值 这 代码大小 , 可变尺寸 , 堆栈大小 ， 和 来电 仅针对项目中集成的库中的 POU 报告指标。 违反激活指标的上下限可以通过静态分析规则报告为构建错误 SA0150 . " }, 
{ "title" : "对话框：静态分析设置：禁止符号 ", 
"url" : "_san_dlg_settings_sa_forbidden_symbols.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 对话框 \/ 对话框：静态分析设置：禁止符号 ", 
"snippet" : "禁止符号 功能 ：在对话框中定义项目代码中不能使用的关键字和符号。有关更多信息，请参阅： 配置和运行静态分析称呼 ： 项目 → 项目设置 菜单， 静态分析 类别， 打开配置对话框 关联 构建→静态分析→设置 菜单 要求 ： 这 CODESYS Static Analysis 包已安装。 一个项目已打开。 输入线 双击行打开行编辑器以指定关键字或符号。 ：输入助手打开以选择关键字或符号。...", 
"body" : "禁止符号 功能 ：在对话框中定义项目代码中不能使用的关键字和符号。有关更多信息，请参阅： 配置和运行静态分析称呼 ： 项目 → 项目设置 菜单， 静态分析 类别， 打开配置对话框 关联 构建→静态分析→设置 菜单 要求 ： 这 CODESYS Static Analysis 包已安装。 一个项目已打开。 输入线 双击行打开行编辑器以指定关键字或符号。 ：输入助手打开以选择关键字或符号。 " }, 
{ "title" : "对话框：选项：自动格式化程序 ", 
"url" : "_cds_dlg_options_smart_code.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项：自动格式化程序 ", 
"snippet" : "自动格式化程序 调试模式 仅当您的 CODESYS 实例以调试模式启动。 为此，请使用以下命令行调用启动您的实例： codesys.exe --debug 象征： 功能 ：在此对话框中配置 IEC 代码的自动格式化。 称呼 ： 工具 → 选项 菜单， 自动格式化程序 类别...", 
"body" : "自动格式化程序 调试模式 仅当您的 CODESYS 实例以调试模式启动。 为此，请使用以下命令行调用启动您的实例： codesys.exe --debug 象征： 功能 ：在此对话框中配置 IEC 代码的自动格式化。 称呼 ： 工具 → 选项 菜单， 自动格式化程序 类别 " }, 
{ "title" : "自动格式化程序 ", 
"url" : "_cds_dlg_options_smart_code.html#UUID-ed744990-e58a-afa4-07c6-a11c0254c4c0_section-idm4605775334425634132064038043", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：用户界面 \/ 对话框 \/ 对话框：选项：自动格式化程序 \/ 自动格式化程序 ", 
"snippet" : "一般的 声明与实施 挤压空行 true （默认）：删除空行。 false ：保留空行。 界面 宣言 对齐变量类型 true （默认）： 变量块中的所有类型都经过排列，以便它们以相同的行深度开始。 false ： 对齐变量初始化 true （默认）： 变量块中的所有初始化都经过排列，以便它们以相同的行深度开始。 false ： 对齐变量尾随注释 true （默认）： 与变量声明位于同一行的所有注释都以相同的行深度开始。 false ： 祈求 当超过最大值时，所有调用都会被格式化。 例子： 最大限度。换行前的参数数量 单行调用可以包含的参数数量是有限的。 示例：4（默认） 最大限度。换行前参数的字...", 
"body" : "一般的 声明与实施 挤压空行 true （默认）：删除空行。 false ：保留空行。 界面 宣言 对齐变量类型 true （默认）： 变量块中的所有类型都经过排列，以便它们以相同的行深度开始。 false ： 对齐变量初始化 true （默认）： 变量块中的所有初始化都经过排列，以便它们以相同的行深度开始。 false ： 对齐变量尾随注释 true （默认）： 与变量声明位于同一行的所有注释都以相同的行深度开始。 false ： 祈求 当超过最大值时，所有调用都会被格式化。 例子： 最大限度。换行前的参数数量 单行调用可以包含的参数数量是有限的。 示例：4（默认） 最大限度。换行前参数的字符长度 参数名称中的字符数是有限的。 示例：300（默认） " }, 
{ "title" : "参考：编程 ", 
"url" : "_san_f_reference_programming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "编译指示和属性 ", 
"url" : "_san_struct_reference_pragmas.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 编译指示和属性 ", 
"snippet" : "CODESYS Static Analysis 提供用于激活或停用个别规则或命名约定以进行静态代码分析的编译指示和属性。 要求：在项目设置中激活或定义规则或约定。 属性被插入到 POU 的声明部分以禁用整个编程对象的特定规则。 Pragma 用于 POU 的实现部分，以停用各个代码行的特定规则。一个例外是规则 164，它也可以在声明部分关闭。 在项目设置中停用的规则无法通过编译指示或属性激活。 不能通过编译指示或属性禁用规则 SA0004。...", 
"body" : "CODESYS Static Analysis 提供用于激活或停用个别规则或命名约定以进行静态代码分析的编译指示和属性。 要求：在项目设置中激活或定义规则或约定。 属性被插入到 POU 的声明部分以禁用整个编程对象的特定规则。 Pragma 用于 POU 的实现部分，以停用各个代码行的特定规则。一个例外是规则 164，它也可以在声明部分关闭。 在项目设置中停用的规则无法通过编译指示或属性激活。 不能通过编译指示或属性禁用规则 SA0004。 " }, 
{ "title" : "语用：analysis ", 
"url" : "_san_pragma_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 编译指示和属性 \/ 语用：analysis ", 
"snippet" : "此 pragma 用于停用 POU 的各个代码行的代码规则，以便将它们排除在 静态分析 .您可以通过指定带有前置减号 (\"-\") 的规则编号来停用代码规则。前置加号 (\"+\") 激活规则。您可以在 pragma 中指定任意数量的规则。 插入位置 ：停用：在实现部分，用 {analysis - ...} 在停用代码分析的第一个代码行之前。激活：有 {analysis + ...} 在停用的最后一行之后。对于规则 164，pragma 也可以插入到注释之前的声明部分中。 句法： Deaktivierung von Regeln: {analysis -<rule number> ( , -<fur...", 
"body" : "此 pragma 用于停用 POU 的各个代码行的代码规则，以便将它们排除在 静态分析 .您可以通过指定带有前置减号 (\"-\") 的规则编号来停用代码规则。前置加号 (\"+\") 激活规则。您可以在 pragma 中指定任意数量的规则。 插入位置 ：停用：在实现部分，用 {analysis - ...} 在停用代码分析的第一个代码行之前。激活：有 {analysis + ...} 在停用的最后一行之后。对于规则 164，pragma 也可以插入到注释之前的声明部分中。 句法： Deaktivierung von Regeln:\n\n{analysis -<rule number> ( , -<further rule number> )* }\n* : optional none, one or more further rule numbers Aktivierung von Regeln:\n\nanalysis +<rule number> ( , +<further rule number> )* }\n* : none, one or more further rule numbers 例子 规则 24 对两行停用，然后重新启用。结果，规则 24 没有在这些行中检查，因此 nTest:=DINT#99 例如是允许的。 {analysis -24}\nnTest := 99;\niVar := INT#2;\n{analysis +24} 停用多个规则： {analysis -10, -24, -18} " }, 
{ "title" : "属性：analysis ", 
"url" : "_san_attribute_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 编译指示和属性 \/ 属性：analysis ", 
"snippet" : "该属性停用整个编程对象的特定规则，以便将它们排除在 静态分析 .您可以通过指定带有前置减号 (\"-\") 的规则编号来停用代码规则。您可以在属性中指定任意数量的规则。 插入位置 : 在 POU 的声明部分，在第一行。 句法 ： {attribute 'analysis' := '-<rule number> ( , -<further rule number> )* '} * : none, one or more further rule numbers 例子 规则 33 和 31 对整个结构无效： {attribute 'analysis' := '-33, -31'} TYPE My_St...", 
"body" : "该属性停用整个编程对象的特定规则，以便将它们排除在 静态分析 .您可以通过指定带有前置减号 (\"-\") 的规则编号来停用代码规则。您可以在属性中指定任意数量的规则。 插入位置 : 在 POU 的声明部分，在第一行。 句法 ： {attribute 'analysis' := '-<rule number> ( , -<further rule number> )* '}\n* : none, one or more further rule numbers 例子 规则 33 和 31 对整个结构无效： {attribute 'analysis' := '-33, -31'}\nTYPE My_Structure :\nSTRUCT\n iLocal : INT;\n uiLocal : UINT;\n udiLocal : UDINT;\nEND_STRUCT\nEND_TYPE 阵列的规则 100 已停用： {attribute 'analysis' := '-100'}\nPROGRAM PLC_PRG\nVAR\n aBigData: ARRAY[1..10000] OF DWORD;\n aBigDATA_2: ARRAY[1..10000] OF DWORD;\nEND_VAR\n; " }, 
{ "title" : "属性：'naming' ", 
"url" : "_san_attribute_naming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 编译指示和属性 \/ 属性：'naming' ", 
"snippet" : "该属性标记了被排除在外的代码行 命名约定分析 .一个 off 在停用代码分析的第一个代码行之前分配给 pragma 属性。一个 on 在最后一行之后分配。当一个 omit 被分配，只有下一个代码行被忽略。 插入位置 ：停用：在 POU 和 DUT 的声明部分中，受影响的行上方。激活：在受影响的线下方。 句法 ： {attribute 'naming' := '<switch state>'} <switch state> : on | off | omit on : naming is switched on off : naming is switched off omit : only n...", 
"body" : "该属性标记了被排除在外的代码行 命名约定分析 .一个 off 在停用代码分析的第一个代码行之前分配给 pragma 属性。一个 on 在最后一行之后分配。当一个 omit 被分配，只有下一个代码行被忽略。 插入位置 ：停用：在 POU 和 DUT 的声明部分中，受影响的行上方。激活：在受影响的线下方。 句法 ： {attribute 'naming' := '<switch state>'}\n<switch state> : on | off | omit\non : naming is switched on\noff : naming is switched off\nomit : only next codeline is switched off 例子 定义的命名约定： 1) INT 变量名称必须以“int”作为标识符前缀，例如“intVar1”。 (2) 程序名称必须以“prog”开头。 对于下面显示的代码，静态分析仅针对以下变量发出消息： cccVar , aVariable ， 和 bVariable . VAR\n{attribute 'naming' := 'off'}\n iVarA : INT;\n iVarB : INT;\n{attribute 'naming' := 'on'}\n iVarC : INT;\nEND_VAR VAR\n ...\n{attribute 'naming' := 'omit'}\n iVarC : INT;\n...\nEND_VAR {attribute 'naming' := 'omit'}\nPROGRAM PLC_PRG\nVAR\n...\nEND_VAR {attribute 'naming' := 'off'}\nPROGRAM DoSomethingA\nVAR\n{attribute 'naming' := 'on'}\n iVarA : INT;\n iVarB : INT;\n …\nVAR_END " }, 
{ "title" : "属性：nameprefix ", 
"url" : "_san_attribute_nameprefix.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 编译指示和属性 \/ 属性：nameprefix ", 
"snippet" : "nameprefix 该属性为结构化数据类型的变量定义前缀。前缀必须添加到此类型声明的变量的标识符之前。这 静态分析 检查此命名约定。 插入位置 ：在声明结构化数据类型之前的行中 句法 ： {attribute 'nameprefix' := '<prefix>'} 例子 在以下示例中，Static Analysis 为 pB 发出一条消息，因为变量名称不以“point”开头。 {attribute 'nameprefix' := 'point'} TYPE DATAPOINT : STRUCT iX: INT; iY: INT; END_STRUCT END_TYPE PROGRAM PLC...", 
"body" : "nameprefix 该属性为结构化数据类型的变量定义前缀。前缀必须添加到此类型声明的变量的标识符之前。这 静态分析 检查此命名约定。 插入位置 ：在声明结构化数据类型之前的行中 句法 ： {attribute 'nameprefix' := '<prefix>'} 例子 在以下示例中，Static Analysis 为 pB 发出一条消息，因为变量名称不以“point”开头。 {attribute 'nameprefix' := 'point'}\nTYPE DATAPOINT :\nSTRUCT\n iX: INT;\n iY: INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n pointA : DATAPOINT;\n pB : DATAPOINT;\nEND_VAR\npointA.iX := 1;\npointA.iY := 10;\npB.iX := 2;\npB.iY := 20; 静态分析后的错误信息： 无效的变量名“pB”：预期的前缀“点” " }, 
{ "title" : "属性：analysis:report-multiple-instance-calls ", 
"url" : "_san_attribute_analysis_report_multiple_instance_calls.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 编译指示和属性 \/ 属性：analysis:report-multiple-instance-calls ", 
"snippet" : "analysis:report-multiple-instance-calls 该属性标记了用于检查规则的功能块 规则 105 ：仅检查具有该属性的功能块是否多次调用功能块实例。当规则 105 在 项目设置 ，该属性没有任何作用。 插入位置 : 功能块声明部分的顶行。 句法 ： {attribute 'analysis:report-multiple-instance-calls'} 例子 \/\/ {attribute 'analysis:report-multiple-instance-calls'} deactivated FUNCTION_BLOCK FB_DoA VAR_INPUT EN...", 
"body" : "analysis:report-multiple-instance-calls 该属性标记了用于检查规则的功能块 规则 105 ：仅检查具有该属性的功能块是否多次调用功能块实例。当规则 105 在 项目设置 ，该属性没有任何作用。 插入位置 : 功能块声明部分的顶行。 句法 ： {attribute 'analysis:report-multiple-instance-calls'} 例子 \/\/ {attribute 'analysis:report-multiple-instance-calls'} deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\n{attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\niB := iB +1;\n\nPROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nND_VAR\n\nfbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n 查看输出 留言 : SA0105：实例“fbB”被调用多次 " }, 
{ "title" : "规则 ", 
"url" : "_san_struct_reference_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0001：无法访问的代码 ", 
"url" : "_san_rule_sa0001.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0001：无法访问的代码 ", 
"snippet" : "检测未执行的代码行，例如由于 RETURN 或者 CONTINUE 陈述 理由：应始终避免无法访问的代码。这 测试 通常表明测试代码仍然存在，应该删除。 重要性：高 PLCopen 规则：CP2 例子 PROGRAM PLC_PRG VAR xReturn_Before_End: BOOL; xContinue_In_Loop_FUN: BOOL; iCounter: INT; END_VAR xContinue_In_Loop_FUN := FALSE; FOR iCounter := INT#0 TO INT#5 BY INT#1 DO CONTINUE; xContinue_In_Loo...", 
"body" : "检测未执行的代码行，例如由于 RETURN 或者 CONTINUE 陈述 理由：应始终避免无法访问的代码。这 测试 通常表明测试代码仍然存在，应该删除。 重要性：高 PLCopen 规则：CP2 例子 PROGRAM PLC_PRG\nVAR\n xReturn_Before_End: BOOL;\n xContinue_In_Loop_FUN: BOOL;\n iCounter: INT;\nEND_VAR\n xContinue_In_Loop_FUN := FALSE;\nFOR iCounter := INT#0 TO INT#5 BY INT#1 DO\n CONTINUE;\n xContinue_In_Loop_FUN := FALSE;\nEND_FOR 输出在 留言 看法： SA0001：在“PLC_PRG”中检测到无法访问的代码 " }, 
{ "title" : "SA0002：空对象 ", 
"url" : "_san_rule_sa0002.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0002：空对象 ", 
"snippet" : "检测不包含任何代码的 POU、GVL、数据类型声明或接口 理由：应该避免空对象。它们通常表明对象尚未完全实现。例外：在某些情况下，当功能块只应由接口使用时，没有在功能块主体中指定代码。在其他情况下，创建一个方法只是因为接口需要该方法，而对该方法没有合理的实现。无论如何，这种情况都应该被评论。 重要性：中等...", 
"body" : "检测不包含任何代码的 POU、GVL、数据类型声明或接口 理由：应该避免空对象。它们通常表明对象尚未完全实现。例外：在某些情况下，当功能块只应由接口使用时，没有在功能块主体中指定代码。在其他情况下，创建一个方法只是因为接口需要该方法，而对该方法没有合理的实现。无论如何，这种情况都应该被评论。 重要性：中等 " }, 
{ "title" : "SA0003：空语句 ", 
"url" : "_san_rule_sa0003.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0003：空语句 ", 
"snippet" : "检测带有分号 ( ; ) 但不是声明 理由：空语句可能是缺少代码的标志。 注意：使用空语句有充分的理由。例如，在一个 CASE 声明明确地编程出所有情况是有意义的，即使是那些无事可做的情况。当这种空 CASE 语句包含注释，静态分析不会生成错误消息。 重要性：低 例子 CASE value OF 1: DoSomething(); 2: ; 3: DoSomethingElse(); END_CASE 输出在 留言 看法： SA0003：空语句 CASE value OF 1: DoSomething(); 2: ; \/\/nothing to do 3: DoSomethingElse(); ...", 
"body" : "检测带有分号 ( ; ) 但不是声明 理由：空语句可能是缺少代码的标志。 注意：使用空语句有充分的理由。例如，在一个 CASE 声明明确地编程出所有情况是有意义的，即使是那些无事可做的情况。当这种空 CASE 语句包含注释，静态分析不会生成错误消息。 重要性：低 例子 CASE value OF\n 1:\n DoSomething();\n 2:\n ;\n 3:\n DoSomethingElse();\nEND_CASE\n 输出在 留言 看法： SA0003：空语句 CASE value OF\n 1:\n DoSomething();\n 2:\n ; \/\/nothing to do\n 3:\n DoSomethingElse();\nEND_CASE\n 输出在 留言 看法： 无 SA 错误 " }, 
{ "title" : "SA0004：输出上的多写访问 ", 
"url" : "_san_rule_sa0004.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0004：输出上的多写访问 ", 
"snippet" : "检测写入多个位置的输出。 理由：当输出写入代码的不同位置时，可维护性会降低。然后不确定哪个写访问是在该过程中实际产生影响的访问。好的做法是计算辅助变量中的输出变量，并在循环结束时将计算值分配到一个位置。 重要性：高 PLCopen规则：CP12 当输出变量 ( VAR_IN_OUT ) 被写入不同的分支 IF 和 CASE 陈述。 杂注不能禁用此规则。 例子 VAR_GLOBAL g_xVar AT %QX0.0 : BOOL ; g_iTest AT %QW0 : INT ; END_VAR PROGRAM PLC_PRG IF g_iCondition < INT#0 THEN g_xVa...", 
"body" : "检测写入多个位置的输出。 理由：当输出写入代码的不同位置时，可维护性会降低。然后不确定哪个写访问是在该过程中实际产生影响的访问。好的做法是计算辅助变量中的输出变量，并在循环结束时将计算值分配到一个位置。 重要性：高 PLCopen规则：CP12 当输出变量 ( VAR_IN_OUT ) 被写入不同的分支 IF 和 CASE 陈述。 杂注不能禁用此规则。 例子 VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW0 : INT ;\nEND_VAR PROGRAM PLC_PRG IF g_iCondition < INT#0 THEN\n g_xVar := TRUE;\n g_iTest := INT#12;\nEND_IF\n\nCASE g_iCondition OF\n INT#1:\n g_xVar := FALSE;\n INT#2:\n g_iTest := INT#11;\n ELSE\n g_xVar := TRUE;\n g_iTest := INT#9;\nEND_CASE\n 输出在 留言 看法： SA0004：对输出“%QX0.0”进行多次写入访问 SA0004：对输出“%QW0”进行多次写访问 " }, 
{ "title" : "SA0006：来自多个任务的写访问 ", 
"url" : "_san_rule_sa0006.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0006：来自多个任务的写访问 ", 
"snippet" : "检测由多个任务写入的变量。 理由：在多个任务中写入的变量可能会意外更改其值。这可能会导致混乱的情况。如果同时将变量写入两个任务，则字符串变量（在某些 32 位系统上还有 64 位整数变量）甚至会达到不一致的状态。 例外：在特定情况下，可能需要多个任务编写一个变量。例如，使用信号量来确保访问不会导致不一致的状态。 重要性：高 PLCopen规则：CP10 例子 VAR_GLOBAL g_iTemp1: INT; END_VAR PROGRAM PLC_PRG \/\/ Controlled by MainTask g_iTemp1 := g_iTemp1 + INT#2; PROGRAM PLC_P...", 
"body" : "检测由多个任务写入的变量。 理由：在多个任务中写入的变量可能会意外更改其值。这可能会导致混乱的情况。如果同时将变量写入两个任务，则字符串变量（在某些 32 位系统上还有 64 位整数变量）甚至会达到不一致的状态。 例外：在特定情况下，可能需要多个任务编写一个变量。例如，使用信号量来确保访问不会导致不一致的状态。 重要性：高 PLCopen规则：CP10 例子 VAR_GLOBAL\n g_iTemp1: INT;\nEND_VAR PROGRAM PLC_PRG \/\/ Controlled by MainTask\ng_iTemp1 := g_iTemp1 + INT#2;\n PROGRAM PLC_PRG_1 \/\/Controlled by SubTask\ng_iTemp1 := g_iTemp1 - INT#3; 输出在 留言 看法： SA0006：对任务 MainTask、SubTask 中的“g_iTemp1”进行并发写入访问 " }, 
{ "title" : "SA0007：常量上的地址运算符 ", 
"url" : "_san_rule_sa0007.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0007：常量上的地址运算符 ", 
"snippet" : "检测操作员所在的代码行 ADR 应用于一个常数 理由：使用指向常量变量的指针会覆盖 CONSTANT 变量的属性。可以通过指针更改变量，而无需编译器发出任何通知。 例外：在极少数情况下，将指向常量的指针传递给函数可能很有用。但是，您必须确保此函数不会更改传输的值。尽可能使用 VAR_IN_OUT CONSTANT . 重要性：高 当。。。的时候 替换常量 选项被选中 编译器选项 在项目设置中，标量常量（整数、 BOOL , REAL ）并发出编译错误。 （常量字符串、结构体和数组始终有一个地址。） 例子 PROGRAM PLC_PRG VAR CONSTANT c_iValue : INT :...", 
"body" : "检测操作员所在的代码行 ADR 应用于一个常数 理由：使用指向常量变量的指针会覆盖 CONSTANT 变量的属性。可以通过指针更改变量，而无需编译器发出任何通知。 例外：在极少数情况下，将指向常量的指针传递给函数可能很有用。但是，您必须确保此函数不会更改传输的值。尽可能使用 VAR_IN_OUT CONSTANT . 重要性：高 当。。。的时候 替换常量 选项被选中 编译器选项 在项目设置中，标量常量（整数、 BOOL , REAL ）并发出编译错误。 （常量字符串、结构体和数组始终有一个地址。） 例子 PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n poiValue : POINTER TO INT;\nEND_VAR\n poiValue := ADR(c_iValue); \/\/ SA0007 输出在 留言 看法： SA0007：常量变量“c_iValue”的地址 " }, 
{ "title" : "SA0008：检查子范围类型 ", 
"url" : "_san_rule_sa0008.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0008：检查子范围类型 ", 
"snippet" : "检测超出范围的子范围类型违规。编译器已经检查了分配的文字。分配常量时，值必须在定义的范围内。分配变量时，数据类型必须相同。 说明：如果使用子范围类型，则确保不退出此子范围。编译器仅针对常量分配检查这些类型的子范围违规。 重要性：低 不对 CFC 对象执行检查，因为代码结构不允许这样做。 例子 VAR_GLOBAL iVarGlob:INT; END_VAR PROGRAM PLC_PRG VAR iSubr1: INT (INT#1..INT#10); iSubr2: INT (INT#1..INT#1000); iCount: INT; by_SubType : BYTE (BYTE#0.....", 
"body" : "检测超出范围的子范围类型违规。编译器已经检查了分配的文字。分配常量时，值必须在定义的范围内。分配变量时，数据类型必须相同。 说明：如果使用子范围类型，则确保不退出此子范围。编译器仅针对常量分配检查这些类型的子范围违规。 重要性：低 不对 CFC 对象执行检查，因为代码结构不允许这样做。 例子 VAR_GLOBAL\n iVarGlob:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iSubr1: INT (INT#1..INT#10);\n iSubr2: INT (INT#1..INT#1000);\n iCount: INT;\n by_SubType : BYTE (BYTE#0..BYTE#11);\n iVar : INT (-4095..4095);\nEND_VAR\n iSubr1 := nCount; \/\/ SA0008\niSubr1 := subr2; \/\/ SA0008\niSubr1 := gvl.iVarGlob; \/\/ SA0008\n\/\/byBYTE_SubType := BYTE#123; \/\/already detected by compiler, error \"Cannot convert type...\" 输出在 留言 看法： SA0008：子范围变量“iSubr1”可能超出允许的范围 " }, 
{ "title" : "SA0009：未使用的返回值 ", 
"url" : "_san_rule_sa0009.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0009：未使用的返回值 ", 
"snippet" : "检测未使用返回值的函数、方法和属性调用 理由：当函数或方法返回返回值时，您也应该对其进行评估。返回值通常表明函数是否执行成功。如果没有评估，那么您稍后将无法识别返回值是否被遗忘或者是否实际上不需要。 例外：如果返回值与调用无关，那么您应该对此进行记录并省略赋值。错误返回永远不应该被忽略。 重要性：中等 PLCopen规则：CP7\/CP17 例子 FUNCTION Return_BOOL : BOOL VAR_INPUT END_VAR VAR    xTest : BOOL; END_VAR xTest := FALSE; Return_BOOL := xTest; PROGRAM PLC_P...", 
"body" : "检测未使用返回值的函数、方法和属性调用 理由：当函数或方法返回返回值时，您也应该对其进行评估。返回值通常表明函数是否执行成功。如果没有评估，那么您稍后将无法识别返回值是否被遗忘或者是否实际上不需要。 例外：如果返回值与调用无关，那么您应该对此进行记录并省略赋值。错误返回永远不应该被忽略。 重要性：中等 PLCopen规则：CP7\/CP17 例子 FUNCTION Return_BOOL : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n    xTest : BOOL;\nEND_VAR xTest := FALSE;\nReturn_BOOL := xTest; PROGRAM PLC_PRG\nReturn_BOOL();  \/\/ SA0009\n 输出在 留言 看法： SA0009：忽略“Return_BOOL”的返回值 " }, 
{ "title" : "SA0010：只有一个组件的数组 ", 
"url" : "_san_rule_sa0010.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0010：只有一个组件的数组 ", 
"snippet" : "检测只有一个元素的数组 理由：一个元素的数组可以被一个基本类型的变量替换。访问此变量比通过索引访问变量快得多。 例外：数组的长度通常由常量确定，并且是程序的参数。那么程序就可以处理不同长度的数组，并且如果长度仅为1则不必更改。这种情况应该相应地记录下来。 重要性：低 例子 PROGRAM PLC_PRG VAR aoiEmpty : ARRAY [22..22] OF INT := [22]; aorEmpty : ARRAY [2..2] OF REAL := [2.2]; iVar : INT; rVAR : REAL; END_VAR iVar := aoiEmpty[22]; rVAR...", 
"body" : "检测只有一个元素的数组 理由：一个元素的数组可以被一个基本类型的变量替换。访问此变量比通过索引访问变量快得多。 例外：数组的长度通常由常量确定，并且是程序的参数。那么程序就可以处理不同长度的数组，并且如果长度仅为1则不必更改。这种情况应该相应地记录下来。 重要性：低 例子 PROGRAM PLC_PRG\nVAR\n aoiEmpty : ARRAY [22..22] OF INT := [22];\n aorEmpty : ARRAY [2..2] OF REAL := [2.2];\n iVar : INT;\n rVAR : REAL;\nEND_VAR iVar := aoiEmpty[22];\nrVAR := aorEmpty[2];\n 输出在 留言 看法： SA0010：变量“aoiEmpty”中的空数组元素 SA0010：变量“aorEmpty”中的空数组元素 " }, 
{ "title" : "SA0011：只有一个成员的无用声明 ", 
"url" : "_san_rule_sa0011.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0011：只有一个成员的无用声明 ", 
"snippet" : "检测仅具有单个成员的结构或枚举 理由：不应声明只有一个成员的结构或枚举。此类声明可能会让读者感到困惑。只有一个元素的结构可以用别名类型替换。只有一个元素的枚举可以用常量替换。 PLCopen规则：CP22\/CP24 重要性：低 例子 {attribute 'qualified_only'} {attribute 'strict'} TYPE SINGLE_ENUM : ( OnlyOne := 1 ); END_TYPE TYPE SINGLE_UNION : UNION lrValue : LREAL; END_UNION END_TYPE {attribute 'qualified_onl...", 
"body" : "检测仅具有单个成员的结构或枚举 理由：不应声明只有一个成员的结构或枚举。此类声明可能会让读者感到困惑。只有一个元素的结构可以用别名类型替换。只有一个元素的枚举可以用常量替换。 PLCopen规则：CP22\/CP24 重要性：低 例子 {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE TYPE SINGLE_UNION :\nUNION\n\tlrValue : LREAL;\nEND_UNION\nEND_TYPE {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE 输出在 留言 看法： SA0011：无用声明“SINGLE_ENUM”：不应使用仅具有单个成员的结构\/枚举 SA0011：无用的声明“SINGLE_UNION”：不应使用仅具有单个成员的结构\/枚举 SA0011：无用的声明“SINGLE_STRUCT”：不应使用仅具有单个成员的结构\/枚举 " }, 
{ "title" : "SA0012：可以声明为常量的变量 ", 
"url" : "_san_rule_sa0012.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0012：可以声明为常量的变量 ", 
"snippet" : "检测未使用写权限访问的变量，因此可以声明为常量 理由：如果变量仅在声明点写入并且仅用于读取，则静态分析假定该变量也不应该被更改。首先，声明为常量会导致检查程序更改时变量是否未更改。其次，声明为常量可能会导致代码更快。 如果一个项目中存在多个应用程序，则仅影响当前活动应用程序下的对象。如果只有一个应用程序，那么公共 POU 池中的对象也会受到影响。 重要性：低 例子 PROGRAM PLC_PRG VAR iVar : INT := INT#17; iTest : INT; END_VAR iTest := iTest + iVar; \/\/ SA0012: 'iVar' could be dec...", 
"body" : "检测未使用写权限访问的变量，因此可以声明为常量 理由：如果变量仅在声明点写入并且仅用于读取，则静态分析假定该变量也不应该被更改。首先，声明为常量会导致检查程序更改时变量是否未更改。其次，声明为常量可能会导致代码更快。 如果一个项目中存在多个应用程序，则仅影响当前活动应用程序下的对象。如果只有一个应用程序，那么公共 POU 池中的对象也会受到影响。 重要性：低 例子 PROGRAM PLC_PRG\nVAR\n iVar : INT := INT#17;\n iTest : INT;\nEND_VAR\n iTest := iTest + iVar; \/\/ SA0012: 'iVar' could be declared as constant 输出在 留言 看法： SA0012：变量“iVar”可以声明为常量 " }, 
{ "title" : "SA0013：具有相同变量名的声明 ", 
"url" : "_san_rule_sa0013.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0013：具有相同变量名的声明 ", 
"snippet" : "检测名称已被其他变量使用的变量（例如，具有相同名称的全局变量和局部变量）。还可以检测其函数、操作、方法或属性名称在同一访问范围内使用的变量。还检测在 GVL 中声明的变量 设备 查看或在 POU 池中。然而，为此，GVL POU 视图必须在应用程序中使用。 说明：相同的名称在阅读代码时可能会造成混淆，如果无意中访问了错误的对象，它们可能会导致错误。我们建议您使用命名约定来避免这些情况。 PLCopen规则：N5 \/ N9 重要性：中等 例子 VAR_GLOBAL xVar1 : BOOL; iVar3 : INT; END_VAR PROGRAM PLC_PRG VAR xVar1 : BOO...", 
"body" : "检测名称已被其他变量使用的变量（例如，具有相同名称的全局变量和局部变量）。还可以检测其函数、操作、方法或属性名称在同一访问范围内使用的变量。还检测在 GVL 中声明的变量 设备 查看或在 POU 池中。然而，为此，GVL POU 视图必须在应用程序中使用。 说明：相同的名称在阅读代码时可能会造成混淆，如果无意中访问了错误的对象，它们可能会导致错误。我们建议您使用命名约定来避免这些情况。 PLCopen规则：N5 \/ N9 重要性：中等 例子 VAR_GLOBAL\n xVar1 : BOOL;\n iVar3 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n xVar1 : BOOL; \/\/ SA0013\n iVar3 : INT; \/\/ SA0013\nEND_VAR\n xVar1 := NOT GVL.xVar1;\niVar3 := iVar3 + INT#2;\niVar3 := GVL.iVar3; 输出在 留言 看法： SA0013：“iVar1”的声明隐藏了符号“GVL.iVar1” SA0013：“xVar3”的声明隐藏了符号“GVL.xVar3” 例子 这 FB_Pou 功能块有 ACT 行动, 的 METH 方法和具有相同名称的局部变量。 FUNCTION_BLOCK FB_Pou\nVAR\n ACT : UINT; \/\/ SA0013\n METH : BYTE; \/\/ SA0013\nEND_VAR PROGRAM PLC_PRG\nVAR\n fbPou : FB_Pou;\nEND_VAR\n fbPou(); 输出在 留言 看法： SA0013：“ACT”声明隐藏符号“FB_Pou.ACT” SA0013：“METH”的声明隐藏了符号“FB_Pou.METH” " }, 
{ "title" : "SA0014：实例分配 ", 
"url" : "_san_rule_sa0014.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0014：实例分配 ", 
"snippet" : "检测功能块实例的分配。在具有指针或引用变量的实例的情况下，这些赋值具有潜在的风险。 理由：这是一个性能警告。当一个实例分配给另一个实例时，所有元素和子元素都从一个实例复制到另一个实例。指向数据的指针也会被复制，但不会复制它们引用的数据，因此目标实例和源实例在赋值后包含相同的数据。根据实例的大小，这种分配可能会持续很长时间。例如，如果应该将一个实例传递给一个函数进行处理，那么传递一个指向该实例的指针会更有效率。 如果您想有选择地将值从一个实例复制到另一个实例，则复制方法很有用： inst_First.Copy_From(inst_Second) 重要性：中等 例子 PROGRAM PLC_PRG...", 
"body" : "检测功能块实例的分配。在具有指针或引用变量的实例的情况下，这些赋值具有潜在的风险。 理由：这是一个性能警告。当一个实例分配给另一个实例时，所有元素和子元素都从一个实例复制到另一个实例。指向数据的指针也会被复制，但不会复制它们引用的数据，因此目标实例和源实例在赋值后包含相同的数据。根据实例的大小，这种分配可能会持续很长时间。例如，如果应该将一个实例传递给一个函数进行处理，那么传递一个指向该实例的指针会更有效率。 如果您想有选择地将值从一个实例复制到另一个实例，则复制方法很有用： inst_First.Copy_From(inst_Second) 重要性：中等 例子 PROGRAM PLC_PRG\nVAR\n inst_First : My_FB;\n inst_Second : My_FB;\nEND_VAR\n inst_First();\ninst_Second := inst_First; \/\/ SA0014 输出在 留言 看法： SA0014：实例分配 " }, 
{ "title" : "SA0015：通过 FB_Init 访问全局数据 ", 
"url" : "_san_rule_sa0015.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0015：通过 FB_Init 访问全局数据 ", 
"snippet" : "通过方法检测功能块对全局变量的访问 FB_Init .此变量的值取决于初始化的顺序。 理由：根据 POU 实例的声明位置，如果违反规则，可能会访问未初始化的变量。 重要性：高 例子 VAR_GLOBAL g_xTest1 : BOOL; g_iTest3 : INT; END_VAR METHOD PUBLIC fb_init : BOOL VAR_INPUT (* If TRUE, the retain variables are initialized (warm start \/ cold start) *) bInitRetains : BOOL; (* If TRUE, the ins...", 
"body" : "通过方法检测功能块对全局变量的访问 FB_Init .此变量的值取决于初始化的顺序。 理由：根据 POU 实例的声明位置，如果违反规则，可能会访问未初始化的变量。 重要性：高 例子 VAR_GLOBAL\n g_xTest1 : BOOL;\n g_iTest3 : INT;\nEND_VAR METHOD PUBLIC fb_init : BOOL\nVAR_INPUT\n (* If TRUE, the retain variables are initialized (warm start \/ cold start) *)\n bInitRetains : BOOL; \n (* If TRUE, the instance afterwards gets moved into the copy code (online change) *)\n bInCopyCode : BOOL; \nEND_VAR\n g_xTest1 := NOT g_xTest1; \/\/ SA0015\ng_iTest3 := g_iTest3 + INT#1; \/\/ SA0015 输出在 留言 看法： SA0015：功能块“POU”的 FB_Init 方法访问全局数据 " }, 
{ "title" : "SA0016：结构中的间隙 ", 
"url" : "_san_rule_sa0016.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0016：结构中的间隙 ", 
"snippet" : "检测由当前设置的目标系统的对齐要求引起的结构或功能块中的间隙。如果可能，您应该通过使用结构元素或用虚拟元素填充它们来消除间隙。如果这是不可能的，那么您可以通过以下方式停用受影响结构的规则 analysis 语用。 说明：由于不同平台的对齐要求不同，这些结构在内存中可能会有不同的布局。然后代码可以根据平台执行不同的操作。 重要性：低 例子 TYPE Unpadded_Structure : STRUCT xTest : BOOL; iTest : INT; \/\/ SA0016 byTest : BYTE; wTest : WORD; END_STRUCT END_TYPE PROGRAM PLC...", 
"body" : "检测由当前设置的目标系统的对齐要求引起的结构或功能块中的间隙。如果可能，您应该通过使用结构元素或用虚拟元素填充它们来消除间隙。如果这是不可能的，那么您可以通过以下方式停用受影响结构的规则 analysis 语用。 说明：由于不同平台的对齐要求不同，这些结构在内存中可能会有不同的布局。然后代码可以根据平台执行不同的操作。 重要性：低 例子 TYPE Unpadded_Structure :\nSTRUCT\n xTest : BOOL;\n iTest : INT; \/\/ SA0016\n byTest : BYTE;\n wTest : WORD;\nEND_STRUCT\nEND_TYPE\n PROGRAM PLC_PRG\nVAR\n myStruct : Unpadded_Structure;\nEND_VAR\n myStruct.iTest := 0; 输出在 留言 看法： SA0016：必须填充结构“Unpadded_Structure”（pack-mode = 8） " }, 
{ "title" : "SA0017：对指针变量的异常赋值 ", 
"url" : "_san_rule_sa0017.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0017：对指针变量的异常赋值 ", 
"snippet" : "检测对既不是地址的指针的分配（ ADR 运算符、指针变量）或常量 0 理由：如果为指针分配的值不是有效地址，则指针的取消引用会导致“访问冲突异常”。 重要性：高 例子 PROGRAM PLC_PRG VAR pInt : POINTER TO INT; dwAddress : DWORD; END_VAR dwAddress := dwAddress + DWORD#1; pInt := dwAddress; \/\/ SA0017 输出在 留言 看法： SA0017：对指针变量的异常赋值...", 
"body" : "检测对既不是地址的指针的分配（ ADR 运算符、指针变量）或常量 0 理由：如果为指针分配的值不是有效地址，则指针的取消引用会导致“访问冲突异常”。 重要性：高 例子 PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n dwAddress : DWORD;\nEND_VAR\n dwAddress := dwAddress + DWORD#1;\npInt := dwAddress; \/\/ SA0017 输出在 留言 看法： SA0017：对指针变量的异常赋值 " }, 
{ "title" : "SA0018：异常位访问 ", 
"url" : "_san_rule_sa0018.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0018：异常位访问 ", 
"snippet" : "检测对有符号变量的位访问。但是，IEC 61131-3 标准只允许对位域进行位访问和位移操作。另请参阅严格的规则 SA0147 和 SA0148 . 另请参阅严格规则 SA0147 和 SA0148 。 理由：有符号数据类型不应用作位字段，反之亦然。 IEC 61131-3 标准不提供这种访问，因此您在编写可移植代码时应遵守此规则。 重要性：中等 标志枚举的例外：当一个枚举通过 {attribute 'flags'} pragma 属性 SA0018 不发出错误的位访问与 OR , AND 或者 NOT 运营商。 例子 PROGRAM PLC_PRG VAR iTemp1 : INT; diT...", 
"body" : "检测对有符号变量的位访问。但是，IEC 61131-3 标准只允许对位域进行位访问和位移操作。另请参阅严格的规则 SA0147 和 SA0148 . 另请参阅严格规则 SA0147 和 SA0148 。 理由：有符号数据类型不应用作位字段，反之亦然。 IEC 61131-3 标准不提供这种访问，因此您在编写可移植代码时应遵守此规则。 重要性：中等 标志枚举的例外：当一个枚举通过 {attribute 'flags'} pragma 属性 SA0018 不发出错误的位访问与 OR , AND 或者 NOT 运营商。 例子 PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/SA0018\ndiTemp3.4 := TRUE; \/\/SA0018\nuliTemp4.18 := FALSE; \/\/no error because this is an unsigned data type\nsiTemp5.2 := FALSE; \/\/SA0018\nusiTemp6.3 := TRUE; \/\/no error because this is an unsigned data type\nbyTemp2.5 := FALSE; \/\/no error because the byte is a bitfield 输出在 留言 看法： SA0018：异常位访问 " }, 
{ "title" : "SA0020：可能将截断的值分配给 REAL 变量 ", 
"url" : "_san_rule_sa0020.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0020：可能将截断的值分配给 REAL 变量 ", 
"snippet" : "检测对整数变量的操作，其截断值可以分配给 REAL 数据类型变量 理由：当整数计算的结果分配给一个 REAL 或者 LREAL 多变的。应该提醒程序员注意对这种赋值的可能错误解释： lrealvar := dintvar1 * dintvar2 . 因为取值范围 LREAL 大于 DINT ，可以假设计算的结果总是可以表示为 LREAL .但事实并非如此。处理器将乘法的结果计算为整数，然后将结果转换为 LREAL .整数计算中的溢出将丢失。为了解决这个问题，计算必须作为 REAL 手术： lreal_var := TO_LREAL(dintvar1) * TO_LREAL(dintvar2) ...", 
"body" : "检测对整数变量的操作，其截断值可以分配给 REAL 数据类型变量 理由：当整数计算的结果分配给一个 REAL 或者 LREAL 多变的。应该提醒程序员注意对这种赋值的可能错误解释： lrealvar := dintvar1 * dintvar2 . 因为取值范围 LREAL 大于 DINT ，可以假设计算的结果总是可以表示为 LREAL .但事实并非如此。处理器将乘法的结果计算为整数，然后将结果转换为 LREAL .整数计算中的溢出将丢失。为了解决这个问题，计算必须作为 REAL 手术： lreal_var := TO_LREAL(dintvar1) * TO_LREAL(dintvar2) . 重要性：高 例子 PROGRAM PLC_PRG\nVAR\n rX : LREAL;\n dI : DINT;\nEND_VAR\n rX := dI * dI \/\/ SA0020\nrX := TO_LREAL(dI) * TO_LREAL(dI) \/\/no message 输出在 留言 看法： SA0020：可能将截断值分配给 REAL 变量 " }, 
{ "title" : "SA0021：传输临时变量的地址 ", 
"url" : "_san_rule_sa0021.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0021：传输临时变量的地址 ", 
"snippet" : "检测临时变量（在堆栈上）到非临时变量的地址分配 理由：函数或方法的局部变量是在堆栈上创建的，它们仅在处理函数或方法时才存在。如果一个指针在处理完方法或函数后指向这种变量，那么你可以使用这个指针访问未定义的内存，或者访问另一个函数中不正确的变量。应不惜一切代价避免这种情况。 重要性：高 例子 FUNCTION TempVarInFUNC : DWORD VAR uiTemp : UINT; END_VAR TempVarInFUNC := ADR(uiTemp); \/\/SA0021 PROGRAM PLC_PRG VAR dwTest : DWORD; END_VAR dwTest := Tem...", 
"body" : "检测临时变量（在堆栈上）到非临时变量的地址分配 理由：函数或方法的局部变量是在堆栈上创建的，它们仅在处理函数或方法时才存在。如果一个指针在处理完方法或函数后指向这种变量，那么你可以使用这个指针访问未定义的内存，或者访问另一个函数中不正确的变量。应不惜一切代价避免这种情况。 重要性：高 例子 FUNCTION TempVarInFUNC : DWORD\nVAR\n uiTemp : UINT;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0021 PROGRAM PLC_PRG\nVAR\n dwTest : DWORD;\nEND_VAR dwTest := TempVarInFUNC(); 输出在 留言 看法： SA0021：将临时变量的地址传输到外部作用域符号 " }, 
{ "title" : "SA0022：（可能）未分配的返回值 ", 
"url" : "_san_rule_sa0022.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0022：（可能）未分配的返回值 ", 
"snippet" : "检测所有包含执行线程但未分配返回值的函数和方法 理由：函数或方法中未分配的返回值表示缺少代码。即使返回值总是有一个默认值，再次显式分配它以避免混淆总是有用的。 重要性：中等 例子 FUNCTION FUN : DINT VAR_INPUT bTest : BOOL; END_VAR IF bTest THEN RETURN; END_IF FUN := 99; 输出在 留言 看法： SA0022：（可能）未分配的返回值...", 
"body" : "检测所有包含执行线程但未分配返回值的函数和方法 理由：函数或方法中未分配的返回值表示缺少代码。即使返回值总是有一个默认值，再次显式分配它以避免混淆总是有用的。 重要性：中等 例子 FUNCTION FUN : DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR\n IF bTest THEN\n RETURN;\nEND_IF\nFUN := 99; 输出在 留言 看法： SA0022：（可能）未分配的返回值 " }, 
{ "title" : "SA0023：复杂的返回值 ", 
"url" : "_san_rule_sa0023.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0023：复杂的返回值 ", 
"snippet" : "确定无法使用处理器的简单注册表副本返回的复杂返回值。这包括结构、数组和类型的返回值 STRING （不管已用内存的大小）。 理由：这是一个性能警告。如果函数、方法或属性的结果返回较大的值，则处理器在执行代码时会多次复制它们。这可能会导致运行时问题，应尽可能避免。可以通过传递结构化值来提高性能 VAR_IN_OUT 到一个函数或方法并将其填充到该函数或方法中。 重要性：中等 例子 TYPE LargeStructure : STRUCT a : LINT; b : BOOL; END_STRUCT END_TYPE FUNCTION Large_Return_Value_FUNC : Large...", 
"body" : "确定无法使用处理器的简单注册表副本返回的复杂返回值。这包括结构、数组和类型的返回值 STRING （不管已用内存的大小）。 理由：这是一个性能警告。如果函数、方法或属性的结果返回较大的值，则处理器在执行代码时会多次复制它们。这可能会导致运行时问题，应尽可能避免。可以通过传递结构化值来提高性能 VAR_IN_OUT 到一个函数或方法并将其填充到该函数或方法中。 重要性：中等 例子 TYPE LargeStructure :\nSTRUCT\n a : LINT;\n b : BOOL;\nEND_STRUCT\nEND_TYPE\n FUNCTION Large_Return_Value_FUNC : LargeStructure \/\/ SA0023 输出在 留言 看法： SA0023：复杂返回值 " }, 
{ "title" : "SA0024：无类型文字\/常量 ", 
"url" : "_san_rule_sa0024.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0024：无类型文字\/常量 ", 
"snippet" : "标识属于操作一部分的无类型文字 理由：无类型文字会根据其用法自动类型化。在某些情况下，例如 dw := ROL(DWORD#1, i); ，这可能会导致意外的情况，最好使用类型化文字来提供独特的说明。 重要性：低 例子 PROGRAM PLC_PRG VAR iTemp1 : INT := 10; \/\/no part of operation diTemp2 : DINT; liTemp3 : LINT; rTemp4 : REAL; lrTemp5 : LREAL; END_VAR iTemp1 := iTemp1 + INT#34; diTemp2 := diTemp2 + 23; \/\/ ...", 
"body" : "标识属于操作一部分的无类型文字 理由：无类型文字会根据其用法自动类型化。在某些情况下，例如 dw := ROL(DWORD#1, i); ，这可能会导致意外的情况，最好使用类型化文字来提供独特的说明。 重要性：低 例子 PROGRAM PLC_PRG\nVAR\n iTemp1 : INT := 10; \/\/no part of operation\n diTemp2 : DINT;\n liTemp3 : LINT;\n rTemp4 : REAL;\n lrTemp5 : LREAL;\n END_VAR iTemp1 := iTemp1 + INT#34;\ndiTemp2 := diTemp2 + 23; \/\/ SA0024\nliTemp3 := liTemp3 + 124; \/\/ SA0024\nrTemp4 := rTemp4 + 1.1; \/\/ SA0024\nlrTemp5 := lrTemp5 + 3.4; \/\/ SA0024\n 输出在 留言 看法： SA0024：找到非类型化文字 " }, 
{ "title" : "SA0025：不合格的枚举常量 ", 
"url" : "_san_rule_sa0025.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0025：不合格的枚举常量 ", 
"snippet" : "检测限定名称未在枚举前面添加的枚举常量 理由：合格的访问使代码更具可读性且更易于维护。如果不强制使用限定变量名，则可以在扩展程序时插入附加枚举。该枚举包含一个与现有枚举同名的常量（参见下面的示例：“red”）。这将导致对这段代码的访问不明确。 在每种情况下，我们建议仅使用带有编译指示的枚举 {attribute 'qualified-only'} 。 重要性：中等 例子 TYPE COLOR : (red, green, blue); END_TYPE PROGRAM PLC_PRG VAR myColor : COLOR; END_VAR myColor := COLOR.red; \/\/ O...", 
"body" : "检测限定名称未在枚举前面添加的枚举常量 理由：合格的访问使代码更具可读性且更易于维护。如果不强制使用限定变量名，则可以在扩展程序时插入附加枚举。该枚举包含一个与现有枚举同名的常量（参见下面的示例：“red”）。这将导致对这段代码的访问不明确。 在每种情况下，我们建议仅使用带有编译指示的枚举 {attribute 'qualified-only'} 。 重要性：中等 例子 TYPE COLOR :\n (red,\n green,\n blue);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n myColor : COLOR;\nEND_VAR\n myColor := COLOR.red; \/\/ OK\nmyColor := red; \/\/ SA0025 输出在 留言 看法： SA0025：枚举常量“红色”不合格 也可以看看 配置和运行静态分析 " }, 
{ "title" : "SA0026: 可能的截断字符串 ", 
"url" : "_san_rule_sa0026.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0026: 可能的截断字符串 ", 
"snippet" : "检测未使用足够字符串长度的字符串分配和字符串初始化 理由：当分配不同长度的字符串时，字符串可能会被截断。这可能会产生意想不到的结果。 重要性：中等 例子 PROGRAM PLC_PRG VAR strVar1 : STRING[10]; strVar2 : STRING[6]; strVar3 : STRING[6] := 'abcdefghi'; \/\/ SA0026 END_VAR strVar2 := strVar1; \/\/ SA0026 输出在 留言 看法： SA0026：“abcdefghi”的截断 SA0026：字符串“strVar1”可能被截断 有关更多信息，请参阅： 配置和运行静...", 
"body" : "检测未使用足够字符串长度的字符串分配和字符串初始化 理由：当分配不同长度的字符串时，字符串可能会被截断。这可能会产生意想不到的结果。 重要性：中等 例子 PROGRAM PLC_PRG\nVAR\n strVar1 : STRING[10];\n strVar2 : STRING[6];\n strVar3 : STRING[6] := 'abcdefghi'; \/\/ SA0026\nEND_VAR\n strVar2 := strVar1; \/\/ SA0026 输出在 留言 看法： SA0026：“abcdefghi”的截断 SA0026：字符串“strVar1”可能被截断 有关更多信息，请参阅： 配置和运行静态分析 " }, 
{ "title" : "SA0027：标识符的多种用途 ", 
"url" : "_san_rule_sa0027.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0027：标识符的多种用途 ", 
"snippet" : "检测项目范围内变量或对象 (POU) 的名称\/标识符的多次使用。 对于枚举，将考虑限定名称。 理由：阅读代码时，相同的名称可能会造成混淆。如果意外访问了错误的对象，它们可能会导致错误。定义并遵循命名约定以避免出现此类情况。 检测到以下情况： 枚举的名称与应用程序或集成库中的另一个枚举的名称相同。 变量的名称与应用程序或集成库中的另一个对象的名称相同。 变量的名称与应用程序或集成库中的枚举中的枚举常量的名称相同。 对象的名称与应用程序或集成库中的另一个对象的名称相同。 重要性：中等 例子 TYPE COLOR : ( red, green, blue ); END_TYPE PROGRAM PL...", 
"body" : "检测项目范围内变量或对象 (POU) 的名称\/标识符的多次使用。 对于枚举，将考虑限定名称。 理由：阅读代码时，相同的名称可能会造成混淆。如果意外访问了错误的对象，它们可能会导致错误。定义并遵循命名约定以避免出现此类情况。 检测到以下情况： 枚举的名称与应用程序或集成库中的另一个枚举的名称相同。 变量的名称与应用程序或集成库中的另一个对象的名称相同。 变量的名称与应用程序或集成库中的枚举中的枚举常量的名称相同。 对象的名称与应用程序或集成库中的另一个对象的名称相同。 重要性：中等 例子 TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n color : INT;\nEND_VAR\n 输出在 留言 看法： SA0027：“PLC_PRG”中的变量名称“颜色”已用于此应用程序中的对象 有关更多信息，请参阅： 配置和运行静态分析 " }, 
{ "title" : "SA0028：重叠的内存区域 ", 
"url" : "_san_rule_sa0028.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0028：重叠的内存区域 ", 
"snippet" : "检测两个或多个变量保留相同内存的代码行。 理由：当两个变量保留相同的内存时，代码可能会出现意外的结果。应不惜一切代价避免这种情况。如果您无法避免在不同的解释中使用某个值（例如，一次作为 DINT 还有一次作为 REAL ），那么你应该定义一个 UNION 。您还可以使用指针访问不同类型的值，而无需转换该值。 重要性：高 例子 PROGRAM PLC_PRG VAR iVvar1 AT %QB21: INT; dwVar2 AT %QD5: DWORD; END_VAR 输出在 留言 看法： 以下变量访问同一内存： SA0028：iVar1 AT %QB21 SA0028：dwVar2 AT %...", 
"body" : "检测两个或多个变量保留相同内存的代码行。 理由：当两个变量保留相同的内存时，代码可能会出现意外的结果。应不惜一切代价避免这种情况。如果您无法避免在不同的解释中使用某个值（例如，一次作为 DINT 还有一次作为 REAL ），那么你应该定义一个 UNION 。您还可以使用指针访问不同类型的值，而无需转换该值。 重要性：高 例子 PROGRAM PLC_PRG\nVAR\n iVvar1 AT %QB21: INT;\n dwVar2 AT %QD5: DWORD;\nEND_VAR\n 输出在 留言 看法： 以下变量访问同一内存： SA0028：iVar1 AT %QB21 SA0028：dwVar2 AT %QD5 有关更多信息，请参阅： 配置和运行静态分析 " }, 
{ "title" : "SA0029：代码中的符号与声明不同 ", 
"url" : "_san_rule_sa0029.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0029：代码中的符号与声明不同 ", 
"snippet" : "检测标识符的符号与其声明中的符号不同的代码位置 理由：IEC 61131-3 标准将标识符定义为不区分大小写。这意味着变量声明为“ varx “也可以用作” VaRx ” 在代码中。但是，这是令人困惑和误导的，应该避免。 重要性：中等 例子 一个 PLC_PRG POU 和一个 fnc (函数) POU 存在于设备树中。 PROGRAM PLC_PRG VAR iVar: INT; _123test_var_: INT; END_VAR ivar := iVar + 1; \/\/ SA0029 _123TEST_var_ := _123test_var_; \/\/ SA0029 Fnc(); \/\/...", 
"body" : "检测标识符的符号与其声明中的符号不同的代码位置 理由：IEC 61131-3 标准将标识符定义为不区分大小写。这意味着变量声明为“ varx “也可以用作” VaRx ” 在代码中。但是，这是令人困惑和误导的，应该避免。 重要性：中等 例子 一个 PLC_PRG POU 和一个 fnc (函数) POU 存在于设备树中。 PROGRAM PLC_PRG\nVAR\n iVar: INT;\n _123test_var_: INT;\nEND_VAR\n ivar := iVar + 1; \/\/ SA0029\n_123TEST_var_ := _123test_var_; \/\/ SA0029\nFnc(); \/\/ SA0029 输出在 留言 看法： SA0029：代码中的符号 (ivar) 必须等于声明 (iVar) SA0029：代码中的符号 (_123TEST_var_) 必须等于声明 (_123test_var_) SA0029：代码中的符号 (Fnc) 必须等于声明 (fnc) 有关更多信息，请参阅： 配置和运行静态分析 " }, 
{ "title" : "未使用的对象 ", 
"url" : "_san_list_unused_objects.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 未使用的对象 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0031：未使用的签名 ", 
"url" : "_san_rule_sa0031.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 未使用的对象 \/ SA0031：未使用的签名 ", 
"snippet" : "检测编译程序代码中未调用的程序、功能块、函数、数据类型、接口、方法、属性和动作 理由：未使用的对象不必要地增加了项目的大小，并且在阅读代码时可能会造成混淆。 重要性：低 PLCopen 规则：CP2 如果一个项目中存在多个应用程序，则仅影响当前活动应用程序下方的对象。如果只有一个应用程序，那么 POU 池中的对象也会受到影响。 也可以看看 配置和运行静态分析...", 
"body" : "检测编译程序代码中未调用的程序、功能块、函数、数据类型、接口、方法、属性和动作 理由：未使用的对象不必要地增加了项目的大小，并且在阅读代码时可能会造成混淆。 重要性：低 PLCopen 规则：CP2 如果一个项目中存在多个应用程序，则仅影响当前活动应用程序下方的对象。如果只有一个应用程序，那么 POU 池中的对象也会受到影响。 也可以看看 配置和运行静态分析 " }, 
{ "title" : "SA0032：未使用的枚举常量 ", 
"url" : "_san_rule_sa0032.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 未使用的对象 \/ SA0032：未使用的枚举常量 ", 
"snippet" : "检测编译程序代码中未使用的枚举常量 理由：未使用的枚举常量不必要地增加了枚举定义的大小，并且在阅读程序时可能会造成混淆。 PLCopen规则：CP24 重要性：低 如果一个项目中存在多个应用程序，则仅影响当前活动应用程序下方的对象。如果只有一个应用程序，那么公共 POU 池中的对象也会受到影响。 例子 TYPE My_Enum : ( one := 1, two := 2 ); END_TYPE 输出在 留言 看法： SA0032：未使用的枚举常量“one” SA0032：未使用的枚举常量“二” 有关更多信息，请参阅： 配置和运行静态分析...", 
"body" : "检测编译程序代码中未使用的枚举常量 理由：未使用的枚举常量不必要地增加了枚举定义的大小，并且在阅读程序时可能会造成混淆。 PLCopen规则：CP24 重要性：低 如果一个项目中存在多个应用程序，则仅影响当前活动应用程序下方的对象。如果只有一个应用程序，那么公共 POU 池中的对象也会受到影响。 例子 TYPE My_Enum :\n(\n one := 1, \n two := 2\n);\nEND_TYPE\n 输出在 留言 看法： SA0032：未使用的枚举常量“one” SA0032：未使用的枚举常量“二” 有关更多信息，请参阅： 配置和运行静态分析 " }, 
{ "title" : "SA0033：未使用的变量 ", 
"url" : "_san_rule_sa0033.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 未使用的对象 \/ SA0033：未使用的变量 ", 
"snippet" : "检测已声明但未在已编译程序代码中使用的变量 理由：未使用的变量使程序的可读性和可维护性降低。未使用的变量不必要地填充内存并在初始化期间不必要地浪费运行时间。 重要性：中等 PLCopen规则：CP22\/CP24 对于 GVL 变量：如果一个项目中存在多个应用程序，则仅考虑当前活动应用程序下方的对象。如果只有一个应用程序，则还会考虑公共 POU 池中的对象 例子 PROGRAM PLC_PRG VAR iCounter1 : INT; iCounter2 : INT; \/\/ SA0033 END_VAR iCounter1 := 100; 输出在 留言 看法： SA0033：未使用的变量 'iC...", 
"body" : "检测已声明但未在已编译程序代码中使用的变量 理由：未使用的变量使程序的可读性和可维护性降低。未使用的变量不必要地填充内存并在初始化期间不必要地浪费运行时间。 重要性：中等 PLCopen规则：CP22\/CP24 对于 GVL 变量：如果一个项目中存在多个应用程序，则仅考虑当前活动应用程序下方的对象。如果只有一个应用程序，则还会考虑公共 POU 池中的对象 例子 PROGRAM PLC_PRG\nVAR\n iCounter1 : INT;\n iCounter2 : INT; \/\/ SA0033\nEND_VAR\n iCounter1 := 100; 输出在 留言 看法： SA0033：未使用的变量 'iCounter2' 有关更多信息，请参阅： 配置和运行静态分析 " }, 
{ "title" : "SA0035：未使用的输入变量 ", 
"url" : "_san_rule_sa0035.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 未使用的对象 \/ SA0035：未使用的输入变量 ", 
"snippet" : "检测未被任何功能块实例使用的输入变量 理由：未使用的输入变量会降低程序的可读性和可维护性。未使用的变量会不必要地填充内存，并在初始化期间不必要地浪费运行时间。 只有在函数块实例本身的实现（或方法）中主动引用输入时，才会认为使用该输入。 重要性：中等 PLCopen规则：CP24 例子 FUNCTION_BLOCK FB_Afb VAR_INPUT iIn1: INT; iIn2: INT; END_VAR VAR_OUTPUT iOut1: INT; END_VAR iOut1 := iIn1; \/\/ iIn1 is used here PROGRAM PLC_PRG VAR fbAfb: F...", 
"body" : "检测未被任何功能块实例使用的输入变量 理由：未使用的输入变量会降低程序的可读性和可维护性。未使用的变量会不必要地填充内存，并在初始化期间不必要地浪费运行时间。 只有在函数块实例本身的实现（或方法）中主动引用输入时，才会认为使用该输入。 重要性：中等 PLCopen规则：CP24 例子 FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\nEND_VAR iOut1 := iIn1; \/\/ iIn1 is used here PROGRAM PLC_PRG\nVAR\n fbAfb: FB_Afb;\nEND_VAR\n fbAfb(iIn2 := 99); \/\/ iIn2 is unused internally => error 输出在 留言 看法： SA0035：未使用的输入“iIn2” " }, 
{ "title" : "SA0036：未使用的输出变量 ", 
"url" : "_san_rule_sa0036.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 未使用的对象 \/ SA0036：未使用的输出变量 ", 
"snippet" : "确定未在相关功能或功能块内分配的功能和功能块的输出变量。 理由：未使用的变量使程序的可读性和可维护性降低。未使用的变量不必要地填充内存并在初始化期间不必要地浪费运行时间。 重要性：中等 PLCopen规则：CP24 例子 FUNCTION_BLOCK FB_Afb VAR_INPUT iIn1: INT; iIn2: INT; END_VAR VAR_OUTPUT iOut1: INT; iOut2: INT; END_VAR iOut1 := iIn1 + iIn2; 输出在 留言 看法： SA0036：未使用的输出“iOut1”...", 
"body" : "确定未在相关功能或功能块内分配的功能和功能块的输出变量。 理由：未使用的变量使程序的可读性和可维护性降低。未使用的变量不必要地填充内存并在初始化期间不必要地浪费运行时间。 重要性：中等 PLCopen规则：CP24 例子 FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\n iOut2: INT;\nEND_VAR\n iOut1 := iIn1 + iIn2; 输出在 留言 看法： SA0036：未使用的输出“iOut1” " }, 
{ "title" : "SA0034：分配不正确的枚举 ", 
"url" : "_san_rule_sa0034.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0034：分配不正确的枚举 ", 
"snippet" : "检测分配给枚举变量的值。仅允许分配枚举变量的已定义枚举常量。 理由：枚举类型的变量应该只具有预期的值，否则使用该变量的代码可能无法正常工作。我们建议始终将枚举与 pragma 一起使用 {attribute 'strict'} 。然后编译器已经检查了枚举组件的正确使用。 重要性：高 例子 TYPE COLOR : ( Red := 0, Green, Yellow ); END_TYPE PROGRAM PLC_PRG VAR eColor1: COLOR; END_VAR eColor1 := COLOR.Red; eColor1 := 1; \/\/ SA0034 输出在 留言 看法： SA0...", 
"body" : "检测分配给枚举变量的值。仅允许分配枚举变量的已定义枚举常量。 理由：枚举类型的变量应该只具有预期的值，否则使用该变量的代码可能无法正常工作。我们建议始终将枚举与 pragma 一起使用 {attribute 'strict'} 。然后编译器已经检查了枚举组件的正确使用。 重要性：高 例子 TYPE COLOR :\n(\n Red := 0,\n Green,\n Yellow\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n eColor1: COLOR;\nEND_VAR\n eColor1 := COLOR.Red;\neColor1 := 1; \/\/ SA0034 输出在 留言 看法： SA0034：使用枚举值而不是“INT#1” 有关更多信息，请参阅： 配置和运行静态分析 " }, 
{ "title" : "SA0037: 对输入变量的写访问 ", 
"url" : "_san_rule_sa0037.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0037: 对输入变量的写访问 ", 
"snippet" : "检测输入变量（ VAR_INPUT ) 可以通过 POU 内的写权限进行访问 理由：根据 IEC 61131-3 标准，输入变量不得在 POU 内更改。这种访问也是导致错误的原因，并使代码难以维护。这表明变量既用作输入变量又用作辅助变量。应该避免这种双重用途。 重要性：中等 例子 VAR_GLOBAL g_xGlob AT %QX0.0 : BOOL; END_VAR PROGRAM PLC_PRG VAR_INPUT xVarIn1 : BOOL; xVarIn2 : BOOL; END_VAR VAR iCondition : INT; END_VAR iCondition := iCon...", 
"body" : "检测输入变量（ VAR_INPUT ) 可以通过 POU 内的写权限进行访问 理由：根据 IEC 61131-3 标准，输入变量不得在 POU 内更改。这种访问也是导致错误的原因，并使代码难以维护。这表明变量既用作输入变量又用作辅助变量。应该避免这种双重用途。 重要性：中等 例子 VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL;\nEND_VAR PROGRAM PLC_PRG\nVAR_INPUT\n xVarIn1 : BOOL;\n xVarIn2 : BOOL;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_xGlob := xVarIn1;\n INT#2:\n g_xGlob := xVarIn2;\n ELSE\n g_xGlob := FALSE;\n xVarIn1 := FALSE; \/\/ SA0037\nEND_CASE 输出在 留言 看法： SA0037：对输入变量“xVarIn1”的写访问 " }, 
{ "title" : "SA0038: 对输出变量的读访问 ", 
"url" : "_san_rule_sa0038.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0038: 对输出变量的读访问 ", 
"snippet" : "检测输出变量（ VAR_OUTPUT ) 可以通过 POU 内的读取权限进行访问 理由：根据 IEC 61131-3 标准，禁止读取 POU 内的输出。这表明输出不仅用作输出，而且还用作中间结果的临时变量。应该避免这种双重用途。 重要性：低 例子 VAR_GLOBAL g_xGlob AT %QX0.0 : BOOL ; g_iGlob AT %QW1 : INT ; END_VAR PROGRAM PLC_PRG VAR_OUTPUT xVarOut1:BOOL; xVarOut2:INT; xVarOut3:INT; END_VAR VAR iCondition : INT; END_VA...", 
"body" : "检测输出变量（ VAR_OUTPUT ) 可以通过 POU 内的读取权限进行访问 理由：根据 IEC 61131-3 标准，禁止读取 POU 内的输出。这表明输出不仅用作输出，而且还用作中间结果的临时变量。应该避免这种双重用途。 重要性：低 例子 VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL ;\n g_iGlob AT %QW1 : INT ;\nEND_VAR PROGRAM PLC_PRG\nVAR_OUTPUT\n xVarOut1:BOOL;\n xVarOut2:INT;\n xVarOut3:INT;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n xVarOut1 := g_xGlob;\n xVarOut2 := g_iGlob;\n INT#2:\n xVarOut3 := xVarOut2; \/\/ SA0038\n ELSE\n xVarOut1 := FALSE;\n g_xGlob := xVarOut1; \/\/ SA0038\n xVarOut2 := INT#0;\n xVarOut3 := INT#-1;\nEND_CASE 输出在 留言 看法： SA0038：对输出变量“xVarOUT2”的读取访问 SA0026：SA0038：对输出变量“xVarOUT1”的读取访问 " }, 
{ "title" : "SA0040：可能被零除 ", 
"url" : "_san_rule_sa0040.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0040：可能被零除 ", 
"snippet" : "检测可能被零除的代码位置 理由：除以 0 导致错误。应始终首先检查要除法的变量是否为 0。 重要性：高 例子 VAR_GLOBAL g_iVar AT %QW1 : INT; END_VAR PROGRAM PLC_PRG VAR iCounter : INT; iSumme:INT; iMid:INT; iVal1:INT := INT#2; iVal2:INT; iVal3:INT := INT#3; iVal4:INT := INT#4; iVal5:INT; END_VAR IF iVal2 <> 0 THEN iVal1 := iVal1\/iVal2; \/\/ no error END...", 
"body" : "检测可能被零除的代码位置 理由：除以 0 导致错误。应始终首先检查要除法的变量是否为 0。 重要性：高 例子 VAR_GLOBAL\n g_iVar AT %QW1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n iSumme:INT;\n iMid:INT;\n iVal1:INT := INT#2;\n iVal2:INT;\n iVal3:INT := INT#3;\n iVal4:INT := INT#4;\n iVal5:INT;\nEND_VAR IF iVal2 <> 0 THEN\n iVal1 := iVal1\/iVal2; \/\/ no error\nEND_IF;\niMid := iSumme \/ iCounter; \/\/ SA0040\niCounter := iCounter + INT#1;\niSumme := g_iVar + iSumme;\nIF iMid < INT#100 THEN\n iVal1 := iVal1 \/ iVal2; \/\/ SA0040\nEND_IF 输出在 留言 看法： SA0040：可能被零除 SA0040：可能被零除 " }, 
{ "title" : "SA0041：检测可能的循环不变代码 ", 
"url" : "_san_rule_sa0041.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0041：检测可能的循环不变代码 ", 
"snippet" : "检测循环中为每个循环周期计算相同值的分配。这些代码行可以插入到循环之外。 理由：这是一个性能警告。在循环中执行但在每个循环中执行相同操作的代码可以在循环外执行。 重要性：中等 例子 PROGRAM PLC_PRG VAR iCounter, iVar1, iVar2 : INT; END_VAR FOR iCounter := 0 TO 10 DO iVar1 := 100; \/\/ SA0041 iVar2 := iVar2 + iVar1; END_FOR 输出在 留言 看法： SAN0041：可能的循环不变代码“iVar1：= 100”...", 
"body" : "检测循环中为每个循环周期计算相同值的分配。这些代码行可以插入到循环之外。 理由：这是一个性能警告。在循环中执行但在每个循环中执行相同操作的代码可以在循环外执行。 重要性：中等 例子 PROGRAM PLC_PRG\nVAR\n iCounter, iVar1, iVar2 : INT;\nEND_VAR FOR iCounter := 0 TO 10 DO\n iVar1 := 100; \/\/ SA0041\n iVar2 := iVar2 + iVar1;\nEND_FOR\n 输出在 留言 看法： SAN0041：可能的循环不变代码“iVar1：= 100” " }, 
{ "title" : "SA0042：使用不同的访问路径 ", 
"url" : "_san_rule_sa0042.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0042：使用不同的访问路径 ", 
"snippet" : "检测同一变量的不同访问路径的使用情况 理由：对同一元素的不同访问会降低程序的可读性和可维护性。我们建议一致使用 {attribute 'qualified-only'} 用于库、全局变量列表和枚举。这会强制进行完全限定的访问。 重要性：低 例子 VAR_GLOBAL iTemp:INT; instPOU:POU; END_VAR FUNCTION_BLOCK POU VAR a:INT; END_VAR a := INT#1; PROGRAM SA0042 VAR ptiTemp:POINTER TO INT; sTemp:STRING; END_VAR ptiTemp := ADR(iTem...", 
"body" : "检测同一变量的不同访问路径的使用情况 理由：对同一元素的不同访问会降低程序的可读性和可维护性。我们建议一致使用 {attribute 'qualified-only'} 用于库、全局变量列表和枚举。这会强制进行完全限定的访问。 重要性：低 例子 VAR_GLOBAL\n iTemp:INT;\n instPOU:POU;\nEND_VAR FUNCTION_BLOCK POU\nVAR\n a:INT;\nEND_VAR\n a := INT#1; PROGRAM SA0042\nVAR\n ptiTemp:POINTER TO INT;\n sTemp:STRING;\nEND_VAR ptiTemp := ADR(iTemp);\n\nptiTemp^ := INT#1;\niTemp := INT#2; \/\/ SA0042 - direct access on variable\nGVL.iTemp := INT#3; \/\/ SA0042 - access on variable via GVL\n\nsTemp := CONCAT( 'ab', 'cd'); \/\/ SA0042 - direct access on function\nsTemp := Standard.CONCAT( 'ab', 'cd'); \/\/ SA0042 - access on function via Standard\n\ninstPOU(); \/\/ SA0042 - direct access on POU instance\nGVL.instPOU(); \/\/ SA0042 - access via GVL\n 输出在 留言 看法： SA0042：“CONCAT”的不同访问路径 SA0042：“Standard.CONCAT”的不同访问路径 SA0042：“instPOU”的不同访问路径 SA0042：“GVL.instPOU”的不同访问路径 SA0042：“iTemp”的不同访问路径 SA0042：“GVL.iTemp”的不同访问路径 " }, 
{ "title" : "SA0043：仅在一个 POU 中使用全局变量 ", 
"url" : "_san_rule_sa0043.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0043：仅在一个 POU 中使用全局变量 ", 
"snippet" : "仅在单个 POU 中检测全局变量的使用 理由：仅在一个位置使用的全局变量也只能在该位置声明。 重要性：中等 PLCopen规则：CP26 例子 VAR_GLOBAL g_xVar AT %QX0.0 : BOOL ; g_iTest AT %QW1 : INT ; g_wTest AT %QW2 : WORD; END_VAR PROGRAM prog1 VAR iCondition : INT; bTemp : BOOL; END_VAR iCondition := iCondition + INT#1; IF iCondition < INT#0 THEN bTemp := g_xVar;...", 
"body" : "仅在单个 POU 中检测全局变量的使用 理由：仅在一个位置使用的全局变量也只能在该位置声明。 重要性：中等 PLCopen规则：CP26 例子 VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW1 : INT ;\n g_wTest AT %QW2 : WORD;\nEND_VAR PROGRAM prog1\nVAR\n iCondition : INT;\n bTemp : BOOL;\nEND_VAR\n iCondition := iCondition + INT#1;\nIF iCondition < INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n ELSIF iCondition = INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\nELSE\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n g_wTest := WORD#4; \/\/ g_WTest used also in prog2 -> OK\nEND_IF PROGRAM prog2\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_iTest := WORD_TO_INT(g_wTest); \/\/ SA0043 - g_iTest only written in this POU\n INT#2:\n g_iTest := INT#2; \/\/ SA0043 - g_iTest only written in this POU\n ELSE\n g_iTest := INT#3; \/\/ SA0043 - g_iTest only written in this POU\nEND_CASE 输出在 留言 看法： SA0043：全局变量“g_xVar”仅在“prog1”中使用 SA0043：全局变量“g_iTest”仅在“prog2”中使用 " }, 
{ "title" : "SA0044：关于接口的声明 ", 
"url" : "_san_rule_sa0044.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0044：关于接口的声明 ", 
"snippet" : "检测声明 REFERENCE TO 接口和声明 VAR_IN_OUT 带接口的变量（通过 REFERENCE TO ) 理由：接口类型总是隐含地引用实现该接口的功能块实例。因此，对接口的引用就是对引用的引用，并且可能导致不需要的行为。 重要性：高 例子 ITF 是在项目中定义的接口。 FUNCTION_BLOCK POU VAR_INPUT inst_itf2 : ITF; END_VAR VAR_OUTPUT inst_itf3 : ITF; END_VAR VAR_IN_OUT inst_itf4 : ITF; \/\/ SA0044 END_VAR PROGRAM PLC_PRG VAR i...", 
"body" : "检测声明 REFERENCE TO 接口和声明 VAR_IN_OUT 带接口的变量（通过 REFERENCE TO ) 理由：接口类型总是隐含地引用实现该接口的功能块实例。因此，对接口的引用就是对引用的引用，并且可能导致不需要的行为。 重要性：高 例子 ITF 是在项目中定义的接口。 FUNCTION_BLOCK POU\nVAR_INPUT\n inst_itf2 : ITF;\nEND_VAR\nVAR_OUTPUT\n inst_itf3 : ITF;\nEND_VAR\nVAR_IN_OUT\n inst_itf4 : ITF; \/\/ SA0044\nEND_VAR\n PROGRAM PLC_PRG\nVAR\n inst : POU;\n itf_inst1 : ITF;\n itf_ref : REFERENCE TO ITF; \/\/ SA0044\nEND_VAR 输出在 留言 看法： SA0044：对接口“itf4_ref”的引用 SA0044：对接口“itf_ref”的引用 " }, 
{ "title" : "转换 ", 
"url" : "_san_conversion.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 转换 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0019：隐式指针转换 ", 
"url" : "_san_rule_sa0019.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 转换 \/ SA0019：隐式指针转换 ", 
"snippet" : "检测隐式生成的指针转换 理由：在 CODESYS ，指针不是严格类型的，它们可以以任何方式相互分配。它经常被使用，因此编译器不会报告。但是，它也可能导致未经授权的意外访问。例如，如果您分配类型 POINTER TO DWORD 指向类型为的指针 POINTER TO BYTE ，可能会以不想要的方式覆盖内存。 因此，请务必检查此规则，仅在您故意要访问不同类型的值时才屏蔽该消息。 与之之间的转换 POINTER TO BYTE SA0019 规则未检查数据类型。他们总是被允许的。 使用不同的消息报告隐式数据类型转换。 重要性：高 PLCOpen 规则：CP25 例外： BOOL <-> BIT ...", 
"body" : "检测隐式生成的指针转换 理由：在 CODESYS ，指针不是严格类型的，它们可以以任何方式相互分配。它经常被使用，因此编译器不会报告。但是，它也可能导致未经授权的意外访问。例如，如果您分配类型 POINTER TO DWORD 指向类型为的指针 POINTER TO BYTE ，可能会以不想要的方式覆盖内存。 因此，请务必检查此规则，仅在您故意要访问不同类型的值时才屏蔽该消息。 与之之间的转换 POINTER TO BYTE SA0019 规则未检查数据类型。他们总是被允许的。 使用不同的消息报告隐式数据类型转换。 重要性：高 PLCOpen 规则：CP25 例外： BOOL <-> BIT 示例 PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n byteVar : BYTE;\nEND_VAR\n pInt := ADR(byteVar); 中的输出 消息 视图： SA0019：从指针到 “指针到字节” 的隐式转换到指向 “指向整数指针” 的指针 " }, 
{ "title" : "SA0130：隐式扩展转换 ", 
"url" : "_san_rule_sa0130.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 转换 \/ SA0130：隐式扩展转换 ", 
"snippet" : "检测算术运算期间隐式执行从较小数据类型到较大数据类型的转换的代码位置 理由：当源类型的值范围完全包含在目标类型的值范围内时，编译器允许不同类型的任何赋值。但是，编译器将尽可能晚地构建对代码的转换。对于类型的赋值 lint := dint * dint ，编译器仅在乘法之后执行隐式转换： lint := TO_LINT(dint * dint); 因此溢出被截断。如果你想防止这种情况，那么你已经可以转换元素： lint := TO_LINT(dint) * TO_LINT(dint); 因此，报告编译器实现隐式转换的位置可能很有用，以便检查这些转换是否完全符合预期。此外，当其他系统具有更严格的类...", 
"body" : "检测算术运算期间隐式执行从较小数据类型到较大数据类型的转换的代码位置 理由：当源类型的值范围完全包含在目标类型的值范围内时，编译器允许不同类型的任何赋值。但是，编译器将尽可能晚地构建对代码的转换。对于类型的赋值 lint := dint * dint ，编译器仅在乘法之后执行隐式转换： lint := TO_LINT(dint * dint); 因此溢出被截断。如果你想防止这种情况，那么你已经可以转换元素： lint := TO_LINT(dint) * TO_LINT(dint); 因此，报告编译器实现隐式转换的位置可能很有用，以便检查这些转换是否完全符合预期。此外，当其他系统具有更严格的类型检查时，显式转换可用于提高其他系统的可移植性。 重要性：低 例子 PROGRAM PLC_PRG\nVAR\n d : DINT;\n l : LINT;\n ui : UINT;\n uli : ULINT;\n usi : USINT;\n lw : LWORD;\n udi : UDINT;\n lr : LREAL;\n b : BYTE;\nEND_VAR\n (*The following lines could result in unwanted truncating by implicit conversions \nand should be reported with SA0130*) \nl := d * d;\nuli := usi * usi;\nlw := udi * udi;\nlr := b * b;\nd := ui * ui; 输出在 留言 看法： SA0130：从类型“DINT”到类型“LINT”的隐式扩展转换 SA0130：从类型“USINT”到类型“ULINT”的隐式扩展转换 SA0130：从类型“UDINT”到类型“LWORD”的隐式扩展转换 SA0130：从类型“USINT”到类型“LREAL”的隐式扩展转换 SA0130：从类型“UINT”到类型“DINT”的隐式扩展转换 " }, 
{ "title" : "SA0133：显式缩小转换 ", 
"url" : "_san_rule_sa0133.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 转换 \/ SA0133：显式缩小转换 ", 
"snippet" : "检测从较大数据类型到较小数据类型的显式转换 理由：大量类型转换可能表明您为变量选择了错误的数据类型。因此，有一些编程指南要求对数据类型转换提供明确的理由。 重要性：低 例子 PROGRAM SA0133 VAR siVar:SINT; diVar:DINT; liVar:LINT; byVar:BYTE; uiVar:UINT; dwVar:DWORD; lwVar:LWORD; rVar:REAL; lrVar:LREAL; END_VAR siVar := LINT_TO_SINT(liVar); \/\/ SA0133 byVar := DINT_TO_BYTE(diVar); \/\/ SA0...", 
"body" : "检测从较大数据类型到较小数据类型的显式转换 理由：大量类型转换可能表明您为变量选择了错误的数据类型。因此，有一些编程指南要求对数据类型转换提供明确的理由。 重要性：低 例子 PROGRAM SA0133\nVAR\n siVar:SINT;\n diVar:DINT;\n liVar:LINT;\n byVar:BYTE;\n uiVar:UINT;\n dwVar:DWORD;\n lwVar:LWORD;\n rVar:REAL;\n lrVar:LREAL;\nEND_VAR\n siVar := LINT_TO_SINT(liVar); \/\/ SA0133\nbyVar := DINT_TO_BYTE(diVar); \/\/ SA0133\nsiVar := DWORD_TO_SINT(dwVar); \/\/ SA0133\nuiVar := LREAL_TO_UINT(lrVar); \/\/ SA0133\nrVar := LWORD_TO_REAL(lwVar); \/\/ SA0133 输出在 留言 看法： SA0133：从类型“LINT”到类型“SINT”的显式缩小转换 SA0133：从类型“DINT”到类型“BYTE”的显式缩小转换 SA0133：从类型“DWORD”到类型“SINT”的显式缩小转换 SA0133：从类型“LREAL”到类型“UINT”的显式缩小转换 SA0133：从类型“LWORD”到类型“REAL”的显式缩小转换 " }, 
{ "title" : "SA0134：显式有符号\/无符号转换 ", 
"url" : "_san_rule_sa0134.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 转换 \/ SA0134：显式有符号\/无符号转换 ", 
"snippet" : "检测从有符号数据类型到无符号数据类型的显式转换，反之亦然 理由：过度使用类型转换可能表明为变量选择了错误的数据类型。因此，有一些编程指南要求对数据类型转换提供明确的理由。 重要性：低 例子 PROGRAM PLC_PRG VAR byVar :BYTE; udiVar : UDINT; uliVar : ULINT; lwVar : LWORD; wVar : WORD; siVar : SINT; iVar : INT; diVar : DINT; liVar : LINT; END_VAR liVar := ULINT_TO_LINT(uliVar); udiVar := DINT_TO_...", 
"body" : "检测从有符号数据类型到无符号数据类型的显式转换，反之亦然 理由：过度使用类型转换可能表明为变量选择了错误的数据类型。因此，有一些编程指南要求对数据类型转换提供明确的理由。 重要性：低 例子 PROGRAM PLC_PRG\nVAR\n byVar :BYTE;\n udiVar : UDINT;\n uliVar : ULINT;\n lwVar : LWORD;\n wVar : WORD;\n siVar : SINT;\n iVar : INT;\n diVar : DINT;\n liVar : LINT;\nEND_VAR\n liVar := ULINT_TO_LINT(uliVar);\nudiVar := DINT_TO_UDINT(diVar);\nsiVar := BYTE_TO_SINT(byVar);\nwVar := INT_TO_WORD(iVar);\nlwVar := SINT_TO_LWORD(siVar); 输出在 留言 看法： SA0134：从类型“ULINT”到类型“LINT”的显式有符号\/无符号转换 SA0134：从类型“DINT”到类型“UDINT”的显式有符号\/无符号转换 SA0134：从类型“BYTE”到类型“SINT”的显式有符号\/无符号转换 SA0134：从“INT”类型到“WORD”类型的显式有符号\/无符号转换 SA0134：从“SINT”类型到“LWORD”类型的显式有符号\/无符号转换 " }, 
{ "title" : "使用直接地址 ", 
"url" : "_san_use_direct_adresses.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 使用直接地址 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0005：无效的地址和数据类型 ", 
"url" : "_san_rule_sa0005.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 使用直接地址 \/ SA0005：无效的地址和数据类型 ", 
"snippet" : "检测无效地址和数据类型规范。地址中的有效大小前缀：X 表示 BOOL B 表示 1 字节数据类型，W 表示 2 字节数据类型，D 表示 4 字节数据类型。 理由：位于直接地址上的变量最好与与其数据类型宽度相对应的地址相关联。代码的读者可能会感到困惑，例如，如果 DWORD 分配给一个 BYTE 地址。 重要性：低 例子 PROGRAM Check_Address_Type_PRG VAR iVar AT %QB0 : INT ; \/\/ OK e. g.: %QW0 xTest AT %QW1 : BOOL ; \/\/ OK e. g.: %QX1.0 END_VAR iVar := iVar +...", 
"body" : "检测无效地址和数据类型规范。地址中的有效大小前缀：X 表示 BOOL B 表示 1 字节数据类型，W 表示 2 字节数据类型，D 表示 4 字节数据类型。 理由：位于直接地址上的变量最好与与其数据类型宽度相对应的地址相关联。代码的读者可能会感到困惑，例如，如果 DWORD 分配给一个 BYTE 地址。 重要性：低 例子 PROGRAM Check_Address_Type_PRG\nVAR\n iVar AT %QB0 : INT ; \/\/ OK e. g.: %QW0\n xTest AT %QW1 : BOOL ; \/\/ OK e. g.: %QX1.0\nEND_VAR iVar := iVar + INT#1;\nxTest := NOT xTest;\n 输出在 留言 看法： SA0005：数据类型“iVar”的地址无效 也可以看看 配置和运行静态分析 " }, 
{ "title" : "SA0047：访问直接地址 ", 
"url" : "_san_rule_sa0047.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 使用直接地址 \/ SA0047：访问直接地址 ", 
"snippet" : "检测实现代码中的直接地址访问 理由：符号编程总是更可取的。变量的名称也可以具有含义。地址不能表明它的用途。 重要性：高 PLCopen 规则：N1 \/ CP1 例子 PROGRAM PLC_PRG VAR xVar : BOOL; byVar : BYTE; END_VAR xVar := %IX0.0; %QX0.0 := xVar; %MX0.1 := xVar; %MB1 := byVar; 输出在 留言 看法： SA0047：访问直接地址“%IX0.0” SA0026：访问直接地址“%QX0.0” SA0026：访问直接地址“%MX0.1” SA0026：访问直接地址“%MB1”...", 
"body" : "检测实现代码中的直接地址访问 理由：符号编程总是更可取的。变量的名称也可以具有含义。地址不能表明它的用途。 重要性：高 PLCopen 规则：N1 \/ CP1 例子 PROGRAM PLC_PRG\nVAR\n xVar : BOOL;\n byVar : BYTE;\nEND_VAR\n xVar := %IX0.0;\n%QX0.0 := xVar;\n%MX0.1 := xVar;\n%MB1 := byVar; 输出在 留言 看法： SA0047：访问直接地址“%IX0.0” SA0026：访问直接地址“%QX0.0” SA0026：访问直接地址“%MX0.1” SA0026：访问直接地址“%MB1” " }, 
{ "title" : "SA0048：直接地址的 AT 声明 ", 
"url" : "_san_rule_sa0048.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 使用直接地址 \/ SA0048：直接地址的 AT 声明 ", 
"snippet" : "检测到 AT 直接地址声明 在代码中使用直接地址是有问题的，因为地址会出现在多个位置： 首先在控制器配置中定义物理对象到地址的分配 程序中的第二个变量被分配给这些地址。 如果由于配置更改而重新定位地址，则需要将变量重新分配给程序中完全不同位置的地址。这是错误的原因并导致代码的可读性和可维护性较差。因此，最好在设备编辑器的 I\/O 映射中执行所有分配。 重要性：高 PLCopen 规则：N1 \/ CP1 我们建议您仅在 输入\/输出映射 设备编辑器的选项卡。 例子 PROGRAM PLC_PRG VAR xVar1 AT %IX0.0 : BOOL; byVar1 AT %IB1 : BYTE; ...", 
"body" : "检测到 AT 直接地址声明 在代码中使用直接地址是有问题的，因为地址会出现在多个位置： 首先在控制器配置中定义物理对象到地址的分配 程序中的第二个变量被分配给这些地址。 如果由于配置更改而重新定位地址，则需要将变量重新分配给程序中完全不同位置的地址。这是错误的原因并导致代码的可读性和可维护性较差。因此，最好在设备编辑器的 I\/O 映射中执行所有分配。 重要性：高 PLCopen 规则：N1 \/ CP1 我们建议您仅在 输入\/输出映射 设备编辑器的选项卡。 例子 PROGRAM PLC_PRG\nVAR\n xVar1 AT %IX0.0 : BOOL;\n byVar1 AT %IB1 : BYTE;\n xVar2 AT %QX0.0 : BOOL;\nEND_VAR\n 输出在 留言 看法： SA0048：声明使用直接地址“%IX0.0” SA0048：声明使用直接地址“%IB1” SA0048：声明使用直接地址“%QX0.0” " }, 
{ "title" : "运营商规则 ", 
"url" : "_san_rule_operators.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0051：对 BOOL 变量的比较操作 ", 
"url" : "_san_rule_sa0051.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0051：对 BOOL 变量的比较操作 ", 
"snippet" : "检测类型变量的比较操作 BOOL 理由： CODESYS 允许进行这些类型的比较。但它们非常不寻常并且可能令人困惑。 IEC 61131-3 标准没有提供这些比较。通过避免它们，您可以提高代码到其他开发系统的可移植性。 重要性：中等 例子 PROGRAM PLC_PRG VAR xBool1, xBool2 : BOOL; xResult : BOOL; END_VAR xResult := xBool1 > xBool2; \/\/ SA0051 xBool1 := NOT xBool1; \/\/ OK! xBool2 := xBool2 XOR xBool1; \/\/ OK! 输出在 留言 看法：...", 
"body" : "检测类型变量的比较操作 BOOL 理由： CODESYS 允许进行这些类型的比较。但它们非常不寻常并且可能令人困惑。 IEC 61131-3 标准没有提供这些比较。通过避免它们，您可以提高代码到其他开发系统的可移植性。 重要性：中等 例子 PROGRAM PLC_PRG\nVAR\n xBool1, xBool2 : BOOL;\n xResult : BOOL;\nEND_VAR\n xResult := xBool1 > xBool2; \/\/ SA0051\nxBool1 := NOT xBool1; \/\/ OK!\nxBool2 := xBool2 XOR xBool1; \/\/ OK! 输出在 留言 看法： SA0051：BOOL 变量的比较运算 " }, 
{ "title" : "SA0052：不寻常的移位操作 ", 
"url" : "_san_rule_sa0052.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0052：不寻常的移位操作 ", 
"snippet" : "检测有符号变量的移位操作（位移）。在对位域数据类型进行移位操作的情况下（ Byte , DWORD , LWORD , WORD )，不报错。 理由： CODESYS 允许对有符号数据类型进行移位操作。但是，这些操作是不寻常的并且可能会令人困惑。 IEC 61131-3 标准不提供此类操作。因此，应该避免它们以增加代码对其他开发系统的可移植性。 重要性：中等 例子 PROGRAM PLC_PRG VAR iTemp : INT; dwTemp1 : DWORD; byTemp2 : BYTE; diTemp3 : DINT; siTemp4 : SINT; liTemp5 : LINT; EN...", 
"body" : "检测有符号变量的移位操作（位移）。在对位域数据类型进行移位操作的情况下（ Byte , DWORD , LWORD , WORD )，不报错。 理由： CODESYS 允许对有符号数据类型进行移位操作。但是，这些操作是不寻常的并且可能会令人困惑。 IEC 61131-3 标准不提供此类操作。因此，应该避免它们以增加代码对其他开发系统的可移植性。 重要性：中等 例子 PROGRAM PLC_PRG\nVAR\n iTemp : INT;\n dwTemp1 : DWORD;\n byTemp2 : BYTE;\n diTemp3 : DINT;\n siTemp4 : SINT;\n liTemp5 : LINT;\nEND_VAR\n \/\/the following lines each will cause an SA0052:\niTemp := SHL(iTemp, BYTE#2);\ndiTemp3 := SHR(diTemp3, BYTE#4);\nsiTemp4 := ROL(siTemp4, BYTE#2);\nliTemp5 := ROR(liTemp5, BYTE#2);\n\n\/\/no error SA0052 because DWORD and BYTE are bitfield datatypes:\ndwTemp1 := SHL(dwTemp1, BYTE#3);\nbyTemp2 := SHR(byTemp2, BYTE#1); 输出在 留言 看法： SA0052：异常轮班操作 " }, 
{ "title" : "SA0053：按位移位太大 ", 
"url" : "_san_rule_sa0053.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0053：按位移位太大 ", 
"snippet" : "在操作数按位移位（bit shift）的情况下，检测是否超出了操作数的数据类型宽度 理由：如果移位操作超出数据类型宽度，则为常数 0 生成。 如果旋转移位超过数据类型宽度，则难以读取。因此，应缩短旋转值。 重要性：高 例子 PROGRAM PLC_PRG VAR byTemp1 : BYTE; wTemp2 : WORD; dwTemp3 : DWORD; lwTemp4 : LWORD; END_VAR byTemp1 := SHR(byTemp1, BYTE#25); wTemp2 := SHL(wTemp2, BYTE#45); dwTemp3 := ROR(dwTemp3, BYTE#...", 
"body" : "在操作数按位移位（bit shift）的情况下，检测是否超出了操作数的数据类型宽度 理由：如果移位操作超出数据类型宽度，则为常数 0 生成。 如果旋转移位超过数据类型宽度，则难以读取。因此，应缩短旋转值。 重要性：高 例子 PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\n lwTemp4 : LWORD;\nEND_VAR\n byTemp1 := SHR(byTemp1, BYTE#25);\nwTemp2 := SHL(wTemp2, BYTE#45);\ndwTemp3 := ROR(dwTemp3, BYTE#78);\nlwTemp4 := ROL(lwTemp4, BYTE#111); 输出在 留言 看法： SA0053：按位移位太大 " }, 
{ "title" : "SA0054：REAL\/LREAL 的相等\/不等比较 ", 
"url" : "_san_rule_sa0054.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0054：REAL\/LREAL 的相等\/不等比较 ", 
"snippet" : "检测比较运算符是否 = （平等）和 <> （不等式）比较类型的操作数 REAL 或者 LREAL . 理由： REAL \/ LREAL 根据 IEEE 754 标准，值被实现为浮点数。该标准意味着特定的、看似简单的十进制数无法精确表示。因此，可能会有不同的表示形式： LREAL 对于相同的十进制数。 考虑以下代码行： lr11 := 1.1; lr33 := 3.3; lrVar1 := lr11 + lr11; lrVar2 := lr33 - lr11; botest := lrVar1 = lrVar2; 在这种情况下， botest 返回 FALSE , 即使变量 lrVar1 和 l...", 
"body" : "检测比较运算符是否 = （平等）和 <> （不等式）比较类型的操作数 REAL 或者 LREAL . 理由： REAL \/ LREAL 根据 IEEE 754 标准，值被实现为浮点数。该标准意味着特定的、看似简单的十进制数无法精确表示。因此，可能会有不同的表示形式： LREAL 对于相同的十进制数。 考虑以下代码行： lr11 := 1.1;\nlr33 := 3.3;\nlrVar1 := lr11 + lr11;\nlrVar2 := lr33 - lr11;\nbotest := lrVar1 = lrVar2; 在这种情况下， botest 返回 FALSE , 即使变量 lrVar1 和 lrVar2 两者都返回“2.2”的监控值。这不是编译器的错误，而是所有常规处理器的浮点单元的属性。您可以通过指定值可能不同的最小值来避免这种情况： botest := ABS(lrVar1 - lrVar2) < 0.1; botest := ABS(lrVar1 - lrVar2) < 0.1; 例外：与 0.0 本分析未报告。对于 0，IEEE 754 标准中有精确的表示，因此比较函数通常符合预期。因此，为了获得更好的性能，允许在这里进行直接比较是有意义的。 重要性：高 PLCopen规则：CP54 例子 PROGRAM PLC_PRG\nVAR\n rTest1 : REAL;\n rTest2 : REAL;\n lrTest3 : LREAL;\n lrTest4 : LREAL;\n xResult : BOOL;\nEND_VAR \/\/the following lines each will cause an SA0054:\nxResult := rTest1 = rTest1;\nxResult := rTest1 = rTest2;\nxResult := rTest1 <> rTest2;\nxResult := lrTest3 = lrTest3;\nxResult := lrTest3 = lrTest4;\nxResult := lrTest3 <> lrTest4;\n\/\/the following lines each will not cause an SA0054:\nxResult := rTest1 > rTest2;\nxResult := lrTest3 < lrTest4;\n 输出在 留言 看法： SA0054：REAL\/LREAL 相等\/不相等的比较 " }, 
{ "title" : "SA0055：无符号操作数的不必要比较 ", 
"url" : "_san_rule_sa0055.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0055：无符号操作数的不必要比较 ", 
"snippet" : "检测与无符号操作数的不必要比较。无符号数据类型永远不会小于零。这可以用作符号检查。 理由：使用此检查检测到的比较会产生恒定的结果，并且表明代码中存在错误。 重要性：高 例子 PROGRAM PLC_PRG VAR byTest: BYTE; END_VAR \/\/ SA0055 WHILE byTest >= 0 DO byTest := byTest - 1; END_WHILE 输出在 留言 看法： SA0055：无符号操作数的不必要比较...", 
"body" : "检测与无符号操作数的不必要比较。无符号数据类型永远不会小于零。这可以用作符号检查。 理由：使用此检查检测到的比较会产生恒定的结果，并且表明代码中存在错误。 重要性：高 例子 PROGRAM PLC_PRG\nVAR\n byTest: BYTE;\nEND_VAR\n \/\/ SA0055\nWHILE byTest >= 0 DO\n byTest := byTest - 1;\nEND_WHILE 输出在 留言 看法： SA0055：无符号操作数的不必要比较 " }, 
{ "title" : "SA0056：常数超出有效范围 ", 
"url" : "_san_rule_sa0056.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0056：常数超出有效范围 ", 
"snippet" : "检测运算符有效范围之外的文字（常量） 说明：在将某个值与超出该值范围的常数进行比较时发出该消息。然后比较不断返回 TRUE 或者 FALSE .这是编程错误的指示。 重要性：高 例子 PROGRAM PLC_PRG VAR byTestVar: BYTE; END_VAR WHILE byTestVar >= 260 DO byTestVar := byTestVar + 1; END_WHILE 输出在 留言 看法： SA0056：常量超出有效范围...", 
"body" : "检测运算符有效范围之外的文字（常量） 说明：在将某个值与超出该值范围的常数进行比较时发出该消息。然后比较不断返回 TRUE 或者 FALSE .这是编程错误的指示。 重要性：高 例子 PROGRAM PLC_PRG\nVAR\n byTestVar: BYTE;\nEND_VAR\n WHILE byTestVar >= 260 DO\n byTestVar := byTestVar + 1;\nEND_WHILE 输出在 留言 看法： SA0056：常量超出有效范围 " }, 
{ "title" : "SA0057：可能丢失小数位 ", 
"url" : "_san_rule_sa0057.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0057：可能丢失小数位 ", 
"snippet" : "检测可能丢失小数位的语句 理由：以下类型的一段代码（ diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) ) 可能会导致误解。这行代码的作者或读者可以假设除法将作为 REAL 操作，在这种情况下，结果将是 REAL#0.5 .然而，事实并非如此。它是一个整数运算。结果被转换为 REAL 和 rTemp1 获取值 REAL#0 . 为了避免这种情况，请使用强制转换来确保该操作作为 REAL 手术： rTemp1 := TO_REAL(diTemp2) \/ REAL#2; 重要性：中等 例子 PROGRAM PLC_PRG VAR rTemp1 : R...", 
"body" : "检测可能丢失小数位的语句 理由：以下类型的一段代码（ diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) ) 可能会导致误解。这行代码的作者或读者可以假设除法将作为 REAL 操作，在这种情况下，结果将是 REAL#0.5 .然而，事实并非如此。它是一个整数运算。结果被转换为 REAL 和 rTemp1 获取值 REAL#0 . 为了避免这种情况，请使用强制转换来确保该操作作为 REAL 手术： rTemp1 := TO_REAL(diTemp2) \/ REAL#2; 重要性：中等 例子 PROGRAM PLC_PRG\nVAR\n rTemp1 : REAL;\n diTemp2 : DINT;\n liTemp3 : LINT;\nEND_VAR diTemp2 := diTemp2 + DINT#11;\n\/\/ SA0057\nrTemp1 := DINT_TO_REAL(diTemp2 \/ DINT#3); \nrTemp1 := DINT_TO_REAL(diTemp2) \/ REAL#3.0;\nliTemp3 := liTemp3 + LINT#13;\n\/\/ SA0057\nrTemp1 := LINT_TO_REAL(liTemp3 \/ LINT#7);\nrTemp1 := LINT_TO_REAL(liTemp3) \/ REAL#7.0; 输出在 留言 看法： SA0057：可能丢失小数位 " }, 
{ "title" : "SA0058：对枚举变量的操作 ", 
"url" : "_san_rule_sa0058.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0058：对枚举变量的操作 ", 
"snippet" : "检测对枚举数据类型的变量的操作 允许赋值。 理由：枚举不应用作普通整数值。或者，可以定义别名数据类型或者可以使用子范围类型。 重要性：中等 例外：如果枚举用 pragma 标记 {attribute 'strict'} ，那么编译器已经报告了这种操作。 如果枚举被 pragma 声明为标志 {attribute 'flags'} ，则不会发出错误 AND , OR , NOT , 或序 XOR 操作。 例子 TYPE My_Enum : ( red := 1, blue := 2, green := 3, black := 4 ); END_TYPE PROGRAM PLC_PRG VAR i...", 
"body" : "检测对枚举数据类型的变量的操作 允许赋值。 理由：枚举不应用作普通整数值。或者，可以定义别名数据类型或者可以使用子范围类型。 重要性：中等 例外：如果枚举用 pragma 标记 {attribute 'strict'} ，那么编译器已经报告了这种操作。 如果枚举被 pragma 声明为标志 {attribute 'flags'} ，则不会发出错误 AND , OR , NOT , 或序 XOR 操作。 例子 TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : My_Enum;\nEND_VAR iTemp1 := iTemp1 + INT#1;\nabc := My_Enum.red; \/\/ OK\niTemp1 := My_Enum.black \/ My_Enum.blue; \/\/ SA0058\niTemp1 := My_Enum.green \/ My_Enum.red; \/\/ SA0058\n 输出在 留言 看法： SA0058：枚举变量的操作 使用编译指示 {attribute 'flags'} 的示例 {attribute 'flags'} \/\/ declaring the enumeration as a \"flag\"\nTYPE Flags :\n(\n Unknown := 16#00000001,\n Stopped := 16#00000002,\n Running := 16#00000004\n) DWORD;\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : Flags;\n batate : BYTE;\n dwFlags : DWORD;\n dwState : DWORD;\nEND_VAR \/\/ OK for the following\nIF (dwFlags AND Flags.Unknown) <> DWORD#0 THEN\n dwState := dwState AND Flags.Unknown;\n ELSIF (dwFlags OR Flags.Stopped) <> DWORD#0 THEN\n dwState := dwState OR Flags.Running;\nEND_IF " }, 
{ "title" : "SA0059: 比较操作总是返回 TRUE 或 FALSE ", 
"url" : "_san_rule_sa0059.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0059: 比较操作总是返回 TRUE 或 FALSE ", 
"snippet" : "检测与结果始终为的文字的比较 TRUE 或者 FALSE ，并且可以在编译期间进行处理。 理由：持续产生的操作 TRUE 或者 FALSE 是编程错误的指示。 重要性：高 例子 PROGRAM PLC_PRG VAR byTemp1 : BYTE; END_VAR WHILE byTemp1 <= 255 DO byTemp1 := byTemp1 + 1; END_WHILE 输出在 留言 看法： SA0059：关系运算符“<=”的计算结果始终为“TRUE”...", 
"body" : "检测与结果始终为的文字的比较 TRUE 或者 FALSE ，并且可以在编译期间进行处理。 理由：持续产生的操作 TRUE 或者 FALSE 是编程错误的指示。 重要性：高 例子 PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\nEND_VAR\n WHILE byTemp1 <= 255 DO\n byTemp1 := byTemp1 + 1;\nEND_WHILE 输出在 留言 看法： SA0059：关系运算符“<=”的计算结果始终为“TRUE”\n " }, 
{ "title" : "SA0060：零用作无效操作数 ", 
"url" : "_san_rule_sa0060.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0060：零用作无效操作数 ", 
"snippet" : "检测操作数具有以下值的操作 0 导致无效或无意义的操作 理由：这种表达方式可能表明存在编程错误。在任何情况下，它都会不必要地浪费运行时间。 重要性：中等 例子 PROGRAM PLC_PRG VAR byTemp1 : BYTE; wTemp2 : WORD; dwTemp3 : DWORD; END_VAR byTemp1 := byTemp1 + 0; wTemp2 := wTemp2 - WORD#0; dwTemp3 := dwTemp3 * DWORD#0; 输出在 留言 看法： SA0060：零用作无效操作数...", 
"body" : "检测操作数具有以下值的操作 0 导致无效或无意义的操作 理由：这种表达方式可能表明存在编程错误。在任何情况下，它都会不必要地浪费运行时间。 重要性：中等 例子 PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\nEND_VAR\n byTemp1 := byTemp1 + 0;\nwTemp2 := wTemp2 - WORD#0;\ndwTemp3 := dwTemp3 * DWORD#0; 输出在 留言 看法： SA0060：零用作无效操作数 " }, 
{ "title" : "SA0061：指针上的异常操作 ", 
"url" : "_san_rule_sa0061.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0061：指针上的异常操作 ", 
"snippet" : "检测操作一种类型的变量 POINTER TO 哪些不是 = （平等）， <> （不等式）， + （加法），或 ADR . 在 CODESYS , 指针算术一般是允许的，也可以适当使用。因此，将指针与整数值相加被认为是对指针的常见操作。这使得可以使用指针来处理可变长度的数组。使用 SA0061 报告所有其他（不寻常的）指针操作。 重要性：高 PLCopen 规则：E2 \/ E3 例子 PROGRAM PLC_PRG VAR piTemp : POINTER TO INT; iTemp : INT; END_VAR iTemp := iTemp + INT#1; piTemp := ADR(iTe...", 
"body" : "检测操作一种类型的变量 POINTER TO 哪些不是 = （平等）， <> （不等式）， + （加法），或 ADR . 在 CODESYS , 指针算术一般是允许的，也可以适当使用。因此，将指针与整数值相加被认为是对指针的常见操作。这使得可以使用指针来处理可变长度的数组。使用 SA0061 报告所有其他（不寻常的）指针操作。 重要性：高 PLCopen 规则：E2 \/ E3 例子 PROGRAM PLC_PRG\nVAR\n piTemp : POINTER TO INT;\n iTemp : INT;\nEND_VAR\n iTemp := iTemp + INT#1;\npiTemp := ADR(iTemp);\npiTemp := piTemp * DWORD#5; \/\/ SA0061\npiTemp := piTemp \/ DWORD#2; \/\/ SA0061\npiTemp := piTemp MOD DWORD#3; \/\/ SA0061\npiTemp := piTemp + DWORD#1;\npiTemp := piTemp - DWORD#1; \/\/ SA0061 输出在 留言 看法： SA0061：指针的异常操作 " }, 
{ "title" : "SA0062：表达式是常量 ", 
"url" : "_san_rule_sa0062.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0062：表达式是常量 ", 
"snippet" : "检测运行时始终具有相同值的表达式的用法。 理由：重复计算且始终生成相同值的复杂表达式可能表示存在错误。如果有其他意图，这尤其适用。在每种情况下，该表达式都会不必要地给程序的运行时间带来负担。 重要性：中等 例子 PROGRAM PLC_PRG VAR value : INT; condition : BOOL; END_VAR value := 8; condition := value = 8 \/\/ Reports: Expression (value=8) is always TRUE 中的输出 消息 视图： SA0062：表达式 '(value=8)' 始终为 TRUE...", 
"body" : "检测运行时始终具有相同值的表达式的用法。 理由：重复计算且始终生成相同值的复杂表达式可能表示存在错误。如果有其他意图，这尤其适用。在每种情况下，该表达式都会不必要地给程序的运行时间带来负担。 重要性：中等 例子 PROGRAM PLC_PRG\nVAR\n value : INT;\n condition : BOOL;\nEND_VAR\n value := 8;\ncondition := value = 8 \/\/ Reports: Expression (value=8) is always TRUE 中的输出 消息 视图： SA0062：表达式 '(value=8)' 始终为 TRUE " }, 
{ "title" : "SA0063：可能不是 16 位兼容的操作 ", 
"url" : "_san_rule_sa0063.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0063：可能不是 16 位兼容的操作 ", 
"snippet" : "检测具有临时结果的 16 位操作。背景：在 16 位系统上，可以截断 32 位临时结果。例子： (int+10) 可以超过 16 位。 理由：在极少数情况下，您必须编写应该在 16 位处理器和 32 位处理器上运行的代码，此消息应该有助于防止出现任何问题。 重要性：低 例子 PROGRAM PLC_PRG VAR iVar : INT; END_VAR iVar := (iVar + 10) \/ 2; 输出在 留言 看法： SA0063：16 位的兼容性 – 可能被截断的中间结果...", 
"body" : "检测具有临时结果的 16 位操作。背景：在 16 位系统上，可以截断 32 位临时结果。例子： (int+10) 可以超过 16 位。 理由：在极少数情况下，您必须编写应该在 16 位处理器和 32 位处理器上运行的代码，此消息应该有助于防止出现任何问题。 重要性：低 例子 PROGRAM PLC_PRG\nVAR\n iVar : INT;\nEND_VAR\n iVar := (iVar + 10) \/ 2; 输出在 留言 看法： SA0063：16 位的兼容性 – 可能被截断的中间结果 " }, 
{ "title" : "SA0064：添加指针 ", 
"url" : "_san_rule_sa0064.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0064：添加指针 ", 
"snippet" : "检测指针的添加 理由：在 CODESYS ，指针运算一般是允许的，也可以适当使用。然而，它也代表了错误的来源。因此，存在通常禁止指针运算的编程规则。这个测试可以检查这样的需求。 重要性：中等 例子 PROGRAM PLC_PRG VAR iTest : INT; ariTest : ARRAY[0..10] OF INT; {attribute 'analysis':='-111'} piTest : POINTER TO INT; i : INT; END_VAR piTest := ADR(ariTest[0]); \/\/ OK piTest^ := 0; piTest := ADR(ari...", 
"body" : "检测指针的添加 理由：在 CODESYS ，指针运算一般是允许的，也可以适当使用。然而，它也代表了错误的来源。因此，存在通常禁止指针运算的编程规则。这个测试可以检查这样的需求。 重要性：中等 例子 PROGRAM PLC_PRG\nVAR\n iTest : INT;\n ariTest : ARRAY[0..10] OF INT;\n {attribute 'analysis':='-111'}\n piTest : POINTER TO INT;\n i : INT;\nEND_VAR\n piTest := ADR(ariTest[0]); \/\/ OK\npiTest^ := 0;\npiTest := ADR(ariTest) + SIZEOF(INT); \/\/ SA0064\npiTest^ := 1;\npiTest := ADR(ariTest) + 6; \/\/ SA0064\npiTest^ := 3;\npiTest := ADR(ariTest[10]);\nFOR i:=0 TO 10 DO\n piTest^ := i;\n piTest := piTest + 2; \/\/ SA0064\nEND_FOR 输出在 留言 看法： SA0064：添加指针 " }, 
{ "title" : "SA0065：添加到基本大小的指针不正确 ", 
"url" : "_san_rule_sa0065.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0065：添加到基本大小的指针不正确 ", 
"snippet" : "检测要添加的值与指针的基本大小不匹配的指针添加。只能添加基本数据大小及其倍数的文字而不会出现错误。 理由：在 CODESYS （与 C 和 C++ 相反），当添加具有整数值的指针时，仅将该整数值添加为字节数，而不是整数值乘以基本大小。 ST 中的示例 pINT := ADR(array_of_int[0]); pINT := pINT + 2; \/\/in CODESYS, pINT then points to array_of_int[1] 此代码在 C 中的功能会有所不同： short* pShort pShort = &(array_of_short[0]) pShort = pShor...", 
"body" : "检测要添加的值与指针的基本大小不匹配的指针添加。只能添加基本数据大小及其倍数的文字而不会出现错误。 理由：在 CODESYS （与 C 和 C++ 相反），当添加具有整数值的指针时，仅将该整数值添加为字节数，而不是整数值乘以基本大小。 ST 中的示例 pINT := ADR(array_of_int[0]);\npINT := pINT + 2; \/\/in CODESYS, pINT then points to array_of_int[1] 此代码在 C 中的功能会有所不同： short* pShort\npShort = &(array_of_short[0])\npShort = pShort + 2; \/\/in C, pShort then points to array_of_short[2] 因此，在 CODESYS ，您应该始终将指针基本大小的倍数添加到指针中。否则，指针可能指向 未对齐 内存（取决于处理器）在访问它时可能会导致对齐异常。 重要性：高 例子 VAR\n pudiTest:POINTER TO UDINT;\n udiTest:UDINT;\n prTest:POINTER TO REAL;\n rTest:REAL;\nEND_VAR pudiTest := ADR(udiTest) + 4; \/\/ OK\npudiTest := ADR(udiTest) + ( 2 + 2 ); \/\/ OK\npudiTest := ADR(udiTest) + SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + 3; \/\/ SA0065\npudiTest := ADR(udiTest) + 2*SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + ( 3 + 2 ); \/\/ SA0065\nprTest := ADR(rTest);\nprTest := prTest + 4; \/\/ OK\nprTest := prTest + ( 2 + 2 ); \/\/ OK\nprTest := prTest + SIZEOF(REAL); \/\/ OK\nprTest := prTest + 1; \/\/ SA0065\nprTest := prTest + 2; \/\/ SA0065\nprTest := prTest + 3; \/\/ SA0065\nprTest := prTest + ( SIZEOF(REAL) - 1 ); \/\/ SA0065\nprTest := prTest + ( 1 + 4 ); \/\/ SA0065\n 输出在 留言 看法： SA0065：基本大小的指针添加不正确 " }, 
{ "title" : "SA0066：临时结果的使用 ", 
"url" : "_san_rule_sa0066.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 运营商规则 \/ SA0066：临时结果的使用 ", 
"snippet" : "检测数据类型小于寄存器大小的语句中临时结果的使用。在这种情况下，隐式强制转换可能会导致不良结果。 理由：出于性能原因， CODESYS Static Analysis 对处理器的寄存器宽度执行操作。中间结果不会被截断。这可能会导致误解，如下例所示： 例子 usintTest := 0; xError := usintTest - 1 <> 255; 在 CODESYS , xError 是 TRUE 在这种情况下，因为操作 usintTest - 1 通常作为 32 位操作执行，并且结果不会转换为字节大小。然后是值 16#ffffffff （不等于255）位于寄存器中。 为了避免这种情况，您需...", 
"body" : "检测数据类型小于寄存器大小的语句中临时结果的使用。在这种情况下，隐式强制转换可能会导致不良结果。 理由：出于性能原因， CODESYS Static Analysis 对处理器的寄存器宽度执行操作。中间结果不会被截断。这可能会导致误解，如下例所示： 例子 usintTest := 0; xError := usintTest - 1 <> 255; 在 CODESYS , xError 是 TRUE 在这种情况下，因为操作 usintTest - 1 通常作为 32 位操作执行，并且结果不会转换为字节大小。然后是值 16#ffffffff （不等于255）位于寄存器中。 为了避免这种情况，您需要显式转换中间结果： xError := TO_USINT(usintTest - 1) <> 255; 如果激活此消息，则将报告代码中许多问题较少的位置。尽管只有当操作在数据类型中产生上溢或下溢时才会出现问题，但静态分析无法区分各个位置。 如果您在所有报告的位置中包含显式类型转换，那么代码将慢得多且可读性差。 重要性：低 例子 PROGRAM PLC_PRG\nVAR\n byTest:BYTE;\n liTest:LINT;\n xError:BOOL;\nEND_VAR \/\/type size smaller than register size;\nbyTest := 0;\nIF (byTest - 1) <> 255 THEN \/\/use of temporary result + implicit casting -> SA0066\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n\n\/\/type size equal to or bigger than register size;\nliTest := 0;\nIF (liTest - 1) <> -1 THEN \/\/ use of temporary result and no implicit casting -> OK\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n 输出在 留言 看法： SA0066：临时结果的使用（byTest - USINT #1） " }, 
{ "title" : "声明规则 ", 
"url" : "_san_rule_instructions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 声明规则 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0072：计数器变量的无效使用 ", 
"url" : "_san_rule_sa0072.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 声明规则 \/ SA0072：计数器变量的无效使用 ", 
"snippet" : "检测计数器变量的使用 FOR 环形 理由：在 a 中操作计数器变量 FOR 循环很容易导致无限循环。要防止针对计数器变量的特定值执行循环，请使用 CONTINUE 或者只是一个 IF 。 重要性：高 PLCopen 规则：L12 例子 PROGRAM PLC_PRG VAR_TEMP iIndex : INT; END_VAR FOR iIndex := INT#0 TO INT#20 BY INT#1 DO iIndex := iIndex - INT#1; END_FOR 输出在 留言 看法： SA0072：计数器变量“iIndex”的使用无效...", 
"body" : "检测计数器变量的使用 FOR 环形 理由：在 a 中操作计数器变量 FOR 循环很容易导致无限循环。要防止针对计数器变量的特定值执行循环，请使用 CONTINUE 或者只是一个 IF 。 重要性：高 PLCopen 规则：L12 例子 PROGRAM PLC_PRG\nVAR_TEMP\n iIndex : INT;\nEND_VAR FOR iIndex := INT#0 TO INT#20 BY INT#1 DO\n iIndex := iIndex - INT#1;\nEND_FOR 输出在 留言 看法： SA0072：计数器变量“iIndex”的使用无效 " }, 
{ "title" : "SA0073：使用不充分的计数器变量 ", 
"url" : "_san_rule_sa0073.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 声明规则 \/ SA0073：使用不充分的计数器变量 ", 
"snippet" : "检测非临时变量的使用 FOR 循环。 理由：这是一个性能警告。每次调用 POU 时都会初始化一个计数器变量。您可以将此变量创建为临时变量 ( VAR_TEMP ）。访问它可能会更快，并且该变量不会占用任何永久内存。 重要性：中等 PLCopen规则：CP21\/L13 例子 PROGRAM PLC_PRG VAR nIndex : INT; iVar : INT; END_VAR FOR nIndex := INT#0 TO INT#20 BY INT#1 DO iVar := iVar + nIndex; END_FOR 查看输出 留言 : SA0073：计数器变量不匹配...", 
"body" : "检测非临时变量的使用 FOR 循环。 理由：这是一个性能警告。每次调用 POU 时都会初始化一个计数器变量。您可以将此变量创建为临时变量 ( VAR_TEMP ）。访问它可能会更快，并且该变量不会占用任何永久内存。 重要性：中等 PLCopen规则：CP21\/L13 例子 PROGRAM PLC_PRG\nVAR\n nIndex : INT;\n iVar : INT;\nEND_VAR FOR nIndex := INT#0 TO INT#20 BY INT#1 DO\n iVar := iVar + nIndex;\nEND_FOR\n 查看输出 留言 : SA0073：计数器变量不匹配 " }, 
{ "title" : "SA0075：缺少 ELSE ", 
"url" : "_san_rule_sa0075.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 声明规则 \/ SA0075：缺少 ELSE ", 
"snippet" : "检测到 CASE 没有的陈述 ELSE 分支 理由：防御性编程需要包含一个 ELSE 在每个分支 CASE 陈述。如果在里面无事可做 ELSE 分支，然后包含注释以表明这一点。代码的读者很清楚，这个案例并没有被简单地遗忘。 重要性：低 PLCopen 规则：L17 For CASE 使用带有属性的枚举的语句 strict  并且所有枚举常量都用在 CASE 使用语句时，不会发出错误消息。 例子 PROGRAM PLC_PRG VAR iVar : INT; xTemp : BOOL; END_VAR iVar := iVar + INT#1; CASE iVar OF INT#1: xTemp...", 
"body" : "检测到 CASE 没有的陈述 ELSE 分支 理由：防御性编程需要包含一个 ELSE 在每个分支 CASE 陈述。如果在里面无事可做 ELSE 分支，然后包含注释以表明这一点。代码的读者很清楚，这个案例并没有被简单地遗忘。 重要性：低 PLCopen 规则：L17 For CASE 使用带有属性的枚举的语句 strict  并且所有枚举常量都用在 CASE 使用语句时，不会发出错误消息。 例子 PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\nCASE iVar OF\n INT#1:\n xTemp := FALSE;\n INT#2:\n xTemp := TRUE;\nEND_CASE\n 输出在 留言 看法： SA0075：CASE 语句中缺少 ELSE " }, 
{ "title" : "SA0076: 缺少枚举常量 ", 
"url" : "_san_rule_sa0076.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 声明规则 \/ SA0076: 缺少枚举常量 ", 
"snippet" : "确定每个枚举常量是否用作条件 CASE 语句并在 a 中查询 CASE 分支。 理由：防御性编程需要处理枚举的所有可能值。如果特定枚举值不需要执行操作，则应添加注释以明确指出这一点。然后，代码的读者很清楚，该值并没有被简单地遗忘。 重要性：低 例子 TYPE My_Enum : ( red := 1, blue := 2, green := 3, black := 4 ); END_TYPE PROGRAM PLC_PRG VAR iVar : My_Enum; xTemp : BOOL; END_VAR iVar := My_Enum.black; CASE iVar OF My_Enum....", 
"body" : "确定每个枚举常量是否用作条件 CASE 语句并在 a 中查询 CASE 分支。 理由：防御性编程需要处理枚举的所有可能值。如果特定枚举值不需要执行操作，则应添加注释以明确指出这一点。然后，代码的读者很清楚，该值并没有被简单地遗忘。 重要性：低 例子 TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iVar : My_Enum;\n xTemp : BOOL;\nEND_VAR iVar := My_Enum.black;\nCASE iVar OF\n My_Enum.red:\n xTemp := FALSE;\n My_Enum.blue, My_Enum.green:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n 输出在 留言 看法： SA0076：CASE 语句中缺少枚举常量“black” " }, 
{ "title" : "SA0077：枚举类型与不匹配 CASE 表情 ", 
"url" : "_san_rule_sa0077.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 声明规则 \/ SA0077：枚举类型与不匹配 CASE 表情 ", 
"snippet" : "检测代码位置，其中 CASE 语句将枚举值与非枚举类型混合在一起。 理由：在 CASE 结构中混合枚举值和整数值会违反数据类型安全性，降低代码的可读性并影响可维护性。枚举值确保语义清晰度。使用原始整数值会带来小错误的风险，并使代码更难理解。枚举的数据类型更改也会破坏基于整数的分支，而这些分支可能会 重要性：低 例子 {attribute 'qualified_only'} {attribute 'strict'} TYPE DUT_MyEnum : ( One := 1, Two := 2, Three := 3, Four := 4 ); END_TYPE PROGRAM PRG_Case ...", 
"body" : "检测代码位置，其中 CASE 语句将枚举值与非枚举类型混合在一起。 理由：在 CASE 结构中混合枚举值和整数值会违反数据类型安全性，降低代码的可读性并影响可维护性。枚举值确保语义清晰度。使用原始整数值会带来小错误的风险，并使代码更难理解。枚举的数据类型更改也会破坏基于整数的分支，而这些分支可能会 重要性：低 例子 {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE DUT_MyEnum :\n(\n\tOne := 1, \n\tTwo := 2, \n\tThree := 3, \n\tFour := 4\n);\nEND_TYPE PROGRAM PRG_Case\nVAR\ndiVar : DINT;\nxTemp : BOOL;\n\neMyEnum : DUT_MyEnum;\nEND_VAR\n CASE diVar OF\n 1 :\n xTemp := FALSE;\n DUT_MyEnum.Two : \/\/ SA0077\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n\nCASE eMyEnum OF\n 1 : \/\/ SA0077\n xTemp := FALSE;\n DUT_MyEnum.Two:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE 输出在 留言 看法： SA0077：类型与 CASE 表达式不匹配 " }, 
{ "title" : "SA0078：缺少 CASE 分支 ", 
"url" : "_san_rule_sa0078.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 声明规则 \/ SA0078：缺少 CASE 分支 ", 
"snippet" : "检测到 CASE 没有的陈述 CASE 分支，只有一个 ELSE 陈述 理由：A CASE 没有 case 的语句会浪费执行时间并且难以阅读。 重要性：中等 例子 PROGRAM PLC_PRG VAR iVar : INT; xTemp : BOOL; END_VAR iVar := iVar + INT#1; \/\/in the following the case descriptions are missing: CASE iVar OF ELSE xTemp := NOT xTemp; END_CASE 输出在 留言 看法： SA0078：缺少 CASE 分支...", 
"body" : "检测到 CASE 没有的陈述 CASE 分支，只有一个 ELSE 陈述 理由：A CASE 没有 case 的语句会浪费执行时间并且难以阅读。 重要性：中等 例子 PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\n\/\/in the following the case descriptions are missing:\nCASE iVar OF\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n 输出在 留言 看法： SA0078：缺少 CASE 分支 " }, 
{ "title" : "SA0081：上边界不是常数 ", 
"url" : "_san_rule_sa0081.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 声明规则 \/ SA0081：上边界不是常数 ", 
"snippet" : "检测到 FOR 未使用常量值定义上限的语句 理由：如果循环的上限是一个变量值，那么就不再可能看到循环执行的频率。这可能会导致运行时出现严重问题。最坏的情况是无限循环。 重要性：高 例子 PROGRAM PLC_PRG VAR i:INT; iBorder1: INT := 10; iBorder2: INT := 10; iCounter: INT; END_VAR VAR CONSTANT ciBorder:INT := 10; END_VAR FOR i:=0 TO 10 DO \/\/OK iCounter := i; END_FOR FOR i:=0 TO ciBorder DO \/\/ O...", 
"body" : "检测到 FOR 未使用常量值定义上限的语句 理由：如果循环的上限是一个变量值，那么就不再可能看到循环执行的频率。这可能会导致运行时出现严重问题。最坏的情况是无限循环。 重要性：高 例子 PROGRAM PLC_PRG\nVAR\n i:INT;\n iBorder1: INT := 10;\n iBorder2: INT := 10;\n iCounter: INT;\nEND_VAR\nVAR CONSTANT\n ciBorder:INT := 10;\nEND_VAR\n FOR i:=0 TO 10 DO \/\/OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO ciBorder DO \/\/ OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder1 DO \/\/ SA0081\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder2 DO \/\/ SA0081\n iCounter := i;\n IF iCounter = 10 THEN\n iBorder2 := 50;\n END_IF\nEND_FOR\n 输出在 留言 看法： SA0081：for循环的上边界必须是常量值 " }, 
{ "title" : "SA0090：函数结束前的 RETURN 语句 ", 
"url" : "_san_rule_sa0090.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 声明规则 \/ SA0090：函数结束前的 RETURN 语句 ", 
"snippet" : "检测代码位置 RETURN 语句不是函数、方法、属性或程序中的最后一个语句。地点 RETURN 存在于一个 IF 还检测到分支。 理由：A RETURN 在代码中导致代码的可维护性、可测试性和可读性变差。一个 RETURN 在代码中很容易被忽略。每次之前 RETURN ，经常忘记插入退出函数时应始终执行的代码。 重要性：中等 PLCopen规则：CP14 例子 FUNCTION SA0090: DINT VAR_INPUT bTest : BOOL; END_VAR IF bTest THEN RETURN; END_IF SA0090 := 99; 输出在 留言 看法： SA0090：POU...", 
"body" : "检测代码位置 RETURN 语句不是函数、方法、属性或程序中的最后一个语句。地点 RETURN 存在于一个 IF 还检测到分支。 理由：A RETURN 在代码中导致代码的可维护性、可测试性和可读性变差。一个 RETURN 在代码中很容易被忽略。每次之前 RETURN ，经常忘记插入退出函数时应始终执行的代码。 重要性：中等 PLCopen规则：CP14 例子 FUNCTION SA0090: DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR IF bTest THEN\n RETURN;\nEND_IF\nSA0090 := 99; 输出在 留言 看法： SA0090：POU 应具有单出口点 " }, 
{ "title" : "SA0095：条件分配 ", 
"url" : "_san_rule_sa0095.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0095：条件分配 ", 
"snippet" : "检测条件下的分配 IF , CASE ， 或者 REPEAT 结构体 理由：赋值 (:=) 和比较 (=) 很容易被误解。结果，条件中的分配很容易是无意的，因此会被报告。这也会使代码的读者感到困惑。 重要性：高 例子 PROGRAM PLC_PRG VAR iCond1:INT := INT#1; iCond2:INT := INT#2; xCond:BOOL := FALSE; iVar : INT; END_VAR IF INT_TO_BOOL(iCond1 := iCond2) THEN \/\/ SA0095 iCond1 := INT#1; iCond2 := INT#2; ELSIF ...", 
"body" : "检测条件下的分配 IF , CASE ， 或者 REPEAT 结构体 理由：赋值 (:=) 和比较 (=) 很容易被误解。结果，条件中的分配很容易是无意的，因此会被报告。这也会使代码的读者感到困惑。 重要性：高 例子 PROGRAM PLC_PRG\nVAR\n iCond1:INT := INT#1;\n iCond2:INT := INT#2;\n xCond:BOOL := FALSE;\n iVar : INT;\nEND_VAR IF INT_TO_BOOL(iCond1 := iCond2) THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\n ELSIF (iCond1 := 11) = 11 THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF xCond := TRUE THEN \/\/ SA0095\n xCond := FALSE;\nEND_IF\n\nIF (xCond := FALSE) OR (iCond1 := iCond2) = 12 THEN \/\/ SA0095\n xCond := FALSE;\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF (iVar := iVar + 1) = 120 THEN \/\/ SA0095 (can be valid, but is not reparable very well\n iVar := 0;\nEND_IF\n\nWHILE (xCond = TRUE) OR (iCond1 := iCond2) = 12 DO \/\/ SA0095\n xCond := FALSE;\nEND_WHILE\n\n\/\/Error: assignment in repeat loop\nREPEAT\n xCond := FALSE;\nUNTIL (xCond = TRUE) OR (iCond1 := iCond2) = 12 \/\/ SA0095\nEND_REPEAT 输出在 留言 看法： SA0095：条件分配：“...” " }, 
{ "title" : "SA0100: 大于 <n> 字节的变量 ", 
"url" : "_san_rule_sa0100.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0100: 大于 <n> 字节的变量 ", 
"snippet" : "检测使用超过 n 个字节的变量，其中 n 由当前配置定义。默认值：1024 字节。可以通过双击该行来更改该值。 理由：一些编程指南指定了单个变量的最大大小。这可以用这个来检查。 重要性：低 例子 PROGRAM PLC_PRG VAR aobyTest : ARRAY [0..1024] OF BYTE; END_VAR aobyTest[INT#0] := aobyTest[INT#0] + BYTE#1; 输出在 留言 看法： SA0100：变量“aobyTest”大于 1024 字节...", 
"body" : "检测使用超过 n 个字节的变量，其中 n 由当前配置定义。默认值：1024 字节。可以通过双击该行来更改该值。 理由：一些编程指南指定了单个变量的最大大小。这可以用这个来检查。 重要性：低 例子 PROGRAM PLC_PRG\nVAR\n aobyTest : ARRAY [0..1024] OF BYTE;\nEND_VAR\n aobyTest[INT#0] := aobyTest[INT#0] + BYTE#1; 输出在 留言 看法： SA0100：变量“aobyTest”大于 1024 字节 " }, 
{ "title" : "SA0101：名称长度无效 ", 
"url" : "_san_rule_sa0101.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0101：名称长度无效 ", 
"snippet" : "检测长度无效的名称。在里面 项目设置 ，双击规则条目以打开一个对话框，您可以在其中定义名称的长度并定义任何例外。 理由：一些编程指南指定了变量名的最小长度。此分析可用于检查合规性。 重要性：低 PLCopen规则：N6 所有规则都列在 设置静态分析：规则 对话。您可以在其中双击规则 101 以打开特定于规则的配置。然后，您可以定义最小和最大字符数，并在 名称长度 对话。 例子 PROGRAM PLC1 \/\/ SA0101 VAR iVar1 : INT; \/\/ SA0101 END_VAR 输出在 留言 看法： SA0101：名称“PLC1”的长度无效...", 
"body" : "检测长度无效的名称。在里面 项目设置 ，双击规则条目以打开一个对话框，您可以在其中定义名称的长度并定义任何例外。 理由：一些编程指南指定了变量名的最小长度。此分析可用于检查合规性。 重要性：低 PLCopen规则：N6 所有规则都列在 设置静态分析：规则 对话。您可以在其中双击规则 101 以打开特定于规则的配置。然后，您可以定义最小和最大字符数，并在 名称长度 对话。 例子 PROGRAM PLC1 \/\/ SA0101\nVAR\n iVar1 : INT; \/\/ SA0101\nEND_VAR\n 输出在 留言 看法： SA0101：名称“PLC1”的长度无效 " }, 
{ "title" : "SA0102：从外部访问程序\/fb变量 ", 
"url" : "_san_rule_sa0102.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0102：从外部访问程序\/fb变量 ", 
"snippet" : "检测对程序或功能块的局部变量的外部访问。 理由： CODESYS 允许对程序或功能块的局部变量进行外部读取访问。这违背了数据封装（隐藏数据）的原则，不符合IEC 61131-3标准。 重要性：中等 例子 PROGRAM PLC_PRG VAR iCounter : INT; afb_Instance : AFB; bfb_Instance : BFB; END_VAR iCounter := A_PRG.iLocal; \/\/ SA0102 iCounter := bfb_Instance.iLocal; \/\/ SA0102 A_PRG(); FUNCTION_BLOCK AFB VAR_INP...", 
"body" : "检测对程序或功能块的局部变量的外部访问。 理由： CODESYS 允许对程序或功能块的局部变量进行外部读取访问。这违背了数据封装（隐藏数据）的原则，不符合IEC 61131-3标准。 重要性：中等 例子 PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n afb_Instance : AFB;\n bfb_Instance : BFB;\nEND_VAR iCounter := A_PRG.iLocal; \/\/ SA0102\niCounter := bfb_Instance.iLocal; \/\/ SA0102\nA_PRG(); FUNCTION_BLOCK AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iLocal: INT;\nEND_VAR METHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; FUNCTION_BLOCK BFB EXTENDS AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\nEND_VAR\nMETHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; PROGRAM A_PRG\nVAR\n iLocal: INT;\nEND_VAR iLocal := iLocal + 1;\n 输出在 留言 看法： SA0102：从外部访问程序\/fb变量“iLocal” " }, 
{ "title" : "SA0103：对非原子数据的并发访问 ", 
"url" : "_san_rule_sa0103.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0103：对非原子数据的并发访问 ", 
"snippet" : "检测是否非原子变量（例如，具有数据类型 STRING , WSTRING , ARRAY , STRUCT 、FB 实例、64 位数据类型）用于多个任务 理由：在访问过程中没有同步的情况下，在一个任务中读，同时在另一个任务中写入时，可能会读到不一致的值。 重要性：中等 对于某些数据类型，尤其是 64 位整数，访问是否是原子的取决于平台。仅当控制器不支持对 64 位整数数据类型的原子访问时，静态分析才会报告问题。 此规则不适用于以下情况： 如果目标系统有一个浮点单元（FPU），那么多个任务的访问 LREAL 未检测到变量 如果目标系统是 64 位处理器或为目标设备设置了相应的目标设置，则该规则不...", 
"body" : "检测是否非原子变量（例如，具有数据类型 STRING , WSTRING , ARRAY , STRUCT 、FB 实例、64 位数据类型）用于多个任务 理由：在访问过程中没有同步的情况下，在一个任务中读，同时在另一个任务中写入时，可能会读到不一致的值。 重要性：中等 对于某些数据类型，尤其是 64 位整数，访问是否是原子的取决于平台。仅当控制器不支持对 64 位整数数据类型的原子访问时，静态分析才会报告问题。 此规则不适用于以下情况： 如果目标系统有一个浮点单元（FPU），那么多个任务的访问 LREAL 未检测到变量 如果目标系统是 64 位处理器或为目标设备设置了相应的目标设置，则该规则不适用于 64 位数据类型 例子 该项目包含两个程序， PRG1 和 PRG2 . 该程序 PRG1 由任务调用 MainTask_1 .该程序 PRG2 由任务调用 MainTask_2 . VAR_GLOBAL\n lrTest : LREAL; \/\/ Since the target system has an FPU, SA0103 does apply.\n lint1 : LINT;\n sTest : STRING; \/\/ SA0103\n wsTest : WSTRING; \/\/ SA0103\nEND_VAR PROGRAM PRG1 GVL.lrTest := 5.0;\nGVL.sTest := 'welt';\nGVL.wsTest := \"welt\";\nGVL.lint1 := 99;\n PROGRAM PRG2 GVL.lrTest := 5.0;\nGVL.sTest := 'hallo';\nGVL.wsTest := \"hallo\";\nGVL.lint1 := 88; 输出在 留言 看法： SA0103：对非原子数据“sTest”的并发访问 SA0103：对非原子数据“wsTest”的并发访问 " }, 
{ "title" : "SA0105：多个实例调用 ", 
"url" : "_san_rule_sa0105.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0105：多个实例调用 ", 
"snippet" : "检测被多次调用的功能块的实例。为此，必须使用以下编译指示来标记功能块： {attribute 'analysis:report-multiple-instance-calls'} 理由： 某些功能块的设计方式是在一个循环中只能调用一次。此测试检查是否在多个位置进行呼叫。 重要性：低 PLCopen规则：CP16 \/ CP20 例子 \/\/ {attribute 'analysis:report-multiple-instance-calls'} Deactivated FUNCTION_BLOCK FB_DoA VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR i...", 
"body" : "检测被多次调用的功能块的实例。为此，必须使用以下编译指示来标记功能块： {attribute 'analysis:report-multiple-instance-calls'} 理由： 某些功能块的设计方式是在一个循环中只能调用一次。此测试检查是否在多个位置进行呼叫。 重要性：低 PLCopen规则：CP16 \/ CP20 例子 \/\/ {attribute 'analysis:report-multiple-instance-calls'} Deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\n iA := iA + 1; {attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\n iB := iB + 1; PROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nEND_VAR fbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n 输出在 留言 看法： SA0105：多次调用实例“fbB” " }, 
{ "title" : "SA0106：FB_INIT 中的虚拟方法调用 ", 
"url" : "_san_rule_sa0106.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0106：FB_INIT 中的虚拟方法调用 ", 
"snippet" : "检测方法调用 FB_Init 基本功能块的方法，被从基本功能块派生的功能块覆盖 理由：在这些情况下，可能是覆盖方法中的变量未在基础 FB 中初始化。 重要性：高 例子 功能块 FB_A 包括方法 FB_Init 和 Meth_MyInit . FB_Init 来电 Meth_MyInit 用于初始化。功能块 FB_B 来源于 FB_A . PLC_PRG 来电 FB_B 因此使用它的 mbMyDintB 变量在初始化之前。 FB_B.Meth_MyInit 覆盖 FB_A.Meth_MyInit . FUNCTION_BLOCK FB_A VAR mbMyDintA : DINT; END_V...", 
"body" : "检测方法调用 FB_Init 基本功能块的方法，被从基本功能块派生的功能块覆盖 理由：在这些情况下，可能是覆盖方法中的变量未在基础 FB 中初始化。 重要性：高 例子 功能块 FB_A 包括方法 FB_Init 和 Meth_MyInit . FB_Init 来电 Meth_MyInit 用于初始化。功能块 FB_B 来源于 FB_A . PLC_PRG 来电 FB_B 因此使用它的 mbMyDintB 变量在初始化之前。 FB_B.Meth_MyInit 覆盖 FB_A.Meth_MyInit . FUNCTION_BLOCK FB_A\nVAR\n mbMyDintA : DINT;\nEND_VAR FUNCTION_BLOCK FB_B EXTENDS FB_A\nVAR\n mbMyDintB : DINT;\nEND_VAR METHOD FB_Init : BOOL\nVAR_INPUT\n bInitRetains:BOOL;\n bInCopyCode:BOOL;\nEND_VAR\nVAR\n diDummy:DINT; \/\/SA0106\nEND_VAR\n mbMyDintA := 123;\ndiDummy := Meth_MyInit(); METHOD Meth_MyInit : DINT\nVAR_INPUT\nEND_VAR\n mbMyDintB := 123; \/\/access to member of FB_B PROGRAM PLC_PRG\nVAR\n g_BInst : FB_B;\n xVar : BOOL;\nEND_VAR\n\n xVar := g_BInst.fb_init(TRUE, TRUE);\n\/\/this instruction causes the following order of initializations:\n\/\/FB_A.fb_init\n\/\/FB_B.Meth_MyInit \/\/SA0106\n\/\/FB_B.fb_init\n\/\/FB_B.Meth_MyInit 输出在 留言 看法： SA0106：FB_INIT 中的虚拟方法调用“Meth_MyInit” " }, 
{ "title" : "SA0107：缺少形式参数 ", 
"url" : "_san_rule_sa0107.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0107：缺少形式参数 ", 
"snippet" : "检测是否缺少形式参数 理由：在调用中指定形式参数时，代码变得更具可读性。 重要性：低 例子 FUNCTION FUNA : BOOL VAR_INPUT bDo : BOOL; bInit : BOOL; bManual : BOOL; END_VAR VAR iInit : INT; iLocal : INT; iManual : INT; END_VAR IF bInit = TRUE THEN iInit := iInit + 1; END_IF IF bDo = TRUE THEN iLocal := iLocal + 1; END_IF IF bManual = TRUE THEN ...", 
"body" : "检测是否缺少形式参数 理由：在调用中指定形式参数时，代码变得更具可读性。 重要性：低 例子 FUNCTION FUNA : BOOL\nVAR_INPUT\n bDo : BOOL;\n bInit : BOOL;\n bManual : BOOL;\nEND_VAR\nVAR\n iInit : INT;\n iLocal : INT;\n iManual : INT;\nEND_VAR\n IF bInit = TRUE THEN\n iInit := iInit + 1;\nEND_IF\nIF bDo = TRUE THEN\n iLocal := iLocal + 1;\nEND_IF\nIF bManual = TRUE THEN\n iManual := iManual + 1;\nEND_IF\nFUNA := TRUE;\n PROGRAM PLC_PRG\nVAR\nEND_VAR\n FUNA(bInit := TRUE, bDo := TRUE, bManual := FALSE); \/\/ OK\nFUNA(TRUE, TRUE, bManual:= FALSE); \/\/ SA0107 输出在 留言 看法： SA0107：输入“TRUE”缺少形式参数 " }, 
{ "title" : "检查严格的 IEC 规则 ", 
"url" : "_san_check_strict_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0111：指针变量 ", 
"url" : "_san_rule_sa0111.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0111：指针变量 ", 
"snippet" : "检测类型变量 POINTER TO 理由：IEC 61131-3 标准不允许指针。 重要性：低 例子 VAR piTemp : POINTER TO INT; pbyTemp : POINTER TO BYTE; END_VAR 输出在 留言 看法： SA0111：不允许数据类型 POINTER...", 
"body" : "检测类型变量 POINTER TO 理由：IEC 61131-3 标准不允许指针。 重要性：低 例子 VAR\n piTemp : POINTER TO INT;\n pbyTemp : POINTER TO BYTE;\nEND_VAR\n 输出在 留言 看法： SA0111：不允许数据类型 POINTER " }, 
{ "title" : "SA0112：参考变量 ", 
"url" : "_san_rule_sa0112.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0112：参考变量 ", 
"snippet" : "检测类型变量 REFERENCE TO 理由：IEC 61131-3 标准不允许引用。 重要性：低 例子 VAR ref_int : REFERENCE TO INT; ref_dw : REFERENCE TO DWORD; END_VAR 输出在 留言 看法： SA0112：不允许数据类型引用...", 
"body" : "检测类型变量 REFERENCE TO 理由：IEC 61131-3 标准不允许引用。 重要性：低 例子 VAR\n ref_int : REFERENCE TO INT;\n ref_dw : REFERENCE TO DWORD;\nEND_VAR\n 输出在 留言 看法： SA0112：不允许数据类型引用 " }, 
{ "title" : "SA0113：数据类型为 WSTRING 的变量 ", 
"url" : "_san_rule_sa0113.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0113：数据类型为 WSTRING 的变量 ", 
"snippet" : "检测类型变量 WSTRING 理由：并非所有系统都支持 WSTRING .代码更容易移植，无需 WSTRING . 重要性：低 例子 VAR wstrTemp : WSTRING; END_VAR 输出在 留言 看法： SA0113：不允许数据类型 WSTRING...", 
"body" : "检测类型变量 WSTRING 理由：并非所有系统都支持 WSTRING .代码更容易移植，无需 WSTRING . 重要性：低 例子 VAR\n wstrTemp : WSTRING;\nEND_VAR\n 输出在 留言 看法： SA0113：不允许数据类型 WSTRING " }, 
{ "title" : "SA0114：数据类型为 LTIME 的变量 ", 
"url" : "_san_rule_sa0114.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0114：数据类型为 LTIME 的变量 ", 
"snippet" : "检测类型变量 LTIME 理由：并非所有系统都支持 LTIME 代码更容易移植，无需 LTIME . 重要性：低 例子 VAR ltVar : LTIME; \/\/ SA0114 END_VAR 输出在 留言 看法： SA0114：不允许数据类型 LTIME 有关更多信息，请参阅： 属性“分析：报告多实例调用”...", 
"body" : "检测类型变量 LTIME 理由：并非所有系统都支持 LTIME 代码更容易移植，无需 LTIME . 重要性：低 例子 VAR\n ltVar : LTIME; \/\/ SA0114\nEND_VAR\n 输出在 留言 看法： SA0114：不允许数据类型 LTIME 有关更多信息，请参阅： 属性“分析：报告多实例调用” " }, 
{ "title" : "SA0115：数据类型为 UNION 的变量 ", 
"url" : "_san_rule_sa0115.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0115：数据类型为 UNION 的变量 ", 
"snippet" : "检测 a 的声明 UNION 数据类型和变量声明 UNION 类型 理由：IEC 61131-3 标准不包括工会。该代码在没有联合的情况下更容易移植。 重要性：低 例子 TYPE A_UNION: UNION lrTemp : LREAL; liTemp : LINT; END_UNION END_TYPE PROGRAM PLC_PRG VAR aunionVar: A_UNION; liVar : LINT; END_VAR aunionVar.lrTemp := 0.123E-12; liVar := aunionVar.liTemp; 输出在 留言 看法： SA0115：不允许工会...", 
"body" : "检测 a 的声明 UNION 数据类型和变量声明 UNION 类型 理由：IEC 61131-3 标准不包括工会。该代码在没有联合的情况下更容易移植。 重要性：低 例子 TYPE A_UNION: \nUNION\n lrTemp : LREAL;\n liTemp : LINT;\nEND_UNION\nEND_TYPE PROGRAM PLC_PRG\nVAR\n aunionVar: A_UNION;\n liVar : LINT;\nEND_VAR aunionVar.lrTemp := 0.123E-12;\nliVar := aunionVar.liTemp; 输出在 留言 看法： SA0115：不允许工会 " }, 
{ "title" : "SA0117：数据类型为 BIT 的变量 ", 
"url" : "_san_rule_sa0117.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0117：数据类型为 BIT 的变量 ", 
"snippet" : "检测数据类型的变量声明 BIT （可能在结构定义内） 理由：IEC 61131-3 标准不包含数据类型 BIT 。该代码更容易移植，无需 BIT 。 重要性：低 例子 TYPE Struct1 : STRUCT bitVar : BIT; iVar : INT; bVar : BOOL; END_STRUCT END_TYPE 输出在 留言 看法： SA0117：数据类型 BIT 的变量...", 
"body" : "检测数据类型的变量声明 BIT （可能在结构定义内） 理由：IEC 61131-3 标准不包含数据类型 BIT 。该代码更容易移植，无需 BIT 。 重要性：低 例子 TYPE Struct1 :\nSTRUCT\n bitVar : BIT;\n iVar : INT;\n bVar : BOOL;\nEND_STRUCT\nEND_TYPE\n 输出在 留言 看法： SA0117：数据类型 BIT 的变量 " }, 
{ "title" : "SA0119：面向对象的特性 ", 
"url" : "_san_rule_sa0119.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0119：面向对象的特性 ", 
"snippet" : "检测面向对象功能的使用，例如功能块声明 EXTENDS 和 IMPLEMENTS ，或属性和接口声明。当您编写旨在移植到其他符合 IEC 61131-3 的系统的代码时，此规则很有用。 理由：并非所有系统都支持面向对象编程。没有面向对象的代码更容易移植。 重要性：低 例子 \/\/Function block extended by another and implementing an interface: FUNCTION_BLOCK POU EXTENDS CTD IMPLEMENTS ITF \/\/SA0119 ; \/\/ Declaration parts of property metho...", 
"body" : "检测面向对象功能的使用，例如功能块声明 EXTENDS 和 IMPLEMENTS ，或属性和接口声明。当您编写旨在移植到其他符合 IEC 61131-3 的系统的代码时，此规则很有用。 理由：并非所有系统都支持面向对象编程。没有面向对象的代码更容易移植。 重要性：低 例子 \/\/Function block extended by another and implementing an interface:\nFUNCTION_BLOCK POU EXTENDS CTD IMPLEMENTS ITF \/\/SA0119\n;\n \/\/ Declaration parts of property methods assigned to a function block:\nPOU.Prop.Get \/\/SA0119 POU.Prop.Set \/\/SA0119 输出在 留言 看法： SA0119：不允许面向对象的功能 " }, 
{ "title" : "SA0120：程序调用 ", 
"url" : "_san_rule_sa0120.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0120：程序调用 ", 
"snippet" : "检测程序调用 说明：根据IEC 61131-3标准，程序只能在任务配置中调用。当您不从其他位置调用程序时，代码更容易移植。 重要性：低 例子 PROGRAM prog_control VAR END_VAR ; PROGRAM PLC_PRG VAR END_VAR prog_control(); 输出在 留言 看法： SA0120：不允许程序调用“prg_control”...", 
"body" : "检测程序调用 说明：根据IEC 61131-3标准，程序只能在任务配置中调用。当您不从其他位置调用程序时，代码更容易移植。 重要性：低 例子 PROGRAM prog_control\nVAR\nEND_VAR\n; PROGRAM PLC_PRG\nVAR\nEND_VAR\n prog_control(); 输出在 留言 看法： SA0120：不允许程序调用“prg_control” " }, 
{ "title" : "SA0121：缺少 VAR_EXTERNAL 声明 ", 
"url" : "_san_rule_sa0121.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0121：缺少 VAR_EXTERNAL 声明 ", 
"snippet" : "检测功能块中全局变量的使用，而无需将其声明为 VAR_EXTERNAL 理由：根据 IEC 61131-3 标准，只有通过显式导入才允许访问全局变量 VAR_EXTERNAL 宣言。 重要性：低 PLCopen规则：CP18 例子 VAR_GLOBAL iGlob1 : INT; END_VAR PROGRAM PLC_PRG VAR ivar : INT; END_VAR ivar := iGlob1; \/\/ SA0121 输出在 留言 看法： SA0121：变量“iGlob1”需要 VAR_EXTERNAL 声明 避免错误的示例 VAR_GLOBAL iGlob1:INT; END_VAR...", 
"body" : "检测功能块中全局变量的使用，而无需将其声明为 VAR_EXTERNAL 理由：根据 IEC 61131-3 标准，只有通过显式导入才允许访问全局变量 VAR_EXTERNAL 宣言。 重要性：低 PLCopen规则：CP18 例子 VAR_GLOBAL\n iGlob1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar : INT;\nEND_VAR\n ivar := iGlob1; \/\/ SA0121 输出在 留言 看法： SA0121：变量“iGlob1”需要 VAR_EXTERNAL 声明 避免错误的示例 VAR_GLOBAL\n iGlob1:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar:INT;\nEND_VAR\nVAR_EXTERNAL\n iGlob1:INT;\nEND_VAR\n ivar:=iGlob1; \/\/ OK " }, 
{ "title" : "SA0122：数组索引定义为表达式 ", 
"url" : "_san_rule_sa0122.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0122：数组索引定义为表达式 ", 
"snippet" : "检测数组索引声明中表达式的使用 理由：并非所有系统都允许将表达式作为数组限制。 重要性：低 例子 PROGRAM PLC_PRG VAR CONSTANT c_iValue : INT := INT#15; END_VAR VAR arr : ARRAY [0..c_iValue + 1] OF INT; END_VAR 输出在 留言 看法： SA0122：数组定义“arr”只允许使用常量...", 
"body" : "检测数组索引声明中表达式的使用 理由：并非所有系统都允许将表达式作为数组限制。 重要性：低 例子 PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n arr : ARRAY [0..c_iValue + 1] OF INT;\nEND_VAR\n 输出在 留言 看法： SA0122：数组定义“arr”只允许使用常量 " }, 
{ "title" : "SA0123：INI、ADR 或 BITADR 的用法 ", 
"url" : "_san_rule_sa0123.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0123：INI、ADR 或 BITADR 的用法 ", 
"snippet" : "检测使用 CODESYS Static Analysis - 特定的运算符 INI , ADR ， 和 BITADR . 理由： CODESYS - 特定的运算符会阻止代码的可移植性。 重要性：低 例子 PROGRAM PLC_PRG VAR uiTemp : UINT; TempVarInFUNC : DWORD; END_VAR TempVarInFUNC := ADR(uiTemp); \/\/SA0123 输出在 留言 看法： SA0123：不允许运营商“ADR”...", 
"body" : "检测使用 CODESYS Static Analysis - 特定的运算符 INI , ADR ， 和 BITADR . 理由： CODESYS - 特定的运算符会阻止代码的可移植性。 重要性：低 例子 PROGRAM PLC_PRG\nVAR\n uiTemp : UINT;\n TempVarInFUNC : DWORD;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0123 输出在 留言 看法： SA0123：不允许运营商“ADR” " }, 
{ "title" : "SA0147：不寻常的班次操作 -strict ", 
"url" : "_san_rule_sa0147.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0147：不寻常的班次操作 -strict ", 
"snippet" : "检测不对位域数据类型进行的位移操作（ BYTE , WORD , DWORD , LWORD ) 说明：IEC 61131-3 标准只允许对位域数据类型进行位访问。但是，那 CODESYS 编译器还允许对无符号数据类型进行位移操作。 重要性：低 另见严格规则 SA0018 . 例子 PROGRAM PLC_PRG VAR in_byte : BYTE := 16#45; \/\/ 2#01000101 in_word : WORD := 16#0045; \/\/ 2#0000000001000101 in_uint : UINT; in_dint : DINT; erg_byte : BYTE; e...", 
"body" : "检测不对位域数据类型进行的位移操作（ BYTE , WORD , DWORD , LWORD ) 说明：IEC 61131-3 标准只允许对位域数据类型进行位访问。但是，那 CODESYS 编译器还允许对无符号数据类型进行位移操作。 重要性：低 另见严格规则 SA0018 . 例子 PROGRAM PLC_PRG\nVAR\n in_byte : BYTE := 16#45; \/\/ 2#01000101\n in_word : WORD := 16#0045; \/\/ 2#0000000001000101\n in_uint : UINT;\n in_dint : DINT;\n erg_byte : BYTE;\n erg_word : WORD;\n erg_uint : UINT;\n erg_dint : DINT;\n n: BYTE := 2;\nEND_VAR\n erg_byte := SHL(in_byte,n); \/\/ no error because BYTE is a bit field\nerg_word := SHL(in_word,n); \/\/ no error because WORD is a bit field\nerg_uint := SHL(in_uint,n); \/\/ SA0147\nerg_dint := SHL(in_dint,n); \/\/ SA0147 输出在 留言 看法： SA0147：不寻常的轮班操作 - 严格 " }, 
{ "title" : "SA0148：异常位访问 -strict ", 
"url" : "_san_rule_sa0148.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0148：异常位访问 -strict ", 
"snippet" : "检测未对位域数据类型进行的位访问（ BYTE , WORD , DWORD ， 和 LWORD ）。 IEC 61131-3 标准只允许对位域数据类型进行位访问。但是，那 CODESYS 编译器还允许对无符号数据类型进行位访问。 重要性：低 例子 PROGRAM PLC_PRG VAR iTemp1 : INT; diTemp3 : DINT; uliTemp4 : ULINT; siTemp5 : SINT; usiTemp6 : USINT; byTemp2 : BYTE; END_VAR iTemp1.3 := TRUE; \/\/ SA0148 diTemp3.4 := TRUE; \/\/ ...", 
"body" : "检测未对位域数据类型进行的位访问（ BYTE , WORD , DWORD ， 和 LWORD ）。 IEC 61131-3 标准只允许对位域数据类型进行位访问。但是，那 CODESYS 编译器还允许对无符号数据类型进行位访问。 重要性：低 例子 PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/ SA0148\ndiTemp3.4 := TRUE; \/\/ SA0148\nuliTemp4.18 := FALSE; \/\/ SA0148\nsiTemp5.2 := FALSE; \/\/ SA0148\nusiTemp6.3 := TRUE; \/\/ SA0148\nbyTemp2.5 := FALSE; \/\/ no error because BYTE is a bitfield 输出在 留言 看法： SA0148：不寻常的位访问 - 严格 " }, 
{ "title" : "SA0118：不使用常量的初始化 ", 
"url" : "_san_rule_sa0118.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0118：不使用常量的初始化 ", 
"snippet" : "检测未分配常量的初始化 理由：如果可能，初始化应该是常量，并且不应该引用其他变量。特别是，您应该避免在初始化期间调用函数，因为这可能允许访问未初始化的数据。 重要性：中等 例子 PROGRAM PLC_PRG VAR dwTemp : DWORD := 22; dwTest : DWORD := dwTemp; \/\/ SA0118 dwVar : DWORD := TempVarInFUNC(); \/\/ SA0118 END_VAR 输出在 留言 看法： SA0118：不使用常量的初始化...", 
"body" : "检测未分配常量的初始化 理由：如果可能，初始化应该是常量，并且不应该引用其他变量。特别是，您应该避免在初始化期间调用函数，因为这可能允许访问未初始化的数据。 重要性：中等 例子 PROGRAM PLC_PRG\nVAR\n dwTemp : DWORD := 22;\n dwTest : DWORD := dwTemp; \/\/ SA0118\n dwVar : DWORD := TempVarInFUNC(); \/\/ SA0118\nEND_VAR\n 输出在 留言 看法： SA0118：不使用常量的初始化 " }, 
{ "title" : "SA0124：声明中的指针取消引用 ", 
"url" : "_san_rule_sa0124.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0124：声明中的指针取消引用 ", 
"snippet" : "检测用于声明部分初始化的指针取消引用 理由：指针和引用不应该用于初始化，因为如果指针尚未初始化，这可能会导致访问冲突。 重要性：中等 例子 TYPE TESTSTRUCT : STRUCT xA : BOOL; xB : BOOL; END_STRUCT END_TYPE FUNCTION_BLOCK FB_Test VAR_INPUT pTeststruct : POINTER TO TESTSTRUCT; END_VAR VAR xA : BOOL := pTeststruct^.xA; \/\/SA0124 END_VAR xA := TRUE; PROGRAM PLC_PRG VAR fb...", 
"body" : "检测用于声明部分初始化的指针取消引用 理由：指针和引用不应该用于初始化，因为如果指针尚未初始化，这可能会导致访问冲突。 重要性：中等 例子 TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n pTeststruct : POINTER TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := pTeststruct^.xA; \/\/SA0124 \nEND_VAR\n\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); 输出在 留言 看法： SA0124：声明中的指针取消引用 " }, 
{ "title" : "SA0125：初始化中的引用 ", 
"url" : "_san_rule_sa0125.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 检查严格的 IEC 规则 \/ SA0125：初始化中的引用 ", 
"snippet" : "检测声明部分中用于初始化的引用变量 理由：指针和引用不应该用于初始化，因为如果指针尚未初始化，这可能会导致访问冲突。 重要性：中等 例子 TYPE TESTSTRUCT : STRUCT xA : BOOL; xB : BOOL; END_STRUCT END_TYPE FUNCTION_BLOCK FB_Test VAR_INPUT refTeststruct: REFERENCE TO TESTSTRUCT; END_VAR VAR xA : BOOL := refTeststruct.xA; \/\/SA0125 END_VAR xA := TRUE; PROGRAM PLC_PRG VAR...", 
"body" : "检测声明部分中用于初始化的引用变量 理由：指针和引用不应该用于初始化，因为如果指针尚未初始化，这可能会导致访问冲突。 重要性：中等 例子 TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n refTeststruct: REFERENCE TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := refTeststruct.xA; \/\/SA0125\nEND_VAR\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); 输出在 留言 看法： SA0125：初始化时使用的参考 " }, 
{ "title" : "SA0140：注释掉的语句 ", 
"url" : "_san_rule_sa0140.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0140：注释掉的语句 ", 
"snippet" : "检测注释掉的语句 理由：出于调试目的，代码经常被注释掉。当这种注释发布时，以后并不总是清楚代码是否应该被删除，或者它是否出于调试目的而被注释掉并且无意中没有被注释掉。 重要性：高 PLCopen 规则：C4 例子 PROGRAM PLC_PRG VAR iValue1: INT; iValue2: INT; END_VAR iValue1 := 100; iValue2 := 200; \/\/ iValue2 := 300; 输出在 留言 看法： SA0140：注释掉的语句：iValue2 := 300...", 
"body" : "检测注释掉的语句 理由：出于调试目的，代码经常被注释掉。当这种注释发布时，以后并不总是清楚代码是否应该被删除，或者它是否出于调试目的而被注释掉并且无意中没有被注释掉。 重要性：高 PLCopen 规则：C4 例子 PROGRAM PLC_PRG\nVAR\n iValue1: INT;\n iValue2: INT;\nEND_VAR\n iValue1 := 100;\niValue2 := 200;\n\/\/ iValue2 := 300; 输出在 留言 看法： SA0140：注释掉的语句：iValue2 := 300 " }, 
{ "title" : "可能使用未初始化的变量 ", 
"url" : "_san_non_initialized_variables.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 可能使用未初始化的变量 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0039：可能的空指针引用 ", 
"url" : "_san_rule_sa0039.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 可能使用未初始化的变量 \/ SA0039：可能的空指针引用 ", 
"snippet" : "检测可能取消引用空指针的代码位置 理由：在每次取消引用之前应检查指针以确保它不等于零。否则，运行时可能会发生访问冲突。 重要性：高 例子 PROGRAM PLC_PRG VAR ptiVar1:POINTER TO INT; ptiVar2:POINTER TO INT; ptiVar3:POINTER TO INT; iVar:INT; iCount :INT; iCondition: INT; END_VAR iCount := iCount + INT#1; ptiVar1 := ADR(iVar); ptiVar1^ := iCondition; \/\/ OK - valid refer...", 
"body" : "检测可能取消引用空指针的代码位置 理由：在每次取消引用之前应检查指针以确保它不等于零。否则，运行时可能会发生访问冲突。 重要性：高 例子 PROGRAM PLC_PRG\nVAR\n ptiVar1:POINTER TO INT;\n ptiVar2:POINTER TO INT;\n ptiVar3:POINTER TO INT;\n iVar:INT;\n iCount :INT;\n iCondition: INT;\nEND_VAR\n iCount := iCount + INT#1;\nptiVar1 := ADR(iVar);\nptiVar1^ := iCondition; \/\/ OK - valid reference\nptiVar2^ := iCondition; \/\/ SA0039 - null pointer dereferenciation\niVar := ptiVar3^; \/\/ SA0039 - null pointer dereferenciation 输出在 留言 看法： SA0039：可能的空指针引用“ptiVar2^” SA0039：可能的空指针引用“ptiVar3^” " }, 
{ "title" : "SA0046: 可能使用未初始化的接口 ", 
"url" : "_san_rule_sa0046.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 可能使用未初始化的变量 \/ SA0046: 可能使用未初始化的接口 ", 
"snippet" : "检测使用前未初始化的接口的使用情况 理由：接口引用在使用之前应该检查<> 0。否则访问过程中可能会出现访问冲突。 重要性：高 例子 \/\/Declaration of INTERFACE ITF and assigned METH2: METHOD METH2 : BOOL VAR_INPUT iInput2:INT; END_VAR \/\/Declaration of INTERFACE Master_ITF1 and assigned METH: METHOD METH : BOOL VAR_INPUT iInput:INT; END_VAR PROGRAM PLC_PRG VAR instP...", 
"body" : "检测使用前未初始化的接口的使用情况 理由：接口引用在使用之前应该检查<> 0。否则访问过程中可能会出现访问冲突。 重要性：高 例子 \/\/Declaration of INTERFACE ITF and assigned METH2:\nMETHOD METH2 : BOOL\nVAR_INPUT\n iInput2:INT;\nEND_VAR \/\/Declaration of INTERFACE Master_ITF1 and assigned METH:\nMETHOD METH : BOOL\nVAR_INPUT\n iInput:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n instPOU : POU;\n instITF : ITF;\n instMasterITF1 : Master_ITF1;\n instMasterITF2 : Master_ITF2;\n iDummy : INT;\n xDummy : BOOL;\n instNoInitITF : ITF;\n instNoInitITF2 : ITF;\n instNoInitMasterITF1 : Master_ITF1;\n instNoInitMasterITF2 : Master_ITF2;\nEND_VAR instITF := instPOU;\nxDummy := instITF.METH(iInput := iDummy); \/\/ OK\ninstMasterITF1 := instPOU;\nxDummy := instMasterITF1.METH(iInput := iDummy); \/\/ OK\n\nxDummy := instNoInitITF.METH(iInput := INT#1); \/\/ SA0046\nxDummy := instNoInitITF.METH2(iInput2 := INT#2); \/\/ SA0046\nxDummy := instNoInitMasterITF1.METH(iInput := INT#3); \/\/ SA0046\niDummy := instNoInitMasterITF2.Prop; \/\/ SA0046\n\nIF instNoInitITF <> 0 THEN\n instNoInitITF.Prop; \/\/ OK, because the interface can't be 0\nEND_IF 输出在 留言 看法： SA0046：可能使用未初始化的接口“instNoInitITF” SA0046：可能使用未初始化的接口“instNoInitITF” SA0046：可能使用未初始化的接口“instNoInitMasterITF1” SA0046：可能使用未初始化的接口“instNoInitMasterITF2” " }, 
{ "title" : "SA0145：可能使用未初始化的引用 ", 
"url" : "_san_rule_sa0145.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ 可能使用未初始化的变量 \/ SA0145：可能使用未初始化的引用 ", 
"snippet" : "检测任何在使用前可能未初始化且操作员未检查的参考变量 __ISVALIDREF .该规则适用于 POU 的实现部分。对于声明，有规则 SA0124 . 理由：访问前应检查引用的有效性，因为访问期间可能会发生访问冲突。 重要性：高 例子 PROGRAM PLC_PRG VAR_INPUT ref_iTest : REFERENCE TO INT; END_VAR ref_iTest := 99; \/\/ SA0145 IF __ISVALIDREF(ref_iTest) THEN ref_iTest := 88; END_IF 输出在 留言 看法： SA0145：可能使用未初始化的参考“ref_i...", 
"body" : "检测任何在使用前可能未初始化且操作员未检查的参考变量 __ISVALIDREF .该规则适用于 POU 的实现部分。对于声明，有规则 SA0124 . 理由：访问前应检查引用的有效性，因为访问期间可能会发生访问冲突。 重要性：高 例子 PROGRAM PLC_PRG\nVAR_INPUT\n ref_iTest : REFERENCE TO INT;\nEND_VAR\n ref_iTest := 99; \/\/ SA0145\nIF __ISVALIDREF(ref_iTest) THEN\n ref_iTest := 88;\nEND_IF 输出在 留言 看法： SA0145：可能使用未初始化的参考“ref_iTest” " }, 
{ "title" : "SA0150：违反下限或上限或指标 ", 
"url" : "_san_rule_sa0150.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0150：违反下限或上限或指标 ", 
"snippet" : "检测违反下限或上限激活指标的 POU 理由：符合某些指标的代码更易于阅读、更易于维护和更易于测试。 重要性：高 PLCopen规则：CP9 例子 初始情况： 通话次数 指标选择在 项目设置→静态分析→指标 .下限： 0 ;上限： 3 . Prog_1 被调用五次。 运行静态分析时， SA0150：Prog_1 的度量违规。指标调用报告 (5) > 2 在消息视图中发出错误，在 建造 类别。...", 
"body" : "检测违反下限或上限激活指标的 POU 理由：符合某些指标的代码更易于阅读、更易于维护和更易于测试。 重要性：高 PLCopen规则：CP9 例子 初始情况： 通话次数 指标选择在 项目设置→静态分析→指标 .下限： 0 ;上限： 3 . Prog_1 被调用五次。 运行静态分析时， SA0150：Prog_1 的度量违规。指标调用报告 (5) > 2 在消息视图中发出错误，在 建造 类别。 " }, 
{ "title" : "SA0160：递归调用 ", 
"url" : "_san_rule_sa0160.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0160：递归调用 ", 
"snippet" : "检测功能块的动作、方法和属性中的递归调用。还检测来自虚拟函数调用和接口调用的可能递归。 理由：递归会导致不确定的行为，因此是错误的来源。 重要性：中等 PLCopen规则：CP13 例子 下面的方法 Call 分配给功能块 FB_Test ： FUNCTION_BLOCK FB_Test VAR bParameter: BOOL; END_VAR METHOD Call : BOOL VAR_INPUT END_VAR Call := THIS^.Call(); \/\/SA0160 该程序 PLC_PRG 来电 FB_Test ： PROGRAM PLC_PRG VAR fbTest : FB_...", 
"body" : "检测功能块的动作、方法和属性中的递归调用。还检测来自虚拟函数调用和接口调用的可能递归。 理由：递归会导致不确定的行为，因此是错误的来源。 重要性：中等 PLCopen规则：CP13 例子 下面的方法 Call 分配给功能块 FB_Test ： FUNCTION_BLOCK FB_Test\nVAR\n bParameter: BOOL;\nEND_VAR\n METHOD Call : BOOL\nVAR_INPUT\nEND_VAR\n Call := THIS^.Call(); \/\/SA0160 该程序 PLC_PRG 来电 FB_Test ： PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\n bValue : BOOL;\nEND_VAR\n bValue := fbTest.bParameter;\nfbTest.Call(); 输出在 留言 看法： SA0160：检测到递归调用：“PLC_PRG”->“FB_Test.Call”->“FB_Test.Call” " }, 
{ "title" : "SA0161：压缩结构中的未压缩结构 ", 
"url" : "_san_rule_sa0161.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0161：压缩结构中的未压缩结构 ", 
"snippet" : "检测在打包结构中使用的未打包结构 理由：编译器通常将解包结构设置为一个地址，该地址允许对结构内的所有元素进行对齐访问。如果您在打包结构中创建此结构，则不再可能进行对齐访问。此外，访问解压缩结构中的元素可能会导致“未对齐异常”。 重要性：高 例子 结构 structSingleDataRecord 已打包，但它包含未打包的结构 struct4Byte 和 struct9Byte . {attribute 'pack_mode' := '1'} TYPE structSingleDataRecord : STRUCT str9ByteData: struct9Byte; (* 9 BYTE *) ...", 
"body" : "检测在打包结构中使用的未打包结构 理由：编译器通常将解包结构设置为一个地址，该地址允许对结构内的所有元素进行对齐访问。如果您在打包结构中创建此结构，则不再可能进行对齐访问。此外，访问解压缩结构中的元素可能会导致“未对齐异常”。 重要性：高 例子 结构 structSingleDataRecord 已打包，但它包含未打包的结构 struct4Byte 和 struct9Byte . {attribute 'pack_mode' := '1'}\nTYPE structSingleDataRecord :\nSTRUCT\n str9ByteData: struct9Byte; (* 9 BYTE *)\n str4ByteData: struct4Byte; (* 4 BYTE *)\n udi1: UDINT;\n udi2: UDINT;\n udi3: UDINT;\n usi4: USINT;\nEND_STRUCT\nEND_TYPE (* 9 BYTE *)\nTYPE struct9Byte :\nSTRUCT\n usiRotorSlots: USINT; (* 1 BYTE *)\n uiMaxCurrent: UINT; (* 2 BYTE *)\n usiVelocity: USINT; (* 1 BYTE *)\n uiAcceleration: UINT; (* 2 BYTE *)\n uiDeceleration: UINT; (* 2 BYTE *)\n usiDirectionChange: USINT; (* 1 BYTE *)\nEND_STRUCT\nEND_TYPE TYPE struct4Byte :\nSTRUCT\n \/\/udiDummy : UDINT;\n rRealDummy : REAL;\nEND_STRUCT\nEND_TYPE 输出在 留言 看法： SA0161：在打包结构“structSingleDataRecord”内声明未打包结构“struct9ByteData” SA0161：在打包结构“structSingleDataRecord”内声明未打包结构“struct4ByteData” " }, 
{ "title" : "SA0162：缺少注释 ", 
"url" : "_san_rule_sa0162.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0162：缺少注释 ", 
"snippet" : "检测程序中未注释的位置 理由：许多编程指南都要求完整的注释，它增加了代码的可读性和可维护性。 重要性：低 PLCopen 规则：C2 在以下情况下需要注释： 对于变量的声明。评论位于上方或右侧。 用于程序、功能块或方法的声明。注释位于声明上方（第一行）。 例子 PROGRAM PLC_PRG VAR iMaxValue: INT; END_VAR 输出在 留言 看法： SA0162：缺少“PLC_PRG”的注释 SA0162：缺少“iMaxValue”的评论...", 
"body" : "检测程序中未注释的位置 理由：许多编程指南都要求完整的注释，它增加了代码的可读性和可维护性。 重要性：低 PLCopen 规则：C2 在以下情况下需要注释： 对于变量的声明。评论位于上方或右侧。 用于程序、功能块或方法的声明。注释位于声明上方（第一行）。 例子 PROGRAM PLC_PRG\nVAR\n iMaxValue: INT;\nEND_VAR\n 输出在 留言 看法： SA0162：缺少“PLC_PRG”的注释 SA0162：缺少“iMaxValue”的评论 " }, 
{ "title" : "SA0163：嵌套注释 ", 
"url" : "_san_rule_sa0163.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0163：嵌套注释 ", 
"snippet" : "检测嵌套评论 理由：应避免嵌套注释，因为它们难以阅读。 重要性：低 PLCopen 规则：C3 例子 {attribute 'do-analysis'} (* That is (* nested comment 1 *) *) PROGRAM PLC_PRG VAR (* That is \/\/ nested comment 2 comment *) iVal1: INT; iVal2: INT; (* That is (* nested comment 3 *) *) pVal3: POINTER TO DWORD; hugo: INT; END_VAR (* That is \/\/ neste...", 
"body" : "检测嵌套评论 理由：应避免嵌套注释，因为它们难以阅读。 重要性：低 PLCopen 规则：C3 例子 {attribute 'do-analysis'}\n(* That is\n(* nested comment 1 *)\n*)\nPROGRAM PLC_PRG\nVAR\n(* That is\n\/\/ nested comment 2\ncomment *)\n iVal1: INT;\n iVal2: INT;\n\n(* That is\n(* nested comment 3 *) *)\n pVal3: POINTER TO DWORD;\n hugo: INT;\nEND_VAR\n (* That is\n\/\/ nested comment 4\ncomment *)\niVal1 := iVal1 + 1;\n(* That is\n(* nested comment 5 *)\n*)\n\n(* Not that one *) 输出在 留言 看法： SA0163：嵌套评论“嵌套评论 1” SA0163：嵌套评论“嵌套评论 2” SA0163：嵌套评论“嵌套评论 3” SA0163：嵌套评论“嵌套评论 4” SA0163：嵌套评论“嵌套评论 5” " }, 
{ "title" : "SA0164：多行注释 ", 
"url" : "_san_rule_sa0164.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0164：多行注释 ", 
"snippet" : "检测编码为的多行注释 (* comment *) .仅编码为的单行注释 \/\/ comment 被允许。 理由：一些编程指南禁止代码中的多行注释，因为注释的开头和结尾可能会丢失，并且结束注释括号可能会被意外删除。 您可以通过编译指示停用此检查 analysis ，也用于声明部分的注释。 重要性：低 PLCopen规则：C5 例子 {attribute 'do-analysis'} (* This is a multi-line comment \/\/ SA0164 *) PROGRAM PLC_PRG VAR \/\/ This is a single line comment a: DINT; EN...", 
"body" : "检测编码为的多行注释 (* comment *) .仅编码为的单行注释 \/\/ comment 被允许。 理由：一些编程指南禁止代码中的多行注释，因为注释的开头和结尾可能会丢失，并且结束注释括号可能会被意外删除。 您可以通过编译指示停用此检查 analysis ，也用于声明部分的注释。 重要性：低 PLCopen规则：C5 例子 {attribute 'do-analysis'}\n(*\n This is a multi-line comment \/\/ SA0164\n*)\nPROGRAM PLC_PRG\nVAR\n\/\/ This is a single line comment\n a: DINT;\nEND_VAR\n (* This is not a single line comment *) \/\/ SA0164\na := a + 1; 输出在 留言 看法： SA0164：仅使用单行注释 " }, 
{ "title" : "SA0165：调用其他 POU 而非程序的任务 ", 
"url" : "_san_rule_sa0165.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0165：调用其他 POU 而非程序的任务 ", 
"snippet" : "检测调用功能块或函数而不是程序的任务 理由：此规则是 PLCopen 编码指南的一部分。因此，还检查了合规性 CODESYS .我们没有看到任何数据一致性问题 CODESYS 如果任务会调用程序以外的 POU。但是，如果要将代码移植到其他平台，则可能会出现问题。 重要性：低 PLCopen规则：CP16 任务被插入到任务配置下方。要调用的 POU 在任务中配置。 POU 必须是 程序 类型。这 功能块 和 功能 类型是不允许的。 例子...", 
"body" : "检测调用功能块或函数而不是程序的任务 理由：此规则是 PLCopen 编码指南的一部分。因此，还检查了合规性 CODESYS .我们没有看到任何数据一致性问题 CODESYS 如果任务会调用程序以外的 POU。但是，如果要将代码移植到其他平台，则可能会出现问题。 重要性：低 PLCopen规则：CP16 任务被插入到任务配置下方。要调用的 POU 在任务中配置。 POU 必须是 程序 类型。这 功能块 和 功能 类型是不允许的。 例子 " }, 
{ "title" : "SA0166：最大。输入\/输出\/输入输出变量的数量... ", 
"url" : "_san_rule_sa0166.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0166：最大。输入\/输出\/输入输出变量的数量... ", 
"snippet" : "检测是否有定义数量的输入变量 ( VAR_INPUT ), 输出变量 ( VAR_OUTPUT ） 或者 VAR_IN_OUT 在 POU 中超出变量。在里面 项目设置 ，双击规则条目以打开一个对话框，您可以在其中定义最大数量。 理由：这是关于检查个人编程指南。许多编程指南都规定了 POU 参数的最大数量。太多的参数使代码不可读，POU 难以测试。 重要性：中等 PLCopen规则：CP23 例子 在项目设置中，对于规则 166，您定义了最大数量的 1 为了 VAR_IN_OUT 变量。 FUNCTION_BLOCK FB1 VAR_INPUT xIn : BOOL; END_VAR VAR_...", 
"body" : "检测是否有定义数量的输入变量 ( VAR_INPUT ), 输出变量 ( VAR_OUTPUT ） 或者 VAR_IN_OUT 在 POU 中超出变量。在里面 项目设置 ，双击规则条目以打开一个对话框，您可以在其中定义最大数量。 理由：这是关于检查个人编程指南。许多编程指南都规定了 POU 参数的最大数量。太多的参数使代码不可读，POU 难以测试。 重要性：中等 PLCopen规则：CP23 例子 在项目设置中，对于规则 166，您定义了最大数量的 1 为了 VAR_IN_OUT 变量。 FUNCTION_BLOCK FB1\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nVAR_IN_OUT\n xInOut1 : BOOL;\n xInOut2 : BOOL;\nEND_VAR\n 输出在 留言 看法： SA0166：POU“FB1”中的 VAR_IN_OUT 变量太多 " }, 
{ "title" : "SA0167：临时功能块实例 ", 
"url" : "_san_rule_sa0167.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0167：临时功能块实例 ", 
"snippet" : "检查检测声明为临时变量的功能块实例。这会影响在方法或函数中声明的实例，或者 VAR_TEMP ，因此在每个处理周期或每个 POU 调用中重新初始化。 理由： 功能块的状态通常在多个 PLC 周期内维持。堆栈上的实例仅在函数调用期间存在。因此，创建实例作为临时变量几乎没有意义。 其次，功能块实例通常很大，并且需要大量堆栈空间（通常仅限于控制器）。 第三，功能块的初始化以及通常的调度可能需要很长时间。 重要性：中等 例子 PROGRAM PLC_PRG VAR END_VAR VAR_TEMP yafb: AFB; END_VAR FUNCTION Fun : INT VAR_INPUT END_...", 
"body" : "检查检测声明为临时变量的功能块实例。这会影响在方法或函数中声明的实例，或者 VAR_TEMP ，因此在每个处理周期或每个 POU 调用中重新初始化。 理由： 功能块的状态通常在多个 PLC 周期内维持。堆栈上的实例仅在函数调用期间存在。因此，创建实例作为临时变量几乎没有意义。 其次，功能块实例通常很大，并且需要大量堆栈空间（通常仅限于控制器）。 第三，功能块的初始化以及通常的调度可能需要很长时间。 重要性：中等 例子 PROGRAM PLC_PRG\nVAR\nEND_VAR\nVAR_TEMP\n yafb: AFB;\nEND_VAR FUNCTION Fun : INT\nVAR_INPUT\nEND_VAR\nVAR\n funafb: AFB;\nEND_VAR\n METHOD METH : INT\nVAR_INPUT\nEND_VAR\nVAR\n methafb: AFB; \/\/ SA0167\nEND_VAR 输出在 留言 看法： SA0167：临时功能块实例：“methafb” " }, 
{ "title" : "SA0168：不必要的分配 ", 
"url" : "_san_rule_sa0168.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0168：不必要的分配 ", 
"snippet" : "检测对代码没有任何影响的变量的赋值。 理由：当值被多次赋值给一个变量而没有在赋值之间评估变量时，第一次赋值对程序没有任何影响。 重要性：低 例子 PROGRAM PLC_PRG VAR dwVal1 : DWORD; dwVal2 : DWORD; END_VAR \/\/ unnecessary assignment dwVal1 := 1; IF dwVal2 > 100 THEN dwVal2 := 0; dwVal2 := dwVal2 + 1; END_IF dwVal1 := 2; 输出在 留言 看法： SA0168：变量“dwVal1”已分配，但从未使用其值。...", 
"body" : "检测对代码没有任何影响的变量的赋值。 理由：当值被多次赋值给一个变量而没有在赋值之间评估变量时，第一次赋值对程序没有任何影响。 重要性：低 例子 PROGRAM PLC_PRG\nVAR\n dwVal1 : DWORD;\n dwVal2 : DWORD;\nEND_VAR\n \/\/ unnecessary assignment\ndwVal1 := 1; \nIF dwVal2 > 100 THEN\n dwVal2 := 0;\n dwVal2 := dwVal2 + 1;\nEND_IF\ndwVal1 := 2; 输出在 留言 看法： SA0168：变量“dwVal1”已分配，但从未使用其值。 " }, 
{ "title" : "SA0169：忽略的输出 ", 
"url" : "_san_rule_sa0169.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0169：忽略的输出 ", 
"snippet" : "检测调用方法或函数时未指定的方法和函数的输出。 理由：忽略的输出可能是关于未处理错误或无意义函数调用的通知，因为未使用结果。 重要性：中等 例子 FUNCTION Fun1 VAR_INPUT bIn : BOOL; VAR_END VAR_OUTPUT bOut : BOOL; END_VA ; PROGRAM PLC_PRG VAR bValue :BOOl; END_VAR Fun1(bIn : TRUE); 输出在 留言 看法： SA0169：调用时输出“bOut”被忽略...", 
"body" : "检测调用方法或函数时未指定的方法和函数的输出。 理由：忽略的输出可能是关于未处理错误或无意义函数调用的通知，因为未使用结果。 重要性：中等 例子 FUNCTION Fun1\nVAR_INPUT\n bIn : BOOL;\nVAR_END\nVAR_OUTPUT\n bOut : BOOL;\nEND_VA\n ; PROGRAM PLC_PRG\nVAR\n bValue :BOOl;\nEND_VAR\n Fun1(bIn : TRUE);\n 输出在 留言 看法： SA0169：调用时输出“bOut”被忽略 " }, 
{ "title" : "SA0170：不应使用输出变量的地址 ", 
"url" : "_san_rule_sa0170.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0170：不应使用输出变量的地址 ", 
"snippet" : "检测输出变量地址所在的代码位置（ VAR_OUTPUT , VAR_IN_OUT 使用功能块的 )。 理由： 不允许按以下方式使用功能块输出的地址： 通过 ADR 操作员 通过 REF= 例外：如果在同一功能块中使用输出变量，则不会报告错误。 重要性：中等 例子 功能块 FB1 有 VAR_OUTPUT 多变的 iOutVal : INT; 另一个 POU 中的以下访问会生成错误 SA0170： \/\/FB1_inst is of type FB1 addr1 := ADR(FB1_inst.iOutVal); \/\/SA0170 refINT REF= FB1_inst.iOutVal; \/\/S...", 
"body" : "检测输出变量地址所在的代码位置（ VAR_OUTPUT , VAR_IN_OUT 使用功能块的 )。 理由： 不允许按以下方式使用功能块输出的地址： 通过 ADR 操作员 通过 REF= 例外：如果在同一功能块中使用输出变量，则不会报告错误。 重要性：中等 例子 功能块 FB1 有 VAR_OUTPUT 多变的 iOutVal : INT; 另一个 POU 中的以下访问会生成错误 SA0170： \/\/FB1_inst is of type FB1\naddr1 := ADR(FB1_inst.iOutVal); \/\/SA0170\nrefINT REF= FB1_inst.iOutVal; \/\/SA0179\n 下面直接访问内 FB1 功能块也会产生错误： \/\/other is a POINTER TO FB1\nptr := ADR(other^.iOutVal); \/\/SA0170 下面直接访问内 FB1 功能块不会产生错误： \/\/iInputVal is a VAR_INPUT of FB1\niOutVal := iInputVal; \n\/\/ptr is a POINTER TO INT\nptr := ADR(THIS^.iOutVal); \nptr := ADR(iOutVal); 输出在 留言 看法： SA0170：不应采用输出变量的地址 " }, 
{ "title" : "SA0171：枚举应具有“strict”属性 ", 
"url" : "_san_rule_sa0171.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0171：枚举应具有“strict”属性 ", 
"snippet" : "检测未提供的枚举声明 {attribute 'strict'} 属性。 理由： {attribute 'strict'} 如果代码违反了严格的枚举编程规则，属性会导致编译器错误。默认情况下，创建新枚举时，声明会自动分配 'strict' 属性。 有关更多信息，请参阅： 数据类型：枚举 重要性：高 例子 TYPE COLOR : ( red, green, blue ); END_TYPE 输出在 留言 看法： SA0171：枚举应具有“严格”属性 不违反编程规则： {attribute 'qualified_only'} {attribute 'strict'} TYPE COLOR : ( ...", 
"body" : "检测未提供的枚举声明 {attribute 'strict'} 属性。 理由： {attribute 'strict'} 如果代码违反了严格的枚举编程规则，属性会导致编译器错误。默认情况下，创建新枚举时，声明会自动分配 'strict' 属性。 有关更多信息，请参阅： 数据类型：枚举 重要性：高 例子 TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE 输出在 留言 看法： SA0171：枚举应具有“严格”属性 不违反编程规则： {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE " }, 
{ "title" : "SA0172：可能尝试访问数组边界之外 ", 
"url" : "_san_rule_sa0172.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0172：可能尝试访问数组边界之外 ", 
"snippet" : "检测对数组边界之外的数组索引的可能访问。 通常会超出数组索引的范围 FOR 循环，其中索引变量用于访问数组索引。 重要性：高 例子 PROGRAM Test VAR_TEMP iIndex: INT; arUSINT: Array[0..10] OF INT; END_VAR FOR iIndex := INT#0 TO INT#50 DO arUSINT[iIndex] := 0; END_FOR 输出在 留言 看法： SA0172：可能尝试访问数组边界之外...", 
"body" : "检测对数组边界之外的数组索引的可能访问。 通常会超出数组索引的范围 FOR 循环，其中索引变量用于访问数组索引。 重要性：高 例子 PROGRAM Test\nVAR_TEMP\n iIndex: INT;\n arUSINT: Array[0..10] OF INT;\nEND_VAR\n FOR iIndex := INT#0 TO INT#50 DO\n arUSINT[iIndex] := 0;\nEND_FOR 输出在 留言 看法： SA0172：可能尝试访问数组边界之外 " }, 
{ "title" : "SA0175：对字符串的可疑操作 ", 
"url" : "_san_rule_sa0175.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0175：对字符串的可疑操作 ", 
"snippet" : "不要总是启用此规则。仅在必要时启用该规则，以查找转换为 UTF-8 编码时应检查的代码中的位置。 检查项目选项是否 字符串的 UTF-8 编码 可以启用。当没有找到具有可疑操作的代码位置时就是这种情况。 切换到 UTF-8 编码时，前 127 个字符对应 ASCII 编码。但是，所有其他字符都使用多于一个字节进行编码。这可能会导致处理字符串时的行为发生变化。因此，包含非 ASCII 字符的字符串文字可能会变得更长。或者通过索引访问字符串可以访问错误的元素。最后，甚至会发生对无效字节偏移的访问。 当规则处于活动状态时，将报告包含以下任何构造的所有代码位置： 对字节字符串的索引访问 例子： str...", 
"body" : "不要总是启用此规则。仅在必要时启用该规则，以查找转换为 UTF-8 编码时应检查的代码中的位置。 检查项目选项是否 字符串的 UTF-8 编码 可以启用。当没有找到具有可疑操作的代码位置时就是这种情况。 切换到 UTF-8 编码时，前 127 个字符对应 ASCII 编码。但是，所有其他字符都使用多于一个字节进行编码。这可能会导致处理字符串时的行为发生变化。因此，包含非 ASCII 字符的字符串文字可能会变得更长。或者通过索引访问字符串可以访问错误的元素。最后，甚至会发生对无效字节偏移的访问。 当规则处于活动状态时，将报告包含以下任何构造的所有代码位置： 对字节字符串的索引访问 例子： str[2] 信息： SA0175：具有属性“strict”的枚举：对字符串的可疑操作：索引访问“<表达式>” 对单字节字符串的地址访问 例子： ADR(str) 信息： SA0175：具有属性“strict”的枚举：对字符串的可疑操作：可能的索引访问“<表达式>” 调用字符串函数 Standard 库，除非调用 CONCAT 和 LEN 功能 信息： SA0175：具有属性“strict”的枚举：对字符串的可疑操作：可能的索引访问“<表达式>” 包含非 ASCII 字符的字节文字 例子： str := '99€';\nstr :='Ä'; 信息： SA0175：对字符串的可疑操作：文字“<literal>”包含非 ASCII 字符 " }, 
{ "title" : "SA0180：索引范围未覆盖整个数组 ", 
"url" : "_san_rule_sa0180.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 规则 \/ SA0180：索引范围未覆盖整个数组 ", 
"snippet" : "检测索引范围不完全覆盖的数组 数组通常在循环中处理，其中循环索引对数组进行索引，以便数组的所有组件都可以无间隙地跳转到。如果循环索引和数组索引在所有维度上都相同，则给出此值。如果索引范围没有完全覆盖数组，则表明数组中存在未处理的组件。 重要性：中 例子 {attribute 'do-analysis'} PROGRAM PLC_PRG VAR a : INT; arWord : ARRAY [0..100] OF WORD; END_VAR \/\/Implementation FOR a := INT#1 TO INT#100 BY 1 DO \/\/SA0180: Lower range is n...", 
"body" : "检测索引范围不完全覆盖的数组 数组通常在循环中处理，其中循环索引对数组进行索引，以便数组的所有组件都可以无间隙地跳转到。如果循环索引和数组索引在所有维度上都相同，则给出此值。如果索引范围没有完全覆盖数组，则表明数组中存在未处理的组件。 重要性：中 例子 {attribute 'do-analysis'}\nPROGRAM PLC_PRG\nVAR\n a : INT;\n arWord : ARRAY [0..100] OF WORD;\nEND_VAR\n\/\/Implementation\nFOR a := INT#1 TO INT#100 BY 1 DO \/\/SA0180: Lower range is not reached\n\tarWord[a] := INT_TO_WORD(a);\nEND_FOR;\n;\n 输出在 留言 看法： SA0180：索引范围未覆盖整个数组 " }, 
{ "title" : "指标 ", 
"url" : "_san_reference_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 ", 
"snippet" : "提供的指标的详细描述 CODESYS Static Analysis 这 代码大小 , 尺寸可变 , 堆栈大小 ， 和 通话次数 仅报告项目中集成的库中的 POU 的指标。...", 
"body" : "提供的指标的详细描述 CODESYS Static Analysis 这 代码大小 , 尺寸可变 , 堆栈大小 ， 和 通话次数 仅报告项目中集成的库中的 POU 的指标。 " }, 
{ "title" : "指标：代码大小（字节数） ", 
"url" : "_san_reference_metrics.html#UUID-35adc4d5-9253-44d6-f130-aab7171bff69", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：代码大小（字节数） ", 
"snippet" : "代码大小（字节数） 类别： 信息丰富、效率 功能块为应用程序代码贡献的字节数 该数量还取决于代码生成器。例如，ARM 处理器的代码生成器通常比 x86 处理器的代码生成器生成更多字节。...", 
"body" : "代码大小（字节数） 类别： 信息丰富、效率 功能块为应用程序代码贡献的字节数 该数量还取决于代码生成器。例如，ARM 处理器的代码生成器通常比 x86 处理器的代码生成器生成更多字节。 " }, 
{ "title" : "指标：可变大小（字节数） ", 
"url" : "_san_reference_metrics.html#UUID-b07882e2-be28-fe1e-eb10-ed5defcf3c74", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：可变大小（字节数） ", 
"snippet" : "可变大小（字节数） 类别 ：信息丰富、高效 对象使用的静态内存的大小 对于功能块，这是用于功能块实例的大小（可能包括内存间隙，具体取决于内存对齐）。对于程序、函数和全局变量列表，这是所有静态变量的大小之和。 例子 FUNCTION FUN1 : INT VAR_INPUT a,b : INT; END_VAR VAR c,d : INT; END_VAR VAR_STAT f,g,h : INT; END_VAR 该函数有 3 个类型的静态变量 INT (f , g ， 和 h ），每个需要2个字节的内存。因此， FUN1 具有 6 个字节的可变大小。...", 
"body" : "可变大小（字节数） 类别 ：信息丰富、高效 对象使用的静态内存的大小 对于功能块，这是用于功能块实例的大小（可能包括内存间隙，具体取决于内存对齐）。对于程序、函数和全局变量列表，这是所有静态变量的大小之和。 例子 FUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR 该函数有 3 个类型的静态变量 INT (f , g ， 和 h ），每个需要2个字节的内存。因此， FUN1 具有 6 个字节的可变大小。 " }, 
{ "title" : "指标：堆栈大小（字节数） ", 
"url" : "_san_reference_metrics.html#UUID-52e032c0-e190-f5c0-344b-e6c04694a3ef", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：堆栈大小（字节数） ", 
"snippet" : "堆栈大小（字节数） 类别 ：信息丰富、高效、可靠 调用函数或功能块所需的字节数 输入变量和输出变量与内存对齐。这可能会在这些变量和局部变量之间产生间隙。这个差距是被计算在内的。 不适合寄存器的被调用函数的返回值将被压入堆栈。这些值中的最大值决定了额外分配的内存，这也很重要。在所考虑的 POU 内调用的函数或函数块有自己的堆栈帧。因此，此类调用的内存不算在内。 根据所使用的代码生成器，计算的中间结果也使用堆栈。这些结果不计算在内。 例子 \/\/Declaration FUNCTION FUN1 : INT VAR_INPUT a,b : INT; END_VAR VAR c,d,e : INT; ...", 
"body" : "堆栈大小（字节数） 类别 ：信息丰富、高效、可靠 调用函数或功能块所需的字节数 输入变量和输出变量与内存对齐。这可能会在这些变量和局部变量之间产生间隙。这个差距是被计算在内的。 不适合寄存器的被调用函数的返回值将被压入堆栈。这些值中的最大值决定了额外分配的内存，这也很重要。在所考虑的 POU 内调用的函数或函数块有自己的堆栈帧。因此，此类调用的内存不算在内。 根据所使用的代码生成器，计算的中间结果也使用堆栈。这些结果不计算在内。 例子 \/\/Declaration\nFUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d,e : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR\n\n\/\/Implementation\nc := b;\nd := a;\ne := a+b; 假设：对于计算，假设 CODESYS Control Win 它使用 x86 代码生成器。 上面的示例的调用者大小为 8 个字节：两个为 4 个字节 INT inputs 和 4 个字节的返回值。该设备的堆栈对齐为 4 字节，因此存在 2 字节的间隙。调用者大小为 8 个字节：三个局部变量，每个变量 2 个字节，加上用于堆栈对齐的 2 个字节间隙。结果，总堆栈大小为 FUN1 是16字节。 VAR_STAT 不存储在堆栈中，因此不会增加 POU 的堆栈大小。 " }, 
{ "title" : "指标：调用次数（Calls） ", 
"url" : "_san_reference_metrics.html#UUID-652fc3dc-10b7-711b-cea7-9b006e6249b5", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：调用次数（Calls） ", 
"snippet" : "通话次数（次） 类别 ：信息丰富 下 POU 的调用次数 节目单位 例子 \/\/Declaration PLC_PRG PROGRAM PLC_PRG VAR myFB : FB1; END_VAR \/\/Implementation myFB(b := FALSE); \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR_INPUT b : BOOL; END_VAR VAR i : INT; END_VAR \/\/Implementation METH(i); IF b THEN METH(i*i); END_IF \/\/Declaration FB1.METH MET...", 
"body" : "通话次数（次） 类别 ：信息丰富 下 POU 的调用次数 节目单位 例子 \/\/Declaration PLC_PRG\nPROGRAM PLC_PRG\nVAR\n myFB : FB1;\nEND_VAR\n\n\/\/Implementation\nmyFB(b := FALSE); \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR_INPUT\n b : BOOL;\nEND_VAR\nVAR\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH(i);\nIF b THEN\n METH(i*i);\nEND_IF\n \/\/Declaration FB1.METH\nMETHOD METH : BOOL\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := i >= 42; 如果 PLC_PRG 在一个任务中被调用，那么这个调用也被统计在内。 FB1 仅有一个调用（在 PLC_PRG ）。 METH 有两个电话，都在 FB1 。 " }, 
{ "title" : "指标：任务（Tasks）的调用次数 ", 
"url" : "_san_reference_metrics.html#UUID-3768e9b9-fdef-e8c5-d81a-3ab94c3eed82", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：任务（Tasks）的调用次数 ", 
"snippet" : "任务（任务）调用次数 类别 ：可维护性、可靠性 任务数量（ 任务 ）其中指定的 POU 节目单位 叫做 对于功能块，计算调用功能块本身或功能块继承树中的任何功能块的任务数量。 对于方法和操作，会显示调用（父）功能块的任务数。 例子 FUNCTION_BLOCK FB \/\/... FUNCTION_BLOCK FB2 EXTENDS FB \/\/... FUNCTION_BLOCK FB3 EXTENDS FB2 \/\/... 每个功能块都有自己的调用 PROGRAM 。每个 PROGRAM 有它自己的任务。 这 在任务中调用 指标返回 1 为 FB3 和 2 为 FB2 因为来自的电话 FB3 和...", 
"body" : "任务（任务）调用次数 类别 ：可维护性、可靠性 任务数量（ 任务 ）其中指定的 POU 节目单位 叫做 对于功能块，计算调用功能块本身或功能块继承树中的任何功能块的任务数量。 对于方法和操作，会显示调用（父）功能块的任务数。 例子 FUNCTION_BLOCK FB\n\/\/... FUNCTION_BLOCK FB2 EXTENDS FB\n\/\/... FUNCTION_BLOCK FB3 EXTENDS FB2\n\/\/... 每个功能块都有自己的调用 PROGRAM 。每个 PROGRAM 有它自己的任务。 这 在任务中调用 指标返回 1 为 FB3 和 2 为 FB2 因为来自的电话 FB3 和 FB2 被计算在内。该指标结果为 3 FB 因为在这种情况下，来自的电话 FB3 , FB2 ， 和 FB 被计算在内。 " }, 
{ "title" : "指标：使用的全局变量的数量（Globals） ", 
"url" : "_san_reference_metrics.html#UUID-04068c53-4046-0979-468b-866b1a155a8a", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：使用的全局变量的数量（Globals） ", 
"snippet" : "使用的全局变量数量（Globals） 类别 ：可维护性、可重用性 下 POU 中使用的全局变量数量 节目单位 例子 \/\/GVL VAR_GLOBAL gvla : INT; gvlb : INT; gvlc : INT; END_VAR \/PRG declaration PROGRAM PRG VAR x : INT := GVL.gvlc; y : INT; END_VAR \/\/PRG implementation x := GVL.gvla; y := GVL.gvla*GVL.gvlb; 这 PRG 程序使用 3 个变量 GVL : gvla , gvlb ， 和 gvlc 。...", 
"body" : "使用的全局变量数量（Globals） 类别 ：可维护性、可重用性 下 POU 中使用的全局变量数量 节目单位 例子 \/\/GVL\nVAR_GLOBAL\n gvla : INT;\n gvlb : INT;\n gvlc : INT;\nEND_VAR \/PRG declaration\nPROGRAM PRG\nVAR\n x : INT := GVL.gvlc;\n y : INT;\nEND_VAR\n\n\/\/PRG implementation\nx := GVL.gvla;\ny := GVL.gvla*GVL.gvlb; 这 PRG 程序使用 3 个变量 GVL : gvla , gvlb ， 和 gvlc 。 " }, 
{ "title" : "指标：直接地址访问 (IO) 数量 ", 
"url" : "_san_reference_metrics.html#UUID-792a6162-1022-f930-dadb-104aa5a51709", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：直接地址访问 (IO) 数量 ", 
"snippet" : "直接地址访问 (IO) 数量 类别 ：可重用性、可维护性 直接地址访问次数（ IO ）在对象的实现中。 例子 \/\/Declaration PROGRAM PRG VAR xVar : BOOL:= %IX0.0; \/\/ +1 direct address access byVar : BYTE; END_VAR \/\/Implementation xVar := %IX0.0; \/\/ +1 direct address access %QX0.0 := xVar; \/\/ +1 %MX0.1 := xVar; \/\/ +1 %MB1 := byVar; \/\/ +1 该示例有 5 个直接地址访问。...", 
"body" : "直接地址访问 (IO) 数量 类别 ：可重用性、可维护性 直接地址访问次数（ IO ）在对象的实现中。 例子 \/\/Declaration\nPROGRAM PRG\nVAR\n xVar : BOOL:= %IX0.0; \/\/ +1 direct address access\n byVar : BYTE;\nEND_VAR\n\n\/\/Implementation\nxVar := %IX0.0; \/\/ +1 direct address access\n%QX0.0 := xVar; \/\/ +1\n%MX0.1 := xVar; \/\/ +1\n%MB1 := byVar; \/\/ +1 该示例有 5 个直接地址访问。 " }, 
{ "title" : "指标：局部变量（Locals）的数量 ", 
"url" : "_san_reference_metrics.html#UUID-f738f257-cf3a-1e7c-979e-1d6b4733c2d9", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：局部变量（Locals）的数量 ", 
"snippet" : "局部变量（Locals）的数量 类别 ：信息丰富、高效 中声明的变量数量 VAR POU 的区域。继承的变量不计算在内。 例子 \/\/Declaration FUNCTION_BLOCK FB VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR i,j,k,l : INT; m,n,o : BOOL; END_VAR 在功能块中，声明了7个局部变量。...", 
"body" : "局部变量（Locals）的数量 类别 ：信息丰富、高效 中声明的变量数量 VAR POU 的区域。继承的变量不计算在内。 例子 \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,j,k,l : INT;\n m,n,o : BOOL;\nEND_VAR\n 在功能块中，声明了7个局部变量。 " }, 
{ "title" : "指标：输入变量的数量（输入） ", 
"url" : "_san_reference_metrics.html#UUID-03e01655-9ac0-74f4-3fd7-cf22f23db4f6", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：输入变量的数量（输入） ", 
"snippet" : "输入变量的数量（Inputs） 类别 ：可维护性、可重用性 对应的默认上限 SA0166 规则：10 声明的变量数量 VAR_INPUT 程序单元的。继承的输入变量不计算在内。 例子 FUNCTION_BLOCK FB VAR_INPUT i : INT; r : REAL; END_VAR 在功能块中，声明了 2 个输入变量： i 和 r 。 METHOD METH : BOOL VAR_INPUT j : INT; l : LREAL; END_VAR 该方法有 2 个输入： j 和 l...", 
"body" : "输入变量的数量（Inputs） 类别 ：可维护性、可重用性 对应的默认上限 SA0166 规则：10 声明的变量数量 VAR_INPUT 程序单元的。继承的输入变量不计算在内。 例子 FUNCTION_BLOCK FB\nVAR_INPUT\n i : INT;\n r : REAL;\nEND_VAR\n 在功能块中，声明了 2 个输入变量： i 和 r 。 METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR\n 该方法有 2 个输入： j 和 l " }, 
{ "title" : "指标：输出变量（输出）的数量 ", 
"url" : "_san_reference_metrics.html#UUID-7bba3bc6-748c-311d-7f8c-4878fdce9da0", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：输出变量（输出）的数量 ", 
"snippet" : "输出变量的数量（输出） 类别 ：可维护性、可重用性 对应的默认上限 SA0166 规则：10 中的变量数量 VAR_OUTPUT 节目单元的 对于功能块，这是自定义输出变量的数量（ VAR_OUTPUT ）。对于方法和函数，这是自定义输出变量的数量加一（如果它们有返回值）。返回值也被计算在内。继承的输出变量不计算在内。 大量输出变量表明违反了唯一责任原则。 例子 FUNCTION_BLOCK FB VAR_OUTPUT i : INT; \/\/ +1 output r : REAL; \/\/ +1 output END_VAR 该功能块有 2 个输出变量： i 和 r METHOD METH : ...", 
"body" : "输出变量的数量（输出） 类别 ：可维护性、可重用性 对应的默认上限 SA0166 规则：10 中的变量数量 VAR_OUTPUT 节目单元的 对于功能块，这是自定义输出变量的数量（ VAR_OUTPUT ）。对于方法和函数，这是自定义输出变量的数量加一（如果它们有返回值）。返回值也被计算在内。继承的输出变量不计算在内。 大量输出变量表明违反了唯一责任原则。 例子 FUNCTION_BLOCK FB\nVAR_OUTPUT\n i : INT; \/\/ +1 output\n r : REAL; \/\/ +1 output\nEND_VAR 该功能块有 2 个输出变量： i 和 r METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR 该方法有 3 个输出： METH , j ， 和 l METHOD METH1 \/\/ +0 outputs (no return type)\nVAR_OUTPUT\n ar : ARRAY[0..10] OF INT; \/\/ +1 output\n l : LREAL; \/\/ +1 output\nEND_VAR 这 METH1 方法有 2 个输出： ar 和 i " }, 
{ "title" : "指标：NOS – 语句数量 ", 
"url" : "_san_reference_metrics.html#UUID-82054fe5-816d-0c12-0afa-11dabf2c47b3", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：NOS – 语句数量 ", 
"snippet" : "NOS – 声明数量 类别 ：信息丰富 功能块、函数或方法的实现中的语句数 声明中的语句、空语句或编译指示不计算在内。 例子 \/\/Declaration: FUNCTION POU : BOOL VAR_INPUT END_VAR VAR c : INT := 100; \/\/ statements in the declaration are not counted END_VAR VAR_OUTPUT test : INT; i : INT; END_VAR \/\/Implementation: IF TRUE THEN \/\/if statement: +1 test := 0; \/\/ +1 ...", 
"body" : "NOS – 声明数量 类别 ：信息丰富 功能块、函数或方法的实现中的语句数 声明中的语句、空语句或编译指示不计算在内。 例子 \/\/Declaration:\nFUNCTION POU : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n c : INT := 100; \/\/ statements in the declaration are not counted\nEND_VAR\nVAR_OUTPUT\n test : INT;\n i : INT;\nEND_VAR\n\n\/\/Implementation:\nIF TRUE THEN \/\/if statement: +1\n test := 0; \/\/ +1\nEND_IF\n\nWHILE test = 1 DO \/\/while statement: +1\n ; \/\/ empty statements do not add to the statement count\nEND_WHILE\n\nFOR c := 0 TO 10 BY 2 DO \/\/for statement: +1\n i := i+i; \/\/ +1\nEND_FOR\n\n{text 'simple text pragma'} \/\/pragmas are not counted\ntest := 2; \/\/+1 该示例有 6 个语句。 " }, 
{ "title" : "指标：评论的百分比 ", 
"url" : "_san_reference_metrics.html#UUID-abd88d31-c33e-db93-0f69-bec1a38795f7", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：评论的百分比 ", 
"snippet" : "评论百分比 类别 ：可维护性 源代码中注释的百分比 该数字根据以下公式计算： 百分比 = 100 * <注释中的字符数> \/ <源代码中的字符数与注释中的字符数之和> 源代码中连续的多个空格会被算作一个空格，这样可以防止源代码缩进的权重过高。对于空对象（没有源代码和注释），返回 0 的百分比。 例子 声明部分： FUNCTION_BLOCK FB \/\/comments in the declaration are counted, as well VAR_TEMP hugo : INT; END_VAR 执行： hugo := hugo + 1; \/\/Declaration: 40 lette...", 
"body" : "评论百分比 类别 ：可维护性 源代码中注释的百分比 该数字根据以下公式计算： 百分比 = 100 * <注释中的字符数> \/ <源代码中的字符数与注释中的字符数之和> 源代码中连续的多个空格会被算作一个空格，这样可以防止源代码缩进的权重过高。对于空对象（没有源代码和注释），返回 0 的百分比。 例子 声明部分： FUNCTION_BLOCK FB \/\/comments in the declaration are counted, as well\nVAR_TEMP\n hugo : INT;\nEND_VAR 执行： hugo := hugo + 1;\n\/\/Declaration: 40 letters non comment; 50 letters comment\n\/\/Implementation: 13 letters non comment; 152 letters comment\n\/\/ 100 * 202 \/ 255 -> 79% comments 百分比 100 * 202 \/ 255 的计算返回 79%。 " }, 
{ "title" : "指标：复杂性 (McCabe) ", 
"url" : "_san_reference_metrics.html#UUID-ea21160c-97be-30d4-7748-0adac68532a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：复杂性 (McCabe) ", 
"snippet" : "复杂性（麦凯布） 类别 ：可测试性 建议上限：10 McCabe 认为，圈复杂度是源代码可读性和可测试性的衡量标准。它是通过计算 POU 控制流中二进制分支的数量来计算的。然而，圈复杂度会损害高分支，因为高分支会增加高测试覆盖率所需的测试用例数量。 例子： IF 陈述 \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch IF b1 THEN \/\/ +1 for the THEN branch ; ELSIF b2 THEN \/\/ +1 for the THEN branch...", 
"body" : "复杂性（麦凯布） 类别 ：可测试性 建议上限：10 McCabe 认为，圈复杂度是源代码可读性和可测试性的衡量标准。它是通过计算 POU 控制流中二进制分支的数量来计算的。然而，圈复杂度会损害高分支，因为高分支会增加高测试覆盖率所需的测试用例数量。 例子： IF 陈述 \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nIF b1 THEN \/\/ +1 for the THEN branch\n ;\n ELSIF b2 THEN \/\/ +1 for the THEN branch of the IF inside the else\n ;\nELSE \n IF b3 OR b4 THEN \/\/ +1 for the THEN branch\n ;\n END_IF\nEND_IF 该代码片段的圈复杂度为 4。 例子： CASE 陈述 \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nCASE a OF\n 1:\t; \/\/ +1\n 2:\t; \/\/ +1\n 3,4,5:\t; \/\/ +1\nELSE \/\/ the ELSE statement does not increase the cyclomatic complexity\n ;\nEND_CASE 该代码片段的圈复杂度为 4。 示例：循环语句 \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nWHILE b1 DO \/\/ +1 for the WHILE loop\n ;\nEND_WHILE\n\nREPEAT \/\/ +1 for the REPEAT loop\n ;\n UNTIL b2\nEND_REPEAT\n\nFOR a := 0 TO 100 BY 2 DO \/\/ +1 for the REPEAT loop\n ;\nEND_FOR 该代码片段的圈复杂度为 4。 示例：其他陈述 以下语句也会增加圈复杂度： \/\/Declaration\nFUNCTION FUN : STRING\nVAR_INPUT\n condition_return : BOOL;\n condition_jmp : BOOL;\nEND_VAR\nVAR\nEND_VAR\n\n\/\/Implementation\n\/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nJMP(condition_jmp) lbl; \/\/Conditional jumps increase the cyclomatic complexity by 1\n\nFUN := 'u';\nRETURN(condition_return); \/\/Conditional returns increase the cyclomatic complexity by 1, too\n\nlbl:\nFUN := 't';\n 该代码片段的圈复杂度为 3。 " }, 
{ "title" : "指标：认知复杂性 ", 
"url" : "_san_reference_metrics.html#UUID-cd064f18-bd35-1d86-1bd4-2ae3a8fe344f", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：认知复杂性 ", 
"snippet" : "认知复杂性 类别 ：可维护性 对应SA0178规则的默认上限：20 认知复杂性是 Sonarsource™ 于 2016 年引入的源代码可读性和可理解性的衡量标准。然而，它会惩罚控制流和复杂布尔表达式的大量嵌套。仅针对结构化文本实现计算认知复杂度。 以下示例显示了如何计算认知复杂性。 这 显示当前编辑者的认知复杂性 命令可用于另外显示结构化文本的增量。 示例：控制流程 操纵控制流的语句将认知复杂度增加 1 IF TRUE THEN \/\/ +1 cognitive complexity ; END_IF WHILE TRUE DO \/\/+1 cognitive complexity ; END_...", 
"body" : "认知复杂性 类别 ：可维护性 对应SA0178规则的默认上限：20 认知复杂性是 Sonarsource™ 于 2016 年引入的源代码可读性和可理解性的衡量标准。然而，它会惩罚控制流和复杂布尔表达式的大量嵌套。仅针对结构化文本实现计算认知复杂度。 以下示例显示了如何计算认知复杂性。 这 显示当前编辑者的认知复杂性 命令可用于另外显示结构化文本的增量。 示例：控制流程 操纵控制流的语句将认知复杂度增加 1 IF TRUE THEN \/\/ +1 cognitive complexity\n ;\nEND_IF\n\nWHILE TRUE DO \/\/+1 cognitive complexity\n ;\nEND_WHILE\n\nFOR i := 0 TO 10 BY 1 DO \/\/+1 cognitive complexity\n ;\nEND_FOR\n\nREPEAT \/\/+1 cognitive complexity\n ;\nUNTIL TRUE\nEND_REPEAT 该代码片段的认知复杂度为 4。 示例：控制流的嵌套 嵌套控制流时，每层嵌套增量加1。 IF TRUE THEN \/\/+1 cognitive complexity\n WHILE TRUE DO \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n FOR i := 0 TO 10 BY 1 DO \/\/+3 (+1 for the FOR loop itself, +2 for the nesting inside the WHILE and the IF)\n\t\t\t;\n END_FOR\n END_WHILE\n\n REPEAT \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n ;\n UNTIL TRUE\n END_REPEAT\nEND_IF 该代码片段的认知复杂度为 8。 示例：布尔表达式 由于布尔表达式在理解源代码方面发挥着重要作用，因此在计算认知复杂性时也会考虑它们。 理解与同一布尔运算符关联的布尔表达式并不像理解包含交替布尔运算符的布尔表达式那么困难。因此，表达式中任何相同布尔运算符链都会增加认知复杂性。 b := b1; \/\/+0: a simple expression, containing no operators, has no increment\n 不带运算符的简单表达式的增量为 0。 b := b1 AND b2; \/\/+1: one chain of AND operators 表达式带有一个 AND 链接增量为 1。 b := b1 AND b2 AND b3; \/\/+1: one more AND, but the number of chains of operators does not change 表达式还有一个 AND 。但由于是同一个运营商，因此相同运营商形成的链的数量不会改变。 b := b1 AND b2 OR b3; \/\/+2: one chain of AND operators and one chain of OR operators 该表达式有一个链 AND 运营商和连锁 OR 运营商。这导致增量为 2。 b := b1 AND b2 OR b3 AND b4 AND b5; \/\/+3 代码片段的增量为 3。 b := b1 AND NOT b2 AND b3; \/\/+1: the unary NOT operator is not considered in the cognitive complexity 一元运算符 NOT 不考虑认知复杂性。 示例：其他带有增量的语句 结构化文本具有更改控制流的附加语句和表达式。 以下陈述会因认知复杂性的增加而受到惩罚： aNewLabel:\nx := MUX(i, a,b,c); \/\/+1 for MUX operator\ny := SEL(b, i,j); \/\/+1 for SEL operator\nJMP aNewLabel; \/\/+1 for JMP to label EXIT 和 RETURN 陈述不会增加认知复杂性。 " }, 
{ "title" : "指标：DIT——继承树深度 ", 
"url" : "_san_reference_metrics.html#UUID-c7e1c296-e321-f999-8ed7-9713ebdb50fc", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：DIT——继承树深度 ", 
"snippet" : "DIT——继承树深度 类别 ：可维护性 到达不扩展任何其他功能块的功能块之前的继承数 例子 FUNCTION_BLOCK MyBaseFB \/\/ ... FUNCTION_BLOCK AChildFB EXTENDS MyBaseFB \/\/ ... FUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB \/\/ ... MyBaseFB DIT 为 0，因为它本身是一个功能块，不扩展任何其他功能块。 为了 AChildFB ，DIT 为 1，因为需要一步才能到达 MyBaseFB 。 AGrandChildFB DIT 为 2：需要一个步骤 AChildFB ...", 
"body" : "DIT——继承树深度 类别 ：可维护性 到达不扩展任何其他功能块的功能块之前的继承数 例子 FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB DIT 为 0，因为它本身是一个功能块，不扩展任何其他功能块。 为了 AChildFB ，DIT 为 1，因为需要一步才能到达 MyBaseFB 。 AGrandChildFB DIT 为 2：需要一个步骤 AChildFB 另一个到 MyBaseFB 。 " }, 
{ "title" : "指标：NOC – 儿童数量 ", 
"url" : "_san_reference_metrics.html#UUID-04314eaf-28e7-40ea-0aa9-e7f46e79bfa0", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：NOC – 儿童数量 ", 
"snippet" : "NOC – 儿童数量 类别 ：可重用性、可维护性 扩展给定基本功能块的功能块数量。间接扩展基本功能块的功能块不计算在内。 例子 FUNCTION_BLOCK MyBaseFB \/\/ ... FUNCTION_BLOCK AChildFB EXTENDS MyBaseFB \/\/ ... FUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB \/\/ ... MyBaseFB 只有一 (1) 个子对象： AChildFB ，它又具有一个子对象， AGrandChildFB 。 AGrandChildFB 没有子对象。...", 
"body" : "NOC – 儿童数量 类别 ：可重用性、可维护性 扩展给定基本功能块的功能块数量。间接扩展基本功能块的功能块不计算在内。 例子 FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB 只有一 (1) 个子对象： AChildFB ，它又具有一个子对象， AGrandChildFB 。 AGrandChildFB 没有子对象。 " }, 
{ "title" : "指标：RFC – 类响应 ", 
"url" : "_san_reference_metrics.html#UUID-0fcfc138-e361-a392-6fbe-11240e7a6e2a", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：RFC – 类响应 ", 
"snippet" : "类响应 (RFC) 类别 ：可维护性、可重用性 被调用并因此生成下面指定的 POU 的响应的不同 POU、方法或操作的数量 节目单位 例子 \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR d,x,y : INT; END_VAR \/\/Implementation x := METH(d+10); y := FUN(42, 0.815); \/\/Declaration FB1.METH METHOD METH : INT VAR_INPUT i : INT; END_VAR \/\/Implementation METH := FUN(CUBE(i), 3.1415)...", 
"body" : "类响应 (RFC) 类别 ：可维护性、可重用性 被调用并因此生成下面指定的 POU 的响应的不同 POU、方法或操作的数量 节目单位 例子 \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR\n d,x,y : INT;\nEND_VAR\n\n\/\/Implementation\nx := METH(d+10);\ny := FUN(42, 0.815); \/\/Declaration FB1.METH\nMETHOD METH : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := FUN(CUBE(i), 3.1415); \/\/Declaration CUBE\nFUNCTION CUBE : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nCUBE := i*i*i; \/\/Declaration Function FUN\nFUNCTION FUN : INT\nVAR_INPUT\n a : INT;\n lr : LREAL;\nEND_VAR\n\n\/\/Implementation\nFUN := LREAL_TO_INT(lr*10)*a; 从...开始 FUN 和 CUBE ，这些函数的 RFC 为 0，因为它们都不调用其他函数、功能块或方法来进行计算。 FB1.METH 用途 FUN 和 CUBE ，导致 RFC 为 2。 功能块 FB1 本身调用 METH 和 FUN ，这将其 RFC 增加了 2。 对于 FB1，还必须考虑其 METH 方法。 METH 使用 FUN 和 CUBE。 FUN 已添加到 RFC 中。因此，只有在METH中使用CUBE才能将FB1的RFC增加到3 " }, 
{ "title" : "指标：CBO – 对象之间的耦合 ", 
"url" : "_san_reference_metrics.html#UUID-d98bd2a3-497b-920f-1f11-f4f38973066f", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：CBO – 对象之间的耦合 ", 
"snippet" : "CBO——对象之间的耦合 类别 ：可维护性、可重用性 对应SA0179规则的默认上限：30 在功能块中实例化和使用的其他功能块的数量 对象之间耦合度高的功能块很可能涉及许多不同的任务，因此违反了唯一责任原则。 例子 \/\/ Declaration FUNCTION_BLOCK FB_Child EXTENDS FB_Base objects \/\/ +0 for EXTENDS VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR i_fb1 : FB1; \/\/ +1 instantiated here i_fb2 : FB2; \/\/ +1 instantiated h...", 
"body" : "CBO——对象之间的耦合 类别 ：可维护性、可重用性 对应SA0179规则的默认上限：30 在功能块中实例化和使用的其他功能块的数量 对象之间耦合度高的功能块很可能涉及许多不同的任务，因此违反了唯一责任原则。 例子 \/\/ Declaration\nFUNCTION_BLOCK FB_Child EXTENDS FB_Base objects \/\/ +0 for EXTENDS\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i_fb1 : FB1; \/\/ +1 instantiated here\n i_fb2 : FB2; \/\/ +1 instantiated here\nEND_VAR\n\n\/\/Implementation\ni_fb3(); \/\/ +0 instantiated in FB_Base, no increment for call 功能块的扩展不会增加对象之间的耦合。 i_fb3 在执行中被实例化 FB_Base 并传递给 FB_Child ( EXTENDS ）。来电 FB_Child 不会增加对象之间的耦合。 国会预算办公室 (CBO) FB_Child 是 2。 " }, 
{ "title" : "指标：参考复杂性 (Elshof) ", 
"url" : "_san_reference_metrics.html#UUID-a43f74c1-523d-b649-00e5-788c653e5ea1", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：参考复杂性 (Elshof) ", 
"snippet" : "参考的复杂性（Elshof） 类别 ：效率、可维护性、可重用性 POU 数据流的复杂性 引用复杂度根据以下公式计算： <使用的变量数量> \/ <变量访问数量> 仅考虑 POU 实现部分中的变量访问。 例子 \/\/Declaration PROGRAM PRG VAR i, j : INT; k : INT := GVL.m; b, c : BOOL; myFB : FB; END_VAR \/\/Implementation myFB(paramA := b); \/\/ +3 accesses (myFB, paramA and b) i := j; \/\/ +2 accesses (i and j) ...", 
"body" : "参考的复杂性（Elshof） 类别 ：效率、可维护性、可重用性 POU 数据流的复杂性 引用复杂度根据以下公式计算： <使用的变量数量> \/ <变量访问数量> 仅考虑 POU 实现部分中的变量访问。 例子 \/\/Declaration\nPROGRAM PRG\nVAR\n i, j : INT;\n k : INT := GVL.m;\n b, c : BOOL;\n myFB : FB;\nEND_VAR\n\n\/\/Implementation\nmyFB(paramA := b); \/\/ +3 accesses (myFB, paramA and b)\ni := j; \/\/ +2 accesses (i and j)\nj := GVL.d; \/\/ +2 accesses (j and GVL.d) 引用代码片段结果中的复杂性： 6 使用的变量数量 \/7 变量访问次数 = 0.85 警告： c 和 k 未使用，因此不计为“已使用的变量”。 分配 k : INT := GVL.m 不被计算在内，因为它是程序声明的一部分。 " }, 
{ "title" : "指标：方法缺乏凝聚力 – LCOM ", 
"url" : "_san_reference_metrics.html#UUID-068c2765-4709-d4e2-80b6-d173998195a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：方法缺乏凝聚力 – LCOM ", 
"snippet" : "方法缺乏凝聚力 – LCOM 方法缺乏凝聚力 – LCOM 类别 ：可维护性、可重用性 功能块、它们的动作、转换和方法之间的内聚性描述了它们是否访问相同的变量。 方法内聚性的缺乏描述了功能块的对象相互连接的强度。内聚力缺乏程度越低，对象之间的联系就越强。 高度缺乏内聚性的功能块可能涉及许多不同的任务，因此违反了唯一责任原则。 该指标根据以下公式计算： MAX(0, <无内聚的对象对数量> - <有内聚的对象对数量>) 例子 \/\/Declaration FUNCTION_BLOCK FB VAR_INPUT a : BOOL; END_VAR VAR_OUTPUT END_VAR VAR i,b...", 
"body" : "方法缺乏凝聚力 – LCOM 方法缺乏凝聚力 – LCOM 类别 ：可维护性、可重用性 功能块、它们的动作、转换和方法之间的内聚性描述了它们是否访问相同的变量。 方法内聚性的缺乏描述了功能块的对象相互连接的强度。内聚力缺乏程度越低，对象之间的联系就越强。 高度缺乏内聚性的功能块可能涉及许多不同的任务，因此违反了唯一责任原则。 该指标根据以下公式计算： MAX(0, <无内聚的对象对数量> - <有内聚的对象对数量>) 例子 \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\n a : BOOL;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,b : BOOL;\nEND_VAR\n\n\/\/Implementation\ni := 42;\n\/\/FB.ACT\ni:= 0; \/\/FB.METH Declaration\nMETHOD METH : BOOL\nVAR_INPUT\n\tc : BOOL;\nEND_VAR\n\n\/\/Implementation\nMETH := c;\ni := 1; \/\/FB.SecondMETH Declaration\nMETHOD SecondMETH : INT\nVAR_INPUT\nEND_VAR\n\n\/\/Implementation\nSecondMETH := SEL(c,3,4); 无连接的对象对（4 对）： FB, FB.ACT FB , FB.METH FB.ACT , FB.SecondMETH FB.METH , FB.SecondMETH 带连接的对象对（2 对）： FB , FB.SecondMETH （两者都使用 c ） FB.ACT , FB.METH （两者都使用 i ） 下表显示了哪些变量连接了 FB 的哪些对象： FB FB.ACT FB.METH FB.SecondMETH FB.SecondMETH c 0 0 . FB.METH 0 i . . FB.ACT 0 . . . FB - . . . " }, 
{ "title" : "指标：证监会分支机构数量 ", 
"url" : "_san_reference_metrics.html#UUID-d74f2703-e85d-ed16-b335-69a4dfd4a8bd", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：证监会分支机构数量 ", 
"snippet" : "证监会分支机构数量 类别 ：可测试性、可维护性 SFC（顺序功能图）实现语言的 POU 的替代分支和并行分支的数量 例子 上述SFC中的代码片段有4个分支：3个替代分支和1个并行分支...", 
"body" : "证监会分支机构数量 类别 ：可测试性、可维护性 SFC（顺序功能图）实现语言的 POU 的替代分支和并行分支的数量 例子 上述SFC中的代码片段有4个分支：3个替代分支和1个并行分支 " }, 
{ "title" : "指标：SFC 步骤数 ", 
"url" : "_san_reference_metrics.html#UUID-19d1353f-ebce-6c25-6214-7b3a97c92490", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参考：编程 \/ 指标 \/ 指标：SFC 步骤数 ", 
"snippet" : "SFC 步数 类别 ：可维护性 SFC 中 POU 的步数（顺序功能图） 仅对 SFC 中编程的 POU 中包含的步进行计数。在 POU 中调用的操作或转换的实现中的步骤不计算在内。 例子 SFC 中的代码片段有 10 个步骤。...", 
"body" : "SFC 步数 类别 ：可维护性 SFC 中 POU 的步数（顺序功能图） 仅对 SFC 中编程的 POU 中包含的步进行计数。在 POU 中调用的操作或转换的实现中的步骤不计算在内。 例子 SFC 中的代码片段有 10 个步骤。 " }
]
$(document).trigger('search.ready');
});