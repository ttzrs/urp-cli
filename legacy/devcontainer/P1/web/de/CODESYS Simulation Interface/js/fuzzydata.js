$(document).ready(function () {indexDict['de'] = [{ "title" : "CODESYS Simulation Interface ", 
"url" : "_simitf_start_page.html", 
"breadcrumbs" : "CODESYS Simulation Interface \/ CODESYS Simulation Interface ", 
"snippet" : "Das CODESYS Simulation Interface ist ein Add-on des IEC 61131-3 Programmiertool CODESYS Development System für die industrielle Steuerungs- und Automatisierungstechnik. Vorabversion Die Version 0.9.0.0 ist die Vorabversion eines zukünftigen Produkts. Die Vorabversion ist nicht für den produktiven Ei...", 
"body" : "Das CODESYS Simulation Interface ist ein Add-on des IEC 61131-3 Programmiertool CODESYS Development System für die industrielle Steuerungs- und Automatisierungstechnik. Vorabversion Die Version 0.9.0.0 ist die Vorabversion eines zukünftigen Produkts. Die Vorabversion ist nicht für den produktiven Einsatz bestimmt. Sie wird interessierten Kunden oder Anbietern von Simulationswerkzeugen zur Verfügung gestellt, um die Simulationsschnittstelle vor dem ersten Produkt-Release (Version 1.0.0.0) zu evaluieren.\nDie Vorabversion wird nicht über den CODESYS Store International erhältlich sein. Bitte wenden Sie sich an sales@codesys.com , wenn Sie das CODESYS Simulation Interface evaluieren möchten. " }, 
{ "title" : "Einführung ", 
"url" : "_simitf_intorduction.html", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Einführung ", 
"snippet" : "Die CODESYS -Simulationsschnittstelle benötigt für ein vollständig integriertes System drei Subsysteme. Simulations-Broker Simulationsschnittstelle Simulationsdemonstrator für den Fall, dass das System zu Demonstrationszwecken betrieben werden soll. Oder (als Alternative zum Simulationsdemonstator) ...", 
"body" : "Die CODESYS -Simulationsschnittstelle benötigt für ein vollständig integriertes System drei Subsysteme. Simulations-Broker Simulationsschnittstelle Simulationsdemonstrator für den Fall, dass das System zu Demonstrationszwecken betrieben werden soll. Oder (als Alternative zum Simulationsdemonstator) ein Simulationstool von einem Drittanbieter. Die Simulationsschnittstelle generiert ein OPC-Informationsmodell und lädt es auf den Broker. Der Broker hostet das OPC Informationsmodell und macht es über OPC UA Client\/Server für das Simulationstool lesbar. Mit diesen Informationen ist das Simulationstool in der Lage, die Gegenstelle für die OPC-PubSub-Kommunikation zu erstellen. " }, 
{ "title" : "Simulations-Broker ", 
"url" : "_simitf_intorduction.html#UUID-af54d22d-76ba-7559-d5ee-0e5ca76c551d", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Einführung \/ Simulations-Broker ", 
"snippet" : "Der Broker wird mit Hilfe der Simulationsschnittstelle erzeugt. Er wird als eigene IEC-Applikation bereitgestellt und als OPC-UA-Server auf einem separaten CODESYS Laufzeitsystem ausgeführt. Mit diesem Subsystem hat der Anwender die Möglichkeit, die von der Simulationsschnittstelle simulierte Applik...", 
"body" : "Der Broker wird mit Hilfe der Simulationsschnittstelle erzeugt. Er wird als eigene IEC-Applikation bereitgestellt und als OPC-UA-Server auf einem separaten CODESYS Laufzeitsystem ausgeführt. Mit diesem Subsystem hat der Anwender die Möglichkeit, die von der Simulationsschnittstelle simulierte Applikation zu kontrollieren und zu steuern. Das Gerät oder das Laufzeitsystem, auf dem der Broker läuft, wird auch als \"Simulations-Broker\" oder \"Sim-Broker\" bezeichnet. Dieses Subsystem ist Teil des Add-ons CODESYS Simulation Interface . " }, 
{ "title" : "Simulationsschnittstelle ", 
"url" : "_simitf_intorduction.html#UUID-8873f5f3-8ecf-aa27-263e-142938ac8674", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Einführung \/ Simulationsschnittstelle ", 
"snippet" : "Fügen Sie das Objekt Simulation Interface unterhalb Ihrer Applikation zu Ihrem Projekt hinzu, konfigurieren Sie die Simulationsschnittstelle und starten Sie die Applikation. Auf diese Weise werden alle E\/As entkoppelt und die Applikation mit dem Simulationswerkzeug oder dem Simulationsdemonstrator v...", 
"body" : "Fügen Sie das Objekt Simulation Interface unterhalb Ihrer Applikation zu Ihrem Projekt hinzu, konfigurieren Sie die Simulationsschnittstelle und starten Sie die Applikation. Auf diese Weise werden alle E\/As entkoppelt und die Applikation mit dem Simulationswerkzeug oder dem Simulationsdemonstrator verbunden. Grundsätzlich ist es so, dass bei gesetzter Option Simulation aktiviert die Applikation (oder letztendlich die für diese Applikation relevanten E\/As) über OPC UA PubSub mit der Simulation kommunizieren. Bei nicht aktivierter Option kommuniziert die Applikation über Feldbusse mit der realen Umgebung. Um Ihre simulierte Applikation mit Ihrem Simulationstool (oder anderen UA Clients) über OPC UA Client\/Server zu finden, hilft Ihnen die Simulationsschnittstelle. Sie erhalten Unterstützung bei der Bereitstellung und Ausführung der Simulation-Broker auf einer anderen CODESYS Laufzeitumgebung. Das Gerät oder das Laufzeitsystem, auf der die Simulationsschnittstelle läuft, wird auch als \"Simulations-Target\" oder \"Sim-Target\" bezeichnet. Dieses Subsystem ist Teil des Add-ons CODESYS Simulation Interface . Für weitere Informationen siehe: Objekt: " }, 
{ "title" : "Simulationsdemonstrator ", 
"url" : "_simitf_intorduction.html#UUID-63d1789b-b9d8-10c6-e65a-e82ea895537c", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Einführung \/ Simulationsdemonstrator ", 
"snippet" : "Für Kunden, die Entwickler oder Hersteller von Simulationswerkzeugen sind und die PubSub-Kommunikation in ihre eigenen Produkte und Simulationswerkzeuge implementieren wollen, stellt der Simulationsdemonstrator eine Referenzimplementierung dar. Der Simulationsdemonstrator zeigt als praktische Demons...", 
"body" : "Für Kunden, die Entwickler oder Hersteller von Simulationswerkzeugen sind und die PubSub-Kommunikation in ihre eigenen Produkte und Simulationswerkzeuge implementieren wollen, stellt der Simulationsdemonstrator eine Referenzimplementierung dar. Der Simulationsdemonstrator zeigt als praktische Demonstration, wie die Serialisierung und Deserialisierung im Prinzip durchgeführt wird. Das Subsystem ist nicht Bestandteil des Add-ons CODESYS Simulation Interface . Sie erhalten das Tool als CODESYS Simulation Interface Example Package. Die Version 0.9.0.0 wird nicht über den CODESYS Installer verfügbar sein. Das Produkt kann über den Vertrieb angefragt werden. Bekannte Einschränkungen Ein erneutes Verbinden des CODESYS Simulation Demonstrator -Tools mit dem Simulationstarget ist in der Vorabversion 0.9.0.0 nicht möglich. Mögliche Abhilfe: Gleichen Broker über den Befehl Broker-Gerät auswählen , Verbinden auswählen. Dieses Problem muss im OPC UA Stack der OPC Foundation behoben werden (#2929). Siehe https:\/\/github.com\/OPCFoundation\/UA-.NETStandard\/issues\/2929 " }, 
{ "title" : "Einstellungen ", 
"url" : "_simitf_settings.html", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Einstellungen ", 
"snippet" : "Konfigurieren Sie als erstes die Simulationsschnittstelle. Aktivieren Sie die Simulation in der Registerkarte Konfiguration , dann läuft die Simulationsapplikation gegen das Simulations-Tool. Wenn die Option Simulation aktiviert nicht aktiviert ist, läuft die Applikation gegen den realen Feldbus. Fü...", 
"body" : "Konfigurieren Sie als erstes die Simulationsschnittstelle. Aktivieren Sie die Simulation in der Registerkarte Konfiguration , dann läuft die Simulationsapplikation gegen das Simulations-Tool. Wenn die Option Simulation aktiviert nicht aktiviert ist, läuft die Applikation gegen den realen Feldbus. Für weitere Informationen siehe: Registerkarte: , Registerkarte: " }, 
{ "title" : "Arbeiten mit dem Simulationsinterface ", 
"url" : "_simitf_use_the_sim_interface.html", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Arbeiten mit dem Simulationsinterface ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Vorbereiten ", 
"url" : "_simitf_use_the_sim_interface.html#UUID-11fcc5e9-f7fe-dcee-a616-ddc58e0f84db", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Arbeiten mit dem Simulationsinterface \/ Vorbereiten ", 
"snippet" : "Für die ersten Schritte mit der Simulationsschnittstelle ist es hilfreich, die lokale Umgebung mit zwei CODESYS Steuerungen zu konfigurieren. Am einfachsten ist es, wenn Sie die beiden Steuerungen CODESYS Control Win SL aus dem CODESYS Store International herunterladen. Im CODESYS Store Internationa...", 
"body" : "Für die ersten Schritte mit der Simulationsschnittstelle ist es hilfreich, die lokale Umgebung mit zwei CODESYS Steuerungen zu konfigurieren. Am einfachsten ist es, wenn Sie die beiden Steuerungen CODESYS Control Win SL aus dem CODESYS Store International herunterladen. Im CODESYS Store International oder im CODESYS Store North America finden Sie das Produkt und das Datenblatt zum Produkt. Die ZIP-Datei enthält die 64-Bit und die 32-Bit Version von CODESYS Control Win SL . Packages installieren Installieren Sie in Ihrem CODESYS Programmiertool das Add-on CODESYS Simulation Interface . Installieren Sie das Package CODESYS Simulation Interface Example . Der Add-on CODESYS Simulation Demonstrator ist Teil des Packages. Installiere und öffnen Sie das Beispielprojekt SimulationInterfaceExample.projectarchive . Installieren Sie die beiden Laufzeitsysteme. Öffnen Sie ein Standardprojekt mit einem 32 Bit Gerät CODESYS Control Win . Starten Sie den Gateway und das Gerät. Doppelklicken Sie in der Ansicht Geräte auf dieses Gerät. Der Geräteeditor öffnet sich. Wählen Sie die Schaltfläche Netzwerk durchsuchen . Die 32-Bit-Laufzeitumgebung CODESYS Control Win wird angezeigt. Wählen Sie das Gerät aus und konfigurieren Sie es wie üblich. Das Gerät ist verbunden. Wählen Sie den Befehl Laufzeitsystem-Sicherheitsrichtlinie ändern und bestätigen Sie den aufgehenden Dialog mit Ja . Kommunikationseinstellungen Konfigurieren Sie die Gerätebenutzerverwaltung. Setzen Sie im Dialog Laufzeitsystem-Sicherheitsrichtlinie ändern die Gerätebenutzerverwaltung von Erzwungene Benutzerverwaltung auf Optionale Benutzerverwaltung . Aktivieren Sie die Option Anonymes Einloggen erlauben und bestätigen Sie die Einstellungen mit OK . Klicken Sie auf die Schaltfläche Gerät und wählen Sie den Befehl Aktives Gerät umbenennen und benennen Sie im nun aufgehenden Dialog das aktive Gerät um. Geben Sie einen neuen Gerätenamen wie beispielsweise zu SimBroker ein. Aktualisieren Sie das Gerät auf die Gerätebeschreibung CODESYS Control Win x64 . Wiederholen Sie die Schritte ab 3, aber benennen Sie das Gerät in SimTarget um. Bereit. " }, 
{ "title" : "Einfaches Beispiel ", 
"url" : "_simitf_use_the_sim_interface.html#UUID-1abd1d51-840b-821b-1318-dc0fea54f94f", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Arbeiten mit dem Simulationsinterface \/ Einfaches Beispiel ", 
"snippet" : "Zum Kennenlernen der Simulationsschnittstelle wird hier ein einfaches Beispiel schrittweise entwickelt. Stellen Sie sich eine Maschine vor, deren E\/A-Daten über einen Feldbus ausgetauscht werden. Als Feldbus wird ein PROFIBUS verwendet. Erstellen Sie ein neues Standardprojekt und wählen Sie als Gerä...", 
"body" : "Zum Kennenlernen der Simulationsschnittstelle wird hier ein einfaches Beispiel schrittweise entwickelt. Stellen Sie sich eine Maschine vor, deren E\/A-Daten über einen Feldbus ausgetauscht werden. Als Feldbus wird ein PROFIBUS verwendet. Erstellen Sie ein neues Standardprojekt und wählen Sie als Gerätetyp des Simulationstargets das 64 Bit Gerät CODESYS Control Win . Doppelklicken Sie auf das Gerät. Der Geräteeditor öffnet sich. Konfigurieren Sie Folgendes: Fügen Sie einen Ethernet Adapter hinzu. Fügen Sie einen PROFINET Controller hinzu. Fügen Sie einen Eingang 8 Bit hinzu. Fügen Sie einen Ausgang 8 Bit hinzu. Deklarieren Sie zwei Byte-Variablen in PLC_PRG und verwenden Sie die Variablen in Ihrem Applikationscode. byIn , byOut Ordnen Sie die Variablen einem Eingang und einem Ausgang zu. Generieren Sie den Code. Im Gutfall wird der Build ohne Fehler durchgeführt. Nun haben Sie den folgenden Gerätebaum: Dies ist die Applikation, die wir simulieren wollen. Mit den folgenden Schritten fügen Sie die Simulationsschnittstelle hinzu. Sie konfigurieren diese, um die Applikation zu simulieren. Selektieren Sie die Applikation und wählen Sie im Kontextmenü den Befehl Objekt hinzufügen → Simulation Interface . Beenden Sie den sich öffnenden Dialog mit einem Klick auf den Befehl Hinzufügen . Die Simulationsschnittstelle ist hinzugefügt und kann nun konfiguriert werden. Lassen Sie für diese ersten Schritte die Standardwerte unverändert und passen Sie nur die IP-Adresse des Geräts an. Geben Sie die lokale Adresse ein, z. B. 192.168.178.47. Setzen Sie in der Registerkarte Konfiguration die Einstellung Simulationsoptionen auf Nur gemappte E\/A-Signale . Aktivieren Sie die Einstellung Simulation aktiviert . Wechseln Sie zur Registerkarte Simulations-Broker . Klicken Sie auf die Schaltfläche Broker-Gerät auswählen . Wählen Sie das Gateway-1 und wählen Sie die Schaltfläche Netzwerk durchsuchen . Die Geräte SimBroker und SimTarget werden angezeigt. Wählen Sie das Gerät SimBroker . Klicken Sie auf die Schaltfläche Broker aktualisieren . Warten Sie, bis die Meldung Simulationsbroker erfolgreich aktualisiert angezeigt wird. Loggen Sie sich auf dem SimTarget Gerät ein. Dieses Informationsmodell kann nun auch von der Software gescannt werden, um Informationen über die vorhandenen Simulationstargets und das verwendete Informationsmodell zu erhalten. Das Add-on CODESYS Simulation Interface Example demonstriert dies. Sie müssen lediglich die Datei CODESYS Simulation Demonstrator.msi installieren und ausführen. Drücken Sie die Schaltfläche Durchsuchen , um nach dem Ziel zu suchen. Es sollte als ISim_Target_xxx_xxx_xxx_xxx erscheinen, wie Sie es unten sehen können. Das folgende Bild zeigt auch die Verwendung des Objekts Simulation Interface und die Verwendung des Simulationsdemonstrators . Der Wert Application_PLC_PRG_byOut wurde vom Publisher geschrieben, der Wert Application_PLC_PRG_byIn wurde vom Simulationsdemonstrator abonniert, über OPC UA PubSub. " }, 
{ "title" : "Informationen für Entwickler ", 
"url" : "_simitf_information_for_developers.html", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Informationen für Entwickler ", 
"snippet" : "Für die Entwicklung ist es wichtig zu verstehen, dass zwei Hauptprotokolle für die Kommunikation verwendet werden. Das erste Protokoll ist OPC UA Client\/Server. Dieses Protokoll wird vom Broker und dem Simulationstool verwendet, um das Informationsmodell gemeinsam zu nutzen. Das Simulationstool (Cli...", 
"body" : "Für die Entwicklung ist es wichtig zu verstehen, dass zwei Hauptprotokolle für die Kommunikation verwendet werden. Das erste Protokoll ist OPC UA Client\/Server. Dieses Protokoll wird vom Broker und dem Simulationstool verwendet, um das Informationsmodell gemeinsam zu nutzen. Das Simulationstool (Client) liest also das Informationsmodell über OPC UA Client\/Server, und baut das Gegenteil der beschriebenen OPC UA Pub\/Sub Kommunikation auf. Für das obige Beispiel bedeutet dies, dass ein Publisher und ein Subscriber im entwickelten Simulationstool benötigt wird, um eine gültige Kommunikationsarchitektur zu erhalten: ein PublisherSet mit einem Publisher0 und ein SubsciberSet mit einem Subscriber0 . Wenn Sie den Quellcode des CODESYS Simulation Demonstrator erhalten möchten, wenden Sie sich bitte mit einer Anfrage an den Technischen Support . " }, 
{ "title" : "Informationen zum C#-Quellcode ", 
"url" : "_simitf_information_on_csharp_source.html", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Informationen für Entwickler \/ Informationen zum C#-Quellcode ", 
"snippet" : "Der Quellcode ist nicht im Beispielpaket enthalten. Die folgenden Informationen sind für Entwickler von Simulationstools interessant und wichtig. Der Simulationsdemonstrator verwendet den Open Source OPC UA Stack. Für weitere Informationen siehe: OPCFoundation\/UA-.NETStandard Im Folgenden wird die F...", 
"body" : "Der Quellcode ist nicht im Beispielpaket enthalten. Die folgenden Informationen sind für Entwickler von Simulationstools interessant und wichtig. Der Simulationsdemonstrator verwendet den Open Source OPC UA Stack. Für weitere Informationen siehe: OPCFoundation\/UA-.NETStandard Im Folgenden wird die Funktionalität der einzelnen Klassen erläutert. " }, 
{ "title" : "MainWindow.xaml.cs ", 
"url" : "_simitf_information_on_csharp_source.html#UUID-043180a5-86fa-9f2a-0dbd-f0da3a1ac489_section-idm234825454321504", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Informationen für Entwickler \/ Informationen zum C#-Quellcode \/ MainWindow.xaml.cs ", 
"snippet" : "Diese Klasse ist die oberste Klasse (Top-Layer-Klasse). browseButton_Click startet eine Zielsuchaktion. Siehe unten Simitf.cs > Erste Schritte. Ein Dialog öffnet sich und zeigt alle verfügbaren Ziele an. Siehe unten. Durch Auswahl eines Ziels werden die zweiten Schritte ausgeführt. btnStartConnectio...", 
"body" : "Diese Klasse ist die oberste Klasse (Top-Layer-Klasse). browseButton_Click startet eine Zielsuchaktion. Siehe unten Simitf.cs > Erste Schritte. Ein Dialog öffnet sich und zeigt alle verfügbaren Ziele an. Siehe unten. Durch Auswahl eines Ziels werden die zweiten Schritte ausgeführt. btnStartConnection_Click startet eine Verbindung zum ausgewählten Ziel. Siehe unten PubSubConfigurator.cs . PubSubApplication_DataReceived wird aufgerufen, wenn neue Daten einer Subscription empfangen werden. DispatcherTimer_Tick : Dekodierung oder Kodierung der Pub\/Sub-Daten. " }, 
{ "title" : "SimItf.cs ", 
"url" : "_simitf_information_on_csharp_source.html#UUID-043180a5-86fa-9f2a-0dbd-f0da3a1ac489_section-idm234825461659681", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Informationen für Entwickler \/ Informationen zum C#-Quellcode \/ SimItf.cs ", 
"snippet" : "Diese Klasse enthält Code zum Durchsuchen des Brokers, um Informationen über die vorhandenen Simulations-Targets zu erhalten. Das Durchsuchen erfolgt in zwei Schritten: Erste Schritte Der Konstruktor liest den Namespace-Index des CODESYS Simulationsinterfaces. Und der Konstruktor liest alle verfügba...", 
"body" : "Diese Klasse enthält Code zum Durchsuchen des Brokers, um Informationen über die vorhandenen Simulations-Targets zu erhalten. Das Durchsuchen erfolgt in zwei Schritten: Erste Schritte Der Konstruktor liest den Namespace-Index des CODESYS Simulationsinterfaces. Und der Konstruktor liest alle verfügbaren Simulationsinterface-Targets aus dem Broker (Eigenschaft Targets ). Zweite Schritte Über die Public Methode Set Target kann eines der verfügbaren Simulationsinterface-Targets ausgewählt werden. Das ausgewählte Target wird im Detail nach allen Publishern, Subscriber und benötigten Datensätzen durchsucht. Die durchsuchten Informationen sind über die Eigenschaften auslesbar (siehe Code). " }, 
{ "title" : "PubSubConfigurator.cs ", 
"url" : "_simitf_information_on_csharp_source.html#UUID-043180a5-86fa-9f2a-0dbd-f0da3a1ac489_section-idm23482546491366", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Informationen für Entwickler \/ Informationen zum C#-Quellcode \/ PubSubConfigurator.cs ", 
"snippet" : "Diese Klasse übernimmt die Pub\/Sub-Konfiguration für das ausgewählte Ziel. Rufen Sie die Methode Create auf und leiten Sie die Pub\/Sub-Informationen aus der SimItf.cs weiter....", 
"body" : "Diese Klasse übernimmt die Pub\/Sub-Konfiguration für das ausgewählte Ziel. Rufen Sie die Methode Create auf und leiten Sie die Pub\/Sub-Informationen aus der SimItf.cs weiter. " }, 
{ "title" : "OPC PubSub ", 
"url" : "_simitf_opc_pubsub.html", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Informationen für Entwickler \/ OPC PubSub ", 
"snippet" : "Die Grundlage für Applikationen auf Basis des UADP Protokolls ist der konsistente Transport einer Datenstruktur über UADP, (das heißt OPC codierte Frames über UDP\/IP). Da die Konsistenz erhalten bleiben muss, muss die Datenstruktur in einen UDP-Frame (1500 Byte) passen. Da der Platz begrenzt ist, mu...", 
"body" : "Die Grundlage für Applikationen auf Basis des UADP Protokolls ist der konsistente Transport einer Datenstruktur über UADP, (das heißt OPC codierte Frames über UDP\/IP). Da die Konsistenz erhalten bleiben muss, muss die Datenstruktur in einen UDP-Frame (1500 Byte) passen. Da der Platz begrenzt ist, muss die Übertragung über UADP so effizient wie möglich sein. Nur RawData Field Encoding wird unterstützt. (Dies spart Platz.) Es werden nur DataSetMessages vom Typ Data Key Frame unterstützt. (Zyklischer Austausch von Echtzeitdaten) Die Struktur, das heißt die Abfolge von Werten ( DataSetField ) und deren Typen ( DataSetMessage ), bleibt während des Betriebs unverändert und wird im Voraus zwischen dem Herausgeber und dem Teilnehmer vereinbart. (Während des Betriebs müssen keine Metadaten übertragen werden.) Die folgende Tabelle hilft Ihnen, die verwendeten Parameter zu verstehen: Der Parameter GroupVersion wird vom Subscriber verwendet, um zu prüfen, ob die empfangene Struktur der erwarteten Struktur entspricht. Anhand des Parameters SequenceNumber kann ein Subscriber erkennen, ob Nachrichten verloren gegangen sind. Die Parameter DataSetMessag sind wie folgt aufgebaut. Die Datenstrukturen des Publishers sind 1:1 von IEC nach OPC UA kodiert. In der folgenden Tabelle werden die verwendeten Parameter erläutert. Nach dem NetworkMessage -Header wird der Parameter DataSetMessage , bestehend aus dem DataSetMessage -Header und den einzelnen DataSetField Daten (= Data Key Frame ) eingefügt. Ein DataSetField besteht aus einem Wert eines Basisdatentyps: Teil 14 der OPC UA Spezifikation besagt: Der FieldCount Parameter muss weggelassen werden, wenn die Option RwaData Field Encoding in den Flags EncodingFlags des DataSetMessage Headers ( DataSetFlags1 ) gesetzt ist. Der FieldCount ist also nicht im „Data Key Frame“ kodiert. Das bedeutet, dass für den Transport einer Datenstruktur über UADP noch 1500 Byte - 15 Byte = 1485 Byte Nutzdaten zur Verfügung stehen. Teil 14 der OPC UA Spezifikation besagt: Der FieldCount wird ignoriert, wenn die RawDate Encodings in den EncodingFlags der DataSetMessage -Header ( DataSetFalgs1 ) gesetzt sind. Der FieldCount ist daher im Data-Key-Frame nicht kodiert. Das bedeutet, dass für den Transport einer Datenstruktur über UADP noch 1500 Byte - 15 Byte = 1485 Byte Nutzdaten zur Verfügung stehen. PubSub Komponentenübersicht " }, 
{ "title" : "Technische Grundlagen ", 
"url" : "_simitf_technical_basics.html", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Informationen für Entwickler \/ Technische Grundlagen ", 
"snippet" : "Technische Grundlagen der binären Datenkodierung und des Header Layouts Die Maschine-zu-Maschine-Kommunikation ist das Hauptanwendungsgebiet der CODESYS -Bibliothek OPC UA PubSub SL . Die OPC Foundation stellt in [A6] C.2 das Profil „UADP-Periodic-Fixed“ für den Anwendungsfall der echtzeitorientiert...", 
"body" : "Technische Grundlagen der binären Datenkodierung und des Header Layouts Die Maschine-zu-Maschine-Kommunikation ist das Hauptanwendungsgebiet der CODESYS -Bibliothek OPC UA PubSub SL . Die OPC Foundation stellt in [A6] C.2 das Profil „UADP-Periodic-Fixed“ für den Anwendungsfall der echtzeitorientierten zyklischen Datenübertragung zur Verfügung. Publisher PubSub Publisher UADP Periodic Fixed Settings Der Publisher unterstützt die Kodierung von NetworkMessage und DataSetMessage Nachrichten mit UADP Message -Header für periodische Daten mit festem Layout. Subscriber PubSub Subscriber UADP Periodic Fixed Settings Der Subscriber unterstützt die Dekodierung von NetworkMessage und DataSetMessage Nachrichten mit UADP Message Header für periodische Daten mit festem Layout. Da der Platz und die Übertragungszeit begrenzt sind, muss die Datenkodierung und -übertragung über UADP so effizient wie möglich sein. Ziel ist es, eine Konfiguration des Pub\/Sub-Systems zu schaffen, die die Anforderungen an eine effiziente Übertragung erfüllt. Das heißt, so wenig Metadaten wie möglich und so viel Nutzdaten pro Netzwerknachricht wie möglich. Diese Ziele können sehr gut erreicht werden, wenn die Spezifikationen aus [A6] C.2 umgesetzt werden. Die OPC Foundation benötigt für eine Pub\/Sub-Implementierung die folgenden Eigenschaften, die dem Profil UADP-Periodic-Fixed folgen: OPC UA Binäre Datenkodierung Festes Nachrichtenlayout UADP-Periodic-Fixed Header Layout [A6] C.2 Von Publisher und Subscriber wird erwartet, dass sie die Strukturen, die sie unterstützen, im Voraus kennen. " }, 
{ "title" : "OPC UA Binary Data Encoding ", 
"url" : "_simitf_opc_ua_binary_data_encoding.html", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Informationen für Entwickler \/ OPC UA Binary Data Encoding ", 
"snippet" : "Das OPC UA Binary Data Encoding ist ein Datenformat, das entwickelt wurde, um die Leistungsanforderungen von OPC UA Applikationen zu erfüllen. Dieses Format ist in erster Linie für eine schnelle Kodierung und Dekodierung konzipiert, wobei jedoch auch die Größe der kodierten Daten auf der Leitung ber...", 
"body" : "Das OPC UA Binary Data Encoding ist ein Datenformat, das entwickelt wurde, um die Leistungsanforderungen von OPC UA Applikationen zu erfüllen. Dieses Format ist in erster Linie für eine schnelle Kodierung und Dekodierung konzipiert, wobei jedoch auch die Größe der kodierten Daten auf der Leitung berücksichtigt wurde. Die OPC UA Binärdatenkodierung basiert auf mehreren primitiven Datentypen mit klar definierten Kodierungsregeln, die sequentiell in einen Binärstrom geschrieben oder daraus gelesen werden können. Eine Struktur wird durch sequentielles Schreiben der kodierten Form jedes Feldes kodiert. Wenn ein bestimmtes Feld ebenfalls eine Struktur ist, werden die Werte seiner Felder sequentiell geschrieben, bevor das nächste Feld in die enthaltende Struktur geschrieben wird. Alle Felder müssen in den Datenstrom geschrieben werden, auch wenn sie Nullwerte enthalten. Die Kodierungen für jeden primitiven Typ geben an, wie entweder ein Nullwert oder ein Standardwert für den Typ zu kodieren ist. Die OPC UA Binärdatenkodierung enthält keine Typ- oder Feldnameninformationen, da von allen OPC UA Applikationen erwartet wird, dass sie die von ihnen unterstützten Dienste und Strukturen im Voraus kennen. [P6] 5.2.1: \"Die Begriffe OPC UA Binary Data Encoding und Raw Data Field Encoding haben die identische Bedeutung und werden je nach zitierter Quelle entsprechend verwendet.“ Abbildung der elementaren Datentypen IEC 61131-3 [P6] 5.2.1 OPC UA References BOOL Boolescher Wert 1 Boolean [P6] 5.2.2.1 BYTE Byte 3 Byte CHAR Einzelbyte-Zeichen 3 Byte DATE Datum (allein) 13 DateTime DINT Doppelte Ganzzahl 6 Int32 DT Datum und Uhrzeit des Tages [s] 13 DateTime [P6] 5.2.2.5 DWORD Bitstring der Länge 32 7 UInt32 INT Integer 4 Int16 [P6] 5.2.2.1 LDATE Langes Datum [ns] 8 Int64 LDT Datum und Uhrzeit des Tages [ns] 8 Int64 LINT Lange Ganzzahl 8 Int64 LREAL Lange Gleitpunktzahl 11 Double LTIME Dauer [ns] 8 Int64 LTOD Uhrzeit [ns] 8 Int64 LWORD Bitstring der Länge 64 9 UInt64 REAL Gleitpunktzahl 10 Float [P6] 5.2.2.3 SINT Kurze Integerzahl 2 SByte STRING Kodierung: Windows-1252 12 String [P6] 5.2.2.4 TIME Dauer [ms] 8 Int64 TOD Uhrzeit [ms] 7 UInt32 UDINT 19 StatusCode [P6] 5.2.2.11 UDINT VersionTime [P4] 7.38 UDINT Vorzeichenlose doppelte Integer 7 UInt32 UINT Vorzeichenlose Integer 5 UInt16 ULINT Vorzeichenlose Iange Integer 9 UInt64 USINT Vorzeichenlose kurze Integer 3 Byte WCHAR Doppelbyte-Zeichen 5 UInt16 WORD Bitstring der Länge 16 5 UInt16 WSTRING Kodierung: UCS-2 12 String " }, 
{ "title" : "String ", 
"url" : "_simitf_opc_ua_binary_data_encoding.html#UUID-bb341947-7839-531b-1454-a1d942c90ddc_section-idm234825522855678", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Informationen für Entwickler \/ OPC UA Binary Data Encoding \/ String ", 
"snippet" : "Die Länge eines OPC UA Strings kann aufgrund seiner UTF 8-Kodierung nicht im Voraus bestimmt werden. Sie hängt von den verwendeten Zeichen ab. Daher muss bei der Definition eines DataSetFields dieses Datentyps eine maximale Länge angegeben werden. Der verbleibende Platz wird mit 0 Wertbytes aufgefül...", 
"body" : "Die Länge eines OPC UA Strings kann aufgrund seiner UTF 8-Kodierung nicht im Voraus bestimmt werden. Sie hängt von den verwendeten Zeichen ab. Daher muss bei der Definition eines DataSetFields dieses Datentyps eine maximale Länge angegeben werden. Der verbleibende Platz wird mit 0 Wertbytes aufgefüllt. Die maximale Länge eines Strings ( maxStringLength ) ist in [P14] 6.2.2.1.3 FieldMetaData beschrieben. " }, 
{ "title" : "StatusCode ", 
"url" : "_simitf_opc_ua_binary_data_encoding.html#UUID-bb341947-7839-531b-1454-a1d942c90ddc_section-idm234825523271513", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Informationen für Entwickler \/ OPC UA Binary Data Encoding \/ StatusCode ", 
"snippet" : "Die Variable StatusCode wird als UInt32 kodiert....", 
"body" : "Die Variable StatusCode wird als UInt32 kodiert. " }, 
{ "title" : "VersionTime ", 
"url" : "_simitf_opc_ua_binary_data_encoding.html#UUID-bb341947-7839-531b-1454-a1d942c90ddc_section-idm234825523466288", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Informationen für Entwickler \/ OPC UA Binary Data Encoding \/ VersionTime ", 
"snippet" : "Die Variable VersionTime ist als UInt32 kodiert. Sie stellt die Zeit in Sekunden seit dem Jahr 2000 dar. Das Epochendatum ist Mitternacht UTC (00:00) am 1. Januar 2000. Sie wird als Versionsnummer auf der Grundlage der letzten Änderungszeit verwendet. Wenn die Version aktualisiert wird, muss der neu...", 
"body" : "Die Variable VersionTime ist als UInt32 kodiert. Sie stellt die Zeit in Sekunden seit dem Jahr 2000 dar. Das Epochendatum ist Mitternacht UTC (00:00) am 1. Januar 2000. Sie wird als Versionsnummer auf der Grundlage der letzten Änderungszeit verwendet. Wenn die Version aktualisiert wird, muss der neue Wert größer sein als der vorherige Wert. Der Wert 0 wird verwendet, um anzuzeigen, dass keine Versionsinformationen verfügbar sind. " }, 
{ "title" : "Referenz ", 
"url" : "_simitf_ref.html", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Referenz ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Objekt: Simulation Interface ", 
"url" : "_simitf_ref_object_simulation_interface.html", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Referenz \/ Objekt: Simulation Interface ", 
"snippet" : "Das Objekt Simulation Interface liegt unter der Applikation. Es stellt einen Konfigurator für das Simulationsinterface und für den Simulationsbroker bereit....", 
"body" : "Das Objekt Simulation Interface liegt unter der Applikation. Es stellt einen Konfigurator für das Simulationsinterface und für den Simulationsbroker bereit. " }, 
{ "title" : "Registerkarte: Konfiguration ", 
"url" : "_simitf_ref_object_simulation_interface.html#UUID-fa9b466a-c433-1b37-c434-4e996e66915b", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Referenz \/ Objekt: Simulation Interface \/ Registerkarte: Konfiguration ", 
"snippet" : "Simulation aktiviert : Die Applikation verbindet sich mit dem Simulationstool. (Folglich sind die realen E\/As entkoppelt.) : Die Applikation verwendet die realen E\/As. Simulationsoptionen Gesamtes E\/A-Abbild Das gesamte E\/A-Abbild wird gesendet und empfangen. Es ist unabhängig davon, ob die E\/As abg...", 
"body" : "Simulation aktiviert : Die Applikation verbindet sich mit dem Simulationstool. (Folglich sind die realen E\/As entkoppelt.) : Die Applikation verwendet die realen E\/As. Simulationsoptionen Gesamtes E\/A-Abbild Das gesamte E\/A-Abbild wird gesendet und empfangen. Es ist unabhängig davon, ob die E\/As abgebildet sind oder nicht. Nur gemappte E\/A-Signale Nur die zugeordneten E\/A-Signale werden gesendet und können empfangen werden. IP-Einstellungen Publisher Multicast\/Unicast IP IP-Adresse für die Veröffentlichung der Ausgabe des E\/A-Bildes Stellen Sie sicher, dass dieser Adressbereich nicht mit anderen IT\/OT-Systemen in der gemeinsamen Umgebung übereinstimmt. Subscriber Multicast IP IP-Adresse, mit der die Eingänge des E\/A-Abbilds abonniert werden Stellen Sie sicher, dass dieser Adressbereich nicht mit anderen IT\/OT-Systemen in der gemeinsamen Umgebung übereinstimmt. IP-Adresse des Geräts IP-Adresse des Geräts, auf dem die Applikation läuft Start-Port Port für die Kommunikation Voreinstellung: 4840 Einstellungen für Senden\/Empfangen Tx Publisher ID ID für die Kommunikation über Pub\/Sub Voreinstellung: 10 Tx Writer Group Start ID ID für die Kommunikation über Pub\/Sub Voreinstellung: 10 Rx Publisher ID ID für die Kommunikation über Pub\/Sub Voreinstellung: 20 Rx Writer Group Start ID ID für die Kommunikation über Pub\/Sub Voreinstellung: 20 Alle Einstellungen sind mit einem Tooltip versehen. Der Tooltip erscheint, wenn Sie mit dem Mauszeiger über einen Einstellungsnamen fahren. " }, 
{ "title" : "Registerkarte: Status ", 
"url" : "_simitf_ref_object_simulation_interface.html#UUID-a691adfa-f347-5480-5f88-f80afe35e418", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Referenz \/ Objekt: Simulation Interface \/ Registerkarte: Status ", 
"snippet" : "Diese Seite dient der Diagnostik. Sie zeigt Informationen über den Sende- und Lesestatus der einzelnen Tasks....", 
"body" : "Diese Seite dient der Diagnostik. Sie zeigt Informationen über den Sende- und Lesestatus der einzelnen Tasks. " }, 
{ "title" : "Registerkarte: Simulations-Broker ", 
"url" : "_simitf_ref_object_simulation_interface.html#UUID-f5ac9339-10b2-87e5-ef5a-2757b5bd0b4a", 
"breadcrumbs" : "CODESYS Simulation Interface \/ Referenz \/ Objekt: Simulation Interface \/ Registerkarte: Simulations-Broker ", 
"snippet" : "Der Simulationsbroker enthält einen OPC UA Server mit dem Simulationsmodell der OPC UA Pub Sub-Konfiguration. Und er kann die Konfigurationen von mehreren Geräten verwalten. Schaltfläche: Broker-Gerät auswählen Öffnet den Dialog Gerät auswählen . Wählen Sie aus den gelisteten Steuerungen die gewünsc...", 
"body" : "Der Simulationsbroker enthält einen OPC UA Server mit dem Simulationsmodell der OPC UA Pub Sub-Konfiguration. Und er kann die Konfigurationen von mehreren Geräten verwalten. Schaltfläche: Broker-Gerät auswählen Öffnet den Dialog Gerät auswählen . Wählen Sie aus den gelisteten Steuerungen die gewünschte aus. Die Broker-Applikation kann auf jeder Standard- CODESYS -Steuerung laufen. Hinweis: Das ausgewählte Laufzeitsystem muss einen OPC UA Server bereitstellen. Hinweis: Die Gerätebeschreibung des Broker-Geräts muss im Geräte-Repository Ihres CODESYS Development System installiert sein. Schaltfläche: Broker aktualisieren Erstellt oder aktualisiert die Applikation des Simulations-Brokers Die erstellte Broker-Applikation wird zu einem bereits vorhandenen Broker-Setup hinzugefügt. Wenn kein Broker-Setup vorhanden ist, wird ein neues erstellt, heruntergeladen und automatisch gestartet. Einstellungen für Broker-Kommunikation Name des Geräts Beispiel: SimBroker Geräteadresse Beispiel: 0001 Seriennummer Target-ID Beispiel: 0000 0004 Target-Type Beispiel: 4096 Target-Hersteller Beispiel: CODESYS Target-Version Beispiel: 3.5.21.0 " }
]
$(document).trigger('search.ready');
});