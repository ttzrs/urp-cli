$(document).ready(function () {indexDict['de'] = [{ "title" : "CODESYS Git ", 
"url" : "_git_start_page.html", 
"breadcrumbs" : "CODESYS Git \/ CODESYS Git ", 
"snippet" : "CODESYS Git ermöglicht es, in CODESYS das verteilte Versionsverwaltungssystem Git zur Versionierung von CODESYS -Projekten zu verwenden. Die Funktionen von Git stehen direkt in CODESYS zur verfügung. Sie können CODESYS Git im CODESYS Store International oder im CODESYS Store North America herunterla...", 
"body" : "CODESYS Git ermöglicht es, in CODESYS das verteilte Versionsverwaltungssystem Git zur Versionierung von CODESYS -Projekten zu verwenden. Die Funktionen von Git stehen direkt in CODESYS zur verfügung. Sie können CODESYS Git im CODESYS Store International oder im CODESYS Store North America herunterladen. Dort finden Sie auch das Datenblatt zum Produkt. Release CODESYS Git (video clip) " }, 
{ "title" : "Einführung ", 
"url" : "_git_introduction.html", 
"breadcrumbs" : "CODESYS Git \/ Einführung ", 
"snippet" : "Die Implementierung von CODESYS Git ist an das Arbeiten in Git und an die Begrifflichkeiten von Git angelehnt. Nach der Installation erhalten Sie in der Menüleiste von CODESYS das Menü Git mit den Befehlen zum Initialisieren eines Git-Projekts und zum Arbeiten mit den angebundenen Git-Repositorys. S...", 
"body" : "Die Implementierung von CODESYS Git ist an das Arbeiten in Git und an die Begrifflichkeiten von Git angelehnt. Nach der Installation erhalten Sie in der Menüleiste von CODESYS das Menü Git mit den Befehlen zum Initialisieren eines Git-Projekts und zum Arbeiten mit den angebundenen Git-Repositorys. Sehen Sie im Folgenden einige Begriffsverwendungen in der CODESYS Git -Hilfe und in der CODESYS Git -Benutzeroberfläche. Entsprechende Standard-Git-Befehle sind mit angegeben. Grundkenntnisse im Arbeiten mit Git werden vorausgesetzt. Dokumentation dazu finden Sie beispielsweise hier: Git-Book , Atlassian Git Bucket Git-Repository , Git-Projektablage („Arbeitsverzeichnis“, „Arbeitsbaum“, „Working Tree“, „Git Project Storage“) Für das rein lokale Repository für ein CODESYS Git -Projekt verwenden wir hier abgekürzt den Begriff „Git-Repository“. Das Git-Repository liegt im Dateisystem in der „Git-Projektablage“ im Unterverzeichnis .git . Im Unterverzeichnis project liegen die unter Git-Verwaltung stehenden Objekte des Projekts ( <objecttype>_<ID> ). Die Objektdateien liegen in einer Verzeichnishierarchie, die der Hierarchie der Objekte im CODESYS -Projekt entspricht. Die Git-Projektablage enthält außerdem die Git-Verwaltungsdateien .gitattribute , .gitignore und .apsession . .apsession dient zur Steuerung der Zugriffe von CODESYS -Instanzen auf das Git-Repository und wird von Git ignoriert. Der Pfad der Git-Projektablage eines Projekts ist in der Ansicht Git-Projekteinstellungen sichtbar. Die Konfigurationseinstellungen, die in der Datei .git\/config vorliegen, können in einem CODESYS Git -Projekt über einen Konfigurationsdialog verändert werden. Falls aus vorherigen Git-Aktionen noch keine globale config-Datei im lokalen Benutzerverzeichnis vorliegt, wird der Anwender beim Initialisieren oder Klonen eines Projekts aufgefordert, eine Konfiguration anzulegen. CODESYS -Projektverzeichnis Ein mit CODESYS Git verwaltetes Projekt wird zusätzlich zur Git-Projektablage immer auch in einem „normalen“ CODESYS -Projektverzeichnis abgelegt (doppelte Datenhaltung). Remote-Repository Ansicht Git Remotes git remote Achten Sie auf eine sichere Verbindung zu einem Remote-Server. Für weitere Informationen siehe: Security für CODESYS Git Remote-Repositorys sind Versionen Ihres Projekts, die im Internet oder irgendwo im Netzwerk gehostet werden. Es ist durchaus möglich, dass Sie mit einem „entfernten“ Repository arbeiten können, das sich tatsächlich auf demselben Rechner (Host) befindet auf dem Sie gerade arbeiten. Das Remote-Repository heißt üblicherweise origin . Ein CODESYS -Projekt, das bereits unter Git-Verwaltung in einem lokalen Git-Repository ist, kann in der Ansicht Git Remotes mit einem Remote-Repository verknüpft werden ( git remote , git remote add ). Erst dann können lokale Branches Remote-Branches „tracken“ und können für lokale Branches äquivalente Branches im Remote Repository erzeugt werden („Upstream“). Und erst dann kann mit Fetch , Pull , Push und Merge ein Austausch\/Zusammenführen von Commits zwischen dem lokalen Git-Repository und dem Remote-Repository erfolgen. Um Git-Operationen mit einem Remote-Repository durchzuführen, werden in der Regel Anmeldedaten zur Authentifizierung benötigt. Diese werden in Windows in der Anmeldeinformationsverwaltung gespeichert. Für alle Remote-Repositorys, die auf demselben Host-Server liegen, können diesselben Anmeldedaten verwendet werden. Für weitere Informationen sehen Sie: Anmeldedaten erforderlich. Lokale Branches, Remote-Branches Ansicht Git-Branches git remote git branch Es gibt genau zwei Arten von Branches: „Lokal“ und „Remote“. Ein lokaler Branch kann genau einen Remote-Branch „tracken“. Lokale Branches: Lokale Branches werden in der Ansicht Git-Branches Lokal (<n>) angezeigt. Der lokale Standard-Branch eines Git-Repositorys (üblicherweise master entsteht automatisch nach dem ersten Commit. Wenn das CODESYS -Projekt mittels git clone erstellt wurde, trackt der lokale „master“-Branch automatisch den Remote-Branch gleichen Namens. Ein lokaler Branch entsteht auch durch Kopieren eines bereits vorhandenen lokalen Branches, oder durch Auschecken eines Remote-Branches. Im letzteren Fall trackt der neu entstandene lokale Branch automatisch den Remote-Branch. Remote-Branches: Remote-Branches werden in der Ansicht Git-Branches Remote (<n>) angezeigt. Sie sind im Git-Repository vorhandene Stellvertreter des jeweiligen gleichnamigen Branches im Remote-Repository. Remote-Branches dienen nur intern als „Zwischenstation“ bei der Kommunikation über Push \/ Pull mit dem Remote-Repository und werden vom Anwender nicht direkt benutzt. „ Upstream \" Befehl in der Ansicht Git-Branches Lokal git branch --set-upstream-to <origin\/remote-branch> Die Aktion Upstream Set bewirkt, dass ein dem lokalen Branch entsprechender Branch im Remote-Repository angelegt wird (Remote-Branch). „ Tracken \", „Remote Tracking Branches“ Befehl in der Ansicht Git-Branches git branch --track git checkout Branch tracken heißt, die Verknüpfung eines lokalen Branches mit einem Remote-Branch herstellen. Standardfall: Der lokale Stellvertreter-Branch master des Git-Repositorys trackt den Remote-Branch origin\/master des Remote-Repositorys. Wenn ein lokaler Branch einen Remote-Branch trackt, ist ein Austausch von Commits mit dem Remote Repository über Pull und Push möglich. Alternativ können Sie auch mit dem Befehl Checkout in der Ansicht Git-Branches Remote (<n>) für einen vorhandenen Remote-Branch einen lokalen „tracking“ Branch erzeugen, der gleichzeitig als „Aktueller“ Branch gesetzt wird. Der aktuelle (current) Branch ist derjenige Branch, in dem neue Commits ankommen. Git Index Ansicht Git-Status git status Der Index ist eine Git-interne Zwischenebene zwischen Arbeitsverzeichnis und Git-Repository. Er ermöglicht, gezielt nur eine Auswahl von geänderten Objekten für einen Commit vorzumerken. Nicht alle Änderungen müssen als Commit eingecheckt werden. Objekte, die im Git-Index liegen, sind in der Ansicht Status & Vormerken in der Sektion Vorgemerkte Änderungen sichtbar. Resynchronisierung und Neuladen des Projekts Synchronisierung Eine Resynchronisation des CODESYS -Projekts in CODESYS mit dem aktuellen Stand aus der Git-Projektablage erfolgt nach jeder Git-Operation, die eine Änderung am Git-Repository ausführt. Solche Operationen sind u.a.: Checkout , Pull und Merge von Branches (Ansicht Git-Branches ) Alle Änderungen verwerfen und Alle nicht übertragenen Änderungen rückgängig machen (Ansicht Status & Vormerken ) Änderungen durch das Auflösen von Konflikten Das Resynchronisieren des CODESYS -Projekts bewirkt, dass das Projekt als Ganzes neu aus dem Repository erstellt wird. Es wird nicht versucht, das Projekt zu aktualisieren. Mit dem Befehl Projekt aus Repository neu laden können Sie eine Resynchronisierung explizit veranlassen. MIt Synchronisierung ist umgekehrt die Übernahme von Änderungen aus der CODESYS -Projektablage in die Git-Projektablage gemeint. Dies erfolgt immer dann, wenn im CODESYS -Projekt geändert wird. Bei Änderungen im Projekt werden nur genau diese übernommen. Wenn das Projekt neu geöffnet wird, wird das komplette Projekt erneut in die Git-Projektablage übernommen und überschreibt den dortigen Stand. Mit dem Befehl Projekt mit Git-Projektablage synchronisieren (standardmäßig nicht im Git-Menü) können Sie eine Synchronisierung explizit veranlassen. " }, 
{ "title" : "Projekt unter Git-Kontrolle bringen ", 
"url" : "_git_setting_up_repositories.html", 
"breadcrumbs" : "CODESYS Git \/ Projekt unter Git-Kontrolle bringen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Repositorys und Branches in CODESYS Git ", 
"url" : "_git_setting_up_repositories.html#UUID-45dd2cae-82b0-7a65-3526-e4fdc7369aa4_id_d99ef84311db29bfc0a8646324d30e24-id-73febd7011db29bfc0a86463349a40b7", 
"breadcrumbs" : "CODESYS Git \/ Projekt unter Git-Kontrolle bringen \/ Repositorys und Branches in CODESYS Git ", 
"snippet" : "Für die Verwaltung eines CODESYS -Projekts in Git mit Hilfe von CODESYS Git genügt zunächst ein rein lokales Git-Repository in der „Projektablage“ (Arbeitsverzeichnis), im Folgenden auch nur „Git-Repository“ genannt. Für die Zusammenarbeit mit anderen Entwicklern am Projekt kann das lokale Git-Repos...", 
"body" : "Für die Verwaltung eines CODESYS -Projekts in Git mit Hilfe von CODESYS Git genügt zunächst ein rein lokales Git-Repository in der „Projektablage“ (Arbeitsverzeichnis), im Folgenden auch nur „Git-Repository“ genannt. Für die Zusammenarbeit mit anderen Entwicklern am Projekt kann das lokale Git-Repository mit einem allen zugänglichen „ Remote-Repository “ verknüpft werden. Das Arbeiten am Git-verwalteten Projekt erfolgt zunächst in lokalen Branches (Arbeitsständen). Die lokalen Branches können einen Remote-Branch tracken, also eine Verbindung zum Remote-Repository haben. Remote-Branches sind im lokalen Git-Repository verfügbare Stellvertreter des jeweiligen gleichnamigen Branches im Remote-Repository. Sie können ein Git-Repository mit dem Befehl Repository verschieben an einen anderen Ort im Dateisystem verschieben. Sie können mit dem Befehl Von Git-Repository trennen ein Projekt von der Quellcodeverwatlung in Git trennen. Wenn für das CODESYS -Projekt eine Verschlüsselung eingestellt ist ( CODESYS - Projekteinstellungen - Sicherheit ), ist das Git-Repository (weder lokal noch Remote) nicht automatisch auch entsprechend geschützt. " }, 
{ "title" : "CODESYS -Projekt über git init unter Git-Verwaltung bringen ", 
"url" : "_git_setting_up_repositories.html#UUID-45dd2cae-82b0-7a65-3526-e4fdc7369aa4_id_d99ef84311db29bfc0a8646324d30e24-id-e53fbb62a75511ebb64e996906c7fdba", 
"breadcrumbs" : "CODESYS Git \/ Projekt unter Git-Kontrolle bringen \/ CODESYS -Projekt über git init unter Git-Verwaltung bringen ", 
"snippet" : "Voraussetzung: CODESYS Git ist installiert. Sie haben ein CODESYS -Projekt geöffnet. Bereiten Sie im Dateisystem ein leeres Verzeichnis für die Git-Projektablage vor, das das lokale Git-Repository enthalten soll. Beispiel: D:\\git_local\\rep1 Öffnen Sie das CODESYS -Projekt, das unter Git-Verwaltung g...", 
"body" : "Voraussetzung: CODESYS Git ist installiert. Sie haben ein CODESYS -Projekt geöffnet. Bereiten Sie im Dateisystem ein leeres Verzeichnis für die Git-Projektablage vor, das das lokale Git-Repository enthalten soll. Beispiel: D:\\git_local\\rep1 Öffnen Sie das CODESYS -Projekt, das unter Git-Verwaltung gebracht werden soll, in CODESYS Git . Beispiel: myproj.project . Wählen Sie den Befehl Git → Git-Repository initialisieren... . Der Dialog Git-Repository initialisieren öffnet sich. Tragen Sie im Dialog den Pfad des leeren Verzeichnisses für die Git-Projektablage ein (Beispiel: D:\\git_local\\rep1 ). Das darin angelegte Git-Repository wird Ihr lokaler „master“. Falls im lokalen Benutzerverzeichnis (z.B. C:\\Benutzer\\m.muster ) noch keine globale Konfigurationsdatei .gitconfig vorliegt, werden Sie jetzt in einem Meldungsdialog aufgefordert, eine solche Grundkonfiguration für alle CODESYS Git -Aktionen anzulegen. Sie erhalten zur Eingabe einiger Parameter denselben Dialog wie über den Befehl Git Config . Die Standardeinstellung für Standard-Branch ist master . Geben Sie Ihre Benutzerdaten Benutzername und Email -Adresse an (Beispiel m.muster , m.muster@company.com ). Die Objekte im Projektnavigator sind mit blauen Plussymbolen (Status „hinzugefügt“) versehen, der Wurzelknoten (Projektname) mit einem orangem Quadratsymbol (Status „geändert“). In der Ansicht Git → Projekteinstellungen wird der Pfad der Git-Projektablage angezeigt. Damit ist die Projektverwaltung in dem in der Projektablage liegenden Git-Repository initialisiert. Speichern Sie das Projekt, wie ohne Git-Verwaltung üblich, in einem separaten Projektverzeichnis (Beispiel: D:\\git_projects\\myproj.project ). Hinweis: Die Projektdateien unterliegen somit doppelter Datenhaltung. Öffnen Sie die Ansicht Git-Status . Wählen Sie die im unteren Teil Nicht vorgemerkte Änderungen die angezeigten Projektobjekte aus. Klicken Sie dann auf die Schaltfläche , um sie für einen Commit vorzumerken. Die Objekte werden nach oben unter Vorgemerkte Änderungen verschoben. Klicken Sie die Schaltfläche (Commit). Geben Sie im Dialog Vorgemerkte Änderungen committen eine Commit-Meldung ein und bestätigen Sie mit OK . Der aktuelle Stand der Projektobjekte wird in das lokale Repository übertragen. Wählen Sie den Befehl Git → Git History . In der Ansicht History wird der erste Commit für den „master“ mit Informationen dazu dargestellt. Im Projektnavigator erscheinen grüne Kreissymbole vor den committeten Objekten und auch vor der Wurzel. Dies bedeutet, der Stand des Projekts ist synchron mit seinem Stand im Git-Repository. Wählen Sie den Befehl Git → Git Branches und aktivieren Sie den Filter Local (1) . Der Default-Branch für das Git-Repository ist als master (refs\/heads\/master) sichtbar. Sehen Sie im Dateisystem ins lokale Repository D:\\git_local\\rep1 . Hier liegt jetzt das Verzeichnis .git (das eigentliche Git-Repository) mit dem Unterverzeichnis project und den Dateien .gitattributes , .gitignore und .apsession . Das Verzeichnis project enthält die Objekte des CODESYS -Projekts. Nun können Sie das Projekt, sobald erforderlich, noch mit einem Remote-Repository verbinden. " }, 
{ "title" : "Über Git-Repository klonen... ein neues CODESYS -Projekt erstellen, das bereits unter Git-Verwaltung steht ", 
"url" : "_git_setting_up_repositories.html#UUID-45dd2cae-82b0-7a65-3526-e4fdc7369aa4_id_d99ef84311db29bfc0a8646324d30e24-id-11ad0c1713d3a29ac0a8646340f28253", 
"breadcrumbs" : "CODESYS Git \/ Projekt unter Git-Kontrolle bringen \/ Über Git-Repository klonen... ein neues CODESYS -Projekt erstellen, das bereits unter Git-Verwaltung steht ", 
"snippet" : "Mittels Git Clone wird ein neues CODESYS -Projekt erstellt, das unter Git-Versionsverwaltung liegt. Dabei wird die neue Projektablage, also das neue Arbeitsverzeichnis mit dem Git-Repository, durch Klonen eines Remote-Repositorys erzeugt. Voraussetzung: CODESYS Git ist installiert. Sie haben Zugriff...", 
"body" : "Mittels Git Clone wird ein neues CODESYS -Projekt erstellt, das unter Git-Versionsverwaltung liegt. Dabei wird die neue Projektablage, also das neue Arbeitsverzeichnis mit dem Git-Repository, durch Klonen eines Remote-Repositorys erzeugt. Voraussetzung: CODESYS Git ist installiert. Sie haben Zugriff auf ein Remote-Repository. Öffnen Sie CODESYS Git . Wählen Sie den Befehl Git → Git-Repository klonen... . Er ist verfügbar, wenn kein CODESYS -Projekt geöffnet ist. Der Dialog Git Clone öffnet sich. Geben Sie als Quell-URL die URL oder den Dateipfad des zu klonenden Remote-Repositorys an (Beispiel: D:\\git_remotes\\remote1 ). Geben Sie bei Git-Speicherpfad das für die neue Git-Projektablage (neues Git-Repository) vorgesehene leere Dateiverzeichnis an (Beispiel: D:\\git_local\\rep1 ). Geben Sie bei Projektdatei ein Projektverzeichnis an, in dem das neue CODESYS -Projekt zusätzlich und außerhalb von Git (!) abgelegt werden soll (Beispiel: D:\\git_projects\\myproj1.project , doppelte Datenhaltung!). Wählen Sie bei Projektdateityp , ob es ein Standardprojekt oder ein Bibliotheksprojekt werden soll. Bestätigen Sie den Dialog. Falls im lokalen Benutzerverzeichnis (z.B. C:\\Benutzer\\m.muster ) noch keine globale Konfigurationsdatei .gitconfig vorliegt, werden Sie jetzt in einem Meldungsdialog aufgefordert, eine solche Grundkonfiguration für alle CODESYS Git -Aktionen anzulegen. Sehen Sie dazu oben die Anleitung für das Initialisieren eines Git-Projekts, Schritt 4. Wenn die Git-Option Selbstsigniertes Zertifikat akzeptieren nicht aktiviert ist, prüft CODESYS Git zunächst das Zertifikat für die Verbindung mit dem Server, von dem das Projekt geklont werden soll. Wenn das Zertifikat nicht vertrauenswürdig ist, erhalten Sie die Möglichkeit, die Verbindung nach persönlicher Prüfung dennoch zuzulassen. Das neue Projekt wird geöffnet. Das neue Arbeitsverzeichnis wird angelegt und automatisch als Git-Repository initialisiert. Es enthält zunächst genau den Stand des Remote-Repositorys zum Zeitpunkt des Klonens. Wählen Sie im CODESYS -Projekt den Befehl Git → Git Branches . In der Ansicht Git-Branches sind bereits die Remote-Branches zu sehen. Standardmäßig wird für den Remote-Branch „master“ auch ein lokaler Branch „master“ angelegt, der den Remote-Branch trackt. Sie können nun sofort auf diesem lokalen Branch arbeiten. Auch eine Verbindung (Tracking) des lokalen Branches zum „Stellvertreter“-Remote-Branch ( origin\/master ) des neuen Git-Repositorys ist bereits hergestellt. " }, 
{ "title" : "Projekt mit einem Remote-Repository verknüpfen ", 
"url" : "_git_setting_up_repositories.html#UUID-45dd2cae-82b0-7a65-3526-e4fdc7369aa4_id_d99ef84311db29bfc0a8646324d30e24-id-57b75172176320a3c0a864631b96d43f", 
"breadcrumbs" : "CODESYS Git \/ Projekt unter Git-Kontrolle bringen \/ Projekt mit einem Remote-Repository verknüpfen ", 
"snippet" : "Voraussetzung: Sie haben ein Projekt unter Git-Verwaltung in CODESYS Git . Nun möchten Sie die Verbindung zu einem Remote-Repository herstellen, um dort Ihre Commits mit den Commits anderer Bearbeiter zu synchronisieren. Wählen Sie den Befehl Git → Git-Remotes . Klicken Sie in der Ansicht Git-Remote...", 
"body" : "Voraussetzung: Sie haben ein Projekt unter Git-Verwaltung in CODESYS Git . Nun möchten Sie die Verbindung zu einem Remote-Repository herstellen, um dort Ihre Commits mit den Commits anderer Bearbeiter zu synchronisieren. Wählen Sie den Befehl Git → Git-Remotes . Klicken Sie in der Ansicht Git-Remotes auf die Schaltfläche Hinzufügen . Der Dialog Neues Git-Remote hinzufügen öffnet sich. Geben Sie den Pfad und einen Namen für das anzubindende Remote-Repository ein. Beispiel: Alias-Name : origin , URL : D:\\git_remote . Führen Sie den Befehl Fetch aus und wechseln Sie dann mit dem Befehl Git → Git-Branches zur Ansicht Git-Branches . Üblicherweise sind für den Zugriff auf ein Remote-Repository Anmeldedaten nötig. Nur falls auf dem Computer keine gültigen Anmeldedaten gefunden werden, erhalten Sie zur Eingabe den Dialog Anmeldedaten erforderlich . Sehen Sie für weitere Informationen: Anmeldedaten erforderlich. Aktivieren Sie den Filter Remote (<n>) . Sie sehen die Remote-Branches. Deaktivieren Sie den Filter Remote (<n>) . Aktiveren Sie den Filter Lokal (1) . Selektieren Sie den Eintrag master und wählen Sie den Befehl Upstream Set . Wenn es für das gewählte Remote-Repository noch keinen Remote-Branch ( origin\/master ) gibt, geschieht Folgendes: Der Dialog Upstream-Remote für Branch setzen öffnet sich. Der Remote-Name origin ist bereits vorgegeben. Bestätigen Sie die Eingaben mit OK . → Für den master sind die Optionen Tracking und Aktueller aktiviert. Unter Tracked Branch, Name steht origin\/master . Das bedeutet, der Remote-Branch origin\/master für das Remote-Repository ist intern angelegt. Er dient nur als Stellvertreter, auf diesem Branch wird nicht direkt gearbeitet. Selektieren Sie den master und klicken Sie Push , um. Aktivieren Sie den Filter Remote (1) . Nun wird der Stellvertreter-Branch origin\/master unter Git-Branches Remote (1) auch angezeigt. Die Verbindung vom lokalen master zum Remote-Repository über dessen Stellvertreter origin\/master ist hergestellt. Nun können Sie in der Ansicht Git-Branches Lokal (<1>) den lokalen Branch ( master ) des Git-Repositorys mit Hilfe des Befehls Branch tracken mit dem neuen Remote-Branch des Remote-Repositorys verknüpfen. " }, 
{ "title" : "„Best Practices“ ", 
"url" : "_git_best_practises.html", 
"breadcrumbs" : "CODESYS Git \/ „Best Practices“ ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Wiederherstellen eines Git-Projekts im Fall eines Crashes von CODESYS während der Projektbearbeitung ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm457535419458083309225168268", 
"breadcrumbs" : "CODESYS Git \/ „Best Practices“ \/ Wiederherstellen eines Git-Projekts im Fall eines Crashes von CODESYS während der Projektbearbeitung ", 
"snippet" : "Je nachdem, bei welchem Vorgang CODESYS zuvor abgestürzt ist, haben Sie folgende Möglichkeiten zur Wiederherstellung: Normalerweise können Sie nach einem Crash das Projekt erneut öffnen. CODESYS Git stellt den zuletzt intern gespeicherten Projektstand wieder her und schreibt die Projektinhalte erneu...", 
"body" : "Je nachdem, bei welchem Vorgang CODESYS zuvor abgestürzt ist, haben Sie folgende Möglichkeiten zur Wiederherstellung: Normalerweise können Sie nach einem Crash das Projekt erneut öffnen. CODESYS Git stellt den zuletzt intern gespeicherten Projektstand wieder her und schreibt die Projektinhalte erneut in die Git-Projektablage. Dieser \"failsave\"-Mechanismus behandelt das Projekt als \"Master\"-Datenquelle. Wenn das Projekt während eines Merge-Vorgangs abgestürzt ist, sollten Sie vor dem Weiterarbeiten nach dem erneuten Öffnen nicht gleich speichern, sondern zunächst alle Änderungen verwerfen (git reset --hard). Dazu können Sie in der Ansicht Status & Vormerken den Befehl Alle Änderungen verwerfen verwenden. Falls das Öffnen des Projekts nach dem Crash nicht mehr gelingt, beispielsweise weil völlig inkompatible Dateien in die Projektablage gelangt waren, haben Sie folgende Möglichkeit einer Wiederherstellung: Laden Sie das Projekt komplett neu aus dem Repository. Sehen Sie dazu: Projekt aus Repository neu laden" }, 
{ "title" : "Übertragen eines Projekts von CODESYS SVN nach CODESYS Git ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm4543860664779233978358194268", 
"breadcrumbs" : "CODESYS Git \/ „Best Practices“ \/ Übertragen eines Projekts von CODESYS SVN nach CODESYS Git ", 
"snippet" : "Wir empfehlen Ihnen dringend, die SVN-Projektarchive nach der erfolgreichen Übertragung der Projekte nach GIT nicht zu löschen, um gegebenenfalls auf sie zurückgreifen zu können. Ab CODESYS Git Version 1.4.0.0 wird für die Übertragung eines Projekts von CODESYS SVN nach CODESYS Git eine Scripting-Sc...", 
"body" : "Wir empfehlen Ihnen dringend, die SVN-Projektarchive nach der erfolgreichen Übertragung der Projekte nach GIT nicht zu löschen, um gegebenenfalls auf sie zurückgreifen zu können. Ab CODESYS Git Version 1.4.0.0 wird für die Übertragung eines Projekts von CODESYS SVN nach CODESYS Git eine Scripting-Schnittstelle zur Verfügung stehen. Der Git-Befehl git-svn kann nicht für die Übertragung von CODESYS -Projekten aus CODESYS SVN nach CODESYS Git verwendet werden, da CODESYS Git im Gegensatz zum binären Dateiformat von CODESYS SVN das Dateiformat .json verwendet. Anmerkungen und Empfehlungen aufgrund der unterschiedlichen Projektarchiv-Struktur von CODESYS SVN und CODESYS Git In CODESYS Git kann ein Git-Repository nur ein CODESYS -Projekt verwalten. Da ein SVN-Projektarchiv mehrere CODESYS -Projekte enthalten kann, muss bei der Übertragung nach CODESYS Git für jedes Projekt eines SVN-Projektarchivs ein eigenes Git-Repository erstellt werden. Es wird empfohlen die einzelnen Projekte eines SVN-Projektarchivs projektweise in die Projektarchive von CODESYS Git zu übertragen. Es wird nicht empfohlen ein SVN-Projektarchiv in mehrere SVN-Projektarchive aufzusplitten, da dies nachträglich zu Problemen führen kann. Branches und Tags gibt es zwar sowohl in SVN als auch in GIT, allerdings sind sie in diesen beiden Systemen unterschiedlich konzipiert. Ein Transfer mit dem Befehl git-svn ist nicht möglich, da dieser Befehl in CODESYS Git nicht verwendet werden kann (siehe oben). Daher beschränken wir uns darauf, den SVN-Trunk in einen Git-Branch (standardmäßig \"Master\" oder \"Main\") zu übertragen. Wenn nötig, können die SVN-Tags manuell als Git-Tags hinzugefügt werden. " }, 
{ "title" : "Übertragung eines SVN-Projekts nach Git ohne Historie ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm4551054095480033979915375444", 
"breadcrumbs" : "CODESYS Git \/ „Best Practices“ \/ Übertragen eines Projekts von CODESYS SVN nach CODESYS Git \/ Übertragung eines SVN-Projekts nach Git ohne Historie ", 
"snippet" : "Bei diesem Verfahren wird zunächst die neueste Version des CODESYS -Projekts in CODESYS SVN ausgecheckt. anschließend wird die Verbindung zum SVN getrennt und für das Projekt ein Git-Repository mit CODESYS Git initialisiert. Der Nachteil dieses Verfahrens ist, dass die Historie des Projekts verloren...", 
"body" : "Bei diesem Verfahren wird zunächst die neueste Version des CODESYS -Projekts in CODESYS SVN ausgecheckt. anschließend wird die Verbindung zum SVN getrennt und für das Projekt ein Git-Repository mit CODESYS Git initialisiert. Der Nachteil dieses Verfahrens ist, dass die Historie des Projekts verloren geht, da nur die aktuellste SVN-Revision nach Git übertragen wird. Voraussetzungen: CODESYS SVN und CODESYS Git sind in CODESYS installiert. Über den Befehl Tools → Anpassen wurde der Befehl Alles committen der Befehlskategorie Git Integration dem Menü Git hinzugefügt. Öffnen Sie das CODESYS -Projekt, das Sie in einem SVN-Projektarchiv gespeichert haben. Wählen Sie den Befehl Projekt → SVN → Auschecken . Die aktuellste Revision des Projekts ist ausgecheckt. Wählen Sie den Befehl Projekt → SVN → Projekt von SVN trennen . Erstellen Sie im lokalen Dateiverzeichnis Ihres Rechners einen neuen leeren Ordner. Wählen in CODESYS den Befehl GiT → Git-Repostory installieren und wählen Sie in dem Dialog den in vorigen Schritt erstellten leeren Ordner aus. Wählen Sie den Befehl GiT → Alles committen . Das Projekt ist jetzt im lokalen Git-Repository gespeichert und kann bei Bedarf in ein Remote-Repository gepusht werden. " }, 
{ "title" : "Manuelle Übertragung eines SVN-Projekts nach Git mit Historie ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm4577975410139233980281280226", 
"breadcrumbs" : "CODESYS Git \/ „Best Practices“ \/ Übertragen eines Projekts von CODESYS SVN nach CODESYS Git \/ Manuelle Übertragung eines SVN-Projekts nach Git mit Historie ", 
"snippet" : "Bei diesem Verfahren wird jede einzelne SVN-Revision in einen Git-Commit manuell übertragen. Voraussetzungen: CODESYS SVN und CODESYS Git sind in CODESYS installiert. Über den Befehl Tools → Anpassen wurde der Befehl Alles committen der Befehlskategorie Git Integration dem Menü Git hinzugefügt Erste...", 
"body" : "Bei diesem Verfahren wird jede einzelne SVN-Revision in einen Git-Commit manuell übertragen. Voraussetzungen: CODESYS SVN und CODESYS Git sind in CODESYS installiert. Über den Befehl Tools → Anpassen wurde der Befehl Alles committen der Befehlskategorie Git Integration dem Menü Git hinzugefügt Erstellen Sie in CODESYS ein neues leeres Projekt und geben Sie ihm beispielsweise den Namen Main Project Wählen Sie den Befehl Git → Git-Repository initialisieren. Wählen Sie den Befehl Git → Alles committen . Führen Sie einen leeren Commit aus, indem Sie den Befehl wählen Git → Commit und dabei im Dialog Vorgemerkte Änderungen committen die Option Leeren Commit erlauben aktivieren. Schließen Sie dieses Projekt . Checken Sie die gewünschte Revision des in SVN abgelegten Projekts mit dem Befehl Projekt → SVN → Auschecken aus. Wählen Sie den Befehl Projekt → SVN → Projekt von SVN trennen und bestätigen Sie den anschließenden Dialog mit OK , ohne die standardmäßig eingestellte Option zu ändern. Speichern Sie das Projekt. Wählen Sie den Befehl Git → Git-Repository initialisieren und wählen Sie dafür im Dateiverzeichnis einen leeren Ordner, beispielsweise Temp Wählen Sie den Befehl Git → Alles committen . Speichern Sie das Projekt und schließen Sie es. Die Datei *.project dieses Projekts kann gelöscht werden, das Git-Repository Temp des Projekts darf auf keinen Fall gelöscht werden. Öffnen Sie erneut das Projekt Main Project . Öffnen Sie die Ansicht Remotes über den Befehl Git → Remotes . Wählen Sie in der Ansicht Remotes den Befehl Add und tragen Sie im Dialog Neuen Remote hinzufügen die URL des Git-Repositorys Temp ein und als Alias-Name zum Beispiel Temp_Remote ein. Selektieren Sie diesen hinzugefügten Remote und wählen Sie den Befehl Fetch . Öffnen Sie die Ansicht Git-Branches über den Befehl Git → Branches . Selektieren Sie den Master\/Main Branch von Main , wählen Sie den Befehl Branch tracken und wählen Sie im Dialog Remote-Branch tracken den Master\/Main-Branch des in Schritt 14 hinzugefügten Remotes Temp_Remote . Führen Sie einen Pull auf den Master\/Main-Branch des Git-Repositorys Main aus indem Sie in der Ansicht Git-Branches den Befehl Pull mit Optionen wählen und im Dialog Git pull master als Merge-Konflikt-Strategie die Option \"Ihres\" für Konflikte verwenden auswählen. Die voreingestellte Option für Fast-Forward-Strategie sollte nicht geändert werden. Wählen Sie nun den Befehl Git -→ Alles committen und wählen Sie dabei im Dialog Vorgemerkte und nicht vorgemerkte Änderungen committen die Option Commit abändern . Die zu Beginn der Anleitung ausgecheckte Revision des SVN-Projekts ist jetzt im Git-Repository Main als Commit abgelegt. Selektieren Sie in der Ansicht Remotes den Remote Temp und wählen Sie den Befehl Entfernen . Speichern Sie das Projekt Main Project und schließen Sie es. Entfernen Sie das Git-Repository Temp aus Ihrem Dateiverzeichnis. Wenn Sie noch eine weitere Revision des SVN-Projekts in das Git-Repository übertragen wollen, dann führen Sie diese Anleitung ab Schritt 6 für die nächste gewünschte Revision des SVN-Projekts durch. " }, 
{ "title" : "Übertragung SVN-Projekts nach Git mit Scripting ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm53402697907264", 
"breadcrumbs" : "CODESYS Git \/ „Best Practices“ \/ Übertragen eines Projekts von CODESYS SVN nach CODESYS Git \/ Übertragung SVN-Projekts nach Git mit Scripting ", 
"snippet" : "Voraussetzung: CODESYS Git Version >= 1.4.0.0 Folgende Skriptvorlagen für die Übertragung werden im Folgenden angezeigt: 1. Skript für die Übertragung eines Projekts von CODESYS SVN nach CODESYS Git 2. Skript für die Überprüfung, ob bei der Übertragung für jede SVN-Revision ein entsprechender Git-Co...", 
"body" : "Voraussetzung: CODESYS Git Version >= 1.4.0.0 Folgende Skriptvorlagen für die Übertragung werden im Folgenden angezeigt: 1. Skript für die Übertragung eines Projekts von CODESYS SVN nach CODESYS Git 2. Skript für die Überprüfung, ob bei der Übertragung für jede SVN-Revision ein entsprechender Git-Commit erstellt wurde Hinweise Am SVN-Repository werden keinerlei Änderungen vorgenommen. Beide Skripte sind als Vorlage gedacht, die Sie an die jeweiligen Anforderungen anpassen müssen. " }, 
{ "title" : "Skript für die Übertragung eines SVN-Projekts ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm4610024336323234027017655364", 
"breadcrumbs" : "CODESYS Git \/ „Best Practices“ \/ Übertragen eines Projekts von CODESYS SVN nach CODESYS Git \/ Skript für die Übertragung eines SVN-Projekts ", 
"snippet" : "Das Skript überträgt alle SVN-Revisionen des Trunks eines CODESYS SVN -Projekts in den \"Master\"-Branch eines CODESYS Git -Projekts. import os import shutil import logging \"\"\" --- inputs --- \"\"\" # URL of the SVN project you want to migrate # only migrate a single project at a time if you have multipl...", 
"body" : "Das Skript überträgt alle SVN-Revisionen des Trunks eines CODESYS SVN -Projekts in den \"Master\"-Branch eines CODESYS Git -Projekts. import os\nimport shutil\nimport logging\n\n\n\"\"\" --- inputs ---\n\"\"\"\n# URL of the SVN project you want to migrate\n# only migrate a single project at a time if you have multiple in your SVN repo\nSVN_REPO_URL = 'svn:\/\/your.svnserver.com\/trunk\/CodesysProjectNr1'\n# Starts migration at this svn revision\nSTARTING_REVISION = 0\n# Directory of the new project with the git repository\nNEW_PROJECT_DIR = 'C:\/CodesysProjects\/CodesysProjectNr1'\n# Name of the new project\nNEW_PROJECT_NAME = 'CodesysProjectNr1'\n# Is the project a library (otherwise will be checked out as a project)\nIS_LIBRARY = False\n# Path to the local git repository of the new project\nNEW_PROJECT_REPO_DIR = 'C:\/CodesysProjects\/CodesysProjectNr1\/repo'\n\n# Path to an EMPTY temporary folder (doesn't have to exist) that can be deleted\nTEMP_PATH = 'C:\/CodesysProjects\/CodesysProjectNr1\/temp'\n\n# Author of the git commits\nAUTHOR_NAME = 'Author Name'\n# E-mail address of the git commits\nAUTHOR_EMAIL = 'Author.Name@e-mail.com'\n\n# Name of the branch that should contain the history\n# Can't be named 'master'\nTARGET_BRANCH_NAME = 'develop'\n# Initial commit messages on the master branch and the target branch\nIC_MSG_MASTER = 'master: Initial commit.'\nIC_MSG_TARGET_BRANCH = 'develop: Initial commit.'\n\n# Removes the newly created project and its repository if the migration fails\nREMOVE_MAIN_PROJECT_ON_FAILURE = True\n\n\ndef get_git_commit_msg(svn_log):\n \"\"\" Returns the commit messages that will be seen in the resulting git history\n Can be customized to ones demands.\n *svn_log* see: https:\/\/content.helpme-codesys.com\/en\/ScriptingEngine\/ScriptSubversion.html#ScriptSubversion.LogInfo\n \"\"\"\n return 'SVN revision %d: %s' % (svn_log.revision, svn_log.message)\n\n\n\"\"\" --- migration script ---\n\"\"\"\n# Type extension of the project (.project \/ .library)\nPROJECT_FILE_TYPE_EXTENSION = '.library' if IS_LIBRARY else '.project'\n# Path to your new Git project\nNEW_MAIN_PROJECT_PATH = os.path.join(NEW_PROJECT_DIR, NEW_PROJECT_NAME + PROJECT_FILE_TYPE_EXTENSION)\n# Name of the temporarily added remote\nTEMP_REMOTE_NAME = 'remote1'\n# Temporary commit message will be overwritten\/amended (put what u like)\nTEMP_COMMIT_MSG = 'TEMP COMMIT: This will be overwritten'\n\n\ndef create_git_project():\n \"\"\" 1. Creates a new project at *NEW_MAIN_PROJECT_PATH*\n 2. Initializes it in git with the repository at *NEW_PROJECT_REPO_DIR*\n 3. Makes an initial commit with the message *IC_MSG_MASTER*\n 4. Creates and switches to the target branch *TARGET_BRANCH_NAME*\n 5. Makes an initial commit on the target branch with the message *IC_MSG_TARGET_BRANCH*\n 6. Saves and closes the project\n \"\"\"\n git_project = projects.create(NEW_MAIN_PROJECT_PATH)\n git_project.git.init(NEW_PROJECT_REPO_DIR)\n git_project.git.commit_complete(IC_MSG_MASTER, AUTHOR_NAME, AUTHOR_EMAIL)\n\n git_project, git_branch = git_project.git.branch_copy(TARGET_BRANCH_NAME, checkout=True)\n git_project.git.commit_complete(IC_MSG_TARGET_BRANCH, AUTHOR_NAME, AUTHOR_EMAIL, bAllowEmptyCommits=True)\n\n git_project.save()\n git_project.close()\n\n\ndef remove_all_children(project):\n \"\"\" Removes all objects that can be removed from the project *project*\n \"\"\"\n children = project.get_children(recursive=True)\n for child in children:\n try:\n child.remove()\n except Exception as ex:\n if not 'Object reference not set to an instance of an object.' == str(ex):\n logging.error(ex)\n\n\ndef create_git_repo_from_svn_revision(svn_log):\n \"\"\" 1. Checks out a project from the SVN server *SVN_REPO_URL*\n 2. Disconnects it from SVN\n 3. Initiates it in git with the repository at *repo_dir*\n 4. Makes a commit with the message *commit_message*\n 4.1 See \"get_git_commit_msg\" to customize the commit message\n 5. Saves and closes the project\n 6. Returns the path of the project and path of the repository\n \"\"\"\n project_path = os.path.join(TEMP_PATH, 'revision_' + str(svn_log.revision) + PROJECT_FILE_TYPE_EXTENSION)\n repo_dir = os.path.join(TEMP_PATH, 'repo_' + str(svn_log.revision))\n commit_message = get_git_commit_msg(svn_log)\n\n temp_project_name = 'revision_%d' % svn_log.revision\n svn_project = svn.checkout(SVN_REPO_URL, TEMP_PATH, temp_project_name, svn_log.revision, as_library=IS_LIBRARY)\n\n svn_project.svn.disconnect()\n svn_project.git.init(repo_dir)\n svn_project.git.commit_complete(commit_message, AUTHOR_NAME, AUTHOR_EMAIL)\n svn_project.save()\n svn_project.close()\n\n return project_path, repo_dir\n\n\ndef magic_git_pull(project, temp_repo_path, svn_log):\n \"\"\" 1. Removes everything from the *project* (to insure svn revision and git commit match exactly)\n 2. Pulls from the repo at *repo_path*\n 4. Commits the changes with the commit message *commit_message*\n 5. Saves and closes the project\n \"\"\"\n remove_all_children(project)\n\n # Temp commit for fake git merge --squash\n project.git.commit_complete(TEMP_COMMIT_MSG, AUTHOR_NAME, AUTHOR_EMAIL, bAllowEmptyCommits=True)\n\n project.git.remote_add(TEMP_REMOTE_NAME, temp_repo_path)\n project.git.fetch(TEMP_REMOTE_NAME)\n project.git.branch_track('refs\/remotes\/%s\/master' % TEMP_REMOTE_NAME, TARGET_BRANCH_NAME)\n\n pull_options = git.get_pull_options()\n pull_options.fast_forward_strategy = GitFastForwardStrategy.NoFastForward\n pull_options.resolve_file_conflict_strategy = GitResolveFileConflictStrategy.Theirs\n project, merge_result = project.git.pull(AUTHOR_NAME, AUTHOR_EMAIL, pull_options)\n\n commit_message = get_git_commit_msg(svn_log)\n project.git.commit_complete(commit_message, AUTHOR_NAME, AUTHOR_EMAIL, bAllowEmptyCommits=True, bAmendCommit=True)\n\n project.git.branch_unset_upstream()\n project.git.remote_remove(TEMP_REMOTE_NAME)\n\n project.save()\n project.close()\n\n\ndef remove_repo(project_path):\n try:\n project = projects.open(project_path)\n project.git.de_init(True)\n project.close()\n except:\n pass\n\n\ndef remove_temp_project(project_path):\n \"\"\" Opens the project at *project_path* and deinitializes its git repository\n This needs to be done because the script can't delete the repository with \"shutil.rmtree\"\n Removes the rest of the contents int the folder at *TEMP_PATH*\n Removes the temporary .project\/.library files and their associated files\n \"\"\"\n remove_repo(project_path)\n try:\n shutil.rmtree(TEMP_PATH)\n os.makedirs(TEMP_PATH)\n except Exception as e:\n logging.error('Failed to delete %s. Reason: %s' % (TEMP_PATH, e))\n\n\ndef main():\n if projects.primary is not None:\n projects.primary.close()\n\n create_git_project()\n\n # get the list of all revision of SVN_REPO_URL\n # oldest to newest\n # starting at revision STARTING_REVISION + 1\n svn_logs = list(reversed(svn.get_log(SVN_REPO_URL)))\n svn_logs_to_migrate = [log for log in svn_logs if STARTING_REVISION <= log.revision]\n assert svn_logs_to_migrate, ('Nothing to migrate. STARTING_REVISION is greater than the newest '\n 'revision in %s') % SVN_REPO_URL\n\n system.prompt_answers['LossOfDataWarning2'] = PromptResult.Yes\n no_project_root_dir_amount = 0\n try:\n for svn_log in svn_logs_to_migrate:\n try:\n temp_project_path, temp_git_repo_path = create_git_repo_from_svn_revision(svn_log)\n\n # pull to your main Git project\n git_project = projects.open(NEW_MAIN_PROJECT_PATH)\n\n magic_git_pull(git_project, temp_git_repo_path, svn_log)\n\n # can be omitted if enough storage space is available (big performance increase)\n # if omitted the folder at \"TEMP_PATH\" needs to be deleted manually\n # needed storage space = (project file size + project git repository size) * revisions\n # example: 255.16 MB = (1.6 KB + 2.55 MB) * 100\n remove_temp_project(temp_project_path)\n except ValueError as ve:\n # Early svn revisions often do not contain a codesys project\n if ('The URL %s is not a project root directory.' % SVN_REPO_URL) == str(ve):\n no_project_root_dir_amount += 1\n if no_project_root_dir_amount < len(svn_logs_to_migrate):\n logging.info(ve)\n continue\n logging.critical(ve)\n raise\n except:\n if REMOVE_MAIN_PROJECT_ON_FAILURE:\n remove_repo(NEW_MAIN_PROJECT_PATH)\n for file in os.listdir(NEW_PROJECT_DIR):\n if file.startswith(NEW_PROJECT_NAME):\n os.remove(os.path.join(NEW_PROJECT_DIR, file))\n raise\n finally:\n system.prompt_answers.clear()\n\n\nif __name__ == '__main__':\n main()\n\n " }, 
{ "title" : "Skript für die Überprüfung des Übertragungsergebnisses ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm53402698265504", 
"breadcrumbs" : "CODESYS Git \/ „Best Practices“ \/ Übertragen eines Projekts von CODESYS SVN nach CODESYS Git \/ Skript für die Überprüfung des Übertragungsergebnisses ", 
"snippet" : "Das unten gezeigte Skript dient folgenden Überprüfungen: Überprüfung, ob es nach der Übertragung für jede SVN-Revision des Trunks eines CODESYS SVN -Projekts einen entsprechenden Git-Commit im CODESYS Git -Projekt gibt Überprüfung, ob das CODESYS -Projekt einer SVN-Revision und das CODESYS -Projekt ...", 
"body" : "Das unten gezeigte Skript dient folgenden Überprüfungen: Überprüfung, ob es nach der Übertragung für jede SVN-Revision des Trunks eines CODESYS SVN -Projekts einen entsprechenden Git-Commit im CODESYS Git -Projekt gibt Überprüfung, ob das CODESYS -Projekt einer SVN-Revision und das CODESYS -Projekt des entsprechenden Git-Commits identisch sind Der Vergleich eines CODESYS -Projekts basiert auf der CODESYS -Entwicklungsumgebung, in der die Übertragung und die Überprüfung durchgeführt werden. Die in CODESYS übliche Skripting-Methode compare_to() verhält sich in diesem Zusammenhang nicht wie erwartet. Aus diesem Grund wird in dem Script ein Workaround verwendet. import os\nimport logging\n\n\n\"\"\" --- inputs ---\n\"\"\"\n# URL of the SVN project you want to check the migration for\nSVN_REPO_URL = 'svn:\/\/your.svnserver.com\/trunk\/CodesysProjectNr1'\n# Directory of the project with git repository to check\nPROJECT_DIR = 'C:\/CodesysProjects\/CodesysProjectNr1'\n# Name of the project to check\nPROJECT_NAME = 'CodesysProjectNr1'\n# Is the project a library (otherwise will be checked out as a project)\nIS_LIBRARY = False\n\n# Path to an EMPTY temporary folder (doesn't have to exist) that can be deleted\nTEMP_PATH = 'C:\/CodesysProjects\/CodesysProjectNr1\/temp'\n\n# Name of the branch that should be checked\nTARGET_BRANCH_NAME = 'develop'\n\n\"\"\" --- check script ---\n\"\"\"\n# Type extension of the project (.project \/ .library)\nPROJECT_FILE_TYPE_EXTENSION = '.library' if IS_LIBRARY else '.project'\n# Path to your new Git project\nMAIN_PROJECT_PATH = os.path.join(PROJECT_DIR, PROJECT_NAME + PROJECT_FILE_TYPE_EXTENSION)\n\n\ndef get_revision_from_commit_msg(msg):\n \"\"\" filters out the revision number from the commit message *msg*\n migrated SVN commits in git: git commit = 'SVN revision *revision number*: *svn commit message*'\n if your migrated svn commits in git are different this possibly won't work\n \"\"\"\n s_num = ''\n for c in msg:\n if c.isdigit():\n s_num = s_num + c\n if ':' == c:\n break\n return int(s_num)\n\n\ndef compare_changed_objects_workaround(changed_objects):\n \"\"\" Compares the changed objects in the *changed_objects* list\n by comparing their content\n Returns True if the objects are identical (not changed)\n \"\"\"\n for changed_object in changed_objects:\n if changed_object.left_object is None:\n return False\n if changed_object.right_object is None:\n return False\n if not changed_object.left_object.textual_declaration.text == changed_object.right_object.textual_declaration.text:\n logging.error('Compared objects are not the same:')\n logging.error('left: %s\/%s' %\n (changed_object.left_object.parent.get_name(), changed_object.left_object.get_name()))\n logging.error(changed_object.left_object.textual_declaration.text)\n logging.error('right: %s\/%s' %\n (changed_object.right_object.parent.get_name(), changed_object.right_object.get_name()))\n logging.error(changed_object.right_object.textual_declaration.text)\n logging.error('diff: ' + str(changed_object.differences))\n logging.error('-----------------------------------------------------')\n return False\n return True\n\n\ndef compare_projects(project_one, project_two):\n \"\"\" Compares two projects\n Returns True if they are identical\n \"\"\"\n comparison_result = project_one.compare_to(project_two, flags=ComparisonFlags.IGNORE_PROPERTIES)\n changed_objects = list(comparison_result.get_changed_objects())\n\n if 0 == len(changed_objects):\n return True\n else:\n return compare_changed_objects_workaround(changed_objects)\n\n\ndef main():\n system.prompt_handling = PromptHandling.LogSimplePrompts\n\n if projects.primary is not None:\n projects.primary.close()\n\n git_project = projects.open(MAIN_PROJECT_PATH)\n\n git_project, git_branch = git_project.git.checkout(TARGET_BRANCH_NAME, force=True)\n\n git_logs = list(reversed(list(git_project.git.log())))\n\n system.prompt_answers['LossOfDataWarning2'] = PromptResult.Yes\n\n checks_done = 0\n try:\n for git_log in git_logs:\n if 'SVN revision ' in git_log.message_string:\n git_project, git_null_branch = git_project.git.checkout(git_log.sha_string)\n\n revision = get_revision_from_commit_msg(git_log.message_string)\n\n temp_project = svn.checkout(SVN_REPO_URL, TEMP_PATH, 'revision_' + str(revision), revision,\n as_library=IS_LIBRARY ,as_primary_project=False)\n\n if not compare_projects(git_project, temp_project):\n prompt_message = (\"Revision %d does not equal it's corresponding git commit. \"\n \"Do you want to continue?\") % revision\n logging.error(prompt_message)\n prompt_result = system.ui.prompt(prompt_message, PromptChoice.YesNo, PromptResult.No)\n if PromptResult.No == prompt_result:\n temp_project.close()\n break\n\n checks_done += 1\n temp_project.close()\n finally:\n system.prompt_answers.clear()\n git_project, git_branch = git_project.git.checkout(TARGET_BRANCH_NAME)\n git_project.close()\n\n if checks_done:\n system.ui.prompt('Done', PromptChoice.OK, PromptResult.OK)\n else:\n error_msg = 'No migrated commits found. If you have custom commit messages change this script accordingly.'\n logging.error(error_msg)\n raise Exception(error_msg)\n\n\nif __name__ == '__main__':\n main()\n \n " }, 
{ "title" : "Merge-Konflikte, \"Relationship Issues\" ", 
"url" : "_git_merge_conflicts.html", 
"breadcrumbs" : "CODESYS Git \/ Merge-Konflikte, \"Relationship Issues\" ", 
"snippet" : "Ein Merge-Vorgang führt die Inhalte zweier Branches zusammen, die einen gemeinsamen Vorfahren haben, aber unterschiedliche Änderungen erhalten haben. Gezieltes Mergen von Branches wird in erster Linie in der Ansicht Git-Branches mit dem Befehl Merge durchgeführt. Ein Merge-Vorgang ist außerdem in ei...", 
"body" : "Ein Merge-Vorgang führt die Inhalte zweier Branches zusammen, die einen gemeinsamen Vorfahren haben, aber unterschiedliche Änderungen erhalten haben. Gezieltes Mergen von Branches wird in erster Linie in der Ansicht Git-Branches mit dem Befehl Merge durchgeführt. Ein Merge-Vorgang ist außerdem in einer Pull-Aktion beinhaltet. Unterschiedliche Stände von Quell- und Zielbranch werden beim Merge-Vorgang festgestellt und als Konflikt bezeichnet. Eine durch das Mergen entstandene unzulässige Projektstruktur wird als \"Relationship Issue\" festgestellt. Je nach eingestellter Option versucht CODESYS Git diese Konflikte soweit möglich automatisch zu lösen, oder wird diese Lösung dem Anwender überlassen. Nach erfolgter Konfliktlösung versucht CODESYS Git immer ein Resynchronisieren , also ein erneutes Einlesen des Projekts aus der Projektablage. Dazu wird das in CODESYS geöffnete Projekt geschlossen und ein neues aus der Ablage erstellt. CODESYS Git unterscheidet zwei Typen von aufzulösenden Problemen, die beim Mergen auftreten können: Konflikte : Reine Git-Konflikte: Ein oder mehrere Objekte erhielt(en) konkurrierende Änderungen. Es kann sich um unterschiedliche Änderungen im Inhalt eines Objekts handeln. Die grundlegende \"Merge-Konflikt-Strategie\" ist in den Git-Merge-Optionen in der Ansicht Git-Branches festgelegt. Davon abhängig läuft entweder eine soweit möglich automatische Konfliktlösung, oder eine grundsätzliche Übernahme in eine bestimmte Richtung, oder eine händisch vorzunehmende Behandlung der Konflikte. Im Fall der händischen Konfliktlösung werden die konfliktbehafteten Objekte in der Ansicht Status & Vormerken als solche dargestellt. Durch einen Doppelklick auf ein konfliktbehaftetes Objekt wird eine Vergleichsansicht geöffnet. In der Vergleichsansicht sind die aus den beiden Branches stammenden Änderungen einander gegenüber gestellt. Inhaltliche Unterschiede können Sie durch gezieltes Übernehmen bereinigen. Wenn es sich um reine Namensraumkonflikte handelt, müssen Sie diese durch Umbenennen oder Löschen im Projektbaum lösen. Mit Anwenden wird die Konfliktlösung durchgeführt. Danach wird das zuvor konfliktbehaftete Objekt automatisch in den Bereich Vorgemerkte Änderungen verschoben. \"Relationship Issues\" : Konkurrierende Änderungen haben zu einer unzulässigen Projektstruktur in CODESYS geführt, was nicht durch die Git-Merge-Funktion behandelt werden kann. Möglicherweise wurde extern im Dateisystem mit externen Werkzeugen geändert. Oder es wurde aus verschiedenen Branches eine konkurrierende Erzeugung eines Objekts gleichen Typs und\/oder gleichen Namens committet, das daraufhin im CODESYS -Projekt im gleichen Namensraum zu liegen kommt. Dies ist in einem CODESYS -Projekt nicht erlaubt. Oder es entstand eine unzulässige Vater-Kindobjekt-Beziehung. Eine weitere Möglichkeit: Relationship Issues stammen noch aus früheren Merges, bei denen sie bewusst ignoriert wurden, um zunächst weiterarbeiten zu können. Beispielsweise entsteht die Situation, dass 2 Alarmkonfigurationen unter einem Gerät eingehängt sind, was nicht zulässig ist. Der Benutzer muss die Projektstruktur mit den verfügbaren Mitteln (Mergen eines Objekts in ein anderes, Löschen, Umbenennen, Verschieben) händisch korrigieren, um wieder ein konsistentes Projekt zu erhalten. Ab Version 1.2.0.0 kann ein Projekt auch mit vorliegenden Relationship Issues weiter bearbeitet werden (Ignorieren). Achtung: In Folge werden in einem solchen Fall Änderungen am Projekt durch ein späteres Resynchronisieren wieder verworfen. Grund: Der Resynchronisierungsvorgang lädt aus dem Dateisystem diejenige Projektversion, die vor dem Ignorieren des Relationship Issues abgelegt worden war. In der Ansicht Status & Vormerken können Sie als Anwender einen Konflikt folgendermaßen prüfen und bearbeiten: Im Kontextmenü eines konfliktbehafteten Objekts gibt es hilfreiche Befehle. Die aktuelle Auswahl hängt von der Situation ab: Alle betroffenen Objekte anzeigen \/ Dieses Objekt anzeigen : Die Objekte\/das Objekt werden\/wird in der Ansicht Geräte des Projekts markiert. Auflösen mit ihrem : Der Stand des Quell-Branches wird übernommen Auflösen mit Unserem : Der Stand des Ziel-Branches wird übernommen. Automatisch auflösen : CODESYS Git versucht die Änderungen selbst zu konsolidieren. Als aufgelöst markieren : Das aktuell im Projekt vorhandene Objekt wird übernommen und als Lösung den Konflikts betrachtet. Das entsprechende Objekt wurde vorgemerkt. Relationship Issue ignorieren : Der Relationship Issue wird bis zur nächsten Resynchronisation ignoriert. Das kann sinnvoll sein, wenn es zunächst nur darum geht, an einem Projekt weiterarbeiten zu können und der Konflikt dabei keine Rolle spielt. Ein Doppelklick auf ein konfliktbehaftetes Objekt öffnet die Vergleichsansicht von Quell- und Zielbranchinhalt. Im Fall von konkurrierenden Inhalten kann hier wie gewünscht von einem Branch in den anderen übernommen werden. In der Ansicht Meldungen können Sie mit Doppelklick auf eine Fehlermeldung zu einem Konflikt das betroffene Objekt öffnen. " }, 
{ "title" : "Git Scripting-Schnittstelle verwenden ", 
"url" : "_git_using_scripting.html", 
"breadcrumbs" : "CODESYS Git \/ Git Scripting-Schnittstelle verwenden ", 
"snippet" : "CODESYS Git stellt eine Scripting-Schnittstelle für Git zur Verfügung. Im Folgenden werden Ihnen Beispiele zur Verwendung der Schnittstelle aufgezeigt. Weiter unten finden Sie außerdem Informationen zur textbasierten Ausgabe der Meldungen, die bei vielen Git-Operationen erzeugt werden. Für weitere I...", 
"body" : "CODESYS Git stellt eine Scripting-Schnittstelle für Git zur Verfügung. Im Folgenden werden Ihnen Beispiele zur Verwendung der Schnittstelle aufgezeigt. Weiter unten finden Sie außerdem Informationen zur textbasierten Ausgabe der Meldungen, die bei vielen Git-Operationen erzeugt werden. Für weitere Informationen zum Arbeiten mit der Scripting-Schnittstelle siehe: Script Engine API Documentation " }, 
{ "title" : "Voraussetzungen ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403339456886", 
"breadcrumbs" : "CODESYS Git \/ Git Scripting-Schnittstelle verwenden \/ Voraussetzungen ", 
"snippet" : "Für die Ausführung der folgenden Beispiele wird vorausgesetzt: CODESYS 3.5.19.30 oder höher Zusätzlich werden die folgenden Komponenten benötigt: CODESYS Library Documentation Support (für das Erstellen der Compiled Library) CODESYS Git 1.6.0.0 oder höher Eine lokale Git-Installation Verwenden Sie m...", 
"body" : "Für die Ausführung der folgenden Beispiele wird vorausgesetzt: CODESYS 3.5.19.30 oder höher Zusätzlich werden die folgenden Komponenten benötigt: CODESYS Library Documentation Support (für das Erstellen der Compiled Library) CODESYS Git 1.6.0.0 oder höher Eine lokale Git-Installation Verwenden Sie möglichst SecureString-Passwörter Für eine erhöhte Sicherheit sollten Passwörter als .NET-SecureString übergeben werden. Die davon betroffenen git-Operationen sind: clone , fetch , pull , push SecureStrings können in IronPython wie folgt erstellt werden. Das \"Passwort“ sollte dabei selbst aus einem sicheren String stammen und nicht, wie hier zu Demonstrationszwecken, im Klartext im Skript stehen. Intern wird jedes übergebene Passwort sicher behandelt: from System.Security import SecureString \n\n sec_str_password = SecureString()\n for c in \"Passwort\": \n sec_str_password.AppendChar(c) Für weitere Security-Maßnahmen bei der Verwendung von CODESYS Git siehe: Security für CODESYS Git " }, 
{ "title" : "Vorbereitung ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403341267380", 
"breadcrumbs" : "CODESYS Git \/ Git Scripting-Schnittstelle verwenden \/ Vorbereitung ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Bibliothek ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm56806682534762", 
"breadcrumbs" : "CODESYS Git \/ Git Scripting-Schnittstelle verwenden \/ Vorbereitung \/ CODESYS Bibliothek ", 
"snippet" : "Da aktuell keine CODESYS -Bibliotheken in Git verwaltet werden, werden die Quellen einer CODESYS -Bibliothek benötigt. In den Beispielen wird die Bibliothek String Functions.library des Produkts CODESYS String Libraries verwendet....", 
"body" : "Da aktuell keine CODESYS -Bibliotheken in Git verwaltet werden, werden die Quellen einer CODESYS -Bibliothek benötigt. In den Beispielen wird die Bibliothek String Functions.library des Produkts CODESYS String Libraries verwendet. " }, 
{ "title" : "Remote-Git-Repository ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm566365154713912", 
"breadcrumbs" : "CODESYS Git \/ Git Scripting-Schnittstelle verwenden \/ Vorbereitung \/ Remote-Git-Repository ", 
"snippet" : "Für das vorliegende Beispiel wird ein Git-Bare-Repository im Dateisystem als Remote-Repository verwendet. Zur Vorbereitung wird das entsprechende Verzeichnis zunächst gelöscht und dann neu angelegt. import shutil import os  def prepare_empty_dir(empty_dir_path):     print(\"Prepare empty directory at...", 
"body" : "Für das vorliegende Beispiel wird ein Git-Bare-Repository im Dateisystem als Remote-Repository verwendet. Zur Vorbereitung wird das entsprechende Verzeichnis zunächst gelöscht und dann neu angelegt. import shutil\nimport os \n\ndef prepare_empty_dir(empty_dir_path):\n    print(\"Prepare empty directory at\", empty_dir_path)\n    shutil.rmtree(empty_dir_path, ignore_errors=True)\n    if not(os.path.exists(empty_dir_path) and os.path.isdir(empty_dir_path)):\n        os.makedirs(empty_dir_path) Anschließend wird ein leeres Bare-Git-Repository angelegt. import subprocess\ndef create_bare_git_repository(bare_repository_path):\n    print(\"Create bare git repository at\", bare_repository_path)\n    create_bare_repository_cmd = 'cmd \/c \"git -C \\\"' + bare_repository_path + '\\\" init --bare\"'\n    try:\n        retcode = subprocess.call(create_bare_repository_cmd, shell=True)\n        if retcode < 0:\n            raise Exception(\"Creating bare git repository at \" + bare_repository_path + \" failed: \", -retcode)\n        else:\n            print(\"Creating bare git repository at \" + bare_repository_path + \" succeeded.\")\n    except Exception as e:\n        print(\"[ERROR] Creating bare git repository failed: \", e)\n        raise Das angelegte leere Bare-Git-Repository wird mit dem Inhalt der CODESYS -Bibliothek befüllt. def initialize_bare_git_repository(library_path, local_repository_path, bare_repository_path):\n    print(\"Open library:\", library_path)\n    project = projects.open(library_path)\n     \n print(\"Initiate local git repository\")\n    project.git.init(local_repository_path)\n    project.git.commit_complete(\"Create git repo for lib\", \"user\", \"mail@mail\")\n     \n print(\"Push to remote git repository\")\n    origin_remote = project.git.remote_add(\"origin\", bare_repository_path)\n    project.git.branch_set_upstream_to(origin_remote)\n    project.git.push()\n    project.git.de_init(cleanUpFileSystem=True)\n    project.close() Das folgende Skript führt die beschriebenen Funktionen aus. import os\n\ndef main():\n    if projects.primary:\n        projects.primary.close()\n\n    basepath = \"C:\\\\CODESYS_Projects\\\\Git_Scripting_Tutorial\\\\\"\n\n    project_basepath = os.path.join(basepath, \"projects\\\\\")\n    library_file_name = \"ExampleLib1.library\"\n    library_path = os.path.join(project_basepath, library_file_name)\n\n    remote_repo_basepath = os.path.join(basepath, \"remotes\\\\\")\n    remote_repo_directory_name = \"ExampleLib1RemoteRepo\"\n    remote_repo_path = os.path.join(remote_repo_basepath, remote_repo_directory_name)\n\n    local_repo_basepath = os.path.join(basepath, \"repos\\\\\")\n    local_repo_directory_name = \"ExampleLib1LocalRepo\"\n    local_repo_path = os.path.join(local_repo_basepath, local_repo_directory_name)\n\n    print(\"Create and push library to remote git repository\")\n    \n prepare_empty_dir(remote_repo_path)\n    create_bare_git_repository(remote_repo_path)\n    initialize_bare_git_repository(library_path, local_repo_path, remote_repo_path)\n\n    print(\"[Success] All done\")\n\n\nif __name__ == '__main__':\n    main() Das auf diese Weise erstellte und mit Inhalt versehene Bare-Git-Repository wird für die weiteren Bespiele genutzt. " }, 
{ "title" : "Clonen eines Git-Remote-Repository ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403354678654", 
"breadcrumbs" : "CODESYS Git \/ Git Scripting-Schnittstelle verwenden \/ Vorbereitung \/ Clonen eines Git-Remote-Repository ", 
"snippet" : "Die folgende Funktion führt git clone für ein Git-Remote-Repository aus. def clone_git_repository(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path):     update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFlags.SilentMode     project = git.clone(project_basepath, ...", 
"body" : "Die folgende Funktion führt git clone für ein Git-Remote-Repository aus. def clone_git_repository(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path):\n    update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFlags.SilentMode    \n project = git.clone(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path, update_flags=update_flags)\n    project.save()\n    return project " }, 
{ "title" : "Erstellen und Mergen eines neuen Branches ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_id_CopyofCODESYSGitScriptingUsage-ErstellenundMergeneinesneuenBranches", 
"breadcrumbs" : "CODESYS Git \/ Git Scripting-Schnittstelle verwenden \/ Vorbereitung \/ Erstellen und Mergen eines neuen Branches ", 
"snippet" : "Die folgende Hilfsfunktion erzeugt exemplarisch einige neue Objekte in einem CODESYS -Projekt. def add_dut(project): ST_STRUCT_STR = \"\"\"\\ a : BOOL; b : BIT; c : BIT; \"\"\" ST_UNION_STR = \"\"\"\\ TYPE ExampleUnion : UNION Zahl : INT; Prozent : ExampleAlias; Bits : ExampleStruct; END_UNION END_TYPE \"\"\" # C...", 
"body" : "Die folgende Hilfsfunktion erzeugt exemplarisch einige neue Objekte in einem CODESYS -Projekt. def add_dut(project):\n ST_STRUCT_STR = \"\"\"\\\n a : BOOL;\n b : BIT;\n c : BIT;\n \"\"\"\n\n ST_UNION_STR = \"\"\"\\\n TYPE ExampleUnion :\n UNION\n Zahl : INT;\n Prozent : ExampleAlias;\n Bits : ExampleStruct;\n END_UNION\n END_TYPE\n \"\"\"\n\n # Create a struct DUT and insert the list of variables just into the right\n   # place in line two, row 0 (line numbering starts with line 0)\n   example_dut_struct = project.create_dut('ExampleStruct') # DutType.Structure is the default\n   example_dut_struct.textual_declaration.insert(2, 0, ST_STRUCT_STR) \n\n   # Alias types get their \"content\" via the base type, which will just end up \n   # as one line in the declaration part:    \n # TYPE MyAlias : INT (0..100); END_TYPE \n   example_dut_alias = project.create_dut('ExampleAlias', DutType.Alias, \"INT (0..100)\") \n\n   # Instead of injecting the variables into the existing declaration, \n   # one can also just replace the complete declaration part, including the \n   # boilerplate code.\n   example_dut_union = project.create_dut('ExampleUnion', DutType.Union)\n   example_dut_union.textual_declaration.replace(ST_UNION_STR) Die folgende Hilfsfunktion inkrementiert die Build-Version in den Projektinformationen eines CODESYS -Projekts. def increment_build_version(project):\n \"\"\"\n Increment build version in project info.\n \"\"\"\n info = project.get_project_info()\n old_version = info.version\n info.version = (old_version.Major, old_version.Minor, old_version.Build + 1, 0)\n project.save() Die folgende Funktion erstellt zunächst einen neuen Branch, führt in diesem Branch Änderungen aus und merget anschließend diese Änderungen zurück in den Hauptbranch. def copy_branch_and_merge(project):\n current_branch = project.git.branch_show_current()\n print(\"Current branch: \", current_branch.friendly_name)\n project, current_branch = project.git.branch_copy(current_branch, \"new_branch\", checkout=True)\n print(\"Current branch: \", current_branch.friendly_name)\n\n add_dut(project)\n project.git.commit_complete(\"Added DUT\", \"user\", \"mail@mail\")\n\n increment_build_version(project)\n project.git.commit_complete(\"Incremented build version\", \"user\", \"mail@mail\")\n\n project, current_branch = project.git.checkout(\"master\")\n print(\"Current branch: \", current_branch.friendly_name)\n project, merge_result = project.git.merge(\"new_branch\")\n print(\"Merged: \", merge_result.ToString())\n project.save()\n return project Das folgende Skript führt git clone für ein Git-Remote-Repository aus, führt Änderungen im Projekt durch und pusht die Änderungen anschließend in das Git-Remote-Repository ( CopyBranchAndMerge.py ). def main():\n    if projects.primary: \n       projects.primary.close()\n\n    basepath = \"C:\\\\CODESYS_Projects\\\\Git_Scripting_Tutorial\\\\\"\n\n project_basepath = os.path.join(basepath, \"projects\\\\\")\n    library_file_name = \"ExampleLib1Cloned.library\"\n\n remote_repo_basepath = os.path.join(basepath, \"remotes\\\\\")\n    remote_repo_directory_name = \"ExampleLib1RemoteRepo\"\n    remote_repo_path = os.path.join(remote_repo_basepath, remote_repo_directory_name)\n\n local_repo_basepath = os.path.join(basepath, \"repos\\\\\")\n    local_repo_directory_name = \"ExampleLib1LocalRepo\"\n    local_repo_path = os.path.join(local_repo_basepath, local_repo_directory_name)\n\n print(\"Clone project\")\n    project = clone_git_repository(project_basepath, library_file_name, remote_repo_path, local_repo_path)\n project = copy_branch_and_merge(project)\n project.git.push()\n    project.save()\n    project.git.de_init(cleanUpFileSystem=True)\n    project.save()\n    project.close()\n print(\"[Success] All done\")\n\nif __name__ == '__main__':\n    main()) " }, 
{ "title" : "Erzeugen einer Compiled Library ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403356979728", 
"breadcrumbs" : "CODESYS Git \/ Git Scripting-Schnittstelle verwenden \/ Vorbereitung \/ Erzeugen einer Compiled Library ", 
"snippet" : "Das folgende Skript führt git clone für eine CODESYS -Quellbibliothek aus einem Git-Remote-Repository aus und erstellt anschließend daraus eine compilierte Bibliothek ( CreateCompiledLibrary.py ). import os class CompileError(Exception): pass def clone_git_repository(project_basepath, project_file_n...", 
"body" : "Das folgende Skript führt git clone für eine CODESYS -Quellbibliothek aus einem Git-Remote-Repository aus und erstellt anschließend daraus eine compilierte Bibliothek ( CreateCompiledLibrary.py ). import os\n\nclass CompileError(Exception):\n pass\n\ndef clone_git_repository(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path):\n update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFlags.SilentMode\n project = git.clone(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path, update_flags=update_flags)\n project.save()\n return project\n\ndef create_compiled_library(project):\n # requires the CODESYS Library Documentation Support Package!\n project.check_all_pool_objects()\n compile_result_message = system.get_messages(category='{97F48D64-A2A3-4856-B640-75C046E37EA9}')[-1]\n if \"0 errors\" in compile_result_message:\n project.save_as_compiled_library(destination_name=None)\n else:\n raise CompileError(\"Compile failed: \" + compile_result_message)\n return project\n\nbasepath = \"D:\\\\JiraTickets\\\\GIT-145\\\\\"\n\nproject_basepath = os.path.join(basepath, \"projects\\\\\")\n\nremote_repo_basepath = os.path.join(basepath, \"remotes\\\\\")\nremote_repo_directory_name = \"StringFunctions.git\"\nremote_repo_path = os.path.join(remote_repo_basepath, remote_repo_directory_name)\n\nlocal_repo_basepath = os.path.join(basepath, \"repos\\\\\")\nlocal_repo_path = os.path.join(local_repo_basepath, \"StringFunctions.git\")\n\nprint(\"Clone project\")\nproject = clone_git_repository(project_basepath, \"String Functions Cloned.library\", remote_repo_path, local_repo_path)\nproject = create_compiled_library(project)\nproject.git.de_init(cleanUpFileSystem=True)\nproject.close()\n\nprint(\"[Success] All done\") " }, 
{ "title" : "Installieren einer Bibliothek aus einem Git Remote Repository ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403357071816", 
"breadcrumbs" : "CODESYS Git \/ Git Scripting-Schnittstelle verwenden \/ Vorbereitung \/ Installieren einer Bibliothek aus einem Git Remote Repository ", 
"snippet" : "Das folgende Skript führt git clone für eine CODESYS -Quellbibliothek aus einem Git-Remote-Repository aus und installiert diese Bibliothek in der aktuellen CODESYS -Instanz ( InstallLibrary.py ). import os def clone_git_repository(project_directory_path, project_file_name, remote_repo_url_or_path, l...", 
"body" : "Das folgende Skript führt git clone für eine CODESYS -Quellbibliothek aus einem Git-Remote-Repository aus und installiert diese Bibliothek in der aktuellen CODESYS -Instanz ( InstallLibrary.py ). import os\n\ndef clone_git_repository(project_directory_path, project_file_name, remote_repo_url_or_path, local_repo_path):\n    update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFlags.SilentMode\n    project = git.clone(project_directory_path, project_file_name, remote_repo_url_or_path, local_repo_path, update_flags=update_flags)\n    project.save()\n    return project\n\ndef install_library(project):\n    library_repo = librarymanager.repositories[0]\n    librarymanager.install_library(project.path, library_repo, True)\n\ndef main():\n    if projects.primary:\n        projects.primary.close()\n\n     basepath = \"C:\\\\CODESYS_Projects\\\\Git_Scripting_Tutorial\\\\\"\n\n    project_basepath = os.path.join(basepath, \"projects\\\\\")\n    library_file_name = \"ExampleLib1Cloned2.library\"\n\n remote_repo_basepath = os.path.join(basepath, \"remotes\\\\\")\n    remote_repo_directory_name = \"ExampleLib1RemoteRepo\"\n    remote_repo_path = os.path.join(remote_repo_basepath, remote_repo_directory_name)\n\n    local_repo_basepath = os.path.join(basepath, \"repos\\\\\")\n    local_repo_directory_name = \"ExampleLib1LocalRepo\"\n    local_repo_path = os.path.join(local_repo_basepath, local_repo_directory_name)\n\n    print(\"Clone project\")\n    project = clone_git_repository(project_basepath, library_file_name, remote_repo_path, local_repo_path)\n\n print(\"Install library\")\n    install_library(project)\n    project.git.de_init(cleanUpFileSystem=True)\n    project.close()\n\n print(\"[Success] All done\")\n\nif __name__ == '__main__':\n    main() " }, 
{ "title" : "Meldungsausgaben bei Git-Operationen ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm234656140725653", 
"breadcrumbs" : "CODESYS Git \/ Git Scripting-Schnittstelle verwenden \/ Vorbereitung \/ Installieren einer Bibliothek aus einem Git Remote Repository \/ Meldungsausgaben bei Git-Operationen ", 
"snippet" : "Für die Nutzung von CODESYS Git liefern die meisten Befehle eine textbasierte Ausgabe. Diese wird im Betrieb von CODESYS in der Kommandozeile automatisch bei der Ausführung von CODESYS Git -Befehlen über den Script-Treiber ausgegeben. Beim Verwenden von CODESYS Git in CODESYS Development System ersc...", 
"body" : "Für die Nutzung von CODESYS Git liefern die meisten Befehle eine textbasierte Ausgabe. Diese wird im Betrieb von CODESYS in der Kommandozeile automatisch bei der Ausführung von CODESYS Git -Befehlen über den Script-Treiber ausgegeben. Beim Verwenden von CODESYS Git in CODESYS Development System erscheinen die Ausgaben auch im Meldungsfenster. Aufbau der Meldungen: Git: <severity>: [<time>] <text> In der Benutzeroberfläche von CODESYS Git reduziert sich die Ausgabe auf: [<time>] <text> severity : Meldungskategorie. Die Kategorien reichen von reiner Information bis zu kritischem Fehler time : Genauer Zeitpunkt der Meldung. Format HH:MM:SS text : Inhalt der Meldung. Bei Standard-Git-Befehlen entspricht der Inhalt dem Kommandozeilen-Befehl, der dasselbe Resultat liefern würde wie der getätigte Script-Treiber-Aufruf. Bei CODESYS Git -Befehlen, die keinem Standard-Git-Befehl entsprechen, beispielsweise Projekt aus Repository neu erstellen , erklärt der Meldungstext die ausgeführte Aktion. Befehle mit mehreren Meldungen: Für manche Befehle (beispielsweise git log wird die Ausgabe auf mehrere Meldungen aufgeteilt. Im Fall von git log wird jeder angezeigte Commit in einer eigenen Meldung angezeigt. Um in diesem Fall zu verdeutlichen, dass diese Meldungen Teil des git log -Befehls sind, wird in den Meldungen auf den ursprünglichem Befehl verwiesen. " }, 
{ "title" : "Referenz, Benutzeroberfläche ", 
"url" : "_git_f_reference_user_interface.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Ansichten und Dialoge ", 
"url" : "_git_struct_reference_views_dialogs.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Ansicht: Git-Status & Vormerken ", 
"url" : "_git_view_status.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Ansicht: Git-Status & Vormerken ", 
"snippet" : "Git-Status & Vormerken Symbol: Entsprechender Git-Befehl: git status Funktion : Die Ansicht zeigt den Git-Status der seit dem letzten Commit geänderten oder neuer Objekte und Dateien. Änderungen können hier für einen Commit vorgemerkt und committet werden. Ein Vergleich der Änderungen ist direkt mög...", 
"body" : "Git-Status & Vormerken Symbol: Entsprechender Git-Befehl: git status Funktion : Die Ansicht zeigt den Git-Status der seit dem letzten Commit geänderten oder neuer Objekte und Dateien. Änderungen können hier für einen Commit vorgemerkt und committet werden. Ein Vergleich der Änderungen ist direkt möglich und Änderungen seit dem letzten Commit können aus dem Arbeitsverzeichnis entfernt werden. Wenn durch einen Merge-Versuch Konflikte oder Relationship Issues entstehen, wird dies in der Ansicht hier dargestellt. Aufruf : Menü Git → Status & Vormerken Voraussetzung : Das geöffnete Projekt wird in Git verwaltet. Titelleiste: Branch: <branch name> Letzter Commit: <ID> Name des betroffenen Branches Der aktuelle Zustand des Branches ist vorangestellt. Beispiele: Merging , Unaufgelöste Konflikte oder Unaufgelöste Relationship Issues Ein Klick auf den Namen des Branches öffnet die Ansicht Git-Branches . Ein Klick auf die ID des letzten Commits öffnet die Ansicht Git-History . Die Ansicht wird aktualisiert. Alle Änderungen verwerfen ( git reset --hard ) Unabhängig von einer Selektion in der Tabelle werden alle Änderungen verworfen, auch die nicht vorgemerkten. Das Projekt wird auf den Stand zurückgesetzt, den es vor allen noch nicht committeten Änderungen hatte. Commit aller Änderungen ( git commit complete ) Öffnet den Dialog Vorgemerkte und nicht vorgemerkte Änderungen committen (s.u.) Änderungen vergleichen: Ein Doppelklick auf einen Objekteintrag öffnet eine separate Vergleichsansicht („Diff“), die die Unterschiede zwischen dem aktuellen Stand des Objekts ( neuer… ) und dem zuletzt committeten Stand ( base… ) zeigt. Siehe hierzu unten, \"Vergleichsansicht“. Betroffene Objekte im Projektnavigator finden: Sehen Sie dazu die Befehle Dieses Objekt anzeigen und Alle betroffenen Objekte anzeigen im Kontextmenü eines Objekteintrags. Vorgemerkte Änderungen Dieser obere Teil der Ansicht Git-Status zeigt die für einen Commit vorgemerkten geänderten Objekte (Git-Index). Hier werden die Vormerkungen für Commits organisiert und Commits durchgeführt. Objekt Physikalischer Pfad Pfad des geänderten Objekts im Git-Projekt Beispiel: project\\device\\plc_logic\\application\\plc_prg Wenn die Option Physikalische Pfade anzeigen im Kontextmenü des Spaltentitels Objekt aktiviert ist, erscheint zusätzlich die Spalte Physikalischer Pfad mit der ausführlichen Pfadangabe für das Objekt. Beispiel: project\\device_5aca2685\\plc_logic_b738fa32\\application_0dcb78bb\\plc_prg_33759ca0\\33759ca04 b4e4930a972d2050e97661a.object Kontextmenü eines Objekteintrags: Dieses Objekt anzeigen : Das Objekt wird im Projektnavigator selektiert. Alle betroffenen Objekte anzeigen : Verfügbar am Eintrag eines mit einem Konflikt oder Relationship Issue behafteten Objekts: Alle Objekte, für die der Konflikt noch nicht aufgelöst ist, werden im Projektnavigator selektiert. Index-Status , Details Git-Status des Objekts im Index (intern) Mögliche Status: : Unverändert : Das Objekt ist identisch mit dem aktuellen Stand im Git-Repository. : Neu (im Index): Das Objekt wurde dem Index neu hinzugefügt. Im Git-Repository existiert es nicht. : Geändert (im Index): Das Objekt wurde gegenüber der vorherigen Version im Index verändert. In diesem Fall kann mit einem Commit ( git commit ) oder einem Verwerfen der Änderungen ( git reset ) reagiert werden:. Die Änderung kann aus dem Index wieder entfernt werden ( git reset --mixed ): Selektierte Änderungen aufheben (git reset –mixed) Die Änderung kann gänzlich verworfen werden: Alle Änderungen verwerfen ( git reset --hard ) : Gelöscht : Das Objekt wurde gelöscht. Achtung: Ein Reset-Vorgang im Index überschreibt möglicherweise den Inhalt des Objekts im Arbeitsverzeichnis. Alle Änderungen verwerfen ( git reset --hard ) Unabhängig von einer Selektion in der Tabelle werden alle Änderungen verworfen, auch die nicht vorgemerkten. Das Projekt wird auf den Stand zurückgesetzt, den es vor allen noch nicht committeten Änderungen hatte. Alles committen Öffnet den Dialog Vorgemerkte und nicht vorgemerkte Änderungen committen Vorgemerkte Änderungen committen (git commit) Öffnet den Dialog Vorgemerkte Änderungen committen Beim Commit werden alle Änderungen im Index (vorgemerkte Änderungen) in den neuen Commit übernommen. Die Änderungen im Arbeitsverzeichnis (nicht vorgemerkt) werden nicht übernommen. Selektierte Vormerkungen aufheben (git reset –mixed) Die für den Commit vorgemerkten Änderungen werden auf „nicht vorgemerkt“ zurückgesetzt. Die Einträge im Fenster verschwinden. Achtung: Ein Reset-Vorgang im Index überschreibt möglicherweise den Inhalt des Objektes im Arbeitsverzeichnis. Nicht vorgemerkte Änderungen Dieser untere Teil der Ansicht Git-Status zeigt alle Änderungen, die im Projekt seit dem letzten Commit vorgenommen wurden und die noch nicht für einen Commit vorgemerkt sind. Sie können nun vorgemerkt werden. Es kann sich um Änderungen an Objekten handeln, die bereits im Git-Repository bekannt sind, oder um noch „nicht getrackte“. „Nicht getrackte“ Objekte sind noch nicht mittels Hinzufügen ( git add ) oder Commit ( git commit ) ins Git-Repository aufgenommen worden. Objekt Physikalischer Pfad Pfad des geänderten Objekts im Git-Projekt Beispiel: project\\device\\plc_logic\\application\\plc_prg Zur möglichen Anzeige von Physikalischer Pfad siehe oben bei „Vorgemerkte Änderungen“. Arbeitsverzeichnis-Status , Details Status des Objekts im Arbeitsverzeichnis: : Unverändert (im Arbeitsverzeichnis): Das Objekt ist gegenüber dem Index unverändert. : Neu (im Arbeitsverzeichnis): Das Objekt existiert im Arbeitsverzeichnis, aber noch nicht im Index oder im Git-Repository. : Gelöscht (im Arbeitsverzeichnis): Das Objekt existiert im Arbeitsverzeichnis nicht mehr, ist aber im Git-Repository (Index) bekannt. Es wurde schon einmal mittels git add und\/oder mittels git commit hinzugefügt. : Geändert (im Arbeitsverzeichnis): Das Objekt wurde gegenüber der vorherigen Version im Index verändert. : Beim Mergen des Objekts ist ein Konflikt oder Relationship Issue aufgetreten. In diesem Fall gibt es im Kontextmenü folgendende Befehle zur Behandlung des Konflikts: Manuell auflösen : Eine Vergleichsansicht der beiden betroffenen Commits öffnet sich. Auflösen mit 'ours' : Der Stand des neueren Commits („Neuer“) wird übernommen. Auflösen mit 'theirs' : Der Stand des älteren Commits ( Basis ) wird übernommen. Beim Committen nach der Behandlung des Konflikts enthält die Commit-Meldung automatisch eine Liste der betroffenen Objekte. : Änderungen vormerken ( git add ) Die selektierten Änderungen werden für den Commit vorgemerkt und dazu in den Bereich Vorgemerkte Änderungen verschoben. : Alle nicht übertragenen Änderungen rückgängig machen ( git clean & git checkout ) Alle Änderungen, die in der Ansicht Nicht vorgemerkte Änderungen stehen, werden verworfen. : Selektion aller Änderungen umschalten Die Selektion aller Änderungen wird aktiviert oder deaktiviert. " }, 
{ "title" : "Dialog: Vorgemerkte Änderungen committen ", 
"url" : "_git_view_status.html#UUID-d928d26b-8202-57f2-233c-383ef01152f6_id_c24a156863171e3cc0a8646329f090c1-id-76eeb06c64c0f307c0a86463133e3737", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Ansicht: Git-Status & Vormerken \/ Dialog: Vorgemerkte Änderungen committen ", 
"snippet" : "Symbol: Funktion : In dem Dialog veranlassen Sie einen Commit der vorgemerkten Änderungen oder einen leeren Commit. Aufruf : Befehl Commit aller Änderungen in der Ansicht Git-Status <Benutzername und E-Mail> Name und E-Mail des Benutzers. Diese Anmeldedaten für das Repository können mit Merken in de...", 
"body" : "Symbol: Funktion : In dem Dialog veranlassen Sie einen Commit der vorgemerkten Änderungen oder einen leeren Commit. Aufruf : Befehl Commit aller Änderungen in der Ansicht Git-Status <Benutzername und E-Mail> Name und E-Mail des Benutzers. Diese Anmeldedaten für das Repository können mit Merken in der .gitconfig des lokalen Repositorys gespeichert werden. Dann verwendet CODESYS Git sie automatisch bei den nächsten entsprechenden Aktionen. Commit nach <…> Ziel des Commits. Beispiel: Commit nach Branch ‚refs\/heads\/master‘ <Name des Committers> Name und E-Mail -Adresse des Committers In CODESYS Git wird zwischen Committer und Autor nicht unterschieden. Der Autor ist somit hier bereits auch als Committer eingetragen. Commit-Meldung Commit-Meldung (obligatorisch) Leeren Commit erlauben : Wenn es keine Änderungen im Projekt gibt, wird ein „leerer“ Commit durchgeführt. Leere Commits dienen als eine Art Kommentar oder Marker in der Historie. " }, 
{ "title" : "Dialog: Vorgemerkte und nicht vorgemerkte Änderungen committen ", 
"url" : "_git_view_status.html#UUID-d928d26b-8202-57f2-233c-383ef01152f6_id_c24a156863171e3cc0a8646329f090c1-id-8a99954a5b645d73c0a8646331f25fbc", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Ansicht: Git-Status & Vormerken \/ Dialog: Vorgemerkte und nicht vorgemerkte Änderungen committen ", 
"snippet" : "Symbol: Funktion : In dem Dialog veranlassen Sie das Committen aller Änderungen im Projekt, wobei der Status „Vorgemerkt“ übersprungen wird. Sie müssen wie im Dialog Vorgemerkte Änderungen committen eine Commit-Meldung angeben und die Committer-Informationen eintragen oder bestätigen. Optional ist a...", 
"body" : "Symbol: Funktion : In dem Dialog veranlassen Sie das Committen aller Änderungen im Projekt, wobei der Status „Vorgemerkt“ übersprungen wird. Sie müssen wie im Dialog Vorgemerkte Änderungen committen eine Commit-Meldung angeben und die Committer-Informationen eintragen oder bestätigen. Optional ist auch hier ein leerer Commit möglich. Aufruf : Befehl Commit aller Änderungen in der Ansicht Git-Status " }, 
{ "title" : "Vergleichsansicht ", 
"url" : "_git_view_status.html#UUID-d928d26b-8202-57f2-233c-383ef01152f6_id_c24a156863171e3cc0a8646329f090c1-id-17604f183ce6a486c0a86463069dfb21", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Ansicht: Git-Status & Vormerken \/ Vergleichsansicht ", 
"snippet" : "Symbol: Funktion : Die Ansicht stellt die Unterschiede zwischen zwei Commits dar. Änderungen können übernommen oder verworfen werden. Aufruf : Doppelklick auf eine Änderung in der Ansicht Git-Status Nehmen Sie in der Vergleichsanischt KEINE Änderungen vor! Einzige Ausnahme: Auflösen von Konflikten. ...", 
"body" : "Symbol: Funktion : Die Ansicht stellt die Unterschiede zwischen zwei Commits dar. Änderungen können übernommen oder verworfen werden. Aufruf : Doppelklick auf eine Änderung in der Ansicht Git-Status Nehmen Sie in der Vergleichsanischt KEINE Änderungen vor! Einzige Ausnahme: Auflösen von Konflikten. Die Vergleichsansicht entspricht bezüglich Funktionsweise und Handhabung der Vergleichsansicht, die für einen Projektvergleich verwendet wird. Der durch die Änderung entstandene neue Stand des Objekts ( Neueres (vorgemerkt|nicht vorgemerkt ) wird bei den nicht vorgemerkten Änderungen mit dem letzten Stand des Objekts im Index ( Basis (head, <object ID>) verglichen. Bei den vorgemerkten Änderungen wird er mit dem letzten Stand im Repository verglichen. Sehen Sie für weitere Informationen zur CODESYS -Vergleichsansicht: Projektvergleich " }, 
{ "title" : "Ansicht: History ", 
"url" : "_git_view_history.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Ansicht: History ", 
"snippet" : "History Entsprechender Git-Befehl: git log Funktion : In der Ansicht wird die Historie der Commits dargestellt, die auf die in Git verwalteten Objekte des Projekts oder auf andere Dateien im Git-Repository erfolgt sind. Für jeden Commit werden die Änderungsinformationen angezeigt. Ein Vergleich zwis...", 
"body" : "History Entsprechender Git-Befehl: git log Funktion : In der Ansicht wird die Historie der Commits dargestellt, die auf die in Git verwalteten Objekte des Projekts oder auf andere Dateien im Git-Repository erfolgt sind. Für jeden Commit werden die Änderungsinformationen angezeigt. Ein Vergleich zwischen Commits ist möglich. Außerdem können Sie aus einem Commit direkt einen neuen Branch erstellen. Aufruf : Menü Git → History Voraussetzung : Für das geöffnete Projekt wurden bereits Git-Aktionen durchgeführt. Es muss mindestens ein Commit exisiteren. Vergleichen Der selektierte Commit wird mit seinem Stand in der Projektablage verglichen und Änderungen in der Vergleichsansicht dargestellt. Wenn zwei Commits ausgewählt sind, werden diese verglichen. Graph Optische Darstellung der Abspaltungen und Zusammenführungen der Branches Die nacheinder auf einen Branch erfolgten Commits werden in chronologischer Abfolge (von unten nach oben) dargestellt. Die einzelnen Branches sind nebeneinander angeordnet und durch verschiedene Farben zu unterscheiden. Ganz links ist der „master“-Branch, daneben die Branches, die mit ihm verknüpft sind. Normale Commits sind mit Kreissymbolen gekennzeichnet, Merge-Commits mit Quadratsymbolen. Die Linien zwischen den Kreissymbolen der Commits zeigen, wann abgezweigt oder gemergt wurde. Git-Labels, die in einem Git-Tool vergeben wurden, werden mit einem Etikettsymbol dargestellt. Bei Commits in den gemeinsamen Remote-Master wird dessen Name mit angegeben (beispielsweise origin\/master ). Meldung Commit-Meldung Autor Autor des Commits Verfasst am Datum des Commits SHA1 „Secure Hash Algorithm 1“ SHA1 ist ein Hashwert und hat die Funktion einer eindeutigen ID des Commits. Für den oben selektierten Commit werden folgende Informationen angezeigt: Details <Text der Commit-Meldung> SHA1 : „Secure Hash Algorithm 1“ SHA1 ist ein Hashwert und hat die Funktion einer eindeutigen ID des Commits. Autor Name des Autors der Änderung Committer Name des Committers der Änderung Pfad Physikalischer Pfad Pfad des Objekts im Git-Arbeitsverzeichnis des CODESYS -Projekts Beispiel: project\\device\\plc_logic\\application\\plc_prg Wenn die Option Physikalische Pfade anzeigen im Kontextmenü des Spaltentitels Objekt aktiviert ist, erscheint zusätzlich die Spalte Physikalischer Pfad mit der ausführlichen Pfadangabe für das Objekt. Beispiel: project\\device_5aca2685\\plc_logic_b738fa32\\application_0dcb78bb\\plc_prg_33759ca0\\33759ca04 b4e4930a972d2050e97661a.object Objektname Name des Objekts im CODESYS -Projekt oder Name einer anderen Datei im Git-Repository Beispiele: PLC_PRG , Device , .gitattributes Objekttyp Typ des Objekts im CODESYS -Projekt oder Typ der Datei Beispiele: DeviceObject , .gitattributes Art der Änderung Art der Änderung, die committet wurde Beispiele: Hinzugefügt , Gelöscht , Geändert , Umbenannt , Verschoben Ein Doppelklick auf eine Änderung öffnet die aus der Ansicht Status & Vormerken bekannten Vergleichsansicht. Die Änderung durch den neuen Commit ( Neueres <commit ID> ) wird dargestellt. Die Ansicht dient nur der Information, eine Bearbeitung ist nicht möglich. Mit dem Kontextmenübefehl Branch aus Commit erzeugen können Sie für einen selektierten Commit direkt einen neuen Branch erstellen. " }, 
{ "title" : "Ansicht: Git-Branches ", 
"url" : "_git_view_branches.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Ansicht: Git-Branches ", 
"snippet" : "Git-Branches Symbol: Entsprechender Git-Befehl: git branch Funktion : In der Ansicht werden die lokalen Git-Branches dargestellt und verwaltet. Es kann sich um Branches handeln, die bereits einen Remote-Branch tracken, oder um Branches, die rein lokal existieren und keinerlei Verbindung zu einem Rem...", 
"body" : "Git-Branches Symbol: Entsprechender Git-Befehl: git branch Funktion : In der Ansicht werden die lokalen Git-Branches dargestellt und verwaltet. Es kann sich um Branches handeln, die bereits einen Remote-Branch tracken, oder um Branches, die rein lokal existieren und keinerlei Verbindung zu einem Remote-Repository beinhalten. Aufruf : Menü Git → Branches Voraussetzung : Im Repository existiert mindestens 1 Commit. Die Ansicht wird aktualisiert. Kopieren ( git copy ) Öffnet den Dialog Neuen Branch erzeugen zum Anlegen eines neuen lokalen Branches als Kopie des gerade selektierten lokalen Branches (s.u.) Löschen ( git branch -D ) Der selektierte Branch wird gelöscht, auch wenn der Branch noch nicht vollständig gemergt wurde. Hinweis: Der aktuelle Branch kann nicht gelöscht werden. Checkout ( git checkout ) Durch die Checkout -Operation wird der selektierte Branch zum aktuellen Branch. Das heißt, die Git-Operationen wirken auf die Inhalte dieses Branches, die zu diesem Zweck ins lokale Git-Repository („Arbeitsverzeichnis“) geladen werden. Ein Checkout wird durch uncommittete Änderungen verhindert. Wenn es sich um einen Remote-Branch, also Eintrag unter Remote (<n>) handelt, gibt es folgende Möglichkeiten: Ein Dialog öffnet sich mit der Meldung: Dieser Remote-Branch wird bereits vom lokalen Branch ‚master‘ getrackt, der statt dessen ausgecheckt wird. Branch-Name „origin\/master“ . In diesem Fall gibt es bereits einen lokalen Remote-Branch (unter Lokal (<n>) ), der den gerade selektierten Remote-Branch trackt und sich somit mit diesem über Pull und Push austauschen kann. Dann wird dieser lokale Branch zur Bearbeitung ins Arbeitsverzeichnis geladen. Möglicherweise wird der Checkout zunächst verweigert, weil es durch lokale Änderungen, die direkt im Arbeitsverzeichnis vorgenommen wurden, zu Inkonsistenzen kommt. Mit der Option Forcen können solche Inkonsistenzen zunächst akzeptiert werden und das Auschecken dennoch durchgeführt werden. Ein Auschecken dieses Remote-Branches erzeugt einen entsprechenden lokalen Tracking-Branch. Dieser Name für den lokalen Branch ist bereits vergeben. Die Operation wird sehr wahrscheinlich fehlschlagen. In diesem Fall gab es noch keinen lokalen Remote-Branch, der den gerade selektierten Remote-Branch trackt. CODESYS Git will einen lokalen Branch anlegen, allerdings ist der Name dafür bereits vergeben. Mit der Option Forcen kann der Vorgang dennoch erzwungen werden. Achtung: Der zuvor bereits vorhandene Branch wird dadurch überschrieben! Es gab noch keinen lokalen Remote-Branch. Kein Tracking. Dieser wird jetzt angelegt und als „aktueller“ gesetzt und das Tracking aktiviert. Somit wird sofort auf diesem Branch weitergearbeitet. Merge ( git merge ) Mit einem Klick auf die Schaltfläche wird der Befehl direkt ausgeführt. Alternativ können Sie Optionen dafür einstellen. Wählen Sie dazu über die Pfeiltaste den Befehl Mergen mit Optionen . Der Dialog Branch mergen öffnet sich, wo Sie die für die aktuelle Merge-Aktion gültigen Optionen wählen können. Für das Mergen sind der Name und die Email-Adresse des Benutzers erforderlich. Diese Informationen werden aus den Git-Einstellungen übernommen. Wenn dies nicht möglich ist, werden sie in einem Dialog abgefragt. Benutzername und Email-Adresse können im Dialog Branch mergen geändert werden. Wenn Sie die Nachfrage (Meldungsbox), ob wirklich gemergt werden soll, bestätigen, werden die Commits des gerade selektierten Branches in den aktuellen Branch gemergt. Der aktuelle Branch ist derjenige, dessen Stand gerade im Arbeitsverzeichnis liegt. (Haken in der Spalte Aktueller ) Wenn beim Mergen Konflikte oder Relationship Issues auftreten, müssen diese zunächst aufgelöst werden. Je nach Fall und den in der Ansicht Git-Branches eingestellten Merge-Optionen laufen dazu automatisierte Aktionen, oder es sind händische Aktionen nötig. Wenn ein Konflikt nicht automatisch aufgelöst werden kann, wird dies in der Ansicht Git-Status & Vormerken angezeigt. Beachten Sie zur Konfliktlösung im ersten Schritt die angebotenen Kontextmenübefehle in der Ansicht Git-Status & Vormerken . Solange der Merge-Vorgang nicht abgeschlossen ist, erscheint die Statusinfo Merging in der Titelzeile der Ansicht sowie in der Taskleiste. Für die Aktion Merge sind der Name und die Email-Adresse des Benutzers erforderlich. Diese Informationen werden aus den- Git-Projekteinstellungen übernommen. Wenn dies nicht möglich ist, werden sie in einem Dialog abgefragt. Upstream: Set\/Clear git push -u origin local-branch git branch --set-upstream-to <origin\/remote-branch> Öffnet den Dialog Upstream-Remote für Branch setzen Hier wird auf dem angebundenen Remote-Repository (üblicherweise „origin“ genannt, das beispielsweise auf einem Server liegt) ein dem lokalen Branch entsprechender Branch angelegt und die Verknüpfung mit diesem eingerichtet. Branch tracken git branch --track Öffnet den Dialog Remote-Branch tracken Hier kann der lokale Branch mit einem verfügbaren Stellvertreter eines Remote-Repositorys (Remote-Branch) verknüpft werden. Dies ermöglicht, die Commits mit Hilfe der Git-Operationen Pull und Push zwischen dem lokalen und dem Remote-Repository auszutauschen. Pull ( git pull ) Pull mit Optionen ( Der Stand des getrackten Remote-Repository-Branches wird in den lokalen Branch abgerufen ( git fetch ) und zusätzlich auch mit diesem gemergt ( git merge ). Voraussetzung: Der lokale Branch trackt den Remote-Branch des Remote-Repositorys. Für die Aktion Pull sind der Name und die Email-Adresse des Benutzers erforderlich. Diese Informationen werden aus den Anmeldeinformationen übernommen, die auf dem Computer hinterlegt sind. Wenn dies nicht möglich ist, werden sie im Dialog Git pull <remote branch> neu abgefragt. Für weitere Informationen zu den Anmeldedaten für ein Remote-Repository sehen Sie: Anmeldedaten erforderlichMit dem Befehl Pull mit Optionen wird dieser Dialog explizit geöffnet, um Einstellungen bearbeiten zu können. Wenn die Option Merken für die Anmeldedaten Name und E-Mail aktiviert ist, werden die Einstellungen aus dem Dialog in der Git-Konfigurationsdatei .git\/config im lokalen Repository gespeichert. Push ( git push ) Wenn es sich bei dem selektierten Branch nicht um einen Tracking-Branch handelt, öffnet sich der Dialog Push Branch . Hier geben Sie den Remote-Branch an, in den gemergt werden soll. Die Commits des lokalen Branches werden in den entsprechenden Branch im Remote-Repository gepusht. Falls es sich bei dem selektierten Branch um einen Tracking-Branch handelt, wird die Aktion unmittelbar ausgeführt. Es erscheint kein Dialog. Vergleichen Der selektierte Branch wird mit dem letzten Stand des Projekts in der Projektablage verglichen und die Unterschiede werden in der Vergleichsansicht dargestellt. Wenn zwei Branches ausgewählt sind, werden diese verglichen. Branches filtern: LokallRemote Mit einem Klick auf die Schaltflächen Local (<n>) oder\/und Remote (<n>) wird in der Tabelle die Anzeige von lokalen Branches oder\/und Remote-Branches („Stellvertreter“ der Branches, die im Remote-Repository liegen) aktiviert oder deaktiviert. Tabelle Aktueller : : Dies ist der lokale Branch, auf dem aktuell gearbeitet wird. Mit Hilfe von Checkout wird ein Branch zum aktuellen gemacht. Das Arbeitsverzeichnis (Git-Repository) enthält dann gerade den Stand dieses Branches. Remote : : Dies ist ein „Remote-Branch“, ein Branch, der im Remote-Repository vorliegt. Der Eintrag hier dient als Stellvertreter dieses Branches, beispielsweise origin\/master als Stellvertreter-Branch des Remote-Repositorys. Tracking : : Der lokale Branch trackt einen Remote-Branch, ist also mit diesem für einen Austausch der Commits via Git-Operationen verbunden. Name : Name des Branches Kanonischer Name : Eindeutiger Name des Branches Beispiel: refs\/heads\/master Remote : Name des Remote-Repositorys, das der Remote-Branch referenziert (üblicherweise origin ) Upstream-Branch, kanonischer Name Beispiel: refs\/heads\/master Tracked Branch, Name : Name des Remote-Branches, der getrackt wird Beispiel: origin\/master Tracked Branch, kanonischer Name : Kanonischer Name des Remote-Branches, der getrackt wird. Beispiel remotes\/origin\/master Wenn ein Branch einen Remote-Branch trackt, sind folgende Infos relevant. Achtung: Diese Anzeige wird nur aktualisiert, wenn ein Fetch ausgeführt wird: Commits voraus : Anzahl der Commits auf dem lokalen (tracking) Branch, mit denen er zeitlich dem Remote-Branch \"voraus\" ist Commits hinterher : Anzahl der Commits, die der lokale (tracking) Branch gegenüber dem Remote-Branch im Rückstand ist. " }, 
{ "title" : "Dialog: Neuen Branch anlegen ", 
"url" : "_git_view_branches.html#UUID-97ba347b-85e1-cc8a-9709-7e25d06325fd_id_c9b5a632b41e5c0a8646364f8237e-id-de5b4ae7906a11eba659cf2e134a78be", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Ansicht: Git-Branches \/ Dialog: Neuen Branch anlegen ", 
"snippet" : "Entsprechender Git-Befehl: git branch --copy Symbol: Funktion : Anlegen eines neuen lokalen Git-Branches Aufruf : Befehl Kopieren in der Ansicht Lokale Branches Voraussetzung : Ein lokaler Branch existiert bereits. Source-Branch Name des Branches, der kopiert wird Neuer Branch-Name Eingabefeld für d...", 
"body" : "Entsprechender Git-Befehl: git branch --copy Symbol: Funktion : Anlegen eines neuen lokalen Git-Branches Aufruf : Befehl Kopieren in der Ansicht Lokale Branches Voraussetzung : Ein lokaler Branch existiert bereits. Source-Branch Name des Branches, der kopiert wird Neuer Branch-Name Eingabefeld für den neuen Namen Erzwingen : Wenn es zum Zeitpunkt eines Checkout nicht committete Änderungen gibt, kann man standardmäßig nicht den Branch wechseln. Mit aktivierter Option Erzwingen wird dies jedoch erzwungen. Checkout : Der neue Branch wird beim Anlegen sofort ausgecheckt und erhält einen Haken bei Aktueller . " }, 
{ "title" : "Dialog: Branch mergen ", 
"url" : "_git_view_branches.html#UUID-97ba347b-85e1-cc8a-9709-7e25d06325fd_section-idm4555057866660833047299804314", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Ansicht: Git-Branches \/ Dialog: Branch mergen ", 
"snippet" : "Symbol: Funktion : Einstellen der Merge-Optionen für den aktuellen Merge-Vorgang. Diese Optionen sind in den CODESYS -Optionen vordefiniert und können für den Einzelfall hier im Dialog Branch mergen verändert werden. Aufruf : Schaltfläche Merge im Dialog Branches , Befehl Mergen mit Optionen Vorauss...", 
"body" : "Symbol: Funktion : Einstellen der Merge-Optionen für den aktuellen Merge-Vorgang. Diese Optionen sind in den CODESYS -Optionen vordefiniert und können für den Einzelfall hier im Dialog Branch mergen verändert werden. Aufruf : Schaltfläche Merge im Dialog Branches , Befehl Mergen mit Optionen Voraussetzung : In der Ansicht Git-Branches ist ein Branch selektiert, der in den aktuell ausgecheckten Branch gemergt werden soll. Branch, der gemergt werden soll Der in der Ansicht Git-Branches selektierte Branch Benutzername und Email-Adresse Wenn der Text aufgeklappt wird, können Name und E-Mail geändert werden. Der Inhalt der Felder wird aus den Git Einstellungen user.name und user.email vorbelegt. Wenn diese Git-Einstellungen nicht vorhanden sind, müssen die Werte durch den Benutzer eingegeben werden. Git Merge-Optionen Merge-Konflikt-Strategie Siehe für Informationen: Optionen: GitFast Forward-Strategie Siehe für Informationen: Optionen: GitCommit bei Erfolg Wenn das Mergen erfolgreich war, werden die resultierenden Änderungen automatisch committet. " }, 
{ "title" : "Ansicht: Git-Remotes ", 
"url" : "_git_view_remotes.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Ansicht: Git-Remotes ", 
"snippet" : "Git-Remotes Symbol: Entsprechender Git-Befehl: git remote Funktion : In der Ansicht werden die Remote-Repositorys verwaltet, die zur Verwaltung von CODESYS -Projekten dienen, an denen mehrere Benutzer arbeiten können sollen. Lokale Repositorys einzelner Benutzer können eine Verbindung zu einem gemei...", 
"body" : "Git-Remotes Symbol: Entsprechender Git-Befehl: git remote Funktion : In der Ansicht werden die Remote-Repositorys verwaltet, die zur Verwaltung von CODESYS -Projekten dienen, an denen mehrere Benutzer arbeiten können sollen. Lokale Repositorys einzelner Benutzer können eine Verbindung zu einem gemeinsamen Remote-Repository einrichten und daraufhin ihre Commits synchronisieren\/zusammenführen. Achten Sie auf eine sichere Verbindung zu einem Remote-Server. Für weitere Informationen siehe: Security für CODESYS Git Aufruf : Menü Git → Remotes Voraussetzung : Ein Projekt ist geöffnet und steht unter Git-Verwaltung. Die Ansicht wird aktualisiert. Hinzufügen Öffnet den Dialog Neues Git-Remote hinzufügen zur Angabe des Remote-Repositorys, mit dem das CODESYS -Projekt verbunden werden soll Alias-Name Hinweis: Der in Git übliche Name für das Remote-Repository ist origin . URL : URL oder Dateipfad des Remote-Repositorys Derzeit werden folgende Protokolle unterstützt: HTTP, HTTPS, Lokal. Beispiele: file:\/\/\/D:\/GitRep\/Remote\/<repository name> , https:\/\/dockerhostpde\/testuser1\/publicproject.git Entfernen Der Benutzer wird gefragt, ob die Verknüpfung zum Remote-Repository wirklich aus dem Projekt entfernt werden soll. Achtung: Alle zum gelöschten Remote-Repository gehörenden Remote-Branches werden gelöscht. Die lokalen Branches bleiben erhalten, tracken aber die gelöschten Remote-Branches nicht mehr. Diese Aktion kann nicht rückgängig gemacht werden. Umbenennen Der Alias-Name des Remote-Repositorys kann geändert werden. URL setzen Öffnet den Dialog URL setzen für Remote <remote> Hier kann die Pfadangabe (URL oder Dateipfad) für das aktuell verwendete Remote-Repository geändert werden. Durch das Ändern der Pfadangabe und damit der Verknüpfung zum Remote-Repository können Remote-Branches verschwinden. Daher müssen die Zuordnungen von lokalen Branches zu Remote-Branches (Tracking) vom Benutzer neu vorgenommen werden. Die lokalen Branches werden nicht verändert. Fetch Fetch (prune) Der lokale Stellvertreter des Remote-Repositorys (Beispiel: origin\/master ) wird mit dem Stand des von allen Benutzern verwendeten Remote-Repositorys aktualisiert: Alle Änderungen werden vom Remote-Repository übernommen. Dies sind alle neuen Branches und neue Commits in den Remote-Branches. Die Commits werden jedoch nicht in die Tracking-Branches übernommen. Hinweis: Um einen lokalen Branch mit dem aktuellen Stand aus dem Remote-Branch zu aktualisieren, muss zusätzlich ein Pull in der Ansicht Git-Branches ausgeführt werden. Als Option erhalten Sie über die Schaltfläche den Befehl Fetch (prune) . Dieser Fetch-Befehl bewirkt, dass Remote-Branches, die im Remote-Repository nicht mehr vorhanden sind, aus dem lokalen Repository gelöscht werden. Anmeldedaten Die Schaltfläche öffnet den Dialog Anmeldedaten bearbeiten . Hier können der Benutzername und das Passwort für den Zugriff auf das Remote-Repository vergeben und bearbeitet werden. Für das ausgewählte Remote-Repository ( Remote-Name ) stellt die Auswahlliste jede URL bereit, für die das Repository Anmeldedaten liefern kann. Für die ausgewählte URL können dann die Anmeldedaten hinterlegt, gelöscht, oder geändert werden. Es wird empfohlen, die Anmeldedaten für die erste URL der Auswahlliste zu hinterlegen, da sie dann auch für andere Projekte innerhalb der \"Domain\" wiederverwendet werden können. Für detaillierte Informationen zur Handhabung domain-spezfischer Anmeldedaten sehen Sie bitte: Anmeldedaten erforderlich. Die Bearbeitung im Dialog ersetzt die Bearbeitung im Windows Credential Manager. Hinweis: Beim Arbeiten mit GitHUb wird ein PAT (Personal Access Token) benötigt. Das PAT muss dann anstelle des Passworts angegeben werden. Beispiel für ein PAT in GitHub: ghp_WPZP1ijlX4E<xxxxxxxxxxxxxxxxxx> Tabelle Name : Alias-Name des Remote-Repositorys URL URL oder Dateipfad des Remote-Repositorys " }, 
{ "title" : "Ansicht: Git-Projekteinstellungen ", 
"url" : "_git_view_project_settings.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Ansicht: Git-Projekteinstellungen ", 
"snippet" : "Git-Projekteinstellungen Funktion : Diese Ansicht zeigt die aktuellen Projekteinstellungen für das mit Hilfe von CODESYS Git in Git verwaltete CODESYS -Projekt („Git-Projekt“). Aufruf : Menü Git → Git-Projekteinstellungen Voraussetzung : Ein Git-Projekt ist geöffnet. Git-Projektablagepfad Pfad der G...", 
"body" : "Git-Projekteinstellungen Funktion : Diese Ansicht zeigt die aktuellen Projekteinstellungen für das mit Hilfe von CODESYS Git in Git verwaltete CODESYS -Projekt („Git-Projekt“). Aufruf : Menü Git → Git-Projekteinstellungen Voraussetzung : Ein Git-Projekt ist geöffnet. Git-Projektablagepfad Pfad der Git-Projektablage (lokales Git-Repository), in dem CODESYS Git die Projektdateien verwaltet Der Pfad wird beim Initialisieren der Git-Anbindung definiert ( Git Init oder Git Clone ). Nicht zu verwechseln mit dem zusätzlichen Ablageort außerhalb der Git-Verwaltung für die CODESYS -Projektdateien (doppelte Datenhaltung). " }, 
{ "title" : "Dialog: Anmeldedaten erforderlich ", 
"url" : "_git_dlg_credentials_needed.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Dialog: Anmeldedaten erforderlich ", 
"snippet" : "Anmeldedaten erforderlich Funktion : In dem Dialog geben Sie die Anmeldedaten für den Zugriff auf ein Remote-Repository ein. Aufruf : Der Dialog erscheint, wenn Sie von CODESYS Git auf ein zugriffsgeschütztes Remote-Repository zugreifen wollen. Dies erfolgt beispielsweise mit dem Befehl Fetch in der...", 
"body" : "Anmeldedaten erforderlich Funktion : In dem Dialog geben Sie die Anmeldedaten für den Zugriff auf ein Remote-Repository ein. Aufruf : Der Dialog erscheint, wenn Sie von CODESYS Git auf ein zugriffsgeschütztes Remote-Repository zugreifen wollen. Dies erfolgt beispielsweise mit dem Befehl Fetch in der Ansicht Remotes . Nach einer serverabhängigen Anzahl von fehlgeschlagenen Versuchen, korrekte Anmeldedaten einzugeben, wird die Operation mit einer entsprechenden Meldung abgebrochen. Achten Sie auf eine sichere Verbindung zu einem Remote-Server. Für weitere Informationen siehe: Security für CODESYS Git Die Anmeldedaten werden in Windows in der Anmeldeinformationsverwaltung gespeichert und sind von der URL des Remotes abgeleitet. Ein git: wird vorangestellt. Beispiel: Die Credentials mit der URL git:https:\/\/gitlab.com\/user\/privateproject.git  werden automatisch für Git-Operationen verwendet, die das Remote-Repository an der URL https:\/\/gitlab.com\/user\/privateproject.git ansteuern. Die Anmeldedaten für das Remote-Repository über den Git-Server können Sie in der Ansicht Git-Remotes bearbeiten. Sie müssen dazu nicht in die Windows Anmeldeinformationsverwaltung wechseln. Sehen Sie weiter unten für Information zur Handhabung von domain-spezifischen Anmeldedaten. Benutzer Benutzername für das Remote-Repository Passwort Passwort für das Remote-Repository, ein leeres Passwort ist möglich Speichern : Die Anmeldedaten werden in der Windows Anmeldeinformationsverwaltung gespeichert. Wenn Sie danach erneut auf das Remote-Repository zugreifen, erscheint keine Aufforderung mehr, die Anmeldedaten einzugeben. " }, 
{ "title" : "Domain-spezifische Anmeldedaten ", 
"url" : "_git_dlg_credentials_needed.html#UUID-933ca5ae-45c1-256f-cb97-3e472b5757e0_section-idm234662684414694", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Dialog: Anmeldedaten erforderlich \/ Domain-spezifische Anmeldedaten ", 
"snippet" : "Remote-Repositorys können sich einen Hostnamen oder Pfad auf einem Host-Server teilen. Anmeldedaten, die für eine Host-URL gespeichert werden, können in diesem Fall für alle Projekte mit demselben Hostnamen verwendet werden. Beispiel: Credentials, die mit der URL git:https:\/\/gitlab.com\/user gespeich...", 
"body" : "Remote-Repositorys können sich einen Hostnamen oder Pfad auf einem Host-Server teilen. Anmeldedaten, die für eine Host-URL gespeichert werden, können in diesem Fall für alle Projekte mit demselben Hostnamen verwendet werden. Beispiel: Credentials, die mit der URL git:https:\/\/gitlab.com\/user gespeichert sind, können sowohl für ein Repository mit URL git:https:\/\/gitlab.com\/user\/project1.git \" als auch für ein Repository mit der URL git:https:\/\/gitlab.com\/user\/project2.git verwendet werden, da die URL Teil von beiden Repository-URLs ist. Somit muss für mehrere Repositorys nur 1 Anmeldedaten-Eintrag erstellt werden. " }, 
{ "title" : "Nutzung von gespeicherten Anmeldedaten ", 
"url" : "_git_dlg_credentials_needed.html#UUID-933ca5ae-45c1-256f-cb97-3e472b5757e0_section-idm234662700956759", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Dialog: Anmeldedaten erforderlich \/ Nutzung von gespeicherten Anmeldedaten ", 
"snippet" : "Wird in CODESYS Git eine Remote-Operation ausgeführt, für die Anmeldedaten benötigt werden, sucht CODESYS Git nach folgendem Verfahren nach gültigen Anmeldedaten: Ausgehend von der vollständigen URL des Repositorys wird für jeden Teilpfad der URL nach gespeicherten Anmeldedaten gesucht, bis ein Eint...", 
"body" : "Wird in CODESYS Git eine Remote-Operation ausgeführt, für die Anmeldedaten benötigt werden, sucht CODESYS Git nach folgendem Verfahren nach gültigen Anmeldedaten: Ausgehend von der vollständigen URL des Repositorys wird für jeden Teilpfad der URL nach gespeicherten Anmeldedaten gesucht, bis ein Eintrag gefunden wird und verwendet diesen für die Authentifizierung. Wenn die Anmeldedaten ungültig sind, erscheint ein Meldungsdialog mit den Optionen: Aktuelle Anmeldedaten mit den neu einzugebenden Anmeldedaten überschreiben Ameldedaten aus den Windows Anmeldeinformationen löschen und ausgehend von der aktuell angezeigten URL wieder nach Einträgen suchen. Wenn mit dieser Suche keine validen Anmeldedaten gefunden werden, erscheint ein Eingabedialog über den Sie Anmeldedaten für die allgemeinste mögliche URL angeben können. Dann können die Anmeldedaten künftig auch für andere Projekte unter dieser URL verwendet werden. " }, 
{ "title" : "Zwei-Faktor-Authorisierung ", 
"url" : "_git_dlg_credentials_needed.html#UUID-933ca5ae-45c1-256f-cb97-3e472b5757e0_section-idm4575047671689634318583574228", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Dialog: Anmeldedaten erforderlich \/ Zwei-Faktor-Authorisierung ", 
"snippet" : "Für die Verbindung zu Git-Plattformen wie beispielsweise GitHub oder GitLab wird möglicherweise eine Zwei-Faktor-Authentifizierung gefordert. Wenn dies der Fall ist, müssen Sie zunächst in der jeweiligen Plattform ein PAT (Personal Access Token) erstellen und dieses in CODESYS Git im Dialog Anmelded...", 
"body" : "Für die Verbindung zu Git-Plattformen wie beispielsweise GitHub oder GitLab wird möglicherweise eine Zwei-Faktor-Authentifizierung gefordert. Wenn dies der Fall ist, müssen Sie zunächst in der jeweiligen Plattform ein PAT (Personal Access Token) erstellen und dieses in CODESYS Git im Dialog Anmeldedaten erforderlich anstelle des Passworts oder des Benutzernamens eintragen. Die folgende Tabelle enthält Informationen zur Erstellung und Verwendung eines PAT der einzelnen Git-Plattformen. Git-Plattform Erforderliche Eingaben für die Autorisierung Detaillierte Informationen zur Erstellung des PAT GitHub Benutzer : Benutzername Passwort : PAT (anstelle des Passworts) GitHub: PAT GitLab Benutzer : Benutzername optional (wird aktuell ignoriert) Passwort : PAT (anstelle des Passworts) GitLab: Personal access tokens Bitbucket Benutzer : Benutzername Passwort : PAT (anstelle des Passworts) Bitbucket Support: Create a Repository Access Token " }, 
{ "title" : "Dialog: Git-Repository-Pfad wählen ", 
"url" : "_git_dlg_extract_git_repository.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Dialog: Git-Repository-Pfad wählen ", 
"snippet" : "Git-Repository-Pfad wählen Funktion : Beim Extrahieren eines CODESYS -Projekts, das auch ein Git-Repository beinhaltet, legen Sie in diesem Dialog einen neuen Ablageort für dieses Repository fest. Aufruf : Befehl Datei → Projektarchiv → Archiv extrahieren , Objekt Git-Repository selektieren, Schaltf...", 
"body" : "Git-Repository-Pfad wählen Funktion : Beim Extrahieren eines CODESYS -Projekts, das auch ein Git-Repository beinhaltet, legen Sie in diesem Dialog einen neuen Ablageort für dieses Repository fest. Aufruf : Befehl Datei → Projektarchiv → Archiv extrahieren , Objekt Git-Repository selektieren, Schaltfläche Extrahieren Voraussetzung : Das zu extrahierende Projektarchiv beinhaltet ein Git-Repository. Git-Repository-Ablageort auswählen Gültiger Pfad für ein Git-Repository im lokalen Dateisystem Beispiel: D:\\GIT_LOCAL\\proj_xy . Siehe Ansicht Git → Projekteinstellungen . " }, 
{ "title" : "Dialog: Git-Projektwiederherstellung ", 
"url" : "_git_dlg_project_recovery.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Dialog: Git-Projektwiederherstellung ", 
"snippet" : "Git-Projektwiederherstellung Funktion : In dem Dialog legen Sie fest, was geschehen soll, wenn ein geladenes CODESYS -Projekt nicht mehr auf das zugehörige Git-Repository zugreifen kann. Aufruf : Der Dialog erscheint beim Öffnen eines Git-Projekts in CODESYS , wenn der gespeicherte Git-Repository-Pf...", 
"body" : "Git-Projektwiederherstellung Funktion : In dem Dialog legen Sie fest, was geschehen soll, wenn ein geladenes CODESYS -Projekt nicht mehr auf das zugehörige Git-Repository zugreifen kann. Aufruf : Der Dialog erscheint beim Öffnen eines Git-Projekts in CODESYS , wenn der gespeicherte Git-Repository-Pfad nicht gefunden wird, oder das Öffnen aus anderen Gründen fehlschlägt. Im Textfeld erscheint eine Beschreibung zum fehlgeschlagenen Versuch, das Git-Projekt aus dem Repository zu laden. Sie enthält den Hinweis, die Git-Meldungen im Meldungsfenster zu prüfen. Optionen Projekt schließen Keine weiteren Aktionen Git-Verknüpfung aus dem Projekt entfernen Die Angabe des Git-Repositorys in den Git-Projekteinstellungen wird entfernt. Das Projekt steht nach dem Speichern nicht mehr unter Git-Verwaltung. Bestehenden Repository-Pfad verwenden Das Projekt wird neu mit einem gültigen Git-Repository im lokalen Dateisystem verknüpft. Der neue Repository-Pfad ist hier im Dialog einzutragen und wird beim Speichern des Projekts automatisch in die Git-Projekteinstellungen übernommen. Achtung: Das gewählte Repository sollte zum Projekt passen. " }, 
{ "title" : "Dialog: Optionen: Git ", 
"url" : "_git_dlg_options_git.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Ansichten und Dialoge \/ Dialog: Optionen: Git ", 
"snippet" : "Optionen: Git Symbol: Funktion: Der Dialog enthält Einstellungen für CODESYS Git . Für weitere Informationen zu den CODESYS -Optionen siehe: Dialog: Optionen Aufruf: Menü Zertifikatshandhabung Zertifikat immer akzeptieren Standardmäßig deaktiviert : Vom Server geschicktes Zertifikat wird immer akzep...", 
"body" : "Optionen: Git Symbol: Funktion: Der Dialog enthält Einstellungen für CODESYS Git . Für weitere Informationen zu den CODESYS -Optionen siehe: Dialog: Optionen Aufruf: Menü Zertifikatshandhabung Zertifikat immer akzeptieren Standardmäßig deaktiviert : Vom Server geschicktes Zertifikat wird immer akzeptiert, auch wenn es nicht gültig ist. Es wird nicht als vertrauenswürdig gekennzeichnet. Selbstsigniertes Zertifikat akzeptieren Standardmäßig deaktiviert : Auch ein selbstsigniertes Zertifikat wird akzeptiert (solche werden normalerweise abgelehnt). Wenn die Option nicht aktiviert ist und kein vertrauenswürdiges Zertifikat vorliegt, erhalten Sie eine Fehlermeldung, Sie können dann die Details des Zertifikats einsehen und entscheiden, ob die Verbindung trotzdem hergestellt werden soll. Git Pull\/Merge-Optionen Git Pull \/ Git Merge Diese Optionen betreffen nur reine Git-Konflikte . Merge-Konflikt-Strategie Optionen: Automatische Merger anwenden (wie verfügbar) : Die automatischen Merge-Funktionalitäten sollen verwendet werden, soweit für den betroffenen Objekttyp verfügbar. Bei Konflikt fehlschlagen (nicht mergen) : Der Merge-Vorgang wird mit einer Fehlermeldung abgebrochen, wenn ein Konflikt auftritt. Der Benutzer soll die Konflikte auflösen : Die Konflikte müssen grundsätzlich händisch bearbeitet werden. Siehe für weitere Informationen: Merge-Konflikte, \"Relationship Issues\"'Unseres' für Konflikte verwenden : CODESYS Git soll versuchen, Konflikte aufzulösen, indem beim Mergen immer der Inhalt des Zielbranches verwendet wird. 'Ihres' für Konflikte verwenden : CODESYS Git soll versuchen, Konflikte aufzulösen, indem beim Mergen immer der Inhalt des Quellbranches verwendet wird. Fast-Forward-Strategie Optionen: Fast-Forward verwenden, wenn möglich : Commits des Quellbranches, die zeitlich nach einem in beiden Branches bereits vorhandenen Commit liegen, werden beim Mergen automatisch übernommen. In der Historie entsteht in diesem Fall kein Merge-Commit-Eintrag. Wenn die Commits nicht konsistent sind, erfolgt kein Fast-Forward. Kein Fast-Forward Nur Fast-Forward (ansonsten fehlschlagen) : Das Mergen wird immer mit Fast-Forward-Strategie versucht. Wenn die Voraussetzungen nicht gegeben sind, schlägt das Mergen mit einer entsprechenden Meldung fehl. Typischer Anwendungsfall für Fast-Forward: Pull Commit bei Erfolg : : Wenn der Pull- oder Merge-Vorgang ohne Konflikt ausgeführt wurde, wird automatisch auch ein Commit ausgeführt. Bei erfolgreichem Fast-Forward hat die Option keine Auswirkung. Meldungserfassung Ausführlichkeitsgrad Auswahl des Ausführlichkeitsgrads: Standard : Grundlegende Informationen (beispielsweise Befehlsname mit Angabe über Erfolg der Aktion, keine Details) Ausführlich : Zusätzliche Informationen zu Ergebnissen und Zwischenschritten. Hilfreich bei Scripting im Betrieb ohne CODESYS -Benutzeroberfläche. " }, 
{ "title" : "Menübefehle ", 
"url" : "_git_struct_reference_commands.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Git-Projekteinstellungen ", 
"url" : "_git_cmd_git_project_settings.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Git-Projekteinstellungen ", 
"snippet" : "Git-Projekteinstellungen Funktion : Der Befehl öffnet die Ansicht Git-Projekteinstellungen. Die Ansicht zeigt den Pfad der Git-Projektablage (lokales Repository) für das gerade geöffnete Projekt. Aufruf : Menü Git Voraussetzung : Das geöffnete CODESYS -Projekt ist unter Git-Verwaltung in einem lokal...", 
"body" : "Git-Projekteinstellungen Funktion : Der Befehl öffnet die Ansicht Git-Projekteinstellungen. Die Ansicht zeigt den Pfad der Git-Projektablage (lokales Repository) für das gerade geöffnete Projekt. Aufruf : Menü Git Voraussetzung : Das geöffnete CODESYS -Projekt ist unter Git-Verwaltung in einem lokalen Repository. " }, 
{ "title" : "Befehl: Status & Vormerken ", 
"url" : "_git_cmd_status_and_staging.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Status & Vormerken ", 
"snippet" : "Status & Vormerken Symbol: ( git status ) Funktion : Der Befehl öffnet die Ansicht Git-Status & Vormerken. Die Ansicht zeigt den Git-Status der seit dem letzten Commit geänderten Objekte. In der Ansicht werden geänderte Objekte für den Git-Commit vorbereitet (Staging) und vorbereitete Objekte in das...", 
"body" : "Status & Vormerken Symbol: ( git status ) Funktion : Der Befehl öffnet die Ansicht Git-Status & Vormerken. Die Ansicht zeigt den Git-Status der seit dem letzten Commit geänderten Objekte. In der Ansicht werden geänderte Objekte für den Git-Commit vorbereitet (Staging) und vorbereitete Objekte in das angebundene lokale Git-Repository committet. Aufruf : Menü Git Voraussetzung : Das geöffnete CODESYS -Projekt wird in einem lokalen Git-Repository verwaltet. " }, 
{ "title" : "Befehl: Branches ", 
"url" : "_git_cmd_branches.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Branches ", 
"snippet" : "Branches Symbol: ( git branch ) Funktion : Der Befehl öffnet die Ansicht Git-Branches , in der die Branches für die Arbeit im Git-Repository erstellt und verwaltet werden. Aufruf : Menü Git Voraussetzung : Das geöffnete CODESYS -Projekt wird in einem lokalen Git-Repository verwaltet....", 
"body" : "Branches Symbol: ( git branch ) Funktion : Der Befehl öffnet die Ansicht Git-Branches , in der die Branches für die Arbeit im Git-Repository erstellt und verwaltet werden. Aufruf : Menü Git Voraussetzung : Das geöffnete CODESYS -Projekt wird in einem lokalen Git-Repository verwaltet. " }, 
{ "title" : "Befehl: Remotes ", 
"url" : "_git_cmd_remotes.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Remotes ", 
"snippet" : "Remotes Tastaturkürzel: F7 ( git remote ) Funktion : Der Befehl öffnet die Ansicht Git-Remotes In der Ansicht werden die Remote-Repositorys verwaltet, die in Verbindung mit den lokalen Git-Repositorys für CODESYS -Projekte unter CODESYS Git dienen. Aufruf : Menü Git Voraussetzung : Ein CODESYS -Proj...", 
"body" : "Remotes Tastaturkürzel: F7 ( git remote ) Funktion : Der Befehl öffnet die Ansicht Git-Remotes In der Ansicht werden die Remote-Repositorys verwaltet, die in Verbindung mit den lokalen Git-Repositorys für CODESYS -Projekte unter CODESYS Git dienen. Aufruf : Menü Git Voraussetzung : Ein CODESYS -Projekt, das unter Git-Verwaltung in einem lokalen Git-Repository steht, ist geöffnet. " }, 
{ "title" : "Befehl: History ", 
"url" : "_git_cmd_history.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: History ", 
"snippet" : "History ( git log ) Funktion : Der Befehl öffnet die Ansicht History . Die Ansicht stellt die Historie der Commits im Repository dar. Aufruf : Menü Git Voraussetzung : Das geöffnete CODESYS -Projekt wird in einem lokalen Git-Repository verwaltet....", 
"body" : "History ( git log ) Funktion : Der Befehl öffnet die Ansicht History . Die Ansicht stellt die Historie der Commits im Repository dar. Aufruf : Menü Git Voraussetzung : Das geöffnete CODESYS -Projekt wird in einem lokalen Git-Repository verwaltet. " }, 
{ "title" : "Befehl: Git-Repository initialisieren... ", 
"url" : "_git_cmd_git_init.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Git-Repository initialisieren... ", 
"snippet" : "Git-Repository initialisieren... ( git init ) Funktion : Der Befehl öffnet den Dialog Git-Repository initialisieren zur Initialisieurung eines lokalen Git-Repositorys für das geöffnete CODESYS -Projekt. Bei der Initialisierung wird das Projekt in Git importiert, wodurch ein lokales Repository und de...", 
"body" : "Git-Repository initialisieren... ( git init ) Funktion : Der Befehl öffnet den Dialog Git-Repository initialisieren zur Initialisieurung eines lokalen Git-Repositorys für das geöffnete CODESYS -Projekt. Bei der Initialisierung wird das Projekt in Git importiert, wodurch ein lokales Repository und der Index für das Projekt erzeugt werden (Git-Projektablage). Damit wird das Git-Arbeitsverzeichnis für das Projekt angelegt. Aufruf : Menü Git Voraussetzung : Ein CODESYS -Projekt ist geöffnet. Wenn für das CODESYS -Projekt eine Verschlüsselung eingestellt ist ( CODESYS - Projekteinstellungen - Sicherheit ), ist das Git-Repository (weder lokal noch Remote) nicht automatisch auch entsprechend geschützt. Dialog Git-Repository initialisieren Eingabefeld für den Pfad des lokalen Git-Verzeichnisses Pfad des leeren Verzeichnisses im Dateisystem, das für die neue Git-Projektablage verwendet werden soll Beispiel: D:\\git_local\\rep1 OK Das geöffnete Projekt wird in Git importiert und für das Projekt wird das Lokale Repository erzeugt. In den Navigatoransichten des Projekts werden die Objekte mit folgenden Symbolen gekennzeichnet: Wurzelknoten des Projekts: alle anderen Objekte und Geräte des Projekt: Im Meldungsfenster erscheinen entsprechende Git-Meldungen. " }, 
{ "title" : "Befehl: Git-Repository klonen... ", 
"url" : "_git_cmd_git_clone.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Git-Repository klonen... ", 
"snippet" : "Git-Repository klonen... ( git clone ) Funktion : Der Befehl öffnet den Dialog Git Clone . Mit Hilfe des Dialogs wird ein Remote-Repository in ein leeres Verzeichnis kopiert, welches damit zu einem neuen lokalen Git-Repository wird. Das lokale Repository enthält nach dem Kopiervorgang die gesamte Hi...", 
"body" : "Git-Repository klonen... ( git clone ) Funktion : Der Befehl öffnet den Dialog Git Clone . Mit Hilfe des Dialogs wird ein Remote-Repository in ein leeres Verzeichnis kopiert, welches damit zu einem neuen lokalen Git-Repository wird. Das lokale Repository enthält nach dem Kopiervorgang die gesamte Historie des Remote-Repositorys. Aufruf : Menü Git Voraussetzung : In CODESYS ist kein Projekt geöffnet. Wenn für das CODESYS -Projekt eine Verschlüsselung eingestellt ist ( CODESYS - Projekteinstellungen - Sicherheit ), ist das Git-Repository (weder lokal noch Remote) nicht automatisch auch entsprechend geschützt. Dialog Git Clone Klonen von Quell-URL URL oder Dateipfad des Remote-Repositorys Klonen nach Git-Speicherpfad Dateiverzeichnis für die Git-Projektablage (Verzeichnis, in dem das Lokale Repository liegt). Beispiel: D:\\git_local\\rep1 Projektdatei Dateipfad für die Projektdatei ( Projektverzeichnis ). Beachten Sie: Die Projektdatei darf nicht im gleichen Verzeichnis liegen wie die Git-Projektablage. Beispiel: D:\\git_projects\\myproj1.project Projektdateityp Projekt Bibliothek Verwandt dem Clone-Vorgang können Sie den Befehl Projekt aus Repository neu erstellen verwenden, um ein im Git-Repository bereits vorhandenes Projekt als neues CODESYS -Projekt zu laden. " }, 
{ "title" : "Befehl: Von Git-Repository trennen... ", 
"url" : "_git_cmd_git_deinit.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Von Git-Repository trennen... ", 
"snippet" : "Von Git-Repository trennen... Funktion : Der Befehl löscht die gesamte Git-Projektablage . Somit ist das geöffnete CODESYS -Projekt in Git nicht mehr vorhanden. Aufruf : Menü Git Voraussetzung : Für das geöffnete CODESYS -Projekt existiert eine Git-Projektablage und somit auch ein lokales Repository...", 
"body" : "Von Git-Repository trennen... Funktion : Der Befehl löscht die gesamte Git-Projektablage . Somit ist das geöffnete CODESYS -Projekt in Git nicht mehr vorhanden. Aufruf : Menü Git Voraussetzung : Für das geöffnete CODESYS -Projekt existiert eine Git-Projektablage und somit auch ein lokales Repository. Das heißt, Git Init oder Git Clone wurden zuvor ausgeführt. " }, 
{ "title" : "Befehl: Projekt aus Repository neu erstellen ", 
"url" : "_git_cmd_build_project_from_repository.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Projekt aus Repository neu erstellen ", 
"snippet" : "Projekt aus Repository neu erstellen Funktion : Der Befehl ermöglicht das erneute Erstellen eines Projekts in CODESYS aus der Git-Projektablage (lokales Repository). Der Vorgang ist somit ähnlich dem Erstellen eines Git-Projekts über Git Clone (aus Remote-Repository). Aufruf : Der Befehl ist nicht s...", 
"body" : "Projekt aus Repository neu erstellen Funktion : Der Befehl ermöglicht das erneute Erstellen eines Projekts in CODESYS aus der Git-Projektablage (lokales Repository). Der Vorgang ist somit ähnlich dem Erstellen eines Git-Projekts über Git Clone (aus Remote-Repository). Aufruf : Der Befehl ist nicht standardmäßig im Git-Menü enthalten. Voraussetzung : Kein Projekt ist in CODESYS geöffnet. Der Befehl öffnet den Dialog Projekt neu erstellen . Hier geben Sie Quelle und Ziel des Projekts an, das neu erstellt werden soll. Quelle Git-Repository-Ablageort Pfad des Git-Repositorys, aus dem das Projekt in CODESYS neu erstellt werden soll Ziel Projektdatei Dateiverzeichnis für die CODESYS-Projektablage Beispiel: D:\\proj.project Projektdateityp : Projekt : Bibliothek " }, 
{ "title" : "Befehl: Projekt aus Repository neu laden ", 
"url" : "_git_cmd_load_project_from_repository.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Projekt aus Repository neu laden ", 
"snippet" : "Projekt aus Repository neu laden Funktion : Der Befehl bewirkt eine Resynchronisation des Projekts. Aufruf : Der Befehl ist nicht standardmäßig im Git-Menü enthalten. Voraussetzung : Ein Projekt ist geöffnet und ist unter Git-Versionsverwaltung. CODESYS Git versucht, das Projekt aus dem aktuellen St...", 
"body" : "Projekt aus Repository neu laden Funktion : Der Befehl bewirkt eine Resynchronisation des Projekts. Aufruf : Der Befehl ist nicht standardmäßig im Git-Menü enthalten. Voraussetzung : Ein Projekt ist geöffnet und ist unter Git-Versionsverwaltung. CODESYS Git versucht, das Projekt aus dem aktuellen Stand aus dem Arbeitsverzeichnis des Git-Repositorys wieder zu erstellen. " }, 
{ "title" : "Befehl: Projekt mit Git-Projektablage synchronisieren ", 
"url" : "_git_cmd_synchronize_project.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Projekt mit Git-Projektablage synchronisieren ", 
"snippet" : "Projekt mit Git-Projektablage synchronisieren Funktion : Ein unter Git-Verwaltung befindliches CODESYS -Projekt wird in die Git-Projektablage geschrieben. Aufruf : Menü Git Voraussetzung : Ein Git-Projekt ist in CODESYS geöffnet. Die Synchronisierung bedeutet, dass das aktuelle CODESYS -Projekt in d...", 
"body" : "Projekt mit Git-Projektablage synchronisieren Funktion : Ein unter Git-Verwaltung befindliches CODESYS -Projekt wird in die Git-Projektablage geschrieben. Aufruf : Menü Git Voraussetzung : Ein Git-Projekt ist in CODESYS geöffnet. Die Synchronisierung bedeutet, dass das aktuelle CODESYS -Projekt in der Git-Projektablage das aktuelle Arbeitsverzeichnis überschreibt. " }, 
{ "title" : "Befehl: Repository verschieben ", 
"url" : "_git_cmd_move_repository.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Repository verschieben ", 
"snippet" : "Repository verschieben Funktion : Der Befehl öffnet den Dialog Git-Repository verschieben , um die Git-Projektablage mit seinem kompletten Inhalt in ein neues Verzeichnis zu verschieben. Alle Inhalte werden verschoben, die Commit-Historie bleibt ebenfalls erhalten. Aufruf : Menü Git Voraussetzung : ...", 
"body" : "Repository verschieben Funktion : Der Befehl öffnet den Dialog Git-Repository verschieben , um die Git-Projektablage mit seinem kompletten Inhalt in ein neues Verzeichnis zu verschieben. Alle Inhalte werden verschoben, die Commit-Historie bleibt ebenfalls erhalten. Aufruf : Menü Git Voraussetzung : Für das geöffnete CODESYS -Projekt wurde bereits mindestens 1 Commit ausgeführt. Dialog Git-Repository verschieben Repository verschieben von Aktueller Pfad Pfad des lokalen Repositorys des Projekts Zu Zielpfad Zielverzeichnis, wohin das lokale Repository verschoben wird Voraussetzung: Das angegebene Verzeichnis muss leer sein " }, 
{ "title" : "Befehl: Objekt vergleichen ", 
"url" : "_git_cmd_compare_object.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Objekt vergleichen ", 
"snippet" : "Objekt vergleichen Symbol : Funktion : Ein Objekt, das im CODESYS -Projektbaum selektiert ist, kann mit seinem letzten comitteten Stand oder mit dem vorgemerkten Stand (index) verglichen werden. Aufruf : Kontextmenü des im Projektnavigator selektierten Objekts Voraussetzung : Ein Git-Projekt ist in ...", 
"body" : "Objekt vergleichen Symbol : Funktion : Ein Objekt, das im CODESYS -Projektbaum selektiert ist, kann mit seinem letzten comitteten Stand oder mit dem vorgemerkten Stand (index) verglichen werden. Aufruf : Kontextmenü des im Projektnavigator selektierten Objekts Voraussetzung : Ein Git-Projekt ist in CODESYS geöffnet. Der Befehl öffnet die Vergleichsansicht , in der der aktuelle Stand des Objekts im Projekts mit seinem zuletzt ins Git-Repository committeten Stand oder dem letzten Stand im Index verglichen wird. Im linken Fenster wird der Stand im Projekt gezeigt (Neueres), im rechten Fenster der Stand des letzten Commits oder letzten Indexstands. " }, 
{ "title" : "Befehl: Zwei Objekte mergen ", 
"url" : "_git_cmd_merge_two_objects.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Zwei Objekte mergen ", 
"snippet" : "Zwei Objekte mergen Funktion : Zwei im Projektnavigator selektierte Objekte des gleichen Typs können gemergt werden. Aufruf : Kontextmenü, wenn die Objekte im Projektnavigator selektiert sind Voraussetzung : Die Objekte müssen vom gleichen Typ sein. Beispielsweise kann nicht ein Funktionsbaustein mi...", 
"body" : "Zwei Objekte mergen Funktion : Zwei im Projektnavigator selektierte Objekte des gleichen Typs können gemergt werden. Aufruf : Kontextmenü, wenn die Objekte im Projektnavigator selektiert sind Voraussetzung : Die Objekte müssen vom gleichen Typ sein. Beispielsweise kann nicht ein Funktionsbaustein mit einer Taskkonfiguration gemergt werden. Der Befehl öffnet die Ansicht Merge <object1> in <object2> . Diese entspricht weitgehend der Ansicht, die auch zum Vergleichen von Objekten verwendet wird. Sie können darin explizit festlegen, welche Inhalte von der Merge-Quelle (linkes Fenster) in das Merge-Ziel (rechtes Fenster) übernommen werden sollen. Um die Richtung des Merges umzukehren, verwenden Sie die Schaltfläche Objekte umschalten . Entsprechend wechseln die dargestellten Inhalte der beiden Objekte zwischen linkem und rechtem Fenster. Das Mergen berücksichtigt nur die hier in der Ansicht dargestellten Objekte. Ihre Kinder oder Eigenschaften werden nicht gemergt oder geändert. Sehen Sie für Informationen zur Vergleichsansicht: Vergleichsansicht" }, 
{ "title" : "Befehl: Branch aus Commit erzeugen ", 
"url" : "_git_cmd_create_branch_from_commit.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Branch aus Commit erzeugen ", 
"snippet" : "Branch aus Commit erzeugen Symbol : Funktion : Aus einem Commit in der Ansicht History wird ein neuer Branch für das betroffene Projekt erzeugt und ist danach in der Ansicht Git-Branches verfügbar. Aufruf : Kontextmenü eines Commit-Eintrags in der Ansicht History Der Befehl öffnet den Dialog Branch ...", 
"body" : "Branch aus Commit erzeugen Symbol : Funktion : Aus einem Commit in der Ansicht History wird ein neuer Branch für das betroffene Projekt erzeugt und ist danach in der Ansicht Git-Branches verfügbar. Aufruf : Kontextmenü eines Commit-Eintrags in der Ansicht History Der Befehl öffnet den Dialog Branch aus Commit erzeugen zum Definieren des neuen Branches. " }, 
{ "title" : "Dialog: Branch aus Commit erzeugen ", 
"url" : "_git_cmd_create_branch_from_commit.html#UUID-102fabea-ba95-ff2e-3b37-dc6bdeefb8e0_section-idm4573495381971233102385669569", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Branch aus Commit erzeugen \/ Dialog: Branch aus Commit erzeugen ", 
"snippet" : "Quell-Commit SHA1 SHA1 (eindeutige ID) des Commits Meldung Commit-Meldung des Commits Name für neuen Branch Name, unter dem der neue Branch in Ansicht Branches erscheinen soll Erzwingen Der neue Branch wird auch dann erzeugt, wenn es bereits einen Branch gleichen Namens gibt und auch wenn es lokale,...", 
"body" : "Quell-Commit SHA1 SHA1 (eindeutige ID) des Commits Meldung Commit-Meldung des Commits Name für neuen Branch Name, unter dem der neue Branch in Ansicht Branches erscheinen soll Erzwingen Der neue Branch wird auch dann erzeugt, wenn es bereits einen Branch gleichen Namens gibt und auch wenn es lokale, nicht committete Änderungen gibt. Checkout Der neue Branch wird nach dem An legen in der Ansicht Branches ausgecheckt. " }, 
{ "title" : "Befehl: Git Config ", 
"url" : "_git_cmd_git_config.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Menübefehle \/ Befehl: Git Config ", 
"snippet" : "Git Config Funktion : Der Befehl öffnet einen Dialog zum Bearbeiten der Einträge für die Sektionen core , init , und user in der Konfigurationsdatei .git\/config . Diese Datei liegt nach dem Initialisieren im lokalen Git-Repository. Hintergrund: Wenn Sie ein Repository klonen oder initialisieren, und...", 
"body" : "Git Config Funktion : Der Befehl öffnet einen Dialog zum Bearbeiten der Einträge für die Sektionen core , init , und user in der Konfigurationsdatei .git\/config . Diese Datei liegt nach dem Initialisieren im lokalen Git-Repository. Hintergrund: Wenn Sie ein Repository klonen oder initialisieren, und es liegt noch keine globale .gitconfig -Datei vor, werden Sie aufgefordert, eine solche initial zu konfigurieren. Mit dem Befehl Git Config können Sie die Datei jederzeit erneut bearbeiten. Die globale .gitconfig -Datei liegt standardmäßig im Benutzerverzeichnis (z.B. C:\/Users\/<username> ). Aufruf : Menü Git Voraussetzung : Das geöffnete CODESYS -Projekt ist unter Git-Verwaltung in einem lokalen Repository. Dialog : Bearbeiten Sie Ihre git config. Änderungen werden in der config-Datei des Repositorys gespeichert. Core Long Paths Diese Option muss aktiviert sein, damit lange Pfade unterstützt werden und dadurch CODESYS Git korrekt arbeiten kann. Init Standard-Branch Der lokale Standard-Branch eines Git-Repositorys (üblicherweise master entsteht automatisch nach dem ersten Commit. Siehe hierzu auch: EinführungUser Benutzer Email " }, 
{ "title" : "Symbole ", 
"url" : "_git_reference_symbols.html", 
"breadcrumbs" : "CODESYS Git \/ Referenz, Benutzeroberfläche \/ Symbole ", 
"snippet" : "Jedes Objekt besitzt einen Status im Index (vorgemerkte Änderungen) und im Git-Repository . Der Status wird durch ein entsprechendes Symbol vor dem Objekt in den Navigatoransichten des CODESYS -Projekts oder in der Ansicht Status & Vormerken angezeigt. Symbol Beschreibung Unverändert (im Arbeitsverz...", 
"body" : "Jedes Objekt besitzt einen Status im Index (vorgemerkte Änderungen) und im Git-Repository . Der Status wird durch ein entsprechendes Symbol vor dem Objekt in den Navigatoransichten des CODESYS -Projekts oder in der Ansicht Status & Vormerken angezeigt. Symbol Beschreibung Unverändert (im Arbeitsverzeichnis) Das Objekt ist gegenüber dem Index unverändert. Geändert (im Arbeitsverzeichnis) Das Objekt wurde gegenüber der vorherigen Version im Index verändert. Neu (im Arbeitsverzeichnis) Das Objekt existiert im Arbeitsverzeichnis, aber noch nicht im Index oder im lokalen Repository. Konflikt oder Relationship Issue Beim Mergen des Objekts ist ein Konflikt oder ein Relationship Issue aufgetreten. Gelöscht (im Arbeitsverzeichnis) Das Objekt existiert nicht im Arbeitsverzeichnis, es existiert aber noch im Index. Fehler Keine Zuordnung zu einem Status Das Symbol erscheint nur im Navigator. Transient Tranisente Objekte werden nicht in das Git-Repository aufgenommen. Das Symbol erschient nur im Navigator. Git-Status konnte noch nicht ermittelt werden. Sobald der Status bekannt ist, erscheint das entsprechende Symbol. Das Symbol erscheint nur im Navigator. " }, 
{ "title" : "Fehlerbehebung - \"Unbekannter Fehler\" ", 
"url" : "_git_troubleshooting.html", 
"breadcrumbs" : "CODESYS Git \/ Fehlerbehebung - \"Unbekannter Fehler\" ", 
"snippet" : "Die Fehlermeldung \"Unbekannter Fehler\" erscheint für eine Reihe von Fehlern, die CODESYS nicht selbstständig auflösen kann. Für einige dieser Fehler gibt es für den Anwender jedoch Möglichkeiten für eine Behebung. Klicken Sie im Meldungsdialog mit der Fehlermeldung auf die Schaltfläche Details , um ...", 
"body" : "Die Fehlermeldung \"Unbekannter Fehler\" erscheint für eine Reihe von Fehlern, die CODESYS nicht selbstständig auflösen kann. Für einige dieser Fehler gibt es für den Anwender jedoch Möglichkeiten für eine Behebung. Klicken Sie im Meldungsdialog mit der Fehlermeldung auf die Schaltfläche Details , um weitere Informationen zum Fehler zu erhalten. Sehen Sie im Folgenden Instruktionen zu einer möglichen Behandlung des jeweiligen Fehlers: " }, 
{ "title" : "Pfad zu lang ", 
"url" : "_git_troubleshooting.html#UUID-5b09f6b2-044d-09e7-27fa-a7ba0d49e5a2_section-idm23463169779052", 
"breadcrumbs" : "CODESYS Git \/ Fehlerbehebung - \"Unbekannter Fehler\" \/ Pfad zu lang ", 
"snippet" : "Diese Fehlermeldung kann erscheinen, wenn die Dateipfade des Git-Projekts im Dateisystem zu lang sind. Um das Problem zu lösen, müssen Sie für Git die Option Lange Pfade aktivieren. Hierfür gibt es zwei mögliche Lösungen: Aktivieren der Option im Projekt über Git Config : Wählen Sie im geöffneten Pr...", 
"body" : "Diese Fehlermeldung kann erscheinen, wenn die Dateipfade des Git-Projekts im Dateisystem zu lang sind. Um das Problem zu lösen, müssen Sie für Git die Option Lange Pfade aktivieren. Hierfür gibt es zwei mögliche Lösungen: Aktivieren der Option im Projekt über Git Config : Wählen Sie im geöffneten Projekt den Befehl Git - Git Config . Aktivieren Sie im Konfigurationsdialog die Option Lange Pfade . Schließen Sie den Dialog mit OK . Schließen Sie das Projekt und öffnen Sie es erneut. Aktivieren der Option in der Datei .gitconfig des Benutzers: Öffnen Sie die Datei C:\\Benutzer\\<Benutzername>\\.gitconfig (Beispiel: C:\\Benutzer\\m.muster\\.gitconfig ). Bearbeiten Sie die Datei so, dass es im Bereich core einen Eintrag longpaths = true gibt. Schließen Sie danach das Projekt und öffnen Sie es erneut. [core]    \n longpaths = true " }, 
{ "title" : "Konflikt verhindert Checkout ", 
"url" : "_git_troubleshooting.html#UUID-5b09f6b2-044d-09e7-27fa-a7ba0d49e5a2_section-idm23463173497096", 
"breadcrumbs" : "CODESYS Git \/ Fehlerbehebung - \"Unbekannter Fehler\" \/ Konflikt verhindert Checkout ", 
"snippet" : "Dieser Fehler kann bei Git-Operationen auftreten, die einen Merge durchführen ( git merge \/ git pull ). Vermutlich befinden sich im Repository modifizierte Dateien, die nicht Teil des CODESYS -Projekts sind. Öffnen Sie die Ansicht Status & Vormerken . Prüfen Sie, ob unter  Nicht vorgemerkte Änderung...", 
"body" : "Dieser Fehler kann bei Git-Operationen auftreten, die einen Merge durchführen ( git merge \/ git pull ). Vermutlich befinden sich im Repository modifizierte Dateien, die nicht Teil des CODESYS -Projekts sind. Öffnen Sie die Ansicht Status & Vormerken . Prüfen Sie, ob unter  Nicht vorgemerkte Änderungen \"externe\" Dateien aufgelistet sind, die also im Projekt in den Ansichten Geräte oder POUs nicht als Objekte zu finden sind. Ob eine Datei eine externe Datei ist, können Sie zusätzlich wie folgt prüfen: Führen Sie in Ansicht Status & Vormerken in der Spalte Objekt einen Doppelklick auf den Dateieintrag aus. Wenn statt der Vergleichsansicht die Fehlermeldung: External objects are not supported in diff view erscheint, liegt ein externes Objekt vor. " }
]
$(document).trigger('search.ready');
});