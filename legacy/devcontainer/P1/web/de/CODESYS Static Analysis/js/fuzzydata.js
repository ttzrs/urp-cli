$(document).ready(function () {indexDict['de'] = [{ "title" : "CODESYS Static Analysis ", 
"url" : "_san_start_page.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis ", 
"snippet" : "Mit CODESYS Static Analysis kann eine Überprüfung des IEC-Quellcodes anhand definierter Regeln, Namenskonventionen oder Metriken durchgeführt werden. Daraufhin werden Hinweise auf mögliche Entwicklungsprobleme aufgezeigt und Fehler können bereits vor einem Feldtest erkannt und behoben werden. So kön...", 
"body" : "Mit CODESYS Static Analysis kann eine Überprüfung des IEC-Quellcodes anhand definierter Regeln, Namenskonventionen oder Metriken durchgeführt werden. Daraufhin werden Hinweise auf mögliche Entwicklungsprobleme aufgezeigt und Fehler können bereits vor einem Feldtest erkannt und behoben werden. So können bei der Entwicklung von Applikationen und bei der Fehlersuche viel Zeit eingespart werden. In CODESYS Static Analysis sind bereits mehr als 100 zum Teil parametrisierbare Regeln implementiert, die Sie zu individuellen Regelwerken kombinieren können. In einigen Regeln werden die in \"PLCopen Coding Guidelines\" definierten Regelsätze berücksichtigt. Außerdem können Sie für jeden möglichen Datentyp eine Namenskonvention definieren, auf dessen Einhaltung dann geprüft wird. Darüber hinaus stehen Ihnen über 20 Metriken zur Verfügung, die bei regelmäßiger Berechnung den zugrundeliegenden Quellcode analysieren und Hinweise auf negative Trends und Abweichungen von Qualitätszielen geben können. Sie können CODESYS Static Analysis im CODESYS Store International oder im CODESYS Store North America herunterladen. Dort finden Sie auch das Datenblatt zum Produkt. Das Produkt ist lizenzpflichtig. Webinar CODESYS Static Analysis Ist CODESYS Static Analysis installiert, aber keine Lizenz aktiviert, erscheint eine reduzierte Oberfläche mit dem Funktionsumfang von Static Analysis Light . Als Alternative zu CODESYS Static Analysis wird im CODESYS Development System das Add-on Static Analysis Light bereitgestellt. Das Add-on ist automatisch Bestandteil von CODESYS , wenn kein CODESYS Static Analysis installiert ist. " }, 
{ "title" : "Static Analysis Light ", 
"url" : "_san_start_page.html#UUID-cc139654-e7d3-fe83-903e-e33f8fd0a5ec_section-idm452529692233763389020840932", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis \/ Static Analysis Light ", 
"snippet" : "Static Analysis Light hat einen stark eingeschränkten Funktionsumfang und stellt lediglich 7 Kompilierungsprüfungen bereit. Das Produkt ist frei verfügbar. Sie können die Kompilierungsprüfungen unter Menü Projekt → Projekteinstellungen , Kategorie Static Analysis Light einzeln aktivieren. Für weiter...", 
"body" : "Static Analysis Light hat einen stark eingeschränkten Funktionsumfang und stellt lediglich 7 Kompilierungsprüfungen bereit. Das Produkt ist frei verfügbar. Sie können die Kompilierungsprüfungen unter Menü Projekt → Projekteinstellungen , Kategorie Static Analysis Light einzeln aktivieren. Für weitere Informationen siehe: Projekteinstellungen: Static Analysis Light " }, 
{ "title" : "Überblick ", 
"url" : "_san_overview.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Überblick ", 
"snippet" : "Die statische Analyse wird im aktuellen Projekt nur für den Applikationscode durchgeführt. Bibliotheken und deren Quellcodes werden nicht analysiert! CODESYS Static Analysis unterstützt Sie bei der Implementierung, um besseren, gut lesbaren Code zu schreiben und widersprüchliche oder nicht unterstüt...", 
"body" : "Die statische Analyse wird im aktuellen Projekt nur für den Applikationscode durchgeführt. Bibliotheken und deren Quellcodes werden nicht analysiert! CODESYS Static Analysis unterstützt Sie bei der Implementierung, um besseren, gut lesbaren Code zu schreiben und widersprüchliche oder nicht unterstützte Programmteile zu erkennen. Insbesondere werden potenzielle Fehlerquellen aufgedeckt. Beispielsweise werden Stellen identifiziert, an denen noch Testcode enthalten ist. Oder es werden Pointer gefunden, die vor einer Dereferenzierung nicht auf 0 überprüft werden. Oder es werden (mit der Regel SA0119 ) die Stellen analysiert, an denen objektorientierte Sprachmittel verwendet werden, die eine Portierung auf eine andere, die Objektorientierung nicht unterstütztene Entwicklungsumgebung ummöglich machen. Die Portierbarkeit des Codes kann so sichergestellt werden. Für Fehler, die von der statische Codeanalyse auf Basis von Informationen während der Vorkompilierung gemeldet werden, gibt es eine Unterstützung zur unmittelbaren Fehlerbehandlung („Quickfix“). Dadurch können Sie schnell die Stellen im Code finden und beheben, die bei der Analyse gemeldet werden. Zur Verbesserung der Lesbarkeit des Quellcodes können Sie Namenskonventionen definieren und auf deren Einhaltung prüfen. Um die Qualität des Codes zu beurteilen, können Sie darüber hinaus Metriken anzeigen lassen, die anhand des Quellcodes ermittelt wurden. Beispiele dafür sind die McCabe-Metrik als Maß für die Testbarkeit des Codes, oder die kognitive Komplexität als Maß für Lesbarkeit und Wartbarkeit von Quelltext. Die bei der statischen Analyse durchgeführte Datenflussanalyse erfolgt nach dem Prinzip der Konstantenpropagation. Mit dem Menübefehl Statische Analyse durchführen aktivieren Sie explizit die statische Analyse. Im Dialog Einstellungen aktivieren Sie eine automatisch nach jeder Codekompilierung ausgeführte statische Analyse. Mit Hilfe von Pragmas und Attribute nehmen Sie einzelne Teile oder Bausteine des Codes von der Analyse aus. Im Dialog Regeln informieren Sie sich darüber, welche Regeln wie konfiguriert und aktiviert sind, und wann die Prüfungen auf die jeweilige Regel laufen. Dort aktivieren Sie die für Sie relevanten Regeln. Im Dialog Namenskonventionen weisen Sie jeden Datentyp ein Präfix zu, wie es dann in den Deklarationen erwartet wird. Abweichungen werden gemeldet. Im Dialog Einstellungen Statische Analyse: Metriken aktivieren Sie die für Sie relevanten Metriken. Mit dem Befehl Kognitive Komplexität für aktuellen Editor anzeigen werden die ermittelten Inkremente zeilengenau im aktiven Editor angezeigt. Mit dem Befehl Konstantenpropagation für aktuellen Editor anzeigen wird der Datenfluss im aktiven Editor im Detail analysiert und pfadgenau angezeigt. In Abhängigkeit davon sind Codeverbesserungen möglich. Für weitere Informationen siehe: Regeln, Metriken, Pragmas und Attribute" }, 
{ "title" : "Statische Codeanalyse konfigurieren und durchführen ", 
"url" : "_san_configuring_and_running.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Statische Codeanalyse konfigurieren und durchführen ", 
"snippet" : "Anhand eines einfachen Beispielprojekts finden Sie im Folgenden die wichtigsten Schritte und Möglichkeiten der Konfiguration und Durchführung einer statischen Codeanalyse. Voraussetzungen: CODESYS Static Analysis ist installiert....", 
"body" : "Anhand eines einfachen Beispielprojekts finden Sie im Folgenden die wichtigsten Schritte und Möglichkeiten der Konfiguration und Durchführung einer statischen Codeanalyse. Voraussetzungen: CODESYS Static Analysis ist installiert. " }, 
{ "title" : "Beispielprojekt ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-5b7b70fe166a598dc0a864631da88a82", 
"breadcrumbs" : "CODESYS Static Analysis \/ Statische Codeanalyse konfigurieren und durchführen \/ Beispielprojekt ", 
"snippet" : "Wenn Sie das Beispielprojekt nachprogrammieren wollen, legen Sie ein Standardprojekt an und fügen Sie die unten dargestellten Bausteine unterhalb der Applikation im Gerätebaum ein. Konfigurieren Sie danach die Kommunikationseinstellungen für die Verbindung zu Ihrem lokalen CODESYS Control Win . FUNC...", 
"body" : "Wenn Sie das Beispielprojekt nachprogrammieren wollen, legen Sie ein Standardprojekt an und fügen Sie die unten dargestellten Bausteine unterhalb der Applikation im Gerätebaum ein. Konfigurieren Sie danach die Kommunikationseinstellungen für die Verbindung zu Ihrem lokalen CODESYS Control Win . FUNCTION_BLOCK fb1\nVAR_INPUT\n iVar_fb1in1 : INT;\n ivar_fb1in2 : INT;\n rVar_fb1in3 : REAL;\nEND_VAR\nVAR_OUTPUT\n iVar_fb1out:INT;\nEND_VAR\nVAR\n P_fSampleProperty : INT;\n rVar : REAL;\n PRO : BOOL;\nEND_VAR\n iVar_fb1out:=iVar_fb1in1 + 1; FUNCTION_BLOCK fb2\nVAR_INPUT\n iVar_fb2in:INT;\nEND_VAR\nVAR_OUTPUT\n iVar_fb2out:INT;\nEND_VAR\nVAR\nEND_VAR\n iVar_fb2out:=iVar_fb2in - 1; PROGRAM PLC_PRG\nVAR\n fb1_inst: fb1;\n fb2_inst: fb2;\nEND_VAR fb1_inst(iVar_fb1in1 := 99);\nfb2_inst(iVar_fb2in := 22);\nfb2_inst(iVar_fb2in := 1); " }, 
{ "title" : "Einhaltung von Regeln überprüfen ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9641312f166a598dc0a864630126d291", 
"breadcrumbs" : "CODESYS Static Analysis \/ Statische Codeanalyse konfigurieren und durchführen \/ Einhaltung von Regeln überprüfen ", 
"snippet" : "Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wechseln Sie zur Registerkarte Regeln . Sie erhalten eine Auflistung aller möglichen Regelüberprüfungen. Sie sind in Baumstruktur in thematischen Kategorien angeordnet. Die „Regelnummer“ ist jeweils in runden Klammern hinzugefügt,...", 
"body" : "Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wechseln Sie zur Registerkarte Regeln . Sie erhalten eine Auflistung aller möglichen Regelüberprüfungen. Sie sind in Baumstruktur in thematischen Kategorien angeordnet. Die „Regelnummer“ ist jeweils in runden Klammern hinzugefügt, Beispiel: Nicht verwendete Variablen (33) in Kategorie Nicht verwendete Objekte auflisten . Klicken Sie mehrmals hintereinander in die Checkbox der ersten Zeile (Knoten Regeln ). Mit jedem Klick ändert sich der Zustand der Aktivierung. Die Checkboxen im gesamten Baum werden gleichzeitig entweder mit einem roten, orangen oder mit keinem Häkchen versehen. Aktivieren Sie auf diese Weise alle Einträge mit einem roten Häkchen. Dies bedeutet, dass CODESYS Static Analysis gefundene Regelverstöße als Fehler melden soll. Wählen Sie den Befehl Erstellen → Statische Analyse → Statische Analyse durchführen . Im Meldungsfenster werden Fehler ausgegeben. Die Meldungstexte sind mit einem gekennzeichnet und beginnen mit der Fehlernummer „SA<Regelnummer>“. Doppelklicken Sie auf die Meldung SA0033: Nicht verwendete Variable 'iVar_fb2out' . Der Fokus springt in den Deklarationsteil von Funktionsbaustein fb2 und die betreffende Variable wird selektiert. Die Variable ist deklariert, wird aber nicht verwendet. Dies wird mit der Regel 33 überprüft ( Nicht verwendete Variablen ). Im Code sind die betroffenen Stellen unterkringelt. Testen Sie die automatische Durchführung der Analyse: Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . In der Registerkarte Einstellungen aktivieren Sie die Option Statische Codenalyse automatisch nach dem Kompilieren ausführen . Schließen Sie den Dialog mit OK . Wählen Sie den Befehl Online → Einloggen . Eine Meldungsbox weist darauf hin, dass Übersetzungsfehler vorliegen. Im Meldungsfenster erscheinen wie vorher die von der Codeanalyse gemeldeten Fehler. Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wechseln Sie zur Registerkarte Regeln . Deaktivieren Sie nun im Dialog alle Regeln. Aktivieren Sie in Kategorie Nicht verwendete Objekte auflisten explizit die Regel SA0035 ( Nicht verwendete Eingabevariablen (35) ) mit einem orangefarbenen Häkchen, also zur Ausgabe einer „Warnung“. Sehen Sie sich den Tooltip zum Regeltext an: Diese Regel entspricht den folgenden PLCopen-Regeln: CP24 ). Schließen Sie den Dialog mit OK . Wählen Sie den Befehl Erstellen → Code erzeugen . Die Analyse wird automatisch ausgeführt. Im Meldungsfenster werden in der Kategorie Statische Analyse Meldungen 2 Fehler ausgegeben: § SA0035: Nicht verwendet: Eingang 'iVar_fb1in2 § SA0035: Nicht verwendet: Eingang 'iVar_fb1in3 Doppelklicken Sie jeweils auf die Meldung und kommentieren Sie die Deklaration aus oder entfernen Sie diese. Führen Sie die Codeanalyse erneut durch. Keine Fehlermeldungen. " }, 
{ "title" : "Einhaltung der definierten Namenskonventionen überprüfen ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-d64b88b5166a598dc0a864632e22b38d", 
"breadcrumbs" : "CODESYS Static Analysis \/ Statische Codeanalyse konfigurieren und durchführen \/ Einhaltung der definierten Namenskonventionen überprüfen ", 
"snippet" : "Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wechseln Sie zur Registerkarte Namenskonventionen . Sie sehen eine Tabelle in Baumstruktur, unterteilt in aufklappbare Kategorien von Variablen und Programmbausteinen. Klappen Sie die Kategorie Präfxe für Variablen - Präfixe für T...", 
"body" : "Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wechseln Sie zur Registerkarte Namenskonventionen . Sie sehen eine Tabelle in Baumstruktur, unterteilt in aufklappbare Kategorien von Variablen und Programmbausteinen. Klappen Sie die Kategorie Präfxe für Variablen - Präfixe für Typen auf: Tragen Sie für INT (14) in der Spalte Präfix ein i ein. Klappen Sie die Kategorie Präfixe für POUs - Präfixe für POU-Typ auf. Tragen Sie in der Spalte Präfix Folgendes ein: Bei PROGRAM (122) : prog , bei FUNCTIONBLOCK (103) : fb . Aktivieren Sie die Option Erstes Zeichen nach Präfix soll ein Großbuchstabe sein . Deaktivieren Sie alle anderen Optionen. Wählen Sie den Befehl Erstellen → Statische Analyse → Statische Analyse durchführen . Fehlermeldungen: NC0102: Ungültiger Name 'PLC_PRG': Erwartetes Präfix 'prog' , weil PLC_PRG nicht das geforderte Präfix hat Das erste Zeichen nach dem Präfix soll ein Großbuchstabe sein: 'ivar_fb1in2' , wegen ivar_fb1in2 : INT; in fb1 . NC0014: Ungültiger Variablenname P_fSampleProperty: Erwartetes Präfis 'i' , weil diese Integervariable nicht das geforderte Präfix hat. " }, 
{ "title" : "Symbole auf Zulässigkeit prüfen ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-7e83abe1166a598dc0a86463714e1dc5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Statische Codeanalyse konfigurieren und durchführen \/ Symbole auf Zulässigkeit prüfen ", 
"snippet" : "Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wechseln Sie zur Registerkarte Unzulässige Symbole . Ein Zeileneditor ermöglicht das Eintragen von Zeichenfolgen, die im Code nicht verwendet werden sollen. Doppelklicken Sie in die leere Zeile und tragen Sie als Beispiel die unzu...", 
"body" : "Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wechseln Sie zur Registerkarte Unzulässige Symbole . Ein Zeileneditor ermöglicht das Eintragen von Zeichenfolgen, die im Code nicht verwendet werden sollen. Doppelklicken Sie in die leere Zeile und tragen Sie als Beispiel die unzulässige Zeichenfolge PRO direkt ein. Doppelklicken Sie in die nächste leere Zeile und öffnen Sie über die Schaltfläche die Eingabehilfe. Wählen Sie aus Standardtypen den Typ REAL aus. Schließen Sie den Dialog mit OK . Wählen Sie den Befehl Erstellen → Statische Analyse → Statische Analyse durchführen . Im Meldungsfenster erscheinen die Fehlermeldungen Verbotenes Symbol 'REAL' und Verbotenes Symbol 'PRO' und Sie können mit Doppelklick auf den Meldungstext zur betreffenden Codestelle springen. " }, 
{ "title" : "Metriken anzeigen lassen ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Statische Codeanalyse konfigurieren und durchführen \/ Metriken anzeigen lassen ", 
"snippet" : "CODESYS Static Analysis nimmt von Ihnen ausgewählte Messungen am Code vor, und Sie können die Ergebnisse in einer Ansicht darstellen lassen. Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wechseln Sie zur Registerkarte Metriken . In einer Tabelle sehen Sie die von CODESYS Stat...", 
"body" : "CODESYS Static Analysis nimmt von Ihnen ausgewählte Messungen am Code vor, und Sie können die Ergebnisse in einer Ansicht darstellen lassen. Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wechseln Sie zur Registerkarte Metriken . In einer Tabelle sehen Sie die von CODESYS Static Analysis auf den Code anwendbaren Metriken. Aktivieren Sie für unser Beispiel die Metrik Anzahl Eingabevariablen und geben Sie den zulässigen Wertebereich an: Untergrenze 1 , Obergrenze 2 . Aktivieren Sie noch einige zusätzliche Metriken, wie beispielsweise Codegröße , Anzahl Aufrufe etc. Wählen Sie den Befehl Erstellen → Statische Analyse → Standard-Metriken anzeigen . Die Ansicht zeigt eine Tabelle mit je einer Zeile für jede Programmeinheit des Beispielprogramms. Für jede aktivierte Metrik gibt es eine Spalte, die die gemessenen Werte zeigt. Werte, die außerhalb des in den Einstellungen definierten Wertebereichs liegen, sind rot hinterlegt. Im Fall unseres konkreten Beispiels ist dies mindestens das Feld PLC_PRG\/Eingänge , weil in diesem Baustein die Anzahl der Eingabevariablen größer ist als die definierte Obergrenze 2 . " }, 
{ "title" : "Regelverletzungen im ST-Code schnell beheben ", 
"url" : "_san_fix_errors_quickly.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Regelverletzungen im ST-Code schnell beheben ", 
"snippet" : "Im Dialog Einstellungen Statische Analyse unter der Registerkarte Regeln können Sie für ST-Code Regeln aktivieren, deren Einhaltung auf Basis von Precompile-Informationen geprüft wird. Für das Auffinden solcher Regelverletzungen ist dabei kein expliziter Aufruf der statischen Codeanalyse nötig. Die ...", 
"body" : "Im Dialog Einstellungen Statische Analyse unter der Registerkarte Regeln können Sie für ST-Code Regeln aktivieren, deren Einhaltung auf Basis von Precompile-Informationen geprüft wird. Für das Auffinden solcher Regelverletzungen ist dabei kein expliziter Aufruf der statischen Codeanalyse nötig. Die Einhaltung der Regeln wird im aktiven ST-Editor während der Vorkompilierung und nach einer erfolgreichen Kompilierung geprüft. Wenn eine Regelverletzung auftritt, wird diese im ST-Editor sofort durch Unterringelung angezeigt. Zusätzlich erscheinen im Meldungsfenster in der Ansicht Vorkompilierung Fehlermeldungen oder Warnungen. Eine Anleitung dazu: Einhaltung der definierten Namenskonventionen überprüfenZur schnellen Fehlerbehandlung gelangen Sie dann entweder im ST-Editor mit Klick auf den unterringelten Code und dann auf das Glühbirnensymbol , oder über im Meldungsfenster über die Schaltfläche in der Fehlermeldungszeile. Jeweils erhalten Sie die passenden Befehle für eine Reaktion auf die Regelverletzung. Zur schnellen Fehlerbehebung (Quickfix) werden je nach Fehler folgende Befehle angeboten: Fehlermeldung\/Warnung ignorieren Der Befehl bewirkt, dass automatisch Pragmas oder Attribute in den Code eingefügt werden, die eine Prüfung der dazugehörigen Regel für diese Codezeile ausschließen. Fehlermeldung\/Warnung global für <programming objekt name> ignorieren Der Befehl bewirkt, dass automatisch ein Attribut an den Beginn des Deklarationsteils des Programmierobjekts eingefügt wird. Dann wird eine Prüfung der dazugehörigen Regel für dieses Programmierobjekt ausgeschlossen. Befehl mit einem Vorschlag, wie der ST-Code zu ändern ist, um die Regelverletzung zu vermeiden (Quickfix). Beispielsweise SA0168: Zuweisung ‚enum1 := 5‘ entfernen Prüfung ausschalten Der Befehl bewirkt, dass die Überprüfung der dazugehörigen Regel in den Einstellungen deaktiviert wird. Sie können die Auswirkungen, die der Aufruf eines der Befehle bewirkt hat, rückgängig machen. Klicken Sie dafür zunächst in die Ansicht Geräte (oder alternativ in die Ansicht POUs ). Dann wird der Befehl Undo aktiviert. " }, 
{ "title" : "Regeln aktivieren ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-1cca77b1336bf579c0a8646302e5e6f3", 
"breadcrumbs" : "CODESYS Static Analysis \/ Regelverletzungen im ST-Code schnell beheben \/ Regeln aktivieren ", 
"snippet" : "Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wechseln Sie zur Registerkarte Regeln . Sie erhalten eine Auflistung aller möglichen Regelüberprüfungen. Sie sind in Baumstruktur in thematischen Kategorien angeordnet. Die „Regelnummer“ ist jeweils in runden Klammern hinzugefügt....", 
"body" : "Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wechseln Sie zur Registerkarte Regeln . Sie erhalten eine Auflistung aller möglichen Regelüberprüfungen. Sie sind in Baumstruktur in thematischen Kategorien angeordnet. Die „Regelnummer“ ist jeweils in runden Klammern hinzugefügt. Sie können die Regeln filtern, nach Optionen sortieren oder als Liste darstellen. Klicken Sie auf den Filter Strukturierte Ansicht auf das Symbol und wählen Sie die Option Strukturiert nach dem Zeitpunkt der Ausführung . Die Regeln, die auch während der Vorkompilierung überprüft werden können, erscheinen unter dem Knoten Ausgeführt während der Vorkompilierung und nach einer erfolgreichen Kompilierung . Das sind die Regeln, die in der Spalte Vorkompilierung mit einem Haken gekennzeichnet sind. In der Spalte links daneben können Sie nun die Regel für die Prüfung aktivieren. Klicken Sie in der Zeile der Regel (168) auf das Kontrollkästchen, so dass der Zustand von „roter Haken“ nach „gelber Haken“ nach „kein Haken“ wechselt. Ein roter Haken bedeutet, dass die Regelverletzung als Fehlermeldung ausgegeben wird. Ein gelber Haken bedeutet, dass die Regelverletzung als Warnung ausgegeben wird. Kein Haken bedeutet, dass die Regel nicht überprüft wird. Die aktivierten Regeln werden nun überprüft und bei Verletzung im Code gekennzeichnet und im Meldungsfenster angezeigt. " }, 
{ "title" : "Regelverletzungen im Meldungsfenster anzeigen ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8f3e8ec3336bf579c0a86463654e2139", 
"breadcrumbs" : "CODESYS Static Analysis \/ Regelverletzungen im ST-Code schnell beheben \/ Regelverletzungen im Meldungsfenster anzeigen ", 
"snippet" : "Wählen Sie den Befehl Ansicht → Meldungen . Das Meldungsfenster öffnet sich. Wählen Sie im Meldungsfenster in der Auswahlliste die Kategorie Vorkompilierung . Nur in dieser Kategorie werden die Regelverletzungen angezeigt, die während der Vorkompilierung und nach einer erfolgreichen Kompilierung erm...", 
"body" : "Wählen Sie den Befehl Ansicht → Meldungen . Das Meldungsfenster öffnet sich. Wählen Sie im Meldungsfenster in der Auswahlliste die Kategorie Vorkompilierung . Nur in dieser Kategorie werden die Regelverletzungen angezeigt, die während der Vorkompilierung und nach einer erfolgreichen Kompilierung ermittelt wurden und die Sie dann mit Quickfix beheben können. Dazu erhalten Sie über die Schaltfläche die passenden Befehle. " }, 
{ "title" : "Schnelle Fehlerbehebung durchführen ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8a9adfb3336bf579c0a8646308d0b385", 
"breadcrumbs" : "CODESYS Static Analysis \/ Regelverletzungen im ST-Code schnell beheben \/ Schnelle Fehlerbehebung durchführen ", 
"snippet" : "In den Einstellungen ist die Regel 168 aktiviert und im ST-Editor wird eine Regelverletzungen angezeigt. Voraussetzung: Im ST-Code ist (mindestens) eine Zeile unterkringelt und im Meldungsfenster wird die dazugehörige SA-Nummer ausgegeben. Klicken Sie auf die unterkringelte Codezeile. Das Symbol ers...", 
"body" : "In den Einstellungen ist die Regel 168 aktiviert und im ST-Editor wird eine Regelverletzungen angezeigt. Voraussetzung: Im ST-Code ist (mindestens) eine Zeile unterkringelt und im Meldungsfenster wird die dazugehörige SA-Nummer ausgegeben. Klicken Sie auf die unterkringelte Codezeile. Das Symbol erscheint. Klicken Sie auf das Glühbirnen-Symbol. Ein Fenster mit Menübefehlen für die Fehlerbehandlung erscheint. Sie wollen den Fehler beheben. Wählen Sie deshalb den Befehl Zuweisung ‚enum1 := GVL.CONST‘ . Die Codezeile wird nun automatisch, so wie im Befehl angezeigt, geändert. Der Fehler ist behoben. Der dritte Befehl enthält einen Vorschlag, wie der Fehler durch eine Codeänderung gefixt werden kann, abhängig von der Regelverletzung. Die gleiche Fehlerbehandlung ist über einen Klick auf die Schaltfläche in der Fehlermeldungszeile im Meldungsfenster möglich. " }, 
{ "title" : "Überprüfung der Regel für eine Codezeile deaktivieren ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-107e44f0336bf579c0a8646347e7d5cc", 
"breadcrumbs" : "CODESYS Static Analysis \/ Regelverletzungen im ST-Code schnell beheben \/ Überprüfung der Regel für eine Codezeile deaktivieren ", 
"snippet" : "In den Einstellungen ist die Regel (168) aktiviert und im ST-Editor wird eine Regelverletzungen angezeigt. Voraussetzung: Im ST-Code ist (mindestens) eine Zeile unterkringelt und im Meldungsfenster wird die dazugehörige SA-Nummer ausgegeben. Klicken Sie auf in die unterkringelte Codezeile. Das Symbo...", 
"body" : "In den Einstellungen ist die Regel (168) aktiviert und im ST-Editor wird eine Regelverletzungen angezeigt. Voraussetzung: Im ST-Code ist (mindestens) eine Zeile unterkringelt und im Meldungsfenster wird die dazugehörige SA-Nummer ausgegeben. Klicken Sie auf in die unterkringelte Codezeile. Das Symbol erscheint. Klicken Sie auf das Glühbirnen-Symbol. Ein Fenster mit Menübefehlen für die Fehlerbehandlung erscheint. Sie wollen den Fehler nicht beheben. Deshalb wählen Sie den Befehl Fehlermeldung\/Warnung ignorieren . Die Codezeile wird nun automatisch mit Pragmas versehen. Die Pragmas bewirken, dass die Zeile für die betroffene Regel nicht mehr geprüft wird. Es wird keine Fehlermeldung oder Warnung ausgegeben. Den Befehl zum Deaktivieren der Regelprüfung für die betroffene Codezeile finden Sie auch über die Schaltfläche in der Fehlermeldungszeile im Meldungsfenster. " }, 
{ "title" : "Überprüfung der Regel für ein Programmierobjekt deaktivieren ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-6dee377f336bf579c0a8646357b65fa8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Regelverletzungen im ST-Code schnell beheben \/ Überprüfung der Regel für ein Programmierobjekt deaktivieren ", 
"snippet" : "In den Einstellungen ist die Regel 168 aktiviert und im ST-Editor wird eine Regelverletzungen angezeigt. Voraussetzung: Im ST-Code ist (mindestens) eine Zeile unterkringelt und im Meldungsfenster wird die dazugehörige SA-Nummer ausgegeben. Klicken Sie auf in die unterkringelte Codezeile. Das Symbol ...", 
"body" : "In den Einstellungen ist die Regel 168 aktiviert und im ST-Editor wird eine Regelverletzungen angezeigt. Voraussetzung: Im ST-Code ist (mindestens) eine Zeile unterkringelt und im Meldungsfenster wird die dazugehörige SA-Nummer ausgegeben. Klicken Sie auf in die unterkringelte Codezeile. Das Symbol erscheint. Klicken Sie auf die Glühbirne. Ein Fenster mit Menübefehlen für die Fehlerbehandlung erscheint. Sie wollen, dass das Programmierobjekt nicht auf die angegebene Regel überprüft wird. Deshalb wählen Sie den zweiten Befehl Fehlermeldung\/Warnung global für PLC_PRG ignorieren . Die Deklaration des Objekts wird nun automatisch mit einem Attribut versehen. Das Attribut bewirkt, dass für das Objekt die betroffene Regel nicht mehr geprüft wird. Es wird keine Fehlermeldung oder Warnung ausgegeben. Den Befehl zum Ignorieren der Meldung finden Sie auch über die Schaltfläche in der Fehlermeldungszeile im Meldungsfenster. " }, 
{ "title" : "Überprüfung der Regel generell deaktivieren ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Regelverletzungen im ST-Code schnell beheben \/ Überprüfung der Regel generell deaktivieren ", 
"snippet" : "In den Einstellungen ist die Regel 168 aktiviert und im ST-Editor wird eine Regelverletzungen angezeigt. Voraussetzung: Im ST-Code ist (mindestens) eine Zeile unterringelt und im Meldungsfenster wird die dazugehörige SA-Nummer ausgegeben. Klicken Sie auf in die unterkringelte Codezeile. Das Symbol e...", 
"body" : "In den Einstellungen ist die Regel 168 aktiviert und im ST-Editor wird eine Regelverletzungen angezeigt. Voraussetzung: Im ST-Code ist (mindestens) eine Zeile unterringelt und im Meldungsfenster wird die dazugehörige SA-Nummer ausgegeben. Klicken Sie auf in die unterkringelte Codezeile. Das Symbol erscheint. Klicken Sie auf die Glühbirne. Ein Fenster mit Menübefehlen für die Fehlerbehandlung erscheint. Sie wollen, dass die angezeigte Regel nicht mehr überprüft wird. Deshalb wählen Sie den vierten Befehl Prüfung ausschalten . In den Einstellungen der Statischen Analyse wird die Regel deaktiviert. Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wechseln Sie zur Registerkarte Regeln . Die Regel 168 ist deaktiviert. Den Befehl zum globalen Deaktivieren der Prüfung finden Sie auch über die Schaltfläche in der Fehlermeldungszeile im Meldungsfenster. " }, 
{ "title" : "Namenskonventionen definieren ", 
"url" : "_san_define_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Namenskonventionen definieren ", 
"snippet" : "Im Dialog Einstellungen Statische Analyse unter der Registerkarte Namenskonventionen definieren Sie die Namenskonventionen, denen Sie in Ihren Code folgen werden. Sie definieren Präfixe für die Bezeichner Ihrer Programmierbausteine, Variablen und Datentypen in Abhängigkeit von deren Gültigkeitsberei...", 
"body" : "Im Dialog Einstellungen Statische Analyse unter der Registerkarte Namenskonventionen definieren Sie die Namenskonventionen, denen Sie in Ihren Code folgen werden. Sie definieren Präfixe für die Bezeichner Ihrer Programmierbausteine, Variablen und Datentypen in Abhängigkeit von deren Gültigkeitsbereichen und Qualifizierern. Die Einhaltung der Namenskonventionen können Sie dann von der Statischen Analyse prüfen lassen. Eine Anleitung dazu: Einhaltung der definierten Namenskonventionen überprüfen" }, 
{ "title" : "Präfixe definieren ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-291ced2808fb693bc0a8646323d0819d", 
"breadcrumbs" : "CODESYS Static Analysis \/ Namenskonventionen definieren \/ Präfixe definieren ", 
"snippet" : "Im Dialog Einstellungen Statische Analyse unter der Registerkarte Namenskonventionen definieren Sie die Namenskonventionen im Eingabefeld der Spalte Präfix . Zeichenliteral Beispiel: PRG_ in Präfixe für POUs , Präfixe für POU-Typ , PROGRAM (102) Mehrere Literale pro Eintrag, die durch ein Komma sepa...", 
"body" : "Im Dialog Einstellungen Statische Analyse unter der Registerkarte Namenskonventionen definieren Sie die Namenskonventionen im Eingabefeld der Spalte Präfix . Zeichenliteral Beispiel: PRG_ in Präfixe für POUs , Präfixe für POU-Typ , PROGRAM (102) Mehrere Literale pro Eintrag, die durch ein Komma separiert werden Syntax: <prefix> ( , <next prefix> )* Beispiel: PRG_, PRG in Präfixe für POUs , Präfixe für POU-Typ , PROGRAM (102) Regulärer Ausdruck RegEx , der eine Menge von Präfixen definiert Syntax: @ <expression> Beispiele: @x[a-dA-D] definiert ein Präfix, das mit x beginnt, gefolgt von genau einem Zeichen des Bereichs a-dA-D @[A-Za-z][A-Za-z][A-Za-z][A-Za-z0-9] definiert ein Präfix, das aus 4 Zeichen besteht: die ersten 3 sind Buchstaben, das 4. Zeichen kann auch eine Ziffer sein " }, 
{ "title" : "Für kombinierbare Datentypen Präfixe definieren ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e9a24404c19ad708c0a86463215af896", 
"breadcrumbs" : "CODESYS Static Analysis \/ Namenskonventionen definieren \/ Für kombinierbare Datentypen Präfixe definieren ", 
"snippet" : "Folgende Datentypen basieren auf Standarddatenypen, bestehenden Datentypen oder Funktionsbausteinen: Pointer : POINTER TO <basic type> Referenz: REFERENCE TO <basic type> Array: ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> Diese Datentypen können verschachtelt und gegenseitig ...", 
"body" : "Folgende Datentypen basieren auf Standarddatenypen, bestehenden Datentypen oder Funktionsbausteinen: Pointer : POINTER TO <basic type> Referenz: REFERENCE TO <basic type> Array: ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> Diese Datentypen können verschachtelt und gegenseitig kombiniert werden. Wenn die Option Rekursive Präfixe für kombinierbare Datentypen aktiviert ist, erwartet die Statische Analyse bei Variablen solcher kombinierbarer Datentypen rekursiv zusammengesetzte Präfixe. Die Präfixe folgen der Deklaration und entsprechen den Namenskonventionen, die für die Basisdatentypen vereinbart wurden. Beispiel Folgende Namenskonventionen wurden gesetzt: i in Präfixe für Variablen , INT (26) p in Präfixe für Variablen , POINTER (26) ref in Präfixe für Variablen , REFERENCE (27) struct in Präfixe für Variablen , Struktur (32) Option Rekursive Präfixe für kombinierbare Datentypen : Der folgende Code verletzt Namenskonventionen und ist schwer lesbar. PROGRAM plc1\nVAR\n var1 : ARRAY[100..110] OF ARRAY[30..50] OF ARRAY[6..7] OF BOOL;\n var2 : ARRAY[1..3] OF INT;\n var3 : REFERENCE TO INT;\n iVar4 : INT;\n iVar5 : INT;\n var6 : ARRAY[1..3] OF INT := [11, 22, 33];\n var7 : POINTER TO ARRAY[1..3] OF INT;\n var8 : REFERENCE TO INT;\n var9 : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n var0 : ARRAY[0..3] OF S_POLYGONLINE; \/\/ S_POLYGONLINE is a already defined structure\nEND_VAR\n\niVar4 := iVar4 + 1;\nvar8 REF= iVar4;\nvar1[100][30][6] := TRUE;\nvar9.aiPoint1[1] := 99;\nvar7 := ADR(var6);\nvar6[2] := 44;\niVar5 := var7^[2];\nvar0[0] := var9; Die Statische Analyse meldet folgende Verletzungen der Namenskonventionen: NC0102: Ungültiger Name ‚plc1‘: Erwartetes Präfix ‚PRG_‘ NC0014: Ungültiger Variablenname ‚var0‘: Erwartetes Präfix ‚astruct‘ NC0014: Ungültiger Variablenname ‚var1‘: Erwartetes Präfix ‚aaax‘ NC0014: Ungültiger Variablenname ‚var2‘: Erwartetes Präfix ‚ai‘ NC0014: Ungültiger Variablenname ‚var3‘: Erwartetes Präfix ‚refi‘ NC0014: Ungültiger Variablenname ‚var6‘: Erwartetes Präfix ‚ai‘ NC0014: Ungültiger Variablenname ‚var7‘: Erwartetes Präfix ‚pai‘ NC0014: Ungültiger Variablenname ‚var8‘: Erwartetes Präfix ‚refi‘ NC0014: Ungültiger Variablenname ‚var9‘: Erwartetes Präfix ‚struct‘ " }, 
{ "title" : "Für Variablen eines Alias Präfixe definieren ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9f66c39a945e11eab0a0b46479d263a5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Namenskonventionen definieren \/ Für Variablen eines Alias Präfixe definieren ", 
"snippet" : "Sie können Präfixe für Variablen des Datentyps Alias als Literal mit dem Platzhalter {datatype} definieren. Dann erwartet die Statische Analyse an Stelle des Platzhalters das Präfix des Basisdatentyps. Die Option Namensraumpräfix mit Datentyppräfix kombinieren hat keinen Einfluss auf die Verwendung ...", 
"body" : "Sie können Präfixe für Variablen des Datentyps Alias als Literal mit dem Platzhalter {datatype} definieren. Dann erwartet die Statische Analyse an Stelle des Platzhalters das Präfix des Basisdatentyps. Die Option Namensraumpräfix mit Datentyppräfix kombinieren hat keinen Einfluss auf die Verwendung des Präfixes {datatype} . Beispiel Folgende Namenskonventionen wurden gesetzt: s in Präfixe für Variablen , Präfixe für Typen , STRING()19 A_{datatype} in Präfixe für Variablen , Alias (33) Code TYPE A_MESSAGE : STRING[50]; \/\/ base data type is STRING\nEND_TYPE\n\nVAR\n A_sMessage_N1 : A_MESSAGE := 'Robot is running.';\n A_s_Message_N2 : A_MESSAGE := 'Robot has been finished.';\n As_Message_N3 : A_MESSAGE := 'Robot has been stopped.';\n AsMessage_N4 : A_MESSAGE := 'Error 3 has been occured.';\nEND_VAR Die Statische Analyse meldet folgende Verletzung der Namenskonvention: NC0033: Ungültiger Variablenname ‚‘As_Message_N3‘: Erwartetes Präfix ‚A_s‘ NC0033: Ungültiger Variablenname ‚AsMessage_N4‘: Erwartetes Präfix ‚A_s‘‘ " }, 
{ "title" : "Für Eigenschaften Präfixe definieren ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e0cda739c19ad708c0a864636e955ca0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Namenskonventionen definieren \/ Für Eigenschaften Präfixe definieren ", 
"snippet" : "Sie können das Präfix für Bausteine (POUs) des Datentyps PROPERTY als ein Literal mit dem Platzhalter {datatype} definieren. Dann erwartet die Statische Analyse an Stelle des Platzhalters das Präfix des Rückgabedatentyps der Eigenschaft. Die Option Namensraumpräfix mit Datentyppräfix kombinieren hat...", 
"body" : "Sie können das Präfix für Bausteine (POUs) des Datentyps PROPERTY als ein Literal mit dem Platzhalter {datatype} definieren. Dann erwartet die Statische Analyse an Stelle des Platzhalters das Präfix des Rückgabedatentyps der Eigenschaft. Die Option Namensraumpräfix mit Datentyppräfix kombinieren hat keinen Einfluss auf die Verwendung des Platzhalters {datatype} . Beispiel Folgende Namenskonventionen wurden gesetzt: fb in Präfixe für Variablen , Präfixe für Typen , Funktionsbausteininstanz FB_ in Präfixe für POUs , Präfixe für POU-Typ , FUNCTIONBLOCK (103) prop_{datatype} in Präfixe für POUs , Präfixe für POU-Typ , PROPERTY (107) Code FUNCTION_BLOCK blocka \/\/ Invalid function block name\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC vara : INT \/\/ Invalid property name, return data type is INT\nGet\n vara := iA;\nSet\niA := vara;\n\nPROGRAM plc1\nVAR\n var10 : blocka; \/\/ Invalid variable name of typ function block\n iVar11: INT;\nEND_VAR\n\nvar10();\nIF var10.vara > 500 THEN\n var10.vara := 0;\nEND_IF\niVar11 := var10.vara; Die Statische Analyse meldet folgende Verletzung der Namenskonventionen: NC0102: Ungültiger Name ‚‘plc1‘: Erwartetes Präfix ‚PRG_‘‘ NC0031: Ungültiger Variablenname ‚‘var10‘: Erwartetes Präfix ‚‘fb‘‘ NC0103: Ungültiger Variablenname ‚‘blocka‘: Erwartetes Präfix ‚FB_‘‘ NC0107: Ungültiger Variablenname ‚blocka.vara‘: Erwartetes Präfix ‚prop_i‘‘ Code gemäß Namenskonventionen FUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC prop_iA : INT\nGet\n prop_iA := iA;\nSet\n iA := prop_iA;\n\nPROGRAM PRG_PLC1\nVAR\n fbA : FB_A;\n iVar11: INT;\nEND_VAR\n\nfbA();\nIF fbA.prop_iA > 500 THEN\n fbA.prop_iA := 0;\nEND_IF\niVar11 := fbA.prop_iA; " }, 
{ "title" : "Für Strukturen Präfixe definieren ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-ed64228609104c08c0a864630c58c86b", 
"breadcrumbs" : "CODESYS Static Analysis \/ Namenskonventionen definieren \/ Für Strukturen Präfixe definieren ", 
"snippet" : "Sie können im Projekt für Strukturen ein allgemeinen Präfix unter Präfixe für DUTs , Struktur (151) definieren. Daneben können Sie eine Struktur mit einem speziellen Präfix versehen. Das spezielle Präfix verschattet dann das allgemeine Präfix. Das spezielle Präfix wird in der Datentypdeklaration der...", 
"body" : "Sie können im Projekt für Strukturen ein allgemeinen Präfix unter Präfixe für DUTs , Struktur (151) definieren. Daneben können Sie eine Struktur mit einem speziellen Präfix versehen. Das spezielle Präfix verschattet dann das allgemeine Präfix. Das spezielle Präfix wird in der Datentypdeklaration der Struktur mit dem Pragma {attribute 'nameprefix' := <special prefix> '} definiert. Beginnen Sie daraufhin alle Variablen dieser Struktur mit diesem Präfix <special prefix> . Beispiel Folgende Namenskonventionen wurden gesetzt: struct in Präfixe für Variablen , Struktur(32) S_ in Präfixe für DUTs , Struktur (151) Rekursive Präfixe für kombinierbare Datentypen : Code TYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE\n\n{attribute 'nameprefix' := 'penta'} \/\/ Pragma to define a special prefix\nTYPE S_PENTA EXTENDS S_POLYGONLINE :\nSTRUCT\n aiPoint5 : ARRAY[1..2] OF INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PRG_Compute\nVAR\n structPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n structPentagon : S_PENTAGON := (aiStart:=[0,0], aiPoint1:=[1,1], aiPoint2:=[2,2], aiPoint3:=[3,3], aiPoint4:=[4,4], aiPoint5:=[5,5]);\n structLine0 : S_PENTA;\n pentaLine1 : S_PENTA;\n iXPoint: INT;\n aPoint0: ARRAY [1..2] OF INT;\n aPoint1: ARRAY [1..2] OF INT;\nEND_VAR\n\niXPoint := structPolygon.aiPoint1[1];\naPoint0 := structLine0.aiEnd;\naiPoint1 := pentaLine1.aiEnd; Die Statische Analyse meldet folgende Verletzung der Namenskonventionen: Ungültiger Variablenname ‚structLine0‘: Erwartetes Präfix ‚penta‘ " }, 
{ "title" : "Weiteren CODESYS Static Analysis -Projekten Namenskonventionen zur Verfügung stellen ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Namenskonventionen definieren \/ Weiteren CODESYS Static Analysis -Projekten Namenskonventionen zur Verfügung stellen ", 
"snippet" : "Speichern Sie Ihre Namenskonventionen in einer CSA-Datei. Diese Datei können Sie in anderen CODESYS Static Analysis -Projekten laden und verwenden. In Datei speichern Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wählen Sie die Schaltfläche Speichern . Ein Dateiauswahldialog ...", 
"body" : "Speichern Sie Ihre Namenskonventionen in einer CSA-Datei. Diese Datei können Sie in anderen CODESYS Static Analysis -Projekten laden und verwenden. In Datei speichern Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wählen Sie die Schaltfläche Speichern . Ein Dateiauswahldialog öffnet sich. Dort können Sie die Namenkonventionen in einer Datei unter einem beliebigen Namen mit Dateiendung CSA ablegen. Datei mit Namenskonventionen laden Wählen Sie den Befehl Erstellen → Statische Analyse → Einstellungen . Wählen Sie die Schaltfläche Laden . Der Dateiauswahldialog öffnet sich. Wählen Sie unter den angezeigten CSA-Dateien eine aus. " }, 
{ "title" : "Codeklone finden ", 
"url" : "_san_find_code_clone.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Codeklone finden ", 
"snippet" : "Voraussetzungen: CODESYS Static Analysis ist installiert. Ein CODESYS -Projekt ist geöffnet. Das Projekt enthält in mindestens zwei Programmierobjekten einen gleichen Codeblock. Wählen Sie den Befehl Erstellen → Statische Analyse → Klone finden . Die Ansicht Ergebnisse Klonsuche öffnet sich. Klicken...", 
"body" : "Voraussetzungen: CODESYS Static Analysis ist installiert. Ein CODESYS -Projekt ist geöffnet. Das Projekt enthält in mindestens zwei Programmierobjekten einen gleichen Codeblock. Wählen Sie den Befehl Erstellen → Statische Analyse → Klone finden . Die Ansicht Ergebnisse Klonsuche öffnet sich. Klicken Sie auf Ergebnisse . In einem Fenster werden die gefundenen Codeklone als Baumansicht dargestellt. Wenn es neben identischen Codeklonen auch Codeklone mit Abweichungen gibt, sind diese Kindknoten in der Baumansicht farblich hervorgehoben. Selektieren Sie in der Baumansicht zwei Codeklone eines Kindknotens und klicken Sie auf die Schaltfläche Selektierte Klone anzeigen . Die zwei Programmierobjekte, die diesen duplizierten Code enthalten, werden im Editor geöffnet und im oberen Bereich der Ansicht angezeigt. Die identischen Codeklone sind hellgelb markiert und die Codeklone mit Abweichungen, wie hier im Beispiel die Variablennamen ivar3 und ivarx , sind farblich rot hervorgehoben. Um aus dem identischen Codeklon des Programmierobjekts POU_1 eine Funktion zu erstellen, doppelklicken Sie zunächst in der Baumansicht die Zeile mit dem Codeklon von Objekt POU_1 . Das Programmierobjekt POU_1 öffnet sich im Editor und im Implementierungsteil sind die vier Zeilen markiert, die den duplizierten Code enthalten. Wenn Sie im Kontextmenü des markierten Codeblocks den Befehl Funktion extrahieren auswählen, wird der Codeblock aus POU_1 extrahiert und daraus eine neue Methode erstellt. Der Codeblock im Implementierungsteil von POU_1 wird automatisch durch den Aufruf der Methode ersetzt. Im zweiten Programmierobjekt müssen Sie das Codeduplikat manuell entfernen und durch den Aufruf der Methode ersetzen. In einer späteren Version wird die Funktionalität so erweitert, dass aus beiden Progammierobjekten der duplizierte Codeblock automatisch extrahiert und durch den korrekten Funktionsaufruf ersetzt werden kann. " }, 
{ "title" : "Konstantenpropagation ", 
"url" : "_san_constant_propagation.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Konstantenpropagation ", 
"snippet" : "Mit der CODESYS Static Analysis Version V5.0.0.0 basiert die statische Codeanalyse auf Konstantenpropagation. Die Ergebnisse der Konstantenpropagation werden für verschiedene Überprüfungen genutzt. So wird beispielsweise überprüft, ob Pointer ungleich 0 sind, oder ob Arrayindindizes außerhalb des gü...", 
"body" : "Mit der CODESYS Static Analysis Version V5.0.0.0 basiert die statische Codeanalyse auf Konstantenpropagation. Die Ergebnisse der Konstantenpropagation werden für verschiedene Überprüfungen genutzt. So wird beispielsweise überprüft, ob Pointer ungleich 0 sind, oder ob Arrayindindizes außerhalb des gültigen Bereichs liegen. Sie können die statische Analyse effektiv unterstützen, allein wenn sie wissen, wie diese Analyse funktioniert und wo ihre Grenzen liegen. " }, 
{ "title" : "Konstantenpropagation ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078132035233833484992758", 
"breadcrumbs" : "CODESYS Static Analysis \/ Konstantenpropagation \/ Konstantenpropagation ", 
"snippet" : "Bei der statischen Analyse wird versucht, den Wert einer Variable anhand ihrer Verwendung zu bestimmen. Beispiel PROGRAM PLC_PRG \/\/Declaration VAR x: INT; bTest: BOOL; END_VAR \/\/Implementation x := 99; IF x < 100 THEN bTest := TRUE; END_IF In der Implementierung in Zeile 1 zeichnet die Konstantenpro...", 
"body" : "Bei der statischen Analyse wird versucht, den Wert einer Variable anhand ihrer Verwendung zu bestimmen. Beispiel PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT;\n bTest: BOOL;\nEND_VAR \/\/Implementation\nx := 99;\nIF x < 100 THEN\n bTest := TRUE;\nEND_IF In der Implementierung in Zeile 1 zeichnet die Konstantenpropagation den Wert 99 für die Variable x , um diesen Wert für weitere Analysen zu verwenden. Die Analyse erkennt dann, dass der Ausdruck in der nachfolgenden IF -Anweisung konstant TRUE ist. " }, 
{ "title" : "Lokal durchgeführte Konstantenpropagation ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4525765239721633833551650952", 
"breadcrumbs" : "CODESYS Static Analysis \/ Konstantenpropagation \/ Konstantenpropagation \/ Lokal durchgeführte Konstantenpropagation ", 
"snippet" : "Ein Wert wird nur lokal im Baustein ermittelt. Es ist unerheblich, wie eine Eingabe übergeben wird. Auch die Ergebnisse von Funktionsaufrufen sind irrelevant. Beispiel FUNCTION Func : BOOL \/\/Declaration VAR_INPUT bText : BOOL; END_VAR \/\/Implementation IF bTest THEN Func := OtherFunc(TRUE); END_IF We...", 
"body" : "Ein Wert wird nur lokal im Baustein ermittelt. Es ist unerheblich, wie eine Eingabe übergeben wird. Auch die Ergebnisse von Funktionsaufrufen sind irrelevant. Beispiel FUNCTION Func : BOOL\n\/\/Declaration\nVAR_INPUT\n bText : BOOL;\nEND_VAR \/\/Implementation\nIF bTest THEN\n Func := OtherFunc(TRUE);\nEND_IF Wenn der Parameter bTest bei jedem Aufruf auf TRUE gesetzt wird, hat dies keine Auswirkung auf die Konstantenpropagation. Auch wenn OtherFunc(TRUE) immer TRUE zurück gibt, hat dies keine Auswirkung auf die Konstantenpropagation. " }, 
{ "title" : "Nur temporäre Variablen haben Initialwerte ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505885763755233833526533567", 
"breadcrumbs" : "CODESYS Static Analysis \/ Konstantenpropagation \/ Konstantenpropagation \/ Nur temporäre Variablen haben Initialwerte ", 
"snippet" : "Statische lokale Variablen in Programmen und Funktionsbausteinen haben keinen angenommenen Initialwert. Die Variablen behalten ihre Werte vom letzten Aufruf und können daher prinzipiell \"alles\" sein. Lokale Variablen in Funktionen und temporäre Variablen haben einen Initialwert bei jedem Aufruf. Die...", 
"body" : "Statische lokale Variablen in Programmen und Funktionsbausteinen haben keinen angenommenen Initialwert. Die Variablen behalten ihre Werte vom letzten Aufruf und können daher prinzipiell \"alles\" sein. Lokale Variablen in Funktionen und temporäre Variablen haben einen Initialwert bei jedem Aufruf. Die Konstantenpropagation rechnet mit diesem Initialwert. Beispiel PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT := 6;\n bTest: BOOL;\nEND_VAR\nVAR_TEMP\n y : INT := 8;\nEND_VAR bText := x < y; Die Variable y wird bei jeder Ausführung von PLC_PRG den Wert 8 haben. Die Variable x jedoch nicht unbedingt. Daher wird die Konstantenpropagation nur für y einen Wert annehmen, nicht aber für x . Es empfiehlt sich, Variablen, die immer zuerst geschrieben und dann gelesen werden, als temporäre Variablen zu deklarieren. " }, 
{ "title" : "Konstantenpropagation ermittelt Wertebereiche für numerische Datentypen ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078129465633833541363136", 
"breadcrumbs" : "CODESYS Static Analysis \/ Konstantenpropagation \/ Konstantenpropagation \/ Konstantenpropagation ermittelt Wertebereiche für numerische Datentypen ", 
"snippet" : "Um die Komplexität zu reduzieren, wird für jede Variable ein Wertebereich mit Ober- und Untergrenze ermittelt. Beispiel PROGRAM PLC_PRG VAR x: INT := 6; bTest: BOOL; y : INT; END_VAR \/\/Implementation IF bTest THEN x := 1; ELSSE x := 100; END_IF IF x = 77 THEN y := 13; END_IF Hier wird für die Variab...", 
"body" : "Um die Komplexität zu reduzieren, wird für jede Variable ein Wertebereich mit Ober- und Untergrenze ermittelt. Beispiel PROGRAM PLC_PRG\nVAR\n x: INT := 6;\n bTest: BOOL;\n y : INT; \nEND_VAR\n \/\/Implementation\nIF bTest THEN\n x := 1;\nELSSE\n x := 100;\nEND_IF\nIF x = 77 THEN\n y := 13;\nEND_IF Hier wird für die Variable x der Wertebereich [1..100] ermittelt. Infolgedessen wird in Zeile 7 der Vergleich x = 77 nicht als konstanter Ausdruck erkannt, da 77 innerhalb des Wertebereichs liegt. " }, 
{ "title" : "Wiederkehrende komplexe Ausdrücke werden nicht als die gleiche Variable erkannt ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4581954142281633833566535545", 
"breadcrumbs" : "CODESYS Static Analysis \/ Konstantenpropagation \/ Konstantenpropagation \/ Wiederkehrende komplexe Ausdrücke werden nicht als die gleiche Variable erkannt ", 
"snippet" : "Komplexe Ausdrücke haben unter Umständen keinen Wert zugeordnet. Wenn solche Ausdrücke mehrfach vorkommen, ist es hilfreich, eine Hilfsvariable einzuführen. Beispiel PROGRAM PLC_PRG VAR x: DINT; py : POINTER TO INT; y : INT; testArray : ARRAY [0..4] OF DINT; END_VAR \/\/Implementation IF py^ >= 0 AND ...", 
"body" : "Komplexe Ausdrücke haben unter Umständen keinen Wert zugeordnet. Wenn solche Ausdrücke mehrfach vorkommen, ist es hilfreich, eine Hilfsvariable einzuführen. Beispiel PROGRAM PLC_PRG\nVAR\n x: DINT;\n py : POINTER TO INT;\n y : INT; \n testArray : ARRAY [0..4] OF DINT; \nEND_VAR\n \/\/Implementation\nIF py^ >= 0 AND py^<= 4 THEN\n x := testArray[py^];\nEND_IF\ny := py^;\nIF y <= 0 AND y <=4 THEN\n x := testArray[y];\nEND_IF In Zeile 2 wird ein Fehler ausgegeben für einen möglichen Zugriff über Pointer auf einen Wert, obwohl der Bereich, auf den der Pointer zeigt, überprüft wird. Wird der Wert zuerst in eine lokale Variable kopiert und deren Bereich überprüft, dann kann die Konstantenpropagation den Wertebereich für diese Variable ermitteln und erlaubt den Zugriff in den Array in Zeile 7. " }, 
{ "title" : "Verzweigungen ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078204272033833577361725", 
"breadcrumbs" : "CODESYS Static Analysis \/ Konstantenpropagation \/ Konstantenpropagation \/ Verzweigungen ", 
"snippet" : "Bei Verzweigungen werden einzelne Zweige getrennt berechnet. Wertebereiche aus den einzelnen Bereichen werden anschließend zu einem neuen Wertebereich vereinigt. Beispiel \/\/Implementation IF func(TRUE) THEN x := 1; ELSE x := 10; END_IF IF func(FALSE) THEN y := x; ELSE Y := 2*x; END_IF In Zeile 6 hat...", 
"body" : "Bei Verzweigungen werden einzelne Zweige getrennt berechnet. Wertebereiche aus den einzelnen Bereichen werden anschließend zu einem neuen Wertebereich vereinigt. Beispiel \/\/Implementation\nIF func(TRUE) THEN\n x := 1;\nELSE \n x := 10;\nEND_IF\n\nIF func(FALSE) THEN\n y := x;\nELSE\n Y := 2*x;\nEND_IF In Zeile 6 hat x den Bereich [1..10] . Nach Zeile 11 hat y den Wertebereich [1..20] , das ergibt sich aus der Vereinigung der beiden Wertebereiche [1..10] und [2..20] . " }, 
{ "title" : "Bedingungen ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505886343398433833583258632", 
"breadcrumbs" : "CODESYS Static Analysis \/ Konstantenpropagation \/ Konstantenpropagation \/ Bedingungen ", 
"snippet" : "Beispiel Bedingungen können den Wertebereich einer Variablen in einem Codeblock einschränken. Mehrere Bedingungen können kombiniert werden. Einander ausschließende Bedingungen können auch zu einem leeren Wertebereich führen. IF y > 0 AND y < 10 THEN x := y; ELSE x:= 0; END_IF IF x < 0 THEN i := 99; ...", 
"body" : "Beispiel Bedingungen können den Wertebereich einer Variablen in einem Codeblock einschränken. Mehrere Bedingungen können kombiniert werden. Einander ausschließende Bedingungen können auch zu einem leeren Wertebereich führen. IF y > 0 AND y < 10 THEN\n x := y;\nELSE\n x:= 0;\nEND_IF\nIF x < 0 THEN\n i := 99;\nEND_IF y hat in Zeile 2 den Wertebereich [1..9] . Daraus ergibt sich für x in Zeile 6 der Wertebereich [0..9] . Kombiniert mit der Bedingung x < 0 ergibt das in Zeile 8 für x eine leere Menge an möglichen Werten. Der Code ist nicht erreichbar. Die statische Analyse wird melden, dass die Bedingung x < 0 an dieser Stelle immer FALSE ergibt. " }, 
{ "title" : "Schleifen ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4649940201660833833593476437", 
"breadcrumbs" : "CODESYS Static Analysis \/ Konstantenpropagation \/ Konstantenpropagation \/ Schleifen ", 
"snippet" : "Die Konstantenpropagation wird Schleifen im Code so lange ausführen, bis sich die Werte der Variablen in der Schleife nicht mehr ändern. Dabei wird angenommen, dass eine Schleife beliebig oft durchlaufen werden kann. Die bisher ermittelten Werte werden mit den vorhergehenden Werten vereint. Variable...", 
"body" : "Die Konstantenpropagation wird Schleifen im Code so lange ausführen, bis sich die Werte der Variablen in der Schleife nicht mehr ändern. Dabei wird angenommen, dass eine Schleife beliebig oft durchlaufen werden kann. Die bisher ermittelten Werte werden mit den vorhergehenden Werten vereint. Variablen, die innerhalb der Schleife geändert werden, haben einen sukzessiv wachsenden Bereich. Dabei nimmt die Konstantenpropagation nicht alle möglichen Werte für Bereiche an, sondern verwendet nur im Code vorkommende Grenzen und außerdem die Werte 0, 1, 2, 3 und 10, da diese häufig eine Rolle spielen. Beispiel Am einfachsten wird das Vorgehen an einem Beispiel deutlich: PROGRAM PLC_PRG\nVAR\n x: DINT;\n i : DINT;\n y : DINT;\nEND_VAR \/\/Implementation\nx := 0;\ny := 0;\nFOR i := 0 TO 5 DO\n x := x + 1;\n y := i;\nEND_FOR Die Konstantenpropagation weiß folgendes über die Schleife: i , x , und y sind zu Beginn der ersten Ausführung der Schleife 0. Für den Code in der Schleife gilt die Bedingung i <= 5 . Für den Code nach der Schleife gilt die Bedingung i > 5 . Für die Werte der Variablen in der Schleife ermittelt die Konstantenpropagation folgende Werte: i x y [0..5] [0..MAXDINT] [0..5] Im Detail werden folgende Zwischenschritte durchlaufen: Durchlauf i x y 1 0 [0..1] 0 i wurde mit 0 initialisiert, y bekommt immer die gleichen Werte wie i 2 [0..1] [0..2 ] [0..1] 6 [0..5] [0..6] [0..5] Zunächst wird tatsächlich der Bereich [0..6] für i berechnet. Es ist aber bekannt, dass i < 5 eine Bedingung ist. Daher wird der Wert für den Code in der Schleife auf diesen Wert begrenzt. 7 [0..5] [0..7] [0..5] 10 [0..5] [0..10] [0..5] x wird immer weiter hochgezählt. Ab 10 wird allerdings der Wert auf MAXINT \"aufgerundet\". 11 [0..5] [0..MAXDINT] [0..5] MAXDINT + 1 ergibt MAXDINT ab 11 Ab dem 11. Durchlauf werden sich die Werte in der Schleife nicht mehr ändern. Die Propagation wird beendet. Darüber hinaus gilt für den nach dieser Schleife folgenden Code i = 6 . Es wird in der Schleife der Bereich [0..6] ermittelt und dieser mit der Bedingung i > 5 kombiniert, was exakt den Wert 6 ergibt. " }, 
{ "title" : "Referenz: Benutzeroberfläche ", 
"url" : "_san_f_reference_user_interface.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehle ", 
"url" : "_san_struct_reference_commands.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Funktion extrahieren ", 
"url" : "_san_cmd_extract_function.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Funktion extrahieren ", 
"snippet" : "Funktion extrahieren Funktion : Der Befehl öffnet den Dialog Konfiguration für Funktionsextraktion . Der Befehl extrahiert aus dem ST-Editor ausgewählte Codestellen und erstellt daraus eine neue Methode oder Funktion, die diesen Code enthält. Der betroffene Code im ST-Editor wird durch einen korrekt...", 
"body" : "Funktion extrahieren Funktion : Der Befehl öffnet den Dialog Konfiguration für Funktionsextraktion . Der Befehl extrahiert aus dem ST-Editor ausgewählte Codestellen und erstellt daraus eine neue Methode oder Funktion, die diesen Code enthält. Der betroffene Code im ST-Editor wird durch einen korrekten Aufruf ersetzt. Wenn Code aus einem Funktionsbaustein oder dem Kind eines Funktionsbausteins extrahiert wird, wird aus dem Code eine neue Methode erstellt. Wenn Code aus einem Programm oder einer Funktion extrahiert wird, wird aus dem Code eine neue Funktion erstellt. Beachten Sie in diesem Zusammenhang auch: Codeklone findenAufruf : Kontextmenü Refactoring Voraussetzungen , wenn der selektierte Code aus einer oder mehreren Anweisungen besteht: Der selektierte Code enthält keine Übersetzungsfehler Der selektierte Code befindet sich im Implementierungsteil eines ST-Programmierbausteins Der selektierte Code enthält keine ausgehenden Sprünge Beispiele für ausgehende Sprünge sind: Verlassen der umgebenden Funktion mit RETURN Verlassen einer den Code umgebenden Schleife mit CONTINUE oder EXIT Sie können die durch den Befehl Funktion extrahieren entstandenen Änderungen in Ihrem Projekt wieder rückgängig machen, indem Sie den Cursor im Gerätebaum positionieren und den Befehl Bearbeiten → Rückgängig wählen. Dialog Konfiguration für Funktionsextraktion Name Name für die neu erstellte Funktion oder Methode Der standardmäßig eingetragene Name kann geändert werden. Rückgabewert Festlegung des Rückgabewerts einer Funktion, wenn es mehrere Ausgabe- und\/oder Eingabe-\/Ausgabeparameter gibt Parameter Anzeige der zur Verfügung stehenden POUs Konfiguration, ob die Parameter als Eingabe-, Ausgabe-, oder Eingabe-\/Ausgabevariablen verwendet werden : Eingabevariablen : Ausgabevariablen : Eingabe-\/Ausgabevariablen Die bei Name , Rückgabewert oder Parameter durchgeführten Änderunge werden rückgängig gemacht. Oberes Codefenster Neu erstellter Code der Aufrufstelle Unteres Codefenster Neu erstellter Code der Funktion oder der Methode OK Die angezeigten Codeänderungen werden in die ST-Bausteine übernommen und der Dialog wird geschlossen. Abbrechen Die angezeigten Codeänderungen werden verworfen und der Dialog wird geschlossen. " }, 
{ "title" : "Befehl: IF-Anweisung invertieren ", 
"url" : "_san_cmd_invert_if_statement.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: IF-Anweisung invertieren ", 
"snippet" : "IF-Anweisung invertieren Funktion : Dieser Befehl invertiert die IF -Anweisung, ohne die Semantik der IF -Anweisung zu ändern. Die Bedingung wird negiert. Die Anweisungen in den Zweigen THEN und ELSE werden vertauscht. Alle Kommentare bleiben erhalten. Aufruf : Kontextmenü unter Befehl Refactoring V...", 
"body" : "IF-Anweisung invertieren Funktion : Dieser Befehl invertiert die IF -Anweisung, ohne die Semantik der IF -Anweisung zu ändern. Die Bedingung wird negiert. Die Anweisungen in den Zweigen THEN und ELSE werden vertauscht. Alle Kommentare bleiben erhalten. Aufruf : Kontextmenü unter Befehl Refactoring Voraussetzung: Der Cursor steht innerhalb einer IF -Anweisung an einer beliebigen Stelle. Regeln für Negierung Ausdruck Negierter Ausdruck Beschreibung < >= Der Vergleich auf \"kleiner als\" wird zu \"größer als\" und umgekehrt. <= > Der Vergleich auf \"kleiner gleich als\" wird zu \"größer als\" und umgekehrt. = <> Der Vergleich auf \"gleich\" wird zu \"ungleich\" und umgekehrt. <Ausdruck1> AND <Ausdruck2> ( NOT <Ausdruck1> ) OR ( NOT <Ausdruck2> ) Negierung nach De-Morgan für Operator AND <Ausdruck1> OR <Ausdruck2> (NOT <Ausdruck1> ) AND (NOT <Ausdruck2> ) Negierung nach De-Morgan für Operator OR <Ausdruck> NOT <Ausdruck> Standardnegation NOT <Ausdruck> <Ausdruck> Kein doppeltet NOT -Ausdruck a (*Kommentar*) = b a (*Kommentar*) <> b Kommentare bleiben erhalten. Dies gilt insbesondere für vertauschte Operanden Beispiel PROGRAM Inversion1\nVAR\n xA, xB, xC : BOOL;\n iVar : INT;\nEND_VAR iVar := 0;\nIF NOT(xA AND xB AND xC) THEN\n\tiVar:= 1; (* IF 1 *)\nELSE\n\tiVar := iVar + 1; (* ELSE counter*)\nEND_IFiVar := 0;\n Code nach Aufruf des Befehls mit invertierter Logik bei gleicher Semantik: iVar := 0;\nIF (xA AND xB AND xC) THEN\n iVar := iVar + 1; (* ELSE counter*)\nELSE\n iVar:= 1; (* IF 1 *)\nEND_IF " }, 
{ "title" : "Befehl: Konstantenpropagation für aktuellen Editor anzeigen ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Konstantenpropagation für aktuellen Editor anzeigen ", 
"snippet" : "Konstantenpropagation für aktuellen Editor anzeigen Symbol: Funktion : Der Befehl startet die statische Codeanalyse und berechnet eine Maßzahl für die Konstantenpropagation des Codes im aktuellen Editors. Der sich öffnende Dialog visualisiert das Ergebnis. Der analysierte Code wird gelistet und die ...", 
"body" : "Konstantenpropagation für aktuellen Editor anzeigen Symbol: Funktion : Der Befehl startet die statische Codeanalyse und berechnet eine Maßzahl für die Konstantenpropagation des Codes im aktuellen Editors. Der sich öffnende Dialog visualisiert das Ergebnis. Der analysierte Code wird gelistet und die ermittelten Maßzahlen werden angezeigt. Aufruf : Menü Erstellen → Statische Analyse Voraussetzung : Im Editor ist ein Programmierobjekt in der Implementierungssprache ST geöffnet Für weitere Informationen siehe: Konstantenpropagation" }, 
{ "title" : "Dialog: Ergebnisse der Konstantenpropagation ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html#UUID-948900c6-97a3-c88d-ff29-bca9a5de0d7b_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Konstantenpropagation für aktuellen Editor anzeigen \/ Dialog: Ergebnisse der Konstantenpropagation ", 
"snippet" : "Beispiel...", 
"body" : "Beispiel " }, 
{ "title" : "Befehl: Statische Analyse durchführen ", 
"url" : "_san_cmd_run_static_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Statische Analyse durchführen ", 
"snippet" : "Statische Analyse durchführen Symbol: Funktion : Der Befehl startet die statische Codeanalyse für die aktive Applikation und stellt die Metriken für alle Programmierbausteine in einer Tabelle dar. Aufruf : Menü Erstellen → Statische Analyse Bei der Codeanalyse führt CODESYS Static Analysis eine Code...", 
"body" : "Statische Analyse durchführen Symbol: Funktion : Der Befehl startet die statische Codeanalyse für die aktive Applikation und stellt die Metriken für alle Programmierbausteine in einer Tabelle dar. Aufruf : Menü Erstellen → Statische Analyse Bei der Codeanalyse führt CODESYS Static Analysis eine Codegenerierung durch, wie auch mit dem Befehl Erstellen → Code erzeugen . Die Ergebnisse der Analyse werden im Meldungsfenster in der Kategorie Übersetzen als Fehler und Warnungen ausgegeben. Die Nummern beziehen sich auf die entsprechenden Regeln , so wie sie in den Projekteinstellungen definiert sind. Die Syntax für die Meldungsausgabe ist SA<rule number>:<rule text> . " }, 
{ "title" : "Befehl: Einstellungen ", 
"url" : "_san_cmd_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Einstellungen ", 
"snippet" : "Einstellungen Funktion : Der Befehl öffnet den Dialog Einstellungen Statische Analyse . Aufruf : Menü Erstellen → Statische Analyse Voraussetzung : Das Package CODESYS Static Analysis ist installiert. Ein Projekt ist geöffnet...", 
"body" : "Einstellungen Funktion : Der Befehl öffnet den Dialog Einstellungen Statische Analyse . Aufruf : Menü Erstellen → Statische Analyse Voraussetzung : Das Package CODESYS Static Analysis ist installiert. Ein Projekt ist geöffnet " }, 
{ "title" : "Befehl: Standardmetriken anzeigen ", 
"url" : "_san_cmd_view_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Standardmetriken anzeigen ", 
"snippet" : "Standardmetriken anzeigen Symbol: Funktion : Der Befehl startet die statische Codeanalyse für die aktive Applikation. Daraufhin werden die Standardmetriken für alle Programmierbausteine berechnet und in der Registerkarte Stadnard-Metriken als Tabelle angezeigt. Aufruf : Menü Erstellen → Statische An...", 
"body" : "Standardmetriken anzeigen Symbol: Funktion : Der Befehl startet die statische Codeanalyse für die aktive Applikation. Daraufhin werden die Standardmetriken für alle Programmierbausteine berechnet und in der Registerkarte Stadnard-Metriken als Tabelle angezeigt. Aufruf : Menü Erstellen → Statische Analyse Für weitere Informationen siehe: Metriken anzeigen lassenMetriken" }, 
{ "title" : "Registerkarte: Standard-Metriken ", 
"url" : "_san_cmd_view_standard_metrics.html#UUID-c2310f81-c613-bf67-ba1e-4f10694a38a1_section-idm4622240725232033866114829692", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Standardmetriken anzeigen \/ Registerkarte: Standard-Metriken ", 
"snippet" : "Beispiel Im Dialog Einstellungen Statische Analyse: Metriken können Sie die Konfiguration der Metriken ändern. Sie können für eine Metrik die Berechnung deaktivieren. Und Sie können für bestimmte Metriken Grenzwerte definieren. Wenn ein Wert außerhalb der konfigurierten Unter- und Obergrenze liegt, ...", 
"body" : "Beispiel Im Dialog Einstellungen Statische Analyse: Metriken können Sie die Konfiguration der Metriken ändern. Sie können für eine Metrik die Berechnung deaktivieren. Und Sie können für bestimmte Metriken Grenzwerte definieren. Wenn ein Wert außerhalb der konfigurierten Unter- und Obergrenze liegt, erscheint das Tabellenfeld rot hinterlegt. Im Kontextmenü der Tabelle gibt es folgende Befehle: Berechnen Aktualisiert die Werte Tabelle kopieren Kopiert die Tabelle in die Zwischenablage Das Trennzeichen ist ein Tabstopp. Tabelle drucken Öffnet den Standarddialog zum Einrichten des Druckauftrags Tabelle exportieren Exportiert die Tabelle wird in eine CSV-Datei Trennzeichen ist ein Strichpunkt. Kiviat-Diagramm Voraussetzung: Mindestens drei Metriken, die eine Unter- und Obergrenzen definiert haben, sind aktiviert. Stellt für den ausgewählten Baustein die Metriken als Spinnennetzdiagramm dar Damit wird visualisiert, wie gut der Code der Programmiereinheit bezüglich einer vorgegebenen Norm ist. Jede Metrik wird in einem Kreis als Achse dargestellt, die ausgehend vom Mittelpunkt (Wert 0) nach außen drei Ringzonen des Kreises durchläuft. Die innere Ringzone repräsentiert den Wertebereich unterhalb der für die Metrik definierten Untergrenze, die äußere den oberhalb der Obergrenze. Die Achsen der betroffenen Metriken sind gleichmäßig auf den Kreis verteilt. Die aktuellen Werte der einzelnen Metriken auf ihren Achsen werden mit Linien verbunden und idealerweise liegt die Gesamtlinie in der mittleren Kreiszone. Konfigurieren Öffnet die Tabelle zur Auswahl der gewünschten Metriken Sie entspricht der Tabelle in den Projekteinstellungen. POU öffnen Öffnet den Editor mit dem Programmierbaustein Beispiel Beispiel für ein Kiviat-Diagramm für 5 Metriken Der Name der Metrik steht jeweils am Ende der Achse, der Name des Bausteins rechts oben. " }, 
{ "title" : "Befehl: Standardmetriken berechnen und exportieren ", 
"url" : "_san_calculate_and_export_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Standardmetriken berechnen und exportieren ", 
"snippet" : "Standardmetriken berechnen und exportieren Funktion: Berechnet und exportiert die Standardmetriken direkt, ohne die Metriktabelle im Editor anzuzeigen. Geben Sie im Standarddateidialog einen geeigneten Namen für die CSV-Exportdatei an. Aufruf: Dieser Befehl ist standardmäßig in keinem Menü verfügbar...", 
"body" : "Standardmetriken berechnen und exportieren Funktion: Berechnet und exportiert die Standardmetriken direkt, ohne die Metriktabelle im Editor anzuzeigen. Geben Sie im Standarddateidialog einen geeigneten Namen für die CSV-Exportdatei an. Aufruf: Dieser Befehl ist standardmäßig in keinem Menü verfügbar. Alternativ können Sie die Metriken mit dem Befehl Standardmetriken anzeigen im Editor anzeigen. Der Editor stellt unter anderem den Kontextbefehl Tabelle exportieren zur Verfügung. Anpassen des Menüs Befehl bereitstellen Wählen Sie den Befehl Tools → Anpassen Es erscheint die Registerkarte Menü . Dort müssen Sie zunächst eine Menüposition für den Befehl festlegen. In diesem Fall ist es sinnvoll, eine Position unter dem Menü Erstellen → Statische Analyse auszuwählen. Selektieren Sie die gewünschte Position und klicken Sie die Schaltfläche Befehl hinzufügen . In der Liste Befehl hinzufügen werden alle Befehle gelistet. Selektieren Sie links die Kategorie Statische Analyse und danach rechts den gewünschten Befehl. Beenden Sie den Dialog mit OK . Beenden Sie dann den Dialog Anpassen ebenfalls mit OK Nun ist der Befehl Standardmetriken berechnen und exportieren unter dem Menü Erstellen → Statische Analyse verfügbar. " }, 
{ "title" : "Befehl: Klone finden ", 
"url" : "_san_cmd_find_clones.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Klone finden ", 
"snippet" : "Klone finden Funktion : Der Befehl durchsucht den Programmcode des geöffneten CODESYS -Projekts nach kopiertem Code und öffnet die Ansicht Ergebnisse Klonsuche zur Anzeige der gefundenen geklonten Codeblöcke. Dabei werden nur Codeblöcke ab einer bestimmten Größe als Klone berücksichtigt. Sehr kleine...", 
"body" : "Klone finden Funktion : Der Befehl durchsucht den Programmcode des geöffneten CODESYS -Projekts nach kopiertem Code und öffnet die Ansicht Ergebnisse Klonsuche zur Anzeige der gefundenen geklonten Codeblöcke. Dabei werden nur Codeblöcke ab einer bestimmten Größe als Klone berücksichtigt. Sehr kleine Codestücke werden nicht als Klone angezeigt werden. Beachten Sie in diesem Zusammenhang auch Funktion extrahieren und die Anleitung Codeklone finden. Aufruf : Menü Erstellen → Statische Analyse Kontextmenü Statische Analyse Voraussetzung : Das CODESYS Static Analysis -Projekt ist geöffnet. Zwei Codestellen gelten als Klone, wenn Sie folgende Eigenschaften haben: Gleicher struktureller Aufbau Variablen haben den gleichen Datentyp Variablennamen dürfen unterschiedlich sein (Ausnahme: Komponentenzugriffe). Allerdings muss ein Bezeichner, der mehrfach im Code enthalten ist, in beiden Codestellen an der gleichen Position stehen. Literale haben den gleichen Datentyp Literale dürfen unterschiedlich sein. Ein Literal, das mehrfach im Code auftaucht, muss in beiden Codestellen an der gleichen Position auftauchen. Ansicht Ergebnisse Klonsuche Zusammenfassung Registerkarte zur Anzeige des Suchergebnisses Anzahl gefundener geklonter Codeblöcke Anzahl verglichener Anweisungen Anzahl Anweisungen in geklontem Code Klonanteil : Angabe in Prozent: Anzahl Anweisungen in geklontem Code \/ Anzahl verglichener Anweisungen Ergebnisse In der Registerkarte werden die Codeklone in einer Baumansicht dargestellt und Befehle und Filtermöglichkeiten zur Verfügung gestellt. Als Wurzelknoten wird das erste Vorkommen eines Duplikats aus der Menge der Duplikate genommen. Durch die Hintergrundfarbe der Kindknoten wird dargestellt, ob der Code sich unterscheidet oder völlig identisch ist. Gleiche Farben bedeuten dabei „gleicher Code“. Die Inhalte der Baumansicht sind nach der Anzahl Anweisungen des duplizierten Codes absteigend sortiert. Befehle und Filter in der Registerkarte Ergebnisse Submodule\/Klon Anzahl der Submodule (Anweisungen) in dem Codeblock Wenn die Anzahl der Submodule kleiner als 20 ist, wird der Codeklon nicht berücksichtigt Filter nach Objekt Eingabefeld für ein Objekt , nach dem die Auflistung der Klone gefiltert wird Selektierte Klone anzeigen Voraussetzung: Zwei Kindknoten des gleichen Elternknotens sind selektiert. Die beiden Programmierobjekte werden im oberen Bereich der Ansicht zum Vergleich angezeigt. Dabei werden die Codeduplikate markiert und Unterschiede (zum Beispiel unterschiedliche Variablennamen) durch eine andere Farbe hervorgehoben. Auflistung der Codeklone Spalten Beschreibung Submodul\/Klon Objekt Position Ein Doppelklick auf einen Kindknoten öffnet das entsprechende Programmierobjekt, dort ist der duplizierte Codeblock selektiert. " }, 
{ "title" : "Befehl: Kognitive Komplexität für aktuellen Editor anzeigen ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Kognitive Komplexität für aktuellen Editor anzeigen ", 
"snippet" : "Kognitive Komplexität für aktuellen Editor anzeigen Symbol: Funktion : Der Befehl startet die statische Codeanalyse und berechnet ein Inkrement für die kognitive Komplexität des Codes im aktuellen Editor. Der sich öffnende Dialog visualisiert das Ergebnis und gibt im Titel die aufsummierte Maßzahl a...", 
"body" : "Kognitive Komplexität für aktuellen Editor anzeigen Symbol: Funktion : Der Befehl startet die statische Codeanalyse und berechnet ein Inkrement für die kognitive Komplexität des Codes im aktuellen Editor. Der sich öffnende Dialog visualisiert das Ergebnis und gibt im Titel die aufsummierte Maßzahl an. Der analysierte Code wird gelistet und mit den erkannten Komplexitäten angezeigt. Aufruf : Menü Erstellen → Statische Analyse Voraussetzung : Im Editor ist ein Programmierobjekt in der Implementierungssprache ST geöffnet " }, 
{ "title" : "Dialog: Kognitive Komplexität von <Name Programmierobjekt>: <Berechnetes Inkrement> ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html#UUID-315a7cbe-83be-ba91-4d86-234b9f3e6fc3_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Kognitive Komplexität für aktuellen Editor anzeigen \/ Dialog: Kognitive Komplexität von <Name Programmierobjekt>: <Berechnetes Inkrement> ", 
"snippet" : "Beispiel...", 
"body" : "Beispiel " }, 
{ "title" : "Befehl: Statische Analyse starten und in Sarif-Datei exportieren ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Statische Analyse starten und in Sarif-Datei exportieren ", 
"snippet" : "Statische Analyse starten und in Sarif-Datei exportieren Symbol: Funktion : Mit diesem Befehl wird die statische Codeanalyse gestartet und das Ergebnis in einer SARIF-Datei gespeichert. Aufruf : Menü Erstellen → Statische Analyse Eine SARIF-Datei (\" Static Analysis Results Interchange Format \") ist ...", 
"body" : "Statische Analyse starten und in Sarif-Datei exportieren Symbol: Funktion : Mit diesem Befehl wird die statische Codeanalyse gestartet und das Ergebnis in einer SARIF-Datei gespeichert. Aufruf : Menü Erstellen → Statische Analyse Eine SARIF-Datei (\" Static Analysis Results Interchange Format \") ist eine maschinenlesbare JSON-Dateien mit der Dateiendung \" *.sarif.json \", die von der Statischen Analyse erstellt wird, um die Ergebnisse in einem standardisierten Format zu speichern.  SARIF ist ein OASIS-Standard. Das bedeutet, dass verschiedene Tools und Plattformen ihn verwenden können, um Analyseresultate auszutauschen und weiterzuverarbeiten. " }, 
{ "title" : "Kommandozeilenbefehl ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html#UUID-b1a6530c-4103-8c37-7a9e-f6ad763d2402_section-idm235003337576496", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Statische Analyse starten und in Sarif-Datei exportieren \/ Kommandozeilenbefehl ", 
"snippet" : "Der Befehl kann auch automatisiert über CODESYS Scripting ausgeführt werden. Der Batch-Befehl [„staticanalysis“, „runandexportosarif“] akzeptiert die folgenden Argumente. Argument --sariffile --sariffile=<path to output>; Legen Sie den Pfad fest, in den die resultierende SARIF-Datei geschrieben werd...", 
"body" : "Der Befehl kann auch automatisiert über CODESYS Scripting ausgeführt werden. Der Batch-Befehl [„staticanalysis“, „runandexportosarif“] akzeptiert die folgenden Argumente. Argument --sariffile --sariffile=<path to output>; Legen Sie den Pfad fest, in den die resultierende SARIF-Datei geschrieben werden soll. Wenn Sie keinen Pfad angegeben wird, wird die Datei im Ordner des aktuellen Projekts gespeichert.\n Argument --rulesfile --rulesfile=<patch to CSA file>; Legen Sie den Pfad zu einer CSA-Datei fest, die für die statische Analyse verwendet werden soll. Wenn Sie keinen Pfad angegeben, wird die aktuelle Konfiguration verwendet. Beispiel für den Aufruf in einem Python-Skript system.commands[\"staticanalysis\", \"runandexportosarif\"].execute(\"--sariffile=result.sarif\", \"--rulesfile=rules.csa\") " }, 
{ "title" : "Befehl: Formatieren ", 
"url" : "_san_cmd_format.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Befehle \/ Befehl: Formatieren ", 
"snippet" : "Formatieren Debug-Betrieb Diese Funktionalität ist nur verfügbar, wenn Ihre CODESYS -Instanz im Debug-Betrieb gestartet wird. Starten Sie dafür Ihre Instanz mit folgendem Kommandozeilenaufruf: codesys.exe --debug Funktion : Der Befehl formatiert ein ST-Objekt nach den in den CODESYS -Optionen konfig...", 
"body" : "Formatieren Debug-Betrieb Diese Funktionalität ist nur verfügbar, wenn Ihre CODESYS -Instanz im Debug-Betrieb gestartet wird. Starten Sie dafür Ihre Instanz mit folgendem Kommandozeilenaufruf: codesys.exe --debug Funktion : Der Befehl formatiert ein ST-Objekt nach den in den CODESYS -Optionen konfigurierten Regeln, um die Lesbarkeit des Codes zu verbessern. Aufruf : Kontextmenü unter Menü Refactoring Voraussetzung: Ein ST-Editor ist geöffnet und de Cursor befindet sich innerhalb einer Deklaration oder Implementierung. Für weitere Informationen siehe: Autoformatierung" }, 
{ "title" : "Dialoge ", 
"url" : "_san_struct_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Dialoge ", 
"snippet" : "Die Dialoge für die Konfiguration der statischen Codeanalyse finden Sie in Erstellen → Statische Analyse → Einstellungen . Als Voraussetzung muss ein CODESYS -Projekt geöffnet sein....", 
"body" : "Die Dialoge für die Konfiguration der statischen Codeanalyse finden Sie in Erstellen → Statische Analyse → Einstellungen . Als Voraussetzung muss ein CODESYS -Projekt geöffnet sein. " }, 
{ "title" : "Dialog: Einstellungen Statische Analyse: Einstellungen ", 
"url" : "_san_dlg_settings_static_analysis_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Einstellungen Statische Analyse: Einstellungen ", 
"snippet" : "Einstellungen Funktion : In dem Dialog aktivieren Sie die automatische statische Codeanalyse und speichern oder laden die Projekteinstellungen für die statische Codeanalyse als CSA-Datei. Schaltfläche Konfigurationsdialog öffnen in Projekt → Projekteinstellungen , Kategorie Statische Codeanalyse Men...", 
"body" : "Einstellungen Funktion : In dem Dialog aktivieren Sie die automatische statische Codeanalyse und speichern oder laden die Projekteinstellungen für die statische Codeanalyse als CSA-Datei. Schaltfläche Konfigurationsdialog öffnen in Projekt → Projekteinstellungen , Kategorie Statische Codeanalyse Menü Erstellen → Statische Analyse → Einstellungen Voraussetzung : Das Package CODESYS Static Analysis ist installiert Ein Projekt ist geöffnet Statische Analyse automatisch durchführen : CODESYS Static Analysis führt die Codeprüfung automatisch bei jeder Codegenerierung durch, zum Beispiel bei Ausführung des Befehls Erstellen → Code erzeugen oder vor einem Download. : Die Codeprüfung wird nicht automatisch durchgeführt, kann jedoch explizit über den Befehl Erstellen → Statische Analyse → Statische Analyse durchführen durchgeführt werden. Laden Öffnet den Standarddialog Konfiguration der Statischen Analyse laden zum Laden der Projekteinstellungen für die Statische Analyse als csa-Datei aus dem Dateisystem. Wenn Sie die Schaltfläche Öffnen klicken, wird die ausgewählte csa-Datei geladen. Speichern Öffnet den Standarddialog Konfiguration der Statischen Analyse speichern zum Speichern aller Projekteinstellungen der Kategorie Statische Codeanalyse als csa-Datei im Dateisystem. " }, 
{ "title" : "Dialog: Einstellungen Statische Analyse: Regeln ", 
"url" : "_san_dlg_settings_sa_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Einstellungen Statische Analyse: Regeln ", 
"snippet" : "Regeln Funktion : In dem Dialog wählen Sie die Regeln aus, die bei der statischen Analyse des Quellcodes eines Projekts geprüft werden. Weitere Informationen siehe: Statische Codeanalyse konfigurieren und durchführenAufruf : Schaltfläche Konfigurationsdialog öffnen in Menü Projekt → Projekteinstellu...", 
"body" : "Regeln Funktion : In dem Dialog wählen Sie die Regeln aus, die bei der statischen Analyse des Quellcodes eines Projekts geprüft werden. Weitere Informationen siehe: Statische Codeanalyse konfigurieren und durchführenAufruf : Schaltfläche Konfigurationsdialog öffnen in Menü Projekt → Projekteinstellungen , Kategorie Statische Codeanalyse Menü Erstellen → Statische Analyse → Einstellungen Voraussetzung : Das CODESYS Static Analysis -Package ist installiert. Ein Projekt ist geöffnet Diese Registerkarte zeigt in einer Baumstruktur alle Regeln, die bei der statischen Codeanalyse geprüft werden können. Standardmäßig sind alle Regeln aktiviert, mit Ausnahme von SA0016, SA0024, SA0073, SA0101, SA0105, SA0106, SA0133, SA0134, SA0150, SA0162 und allen „Strikten IEC-Regeln“. Jede Regel hat eine eindeutige Nummer. Wenn die Überprüfung der Regel einen Treffer ergibt, wird die Regelnummer zusammen mit einer Fehlerbeschreibung im Meldungsfenster in Kategorie Übersetzen in folgender Form ausgegeben: SA<Regelnummer> , „SA“ bedeutet „Statische Analyse“, Beispiel:: „SA003“ für Regelnummer 3. Die Liste der verfügbaren Regeln kann durch spezifische Plug-ins erweitert sein. Filter Eingabefeld für die Zeichenfolge, nach der gesucht wird Regeln werden in Kategorien gruppiert angezeigt Strukturiert nach Wichtigkeit : Sortierung nach Wichtigkeit hoch , Wichtigkeit mittel , Wichtigkeit gering Standard : Standardmäßige Strukturierung der Regeln in CODESYS Static Analysis : Regeln werden als flache Liste angezeigt. Durch einen Klick auf den entsprechenden Spaltentitel kann die Liste nach Regelnummer, Aktivierung\/Deaktivierung, regelspezifischer Konfiguration oder Wichtigkeit sortiert werden. Einige Regeln, die hier im Dialog aktiviert sind, können über ein Pragma in der Applikation temporär abgeschaltet werden Wenn Sie das Kontrollkästchen klicken, wechselt die Einstellung zwischen , und . Wenn Sie einen Knotenpunkt aktivieren, bzw. deaktivieren, werden alle Regeln unterhalb dieses Knotenpunkts ebenfalls aktiviert, bzw. deaktiviert. Spalten Regeln Auflistung der Regeln mit Regelnummer Prüfung der Regel : Die Regel wird nicht geprüft. : Bei einem positiven Prüfergebnis wird im Meldungsfenster ein Fehler für die statische Codeanalyse ausgegeben. : Bei einem positiven Prüfergebnis wird im Meldungsfenster eine Warnung für die statische Codeanalyse ausgegeben. Vorkompilierung : Regeln, die während der Vorkompilierung geprüft werden können, sind in dieser Spalte mit einem Haken gekennzeichnet. Dadurch werden die Regeln bereits bei der Eingabe des Codes überprüft. Für diese Regeln gibt es die Möglichkeit einer schnellen Fehlerbehebung (Quickfix). Sie können direkt an den betroffenen Codestellen eine automatische unmittelbare Fehlerbehandlung ausführen. : Regeln, die nicht gekennzeichnet sind, werden erst nach einer erfolgreichen Kompilierung geprüft Regelspezifische Konfiguration Bei einigen Regeln öffnet sich durch einen Doppelklick auf das Feld ein regelspezifischer Dialog zur Konfiguration der Regel. Wichtigkeit Wichtigkeit der Regel: 3 rote Sterne: Hoch 2 orange Sterne: Mittel 1 grauer Stern: Niedrig " }, 
{ "title" : "Dialog: Einstellungen Statische Analyse: Namenskonventionen ", 
"url" : "_san_dlg_settings_sa_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Einstellungen Statische Analyse: Namenskonventionen ", 
"snippet" : "Namenskonventionen Funktion : In dem Dialog definieren Sie die Präfixe für die Datentypen und die Gültigkeitsbereiche von Variablen, sowie Präfixe für POUs und benutzerdefinierte Datentypen (DUTs). Die Einhaltung der Namenskonventionen wird durch die statische Codeanalyse geprüft. Wenn eine Konventi...", 
"body" : " Namenskonventionen Funktion : In dem Dialog definieren Sie die Präfixe für die Datentypen und die Gültigkeitsbereiche von Variablen, sowie Präfixe für POUs und benutzerdefinierte Datentypen (DUTs). Die Einhaltung der Namenskonventionen wird durch die statische Codeanalyse geprüft. Wenn eine Konvention nicht eingehalten wird, wird für die statische Codeanalyse eine Fehlermeldung in der Ansicht Meldungen angezeigt. Weitere Informationen hierzu: Statische Codeanalyse konfigurieren und durchführenAufruf : Schaltfläche Konfigurationsdialog öffnen in Menü Projekt → Projekteinstellungen , Kategorie Statische Codeanalyse Menü Erstellen → Statische Analyse → Einstellungen Voraussetzung : Das Package CODESYS Static Analysis ist installiert Ein Projekt ist geöffnet Die Fehlermeldungen werden in der Form NC <Präfix-Konventionsnummer> : <Meldungstext> angezeigt. NC steht für „Naming Convention“. Beispielsweise bedeutet die Fehlermeldung NC0102: Ungültiger Name … eine Verletzung der Namenskonvention 102 für POUs vom Typ PROGRAM . Sie können für einzelne Bezeichner die Namenskonventionen mit dem Pragma 'naming' deaktivieren. Die Bezeichner können dann beliebig beginnen und nicht zwingend mit dem Präfix. Filter Eingabefeld für Zeichenfolge, nach der gesucht wird Tabelle mit den Namenskonventionen Namen Knotenpunkte und Elemente, für die ein Präfix definiert werden kann Die Nummer in Klammer nach jedem Element, zum Beispiel PROGRAM (102) , ist die Präfix-Konventionsnummer, die bei einer Nichteinhaltung der Namenskonvention ausgegeben wird. Präfix Eingabefeld für das Präfix Mehrere Präfixe können, getrennt durch Komma, eingegeben werden. Beispiel: Präfix für POUs , PROGRAM (102) : prog, PRG_ Präfix für POUs , FUNCTION (103) : fun, FUN_ Für Präfixe sind auch reguläre Ausdrücke (RegEx) möglich. Dazu muss ein @ vorangestellt werden. Beispiel: Der Name muss mit x beginnen und darf dann noch ein Zeichen des Bereichs a-dA-D enthalten: @x[a-dA-D] Für Variablen vom Datentyp Alias und für Bausteine (POUs) vom Datentyp Property das Präfix mit dem Platzhalter {datatype} definiert werden Präfixe für Variablen Organisatorischer Knotenpunkt für alle Variablen, für die ein von ihrem Datentyp oder Gültigkeitsbereich abhängiges Präfix definiert werden kann Präfixe für POUs Organisatorischer Knotenpunkt für alle POU-Typen und Methodengültigkeitsbereiche, für die ein Präfix definiert werden kann Präfixe für DUTs Organisatorischer Knotenpunkt für die DUT-Datentypen Struktur, Enumeration, Alias oder Union, für die ein Präfix definiert werden kann Präfixe für benutzerdefinierte Typen Organisatorischer Knotenpunkt für spezielle benutzerdefinierte Typen, insbesondere solche aus Bibliotheken Sie können die Liste mit Konventionen erweitern: Klicken Sie auf die Leerzeile darunter. Geben Sie dann den Namen eines benutzerdefinierten Typen ein oder wählen Sie einen benutzerdefinierten Typ im Dialog Eingabehilfe aus. Sie können eine Konvention löschen, indem Sie diese selektieren und die Taste Entf wählen. Hinweis: Diese Konventionen haben Vorrang vor den Präfixen, die mit dem Attribut {attribute 'nameprefix' := '<prefix>'} definiert sind. Optionen Erstes Zeichen nach Präfix soll ein Großbuchstabe sein : Die statische Codeanalyse meldet einen Fehler für eine Variable, wenn das erste Zeichen des Variablennamens nach dem definierten Präfix kein Großbuchstabe ist. Namensraumpräfix mit Datentyppräfix kombinieren : Eine Variable muss das definierte Präfix für ihren Namensraum haben, gefolgt von dem definierten Präfix für ihren Datentyp. Beispiel: Folgende Präfixe sind definiert: Für VAR_GLOBAL g_ , für Datentyp REAL r . Die Codeanalyse meldet Fehler für globale REAL-Variablen, die nicht das Präfix g_r haben. : Wenn für eine Variable Konventionen für den Namensraum angegeben wurden, werden diese Konventionen berücksichtigt. Etwaige Datentypskonventionen bleiben dann unberücksichtigt. Beispiel: Folgende Präfixe sind definiert: Für VAR_GLOBAL g_ , für Datentyp REAL r . Die Codeanalyse meldet ausschließlich Fehler für globale REAL -Variablen, die nicht das Präfix g_ haben. Rekursive Präfixe für kombinierbare Datentypen : Variablen kombinierter Datentypen müssen zusammengesetzte Präfixe haben, die den definierten Namenskonventionen entsprechen. Beispiel: ppiVariable : POINTER TO POINTER TO INT; Für Variablen des Datentyps POINTER TO wurde das Präfix p definiert, für den Datentyp INT das Präfix i . Die statische Codeanalyse meldet Fehler für alle Variablen vom Datentyp POINTER TO POINTER TO INT , die nicht das Präfix ppi haben. refaiVar : REFERENCE TO ARRAY[1..3] OF INT; Für den Datentyp REFERENCE TO wurde das Präfix ref definiert, für ein Array das Präfix a und für den Datentyp INT das Präfix i . Die statische Codeanalyse meldet Fehler für alle Variablen vom Datentyp REFERENCE TO ARRAY[1..3] OF INT , die nicht das Präfix refai haben. Beispiel Die folgende Namenskonvention entspricht weitestgehend den Empfehlungen, die für die \"Bezeichner\" in CODESYS beschrieben sind. Beispiel Die Namenskonvention (1) bezieht sich auf den Standardbaustein TON . Deklarationen des spezieller Bibliotheksbausteins werden infolgedessen auf das Präfx „ton_“ überprüft. Mit Klick in die Leerzeile (2) können Sie weitere Namenskonventionen einfügen. " }, 
{ "title" : "Dialog: Einstellungen Statische Analyse: Metriken ", 
"url" : "_san_dlg_settings_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Einstellungen Statische Analyse: Metriken ", 
"snippet" : "Einstellungen Statische Analyse: Metriken Symbol: Funktion : Konfiguriert die Metriken, so daß sie bei Aufruf des Befehls Standardmetriken anzeigen dementsprechend berechnet und angezeigt werden. Aufruf : Menü Projekt → Projekteinstellungen , Kategorie Statische Codeanalyse , Link Konfigurationsdial...", 
"body" : "Einstellungen Statische Analyse: Metriken Symbol: Funktion : Konfiguriert die Metriken, so daß sie bei Aufruf des Befehls Standardmetriken anzeigen dementsprechend berechnet und angezeigt werden. Aufruf : Menü Projekt → Projekteinstellungen , Kategorie Statische Codeanalyse , Link Konfigurationsdialog öffnen Menü Erstellen → Statische Analyse → Einstellungen Voraussetzung : Das Package CODESYS Static Analysis ist installiert Ein Projekt ist geöffnet Weitere Informationen siehe: Statische Codeanalyse konfigurieren und durchführenMetrik In der Spalte werden alle auswählbaren Metriken angezeigt. Aktiv : Metrik wird auf den Befehl Erstellen → Statische Analyse → Standard-Metriken anzeigen im Fenster Standard-Metriken für jeden Baustein angezeigt. : Metrik wird auf den Befehl Erstellen → Statische Analyse → Standard-Metriken anzeigen im Fenster Standard-Metriken nicht angezeigt. Untergrenze Unterer Wert, ab dem die Metrik angezeigt wird Obergrenze Oberer Wert, bis zu dem die Metrik angezeigt wird Die Metriken Codegröße , Variablengröße , Stackgröße und Anzahl Aufrufe werden nur für Bausteine aus Bibliotheken ausgegeben, die im Projekt eingebunden sind. Sie können Verletzungen der Ober- und Untergrenzen der aktivierten Metriken über die Regel SA0150 der statischen Codeanalyse als Übersetzungsfehler ausgeben lassen. " }, 
{ "title" : "Dialog: Einstellungen Statische Analyse: Unzulässige Symbole ", 
"url" : "_san_dlg_settings_sa_forbidden_symbols.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Einstellungen Statische Analyse: Unzulässige Symbole ", 
"snippet" : "Unzulässige Symbole Funktion : In dem Dialog legen Sie die Schlüsselwörter und Symbole fest, die im Code des Projekts nicht verwendet werden dürfen. Weitere Informationen hierzu: Statische Codeanalyse konfigurieren und durchführenAufruf : Schaltfläche Konfigurationsdialog öffnen in Menü Projekt → Pr...", 
"body" : "Unzulässige Symbole Funktion : In dem Dialog legen Sie die Schlüsselwörter und Symbole fest, die im Code des Projekts nicht verwendet werden dürfen. Weitere Informationen hierzu: Statische Codeanalyse konfigurieren und durchführenAufruf : Schaltfläche Konfigurationsdialog öffnen in Menü Projekt → Projekteinstellungen , Kategorie Statische Codeanalyse Menü Erstellen → Statische Analyse → Einstellungen Voraussetzung : Das Package CODESYS Static Analysis ist installiert Ein Projekt ist geöffnet Eingabezeile Ein Doppelklick in die Zeile öffnet den Zeileneditor zur Eingabe eines Schlüsselworts oder Symbols. : Die Eingabehilfe öffnet sich zur Auswahl des Symbols oder Schlüsselworts. " }, 
{ "title" : "Dialog: Optionen: Autoformatierung ", 
"url" : "_cds_dlg_options_smart_code.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen: Autoformatierung ", 
"snippet" : "Autoformatierung Debug-Betrieb Diese Funktionalität ist nur verfügbar, wenn Ihre CODESYS -Instanz im Debug-Betrieb gestartet wird. Starten Sie dafür Ihre Instanz mit folgendem Kommandozeilenaufruf: codesys.exe --debug Symbol: Funktion : In diesem Dialog ist die automatische Formatierung des IEC-Code...", 
"body" : "Autoformatierung Debug-Betrieb Diese Funktionalität ist nur verfügbar, wenn Ihre CODESYS -Instanz im Debug-Betrieb gestartet wird. Starten Sie dafür Ihre Instanz mit folgendem Kommandozeilenaufruf: codesys.exe --debug Symbol: Funktion : In diesem Dialog ist die automatische Formatierung des IEC-Codes konfiguriert. Aufruf : Menü Tools → Optionen , Kategorie Autoformatierung " }, 
{ "title" : "Autoformatierung ", 
"url" : "_cds_dlg_options_smart_code.html#UUID-ed744990-e58a-afa4-07c6-a11c0254c4c0_section-idm4605775334425634132064038043", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen: Autoformatierung \/ Autoformatierung ", 
"snippet" : "Allgemein Deklaration und Implementation Leere Zeilen unterdrücken true (Default): Leere Zeilen werden entfernt. false : Leere Zeilen bleiben erhalten Schnittstelle Deklaration Variablentypen ausrichten true (Default): Alle Typen in einem Variablenbaustein werden so angeordnet, dass sie mit der glei...", 
"body" : "Allgemein Deklaration und Implementation Leere Zeilen unterdrücken true (Default): Leere Zeilen werden entfernt. false : Leere Zeilen bleiben erhalten Schnittstelle Deklaration Variablentypen ausrichten true (Default): Alle Typen in einem Variablenbaustein werden so angeordnet, dass sie mit der gleichen Zeilentiefe beginnen. false : Variableninitialisierung ausrichten true (Default): Alle Initialisierungen in einem Variablenbaustein werden so angeordnet, dass sie mit der gleichen Zeilentiefe beginnen. false : Kommentare nach Variablen ausrichten true (Default): Alle Kommentare, die sich in derselben Zeile wie die Variablendeklaration befinden, beginnen auf derselben Zeilentiefe. false : Aufrufe Alle Aufrufe werden formatiert, wenn die maximalen Werte überschritten werden.  Beispiel: Max. Anzahl der Parameter vor Zeilenumbruch Die Anzahl der Parameter, die ein einzeiliger Aufruf enthalten kann, ist begrenzt. Beispiel: 4 (Default) Max. Zeichenlänge der Parameter vor Zeilenumbruch Die Anzahl der Zeichen des Parameternamens ist begrenzt. Beispiel: 300 (Default) " }, 
{ "title" : "Referenz: Programmierung ", 
"url" : "_san_f_reference_programming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Pragmas und Attribute ", 
"url" : "_san_struct_reference_pragmas.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Pragmas und Attribute ", 
"snippet" : "CODESYS Static Analysis bietet Pragmas und Attribute, um einzelne Regeln oder Namenskonventionen für die statische Codeanalyse aus- oder einzuschalten. Voraussetzung: Die Regeln oder Konventionen sind in den Projekteinstellungen aktiviert oder definiert. Attribute werden im Deklarationsteil eines Pr...", 
"body" : "CODESYS Static Analysis bietet Pragmas und Attribute, um einzelne Regeln oder Namenskonventionen für die statische Codeanalyse aus- oder einzuschalten. Voraussetzung: Die Regeln oder Konventionen sind in den Projekteinstellungen aktiviert oder definiert. Attribute werden im Deklarationsteil eines Programmierbausteins eingefügt, um bestimmte Regeln für ein gesamtes Programmierobjekt abzuschalten. Pragmas werden im Implementierungsteil eines Programmierbausteins verwendet, um bestimmte Regeln für einzelne Codezeilen abzuschalten. Ausnahme ist die Regel 164, die auch im Deklarationsteil abgeschaltet werden kann. Regeln, die in den Projekteinstellungen deaktiviert sind, können über ein Pragma oder Attribut nicht aktiviert werden. Regel SA0004 kann nicht über ein Pragma oder Attribut deaktiviert werden. " }, 
{ "title" : "Pragma: analysis ", 
"url" : "_san_pragma_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Pragmas und Attribute \/ Pragma: analysis ", 
"snippet" : "Mit diesem Pragma deaktivieren Sie die Codierregeln für einzelne Codezeilen eines Programmierbausteins, so dass sie bei der statischen Codeanalyse nicht berücksichtigt werden. Sie deaktivieren Codierregeln durch die Angabe der Regelnummern und einem vorangestellten Minuszeichen („-„). Zur Aktivierun...", 
"body" : "Mit diesem Pragma deaktivieren Sie die Codierregeln für einzelne Codezeilen eines Programmierbausteins, so dass sie bei der statischen Codeanalyse nicht berücksichtigt werden. Sie deaktivieren Codierregeln durch die Angabe der Regelnummern und einem vorangestellten Minuszeichen („-„). Zur Aktivierung wird ein Pluszeichen („+“) vorangestellt. Sie können im Pragma beliebig viele Regeln angeben. Einfügeort : Deaktivierung: Im Implementierungsteil, vor der ersten Codezeile, ab der die Codeanalyse deaktiviert wird, mit {analysis - ...} . Aktivierung: Nach der letzten Zeile der Deaktivierung mit {analysis + ...} . Für die Regel 164 kann das Pragma auch im Deklarationsteil vor einem Kommentar eingefügt werden. Syntax: Deaktivierung von Regeln:\n\n{analysis -<rule number> ( , -<further rule number> )* }\n* : optional none, one or more further rule numbers Aktivierung von Regeln:\n\nanalysis +<rule number> ( , +<further rule number> )* }\n* : none, one or more further rule numbers Beispiel Regel 24 wird für zwei Zeilen deaktiviert und danach wieder aktiviert. Damit wird in diesen Zeilen Regel 24 nicht geprüft, so dass beispielsweise nTest:=DINT#99 erlaubt ist. {analysis -24}\nnTest := 99;\niVar := INT#2;\n{analysis +24} Deaktivieren mehrerer Regeln: {analysis -10, -24, -18} " }, 
{ "title" : "Attribut: analysis ", 
"url" : "_san_attribute_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Pragmas und Attribute \/ Attribut: analysis ", 
"snippet" : "Das Attribut deaktiviert bestimmte Regeln für ein ganzes Programmierobjekt, so dass sie bei der statischen Codeanalyse nicht berücksichtigt werden. Sie deaktivieren die Codierregeln durch die Angabe der Regelnummern und einem vorangestellten Minuszeichen („-„). Sie können im Attribut beliebig viele ...", 
"body" : "Das Attribut deaktiviert bestimmte Regeln für ein ganzes Programmierobjekt, so dass sie bei der statischen Codeanalyse nicht berücksichtigt werden. Sie deaktivieren die Codierregeln durch die Angabe der Regelnummern und einem vorangestellten Minuszeichen („-„). Sie können im Attribut beliebig viele Regeln angeben. Einfügeort : Im Deklarationsteil eines Programmierbausteins in der ersten Zeile. Syntax : {attribute 'analysis' := '-<rule number> ( , -<further rule number> )* '}\n* : none, one or more further rule numbers Beispiel Regeln 33 und 31 werden für die komplette Struktur ausgeschaltet: {attribute 'analysis' := '-33, -31'}\nTYPE My_Structure :\nSTRUCT\n iLocal : INT;\n uiLocal : UINT;\n udiLocal : UDINT;\nEND_STRUCT\nEND_TYPE Regel 100 wird für das Array ausgeschaltet: {attribute 'analysis' := '-100'}\nPROGRAM PLC_PRG\nVAR\n aBigData: ARRAY[1..10000] OF DWORD;\n aBigDATA_2: ARRAY[1..10000] OF DWORD;\nEND_VAR\n; " }, 
{ "title" : "Attribut: 'naming' ", 
"url" : "_san_attribute_naming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Pragmas und Attribute \/ Attribut: 'naming' ", 
"snippet" : "Das Attribut kennzeichnet die Codezeilen, die von der Analyse der Namenskonvention ausgeschlossen sind. Vor der ersten Codezeile, bei der die Codeanalyse ausgesetzt wird, ist dem Pragmaattribut ein off , nach der letzten Zeile ein on zugewiesen. Wenn ein omit zugewiesen ist, wird nur die nächste Cod...", 
"body" : "Das Attribut kennzeichnet die Codezeilen, die von der Analyse der Namenskonvention ausgeschlossen sind. Vor der ersten Codezeile, bei der die Codeanalyse ausgesetzt wird, ist dem Pragmaattribut ein off , nach der letzten Zeile ein on zugewiesen. Wenn ein omit zugewiesen ist, wird nur die nächste Codezeile ignoriert. Einfügeort : Deaktivierung: Im Deklarationsteil von POUs und DUTs oberhalb der betreffenden Zeilen. Aktivierung: Unterhalb der betreffenden Zeilen. Syntax : {attribute 'naming' := '<switch state>'}\n<switch state> : on | off | omit\non : naming is switched on\noff : naming is switched off\nomit : only next codeline is switched off Beispiel Definierte Namenskonventionen: (1) Die Kennzeichner von INT-Variablen müssen mit einem Präfix „int“ versehen sein, beispielsweise „intVar1“. (2) Programmnamen müssen mit „prog“ beginnen. Für den unten dargestellten Code gibt die statische Analyse dann nur Meldungen zu folgenden Variablen aus: cccVar , aVariable , bVariable . VAR\n{attribute 'naming' := 'off'}\n iVarA : INT;\n iVarB : INT;\n{attribute 'naming' := 'on'}\n iVarC : INT;\nEND_VAR VAR\n ...\n{attribute 'naming' := 'omit'}\n iVarC : INT;\n...\nEND_VAR {attribute 'naming' := 'omit'}\nPROGRAM PLC_PRG\nVAR\n...\nEND_VAR {attribute 'naming' := 'off'}\nPROGRAM DoSomethingA\nVAR\n{attribute 'naming' := 'on'}\n iVarA : INT;\n iVarB : INT;\n …\nVAR_END " }, 
{ "title" : "Attribut: nameprefix ", 
"url" : "_san_attribute_nameprefix.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Pragmas und Attribute \/ Attribut: nameprefix ", 
"snippet" : "nameprefix Das Attribut definiert ein Präfix für Variablen eines strukturierten Datentyps. Das Präfix muss den Kennzeichnern der Variablen vorangestellt sein, die mit diesem Typ deklariert sind. Diese Namenskonvention prüft die statische Codeanalyse . Einfügeort : In der Zeile vor der Deklaration ei...", 
"body" : "nameprefix Das Attribut definiert ein Präfix für Variablen eines strukturierten Datentyps. Das Präfix muss den Kennzeichnern der Variablen vorangestellt sein, die mit diesem Typ deklariert sind. Diese Namenskonvention prüft die statische Codeanalyse . Einfügeort : In der Zeile vor der Deklaration eines strukturierten Datentyps Syntax : {attribute 'nameprefix' := '<prefix>'} Beispiel Im folgenden Beispiel gibt die Statische Analyse eine Meldung für pB aus, weil der Variablenname nicht mit „point“ beginnen. {attribute 'nameprefix' := 'point'}\nTYPE DATAPOINT :\nSTRUCT\n iX: INT;\n iY: INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n pointA : DATAPOINT;\n pB : DATAPOINT;\nEND_VAR\npointA.iX := 1;\npointA.iY := 10;\npB.iX := 2;\npB.iY := 20; Fehlermeldung nach Statischer Codeanalyse: Ungültiger Variablenname ‚pB‘: Erwartetes Präfix ‚point‘ " }, 
{ "title" : "Attribut: analysis:report-multiple-instance-calls ", 
"url" : "_san_attribute_analysis_report_multiple_instance_calls.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Pragmas und Attribute \/ Attribut: analysis:report-multiple-instance-calls ", 
"snippet" : "analysis:report-multiple-instance-calls Das Attribut kennzeichnet einen Funktionsbaustein für eine Prüfung auf Regel 105 : Nur bei Funktionsbausteinen mit diesem Attribut wird geprüft, ob die Instanzen des Funktionsbausteins mehrfach aufgerufen werden. Wenn die Regel 105 in den Projekteinstellungen ...", 
"body" : "analysis:report-multiple-instance-calls Das Attribut kennzeichnet einen Funktionsbaustein für eine Prüfung auf Regel 105 : Nur bei Funktionsbausteinen mit diesem Attribut wird geprüft, ob die Instanzen des Funktionsbausteins mehrfach aufgerufen werden. Wenn die Regel 105 in den Projekteinstellungen deaktiviert ist, hat das Attribut keine Auswirkung. Einfügeort : Erste Zeile im Deklarationsteil eines Funktionsbausteins. Syntax : {attribute 'analysis:report-multiple-instance-calls'} Beispiel \/\/ {attribute 'analysis:report-multiple-instance-calls'} deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\n{attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\niB := iB +1;\n\nPROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nND_VAR\n\nfbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n Ausgabe unter Ansicht Meldungen : SA0105: Instanz 'fbB' mehrmals aufgerufen " }, 
{ "title" : "Regeln ", 
"url" : "_san_struct_reference_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0001: Unerreichbarer Code ", 
"url" : "_san_rule_sa0001.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0001: Unerreichbarer Code ", 
"snippet" : "Ermittelt Codezeilen, die nicht ausgeführt werden, beispielsweise wegen einer RETURN - oder CONTINUE -Anweisung. Begründung: Unerreichbarer Code sollte in jedem Fall vermieden werden. Häufig weist die Prüfung darauf hin, dass noch Testcode enthalten ist, der wieder entfernt werden sollte. Wichtigkei...", 
"body" : "Ermittelt Codezeilen, die nicht ausgeführt werden, beispielsweise wegen einer RETURN - oder CONTINUE -Anweisung. Begründung: Unerreichbarer Code sollte in jedem Fall vermieden werden. Häufig weist die Prüfung darauf hin, dass noch Testcode enthalten ist, der wieder entfernt werden sollte. Wichtigkeit: Hoch PLCopen-Regel: CP2 Beispiel PROGRAM PLC_PRG\nVAR\n xReturn_Before_End: BOOL;\n xContinue_In_Loop_FUN: BOOL;\n iCounter: INT;\nEND_VAR\n xContinue_In_Loop_FUN := FALSE;\nFOR iCounter := INT#0 TO INT#5 BY INT#1 DO\n CONTINUE;\n xContinue_In_Loop_FUN := FALSE;\nEND_FOR Ausgabe unter Ansicht Meldungen : SA0001: Nicht durchlaufener Code gefunden in 'PLC_PRG' " }, 
{ "title" : "SA0002: Leere Objekte ", 
"url" : "_san_rule_sa0002.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0002: Leere Objekte ", 
"snippet" : "Ermittelt POUs, GVLs, Datentypdeklarationen oder Schnittstellen, die keinen Code enthalten. Begründung: Leere Objekte sollten vermieden werden. Sie sind oft ein Zeichen dafür dass ein Objekt nicht vollständig implementiert ist. Ausnahme: In manchen Fällen wird man dem Rumpf eines Funktionsblocks kei...", 
"body" : "Ermittelt POUs, GVLs, Datentypdeklarationen oder Schnittstellen, die keinen Code enthalten. Begründung: Leere Objekte sollten vermieden werden. Sie sind oft ein Zeichen dafür dass ein Objekt nicht vollständig implementiert ist. Ausnahme: In manchen Fällen wird man dem Rumpf eines Funktionsblocks keinen Code geben, wenn dieser nur über Schnittstellen verwendet werden soll. In anderen Fällen wird man eine Methode nur anlegen, weil sie von einer Schnittstelle gefordert wird, ohne dass für die Methode eine sinnvolle Implementierung möglich ist. In jedem Fall sollte eine solche Situation kommentiert werden. Wichtiigkeit: Mittel " }, 
{ "title" : "SA0003: Leere Anweisungen ", 
"url" : "_san_rule_sa0003.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0003: Leere Anweisungen ", 
"snippet" : "Ermittelt Codezeilen, die einen Strichpunkt ; , aber keine Anweisung enthalten. Begründung: Eine leere Anweisung kann ein Zeichen für fehlenden Code sein. Hinweis: Es gibt sinnvolle Verwendungen leerer Anweisungen. Beispielsweise kann es sinnvoll sein, in einer CASE -Anweisung alle Fälle explizit au...", 
"body" : "Ermittelt Codezeilen, die einen Strichpunkt ; , aber keine Anweisung enthalten. Begründung: Eine leere Anweisung kann ein Zeichen für fehlenden Code sein. Hinweis: Es gibt sinnvolle Verwendungen leerer Anweisungen. Beispielsweise kann es sinnvoll sein, in einer CASE -Anweisung alle Fälle explizit auszuprogrammieren, auch die, in denen nichts zu tun ist. Wenn eine solche leere CASE -Anweisung mit einem Kommentar versehen ist, erzeugt die statische Codeanalyse keine Fehlermeldung. Wichtigkeit: niedrig Beispiel CASE value OF\n 1:\n DoSomething();\n 2:\n ;\n 3:\n DoSomethingElse();\nEND_CASE\n Ausgabe unter Ansicht Meldungen : SA0003: Leere Anweisungen CASE value OF\n 1:\n DoSomething();\n 2:\n ; \/\/nothing to do\n 3:\n DoSomethingElse();\nEND_CASE\n Ausgabe unter Ansicht Meldungen : Kein SA-Fehler " }, 
{ "title" : "SA0004: Mehrfacher Schreibzugriff auf Ausgang ", 
"url" : "_san_rule_sa0004.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0004: Mehrfacher Schreibzugriff auf Ausgang ", 
"snippet" : "Ermittelt Ausgänge, die an mehr als einer Position geschrieben werden. Begründung: Die Wartbarkeit leidet, wenn ein Ausgang an verschiedenen Stellen im Code geschrieben wird. Es ist dann unklar, welcher Schreibzugriff derjenige ist, der tatsächlich Auswirkungen im Prozess hat. Gute Praxis ist es, di...", 
"body" : "Ermittelt Ausgänge, die an mehr als einer Position geschrieben werden. Begründung: Die Wartbarkeit leidet, wenn ein Ausgang an verschiedenen Stellen im Code geschrieben wird. Es ist dann unklar, welcher Schreibzugriff derjenige ist, der tatsächlich Auswirkungen im Prozess hat. Gute Praxis ist es, die Berechnung der Ausgangsvariablen in Hilfsvariablen durchzuführen und an einer Stelle am Ende des Zyklus den berechneten Wert zuzuweisen. Wichtigkeit: Hoch PLCopen-Regel: CP12 Kein Fehler wird ausgegeben, wenn auf eine Ausgabevariable ( VAR_IN_OUT ) in verschiedenen Zweigen von IF oder CASE Anweisungen geschrieben wird. Diese Regel kann nicht über ein Pragma abgeschaltet werden. Beispiel VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW0 : INT ;\nEND_VAR PROGRAM PLC_PRG IF g_iCondition < INT#0 THEN\n g_xVar := TRUE;\n g_iTest := INT#12;\nEND_IF\n\nCASE g_iCondition OF\n INT#1:\n g_xVar := FALSE;\n INT#2:\n g_iTest := INT#11;\n ELSE\n g_xVar := TRUE;\n g_iTest := INT#9;\nEND_CASE\n Ausgabe unter Ansicht Meldungen : SA0004: Mehrfacher Schreibzugriff auf Ausgang '%QX0.0' SA0004: Mehrfacher Schreibzugriff auf Ausgang '%QW0' " }, 
{ "title" : "SA0006: Schreibzugriff aus mehreren Tasks ", 
"url" : "_san_rule_sa0006.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0006: Schreibzugriff aus mehreren Tasks ", 
"snippet" : "Ermittelt Variablen, auf die von mehr als einer Task geschrieben werden. Begründung: Eine Variable, die in mehreren Tasks geschrieben wird, kann unter Umständen ihren Wert unerwartet ändern. Das kann zu verwirrenden Situationen führen. Stringvariablen und auf einigen 32-Bit-Systemen auch 64-Bit-Inte...", 
"body" : "Ermittelt Variablen, auf die von mehr als einer Task geschrieben werden. Begründung: Eine Variable, die in mehreren Tasks geschrieben wird, kann unter Umständen ihren Wert unerwartet ändern. Das kann zu verwirrenden Situationen führen. Stringvariablen und auf einigen 32-Bit-Systemen auch 64-Bit-Integer-Variablen können sogar einen inkonsistenten Zustand bekommen, wenn die Variable gleichzeitig in zwei Tasks geschrieben wird. Ausnahme: In bestimmten Fällen kann es nötig sein, dass mehrere Tasks eine Variable schreiben. Stellen Sie dann sicher, beispielsweise durch die Verwendung von Semaphoren, dass der Zugriff nicht zu einem inkonsistenten Zustand führt. Wichtigkeit: Hoch PLCopen-Regel: CP10 Beispiel VAR_GLOBAL\n g_iTemp1: INT;\nEND_VAR PROGRAM PLC_PRG \/\/ Controlled by MainTask\ng_iTemp1 := g_iTemp1 + INT#2;\n PROGRAM PLC_PRG_1 \/\/Controlled by SubTask\ng_iTemp1 := g_iTemp1 - INT#3; Ausgabe unter Ansicht Meldungen : SA0006: Gleichzeitiger Schreibzugriff auf 'g_iTemp1' in Tasks MainTask, SubTask " }, 
{ "title" : "SA0007: Adressoperator auf Konstanten ", 
"url" : "_san_rule_sa0007.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0007: Adressoperator auf Konstanten ", 
"snippet" : "Ermittelt Codezeilen, an denen der Operator ADR bei einer Konstanten angewendet wird. Begründung: Durch einen Pointer auf eine konstante Variable hebt man die CONSTANT -Eigenschaft der Variable auf. Über den Pointer kann die Variable verändert werden, ohne dass der Compiler dies meldet. Ausnahme: In...", 
"body" : "Ermittelt Codezeilen, an denen der Operator ADR bei einer Konstanten angewendet wird. Begründung: Durch einen Pointer auf eine konstante Variable hebt man die CONSTANT -Eigenschaft der Variable auf. Über den Pointer kann die Variable verändert werden, ohne dass der Compiler dies meldet. Ausnahme: In seltenen Fällen kann es sinnvoll sein, einen Pointer auf eine Konstante an eine Funktion zu übergeben. Es muss dann allerdings gewährleistet sein, dass diese Funktion den übergebenen Wert nicht ändert. Verwenden Sie wenn möglich VAR_IN_OUT CONSTANT . Wichtigkeit: Hoch Wenn die Option Konstanten ersetzen in den Compileroptionen der Projekteinstellungen aktiviert ist, ist der Adressoperator für skalare Konstanten (Integer, BOOL , REAL ) nicht erlaubt und ein Übersetzungsfehler wird ausgegeben. (Konstante Strings, Strukturen und Arrays haben immer eine Adresse.) Beispiel PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n poiValue : POINTER TO INT;\nEND_VAR\n poiValue := ADR(c_iValue); \/\/ SA0007 Ausgabe unter Ansicht Meldungen : SA0007: Adressoperator auf konstante Variable 'c_iValue' " }, 
{ "title" : "SA0008: Unterbereichstypen prüfen ", 
"url" : "_san_rule_sa0008.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0008: Unterbereichstypen prüfen ", 
"snippet" : "Ermittelt Bereichsüberschreitungen von Unterbereichstypen. Zugewiesene Literale werden bereits vom Compiler geprüft. Wenn Konstanten zugeordnet sind, müssen die Werte innerhalb des definierten Bereichs liegen. Wenn Variablen zugeordnet sind, müssen die Datentypen identisch sein. Begründung: Wenn Unt...", 
"body" : "Ermittelt Bereichsüberschreitungen von Unterbereichstypen. Zugewiesene Literale werden bereits vom Compiler geprüft. Wenn Konstanten zugeordnet sind, müssen die Werte innerhalb des definierten Bereichs liegen. Wenn Variablen zugeordnet sind, müssen die Datentypen identisch sein. Begründung: Wenn Unterbereichstypen verwendet werden, dann sollte sichergestellt werden, dass dieser Unterbereich nicht verlassen wird. Der Compiler überprüft solche Unterbereichsverletzungen nur für Zuweisungen von Konstanten. Wichtigkeit: Niedrig Die Prüfung wird nicht für CFC-Objekte durchgeführt, da die Codestruktur dies nicht zulässt. Beispiel VAR_GLOBAL\n iVarGlob:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iSubr1: INT (INT#1..INT#10);\n iSubr2: INT (INT#1..INT#1000);\n iCount: INT;\n by_SubType : BYTE (BYTE#0..BYTE#11);\n iVar : INT (-4095..4095);\nEND_VAR\n iSubr1 := nCount; \/\/ SA0008\niSubr1 := subr2; \/\/ SA0008\niSubr1 := gvl.iVarGlob; \/\/ SA0008\n\/\/byBYTE_SubType := BYTE#123; \/\/already detected by compiler, error \"Cannot convert type...\" Ausgabe unter Ansicht Meldungen : SA0008: Unterbereichsvariable 'iSubr1' eventuell außerhalb des zulässigen Bereichs " }, 
{ "title" : "SA0009: Nicht verwendete Rückgabewerte ", 
"url" : "_san_rule_sa0009.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0009: Nicht verwendete Rückgabewerte ", 
"snippet" : "Ermittelt Funktions-, Methoden- und Eigenschaftenaufrufe, bei denen der Rückgabewert nicht verwendet wird. Begründung: Wenn eine Funktion oder eine Methode einen Rückgabewert liefert, sollten Sie diesen auch auswerten. Häufig wird im Rückgabewert mitgeliefert, ob die Funktion erfolgreich ausgeführt ...", 
"body" : "Ermittelt Funktions-, Methoden- und Eigenschaftenaufrufe, bei denen der Rückgabewert nicht verwendet wird. Begründung: Wenn eine Funktion oder eine Methode einen Rückgabewert liefert, sollten Sie diesen auch auswerten. Häufig wird im Rückgabewert mitgeliefert, ob die Funktion erfolgreich ausgeführt wurde. Wenn keine Auswertung erfolgt, kann man später nicht mehr erkennen, ob der Rückgabewert übersehen wurde, oder ob er tatsächlich nicht benötigt wird. Ausnahme: Wenn ein Rückgabewert beim Aufruf nicht von Interesse ist, sollten Sie dies dokumentieren und die Zuweisung weglassen. Fehlerrückgaben sollten nie ignoriert werden! Wichtigkeit: Mittel PLCopen-Regel: CP7\/CP17 Beispiel FUNCTION Return_BOOL : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n    xTest : BOOL;\nEND_VAR xTest := FALSE;\nReturn_BOOL := xTest; PROGRAM PLC_PRG\nReturn_BOOL();  \/\/ SA0009\n Ausgabe unter Ansicht Meldungen : SA0009: Rückgabewert von 'Return_BOOL' wird ignoriert " }, 
{ "title" : "SA0010: Arrays mit nur einer Komponente ", 
"url" : "_san_rule_sa0010.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0010: Arrays mit nur einer Komponente ", 
"snippet" : "Ermittelt Arrays mit nur einer Komponente. Begründung: Ein Array mit 1 Komponente kann durch eine Variable vom Basistyp ersetzt werden. Der Zugriff auf diese Variable ist deutlich schneller als der Zugriff mit Index auf eine Variable. Ausnahme: Häufig wird die Länge eines Arrays über eine Konstante ...", 
"body" : "Ermittelt Arrays mit nur einer Komponente. Begründung: Ein Array mit 1 Komponente kann durch eine Variable vom Basistyp ersetzt werden. Der Zugriff auf diese Variable ist deutlich schneller als der Zugriff mit Index auf eine Variable. Ausnahme: Häufig wird die Länge eines Arrays über eine Konstante festgelegt und ist ein Parameter für ein Programm. Das Programm kann dann mit Arrays von verschiedener Länge arbeiten und muss nicht geändert werden, wenn die Länge nur 1 beträgt. Eine solche Situation sollte entsprechend dokumentiert werden. Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG\nVAR\n aoiEmpty : ARRAY [22..22] OF INT := [22];\n aorEmpty : ARRAY [2..2] OF REAL := [2.2];\n iVar : INT;\n rVAR : REAL;\nEND_VAR iVar := aoiEmpty[22];\nrVAR := aorEmpty[2];\n Ausgabe unter Ansicht Meldungen : SA0010: Nicht sinnvolles Arrayelement in Variable'aoiEmpty' SA0010: Nicht sinnvolles Arrayelement in Variable'aorEmpty' " }, 
{ "title" : "SA0011: Nutzlose Deklaration mit nur einer einzigen Komponente ", 
"url" : "_san_rule_sa0011.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0011: Nutzlose Deklaration mit nur einer einzigen Komponente ", 
"snippet" : "Ermittelt Strukturen oder Enumerationen mit nur einer einzigen Komponente. Begründung: Es sollten keine Strukturen oder Enumerationen mit nur einer einzigen Komponente deklariert werden. Solche Deklarationen können für Leser verwirrend sein. Eine Struktur mit nur einem Element kann durch einen Alias...", 
"body" : "Ermittelt Strukturen oder Enumerationen mit nur einer einzigen Komponente. Begründung: Es sollten keine Strukturen oder Enumerationen mit nur einer einzigen Komponente deklariert werden. Solche Deklarationen können für Leser verwirrend sein. Eine Struktur mit nur einem Element kann durch einen Aliastyp ersetzt werden. Eine Enumeration mit einem Element kann durch eine Konstante ersetzt werden. PLCopen-Regel: CP22\/CP24 Wichtigkeit: Niedrig Beispiel {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE TYPE SINGLE_UNION :\nUNION\n\tlrValue : LREAL;\nEND_UNION\nEND_TYPE {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE Ausgabe unter Ansicht Meldungen : SA0011: Nutzlose Deklaration 'SINGLE_ENUM': Struct\/Enum mit nur einer einzigen Komponente sollte nicht verwendet werden SA0011: Nutzlose Deklaration 'SINGLE_UNION': Struct\/Enum mit nur einer einzigen Komponente sollte nicht verwendet werden SA0011: Nutzlose Deklaration 'SINGLE_STRUCT': Struct\/Enum mit nur einer einzigen Komponente sollte nicht verwendet werden " }, 
{ "title" : "SA0012: Variablen, die als Konstanten deklariert werden könnten ", 
"url" : "_san_rule_sa0012.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0012: Variablen, die als Konstanten deklariert werden könnten ", 
"snippet" : "Ermittelt Variablen, auf die nicht schreibend zugegriffen wird und die deshalb als Konstanten deklariert werden könnten. Begründung: Wenn eine Variable nur an der Deklarationsstelle geschrieben und sonst nur lesend verwendet wird, nimmt die statische Analyse an, dass die Variable auch nicht geändert...", 
"body" : "Ermittelt Variablen, auf die nicht schreibend zugegriffen wird und die deshalb als Konstanten deklariert werden könnten. Begründung: Wenn eine Variable nur an der Deklarationsstelle geschrieben und sonst nur lesend verwendet wird, nimmt die statische Analyse an, dass die Variable auch nicht geändert werden soll. Eine Deklaration als Konstante führt dann erstens dazu, dass auch bei Programmänderungen überprüft wird, dass die Variable nicht verändert wird. Zweitens führt die Deklaration als Konstante unter Umständen zu schnellerem Code. Wenn in einem Projekt mehrere Applikationen vorhanden sind, werden nur die Objekte unter der gerade aktiven Applikation berücksichtigt. Wenn es nur eine einzige Applikation gibt, werden auch die Objekte im allgemeinen POUs-Pool betrachtet. Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG\nVAR\n iVar : INT := INT#17;\n iTest : INT;\nEND_VAR\n iTest := iTest + iVar; \/\/ SA0012: 'iVar' could be declared as constant Ausgabe unter Ansicht Meldungen : SA0012: Variable 'iVar' könnte als Konstante deklariert werden " }, 
{ "title" : "SA0013: Deklarationen mit gleichem Variablennamen ", 
"url" : "_san_rule_sa0013.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0013: Deklarationen mit gleichem Variablennamen ", 
"snippet" : "Ermittelt Variablen, deren Name bereits von anderen Variablen verwendet wird (beispielsweise globale und lokale Variablen mit gleichen Namen). Äußerem werden Variablen ermittelt, deren Namen von Funktionen, Aktionen, Methoden oder Eigenschaften innerhalb des gleichen Zugriffsbereichs verwendet werde...", 
"body" : "Ermittelt Variablen, deren Name bereits von anderen Variablen verwendet wird (beispielsweise globale und lokale Variablen mit gleichen Namen). Äußerem werden Variablen ermittelt, deren Namen von Funktionen, Aktionen, Methoden oder Eigenschaften innerhalb des gleichen Zugriffsbereichs verwendet werden. Es werden auch Variablen erkannt, die in einer GVL in der Ansicht Geräte und in einer GVL im POUs-Pool deklariert sind. Dafür muss jedoch die GVL der Ansicht POUs im Applikationsprogramm verwendet werden. Begründung: Gleiche Namen können beim Lesen des Codes verwirrend sein, und sie können zu Fehlern führen, wenn unbeabsichtigt auf das falsche Objekt zugegriffen wird. Es wird empfohlen, Namenskonventionen zu verwenden, deren Einhaltung solche Situationen vermeidet. PLCopen-Regel: N5\/N9 Wichtigkeit: Mittel Beispiel VAR_GLOBAL\n xVar1 : BOOL;\n iVar3 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n xVar1 : BOOL; \/\/ SA0013\n iVar3 : INT; \/\/ SA0013\nEND_VAR\n xVar1 := NOT GVL.xVar1;\niVar3 := iVar3 + INT#2;\niVar3 := GVL.iVar3; Ausgabe unter Ansicht Meldungen : SA0013: Deklaration von 'iVar1' verdeckt Symbol 'GVL.iVar1' SA0013: Deklaration von 'xVar3' verdeckt Symbol 'GVL.xVar3' Beispiel Funktionsbaustein FB_Pou hat die Aktion ACT und die Methode METH und lokale Variablen mit gleichen Namen. FUNCTION_BLOCK FB_Pou\nVAR\n ACT : UINT; \/\/ SA0013\n METH : BYTE; \/\/ SA0013\nEND_VAR PROGRAM PLC_PRG\nVAR\n fbPou : FB_Pou;\nEND_VAR\n fbPou(); Ausgabe unter Ansicht Meldungen : SA0013: Deklaration von 'ACT' verdeckt Symbol 'FB_Pou.ACT' SA0013: Deklaration von 'METH' verdeckt Symbol 'FB_Pou.METH' " }, 
{ "title" : "SA0014: Zuweisungen auf Instanzen ", 
"url" : "_san_rule_sa0014.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0014: Zuweisungen auf Instanzen ", 
"snippet" : "Ermittelt Zuweisungen auf Funktionsbaustein-Instanzen. Bei Instanzen mit Pointer- oder Referenzvariablen können diese Zuweisungen riskant sein. Begründung: Dies ist eine Performance-Warnung. Wenn eine Instanz einer anderen Instanz zugewiesen wird, dann werden alle Elemente und Unterelemente von der ...", 
"body" : "Ermittelt Zuweisungen auf Funktionsbaustein-Instanzen. Bei Instanzen mit Pointer- oder Referenzvariablen können diese Zuweisungen riskant sein. Begründung: Dies ist eine Performance-Warnung. Wenn eine Instanz einer anderen Instanz zugewiesen wird, dann werden alle Elemente und Unterelemente von der einen Instanz in die andere kopiert. Pointer auf Daten werden mitkopiert, jedoch nicht deren referenzierte Daten, so dass die Zielinstanz und die Quellinstanz nach der Zuweisung die gleichen Daten enthalten. Je nach Größe der Instanzen kann eine solche Zuweisung sehr lange dauern. Wenn eine Instanz beispielsweise zur Bearbeitung an eine Funktion übergeben werden soll, dann ist es sehr viel performanter, einen Pointer auf die Instanz zu übergeben. Will man selektiv Werte von einer Instanz in eine andere kopieren, dann kann eine Kopiermethode sinnvoll sein: inst_First.Copy_From(inst_Second) Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG\nVAR\n inst_First : My_FB;\n inst_Second : My_FB;\nEND_VAR\n inst_First();\ninst_Second := inst_First; \/\/ SA0014 Ausgabe unter Ansicht Meldungen : SA0014: Zuweisung von Instanzen " }, 
{ "title" : "SA0015: Zugriff auf globale Daten über FB_Init ", 
"url" : "_san_rule_sa0015.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0015: Zugriff auf globale Daten über FB_Init ", 
"snippet" : "Ermittelt Zugriffe eines Funktionsbausteins auf globale Variablen über die Methode FB_Init . Der Wert dieser Variablen hängt von der Reihenfolge der Initialisierungen ab! Begründung: Je nach Deklarationsstelle der Instanz eines Bausteins kann es sein dass bei Verletzung der Regel auf eine uninitiali...", 
"body" : "Ermittelt Zugriffe eines Funktionsbausteins auf globale Variablen über die Methode FB_Init . Der Wert dieser Variablen hängt von der Reihenfolge der Initialisierungen ab! Begründung: Je nach Deklarationsstelle der Instanz eines Bausteins kann es sein dass bei Verletzung der Regel auf eine uninitialisierte Variable zugegriffen wird. Wichtigkeit: Hoch Beispiel VAR_GLOBAL\n g_xTest1 : BOOL;\n g_iTest3 : INT;\nEND_VAR METHOD PUBLIC fb_init : BOOL\nVAR_INPUT\n (* If TRUE, the retain variables are initialized (warm start \/ cold start) *)\n bInitRetains : BOOL; \n (* If TRUE, the instance afterwards gets moved into the copy code (online change) *)\n bInCopyCode : BOOL; \nEND_VAR\n g_xTest1 := NOT g_xTest1; \/\/ SA0015\ng_iTest3 := g_iTest3 + INT#1; \/\/ SA0015 Ausgabe unter Ansicht Meldungen : SA0015: FB_Init-Methode des Funktionsbausteins 'POU' greift auf globale Daten zu " }, 
{ "title" : "SA0016: Lücken in Strukturen ", 
"url" : "_san_rule_sa0016.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0016: Lücken in Strukturen ", 
"snippet" : "Ermittelt Lücken in Strukturen oder Funktionsbausteinen, verursacht durch die Alignment-Anforderungen des aktuell eingestellten Zielsystems. Wenn möglich, sollten Sie die Lücken durch Umsortieren der Strukturelemente oder durch Auffüllen mit einem Dummy-Element entfernen. Wenn dies nicht möglich ist...", 
"body" : "Ermittelt Lücken in Strukturen oder Funktionsbausteinen, verursacht durch die Alignment-Anforderungen des aktuell eingestellten Zielsystems. Wenn möglich, sollten Sie die Lücken durch Umsortieren der Strukturelemente oder durch Auffüllen mit einem Dummy-Element entfernen. Wenn dies nicht möglich ist, dann können Sie die Regel für die betroffenen Strukturen durch das Pragma analysis deaktivieren. Begründung: durch unterschiedliche Alignment-Anforderungen auf verschiedenen Plattformen, kann es zu einem unterschiedlichen Layout im Speicher kommen für solche Strukturen. Der Code kann sich dann unterschiedlich verhalten, je nach Plattform. Wichtigkeit: Niedrig Beispiel TYPE Unpadded_Structure :\nSTRUCT\n xTest : BOOL;\n iTest : INT; \/\/ SA0016\n byTest : BYTE;\n wTest : WORD;\nEND_STRUCT\nEND_TYPE\n PROGRAM PLC_PRG\nVAR\n myStruct : Unpadded_Structure;\nEND_VAR\n myStruct.iTest := 0; Ausgabe unter Ansicht Meldungen : SA0016: Struktur 'Unpadded_Structure' muss aufgefüllt werden (Pack Modus=8) " }, 
{ "title" : "SA0017: Nicht-reguläre Zuweisungen auf Pointer-Variable ", 
"url" : "_san_rule_sa0017.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0017: Nicht-reguläre Zuweisungen auf Pointer-Variable ", 
"snippet" : "Ermittelt Zuweisungen auf Pointer, die keine Adresse (Operator ADR oder Zeigervariablen) oder Konstante 0 sind. Begründung: Wenn ein Pointer einen Wert zugewiesen erhält, der keine gültige Adresse ist, führt die Dereferenzierung des Pointers zu einer \"Access Violation Exception\" (Exception bei Zugri...", 
"body" : "Ermittelt Zuweisungen auf Pointer, die keine Adresse (Operator ADR oder Zeigervariablen) oder Konstante 0 sind. Begründung: Wenn ein Pointer einen Wert zugewiesen erhält, der keine gültige Adresse ist, führt die Dereferenzierung des Pointers zu einer \"Access Violation Exception\" (Exception bei Zugriffsverletzung). Wichtigkeit: Hoch Beispiel PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n dwAddress : DWORD;\nEND_VAR\n dwAddress := dwAddress + DWORD#1;\npInt := dwAddress; \/\/ SA0017 Ausgabe unter Ansicht Meldungen : SA0017: Nicht reguläre Zuweisung auf Pointer-Variable " }, 
{ "title" : "SA0018: Unübliche Bitzugriffe ", 
"url" : "_san_rule_sa0018.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0018: Unübliche Bitzugriffe ", 
"snippet" : "Ermittelt Bitzugriffe auf vorzeichenbehaftete Variablen. Die Norm IEC 61131-3 erlaubt allerdings nur Bitzugriffe und Schiebeoperationen (\"bitshift\") auf Bitfelder. Siehe hierzu auch die strikten Regeln SA0147 und SA0148 . Begründung: Vorzeichenbehaftete Datentypen sollten nicht als Bitfelder verwend...", 
"body" : "Ermittelt Bitzugriffe auf vorzeichenbehaftete Variablen. Die Norm IEC 61131-3 erlaubt allerdings nur Bitzugriffe und Schiebeoperationen (\"bitshift\") auf Bitfelder. Siehe hierzu auch die strikten Regeln SA0147 und SA0148 . Begründung: Vorzeichenbehaftete Datentypen sollten nicht als Bitfelder verwendet werden und umgekehrt. Die Norm IEC 61131-3 sieht solche Zugriffe nicht vor, und daher sollte man diese Regel einhalten wenn man portierbaren Code schreiben will. Wichtigkeit: Mittel Ausnahme für Flag-Enumerationen: Wenn eine Enumeration mit Hilfe des Pragmaattributs {attribute 'flags'} als Flag deklariert ist, wird für Bitzugriffe mit den Operationen OR , AND oder NOT der Fehler SA0018 nicht ausgegeben. Beispiel PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/SA0018\ndiTemp3.4 := TRUE; \/\/SA0018\nuliTemp4.18 := FALSE; \/\/no error because this is an unsigned data type\nsiTemp5.2 := FALSE; \/\/SA0018\nusiTemp6.3 := TRUE; \/\/no error because this is an unsigned data type\nbyTemp2.5 := FALSE; \/\/no error because the byte is a bitfield Ausgabe unter Ansicht Meldungen : SA0018: Unübliche Bitzugriffe " }, 
{ "title" : "SA0020: Möglicherweise Zuweisung eines abgeschnittenen Werts an REAL-Variable ", 
"url" : "_san_rule_sa0020.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0020: Möglicherweise Zuweisung eines abgeschnittenen Werts an REAL-Variable ", 
"snippet" : "Ermittelt Operationen auf Integervariablen, bei denen möglicherweise ein abgeschnittener Wert einer Variablen vom Datentyp REAL zugewiesen wird. Begründung: Die statische Codeanalyse gibt einen Fehler aus, wenn das Ergebnis einer Integerberechnung einer REAL - oder LREAL -Variablen zugewiesen wird. ...", 
"body" : "Ermittelt Operationen auf Integervariablen, bei denen möglicherweise ein abgeschnittener Wert einer Variablen vom Datentyp REAL zugewiesen wird. Begründung: Die statische Codeanalyse gibt einen Fehler aus, wenn das Ergebnis einer Integerberechnung einer REAL - oder LREAL -Variablen zugewiesen wird. Der Programmierer soll dabei auf eine möglicherweise fehlerhafte Interpretation einer solchen Zuweisung aufmerksam gemacht werden: lrealvar := dintvar1 * dintvar2 . Da der Wertebereich von LREAL größer ist als der von DINT , könnte man annehmen, das Ergebnis der Rechnung würde in jedem Fall in LREAL dargestellt werden können. Das ist aber nicht der Fall. Der Prozessor berechnet das Ergebnis der Multiplikation als Integer und castet anschließend das Ergebnis nach LREAL . Ein Überlauf in der Integer-Berechnung würde verloren gehen. Wenn man das Problem umgehen will, dann muss die Rechnung bereits als REAL -Operation erfolgen: lreal_var := TO_LREAL(dintvar1) * TO_LREAL(dintvar2) Wichtigkeit: Hoch Beispiel PROGRAM PLC_PRG\nVAR\n rX : LREAL;\n dI : DINT;\nEND_VAR\n rX := dI * dI \/\/ SA0020\nrX := TO_LREAL(dI) * TO_LREAL(dI) \/\/no message Ausgabe unter Ansicht Meldungen : SA0020: Möglicherweise Zuweisung eines abgeschnittenen Werts an REAL-Variable " }, 
{ "title" : "SA0021: Weitergabe der Adresse einer temporären Variable ", 
"url" : "_san_rule_sa0021.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0021: Weitergabe der Adresse einer temporären Variable ", 
"snippet" : "Ermittelt Zuweisungen von Adressen von temporären Variablen (Variablen auf dem Stack) zu nicht-temporären Variablen. Begründung: Lokale Variablen einer Funktion oder einer Methode werden auf dem Stack angelegt und existieren nur während der Abarbeitung der Funktion oder Methode. Wenn ein Pointer nac...", 
"body" : "Ermittelt Zuweisungen von Adressen von temporären Variablen (Variablen auf dem Stack) zu nicht-temporären Variablen. Begründung: Lokale Variablen einer Funktion oder einer Methode werden auf dem Stack angelegt und existieren nur während der Abarbeitung der Funktion oder Methode. Wenn ein Pointer nach Abarbeitung der Methode oder Funktion auf eine solche Variable zeigt, dann kann man über diesen Pointer in undefinierten Speicher greifen, oder auf eine falsche Variable in einer anderen Funktion zugreifen. Diese Situation ist in jedem Fall zu vermeiden. Wichtigkeit: Hoch Beispiel FUNCTION TempVarInFUNC : DWORD\nVAR\n uiTemp : UINT;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0021 PROGRAM PLC_PRG\nVAR\n dwTest : DWORD;\nEND_VAR dwTest := TempVarInFUNC(); Ausgabe unter Ansicht Meldungen : SA0021: Adresse einer temporären Variable wird auf ein Symbol übertragen, das außerhalb des gültigen Bereichs liegt " }, 
{ "title" : "SA0022: (Möglicherweise) nicht zugewiesene Rückgabewerte ", 
"url" : "_san_rule_sa0022.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0022: (Möglicherweise) nicht zugewiesene Rückgabewerte ", 
"snippet" : "Ermittelt alle Funktionen und Methoden, die einen Ausführungsstrang ohne Zuweisung auf den Rückgabewert enthalten. Begründung: Ein nicht zugewiesener Rückgabewert in einer Funktion oder Methode deutet auf fehlenden Code hin. Auch wenn der Rückgabewert in jedem Fall einen Standardwert hat, ist es imm...", 
"body" : "Ermittelt alle Funktionen und Methoden, die einen Ausführungsstrang ohne Zuweisung auf den Rückgabewert enthalten. Begründung: Ein nicht zugewiesener Rückgabewert in einer Funktion oder Methode deutet auf fehlenden Code hin. Auch wenn der Rückgabewert in jedem Fall einen Standardwert hat, ist es immer sinnvoll, diesen nochmal explizit zuzuweisen um Unklarheiten zu vermeiden. Wichtigkeit: Mittel Beispiel FUNCTION FUN : DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR\n IF bTest THEN\n RETURN;\nEND_IF\nFUN := 99; Ausgabe unter Ansicht Meldungen : SA0022: Möglicherweise nicht zugewiesene Rückgabewerte " }, 
{ "title" : "SA0023: Komplexe Rückgabewerte ", 
"url" : "_san_rule_sa0023.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0023: Komplexe Rückgabewerte ", 
"snippet" : "Ermittelt komplexe Rückgabewerte, die mit einer einfachen Registerkopie des Prozessors nicht zurückgegeben werden können. Dazu gehören Strukturen, Arrays und Rückgabewerte vom Typ STRING (unabhängig von der Größe des belegten Speicherplatzes). Begründung: Dies ist eine Performance-Warnung. Wenn groß...", 
"body" : "Ermittelt komplexe Rückgabewerte, die mit einer einfachen Registerkopie des Prozessors nicht zurückgegeben werden können. Dazu gehören Strukturen, Arrays und Rückgabewerte vom Typ STRING (unabhängig von der Größe des belegten Speicherplatzes). Begründung: Dies ist eine Performance-Warnung. Wenn große Werte als Ergebnis einer Funktion, Methode oder einer Eigenschaft zurückgeliefert werden, dann werden diese vom Prozessor bei der Ausführung des Codes mehrfach kopiert. Das kann zu Laufzeitproblemen führen und sollte wenn möglich vermieden werden. Bessere Performance erreicht man, wenn ein strukturierter Wert als VAR_IN_OUT an eine Funktion oder Methode übergeben wird und in der Funktion oder Methode gefüllt wird. Wichtigkeit: Mittel Beispiel TYPE LargeStructure :\nSTRUCT\n a : LINT;\n b : BOOL;\nEND_STRUCT\nEND_TYPE\n FUNCTION Large_Return_Value_FUNC : LargeStructure \/\/ SA0023 Ausgabe unter Ansicht Meldungen : SA0023: Komplexe Rückgabewerte " }, 
{ "title" : "SA0024: Nicht typisierte Literale ", 
"url" : "_san_rule_sa0024.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0024: Nicht typisierte Literale ", 
"snippet" : "Identifiziert nicht typisierten Literale, die Teil einer Operation sind Begründung: Nicht typisierte Literale werden je nach ihrer Verwendung automatisch typisiert. In einigen Fällen wie beispielsweise dw := ROL(DWORD#1, i); kann dies zu unerwarteten Situationen führen, in denen es besser ist, eine ...", 
"body" : "Identifiziert nicht typisierten Literale, die Teil einer Operation sind Begründung: Nicht typisierte Literale werden je nach ihrer Verwendung automatisch typisiert. In einigen Fällen wie beispielsweise dw := ROL(DWORD#1, i); kann dies zu unerwarteten Situationen führen, in denen es besser ist, eine eindeutige Klärung durch Verwendung eines typisierten Literals zu erreichen. Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG\nVAR\n iTemp1 : INT := 10; \/\/no part of operation\n diTemp2 : DINT;\n liTemp3 : LINT;\n rTemp4 : REAL;\n lrTemp5 : LREAL;\n END_VAR iTemp1 := iTemp1 + INT#34;\ndiTemp2 := diTemp2 + 23; \/\/ SA0024\nliTemp3 := liTemp3 + 124; \/\/ SA0024\nrTemp4 := rTemp4 + 1.1; \/\/ SA0024\nlrTemp5 := lrTemp5 + 3.4; \/\/ SA0024\n Ausgabe unter Ansicht Meldungen : SA0024: Ungetyptes Literal gefunden " }, 
{ "title" : "SA0025: Unqualifizierte Enumerationskonstanten ", 
"url" : "_san_rule_sa0025.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0025: Unqualifizierte Enumerationskonstanten ", 
"snippet" : "Ermittelt Enumerationskonstanten, bei denen kein qualifizierter Name der Enumeration vorangestellt ist. Begründung: Qualifizierte Zugriffe machen den Code besser lesbar und besser wartbar. Ohne das Erzwingen qualifizierter Variablennamen könnte bei Erweiterung des Programms eine weitere Enumeration ...", 
"body" : "Ermittelt Enumerationskonstanten, bei denen kein qualifizierter Name der Enumeration vorangestellt ist. Begründung: Qualifizierte Zugriffe machen den Code besser lesbar und besser wartbar. Ohne das Erzwingen qualifizierter Variablennamen könnte bei Erweiterung des Programms eine weitere Enumeration eingefügt werden, die eine gleichnamige Konstante wie eine bereits existierende Enumeration enthält (siehe im Beispiel unten: „red“). Dann käme es zu einem uneindeutigen Zugriff in diesem Codestück. Wir empfehlen in jedem Fall nur Enumerationen zu verwenden, die das Pragma {attribute 'qualified-only'} tragen. Wichtigkeit: Mittel Beispiel TYPE COLOR :\n (red,\n green,\n blue);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n myColor : COLOR;\nEND_VAR\n myColor := COLOR.red; \/\/ OK\nmyColor := red; \/\/ SA0025 Ausgabe unter Ansicht Meldungen : SA0025: Aufzählungskonstante 'red' ist nicht qualifiziert Fr weitere Informationen siehe: Statische Codeanalyse konfigurieren und durchführen " }, 
{ "title" : "SA0026: Möglicherweise Abschneiden von Strings ", 
"url" : "_san_rule_sa0026.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0026: Möglicherweise Abschneiden von Strings ", 
"snippet" : "Ermittelt Stringzuweisungen und Stringinitialisierungen, die keine ausreichende Stringlänge verwenden. Begründung: Wenn Strings unterschiedlicher Länge zugewiesen werden, dann wird möglicherweise ein String abgeschnitten. Das Ergebnis ist dann nicht das erwartete. Wichtigkeit: Mittel Beispiel PROGRA...", 
"body" : "Ermittelt Stringzuweisungen und Stringinitialisierungen, die keine ausreichende Stringlänge verwenden. Begründung: Wenn Strings unterschiedlicher Länge zugewiesen werden, dann wird möglicherweise ein String abgeschnitten. Das Ergebnis ist dann nicht das erwartete. Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG\nVAR\n strVar1 : STRING[10];\n strVar2 : STRING[6];\n strVar3 : STRING[6] := 'abcdefghi'; \/\/ SA0026\nEND_VAR\n strVar2 := strVar1; \/\/ SA0026 Ausgabe unter Ansicht Meldungen : SA0026: Abschneiden von 'abcdefghi' SA0026: String 'strVar1' wird möglicherweise abgeschnitten Für weitere Informatinen siehe: Statische Codeanalyse konfigurieren und durchführen " }, 
{ "title" : "SA0027: Mehrfachverwendungen von Bezeichnern ", 
"url" : "_san_rule_sa0027.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0027: Mehrfachverwendungen von Bezeichnern ", 
"snippet" : "Ermittelt Mehrfachverwendung des Namens\/Bezeichners einer Variable oder eines Objekts (POU) innerhalb des Gültigkeitsbereichs eines Projekts. Bei Enumerationen wird der qualifizierte Name berücksichtigt. Begründung: Gleiche Namen können beim Lesen des Codes verwirrend sein. Sie können zu Fehlern füh...", 
"body" : "Ermittelt Mehrfachverwendung des Namens\/Bezeichners einer Variable oder eines Objekts (POU) innerhalb des Gültigkeitsbereichs eines Projekts. Bei Enumerationen wird der qualifizierte Name berücksichtigt. Begründung: Gleiche Namen können beim Lesen des Codes verwirrend sein. Sie können zu Fehlern führen, wenn unbeabsichtigt auf das falsche Objekt zugegriffen wird. Definieren und befolgen Sie deshalb Namenskonventionen zur Vermeidung solcher Situationen. Die folgenden Fälle werden abgedeckt: Der Name einer Enumerationskonstanten ist identisch mit dem Namen in einer anderen Enumeration innerhalb der Applikation oder in einer eingebundenen Bibliothek. Der Name einer Variablen ist identisch mit dem Namen eines anderen Objekts in der Applikation oder in einer eingebundenen Bibliothek. Der Name einer Variablen ist identisch mit dem Namen einer Enumerationskonstanten in einer Enumeration in der Applikation oder in einer eingebundenen Bibliothek. Der Name eines Objekts ist identisch mit dem Namen eines anderen Objekts in der Applikation oder in einer eingebundenen Bibliothek. Wichtigkeit: Mittel Beispiel TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n color : INT;\nEND_VAR\n Ausgabe unter Ansicht Meldungen : SA0027: Variablenname 'color' in 'PLC_PRG' wird bereits für ein Objekt in dieser Applikation verwendet Für weitere Informatinen siehe: Statische Codeanalyse konfigurieren und durchführen " }, 
{ "title" : "SA0028: Überlappende Speicherbereiche ", 
"url" : "_san_rule_sa0028.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0028: Überlappende Speicherbereiche ", 
"snippet" : "Ermittelt die Codestellen, durch die 2 oder mehr Variablen denselben Speicherplatz belegen. Begründung: Wenn zwei Variablen auf dem gleichen Speicherplatz liegen, kann sich der Code sehr unerwartet verhalten. Dies ist in jedem Fall zu vermeiden. Wenn es unumgänglich ist, einen Wert in verschiedenen ...", 
"body" : "Ermittelt die Codestellen, durch die 2 oder mehr Variablen denselben Speicherplatz belegen. Begründung: Wenn zwei Variablen auf dem gleichen Speicherplatz liegen, kann sich der Code sehr unerwartet verhalten. Dies ist in jedem Fall zu vermeiden. Wenn es unumgänglich ist, einen Wert in verschiedenen Interpretationen zu verwenden, zum Beispiel einmal als DINT und einmal als REAL , sollten Sie eine UNION definieren. Auch über einen Pointer können Sie auf einen Wert anders getypt zugreifen, ohne dass der Wert umgewandelt wird. Wichtigkeit: Hoch Beispiel PROGRAM PLC_PRG\nVAR\n iVvar1 AT %QB21: INT;\n dwVar2 AT %QD5: DWORD;\nEND_VAR\n Ausgabe unter Ansicht Meldungen : Die folgenden Variablen greifen auf denselben Speicher zu: SA0028: iVar1 AT %QB21 SA0028: dwVar2 AT %QD5 Für weitere Informatinen siehe: Statische Codeanalyse konfigurieren und durchführen " }, 
{ "title" : "SA0029: Notation in Implementierung und Deklaration unterschiedlich ", 
"url" : "_san_rule_sa0029.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0029: Notation in Implementierung und Deklaration unterschiedlich ", 
"snippet" : "Ermittelt die Codestellen, an denen die Notation eines Bezeichners unterschiedlich zur Notation in dessen Deklaration ist. Begründung: Die Norm IEC 61131-3 definiert Bezeichner als nicht case-sensitiv. Das heißt, eine Variable, die als „ varx “ deklariert wurde, kann im Code auch als „ VaRx “ verwen...", 
"body" : "Ermittelt die Codestellen, an denen die Notation eines Bezeichners unterschiedlich zur Notation in dessen Deklaration ist. Begründung: Die Norm IEC 61131-3 definiert Bezeichner als nicht case-sensitiv. Das heißt, eine Variable, die als „ varx “ deklariert wurde, kann im Code auch als „ VaRx “ verwendet werden. Dies ist jedoch verwirrend und irreführend und sollte vermieden werden. Wichtigkeit: Mittel Beispiel Im Gerätebaum gibt es einen Baustein PLC_PRG und einen Baustein fnc (Funktion). PROGRAM PLC_PRG\nVAR\n iVar: INT;\n _123test_var_: INT;\nEND_VAR\n ivar := iVar + 1; \/\/ SA0029\n_123TEST_var_ := _123test_var_; \/\/ SA0029\nFnc(); \/\/ SA0029 Ausgabe unter Ansicht Meldungen : SA0029: Notation in Code (ivar) muss der Deklaration (iVar) entsprechen SA0029: Notation in Code (_123TEST_var_) muss der Deklaration (_123test_var_) entsprechen SA0029: Notation in Code (Fnc) muss der Deklaration (fnc) entsprechen Für weitere Informatinen siehe: Statische Codeanalyse konfigurieren und durchführen " }, 
{ "title" : "Nicht verwendete Objekte auflisten ", 
"url" : "_san_list_unused_objects.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Nicht verwendete Objekte auflisten ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0031: Nicht verwendete Signaturen ", 
"url" : "_san_rule_sa0031.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Nicht verwendete Objekte auflisten \/ SA0031: Nicht verwendete Signaturen ", 
"snippet" : "Ermittelt Programme, Funktionsbausteine, Funktionen, Datentypen, Schnittstellen, Methoden, Eigenschaften und Aktionen, die nicht innerhalb des kompilierten Programmcodes aufgerufen werden. Begründung: Nicht verwendete Objekte vergrößern das Projekt unnötig und können beim Lesen des Codes verwirren. ...", 
"body" : "Ermittelt Programme, Funktionsbausteine, Funktionen, Datentypen, Schnittstellen, Methoden, Eigenschaften und Aktionen, die nicht innerhalb des kompilierten Programmcodes aufgerufen werden. Begründung: Nicht verwendete Objekte vergrößern das Projekt unnötig und können beim Lesen des Codes verwirren. Wichtigkeit: Niedrig PLCopen-Regel: CP2 Wenn es in einem Projekt mehrere Applikationen gibt, werden nur die Objekte unter der gerade aktiven Applikationen berücksichtigt. Wenn es nur eine einzige Applikation gibt, werden auch die Objekte im POUs-Pool betrachtet. Siehe auch Statische Codeanalyse konfigurieren und durchführen " }, 
{ "title" : "SA0032: Nicht verwendete Enumerationskonstanten ", 
"url" : "_san_rule_sa0032.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Nicht verwendete Objekte auflisten \/ SA0032: Nicht verwendete Enumerationskonstanten ", 
"snippet" : "Ermittelt Enumerationskonstanten, die nicht im kompilierten Programmcode verwendet werden. Begründung: Nicht verwendete Enumerationskonstanten vergrößern die Enumerationsdefinition unnötig und können beim Lesen des Programms verwirren. PLCopen-Regel: CP24 Wichtigkeit: Niedrig Wenn es in einem Projek...", 
"body" : "Ermittelt Enumerationskonstanten, die nicht im kompilierten Programmcode verwendet werden. Begründung: Nicht verwendete Enumerationskonstanten vergrößern die Enumerationsdefinition unnötig und können beim Lesen des Programms verwirren. PLCopen-Regel: CP24 Wichtigkeit: Niedrig Wenn es in einem Projekt mehrere Applikationen gibt, werden nur die Objekte unter der gerade aktiven berücksichtigt. Wenn es nur eine einzige Applikation gibt, werden auch die Objekte im allgemeinen POUs-Pool betrachtet. Beispiel TYPE My_Enum :\n(\n one := 1, \n two := 2\n);\nEND_TYPE\n Ausgabe unter Ansicht Meldungen : SA0032: Nicht verwendet: Aufzählungskonstante 'one' SA0032: Nicht verwendet: Aufzählungskonstante 'two' Für weitere Informatinen siehe: Statische Codeanalyse konfigurieren und durchführen " }, 
{ "title" : "SA0033: Nicht verwendete Variablen ", 
"url" : "_san_rule_sa0033.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Nicht verwendete Objekte auflisten \/ SA0033: Nicht verwendete Variablen ", 
"snippet" : "Ermittelt Variablen, die deklariert sind, aber innerhalb des kompilierten Programmcodes nicht verwendet werden. Begründung: Nicht verwendete Variablen machen ein Programm weniger gut lesbar und wartbar. Nicht verwendete Variablen belegen unnötig Speicher und kosten bei der Initialisierung unnötig La...", 
"body" : "Ermittelt Variablen, die deklariert sind, aber innerhalb des kompilierten Programmcodes nicht verwendet werden. Begründung: Nicht verwendete Variablen machen ein Programm weniger gut lesbar und wartbar. Nicht verwendete Variablen belegen unnötig Speicher und kosten bei der Initialisierung unnötig Laufzeit. Wichtigkeit: Mittel PLCopen-Regel: CP22 \/ CP24 Für GVL-Variablen: Wenn es in einem Projekt mehrere Applikationen gibt, werden nur die Objekte unter der gerade aktiven Applikation berücksichtigt. Wenn es nur eine einzige Applikation gibt, werden auch die Objekte im allgemeinen POUs-Pool betrachtet. Beispiel PROGRAM PLC_PRG\nVAR\n iCounter1 : INT;\n iCounter2 : INT; \/\/ SA0033\nEND_VAR\n iCounter1 := 100; Ausgabe unter Ansicht Meldungen : SA0033: Nicht verwendet: Variable 'iCounter2' Für weitere Informationen siehe: Statische Codeanalyse konfigurieren und durchführen " }, 
{ "title" : "SA0035: Nicht verwendete Eingabevariablen ", 
"url" : "_san_rule_sa0035.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Nicht verwendete Objekte auflisten \/ SA0035: Nicht verwendete Eingabevariablen ", 
"snippet" : "Ermittelt Eingangsvariablen, die von keiner Funktionsbaustein-Instanz verwendet werden. Begründung: Nicht verwendete Eingabevariablen machen ein Programm weniger gut lesbar und wartbar. Nicht verwendete Variablen belegen unnötig Speicher und kosten bei der Initialisierung unnötig Laufzeit. Ein Einga...", 
"body" : "Ermittelt Eingangsvariablen, die von keiner Funktionsbaustein-Instanz verwendet werden. Begründung: Nicht verwendete Eingabevariablen machen ein Programm weniger gut lesbar und wartbar. Nicht verwendete Variablen belegen unnötig Speicher und kosten bei der Initialisierung unnötig Laufzeit. Ein Eingang gilt nur dann als verwendet, wenn er innerhalb der Implementierung (oder der Methoden) der Funktionbaustein-Instanz selbst aktiv referenziert wird. Wichtigkeit: Mittel PLCopen-Regel: CP24 Beispiel FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\nEND_VAR iOut1 := iIn1; \/\/ iIn1 is used here PROGRAM PLC_PRG\nVAR\n fbAfb: FB_Afb;\nEND_VAR\n fbAfb(iIn2 := 99); \/\/ iIn2 is unused internally => error Ausgabe unter Ansicht Meldungen : SA0035: Nicht verwendet: Eingang 'iIn2' " }, 
{ "title" : "SA0036: Nicht verwendete Ausgabevariablen ", 
"url" : "_san_rule_sa0036.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Nicht verwendete Objekte auflisten \/ SA0036: Nicht verwendete Ausgabevariablen ", 
"snippet" : "Ermittelt Ausgangsvariablen von Funktionen und Funktionsbausteinen, die innerhalb der jeweiligen Funktion oder des Funktionsbausteins nicht zugewiesen werden. Begründung: Nicht verwendete Variablen machen ein Programm weniger gut lesbar und wartbar. Nicht verwendete Variablen belegen unnötig Speiche...", 
"body" : "Ermittelt Ausgangsvariablen von Funktionen und Funktionsbausteinen, die innerhalb der jeweiligen Funktion oder des Funktionsbausteins nicht zugewiesen werden. Begründung: Nicht verwendete Variablen machen ein Programm weniger gut lesbar und wartbar. Nicht verwendete Variablen belegen unnötig Speicher und kosten bei der Initialisierung unnötig Laufzeit. Wichtigkeit: Mittel PLCopen-Regel: CP24 Beispiel FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\n iOut2: INT;\nEND_VAR\n iOut1 := iIn1 + iIn2; Ausgabe unter Ansicht Meldungen : SA0036: Nicht verwendet: Ausgang 'iOut1' " }, 
{ "title" : "SA0034: Enumerationsvariablen mit falscher Zuweisung ", 
"url" : "_san_rule_sa0034.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0034: Enumerationsvariablen mit falscher Zuweisung ", 
"snippet" : "Ermittelt Werte, die einer Enumerationsvariablen zugewiesen sind. Es dürfen nur definierte Enumerationskonstanten einer Enumerationsvariablen zugewiesen sein. Begründung: Eine Variable vom Typ einer Enumeration sollte auch nur die vorgesehenen Werte haben, ansonsten funktioniert Code, der diese Vari...", 
"body" : "Ermittelt Werte, die einer Enumerationsvariablen zugewiesen sind. Es dürfen nur definierte Enumerationskonstanten einer Enumerationsvariablen zugewiesen sein. Begründung: Eine Variable vom Typ einer Enumeration sollte auch nur die vorgesehenen Werte haben, ansonsten funktioniert Code, der diese Variable verwendet möglicherweise nicht richtig. Wir empfehlen, Enumerationen immer mit dem Pragma {attribute 'strict'} zu verwenden. Dann prüft bereits der Compiler die korrekte Verwendung der Enumerationskomponenten. Wichtigkeit: Hoch Beispiel TYPE COLOR :\n(\n Red := 0,\n Green,\n Yellow\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n eColor1: COLOR;\nEND_VAR\n eColor1 := COLOR.Red;\neColor1 := 1; \/\/ SA0034 Ausgabe unter Ansicht Meldungen : SA0034: Enumerationswert anstelle 'INT#1' verwenden Für weitere Informatinen siehe: Statische Codeanalyse konfigurieren und durchführen " }, 
{ "title" : "SA0037: Schreibzugriff auf Eingabevariable ", 
"url" : "_san_rule_sa0037.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0037: Schreibzugriff auf Eingabevariable ", 
"snippet" : "Ermittelt Eingabevariablen ( VAR_INPUT ), auf die innerhalb des Bausteins schreibend zugegriffen wird. Begründung: Nach der Norm IEC 61131-3 darf eine Eingabevariable nicht innerhalb eines Bausteins verändert werden. Ein solcher Zugriff ist außerdem eine Fehlerquelle und macht den Code schlecht wart...", 
"body" : "Ermittelt Eingabevariablen ( VAR_INPUT ), auf die innerhalb des Bausteins schreibend zugegriffen wird. Begründung: Nach der Norm IEC 61131-3 darf eine Eingabevariable nicht innerhalb eines Bausteins verändert werden. Ein solcher Zugriff ist außerdem eine Fehlerquelle und macht den Code schlecht wartbar. Es weißt daraufhin, dass eine Variable als Eingang und gleichzeitig als Hilfsvariable verwendet wird. Eine solche Doppelverwendung sollte vermieden werden. Wichtigkeit: Mittel Beispiel VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL;\nEND_VAR PROGRAM PLC_PRG\nVAR_INPUT\n xVarIn1 : BOOL;\n xVarIn2 : BOOL;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_xGlob := xVarIn1;\n INT#2:\n g_xGlob := xVarIn2;\n ELSE\n g_xGlob := FALSE;\n xVarIn1 := FALSE; \/\/ SA0037\nEND_CASE Ausgabe unter Ansicht Meldungen : SA0037: Schreibzugriff auf Eingabevariable 'xVarIn1' " }, 
{ "title" : "SA0038: Lesezugriff auf Ausgabevariable ", 
"url" : "_san_rule_sa0038.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0038: Lesezugriff auf Ausgabevariable ", 
"snippet" : "Ermittelt Ausgangsvariablen ( VAR_OUTPUT ), auf die innerhalb der Bausteins lesend zugegriffen wird. Begründung: Nach 61131-3 ist es verboten, einen Ausgang innerhalb eines Bausteins zu lesen. Es weist darauf hin, dass der Ausgang nicht nur als Ausgang sondern gleichzeitig als temporäre Variable für...", 
"body" : "Ermittelt Ausgangsvariablen ( VAR_OUTPUT ), auf die innerhalb der Bausteins lesend zugegriffen wird. Begründung: Nach 61131-3 ist es verboten, einen Ausgang innerhalb eines Bausteins zu lesen. Es weist darauf hin, dass der Ausgang nicht nur als Ausgang sondern gleichzeitig als temporäre Variable für Zwischenergebnisse verwendet wird. Eine solche Doppelverwendung sollte vermieden werden. Wichtigkeit: Niedrig Beispiel VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL ;\n g_iGlob AT %QW1 : INT ;\nEND_VAR PROGRAM PLC_PRG\nVAR_OUTPUT\n xVarOut1:BOOL;\n xVarOut2:INT;\n xVarOut3:INT;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n xVarOut1 := g_xGlob;\n xVarOut2 := g_iGlob;\n INT#2:\n xVarOut3 := xVarOut2; \/\/ SA0038\n ELSE\n xVarOut1 := FALSE;\n g_xGlob := xVarOut1; \/\/ SA0038\n xVarOut2 := INT#0;\n xVarOut3 := INT#-1;\nEND_CASE Ausgabe unter Ansicht Meldungen : SA0038: Lesezugriff auf Ausgangsvariable 'xVarOUT2' SA0026: SA0038: Lesezugriff auf Ausgangsvariable 'xVarOUT1' " }, 
{ "title" : "SA0040: Mögliche Division durch Null ", 
"url" : "_san_rule_sa0040.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0040: Mögliche Division durch Null ", 
"snippet" : "Ermittelt Codestellen, an denen möglicherweise durch Null dividiert wird. Begründung: Durch 0 sollte nie dividiert werden. Eine Variable, durch die dividiert wird, sollte immer zuerst auf 0 überprüft werden. Wichtigkeit: Hoch Beispiel VAR_GLOBAL g_iVar AT %QW1 : INT; END_VAR PROGRAM PLC_PRG VAR iCou...", 
"body" : "Ermittelt Codestellen, an denen möglicherweise durch Null dividiert wird. Begründung: Durch 0 sollte nie dividiert werden. Eine Variable, durch die dividiert wird, sollte immer zuerst auf 0 überprüft werden. Wichtigkeit: Hoch Beispiel VAR_GLOBAL\n g_iVar AT %QW1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n iSumme:INT;\n iMid:INT;\n iVal1:INT := INT#2;\n iVal2:INT;\n iVal3:INT := INT#3;\n iVal4:INT := INT#4;\n iVal5:INT;\nEND_VAR IF iVal2 <> 0 THEN\n iVal1 := iVal1\/iVal2; \/\/ no error\nEND_IF;\niMid := iSumme \/ iCounter; \/\/ SA0040\niCounter := iCounter + INT#1;\niSumme := g_iVar + iSumme;\nIF iMid < INT#100 THEN\n iVal1 := iVal1 \/ iVal2; \/\/ SA0040\nEND_IF Ausgabe unter Ansicht Meldungen : SA0040: Möglicherweise Division durch Null SA0040: Möglicherweise Division durch Null " }, 
{ "title" : "SA0041: Möglicherweise schleifeninvarianter Code ", 
"url" : "_san_rule_sa0041.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0041: Möglicherweise schleifeninvarianter Code ", 
"snippet" : "Ermittelt Zuweisungen in Schleifen, die bei jedem Schleifendurchlauf den gleichen Wert berechnen. Solche Codezeilen könnten außerhalb der Schleife eingefügt werden. Begründung: Dies ist eine Performance-Warnung. Code, der in einer Schleife ausgeführt wird, aber in jedem Schleifendurchlauf das Gleich...", 
"body" : "Ermittelt Zuweisungen in Schleifen, die bei jedem Schleifendurchlauf den gleichen Wert berechnen. Solche Codezeilen könnten außerhalb der Schleife eingefügt werden. Begründung: Dies ist eine Performance-Warnung. Code, der in einer Schleife ausgeführt wird, aber in jedem Schleifendurchlauf das Gleiche tut, kann außerhalb der Schleife durchgeführt werden. Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG\nVAR\n iCounter, iVar1, iVar2 : INT;\nEND_VAR FOR iCounter := 0 TO 10 DO\n iVar1 := 100; \/\/ SA0041\n iVar2 := iVar2 + iVar1;\nEND_FOR\n Ausgabe unter Ansicht Meldungen : SAN0041: Möglicherweise schleifeninvarianter Code 'iVar1 := 100' " }, 
{ "title" : "SA0042: Verwendung unterschiedlicher Zugriffspfade ", 
"url" : "_san_rule_sa0042.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0042: Verwendung unterschiedlicher Zugriffspfade ", 
"snippet" : "Ermittelt die Verwendung unterschiedlicher Zugriffspfade für die gleiche Variable. Begründung: Unterschiedlicher Zugriff auf das gleiche Element reduziert die Lesbarkeit und Wartbarkeit eines Programms. Wir empfehlen die konsequente Verwendung von {attribute 'qualified-only'} für Bibliotheken, globa...", 
"body" : "Ermittelt die Verwendung unterschiedlicher Zugriffspfade für die gleiche Variable. Begründung: Unterschiedlicher Zugriff auf das gleiche Element reduziert die Lesbarkeit und Wartbarkeit eines Programms. Wir empfehlen die konsequente Verwendung von {attribute 'qualified-only'} für Bibliotheken, globale Variablenlisten und Enumerationen. Dadurch wird der vollqualifizierte Zugriff erzwungen. Wichtigkeit: Niedrig Beispiel VAR_GLOBAL\n iTemp:INT;\n instPOU:POU;\nEND_VAR FUNCTION_BLOCK POU\nVAR\n a:INT;\nEND_VAR\n a := INT#1; PROGRAM SA0042\nVAR\n ptiTemp:POINTER TO INT;\n sTemp:STRING;\nEND_VAR ptiTemp := ADR(iTemp);\n\nptiTemp^ := INT#1;\niTemp := INT#2; \/\/ SA0042 - direct access on variable\nGVL.iTemp := INT#3; \/\/ SA0042 - access on variable via GVL\n\nsTemp := CONCAT( 'ab', 'cd'); \/\/ SA0042 - direct access on function\nsTemp := Standard.CONCAT( 'ab', 'cd'); \/\/ SA0042 - access on function via Standard\n\ninstPOU(); \/\/ SA0042 - direct access on POU instance\nGVL.instPOU(); \/\/ SA0042 - access via GVL\n Ausgabe unter Ansicht Meldungen : SA0042: Unterschiedliche Zugriffspfade für 'CONCAT' SA0042: Unterschiedliche Zugriffspfade für 'Standard.CONCAT' SA0042: Unterschiedliche Zugriffspfade für 'instPOU' SA0042: Unterschiedliche Zugriffspfade für 'GVL.instPOU' SA0042: Unterschiedliche Zugriffspfade für 'iTemp' SA0042: Unterschiedliche Zugriffspfade für 'GVL.iTemp' " }, 
{ "title" : "SA0043: Verwendung einer globalen Variablen in nur einer POU ", 
"url" : "_san_rule_sa0043.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0043: Verwendung einer globalen Variablen in nur einer POU ", 
"snippet" : "Ermittelt die Verwendung einer globalen Variablen in nur einem einzigen Baustein. Begründung: Eine globale Variable, die nur an einer Stelle verwendet wird, sollte auch nur an dieser einen Stelle deklariert sein. Wichtigkeit: Mittel PLCopen-Regel: CP26 Beispiel VAR_GLOBAL g_xVar AT %QX0.0 : BOOL ; g...", 
"body" : "Ermittelt die Verwendung einer globalen Variablen in nur einem einzigen Baustein. Begründung: Eine globale Variable, die nur an einer Stelle verwendet wird, sollte auch nur an dieser einen Stelle deklariert sein. Wichtigkeit: Mittel PLCopen-Regel: CP26 Beispiel VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW1 : INT ;\n g_wTest AT %QW2 : WORD;\nEND_VAR PROGRAM prog1\nVAR\n iCondition : INT;\n bTemp : BOOL;\nEND_VAR\n iCondition := iCondition + INT#1;\nIF iCondition < INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n ELSIF iCondition = INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\nELSE\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n g_wTest := WORD#4; \/\/ g_WTest used also in prog2 -> OK\nEND_IF PROGRAM prog2\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_iTest := WORD_TO_INT(g_wTest); \/\/ SA0043 - g_iTest only written in this POU\n INT#2:\n g_iTest := INT#2; \/\/ SA0043 - g_iTest only written in this POU\n ELSE\n g_iTest := INT#3; \/\/ SA0043 - g_iTest only written in this POU\nEND_CASE Ausgabe unter Ansicht Meldungen : SA0043: Globale Variable 'g_xVar' nur in 'prog1' verwendet SA0043: Globale Variable 'g_iTest' nur in 'prog2' verwendet " }, 
{ "title" : "SA0044: Deklarationen mit Schnittstellenreferenz ", 
"url" : "_san_rule_sa0044.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0044: Deklarationen mit Schnittstellenreferenz ", 
"snippet" : "Ermittelt Deklarationen mit REFERENCE TO -Schnittstellen und Deklarationen von VAR_IN_OUT -Variablen mit Schnittstellen (implizit über REFERENCE TO realisiert). Begründung: Ein Schnittstellentyp ist immer implizit eine Referenz auf eine Instanz eines Funktionsbausteins, der diese Schnittstelle imple...", 
"body" : "Ermittelt Deklarationen mit REFERENCE TO -Schnittstellen und Deklarationen von VAR_IN_OUT -Variablen mit Schnittstellen (implizit über REFERENCE TO realisiert). Begründung: Ein Schnittstellentyp ist immer implizit eine Referenz auf eine Instanz eines Funktionsbausteins, der diese Schnittstelle implementiert. Eine Referenz auf eine Schnittstelle ist demnach eine Referenz auf eine Referenz und kann zu sehr unerwünschtem Verhalten führen. Wichtigkeit: Hoch Beispiel ITF ist eine im Projekt definierte Schnittstelle. FUNCTION_BLOCK POU\nVAR_INPUT\n inst_itf2 : ITF;\nEND_VAR\nVAR_OUTPUT\n inst_itf3 : ITF;\nEND_VAR\nVAR_IN_OUT\n inst_itf4 : ITF; \/\/ SA0044\nEND_VAR\n PROGRAM PLC_PRG\nVAR\n inst : POU;\n itf_inst1 : ITF;\n itf_ref : REFERENCE TO ITF; \/\/ SA0044\nEND_VAR Ausgabe unter Ansicht Meldungen : SA0044: Referenz auf Schnittstelle 'itf4_ref' SA0044: Referenz auf Schnittstelle 'itf_ref' " }, 
{ "title" : "Konvertierungen ", 
"url" : "_san_conversion.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Konvertierungen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0019: Implizite Pointerkonvertierungen ", 
"url" : "_san_rule_sa0019.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Konvertierungen \/ SA0019: Implizite Pointerkonvertierungen ", 
"snippet" : "Ermittelt implizit erzeugte Pointerkonvertierungen. Begründung: In CODESYS sind Pointer nicht streng getypt und können einander aber beliebig zugewiesen werden. Dies wird häufig genutzt und deswegen auch nicht vom Compiler gemeldet. Allerdings kann es dadurch zu unerwünschten und unerwarteten Zugrif...", 
"body" : "Ermittelt implizit erzeugte Pointerkonvertierungen. Begründung: In CODESYS sind Pointer nicht streng getypt und können einander aber beliebig zugewiesen werden. Dies wird häufig genutzt und deswegen auch nicht vom Compiler gemeldet. Allerdings kann es dadurch zu unerwünschten und unerwarteten Zugriffen kommen. Wenn man beispielsweise einem Pointer mit Typ POINTER TO BYTE den Typ POINTER TO DWORD zuweist, kann unerwünscht Speicher überschrieben werden. Lassen Sie diese Regel deshalb in jedem Fall prüfen und unterdrücken Sie die Meldung nur in den Fällen, in denen Sie bewusst anders getypt auf einen Wert zugreifen wollen. Konvertierungen von und zu dem Datentyp POINTER TO BYTE werden von der Regel SA0019 nicht geprüft. Sie sind immer erlaubt. Implizite Datentyp-Konvertierungen werden mit einer anderen Meldung gemeldet. Wichtigkeit: Hoch PLCopen-Regel: CP25 Ausnahme: BOOL <-> BIT Beispiel PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n byteVar : BYTE;\nEND_VAR\n pInt := ADR(byteVar); Ausgabe unter Ansicht Meldungen : SA0019: Implizite Konvertierung von Pointer auf 'POINTER TO BYTE' zu Pointer auf 'POINTER TO INT' " }, 
{ "title" : "SA0130: Implizite erweiternde Konvertierungen ", 
"url" : "_san_rule_sa0130.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Konvertierungen \/ SA0130: Implizite erweiternde Konvertierungen ", 
"snippet" : "Ermittelt Codestellen, an denen bei arithmetischen Operationen implizit Konvertierungen von kleineren in größere Datentypen durchgeführt werden Begründung: Der Compiler erlaubt jegliche Zuweisungen von unterschiedlichen Typen, wenn der Wertebereich des Quelltyps vollständig im Wertebereich des Zielt...", 
"body" : "Ermittelt Codestellen, an denen bei arithmetischen Operationen implizit Konvertierungen von kleineren in größere Datentypen durchgeführt werden Begründung: Der Compiler erlaubt jegliche Zuweisungen von unterschiedlichen Typen, wenn der Wertebereich des Quelltyps vollständig im Wertebereich des Zieltyps enthalten ist. Allerdings baut der Compiler eine Konvertierung so spät wie möglich in den Code ein. Bei einer Zuweisung der folgenden Art: lint := dint * dint führt der Compiler die implizite Konvertierung erst nach der Multiplikation durch: lint := TO_LINT(dint * dint); Ein Überlauf wird daher abgeschnitten. Wenn Sie das verhindern wollen, können Sie die Konvertierung bereits für die Elemente durchführen lassen: lint := TO_LINT(dint) * TO_LINT(dint); Es kann daher sinnvoll sein, sich Stellen melden zu lassen, an denen der Compiler implizite Konvertierungen einbaut, um zu prüfen, ob diese genau so gewollt sind. Außerdem können explizite Konvertierungen zu besserer Portierbarkeit auf andere Systeme dienen, wenn diese restriktivere Typprüfungen haben. Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG\nVAR\n d : DINT;\n l : LINT;\n ui : UINT;\n uli : ULINT;\n usi : USINT;\n lw : LWORD;\n udi : UDINT;\n lr : LREAL;\n b : BYTE;\nEND_VAR\n (*The following lines could result in unwanted truncating by implicit conversions \nand should be reported with SA0130*) \nl := d * d;\nuli := usi * usi;\nlw := udi * udi;\nlr := b * b;\nd := ui * ui; Ausgabe unter Ansicht Meldungen : SA0130: Implizite erweiternde Konvertierung vom Typ 'DINT' zu Typ 'LINT' SA0130: Implizite erweiternde Konvertierung vom Typ 'USINT' zu Typ 'ULINT' SA0130: Implizite erweiternde Konvertierung vom Typ 'UDINT' zu Typ 'LWORD' SA0130: Implizite erweiternde Konvertierung vom Typ 'USINT' zu Typ 'LREAL' SA0130: Implizite erweiternde Konvertierung vom Typ 'UINT' zu Typ 'DINT' " }, 
{ "title" : "SA0133: Explizite einschränkende Konvertierungen ", 
"url" : "_san_rule_sa0133.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Konvertierungen \/ SA0133: Explizite einschränkende Konvertierungen ", 
"snippet" : "Ermittelt explizit durchgeführte Konvertierungen von einem größeren auf einen kleineren Datentyp. Begründung: Eine große Zahl von Typkonvertierungen kann bedeuten, dass man falsche Datentypen für Variablen gewählt hat. Es gibt daher Programmierrichtlinien, die eine explizite Begründung für Datentypk...", 
"body" : "Ermittelt explizit durchgeführte Konvertierungen von einem größeren auf einen kleineren Datentyp. Begründung: Eine große Zahl von Typkonvertierungen kann bedeuten, dass man falsche Datentypen für Variablen gewählt hat. Es gibt daher Programmierrichtlinien, die eine explizite Begründung für Datentypkonvertierungen fordern. Wichtigkeit: Niedrig Beispiel PROGRAM SA0133\nVAR\n siVar:SINT;\n diVar:DINT;\n liVar:LINT;\n byVar:BYTE;\n uiVar:UINT;\n dwVar:DWORD;\n lwVar:LWORD;\n rVar:REAL;\n lrVar:LREAL;\nEND_VAR\n siVar := LINT_TO_SINT(liVar); \/\/ SA0133\nbyVar := DINT_TO_BYTE(diVar); \/\/ SA0133\nsiVar := DWORD_TO_SINT(dwVar); \/\/ SA0133\nuiVar := LREAL_TO_UINT(lrVar); \/\/ SA0133\nrVar := LWORD_TO_REAL(lwVar); \/\/ SA0133 Ausgabe unter Ansicht Meldungen : SA0133: Explizite einschränkende Konvertierungen von Typ 'LINT' zu Typ 'SINT' SA0133: Explizite einschränkende Konvertierungen von Typ 'DINT' zu Typ 'BYTE' SA0133: Explizite einschränkende Konvertierungen von Typ 'DWORD' zu Typ 'SINT' SA0133: Explizite einschränkende Konvertierungen von Typ 'LREAL' zu Typ 'UINT' SA0133: Explizite einschränkende Konvertierungen von Typ 'LWORD' zu Typ 'REAL' " }, 
{ "title" : "SA0134: Explizite vorzeichenbehaftete\/vorzeichenlose Konvertierungen ", 
"url" : "_san_rule_sa0134.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Konvertierungen \/ SA0134: Explizite vorzeichenbehaftete\/vorzeichenlose Konvertierungen ", 
"snippet" : "Ermittelt explizit durchgeführte Konvertierungen von vorzeichenbehafteten auf vorzeichenlose Datentypen und umgekehrt. Begründung: Ein übermäßiger Gebrauch von Typkonvertierungen kann bedeuten, dass falsche Datentypen für Variablen gewählt wurden. Es gibt daher Programmierrichtlinien, die eine expli...", 
"body" : "Ermittelt explizit durchgeführte Konvertierungen von vorzeichenbehafteten auf vorzeichenlose Datentypen und umgekehrt. Begründung: Ein übermäßiger Gebrauch von Typkonvertierungen kann bedeuten, dass falsche Datentypen für Variablen gewählt wurden. Es gibt daher Programmierrichtlinien, die eine explizite Begründung für Datentypkonvertierungen fordern. Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG\nVAR\n byVar :BYTE;\n udiVar : UDINT;\n uliVar : ULINT;\n lwVar : LWORD;\n wVar : WORD;\n siVar : SINT;\n iVar : INT;\n diVar : DINT;\n liVar : LINT;\nEND_VAR\n liVar := ULINT_TO_LINT(uliVar);\nudiVar := DINT_TO_UDINT(diVar);\nsiVar := BYTE_TO_SINT(byVar);\nwVar := INT_TO_WORD(iVar);\nlwVar := SINT_TO_LWORD(siVar); Ausgabe unter Ansicht Meldungen : SA0134: Explizite vorzeichenbehaftete\/vorzeichenlose Konvertierungen von Typ 'ULINT' zu Typ 'LINT' SA0134: Explizite vorzeichenbehaftete\/vorzeichenlose Konvertierungen von Typ 'DINT' zu Typ 'UDINT' SA0134: Explizite vorzeichenbehaftete\/vorzeichenlose Konvertierungen von Typ 'BYTE' zu Typ 'SINT' SA0134: Explizite vorzeichenbehaftete\/vorzeichenlose Konvertierungen von Typ 'INT' zu Typ 'WORD' SA0134: Explizite vorzeichenbehaftete\/vorzeichenlose Konvertierungen von Typ 'SINT' zu Typ 'LWORD' " }, 
{ "title" : "Verwendung direkter Adressen ", 
"url" : "_san_use_direct_adresses.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Verwendung direkter Adressen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0005: Ungültige Adressen und Datentypen ", 
"url" : "_san_rule_sa0005.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Verwendung direkter Adressen \/ SA0005: Ungültige Adressen und Datentypen ", 
"snippet" : "Ermittelt ungültige Adress- und Datentypspezifikationen. Gültige Größenpräfixe in Adressen: X für BOOL , B für 1-Byte-Datentypen, W für 2-Byte-Datentypen und D für 4-Byte-Datentypen. Begründung: Variablen, die auf direkten Adressen liegen, sollten möglichst mit einer Adresse assoziiert werden, die i...", 
"body" : "Ermittelt ungültige Adress- und Datentypspezifikationen. Gültige Größenpräfixe in Adressen: X für BOOL , B für 1-Byte-Datentypen, W für 2-Byte-Datentypen und D für 4-Byte-Datentypen. Begründung: Variablen, die auf direkten Adressen liegen, sollten möglichst mit einer Adresse assoziiert werden, die ihrer Datentypbreite entspricht. Es kann für den Leser des Codes zur Verwirrung führen, wenn beispielsweise ein DWORD auf eine BYTE -Adresse gelegt wird. Wichtigkeit: Niedrig Beispiel PROGRAM Check_Address_Type_PRG\nVAR\n iVar AT %QB0 : INT ; \/\/ OK e. g.: %QW0\n xTest AT %QW1 : BOOL ; \/\/ OK e. g.: %QX1.0\nEND_VAR iVar := iVar + INT#1;\nxTest := NOT xTest;\n Ausgabe unter Ansicht Meldungen : SA0005: Ungültige Adresse für Datentyp 'iVar' Für weitere Informationen siehe: Statische Codeanalyse konfigurieren und durchführen " }, 
{ "title" : "SA0047: Zugriffe auf direkte Adresse ", 
"url" : "_san_rule_sa0047.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Verwendung direkter Adressen \/ SA0047: Zugriffe auf direkte Adresse ", 
"snippet" : "Ermittelt direkten Adresszugriff im Implementierungscode. Begründung: Symbolische Programmierung ist immer zu bevorzugen: Eine Variable hat einen Namen, der auch eine Bedeutung tragen kann. Einer Adresse kann man nicht ansehen, wofür diese verwendet wird. Wichtigkeit: Hoch PLCopen-Regel: N1 \/ CP1 Be...", 
"body" : "Ermittelt direkten Adresszugriff im Implementierungscode. Begründung: Symbolische Programmierung ist immer zu bevorzugen: Eine Variable hat einen Namen, der auch eine Bedeutung tragen kann. Einer Adresse kann man nicht ansehen, wofür diese verwendet wird. Wichtigkeit: Hoch PLCopen-Regel: N1 \/ CP1 Beispiel PROGRAM PLC_PRG\nVAR\n xVar : BOOL;\n byVar : BYTE;\nEND_VAR\n xVar := %IX0.0;\n%QX0.0 := xVar;\n%MX0.1 := xVar;\n%MB1 := byVar; Ausgabe unter Ansicht Meldungen : SA0047: Zugriffe auf direkte Adresse '%IX0.0' SA0026: Zugriffe auf direkte Adresse '%QX0.0' SA0026: Zugriffe auf direkte Adresse '%MX0.1' SA0026: Zugriffe auf direkte Adresse '%MB1' " }, 
{ "title" : "SA0048: AT-Deklarationen auf direkte Adressen ", 
"url" : "_san_rule_sa0048.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Verwendung direkter Adressen \/ SA0048: AT-Deklarationen auf direkte Adressen ", 
"snippet" : "Ermittelt AT -Deklarationen auf direkte Adressen. Begründung: Direkte Adressen im Code zu verwenden ist problematisch, da eine Adresse dann mehrfach vorkommt: Erstens in der Steuerungskonfiguration, in der die Zuordnung eines physikalischen Objekts zu einer Adresse festgelegt wird Zweitens im Progra...", 
"body" : "Ermittelt AT -Deklarationen auf direkte Adressen. Begründung: Direkte Adressen im Code zu verwenden ist problematisch, da eine Adresse dann mehrfach vorkommt: Erstens in der Steuerungskonfiguration, in der die Zuordnung eines physikalischen Objekts zu einer Adresse festgelegt wird Zweitens im Programm, in dem Variablen auf diese Adressen gelegt werden Kommt es zu einer Verschiebung der Adressen, weil die Konfiguration geändert wird, dann müssen Sie an ganz anderer Stelle im Programm eine neue Zuordnung von Variable zu Adresse durchführen. Das ist eine Fehlerquelle und führt zu schlechterer Lesbarkeit und Wartbarkeit des Codes. Nehmen Sie daher am Besten alle Zuordnungen im E\/A-Abbild des Geräteeditors vor. Wichtigkeit: Hoch PLCopen-Regel: N1 \/ CP1 Es wird empfohlen, Zuweisungen auf direkte Adressen nur in der Registerkarte E\/A-Abbild des Geräteeditors vorzunehmen. Beispiel PROGRAM PLC_PRG\nVAR\n xVar1 AT %IX0.0 : BOOL;\n byVar1 AT %IB1 : BYTE;\n xVar2 AT %QX0.0 : BOOL;\nEND_VAR\n Ausgabe unter Ansicht Meldungen : SA0048: Deklaration verwendet direkte Adresse '%IX0.0' SA0048: Deklaration verwendet direkte Adresse '%IB1 SA0048: Deklaration verwendet direkte Adresse '%QX0.0' " }, 
{ "title" : "Regeln für Operatoren ", 
"url" : "_san_rule_operators.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0051: Vergleichsoperationen auf BOOL-Variablen ", 
"url" : "_san_rule_sa0051.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0051: Vergleichsoperationen auf BOOL-Variablen ", 
"snippet" : "Ermittelt Vergleichsoperationen auf Variablen vom Typ BOOL . Begründung: CODESYS erlaubt solche Vergleiche. Diese sind aber zumindest sehr unüblich und können verwirrend sein. Die Norm IEC-61131-3 sieht diese Vergleiche nicht vor. Indem Sie sie vermeiden, erhöhen Sie die Portierbarkeit des Codes auf...", 
"body" : "Ermittelt Vergleichsoperationen auf Variablen vom Typ BOOL . Begründung: CODESYS erlaubt solche Vergleiche. Diese sind aber zumindest sehr unüblich und können verwirrend sein. Die Norm IEC-61131-3 sieht diese Vergleiche nicht vor. Indem Sie sie vermeiden, erhöhen Sie die Portierbarkeit des Codes auf andere Entwicklungssysteme. Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG\nVAR\n xBool1, xBool2 : BOOL;\n xResult : BOOL;\nEND_VAR\n xResult := xBool1 > xBool2; \/\/ SA0051\nxBool1 := NOT xBool1; \/\/ OK!\nxBool2 := xBool2 XOR xBool1; \/\/ OK! Ausgabe unter Ansicht Meldungen : SA0051: Vergleichsoperationen auf BOOL-Variablen " }, 
{ "title" : "SA0052: Unübliche Schiebeoperation ", 
"url" : "_san_rule_sa0052.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0052: Unübliche Schiebeoperation ", 
"snippet" : "Ermittelt Schiebeoperationen (Bitverschiebung) auf vorzeichenbehaftete Variablen. Bei Schiebeoperationen auf Bitfeld-Datentypen ( Byte , DWORD , LWORD , WORD ) wird kein Fehler ausgegeben. Begründung: CODESYS erlaubt Schiebeoperationen auf vorzeichenbehafteten Datentypen. Diese Operationen sind aber...", 
"body" : "Ermittelt Schiebeoperationen (Bitverschiebung) auf vorzeichenbehaftete Variablen. Bei Schiebeoperationen auf Bitfeld-Datentypen ( Byte , DWORD , LWORD , WORD ) wird kein Fehler ausgegeben. Begründung: CODESYS erlaubt Schiebeoperationen auf vorzeichenbehafteten Datentypen. Diese Operationen sind aber unüblich und können verwirrend sein. Die Norm IEC-61131-3 sieht solche Operationen nicht vor und sie sollten vermieden werden, um die Portierbarkeit des Codes auf andere Entwicklungssysteme zu erhöhen. Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG\nVAR\n iTemp : INT;\n dwTemp1 : DWORD;\n byTemp2 : BYTE;\n diTemp3 : DINT;\n siTemp4 : SINT;\n liTemp5 : LINT;\nEND_VAR\n \/\/the following lines each will cause an SA0052:\niTemp := SHL(iTemp, BYTE#2);\ndiTemp3 := SHR(diTemp3, BYTE#4);\nsiTemp4 := ROL(siTemp4, BYTE#2);\nliTemp5 := ROR(liTemp5, BYTE#2);\n\n\/\/no error SA0052 because DWORD and BYTE are bitfield datatypes:\ndwTemp1 := SHL(dwTemp1, BYTE#3);\nbyTemp2 := SHR(byTemp2, BYTE#1); Ausgabe unter Ansicht Meldungen : SA0052: Unübliche Schiebeoperation " }, 
{ "title" : "SA0053: Zu große bitweise Verschiebung ", 
"url" : "_san_rule_sa0053.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0053: Zu große bitweise Verschiebung ", 
"snippet" : "Ermittelt bei bitweiser Verschiebung (Bitverschiebung) von Operanden, ob die Datentypbreite des Operanden überschritten wurde. Begründung: Wenn eine Verschiebeoperation über die Datentypbreite hinausgeht, dann erzeugt man eine Konstante 0 . Wenn eine Rotationsverschiebung über die Datentypbreite hin...", 
"body" : "Ermittelt bei bitweiser Verschiebung (Bitverschiebung) von Operanden, ob die Datentypbreite des Operanden überschritten wurde. Begründung: Wenn eine Verschiebeoperation über die Datentypbreite hinausgeht, dann erzeugt man eine Konstante 0 . Wenn eine Rotationsverschiebung über die Datentypbreite hinausgeht, dann ist das schwer zu lesen und der Rotationswert sollte deswegen gekürzt werden. Wichtigkeit: Hoch Beispiel PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\n lwTemp4 : LWORD;\nEND_VAR\n byTemp1 := SHR(byTemp1, BYTE#25);\nwTemp2 := SHL(wTemp2, BYTE#45);\ndwTemp3 := ROR(dwTemp3, BYTE#78);\nlwTemp4 := ROL(lwTemp4, BYTE#111); Ausgabe unter Ansicht Meldungen : SA0053: Zu große bitweise Verschiebung " }, 
{ "title" : "SA0054: Vergleich von REAL \/ LREAL auf Gleichheit\/Ungleichheit ", 
"url" : "_san_rule_sa0054.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0054: Vergleich von REAL \/ LREAL auf Gleichheit\/Ungleichheit ", 
"snippet" : "Ermittelt, ob die Vergleichsoperatoren = (Gleichheit) und <> (Ungleichheit) Operanden vom Typ REAL oder LREAL vergleichen. Begründung: REAL \/ LREAL - Werte werden als Gleitpunktzahlen nach dem Standard IEEE 754 implementiert. Dieser Standard bringt es mit sich, dass bestimmte, scheinbar einfache Dez...", 
"body" : "Ermittelt, ob die Vergleichsoperatoren = (Gleichheit) und <> (Ungleichheit) Operanden vom Typ REAL oder LREAL vergleichen. Begründung: REAL \/ LREAL - Werte werden als Gleitpunktzahlen nach dem Standard IEEE 754 implementiert. Dieser Standard bringt es mit sich, dass bestimmte, scheinbar einfache Dezimalzahlen nicht exakt dargestellt werden können. Das hat zur Folge dass es für dieselbe Dezimalzahl unterschiedliche Repräsentationen als LREAL geben kann. Betrachten Sie folgende Codezeilen: lr11 := 1.1;\nlr33 := 3.3;\nlrVar1 := lr11 + lr11;\nlrVar2 := lr33 - lr11;\nbotest := lrVar1 = lrVar2; botest wird in diesem Fall FALSE liefern, auch wenn die Variablen lrVar1 und lrVar2 beide den Monitoring-Wert „2.2“ liefern. Das ist kein Fehler des Compilers, sondern eine Eigenschaft der Gleitpunkteinheiten aller üblichen Prozessoren. Vermeiden können Sie das, indem Sie einen Mindestwert angeben, um den sich die Werte unterscheiden dürfen: botest := ABS(lrVar1 - lrVar2) < 0.1; Ausnahme: Ein Vergleich mit 0.0 wird nicht von dieser Analyse gemeldet. Für die 0 gibt es im Standard IEEE 754 eine exakte Darstellung und daher funktioniert der Vergleich üblicherweise wie erwartet. Für eine bessere Performance ist es daher sinnvoll, hier einen direkten Vergleich zuzulassen. Wichtigkeit: Hoch PLCopen-Regel: CP54 Beispiel PROGRAM PLC_PRG\nVAR\n rTest1 : REAL;\n rTest2 : REAL;\n lrTest3 : LREAL;\n lrTest4 : LREAL;\n xResult : BOOL;\nEND_VAR \/\/the following lines each will cause an SA0054:\nxResult := rTest1 = rTest1;\nxResult := rTest1 = rTest2;\nxResult := rTest1 <> rTest2;\nxResult := lrTest3 = lrTest3;\nxResult := lrTest3 = lrTest4;\nxResult := lrTest3 <> lrTest4;\n\/\/the following lines each will not cause an SA0054:\nxResult := rTest1 > rTest2;\nxResult := lrTest3 < lrTest4;\n Ausgabe unter Ansicht Meldungen : SA0054: Vergleich von REAL \/ LREAL auf Gleichheit\/Ungleichheit " }, 
{ "title" : "SA0055: Unnötige Vergleichsoperationen von vorzeichenlosen Operanden ", 
"url" : "_san_rule_sa0055.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0055: Unnötige Vergleichsoperationen von vorzeichenlosen Operanden ", 
"snippet" : "Ermittelt unnötige Vergleiche mit vorzeichenlosen Operanden. Ein vorzeichenloser Datentyp ist nie kleiner Null. Dies kann als Vorzeichenprüfung verwendet werden. Begründung: Ein mit dieser Prüfung aufgedeckter Vergleich liefert ein konstantes Ergebnis und das deutet auf einen Fehler im Code hin. Wic...", 
"body" : "Ermittelt unnötige Vergleiche mit vorzeichenlosen Operanden. Ein vorzeichenloser Datentyp ist nie kleiner Null. Dies kann als Vorzeichenprüfung verwendet werden. Begründung: Ein mit dieser Prüfung aufgedeckter Vergleich liefert ein konstantes Ergebnis und das deutet auf einen Fehler im Code hin. Wichtigkeit: Hoch Beispiel PROGRAM PLC_PRG\nVAR\n byTest: BYTE;\nEND_VAR\n \/\/ SA0055\nWHILE byTest >= 0 DO\n byTest := byTest - 1;\nEND_WHILE Ausgabe unter Ansicht Meldungen : SA0055: Unnötige Vergleichsoperationen von vorzeichenlosen Operanden " }, 
{ "title" : "SA0056: Konstante außerhalb des gültigen Bereichs ", 
"url" : "_san_rule_sa0056.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0056: Konstante außerhalb des gültigen Bereichs ", 
"snippet" : "Ermittelt Literale (Konstanten) außerhalb des für den Operator gültigen Bereichs. Begründung: Die Meldung wird für Fälle ausgegeben, in denen ein Wert mit einer Konstanten verglichen wird, die außerhalb des Wertebereichs dieses Werts liegt. Der Vergleich liefert dann konstant TRUE oder FALSE . Dies ...", 
"body" : "Ermittelt Literale (Konstanten) außerhalb des für den Operator gültigen Bereichs. Begründung: Die Meldung wird für Fälle ausgegeben, in denen ein Wert mit einer Konstanten verglichen wird, die außerhalb des Wertebereichs dieses Werts liegt. Der Vergleich liefert dann konstant TRUE oder FALSE . Dies deutet auf einen Programmierfehler hin. Wichtigkeit: Hoch Beispiel PROGRAM PLC_PRG\nVAR\n byTestVar: BYTE;\nEND_VAR\n WHILE byTestVar >= 260 DO\n byTestVar := byTestVar + 1;\nEND_WHILE Ausgabe unter Ansicht Meldungen : SA0056: Konstante außerhalb des gültigen Bereichs " }, 
{ "title" : "SA0057: Möglicherweise Verlust von Nachkommastellen ", 
"url" : "_san_rule_sa0057.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0057: Möglicherweise Verlust von Nachkommastellen ", 
"snippet" : "Ermittelt Anweisungen mit möglichem Verlust von Nachkommastellen. Begründung: Ein Codestück der folgenden Art: diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) kann zu einer Fehlinterpretation führen. Der Autor oder Leser dieser Codezeile kann der Annahme sein, die Division würde als REAL -Operation...", 
"body" : "Ermittelt Anweisungen mit möglichem Verlust von Nachkommastellen. Begründung: Ein Codestück der folgenden Art: diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) kann zu einer Fehlinterpretation führen. Der Autor oder Leser dieser Codezeile kann der Annahme sein, die Division würde als REAL -Operation durchgeführt und das Ergebnis würde in diesem Fall REAL#0.5 sein. Dies ist jedoch nicht der Fall, die Operation wird als Integer-Operation durchgeführt, das Ergebnis wird auf REAL gecastet und rTemp1 erhält den Wert REAL#0 . Um dies zu vermeiden, sollten Sie durch einen Cast dafür sorgen, dass die Operation als REAL -Operation durchgeführt wird: rTemp1 := TO_REAL(diTemp2) \/ REAL#2; Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG\nVAR\n rTemp1 : REAL;\n diTemp2 : DINT;\n liTemp3 : LINT;\nEND_VAR diTemp2 := diTemp2 + DINT#11;\n\/\/ SA0057\nrTemp1 := DINT_TO_REAL(diTemp2 \/ DINT#3); \nrTemp1 := DINT_TO_REAL(diTemp2) \/ REAL#3.0;\nliTemp3 := liTemp3 + LINT#13;\n\/\/ SA0057\nrTemp1 := LINT_TO_REAL(liTemp3 \/ LINT#7);\nrTemp1 := LINT_TO_REAL(liTemp3) \/ REAL#7.0; Ausgabe unter Ansicht Meldungen : SA0057: Möglicherweise Verlust von Nachkommastellen " }, 
{ "title" : "SA0058: Operation auf Enumerationsvariablen ", 
"url" : "_san_rule_sa0058.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0058: Operation auf Enumerationsvariablen ", 
"snippet" : "Ermittelt Operationen auf Variablen des Datentyps Enumeration. Zuweisungen sind erlaubt. Begründung: Enumerationen sollten nicht als normale Integer-Werte verwendet werden. Alternativ kann ein Alias-Datentyp definiert oder ein Unterbereichstyp verwendet werden Wichtigkeit: Mittel Ausnahme: Wenn eine...", 
"body" : "Ermittelt Operationen auf Variablen des Datentyps Enumeration. Zuweisungen sind erlaubt. Begründung: Enumerationen sollten nicht als normale Integer-Werte verwendet werden. Alternativ kann ein Alias-Datentyp definiert oder ein Unterbereichstyp verwendet werden Wichtigkeit: Mittel Ausnahme: Wenn eine Enumeration mit dem Attribut {attribute 'strict'} gekennzeichnet ist, dann meldet bereits der Compiler eine solche Operation. Wenn eine Enumeration durch das Pragma {attribute 'flags'} als Flag deklariert ist, wird für AND -, OR -, NOT - oder XOR -Operationen kein Fehler ausgegeben. Beispiel TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : My_Enum;\nEND_VAR iTemp1 := iTemp1 + INT#1;\nabc := My_Enum.red; \/\/ OK\niTemp1 := My_Enum.black \/ My_Enum.blue; \/\/ SA0058\niTemp1 := My_Enum.green \/ My_Enum.red; \/\/ SA0058\n Ausgabe unter Ansicht Meldungen : SA0058: Operation auf Enumerationsvariablen Beispiel mit Pragma {attribute 'flags'} {attribute 'flags'} \/\/ declaring the enumeration as a \"flag\"\nTYPE Flags :\n(\n Unknown := 16#00000001,\n Stopped := 16#00000002,\n Running := 16#00000004\n) DWORD;\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : Flags;\n batate : BYTE;\n dwFlags : DWORD;\n dwState : DWORD;\nEND_VAR \/\/ OK for the following\nIF (dwFlags AND Flags.Unknown) <> DWORD#0 THEN\n dwState := dwState AND Flags.Unknown;\n ELSIF (dwFlags OR Flags.Stopped) <> DWORD#0 THEN\n dwState := dwState OR Flags.Running;\nEND_IF " }, 
{ "title" : "SA0059: Vergleichsoperationen, die immer TRUE oder FALSE liefern ", 
"url" : "_san_rule_sa0059.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0059: Vergleichsoperationen, die immer TRUE oder FALSE liefern ", 
"snippet" : "Ermittelt Vergleiche mit Literalen, deren Ergebnis immer TRUE oder FALSE ist und die bereits während der Kompilierung ausgewertet werden können. Begründung: Eine Operation, die konstant TRUE oder FALSE liefert, ist ein Hinweis auf einen Programmierfehler. Wichtigkeit: Hoch Beispiel PROGRAM PLC_PRG V...", 
"body" : "Ermittelt Vergleiche mit Literalen, deren Ergebnis immer TRUE oder FALSE ist und die bereits während der Kompilierung ausgewertet werden können. Begründung: Eine Operation, die konstant TRUE oder FALSE liefert, ist ein Hinweis auf einen Programmierfehler. Wichtigkeit: Hoch Beispiel PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\nEND_VAR\n WHILE byTemp1 <= 255 DO\n byTemp1 := byTemp1 + 1;\nEND_WHILE Ausgabe unter Ansicht Meldungen : SA0059: Vergleichsoperator '<=' errechnet immer 'TRUE' " }, 
{ "title" : "SA0060: Null als ungültiger Operand ", 
"url" : "_san_rule_sa0060.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0060: Null als ungültiger Operand ", 
"snippet" : "Ermittelt Operationen, in denen ein Operand mit dem Wert 0 zu einer ungültigen oder unsinnigen Operation führt. Begründung: Ein solcher Ausdruck kann auf einen Programmierfehler hindeuten. In jedem Fall kostet er unnötig Laufzeit. Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG VAR byTemp1 : BYTE; wTem...", 
"body" : "Ermittelt Operationen, in denen ein Operand mit dem Wert 0 zu einer ungültigen oder unsinnigen Operation führt. Begründung: Ein solcher Ausdruck kann auf einen Programmierfehler hindeuten. In jedem Fall kostet er unnötig Laufzeit. Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\nEND_VAR\n byTemp1 := byTemp1 + 0;\nwTemp2 := wTemp2 - WORD#0;\ndwTemp3 := dwTemp3 * DWORD#0; Ausgabe unter Ansicht Meldungen : SA0060: Null als ungültiger Operand " }, 
{ "title" : "SA0061: Unübliche Operation auf Pointer ", 
"url" : "_san_rule_sa0061.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0061: Unübliche Operation auf Pointer ", 
"snippet" : "Ermittelt Operationen auf Variablen vom Typ POINTER TO , die nicht = (Gleichheit), <> (Ungleichheit), + (Addition) oder ADR sind. In CODESYS ist Pointer-Arithmetik grundsätzlich erlaubt und kann auch sinnvoll eingesetzt werden. Als übliche Operation auf Pointer wird daher die Addition eines Pointers...", 
"body" : "Ermittelt Operationen auf Variablen vom Typ POINTER TO , die nicht = (Gleichheit), <> (Ungleichheit), + (Addition) oder ADR sind. In CODESYS ist Pointer-Arithmetik grundsätzlich erlaubt und kann auch sinnvoll eingesetzt werden. Als übliche Operation auf Pointer wird daher die Addition eines Pointers mit einem Integerwert eingestuft. Damit ist es möglich, mit Hilfe eines Pointers ein Array mit variabler Länge zu bearbeiten. Alle anderen (unüblichen) Operationen mit Pointer werden mit SA0061 gemeldet. Wichtigkeit: Hoch PLCopen-Regel: E2 \/ E3 Beispiel PROGRAM PLC_PRG\nVAR\n piTemp : POINTER TO INT;\n iTemp : INT;\nEND_VAR\n iTemp := iTemp + INT#1;\npiTemp := ADR(iTemp);\npiTemp := piTemp * DWORD#5; \/\/ SA0061\npiTemp := piTemp \/ DWORD#2; \/\/ SA0061\npiTemp := piTemp MOD DWORD#3; \/\/ SA0061\npiTemp := piTemp + DWORD#1;\npiTemp := piTemp - DWORD#1; \/\/ SA0061 Ausgabe unter Ansicht Meldungen : SA0061: Unübliche Operation auf Pointer " }, 
{ "title" : "SA0062: Ausdruck ist konstant ", 
"url" : "_san_rule_sa0062.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0062: Ausdruck ist konstant ", 
"snippet" : "Ermittelt die Verwendung von Ausdrücken, die zur Laufzeit einen immer gleichen Wert haben. Begründung: Ein komplexer Ausdruck, der immer wieder berechnet wird und dabei stets den gleichen Wert erzeugt, kann auf einen Fehler hinweisen. Dies gilt insbesondere, wenn etwas anderes beabsichtigt war. In j...", 
"body" : "Ermittelt die Verwendung von Ausdrücken, die zur Laufzeit einen immer gleichen Wert haben. Begründung: Ein komplexer Ausdruck, der immer wieder berechnet wird und dabei stets den gleichen Wert erzeugt, kann auf einen Fehler hinweisen. Dies gilt insbesondere, wenn etwas anderes beabsichtigt war. In jedem Fall belastet der Ausdruck die Laufzeit des Programms unnötig. Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG\nVAR\n value : INT;\n condition : BOOL;\nEND_VAR\n value := 8;\ncondition := value = 8 \/\/ Reports: Expression (value=8) is always TRUE Ausgabe unter Ansicht Meldungen : SA0062: Ausdruck '(value=8)' ist immer TRUE " }, 
{ "title" : "SA0063: Möglicherweise nicht 16-bit-kompatible Operationen ", 
"url" : "_san_rule_sa0063.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0063: Möglicherweise nicht 16-bit-kompatible Operationen ", 
"snippet" : "Ermittelt 16-Bit-Operationen mit Zwischenergebnissen. Hintergrund: Auf 16-Bit-Systemen können 32-Bit-Zwischenergebnisse abgeschnitten werden. Beispiel: (int+10) kann 16 Bit überschreiten. Begründung: Diese Meldung soll in dem sehr seltenen Fall vor Problemen schützen, dass man Code schreiben muss, d...", 
"body" : "Ermittelt 16-Bit-Operationen mit Zwischenergebnissen. Hintergrund: Auf 16-Bit-Systemen können 32-Bit-Zwischenergebnisse abgeschnitten werden. Beispiel: (int+10) kann 16 Bit überschreiten. Begründung: Diese Meldung soll in dem sehr seltenen Fall vor Problemen schützen, dass man Code schreiben muss, der sowohl auf einem 16-Bit-Prozessor als auch auf einem 32-Bi- Prozessor laufen soll. Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG\nVAR\n iVar : INT;\nEND_VAR\n iVar := (iVar + 10) \/ 2; Ausgabe unter Ansicht Meldungen : SA0063: Kompatibilität für 16 Bit - Möglicherweise abgeschnittenes Zwischenergebnis " }, 
{ "title" : "SA0064: Addition eines Pointers ", 
"url" : "_san_rule_sa0064.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0064: Addition eines Pointers ", 
"snippet" : "Ermittelt Additionen von Pointern. Begründung: In CODESYS ist eine Pointerarithmetik grundsätzlich erlaubt und kann sinnvoll eingesetzt werden. Sie stellt aber auch eine Fehlerquelle dar. Deswegen gibt es Programmiervorschriften, die eine Pointerarithmetik grundsätzlich verbieten. Eine solche Vorsch...", 
"body" : "Ermittelt Additionen von Pointern. Begründung: In CODESYS ist eine Pointerarithmetik grundsätzlich erlaubt und kann sinnvoll eingesetzt werden. Sie stellt aber auch eine Fehlerquelle dar. Deswegen gibt es Programmiervorschriften, die eine Pointerarithmetik grundsätzlich verbieten. Eine solche Vorschrift kann mit diesem Test überprüft werden. Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG\nVAR\n iTest : INT;\n ariTest : ARRAY[0..10] OF INT;\n {attribute 'analysis':='-111'}\n piTest : POINTER TO INT;\n i : INT;\nEND_VAR\n piTest := ADR(ariTest[0]); \/\/ OK\npiTest^ := 0;\npiTest := ADR(ariTest) + SIZEOF(INT); \/\/ SA0064\npiTest^ := 1;\npiTest := ADR(ariTest) + 6; \/\/ SA0064\npiTest^ := 3;\npiTest := ADR(ariTest[10]);\nFOR i:=0 TO 10 DO\n piTest^ := i;\n piTest := piTest + 2; \/\/ SA0064\nEND_FOR Ausgabe unter Ansicht Meldungen : SA0064: Addition eines Pointers " }, 
{ "title" : "SA0065: Pointeraddition passt nicht zur Basisgröße ", 
"url" : "_san_rule_sa0065.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0065: Pointeraddition passt nicht zur Basisgröße ", 
"snippet" : "Ermittelt Pointeradditionen, bei denen der zu addierende Wert nicht zur Basisdatengröße des Pointers passt. Fehlerfrei können nur Literale der Basisdatengröße und Vielfache davon addiert werden. Begründung: In CODESYS (im Gegensatz zu C und C++) wird bei einer Addition eines Pointers mit einem Integ...", 
"body" : "Ermittelt Pointeradditionen, bei denen der zu addierende Wert nicht zur Basisdatengröße des Pointers passt. Fehlerfrei können nur Literale der Basisdatengröße und Vielfache davon addiert werden. Begründung: In CODESYS (im Gegensatz zu C und C++) wird bei einer Addition eines Pointers mit einem Integerwert nur dieser Integerwert als Anzahl der Bytes addiert, und nicht der Integerwert mit der Basisgröße multipliziert. Beispiel in ST pINT := ADR(array_of_int[0]);\npINT := pINT + 2; \/\/in CODESYS, pINT then points to array_of_int[1] Dieser Code würde in C anders funktionieren: short* pShort\npShort = &(array_of_short[0])\npShort = pShort + 2; \/\/in C, pShort then points to array_of_short[2] Daher sollte man in CODESYS immer ein Vielfaches der Basisgröße des Pointers zu einem Pointer addieren. Ansonsten zeigt der Pointer möglicherweise auf einen nicht-ausgerichteten ( not aligned ) Speicher was (je nach Prozessor) beim Zugriff zu einer Alignment-Exception führen kann. Wichtigkeit: Hoch Beispiel VAR\n pudiTest:POINTER TO UDINT;\n udiTest:UDINT;\n prTest:POINTER TO REAL;\n rTest:REAL;\nEND_VAR pudiTest := ADR(udiTest) + 4; \/\/ OK\npudiTest := ADR(udiTest) + ( 2 + 2 ); \/\/ OK\npudiTest := ADR(udiTest) + SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + 3; \/\/ SA0065\npudiTest := ADR(udiTest) + 2*SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + ( 3 + 2 ); \/\/ SA0065\nprTest := ADR(rTest);\nprTest := prTest + 4; \/\/ OK\nprTest := prTest + ( 2 + 2 ); \/\/ OK\nprTest := prTest + SIZEOF(REAL); \/\/ OK\nprTest := prTest + 1; \/\/ SA0065\nprTest := prTest + 2; \/\/ SA0065\nprTest := prTest + 3; \/\/ SA0065\nprTest := prTest + ( SIZEOF(REAL) - 1 ); \/\/ SA0065\nprTest := prTest + ( 1 + 4 ); \/\/ SA0065\n Ausgabe unter Ansicht Meldungen : SA0065: Pointeraddition passt nicht zur Basisgröße " }, 
{ "title" : "SA0066: Verwendung von Zwischenergebnissen ", 
"url" : "_san_rule_sa0066.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Operatoren \/ SA0066: Verwendung von Zwischenergebnissen ", 
"snippet" : "Ermittelt Verwendungen von Zwischenergebnissen in Anweisungen mit einem Datentyp, der kleiner als die Registergröße ist. In diesem Fall führt der implizite Cast gegebenenfalls zu unerwünschten Ergebnissen. Begründung: CODESYS Static Analysis führt aus Performancegründen Operationen auf der Registerb...", 
"body" : "Ermittelt Verwendungen von Zwischenergebnissen in Anweisungen mit einem Datentyp, der kleiner als die Registergröße ist. In diesem Fall führt der implizite Cast gegebenenfalls zu unerwünschten Ergebnissen. Begründung: CODESYS Static Analysis führt aus Performancegründen Operationen auf der Registerbreite des Prozessors aus. Zwischenergebnisse werden nicht abgeschnitten! Das kann zu Fehlinterpretationen führen, wie im folgenden Fall: Beispiel usintTest := 0; xError := usintTest - 1 <> 255; In CODESYS ist xError in diesem Fall TRUE , weil die Operation usintTest - 1 typischerweise als 32-Bit-Operation ausgeführt wird und das Ergebnis nicht auf die Größe von Byte gecastet wird. Im Register steht dann der Wert 16#ffffffff und dieser ist ungleich 255. Um dies zu umgehen müssen Sie das Zwischenergebnis explizit casten: xError := TO_USINT(usintTest - 1) <> 255; Wenn diese Meldung aktiviert ist, werden sehr viele eher unproblematische Stellen im Code gemeldet werden. Ein Problem kann zwar nur entstehen, wenn die Operation einen Überlauf oder Unterlauf im Datentyp produziert, die statische Analyse kann dies aber für die einzelnen Stellen nicht differenziert erkennen. Wenn Sie an allen gemeldeten Stellen einen expliziten Typcast einbauen, dann wird der Code deutlich langsamer und unleserlicher! Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG\nVAR\n byTest:BYTE;\n liTest:LINT;\n xError:BOOL;\nEND_VAR \/\/type size smaller than register size;\nbyTest := 0;\nIF (byTest - 1) <> 255 THEN \/\/use of temporary result + implicit casting -> SA0066\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n\n\/\/type size equal to or bigger than register size;\nliTest := 0;\nIF (liTest - 1) <> -1 THEN \/\/ use of temporary result and no implicit casting -> OK\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n Ausgabe unter Ansicht Meldungen : SA0066: Verwendung von Zwischenergebnissen (byTest - USINT #1) " }, 
{ "title" : "Regeln für Anweisungen ", 
"url" : "_san_rule_instructions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Anweisungen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0072: Ungültige Verwendung einer Zählervariablen ", 
"url" : "_san_rule_sa0072.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Anweisungen \/ SA0072: Ungültige Verwendung einer Zählervariablen ", 
"snippet" : "Ermittelt die Verwendung einer Zählervariable innerhalb einer FOR -Schleife. Begründung: Eine Manipulation der Zählervariable in einer FOR -Schleife kann leicht zu einer Endlosschleife führen. Um die Ausführung der Schleife für bestimmte Werte der Zählervariable zu unterbinden, arbeiten Sie mit CONT...", 
"body" : "Ermittelt die Verwendung einer Zählervariable innerhalb einer FOR -Schleife. Begründung: Eine Manipulation der Zählervariable in einer FOR -Schleife kann leicht zu einer Endlosschleife führen. Um die Ausführung der Schleife für bestimmte Werte der Zählervariable zu unterbinden, arbeiten Sie mit CONTINUE oder einfach mit einem IF . Wichtigkeit: Hoch PLCopen-Regel: L12 Beispiel PROGRAM PLC_PRG\nVAR_TEMP\n iIndex : INT;\nEND_VAR FOR iIndex := INT#0 TO INT#20 BY INT#1 DO\n iIndex := iIndex - INT#1;\nEND_FOR Ausgabe unter Ansicht Meldungen : SA0072: Ungültige Verwendung einer Zählervariablen 'iIndex' " }, 
{ "title" : "SA0073: Verwendung einer nicht-temporären Zählervariable ", 
"url" : "_san_rule_sa0073.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Anweisungen \/ SA0073: Verwendung einer nicht-temporären Zählervariable ", 
"snippet" : "Ermittelt die Verwendung von nicht-temporären Variablen in FOR -Schleifen. Begründung: Dies ist eine Performance-Warnung. Eine Zählervariable wird in jedem Fall bei jedem Aufruf eines Programmierbausteins initialisiert. Sie können eine solche Variable als temporäre Variable ( VAR_TEMP ) anlegen, ein...", 
"body" : "Ermittelt die Verwendung von nicht-temporären Variablen in FOR -Schleifen. Begründung: Dies ist eine Performance-Warnung. Eine Zählervariable wird in jedem Fall bei jedem Aufruf eines Programmierbausteins initialisiert. Sie können eine solche Variable als temporäre Variable ( VAR_TEMP ) anlegen, ein Zugriff darauf ist unter Umständen schneller, und die Variable belegt keinen dauerhaften Speicherplatz. Wichtigkeit: Mittel PLCopen-Regel: CP21 \/ L13 Beispiel PROGRAM PLC_PRG\nVAR\n nIndex : INT;\n iVar : INT;\nEND_VAR FOR nIndex := INT#0 TO INT#20 BY INT#1 DO\n iVar := iVar + nIndex;\nEND_FOR\n Ausgabe unter Ansicht Meldungen : SA0073: Nicht passende Zählervariable " }, 
{ "title" : "SA0075: Fehlendes ELSE ", 
"url" : "_san_rule_sa0075.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Anweisungen \/ SA0075: Fehlendes ELSE ", 
"snippet" : "Ermittelt CASE -Anweisungen ohne ELSE -Zweig. Begründung: Defensive Programmierung fordert das Vorhandensein eines ELSE in jeder CASE -Anweisung. Wenn im ELSE -Fall nichts zu tun ist, dann sollten Sie dies durch einen Kommentar kennzeichnen. Dem Leser des Codes ist dann klar, dass der Fall nicht ein...", 
"body" : "Ermittelt CASE -Anweisungen ohne ELSE -Zweig. Begründung: Defensive Programmierung fordert das Vorhandensein eines ELSE in jeder CASE -Anweisung. Wenn im ELSE -Fall nichts zu tun ist, dann sollten Sie dies durch einen Kommentar kennzeichnen. Dem Leser des Codes ist dann klar, dass der Fall nicht einfach vergessen wurde. Wichtigkeit: Niedrig PLCopen-Regel: L17 Bei CASE -Anweisungen, die Aufzählungen mit Attribut strict verwenden und bei denen alle Enum-Konstanten in der CASE -Anweisung verwendet werden, wird keine Fehlermeldung ausgegeben. Beispiel PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\nCASE iVar OF\n INT#1:\n xTemp := FALSE;\n INT#2:\n xTemp := TRUE;\nEND_CASE\n Ausgabe unter Ansicht Meldungen : SA0075: Fehlendes ELSE in CASE-Anweisung " }, 
{ "title" : "SA0076: Fehlende Aufzählungskonstante ", 
"url" : "_san_rule_sa0076.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Anweisungen \/ SA0076: Fehlende Aufzählungskonstante ", 
"snippet" : "Ermittelt, ob in CASE -Anweisungen jede Enumerationskonstante als Bedingung verwendet und in einem CASE -Zweige abgefragt wird. Begründung: Defensive Programmierung erfordert die Bearbeitung aller möglichen Werte einer Enumeration. Wenn für einen bestimmten Enumerationswert keine Aktion nötig ist, d...", 
"body" : "Ermittelt, ob in CASE -Anweisungen jede Enumerationskonstante als Bedingung verwendet und in einem CASE -Zweige abgefragt wird. Begründung: Defensive Programmierung erfordert die Bearbeitung aller möglichen Werte einer Enumeration. Wenn für einen bestimmten Enumerationswert keine Aktion nötig ist, dann sollten Sie dies explizit durch einen Kommentar kennzeichnen. Dem Leser des Codes ist dann klar, dass der Wert nicht einfach vergessen wurde. Wichtigkeit: Niedrig Beispiel TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iVar : My_Enum;\n xTemp : BOOL;\nEND_VAR iVar := My_Enum.black;\nCASE iVar OF\n My_Enum.red:\n xTemp := FALSE;\n My_Enum.blue, My_Enum.green:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n Ausgabe unter Ansicht Meldungen : SA0076: Aufzählungskonstante 'black' fehlt in CASE-Anweisung " }, 
{ "title" : "SA0077: Unstimmigkeit des Enumerationstyps mit CASE -Ausdruck ", 
"url" : "_san_rule_sa0077.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Anweisungen \/ SA0077: Unstimmigkeit des Enumerationstyps mit CASE -Ausdruck ", 
"snippet" : "Erkennt Codepositionen, an denen eine CASE -Anweisung Enumerationswerte mit Nicht-Enumerationstypen vermischt. Begründung: Die Vermischung von Enumerationswerten und Integer-Werten in CASE-Konstrukten verletzt die Datentypsicherheit, verringert die Lesbarkeit des Codes und beeinträchtigt die Wartbar...", 
"body" : "Erkennt Codepositionen, an denen eine CASE -Anweisung Enumerationswerte mit Nicht-Enumerationstypen vermischt. Begründung: Die Vermischung von Enumerationswerten und Integer-Werten in CASE-Konstrukten verletzt die Datentypsicherheit, verringert die Lesbarkeit des Codes und beeinträchtigt die Wartbarkeit. Enumerationswerte sorgen für semantische Klarheit. Die Verwendung von rohen Integer-Werten bergen das Risiko subtiler Fehler und machen den Code schwerer verständlich. Datentypänderungen an Enumerationen können außerdem integerbasierte Verzweigungen unbemerkt zerstören. Wichtigkeit: Niedrig Beispiel {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE DUT_MyEnum :\n(\n\tOne := 1, \n\tTwo := 2, \n\tThree := 3, \n\tFour := 4\n);\nEND_TYPE PROGRAM PRG_Case\nVAR\ndiVar : DINT;\nxTemp : BOOL;\n\neMyEnum : DUT_MyEnum;\nEND_VAR\n CASE diVar OF\n 1 :\n xTemp := FALSE;\n DUT_MyEnum.Two : \/\/ SA0077\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n\nCASE eMyEnum OF\n 1 : \/\/ SA0077\n xTemp := FALSE;\n DUT_MyEnum.Two:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE Ausgabe unter Ansicht Meldungen : SA0077: Unstimmigkeit des Enum-Typs mit CASE-Ausdruck " }, 
{ "title" : "SA0078: CASE-Anweisungen ohne CASE-Zweig ", 
"url" : "_san_rule_sa0078.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Anweisungen \/ SA0078: CASE-Anweisungen ohne CASE-Zweig ", 
"snippet" : "Ermittelt CASE -Anweisungen ohne CASE -Zweige und mit nur einer ELSE -Anweisung. Begründung: Eine CASE -Anweisung ohne Fälle kostet nur Zeit in der Ausführung und ist schwer zu lesen. Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG VAR iVar : INT; xTemp : BOOL; END_VAR iVar := iVar + INT#1; \/\/in the fo...", 
"body" : "Ermittelt CASE -Anweisungen ohne CASE -Zweige und mit nur einer ELSE -Anweisung. Begründung: Eine CASE -Anweisung ohne Fälle kostet nur Zeit in der Ausführung und ist schwer zu lesen. Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\n\/\/in the following the case descriptions are missing:\nCASE iVar OF\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n Ausgabe unter Ansicht Meldungen : SA0078: CASE-Anweisungen ohne CASE-Zweig " }, 
{ "title" : "SA0081: Obergrenze ist kein konstanter Wert ", 
"url" : "_san_rule_sa0081.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Anweisungen \/ SA0081: Obergrenze ist kein konstanter Wert ", 
"snippet" : "Ermittelt die FOR -Anweisungen, bei denen die Obergrenze nicht mit einem konstanten Wert definiert ist. Begründung: Wenn die Obergrenze einer Schleife ein variabler Wert ist, dann lässt sich nicht mehr erkennen wie oft eine Schleife ausgeführt wird. Dies kann zur Laufzeit zu gravierenden Problemen f...", 
"body" : "Ermittelt die FOR -Anweisungen, bei denen die Obergrenze nicht mit einem konstanten Wert definiert ist. Begründung: Wenn die Obergrenze einer Schleife ein variabler Wert ist, dann lässt sich nicht mehr erkennen wie oft eine Schleife ausgeführt wird. Dies kann zur Laufzeit zu gravierenden Problemen führen, im schlimmsten Fall zu einer Endlosschleife. Wichtigkeit: Hoch Beispiel PROGRAM PLC_PRG\nVAR\n i:INT;\n iBorder1: INT := 10;\n iBorder2: INT := 10;\n iCounter: INT;\nEND_VAR\nVAR CONSTANT\n ciBorder:INT := 10;\nEND_VAR\n FOR i:=0 TO 10 DO \/\/OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO ciBorder DO \/\/ OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder1 DO \/\/ SA0081\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder2 DO \/\/ SA0081\n iCounter := i;\n IF iCounter = 10 THEN\n iBorder2 := 50;\n END_IF\nEND_FOR\n Ausgabe unter Ansicht Meldungen : SA0081: Obergrenze für eine FOR-Schleife muss ein konstanter Wert sein " }, 
{ "title" : "SA0090: POUs sollen eine einzige Exit-Stelle haben ", 
"url" : "_san_rule_sa0090.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Regeln für Anweisungen \/ SA0090: POUs sollen eine einzige Exit-Stelle haben ", 
"snippet" : "Erkennt Codestellen, an denen die RETURN -Anweisung nicht die letzte Anweisung in einer Funktion, Methode, Eigenschaft oder einem Programm ist. Es werden auch Stellen erkannt, an denen ein RETURN innerhalb einer IF -Verzweigung steht. Begründung: Ein RETURN im Code führt zu schlechterer Wartbarkeit,...", 
"body" : "Erkennt Codestellen, an denen die RETURN -Anweisung nicht die letzte Anweisung in einer Funktion, Methode, Eigenschaft oder einem Programm ist. Es werden auch Stellen erkannt, an denen ein RETURN innerhalb einer IF -Verzweigung steht. Begründung: Ein RETURN im Code führt zu schlechterer Wartbarkeit, Testbarkeit und Lesbarkeit des Codes. Ein RETURN im Code wird leicht übersehen. Sie müssen Code, der auf alle Fälle beim Austritt einer Funktion ausgeführt werden sollte, vor jedem RETURN einfügen und das wird oft vergessen. Wichtigkeit: Mittel PLCopen-Regel: CP14 Beispiel FUNCTION SA0090: DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR IF bTest THEN\n RETURN;\nEND_IF\nSA0090 := 99; Ausgabe unter Ansicht Meldungen : SA0090: POUs sollen eine einzige Exit-Stelle haben " }, 
{ "title" : "SA0095: Zuweisung in Bedingung ", 
"url" : "_san_rule_sa0095.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0095: Zuweisung in Bedingung ", 
"snippet" : "Ermittelt Zuweisungen in Bedingungen von IF -, CASE - oder REPEAT -Konstrukten. Begründung: Ein Zuweisung (:=) und ein Vergleich (=) kann leicht verwechselt werden. Eine Zuweisung in einer Bedingung kann daher leicht unabsichtlich erfolgt sein, und wird deswegen gemeldet. Auch der Leser des Codes ka...", 
"body" : "Ermittelt Zuweisungen in Bedingungen von IF -, CASE - oder REPEAT -Konstrukten. Begründung: Ein Zuweisung (:=) und ein Vergleich (=) kann leicht verwechselt werden. Eine Zuweisung in einer Bedingung kann daher leicht unabsichtlich erfolgt sein, und wird deswegen gemeldet. Auch der Leser des Codes kann dadurch verwirrt werden. Wichtigkeit: Hoch Beispiel PROGRAM PLC_PRG\nVAR\n iCond1:INT := INT#1;\n iCond2:INT := INT#2;\n xCond:BOOL := FALSE;\n iVar : INT;\nEND_VAR IF INT_TO_BOOL(iCond1 := iCond2) THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\n ELSIF (iCond1 := 11) = 11 THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF xCond := TRUE THEN \/\/ SA0095\n xCond := FALSE;\nEND_IF\n\nIF (xCond := FALSE) OR (iCond1 := iCond2) = 12 THEN \/\/ SA0095\n xCond := FALSE;\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF (iVar := iVar + 1) = 120 THEN \/\/ SA0095 (can be valid, but is not reparable very well\n iVar := 0;\nEND_IF\n\nWHILE (xCond = TRUE) OR (iCond1 := iCond2) = 12 DO \/\/ SA0095\n xCond := FALSE;\nEND_WHILE\n\n\/\/Error: assignment in repeat loop\nREPEAT\n xCond := FALSE;\nUNTIL (xCond = TRUE) OR (iCond1 := iCond2) = 12 \/\/ SA0095\nEND_REPEAT Ausgabe unter Ansicht Meldungen : SA0095: Zuweisung in Bedingung '...' " }, 
{ "title" : "SA0100: Variablen größer als <n> Bytes ", 
"url" : "_san_rule_sa0100.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0100: Variablen größer als <n> Bytes ", 
"snippet" : "Ermittelt Variablen, die mehr als n Bytes verwenden, wobei n durch die aktuelle Konfiguration vorgegeben ist. Standardwert: 1024 Bytes. Der Wert kann durch einen Doppelklick auf die Zeile verändert werden. Begründung: Manche Programmierrichtlinien legen eine maximale Größe für eine einzelne Variable...", 
"body" : "Ermittelt Variablen, die mehr als n Bytes verwenden, wobei n durch die aktuelle Konfiguration vorgegeben ist. Standardwert: 1024 Bytes. Der Wert kann durch einen Doppelklick auf die Zeile verändert werden. Begründung: Manche Programmierrichtlinien legen eine maximale Größe für eine einzelne Variable fest. Dies kann hiermit überprüft werden. Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG\nVAR\n aobyTest : ARRAY [0..1024] OF BYTE;\nEND_VAR\n aobyTest[INT#0] := aobyTest[INT#0] + BYTE#1; Ausgabe unter Ansicht Meldungen : SA0100: Variablen 'aobyTest' größer als 1024 Bytes " }, 
{ "title" : "SA0101: Namen mit unzulässiger Länge ", 
"url" : "_san_rule_sa0101.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0101: Namen mit unzulässiger Länge ", 
"snippet" : "Ermittelt Namen mit unzulässiger Länge. Begründung: In manchen Programmierrichtlinien wird eine Mindestlänge für Variablennamen festgelegt. Die Einhaltung kann mit dieser Analyse überprüft werden. Wichtigkeit: Niedrig PLCopen-Regel: N6 Im Dialog Einstellungen Statische Analyse: Regeln werden alle Re...", 
"body" : "Ermittelt Namen mit unzulässiger Länge. Begründung: In manchen Programmierrichtlinien wird eine Mindestlänge für Variablennamen festgelegt. Die Einhaltung kann mit dieser Analyse überprüft werden. Wichtigkeit: Niedrig PLCopen-Regel: N6 Im Dialog Einstellungen Statische Analyse: Regeln werden alle Regeln gelistet. Dort können Sie durch Doppelklick auf die Regel 101 die regelspezifische Konfiguration öffnen. Daraufhin können Sie Im Dialog Länge der Namen die minimale und maximale Anzahl an Zeichen definieren und Ausnahmen davon festlegen. Beispiel PROGRAM PLC1 \/\/ SA0101\nVAR\n iVar1 : INT; \/\/ SA0101\nEND_VAR\n Ausgabe unter Ansicht Meldungen : SA0101: Unzulässige Länge des Namens 'PLC1' " }, 
{ "title" : "SA0102: Zugriff von außen auf lokale Variablen ", 
"url" : "_san_rule_sa0102.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0102: Zugriff von außen auf lokale Variablen ", 
"snippet" : "Ermittelt Zugriffe von außen auf lokale Variablen von Programmen oder Funktionsbausteinen. Begründung: CODESYS ermöglicht einen Lesezugriff von außen auf lokale Variablen von Programmen oder von Funktionsbausteinen. Dies bricht mit dem Grundsatz der Datenkapselung (Verbergen von Daten) und entsprich...", 
"body" : "Ermittelt Zugriffe von außen auf lokale Variablen von Programmen oder Funktionsbausteinen. Begründung: CODESYS ermöglicht einen Lesezugriff von außen auf lokale Variablen von Programmen oder von Funktionsbausteinen. Dies bricht mit dem Grundsatz der Datenkapselung (Verbergen von Daten) und entspricht nicht der Norm IEC 61131-3. Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n afb_Instance : AFB;\n bfb_Instance : BFB;\nEND_VAR iCounter := A_PRG.iLocal; \/\/ SA0102\niCounter := bfb_Instance.iLocal; \/\/ SA0102\nA_PRG(); FUNCTION_BLOCK AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iLocal: INT;\nEND_VAR METHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; FUNCTION_BLOCK BFB EXTENDS AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\nEND_VAR\nMETHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; PROGRAM A_PRG\nVAR\n iLocal: INT;\nEND_VAR iLocal := iLocal + 1;\n Ausgabe unter Ansicht Meldungen : SA0102: Zugriff auf Programm- \/FB-Variablen 'iLocal' von außen " }, 
{ "title" : "SA0103: Gleichzeitiger Zugriff auf nicht-atomare Daten ", 
"url" : "_san_rule_sa0103.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0103: Gleichzeitiger Zugriff auf nicht-atomare Daten ", 
"snippet" : "Ermittelt, ob nicht-atomare Variablen (zum Beispiel mit Datentyp STRING , WSTRING , ARRAY , STRUCT , FB-Instanzen, 64-Bit-Datentypen) in mehr als einer Task verwendet werden. Begründung: Wenn keine Synchronisation beim Zugriff erfolgt, dann kann es bei gleichzeitigem Lesen in einer Task und Schreibe...", 
"body" : "Ermittelt, ob nicht-atomare Variablen (zum Beispiel mit Datentyp STRING , WSTRING , ARRAY , STRUCT , FB-Instanzen, 64-Bit-Datentypen) in mehr als einer Task verwendet werden. Begründung: Wenn keine Synchronisation beim Zugriff erfolgt, dann kann es bei gleichzeitigem Lesen in einer Task und Schreiben in einer anderen Task dazu kommen, dass inkonsistente Werte gelesen werden. Wichtigkeit: Mittel Für manche Datentypen, insbesondere 64-Bit-Integer, ist es von der Plattform abhängig, ob der Zugriff atomar erfolgt oder nicht. Die statische Codeanalyse meldet ein Problem nur, wenn die Steuerung den atomaren Zugriff auf 64-Bit-Integer-Datentypen nicht unterstützt. In folgenden Fällen greift diese Regel nicht: Wenn das Zielsystem eine FPU (Floating Point Unit) besitzt, wird der Zugriff mehrerer Tasks auf LREAL -Variablen nicht ermittelt Wenn das Zielsystem ein 64-Bit-Prozessor ist oder das entsprechende Target Setting für das Zielgerät gesetzt ist, greift die Regel nicht für 64-Bit-Datentypen Beispiel Das Projekt enthält die beiden Programme PRG1 und PRG2 . Das Programm PRG1 wird von der Task MainTask_1 aufgerufen, das Programm PRG2 von der Task MainTask_2 . VAR_GLOBAL\n lrTest : LREAL; \/\/ Since the target system has an FPU, SA0103 does apply.\n lint1 : LINT;\n sTest : STRING; \/\/ SA0103\n wsTest : WSTRING; \/\/ SA0103\nEND_VAR PROGRAM PRG1 GVL.lrTest := 5.0;\nGVL.sTest := 'welt';\nGVL.wsTest := \"welt\";\nGVL.lint1 := 99;\n PROGRAM PRG2 GVL.lrTest := 5.0;\nGVL.sTest := 'hallo';\nGVL.wsTest := \"hallo\";\nGVL.lint1 := 88; Ausgabe unter Ansicht Meldungen : SA0103: Gleichzeitiger Zugriff auf nicht-atomare Daten 'sTest' SA0103: Gleichzeitiger Zugriff auf nicht-atomare Daten 'wsTest' " }, 
{ "title" : "SA0105: Mehrfache Instanzaufrufe ", 
"url" : "_san_rule_sa0105.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0105: Mehrfache Instanzaufrufe ", 
"snippet" : "Ermittelt die Instanzen von Funktionsbausteinen, die mehrfach aufgerufen werden. Dazu müssen die Funktionsbausteine mit folgendem Pragma gekennzeichnet sein: {attribute 'analysis:report-multiple-instance-calls'} Begründung: Einige Funktionsbausteine sind so designt, dass sie nur einmal im Zyklus auf...", 
"body" : "Ermittelt die Instanzen von Funktionsbausteinen, die mehrfach aufgerufen werden. Dazu müssen die Funktionsbausteine mit folgendem Pragma gekennzeichnet sein: {attribute 'analysis:report-multiple-instance-calls'} Begründung: Einige Funktionsbausteine sind so designt, dass sie nur einmal im Zyklus aufgerufen werden können. Dieser Test prüft, ob ein Aufruf an mehreren Stellen erfolgt. Wichtigkeit: Niedrig PLCopen-Regel: CP16 \/ CP20 Beispiel \/\/ {attribute 'analysis:report-multiple-instance-calls'} Deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\n iA := iA + 1; {attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\n iB := iB + 1; PROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nEND_VAR fbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n Ausgabe unter Ansicht Meldungen : SA0105: Instanz 'fbB' mehrmals aufgerufen " }, 
{ "title" : "SA0106: Virtuelle Methodenaufrufe in FB_Init ", 
"url" : "_san_rule_sa0106.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0106: Virtuelle Methodenaufrufe in FB_Init ", 
"snippet" : "Ermittelt Methodenaufrufe in der Methode FB_Init eines Basis-Funktionsbausteins, die von einem vom Basis-FB abgeleiteten Funktionsbaustein überschrieben werden. Begründung: In solchen Fällen kann es sein, dass die Variablen in überschriebenen Methoden im Basis-FB nicht initialisiert sind. Wichtigkei...", 
"body" : "Ermittelt Methodenaufrufe in der Methode FB_Init eines Basis-Funktionsbausteins, die von einem vom Basis-FB abgeleiteten Funktionsbaustein überschrieben werden. Begründung: In solchen Fällen kann es sein, dass die Variablen in überschriebenen Methoden im Basis-FB nicht initialisiert sind. Wichtigkeit: Hoch Beispiel Funktionsbaustein FB_A hat die Methoden FB_Init und Meth_MyInit . FB_Init ruft Meth_MyInit zur Initialisierung auf. Funktionsbaustein FB_B ist von FB_A abgeleitet. PLC_PRG ruft FB_B auf und verwendet damit dessen Variable mbMyDintB bevor sie initialisiert wurde. FB_B.Meth_MyInit überschreibt FB_A.Meth_MyInit . FUNCTION_BLOCK FB_A\nVAR\n mbMyDintA : DINT;\nEND_VAR FUNCTION_BLOCK FB_B EXTENDS FB_A\nVAR\n mbMyDintB : DINT;\nEND_VAR METHOD FB_Init : BOOL\nVAR_INPUT\n bInitRetains:BOOL;\n bInCopyCode:BOOL;\nEND_VAR\nVAR\n diDummy:DINT; \/\/SA0106\nEND_VAR\n mbMyDintA := 123;\ndiDummy := Meth_MyInit(); METHOD Meth_MyInit : DINT\nVAR_INPUT\nEND_VAR\n mbMyDintB := 123; \/\/access to member of FB_B PROGRAM PLC_PRG\nVAR\n g_BInst : FB_B;\n xVar : BOOL;\nEND_VAR\n\n xVar := g_BInst.fb_init(TRUE, TRUE);\n\/\/this instruction causes the following order of initializations:\n\/\/FB_A.fb_init\n\/\/FB_B.Meth_MyInit \/\/SA0106\n\/\/FB_B.fb_init\n\/\/FB_B.Meth_MyInit Ausgabe unter Ansicht Meldungen : SA0106: Virtueller Methodenaufruf 'Meth_MyInit' in FB_INIT " }, 
{ "title" : "SA0107: Fehlen von formalen Parametern ", 
"url" : "_san_rule_sa0107.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0107: Fehlen von formalen Parametern ", 
"snippet" : "Ermittelt, ob formale Parameter fehlen. Begründung: Code wird lesbarer, wenn die formalen Parameter beim Aufruf angegeben werden. Wichtigkeit: Niedrig Beispiel FUNCTION FUNA : BOOL VAR_INPUT bDo : BOOL; bInit : BOOL; bManual : BOOL; END_VAR VAR iInit : INT; iLocal : INT; iManual : INT; END_VAR IF bI...", 
"body" : "Ermittelt, ob formale Parameter fehlen. Begründung: Code wird lesbarer, wenn die formalen Parameter beim Aufruf angegeben werden. Wichtigkeit: Niedrig Beispiel FUNCTION FUNA : BOOL\nVAR_INPUT\n bDo : BOOL;\n bInit : BOOL;\n bManual : BOOL;\nEND_VAR\nVAR\n iInit : INT;\n iLocal : INT;\n iManual : INT;\nEND_VAR\n IF bInit = TRUE THEN\n iInit := iInit + 1;\nEND_IF\nIF bDo = TRUE THEN\n iLocal := iLocal + 1;\nEND_IF\nIF bManual = TRUE THEN\n iManual := iManual + 1;\nEND_IF\nFUNA := TRUE;\n PROGRAM PLC_PRG\nVAR\nEND_VAR\n FUNA(bInit := TRUE, bDo := TRUE, bManual := FALSE); \/\/ OK\nFUNA(TRUE, TRUE, bManual:= FALSE); \/\/ SA0107 Ausgabe unter Ansicht Meldungen : SA0107: Fehlender formaler Parameter für Eingang 'TRUE' " }, 
{ "title" : "Strikte IEC-Regeln prüfen ", 
"url" : "_san_check_strict_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0111: Pointervariablen ", 
"url" : "_san_rule_sa0111.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0111: Pointervariablen ", 
"snippet" : "Ermittelt Variablen des Typs POINTER TO . Begründung: Die Norm IEC 61131-3 erlaubt keine Pointer. Wichtigkeit: Niedrig Beispiel VAR piTemp : POINTER TO INT; pbyTemp : POINTER TO BYTE; END_VAR Ausgabe unter Ansicht Meldungen : SA0111: Datentyp POINTER nicht erlaubt...", 
"body" : "Ermittelt Variablen des Typs POINTER TO . Begründung: Die Norm IEC 61131-3 erlaubt keine Pointer. Wichtigkeit: Niedrig Beispiel VAR\n piTemp : POINTER TO INT;\n pbyTemp : POINTER TO BYTE;\nEND_VAR\n Ausgabe unter Ansicht Meldungen : SA0111: Datentyp POINTER nicht erlaubt " }, 
{ "title" : "SA0112: Referenzvariablen ", 
"url" : "_san_rule_sa0112.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0112: Referenzvariablen ", 
"snippet" : "Ermittelt Variablen des Typs REFERENCE TO . Begründung: Die Norm IEC 61131-3 erlaubt keine Referenzen. Wichtigkeit: Niedrig Beispiel VAR ref_int : REFERENCE TO INT; ref_dw : REFERENCE TO DWORD; END_VAR Ausgabe unter Ansicht Meldungen : SA0112: Datentyp REFERENCE nicht erlaubt...", 
"body" : "Ermittelt Variablen des Typs REFERENCE TO . Begründung: Die Norm IEC 61131-3 erlaubt keine Referenzen. Wichtigkeit: Niedrig Beispiel VAR\n ref_int : REFERENCE TO INT;\n ref_dw : REFERENCE TO DWORD;\nEND_VAR\n Ausgabe unter Ansicht Meldungen : SA0112: Datentyp REFERENCE nicht erlaubt " }, 
{ "title" : "SA0113: Variablen mit Datentyp WSTRING ", 
"url" : "_san_rule_sa0113.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0113: Variablen mit Datentyp WSTRING ", 
"snippet" : "Ermittelt Variablen des Typs WSTRING . Begründung: Nicht alle Systeme unterstützen WSTRING . Der Code wird leichter portierbar, wenn man auf WSTRING verzichtet. Wichtigkeit: Niedrig Beispiel VAR wstrTemp : WSTRING; END_VAR Ausgabe unter Ansicht Meldungen : SA0113: Datentyp WSTRING nicht erlaubt...", 
"body" : "Ermittelt Variablen des Typs WSTRING . Begründung: Nicht alle Systeme unterstützen WSTRING . Der Code wird leichter portierbar, wenn man auf WSTRING verzichtet. Wichtigkeit: Niedrig Beispiel VAR\n wstrTemp : WSTRING;\nEND_VAR\n Ausgabe unter Ansicht Meldungen : SA0113: Datentyp WSTRING nicht erlaubt " }, 
{ "title" : "SA0114: Variablen mit Datentyp LTIME ", 
"url" : "_san_rule_sa0114.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0114: Variablen mit Datentyp LTIME ", 
"snippet" : "Ermittelt Variablen des Typs LTIME . Begründung: Nicht alle Systeme unterstützen LTIME . Der Code wird portierbarer, wenn man auf LTIME verzichtet. Wichtigkeit: Niedrig Beispiel VAR ltVar : LTIME; \/\/ SA0114 END_VAR Ausgabe unter Ansicht Meldungen : SA0114: Datentyp LTIME nicht erlaubt Für weitere In...", 
"body" : "Ermittelt Variablen des Typs LTIME . Begründung: Nicht alle Systeme unterstützen LTIME . Der Code wird portierbarer, wenn man auf LTIME verzichtet. Wichtigkeit: Niedrig Beispiel VAR\n ltVar : LTIME; \/\/ SA0114\nEND_VAR\n Ausgabe unter Ansicht Meldungen : SA0114: Datentyp LTIME nicht erlaubt Für weitere Informationen siehe: Attribut 'analysis:report-multiple-instance-calls' " }, 
{ "title" : "SA0115: Deklarationen mit Datentyp UNION ", 
"url" : "_san_rule_sa0115.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0115: Deklarationen mit Datentyp UNION ", 
"snippet" : "Ermittelt Deklarationen eines UNION -Datentyps und Deklarationen von Variablen vom Typ einer UNION . Begründung: Die Norm IEC-61131-3 kennt keine Unions. Der Code wird leichter portierbar, wenn Sie auf Unions verzichten. Wichtigkeit: Niedrig Beispiel TYPE A_UNION: UNION lrTemp : LREAL; liTemp : LINT...", 
"body" : "Ermittelt Deklarationen eines UNION -Datentyps und Deklarationen von Variablen vom Typ einer UNION . Begründung: Die Norm IEC-61131-3 kennt keine Unions. Der Code wird leichter portierbar, wenn Sie auf Unions verzichten. Wichtigkeit: Niedrig Beispiel TYPE A_UNION: \nUNION\n lrTemp : LREAL;\n liTemp : LINT;\nEND_UNION\nEND_TYPE PROGRAM PLC_PRG\nVAR\n aunionVar: A_UNION;\n liVar : LINT;\nEND_VAR aunionVar.lrTemp := 0.123E-12;\nliVar := aunionVar.liTemp; Ausgabe unter Ansicht Meldungen : SA0115: Unions nicht erlaubt " }, 
{ "title" : "SA0117: Variablen mit Datentyp BIT ", 
"url" : "_san_rule_sa0117.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0117: Variablen mit Datentyp BIT ", 
"snippet" : "Ermittelt Deklarationen von Variablen vom Typ BIT (möglich innerhalb von Strukturdefinitionen). Begründung: Die IEC-61131-3 kennt keinen Datentyp BIT . Der Code wird leichter portierbar, wenn Sie auf BIT verzichten. Wichtigkeit: Niedrig Beispiel TYPE Struct1 : STRUCT bitVar : BIT; iVar : INT; bVar :...", 
"body" : "Ermittelt Deklarationen von Variablen vom Typ BIT (möglich innerhalb von Strukturdefinitionen). Begründung: Die IEC-61131-3 kennt keinen Datentyp BIT . Der Code wird leichter portierbar, wenn Sie auf BIT verzichten. Wichtigkeit: Niedrig Beispiel TYPE Struct1 :\nSTRUCT\n bitVar : BIT;\n iVar : INT;\n bVar : BOOL;\nEND_STRUCT\nEND_TYPE\n Ausgabe unter Ansicht Meldungen : SA0117: Variablen mit Datentyp BIT " }, 
{ "title" : "SA0119: Objektorientierte Funktionalität ", 
"url" : "_san_rule_sa0119.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0119: Objektorientierte Funktionalität ", 
"snippet" : "Ermittelt die Verwendung objektorientierter Funktionalitäten wie beispielsweise Funktionsbaustein-Deklarationen mit EXTENDS und IMPLEMENTS , oder auch Eigenschaften- und Schnittstellendeklarationen. Diese Regel ist nützlich, wenn Sie Code schreiben, der auf andere 61131-3-Systeme portiert werden sol...", 
"body" : "Ermittelt die Verwendung objektorientierter Funktionalitäten wie beispielsweise Funktionsbaustein-Deklarationen mit EXTENDS und IMPLEMENTS , oder auch Eigenschaften- und Schnittstellendeklarationen. Diese Regel ist nützlich, wenn Sie Code schreiben, der auf andere 61131-3-Systeme portiert werden soll. Begründung: Nicht alle Systeme unterstützen Objektorientierte Programmierung. Der Code wird leichter portierbar, wenn Sie auf Objektorientierung verzichten. Wichtigkeit: Niedrig Beispiel \/\/Function block extended by another and implementing an interface:\nFUNCTION_BLOCK POU EXTENDS CTD IMPLEMENTS ITF \/\/SA0119\n;\n \/\/ Declaration parts of property methods assigned to a function block:\nPOU.Prop.Get \/\/SA0119 POU.Prop.Set \/\/SA0119 Ausgabe unter Ansicht Meldungen : SA0119: Objektorientierte Funktionalitäten nicht erlaubt " }, 
{ "title" : "SA0120: Programmaufrufe ", 
"url" : "_san_rule_sa0120.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0120: Programmaufrufe ", 
"snippet" : "Ermittelt Programmaufrufe. Begründung: Nach der Norm IEC 61131-3 kann man Programme nur in der Taskkonfiguration aufrufen. Der Code wird leichter portierbar, wenn Sie auf Programmaufrufe an anderen Stellen verzichten. Wichtigkeit: Niedrig Beispiel PROGRAM prog_control VAR END_VAR ; PROGRAM PLC_PRG V...", 
"body" : "Ermittelt Programmaufrufe. Begründung: Nach der Norm IEC 61131-3 kann man Programme nur in der Taskkonfiguration aufrufen. Der Code wird leichter portierbar, wenn Sie auf Programmaufrufe an anderen Stellen verzichten. Wichtigkeit: Niedrig Beispiel PROGRAM prog_control\nVAR\nEND_VAR\n; PROGRAM PLC_PRG\nVAR\nEND_VAR\n prog_control(); Ausgabe unter Ansicht Meldungen : SA0120: Programmaufruf von 'prg_control' nicht erlaubt " }, 
{ "title" : "SA0121: Fehlende VAR_EXTERNAL-Deklarationen ", 
"url" : "_san_rule_sa0121.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0121: Fehlende VAR_EXTERNAL-Deklarationen ", 
"snippet" : "Ermittelt die Verwendung einer globalen Variablen in Funktionsbausteinen, ohne dass sie dort als VAR_EXTERNAL deklariert ist. Begründung: Nach der Norm IEC 61131-3 ist der Zugriff auf globale Variablen nur über einen expliziten Import durch eine VAR_EXTERNAL -Deklaration erlaubt. Wichtigkeit: Niedri...", 
"body" : "Ermittelt die Verwendung einer globalen Variablen in Funktionsbausteinen, ohne dass sie dort als VAR_EXTERNAL deklariert ist. Begründung: Nach der Norm IEC 61131-3 ist der Zugriff auf globale Variablen nur über einen expliziten Import durch eine VAR_EXTERNAL -Deklaration erlaubt. Wichtigkeit: Niedrig PLCopen-Regel: CP18 Beispiel VAR_GLOBAL\n iGlob1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar : INT;\nEND_VAR\n ivar := iGlob1; \/\/ SA0121 Ausgabe unter Ansicht Meldungen : SA0121: VAR_EXTERNAL-Deklaration für Variable 'iGlob1' erforderlich Beispiel zur Fehlervermeidung VAR_GLOBAL\n iGlob1:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar:INT;\nEND_VAR\nVAR_EXTERNAL\n iGlob1:INT;\nEND_VAR\n ivar:=iGlob1; \/\/ OK " }, 
{ "title" : "SA0122: Als Ausdruck definierter Arrayindex ", 
"url" : "_san_rule_sa0122.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0122: Als Ausdruck definierter Arrayindex ", 
"snippet" : "Ermittelt die Verwendung von Ausdrücken bei der Deklaration von Arrayindizes. Begründung: Nicht alle Systeme erlauben Ausdrücke als Arraygrenzen. Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG VAR CONSTANT c_iValue : INT := INT#15; END_VAR VAR arr : ARRAY [0..c_iValue + 1] OF INT; END_VAR Ausgabe unt...", 
"body" : "Ermittelt die Verwendung von Ausdrücken bei der Deklaration von Arrayindizes. Begründung: Nicht alle Systeme erlauben Ausdrücke als Arraygrenzen. Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n arr : ARRAY [0..c_iValue + 1] OF INT;\nEND_VAR\n Ausgabe unter Ansicht Meldungen : SA0122: Nur Konstanten erlaubt für Arraydefinition 'arr' " }, 
{ "title" : "SA0123: Verwendung von INI, ADR oder BITADR ", 
"url" : "_san_rule_sa0123.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0123: Verwendung von INI, ADR oder BITADR ", 
"snippet" : "Ermittelt die Verwendung der CODESYS Static Analysis -spezifischen Operatoren INI , ADR und BITADR . Begründung: CODESYS -spezifische Operatoren verhindern die Portierbarkeit des Codes. Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG VAR uiTemp : UINT; TempVarInFUNC : DWORD; END_VAR TempVarInFUNC := A...", 
"body" : "Ermittelt die Verwendung der CODESYS Static Analysis -spezifischen Operatoren INI , ADR und BITADR . Begründung: CODESYS -spezifische Operatoren verhindern die Portierbarkeit des Codes. Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG\nVAR\n uiTemp : UINT;\n TempVarInFUNC : DWORD;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0123 Ausgabe unter Ansicht Meldungen : SA0123: Operator 'ADR' nicht erlaubt " }, 
{ "title" : "SA0147: Unübliche Verschiebeoperation - strikt ", 
"url" : "_san_rule_sa0147.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0147: Unübliche Verschiebeoperation - strikt ", 
"snippet" : "Ermittelt Bitshift-Operationen, die nicht auf Bitfeld-Datentypen ( BYTE , WORD , DWORD , LWORD ) erfolgen. Begründung: Die Norm IEC 61131-3 erlaubt nur Bitzugriffe auf Bitfeld-Datentypen. Der CODESYS -Compiler erlaubt jedoch auch Bitshift-Operationen mit nicht vorzeichenbehafteten Datentypen. Wichti...", 
"body" : "Ermittelt Bitshift-Operationen, die nicht auf Bitfeld-Datentypen ( BYTE , WORD , DWORD , LWORD ) erfolgen. Begründung: Die Norm IEC 61131-3 erlaubt nur Bitzugriffe auf Bitfeld-Datentypen. Der CODESYS -Compiler erlaubt jedoch auch Bitshift-Operationen mit nicht vorzeichenbehafteten Datentypen. Wichtigkeit: Niedrig Siehe auch die nicht strikte Regel SA0018 . Beispiel PROGRAM PLC_PRG\nVAR\n in_byte : BYTE := 16#45; \/\/ 2#01000101\n in_word : WORD := 16#0045; \/\/ 2#0000000001000101\n in_uint : UINT;\n in_dint : DINT;\n erg_byte : BYTE;\n erg_word : WORD;\n erg_uint : UINT;\n erg_dint : DINT;\n n: BYTE := 2;\nEND_VAR\n erg_byte := SHL(in_byte,n); \/\/ no error because BYTE is a bit field\nerg_word := SHL(in_word,n); \/\/ no error because WORD is a bit field\nerg_uint := SHL(in_uint,n); \/\/ SA0147\nerg_dint := SHL(in_dint,n); \/\/ SA0147 Ausgabe unter Ansicht Meldungen : SA0147: Unübliche Verschiebeoperation - strikt " }, 
{ "title" : "SA0148: Unüblicher Bitzugriff - strikt ", 
"url" : "_san_rule_sa0148.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0148: Unüblicher Bitzugriff - strikt ", 
"snippet" : "Ermittelt Bitzugriffe, die nicht auf Bitfeld-Datentypen ( BYTE , WORD , DWORD , LWORD ) erfolgen. Die Norm IEC 61131-3 erlaubt nur Bitzugriffe auf Bitfeld-Datentypen. Der CODESYS -Compiler erlaubt jedoch auch Bitzugriffe auf nicht vorzeichenbehaftete Datentypen. Wichtigkeit: Niedrig Beispiel PROGRAM...", 
"body" : "Ermittelt Bitzugriffe, die nicht auf Bitfeld-Datentypen ( BYTE , WORD , DWORD , LWORD ) erfolgen. Die Norm IEC 61131-3 erlaubt nur Bitzugriffe auf Bitfeld-Datentypen. Der CODESYS -Compiler erlaubt jedoch auch Bitzugriffe auf nicht vorzeichenbehaftete Datentypen. Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/ SA0148\ndiTemp3.4 := TRUE; \/\/ SA0148\nuliTemp4.18 := FALSE; \/\/ SA0148\nsiTemp5.2 := FALSE; \/\/ SA0148\nusiTemp6.3 := TRUE; \/\/ SA0148\nbyTemp2.5 := FALSE; \/\/ no error because BYTE is a bitfield Ausgabe unter Ansicht Meldungen : SA0148: Unüblicher Bitzugriff - strikt " }, 
{ "title" : "SA0118: Initialisierungen nicht mit Konstanten ", 
"url" : "_san_rule_sa0118.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0118: Initialisierungen nicht mit Konstanten ", 
"snippet" : "Ermittelt Initialisierungen, die nicht Konstanten zuweisen. Begründung: Initialisierungen sollten möglichst konstant sein und sich nicht auf andere Variablen beziehen. Insbesondere sollten Sie Funktionsaufrufe in der Initialisierung vermeiden, weil es dadurch zu Zugriff auf nicht initialisierte Date...", 
"body" : "Ermittelt Initialisierungen, die nicht Konstanten zuweisen. Begründung: Initialisierungen sollten möglichst konstant sein und sich nicht auf andere Variablen beziehen. Insbesondere sollten Sie Funktionsaufrufe in der Initialisierung vermeiden, weil es dadurch zu Zugriff auf nicht initialisierte Daten kommen kann. Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG\nVAR\n dwTemp : DWORD := 22;\n dwTest : DWORD := dwTemp; \/\/ SA0118\n dwVar : DWORD := TempVarInFUNC(); \/\/ SA0118\nEND_VAR\n Ausgabe unter Ansicht Meldungen : SA0118: Initialisierung nicht mit Konstanten durchgeführt " }, 
{ "title" : "SA0124: Pointer-Dereferenzierung im Deklarationsteil ", 
"url" : "_san_rule_sa0124.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0124: Pointer-Dereferenzierung im Deklarationsteil ", 
"snippet" : "Ermittelt Pointer-Dereferenzierungen, die zur Initialisierung im Deklarationsteil verwendet werden. Begründung: Pointer und Referenzen sollten nicht für Initialisierungen verwendet werden, weil es dadurch zu Zugriffsverletzungen kommen kann, wenn der Pointer nicht initialisiert worden ist. Wichtigke...", 
"body" : "Ermittelt Pointer-Dereferenzierungen, die zur Initialisierung im Deklarationsteil verwendet werden. Begründung: Pointer und Referenzen sollten nicht für Initialisierungen verwendet werden, weil es dadurch zu Zugriffsverletzungen kommen kann, wenn der Pointer nicht initialisiert worden ist. Wichtigkeit: Mittel Beispiel TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n pTeststruct : POINTER TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := pTeststruct^.xA; \/\/SA0124 \nEND_VAR\n\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); Ausgabe unter Ansicht Meldungen : SA0124: Pointer-Deferenzierungen im Deklarationsteil " }, 
{ "title" : "SA0125: Referenzvariablen in Initialisierungen ", 
"url" : "_san_rule_sa0125.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Strikte IEC-Regeln prüfen \/ SA0125: Referenzvariablen in Initialisierungen ", 
"snippet" : "Ermittelt Referenzvariablen, die zur Initialisierung im Deklarationsteil verwendet werden. Begründung: Pointer und Referenzen sollten nicht für Initialisierungen verwendet werden, weil es dadurch zu Zugriffsverletzungen kommen kann, wenn der Pointer nicht initialisiert worden ist. Wichtigkeit: Mitte...", 
"body" : "Ermittelt Referenzvariablen, die zur Initialisierung im Deklarationsteil verwendet werden. Begründung: Pointer und Referenzen sollten nicht für Initialisierungen verwendet werden, weil es dadurch zu Zugriffsverletzungen kommen kann, wenn der Pointer nicht initialisiert worden ist. Wichtigkeit: Mittel Beispiel TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n refTeststruct: REFERENCE TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := refTeststruct.xA; \/\/SA0125\nEND_VAR\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); Ausgabe unter Ansicht Meldungen : SA0125: Referenzierung in Initialisierung " }, 
{ "title" : "SA0140: Auskommentierte Anweisungen ", 
"url" : "_san_rule_sa0140.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0140: Auskommentierte Anweisungen ", 
"snippet" : "Ermittelt auskommentierte Anweisungen Begründung: Code wird oft zu Debugging-Zwecken auskommentiert. Wenn ein solcher Kommentar freigegeben wird, dann ist zu einem späteren Zeitpunkt nicht mehr klar, ob der Code gelöscht werden sollte oder ob er nur zu Debug-Zwecken auskommentiert wurde und versehen...", 
"body" : "Ermittelt auskommentierte Anweisungen Begründung: Code wird oft zu Debugging-Zwecken auskommentiert. Wenn ein solcher Kommentar freigegeben wird, dann ist zu einem späteren Zeitpunkt nicht mehr klar, ob der Code gelöscht werden sollte oder ob er nur zu Debug-Zwecken auskommentiert wurde und versehentlich nicht mehr einkommentiert. Wichtigkeit: Hoch PLCopen-Regel: C4 Beispiel PROGRAM PLC_PRG\nVAR\n iValue1: INT;\n iValue2: INT;\nEND_VAR\n iValue1 := 100;\niValue2 := 200;\n\/\/ iValue2 := 300; Ausgabe unter Ansicht Meldungen : SA0140: Auskommentierte Anweisungen: iValue2 := 300 " }, 
{ "title" : "Möglicherweise nicht initialisierte Variablen verwendet ", 
"url" : "_san_non_initialized_variables.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Möglicherweise nicht initialisierte Variablen verwendet ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0039: Mögliche Null-Pointer-Dereferenzierung ", 
"url" : "_san_rule_sa0039.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Möglicherweise nicht initialisierte Variablen verwendet \/ SA0039: Mögliche Null-Pointer-Dereferenzierung ", 
"snippet" : "Ermittelt Codestellen an denen möglicherweise ein Null-Pointer dereferenziert wird. Begründung: Ein Pointer sollte vor jeder Dereferenzierung daraufhin geprüft werden, ob er ungleich 0 ist. Ansonsten kann es zu einer Zugriffsverletzung zur Laufzeit kommen. Wichtigkeit: Hoch Beispiel PROGRAM PLC_PRG ...", 
"body" : "Ermittelt Codestellen an denen möglicherweise ein Null-Pointer dereferenziert wird. Begründung: Ein Pointer sollte vor jeder Dereferenzierung daraufhin geprüft werden, ob er ungleich 0 ist. Ansonsten kann es zu einer Zugriffsverletzung zur Laufzeit kommen. Wichtigkeit: Hoch Beispiel PROGRAM PLC_PRG\nVAR\n ptiVar1:POINTER TO INT;\n ptiVar2:POINTER TO INT;\n ptiVar3:POINTER TO INT;\n iVar:INT;\n iCount :INT;\n iCondition: INT;\nEND_VAR\n iCount := iCount + INT#1;\nptiVar1 := ADR(iVar);\nptiVar1^ := iCondition; \/\/ OK - valid reference\nptiVar2^ := iCondition; \/\/ SA0039 - null pointer dereferenciation\niVar := ptiVar3^; \/\/ SA0039 - null pointer dereferenciation Ausgabe unter Ansicht Meldungen : SA0039: Mögliche Null-Pointer-Dereferenzierung 'ptiVar2^' SA0039: Mögliche Null-Pointer-Dereferenzierung 'ptiVar3^' " }, 
{ "title" : "SA0046: Möglicherweise nicht initialisierte Schnittstelle verwendet ", 
"url" : "_san_rule_sa0046.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Möglicherweise nicht initialisierte Variablen verwendet \/ SA0046: Möglicherweise nicht initialisierte Schnittstelle verwendet ", 
"snippet" : "Ermittelt die Verwendung von Schnittstellen, die vor der Verwendung nicht initialisiert wurden. Begründung: Eine Interface-Referenz sollte vor ihrer Verwendung auf <> 0 geprüft werden, weil es sonst beim Zugriff zu einer Access Violation kommen kann. Wichtigkeit: Hoch Beispiel \/\/Declaration of INTER...", 
"body" : "Ermittelt die Verwendung von Schnittstellen, die vor der Verwendung nicht initialisiert wurden. Begründung: Eine Interface-Referenz sollte vor ihrer Verwendung auf <> 0 geprüft werden, weil es sonst beim Zugriff zu einer Access Violation kommen kann. Wichtigkeit: Hoch Beispiel \/\/Declaration of INTERFACE ITF and assigned METH2:\nMETHOD METH2 : BOOL\nVAR_INPUT\n iInput2:INT;\nEND_VAR \/\/Declaration of INTERFACE Master_ITF1 and assigned METH:\nMETHOD METH : BOOL\nVAR_INPUT\n iInput:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n instPOU : POU;\n instITF : ITF;\n instMasterITF1 : Master_ITF1;\n instMasterITF2 : Master_ITF2;\n iDummy : INT;\n xDummy : BOOL;\n instNoInitITF : ITF;\n instNoInitITF2 : ITF;\n instNoInitMasterITF1 : Master_ITF1;\n instNoInitMasterITF2 : Master_ITF2;\nEND_VAR instITF := instPOU;\nxDummy := instITF.METH(iInput := iDummy); \/\/ OK\ninstMasterITF1 := instPOU;\nxDummy := instMasterITF1.METH(iInput := iDummy); \/\/ OK\n\nxDummy := instNoInitITF.METH(iInput := INT#1); \/\/ SA0046\nxDummy := instNoInitITF.METH2(iInput2 := INT#2); \/\/ SA0046\nxDummy := instNoInitMasterITF1.METH(iInput := INT#3); \/\/ SA0046\niDummy := instNoInitMasterITF2.Prop; \/\/ SA0046\n\nIF instNoInitITF <> 0 THEN\n instNoInitITF.Prop; \/\/ OK, because the interface can't be 0\nEND_IF Ausgabe unter Ansicht Meldungen : SA0046: Möglicherweise Verwendung von nicht initialisierter Schnittstelle 'instNoInitITF' SA0046: Möglicherweise Verwendung von nicht initialisierter Schnittstelle 'instNoInitITF' SA0046: Möglicherweise Verwendung von nicht initialisierter Schnittstelle 'instNoInitMasterITF1' SA0046: Möglicherweise Verwendung von nicht initialisierter Schnittstelle 'instNoInitMasterITF2' " }, 
{ "title" : "SA0145: Mögliche Verwendung einer nicht initialisierten Referenz ", 
"url" : "_san_rule_sa0145.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ Möglicherweise nicht initialisierte Variablen verwendet \/ SA0145: Mögliche Verwendung einer nicht initialisierten Referenz ", 
"snippet" : "Ermittelt alle verwendeten Referenzvariablen, die möglicherweise vor der Verwendung nicht initialisiert und nicht durch den Operator __ISVALIDREF überprüft werden. Diese Regel wird im Implementierungsteil von POUs angewendet. Für die Deklaration gibt es die Regel SA0124 . Begründung: Eine Referenz s...", 
"body" : "Ermittelt alle verwendeten Referenzvariablen, die möglicherweise vor der Verwendung nicht initialisiert und nicht durch den Operator __ISVALIDREF überprüft werden. Diese Regel wird im Implementierungsteil von POUs angewendet. Für die Deklaration gibt es die Regel SA0124 . Begründung: Eine Referenz sollte vor dem Zugriff auf Gültigkeit geprüft werden, weil es sonst beim Zugriff zu einer Zugriffsverletzung kommen kann. Wichtigkeit: Hoch Beispiel PROGRAM PLC_PRG\nVAR_INPUT\n ref_iTest : REFERENCE TO INT;\nEND_VAR\n ref_iTest := 99; \/\/ SA0145\nIF __ISVALIDREF(ref_iTest) THEN\n ref_iTest := 88;\nEND_IF Ausgabe unter Ansicht Meldungen : SA0145: Möglicherweise Verwendung einer nicht initialisierten Referenz 'ref_iTest' " }, 
{ "title" : "SA0150: Verletzung von Unter- oder Obergrenzen der Metriken ", 
"url" : "_san_rule_sa0150.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0150: Verletzung von Unter- oder Obergrenzen der Metriken ", 
"snippet" : "Ermittelt die Bausteine, die die aktivierten Metriken an der Unter- oder Obergrenzen verletzen. Begründung: Code, der bestimmte Metriken einhält, ist leichter lesbar, leichter wartbar und leichter testbar. Wichtigkeit: Hoch PLCopen-Regel: CP9 Beispiel Ausgangssituation: Die Metrik Anzahl Aufrufe ist...", 
"body" : "Ermittelt die Bausteine, die die aktivierten Metriken an der Unter- oder Obergrenzen verletzen. Begründung: Code, der bestimmte Metriken einhält, ist leichter lesbar, leichter wartbar und leichter testbar. Wichtigkeit: Hoch PLCopen-Regel: CP9 Beispiel Ausgangssituation: Die Metrik Anzahl Aufrufe ist im Dialog Projekteinstellungen → Statische Codeanalyse → Metriken aktiviert. Untergrenze: 0 , Obergrenze: 3 . Baustein Prog_1 wird jedoch 5x aufgerufen. Beim Ausführen der statischen Analyse wird der Fehler SA0150: Metrische Verletzung für Prog_1. Ergebnis für Metrik Aufrufe (5) > 2 im Meldungsfenster in Kategorie Übersetzen ausgegeben. " }, 
{ "title" : "SA0160: Rekursive Aufrufe ", 
"url" : "_san_rule_sa0160.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0160: Rekursive Aufrufe ", 
"snippet" : "Ermittelt rekursive Aufrufe in Aktionen, Methoden und Eigenschaften von Funktionsbausteinen. Ermittelt auch mögliche Rekursionen durch virtuelle Funktionsaufrufe und Schnittstellenaufrufe. Begründung: Rekursionen führen zu nicht-deterministischem Verhalten und sind daher eine Fehlerquelle. Wichtigke...", 
"body" : "Ermittelt rekursive Aufrufe in Aktionen, Methoden und Eigenschaften von Funktionsbausteinen. Ermittelt auch mögliche Rekursionen durch virtuelle Funktionsaufrufe und Schnittstellenaufrufe. Begründung: Rekursionen führen zu nicht-deterministischem Verhalten und sind daher eine Fehlerquelle. Wichtigkeit: Mittel PLCopen-Regel: CP13 Beispiel Dem Funktionsbaustein FB_Test ist folgende Methode Call zugewiesen: FUNCTION_BLOCK FB_Test\nVAR\n bParameter: BOOL;\nEND_VAR\n METHOD Call : BOOL\nVAR_INPUT\nEND_VAR\n Call := THIS^.Call(); \/\/SA0160 Das Programm PLC_PRG ruft FB_Test auf: PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\n bValue : BOOL;\nEND_VAR\n bValue := fbTest.bParameter;\nfbTest.Call(); Ausgabe unter Ansicht Meldungen : SA0160: Rekursiver Aufruf gefunden: 'PLC_PRG' -> 'FB_Test.Call' -> 'FB_Test.Call' " }, 
{ "title" : "SA0161: Ungepackte Struktur in gepackter Struktur ", 
"url" : "_san_rule_sa0161.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0161: Ungepackte Struktur in gepackter Struktur ", 
"snippet" : "Ermittelt ungepackte Strukturen, die in gepackten Strukturen verwendet werden. Begründung: Eine ungepackte Struktur legt der Compiler normalerweise auf eine Adresse, die einen alignten Zugriff auf alle Elemente innerhalb der Struktur erlaubt. Wenn Sie diese Struktur in einer gepackten Struktur anleg...", 
"body" : "Ermittelt ungepackte Strukturen, die in gepackten Strukturen verwendet werden. Begründung: Eine ungepackte Struktur legt der Compiler normalerweise auf eine Adresse, die einen alignten Zugriff auf alle Elemente innerhalb der Struktur erlaubt. Wenn Sie diese Struktur in einer gepackten Struktur anlegen, dann ist ein alignter Zugriff nicht mehr möglich, und ein Zugriff auf ein Element in der ungepackten Struktur kann zu einer „Misalignment Exception“ führen. Wichtigkeit: Hoch Beispiel Die Struktur structSingleDataRecord ist gepackt, enthält jedoch die ungepackte Strukturen struct4Byte und struct9Byte . {attribute 'pack_mode' := '1'}\nTYPE structSingleDataRecord :\nSTRUCT\n str9ByteData: struct9Byte; (* 9 BYTE *)\n str4ByteData: struct4Byte; (* 4 BYTE *)\n udi1: UDINT;\n udi2: UDINT;\n udi3: UDINT;\n usi4: USINT;\nEND_STRUCT\nEND_TYPE (* 9 BYTE *)\nTYPE struct9Byte :\nSTRUCT\n usiRotorSlots: USINT; (* 1 BYTE *)\n uiMaxCurrent: UINT; (* 2 BYTE *)\n usiVelocity: USINT; (* 1 BYTE *)\n uiAcceleration: UINT; (* 2 BYTE *)\n uiDeceleration: UINT; (* 2 BYTE *)\n usiDirectionChange: USINT; (* 1 BYTE *)\nEND_STRUCT\nEND_TYPE TYPE struct4Byte :\nSTRUCT\n \/\/udiDummy : UDINT;\n rRealDummy : REAL;\nEND_STRUCT\nEND_TYPE Ausgabe unter Ansicht Meldungen : SA0161: Deklaration einer nicht gepackten Struktur 'struct9ByteData' innerhalb einer gepackten Struktur 'structSingleDataRecord' SA0161: Deklaration einer nicht gepackten Struktur 'struct4ByteData' innerhalb einer gepackten Struktur 'structSingleDataRecord' " }, 
{ "title" : "SA0162: Fehlende Kommentare ", 
"url" : "_san_rule_sa0162.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0162: Fehlende Kommentare ", 
"snippet" : "Ermittelt nicht kommentierte Stellen im Programm. Begründung: Eine vollständige Kommentierung wird von vielen Programmierrichtlinien gefordert und erhöht die Lesbarkeit und Wartbarkeit des Codes. Wichtigkeit: Niedrig PLCopen-Regel: C2 Kommentare sind erforderlich bei der Deklaration von Variablen. D...", 
"body" : "Ermittelt nicht kommentierte Stellen im Programm. Begründung: Eine vollständige Kommentierung wird von vielen Programmierrichtlinien gefordert und erhöht die Lesbarkeit und Wartbarkeit des Codes. Wichtigkeit: Niedrig PLCopen-Regel: C2 Kommentare sind erforderlich bei der Deklaration von Variablen. Die Kommentare stehen darüber oder rechts davon. der Deklaration von Programmen, Funktionsbausteinen oder Methoden. Die Kommentar stehen über der Deklaration ( in der ersten Zeile). Beispiel PROGRAM PLC_PRG\nVAR\n iMaxValue: INT;\nEND_VAR\n Ausgabe unter Ansicht Meldungen : SA0162: Kommentar für 'PLC_PRG' fehlt SA0162: Kommentar für 'iMaxValue' fehlt " }, 
{ "title" : "SA0163: Verschachtelte Kommentare ", 
"url" : "_san_rule_sa0163.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0163: Verschachtelte Kommentare ", 
"snippet" : "Ermittelt verschachtelte Kommentare. Begründung: Verschachtelte Kommentare sind schwer zu lesen und sollten deswegen vermieden werden. Wichtigkeit: Niedrig PLCopen-Regel: C3 Beispiel {attribute 'do-analysis'} (* That is (* nested comment 1 *) *) PROGRAM PLC_PRG VAR (* That is \/\/ nested comment 2 com...", 
"body" : "Ermittelt verschachtelte Kommentare. Begründung: Verschachtelte Kommentare sind schwer zu lesen und sollten deswegen vermieden werden. Wichtigkeit: Niedrig PLCopen-Regel: C3 Beispiel {attribute 'do-analysis'}\n(* That is\n(* nested comment 1 *)\n*)\nPROGRAM PLC_PRG\nVAR\n(* That is\n\/\/ nested comment 2\ncomment *)\n iVal1: INT;\n iVal2: INT;\n\n(* That is\n(* nested comment 3 *) *)\n pVal3: POINTER TO DWORD;\n hugo: INT;\nEND_VAR\n (* That is\n\/\/ nested comment 4\ncomment *)\niVal1 := iVal1 + 1;\n(* That is\n(* nested comment 5 *)\n*)\n\n(* Not that one *) Ausgabe unter Ansicht Meldungen : SA0163: Verschachtelter Kommentar 'nested comment 1' SA0163: Verschachtelter Kommentar 'nested comment 2' SA0163: Verschachtelter Kommentar 'nested comment 3' SA0163: Verschachtelter Kommentar 'nested comment 4' SA0163: Verschachtelter Kommentar 'nested comment 5' " }, 
{ "title" : "SA0164: Mehrzeilige Kommentare ", 
"url" : "_san_rule_sa0164.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0164: Mehrzeilige Kommentare ", 
"snippet" : "Ermittelt mehrzeilige Kommentare, die mit (* comment *) codiert sind. Erlaubt sind nur einzeilige Kommentare, die mit \/\/ comment codiert sind. Begründung: Einige Programmierrichtlinien verbieten mehrzeilige Kommentare im Code, weil Anfang und Ende eines Kommentars aus dem Blickfeld geraten könnten u...", 
"body" : "Ermittelt mehrzeilige Kommentare, die mit (* comment *) codiert sind. Erlaubt sind nur einzeilige Kommentare, die mit \/\/ comment codiert sind. Begründung: Einige Programmierrichtlinien verbieten mehrzeilige Kommentare im Code, weil Anfang und Ende eines Kommentars aus dem Blickfeld geraten könnten und die schließende Kommentarklammer durch einen Fehler gelöscht werden könnte. Sie können diese Prüfung mit dem Pragma analysis deaktivieren, auch für Kommentare im Deklarationsteil. Wichtigkeit: Niedrig PLCopen-Regel: C5 Beispiel {attribute 'do-analysis'}\n(*\n This is a multi-line comment \/\/ SA0164\n*)\nPROGRAM PLC_PRG\nVAR\n\/\/ This is a single line comment\n a: DINT;\nEND_VAR\n (* This is not a single line comment *) \/\/ SA0164\na := a + 1; Ausgabe unter Ansicht Meldungen : SA0164: Nur einzeilige Kommentare verwenden " }, 
{ "title" : "SA0165: Tasks, die andere POUs aufrufen als Programme ", 
"url" : "_san_rule_sa0165.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0165: Tasks, die andere POUs aufrufen als Programme ", 
"snippet" : "Die Prüfung ermittelt Tasks, die Funktionsbausteine oder Funktionen aufrufen statt eines Programms. Begründung: Diese Regel ist Teil der PLCopen Coding Guidelines und die Einhaltung wird deswegen auch in CODESYS geprüft. Wir sehen in CODESYS zwar keine Probleme bezüglich der Datenkonsistenz, wenn Ta...", 
"body" : "Die Prüfung ermittelt Tasks, die Funktionsbausteine oder Funktionen aufrufen statt eines Programms. Begründung: Diese Regel ist Teil der PLCopen Coding Guidelines und die Einhaltung wird deswegen auch in CODESYS geprüft. Wir sehen in CODESYS zwar keine Probleme bezüglich der Datenkonsistenz, wenn Tasks andere POUs aufrufen würden als Programme. Es kann aber zu Problemen kommen, wenn der Code auf andere Plattformen portiert werden soll. Wichtigkeit: Niedrig PLCopen-Regel: CP16 Unter der Taskkonfiguration sind Tasks eingefügt. In den Tasks ist konfiguriert, welche POUs aufgerufen werden. Die POUs müssen vom Typ Programm sein. Der Typ Funktionsbaustein oder Funktion ist nicht erlaubt. Beispiel " }, 
{ "title" : "SA0166: Maximale Anzahl an Eingabe-\/Ausgabe-\/VAR_IN_OUT-Variablen ", 
"url" : "_san_rule_sa0166.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0166: Maximale Anzahl an Eingabe-\/Ausgabe-\/VAR_IN_OUT-Variablen ", 
"snippet" : "Die Prüfung ermittelt, ob eine definierte Anzahl an Eingabevariablen ( VAR_INPUT ), Ausgabevariablen ( VAR_OUTPUT ) oder VAR_IN_OUT -Variablen in einem Baustein überschritten wird. Die maximale Anzahl definieren Sie in einem Dialog, der in den Projekteinstellungen bei einem Doppelklick auf die Zeile...", 
"body" : "Die Prüfung ermittelt, ob eine definierte Anzahl an Eingabevariablen ( VAR_INPUT ), Ausgabevariablen ( VAR_OUTPUT ) oder VAR_IN_OUT -Variablen in einem Baustein überschritten wird. Die maximale Anzahl definieren Sie in einem Dialog, der in den Projekteinstellungen bei einem Doppelklick auf die Zeile mit der Regel erscheint. Begründung: Es geht um die Überprüfung von individuellen Programmierrichtlinien. Viele Programmierrichtlinien sehen für Bausteine eine maximale Anzahl an Parametern vor. Zu viele Parameter machen den Code unleserlich und die Bausteine schwer testbar. Wichtigkeit: Mittel PLCopen-Regel: CP23 Beispiel Sie haben in den Projekteinstellungen bei Regel 166 für VAR_IN_OUT -Variablen eine maximale Anzahl von 1 definiert. FUNCTION_BLOCK FB1\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nVAR_IN_OUT\n xInOut1 : BOOL;\n xInOut2 : BOOL;\nEND_VAR\n Ausgabe unter Ansicht Meldungen : SA0166: Zu viele VAR_IN_OUT Variablen in POU 'FB1' " }, 
{ "title" : "SA0167: Temporäre Funktionsbausteininstanzen ", 
"url" : "_san_rule_sa0167.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0167: Temporäre Funktionsbausteininstanzen ", 
"snippet" : "Die Prüfung ermittelt Funktionsbaustein-Instanzen, die als temporäre Variablen deklariert sind. Dies betrifft Instanzen, die in einer Methode oder in einer Funktion oder als VAR_TEMP deklariert sind, und die deshalb in jedem Abarbeitungszyklus oder bei jedem Bausteinaufruf neu initialisiert werden. ...", 
"body" : "Die Prüfung ermittelt Funktionsbaustein-Instanzen, die als temporäre Variablen deklariert sind. Dies betrifft Instanzen, die in einer Methode oder in einer Funktion oder als VAR_TEMP deklariert sind, und die deshalb in jedem Abarbeitungszyklus oder bei jedem Bausteinaufruf neu initialisiert werden. Begründung: Funktionsbausteine haben einen Zustand, der meist über mehrere SPS-Zyklen hinweg erhalten bleibt. Eine Instanz auf dem Stack existiert nur für die Dauer des Funktionsaufrufs. Es ist daher nur selten sinnvoll, eine Instanz als temporäre Variable anzulegen. Zweitens sind Funktionsbaustein-Instanzen häufig groß und verbrauchen sehr viel Platz auf dem Stack (der auf Steuerungen meist begrenzt ist). Drittens kann die Initialisierung und häufig auch die Terminierung eines Funktionsbausteins ziemlich viel Zeit in Anspruch nehmen. Wichtigkeit: Mittel Beispiel PROGRAM PLC_PRG\nVAR\nEND_VAR\nVAR_TEMP\n yafb: AFB;\nEND_VAR FUNCTION Fun : INT\nVAR_INPUT\nEND_VAR\nVAR\n funafb: AFB;\nEND_VAR\n METHOD METH : INT\nVAR_INPUT\nEND_VAR\nVAR\n methafb: AFB; \/\/ SA0167\nEND_VAR Ausgabe unter Ansicht Meldungen : SA0167: Temporäre Funktionsbausteininstanz: 'methafb' " }, 
{ "title" : "SA0168: Unnötige Zuweisungen ", 
"url" : "_san_rule_sa0168.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0168: Unnötige Zuweisungen ", 
"snippet" : "Ermittelt Zuweisungen auf Variablen, die keine Auswirkungen im Code haben. Begründung: Wenn einer Variablen mehrfach Werte zugewiesen werden, ohne dass die Variable zwischen den Zuweisungen ausgewertet wird, wirken sich die ersten Zuweisungen nicht auf das Programm aus. Wichtigkeit: Niedrig Beispiel...", 
"body" : "Ermittelt Zuweisungen auf Variablen, die keine Auswirkungen im Code haben. Begründung: Wenn einer Variablen mehrfach Werte zugewiesen werden, ohne dass die Variable zwischen den Zuweisungen ausgewertet wird, wirken sich die ersten Zuweisungen nicht auf das Programm aus. Wichtigkeit: Niedrig Beispiel PROGRAM PLC_PRG\nVAR\n dwVal1 : DWORD;\n dwVal2 : DWORD;\nEND_VAR\n \/\/ unnecessary assignment\ndwVal1 := 1; \nIF dwVal2 > 100 THEN\n dwVal2 := 0;\n dwVal2 := dwVal2 + 1;\nEND_IF\ndwVal1 := 2; Ausgabe unter Ansicht Meldungen : SA0168: Die Variable 'dwVal1' ist zugewiesen, aber ihr Wert wird nie verwendet. " }, 
{ "title" : "SA0169: Ignorierte Ausgänge ", 
"url" : "_san_rule_sa0169.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0169: Ignorierte Ausgänge ", 
"snippet" : "Ermittelt die Ausgänge von Methoden und Funktionen, die beim Aufruf der Methode oder Funktion nicht angegeben werden. Begründung: Ignorierte Ausgänge können ein Hinweis auf nicht behandelte Fehler oder sinnlose Funktionsaufrufe sein, da Ergebnisse nicht verwendet werden. Wichtigkeit: Mittel Beispiel...", 
"body" : "Ermittelt die Ausgänge von Methoden und Funktionen, die beim Aufruf der Methode oder Funktion nicht angegeben werden. Begründung: Ignorierte Ausgänge können ein Hinweis auf nicht behandelte Fehler oder sinnlose Funktionsaufrufe sein, da Ergebnisse nicht verwendet werden. Wichtigkeit: Mittel Beispiel FUNCTION Fun1\nVAR_INPUT\n bIn : BOOL;\nVAR_END\nVAR_OUTPUT\n bOut : BOOL;\nEND_VA\n ; PROGRAM PLC_PRG\nVAR\n bValue :BOOl;\nEND_VAR\n Fun1(bIn : TRUE);\n Ausgabe unter Ansicht Meldungen : SA0169: Der Ausgang 'bOut' wird beim Aufruf ingnoriert " }, 
{ "title" : "SA0170: Adresse einer Ausgabevariablen sollte nicht verwendet werden ", 
"url" : "_san_rule_sa0170.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0170: Adresse einer Ausgabevariablen sollte nicht verwendet werden ", 
"snippet" : "Ermittelt Codestellen, in denen die Adresse einer Ausgabevariablen ( VAR_OUTPUT , VAR_IN_OUT ) eines Funktionsbausteins verwendet wird. Begründung; Es ist nicht erlaubt, in folgender Weise die Adresse eines Funktionsbausteinausgangs zu verwenden: via ADR -Operator via REF= Ausnahme: Kein Fehler wird...", 
"body" : "Ermittelt Codestellen, in denen die Adresse einer Ausgabevariablen ( VAR_OUTPUT , VAR_IN_OUT ) eines Funktionsbausteins verwendet wird. Begründung; Es ist nicht erlaubt, in folgender Weise die Adresse eines Funktionsbausteinausgangs zu verwenden: via ADR -Operator via REF= Ausnahme: Kein Fehler wird gemeldet, wenn die Ausgabevariable innerhalb desselben Funktionsbausteins verwendet wird. Wichtigkeit: Mittel Beispiel Funktionsbaustein FB1 hat die VAR_OUTPUT -Variable iOutVal : INT; Folgende Zugriffe in einem anderen Baustein erzeugen den Fehler SA0170: \/\/FB1_inst is of type FB1\naddr1 := ADR(FB1_inst.iOutVal); \/\/SA0170\nrefINT REF= FB1_inst.iOutVal; \/\/SA0179\n Folgender Zugriff direkt innerhalb des Funktionsbausteins FB1 erzeugt ebenfalls den Fehler: \/\/other is a POINTER TO FB1\nptr := ADR(other^.iOutVal); \/\/SA0170 Folgende Zugriffe direkt innerhalb des Funktionsbausteins FB1 erzeugen keine Fehler: \/\/iInputVal is a VAR_INPUT of FB1\niOutVal := iInputVal; \n\/\/ptr is a POINTER TO INT\nptr := ADR(THIS^.iOutVal); \nptr := ADR(iOutVal); Ausgabe unter Ansicht Meldungen : SA0170: Sollte nicht die Adresse einer Ausgabevariablen annehmen " }, 
{ "title" : "SA0171: Enumerationen sollten das Attribut 'strict' haben ", 
"url" : "_san_rule_sa0171.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0171: Enumerationen sollten das Attribut 'strict' haben ", 
"snippet" : "Ermittelt Deklarationen von Enumerationen, die nicht mit dem Attribut {attribute 'strict'} versehen sind. Begründung: Das Attribut {attribute 'strict'} bewirkt, dass Compilerfehler ausgegeben werden, wenn der Code gegen strikte Programmierregeln für Enumerationen verstößt. Standardmäßig wird beim An...", 
"body" : "Ermittelt Deklarationen von Enumerationen, die nicht mit dem Attribut {attribute 'strict'} versehen sind. Begründung: Das Attribut {attribute 'strict'} bewirkt, dass Compilerfehler ausgegeben werden, wenn der Code gegen strikte Programmierregeln für Enumerationen verstößt. Standardmäßig wird beim Anlegen einer neuen Enumeration die Deklaration automatisch mit dem Attribut 'strict' versehen. Für weitere Informationen siehe: Datentyp Enumeration Wichtigkeit: Hoch Beispiel TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE Ausgabe unter Ansicht Meldungen : SA0171: Enumerationen sollten das Attibut 'strict' haben Kein Verstoß gegen Programmierregeln: {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE " }, 
{ "title" : "SA0172: Möglicher Versuch eines Zugriffs außerhalb der Arraygrenzen ", 
"url" : "_san_rule_sa0172.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0172: Möglicher Versuch eines Zugriffs außerhalb der Arraygrenzen ", 
"snippet" : "Ermittelt mögliche Zugriffe auf einen Arrayindex außerhalb der Arraygrenzen. Häufig wird der Bereich des Arrayindex in FOR -Schleifen überschritten, bei denen die Indexvariable für den Zugriff auf einen Arrayindex verwendet wird. Wichtigkeit: Hoch Beispiel PROGRAM Test VAR_TEMP iIndex: INT; arUSINT:...", 
"body" : "Ermittelt mögliche Zugriffe auf einen Arrayindex außerhalb der Arraygrenzen. Häufig wird der Bereich des Arrayindex in FOR -Schleifen überschritten, bei denen die Indexvariable für den Zugriff auf einen Arrayindex verwendet wird. Wichtigkeit: Hoch Beispiel PROGRAM Test\nVAR_TEMP\n iIndex: INT;\n arUSINT: Array[0..10] OF INT;\nEND_VAR\n FOR iIndex := INT#0 TO INT#50 DO\n arUSINT[iIndex] := 0;\nEND_FOR Ausgabe unter Ansicht Meldungen : SA0172: Möglicher Versuch eines Zugriffs außerhalb der Arraygrenzen " }, 
{ "title" : "SA0175: Verdächtige Operation auf Zeichenkette ", 
"url" : "_san_rule_sa0175.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0175: Verdächtige Operation auf Zeichenkette ", 
"snippet" : "Aktivieren Sie diese Regel nicht ständig. Aktivieren Sie die Regel nur bei Bedarf, um die Stellen im Code zu finden, die bei einer Umstellung auf UTF-8 Kodierung geprüft werden sollten. Prüft, ob die Projektoption UTF-8-Kodierung für Zeichenketten aktiviert werden kann. Das ist dann der Fall, wenn k...", 
"body" : "Aktivieren Sie diese Regel nicht ständig. Aktivieren Sie die Regel nur bei Bedarf, um die Stellen im Code zu finden, die bei einer Umstellung auf UTF-8 Kodierung geprüft werden sollten. Prüft, ob die Projektoption UTF-8-Kodierung für Zeichenketten aktiviert werden kann. Das ist dann der Fall, wenn keine Codestellen mit verdächtigen Operationen gefunden werden. Bei der Umstellung auf UTF-8-Kodierung entsprechen die ersten 127 Zeichen der ASCII-Kodierung. Alle anderen Zeichen werden jedoch mit mehr als einem Byte kodiert. Dadurch kann es bei der Verarbeitung von Zeichenketten zu einer Änderung im Verhalten kommen. So kann ein String-Literal, das Nicht-ASCII-Zeichen enthält, länger werden. Oder aber Zugriffe in einen String über Index können auf das falsche Element zugreifen. Schlussendlich können sogar Zugriffe sogar auf einen ungültigen Byte-Offset passieren. Wenn die Regel aktiv ist, werden alle Codestellen, die eines der folgenden Konstrukte enthält, gemeldet: Indexzugriff auf Ein-Byte-Strings Beispiel: str[2] Meldung: SA0175: Enumeration mit Attribut 'strict'Verdächtige Operation an Zeichenkette: Indexzugriff '<Ausdruck>' Adresszugriff auf Single-Byte-Strings Beispiel: ADR(str) Meldung: SA0175:Enumeration mit Attribut 'strict'Verdächtige Operation an Zeichenkette: Möglicher Indexzugriff '<Ausdruck>' Aufruf von Stringfunktionen der Bibliothek Standard , außer bei Aufruf der Funktionen CONCAT und LEN Meldung: SA0175:Enumeration mit Attribut 'strict'Verdächtige Operation auf String: Möglicher Indexzugriff '<Ausdruck>' Byte-Literal, das Nicht-ASCII-Zeichen enthält Beispiele: str := '99€';\nstr :='Ä'; Meldung: SA0175: Verdächtige Operation an Zeichenkette: Literal '<Literal>' enthält Nicht-ASCII-Zeichen " }, 
{ "title" : "SA0180: Indexbereich deckt nicht das gesamte Array ab ", 
"url" : "_san_rule_sa0180.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Regeln \/ SA0180: Indexbereich deckt nicht das gesamte Array ab ", 
"snippet" : "Ermittelt Arrays mit nicht vollständig abgedecktem Indexbereich Arrays werden oftmals in Schleifen behandelt, wobei der Schleifenindex das Array so indiziert, dass alle Komponenten des Arrays lückenlos angesprungen werden. Das ist dann gegeben, wenn der Schleifenindex und der Arrayindex in allen Dim...", 
"body" : "Ermittelt Arrays mit nicht vollständig abgedecktem Indexbereich Arrays werden oftmals in Schleifen behandelt, wobei der Schleifenindex das Array so indiziert, dass alle Komponenten des Arrays lückenlos angesprungen werden. Das ist dann gegeben, wenn der Schleifenindex und der Arrayindex in allen Dimensionen gleich sind. Wenn der Indexbereich das Array nicht vollständig abdeckt, weist das auf nicht behandelte Komponenten im Array hin. Wichtigkeit: Mittel Beispiel {attribute 'do-analysis'}\nPROGRAM PLC_PRG\nVAR\n a : INT;\n arWord : ARRAY [0..100] OF WORD;\nEND_VAR\n\/\/Implementation\nFOR a := INT#1 TO INT#100 BY 1 DO \/\/SA0180: Lower range is not reached\n\tarWord[a] := INT_TO_WORD(a);\nEND_FOR;\n;\n Ausgabe unter Ansicht Meldungen : SA0180: Indexbereich deckt nicht das gesamte Array ab " }, 
{ "title" : "Metriken ", 
"url" : "_san_reference_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken ", 
"snippet" : "Detaillierte Beschreibung der von CODESYS Static Analysis bereitgestellten Metriken Die Metriken Codegröße , Variablengröße , Stackgröße und Anzahl Aufrufe werden nur für Bausteine aus Bibliotheken ausgegeben, die im Projekt eingebunden sind....", 
"body" : "Detaillierte Beschreibung der von CODESYS Static Analysis bereitgestellten Metriken Die Metriken Codegröße , Variablengröße , Stackgröße und Anzahl Aufrufe werden nur für Bausteine aus Bibliotheken ausgegeben, die im Projekt eingebunden sind. " }, 
{ "title" : "Metrik: Codegröße (Anzahl Bytes) ", 
"url" : "_san_reference_metrics.html#UUID-35adc4d5-9253-44d6-f130-aab7171bff69", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Codegröße (Anzahl Bytes) ", 
"snippet" : "Codegröße (Anzahl Bytes) Kategorie: Informativ, Effizienz Anzahl Bytes, die ein Baustein zum Applikationscode beiträgt Die Anzahl hängt auch vom Codegenerator ab. Beispielsweise erzeugt der Codegenerator für ARM-Prozessoren im Allgemeinen mehr Bytes als der Codegenerator für x86-Prozessoren....", 
"body" : "Codegröße (Anzahl Bytes) Kategorie: Informativ, Effizienz Anzahl Bytes, die ein Baustein zum Applikationscode beiträgt Die Anzahl hängt auch vom Codegenerator ab. Beispielsweise erzeugt der Codegenerator für ARM-Prozessoren im Allgemeinen mehr Bytes als der Codegenerator für x86-Prozessoren. " }, 
{ "title" : "Metrik: Variablengröße (Anzahl Bytes) ", 
"url" : "_san_reference_metrics.html#UUID-b07882e2-be28-fe1e-eb10-ed5defcf3c74", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Variablengröße (Anzahl Bytes) ", 
"snippet" : "Variablengröße (Anzahl Bytes) Kategorien : Informativ, Effizienz Größe des statischen Speichers, der von dem Objekt verwendet wird Bei Funktionsbausteinen ist dies die Größe, die für eine Instanz dieses Funktionsbausteins verwendet wird (und die je nach Speicher-Alignment auch Speicherlücken enthalt...", 
"body" : "Variablengröße (Anzahl Bytes) Kategorien : Informativ, Effizienz Größe des statischen Speichers, der von dem Objekt verwendet wird Bei Funktionsbausteinen ist dies die Größe, die für eine Instanz dieses Funktionsbausteins verwendet wird (und die je nach Speicher-Alignment auch Speicherlücken enthalten kann). Bei Programmen, Funktionen und globalen Variablenlisten ist dies die Summe der Größe aller statischen Variablen. Beispiel FUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR Die Funktion hat 3 statische Variablen vom Typ INT ( f , g und h ), die jeweils 2 Byte Speicherplatz benötigen. FUN1 hat folglich eine Variablengröße von 6 Byte. " }, 
{ "title" : "Metrik: Stackgröße (Anzahl Bytes) ", 
"url" : "_san_reference_metrics.html#UUID-52e032c0-e190-f5c0-344b-e6c04694a3ef", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Stackgröße (Anzahl Bytes) ", 
"snippet" : "Stackgröße (Anzahl Bytes) Kategorien : Informativ, Effizienz, Verlässlichkeit Anzahl der Bytes, die für den Aufruf einer Funktion oder eines Funktionsbausteins benötigt werden Eingangsvariablen und Ausgangsvariablen werden am Speicher ausgerichtet. Dadurch kann eine Lücke zwischen diesen Variablen u...", 
"body" : "Stackgröße (Anzahl Bytes) Kategorien : Informativ, Effizienz, Verlässlichkeit Anzahl der Bytes, die für den Aufruf einer Funktion oder eines Funktionsbausteins benötigt werden Eingangsvariablen und Ausgangsvariablen werden am Speicher ausgerichtet. Dadurch kann eine Lücke zwischen diesen Variablen und den lokalen Variablen entstehen. Diese Lücke wird mitgezählt. Rückgabewerte von aufgerufenen Funktionen, die nicht in ein Register passen, werden auf den Stack geschoben. Der größte dieser Werte bestimmt den zusätzlich zugewiesenen Speicher, der ebenfalls mit zählt. Funktionen oder Funktionsbausteine, die innerhalb der betrachteten POUs aufgerufen werden, haben ihren eigenen Stack-Frame. Deshalb zählt der Speicher für solche Aufrufe nicht mit. Je nach verwendetem Codegenerator verwenden auch Zwischenergebnisse von Berechnungen den Stapel. Diese Ergebnisse werden nicht gezählt. Beispiel \/\/Declaration\nFUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d,e : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR\n\n\/\/Implementation\nc := b;\nd := a;\ne := a+b; Annahme: Für die Berechnung wird eine CODESYS Control Win angenommen, die den x86-Codegenerator verwendet. Das obige Beispiel hat eine Caller-Größe von 8 Bytes: 4 Byte für die beiden INT -Eingänge und 4 Byte für den Rückgabewert. Das Gerät hat ein Stack-Alignment von 4 Bytes, so dass eine Lücke von 2 Bytes entsteht. Die Caller-Größe beträgt 8 Bytes: 3 lokale Variablen mit je 2 Byte plus die 2 Byte Lücke für das Stack-Alignment. Die gesamte Stack-Größe von FUN1 beträgt somit 16 Bytes. VAR_STAT wird nicht auf dem Stack gespeichert und erhöht daher nicht die Stack-Größe einer POU. " }, 
{ "title" : "Metrik: Anzahl Aufrufe (Aufrufe) ", 
"url" : "_san_reference_metrics.html#UUID-652fc3dc-10b7-711b-cea7-9b006e6249b5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Anzahl Aufrufe (Aufrufe) ", 
"snippet" : "Anzahl Aufrufe (Aufrufe) Kategorie : Informativ Anzahl der Anrufe des Programmierbausteins (POU) unter Programmiereinheit Beispiel \/\/Declaration PLC_PRG PROGRAM PLC_PRG VAR myFB : FB1; END_VAR \/\/Implementation myFB(b := FALSE); \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR_INPUT b : BOOL; END_VAR VAR i :...", 
"body" : "Anzahl Aufrufe (Aufrufe) Kategorie : Informativ Anzahl der Anrufe des Programmierbausteins (POU) unter Programmiereinheit Beispiel \/\/Declaration PLC_PRG\nPROGRAM PLC_PRG\nVAR\n myFB : FB1;\nEND_VAR\n\n\/\/Implementation\nmyFB(b := FALSE); \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR_INPUT\n b : BOOL;\nEND_VAR\nVAR\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH(i);\nIF b THEN\n METH(i*i);\nEND_IF\n \/\/Declaration FB1.METH\nMETHOD METH : BOOL\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := i >= 42; Falls PLC_PRG in einer Task aufgerufen wird, wird dieser Aufruf auch mitgezählt. FB1 hat genau einen Aufruf (in PLC_PRG ). METH hat zwei Aufrufe, beide in FB1 . " }, 
{ "title" : "Metrik: Anzahl Aufrufe aus Tasks (Tasks) ", 
"url" : "_san_reference_metrics.html#UUID-3768e9b9-fdef-e8c5-d81a-3ab94c3eed82", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Anzahl Aufrufe aus Tasks (Tasks) ", 
"snippet" : "Anzahl Aufrufe aus Tasks (Tasks) Kategorien : Wartbarkeit, Verlässlichkeit Anzahl der Tasks ( Tasks ), in der die unter Programmeinheit angegebene POU aufgerufen wird Bei Funktionsbausteinen wird die Anzahl der Tasks gezählt, in denen der Funktionsbaustein selbst oder ein beliebiger Funktionsbaustei...", 
"body" : "Anzahl Aufrufe aus Tasks (Tasks) Kategorien : Wartbarkeit, Verlässlichkeit Anzahl der Tasks ( Tasks ), in der die unter Programmeinheit angegebene POU aufgerufen wird Bei Funktionsbausteinen wird die Anzahl der Tasks gezählt, in denen der Funktionsbaustein selbst oder ein beliebiger Funktionsbaustein im Vererbungsbaum des Funktionsbausteins aufgerufen wird. Bei Methoden und Aktionen wird die Anzahl der Tasks angezeigt, in denen der (übergeordneten) Funktionsbaustein aufgerufen wird. Beispiel FUNCTION_BLOCK FB\n\/\/... FUNCTION_BLOCK FB2 EXTENDS FB\n\/\/... FUNCTION_BLOCK FB3 EXTENDS FB2\n\/\/... Jeder Funktionsbaustein wird in einem eigenen PROGRAM aufgerufen. Jedes PROGRAM hat seine eigene Task. Die Metrik Aufgerufen aus Tasks ergibt für FB3 1 und für FB2 2, denn die Aufrufe von FB3 und FB2 werden gezählt. Die Metrik ergibt für FB 3, denn in diesem Fall werden die Aufrufe von FB3 , FB2 und FB gezählt. " }, 
{ "title" : "Metrik: Anzahl verwendeter globaler Variablen (Globale) ", 
"url" : "_san_reference_metrics.html#UUID-04068c53-4046-0979-468b-866b1a155a8a", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Anzahl verwendeter globaler Variablen (Globale) ", 
"snippet" : "Anzahl verwendeter globaler Variablen (Globale) Kategorien : Wartbarkeit, Wiederverwendbarkeit Anzahl der verwendeten globalen Variable in der POU unter Programmeinheit Beispiel \/\/GVL VAR_GLOBAL gvla : INT; gvlb : INT; gvlc : INT; END_VAR \/PRG declaration PROGRAM PRG VAR x : INT := GVL.gvlc; y : INT...", 
"body" : "Anzahl verwendeter globaler Variablen (Globale) Kategorien : Wartbarkeit, Wiederverwendbarkeit Anzahl der verwendeten globalen Variable in der POU unter Programmeinheit Beispiel \/\/GVL\nVAR_GLOBAL\n gvla : INT;\n gvlb : INT;\n gvlc : INT;\nEND_VAR \/PRG declaration\nPROGRAM PRG\nVAR\n x : INT := GVL.gvlc;\n y : INT;\nEND_VAR\n\n\/\/PRG implementation\nx := GVL.gvla;\ny := GVL.gvla*GVL.gvlb; Das Programm PRG verwendet 3 Variablen aus GVL : gvla , gvlb und gvlc . " }, 
{ "title" : "Metrik: Anzahl direkter Adresszugriffe (EAs) ", 
"url" : "_san_reference_metrics.html#UUID-792a6162-1022-f930-dadb-104aa5a51709", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Anzahl direkter Adresszugriffe (EAs) ", 
"snippet" : "Anzahl direkter Adresszugriffe (EAs) Kategorien : Wiederverwendbarkeit, Wartbarkeit Anzahl der direkten Adresszugriffe ( EAs ) in der Implementierung des Objekts. Beispiel \/\/Declaration PROGRAM PRG VAR xVar : BOOL:= %IX0.0; \/\/ +1 direct address access byVar : BYTE; END_VAR \/\/Implementation xVar := %...", 
"body" : "Anzahl direkter Adresszugriffe (EAs) Kategorien : Wiederverwendbarkeit, Wartbarkeit Anzahl der direkten Adresszugriffe ( EAs ) in der Implementierung des Objekts. Beispiel \/\/Declaration\nPROGRAM PRG\nVAR\n xVar : BOOL:= %IX0.0; \/\/ +1 direct address access\n byVar : BYTE;\nEND_VAR\n\n\/\/Implementation\nxVar := %IX0.0; \/\/ +1 direct address access\n%QX0.0 := xVar; \/\/ +1\n%MX0.1 := xVar; \/\/ +1\n%MB1 := byVar; \/\/ +1 Das Beispiel hat 5 direkte Adresszugriffe. " }, 
{ "title" : "Metrik: Anzahl lokaler Variablen (Lokale) ", 
"url" : "_san_reference_metrics.html#UUID-f738f257-cf3a-1e7c-979e-1d6b4733c2d9", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Anzahl lokaler Variablen (Lokale) ", 
"snippet" : "Anzahl lokaler Variablen (Lokale) Kategorien : Informativ, Effizienz Anzahl Variablen, die im VAR -Bereich der POU deklariert sind. Geerbte Variablen werden nicht gezählt. Beispiel \/\/Declaration FUNCTION_BLOCK FB VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR i,j,k,l : INT; m,n,o : BOOL; END_VAR Im Funkti...", 
"body" : "Anzahl lokaler Variablen (Lokale) Kategorien : Informativ, Effizienz Anzahl Variablen, die im VAR -Bereich der POU deklariert sind. Geerbte Variablen werden nicht gezählt. Beispiel \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,j,k,l : INT;\n m,n,o : BOOL;\nEND_VAR\n Im Funktionsbaustein sind 7 lokale Variablen deklariert. " }, 
{ "title" : "Metrik: Anzahl Eingabevariablen (Eingänge) ", 
"url" : "_san_reference_metrics.html#UUID-03e01655-9ac0-74f4-3fd7-cf22f23db4f6", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Anzahl Eingabevariablen (Eingänge) ", 
"snippet" : "Anzahl Eingabevariablen (Eingänge) Kategorien : Wartbarkeit, Wiederverwendbarkeit Standardobergrenze für die zugehörige Regel SA0166 : 10 Anzahl an Variablen, die in VAR_INPUT der Programmeinheit deklariert sind. Geerbte Eingangsvariablen werden nicht gezählt. Beispiele FUNCTION_BLOCK FB VAR_INPUT i...", 
"body" : "Anzahl Eingabevariablen (Eingänge) Kategorien : Wartbarkeit, Wiederverwendbarkeit Standardobergrenze für die zugehörige Regel SA0166 : 10 Anzahl an Variablen, die in VAR_INPUT der Programmeinheit deklariert sind. Geerbte Eingangsvariablen werden nicht gezählt. Beispiele FUNCTION_BLOCK FB\nVAR_INPUT\n i : INT;\n r : REAL;\nEND_VAR\n Im Funktionsbaustein sind 2 Eingabevariablen deklariert: i und r . METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR\n Die Methode hat 2 Eingänge: j und l " }, 
{ "title" : "Metrik: Anzahl Ausgabevariablen (Ausgänge) ", 
"url" : "_san_reference_metrics.html#UUID-7bba3bc6-748c-311d-7f8c-4878fdce9da0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Anzahl Ausgabevariablen (Ausgänge) ", 
"snippet" : "Anzahl Ausgabevariablen (Ausgänge) Kategorien : Wartbarkeit, Wiederverwendbarkeit Standardobergrenze für die zugehörige Regel SA0166 : 10 Anzahl an Variablen in VAR_OUTPUT der Programmeinheit Bei Funktionsbausteinen ist dies die Anzahl der benutzerdefinierten Ausgangsvariablen ( VAR_OUTPUT ). Bei Me...", 
"body" : "Anzahl Ausgabevariablen (Ausgänge) Kategorien : Wartbarkeit, Wiederverwendbarkeit Standardobergrenze für die zugehörige Regel SA0166 : 10 Anzahl an Variablen in VAR_OUTPUT der Programmeinheit Bei Funktionsbausteinen ist dies die Anzahl der benutzerdefinierten Ausgangsvariablen ( VAR_OUTPUT ). Bei Methoden und Funktionen ist dies die Anzahl der benutzerdefinierten Ausgangsvariablen plus eins, wenn sie einen Rückgabewert haben. der Rückgabewert wird mit gezählt. Geerbte Ausgangsvariablen werden nicht gezählt. Eine hohe Anzahl an Ausgabevariablen ist ein Zeichen für die Verletzung des Prinzips der eindeutigen Verantwortlichkeit. Beispiele FUNCTION_BLOCK FB\nVAR_OUTPUT\n i : INT; \/\/ +1 output\n r : REAL; \/\/ +1 output\nEND_VAR Der Funktionsbaustein hat 2 Ausgabevariablen: i und r METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR Die Methode hat 3 Ausgänge: METH , j , l METHOD METH1 \/\/ +0 outputs (no return type)\nVAR_OUTPUT\n ar : ARRAY[0..10] OF INT; \/\/ +1 output\n l : LREAL; \/\/ +1 output\nEND_VAR Die Methode METH1 hat 2 Ausgänge: ar und i " }, 
{ "title" : "Metrik: NOS - Anzahl Anweisungen ", 
"url" : "_san_reference_metrics.html#UUID-82054fe5-816d-0c12-0afa-11dabf2c47b3", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: NOS - Anzahl Anweisungen ", 
"snippet" : "NOS - Anzahl Anweisungen Kategorie : Informativ Anzahl der Anweisungen in der Implementierung eines Funktionsbausteines, einer Funktion oder einer Methode Anweisungen in der Deklaration, leere Anweisungen oder Pragmas werden nicht gezählt. Beispiel \/\/Declaration: FUNCTION POU : BOOL VAR_INPUT END_VA...", 
"body" : "NOS - Anzahl Anweisungen Kategorie : Informativ Anzahl der Anweisungen in der Implementierung eines Funktionsbausteines, einer Funktion oder einer Methode Anweisungen in der Deklaration, leere Anweisungen oder Pragmas werden nicht gezählt. Beispiel \/\/Declaration:\nFUNCTION POU : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n c : INT := 100; \/\/ statements in the declaration are not counted\nEND_VAR\nVAR_OUTPUT\n test : INT;\n i : INT;\nEND_VAR\n\n\/\/Implementation:\nIF TRUE THEN \/\/if statement: +1\n test := 0; \/\/ +1\nEND_IF\n\nWHILE test = 1 DO \/\/while statement: +1\n ; \/\/ empty statements do not add to the statement count\nEND_WHILE\n\nFOR c := 0 TO 10 BY 2 DO \/\/for statement: +1\n i := i+i; \/\/ +1\nEND_FOR\n\n{text 'simple text pragma'} \/\/pragmas are not counted\ntest := 2; \/\/+1 Das Beispiel hat 6 Anweisungen. " }, 
{ "title" : "Metrik: Prozentsatz Kommentare (Kommentare) ", 
"url" : "_san_reference_metrics.html#UUID-abd88d31-c33e-db93-0f69-bec1a38795f7", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Prozentsatz Kommentare (Kommentare) ", 
"snippet" : "Prozentsatz Kommentare (Kommentare) Kategorie : Wartbarkeit Prozentualer Anteil Kommentare im Quellcode Diese Zahl wird nach der folgenden Formel berechnet: Prozentsatz = 100 * <Buchstaben in Kommentaren> \/ <Buchstaben in Quellcode und Kommentaren zusammen> Mehrere aufeinander folgende Leerzeichen i...", 
"body" : "Prozentsatz Kommentare (Kommentare) Kategorie : Wartbarkeit Prozentualer Anteil Kommentare im Quellcode Diese Zahl wird nach der folgenden Formel berechnet: Prozentsatz = 100 * <Buchstaben in Kommentaren> \/ <Buchstaben in Quellcode und Kommentaren zusammen> Mehrere aufeinander folgende Leerzeichen im Quellcode werden als ein Leerzeichen gezählt, was eine hohe Gewichtung von eingerücktem Quellcode verhindert. Für leere Objekte (kein Quellcode und keine Kommentare) wird ein Prozentsatz von 0 zurückgegeben. Beispiel Deklarationsteil: FUNCTION_BLOCK FB \/\/comments in the declaration are counted, as well\nVAR_TEMP\n hugo : INT;\nEND_VAR Implementierung: hugo := hugo + 1;\n\/\/Declaration: 40 letters non comment; 50 letters comment\n\/\/Implementation: 13 letters non comment; 152 letters comment\n\/\/ 100 * 202 \/ 255 -> 79% comments Die Berechnung des Prozentsatzes 100 * 202 \/ 255 ergibt 79 %. " }, 
{ "title" : "Metrik: Komplexität (McCabe) ", 
"url" : "_san_reference_metrics.html#UUID-ea21160c-97be-30d4-7748-0adac68532a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Komplexität (McCabe) ", 
"snippet" : "Komplexität (McCabe) Kategorie : Testbarkeit Empfohlene Obergrenze: 10 Die zyklomatische Komplexität nach McCabe ist ein Maß für die Lesbarkeit und Testbarkeit von Quellcode. Sie wird durch Zählen der Anzahl der binären Verzweigungen im Kontrollfluss der POU berechnet. Die zyklomatische Komplexität ...", 
"body" : "Komplexität (McCabe) Kategorie : Testbarkeit Empfohlene Obergrenze: 10 Die zyklomatische Komplexität nach McCabe ist ein Maß für die Lesbarkeit und Testbarkeit von Quellcode. Sie wird durch Zählen der Anzahl der binären Verzweigungen im Kontrollfluss der POU berechnet. Die zyklomatische Komplexität bestraft jedoch eine hohe Verzweigung, da eine hohe Verzweigung die Anzahl der für eine hohe Testabdeckung benötigten Testfälle erhöht. Beispiel: IF -Anweisung \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nIF b1 THEN \/\/ +1 for the THEN branch\n ;\n ELSIF b2 THEN \/\/ +1 for the THEN branch of the IF inside the else\n ;\nELSE \n IF b3 OR b4 THEN \/\/ +1 for the THEN branch\n ;\n END_IF\nEND_IF Das Codeschnipsel hat eine zyklomatische Komplexität von 4. Beispiel: CASE -Anweisung \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nCASE a OF\n 1:\t; \/\/ +1\n 2:\t; \/\/ +1\n 3,4,5:\t; \/\/ +1\nELSE \/\/ the ELSE statement does not increase the cyclomatic complexity\n ;\nEND_CASE Das Codeschnipsel hat eine zyklomatische Komplexität von 4. Beispiel: Schleifenanweisung \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nWHILE b1 DO \/\/ +1 for the WHILE loop\n ;\nEND_WHILE\n\nREPEAT \/\/ +1 for the REPEAT loop\n ;\n UNTIL b2\nEND_REPEAT\n\nFOR a := 0 TO 100 BY 2 DO \/\/ +1 for the REPEAT loop\n ;\nEND_FOR Das Codeschnipsel hat eine zyklomatische Komplexität von 4. Beispiel: Andere Anweisungen Auch die folgenden Anweisungen führen zu einer Erhöhung der zyklomatischen Komplexität: \/\/Declaration\nFUNCTION FUN : STRING\nVAR_INPUT\n condition_return : BOOL;\n condition_jmp : BOOL;\nEND_VAR\nVAR\nEND_VAR\n\n\/\/Implementation\n\/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nJMP(condition_jmp) lbl; \/\/Conditional jumps increase the cyclomatic complexity by 1\n\nFUN := 'u';\nRETURN(condition_return); \/\/Conditional returns increase the cyclomatic complexity by 1, too\n\nlbl:\nFUN := 't';\n Das Codeschnipsel hat eine zyklomatische Komplexität von 3. " }, 
{ "title" : "Metrik: Kognitive Komplexität ", 
"url" : "_san_reference_metrics.html#UUID-cd064f18-bd35-1d86-1bd4-2ae3a8fe344f", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Kognitive Komplexität ", 
"snippet" : "Kognitive Komplexität Kategorie : Wartbarkeit Standardobergrenze für die zugehörige Regel SA0178: 20 Die kognitive Komplexität ist ein Maß für die Lesbarkeit und Verständlichkeit von Quellcode, das von Sonarsource™ im Jahr 2016 eingeführt wurde. Sie bestraft jedoch eine starke Verschachtelung des Ko...", 
"body" : "Kognitive Komplexität Kategorie : Wartbarkeit Standardobergrenze für die zugehörige Regel SA0178: 20 Die kognitive Komplexität ist ein Maß für die Lesbarkeit und Verständlichkeit von Quellcode, das von Sonarsource™ im Jahr 2016 eingeführt wurde. Sie bestraft jedoch eine starke Verschachtelung des Kontrollflusses und komplexe boolesche Ausdrücke. Die kognitive Komplexität wird nur für strukturierte Textimplementierungen berechnet. Die folgenden Beispiele zeigen, wie die kognitive Komplexität berechnet wird. Mit dem Befehl Kognitive Komplexität für aktuellen Editor anzeigen können zusätzlich die Inkremente für strukturierten Text angezeigt werden. Beispiel: Kontrollfluss Anweisungen, die den Kontrollfluss manipulieren, erhöhen die kognitive Komplexität um 1 IF TRUE THEN \/\/ +1 cognitive complexity\n ;\nEND_IF\n\nWHILE TRUE DO \/\/+1 cognitive complexity\n ;\nEND_WHILE\n\nFOR i := 0 TO 10 BY 1 DO \/\/+1 cognitive complexity\n ;\nEND_FOR\n\nREPEAT \/\/+1 cognitive complexity\n ;\nUNTIL TRUE\nEND_REPEAT Das Codeschnipsel hat ein kognitive Komplexität von 4. Beispiel: Verschachtelung des Kontrollflusses Bei der Verschachtelung des Kontrollflusses wird für jede Stufe der Verschachtelung ein Inkrement von 1 hinzugefügt. IF TRUE THEN \/\/+1 cognitive complexity\n WHILE TRUE DO \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n FOR i := 0 TO 10 BY 1 DO \/\/+3 (+1 for the FOR loop itself, +2 for the nesting inside the WHILE and the IF)\n\t\t\t;\n END_FOR\n END_WHILE\n\n REPEAT \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n ;\n UNTIL TRUE\n END_REPEAT\nEND_IF Das Codeschnipsel hat ein kognitve Komplexität von 8. Beispiel: Boolescher Ausdruck Da boolesche Ausdrücke eine große Rolle beim Verständnis von Quellcode spielen, werden sie auch bei der Berechnung der kognitiven Komplexität berücksichtigt. Das Verständnis von booleschen Ausdrücken, die mit demselben booleschen Operator verbunden sind, ist nicht so schwierig wie das Verständnis eines booleschen Ausdrucks, der alternierende boolesche Operatoren enthält. Daher erhöht jede Kette von gleichen booleschen Operatoren in einem Ausdruck die kognitive Komplexität. b := b1; \/\/+0: a simple expression, containing no operators, has no increment\n Der einfache Ausdruck ohne Operator hat ein Inkrement von 0. b := b1 AND b2; \/\/+1: one chain of AND operators Der Ausdruck mit einer AND -Verknüpfung hat ein Inkrement von 1. b := b1 AND b2 AND b3; \/\/+1: one more AND, but the number of chains of operators does not change Der Ausdruck hat ein AND mehr. Aber da es der gleiche Operator ist, ändert sich die Anzahl der mit identischen Operatoren gebildeten Kette nicht. b := b1 AND b2 OR b3; \/\/+2: one chain of AND operators and one chain of OR operators Der Ausdruck hat eine Kette von AND -Operatoren und eine Kette von OR -Operatoren. Das ergibt ein Inkrement von 2. b := b1 AND b2 OR b3 AND b4 AND b5; \/\/+3 Das Codeschnipsel hat ein Inkrement von 3. b := b1 AND NOT b2 AND b3; \/\/+1: the unary NOT operator is not considered in the cognitive complexity Der unäre Operator NOT wird bei der kognitiven Komplexität nicht berücksichtigt. Beispiel: Weitere Anweisungen mit Inkrement Strukturierter Text hat zusätzliche Anweisungen und Ausdrücke, die den Kontrollfluss verändern. Die folgenden Anweisungen werden mit einem Inkrement der kognitiven Komplexität bestraft: aNewLabel:\nx := MUX(i, a,b,c); \/\/+1 for MUX operator\ny := SEL(b, i,j); \/\/+1 for SEL operator\nJMP aNewLabel; \/\/+1 for JMP to label EXIT - und RETURN -Anweisungen erhöhen nicht die kognitive Komplexität. " }, 
{ "title" : "Metrik: DIT - Tiefe des Vererbungsbaums ", 
"url" : "_san_reference_metrics.html#UUID-c7e1c296-e321-f999-8ed7-9713ebdb50fc", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: DIT - Tiefe des Vererbungsbaums ", 
"snippet" : "DIT - Tiefe des Vererbungsbaums Kategorie : Wartbarkeit Anzahl der Vererbungen, bis ein Funktionsbaustein erreicht ist, der keinen anderen Funktionsbaustein erweitert Beispiel FUNCTION_BLOCK MyBaseFB \/\/ ... FUNCTION_BLOCK AChildFB EXTENDS MyBaseFB \/\/ ... FUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB...", 
"body" : "DIT - Tiefe des Vererbungsbaums Kategorie : Wartbarkeit Anzahl der Vererbungen, bis ein Funktionsbaustein erreicht ist, der keinen anderen Funktionsbaustein erweitert Beispiel FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB hat einen DIT von 0, da er selbst ein Funktionsbaustein ist, der keinen anderen Funktionsblock erweitert. Für AChildFB ist der DIT 1, da ein Schritt erforderlich ist, um zu MyBaseFB zu gelangen. AGrandChildFB hat einen DIT von 2: Ein Schritt wird zu AChildFB und ein weiterer zu MyBaseFB benötigt. " }, 
{ "title" : "Metrik: NOC - Anzahl Kindobjekte ", 
"url" : "_san_reference_metrics.html#UUID-04314eaf-28e7-40ea-0aa9-e7f46e79bfa0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: NOC - Anzahl Kindobjekte ", 
"snippet" : "NOC - Anzahl Kindobjekte Kategorien : Wiederverwendbarkeit, Wartbarkeit Anzahl der Funktionsbausteine, die den gegebenen Basisfunktionsbaustein erweitern. Dabei werden Funktionsbausteine, die einen Basisfunktionsbaustein indirekt erweitern, nicht mitgezählt. Beispiel FUNCTION_BLOCK MyBaseFB \/\/ ... F...", 
"body" : "NOC - Anzahl Kindobjekte Kategorien : Wiederverwendbarkeit, Wartbarkeit Anzahl der Funktionsbausteine, die den gegebenen Basisfunktionsbaustein erweitern. Dabei werden Funktionsbausteine, die einen Basisfunktionsbaustein indirekt erweitern, nicht mitgezählt. Beispiel FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB hat nur ein (1) Kindobjekt: AChildFB , das wiederum das eine Kindobjekt AGrandChildFB hat. AGrandChildFB hat keine Kindobjekte. " }, 
{ "title" : "Metrik: RFC - Antwort auf Klasse ", 
"url" : "_san_reference_metrics.html#UUID-0fcfc138-e361-a392-6fbe-11240e7a6e2a", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: RFC - Antwort auf Klasse ", 
"snippet" : "RFC - Antwort auf Klasse (RFC) Kategorien : Wartbarkeit, Wiederverwendbarkeit Anzahl unterschiedlicher POUs, Methoden oder Aktionen, die aufgerufen werden und dadurch eine Antwort der unter Programmeinheit angegebene POU erzeugen Beispiel \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR d,x,y : INT; END_VAR...", 
"body" : "RFC - Antwort auf Klasse (RFC) Kategorien : Wartbarkeit, Wiederverwendbarkeit Anzahl unterschiedlicher POUs, Methoden oder Aktionen, die aufgerufen werden und dadurch eine Antwort der unter Programmeinheit angegebene POU erzeugen Beispiel \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR\n d,x,y : INT;\nEND_VAR\n\n\/\/Implementation\nx := METH(d+10);\ny := FUN(42, 0.815); \/\/Declaration FB1.METH\nMETHOD METH : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := FUN(CUBE(i), 3.1415); \/\/Declaration CUBE\nFUNCTION CUBE : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nCUBE := i*i*i; \/\/Declaration Function FUN\nFUNCTION FUN : INT\nVAR_INPUT\n a : INT;\n lr : LREAL;\nEND_VAR\n\n\/\/Implementation\nFUN := LREAL_TO_INT(lr*10)*a; Beginnend mit FUN und CUBE haben diese Funktionen einen RFC von 0, denn keine der beiden Funktionen rufen andere Funktionen, Funktionsbausteine oder Methoden für ihre Berechnungen auf. FB1.METH verwendet FUN und CUBE , was einen RFC von 2 ergibt. Der Funktionsbaustein FB1 selbst ruft METH und FUN auf, was seinen RFC um 2 erhöht. Bei FB1 muss auch seine Methode METH berücksichtigt werden. METH verwendet FUN und CUBE. FUN ist bereits zum RFC hinzugefügt. Somit erhöht nur die Verwendung von CUBE in METH den RFC für FB1 auf 3 " }, 
{ "title" : "Metrik: CBO - Kopplung zwischen Objekten ", 
"url" : "_san_reference_metrics.html#UUID-d98bd2a3-497b-920f-1f11-f4f38973066f", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: CBO - Kopplung zwischen Objekten ", 
"snippet" : "CBO - Kopplung zwischen Objekten Kategorien : Wartbarkeit, Wiederverwendbarkeit Standardobergrenze für die zugehörige Regel SA0179: 30 Anzahl weiterer Funktionsbausteine, die in einem Funktionsbausteine instanziiert und verwendet werden Ein Funktionsbausteine mit einer hohen Kopplung zwischen Objekt...", 
"body" : "CBO - Kopplung zwischen Objekten Kategorien : Wartbarkeit, Wiederverwendbarkeit Standardobergrenze für die zugehörige Regel SA0179: 30 Anzahl weiterer Funktionsbausteine, die in einem Funktionsbausteine instanziiert und verwendet werden Ein Funktionsbausteine mit einer hohen Kopplung zwischen Objekten ist wahrscheinlich an vielen verschiedenen Aufgaben beteiligt und verstößt daher gegen das Prinzip der eindeutigen Verantwortlichkeit. Beispiel \/\/ Declaration\nFUNCTION_BLOCK FB_Child EXTENDS FB_Base objects \/\/ +0 for EXTENDS\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i_fb1 : FB1; \/\/ +1 instantiated here\n i_fb2 : FB2; \/\/ +1 instantiated here\nEND_VAR\n\n\/\/Implementation\ni_fb3(); \/\/ +0 instantiated in FB_Base, no increment for call Die Erweiterung eines Funktionsbausteine erhöht nicht die Kopplung zwischen Objekten. i_fb3 wird in der Implementierung von FB_Base instanziiert und an FB_Child vererbt ( EXTENDS ). Der Aufruf in FB_Child erhöht nicht die Kopplung zwischen den Objekten. Der CBO von FB_Child ist 2. " }, 
{ "title" : "Metrik: Referenzierungskomplexität (Elshof) ", 
"url" : "_san_reference_metrics.html#UUID-a43f74c1-523d-b649-00e5-788c653e5ea1", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Referenzierungskomplexität (Elshof) ", 
"snippet" : "Referenzierungskomplexität (Elshof) Kategorien : Effizienz, Wartbarkeit, Wiederverwendbarkeit Komplexität des Datenflusses einer POU Die Referenzierungskomplexität wird nach der folgenden Formel berechnet: <Anzahl verwendeter Variablen> \/ <Anzahl Variablenzugriffe> Es werden nur Variablenzugriffe im...", 
"body" : "Referenzierungskomplexität (Elshof) Kategorien : Effizienz, Wartbarkeit, Wiederverwendbarkeit Komplexität des Datenflusses einer POU Die Referenzierungskomplexität wird nach der folgenden Formel berechnet: <Anzahl verwendeter Variablen> \/ <Anzahl Variablenzugriffe> Es werden nur Variablenzugriffe im Implementierungsteil der POU berücksichtigt. Beispiel \/\/Declaration\nPROGRAM PRG\nVAR\n i, j : INT;\n k : INT := GVL.m;\n b, c : BOOL;\n myFB : FB;\nEND_VAR\n\n\/\/Implementation\nmyFB(paramA := b); \/\/ +3 accesses (myFB, paramA and b)\ni := j; \/\/ +2 accesses (i and j)\nj := GVL.d; \/\/ +2 accesses (j and GVL.d) Referenzierungskomplexität im Codeschnipsel ergibt: 6 Anzahl verwendete Variablen \/ 7 Anzahl Variablenzugriffe = 0.85 Achtung: c und k werden nicht verwendet und zählen daher nicht als \"verwendete Variablen\". Die Zuweisung k : INT := GVL.m wird nicht gezählt, da sie Teil der Deklaration des Programms ist. " }, 
{ "title" : "Metrik: LCOM - Mangelnder Zusammenhalt in Methoden ", 
"url" : "_san_reference_metrics.html#UUID-068c2765-4709-d4e2-80b6-d173998195a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: LCOM - Mangelnder Zusammenhalt in Methoden ", 
"snippet" : "LCOM - Mangelnder Zusammenhalt in Methoden Mangelnde Kohäsion der Methoden (LCOM) Kategorien : Wartbarkeit, Wiederverwendbarkeit Die Kohäsion zwischen Funktionsbausteinen, ihren Aktionen, Transitionen und Methoden beschreibt, ob sie auf die gleichen Variablen zugreifen. Der Mangel an Kohäsion von Me...", 
"body" : "LCOM - Mangelnder Zusammenhalt in Methoden Mangelnde Kohäsion der Methoden (LCOM) Kategorien : Wartbarkeit, Wiederverwendbarkeit Die Kohäsion zwischen Funktionsbausteinen, ihren Aktionen, Transitionen und Methoden beschreibt, ob sie auf die gleichen Variablen zugreifen. Der Mangel an Kohäsion von Methoden beschreibt, wie stark die Objekte eines Funktionsbausteins miteinander verbunden sind. Je geringer der Kohäsionsmangel, desto stärker ist die Verbindung zwischen den Objekten. Funktionsbausteine mit einem hohen Mangel an Kohäsion sind wahrscheinlich an vielen verschiedenen Aufgaben beteiligt und verletzen daher das Prinzip der eindeutigen Verantwortlichkeit. Die Metrik wird nach folgender Formel berechnet: MAX(0, <Anzahl Objektpaare ohne Kohäsion> - <Anzahl Objektpaare mit Kohäsion> ) Beispiel \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\n a : BOOL;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,b : BOOL;\nEND_VAR\n\n\/\/Implementation\ni := 42;\n\/\/FB.ACT\ni:= 0; \/\/FB.METH Declaration\nMETHOD METH : BOOL\nVAR_INPUT\n\tc : BOOL;\nEND_VAR\n\n\/\/Implementation\nMETH := c;\ni := 1; \/\/FB.SecondMETH Declaration\nMETHOD SecondMETH : INT\nVAR_INPUT\nEND_VAR\n\n\/\/Implementation\nSecondMETH := SEL(c,3,4); Objektpaare ohne Verbindung (4 Paare): FB, FB.ACT FB , FB.METH FB.ACT , FB.SecondMETH FB.METH , FB.SecondMETH Objektpaare mit Verbindung (2 Paare): FB , FB.SecondMETH (both use c ) FB.ACT , FB.METH (both use i ) Die Tabelle zeigt, welche Variablen welche Objekte des FB verbinden: FB FB.ACT FB.METH FB.SecondMETH FB.SecondMETH c 0 0 . FB.METH 0 i . . FB.ACT 0 . . . FB - . . . " }, 
{ "title" : "Metrik: Anzahl AS-Verzweigungen (AS-Verzweigungen) ", 
"url" : "_san_reference_metrics.html#UUID-d74f2703-e85d-ed16-b335-69a4dfd4a8bd", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Anzahl AS-Verzweigungen (AS-Verzweigungen) ", 
"snippet" : "Metrik: Anzahl AS-Verzweigungen (AS-Verzweigungen) Kategorien : Testbarkeit, Wartbarkeit Anzahl alternativer und paralleler Verzweigungen einer POU der Implementierungssprache AS (Ablaufsprache) Beispiel Das obige Codeschnipsel in AS hat 4 Verzweigungen: 3 alternative und 1 parallele Verzweigung...", 
"body" : "Metrik: Anzahl AS-Verzweigungen (AS-Verzweigungen) Kategorien : Testbarkeit, Wartbarkeit Anzahl alternativer und paralleler Verzweigungen einer POU der Implementierungssprache AS (Ablaufsprache) Beispiel Das obige Codeschnipsel in AS hat 4 Verzweigungen: 3 alternative und 1 parallele Verzweigung " }, 
{ "title" : "Metrik: Anzahl AS-Schritte (AS-Schritte) ", 
"url" : "_san_reference_metrics.html#UUID-19d1353f-ebce-6c25-6214-7b3a97c92490", 
"breadcrumbs" : "CODESYS Static Analysis \/ Referenz: Programmierung \/ Metriken \/ Metrik: Anzahl AS-Schritte (AS-Schritte) ", 
"snippet" : "Anzahl AS-Schritte (AS-Schritte) Kategorie : Wartbarkeit Anzahl der Schritte in einer POU in Ablaufsprache AS Es werden nur die Schritte gezählt, die in der in AS programmierten POU enthalten sind. Schritte in den Implementierungen von in POUs aufgerufenen Aktionen oder Transitionen werden nicht gez...", 
"body" : "Anzahl AS-Schritte (AS-Schritte) Kategorie : Wartbarkeit Anzahl der Schritte in einer POU in Ablaufsprache AS Es werden nur die Schritte gezählt, die in der in AS programmierten POU enthalten sind. Schritte in den Implementierungen von in POUs aufgerufenen Aktionen oder Transitionen werden nicht gezählt. Beispiel Das Codeschnipsel in AS hat 10 Schritte. " }
]
$(document).trigger('search.ready');
});