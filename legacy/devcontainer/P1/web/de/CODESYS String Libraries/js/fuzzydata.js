$(document).ready(function () {indexDict['de'] = [{ "title" : "CODESYS String Libraries ", 
"url" : "_strlib_start_page.html", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Einleitung ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4664735744121633736389596078", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Einleitung ", 
"snippet" : "Die Bibliotheken im Package CODESYS String Libraries k√∂nnen f√ºr die Verarbeitung von Zeichenketten, die UTF-8 kodiert sind, eingesetzt werden. Grundlage ist die Schnittstelle¬† IString aus der Bibliothek String Segments . Mithilfe dieser Schnittstelle k√∂nnen die Zeichenketten per Referenz an die jewe...", 
"body" : "Die Bibliotheken im Package CODESYS String Libraries k√∂nnen f√ºr die Verarbeitung von Zeichenketten, die UTF-8 kodiert sind, eingesetzt werden. Grundlage ist die Schnittstelle¬† IString aus der Bibliothek String Segments . Mithilfe dieser Schnittstelle k√∂nnen die Zeichenketten per Referenz an die jeweiligen Funktionen √ºbergeben werden. Zur Erstellung einer¬† IString -Instanz gibt es beispielsweise den Funktionsbaustein¬† GSB.UTF8String ¬†aus der Bibliothek Generic String Base . Folgende Bibliotheken werden mit dem Package ausgeliefert: String Segments Basisfunktionen f√ºr IString -Instanzen String Segments Library Documentation String Builder Effiziente Verwaltung von UTF-8 kodierten String-Segmenten String Builder Library Documentation String Conversions Umwandlung von Zeichenketten unterschiedlicher Kodierung von\/nach UTF-8 String Conversions Library Documentation String Functions Funktionen f√ºr die Verarbeitung von UTF-8 kodierten Zeichenketten nach dem Vorbild der herk√∂mmlichen Standardbibliothek String Functions Library Documentation Unicode Support Funktionen f√ºr die Verarbeitung von Unicoce-Zeichenkategorien Unicode Support Functions Library Documentation UTF-16 Encoding Support Basisfunktion f√ºr die Handhabung von UTF-16 kodierten Speicherbereichen UTF-16 Encoding Support Library Documentation UTF-8 Encoding Support Basisfunktion f√ºr die Handhabung von UTF-8 kodierten Speicherbereichen UTF-8 Encoding Support Functions Library Documentation Generic String Base Bausteine zur Verarbeitung von UTF-8-kodierten Zeichenketten, die ihren Speicherplatz statisch √ºber¬† GENERIC CONSTANT ¬†verwalten Generic String Base Functions Library Documentation " }, 
{ "title" : "Vorteile der neuen String-Bibliotheken ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4563869800648033733012917566", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Vorteile der neuen String-Bibliotheken ", 
"snippet" : "Die neuen String-Bibliotheken ersetzen¬†nicht¬†die altbekannten String-Funktionen der Bibliotheken Standard und Standard64 . Wir empfehlen dennoch, f√ºr neue Projekte die neuen String-Bibliotheken zu verwenden. Die neuen String-Bibliotheken k√∂nnen auch mit gro√üen Strings effizient umgehen. Die L√§nge de...", 
"body" : "Die neuen String-Bibliotheken ersetzen¬†nicht¬†die altbekannten String-Funktionen der Bibliotheken Standard und Standard64 . Wir empfehlen dennoch, f√ºr neue Projekte die neuen String-Bibliotheken zu verwenden. Die neuen String-Bibliotheken k√∂nnen auch mit gro√üen Strings effizient umgehen. Die L√§nge der Strings ist nahezu unbegrenzt. Aus diesem Grund sind die Bibliotheken auch f√ºr das Bearbeiten von gro√üen Textdateien und Web-Inhalten geeignet. Weitere Vorteile: UTF-8 ist eine Kodierung, die den vollst√§ndigen Zeichenumfang gem√§√ü UNICODE darstellen kann. UTF-8 hat im World Wide Web eine weite Verbreitung und wird vom World Wide Web Consortium (W3C) empfohlen. UTF-8 ist aufgrund der ASCII-Kompatiblit√§t kompatibel zu Altsystemen. UTF-8 bietet ein hohes Ma√ü an Interoperabilit√§t. UTF-8 arbeitet speicherplatzoptimierend. Durch die neuen String-Bibliotheken k√∂nnen Sie einen zuvor definierten String √ºber entsprechende Methoden abfragen, so wie Sie es von anderen Hochsprachen kennen. Beispiel String Methode: Len() udiStringLen := myString.Len();\nif¬†udiStringLen =¬†22¬†THEN\n... Seit CODESYS 3.5.18.0 k√∂nnen Sie den Compiler so einzustellen, dass der Inhalt von Variablen vom Typ¬† STRING ¬†als UTF-8-Kodierung interpretiert wird. Die Option UTF-8-Kodierung f√ºr STRING aktivieren Sie in den Projekteinstellungen in der Kategorie Compile-Optionen . Wenn Sie nicht alle¬† STRING -Variablen eines Projekts als UTF-8 kodiert behandeln wollen, m√ºssen Sie diese Option ausschalten. Danach k√∂nnen Sie einzelne Literale vom Typ STRING von Fall zu Fall mit einer UTF-8-Kodierung versehen. UTF-8-Kodierung f√ºr Literale {attribute¬†'monitoring_encoding'¬†:=¬†'UTF-8'}\nsValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë'; Durch die M√∂glichkeiten der UTF-8-Kodierung m√ºssen Sie in CODESYS nicht den Datentyp WSTRING verwenden, um einen erweiterten Zeichenvorrat zu nutzen. Die f√ºr¬† WSTRING ¬†zugrunde liegende UCS-2-Kodierung ben√∂tigt je nach Anwendung unter Umst√§nden mehr Speicherplatz als eine UTF-8-Kodierung. Die UCS-2-Kodierung verwendet pro Zeichen immer ein¬† WORD und kann nur die Zeichen U+0000 bis U+D800 und U+DFFF bis U+FFFD darstellen. Die UTF-8-Kodierung ben√∂tigt zwischen ein und vier Bytes pro Zeichen. Es k√∂nnen damit alle Unicode-Zeichen verarbeitet werden. Wenn Sie bei UTF-8-Kodierung versuchen, ein bestimmtes Zeichen √ºber einen bestimmten Index zu erreichen, f√ºhrt dies aufgrund der variablen L√§nge zu unerwarteten Ergebnissen. Kodierung variabler L√§nge {attribute 'monitoring_encoding' := 'UTF-8'}\nsValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë';\n\nbyValue := sValue[13];¬†\/\/ The 'u' is NOT the 13th character in the string\nxOk := byValue <>¬†16#75; Sie m√ºssen den¬†Index¬†eines Zeichens durch Iteration durch die Zeichenkette bestimmen. Iteration √ºber UTF-8-kodierte Zeichenketten VAR\t\n {attribute 'monitoring_encoding' := 'UTF-8'}\n sValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë';\n\n fbsValue : STR.UTF8Literal := (psValue:=ADR(sValue)); \n fbRange : STR.Range := (itfString:=fbsValue);\n diRune : STR.RUNE;\n udiIndex, udiLength : UDINT;\n xOk : BOOL;\nEND_VAR\n \nWHILE (diRune := fbRange.GetNextRune(udiLength=>udiLength)) <> 0 DO\n IF diRune = 16#75 (* 'u' *) THEN\n EXIT;\n END_IF\n udiIndex := udiIndex + udiLength;\nEND_WHILE\n \nxOk := sValue[udiIndex] = 16#75 (* 'u' *); " }, 
{ "title" : "Nachteile der etablierten STRING -Funktionen ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4613761597678433733013344138", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Nachteile der etablierten STRING -Funktionen ", 
"snippet" : "In den bisher etablierten STRING -Funktionen aus der Standardbibliothek werden die Parameter vom Typ¬† STRING ¬†bei der √úbergabe an die Funktionen kopiert. Der R√ºckgabewert wird mit der Zuweisung ebenfalls an eine Variable kopiert. Probleme mit den etablierte STRING-Funktionen VAR sValue : STRING; END...", 
"body" : "In den bisher etablierten STRING -Funktionen aus der Standardbibliothek werden die Parameter vom Typ¬† STRING ¬†bei der √úbergabe an die Funktionen kopiert. Der R√ºckgabewert wird mit der Zuweisung ebenfalls an eine Variable kopiert. Probleme mit den etablierte STRING-Funktionen VAR\n sValue : STRING;\nEND_VAR\n \nsValue := CONCAT(CONCAT(CONCAT('Da steh ich nun,', ' ich armer Tor!'), ' Und bin so'), ' klug als wie zu vor');\n\/\/ -> Copy, LEN -> Copy, LEN -> Copy, LEN -> Copy, LEN\n\/\/ -> 2xCopy, LEN\n\/\/ -> 2xCopy, LEN\n\/\/ -> 2xCopy, LEN Vor der Verarbeitung der Parameter vom Typ¬† STRING ¬†in den jeweiligen Funktionen muss oft deren L√§nge durch Iteration bis zum abschlie√üenden Null-Zeichen ermittelt werden. Bei l√§ngeren Zeichenketten verl√§ngern diese Kopier- und Iterationsvorg√§nge die Bearbeitungszeit der Applikation. Die L√§nge der Zeichenketten ist f√ºr die Anwendung dieser Funktionen auf eine L√§nge von 255 Zeichen begrenzt. " }, 
{ "title" : "Verwendung der Schnittstelle IString ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4598276788502433733013693363", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Verwendung der Schnittstelle IString ", 
"snippet" : "Die Schnittstelle¬† STR.IString ¬† wurde eingef√ºhrt, um die Datenstruktur, die die Informationen¬†√ºber einen¬†String¬†verwaltet, als Referenz weiterreichen zu k√∂nnen. Das ist ein gro√üer Unterschied zu den bisher etablierten STRING-Funktionen, welche die Schnittstelle¬† STR.IString nicht implementieren.¬† D...", 
"body" : "Die Schnittstelle¬† STR.IString ¬† wurde eingef√ºhrt, um die Datenstruktur, die die Informationen¬†√ºber einen¬†String¬†verwaltet, als Referenz weiterreichen zu k√∂nnen. Das ist ein gro√üer Unterschied zu den bisher etablierten STRING-Funktionen, welche die Schnittstelle¬† STR.IString nicht implementieren.¬† Des Weiteren darf sich¬†die Gr√∂√üe¬†eines Strings (der jeweilige Speicherplatz f√ºr die UTF-8-kodierten Zeichen) im Zahlenbereich¬† UDINT ¬†( 4 ‚â¶¬†udiSize¬†‚â¶ 16#FFFF_FF00 ) befinden. In der erw√§hnten Datenstruktur werden folgende Informationen aktuell gehalten und m√ºssen nicht vor einem Verarbeitungsschritt jedesmal neu berechnet werden: Verweis auf das jeweilige Speichersegment Aktuelle¬†Kapazit√§t¬†(‚Üí GetSegment ) L√§nge (‚Üí Len ) in Byte Anzahl der Zeichen (‚Üí RuneCount ) Eigenschaften von STR.IString VAR\n itfString : STR.IString;\n udiLength, udiSize, udiRuneCount : UDINT;\n pbySegment : POINTER TO BYTE;\n xValid : BOOL;\nEND_VAR\n \nudiLength := itfString.Len(); \/\/ Current length in byte\npbySegment := itfString.GetSegment(udiSize=>udiSize); \/\/ Address first byte, capacity of the segment in bytes\nudiRuneCount := STR.RuneCount(itfString); \/\/ Current number of \"characters\" in the segment\nxValid := itfString.IsValid(); \/\/ Indication that a valid UTF-8 encoding is present. Zusammenhang: \"Zeichen\" und \"Rune\" Der Begriff \"Rune\" kommt in den Bibliotheken und im Quellcode vor und bedeutet genau dasselbe wie \"Unicode-Codepunkt\", mit einem interessanten Zusatz. Die Bibliotheken definieren das Wort¬†\"Rune\"¬†als Alias f√ºr den Typ¬† DINT . Somit kann der Anwender klar erkennen, wann ein Integerwert einen Codepunkt darstellt. Au√üerdem wird das, was als Zeichenkonstante vorstellbar ist, als Runenkonstante bezeichnet. Beispiel: Der Typ und Wert des Ausdrucks WSTRING#\"‚åò\" ist eine Rune mit dem Integerwert DINT#16#2318 . " }, 
{ "title" : "Informationen f√ºr Experten ", 
"url" : "_strlib_expert_information.html", 
"breadcrumbs" : "CODESYS String Libraries \/ Informationen f√ºr Experten ", 
"snippet" : "In CODESYS -Versionen vor 3.5.18.0 haben Sie nicht¬†die M√∂glichkeit, UTF-8-kodierte Variablen vom Typ¬† STRING ¬†und die Bibliothek Generic String Base zu nutzen. Dies ist erst ab Version 3.5.19.50 m√∂glich. Die anderen Bibliotheken aus dem Package CODESYS String Libraries k√∂nnen Sie trotzdem verwenden....", 
"body" : "In CODESYS -Versionen vor 3.5.18.0 haben Sie nicht¬†die M√∂glichkeit, UTF-8-kodierte Variablen vom Typ¬† STRING ¬†und die Bibliothek Generic String Base zu nutzen. Dies ist erst ab Version 3.5.19.50 m√∂glich. Die anderen Bibliotheken aus dem Package CODESYS String Libraries k√∂nnen Sie trotzdem verwenden. Allerdings ist die Handhabung von UTF-8-kodierten Speicherbereichen (beispielsweise vom Typ¬† ARRAY OF BYTE ) dort etwas umst√§ndlicher. VOR SP18 VAR\n abyValue : ARRAY[0..33] OF BYTE := [ \/\/ UTF-8 C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl\n 16#43, 16#C3, 16#98, 16#44, 16#E2, 16#82, 16#AC, 16#C5, 16#A1, 16#C5, 16#B8,\n 16#C5, 16#A0, 16#20, 16#C3, 16#AF, 16#C3, 16#9F, 16#20, 16#76, 16#C3, 16#A4,\n 16#72, 16#C3, 16#BF, 16#20, 16#C3, 16#A7, 16#C3, 16#B4, 16#C3, 16#B5, 16#6C, 0\n ];\n myString : STR.UTF8Literal := (psValue:=ADR(abyValue));\nEND_VAR Sobald UTF8 kodierte Variablen vom Typ¬† STRING ¬†verf√ºgbar sind, vereinfacht sich das obige Beispiel weiter: VAR\n myString : STR.UTF8Literal := (psValue:=ADR(UTF8#'C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl'));\nEND_VAR " }, 
{ "title" : "Konvertierung von STRING zu IString ", 
"url" : "_strlib_expert_information.html#UUID-ab7f59ef-3fd1-9368-2073-8d15fffc313a_section-idm4670931916384033733014074571", 
"breadcrumbs" : "CODESYS String Libraries \/ Informationen f√ºr Experten \/ Konvertierung von STRING zu IString ", 
"snippet" : "Die Datenstruktur f√ºr die Verwaltung der Eigenschaften eines String-Segments wird √ºber den¬†Funktionsbaustein STR._UTF8String implementiert. Dazu m√ºssen Sie f√ºr eine Instanz dieses Bausteins und f√ºr das String-Segment selbst Speicher reservieren. Eine Bausteininstanz muss sich in einem Speicherbereic...", 
"body" : "Die Datenstruktur f√ºr die Verwaltung der Eigenschaften eines String-Segments wird √ºber den¬†Funktionsbaustein STR._UTF8String implementiert. Dazu m√ºssen Sie f√ºr eine Instanz dieses Bausteins und f√ºr das String-Segment selbst Speicher reservieren. Eine Bausteininstanz muss sich in einem Speicherbereich befinden, der auf einer¬† __XWORD -Adresse ausgerichtet ist. Konvertierung von String zu IString VAR CONSTANT\n c_udiLength : UDINT := MAX(4, 512); \/\/ String segment capacity including terminal NULL\n c_udiXWORD : UDINT := SIZEOF(__XWORD);\n¬† ¬†¬†c_udiMaxIndex : UDINT := (SIZEOF(STR._UTF8String) + c_udiLength +¬† c_udiXWORD¬† -¬†1) \/ c_udiXWORD;\nEND_VAR\n \nVAR\n abyValue : ARRAY[0..33] OF BYTE := [ \/\/ UTF-8 C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl\n 16#43, 16#C3, 16#98, 16#44, 16#E2, 16#82, 16#AC, 16#C5, 16#A1, 16#C5, 16#B8,\n 16#C5, 16#A0, 16#20, 16#C3, 16#AF, 16#C3, 16#9F, 16#20, 16#76, 16#C3, 16#A4,\n 16#72, 16#C3, 16#BF, 16#20, 16#C3, 16#A7, 16#C3, 16#B4, 16#C3, 16#B5, 16#6C, 0\n\t];\n axwMemory : ARRAY[0..c_udiMaxIndex] OF __XWORD;\n udiSize : UDINT;\n itfString : STR.IString := STR.CreateString(\n ADR(axwMemory), SIZEOF(axwMemory),\n ADR(abyValue),\n udiStrSize=>udiSize\n );\n xOk : BOOL;\nEND_VAR\n \nxOk := (\n udiSize >= 512 AND\n itfString.Len() = 33 AND\n STR.RuneCount(itfString) = 20 AND\n itfString.IsValid() AND\n NOT itfString.IsASCII()\n); Mit den Hilfsmitteln der Bibliothek Generic String Base werden viele dieser Anforderungen von entsprechenden Bausteinen ber√ºcksichtigt und somit¬†dem Anwender¬†viele Aufgaben abgenommen. Vor allem die richtige Reservierung und Ausrichtung der Speicherbereiche sind¬†in den entsprechenden Bausteinen¬†gekapselt. " }, 
{ "title" : "Beispiele ", 
"url" : "_strlib_examples.html", 
"breadcrumbs" : "CODESYS String Libraries \/ Beispiele ", 
"snippet" : "Um die Stringverarbeitung so einfach wie m√∂glich zu gestalten, steht Ihnen die Bibliothek Generic String Base zur Verf√ºgung. Sie verwendet allerdings das Compilerfeature¬† VAR_GENERIC CONSTANT ¬†und kann somit erst ab CODESYS V3.5 SP19 Patch 5 genutzt werden....", 
"body" : "Um die Stringverarbeitung so einfach wie m√∂glich zu gestalten, steht Ihnen die Bibliothek Generic String Base zur Verf√ºgung. Sie verwendet allerdings das Compilerfeature¬† VAR_GENERIC CONSTANT ¬†und kann somit erst ab CODESYS V3.5 SP19 Patch 5 genutzt werden. " }, 
{ "title" : "Bibliothek Generic String Base ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4598276773272033733014529891", 
"breadcrumbs" : "CODESYS String Libraries \/ Beispiele \/ Bibliothek Generic String Base ", 
"snippet" : "Hier wird eine Instanz ( myString ) eines¬† GSB.UTF8Strings ¬†mit einer Kapazit√§t von 128 Bytes erzeugt und das String-Segment mit dem Wert einer STRING-Variablen (R√∂mische Zahl 1968) initialisiert. Es stehen die Methoden von¬† STR.IString ¬†zur Verf√ºgung. Von STRING zu IString VAR ¬† ¬†¬†myString : GSB.UT...", 
"body" : "Hier wird eine Instanz ( myString ) eines¬† GSB.UTF8Strings ¬†mit einer Kapazit√§t von 128 Bytes erzeugt und das String-Segment mit dem Wert einer STRING-Variablen (R√∂mische Zahl 1968) initialisiert. Es stehen die Methoden von¬† STR.IString ¬†zur Verf√ºgung. Von STRING zu IString VAR\n¬† ¬†¬†myString : GSB.UTF8String<128> := (sValue := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß');¬†\/\/ r√∂misch 1968¬†¬†¬†¬†\n psString : POINTER TO STRING;¬†¬†¬†¬†udiSize, udiLength : UDINT;¬† ¬†¬†xASCII, xOk : BOOL;\nEND_VAR\n \n psString := myString.GetSegment(udiSize=>udiSize, udiLength=>udiLength, xASCII=>xASCII);¬†\/\/ Conversion back to the STRING data type\n \nxOk := (\n myString.IsValid() AND \/\/ A valid UTF-8 encoding is present\n udiSize = 128 AND \/\/ The capacity of the string in bytes\n myString.Len() = 17 AND \/\/ The current length of the string in bytes\n STR.RuneCount(myString) = 6 \/\/ The current number of characters in the string\n); Funktion des String-Builders VAR\n myString : GSB.UTF8String<20> := (sValue := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß'); \/\/ roman 1968\n sValue : STRING := 'wurden in Mexico-Stadt die';\n wsValue : WSTRING := \"‚Ö©‚Ö®.\";\n diSpace : STR.RUNE := 32;\n myValue : GSB.UTF8String<128> := (sValue := UTF8#'—∫‚Ñì∆¥ŒºœÅ‚ò§·πß·∏â–ΩŒµŒ∑ $$œÅ—ó‚ÑÆ≈Ç‚ÑØ Œ±‚ô≠‚ÑäŒµ‚ÑåŒ± ü‚ä•‚ÑÆ·æî.');\n \n myBuilder : GSB.Builder<(*udiInitialCapacity*) 64, (*usiExtensionFactor*) 50> := (itfString:=myString);\n myResult : GSB.UTF8String<128>;\n \n {attribute 'monitoring_encoding' := 'UTF-8'}\n sResult : STRING(128) := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß wurden in Mexico-Stadt die ‚Ö©‚Ö®. —∫‚Ñì∆¥ŒºœÅ‚ò§·πß·∏â–ΩŒµŒ∑ $$œÅ—ó‚ÑÆ≈Ç‚ÑØ Œ±‚ô≠‚ÑäŒµ‚ÑåŒ± ü‚ä•‚ÑÆ·æî.';\n \n psResult : POINTER TO STRING;\n udiLength : UDINT;\n xOk : BOOL;\nEND_VAR\n \nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteString(sValue);\nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteWString(wsValue);\nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteIString(myValue);\n \nudiLength := myBuilder.Len(); \/\/ The number of bytes occupied in the builder.\nmyBuilder.ToIString(myResult); \/\/ The individual parts of the string are copied together to myResult.\n \npsResult := myResult.GetSegment(); \nxOk := (psResult^ = sResult); \/\/ Both memory areas should have the same content. Im obigen Beispiel wird eine Instanz des Builders mit einer initialen Kapazit√§t von 64 Bytes ( udiInitialCapacity ) und einem Dynamikfaktor von 50 ( usiExtensionFactor ) erzeugt. Der weiter oben erzeugte String wird noch in der Deklaration √ºbergeben, somit wird der Builder mit diesem String ( UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß' ) bef√ºllt. √úber den Parameter¬† usiExtensionFactor ¬†wird erreicht, dass der Builder automatisch um 50 % vergr√∂√üert wird, wenn seine aktuelle Kapazit√§t ersch√∂pft ist. Einlesen einer Datei mit dem Builder VAR\n sPath : STRING := 'myFilePath';\n hFile : RTS_IEC_HANDLE := RTS_INVALID_HANDLE;\n myBuilder : GSB.Builder<(*udiInitialCapacity*) 16#10000, (*usiExtensionFactor*) 50>;\n abyBuffer : ARRAY[0..4095] OF BYTE;\n pbyData : POINTER TO BYTE;\n udiSize : UDINT;\n udiCount : UDINT;\n eEncoding : SCV.ENCODING;\n eErrorID : SCV.ERROR;\n udiResult : RTS_IEC_RESULT;\nEND_VAR\n \nhFile := SysFileOpen(sPath, ACCESS_MODE.AM_READ, ADR(udiResult));\nIF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n RETURN; \nEND_IF\n \nREPEAT \/\/ fake loop - We need the EXIT feature\n pbyData := ADR(abyBuffer);\n udiSize := TO_UDINT(SysFileRead(hFile, pbyData, XSIZEOF(abyBuffer), ADR(udiResult)));\n IF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n EXIT; \n END_IF\n \n \/\/ Determination of the file encoding\n udiCount := SCV.DecodeBOM(pbyData, udiSize, eEncoding=>eEncoding, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n \/\/ handle error condition\n EXIT;\n END_IF\n \n pbyData := pbyData + udiCount;\n udiSize := udiSize - udiCount;\n \n WHILE udiSize > 0 DO\n \/\/ Convert file content to UTF-8 and copy to Builder-Content\n udiCount := myBuilder.WriteMemSegment(pbyData, udiSize, eEncoding, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n \/\/ handle error condition\n EXIT;\n END_IF\n pbyData := ADR(abyBuffer);\n udiSize := TO_UDINT(SysFileRead(hFile, pbyData, XSIZEOF(abyBuffer), ADR(udiResult)));\n IF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n EXIT; \n END_IF\n END_WHILE\nUNTIL TRUE\nEND_REPEAT\n \nIF hFile <> RTS_INVALID_HANDLE THEN\n SysFileClose(hFile);\n hFile := RTS_INVALID_HANDLE;\n udiCount : UDINT;\nEND_IF Analyse des Inhalts einer Builder-Instanz VAR\n myRange : SBD.Range := (itfBuilder := myBuilder);\n diRune : STR.RUNE;\n eError : STR.ERROR;\nEND_VAR\n \nmyRange.Reset();\nWHILE (diRune := myRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND_THEN eErrorID = 0 DO\n IF UC.IsSpace(diRune) THEN\n \/\/ The characters in the builder which are considered as spaces according to UNICODE are counted.\n udiCount := udiCount + 1;\n END_IF\nEND_WHILE F√ºr die Weitergabe von UTF-8-kodierten Inhalten wird kein Zwischenspeicher f√ºr die Umwandlung der Kodierung ben√∂tigt, weil die Daten im Builder bereits UTF-8-kodiert sind. Daher k√∂nnen die Inhalte der Segmente eines Builders direkt, beispielsweise √ºber eine TCP\/IP-Verbindung, verschickt werden. Transport des UTF-8 kodierten Inhalts eines Builders √ºber das Netzwerk VAR\n itfConnection : NBS.IConnection;\n pbySegment : POINTER TO BYTE;\n udiSize : UDINT;\n eError : NBS.ERROR;\nEND_VAR\n \n(* Provide an active itfConnection *)\n \npbySegment:= myBuilder.GetFirstSegment(udiSize=>udiSize, eErrorID=>eErrorID);\nWHILE pbySegment <> 0 AND eErrorID = 0 DO\n eError := itfConnection.Write(pbySegment, udiSize, udiCount=>udiCount);\n IF eError <> 0 OR udiCount <> udiSize THEN\n \/\/ Handle Error\n EXIT;\n END_IF\n pbySegment := myBuilder.GetNextSegment(pbySegment, udiSize=>udiSize, eErrorID=>eErrorID);\nEND_WHILE\n \n(* e.g. Close itfConnection *) " }, 
{ "title" : "Arbeiten mit den Funktionsbausteinen StringPool und RangePool ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4670931838168033733015007444", 
"breadcrumbs" : "CODESYS String Libraries \/ Beispiele \/ Arbeiten mit den Funktionsbausteinen StringPool und RangePool ", 
"snippet" : "Der folgende Code zeigt die Verwendung von dynamischen IString -Instanzen aus einem StringPool . Ein¬† StringPool ¬†oder ein¬† RangePool ¬†ist gut daf√ºr geeignet, an unterlagerte Programmteile weitergegeben zu werden. Diese k√∂nnen dann bei Bedarf die entsprechenden Instanzen aus dem jeweiligen Pool erze...", 
"body" : "Der folgende Code zeigt die Verwendung von dynamischen IString -Instanzen aus einem StringPool . Ein¬† StringPool ¬†oder ein¬† RangePool ¬†ist gut daf√ºr geeignet, an unterlagerte Programmteile weitergegeben zu werden. Diese k√∂nnen dann bei Bedarf die entsprechenden Instanzen aus dem jeweiligen Pool erzeugen, damit arbeiten und diese Instanzen anschlier√üend in den Pool zur√ºcklegen. Arbeiten mit StringPool und RangePool VAR\n myString : GSB.UTF8String<256> := (sValue:=UTF8#'Was du nicht willst, dass man dir tu‚Äô, das f√ºg auch keinem andern zu.');\n myRange : STR.Range := (itfString:=myString);\n \n myStringPool : GSB.StringPool<(*udiStringSize*) 30, (*udiInitialCapacity*) 25, (*usiExtensionFactor*) 0>;\n myRangePool : GSB.RangePool<GSB.RANGE_TYPE.ISTRING, (*udiInitialCapacity*) 10, (*usiExtensionFactor*) 0>;\n \n diRune : STR.RUNE;\n eErrorID : STR.ERROR;\n itfSubString : STR.IString;\n liStart, liEnd : LINT;\n udiCount : UDINT;\nEND_VAR\n \nmyRange.Reset();\n\/\/ Decompose myString into substrings and analyze them via a subroutine.\nWHILE (diRune:=myRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND eErrorID = 0 DO\n IF diRune = 16#2C (*,*) OR diRune = 16#2E (*.*) THEN\n itfSubString := myStringPool.GetString();\n IF itfSubString = 0 THEN\n (* Handle Error *)\n EXIT;\n END_IF\n myString.ToIString(itfSubString, liStart+1, liEnd, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n (* Handle Error *)\n EXIT;\n END_IF\n \/\/ Analyse the substring and use pool's\n \/\/ Will release itfSubString\n udiCount := Analyse(itfSubString, myStringPool, myRangePool);\n (* ... Handle Result ... *)\n IF diRune = 16#2E (*.*) THEN\n EXIT;\n END_IF\n diRune:=myRange.GetNextRune(eErrorID=>eErrorID);\n IF diRune = 16#20 (* space *) AND eErrorID = 0 THEN\n liEnd := liEnd + 1;\n ELSE\n myRange.UngetLastRune();\n END_IF\n liStart := liEnd + 1;\n END_IF\n liEnd := liEnd + 1;\nEND_WHILE " }, 
{ "title" : "Arbeiten mit den Zeichenkategorien von Unicode ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4613758488403233733015299155", 
"breadcrumbs" : "CODESYS String Libraries \/ Beispiele \/ Arbeiten mit den Zeichenkategorien von Unicode ", 
"snippet" : "Der Unicode-Standard hat das Ziel, weltweit alle Zeichen digital zu erfassen und ihre Eigenschaften zu beschreiben. Dabei werden die Zeichen zu Gruppen (Kategorien) zusammengefasst. In der Unicode-Bibliothek finden sich Funktionen, die ein Zeichen hinsichtlich der Zugeh√∂rigkeit zu einer Kategorie pr...", 
"body" : "Der Unicode-Standard hat das Ziel, weltweit alle Zeichen digital zu erfassen und ihre Eigenschaften zu beschreiben. Dabei werden die Zeichen zu Gruppen (Kategorien) zusammengefasst. In der Unicode-Bibliothek finden sich Funktionen, die ein Zeichen hinsichtlich der Zugeh√∂rigkeit zu einer Kategorie pr√ºfen. Diese Funktionen geben TRUE zur√ºck, wenn das √ºbergebene Zeichen zu der jeweiligen Kategorie geh√∂rt, ansonsten wird FALSE zur√ºckgegeben. Name Funktion IsControl Erkennt allgemeine Steuerzeichen IsLetter Erkennt Buchstaben im weiteren Sinne IsMark Erkennt kombinierende also beispielsweise diakritische Zeichen IsDigit Erkennt dezimale Ziffern IsLower Erkennt Kleinbuchstaben IsNumber Erkennt Ziffern und Zeichen, die f√ºr Zahlen Anwendung finden IsGraphic Erkennt nur druckbare Zeichen (inklusive unterschiedlicher Leerzeichen) IsUpper Erkennt Gro√übuchstaben IsPunct Erkennt Zeichen, die zur Interpunktion verwendet werden IsPrint Erkennt nur druckbare Zeichen (ber√ºcksichtigt als Leerzeichen nur 16#20 ) IsTitle Erkennt Gro√übuchstaben f√ºr √úberschriften IsSpace Erkennt Leerzeichen unterschiedlicher Breite, Zeilenumbruch, ... IsSymbol Erkennt Symbole im weiteren Sinne, beispielsweise mathematische Symbole und W√§hrungssymbole. Die Inhalte einer¬† IString -¬†oder¬† IBuilder -Instanz lassen sich √ºber einen passenden Baustein vom Typ¬† Range ¬†\"zeichenweise\" analysieren. F√ºr die Analyse lassen sich die Funktionen aus der Unicode-Bibliothek gut verwenden. Zeichenanalyse VAR\n myString : GSB.UTF8String<50> := (sValue:='Hello World!');\n myBuilder : GSB.Builder<100, 0> := (itfString:=myString);\n mySRange : STR.Range := (itfString:=myString);\n myBRange : SBD.Range := (itfBuilder:=myBuilder);\n diSRune, diBRune : STR.RUNE;\n eErrorID : STR.ERROR;\n udiCount : UDINT;\nEND_VAR\n \nWHILE (diSRune:=mySRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND eErrorID = 0 DO\n diBRune := myBRange.GetNextRune();\n IF diSRune <> diBRune THEN\n (* Solle nicht vorkommen *)\n END_IF\n IF UC.IsSpace(diSrune) THEN\n udiCount := udiCount + 1;\n END_IF\nEND_WHILE " }, 
{ "title" : "Umwandlung von Zeichen ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4613761628716833733015669185", 
"breadcrumbs" : "CODESYS String Libraries \/ Beispiele \/ Umwandlung von Zeichen ", 
"snippet" : "Buchstaben in Gro√übuchstaben umwandeln ( UC.ToUpper ) Buchstaben in Kleinbuchstaben umwandeln ( UC.ToLower ) Umwandlung VAR diRuneA, diRuneB : STR.RUNE; END_VAR diRuneA := 16#1F3; \/\/ U+01F3 = «Ö diRuneB := UC.ToUpper(diRuneA); \/\/ U+01F1 = «± diRuneA := UC.ToLower(diRuneB); \/\/ U+01F3 = «Ö diRuneB := UC....", 
"body" : "Buchstaben in Gro√übuchstaben umwandeln ( UC.ToUpper ) Buchstaben in Kleinbuchstaben umwandeln ( UC.ToLower ) Umwandlung VAR\n diRuneA, diRuneB : STR.RUNE;\nEND_VAR\n \ndiRuneA := 16#1F3; \/\/ U+01F3 = «Ö\ndiRuneB := UC.ToUpper(diRuneA); \/\/ U+01F1 = «±\ndiRuneA := UC.ToLower(diRuneB); \/\/ U+01F3 = «Ö\ndiRuneB := UC.ToTitle(diRuneA); \/\/ U+01F2 = «≤ " }, 
{ "title" : "Vergleich von Zeichenketten ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4563870076659233733015900115", 
"breadcrumbs" : "CODESYS String Libraries \/ Beispiele \/ Vergleich von Zeichenketten ", 
"snippet" : "Mit Ber√ºcksichtigung der Gro√ü-\/Kleinschreibung ( STR.Compare ) Ohne Ber√ºcksichtigung der Gro√ü-\/Kleinschreibung ( UC.EqualFold ) Vergleich von Strings VAR myFirstString : GSB.UTF8String<50> := (sValue:='test'); mySecondString : GSB.UTF8String<50> := (sValue:='Test'); myThirdString : GSB.UTF8String<50...", 
"body" : "Mit Ber√ºcksichtigung der Gro√ü-\/Kleinschreibung ( STR.Compare ) Ohne Ber√ºcksichtigung der Gro√ü-\/Kleinschreibung ( UC.EqualFold ) Vergleich von Strings VAR\n myFirstString : GSB.UTF8String<50> := (sValue:='test');\n mySecondString : GSB.UTF8String<50> := (sValue:='Test');\n \n myThirdString : GSB.UTF8String<50> := (sValue:='CoDeSys');\n myFourthString : GSB.UTF8String<50> := (sValue:='CODESYS');\n \n diResult : DINT;\n xEqual : BOOL;\nEND_VAR\n \n\/\/\/ Comparing two Strings lexicographically\n\/\/\/ diResult = 1 --> myFirstString > mySecondString\ndiResult := STR.Compare(myFirstString, mySecondString);\n \n\/\/\/ Unicode defined simple case folding\n\/\/\/ xEqual = TRUE --> myThirdString == myFourthString\nxEqual := UC.EqualFold(\n ADR(myThirdString.sValue), myThirdString.Len(),\n ADR(myFourthString.sValue), myFourthString.Len()\n); " }
]
$(document).trigger('search.ready');
});