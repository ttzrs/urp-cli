$(document).ready(function () {indexDict['de'] = [{ "title" : "CODESYS SoftMotion ", 
"url" : "_sm_start_page.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion ", 
"snippet" : "Mit CODESYS SoftMotion können Sie SPS-gesteuerte Bewegungen effizient realisieren. Dies reicht von einfachen einachsigen Bewegungen oder Kurvenscheiben bis hin zu komplexen Bewegungen in mehreren Dimensionen. Besonders Applikationen, die neben der Bewegungsfunktionalität auch die Ablauf- und Prozess...", 
"body" : "Mit CODESYS SoftMotion können Sie SPS-gesteuerte Bewegungen effizient realisieren. Dies reicht von einfachen einachsigen Bewegungen oder Kurvenscheiben bis hin zu komplexen Bewegungen in mehreren Dimensionen. Besonders Applikationen, die neben der Bewegungsfunktionalität auch die Ablauf- und Prozesskontrolle beinhalten, fallen in den Anwendungsbereich der CODESYS SoftMotion . Sie können CODESYS SoftMotion im CODESYS Store International oder im CODESYS Store North America herunterladen. Dort finden Sie auch das Datenblatt zum Produkt. Siehe auch CODESYS SoftMotion im CODESYS Forum " }, 
{ "title" : "Lizenzierung ", 
"url" : "_sm_licensing.html", 
"breadcrumbs" : "CODESYS Softmotion \/ Lizenzierung ", 
"snippet" : "Zusätzlich zu den allgemeinen lizenzierten Softwaremetriken sind für CODESYS SoftMotion Metriken definiert, die beim Download geprüft werden. Die SoftMotion -Metriken werden beim Übersetzen berechnet und der aktuelle Wert wird erst danach im Editor angezeigt. Die ermittelten Werte beziehen sich auf ...", 
"body" : "Zusätzlich zu den allgemeinen lizenzierten Softwaremetriken sind für CODESYS SoftMotion Metriken definiert, die beim Download geprüft werden. Die SoftMotion -Metriken werden beim Übersetzen berechnet und der aktuelle Wert wird erst danach im Editor angezeigt. Die ermittelten Werte beziehen sich auf eine Applikation. Bei mehreren Applikationen werden die Werte der einzelnen Applikationen aufsummiert. Gruppe Metrik Wertermittlung Anzahl der Achsen Reale Achse Der Wert der Metrik wird definiert durch den größeren Wert von verwendeten realen Achsen und virtuellen Achsen. Beispiel: Bei 3 realen und 4 virtuellen Achsen ist der Wert in der Applikation = 4 Virtuelle Achse Anzahl der Achsgruppen und CNC-Interpolatoren Achsgruppen Der Wert der Metrik wird definiert durch die Summe von Achsgruppen und CNC-Interpolatoren Beispiel: Bei 2 Achsgruppen und 2 CNC-Interpolatoren ist der Wert in der Applikation = 4 CNC-Interpolatoren " }, 
{ "title" : "Komponenten der CODESYS SoftMotion ", 
"url" : "_sm_components.html", 
"breadcrumbs" : "CODESYS Softmotion \/ Komponenten der CODESYS SoftMotion ", 
"snippet" : "CODESYS SoftMotion ist ein Softwarepaket, das als Entwicklungs- und Laufzeitumgebung für Motionsteuerungen dient. Es gliedert sich wie folgt: Antriebskonfiguration ( Drive Configuration ): Die Antriebskonfiguration stellt einen Editor zur Verfügung, mit dem Sie die Struktur und Konfiguration der Ant...", 
"body" : "CODESYS SoftMotion ist ein Softwarepaket, das als Entwicklungs- und Laufzeitumgebung für Motionsteuerungen dient. Es gliedert sich wie folgt: Antriebskonfiguration ( Drive Configuration ): Die Antriebskonfiguration stellt einen Editor zur Verfügung, mit dem Sie die Struktur und Konfiguration der Antriebshardware über die CODESYS -Benutzeroberfläche einstellen können. Dabei wird eine Instanz eines IEC-Funktionsbausteins erzeugt, der den Antrieb repräsentiert. Dieser Baustein kommuniziert automatisch mit den Antrieben, ohne zusätzlichen Aufwand für den IEC-Programmierer. Er sorgt für die Übermittlung von aktualisierten Daten. Zur Steuerung der Antriebe kann das SoftMotion IEC-Programm den Antrieb über die Funktionsbausteine der -Bibliotheken ansprechen. Alternativ können Sie zu diesem Zweck auch eigene Funktionsbausteine entwickeln. Durch diese Funktionsbausteine werden die Sollwerte (für Position, Geschwindigkeit, Beschleunigung, etc.) zyklisch geschrieben. Hinweis: Das Produkt CODESYS SoftMotion Light ist Bestandteil der Standardinstallation von CODESYS . Es bietet die Möglichkeit, die Achsen zu kommandieren. Dabei gibt CODESYS nur die Zielposition vor und wartet auf die Rückmeldung des Achsreglers. Die Bewegungsplanung wird vom Achsregler übernommen. Eine koordinierte Bewegung mehrerer Achsen durch CODESYS ist dabei nicht möglich. Kurvenscheibeneditor ( Cam editor ): Im Kurvenscheibeneditor können Sie eine Kurvenscheibe graphisch oder mit Hilfe von Tabellen beschreiben. CODESYS erzeugt daraus eine globale Instanz einer Datenstruktur, die die Kurvenscheibe beschreibt. Diese wird an die Applikation übergeben, wo die geeigneten POUs auf sie zugreifen können. CNC-Editor ( CNC editor ): Im CNC-Editor können Sie mehrdimensionale Bewegungen erzeugen. Sie erstellen die CNC-Bahn mit einem Texteditor (angelehnt an DIN 66025) oder mit einem grafischen Editor. Alternativ zum Texteditor können Sie in einer vereinfachten Tabellenansicht arbeiten. Achsgruppenkonfiguration ( Axis group configuration ): Eine Achsgruppe beschreibt die Beziehungen mehrerer mechanisch abhängiger Achsen, die gemeinsam ein Werkzeug oder einen Greifer im Raum positionieren und orientieren. Mit dem Konfigurator wählen Sie die zu verwendende Kinematik aus und konfigurieren sie. Außerdem können Sie die SoftMotion-Achsen zuordnen. Die Bibliothek SM3_Basic ist eine Basisbibliothek für alle SoftMotion -Applikationen. Sie enthält insbesondere: PLCopen-Funktionsbausteine gemäß dem PLCopen-Standard Sie können mit den Bausteinen einachsige Bewegungen oder Master-\/Slavebewegungen zweier Achsen (elektrische Kurvenscheibe, elektrisches Getriebe) steuern. Zusätzliche Bausteine, die nicht durch PLCopen-Funktionalitäten abgedeckt sind Hilfsfunktionen: zum Beispiel zur Handhabung von Dateien oder für Fehlermeldungen Die Bibliothek SM3_CNC basiert auf der Bibliothek SM3_Basic . Neben einigen Funktionsbausteinen für kinematische Transformationen stellt sie alle POUs zur Verfügung, die zur Erzeugung, Ausführung und Visualisierung von CNC-Bewegungen benötigt werden. Sie stellt auch Funktionsbausteine zur Bahnvorverarbeitung und Bahnrekonstruktion zur Verfügung. Die Bibliothek SM3_Robotics enthält Funktionsbausteine nach PLCopen Part 4 für Robotik und zusätzliche Funktionsbausteine. Die zugehörige Bibliothek SM3_Transformations enthält die unterstützten kinematischen Transformationen. Die Antriebsschnittstelle ( Drive interface ) ist Teil der Bibliothek SM3_Basic und zuständig für die Kommunikation zwischen IEC-Programm und Antrieben. CODESYS SoftMotion stellt für die unterstützten Antriebe Bibliotheken zur Verfügung, die diese Antriebsschnittstelle implementieren. Sehen Sie auch die Beschreibungen der Anwendungsbeispiele. " }, 
{ "title" : "Verwendung der Steuerungen CODESYS RTE V3 und CODESYS WIN V3 ", 
"url" : "_sm_rtev3_winv3.html", 
"breadcrumbs" : "CODESYS Softmotion \/ Verwendung der Steuerungen CODESYS RTE V3 und CODESYS WIN V3 ", 
"snippet" : "Ab CODESYS Development System SP20 sind die SoftMotion -Steuerungen CODESYS SoftMotion RTE V3 und CODESYS SoftMotion Win V3 nicht mehr vorhanden. Es werden nun die Standard-Steuerungen CODESYS Control RTE V3 und CODESYS Control Win V3 verwendet. Über den Befehl Befehl: werden die Standard-Steuerung ...", 
"body" : "Ab CODESYS Development System SP20 sind die SoftMotion -Steuerungen CODESYS SoftMotion RTE V3 und CODESYS SoftMotion Win V3 nicht mehr vorhanden. Es werden nun die Standard-Steuerungen CODESYS Control RTE V3 und CODESYS Control Win V3 verwendet. Über den Befehl Befehl: werden die Standard-Steuerung in SoftMotion -Steuerung umgewandelt. " }, 
{ "title" : "SoftMotion mit Mehrkernprozessoren ", 
"url" : "_sm_multicore_hint.html", 
"breadcrumbs" : "CODESYS Softmotion \/ SoftMotion mit Mehrkernprozessoren ", 
"snippet" : "Durch Verteilung der Motion-Tasks auf mehrere Prozessorkerne können mehr Achsen oder Achsgruppen durch SoftMotion angesteuert werden. Rechenintensive Aufgaben wie die CNC-Bahnvorverarbeitung oder Robotik-Bahnplanung für CP-Bewegungen können auf einen anderen Prozessorkern ausgelagert werden. Dann bl...", 
"body" : "Durch Verteilung der Motion-Tasks auf mehrere Prozessorkerne können mehr Achsen oder Achsgruppen durch SoftMotion angesteuert werden. Rechenintensive Aufgaben wie die CNC-Bahnvorverarbeitung oder Robotik-Bahnplanung für CP-Bewegungen können auf einen anderen Prozessorkern ausgelagert werden. Dann bleibt in der Bustask mehr Zeit für andere Aufgaben. Dass die Rechenleistung der Einzelkernsteuerung nicht ausreicht, äußert sich im Fall von Robotik beispielsweise dadurch, dass die Bahngeschwindigkeit unerklärlicherweise abnimmt. Systemvoraussetzungen Version SM 4.5.1.0 oder höher Version Compiler 3.5.12.0 oder höher Multicore-fähiges Laufzeitsystem Anwendung Robotik und CNC: Planungs- und Bustask auf verschiedene Prozessorkerne legen Bei Verwendung von verschiedenen Bussystemen die einzelnen Bustasks auf verschiedene Prozessorkerne legen Bei der Verwendung von mehreren Tasks und mehreren Prozessorkernen ist Folgendes zu beachten: Die Funktionsbausteine in der CNC-Planungstask dürfen nur in bestimmten Zuständen des Interpolators (Ausgang iStatus ) eine neue steigende Flanke am Eingang Execute bekommen. Dies gilt auch für Einzelkern: IPO_UNKNOWN IPO_WAIT IPO_FINISHED IPO_INIT (nur beim ersten Start, nicht bei Restart) Die Bustasks voneinander abhängiger Achsen (Achsgruppe, Kurvenscheibe, CNC-Kinematik) müssen auf dem gleichen Prozessorkern laufen. " }, 
{ "title" : "CODESYS SoftMotion Drives ", 
"url" : "_sm_f_drive_control.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SoftMotion-Antriebskonfiguration ", 
"url" : "_sm_f_drive_configuration.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ SoftMotion-Antriebskonfiguration ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Übersicht ", 
"url" : "_sm_overview_drive_configuration.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ SoftMotion-Antriebskonfiguration \/ Übersicht ", 
"snippet" : "Das SoftMotion-Drive-Interface ist eine standardisierte Schnittstelle, mit der Sie die Antriebshardware innerhalb des IEC-Programms einbinden, konfigurieren und adressieren können. Durch das Abbilden unterschiedlicher Hardware auf eine allgemeine Schnittstelle können Sie Antriebe einfach auswechseln...", 
"body" : "Das SoftMotion-Drive-Interface ist eine standardisierte Schnittstelle, mit der Sie die Antriebshardware innerhalb des IEC-Programms einbinden, konfigurieren und adressieren können. Durch das Abbilden unterschiedlicher Hardware auf eine allgemeine Schnittstelle können Sie Antriebe einfach auswechseln und IEC-Programme wiederverwenden. Die Schnittstelle koppelt die Antriebe an das E\/A-Abbild und ist für die Aktualisierung und Übertragung der notwendigen Bewegungsdaten an die Antriebssteuerung verantwortlich. Die Antriebsschnittstelle besteht aus den folgenden Komponenten: Gerätebeschreibung der SoftMotion -Geräte zu ihrer Darstellung im Gerätebaum Bibliotheken, die in der Gerätebeschreibung referenziert sind, die die grundlegenden Funktionsbausteine AXIS_REF_SM3 entsprechend den Anforderungen der spezifischen Antriebstypen erweitern oder überladen Bibliotheken, die Funktionsbausteine für azyklisches Lesen\/Schreiben von Daten enthalten, um Standardfunktionen für den Feldbustreiber zu wrappen Wenn Sie eine SoftMotion -SPS, wie zum Beispiel CODESYS SoftMotion Win verwenden, werden die Basisbibliotheken automatisch in den Bibliotheksverwalter eingebunden. Solche Steuerungen stellen einen SoftMotion General Axis Pool zur Verfügung. Darin können Sie freie Antriebsgeräte einfügen. " }, 
{ "title" : "Gekoppelte Antriebsgeräte ", 
"url" : "_sm_inserting_connected_drive_devices.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ SoftMotion-Antriebskonfiguration \/ Gekoppelte Antriebsgeräte ", 
"snippet" : "Gekoppelte Antriebsgeräte gehören zu einem Gerät, das den Antrieb innerhalb der Feldbustopologie repräsentiert. Die Piktogramme dieser Antriebe sind um kleine Zeichen erweitert, die den zugehörigen Feldbustyp andeuten. Beispielsweise ist jeder Standard-Servoantrieb durch einen Feldbus mit der Steuer...", 
"body" : "Gekoppelte Antriebsgeräte gehören zu einem Gerät, das den Antrieb innerhalb der Feldbustopologie repräsentiert. Die Piktogramme dieser Antriebe sind um kleine Zeichen erweitert, die den zugehörigen Feldbustyp andeuten. Beispielsweise ist jeder Standard-Servoantrieb durch einen Feldbus mit der Steuerung verbunden. Für die Verwendung von Antrieben bietet CODESYS SoftMotion spezielle Gerätebeschreibungen für die Feldbusmaster (Endung „_SoftMotion“) an. Diese besitzen für den Antrieb optimierte Grundparameter. Bei Antrieben, die mit CODESYS SoftMotion verwendet werden, muss das Modulo-Handling im Antrieb deaktiviert werden. Das Modulo-Handling wird von CODESYS SoftMotion in der Steuerung durchgeführt. Der maximale Verfahrbereich sollte nach Möglichkeit auf 32 Bit eingestellt werden. Gekoppeltes Antriebgerät (EtherCAT) einfügen Voraussetzung: Sie haben in Ihrem Projekt eine SoftMotion-kompatible Steuerung eingefügt. Selektieren Sie die SoftMotion -Steuerung im Gerätebaum. Wählen Sie den Befehl Gerät anhängen aus dem Kontextmenü. Wählen Sie im Dialog Gerät anhängen das Gerät Feldbusse → EtherCAT → Master → EtherCATMasterSoftMotion aus. Klicken Sie auf die Schaltfläche Gerät anhängen . Das Gerät wird zum Gerätebaum hinzugefügt. Der Dialog Gerät anhängen bleibt geöffnet. Selektieren Sie das neu eingefügte Gerät im Gerätebaum. Wählen Sie im Dialog Gerät anhängen einen SoftMotion-Slave aus ( Feldbusse → EtherCAT → Slave → <SoftMotion-Antrieb> ). Klicken Sie auf die Schaltfläche Gerät anhängen . Das Gerät wird zum Gerätebaum hinzugefügt. Durch Doppelklick auf das Gerät öffnet sich der zugehörige Geräteeditor. " }, 
{ "title" : "Encoder-Achse ", 
"url" : "_sm_encoder_drive_devices.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ SoftMotion-Antriebskonfiguration \/ Encoder-Achse ", 
"snippet" : "Mit Encoder-Achsen werden Geberwerte in eine SoftMotion-Achse umgewandelt, die als Masterachse für MC_CamIn , MC_GearIn und andere Master\/Slave-Funktionsbausteine verwendet werden kann. Encoder-Achsen können zusätzliche Encoder von Antriebsgeräten abbilden. In diesem Fall werden sie als spezielle En...", 
"body" : "Mit Encoder-Achsen werden Geberwerte in eine SoftMotion-Achse umgewandelt, die als Masterachse für MC_CamIn , MC_GearIn und andere Master\/Slave-Funktionsbausteine verwendet werden kann. Encoder-Achsen können zusätzliche Encoder von Antriebsgeräten abbilden. In diesem Fall werden sie als spezielle Encoder-Achsen unter Feldbusgeräten im Gerätebaum konfiguriert. Alternativ können freie Encoder im General Axis Pool verwendet werden, um analoge Eingänge als Encoder-Achsen abzubilden. Für weitere Informationen siehe: Freier EncoderEigenschaften Encoder-Achsen sind, ähnlich wie logische Achsen, \"read-only\". Sie liefern nur die Positions- und Geschwindigkeitswerte. Es kann keine Bewegung auf ihnen kommandiert werden. Der Achszustand von Encoder-Achsen ist immer standstill . Dies ist der Zustand von PLCopen for Motion Control Part 1, der am besten passt. Nach dem Zustandsdiagramm hat dieser Zustand die Bedeutung, dass die Achse bereit ist und kein Fehler vorliegt. Außerdem ist keine von der SPS befohlene Bewegung an der Achse aktiv. Beachten Sie, dass sich vor CODESYS SoftMotion Version 4.18.0.0 die Encoder-Achsen im Zustand power_off befanden. Wenn jedoch MC_Power für sie aufgerufen wurde, befanden sie sich im Zustand standstill . Die Nullposition der Encoderachse kann mit MC_SetPosition versetzt werden. Master\/Slave-Funktionsbausteine verwenden immer die Istwerte der Encoderachse. Zur Totzeitkompensation kann eine logische Achse unterhalb der Encoderachse verwendet werden. Bei Verwendung von Encoderachsen ist ein Aufruf von MC_Power nicht nötig und macht ab CODESYS SoftMotion Version 4.18.0.0 keinen Unterschied für das Verhalten der Encoderachse. " }, 
{ "title" : "Freie Antriebsgeräte einfügen ", 
"url" : "_sm_f_free_drive_devices.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ SoftMotion-Antriebskonfiguration \/ Freie Antriebsgeräte einfügen ", 
"snippet" : "Freie Antriebsgeräte sind nicht fest mit einem anderen Gerät im Gerätebaum gekoppelt. Sie werden im Gerätebaum unter SoftMotion General Drive Pool eingehängt....", 
"body" : "Freie Antriebsgeräte sind nicht fest mit einem anderen Gerät im Gerätebaum gekoppelt. Sie werden im Gerätebaum unter SoftMotion General Drive Pool eingehängt. " }, 
{ "title" : "Antriebsregler Drive_PosControl ", 
"url" : "_sm_drive_controller_drive_poscontrol.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ SoftMotion-Antriebskonfiguration \/ Freie Antriebsgeräte einfügen \/ Antriebsregler Drive_PosControl ", 
"snippet" : "Mit dem Antriebsregler Drive_PosControl können Sie die Lageregelung einer Achse von CODESYS durchführen lassen. Voraussetzung dafür ist ein Gerät, das über Sollgeschwindigkeit angesteuert wird und das seine aktuelle Position zurückliefert. Beispielsweise ist dies ein drehzahlgesteuertes Gerät (Frequ...", 
"body" : "Mit dem Antriebsregler Drive_PosControl können Sie die Lageregelung einer Achse von CODESYS durchführen lassen. Voraussetzung dafür ist ein Gerät, das über Sollgeschwindigkeit angesteuert wird und das seine aktuelle Position zurückliefert. Beispielsweise ist dies ein drehzahlgesteuertes Gerät (Frequenzumrichter) mit Positionsrückführung. Antriebsregler einfügen Voraussetzung: Sie haben in Ihrem Projekt eine SoftMotion-Steuerung eingefügt. Selektieren Sie die SoftMotion General Axis Pool im Gerätebaum. Wählen Sie den Befehl Gerät anhängen aus dem Kontextmenü. Wählen Sie im Dialog Gerät anhängen das Gerät SoftMotion Antriebe → positionsgesteuerte Antriebe → SMC_Drive_PosControl aus. Klicken Sie auf die Schaltfläche Gerät anhängen . Das Gerät wird zum Gerätebaum hinzugefügt. Durch Doppelklick auf das Gerät öffnet der zugehörige Geräteeditor. Für weitere Informationen siehe: Registerkarte: Allgemein" }, 
{ "title" : "Logischer Antrieb ", 
"url" : "_sm_drive_controller_logical_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ SoftMotion-Antriebskonfiguration \/ Freie Antriebsgeräte einfügen \/ Logischer Antrieb ", 
"snippet" : "Sie können einen logischen Antrieb zu jeder Art von Antriebsgeräten hinzufügen. Dabei spiegelt die Achse des logischen Antriebs die Bewegung ihrer Masterachse wieder, während sie eine eigenständige Instanz darstellt. Dies ermöglicht das Ausführen folgender Instruktionen auf ihr, ohne die Masterachse...", 
"body" : "Sie können einen logischen Antrieb zu jeder Art von Antriebsgeräten hinzufügen. Dabei spiegelt die Achse des logischen Antriebs die Bewegung ihrer Masterachse wieder, während sie eine eigenständige Instanz darstellt. Dies ermöglicht das Ausführen folgender Instruktionen auf ihr, ohne die Masterachse zu beeinflussen. MC_SetPosition : Setzen der Position auf einen definierten Wert (beispielsweise 0) MC_TouchProbe : Abspeichern der aktuellen Achsposition aufgrund eines Triggersignals MC_AbortTrigger : Deaktivierung eines zuvor mit MC_TouchProbe aktivierten Messtasters Eine Anwendung wäre ein Transportband, das durch mehrere Bearbeitungsstationen läuft. Über ein externes Signal (beispielsweise eine Lichtschranke) wird die Position des Bauteils erkannt und die Achse auf eine definierte Position gesetzt (Touch-Probe-Funktion). Der logische Antrieb bietet die Möglichkeit, das Signal zu filtern. Deshalb kann der logische Antrieb auch in Verbindung mit einem Encoder, der ein verrauschtes Signal liefert, eingesetzt werden. Logischen Antrieb einfügen Voraussetzung: Sie haben in Ihrem Projekt eine SoftMotion-Steuerung eingefügt. Selektieren Sie ein Antriebsgerät im Gerätebaum. Wählen Sie den Befehl Gerät anhängen aus dem Kontextmenü. Wählen Sie im Dialog Gerät anhängen das Gerät SoftMotionAntriebe → virtuelle Antriebe → SM_Drive_Logical aus. Klicken Sie auf die Schaltfläche Gerät anhängen . Das Gerät wird zum Gerätebaum hinzugefügt. Durch Doppelklick auf das Gerät öffnet sich der zugehörige Geräteeditor. " }, 
{ "title" : "Virtueller Antrieb ", 
"url" : "_sm_drive_controller_virtual_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ SoftMotion-Antriebskonfiguration \/ Freie Antriebsgeräte einfügen \/ Virtueller Antrieb ", 
"snippet" : "Virtuelle Antriebe sind in Software simulierte Antriebe. Mit ihnen können Sie Ihre Programme ohne angebundene Hardware testen oder erweiterte Funktionalitäten realisieren. Solche Funktionen sind beispielsweise das Steuern des Overrides von Achsbewegungen oder das manuelle kartesische Verfahren eines...", 
"body" : "Virtuelle Antriebe sind in Software simulierte Antriebe. Mit ihnen können Sie Ihre Programme ohne angebundene Hardware testen oder erweiterte Funktionalitäten realisieren. Solche Funktionen sind beispielsweise das Steuern des Overrides von Achsbewegungen oder das manuelle kartesische Verfahren eines Roboters im Raum. Für weitere Informationen siehe: Kurvenscheiben-Antrieb mit Hilfe einer virtuellen Zeitachse steuernVirtuelle Antriebe simulieren einen realen Antrieb, indem zu Beginn eines Zyklus die Istwerte von Position, Geschwindigkeit und Beschleunigung auf Basis der Sollpositionen der vorherigen Zyklen berechnet werden. Funktionen, die einen realen Antrieb benötigen, wie ein antriebsseitiges MC_TouchProbe oder die Verwendung von SMC_SetControllerMode , werden nicht unterstützt. Virtuellen Antrieb einfügen Voraussetzung: Sie haben in Ihrem Projekt eine SoftMotion-Steuerung eingefügt. Selektieren Sie die SoftMotion General Axis Pool im Gerätebaum. Wählen Sie den Befehl Gerät anhängen aus dem Kontextmenü. Wählen Sie im Dialog Gerät anhängen das Gerät SoftMotionAntriebe → virtuelle Antriebe → SMC_Drive_Virtual aus. Klicken Sie auf die Schaltfläche Gerät anhängen . Das Gerät wird zum Gerätebaum hinzugefügt. Durch Doppelklick auf das Gerät öffnet sich der zugehörige Geräteeditor. " }, 
{ "title" : "Freier Encoder ", 
"url" : "_sm_drive_controller_free_encoder.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ SoftMotion-Antriebskonfiguration \/ Freie Antriebsgeräte einfügen \/ Freier Encoder ", 
"snippet" : "Verwenden Sie den Freien Encoder , um einen Encoder einzubinden, der nicht fest an E\/As oder eine Hardware gekoppelt ist. Freien Encoder einfügen Selektieren Sie die SoftMotion General Axis Pool im Gerätebaum. Wählen Sie den Befehl Gerät anhängen aus dem Kontextmenü. Wählen Sie im Dialog Gerät anhän...", 
"body" : "Verwenden Sie den Freien Encoder , um einen Encoder einzubinden, der nicht fest an E\/As oder eine Hardware gekoppelt ist. Freien Encoder einfügen Selektieren Sie die SoftMotion General Axis Pool im Gerätebaum. Wählen Sie den Befehl Gerät anhängen aus dem Kontextmenü. Wählen Sie im Dialog Gerät anhängen das Gerät SoftMotionAntriebe → Freie Encoder → SMC_FreeeEncoder aus. Klicken Sie auf die Schaltfläche Gerät anhängen . Das Gerät wird zum Gerätebaum hinzugefügt. Öffnen Sie den Encoder im Editor . Passen Sie die Einstellungen an die Hardware an und stellen Sie Bitbreite und Skalierung ein. Weisen Sie den Eingangswert des Encoders der Variablen <FREE_ENCODER_AXIS>.diEncoderPosition zu. Das ist entweder als IEC-Code möglich oder indem Sie den Speicher der Eingangsdaten mappen. Während der Initialisierung des Feldbusses liefert dieser Eingang möglicherweise ungültige Werte. Über den Eingang bDelayActivation können Sie die Auswertung des Eingangs deaktivieren, bis ein gültiger Wert zur Verfügung steht. Verwenden Sie den Encoder nun wie einen Antrieb. Für weitere Informationen siehe: Encoder-Achse" }, 
{ "title" : "Programmatisches Anlegen von Achsen ", 
"url" : "_sm_programmatic_axes.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ SoftMotion-Antriebskonfiguration \/ Freie Antriebsgeräte einfügen \/ Programmatisches Anlegen von Achsen ", 
"snippet" : "Folgende freie Antriebsgeräte können auch programmatisch angelegt werden: Achsen SMC_VIRTUAL_AXIS Erstellt eine virtuelle Achse, ohne dass diese zum Gerätebaum hinzugefügt werden muss Für weitere Informationen siehe: Virtueller AntriebSMC_Logical_Axis Erstellt eine logische Achse, ohne dass diese zu...", 
"body" : "Folgende freie Antriebsgeräte können auch programmatisch angelegt werden: Achsen SMC_VIRTUAL_AXIS Erstellt eine virtuelle Achse, ohne dass diese zum Gerätebaum hinzugefügt werden muss Für weitere Informationen siehe: Virtueller AntriebSMC_Logical_Axis Erstellt eine logische Achse, ohne dass diese zum Gerätebaum hinzugefügt werden muss. Für weitere Informationen siehe: Logischer AntriebSMC_FreeEncoder Erstellt eine Encoderachse, ohne dass diese zum Gerätebaum hinzugefügt werden muss Für weitere Informationen siehe: Freier Encoder" }, 
{ "title" : "Unterstützte Antriebe ", 
"url" : "_sm_drives_supported_drives.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Unterstützte Antriebe ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Unterstützte Antriebe EtherCAT ", 
"url" : "_sm_drives_supported_drives_ethercat.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Unterstützte Antriebe \/ Unterstützte Antriebe EtherCAT ", 
"snippet" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control...", 
"body" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control Techniques Mentor Control Techniques Unidrive M Copley Accelnet Danfoss ISD 520 Delta ASDA A2 Delta ASDA A3 Delta ASDA B3 Delta R1-EC5621 Festo CMMP EtherCAT Generischer CiA 402 Treiber: siehe Konfiguration der generischen CiA402-AchseGenerischer SoE Treiber (auch für mehrachsige Antriebe) Hitachi ADV series Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB H6 KEBA KeDrive D3 Kollmorgen AKD Kollmorgen AKD-N\/C Kollmorgen MKD-N\/C Kollmorgen AKD2G Kollmorgen KED Metronix ARS 2000-Serie Mitsubishi Melservo MR-J5 Mitsubishi Melservo MR-JET Omron G5 Panasonic MINAS A5B Panasonic MINAS A6B Panasonic MINAS A6 MultiDrive Parker compax3 Parker SBC Parker PSD Sanyo Denki RS2 Schneider Electric Lexium32 Schneider Electric Lexium32i Servotronix CDHD Stäubli uniVAL Stöber Posidrive Stöber SD6 Stöber SI6\/SC6 WEG SCA06 Yaskawa Sigma7 series " }, 
{ "title" : "Unterstützte Antriebe CAN ", 
"url" : "_sm_drives_supported_drives_can.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Unterstützte Antriebe \/ Unterstützte Antriebe CAN ", 
"snippet" : "CAN Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP Generischer CiA 402 Treiber: siehe Konfiguration der generischen CiA402-AchseInfranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schnei...", 
"body" : "CAN Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP Generischer CiA 402 Treiber: siehe Konfiguration der generischen CiA402-AchseInfranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schneider Electric Lexium05 Schneider Electric Lexium23 Schneider Electric Lexium28 Schneider Electric Lexium32 Schneider Electric Lexium32i Schneider Electric SD-3 " }, 
{ "title" : "Anwendungsfälle ", 
"url" : "_sm_f_use_cases_drive_control.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Anwendungsfälle ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Standardanwendungsfälle ", 
"url" : "_sm_special_use_cases.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Anwendungsfälle \/ Standardanwendungsfälle ", 
"snippet" : "Die Bibliothek SM3_Basic enthält übergeordnete Funktionsbausteine, die nicht über die standardmäßige Soll-\/Istwert-Schnittstelle mit dem Antrieb interagieren. Diese Bausteine geben Kommandos oder verändern die Einstellungen des Antriebs indem sie die Parameter der Instanz von AXIS_REF_SM3 lesen oder...", 
"body" : "Die Bibliothek SM3_Basic enthält übergeordnete Funktionsbausteine, die nicht über die standardmäßige Soll-\/Istwert-Schnittstelle mit dem Antrieb interagieren. Diese Bausteine geben Kommandos oder verändern die Einstellungen des Antriebs indem sie die Parameter der Instanz von AXIS_REF_SM3 lesen oder schreiben. " }, 
{ "title" : "Antrieb reinitalisieren ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_0e9f93f91e8d4c6dc0a8640e01d50c94", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Anwendungsfälle \/ Standardanwendungsfälle \/ Antrieb reinitalisieren ", 
"snippet" : "Wenn Sie die Antriebsparameter während der Laufzeit geändert haben, müssen Sie den Antrieb neu initialisieren. Beispiel: Ändern des Skalierungsfaktors oder die Moduloperiode von rotatorischen Antrieben. Durch Aufruf des Funktionsbausteins SMC3_ReinitDrive mit einer steigenden Flanke am Eingang Execu...", 
"body" : "Wenn Sie die Antriebsparameter während der Laufzeit geändert haben, müssen Sie den Antrieb neu initialisieren. Beispiel: Ändern des Skalierungsfaktors oder die Moduloperiode von rotatorischen Antrieben. Durch Aufruf des Funktionsbausteins SMC3_ReinitDrive mit einer steigenden Flanke am Eingang Execute wird der Parameter   wCommuncationState des Antriebs zurückgesetzt und der komplette Start-up-Prozess des Antriebs wiederholt. Warten Sie mit der Reinitialisierung, bis die Achse den erforderlichen Zustand SMC_COMSTATE_BASE_COM_INITIALIZATION oder höher erreicht hat. Andernfalls wird der Fehler SMC_RAG_ERROR_AXIS_NOT_INITIALIZED ausgegeben. Wenn die Kommunikation eines untergeordneten Feldbusses unterbrochen ist, dann ist ab CODESYS SoftMotion Version 4.18.0.0 keine explizite Reinitialisierung mehr notwendig. Die Achse wird automatisch neu initialisiert, sobald die Feldbuskommunikation wiederhergestellt wurde. Vor Version 4.18.0.0 war nach dem Kommunikationsabbruch des Feldbusses (Fehler mit SMC_DI_GENERAL_COMMUNICATION_ERROR) ein expliziter Aufruf von SMC3_ReinitDrive nötig, nachdem die Feldbuskommunikation wiederhergestellt war. Das alte Verhalten kann wiederhergestellt werden, indem der Eingang AutoRestart des Funktionsbausteins SMC_AxisChangeSettings auf SMC_AXIS_AUTORESTART_MODE.OFF gesetzt wird. " }, 
{ "title" : "Antrieb ein-\/abschalten ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_bd45abb41e8d4c6dc0a8640e01589872", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Anwendungsfälle \/ Standardanwendungsfälle \/ Antrieb ein-\/abschalten ", 
"snippet" : "Die Parameter bRegulatorOn und bDriveStart des Funktionsbausteins AXIS_REF_SM3 steuern die Leistungsstufe und das Abbremsen eines Antriebs. Der Zugriff erfolgt über den Funktionsbaustein MC_Power . Zur Freigabe der Endstufe müssen Sie den Parameter bRegulatorOn des Funktionsbausteins MC_Power setzen...", 
"body" : "Die Parameter bRegulatorOn und bDriveStart des Funktionsbausteins AXIS_REF_SM3 steuern die Leistungsstufe und das Abbremsen eines Antriebs. Der Zugriff erfolgt über den Funktionsbaustein MC_Power . Zur Freigabe der Endstufe müssen Sie den Parameter bRegulatorOn des Funktionsbausteins MC_Power setzen. Über den Ausgang bRegulatorRealState meldet der Antrieb den momentanen Status dieses Prozesses. Wenn es vom Antrieb unterstützt wird, setzt ein Reset von bRegulatorOn während einer Bewegung das Drehmoment mit sofortiger Wirkung außer Kraft. Der Funktionsbaustein meldet in diesem Fall einen Fehler und setzt die Achsen in den Zustand errorstop . Die Variable bDriveStart bestimmt, ob sich der Antrieb bewegen darf oder nicht. In bDriveStartRealState steht der aktuelle Zustand dieses Parameters. Wenn es vom Antrieb unterstützt wird,  führt ein Reset des Parameters bDriveStart während der Bewegung ein Abbremsen des Antriebs mit der konfigurierten Rampe durch (genannt „QuickStop“). Danach hält der Antrieb die erreichte Position solange, wie bRegulatorOn gesetzt bleibt. Die Achse bleibt im Zustand stopping , solange der „QuickStop-Mechanismus“ aktiv ist (Eingang bDriveStart = FALSE). Wenn der Antrieb zuvor von einem Funktionsbaustein bewegt wurde, zeigt dieser nun CommandAborted . Das gilt nicht für den Funktionsbaustein   MC_Stop , der einen Fehler meldet und die Achsen in den Zustand errorstop setzt. " }, 
{ "title" : "Mechanische Bremsen handhaben ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_6670a1571e8d4c6ec0a8640e01f5eecb", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Anwendungsfälle \/ Standardanwendungsfälle \/ Mechanische Bremsen handhaben ", 
"snippet" : "Wenn es vom Antrieb unterstützt wird, kann die Variable eBrakeControl mit Hilfe des Funktionsbausteins SMC3_BrakeControl gesetzt oder zurückgesetzt werden. Drei unterschiedliche Modi sind möglich. SMC3_BrakeSetState SMC_BRAKE_AUTO : Der Zustand der Bremse wird vom Antrieb selbst geregelt. SMC_BRAKE_...", 
"body" : "Wenn es vom Antrieb unterstützt wird, kann die Variable eBrakeControl mit Hilfe des Funktionsbausteins SMC3_BrakeControl gesetzt oder zurückgesetzt werden. Drei unterschiedliche Modi sind möglich. SMC3_BrakeSetState SMC_BRAKE_AUTO : Der Zustand der Bremse wird vom Antrieb selbst geregelt. SMC_BRAKE_OPEN : Die Bremse ist geöffnet. SMC_BRAKE_CLOSE : Die Bremse ist geschlossen. Die Variable bBrakeClosedRealState  meldet den aktuellen Status der Bremse. Vom SoftMotion -Standpunkt aus hängen Kontrolle wie auch Zustand der mechanischen Bremse weder vom Zustand des Antriebs noch von der laufenden Bewegung ab. " }, 
{ "title" : "Reglerbetriebsart wechseln ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_959f85271e8d4c6ec0a8640e01ed4fcb", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Anwendungsfälle \/ Standardanwendungsfälle \/ Reglerbetriebsart wechseln ", 
"snippet" : "Mit dem Funktionsbaustein SMC_SetControllerMode können Sie zwischen den verschiedenen Reglerbetriebsaraten wechseln. Die Parameter byControllerMode und byRealControllerMode von AXIS_REF_SM3 repräsentieren die gewünschte und die aktuelle Betriebsart des Reglers. Mögliche Werte SMC_nocontrol SoftMotio...", 
"body" : "Mit dem Funktionsbaustein SMC_SetControllerMode können Sie zwischen den verschiedenen Reglerbetriebsaraten wechseln. Die Parameter byControllerMode und byRealControllerMode von AXIS_REF_SM3 repräsentieren die gewünschte und die aktuelle Betriebsart des Reglers. Mögliche Werte SMC_nocontrol SoftMotion sendet keine zyklischen Daten zum Antrieb. Somit kann der Antrieb anderweitig gesteuert werden. SMC_torque Moment\/-Kraft-Regelung SMC_velocity Geschwindigkeitsregelung SMC_position , Lageregelung Nach Schreiben der Variablen byControllerMode  wird die aktuelle Betriebsart solange geprüft bis sie mit dem gewünschten Reglerbetriebsart übereinstimmt. Der Funktionsbaustein berechnet die Sollwerte, bis die neue Betriebsart vom Antrieb bestätigt wird. Sobald der Antrieb die neue Betriebsart bestätigt, wird der Ausgang bDone gesetzt und SMC_SetControllerMode schreibt die Sollwerte nicht mehr. Dies muss durch andere Funktionsbausteine erfolgen. Beispiel: Der Ausgang bDone ist mit dem Eingang Execute eines Funktionsbausteins wie MC_MoveVelocity , MC_MoveAbsolute oder MC_Halt verbunden. Andernfalls stoppt die Achse sofort nach dem Wechsel der Betriebsart. Beachten Sie, dass die Totzeit zur Berechnung der Sollposition verwendet wird. Für weitere Informationen siehe Istwerte, Sollwerte und Totzeit. " }, 
{ "title" : "Referenzfahrt (antriebsgesteuert) ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_7fa66d251e8d4c6fc0a8640e00782f3b", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Anwendungsfälle \/ Standardanwendungsfälle \/ Referenzfahrt (antriebsgesteuert) ", 
"snippet" : "Sie können in SoftMotion einen Antrieb auf zwei Arten referenzieren: Referenzierung über Regelung in der SPS: Diese Referenzierung wird durch Aufruf des Funktionbausteins   SMC_Homing ausgeführt. Dabei muss das Referenzsignal Teil des E\/A-Abbilds des Reglers sein. Während des Referenzierens bleibt d...", 
"body" : "Sie können in SoftMotion einen Antrieb auf zwei Arten referenzieren: Referenzierung über Regelung in der SPS: Diese Referenzierung wird durch Aufruf des Funktionbausteins   SMC_Homing ausgeführt. Dabei muss das Referenzsignal Teil des E\/A-Abbilds des Reglers sein. Während des Referenzierens bleibt der Antrieb im Kontrollmodus „Lageregelung“. Im Allgemeinen ist diese Methode nicht so genau, da die Erfassung der Position (beim Berühren des Referenzschalter) auf den vom Antrieb erhaltenen aktuellen Positionen basiert; folglich ist die Genauigkeit durch den Kommunikationszyklus beschränkt. Referenzierung über Regelung im Antrieb: Dabei ist der Referenzschalter zum Antrieb selbst verdrahtet. Dadurch wird seine Position schneller und mit höherer Genauigkeit ausgewertet. Während des antriebsgesteuerten Referenzpfads ist der Antrieb in einem anderen Kontrollmodus, in dem er nicht die Sollwerte des Reglers befolgt, sondern durch interne Prozesse gesteuert wird. Sobald der Referenzpfad beendet wird, wird der Antrieb in seinen ursprünglichen Kontrollmodus zurückversetzt. Der Funktionsbaustein MC_Home startet den antriebsgesteuerten Referenzpfad durch Setzen von fReference und bStartReference . Zusätzlich wird der Zustand von AXIS_REF_SM3 ( wState ) auf   homing gesetzt. Sobald der Antrieb in den Referenzpfad übergeht (das heißt, dass er die vom Regler vorgegebenen Werte nicht mehr beachtet), setzt der Antrieb den Parameter auf   TRUE . Um das Ende des Referenzpfads anzuzeigen, setzt der Treiber die Werte von bStartReference und bStartReferenceRealState wiederum auf   FALSE . " }, 
{ "title" : "Positionserfassung ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_index_14", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Anwendungsfälle \/ Standardanwendungsfälle \/ Positionserfassung ", 
"snippet" : "Abhängig davon, welche Funktionen der Antrieb zur Positionsermittlung der Antrieb unterstützt, kann die Position einer Achse auf mehrere Arten ermittelt werden: Der Antrieb ermittelt die Achsposition selbst (integriert oder durch Anschaltung eines externen Gebers). Da die Istposition dabei vom Antri...", 
"body" : "Abhängig davon, welche Funktionen der Antrieb zur Positionsermittlung der Antrieb unterstützt, kann die Position einer Achse auf mehrere Arten ermittelt werden: Der Antrieb ermittelt die Achsposition selbst (integriert oder durch Anschaltung eines externen Gebers). Da die Istposition dabei vom Antrieb selbst übertragen wird, ist die Übertragungszeit des Signals minimal und somit präzise. Die aktuelle Position der Achse wird unabhängig vom Antrieb erfasst und über einen Eingang der Steuerung übertragen. Dabei auftretende Latenzzeit des Steuerungseingangs und des Applikationszyklus machen diese Methode weniger präzise. Wenn die Position vom Antrieb selbst übertragen wird, wird sie in der Applikation typischerweise vom zugehörigen Treiber herstellerspezifisch direkt verarbeitet. Um die Position einer solchen Achse zu ermitteln, können Sie den Funktionsbaustein MC_TouchProbe verwenden. Er ermöglicht die Aufzeichnung der Achsposition zu einem konfigurierbaren Trigger und innerhalb eines Positionsfensters. Wenn die Position nicht durch den Antrieb übertragen wird, muss sie dem Antriebstreiber beispielsweise zur Regelung übergeben werden. Für weitere Informationen siehe: Lageregelung auf der Steuerung mit SM_Drive_PosControl" }, 
{ "title" : "Achsposition persistieren ", 
"url" : "_sm_storing_axis_position_persistently.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Anwendungsfälle \/ Achsposition persistieren ", 
"snippet" : "Eine Achse, die über einen Absolutgeber verfügt, kann eine Position speichern, so dass sie nach einem Neustart der Steuerung ihre vorige Position behält. Eine Referenzfahrt wird unnötig. Die Funktionsbausteine SMC3_PersistPosition und SMC3_PersistPositionLogical bieten die Funktionalität zur Speiche...", 
"body" : "Eine Achse, die über einen Absolutgeber verfügt, kann eine Position speichern, so dass sie nach einem Neustart der Steuerung ihre vorige Position behält. Eine Referenzfahrt wird unnötig. Die Funktionsbausteine SMC3_PersistPosition und SMC3_PersistPositionLogical bieten die Funktionalität zur Speicherung. Die nötigen Daten werden in SMC3_PersistPosition_Data und SMC3_PersistPositionLogical_Data gespeichert. Der Ausgang bPositionStored zeigt an, ob sich der Inhalt von PersistentData geändert hat. Je nach Art des Persistierens geschieht dies unterschiedlich häufig. Der vom Encoder persistierte Wertebereich muss am Eingang SMC_PersistPosition.maxPersistedValue konfiguriert werden. Für Multi-Turn-Encoder wird der Wert auf 16#FFFFFFFF gesetzt, für einen 12-Bit-Single-Turn-Encoder beispielsweise auf den Wert 2^12 = 4096. Für weitere Informationen siehe: Datenpersistenz Die Persistierung der Instanz erfolgt über eine Deklaration als VAR_PERSISTENT oder über den Persistence Managers des Application Composers. Achsposition einer logischer Achse persistieren Voraussetzung: Die Achse ist logisch. Verwenden Sie den Funktionsbaustein SMC3_PersistPositionLogical um die Position der logischen Achse zu persistieren. Das funktioniert nur, wenn die Position der übergeordneten realen Achse persistiert wurde. Die Position einer virtuellen Achse kann mit diesem Bausteinen nicht persistiert werden. Legen Sie eine Instanz des Funktionsbausteins SMC3_PersistPositionLogical für die Achse an. ppl: SM3_BASIC.SMC3_PersistPositionLogical; Instanzieren Sie eine persistente Datenstruktur des Typs SMC3_PersistPositionLogical_Data . ppl_Data: SMC3_PersistPositionLogical_Data; Erweitern Sie das Programm der Motion-Task so, dass dort ein Aufruf der SMC3_PersistPositionLogical -Instanz implementiert ist und ihr die persistenten Daten vom Typ SMC3_PersistPositionLogical_Data übergeben werden. " }, 
{ "title" : "Achsposition eines Multiturn-Absolutgebers mit realer Achse persistieren ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_49c53944c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Anwendungsfälle \/ Achsposition persistieren \/ Achsposition eines Multiturn-Absolutgebers mit realer Achse persistieren ", 
"snippet" : "Voraussetzung: Die Achse verfügt über einen Multiturn-Absolutgeber. Verwenden Sie den Baustein SMC3_PersistPosition um die Position der realen Achse zu persistieren. Das zugehörige Programm läuft in der Motion-Task. Legen Sie eine Instanz des Funktionsbausteins SMC3_PersistPosition für die Achse an....", 
"body" : "Voraussetzung: Die Achse verfügt über einen Multiturn-Absolutgeber. Verwenden Sie den Baustein SMC3_PersistPosition um die Position der realen Achse zu persistieren. Das zugehörige Programm läuft in der Motion-Task. Legen Sie eine Instanz des Funktionsbausteins SMC3_PersistPosition für die Achse an. pp: SM3_BASIC.SMC3_PersistPosition; Instanzieren Sie eine persistente Datenstruktur des Typs SMC3_PersistPosition_Data . pp_Data: SM3_BASIC.SMC3_PersistPosition_Data1; Erweitern Sie das Programm der Motion-Task so, dass dort ein Aufruf der SMC3_PersistPosition -Instanz implementiert ist. Aufruf implementiert in CFC: Der Funktionsbaustein wird zyklisch mit der Motion-Task aufgerufen. Die SMC3_PersistPosition -Instanz führt während des Start-up-Vorgangs das Wiederherstellen der gespeicherten Position durch. Der Baustein speichert im Normalbetrieb die Istposition in die zugehörige Datenstruktur ab. " }, 
{ "title" : "Achsposition eines Singleturn-Absolutgebers mit realen Achse persistieren ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_a4cc9967c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Anwendungsfälle \/ Achsposition persistieren \/ Achsposition eines Singleturn-Absolutgebers mit realen Achse persistieren ", 
"snippet" : "Voraussetzung: Die reale Achse verfügt über einen Singleturn-Absolutgeber. Verwenden Sie den Funktionsbaustein SMC3_PersistPosition um die Position der Achse zu persistieren. Das zugehörige Programm läuft in der Motion-Task. Die Position wird nur dann korrekt angezeigt, wenn die Achse zwischen Aus- ...", 
"body" : "Voraussetzung: Die reale Achse verfügt über einen Singleturn-Absolutgeber. Verwenden Sie den Funktionsbaustein SMC3_PersistPosition um die Position der Achse zu persistieren. Das zugehörige Programm läuft in der Motion-Task. Die Position wird nur dann korrekt angezeigt, wenn die Achse zwischen Aus- und Einschalten der Steuerung keine oder nur eine kleine Distanz zurückgelegt hat (maximal die Hälfte der Singleturn-Distanz). Um das erreichen, können Sie beispielsweise eine mechanische Bremse verwenden. Wenn die Achse bei ausgeschalteter Steuerung eine größere Bewegung macht, erhält sie eine falsche Position. Eine Überprüfung durch den Baustein ist nicht möglich. Legen Sie eine Instanz des Funktionsbausteins SMC3_PersistPosition für die Achse an. ppst_X: SM3_BASIC.SMC3_PersistPositionSinglturn; Instanzieren Sie eine persistente Datenstruktur des Typs SMC3_PersistPosition_Data . ppst_Data_X: SMC3_PersistPositionSingleturn_Data; Erweitern Sie das Programm der Motion-Task so, dass dort ein Aufruf der SMC3_PersistPosition -Instanz implementiert ist und ihr die persistente Datenstruktur vom Typ SMC_PersistPosition_Data übergeben wird. " }, 
{ "title" : "Initiale Positionsbestimmung einer Modulo-Achse ", 
"url" : "_sm_initial_positioning_of_a_rotary_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Anwendungsfälle \/ Initiale Positionsbestimmung einer Modulo-Achse ", 
"snippet" : "Die Istposition eines Antriebs oder Encoders wird als DWORD zur Steuerung übertragen. Bei einer Modulo-Achse wird die Periode P in Inkrementen durch den Modulowert und die Skalierung bestimmt. Die Periode P gibt an, wie viele Inkremente genau eine Umdrehung ergeben. Das bedeutet, dass die Positionsw...", 
"body" : "Die Istposition eines Antriebs oder Encoders wird als DWORD zur Steuerung übertragen. Bei einer Modulo-Achse wird die Periode P in Inkrementen durch den Modulowert und die Skalierung bestimmt. Die Periode P gibt an, wie viele Inkremente genau eine Umdrehung ergeben. Das bedeutet, dass die Positionswerte X, X+1*P, X+2*P, etc. die gleiche physikalische Position beschreiben. Die Position X+n*P überschreitet die Grenze des DWORDs, wenn n genügend groß ist. Das passiert bei der Position 0x1 00 00 00 00. Dabei wird die führende Stelle abgeschnitten und der Wert beginnt wieder bei 0 . Wenn P kein Teiler von 0x1 00 00 00 00 ist, beschreibt die Position X vor und nach dem Umbruch nicht mehr die gleiche physikalische Position. Wenn die Getriebeverhältnisse so sind, dass die Periode kein Teiler von 0x1 0000 0000 ist, kann die Position einer Rundachse nach dem Einschalten verschoben sein. Beispiel Die Achse startet bei Position 0x0 . Sie steht auf 0°. Eine Periode ist 360° lang. Die Skalierung ist so gewählt, dass das 3600000 = 0x36 EE80 Inkrementen entspricht. Nach 1193 Umdrehungen steht die Achse auf 0xFFFD 7280=1193*3600000 . Nach einer weiteren vollen Umdrehung erreicht die Achse die Position 0x10034 6100 . Beim Umbruch wird die führende 1 abgeschnitten und es entsteht die Position 0x34 6100 . Wenn Sie die Achse zurück auf die Position 0x0 bewegen, steht die Achse bei Position 16,7296°. Die Position 0x0 entspricht also je nach stattgefundenem Umbruch der Position 0°, 16.7296°, etc. Wenn Sie die Skalierung so gewählt haben, dass der oben beschriebene Effekt auftreten kann, und wenn eine Referenzfahrt am Start des Programms nicht möglich oder nicht gewünscht ist, dann können Sie mit Hilfe des Bausteins SMC3_PersistPosition die Position vor dem letzten Ausschalten wiederherstellen. Verwenden Sie dabei einen Absolutwertegeber. " }, 
{ "title" : "CiA402 Achsen ", 
"url" : "_sm_cia402_axes.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ CiA402 Achsen ", 
"snippet" : "Für weitere Informationen siehe SoftMotion...", 
"body" : "Für weitere Informationen siehe SoftMotion" }, 
{ "title" : "Konfiguration der generischen CiA402-Achse ", 
"url" : "_sm_drives_generic_cia402_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ CiA402 Achsen \/ Konfiguration der generischen CiA402-Achse ", 
"snippet" : "CODESYS SoftMotion stellt Antriebstreiber für verschiedene Antriebe bereit. Falls für Ihren verwendeten CiA402-Antrieb kein spezifischer Treiber verfügbar ist, können Sie die generische CiA402-Achse nutzen. Die Kompatibilität und das Verhalten der generischen Achse hängen jedoch maßgeblich von der C...", 
"body" : "CODESYS SoftMotion stellt Antriebstreiber für verschiedene Antriebe bereit. Falls für Ihren verwendeten CiA402-Antrieb kein spezifischer Treiber verfügbar ist, können Sie die generische CiA402-Achse nutzen. Die Kompatibilität und das Verhalten der generischen Achse hängen jedoch maßgeblich von der CiA402-Implementierung im jeweiligen Antrieb ab. In der Praxis hat sich gezeigt, dass verschiedene Hersteller den CiA402-Standard unterschiedlich auslegen – insbesondere im Hinblick auf die Fehlerbehandlung und die Unterstützung von Endschaltern. Daher kann nicht garantiert werden, dass die generische CiA402-Achse in jedem Fall korrekt oder vollständig mit einem bestimmten Antrieb funktioniert. Der generische CiA402-Treiber unterstützt bis zu 8 Achsen, falls die Gerätebeschreibung des Antriebs keine Anzahl vorgibt. Andernfalls wird die in der Gerätebeschreibung definierte Anzahl von Achsen unterstützt. CANopen : Die Anzahl der möglichen Achsen hängt von den Profilen der logischen Geräte in der EDS-Datei ab (Objekt 1000H  und 67FFH + X * 800H , X = Nummer des logischen Geräts). Weitere Details finden Sie in der Norm CANopen CiA301. EtherCAT : Die Anzahl der möglichen Achsen hängt von den definierten CiA402-Kanälen (CoE DS402Channels) in der ESI-Datei ab. Eine Anpassung der EDS- oder ESI-Datei muss durch den Gerätehersteller erfolgen. " }, 
{ "title" : "Verwendete Objekte während der Inbetriebnahme ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e06c925bc32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ CiA402 Achsen \/ Konfiguration der generischen CiA402-Achse \/ Verwendete Objekte während der Inbetriebnahme ", 
"snippet" : "Während der Inbetriebnahme wird auf folgende Objekte zugegriffen, wenn dies vom Gerät unterstützt wird. Objekt Lese-\/Schreibzugriff (M)andatory: verpflichtend\/ (O)ptional Kommentar 0x1000:0 lesen M Das niederwertige Wort muss 402 sein. Ansonsten Abbruch. 0x1018:1 lesen O 0x1018:2 lesen O 0x1018:3 le...", 
"body" : "Während der Inbetriebnahme wird auf folgende Objekte zugegriffen, wenn dies vom Gerät unterstützt wird. Objekt Lese-\/Schreibzugriff (M)andatory: verpflichtend\/ (O)ptional Kommentar 0x1000:0 lesen M Das niederwertige Wort muss 402 sein. Ansonsten Abbruch. 0x1018:1 lesen O 0x1018:2 lesen O 0x1018:3 lesen O 0x1018:4 lesen O 0x6502:0 lesen O 0x605A:0 lesen O 0x60C2:1 schreiben Wenn Parameter Set60C2 = TRUE 0x60C2:2 schreiben Wenn Parameter Set60C2 = TRUE 0x6076:0 lesen O " }, 
{ "title" : "Verwendete Objekte während des Betriebs ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7dfc492c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ CiA402 Achsen \/ Konfiguration der generischen CiA402-Achse \/ Verwendete Objekte während des Betriebs ", 
"snippet" : "Die folgenden Objekte werden abhängig von den verwendeten Funktionen während des Betriebs verwendet: 0x603F:00 , 0x6040:00 , 0x6041:00 , 0x6060:00 , 0x6061:00 , 0x6062:00 , 0x6064:00 , 0x606B:00 , 0x606C:00 , 0x6074:00 , 0x6077:00 , 0x6078:00 , 0x607C:00 , 0x60B1:00 , 0x60B2:00, 0x60B8:00 0x60B9:00 ...", 
"body" : "Die folgenden Objekte werden abhängig von den verwendeten Funktionen während des Betriebs verwendet: 0x603F:00 , 0x6040:00 , 0x6041:00 , 0x6060:00 , 0x6061:00 , 0x6062:00 , 0x6064:00 , 0x606B:00 , 0x606C:00 , 0x6074:00 , 0x6077:00 , 0x6078:00 , 0x607C:00 , 0x60B1:00 , 0x60B2:00, 0x60B8:00 0x60B9:00 , 0x60BA:00 , 0x60BB:00 , 0x60BC:00 , 0x60BD:00 , 0x60F4:00 . " }, 
{ "title" : "Erweiterte Konfiguration ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7e012b4c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ CiA402 Achsen \/ Konfiguration der generischen CiA402-Achse \/ Erweiterte Konfiguration ", 
"snippet" : "Sie müssen die Option Generische Konfigurationseditoren anzeigen im Dialog: Optionen: Geräteeditor aktivieren, damit die Registerkarte mit den Parametern angezeigt wird. Sie können mit folgenden Parametern den Ablauf des CiA402-Zustandsautomaten detailliert beeinflussen. CiA402 Parameter Beschreibun...", 
"body" : "Sie müssen die Option Generische Konfigurationseditoren anzeigen im Dialog: Optionen: Geräteeditor aktivieren, damit die Registerkarte mit den Parametern angezeigt wird. Sie können mit folgenden Parametern den Ablauf des CiA402-Zustandsautomaten detailliert beeinflussen. CiA402 Parameter Beschreibung _readVelocityFactor_6096 TRUE : Der Geschwindigkeitsfaktor (Objekt 6096 ) wird gelesen und für die Umrechnung der Geschwindigkeitseinheiten verwendet. FALSE : Der Geschwindigkeitsfaktor wird nicht gelesen. Die Geschwindigkeitseinheit wird als Inkremente pro Sekunde angenommen. _bImmediateDisabling TRUE : Schaltet den Status des Antriebss von Operation enabled direkt nach Switch on disabled , wenn bRegulator auf FALSE zurückgesetzt wird. FALSE : Schaltet den Status über \"Eingeschaltet\" und \"Einschaltbereit\", um dem Antrieb die Möglichkeit zu geben, einen Schnellstopp durchzuführen und die Bremse richtig zu bedienen. Hinweis: Ist diese Option auf FALSE gesetzt, können die Zustände, für die die sofortige Deaktivierung ausgeschaltet wird, mit der Bit-Maskierung _dwStatesImmediateDisabling feinabgestimmt werden. _bForbidReenableDuringDisabling Nur relevant, wenn _bImmediateDisabling = FALSE. TRUE : Antrieb wird Schritt für Schritt deaktiviert bis das Antriebssignal in Ready to switch on ist. dwStatesImmediateDisabling Nur relevant when _bImmediateDisabling = FALSE . Bit-Maskierung der Zustände, für die die sofortige Deaktivierung eingeschaltet ist: Bit 0: Normale Operation Bit 1: Schnellhalt Bit 2: Externer Schnellhalt Bit 3: Referenzfahrt Beispiel: Wenn _bImmediateDisabling = FALSE , bedeutet der Wert 2#0110 , dass nur für die Zustände \"Normale Operation\" und \"Referenzfahrt\" die sofortige Deaktivierung ausgeschaltet ist. Für die Zustände \"Schnellhalt\" und \"Externer Schnellhalt\" ist die sofortige Deaktivierung eingeschaltet. _uiPreHomingWait Anzahl der Zyklen, die im Zustand PRE_HOMING gewartet werden, bevor die Referenzfahrt mit Setzen von Bit 4 des Steuerworts gestartet wird. _uiPostHomingWait Anzahl der Zyklen, die die Zustandsmaschine im Zustand HOMING_DONE wartet, bevor sie in \"Normale Operation\" zurückschaltet. _uiHomingMinCycles Anzahl der Zyklen zu Beginn von HOMING , wobei die „erledigt“-Bits (Bit 10\/12 des Statusworts) ignoriert werden. _uiWaitCyclesForStateSwitch Anzahl der Zyklen, die das System wartet, bis der Antrieb einen Befehl zur Zustandsänderung ausgeführt hat. Wenn der Antrieb fehlschlägt, schaltet das System zurück auf SWITCH_ON_DISABLED . _bPreHomingWaitBit12Clear TRUE : Warten in PRE_HOMING bis Bit 12 des Statuswort vom Antrieb gelöscht wurde, bevor die Referenzfahrt gestartet wird (bevor Bit 4 des Steuerworts gesetzt wird). Beachten Sie, dass der Zustandsmaschine in jedem Fall mindestens _uiPreHomingCycles lang im Zustand PRE_HOMING bleibt. _bCheckBit10PostHoming TRUE : Wenn Bit 12 und Bit 10 des Statuswort TRUE sind, wird auf HOMING_DONE geschaltet (wie in der CiA-402 spezifiziert). FALSE : Bit 10 wird ignoriert, nur Bit 12 wird verwendet. _bCheckOpMode TRUE : Überprüfen, ob 0x6061 den Wert hat, der in 0x6060 gesetzt ist, wenn die Achse freigegeben wird. FALSE : Diese Prüfung auslassen und sofort nach Setzen der Betriebsart aktivieren. _abyControllerMode Dieses ARRAY[0..7] OF BYTE enthält die Betriebsarten (Objekt 0x6060 ), die mit AXIS_REF_SM3.byOperationMode übereinstimmen. (Index 0,3 = Position, Index 1 = Geschwindigkeit, Index 2 = Drehmoment _bCheckBit12InPositionMode TRUE : AxisIsReadyForMotion überprüft Bit 12 in CSP oder IP. FALSE : AxisIsReadyForMotion überprüft Bit 12 nicht. _bDoHaltWhenStopInterruptsHome TRUE : bei Unterbrechung von MC_Stop , Abbruch der Referenzfahrt mit Bit 8 des Steuerworts FALSE : Bit 8 nicht setzen, sondern direkt die Betriebsart umschalten _bCheckBit13InHomingMode TRUE : in HOMING_ACTIVE , wStatusWord.13 = TRUE führt zu einem Fehlerstopp und wControlWord.8 := TRUE (abhängig von _bDoHaltWhenStopInterruptsHome ) _bSetControlBit4InCSP TRUE : Setzt Bit 4 des Statusworts auch in CSP-Mode. Einige Antriebe erfordern dies, obwohl es nicht standard ist. _uiHomingWaitListeningBits101213 Im Zustand HOMING_ACTIVE dürfen nach dem Setzen von Bit 4 während dieser Anzahl von Zyklen die Bits 10, 12 und 13 nicht abgehört werden. (Einige Antriebe brauchen etwas Zeit, um diese Bits zurückzusetzen). _bRegulatorOnRequiresVoltageEnabled Legt fest, ob Bit 4 des Statusworts (Spannung freigegeben) TRUE sein muss, damit bRegulatorRealState = TRUE wird (Standardwert: FALSE ). _bDriveStartRequiresOperationEnabled Legt fest, ob Bit 2 des Statusworts (Betrieb freigegeben) TRUE sein muss, damit bDriveStartRealState = TRUE wird (Standardwert: TRUE ). _modeOfOperation_Torque Der ModeOfOperation , der für den Controller-Mode torque verwendet wird. Muss sich wie der Cyclic Sync Torque-Modus verhalten. _modeOfOperation_Velocity Der ModeOfOperation , der für den Controller-Mode velocity verwendet wird. Muss sich wie der Cyclic Sync Velocity-Modus verhalten. _modeOfOperation_Position Der ModeOfOperation , der für den Controller-Mode position verwendet wird. Muss sich wie der Cyclic Sync Position-Modus verhalten. _bStayInSwitchOnDisabled FALSE : Es wird ein automatischer Wechsel von SWITCH_ON_DISABLED zu READY_TO_SWITCH_ON durchgeführt, wenn entweder MC_Power.bDriveStart TRUE ist oder der Code für die Schnellstopp-Option ( Objekt 0x605A:00 ) > 4 ist. TRUE: Der Wechsel von SWITCH_ON_DISABLED zu READY_TO_SWITCH_ON erfolgt nur, wenn MC_Power.bRegulatorOn TRUE is t. " }, 
{ "title" : "Touch Probe ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087437140543", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ CiA402 Achsen \/ Konfiguration der generischen CiA402-Achse \/ Touch Probe ", 
"snippet" : "Der Funktionsbaustein MC_TouchProbe benötigt eine TRIGGER_REF als Eingang. TRIGGER_REF.iTriggerNumber hat bei der generischen CiA402-Achse folgende Bedeutung: TRIGGER_REF.iTriggerNumber Bedeutung 0 Touch Probe 1, positive Flanke 1 Touch Probe 1, negative Flanke 2 Touch Probe 2, positive Flanke 3 Tou...", 
"body" : "Der Funktionsbaustein MC_TouchProbe benötigt eine TRIGGER_REF als Eingang. TRIGGER_REF.iTriggerNumber hat bei der generischen CiA402-Achse folgende Bedeutung: TRIGGER_REF.iTriggerNumber Bedeutung 0 Touch Probe 1, positive Flanke 1 Touch Probe 1, negative Flanke 2 Touch Probe 2, positive Flanke 3 Touch Probe 2, negative Flanke " }, 
{ "title" : "Fehlerdiagnose: Antrieb lässt sich nicht über MC_Power einschalten ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087440495495", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ CiA402 Achsen \/ Konfiguration der generischen CiA402-Achse \/ Fehlerdiagnose: Antrieb lässt sich nicht über MC_Power einschalten ", 
"snippet" : "Die generische Achse erwartet folgende Bits im Statuswort, um MC_Power.Status = TRUE zurückzugeben: Bit 0 (ready to switch on) Bit 1 (switched on) Bit 2 (operation enabled) Bit 5 (quick stop) Bit 12 Bit 12 wird jedoch nicht von jedem Antrieb gesetzt. Wenn der Antrieb das Bit nicht setzt, kann der Pa...", 
"body" : "Die generische Achse erwartet folgende Bits im Statuswort, um MC_Power.Status = TRUE zurückzugeben: Bit 0 (ready to switch on) Bit 1 (switched on) Bit 2 (operation enabled) Bit 5 (quick stop) Bit 12 Bit 12 wird jedoch nicht von jedem Antrieb gesetzt. Wenn der Antrieb das Bit nicht setzt, kann der Parameter _bCheckBit12InPositionMode der generischen Achse auf FALSE gesetzt werden. " }, 
{ "title" : "Touch Probe ", 
"url" : "_sm_touch_probe.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ CiA402 Achsen \/ Touch Probe ", 
"snippet" : "Antriebe mit CiA402-Profil unterstützen zum Teil die Auswahl der Touch Probe-Quelle. Über den Funktionsbaustein MC_TouchProbe ist es nicht möglich, die Quelle einzustellen. Standardmäßig wird der zum Touch Probe gehörende digitale Eingang verwendet. Ändern der Quelle: Manuelles Schreiben des Touch P...", 
"body" : "Antriebe mit CiA402-Profil unterstützen zum Teil die Auswahl der Touch Probe-Quelle. Über den Funktionsbaustein MC_TouchProbe ist es nicht möglich, die Quelle einzustellen. Standardmäßig wird der zum Touch Probe gehörende digitale Eingang verwendet. Ändern der Quelle: Manuelles Schreiben des Touch Probe Objekts 0x60B8 Hierfür müssen Sie den Funktionsbaustein MC_WriteParameter mit ParameterNumber = 10184 aufrufen. Dies entspricht dem CiA 402-Objekt 0x60B8 . Wenn der Ausgang MC_WriteParameter.Done = TRUE meldet, können Sie den Funktionsbaustein MC_TouchProbe wie gewohnt kommandieren. Von Objekt 0x60B8 werden nur noch die Bits gesetzt, die durch MC_TouchProbe vorgegeben werden können (gekennzeichnet durch ). Die restlichen Bits behalten den Wert von Schritt 1 (gekennzeichnet durch ): Bits von Objekt 0x60B8 Touch Probe 2 Touch Probe 1 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 Hinweis zum Objekt 0x60D0 Im Touch Probe-Objekt 0x60B8 können Sie die Quelle so angeben, dass diese über das Objekt 0x60D0 aufgelöst wird. Dies entspricht der Bit-Kombination 10 b für die Bits 3 , 2 oder 11 , 10 vom Objekt 0x60B8 . In diesem Fall müssen Sie vor der Ausführung von MC_TouchProbe das Objekt 0x60D0 schreiben. Hierfür müssen Sie den Funktionsbaustein  MC_WriteParameter verwenden, wobei die ParameterNumber über die Funktion  SMC_ParameterNumber_CoE berechnet wird. " }, 
{ "title" : "Istwerte, Sollwerte und Totzeit ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Istwerte, Sollwerte und Totzeit ", 
"snippet" : "Diese Seite beantwortet die Frage, wann die Ist- und Sollwerte empfangen und gesendet werden und wie sie mit der Totzeit zusammenhängen. Der Einfachheit halber konzentrieren wir uns auf die Position, aber das Gleiche gilt auch für andere Werte wie die Geschwindigkeit oder das Drehmoment. Wir betrach...", 
"body" : "Diese Seite beantwortet die Frage, wann die Ist- und Sollwerte empfangen und gesendet werden und wie sie mit der Totzeit zusammenhängen. Der Einfachheit halber konzentrieren wir uns auf die Position, aber das Gleiche gilt auch für andere Werte wie die Geschwindigkeit oder das Drehmoment. Wir betrachten das Verhalten für EtherCAT, für andere Feldbusse ist das Verhalten ähnlich. (Beachten Sie, dass wir die standardmäßige und empfohlene Konfiguration mit FrameAtTaskStart = TRUE annehmen). " }, 
{ "title" : "Wann werden die Istwerte empfangen? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054861776368", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Istwerte, Sollwerte und Totzeit \/ Wann werden die Istwerte empfangen? ", 
"snippet" : "Die Istposition ( <DriveA>.fActPosition ) wird zu Beginn des aktuellen Bustaskzyklus empfangen. Sie ist die Position des Antriebs zum Zeitpunkt des vorherigen EtherCAT SYNC-Ereignisses. Im Bustaskzyklus i wird der EtherCAT-Frame empfangen, der im vorherigen Bustaskzyklus i-1 gesendet wurde. Dieser F...", 
"body" : "Die Istposition ( <DriveA>.fActPosition ) wird zu Beginn des aktuellen Bustaskzyklus empfangen. Sie ist die Position des Antriebs zum Zeitpunkt des vorherigen EtherCAT SYNC-Ereignisses. Im Bustaskzyklus i wird der EtherCAT-Frame empfangen, der im vorherigen Bustaskzyklus i-1 gesendet wurde. Dieser Frame enthält die Istposition, die vom Antrieb beim SYNC-Ereignis i-2 gelatcht wurde. " }, 
{ "title" : "Wann werden die Sollwerte gesendet? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862001312", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Istwerte, Sollwerte und Totzeit \/ Wann werden die Sollwerte gesendet? ", 
"snippet" : "Die im aktuellen Bustaskzyklus i errechneten Sollwerte werden im folgenden Bustaskzyklus i+1 an den Antrieb gesendet und vom Antrieb beim SYNC-Ereignis i+1 übernommen. Siehe obiges Diagramm....", 
"body" : "Die im aktuellen Bustaskzyklus i errechneten Sollwerte werden im folgenden Bustaskzyklus i+1 an den Antrieb gesendet und vom Antrieb beim SYNC-Ereignis i+1 übernommen. Siehe obiges Diagramm. " }, 
{ "title" : "Was ist die Totzeit, wie wird sie ermittelt, wie wird sie genutzt? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862210917", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Istwerte, Sollwerte und Totzeit \/ Was ist die Totzeit, wie wird sie ermittelt, wie wird sie genutzt? ", 
"snippet" : "Generell ist die Totzeit immer dann wichtig, wenn es notwendig ist, eine Aktion genau dann durchzuführen, wenn der Antrieb eine Position erreicht. Weiterhin ist die Totzeit wichtig, wenn die Antriebsposition zu einem bestimmten Zeitpunkt genau bestimmt werden muss. Beispiele hierfür sind das Auftrag...", 
"body" : "Generell ist die Totzeit immer dann wichtig, wenn es notwendig ist, eine Aktion genau dann durchzuführen, wenn der Antrieb eine Position erreicht. Weiterhin ist die Totzeit wichtig, wenn die Antriebsposition zu einem bestimmten Zeitpunkt genau bestimmt werden muss. Beispiele hierfür sind das Auftragen von Klebstoff mit hoher Geschwindigkeit oder das Ausführen von Messtastern in der SPS mit hochpräzisen digitalen Eingängen, die an die SPS angeschlossen sind. " }, 
{ "title" : "Definition der Totzeit ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862962511", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Istwerte, Sollwerte und Totzeit \/ Was ist die Totzeit, wie wird sie ermittelt, wie wird sie genutzt? \/ Definition der Totzeit ", 
"snippet" : "Die Totzeit ist die Zeit, die der Antrieb benötigt, um die von der SPS gesendete Sollposition tatsächlich zu erreichen. Das heißt, die Totzeit ist die Zeitspanne zwischen der fActPosition und der fSetPosition zu Beginn des aktuellen Bustaskzyklus. Die Totzeit kann im allgemeinen Antriebseditor ( Reg...", 
"body" : "Die Totzeit ist die Zeit, die der Antrieb benötigt, um die von der SPS gesendete Sollposition tatsächlich zu erreichen. Das heißt, die Totzeit ist die Zeitspanne zwischen der fActPosition und der fSetPosition zu Beginn des aktuellen Bustaskzyklus. Die Totzeit kann im allgemeinen Antriebseditor ( Registerkarte: Allgemein) oder über den Funktionsbaustein MC_WriteParameter mit der Parameternummer 1070 ( fSetActTimeLagCycles ) konfiguriert werden. Die Totzeit ist die Summe der folgenden Zeiten: Die Zeit, die benötigt wird, um die Sollposition an den Antrieb zu senden Die Zeit, die der Antriebsregler benötigt, um die Sollposition zu erreichen Die Zeit, die benötigt wird, um die Istposition vom Antrieb zu erhalten. " }, 
{ "title" : "Abschätzung der Totzeit ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054864599382", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Istwerte, Sollwerte und Totzeit \/ Was ist die Totzeit, wie wird sie ermittelt, wie wird sie genutzt? \/ Abschätzung der Totzeit ", 
"snippet" : "Die Totzeit kann mit dem Funktionsbaustein SMC_EstimateDeadTime geschätzt werden. Der Antrieb sollte mit konstanter Geschwindigkeit bewegt werden, und es sollte der Median oder Durchschnitt mehrerer Totzeitmessungen verwendet werden. Alternativ kann die Totzeit auch mit Hilfe des Trace-Editors gesch...", 
"body" : "Die Totzeit kann mit dem Funktionsbaustein SMC_EstimateDeadTime geschätzt werden. Der Antrieb sollte mit konstanter Geschwindigkeit bewegt werden, und es sollte der Median oder Durchschnitt mehrerer Totzeitmessungen verwendet werden. Alternativ kann die Totzeit auch mit Hilfe des Trace-Editors geschätzt werden. Für weitere Informationen siehe Totzeit des Systems ermitteln" }, 
{ "title" : "Verwendung der Totzeit ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054865995483", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Istwerte, Sollwerte und Totzeit \/ Was ist die Totzeit, wie wird sie ermittelt, wie wird sie genutzt? \/ Verwendung der Totzeit ", 
"snippet" : "Die Totzeit wird in den folgenden Funktionen verwendet. Wenn Sie eine dieser Funktionen verwenden und eine hohe Genauigkeit benötigen, müssen Sie die Totzeit bestimmen und konfigurieren. Beim Umschalten in den Reglermodus SMC_position Für weitere Informationen siehe StandardanwendungsfälleIm Reglerm...", 
"body" : "Die Totzeit wird in den folgenden Funktionen verwendet. Wenn Sie eine dieser Funktionen verwenden und eine hohe Genauigkeit benötigen, müssen Sie die Totzeit bestimmen und konfigurieren. Beim Umschalten in den Reglermodus SMC_position Für weitere Informationen siehe StandardanwendungsfälleIm Reglermodus SMC_velocity zur Berechnung der Sollposition aus der Istposition und Sollgeschwindigkeit Im Reglermodus SMC_torque zur Berechnung der Sollposition aus der Istposition und Istgeschwindigkeit Wenn die Software-Schleppfehlerüberwachung aktiviert ist Im Funktionsbaustein SMC_GetTravelTime , wenn der Eingang ValueSource den Wert MC_SOURCE.ACT hat Im Funktionsbaustein SMC_DigitalCamSwitch_HighPrecision , wenn der Eingang ValueSource den Wert MC_SOURCE.ACT hat Im Funktionsbaustein SMC_ETC_InterpolateAxisPosition (SPS-basierter Messtaster) " }, 
{ "title" : "Beispiele ", 
"url" : "_sm_drives_examples.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Beispiele ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Lageregelung auf der Steuerung mit SM_Drive_PosControl ", 
"url" : "_sm_example_poscontrol.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Beispiele \/ Lageregelung auf der Steuerung mit SM_Drive_PosControl ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt PosControl.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . In den meisten Fällen übernimmt ein Servoregler neben der Strom- und Drehzahlregelung auch die Lageregelung des Antriebs. Es gibt jedoch Anwendungsfälle, bei denen d...", 
"body" : "Sehen Sie hierzu das Beispielprojekt PosControl.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . In den meisten Fällen übernimmt ein Servoregler neben der Strom- und Drehzahlregelung auch die Lageregelung des Antriebs. Es gibt jedoch Anwendungsfälle, bei denen die Steuerung die Lageregelung der Achsen übernimmt. Dieses Beispiel zeigt, wie ein drehzahlgesteuertes Gerät wie beispielsweise ein Frequenzumrichter mit Positionsrückführung von CODESYS SoftMotion lagegeregelt wird. Voraussetzung dafür ist ein Gerät, das über Sollgeschwindigkeit angesteuert wird und das seine aktuelle Position zurück liefert. Exemplarisch wird in diesem Beispiel eine 10V-Analog-Ausgangsklemme EL4031 verwendet, deren Signal als Drehzahlsollwert für einen Frequenzumrichter verwendet wird. Für die Rückführung der Position wird eine Encoder-Klemme EL5101 verwendet. " }, 
{ "title" : "Achsposition mit SM_Drive_PosControl regeln ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_7bfb9b9f2d9ce618c0a8646335ff28dd", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Beispiele \/ Lageregelung auf der Steuerung mit SM_Drive_PosControl \/ Achsposition mit SM_Drive_PosControl regeln ", 
"snippet" : "Fügen Sie im Gerätebaum unterhalb von SoftMotion General Axis Pool eine lagegeregelte Achse des Typs SM_Drive_PosControl hinzu. Fügen Sie im Gerätebaum die Klemmen für den Analogausgang (EL4031) und den Encoder (EL5101) hinzu. Gerätebaum: Die Gerätebeschreibungen der Feldbusgeräte müssen beim Herste...", 
"body" : "Fügen Sie im Gerätebaum unterhalb von SoftMotion General Axis Pool eine lagegeregelte Achse des Typs SM_Drive_PosControl hinzu. Fügen Sie im Gerätebaum die Klemmen für den Analogausgang (EL4031) und den Encoder (EL5101) hinzu. Gerätebaum: Die Gerätebeschreibungen der Feldbusgeräte müssen beim Hersteller herunter geladen und installiert werden. Öffnen Sie das Gerät SM_Drive_PosControl im Editor und tragen Sie die allgemeinen Parameter Modulo mit dem Modulowert 360.0 in der Registerkarte Allgemein ein. Wechseln Sie zur Registerkarte Skalieren\/Mapping . Die Anzahl der Inkremente pro Motorumdrehung entnehmen Sie dem Datenblatt des Encoders. In diesem Beispiel sind 4096 Inkremente (1) eine Motorumdrehung. Da Sie in der Applikation mit Winkelgraden arbeiten, geben Sie bei Einheiten in der Applikation den Wert 360 (2). Einstellungen: Wechseln Sie zur Registerkarte SoftMotion Antrieb: Lageregelung und geben Sie folgende Parameter ein: D 2.0 Die Totzeit legt die Anzahl an Zyklen fest, um die die empfangene Istposition (Encoder) phasenverschoben zur Sollposition der Achse ist. Die Totzeit ist abhängig von den verwendeten Komponenten und muss experimentell ermittelt werden. Kp 0.0 Die Proportionalitätskonstante ist der Faktor, mit dem der Lagefehler, also die Abweichung zwischen Soll- und Istposition multipliziert wird, um später auf die Sollgeschwindigkeit addiert zu werden. Setzen Sie diesen Wert zunächst auf 0 . Sie werden den Wert später experimentell ermitteln. Bit width: 16 Die Bitbreite des Istwerts wird in Abhängigkeit von den verwendeten Komponenten empfangen und kann als 16-, 24- oder 32-Bit-Wert gesetzt sein. Setzen Sie den Wert 16 , da die verwendete Komponente die Position als UINT übergibt. max Lassen Sie die Lagefehlerüberwachung zunächst ausgeschaltet. Sie können sie anschließend bei Bedarf wieder einschalten. Dazu aktivieren Sie die Checkbox und geben einen maximal zulässigen Schleppfehler ein. Wird dieser Wert während des Betriebs überschritten, geht die Achse in einen Fehlerzustand. δ\/δt Der Parameter hat den Wert 1 und sollte nur in sehr speziellen Fällen verändert werden. Er definiert das Verhältnis von Sollgeschwindigkeit zur Ableitung der Position. Der Wertebereich reicht von 0 bis 1: 0 : Nur die numerische Ableitung von fSetPosition wird verwendet. 1 : Nur fSetVelocity wird verwendet. Regelkreis: Nun stellen Sie die Geschwindigkeitswerte ein, die an den Aktuator gesendet werden. Dazu muss Ihnen die Maximalgeschwindigkeit in Applikationseinheiten und der dazugehörige Rohwert der übertragenen Daten bekannt sein. In diesem Beispiel wird die Maximalgeschwindigkeit durch Ausgabe des Werts 16#7FFF erreicht, der einer Geschwindigkeit von 10 Umdrehungen\/s entspricht. Gemäß den gesetzten Einstellungen entspricht dies 3600 Grad\/s. Einstellungen: " }, 
{ "title" : "Variablen auf Ein-\/Ausgänge abbilden ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_869c8e3e2852db2ec0a8640e00c42e8b", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Beispiele \/ Lageregelung auf der Steuerung mit SM_Drive_PosControl \/ Variablen auf Ein-\/Ausgänge abbilden ", 
"snippet" : "Bilden Sie die Variablen mit den Achsdaten auf die E\/A-Module ab. Die verfügbaren zyklischen Daten der Achse liegen in den Datenstrukturen in und out . Sie können diese Verbindung entweder programmatisch oder direkt im Geräteeditor des Ein- bzw. Ausgabegeräts herstellen. Verbinden Sie den Ausgang (S...", 
"body" : "Bilden Sie die Variablen mit den Achsdaten auf die E\/A-Module ab. Die verfügbaren zyklischen Daten der Achse liegen in den Datenstrukturen in und out . Sie können diese Verbindung entweder programmatisch oder direkt im Geräteeditor des Ein- bzw. Ausgabegeräts herstellen. Verbinden Sie den Ausgang (Solldrehzahl) mit dem Gerät EL4031. Öffnen Sie dazu das Gerät im Editor und wählen Sie die Registerkarte EtherCAT E\/A-Abbild . Weisen Sie darin dem Ausgang die Variable out.iSetVelocity der Achse zu. Im Falle eines 32-Bit-Ausgangs wird out.diSetVelocity verwendet. Mapping: Verfahren Sie in der gleichen Weise mit dem Positionseingang. Öffnen Sie dazu das Gerät EL5101 im Editor und legen Sie den Positionseingangswert auf in.wActPosition fest. Im Falle eines 32-Bit-Eingangs setzen Sie den Wert auf in.dwActPosition . Mapping: Damit die Reglerfreigabe, der Quickstopp und die Endschalter funktionieren, müssen die entsprechenden Eingänge von SMC_PosControlInput mit den Werten des Antriebs beschrieben werden. Die Ausgänge von SMC_PosControlOutput müssen an den Antrieb übertragen werden (Beschreibung siehe unten). Wenn der Antrieb beispielsweise keinen Quickstopp unterstützt, muss SM_Drive_PosControl.in.bDriveStartRealState := TRUE gesetzt werden und SM_Drive_PosControl.out.bDriveStart kann ignoriert werden. In diesem Beispiel müssen bDriveStartRealState und bRegulatorRealState in der Applikation gesetzt werden. SM_Drive_PosControl.in.bDriveStartRealState := TRUE;\nSM_Drive_PosControl.in.bRegulatorRealState := TRUE; " }, 
{ "title" : "Totzeit des Systems ermitteln ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_section-idm43260109050006", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Beispiele \/ Lageregelung auf der Steuerung mit SM_Drive_PosControl \/ Totzeit des Systems ermitteln ", 
"snippet" : "Gehen Sie jetzt mit der Achse in den Onlinebetrieb und stellen Sie die Regelparameter ein. Bitte beachten Sie, dass die Achse sich dabei möglicherweise unkontrolliert bewegen kann und treffen Sie entsprechende Sicherheitsvorkehrungen. Versuchen Sie zunächst, die Achse ohne Lageregler zu betreiben. f...", 
"body" : "Gehen Sie jetzt mit der Achse in den Onlinebetrieb und stellen Sie die Regelparameter ein. Bitte beachten Sie, dass die Achse sich dabei möglicherweise unkontrolliert bewegen kann und treffen Sie entsprechende Sicherheitsvorkehrungen. Versuchen Sie zunächst, die Achse ohne Lageregler zu betreiben. fKp ist bereits auf 0.0 gestellt und die Skalierungseinstellungen werden verifiziert. Schalten Sie dazu die Achse mit MC_Power ein und starten Sie MC_MoveVelocity . Die Achse bewegt sich nun mit der programmierten Geschwindigkeit von 1 U\/s. Bei Abweichungen müssen Sie die Skalierung entsprechend korrigieren. Beenden Sie die Bewegung, beispielsweise mit MC_MoveRelative und starten Sie die Tracefunktion. Bestimmen Sie die Totzeit des Systems durch Messen der Zeitdifferenz zwischen Soll- und Istposition. Stellen Sie dazu in MC_MoveRelative die Maximalgeschwindigkeit und eine große Beschleunigung ein. Starten Sie die Traceaufzeichnung mit MC_MoveRelative . Bestimmen Sie nun die Zeitdifferenz zwischen dem Bewegungsstart der Sollposition und der ersten Reaktion der Istposition. Trace: Zur Bestimmung der Totzeit D teilen Sie diese Zeitdifferenz durch die Zykluszeit (D = Zeitdifferenz \/ Zykluszeit). Tragen Sie diesen Wert auf der Registerkarte SoftMotion Antrieb: Lageregelung im Regelkreis bei D ein. Versuchen Sie jetzt, die korrekte Einstellung für fKp zu ermitteln. Verändern Sie dazu den Wert der Variablen <Drive>.controller.fKp in einer Überwachungsliste. Setzen Sie fKp auf eine kleine Zahl (zum Beispiel 0.0001) und erhöhen Sie den Wert schrittweise. Überprüfen Sie das Verhalten bei jeder Änderung mit der Traceaufzeichnung. Sobald Sie Schwingungen feststellen, ist die Obergrenze erreicht. Verringern Sie nun den Wert von fKp um etwa 10% und tragen Sie ihn auf der Registerkarte SoftMotion Antrieb: Lageregelung im Regelkreis bei Kp ein. Sie können die Achse nun verwenden. " }, 
{ "title" : "Funktionsbaustein SMC_PosControlInput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_666f8939fd0b11e3b1f5b5a0173eacdc", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Beispiele \/ Lageregelung auf der Steuerung mit SM_Drive_PosControl \/ Funktionsbaustein SMC_PosControlInput ", 
"snippet" : "Bibliothek: SM3_Drive_PosControl Eingänge (VAR_INPUT) Name Datentyp Initialwert Beschreibung bLimitPos BOOL Endschalter in positive Richtung (nur bei finiten Achsen) Seit SoftMotion Version 4.12.0.0 ist die Endschalterüberwachung standardmäßig aktiv. Bei älteren Versionen muss diese manuell aktivier...", 
"body" : "Bibliothek: SM3_Drive_PosControl Eingänge (VAR_INPUT) Name Datentyp Initialwert Beschreibung bLimitPos BOOL Endschalter in positive Richtung (nur bei finiten Achsen) Seit SoftMotion Version 4.12.0.0 ist die Endschalterüberwachung standardmäßig aktiv. Bei älteren Versionen muss diese manuell aktiviert werden, indem bHWLimitEnable auf TRUE gesetzt wird. Das erreicht man typischerweise durch Schreiben der entsprechenden Parameternummer 1206 mittels MC_WriteBoolParameter . TRUE : Endschalter nicht betätigt FALSE : Endschalter betätigt bLimitNeg BOOL Endschalter in negativer Richtung TRUE : Endschalter nicht betätigt FALSE : Endschalter betätigt wActPosition WORD Aktuelle Position (Istposition) als 16-Bit-Wert dwActPosition DWORD Aktuelle Position (Istposition) als 32-Bit-Wert bExternalError BOOL Externer Fehler bRegulatorRealState BOOL TRUE : Achse in Regelung bDriveStartRealState BOOL FALSE : Achse in Schnellhalt ( Quick Stop ) dwEncoderCounterModulo DWORD 0 bDelayActivation BOOL TRUE : Solange bDelayActivation TRUE ist, schaltet SM3_Drive_PosControl nicht in den Kommunikationszustand 100 . Anwendungsfall: Der Wert wird auf TRUE gehalten, bis der verwendete Encoder gültige Positionswerte liefert. " }, 
{ "title" : "Funktionsbaustein SMC_PosControlOutput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_60809817bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Beispiele \/ Lageregelung auf der Steuerung mit SM_Drive_PosControl \/ Funktionsbaustein SMC_PosControlOutput ", 
"snippet" : "Bibliothek: SM3_Drive_PosControl Ausgänge (VAR_OUTPUT) Name Datentyp Initialwert Beschreibung bRegulatorOnIn BOOL TRUE : Die Achse soll in Regelung schalten. bDriveStart BOOL FALSE : Die Achse soll Schnellhalt ausführen. diSetVelocity DINT Sollgeschwindigkeit iSetVelocity INT Sollgeschwindigkeit...", 
"body" : "Bibliothek: SM3_Drive_PosControl Ausgänge (VAR_OUTPUT) Name Datentyp Initialwert Beschreibung bRegulatorOnIn BOOL TRUE : Die Achse soll in Regelung schalten. bDriveStart BOOL FALSE : Die Achse soll Schnellhalt ausführen. diSetVelocity DINT Sollgeschwindigkeit iSetVelocity INT Sollgeschwindigkeit " }, 
{ "title" : "Funktionsbaustein SMC_SetPosControlParams ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_6080e639bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Beispiele \/ Lageregelung auf der Steuerung mit SM_Drive_PosControl \/ Funktionsbaustein SMC_SetPosControlParams ", 
"snippet" : "Bibliothek: SM3_Drive_PosControl Ändert die Parameter einer SM3_Drive_PosControl -Achse Eingänge (VAR_INPUT) Name Datentyp Initialwert Beschreibung Axis AXIS_REF_POSCONTROL Achsenreferenz bExecute BOOL TRUE : Aktiviert die Ausführung des Funktionsbausteins fKp LREAL -1 Proportionalverstärkung für Sc...", 
"body" : "Bibliothek: SM3_Drive_PosControl Ändert die Parameter einer SM3_Drive_PosControl -Achse Eingänge (VAR_INPUT) Name Datentyp Initialwert Beschreibung Axis AXIS_REF_POSCONTROL Achsenreferenz bExecute BOOL TRUE : Aktiviert die Ausführung des Funktionsbausteins fKp LREAL -1 Proportionalverstärkung für Schleppfehler Ein Wert kleiner als 0 wird ignoriert. fPartVelPilotControl LREAL -1 Faktor für die Geschwindigkeitsregelung mit fSetPosition 0: keine Geschwindigkeitspilotsteuerung, 1: direkte Ausgabe von fSetVelocity . Ein Wert kleiner als 0 wird ignoriert. fDeadTime LREAL -1 Zeitverzögerung in Zyklen zwischen fSetPosition und fActPositioin Dieser Wert darf nicht 0 sein. Ein Wert kleiner als 0 wird ignoriert. fMaxPositionDiff LREAL -1 Maximale Positionsdifferenz 0 deaktiviert die Prüfung der maximalen Positionsverzögerung. Ein Wert kleiner als 0 wird ignoriert. Ausgänge (VAR_OUTPUT) Name Datentyp Initialwert Beschreibung bDone BOOL Die Ausführung des Funktionsbausteins wurde beendet. bError BOOL TRUE : Ein Fehler ist im Funktionsbaustein aufgetreten. ErrorID SMC_ERROR Fehleridentifikation Beispiel Die Parameter des Achsenantriebs SM_Drive_PosControl werden gesetzt. PROGRAM PLC_PRG\nVAR\n fbSetPosControlParams : SMC_SetPosControlParams;\nEND_VAR\n\nfbSetPosControlParams.fKp := 1;\nfbSetPosControlParams.fPartVelPilotControl :=0;\nfbSetPosControlParams.fDeadTime :=0.1;\nfbSetPosControlParams.fMaxPositionDiff :=1;\n\nfbSetPosControlParams(Axis:= SM_Drive_PosControl, bExecute:= TRUE); " }, 
{ "title" : "Benutzeroberfläche ", 
"url" : "_sm_drives_user_interface.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Benutzeroberfläche ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: SoftMotion -CiA402-Achse hinzufügen ", 
"url" : "_sm_cmd_add_softmotion_cia402_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Benutzeroberfläche \/ Befehl: SoftMotion -CiA402-Achse hinzufügen ", 
"snippet" : "SoftMotion -CiA402-Achse hinzufügen Funktion : Der Befehl fügt im Gerätebaum eine allgemeine SoftMotion -CiA402-Achse unterhalb eines Feldbusslaves ein. Aufruf : Menü Projekt , Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung : Im Gerätebaum ist ein Gerät ausgewählt, das diesen Antrieb un...", 
"body" : "SoftMotion -CiA402-Achse hinzufügen Funktion : Der Befehl fügt im Gerätebaum eine allgemeine SoftMotion -CiA402-Achse unterhalb eines Feldbusslaves ein. Aufruf : Menü Projekt , Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung : Im Gerätebaum ist ein Gerät ausgewählt, das diesen Antrieb unterstützt. Beispielsweise ein EtherCAT- oder CAN-Slave Die ESI-Datei des Antriebs enthält den Eintrag, dass es sich um eine CiA402-Achse handelt ( ProfileNo 402) . Der Befehl fügt eine generische CiA402-Achse ein. Für weitere Informationen siehe: Konfiguration der generischen CiA402-Achse " }, 
{ "title" : "Befehl: SoftMotion -Sercos-Achse hinzufügen ", 
"url" : "_sm_cmd_add_softmotion_sercos_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Benutzeroberfläche \/ Befehl: SoftMotion -Sercos-Achse hinzufügen ", 
"snippet" : "SoftMotion -Sercos-Achse hinzufügen Funktion : Der Befehl fügt eine allgemeine SoftMotion -Sercos-Achse unterhalb eines Sercos-Moduls ein. Aufruf : Menü Projekt , Kontextmenü des Sercos-Slaves Voraussetzung : Ein geeigneter Sercos-Slave im Gerätebaum ist selektiert. Ab SoftMotion Version 4.17.0.0 we...", 
"body" : "SoftMotion -Sercos-Achse hinzufügen Funktion : Der Befehl fügt eine allgemeine SoftMotion -Sercos-Achse unterhalb eines Sercos-Moduls ein. Aufruf : Menü Projekt , Kontextmenü des Sercos-Slaves Voraussetzung : Ein geeigneter Sercos-Slave im Gerätebaum ist selektiert. Ab SoftMotion Version 4.17.0.0 werden Sercos-Achsen nicht mehr unterstützt. Dieser Befehl wird verwendet, um jeden beliebigen Servoantrieb mit CODESYS SoftMotion zu verwenden. Der Antrieb muss lediglich den Sercos-Standard unterstützen. CODESYS verwendet einen Standardtreiber, um mit dem Gerät zu kommunizieren. Ob und wie der Antrieb mit dem Gerät zusammenarbeitet, hängt von der Implementierung im Gerät selber ab. Insofern gibt es keine Garantie, ob und wie der Treiber mit dem Gerät arbeitet. Der generische Sercos-Treiber unterstützt Multiachsgeräte bis maximal 8 Achsen. " }, 
{ "title" : "Befehl: SoftMotion -SoE-Achse hinzufügen ", 
"url" : "_sm_cmd_add_softmotion_soe_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Benutzeroberfläche \/ Befehl: SoftMotion -SoE-Achse hinzufügen ", 
"snippet" : "SoftMotion -SoE-Achse hinzufügen Funktion : Der Befehl fügt eine allgemeine SoftMotion -SoE-Achse unterhalb eines EtherCAT-Slaves ein. Aufruf : Menü Projekt , Kontextmenü des Slaves Voraussetzung : Ein geeigneter EtherCAT-Slave ist im Gerätebaum selektiert. Dieser Befehl wird verwendet, um jeden bel...", 
"body" : "SoftMotion -SoE-Achse hinzufügen Funktion : Der Befehl fügt eine allgemeine SoftMotion -SoE-Achse unterhalb eines EtherCAT-Slaves ein. Aufruf : Menü Projekt , Kontextmenü des Slaves Voraussetzung : Ein geeigneter EtherCAT-Slave ist im Gerätebaum selektiert. Dieser Befehl wird verwendet, um jeden beliebigen Servoantrieb mit CODESYS SoftMotion zu verwenden. Der Servoantrieb muss lediglich den SoE-Standard unterstützen. CODESYS verwendet einen Standardtreiber, um mit dem Gerät zu kommunizieren. Ob und wie der Antrieb mit dem Gerät zusammenarbeitet, hängt von der Implementierung im Gerät selber ab. Insofern gibt es keine Garantie, ob und wie der Treiber mit dem Gerät arbeitet Der generische SoE-Treiber unterstützt Multiachsgeräte bis maximal 8 Achsen. " }, 
{ "title" : "SoftMotion -Antriebe ", 
"url" : "_sm_f_reference_object_sm_drives.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Benutzeroberfläche \/ SoftMotion -Antriebe ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Registerkarte: Allgemein ", 
"url" : "_sm_edt_drive_general.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Benutzeroberfläche \/ SoftMotion -Antriebe \/ Registerkarte: Allgemein ", 
"snippet" : "Achsentyp und Einstellungen Achstyp Virtueller Modus : Der Antrieb wird durch eine Simulation ähnlich einem virtuellen Antriebsgerät ersetzt. Im Falle eines gekoppelten Antriebs hat dies keinen Einfluss auf die Feldbusgeräte. Sie funktionieren wie gewohnt, ohne jedoch Nachrichten von einem realen Ge...", 
"body" : "Achsentyp und Einstellungen Achstyp Virtueller Modus : Der Antrieb wird durch eine Simulation ähnlich einem virtuellen Antriebsgerät ersetzt. Im Falle eines gekoppelten Antriebs hat dies keinen Einfluss auf die Feldbusgeräte. Sie funktionieren wie gewohnt, ohne jedoch Nachrichten von einem realen Gerät zu erhalten oder an ein reales Gerät zu senden. Hinweis: Sie können den virtuellen Modus eines Antriebs auch in IEC-Code durch den Funktionsbaustein SMC3_ReinitDrive setzen\/rücksetzen. Modulo : Der Antrieb ist endlos drehend ohne Begrenzung des Verfahrbereichs (beispielsweise einen Bandantrieb). Modulowert [u] : Wert eines Zyklus (Modulo-Periode) Der Wert wird im Parameter fPositionPeriod im Funktionsbaustein AXIS_REF_SM3 gespeichert. Hinweis: Wenn Sie den Antriebstyp Modulo wählen, dann muss das Produkt fPositionPeriod * dwRatioTechUnitsDenom eine ganze Zahl sein. Begrenzt : Der Antrieb hat einen festen Arbeitsbereich (beispielsweise einen Linearantrieb). Software Endschalter Aktiviert : Positionswerte werden durch die untere Grenze Negativ und eine obere Grenze Positiv beschränkt. Negativ : Eingabefeld für den negativen Begrenzungswert Positiv : Eingabefeld für den positiven Begrenzungswert Motortyp Rotierend : Die Einstellungen unter Skalierung gelten für drehende Motoren. Linear : Die Einstellungen unter Skalierung gelten für lineare Motoren. (Vereinfachte Konfiguration ohne Getriebe und Motorumdrehungen.) Geschwindigkeitsrampentyp Legt das Geschwindigkeitsprofil für bewegungserzeugende Einachsbausteine und für Master\/Slave-Module fest: Hinweis: Für die Robotik werden die Rampentypen Sin² und Quadratisch (geglättet) nicht unterstützt. Trapezoid : Trapezförmiges Geschwindigkeitsprofil (mit konstanter Beschleunigung in jedem Abschnitt) Sin² : Ein durch die Funktion sin² beschreibbares Geschwindigkeitsprofil mit stetigem Beschleunigungsverlauf. Quadratisch : Beschleunigungsprofil in trapezoidaler Form mit Ruckbegrenzung Quadratisch (geglättet) : Wie Quadratisch , erzeugt aber ein Ruckprofil ohne Sprünge. Identifikation ID Ganzzahliger Bezeichner. Sollte für jeden Antrieb eindeutig sein. Dieser Bezeichner wird beispielsweise bei Fehlern im SPS-Log ausgegeben um den Antrieb zu identifizieren. Totzeit Zyklen Die Totzeit in Zyklen zwischen der fActPosition und der fSetPosition am Anfang dieses Zyklus Dynamische Grenzen Die Grenzwerte werden von den PLCopen Part 4 Bausteinen berücksichtigt. Weiterhin werden sie von Bibliotheksbausteinen mit Namen SMC_ControlAxisBy* verwendet, um Sprünge zu erkennen. Geschwindigkeit [u\/s²] Grenzwert von Geschwindigkeit, Beschleunigung, Verzögerung und Ruck Beschleunigung [u\/s²] Verzögerung [u\/s²] Ruck [u\/s³] Überwachung und Fehlerreaktion Softwaregrenzen Aktiviert : Positionswerte werden durch die untere Grenze Negativ und eine obere Grenze Positiv beschränkt. Negativ : Eingabefeld für den negativen Begrenzungswert Positiv : Eingabefeld für den positiven Begrenzungswert Software Fehlerreaktion Ursachen für einen Softwarefehler Erreichen eines Software-Endschalters Überschreiten des maximal zulässigen Software-Schleppfehlers Bei finiten Achsen: Zu viele 32-Bit Überläufe MC_Power.bRegulatorOn = FALSE während einer aktiven Bewegung (Fehler SMC_FB_ACTIVE_AXIS_DISABLED ) Bewegungsbaustein mit Busy=TRUE wird nicht aufgerufen (Fehler SMC_FB_WASNT_CALLED_DURING_MOTION ) Für die Software-Fehlerreaktion wird die Verzögerung , die Max. Distanz sowie die Verzögerung der dynamischen Grenzen berücksichtigt. Dabei wird aus der maximalen Distanz ebenfalls eine Verzögerung berechnet. Für die Fehlerrampe wird die höchste dieser Verzögerungswerte verwendet. Verzögerung [u\/s²] : Verzögerung für die Fehlerrampe Max. Distanz [u] Optional Distanz, innerhalb der der Antrieb einen Stillstand erreicht haben muss, nachdem ein Fehler aufgetreten ist. Schleppfehlerüberwachung Reaktion des Systems auf einen erkannten Schleppfehler. Ein Schleppfehler wird erkannt, wenn der Unterschied zwischen Sollposition und kompensierter Istposition den Schleppfehlergrenzwert überschreitet. Die extrapolierte Istposition wird in folgender Formel berechnet: extrapolierte Istposition := Istposition + Istgeschwindigkeit * Zykluszeit * Axis.fSetActTimeLagCycles Dieser Wert ist die um die Totzeit kompensierte Istposition der Achse. Hinweis: Wenn Sie den Schleppfehler überwachen, sollten Sie die Totzeit ermitteln und eintragen. Eine Beschreibung dazu finden Sie im Kapitel Istwerte, Sollwerte und Totzeit. Hinweis: Bei virtuellen Antrieben ist keine Schleppfehlerüberwachung verfügbar. abgeschaltet Keine Reaktion Die Schleppfehlerüberwachung ist deaktiviert. Antrieb ausschalten Bit bRegulatorOn wird auf FALSE gezwungen (mit Eingang MC_Power vergleichen) was den Antrieb (abhängig von der Antriebsimplementation zuerst zum Verzögern und dann) zum Deaktivieren zwingt. Quickstop durchführen Bit bDriveStart wird auf FALSE gezwungen (mit Eingang MC_Power vergleichen) was den Antrieb zur Durchführung eines Quickstops zwingt. eingeschaltet bleiben Der Antrieb bleibt eingeschaltet, aber alle laufenden Bewegungen werden abrupt gestoppt. Schleppfehlergrenzwert : Schleppfehlerüberwachung in der Steuerung Eine davon unabhängige Überwachung kann zusätzlich im Antrieb existieren, wird jedoch nicht über diesen Dialog konfiguriert. Online Voraussetzung: Die Steuerung befindet sich im Onlinebetrieb. Variablentabelle Auflistung von Antriebsvariablen mit Variablenname, Sollwert und aktueller Wert Status Anzeige des aktuellen Status des SoftMotion-Antriebs Kommunikation Anzeige des aktuellen Kommunikationsstatus Fehler Achsfehler FB-Fehler uiDriveInterfaceError strDriveInterfaceError Für weitere Informationen siehe: Totzeit des Systems ermittelnBeispiel Die folgenden Bilder demonstrieren den Effekt der unterschiedlichen Rampentypen. Die Position ist in grün gezeichnet,  die Geschwindigkeit in blau und die Beschleunigung in rot. trapezoid Die Geschwindigkeit ist teilweise linear, jedoch stetig, wohingegen die teilweise konstante Beschleunigung Sprünge aufweist. Sin² Die Knicke im Geschwindigkeitsprofil werden geglättet (durch Verwendung der Funktion sin² anstelle von Geraden), so dass die Sprünge in der Beschleunigung vermieden werden. Der Ruck kann bei diesem Rampentyp nicht vom Anwender beschränkt werden. Der eingestellte maximale Ruck wirkt sich nur aus, wenn zu Beginn der Bewegung die Beschleunigung ungleich 0 ist und die unterbrochene Brems- oder Beschleunigungsrampe nicht nahtlos fortgesetzt werden kann. Dann wird unter Berücksichtigung der Ruckbegrenzung zuerst die Beschleunigung auf 0 heruntergefahren, bevor mit der aktuellen Bewegung begonnen wird. Verglichen mit dem trapezförmigen Geschwindigkeitsprofil wird das Abbremsen in diesem Fall mehr Zeit einnehmen. Quadratisch Die Beschleunigung ist stückweise linear und stetig, der Ruck weist Sprünge auf. Die Geschwindigkeit besteht aus quadratischen und linearen Abschnitten. Quadratisch (geglättet) Die linearen Beschleunigungsrampen des quadratischen Rampentyps werden durch eine „glättende“ Funktion ersetzt, deren Steigung zu Beginn und am Ende 0 ist. Dadurch wird der Ruck ebenfalls stetig. Anmerkung: wird eine Bewegung unterbrochen, kann es trotzdem zu Sprüngen im Ruck kommen. Für weitere Informationen siehe: Bewegungen unterbrechen" }, 
{ "title" : "Registerkarte: Skalieren\/Mapping ", 
"url" : "_sm_edt_drive_scaling_mapping.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Benutzeroberfläche \/ SoftMotion -Antriebe \/ Registerkarte: Skalieren\/Mapping ", 
"snippet" : "In dieser Registerkarte können Sie das Verhältnis zwischen technischen Einheiten (zum Beispiel Millimeter oder Winkelgrad) und den Antriebseinheiten (Inkremente) festlegen. Abhängig von der Gerätebeschreibung erscheinen die Einstellmöglichkeiten vereinfacht (Parameter bHiresMode = TRUE ), und\/oder i...", 
"body" : "In dieser Registerkarte können Sie das Verhältnis zwischen technischen Einheiten (zum Beispiel Millimeter oder Winkelgrad) und den Antriebseinheiten (Inkremente) festlegen. Abhängig von der Gerätebeschreibung erscheinen die Einstellmöglichkeiten vereinfacht (Parameter bHiresMode = TRUE ), und\/oder ist zusätzlich eine Skalierung für lineare Motoren möglich (Parameter IsLinearMotor = TRUE ). Außerdem können Sie, falls nötig, die Zuordnung von zyklisch übertragenen Antriebsobjekten auf IEC-Variablen beeinflussen. Skalierung Richtung umkehren : Die Drehrichtung wird umgedreht. Der Motor erhält die vorgegebenen Werte mit umgekehrtem Vorzeichen. Genauigkeit (Dezimalstellen) Voraussetzung: Die Gerätebeschreibung gibt einen vereinfachten Konfigurationsdialog vor (Parameter bHiresMode = TRUE ). In diesem Fall erhalten die nicht angezeigten Einstellungen den Standardwert 1 . Anzahl der Dezimalstellen, mit der die Anwendereinheiten der Inkremente skaliert und übertragen werden. Zum Beispiel entspricht 3 einer Genauigkeit von 10 3 . Inkremente <=> Motorumdrehungen Anzahl der Inkremente, die einer gegebenen Anzahl von Umdrehungen des Motors entsprechen. Sie sehen den Parameter in der Registerkarte Konfiguration des Geräteeditors. Motorumdrehungen <=> Getriebeausgangsumdrehungen Anzahl der Motorumdrehungen, die einer gegeben Anzahl von Getriebeausgangsumdrehungen entsprechen. Getriebeausgangsumdrehungen <=> Einheiten in Applikation Anzahl der Getriebeausgangsumdrehungen, die einer Einheit in der Applikation entsprechen. Beispiel einer ausführlichen Konfiguration In der Beispielkonfiguration wird ein Antrieb, der 3600 Inkremente für eine Motorumdrehung hat, so skaliert, dass die technischen Einheiten der Applikation gerade Winkelgrade sind. Mapping Hinweis: Diese Parameter sind bei Drive_PosControl nicht verfügbar. Automatische Mapping : IEC-Parameter, die den Antrieb betreffen, werden automatisch auf die entsprechenden Ein- und Ausgänge des Gerätes abgebildet. Nach Deaktivierung der Option kann die Abbildung von Hand bearbeitet werden: Ändern Sie hierzu  Adresse oder Typ der Ein- und Ausgänge in der angezeigten Parameterliste, die gemäß der Gerätebeschreibungsdatei erstellt wurde. " }, 
{ "title" : "Registerkarte: Inbetriebnahme ", 
"url" : "_sm_edt_drive_commisioning.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Benutzeroberfläche \/ SoftMotion -Antriebe \/ Registerkarte: Inbetriebnahme ", 
"snippet" : "Sie können den Antrieb mit den Schaltflächen auf dieser Seite bewegen. Der Antrieb macht dadurch möglicherweise unerwartete Bewegungen. Treffen Sie alle nötigen Sicherheitsvorkehrungen! Diese Registerkarte dient zu Testzwecken bei der Inbetriebnahme von realen Antrieben. Sie ist nur verfügbar, wenn ...", 
"body" : "Sie können den Antrieb mit den Schaltflächen auf dieser Seite bewegen. Der Antrieb macht dadurch möglicherweise unerwartete Bewegungen. Treffen Sie alle nötigen Sicherheitsvorkehrungen! Diese Registerkarte dient zu Testzwecken bei der Inbetriebnahme von realen Antrieben. Sie ist nur verfügbar, wenn der Online-Konfigurationsbetrieb aktiviert ist. In diesem Modus ist das Entwicklungssystem mit dem Gerät verbunden, es muss jedoch noch keine Applikation geladen sein. Online Voraussetzung: Die Steuerung befindet sich im Onlinebetrieb. Variablentabelle Auflistung von Antriebsvariablen mit Variablenname, Sollwert und aktueller Wert Status Anzeige des aktuellen Status des SoftMotion-Antriebs Kommunikation Anzeige des aktuellen Kommunikationsstatus Fehler Achsfehler FB-Fehler uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "Bedienelemente ", 
"url" : "_sm_edt_drive_commisioning.html#UUID-44ff80c7-7f0e-b818-51b8-af95752bbbbd_id_b3c83ad0f91194c0a8646325634a44_id_063bbc9a58bd11e68fa9d28177272265", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Benutzeroberfläche \/ SoftMotion -Antriebe \/ Registerkarte: Inbetriebnahme \/ Bedienelemente ", 
"snippet" : "Bedienelemente Einschalten Der Antrieb wird mit Strom versorgt (vergleichbar MC_Power ). Fehler-Reset Zurücksetzen des Antriebs nach einem Fehler (vergleichbar MC_Reset ). Referenzfahrt starten Der Antrieb führt eine Referenzfahrt mit den im Antrieb eingestellten Parametern aus (vergleichbar MC_Home...", 
"body" : "Bedienelemente Einschalten Der Antrieb wird mit Strom versorgt (vergleichbar MC_Power ). Fehler-Reset Zurücksetzen des Antriebs nach einem Fehler (vergleichbar MC_Reset ). Referenzfahrt starten Der Antrieb führt eine Referenzfahrt mit den im Antrieb eingestellten Parametern aus (vergleichbar MC_Home ). Tippbetrieb Mit den < und > Schaltern kann der Antrieb gemäß der eingegebenen Werte für Distanz , Geschwindigkeit , Beschleunigung , Verzögerung und Jerk vorwärts oder rückwärts bewegt werden (vergleichbar MC_Inch ). Lesen&Schreiben Für den eingegebenen Antriebsparameter wird der aktuelle Wert aus der Steuerung gelesen und dargestellt. In Vorbereiteter Wert können Sie einen neuen Wert eintragen und mit der dahinter liegenden kleinen Schaltfläche auf den Parameter im Antrieb schreiben (vergleichbar MC_ReadParameter , MC_WriteParameter ). " }, 
{ "title" : "Registerkarte: SoftMotion-Antrieb - Lageregelung ", 
"url" : "_sm_edt_drive_poscontrol_position_control_loop.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Benutzeroberfläche \/ SoftMotion -Antriebe \/ Registerkarte: SoftMotion-Antrieb - Lageregelung ", 
"snippet" : "In dieser Registerkarte stellen Sie die Parameter für die Lageregelung ein. Beachten Sie dazu auch das Beispiel Lageregelung auf der Steuerung mit SM_Drive_PosControl. Lageregler fSetPosition Positionssollwert D Die Totzeit legt die Anzahl an Zyklen fest, um die die empfangene Istposition (Encoder) ...", 
"body" : "In dieser Registerkarte stellen Sie die Parameter für die Lageregelung ein. Beachten Sie dazu auch das Beispiel Lageregelung auf der Steuerung mit SM_Drive_PosControl. Lageregler fSetPosition Positionssollwert D Die Totzeit legt die Anzahl an Zyklen fest, um die die empfangene Istposition (Encoder) zur Sollposition der Achse phasenverschoben ist. Die Totzeit ist abhängig von den verwendeten Komponenten und muss experimentell ermittelt werden. Für weitere Informationen siehe: Totzeit des Systems ermittelnfActPosition Positionsistwert Bitbreite Die Bitbreite des Istwerts wird in Abhängigkeit von den verwendeten Komponenten empfangen und kann als 16-, 24- oder 32-Bit-Wert gesetzt sein. max : Die Lagefehlerüberwachung ist aktiviert. Eingabe des maximal zulässigen Schleppfehler Wird dieser Wert während des Betriebs überschritten, geht die Achse in einen Fehlerzustand. Kp Die Proportionalitätskonstante ist der Faktor, mit dem der Lagefehler, also die Abweichung zwischen Soll- und Ist-Position multipliziert wird, um später auf die Sollgeschwindigkeit addiert zu werden. fSetVelocity Geschwindigkeitssollwert Skalierung des Geschwindigkeitsausgangs fActPosition und Geschwindigkeitsausgang haben entgegengesetzte Richtung : Wenn Geschwindigkeitsausgang und die aktuelle Position eine entgegengesetzte Richtung haben, wird dies durch Aktivieren der Option korrigiert. Applikation [t.u.\/s] Minimaler und maximaler Geschwindigkeitswert, in Applikationseinheiten (beispielsweise 3600 Umdrehungen pro Sekunde). Ausgabewert Minimaler und maximaler Ausgabewert, der an den Aktuator gesendet wird (beispielsweise 16#7FFF). " }, 
{ "title" : "Registerkarte: Logische Achsen ", 
"url" : "_sm_edt_drive_logical_general.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Benutzeroberfläche \/ SoftMotion -Antriebe \/ Registerkarte: Logische Achsen ", 
"snippet" : "Achsentyp Modulo : Der Antrieb ist endlos drehend, ohne Begrenzung des Verfahrbereichs (beispielsweise ein Bandantrieb). Moduloeinstellungen Modulowert : Wert eines Zyklus Der Wert wird im Parameter fPositionPeriod im Funktionsbaustein AXIS_REF_SM3 gespeichert. Hinweis: Wenn Sie den Antriebstyp Modu...", 
"body" : "Achsentyp Modulo : Der Antrieb ist endlos drehend, ohne Begrenzung des Verfahrbereichs (beispielsweise ein Bandantrieb). Moduloeinstellungen Modulowert : Wert eines Zyklus Der Wert wird im Parameter fPositionPeriod im Funktionsbaustein AXIS_REF_SM3 gespeichert. Hinweis: Wenn Sie den Antriebstyp Modulo wählen, dann muss das Produkt fPositionPeriod * dwRatioTechUnitsDenom eine ganze Zahl sein. Begrenzt : Der Antrieb hat einen festen Arbeitsbereich (beispielsweise einen Linearantrieb). Negativ : Eingabefeld für den negativen Begrenzungswert Positiv : Eingabefeld für den positiven Begrenzungswert Master Referenzwert Soll : Sollwert des Masters wird als Eingang für die logische Achse und der Totzeitkompensation verwendet. Ist : Istwert des Masters wird als Eingang für die logische Achse und der Totzeitkompensation verwendet. Zeitversatz Zeitversatz relativ zu den Masterwerten Anzahl der Zyklen Zeitspanne, um die die Sollwerte extrapoliert werden müssen Eingangsdatenfilter Mit den Filtern ist es möglich, die Positions- und Geschwindigkeitswerte eines Encoders mit einem PT1-Filter zu glätten. Position Anzahl der Zyklen, die als Zeitkonstante des PT1-Filters verwendet wird. Wertebereich [0..999.9] Wert 0: Es wird keine Filterung durchgeführt (es werden Rohwerte zurückgegeben). Der gefilterte Rückgabewert ist eine Kombination aus einem PT1-gefilterten Positionssignal und einer zusätzlichen Positionsextrapolation unter Verwendung des Geschwindigkeitssignals. Die Extrapolation selbst verwendet ebenfalls einen PT1-Filter zur Rauschunterdrückung und wählt automatisch eine geeignete Zeitkonstante: Wenn nur Sollwerte gefiltert werden sollen oder die Achse das Geschwindigkeitssignal sendet, dann ist die Zeitkonstante des PT1-Extrapolationsfilters dieselbe wie beim PT1-Positionsfilter. Andernfalls wird ein heuristischer Ansatz verwendet: T Extrapolate = (T Pos + T Dead ) * T Pos \/ T Cycle T Extrapolate : Zeitkonstante vom PT1-Extrapolationsfilter T Pos : Zeitkonstante vom PT1-Positionsfilter T Cycle : Zykluszeit T Dead : Totzeitkompensation, unter Verwendung der Zeitverschiebung relativ zu den Masterwerten der logischen Achse n Shift und der Zykluszeit T Cycle : T Dead = n Shift * T Cycle Geschwindigkeit Die Anzahl der Zyklen, die als Zeitkonstante des PT1-Filters verwendet wird. Wertebereich [0..999.9] Wert 0: Es wird keine Filterung durchgeführt (es werden Rohwerte zurückgegeben). Der gefilterte Rückgabewert ist eine Kombination aus einem PT1-gefilterten Geschwindigkeitssignal und einer zusätzlichen Geschwindigkeitsextrapolation unter Verwendung des Beschleunigungssignals. Bitte beachten Sie: Die Extrapolation wird nur verwendet, wenn die Achse ein Geschwindigkeitssignal sendet oder wenn Sollwerte gefiltert werden sollen. Die Extrapolation selbst verwendet ebenfalls einen PT1-Filter zur Rauschunterdrückung und wählt automatisch eine geeignete Zeitkonstante: T Extrapolate = (T Vel + T Dead ) * T Vel \/ T Cycle mit T Extrapolate : Zeitkonstante vom PT1-Extrapolationsfilter T Vel : Zeitkonstante vom PT1-Geschwindigkeitsfilter T Cycle : Zykluszeit T Dead : Totzeitkompensation, unter Verwendung der Zeitverschiebung relativ zu den Masterwerten der logischen Achse n Shift und der Zykluszeit T Cycle : T Dead = n Shift * T Cycle Geschwindigkeitssignal der logischen Achse ( fActVelocity ): Fall 1: Master Referenzwert = Set fSetVelocity der Masterachse wird als Rohwert für das Geschwindigkeitssignal der logischen Achse verwendet. Fall 2: Master Referenzwert = Actual , kein Geschwindigkeitssignal von der Masterachse. Die numerische Ableitung der gefilterten Position der logischen Achse ( fActPosition ) wird als Rohwert für das Geschwindigkeitssignal der logischen Achse verwendet. Fall 3: Master Referenzwert = Actual , ein Geschwindigkeitssignal von der Masterachse. Das Geschwindigkeitssignal wird als Rohwert für das Geschwindigkeitssignal der logischen Achse verwendet. Die Geschwindigkeitsfilterung wird auf diesem Rohsignal durchgeführt. Das heißt, wenn es mit dem Standardwert usiFilterDepthVelocity = 0 konfiguriert ist, dann wird dieses Signal unverändert an fActVelocity übergeben. Im Fall 2 wäre es auch möglich, die numerische Ableitung der ungefilterten Position ( fActPosition der Masterachse) zu verwenden. Es wurde die gefilterte Position gewählt, weil in diesem Fall die fActVelocity der logischen Achse mit der fActPosition in der Standardkonfiguration ohne Geschwindigkeitsfilterung übereinstimmt. Für die Geschwindigkeit wird die Extrapolation der Filterverzögerung nur in den Fällen 1 und 3 durchgeführt. Im Fall 2 wäre dies numerisch nicht stabil oder würde eine zu starke Filterung der Beschleunigung erfordern, um sinnvoll zu sein. Die Beschleunigung der logischen Achse ( fActAcceleration ) Fall 1: Master Referenzwert = Set fSetAcceleration der Masterachse wird für das Beschleunigungssignal der logischen Achse verwendet. Fall 2: Master Referenzwert = Actual und ein Geschwindigkeitssignal von der Masterachse. Die numerische Ableitung der gefilterten Geschwindigkeit der logischen Achse ( fActVelocity ) wird für das Beschleunigungssignal der logischen Achse verwendet. Fall 3: Master Referenzwert = Actual und kein Geschwindigkeitssignal von der Masterachse. Der Wert 0 wird für das Beschleunigungssignal der logischen Achse verwendet, da die zweifache Differenzierung eines verrauschten Positionssignals zu unbrauchbaren Ergebnissen führt. Der Ruck der logischen Achse ( fActJerk ) Der Ruck der logischen Achse ( fActJerk ) ist entweder Fall 1 : Master Referenzwert = Set fSetJerk der Masterachse wird für das Rucksignal der logischen Achse verwendet. Fall 2: Master Referenzwert = Actual Der Wert 0 wird für das Rucksignal der logischen Achse verwendet, da die dreifache Differenzierung eines verrauschten Positionssignals zu unbrauchbaren Ergebnissen führt. Für das Beschleunigungs- und Rucksignal wird keine Totzeitkompensation durchgeführt. Alle Sollwerte (Position, Geschwindigkeit, Beschleunigung und Ruck) der logischen Achse entsprechen den Istwerten. Werte schreiben Schreibt die Werte von Eingangsdatenfilter und Zeitversatz auf die Steuerung. Identifikation ID Eindeutige ID der logischen Achse Online Voraussetzung: Die Steuerung befindet sich im Onlinebetrieb. Variablentabelle Auflistung von Antriebsvariablen mit Variablenname, Sollwert und aktueller Wert Status Anzeige des aktuellen Status des SoftMotion-Antriebs Kommunikation Anzeige des aktuellen Kommunikationsstatus Fehler Achsfehler FB-Fehler uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "Registerkarte: Encoder ", 
"url" : "_sm_edt_drive_free_encoder_general.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Drives \/ Benutzeroberfläche \/ SoftMotion -Antriebe \/ Registerkarte: Encoder ", 
"snippet" : "Allgemeine Encodereinstellungen Modulo Bei einem Moduloantrieb muss diese Option aktiviert und ein Modulowert eingegeben werden. : Der Antrieb ist endlos drehend ohne Begrenzung des Verfahrbereichs (beispielsweise ein Bandantrieb). Fenster Moduloeinstellungen wird angezeigt: Modulowert : Eingabefeld...", 
"body" : "Allgemeine Encodereinstellungen Modulo Bei einem Moduloantrieb muss diese Option aktiviert und ein Modulowert eingegeben werden. : Der Antrieb ist endlos drehend ohne Begrenzung des Verfahrbereichs (beispielsweise ein Bandantrieb). Fenster Moduloeinstellungen wird angezeigt: Modulowert : Eingabefeld für den Modulowert Der Wert wird im Parameter fPositionPeriod im FB AXIS_REF_SM3 gespeichert. Hinweis: Wenn Sie den Antriebstyp Modulo wählen, dann muss das Produkt fPositionPeriod * dwRatioTechUnitsDenom eine ganze Zahl sein. Begrenzt : Der Antrieb ist begrenzt. Bitbreite Auswahlliste für eine geeignete Bitbreite Skalierung Definition der Umwandlung der ganzzahligen Positionswerte, die vom Gerät gesendet werden, in Inkremente und technische Einheiten, die in einer IEC-Applikaiton verwendet werden. Richtung umkehren : Der Encoder erhält die vorgegebenen Werte mit umgekehrtem Vorzeichen und dreht dadurch in die entgegengesetzte Rotationsrichtung. Inkremente < = > Encoderumdrehungen Anzahl Inkremente , die der Anzahl an vollen Encoderumdrehungen entsprechen Encoderumdrehungen <=> Einheiten in Applikation Anzahl an Encoderumdrehungen , die der Anzahl an Einheiten in Applikation entspricht Online Voraussetzung: Die Steuerung befindet sich im Onlinebetrieb. Variablentabelle Auflistung von Antriebsvariablen mit Variablenname, Sollwert und aktueller Wert Status Anzeige des aktuellen Status des SoftMotion-Antriebs Kommunikation Anzeige des aktuellen Kommunikationsstatus Fehler Achsfehler FB-Fehler uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "CODESYS Softmotion Basic ", 
"url" : "_sm_basic.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Übersicht ", 
"url" : "_sm_overview_basic.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Übersicht ", 
"snippet" : "CODESYS Softmotion Basic bietet eine Schnittstelle für Funktionsbausteine zur Bewegungssteuerung von Einzelachsen. Diese Schnittstelle basiert auf der PLCopen-Spezifikation \"Function blocks for motion control Part 1 V2.0\". Die Trajektorienplanung erfolgt dabei in der CODESYS -Steuerung. Der Funktion...", 
"body" : "CODESYS Softmotion Basic bietet eine Schnittstelle für Funktionsbausteine zur Bewegungssteuerung von Einzelachsen. Diese Schnittstelle basiert auf der PLCopen-Spezifikation \"Function blocks for motion control Part 1 V2.0\". Die Trajektorienplanung erfolgt dabei in der CODESYS -Steuerung. Der Funktionsumfang reicht vom Anfahren einer Zielposition oder -geschwindigkeit über das Überlagern zweier Bewegungen bis zu synchronisierten Bewegungen über virtuelle Getriebe und Kurvenscheiben. Bewegungskommandos lassen sich puffern und zyklusgenau abbrechen, sowie per Override verlangsamen oder anhalten und fortsetzen. " }, 
{ "title" : "Erste Schritte mit CODESYS Softmotion Basic ", 
"url" : "_sm_basic_first_steps.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Erste Schritte mit CODESYS Softmotion Basic ", 
"snippet" : "Um eine Bewegung mit CODESYS Softmotion Basic zu programmieren, wird zunächst mindestens eine Achse im Gerätebaum konfiguriert. Dazu gehört unter anderem die Einstellung des Achstyps ( modulo oder finit ), des Geschwindigkeitsrampentyps, der Softwareendschalter und der Fehlerreaktion. Einen Überblic...", 
"body" : "Um eine Bewegung mit CODESYS Softmotion Basic zu programmieren, wird zunächst mindestens eine Achse im Gerätebaum konfiguriert. Dazu gehört unter anderem die Einstellung des Achstyps ( modulo oder finit ), des Geschwindigkeitsrampentyps, der Softwareendschalter und der Fehlerreaktion. Einen Überblick über die unterstützten Bewegungsarten finden Sie im Kapitel Einachsbewegungen. Wie Sie eine Einzelachsbewegung programmieren, können Sie im Kapitel Bewegung einzelner Achsen steuern nachlesen. Die grundlegende Verwendung von Kurvenscheiben können Sie im Kapitel Kurvenscheiben-Antrieb mit Hilfe einer virtuellen Zeitachse steuern nachlesen. Informationen zum Puffern, Überschleifen und Überlagern von Bewegungen finden Sie im Abschnitt Kommandierung mehrerer Bewegungen. Für weitere Informationen siehe: Übersicht über KurvenscheibenKapitel Umschalten zwischen KurvenscheibenErstellung einer Kurvenscheibe online aus der Applikation: Datenstrukturen der KurvenscheibeKapitel Dynamikanpassung mit MC_SetOverride" }, 
{ "title" : "Administrative Funktionsbausteine ", 
"url" : "_sm_administrative_fbs.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Administrative Funktionsbausteine ", 
"snippet" : "Administrative Funktionsbausteine dienen der Abfrage von Informationen oder der Änderung bestimmter Einstellungen. Sie lösen jedoch niemals eine Bewegung aus. Ein realer Antrieb (im Folgenden Antrieb genannt) wird in CODESYS SoftMotion durch das Softwareobjekt AXIS_REF_SM3 (im Folgenden Achse genann...", 
"body" : "Administrative Funktionsbausteine dienen der Abfrage von Informationen oder der Änderung bestimmter Einstellungen. Sie lösen jedoch niemals eine Bewegung aus. Ein realer Antrieb (im Folgenden Antrieb genannt) wird in CODESYS SoftMotion durch das Softwareobjekt AXIS_REF_SM3 (im Folgenden Achse genannt) repräsentiert. Je nach verwendetem administrativen Funktionsbaustein erfolgt die Ausführung entweder auf dem Antrieb, auf der Achse oder auf beide. Funktionsbausteine MC_Power Steuert die Leistungsstufe des Antriebs MC_Reset Setzt Fehler der Achse und Fehler des Antriebs zurück MC_SetPosition Verschiebt das Koordinatensystem der Achse auf einen beliebigen Wert, was beispielsweise für eine Referenzierung hilfreich sein kann SMC3_BrakeControl Steuert die mechanische Bremse, wenn der Antrieb dies unterstützt SMC3_BrakeStatus Liest den aktuellen Zustand der mechanischen Bremse aus SMC_ChangeDynamicLimits Setzt die dynamischen Grenzen (Geschwindigkeit, Beschleunigung, Verzögerung, Ruck und Drehmoment) einer Achse Für weitere Informationen siehe Dynamische Grenzen in Registerkarte: AllgemeinSMC_ChangeAxisScalingLinear Verändert die Skalierung einer linearen Achse SMC_ChangeAxisScalingRotary Verändert die Skalierung einer rotatorischen Achse SMC_SetForecast Setzt die Vorausschau einer Achse SMC_GetForecast Gibt die eingestellte Vorausschau der Achse zurück SMC_GetTravelTime Gibt den Zeitpunkt zurück, wann die Achse eine bestimmte Position erreicht. Dies ist besonders in Kombination mit einer Vorausschau hilfreich. SMC_SetAdditionalConversionFactors Setzt zusätzliche Faktoren für die Konvertierung. Mit dem Faktor für Drehmomente kann beispielsweise ein Getriebe berücksichtigt werden. SMC_SetControllerMode Setzt einen anderen Betriebsmodus der Achse, wenn der Antrieb dies unterstützt SMC_SetMovementType Setzt den Bewegungstyp einer virtuellen Achse auf Begrenzt oder Modulo Für weitere Informationen siehe Registerkarte: Allgemein. SMC_SetRampType Setzt den Geschwindigkeitsrampentyp einer Achse Für weitere Informationen siehe Geschwindigkeitsrampentyp im Kapitel Registerkarte: AllgemeinSMC_SetSoftwareLimits Setzt Positionsgrenzen für begrenzte Achsen und die dazugehörige Reaktion im Fehlerfall Für weitere Informationen siehe Software-Endschalter und Software-Fehlerreaktion im Kapitel Registerkarte: AllgemeinMC_TouchProbe Gibt die Antriebsposition beim Auslösen eines definierten Trigger-Events zurück MC_AbortTrigger Bricht Funktionen ab, die Trigger-Events verwenden (beispielsweise MC_TouchProbe ) SMC_ReadFBError Gibt den ältesten Eintrag aus dem Funktionsbaustein-Fehlerspeicher der Achse zurück. Diese Information kann beispielsweise für die Anzeige in einer Visualisierung verwendet werden. SMC_ClearFBError Löscht den ältesten Eintrag aus dem Funktionsbaustein-Fehlerspeicher der Achse SMC_ReadSetPosition Gibt die Sollposition der Achse zurück SMC_ReadSetValues Gibt Sollposition, Sollgeschwindigkeit, Sollbeschleunigung und Sollruck zurück. Mit aktivierter Vorausschau können auch Daten in der Zukunft abgefragt werden. Für weitere Informationen siehe SMC_SetForecast MC_ReadActualPosition Gibt die Istposition des Antriebs zurück MC_ReadActualVelocity Gibt die Istgeschwindigkeit des Antriebs zurück MC_ReadActualTorque Gibt das Istdrehmoment oder die Istkraft des Antriebs zurück MC_ReadAxisError Liest den Fehler vom Antrieb aus MC_ReadStatus Liest den aktuellen Status der Achse aus SMC_CheckAxisCommunication Gibt den Kommunikationszustand der Achse zurück SMC_CheckLimits Prüft, ob die aktuellen Sollwerte die eingestellten dynamischen Grenzen der Achse überschreiten Für weitere Informationen siehe SMC_ChangeDynamicLimits und Dynamische Grenzen in Registerkarte: AllgemeinSMC_GetTrackingError Gibt den Schleppfehler der Achse zurück (Differenz zwischen Sollposition der Achse und Istposition des Antriebs) SMC_InPosition Gibt zurück, ob der Schleppfehler innerhalb eines konfigurierbaren Bereichs liegt SMC_MeasureDistance Gibt die zurückgelegte Distanz der Achse seit dem Start des Bausteins zurück. Dies ist besonders für Modulo Achsen hilfreich. MC_ReadBoolParameter Liest einen booleschen Wert aus der Achse oder dem Antrieb aus MC_ReadParameter Liest einen Wert aus der Achse oder dem Antrieb aus MC_WriteBoolParameter Schreibt einen booleschen Wert zur Achse oder dem Antrieb MC_WriteParameter Schreibt einen Wert zur Achse oder dem Antrieb Diagnose-Funktionsbausteine SMC_AxisDiagnosticLog Schreibt zyklisch die Soll- und Istwerte (Position, Geschwindigkeit, Beschleunigung) der Achse und des Antriebs in eine Datei. Dies kann für die Diagnose von Fehlern und Bewegungsabläufen in weiteren Tools hilfreich sein. SMC_GetMaxSetVelocity Zeichnet den maximalen Betrag der Sollgeschwindigkeit der Achse auf. Dieser Baustein kann für die Diagnose hilfreich sein. SMC_GetMaxSetAccDec Zeichnet den maximalen Betrag der Sollbeschleunigung der Achse auf. Dieser Baustein kann für die Diagnose hilfreich sein. Persistieren SMC3_PersistPosition Persistiert die Position einer Achse mit Absolut-Encoder Für weitere Informationen zu \"Persistieren\" siehe Achsposition persistierenSMC3_PersistPositionLogical Persistiert die Position einer logischen Achse Für weitere Informationen zu logischen Achsen siehe Logischer Antrieb. " }, 
{ "title" : "Einachsbewegungen ", 
"url" : "_sm_basic_single_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Einachsbewegungen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Übersicht ", 
"url" : "_sm_overview_single_axis_movement.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Einachsbewegungen \/ Übersicht ", 
"snippet" : "CODESYS SoftMotion unterscheidet zwischen Bewegungen, die nur auf eine Einzelachse wirken und Bewegungen, bei denen zwei Achsen, beispielsweise über elektronische Kurvenscheiben oder virtuelle Getriebe, synchronisiert werden. Letzteres ist auf der Hilfeseite Synchrone Bewegungen von zwei Achsen besc...", 
"body" : "CODESYS SoftMotion unterscheidet zwischen Bewegungen, die nur auf eine Einzelachse wirken und Bewegungen, bei denen zwei Achsen, beispielsweise über elektronische Kurvenscheiben oder virtuelle Getriebe, synchronisiert werden. Letzteres ist auf der Hilfeseite Synchrone Bewegungen von zwei Achsen beschrieben. Grundsätzlich lassen sich die Bewegungsbausteine, die nur auf eine Einzelachse wirken, in die folgenden Kategorien einteilen: Bewegungsbausteine Baustein Beschreibung MC_MoveAbsolute Führt eine Bewegung zur angegebenen Position aus MC_MoveRelative Führt eine Bewegung um die angegebene Distanz relativ zur aktuellen Position aus MC_MoveAdditive Führt eine Bewegung um die angegebene Distanz relativ zur zuletzt kommandierten Zielposition einer anderen Bewegung (beispielsweise von MC_MoveAbsolute ) aus MC_MoveSuperimposed Führt eine Bewegung um die angegebene relative Distanz zusätzlich zu einer weiteren aktiven Bewegung (beispielsweise von MC_MoveAbsolute ) aus. Dabei wird die bereits aktive Bewegung nicht abgebrochen. MC_MoveVelocity Führt eine kontinuierlich andauernde Bewegung mit der angegebenen Geschwindigkeit aus SMC_MoveContinuousAbsolute Führt eine Bewegung zur angegebenen Position aus. Dabei wird die Zielposition mit einer definierten Geschwindigkeit erreicht, die anschließend gehalten wird. SMC_MoveContinuousRelative Führt eine Bewegung um die angegebene Distanz relativ zur aktuellen Position aus. Dabei wird die Zielposition mit einer definierten Geschwindigkeit erreicht, die anschließend gehalten wird. MC_Jog Führt eine kontinuierlich andauernde Bewegung mit der angegebenen Geschwindigkeit aus, solange sich die Achse vorwärts oder rückwärts bewegen soll SMC_Inch Führt eine Bewegung um die angegebene Distanz relativ zur aktuellen Position aus, solange sich die Achse vorwärts oder rückwärts bewegen soll Stoppen von Bewegungen Baustein Beschreibung MC_Halt Führt einen kontrollierten Stopp aus, unterbricht jegliche aktive Bewegung und bringt die Achse in den Stillstand. MC_Halt ist für normale Betriebsbedingungen vorgesehen, da der Stopp durch neue Bewegungen unterbrochen werden kann. Zudem kann der Betrieb nach einem erfolgten Stopp leichter fortgesetzt werden, da die Achse in einem betriebsbereiten Zustand ist. MC_Stop Führt einen kontrollierten Stopp aus, unterbricht jegliche aktive Bewegung und bringt die Achse in den Stillstand. MC_Stop ist für Notfallsituationen vorgesehen, da der Stopp nicht durch neue Bewegungen unterbrochen werden kann. Nach einem erfolgten Stopp befindet sich die Achse in einem Stopp-Zustand, sodass keine neuen Bewegungen akzeptiert werden. Erst wenn der Stopp abgeschlossen ist und der Eingang Execute auf FALSE gesetzt wird, sind wieder neue Bewegungen möglich. MC_HaltSuperImposed Führt einen kontrollierten Stopp von SuperImposed -Bewegungen aus. Die zugrunde liegende Bewegung wird dabei nicht abgebrochen Referenzfahrt Baustein Beschreibung MC_Home Startet eine durch den Antrieb kontrollierte Referenzfahrt der Achse. Der Ablauf und dessen Parameter sind abhängig vom Antrieb und dem Hersteller. SMC_Homing Startet eine durch die Steuerung kontrollierte Referenzfahrt der Achse MC_SetPosition Führt zu keiner Bewegung der Achse, sondern verschiebt nur den Nullpunkt. Dadurch kann der Baustein beispielsweise für das Referenzieren verwendet werden. Außerdem kann der Baustein während einer aktiven Bewegung aufgerufen werden. Spezielle Bewegungen Baustein Beschreibung SMC_FollowPosition Schreibt die Sollposition der Achse. Dies kann verwendet werden, um eigene berechnete Trajektorien an die Achse weiterzugeben. SMC_FollowVelocity Schreibt die Sollgeschwindigkeit der Achse. Dies kann verwendet werden, um eigene berechnete Trajektorien an die Achse weiterzugeben. SMC_FollowPositionVelocity Schreibt die Sollposition und -geschwindigkeit der Achse. Dies kann verwendet werden, um eigene berechnete Trajektorien an die Achse weiterzugeben. SMC_FollowSetValues Schreibt wahlweise die Sollposition, -geschwindigkeit, -beschleunigung, den Sollruck und oder das Solldrehmoment der Achse. Dies kann verwendet werden, um eigene berechnete Trajektorien an die Achse weiterzugeben. SMC_SetTorque Schreibt das Solldrehmoment der Achse. Je nach Betriebsmodus der Achse wird der Wert entweder für die Drehmomentenvorsteuerung oder als das Drehmoment verwendet, das die Achse aufbringen soll. " }, 
{ "title" : "Bewegungen unterbrechen ", 
"url" : "_sm_interrupt_single_axis_movement.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Einachsbewegungen \/ Bewegungen unterbrechen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Unterbrechung von Einachsbewegungen ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_section-idm234855926060424", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Einachsbewegungen \/ Bewegungen unterbrechen \/ Unterbrechung von Einachsbewegungen ", 
"snippet" : "Einachsbewegungen, wie zum Beispiel MC_MoveAbsolute , können jederzeit durch andere Bewegungen unterbrochen werden. Dies kann eine Bewegung zu einer anderen Position oder eine Änderung der maximalen Geschwindigkeit, Beschleunigung oder Ruck mit dem gleichen Bewegungstyp und zur gleichen Position sei...", 
"body" : "Einachsbewegungen, wie zum Beispiel MC_MoveAbsolute , können jederzeit durch andere Bewegungen unterbrochen werden. Dies kann eine Bewegung zu einer anderen Position oder eine Änderung der maximalen Geschwindigkeit, Beschleunigung oder Ruck mit dem gleichen Bewegungstyp und zur gleichen Position sein. Die Unterbrechung ist so implementiert, dass kein Sprung in der Geschwindigkeit stattfindet. Bei den quadratischen Rampentypen findet außerdem auch kein Sprung in der Beschleunigung statt. In bestimmten Fällen ist eine Umkehr der Achse aufgrund der Abbruchbewegung unvermeidlich: Wenn die neue Zielposition eines MC_MoveAbsolute vor dem Ende des aktuellen Bremswegs liegt Wenn für die Abbruchbewegung eine kleinere maximale Verzögerung und\/oder ein kleinerer maximaler Ruck verwendet wird, was wiederum den Bremsweg über die Zielposition hinaus verlängert Wenn SMC_MoveContinuousAbsolute oder SMC_MoveContinuousRelative mit einer EndVelocity verwendet werden, die aus dem aktuellen Achszustand nicht ohne Umkehr erreicht werden kann Bei Verwendung der Rampentypen sin² und quadratisch (geglättet) kann es bei Unterbrechung zu einer Umkehr kommen, die auf den ersten Blick nicht notwendig scheint (siehe Erläuterungen). Die neue Zielposition könnte dann überfahren werden, obwohl sie nicht vor der alten Zielposition liegt. Dies ist auch dann möglich, wenn die maximale Verzögerung und der maximale Ruck nicht verändert (oder sogar erhöht) werden und die Endgeschwindigkeit gegenüber der abgebrochenen Bewegung nicht verändert wird. In diesem Fall gelten die folgenden Regeln: Bei trapezförmigen und quadratischen Rampentypen kommt es nie zu einem Überfahren Bei der Rampenart sin² gibt es kein Überfahren, wenn die neue Zielposition und die Grenzwerte für Beschleunigung und Verzögerung gleich den alten Werten sind In allen anderen Fällen kann es bei den Rampentypen sin² und quadratisch (geglättet) zu einem Überfahren kommen Erläuterung für den Rampentyp sin² : Die Abbruchbewegung beginnt mit einer neuen sin²-Geschwindigkeitsrampe, d.h. die Beschleunigung beginnt bei 0 und steigt oder fällt allmählich. Wenn die Achse zum Zeitpunkt des Abbruchs eine Beschleunigung ungleich 0 hat, dann springt die Beschleunigung zu Beginn der sin²-Geschwindigkeitsrampe auf 0. Dies kann zu einem Überfahren führen, da das Hoch- oder Runterfahren der Beschleunigung Zeit benötigt. Erläuterung für den Rampentyp quadratisch (geglättet) : Es gilt die gleiche Erläuterung wie für sin² , aber für den Ruck statt für die Beschleunigung. Hinweis zu Override Aufgrund obiger Erläuterungen wird die Verwendung von MC_SetOverride mit dem Rampentyp sin² und quadratisch (geglättet) nicht empfohlen " }, 
{ "title" : "Unterbrechung während der Bremsphase ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_id_fbc677d73098ed1c0a86463411e7edd_id_b5d8fdf3fc0362bfc0a8658d00b6a52e", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Einachsbewegungen \/ Bewegungen unterbrechen \/ Unterbrechung während der Bremsphase ", 
"snippet" : "Einachsbewegungen, wie zum Beispiel MC_MoveAbsolute , können jederzeit durch andere Bewegungen unterbrochen werden. Dies kann eine Bewegung zu einer anderen Position oder eine Änderung der Geschwindigkeit oder Beschleunigung sein. Grundsätzlich wird die Unterbrechung der Bewegung durch eine andere s...", 
"body" : "Einachsbewegungen, wie zum Beispiel MC_MoveAbsolute , können jederzeit durch andere Bewegungen unterbrochen werden. Dies kann eine Bewegung zu einer anderen Position oder eine Änderung der Geschwindigkeit oder Beschleunigung sein. Grundsätzlich wird die Unterbrechung der Bewegung durch eine andere so umgesetzt, dass kein Sprung in der Geschwindigkeit stattfindet. Bei allen Rampentypen außer trapezoid findet außerdem auch kein Sprung in der Beschleunigung statt. Bei Verwendung der Rampentypen sin² und quadratisch (geglättet) kann es bei Unterbrechung zu einer Umkehr kommen, die auf den ersten Blick nicht notwendig scheint (siehe Erklärung). Die neue Zielposition wird dann überfahren werden, obwohl sie nicht vor der alten Zielposition liegt. Dies kann in folgenden Situationen auftreten: Wenn für die abbrechende Bewegung ein kleinerer Maximalwert für die Bremsung gesetzt wird als vorher In diesem Fall wird der zur Verfügung stehende Bremsweg zur neuen Zielposition unter Umständen zu kurz (bei allen Rampentypen). Entsprechend auch bei den Rampentypen quadratisch und quadratisch (geglättet) , wenn ein kleinerer Maximalwert für den Ruck gesetzt wird Falls diese Maximalwerte aber gleich bleiben (oder größer gewählt werden), dann gelten folgende Regeln: Bei Rampentyp trapezoid und quadratisch kommt es nie zu einem Überfahren. Beim Rampentyp sin² kommt es nicht zu einem Überfahren, wenn die neue Zielposition sowie die Grenzwerte für Bremsung und Beschleunigung gleich den alten Werten sind. In allen anderen Fällen kann es mit Rampentyp sin² und quadratisch (geglättet) zu einem Überfahren kommen. " }, 
{ "title" : "Synchrone Bewegungen von zwei Achsen ", 
"url" : "_sm_basic_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Übersicht ", 
"url" : "_sm_overview_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Übersicht ", 
"snippet" : "Dieser Abschnitt gibt einen Überblick über Bewegungen, bei denen eine Achse synchron zu einer anderen Achse bewegt wird (zeitlich oder positionsabhängig). Kurvenscheiben: Dabei soll in Abhängigkeit eines Antriebs (Master) ein weiterer Antrieb (Slave) beliebig definierte Bewegungen ausführen. Für wei...", 
"body" : "Dieser Abschnitt gibt einen Überblick über Bewegungen, bei denen eine Achse synchron zu einer anderen Achse bewegt wird (zeitlich oder positionsabhängig). Kurvenscheiben: Dabei soll in Abhängigkeit eines Antriebs (Master) ein weiterer Antrieb (Slave) beliebig definierte Bewegungen ausführen. Für weitere Informationen siehe KurvenscheibenSynchronisieren von zwei Achsen mit einem definierten Übersetzungsverhältnis mittels MC_GearIn , MC_GearOut und MC_GearInPos . Weitere Informationen zu diesen Funktionen finden Sie in der Dokumentation des jeweiligen Funktionsbausteins. Phasenverschiebung zwischen einer Master und Slave Achse mittels MC_Phasing . Mehr Details zu dieser Funktion ist in der Dokumentation des Funktionsbausteins zu finden. Ausgleichen von Spiel zwischen mechanischen Komponenten (beispielsweise in einem Getriebe) mittels SMC_BacklashCompensation . Mehr Details zu dieser Funktion ist in der Dokumentation des Funktionsbausteins zu finden. " }, 
{ "title" : "Kurvenscheiben ", 
"url" : "_sm_f_cam.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Übersicht ", 
"url" : "_sm_overview_synch_movements_2_axis_cam.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Übersicht ", 
"snippet" : "Die SoftMotion -Kurvenscheibe ist in die Benutzeroberfläche von CODESYS integriert. Innerhalb des Kurvenscheibeneditors können Kurvenscheiben und Nocken sowohl graphisch als auch mit Hilfe von Tabellen implementiert werden. Sobald für die zugehörige Applikation Code erzeugt wird, werden globale Date...", 
"body" : "Die SoftMotion -Kurvenscheibe ist in die Benutzeroberfläche von CODESYS integriert. Innerhalb des Kurvenscheibeneditors können Kurvenscheiben und Nocken sowohl graphisch als auch mit Hilfe von Tabellen implementiert werden. Sobald für die zugehörige Applikation Code erzeugt wird, werden globale Datenstrukturen („Cam Data“) angelegt, auf die das IEC-Programm zugreifen kann. Zu diesem Zweck wird automatisch mit dem Einfügen eines SoftMotion-Antriebs auch die Bibliothek SM3_Basic in das Projekt eingebunden. Für weitere Informationen siehe: Definition einer und How-To: Kurvenscheibe anlegen. " }, 
{ "title" : "Definition einer SoftMotion -Kurvenscheibe ", 
"url" : "_sm_cam_definition_softmotion_cam.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Definition einer SoftMotion -Kurvenscheibe ", 
"snippet" : "Eine Kurvenscheibe beschreibt die funktionale Abhängigkeit eines Antriebs (Slave) von einem anderen Antrieb (Master). Die Beziehung wird beschrieben durch eine stetige Funktion (oder Abbildung), die einen definierten Bereich an Masterwerten auf Slavewerte abbildet. Noch genauer: Nach Unterteilen der...", 
"body" : "Eine Kurvenscheibe beschreibt die funktionale Abhängigkeit eines Antriebs (Slave) von einem anderen Antrieb (Master). Die Beziehung wird beschrieben durch eine stetige Funktion (oder Abbildung), die einen definierten Bereich an Masterwerten auf Slavewerte abbildet. Noch genauer: Nach Unterteilen der Masterachse in geeignete Abschnitte kann der Graph dieser Funktion auf jedem dieser Intervalle entweder durch eine Gerade oder aber durch ein Polynom 5. Grades dargestellt werden. Beispiel Die Masterwerte sind auf der horizontalen, die Slavewerte auf der vertikalen Achse im Graphen einer Kurvenscheibe aufgetragen. Im Beispiel liegen die Masterwerte zwischen 0 und 360. Dieser Bereich ist in drei Intervalle unterteilt: (1) erstes Intervall: [0, 140] (2) zweites Intervall: [140, 280] (3) drittes Intervall: [280, 360] Auf dem ersten und dritten Intervall ist die Funktion (Abbildung) linear, ihr Graph entsprechend eine Gerade. Demzufolge ist ihre erste Ableitung (Steigung) konstant, alle höheren Ableitungen sind 0. Auf dem mittleren Intervall wird die Abbildung durch ein Polynom fünften Grades beschrieben. Somit ist ihre erste Ableitung ein Polynom vierten Grades, ihre zweite Ableitung (die Krümmung) ein Polynom dritten Grades, ihre dritte Ableitung ein Polynom zweiten Grades (usw.). Wenn die Funktion die Bewegung des Slaves in Abhängigkeit von der Position des Masters beschreibt, so entspricht ihre erste Ableitung gerade der Geschwindigkeit des Slaves, die zweite Ableitung seiner Beschleunigung. Behält man diese physikalische Interpretation im Hinterkopf, so wird offensichtlich, dass die Abbildung stetig sein muss. Das bedeutet, dass ihr Graph keine Sprünge aufweisen darf. Insbesondere muss die Stetigkeit auch an jedem Punkt erfüllt sein, an dem zwei Intervalle zusammentreffen. Des Weiteren wird die Stetigkeit im Allgemeinen auch von der ersten und zweiten Ableitung gefordert. (In der Tat bestimmen diese drei Stetigkeitsforderungen an Anfangs- und Endpunkt eines Intervalls gerade die Koeffizienten des zwischen zwei Geradenstücken eingefügten Polynoms fünften Grades. Außerdem dürfen Sie an beliebigen Stellen Nocken, das heißt binäre Schalter, zur Kurvenscheibe hinzufügen. Damit können Sie Kurvenscheibentabellen anlegen, die nur Nocken enthalten. Die Slaveposition wird dann über den gesamten Masterwertebereich auf 0 gesetzt. " }, 
{ "title" : "Übersicht der definierten Segmenttypen ", 
"url" : "_sm_overview_segment_types.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Übersicht der definierten Segmenttypen ", 
"snippet" : "CODESYS SoftMotion bietet verschiedene Segmenttypen für Kurvenscheiben an. Je nach Kompilierungsformat wird nur ein Teil der Segmenttypen unterstützt: XYVA: Nur Line und Poly5. Segments: Es werden alle Segmenttypen unterstützt. Segmenttyp Parameter Verlauf Poly7 Randbedingungen Master-Position Slave...", 
"body" : "CODESYS SoftMotion bietet verschiedene Segmenttypen für Kurvenscheiben an. Je nach Kompilierungsformat wird nur ein Teil der Segmenttypen unterstützt: XYVA: Nur Line und Poly5. Segments: Es werden alle Segmenttypen unterstützt. Segmenttyp Parameter Verlauf Poly7 Randbedingungen Master-Position Slave-Position Slave-Geschwindigkeit Slave-Beschleunigung Slave-Ruck Poly5 Randbedingungen Master-Position Slave-Position Slave-Geschwindigkeit Slave-Beschleunigung ModifiedSine Randbedingungen Master-Position Slave-Position Slave-Geschwindigkeit Segmentparameter Entweder Wendepunkt-Parameter λ (0≤λ≤1) oder Beschleunigungs-Parameter C a * (maximale Verzögerung) Line Randbedingungen Master-Position Slave-Position InclinedSine Randbedingungen Master-Position Slave-Position Die Auswahl des Segmenttyps hängt von der Applikation ab, da jeder Typ spezielle dynamische Eigenschaften hat. Je nach Bewegungsaufgabe (beispielsweise Rast - konstante Geschwindigkeit) gibt es verschiedene geeignete Segmenttypen. Eine Übersicht bietet die nachfolgende Tabelle: Rast (v=0, a=0) konstante Geschwindigkeit (v­­≠0, a=0) Umkehr (v=0, a≠0) Bewegung (v≠0, a≠0) Rast (v=0, a=0) Line Poly5\/7 InclinedSine ModifiedSine Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 konstante Geschwindigkeit (v≠0, a=0) Poly5\/7 ModifiedSine Line Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 Umkehr (v=0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 Bewegung (v≠0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 " }, 
{ "title" : "Aufbau des Kurvenscheibeneditors ", 
"url" : "_sm_cam_editor_layout.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Aufbau des Kurvenscheibeneditors ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Übersicht ", 
"url" : "_sm_overview_synch_movements_2_axis_cam_editor.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Aufbau des Kurvenscheibeneditors \/ Übersicht ", 
"snippet" : "Sie öffnen den Kurvenscheibeneditor durch einen Doppelklick auf das Objekt Kurvenscheibe im Gerätebaum. Der Editor besteht aus folgenden Registerkarten: Registerkarte Registerkarte: Kurvenscheibe: In diesem Editor erstellen Sie einen Kurvenscheibenverlauf mit einem graphischen Editor. Sie können dar...", 
"body" : "Sie öffnen den Kurvenscheibeneditor durch einen Doppelklick auf das Objekt Kurvenscheibe im Gerätebaum. Der Editor besteht aus folgenden Registerkarten: Registerkarte Registerkarte: Kurvenscheibe: In diesem Editor erstellen Sie einen Kurvenscheibenverlauf mit einem graphischen Editor. Sie können darin die Slaveposition, die Slavegeschwindigkeit, die Slavebeschleunigung sowie den Slaveruck darstellen und verändern. Im graphischen Editor erkennen Sie sehr schnell, wenn Sie eine Bewegung mit hohen Beschleunigungen programmieren. Registerkarte Kurvenscheibentabelle : In diesem Editor werden die Stützpunkte in einer Tabelle dargestellt. Darin können Sie die Positionen und Geschwindigkeiten exakt eingeben. Registerkarte Nocken : In diesem Editor programmieren Sie Nocken (Schaltpunkte) in einem Diagramm. Diese Darstellung gibt eine gute Übersicht über die zeitliche Abfolge der Nocken. Registerkarte Nockentabelle : In diesem Editor werden die Schaltpunkte in einer Tabelle dargestellt. Darin können Sie die Schaltpositionen exakt eingeben. Die Registerkarten sind aufgeteilt in einen Editor sowie eine Ansicht Werkzeuge und eine Ansicht Eigenschaften . Programmbeispiel zur Verwendung des Kurvenscheibeneditors " }, 
{ "title" : "Registerkarte: Kurvenscheibe ", 
"url" : "_sm_obj_cam_table_cam.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Aufbau des Kurvenscheibeneditors \/ Registerkarte: Kurvenscheibe ", 
"snippet" : "In diesem grafischen Editor definieren Sie den Kurvenscheibengraphen. Sie können jederzeit zwischen grafischem Editor und dem alternativ verwendbaren Tabelleneditor ( Registerkarte: Kurvenscheibentabelle) wechseln. Im Editor ist der Verlauf von vier Graphen dargestellt: Slaveposition (schwarz) Slave...", 
"body" : "In diesem grafischen Editor definieren Sie den Kurvenscheibengraphen. Sie können jederzeit zwischen grafischem Editor und dem alternativ verwendbaren Tabelleneditor ( Registerkarte: Kurvenscheibentabelle) wechseln. Im Editor ist der Verlauf von vier Graphen dargestellt: Slaveposition (schwarz) Slavegeschwindigkeit (blau) Slavebeschleunigung (grün) Slaveruck (gelb) Die horizontale Achse aller vier Koordinatensysteme zeigt den Bereich der Masterwerte ([0,360]). Die vertikale Achse im Positionsdiagramm zeigt den Wertebereich, der in den Eigenschaften der Kurvenscheibe definiert ist. Die Skalierung der vertikalen Achse von Geschwindigkeit, Beschleunigung und Ruck erfolgt automatisch. Eine neu eingefügte Kurvenscheibe ist mit Standardwerten vorbelegt. Sie besteht aus vier Punkten, die den Graphen in drei Abschnitte unterteilen ([0,120], [120,240] und [240,360]). Jedes der Intervallstücke des Kurvenscheibengraphen ist vom Typ Poly5 (Polynom fünften Grades). Sie können alle Kurven editieren. Da Geschwindigkeit, Beschleunigung und Ruck abgeleitete Kurven sind, wirkt sich eine Veränderung in einem der Graphen auch auf die anderen aus. Sie verändern die Höhe der Diagramme durch Verschieben der horizontalen Trennbalken mit der Maus. Ansicht Werkzeuge Auswählen Mit diesem Werkzeug selektieren Sie eine Zeile in der Tabelle. Selektierte Punkte werden mit der Taste Entf gelöscht. Punkt hinzufügen Mit diesem Werkzeug fügen Sie neue Punkte hinzu. Dazu klicken Sie in das gewünschte Diagramm auf die gewünschte Einfügeposition. Der Graph wird dann automatisch so angepasst, dass sein Verlauf durch den neu eingefügten Punkt führt. Ansicht ‚Eigenschaften‘ X X-Position der Slaveachse Y Y-Position der Slaveachse V Geschwindigkeit der Slaveachse A Beschleunigung der Slaveachse J Ruck der Slaveachse Für weitere Informationen siehe Dialog: Eigenschaften - Kurvenscheibe und How-To: Kurvenscheibe anlegen" }, 
{ "title" : "Registerkarte: Kurvenscheibentabelle ", 
"url" : "_sm_obj_cam_table_cam_table.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Aufbau des Kurvenscheibeneditors \/ Registerkarte: Kurvenscheibentabelle ", 
"snippet" : "In der Kurvenscheibentabelle können Sie alternativ zum grafischen Editor ( Registerkarte Kurvenscheibe ) den Kurvenscheibengraphen definieren. Sie können jederzeit zwischen Tabelleneditor und grafischem Editor wechseln. Die erste Zeile der Tabelle enthält immer die Startposition des Masters (und die...", 
"body" : "In der Kurvenscheibentabelle können Sie alternativ zum grafischen Editor ( Registerkarte Kurvenscheibe ) den Kurvenscheibengraphen definieren. Sie können jederzeit zwischen Tabelleneditor und grafischem Editor wechseln. Die erste Zeile der Tabelle enthält immer die Startposition des Masters (und die darauf bezogenen Slavewerte), die letzte immer seine Endposition. Die dazwischenliegenden Zeilen definieren abwechselnd Abschnitte und Punkte. Fügt eine neue Zeile hinzu Löscht das selektierte Segment X X-Position der Slaveachse Y Y-Position der Slaveachse V Geschwindigkeit der Slaveachse A Beschleunigung der Slaveachse J Ruck der Slaveachse Segmenttyp Line : Linie Poly5 : Polynom fünften Grades Poly7 : Polynom siebten Grades InclinedSine : Geneigte Sinuslinie ModifiedSine : Modifizierte Sinuslinie Lambda Wendepunkt-Parameter für die modifizierte Sinuslinie Beschleunigungsparameter Maximale Verzögerungsparameter für die modifizierte Sinuslinie Die folgenden Werte resultieren aus den Werten des jeweiligen Abschnitts. Sie können nicht verändert werden. min(Position) Minimalwert der Slaveposition max(Position) Maximalwert der Slaveposition max(Geschwindigkeit) Maximalwert der Geschwindigkeit des Slaves bezogen auf die Masterachse max(Beschleunigung) Maximalwert der Beschleunigung des Slaves bezogen auf die Masterachse Ansicht Werkzeuge : Auswählen Mit diesem Werkzeug selektieren Sie eine Zeile in der Tabelle. Selektierte Punkte werden mit der Taste Entf gelöscht. Für weitere Informationen siehe Dialog: Eigenschaften - Kurvenscheibe und How-To: Kurvenscheibe anlegen" }, 
{ "title" : "Registerkarte: Nocken ", 
"url" : "_sm_obj_cam_table_tappets.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Aufbau des Kurvenscheibeneditors \/ Registerkarte: Nocken ", 
"snippet" : "In diesem grafischen Editor definieren Sie Nockenspuren. Eine Nockenspur definiert eine oder mehrere masterpostionsabhängige Nocken. Am oberen Rand des Editorfensters stellt eine horizontale Achse den Bereich der Masterpositionen an. Unterhalb folgen die einzelnen Nockenspuren. Sie können jederzeit ...", 
"body" : "In diesem grafischen Editor definieren Sie Nockenspuren. Eine Nockenspur definiert eine oder mehrere masterpostionsabhängige Nocken. Am oberen Rand des Editorfensters stellt eine horizontale Achse den Bereich der Masterpositionen an. Unterhalb folgen die einzelnen Nockenspuren. Sie können jederzeit zwischen dem grafischen Editor und dem alternativ verwendbaren Tabelleneditor ( Registerkarte: Nockentabelle) wechseln. „Track-ID“ der Nockenspur Alle Nocken einer Nockenspur beziehen sich auf denselben Nockenschalter, eine Variable vom Typ BOOL. Ansicht Werkzeuge : Auswählen Mit diesem Werkzeug selektieren Sie die Nocken. Sie können selektierte Nocken mit der Maus auf eine andere Position ziehen. Sie können die Ein- und Ausschalt-Attribute einer Nocke ändern, indem Sie mit der Maus auf das betreffende Ende der gekreuzten Linien klicken. Mit der Taste Entf löschen Sie die selektierte Nocke. Mit diesem Werkzeug fügen Sie neue Nocken hinzu. Dazu klicken Sie in der gewünschten Spur auf die gewünschte Einfügeposition. Ansicht ‚Eigenschaften‘ Der Nocke wird ein Ereignis zugeordnet, wenn sie von der Position der Masterachse in positiver (aufsteigende Masterwerte) oder negativer Richtung passiert wird. X Position der Nocke positiver Durchlauf Ein- und Ausschalt-Attribute keine Aktion Umschalten auf ON Umschalten auf OFF Invertieren negativer Durchlauf Ein- und Ausschalt-Attribute keine Aktion Umschalten auf ON Umschalten auf OFF Invertieren Tabelle der möglichen Kombinationen der Nockenattribute Nockensymbol positiver Durchlauf negativer Durchlauf keine Aktion keine Aktion Umschalten auf ON keine Aktion Umschalten auf OFF keine Aktion keine Aktion Umschalten auf ON keine Aktion Umschalten auf OFF Umschalten auf ON Umschalten auf OFF Umschalten auf ON Umschalten auf OFF Umschalten auf OFF Umschalten auf ON Umschalten auf OFF Umschalten auf OFF Invertieren keine Aktion keine Aktion Invertieren Umschalten auf ON Invertieren Invertieren Umschalten auf ON Invertieren Umschalten auf OFF Umschalten auf OFF Invertieren Invertieren Invertieren Für weitere Informationen siehe: How-To: Schaltpunkte definieren" }, 
{ "title" : "Registerkarte: Nockentabelle ", 
"url" : "_sm_obj_cam_table_tappet_table.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Aufbau des Kurvenscheibeneditors \/ Registerkarte: Nockentabelle ", 
"snippet" : "In diesem Tabelleneditor können Sie alternativ zum grafischen Editor ( Registerkarte: Nocken) die Nockenspuren konfigurieren. Eine Nockenspur definiert eine oder mehrere masterpostionsabhängige Nocken. In der Tabelle folgen jeweils unter der Zeile, die eine Nockenspur definiert, die Zeilen mit den D...", 
"body" : "In diesem Tabelleneditor können Sie alternativ zum grafischen Editor ( Registerkarte: Nocken) die Nockenspuren konfigurieren. Eine Nockenspur definiert eine oder mehrere masterpostionsabhängige Nocken. In der Tabelle folgen jeweils unter der Zeile, die eine Nockenspur definiert, die Zeilen mit den Definitionen der zugehörigen Nocken. Sie können jederzeit zwischen dem Tabelleneditor und dem grafischen Editor wechseln. Fügt eine neue Nocke hinzu Löscht die Nocke Track-ID ID der Nockenspur Alle Nocken einer Nockenspur beziehen sich auf denselben Nockenschalter, eine Variable vom Typ BOOL. X Position der Nocke positiver Durchlauf Ein- und Ausschalt-Attribute keine Aktion Umschalten auf ON Umschalten auf OFF Invertieren negativer Durchlauf Ein- und Ausschalt-Attribute keine Aktion Umschalten auf ON Umschalten auf OFF Invertieren Ansicht Eigenschaften Der Nocke wird ein Ereignis zugeordnet, wenn sie von der Position der Masterachse in positiver (aufsteigende Masterwerte) oder negativer Richtung passiert wird. X Position der Nocke positiver Durchlauf Ein- und Ausschalt-Attribute keine Aktion Umschalten auf ON Umschalten auf OFF Invertieren negativer Durchlauf Ein- und Ausschalt-Attribute keine Aktion Umschalten auf ON Umschalten auf OFF Invertieren Für weitere Informationen siehe: How-To: Schaltpunkte definieren" }, 
{ "title" : "How-To: Kurvenscheibe anlegen ", 
"url" : "_sm_cam_creating_a_cam.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ How-To: Kurvenscheibe anlegen ", 
"snippet" : "Die Schritte zum Erstellen einer Kurvenscheibe werden anhand einer Beispielanwendung erklärt: Die Anwendung beschreibt einen Rundtisch mit 8 Aufnahmen (Teilung 45°). Darin befindet sich ein Bauteil, das mit Ultraschall verschweißt wird. Das Schweißwerkzeug wird über einen Linearantrieb zugestellt, n...", 
"body" : "Die Schritte zum Erstellen einer Kurvenscheibe werden anhand einer Beispielanwendung erklärt: Die Anwendung beschreibt einen Rundtisch mit 8 Aufnahmen (Teilung 45°). Darin befindet sich ein Bauteil, das mit Ultraschall verschweißt wird. Das Schweißwerkzeug wird über einen Linearantrieb zugestellt, nachdem der Rundtisch gedreht hat. Nach der Schweißung fährt die Linearachse wieder zurück und der Rundtisch dreht weiter. Arbeitsschritte Rundtisch dreht 45° (Dauer 400 ms). Schweißkopf wird durch Vertikalachse 250 mm nach unten bewegt (Dauer 200 ms). Start Schweißung, Dauer 1200 ms Schweißkopf wird durch Vertikalachse 250 mm nach oben bewegt (Dauer 200 ms). Mit den angenommen Zeiten ergibt sich eine Taktzeit von 2000 ms. Realisiert wird die Anwendung über eine virtuelle Masterachse, die endlos betrieben wird (modulo). Der Endwert der Achse wird entsprechend der Taktzeit mit 2000 projektiert. Der Rundtisch wird als Kurvenscheibe (modulo, Endwert 45°) ausgeführt. Die Vertikalachse wird ebenfalls als Kurvenscheibe (begrenzt, Endwert 300 mm) ausgeführt. Der Schweißprozess wird über eine Nocke gesteuert. Eigenschaften der Kurvenscheibe einstellen Selektieren Sie im Gerätebaum die Kurvenscheibe Rundtisch . Wählen Sie aus dem Kontextmenü oder dem Menü Ansicht den Befehl Eigenschaften . Wählen Sie die Registerkarte Kurvenscheibe . Geben Sie folgende Werte ein: Master Startposition : 0 Master Endtposition : 2000 Slave Startposition : 0 Slave Endposition : 45 Übergang glätten : (deaktiviert) Schließen Sie den Dialog mit OK . Bestätigen Sie den Dialog zum Ändern des Kurvenscheibenobjekts. Verändern Sie in gleicher Weise die Werte für die Kurvenscheibe Vertikalachse : Master Startposition : 0 Master Endtposition : 2000 Slave Startposition : 0 Slave Endposition : 300 Übergang glätten : (aktiviert) Schließen Sie den Dialog mit OK . Bestätigen Sie den Dialog zum Ändern des Kurvenscheibenobjekts. " }, 
{ "title" : "Kurvenscheibe zum Gerätebaum hinzufügen ", 
"url" : "_sm_cam_creating_a_cam.html#UUID-7c227a8f-47be-4a95-ca96-f0cd1d78635d_id_edb85f246cc9d9f4c0a8646368ed3bd6_id_fa86c256038b2152c0a864632d864483", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ How-To: Kurvenscheibe anlegen \/ Kurvenscheibe zum Gerätebaum hinzufügen ", 
"snippet" : "Voraussetzung: Sie haben eine SoftMotion-Steuerung ausgewählt. Selektieren Sie im Gerätebaum das Objekt Application . Wählen Sie den Befehl Projekt → Objekt hinzufügen → Kurvenscheibentabelle . Geben Sie den Namen Rundtisch für die Kurvenscheibe ein und klicken Sie auf OK . Das Objekt wird im Geräte...", 
"body" : "Voraussetzung: Sie haben eine SoftMotion-Steuerung ausgewählt. Selektieren Sie im Gerätebaum das Objekt Application . Wählen Sie den Befehl Projekt → Objekt hinzufügen → Kurvenscheibentabelle . Geben Sie den Namen Rundtisch für die Kurvenscheibe ein und klicken Sie auf OK . Das Objekt wird im Gerätebaum eingefügt. Der Kurvenscheibeneditor öffnet sich. Fügen Sie eine weitere Kurvenscheibe mit dem Namen Vertikalachse ein. " }, 
{ "title" : "How-To: Kurvenscheibenverlauf ändern ", 
"url" : "_sm_cam_changing_the_course.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ How-To: Kurvenscheibenverlauf ändern ", 
"snippet" : "Die Anweisung beschreibt das Verändern von Kurvenscheiben anhand des Beispiels aus dem Kapitel How-To: Kurvenscheibe anlegen....", 
"body" : "Die Anweisung beschreibt das Verändern von Kurvenscheiben anhand des Beispiels aus dem Kapitel How-To: Kurvenscheibe anlegen. " }, 
{ "title" : "Verlauf mit dem grafischen Editor verändern ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_0e7e8ac72c554f26c0a86463347ccca5", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ How-To: Kurvenscheibenverlauf ändern \/ Verlauf mit dem grafischen Editor verändern ", 
"snippet" : "Öffnen Sie die Kurvenscheibe Rundtisch im Editor. Die Registerkarte Kurvenscheibe ist sichtbar. Selektieren Sie den Punkt bei 120 und löschen Sie ihn mit der Taste Entf . Löschen Sie auch den Punkt bei 240. Wählen Sie das Werkzeug Punkt hinzufügen aus der Ansicht Werkzeuge . Der Mauszeiger wird zum ...", 
"body" : "Öffnen Sie die Kurvenscheibe Rundtisch im Editor. Die Registerkarte Kurvenscheibe ist sichtbar. Selektieren Sie den Punkt bei 120 und löschen Sie ihn mit der Taste Entf . Löschen Sie auch den Punkt bei 240. Wählen Sie das Werkzeug Punkt hinzufügen aus der Ansicht Werkzeuge . Der Mauszeiger wird zum Fadenkreuz, wenn Sie ihn in den Editor bewegen. Klicken Sie in den oberen Graphen (Slaveposition) in die Nähe der Position Masterposition 400, Slaveposition 45. Der Verlauf der Slaveposition wird angepasst. Die Verläufe von Geschwindigkeit, Beschleunigung und Ruck ändern sich ebenfalls. Selektieren Sie den neu eingefügten Punkt durch einen Einfachklick. Ziehen Sie den Punkt mit der Maus auf eine andere Position. Der Verlauf der Slaveposition wird entsprechend angepasst. Ändern Sie die Eigenschaften X und Y auf die exakten Werte 400 und 45. Ändern Sie in der gleichen Weise den X-Wert des Punkts bei Masterposition 2000 auf 45. Wählen Sie das Werkzeug Auswählen aus der Ansicht Werkzeuge . Selektieren Sie das zweite Kurvenelement (zwischen 400 und 2000). Ändern Sie die Eigenschaft Segmenttyp auf Linie . Kontrollieren Sie den Verlauf im grafischen Editor. Darstellung: " }, 
{ "title" : "Verlauf mit der Kurvenscheibentabelle verändern ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_a888a2ff556a11e6abf6d2d0503b3e46", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ How-To: Kurvenscheibenverlauf ändern \/ Verlauf mit der Kurvenscheibentabelle verändern ", 
"snippet" : "Öffnen Sie die Kurvenscheibe Vertikalachse im Editor. Die Registerkarte Kurvenscheibe ist sichtbar. Wählen Sie die Registerkarte Kurvenscheibentabelle . Löschen Sie den Punkt bei 120 durch einen Klick auf das Symbol . Löschen Sie auch den Punkt bei 240. Klicken Sie auf das Symbol . Es wird ein neuer...", 
"body" : "Öffnen Sie die Kurvenscheibe Vertikalachse im Editor. Die Registerkarte Kurvenscheibe ist sichtbar. Wählen Sie die Registerkarte Kurvenscheibentabelle . Löschen Sie den Punkt bei 120 durch einen Klick auf das Symbol . Löschen Sie auch den Punkt bei 240. Klicken Sie auf das Symbol . Es wird ein neuer Punkt bei (1000\/150) und ein neuer Abschnitt eingefügt. Fügen Sie 2 weiteren Punkte hinzu. Ändern Sie die Werte X \/ Y der Punkte: Punkt 1: 0 \/ 0 Punkt 2: 400 \/ 0 Punkt 3: 600 \/ 250 Punkt 4: 1800 \/ 250 Punkt 5: 2000 \/ 0 Der Verlauf der Slaveposition wird angepasst. Der Verlauf von Geschwindigkeit, Beschleunigung und Ruck ändert sich ebenfalls. Ändern Sie in der Kurvenscheibentabelle den Segmenttyp des ersten und dritten Abschnitts auf Linie . Kontrollieren Sie den Verlauf im grafischen Editor. Darstellung: In der Praxis werden sehr oft die Verläufe der verschiedenen Kurvenscheiben überlappend definiert um Taktzeit zu sparen. Im obigen Beispiel könnte die Vertikalachse die Bewegung bereits beginnen, während der Rundtisch noch in Bewegung ist (beispielsweise bei X: 350). " }, 
{ "title" : "How-To: Schaltpunkte definieren ", 
"url" : "_sm_cam_defining_tappets.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ How-To: Schaltpunkte definieren ", 
"snippet" : "Sie verwenden Schaltpunkte, wenn Sie abhängig von der Masterposition Ereignisse auslösen wollen. Dies kann zum Beispiel das Setzen eines Ausgangs oder der Aufruf eines Funktionsbausteins sein. Die Anweisung beschreibt das Definieren von Schaltpunkten anhand des Beispiels aus dem Kapitel How-To: Kurv...", 
"body" : "Sie verwenden Schaltpunkte, wenn Sie abhängig von der Masterposition Ereignisse auslösen wollen. Dies kann zum Beispiel das Setzen eines Ausgangs oder der Aufruf eines Funktionsbausteins sein. Die Anweisung beschreibt das Definieren von Schaltpunkten anhand des Beispiels aus dem Kapitel How-To: Kurvenscheibe anlegen. In diesem Beispiel startet und stoppt die Nocke den Schweißprozess. Öffnen Sie die Kurvenscheibe Vertikalachse im Editor. Die Registerkarte Kurvenscheibe ist sichtbar. Wählen Sie die Registerkarte: Nocken. Wählen Sie das Werkzeug Nocke hinzufügen aus der Ansicht Werkzeuge . Der Mauszeiger wird zum Fadenkreuz, wenn Sie ihn in den Editor bewegen. Klicken Sie unterhalb der Masterposition in die Nähe der Position 600. Es wird eine Nocke auf der Nockenspur 1 eingefügt. Selektieren Sie die Nocke. Ändern Sie die Werte der Nocke in der Ansicht Eigenschaft. X : 600 positiver Durchlauf : Umschalten auf ON negativer Durchlauf : keine Aktion Fügen Sie eine weitere Nocke in der Nockenspur 1 bei X: 1800 ein. X : 1800 positiver Durchlauf : Umschalten auf OFF negativer Durchlauf : keine Aktion Kontrollieren Sie das Ergebnis. Sie können die Werte für positiver Durchlauf und negativer Durchlauf auch durch Klicken auf das betreffende Ende der gekreuzten Linien ändern. Beachten Sie die Möglichkeit, Schaltpunkte auch in der Registerkarte Nockentabelle zu setzen. Dieser Editor bietet Ihnen die gleichen Möglichkeiten, jedoch in tabellarischer Form. " }, 
{ "title" : "Programmatisches Anlegen von Kurvenscheiben ", 
"url" : "_sm_basic_cam_programmatic_creation.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Programmatisches Anlegen von Kurvenscheiben ", 
"snippet" : "Ab CODESYS SoftMotion Version 4.17.0.0 gibt es mit dem Funktionsbaustein CamBuilder eine Schnittstelle zum programmatischen Anlegen von Kurvenscheiben, direkt in der IEC-Applikation. Für weitere Informationen siehe Beispiel Kurvenscheiben programmatisch erstellen...", 
"body" : "Ab CODESYS SoftMotion Version 4.17.0.0 gibt es mit dem Funktionsbaustein CamBuilder eine Schnittstelle zum programmatischen Anlegen von Kurvenscheiben, direkt in der IEC-Applikation. Für weitere Informationen siehe Beispiel Kurvenscheiben programmatisch erstellen" }, 
{ "title" : "Verwendung des Funktionsbausteins CamBuilder (ab SM 4.17.0.0) ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4552813176932834337885510319", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Programmatisches Anlegen von Kurvenscheiben \/ Verwendung des Funktionsbausteins CamBuilder (ab SM 4.17.0.0) ", 
"snippet" : "Folgende Kurvenscheibe wird standardmäßig erzeugt, wenn ein Kurvenscheibenobjekt im Gerätebaum angelegt wird: Die Kurvenscheibe besteht aus drei Polynomen fünften Grades mit den folgenden vier Randwerten X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 Um diese Kurvenscheibe programmatisch zu erz...", 
"body" : "Folgende Kurvenscheibe wird standardmäßig erzeugt, wenn ein Kurvenscheibenobjekt im Gerätebaum angelegt wird: Die Kurvenscheibe besteht aus drei Polynomen fünften Grades mit den folgenden vier Randwerten X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 Um diese Kurvenscheibe programmatisch zu erzeugen, wird zunächst eine Instanz des Funktionsbausteins CamBuilder deklariert: VAR\n camBuilder : SMCB.CamBuilder;\nEND_VAR Im Implementierungsteil muss die CamBuilder -Instanz zunächst initialisiert werden. Danach können drei Segmente vom Typ Poly5 über die Methode Append angehängt werden: camBuilder.Init();\n \ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(120, 120, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(240, 240, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(360, 360))); Die Polynome werden über die linken und rechten Randbedingungen definiert. Im Beispiel wird für den linken Rand immer die Funktion BoundImplicit verwendet. Dadurch wird die rechte Randbedingung des vorherigen Segments übernommen. Wenn für das erste Segment als linken Rand die Funktion BoundImplicit verwendet wird, wird bei Null gestartet: Im vorliegenden Beispiel mit Poly5-Segment bei (X, Y, V, A) = (0, 0, 0, 0). Zur Verwendung mit den Funktionsbausteinen MC_CamTableSelect und MC_CamIn muss die im Funktionsbaustein CamBuilder definierte Kurvenscheibe schließlich in eine MC_CamRef überführt werden. Dafür gibt es, je nachdem wo der CamBuilder aufgerufen wird, zwei Möglichkeiten: Aufruf des CamBuilders in der Bustask: Zuerst muss der Deklarationsteil um entsprechende Instanzen erweitert werden: VAR\n    ...\n    camRef : MC_CAM_REF;\n    aCamSegments : ARRAY[1..3] OF SMC_CAM_SEGMENT;\nEND_VAR Danach wird die Funktionsbausteininstanz MC_CAM_REF initialisiert und mit der Methode Write des Funktionsbausteins CamBuilder geschrieben. SMCB.InitCamRef(camRef, ADR(aCamSegments), XSIZEOF(aCamSegments));\ncamBuilder.Write(camRef); Aufruf des CamBuilders in einer anderen Task (Multitask, Multicore): Zuerst wird in einer GVL eine Multitask\/Multicore sichere Instanz der Kurvenscheibe angelegt, auf die sowohl die Bustask als auch die CamBuilder-Task zugreifen. VAR_GLOBAL\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR Aus der Bustask wird nun das Erstellen der Kurvenscheibe in der anderen Task gestartet. Damit in der Bustask festgestellt werden kann, wann die neue Kurvenscheibe in der anderen Task fertig geschrieben wurde, merkt sich das Programm in STATE_INIT_ONLINE_TABLE_MULTITASK die  CamId vor dem Erstellen der Kurvenscheibe. Anschließend wird im Zustand STATE_START_CREATE_ONLINE_TABLE_MULTITASK das Erstellen der Kurvenscheibe in der anderen Task gestartet. Abschließend wird im Zustand STATE_READ_ONLINE_TABLE_MULTITASK die erstellte Kurvenscheibe ausgelesen. PROGRAM BUS_TASK\nVAR\n    state : UDINT;\n    error : SMC_ERROR;\n    camIdBeforeCreate : UDINT;\n    camSegments: ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    camRef: MC_CAM_REF;\nEND_VAR\nVAR CONSTANT\n    STATE_INIT_ONLINE_TABLE_MULTITASK : UDINT := 0;\n    STATE_START_CREATE_ONLINE_TABLE_MULTITASK : UDINT := 10;\n    STATE_READ_ONLINE_TABLE_MULTITASK : UDINT := 20;\n    STATE_ERROR : UDINT := 1000;\nEND_VAR\n\n\nCASE state OF\nSTATE_INIT_ONLINE_TABLE_MULTITASK:\n    camIdBeforeCreate := GVL.safeCam.CamId;\n\n    state := STATE_START_CREATE_ONLINE_TABLE_MULTITASK;\n\nSTATE_START_CREATE_ONLINE_TABLE_MULTITASK:\n    CamBuilderTask.BuildCam := TRUE;\n\n    state := STATE_READ_ONLINE_TABLE_MULTITASK;\n\nSTATE_READ_ONLINE_TABLE_MULTITASK:\n    IF CamBuilderTask.Error THEN\n        error := CamBuilderTask.ErrorId;\n        state := state + STATE_ERROR;\n    ELSIF GVL.safeCam.CamId <> camIdBeforeCreate THEN\n        error := GVL.safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n        IF error = SMC_NO_ERROR THEN\n            state := state + 10;\n        ELSE\n            state := state + STATE_ERROR;\n        END_IF\n    END_IF\nEND_CASE In der CamBuilder-Task wird die Multitask\/Multicore sichere Kurvenscheibe mit dem Aufruf CamBuilder.WriteMulticoreSafe() geschrieben: PROGRAM CamBuilderTask\nVAR_INPUT\n    BuildCam : BOOL;\nEND_VAR\nVAR_OUTPUT\n    Error : BOOL;\n    ErrorId : SMC_ERROR;\nEND_VAR\nVAR\n    camBuilder : SMCB.CamBuilder;\nEND_VAR\n\nIF BuildCam THEN\n    BuildCam := FALSE;\n\n    camBuilder.Init();\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(120, 120, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(240, 240, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(360, 360)));\n     \n Error := camBuilder.IsErrorPending(errorID=> ErrorId);\n\n    IF NOT Error THEN\n        ErrorId := camBuilder.WriteMulticoreSafe(GVL.safeCam);\n        Error := ErrorId <> SMC_NO_ERROR;\n    END_IF\nEND_IF " }, 
{ "title" : "Implizite und explizite Randbedingungen ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930557874", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Programmatisches Anlegen von Kurvenscheiben \/ Verwendung des Funktionsbausteins CamBuilder (ab SM 4.17.0.0) \/ Implizite und explizite Randbedingungen ", 
"snippet" : "Eine mit BoundImplicit definierte implizite Randbedingung führt dazu, dass der Übergang zum angrenzenden Segment so glatt wie möglich ist. Dafür muss die Randbedingung des angrenzenden Segments explizit über die Methode Bound definiert sein. Wenn also die linke Randbedingung eines Segments implizit ...", 
"body" : "Eine mit BoundImplicit definierte implizite Randbedingung führt dazu, dass der Übergang zum angrenzenden Segment so glatt wie möglich ist. Dafür muss die Randbedingung des angrenzenden Segments explizit über die Methode Bound definiert sein. Wenn also die linke Randbedingung eines Segments implizit ist, muss die rechte Randbedingung des vorherigen Segments explizit sein. Umgekehrt muss bei einer impliziten rechten Randbedingung die linke Randbedingung des nachfolgenden Segments explizit sein. Der häufigste Anwendungsfall ist vermutlich, dass wie im obigen Beispiel nur die rechten Randbedingungen der Segmente explizit angegeben werden. Durch die impliziten linken Randbedingungen sind die Segmentübergänge automatisch so glatt wie möglich und es gibt keine Lücken im Definitionsbereich. Ein einfaches Beispiel, bei dem es hilfreich ist, von diesem Vorgehen abzuweichen, ist das folgende: Die Slaveachse soll von Position 20 bis 100 mit konstanter Geschwindigkeit fahren: camBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100))); Davor und danach soll mit einem Segment vom Typ Poly5 beschleunigt und verzögert werden: camBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.BoundImplicit()));\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(120, 120, 0))); Die so definierte Kurvenscheibe hat unerwünschte Beschleunigungs- und Verzögerungsphasen in den Poly5-Segmenten (Geschwindigkeit in blau): Um diese zu vermeiden, reicht es, im Segment vom Typ Line die Masterposition anzupassen, beispielsweise die des linken Rands von 20 auf 30 und die es rechten Rands von 100 auf 90: ...\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(30, 20),\n SMCB.Bound(90, 100)));\n... Eine Anpassung der Segmente vom Typ Poly5 ist nicht nötig, weil sie aufgrund der über die Funktion BoundImplicit definierten Randbedingungen automatisch so glatt wie möglich an das Line-Segment angefügt werden. " }, 
{ "title" : "Fehlerbehandlung ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930649954", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Programmatisches Anlegen von Kurvenscheiben \/ Verwendung des Funktionsbausteins CamBuilder (ab SM 4.17.0.0) \/ Fehlerbehandlung ", 
"snippet" : "Die Methode Append des Funktionsbausteins CamBuilder gibt TRUE zurück, wenn ein Segment erfolgreich angehängt wurde, und FALSE , wenn es einen Fehler gab. Nach einem Fehler können keine weiteren Segmente angehängt werden und der Funktionsbaustein CamBuilder muss über die Methode Init neu initialisie...", 
"body" : "Die Methode Append des Funktionsbausteins CamBuilder gibt TRUE zurück, wenn ein Segment erfolgreich angehängt wurde, und FALSE , wenn es einen Fehler gab. Nach einem Fehler können keine weiteren Segmente angehängt werden und der Funktionsbaustein CamBuilder muss über die Methode Init neu initialisiert werden. Die Fehlerursache kann über die Methode IsErrorPending ermittelt werden: camBuilder.IsErrorPending(errorId=> errorId); " }, 
{ "title" : "Manuelles Anlegen der Datenstruktur MC_CAM_REF (vor SM 4.17.0.0) ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4565212026644834337937734299", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Programmatisches Anlegen von Kurvenscheiben \/ Manuelles Anlegen der Datenstruktur MC_CAM_REF (vor SM 4.17.0.0) ", 
"snippet" : "Es wird empfohlen, ab CODESYS SoftMotion 4.17.0.0 die Bibliothek SM3_CamBuilder zu verwenden....", 
"body" : "Es wird empfohlen, ab CODESYS SoftMotion 4.17.0.0 die Bibliothek SM3_CamBuilder zu verwenden. " }, 
{ "title" : "Datenstrukturen der Kurvenscheibe ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793858538", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Programmatisches Anlegen von Kurvenscheiben \/ Manuelles Anlegen der Datenstruktur MC_CAM_REF (vor SM 4.17.0.0) \/ Datenstrukturen der Kurvenscheibe ", 
"snippet" : "Mit dem Übersetzen des Projekts werden die erstellten Kurvenscheibendaten intern in eine globale Variablenliste umgewandelt. Mit dem Befehl Zeige generierten Code an im Kurvenscheibeneditor können Sie die automatisch erzeugten globalen Variablen anzeigen. Jede Kurvenscheibe wird repräsentiert durch ...", 
"body" : "Mit dem Übersetzen des Projekts werden die erstellten Kurvenscheibendaten intern in eine globale Variablenliste umgewandelt. Mit dem Befehl Zeige generierten Code an im Kurvenscheibeneditor können Sie die automatisch erzeugten globalen Variablen anzeigen. Jede Kurvenscheibe wird repräsentiert durch die Datenstruktur MC_CAM_REF . Sie können auf diese Datenstruktur mittels IEC-Programm, aber auch durch Vorverarbeitungsfunktionen und Funktionsbausteine zugreifen. Sie wird von der Bibliothek SM3_Basic zur Verfügung gestellt. Ein Funktionsbaustein, der eine Kurvenscheibe beschreibt, kann auch vom IEC-Programm zur Laufzeit erzeugt oder befüllt werden. Beispiel Definition der Datenstuktur: TYPE mySMC_CAMTable_LREAL_10000_2 :\nSTRUCT\n Table: ARRAY[0..9999] OF ARRAY[0..1] OF LREAL;\n (* set all scaling definitions to 0 and 1\n result: all values of the table are not scaled *)\n fEditorMasterMin: REAL := 0;\n fEditorMasterMax: REAL := 1;\n fEditorSlaveMin: REAL := 0;\n fEditorSlaveMax: REAL := 1;\n fTableMasterMin: REAL := 0;\n fTableMasterMax: REAL := 1;\n fTableSlaveMin: REAL := 0;\n fTableSlaveMax: REAL := 1;\nEND_STRUCT\nEND_TYPE Instanziierung der Datenstruktur: Cam: MC_CAM_REF;\nCam_PointArray : mySMC_CAMTable_LREAL_10000_2; Berechnung einer Kurvenscheibe: Cam.byType:=2;\nCam.byVarType:=6;\nCam.nTappets:=0;\nCam.strCAMName:='myCAM';\nCam.pce:= ADR(CAM_PointArray);\nFOR i:=0 TO 9999 DO\n (* example cam: master 0..360, slave 0..100,\n constant velocity *)\n Cam_PointArray.Table[i][0]:=UDINT_TO_LREAL(I)\/10000 * 360; (* X *)\n Cam_PointArray.Table[i][1]:=UDINT_TO_LREAL(I)\/10000 * 100; (* Y *)\nEND_FOR\nCam.nElements:=10000\nCam.xStart:=0.0;\nCam.xEnd:=360.0; " }, 
{ "title" : "Manuell erzeugte Kurvenscheibe ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793936406", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Programmatisches Anlegen von Kurvenscheiben \/ Manuelles Anlegen der Datenstruktur MC_CAM_REF (vor SM 4.17.0.0) \/ Manuell erzeugte Kurvenscheibe ", 
"snippet" : "Eine Kurvenscheibe kann ohne Verwendung des Kurvenscheibeneditors in einem IEC-Programm erzeugt werden. Beispiel Deklaration: VAR i: INT; CAM: MC_CAM_REF := ( byType:=2, (* non-equidistant *) byVarType:=2, (* UINT *) nElements:=128, xStart:=0, xEnd:=360); Table: SMC_CAMTable_UINT_128_2 := ( fEditorM...", 
"body" : "Eine Kurvenscheibe kann ohne Verwendung des Kurvenscheibeneditors in einem IEC-Programm erzeugt werden. Beispiel Deklaration: VAR\ni: INT;\nCAM: MC_CAM_REF := (\n byType:=2, (* non-equidistant *)\n byVarType:=2, (* UINT *)\n nElements:=128,\n xStart:=0,\n xEnd:=360);\nTable: SMC_CAMTable_UINT_128_2 := (\n fEditorMasterMin := 0, fEditorMasterMax := 360,\n fTableMasterMin := 0, fTableMasterMax := 6000,\n fEditorSlaveMin := 0, fEditorSlaveMax := 360,\n fTableSlaveMin := 0, fTableSlaveMax := 6000);\nEND_VAR Implementierung: (* Create cam disk (example straight line); unambiguous *)\nFOR i:=0 TO 127 DO\n Table.Table[i][0] := Table.Table[i][1] := REAL_TO_UINT(i \/ 127.0 * 6000);\nEND_FOR\n(* Link pointer; must be done in every cycle! *)\nCAM.pce := ADR(Table); Diese so erzeugte Kurvenscheibe kann in den Baustein MC_CamTableSelect eingegeben und dessen Ausgang wieder für MC_CamIn verwendet werden. " }, 
{ "title" : "Kompilieren einer Kurvenscheibendefinition ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793975398", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Programmatisches Anlegen von Kurvenscheiben \/ Manuelles Anlegen der Datenstruktur MC_CAM_REF (vor SM 4.17.0.0) \/ Kompilieren einer Kurvenscheibendefinition ", 
"snippet" : "Während des Kompilierens werden für eine Kurvenscheibe Variablen des Typs MC_CAM_REF angelegt. Sie enthalten eine Beschreibung jedes Segments der Kurvenscheibe. Datenstrukturen dieser Art werden dem Funktionsbaustein MC_CamTableSelect übergeben. Die Struktur ist Teil der Bibliothek SM3_Basic ....", 
"body" : "Während des Kompilierens werden für eine Kurvenscheibe Variablen des Typs MC_CAM_REF angelegt. Sie enthalten eine Beschreibung jedes Segments der Kurvenscheibe. Datenstrukturen dieser Art werden dem Funktionsbaustein MC_CamTableSelect übergeben. Die Struktur ist Teil der Bibliothek SM3_Basic . " }, 
{ "title" : "Umschalten zwischen Kurvenscheiben ", 
"url" : "_sm_cam_switch_between_cams.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Umschalten zwischen Kurvenscheiben ", 
"snippet" : "Grundsätzlich können Sie jederzeit zwischen verschiedenen Kurvenscheiben umschalten. Dabei sollten Sie jedoch Folgendes beachten: Im Kurvenscheibeneditor ist die Position des Slaves eindeutig definiert als Funktionswert der Kurvenscheibenfunktion. Diese Funktion ist auf dem Masterwertebereich defini...", 
"body" : "Grundsätzlich können Sie jederzeit zwischen verschiedenen Kurvenscheiben umschalten. Dabei sollten Sie jedoch Folgendes beachten: Im Kurvenscheibeneditor ist die Position des Slaves eindeutig definiert als Funktionswert der Kurvenscheibenfunktion. Diese Funktion ist auf dem Masterwertebereich definiert und kann folgendermaßen ausgedrückt werden: SlavePosition = CAM( MasterPosition ) Da die aktuelle Position des Masterantriebs üblicherweise vom Masterwertebereich abweicht, müssen Sie die Masterposition auf den Definitionsbereich der Kurvenscheibenfunktion skalieren, um ein gültiges Argument darzustellen: SlavePosition = CAM( MasterScale*MasterPosition + MasterOffset ) In analoger Weise müssen Sie den Funktionswert (die Slaveposition) skalieren, wenn der Start der Kurvenscheibe im Modus absolute zu einem Sprung führen würde: SlavePosition = SlaveScale*CAM( MasterPosition ) + SlaveOffset Möglicherweise müssen Sie beide Skalierungen anwenden, woraus dann folgt: Slaveposition = SlaveScale*CAM( MasterScale*Masterposition + MasterOffset ) + SlaveOffset Die geeigneten Werte für Skalierungs- und Offsetparameter können von Periode zu Periode variieren. Ein Umschalten zwischen Kurvenscheiben kann auf drei Arten erfolgen: Die zweite Kurvenscheibe über eine zweite Instanz von MC_CamIn mit BufferMode = MC_BUFFER_MODE.Buffered , StartMode = relative , MasterAbsolute = FALSE und SlaveAbsolute = FALSE starten. Ab CODESYS SoftMotion Version 4.17.0.0 Start der neuen Kurvenscheibe über das Zuweisen von MC_CamIn.CamTableID auf die neue Kurvenscheibe (kein Neustart des Funktionsbausteins MC_CamIn erforderlich). Diese Variante wird empfohlen, wenn folgende Punkte auf Ihren Anwendungsfall zutreffen: Alle folgenden Kurvenscheiben sollen relativ mit MasterAbsolute = FALSE oder SlaveAbsolute = FALSE ausgeführt werden. Die neue Kurvenscheibe soll exakt am Ende der vorherigen beginnen. Es werden keine weiteren Parameter (beispielsweise SlaveOffset ) verändert. Der Sprung, der im nachfolgenden Beispiel für periodische Kurvenscheiben und SlaveAbsolute = FALSE erläutert wird, gilt nicht für diese Variante, da exakt an die Endpositionen der vorherigen Kurvenscheibe angesetzt wird. Die neue Kurvenscheibe wird nur exakt an das Ende der vorherigen Kurvenscheibe angesetzt, wenn die Umschaltung zur neuen Kurvenscheibe im selben Zyklus erfolgt, in dem die vorherige Kurvenscheibe EndOfProfile = TRUE meldet. Start der neuen Kurvenscheibe über einen Neustart des Funktionsbausteins MC_CamIn . Diese Variante wird empfohlen, wenn für die korrekte Funktion der neuen Kurvenscheibe Parameter verändert werden müssen (beispielsweise SlaveOffset vom nachfolgenden Beispiel). Es gelten die Einschränkungen des nachfolgenden Beispiels. Beispiel In folgendem Beispiel wird von Kurvenscheibe CAM1 zu CAM2 gewechselt: CAM1 besteht aus einem Polynom 5. Grades gefolgt von zwei Geradenstücken. CAM2 besteht aus zwei Geradenstücken gefolgt von einem Polynom 5. Grades. Beim Umschalten zwischen den beiden Kurvenscheiben sollten Sie Folgendes berücksichtigen: Um Sprünge zu vermeiden, sollen die Werte von Geschwindigkeit und Beschleunigung am Endpunkt der ersten Kurvenscheibe mit den Werten am Anfangspunkt der zweiten Kurvenscheibe übereinstimmen. Im Beispiel ist diese Bedingung erfüllt, da dem Endpunkt von CAM1 und dem Startpunkt von CAM2 dieselbe Geschwindigkeit (=1) und Beschleunigung (=0) zugeordnet ist. Sie können die zweite Kurvenscheibe im Modus relativ starten, wenn Sie die Startposition des Slaves mit 0 definiert haben. Dabei muss die erste Kurvenscheibe jedoch im Modus non-periodic laufen. Anderenfalls, wenn CAM1 periodisch wäre, resultiert die Einstellung relative in einem Sprung. Die Vergrößerung zeigt den Übergang von CAM1 zu CAM2 . Die blauen Linien markieren die Auswertungen der Kurvenscheibenfunktionen an den Masterpositionen x1 und x2 . Wir betrachten zunächst den ungünstigen periodic Fall: MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=TRUE); Der Aufruf bedingt eine Auswertung der Kurvenscheibe an der Masterposition x1 , die kleiner ist als die Endposition des Masters von CAM1 . So erfolgt die Auswertung von CAM1 standardmäßig und liefert Punkt 1 als Position für den Slave. CAM(x2, CAM1, PERIODIC:=TRUE); Beim folgenden Aufruf des Moduls liegt die Masterposition x2 außerhalb des Masterwertebereichs von CAM1 , dessen Grenze durch die grüne gestrichelte Linie markiert ist und mit der Abszisse des Punkts 3p übereinstimmt. Demzufolge ist das Flag EndOfProfile gesetzt. Da CAM1 im Modus periodic gestartet wurde, erfolgt ihr Neustart am Ende des Wertebereichs, was schließlich den Punkt 2p als Ergebnis des Modulaufrufs liefert. CAM(EXECUTE:=FALSE); Wechsel zur neuen Kurvenscheibe CAM(x2, CAM2, PERIODIC:=TRUE); Zweite Auswertung an der Masterposition x2 . Diesmal wird die neue Kurvenscheibe CAM2 ausgewertet. Nachdem CAM2 im Modus relative gestartet wurde, wird die aktuelle Position ( 2p ) des Slaves als Offset zum Bild der Kurvenscheibenfunktion von CAM2 addiert. Dadurch wird der Startpunkt ihres Graphen verschoben auf den Punkt 3p und ihre Auswertung an der Masterposition x2 liefert den Punkt 4p und somit einen unerwünschten Sprung. Wählen Sie den Modus non-periodic um Sprünge zu vermeiden: MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=FALSE); Der Aufruf bedingt eine Auswertung der Kurvenscheibe an der Masterposition x1 , die kleiner ist als die Endposition des Masters von CAM1 . So erfolgt die Auswertung von CAM1 standardmäßig und liefert Punkt 1 als Position für den Slave. CAM(x2, CAM1, PERIODIC:=FALSE); Beim folgenden Aufruf des Moduls liegt die Masterposition x2 außerhalb des Masterwertebereichs von CAM1 , dessen Grenze durch die grüne gestrichelte Linie markiert ist und mit der Abszisse des Punktes 3n übereinstimmt. Demzufolge ist das Flag EndOfProfile gesetzt.  Da CAM1 im Modus non-periodic gestartet wurde, ist die der Masterposition x2 zugeordnete Slaveposition ( 2n ) identisch mit der Position des Slaves beim Erreichen des Endes des Wertebereichs von CAM1 ( 3n ). CAM(EXECUTE:=FALSE); Wechsel zur neuen Kurvenscheibe. CAM(x2, CAM2, PERIODIC:=FALSE); Zweite Auswertung an der Masterposition x2 . Diesmal wird die neue Kurvenscheibe CAM2 ausgewertet. Nachdem CAM2 im Modus relative gestartet wurde, wird die aktuelle Position ( 2n ) des Slaves als Offset zum Bild der Kurvenscheibenfunktion von CAM2 addiert. Dadurch wird der Startpunkt ihres Graphen verschoben auf den Punkt 3n und ihre Auswertung an der Masterposition x2 liefert den Punkt 4n , der auf der durch die Punkte 1 und 3n bestimmten Geraden liegt. Wenn Sie die Kurvenscheiben im Modus absolute starten wollen, müssen Sie auf eine passende Startposition des Slaves achten. Falls der Wertebereich des Masters gerade mit der Periode des Slaves übereinstimmt, wird der Wechsel zwischen den Kurvenscheiben keinerlei Komplikationen mit sich bringen, unabhängig davon, ob die Kurvenscheiben periodisch sind oder nicht. In obigem Beispiel können Sie CAM2 im Modus absolute starten, wenn die Perioden von Master und Slave mit dem Masterwertebereich von CAM2 übereinstimmen, also jeweils 360° betragen. Ansonsten, beispielsweise wenn die Periode des Slaves 270° beträgt (angedeutet durch die hellblauen Linien), ist die Option absolute nicht zulässig, ohne weitere Maßnahmen zu treffen. In diesem Fall befindet sich der Slave beim Wechsel von CAM1 zu CAM2 bei 90°. Der Start von CAM2 im Modus absolute bewirkt seinen Sprung auf 0° (angezeigt durch graue Gerade). Der Sprung kann allerdings verhindert werden, indem Sie den Offset des Slaves auf den passenden Wert von 90° setzen. " }, 
{ "title" : "Periodische Kurvenscheiben ", 
"url" : "_sm_basic_periodic_cams.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Periodische Kurvenscheiben ", 
"snippet" : "Eine Kurvenscheibe kann wiederholt abgefahren werden, wenn der Eingang Periodic des Funktionsbausteins MC_CamTableSelect auf TRUE gesetzt wird. Dann wird die Kurvenscheibe nach Erreichen der Endposition automatisch neu gestartet. Wenn dieser Eingang FALSE ist, wird beim Erreichen der Endposition des...", 
"body" : "Eine Kurvenscheibe kann wiederholt abgefahren werden, wenn der Eingang Periodic des Funktionsbausteins MC_CamTableSelect auf TRUE gesetzt wird. Dann wird die Kurvenscheibe nach Erreichen der Endposition automatisch neu gestartet. Wenn dieser Eingang FALSE ist, wird beim Erreichen der Endposition des Masters die Ausgangsvariable EndOfProfile des Funktionsbausteins MC_CamIn auf TRUE gesetzt. Der Slave verharrt auf seiner aktuellen Position. Beachten Sie, dass durch das Verlassen des Masterwertebereichs die Aktivität der Kurvenscheibe nicht beendet wird: Wenn der Führungsantrieb wieder in den Bereich der Masterwerte eintritt, folgt der Folgeantrieb wieder der Kurvenscheibe. Verhalten bei Slave.EndPosition <> Slave.StartPosition : Der Funktionsbaustein MC_CamIn berechnet am Ende einer Periode einen internen Offset. In der darauf folgenden Periode wird die Kurvenscheibe um diesen Offset verschoben, damit sie an der aktuellen Position des Slaves anknüpft und somit Sprünge vermieden werden. Bei einer periodischen Kurvenscheibe können Sie die Option Übergang glätten in den Eigenschaften der Kurvenscheibe aktivieren. Damit wird vermieden, dass beim Übergang von einer zur anderen Periode ein Sprung auftritt. Der Slave hat dann an der Endposition dieselbe Geschwindigkeit und Beschleunigung wie an der Startposition. Periode und Vorschub werden in der Einheit der Slaveskalierung gemessen. Selbst wenn Sie die Option Übergang glätten nicht aktivieren, kann die Kurvenscheibe fortlaufend abgefahren werden. In diesem Fall ist es Ihre Aufgabe die Konsistenz der Übergänge in ausreichendem Maß sicherzustellen. " }, 
{ "title" : "Visualisierungselement Online-Kurvenscheibeneditor ", 
"url" : "_sm_cam_visu_elem_online_cam.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Visualisierungselement Online-Kurvenscheibeneditor ", 
"snippet" : "Der Online-Kurvenscheibeneditor ist eine Visualisierungsvorlage, die eine Kurvenscheibe in der Visualisierung anzeigt. Mit diesem Element können Sie die Kurvenscheibe im Onlinebetrieb verändern. Das Visualisierungselement wird in einer Visualisierungsvorlage ( SMC_VISU_CamEditor ) der Bibliothek SM3...", 
"body" : "Der Online-Kurvenscheibeneditor ist eine Visualisierungsvorlage, die eine Kurvenscheibe in der Visualisierung anzeigt. Mit diesem Element können Sie die Kurvenscheibe im Onlinebetrieb verändern. Das Visualisierungselement wird in einer Visualisierungsvorlage ( SMC_VISU_CamEditor ) der Bibliothek SM3_Basic_Visu zur Verfügung gestellt. Sie finden es im Visualisierungseditor in der Ansicht Werkzeuge unter dem Kennzeichen SM3_Basic_Visu . Der SMC_Visu_CamEditor wird über einen Frame in die Visualisierung eingefügt. Für weitere Informationen zu diesem Visualisierungselement siehe: Visualisierungselement Frame . Zusätzlich zu den Eigenschaften des Frame-Elements besitzt diese Vorlage folgende Eigenschaften: Eigenschaft Beschreibung safeCam Referenz auf die zu editierende Kurvenscheibe showPosition Boolesche Variable zum Ein- und Ausschalten der Darstellung des Positionsverlaufs showVelocity Boolesche Variable zum Ein- und Ausschalten der Darstellung des Geschwindigkeitsverlaufs showAcceleration Boolesche Variable zum Ein- und Ausschalten der Darstellung des Beschleunigungsverlaufs showJerk Boolesche Variable zum Ein- und Ausschalten der Darstellung des Ruckverlaufs showSelectedSegment Boolesche Variable zum Ein- und Ausschalten der Hervorhebung des selektierten Segments Die zu editierende Kurvenscheibe wird über eine Instanz des Funktionsbausteins SMCB.CAM_REF_MULTICORE_SAFE übergeben. PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR " }, 
{ "title" : "Kurvenscheibeneditor im Onlinebetrieb ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_id_ba4cc02c6ccda90bc0a864637badf4e0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Visualisierungselement Online-Kurvenscheibeneditor \/ Kurvenscheibeneditor im Onlinebetrieb ", 
"snippet" : "Im Onlinebetrieb lassen sich die einzelnen Segmente der Kurvenscheibe im Graphen selektieren. Über den Segmenteditor auf der rechten Seite lassen sich Segmente hinzufügen und löschen sowie die Randbedingungen des selektierten Segments anpassen. (1) Kurvenscheibe laden Lädt die konfigurierte Kurvensc...", 
"body" : "Im Onlinebetrieb lassen sich die einzelnen Segmente der Kurvenscheibe im Graphen selektieren. Über den Segmenteditor auf der rechten Seite lassen sich Segmente hinzufügen und löschen sowie die Randbedingungen des selektierten Segments anpassen. (1) Kurvenscheibe laden Lädt die konfigurierte Kurvenscheibe in den Editor (2) Kurvenscheibe speichern Speichert die editierte Kurvenscheibe (3) Statusleiste Zeigt Statusnachrichten an (4) Segmentauswahl Über die Pfeile kann ein Segment ausgewählt werden. Über die Combobox kann der Segmenttyp verändert werden. (5) Masterposition Die Masterposition am linken und rechten Rand des Segments (6) Slaveposition Die Slaveposition am linken und rechten Rand des Segments. (7) Slavegeschwindigkeit Die Slavegeschwindigkeit am linken und rechten Rand des Segments. Nicht bei allen Segmenttypen editierbar. (8) Slavebeschleunigung Die Slavebeschleunigung am linken und rechten Rand des Segments. Nicht bei allen Segmenttypen editierbar. (9) Slaveruck Der Slaveruck am linken und rechten Rand des Segments. Nicht bei allen Segmenttypen editierbar. (10) Parameter Lambda Parameter Lambda für die modifizierte Sinuslinie. (11) Split Teilt das selektierte Segment in zwei Segmente. (12) Delete Löscht das selektierte Segment. " }, 
{ "title" : "Erstellte Kurvenscheibe in der Applikation verwenden ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_section-idm234870310600632", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Synchrone Bewegungen von zwei Achsen \/ Kurvenscheiben \/ Visualisierungselement Online-Kurvenscheibeneditor \/ Erstellte Kurvenscheibe in der Applikation verwenden ", 
"snippet" : "Sie können die mit dem Visualisierungselement SMC_Visu_CamEditor erstellte Kurvenscheibe in der Applikation verwenden, indem Sie die Methode GetCopy der Instanz CAM_REF_MULTICORE_SAFE aufrufen. PROGRAM PLC_PRG VAR     safeCam : SMCB.CAM_REF_MULTICORE_SAFE;     camRef : MC_CAM_REF;     camSegments : ...", 
"body" : "Sie können die mit dem Visualisierungselement SMC_Visu_CamEditor erstellte Kurvenscheibe in der Applikation verwenden, indem Sie die Methode GetCopy der Instanz CAM_REF_MULTICORE_SAFE aufrufen. PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\n    camRef : MC_CAM_REF;\n    camSegments : ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    error : SMC_ERROR;\nEND_VAR\n\nIF safeCam.CamId <> oldCamId THEN\n     error :=\n         safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n oldCamId := safeCam.CamId;\nEND_IF Im Programm wird zunächst überprüft, ob eine neue Kurvenscheibe erstellt wurde ( CamId <> oldCamID ). Wenn das der Fall ist, wird mit der Methode GetCopy eine Kopie dieser Kurvenscheibe erstellt. Wenn der Aufruf SMC_NO_ERROR zurück gibt, kann die Instanz camRef des Funktionsbausteins MC_CAM_REF mit den SoftMotion-Kurvenscheiben-Bausteinen MC_CamTableSelect und MC_CamIn verwendet werden. Der Aufruf GetCopy ist tasksicher und muss deshalb nicht aus der Visu-Task erfolgen. " }, 
{ "title" : "Kommandierung mehrerer Bewegungen ", 
"url" : "_sm_basic_mulitple_movements.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Übersicht ", 
"url" : "_sm_overview_mulitple_movements.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen \/ Übersicht ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "BufferMode ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844820766", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen \/ Übersicht \/ BufferMode ", 
"snippet" : "Einige Funktionsbausteine haben einen Eingang BufferMode , über den die zeitliche Abfolge von Bewegungen geregelt wird. Der BufferMode definiert, ob der Funktionsbaustein im nicht gepufferten Modus („Aborting“, Standardverhalten) oder im gepufferten Modus („Buffered“) arbeitet. Der Unterschied diese...", 
"body" : "Einige Funktionsbausteine haben einen Eingang BufferMode , über den die zeitliche Abfolge von Bewegungen geregelt wird. Der BufferMode definiert, ob der Funktionsbaustein im nicht gepufferten Modus („Aborting“, Standardverhalten) oder im gepufferten Modus („Buffered“) arbeitet. Der Unterschied dieser zwei Modi ist der Zeitpunkt, wenn sie ihre Aktionen beginnen: „Non-buffered Mode“: Der Bewegungsbefehl wirkt sofort, auch wenn dadurch eine andere Bewegung unterbrochen wird. Der Puffer der kommandierten Bewegungen wird gelöscht. „Buffered Mode“: Der Bewegungsbefehl wartet, bis der aktuelle Funktionsbaustein seinen Ausgang Done (oder InPosition , oder InVelocity usw.) setzt. Über die BufferModes wird ebenfalls festgelegt, wie der Geschwindigkeitsverlauf am Übergang der Bewegungen aussehen soll. Der Eingang BufferMode ist ein ENUM vom Typ MC_BUFFER_MODE. Aborting Standardmodus ohne Buffering. Der Funktionsbaustein startet sofort und bricht eine laufende Bewegung ab. Der Befehl wirkt sich sofort auf die Achse aus. Buffered Der Funktionsbaustein startet, sobald die letzte zuvor kommandierte Bewegung beendet wurde. Es findet kein Überblenden statt. Die neue Bewegung startet mit der Geschwindigkeit, die die vorhergehende Bewegung beim Erreichen der Endbedingung ( Done , InVelocity , InEndVelocity , InGear , InSync , EndOfProfile etc.) hat. Wenn die vorhergehende Bewegung ein MC_MoveAbsolute oder MC_MoveRelative war, dann startet die neue Bewegung also im Stillstand. BlendingLow Der Funktionsbaustein startet, sobald die letzte zuvor kommandierte Bewegung beendet wurde. Die Achse stoppt zwischen den Bewegungen nicht, sondern durchläuft die Endposition der ersten Bewegung mit der niedrigeren Geschwindigkeit der beiden Bewegungsbefehle. BlendingPrevious Der Funktionsbaustein startet, sobald die letzte zuvor kommandierte Bewegung beendet wurde. Die Achse stoppt zwischen den Bewegungen nicht, sondern durchläuft die Endposition der ersten Bewegung mit der Geschwindigkeit des ersten Bewegungsbefehls. BlendingNext Der Funktionsbaustein startet, sobald die letzte zuvor kommandierte Bewegung beendet wurde. Die Achse stoppt zwischen den Bewegungen nicht, sondern durchläuft die Endposition der ersten Bewegung mit der Geschwindigkeit des zweiten Bewegungsbefehls. BlendingHigh Der Funktionsbaustein startet, sobald die letzte zuvor kommandierte Bewegung beendet wurde. Die Achse stoppt zwischen den Bewegungen nicht, sondern durchläuft die Endposition der ersten Bewegung mit der höheren Geschwindigkeit der beiden Bewegungsbefehle. " }, 
{ "title" : "Unterstützte Funkionsbausteine ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844838676", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen \/ Übersicht \/ BufferMode \/ Unterstützte Funkionsbausteine ", 
"snippet" : "Alle Funktionsbausteine, die als Buffered\/Blending-Befehle spezifiziert werden können, besitzen die folgenden Ein- und Ausgänge: Eingang BufferMode (Typ MC_BUFFER_MODE ) Ausgang Active : (Typ BOOL ) Ein Befehl wird akzeptiert, wenn der Funktionsbaustein in den Zustand Busy übergeht, nachdem eine neu...", 
"body" : "Alle Funktionsbausteine, die als Buffered\/Blending-Befehle spezifiziert werden können, besitzen die folgenden Ein- und Ausgänge: Eingang BufferMode (Typ MC_BUFFER_MODE ) Ausgang Active : (Typ BOOL ) Ein Befehl wird akzeptiert, wenn der Funktionsbaustein in den Zustand Busy übergeht, nachdem eine neue Bewegung kommandiert wurde. Funktionsbaustein Kann als Buffered\/Blending-Befehl definiert werden Kann von einem Buffered\/Blending-Befehl gefolgt werden Relevantes Signal zur Aktivierung des nächsten Buffered\/Blending-FBs MC_Power Nein Nein MC_Home Nein Nein MC_Stop Nein Nein MC_Halt Nein Nein MC_MoveAbsolute MC_MoveRelative Ja Ja Done MC_MoveAdditive Nein Ja (nur Buffered ) Done MC_MoveSuperImposed MC_HaltSuperImposed Nein Nein Für weitere Informationen siehe: Verhalten von MC_MoveSuperImposed und MC_HaltSuperImposedMC_MoveVelocity Ja Ja (nur Buffered ) InVelocity SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative Nein Ja (nur Buffered ) InEndVelocity MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile Nein Ja (nur Buffered ) Done MC_CamIn Ja (nur Buffered und BlendingPrevious ) Ja, auch wenn periodisch (nur Buffered ) EndOfProfile MC_CamOut Nein Ja (nur Buffered ) Done MC_GearIn Ja (nur BlendingPrevious ) Ja (nur Buffered ) InGear MC_GearOut Nein Ja (nur Buffered ) Done MC_GearInPos Ja (nur BlendingPrevious ) Ja (nur Buffered ) InSync SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues Nein Nein SMC_SetTorque Nein Nein MC_Phasing Nein Nein MC_Jog SMC_Inch Nein Nein Diese Funktionsbausteine sollten nicht verwendet werden, wenn Bewegungen mit BufferMode Buffered oder Blending* kommandiert werden. Jogging und die kommandierten Bewegungen können sich gegenseitig unterbrechen. SMC_BacklashCompensation Nein Nein SMC_TrackAxis Nein Nein SMC_TrackSetValues Nein Nein Hinweis für MC_GearInPos und MC_GearIn : Das Verhalten von anderen BufferModes als BlendingPrevious ist schwer festzulegen. Das Hauptproblem besteht darin, dass sich die Geschwindigkeit dieser Funktionsbausteine in Abhängigkeit von der Masterachse jederzeit ändern kann. Da das Überschleifen am besten funktioniert, wenn die Blending-Geschwindigkeit so früh wie möglich bekannt ist, wird nur BlendingPrevious unterstützt. Bei BlendingPrevious kann sich auch die Richtung der Masterachse jederzeit ändern. Das bedeutet, dass die Richtung, die die Slave-Achse beim MC_GearInPos haben sollte, erst bekannt ist, wenn das Blending abgeschlossen ist. Wir benötigen aber für die Blending-Bewegung eine Richtung bereits wenn das Blending beginnt. Deshalb definiert die erste Bewegung sowohl die Blending-Geschwindigkeit als auch die Richtung, ungeachtet der Richtung, die der nachfolgende MC_GearIn(Pos) definiert. " }, 
{ "title" : "Verhalten bei gepufferten Bewegungen ", 
"url" : "_sm_buffermode_buffered_movements.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen \/ Verhalten bei gepufferten Bewegungen ", 
"snippet" : "Wenn eine gepufferte Bewegung nach MC_MoveAbsolute oder MC_MoveRelative kommandiert wird, wird die gepufferte Bewegung im gleichen Zyklus aktiv, in dem die vorherige Bewegung Done meldet und die Geschwindigkeit 0 erreicht. Die Interpolation der gepufferten Bewegung beginnt jedoch erst im nächsten Zy...", 
"body" : "Wenn eine gepufferte Bewegung nach MC_MoveAbsolute oder MC_MoveRelative kommandiert wird, wird die gepufferte Bewegung im gleichen Zyklus aktiv, in dem die vorherige Bewegung Done meldet und die Geschwindigkeit 0 erreicht. Die Interpolation der gepufferten Bewegung beginnt jedoch erst im nächsten Zyklus, so dass die Geschwindigkeit der Achse am Ende des Zyklus gleich 0 ist. Wenn eine gepufferte Bewegung nach MC_CamIn kommandiert wird, dann ist die gepufferte Bewegung in demselben Zyklus aktiv, in dem die vorherige Bewegung EndOfProfile meldet. Die Interpolation der gepufferten Bewegung beginnt sofort in diesem Zyklus. " }, 
{ "title" : "Verhalten beim Überschleifen ", 
"url" : "_sm_buffermode_blending.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen \/ Verhalten beim Überschleifen ", 
"snippet" : "Eine grundlegende Eigenschaft des Blending-Verhaltens von CODESYS SoftMotion ist, dass sich die Achse beim Blending entlang derselben Positionen bewegt wie bei einer gepufferten Bewegung. Der einzige Unterschied ist die Geschwindigkeit entlang dieser Positionen. Für einfache Fälle ist dies offensich...", 
"body" : "Eine grundlegende Eigenschaft des Blending-Verhaltens von CODESYS SoftMotion ist, dass sich die Achse beim Blending entlang derselben Positionen bewegt wie bei einer gepufferten Bewegung. Der einzige Unterschied ist die Geschwindigkeit entlang dieser Positionen. Für einfache Fälle ist dies offensichtlich. Sehen Sie dazu das folgende Beispiel: Es gibt Fälle, in denen die Eigenschaft, die gleichen Positionen von der Achse unabhängig vom Buffermode zu überfahren, die effektive Blending-Geschwindigkeit zwischen den beiden Bewegungen beeinflusst. Dies ist beispielsweise der Fall, wenn das obige Beispiel so modifiziert wird, dass die maximale Geschwindigkeit der zweiten Bewegung so hoch ist, dass sie an der Blending-Position nicht erreicht werden kann. Nach den in der PLCopen beschriebenen Regeln sollte die Blending-Geschwindigkeit 500 u\/s betragen. Um diese Geschwindigkeit an der Position 100 u zu erreichen, müsste die Achse jedoch umkehren, in negative Richtung zu einer Position kleiner 0 u fahren und dann auf 500 u\/s beschleunigen. Stattdessen wird in solchen Fällen die effektive Blending-Geschwindigkeit auf die maximale Geschwindigkeit begrenzt, die ohne Umkehr und Positionsüberschwingen erreicht werden kann. In diesem Beispiel beträgt die maximale Geschwindigkeit 447 u\/s. Die folgenden Regeln für die effektive Blending-Geschwindigkeit resultieren aus der Eigenschaft, dass der BufferMode die gefahrenen Positionen nicht verändert: Wenn die Blending-Geschwindigkeit nicht ohne Positionsüberschwingen erreicht werden kann, dann ist die effektive Blending-Geschwindigkeit die nächstmögliche Geschwindigkeit, die ohne Überschwingen erreicht werden kann (siehe obiges Beispiel). Hinweis: Die effektive Blending-Geschwindigkeit kann höher oder niedriger als die Blending-Geschwindigkeit sein. Wenn die Richtung zu Beginn der zweiten Bewegung entgegengesetzt zur Richtung der ersten Bewegung ist, wird die effektive Blending-Geschwindigkeit auf 0 gesetzt. Dadurch wird ein Überschwingen der Position in Richtung der ersten Bewegung über ihre Zielposition hinaus vermieden. Wenn die Strecke der zweiten Bewegung zu kurz ist, um ein Abbremsen von der Blending-Geschwindigkeit bis zum Stillstand zu ermöglichen, wird die effektive Blending-Geschwindigkeit angepasst. Sie wird auf die maximale Geschwindigkeit eingestellt, die ein sicheres Abbremsen bis zum Stillstand auf der Strecke der zweiten Bewegung ermöglicht. Bei Modulo-Achsen wird die Wirkung des Direction -Eingangs von MC_MoveAbsolute nicht durch das Blending auf eine zweite Bewegung beeinflusst. Das bedeutet, dass die Zielposition der ersten Bewegung immer in derselben Modulo-Periode liegt, egal ob darauf eine Blending-Bewegung folgt oder nicht. Bei Modulo-Achsen und einer zweiten Bewegung vom Typ MC_MoveAbsolute beeinflusst die Blending-Geschwindigkeit nicht die Modulo-Periode der Zielposition der zweiten Bewegung, wenn Direction = fastest verwendet wird. Das bedeutet, dass dieselbe Zielperiode ausgewählt wird, egal ob die zweite Bewegung Buffered oder Blending kommandiert wird. " }, 
{ "title" : "Beschleunigung, Verzögerung und Ruck während des Blendings ", 
"url" : "_sm_buffermode_blending.html#UUID-60273b62-3ad5-7014-3fa9-e2fa61f7a008_section-idm235068399508112", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen \/ Verhalten beim Überschleifen \/ Beschleunigung, Verzögerung und Ruck während des Blendings ", 
"snippet" : "Der Buffermode ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext ) der zweiten Bewegung legt fest, mit welcher Geschwindigkeit die Startposition der Bewegung erreicht wird. Die maximale Beschleunigung, Verzögerung und der maximale Ruck während des Blendings sind dagegen immer die Werte ...", 
"body" : "Der Buffermode ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext ) der zweiten Bewegung legt fest, mit welcher Geschwindigkeit die Startposition der Bewegung erreicht wird. Die maximale Beschleunigung, Verzögerung und der maximale Ruck während des Blendings sind dagegen immer die Werte der ersten Bewegung. Der Grund hierfür ist, dass es zu einem Überschreiten der Zielposition der ersten Bewegung kommen kann, wenn beispielsweise die maximale Verzögerung der zweiten Bewegung kleiner ist als die der ersten, und die kleinere Verzögerung verwendet wird. " }, 
{ "title" : "Buffering\/Blending aus kontinuierlicher oder synchronisierter Bewegung ", 
"url" : "_sm_buffermode_continuous_motion.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen \/ Buffering\/Blending aus kontinuierlicher oder synchronisierter Bewegung ", 
"snippet" : "Nach der PLCopen bestimmt der Blending-BufferMode die Geschwindigkeit am Ende der ersten Bewegung. In einigen Fällen wird die Geschwindigkeit bereits durch die erste Bewegung vollständig bestimmt. Dies ist der Fall, wenn die erste Bewegung von einem der folgenden Typen ist: kontinuierliche Bewegung ...", 
"body" : "Nach der PLCopen bestimmt der Blending-BufferMode die Geschwindigkeit am Ende der ersten Bewegung. In einigen Fällen wird die Geschwindigkeit bereits durch die erste Bewegung vollständig bestimmt. Dies ist der Fall, wenn die erste Bewegung von einem der folgenden Typen ist: kontinuierliche Bewegung ( MC_MoveVelocity , SMC_MoveContinuousRelative oder SMC_MoveContinuousAbsolute ) synchronisierte Bewegung ( MC_CamIn , MC_GearIn oder MC_GearInPos ) In diesem Fällen unterstützt CODESYS SoftMotion nur die BufferModes Buffered und Aborting . Die Verwendung eines der Blending-BufferModes führt zu einem FB-Fehler ( SMC_BLENDING_NOT_SUPPORTED_BY_PREVIOUS_MOVEMENT) . Wenn der nachfolgende gepufferte Befehl aktiv wird, wird bei einem vorhergehenden Bewegungsbefehl der Ausgang CommandAborted auf TRUE gesetzt. Zusätzlich werden die „Inxxx“-Ausgänge (beispielsweise InVelocity für MC_MoveVelocity oder InGear für MC_GearIn ) und der Ausgang Busy für einen Zyklus gesetzt. Dies steht im Gegensatz zur PLCopen, Abschnitt 2.4.1, wo es heißt, dass CommandAborted und „Inxxx“ sowie Busy sich gegenseitig ausschließen. " }, 
{ "title" : "Aufrufreihenfolge von Bewegungsfunktionsbausteinen ", 
"url" : "_sm_buffermode_execution_order.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen \/ Aufrufreihenfolge von Bewegungsfunktionsbausteinen ", 
"snippet" : "Wenn gepufferte Bewegungen oder Blending-Bewegungen kommandiert werden, dann darf die Funktionsbaustein-Instanz, die die Folgebewegung kommandiert, nicht früher aufgerufen werden als die Funktionsbaustein-Instanz, die die vorhergehende Bewegung kommandiert hat. Wenn diese Reihenfolge verletzt wird, ...", 
"body" : "Wenn gepufferte Bewegungen oder Blending-Bewegungen kommandiert werden, dann darf die Funktionsbaustein-Instanz, die die Folgebewegung kommandiert, nicht früher aufgerufen werden als die Funktionsbaustein-Instanz, die die vorhergehende Bewegung kommandiert hat. Wenn diese Reihenfolge verletzt wird, wird der neue Fehler SMC_FB_WASNT_CALLED_DURING_MOTION gemeldet und die Achse geht in den Zustand Errorstop über. Beispiel movement1();\nmovement2(); Korrekte Ausführungsreihenfolge Ausführen von movement1() Ausführen von movement2() , sobald movement1() aktiv ist Ungültige Ausführungsreihenfolge Ausführen von movement2() Ausführen von movement1() , sobald movement2() aktiv ist Dies führt zu Fehler SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT . " }, 
{ "title" : "Verwendung einer Funktionsbaustein-Instanz zur Steuerung mehrerer Bewegungen ", 
"url" : "_sm_buffermode_one_fb.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen \/ Verwendung einer Funktionsbaustein-Instanz zur Steuerung mehrerer Bewegungen ", 
"snippet" : "Eine einzige Funktionsbaustein-Instanz, beispielsweise von MC_MoveAbsolute , kann nicht zur Steuerung mehrerer Buffered\/Blending Bewegungen verwendet werden, solange sie Busy ist. Wenn eine Funktionsbaustein-Instanz Busy ist, führt der Befehl für eine neue gepufferte oder überschliffene Bewegung mit...", 
"body" : "Eine einzige Funktionsbaustein-Instanz, beispielsweise von MC_MoveAbsolute , kann nicht zur Steuerung mehrerer Buffered\/Blending Bewegungen verwendet werden, solange sie Busy ist. Wenn eine Funktionsbaustein-Instanz Busy ist, führt der Befehl für eine neue gepufferte oder überschliffene Bewegung mit dieser Instanz zu dem Fehler SMC_MORE_THAN_ONE_MOVEMENT_PER_INSTANCE . Um mehrere gepufferte oder verschliffene Bewegungen desselben Typs in kurzer Reihenfolge zu kommandieren, sind mehrere Funktionsbaustein-Instanzen erforderlich. " }, 
{ "title" : "Verhalten bei Fehler ", 
"url" : "_sm_basic_behavior_error.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen \/ Verhalten bei Fehler ", 
"snippet" : "Wenn ein Achsfehler auftritt (die Achse beispielsweise in den Zustand Errorstop geht), dann wird die aktive Bewegung zusammen mit allen anderen akzeptierten Bewegungen einen Fehler melden. Wenn im Funktionsbaustein einer aktiven Bewegung ein FB-Fehler auftritt, so melden auch alle später akzeptierte...", 
"body" : "Wenn ein Achsfehler auftritt (die Achse beispielsweise in den Zustand Errorstop geht), dann wird die aktive Bewegung zusammen mit allen anderen akzeptierten Bewegungen einen Fehler melden. Wenn im Funktionsbaustein einer aktiven Bewegung ein FB-Fehler auftritt, so melden auch alle später akzeptierten Bewegungen einen Fehler. Dies steht im Gegensatz zur PLCopen, Abschnitt 2.2.2, wo nachfolgende Befehle die Ausführung nach einem FB-Fehler fortsetzen. " }, 
{ "title" : "Verhalten von MC_MoveSuperImposed und MC_HaltSuperImposed ", 
"url" : "_sm_buffermode_movesuperimposed.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen \/ Verhalten von MC_MoveSuperImposed und MC_HaltSuperImposed ", 
"snippet" : "Wenn MC_MoveSuperImposed oder MC_HaltSuperImposed aktiv ist und die zugrunde liegende Bewegung abgebrochen wird, dann wird MC_MoveSuperImposed \/ MC_HaltSuperImposed ebenfalls abgebrochen. Wenn die zugrundeliegende Bewegung nicht abgebrochen wird, sondern eine andere Bewegung mit dem Modus Buffered o...", 
"body" : "Wenn MC_MoveSuperImposed oder MC_HaltSuperImposed aktiv ist und die zugrunde liegende Bewegung abgebrochen wird, dann wird MC_MoveSuperImposed \/ MC_HaltSuperImposed ebenfalls abgebrochen. Wenn die zugrundeliegende Bewegung nicht abgebrochen wird, sondern eine andere Bewegung mit dem Modus Buffered oder einem der Blending-BufferMode kommandiert wird, ist das Verhalten folgendermaßen: MC_MoveSuperimposed \/ MC_HaltSuperImposed wird nicht abgebrochen, wenn das Blending beginnt oder die neue Bewegung aktiv wird. Stattdessen wird MC_MoveSuperimposed \/ MC_HaltSuperImposed im Hintergrund fortgesetzt, bis es fertig ist. " }, 
{ "title" : "Ab CODESYS SoftMotion Version 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439539337338", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen \/ Verhalten von MC_MoveSuperImposed und MC_HaltSuperImposed \/ Ab CODESYS SoftMotion Version 4.17.0.0 ", 
"snippet" : "Wenn ein mit Buffered-Mode oder einem Blending-Mode versehener MC_MoveAbsolute kommandiert wird, ist die resultierende Endposition die Summe aus der am MC_MoveAbsolute konfigurierten Position und der am MC_MoveSuperImposed \/ MC_HaltSuperImposed konfigurierten Distanz. Dabei ist es irrelevant, ob der...", 
"body" : "Wenn ein mit Buffered-Mode oder einem Blending-Mode versehener MC_MoveAbsolute kommandiert wird, ist die resultierende Endposition die Summe aus der am MC_MoveAbsolute konfigurierten Position und der am MC_MoveSuperImposed \/ MC_HaltSuperImposed konfigurierten Distanz. Dabei ist es irrelevant, ob der MC_MoveSuperImposed \/ MC_HaltSuperImposed noch aktiv ist, die SuperImposed-Distanz bleibt auch nach Abschluss der überlagerten Bewegung erhalten. Zurückgesetzt wird die SuperImposed-Distanz, sobald eine Aborting-Bewegung kommandiert wird. " }, 
{ "title" : "Vor CODESYS SoftMotion Version 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439540497353", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Kommandierung mehrerer Bewegungen \/ Verhalten von MC_MoveSuperImposed und MC_HaltSuperImposed \/ Vor CODESYS SoftMotion Version 4.17.0.0 ", 
"snippet" : "Wenn ein mit Buffered-Mode oder einem Blending-Mode versehener MC_MoveAbsolute kommandiert wird, während ein MC_MoveSuperImposed \/ MC_HaltSuperImposed aktiv ist, dann hängt die resultierende Endposition vom Status von MC_MoveSuperImposed \/ MC_HaltSuperImposed zu dem Zeitpunkt ab, an dem der MC_MoveA...", 
"body" : "Wenn ein mit Buffered-Mode oder einem Blending-Mode versehener MC_MoveAbsolute kommandiert wird, während ein MC_MoveSuperImposed \/ MC_HaltSuperImposed aktiv ist, dann hängt die resultierende Endposition vom Status von MC_MoveSuperImposed \/ MC_HaltSuperImposed zu dem Zeitpunkt ab, an dem der MC_MoveAbsolute aktiv wird. Wenn MC_MoveSuperImposed \/ MC_HaltSuperImposed zu diesem Zeitpunkt noch aktiv ist, dann ist die resultierende Endposition die Summe aus der Position von MC_MoveAbsolute und der Strecke von MC_MoveSuperImposed \/ MC_HaltSuperImposed . Wenn dagegen MC_MoveSuperImposed \/ MC_HaltSuperImposed zu diesem Zeitpunkt nicht mehr aktiv ist, dann ist die resultierende Endposition die Position von MC_MoveAbsolute , ohne die Strecke von MC_MoveSuperImposed \/ MC_HaltSuperImposed . In ähnlicher Weise hängt die resultierende Geschwindigkeit von MC_MoveVelocity vom Status von MC_MoveSuperImposed \/ MC_HaltSuperImposed ab, wenn MC_MoveVelocity aktiv wird. Die Kurve unten zeigt einen MC_MoveSuperImposed (Funktionsbaustein sup ) parallel zu drei absoluten Bewegungen mit Blending-BufferMode BlendingHigh . Die erste und zweite Bewegung werden mit einer Geschwindigkeit von 100 u\/s kommandiert, mit den Funktionsbausteinen ma0 und. ma1 . Die dritte Bewegung wird mit einer Geschwindigkeit von 120 u\/s mit dem Funktionsbaustein ma2 kommandiert. Die erste Zielposition beträgt 10 u, die zweite 25 u, die dritte 40 u. Die Geschwindigkeit der überlagerten Bewegung beträgt 20, der Abstand 10. Die resultierende Position ist 50 u, die Position der letzten absoluten Bewegung plus die Strecke von MC_MoveSuperimposed . " }, 
{ "title" : "Digitale Schaltpunkte ", 
"url" : "_sm_digital_switches.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Digitale Schaltpunkte ", 
"snippet" : "CODESYS SoftMotion bietet verschiedene Möglichkeiten, digitale Schaltpunkte zu realisieren. Dieser Abschnitt liefert einen Überblick über die jeweiligen Vor- und Nachteile....", 
"body" : "CODESYS SoftMotion bietet verschiedene Möglichkeiten, digitale Schaltpunkte zu realisieren. Dieser Abschnitt liefert einen Überblick über die jeweiligen Vor- und Nachteile. " }, 
{ "title" : "Anwendungsbeispiel ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632666072", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Digitale Schaltpunkte \/ Anwendungsbeispiel ", 
"snippet" : "Digitale Schaltpunkte werden zum Beispiel für das Einschalten einer Klebstoffpistole in Abhängigkeit der Achsposition benötigt. In dem nachfolgenden Beispiel soll die Klebstoffpistole von Position 90 bis 120 Klebstoff auf ein Produkt auftragen. Eine Klebstoffpistole hat eine Verzögerung zwischen dem...", 
"body" : "Digitale Schaltpunkte werden zum Beispiel für das Einschalten einer Klebstoffpistole in Abhängigkeit der Achsposition benötigt. In dem nachfolgenden Beispiel soll die Klebstoffpistole von Position 90 bis 120 Klebstoff auf ein Produkt auftragen. Eine Klebstoffpistole hat eine Verzögerung zwischen dem Einschalten und Auftragen von Klebstoff. Dasselbe gilt für das Ausschalten. Deshalb wird eine Ein- und Ausschaltverzögerung benötigt, sodass die Klebstoffpistole 50 ms vor Position 90 eingeschaltet und 50 ms vor Position 120 ausgeschaltet wird. " }, 
{ "title" : "Baustein Übersicht ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632773598", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Digitale Schaltpunkte \/ Baustein Übersicht ", 
"snippet" : "Baustein Mehrere Schaltpunkte Ein- und Ausschaltverzögerung Vorausschau Hochgenau (zeitliche Auflösung höher als die Zykluszeit) Datenbasis Anmerkung SMC_DigitalCamSwitch_HighPrecision 1 2 Soll- oder Istposition Sinnvoll, wenn höhere zeitliche Genauigkeiten benötigt werden. Für den hochgenauen Betri...", 
"body" : "Baustein Mehrere Schaltpunkte Ein- und Ausschaltverzögerung Vorausschau Hochgenau (zeitliche Auflösung höher als die Zykluszeit) Datenbasis Anmerkung SMC_DigitalCamSwitch_HighPrecision 1 2 Soll- oder Istposition Sinnvoll, wenn höhere zeitliche Genauigkeiten benötigt werden. Für den hochgenauen Betrieb wird neben diesem Baustein eine hochgenaue digitale Ausgangskarte benötigt. Diese Kombination ermöglicht es auch bei höheren Zykluszeiten, Ausgänge mit hoher zeitlichen Genauigkeit zu schalten. Mehr Informationen zur Verwendung des Bausteins können Sie dem Beispiel Verwendung von MC_DigitalCamSwitch_HighPrecision entnehmen. SMC_GetTravelTime 2 Soll- oder Istposition Sinnvoll, wenn eine eigene Version des Bausteins DigitalCamSwitch implementiert werden soll, beispielsweise weil weitere Funktionen benötigt werden. MC_DigitalCamSwitch 3 Soll- oder Istposition Sinnvoll, wenn eine zyklusgenaue zeitliche Auflösung ausreichend ist. SMC_GetTappetValue Soll- oder Istposition Diese Bausteine werden nur aus Gründen der Kompatibilität beibehalten. Für aktuelle und zukünftige Projekte sollten die anderen, weiterentwickelten Bausteine verwendet werden. SMC_CamRegister Soll- oder Istposition 1 Exakt. Es werden die Daten aus der Vorausschau verwendet. 2 Die Vorausschau muss über den Funktionsbaustein SMC_SetForecast gesetzt werden. Für weitere Informationen zur Vorausschau siehe Vorausschau. 3 Nur über Extrapolation " }, 
{ "title" : "Dynamikanpassung mit MC_SetOverride ", 
"url" : "_sm_adjust_dynamics.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Dynamikanpassung mit MC_SetOverride ", 
"snippet" : "Die Dynamik (Geschwindigkeit, Beschleunigung und Ruck) der aktiven und zukünftigen Bewegungen kann mittels MC_SetOverride angepasst werden. Dabei bedeutet eine Anpassung der Dynamik immer eine Reduktion im Vergleich zur ursprünglich kommandierten Bewegung (Faktoren größer 1 sind nicht zulässig). Dad...", 
"body" : "Die Dynamik (Geschwindigkeit, Beschleunigung und Ruck) der aktiven und zukünftigen Bewegungen kann mittels MC_SetOverride angepasst werden. Dabei bedeutet eine Anpassung der Dynamik immer eine Reduktion im Vergleich zur ursprünglich kommandierten Bewegung (Faktoren größer 1 sind nicht zulässig). Dadurch können Bediener einer Maschine eine Bewegung temporär anhalten ( VelFactor = 0 ) oder diese, beispielsweise zum Kontrollieren von neuen Bewegungsabläufen, mit reduzierten Dynamikwerten ausführen. Die Anpassung der Dynamik mit MC_SetOverride und die daraus resultierende Anpassung der Trajektorie erfolgen direkt im selben Zyklus. Voraussetzung dafür ist, dass MC_SetOverride vor dem aktiven Bewegungsbaustein aufgerufen wird. Sehen Sie hierzu auch das Beispiel Geschwindigkeits-Override für Softmotion-Achsen. " }, 
{ "title" : "Unterstützte Bausteine ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4626631011382434026679825113", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Dynamikanpassung mit MC_SetOverride \/ Unterstützte Bausteine ", 
"snippet" : "Funktionsbaustein Unterstützung MC_SetOverride Bemerkung MC_Stop -- MC_Stop ist ein Not-Halt, der immer schnellstmöglich ausgeführt werden soll. Deshalb haben die Dynamikfaktoren von MC_SetOverride keinen Einfluss auf die Bewegung. MC_Halt ✓ Der Geschwindigkeitsfaktor hat keine Auswirkung. MC_MoveAb...", 
"body" : "Funktionsbaustein Unterstützung MC_SetOverride Bemerkung MC_Stop -- MC_Stop ist ein Not-Halt, der immer schnellstmöglich ausgeführt werden soll. Deshalb haben die Dynamikfaktoren von MC_SetOverride keinen Einfluss auf die Bewegung. MC_Halt ✓ Der Geschwindigkeitsfaktor hat keine Auswirkung. MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_Jog SMC_Inch ✓ SMC_Homing ✓ SMC_ControlAxisByPos SMC_ControlAxisByPosVel SMC_ControlAxisByVel O Die Dynamikfaktoren wirken sich nur aus, wenn die Funktion  bAvoidGaps  aktiviert ist und ein Sprung erkannt wurde. Die Faktoren von MC_SetOverride beachten dabei sowohl das Anhalten als auch die anschließende absolute Bewegung zum Schließen der Lücke. MC_Home -- Die Referenzfahrt wird vom Antrieb selbstständig ausgeführt, sodass die Dynamikfaktoren von MC_SetOverride keine Auswirkung haben. MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- Wir empfehlen die Verwendung von MC_CamIn anstelle dieser Bausteine. MC_CamIn O Die Dynamikfaktoren haben keine Auswirkung mehr, sobald die Bewegung synchronisiert ist ( MC_CamIn.InSync = TRUE ). MC_CamOut -- MC_CamOut hat keine einstellbaren Dynamikgrenzen und soll die aktuelle Geschwindigkeit halten. Deshalb haben die Dynamikfaktoren von MC_SetOverride keine Auswirkung. MC_GearIn O Die Dynamikfaktoren haben keine Auswirkung mehr, sobald die Bewegung synchronisiert ist ( MC_GearIn.InGear = TRUE ). Während des Einrampens werden nur der Beschleunigungs- und Ruckfaktor beachtet. Änderungen des Geschwindigkeitsfaktors (insbesondere  VelFactor=0 ) werden ignoriert. MC_GearInPos -- Hat im Gegensatz zu  MC_GearIn  keine konfigurierbare Einrampbewegung. Deshalb wirken sich die Dynamikfaktoren von MC_SetOverride nicht aus. SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- Diese Bausteine schreiben die Sollwerte der Achse (beispielsweise  fSetPosition ). Diese Werte sollen nicht modifiziert werden. Deshalb wirken sich die Dynamikfaktoren von MC_SetOverride nicht aus. MC_Phasing O Die Dynamikfaktoren haben keine Auswirkung mehr, sobald die Bewegung synchronisiert ist ( MC_Phasing.Done = TRUE ). Während des Einrampens werden nur der Beschleunigungs- und Ruckfaktor beachtet. Änderungen des Geschwindigkeitsfaktors (insbesondere  VelFactor=0 ) werden ignoriert. SMC_BacklashCompensation -- Die Dynamikfaktoren wirken sich nicht auf synchronisierte Bewegungen aus. Deshalb ignoriert dieser Baustein die Dynamikfaktoren von MC_SetOverride . " }, 
{ "title" : "Überschreitung der Zielposition oder -geschwindigkeit durch Änderung der Dynamikfaktoren ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469374918434026680028303", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Dynamikanpassung mit MC_SetOverride \/ Überschreitung der Zielposition oder -geschwindigkeit durch Änderung der Dynamikfaktoren ", 
"snippet" : "Wenn der Beschleunigungs- und\/oder Ruckfaktor während einer aktiven Bewegung reduziert wird, kann es passieren, dass die Zielposition oder -geschwindigkeit temporär überschritten wird. Dies kann zu Schäden an der Maschine führen. Bei  SMC_MoveContinuousAbsolute  und  SMC_MoveContinuousRelative  kann...", 
"body" : "Wenn der Beschleunigungs- und\/oder Ruckfaktor während einer aktiven Bewegung reduziert wird, kann es passieren, dass die Zielposition oder -geschwindigkeit temporär überschritten wird. Dies kann zu Schäden an der Maschine führen. Bei  SMC_MoveContinuousAbsolute  und  SMC_MoveContinuousRelative  kann auch eine Änderung des Geschwindigkeitsfaktors zu einer Überschreitung der Limits oder zu einer Umkehr führen. Mehr Details sind in der Dokumentation der beiden Bausteine zu finden. " }, 
{ "title" : "Auswirkung des Geschwindigkeitprofils auf die Verwendung von MC_SetOverride ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469646968034026680341439", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Dynamikanpassung mit MC_SetOverride \/ Auswirkung des Geschwindigkeitprofils auf die Verwendung von MC_SetOverride ", 
"snippet" : "Es wird grundsätzlich empfohlen, MC_SetOverride zusammen mit einem trapezoiden oder quadratischen Geschwindigkeitsprofil der Achsen zu verwenden. Quadratisch geglättete und sin²-Geschwindigkeitsprofile reagieren in bestimmten Fällen nicht gut auf ein Neustarten oder Unterbrechen der Bewegung, siehe ...", 
"body" : "Es wird grundsätzlich empfohlen, MC_SetOverride zusammen mit einem trapezoiden oder quadratischen Geschwindigkeitsprofil der Achsen zu verwenden. Quadratisch geglättete und sin²-Geschwindigkeitsprofile reagieren in bestimmten Fällen nicht gut auf ein Neustarten oder Unterbrechen der Bewegung, siehe Bewegungen unterbrechen. Da eine Änderung des Overrides äquivalent zu einem Neustart der Bewegung mit veränderten Limits ist, kann es auch bei Verwendung dieser Geschwindigkeitsprofile in Kombination mit MC_SetOverride zu der beschriebenen Überschreitung der kommandierten Limits kommen. " }, 
{ "title" : "Auswirkung von MC_SetOverride auf koordinierte Bewegungen mit einer Achsgruppe ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm456655390848963402668059106", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Dynamikanpassung mit MC_SetOverride \/ Auswirkung von MC_SetOverride auf koordinierte Bewegungen mit einer Achsgruppe ", 
"snippet" : "Koordinierte Bewegungen mit einer Achsgruppe (beispielsweise MC_MoveLinearAbsolute ) berücksichtigen die mit MC_SetOverride eingestellten Overrides jeder Achse bei der Bewegungsplanung. Umgekehrt überschreibt MC_GroupSetOverride die Overrides jeder Achse der Achsgruppe....", 
"body" : "Koordinierte Bewegungen mit einer Achsgruppe (beispielsweise MC_MoveLinearAbsolute ) berücksichtigen die mit MC_SetOverride eingestellten Overrides jeder Achse bei der Bewegungsplanung. Umgekehrt überschreibt MC_GroupSetOverride die Overrides jeder Achse der Achsgruppe. " }, 
{ "title" : "Vorausschau ", 
"url" : "_sm_basic_forecast.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Vorausschau ", 
"snippet" : "Mit der Vorausschau können Informationen über die zukünftige Bewegung einer Achse abgefragt werden. Eine wichtige Anwendung der Vorausschau ist die Ermittlung der Zeit, bis eine Position erreicht wird (ähnlich der Funktion von Schaltpunkten). Eine andere Anwendung ist die Ermittlung der Position und...", 
"body" : "Mit der Vorausschau können Informationen über die zukünftige Bewegung einer Achse abgefragt werden. Eine wichtige Anwendung der Vorausschau ist die Ermittlung der Zeit, bis eine Position erreicht wird (ähnlich der Funktion von Schaltpunkten). Eine andere Anwendung ist die Ermittlung der Position und Geschwindigkeit, die eine Achse zu einer gegebenen Zeit haben wird. Damit können Totzeiten beim Einschalten von Aktoren, wie beispielsweise das Einschalten einer Klebstoffdüse, kompensiert werden. Weiterhin können damit auch Aktoren mit Totzeit präzise angesteuert werden, wie beispielsweise die Steuerung des Klebstoffvolumens pro Zeit, abhängig von der Achsgeschwindigkeit, 100 ms in der Zukunft. Um diese Anwendungen umzusetzen, können Sie die Bausteine  SMC_GetTravelTime und SMC_ReadSetValues verwenden, nachdem Sie die Vorausschau-Dauer mit SMC_SetForecast eingestellt haben. Ein Beispiel, das die Verwendung zeigt, finden Sie hier: Vorausschau für Einzelachsbewegungen" }, 
{ "title" : "Bewegungsbausteine mit Vorausschau ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm2344331274012", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Vorausschau \/ Bewegungsbausteine mit Vorausschau ", 
"snippet" : "Die folgende Übersicht zeigt, welche Bausteine eine Vorausschau unterstützen. Funktionsbaustein Vorausschau MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRela...", 
"body" : "Die folgende Übersicht zeigt, welche Bausteine eine Vorausschau unterstützen. Funktionsbaustein Vorausschau MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- MC_CamIn ✓ MC_CamOut ✓ MC_GearIn ✓ MC_GearOut ✓ MC_GearInPos ✓ SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- SMC_SetTorque -- MC_Phasing ✓ MC_Jog SMC_Inch ✓ SMC_BacklashCompensation ✓ " }, 
{ "title" : "Aktivierung der Vorausschau ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433129890703", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Vorausschau \/ Aktivierung der Vorausschau ", 
"snippet" : "Standardmäßig ist die Vorausschau deaktiviert. Das bedeutet, dass SMC_ReadSetValues nur für einen TimeOffset zwischen 0 s (Anfang des aktuellen Taskzyklus) und Taskinterval (Ende des aktuellen Taskzyklus) gültige Werte zurückgibt und SMC_GetTravelTime nur für Positionen, die in diesem Zyklus erreich...", 
"body" : "Standardmäßig ist die Vorausschau deaktiviert. Das bedeutet, dass SMC_ReadSetValues nur für einen TimeOffset zwischen 0 s (Anfang des aktuellen Taskzyklus) und Taskinterval (Ende des aktuellen Taskzyklus) gültige Werte zurückgibt und SMC_GetTravelTime nur für Positionen, die in diesem Zyklus erreicht werden, eine gültige Zeit zurückgibt. Die benötigte Vorausschau-Dauer kann mit dem Baustein SMC_SetForecast gesetzt und mit dem Baustein SMC_GetForecast ausgelesen werden. Anmerkungen: Die Vorausschau-Dauer kann jederzeit verändert werden. Vermeiden Sie eine unnötig lange Vorausschau-Dauer, da die Vorausberechnung Rechenzeit kostet. Wählen Sie den kleinsten Wert, der für Ihre Applikation ausreicht. Wenn Sie Master-\/Slave-Bausteine (wie MC_CamIn ) verwenden, dann muss die Vorausschau sowohl für die Master- als auch für die Slave-Achse aktiviert werden. " }, 
{ "title" : "Aufrufreihenfolge ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130424909", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Vorausschau \/ Aufrufreihenfolge ", 
"snippet" : "Damit die Vorausschau bestmögliche Ergebnisse liefert, ist es wichtig, auf eine korrekte Aufrufreihenfolge bei den Master-\/Slave-Bausteinen zu achten. Das betrifft MC_CamIn , MC_GearIn , MC_GearInPos , MC_Phasing , SMC_BacklashCompensation und SMC_TrackAxis . Der Bewegungsbaustein der Master-Achse s...", 
"body" : "Damit die Vorausschau bestmögliche Ergebnisse liefert, ist es wichtig, auf eine korrekte Aufrufreihenfolge bei den Master-\/Slave-Bausteinen zu achten. Das betrifft MC_CamIn , MC_GearIn , MC_GearInPos , MC_Phasing , SMC_BacklashCompensation und SMC_TrackAxis . Der Bewegungsbaustein der Master-Achse sollte vor dem Master-\/Slave-Baustein aufgerufen werden. Auch ohne Vorausschau ist die Trajektorie bei korrekter Aufrufreihenfolge besser. Bei falscher Reihenfolge wird die Slave-Bewegung um einen Zyklus verzögert. Für MC_SetOverride gilt zusätzlich, dass dieser Baustein vor den Bewegungsbausteinen der Achse aufgerufen werden sollte. Durch eine Änderung des Override ändert sich die Bewegung der Achse noch im selben Taskzyklus. Zuvor aufgrund der Vorausschau ermittelte Werte verlieren dadurch ihre Gültigkeit. Beim nächsten Aufruf von SMC_GetTravelTime oder SMC_ReadSetValues werden sie neu ermittelt. " }, 
{ "title" : "BufferModes ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130652478", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Vorausschau \/ BufferModes ", 
"snippet" : "Die Vorausschau ist nicht auf eine einzelne Bewegung begrenzt, sie erstreckt sich auch auf alle folgenden Bewegungen, die mit einem Blending- oder Buffered-BufferMode kommandiert werden. Wenn auf einer Achse eine Aborting-Bewegung ausgeführt wird, dann ändert sich dadurch die Bewegung der Achse noch...", 
"body" : "Die Vorausschau ist nicht auf eine einzelne Bewegung begrenzt, sie erstreckt sich auch auf alle folgenden Bewegungen, die mit einem Blending- oder Buffered-BufferMode kommandiert werden. Wenn auf einer Achse eine Aborting-Bewegung ausgeführt wird, dann ändert sich dadurch die Bewegung der Achse noch in diesem Taskzyklus. Zuvor aufgrund der Vorausschau ermittelte Werte verlieren dadurch ihre Gültigkeit. Beim nächsten Aufruf von SMC_GetTravelTime oder SMC_ReadSetValues werden sie neu ermittelt. " }, 
{ "title" : "Effektive Vorausschau \/ Einschränkungen ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130869747", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Vorausschau \/ Effektive Vorausschau \/ Einschränkungen ", 
"snippet" : "Idealerweise ist die effektiv verfügbare Vorausschau-Dauer gleich der eingestellten Vorausschau-Dauer. Es gibt jedoch einige Faktoren, die dazu führen können, dass die effektive Vorausschau kürzer ist als die eingestellte. Wenn eine Master-\/Slave-Bewegung ausgeführt wird, dann ist die effektive Vora...", 
"body" : "Idealerweise ist die effektiv verfügbare Vorausschau-Dauer gleich der eingestellten Vorausschau-Dauer. Es gibt jedoch einige Faktoren, die dazu führen können, dass die effektive Vorausschau kürzer ist als die eingestellte. Wenn eine Master-\/Slave-Bewegung ausgeführt wird, dann ist die effektive Vorausschau des Slave das Minimum der effektiven Vorausschau des Masters und der eingestellten Vorausschau des Slaves. Für logische Achsen und Encoder-Achsen ist die effektive Vorausschau immer 0. Wenn der aktive Bewegungsbaustein keine Vorausschau unterstützt, ist die effektive Vorausschau ebenfalls 0. In allen anderen Fällen ist die effektive Vorausschau gleich der konfigurierten Vorausschau. " }, 
{ "title" : "Diagnose ", 
"url" : "_sm_basic_error_diagnosis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Diagnose ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Häufige Fehler ", 
"url" : "_sm_basic_common_errors.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Diagnose \/ Häufige Fehler ", 
"snippet" : "Diese Seite beschreibt häufige Fehler bei der Verwendung von CODESYS Softmotion Basic , deren Ursachen und mögliche Maßnahmen, um den Fehler zu beheben. Eine Liste aller möglichen Fehler mit kurzer Beschreibung finden Sie in der Bibliotheksdokumentation: SMC_ERROR Fehlercode Beschreibung und Ursache...", 
"body" : "Diese Seite beschreibt häufige Fehler bei der Verwendung von CODESYS Softmotion Basic , deren Ursachen und mögliche Maßnahmen, um den Fehler zu beheben. Eine Liste aller möglichen Fehler mit kurzer Beschreibung finden Sie in der Bibliotheksdokumentation: SMC_ERROR Fehlercode Beschreibung und Ursachen Maßnahmen SMC_DI_AXIS_ERROR Der Antrieb hat einen Fehler gemeldet. Mögliche Ursachen: Schleppfehler Endschalter Überlastung (I²t Fehler) Prüfen Sie, welchen Fehler der Antrieb meldet. Dies kann über das Display des Antriebs (sofern vorhanden) oder durch Auslesen mit dem Baustein MC_ReadAxisError erfolgen. SMC_AXIS_ERROR_DURING_MOTION Der Antrieb hat einen Fehler gemeldet. Während einer Bewegung gibt der aktive Bewegungsbaustein diesen Fehler zurück. Siehe Maßnahmen von Fehler SMC_DI_AXIS_ERROR . SMC_FB_WASNT_CALLED_DURING_MOTION Der Funktionsbaustein, der die aktive Bewegung steuert, wurde im aktuellen Zyklus nicht aufgerufen. Mögliche Ursachen: Die Aufrufreihenfolge bei gepufferten Bewegungen oder Überschleifbewegungen ist falsch. Die Funktionsbaustein-Instanz der Folgebewegung darf nicht früher aufgerufen werden, als die Funktionsbausteininstanz, die die vorhergehende Bewegung kommandiert hat. Ab SoftMotion Version 4.15.0.0 enthält die Log-Meldung zu diesem Fehler den Instanzpfad zum betroffenen Funktionsbaustein Prüfen Sie in der Applikation, weshalb der Baustein nicht zyklisch aufgerufen wurde Beheben Sie den Aufruf, sodass dieser zyklisch erfolgt (mindestens solange der Baustein in Verwendung ist) SMC_BLOCKING_MC_STOP_WASNT_CALLED Während eines aktiven Stopps wurde der zugehörige Funktionsbaustein MC_Stop im aktuellen Zyklus nicht aufgerufen. Siehe Maßnahmen von Fehler SMC_FB_WASNT_CALLED_DURING_MOTION . SMC_AXIS_NOT_READY_FOR_MOTION Die Achse ist nicht betriebsbereit und kann die gewünschte Bewegung nicht ausführen. Mögliche Ursachen sind: Die Achse befindet sich nicht in einem betriebsbereiten Zustand für die jeweilige Bewegung (beispielsweise power_off oder errorstop ) Die Achse befindet sich im Fehlerzustand und alle gepufferten Bewegungen geben diesen Fehler zurück Die Achse befindet sich im Zustand stopping (während einem aktiven MC_Stop ) und eine neue Aborting Bewegung wird kommandiert Prüfen Sie den Zustand der Achse: Ist die Achse durch MC_Power in einem betriebsbereiten Zustand? Ist die Achse im Zustand errorstop ? Falls ja, bitte identifizieren und beheben Sie den Achsfehler. Passt der Achszustand zu der kommandierten Bewegung? Zum Beispiel kann MC_CamOut nur kommandiert werden, wenn sich die Achse im Zustand der synchronisierten Bewegung befindet. SMC_FB_CALLED_FROM_WRONG_TASK Der SoftMotion -Baustein wurde aus einer Task aufgerufen, die nicht der Bustask der Achse entspricht. Da die SoftMotion -Bausteine Werte in der Achse verändern, kann es zu inkonsistenten Zuständen kommen, wenn Aufrufe aus anderen Tasks als der Bustask erfolgen. Dies kann zu undefinierten Fehlern führen, was über diesen Fehler verhindert wird. Prüfen Sie das Log: Es wird die betroffene Achse und Bausteininstanz protokolliert. Entfernen Sie den Aufruf aus der falschen Task. SMC_DI_FIELDBUS_LOST_SYNCRONICITY Tritt bei der Verwendung von EtherCAT mit Distributed Clocks auf, wenn der Frame von der Steuerung zum Antrieb nicht rechtzeitig (innerhalb des definierten Zeitfensters, dem sogenannten \"SyncWindow\") oder gar nicht empfangen wurde. Mögliche Ursachen: Echtzeitprobleme: Task-Jitter zu hoch Zu niedrige Task-Priorität der EtherCAT -Task Weitere Feldbusse (beispielsweise Modbus ) oder langwierige Operationen neben den Steuerungsaufgaben (beispieleweise Dateizugriffe) in der EtherCAT -Task Modbus wird in einer anderen Task ausgeführt, aber die E\/A-Kanäle, die dieser verwendet, werden auch in der EtherCAT -Task referenziert Gerade bei Linux-Betriebssystemen die Konfiguration des Systems (beispielsweise IRQ-Prioritäten) Kommunikationsproblem zum EtherCAT -Slave: Verbindung unterbrochen, Probleme mit der elektromagnetischen Verträglichkeit (EMV), etc. Prüfen Sie, welche Ursache für das Verhalten verantwortlich ist. Dabei können Ihnen folgende Funktionen helfen: Die Statusseite vom EtherCAT -Master Analyse der Zyklus- und Jitterzeiten der EtherCAT-Task in der Taskkonfiguration Mögliche Maßnahmen bei Echtzeitproblemen: Echtzeit optimieren. Befolgen Sie dafür die Hinweise in Performance-Optimierung Zykluszeit der EtherCAT -Task erhöhen DCInSyncWindow vom EtherCAT -Master erhöhen. Siehe IoDrvEtherCAT.DCInSyncWindow (PROP) Beim EtherCAT -Master FrameAtTaskStart aktivieren. Siehe IoDrvEtherCAT.FrameAtTaskStart (PROP) Wenn der Antrieb mit den Synchronitätsproblemen umgehen kann, kann die Überprüfung der Synchronität mithilfe von SMC_Set_ETC_DCSyncSupervision deaktiviert werden. SMC_DI_SWLIMITS_EXCEEDED Die Achse bewegt sich in Richtung des positiven oder negativen Software-Endschalters und wird diesen mit der aktuellen Dynamik überschreiten. Der Fehler löst auch vor der eigentlichen Endschalter-Position aus, da der benötigte Bremsweg noch in die Berechnung mit einbezogen wird. Prüfen Sie, ob die Bewegung in diesem Positionsbereich gewünscht ist Passen Sie bei Bedarf die negative und oder positive Software-Endschalterposition an. Siehe Registerkarte: AllgemeinSMC_DI_HWLIMITS_EXCEEDED Der positive oder negative Hardware-Endschalter hat ausgelöst und die Achse bewegt sich in Richtung dieses Endschalters. Prüfen Sie die kommandierte Position der Bewegung. Diese sollte die Positionen der Hardware-Endschalter nicht überschreiten. Falls die Bewegung in Ordnung ist, prüfen Sie die Signale der Hardware-Endschalter. SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT Es gibt keine aktive Bewegung, aber die Sollgeschwindigkeit ist ungleich Null und die Achse ist in einem Betriebszustand, in der den Sollwerten gefolgt wird. Mögliche Ursachen: Bei der Verwendung von MC_PositionProfile , MC_VelocityProfile oder MC_AccelerationProfile muss die Achse am Ende dieser Bewegung Stillstand erreichen oder im selben Zyklus eine Folgebewegung kommandiert werden. Ansonsten wird dieser Fehler zurückgegeben. Prüfen Sie die Ursache des Problems: Falsche Aufrufreihenfolge bei gepufferten und Blending-Bewegungen: Passen Sie die Aufrufreihenfolge an. Mehr Informationen sind im Abschnitt Aufrufreihenfolge von Bewegungsfunktionsbausteinen zu finden. Es wird MC_PositionProfile , MC_VelocityProfile oder MC_AccelerationProfile verwendet und am Ende kein Stillstand erreicht: Passen Sie das Profil entsprechend an, sodass am Ende Stillstand erreicht wird. Oder verwenden Sie stattdessen Kurvenscheiben, die einen ähnlichen Anwendungsfall wie diese Funktionsbausteine abdecken, aber flexibler und einfacher zu verwenden sind. " }, 
{ "title" : "Performance ", 
"url" : "_sm_diagnosis_performance.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Diagnose \/ Performance ", 
"snippet" : "POUs, die den Funktionsbaustein AXIS_REF_SM3 verwenden, überprüfen immer, ob sie aus der Buszyklustask aufgerufen werden. Diese Prüfung kann für zeitkritische Anwendungen mit dem Compiler-Define SM3_DISABLE_TASK_CHECKS deaktiviert werden....", 
"body" : "POUs, die den Funktionsbaustein AXIS_REF_SM3 verwenden, überprüfen immer, ob sie aus der Buszyklustask aufgerufen werden. Diese Prüfung kann für zeitkritische Anwendungen mit dem Compiler-Define SM3_DISABLE_TASK_CHECKS deaktiviert werden. " }, 
{ "title" : "Beispiele ", 
"url" : "_sm_basic_examples.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Einachsbewegungen ", 
"url" : "_sm_basic_examples_single_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Einachsbewegungen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Bewegung einzelner Achsen steuern ", 
"url" : "_sm_example_single_axis_motion_control.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Einachsbewegungen \/ Bewegung einzelner Achsen steuern ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt PLCopenSingle.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie Sie einen Antrieb mittels der nach PLCopen standardisierten Funktionsbausteine steuern können. Fügen Sie im Gerätebaum unter SoftMotion...", 
"body" : "Sehen Sie hierzu das Beispielprojekt PLCopenSingle.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie Sie einen Antrieb mittels der nach PLCopen standardisierten Funktionsbausteine steuern können. Fügen Sie im Gerätebaum unter SoftMotion General Axis Pool einen virtuellen Antrieb mit dem _Namen Drive ein. Erstellen Sie ein Programm MOTION_PRG in der Sprache ST. PROGRAM MOTION_PRG\nVAR\n iStatus: INT;\n Power: MC_Power;\n MoveAbsolute: MC_MoveAbsolute;\n p:REAL:=100;\nEND_VAR\n\nCASE iStatus OF\n\n\/\/ initialization of the axis\n0:\n Power(Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE, Axis:=Drive);\n IF Power.Status THEN\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis to position p by use of the MC_MoveAbsolute function block\n1:\n MoveAbsolute(Execute:=TRUE, Position:= p, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis back to position 0 by use of the MC_MoveAbsolute function block:\n2:\n MoveAbsolute(Execute:=TRUE, Position:= 0, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := 1;\n END_IF Fügen Sie den Aufruf des Programms MOTION_PRG zur Task MainTask hinzu. Gerätebaum: Laden Sie das Projekt auf die Steuerung und starten Sie es. Öffnen Sie die virtuelle Achse Drive im Editor. In der Sektion Online der Registerkarte Allgemein sehen Sie die Bewegung der Achse. " }, 
{ "title" : "Bewegung einzelner Achsen in CFC mit Visualisierungstemplate steuern ", 
"url" : "_sm_example_single_axis_visu_template.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Einachsbewegungen \/ Bewegung einzelner Achsen in CFC mit Visualisierungstemplate steuern ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt PLCopenSingle2.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Sie können anstelle von ST auch jede andere IEC-Programmiersprache verwenden, wie zum Beispiel CFC im vorliegenden Beispiel. Diese Sprache hilft, den Start- und ...", 
"body" : "Sehen Sie hierzu das Beispielprojekt PLCopenSingle2.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Sie können anstelle von ST auch jede andere IEC-Programmiersprache verwenden, wie zum Beispiel CFC im vorliegenden Beispiel. Diese Sprache hilft, den Start- und Unterbrechungsmechanismus der Funktionsbausteine nachzuvollziehen. Außerdem können Sie verschiedene Startmodi für den Baustein MC_MoveAbsolute für rotatorische Achsen ausprobieren. Fügen Sie im Gerätebaum unter SoftMotion General Axis Pool einen virtuellen Antrieb mit dem Namen Drive ein. Öffnen Sie mit einem Doppelklick das Objekt im Editor. Ändern Sie die Parameter auf einen rotatorischen Antrieb mit Periode 360°. Achsentyp : Modulo Modulowert [u] : 360.0 Erstellen Sie ein Programm MOTION_PRG in der Sprache CFC. Fügen Sie dazu die Funktionsbausteine MC_Power , MC_MoveAbsolute und MC_MoveVelocity ein. Es empfiehlt sich, die Bausteineingänge zu initialisieren. Dann müssen Sie später, beim Starten dieser Testapplikation, die Werte nicht stets von Neuem eingeben. PROGRAM MOTION_PRG\nVAR\n mcp: MC_Power := (Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n mcmv: MC_MoveVelocity :=(Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\n mcma: MC_MoveAbsolute := (Position:=180, Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\nEND_VAR CFC: Fügen Sie den Aufruf des Programms MOTION_PRG zur Task MainTask hinzu. Fügen Sie ein Objekt Visualisierung zu Ihrer Applikation hinzu. Platzieren Sie die Visualisierungsvorlagen VISU_NEW_MC_MoveAbsolute , VISU_NEW_MC_MoveVelocity , VISU_NEW_MC_Power und RotDrive im Visualisierungseditor. Verknüpfen Sie diese mit den Bausteininstanzen von MOTION_PRG . Visualisierung: Übersetzen Sie das Projekt und laden Sie es auf die Steuerung. Starten Sie das Projekt. Öffnen Sie die Visualierung im Editor. Drücken Sie den Eingang Enable (MC_Power) und danach den Eingang Execute (MC_Move_Absolute). Der Antrieb dreht sich. Öffnen Sie die virtuelle Achse Drive im Editor. In der Sektion Online der Registerkarte Allgemein sehen Sie die Bewegung der Achse. Spielen Sie mit den Parametern dieser Bausteine. Verändern Sie die Parameter und beobachten Sie das Verhalten. " }, 
{ "title" : "Vorausschau für Einzelachsbewegungen ", 
"url" : "_sm_basic_example_forecast.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Einachsbewegungen \/ Vorausschau für Einzelachsbewegungen ", 
"snippet" : "Das Beispielprojekt BasicMotion_Forecast.project ist im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples zu finden. Dieses Beispiel zeigt, wie Sie eine Vorausschau für eine Achse definieren und dadurch Informationen über den Zustand der Achse in der Zukunft erhalten können. ...", 
"body" : "Das Beispielprojekt BasicMotion_Forecast.project ist im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples zu finden. Dieses Beispiel zeigt, wie Sie eine Vorausschau für eine Achse definieren und dadurch Informationen über den Zustand der Achse in der Zukunft erhalten können. Im Beispiel wird eine Absolutbewegung auf einer Achse zu Position 10 ausgeführt. Durch das Setzen einer Vorausschau von 300 ms auf der Achse, können Sie in der Applikation im Vorfeld erfahren, wann und mit welcher Dynamik die Achse Position 8 durchfahren wird. Für weitere Informationen rund um das Thema Vorausschau für Achsen siehe: Vorausschau" }, 
{ "title" : "Aufbau der Applikation ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768266588", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Einachsbewegungen \/ Vorausschau für Einzelachsbewegungen \/ Aufbau der Applikation ", 
"snippet" : "Die Applikation besteht aus einem Programm PLC_PRG und einem Trace . PLC_PRG Im Zustand  STATE_POWER_DRIVE wird die virtuelle Achse eingeschalten. Daraufhin wird im Zustand STATE_SET_FORECAST mithilfe des Funktionsbausteins SMC_SetForecast eine Vorausschau von 300 ms für die Achse definiert. Die ein...", 
"body" : "Die Applikation besteht aus einem Programm PLC_PRG und einem Trace . PLC_PRG Im Zustand  STATE_POWER_DRIVE wird die virtuelle Achse eingeschalten. Daraufhin wird im Zustand STATE_SET_FORECAST mithilfe des Funktionsbausteins SMC_SetForecast eine Vorausschau von 300 ms für die Achse definiert. Die eingestellte Vorausschau der Achse kann mit dem Funktionsbaustein SMC_GetForecast ausgelesen werden. Im Zustand STATE_MOVE_TO_POSITION wird eine Absolutbewegung zu Position 10 ausgeführt. Ausserdem wird der Funktionsbaustein SMC_GetTravelTime gestartet. Mithilfe des Funktionsbausteins wird die Zeit ausgelesen, wann die Achse Position 8 erreichen wird. Um die Dynamik an Position 8 zu ermitteln, wird der Baustein SMC_ReadSetValues verwendet. Diesem Funktionsbaustein kann ein Zeit-Offset übergeben werden, zu dem man die Dynamik der Achse auslesen will. In unserem Fall übergeben wir die Zeit, bis die Achse Position 8 erreichen wird. Trace Mithilfe des Trace können Sie die Bewegung der virtuellen Achse nachvollziehen. Aufgezeichnet werden die aktuelle Position, Geschwindigkeit und Beschleunigung der Achse. Zusätzlich wird die Dauer bis zu Position 8, sowie die Dynamik der Achse an dieser Position dargestellt. Bitte beachten Sie, dass die Dauer von SMC_GetTravelTime relativ zum Beginn des Zyklus angegeben wird. Die Set-Werte der Achse entsprechen denen am Ende des Zyklus. " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768283734", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Einachsbewegungen \/ Vorausschau für Einzelachsbewegungen \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie den Trace und die Applikation. Im Trace können Sie die Bewegung der virtuellen Achse nachvollziehen. Achten Sie auf die Dauer bis und die Dynamik an Position 8...", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie den Trace und die Applikation. Im Trace können Sie die Bewegung der virtuellen Achse nachvollziehen. Achten Sie auf die Dauer bis und die Dynamik an Position 8 " }, 
{ "title" : "Synchrone Bewegungen von zwei Achsen ", 
"url" : "_sm_basic_synch_movements_2_axis_example.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Synchrone Bewegungen von zwei Achsen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Elektronisches Getriebe, Phasenversatz und Kompensation von Getriebespiel ", 
"url" : "_sm_basic_example_synchronized_motion.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Synchrone Bewegungen von zwei Achsen \/ Elektronisches Getriebe, Phasenversatz und Kompensation von Getriebespiel ", 
"snippet" : "Sehen Sie hierzu das Beispiel BasicMotion_SynchronizedMotion.project im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples . Diese Beispiel zeigt die kombinierte Verwendung eines elektronischen Getriebes mit einem Phasenversatz und Getriebespielkompensation....", 
"body" : "Sehen Sie hierzu das Beispiel BasicMotion_SynchronizedMotion.project im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples . Diese Beispiel zeigt die kombinierte Verwendung eines elektronischen Getriebes mit einem Phasenversatz und Getriebespielkompensation. " }, 
{ "title" : "Aufbau der Applikation ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Synchrone Bewegungen von zwei Achsen \/ Elektronisches Getriebe, Phasenversatz und Kompensation von Getriebespiel \/ Aufbau der Applikation ", 
"snippet" : "Die Applikation besteht aus einer einfachen Zustandsmaschine im Programm PLC_PRG und einem Trace, mit dem Sie die Funktionsweise der Funktionsbausteine nachvollziehen können. Freigeben der Achsen mit MC_Power ( STATE_POWER ). Starten der Synchronbewegungen und Verfahren der Master-Achse kontinuierli...", 
"body" : "Die Applikation besteht aus einer einfachen Zustandsmaschine im Programm PLC_PRG und einem Trace, mit dem Sie die Funktionsweise der Funktionsbausteine nachvollziehen können. Freigeben der Achsen mit MC_Power ( STATE_POWER ). Starten der Synchronbewegungen und Verfahren der Master-Achse kontinuierlich zwischen Position 0 und Position 100 ( STATE_COMMAND_POS_0 und STATE_COMMAND_POS_1) " }, 
{ "title" : "Verwendung ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Synchrone Bewegungen von zwei Achsen \/ Elektronisches Getriebe, Phasenversatz und Kompensation von Getriebespiel \/ Verwendung ", 
"snippet" : "Die Master-Achse (im Trace-Diagramm schwarz)  fährt kontinuierlich zwischen Position 0 und Position 100 hin und her mit maximaler Geschwindigkeit von 50 Einheiten pro Sekunde. Ein elektronisches Getriebe ( MC_GearIn ) mit Getriebeverhältnis 2:3 setzt die Master-Bewegung auf die Achse Slave0 um (im T...", 
"body" : "Die Master-Achse (im Trace-Diagramm schwarz)  fährt kontinuierlich zwischen Position 0 und Position 100 hin und her mit maximaler Geschwindigkeit von 50 Einheiten pro Sekunde. Ein elektronisches Getriebe ( MC_GearIn ) mit Getriebeverhältnis 2:3 setzt die Master-Bewegung auf die Achse Slave0 um (im Trace-Diagramm grün). Die aus dem Getriebe resultierende maximale Geschwindigkeit ist 75 Einheiten pro Sekunde. Darauf wird ein Phasenversatz ( MC_Phasing ) von 30 Einheiten auf die Achse Slave1  aufgebracht (im Trace-Diagramm orange). Die Geschwindigkeit ist, bis auf die Einrampphase, identisch zur Achse Slave0 . Schließlich wird noch eine Getriebespielkompensation verwendet, um die Bewegung auf Achse Drive zu bringen (im Trace-Diagramm blau). Für das Getriebespiel ist zu illustrativen Zwecken ein unrealistisch hoher Wert von 5 Einheiten eingestellt. Das Diagramm zeigt eine Ausgleichsbewegung zu Beginn der Bewegung und bei jeder Umkehr der Bewegungsrichtung. " }, 
{ "title" : "GearInPos (fliegende Säge) ", 
"url" : "_sm_basic_example_gearinpos.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Synchrone Bewegungen von zwei Achsen \/ GearInPos (fliegende Säge) ", 
"snippet" : "Sehen Sie hierzu das Beispiel BasicMotion_GearInPos.project im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt die Verwendung von MC_GearInPos zur Realisierung einer fliegenden Säge. Für dieses Projekt empfehlen wir den CODESYS Depictor zu installie...", 
"body" : "Sehen Sie hierzu das Beispiel BasicMotion_GearInPos.project im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt die Verwendung von MC_GearInPos zur Realisierung einer fliegenden Säge. Für dieses Projekt empfehlen wir den CODESYS Depictor zu installieren, der die Anwendung als 3D-Animation darstellen kann. (Dazu genügt die lizenzfreie kostenlose Variante) " }, 
{ "title" : "Aufbau der Applikation ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4565133330038434227193133829", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Synchrone Bewegungen von zwei Achsen \/ GearInPos (fliegende Säge) \/ Aufbau der Applikation ", 
"snippet" : "Die Applikation besteht aus einer Zustandsmaschine im Programm  PLC_PRG , einer 3D-Darstellung (Scene, Programm DepictorCalculation ), einer einfachen Teile-Simulation (Programm SimulateWorkpiece ) und einem Trace, mit dem Sie den Effekt der Funktionsbausteine nachvollziehen können. Der Ablauf in PL...", 
"body" : "Die Applikation besteht aus einer Zustandsmaschine im Programm  PLC_PRG , einer 3D-Darstellung (Scene, Programm DepictorCalculation ), einer einfachen Teile-Simulation (Programm SimulateWorkpiece ) und einem Trace, mit dem Sie den Effekt der Funktionsbausteine nachvollziehen können. Der Ablauf in PLC_PRG ist wie folgt: Freigabe der Achsen mit MC_Power . ( STATE_POWER ) Warten, bis die Lichtschranke ein Werkstück erkennt ( STATE_WAIT_FOR_WORKPIECE ) Sobald die Lichtschranke ein Werkstück erkennt, wird der Slave, der die Säge parallel zum Band transportiert, mit dem Werkstück auf dem Band synchronisiert (gesteuert von der Achse Master ), STATE_WAIT_FOR_SYNC ) Wenn die Synchronisation erreicht ist, wird die Säge senkrecht zum Werkstück einmal vor und zurückgefahren ( STATE_MOVE_TOOL_0\/1 ) Fahren des Slaves in die Ruheposition und Ablauf erneut bei 2. beginnen ( STATE_MOVE_TO_REST ) " }, 
{ "title" : "Koordinatensysteme und Dimensionen ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4627667581768034227193767932", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Synchrone Bewegungen von zwei Achsen \/ GearInPos (fliegende Säge) \/ Koordinatensysteme und Dimensionen ", 
"snippet" : "Der Ursprung des Koordinatensystems liegt in der Mitte des  Bands, die Z-Achse zeigt nach oben, die X-Achse zeigt in Bewegungsrichtung des Förderbandes. Die Y-Achse zeigt vom Förderband aus weg von der Säge. Die Dimensionen von Band und Werkstück, die Position der Lichtschranke und die Position, an ...", 
"body" : "Der Ursprung des Koordinatensystems liegt in der Mitte des  Bands, die Z-Achse zeigt nach oben, die X-Achse zeigt in Bewegungsrichtung des Förderbandes. Die Y-Achse zeigt vom Förderband aus weg von der Säge. Die Dimensionen von Band und Werkstück, die Position der Lichtschranke und die Position, an dem die Säge synchron zum Werkstück läuft, sind in der GVL Const als Konstanten hinterlegt. " }, 
{ "title" : "Verwendung ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm458752582335683422719410462", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Synchrone Bewegungen von zwei Achsen \/ GearInPos (fliegende Säge) \/ Verwendung ", 
"snippet" : "Starten Sie die Applikation. Im Depictor-Objekt Szene und im Trace können Sie nachvollziehen, wie die Synchronisation zwischen Master (Werkstück auf dem Band) und Slave (Säge) abläuft....", 
"body" : "Starten Sie die Applikation. Im Depictor-Objekt Szene und im Trace können Sie nachvollziehen, wie die Synchronisation zwischen Master (Werkstück auf dem Band) und Slave (Säge) abläuft. " }, 
{ "title" : "Kurvenscheiben ", 
"url" : "_sm_basic_examples_cam.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Wechselnde Kurvenscheiben ", 
"url" : "_sm_example_changing_cams.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Wechselnde Kurvenscheiben ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt PLCopenMultiCAM.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie eine Kurvenscheibenbewegung mit zwei sich abwechselnden Kurvenscheiben realisiert werden kann. Das Programm ist in ST programmiert un...", 
"body" : "Sehen Sie hierzu das Beispielprojekt PLCopenMultiCAM.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie eine Kurvenscheibenbewegung mit zwei sich abwechselnden Kurvenscheiben realisiert werden kann. Das Programm ist in ST programmiert und führt die selben Aktionen aus wie das Beispiel „Kurvenscheiben-Antriebssteuerung mit Hilfe einer virtuellen Zeitachse“. Am Ende der ersten Kurvenscheibe setzt der Funktionsbaustein MC_CamIn den Ausgang EndOfProfile . Dadurch wird die jeweils andere Kurventabelle MC_CamTableSelect zugewiesen und MC_CamIn neu gestartet. " }, 
{ "title" : "Kurvenscheiben-Antrieb mit Hilfe einer virtuellen Zeitachse steuern ", 
"url" : "_sm_example_drive_control_virtual_time_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Kurvenscheiben-Antrieb mit Hilfe einer virtuellen Zeitachse steuern ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt PLCopenMulti.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das folgende Beispiel demonstriert, wie Sie eine periodische Kurvenscheibe auf einen linearen Antrieb umsetzen. Das Beispiel zeigt weiterhin, wie Sie die Nockenfun...", 
"body" : "Sehen Sie hierzu das Beispielprojekt PLCopenMulti.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das folgende Beispiel demonstriert, wie Sie eine periodische Kurvenscheibe auf einen linearen Antrieb umsetzen. Das Beispiel zeigt weiterhin, wie Sie die Nockenfunktion anwenden können. Fügen Sie im Gerätebaum unter Applikation eine Kurvenscheibe mit dem Namen Example ein. Öffnen Sie die Kurvenscheibe im Editor. Definieren Sie in der Registerkarte Nocken eine Nocke. X : 8.0 positiver Durchlauf : Invertieren negativer Durchlauf : Invertieren Fügen Sie im Gerätebaum unter SoftMotion General Axis Pool einen virtuellen Antrieb mit dem Namen Drive ein. Wählen Sie für diese Achse den Achstyp Modulo mit einem Modulowert von 360 . Fügen Sie einen weiteren virtuellen Antrieb mit dem Namen Virtual ein. Wählen Sie für diese Achse den Achstyp Modulo mit einem Modulowert von 10 . Erstellen Sie ein Programm MOTION_PRG in der Sprache CFC. PROGRAM MOTION_PRG\nVAR\n power1, power2: MC_Power;\n TableSelect: MC_CamTableSelect;\n CamIn: MC_CamIn;\n Tappet: SMC_GetTappetValue;\n MoveVirtual: MC_MoveVelocity;\nEND_VAR Fügen Sie einen Baustein ein und weisen Sie ihm die Variable power1 zu. Der Baustein dient dem Einschalten des Antriebs von Drive . Belegen Sie die Eingänge wie folgt: Axis : Drive Enable : TRUE bRegulatorOn : TRUE bDriveStart TRUE Fügen Sie einen Baustein ein und weisen Sie ihm die Variable power2 zu. Der Baustein dient dem Einschalten des Antriebs von Virtual . Belegen Sie die Eingänge wie folgt: Axis : Virtual Enable : TRUE bRegulatorOn : TRUE bDriveStart TRUE Fügen Sie einen Baustein ein und weisen Sie ihm die Variable MoveVirtual zu. Der Baustein dient der Bewegung des virtuellen Masters. Belegen Sie die Eingänge wie folgt: Axis : Virtual Execute : power2.Status Velocity : 2 Acceleration 10 Deceleration 10 Direction positive Fügen Sie einen Baustein ein und weisen Sie ihm die Variable TableSelect zu. Der Baustein dient der Auswahl der Kurvenscheibe. Belegen Sie die Eingänge wie folgt: Master : Virtual Slave : Drive CamTable : Example Execute TRUE Periodic TRUE MasterAbsolute TRUE SlaveAbsolute TRUE Fügen Sie einen Baustein ein und weisen Sie ihm die Variable CamIn zu. Der Baustein setzt die ausgewählte Kurvenscheibe um. Belegen Sie die Eingänge wie folgt: Master : Virtual Slave : Drive Execute power1.Status MasterOffset : 0 SlaveOffset : 0 MasterScaling : 1 SlaveScaling : 1 StartMode : absolute CamTableID : TableSelect.CamTableID VelocityDiff : 1 Acceleration : 1 Deceleration : 1 TappetHysteresis : 1 Fügen Sie einen Baustein ein und weisen Sie ihm die Variable Tappet zu. Der Baustein überprüft die Stellung des Nockenschalters. Belegen Sie die Eingänge wie folgt: Tappets : CamIn.Tappets iID : 1 bInitValue FALSE bSetInitValueAtReset : FALSE Die Nocke ist als invertierende Nocke definiert. Deshalb wird sie alle 10 Sekunden ihren Wert ändern. Im Beispielprojekt sehen Sie eine Visualisierung, mit deren Hilfe Sie die einzelnen Bausteine und die Position der Achsen überprüfen können. Fügen Sie den Aufruf des Programms MOTION_PRG zur Task MainTask hinzu. Laden Sie das Projekt auf die Steuerung und starten Sie es. Für weitere Informationen siehe: MC_Power MC_CamTableSelect MC_CamIn SMC_GetTappetValue MC_MoveVelocity " }, 
{ "title" : "Kurvenscheiben programmatisch erstellen ", 
"url" : "_sm_basic_example_cam_programmatic.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Kurvenscheiben programmatisch erstellen ", 
"snippet" : "Das Beispielprojekt BasicMotion_CreateCamTableOnline.project ist im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples zu finden. Das Beispiel zeigt, wie Sie eine Kurvenscheibe im IEC-Code erstellen und verwenden können. Dabei wird auf die folgenden Punkte eingegangen: Eine i...", 
"body" : "Das Beispielprojekt BasicMotion_CreateCamTableOnline.project ist im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples zu finden. Das Beispiel zeigt, wie Sie eine Kurvenscheibe im IEC-Code erstellen und verwenden können. Dabei wird auf die folgenden Punkte eingegangen: Eine im Kurvenscheibeneditor erzeugte Kurvenscheibe wird im IEC-Code nachgebaut. In einem Fall wird die Kurvenscheibe in der Bus-Task erzeugt. Im anderen Fall wird die Kurvenscheibe in einer eigenen Task erzeugt. Alle drei Kurvenscheiben werden abschließend mit der gleichen Masterachse und unterschiedlichen Slaveachsen ausgeführt. Die Bewegung der drei Slaves ist dabei identisch. Die im IEC-Code erzeugte Kurvenscheibe wird in der Visualisierung dargestellt. Für weitere Informationen rund um die programmatische Erstellung von Kurvenscheiben siehe: Programmatisches Anlegen von Kurvenscheiben" }, 
{ "title" : "Aufbau der Applikation ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Kurvenscheiben programmatisch erstellen \/ Aufbau der Applikation ", 
"snippet" : "Die Applikation besteht aus den folgenden Bestandteilen: CamOffline Die im Kurvenscheibeneditor erzeugte Kurvenscheibe, die im IEC-Code nachgebaut werden soll. PLC_PRG Das Programm besteht aus einer einfachen Zustandsmaschine und logisch gesehen aus drei Teilen. Im ersten und zweiten Teil wird eine ...", 
"body" : "Die Applikation besteht aus den folgenden Bestandteilen: CamOffline Die im Kurvenscheibeneditor erzeugte Kurvenscheibe, die im IEC-Code nachgebaut werden soll. PLC_PRG Das Programm besteht aus einer einfachen Zustandsmaschine und logisch gesehen aus drei Teilen. Im ersten und zweiten Teil wird eine Kurvenscheibe im IEC-Code erstellt. Im dritten Teil werden die zuvor erstellten Kurvenscheiben sowie eine offline angelegte, identische Kurvenscheibe ausgeführt. Teil 1: Im ersten Zustand STATE_CREATE_ONLINE_TABLE wird eine Kurvenscheibe im IEC-Code angelegt. Dazu wird der Baustein SMCB.CamBuilder aus der Bibliothek SM3_CamBuilder  verwendet. Es werden 3 Segmente angehängt: Ein Poly5-Element gefolgt von einem Line-Element und einem weiteren Poly5-Element. Der Builder erzeugt daraus eine Kurvenscheibe CamOnline . Ab diesem Zeitpunkt ist die Kurvenscheibe im IEC-Code angelegt und kann, wie die offline im Kurvenscheibeneditor angelegte Kurvenscheibe CamOffline , verwendet werden. Teil 2: In den Zuständen STATE_INIT_ONLINE_TABLE_MULTITASK , STATE_START_CREATE_ONLINE_TABLE_MULTITASK und STATE_READ_ONLINE_TABLE_MULTITASK wird das Anlegen der Kurvenscheibe in einer anderen Task gestartet und abschließend wird diese ausgelesen. Teil 3: Im Zustand STATE_POWER_DRIVES werden die virtuellen Achsen für den Master und der drei Slaveachsen initialisiert. Daraufhin werden die Kurvenscheiben mit MC_CamTableSelect  im Zustand STATE_SELECT_TABLE ausgewählt und im finalen Zustand STATE_MOVEMENT ausgeführt. Die Masterachse wird mit MC_MoveVelocity bewegt und dient als Master für die drei Kurvenscheiben. MultitaskCamBuilder Ein Programm, das, wie in Teil 1 von  PLC_PRG beschrieben, eine Kurvenscheibe erzeugt. Einziger Unterschied ist hier, dass eine Multitask\/Multicore sichere Variante der Kurvenscheibe verwendet wird. GVL Hier ist die Multitask\/Multicore sichere Variante der Kurvenscheibe instanziiert. Visualization Die Visualisierung beinhaltet das Element SMC_Visu_CamDisplayer zum Darstellen von Kurvenscheiben. Es wird die in Teil 1 von PLC_PRG erzeugte Kurvenscheibe angezeigt. CamDisplayerSettings Zusätzliche Elemente für die Darstellung der Kurvenscheibe in Visualization Trace Mithilfe des Trace können Sie die Bewegung der virtuellen Achsen nachvollziehen. Es wird die aktuelle Position des Masters, sowie die Position, Geschwindigkeit und Beschleunigung der drei Slaveachsen aufgezeichnet. " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Kurvenscheiben programmatisch erstellen \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie den Trace und die Applikation. Beobachten Sie die Traceaufzeichnung Anzeige der erzeugten Kurvenscheibe in der Visualisierung...", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie den Trace und die Applikation. Beobachten Sie die Traceaufzeichnung Anzeige der erzeugten Kurvenscheibe in der Visualisierung " }, 
{ "title" : "Verwendung von MC_DigitalCamSwitch_HighPrecision ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Verwendung von MC_DigitalCamSwitch_HighPrecision ", 
"snippet" : "Sie finden das Beispiel BasicMotion_DigitalCamSwitch_HighPrecision.project ist im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie Sie die Ausgänge von SMC_DigitalCamSwitch_HighPrecision verwenden können, um digitale Ausgänge mit hoher Zeitauflös...", 
"body" : "Sie finden das Beispiel BasicMotion_DigitalCamSwitch_HighPrecision.project ist im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie Sie die Ausgänge von SMC_DigitalCamSwitch_HighPrecision verwenden können, um digitale Ausgänge mit hoher Zeitauflösung anzusteuern. Als Beispiel werden die Klemmen EL2258 und EL2252 von der Firma Beckhoff verwendet. Die Gerätebeschreibungen von der Fa. Beckhoff sind im Beispiel nicht enthalten. Laden Sie diese bitte direkt beim Hersteller herunter und installieren Sie sie im Geräte-Repository. Für den Betrieb des Beispiels benötigen Sie einen Buskoppler EK1100, eine Klemme EL2258 und eine Klemme EL2252. Dieses Beispiel wurde gegen die Revision 0017 der EL2258 und die Revision 0020 der EL2252 entwickelt und getestet. Es hat lediglich Beispielcharakter. Wir übernehmen keine Garantie für die Korrektheit. Der Quellcode muss vor Verwendung getestet und gegebenenfalls auf andere Revisionen der Klemmen angepasst werden. " }, 
{ "title" : "Struktur der Applikation ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856510750361", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Verwendung von MC_DigitalCamSwitch_HighPrecision \/ Struktur der Applikation ", 
"snippet" : "Die Applikation besteht aus einem Programm  Main , den Funktionsbausteinen DigitalCamSwitch_EL2258 und DigitalCamSwitch_EL2252 sowie einem Buskoppler EK1100 mit den Ausgangsklemmen EL2258 und EL2252. Die Funktionsbausteine DigitalCamSwitch_EL2258 und DigitalCamSwitch_EL2252 sind der Kern des Beispie...", 
"body" : "Die Applikation besteht aus einem Programm  Main , den Funktionsbausteinen DigitalCamSwitch_EL2258 und DigitalCamSwitch_EL2252 sowie einem Buskoppler EK1100 mit den Ausgangsklemmen EL2258 und EL2252. Die Funktionsbausteine DigitalCamSwitch_EL2258 und DigitalCamSwitch_EL2252 sind der Kern des Beispiels. Sie zeigen, wie man den Ausgang Events von SMC_DigitalCamSwitch_HighPrecision verwenden kann, um digitale Ausgänge zu programmieren. Die Funktionsbausteine sind als Muster zu verstehen, das an andere Hardware angepasst werden kann. " }, 
{ "title" : "DigitalCamSwitch_EL2258 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856513787236", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Verwendung von MC_DigitalCamSwitch_HighPrecision \/ Struktur der Applikation \/ DigitalCamSwitch_EL2258 ", 
"snippet" : "Die Arbeitsweise des Bausteins ist wie folgt: Bei steigender Flanke am Eingang Enable wird der Funktionsbaustein initialisiert. In den Zuständen STATE_INIT_0 und STATE_INIT_1 werden die Signale OutputBufferReset der Klemme EL2258 geschrieben und es wird das Array aLastEventIds  initialisiert. In die...", 
"body" : "Die Arbeitsweise des Bausteins ist wie folgt: Bei steigender Flanke am Eingang Enable wird der Funktionsbaustein initialisiert. In den Zuständen STATE_INIT_0 und STATE_INIT_1 werden die Signale OutputBufferReset der Klemme EL2258 geschrieben und es wird das Array aLastEventIds  initialisiert. In diesem Array wird pro Track die ID des zuletzt verarbeiteten Events gespeichert. Somit kann verhindert werden, dass ein Event mehrfach an die Klemme übergeben wird. Im laufenden Betrieb ( STATE_ACTIVE ) werden alle Tracks durchlaufen und für jeden Track nachfolgende Logik bearbeitet: Prüfung, ob die Klemme EL2258 die zuletzt kommandierten Events bereits übernommen hat ( ChannelsIn[channel].OutputOrderFeedback = ChannelsOut[channel].OutputOrderCounter ). Durchlaufen aller Events des Tracks. Nur die Events, deren ToggleEventId größer ist als die zuletzt bearbeitete ID, werden weiter betrachtet. (Abfrage  EventId_GreaterThan(event^.ToggleEventId, aLastEventIds[channel]) ) Siehe Abschnitt \"Hinweis zur Event-Reihenfolge\". Umrechnung der Duration des Events in einen EtherCAT-Zeitstempel und entsprechend Schreiben der Ausgänge ChannelsOut[channel].OutputEventState und  ChannelsOut[channel].OutputEventTime . Abbruch der Bearbeitung nach höchstens 5 Events. Mitteilung an die Klemme, dass neue Events anliegen, wenn mindestens ein Event gefunden wurde (C hannelsOut[channel].OutputOrderCounter := ChannelsOut[channel].OutputOrderCounter + 1 ). Hinweis zur Event-Reihenfolge Die Events werden vom Funktionsbaustein SMC_DigitalCamSwitch_HighPrecision pro Track in einem Array zurückgegeben. Für jedes Event wird die SwitchNumber und eine sogenannte ToggleEventId zurückgegeben. Diese ToggleEventId ist pro Track eindeutig und aufsteigend. Für weitere Informationen siehe SMC_CAMSWITCH_TOGGLE_EVENT . Im Beispiel wird in dem Array aLastEventIds[trackNo] pro Track gespeichert, welche  ToggleEventId in einem vergangenen Bausteinaufruf zuletzt an die Klemme übertragen wurde. Da die ToggleEventIds aufsteigend sind, ist beim nächsten Aufruf genau bekannt, welche Events noch übertragen werden müssen. Zwei Details sind noch zu beachten: Da nicht bekannt ist, bei welcher ToggleEventId die Events starten, wird neben der Id noch ein valid -Flag im Datentyp EventId gespeichert. Beim Vergleich EventId_GreaterThan wird dieses valid -Flag entsprechend berücksichtigt. Die ToggleEventIds haben den 32-Bit-Datentyp UDINT und können damit prinzipiell bei entsprechend langer Laufzeit oder hoher Schaltfrequenz überlaufen. Der Wert geht dann von 2^32-1 wieder nach 0. Die Vergleichsfunktion EventId_GreaterThan berücksichtigt auch die 32-Bit-Überläufe. PDO Mapping EL2258 Die Ausgänge ChannelsOut und ChannelsIn des Funktionsbausteins DigitalCamSwitch_EL2258 sind mit den entsprechenden E\/A-Kanälen der Klemme EL2258 verbunden. Im nachfolgenden Bild sind die Mappings für Channel 1 dargestellt. Bei Channel 2 ist es ähnlich, lediglich der Index beim Zugriff auf ChannelsOut und ChannelsIn ist 2, nicht 1. " }, 
{ "title" : "DigitalCamSwitch_EL2252 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434780928", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Verwendung von MC_DigitalCamSwitch_HighPrecision \/ Struktur der Applikation \/ DigitalCamSwitch_EL2252 ", 
"snippet" : "Das Grundprinzip ist identisch zum DigitalCamSwitch_EL2258 . Der Unterschied besteht darin, wie die Signale geschrieben werden, da die Klemme EL2252 nur ein aktives Event programmieren kann. Zuerst wird der Funktionsbaustein in STATE_INIT initialisiert. In STATE_CHECK_FOR_EVENT wird überprüft, ob Ev...", 
"body" : "Das Grundprinzip ist identisch zum DigitalCamSwitch_EL2258 . Der Unterschied besteht darin, wie die Signale geschrieben werden, da die Klemme EL2252 nur ein aktives Event programmieren kann. Zuerst wird der Funktionsbaustein in STATE_INIT initialisiert. In STATE_CHECK_FOR_EVENT wird überprüft, ob Events vom Funktionsbaustein SMC_DigitalCamSwitch_HighPrecision anstehen. Wenn ein Event vorhanden ist, muss das Event innerhalb von zwei Zyklen programmiert werden: Im ersten Zyklus werden die Ausgänge und der EtherCAT-Zeitstempel geschrieben. Der Ausgang Activate wird auf 0 gesetzt. Im zweiten Zyklus wird in STATE_ACTIVATE_EVENT_IN_EL2252  der Ausgang Activate auf 3 gesetzt. Damit wird das Event in der Klemme aktiviert. In STATE_WAIT_UNTIL_THE_INPUTS_MATCH_THE_OUTPUTS wird anschließend gewartet, bis das Event ausgeführt wurde. Hierfür werden die Signale des Eingangs Feedback der Klemme verwendet. PDO Mapping EL2252 " }, 
{ "title" : "Main ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434889277", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Verwendung von MC_DigitalCamSwitch_HighPrecision \/ Struktur der Applikation \/ Main ", 
"snippet" : "Im Hauptprogramm werden vier Schalter konfiguriert, 2 auf jedem Track. Die Tracks erhalten zudem unterschiedliche Einschalt- und Ausschaltkompensationen ( OnComp , OffComp ): Das Programm enthält die nötigen Bausteinaufrufe, um einen Forecast für die Achse zu aktivieren und sie konstant mit 180°\/s z...", 
"body" : "Im Hauptprogramm werden vier Schalter konfiguriert, 2 auf jedem Track. Die Tracks erhalten zudem unterschiedliche Einschalt- und Ausschaltkompensationen ( OnComp , OffComp ): Das Programm enthält die nötigen Bausteinaufrufe, um einen Forecast für die Achse zu aktivieren und sie konstant mit 180°\/s zu bewegen (*), sowie für SMC_DigitalCamSwitch_HighPrecision ,  DigitalCamSwitch_EL2258 und DigitalCamSwitch_EL2252 . Bevor mit der Bewegung gestartet wird, muss der Feldbus vollständig hochgefahren sein. Ansonsten können die Events nicht zur Klemme übertragen werden. (*) Die konstante Bewegung wurde gewählt, um das Beispiel einfach und übersichtlich zu halten. Der Funktionsbaustein SMC_DigitalCamSwitch_HighPrecision funktioniert jedoch mit allen Bewegungsarten. Er liefert zum Beispiel auch während einer Beschleunigungsphase oder bei Kurvenscheiben exakte Zeitstempel. " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856511865803", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Verwendung von MC_DigitalCamSwitch_HighPrecision \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie die Applikation....", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie die Applikation. " }, 
{ "title" : "Kurvenscheiben exportieren und importieren ", 
"url" : "_sm_example_cams_export_import.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Kurvenscheiben exportieren und importieren ", 
"snippet" : "Sie finden das Beispielprojekt BasicMotion_CamExportAndImport.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Beispiel zeigt, wie eine Kurvenscheibe exportiert und anschließend wieder importieren werden kann....", 
"body" : "Sie finden das Beispielprojekt BasicMotion_CamExportAndImport.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Beispiel zeigt, wie eine Kurvenscheibe exportiert und anschließend wieder importieren werden kann. " }, 
{ "title" : "Aufbau der Applikation ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm235085906313629", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Kurvenscheiben exportieren und importieren \/ Aufbau der Applikation ", 
"snippet" : "Die Applikation besteht aus dem Programm PLC_PRG und einer Kurvenscheibe CamEditor . PLC_PRG Das Programm besteht aus einer einfachen Zustandsmaschine, in der im Zustand STATE_CREATE_CAM eine Kurvenscheibe im IEC-Code angelegt wird. Für weitere Informationen siehe: Kurvenscheiben programmatisch erst...", 
"body" : "Die Applikation besteht aus dem Programm PLC_PRG und einer Kurvenscheibe CamEditor . PLC_PRG Das Programm besteht aus einer einfachen Zustandsmaschine, in der im Zustand STATE_CREATE_CAM eine Kurvenscheibe im IEC-Code angelegt wird. Für weitere Informationen siehe: Kurvenscheiben programmatisch erstellen. Diese Kurvenscheibe wird anschließend in Zustand STATE_EXPORT_CAM durch den Funktionsbausteins SMC_WriteCAM exportiert und abschließend im Zustand STATE_START_IMPORT_CAM mit SMC_ReadCAM wieder eingelesen. CamEditor Die Kurvenscheibe hat initial keine Bedeutung, da diese in der Applikation nicht verwendet wird. Die exportierte Kurvenscheibe aus PLC_PRG kann in den Kurvenscheibeneditor importiert werden. Dies ist ein manueller Schritt, der im nachfolgenden Abschnitt beschrieben wird. " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm23508590648994", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Kurvenscheiben \/ Kurvenscheiben exportieren und importieren \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie die Applikation. Das Programm PLC_PRG erzeugt die Kurvenscheibe und exportiert sie in das Verzeichnis PlcLogic der Steuerung. Sie können die exportierte Kurvenscheibe auch im Kurvenscheibeneditor anzeigen und weiter bea...", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie die Applikation. Das Programm PLC_PRG erzeugt die Kurvenscheibe und exportiert sie in das Verzeichnis PlcLogic der Steuerung. Sie können die exportierte Kurvenscheibe auch im Kurvenscheibeneditor anzeigen und weiter bearbeiten. Öffnen Sie hierfür die Kurvenscheibe CamEditor und lesen die Kurvenscheibe mit dem Befehl Kurvenscheiben-Onlinedatei lesen ein. Wenn Sie Änderungen vorgenommen haben, können Sie die veränderte Kurvenscheibe mit dem Befehl Kurvernscheiben-Onlinedatei schreiben exportieren. Diese Kurvenscheibe kann im IEC-Code mit dem Funktionsbaustein SMC_ReadCAM eingelesen und in der Applikation verwendet werden. " }, 
{ "title" : "Geschwindigkeits-Override für Softmotion-Achsen ", 
"url" : "_sm_example_override.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Geschwindigkeits-Override für Softmotion-Achsen ", 
"snippet" : "Das hier beschriebene Beispielprojekt  BasicMotion_Override.project  finden Sie im Installationsverzeichnis von  CODESYS  unter  ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie Sie einen Geschwindigkeits-Override für eine Softmotion-Achse definieren. Für weitere Informationen zum Thema O...", 
"body" : "Das hier beschriebene Beispielprojekt  BasicMotion_Override.project  finden Sie im Installationsverzeichnis von  CODESYS  unter  ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie Sie einen Geschwindigkeits-Override für eine Softmotion-Achse definieren. Für weitere Informationen zum Thema Override siehe: Dynamikanpassung mit MC_SetOverride" }, 
{ "title" : "Struktur der Applikation ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4552520462032034028650702932", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Geschwindigkeits-Override für Softmotion-Achsen \/ Struktur der Applikation ", 
"snippet" : "Die Applikation besteht aus einem Programm PLC_PRG und einem Trace . PLC_PRG Das Programm besteht aus einer einfachen Zustandsmaschine. Im ersten Zustand  STATE_POWER  wird die virtuelle Achse Drive initialisiert. Im zweiten Zustand  STATE_COMMAND_MOVEMENT  wird ein Geschwindigkeits-Override von 0.5...", 
"body" : "Die Applikation besteht aus einem Programm PLC_PRG und einem Trace . PLC_PRG Das Programm besteht aus einer einfachen Zustandsmaschine. Im ersten Zustand  STATE_POWER  wird die virtuelle Achse Drive initialisiert. Im zweiten Zustand  STATE_COMMAND_MOVEMENT  wird ein Geschwindigkeits-Override von 0.5 gesetzt, damit die Bewegungen der Achse nur mit halber Geschwindigkeit ausgeführt werden. Anschließend wird eine Bewegung mittels  MC_MoveAbsolute  zu Position 10 ausgeführt. Am Baustein ist eine maximale Geschwindigkeit von 20 Einheiten\/s angegeben. Durch den eingestellten Geschwindigkeits-Override in der virtuellen Achse wird die Bewegung mit einer maximalen Geschwindigkeit von 10 Einheiten\/s ausgeführt. Sobald an Position 5 die Hälfte der Bewegung abgeschlossen ist, wird im Zustand   STATE_CHANGE_OVERRIDE  der Geschwindigkeits-Override auf 0.25 reduziert. Die Achse verzögert auf 5 Einheiten\/s und führt den Rest der Bewegung mit dieser Geschwindigkeit aus. Im Programm werden zusätzlich noch die aktiven Override-Faktoren (Geschwindigkeit, Beschleunigung und Ruck) der virtuellen Achse ausgelesen. Dafür wird der Baustein  SMC_GetOverride  verwendet. Trace Mithilfe des Trace kann die Bewegung der virtuellen Achse nachvollzogen werden. Dabei werden die aktuell vorgegebene Position, die Geschwindigkeit und die Beschleunigung der Achse sowie der aktive Geschwindigkeits-Override aufgezeichnet. " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4563439233780834028650966211", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Geschwindigkeits-Override für Softmotion-Achsen \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie den Trace und die Applikation. Im Trace können Sie die Bewegung der virtuellen Achse nachvollziehen....", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie den Trace und die Applikation. Im Trace können Sie die Bewegung der virtuellen Achse nachvollziehen. " }, 
{ "title" : "Abstandsbasiertes Einrampen ", 
"url" : "_sm_axis_based_ramp_in.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Abstandsbasiertes Einrampen ", 
"snippet" : "Das hier beschriebene Beispielprojekt  BasicMotion_CamIn_StartModes.project  finden Sie im Installationsverzeichnis von CODESYS unter dem Verzeichnis  ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt die Verwendung des Eingangs  StartMode  des Funktionsbausteins MC_CamIn . Über diesen Eingang ...", 
"body" : "Das hier beschriebene Beispielprojekt  BasicMotion_CamIn_StartModes.project  finden Sie im Installationsverzeichnis von CODESYS unter dem Verzeichnis  ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt die Verwendung des Eingangs  StartMode  des Funktionsbausteins MC_CamIn . Über diesen Eingang wird konfiguriert, auf welche Weise die Slave-Achse beim Start von MC_CamIn mit der Master-Achse synchronisiert wird. Im Wesentliche gibt es die folgenden drei Möglichkeiten Die Slave-Achse folgt sofort der durch Kurvenscheibe und Master-Achse vorgegebenen Trajektorie. Abhängig vom Startzustand der Slave-Achse kann dies zu einem Positions-, Geschwindigkeits- und\/oder Beschleunigungssprung der Slave-Achse führen. StartMode :  absolute ,  relative Die Slave-Achse synchronisiert so schnell wie möglich unter Einhaltung von vorgebbaren Geschwindigkeits-, Beschleunigungs-, Verzögerungs- und Ruckgrenzen.  StartMode :  ramp_in ,  ramp_in_pos ,  ramp_in_neg Es wird eine Masterposition in der Kurvenscheibe angegeben, an der die Slave-Achse der durc Kurvenscheibe und Master-Achse vorgegebenen Trajektorie folgen soll. Die Synchronisation findet über eine konfigurierbare Distanz der Master-Achse statt. StartMode : ramp_in_dist Für weitere Informationen über den Funktionsbaustein MC_CamIn siehe:  MC_CamIn (FB) " }, 
{ "title" : "Struktur der Applikation ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4561064201451234280796827706", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Abstandsbasiertes Einrampen \/ Struktur der Applikation ", 
"snippet" : "Die Applikation besteht aus einem Programm PLC_PRG und einem Trace. Außerdem gibt es vier virtuelle Achsen: die Master-Achse Master und die drei Slave-Achsen SlaveAbsolute , SlaveRampIn und SlaveRampInDist . Und es gibt die Kurvenscheibe Cam . Im Programm PLC_PRG werden drei Instanzen von MC_CamIn m...", 
"body" : "Die Applikation besteht aus einem Programm PLC_PRG und einem Trace. Außerdem gibt es vier virtuelle Achsen: die Master-Achse Master und die drei Slave-Achsen SlaveAbsolute , SlaveRampIn und SlaveRampInDist . Und es gibt die Kurvenscheibe Cam . Im Programm PLC_PRG werden drei Instanzen von MC_CamIn mit unterschiedlich gesetztem StartMode -Eingang ausgeführt: ciSlaveAbsolute mit  StartMode = absolute ciSlaveRampIn mit  StartMode = ramp_in ciSlaveRampInDist mit  StartMode = ramp_in_dist Die Bausteininstanzen steuern die zugehörigen virtuellen Achsen SlaveAbsolute , SlaveRampIn und SlaveRampInDist . Die Master-Achse wird mit einer MC_MoveVelocity -Instanz mit konstanter Geschwindigkeit bewegt. Im Trace können die Trajektorien der drei Slave-Achsen sowie die Ausgänge  Active und  InSync  der MC_CamIn -Instanzen verfolgt werden. Alle MC_CamIn -Instanzen werden gestartet, wenn die Master-Achse Position 40 überschreitet: Die Achse SlaveAbsolute springt sofort auf die über die Kurvenscheibe definierten Sollwerte. Die zugehörige MC_CamIn -Instanz ist sofort  Active und  InSync . Die Achse SlaveRampIn synchronisiert unter Einhaltung der kommandierten Dynamikgrenzen. Die zugehörige MC_CamIn -Instanz ist sofort  Active . Ab Master-Position ~114 folgt die Slave-Achse der durch die von der Kurvenscheibe und der Master-Achse vorgegebenen Trajektorie und die MC_CamIn -Instanz meldet  InSync . Die Achse SlaveRampInDist bleibt zunächst stehen, bis die Master-Achse bis auf die an der MC_CamIn -Instanz konfigurierten  MasterStartDistance von 60 an die  MasterSyncPosition von 120 herangekommen ist. Dann beginnt die Synchronisierung und die MC_CamIn -Instanz meldet  Active . Wenn die Master-Achse die  MasterSyncPosition 120 erreicht, folgt die Slave-Achse der durch Kurvenscheibe und Master-Achse vorgegebenen Trajektorie und die MC_CamIn -Instanz meldet  InSync . " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4602846053456034280814845985", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Beispiele \/ Abstandsbasiertes Einrampen \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie den Trace und die Applikation. Im Trace können Sie die Bewegung der virtuellen Achsen nachvollziehen....", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie den Trace und die Applikation. Im Trace können Sie die Bewegung der virtuellen Achsen nachvollziehen. " }, 
{ "title" : "Benutzeroberfläche ", 
"url" : "_sm_basic_user_interface.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Benutzeroberfläche ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Kurvenscheibe ", 
"url" : "_sm_basic_user_interface_cam.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Benutzeroberfläche \/ Kurvenscheibe ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Dialog: Eigenschaften - Kurvenscheibe ", 
"url" : "_sm_dlg_properties_cam.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Benutzeroberfläche \/ Kurvenscheibe \/ Dialog: Eigenschaften - Kurvenscheibe ", 
"snippet" : "Funktion : In diesem Dialog definieren Sie die globalen Einstellungen der Kurvenscheibe. Dimensionen Master Start-\/Endposition Start- und Endposition des Masters definieren den Umfang der Masterwerte und damit die Skala der horizontalen Achse der Kurvenscheibe. Die Standardeinstellungen erfolgen in ...", 
"body" : "Funktion : In diesem Dialog definieren Sie die globalen Einstellungen der Kurvenscheibe. Dimensionen Master Start-\/Endposition Start- und Endposition des Masters definieren den Umfang der Masterwerte und damit die Skala der horizontalen Achse der Kurvenscheibe. Die Standardeinstellungen erfolgen in Winkelgraden und somit werden 0 und 360 als Grenzwerte vorgegeben. Slave Start-\/Endposition Die zugeordneten Slavepositionen werden durch den Abbildungstyp, der für die Kurvenscheibe definiert ist, bestimmt. Jedoch kann der durch die Kurven dargestellte Ausschnitt, d.h. die Skala der vertikalen Achse, über die hier angegebenen Start- und Endpositionen des Slaves festgelegt werden. Periode Diese Einstellungen wirken sich auf das Arbeiten im Kurvenscheibeneditor und in der Kurvenscheibentabelle aus. Abhängig von diesen Parametern wird der Slavestartpunkt automatisch angepasst, wenn der Endpunkt verändert wird und umgekehrt. Diese Anpassung optimiert den Periodenübergang, so dass dieser möglichst gleichmäßig und ruckfrei erfolgt. Übergang glätten : Die Werte für Position, Geschwindigkeit und Beschleunigung werden automatisch angepasst. Slaveperiode Gibt an, wann sich die Slaveperiode mechanisch wiederholt. Die Slaveposition am Ende und am Anfang der Masterperiode dürfen sich um ein ganzzahliges Vielfaches dieses Wertes unterscheiden. Dieser Wert ist nur wirksam, wenn der Übergang glätten aktiviert ist. Kontinuitätsanforderungen Die Aktivierung dieser Optionen bzgl. der Stetigkeit der Abbildung hat keine Auswirkung auf das Editieren der Kurve. Aber sie bewirkt eine Prüfung der Stetigkeit und eventuelle Verletzungen werden im Meldungsfenster (Kategorie CAM ) ausgegeben. Es ist nicht möglich, in der Positionsabbildung Sprünge zu bearbeiten. Die Standardeinstellung fordert außerdem Kontinuität von Geschwindigkeit und Beschleunigung. Die Optionen können deaktiviert werden (beispielsweise im speziellen Fall einer Abbildung, die nur aus linearen Segmenten besteht). Dies kann jedoch zu Knicken in der Positionskurve führen. Standardmäßig wird der Ruck, d.h. die vierte Ableitung, nicht auf Sprünge getestet. Position : Der Verlauf wird auf Sprünge getestet. Geschwindigkeit Beschleunigung Ruck Übersetzungsformat Während der Übersetzung werden Strukturvariablen des Typs MC_CAM_REF erzeugt. Die Beschreibung eines Kurvenscheibensegments erfolgt gemäß einer der folgenden Optionen: polynomial (XYVA) polynomiale Beschreibung der einzelnen Punkte, bestehend aus Masterposition, Slaveposition, Slavegeschwindigkeit und Slavebeschleunigung. eindimensionales Punkte-Array 1-dimensionale Tabelle von Slavepositionen zweidimensionales Punkte-Array 2-dimensionale Tabelle von zusammengehörigen Master\/Slavepositionen Elemente Anzahl der Elemente für das 1- oder 2-dimensionale Punkte-Arrays. Für die Standardfälle 128 und 256 ist dieses Array bereits in der SM3_Basic angelegt. Wenn Sie einen anderen Wert eingeben, müssen Sie die Struktur in Ihrer Applikation selbst anlegen. Sehen Sie dazu nachfolgendes Beispiel. Segmente Standard-Übersetzungsformat, unterstützt alle Segmenttypen Beispiel für ein Array mit 720 Elementen TYPE SMC_CAMTable_LREAL_720_2 :\nSTRUCT\n Table: ARRAY[0..719] OF ARRAY[0..1] OF LREAL;\n fEditorMasterMin, fEditorMasterMax: REAL;\n fEditorSlaveMin, fEditorSlaveMax: REAL;\n fTableMasterMin, fTableMasterMax: REAL;\n fTableSlaveMin, fTableSlaveMax: REAL;\nEND_STRUCT\nEND_TYPE Für weitere Informationen siehe: How-To: Kurvenscheibe anlegen" }, 
{ "title" : "Befehl: Zeige generierten Code an ", 
"url" : "_sm_cmd_cam_display_generated_code.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Benutzeroberfläche \/ Kurvenscheibe \/ Befehl: Zeige generierten Code an ", 
"snippet" : "Zeige generierten Code an Funktion : Der Befehl öffnet den Dialog Generierter Code , in dem der IEC-Initialisierungscode der dargestellten Kurvenscheibe angezeigt wird. Aufruf : Menü Kurvenscheibe Voraussetzung : Der Kurvenscheibeneditor ist geöffnet und stellt eine Kurvenscheibe dar. Für das Überse...", 
"body" : "Zeige generierten Code an Funktion : Der Befehl öffnet den Dialog Generierter Code , in dem der IEC-Initialisierungscode der dargestellten Kurvenscheibe angezeigt wird. Aufruf : Menü Kurvenscheibe Voraussetzung : Der Kurvenscheibeneditor ist geöffnet und stellt eine Kurvenscheibe dar. Für das Übersetzungsformat Segmente wird keine generierter Code angezeigt. Der generierte Code ist nicht mehr notwendig, da mit der CamBuilder-API Kurvenscheiben programmatisch auf bessere Weise erzeugt werden können. Dialog: Generierter Code Beispiel: IEC-Initialisierungscode {attribute 'linkalways'}\n\nVAR_GLOBAL\nCam_A: ARRAY[0..3] OF SMC_CAMXYVA := [\n (dX := 0, dY := 0, dV := 0, dA := 0),\n (dX := 120, dY := 120, dV := 1, dA := 0),\n (dX := 240, dY := 240, dV := 1, dA := 0),\n (dX := 360, dY := 360, dV := 0, dA := 0)];\nCam: MC_CAM_REF := (nElements := 4, byType := 3, xStart := 0, xEnd := 360, nTappets := 0, strCAMName := 'Cam', pce := ADR(Cam_A), xPartofLM := TRUE);\nEND_VAR " }, 
{ "title" : "Befehl: Kurvenscheibendaten aus ASCII-Tabelle lesen ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Benutzeroberfläche \/ Kurvenscheibe \/ Befehl: Kurvenscheibendaten aus ASCII-Tabelle lesen ", 
"snippet" : "Kurvenscheibendaten aus ASCII-Tabelle lesen Funktion : Der Befehl bewirkt, dass eine ASCII -Datei eingelesen wird. Aufruf : Menü Kurvenscheibe Voraussetzung : Der Kurvenscheibeneditor ist geöffnet. Beim Einlesen werden die Dateidaten als X\/Y-Werte einer Kurvenscheibe interpretiert. Dabei öffnet sich...", 
"body" : "Kurvenscheibendaten aus ASCII-Tabelle lesen Funktion : Der Befehl bewirkt, dass eine ASCII -Datei eingelesen wird. Aufruf : Menü Kurvenscheibe Voraussetzung : Der Kurvenscheibeneditor ist geöffnet. Beim Einlesen werden die Dateidaten als X\/Y-Werte einer Kurvenscheibe interpretiert. Dabei öffnet sich der Dialog Anzahl Punkte , so dass Sie die Anzahl der Interpolationspunkte verringern können. Dann werden die ermittelten Punkte zu einer Kurvenscheibe interpoliert und im Editor dargestellt. Eine geeignete Datei im TXT -Format wurde mit dem Befehl Kurvenscheiben-Daten in ASCII-Tabelle schreiben erstellt. " }, 
{ "title" : "Dialog: Anzahl Punkte ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html#UUID-dc22ffbd-b76b-ca74-a92b-235fbf0143cb_id_d53fe1240e8dd1c0a8640e0032565c_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Benutzeroberfläche \/ Kurvenscheibe \/ Befehl: Kurvenscheibendaten aus ASCII-Tabelle lesen \/ Dialog: Anzahl Punkte ", 
"snippet" : "Anzahl Punkte Anzahl der Punkte, durch die interpoliert wird. Voreinstellung: Entspricht der Anzahl X\/Y-Werte, die in der eingelesenen Datei gespeichert sind. Beispiel: 256 Sie können den voreingestellten Wert verringern, um die Kurvenscheibe durch weniger Interpolationspunkte zu bestimmen. Bei der ...", 
"body" : "Anzahl Punkte Anzahl der Punkte, durch die interpoliert wird. Voreinstellung: Entspricht der Anzahl X\/Y-Werte, die in der eingelesenen Datei gespeichert sind. Beispiel: 256 Sie können den voreingestellten Wert verringern, um die Kurvenscheibe durch weniger Interpolationspunkte zu bestimmen. Bei der Ermittlung der Interpolationspunkte wird berücksichtigt, dass ihre X-Werte äquidistant verteilt bleiben. Da die Kurvenscheibe durch ein Polynom fünften Grades interpoliert wird, kann eine hohe Anzahl an Interpolationspunkten zu Oszillationen führen. " }, 
{ "title" : "Befehl: Kurvenscheibendaten in ASCII-Tabelle schreiben ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Benutzeroberfläche \/ Kurvenscheibe \/ Befehl: Kurvenscheibendaten in ASCII-Tabelle schreiben ", 
"snippet" : "Kurvenscheibendaten in ASCII-Tabelle schreiben Funktion : Der Befehl bewirkt, dass eine ASCII -Datei (Dateiendung TXT ) auf dem Entwicklungssystem erstellt wird. Darin wird eine von Ihnen bestimmte Anzahl an X\/Y-Werten der gerade aktiven Kurvenscheibe gespeichert. Dabei öffnet sich erst ein Standard...", 
"body" : "Kurvenscheibendaten in ASCII-Tabelle schreiben Funktion : Der Befehl bewirkt, dass eine ASCII -Datei (Dateiendung TXT ) auf dem Entwicklungssystem erstellt wird. Darin wird eine von Ihnen bestimmte Anzahl an X\/Y-Werten der gerade aktiven Kurvenscheibe gespeichert. Dabei öffnet sich erst ein Standarddialog und dann der Dialog Anzahl Punkte . Aufruf : Menü Kurvenscheibe Voraussetzung : Der Kurvenscheibeneditor ist geöffnet und stellt eine Kurvenscheibe dar. " }, 
{ "title" : "Dialog: Anzahl Punkte ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html#UUID-b84e5af8-679e-916c-e8a6-2358c4cccb5c_id_c2bdaa8241199e2c0a8640e018c7af7_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Benutzeroberfläche \/ Kurvenscheibe \/ Befehl: Kurvenscheibendaten in ASCII-Tabelle schreiben \/ Dialog: Anzahl Punkte ", 
"snippet" : "Die ASCII-Tabelle enthält keine Information über Nocken. Anzahl Punkte Anzahl an X\/Y-Werten, die tabellarisch in der Datei gespeichert werden und den Kurvenverlauf wiedergeben. Dabei wird der X-Verlauf äquidistant zerlegt und der zugehörige Y-Wert ermittelt....", 
"body" : "Die ASCII-Tabelle enthält keine Information über Nocken. Anzahl Punkte Anzahl an X\/Y-Werten, die tabellarisch in der Datei gespeichert werden und den Kurvenverlauf wiedergeben. Dabei wird der X-Verlauf äquidistant zerlegt und der zugehörige Y-Wert ermittelt. " }, 
{ "title" : "Befehl: Kurvenscheiben-Onlinedatei lesen ", 
"url" : "_sm_cmd_cam_read_online_file.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Benutzeroberfläche \/ Kurvenscheibe \/ Befehl: Kurvenscheiben-Onlinedatei lesen ", 
"snippet" : "Kurvenscheiben-Onlinedatei lesen Funktion : Der Befehl bewirkt, dass eine externe Datei mit Kurvenscheibendaten eingelesen wird. Die Dateiendung ist CAM . Die Kurvenscheibe wird im Kurvenscheibeneditor dargestellt. Aufruf : Menü Kurvenscheibe Voraussetzung : Der Kurvenscheibeneditor ist geöffnet. Si...", 
"body" : "Kurvenscheiben-Onlinedatei lesen Funktion : Der Befehl bewirkt, dass eine externe Datei mit Kurvenscheibendaten eingelesen wird. Die Dateiendung ist CAM . Die Kurvenscheibe wird im Kurvenscheibeneditor dargestellt. Aufruf : Menü Kurvenscheibe Voraussetzung : Der Kurvenscheibeneditor ist geöffnet. Sie erstellen eine geeignete Datei im CAM -Format mit dem Befehl Kurvenscheiben-Onlinedatei schreiben . " }, 
{ "title" : "Befehl: Kurvenscheiben-Onlinedatei schreiben ", 
"url" : "_sm_cmd_cam_write_online_file.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS Softmotion Basic \/ Benutzeroberfläche \/ Kurvenscheibe \/ Befehl: Kurvenscheiben-Onlinedatei schreiben ", 
"snippet" : "Kurvernscheiben-Onlinedatei schreiben Funktion : Der Befehl bewirkt, dass eine Datei (Dateinendung CAM ) erstellt wird. Die Datei enthält die Daten der Kurvenscheibe, die gerade im Editor aktiv ist. Aufruf : Menü Kurvenscheibe Voraussetzung : Der Kurvenscheibeneditor ist geöffnet und stellt eine Kur...", 
"body" : "Kurvernscheiben-Onlinedatei schreiben Funktion : Der Befehl bewirkt, dass eine Datei (Dateinendung CAM ) erstellt wird. Die Datei enthält die Daten der Kurvenscheibe, die gerade im Editor aktiv ist. Aufruf : Menü Kurvenscheibe Voraussetzung : Der Kurvenscheibeneditor ist geöffnet und stellt eine Kurvenscheibe dar. Die Kurvenscheibendaten setzen sich aus einer Beschreibung der Kurvenscheibe und den Positionen und Typen der Nocken zusammen. Eine CAM-Datei kann mit dem Befehl Kurvenscheiben-Onlinedatei lesen in den Editor eingelesen werden. Außerdem kann eine Instanz des Funktionsbausteins SMC_ReadCAM die Datei einlesen, um eine Kurvenscheibentabelle zur Laufzeit in eine Applikation zu laden. Für weitere Informationen siehe: Datenstrukturen der Kurvenscheibe" }, 
{ "title" : "CODESYS SoftMotion CNC ", 
"url" : "_sm_f_cnc.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Editor ", 
"url" : "_sm_f_cnc_editor.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Übersicht ", 
"url" : "_sm_overview_cnc_editor.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ Übersicht ", 
"snippet" : "Im CNC-Editor implementieren Sie komplexe mehrdimensionale Bewegungen im Tabelleneditor oder im Texteditor nach der CNC-Sprache DIN 66025. Der Editor stellt außerdem zur Verfügung: einen grafischen Editor zur Darstellung der Bahn eine Werkzeugbox für den grafischen Editor eine Ansicht mit den Eigens...", 
"body" : "Im CNC-Editor implementieren Sie komplexe mehrdimensionale Bewegungen im Tabelleneditor oder im Texteditor nach der CNC-Sprache DIN 66025. Der Editor stellt außerdem zur Verfügung: einen grafischen Editor zur Darstellung der Bahn eine Werkzeugbox für den grafischen Editor eine Ansicht mit den Eigenschaften des selektierten Bahnelements " }, 
{ "title" : "CNC-Editor Grundlagen ", 
"url" : "_sm_cnc_edt_basics.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC-Editor Grundlagen ", 
"snippet" : "In DIN 66025 können Sie grundsätzlich bis zu 9-dimensionale Bahnen realisieren, wobei drei Dimensionen nicht linear interpoliert werden. In X\/Y\/Z können Sie Linien, Kreisbögen, Ellipsen, Parabeln und Splines programmieren. Sie haben weitere acht so genannte Zusatzachsen zur Verfügung. Davon werden f...", 
"body" : "In DIN 66025 können Sie grundsätzlich bis zu 9-dimensionale Bahnen realisieren, wobei drei Dimensionen nicht linear interpoliert werden. In X\/Y\/Z können Sie Linien, Kreisbögen, Ellipsen, Parabeln und Splines programmieren. Sie haben weitere acht so genannte Zusatzachsen zur Verfügung. Davon werden fünf linear interpoliert (P\/Q\/U\/V\/W) und drei mit einem Polynom vom Grad 3 (A\/B\/C). Der Interpolator berechnet für jeden Satz im CNC-Programm den Verfahrweg. Dabei berechnet der Interpolator den Verlauf des Wegs, der Geschwindigkeit, der Beschleunigung und des Rucks entprechend der angegebenen Interpolation. Für jede programmierte Bahn erzeugt CODESYS automatisch eine globale Datenstruktur, die CNC-Daten, die in einem IEC-Programm verwendet werden kann. Hierfür gibt es verschiedene Möglichkeiten: SMC_CNC_REF : Das CNC-Programm wird als Array aus G-Code-Worten abgelegt, die zur Laufzeit der Applikation mit Hilfe von SMC_NCInterpreter verarbeitet werden. Das Ergebnis ist die CNC-Bahn, beschrieben als Sequenz von GEOINFO-Strukturobjekten. Diese können mit Hilfe von Bahnvorverarbeitungsmodulen der Bibliothek SM3_CNC, wie beispielsweise Werkzeugradiuskorrektur, bearbeitet, interpoliert, transformiert und dem Drive-Interface wieder zur Kommunikation an die Hardware übergeben werden. SMC_OUTQUEUE : Das CNC-Programm wird als Liste von GEOINFO-Strukturobjekten mit Namen SMC_OUTQUEUE in eine Datenstruktur geschrieben und kann so direkt in den Interpolator eingegeben werden. Im Vergleich zu SMC_CNC_REF müssen dadurch der Interpreter-Funktionsbaustein und die Bahnvorverarbeitungs-Funktionsbausteine nicht aufgerufen werden. Jedoch kann dadurch das Programm zur Laufzeit nicht verändert werden und es können in diesem Modus keine Variablen im G-Code verwendet werden. FILE : Das CNC-Programm wird als ASCII-Datei im Dateisystem der Steuerung gespeichert und zur Laufzeit schrittweise ausgelesen und umgesetzt. Diese Methode eignet sich vor allem für große Programme, die nicht komplett im Speicher gehalten werden können. Ebenso eignet sie sich für Programme die vom Anwender nach dem Übersetzen der Steuerungsapplikation generiert wurden. " }, 
{ "title" : "Aufbau des CNC-Editors ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_43423fe2e9a24fa0c0a864632228473f", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC-Editor Grundlagen \/ Aufbau des CNC-Editors ", 
"snippet" : "Der CNC-Editor besteht aus folgenden Komponenten: Haupteditor: Text- oder Tabelleneditor: im Texteditor wird das DIN 66025 Programm dargestellt, im Tabelleneditor wird die CNC-Bahn dargetellt. Grafischer Editor: hier wird die grafische Ansicht der Bahn angezeigt. Ansicht Eigenschaften der CNC-Elemen...", 
"body" : "Der CNC-Editor besteht aus folgenden Komponenten: Haupteditor: Text- oder Tabelleneditor: im Texteditor wird das DIN 66025 Programm dargestellt, im Tabelleneditor wird die CNC-Bahn dargetellt. Grafischer Editor: hier wird die grafische Ansicht der Bahn angezeigt. Ansicht Eigenschaften der CNC-Elemente Ansicht Werkzeuge : enthält Werkzeuge für das Auswählen und Einfügen von Bahnelementen Mit Drücken von F6 wechselt der Fokus zwischen dem Haupteditor und dem grafischen Editor. Wenn ein Bahnelement im grafischen Editor selektiert wird, dann ist implizit im Texteditor oder im Tabelleneditor der zugehörige Satz oder die zugehörige Zeile ausgewählt. Umgekehrt wird ein im Tabellen- oder Texteditor selektiertes Element im grafischen Editor ebenfalls selektiert. Änderungen im grafischen Editor werden im Text- oder im Tabelleneditor übernommen und umgekehrt. Applikationsweite CNC-Einstellungen werden im Objekt CNC-Einstellungen vorgenommen und gespeichert. Objektweite CNC-Einstellungen werden im Dialog Eigenschaften des CNC-Objekts vorgenommen und gespeichert. " }, 
{ "title" : "SoftMotion-Software-Bestandteile des CNC-Editors ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_92f7df24e9a24fa0c0a864630c4c4560", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC-Editor Grundlagen \/ SoftMotion-Software-Bestandteile des CNC-Editors ", 
"snippet" : "(1) CNC-Editor (2) IEC-Programm (3) Parameter (4) Interpreter (5) GeoInfo (6) Bahnvorverarbeitung (7) Interpolator (8) Bahnpunkte (9) kartesische Koordinaten (10) direkte Kinematik (11) maschinenabhängige Transformation (12) inverse Kinematik (13) Achsposition (14) Drive Interface...", 
"body" : "(1) CNC-Editor (2) IEC-Programm (3) Parameter (4) Interpreter (5) GeoInfo (6) Bahnvorverarbeitung (7) Interpolator (8) Bahnpunkte (9) kartesische Koordinaten (10) direkte Kinematik (11) maschinenabhängige Transformation (12) inverse Kinematik (13) Achsposition (14) Drive Interface " }, 
{ "title" : "Kompilieren eines CNC-Objekts ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_c0635f14eddc9007c0a8646316c80481", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC-Editor Grundlagen \/ Kompilieren eines CNC-Objekts ", 
"snippet" : "Der Übersetzungsmodus wird beim Hinzufügen eines neuen CNC-Objekts ausgewählt und kann bei Bedarf im Dialog Eigenschaften , Registerkarte CNC des CNC-Objekts geändert werden. Abhängig von diesem Übersetzungsmodus wird während des Kompilierens ein Funktionsbaustein des Typs SMC_OutQueue , des Typs SM...", 
"body" : "Der Übersetzungsmodus wird beim Hinzufügen eines neuen CNC-Objekts ausgewählt und kann bei Bedarf im Dialog Eigenschaften , Registerkarte CNC des CNC-Objekts geändert werden. Abhängig von diesem Übersetzungsmodus wird während des Kompilierens ein Funktionsbaustein des Typs SMC_OutQueue , des Typs SMC_CNC_REF oder eine ASCII-Datei mit der programmierten CNC-Bahn erzeugt. Wenn im Dialog Eigenschaften , Registerkarte Übersetzen des CNC-Objekts die Option Vom Übersetzen ausschließen aktiviert ist, werden keine IEC-Daten generiert. Beim Übersetzungsmodus File werden dann keine Daten auf die Steuerung geladen. " }, 
{ "title" : "Öffnen eines CoDeSys V2.3 -Projekts ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_88cb0aeee9a24fa0c0a864634f00b359", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC-Editor Grundlagen \/ Öffnen eines CoDeSys V2.3 -Projekts ", 
"snippet" : "Wenn Sie in CODESYS V3 ein CoDeSys V2.3 -Projekt öffnen, steht ein Konverter zur Verfügung, der folgende Funktionen ausführt, vorausgesetzt wird eine SoftMotion-Steuerung verwendet: Jedes CNC-Porgramm wird in ein CNC-Objekt mit gleichem Namen und Implementierungstyp DIN 66025 umgewandelt. Hier wird ...", 
"body" : "Wenn Sie in CODESYS V3 ein CoDeSys V2.3 -Projekt öffnen, steht ein Konverter zur Verfügung, der folgende Funktionen ausführt, vorausgesetzt wird eine SoftMotion-Steuerung verwendet: Jedes CNC-Porgramm wird in ein CNC-Objekt mit gleichem Namen und Implementierungstyp DIN 66025 umgewandelt. Hier wird auch der Übersetzungsmodus, die Queue-Größe und die Startposition des konvertierenden Programms ebenso wie der Status der Satzunterdrückung übernommen. Wenn im CNC-Programm im CoDeSys V2.3 -Projekt die Option Vom Übersetzen ausschließen aktiviert ist, wird diese Option übernommen. Das Objekt CNC-Einstellungen wird automatisch erzeugt. Alle CNC-Objekte werden unterhalb einer SoftMotion-fähigen Applikation eingeordnet. " }, 
{ "title" : "CNC-Programm anlegen ", 
"url" : "_sm_cnc_creating_cnc_program.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC-Programm anlegen ", 
"snippet" : "Selektieren Sie eine Applikation im Gerätebaum. Wählen Sie den Befehl Projekt → Objekt hinzufügen → CNC-Programm . Geben Sie im Dialog CNC-Programm hinzufügen einen Namen ein und wählen Sie in der Auswahlliste die gewünschte Implementierung aus: DIN 66025 , wenn Sie Ihr Programm im Texteditor nach D...", 
"body" : "Selektieren Sie eine Applikation im Gerätebaum. Wählen Sie den Befehl Projekt → Objekt hinzufügen → CNC-Programm . Geben Sie im Dialog CNC-Programm hinzufügen einen Namen ein und wählen Sie in der Auswahlliste die gewünschte Implementierung aus: DIN 66025 , wenn Sie Ihr Programm im Texteditor nach DIN 66025 erstellen möchten Tabelle , wenn Sie Ihr Programm im Tabelleneditor erstellen möchten Wählen Sie den gewünschten Übersetzungsmodus aus, wodurch das Verhalten beim Kompilieren festgelegt wird: SMC_OutQueue : Beim Kompilieren wird eine SMC_OutQueue-Datenstruktur erzeugt. Sie erhalten globalen Zugriff über g_CNCQueueManager (SMC_OutQueue). SMC_CNC_REF : Beim Kompilieren werden Programmvariablen erzeugt. Sie erhalten in einem IEC-Programm globalen Zugriff über g_CNCProgManager (SMC-CNC_REF). FILE : Eine aus dem G-Code generierte Datei wird erzeugt, die bei jedem Einloggen auf die Steuerung geladen und aktualisiert wird. Die SPS kann diese Datei mit Hilfe von Funktionsbausteinen laden. Sie können die Implementierung und den Übersetzungsmodus nachträglich im Dialog Eigenschaften , Registerkarte CNC des CNC-Programms ändern. Klicken Sie auf Hinzufügen . Das CNC-Objekt wird im Gerätebaum hinzugefügt und im Editor geöffnet. " }, 
{ "title" : "Bahn nach DIN 66025 programmieren ", 
"url" : "_sm_cnc_programming_din_66025.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ Bahn nach DIN 66025 programmieren ", 
"snippet" : "SoftMotion unterstützt Teile der CNC-Sprache DIN 66025, die das Programmieren von geometrischen Bahnen im Editor eines CNC-Objekts ermöglicht. Zur Programmierung in der CNC-Sprache DIN 66025 steht Ihnen der Editor für DIN 66025 , auch als CNC-Texteditor bezeichnet, des CNC-Objekts zur Verfügung. Vor...", 
"body" : "SoftMotion unterstützt Teile der CNC-Sprache DIN 66025, die das Programmieren von geometrischen Bahnen im Editor eines CNC-Objekts ermöglicht. Zur Programmierung in der CNC-Sprache DIN 66025 steht Ihnen der Editor für DIN 66025 , auch als CNC-Texteditor bezeichnet, des CNC-Objekts zur Verfügung. Voraussetzung: Ein Objekt CNC-Programm mit Implementierung DIN 66025 ist geöffnet. Platzieren Sie den Cursor in die leere Zeile. Geben nun zeilenweise die Sätze Ihres G-Code-Programms im Editor ein. Wenn Sie einen Satz eingegeben haben, zum Beispiel N10 G01 X100 Y100 E100 F100 E-200 , wird das Bahnelement sofort im grafischen Editor angezeigt. Dort können Sie mit Hilfe des Bedienfelds die Ansicht und die Blickrichtung auf die verschiedenen Achsen ändern. Wenn Sie im grafischen Editor das Bahnelement selektieren, werden dessen Eigenschaften nun in der Ansicht Eigenschaften angezeigt. Für weitere Informationen siehe: DIN 66025 Grundlagen" }, 
{ "title" : "Bahn im Tabelleneditor programmieren ", 
"url" : "_sm_cnc_programming_table_editor.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ Bahn im Tabelleneditor programmieren ", 
"snippet" : "Voraussetzung: Sie haben ein Objekt CNC-Programm mit der Implementierung Tabelle angelegt, das Objekt ist im Tabelleneditor geöffnet....", 
"body" : "Voraussetzung: Sie haben ein Objekt CNC-Programm mit der Implementierung Tabelle angelegt, das Objekt ist im Tabelleneditor geöffnet. " }, 
{ "title" : "Element einfügen ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f56fa52f4ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ Bahn im Tabelleneditor programmieren \/ Element einfügen ", 
"snippet" : "Doppelklicken Sie auf den Eintrag Leer der Spalte Typ , wählen Sie ein Element aus der Auswahlliste aus und drücken Sie die Eingabetaste . Wenn es das erste Element der Tabelle ist, werden die Felder mit den Initialwerten des Elements gefüllt, ansonsten erhält das Element die Werte des Elements der ...", 
"body" : "Doppelklicken Sie auf den Eintrag Leer der Spalte Typ , wählen Sie ein Element aus der Auswahlliste aus und drücken Sie die Eingabetaste . Wenn es das erste Element der Tabelle ist, werden die Felder mit den Initialwerten des Elements gefüllt, ansonsten erhält das Element die Werte des Elements der vorhergehenden Zeile. Alle anderen Felder bleiben grau schraffiert und das Element wird im grafischen Editor angezeigt. Als letzte Zeile der Tabelle wird eine leere Zeile mit dem Typ Leer hinzugefügt. Um ein weiteres Element hinzufügen können Sie auch alternativ im Kontextmenü eines Tabelleneintrags den Befehl Element einfügen auswählen. " }, 
{ "title" : "Tabelleneintrag ändern ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f568c7504ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ Bahn im Tabelleneditor programmieren \/ Tabelleneintrag ändern ", 
"snippet" : "Doppelklicken Sie auf einen Tabelleneintrag eines Elements. Das Feld wird editierbar oder es scheint ein für eine Auswahlliste. Das Element wird im grafischen Editor rot markiert. Ändern Sie den Wert des Tabelleneintrags. Die Änderung wird im grafischen Editor angezeigt. Wenn Sie im Kontextmenü des ...", 
"body" : "Doppelklicken Sie auf einen Tabelleneintrag eines Elements. Das Feld wird editierbar oder es scheint ein für eine Auswahlliste. Das Element wird im grafischen Editor rot markiert. Ändern Sie den Wert des Tabelleneintrags. Die Änderung wird im grafischen Editor angezeigt. Wenn Sie im Kontextmenü des Tabelleneintrags den Befehl Wert auf allen Elementen anwenden auswählen, wird der aktuelle Wert in alle anderen Einträge der selben Spalte übernommen. Voraussetzung ist, dass der Wert für den jeweiligen Elementtyp anwendbar ist. Die Zeilennummer kann nicht editiert werden. " }, 
{ "title" : "Element löschen ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f0684d0502561eafc0a864633d0e8542", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ Bahn im Tabelleneditor programmieren \/ Element löschen ", 
"snippet" : "Selektieren Sie eine Zeile der Tabelle und wählen Sie im Kontextmenü den Befehl Element entfernen . Die letzte Zeile der Tabelle mit dem Typ Leer kann nicht gelöscht werden....", 
"body" : "Selektieren Sie eine Zeile der Tabelle und wählen Sie im Kontextmenü den Befehl Element entfernen . Die letzte Zeile der Tabelle mit dem Typ Leer kann nicht gelöscht werden. " }, 
{ "title" : "CNC-Datenstrukturen und globaler Zugriff ", 
"url" : "_sm_cnc_data_structure_global_access.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC-Datenstrukturen und globaler Zugriff ", 
"snippet" : "Die im Projekt vorhandenen CNC-Objekte werden in Funktionsbausteine vom Typ SMC_OUTQUEUE oder SMC_CNC_REF übersetzt. (Dies geschieht nicht wenn die Übersetzungsmethode FILE verwendet wird.) Im Zuge der Kompilierung des Projekts werden die erstellten CNC-Daten intern in Funktionsbausteinen SMC_CNC_Da...", 
"body" : "Die im Projekt vorhandenen CNC-Objekte werden in Funktionsbausteine vom Typ SMC_OUTQUEUE oder SMC_CNC_REF übersetzt. (Dies geschieht nicht wenn die Übersetzungsmethode FILE verwendet wird.) Im Zuge der Kompilierung des Projekts werden die erstellten CNC-Daten intern in Funktionsbausteinen SMC_CNC_Data verwaltet. Beim Übersetzungsmodus SMC_OutQueue wird jedes CNC-Element durch einen Funktionsbaustein SMC_OUTQUEUE repräsentiert, beim Übersetzungsmodus SMC_CNC_REF wird ein CNC-Element durch SMC_CNC_REF repräsentiert. Die Funktionsbausteine werden während des Ablaufs des IEC-Programms instanziert und mit Werten gefüllt, die dann in IEC-Programmen verarbeitet werden können. All diese Funktionsbausteine sind in SM3_CNC enthalten. " }, 
{ "title" : "Globaler Zugriff auf CNC-Daten ", 
"url" : "_sm_cnc_data_structure_global_access.html#UUID-aaee586d-72f4-405c-8bb5-b4b2cb32f52d_id_cb8536efda52bb5c0a8646375871841_id_4fd460ed02599820c0a864633ab223de", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC-Datenstrukturen und globaler Zugriff \/ Globaler Zugriff auf CNC-Daten ", 
"snippet" : "Während der Initialisierung werden Typ und Anzahl der generierten Objekte aus dem CNC-Programm ermittelt. In einer implizit deklarierten globalen Datenstruktur werden all diese Objekte zusammen aufgelistet. Objekte vom Typ SMC_OUTQUEUE werden in dem globalen Datenobjekt g_CNCQueueManager mit der Eig...", 
"body" : "Während der Initialisierung werden Typ und Anzahl der generierten Objekte aus dem CNC-Programm ermittelt. In einer implizit deklarierten globalen Datenstruktur werden all diese Objekte zusammen aufgelistet. Objekte vom Typ SMC_OUTQUEUE werden in dem globalen Datenobjekt g_CNCQueueManager mit der Eigenschaft Count und der Methode GetOutQueue(int n) aufgelistet. Objekte vom Typ SMC_CNC_REF werden in dem globalen Datenobjekt g_CNCProgManager mit der Eigenschaft Count und der Methode GetProgram(int n) aufgelistet. Der Anwender kann dann in einem IEC-Programm darauf zugreifen. Beispiel Zugriff auf Datenobjekte der Struktur SMC_OUTQUEUE PROGRAM CNCManageQueue\nVAR\n pCNC_OutQueue : POINTER TO SMC_OUTQUEUE;\n n: INT;\n i: INT;\nEND_VAR\n\nn := g_CNCQueueManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_OutQueue := g_CNCQueueManager.GetOutQueue(I);\n (* calculate pCNC_OutQueue *)\nEND_FOR Zugriff auf Datenobjekte der Struktur SMC_CNC_REF PROGRAM CNCManageRef\nVAR\n pCNC_Ref: POINTER TO SMC_CNC_REF;\n n: INT;\nEND_VAR\n\nn := g_CNCProgManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_Ref := g_CNCProgManager.GetProgram(I);\n (* calculate pCNC_Ref *)\nEND_FOR " }, 
{ "title" : "Kinematische Transformationen ", 
"url" : "_sm_f_cnc_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Vorwärts- und Rückwärtstransformation ", 
"url" : "_sm_cnc_forward_backward_transformation.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ Vorwärts- und Rückwärtstransformation ", 
"snippet" : "CODESYS SoftMotion stellt Funktionsbausteine für die mathematische Vorwärts- und Rückwärtstransformation für einige gängige Kinematiken zur Verfügung. Für jede Kinematik sind 2 Funktionsbausteine für die Transformation vorhanden. Der Baustein mit Namen SMC_TRAFO_<Kinematik> berechnet die Achspositio...", 
"body" : "CODESYS SoftMotion stellt Funktionsbausteine für die mathematische Vorwärts- und Rückwärtstransformation für einige gängige Kinematiken zur Verfügung. Für jede Kinematik sind 2 Funktionsbausteine für die Transformation vorhanden. Der Baustein mit Namen SMC_TRAFO_<Kinematik> berechnet die Achspositionen aus der Position im Raum (Rückwärtstransformation). Der Baustein mit Namen SMC_TRAFOF_<Kinematik> berechnet die Position im Raum aus den Achspositionen (Vorwärtstransformation). Sie können die Instanzen der Vorwärtstransformationsbausteine mit Visualisierungstemplates verknüpfen, um die Kinematik schnell und einfach zu visualisieren. SMC_TRAFOV_ Einige der Rückwärtstransformationen verwenden zusätzlich die Bahngeschwindigkeit und Bahnrichtung, um die Achsgeschwindigkeiten zu berechnen. Die Namen dieser Transformationsbausteine beginnen mit   SMC_TRAFOV_ anstelle von SMC_TRAFO_ . Als weitere Eingänge erhalten diese Bausteine vom Interpolator die Bahntangente ( v ) und Bahngeschwindigkeit ( dVel ). Sie geben neben den Sollpositionen auch die Sollgeschwindigkeiten ( dvx\/dvy\/dvz ) zurück. Der Vorteil ist, dass der Schleppfehler im Antrieb durch eine Vorsteuerung der Geschwindigkeit minimiert werden kann, vorausgesetzt der Antrieb unterstützt diese Methode. Um die Sollgeschwindigkeiten an den Antrieb zu übertragen, sollten Sie in diesem Fall SMC_ControlAxisByPosVel statt SMC_ControlAxisByPos verwenden. Für weiere Informationen siehe: SMC_ControlAxisByPos (FB) , SMC_ControlAxisByVel (FB) und SMC_ControlAxisByPosVel (FB) " }, 
{ "title" : "5-Achs-Transformation ", 
"url" : "_sm_trafo_pou_five_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ 5-Achs-Transformation ", 
"snippet" : "Mit der 5-Achs-Transformation können Sie eine Kinematik steuern, die aus 3 linearen Raumachsen (X, Y, Z) und einem Werkzeugkopf besteht. Der Werkzeugkopf besteht aus 2 Achsen, die das Werkzeug tragen. Eine Werkzeugachse dreht um die Z-Achse, die andere kippt das Werkzeug gemäß dem folgendem Schema. ...", 
"body" : "Mit der 5-Achs-Transformation können Sie eine Kinematik steuern, die aus 3 linearen Raumachsen (X, Y, Z) und einem Werkzeugkopf besteht. Der Werkzeugkopf besteht aus 2 Achsen, die das Werkzeug tragen. Eine Werkzeugachse dreht um die Z-Achse, die andere kippt das Werkzeug gemäß dem folgendem Schema. Parameter: Länge des Werkzeugs dTool = Abstand vom Bearbeitungspunkt (Werkzeugspitze = TCP) zur Drehachse Inklination. Steuerung der 5-Achs-Transformation über 5 Positionswerte: X\/Y\/Z-Position des Bearbeitungspunktes (TCP), die in pi.dX, pi.dY, pi.dZ enthalten ist. Einheit: Positionseinheiten der Achsen. Orientierung des Werkzeugs über Kugelkoordinaten (Inklination und Azimut), die in pi.dB und pi.dC enthalten sind. Einheit: Winkelgrad. Nullstellung Der Bearbeitungspunkt (TCP) befindet sich an der Position ( 0\/0\/-dTool ). Das Werkzeug streckt sich in Richtung der negativen Z-Achse aus. Die Drehachse Inklination steht so, dass ein Drehen in positiver Richtung das Werkzeug in Richtung der positiven X-Achse bewegen würde. Beispiel Bei der Fahrt in N30 wird die Inklinationsachse, die zunächst leicht in Richtung X zeigt, gedreht und steht zum Ende der Fahrt ebenso verkippt in negativer X-Richtung. N0 PB360 PC360 (set axis B and C in modulo mode 360)\nN10 F10 FB100 FC100 (velocity in X\/Y\/Z: 10, in B and C 100)\nN20 G0 X0 Y0 Z0 C0 B30 (start position)\nN30 G1 X20 B-30 (target position) Für weitere Informationen siehe: SMC_TRAFO_5Axes (FB) und SMC_TRAFOF_5Axes (FB) " }, 
{ "title" : "Portalsystem ", 
"url" : "_sm_trafo_pou_gantry_system.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ Portalsystem ", 
"snippet" : "Portalsysteme bestehen aus zwei oder drei linearen Achsen, die im rechten Winkel angeordnet sind. Da für Portalsysteme keine Transformationen ausgeführt werden müssen, addieren die zugehörigen Module für Rückwärts- oder Vorwärtstransformation in 2 oder 3 Dimensionen nur einen Offset zur X-, Y- und Z...", 
"body" : "Portalsysteme bestehen aus zwei oder drei linearen Achsen, die im rechten Winkel angeordnet sind. Da für Portalsysteme keine Transformationen ausgeführt werden müssen, addieren die zugehörigen Module für Rückwärts- oder Vorwärtstransformation in 2 oder 3 Dimensionen nur einen Offset zur X-, Y- und Z-Achse. Für weitere Informationen siehe: MC_TRAFO_Gantry2 (FB) SMC_TRAFOF_Gantry2 (FB) SMC_TRAFO_Gantry3 (FB) SMC_TRAFOF_Gantry3 (FB) " }, 
{ "title" : "Portalsystem mit Richtungsachsen ", 
"url" : "_sm_trafo_pou_gantry_cutter.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ Portalsystem mit Richtungsachsen ", 
"snippet" : "Ein „Gantry Cutter“ ist ein Portalsystem mit einer Drehachse, an der ein Schneidewerkzeug angebracht ist. Die Konfiguration eines Portalsystems mit einer Drehachse ist ähnlich wie die eines einfachen Portalsystems. Diese Systeme haben jedoch zusätzlich eine Rotationsachse, auf der die vertikale Schn...", 
"body" : "Ein „Gantry Cutter“ ist ein Portalsystem mit einer Drehachse, an der ein Schneidewerkzeug angebracht ist. Die Konfiguration eines Portalsystems mit einer Drehachse ist ähnlich wie die eines einfachen Portalsystems. Diese Systeme haben jedoch zusätzlich eine Rotationsachse, auf der die vertikale Schneideeinheit geführt wird. Wenn Sie ein Portalsystem mit einer Rotationsachse verwenden, müssen Sie die Bausteine SMC_TRAFO<n>_GantryCutter<n> anstelle von SMC_TRAFO<n>_Gantry<n> verwenden. Dabei wird die Rotationsachse so gesteuert, dass sie entlang der aktuellen Bahntangente ausgerichtet ist. Die Gantry Cutter-Bausteine haben folgende zusätzliche Eingänge: DriveR : Rotationsachse, die als Rotationsachse mit einer Periode von 360° definiert werden muss dOffsetR : Offset der Rotationsachse iDirectionR : Die Drehrichtung Für weitere Informationen siehe: SMC_TRAFO_GantryCutter2 (FB) SMC_TRAFOF_GantryCutter2 (FB) SMC_TRAFO_GantryCutter3 (FB) SMC_TRAFOF_GantryCutter3 (FB) Die Bausteine für Rückwärtstransformation müssen zusätzlich den Vektor der aktuellen Bahntangente (v) erhalten, der ein Ausgang des Interpolators ist. Für weitere Informationen siehe: SMC_TRAFOV_GantryCutter2 (FB) und SMC_TRAFOV_GantryCutter3 (FB) " }, 
{ "title" : "Portalsystem mit Werkzeugversatz ", 
"url" : "_sm_trafo_pou_gantry_system_tool.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ Portalsystem mit Werkzeugversatz ", 
"snippet" : "Wenn die Achse des Werkzeugs nicht mit der Z-Achse des Portalsystems zusammenfällt, sondern um einen Offset verschoben ist, stimmt der Eingriffspunkt des Werkzeugs nicht mit der X-\/Y-\/Z-Position des Portalsystems überein. Wenn die Z-Achse nicht gedreht werden kann, ist der resultierende Offset der X...", 
"body" : "Wenn die Achse des Werkzeugs nicht mit der Z-Achse des Portalsystems zusammenfällt, sondern um einen Offset verschoben ist, stimmt der Eingriffspunkt des Werkzeugs nicht mit der X-\/Y-\/Z-Position des Portalsystems überein. Wenn die Z-Achse nicht gedreht werden kann, ist der resultierende Offset der X- und Y-Koordinaten konstant und kann direkt für die Standard-Portal-Transformation verwendet werden. Wenn das Werkzeug durch die Achse C (um Z) gedreht wird, ist der Offset nicht konstant, sondern hängt von der Position der Achse C ab. In diesem Fall kann zwischen 2 Bausteinen gewählt werden, je nach Form des Werkzeugs: SMC_TRAFO_Gantry2Tool1 und SMC_TRAFOF_Gantry2Tool1 Das Werkzeug zeigt entlang der um dAlpha gedrehten X-Achse und hat die Länge dToolA . SMC_TRAFO_Gantry2Tool2 und SMC_TRAFOF_Gantry2Tool2 Das Werkzeug hat einen Anteil in Richtung der um dAlpha gedrehten X-Achse (Länge dToolA ) und einen Anteil in Richtung der gedrehten Y-Achse (Lange dToolB ). In dem in der folgenden Abbildung gezeigten Beispiel ist der Laser sowohl in X-Richtung als auch in Y-Richtung versetzt angebracht. Statt diese eindimensionale Transformation auszuführen, kann die Bahn auch mit einer Werkzeugverschiebung moduliert werden - das Werkzeug wird dabei als Gerade angenähert. Dazu werden die Funktionbausteine SMC_ToolCorr oder SMC_ToolRadiusCorr verwendet. Der Unterschied zwischen den beiden Methoden liegt in der Geschwindigkeit des Werkzeugpunkts. Wenn die Modulation via SMC_ToolCorr verwendet wird, wird die Geschwindigkeit des Rotationspunktes entsprechend den Voreinstellungen im CNC-Programm  (F, E) kontrolliert. Dabei kann die Geschwindigkeit des Werkzeugpunkts schwanken. Wenn die eindimensionale Transformation verwendet wird, wird die Geschwindigkeit des Werkzeugpunkts durch das CNC-Programm bestimmt. Um die Ausrichtung des Werkzeugs zu berechnen, wird der Baustein SMC_CalcDirectionFromVector verwendet. " }, 
{ "title" : "H-Portalsystem mit stationären Achsen ", 
"url" : "_sm_trafo_pou_h_gantry_stationary_drives.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ H-Portalsystem mit stationären Achsen ", 
"snippet" : "Die kinematische Konfiguration ist ähnlich wie beim Portalsystem, jedoch sind die Achsen (Antriebe) fest montiert. Sie bewegen den Werkzeugträger mit Hilfe eines Riemens. Die Transformation durch die Bausteine SMC_TRAFO_GantryH2 und SMC_TRAFOF_GantryH2 setzt folgende Achskonfigurationen voraus. (And...", 
"body" : "Die kinematische Konfiguration ist ähnlich wie beim Portalsystem, jedoch sind die Achsen (Antriebe) fest montiert. Sie bewegen den Werkzeugträger mit Hilfe eines Riemens. Die Transformation durch die Bausteine SMC_TRAFO_GantryH2 und SMC_TRAFOF_GantryH2 setzt folgende Achskonfigurationen voraus. (Andere Konfigurationen können durch Vertauschen von x und y erreicht werden): Diese Transformation erfordert eine spezielle Referenzfahrt: Beide Achsen müssen mit gleicher Geschwindigkeit bewegt werden. Wenn in X-Richtung gefahren werden soll, müssen die Antriebe A und B bewegt werden, während sie für eine reine X-Bewegung mit entgegengesetzter Geschwindigkeit bewegt werden müssen. Wenn die Referenzposition gefunden wurde, werden die vom Vorwärtstransformationsbaustein berechneten X- und Y-Werte als Offset verwendet ( dOffsetX und dOffsetY ). " }, 
{ "title" : "T-Portalsystem mit stationären Achsen ", 
"url" : "_sm_trafo_pou_t_gantry_statinary_drives.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ T-Portalsystem mit stationären Achsen ", 
"snippet" : "Dieses kinematische System ähnelt den H-Portalsystemen. Auch hier sind die Antriebe stationär angebracht und der Werkzeugträger wird mit Hilfe eines Riemen bewegt. Die Transformation, die von den Modulen SMC_TRAFO_GantryT2 und SMC_TRAFOF_GantryT2 ausgeführt werden, sind für die folgenden Antriebskon...", 
"body" : "Dieses kinematische System ähnelt den H-Portalsystemen. Auch hier sind die Antriebe stationär angebracht und der Werkzeugträger wird mit Hilfe eines Riemen bewegt. Die Transformation, die von den Modulen SMC_TRAFO_GantryT2 und SMC_TRAFOF_GantryT2 ausgeführt werden, sind für die folgenden Antriebskonstellationen ausgelegt: Beachten Sie, dass für diese Transformation eine spezielle Referenzfahrt nötig ist. Wenn Sie eine Bewegung in X-Richtung ausführen, müssen Sie die Antriebe A und B mit gleicher Geschwindigkeit bewegen. Wenn Sie eine reine Y-Bewegung ausführen, müssen Die Antriebe gegenläufig drehen. Hat der Antrieb die Referenzposition gefunden, werden die vom Vorwärtstransformationsfunktionsbaustein errechneten X- und Y-Werte als Offset ( dOffsetX und dOffsetY ) verwendet. Die Funktionsbausteine SMC_TRAFO_GantryT2_O und SMC_TRAFOF_GantryT2_O führen die gleiche Berechnung mit folgender Konstellation aus: " }, 
{ "title" : "Polarsystem ", 
"url" : "_sm_trafo_pou_polar_system.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ Polarsystem ", 
"snippet" : "Polarsysteme bestehen aus einer Drehachse (Richtung) und einer linearen Achse (Abstand). Der Ursprung und die Richtung der Linearachse kann über die Offsets dPhi und dR verändert werden. Für weitere Informationen siehe: SMC_TRAFO_Polar (FB) und SMC_TRAFOF_Polar (FB)...", 
"body" : "Polarsysteme bestehen aus einer Drehachse (Richtung) und einer linearen Achse (Abstand). Der Ursprung und die Richtung der Linearachse kann über die Offsets dPhi und dR verändert werden. Für weitere Informationen siehe: SMC_TRAFO_Polar (FB) und SMC_TRAFOF_Polar (FB) " }, 
{ "title" : "2-gelenkiges SCARA-System ", 
"url" : "_sm_trafo_pou_two_jointed_scara.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ 2-gelenkiges SCARA-System ", 
"snippet" : "Der Selective Compliance Assembly Robot Arm (SCARA) ist ein spezieller Typ von Industrieroboter, der einem menschlichen Arm ähnelt. Ein SCARA-System hat 2 Achsen und zwei Freiheitsgrade. Die Bewegung ist auf die X\/Y-Ebene beschränkt. Für weitere Informationen siehe: SMC_TRAFO_Scara2 (FB) und SMC_TRA...", 
"body" : "Der Selective Compliance Assembly Robot Arm (SCARA) ist ein spezieller Typ von Industrieroboter, der einem menschlichen Arm ähnelt. Ein SCARA-System hat 2 Achsen und zwei Freiheitsgrade. Die Bewegung ist auf die X\/Y-Ebene beschränkt. Für weitere Informationen siehe: SMC_TRAFO_Scara2 (FB) und SMC_TRAFOF_Scara2 (FB) " }, 
{ "title" : "3-gelenkiges SCARA-System ", 
"url" : "_sm_trafo_pou_three_jointed_scara.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ 3-gelenkiges SCARA-System ", 
"snippet" : "Das 3-gelenkige SCARA-System hat eine 3. Achse, die eine Bewegung mit Beibehalten der Richtung erlaubt. Wie für 2-gelenkige Systeme ist die Bewegung auf die X\/Y-Ebene beschränkt. Für weitere Informationen siehe: SMC_TRAFO_Scara3 (FB) und SMC_TRAFOF_Scara3 (FB)...", 
"body" : "Das 3-gelenkige SCARA-System hat eine 3. Achse, die eine Bewegung mit Beibehalten der Richtung erlaubt. Wie für 2-gelenkige Systeme ist die Bewegung auf die X\/Y-Ebene beschränkt. Für weitere Informationen siehe: SMC_TRAFO_Scara3 (FB) und SMC_TRAFOF_Scara3 (FB) " }, 
{ "title" : "Parallele Kinematik ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ Parallele Kinematik ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Tripod mit linearen Achsen ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_b6b32d1fbe665307c0a8640e00033022", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ Parallele Kinematik \/ Tripod mit linearen Achsen ", 
"snippet" : "Bei diesem System handelt es sich um 3 lineare Antriebe, die in einem definierten Winkel zu einander stehen. Die Antriebe bestehen aus 3 Schienen mit Verfahrschlitten. Die Werkzeugplatte ist durch Verbindungsstangen gleicher Länge mit den Verfahrschlitten verbunden. Eine paarweise Ausführung der Ver...", 
"body" : "Bei diesem System handelt es sich um 3 lineare Antriebe, die in einem definierten Winkel zu einander stehen. Die Antriebe bestehen aus 3 Schienen mit Verfahrschlitten. Die Werkzeugplatte ist durch Verbindungsstangen gleicher Länge mit den Verfahrschlitten verbunden. Eine paarweise Ausführung der Verbindungsstangen hält die Werkzeugplatte in der gleichen Orientierung parallel zum Boden. Die Kinematik kann die Werkzeugplatte in 3 Dimensionen bewegen. Die Vorwärts- und Rückwärtstransformation dieser Kinematik wird in den Funktionsbausteinen SMC_Trafo_Tripod_Lin und SMC_TrafoF_Tripod_Lin berechnet. Der Achswinkel des Tripods wird bestimmt durch den Winkel zwischen der Schiene und der vertikalen Achse ( dAxisAngle ). Mechanische Voraussetzungen, Koordinatensystem Die Länge der 3 Achsen sind identisch. Die Längen der Verbindungsstangen sind identisch. Der Abstand des Verbindungsstangen-Paares zueinander ist identisch bei allen Paaren. Der Achswinkel zwischen Antriebsschiene und vertikaler Achse ist identisch bei allen 3 Antrieben. Der Winkel kann zwischen 0° und 90° liegen. Die Bewegung des Punktes zwischen den Verbindungsstangen-Gelenken auf dem Schlitten definiert die Achse. Das XYZ-Koordinatensystem ist rechtshändig. Die Vektoren X und Y liegen horizontal und Z zeigt nach oben. Der Ursprung ist so definiert, dass die Schnittpunkte der 3 Bewegungsachsen mit der XY-Ebene (Grafik unten - Punkte A) auf einem Kreis um die Position [0,0,0] liegen. Parametrierung des Funktionsbausteines SMC_TrafoF_Tripod_Lin Name Beschreibung dInnerRadius Abstand von der Mitte der Werkzeugplatte zu den Angriffspunkten der Verbindungsstangen dOuterRadius A ist der Schnittpunkt der Achse mit der XY-Ebene. dLength Länge der Verbindungsstangen dDistance Abstand der Verbindungsstangen-Paare zueinander dRotationOffset Der Punkt A der ersten Achse definiert standardmäßig die X-Achse. Über den Offset kann die Konstruktion um die Z-Achse gedreht werden. In diesem Fall liegt der Punkt A nicht mehr auf der X-Achse. dOffsetA Mit dem Offset kann der Positionswert der Achse in ihrer Grundstellung auf 0 gesetzt werden. dOffsetB dOffsetC Informationen zu anderen Parametern finden Sie in der Bibliotheksbeschreibung. " }, 
{ "title" : "Tripod mit vertikalen Achsen ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_74ba1833be665308c0a8640e019694c6", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ Parallele Kinematik \/ Tripod mit vertikalen Achsen ", 
"snippet" : "Dieses System ist ein Spezialfall der oben beschriebenen Kinematik mit den gleichen mechanischen Voraussetzungen. Der Winkel dAxisAngle zwischen den Führungsschienen und der vertikalen Achse ist 0 Grad - die Führungsschienen stehen parallel zur vertikalen Achse. Die Vorwärts- und Rückwärtstransforma...", 
"body" : "Dieses System ist ein Spezialfall der oben beschriebenen Kinematik mit den gleichen mechanischen Voraussetzungen. Der Winkel dAxisAngle zwischen den Führungsschienen und der vertikalen Achse ist 0 Grad - die Führungsschienen stehen parallel zur vertikalen Achse. Die Vorwärts- und Rückwärtstransformation dieser Kinematik wird in den Funktionsbausteinen SMC_Trafo_Tripod_Lin und SMC_TrafoF_Tripod_Lin berechnet. Der Achswinkel des Tripods wird bestimmt durch den Winkel zwischen der Schiene und der vertikalen Achse ( dAxisAngle ). Parametrierung des Funktionsbausteines SMC_TrafoF_Tripod_Lin Name Beschreibung dInnerRadius Der Parameter definiert den Radius des Kreises, der durch die 6 Angriffspunkte der Verbindungsstangen an der Werkzeugplatte beschrieben wird. dOuterRadius dLength Länge der Verbindungsstangen dDistance Abstand der Verbindungsstangenpaare zueinander dRotationOffset Der Punkt A der ersten Achse definiert standardmäßig die X-Achse. Über den Offset kann die Konstruktion um die Z-Achse gedreht werden. In diesem Fall liegt der Punkt A nicht mehr auf der X-Achse. dOffsetA Mit dem Offset kann der Positionswert der Achse in ihrer Grundstellung auf 0 gesetzt werden. dOffsetB dOffsetC Informationen zu anderen Parametern finden Sie in der Bibliotheksbeschreibung. " }, 
{ "title" : "Tripod mit rotatorischen Achsen ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_30491f2ca003ef70c0a864631e92f50c", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ Parallele Kinematik \/ Tripod mit rotatorischen Achsen ", 
"snippet" : "Beim einem Tripod ist die Kinematik durch 3 Drehantriebe realisiert, die über Arme und Verbindungsstangen mit der Werkzeugplatte verbunden sind. Der Ursprung des Koordinatensystems ist dort, wo sich der Mittelpunkt der Werkzeugplatte befindet, wenn alle 3 Arme in horizontaler Position sind. Die Vorw...", 
"body" : "Beim einem Tripod ist die Kinematik durch 3 Drehantriebe realisiert, die über Arme und Verbindungsstangen mit der Werkzeugplatte verbunden sind. Der Ursprung des Koordinatensystems ist dort, wo sich der Mittelpunkt der Werkzeugplatte befindet, wenn alle 3 Arme in horizontaler Position sind. Die Vorwärts- und Rückwärtstransformation dieser Kinematik wird in den Funktionsbausteinen SMC_TRAFO_Tripod_Arm und SMC_TRAFOF_Tripod_Arm berechnet. Mechanische Voraussetzungen, Koordinatensystem Die Längen aller 3 Arme sind identisch. Die Längen aller Verbindungsstangen sind identisch. Der Abstand des Verbindungsstangen-Paares zueinander ist identisch bei allen Paaren. Parametrierung des Funktionsbausteines SMC_TrafoF_Tripod_Arm Name Beschreibung dArmLength1 dArmLength2 dArm1Radius Der Parameter beschreibt den Radius des Kreises, der durch die 3 Punkte P der Antriebe beschrieben wird. dStewartRadius Der Parameter beschreibt den Radius des Kreises, der durch die 6 Angriffspunkte der Verbindungsstangen an der Werkzeugplatte beschrieben wird. dDistance Abstand der Verbindungsstangen-Paare zueinander dOffsetA dOffsetB dOffsetC Informationen zu anderen Parametern finden Sie in der Bibliotheksbeschreibung. Das Bild zeigt die Nullposition aller Achsen (die drei oberen Arme sind horizontal). Das MCS wird an der Werkzeugplatte angezeigt. Die Pfeile an den Achsen A0, A1 und A2 zeigen die Drehrichtung der Antriebe gemäß der Rechtshandregel an. Maschinenkoordinatensystem (MCS) Ursprung Definiert im Mittelpunkt der Werkzeugplatte, wenn alle 3 oberen Arme (diejenigen, die direkt mit A0, A1 oder A2 verbunden sind) in horizontaler Position sind X Zeigt, vom Ursprung aus gesehen, weg vom ersten Motor (A0), parallel zum oberen Armteil des ersten Arms Y Wird durch X und Z bestimmt, so dass das MCS rechtshändig wird Z Senkrecht zur Werkzeugplatte Zeigt von der Werkzeugplatte in Richtung der Motoren Die zugehörigen Transformationen werden durch folgende Bausteine SMC_TRAFO_Tripod_Arm und S MC_TRAFOF_Tripod_Arm ausgeführt: Beispiel 3S Tripod Transformationseinstellungen tta:\nSMC_TRAFO_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41,dMaxAngleBallJoint:=60);\nttaf:\nSMC_TRAFOF_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41); " }, 
{ "title" : "4-Achs-Palletierer-Kinematik ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ 4-Achs-Palletierer-Kinematik ", 
"snippet" : "Die 4-Achs-Palletierer-Kinematik ist ein allgemeiner Robotertyp, der oftmals für Palletieraufgaben verwendet wird. Die Kinematik verfügt über 4 gesteuerte Rotationsachsen (in rot eingezeichnet) und über eine 5. mechanische Rotationsachse (in grau eingezeichnet). Die Bausteine SMC_Trafo_4AxisPalletiz...", 
"body" : "Die 4-Achs-Palletierer-Kinematik ist ein allgemeiner Robotertyp, der oftmals für Palletieraufgaben verwendet wird. Die Kinematik verfügt über 4 gesteuerte Rotationsachsen (in rot eingezeichnet) und über eine 5. mechanische Rotationsachse (in grau eingezeichnet). Die Bausteine SMC_Trafo_4AxisPalletizer und SMC_TrafoF_4AxisPalletizer implementieren dessen Rückwärts- und Vorwärtstransformation. Das unter der Basis des Palletierers gezeichnete Koordinatensystem ist das Weltkoordinatensystem. Die z-Achse geht senkrecht nach unten, die x-Achse nach „vorne“, das heißt in die Richtung, in die der Arm in der Nullstellung der Achsen zeigt. Der Ursprung des Weltkoordinatensystems ist der Schnittpunkt zwischen der Gelenkachse 1 und der Unterseite des Roboters. Objekte Die Datenstruktur SMC_TrafoConfig_4AxisPalletizer und die Funktionsbausteine SMC_Trafo_4AxisPalletizer und SMC_TrafoF_4AxisPalletizer werden mit der Bibliothek SM3_Transformation eingebunden. Eine Beschreibung der Parameter erhalten Sie, wenn Sie im Bibliotheksverwalter nach diesen Objekten suchen. " }, 
{ "title" : "Definition der Achsen ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_945c0811df409256c0a8657d0066458b", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ 4-Achs-Palletierer-Kinematik \/ Definition der Achsen ", 
"snippet" : "Die folgende Abbildung zeigt die Drehrichtung der 4 Achsen. Die schwarzen Pfeile laufen entlang der Gelenkachse. Die Drehrichtung ist gemäß der Rechten-Hand-Regel festgelegt: Zeigt der Daumen der rechten Hand entlang dem Pfeil, dann ist die positive Drehrichtung in Richtung der leicht gekrümmten Fin...", 
"body" : "Die folgende Abbildung zeigt die Drehrichtung der 4 Achsen. Die schwarzen Pfeile laufen entlang der Gelenkachse. Die Drehrichtung ist gemäß der Rechten-Hand-Regel festgelegt: Zeigt der Daumen der rechten Hand entlang dem Pfeil, dann ist die positive Drehrichtung in Richtung der leicht gekrümmten Finger der Hand. Zum Beispiel ist von oben gesehen die positive Drehrichtung der Achse 0 im Uhrzeigersinn, Achse 1 und 2 kippen bei positiver Drehung „nach vorne“. Die Kinematik verfügt über 4 gesteuerte Rotationsachsen (siehe rot eingefärbte Achsen a0, a1, a2, a3) und über eine 5. mechanische Rotationsachse (siehe grau eingefärbte Achse M). Wertebereiche der Achsen: Achse 0: ]-180°, 180°[ Achse 1: [-90°, 90°] Achse 2: [-180°, 90[ Achse M: Mechanische Rotationsachse. Keine Beschränkung Achse 3: nicht beschränkt, Bereich kann auch größer 360° sein " }, 
{ "title" : "Nullstellung und Maße ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ 4-Achs-Palletierer-Kinematik \/ Nullstellung und Maße ", 
"snippet" : "Die Abbildung zeigt die Kinematik in der Nullstellung aller Achsen. In der Nullstellung verlaufen die Achsen des Werkzeugkoordinatensystems parallel zu denen des Maschinenkoordinatensystems. Tragen Sie die eingezeichneten Maße in der Konfigurationsstruktur SMC_TrafoConfig_4AxisPalletizer ein. Tragen...", 
"body" : "Die Abbildung zeigt die Kinematik in der Nullstellung aller Achsen. In der Nullstellung verlaufen die Achsen des Werkzeugkoordinatensystems parallel zu denen des Maschinenkoordinatensystems. Tragen Sie die eingezeichneten Maße in der Konfigurationsstruktur SMC_TrafoConfig_4AxisPalletizer ein. Tragen Sie dabei alle a_i mit positivem und alle d_i mit negativem Vorzeichen ein. Die Namen der Parameter entsprechen der Denavit-Hartenberg-Konvention. Denavit-Hartenberg-Transformation der Gelenke Gelenkoffset (sigma_i) Gelenkabstand (d_i) Armelementlänge (a_i) Verwindung (alpha_i) 1 0° d_1 a_1 90° 2 -90° 0 a_2 0° 3 90° 0 a_3 0° 4 0° 0 a_4 90° 5 0° d_5 0 180° " }, 
{ "title" : "Programmierung im G-Code ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_67269b93df408f35c0a8657d0178e964", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ 4-Achs-Palletierer-Kinematik \/ Programmierung im G-Code ", 
"snippet" : "Die Position des Greifers wird über X, Y und Z gesteuert. Die Drehung des Greifers um die Vertikale wird über die Zusatzachse C gesteuert. Die Winkel sind in Grad anzugeben....", 
"body" : "Die Position des Greifers wird über X, Y und Z gesteuert. Die Drehung des Greifers um die Vertikale wird über die Zusatzachse C gesteuert. Die Winkel sind in Grad anzugeben. " }, 
{ "title" : "6-Achs-Knickarmroboter ", 
"url" : "_sm_trafo_pou_six_dof_robot.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ 6-Achs-Knickarmroboter ", 
"snippet" : "Transformation eines Knickarmroboters mit 6 Drehachsen und 6 Freiheitsgraden (DoF). Die 3 Orientierungsachsen des Roboterarms schneiden sich in einem einzigen Punkt, dem Handgelenksmittelpunkt. Die Funktionsbausteine SMC_Trafo_ArticulatedRobot_6DOF und SMC_TrafoF_ArticulatedRobot_6DOF implementieren...", 
"body" : "Transformation eines Knickarmroboters mit 6 Drehachsen und 6 Freiheitsgraden (DoF). Die 3 Orientierungsachsen des Roboterarms schneiden sich in einem einzigen Punkt, dem Handgelenksmittelpunkt. Die Funktionsbausteine SMC_Trafo_ArticulatedRobot_6DOF und SMC_TrafoF_ArticulatedRobot_6DOF implementieren Vorwärts- und Rückwärtstransformationen eines Knickarmroboters mit sechs drehenden Achsen. In der Abbildung ist das Weltkoordinatensystem unten an der Achse 0 eingezeichnet. Die z-Achse zeigt nach unten, die x-Achse zeigt nach vorne auf in Richtung des Werkzeugmittelpunkts (TCP). Der Ursprung des Weltkoordinatensystems ist der Schnittpunkt von Achse 0 und dem Boden des Roboters. Transformationsobjekte Die Datenstruktur SMC_TrafoConfig_ArticulatedRobot_6DOF und die Funktionsbausteine SMC_Trafo_ArticulatedRobot_6DOF und SMC_TrafoF_ArticulatedRobot_6DOF werden mit SM3_CNC eingebunden. " }, 
{ "title" : "Definition der Achsen ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_7e060a95379b6b55c0a8640e01f01d63", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ 6-Achs-Knickarmroboter \/ Definition der Achsen ", 
"snippet" : "Die Drehachsen sind durch schwarze Pfeile gekennzeichnet. Die positive Drehrichtung ergibt sich aus der Rechte-Hand-Regel. Wenn Achse 0 sich zum Beispiel in positiver Richtung dreht, dann rotiert der Roboter von oben betrachtet im Uhrzeigersinn. Die Achsen sind auf die folgenden Bereiche beschränkt:...", 
"body" : "Die Drehachsen sind durch schwarze Pfeile gekennzeichnet. Die positive Drehrichtung ergibt sich aus der Rechte-Hand-Regel. Wenn Achse 0 sich zum Beispiel in positiver Richtung dreht, dann rotiert der Roboter von oben betrachtet im Uhrzeigersinn. Die Achsen sind auf die folgenden Bereiche beschränkt: Achse 0, 1, 3, and 4: ]-180°, 180°[ Achse 2: [-90°, 180°] Achse 5: nicht beschränkt, der Bereich darf größer als 360° sein. " }, 
{ "title" : "Referenzposition und Maße ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ 6-Achs-Knickarmroboter \/ Referenzposition und Maße ", 
"snippet" : "Die linke Abbildung zeigt die Referenzposition der Kinematik, also die Position, in der alle Achsen in ihrer Nullposition sind. Tragen Sie die hier gezeigten Maße in die Konfigurationsstruktur SMC_TrafoConfig_ArticulatedRobot_6DOF ein. Name und Vorzeichen der Parameter sind gemäß der Denavit-Hartenb...", 
"body" : "Die linke Abbildung zeigt die Referenzposition der Kinematik, also die Position, in der alle Achsen in ihrer Nullposition sind. Tragen Sie die hier gezeigten Maße in die Konfigurationsstruktur SMC_TrafoConfig_ArticulatedRobot_6DOF ein. Name und Vorzeichen der Parameter sind gemäß der Denavit-Hartenberg Konvention. Die rechte Abbildung zeigt den zusätzlichen Denavit-Hartenberg-Parameter d3 . Bitte beachten Sie: a1, a3, d4, d6 muss >= 0 sein a2 muss > 0 sein (> g_fSMC_CNC_EPS ) d1 muss <= 0 sein Denavit–Hartenberg-Transformation der Gelenke Gelenk-Offset (sigma_i) Hebelverschiebung (d_i) Hebellänge (a_i) Hebeldrehung (alpha_i) 1 0° d1 a_1 -90° 2 90° 0 a_2 0° 3 0° d3 a_3 90° 4 0° d4 0 90° 5 0° 0 0 -90° 6 0° d6 0 0° " }, 
{ "title" : "Programmierung ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_9cf41a3c6a5fb376c0a8640e005461c1", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ 6-Achs-Knickarmroboter \/ Programmierung ", 
"snippet" : "Die Position der Werkzeugmittelpunkts wird mit X, Y, und Z gesteuert. Die Einheiten von X, Y, und Z sind die gleichen Einheiten, wie die bei den Parametern a_i und d_i verwendeten (zum Beispiel mm). Die Orientierung wird in Grad mit A (Gier), B (Nick), und C (Roll) gesteuert....", 
"body" : "Die Position der Werkzeugmittelpunkts wird mit X, Y, und Z gesteuert. Die Einheiten von X, Y, und Z sind die gleichen Einheiten, wie die bei den Parametern a_i und d_i verwendeten (zum Beispiel mm). Die Orientierung wird in Grad mit A (Gier), B (Nick), und C (Roll) gesteuert. " }, 
{ "title" : "Wrapper für kinematische Transformationsfunktionsbausteine aus der Bibliothek SM3_Transformation ", 
"url" : "_sm_wrapper_kinematic_fbs.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Kinematische Transformationen \/ Wrapper für kinematische Transformationsfunktionsbausteine aus der Bibliothek SM3_Transformation ", 
"snippet" : "Mit den Funktionsbausteinen SMC_Trafo_Wrapper und SMC_TrafoF_Wrapper können Sie die Kinematiken der Bibliothek SM3_Transformation für CNC-Anwendungen nutzen. Für weitere Informationen zu den Kinematiken der Bibliothek SM3_Transformation siehe: KinematikenEs ist möglich, jede beliebige Transformation...", 
"body" : "Mit den Funktionsbausteinen SMC_Trafo_Wrapper und SMC_TrafoF_Wrapper können Sie die Kinematiken der Bibliothek SM3_Transformation für CNC-Anwendungen nutzen. Für weitere Informationen zu den Kinematiken der Bibliothek SM3_Transformation siehe: KinematikenEs ist möglich, jede beliebige Transformation, die die Schnittstelle MC_KIN_REF_SM3 implementiert, zu verwenden. Außerdem sind Kombinationen von so genannten Positions- und Orientierungskinematiken möglich. Für weitere Informationen siehe: Kombination von Positionier- und Orientierungskinematiken" }, 
{ "title" : "CNC-Sprache DIN 66025 ", 
"url" : "_sm_struct_reference_programming_din66025.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "DIN 66025 Grundlagen ", 
"url" : "_sm_cnc_din66025_basics.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ DIN 66025 Grundlagen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Struktur eines DIN 66025-Programms ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_c348b29fedfe7b9ec0a86463427bc61d", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ DIN 66025 Grundlagen \/ Struktur eines DIN 66025-Programms ", 
"snippet" : "Das Programm nach DIN 66025 besteht aus einzelnen Sätzen. Am Anfang jedes Satzes steht die Satznummer. ['%' <Programmname>] <Satz>{<Satz>} Die Sätze können folgendermaßen aufgebaut sein: N<Satznummer> G<Ausdruck> <G-Code-Wörter> N<Satznummer> <G-Code-Wörter> (es gilt die G<Ausdruck> des vorherigen S...", 
"body" : "Das Programm nach DIN 66025 besteht aus einzelnen Sätzen. Am Anfang jedes Satzes steht die Satznummer. ['%' <Programmname>]\n<Satz>{<Satz>} Die Sätze können folgendermaßen aufgebaut sein: N<Satznummer> G<Ausdruck> <G-Code-Wörter> N<Satznummer> <G-Code-Wörter> (es gilt die G<Ausdruck> des vorherigen Satzes) N<Satznummer> M<Ausdruck> <G-Code-Wörter> N<Satznummer> <Unterprogrammname> ( <ActualParamList> ) Zusätzliche Satzaufbauten bei Unterprogrammen: SUBPROGRAM <Name> {<FormalParamList>} <RESTORE_OPT> N<Satznummer> RETURN END_SUBPROGRAM Beispiel Bahn aus zwei Geraden und einem Kreisbogen, gefolgt von einem Unterprogrammaufruf % MyProgram\nN10 G01 X100 Y100 E100 F100 E-200\nN20 G01 Z40 F20\nN30 G03 X-100 R200 F100\nN40 SubPrg{5} " }, 
{ "title" : "Syntax ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_section-idm4580346248046432600861986014", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ DIN 66025 Grundlagen \/ Syntax ", 
"snippet" : "['%' <Programmname>] Kopfzeile optional Beginnt mit %, gefolgt vom Programmnamen, der durch ein Leerzeichen oder Tab getrennt wird <Satz> Der Satz wird wortweise von rechts nach links abgearbeitet. \/ Satzunterdrückung Wenn ein Satz mit \/ beginnt und der Befehl CNC ➔ Satzunterdrückung ausgewählt wurd...", 
"body" : "['%' <Programmname>] Kopfzeile optional Beginnt mit %, gefolgt vom Programmnamen, der durch ein Leerzeichen oder Tab getrennt wird <Satz> Der Satz wird wortweise von rechts nach links abgearbeitet. \/ Satzunterdrückung Wenn ein Satz mit \/ beginnt und der Befehl CNC ➔ Satzunterdrückung ausgewählt wurde, wird der Satz nicht ausgeführt. N<Satznummer> Die Satznummer wird als Markierung und für die Festlegung von Sprungzielen verwendet. Beispiel: N01 G<Ausdruck> Fahrbefehl Wenn in einem Satz kein Fahrbefehl eingetragen ist, wird automatisch der Fahrbefehl, der im vorherigen Satz verwendet wurde, ergänzt. Groß- und Kleinschreibung wird ignoriert. Führende Nullen werden ignoriert. Es gilt: G01 = g1 Entspricht einem Bahnelement oder Wegobjekt Beispiel: G1 (Gerade), G2 (Kreisbogen) Die Geschwindigkeit, mit der die Bahnobjekte interpoliert werden, entspricht grundsätzlich der eingestellten Bahngeschwindigkeit und Bahnbeschleunigung\/-verzögerung. Der Interpolator stellt sicher, dass diese Grenzwerte nicht überschritten werden. <G-Code-Wort> Groß- und Kleinschreibung wird ignoriert. G-Code-Wort Besteht aus einer Adresse (beispielsweise E ) und einem Ausdruck (beispielsweise 100 , zusammen also E100 ) Groß- und Kleinschreibung wird ignoriert. Führende Nullen werden ignoriert. Bewirkt, dass die Zahl des Worts in eine Variable geschrieben wird Der Buchstabe des Worts ist der Variablenname. Darauf greift der Fahrbefehl zu. Alle Zahlen können Fließkommawerte sein. Das gilt nicht bei Fahrbefehl G<Ausdruck> , M-Funktion M<Ausdruck> und Schaltpunkt H<Ausdruck> . Die Worte eines Satzes werden durch Leerzeichen oder Tab getrennt. <Ausdruck> Siehe: Ausdrücke() Kommentar Die Zeichen innerhalb der runden Klammern werden als Kommentar interpretiert. Hinweis: Über den Eingang bParenthesesAsComments ( FB SMC_ReadNCFile2 ) können Kommentare umdefiniert werden. Interpolation zwischen zwei aufeinander folgenden Sätzen Die Geschwindigkeit beim Übergang zweier benachbarter Objekte wird nach folgenden Regeln bestimmt: Wenn eines der beiden Objekte eine Positionierung G0 ist, gilt: Übergangsgeschwindigkeit = 0. Wenn der Winkel zwischen den Tangenten der beiden Bahnelementen am Übergang größer als die Winkeltoleranz ist, gilt: Übergangsgeschwindigkeit = 0. Ansonsten gilt: Die Übergangsgeschwindigkeit ist die kleinere Sollgeschwindigkeit der beiden Bahnelemente. Grundsätzlich bewirkt ein Fahrbefehl, dass eine Interpolation von der Zielposition des letzten Fahrbefehls zur Zielposition, die vom aktuellen Fahrbefehl spezifiziert wurde, durchgeführt wird. Der erste Fahrbefehl startet bei der Position, die im Decoder oder CNC-Editor festgelegt wurde. Wenn diese Position nicht definiert ist, wird an der Position X=0, Y=0, Z=0 gestartet. " }, 
{ "title" : "Fahrbefehle und die entsprechenden Bahnelemente ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_48e0dea1edfe7b9ec0a8646321fb969d", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ DIN 66025 Grundlagen \/ Fahrbefehle und die entsprechenden Bahnelemente ", 
"snippet" : "Fahrbefehl Beschreibung Bahnelement G0 Direkte Bewegung ohne Werkzeugeingriff, Linearbewegung PositionierungG1 Lineare, gerade Bewegung mit Werkzeugeingriff Lineare BewegungG2 Kreissegment oder Kreis im Uhrzeigersinn KreisbogenG3 Kreissegment oder Kreis gegen den Uhrzeigersinn KreisbogenG4 Verweilze...", 
"body" : "Fahrbefehl Beschreibung Bahnelement G0 Direkte Bewegung ohne Werkzeugeingriff, Linearbewegung PositionierungG1 Lineare, gerade Bewegung mit Werkzeugeingriff Lineare BewegungG2 Kreissegment oder Kreis im Uhrzeigersinn KreisbogenG3 Kreissegment oder Kreis gegen den Uhrzeigersinn KreisbogenG4 Verweilzeit VerweilzeitG5 Punkt eines 2D-Kardinalsplines SplineG6 Parabel ParabelG8 Ellipsensegment oder Ellipse im Uhrzeigersinn EllipseG9 Ellipsensegment oder Ellipse gegen den Uhrzeigersinn EllipseG10 Punkt eines 3D-Kardinalsplines SplineG15 Wechsel zu 2D 3D-ModusG16 Wechsel zu 3D durch Aktivierung des 3D-Modus mit Normalenvektor I\/J\/K zur Ebene 3D-ModusG17 Wechsel zu 3D durch Aktivierung des 3D-Modus in X\/Y-Ebene 3D-ModusG18 Wechsel zu 3D durch Aktivierung des 3D-Modus in Z\/X-Ebene 3D-ModusG19 Wechsel zu 3D durch Aktivierung des 3D-Modus in Y\/Z-Ebene 3D-ModusG20 Bedingter Sprung nach L wenn K <> 0 SprungG31 Restweg Löschen mit Dekodierstopp Restweg LöschenG36 Wert D auf Variable O schreiben Ändern von VariablenwertenG37 Variable O um Wert D inkrementieren Ändern von VariablenwertenG38 Aktivieren der erweiterten Vorverarbeitungsfunktion Aktivierung der erweiterten VorverarbeitungsfunktionG39 Deaktivieren der erweiterten Vorverarbeitungsfunktion Aktivierung der erweiterten VorverarbeitungsfunktionG40 Ende der Werkzeugradiuskorrektur VorverarbeitungG41 Beginn der Werkzeugradiuskorrektur links der Fahrrichtung VorverarbeitungG42 Beginn der Werkzeugradiuskorrektur rechts der Fahrrichtung VorverarbeitungG43 Startet die Werkzeuglängenkurrektur VorverarbeitungG50 Ende der Eckverrundung\/-verschleifung VorverarbeitungG51 Beginn der Eckverschleifung VorverarbeitungG52 Beginn der Eckverrundung VorverarbeitungG53 Beendet die Koordinatentransformation und setzt das Dekoderkoordinatensystem in die Ursprungslage ( = Maschinenkoordinatensystem) zurück Koordinatensystem schieben, drehen und skalierenG54 Transformiert die Koordinaten absolut Koordinatensystem schieben, drehen und skalierenG55 Transformiert die Koordinaten relativ Koordinatensystem schieben, drehen und skalierenG56 Setzt die aktuelle Orientierung, Position und Skalierung des DCS als Referenzpunkt Koordinatensystem schieben, drehen und skalierenG60 Ende der Schleifenvermeidung VorverarbeitungG61 Beginn der Schleifenvermeidung VorverarbeitungG70 Beendet die Glättung von Zusatzachsen Siehe: SMC_SmoothAddAxes VorverarbeitungG71 Startet die Glättung von Zusatzachsen Siehe: SMC_SmoothAddAxes VorverarbeitungG75 Zeitsynchronisation mit dem Interpolator Zeitsynchronisation mit InterpolatorG90 Die Koordinaten ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) werden als absolute Werte interpretiert. (Dies ist die Standardeinstellung.) ModiG91 Die Koordinaten ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) werden als Werte relativ zur aktuellen Position interpretiert. ModiG92 Positionierung durch Sprung PositionierungG98 Die Achsmittelpunkte ( I \/ J \/ K ) werden als absolute Werte interpretiert. ModiG99 Die Achsmittelpunkte ( I \/ J \/ K ) werden als Werte relativ zur Startposition interpretiert. (Dies ist die Standardeinstellung.) Modi" }, 
{ "title" : "G-Code-Worterkennung ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_591ac87c61b577fcc0a8640e0070747c", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ DIN 66025 Grundlagen \/ G-Code-Worterkennung ", 
"snippet" : "A Zielposition der zusätzlichen Splineachse Bei einer Koordinatentransformation im Decoderkoordinatensystem enthält das Wort einen Winkel. B C D Werkzeugradius für Korrektur G40 - G42 Werkzeugabstand für Eckverrundung G50 - G51 Variablenwert G36 \/ G37 E Max. Bahnbeschleunigung\/-verzögerung in [u\/sec...", 
"body" : "A Zielposition der zusätzlichen Splineachse Bei einer Koordinatentransformation im Decoderkoordinatensystem enthält das Wort einen Winkel. B C D Werkzeugradius für Korrektur G40 - G42 Werkzeugabstand für Eckverrundung G50 - G51 Variablenwert G36 \/ G37 E Max. Bahnbeschleunigung\/-verzögerung in [u\/sec 2 ]. Wert > 0: Beschleunigung, Wert < 0: Verzögerung EF Bahnbeschleunigung\/-verzögerung für G0 -Bewegungen E<axis> Individuelle Beschleunigung\/Verzögerung (>0\/<0) der angegebenen Zusatzachse <axis> Zusatzachsen sind A , B , C , P , Q , U , V , W und im 2D-Modus zusätzlich Z . Wenn dieser G-Code verwendet wird, muss der Bahnverarbeitungsbaustein SMC_ExtendedVelocityChecks zur Begrenzung der Geschwindigkeit verwendet werden. F Geschwindigkeit in [u\/sec]: „Feed“ FF Geschwindigkeit für G0 -Bewegungen F<axis> Individuelle Geschwindigkeit der angegebenen Zusatzachse <axis> Zusatzachsen sind A , B , C , P , Q , U , V , W und im 2D-Modus zusätzlich Z . Wenn dieser G-Code verwendet wird, muss der Bahnverarbeitungsbaustein SMC_ExtendedVelocityChecks zur Begrenzung der Geschwindigkeit verwendet werden. G Wegbedingung H Schaltpunkt (H-Funktion) Positiv: Einschalten Negativ: Ausschalten I X-Koordinate des Kreis-\/Ellipsenmittelpunkts für G02 \/ G03 \/ G08 \/ G09 X-Koordinate des Scheitelpunkts der Parabel für G06 Normalenvektor (X) für die 3D-Ebenenfunktion Parameter für die Aktivierung erweiterter Vorverarbeitungsfunktionen für G38 \/ G39 Skalierung in X-Richtung bei G54 \/ G55 \/ G56 Werkzeugversatz in X-Richtung bei G43 J Y-Koordinate des Kreis-\/Ellipsenmittelpunkts für G02 \/ G03 \/ G08 \/ G09 Y-Koordinate des Scheitelpunkts der Parabel für G06 Normalenvektor (Y) für die 3D-Ebenenfunktion Parameter für die Aktivierung erweiterter Vorverarbeitungsfunktionen für G38 \/ G39 Skalierung in Y-Richtung bei G54 \/ G55 \/ G56 Werkzeugversatz in Y-Richtung bei G43 K Richtung der Ellipsen-Hauptachse im mathematischen Sinn: 0° = O, 90° = N usw. Sprungbedingung bei G20 dT1-Parameterwert bei M-Funktion Z-Koordinate des Kreismittelpunkts bei G02 \/ G03 im 3D-Modus Normalenvektor (Z) für die 3D-Ebenenfunktion Parameter für die Aktivierung erweiterter Vorverarbeitungsfunktionen für G38 \/ G39 Skalierung in Z-Richtung bei G54 \/ G55 \/ G56 Werkzeugversatz in Z-Richtung bei G43 L Absolute Schaltpunktposition bei H-Funktion gemessen vom Bahnelementanfang, falls Position > 0, oder gemessen vom Bahnelementende, falls Position < 0. Sprungziel bei G20 dT2-Parameterwert bei M-Funktion Nummer der Zusatzachse bei G70 und G71 M Zusatzoption für Maschinen, auch M-Funktion O Relative Schaltpunktposition mit Wertebereich [0..1] bei H-Funktion Variablenwert G36 \/ G37 . Datenstruktur der Parameter bei einer M-Funktion P Zielposition der zusätzlichen linearen Achse P P<Achse><Periode> Konfiguration der Moduloachsen Wenn Periode=0 gilt, zum Beispiel PA0 , wird das Verhalten der Achse linear. PROBE Aktiviert die Funktion \"Restweg Löschen\" für die Bewegung Q Zielposition der zusätzlichen linearen Achse Q R Kreisradius alternativ zu I, J mit G02 \/ G03 Längenverhältnis der elliptischen Nebenachse\/Hauptachse im Wertebereich von [0..1] mit G08 \/ G09 S S-Profil für lineare Achsen Positiv: einschalten Negativ: ausschalten Achse 3 : Z, wenn Z im 2D-Modus ist 7 : P 8 : Q 9 : U 10 : V 11 : W T Kommandospezifischer Parameter U Zielposition der zusätzlichen linearen Achse U V Zielposition der zusätzlichen linearen Achse V W Zielposition der zusätzlichen linearen Achse W X X-Koordinate der Zielposition Y Y-Koordinate der Zielposition Z Z-Koordinate der Zielposition " }, 
{ "title" : "3D-Modus ", 
"url" : "_sm_cnc_din66025_3dmode.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ 3D-Modus ", 
"snippet" : "G-Code : G15 , G16 , G17 , G18 , G19 G-Code Beschreibung G15 Wechselt in den 2D-Modus. Gültig für alle weiteren Elemente G16 Aktiviert die 3D-Ebenenfunktion in der Normalebene mit Normalvektor I\/J\/K und wechselt in den 3D-Modus Gültig für alle weiteren Elemente G17 Aktiviert die 3D-Ebenenfunktion in...", 
"body" : "G-Code : G15 , G16 , G17 , G18 , G19 G-Code Beschreibung G15 Wechselt in den 2D-Modus. Gültig für alle weiteren Elemente G16 Aktiviert die 3D-Ebenenfunktion in der Normalebene mit Normalvektor I\/J\/K und wechselt in den 3D-Modus Gültig für alle weiteren Elemente G17 Aktiviert die 3D-Ebenenfunktion in der X\/Y-Ebene und wechselt in den 3D-Modus Gültig für alle weiteren Elemente G18 Aktiviert die 3D-Ebenenfunktion in der Z\/X-Ebene. Wechselt in den 3D-Modus Gültig für alle weiteren Elemente G19 Aktiviert die 3D-Ebenenfunktion in der Y\/Z-Ebene. Wechselt in den 3D-Modus Gültig für alle weiteren Elemente Im 3D-Modus werden dreidimensionale Bahnelemente verwendet. Im 3D-Raum können Sie Punkte setzen und mit 3D-Splines verbinden, oder Sie können Kreisbögen in einer beliebigen Raumebene einfügen. Im Unterschied zu 2,5D-Bahnelementen, die nur X\/Y-Koordinaten verwenden, bezieht sich die Bahngeschwindigkeit und Beschleunigung auf die Bewegung in den Koordinaten X\/Y\/Z. Die Z-Achse wird gleich behandelt wie die X- und Y-Achse. So kann jede Bewegung in Z-Richtung implementiert werden. 3D-Modus Der Modus unterstützt keine Ellipsen, Parabeln und 2D-Splines Eine Fehlermeldung wird generiert. SMC_CheckVelocities überprüft die Z-Komponente SMC_ToolCorr und SMC_AvoidLoop generieren Fehler Hauptunterschiede zwischen 2,5D und 3D Hauptunterschiede zwischen 2,5D und 3D Geschwindigkeit und Beschleunigung (F\/E): In 3D: definiert die Geschwindigkeit\/Beschleunigung der Bahn. In 2,5D: definiert die Geschwindigkeit\/Beschleunigung der Projektion der Bahn auf die X\/Y-Ebene. Splines In 3D: mit einer ruckfrei geglätteten Z-Komponente (G10) In 2,5D: in Z-Richtung nicht geglättet (G5) Kreisbogen In 3D: kann in jeder möglichen Ebene im Raum definiert werden (G2\/G3 mit G16\/G17\/G18\/G19) In 2,5D: begrenzt auf die X\/Y-Ebene (G2\/G3) Beispiel Geschwindigkeitsvergleich 3D und 2,5D N0 G1 X1 Z100 F1 In 3D benötigt die Bewegung ungefähr 100 Sekunden, da die Länge des Objekts die Z-Komponente enthält. Länge = (1 2 + 100 2 ) 1\/2 Bei einer Geschwindigkeit von 1 werden ungefähr 100 Sekunden benötigt. Hier ist die Geschwindigkeit der Z-Komponente ungefähr 1. In 2,5D benötigt diese Bewegung ungefähr 1 Sekunde für die Kalkulation der Länge = 1. Hier ist die Geschwindigkeit in Z-Richtung ungefähr 100. " }, 
{ "title" : "Aktivierung der erweiterten Vorverarbeitungsfunktion ", 
"url" : "_sm_cnc_din66025_activating_extended_preprocessor_functions.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Aktivierung der erweiterten Vorverarbeitungsfunktion ", 
"snippet" : "G-Code : G38 , G39 Funktion : Die Befehle aktivieren und deaktivieren die erweiterte Vorverarbeitungsfunktion. Syntax G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> G39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> G-Code Wort Beschreibung <Bit> Wert zwischen 0 und 31. Die Zuordnung d...", 
"body" : "G-Code : G38 , G39 Funktion : Die Befehle aktivieren und deaktivieren die erweiterte Vorverarbeitungsfunktion. Syntax G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value>\nG39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> G-Code Wort Beschreibung <Bit> Wert zwischen 0 und 31. Die Zuordnung der Bits zu den Funktionen bleibt dem Programmierer überlassen. Einige Funktionsbausteine wie SMC_SmoothMerge oder SMC_SmoothBSpline haben einen Eingang wFeatureBit (Initialwert 0), der festlegt, welches Bit verwendet wird. Das Bit wird in der Variable SMC_GeoInfo.dwFeatureFlags gespeichert. <Param1Value> Beliebiger Wert. Die Werte werden im Array SMC_GeoInfo.aAdditionalParams : ARRAY[0..MAX_ADDITIONAL_PARAMS-1] OF LREAL gespeichert. <Param1Value> <Param1Value> " }, 
{ "title" : "Koordinatensystem schieben, drehen und skalieren ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Koordinatensystem schieben, drehen und skalieren ", 
"snippet" : "G-Code : G53 , G54 , G55 , G56 Funktion : Die G-Code-Befehle G54 , G55 und G56 schieben, drehen und skalieren das Decoderkoordinatensystem, das der Interpreterbaustein SMC_NCInterpreter intern verwendet. Die Koordinatentransformationen werden während der Ausführung der Funktionsbaustein-Instanz SMC_...", 
"body" : "G-Code : G53 , G54 , G55 , G56 Funktion : Die G-Code-Befehle G54 , G55 und G56 schieben, drehen und skalieren das Decoderkoordinatensystem, das der Interpreterbaustein SMC_NCInterpreter intern verwendet. Die Koordinatentransformationen werden während der Ausführung der Funktionsbaustein-Instanz SMC_NCInterpreter bei allen Bahnelementen berechnet. G-Code-Befehl G53 setzt das Decoderkoordinatensystem zurück in die ursprüngliche Lage, Orientierung und Skalierung: Es entspricht dem Maschinenkoordinatensystem. Verschieben und verdrehen Sie das Decoderkoordinatensystem, um den G-Code von Bahnelementen, die sich gleichen und nur durch Lage, Orientierung oder Skalierung unterscheiden, immer wieder zu verwenden. Das Drehen und Skalieren des Decoderkoordinatensystems funktioniert nur im Online-Interpreter (nicht im CNC-Editor). " }, 
{ "title" : "Koordinatensysteme MCS und DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Koordinatensystem schieben, drehen und skalieren \/ Koordinatensysteme MCS und DCS ", 
"snippet" : "Das Maschinenkoordinatensystem MCS (engl. Machine Coordinate System) wird durch die verwendete Kinematik vorgegeben, die dessen Lage und Orientierung bestimmt. Das Decoderkoordinatensystem DCS (engl. Decoder Coordinate System) ist ein Koordinatensystem, das der Interpreter (Funktionsbaustein-Instanz...", 
"body" : "Das Maschinenkoordinatensystem MCS (engl. Machine Coordinate System) wird durch die verwendete Kinematik vorgegeben, die dessen Lage und Orientierung bestimmt. Das Decoderkoordinatensystem DCS (engl. Decoder Coordinate System) ist ein Koordinatensystem, das der Interpreter (Funktionsbaustein-Instanz SMC_NCInterpreter ) verwaltet. Alle Koordinatenangaben für Bewegungsbefehle werden in diesem Koordinatensystem interpretiert. Das betrifft die Zielposition einer Bewegung ( X\/Y\/Z ), aber auch einen Kreismittelpunkt ( I\/J\/K ) oder eine Ebene, die mit G15\/G16\/G17\/G18\/G19 eingestellt wird. Das DCS wird mit den Befehlen G53\/G54\/G55\/G56 programmiert. Sie können das DCS bezogen auf das Maschinenkoordinatensystem drehen, schieben oder skalieren, und somit innerhalb der G-Codedatei beliebig oft in Lage, Orientierung und Skalierung anpassen. Sie programmieren die Bahnelemente relativ zum DCS. Das kann beispielswiese bei gleichen Bahnenelementen in verschiedenen Lagen und Orientierungen von Vorteil sein. Die nachfolgende Grafik zeigt eine Verschiebung (links) und eine Verschiebung mit Verdrehung (rechts). Der Interpreter erhält über seinen Eingang eOriConv die Information, ob A\/B\/C als Zusatzachsen behandelt werden oder als Orientierungswerte. Dementsprechend werden die Koordinaten der Bahnelemente transformiert. Der Interpreterbaustein verwaltet somit ein aktives Koordinatensystem. Initial, wenn das DCS weder verschoben, noch gedreht oder skaliert ist, entspricht das DCS dem MCS. Die Start- und Zielposition und die Ebene für Kreisbögen werden in den erzeugten GeoInfo-Objekten immer relativ zum MCS angegeben. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES Keine Orientierungskonvention angegeben. Der Inhalt der G-Code-Worte A\/B\/C wird als Schiebewert interpretiert. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYZ Die Orientierungskonvention ist die Standard-Y-Konvention (Z, Y‘, Z‘‘). Der Inhalt der G-Code-Worte A\/B\/C wird als Winkel interpretiert. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYX Die Orientierungskonvention ist die Gier-Nick-Roll-Konvention (Z, Y‘, X‘‘). Der Inhalt der G-Code-Worte A\/B\/C wird als Winkel interpretiert. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.XYZ Die Orientierungskonvention ist die XYZ-Konvention (X, Y‘, Z‘‘). Der Inhalt der G-Code-Worte A\/B\/C wird als Winkel interpretiert. " }, 
{ "title" : "Befehl G53, G54, G55, G56 ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Koordinatensystem schieben, drehen und skalieren \/ Befehl G53, G54, G55, G56 ", 
"snippet" : "G-Code Beschreibung G53 Setzt das Decoderkoordinatensystems zurück Das DCS wird wieder in die gleiche Lage und Orientierung gebracht wie das MCS. G54 Schiebt, dreht und skaliert das DCS absolut Die Werte beziehen sich auf das MCS. Wenn keine Orientierungskonvention angegeben ist ( SMC_NCInterpreter....", 
"body" : "G-Code Beschreibung G53 Setzt das Decoderkoordinatensystems zurück Das DCS wird wieder in die gleiche Lage und Orientierung gebracht wie das MCS. G54 Schiebt, dreht und skaliert das DCS absolut Die Werte beziehen sich auf das MCS. Wenn keine Orientierungskonvention angegeben ist ( SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES ), bewirkt der Befehl nur eine Schiebung entlang der Achsen X\/Y\/Z\/A\/B\/C und auf alle zusätzlichen linearen Achsen P\/Q\/U\/V\/W. Somit kann auch eine Schiebung entlang der Achsen A\/B\/C programmiert werden. Wenn eine Orientierungskonvention angegeben ist, bewirkt der Befehl auch eine Schiebung entlang der Achsen X\/Y\/Z und entlang zusätzlichen linearen Achsen P\/Q\/U\/V\/W. Außerdem werden die Koordinatenachsen gedreht. Dabei gibt die Orientierungskonvention die Drehfolge an und die G-Code-Wörter A\/B\/C die Drehwinkel in Grad. Hinweis: Der Interpreter kann gerichtete Drehungen in einem Bereich von -180° bis +180° ausführen. Wenn Sie einen Winkel außerhalb dieses Bereichs angeben, rechnet der Interpreter den Wert so um, dass er im ausführbaren Bereich liegt. Dann erst führt der Interpreter die Drehung der Koordinatenachsen aus. Beispielsweise wird bei einer Winkelangabe von 350° eine Drehung von -10° ausgeführt. G55 Schiebt, dreht und skaliert das DCS relativ zu dessen aktueller Lage und Orientierung Die Werte werden somit relativ zum aktuellen DCS-Ursprung und in Richtung der aktuellen Koordinatenachsen des DCS interpretiert. Bezogen auf das Maschinenkoordinatensystem wird eine weitere Schiebung\/Drehung hinzugefügt. Wenn keine Orientierungskonvention angegeben ist, bewirkt der Befehl nur eine relative Schiebung entlang der Achsen X\/Y\/Z\/A\/B\/C und auf alle zusätzlichen linearen Achsen P\/Q\/U\/V\/W. Somit kann auch eine Schiebung entlang der Achsen A\/B\/C programmiert werden. Wenn eine Orientierungskonvention angegeben ist, bewirkt der Befehl auch eine relative Schiebung entlang der Achsen X\/Y\/Z und entlang der zusätzlichen linearen Achsen P\/Q\/U\/V\/W. Vor allem aber werden die Koordinatenachsen weiter gedreht. Dabei gibt die Orientierungskonvention die Drehfolge an und die G-Code-Wörter A\/B\/C den Drehwinkel. G56 Setzt den Referenzpunkt des Decoderkoordinatensystems neu Die aktuelle Orientierung, Position und Skalierung des DCS wird als Referenz gesetzt. Tipp: Wenn der Referenzpunkt X0 Y0 Z0 A0 B0 C0 ist, dann wird das DCS identisch zur aktuellen Position und Orientierung gesetzt. Syntax G53\nG54 X Y Z A B C I J K P Q U V W\nG55 X Y Z A B C I J K P Q U V W\nG56 X Y Z A B C I J K P Q U V W G-Code Wort Beschreibung X Y Z Wert, um den das Decoderkoordinatensystem geschoben wird A B C Wenn am SMC_NCInterpreter der Eingang eOriConf = SMC_ORI_CONVENTION.ADDAXES ist, dann gibt der Wert in Einheiten an, wie weit die jeweilige Zusatzachse geschoben wird. Der Parameter definiert somit die Schiebung pro Achse des Decoderkoordinatensystem bezüglich des Maschinenkoordinatensystems. Wenn am SMC_NCInterpreter der Eingang eOriConf auf SMC_ORI_CONVENTION.ZYZ , SMC_ORI_CONVENTION.ZYX oder SMC_ORI_CONVENTION.XYZ ist, dann ist eine Orientierungskonvention angegeben. Dann werden automatisch die hier angebebenen Werte als Winkelgrad interpretiert und bestimmen, um wie viel die Achsen des Decoderkoordinatensystems bezüglich des Maschinenkoordinatensystems gedreht werden. Sie definieren somit die Drehung der Hauptachsen gemäß Orientierungskonvention. Hinweis: Beachten Sie bei der Programmierung der DCS-Drehung, dass immer für alle 3 Achsen die Drehwinkel in A\/B\/C anzugeben sind. Das Fehlen eines Drehwinkels führt zu einem Fehler beim Interpretieren ( SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ). I Skalierung in Richtung X Beispiel: 10 für Streckung um Faktor 10 J Skalierung in Richtung Y Beispiel: 10 für Streckung um Faktor 10 K Skalierung in Richtung Z Beispiel: 10 für Streckung um Faktor 10 P Q U V W Wert, um den die Zusatzachse des Decoderkoordinatensystems geschoben wird " }, 
{ "title" : "DCS schieben ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Koordinatensystem schieben, drehen und skalieren \/ DCS schieben ", 
"snippet" : "Setzen Sie den Eingang eOriConv der Funktionsbaustein-Instanz SMC_NCInterpreter auf SMC_ORI_CONVENTION.ADDAXES . Das DCS kann geschoben werden. Eine Drehung ist nicht möglich. Programmieren Sie die CNC-Bahn. Geben Sie zuerst die Lageverschiebung des DCS an. Beispiel: G54 X10 Y10 Z10 A30 B30 C30 Die ...", 
"body" : "Setzen Sie den Eingang eOriConv der Funktionsbaustein-Instanz SMC_NCInterpreter auf SMC_ORI_CONVENTION.ADDAXES . Das DCS kann geschoben werden. Eine Drehung ist nicht möglich. Programmieren Sie die CNC-Bahn. Geben Sie zuerst die Lageverschiebung des DCS an. Beispiel: G54 X10 Y10 Z10 A30 B30 C30 Die Achsen X\/Y\/Z\/A\/B\/C des DCS werden geschoben. Beispiel Absoluter Offset N10 G0 X100 Y100 F100\nN20 G54 X50 Y50 (Offset auf 50\/50)\nN30 G1 X0 Y0 (Fahrt nach 50\/50)\nN40 G54 X100 Y100 (Offset auf 100\/100)\nN50 G1 X0 Y0 (Fahrt nach 100\/100)\nN60 G53 (Offset auf 0)\nN70 G1 X0 Y0 (Fahrt nach 0\/0) Aktuelle Position als Offset N0 G0 X100 Y100 F100\nN10 G56 X0 Y0 (Aktuelle Position 100\/100 wird 0\/0)\nN20 G1 X10 (Fahrt nach 110\/100)\nN30 G56 X20 Y0 (Aktuelle Position 110\/100 wird 20\/0)\nN40 G1 X0 (Fahrt nach 90\/100) Offset um Wert anpassen N0 G54 X10 Y20 Z30 U7 (Offset: X=10, Y=20, Z=30, U=7)\nN10 G55 X-10 U7 (Offset: X=0, Y=20, Z=30, U=14) Gleiches Bahnelemente in 2 Lagen N05 G17\nN10 G54 X10 Y10 Z10\nN20 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN30 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN040 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097\nN50 G55 X10 Y10 Z10\nN60 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN70 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN80 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097 " }, 
{ "title" : "DCS schieben und drehen ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_df6926f62eedd311c0a8646378b457e7", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Koordinatensystem schieben, drehen und skalieren \/ DCS schieben und drehen ", 
"snippet" : "Setzen Sie den Eingang eOriConv der Funktionsbaustein-Instanz SMC_NCInterpreter auf die gewünschte Orientierungskonvention, beispielsweise SMC_ORI_CONVENTION.ZYZ . Die Orientierungskonvention und damit die Drehfolge der Achsen X\/Y\/Z des DCS ist programmiert. Bei SMC_ORI_CONVENTION.ZYZ ist die Drehfo...", 
"body" : "Setzen Sie den Eingang eOriConv der Funktionsbaustein-Instanz SMC_NCInterpreter auf die gewünschte Orientierungskonvention, beispielsweise SMC_ORI_CONVENTION.ZYZ . Die Orientierungskonvention und damit die Drehfolge der Achsen X\/Y\/Z des DCS ist programmiert. Bei SMC_ORI_CONVENTION.ZYZ ist die Drehfolge ZY’Z‘‘ und entspricht der Standard-Y-Konvention. Hinweis: Solange der Eingang eOriConv eine Orientierungskonvention enthält, und nicht den Wert SMC_ORI_CONVENTION.ADDAXES , werden bei den G-Code-Befehlen G54\/G55\/G56 die Werte der Wörter A\/B\/C als Winkelangaben für die Drehung interpretiert. Programmieren Sie die CNC-Bahn. Geben Sie zuerst die Lageverschiebung und Drehung des DCS an. Beispiel: G54 X10 Y10 Z10 A30 B30 C30 Die Werte der Wörter A\/B\/C geben die Drehrichtung und den Winkel in Winkelgrad an. Entsprechend wird das Koordinatensystem gedreht. Die Werte der Wörter X\/Y\/Z definieren die Schiebung. Hinweis: Beachten Sie bei der Programmierung der DCS-Drehung, dass immer für alle 3 Achsen die Drehwinkel in A\/B\/C anzugeben sind. Das Fehlen eines Drehwinkels führt zu einem Fehler beim Interpretieren ( SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ). Wenn der Eingang eOriConv der Funktionsbaustein-Instanz SMC_NCInterpreter den Wert SMC_ORI_CONVENTION.ADDAXES enthält, ist keine Drehung des DCS möglich. Die Werte in G54\/G55\/G56 werden als zusätzliche Splineachsenwerte interpretiert. Eine Schiebung ist möglich. Beispiele Die Orientierungskonvention ist bei den Beispielen auf den Standard-Y-Konvention festgelegt worden ( eOriConv = SMC_ORI_CONVENTION.ZYZ ). Allgemein gilt bei G54 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W gibt einen absolut neuen Wert im MCS an. G55 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W gibt einen relativen Wert im DCS an. G56 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W gibt einen absolut neuen Wert im DCS an. Absolute Orientierung mit G54 N01 G54 X10 A30 B0 C0 G54 bewirkt eine Schiebung und Drehung. Dabei ist die Lage und Orientierung absolut zum MCS angegeben. Relative Orientierung mit G55 N01 G54 X10 A30 B0 C0 (Bezieht sich auf MCS)\nN02 G55 Y10 A0 B30 C0 (Bezieht sich auf das in 01 definierte DCS) G54 führt hier zu einer Schiebung um 10 Einheiten in X-Richtung und um eine 30°-Drehung um die Z-Achse absolut zum MCS. Im Satz 02 wird das DCS dann um weitere 10 Einheiten in Richtung der gedrehten Y-Achse geschoben und dann um weitere 30° um die gedrehte Y-Achse gedreht. Die Transformation in Satz 02 ist also relativ zur Transformation in Satz 01. Referenzierung bezogen auf aktuelle Orientierung mit G56 N01 G01 X10 A10 B90 C10 (Orientierung ist A=10°, B=90°, C=10°)\nN02 G56 A0 B0 C0 (DCS wird auf X=10, A=10°, B=90°, C=10° gesetzt) G56 bewirkt, dass die aktuelle Orientierung des DCS (im Beispiel programmiert in Satz 01) als Referenz gesetzt wird. Beispiel Kreisbogen N0 G17\nN0 G54 A0 B90 C0 Die gewählte Kreisebene wird relativ zum DCS interpretiert. Im Beispiel wird mit G17 die X\/Y-Ebene gewählt und anschließend das DCS um 90° um die Y-Achse gedreht. Dann ist die gewählte Ebene im DCS nach wie vor die X\/Y-Ebene. Im MCS entspricht das der X\/Z-Ebene. Mit G17 wird die X\/Y-Ebene gewählt. Danach wird das DCS um 90° gedreht. Das bewirkt, dass im DCS nach wie vor die X\/Y-Ebene aktiviert ist. Das entspricht allerdings im MCS der Y\/Z-Ebene. Im 2.5D-Modus ( G15 ) darf nur um die Z-Achse gedreht werden. Eine Drehung um eine andere Achse führt zu einem Fehler, der vom Interpreter gemeldet wird ( SMC_DEC_DCS_2D_NOT_IN_XY_PLANE ). Damit bleibt im 2.5D-Modus immer die X\/Y-Ebene des MCS eingestellt. " }, 
{ "title" : "Koordinatensystem skalieren ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_52b3763cadb811e79ffc84f8a2d3d270", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Koordinatensystem schieben, drehen und skalieren \/ Koordinatensystem skalieren ", 
"snippet" : "Wenn nach einer ungleichmäßigen Skalierung eine Drehung programmiert ist, könnte eine Scherung entstehen. In diesem Fall wird der Fehler SMC_DEC_ROTATION_AFFECTS_SCALING ausgegeben. Es müssen entweder alle 3 Skalierungsfaktoren angegeben werden oder keiner. Absolut skalieren Syntax: G54 I<i> J<j> K<...", 
"body" : "Wenn nach einer ungleichmäßigen Skalierung eine Drehung programmiert ist, könnte eine Scherung entstehen. In diesem Fall wird der Fehler SMC_DEC_ROTATION_AFFECTS_SCALING ausgegeben. Es müssen entweder alle 3 Skalierungsfaktoren angegeben werden oder keiner. Absolut skalieren Syntax: G54 I<i> J<j> K<k> Ein Koordinatensystem kann in den 3 Raumrichtungen X\/Y\/Z jeweils unabhängig voneinander gestreckt oder gestaucht werden: Sie können für jede Richtung einen Faktor angegeben. Geben Sie den Skalierungsfaktor für X in I, für Y in J und für Z in K an. Ein Skalierungsfaktor > 1 bewirkt eine Streckung. Ein Skalierungsfaktor < 1 bewirkt eine Stauchung. 10-fache Streckung: N01 G01 X10\nN02 G54 A90 B0 C0 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 Alle Zielpunkte sind in Richtung der gedrehten X-Achse auf das 10-fache gestreckt. Folgender Code generiert dieselbe Bahn: N01 G01 X10\nN02 G01 X-20 Y100\nN03 G01 X-10 Y50. Sind weder I noch J noch K angegeben, dann bleibt der vorher gesetzte Wert erhalten: N01 G54 I10 J1 K1\nN02 G54 X1\nN03 G01 X10 Dieselbe Bahn wird mit folgendem Code bewirkt: N01 G01 X101 Relativ skalieren Syntax: G55 I<i> J<j> K<k> Ein Skalierungsfaktor > 1 bewirkt eine Streckung. Ein Skalierungsfaktor < 1 bewirkt eine Stauchung. Dabei multiplizieren sich die Skalierungsfaktoren. 100-fache Streckung: N01 G54 I10 J1 K1\nN02 G55 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 Folgender Code bewirkt die gleiche Skalierung: N01 G55 I100 J1 K1 Kreis skalieren Die Skalierung eines Kreisbogens ist nur gültig, wenn nach der Skalierung das Element noch ein Kreisbogen (keine Ellipse) ist. Gültige Bahnen ergeben sich: Wenn alle 3 Skalierungsfaktoren denselben Betrag haben Wenn die Kreisebene eine der Hauptebenen des DCS ist und die entsprechenden 2 Skalierungsfaktoren denselben Betrag haben " }, 
{ "title" : "Koordinatensystem spiegeln ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_adba25b098ef7863c0a8646324d700b4", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Koordinatensystem schieben, drehen und skalieren \/ Koordinatensystem spiegeln ", 
"snippet" : "Eine absolute Skalierung mit negativen Skalierungsfaktoren in I , J oder K bewirken Spiegelungen des aktuellen Koordinatensystems. Negativer Skalierungsfaktor G54 A30 B0 C0 I-1 J1 K1...", 
"body" : "Eine absolute Skalierung mit negativen Skalierungsfaktoren in I , J oder K bewirken Spiegelungen des aktuellen Koordinatensystems. Negativer Skalierungsfaktor G54 A30 B0 C0 I-1 J1 K1 " }, 
{ "title" : "Modi ", 
"url" : "_sm_cnc_din66025_modi.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Modi ", 
"snippet" : "Funktion : Diese Befehle legen fest, ob die Koordinaten und Achsmittelpunkte als absolute oder relative Koordinaten interpretiert werden. G-Code Beschreibung G90 Die Koordinaten ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) werden als absolute Werte interpretiert. (Dies ist die Standardeinstellung.)...", 
"body" : "Funktion : Diese Befehle legen fest, ob die Koordinaten und Achsmittelpunkte als absolute oder relative Koordinaten interpretiert werden. G-Code Beschreibung G90 Die Koordinaten ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) werden als absolute Werte interpretiert. (Dies ist die Standardeinstellung.) G91 Die Koordinaten ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) werden als Werte relativ zur aktuellen Position interpretiert. G98 Die Achsmittelpunkte ( I \/ J \/ K ) werden als absolute Werte interpretiert. G99 Die Achsmittelpunkte ( I \/ J \/ K ) werden als Werte relativ zur Startposition interpretiert. (Dies ist die Standardeinstellung.) Syntax G90\nG91\nG98\nG99 Beispiele Koordinatenwert als absoluter Wert Der Interpolator bewegt sich zu 10\/10 und weiter zu 100\/10. Die Koordinaten werden als absolute Werte interpretiert. N0 G90\nN10 G1 X10 Y10 F100 (Startposition)\nN20 G1 X100 (Nächste Position) Koordinatenwert als relativer Wert Der Interpolator bewegt zu 10\/10 und weiter zu 110\/10. Die Koordinaten werden als relative Werte interpretiert. N0 G91\nN10 G1 X10 Y10 F100\nN20 G1 X100 Koordinatenwert als absoluter Wert in I\/J\/K Der Mittelpunkt des Halbkreises befindet sich bei 150\/0. Die Koordinaten werden als absolute Werte interpretiert. N00 G98\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I150 J0 F100 Koordinatenwert als relativer Wert in I\/J\/K Der Mittelpunkt des Halbkreises befindet sich bei 150\/0. Die Koordinaten werden als relative Werte interpretiert. N00 G99\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I50 J0 F100 Für weitere Informationen siehe: Einzelne Zusatzachsen als Moduloachsen (PA\/PB\/…) konfigurieren" }, 
{ "title" : "Verweilzeit ", 
"url" : "_sm_cnc_din66025_delay.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Verweilzeit ", 
"snippet" : "G-Code : G4 Funktion : Der Befehl bewirkt, dass der Interpolator für eine bestimmte Zeit an der aktuellen Position stehen bleibt. Beispiel Verweilzeit N0 G4 T1 Der Interpolator verweilt 1 Sekunde....", 
"body" : "G-Code : G4 Funktion : Der Befehl bewirkt, dass der Interpolator für eine bestimmte Zeit an der aktuellen Position stehen bleibt. Beispiel Verweilzeit N0 G4 T1 Der Interpolator verweilt 1 Sekunde. " }, 
{ "title" : "Schaltpunkt (H-Funktion) ", 
"url" : "_sm_cnc_din66025_hfunction.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Schaltpunkt (H-Funktion) ", 
"snippet" : "Funktion : Die Schaltpunktfunktionalität oder H-Funktion aktiviert binäre, wegabhängige Schalter. Für jedes Bahnelement können maximal 3 Schaltpunkte ( MAX_SWITCHES ) abgearbeitet werden. Syntax [G-Befehl] H O\/L Zuerst wird die Schaltpunktnummer H<Nummer> definiert, dann wird die Position des Schalt...", 
"body" : "Funktion : Die Schaltpunktfunktionalität oder H-Funktion aktiviert binäre, wegabhängige Schalter. Für jedes Bahnelement können maximal 3 Schaltpunkte ( MAX_SWITCHES ) abgearbeitet werden. Syntax [G-Befehl] H O\/L Zuerst wird die Schaltpunktnummer H<Nummer> definiert, dann wird die Position des Schaltpunkts im Bahnelement entweder absolut über das Wort L<Position> oder relativ über das Wort O<Position> festgelegt. G-Code Wort Beschreibung H{-}<Nummer> Nummer der H-Funktion Wenn die H-Nummer positiv ist, wird die zugehörige Schaltfunktion eingeschaltet. Wenn die H-Nummer negativ ist, wird die Schaltfunktion ausgeschaltet. Die H-Nummern ist nicht 0 und liegt im Bereich von -32768 bis 32767. O<Position> Relative Position [0…1] im Bahnelement 0: Anfang des Elements 1: Ende L<Position> L>0: Distanz zum Startpunkt L<0: Distanz zum Endpunkt Grafische Darstellung Die Schaltpunkte können im grafischen Editor entlang der Bahn mit der Maus verschoben werden. Wenn die Maus über die H-Funktion bewegt wird, wird ein Tooltip mit der H-Nummer der H-Funktion angezeigt. Auswirkung auf den Funktionsbaustein SMC_Interpolator Der Interpolator gibt am Ausgang iLastSwitch die zuletzt geschaltete H-Nummer aus. iLastSwitch ist positiv, wenn die H-Funktion eingeschaltet ist. Der Ausgang dwSwitches ist eine Bit-Maske. Bit Nummer i gibt an, ob die H-Funktion (i+1) momentan gesetzt ist oder nicht. Wenn die H-Nummer zwischen 1 und 32 ist, dann wird im Interpolator-Ausgang dwSwitches das entsprechende Bit gesetzt. Ein negativer Wert zwischen -1 und -32 setzt das Bit zurück. Der Ausgang iLastSwitch gibt die Nummer des zuletzt überfahrenen Schaltpunkts aus, auch wenn der Wert außerhalb des Bereichs von -32 bis 32 liegt. Beispiele Ausschalten von Schaltpunkt 2 mit Position relativ zum Element Schaltpunkt 2 wird an der Position X=40\/Y=25 nach dem ersten Viertel des Elements abschaltet. N90 G1 X20 Y20\nN100 G1 X100 Y40 H-2 O0.25 Ein- und Ausschalten von Schaltpunkt 2 mit Position relativ zu Start- und Endpunkt Schaltpunkt 2 wird an Position X=40 eingeschaltet, also 20 Einheiten nach dem Startpunkt des Bahnelements. Schaltpunkt 2 wird an Position X=90 ausgeschaltet, also 10 Einheiten vor dem Endpunkt. N90 G1 X20\nN100 G1 X100 H2 L20 H-2 L-10 " }, 
{ "title" : "M-Funktion ", 
"url" : "_sm_cnc_din66025_mfunction.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ M-Funktion ", 
"snippet" : "Funktion : M-Funktionen oder Zusatzfunktionen starten Aktionen während der Interpolation von G-Code. Dabei bremst der Interpolator auf Geschwindigkeit 0, gibt am Ausgang wM die Nummer der anstehenden M-Funktion aus und wartet auf die Bestätigung in bAcknM , bevor wieder beschleunigt wird. Im Untersc...", 
"body" : "Funktion : M-Funktionen oder Zusatzfunktionen starten Aktionen während der Interpolation von G-Code. Dabei bremst der Interpolator auf Geschwindigkeit 0, gibt am Ausgang wM die Nummer der anstehenden M-Funktion aus und wartet auf die Bestätigung in bAcknM , bevor wieder beschleunigt wird. Im Unterschied zum Schaltpunkt bleibt das Programm so lange an der aktuellen Position stehen, bis die M-Funktion durch Setzen des Eingangs am Interpolator bestätigt wird. Wenn SMC_PreAcknowledgeM ausgeführt wird, bestätigt der Funktionsbaustein die M-Funktion vorzeitig. Wenn der Baustein rechtzeitig ausgeführt wird, hält der Interpolator nicht an und das Programm läuft weiter, als wäre die M-Anweisung nicht vorhanden. Eine M-Funktion wird durch die Applikation implementiert und ist nicht vom System festgelegt. Syntax M K L O G-Code Wort Beschreibung M Nummer der M-Funktion, M > 0 Hinweis: Die Nummern 65533 - 65535 sind für interne Funktionen reserviert. K Numerischer Parameter ( LREAL ) L Numerischer Paramter ( LREAL ) O Referenziert mit O$var$ eine Variable vom Typ SMC_M_PARAMETERS , die weitere Parameter enthält. In der Applikation werden die Parameterwerte der Variablen zur Laufzeit durch Verwendung der Funktion SMC_GetMParameters gelesen. Dabei werden alle Parameter zum Zeitpunkt des Dekodierens ausgewertet und in der Datenstruktur SMC_GEOINFO des Puffers SMC_OUTQUEUE gespeichert. Dies findet in der Regel eine gewisse Zeit vor der Ausführung der M-Funktion am Interpolator statt. Damit die Variable beim Dekodieren vom verwendeten Funktionsbaustein (beispielsweise SMC_ReadNCFile2 ) gefunden werden kann, muss sie zu dessen SMC_VARLIST mit dem Typ SMC_VARTYPE.SMC_TYPE_USERDEF hinzugefügt werden. Beispiele M mit Parameter M-Funktion 10 startet. Bei Programmausführung von N90 wird so lange gewartet, bis die Bestätigung da ist. N90 M10 K100.7 M mit zusätzlichem Parameter M-Funktion 10 startet. Die benutzerdefinierte Datenstruktur g_myMParams , Datentyp SMC_M_PARAMETER wird mit O$var$ referenziert. g_myMParams enthält zusätzliche Parameter. Die Werte von K, L und den Parametern von g_myMParams können zum Zeitpunkt des Bahnstopps der M-Funktion gelesen werden, indem eine Instanz des Bausteins SMC_GetMParameters aufgerufen wird. N150 M13 O$g_myMParams$ " }, 
{ "title" : "Zeitsynchronisation mit Interpolator ", 
"url" : "_sm_cnc_din66025_time_synchronisation_with_interpolator.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Zeitsynchronisation mit Interpolator ", 
"snippet" : "G-Code : G75 Funktion : Der Befehl verhindert, dass der Funktionsbaustein des Decoders G-Code abarbeitet, bis der Interpolator alle vorhergehenden Objekte abgefahren hat. Wenn der Interpolator G75 erreicht, sind alle Queues (Warteschlangen) leer und der NCDecoder und alle vorverarbeitenden Funktions...", 
"body" : "G-Code : G75 Funktion : Der Befehl verhindert, dass der Funktionsbaustein des Decoders G-Code abarbeitet, bis der Interpolator alle vorhergehenden Objekte abgefahren hat. Wenn der Interpolator G75 erreicht, sind alle Queues (Warteschlangen) leer und der NCDecoder und alle vorverarbeitenden Funktionsbausteine laufen weiter. Diese Funktion ist hilfreich, wenn Sie Variablen verwenden. Die Variablen werden vom Decoder ersetzt, wenn die korrespondierende Zeile abgearbeitet wird. Die Ausführung vom Interpolator jedoch geschieht gemäß dem Warteschlangen-Mechanismus erst eine bestimmte Zeit später. Sie können G75 verwenden, um zu warten und die Evaluation der Variablen und die Weiterverarbeitung des Interpolators zu synchronisieren. Syntax G75 Beispiel N10 G1 X100\nN20 G75\nN30 G1 Y$g_y$ Die Variable g_y wird mit Element G1 zur Verfügung gestellt und ist vorher nicht bekannt. Wenn G75 nicht eingefügt ist, arbeitet der NCDecoder die Zeile 30 sofort ab, bevor der Wert bekannt ist. G75 hat keine Auswirkung auf den CNC-Editor oder die Bahnen, die als SMC_OutQueue vom CNC-Editor generiert werden. " }, 
{ "title" : "Sprung ", 
"url" : "_sm_cnc_din66025_jump.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Sprung ", 
"snippet" : "G-Code : G20 Funktion : Der Befehl führt einen bedingten Sprung aus. Syntax G20 L K G-Code Wort Beschreibung L Sprungziel: definierte Zeilennummer, beispielsweise L20 Sprungmarke Der Sprung wird durch ein Fragezeichen und einen Index definiert, beispielsweise L?4 . Der Befehl für das Sprungziel selb...", 
"body" : "G-Code : G20 Funktion : Der Befehl führt einen bedingten Sprung aus. Syntax G20 L K G-Code Wort Beschreibung L Sprungziel: definierte Zeilennummer, beispielsweise L20 Sprungmarke Der Sprung wird durch ein Fragezeichen und einen Index definiert, beispielsweise L?4 . Der Befehl für das Sprungziel selbst wird durch ein Ausrufezeichen und den zugehörigen Index gekennzeichnet, beispielsweise L!4 . Das Sprungziel kann an jeden G-Code-Befehl angehängt werden. Dieser Sprung wird bei automatisch generierten CNC-Programmen eingesetzt, wenn die Zielzeile zunächst nicht bekannt ist. Sprünge mit unbekannten Zielen funktionieren nur im Online-Decoder (nicht im CNC-Editor). Voraussetzung: Die Zeile mit der Sprungmarke muss nach der Zeile mit dem Sprungbefehl stehen. Ein „Rückspringen“ ist nicht möglich. Wenn die „Zielzeile“ nicht definiert ist, werden alle nach dem Sprungbefehl folgenden Befehle nicht ausgeführt. K Bedingung Wenn K <> 0, wird der Sprung ausgeführt. Wenn K nicht definiert ist, wird eine interne Decoder-Variable verwendet. Der Wert der internen Decodervariablen kann mit dem Befehl Ändern von Variablenwerten definiert werden. Der Standardwert dieser internen Variable ist -1 . Beispiel: Sprung ausführen bis interner Zähler = 0 10 Geraden werden durch den Relativmodus aneinander gehängt. Daraus resultiert eine Geradenbewegung auf 100\/100. N00 G36 D10 (set counter to 10)\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G37 D-1 (decrement counter)\nN40 G20 L20 (jump, if counter != 0) Beispiel: Sprungbedingung zum Zeitpunkt des Dekodierens auswerten Voraussetzung: Das Verhalten der Variable bvar ist in der Applikation programmiert. Wenn die X-Achse die Position 15 überschreitet, wird bvar FALSE ( bVar ist initial auf TRUE gesetzt.) Beim ersten Programmzyklus ist die X-Position 10 und das Programm springt in die Zeile 20. Da die Auswertung der Bedingung zum Zeitpunkt des Decodierens stattfindet und der Interpolator noch nicht gestartet wurde oder mit der Abarbeitung von Objekten vom Anfang des Puffers beschäftigt ist, wird die Schleife fortwährend durchlaufen. Erst wenn so viele Objekte erzeugt wurden, dass der Puffer voll ist und der Interpolator mit der Abarbeitung beginnt, wird diese Bedingung erfüllt und der Decoder springt aus dieser Schleife. Beim zweiten Durchlauf ist die X-Achse noch nicht auf Position 20. Die Bedingung ist nicht erfüllt und bVar wurde im IEC-Code nicht auf FALSE gesetzt. N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G20 L20 K$bvar$ (jump, if counter != 0) Beispiel: Zeitsynchronisation einfügen G75 führt eine Zeitsynchronisation des Interpolators aus. G75 bewirkt, dass der Decoder so lange mit der Verarbeitung pausiert, bis der Interpolator und mit ihm die Mechanik die entsprechende Position erreichen. N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN25 G75\nN30 G20 L20 K$x$ (jump, if counter != 0) Für weitere Informationen siehe: Zeitsynchronisation mit InterpolatorBeispiel: Sprung auf Sprungmarke Hinweis: Sprünge auf Sprungmarken funktionieren nur im Online-Decoder (nicht im CNC-Editor). N0 G16 F100 E100 E-100\nN10 G20 L?4 \/\/unconditional jump to the unknown target with index 4\nN15 G20 L60\nN20 G1 X1\nN30 G1 X1 L!5 \/\/resolution unknown jump target with index 5\nN40 G1 Z1 L!4 \/\/resolution unknown jump target with index 4\nN50 G20 L15\nN55 G1 Y1\nN60 G0 X0 Y0 Z0 " }, 
{ "title" : "Kreisbogen ", 
"url" : "_sm_cnc_din66025_arc.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Kreisbogen ", 
"snippet" : "G-Code : G2 , G3 Funktion : Der Befehl interpoliert einen Kreisbogen von der aktuellen Position entlang einer Kreisbahn zur Zielposition. G2 bewirkt eine Bewegung im Uhrzeigersinn, G3 gegen den Uhrzeigersinn. Der Kreisbogen wird folgendermaßen definiert: Radiusmethode Zielkoordinate + Radius: Zielko...", 
"body" : "G-Code : G2 , G3 Funktion : Der Befehl interpoliert einen Kreisbogen von der aktuellen Position entlang einer Kreisbahn zur Zielposition. G2 bewirkt eine Bewegung im Uhrzeigersinn, G3 gegen den Uhrzeigersinn. Der Kreisbogen wird folgendermaßen definiert: Radiusmethode Zielkoordinate + Radius: Zielkoordinaten werden in X\/Y\/Z definiert. Die Biegung wird über Radius R definiert. Mittelpunktsmethode Zielkoordinate + Mittelpunktskoordinate: Zielkoordinaten werden in X\/Y\/Z definiert. Die Biegung wird über Mittelpunktskoordinate I\/J\/K definiert. Die Mittelpunktskoordinate liegt auf der Mittelsenkrechten von Start- und Endpunkt. Wenn dies nicht der Fall ist, wird die Mittelpunktskoordinate automatisch korrigiert. Die Abweichung darf dann nicht mehr als 10% betragen. Öffnungswinkelmethode Öffnungswinkel + Mittelpunktskoordinate: Öffnungswinkel wird in T, Mittelpunktskoordinaten in I\/J\/K definiert. Die Zielposition ergibt sich automatisch. Inkonsistente Parameter führen dazu, dass eine Gerade anstelle eines Kreises gefahren wird. Beispiele: Wenn der Radius kleiner als die halbe Distanz zwischen Start und Ziel ist, ist die Abweichung nicht korrigierbar. Ebenso, wenn der definierte Mittelpunkt zur Start- und Zielposition unterschiedliche Distanz hat. Syntax G2 X Y Z R A B C P Q U V W F E H L\/O D S\nG2 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG2 I J K T A B C P Q U V W F E H L\/O D S\nG3 X Y Z R A B C P Q U V W F E H L\/O D S\nG3 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG3 I J K T A B C P Q U V W F E H L\/O D S G-Code Wort Beschreibung X Y Z Zielpositionen der kartesischen Achsen R Kreisradius I J K Kreismittelpunktskoordinaten T Öffnungswinkel in Grad A B C P Q U V W Zielpositionen der Zusatzachsen F E Bahngeschwindigkeit, Bahnbeschleunigung\/-verzögerung H L\/O Schaltpunkt D Werkzeugradius S S-Profil Grafische Darstellung : Ein Kreisbogen wird mit schwarzen Endpunkten dargestellt. Wenn Sie das Element selektieren, können die Endpunkte verschoben werden. Kreisbögen im 3D-Modus Im 3D-Modus legt das System den Kreisbogen durch die Interpolationsebene, die mittels G15-G19 definiert wird. Beispiel 1 Halbkreis in der X\/Z-Ebene und 1 Halbkreis in der X\/Y-Ebene N10 G1 X100 Y100\nN15 G18\nN20 G2 X200 R50\nN25 G17\nN30 G3 X100 R50 " }, 
{ "title" : "Radiusmethode ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_535707857cba3404c0a86463692656db", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Kreisbogen \/ Radiusmethode ", 
"snippet" : "Mit der Radiusmethode können Sie einen Kreisbogen < 180° erzeugen. Die Radiusmethode ist gültig für zwei Kreisbögen. Einer kleiner als ein Halbkreis, einer größer als ein Halbkreis. Das System verwendet immer den kleineren Kreisbogen. Beispiel Halbkreis N10 G1 X100 Y100 F100 N20 G2 X200 Y100 R50 Ver...", 
"body" : "Mit der Radiusmethode können Sie einen Kreisbogen < 180° erzeugen. Die Radiusmethode ist gültig für zwei Kreisbögen. Einer kleiner als ein Halbkreis, einer größer als ein Halbkreis. Das System verwendet immer den kleineren Kreisbogen. Beispiel Halbkreis N10 G1 X100 Y100 F100\nN20 G2 X200 Y100 R50 Verwenden Sie die Mittelpunktsmethode mit I\/J\/K, um einen Kreisbogen mit mehr als 180° Öffnungswinkel zu erzeugen. Die Radiusmethode ist eindeutig, ausgenommen in dem Fall, dass Start- und Endpunkt des Kreises identisch sind. Das definiert entweder einen Null- oder einen Vollkreis. Das System fügt in diesem Fall einen Vollkreis ein. " }, 
{ "title" : "Mittelpunktmethode ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_7dc8851b7cba3404c0a864637c8195be", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Kreisbogen \/ Mittelpunktmethode ", 
"snippet" : "Wenn Sie die Mittelpunktmethode verwenden, unterscheiden Sie, ob die Koordinaten I\/J\/K relativ oder absolut angegeben sind. Wenn I , J und K nicht korrekt angegeben werden, ist kein Kreisbogen möglich und das System ersetzt diesen durch eine Gerade. Bei einer korrekten Angabe ist der Abstand zwische...", 
"body" : "Wenn Sie die Mittelpunktmethode verwenden, unterscheiden Sie, ob die Koordinaten I\/J\/K relativ oder absolut angegeben sind. Wenn I , J und K nicht korrekt angegeben werden, ist kein Kreisbogen möglich und das System ersetzt diesen durch eine Gerade. Bei einer korrekten Angabe ist der Abstand zwischen Mittelpunkt und Start- oder Endpunkt identisch. Beispiele Gleicher Halbkreis wie bei der Radiusmethode, spezifiziert über den relativen Mittelpunkt N10 G1 X100 Y100 F100\nN15 G99\nN20 G2 X200 Y100 I50 J0 Gleicher Halbkreis wie bei der Radiusmethode, spezifiziert über den absoluten Mittelpunkt N10 G1 X100 Y100 F100\nN15 G98\nN20 G2 X200 Y100 I150 J100 " }, 
{ "title" : "Öffnungswinkelmethode ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_955d99e37cba3404c0a864634d5c784c", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Kreisbogen \/ Öffnungswinkelmethode ", 
"snippet" : "Wenn Sie den Kreis über den Öffnungswinkel T definieren, sind maximal 3 Vollkreise zulässig (T ≤ 1080). Die Öffnungswinkelmethode ist geeignet für einen Kreisbogen > 180°. Beispiele Gleicher Halbkreis wie bei der Radiusmethode über den Öffnungswinkel spezifiziert N10 G1 X100 Y100 N15 G99 N20 G2 I50 ...", 
"body" : "Wenn Sie den Kreis über den Öffnungswinkel T definieren, sind maximal 3 Vollkreise zulässig (T ≤ 1080). Die Öffnungswinkelmethode ist geeignet für einen Kreisbogen > 180°. Beispiele Gleicher Halbkreis wie bei der Radiusmethode über den Öffnungswinkel spezifiziert N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T180 Helix (2 volle Kreise) N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T720 " }, 
{ "title" : "Ellipse ", 
"url" : "_sm_cnc_din66025_ellipse.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Ellipse ", 
"snippet" : "G-Code : G8 , G9 Funktion : Der Befehl spezifiziert einen Ellipsenbogen durch die Zielkoordinaten X\/Y, den Ellipsenmittelpunkt I\/J, die Ellipsenhauptachsen-Richtung K und das Längenverhältnis R zwischen Haupt- und Nebenachse. Syntax G8 X Y Z R I J K A B C P Q U V W F E H L\/O D S G9 X Y Z R I J K A B...", 
"body" : "G-Code : G8 , G9 Funktion : Der Befehl spezifiziert einen Ellipsenbogen durch die Zielkoordinaten X\/Y, den Ellipsenmittelpunkt I\/J, die Ellipsenhauptachsen-Richtung K und das Längenverhältnis R zwischen Haupt- und Nebenachse. Syntax G8 X Y Z R I J K A B C P Q U V W F E H L\/O D S\nG9 X Y Z R I J K A B C P Q U V W F E H L\/O D S G-Code Wort Beschreibung X Y Z Zielpositionen der kartesischen Achsen R Längenverhältnis zwischen Haupt- und Nebenachse. Bereich: 0 < R <= 1 R wird nur dann verwendet, wenn der Ellipsenbogen durch die Endpunkte, den Mittelpunkt und die Neigung der Hauptachse nicht eindeutig definiert ist. Das ist der Fall, wenn beide Endpunkte denselben Abstand zur Hauptachse haben. Dann müssen auch beide Endpunkte denselben Abstand zur Nebenachse haben, sonst gibt es keine Ellipse durch diese Punkte und das System ersetzt die Ellipse durch eine Gerade. I J Mittelpunkt K Richtung der Ellipsenhauptachse in Grad 0: in Richtung der X-Achse 90: in Richtung der Y-Achse -90: entgegengesetzt zur Y-Achse A B C P Q U V W Zielpositionen der Zusatzachsen F E Bahngeschwindigkeit, Bahnbeschleunigung\/-verzögerung H L\/O Schaltpunkt D Werkzeugradius S S-Profil Die Ellipse ist ein 2,5D-Objekt. Das bedeutet, dass die Ellipse immer in der X\/Y-Ebene gehört. Ellipsen in anderen Raumebenen werden nicht unterstützt. Beispiel N10 G0 X100 Y100 F100\nN15 G98\nN20 G8 X200 Y100 I150 J100 K45 R0.5 " }, 
{ "title" : "Lineare Bewegung ", 
"url" : "_sm_cnc_din66025_line.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Lineare Bewegung ", 
"snippet" : "G-Code : G1 Funktion : Dieser Positionierbefehl führt eine Geradeninterpolation aus. Die Geradeninterpolation bewirkt, dass sich der Interpolationspunkt von der aktuellen Position zu den definierten Zielkoordinaten auf einer Gerade bewegt. Alle Achsen kommen gleichzeitig dort an. Für die Beschreibun...", 
"body" : "G-Code : G1 Funktion : Dieser Positionierbefehl führt eine Geradeninterpolation aus. Die Geradeninterpolation bewirkt, dass sich der Interpolationspunkt von der aktuellen Position zu den definierten Zielkoordinaten auf einer Gerade bewegt. Alle Achsen kommen gleichzeitig dort an. Für die Beschreibung der Geraden müssen die Zielkoordinaten (X\/Y\/Z) definiert werden. Zusätzlich zur Bewegung im Raum können Sie für die Zusatzachsen A\/B\/C\/P\/Q\/U\/V\/W Zielpositionen angeben, die gleichzeitig mit den kartesischen Zielkoordinaten erreicht werden. Zwei aufeinanderfolgende identische Positionen führen immer zu einem Bewegungsstopp an dieser Position. Der Stopp erfolgt auch dann, wenn die nachfolgende Bahn stetig anschließt und ohne Stopp abgefahren werden könnte. Syntax G1 X Y Z A B C P Q U V W F E H L\/O D S G-Code Wort Beschreibung X Y Z Zielpositionen der kartesischen Achsen A B C P Q U V W Zielpositionen der Zusatzachsen F E Bahngeschwindigkeit, Bahnbeschleunigung\/-verzögerung H L\/O Schaltpunkt D Werkzeugradius S S-Profil Beispiele Geradeninterpolation Das Werkzeug wird an der der Startposition 0\/0\/0 (Voreinstellung) positioniert und wird dann geradlinig zur Zielposition 1\/2\/3 mit Geschwindigkeit 1, Beschleunigung 10, Verzögerung 20 gefahren. Gleichzeitig wird die Orientierungsachse A auf 180 Grad gefahren: N010 G01 X1 Y2 Z3 A180 F1 E10 E-20 Startposition Startposition wird auf 50\/50\/50, Geradeninterpolation von 50\/50\/50 nach 64\/30\/0 mit Vorschub 100 N000 G92 X50 Y50 Z50 F100\nN010 G01 X64 Y30 Z0 " }, 
{ "title" : "Parabel ", 
"url" : "_sm_cnc_din66025_parabel.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Parabel ", 
"snippet" : "G-Code : G6 Funktion : Der Befehl interpoliert eine Parabel, die durch die Koordinaten des Endpunkts X\/Y\/Z und des Scheitelpunkts I\/J beschrieben ist. Der Scheitelpunkt ist der Punkt, an dem die Tangente des Elements parallel zur Verbindungslinie von Start- und Endpunkt ist. Eine Parabel ist ein 2,5...", 
"body" : "G-Code : G6 Funktion : Der Befehl interpoliert eine Parabel, die durch die Koordinaten des Endpunkts X\/Y\/Z und des Scheitelpunkts I\/J beschrieben ist. Der Scheitelpunkt ist der Punkt, an dem die Tangente des Elements parallel zur Verbindungslinie von Start- und Endpunkt ist. Eine Parabel ist ein 2,5D-Objekt und liegt immer in der X\/Y-Ebene. Eine Parabel in einer anderen Raumebene wird nicht unterstützt. Syntax G6 X Y Z I J A B C P Q U V W F E H L\/O D S G-Code Wort Beschreibung X Y Z Zielpositionen der kartesischen Achsen I J Scheitelpunkt der Parabel A B C P Q U V W Zielpositionen der Zusatzachsen F E Bahngeschwindigkeit, Bahnbeschleunigung\/-verzögerung H L\/O H-Funktion D Werkzeugradius S S-Profil Beispiel N010 G00 X100 Y200 Z0 F100\nN020 G98\nN030 G06 X-100 Y200 Z00 I0 J0 " }, 
{ "title" : "Positionierung ", 
"url" : "_sm_cnc_din66025_positioning.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Positionierung ", 
"snippet" : "G-Code : G0 , G92 Funktion : Diese Befehle positionieren das Werkzeug. G0 kommandiert eine Bewegung im Eilgang auf einer Geraden zur definierten Position (normalerweise ohne Werkzeugeingriff). G92 setzt die Position sprunghaft um. Die Folge ist, dass auf den Achsen auch ein Sprung ausgeführt wird. W...", 
"body" : "G-Code : G0 , G92 Funktion : Diese Befehle positionieren das Werkzeug. G0 kommandiert eine Bewegung im Eilgang auf einer Geraden zur definierten Position (normalerweise ohne Werkzeugeingriff). G92 setzt die Position sprunghaft um. Die Folge ist, dass auf den Achsen auch ein Sprung ausgeführt wird. Wenn SMC_ControlAxisByPos.bAvoidGaps:=TRUE gesetzt wird, wird kein Sprung ausgeführt, sondern alle Achsen einzeln auf schnellstem Wege auf die Zielposition gefahren. G92 kann vor dem ersten Fahrelement eingefügt werden, um die Startposition zu setzen. Bei mehreren aufeinander folgenden G92-Befehlen wird der letzte ausgeführt. Die vorherigen werden übersprungen. Wenn ein G1-Satz mit identischen Koordinaten einfügt ist, wird der Sprung für einen Zyklus lang ausgeführt. Das ist von Vorteil, wenn die Bahn zwischen den Positionen der Sprungbefehle nicht von Interesse ist, sondern die Sollposition auf schnellstmöglichem Weg angefahren werden soll. Die Bausteine SMC_ControlAxisByPos* detektieren einen Sprung zu den Sollwerten, halten den Interpolator an und interpolieren jede Achse einzeln auf schnellstmöglichem Weg dorthin. Zwei aufeinanderfolgende identische Positionen führen immer zu einem Bewegungsstopp an dieser Position. Der Stopp erfolgt auch dann, wenn die nachfolgende Bahn stetig anschließt und ohne Stopp abgefahren werden könnte. Für weitere Informationen siehe Bibliotheksdokumentation zu Direct Axis Control Syntax G0 X Y Z A B C P Q U V W F FF E EF H L\/O S\nG92 X Y Z A B C P Q U V W H L\/O G-Code Wort Beschreibung X Y Z Zielpositionen der kartesischen Achsen A B C P Q U V W Zielpositionen der Zusatzachsen E Bahnbeschleunigung\/-verzögerung EF Bahnbeschleunigung\/-verzögerung nur für G0-Bewegungen. Wenn EF <> 0 gesetzt ist, wird der Wert, der in E definiert ist, für G0-Bewegungen nicht berücksichtigt. F Bahngeschwindigkeit FF Geschwindigkeit, die nur für G0-Bewegungen verwendet wird. Wenn FF <> 0 gesetzt ist, wird der Wert, der in F definiert ist, für G0-Bewegungen nicht berücksichtigt. H L\/O H-Funktion S S-Profil Grafische Darstellung Im graphischen Editor werden G0-Befehle mit grünen Linien dargestellt. G92 Befehle werden nicht direkt dargestellt, sie verschieben lediglich den Anfangspunkt des folgenden Elements. Positionierungsbefehle können nur im CNC-Texteditor oder im Tabelleneditor eingefügt werden. Im grafischen Editor können sie verschoben werden. Beispiele Positionierung mit Geradeninterpolation mit definiertem Vorschub N0 G92 X10 Y10 Sets the start position at 10\/10\nN10 G1 X20 F10 Linear interpolation to 20\/10 with feed 10\nN20 G0 Y20 F100 Linear positioning to 20\/20 with feed 100 Verschiedene Positioniermodi N0 G92 X100 Y100 F100 Sets the position at 100\/100\nN10 G1 X100 Y100 Saves the output of this position for one cycle\nN20 G92 X50 Y100 Sets the position suddenly to 50\/100 Positionierung mit definierter Bahngeschwindigkeit N1 G0 X1000 Y0 FF1000 EF10000 EF-10000 Positioning with velocity 1000\nN2 G1 Y100 F100 E100 E-100 Interpolating positioning with velocity 100\nN3 G0 X0 Y0 Positioning with velocity 1000\nN4 G0 X1000 FF0 EF0 Positioning with velocity 100 because FF and FE are reset; thus the values in F and E are used. " }, 
{ "title" : "Spline ", 
"url" : "_sm_cnc_din66025_spline.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Spline ", 
"snippet" : "G-Code : G5 , G10 Funktion : Der Befehl interpoliert das Bahnelement mit einem Spline, so dass die Übergänge vom vorigen und zum nächsten Bahnelement ohne Knick ineinander übergehen. Dabei wird der Spline-Abschnitt vom System automatisch so berechnet, dass Folgendes gilt: Die Endtangente des vorheri...", 
"body" : "G-Code : G5 , G10 Funktion : Der Befehl interpoliert das Bahnelement mit einem Spline, so dass die Übergänge vom vorigen und zum nächsten Bahnelement ohne Knick ineinander übergehen. Dabei wird der Spline-Abschnitt vom System automatisch so berechnet, dass Folgendes gilt: Die Endtangente des vorherigen Bahnelements stimmt mit der Starttangente des Splines überein. Ebenso stimmt die Endtangente des Splines mit der Starttangente des nachfolgenden Bahnelements überein. Funktion : Der Befehl legt ein Spline-Segment zur gegebenen Position an. Die Übergange vom vorigen Bahnelement sowie zum nachfolgenden Bahnelement sind stetig in Position und Tangente. Syntax G5 X Y Z A B C P Q U V W F E H L\/O D S\nG10 X Y Z A B C P Q U V W F E H L\/O D S G-Code Wort Beschreibung X Y Z Zielpositionen der kartesischen Achsen A B C P Q U V W Zielpositionen der Zusatzachsen F E Bahngeschwindigkeit, Bahnbeschleunigung\/-verzögerung H L\/O Schaltpunkt D Werkzeugradius S S-Profil Mehrere aufeinanderfolgende Spline-Segmente werden folgendermaßen aneinandergereiht: Starttangente Wenn ein Bahnelement mit Werkzeugeingriff vorhanden ist, zum Beispiel G1, G2, G3, G8, G9, wird die Endtangente des Bahnelements als Starttangente für den Spline verwendet. Wenn kein Bahnelement mit Werkzeugeingriff vorhanden ist, zum Beispiel G0, G92, M, wird die Verbindungslinie zwischen Startpunkt und erstem Spline-Punkt als Starttangente verwendet. Tangente in der Mitte des Splines Nachbarpunkte werden verbunden. Tangente des Punkts ist parallel zu dieser Verbindungslinie (grüne Gerade). Endtangente Wenn ein Bahnelement mit Werkzeugeingriff vorhanden ist, zum Beispiel G1, G2, G3, G8, G9, wird die Starttangente des Bahnelements als Endtangente des Splines verwendet. Wenn kein Bahnelement mit Werkzeugeingriff vorhanden ist, zum Beispiel G0, G92, M, wird die Verbindungslinie zwischen Endpunkt und erstem Spline-Punkt als Endtangente verwendet. Beispiele Treppenprofil mit Splines verrundet N0 G0 X0 Y0 Z0 F100 (Startposition)\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40 Profil verrundet mit doppeltem Spline N0 G0 X0 Y0 F100 (Startposition)\nN5 G1 X5 Y0\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN21 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40\nN45 G1 X0 Y40 Der Spline-Punkt bei X20 Y20 ist doppelt vorhanden. Dadurch wird der Spline unterbrochen und neu gestartet. Das zeigt sich an der Festlegungsmethode der Tangente an diesem Punkt. Die Start- und Endpunkte werden durch die Starttangenten des vorangehenden und nachfolgenden Geradenstücks festgelegt. " }, 
{ "title" : "Vorverarbeitung ", 
"url" : "_sm_cnc_din66025_preprocessor.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Vorverarbeitung ", 
"snippet" : "G-Code : G40 , G41 , G42 , G43 , G50 , G51 , G52 , G60 , G61 , G70 , G71 Funktion : Die Befehle aktiveren vorverarbeitende Module wie SMC_SmoothPath , SMC_RoundPath , SMC_AvoidLoop , SMC_ToolCorr , SMC_ToolLengthCorr und SMC_ToolRadiusCorr . Wenn die Option Vorverarbeitete Bahn anzeigen aktiviert is...", 
"body" : "G-Code : G40 , G41 , G42 , G43 , G50 , G51 , G52 , G60 , G61 , G70 , G71 Funktion : Die Befehle aktiveren vorverarbeitende Module wie SMC_SmoothPath , SMC_RoundPath , SMC_AvoidLoop , SMC_ToolCorr , SMC_ToolLengthCorr und SMC_ToolRadiusCorr . Wenn die Option Vorverarbeitete Bahn anzeigen aktiviert ist, ist die bearbeitete Bahn im grafischen Editor sichtbar. Syntax G40\nG41 D\nG42 D\nG50\nG51 D\nG52 D\nG60\nG61 G-Code Wort Beschreibung D Werkzeugradius oder Überblendradius bei G51\/G52 . Für Versionen vor 4.18.0.0: Die Eckverrundung\/Eckverschleifung ( G51\/G52 ) und Werkzeugradiuskorrektur ( G41\/G42 ) können sich gegenseitig beeinflussen, da beide Vorverarbeitungen jedes D-Wort im G-Code interpretieren. Ist beispielsweise eine Werkzeugradiuskorrektur mit Radius=1 aktiv, wenn eine Eckverundung mit D=5 startet, so verwendet die Werkzeugradiuskorrektur in Folge auch einen Radius von 5. Ab Version 4.18.0.0: Die Eckverrundung\/Eckverschleifung ( G51\/G52 ) und Werkzeugradiuskorrektur ( G41\/G42 ) können gleichzeitig verwendet werden, ohne dass sie sich gegenseitig beeinflussen. Dabei gilt folgendes Verhalten: Für Werkzeugradiuskorrektur ( G41\/G42 ): Standardmäßig ist der von SMC_ToolRadiusCorr verwendete 'Tool'-Radius 0. Wenn ein D-Wort hinter den G-Wörtern G41\/G42 angegeben wird, wird der 'Tool'-Radius angepasst und von den Bausteinen berücksichtigt. Ist kein Wert angegeben, wird der aktuell gesetzte 'Tool'-Radius verwendet. Für Eckverrundung\/Eckverschleifung ( G51\/G52 ): Standardmäßig ist der von SMC_Round\/SmoothPath verwendete 'Smooth'-Radius 0. Wenn ein D-Wort hinter einem beliebigen G-Wort (außer G36\/G37\/G40\/G41\/G42 ) oder auch alleinstehend (beispielsweise N00 D5 ) angegeben wird, so wirkt sich dies auf den aktuellen 'Smooth'-Radius aus und wird von den Bausteinen SMC_Round\/SmoothPath berücksichtigt. Befehle zur Werkzeugkorrektur G-Code Beschreibung G40 Beendet die Werkzeugradiuskorrektur G41 Startet die Werkzeugradiuskorrektur links vom Werkstück G42 Startet die Werkzeugradiuskorrektur rechts vom Werkstück G43 Startet die Werkzeuglängenkurrektur Der zu korrigierende Werkzeugversatz wird mit den Parametern I, J, K (entsprechend X, Y, Z ) angegeben. Die Werkzeuglängenkorrektur wird ausgeschaltet, indem die Parameter auf 0 gesetzt werden. Nach Einschalten bzw. Ausschalten wird ein Einrampen bzw. Ausrampen durchgeführt. Weitere Details siehe: SMC_ToolLengthCorr Anmerkung: Die Länge des Werkzeuges darf sich während einer aktiver Werkzeugradiuskorrektur nicht ändern, da es sonst zu einem Sprung in der Bahn kommt. Die Werkzeuglängenkorrektur (G43) funktioniert nur im Online-Decoder (nicht im CNC-Editor). Befehle zur Eckverrundung und Eckverschleifung G-Code Beschreibung G50 Beendet die Eckverrundung\/Eckverschleifung G51 Startet die Eckverschleifung durch SMC_SmoothPath G52 Startet die Eckverrundung durch SMC_RoundPath G70 Beendet die Glättung von Zusatzachsen durch SMC_SmoothAddAxes G71 Startet die Glättung von Zusatzachsen durch SMC_SmoothAddAxes Befehle zur Schleifenvermeidung G-Code Beschreibung G60 Beendet die Funktion zur Schleifenvermeidung G61 Startet die Funktion zur Schleifenvermeidung durch SMC_AvoidLoop Beispiel Eckverschleifung N0 G51 D10 F100\nN10 G01 X$g_x$ Y0 F50 E30 E-30\nN20 G01 X0 Y$g_y$\nN30 G01 X0 Y0\nN40 G50 " }, 
{ "title" : "Zusätzliche Spline-Achsen A, B, C ", 
"url" : "_sm_cnc_din66025_additional_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Zusätzliche Spline-Achsen A, B, C ", 
"snippet" : "G-Code Wort : A , B , C Funktion : Mit A , B und C legen Sie die Zielpositionen für zusätzliche Spline-Achsen fest. Diese Achsen sind ähnlich wie P , Q , U , V und W . Während P , Q , U und V linear interpoliert werden, werden A , B und C mit einem Polynom vom Grad 3 interpoliert. Die Verwendung von...", 
"body" : "G-Code Wort : A , B , C Funktion : Mit A , B und C legen Sie die Zielpositionen für zusätzliche Spline-Achsen fest. Diese Achsen sind ähnlich wie P , Q , U , V und W . Während P , Q , U und V linear interpoliert werden, werden A , B und C mit einem Polynom vom Grad 3 interpoliert. Die Verwendung von A , B oder C schließt die Verwendung der zusätzlichen Achsen U , V und W aus, weil U , V und W dann den Gradienten definieren. Die Achsen A , B oder C können mit den Bits 3, 4 oder 5 am Eingang wAxis von SMC_LimitDynamics oder wAddAxis von SMC_CheckForLimits ausgewählt werden. Die Funktionsbausteine SMC_SmoothPath , SMC_SmoothMerge , SMC_SmoothBSpline und SMC_RecomputeABCSlopes legt die Steigung der Zusatzachsen automatisch fest. Das heißt, die Definition von U , V oder W ist dann nicht notwendig. Beispiel 1 G-Code N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X100 A100 P100 Die lineare Zusatzachse P wird linear zum gefahrenen Weg interpoliert. Dementsprechend gibt ihr zeitliches Profil das der Bahngeschwindigkeit wieder. Die zusätzliche Spline-Achse A wird als Polynomfunktion interpoliert. Beispiel 2 Die Verwendung der Spline-Funktion ist insbesondere dann nötig, wenn eine Bahn mit stetigen Tangentenübergängen verwendet wird, die der Interpolator nicht auf Geschwindigkeit 0 bremsen muss: G-Code N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X50 A40 P40\nN30 G1 X100 A100 P100 Im linearen Fall sieht man einen Sprung in der Geschwindigkeit, der daher kommt, dass im ersten Abschnitt auf 50 Wegeinheiten 40 Einheiten der Zusatzachse verfahren werden; im zweiten Abschnitt auf 50 Wegeinheiten 60 Zusatzachseneinheiten. Da sich die Bahngeschwindigkeit nur nach dem Weg im kartsischen Raum (X Y Z) definiert, bewirkt eine konstante Geschwindigkeit in X einen Geschwindigkeitssprung in P: Die Spline-Achse zeigt folgendes Profil: Beispiel 3 Die Steigung der Achsen A, B und C an der Endposition kann über das U-, V- und W-Wort definiert werden. Die Einheit der Steigung ist Wegeinheit der Zusatzachse pro Wegeinheit im Raum. G-Code N10 G0 X0 A0 F10 E30 E-30\nN20 G1 X100 A100 U1.5\nN30 G1 X200 A200 U0 Da dieses Programm einen stetigen Übergang zwischen N20 und N30 enthält, wirkt die vom Anwender programmierte Steigung (U=2) der A-Achse. Bei X=100 nimmt also die Position der A-Achse doppelt so schnell zu wie die Bahnlänge. " }, 
{ "title" : "Zusatzachsenbewegung über mehrere Objekte verschleifen ", 
"url" : "_sm_cnc_din66025_smooth_additional_axis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Zusatzachsenbewegung über mehrere Objekte verschleifen ", 
"snippet" : "G-Code : G70 , G71 Funktion : G71 startet und G70 beendet das Verschleifen einer Bewegung auf der Zusatzachse, die in L angegeben ist und über mehrere Objekte verläuft. Syntax G70 L4 G71 L4 G-Code Wort Zusatzachse L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W...", 
"body" : "G-Code : G70 , G71 Funktion : G71 startet und G70 beendet das Verschleifen einer Bewegung auf der Zusatzachse, die in L angegeben ist und über mehrere Objekte verläuft. Syntax G70 L4\nG71 L4 G-Code Wort Zusatzachse L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W " }, 
{ "title" : "Einzelne Zusatzachsen als Moduloachsen (PA\/PB\/…) konfigurieren ", 
"url" : "_sm_cnc_din66025_define_additional_axis_modulo.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Einzelne Zusatzachsen als Moduloachsen (PA\/PB\/…) konfigurieren ", 
"snippet" : "Funktion: Für die Achsen A, B, C, P, Q, U, V, W kann durch das Setzen der Worte PA , PB , PC usw. eine Moduloperiode spezifiziert werden. Standardmäßig haben PA , PB usw. den Wert 0, dies bedeutet, dass die Achse linear ist. Wenn eine Zusatzachse als Moduloachse konfiguriert ist, dann wird immer auf...", 
"body" : "Funktion: Für die Achsen A, B, C, P, Q, U, V, W kann durch das Setzen der Worte PA , PB , PC usw. eine Moduloperiode spezifiziert werden. Standardmäßig haben PA , PB usw. den Wert 0, dies bedeutet, dass die Achse linear ist. Wenn eine Zusatzachse als Moduloachse konfiguriert ist, dann wird immer auf kürzestem Weg von der Start- zur Zielposition interpoliert. Bei einer Moduloperiode von 360 wird etwa von der Startposition 270 zur Zielposition 45 wie folgt verfahren: In positiver Richtung (über 360) um insgesamt 135 Einheiten und nicht in negativer Richtung um 225 Einheiten wie bei einer linearen Zusatzachse. Die Positionsausgabe des Interpolators kann außerhalb des Intervalls [0..Periodengrenze[ liegen. (Zum Beispiel 400 statt 40 bei einer Moduloperiode von 360.) Die Position wird von Folgebausteinen , wie SMC_ControlAxisByPos oder SMC_FollowPosition in den Modulobereich gebracht. Beispiel Rotatorisches Steuern einer Achse durch Modulo-Modus In Satz 30 wird die Achse A in positiver Richtung um 90° von 270° auf 360°=0° bewegt. N10 PA360 (A axis has a period of 360 degree)\nN20 G92 A270 (Set the position of A axis to 270)\nN30 G1 A0 " }, 
{ "title" : "Verwendung von Variablen ", 
"url" : "_sm_cnc_din66025_usage_of_variables.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Verwendung von Variablen ", 
"snippet" : "Syntax $<Variablenname>$ Gültige IEC-Basistypen für Variablen und Ausdrücke: INT , SINT , USINT , UINT , DINT , UDINT , BYTE , WORD , DWORD , REAL , LREAL . Ausnahmen sind der O-Parameter bei M-Funktionen, der eine Variable vom Typ SMC_M_PARAMETERS erwartet und G36\/G37 , wo zusätzlich String-Variabl...", 
"body" : "Syntax $<Variablenname>$ Gültige IEC-Basistypen für Variablen und Ausdrücke: INT , SINT , USINT , UINT , DINT , UDINT , BYTE , WORD , DWORD , REAL , LREAL . Ausnahmen sind der O-Parameter bei M-Funktionen, der eine Variable vom Typ SMC_M_PARAMETERS erwartet und G36\/G37 , wo zusätzlich String-Variablen erlaubt sind. Variablen oder Ausdrücke können für alle Worte außer den N-Worten, also den Satznummern, definiert werden. IEC-Ausdrücke und Variablen werden erst im Online-Decoderbaustein durch ihre momentanen Werte ersetzt. Dies geschieht, wenn die Zeile dekodiert wird, was einige Zeit vor der Abarbeitung des Elements im Interpolator stattfindet. Der Wert einer Variablen im Offlinebetrieb wird im Dialog Offlinewerte der Variablen geändert. Sie öffnen den Dialog mit dem Befehl CNC → Variable setzen oder in den Eigenschaften des CNC-Objekts mit der Schaltfläche Variablen . Verwenden einer globalen Variablen im Offlinebetrieb Deklarieren Sie die Variablen in der globalen Variablenliste. Verwenden Sie die Variablen im CNC-Editor an mindestens einer Stelle. Führen Sie den Befehls CNC → Variable setzen aus. Der Dialog Offlinewerte der Variablen öffnet sich. Geben Sie die gewünschten Werte in die Tabelle ein. Beispiel VAR_GLOBAL\n rVal_x1: REAL:=100;\n rVal_y1: REAL:=50;\nEND_VAR\n\n\/\/ CNC-Editor\nN0 G01 X$rVal_x1$ Y0 F50 E30 E-30\nN10 G01 X0 Y$rVal_y1$\nN20 G01 X0 Y0 Verhalten im Onlinebetrieb Wenn das Programm als Programmvariable mit SMC_CNC_REF übersetzt und vom Decoderbaustein online verarbeitet wird, funktioniert das Verwenden von Variablen. Die Variablen werden zu dem Zeitpunkt ersetzt, an dem der Decoder die entsprechende Zeile verarbeitet. Die Verwendung von Variablen in G-Code-Programmen, die online gelesen werden, benötigt zusätzliche Vorbereitung mit SMC_VARLIST . Wenn das CNC-Programm als SMC_OUTQUEUE übersetzt wird, funktioniert der Variablenmechanismus nicht, da die Bahn dann offline erzeugt und als unveränderliche Datenstruktur der Applikation übergeben wird. In diesem Fall und zur Anzeige im Offlinebetrieb ersetzt der Editor die Variable mit deren Offlinewert. Für weitere Informationen siehe: CNC-Datenstrukturen und globaler Zugriff" }, 
{ "title" : "Ändern von Variablenwerten ", 
"url" : "_sm_cnc_din66025_change_variable_values.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Ändern von Variablenwerten ", 
"snippet" : "G-Code : G36 , G37 Funktion : Die Befehle ändern den Wert einer Variablen. G36 schreibt den angegebenen Wert in eine Variable. G37 inkrementiert die Variable um den angegebenen Wert. O$var$ definiert die Variable, die bearbeitet wird. D definiert den Wert, der bei G36 geschrieben wird oder bei G37 a...", 
"body" : "G-Code : G36 , G37 Funktion : Die Befehle ändern den Wert einer Variablen. G36 schreibt den angegebenen Wert in eine Variable. G37 inkrementiert die Variable um den angegebenen Wert. O$var$ definiert die Variable, die bearbeitet wird. D definiert den Wert, der bei G36 geschrieben wird oder bei G37 addiert wird. Der Befehl wird zum Beispiel bei einem Schleifenzähler, der für bedingte Sprünge benötigt wird, angewendet. Syntax G36 O D\nG37 O D G-Code Wort bei G36 Beschreibung O Variable, auf die geschrieben wird. Wenn O nicht angegeben ist, wird eine interne Decodervariable verwendet. Der Standardwert dieser internen Variable ist -1 . Die interne Variable kann in dem Befehl Sprung verwendet werden. D Neuer Variablenwert G-Code Wort bei G37 O Variable, die inkrementiert wird. Wenn O nicht angegeben ist, wird eine interne Decodervariable verwendet. D Inkrement Beispiel Zähler programmieren (wenn die Bahn online verarbeitet wird) Die globale Variable g_i wird auf 5 gesetzt. N1000 G36 O$g_i$ D5 Die Zeilen 1010 und 1020 werden fünf Mal verfahren. N1000 G36 O$g_i$ D5\nN1010 G1 X100 F100 E100 E-100\nN1020 G1 X0\nN1030 G37 O$g_i$ D-1\nN1040 G20 L1010 K$g_i$ Der Mechanismus funktioniert nur, wenn die Bahn online verarbeitet wird, da nur dann Variablen verwendet werden können! Im CNC-Editor funktioniert dieser Mechanismus nicht. Zähler für Offlinebetrieb programmieren Wenn Sie offline im Editor arbeiten wollen, spezifizieren Sie mit O keine Variable. Dann wird eine implizite Decodervariable Typ INT verwendet. Aber es steht nur eine Variable zur Verfügung. Sie können keine verschachtelten Sprünge und Schleifen programmieren. Stringvariablen verwenden Sie können im G-Code eine Stringvariable im O-Wort verwenden. Außerdem darf dieser Variablen über den Befehl G36 und G37 ein Stringwert zugewiesen oder angehängt werden. Beispiel N10 G36 O$strTest$ D'Name' Die Variable strTest erhält den Wert Name. N20 G37 O$strTest$ D'=Test' Der Variablen strTest wird =Test angehängt. Wenn im CNC-Programm Stringvariablen verwendet werden und das CNC-Programm (im IEC- Programm) mit Hilfe des Funktionsbausteins SMC_ReadNCFile eingelesen wird, dann müssen für die Strings Puffer im IEC-Programm reserviert sein. Andernfalls tritt der Fehler SMV_RNCF_NO_STRINGBUFFER auf. Dafür steht der Funktionsbaustein SMC_StringBuffer zur Verfügung. Jeder String des CNC-Programms benötigt einen eigenen Platz in der Funktionsbaustein-Instanz von SMC_StringBuffer , auch wenn der gleiche String mehrfach vorkommt. Folgende Deklaration kann beispielsweise 32 Strings puffern: sb: SMC_StringBuffer(uiBufferSize := 32); Dann wird die Funktionsbaustein-Instanz sb als Pointer an den Eingang pStringBuffer der Instanz von SMC_ReadNCFile übergeben. " }, 
{ "title" : "Unterprogramme ", 
"url" : "_sm_cnc_din66025_subprograms.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Unterprogramme ", 
"snippet" : "Funktion : Aufruf eines Unterprogramms Häufig wiederkehrende Aufgaben, wie zum Beispiel Taschenfräsen, Lochbohren oder Werkzeugwechsel, können in G-Code-Unterprogramme ausgelagert und dann aufgerufen werden. Beim Aufruf können dem Unterprogramm Parameter übergeben werden. Dabei sind nur die Datentyp...", 
"body" : "Funktion : Aufruf eines Unterprogramms Häufig wiederkehrende Aufgaben, wie zum Beispiel Taschenfräsen, Lochbohren oder Werkzeugwechsel, können in G-Code-Unterprogramme ausgelagert und dann aufgerufen werden. Beim Aufruf können dem Unterprogramm Parameter übergeben werden. Dabei sind nur die Datentypen BOOL , LREAL und STRING zulässig. Wenn Sie Unterprogramme verwenden, müssen Sie statt der Funktionsbausteine SMC_ReadNCFile und SMC_NCDecoder die Funktionsbausteine SMC_ReadNCFile2 und SMC_NCInterpreter verwenden. Unterprogramme funktionieren nur im Online-Decoder (nicht im CNC-Editor). Jedes Unterprogramm wird in einer eigenen Datei gespeichert. Diese Dateien werden auf der Steuerung in einem oder mehreren Unterverzeichnissen abgelegt. Die Dateinamen müssen klein geschrieben sein, die Dateierweiterung .cnc haben und dem Namen des Unterprogramms entsprechen. Beispiel: Unterprogrammname „Drill“ -> Dateiname drill.cnc . Bitte beachten Sie, dass der Dateiname des Unterprogramms klein geschrieben werden muss. Der Baustein SMC_ReadNCFile2 hat einen Eingang aSubProgramDirs : ARRAY[0..4] OF STRING(174) . Darüber können bis zu 5 Unterverzeichnisse angegeben werden. Sie werden in der gegebenen Reihenfolge durchsucht. Gibt es in mehreren Verzeichnissen Unterprogramme desselben Namens, dann wird das Unterprogramm gefunden, dessen Verzeichnis im Array den kleineren Index hat. Der Unterprogrammname wird in Kleinbuchstaben umgewandelt. Beispiel aSubProgramDirs = ['subprograms\/user', 'subprograms\/system', ''] Das Unterprogramm DrillA1 wird zuerst in der Datei subprograms\/user\/drilla1.cnc gesucht. Existiert diese Datei nicht, wird noch in subprograms\/system\/drilla1.cnc gesucht. Es ist möglich, Unterprogramme indirekt über eine Variable (genauer gesagt über einen Ausdruck vom Typ STRING ) aufzurufen.  Der Auswertung des Ausdrucks (und somit auch ein eventueller Lookup von Variablen) erfolgt, wie generell bei der Verwendung von Variablen im G-Code, zum Zeitpunkt des Vorlaufs, wenn der Interpreter die Zeile erreicht. Die Typprüfung der Argumente wird in diesem Fall erst gemacht, wenn der Interpreter die Zeile erreicht hat und nicht bereits beim Parsen, wie das bei statischen Aufrufen der Fall ist. Unterprogramme können nicht offline im CNC-Editor erstellt werden. Maximale Schachtelungstiefe von Unterprogrammaufrufen Vor Version 4.18.0.0: Die maximale Schachtelungstiefe von Unterprogrammaufrufen ist auf 14 begrenzt. Ab Version 4.18.0.0: Die Schachtelungstiefe ist nur noch durch den Speicher begrenzt. Der Maximalwert kann über den Bibliotheksparameter SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPTH geändert werden. " }, 
{ "title" : "Syntax für den Aufruf ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Unterprogramme \/ Syntax für den Aufruf ", 
"snippet" : "Unterprogrammaufrufe sind spezielle Sätze im G-Code, die nur aus Satznummer und Aufruf bestehen. Es sind keine weiteren Wörter erlaubt. Weiter gibt es einen dynamischen Aufruf, bei dem der Name des Unterprogramms beim Parsen noch unbekannt ist und beispielsweise über eine IEC-Variable bereitgestellt...", 
"body" : "Unterprogrammaufrufe sind spezielle Sätze im G-Code, die nur aus Satznummer und Aufruf bestehen. Es sind keine weiteren Wörter erlaubt. Weiter gibt es einen dynamischen Aufruf, bei dem der Name des Unterprogramms beim Parsen noch unbekannt ist und beispielsweise über eine IEC-Variable bereitgestellt wird. N<SentenceNo> <Name> <BracketOpen> <ActualParamList> <BracketClosed>\nN<SentenceNo> DYNCALL <BracketOpen> <SubNameExp> [, <ActualParamListNotEmpty] <BracketClosed>\n\n<SubNameExp> : An expression with exactly one value of type STRING\n<ActualParamList> ::= Empty | <ActualParamListNotEmpty>\n<ActualParamListNotEmpty> ::= <ActualParamValue> | <ActualParamValue>, <ActualParamListNotEmpty> <Name> Gültiger IEC-Bezeichner mit mindestens 3 und maximal 80 Zeichen. Er muss dem Dateinamen (ohne Erweiterung) entsprechen, in dem das Unterprogramm definiert ist. Groß-\/Kleinschreibung spielt bei den Unterprogrammnamen keine Rolle. Es sind die Zeichen [a-zA-Z0-9_] erlaubt. Als Name sind folgende Schlüsselwörter ungültig: SUBPROGRAM, RETURN, END_SUBPROGRAM, RESTORE_MODES, BOOL, LREAL, STRING, LET, DYNCALL, IF, ELSE, END_IF, CASE, END_CASE, FOR,END_FOR, WHILE, END_WHILE, REPEAT, UNTIL, END_REPEAT . <ActualParamList> Es müssen exakt so viele Parameterwerte angegeben werden, wie das Unterprogramm vorschreibt (siehe ‚Syntax für die Deklaration‘). Der Typ jedes Parameterwerts muss mit der Deklaration übereinstimmen. <BracketOpen>\/<BracketClosed> Aus Kompatibilitätsgründen werden, bei Standardeinstellungen für SMC_ReadNCFile2 , für Unterprogrammaufrufe und Deklaration nicht runde Klammern, sondern geschweifte Klammern verwendet. Runde Klammern gelten im G-Code als Kommentarzeichen. Der Funktionsbaustein SMC_ReadNCFile2 besitzt einen Modus (Eingang bParenthesesAsComments ), bei dem runde Klammern keine Kommentare sind. Stattdessen werden mehrzeilige Kommentare dann mit (* eingeleitet und mit *) geschlossen. In diesem neuen Modus können sowohl geschweifte als auch runde Klammern für Unterprogrammaufruf und –deklaration verwendet werden. <ActualParamValue> Variable, Literal oder beliebige Ausdrücke Beispiel N10 SUB1()\nN20 DRILL(10.0)\nN30 SUB2(5, \"Text\", 2.5)\nN40 G36 O#SUBNAME D'DRILL' % Indirect call via local variable\nN40 DYNCALL(#SUBNAME, 2) % equivalent to N40 DRILL(2)\nN50 DYNCALL($SUBNAME$, 2, 4) % Indirect call via IEC variable " }, 
{ "title" : "Syntax für die Deklaration ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Unterprogramme \/ Syntax für die Deklaration ", 
"snippet" : "Ein Unterprogramm muss in einer eigenen Datei abgelegt sein. Dabei muss in der ersten Zeile, die weder leer noch eine Kommentarzeile ist, die Deklaration des Unterprogramms stehen. Es gilt folgender Syntax: SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT> <Inhalt Unter...", 
"body" : "Ein Unterprogramm muss in einer eigenen Datei abgelegt sein. Dabei muss in der ersten Zeile, die weder leer noch eine Kommentarzeile ist, die Deklaration des Unterprogramms stehen. Es gilt folgender Syntax: SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT>\n<Inhalt Unterprogramm>\nEND_SUBPROGRAM\n\n<FormalParamList> ::= Empty | <FormalParamListNotEmpty>\n<FormalParamListNoEmpty> ::= <FormalParam> | <FormalParam> , <FormalParamListNotEmpty>\n<FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String with a maximum length of 255 bytes\n<RESTORE_OPT> ::= RESTORE_MODES <ParamName> Der Name darf (nach Abzug des Präfixes # ) maximal 80 Zeichen lang sein. RESTORE_MODES Wenn dieses Schlüsselwort angegeben wird, dann werden bei der Rückkehr zum aufrufenden Programm folgende modalen Zustände wiederhergestellt, d.h. auf den Wert gesetzt, den sie beim Aufruf hatten: Aktiver G-Code Relativer\/absoluter Modus (G90\/G91, G98\/G99) Kreisebene und 2D\/3D-Modus Decoder-Koordinatensystem (inklusive Skalierung) Vorschubgeschwindigkeiten (Bahn und Zusatzachsen), Eilganggeschwindigkeit, maximale Beschleunigungen und Verzögerungen (Bahn und Zusatzachsen) Feature-Flags und allgemeine Parameter (G38) Werkzeugradius (D-Wort) Werkzeugoffsets (G43) S-Profil (S-Wort) Folgende modalen Zustände werden nicht wiederhergestellt: Aktuelle Position des Decoders\/Interpreters sowie der aktuelle Kardinal-Spline Zustand. Die Position umfasst die gesamte Struktur SMC_POSINFO , also X, Y, Z, die Orientierung und alle Zusatzachsen. Zustand (Ein\/Aus) der Bahnvorverarbeitungsbausteine (G40-G43, G50-G52, G60-G61, G70-G71) Moduloeinstellung der Zusatzachsen (PA, PB, …) Hinweis: Unabhängig von diesem Schlüsselwort werden bei der Rückkehr vom Unterprogramm zum aufrufenden Programm die impliziten Zählervariablen (G36, G37) wiederhergestellt. Beispiele SUBPROGRAM SUB1() ; no formal parameters\nSUBPROGRAM DRILL(#depth : LREAL)\nSUBPROGRAM SUB2(#a : LREAL, #b : STRING, #c : LREAL)\nSUBPROGRAM SRM1() RESTORE_MODES " }, 
{ "title" : "Syntax für den Rücksprung ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Unterprogramme \/ Syntax für den Rücksprung ", 
"snippet" : "Der Rücksprung erfolgt entweder am Ende des Unterprogrammtexts (vor dem END_SUBPROGRAM ) oder explizit mit folgende Syntax: N<Satznummer> RETURN ....", 
"body" : "Der Rücksprung erfolgt entweder am Ende des Unterprogrammtexts (vor dem END_SUBPROGRAM ) oder explizit mit folgende Syntax: N<Satznummer> RETURN . " }, 
{ "title" : "Verwendung der formalen Parameter im Unterprogramm ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_ba614a0b6544562fc0a864631e9ee966", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Unterprogramme \/ Verwendung der formalen Parameter im Unterprogramm ", 
"snippet" : "Auf die Werte der formalen Parameter kann im Unterprogramm durch #<ParamName> zugegriffen werden. Die Anzahl der formalen Parameter ist auf 21 begrenzt. Beispiel SUBPROGRAM SUB(#Param1 : LREAL) N10 G01 X#Param1...", 
"body" : "Auf die Werte der formalen Parameter kann im Unterprogramm durch #<ParamName> zugegriffen werden. Die Anzahl der formalen Parameter ist auf 21 begrenzt. Beispiel SUBPROGRAM SUB(#Param1 : LREAL)\nN10 G01 X#Param1 " }, 
{ "title" : "Anzeige der Aufrufliste ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Unterprogramme \/ Anzeige der Aufrufliste ", 
"snippet" : "Der Interpreter ( SMC_NCInterpreter ) besitzt einen Ausgang, der die 10 obersten aktiven Programme\/Unterprogramme enthält: aActivePrograms : ARRAY[0..9] OF STRING . Dabei ist der erste Eintrag ( aActivePrograms[0] ) das derzeit interpretierte Programm\/Unterprogramm. Der zweite Eintrag ( aActiveProgr...", 
"body" : "Der Interpreter ( SMC_NCInterpreter ) besitzt einen Ausgang, der die 10 obersten aktiven Programme\/Unterprogramme enthält: aActivePrograms : ARRAY[0..9] OF STRING . Dabei ist der erste Eintrag ( aActivePrograms[0] ) das derzeit interpretierte Programm\/Unterprogramm. Der zweite Eintrag ( aActivePrograms[1] ) ist das aufrufende Programm\/Unterprogramm und so weiter. Gibt es kein aufrufendes Programm, dann ist der entsprechende String leer. Die Aufrufliste kann auch zur Interpolationszeit angezeigt werden: Der Baustein SMC_DisplayNCCallstack zeigt die aktiven Programme\/Unterprogramme im gleichen Format wie der Interpreter, nur später (nämlich dann, wenn die Bewegung abgefahren wird). Dazu werden ihm als VAR_IN_OUT -Variablen der Interpreter-Ausgang CallstackInfo (SMC_NCCallstackInfo) und der Interpolator übergeben. SMC_NCCallstackInfo speichert alle Aufruflistenänderungen inklusive der zugehörigen SMC_GeoInfo -Objektnummer in einem Ringpuffer. Dadurch ist die Anzahl der speicherbaren Aufruflistenänderungen zwischen Interpretations- und Interpolationszeit beschränkt, momentan auf 128 Stück. Da der Ringpuffer nicht multitasksicher ist, muss SMC_DisplayNCCallstack aus der Interpreter-Task aufgerufen werden. Ein Beispiel für die Anzeige der Aufrufliste zur Interpolationszeit zeigt das Beispielprogramm CNC Beispiel 07: Ausdrücke und Unterprogramme verwenden. " }, 
{ "title" : "Ausdrücke ", 
"url" : "_sm_cnc_din66025_expressions.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Ausdrücke ", 
"snippet" : "Funktion : Ab der Version 4.4.0.0 ist es möglich, mathematische, boolesche und Zeichenketten-Ausdrücke zu verwenden. Dazu müssen die Funktionsbausteine SMC_ReadNCFile2 und SMC_NCInterpreter verwendet werden (anstelle von SMC_ReadNCFile und SMC_NCDecoder ). Ausdrücke funktionieren nur im Online-Decod...", 
"body" : "Funktion : Ab der Version 4.4.0.0 ist es möglich, mathematische, boolesche und Zeichenketten-Ausdrücke zu verwenden. Dazu müssen die Funktionsbausteine SMC_ReadNCFile2 und SMC_NCInterpreter verwendet werden (anstelle von SMC_ReadNCFile und SMC_NCDecoder ). Ausdrücke funktionieren nur im Online-Decoder (nicht im CNC-Editor). Ausdrücke können im G-Code prinzipiell an zwei Stellen verwendet werden: Als Werte von G-Wörtern (ein G-Wort besteht aus Adresse und Wert, z.B. „G1“) Als Übergabeparameter bei Unterprogrammaufrufen " }, 
{ "title" : "Syntax - Allgemeines ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_42546a9cc18a4349c0a86463750fefea", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Ausdrücke \/ Syntax - Allgemeines ", 
"snippet" : "Ein Ausdruck kann aus folgenden Elementen bestehen: Zahl- und Stringliterale globale und lokale Variablen Infix-Operatoren und Funktionen Kommata und Klammern Zur Strukturierung von Ausdrücken können in gleichberechtigter Weise runde (falls nicht zur Kennzeichnung von Kommentaren verwendet) und gesc...", 
"body" : "Ein Ausdruck kann aus folgenden Elementen bestehen: Zahl- und Stringliterale globale und lokale Variablen Infix-Operatoren und Funktionen Kommata und Klammern Zur Strukturierung von Ausdrücken können in gleichberechtigter Weise runde (falls nicht zur Kennzeichnung von Kommentaren verwendet) und geschweifte Klammern verwendet werden. Das heißt, der Ausdruck (1 + 2} * 3 ist zulässig. Der Funktionsbaustein SMC_ReadNCFile2 besitzt einen neuen Modus (Eingang bParenthesesAsComments ), bei dem runde Klammern keine Kommentare sind. Statt dessen werden mehrzeilige Kommentare dann mit (* eingeleitet und mit *) geschlossen. In diesem neuen Modus können sowohl geschweifte als auch runde Klammern für Ausdrücke verwendet werden. Ein Leerzeichen nach der G-Adresse ist nur dann erforderlich, wenn diese von SMC_ReadNCFile2 nicht als eigenständiges Token erkannt würde, Beispiel: X abs{-2} statt Xabs{-2}. Anders als in ST müssen einstellige Funktionen nicht zwingend mit Klammern aufgerufen werden, Beispiel: sin 3 . Jeder Teilausdruck wird während des Parsens einem der drei Typen BOOL, LREAL oder STRING zugeordnet. Entsprechend erwartet jeder Infix-Operator und jede Funktion eine bestimmte Folge von Argumenttypen, bei deren Nichteinhalten (falscher Typ, zu wenige oder zu viele Argumente) ein Fehler zurückgegeben wird. Einschränkungen: Satznummern müssen Zahlliterale sein. Sprungmarken ( x in L!x ) dürfen aus rein technischen Gründen keine lokalen Variablen enthalten. Für weitere Informationen siehe: Sprung, Verwendung von Variablen" }, 
{ "title" : "Beispiele ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_5b6258e8c18a4349c0a864632640e903", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Ausdrücke \/ Beispiele ", 
"snippet" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}} N02 G1 X$var$ + sin{pi + 3 * #locvar} N03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}}...", 
"body" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}}\nN02 G1 X$var$ + sin{pi + 3 * #locvar}\nN03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}} " }, 
{ "title" : "Unterstützte Operatoren und Funktionen ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_da2d0ac5c18a4349c0a864637cb30dc8", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Ausdrücke \/ Unterstützte Operatoren und Funktionen ", 
"snippet" : "Infix-Operatoren Zeichen Typ Argumente Präzedenz MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , LREAL 10 <> B...", 
"body" : "Infix-Operatoren Zeichen Typ Argumente Präzedenz MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , LREAL 10 <> BOOL STRING , STRING 10 > BOOL LREAL , LREAL 10 < BOOL LREAL , LREAL 10 >= BOOL LREAL , LREAL 10 <= BOOL LREAL , LREAL 10 AND BOOL BOOL , BOOL 6 XOR BOOL BOOL , BOOL 5 OR BOOL BOOL , BOOL 4 Funktionen Zeichen Typ Argumente - LREAL LREAL ABS LREAL LREAL MAX LREAL LREAL , LREAL MIN LREAL LREAL , LREAL NOT BOOL BOOL TRUE BOOL FALSE BOOL SIN LREAL LREAL COS LREAL LREAL TAN LREAL LREAL ASIN LREAL LREAL ACOS LREAL LREAL ATAN LREAL LREAL EXP LREAL LREAL LN LREAL LREAL SQRT LREAL LREAL EXPT LREAL LREAL , LREAL FLOOR LREAL LREAL CEIL LREAL LREAL PI LREAL LEN LREAL STRING CONCAT STRING STRING , STRING " }, 
{ "title" : "Definition eigener Funktionen ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_fca8916cc18a4349c0a8646350db2bd3", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Ausdrücke \/ Definition eigener Funktionen ", 
"snippet" : "Es ist möglich, eigene Funktionen hinzuzufügen oder eine vorhandene Implementierung zu überschreiben (beim Parsen des G-Codes werden Funktionen zuerst in den Anwenderfunktionen gesucht). Die Schnittstelle SMC_NC_IFunction muss implementiert sein, und eine globale Instanz der entsprechenden POU muss ...", 
"body" : "Es ist möglich, eigene Funktionen hinzuzufügen oder eine vorhandene Implementierung zu überschreiben (beim Parsen des G-Codes werden Funktionen zuerst in den Anwenderfunktionen gesucht). Die Schnittstelle SMC_NC_IFunction muss implementiert sein, und eine globale Instanz der entsprechenden POU muss über die Struktur SMC_NC_GFunctionTable an SMC_ReadNCFile2 oder SMC_ReadNCFromStream übergeben werden. Für den Rückgabetyp und die Typen der Argumente wird die Enumeration SMC_GVar_Type verwendet. Der dort enthaltene Eintrag T_OTHER kann als Platzhalter für einen Typ verwendet werden: Beim Parsen wird überprüft, dass alle Argumente, die in der Signatur einem T_OTHER entsprechen, den gleichen Typ haben. Der Typ ist beliebig. Für weitere Informationen siehe: Anwenderspezifische G-Code-Funktionen" }, 
{ "title" : "Fehlerbehandlung ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Ausdrücke \/ Fehlerbehandlung ", 
"snippet" : "Bei Syntaxfehlern werden nach Möglichkeit die genaue Position des fehlerhaften Tokens und seine Länge ausgegeben. Die Fehlerposition steht in SMC_ReadNCFile2.errorPos....", 
"body" : "Bei Syntaxfehlern werden nach Möglichkeit die genaue Position des fehlerhaften Tokens und seine Länge ausgegeben. Die Fehlerposition steht in SMC_ReadNCFile2.errorPos. " }, 
{ "title" : "Lokale Variablen ", 
"url" : "_sm_cnc_din66025_local_variables.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Lokale Variablen ", 
"snippet" : "Jede G-Code-Datei kann lokale Variablen deklarieren. Die Deklarationen müssen bei Hauptprogrammen ganz zu Beginn eingefügt werden, bei Unterprogrammen direkt nach der Unterprogrammdeklaration. Lokale Variablen sind nur in dem Programm oder Unterprogramm sichtbar, in dem sie deklariert werden. (Kein ...", 
"body" : "Jede G-Code-Datei kann lokale Variablen deklarieren. Die Deklarationen müssen bei Hauptprogrammen ganz zu Beginn eingefügt werden, bei Unterprogrammen direkt nach der Unterprogrammdeklaration. Lokale Variablen sind nur in dem Programm oder Unterprogramm sichtbar, in dem sie deklariert werden. (Kein dynamischer Scope.) Lokale Variablen funktionieren nur im Online-Decoder (nicht im CNC-Editor). Anzahl der lokalen Variablen Vor Version 4.18.0.0: Die Anzahl der lokalen Variablen ist pro Unterprogramm und im Hauptprogramm auf 21 begrenzt. Ab Version 4.18.0.0: Die Anzahl der lokalen Variablen ist nur noch durch den Speicher begrenzt. Der Maximalwert kann über den Bibliotheksparameter SMC_CNC_LibParams.MAX_SUBPROGRAM_PARAMS geändert werden. Für weitere Informationen siehe: Bibliotheksparameter Syntax für die Deklaration Die Syntax ist ähnlich der Syntax, mit der Unterprogrammparameter deklariert werden. Pro Satz kann eine Variable deklariert werden. Der Satz fängt nicht mit einem N-Wort an. Die Variable kann bei Deklaration optional mit einem Initialwert versehen werden. Ansonsten wird sie mit einem Standardwert je nach Typ vorbelegt ( LREAL: 0, BOOL: FALSE, STRING: ‘‘ ). Syntax der Deklaration: LET <FormalParam> [:= <InitialValue>] . <FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String mit maximaler Länge von 255 Bytes <InitialValue> : Ausdruck, der einen Wert und einen zur Variable passenden Typ hat. Der Ausdruck darf auch lokale Variablen (und in Unterprogrammen die Parameter des Unterprogramms) verwenden, allerdings nur solche, die weiter oben im Programmtext deklariert sind. Beispiele • LET #x : LREAL (* Variable #x, Typ LREAL, Initialwert 0 *)\n• LET #y : LREAL := #x + 1 (* Variable #y, Typ LREAL, Initialwert #x+1 = 1 *)\n• LET #b : BOOL := #x >= #y (* Variable #b, Typ BOOL, Initialwert FALSE *) Bei lokalen Variablen spielt, wie bei Unterprogrammparametern, Groß- und Kleinschreibung keine Rolle. ( #x und #X bezeichnen dieselbe Variable.) Die Namen aller in einem Programm\/Unterprogramm deklarierten lokalen Variablen müssen unterschiedlich sein. Sie müssen sich von den Namen der formalen Parameter des Unterprogramms unterscheiden. Lokale Variablen können im G-Code wie Parameter von Unterprogrammen verwendet werden. Beispiele • N10 G01 X#x Y#y\n• N20 G20 L10 K#b " }, 
{ "title" : "Restweg Löschen ", 
"url" : "_sm_probe_movement.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ CNC-Sprache DIN 66025 \/ Restweg Löschen ", 
"snippet" : "G-Code : G31 \/ Beliebiges Bewegungskommando zusammen mit dem PROBE -Wort Funktion : Restweg Löschen ist eine spezielle Bewegung, die abgebrochen wird, sobald ein Signal ( PROBE ) anliegt. Der Rest des G-Codes wird ab der Position fortgesetzt, an der die Bewegung abgebrochen wurde und nicht an der pr...", 
"body" : "G-Code : G31 \/ Beliebiges Bewegungskommando zusammen mit dem PROBE -Wort Funktion : Restweg Löschen ist eine spezielle Bewegung, die abgebrochen wird, sobald ein Signal ( PROBE ) anliegt. Der Rest des G-Codes wird ab der Position fortgesetzt, an der die Bewegung abgebrochen wurde und nicht an der programmierten Endposition der Bewegung. Restweg Löschen verursacht einen impliziten Dekodierstopp vor der folgenden Bewegung, vergleichbar mit G75 . Das Dekodieren des G-Codes wird erst fortgesetzt, nachdem das Signal empfangen wurde. Typische Anwendungsfälle sind die Messung der Tool-Länge (Fahren in einen Schalter) oder das Fahren auf Block. Restweg Löschen kann für beliebige Bewegungen, wie beispielsweise Geraden und Kreisbögen, aktiviert werden. Dazu muss im G-Code nur das PROBE -Wort hinzugefügt werden. G31 ist eine lineare Bewegung mit Restweg Löschen, mit der Default Probe-Nummer 1. Dieser Default kann mit einem PROBE-Wort überschrieben werden. Jede Bewegung darf höchstens ein PROBE -Wort haben. H-Funktionen (Bahnschaltpunkte) werden für Bewegungen mit Restweg Löschen nicht unterstützt. Bahnvorverarbeitung wie Eckverschleifung, Werkzeugradiuskorrektur usw. werden für Bewegungen mit Restweg Löschen nicht unterstützt. Die Probe-Nummer muss positiv sein. Wenn während der Abarbeitung einer Bewegung mit Restweg Löschen kein passendes Probe-Signal empfangen wird, dann hält der Interpolator am Ende der Bewegung mit einem Fehler. Der Interpolator muss zunächst angehalten werden, wenn ein Probe-Signal empfangen wird. Dazu kann einer der Eingänge bSlow_Stop , bQuick_Stop oder bEmergency_Stop verwendet werden. Sobald die Interpolation angehalten wurde, kann Restweg Löschen quittiert werden. Dazu wird eine steigende Flanke auf den Eingang SMC_Interpolator.bAcknProbe geschrieben. Syntax G31 X Y Z A B C P Q U V W F E S PROBE\nG1\/2\/3\/8\/9 X Y Z A B C P Q U V W F E S PROBE G-Code Wort Beschreibung X Y Z Zielpositionen der kartesischen Achsen A B C P Q U V W Zielpositionen der Zusatzachsen F E Bahngeschwindigkeit, Bahnbeschleunigung\/-verzögerung S S-Profil PROBE Die Probe-Nummer, muss positiv sein Beispiele Lineare Bewegung Lineare Bewegung mit Restweg Löschen und Default-Probe-Nummer 1 N010 G31 X100 Kreisbewegung Kreisbewegung mit Restweg Löschen und Probe-Nummer 7 N010 G02 X100 R50 PROBE 7 Für weitere Informationen siehe das Beispiel: CNC-Beispiel 16: Restweg löschen (G31)" }, 
{ "title" : "Bahnvorverarbeitung und Queue-Größen ", 
"url" : "_sm_preprocessing_queuesize.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Bahnvorverarbeitung und Queue-Größen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Stückweise Abarbeitung von G-Code ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103127844091", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Bahnvorverarbeitung und Queue-Größen \/ Stückweise Abarbeitung von G-Code ", 
"snippet" : "Es ist oft nicht sinnvoll, G-Code Dateien komplett einzulesen, bevor mit der Abarbeitung begonnen wird. Für manche Anwendungen können G-Code-Dateien Hunderttausende oder sogar Millionen von Zeilen umfassen, so dass das komplette Einlesen viel Zeit und Speicher benötigen würde. Stattdessen wird der G...", 
"body" : "Es ist oft nicht sinnvoll, G-Code Dateien komplett einzulesen, bevor mit der Abarbeitung begonnen wird. Für manche Anwendungen können G-Code-Dateien Hunderttausende oder sogar Millionen von Zeilen umfassen, so dass das komplette Einlesen viel Zeit und Speicher benötigen würde. Stattdessen wird der G-Code eingelesen und jeweils nur ein kleiner Teil (einige hundert Zeilen) gleichzeitig im Speicher gehalten. Dieser Teil wird in Queues gehalten, also in Datenstrukturen, die nach dem \"First in, first out\"-Prinzip funktionieren: Der Baustein, der die Queue befüllt, hängt Elemente in die Queue ein. Der Baustein, der aus der Queue liest, entnimmt Elemente in derselben Reihenfolge, in der sie eingefügt wurden. Das Diagramm veranschaulicht den Datenfluss des G-Codes. Zuerst wird der G-Code aus einer Datei eingelesen, dann im Interpreter in sogenannte GeoInfo-Elemente umgewandelt, dann von Bahnvorverarbeitungsbausteinen bearbeitet und schließlich interpoliert. Die mit \"GeoInfo\" gekennzeichneten Rechtecke stehen jeweils für eine Queue. Wenn es mehrere Bahnvorverarbeitungsbausteine gibt (beispielsweise SMC_SmoothPath , SMC_ToolRadiusCorr oder SMC_AvoidLoop ), dann sind sie jeweils über eine eigene Queue verbunden. " }, 
{ "title" : "Empfohlene Queue-Größen ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128036484", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Bahnvorverarbeitung und Queue-Größen \/ Empfohlene Queue-Größen ", 
"snippet" : "Als Richtwert sollten die meisten Queues eine Größe von 16 Elementen haben. Die letzte Queue vor dem Baustein SMC_Interpolator (das ist in der Regel die Queue des Bahnvorverarbeitungsbausteins vor SMC_CheckVelocities ) sollte eine Größe von 100 Elementen haben. Um diese Richtwerte zu verstehen und z...", 
"body" : "Als Richtwert sollten die meisten Queues eine Größe von 16 Elementen haben. Die letzte Queue vor dem Baustein SMC_Interpolator (das ist in der Regel die Queue des Bahnvorverarbeitungsbausteins vor SMC_CheckVelocities ) sollte eine Größe von 100 Elementen haben. Um diese Richtwerte zu verstehen und zu wissen, wann sie nicht passen, müssen Sie die Auswirkungen der Queue-Größe kennen: Latenz beim Einlesen: Je größer die Queues sind, desto länger dauert es, sie initial zu füllen. Der Baustein SMC_Interpolator wartet mit dem Start der Interpolation, bis die letzte Queue komplett gefüllt ist. Für die Latenz zählt die Summe aller Queue-Größen. Vorausschau des Interpolators: Die Vorausschau des Interpolators wird durch die letzte Queue vor dem Baustein SMC_Interpolator bestimmt. Wenn dieser die Trajektorie berechnet, kann er nur bis zum Ende der Vorausschau planen. Ist die Vorausschau zu klein, dann erreicht er unter Umständen nicht die volle Vorschubgeschwindigkeit. Abhängig von der Vorschubgeschwindigkeit und der Länge der Bahnelemente kann es sein, dass die empfohlene Größe von 100 Elementen zu klein ist. Auswirkung auf bestimmte Funktionsbausteine : Funktionsbausteine wie SMC_AvoidLoop oder SMC_SmoothMerge benötigen eine bestimmte Größe der Queue, aus der sie lesen, um gute Ergebnisse zu erzielen. Durch SMC_AvoidLoop werden zum Beispiel nur Schleifen im G-Code erkannt, die komplett in die Queue passen. In der Dokumentation der Vorverarbeitungsbausteine finden sich nähere Informationen. " }, 
{ "title" : "Aufruf der Vorverarbeitung ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128219711", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Bahnvorverarbeitung und Queue-Größen \/ Aufruf der Vorverarbeitung ", 
"snippet" : "Wie oben erwähnt startet die Interpolation erst, wenn alle Queues initial gefüllt sind. Dies verursacht eine Latenz zwischen dem Start der Vorverarbeitung und dem Start der Interpolation und damit der Abarbeitung durch die Maschine. Um diese Latenz zu reduzieren gibt es neben der Verkleinerung der Q...", 
"body" : "Wie oben erwähnt startet die Interpolation erst, wenn alle Queues initial gefüllt sind. Dies verursacht eine Latenz zwischen dem Start der Vorverarbeitung und dem Start der Interpolation und damit der Abarbeitung durch die Maschine. Um diese Latenz zu reduzieren gibt es neben der Verkleinerung der Queues noch eine weitere Möglichkeit. Die Bahnvorverarbeitungsbausteine werden üblicherweise in einer zyklischen Hintergrundtask aufgerufen, wie in diesem Beispiel: CNC-Beispiel 03: Bahnvorverarbeitung online durchführen. Zur Verringerung der Latenz kann das Programm, das SMC_ReadNCFile2 ,  SMC_NCInterpreter und die Bahnvorverarbeitungsbausteine enthält, in einer Schleife aufgerufen werden. Je nach Applikation und Task-Prioritäten kann es ausreichend sein, das Programm pro Task-Aufruf mehrfach ausführen zu lassen (beispielsweise 100 mal) oder die Schleife nach einer bestimmten Zeitspanne (beispielsweise 5 ms) abzubrechen. " }, 
{ "title" : "Beispiele ", 
"url" : "_sm_cnc_examples.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CNC-Beispiel 01: OutQueue direkt erzeugen ", 
"url" : "_sm_example_cnc_1.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 01: OutQueue direkt erzeugen ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC01_direct.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt ein CNC-Programm mit zwei Achsen. 4 Positionen in der XY-Ebene werden mit einer definierten Geschwindigkeit und Beschleunigung angefahren. Du...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC01_direct.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt ein CNC-Programm mit zwei Achsen. 4 Positionen in der XY-Ebene werden mit einer definierten Geschwindigkeit und Beschleunigung angefahren. Durch das Programm werden auf der Bahn zwei Wegschaltpunkte gesetzt. Das Programm wird durch Verwenden des Übersetzungsmodus SMC_OutQueue direkt in eine Datenstruktur geschrieben. Inbetriebnahme Übersetzen Sie das erstellte Programm und starten sie es. Das Programm führt die CNC-Bewegung aus, sobald der Eingang Execute des Interpolators gesetzt wurde. Wenn das Programm vollständig abgefahren ist, können Sie es durch eine neue steigende Flanke erneut starten. Bitte beachten Sie auch die Funktion der Wegschalter, die in der Visualisierung des Interpolations-Bausteins ebenfalls dargestellt sind. " }, 
{ "title" : "NC-Programme im CNC-Editor erstellen ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_0decf30fe1170213c0a864632e7a1fa2", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 01: OutQueue direkt erzeugen \/ NC-Programme im CNC-Editor erstellen ", 
"snippet" : "Erstellen Sie ein Projekt CNCdirect mit einer SoftMotion -Steuerung. Fügen Sie ein Object CNC-Programm mit dem Namen Example ein. Wählen Sie dabei die Implementierung Din66025 und den Übersetzungsmodus SMC_OutQueue . Geben Sie folgende Bewegungssätze ein: CNC-Editor:...", 
"body" : "Erstellen Sie ein Projekt CNCdirect mit einer SoftMotion -Steuerung. Fügen Sie ein Object CNC-Programm mit dem Namen Example ein. Wählen Sie dabei die Implementierung Din66025 und den Übersetzungsmodus SMC_OutQueue . Geben Sie folgende Bewegungssätze ein: CNC-Editor: " }, 
{ "title" : "Drive Interface, Steuerungskonfiguration erstellen ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_502a86c7e1170213c0a864631de910a9", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 01: OutQueue direkt erzeugen \/ Drive Interface, Steuerungskonfiguration erstellen ", 
"snippet" : "Definieren Sie wie folgt eine Antriebsstruktur mit 2 linearen Antrieben: Fügen Sie unterhalb des SoftMotion General Axis Pool zwei virtuelle Antriebe X_Drive und Y_Drive ein. Stellen Sie den Parameter Achsentyp auf Begrenzt (1). Konfigurationseditor:...", 
"body" : "Definieren Sie wie folgt eine Antriebsstruktur mit 2 linearen Antrieben: Fügen Sie unterhalb des SoftMotion General Axis Pool zwei virtuelle Antriebe X_Drive und Y_Drive ein. Stellen Sie den Parameter Achsentyp auf Begrenzt (1). Konfigurationseditor: " }, 
{ "title" : "IEC-Programm erstellen ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_2840ecebe1170213c0a8646360b1cd08", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 01: OutQueue direkt erzeugen \/ IEC-Programm erstellen ", 
"snippet" : "Fügen Sie der Applikation ein neues CFC-Programm Ipo hinzu und konfigurieren Sie dafür eine zyklische Task mit einem Intervall von 3 ms. Aktivieren Sie die Antriebe mit dem Funktionsbaustein MC_Power . Bausteine: Fügen Sie nun den Baustein SMC_Interpolator ein. Der Baustein überführt eine durch GEOI...", 
"body" : "Fügen Sie der Applikation ein neues CFC-Programm Ipo hinzu und konfigurieren Sie dafür eine zyklische Task mit einem Intervall von 3 ms. Aktivieren Sie die Antriebe mit dem Funktionsbaustein MC_Power . Bausteine: Fügen Sie nun den Baustein SMC_Interpolator ein. Der Baustein überführt eine durch GEOINFO-Objekte beschriebene Bahn in diskrete Bahnpunkte. Der Baustein erhält am Eingang poqDataIn die Adresse des erstellten CNC-Programms. Zudem muss die IEC-Task-Zykluszeit auf den Eingang dwIpoTime geschrieben werden. Diese können Sie entweder als konstanten Wert am Eingang dwIpoTime eingeben oder Sie benutzen die Variable dwCycle der Achsgruppen-Struktur aus der Steuerungskonfiguration. Dies hat den Vorteil, dass automatisch die richtige Zeit als Interpolator-Eingang verwendet wird, wenn Sie die Zykluszeit der Task ändern. Baustein: In unserem Beispiel soll ein Portalsystem gesteuert werden. Fügen Sie deshalb eine Instanz der Rückwärts- und Vorwärtstransformationsbausteine aus der Bibliothek SM_Trafo ein. Der Vorwärtstransformationsbaustein erhält als Eingänge die Antriebe, der Rückwärtstrafobaustein muss die Soll-Position des Interpolators erhalten. Die Vorwärtstransformation wird im Beispiel nur für die Visualisierung benötigt. Funktionsbausteininstanz: Die Ausgänge des Bausteins, also die Achskoordinaten, müssen nun auf die Antriebe geschrieben werden. Dies erfolgt mit dem Funktionsbaustein SMC_ControlAxisByPos . Da die Applikation nicht gewährleistet, dass die Ausgaben des Interpolators stetig sind, (zum Beispiel endet die Bahn an einem anderen Punkt als sie anfängt), aktivieren Sie die Sprungvermeidung ( bAvoidGaps , fGapVelocity , fGapAcceleration , fGapDeceleration ). Danach verbinden Sie den Ausgang StopIpo mit dem Eingang bEmergency_Stop des Interpolators und den Interpolator-Ausgang iStatus mit den entsprechenden Eingängen der Achskontroll-Bausteine. Achten Sie bei der Programmierung mit CFC vor allem auch auf die richtige Reihenfolge der Bausteine! CFC: " }, 
{ "title" : "Bedien- und Testoberfläche erstellen ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 01: OutQueue direkt erzeugen \/ Bedien- und Testoberfläche erstellen ", 
"snippet" : "Binden Sie in eine neue Visualisierung zwei Visualisierungsobjekte ein: das Template des Interpolators und das Template der Transformation. Diese müssen Sie über das Platzhalterkonzept mit den entsprechenden Bausteininstanzen (hier: Ipo.smci und Ipo.trafof ) verknüpfen....", 
"body" : "Binden Sie in eine neue Visualisierung zwei Visualisierungsobjekte ein: das Template des Interpolators und das Template der Transformation. Diese müssen Sie über das Platzhalterkonzept mit den entsprechenden Bausteininstanzen (hier: Ipo.smci und Ipo.trafof ) verknüpfen. " }, 
{ "title" : "CNC-Beispiel 02: Online dekodieren mit Verwendung von Variablen ", 
"url" : "_sm_example_cnc_2.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 02: Online dekodieren mit Verwendung von Variablen ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC02_online.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Beispiel zeigt, wie ein CNC-Programm unter Verwendung von Variablen dekodiert werden kann. Inbetriebnahme Übersetzen Sie das erstellte Programm und starten sie...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC02_online.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Beispiel zeigt, wie ein CNC-Programm unter Verwendung von Variablen dekodiert werden kann. Inbetriebnahme Übersetzen Sie das erstellte Programm und starten sie es. Das Programm führt die CNC-Bewegung aus, sobald der Eingang Execute des Decoders und des Interpolators gesetzt wurde. Wenn Sie die Werte der globalen Variablen ändern, werden diese bei einem Neustart des Decoders übernommen und die Bahn passt sich entsprechend an. Beobachten Sie auch die Funktion des Eingangs Append des Decoders. " }, 
{ "title" : "NC-Programm im CNC-Editor erstellen ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_4c86ec04e529c0bcc0a864636a6ae1dc", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 02: Online dekodieren mit Verwendung von Variablen \/ NC-Programm im CNC-Editor erstellen ", 
"snippet" : "Erstellen Sie ein Programm CNCOnline mit einer SoftMotion -Steuerung. Legen Sie eine globale Variablenliste an und deklarieren Sie darin zwei Variablen. VAR_GLOBAL g_x: REAL:=100; g_y:REAL:=50; END_VAR Fügen Sie ein Object CNC-Programm mit dem Namen Example ein. Wählen Sie dabei die Implementierung ...", 
"body" : "Erstellen Sie ein Programm CNCOnline mit einer SoftMotion -Steuerung. Legen Sie eine globale Variablenliste an und deklarieren Sie darin zwei Variablen. VAR_GLOBAL\n g_x: REAL:=100;\n g_y:REAL:=50;\nEND_VAR Fügen Sie ein Object CNC-Programm mit dem Namen Example ein. Wählen Sie dabei die Implementierung Din66025 und den Übersetzungsmodus SMC_CNC_REF . Dieser Modus ist notwendig, da Sie in Ihrem Programm Variablen verwenden. Geben Sie folgende Bewegungssätze ein: CNC-Editor: " }, 
{ "title" : "Drive Interface, Steuerungskonfiguration erstellen ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_7e9d1704e529c0bcc0a8646343b60bbd", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 02: Online dekodieren mit Verwendung von Variablen \/ Drive Interface, Steuerungskonfiguration erstellen ", 
"snippet" : "Definieren Sie eine Antriebsstruktur wie im Beispiel CNCdirect ....", 
"body" : "Definieren Sie eine Antriebsstruktur wie im Beispiel CNCdirect . " }, 
{ "title" : "IEC-Programm erstellen ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3989abe9e529c0bcc0a864630f20ee19", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 02: Online dekodieren mit Verwendung von Variablen \/ IEC-Programm erstellen ", 
"snippet" : "Fügen Sie eine POU (CFC) mit dem Namen Path zur Applikation hinzu. Im Programm Path finden die Decodierung des NC-Programms zur OUTQUEUE und die Geschwindigkeitsüberprüfung statt. Der Aufruf von SMC_CheckVelocities ist obligatorisch. CFC: Fügen Sie eine POU (CFC) mit dem Namen Ipo zur Applikation hi...", 
"body" : "Fügen Sie eine POU (CFC) mit dem Namen Path zur Applikation hinzu. Im Programm Path finden die Decodierung des NC-Programms zur OUTQUEUE und die Geschwindigkeitsüberprüfung statt. Der Aufruf von SMC_CheckVelocities ist obligatorisch. CFC: Fügen Sie eine POU (CFC) mit dem Namen Ipo zur Applikation hinzu. Dieses Programm ist fast identisch mit dem Programm des Beispiels CNCdirect . Der Dateneingang des Interpolators entspricht jedoch nicht CNC-Programmnamen ( ADR(Example) ), sondern dem OutQueue-Ausgang der bahnvorverarbeitenden Bausteine ( checkVel.poqDataOut ). " }, 
{ "title" : "Task für die Bahnvorverarbeitung anlegen ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3014d45de529c0bcc0a86463617895a7", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 02: Online dekodieren mit Verwendung von Variablen \/ Task für die Bahnvorverarbeitung anlegen ", 
"snippet" : "Da Sie den Übersetzungsmodus SMC_CNC_REF gewählt haben, müssen Sie das Decodieren und Bahnvorverarbeiten im IEC-Programm durchführen. Diese Berechnung ist zeitintensiv. Sie muss nicht im Interpolatortakt ausgeführt werden, da pro Decoder-Aufruf ein Wegobjekt erzeugt wird, das typischerweise für viel...", 
"body" : "Da Sie den Übersetzungsmodus SMC_CNC_REF gewählt haben, müssen Sie das Decodieren und Bahnvorverarbeiten im IEC-Programm durchführen. Diese Berechnung ist zeitintensiv. Sie muss nicht im Interpolatortakt ausgeführt werden, da pro Decoder-Aufruf ein Wegobjekt erzeugt wird, das typischerweise für viele Interpolatoraufrufe verwendet wird. Sie sollten den Vorgang in eine Task mit niedrigerer Priorität und selteneren Aufrufen auslagern. Legen Sie eine Task PathTask an. Legen Sie folgende Parameter fest: Priorität : 10 Intervall : T#30ms Fügen Sie die POU Path zur Task hinzu. Task PathTask Zugrundeliegender Mechanismus: In der langsamen Task wird anfänglich pro Zyklus etwa ein GEOINFO-Objekt erzeugt, das in der OUTQUEUE-Struktur des Decoder-Bausteins gespeichert ist. Ist diese OUTQUEUE voll, pausieren die Bausteine der langsamen Task solange, bis die OUTQUEUE nicht mehr voll ist. Dies ist der Fall, sobald die schnelle Task das erste GEOINFO-Objekt abgearbeitet hat und dieses aus der OUTQUEUE löscht. Dann werden die Bausteine der langsamen Task wieder aktiv und befüllen die OUTQUEUE-Struktur. In der schnellen Task wird pro Zyklus ein Bahnpunkt aus der OUTQUEUE-Struktur, auf die der Eingang DataIn des Interpolators zeigt, berechnet und verarbeitet. Da ein GEOINFO-Objekt in der Regel aus mehreren Bahnpunkten besteht, dauert es einige Zyklen bis das erste GEOINFO-Objekt abgearbeitet ist und vom Interpolator automatisch gelöscht wird. Da das Abarbeiten eines GEOINFO-Objekts im Gegensatz zum Erstellen mehrerer Zyklen dauert, kann die langsame Task seltener aufgerufen werden als die schnelle. Die Taskzeiten müssen jedoch so gewählt werden, dass in der letzten OUTQUEUE der langsamen Task immer genügend GEOINFO-Objekte gelagert sind, so dass kein Data-Underrun auftritt. Dies tritt auf, wenn dem Interpolator aus DataIn keine GEOINFO-Objekte mehr zur Verfügung stehen, und das Bahnende noch nicht erreicht ist. In diesem Fall bremst der Interpolator und bleibt so lange stehen, bis wieder neue Datenelemente verfügbar sind. " }, 
{ "title" : "Bedien- und Testoberfläche erstellen ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 02: Online dekodieren mit Verwendung von Variablen \/ Bedien- und Testoberfläche erstellen ", 
"snippet" : "Die Visualisierung entspricht dem Beispiel CNCdirect.project . Fügen Sie zusätzlich Templates der neuen Bausteine ( SMC_NCDecoder und SMC_CheckVelocities ) hinzu. Legen Sie auch für die globalen Variablen g_x und g_y eine Anzeige an, damit Sie deren Funktion später bei der Inbetriebnahme überprüfen ...", 
"body" : "Die Visualisierung entspricht dem Beispiel CNCdirect.project . Fügen Sie zusätzlich Templates der neuen Bausteine ( SMC_NCDecoder und SMC_CheckVelocities ) hinzu. Legen Sie auch für die globalen Variablen g_x und g_y eine Anzeige an, damit Sie deren Funktion später bei der Inbetriebnahme überprüfen können. " }, 
{ "title" : "CNC-Beispiel 03: Bahnvorverarbeitung online durchführen ", 
"url" : "_sm_example_cnc_3.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 03: Bahnvorverarbeitung online durchführen ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC03_prepro.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Beispiel zeigt, wie eine Bahnvorverarbeitung online auf der SPS durchgeführt werden kann. Erweitern Sie das Projekt CNC02_online um eine Bahnvorverarbeitung. D...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC03_prepro.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Beispiel zeigt, wie eine Bahnvorverarbeitung online auf der SPS durchgeführt werden kann. Erweitern Sie das Projekt CNC02_online um eine Bahnvorverarbeitung. Dabei werden die Ecken der Bewegung des Projekts CNConline durch Splines verrundet. Dies erfolgt über den Funktionsbaustein SMC_SmoothPath . Erweitern Sie das CNC-Programm: Umklammern Sie das bisherige Programm mit den Worten G51\/G50 . Damit die von der Bahnvorverarbeitung erstellten Splines im Editor wie in folgendem im Screenshot angezeigt werden, wählen Sie den Befehl CNC → Vorverarbeitete Bahn anzeigen . Darstellung: Ohne die Verwendung von Variablen könnten Sie das Programm in dieser Form als Queue übersetzen und direkt in den Interpolator eingeben. Da jedoch Variablen vorhanden sind, müssen Sie das Decodieren und die Eckverschleifung selbst durchführen. Deklarieren Sie einen neuen Baustein vom Typ SMC_SmoothPath . Rufen Sie ihn nach dem Decoder auf. Setzen Sie wie immer den Dateneingang des Interpolator-Bausteins auf den Ausgang poqDataOut des Bausteins CheckVelocities . Für den Eingang SMC_SmoothPath.pbyBufferOutQueue muss ein neuer Buffer deklariert werden. CFC: Inbetriebnahme Übersetzen Sie das erstellte Programm und starten sie es. Das Programm stoppt – im Unterschied zum vorigen – nicht mehr in den Ecken des NC-Programms, da die Ecken der Bahn durch die Bahnvorverarbeitung knickfrei gemacht wurden. " }, 
{ "title" : "CNC-Beispiel 04: CNC mittels Tabelleneditor programmieren ", 
"url" : "_sm_example_cnc_4.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 04: CNC mittels Tabelleneditor programmieren ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC04_table.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . In diesem Projekt ist die Funktionalität des Projekts CNC03_prepro.project mit dem Tabelleneditor programmiert. Im Unterschied zu CNC03_prepro.project werden in die...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC04_table.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . In diesem Projekt ist die Funktionalität des Projekts CNC03_prepro.project mit dem Tabelleneditor programmiert. Im Unterschied zu CNC03_prepro.project werden in diesem Projekt keine IEC-Variablen verwendet, sondern es wird mit festen Werten gerechnet. Ansonsten ist die Funktionalität identisch. " }, 
{ "title" : "CNC-Beispiel 05: CNC aus Datei erstellen ", 
"url" : "_sm_example_cnc_5.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 05: CNC aus Datei erstellen ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC05_File.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Anhand dieses Beispiels können Sie nachvollziehen, wie das Einlesen eines G-Code-Programms aus einer ASCII-Datei, die auf der SPS abgelegt ist, funktioniert. Eine so...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC05_File.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Anhand dieses Beispiels können Sie nachvollziehen, wie das Einlesen eines G-Code-Programms aus einer ASCII-Datei, die auf der SPS abgelegt ist, funktioniert. Eine solche Datei zu verwenden ist sinnvoll, wenn das G-Code-Programm sehr groß ist. Die Funktion des Projekts ist ähnlich dem Beispielprojekt CNC02_online.project , das G-Code-Programm wird jedoch aus einer ASCII-Datei eingelesen. Es werden keine Variablen verwendet und die Abarbeitungsreihenfolge ist vergleichbar mit der in dem Projekt CNC02_online.project . Zusammenfassend lassen sich folgende Unterschiede feststellen: zusätzlicher virtueller Antrieb (z-Achse) Baustein smoothpath wird nicht benötigt G-Code wird aus Datei eingelesen Vorverarbeitung online (siehe CNC02_online.project ) " }, 
{ "title" : "CNC Beispiel 06: Path3D mit SoftMotion CNC verwenden ", 
"url" : "_sm_example_cnc_6.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC Beispiel 06: Path3D mit SoftMotion CNC verwenden ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC06_File_3DPath.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel erweitert das vorangegangene Beispiel CNC05_File . Es zeigt eine mögliche Verwendung des Visualisierungselements Path3D mit CODESYS SoftMotion...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC06_File_3DPath.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel erweitert das vorangegangene Beispiel CNC05_File . Es zeigt eine mögliche Verwendung des Visualisierungselements Path3D mit CODESYS SoftMotion CNC. Programm CNC_File zu CNC_File_Path3D erweitern Öffnen Sie den Bibliotheksverwalter und fügen Sie die Bibliothek SM3_CNC_Visu hinzu. Legen Sie eine Instanz von SMC_PathCopierFile in CNC_PreparePath an und rufen Sie sie zu Beginn der Bahnverarbeitung auf ( iState=0 ). Programmierung: Ersetzen Sie in der Visualisierung Visualization die zuvor verwendete grafische Anzeige der Position durch das Element Path3D . Ändern Sie die Eigenschaften des Elements Path3D : Bahnbeschreibung → Bahndaten(VisuStruct3DTrack) : CNC_prepare_path.pcf.vs3dt Fügen Sie das Visualisierungselement Frame ein. Referenzieren Sie die Visualisierung ControlPanel aus der Bibliothek VisuElem3DPath . Dieses Element wird verwendet, um die Kameraposition des Elements zu steuern. Legen Sie in der Deklaration des Programms CNC_PreparePath eine Instanz von VisuStruct3DControl (Bibliothek VisuElem3DPath ) an: vc: VisuStruct3DControl; . Diese Instanz bildet die Datenschnittstelle zwischen dem Path3D-Element und des Kamerasteuerungspanels. Ändern Sie die Eigenschaften des Elements Path3D : Kamerasteuerung → Steuerungsdatenstruktur (VisuStruct3DControl) : CNC_PreparePath.vc Ändern Sie die Eigenschaften des Elements ControlPanel : Referenzierte Visualisierungen → VisuElem3DPath.ControlPanel → vc : CNC_PreparePath.vc Übersetzen, laden und starten Sie die Applikation. Das Path3D-Element zeigt die Bahn an. Sie können die Kameraposition über das Panel steuern. Fügen Sie eine Instanz des Funktionsbausteins SMC_PositionTracker im Programm CNC hinzu. Legen Sie einen Speicher an, um den aktuellen Track, also die zuletzt gefahrenen Positionen, aufzuzeichnen. pt: SMC_PositionTracker; pointbuffer_pt: ARRAY [0..1000] OF VisuStruct3DPathPoint; Fügen Sie einen Aufruf der Instanz ein: SMC_PositionTracker in die Aktion Interpolation CFC: Verknüpfen Sie die Spurdaten mit dem Path3D-Element. Ändern Sie dazu die Eigenschaften des Elements Path3D : Spurbeschreibung → Spurdaten (VisuStruct3DTrack) : CNC.pt.vs3dt Gehen Sie online und starten Sie die Applikation. Das Path3D-Element zeigt die zuletzt interpolierte Spur zusätzlich zur Bahn an. Konfigurieren Sie weitere Eigenschaften von Path3D . Konfigurieren Sie zum Beispiel, dass die bereits verarbeiteten Bahnelemente grau dargestellt werden: Hervorhebung → Hervorhebungsfarbe : Grau Beispielprojekt: \"3D Path Generator\" " }, 
{ "title" : "CNC Beispiel 07: Ausdrücke und Unterprogramme verwenden ", 
"url" : "_sm_example_cnc_7.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC Beispiel 07: Ausdrücke und Unterprogramme verwenden ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC07_Subprogram.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt den Aufruf eines Unterprogramms aus einer CNC-Datei sowie die Verwendung von Ausdrücken in CNC-Fahrbefehlen. In dem Programm CNC werden z...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC07_Subprogram.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt den Aufruf eines Unterprogramms aus einer CNC-Datei sowie die Verwendung von Ausdrücken in CNC-Fahrbefehlen. In dem Programm CNC werden zunächst, wie bei den anderen Beispielen auch, die Antriebe eingeschaltet. Das Programm CNC_PreparePath verwendet den Funktionsbaustein SMC_ReadNCFile2 zum Einlesen der CNC-Datei. SMC_ReadNCFile2 ersetzt den Baustein SMC_ReadNCFile und erweitert ihn um die Unterstützung für Unterprogramme und Ausdrücke. Mit dem Funktionsbaustein SMC_NCInterpreter wird das CNC-Programm CNC2Main.cnc konvertiert. SMC_NCInterpreter ersetzt den Baustein SMC_NCDecoder und erweitert ihn um die Unterstützung für Unterprogramme und Ausdrücke. Das Projekt enthält zwei CNC-Programme: Das Hauptprogramm CNC2Main.cnc und das Unterprogramm CNC2.cnc . Das Hauptprogramm übergibt den Wert 25 im Parameter #RADIUS an das Unterprogramm. Im Unterprogramm wird der Ausdruck X#RADIUS*2 für die Berechnung der Kreisbahn verwendet. Hauptprogramm N0 G01 X$g_x$ Y0 F50 E30 E-30\nN10 G01 X0 Y$g_y$\nN20 CNC2{25}\nN30 G01 X0 Y-200 Unterprogramm SUBPROGRAM CNC2{#RADIUS : LREAL}\nN010 G91\nN020 G02 X#RADIUS*2 Y0 R#RADIUS Z2.5 F100 E-100 E100\nN030 G02 X-#RADIUS*2 Y0 R#RADIUS Z7.5\nEND_SUBPROGRAM " }, 
{ "title" : "CNC-Beispiel 08: Verwendung von Zusatzachsen ", 
"url" : "_sm_example_external_axes_usage.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 08: Verwendung von Zusatzachsen ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC08_AdditionalAxes.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel erweitert das Projekt CNC01_direct.projekt das in CNC-Beispiel 01: OutQueue direkt erzeugen beschrieben ist. Es zeigt die Verwendung von Zu...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC08_AdditionalAxes.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel erweitert das Projekt CNC01_direct.projekt das in CNC-Beispiel 01: OutQueue direkt erzeugen beschrieben ist. Es zeigt die Verwendung von Zusatzachsen. Wie in CNC-Beispiel 01 werden 4 Positionen in der XY-Ebene mit einer definierten Geschwindigkeit und Beschleunigung angefahren. Zusätzlich wird während jeder Bewegung die Zusatzachse A verfahren. Durch das Programm werden auf der Bahn zwei Wegschaltpunkte gesetzt. " }, 
{ "title" : "CNC-Programm im Editor editieren ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4510557821784033079793683298", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 08: Verwendung von Zusatzachsen \/ CNC-Programm im Editor editieren ", 
"snippet" : "Öffnen Sie das Projekt CNC01_direct.project aus dem Installationsverzeichnis von CODESYS . Öffnen Sie im Projekt das CNC-Programm Example . Ergänzen Sie die Fahrbefehle um Positionen für die Zusatzachse A: CNC-Editor N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30 N10 G02 X84.9 Y84.6 A40 R100 H12 L10 N20 G01 X ...", 
"body" : "Öffnen Sie das Projekt CNC01_direct.project aus dem Installationsverzeichnis von CODESYS . Öffnen Sie im Projekt das CNC-Programm Example . Ergänzen Sie die Fahrbefehle um Positionen für die Zusatzachse A: CNC-Editor N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30\nN10 G02 X84.9 Y84.6 A40 R100 H12 L10\nN20 G01 X 6.6 Y25.7 A60 H-1 O0.8\nN30 G03 X54.6 Y49.7 A80 R100 " }, 
{ "title" : "Drive Interface, Steuerungskonfiguration erstellen ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758202758433079807306962", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 08: Verwendung von Zusatzachsen \/ Drive Interface, Steuerungskonfiguration erstellen ", 
"snippet" : "Fügen Sie unterhalb des SoftMotion General Axis Pool einen weiteren virtuellen Antrieb A_Drive ein. Stellen Sie die Parameter wie folgt ein:...", 
"body" : "Fügen Sie unterhalb des SoftMotion General Axis Pool einen weiteren virtuellen Antrieb A_Drive ein. Stellen Sie die Parameter wie folgt ein: " }, 
{ "title" : "IEC-Programm editieren ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758311412833079809057524", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 08: Verwendung von Zusatzachsen \/ IEC-Programm editieren ", 
"snippet" : "Öffnen Sie das CFC-Programm Ipo . Aktivieren Sie den zuvor hinzugefügten Antrieb A_Drive mit dem Funktionsbaustein MC_Power . In diesem Beispiel soll mit der Zusatzachse A eine einfache Orientierungsachse ( A_Drive ) gesteuert werden. Aus diesem Grund ist kein weiterer Transformationsbaustein nötig....", 
"body" : "Öffnen Sie das CFC-Programm Ipo . Aktivieren Sie den zuvor hinzugefügten Antrieb A_Drive mit dem Funktionsbaustein MC_Power . In diesem Beispiel soll mit der Zusatzachse A eine einfache Orientierungsachse ( A_Drive ) gesteuert werden. Aus diesem Grund ist kein weiterer Transformationsbaustein nötig. Die Sollposition des Interpolators entspricht direkt der Sollposition des Antriebs und wird über den Selektor SMC_POSINFO mit dem Funktionsbaustein SMC_ControlAxisByPos übernommen. Die Applikation gewährleistet nicht, dass die Ausgaben des Interpolators stetig sind. Die Position der Zusatzachse endet zum Beispiel an einem anderen Punkt als sie anfängt. Deshalb sollten Sie die Sprungvermeidung ( bAvoidGaps , fGapVelocity , fGapAcceleration , fGapDeceleration ) aktivieren. Danach verbinden Sie den Ausgang bStopIpo mit dem Eingang bEmergency_Stop des Interpolators und den Interpolator-Ausgang iStatus mit den entsprechenden Eingängen der Achskontrollbausteine. Achten Sie bei der Programmierung mit CFC vor allem auch auf die richtige Reihenfolge der Bausteine. " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4584880865328033079813143466", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 08: Verwendung von Zusatzachsen \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie das erstellte Programm und starten sie es. Das Programm führt die CNC-Bewegung aus, sobald der Eingang Execute des Interpolators gesetzt wurde. Wenn das Programm vollständig abgefahren ist, können Sie es durch eine erneute steigende Flanke wieder starten. Beachten Sie während der Ausf...", 
"body" : "Übersetzen Sie das erstellte Programm und starten sie es. Das Programm führt die CNC-Bewegung aus, sobald der Eingang Execute des Interpolators gesetzt wurde. Wenn das Programm vollständig abgefahren ist, können Sie es durch eine erneute steigende Flanke wieder starten. Beachten Sie während der Ausführung des CNC-Programms die Position der Zusatzachse A ( piSetPosition.dA ), die in der Visualisierung des Interpolationsbausteins dargestellt ist. " }, 
{ "title" : "CNC-Beispiel 09: Verwendung der Werkzeuglängenkorrektur ", 
"url" : "_sm_example_tool_correction_usage.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 09: Verwendung der Werkzeuglängenkorrektur ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC09_ToolLengthCorr.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt wie mit Hilfe des Bausteins SMC_ToolLengthCorr die Länge eines Werkzeugs kompensiert werden kann. Für weitere Informationen zum Thema...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC09_ToolLengthCorr.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt wie mit Hilfe des Bausteins SMC_ToolLengthCorr die Länge eines Werkzeugs kompensiert werden kann. Für weitere Informationen zum Thema Werkzeuglängenkorrektur siehe: Vorverarbeitung" }, 
{ "title" : "Applikation ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm458488080921763308005489139", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 09: Verwendung der Werkzeuglängenkorrektur \/ Applikation ", 
"snippet" : "Für das Beispiel wird eine Gantry3-Kinematik zusammen mit einer angehängten Orientierungsachse ( AxisA ) verwendet, die sich um die Z-Achse drehen kann. An der Orientierungsachse ist wiederum ein Werkzeug mit einer Länge von 2 Einheiten in Z-Richtung befestigt. Es soll ein einfaches CNC-Programm ver...", 
"body" : "Für das Beispiel wird eine Gantry3-Kinematik zusammen mit einer angehängten Orientierungsachse ( AxisA ) verwendet, die sich um die Z-Achse drehen kann. An der Orientierungsachse ist wiederum ein Werkzeug mit einer Länge von 2 Einheiten in Z-Richtung befestigt. Es soll ein einfaches CNC-Programm verfahren werden. Dieses ist als externe Datei CNC.cnc im Projekt hinterlegt und kann mit einem Texteditor geöffnet werden. Im CNC-Programm wird zunächst die Werkzeuglängenkorrektur mit Hilfe des G-Codes G43 aktiviert. Die Parameter I , J und K entsprechen dabei dem Versatz in X-, Y- und Z-Richtung. Anschließend werden 3 Punkte in der XY-Ebene angefahren. Bei der Bewegung zum letzten Punkt wird zusätzlich die Zusatzachse A um 90 Grad gedreht. N000 G43 I0 J0 K2 (Activate tool length correction with tool offset X=0 Y=0 Z=2)\nN010 G01 X10 F10 E100 E-100\nN020 G03 Y10 R5N030 G01 X0 A90 Die Applikation besteht aus mehreren Teilen. Im Programm CNC_PreparePath wird das CNC-Programm CNC.cnc als Datei von der Steuerung eingelesen und vorverarbeitet. Im Programm CNC werden zunächst, wie bei den anderen Beispielen auch, die Antriebe eingeschaltet. Anschließend erfolgt die Interpolation des zuvor eingelesenen CNC-Programms. In jedem Zyklus gibt der Interpolator eine Sollposition ( piSetPosition ) und den aktuellen Versatz des Werkzeugs ( adToolLength ) aus. Diese Informationen benötigt der Baustein SMC_ToolLengthCorr , um die angegebene Werkzeuglänge zu kompensieren. Die kompensierte Position wird anschließend noch transformiert und letztlich mit Hilfe der Bausteine SMC_ControlAxisByPos an die Achsen übergeben. Das Programm ist nahezu identisch zu den anderen Beispielen. Lediglich der Baustein SMC_ToolLengthCorr wurde nach dem Interpolator und vor der Transformation eingefügt, um die vom Interpolator ausgegebene Sollposition zu bearbeiten. " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm4590758219934433080059282556", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 09: Verwendung der Werkzeuglängenkorrektur \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie das erstellte Programm und starten Sie es. Das Programm führt die CNC-Bewegung aus, sobald der Eingang CNC_PreparePath.xStart gesetzt wird. Sie können diese Variable in der Applikation oder in der Visualisierung per Klick auf die Schaltfläche Start setzen. Wenn das Programm vollständi...", 
"body" : "Übersetzen Sie das erstellte Programm und starten Sie es. Das Programm führt die CNC-Bewegung aus, sobald der Eingang CNC_PreparePath.xStart gesetzt wird. Sie können diese Variable in der Applikation oder in der Visualisierung per Klick auf die Schaltfläche Start setzen. Wenn das Programm vollständig abgefahren ist, können Sie es durch eine erneute steigende Flanke wieder starten. Beachten Sie während der Ausführung des CNC-Programms die Ausgaben des Interpolators ( piSetPosition , adToolLength ) und die kompensierte Position ( piOut ) des Bausteins SMC_ToolLengthCorr . Bemerkung: Die Drehung von AxisA während der letzten Bewegung des CNC-Programms hat in diesem Beispiel keine (zusätzliche) Auswirkung auf die kompensierte kartesische Position, da das Werkzeug nur einen Versatz in Z-Richtung hat. Wenn Sie den Versatz des Werkzeugs (in der CNC-Datei, auf der Steuerung im Applikationsordner) um eine Komponente in X- und Y-Richtung erweitern, wird die Drehung von AxisA während der letzten Bewegung eine zusätzliche Auswirkung auf die kompensierte Position haben. " }, 
{ "title" : "Auslesen des Zustands des Interpolators ", 
"url" : "_sm_example_state_interpolator.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Auslesen des Zustands des Interpolators ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC13_ReadInterpolatorState.project im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples . Das Beispielprojekt zeigt, wie der Zustand des CNC-Interpolators ausgelesen werden kann. Der Zustand wird verwendet, um die Position der Maschine s...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC13_ReadInterpolatorState.project im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples . Das Beispielprojekt zeigt, wie der Zustand des CNC-Interpolators ausgelesen werden kann. Der Zustand wird verwendet, um die Position der Maschine sowohl in Maschinen- als auch in Decoder-Koordinaten anzuzeigen. " }, 
{ "title" : "Aufbau der Applikation ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234546899564", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Auslesen des Zustands des Interpolators \/ Aufbau der Applikation ", 
"snippet" : "Der Aufbau ist für CNC-Applikationen typisch. In der Hintergrund-Task wird der G-Code eingelesen. In der Bustask wird die Interpolation ausgeführt. Während der Interpolation wird der Funktionsbaustein SMC_ReadAdditionalIpoState aufgerufen. Sobald die Interpolation beginnt, ist der Ausgang Valid TRUE...", 
"body" : "Der Aufbau ist für CNC-Applikationen typisch. In der Hintergrund-Task wird der G-Code eingelesen. In der Bustask wird die Interpolation ausgeführt. Während der Interpolation wird der Funktionsbaustein SMC_ReadAdditionalIpoState aufgerufen. Sobald die Interpolation beginnt, ist der Ausgang Valid TRUE . Die Position des Interpolators, die immer im Maschinenkoordinatensystem (MCS) ausgegeben wird, wird dann mithilfe des aktuellen Decoder-Koordinatensystems (DCS) umgewandelt und in der Visualisierung ausgegeben. SMC_V3_Set(pos_MCS, ipo.piSetPosition.dX, ipo.piSetPosition.dY, ipo.piSetPosition.dZ);\n\nreadState(\n    Enable:= TRUE,\n    ipo:= ipo);\n\nIF readState.Valid THEN\n    SMC_PosInfo_Trf_Inverse(\n        piOut:= piMCS_to_DCS,\n        piIn:= readState.State.DCS,\n        eOriConv:= readState.State.OriConv);\n\n SMC_PosInfo_Trf_Apply(\n        vDst:= pos_DCS,\n        piTrf:= piMCS_to_DCS,\n        vSrc:= pos_MCS,\n        eOriConv:= readState.State.OriConv);\nEND_IF Für weitere Informationen zum Decoder-Koordinatensystem siehe: Koordinatensystem schieben, drehen und skalieren. " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234714771807", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Auslesen des Zustands des Interpolators \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Öffnen Sie die Visualisierung. Starten Sie die Applikation, drücken Sie auf die Schaltfläche Start der Visualisierung. Sie können die Bewegung der X- und Y-Koordinate im MCS und DCS nachvollziehen....", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Öffnen Sie die Visualisierung. Starten Sie die Applikation, drücken Sie auf die Schaltfläche Start der Visualisierung. Sie können die Bewegung der X- und Y-Koordinate im MCS und DCS nachvollziehen. " }, 
{ "title" : "Realisierung eines Bahnvorverarbeitungsbausteins ", 
"url" : "_sm_example_cnc14_path_preprocessing.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Realisierung eines Bahnvorverarbeitungsbausteins ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC14_PathPreprocessing.project im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples . Das Beispielprojekt zeigt, wie ein neuer Bahnvorverarbeitungsbaustein umgesetzt werden kann. Die Bahnvorverarbeitung dient allgemein dazu, die vom G-Co...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC14_PathPreprocessing.project im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples . Das Beispielprojekt zeigt, wie ein neuer Bahnvorverarbeitungsbaustein umgesetzt werden kann. Die Bahnvorverarbeitung dient allgemein dazu, die vom G-Code eingelesene Bahn zu verändern. Dadurch können Funktionen wie Werkzeugradiuskorrektur oder Eckverschleifung umgesetzt werden. Es ist aber auch möglich, spezifische Funktionen für eine bestimmte Maschine oder Anwendung als Bahnvorverarbeitungsbaustein einzubinden. Für weitere Informationen zur Bahnvorverarbeitung siehe: Bahnvorverarbeitung und Queue-Größen. Für ein Beispiel, wie Sie einen Bahnvorverarbeitungsbaustein verwenden siehe CNC-Beispiel 03: Bahnvorverarbeitung online durchführen. " }, 
{ "title" : "Begrenzung der Tangentenänderung ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234576416031", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Realisierung eines Bahnvorverarbeitungsbausteins \/ Begrenzung der Tangentenänderung ", 
"snippet" : "Im Beispiel wird eine 2D-Schneideapplikation betrachtet. Mit einem Messer soll entlang einer durch G-Code vorgegebenen Bahn geschnitten werden. Die Transformation SMC_TRAFO_GantryCutter2 wird verwendet, um den Winkel des Messers basierend auf der aktuellen Tangente der Bahn zu ermitteln. Die Herausf...", 
"body" : "Im Beispiel wird eine 2D-Schneideapplikation betrachtet. Mit einem Messer soll entlang einer durch G-Code vorgegebenen Bahn geschnitten werden. Die Transformation SMC_TRAFO_GantryCutter2 wird verwendet, um den Winkel des Messers basierend auf der aktuellen Tangente der Bahn zu ermitteln. Die Herausforderung ist, dass sich das Messer nicht zu schnell drehen darf, da sonst der Schnitt nicht sauber ausgeführt wird. Die Begrenzung der Drehgeschwindigkeit des Messers ist im Beispielprojekt über den neu angelegten Bahnvorverarbeitungsbaustein LimitTangentVelocity gelöst. Er verändert die Vorschubgeschwindigkeit auf der Bahn so, dass die Änderungsgeschwindigkeit der Tangente einen konfigurierbaren Maximalwert nicht überschreitet. Als G-Code wird ein einfaches Rechteck vorgegeben, bei dem die Ecken verschliffen werden. Im Trace ist das Ergebnis der Ausführung zu sehen: In orange wird die Geschwindigkeit der C-Achse dargestellt, die der Drehgeschwindigkeit des Messers entspricht. Sie wird wie vorgegeben auf 45°\/s begrenzt. " }, 
{ "title" : "Aufbau der Applikation ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234546899564", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Realisierung eines Bahnvorverarbeitungsbausteins \/ Aufbau der Applikation ", 
"snippet" : "Der Aufbau ist für CNC-Applikationen typisch. In der Hintergrundtask wird der G-Code eingelesen, hier findet auch die Bahnvorverarbeitung statt. In der Bustask wird die Interpolation ausgeführt. Der Funktionsbaustein LimitTangentVelocity zeigt die notwendigen Schritte und Zustände für einen Bahnvorv...", 
"body" : "Der Aufbau ist für CNC-Applikationen typisch. In der Hintergrundtask wird der G-Code eingelesen, hier findet auch die Bahnvorverarbeitung statt. In der Bustask wird die Interpolation ausgeführt. Der Funktionsbaustein LimitTangentVelocity zeigt die notwendigen Schritte und Zustände für einen Bahnvorverarbeitungsbaustein. Das Grundprinzip ist, dass der Funktionsbaustein Bahnelemente (vom Typ SMC_GEOINFO ) aus der Eingangs-Queue ( poqDataIn ) einliest, bearbeitet und dann in die Ausgangs-Queue ( poqDataOut ) schreibt. Die Elemente werden aus der Eingangs-Queue entfernt. Die Logik zur Veränderung der Vorschubgeschwindigkeit findet sich von Zeile 102 - 138. Die Hilfsfunktion ComputeMaxCurvature berechnet die maximale Krümmung, die auf einem gegebenen Bahnelement auftreten kann. \/\/ Our velocity limitation comes here. This modifies an element from the\n\/\/ input queue and copies the modified element to the output queue.\n\/\/ Finally, the element is removed from the input queue\n\nm_geo := pgeo^; \/\/ Copy the element\n \/\/ Note: the feature flags set in the G-Code with G38\/G39 can be queried\n \/\/ by reading pgo^.dwFeatureFlags, like this:\n IF (SHR(m_geo.dwFeatureFlags, featureFlag) AND 1) = 1 THEN\n     \/\/ feature is turned on\n\n     ok := ComputeMaxCurvature(m_geo, kappa=> kappa_max);\n     IF NOT ok THEN\n         \/\/ Curvature cannot be computed\n         m_state := STATE_ERROR;\n         ErrorID := SMC_INVALID_PARAMETER;\n         OnExit();\n         RETURN;\n     END_IF\n\n     \/\/ Compute maximum allowed path velocity based on maximum curvature\n     \/\/ and maximum allowed angular velocity\n     IF kappa_max = 0 THEN\n         \/\/ No curvature, no limitation necessary\n         vel := m_geo.dVel;\n     ELSE\n         vel := m_maxAngularVelocity_rad \/ kappa_max;\n     END_IF\n\n     IF velMin < 0 OR vel < velMin THEN\n         velMin := vel;\n     END_IF\n\n     \/\/ Set new maximum velocity for the element\n     m_geo.dVel := MIN(m_geo.dVel, vel);\n ELSE\n     \/\/ feature is turned off\n END_IF " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234584108811", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Realisierung eines Bahnvorverarbeitungsbausteins \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie die Applikation. Öffnen Sie den Trace und laden ihn auf die Steuerung. Schreiben Sie den Wert TRUE in die Variablen Path.bExecute und PLC_PRG.bStart . Sie können die Abarbeitung des G-Codes im Trace nachvollziehen....", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie die Applikation. Öffnen Sie den Trace und laden ihn auf die Steuerung. Schreiben Sie den Wert TRUE in die Variablen Path.bExecute und PLC_PRG.bStart . Sie können die Abarbeitung des G-Codes im Trace nachvollziehen. " }, 
{ "title" : "Vorverarbeitung von großen G-Code Dateien ", 
"url" : "_sm_example_large_c_code.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Vorverarbeitung von großen G-Code Dateien ", 
"snippet" : "Das Beispielprojekt CNC15_LargeGCode.project finden Sie im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Beispielprojekt zeigt, wie große G-Code-Dateien verarbeitet werden können. Da sehr große Dateien insbesondere als Ausgabe von CAD\/CAM-Systemen vorkommen, wird di...", 
"body" : "Das Beispielprojekt CNC15_LargeGCode.project finden Sie im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Beispielprojekt zeigt, wie große G-Code-Dateien verarbeitet werden können. Da sehr große Dateien insbesondere als Ausgabe von CAD\/CAM-Systemen vorkommen, wird dieser Fall beispielhaft gezeigt. CAD\/CAM-Systeme erzeugen oftmals G-Code-Dateien mit mehreren hunderttausend Zeilen. Diese bestehen aus sehr kurzen Geradenabschnitten ( G1 ), typischerweise in der Größenordnung von 100 Mikrometern bis zu einem Millimeter. Diese kurzen Geradenabschnitte tasten die Kontur des Werkstücks ab. Sie bilden keine glatte Bahn, zwischen den Geradenabschnitten springt in der Regel die Tangente. Das Beispiel zeigt, wie solch große Dateien effizient und mit konstantem Speicherbedarf eingelesen werden können und wie ein glatter Geschwindigkeitsverlauf auf einer Bahn erreicht werden kann, die aus so vielen kurzen Geradenabschnitten besteht. Die Originalkontur des Werkstücks wird während der Vorverarbeitung des G-Codes rekonstruiert. " }, 
{ "title" : "Aufbau der Applikation ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231424931037", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Vorverarbeitung von großen G-Code Dateien \/ Aufbau der Applikation ", 
"snippet" : "Der Aufbau ist für CNC-Applikationen typisch. In der Hintergrund-Task ( PathTask ) wird der G-Code eingelesen, hier findet auch die Bahnvorverarbeitung statt. In der Bustask ( MainTask ) wird die Interpolation ausgeführt....", 
"body" : "Der Aufbau ist für CNC-Applikationen typisch. In der Hintergrund-Task ( PathTask ) wird der G-Code eingelesen, hier findet auch die Bahnvorverarbeitung statt. In der Bustask ( MainTask ) wird die Interpolation ausgeführt. " }, 
{ "title" : "Einlesen großer Dateien ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425324995", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Vorverarbeitung von großen G-Code Dateien \/ Einlesen großer Dateien ", 
"snippet" : "Damit die Latenz zu Beginn der Verarbeitung des G-Codes kurz ist, wird eine Schleife in der Hintergrundtask verwendet.  Als Abbruchbedingung wird der Einfachheit halber ein Zähler verwendet. Je nach Applikation, G-Code und Leistungsfähigkeit der SPS können hier andere Abbruchbedingungen wie beispiel...", 
"body" : "Damit die Latenz zu Beginn der Verarbeitung des G-Codes kurz ist, wird eine Schleife in der Hintergrundtask verwendet.  Als Abbruchbedingung wird der Einfachheit halber ein Zähler verwendet. Je nach Applikation, G-Code und Leistungsfähigkeit der SPS können hier andere Abbruchbedingungen wie beispielsweise ein Timer sinnvoll sein. Die Schleife wird vor Erreichen dieser Abbruchbedingung beendet, wenn die Path-Queue gefüllt ist. \/\/ Set this value depending on your other tasks, PLC performance, and G-Code\ncounter := 25;\n\nWHILE counter > 0 AND\n      (poqDataOut = 0 OR_ELSE (NOT poqDataOut^.bFull AND NOT poqDataOut^.bEndOfList))\nDO\n     <Read G-Code and process it>\n\n     counter := counter - 1;\nEND_WHILE Durch das Pipelining bei der Vorverarbeitung können auch sehr große G-Code-Dateien mit kleinem, konstantem Speicherbedarf eingelesen werden. Die Queue-Größen sind lediglich so groß gewählt, dass die jeweiligen Bausteine ausreichend große Vorausschau haben. Die Ausgangsqueue des SMC_NCInterpreters ist zugleich die Eingangsqueue von SMC_SmoothMerge . Für die Ausgangsqueue werden 128+3 Elemente reserviert. 3 ist eine Reserve der SMC_OutQueue , 128 bleiben zur Verwendung als Vorausschau für SMC_SmoothMerge . SMC_SmoothMerge fasst maximal 128 kurze Geradenabschnitte zu einem Spline zusammen. Die Ausgangsqueue von SMC_SmoothMerge ist zugleich die Eingangsqueue von SMC_SmoothPath . SMC_SmoothPath benötigt als Vorausschau mindestens 2 Elemente, dazu noch eine Reserve von 3 Elementen. Wenn M-Funktionen zwischen zwei verschliffenen Elementen stehen, dann werden entsprechend der Anzahl der M-Funktionen mehr Elemente benötigt. Die Ausgangsqueue von SMC_SmoothMerge ist zugleich die Eingangsqueue des SMC_Interpolators . Eine Vorausschau von 100 Elementen ist für die meisten Applikationen geeignet. Für weitere Informationen siehe Bahnvorverarbeitung und Queue-Größen. \/\/\/ Buffer of the interpreter, lookahead for SMC_SmoothMerge\naBufIp : ARRAY[0..130] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothMerge\naBufSmm : ARRAY[0..15] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothPath, lookahead for SMC_Interpolator\naBufSmp : ARRAY[0..99] OF SMC_GeoInfo; " }, 
{ "title" : "Vorverarbeitung der Geradenabschnitte ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425764624", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Vorverarbeitung von großen G-Code Dateien \/ Vorverarbeitung der Geradenabschnitte ", 
"snippet" : "Der Baustein SMC_SmoothMerge sorgt für einen glatten Geschwindigkeitsverlauf auf den vielen sehr kurzen Geradenabschnitten. Er fasst möglichst viele aufeinanderfolgende Geradenabschnitte zu einem Spline zusammen, unter Einhaltung von vorgegebenen Toleranzen. Im Beispiel wird eine maximale Abweichung...", 
"body" : "Der Baustein SMC_SmoothMerge sorgt für einen glatten Geschwindigkeitsverlauf auf den vielen sehr kurzen Geradenabschnitten. Er fasst möglichst viele aufeinanderfolgende Geradenabschnitte zu einem Spline zusammen, unter Einhaltung von vorgegebenen Toleranzen. Im Beispiel wird eine maximale Abweichung von 0.1 mm in X und Y erlaubt ( PARAMETERS.piMaxDifference ). Die Abbildungen zeigen die schrittweise Verarbeitung: Einlesen der kurzen Geradenabschnitte Zusammenfassen mehrerer Geradenabschnitte zu Splines mit SMC_SmoothMerge . Verschleifen zwischen den Splines mit SMC_SmoothPath , da die Splines wie oben ersichtlich nicht tangential aneinander anschließen. " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425998344", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Vorverarbeitung von großen G-Code Dateien \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Öffnen Sie den Trace und laden Sie ihn auf die Steuerung. Starten Sie die Applikation. Sie können die Abarbeitung des G-Codes im Trace nachvollziehen....", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Öffnen Sie den Trace und laden Sie ihn auf die Steuerung. Starten Sie die Applikation. Sie können die Abarbeitung des G-Codes im Trace nachvollziehen. " }, 
{ "title" : "CNC-Beispiel 16: Restweg löschen (G31) ", 
"url" : "_sm_example_cnc_16.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 16: Restweg löschen (G31) ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC16_G31.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Beispielprojekt zeigt, wie die Funktion \"Restweg Löschen\" verwendet wird. Im Beispiel fährt die Maschine in X-Richtung bis eine Lichtschranke bei X=50 durchfahren...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC16_G31.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Beispielprojekt zeigt, wie die Funktion \"Restweg Löschen\" verwendet wird. Im Beispiel fährt die Maschine in X-Richtung bis eine Lichtschranke bei X=50 durchfahren wird. Sowie die Lichtschranke erreicht ist, muss die Maschine anhalten. Der verbleibende G-Code wird von dieser Position aus weitergeführt. " }, 
{ "title" : "Aufbau der Applikation ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224424924168", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 16: Restweg löschen (G31) \/ Aufbau der Applikation ", 
"snippet" : "Der Aufbau ist für CNC-Applikationen typisch. In der Hintergrund-Task ( PathTask ) wird der G-Code eingelesen. In dieser Task findet auch die Bahnvorverarbeitung statt. In der Bustask ( MainTask ) wird die Interpolation ausgeführt. Folgender G-Code wird verwendet. In Satz N10 wird per Eilgang nach X...", 
"body" : "Der Aufbau ist für CNC-Applikationen typisch. In der Hintergrund-Task ( PathTask ) wird der G-Code eingelesen. In dieser Task findet auch die Bahnvorverarbeitung statt. In der Bustask ( MainTask ) wird die Interpolation ausgeführt. Folgender G-Code wird verwendet. In Satz N10 wird per Eilgang nach X = 20 verfahren, dann wird mit G31 (Restweg löschen) nach X = 100 verfahren, anschließend in Satz N30 mit einer Linearbewegung nach X = 20, Y = 50 . N10 G0 X20 F100 E1000 E-1000\nN20 G31 X100\nN30 G1 X20 Y50 Für die Funktion \"Restweg Löschen\" ist insbesondere das Zusammenspiel zwischen Interpolator und Interpreter wichtig. Der Interpreter dekodiert den G-Code und erzeugt für Satz N20 eine Gerade von X=20 bis X=100 . Danach stoppt er das Dekodieren. Der Interpolator führt die Linearbewegung aus und gibt gleichzeitig am Ausgang udiActProbe die Probe-Nummer aus. Für G31 ist die Probe-Nummer immer 1. In der Applikation wird der Interpolator mit bQuick_Stop gestoppt, sobald der Antrieb die Position X = 50 überfährt. (Dies simuliert die Lichtschranke.) In der Bustask wird die aktuelle Position der Maschine mit dem Funktionsbaustein SMC_SetInterpreterStartPosition laufend kopiert. In der Pathtask wird die Startposition dem Eingang SMC_NCInterpreter.piStartPosition zugewiesen: inter(\n    sentences:= read.sentences,\n    bExecute:= read.bExecute,\n    nSizeOutQueue:= SIZEOF(bufIpo),\n    pbyBufferOutQueue:= ADR(bufIpo),\n    piStartPosition:= Main.setStart.StartPos); Sobald der Interpolator gestoppt ist, wird der G31-Befehl mithilfe des Eingangs bAcknProbe quittiert. In einer realen Applikation sollte an dieser Stelle noch zusätzlich geprüft werden, ob die Achsen auch tatsächlich an der Stop-Position angekommen sind. Dazu kann der Baustein SMC_InPosition verwendet werden. Dies führt dazu, dass der Interpreter die Dekodierung wieder aufnimmt, aber mit der aktualisierten Startposition, so dass der folgende Satz N30 von der Position X = 55.5 gestartet wird. Im Trace lässt sich dieser Ablauf nachverfolgen. Die Zahlen in Klammern verweisen auf die jeweiligen Schritte im oben skizzierten Ablauf. " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224425037675", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 16: Restweg löschen (G31) \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Öffnen Sie den Trace und laden ihn auf die Steuerung. Starten Sie die Applikation und öffnen Sie die Visualisierung....", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Öffnen Sie den Trace und laden ihn auf die Steuerung. Starten Sie die Applikation und öffnen Sie die Visualisierung. " }, 
{ "title" : "CNC-Beispiel 17: G-Code aus String lesen ", 
"url" : "_sm_example_cnc_17.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 17: G-Code aus String lesen ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC17_ReadGCodeFromStrings.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Beispielprojekt zeigt, wie G-Code mit Hilfe von SMC_StringStream2 von einem String gelesen werden kann. Das Beispiel dient als Startpunkt und kan...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC17_ReadGCodeFromStrings.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Beispielprojekt zeigt, wie G-Code mit Hilfe von SMC_StringStream2 von einem String gelesen werden kann. Das Beispiel dient als Startpunkt und kann dazu dienen, G-Code auch von anderen Quellen einzulesen, zum Beispiel über Netzwerkkommunikation (Sockets). In diesem Fall muss ein Funktionsbaustein umgesetzt werden, der die Schnittstelle SMC_ITextStream implementiert und den Text beispielsweise von einem Socket liest. Das ist analog dazu, wie SMC_StringStream2 diese Schnittstelle implementiert um den G-Code von einem String zu lesen. " }, 
{ "title" : "Aufbau der Applikation ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224424924168", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 17: G-Code aus String lesen \/ Aufbau der Applikation ", 
"snippet" : "Der Aufbau ist für CNC-Applikationen typisch. In der Hintergrundtask ( PathTask ) wird der G-Code eingelesen, hier findet auch die Bahnvorverarbeitung statt. In der Bustask wird die Interpolation ausgeführt. Im Programm Path wird der Baustein SMC_ReadNCFromStream verwendet um den G-Code einzulesen. ...", 
"body" : "Der Aufbau ist für CNC-Applikationen typisch. In der Hintergrundtask ( PathTask ) wird der G-Code eingelesen, hier findet auch die Bahnvorverarbeitung statt. In der Bustask wird die Interpolation ausgeführt. Im Programm Path wird der Baustein SMC_ReadNCFromStream verwendet um den G-Code einzulesen. Aus technischen Gründen wird diesem nicht nur ein Stream vom Typ SMC_StringStream2 übergeben, sondern ein Array, dessen Größe vom Parameter SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPTH abhängt. Der erste Stream im Array wird für das Hauptprogramm verwendet, die weiteren für mögliche Unterprogrammaufrufe. Das Hauptprogramm wird zu Beginn in den ersten Stream des Arrays geladen: \/\/ Load G-Code into first stream\naStringStream[0].Init(sProgramName) ;\naStringStream[0].AppendData(sGCode) ;\naStringStream[0].SetEndOfData() ; Damit ist alles vorbereitet, um gewöhnliche G-Code-Programme einzulesen. Das Beispiel zeigt zusätzlich noch, wie auch Unterprogrammaufrufe unterstützt werden können. Dazu ist es nötig, einen Funktionsbaustein zu erstellen, der die Schnittstelle SMC_INCLookup implementiert. Dieser Funktionsbaustein ist dafür verantwortlich, den G-Code eines Unterprogramms zurückzugeben, wenn er von SMC_ReadNCFromStream benötigt wird. Die Methode Lookup erhält dazu den Namen des Unterprogramms und initialisiert einen hereingereichten Stream mit dem G-Code: METHOD LookUp : SMC_ERROR\nVAR_IN_OUT CONSTANT\n    programName : STRING;\nEND_VAR\nVAR_INPUT\n    stream : SMC_ITextStream;\nEND_VAR\nVAR\n    i : UDINT ;\n    pStringStream : POINTER TO SMC_StringStream2 ;\nEND_VAR Im Beispiel wird dafür ein Array von Unterprogrammen durchsucht. Das Array wird im Programm Path als VAR_INPUT definiert: \/\/ The table of subprograms.\n aSubs : ARRAY[0..0] OF SubProgram := [\n            (stName := 'SUB1',\n             stContent := '\nSUBPROGRAM SUB1{#p1 : LREAL, #p2 : LREAL, #p3 : LREAL}\nN10 G1 X#p1\nN20 G1 X#p2\nN30 G1 X#p3\nEND_SUBPROGRAM')\n        ] ; In Lookup wird durch das Array iteriert, bis ein Unterprogramm mit passendem Namen gefunden wird: i := 0 ;\nWHILE i < nNumSPs DO\n IF psp[i].stName = programName THEN\n IF NOT __QUERYPOINTER(stream, pStringStream) OR_ELSE\n pStringStream = 0\n THEN\n \/\/ A stream of the wrong type has been passed by SMC_ReadNCFromStream.\n LookUp := SMC_CNC_INTERNAL_ERROR ;\n ELSE\n pStringStream^.Init(sName := psp[i].stName) ;\n LookUp := pStringStream^.AppendData(psp[i].stContent) ;\n pStringStream^.SetEndOfData() ;\n END_IF\n RETURN ;\n END_IF\n\n i := i + 1 ;\nEND_WHILE\n \n\/\/ No subprogram with name programName has been found in the array psp.\nLookUp := SMC_RNCF_SUBPROGRAM_FILE_NOT_FOUND ; " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224425037675", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 17: G-Code aus String lesen \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Öffnen Sie die Visualisierung. Drücken Sie auf Start um die G-Code-Abarbeitung zu starten....", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Öffnen Sie die Visualisierung. Drücken Sie auf Start um die G-Code-Abarbeitung zu starten. " }, 
{ "title" : "CNC-Beispiel 10: Dynamische CNC-Bahn programmieren ", 
"url" : "_sm_example_dynamic_path.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ CNC-Beispiel 10: Dynamische CNC-Bahn programmieren ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CNC10_DynamicPath.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . In diesem Beispiel wird gezeigt, wie eine CNC-Bahn direkt in der Applikation zur Laufzeit erzeugt werden kann, also nicht aus einem CNC-Programmobjekt oder ei...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CNC10_DynamicPath.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . In diesem Beispiel wird gezeigt, wie eine CNC-Bahn direkt in der Applikation zur Laufzeit erzeugt werden kann, also nicht aus einem CNC-Programmobjekt oder einer Datei mit G-Code gespeist wird. Wenn ein solches herkömmliches CNC-Programm übersetzt wird, werden die Bahndaten in einer Datenstruktur mit Datentyp SMC_CNC_Data gespeichert. Diese internen Daten werden dann abhängig vom Übersetzungsmodus ( SMC_CNC_REF oder SMC_OutQueue ) in spezielle globale Datenstrukturen übersetzt. Beim Übersetzungsmodus SMC_CNC_REF werden die Daten in einem Array von Elementen des Typs SMC_GEOINFO gespeichert. Üblicherweise wird das Array im Applikationscode an die Funktionsbaustein-Instanz SMC_NCDecoder übergeben. Zur Laufzeit werden die Daten dort decodiert und in eine globale Datenstruktur des Typs SMC_OUTQUEUE ablegt. Anschließend können Bahnvorverarbeitungsbausteine aufgerufen werden. Beim Übersetzungsmodus SMC_OutQueue wird direkt eine globale Datenstruktur ( SMC_OUTQUEUE ) erzeugt, die im Applikationscode an den Interpolator (FB-Instanz SMC_Interpolator ) übergeben wird. Der Funktionsbaustein SMC_NCDecoder wird nicht aufgerufen. Beim Übersetzungsmodus FILE werden die Daten in einer Datei gespeichert. Die Daten sind dabei als Array von Elementen des Typs SMC_GEOINFO abgelegt und entsprechen den Daten, die beim Übersetzungsmodus SMC_CNC_REF erzeugt werden. Statt die CNC-Bahn grafisch zu programmieren, können Sie einen Applikationscode programmieren, der zur Laufzeit eine Datenstruktur des Typs SMC_OUTQUEUE instanziert und ihr Werte zuweist. Sie programmieren eine CNC-Bahn, die zur Laufzeit dynamisch erzeugt wird. Die Datenstruktur können Sie dann an weitere Funktionsbaustein-Instanzen (beispielsweise an Bahnvorverarbeitungsbausteine oder an den Funktionsbaustein SMC_Interpolator ) übergeben. Programmieren Im Installationsverzeichnis von CODESYS finden Sie das Beispielprojekt CNCDynamicPath . Das Beispielprojekt wurde aus dem Projekt CNConline entwickelt. Es enthält statt der grafisch programmierten Bahn Example das Programm Path . Es erzeugt dynamisch eine Datenstruktur mit Typ SMC_OUTQUEUE . Deklaration: Deklarieren Sie eine Datenstruktur des Typs SMC_OUTQUEUE . Die Datenstruktur enthält die CNC-Bahndaten und wird dynamisch gefüllt. Beispiel: QUEUE Allozieren Sie Speicher für die Bahn mit der gewünschten Anzahl an SMC_GEOINFO -Elementen. Beispiel: BUF Deklarieren Sie eine Variable des Typs SMC_GEOINFO mit einem Initialschritt. Beispiel: GEO Implementierung: Ein Arrayelement des Datenyps SMC_GEOINFO entspricht einem Bahnelement im CNC-Code. Für jedes Element müssen folgende Schritte durchgeführt werden, um es der SMC_OUTQUEUE hinzuzufügen: Jedes Arrayelement verfügt über eine Startposition, die der Endposition des vorhergehenden Arrayelements entspricht. Beispiel: GEO.piStartPos.dX := 0; oder GEO.piStartPos := GEO.piDestPos; Bestimmen Sie für jedes Arrayelement einen Bewegungstyp. Beispiel: GEO.iMoveType := CCLW; oder GEO.iMoveType := LIN; Setzen Sie die Parameter des Bewegungstypen. Das ist nicht bei allen Bewegungstypen erforderlich. Beispiel: Bei einem Kreisbogen (Bewegungstyp CCLW) ist das Setzen der folgenden Positionen erforderlich: geoinfo_A[i].dP1 := 200; geoinfo_A[i].dP2 := 100; geoinfo_A[i].dP3 := 50; geoinfo_A[i].dT1 := 0; geoinfo_A[i].dT2 := 90; Fügen Sie die Berechnung der Endposition ein. SMC_CalcEndPnt(ADR(GEO)); Fügen Sie die Berechnung der Länge des Objekts ein. SMC_CalcLengthGeo(ADR(GEO)); Speichern Sie das Objekt in QUEUE : SMC_AppendObj(POQ:=ADR(QUEUE), PGI:=ADR(GEO)); Wenn die Bahn vollständig erstellt ist, muss die Endmarke gesetzt werden: QUEUE.bEndOfList := TRUE; Wenn anschließend ein Bahnvorverarbeitungsbaustein aufgerufen wird, ist es erforderlich das Anfangs- oder Endbit für InternMark zu setzen. Beispiel CNC-Bahn mit 2 Bahnelementen In diesem Beispiel sind die Arrays mit den x\/y-Positionen nicht definiert. Wenn das wie beschrieben ein Beispiel mit zwei Bahnelementen sein soll, müssten diese Arrays je zwei Elemente haben. Aus dem Beispielprojekt entlehnt also z. B.: xp:ARRAY[1..2] OF REAL:= [100,50]; yp:ARRAY[1..2] OF REAL:= [0,100]; PROGRAM Path\nVAR\n iState : INT;\n QUEUE : SMC_OUTQUEUE;\n BUF : ARRAY[0..49] OF SMC_GEOINFO;\n \/\/ Memory allocation\n GEO : SMC_GEOINFO:=(dT1:=0, dT2:=1, dToolRadius:=0, dVel:=100, dVel_End:=100, dAccel:=200, dDecel:=500, iObj_Nr:=0);\n \/\/ Initial path element\n n : INT := 0;\n QUEUE.nSize := SIZEOF(BUF);\nEND_VAR\n\nCASE iState OF\n0:\n QUEUE.pbyBuffer := ADR(BUF[0]);\n \/\/ Initialize QUEUE\n SMC_SetQueueCapacity(ADR(QUEUE), SIZEOF(BUF));\n iState := iState + 1;\n\n1:\n \/\/ Fill QUEUE\n WHILE NOT QUEUE.bFull DO\n \/\/ When QUEUE is full, wait until it has been processed by the following FBs\n n := n + 1;\n GEO.iSourceLine_No := n;\n GEO.piStartPos := GEO.piDestPos;\n \/\/ Copying last destination\n GEO.iMoveType := LIN;\n \/\/ Generating linear movement\n GEO.iObjNo := GEO.iObjNo + 1;\n \/\/ Calculating number\n GEO.piDestPos.dX := xp[n];\n \/\/ Generatint position\n GEO.piDestPos.dY := yp[n];\n SMC_CalcLengthGeo(pg := ADR(GEO));\n \/\/ Calculating length of object with the help of the standard function\n SMC_AppendObj(poq:=ADR(QUEUE), pgi:=ADR(GEO));\n \/\/ Appending object to QUEUE\n IF n = SIZEOF(xp)\/SIZEOF(xp[1]) THEN\n \/\/ All target positions processed\n QUEUE.bEndOfList := TRUE;\n n := 0;\n iState := 2;\n EXIT;\n END_IF\n END_WHILE\n\n2:\n \/\/Done\n ;\nEND_CASE\n\nCheckVel(bExecute:=TRUE , poqDataIn:=ADR(queue)); \/\/ Preprocessing Wenn die Datenstruktur SMC_OUTQUEUE mit SMC_GEOINFO -Daten gefüllt und das Datenstrukturelement bFULL = TRUE gesetzt wurde, dann ist ein weiteres Zuweisen von SMC_GEOINFO -Daten nicht ratsam. Denn in diesem Fall wird zur Laufzeit die Erstellung der Bahn unterbrochen, bis das erste Element der SMC_OUTQUEUE -Datenstruktur im Interpolator verarbeitet ist. Erst dann wird ein weiteres Element angehängt. Vermeiden Sie diese Unterbrechung, indem Sie ausreichend großen Speicher allozieren. Siehe Variable BUF . Wenn die Datenstruktur SMC_OUTQUEUE nach der ersten Ausführung wieder aufgefüllt wird, müssen der Interpolator und alle vorverarbeitenden Funktionsbausteine (beispielsweise SMC_CheckVelocities ) durch eine steigende Flanke an Execute neu gestartet werden. " }, 
{ "title" : "Satzvorlauf verwenden ", 
"url" : "_sm_example_using_block_search.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Satzvorlauf verwenden ", 
"snippet" : "Ein Satzvorlauf ermöglicht die Fortsetzung der Interpolation nach einer Unterbrechung. Dabei wird zuerst die Stoppposition angefahren und ab dieser Position die Bahn unverändert verfahren. Dazu müssen das Programm, das die Interpolation durchführt, und das Programm, das die Bahnvorverarbeitung durch...", 
"body" : "Ein Satzvorlauf ermöglicht die Fortsetzung der Interpolation nach einer Unterbrechung. Dabei wird zuerst die Stoppposition angefahren und ab dieser Position die Bahn unverändert verfahren. Dazu müssen das Programm, das die Interpolation durchführt, und das Programm, das die Bahnvorverarbeitung durchführt, erweitert werden. Beispiel Ein abgebrochener Fräskopf führt zu einem Stopp der Fahrt. Nach einer Reparatur kann mit Satzvorlauf die Bahn weiterverfahren werden. Erweitern der Applikation um Funktionsbausteininstanz in der Interpolationstask, die die Vorlaufposition speichert Funktionsbausteininstanz in der Bahntask, die ein Bahnelement verkürzt Für weitere Informationen siehe: SMC_BlockSearchSavePos, SMC_BlockSearchPos und SMC_BlockSearch Verwenden des Satzvorlaufs Eine Instanz des Funktionsbausteins SMC_BlockSearch muss in der gleichen Task wie die übrige Bahnvorverarbeitung aufgerufen werden, typischerweise direkt vor dem Funktionsbaustein SMC_CheckVelocities . Wenn an bExecute eine steigende Flanke anliegt, wird ein Satzvorlauf ausgeführt. Nach dem Start wird die gespeicherte Position angefahren und ab dieser Position die Bahn unverändert gefahren. Deklarieren Sie in dem Programm, das die Bahnvorverarbeitung durchführt, eine Instanz des Funktionsbausteins SMC_BlockSearch . bs: SMC_BlockSearch; Implementieren Sie das Triggern des Eingangs bExecute der Instanz von SMC_BlockSearch . Als Eingang epos des Funktionsbausteins SMC_BlockSearch muss die zuvor mittels des Funktionsbausteins SMC_BlockSearchSavePos gespeicherte Position übergeben werden. Beispiel: Satzvorlauf in der Bahnvorverarbeitung PROGRAM CNC_PreparePath\n...\nVAR\n bs: SMC_BlockSearch;\nEND_VAR\n...\nbs(\n ePos:=CNC.bssp.ePos ,\n bExecute:=rncf.bExecuteDecoder ,\n bAbort:= ,\n bAppend:= ,\n poqDataIn:=ncd.poqDataOut ,\n bStartFromSavedPos:=CNC.bssp.bPositionStored ,\n nSizeOutQueue:=SIZEOF(agiBufBlockSearch) ,\n pbyBufferOutQueue:=ADR(agiBufBlockSearch) ,\n bDone=> ,\n bBusy=> ,\n bError=> ,\n wErrorID=> ,\n poqDataOut=> ); Der Eingang bStartFromSavedPos kann auch mit einer Steuervariablen beschaltet werden. Die Steuervariable kann nach einer Unterbrechung geschaltet werden, um an der letzten gespeicherten Position wieder fortzufahren. " }, 
{ "title" : "Vorlaufposition vornehmen ", 
"url" : "_sm_example_using_block_search.html#UUID-c7e93ecd-388f-baf1-4162-0ba994d84585_id_defc89f86dbffeecc0a86463490ce87e_id_04188a3f3bea4adbc0a8640e000b4984", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Satzvorlauf verwenden \/ Vorlaufposition vornehmen ", 
"snippet" : "Sie können den Funktionsbaustein SMC_BlockSearchSavePos verwenden, um auf Kommando die aktuelle Position zu speichern. Dabei muss die Instanz des Funktionsbausteins in der Task des Interpolators laufen. Das Interplator-Programm im Beispiel trägt den Namen CNC. Deklarieren Sie in dem Programm, das di...", 
"body" : "Sie können den Funktionsbaustein SMC_BlockSearchSavePos verwenden, um auf Kommando die aktuelle Position zu speichern. Dabei muss die Instanz des Funktionsbausteins in der Task des Interpolators laufen. Das Interplator-Programm im Beispiel trägt den Namen CNC. Deklarieren Sie in dem Programm, das die Interpolation durchführt, eine Instanz des Funktionsbausteins SMC_BlockSearchSavePos . bssp: SMC_BlockSearchSavePos; Verbinden Sie den Eingang ipo der Instanz von SMC_BlockSearchSavePos mit der Instanz des Interpolators. Verbinden Sie den Eingang bExecute mit einer Steuervariablen, die in der Applikation dann gesetzt wird, wenn das CNC-Programm abgebrochen wird (zum Beispiel wenn der Eingang bAbort der SMC_Interpolator-Instanz gesetzt wurde. Die damit an Ausgang ePos gespeicherte Position wird im Folgenden mittels SMC_BlockSearc für den Satzvorlauf verwendet. Nach einer Unterbrechung muss bExecute mit steigender Flanke zurückgesetzt werden. Beispiel Teil des Programms, das die Interpolation durchführt mit der Instanz des Funktionsbaustein SMC_BlockSearchSavePos in CFC. " }, 
{ "title" : "ReadNCFile2 mit Token-Modifizierer ", 
"url" : "_sm_example_readncfile2_token_modifier.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ ReadNCFile2 mit Token-Modifizierer ", 
"snippet" : "Das Beispielprojekt CNC12_TokenModifier.project finden Sie im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie Sie den G-Code beim Einlesen modifizieren können, um die Einheit der Bahngeschwindigkeit (F-Wort) von mm\/min in mm\/s umzuwandeln. Dies ...", 
"body" : "Das Beispielprojekt CNC12_TokenModifier.project finden Sie im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie Sie den G-Code beim Einlesen modifizieren können, um die Einheit der Bahngeschwindigkeit (F-Wort) von mm\/min in mm\/s umzuwandeln. Dies wird erreicht, indem Sie während des Einlesens des G-Codes beim F-Wort vor dem Geschwindigkeitswert den G-Code 1\/60.0 * einfügen. Aus F6000 wird dann F 1\/60.0 * 6000 , was vom Funktionsbaustein SMC_NCInterpreter dann zu F100 verarbeitet wird. In einfachen Fällen könnten Sie auf eine Multiplikation mit 1\/60 verzichten und einfach den Wert, beispielsweise von 6000 auf 100 , anpassen. Die Multiplikation ist aber allgemeiner, da sie auch bei Verwendung von Variablen funktioniert. Aus F $SPEED$ wird F 1\/60.0 * $SPEED$ . " }, 
{ "title" : "Struktur der Applikation ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818233271", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ ReadNCFile2 mit Token-Modifizierer \/ Struktur der Applikation ", 
"snippet" : "Die Applikation besteht, wie für CNC-Applikationen üblich, aus einer Bahnverarbeitung (Programm CNC_PreparePath ) und der Interpolation (Programm CNC ). Da die Interpolation sich nicht von den anderen Beispielen unterscheidet, wird hier nicht weiter darauf eingegangen. Die Bahnverarbeitung wird in d...", 
"body" : "Die Applikation besteht, wie für CNC-Applikationen üblich, aus einer Bahnverarbeitung (Programm CNC_PreparePath ) und der Interpolation (Programm CNC ). Da die Interpolation sich nicht von den anderen Beispielen unterscheidet, wird hier nicht weiter darauf eingegangen. Die Bahnverarbeitung wird in der niederprioren Task PathTask zyklisch alle 20 ms aufgerufen. Die Interpolation wird in der hochprioren Task MotionTask zyklisch alle 4 ms aufgerufen. Für die Visualisierung wird die Hintergrund-Task VISU_TASK definiert. In der Visualisierung können Sie die Abarbeitung des G-Codes starten. Auf der rechten Seite der Visualisierung wird der G-Code und die Bewegung der Maschine (3D-Portals) dargestellt. " }, 
{ "title" : "Der G-Code ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818432406", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ ReadNCFile2 mit Token-Modifizierer \/ Der G-Code ", 
"snippet" : "CNC_PathSpeed N10 G01 X1000 F6000 N20 Y1000 In diesem G-Code wird die Bahngeschwindigkeit in Satz N10 mit F6000 auf 6000 mm\/min vorgegeben. Die Bausteine der CNC erwarten jedoch die Bahngeschwindigkeit in mm\/s. Es werden zwei lineare Bewegungen kommandiert, zuerst nach X=1000 , dann nach X=1000, Y=1...", 
"body" : "CNC_PathSpeed N10 G01 X1000 F6000\nN20 Y1000 In diesem G-Code wird die Bahngeschwindigkeit in Satz N10 mit F6000 auf 6000 mm\/min vorgegeben. Die Bausteine der CNC erwarten jedoch die Bahngeschwindigkeit in mm\/s. Es werden zwei lineare Bewegungen kommandiert, zuerst nach X=1000 , dann nach X=1000, Y=1000 . " }, 
{ "title" : "Token-Verarbeitung ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819460923", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ ReadNCFile2 mit Token-Modifizierer \/ Token-Verarbeitung ", 
"snippet" : "Die Bausteine SMC_ReadNCFile2 und SMC_ReadNCFromStream bieten die Möglichkeit, beim Einlesen des G-Codes eigene Transformationen durchzuführen. Hier beschäftigen wir uns mit der Schnittstelle SMC_ITokenModifier , die über den Eingang aTokenModifier übergeben wird. Diese Schnittstelle arbeitet auf so...", 
"body" : "Die Bausteine SMC_ReadNCFile2 und SMC_ReadNCFromStream bieten die Möglichkeit, beim Einlesen des G-Codes eigene Transformationen durchzuführen. Hier beschäftigen wir uns mit der Schnittstelle SMC_ITokenModifier , die über den Eingang aTokenModifier übergeben wird. Diese Schnittstelle arbeitet auf sogenannten \"Token\". Das sind die Grundbestandteile des G-Codes, in die der G-Code-Text zu Beginn der Verarbeitung zerlegt wird. Beispiel N50 G36 O$plc_variable$ D'TextTest' X-1 (Comment) Dieser G-Code wird folgendermaßen zerlegt: Text SMC_TOKENTYPE SMC_TOKENVALUE N identifer stValue = 'N' 50 number fValue = 50.0 G identifer stValue = 'G' 36 number fValue = 36.0 O identifer stValue = 'O' $plc_variable$ variable stValue = 'plc_variable' D identifer stValue = 'D' 'TextTest' strLiteral stValue = 'TextTest' X identifer stValue = 'X' - operator stValue = '-' 1 number fValue = 1.0 Für die weitere Verarbeitung nicht benötigte Informationen, wie Whitespace-Zeichen, Zeilenumbrüche oder Kommentare, kommen in der Liste der Tokens nicht vor. Wenn die Schnittstelle SMC_ITokenModifier implementiert wird, kann die Liste der Tokens durch Einfügen neuer Tokens, Löschen von Tokens und Änderung des Werts von Tokens angepasst werden. Die Schnittstelle definiert zwei Methoden: Start : Initialisierung des Bausteins. Der interne Zustand wird zurückgesetzt. Call : Aufruf dieser Methode während der Abarbeitung des G-Codes. Token können aus der Eingangs-Queue gelesen und entfernt werden und in die Ausgangs-Queue eingefügt werden. " }, 
{ "title" : "Umsetzung ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819739016", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ ReadNCFile2 mit Token-Modifizierer \/ Umsetzung ", 
"snippet" : "Der Ablauf der Verarbeitung ist wie folgt: Alle Token werden von der Eingangs-Queue in die Ausgangs-Queue verschoben. Wenn ein F-Word enthalten ist, werden nach dem Token für \"F\" und vor dem Token für den Wert der Geschwindigkeit zwei neue Token 1\/60 und * eingefügt. Die Methode Call enthält die Log...", 
"body" : "Der Ablauf der Verarbeitung ist wie folgt: Alle Token werden von der Eingangs-Queue in die Ausgangs-Queue verschoben. Wenn ein F-Word enthalten ist, werden nach dem Token für \"F\" und vor dem Token für den Wert der Geschwindigkeit zwei neue Token 1\/60 und * eingefügt. Die Methode Call enthält die Logik, um die Tokens zu verarbeiten. Es ist hilfreich, die Token der Eingangs-Queue ( tokensIn ) zunächst in eine temporäre Queue ( m_tmpQueue ) zu verschieben, dort zu verarbeiten und danach in die Ausgangs-Queue ( tokensOut ) zu verschieben. Für die Anpassung der Bahngeschwindigkeit ist die temporäre Queue nicht unbedingt nötig, vereinfacht aber die Programmstruktur in komplizierteren Fällen. Methode Call Zu Beginn wird im Zustand STATE_RUNNING gewartet, bis die Bearbeitung starten kann, also bis Token in der Eingangs-Queue vorhanden sind und gleichzeitig noch Platz in der Ausgangs-Queue ist. IF NOT SMC_NC_CanProcessTokens(tokensIn, tokensOut) THEN\n    \/\/ Wait until processing can proceed\n    RETURN;\nEND_IF Danach wird ein Token aus der Eingangs-Queue in die temporäre Queue verschoben. IF m_tmpQueue.IsEmpty() THEN\n    \/\/ Move the next token from the in-queue to the tmp-queue.\n  pt := tokensIn.GetFromStart(0);\n    m_tmpQueue.Append(pt^);\n    tokensIn.RemoveFirst();\nEND_IF Die eigentliche Verarbeitung erfolgt dann in der Methode ConvertSpeed . IF NOT m_tmpQueue.IsEmpty() THEN\n    \/\/ The actual processing is done here\n    ConvertSpeed();\nEND_IF Am Ende der Methode wird dann ein Token aus der temporären Queue in die Ausgangs-Queue verschoben. Methode ConvertSpeed Es wird das erste Token aus der temporären Queue geprüft. Wenn ein Bezeichner mit Wert F gefunden wird, dann werden zwei zusätzliche Token eingefügt: die Zahl 1\/60.0 und der Operator * . (Die Größe der temporären Queue ist so gewählt, dass neben dem einen Token aus der Eingangs-Queue noch zwei weitere Token in die Queue passen.) tk := m_tmpQueue.GetFromStart(0)^;\n\nIF tk.tokenType = SMC_TokenType.identifier THEN\n tk.GetString(pbyString => pby, iSize => iSize);\n \/\/ 70 = ASCII code for F (path velocity)\n IF iSize = 1 AND pby^ = 70 THEN\n \/\/ Insert the number 1\/60\n SMC_Token_InitNumber(\n tk:= tkNumber,\n value:= 1\/60.0,\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkNumber);\n\n \/\/ Insert operator '*' for multiplication\n SMC_Token_InitOperator(\n tk:= tkOperator,\n value:= '*',\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkOperator);\n END_IF\nEND_IF " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869820021001", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ ReadNCFile2 mit Token-Modifizierer \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie die Applikation, wechseln Sie zur Visualisierung und drücken Sie auf Start ....", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie die Applikation, wechseln Sie zur Visualisierung und drücken Sie auf Start . " }, 
{ "title" : "Anwenderspezifische G-Code-Funktionen ", 
"url" : "_sm_custom_g_code_functions.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Anwenderspezifische G-Code-Funktionen ", 
"snippet" : "Das Beispielprojekt  CNC11_CustomFunctions.project finden Sie im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie Sie eigene Funktionen zur Verwendung in Ausdrücken im G-Code erstellen können. Für weitere Informationen zu Ausdrücken und Funktione...", 
"body" : "Das Beispielprojekt  CNC11_CustomFunctions.project finden Sie im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie Sie eigene Funktionen zur Verwendung in Ausdrücken im G-Code erstellen können. Für weitere Informationen zu Ausdrücken und Funktionen im G-Code siehe Ausdrücke. Dort finden Sie eine Liste aller standardmäßig unterstützten Operatoren und Funktionen. Das Beispiel definiert den aus der IEC 61131-3 bekannten Operator SEL , sodass er auch im G-Code verwendet werden kann. " }, 
{ "title" : "Struktur der Applikation ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867931475267", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Anwenderspezifische G-Code-Funktionen \/ Struktur der Applikation ", 
"snippet" : "Die Applikation besteht, wie für CNC-Applikationen üblich, aus einer Bahnverarbeitung (Programm CNC_PreparePath ) und der Interpolation (Programm CNC ). Da die Interpolation sich nicht von den anderen Beispielen unterscheidet, wird hier nicht weiter auf das Thema eingegangen. Die Bahnverarbeitung wi...", 
"body" : "Die Applikation besteht, wie für CNC-Applikationen üblich, aus einer Bahnverarbeitung (Programm CNC_PreparePath ) und der Interpolation (Programm CNC ). Da die Interpolation sich nicht von den anderen Beispielen unterscheidet, wird hier nicht weiter auf das Thema eingegangen. Die Bahnverarbeitung wird in der niederprioren Task PathTask zyklisch alle 20 ms aufgerufen. Die Interpolation wird in der hochprioren Task MotionTask zyklisch alle 4 ms aufgerufen. Für die Visualisierung die Hintergrund-Task VISU_TASK definiert. In der Visualisierung können Sie die Abarbeitung des G-Codes starten und den Wert der Variablen $LONGLINE$ setzen. Auf der rechten Seite der Visualisierung wird der G-Code und die Bewegung der Maschine (3D-Portal) dargestellt. " }, 
{ "title" : "Der G-Code ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867932695176", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Anwenderspezifische G-Code-Funktionen \/ Der G-Code ", 
"snippet" : "CNC LET #WIDTH : LREAL N10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110) N20 F50 E100 E-100 N30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2 N40 Y-#WIDTH N50 X-#WIDTH Z-#WIDTH\/2 N60 Y#WIDTH N70 X0 Y0 Z0 Zeile 1: Deklaration der lokalen Variable #WIDTH vom Typ LREAL . Zeile 2, Satz N10: Zuweisung des Werts von SEL($LONGLI...", 
"body" : "CNC LET #WIDTH : LREAL\nN10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110)\nN20 F50 E100 E-100\nN30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2\nN40 Y-#WIDTH\nN50 X-#WIDTH Z-#WIDTH\/2\nN60 Y#WIDTH\nN70 X0 Y0 Z0 Zeile 1: Deklaration der lokalen Variable #WIDTH vom Typ LREAL . Zeile 2, Satz N10: Zuweisung des Werts von SEL($LONGLINE$, 40, 110) auf die Variable #WIDTH . Wenn der Wert der PLC-Variable $LONGLINE$ TRUE ist, dann ist der Wert des Ausdrucks 110, andernfalls 40. In den folgenden Zeilen wird ein Quadrat mit zusätzlicher Bewegung in Z-Richtung abgefahren, die Seitenlänge des Quadrats ist 2*#WIDTH . " }, 
{ "title" : "Umsetzung der Funktion SEL ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867935164437", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Anwenderspezifische G-Code-Funktionen \/ Umsetzung der Funktion SEL ", 
"snippet" : "Um eine benutzerdefinierte Funktion zu erstellen, müssen Sie einen Funktionsbaustein schreiben, der die Schnittstelle SMC_NC_IFunction implementiert. Für weitere Informationen siehe: SMC_NC_IFunction . Die Schnittstelle definiert zwei Methoden: GetSignature . Hier wird der Rückgabetyp, die Anzahl un...", 
"body" : "Um eine benutzerdefinierte Funktion zu erstellen, müssen Sie einen Funktionsbaustein schreiben, der die Schnittstelle SMC_NC_IFunction implementiert. Für weitere Informationen siehe: SMC_NC_IFunction . Die Schnittstelle definiert zwei Methoden: GetSignature . Hier wird der Rückgabetyp, die Anzahl und die Typen der Argumente der Funktion zurückgegeben. In diesem Beispiel gibt die Funktion SEL einen Wert vom Typ T_OTHER zurück und hat 3 Argumente vom Typ T_BOOL , T_OTHER und T_OTHER . T_OTHER steht für einen beliebigen Typ, also entweder T_BOOL , T_LREAL , oder T_STRING . Alle 3 Vorkommen von T_OTHER müssen denselben Typ haben. METHOD GetSignature\nVAR_OUTPUT\n    resultType : SMC_GVar_Type;\n    nNumArguments : UDINT;\n    pType : POINTER TO SMC_GVar_Type;\nEND_VAR\nVAR    argTypes : ARRAY[0..2] OF SMC_GVar_Type :=\n        [SMC_GVar_Type.T_BOOL,\n         SMC_GVar_Type.T_OTHER,\n         SMC_GVar_Type.T_OTHER];\nEND_VAR\n\nresultType := SMC_GVAR_Type.T_OTHER;\nnNumArguments := 3;\npType := ADR(argTypes); Call : Diese Methode wird während der Abarbeitung des G-Codes aufgerufen. Die Argumente werden über den Eingang pa übergeben. Mit dem Ausdruck pa[0].argValue.bValue wird auf den boolschen Wert des ersten Arguments zugegriffen. Je nach Typ des zweiten Arguments pa[1].argType ergibt sich der Rückgabewert result.argType und die Verzweigung in einen Zweig der CASE-Anweisung. METHOD Call\nVAR_IN_OUT\n    result : SMC_NC_GArgument;\nEND_VAR\nVAR_INPUT\n    pa : POINTER TO SMC_NC_GArgument;\nEND_VA\nRVAR_OUTPUT\n    eError : SMC_ERROR;\nEND_VAR\nVAR\n    g : BOOL;\nEND_VAR\n\ng := pa[0].argValue.bValue;\n\nresult.argType := pa[1].argType;\n\nCASE result.argType OF\nSMC_GVAR_Type.T_BOOL:\n    result.argValue.bValue := SEL(g, pa[1].argValue.bValue, pa[2].argValue.bValue);\n\nSMC_GVAR_Type.T_STRING:\n    result.argValue.sValue := SEL(g, pa[1].argValue.sValue, pa[2].argValue.sValue);\n\nSMC_GVAR_Type.T_LREAL:\n    result.argValue.fValue := SEL(g, pa[1].argValue.fValue, pa[2].argValue.fValue);\n\nELSE\n    eError := SMC_INVALID_PARAMETER;\nEND_CASE " }, 
{ "title" : "Konfiguration von SMC_ReadNCFile2 ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867956933133", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Anwenderspezifische G-Code-Funktionen \/ Konfiguration von SMC_ReadNCFile2 ", 
"snippet" : "In der globalen Variablenliste GVL_CNCFunctions wird eine Instanz des Funktionsbausteins CNC_Sel angelegt. Dann wird ein Array aCNCFunctions der Länge 1 mit Namen und Instanz des Funktionsbausteins initialisiert und dieses Array in der Tabelle funTable vom Typ SMC_NC_GFunctionTable verlinkt. aCNCFun...", 
"body" : "In der globalen Variablenliste GVL_CNCFunctions wird eine Instanz des Funktionsbausteins CNC_Sel angelegt. Dann wird ein Array aCNCFunctions der Länge 1 mit Namen und Instanz des Funktionsbausteins initialisiert und dieses Array in der Tabelle funTable vom Typ SMC_NC_GFunctionTable verlinkt. aCNCFunctions : ARRAY[0..0] OF SMC_NC_GFunction :=\n    [(stName:= 'SEL', iFunc:= GVL_CNCFunctions.g_Sel)];\n\nfunTable : SMC_NC_GFunctionTable :=\n    (numFunctions:= 1,     pFunction:= ADR(aCNCFunctions)) ; Diese Tabelle wird dann dem Funktionsbaustein SMC_ReadNCFile2 mitgegeben: rncf2 : SMC_ReadNCFile2 := (bParenthesesAsComments:= FALSE);\n\n[...]\n\nrncf2(\n    bExecute:= TRUE,\n    sFileName:= sFileName,\n    pCustomFunTable:= ADR(funTable),\n    pvl:= ADR(varList)); " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867960408693", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Beispiele \/ Anwenderspezifische G-Code-Funktionen \/ Konfiguration von SMC_ReadNCFile2 \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie die Applikation, wechseln Sie zur Visualisierung und drücken Sie auf Start . Mit dem Radiobutton Longline können Sie den Wert der Variablen $LONGLINE$ im G-Code auf TRUE oder FALSE setzen....", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Starten Sie die Applikation, wechseln Sie zur Visualisierung und drücken Sie auf Start . Mit dem Radiobutton Longline können Sie den Wert der Variablen $LONGLINE$ im G-Code auf TRUE oder FALSE setzen. " }, 
{ "title" : "Benutzeroberfläche ", 
"url" : "_sm_cnc_user_interface.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Dynamik analysieren ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Dynamik analysieren ", 
"snippet" : "Dynamik analysieren Funktion : Der Befehl startet eine Dynamikanalyse der im Editor aktiven CNC-Bahn. Dabei werden die Größen Position, Geschwindigkeit, Beschleunigung und Ruck der CNC-Bahn in Abhängigkeit von der Zeit ermittelt und im Dialog Dynamikanalyse in Zeitdiagrammen dargestellt. Aufruf : Me...", 
"body" : "Dynamik analysieren Funktion : Der Befehl startet eine Dynamikanalyse der im Editor aktiven CNC-Bahn. Dabei werden die Größen Position, Geschwindigkeit, Beschleunigung und Ruck der CNC-Bahn in Abhängigkeit von der Zeit ermittelt und im Dialog Dynamikanalyse in Zeitdiagrammen dargestellt. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Um eine Dynamikanalyse der CNC-Bahn ausführen zu können, darf bei der Berechnung ihrer Bahnvorverarbeitung kein Fehler auftreten. Für weitere Informationen siehe: Vorverarbeitete Bahn anzeigen" }, 
{ "title" : "Dialog: Dynamikanalyse ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html#UUID-172573a8-7bc5-69ee-931b-3074ace95453_id_f14ff69a244133a5c0a8640e0144954d_id_72da7ed158aa22a9c0a864637a09d164", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Dynamik analysieren \/ Dialog: Dynamikanalyse ", 
"snippet" : "Die Einstellungen im Dialog werden ausschließlich für die Darstellung der Dynamikanalyse verwendet und haben keine Auswirkung auf das CNC-Programm oder den CNC-Einstellungen. Bei der Dynamikanalyse werden die Zeitverläufe für die Größen Position, Geschwindigkeit, Beschleunigung und Ruck für die ganz...", 
"body" : "Die Einstellungen im Dialog werden ausschließlich für die Darstellung der Dynamikanalyse verwendet und haben keine Auswirkung auf das CNC-Programm oder den CNC-Einstellungen. Bei der Dynamikanalyse werden die Zeitverläufe für die Größen Position, Geschwindigkeit, Beschleunigung und Ruck für die ganze Bahn, die abgefahren wird, ermittelt. Die Zeitdiagramme werden im Dialog jeweils über die gleiche Zeitachse dargestellt. Dabei werden die (voreingestellten oder gespeicherten) Einstellungen des Dialogs.berücksichtigt. Diagramm Position Positionsverlauf der ausgewählten Achse (in schwarz) Roter Kreis, markiert den Anfang eines Bahnelements Toolttip der Markierung informiert über die Zeilennummer im zugehörigen G-Code oder in der Tabelle. Diagramm Velocity Geschwindigkeitsverlauf der ausgewählten Achse (in blau) Diagramm Acceleration Beschleunigungsverlauf der ausgewählten Achse (in grün) Diagramm Jerk Ruckverlauf der ausgewählten Achse (in orange) Die Einstellungen werden beim Schließen gespeichert und beim nächsten Öffnen des Dialogs angewendet. Beispielsweise kann der Zoomfaktor bewirken, dass nur ein Teil des Verlaufs sichtbar ist. Zoomt einen Teil der Zeitverläufe heran Alternativ: Strg + + Strg + Rollrad Zoomt aus den Zeitverläufen heraus Alternativ: Strg + - Strg + Rollrad Zoomt die Zeitverläufe so, dass die CNC-Bahn vollständig dargestellt werden Achse Auswahl der Achse: X , Y , Z , A , B , C , A1(P) , A2(Q) , A3 (U) , A4(V) , A5(W) , A6 oder Bahn Voreinstellung: Achse X Achse Bahn : Darstellung von Bahnposition, Bahngeschwindigkeit, Bahnbeschleunigung und Bahnruck Zykluszeit [µs] Wert für Eingang dwIpoTime des Funktionsbausteins SMC_Interpolator Voreingestellung: Wert Zykluszeit [µs] in Objekt CNC-Einstellungen , Registerkarte Vorinterpolation Geschwindigkeitsmodus Wert für Eingang iVelMode des Funktionsbausteins SMC_Interpolator Trapezoid Trapezförmiges Geschwindigkeitsprofil Sigmoidal Wie Trapezoid , aber steigende oder fallende Flanken werden ersetzt durch sin²-Funktionen gleicher Fläche. In diesem Geschwindigkeitsmodus wird der Grenzwert etwa um den Faktor π\/2 überschritten. Sigmoidal begrenzt Wie Sigmoidal , aber die Zeitdauer für die Interpolation der Bahn ist gleich lang wie im Geschwindigkeitsmodus Trapezoid . Voreinstellung Quadratisch Beschleunigungsprofil in trapezförmiger Form mit Ruckbegrenzung Der Ruck erreicht maximal den Wert in Maximaler Jerk [u\/s³] . Das führt zu einem quadratischen Geschwindigkeitsprofil. Das Positionsprofil besteht dabei aus Polynomen dritten Grads. Daraus folgt, dass das Geschwindigkeitsprofil aus Parabeln, die Beschleunigung aus linearen Segmenten und der Ruck aus horizontalen Liniensegmenten besteht. Maximaler Ruck [u\/s³] Ruckbegrenzung " }, 
{ "title" : "Befehl: Von DXF-Datei importieren ", 
"url" : "_sm_cmd_cnc_dxf_import.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Von DXF-Datei importieren ", 
"snippet" : "Von DXF-Datei importieren Funktion : Der Befehl öffnet den Standarddialog. Nach Auswahl der Datei öffnet sich der Dialog DXF-Datei importieren , in dem der Import einer DXF-Datei in den CNC-Editor konfiguriert wird. Aufruf : Menü CNC Voraussetzung : Ein CNC-Objekt ist im Editor geöffnet. Einschränku...", 
"body" : "Von DXF-Datei importieren Funktion : Der Befehl öffnet den Standarddialog. Nach Auswahl der Datei öffnet sich der Dialog DXF-Datei importieren , in dem der Import einer DXF-Datei in den CNC-Editor konfiguriert wird. Aufruf : Menü CNC Voraussetzung : Ein CNC-Objekt ist im Editor geöffnet. Einschränkungen des DXF-Standards beim Dateiimport SPLINE -Elemente werden nicht exakt importiert, es werden nur die Kontrollpunkte ausgelesen und durch diese Kardinalsplines gelegt. Externe Referenzen werden nicht unterstützt. (Das sind Verweise auf andere DXF-Dateien innerhalb eines BLOCK -Elements.) Ellipsen werden nur unterstützt sofern sie in der x\/y-Ebene liegen. Kreisbögen (Element ARC ) und Kreise (Element CIRCLE ) werden nur unterstützt, wenn die Skalierung in allen Raumachsen gleich ist (Parameter 41, 42, 43 des Elements INSERT ). Dies betrifft auch die Elemente POLYLINE und LWPOLYLINE , die Kreisbögen enthalten (Parameter bulge ungleich 0 ). Blockreferenzen (Elemente INSERT ) werden nur unterstützt, wenn die Skalierungsmatrix keine Spiegelung ist. (Das Produkt der Skalierungsfaktoren muss positiv sein.) Flächenelemente, Polygonmeshes und Polyfacemeshes werden nicht unterstützt. Ebenso wenig werden Körperelemente ( SOLID , …) unterstützt. Die Elemente MLINE (Multiline), RAY , XLINE und LEADER (Führungslinie) werden nicht unterstützt. Die Elemente TEXT , MTEXT und DIMENSION werden nicht unterstützt. Linienbreite, -Farbe und -Stil werden ignoriert, Informationen über Elementsichtbarkeiten werden ignoriert. Binäre DXF-Dateien (Dateiendung DXB ) werden nicht unterstützt. Nicht unterstützte Elemente werden beim Import (stillschweigend) ignoriert. " }, 
{ "title" : "Dialog: DXF-Datei importieren ", 
"url" : "_sm_cmd_cnc_dxf_import.html#UUID-ceb47740-324e-76a2-abd9-2d1fa27e1a26_id_fde6e1824400e36c0a8640e013dba7a_id_754451675df6e481c0a8646326153262", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Von DXF-Datei importieren \/ Dialog: DXF-Datei importieren ", 
"snippet" : "Ebenen Alle Ebenen der technischen Zeichnung, ermittelt aus den Daten der DXF-Datei : Die Ebene wird importiert. Maximale Sprunggröße Abstand zwischen den Endpunkten der geometrischen Elemente bis zu dem die Punkte als miteinander verbunden betrachtet werden. Ermittelt aus den Daten der der DXF-Date...", 
"body" : "Ebenen Alle Ebenen der technischen Zeichnung, ermittelt aus den Daten der DXF-Datei : Die Ebene wird importiert. Maximale Sprunggröße Abstand zwischen den Endpunkten der geometrischen Elemente bis zu dem die Punkte als miteinander verbunden betrachtet werden. Ermittelt aus den Daten der der DXF-Datei. Beispiel: 0,001 Vorschau auf die CNC-Bahn Die Daten der ausgewählten DXF-Datei werden so dargestellt, wie sie in den CNC-Editor importiert werden. Dabei ist berüchsichtigt, welche Ebene zur Ansicht aufgewählt ist. Beispiel: Ansicht Um die Ebene umzuschalten, die im Vorschaufenster berücksichtigt ist. x\/y-Ebene, zur Ansicht ausgewählt x\/z-Ebene y\/z-Ebene Schaltfläche Import Die Daten werden in den CNC-Editor geladen und dabei das bestehende CNC-Programm ersetzt. Die Satznummern werden automatisch zugewiesen. Das CNC-Objekt behält seinen Namen. " }, 
{ "title" : "Befehl: CNC Info ", 
"url" : "_sm_cmd_cnc_info.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: CNC Info ", 
"snippet" : "CNC Info Funktion : Der Befehl öffnet den Dialog CNC-Information von Programm <Name> . Aufruf : Menü CNC Kontextmenü eines Objekts, Typ CNC-Programm Voraussetzung : Eine CNC-Programm ist im Editor geöffnet. Dialog: Erzeugter Code Der Dialog zeigt den IEC-Initialisierungscode des aktiven CNC-Programm...", 
"body" : "CNC Info Funktion : Der Befehl öffnet den Dialog CNC-Information von Programm <Name> . Aufruf : Menü CNC Kontextmenü eines Objekts, Typ CNC-Programm Voraussetzung : Eine CNC-Programm ist im Editor geöffnet. Dialog: Erzeugter Code Der Dialog zeigt den IEC-Initialisierungscode des aktiven CNC-Programms an, je nach Übersetzungsmodus für den Funktionsbaustein SMC_OutQueue oder den Funktionsbaustein SMC_CNC_REF . Beispiel: IEC-Initialisierungscode {attribute 'linkalways'}\nVAR_GLOBAL\n {attribute 'init_on_onlchange'}\n {attribute 'init_on_onlchange'}\n Example : SMC_CNC_REF := (nElements := 22, strProgramName := 'Example', piStartPosition := (iFrameNo:=0, wAuxData:=7, wSProfile:=0, dX:=0, dY:=0, dZ:=0, dA:=0, dB:=0, dC:=0, dA1:=0, dA2:=0, dA3:=0, dA4:=0, dA5:=0, dA6:=0), pgc := ADR(Example_D), xPartofLM := TRUE);\n {attribute 'blobinit'}\n {attribute 'init_on_onlchange'}\n Example_D : ARRAY[0..21] OF SMC_GCODE_WORD := [\n {p 35184372088832 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 70, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 69, fValue:=100, diValue:=100),\n {p 35184372088832 }\n (byLetter := 69, fValue:=-100, diValue:=-100),\n {p 35184372088832 }\n (byLetter := 128, fValue:=1, diValue:=1),\n {p 36283883716609 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 36835250143233 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 38486665068545 }\n (byLetter := 88, pAdr := ADR(g_x), byVarType := ANY_TO_BYTE(__TYPEOF(g_x) + 32)),\n {p 36291399909377 }\n (byLetter := 89, fValue:=0, diValue:=0),\n {p 36842766336001 }\n (byLetter := 70, fValue:=50, diValue:=50),\n {p 36844913819649 }\n (byLetter := 69, fValue:=30, diValue:=30),\n {p 37396817117185 }\n (byLetter := 69, fValue:=-30, diValue:=-30),\n {p 35184372088832 }\n (byLetter := 128, fValue:=2, diValue:=2),\n {p 36833639530498 }\n (byLetter := 78, fValue:=10, diValue:=10),\n {p 36835787014146 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683906 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 38488812552194 }\n (byLetter := 89, pAdr := ADR(g_y), byVarType := ANY_TO_BYTE(__TYPEOF(g_y) + 32)),\n {p 35184372088832 }\n (byLetter := 128, fValue:=3, diValue:=3),\n {p 36833639530499 }\n (byLetter := 78, fValue:=20, diValue:=20),\n {p 36835787014147 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683907 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 36289789296643 }\n (byLetter := 89, fValue:=0, diValue:=0)];\nEND_VAR " }, 
{ "title" : "Dialog: CNC-Information von Programm <Name> ", 
"url" : "_sm_cmd_cnc_info.html#UUID-ad8caf78-e0cf-3500-0750-16c2eb5fabe7_id_dc9afe4124423d69c0a8640e01f781e8_id_fc2c1e2959841990c0a864630e5a26e5", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: CNC Info \/ Dialog: CNC-Information von Programm <Name> ", 
"snippet" : "Der Dialog informiert über das genannte CNC-Programm. Programmname Beispiel: Workpiece_1 Version der Funktionsbausteine Beispiel: 4.2.0.0 Anzahl Zeilen Beispiel: 5 Anzahl Objekte Beispiel: 3 Bahnlänge [Einheiten] Beispiel: 261,803398874992 Dauer [s] Dauer für das Abfahren der vorverarbeiteten Bahn i...", 
"body" : "Der Dialog informiert über das genannte CNC-Programm. Programmname Beispiel: Workpiece_1 Version der Funktionsbausteine Beispiel: 4.2.0.0 Anzahl Zeilen Beispiel: 5 Anzahl Objekte Beispiel: 3 Bahnlänge [Einheiten] Beispiel: 261,803398874992 Dauer [s] Dauer für das Abfahren der vorverarbeiteten Bahn in Sekunden Beispiel: 10,158 Voraussetzung: Fehlerfreie Bahnvorverarbeitung und erfolgreich generierte Interpolationspunkte Erzeugten Code anzeigen Dialog Erzeugter Code öffnet sich. Voraussetzung: Das Programm ist fehlerfrei. " }, 
{ "title" : "Befehl: Programm von ASCII-Datei laden ", 
"url" : "_sm_cmd_cnc_load_program_from_ascii_file.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Programm von ASCII-Datei laden ", 
"snippet" : "Programm von ASCII-Datei laden Funktion : Der Befehl ermöglicht das Laden einer ASCII -Datei mit CNC-Programmdaten in den CNC-Editor. Das CNC-Objekt behält seinen Namen. Aufruf : Menü CNC Voraussetzung : Ein CNC-Objekt ist im Editor geöffnet. Der Befehl öffnet den Standarddialog für das Durchsuchen ...", 
"body" : "Programm von ASCII-Datei laden Funktion : Der Befehl ermöglicht das Laden einer ASCII -Datei mit CNC-Programmdaten in den CNC-Editor. Das CNC-Objekt behält seinen Namen. Aufruf : Menü CNC Voraussetzung : Ein CNC-Objekt ist im Editor geöffnet. Der Befehl öffnet den Standarddialog für das Durchsuchen des Dateisystems. Der Filter muss auf CNC, GCODE oder TXT eingestellt sein. Die ausgewählte Datei wird in den aktiven CNC-Editor geladen. Dabei wird ein vorhandenes CNC-Programm (nach einer nochmaligen Abfrage) überschrieben. " }, 
{ "title" : "Befehl: Programm verschieben ", 
"url" : "_sm_cmd_cnc_move_program.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Programm verschieben ", 
"snippet" : "Programm verschieben Funktion : Der Befehl bewirkt, dass sich der Dialog Verschiebungsvektor öffnet, um eine Verschiebung der CNC-Bahn zu konfigurieren. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet....", 
"body" : "Programm verschieben Funktion : Der Befehl bewirkt, dass sich der Dialog Verschiebungsvektor öffnet, um eine Verschiebung der CNC-Bahn zu konfigurieren. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. " }, 
{ "title" : "Einschränkung ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_e69692297289ca8ec0a864631a178469", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Programm verschieben \/ Einschränkung ", 
"snippet" : "Eine Verschiebung der CNC-Bahn ist unter den folgenden Bedingungen möglich: Keine Verwendung der Achse A, B oder C von Variablen...", 
"body" : "Eine Verschiebung der CNC-Bahn ist unter den folgenden Bedingungen möglich: Keine Verwendung der Achse A, B oder C von Variablen " }, 
{ "title" : "Dialog: Verschiebungsvektor ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Programm verschieben \/ Dialog: Verschiebungsvektor ", 
"snippet" : "Verschiebungsvektor in Koordinaten für alle Achsen X Voreinstellung: 1,0000000 Y Z P Q U V W OK Die CNC-Bahn wird verschoben. Dabei wird im CNC-Programm vor dem ersten Positionierungsbefehl ein G0-Befehl (relativer Postionierungsbefehl) mit den Koordinaten des Verschiebungsvektors eingefügt. Positio...", 
"body" : "Verschiebungsvektor in Koordinaten für alle Achsen X Voreinstellung: 1,0000000 Y Z P Q U V W OK Die CNC-Bahn wird verschoben. Dabei wird im CNC-Programm vor dem ersten Positionierungsbefehl ein G0-Befehl (relativer Postionierungsbefehl) mit den Koordinaten des Verschiebungsvektors eingefügt. Positionierungsbefehle sind: G1, G2, G3, G5, G6, G8, G9, G10, G11, G92. Wenn im CNC-Programm G54-, G55- oder G56-Befehle das Koordinatensystem verschieben, werden die Argumente in diesen Befehlen angepasst. Die Sätze bis G53 benötigen keine weitere Anpassung. Wenn ein G56-Befehl erster Positionierungsbefehl ist, wird nur der Befehl angepasst. Die Satznummern werden automatisch zugewiesen. " }, 
{ "title" : "Befehl: CNC-Programm neu nummerieren ", 
"url" : "_sm_cmd_cnc_renumber_cnc_program.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: CNC-Programm neu nummerieren ", 
"snippet" : "CNC-Programm neu nummerieren Symbol: Funktion : Der Befehl aktualisiert die Nummerierung der Programmzeilen im CNC-Programm. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Die Nummern beginnen mit 0 und werden jeweils um 10 inkrementiert. Jeder Satz ohne Satznummer bekommt e...", 
"body" : "CNC-Programm neu nummerieren Symbol: Funktion : Der Befehl aktualisiert die Nummerierung der Programmzeilen im CNC-Programm. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Die Nummern beginnen mit 0 und werden jeweils um 10 inkrementiert. Jeder Satz ohne Satznummer bekommt eine Nummer. L-Code in G20 Sätzen wird korrigiert. " }, 
{ "title" : "Befehl: Richtung umkehren ", 
"url" : "_sm_cmd_cnc_reverse_direction.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Richtung umkehren ", 
"snippet" : "Richtung umkehren Funktion : Der Befehl bewirkt, dass das CNC-Programm umgekehrt wird und die Bahnelemente in umgekehrter Reihenfolge zusammengesetzt werden. Die Satznummern des CNC-Programms werden dabei automatisch erneuert. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. E...", 
"body" : "Richtung umkehren Funktion : Der Befehl bewirkt, dass das CNC-Programm umgekehrt wird und die Bahnelemente in umgekehrter Reihenfolge zusammengesetzt werden. Die Satznummern des CNC-Programms werden dabei automatisch erneuert. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Einschränkung Eine Umkehrung der CNC-Bahn ist unter den folgenden Bedingungen möglich: Wenn für das CNC-Programm Vorverarbeitung ausgewählt wurde, werden die G41\/G42-Blöcke im Umkehrprogramm bearbeitet: G41 wird zu G42 und G42 wird zu G41. Außerdem wird die Richtung der Korrektur umgekehrt. Wenn das CNC-Programm Kreisbögen enthält, die mit einem Öffnungswinkel definiert sind (Parameter K bei 2D-Elementen oder Parameter T bei 3D-Elementen), erzeugt der Befehl keinen exakten, umgekehrten Bogen. Wenn die CNC-Bahn mit folgende Mittel programmiert wurde, ist keine Umkehrung möglich. Keine Umkehrung bei Verwendung der Achse A, B oder C Verwendung von Variablen Aufruf der Satzunterdrückung " }, 
{ "title" : "Befehl: Programm drehen ", 
"url" : "_sm_cmd_cnc_rotate_program.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Programm drehen ", 
"snippet" : "Programm drehen Funktion : Der Befehl öffnet den Dialog Rotationsparameter , in dem eine Drehung der CNC-Bahn zu konfiguriert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet....", 
"body" : "Programm drehen Funktion : Der Befehl öffnet den Dialog Rotationsparameter , in dem eine Drehung der CNC-Bahn zu konfiguriert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. " }, 
{ "title" : "Einschränkung ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_45841f775e56fd50c0a864632eb28d67", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Programm drehen \/ Einschränkung ", 
"snippet" : "Eine Drehung der CNC-Bahn ist unter den folgenden Bedingungen möglich: Keine Verwendung der Achse A, B oder C von Variablen...", 
"body" : "Eine Drehung der CNC-Bahn ist unter den folgenden Bedingungen möglich: Keine Verwendung der Achse A, B oder C von Variablen " }, 
{ "title" : "Dialog: Rotationsparameter ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Programm drehen \/ Dialog: Rotationsparameter ", 
"snippet" : "Winkel (Grad) Drehwinkel in Grad um die Rotationsachse . Beispiel: Annahme Drehung um Z-Achse X-Achse zeigt nach rechts, die Y-Achse nach oben. Die Blickrichtung ist entgegen der Drehachse (Rechtehandregel). Bei einem negativem Wert wird eine Drehung im Uhrzeigersinn ausgeführt. Bei einem positivem ...", 
"body" : "Winkel (Grad) Drehwinkel in Grad um die Rotationsachse . Beispiel: Annahme Drehung um Z-Achse X-Achse zeigt nach rechts, die Y-Achse nach oben. Die Blickrichtung ist entgegen der Drehachse (Rechtehandregel). Bei einem negativem Wert wird eine Drehung im Uhrzeigersinn ausgeführt. Bei einem positivem Wert wird eine Drehung gegen den Uhrzeigersinn ausgeführt. Rotationsachse Das Wählen einer Drehachse ist nur möglich, wenn die Elemente der CNC-Bahn jeweils 3D-Elemente sind. Keine Auswahl, wenn die CNC-Bahn eines der folgenden Elemente enthält: G5-Spline Parabel Ellipse 2D-Kreisbogen Die Rotationsachse definiert sich über die Parameter X , Y und Z . Voreinstellung: X : 0, Y : 0, Z : 1 –> Drehung um die Z-Achse X Voreinstellung: 0,00000 Y Voreinstellung: 0,00000 Z Voreinstellung: 1,00000 OK Die Drehung wird ausgeführt. Die Satznummern werden automatisch zugewiesen. " }, 
{ "title" : "Befehl: Programm skalieren ", 
"url" : "_sm_cmd_cnc_scale_program.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Programm skalieren ", 
"snippet" : "Programm skalieren Funktion : Der Befehl öffnet den Dialog Programm skalieren , in dem die Skalierung der CNC-Bahn konfiguriert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet....", 
"body" : "Programm skalieren Funktion : Der Befehl öffnet den Dialog Programm skalieren , in dem die Skalierung der CNC-Bahn konfiguriert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. " }, 
{ "title" : "Einschränkung ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_1320e28c7289c9f2c0a864633d064770", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Programm skalieren \/ Einschränkung ", 
"snippet" : "Eine Skalierung der CNC-Bahn ist unter den folgenden Bedingungen möglich: Keine Verwendung der Achse A, B oder C von Variablen...", 
"body" : "Eine Skalierung der CNC-Bahn ist unter den folgenden Bedingungen möglich: Keine Verwendung der Achse A, B oder C von Variablen " }, 
{ "title" : "Dialog: Programm skalieren ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Programm skalieren \/ Dialog: Programm skalieren ", 
"snippet" : "Skalierungsfaktor Voreinstellung: 0,001 Bedingung: Skalierungsfaktor >= 1e-3 Bei einem Skalierungsfaktor > 1 wird hochskaliert. Achsen : Die Achse wird skaliert. D (Werkzeugradius) : Der Werkzeugradius D wird skaliert. OK Die Skalierung wird ausgeführt. Die Satznummern werden automatisch zugewiesen....", 
"body" : "Skalierungsfaktor Voreinstellung: 0,001 Bedingung: Skalierungsfaktor >= 1e-3 Bei einem Skalierungsfaktor > 1 wird hochskaliert. Achsen : Die Achse wird skaliert. D (Werkzeugradius) : Der Werkzeugradius D wird skaliert. OK Die Skalierung wird ausgeführt. Die Satznummern werden automatisch zugewiesen. " }, 
{ "title" : "Befehl: Bahnansicht scrollen ", 
"url" : "_sm_cmd_cnc_scroll_path_view.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Bahnansicht scrollen ", 
"snippet" : "Bahnansicht scrollen Funktion : Der Befehl bewirkt, dass das Scrollen der CNC-Bahn aktiviert oder deaktiviert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Wenn das Scrollen aktiviert ist, wird im grafischen Editor die Ansicht der CNC-Bahn gescrollt und gezoomt, so da...", 
"body" : "Bahnansicht scrollen Funktion : Der Befehl bewirkt, dass das Scrollen der CNC-Bahn aktiviert oder deaktiviert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Wenn das Scrollen aktiviert ist, wird im grafischen Editor die Ansicht der CNC-Bahn gescrollt und gezoomt, so dass ein im CNC-Programm selektiertes Bahnelement vollständig sichtbar ist. " }, 
{ "title" : "Befehl: Variablen setzen ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Variablen setzen ", 
"snippet" : "Variablen setzen Funktion : Der Befehl öffnet den Dialog Offlinewerte der Variablen . Dort definieren Sie die Variablen des CNC-Programms für den Offlinebetrieb. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet....", 
"body" : "Variablen setzen Funktion : Der Befehl öffnet den Dialog Offlinewerte der Variablen . Dort definieren Sie die Variablen des CNC-Programms für den Offlinebetrieb. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. " }, 
{ "title" : "Dialog: Offlinewerte der Variablen ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html#UUID-101f0c28-cef6-51dc-ec33-33b8d27ee9c8_id_c97aba1d244400ffc0a8640e01a5ad6c_id_d54502d95df6e2f6c0a8646351ba116d", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Variablen setzen \/ Dialog: Offlinewerte der Variablen ", 
"snippet" : "Variable Variable des CNC-Programms Beispiel: G_X Wenn die Variable in grauer, kursiver Schriftart dargestellt ist, wird sie im CNC-Programm aktuell nicht verwendet. Wert Konfigurierter Offlinewert Beispiel: 100 Auf Onlinewerte setzen Die Werte werden überschrieben mit den Werten, die in der Applika...", 
"body" : "Variable Variable des CNC-Programms Beispiel: G_X Wenn die Variable in grauer, kursiver Schriftart dargestellt ist, wird sie im CNC-Programm aktuell nicht verwendet. Wert Konfigurierter Offlinewert Beispiel: 100 Auf Onlinewerte setzen Die Werte werden überschrieben mit den Werten, die in der Applikation aktuell zugewiesen sind. Voraussetzung: Der Befehl ist verfügbar, wenn die Applikation läuft und der CNC-Editor im Onlinebetrieb ist. Dann ist es möglich die Onlinewerte zu laden. OK Wenn die Werte gültig sind, werden sie in das CNC-Programm übernommen und die Bahn des CNC-Editors wird erneuert. " }, 
{ "title" : "Befehl: Endpunkte anzeigen ", 
"url" : "_sm_cmd_cnc_show_end_points.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Endpunkte anzeigen ", 
"snippet" : "Endpunkte anzeigen Funktion : Der Befehl bewirkt, dass das Anzeigen der CNC-Bahnendpunkten aktiviert oder deaktiviert ist. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Wenn die Anzeige aktiviert ist, sind alle Bahnelemente mit Endpunkten versehen....", 
"body" : "Endpunkte anzeigen Funktion : Der Befehl bewirkt, dass das Anzeigen der CNC-Bahnendpunkten aktiviert oder deaktiviert ist. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Wenn die Anzeige aktiviert ist, sind alle Bahnelemente mit Endpunkten versehen. " }, 
{ "title" : "Befehl: Raster anzeigen ", 
"url" : "_sm_cmd_cnc_show_grid.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Raster anzeigen ", 
"snippet" : "Raster anzeigen Symbol: Funktion : Der Befehl bewirkt, dass im grafischen Editor die Anzeige eines Rasters aktiviert oder deaktiviert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Der Zoomfaktor bestimmt die Abstände der Rasterlinien. Die Ausdehnung der Bahn bestimmt ...", 
"body" : "Raster anzeigen Symbol: Funktion : Der Befehl bewirkt, dass im grafischen Editor die Anzeige eines Rasters aktiviert oder deaktiviert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Der Zoomfaktor bestimmt die Abstände der Rasterlinien. Die Ausdehnung der Bahn bestimmt die Größe des Rasters. " }, 
{ "title" : "Befehl: Interpolationspunkte anzeigen ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Interpolationspunkte anzeigen ", 
"snippet" : "Interpolationspunkte anzeigen Symbol: Funktion : Der Befehl bewirkt, dass die Anzeige von Interpolationspunkten aktiviert oder deaktiviert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Wenn die Anzeige der Interpolationspunkte aktiviert ist, wird die CNC-Bahn mit Inte...", 
"body" : "Interpolationspunkte anzeigen Symbol: Funktion : Der Befehl bewirkt, dass die Anzeige von Interpolationspunkten aktiviert oder deaktiviert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Wenn die Anzeige der Interpolationspunkte aktiviert ist, wird die CNC-Bahn mit Interpolationspunkten angezeigt. Bei der Ermittlung der Interpolationspunkte wird die Zykluszeit verwendet, die im Dialog der CNC-Einstellungen in der Registerkarte Vorinterpolation eingestellt ist. Außerdem wird berücksichtigt, ob eine CNC-Bahn mit oder ohne Vorverarbeitung im Editor angezeigt wird. " }, 
{ "title" : "Darstellung im grafischen Editor ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html#UUID-043dd64e-e07a-5e2b-2f1d-fc2a843ef4b7_id_be380e1242fa185c0a8640e005adee9_id_d6d5fcd172c9c53cc0a864633c37464d", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Interpolationspunkte anzeigen \/ Darstellung im grafischen Editor ", 
"snippet" : "Ein Interpolationspunkt wird mit einer Linie quer zur Bewegungsrichtung dargestellt. Die Länge der Linie ist proportional zur aktuellen Bahngeschwindigkeit. Auf diese Weise ist eine grobe Abschätzung des Verhaltens der Geschwindigkeit möglich. Langer Abstand und lange Linie Hohe Geschwindigkeit Klei...", 
"body" : "Ein Interpolationspunkt wird mit einer Linie quer zur Bewegungsrichtung dargestellt. Die Länge der Linie ist proportional zur aktuellen Bahngeschwindigkeit. Auf diese Weise ist eine grobe Abschätzung des Verhaltens der Geschwindigkeit möglich. Langer Abstand und lange Linie Hohe Geschwindigkeit Kleiner Abstand und kurze Linie Niedrige Geschwindigkeit Rot Der Interpolator ist in der Verzögerung. Grün Der Interpolator ist in der Beschleunigung. Grau Der Interpolator hat konstante Geschwindigkeit. " }, 
{ "title" : "Befehl: Satzunterdrückung ", 
"url" : "_sm_cmd_cnc_step_suppression.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Satzunterdrückung ", 
"snippet" : "Satzunterdrückung Symbol: Funktion : Der Befehl bewirkt, dass die Satzunterdrückung aktiviert oder deaktiviert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Das CNC-Programm ist als DIN66025 implementiert. Wenn die Satzunterdrückung aktiviert ist, werden im CNC-Progra...", 
"body" : "Satzunterdrückung Symbol: Funktion : Der Befehl bewirkt, dass die Satzunterdrückung aktiviert oder deaktiviert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Das CNC-Programm ist als DIN66025 implementiert. Wenn die Satzunterdrückung aktiviert ist, werden im CNC-Programm Sätze, die mit \/ beginnen, ignoriert. Wenn das CNC-Programm als Tabelle implementiert ist, ist der Befehl nicht verfügbar. " }, 
{ "title" : "Befehl: Programm in ASCII-Datei schreiben ", 
"url" : "_sm_cmd_cnc_write_program_to_ascii_file.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Programm in ASCII-Datei schreiben ", 
"snippet" : "Programm in ASCII-Datei schreiben Funktion : Der Befehl öffnet den Standarddialog zum Speichern einer Datei im Dateisystem. Das CNC-Programm kann als ASCII-Datei abgelegt werden. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Name Initaleinstellung: Name des CNC-Objekts Beis...", 
"body" : "Programm in ASCII-Datei schreiben Funktion : Der Befehl öffnet den Standarddialog zum Speichern einer Datei im Dateisystem. Das CNC-Programm kann als ASCII-Datei abgelegt werden. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Name Initaleinstellung: Name des CNC-Objekts Beispiel: cncSpiral_A Dateityp Dateiendung: TXT , GCODE , CNC " }, 
{ "title" : "Befehl: Vorverarbeitete Bahn anzeigen ", 
"url" : "_sm_cmd_cnc_show_preprocessed_path.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Befehl: Vorverarbeitete Bahn anzeigen ", 
"snippet" : "Vorverarbeitete Bahn anzeigen Symbol: Funktion : Der Befehl bewirkt, dass die Anzeige der CNC-Bahn mit Vorverarbeitung aktiviert oder deaktiviert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Wenn die Anzeige aktiviert ist, wird die Bahn mit Vorverarbeitung dargestell...", 
"body" : "Vorverarbeitete Bahn anzeigen Symbol: Funktion : Der Befehl bewirkt, dass die Anzeige der CNC-Bahn mit Vorverarbeitung aktiviert oder deaktiviert wird. Aufruf : Menü CNC Voraussetzung : Eine CNC-Bahn ist im Editor geöffnet. Wenn die Anzeige aktiviert ist, wird die Bahn mit Vorverarbeitung dargestellt und die Ursprungsbahn wird im Hintergrund hellgrau dargestellt. Die Vorverarbeitung wird im Dialog CNC-Einstellungen , Registerkarte Bahnvorverarbeitung konfiguriert. Die dort konfigurierte Vorverarbeitung wird angezeigt. Damit können Sie die Auswirkung der verschiedenen, in Reihe geschalteten Funktionbausteine auf die Vorverarbeitung simulieren. Der Befehl hat keine Auswirkung auf die Codegenerierung. Auch wenn beim Übersetzen des CNC-Programms eine SMC_OutQueue-Datenstruktur erzeugt wird, hat der Befehl keine Auswirkung auf den Inhalt der Datei. Bei der Übersetzung wird die Vorverarbeitung immer berücksichtigt. " }, 
{ "title" : "Objekt: CNC-Programm ", 
"url" : "_sm_f_reference_object_cnc_program.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Programm ", 
"snippet" : "CNC-Programm...", 
"body" : "CNC-Programm " }, 
{ "title" : "Übersicht ", 
"url" : "_sm_f_reference_object_cnc_program-1561724.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Programm \/ Übersicht ", 
"snippet" : "CODESYS bietet Ihnen die Möglichkeit, CNC-Programme in zwei verschiedenen Editoren zu erstellen: Der Editor für DIN 66025 und der Tabelleneditor. Beide Editoren stellen eine grafische Ansicht der programmierten Bahn zur Verfügung. Während der Programmierung kann zwischen den Editoren gewechselt werd...", 
"body" : "CODESYS bietet Ihnen die Möglichkeit, CNC-Programme in zwei verschiedenen Editoren zu erstellen: Der Editor für DIN 66025 und der Tabelleneditor. Beide Editoren stellen eine grafische Ansicht der programmierten Bahn zur Verfügung. Während der Programmierung kann zwischen den Editoren gewechselt werden - diese kann jedoch zu Verlust von Informationen führen. Die einzelnen Editoren bieten einen unterschiedlichen Umfang an Elementen. Element Editor für DIN 66025 Tabelleneditor Positionierung X X Linie X X Kreisbogen X X Ellipse X X Spline X X Schnelle Positionierung X X M-Funktion X X Parabel X Verwendung von Variablen X Sprung X Koordinatenverschiebung X Satzunterdrückung X Verweilzeit X Zeitsynchronisation mit Interpolator X Für weitere Informationen siehe: Tabelleneditor und Editor für DIN 66025" }, 
{ "title" : "Tabelleneditor ", 
"url" : "_sm_obj_cnc_program_table.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Programm \/ Tabelleneditor ", 
"snippet" : "Im Tabelleneditor werden die Bahnbefehle in einer Tabelle aufgelistet. Sie können die Spalten dieser Tabelle in den CNC-Einstellungen , Registerkarte Tabelleneditor anpassen. Die CNC-Einstellungen hängen als Objekt im Gerätebaum. Standardmäßig werden rechts neben der Tabelle die Eigenschaften des se...", 
"body" : "Im Tabelleneditor werden die Bahnbefehle in einer Tabelle aufgelistet. Sie können die Spalten dieser Tabelle in den CNC-Einstellungen , Registerkarte Tabelleneditor anpassen. Die CNC-Einstellungen hängen als Objekt im Gerätebaum. Standardmäßig werden rechts neben der Tabelle die Eigenschaften des selektierten Bahnelements angezeigt. Diese können dort nicht editiert werden. Wenn Sie eine Zeile selektieren, wird die zugehörige Bewegungsbahn im grafischen Editor rot gezeichnet. Ob Sie bestimmte Eigenschaften eines Bahnelements verändern können, hängt vom Elementtyp ab. Nicht einstellbare Parameter sind ausschraffiert. Mit Drücken von F6 wechselt der Fokus in den grafischen Editor und zurück. Eine Übersicht über die Elemente, die dieser Editor unterstützt, finden Sie im Kapitel CNC-Programm. Für weitere Informationen siehe: Bahn im Tabelleneditor programmieren und Grafischer Editor" }, 
{ "title" : "Editor für DIN 66025 ", 
"url" : "_sm_obj_cnc_program_din66025.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Programm \/ Editor für DIN 66025 ", 
"snippet" : "In diesem Editor geben Sie die Bahnbefehle als CNC-Programm gemäß DIN 66025 ein. Standardmäßig werden rechts die Eigenschaften des selektierten Bahnelementes angezeigt, sind dort aber nicht editierbar. Wenn Sie eine Zeile selektieren, wird die zugehörige Bewegungsbahn im grafischen Editor rot gezeic...", 
"body" : "In diesem Editor geben Sie die Bahnbefehle als CNC-Programm gemäß DIN 66025 ein. Standardmäßig werden rechts die Eigenschaften des selektierten Bahnelementes angezeigt, sind dort aber nicht editierbar. Wenn Sie eine Zeile selektieren, wird die zugehörige Bewegungsbahn im grafischen Editor rot gezeichnet. Mit Drücken von F6 wechselt der Fokus in den grafischen Editor und zurück. Eine Übersicht über die Elemente, die dieser Editor unterstützt, finden Sie im Kapitel CNC-Programm. Bitte beachten, dass Referenzen von globalen Variablen im Decoder-Modul evaluiert werden, wenn der Interpreter die Sätze abarbeitet. Dies kann einige Zyklen im Voraus geschehen, bevor das Objekt abgefahren wird. Für weitere Informationen siehe: Bahn nach DIN 66025 programmieren und CNC-Einstellungen" }, 
{ "title" : "Grafischer Editor ", 
"url" : "_sm_obj_cnc_program_graphical.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Programm \/ Grafischer Editor ", 
"snippet" : "Der graphische Editor befindet sich im unteren Teil des CNC-Tabelleneditors und des Editors für DIN 66025. Der Editor dient der Visualisierung des programmierten CNC-Programms. Der Editor bietet Werkzeuge, um die Bahn zu verändern oder zu erweitern. Aufbau des Editors (1): Tabelleneditor oder Editor...", 
"body" : "Der graphische Editor befindet sich im unteren Teil des CNC-Tabelleneditors und des Editors für DIN 66025. Der Editor dient der Visualisierung des programmierten CNC-Programms. Der Editor bietet Werkzeuge, um die Bahn zu verändern oder zu erweitern. Aufbau des Editors (1): Tabelleneditor oder Editor nach DIN 66025 (2): Ansicht Eigenschaften: Zeigt die Eigenschaften des selektierten Bahnelements (3): Grafischer Editor (4): Bedienfeld: Elemente zur Steuerung der Kameraposition und Blickrichtung (5): Werkzeuge zum Verändern der Bahn Hinweise zum Arbeiten im grafischen Editor Das selektierte Bahnelement wird rot gezeichnet. Die Positionierungskommandos (G0) und Schaltpunktfunktionen werden grün gezeichnet. Ist der Endpunkt eines Elements verschiebbar, wird er als kleiner schwarz umrandeter Kreis gezeichnet. Die Start- und Endtangente werden grau gezeichnet. In der Statuszeile wird die aktuelle Position des selektierten Bahnelements angezeigt. Beachten Sie die CNC-Menübefehle zum Skalieren und Verschieben der gesamten Bahn. Beachten Sie die Beispielprogramme, die in der Installation von CODESYS SoftMotion enthalten sind. " }, 
{ "title" : "Werkeuge ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_0ffa6b2d9c1625bec0a8646341693b76", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Programm \/ Grafischer Editor \/ Werkeuge ", 
"snippet" : "Mit den Werkzeugen können Sie Bewegungsbahnen im grafischen Editor verändern und erweitern. Die Änderungen sind gleichzeitig im Texteditor und im Tabelleneditor sichtbar. Auswählen : Mit diesem Werkzeug selektieren Sie mit einem Mausklick einen Punkt oder ein Bahnelement. Das Element wird dann in ro...", 
"body" : "Mit den Werkzeugen können Sie Bewegungsbahnen im grafischen Editor verändern und erweitern. Die Änderungen sind gleichzeitig im Texteditor und im Tabelleneditor sichtbar. Auswählen : Mit diesem Werkzeug selektieren Sie mit einem Mausklick einen Punkt oder ein Bahnelement. Das Element wird dann in rot mit einem blauen Startpunkt gezeichnet. Der Mauszeiger im grafischen Editor verwandelt sich in einen Zeiger. Linie : Einfügen oder Anhängen einer neuen Linie. Der Mauszeiger im grafischen Editor verwandelt sich in ein Kreuz. Kreis (im Uhrzeigersinn) : Einfügen oder Anhängen eines neuen Kreisbogens im Uhrzeigersinn. Der Mauszeiger im grafischen Editor verwandelt sich in ein Kreuz. Kreis (gegen den Uhrzeigersinn) : Einfügen oder Anhängen eines neuen Kreisbogens gegen den Uhrzeigersinn. Der Mauszeiger im grafischen Editor verwandelt sich in ein Kreuz. Der Spline : Einfügen oder Anhängen eines neuen Spline-Punkts. Der Mauszeiger im grafischen Editor verwandelt sich in ein Kreuz. " }, 
{ "title" : "Kameraposition und Blickrichtung ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_05ff18059c1625bec0a864634ba4f71d", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Programm \/ Grafischer Editor \/ Kameraposition und Blickrichtung ", 
"snippet" : "Die Position und Blickrichtung der Kamera auf die Programmbahn können Sie mit Hilfe der Maus beliebig verändern. Gedrückte linke Maustaste + Mausbewegung: Kameraposition wird in der Darstellungsebene entlang den Achsen verschoben. Gedrückte rechte Maustaste + Mausbewegung: Ansicht auf das CNC-Progra...", 
"body" : "Die Position und Blickrichtung der Kamera auf die Programmbahn können Sie mit Hilfe der Maus beliebig verändern. Gedrückte linke Maustaste + Mausbewegung: Kameraposition wird in der Darstellungsebene entlang den Achsen verschoben. Gedrückte rechte Maustaste + Mausbewegung: Ansicht auf das CNC-Programm wird gedreht. Gedrückte Strg + Mausrad : Änderung des Zoomfaktors. " }, 
{ "title" : "Bedienfeld zum Steuern der Anzeige ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_4693d34dba46042bc0a864633b130501", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Programm \/ Grafischer Editor \/ Bedienfeld zum Steuern der Anzeige ", 
"snippet" : "In der linken oberen Ecke des grafischen Editors stellt ein Bedienfeld verschiedene Kommandos zur Verfügung, um die Ansicht der Bahn zu verändern. Dabei wird die Bahn nicht verändert, sondern nur die Kameraposition und Blickrichtung auf die Bahn. Sie können das Bedienfeld mit einem Klick in den schw...", 
"body" : "In der linken oberen Ecke des grafischen Editors stellt ein Bedienfeld verschiedene Kommandos zur Verfügung, um die Ansicht der Bahn zu verändern. Dabei wird die Bahn nicht verändert, sondern nur die Kameraposition und Blickrichtung auf die Bahn. Sie können das Bedienfeld mit einem Klick in den schwarzen Pfeil einklappen, um die Arbeitsfläche des Editors zu vergrößern. Ein erneuter Klick blendet das Bedienfeld wieder ein. Das Bedienfeld stellt folgende Befehle zur Verfügung, um Orientierung, Position und Zoom einzustellen. Vergrößern Verkleinern Rollwinkel der Kamera im Uhrzeigersinn verändern Rollwinkel der Kamera gegen den Uhrzeigersinn verändern Gierwinkel der Kamera im Uhrzeigersinn verändern Gierwinkel der Kamera gegen den Uhrzeigersinn verändern Kamera im Uhrzeigersinn rotieren Kamera gegen den Uhrzeigersinn rotieren Kamera nach oben bewegen Kamera nach links bewegen Kamera nach rechts bewegen Kamera nach unten bewegen Blickrichtung auf negative z-Achse setzen und neu skalieren Blickrichtung auf x-Achse setzen und neu skalieren Blickrichtung auf y-Achse setzen und neu skalieren " }, 
{ "title" : "Dialog: Eigenschaften CNC ", 
"url" : "_sm_dlg_cnc_program_properties.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Programm \/ Dialog: Eigenschaften CNC ", 
"snippet" : "Symbol: Funktion : Der Dialog stellt Parameter für das Objekt CNC-Programm zur Verfügung. Aufruf : Befehl Ansicht → Eigenschaften , Kontextmenü des Objekts Voraussetzung : Das Objekt CNC ist im Gerätebaum selektiert. Applikationsweite CNC-Einstellungen sind im Objekt CNC-Einstellungen gespeichert....", 
"body" : "Symbol: Funktion : Der Dialog stellt Parameter für das Objekt CNC-Programm zur Verfügung. Aufruf : Befehl Ansicht → Eigenschaften , Kontextmenü des Objekts Voraussetzung : Das Objekt CNC ist im Gerätebaum selektiert. Applikationsweite CNC-Einstellungen sind im Objekt CNC-Einstellungen gespeichert. " }, 
{ "title" : "Registerkarte: Allgemein ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_e398c87e5062d26bc0a86520014051d1", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Programm \/ Dialog: Eigenschaften CNC \/ Registerkarte: Allgemein ", 
"snippet" : "Ändern Sie hier den Namen des CNC-Objekts....", 
"body" : "Ändern Sie hier den Namen des CNC-Objekts. " }, 
{ "title" : "Registerkarte: Zugriffskontrolle ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_6f1287e45062d25bc0a865200009f33d", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Programm \/ Dialog: Eigenschaften CNC \/ Registerkarte: Zugriffskontrolle ", 
"snippet" : "Geben Sie hier die Rechte der Benutzergruppen ein. Für weitere Informationen siehe Eigenschaften - Zugriffskontrolle...", 
"body" : "Geben Sie hier die Rechte der Benutzergruppen ein. Für weitere Informationen siehe Eigenschaften - Zugriffskontrolle " }, 
{ "title" : "Registerkarte: Übersetzen ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_18be1ff163875181c0a865ca014256df", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Programm \/ Dialog: Eigenschaften CNC \/ Registerkarte: Übersetzen ", 
"snippet" : "Aktivieren Sie die Option, um das CNC-Objekt vom Übersetzen auszuschließen. Dann werden keine IEC-Daten generiert. Es ist jedoch möglich, den G-Code als eine ASCII-Datei zu speichern. Wenn Sie so eine Datei zur Laufzeit lesen wollen, können Sie die Funktionsbausteine der Bibliothek SM3_CNC verwenden...", 
"body" : "Aktivieren Sie die Option, um das CNC-Objekt vom Übersetzen auszuschließen. Dann werden keine IEC-Daten generiert. Es ist jedoch möglich, den G-Code als eine ASCII-Datei zu speichern. Wenn Sie so eine Datei zur Laufzeit lesen wollen, können Sie die Funktionsbausteine der Bibliothek SM3_CNC verwenden. Für weitere Informationen siehe Eigenschaften - Zugriffskontrolle " }, 
{ "title" : "Registerkarte: CNC ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Programm \/ Dialog: Eigenschaften CNC \/ Registerkarte: CNC ", 
"snippet" : "Implementation DIN66025 : Die Beschreibung der Bewegungsbahn erfolgt in der CNC-Sprache DIN 66025. Tabelle : Die Beschreibung der Bewegungsbahn erfolgt über die Parametrierung einer Tabelle. Übersetzungsmodus Verhalten beim Kompilieren SMC_OutQueue : Beim Kompilieren wird eine SMC_OutQueue-Datenstru...", 
"body" : "Implementation DIN66025 : Die Beschreibung der Bewegungsbahn erfolgt in der CNC-Sprache DIN 66025. Tabelle : Die Beschreibung der Bewegungsbahn erfolgt über die Parametrierung einer Tabelle. Übersetzungsmodus Verhalten beim Kompilieren SMC_OutQueue : Beim Kompilieren wird eine SMC_OutQueue-Datenstruktur erzeugt. Sie erhalten einen globalen Zugriff über g_CNCQueueManager . SMC_CNC_REF : Beim Kompilieren werden Programmvariabeln erzeugt. Sie erhalten einen globalen Zugriff über g_CNCProgManager . Datei : Eine aus dem G-Code generierte Datei wird erzeugt, die bei jedem Einloggen auf die Steuerung geladen und aktualisiert wird. Die SPS kann diese Datei mit Hilfe von Funktionsbausteinen laden. Die G-Code-Dateien werden mit jedem Einloggen der Applikation aktualisiert. Das bedeutet, dass die Dateien auf der SPS bei jedem Einloggen überschrieben werden. Dateiname Voraussetzung: Übersetzungsmodus ist Datei . Standard: $ObjectName$.cnc . Dieser Standardwert repräsentiert einen Platzhalter, der beim Einloggen durch den Objektnamen des CNC-Objekts (wirksamer Dateiname) ersetzt wird. Wenn Sie einen Dateinamen eingeben, beachten Sie, dass nur die Zeichen [a-zA-Z0-9$_.] für Dateinamen zulässig sind. Das Feld für den Dateinamen darf weder leer sein noch mit einem Punkt anfangen oder enden. Weiterhin muss ein Punkt aber kein Pfad im Dateinamen enthalten sein. Queue-Größe Standard: 100 Die Einstellung der Größe hat keinen Einfluss auf die Größe der generierten SMC_OutQueue -Datenstruktur (wenn dieser Mode angewählt ist). Die Größe von SMC_OutQueue ist nur durch die Anzahl der Pfadobjekte bestimmt. Der Parameter setzt jedoch die Puffergröße der vorverarbeitenden FBs ( wie SMC_NCDecoder , SMC_RoundPath , …), die intern verwendet werden und die Größe des Look ahead beschreiben. Standardwerte Geschwindigkeit (F) [u\/s] Dieser Wert wird verwendet, wenn im CNC-Programm der Wert der Geschwindigkeit (im F-Wort) nicht gesetzt ist. In Wegeinheiten pro Sekunde. Wertebereich: [0, 1e9]. Standard: 0 Beschleunigung (E+) [u\/s²] Dieser Wert wird verwendet, wenn der Wert der Beschleunigung (im E-Wort mit positivem Wert) nicht gesetzt ist. In Wegeinheiten pro Sekunde im Quadrat. Wertebereich: ]0, 1e9]. Standard: 100 Verzögerung (E-) [u\/s²] Dieser Wert wird verwendet, wenn der Wert der Verzögerung (im E-Wort mit negativem Wert) nicht gesetzt ist. In Wegeinheiten pro Sekunde im Quadrat. Wertebereich: ]0, 1e9]. Standard: 100 Standardwerte für schnelle Positionierung (G0) Geschwindigkeit (FF) [u\/s] Dieser Wert wird verwendet, wenn im CNC-Programm der Wert der Geschwindigkeit im Eilgang (im FF-Wort) nicht gesetzt ist. In Wegeinheiten pro Sekunde. Wertebereich: [0, 1e9]. Standard: 0 Beschleunigung (EF+) [u\/s²] Dieser Wert wird verwendet, wenn der Wert der Beschleunigung im Eilgang (im „EF+“-Wort mit positivem Wert) nicht gesetzt ist. In Wegeinheiten pro Sekunde im Quadrat. Wertebereich: [0, 1e9]. Standard: 0 Verzögerung (EF-) [u\/s²] Dieser Wert wird verwendet, wenn der Wert der Verzögerung im Eilgang (im „EF-„-Wort mit negativem Wert) nicht gesetzt ist. In Wegeinheiten pro Sekunde im Quadrat. Wertebereich:[0, 1e9]. Standard: 0 3D-Modus Voraussetzung: Implementierung DIN 66025 , Übersetzungsmodus CNC_REF und OUTQueue : 3D-Modus ist Standardwert. Offlinewerte von Variablen Variablen : Wenn Offlinewerte definiert sind, öffnet sich der Dialog Offlinewerte der Variablen . In diesem Dialog werden Variablen angezeigt und können auch editiert werden. Startposition Standard: 0 Präzision Die Genauigkeit der Bahn in technischen Einheiten. Dieser Wert gibt die Genauigkeit der aus dem G-Code gelesenen Positionen an. Wenn der G-Code beispielsweise mit 3 Nachkommastellen angegeben wird, sollte die Genauigkeit auf 0.001 Einheiten eingestellt werden. Die Genauigkeit darf nicht negativ sein. Dieser Wert wird beispielsweise von Bahnvorverarbeitungen wie SMC_ToolRadiusCorr und SMC_AvoidLoop verwendet. " }, 
{ "title" : "Objekt: CNC-Einstellungen ", 
"url" : "_sm_obj_cnc_settings.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Einstellungen ", 
"snippet" : "CNC-Einstellungen Symbol: Die Einstellungen in diesem Objekt sind für alle CNC-Objekte der Applikation gültig. Das Objekt wird im Gerätebaum der Applikation hinzugefügt oder es wird automatisch erzeugt, wenn der Applikation ein CNC-Objekt hinzugefügt wird. Pro Applikation darf das Objekt nur einmal ...", 
"body" : "CNC-Einstellungen Symbol: Die Einstellungen in diesem Objekt sind für alle CNC-Objekte der Applikation gültig. Das Objekt wird im Gerätebaum der Applikation hinzugefügt oder es wird automatisch erzeugt, wenn der Applikation ein CNC-Objekt hinzugefügt wird. Pro Applikation darf das Objekt nur einmal existieren und kann nicht umbenannt werden. Im Editor des Objekts können Einstellungen für die bahnvorverarbeitenden Module, die Vorinterpolation und den CNC-Tabelleneditor festgelegt werden. Sie können das Objekt CNC-Einstellungen nur löschen, wenn kein CNC-Objekt mehr unter der Applikation existiert. Einstellungen, die nur für ein bestimmtes CNC-Programm gültig sind, werden im Dialog Eigenschaften des CNC-Programms gespeichert. " }, 
{ "title" : "Registerkarte: Bahnvorverarbeitende Module ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_de809dbaa55775c9c0a8646311985883", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Einstellungen \/ Registerkarte: Bahnvorverarbeitende Module ", 
"snippet" : "In der Registerkarte wird die Bahnvorverarbeitung durch die Auswahl der gewünschten Funktionsbausteine programmiert. Verfügbare Funktionsbausteine Auflistung aller verfügbarer Funktionsbausteine Aktive Funktionsbaustein-Instanzen Auflistung der ausgewählten Funktionsbaustein-Instanzen Die Position i...", 
"body" : "In der Registerkarte wird die Bahnvorverarbeitung durch die Auswahl der gewünschten Funktionsbausteine programmiert. Verfügbare Funktionsbausteine Auflistung aller verfügbarer Funktionsbausteine Aktive Funktionsbaustein-Instanzen Auflistung der ausgewählten Funktionsbaustein-Instanzen Die Position in der Liste definiert die Abarbeitungsreihenfolge und kann verändert werden. Ein Funktionsbaustein kann in der Liste mehrmals instanziert werden. Parameter Öffnet den Dialog Parametereditor für <selektierte aktive Funktionsbaustein-Instanz> Alternativ: Doppelkick auf eine aktive Funktionsbaustein-Instanz Fügt der Spalte Aktive Funktionsbaustein-Instanzen eine Instanz des Funktionsbausteins hinzu, der in Aktive Funktionsbaustein-Instanzen selektiert ist Löscht die selektierte Funktionsbaustein-Instanz Funktionsbaustein-Instanzen von Funktionsbausteinen, die kursiv und in hellgrauer Schrift angezeigt werden, können nicht gelöscht werden. Verschiebt die selektierte aktive Funktionsbaustein-Instanz um eine Zeile nach oben Alternativ: Nach-oben-Cursor gleichzeitig mit Umschalttaste Verschiebt die selektierte aktive Funktionsbaustein-Instanz um eine Zeile nach unten Alternativ: Nach-unten-Cursor gleichzeitig mit Umschalttaste Dialog Parametereditor für <selektierte aktive Funktionsbaustein-Instanz> Der Dialog dient zur Anzeige und zur Änderung der Eingänge der selektierten Instanz. Nicht alle Eingänge sind sichtbar. Spalte1 Name des Parameters der selektierten aktiven Funktionsbaustein-Instanz Spalte2 Auswahlliste zur Einstellung des Werts Spalte3 Beschreibung des Parameters " }, 
{ "title" : "Registerkarte: Vorinterpolation ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_9a258724a55775c9c0a8646350128da9", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Einstellungen \/ Registerkarte: Vorinterpolation ", 
"snippet" : "Zykluszeit µs Interpolationszeit Initialwert 20000 Geschwindigkeitsmodus Trapezoid : Geschwindigkeitsprofil mit trapezförmiger Form Sigmoidal : Geschwindigkeitsprofil wie das trapezoidale Profil aber mit sin²-Funktionen, die die linearen Geschwindigkeitsrampen ersetzen Sigmoidal begrenzt : Geschwind...", 
"body" : "Zykluszeit µs Interpolationszeit Initialwert 20000 Geschwindigkeitsmodus Trapezoid : Geschwindigkeitsprofil mit trapezförmiger Form Sigmoidal : Geschwindigkeitsprofil wie das trapezoidale Profil aber mit sin²-Funktionen, die die linearen Geschwindigkeitsrampen ersetzen Sigmoidal begrenzt : Geschwindigkeitsprofil wie das sigmoidale aber unter Beachtung der Grenzen für Beschleunigung und Verzögerung Quadratisch : Beschleunigungsprofil mit trapezförmiger Form mit einer Begrenzung des Rucks, wie in Maximaler Jerk definiert ist. Das sich daraus ergebende quadratische Geschwindigkeitsprofil ist auch als S-Kurve bekannt. Quadratisch (geglättet) : Arbeitet wie Modus Quadratisch aber erzeugt ein Ruckprofil ohne Sprünge. Maximaler Ruck [u\/s³] Begrenzung des absoluten Werts des Rucks Verwendung nur beim quadratischen Geschwindigkeitsprofil Interpolationszeit und Zykluszeit der zugehörigen Task, in der der Interpolator aufgerufen wird, müssen für ein identisches Verhalten von CNC-Editor und Onlineapplikation zusammenpassen. " }, 
{ "title" : "Registerkarte: Tabelleneditor ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_section-idm43260108321858", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion CNC \/ Benutzeroberfläche \/ Objekt: CNC-Einstellungen \/ Registerkarte: Tabelleneditor ", 
"snippet" : "In der Registerkarte werden die Spalten des Tabelleneditors und deren Reihenfolge festgelegt. Tabellenspalten Auflistung aller verfügbarer Attribute : Das Attribut ist im Tabelleneditor sichtbar. Die Reihenfolge der Zeilen im Tabelleneditor wird durch die Reihenfolge in dieser Auflistung festgelegt....", 
"body" : "In der Registerkarte werden die Spalten des Tabelleneditors und deren Reihenfolge festgelegt. Tabellenspalten Auflistung aller verfügbarer Attribute : Das Attribut ist im Tabelleneditor sichtbar. Die Reihenfolge der Zeilen im Tabelleneditor wird durch die Reihenfolge in dieser Auflistung festgelegt. Verschiebt das selektierte Attribut um eine Zeile nach oben Verschiebt das selektierte Attribut um eine Zeile nach unten " }, 
{ "title" : "CODESYS SoftMotion Robotik ", 
"url" : "_sm_f_robotics.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Übersicht ", 
"url" : "_sm_overview_robotics.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Übersicht ", 
"snippet" : "CODESYS SoftMotion Robotics bietet eine Funktionsbausteinschnittstelle zur Bewegungssteuerung von Robotern, basierend auf der PLCopen-Spezifikation \"Function blocks for motion control Part 4\". Komplexe Bewegungsabläufe lassen sich aus einfachen Point-to-Point- oder Continuous-Path-Bewegungen, wie Ge...", 
"body" : "CODESYS SoftMotion Robotics bietet eine Funktionsbausteinschnittstelle zur Bewegungssteuerung von Robotern, basierend auf der PLCopen-Spezifikation \"Function blocks for motion control Part 4\". Komplexe Bewegungsabläufe lassen sich aus einfachen Point-to-Point- oder Continuous-Path-Bewegungen, wie Geraden oder Kreisbögen, zusammensetzen. Zwischen den Einzelbewegungen kann konfigurierbar, beispielsweise distanz- oder geschwindigkeitsbasiert, überschliffen werden. Geschwindigkeits-, Beschleunigungs- und Ruckgrenzen, sowohl der einzelnen Achsen als auch auf der Bahn, werden berücksichtigt. Die Trajektorienplanung erfolgt online auf der CODESYS -Steuerung, parallel zur Ausführung der Bewegung. Neue Bewegungen lassen sich zur Ausführungszeit und ohne Anhalten des Roboters anhängen. Kinematische Modelle für verschiedene Standardroboter, vom einfachen Portal, über Delta- und Scara-Roboter, bis hin zu typischen Sechsachsindustrierobotern, sind Teil des Lieferumfangs. Selbst entwickelte kinematische Modelle für Spezialmaschinen lassen sich in Form eines IEC 61131-3 Funktionsbausteins anbinden. Analog dazu ermöglicht eine Schnittstelle die Anbindung dynamischer Modelle, durch die eine Beschränkung der auftretenden Kräfte und Drehmomente sowie eine Drehmomentvorsteuerung ermöglicht wird. Weitere Funktionsbausteine erlauben die einfache Umsetzung typischer Anwendungsfälle. Dazu gehören die Synchronisation mit beweglichen Koordinatensystemen, das Unterbrechen- und Fortsetzen von Bewegungen oder die Ansteuerung hochpräziser digitaler Ausgänge über Bahnschaltpunkte. " }, 
{ "title" : "Erste Schritte ", 
"url" : "_sm_robotics_first_steps.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Erste Schritte ", 
"snippet" : "Um die Achsbewegungen für einen Roboter zu programmieren, müssen Sie zunächst in Ihrem Projekt unter der Applikation eine Achsgruppe anlegen. Sehen Sie dazu: How-To: Achsgruppe anlegen. Die angelegte Achsgruppe konfigurieren Sie mit den gewünschten Kinematiken. Sie fügen reale oder virtuelle Achsen ...", 
"body" : "Um die Achsbewegungen für einen Roboter zu programmieren, müssen Sie zunächst in Ihrem Projekt unter der Applikation eine Achsgruppe anlegen. Sehen Sie dazu: How-To: Achsgruppe anlegen. Die angelegte Achsgruppe konfigurieren Sie mit den gewünschten Kinematiken. Sie fügen reale oder virtuelle Achsen unter dem Gerät ein und verknüpfen diese Achsen mit der Achsgruppe. Sehen Sie hierzu die Hilfeseiten unter Kinematiken: Zustände der AchsgruppeKombination von Positionier- und OrientierungskinematikenDrehgelenke und Modulo-AchsenRotatorische Achsen mit einem Wertebereich von mehr als 360°Wie sie nach dem Anlegen und Konfigurieren der Achsen ein Programm für die Achssteuerung erzeugen, sehen Sie exemplarisch hier: How-To: Programm zur Steuerung der Achsgruppe erstellenInformationen zum Umsetzen der verschiedenen Anforderungen bei der Bewegungssteuerung finden Sie auf den weiteren Hilfeseiten unter Bewegungssteuerung . Puffern und Überschleifen von BewegungenTippbetrieb von AchsgruppenUnterbrechen und Fortsetzen von BewegungenSynchronisation mit einem beweglichen KoordinatensystemWerkzeugversatz konfigurierenHintergrundinformationen zum Verständnis, wie bestimmte Bewegungen ausgeführt werden, finden Sie hier: Orientierungsinterpolation bei CP-BewegungenFür fortgeschrittene Anwender: Drehmomentbegrenzung und DrehmomentvorsteuerungErstellen eigener Kinematiken" }, 
{ "title" : "Achsgruppe ", 
"url" : "_sm_robotics_axis_group.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Achsgruppe ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "How-To: Achsgruppe anlegen ", 
"url" : "_sm_creating_an_axis_group.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Achsgruppe \/ How-To: Achsgruppe anlegen ", 
"snippet" : "Hinzufügen der Objekte im Gerätebaum Die nachfolgende Anweisung beschreibt exemplarisch das Anlegen und Konfigurieren einer Achsgruppe. Legen Sie ein neues Standardprojekt mit CODESYS Control an. Wählen Sie dabei für den Baustein PLC_PRG die Implementierungssprache CFC. Öffnen Sie das Kontextmenü de...", 
"body" : "Hinzufügen der Objekte im Gerätebaum Die nachfolgende Anweisung beschreibt exemplarisch das Anlegen und Konfigurieren einer Achsgruppe. Legen Sie ein neues Standardprojekt mit CODESYS Control an. Wählen Sie dabei für den Baustein PLC_PRG die Implementierungssprache CFC. Öffnen Sie das Kontextmenü des Objekts Device im Gerätebaum und wählen Sie den Befehl SoftMotion aktivieren aus. Unter dem Device wird ein Objekt SoftMotion General Axis Pool eingefügt. Selektieren Sie SoftMotion General Axis Pool im Gerätebaum. Wählen Sie den Befehl Gerät anhängen aus dem Kontextmenü. Der Dialog Gerät anhängen öffnet sich. Wählen Sie das Gerät SM_Drive_Virtual aus. Geben Sie dem Gerät den Namen „DriveX“. Fügen Sie auf dieselbe Weise zwei weitere Antriebe „DriveY“ und „DriveZ“ ein. Öffnen Sie das Kontextmenü des Objekts Application im Gerätebaum aus und wählen Sie den Befehl Projekt → Objekt hinzufügen → Achsgruppe aus. Fügen Sie das Objekt mit dem vorgegebenen Namen AxisGroup ein. Das Objekt Achsgruppe wird unterhalb der Applikation eingefügt. Der Achsgruppenkonfigurator öffnet sich. Klicken Sie im Konfigurationseditor auf die Schaltfläche Kinematik wählen . Der Dialog Kinematik wählen öffnet sich mit einer Liste aller verfügbaren Kinematikbausteine und deren Beschreibungen. Wählen Sie die Kinematik TRAFO.Kin_Gantry3 aus. Der Konfigurationseditor für die gewählte Kinematik öffnet sich. Weisen Sie in der Parametergruppe Achszuordnung den Achsen die im Projekt verwendeten Antriebe zu. Geben Sie dazu im Eingabefeld X den Wert DriveX , im Eingabefeld Y den Wert DriveY und im Eingabefeld Z den Wert DriveZ ein. Sie können den Antrieb auch über die Eingabeunterstützung auswählen oder per Drag-and-drop aus dem Gerätebaum in das Eingabefeld ziehen. Für weitere Informationen siehe: Achsgruppeneditor" }, 
{ "title" : "Achsgruppeneditor ", 
"url" : "_sm_obj_axis_group.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Achsgruppe \/ Achsgruppeneditor ", 
"snippet" : "Symbol: Im Editor des Objekts Achsgruppe wählen Sie die Art der Grundkinematik und der Orientierungskinematik aus. Eine Orientierungskinematik kann jedoch nur ausgewählt werden, wenn dies von der Grundkinematik unterstützt wird. Weiterhin bilden Sie die Achsen der Kinematik auf die Antriebe in Ihrem...", 
"body" : "Symbol: Im Editor des Objekts Achsgruppe wählen Sie die Art der Grundkinematik und der Orientierungskinematik aus. Eine Orientierungskinematik kann jedoch nur ausgewählt werden, wenn dies von der Grundkinematik unterstützt wird. Weiterhin bilden Sie die Achsen der Kinematik auf die Antriebe in Ihrem Projekt ab. Kinematik Kinematik auswählen Kinematik ändern Öffnet eine Liste aller von CODESYS unterstützten Kinematiken Wenn Sie eine Kinematik selektieren, wird eine Kurzbeschreibung im Fenster rechts daneben angezeigt. Wenn Sie eine Kinematik ausgewählt haben, können Sie die entsprechenden Parameter im Editor verändern. Orientierungskinematik Kinematik auswählen Kinematik ändern Öffnet eine Liste aller von CODESYS unterstützten Orientierungskinematiken Wenn Sie eine Kinematik selektieren, wird eine Kurzbeschreibung im Fenster rechts daneben angezeigt. Wenn Sie eine Kinematik ausgewählt haben, können Sie die entsprechenden Parameter im Editor verändern. Achszuordnung Abhängig von der gewählten Kinematik bilden Sie die Achsen der Kinematik auf die Antriebe in Ihrem Projekt ab. Zusätzliche Achsen Achse hinzufügen Fügt ein Konfigurationsfeld für eine Zusatzachse hinzu. In diesem Konfigurationsfeld wird der Antrieb aus dem Projekt eingetragen. Tasks Buszyklustask Buszyklustask der Achsen, falls bereits Achsen zugeordnet sind Die Einstellung kann hier nicht verändert werden. Planungstask Task für die Planung von CP-Aufgaben Mit dem Einfügen der ersten Achsgruppe wird automatische eine Planungstask angelegt. Es sollte kein Watchdog konfiguriert sein, da die Ausführungszeit stark schwanken kann. Für weitere Informationen siehe: Konfiguration der PlanungstaskWenn Sie diese Task löschen, wird ein Fehler im Meldungsfenster ausgegeben. Sie können dann über den Befehl Projekt → Planungstask erzeugen eine neue Task erzeugen lassen. Für weitere Informationen siehe: How-To: Achsgruppe anlegen" }, 
{ "title" : "Zustände der Achsgruppe ", 
"url" : "_sm_robotics_state_machine.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Achsgruppe \/ Zustände der Achsgruppe ", 
"snippet" : "Die nachfolgende Grafik zeigt die möglichen Zustände der Achsgruppe und die Übergänge zwischen den Zuständen. Die Fehler einzelner Achsen führen die Achsgruppe immer in den Zustand GroupErrorStop Wenn die Achsgruppe in den Zustand GroupMoving schaltet, werden alle Achsen in SynchronizedMotion gescha...", 
"body" : "Die nachfolgende Grafik zeigt die möglichen Zustände der Achsgruppe und die Übergänge zwischen den Zuständen. Die Fehler einzelner Achsen führen die Achsgruppe immer in den Zustand GroupErrorStop Wenn die Achsgruppe in den Zustand GroupMoving schaltet, werden alle Achsen in SynchronizedMotion geschaltet Wenn die Achsgruppe von GroupMoving nach GroupStandby schaltet, werden alle Achsen in standstill geschaltet Wenn die Achsgruppe von GroupMoving nach GroupErrorStop schaltet, werden alle Achsen in GroupErrorStop geschaltet Wenn die Achsgruppe in GroupStandby ist, sind die Einzelachsen nicht unbedingt alle in standstill , da sie durch Einzelachsbewegungs-Funktionsbausteine wie MC_Jog gesteuert werden können. Wenn eine Bewegung mit Fehler beendet wird, dann werden alle gepufferten Folgebewegungen mit CommandAborted abgebrochen Solange die Achsgruppe einem dynamischen Koordinatensystem folgt, bleibt sie in GroupMoving Die Achsgruppe ist im Zustand GroupMoving genau dann, wenn die Gruppe koordiniert bewegt wird, also durch einen der Bewegungsbausteine von Part 4. Das Umschalten von GroupMoving in GroupStandby erfolgt einen Zyklus nach der letzten Positionsänderung. " }, 
{ "title" : "Konfiguration der Planungstask ", 
"url" : "_sm_configuration_planning_task.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Achsgruppe \/ Konfiguration der Planungstask ", 
"snippet" : "Die Bewegungsplanung der Achsgruppe wird in einer eigenen Task durchgeführt, die beim Einfügen einer Achsgruppe automatisch mit dem Namen \"SoftMotion_PlanningTask\" angelegt wird. Standardmäßig läuft diese Planungstask auf demselben Prozessorkern wie die Bustask. Auf Multicore-Systemen ist es empfehl...", 
"body" : "Die Bewegungsplanung der Achsgruppe wird in einer eigenen Task durchgeführt, die beim Einfügen einer Achsgruppe automatisch mit dem Namen \"SoftMotion_PlanningTask\" angelegt wird. Standardmäßig läuft diese Planungstask auf demselben Prozessorkern wie die Bustask. Auf Multicore-Systemen ist es empfehlenswert, sie auf einen eigenen Kern zu legen. Abhängig davon, ob die Planungstask auf einem eigenen Kern läuft oder nicht, sollte sie unterschiedlich konfiguriert werden. Single-Core Läuft die Planungstask auf demselben Kern wie die Bustask, sollte sie als freilaufende Task mit niedriger Echtzeit-Priorität konfiguriert werden. Das ist standardmäßig der Fall, die Planungstask wird automatisch als freilaufende Task mit Priorität 15 angelegt. Multi-Core Auf Multi-Core-Systemen sollte die Planungstask auf einem eigenen Core mit höchster Priorität (0) laufen. Der Tasktyp sollte auf zyklisch und das Taskintervall auf einen niedrigen Wert von beispielsweise 2ms gestellt werden. Mit diesen Einstellungen wird die Planungstask ihr Taskintervall immer wieder überschreiten. Das ist zu erwarten und stellt kein Problem dar. Die Taskeinstellungen werden so gewählt, um sicherzustellen, dass die Planungstask nach einem Durchlauf sofort wieder aufgerufen wird. Dadurch wird der dedizierte Kern für die Bewegungsplanung möglichst voll ausgenutzt. Für weitere Informationen zur Taskkonfiguration siehe: Taskkonfiguration Objekt: Taskkonfiguration Objekt: Task " }, 
{ "title" : "Kinematiken ", 
"url" : "_sm_robotics_kinematics.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Übersicht ", 
"url" : "_sm_overview_kinematics.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Übersicht ", 
"snippet" : "Eine der wichtigsten Aufgaben in der Robotik ist es, ein Werkzeug, beispielsweise einen Greifer oder eine Schweißpistole, auf einer vorgegebenen Bahn zu bewegen. Dazu berechnet CODESYS SoftMotion Robotics , wie sich die einzelnen Gelenke des Roboters bewegen müssen, damit die Werkzeugspitze, der Too...", 
"body" : "Eine der wichtigsten Aufgaben in der Robotik ist es, ein Werkzeug, beispielsweise einen Greifer oder eine Schweißpistole, auf einer vorgegebenen Bahn zu bewegen. Dazu berechnet CODESYS SoftMotion Robotics , wie sich die einzelnen Gelenke des Roboters bewegen müssen, damit die Werkzeugspitze, der Tool Center Point (TCP), der kommandierten Bahn mit der gewünschten Orientierung folgt. Zentral für diese Berechnung ist die Kinematik oder kinematische Transformation. Sie implementiert die Umrechnung von Gelenkpositionen auf TCP-Position und TCP-Orientierung und umgekehrt. Die Berechnungsvorschrift unterscheidet sich je nach verwendetem Robotertyp. CODESYS SoftMotion Robotics enthält konfigurierbare Kinematiken für zahlreiche Standardroboter. Für weitere Informationen siehe: In Die Kinematiken sind in Positionier- und Orientierungskinematiken aufgeteilt, die sich kombinieren lassen. Für weitere Informationen siehe: Kombination von Positionier- und OrientierungskinematikenEs kann ein Werkzeugversatz konfiguriert werden, der zur Laufzeit verändert werden kann. Für weitere Informationen siehe: Werkzeugversatz konfigurierenBei Drehgelenken werden endlos drehende Modulo-Achsen unterstützt. Für weitere Informationen siehe: Drehgelenke und Modulo-AchsenFür spezielle Robotertypen, deren Berechnungsvorschrift nicht durch eine der mitgelieferten Kinematiken abgebildet werden kann, kann eine eigene Kinematik in Form eines Funktionsbausteins implementiert werden. Für weitere Informationen siehe: Erstellen eigener Kinematiken" }, 
{ "title" : "In CODESYS SoftMotion enthaltene Kinematiken ", 
"url" : "_sm_robotics_cds_sm_kinematics.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ In CODESYS SoftMotion enthaltene Kinematiken ", 
"snippet" : "Portalsysteme Name Darstellung Verknüpfbar mit einer Orientierungskinematik Weiterführende Informationen Gantry2 ✓ Kin_Gantry2 (FB) Gantry3 ✓ Kin_Gantry3 (FB) HGantry2 ✓ Kin_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ Kin_TGantry2 (FB) 5-Achs-Gantry -- Kin_5Axes (FB) SCARA-Systeme Name Dar...", 
"body" : "Portalsysteme Name Darstellung Verknüpfbar mit einer Orientierungskinematik Weiterführende Informationen Gantry2 ✓ Kin_Gantry2 (FB) Gantry3 ✓ Kin_Gantry3 (FB) HGantry2 ✓ Kin_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ Kin_TGantry2 (FB) 5-Achs-Gantry -- Kin_5Axes (FB) SCARA-Systeme Name Darstellung Verknüpfbar mit einer Orientierungskinematik Weiterführende Informationen Polar ✓ Kin_Polar (FB) Polar mit Z-Achse ✓ Kin_Polar_Z (FB) Scara2 mit Z-Achse ✓ Kin_Scara2_Z (FB) Scara3 mit Z-Achse -- Kin_Scara3_Z (FB) Knickarmroboter Name Darstellung Verknüpfbar mit einer Orientierungskinematik Weiterführende Informationen Knickarmroboter mit 3 rotatorischen Achsen ✓ Kin_Pos_RRR (FB) 4-Achs-Palletierer -- Kin_4AxesPalletizer (FB) 6-Achs-Knickarmroboter -- Kin_ArticulatedRobot_6DOF (FB) Parallele Systeme Name Darstellung Verknüpfbar mit einer Orientierungskinematik Weiterführende Informationen Bipod mit rotatorischen Achsen ✓ Kin_Bipod_Rotary (FB) Tripod mit rotatorischen Achsen ✓ Kin_Tripod_Rotary (FB) Tripod mit linearen Achsen ✓ Kin_Tripod_Linear (FB) Orientierungskinematik Name Darstellung Weiterführende Informationen C-Achse Kin_CAxis (FB) C-Achse mit Werkzeug Kin_CAxis_Tool (FB) Werkzeug Kin_Tool (FB) Wrist2 Kin_Wrist2 (FB) Wrist3 Kin_Wrist3 (FB) " }, 
{ "title" : "Kombination von Positionier- und Orientierungskinematiken ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Kombination von Positionier- und Orientierungskinematiken ", 
"snippet" : "Mit dem Achsgruppenkonfigurator können Sie Positionierkinematiken und Orientierungskinematiken kombinieren. Dadurch kann mit einer kleinen Anzahl von Kinematiken eine große Vielfalt an Robotern konfiguriert werden. Beispiele für Positionierkinematiken sind Portale ( Kin_Gantry3 ) oder Tripoden ( Kin...", 
"body" : "Mit dem Achsgruppenkonfigurator können Sie Positionierkinematiken und Orientierungskinematiken kombinieren. Dadurch kann mit einer kleinen Anzahl von Kinematiken eine große Vielfalt an Robotern konfiguriert werden. Beispiele für Positionierkinematiken sind Portale ( Kin_Gantry3 ) oder Tripoden ( Kin_Tripod_Lin , Kin_Tripod_Rotary ). Diese Kinematiken können eine beliebige Position anfahren, nicht aber beliebige Orientierungen herbeiführen. Das vorderste Koordinatensystem einer Positionierkinematik bezeichnen wir als Flanschkoordinatensystem. Es definiert die Stelle, an der eine Orientierungskinematik befestigt wird (linke Abbildung). Beispiele für Orientierungskinematiken sind Kin_CAxis , Kin_Wrist2 und Kin_Wrist3 . Diese Kinematiken können eine gewünschte Orientierung des TCP herbeiführen, aber nicht eine beliebige Position erreichen (rechte Abbildung). Durch die Kombination einer Positionierkinematik mit einer Orientierungskinematik wird es möglich, beliebige Positionen innerhalb der gewünschten Orientierung anzufahren und umgekehrt. Anmerkungen für selbst erstellte Kinematiken Anwender, die selbst Positionier- oder Orientierungskinematiken erstellen wollen, müssen bei ihren Kinematik-Funktionsbausteinen folgende zusätzliche Schnittstellen umsetzen: Für Positionierkinematiken: Die Schnittstelle ISMPositionKinematics2 mit den Methoden AxesToOrientation und GetOrientationImage . AxesToOrientation ist eine „abgekürzte“ Vorwärtstransformation, die die Orientierung des Flanschkoordinatensystems aus den Achswerten berechnet. Sie ist nur aus Effizienzgründen nötig, da beispielsweise bei einem Portal hier nichts gerechnet werden muss, sondern eine konstante Orientierung zurückgegeben werden kann. GetOrientationImage gibt zurück, wie sich die Orientierung des Flanschkoordinatensystems verändern kann. Diese Methode ist nur für die Prüfung nötig, ob eine Orientierungskinematik mit der Positionierkinematik kompatibel ist. Für Orientierungskinematken: Die Schnittstelle ISMToolKinematics2 mit den Methoden GetPositionFromOrientation2 und IsCompatibleWithPosKin . GetPositionFromOrientation2 berechnet den Vektor zwischen dem Flanschkoordinatensystem und dem TCP aus der gewünschten Orientierung (im MCS). Diese Berechnung ist für die Rückwärtstransformation der kombinierten Kinematik nötig. Die Methode IsCompatibleWithPosKin prüft, ob die Orientierungskinematik mit der Positionierkinematik kompatibel ist. " }, 
{ "title" : "Ungültige Kombinationen ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_718d71abf014b14bc0a864635271f262", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Kombination von Positionier- und Orientierungskinematiken \/ Ungültige Kombinationen ", 
"snippet" : "Nicht jede Kombination einer Positionierkinematik mit einer Orientierungskinematik ist möglich, da manchmal die Rückwärtstransformation nicht eindeutig bestimmt werden kann. Ein Beispiel ist ein Scara mit zwei Gelenken als Positionierkinematik und Kin_CAxis_Tool als Orientierungskinematik mit einem ...", 
"body" : "Nicht jede Kombination einer Positionierkinematik mit einer Orientierungskinematik ist möglich, da manchmal die Rückwärtstransformation nicht eindeutig bestimmt werden kann. Ein Beispiel ist ein Scara mit zwei Gelenken als Positionierkinematik und Kin_CAxis_Tool als Orientierungskinematik mit einem Tool-Offset, der in der X- oder Y-Koordinate nicht 0 ist. Die Orientierung des Flansch-Koordinatensystems des Scaras ist nicht konstant. Sie ist gegenüber der 0-Stellung um die Z-Achse gedreht. Für die Berechnung der Rückwärtstransformation ist diese Drehung noch nicht bekannt, was die eindeutige Bestimmung der Achswinkel in diesem Fall unmöglich macht. Ob eine Kombination möglich ist, kann erst zur Laufzeit geprüft werden, da es von der Parametrierung der Kinematiken abhängt. In diesem Fall wird der Fehler SMC_TRAFO_INVALID_COUPLING angezeigt. " }, 
{ "title" : "Verhalten bei Programmierung von „unmöglichen“ Orientierungen ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_5ba01e61f014b14bc0a86463044fcdf7", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Kombination von Positionier- und Orientierungskinematiken \/ Verhalten bei Programmierung von „unmöglichen“ Orientierungen ", 
"snippet" : "In der Praxis ist es oft nützlich, wenn man Orientierungen programmieren kann, die für die Kinematik eigentlich nicht erreichbar sind. Als einfaches Beispiel betrachten wir einen Scara-Roboter zusammen mit einem Werkzeug mit 1 Freiheitsgrad (Drehung um Z). Dieser Roboter kann prinzipiell nur Orienti...", 
"body" : "In der Praxis ist es oft nützlich, wenn man Orientierungen programmieren kann, die für die Kinematik eigentlich nicht erreichbar sind. Als einfaches Beispiel betrachten wir einen Scara-Roboter zusammen mit einem Werkzeug mit 1 Freiheitsgrad (Drehung um Z). Dieser Roboter kann prinzipiell nur Orientierungen annehmen, bei denen das Werkzeug senkrecht nach unten zeigt. Wenn Positionen auf einem Werkstück angefahren werden sollen, wird dieses leicht aus der X\/Y-Ebene heraus verkippt. Der Anwender teacht das Werkstück und programmiert dann die Positionen und Orientierungen relativ zum Werkstück. Durch die Verkippung des Werkstücks ergeben sich Orientierungen, bei denen die Werkzeugrichtung leicht aus der Senkrechten verkippt ist. Wie gehen wir mit einer solchen „unmöglichen“, das heißt unerreichbaren Orientierung um? Eine drastische Maßnahme wäre die Meldung einer Arbeitsraumverletzung. Das würde aber, wie das Beispiel zeigt, die Programmierung mühsam machen. Daher sind die Orientierungskinematiken ( im Beispiel Kin_CAxis_Tool ) so umgesetzt, dass sie die nächstgelegene erreichbare Orientierung annehmen. Im Beispiel bedeutet das: Die kommandierte Orientierung wird so gekippt, dass das Werkzeug senkrecht steht, und diese Orientierung wird dann angenommen. Das Verhalten kann auf folgende Regeln reduziert werden (vorausgesetzt die Positionierkinematik kann in allen drei Raumrichtungen positionieren): Die Position wird immer exakt angefahren (ansonsten wird ein Fehler gemeldet). Die Orientierung wird, falls nicht erreichbar, auf die nächstgelegene erreichbare „projiziert“. Bei der Projektion der Orientierung hat die Werkzeugrichtung Vorrang. Die hier geschilderten Schwierigkeiten treten auf, weil die Orientierungskinematik nicht die drei Freiheitsgrade hat, um alle gewünschten Orientierungen zu erreichen. Dies ist bei Kin_Wrist2 und Kin_CAxis der Fall, aber nicht bei Kin_Wrist3 . Weitere Schwierigkeiten gibt es, wenn zusätzlich die Positionierkinematik nicht alle Freiheitsgrade im Raum hat. (Dies kommt in der Praxis nicht häufig vor.) Ein Beispiel ist die Kombination von Kin_Gantry2 , einem Portal, das nur in X\/Y positionieren kann, mit Kin_Wrist2 , einem Werkzeug mit nur zwei Freiheitsgraden. In diesem Fall gibt es sowohl unmögliche Orientierungen als auch unmögliche Positionen, da die Z-Koordinate durch die Werkzeuglänge und die Stellung der Orientierungsachse bereits festgelegt ist. Daher empfehlen wir, solche Kombinationen nicht zu verwenden, oder in diesem Fall nur erreichbare Positionen zu programmieren. " }, 
{ "title" : "Konfigurationen von Kinematiken ", 
"url" : "_sm_configure_kinematics.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Konfigurationen von Kinematiken ", 
"snippet" : "Eine Kinematikkonfiguration beschreibt die Anordnung der Achsen einer Achsgruppe zueinander. Je nach Kinematik sind bei gleicher TCP-Position mehrere Konfigurationen möglich. Am Beispiel des Scara 2 sind zwei mögliche Konfigurationen dargestellt. Die Achsgruppe hat eine aktive Konfiguration, die nic...", 
"body" : "Eine Kinematikkonfiguration beschreibt die Anordnung der Achsen einer Achsgruppe zueinander. Je nach Kinematik sind bei gleicher TCP-Position mehrere Konfigurationen möglich. Am Beispiel des Scara 2 sind zwei mögliche Konfigurationen dargestellt. Die Achsgruppe hat eine aktive Konfiguration, die nicht zwingend den aktuellen Achsstellungen entsprechen muss. Wenn eine Bewegung kommandiert wird, dann wird die Zielposition gegebenenfalls in Achskoordinaten umgewandelt. Dafür wird die zum Zeitpunkt der Kommandierung aktive Konfiguration verwendet. Diese aktive Konfiguration kann mit dem Funktionsbaustein SMC_SetKinConfiguration gesetzt werden. Bei der Initialisierung und bei jeder Änderung der Kinematik nimmt die Achsgruppe die Standardkonfiguration der Kinematik an. Jede Kinematik mit Konfiguration bringt eine Standardkonfiguration mit. Eine CP-Bewegung zwischen zwei Konfigurationen ist nicht möglich. In diesem Fall muss die Positionierung über eine PTP-Bewegung erfolgen. Die aktuelle Konfiguration kann mit dem Funktionsbaustein MC_GroupReadActualPosition ermittelt werden. " }, 
{ "title" : "Konfiguration für eine Kinematik setzen ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b2318eb4acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Konfigurationen von Kinematiken \/ Konfiguration für eine Kinematik setzen ", 
"snippet" : "Jede Kinematik mit Konfiguration hat einen eigenen Baustein zum Berechnen der Konfigurationsdaten. Der Name dieses Funktionsbausteins entspricht dem Namen der Kinematik plus Postfix _config . Der Baustein wandelt die verschiedenen Konfigurationen in den Datentyp ConfigData um. Dieser Datentyp wird d...", 
"body" : "Jede Kinematik mit Konfiguration hat einen eigenen Baustein zum Berechnen der Konfigurationsdaten. Der Name dieses Funktionsbausteins entspricht dem Namen der Kinematik plus Postfix _config . Der Baustein wandelt die verschiedenen Konfigurationen in den Datentyp ConfigData um. Dieser Datentyp wird dem Funktionsbaustein SMC_SetKinConfiguration übergeben. Beispiel: Konfiguration setzen für eine Scara 2 Kinematik Aufruf des Funktionsbausteins Kin_Scara2_Z_Config aus der Bibliothek SM3_Transformation . Eingang xElbowRight = TRUE Funktionsbaustein liefert die Konfigurationsdaten vom Datentyp ConfigData zurück. Aufruf des Funktionsbausteins SMC_SetKinConfiguration aus der Bibliothek SM3_Robotics . Eingang ConfigData mit den vorher ermittelten Konfigurationsdaten belegen. Die aktive Konfiguration des Scara 2 ist gesetzt. VAR\n config: TRAFO.Kin_Scara2_Z_Config;\n skc: SMC_SetKinConfiguration;\nEND_VAR\n\nconfig(xElbowRight := TRUE);\nskc(AxisGroup := Scara2, Execute := TRUE, ConfigData := config.Config); " }, 
{ "title" : "Behandlung von gekoppelten Kinematiken ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b22c1067acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Konfigurationen von Kinematiken \/ Behandlung von gekoppelten Kinematiken ", 
"snippet" : "Eine gekoppelte Kinematik liegt vor, wenn gleichzeitig eine Positionierkinematik und eine Orientierungskinematik verwendet werden. In diesem Fall ergibt sich die „gekoppelte“ Konfiguration aus den beiden einzelnen Konfigurationen durch den Aufruf von Kin_Coupled_Config aus der Bibliothek SM3_Transfo...", 
"body" : "Eine gekoppelte Kinematik liegt vor, wenn gleichzeitig eine Positionierkinematik und eine Orientierungskinematik verwendet werden. In diesem Fall ergibt sich die „gekoppelte“ Konfiguration aus den beiden einzelnen Konfigurationen durch den Aufruf von Kin_Coupled_Config aus der Bibliothek SM3_Transformation . Dabei werden dem Funktionsbaustein an den Eingängen die Konfiguration der Positionierkinematik und der Orientierungskinematik zur Verfügung gestellt. Für weitere Informationen siehe: Rotatorische Achsen mit einem Wertebereich von mehr als 360°" }, 
{ "title" : "Werkzeugversatz konfigurieren ", 
"url" : "_sm_configure_tool_offset.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Werkzeugversatz konfigurieren ", 
"snippet" : "Sie können den Versatz zwischen dem Flanschkoordinatensystem der Kinematik (XYZ) und dem TCP-Koordinatensystem der Kinematik (X’Y’Z‘) durch Konfiguration eines Werkzeugversatzes (Tooloffset) einstellen. Dieser Werkzeugversatz wirkt auf alle nachfolgenden Bewegungen. TCP: Tool Center Point Der Werkze...", 
"body" : "Sie können den Versatz zwischen dem Flanschkoordinatensystem der Kinematik (XYZ) und dem TCP-Koordinatensystem der Kinematik (X’Y’Z‘) durch Konfiguration eines Werkzeugversatzes (Tooloffset) einstellen. Dieser Werkzeugversatz wirkt auf alle nachfolgenden Bewegungen. TCP: Tool Center Point Der Werkzeugversatz wird durch eine Verschiebung v=(x,y,z) und eine Drehung r=(A,B,C) in ZYZ-Eulerwinkeln vorgegeben. Verschiebung und Drehung werden relativ zum Flanschkoordinatensystem der Kinematik ausgedrückt. Wenn Sie einen Werkzeugversatz konfigurieren, kann dieser inkompatibel zur aktuellen Kinematik sein. So kann ein Werkzeugversatz dazu führen, dass die Kinematik Orientierungen nicht erreichen kann. In dieser Situation wird ein Fehler zurückgemeldet und der Werkzeugversatz wird ignoriert. Beispielsweise können Sie für die Kinematik Kin_Scara2_Z einen Werkzeugversatz in Z-Richtung konfigurieren. Ein Versatz mit Anteile in X- oder Y-Richtung führt dagegen zum Fehler. Wenn eine Kinematik solche Einschränkungen hat, dann sind diese bei der Kinematik beschrieben. " }, 
{ "title" : "Funktionsbaustein SMC_GroupSetTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_348cb75b4119d4bfc0a864631ca28fed", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Werkzeugversatz konfigurieren \/ Funktionsbaustein SMC_GroupSetTool ", 
"snippet" : "Der Funktionsbaustein konfiguriert den am Eingang ToolOffset (Typ MC_COORD_REF ) angegebenen Werkzeugversatz für eine Achsgruppe. Solange die Achsgruppe im Zustand GroupDisabled oder GroupErrorStop ist, kann allerdings kein Werkzeugversatz konfiguriert werden. Wenn das Werkzeug mit der aktuellen Kin...", 
"body" : "Der Funktionsbaustein konfiguriert den am Eingang ToolOffset (Typ MC_COORD_REF ) angegebenen Werkzeugversatz für eine Achsgruppe. Solange die Achsgruppe im Zustand GroupDisabled oder GroupErrorStop ist, kann allerdings kein Werkzeugversatz konfiguriert werden. Wenn das Werkzeug mit der aktuellen Kinematik nicht kompatibel ist, gibt der Baustein den Fehler SMC_AXIS_GROUP_TOOL_OFFSET_INCOMPATIBLE_WITH_KINEMATICS zurück. Dieser Fehler wird auch dann zurückgegeben, wenn bei der Kinematikbeschreibung die Schnittstelle ISMKinematicsWithOrientationImage nicht implementiert wurde. " }, 
{ "title" : "Funktionsbaustein SMC_GroupReadTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_c1689be51d4132b4c0a864637c06bdff", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Werkzeugversatz konfigurieren \/ Funktionsbaustein SMC_GroupReadTool ", 
"snippet" : "Dieser Funktionsbaustein liest den Werkzeugversatz aus: Ausgang ToolOffset (Typ MC_COORD_REF ). Dabei bestimmt der Eingang ReadMode , ob das Werkzeug der aktiven Bewegung, der zuletzt kommandierten Bewegung oder das in der Achsgruppe derzeit eingestellte Werkzeug ausgelesen werden soll....", 
"body" : "Dieser Funktionsbaustein liest den Werkzeugversatz aus: Ausgang ToolOffset (Typ MC_COORD_REF ). Dabei bestimmt der Eingang ReadMode , ob das Werkzeug der aktiven Bewegung, der zuletzt kommandierten Bewegung oder das in der Achsgruppe derzeit eingestellte Werkzeug ausgelesen werden soll. " }, 
{ "title" : "Kompatible Kinematiken ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_ff04bb6d41a8190bc0a864635e26fe13", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Werkzeugversatz konfigurieren \/ Kompatible Kinematiken ", 
"snippet" : "Nicht alle Kinematiken unterstützen jeden Werkzeugversatz. Welche Werkzeuge zu welchen Kinematiken passen, können Sie der folgenden Liste entnehmen. Kinematik Kompatibles Werkzeug SCARA 2 Kinematik Kin_Scara2_Z Werkzeuge mit Positionsversatz in Z-Richtung und Versatz in der Orientierung SCARA 3 Kine...", 
"body" : "Nicht alle Kinematiken unterstützen jeden Werkzeugversatz. Welche Werkzeuge zu welchen Kinematiken passen, können Sie der folgenden Liste entnehmen. Kinematik Kompatibles Werkzeug SCARA 2 Kinematik Kin_Scara2_Z Werkzeuge mit Positionsversatz in Z-Richtung und Versatz in der Orientierung SCARA 3 Kinematik Kin_Scara3_Z Alle Werkzeuge Polarkinematik Kin_Polar , Kin_Polar_Z Werkzeuge mit Positionsversatz in Z-Richtung und Versatz in der Orientierung 3-Achs-Knickarmroboter Kin_Pos_RRR Werkzeuge mit Versatz in der Orientierung 6-Achs-Knickarmroboter Kin_ArticulatedRobot_6DOF Alle Werkzeuge 4-Achs-Palletierer Kin_4AxisPalletizer Alle Werkzeuge Bipod Kin_Bipod_Rotary Alle Werkzeuge 5-Achs-Portal Kin_5Axes Alle Werkzeuge Portalsysteme Alle Werkzeuge H-Gantry System Alle Werkzeuge T-Gantry System Alle Werkzeuge Rotatorischer oder linearer Tripod Alle Werkzeuge Wenn eine Kinematik keine 3 Freiheitsgrade bei der Orientierung hat, ist es möglich, dass nicht jeder Werkzeugversatz kompatibel ist. " }, 
{ "title" : "Bei eigenen Kinematiken ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_6c7b39581d4132b4c0a8646366a3228c", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Werkzeugversatz konfigurieren \/ Bei eigenen Kinematiken ", 
"snippet" : "Damit von Ihnen erstellte Kinematiken mit Werkzeugversatz verwendet werden können, müssen Sie die Schnittstelle ISMKinematicsWithOrientationImage implementieren. Um bei eigenen Positionskinematiken einen Werkzeugversatz hinzuzufügen, müssen Sie zunächst die Schnittstelle ISMPositionKinematics2 imple...", 
"body" : "Damit von Ihnen erstellte Kinematiken mit Werkzeugversatz verwendet werden können, müssen Sie die Schnittstelle ISMKinematicsWithOrientationImage implementieren. Um bei eigenen Positionskinematiken einen Werkzeugversatz hinzuzufügen, müssen Sie zunächst die Schnittstelle ISMPositionKinematics2 implementieren. " }, 
{ "title" : "Die Schnittstelle ISMKinematicsWithOrientationImage ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_592ee99f1d4132b4c0a864637bd8a061", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Werkzeugversatz konfigurieren \/ Die Schnittstelle ISMKinematicsWithOrientationImage ", 
"snippet" : "Die Kinematikschnittstelle stellt die Methode GetFlangeOrientationImage mit der Variablen mR_Flange des Datentyps SMC_Matrix3 bereit, die die kommandierte Orientierung des Flansches enthält. Die Methode gibt somit möglichen resultierenden Orientierungen oriInfo als Datentyp OrientationSpace zurück. ...", 
"body" : "Die Kinematikschnittstelle stellt die Methode GetFlangeOrientationImage mit der Variablen mR_Flange des Datentyps SMC_Matrix3 bereit, die die kommandierte Orientierung des Flansches enthält. Die Methode gibt somit möglichen resultierenden Orientierungen oriInfo als Datentyp OrientationSpace zurück. Verhalten der Schnittstelle Insbesondere wenn die Orientierung des Flansches bei der kommandierten Orientierung bekannt ist, wird dof = zero zurückgegeben und mOriZero auf die bekannte Orientierung gesetzt. Wenn die Orientierung R des Flansches nur teilweise in der Form R*vU = vRot bekannt ist, wobei vU und vRot bekannte Einheitsvektoren sind, wird dof = one zurückgegeben. mOriZero wird auf eine Orientierung im erreichbaren Raum eingestellt. Ansonsten wird dof = three zurückgegeben. Ein vorgegebener Werkzeugversatz ist mit der Kinematik kompatibel, wenn die Flanschposition unter Berücksichtigung der berechneten Orientierung eindeutig berechnet werden kann. Das ist immer der Fall, wenn die berechnete Orientierung durch die Kinematik erreichbar ist. Nur wenn nicht alle Orientierungen erreichbar sind, ist der Werkzeugversatz möglicherweise inkompatibel. Wenn außerdem die Methode GetFlangeOrientationImage dof = zero zurückgibt, dann ist jeder Werkzeugversatz kompatibel. Wenn die Methode dof = one zurückgibt, dann ist nur der Werkzeugpositionsversatz v_off parallel zum Einheitsvektor vU kompatibel. In diesem Fall ist R*v_off = R*vU*x = vRot*x nicht von den unbekannten Teilen der Orientierungsmatrix R abhängig. Dazu gehört auch ein Werkzeugversatz mit v_off = 0 (mit x = 0). Wenn dof = three zurückgegeben wird, dann sind nur Positionsverschiebungen ohne Versatz in x\/y\/z kompatibel. Hinweise für die Implementierung Implementieren Sie für Orientierungskinematiken die Schnittstelle ISMOrientationKinematicsWithOriImage2 . Dann kann bei Kopplung der Orientierungskinematik mit einer Positionskinematik ein Werkzeugversatz verwendet werden. Die Schnittstelle hat die Methode GetOrientationImage2 mit der Variablen VAR_IN_OUT CONSTANT mR_Flange vom Typ SMC_Matrix3 , die die kommandierte Orientierung des Flansches enthält. Die Methode gibt csTool und oriinfo mit dem Datentyp OrientationSpace zurück, im Basiskoordinatensystem der Orientierungskinematik. Außerdem wird in bActive zurückgegeben, ob die Freiheitsgrade von orinfo aktiv ( TRUE ) oder passiv ( FALSE ) sind. Beispiel für aktive Freiheitsgrade: Kin_CAxis . Die Drehung um die z-Achse wird von der Achse der Orientierungskinematik gesteuert. Beispiel für passive Freiheitsgrade: Kin_Wrist2 . Der verbleibende Freiheitsgrad ist die Drehung von X\/Y um die Z-Achse, die in die vom Benutzer programmierte Richtung zeigt. Wenn bei einem Werkzeugwechsel sowohl die letzte kommandierte als auch die neue Bewegung eine CP-Bewegung ist (beide Bewegungen sind linear oder kreisförmig), wird der Puffermodus der folgenden Bewegung von Blending oder Aborting auf Buffered geändert. Wenn Sie nach MC_GroupInterrupt und vor MC_GroupContinue einen neuen Werkzeugversatz konfigurieren, wird für die unterbrochenen Bewegungen der alte Werkzeugversatz verwendet. Der neue Werkzeugversatz wird nur für Bewegungen verwendet, die danach kommandiert werden. Wenn die Kinematik gewechselt wird ( MC_SetKinTransform ), dann wird der Werkzeugversatz zurückgesetzt (keine Verschiebung, keine Drehung). " }, 
{ "title" : "Drehgelenke und Modulo-Achsen ", 
"url" : "_sm_robotics_rotary_joints_modulo_axes.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Drehgelenke und Modulo-Achsen ", 
"snippet" : "Modulo-Achsen innerhalb von Achsgruppen werden ab SoftMotion 4.12.0.0 unterstützt. Modulo-Achsen sind nur für Drehgelenke von Kinematiken zulässig. Dies sind Drehgelenke, für die SMKinematicWithInfo.GetAxisProperties den Wert props.eType = Axis_Type.Rotary zurückgibt. Wenn eine Modulo-Achse für ein ...", 
"body" : "Modulo-Achsen innerhalb von Achsgruppen werden ab SoftMotion 4.12.0.0 unterstützt. Modulo-Achsen sind nur für Drehgelenke von Kinematiken zulässig. Dies sind Drehgelenke, für die SMKinematicWithInfo.GetAxisProperties den Wert props.eType = Axis_Type.Rotary zurückgibt. Wenn eine Modulo-Achse für ein lineares Gelenk oder für eine Kinematik verwendet wird, die ISMKinematicWithInfo nicht implementiert, gibt MC_GroupEnable den Fehler SMC_MODULO_AXIS_FOR_NON_ROTARY_JOINT zurück. Wenn eine Modulo-Achse verwendet wird und die Kinematik den Bereich eines Drehgelenks begrenzt, gibt MC_GroupEnable den Fehler SMC_MODULO_AXIS_FOR_LIMITED_ROTARY_JOINT zurück. Modulo-Achsen werden nur unterstützt, wenn die Modulo-Periode 360° beträgt. Der Grund dafür ist, dass Achsen, die mit Drehgelenken verbunden sind, so konfiguriert werden müssen, dass eine technische Einheit [u] einem Winkelgrad [°] entspricht. Eine Periode muss einer vollen Umdrehung entsprechen. Wenn eine Modulo-Achse mit einer anderen Periode als 360° verwendet wird, dann gibt MC_GroupEnable den Fehler SMC_MODULO_AXIS_PERIOD_NOT_360 zurück. SoftMotion unterstützt ab der Version 4.12.0.0 nur den Modus shortest ( MC_DIRECTION ). Das bedeutet, dass der Abstand und die Richtung einer Modulo-Achse so gewählt werden, dass sie so nah wie möglich an der Startposition der Achse liegen. Wenn sich zum Beispiel die Orientierungsachse zu Beginn der Bewegung bei a2 = 30° und an der Zielposition bei a2 = 290° befindet, dann wird die Position a2 = 290° - 360° = -70° gewählt und die Achse bewegt sich um 100° in negativer Richtung, anstatt sich um 260° in positiver Richtung zu bewegen. " }, 
{ "title" : "Erstellen eigener Kinematiken ", 
"url" : "_sm_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Kinematiken \/ Erstellen eigener Kinematiken ", 
"snippet" : "Für die Erzeugung der Dokumentation für die Kinematik aus den Kommentaren im Funktionsbaustein wird das Open-Source-Tool wkhtmltopdf benötigt. Diese Komponente ist jedoch ab CODESYS -Version 3.5 SP15 nicht mehr im Setup enthalten. Sie können die DLL von https:\/\/wkhtmltopdf.org\/downloads.html herunte...", 
"body" : "Für die Erzeugung der Dokumentation für die Kinematik aus den Kommentaren im Funktionsbaustein wird das Open-Source-Tool wkhtmltopdf benötigt. Diese Komponente ist jedoch ab CODESYS -Version 3.5 SP15 nicht mehr im Setup enthalten. Sie können die DLL von https:\/\/wkhtmltopdf.org\/downloads.html herunterladen. Erzeugen Sie im Installationsverzeichnis von CODESYS ein Verzeichnis DocScripting\\3.5.xx.x\\bin und legen Sie die Datei wkhtmltox.dll darin ab. Achtung: Da die wkhtmltox.dll ab der Version 0.12.6 standardmäßig Bilder nicht mehr unterstützt, müssen Sie die Version 0.12.5 oder früher verwenden. Sobald eine Instanz einer kinematischen Transformation von einer Achsgruppe benutzt wurde, dürfen die Eingänge der Instanz nicht mehr geändert werden. Wenn Sie die Parametrierung der kinematischen Transformation ändern wollen, müssen Sie, falls möglich, die Konfiguration nutzen oder mehrere Instanzen anlegen. Beim Erstellen eigener Kinematiken müssen Sie folgende Punkte beachten: Die Kinematiken werden durch spezielle Funktionsbausteine beschrieben, die in Bibliotheken oder der Ansicht POUs des Projekts abgelegt sein können. Damit CODESYS die Kinematiken im Konfigurator auflistet, müssen die zugehörigen Funktionsbausteine die Schnittstelle MC_KIN_REF_SM3 implementieren (Bestandteil von SM3_Transformation.library ). Sie können eine Kinematik als Kombination zweier anderer definieren. Kinematiken, an denen verschiedene Greifer oder Werkzeuge befestigt werden können, müssen zusätzlich die Schnittstelle ISMPositionKinematics2 implementieren. Kinematiken, die selbst einen Greifer oder ein Werkzeug beschreiben, müssen die Schnittstelle ISMToolKinematics2 implementieren. Wenn Sie anstelle ISMPositionKinematics2 \/ ISMToolKinematics2 nur ISMPositionKinematics \/ ISMToolKinematics implementieren, könnten „nicht erreichbare“ Orientierungen falsch verarbeitet werden. Wenn Sie zusätzlich die Schnittstelle ISMPositionKinematics_Offset implementieren, können Sie den Orientierungsmodus Axis verwenden. Der im Funktionsbaustein eingetragene Kommentar wird im Konfigurator als Beschreibung der Kinematik verwendet, wenn der Baustein das Attribut sm_kin_libdoc besitzt. Dabei wird die Formatierung „Restructured-Text“ unterstützt. Beachten Sie jedoch, dass Links nicht unterstützt werden. Konstruktionsbedingte Parameter wie Armlängen, Winkel usw. werden als VAR_INPUT-Variablen des Funktionsbausteins angelegt. Sie sollten die Parameter kommentieren, da der Kommentar als Beschreibung im Konfigurator dient. Wenn die Parameter einen numerischen Typ haben und ihr Wertebereich beschränkt ist, müssen sie mit dem Attribut sm_kin_param_range versehen sein. Die Syntax des Wertebereichs ist [a .. b] für geschlossene Intervalle und ]a .. b[ für offene Intervalle. Die Mischformen ]a .. b] und [a .. b[ sind auch möglich. Dabei müssen a und b zum Typ des Parameters passende Literale sein. Bei offenen Intervallgrenzen sind die speziellen Werte +inf und -inf möglich. Beispiele: [0 .. 1] , [1 .. +inf[ , ]-inf .. -5] . Parameter können jeden numerischen Typ oder den Typ BOOL haben. Parameter sollten einen Initialwert mitbringen, der als Standardwert verwendet wird. Sie können die Einheit des Parameters über das optionale Attribut sm_kin_param_unit angeben, beispielsweise „rad“, „°“, „deg“. Für Längen und Abstände sollten Sie die Einheit „u“ verwenden. Ob diese Einheiten dann gleich „mm“, „cm“ oder „m“ sind entscheidet die Applikation und die Skalierung der Antriebe. Wenn für den Funktionsbaustein keine Bibliotheksdokumentation vorhanden ist, wird als Fallback an den jeweiligen Stellen der Kommentar des FB-Elements angezeigt. Die LibDoc-Dokumentation wird in der Sprache, die in CODESYS konfiguriert ist, angezeigt. Wenn keine Lokalisierung in dieser Sprache vorhanden ist, wird die Standardsprache der Bibliothek verwendet. Die Achsnamen der Kinematik werden über die FB-Attribute sm_kin_axes festgelegt. Der Wert des Attributs ist eine Liste der Achsnamen, zum Beispiel „A1, A2, A3“. Sie können ein optionales Icon über das FB-Attribut sm_kin_icon angeben. Der Wert ist in der Form <Imagepool>.<Identifier> anzugeben. Die Bildersammlung wird relativ zum Funktionsbaustein angegeben. Wenn Sie einen eigenen Kinematik-Funktionsbaustein mit rotatorischen Achsen erstellen (beispielsweise Kin_Scara3_Z_Config ), dann sollten Sie das Periodenkonzept für diese Achsen verwenden und die Schnittstelle ISMKinPeriodHandling implementieren. Für rotatorische Achsen ist nur die inverse Kinematiktransformation ( CartesianToAxes ) für die Berechnung des Winkel verantwortlich. CODESYS SoftMotion verschiebt dann automatisch diesen Winkel in die richtige Periode. Wenn die Transformation beispielsweise einen Winkel im Bereich ]-180°, 180°] berechnet, verschiebt CODESYS SoftMotion diesen Winkel in den Bereich [0°, 360°[, vorausgesetzt die Softwaregrenzen des Antriebs sind 0° .. 360°. Außerdem sollten Sie die Schnittstelle ISMKinematicsWithConfiguration3 umsetzen. Nur so ist sichergestellt, dass die Kinematik bei CP-Bewegungen ohne Probleme funktioniert. Für gekoppelte Kinematiken mit unregelmäßiger Anordnung der Positionier- und Orientierungskinematik sollten Sie die Schnittstelle ISMCoupledKinematics3 implementieren. Dadurch kann das System erkennen, ob eine Achse zur Positionier- oder Orientierungskinematik mit der jeweiligen Achsnummer gehört. Hinweis: Die Methode ISMKinematicWithConfigurations2.CPConnectible sollten Sie so implementieren, dass die Periodeneinstellungen beim Vergleich ignoriert werden. Dann gibt CPConnectible den Wert TRUE zurück, auch wenn die Periodeneinstellung unterschiedlich ist. Alle Rückwärtstransformationen haben einen Eingang vom Typ CONFIGDATA , der ein Byte-Array mit Informationen über die Konfiguration der Kinematik enthält. Die Vorwärtstransformationen haben einen entsprechenden Ausgang. Kinematiken, bei denen die Konfiguration eine Rolle spielt, müssen die Schnittstelle ISMKinematicWithConfigurations implementieren. Zu diesen Kinematiken gehört jeweils ein Funktionsbaustein, der die Schnittstelle ISMConfigurationData implementiert (Funktion zur Serialisierung der Konfigurationsdaten). Der Name dieses Funktionsbausteins muss gleich dem Namen der Kinematik plus Postfix _config sein. Sie können diesen FB verwenden, um die Konfiguration in der Applikation zu ändern (mittels des Bausteins SMC_SetKinConfiguration ). Kinematiken sollen aber ausdrücklich keine Instanz des entsprechenden FBs halten. Sie finden eine Schritt-für-Schritt-Anleitung im Kapitel Kundenspezifische Kinematiken. " }, 
{ "title" : "Koordinatensysteme ", 
"url" : "_sm_coordinate_systems.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Koordinatensysteme ", 
"snippet" : "CODESYS SoftMotion Robotics bietet unterschiedliche Koordinatensysteme an, in denen Bewegungen kommandiert werden können. Achskoordinatensystem (ACS) Werkzeugkoordinatensystem (TCS) Weltkoordinatensystem (WCS) Maschinenkoordinatensystem (MCS) Produktkoordinatensystem (PCS_1, PCS_2) Koordinatensystem...", 
"body" : "CODESYS SoftMotion Robotics bietet unterschiedliche Koordinatensysteme an, in denen Bewegungen kommandiert werden können. Achskoordinatensystem (ACS) Werkzeugkoordinatensystem (TCS) Weltkoordinatensystem (WCS) Maschinenkoordinatensystem (MCS) Produktkoordinatensystem (PCS_1, PCS_2) Koordinatensystem Beschreibung Achskoordinatensystem ACS Das Achskoordinatensystem definiert ein Koordinatensystem im Achsraum, bei dem jede Achse des Roboters eine Dimension aufspannt. Somit kann für jede Achse des Roboters eine Position vorgegeben werden. Werkzeugkoordinatensystem TCP Das Werkzeugkoordinatensystem ist ein kartesisches Koordinatensystem, das im Tool-Center-Point (TCP) der Kinematik liegt. Seine Lage und Orientierung sind abhängig von der Position des Roboters. Weltkoordinatensystem WCS Das Weltkoordinatensystem ist ein statisches kartesisches Koordinatensystem und bildet die Basis für alle folgenden Koordinatensysteme. Diese sind relativ zum Weltkoordinatensystem definiert. Maschinenkoordinatensystem MCS Das Maschinenkoordinatensystem ist ein statisches kartesisches Koordinatensystem. Die Lage und Orientierung des MCS relativ zum echten Roboter werden von der Kinematik definiert. Mit Hilfe des Bausteins MC_SetCoordinateTransform kann das Koordinatensystem relativ zum Weltkoordinatensystem (WCS) verschoben werden. Produktkoordinatensystem PCS_1, PCS_2 Die Produktkoordinatensysteme sind kartesische Koordinatensysteme, die vom Anwender definiert werden können. Sie werden relativ zum Weltkoordinatensystem (WCS) ausgedrückt und können sowohl statisch als auch dynamisch sein. Statisch Mit Hilfe des Bausteins MC_SetCoordinateTransform können die Koordinatensysteme relativ zum Weltkoordinatensystem (WCS) verschoben werden. Dynamisch Mit Hilfe der folgenden Bausteine können dynamische Koordinatensysteme definiert werden: MC_SetDynCoordTransform SMC_SetDynCoordTransformEx MC_TrackConveyorBelt MC_TrackRotaryTable " }, 
{ "title" : "Initiale Lage und Orientierung der Koordinatensysteme ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056579261585", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Koordinatensysteme \/ Initiale Lage und Orientierung der Koordinatensysteme ", 
"snippet" : "Die Kinematik des Roboters legt die initiale Lage und Orientierung der Koordinatensysteme fest. In der Dokumentation der Kinematik ist dies beschrieben. Die Kinematik definiert die Lage und Orientierung des Maschinenkoordinatensystems (MCS) relativ zum echten Roboter die Lage und Orientierung des To...", 
"body" : "Die Kinematik des Roboters legt die initiale Lage und Orientierung der Koordinatensysteme fest. In der Dokumentation der Kinematik ist dies beschrieben. Die Kinematik definiert die Lage und Orientierung des Maschinenkoordinatensystems (MCS) relativ zum echten Roboter die Lage und Orientierung des Tool-Center-Points (TCP) relativ zum MCS und dadurch das Werkzeugkoordinatensystem (TCS) die Nullstellung des Roboters sowie die Dreh- oder Verfahrrichtungen der einzelnen Achsen Das Weltkoordinatensystem (WCS), sowie die Produktkoordinatensysteme (PCS_1, PCS_2), sind initial nicht verschoben und identisch zum Maschinenkoordinatensystem. " }, 
{ "title" : "Mehrere Roboter und Werkstücke ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581220108", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Koordinatensysteme \/ Mehrere Roboter und Werkstücke ", 
"snippet" : "Die Lage und Orientierung der Koordinatensysteme werden pro Roboter definiert. Wenn mehrere Roboter zusammen arbeiten, kann es nützlich sein, das Weltkoordinatensystem (WCS) als gemeinsames Basiskoordinatensystem festzulegen. Ausgehend von diesem Koordinatensystem können die Maschinenkoordinatensyst...", 
"body" : "Die Lage und Orientierung der Koordinatensysteme werden pro Roboter definiert. Wenn mehrere Roboter zusammen arbeiten, kann es nützlich sein, das Weltkoordinatensystem (WCS) als gemeinsames Basiskoordinatensystem festzulegen. Ausgehend von diesem Koordinatensystem können die Maschinenkoordinatensysteme (MCS) und Produktkoordinatensysteme (PCS_1, PCS_2) der einzelnen Roboter verschoben werden. " }, 
{ "title" : "Beispiel ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581719182", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Koordinatensysteme \/ Beispiel ", 
"snippet" : "Beispiel anhand eines Roboters mit zwei Drehgelenken ( a0 und a1 )...", 
"body" : "Beispiel anhand eines Roboters mit zwei Drehgelenken ( a0 und a1 ) " }, 
{ "title" : "Kinematik ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582142746", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Koordinatensysteme \/ Beispiel \/ Kinematik ", 
"snippet" : "Die Kinematik definiert die Nullstellung des Roboters, wie nachfolgend dargestellt. Der Ursprung des Maschinenkoordinatensystem liegt in der Drehachse von Achse a0 . Die X-Achse zeigt in Richtung des ersten Glieds, wenn die Position der ersten Achse a0 gleich 0 ist. Die Y-Achse zeigt in Richtung des...", 
"body" : "Die Kinematik definiert die Nullstellung des Roboters, wie nachfolgend dargestellt. Der Ursprung des Maschinenkoordinatensystem liegt in der Drehachse von Achse a0 . Die X-Achse zeigt in Richtung des ersten Glieds, wenn die Position der ersten Achse a0 gleich 0 ist. Die Y-Achse zeigt in Richtung des ersten Glieds, wenn die Position der ersten Achse a0 auf +90° steht. Eine Drehung gegen den Uhrzeigersinn entspricht der positiven Drehrichtung. Der Tool-Center-Point (TCP) liegt am Ende des zweiten Glieds des Roboters, wie nachfolgend dargestellt, und bildet den Ursprung des TCS. Das TCS ist so ausgerichtet, dass die X-Achse entlang des zweiten Glieds verläuft. " }, 
{ "title" : "Achskoordinatensystem (ACS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582875889", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Koordinatensysteme \/ Beispiel \/ Achskoordinatensystem (ACS) ", 
"snippet" : "Die Kinematik hat die Nullstellung des Roboters und die Drehrichtung der einzelnen Achsen vorgegeben. Da der Roboter aus zwei Achsen a0 und a1 besteht, können wir im ACS die Positionen von Achse a0 und a1 vorgeben. Im ersten Bild geben wir die Position ( a0:= 0, a1:= 0 ) vor. Dies entspricht der Nul...", 
"body" : "Die Kinematik hat die Nullstellung des Roboters und die Drehrichtung der einzelnen Achsen vorgegeben. Da der Roboter aus zwei Achsen a0 und a1 besteht, können wir im ACS die Positionen von Achse a0 und a1 vorgeben. Im ersten Bild geben wir die Position ( a0:= 0, a1:= 0 ) vor. Dies entspricht der Nullstellung des Roboters. Im zweiten Bild geben wir die Position ( a0:= 90, a1:= 0 ) vor. Ausgehend von der Nullstellung ist die erste Achse a0 um 90° in positive Drehrichtung gedreht. Die zweite Achse a1 bleibt in der Nullstellung. Im dritten Bild geben wir die Position ( a0:= 90, a1:= -90 ) vor. Ausgehend von der Nullstellung ist die erste Achse a0 um 90° in positive Drehrichtung gedreht (wie im zweiten Bild). Zusätzlich wird die zweite Achse a1 um 90° in negative Drehrichtung gedreht. " }, 
{ "title" : "Werkzeugkoordinatensystem (TCS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056583569251", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Koordinatensysteme \/ Beispiel \/ Werkzeugkoordinatensystem (TCS) ", 
"snippet" : "Die Kinematik definiert die Lage und Orientierung des TCP und TCS. Je nachdem wie wir den Roboter bewegen, ändert sich auch die Lage und Orientierung des TCS....", 
"body" : "Die Kinematik definiert die Lage und Orientierung des TCP und TCS. Je nachdem wie wir den Roboter bewegen, ändert sich auch die Lage und Orientierung des TCS. " }, 
{ "title" : "Weltkoordinatensystem (WCS), Maschinenkoordinatensystem (MCS) und Produktkoordinatensystem (PCS_1, PCS_2) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056584038831", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Koordinatensysteme \/ Beispiel \/ Weltkoordinatensystem (WCS), Maschinenkoordinatensystem (MCS) und Produktkoordinatensystem (PCS_1, PCS_2) ", 
"snippet" : "In einer Produktionshalle stehen zwei Roboter links und rechts eines Förderbandes, die Produkte auf dem Förderband bearbeiten sollen. Wir definieren ein gemeinsames Weltkoordinatensystem und legen es in die linke obere Ecke unserer Produktionshalle. Ausgehend von diesem Koordinatensystem bestimmen w...", 
"body" : "In einer Produktionshalle stehen zwei Roboter links und rechts eines Förderbandes, die Produkte auf dem Förderband bearbeiten sollen. Wir definieren ein gemeinsames Weltkoordinatensystem und legen es in die linke obere Ecke unserer Produktionshalle. Ausgehend von diesem Koordinatensystem bestimmen wir den Abstand und Verdrehung zu den Maschinenkoordinatensystemen sowie dem Produkt und verschieben die Koordinatensysteme entsprechend. Im Beispiel sind alle Koordinatensysteme gleich ausgerichtet, wir müssen die Koordinatensysteme also nur verschieben. Das Maschinenkoordinatensystem des linken Roboters ist in Y-Richtung verschoben, das Maschinenkoordinatensystem des rechten Roboters in X-Richtung und das Produktkoordinatensystem sowohl in X- als auch Y-Richtung. " }, 
{ "title" : "Bewegungssteuerung ", 
"url" : "_sm_f_motion_control.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Übersicht ", 
"url" : "_sm_overview_robotics_motion_control.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Übersicht ", 
"snippet" : "Dieses Kapitel beschreibt die grundlegenden Bewegungsarten der Robotik: Tippbetrieb SMC_GroupJog2 PTP-Bewegungen (Point to Point) MC_MoveDirectAbsolute MC_MoveDirectRelative CP-Bewegungen (Continuous Path) MC_MoveLinearAbsolute MC_MoveLinearRelative MC_MoveCircularAbsolute MC_MoveCircularRelative Wa...", 
"body" : "Dieses Kapitel beschreibt die grundlegenden Bewegungsarten der Robotik: Tippbetrieb SMC_GroupJog2 PTP-Bewegungen (Point to Point) MC_MoveDirectAbsolute MC_MoveDirectRelative CP-Bewegungen (Continuous Path) MC_MoveLinearAbsolute MC_MoveLinearRelative MC_MoveCircularAbsolute MC_MoveCircularRelative Warten SMC_GroupWait Anhalten (siehe Anhalten auf der Bahn mit MC_GroupHalt oder MC_GroupStop und Unterbrechen und Fortsetzen von BewegungenMC_GroupHalt MC_GroupStop MC_GroupInterrupt Außerdem werden alle wichtigen Themen zu Bewegungen erläutert: Puffern und Überschleifen von BewegungenSynchronisation mit einem beweglichen KoordinatensystemSynchronisieren externer Achsen, MomentenvorsteuerungZusatzachsenDiagnose bei langsamen oder ruckartigen Bewegungen" }, 
{ "title" : "How-To: Programm zur Steuerung der Achsgruppe erstellen ", 
"url" : "_sm_creating_an_axis_group_program.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ How-To: Programm zur Steuerung der Achsgruppe erstellen ", 
"snippet" : "Die nachfolgende Anweisung beschreibt exemplarisch die Erstellung eines Programms zur Ansteuerung einer Achsgruppe. Voraussetzung : Sie haben ein Projekt mit einer Achsgruppe angelegt wie im Kapitel How-To: Achsgruppe anlegen beschrieben. Das Programm für die Ansteuerung der Achsgruppe erstellen Sie...", 
"body" : "Die nachfolgende Anweisung beschreibt exemplarisch die Erstellung eines Programms zur Ansteuerung einer Achsgruppe. Voraussetzung : Sie haben ein Projekt mit einer Achsgruppe angelegt wie im Kapitel How-To: Achsgruppe anlegen beschrieben. Das Programm für die Ansteuerung der Achsgruppe erstellen Sie in der POU PLC_PRG in der Implementierungssprache CFC. Öffnen Sie das Programm PLC_PRG im Editor. Ziehen Sie das Element Baustein in den Editor. Weisen Sie dem Baustein den Funktionsbaustein SMC_GroupPower zu. Beschalten Sie den Funktionsbaustein entsprechend nachfolgendem Bild. Erläuterung: Der Funktionsbaustein aktiviert alle Antriebe der Achsgruppe. Der Ausgang Status zeigt die erfolgreiche Reglerfreigabe an. Erstellen Sie einen Funktionsbaustein des Typs MC_GroupEnable . Dieser Funktionsbaustein übergibt der Achsgruppe AxisGroup die Kontrolle über die verknüpften Achsen. Verbinden Sie den Ausgang Status des Bausteins SMC_GroupPower mit dem Eingang Execute des Funktionsbausteins MC_GroupEnable . Erläuterung: Wenn alle Achsregler mit Spannung versorgt sind ( Status = TRUE ), wird der Achsgruppe die Kontrolle über die Achsen übergeben. Der Ausgang Done meldet den Erfolg des Kommandos. Fügen Sie einen Funktionsbaustein MC_MoveDirectAbsolute zum Verfahren des Antriebs ein. Verbinden Sie den Ausgang Done des Bausteins MC_GroupEnable mit dem Eingang Execute des Funktionsbausteins MC_MoveDirectAbsolute . Erweitern Sie das Programm folgendermaßen: Erläuterung: Der Funktionsbaustein MC_MoveDirectAbsolute kommandiert eine Punkt-zu-Punkt Bewegung der Achsgruppe AxisGroup . Im Beispiel wird die Kinematik auf die Position (X = 10, Y= 20, Z = 30) verfahren. Dieser Wert wird über die Struktur SMC_POS_REF dem Eingang Position zugewiesen. Angegeben wird die Position im Maschinenkoordinatensystem (MCS). Das Koordinatensystem wird über den Eingang  CoordSystem  ausgewählt. Programm starten Wenn Sie das Programm fertig erstellt haben und es sich fehlerfrei übersetzen lässt, können Sie es auf die Steuerung übertragen. Starten Sie das Laufzeitsystem CODESYS Control Win (Programm CODESYSControlService.exe im Verzeichnis \"...\\GatewayPLC\" ). Stellen Sie in den Kommunikationseinstellungen den Verbindungspfad zu Ihrer Steuerung ein. Wählen Sie den Befehl Online → Einloggen . Übertragen Sie das Projekt auf die Steuerung. Wählen Sie den Befehl Debug → Start . Öffnen Sie das Objekt AxisGroup im Editor. Die Positionen der Achsen werden angezeigt. Wählen Sie den Befehl  Debug → Start . Die Positionen der Achsen verändern sich. " }, 
{ "title" : "Tippbetrieb von Achsgruppen ", 
"url" : "_sm_cartesian_jogging.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Tippbetrieb von Achsgruppen ", 
"snippet" : "Mit dem Funktionsbaustein SMC_GroupJog2 können Sie eine Achsgruppe im Raum bewegen. Der Funktionsbaustein SMC_GroupJog2 hat für jede Koordinate zwei boolsche Eingänge. Einen Eingang um entlang dieser Koordinate vorwärts zu verfahren, und einen Eingang rückwärts zu verfahren. Die booleschen Eingänge ...", 
"body" : "Mit dem Funktionsbaustein SMC_GroupJog2 können Sie eine Achsgruppe im Raum bewegen. Der Funktionsbaustein SMC_GroupJog2 hat für jede Koordinate zwei boolsche Eingänge. Einen Eingang um entlang dieser Koordinate vorwärts zu verfahren, und einen Eingang rückwärts zu verfahren. Die booleschen Eingänge für die verschiedenen Koordinaten für SMC_GroupJog2 können auf unterschiedliche Weise interpretiert werden. Beispielsweise in Weltkoordinaten, Maschinenkoordinaten, Achskoordinaten oder Werkzeugkoordinaten, je nach eingestelltem Koordinatensystem. Über einen speziellen Eingang ABC_as_ACS: BOOL können gleichzeitig X\/Y\/Z kartesisch und die Achsen der Toolkinematik in Achskoordinaten gejoggt werden. Das \"gemischte\" Joggen wird nur unterstützt, wenn die Kinematik eine gekoppelte Kinematik ist und die Positionierkinematik die Schnittstelle ISMPositionKinematics_Offset umsetzt. (Andernfalls liefert der Funktionsbaustein einen Fehler.) Im Tippbetrieb rotiert A den TCP um die X-Achse des konfigurierten Koordinatensystems (MCS, WCS, PCS oder TCS). B und C rotieren den TCP um die Y- und Z-Achse desselben Koordinatensystems. Dies gilt jedoch nur, wenn ABC_as_ACS = FALSE ist. Der kartesiche Tippbetrieb beginnt, wenn der Baustein SMC_GroupJog2 eine steigende Flanke erhält und den Ausgang Busy setzt. Durch den kartesischen Tippbetrieb werden aktive koordinierte Bewegungen oder Bewegungen der Achsen der Kinematik unterbrochen. Der kartesische Tippbetrieb endet, wenn das Tippen durch eine Bewegung (koordiniert oder auf den Achsen der Kinematik) unterbrochen wird, oder wenn die Position außerhalb des Arbeitsraums liegt. Beim Tippbetrieb werden immer die Achsgrenzen der Achsen der Kinematik eingehalten. Für weitere Informationen siehe: Joggen eines Roboters" }, 
{ "title" : "PTP-Bewegungen ", 
"url" : "_sm_robotics_path_invariant_ptp_movements.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ PTP-Bewegungen ", 
"snippet" : "Bei PTP-Bewegungen hängt die Bahn im Raum von der Kinematik ab, und nur der Start- und der Zielpunkt sind festgelegt. Die Bewegung ist vollsynchron, so dass die Beschleunigungs-, Konstantfahr- und Abbremsphase für alle Achsen zur gleichen Zeit beginnt und endet. PTP-Bewegungen sind immer bahntreu un...", 
"body" : "Bei PTP-Bewegungen hängt die Bahn im Raum von der Kinematik ab, und nur der Start- und der Zielpunkt sind festgelegt. Die Bewegung ist vollsynchron, so dass die Beschleunigungs-, Konstantfahr- und Abbremsphase für alle Achsen zur gleichen Zeit beginnt und endet. PTP-Bewegungen sind immer bahntreu und weisen daher folgende Merkmale auf: Die Bahn ist unabhängig vom Override Die Bahn ist unabhängig von allen Dynamikgrenzen der Achsen (Grenzen für Geschwindigkeit, Beschleunigung, Verzögerung und Ruck). Einzige Ausnahme ist die Bestimmung der Abschneidepunkte im Modus TMStartVelocity Im Modus TMCornerDistance ist die Bahn unabhängig von der Art des Überschleifens ( BlendingHigh \/ Low \/ Previous \/ Next ) Die Bahn wird beim Halt oder Stop ( MC_GroupHalt \/ MC_GroupStop ) nicht verlassen Die Bahn wird beim Unterbrechen und Fortsetzen ( MC_GroupInterrupt \/ MC_GroupContinue ) nicht verlassen " }, 
{ "title" : "CP-Bewegungen ", 
"url" : "_sm_robotics_cp_movements.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ CP-Bewegungen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Übersicht ", 
"url" : "_sm_overview_robotics_motion_control_cp.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ CP-Bewegungen \/ Übersicht ", 
"snippet" : "CP-Bewegungen (Continuous Path) sind über ihre geometrische Bahn gegeben. Im Fall der Robotik sind das Geradenabschnitte ( MC_MoveLinearAbsolute und MC_MoveLinearRelative ) und Kreissegmente ( MC_MoveCircularAbsolute und MC_MoveCircularRelative ). Für CP-Bewegungen kann eine maximale Bahngeschwindig...", 
"body" : "CP-Bewegungen (Continuous Path) sind über ihre geometrische Bahn gegeben. Im Fall der Robotik sind das Geradenabschnitte ( MC_MoveLinearAbsolute und MC_MoveLinearRelative ) und Kreissegmente ( MC_MoveCircularAbsolute und MC_MoveCircularRelative ). Für CP-Bewegungen kann eine maximale Bahngeschwindigkeit, eine maximale Bahnbeschleunigung und ein maximaler Bahnruck vorgegeben werden. Wird zwischen zwei CP-Bewegungen überschliffen, und liegen beide Bewegungen in einer gemeinsamen Ebene, dann wird diese Ebene beim Überschleifen nicht verlassen. Zwei aufeinanderfolgende Geradenabschnitte liegen beispielsweise immer in einer Ebene. Mit der Geometrie der Bahn ist noch nicht festgelegt, wie die Orientierung des TCP von der Startorientierung in die Zielorientierung überführt wird. Das wird im Abschnit Orientierungsinterpolation bei CP-Bewegungen erklärt. CP-Bewegungen starten und enden immer in derselben Konfiguration des Roboters. Mit CP-Bewegungen ist es nicht möglich, die Konfiguration zu wechseln, denn der Roboter würde sich dabei durch eine singuläre Stellung bewegen. Eine Bewegung durch eine singuläre Stellung kann zu unbeschränkten Achsgeschwindigkeiten führen. Zum Wechsel zwischen Konfiguration können PTP-Bewegungen verwendet werden. " }, 
{ "title" : "Orientierungsinterpolation bei CP-Bewegungen ", 
"url" : "_sm_robotics_orientation_interpolation.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ CP-Bewegungen \/ Orientierungsinterpolation bei CP-Bewegungen ", 
"snippet" : "Bei CP-Bewegungen wie MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute oder MC_MoveCircularRelative kann über die Zielposition der Bewegung eine beliebige Zielorientierung des Werkzeugs angegeben werden. Dies hat zur Folge, dass die Orientierung des Werkzeugs während der Bahnb...", 
"body" : "Bei CP-Bewegungen wie MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute oder MC_MoveCircularRelative kann über die Zielposition der Bewegung eine beliebige Zielorientierung des Werkzeugs angegeben werden. Dies hat zur Folge, dass die Orientierung des Werkzeugs während der Bahnbewegung in die Zielorientierung überführt wird, wobei die Werkzeugspitze auf der Bahn verfährt. Es spielt übrigens für die Orientierungsinterpolation keine Rolle, in welchem Koordinatensystem die Zielorientierung angegeben wurde, also beispielsweise in Achskoordinaten (ACS) oder Maschinenkoordinaten (MCS). Die nachfolgende Abbildung zeigt eine lineare Interpolation mit gleichzeitiger Orientierungsinterpolation. Die roten Pfeile zeigen die Richtung des Werkzeugs am Start- und Endpunkt. Die gestrichelten roten Pfeile zeigen, wie das Werkzeug an einigen Stellen während der Interpolation steht. Die oben erwähnten Funktionsbausteine für Bahnbewegungen besitzen den Eingang OrientationMode . Dieser Eingang definiert, auf welche Art die Startorientierung in die Zielorientierung überführt wird. Die Großkreisinterpolation ( SMC_Orientation_Mode.GreatCircle ) Diese Einstellung ist standardmäßig eingestellt. Dabei wird die Startorientierung auf kürzestem Weg in die Zielorientierung überführt. Der kürzeste Weg bedeutet hier: das Werkzeug wird so in die Zielorientierung gedreht, dass der zurückgelegte Winkel der Drehung minimal ist. Achsorientierungsinterpolation ( SMC_Orientation_Mode.Axis ) Beispiel 1: Großkreisinterpolation Wir betrachten ein Portal mit einer C-Achse, mit Wertebereich von -360° bis 360°. Die Startorientierung ist bei C=179°, die Zielorientierung bei C=-175°. Die Großkreisinterpolation bewegt die C-Achse der ZYZ-Eulerwinkel (A,B,C) proportional zum zurückgelegten Weg auf der Bahn von 179° in positiver Richtung über 180° bis 185°, was -175° entspricht. Dabei legt sie also einen Gesamtwinkel von 6° zurück. Beispiel 2: Achsorientierungsinterpolation Wir betrachten wieder das Portal mit einer C-Achse, dieses Mal mit Wertebereich von -180° bis 180°. Die Startorientierung ist bei C=179°, die Zielorientierung bei C=-175°. Die Achsinterpolation bewegt die C-Achse des Portals proportional zum zurückgelegten Weg auf der Bahn von 179° in negativer Richtung über 0° bis -175°, legt also einen Gesamtwinkel von 354° zurück. (Hätte man in diesem Beispiel die Großkreisinterpolation verwendet, dann wäre es zum Fehler gekommen, da der Arbeitsraum der C-Achse überschritten worden wäre.) Die beiden Arten der Interpolation unterscheiden sich in einigen wichtigen Eigenschaften. Bei Großkreisinterpolation ist es vorhersagbar, wie sich die Orientierung des Werkzeugs ändert. Bei der Achsinterpolation dagegen ist die Orientierungsänderung nur schwer vorherzusagen, da sich die Orientierungsachsen je nach Stellung unterschiedlich auf die Orientierung auswirken können. Diese Eigenschaft teilt die Achsorientierungsinterpolation mit PTP-Bewegungen. (Das heißt allerdings nicht, dass die Bahn im Raum bei Achsorientierungsinterpolation schwer vorhersagbar wäre: die Bahn ist bei beiden Arten der Orientierungsinterpolation gleich, der TCP verfährt immer exakt die vorgegebene Kontur.) Mit der Großkreisinterpolation kann man nicht durch Singularitäten der Orientierungskinematik fahren. Dies geht mit der Achsinterpolation ohne Probleme. Bei der Großkreisinterpolation kann es zu Verletzungen der Achsgrenzen der Orientierungsachsen kommen, wie im zweiten Beispiel erwähnt. Es ist also erforderlich, bei der Kommandierung sicherzustellen, dass keine Achsgrenzen verletzt werden, wenn die Zielorientierung mit kürzester Drehung angefahren wird. Mit der Achsinterpolation ist es möglich, um mehr als 360° zu drehen. Wenn eine Orientierungsachse einen Arbeitsraum von mehr als 360° hat, kann man auf diese Art beispielsweise anstelle zu Position 180° auf Position 540° fahren. Dies entspricht derselben Orientierung des Werkzeugs. Mit Großkreisinterpolation ist dies nicht möglich, die kürzeste Drehung zur Zielorientierung entspricht ja immer einem Gesamtwinkel von höchstens 180°. Die Achsorientierungsinterpolation benötigt eine gekoppelte Kinematik, die aus Positionier- und Toolkinematik besteht. Der Positionieranteil muss dabei das Interface ISMPositionKinematics_Offset2 implementieren. Wenn die Kinematik keine Rotationsachsen besitzt und das Interface ISMPositionKinematics implementiert, wird der gewählte Orientierungsmodus ( SMC_Orientation_Mode ) ignoriert. Singularitäten bei Achsorientierungsinterpolation Mit der Achsorientierungsinterpolation kann eine Bahnbewegung durch die Singularitäten der Orientierungskinematik erfolgen, was die Programmierung deutlich einfacher machen kann. Dafür ändern sich aber die Singularitäten der Positionierkinematik. Bei der Großkreisinterpolation hat der Scara3_Z eine Singularität, wenn der Flansch-Punkt (A3) auf der durch den ersten Armteil definierten Geraden liegt, also wenn der zweite Gelenkwinkel 0° beträgt. Bei der Achsorientierungsinterpolation ändern sich die Singularitäten der Positionierkinematik so, dass der TCP die Rolle einnimmt, die sonst der Flanschpunkt (A3) hat. Sie tritt jetzt auf, wenn der TCP (nicht der Flansch-Punkt) auf der durch den ersten Armteil definierten Geraden liegt. Bei der Kommandierung einer Bewegung mit Achsorientierungsinterpolation wird geprüft, ob zwischen der Start- und der Zielposition der Bewegung diese geänderte Singularität liegt. Falls ja, wird die Bewegung nicht akzeptiert und ein Fehler wird zurückgegeben. Beim 6-Achs-Knickarmroboter ist die Situation vergleichbar mit dem Scara3_Z, es sind jedoch zwei Singularitäten möglich: Die erste tritt auf, wenn der TCP auf der Geraden durch A2 und A3 liegt, die zweite wenn der TCP auf der Geraden durch A1 liegt. Auch hier wird bei Kommandierung geprüft, dass keine Singularität durchfahren wird. Es kann vorkommen, dass sich die Konfiguration des Scara3 (oder des 6-Achs-Knickarmroboters) während einer Fahrt mit Achsorientierungsinterpolation ändert. Am Ende der Bewegung wird aber immer dieselbe Konfiguration angenommen, die der Roboter am Startpunkt der Bewegung hatte. " }, 
{ "title" : "Zusatzachsen ", 
"url" : "_sm_additional_axes.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Zusatzachsen ", 
"snippet" : "Zusatzachsen sind Achsen, die Teil der Achsgruppe, aber nicht Teil der Kinematik sind. Sie lassen sich synchron zu koordinierten Bewegung der Kinematik verfahren. Die Zusatzachsen und die Achsen der Kinematik starten die Bewegung und erreichen gleichzeitig ihre Zielposition. Zusatzachsbewegungen wer...", 
"body" : "Zusatzachsen sind Achsen, die Teil der Achsgruppe, aber nicht Teil der Kinematik sind. Sie lassen sich synchron zu koordinierten Bewegung der Kinematik verfahren. Die Zusatzachsen und die Achsen der Kinematik starten die Bewegung und erreichen gleichzeitig ihre Zielposition. Zusatzachsbewegungen werden gemeinsam mit koordinierten Bewegungen gepuffert und überschliffen. Das Gleiche gilt für reine Zusatzachsbewegungen ohne Bewegung der Kinematik. " }, 
{ "title" : "Unterschiede zu Einzelachsbewegungen ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062102818545", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Zusatzachsen \/ Unterschiede zu Einzelachsbewegungen ", 
"snippet" : "Der Hauptunterschied zu Einzelachsbewegungen, die mit Bausteinen wie MC_MoveAbsolute oder MC_MoveRelative kommandiert werden, ist die Synchronität der Bewegung. Wenn die Synchronität nicht wichtig ist, dann kann es sinnvoll sein, die Achsen mit Einzelachsbausteinen zu kommandieren, da die Achsen dan...", 
"body" : "Der Hauptunterschied zu Einzelachsbewegungen, die mit Bausteinen wie MC_MoveAbsolute oder MC_MoveRelative kommandiert werden, ist die Synchronität der Bewegung. Wenn die Synchronität nicht wichtig ist, dann kann es sinnvoll sein, die Achsen mit Einzelachsbausteinen zu kommandieren, da die Achsen dann möglicherweise schneller verfahren werden. Ein weiterer Unterschied ist, dass Zusatzachsen mit der Achsgruppe zusammen verwaltet werden: Sie werden mit SMC_GroupPower aktiviert und Fehler können mit MC_GroupReset gemeinsam zurückgesetzt werden. Zu beachten ist, dass ein Einzelachsfehler einer Zusatzachse zu einem Achsgruppenfehler führt. " }, 
{ "title" : "Kommandierung von Zusatzachsbewegungen ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062103093337", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Zusatzachsen \/ Kommandierung von Zusatzachsbewegungen ", 
"snippet" : "Bei der Kommandierung von Zusatzachsbewegungen kann immer zwischen Absolut- und Relativbewegungen gewählt werden, unabhängig davon, ob die Hauptbewegung der Achsgruppe absolut oder relativ ist. Zum Beispiel kann synchron zu einem MC_MoveLinearAbsolute -Kommando eine relative Zusatzachsbewegung komma...", 
"body" : "Bei der Kommandierung von Zusatzachsbewegungen kann immer zwischen Absolut- und Relativbewegungen gewählt werden, unabhängig davon, ob die Hauptbewegung der Achsgruppe absolut oder relativ ist. Zum Beispiel kann synchron zu einem MC_MoveLinearAbsolute -Kommando eine relative Zusatzachsbewegung kommandiert werden. Zusatzachsbewegung werden über den Eingang AdditionalAxes der Bewegungsbausteine für die Achsgruppe kommandiert. Beispielsweise kann eine absolute PTP-Bewegung mit einer relativen Zusatzachsbewegung wie folgt kommandiert werden: Wenn nur die Zusatzachsen bewegt werden sollen, dann kann eine koordinierte Bewegung mit Länge 0 (zum Beispiel MC_MoveDirectRelative mit Distanz 0 ) zusammen mit einer Zusatzachsbewegung kommandiert werden. " }, 
{ "title" : "Hinweise ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062106608843", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Zusatzachsen \/ Hinweise ", 
"snippet" : "Es werden auch Modulo-Achsen als Zusatzachsen unterstützt. Sie werden bei absoluten Zusatzachsbewegungen immer im Mode shortest verfahren. Für weitere Informationen siehe: MC_Direction MC_Direction Die maximale Anzahl von Zusatzachsen ist durch den Bibliotheksparameter  MAX_NUM_ADDITIONAL_AXES der B...", 
"body" : "Es werden auch Modulo-Achsen als Zusatzachsen unterstützt. Sie werden bei absoluten Zusatzachsbewegungen immer im Mode shortest verfahren. Für weitere Informationen siehe: MC_Direction MC_Direction Die maximale Anzahl von Zusatzachsen ist durch den Bibliotheksparameter  MAX_NUM_ADDITIONAL_AXES der Bibliothek SM3_CPKernelDefaults beschränkt. Dieser Parameter kann im Bibliotheksmanager verändert werden. Ein Beispiel für die Verwendung von Zusatzachsen finden Sie hier: Verwendung von Zusatzachsen in der Robotik" }, 
{ "title" : "Toleranzen für die Bahngenauigkeit ", 
"url" : "_sm_path_accuracy_tolerances.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Toleranzen für die Bahngenauigkeit ", 
"snippet" : "Für Achsgruppen können Toleranzen für die Bahngenauigkeit eingestellt werden. Durch diese Toleranzen kann eine Achsgruppe bei einer unerwarteten Bewegung eines dynamischen Koordinatensytems dieses Koordinatensystem wieder einholen, statt mit Fehler SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GRO...", 
"body" : "Für Achsgruppen können Toleranzen für die Bahngenauigkeit eingestellt werden. Durch diese Toleranzen kann eine Achsgruppe bei einer unerwarteten Bewegung eines dynamischen Koordinatensytems dieses Koordinatensystem wieder einholen, statt mit Fehler SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED oder SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED zu stoppen. " }, 
{ "title" : "Überblick ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4560250800668834033944790208", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Toleranzen für die Bahngenauigkeit \/ Überblick ", 
"snippet" : "Warum sind Toleranzen für die Bahngenauigkeit nötig? Idealerweise sollte die Achsgruppe der Bahn exakt folgen. Wenn jedoch ein dynamisches Koordinatensystem verwendet wird (beispielsweise ein Objekt auf einem Band oder Rundtisch, oder ein Koordinatensystem, das durch eine andere Achsgruppe vorgegebe...", 
"body" : "Warum sind Toleranzen für die Bahngenauigkeit nötig? Idealerweise sollte die Achsgruppe der Bahn exakt folgen. Wenn jedoch ein dynamisches Koordinatensystem verwendet wird (beispielsweise ein Objekt auf einem Band oder Rundtisch, oder ein Koordinatensystem, das durch eine andere Achsgruppe vorgegeben wird), dann ist es in manchen Fällen nicht möglich, der Bahn zu folgen. Beispiel: Ein Roboter soll ein Teil auf einem Band platzieren. Das Band bewegt sich mit konstanter Geschwindigkeit, aber kurz bevor der Roboter die Ablageposition erreicht hat, beschleunigt das Band unerwartet. In dieser Situation wurde die Trajektorie für die Ablage des Teils bereits berechnet, aber mit der Annahme, dass sich das Band weiter mit konstanter Geschwindigkeit bewegt. Daher kann es jetzt sein, dass die restliche Bewegung zu einer Verletzung der maximalen Beschleunigung einer der Achsen des Roboters führt. In solchen Situationen sind die Toleranzen von Bedeutung. Sie erlauben der Achsgruppe innerhalb der vorgegebenen Grenzen von der Bahn abzuweichen und das Koordinatensystem wieder einzuholen. Die Bahngenauigkeit wird durch einen Filter geregelt. Der Filter erhält als Eingang die geplante Trajektorie ( q_ref ) und die zuletzt berechneten Sollpositionen ( q_set ). Ausgang des Filters sind die Sollpositionen ( q_set ), die den Antrieben übergeben werden. Wenn q_ref eine der Achsgrenzen verletzt, verlässt der Filter die Bahn und folgt der geplanten Trajektorie so gut wie möglich, ohne eine Achsgrenze zu verletzen. Solange der Schleppfehler zwischen q_set und q_ref innerhalb der Toleranzen liegt, wird kein Fehler ausgegeben. Die Toleranzen für die Bahngenauigkeit setzen sich aus mehreren Werten zusammen: Maximaler Schleppfehler des TCP in technischen Einheiten (Defaultwert: 1 u ) Maximaler Orientierungsfehler des TCP in Winkelgrad (Defaultwert: 1 deg ) Maximal erlaubter Schleppfehler jeder Achse in technischen Einheiten der Achse (Defaultwert: Unendlich) " }, 
{ "title" : "Auswirkung auf administrative Funktionsbausteine ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4579672191731234033944887183", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Toleranzen für die Bahngenauigkeit \/ Auswirkung auf administrative Funktionsbausteine ", 
"snippet" : "Die Werte für Position, Geschwindigkeit, Beschleunigung und Ruck, die von den Bausteinen SMC_GroupReadSetPosition , SMC_GroupReadSetVelocity , SMC_GroupReadSetAcceleration und SMC_GroupReadSetJerk zurückgegeben werden, werden auf Basis der geplanten Trajektorie ( q_ref ) berechnet. Sie enthalten dah...", 
"body" : "Die Werte für Position, Geschwindigkeit, Beschleunigung und Ruck, die von den Bausteinen SMC_GroupReadSetPosition , SMC_GroupReadSetVelocity , SMC_GroupReadSetAcceleration und SMC_GroupReadSetJerk zurückgegeben werden, werden auf Basis der geplanten Trajektorie ( q_ref ) berechnet. Sie enthalten daher nicht den Anteil, der durch den Filter beigesteuert wird. Die Istwerte von Position, Geschwindigkeit und Ruck dagegen, die von den Bausteinen MC_GroupReadActualPosition , MC_GroupReadActualVelocity und MC_GroupReadActualAcceleration zurückgegeben werden, werden aufgrund der Istposition der Antriebe der Achsgruppe berechnet. Damit enthalten sie auch den Anteil, der durch den Filter beigesteuert wird. Die Bahndynamik, die von SMC_GroupReadPathDynamics mit  Source = MC_SOURCE.SET  zurückgegeben wird,  basiert auf der geplanten Trajektorie ( q_ref ) und wird damit nicht vom Filter beeinflusst. (Für andere Werte des Eingangs Source ist der Anteil des Filters enthalten.) Bahnschaltpunkte beziehen sich immer auf die geplante Trajektorie ( q_ref ). Die Zeit, die von MC_GroupReadTrigger zurückgegeben wird, ist die Zeit, zu der die geplante Trajektorie den Bahnschaltpunkt erreicht. Wenn der Filter aktiv ist ( q_ref <> q_set ), dann erreicht die Achsgruppe die Position und\/oder die Zeit des Triggers in der Regel nicht exakt. Anmerkung: Eine Bewegung meldet erst Done , wenn sowohl die geplante Trajektorie ( q_ref ) das Ende der Bewegung erreicht hat als auch der Filter nicht (mehr) aktiv ist, also einen möglichen Schleppfehler wieder abgebaut hat. Dann entspricht die Sollposition ( q_set ) der Zielposition der Bewegung. " }, 
{ "title" : "Setzen der Toleranzen und Überwachung der Bahnabweichung ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4575205545955234033945121691", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Toleranzen für die Bahngenauigkeit \/ Setzen der Toleranzen und Überwachung der Bahnabweichung ", 
"snippet" : "Die Toleranzen können mit dem Baustein  SMC_GroupSetPathTolerance  gesetzt werden. Der Status des Filters und der aktuelle Schleppfehler zwischen der geplanter Trajektorie q_ref und den Sollwerten q_set der Achsgruppe kann mit den Ausgängen  InSync ,  PositionLag  und  OrientationLag  von  MC_GroupR...", 
"body" : "Die Toleranzen können mit dem Baustein  SMC_GroupSetPathTolerance  gesetzt werden. Der Status des Filters und der aktuelle Schleppfehler zwischen der geplanter Trajektorie q_ref und den Sollwerten q_set der Achsgruppe kann mit den Ausgängen  InSync ,  PositionLag  und  OrientationLag  von  MC_GroupReadStatus  überwacht werden. InSync = TRUE bedeutet, dass  q_ref = q_set ist und dass der Filter nicht aktiv ist. InSync = FALSE bedeutet, dass q_ref <> q_set ist und dass der Filter aktiv ist. " }, 
{ "title" : "Puffern und Überschleifen von Bewegungen ", 
"url" : "_sm_robotics_blending.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Puffern und Überschleifen von Bewegungen ", 
"snippet" : "Mit CODESYS SoftMotion können Bewegungsbefehle gepuffert werden. Für jede kommandierte Bewegung kann angegeben werden, wie die Bewegung gepuffert wird und wie von der vorangehenden Bewegung auf die neue Bewegung überschliffen werden soll. Die kommandierte Bahn wird dabei durch das Abrunden von Ecken...", 
"body" : "Mit CODESYS SoftMotion können Bewegungsbefehle gepuffert werden. Für jede kommandierte Bewegung kann angegeben werden, wie die Bewegung gepuffert wird und wie von der vorangehenden Bewegung auf die neue Bewegung überschliffen werden soll. Die kommandierte Bahn wird dabei durch das Abrunden von Ecken so angepasst, dass die Bahn ohne Anhalten abgefahren werden kann. Ob und auf welche Weise eine Bewegung gepuffert wird, kann über den Eingang BufferMode des Bewegungsbausteins (beispielsweise MC_MoveDirectAbsolute oder MC_MoveCircularRelative ) konfiguriert werden. Für weitere Informationen siehe MC_Buffer_MODE . Die Eingänge TransitionMode und TransitionParameter bestimmen, auf welche Art Ecken abgerundet werden. Für weitere Informationen siehe MC_TRANSITION_MODE . Für weitere Informationen zu Bewegungen siehe Funktionsbausteine für Bewegungen . Bei den Blending-Modi darf der TransitionMode nicht gleich TMNone sein. Das Überschleifen zwischen zwei Bewegungen startet frühestens ab der Hälfte der ersten Bewegung und endet spätestens zur Hälfte der zweiten Bewegung. Wenn die erste Bewegung schon zu weit geplant wurde, ist ein Überschleifen mit den eingestellten Parametern eventuell nicht mehr möglich. Dann wird der Überschleifbereich reduziert oder überhaupt nicht mehr überschliffen. Um ein erfolgreiches Überschleifen zu garantieren, sollten beide Bewegungen im selben Zyklus kommandiert werden. " }, 
{ "title" : "Bahndynamik während des Überschleifens ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-idm43523137701146", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Puffern und Überschleifen von Bewegungen \/ Bahndynamik während des Überschleifens ", 
"snippet" : "Wenn zwischen CP-Bewegungen überschliffen wird, also zwischen Geraden und Kreissegmenten, dann ist zu beachten, dass die maximale Bahnbeschleunigung und der maximale Bahnruck während des Überschleifens unter Umständen überschritten wird. Dieser Effekt ist umso ausgeprägter je kürzer der Überschleifb...", 
"body" : "Wenn zwischen CP-Bewegungen überschliffen wird, also zwischen Geraden und Kreissegmenten, dann ist zu beachten, dass die maximale Bahnbeschleunigung und der maximale Bahnruck während des Überschleifens unter Umständen überschritten wird. Dieser Effekt ist umso ausgeprägter je kürzer der Überschleifbereich ist. Die Grenzen der Achsen, also die maximale Achsbeschleunigung und der maximale Achsruck werden aber in jedem Fall eingehalten. Wenn also die maximale Bahnbeschleunigung niedrig und die maximale Achsbeschleunigung hoch ist, kann es beim Überschleifen zu hohen Beschleunigungen kommen. Dem kann beispielsweise über den Eingang AccFactor der Bewegungsbausteine gegengesteuert werden, indem die maximale Achsbeschleunigung für eine Bewegung reduziert wird. " }, 
{ "title" : "Besonderheiten von TMStartVelocity ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231378653745", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Puffern und Überschleifen von Bewegungen \/ Besonderheiten von TMStartVelocity ", 
"snippet" : "Die Berechnung der Überschleifpunkte basiert auf einer idealisierten Geschwindigkeitskurve, die von der tatsächlichen Geschwindigkeitskurve abweichen kann. Dabei wird auf der Originalbahn eine Bremsrampe auf den Überschleifpunkt zu und eine Beschleunigungsrampe vom Überschleifpunkt weg simuliert. Al...", 
"body" : "Die Berechnung der Überschleifpunkte basiert auf einer idealisierten Geschwindigkeitskurve, die von der tatsächlichen Geschwindigkeitskurve abweichen kann. Dabei wird auf der Originalbahn eine Bremsrampe auf den Überschleifpunkt zu und eine Beschleunigungsrampe vom Überschleifpunkt weg simuliert. Als Zielgeschwindigkeit wird das Minimum aus programmierter Bahngeschwindigkeit und der geschätzten, sich aus den Achslimits ergebenden maximalen Bahngeschwindigkeit verwendet. Zusätzlich wird beim Überschleifen zwischen Geraden der dazwischenliegende Winkel mit einbezogen. Aus der gewünschten Bahngeschwindigkeit und den geschätzten Dynamikgrenzen ergibt sich ein minimaler Krümmungsradius für das Überschleifelement. Aus diesem Radius und dem Winkel zwischen den Geraden ergeben sich wiederum die Punkte A' und B'. Wenn beim Überschleifen der Bewegungen trotz einem eingestellten Faktor von 1 eingebremst wird, kann es helfen, den Faktor zu erhöhen. " }, 
{ "title" : "Beispiel ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231380207819", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Puffern und Überschleifen von Bewegungen \/ Beispiel ", 
"snippet" : "In einer kleinen Beispielapplikation soll ein Werkstück aufgehoben werden. Dazu soll der Roboter zunächst über das Werkstück fahren und anschließend nach unten, um es aufzuheben. Um das Werkstück möglichst schnell zu erreichen, soll zwischen den beiden Bewegungen nicht angehalten, sondern überschlif...", 
"body" : "In einer kleinen Beispielapplikation soll ein Werkstück aufgehoben werden. Dazu soll der Roboter zunächst über das Werkstück fahren und anschließend nach unten, um es aufzuheben. Um das Werkstück möglichst schnell zu erreichen, soll zwischen den beiden Bewegungen nicht angehalten, sondern überschliffen werden. Zehn Einheiten bevor das Ende der ersten Bewegung erreicht wird, soll in die zweite Bewegung überschliffen werden. Um die Vorgaben zu erfüllen, müssen zwei Bewegungen kommandiert werden. Die erste Bewegung ( moveAbove ) über das Werkstück und die zweite Bewegung ( moveDown ) zum Werkstück nach unten. Für die zweite Bewegung muss definiert werden, wie die Bewegung gepuffert und überschliffen werden soll. Wie im nachfolgenden Bild dargestellt, wird für den BufferMode BlendingHigh gewählt. Damit wird festgelegt, dass die Bewegung gepuffert nach der ersten Bewegung ausgeführt und überschliffen werden soll. Zusätzlich wird der TransitionMode TMCornerDistance mit einer Distanz von 10 Einheiten definiert, um passend in die zweite Bewegung zu überschleifen. Um die beiden Eingänge TransitionMode und TransitionParameter passend zu setzen, wie der Funktionsbaustein SMC_CornerDistance verwendet. " }, 
{ "title" : "Warten zwischen Bewegungen ", 
"url" : "_sm_robotics_wait.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Warten zwischen Bewegungen ", 
"snippet" : "SoftMotion Robotics bietet die Möglichkeit, eine bestimmte Zeit zwischen zwei Bewegungen zu warten. Dies kann beispielsweise nötig sein, wenn ein Roboter an der Zielposition einer Bewegung ein Werkstück greifen soll, bevor er die nächste Bewegung startet. Analog zu Bewegungen wird die Wartezeit über...", 
"body" : "SoftMotion Robotics bietet die Möglichkeit, eine bestimmte Zeit zwischen zwei Bewegungen zu warten. Dies kann beispielsweise nötig sein, wenn ein Roboter an der Zielposition einer Bewegung ein Werkstück greifen soll, bevor er die nächste Bewegung startet. Analog zu Bewegungen wird die Wartezeit über den Baustein SMC_GroupWait kommandiert. Nähere Informationen zu diesem Baustein finden sich unter SMC_GroupWait . " }, 
{ "title" : "Anhalten auf der Bahn mit MC_GroupHalt oder MC_GroupStop ", 
"url" : "_sm_robotics_halt_stop.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Anhalten auf der Bahn mit MC_GroupHalt oder MC_GroupStop ", 
"snippet" : "Die Funktionsbausteine MC_GroupHalt und MC_GroupStop erlauben ein bahntreues Anhalten unter Berücksichtigung konfigurierbarer Verzögerungs- und Ruckgrenzen. Das Anhalten beginnt unmittelbar. Die Verzögerungs- und Ruckgrenzen für das Anhalten können sich von denen der aktiven Bewegung unterscheiden u...", 
"body" : "Die Funktionsbausteine MC_GroupHalt und MC_GroupStop erlauben ein bahntreues Anhalten unter Berücksichtigung konfigurierbarer Verzögerungs- und Ruckgrenzen. Das Anhalten beginnt unmittelbar. Die Verzögerungs- und Ruckgrenzen für das Anhalten können sich von denen der aktiven Bewegung unterscheiden und sowohl größer als auch kleiner sein. Sie werden eingehalten, sofern dadurch die Bahn nicht verlassen wird. In der Mitte einer Bahn kann beispielsweise ein sanftes Anhalten mit niedriger Verzögerung möglich sein. Am Ende der Bahn wird dagegen mindestens so stark verzögert, dass nicht über das Ende hinausgefahren wird. Unterschied zwischen MC_GroupHalt und MC_GroupStop Der wesentliche Unterschied zwischen MC_GroupHalt und MC_GroupStop ist, dass ein MC_GroupStop nicht abgebrochen werden kann und dass Folgebewegungen erst akzeptiert werden, wenn der Eingang Execute zurückgesetzt worden ist. Ein MC_GroupStop verhindert, dass sich die Achsgruppe bewegt. Abgrenzung zu MC_GroupInterrupt Im Gegensatz zu MC_GroupHalt und MC_GroupStop startet ein MC_GroupInterrupt mit einer kurzen Latenz und hat keine konfigurierbaren Verzögerungs- und Ruckgrenzen. Stattdessen werden die Grenzen der aktiven Bewegung verwendet. Nach einem MC_GroupInterrupt kann mit MC_GroupContinue die unterbrochene Bewegung fortgesetzt werden. Unter Zuhilfenahme von SMC_GroupSaveContinueData ist das auch mit MC_GroupHalt und MC_GroupStop möglich. Für weitere Informationen siehe Unterbrechen und Fortsetzen von Bewegungen. Verhalten bei Bewegungen in beweglichen Koordinatensystemen Bei Bewegungen in beweglichen Koordinatensystemen , wenn sich der Roboter also beispielsweise relativ zu einem Förderband bewegt, führt ein MC_GroupHalt oder MC_GroupStop zu einem absoluten Anhalten. Es wird also nicht relativ zum beweglichen Koordinatensystem angehalten. Die Achsgruppe bleibt dabei auf der Bahn, die sie im Maschinenkoordinatensystem (MCS) abgefahren wäre, wenn kein MC_GroupHalt oder MC_GroupStop kommandiert worden wäre. " }, 
{ "title" : "Bewegungsplanung ", 
"url" : "_sm_robotics_factor_movements.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Bewegungsplanung ", 
"snippet" : "Wenn eine Bewegung beispielsweise mit MC_MoveLinearAbsolute kommandiert wird, dann hängt die resultierende Geschwindigkeit des Roboters von den folgenden Faktoren ab: Die maximale Geschwindigkeit, Beschleunigung und Ruck für jede Achse der Achsgruppe (konfiguriert in der Achsenkonfiguration) Die Obe...", 
"body" : "Wenn eine Bewegung beispielsweise mit MC_MoveLinearAbsolute kommandiert wird, dann hängt die resultierende Geschwindigkeit des Roboters von den folgenden Faktoren ab: Die maximale Geschwindigkeit, Beschleunigung und Ruck für jede Achse der Achsgruppe (konfiguriert in der Achsenkonfiguration) Die Obergrenzen definieren für jede Achse, wie schnell sie sich bewegen darf. Die anderen unten erläuterten Grenzwerte können die effektiven Grenzwerte nur reduzieren, sie können sie nicht über diese Grenzwerte hinaus erhöhen. Die maximale Geschwindigkeit, Beschleunigung und Ruck, die als Eingänge für den Bewegungs-Funktionsbaustein übergeben werden. Diese Obergrenzen definieren, wie schnell sich der TCP auf der Bahn bewegen kann. Sie gelten zusätzlich zu den Grenzen der einzelnen Achsen. Der aktuelle Override (siehe MC_GroupSetOverride ) und die zusätzlichen Grenzen für eine Achsgruppe Eine Beschreibung, wie alle diese Grenzen kombiniert werden, um die effektiven Pfad- und Achsgrenzen zu berechnen, finden Sie in der Hilfe zu SMC_GroupSetAncillaryAxisLimits , SMC_GroupSetAncillaryPathLimits und SMC_GroupSetAxisLimitFactors . Die programmierte Bahn des Roboters Wenn beispielsweise das Überschleifen zwischen Bewegungen zu einem sehr kleinen Krümmungsradius führt, muss sich der Roboter langsam bewegen, um die Achsgrenzen nicht zu überschreiten. Zusammen bestimmen diese Faktoren die effektive maximale Geschwindigkeit auf der Bahn. Es gibt jedoch noch einen weiteren Faktor, der die erreichbare Geschwindigkeit begrenzen kann: Die Leistung der SPS. Wenn die Leistung für die Planung der Bewegung nicht ausreicht, bewegt sich der Roboter mit einer langsameren Geschwindigkeit. Wenn der Planungsalgorithmus aus Performance-Gründen nicht überprüfen kann, ob der Roboter sicher beschleunigt werden kann, bewegt er sich mit einer langsameren Geschwindigkeit. Für weitere Informationen siehe: Performance" }, 
{ "title" : "Unterbrechen und Fortsetzen von Bewegungen ", 
"url" : "_sm_robotics_stop_continue_movements.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Unterbrechen und Fortsetzen von Bewegungen ", 
"snippet" : "Während der Bewegung einer Achsgruppe kann es zum Stopp der Bewegung kommen. Dies kann ein beabsichtigtes Anhalten ( MC_GroupHalt , MC_GroupStop ) oder Pausieren auf der Bahn ( MC_GroupInterrupt ), oder ein Halt aufgrund einer Störung sein. In allen Fällen bietet CODESYS SoftMotion Funktionsbaustein...", 
"body" : "Während der Bewegung einer Achsgruppe kann es zum Stopp der Bewegung kommen. Dies kann ein beabsichtigtes Anhalten ( MC_GroupHalt , MC_GroupStop ) oder Pausieren auf der Bahn ( MC_GroupInterrupt ), oder ein Halt aufgrund einer Störung sein. In allen Fällen bietet CODESYS SoftMotion Funktionsbausteine, um die Achsgruppe zurück auf die geplante Bahn zu bewegen und diese fortzusetzen. Bewegungsstopp durch eine Störung Kommt es während der Bewegung aufgrund einer Störung zu einem Bewegungsstopp, werden die einzelnen Achsen einer Achsgruppe individuell angehalten und in den Fehlerzustand geschaltet. Dabei verlässt der TCP die geplante Bahn. Sie können nun den Fehler quittieren, die Achsgruppe zurücksetzen und zu der Position fahren, an der der Fehler erkannt wurde. Danach können Sie die Achsgruppe anweisen, die zuvor geplante Bewegungen fortzusetzen. Mit dem Funktionsbaustein SMC_GroupEnableResumeAfterError schalten Sie die Funktion ein, um nach einem Fehler die programmierten Bewegungen wieder aufzunehmen. Der Baustein muss in der Buszyklustask zyklisch aufgerufen werden. Pro Achsgruppe darf nur eine Instanz dieses Funktionsbausteins aufgerufen werden. Wenn die Achsgruppe einen Fehler erkennt und in den Zustand Errorstop wechselt, dann speichert sie die bereits akzeptierten Bewegungen sowie die notwendigen Zustandsinformationen in einer Variablen vom Typ SMC_AXIS_GROUP_CONTINUE_DATA . Diese Variable beinhaltet dann die „Continue-Daten“ und wird als Eingang von SMC_GroupEnableResumeAfterError übergeben. So können Sie die Bewegungen unter Verwendung von MC_GroupContinue später wieder aufnehmen. Wenn die Fehler durch die kommandierten Bewegungen entstehen (Beispiel: Arbeitsraumverletzungen oder ein ungültiger Bogenradius), können sie auf diese Weise nicht beseitigt werden. Diese Fehler werden nach dem Fortsetzen der Bewegung wieder auftreten. Der Mechanismus ist eher für Einzelachsfehler und andere externe Ereignisse gedacht, die die Achsgruppe in den Fehlerstopp zwingen. MC_GroupContinue erfordert, dass sich die Achsgruppe beim Fortsetzen der Bewegung an einer bestimmten Position befindet. Im Falle der Wiederaufnahme nach einem Fehler ist diese Position die aktuelle Position zum Zeitpunkt als der Fehler erkannt wurde. Sie können diese Position mit dem Funktionsbaustein SMC_GroupGetContinuePosition abfragen. Wenn ein Achsgruppenfehler das Fortsetzen der Bewegung nicht zulässt (wie ein interner Fehler beim Schreiben der Continue-Daten), geben MC_GroupContinue und SMC_GroupGetContinuePosition die neue Fehler-ID SMC_AXIS_GROUP_CONTINUE_DATA_NOT_WRITTEN zurück. Wenn ein MC_GroupStop aktiv ist, wenn der Fehler auftritt, dann ist der MC_GroupStop auch nach dem Fortsetzen wieder aktiv. Die Achsgruppe wurde bereits gestoppt, und der MC_GroupStop hat alle anstehenden Bewegungen gelöscht, so dass keine Bewegung stattfindet. Wenn ein Achsgruppenfehler auftritt, zeigt die Funktionsbausteininstanz der aktiven Bewegung den Fehler an (Ausgänge Active und Busy gehen auf FALSE , Ausgang Error geht auf TRUE ). Die Funktionsbausteininstanzen von gepufferten oder überschliffenen Bewegungen, die noch nicht aktiv geworden sind, zeigen ebenfalls einen Fehler an. Nach dem Wiederanlauf werden alle diese Funktionsblockinstanzen wieder Busy \/ Active und ihre Ausgänge Error \/ CommandAborted werden zurückgesetzt. " }, 
{ "title" : "Bewegungsstopp durch Pausieren ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_74b10b31cbbdb856c0a8646354735c5f", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Unterbrechen und Fortsetzen von Bewegungen \/ Bewegungsstopp durch Pausieren ", 
"snippet" : "Mit Hilfe der Funktionsbausteine MC_GroupInterrupt und MC_GroupInterruptAt können Sie die Ausführung der kommandierten Bewegungen pausieren. Dabei wird bei MC_GroupInterrupt ein sofortiger Halt und bei MC_GroupInterruptAt ein Halt an einer bestimmten Position ausgeführt. Die Bewegung kann dann späte...", 
"body" : "Mit Hilfe der Funktionsbausteine MC_GroupInterrupt und MC_GroupInterruptAt können Sie die Ausführung der kommandierten Bewegungen pausieren. Dabei wird bei MC_GroupInterrupt ein sofortiger Halt und bei MC_GroupInterruptAt ein Halt an einer bestimmten Position ausgeführt. Die Bewegung kann dann später mit MC_GroupContinue fortgesetzt werden. Der Funktionsbaustein MC_GroupInterruptAt stellt den Eingang SMC_GroupInterruptPositionMvtRel zur Verfügung. Dieser spezifiziert eine zur Bewegung relative Unterbrechungsposition. Die Bewegung wird durch ihre SMC_Movement_Id referenziert. Die Position innerhalb der Bewegung wird durch einen Wert (Real) zwischen 0 und 1 definiert, wobei 0 der Beginn und 1 das Ende der Bewegung ist. Eine Position zwischen den Punkten B und A wird genauso interpretiert, als wenn es kein Überschleifen gäbe. Eine Position zwischen P start und B oder zwischen A und P dest wird auf die Überschleifbahn projiziert. Fehlerbehandlung bei MC_GroupInterruptAt Wenn die angegebene Bewegungs-ID unbekannt ist, gibt der Funktionsbaustein einen Fehler zurück. Die laufende Bewegung wird nicht unterbrochen. Wenn der aktuelle dynamische Zustand der Achsgruppe das Erreichen des Stillstands vor der angegebenen Unterbrechungsposition nicht zulässt, verhält sich SMC_GroupInterruptAt genauso wie MC_GroupInterrupt : Die Unterbrechung wird sofort ausgeführt und die Achsgruppe erreicht den Stillstand irgendwo hinter der kommandierten Unterbrechungsposition. Alle anderen Fehler werden genauso behandelt wie bei MC_GroupInterrupt . Einschränkungen bei MC_GroupInterruptAt Eine Unterbrechung an einer bestimmten Position kann mit einer anderen Bewegung abgebrochen werden, solange der Vorgang des Anhaltens an der Unterbrechungsposition noch nicht begonnen hat Es kann nur eine Unterbrechung an einer bestimmten Position zur gleichen Zeit kommandiert werden. Wenn eine Unterbrechung kommandiert wurde, muss diese entweder abgeschlossen oder abgebrochen werden, damit eine weiterer Unterbrechung akzeptiert werden kann. Wenn Sie MC_GroupInterrupt oder MC_GroupInterruptAt ausführen, wird zunächst, ähnlich wie bei einem MC_GroupHalt , ein bahntreuer Halt ausgeführt. Dann wird der Zustand der Achsgruppe („Continue-Daten“) in einer vom Anwender übergebenen Variable vom Typ SMC_AXIS_GROUP_CONTINUE_DATA gespeichert. Jetzt ist die Achsgruppe im Zustand GroupStandby und kann ganz normal verwendet werden. Typisch wäre zum Beispiel, dass die Achsgruppe gejoggt wird. Später können Sie dann mit MC_GroupContinue die unterbrochene Ausführung wieder aufnehmen. Dazu übergeben Sie die gespeicherten „Continue-Daten“. Damit dies ohne Fehler funktioniert, muss die Position der Achsgruppe mit der Position übereinstimmen, die sie nach Ausführung von MC_GroupInterrupt hatte. (Siehe SMC_GroupGetContinuePosition .) Wenn eine Tracking-Bewegung unterbrochen wurde (eine Bewegung, die relativ zu einem dynamischen Koordinatensystem kommandiert wurde), hält MC_GroupInterrupt nicht absolut an (wie MC_GroupHalt ), sondern relativ zum dynamischen Koordinatensystem. Wenn zum Beispiel ein Werkstück auf einem Rundtisch verfolgt wird, hält MC_GroupInterrupt in Bezug auf das Werkstück an. Die Achsgruppe folgt weiterhin dem Werkstück. Die Continue-Daten müssen mit SMC_GroupUpdateContinueData aktualisiert werden, wenn die Kinematik rotierende Achsen mit mehreren Perioden hat. Danach kann die Bewegung mit MC_GroupContinue fortgesetzt werden. Die Variable vom Typ SMC_AXIS_GROUP_CONTINUE_DATA darf nicht persistent gespeichert oder während eines Online-Change geändert werden. Mit Hilfe des Funktionsbausteins SMC_GroupWait können Sie auf der Bahn zwischen zwei Bewegungen für eine programmierbare Zeit warten. " }, 
{ "title" : "Bewegungsstopp durch MC_GroupHalt oder MC_GroupStop ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_28e8e9a71ed1fa93c0a8646375852228", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Unterbrechen und Fortsetzen von Bewegungen \/ Bewegungsstopp durch MC_GroupHalt oder MC_GroupStop ", 
"snippet" : "Nach einem mit MC_GroupHalt oder MC_GroupStop ausgelösten Bewegungsstopp kann die Bewegung der Achsgruppe durch Verwendung von SMC_GroupSaveContinueData und MC_GroupContinue ohne Informationsverlust fortgesetzt werden. Dieser Baustein speichert den aktuellen Status, die aktuelle Position und alle ko...", 
"body" : "Nach einem mit MC_GroupHalt oder MC_GroupStop ausgelösten Bewegungsstopp kann die Bewegung der Achsgruppe durch Verwendung von SMC_GroupSaveContinueData und MC_GroupContinue ohne Informationsverlust fortgesetzt werden. Dieser Baustein speichert den aktuellen Status, die aktuelle Position und alle kommandierten Bewegungen. Damit kann später die Bewegung von genau dieser Position aus fortgesetzt werden. Verhalten vor Version 4.12.0.0: Der Funktionsbaustein SMC_GroupSaveContinueData muss im selben Zyklus aufgerufen werden, in dem MC_GroupHalt oder MC_GroupStop aufgerufen wird. Dabei muss sichergestellt werden, dass SMC_GroupSaveContinueData vor MC_GroupHalt oder MC_GroupStop aufgerufen wird, da sonst die abgebrochenen Bewegungen aus der Warteschlange entfernt werden. Verhalten ab Version 4.12.0.0: Der Funktionsbaustein SMC_GroupSaveContinueData kann zu jedem beliebigen Zeitpunkt bis zur ersten Bewegung nach dem Aufruf von MC_GroupHalt oder MC_GroupStop aufgerufen werden. Die Fortsetzungsposition ist die aktuelle Achsgruppenposition zum Zeitpunkt des ersten Aufrufs des Funktionsbausteins. Der gespeicherte Pfad besteht aus allen Bewegungen, die vor dem Halt\/Stopp-Befehl akzeptiert wurden. Um die Bahn nach einem MC_GroupHalt oder MC_GroupStop an der Position fortsetzen zu können, an der die Achsgruppe stehen geblieben ist, sollte also SMC_GroupSaveContinueData in dem Zyklus aufgerufen werden, in dem MC_GroupHalt \/ MC_GroupStop das Done -Signal setzt. Pro Achsgruppe darf nur eine Instanz von SMC_GroupSaveContinueData aufgerufen werden. Das Speichern des aktuellen Status vor dem Halt-\/Stopp-Befehl kann mehrere Zyklen dauern, aber es ist garantiert, dass die Statusinformationen im ersten Zyklus vor allen Abbruchbewegungen gespeichert werden. SMC_GroupSaveContinueData kann jederzeit zum Speichern des aktuellen Zustands aufgerufen werden, nicht nur in Kombination mit Aufrufen von MC_GroupHalt oder MC_GroupStop . " }, 
{ "title" : "Zusammenspiel mit Einzelachsbewegungen ", 
"url" : "_sm_additional_axes_single_axes.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Zusammenspiel mit Einzelachsbewegungen ", 
"snippet" : "Jede Achse einer Achsgruppe, inklusive eventueller Zusatzachsen, kann auch mit Einzelachsbewegungen verfahren werden. Dazu muss die Achse nicht aus der Achsgruppe entfernt werden. Dabei gelten folgende Regeln: Wenn die Achsgruppe im Zustand GroupStandby ist, wenn eine Einzelachsbewegung auf einer ih...", 
"body" : "Jede Achse einer Achsgruppe, inklusive eventueller Zusatzachsen, kann auch mit Einzelachsbewegungen verfahren werden. Dazu muss die Achse nicht aus der Achsgruppe entfernt werden. Dabei gelten folgende Regeln: Wenn die Achsgruppe im Zustand GroupStandby ist, wenn eine Einzelachsbewegung auf einer ihrer Achsen kommandiert wird, dann bleibt die Achsgruppe in diesem Zustand. Für weitere Informationen siehe: Zustände der AchsgruppeWenn die Achsgruppe im Zustand GroupMoving ist, wenn eine Einzelachsbewegung auf einer ihrer Achsen kommandiert wird, dann wechselt die Achsgruppe in den Zustand GroupError . Dabei wird der Fehler SMC_AXIS_GROUP_INTERRUPTED_BY_SINGLE_AXIS ausgegeben und alle anderen Achsen angehalten. Wenn eine Bewegung auf der Achsgruppe kommandiert wird, während eine Einzelachsbewegung auf mindestens einer ihrer Achsen aktiv ist, dann geht die Achsgruppe in den Zustand GroupError . " }, 
{ "title" : "Synchronisation mit einem beweglichen Koordinatensystem ", 
"url" : "_sm_robotics_dynamic_tracking.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Synchronisation mit einem beweglichen Koordinatensystem ", 
"snippet" : "Die integrierte Tracking-Funktion ermöglicht die Programmierung von Bewegungen relativ zu einem beweglichen Koordinatensystem. Ein typischer Anwendungsfall ist das Aufnehmen eines Produkts von einem Förderband und das Ablegen auf ein anderes Förderband. Nach der Definition eines dynamischen Koordina...", 
"body" : "Die integrierte Tracking-Funktion ermöglicht die Programmierung von Bewegungen relativ zu einem beweglichen Koordinatensystem. Ein typischer Anwendungsfall ist das Aufnehmen eines Produkts von einem Förderband und das Ablegen auf ein anderes Förderband. Nach der Definition eines dynamischen Koordinatensystems für jedes Band können Sie einfach Zielpositionen für Bewegungen in diesem Koordinatensystem angeben. CODESYS SoftMotion kümmert sich um die Überlagerung der kommandierten Bewegung der Achsgruppe und der Bewegung des Bandes. Eine typische Tracking-Bewegung besteht aus drei Phasen: Eintracken: Bewegen von einem anderen Koordinatensystem in das dynamische Koordinatensystem. Nach Erreichen der Zielposition folgt die Achsgruppe der Bewegung des dynamischen Koordinatensystems Tracking-Bewegung: Bewegung zu einer anderen Position innerhalb desselben dynamischen Koordinatensystems. Die kommandierte Bewegung und die Bewegung des dynamischen Koordinatensystems werden überlagert. Austracken: Bewegung vom dynamischen Koordinatensystem zu einem anderen Koordinatensystem. Nach Erreichen der Zielposition wird die Bewegung der Achsgruppe nicht mehr durch die Bewegung des dynamischen Koordinatensystems beeinflusst. " }, 
{ "title" : "Definition eines dynamischen Koordinatensystems ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4599737357387233382157942652", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Synchronisation mit einem beweglichen Koordinatensystem \/ Definition eines dynamischen Koordinatensystems ", 
"snippet" : "Der erste Schritt bei der Implementierung einer dynamischen Tracking-Anwendung ist die Definition eines dynamischen Koordinatensystems. CODESYS SoftMotion bietet vier Funktionsbausteine zur Definition dynamischer Koordinatensysteme: MC_TrackConveyorBelt : Ein einfach zu verwendender Funktionsbaustei...", 
"body" : "Der erste Schritt bei der Implementierung einer dynamischen Tracking-Anwendung ist die Definition eines dynamischen Koordinatensystems. CODESYS SoftMotion bietet vier Funktionsbausteine zur Definition dynamischer Koordinatensysteme: MC_TrackConveyorBelt : Ein einfach zu verwendender Funktionsbaustein für den häufigen Anwendungsfall des Trackings eines Förderbandes. Eine Referenz auf das eigentliche Band wird über den Eingang ConveyorBelt bereitgestellt, der eine SoftMotion-Achse vom Typ AXIS_REF_SM3 erwartet. MC_TrackRotaryTable : Ein einfach zu verwendender Funktionsbaustein für den häufigen Anwendungsfall des Trackings eines Drehtisches. Die Referenz auf den eigentlichen Drehtisch wird über den Eingang RotaryTable bereitgestellt, der eine SoftMotion-Achse vom Typ AXIS_REF_SM3 erwartet. MC_SetDynCoordTransform : Der Funktionsbaustein funktioniert ähnlich wie MC_TrackConveyorBelt und MC_TrackRotaryTable , wird jedoch nicht von einer einzelnen Achse, sondern von einer ganzen Achsgruppe gesteuert. Dies ermöglicht die Implementierung eines dynamischen Koordinatensystems mit bis zu sechs Freiheitsgraden. SMC_SetDynCoordTransformEx : Der Funktionsbaustein ermöglicht die Implementierung eines vollständig benutzerdefinierten dynamischen Koordinatensystems. Jeder der vier Funktionsbausteine hat einen Eingang CoordSystem , der es im Wesentlichen ermöglicht, dem Koordinatensystem einen Namen zu geben, entweder PCS_1 oder PCS_2 . Wenn eine Bewegung kommandiert wird, wird das Koordinatensystem durch diesen Namen referenziert. " }, 
{ "title" : "Kommandieren einer Bewegung zu einer Position in einem dynamischen Koordinatensystem ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4620464078688033382158385681", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Synchronisation mit einem beweglichen Koordinatensystem \/ Kommandieren einer Bewegung zu einer Position in einem dynamischen Koordinatensystem ", 
"snippet" : "Nachdem ein dynamisches Koordinatensystem definiert wurde, ist es einfach, eine Bewegung zu einer Position in diesem Koordinatensystem zu kommandieren. Jeder Bewegungsfunktionsbaustein, beispielsweise MC_MoveLinearAbsolute , hat einen Eingang CoordSystem . Dieser Eingang muss auf den Namen ( PCS_1 o...", 
"body" : "Nachdem ein dynamisches Koordinatensystem definiert wurde, ist es einfach, eine Bewegung zu einer Position in diesem Koordinatensystem zu kommandieren. Jeder Bewegungsfunktionsbaustein, beispielsweise MC_MoveLinearAbsolute , hat einen Eingang CoordSystem . Dieser Eingang muss auf den Namen ( PCS_1 oder PCS_2 ) des dynamischen Koordinatensystems gesetzt werden. Der Eingang Position kann dann auf die gewünschte Position bezogen auf den Ursprung des dynamischen Koordinatensystems gesetzt werden. Die Ausführung des Bewegungsfunktionsbausteins führt zu einer Bewegung zu der Position innerhalb des beweglichen Koordinatensystems. Sobald die Zielposition erreicht ist, folgt die Achsgruppe dem dynamischen Koordinatensystem und bleibt dabei an dieser relativen Position. " }, 
{ "title" : "Der \"InUse\"-Ausgang von Funktionsbausteinen für dynamische Koordinatensysteme ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4663886345662433382158689616", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Synchronisation mit einem beweglichen Koordinatensystem \/ Der \"InUse\"-Ausgang von Funktionsbausteinen für dynamische Koordinatensysteme ", 
"snippet" : "Jeder Funktionsbaustein für dynamische Koordinatensysteme ( MC_TrackConveyorBelt , MC_TrackRotaryTable , MC_SetDynCoordTransform und SMC_SetDynCoordTransformEx ) hat einen Ausgang InUse . Ein Neustart eines Funktionsbausteins, während das Koordinatensystem noch in Verwendung ist, ist nicht zulässig ...", 
"body" : "Jeder Funktionsbaustein für dynamische Koordinatensysteme ( MC_TrackConveyorBelt , MC_TrackRotaryTable , MC_SetDynCoordTransform und SMC_SetDynCoordTransformEx ) hat einen Ausgang InUse . Ein Neustart eines Funktionsbausteins, während das Koordinatensystem noch in Verwendung ist, ist nicht zulässig und führt zu dem Fehler SMC_AXIS_GROUP_PCS_STILL_IN_USE . Ein dynamisches Koordinatensystem wird in Verwendung genommen, sobald eine Bewegung zu einer Position im Koordinatensystem kommandiert wird. Das Koordinatensystem bleibt so lange in Verwendung, bis eine Zielposition in einem anderen Koordinatensystem erreicht wird. " }, 
{ "title" : "Achsgrenzen für Tracking-Bewegungen ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4557758355867233382158929251", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Synchronisation mit einem beweglichen Koordinatensystem \/ Achsgrenzen für Tracking-Bewegungen ", 
"snippet" : "Die Achsgrenzen für Geschwindigkeit, Beschleunigung, Verzögerung und Ruck müssen so eingestellt werden, dass sie die Bewegung des Koordinatensystems als auch die kommandierte Bewegung relativ zum Koordinatensystem berücksichtigen. Wenn eine hohe Achsendynamik erforderlich ist, um dem Koordinatensyst...", 
"body" : "Die Achsgrenzen für Geschwindigkeit, Beschleunigung, Verzögerung und Ruck müssen so eingestellt werden, dass sie die Bewegung des Koordinatensystems als auch die kommandierte Bewegung relativ zum Koordinatensystem berücksichtigen. Wenn eine hohe Achsendynamik erforderlich ist, um dem Koordinatensystem zu folgen, ist die Bewegung relativ zum Koordinatensystem möglicherweise nur langsam oder gar nicht möglich. Befindet sich die Achsgruppe in der Nähe einer Singularität der Kinematik, kann dies sogar bei einem relativ langsam bewegten Koordinatensystem der Fall sein. Für weitere Informationen siehe: Registerkarte: Allgemein" }, 
{ "title" : "Bahndynamik von CP-Bewegungen während des Trackings ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm466388653271043338215917861", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Synchronisation mit einem beweglichen Koordinatensystem \/ Bahndynamik von CP-Bewegungen während des Trackings ", 
"snippet" : "Der Bahndynamik von CP-Bewegungen muss besondere Aufmerksamkeit gewidmet werden. Dies betrifft die Eingänge Velocity , Acceleration , Deceleration , und Jerk von MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute und MC_MoveCircularRelative . Befinden sich Start- und Zielpositio...", 
"body" : "Der Bahndynamik von CP-Bewegungen muss besondere Aufmerksamkeit gewidmet werden. Dies betrifft die Eingänge Velocity , Acceleration , Deceleration , und Jerk von MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute und MC_MoveCircularRelative . Befinden sich Start- und Zielposition im selben dynamischen Koordinatensystem, so ist die Bahndynamik relativ zu diesem Koordinatensystem. Befinden sich Start- und Zielposition jedoch in unterschiedlichen Koordinatensystemen, so wird die Bahndynamik von der Dynamik relativ zum ersten Koordinatensystem in die Dynamik relativ zum zweiten Koordinatensystem überführt. Es ist wichtig, dass die Bahndynamik höher eingestellt wird als der absolute Wert der Differenz der Dynamik zwischen den beiden Koordinatensystemen. Insbesondere beim Übergang von einem statischen zu einem dynamischen Koordinatensystem sollte die Bahndynamik höher angesetzt werden als der Absolutwert der Dynamik des Koordinatensystems. Die Bahngeschwindigkeit kann nicht mit SMC_GroupReadPathDynamics überwacht werden, wenn zwischen Koordinatensystemen gewechselt wird (Eintracken, Austracken oder Bewegung zwischen verschiedenen dynamischen Koordinatensystemen). SMC_GroupReadPathDynamics berechnet die Bahndynamik relativ zu einem angegebenen Koordinatensystem. Im Falle des Eintrackens oder Austrackens oder der Bewegung zwischen dynamischen Koordinatensystemen handelt es sich um eine Bewegung, die von zwei Koordinatensystemen abhängt (Start- und Zielkoordinatensystem sind unterschiedlich). Daher ist der Funktionsbaustein SMC_GroupReadPathDynamics nicht geeignet, um die Bahndynamik für diese Fälle zu berechnen. " }, 
{ "title" : "Vermeiden der Fehler SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED oder SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4558812953211233382159412375", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Synchronisation mit einem beweglichen Koordinatensystem \/ Vermeiden der Fehler SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED oder SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED ", 
"snippet" : "Die Fehler SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED oder SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED werden gemeldet gemeldet, wenn es nicht möglich ist, dem kommandierten Weg zu folgen, ohne die konfigurierten Achsgrenzen oder die Bahndynamik zu verletzen. Wen...", 
"body" : "Die Fehler SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED oder SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED werden gemeldet gemeldet, wenn es nicht möglich ist, dem kommandierten Weg zu folgen, ohne die konfigurierten Achsgrenzen oder die Bahndynamik zu verletzen. Wenn dieser Fehler auftritt, sollte zunächst geprüft werden, ob die Achsgrenzen und die Bahndynamik gemäß den beiden vorangegangenen Abschnitten konfiguriert sind. Die Bahnabweichung kann mit den Ausgängen PositionLag und OrientationLag des Funktionsbausteins MC_GroupReadStatus überwacht werden. Mögliche Lösungen sind: Erhöhung der Achsgrenzen Erhöhung der Bahndynamik von CP-Bewegungen beim Tracking eines Koordinatensystem Reduzierung der Dynamik des Koordinatensystems Vermeidung von Bewegungen in der Nähe einer Singularität der Kinematik, beispielsweise durch Neupositionierung des Roboters Wenn das dynamische Koordinatensystem durch den Ausgang eines verrauschten Encoders gesteuert wird, kann es hilfreich sein, das Encodersignal mit einer logischen Achse zu filtern. Für weitere Informationen siehe: Registerkarte: Logische Achsen. Eine akzeptable Toleranz für die Positions- und Orientierungsabweichung kann mit dem Funktionsbaustein SMC_GroupSetPathTolerance konfiguriert werden. " }, 
{ "title" : "Rotatorische Achsen mit einem Wertebereich von mehr als 360° ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Rotatorische Achsen mit einem Wertebereich von mehr als 360° ", 
"snippet" : "Verhalten bei CP-Bewegungen Während einer CP-Bewegung ( MC_MoveLinearAbsolute \/ MC_MoveLinearRelative , MC_MoveCircularAbsolute \/ MC_MoveCircularRelative ) werden rotatorische Achsen immer im Automatikmodus (Period 0) verfahren. Es wird immer die Periode der Achse gewählt, so dass es nicht zu einem ...", 
"body" : "Verhalten bei CP-Bewegungen Während einer CP-Bewegung ( MC_MoveLinearAbsolute \/ MC_MoveLinearRelative , MC_MoveCircularAbsolute \/ MC_MoveCircularRelative ) werden rotatorische Achsen immer im Automatikmodus (Period 0) verfahren. Es wird immer die Periode der Achse gewählt, so dass es nicht zu einem Sprung der Achse kommt. Dabei kann es unter Umständen vorkommen, dass am Ende der CP-Bewegung nicht der kommandierte Achswert erreicht würde, sondern die Achse wegen der automatischen Auswahl der Periode in einer anderen Periode ankommt. Dies bedeutet, dass die kommandierte Position mit der gewählten Bewegungsart nicht erreichbar ist. Dieser Konflikt wird vor Erreichen der Zielposition erkannt, die Achsgruppe wird gestoppt und ein Fehler wird ausgegeben. Beispiel: Sie verwenden einen SCARA-Roboter mit drei rotatorischen Achsen A1, A2 und A3. A3 hat einen Wertebereich von -360° bis +360°. Sie teachen zwei Positionen in Achskoordinaten. Position1 = (A1 = 0°, A2 = 90°, A3 = 170°), Position2 = (A1 = 10°, A2 = 90°, A3 = -170°). Dann kommandieren Sie eine Linearbewegung ( MC_MoveLinear\/MC_MoveAbsolute) mit Orientierungsmodus GreatCircle . Diese Kombination von Kommandierung im ACS und Großkreis-Orientierungsinterpolation erzeugt einen Konflikt. Um der Orientierungsinterpolation zu folgen, müsste die Achse A3 von 170° in positiver Richtung nach 190° fahren. Sie kann daher die geforderte Zielposition (-170°) nicht erreichen. Anmerkung: bei CP-Bewegungen wird die Periode der rotatorischen Achse durch die gewählte Interpolationsart bestimmt. Das bedeutet auch, dass die Zielposition der Achse von der Bahn abhängt, auf der der Zielpunkt angefahren wird. Es ist daher beipielsweise möglich, dass durch das Blending zwischen zwei Bewegungen eine Achse in einer anderen Periode ankommt als dies bei Buffered-Bewegungen der Fall gewesen wäre. Für weitere Informationen siehe: Orientierungsinterpolation bei CP-Bewegungen" }, 
{ "title" : "Einleitung ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_48a1e2bdb79a4093c0a864631bc39e2b", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Rotatorische Achsen mit einem Wertebereich von mehr als 360° \/ Einleitung ", 
"snippet" : "Roboter haben oft rotatorische Achsen mit einem Wertebereich von mehr als 360°. Zum Beispiel kann die letzte Achse (Orientierungsachse A3) eines SCARA-Roboters oft mehr als eine Umdrehung fahren, etwa von -540° bis 540°. Dies bedeutet, dass dieselbe Position und Orientierung auf mehrere Arten angefa...", 
"body" : "Roboter haben oft rotatorische Achsen mit einem Wertebereich von mehr als 360°. Zum Beispiel kann die letzte Achse (Orientierungsachse A3) eines SCARA-Roboters oft mehr als eine Umdrehung fahren, etwa von -540° bis 540°. Dies bedeutet, dass dieselbe Position und Orientierung auf mehrere Arten angefahren werden kann. Um beim SCARA zu bleiben, ist beispielsweise die Orientierung und Position des Werkzeuges identisch, egal ob die letzte Achse bei -170° oder bei 190° (= -170° + 360°) steht. Folglich ist die Umrechnung von kartesischer Position und Orientierung zu Achswerten (die kinematische Rückwärtstransformation) nicht eindeutig, sondern hat mehrere Lösungen. Dies kann beispielsweise bei Pick & Place-Anwendungen genutzt werden, um Zeit zu sparen, indem man von 170° nach 190° und nicht nach -170° fährt. Hinweis: Die Bewegung der Orientierungsachse des SCARA kann bei solchen Anwendungen schnell zum begrenzenden Faktor für die Taktzeit werden. " }, 
{ "title" : "Auflösung der Mehrdeutigkeit ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_e9620f70b79a4093c0a86463477a7031", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Rotatorische Achsen mit einem Wertebereich von mehr als 360° \/ Auflösung der Mehrdeutigkeit ", 
"snippet" : "Wenn die zu verfahrenden Punkte im Achskoordinatensystem (ACS) kommandiert werden, dann ist für jede Achse klar, welchen Wert sie im Zielpunkt annehmen wird. Dagegen gibt es bei kartesischer Kommandierung (Position in X\/Y\/Z und Orientierung in A\/B\/C) die besagte Mehrdeutigkeit für rotatorische Achse...", 
"body" : "Wenn die zu verfahrenden Punkte im Achskoordinatensystem (ACS) kommandiert werden, dann ist für jede Achse klar, welchen Wert sie im Zielpunkt annehmen wird. Dagegen gibt es bei kartesischer Kommandierung (Position in X\/Y\/Z und Orientierung in A\/B\/C) die besagte Mehrdeutigkeit für rotatorische Achsen. Zur Auflösung dieser Mehrdeutigkeit wird die sogenannte Konfiguration der Kinematik verwendet. Beim SCARA-Roboter enthält die Konfiguration bereits die Einstellung, ob der SCARA einen Punkt mit ElbowRight oder ElbowLeft anfahren soll. Zusätzlich enthält die Konfiguration des SCARA auch die Einstellung nPeriodA3 , mit der festgelegt werden kann, wie die Mehrdeutigkeit für Achse A3 aufgelöst werden soll. Dazu wird der gesamte Wertebereich in sogenannte Perioden der maximalen Länge von 360° aufgeteilt: Periode -1 von -540° bis -180° Periode 1 von -180° bis 180° Periode 2 von 180° bis 540° (Bei einem größeren Wertebereich der Achse gibt es entsprechend weitere mögliche Perioden.) Dazu gibt es noch einen speziellen Wert. Setzt man nPeriodA3 := 0 , dann ist eine automatische Auflösung der Mehrdeutigkeit aktiviert. Für PTP-Bewegungen bedeutet dies, dass die Periode so gewählt wird, dass für Achse 4 der Abstand zwischen Start- und Zielposition möglichst klein ist. (Das Verhalten bei CP-Bewegungen wird weiter unten beschrieben.) Es ist also möglich, die Auflösung der Mehrdeutigkeit einer rotatorischen Achse zu steuern, indem man die kinematische Konfiguration entsprechend setzt (siehe SMC_SetKinConfiguration ). Kinematiken, die diese Funktionalität unterstützen, implementieren die Schnittstelle SMKinematicWithConfigurations3 . Die Funktionsbausteine SMC_GroupReadSetPosition , MC_GroupReadActualPosition und SMC_GroupTargetPosition  geben die Konfiguration immer mit aktivierter automatischer Auflösung der Perioden aus. Die aktuelle Konfiguration mit explizit gesetzten Perioden kann ausgelesen werden, indem die Position im ACS ausgelesen und dann mittels  SMC_GroupConvertPosition  ins MCS konvertiert wird. Die dabei zurückgegebene Konfiguration hat explizit gesetzte Perioden. Für weitere Informationen siehe: Konfigurationen von Kinematiken" }, 
{ "title" : "Synchronisieren externer Achsen, Momentenvorsteuerung ", 
"url" : "_sm_robotics_external_axis_torque_control.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Synchronisieren externer Achsen, Momentenvorsteuerung ", 
"snippet" : "Die Achswerte der Achsen einer Achsgruppe werden normalerweise am Ende des Zyklus berechnet, nachdem der vom Anwender programmierte Applikationscode durchlaufen wurde. Für bestimmte Anwendungen ist es jedoch notwendig, dass diese Werte früher zur Verfügung stehen, um sie im Applikationscode zu verwe...", 
"body" : "Die Achswerte der Achsen einer Achsgruppe werden normalerweise am Ende des Zyklus berechnet, nachdem der vom Anwender programmierte Applikationscode durchlaufen wurde. Für bestimmte Anwendungen ist es jedoch notwendig, dass diese Werte früher zur Verfügung stehen, um sie im Applikationscode zu verwenden. Der Funktionsbaustein SMC_GroupUpdate sorgt dafür, dass die Werte aller Achsen, die Teil einer Achsgruppe sind, unmittelbar aktualisiert werden. Ein Anwendungsfall für SMC_GroupUpdate ist die Synchronisation von Achsen, die nicht Teil der Achsgruppe sind. Ein Beispiel wäre bei einem XY-Portal ein zweiter Antrieb für die X-Achse. Vor CODESYS SoftMotion Version 4.13.0.0: Ein weiterer Anwendungsfall für den Funktionsbaustein SMC_GroupUpdate ist die Drehmomentvorsteuerung. Die im aktuellen Zyklus berechneten Achswerte können genutzt werden, um mithilfe eines dynamischen Modells des Roboters die passenden Solldrehmomente zu berechnen. Ab CODESYS SoftMotion Version 4.13.0.0: Wenn der Achsgruppe ein dynamisches Modell mittels SMC_GroupSetDynamics zugewiesen worden ist, werden automatisch zyklisch Solldrehmomente berechnet, die zur Drehmomentvorsteuerung verwendet werden können. Die Verwendung von SMC_GroupUpdate ist für diesen Anwendungsfall nicht mehr notwendig. Für weitere Informationen siehe: Drehmomentbegrenzung und Drehmomentvorsteuerung" }, 
{ "title" : "Bahnschaltpunkte ", 
"url" : "_sm_digital_switches-1517880.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Bahnschaltpunkte ", 
"snippet" : "Bahnschaltpunkte werden verwendet, um eine Aktion auszuführen, wenn die Achsgruppe eine definierte Position auf der Bahn erreicht. Beispielsweise kann eine Klebstoffdüse eingeschaltet werden, wenn die Klebstoffposition erreicht ist. Bahnschaltpunkte unterstützen auch einen Zeitversatz, sodass die Ak...", 
"body" : "Bahnschaltpunkte werden verwendet, um eine Aktion auszuführen, wenn die Achsgruppe eine definierte Position auf der Bahn erreicht. Beispielsweise kann eine Klebstoffdüse eingeschaltet werden, wenn die Klebstoffposition erreicht ist. Bahnschaltpunkte unterstützen auch einen Zeitversatz, sodass die Aktion zu einem genau festgelegten Zeitpunkt vor oder nach Erreichen der Position ausgeführt werden kann. Dies kann beispielsweise verwendet werden, um die Totzeit einer Klebstoffdüse auszugleichen. Dafür bietet CODESYS SoftMotion die Möglichkeit, Bahnschaltpunkte auf Bewegungen zu konfigurieren und im Anschluss kontinuierlich die Restdauer bis zum Erreichen der Position auszulesen. Bei Bahnschaltpunkten ist folgendes zu beachten: Die Zeit bis zum Erreichen eines Bahnschaltpunktes kann erst abgefragt werden, wenn sich die Achsgruppe dem Bahnschaltpunkt bis auf eine konfigurierbare zeitliche Vorausschau genähert hat. Wie diese Vorausschau konfiguriert wird und welche Auswirkungen die Einstellungen haben, wird im Abschnitt  Konfigurieren der Applikation für die Verwendung von Bahnschaltpunkten erläutert. Die Trajektorie wird durch die Verwendung von Bahnschaltpunkten nicht verändert. Insbesondere wird die Trajektorie nicht verlangsamt, um die konfigurierte Vorausschau einzuhalten. Wenn beispielsweise die Position eines Bahnschaltpunkts am Anfang einer Bewegung schon nach 0.01 Sekunden erreicht wird, dann kann auch durch eine höhere Vorausschau nicht erreicht werden, dass mehr als 0.01 Sekunden vorher über das Erreichen informiert wird. Für weitere Informationen siehe Beispiele Bahnschaltpunkte 1: Einfaches Beispiel und Bahnschaltpunkte 2: Beispiel Klebeprozess. " }, 
{ "title" : "Konfigurieren der Applikation für die Verwendung von Bahnschaltpunkten ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612456003211233798533752147", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Bahnschaltpunkte \/ Konfigurieren der Applikation für die Verwendung von Bahnschaltpunkten ", 
"snippet" : "Konfiguration der zeitlichen Vorausschau Die zeitliche Vorausschau bestimmt, wie weit in die Zukunft geplant wird. Dies wird über den Parameter  fPlanningForecastDuration  des Bausteins  SMC_TuneCPKernel  eingestellt. Wie dieser Parameter eingestellt werden soll, hängt von den Anforderungen der Appl...", 
"body" : "Konfiguration der zeitlichen Vorausschau Die zeitliche Vorausschau bestimmt, wie weit in die Zukunft geplant wird. Dies wird über den Parameter  fPlanningForecastDuration  des Bausteins  SMC_TuneCPKernel  eingestellt. Wie dieser Parameter eingestellt werden soll, hängt von den Anforderungen der Applikation ab. Dabei gibt es zwei prinzipiell gegensätzliche Anforderungen: Eine möglichst weite zeitliche Vorausschau Eine möglichst geringe Latenz. Die Latenz beim Losfahren steigt, weil die Vorausschau zunächst aufgebaut werden muss. Die Größe dieser zusätzlichen Latenz hängt im Wesentlichen von der Performance der verwendeten Steuerung ab und ist im Allgemeinen sehr viel niedriger als die konfigurierte Vorausschau. Außerdem vergrößert sich die Latenz, bis die Achsgruppe auf Aborting-Bewegungen und Interrupts reagiert, um die konfigurierte Vorausschau. Die Vorausschau hat keine Auswirkungen auf MC_GroupHalt und MC_GroupStop . Beide Funktionsbausteine wirken immer unmittelbar und unabhängig von der konfigurierten Vorausschau. Der Parameter fPlanningForecastDuration  des Bausteins  SMC_TuneCPKernel  sollte deshalb so hoch wie nötig, aber so niedrig wie möglich eingestellt werden. Wenn keine Vorausschau benötigt wird, kann der Parameter auf dem Standardwert 0 belassen werden. Die tatsächlich verfügbare Vorausschau kann aus unterschiedlichen Gründen von der konfigurierten abweichen, beispielsweise wenn das Ende der letzten Bewegung schon nahezu erreicht ist. Die aktuell verfügbare Vorausschau kann über den Ausgang  CurrentPlanningForecast  von  MC_GroupReadStatus  überwacht werden. Konfiguration der maximalen Anzahl an Bahnschaltpunkten pro Bewegung Im Auslieferungszustand unterstützt CODESYS SoftMotion bis zu 8 Bahnschaltpunkte pro Bewegung. Wenn diese Anzahl nicht ausreichen sollte, kann der Parameter  MAX_NUM_TRIGGERS_PER_MOVEMENT  als Bibliotheksparameter verändert werden. Dies ist möglich über den  Bibliotheksverwalter  und den dazugehörigen Editor für die  Bibliotheksparameter . Für die Verwendung von Bibliotheksparametern wird eine CODESYS -Version >= SP19 empfohlen. " }, 
{ "title" : "Kommandieren und Auswerten von Bahnschaltpunkten ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4620348699414433798534144567", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Bahnschaltpunkte \/ Kommandieren und Auswerten von Bahnschaltpunkten ", 
"snippet" : "Für die Kommandierung von Bahnschaltpunkten stehen zwei Bausteine zur Verfügung:  SMC_GroupPrepareTrigger   und  SMC_GroupReadTrigger . Bahnschaltpunkte werden einer Bewegung zugeordnet. Jeder einzelne Bahnschaltpunkt muss mithilfe des Bausteins  SMC_GroupPrepareTrigger  vorbereitet werden. Die Posi...", 
"body" : "Für die Kommandierung von Bahnschaltpunkten stehen zwei Bausteine zur Verfügung:  SMC_GroupPrepareTrigger   und  SMC_GroupReadTrigger . Bahnschaltpunkte werden einer Bewegung zugeordnet. Jeder einzelne Bahnschaltpunkt muss mithilfe des Bausteins  SMC_GroupPrepareTrigger  vorbereitet werden. Die Position kann relativ, absolut oder als Schnittpunkt mit einer Ebene angegeben werden (siehe  SMC_TriggerPositionType ). Die Aufrufreihenfolge von  SMC_GroupPrepareTrigger  und der dazugehörigen Bewegung ist von besonderer Bedeutung, da die vorbereiteten Bahnschaltpunkte der nächsten im selben Zyklus kommandierten Bewegung zugewiesen werden. Deswegen muss in jeder Applikation auf zwei Punkte geachtet werden: SMC_GroupPrepareTrigger  muss immer vor dem Bewegungsbaustein aufgerufen werden Bahnschaltpunkte und die dazugehörige Bewegung müssen immer im selben Zyklus kommandiert werden. Wenn im Zyklus keine Bewegung gestartet wird, werden die vorbereiteten Bahnschaltpunkte verworfen und der Ausgang CommandAborted  der Funktionsbausteine SMC_GroupPrepareTrigger  gesetzt. Wenn der Bahnschaltpunkt einer Bewegung zugeordnet ist, können Informationen zu einem Bahnschaltpunkt mithilfe von  SMC_GroupReadTrigger  abgefragt werden. Sobald der Bahnschaltpunkt innerhalb der verfügbaren zeitlichen Vorausschau liegt, wechselt der Status auf  SMC_TRIGGER_STATUS.Active  und die Zeit bis zum Erreichen des Bahnschaltpunktes kann ausgelesen werden. Die Zeit bezieht sich immer auf den Startzeitpunkt des aktuellen Zyklus. Abhängig davon, wann der Bahnschaltpunkt auslösen soll (vor, bei oder nach Erreichen der Position), kann in der Applikation in einem passenden Zyklus die gewünschte Aktion ausgeführt werden. Bahnschaltpunkte können nicht mehr entfernt werden, sobald sie einer Bewegung zugewiesen worden sind. Sie können aber einfach ignoriert werden. Wenn eine Bewegung durch eine zweite Bewegung mit  MC_BUFFER_MODE.Aborting  abgebrochen wird, verschwinden auch die der ersten Bewegung zugewiesenen Bahnschaltpunkte. " }, 
{ "title" : "Bahnschaltpunkte bei Bewegungen mit Überschleifen ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612455902227233798534431018", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Bewegungssteuerung \/ Bahnschaltpunkte \/ Bahnschaltpunkte bei Bewegungen mit Überschleifen ", 
"snippet" : "Bei Bewegungen mit  Puffern und Überschleifen von Bewegungen werden die Bahnschaltpunkte auf die resultierende Bahn projiziert. Das nachfolgende Bild zeigt qualitativ einen Fall, bei dem eine Bewegung von P1 zu P2 sowie eine Folgebewegung jeweils mit Überschleifen kommandiert wurden. Das Überschleif...", 
"body" : "Bei Bewegungen mit  Puffern und Überschleifen von Bewegungen werden die Bahnschaltpunkte auf die resultierende Bahn projiziert. Das nachfolgende Bild zeigt qualitativ einen Fall, bei dem eine Bewegung von P1 zu P2 sowie eine Folgebewegung jeweils mit Überschleifen kommandiert wurden. Das Überschleifen zur ersten Bewegung endet an Punkt B, das Überschleifen zur Folgebewegung startet an Punkt A. Zwischen P1 und B liegt der blaue Bahnschaltpunkt. Dieser wird auf die hintere Hälfte der ersten Überschleifbewegung projiziert (hervorgehoben durch die blaue Linie). Genauso wird der rote Bahnschaltpunkt, der zwischen A und P2 liegt, auf die vordere Hälfte der zweiten Überschleifbewegung projiziert (hervorgehoben durch die rote Linie). Der grüne Bahnschaltpunkt liegt außerhalb der Überschleifbereiche und wird nicht verschoben. Beim Überschleifen mit Bahnschaltpunkten gibt es eine Besonderheit, was den Status der Bewegung und der zugehörigen Bahnschaltpunkte betrifft. Der Kommandobaustein zur Bewegung von P1 zu P2 meldet  Done , sobald Punkt A erreicht ist. Der rote Bahnschaltpunkt, der zu dieser Bewegung gehört, bleibt aber weiterhin aktiv, bis die Position auf dem Überschleifelement erreicht ist, auf die er projiziert wurde. " }, 
{ "title" : "Drehmomentbegrenzung und Drehmomentvorsteuerung ", 
"url" : "_sm_torque_limitation.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Drehmomentbegrenzung und Drehmomentvorsteuerung ", 
"snippet" : "Die Drehmomentbegrenzung von CODESYS SoftMotion sorgt dafür, dass vorgegebene Grenzen der Drehmomente oder Kräfte der Antriebe bei koordinierten Bewegungen nicht überschritten werden. Diese Grenzen der Drehmomente und Kräfte werden zusätzlich zu den bestehenden Grenzen für die Geschwindigkeit, die B...", 
"body" : "Die Drehmomentbegrenzung von CODESYS SoftMotion sorgt dafür, dass vorgegebene Grenzen der Drehmomente oder Kräfte der Antriebe bei koordinierten Bewegungen nicht überschritten werden. Diese Grenzen der Drehmomente und Kräfte werden zusätzlich zu den bestehenden Grenzen für die Geschwindigkeit, die Beschleunigung und den Ruck der Antriebe beachtet. Voraussetzung dafür ist ein dynamisches Modell für die verwendete Kinematik in Form eines Funktionsbausteins, der die Schnittstelle ISMDynamics aus der Bibliothek SM3_Dynamics implementiert. Im Wesentlichen wird eine Methode AxesStateToTorque benötigt, die für einen gegebenen Zustand der Achsen, also für deren Position, Geschwindigkeit und Beschleunigung, die benötigten Drehmomente berechnet. Neben der Drehmomentbegrenzung erlaubt ein dynamisches Modell die Berechnung von Solldrehmomenten für eine Drehmomentvorsteuerung. Sie finden ein Anwendungsbeispiel im Kapitel Dynamisches Robotermodell. " }, 
{ "title" : "Anwendungsfälle ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597660278291233422349551383", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Drehmomentbegrenzung und Drehmomentvorsteuerung \/ Anwendungsfälle ", 
"snippet" : "Bei vielen, insbesondere seriellen, Kinematiken gibt es eine Verkopplung mehrerer oder aller Gelenke. Ein einfaches Beispiel dafür ist das unten abgebildete Doppelpendel mit Antrieben in den Gelenken: Anwendungsfall 1 Anwendungsfall 2 Der Antrieb im ersten Gelenk führt eine Drehung um 90° aus, das z...", 
"body" : "Bei vielen, insbesondere seriellen, Kinematiken gibt es eine Verkopplung mehrerer oder aller Gelenke. Ein einfaches Beispiel dafür ist das unten abgebildete Doppelpendel mit Antrieben in den Gelenken: Anwendungsfall 1 Anwendungsfall 2 Der Antrieb im ersten Gelenk führt eine Drehung um 90° aus, das zweite Gelenk soll sich nicht bewegen (Anwendungsfall 1). Nimmt man ein passives zweites Gelenk an, kann man sich leicht vorstellen, dass sich das zweite Glied des Doppelpendels aufgrund seiner Trägheit nach links drehen wird. Um diese Drehung zu verhindern, muss der Antrieb im zweiten Gelenk ein Drehmoment nach rechts erzeugen. Die Bewegung des ersten Antriebs erfordert also eine Reaktion des zweiten Antriebs. Eine Verkopplung in umgekehrter Richtung gibt es beispielsweise in dem Fall, dass sich der erste Antrieb mit konstanter Geschwindigkeit bewegen soll, während der zweite Antrieb das zweite Glied des Doppelpendels einklappt (Anwendungsfall 2). Dadurch reduziert sich das Massenträgheitsmoment des Doppelpendels bezüglich des ersten Gelenks. Um den Drehimpuls, das Produkt aus Massenträgheitsmoment und Drehgeschwindigkeit, zu erhalten, muss sich die Drehgeschwindigkeit des ersten Gelenks erhöhen. Um die Drehgeschwindigkeit konstant zu halten, muss der Drehimpuls durch Drehmomentänderung des ersten Antriebs entgegen seiner Drehrichtung reduziert werden. Die Bewegung des zweiten Antriebs erfordert also eine Reaktion des ersten Antriebs. Ohne ein dynamisches Modell können dem Antrieb nur Sollposition, Sollgeschwindigkeit und Sollbeschleunigung übermittelt werden. Im ersten Fall bekommt der zweite Antrieb eine konstante Sollposition vorgegeben, unabhängig davon, ob sich das erste Gelenk bewegt oder nicht. Der Regler im zweiten Antrieb muss damit umgehen können, dass für dieselben Sollwerte im einen Fall ein Drehmoment erzeugt werden muss und im anderen nicht. Ähnlich verhält es sich im zweiten Fall. Hier wird dem ersten Antrieb dieselbe konstante Sollgeschwindigkeit vorgegeben, unabhängig davon, ob sich das zweite Gelenk bewegt. Auch hier muss der Regler im Antrieb damit umgehen, dass für dieselben Sollwerte unterschiedliche Drehmomente erzeugt werden müssen. Mit einem dynamischen Modell können die Solldrehmomente berechnet und an die Antriebe übermittelt werden. Dort können sie als Vorsteuergröße für die Regler verwendet werden. Der Regler erhält so zusätzliche Informationen, die eine Verbesserung der Regelgüte ermöglichen. Die Drehmomentbegrenzung ermöglicht eine genauere Einhaltung der Grenzen des Antriebs. In vielen Fällen ist nicht die Beschränkung der Geschwindigkeit oder der Beschleunigung des Antriebs entscheidend, sondern die Beschränkung der Drehmomente. Die Vorteile der Drehmomentbegrenzung werden am Beispiel des oben beschriebenen Doppelpendels deutlich, wenn folgende Bewegungen verglichen werden: Eine Bewegung des ersten Antriebs mit eingeklapptem zweiten Glied und eine Bewegung des ersten Antriebs mit ausgeklapptem zweiten Glied. Im eingeklappten Zustand ist das Massenträgheitsmoment bezüglich des ersten Gelenks kleiner als im ausgestreckten Zustand. Für dieselbe Bewegung, also denselben Geschwindigkeits- und Beschleunigungsverlauf des Antriebs, wird im ausgestreckten Zustand deshalb ein größeres Drehmoment benötigt als im eingeklappten Zustand. Ohne dynamisches Modell müssen die Geschwindigkeits- und Beschleunigungsgrenzen so eingestellt werden, dass in beiden Zuständen die Drehmomentgrenzen eingehalten werden. Das kann dazu führen, dass sich der erste Antrieb im eingeklappten Zustand mit niedrigerer Geschwindigkeit oder Beschleunigung bewegt als nötig wäre, um die Drehmomentgrenzen des Antriebs einzuhalten. Mit einem dynamischen Modell können die Drehmomentgrenzen konfiguriert, bei der Planung der Bewegung berücksichtigt und dadurch in beiden Zuständen voll ausgenutzt werden. Ein etwas komplexeres Beispiel ist der erste oben beschriebene Fall, in dem sich der erste Antrieb bewegt und der zweite Antrieb seine Position halten soll. Das benötigte Drehmoment im zweiten Antrieb zum Halten seiner Position, hängt von der Bewegung des ersten Antriebs ab. Beschleunigt der erste Antrieb zu stark, kann es prinzipiell passieren, dass dadurch die Drehmomentgrenze des zweiten Antriebs verletzt wird. Ohne dynamisches Modell kann das nur verhindert werden, indem die Beschleunigungsgrenzen des ersten Antriebs entsprechend konfiguriert werden. Mit dynamischem Modell kann die konfigurierte Drehmomentgrenze des zweiten Antriebs bei der Planung der Bewegung berücksichtigt und die Beschleunigung des ersten Antriebs beschränkt werden. Bei komplexeren Bewegungen oder Kinematiken kommen die hier beschriebenen und noch weitere Verkopplungseffekte zusammen. Ein dynamisches Modell ermöglicht die Berücksichtigung dieser Verkopplungen und dadurch bessere Sollwertvorgaben und eine bessere Einhaltung der Grenzen der Antriebe. " }, 
{ "title" : "Konfiguration des dynamischen Modells ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4510933957710433418427140333", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Drehmomentbegrenzung und Drehmomentvorsteuerung \/ Konfiguration des dynamischen Modells ", 
"snippet" : "Ein bestehendes dynamisches Modell in Form eines Funktionsbausteins, der die Schnittstelle ISMDynamics implementiert, kann mit dem Funktionsbaustein SMC_GroupSetDynamics einer Achsgruppe zugewiesen werden. Neben dem dynamischen Modell müssen über den Baustein auch noch Richtung und Betrag der Gravit...", 
"body" : "Ein bestehendes dynamisches Modell in Form eines Funktionsbausteins, der die Schnittstelle ISMDynamics implementiert, kann mit dem Funktionsbaustein SMC_GroupSetDynamics einer Achsgruppe zugewiesen werden. Neben dem dynamischen Modell müssen über den Baustein auch noch Richtung und Betrag der Gravitationsbeschleunigung in Form eines Vektors im Maschinenkoordinatensystem konfiguriert werden. " }, 
{ "title" : "Berücksichtigung von Lasten ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552490173838433418429772624", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Drehmomentbegrenzung und Drehmomentvorsteuerung \/ Berücksichtigung von Lasten ", 
"snippet" : "Zusätzliche Lasten, beispielsweise gegriffene Objekte oder angebrachte Werkzeuge, können mithilfe des Funktionsbausteins SMC_GroupSetLoad berücksichtigt und zur Laufzeit geändert werden. Über den Eingang ExecutionMode des Bausteins lässt sich festlegen, ab wann eine Laständerung sich auswirken soll,...", 
"body" : "Zusätzliche Lasten, beispielsweise gegriffene Objekte oder angebrachte Werkzeuge, können mithilfe des Funktionsbausteins SMC_GroupSetLoad berücksichtigt und zur Laufzeit geändert werden. Über den Eingang ExecutionMode des Bausteins lässt sich festlegen, ab wann eine Laständerung sich auswirken soll, also beispielsweise sofort oder erst nach Abschluss der aktuellen Bewegung. Fortsetzen mit MC_GroupContinue : Beim Fortsetzen behält jede Bewegung, die in den Continue-Daten gespeichert ist, die Last, mit der sie ursprünglich kommandiert wurde. Jede Bewegung, die nach der Fortsetzung kommandiert wird, verwendet die zuletzt eingestellte Last. " }, 
{ "title" : "Berücksichtigung eines Getriebes ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552678559262433422353734728", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Drehmomentbegrenzung und Drehmomentvorsteuerung \/ Berücksichtigung eines Getriebes ", 
"snippet" : "Die Solldrehmomente werden für den Getriebeausgang berechnet und nicht automatisch auf den Antrieb umgerechnet. Mit dem Funktionsbaustein SMC_SetAdditionalConversionFactors lässt sich pro Achse ein zusätzlicher Umrechenfaktor für das Drehmoment konfigurieren. Darüber lässt sich auch das Getriebe ber...", 
"body" : "Die Solldrehmomente werden für den Getriebeausgang berechnet und nicht automatisch auf den Antrieb umgerechnet. Mit dem Funktionsbaustein SMC_SetAdditionalConversionFactors lässt sich pro Achse ein zusätzlicher Umrechenfaktor für das Drehmoment konfigurieren. Darüber lässt sich auch das Getriebe berücksichtigen. " }, 
{ "title" : "Einheiten ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597662777713633422354433707", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Drehmomentbegrenzung und Drehmomentvorsteuerung \/ Einheiten ", 
"snippet" : "Kräfte und Drehmomente und deren Grenzen werden in der Applikation grundsätzlich in Newton (N) oder Newtonmeter (Nm) angegeben. Bevor Sollkräfte oder Solldrehmomente an die Antriebe geschickt werden, erfolgt eventuell eine Umskalierung. So fordert die Norm CiA 402 beispielsweise, dass Solldrehmoment...", 
"body" : "Kräfte und Drehmomente und deren Grenzen werden in der Applikation grundsätzlich in Newton (N) oder Newtonmeter (Nm) angegeben. Bevor Sollkräfte oder Solldrehmomente an die Antriebe geschickt werden, erfolgt eventuell eine Umskalierung. So fordert die Norm CiA 402 beispielsweise, dass Solldrehmomente in Tausendstel des Nenndrehoments in mNm an den Antrieb gesendet werden. Die Einheit für Längen ist in SoftMotion anwenderspezifisch. Da Kräfte und Drehmoment als feste Einheit N oder Nm definiert sind, muss ein Umrechnungsfaktor von anwenderspezifischer Längeneinheit auf Meter konfiguriert werden, sofern nicht Meter als Längeneinheit verwendet wird. Das geht über den Funktionsbaustein SMC_GroupSetUnits . " }, 
{ "title" : "Drehmomentbegrenzung in beweglichen Koordinatensystemen ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552049322772833422354993274", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Drehmomentbegrenzung und Drehmomentvorsteuerung \/ Drehmomentbegrenzung in beweglichen Koordinatensystemen ", 
"snippet" : "Wenn sich die Achsgruppe in einem beweglichen Koordinatensystem bewegt, können die Drehmomentgrenzen nur eingehalten werden, wenn die Achsgruppe dem beweglichen Koordinatensystem exakt folgen kann. Ist das nicht möglich und sind mittels SMC_GroupSetPathTolerance Toleranzen für die Abweichung konfigu...", 
"body" : "Wenn sich die Achsgruppe in einem beweglichen Koordinatensystem bewegt, können die Drehmomentgrenzen nur eingehalten werden, wenn die Achsgruppe dem beweglichen Koordinatensystem exakt folgen kann. Ist das nicht möglich und sind mittels SMC_GroupSetPathTolerance Toleranzen für die Abweichung konfiguriert, können beim Versuch die Abweichung auszugleichen Drehmomentgrenzen überschritten werden. Kommt es zum Fehler, weil die Abweichungen außerhalb der Toleranzen liegen, hält die Achsgruppe an. Bei diesem Anhalten können die Drehmomentgrenzen ebenfalls überschritten werden. Die Solldrehmomente werden in jedem Fall berechnet und an die Antriebe geschickt. " }, 
{ "title" : "Drehmomentbegrenzung im Fehlerfall ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4612699285196833422355410226", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Drehmomentbegrenzung und Drehmomentvorsteuerung \/ Drehmomentbegrenzung im Fehlerfall ", 
"snippet" : "Wenn ein Fehler während der Planung erkannt wird, beispielsweise dass eine kommandierte Bewegung den Arbeitsbereich verletzen wird, hält die Achsgruppe auf der bisher kommandierten Bahn an. Dabei werden die Drehmomentgrenzen eingehalten. Wenn ein Anhalten auf der Bahn nicht möglich ist, beispielswei...", 
"body" : "Wenn ein Fehler während der Planung erkannt wird, beispielsweise dass eine kommandierte Bewegung den Arbeitsbereich verletzen wird, hält die Achsgruppe auf der bisher kommandierten Bahn an. Dabei werden die Drehmomentgrenzen eingehalten. Wenn ein Anhalten auf der Bahn nicht möglich ist, beispielsweise weil ein Antrieb einen Fehler meldet, können auch die Drehmomentgrenzen nicht eingehalten werden. " }, 
{ "title" : "Unterschiede bei der Verwendung von Einzelachsbewegungen und koordinierten Bewegungen ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4483062104566433422355806924", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Drehmomentbegrenzung und Drehmomentvorsteuerung \/ Unterschiede bei der Verwendung von Einzelachsbewegungen und koordinierten Bewegungen ", 
"snippet" : "Grundsätzlich werden für alle Achsen, die Teil einer Achsgruppe mit dynamischem Modell sind, Solldrehmomente berechnet. Das gilt sowohl im Stillstand als auch wenn die Achse mittels Einzelachsbewegungen (beispielsweise MC_MoveAbsolute ) oder die gesamte Achsgruppe mittels koordinierter Bewegungen (b...", 
"body" : "Grundsätzlich werden für alle Achsen, die Teil einer Achsgruppe mit dynamischem Modell sind, Solldrehmomente berechnet. Das gilt sowohl im Stillstand als auch wenn die Achse mittels Einzelachsbewegungen (beispielsweise MC_MoveAbsolute ) oder die gesamte Achsgruppe mittels koordinierter Bewegungen (beispielsweise MC_MoveDirectAbsolute ) verfahren wird. Die Drehmomentbegrenzung ist nur bei koordinierten Bewegungen aktiv. Der Grund dafür ist, dass die benötigten Drehmomente einer Achse, wie oben beschrieben, von Position und Bewegung einiger oder aller anderen Achsen der Achsgruppe abhängen. Eine Beschränkung der Drehmomente ist deshalb nur möglich, wenn alle Achsen der Achsgruppe koordiniert bewegt werden können. Eine Ausnahme ist der Baustein SMC_GroupJog . Dieser Baustein unterstützt keine Drehmomentbegrenzung. Es wird empfohlen, stattdessen SMC_GroupJog2 zu verwenden. " }, 
{ "title" : "Diagnose ", 
"url" : "_sm_robotics_diagnosis.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Diagnose ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Häufige Fehler ", 
"url" : "_sm_robotics_errors.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Diagnose \/ Häufige Fehler ", 
"snippet" : "Diese Seite beschreibt häufige Achsgruppenfehler, deren Ursachen und mögliche Maßnahmen, um den Fehler zu beheben. Eine Liste aller möglichen Fehler mit kurzer Beschreibung finden Sie auf der Hilfeseite SMC_ERROR (ENUM) . Fehlercode Erklärung und Ursachen Maßnahmen SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEED...", 
"body" : "Diese Seite beschreibt häufige Achsgruppenfehler, deren Ursachen und mögliche Maßnahmen, um den Fehler zu beheben. Eine Liste aller möglichen Fehler mit kurzer Beschreibung finden Sie auf der Hilfeseite SMC_ERROR (ENUM) . Fehlercode Erklärung und Ursachen Maßnahmen SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED Die Achsgruppe kann der kommandierten Bahn nicht folgen, ohne eine Achslimit (Geschwindigkeit, Beschleunigung oder Ruck) zu verletzen. Häufig tritt dieser Fehler beim Tracking auf, wenn sich das dynamische Koordinatensystem unerwartet bewegt. Der Fehler kann ebenfalls auftreten, wenn die Bahn nahe an einer singulären Stellung des Roboters vorbeiführt. Singuläre Stellungen treten zwischen verschiedenen Konfigurationen auf, etwa beim SCARA-Roboter, wenn der Arm voll ausgestreckt ist. Siehe Vermeiden der Fehler SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED oder SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDEDWenn kein dynamisches Koordinatensystem verwendet wird, dann stellen Sie sicher, dass die Bahn des Roboters nicht nahe an einer singulären Stellung vorbeiführt. SMC_CP_QUEUE_UNDERRUN Die Trajektorie (Geschwindigkeitsprofil) der Achsgruppe konnte nicht schnell genug berechnet werden, die Achsgruppe muss daher die Bewegung abbrechen. Mögliche Ursachen sind: Performance-Probleme. Die verwendete Steuerung hat keine ausreichende Performance oder es wird zu viel in einer hochprioren Task berechnet. Ungünstige Task-Einstellungen: die Berechnung der Trajektorie wird durch andere Tasks verdrängt. Rechenintensive Kommandos. Es kann zum Beispiel mehr Rechenzeit erfordern, wenn eine überschliffene Bewegung durch eine Aborting-Bewegung unterbrochen wird und diese dann erneut durch eine Aborting-Bewegung unterbrochen wird. Die Verwendung von Tracking (dynamische Koordinatensysteme) benötigt ebenfalls mehr Rechenzeit. Auch die Ausführung von SMC_GroupSaveContinueData während einer Bewegung und die Verwendung von vielen gleichzeitig aktiven Bahnschaltpunkten können die benötigte Rechenzeit erhöhen. Prüfen Sie, ob die Taskeinstellungen für die Planungstask der Achsgruppe gut gewählt sind und legen Sie diese Task, falls möglich, auf einen separaten und dedizierten CPU-Kern. Für weitere Informationen siehe: Konfiguration der PlanungstaskPrüfen Sie in der Registerkarte Monitoring der Taskkonfiguration 1 , ob eine hochpriore Task viel Rechenzeit benötigt und verlagern Sie performance-intensive Berechnungen nach Möglichkeit in eine niederpriore Task. Verwenden Sie SMC_TuneCPKernel , um das Planungsintervall zu erhöhen. Für weitere Informationen siehe: Diagnose bei langsamen oder ruckartigen BewegungenAnmerkung: Sie können die Performance-Counter von SMC_GroupReadPlanningStatistics verwenden, um festzustellen, wie sich diese Maßnahmen auswirken. Für weitere Informationen siehe: Diagnose bei langsamen oder ruckartigen BewegungenSMC_TRAFO_INVALID_CONSTELLATION SMC_AXIS_POSITION_EXCEEDS_POSLIMITS SMC_AXIS_INVERSE_TRAFO_EXCEEDING_POSLIMITS Die Bahn liegt ganz oder teilweise außerhalb des Arbeitsraums des Roboters. Mögliche Ursachen: Der Start- oder Zielpunkt einer Bewegung liegt außerhalb des Arbeitsraums Je nach Robotertyp kann bei einer CP-Bewegung ein Teil der Bewegung außerhalb des Arbeitsraums liegen. Ein Kreissegment mit einem zu großen Radius kann zu Beginn und am Ende im Arbeitsraum liegen, während der Mittelteil den Arbeitsraum verlässt. Bei Verwendung von Tracking (dynamischen Koordinatensystemen) kann es passieren, dass durch die Bewegung des Koordinatensystems eine Position, die zuvor im Arbeitsraum liegt, diesen mit der Zeit verlässt. Zu beachten: Wenn der Fehler gemeldet wird, steht die Achsgruppe nicht notwendigerweise nahe an der problematischen Position. Es kann sein, dass der Fehler während der Berechnung der Trajektorie gefunden und gemeldet wird und sich auf einen Bahnabschnitt bezieht, der noch weit von der aktuellen Position entfernt ist. Prüfen Sie die kommandierten Bewegungen und stellen Sie sicher, dass sie komplett im Arbeitsraum liegen. Bei Verwendung von Tracking: Stellen Sie durch geeignete Grenzen sicher, dass die Achsgruppe nicht mit der Zeit aus dem Arbeitsraum fährt. Bei Pick&Place mit Förderbändern ist es beispielsweise üblich, eine sichere Region zu definieren, in der Teile noch vom Band geholt werden können. Hat ein Teil diese Region verlassen, sollte die Achsgruppe das Teil nicht mehr anfahren. SMC_CP_CONFIGS_DIFFER SMC_CP_AXIS_ORIENTATION_IPO_CONFIG_DIFFERS Die Start- und Zielposition einer CP-Bewegung liegen in unterschiedlichen Konfigurationen. Der Umgang mit Konfigurationen ist im Kapitel Konfigurationen von Kinematiken erklärt. Wenn Sie den OrientationMode Axis verwenden, dann finden Sie im Kapitel Orientierungsinterpolation bei CP-Bewegungen Details zu Konfigurationen des Orientierungsteils des Roboters. Mögliche Maßnahmen: Stellen Sie sicher, dass die Start- und Zielposition von CP-Bewegungen in derselben Konfiguration liegt. Setzen Sie gegebenenfalls die Konfiguration des Roboters zu Beginn (nach MC_GroupEnable ) mit dem Baustein SMC_SetKinConfiguration . Verwenden Sie PTP-Bewegungen, um zwischen den Konfigurationen zu wechseln, falls gewünscht. " }, 
{ "title" : "Performance ", 
"url" : "_sm_robotics_performance.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Diagnose \/ Performance ", 
"snippet" : "Die Planung von Bewegungen findet in einer separaten Task statt, da die Berechnung CPU-intensiv ist. Diese separate Task wird als Planungstask bezeichnet und läuft parallel zur Bustask. Reicht die Leistung der SPS nicht aus, um die Bahn in der Planungstask rechtzeitig für die Bustask zu planen, spre...", 
"body" : "Die Planung von Bewegungen findet in einer separaten Task statt, da die Berechnung CPU-intensiv ist. Diese separate Task wird als Planungstask bezeichnet und läuft parallel zur Bustask. Reicht die Leistung der SPS nicht aus, um die Bahn in der Planungstask rechtzeitig für die Bustask zu planen, sprechen wir von Performance-Problemen. Performance-Probleme in der Bewegungsplanung können einerseits zum Fehler SMC_CP_QUEUE_UNDERRUN führen, andererseits können sie auch zu einer ruckartigen oder langsamer als erwarteten Bewegung führen. Informationen zum Fehler SMC_CP_QUEUE_UNDERRUN finden Sie im Kapitel Häufige Fehler. Die Diagnose von performancebedingten Problemen bei Bewegungen ist im Folgenden beschrieben. " }, 
{ "title" : "Diagnose bei langsamen oder ruckartigen Bewegungen ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm4597696111868834242456592379", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Diagnose \/ Performance \/ Diagnose bei langsamen oder ruckartigen Bewegungen ", 
"snippet" : "Wenn es keine Performance-Probleme gibt, wird jede Bewegung so geplant, dass während der gesamten Bewegung mindestens einer der effektiven Grenzwerte erreicht wird. Betrachten Sie zum Beispiel ein einfaches zweidimensionales Portal mit zwei Achsen X und Y und einer PTP-Bewegung von Position (0,0) na...", 
"body" : "Wenn es keine Performance-Probleme gibt, wird jede Bewegung so geplant, dass während der gesamten Bewegung mindestens einer der effektiven Grenzwerte erreicht wird. Betrachten Sie zum Beispiel ein einfaches zweidimensionales Portal mit zwei Achsen X und Y und einer PTP-Bewegung von Position (0,0) nach (10,-10). Die maximale Achsgeschwindigkeit beträgt 20, die maximale Achsbeschleunigung 100 und der maximale Achsruck 1000. Die erwartete Bewegung sieht wie folgt aus: Es wird zunächst mit maximalem Ruck die Beschleunigung aufgebaut, bis der Beschleunigungsgrenzwert von 100 erreicht ist. Nach einer kurzen Phase konstanter Beschleunigung wird wiederum mit maximalem Ruck die Beschleunigung abgebaut, sodass der Geschwindigkeitsgrenzwert von 20 mit Beschleunigung 0 erreicht wird. Nach einer Phase konstanter Geschwindigkeit wird so verzögert, dass die Zielposition mit Geschwindigkeit und Beschleunigung 0 erreicht wird. Es gibt zwei mögliche Ursachen, dass die reale Bewegung von diesem idealen Verlauf abweicht: Aufgrund von Performance-Problemen in der Planungstask entspricht schon die geplante Bewegung nicht dem idealen Verlauf. Die geplante Bewegung entspricht dem idealen Verlauf, aber der Roboter führt sie nicht wie erwartet aus. " }, 
{ "title" : "Fall 1: Performance-Probleme der Planungstask ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433006527711", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Diagnose \/ Performance \/ Diagnose bei langsamen oder ruckartigen Bewegungen \/ Fall 1: Performance-Probleme der Planungstask ", 
"snippet" : "Wenn es Performance-Probleme bei der Planung gibt, könnte die Bewegung stattdessen wie folgt aussehen: Ursache ist, dass die Bewegung in der Planungstask, parallel zur Ausführung in der Bustask, geplant wird. Dabei muss im Mittel kontinuierlich mindestens so viel geplant werden, wie in der Bustask a...", 
"body" : "Wenn es Performance-Probleme bei der Planung gibt, könnte die Bewegung stattdessen wie folgt aussehen: Ursache ist, dass die Bewegung in der Planungstask, parallel zur Ausführung in der Bustask, geplant wird. Dabei muss im Mittel kontinuierlich mindestens so viel geplant werden, wie in der Bustask ausgeführt wird. Reicht die Performance dafür nicht aus, wird abgebremst. Das führt zu dem welligen Geschwindigkeitsverlauf. Das erste und wichtigste Werkzeug zur Diagnose solcher Probleme ist der Trace. Neben den Variablen fSetPosition , fSetVelocity und fSetAcceleration für jede Achse sollten auch die Ausgänge   numTimeBudgetExceeded und numSlowDownLowIpoQueue des Funktionsbausteins SMC_GroupReadPlanningStatistics aufgezeichnet werden. Steigen diese Zähler kontinuierlich an, liegt ein Performance-Problem vor. Analog zu den Variablen fSetPosition , fSetVelocity und fSetAcceleration gibt es auch die Variable fSetJerk für den Ruck. Es ist zu beachten, dass der Ruck nicht der durchschnittliche Ruck ist, der während des Bustaskzyklus angewendet wird (wie oft erwartet), sondern der momentane Ruck am Ende des Zyklus. Für die Diagnose von Performance-Problemen hat fSetJerk deshalb nur eine begrenzte Aussagekraft. " }, 
{ "title" : "Möglichkeiten zur Verbesserung der Bewegung ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm43443300985204", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Diagnose \/ Performance \/ Diagnose bei langsamen oder ruckartigen Bewegungen \/ Fall 1: Performance-Probleme der Planungstask \/ Möglichkeiten zur Verbesserung der Bewegung ", 
"snippet" : "Die folgende Liste zeigt Möglichkeiten, um Perfomance-Probleme zu beheben: Anpassung der Grenzwerte für Geschwindigkeit, Beschleunigung und Ruck: Je länger es dauert, um von der aktuellen Geschwindigkeit in den Stillstand zu bremsen, umso höher ist der Rechenaufwand Deshalb verschlechtern ein hoher ...", 
"body" : "Die folgende Liste zeigt Möglichkeiten, um Perfomance-Probleme zu beheben: Anpassung der Grenzwerte für Geschwindigkeit, Beschleunigung und Ruck: Je länger es dauert, um von der aktuellen Geschwindigkeit in den Stillstand zu bremsen, umso höher ist der Rechenaufwand Deshalb verschlechtern ein hoher effektiver Grenzwert für die Geschwindigkeit und niedrige effektive Grenzwerte für Beschleunigung und Ruck tendenziell die Performance Insbesondere die Grenzwerte für Beschleunigung und Ruck sollten deshalb nicht unnötig niedrig gewählt werden Erhöhen der Priorität der Planungstask oder Verringern der Priorität der anderen Tasks, falls diese die Planungstask blockieren. Die Planungstask sollte nach der Bustask die zweithöchste Priorität haben. Zuweisen der Planungstask auf einen dedizierten Kern, falls mehrere CPU-Kerne vorhanden sind (siehe Konfiguration der Planungstask). Verwenden von SMC_TuneCPKernel , um den Wert der Planungsparameters fPlanningInterval und\/oder fSyncBufferDuration zu erhöhen. Der Parameter fPlanningInterval gibt die maximale zeitliche Planungsschrittweite in Sekunden an. Die Zykluszeit der Planungstask sollte diesen Wert nicht dauerhaft überschreiten. Ein höherer Wert senkt den Rechenaufwand, kann aber auch dazu führen, dass die eingestellten Grenzwerte für Geschwindigkeit, Beschleunigung und Ruck nicht voll ausgenutzt werden. Von einem Startwert von 0.016 Sekunden, dem Standardwert ab CODESYS SoftMotion -Versionen 4.6.0.0, sollte der Wert schrittweise erhöht werden, bis die Performance akzeptabel ist. Der Parameter fSyncBufferDuration gibt die Größe des Puffers zwischen Planungs- und Bustask an. Die Zykluszeit der Planungstask darf diesen Wert in der Spitze nicht überschreiten. Durch einen höheren Wert können Spitzen in der Zykluszeit der Planungstask ausgeglichen werden. Gleichzeitig erhöht sich dadurch aber auch die Latenz für Ausführen von Interrupts und Aborting-Bewegungen. " }, 
{ "title" : "Fall 2: Roboter folgt der geplanten Bewegung nicht wie erwartet ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433008452776", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Diagnose \/ Performance \/ Diagnose bei langsamen oder ruckartigen Bewegungen \/ Fall 2: Roboter folgt der geplanten Bewegung nicht wie erwartet ", 
"snippet" : "Wenn der Roboter der geplanten Bewegung nicht wie erwartet folgt, kann das folgende Gründe haben: Unzureichende Echtzeitfähigkeit der Steuerung Regelungsprobleme der Antriebe Auf einer nicht echtzeitfähigen Steuerung wie der CODESYS Control Win , oder einer Linux-basierte Steuerung ohne einen Realti...", 
"body" : "Wenn der Roboter der geplanten Bewegung nicht wie erwartet folgt, kann das folgende Gründe haben: Unzureichende Echtzeitfähigkeit der Steuerung Regelungsprobleme der Antriebe Auf einer nicht echtzeitfähigen Steuerung wie der CODESYS Control Win , oder einer Linux-basierte Steuerung ohne einen Realtime-Patch des zugrundeliegenden Linux-Systems, kann es auch bei ausreichender Performance zu langsamen oder ruckartigen Bewegungen kommen. Dies passiert wenn die Bustask nicht pünktlich im konfigurierten Zeitraster ausgeführt wird. " }, 
{ "title" : "Möglichkeiten zur Verbesserung der Bewegung ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433012326085", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Diagnose \/ Performance \/ Diagnose bei langsamen oder ruckartigen Bewegungen \/ Fall 2: Roboter folgt der geplanten Bewegung nicht wie erwartet \/ Möglichkeiten zur Verbesserung der Bewegung ", 
"snippet" : "Prüfen Sie in der Registerkarte Monitoring der Taskkonfiguration 1 , ob der Task-Jitter der Bustask zu hoch 2 ist. Dies kann entweder daran liegen, dass die Bustask durch eine Task mit gleicher oder höherer Priorität verdrängt wird, oder dass die Steuerung nicht ausreichend echtzeitfähig ist. Wenn d...", 
"body" : "Prüfen Sie in der Registerkarte Monitoring der Taskkonfiguration 1 , ob der Task-Jitter der Bustask zu hoch 2 ist. Dies kann entweder daran liegen, dass die Bustask durch eine Task mit gleicher oder höherer Priorität verdrängt wird, oder dass die Steuerung nicht ausreichend echtzeitfähig ist. Wenn der Jitter zu hoch ist und Sie bereits sichergestellt haben, dass die Bustask die höchste Priorität hat, dann reicht die Echtzeitfähigkeit der Steuerung nicht aus. Verwenden Sie in diesem Fall eine Steuerung mit besseren Echtzeiteigenschaften Bei Regelungsproblemen im Antrieb sollten Sie die Regelungsparameter anpassen. Zusätzlich kann die Drehmomentvorsteuerung die Regelung verbessern. Für weitere Informationen siehe: Drehmomentbegrenzung und Drehmomentvorsteuerung1 Es ist empfehlenswert, die Messwerte des Task-Monitorings über das Kontextmenü zurückzusetzen, da der erste SPS-Zyklus nach Start der Applikation oft eine erhöhte Dauer und einen erhöhten Jitter hat. 2 Jitter-Werte bis ca. 20 us sind sehr gut, Werte bis ca. 100 us sind gut. Je nach verwendeten Antrieben kann auch der Betrieb mit höheren Jitter-Werten funktionieren. Jitter-Werte, die bis in die Größenordnung des Taskintervalls der Bustask gehen, können zu dem beschriebenen Fehlerbild führen. " }, 
{ "title" : "Loggen von Informationen ", 
"url" : "_sm_information_logging.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Diagnose \/ Loggen von Informationen ", 
"snippet" : "Mit der SoftMotion Version 4.18.0.0 wurde der Baustein SMC_GroupEventLogging eingeführt. Mit dem Funktionsbaustein lassen sich Log-Meldungen für eine Achsgruppe aktivieren. Sobald Log-Meldungen aktiviert sind, schreibt die Achsgruppe Aktionen, die sie ausführt, ins Logbuch des Geräts. So können die ...", 
"body" : "Mit der SoftMotion Version 4.18.0.0 wurde der Baustein SMC_GroupEventLogging eingeführt. Mit dem Funktionsbaustein lassen sich Log-Meldungen für eine Achsgruppe aktivieren. Sobald Log-Meldungen aktiviert sind, schreibt die Achsgruppe Aktionen, die sie ausführt, ins Logbuch des Geräts. So können die Ereignisse der Achsgruppe chronologisch nachvollzogen werden. Dies kann nützlich sein bei der Untersuchung von Problemen und unerwartetem Verhalten der Achsgruppe. Geben Sie Ihren Bewegungen, Lasten, Tools etc. Namen, um aussagekräftige Log-Meldungen zu erhalten. Ab CODESYS SoftMotion Version 4.18.0.0 haben einige Kommando-Funktionsbausteine (wie beispielsweise MC_MoveLinearAbsolute , SMC_GroupSetTool und MC_SetCoordinateTransform ) einen neuen Eingang Name erhalten. Logging kann die Performance negativ beeinflussen und muss deshalb über den Baustein SMC_GroupEventLogging aktiviert werden. In der CODESYS SoftMotion Version 4.18.0.0 werden Meldungen geloggt, die sich auf die Bahn der Achsgruppe beziehen. Kategorie Aktion Beschreibung Weitere Informationen Bewegung Bewegung startet Die Achsgruppe hat mit der Interpolation einer Bewegung begonnen. ÜbersichtBewegung endet Die Achsgruppe hat die Interpolation einer Bewegung abgeschlossen. Blending startet Die Achsgruppe hat begonnen, von der aktiven Bewegung auf die Folgebewegung überzuschleifen. Blending endet Die Achsgruppe hat das Überschleifen abgeschlossen und setzt die Interpolation auf der Folgebewegung fort. Aborting startet Die Achsgruppe hat die aktuelle Bewegung abgebrochen und schleift zur Aborting-Bewegung über. Aborting beendet Die Achsgruppe hat das Überschleifen abgeschlossen und setzt die Interpolation auf der Aborting-Bewegung fort. Warten startet Die Achsgruppe wartet an der aktuellen Position. Warten endet Die Achsgruppe hat das Warten beendet. Halt\/Stopp startet Die Achsgruppe hat begonnen, einen Halt\/Stopp auf der Bahn auszuführen. Halt\/Stopp endet Die Achsgruppe hat den Halt\/Stopp auf der Bahn ausgeführt. Tool Tool angehängt Die Achsgruppe verwendet ein neues Tool. Werkzeugversatz konfigurierenLast Last angehängt Die Achsgruppe verwendet eine neue Last. Drehmomentbegrenzung und DrehmomentvorsteuerungOverride Achs- oder Bahnoverride geändert Der Achs- oder Bahnoverride hat sich geändert und wurde von der Achsgruppe übernommen. MC_GroupSetOverride (FB) Bahngenauigkeit Bahn verlassen Die Achsgruppe hat die kommandierte Bahn verlassen, um eine Verletzung der Achslimits zu vermeiden. Die Achsgruppe versucht, die kommandierte Bahn wieder zu erreichen. Toleranzen für die BahngenauigkeitBahn erneut erreicht Die Achsgruppe hat die kommandierte Bahn wieder erreicht. Interrupt-Continue Interrupt startet Die Achsgruppe hat begonnen, einen Interrupt auszuführen. Unterbrechen und Fortsetzen von BewegungenInterrupt endet Die Achsgruppe hat den Interrupt ausgeführt und Continue-Daten abgespeichert. Continue startet Die Achsgruppe hat Continue-Daten gelesen und beginnt diese fortzusetzen. " }, 
{ "title" : "Beispiele ", 
"url" : "_sm_robotics_examples.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Joggen eines Roboters ", 
"url" : "_sm_robotics_jogging.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Joggen eines Roboters ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt Robotics_Jogging.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie eine Achsgruppe mit dem Baustein SMC_GroupJog2 gejoggt werden kann. Es wird empfohlen, den CODESYS Depictor für dieses Beispiel zu i...", 
"body" : "Sehen Sie hierzu das Beispielprojekt Robotics_Jogging.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel zeigt, wie eine Achsgruppe mit dem Baustein SMC_GroupJog2 gejoggt werden kann. Es wird empfohlen, den CODESYS Depictor für dieses Beispiel zu installieren - die kostenlose Demoversion ist ausreichend. Alternativ können Sie die entsprechenden Code-Teile aus dem Beispiel entfernen, um das Beispiel ohne Depictor zu verwenden. " }, 
{ "title" : "Applikation ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584875037158433080105006434", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Joggen eines Roboters \/ Applikation ", 
"snippet" : "Um einen möglichst allgemeinen Fall zu demonstrieren, hat das Beispiel folgende Funktionen: Verwendung eines Roboters mit Singularitäten (6-Achs-artikulierter Roboter). Das Beispiel zeigt, dass Sie den Roboter im ACS durch Singularitäten fahren und dann in einer anderen Konfiguration kartesisch weit...", 
"body" : "Um einen möglichst allgemeinen Fall zu demonstrieren, hat das Beispiel folgende Funktionen: Verwendung eines Roboters mit Singularitäten (6-Achs-artikulierter Roboter). Das Beispiel zeigt, dass Sie den Roboter im ACS durch Singularitäten fahren und dann in einer anderen Konfiguration kartesisch weiter joggen können. Verschiebung und Verdrehung des Maschinenkoordinatensystem des Roboters (MCS) gegenüber dem Weltkoordinatensystem (WCS). So können Sie sehen, wie sich das Joggen im MCS und WCS unterscheidet. Konfiguration eines Werkzeuges, das gegenüber dem Flansch (F) verschoben und verdreht ist. In der Abbildung unten sehen Sie das Werkzeug sowie die Verschiebung und Verdrehung des TCS gegenüber dem Flansch (F). Eine lineare Zusatzachse Add0 und eine rotatorische Zusatzachse Add1 . " }, 
{ "title" : "Aufbau der Applikation ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4576391101379233081218831739", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Joggen eines Roboters \/ Aufbau der Applikation ", 
"snippet" : "Hauptprogramm Das Hauptprogramm PLC_PRG besteht aus einer Zustandsmaschine, die die Achsgruppe aktiviert (Zustand 0) das Tool konfiguriert (Zustand 5) das MCS konfiguriert (Zustand 6) das Joggen startet (Zustand 10) Im Zustand 20 werden Fehler beim Joggen behandelt sowie Bewegungsbefehle angenommen ...", 
"body" : "Hauptprogramm Das Hauptprogramm PLC_PRG besteht aus einer Zustandsmaschine, die die Achsgruppe aktiviert (Zustand 0) das Tool konfiguriert (Zustand 5) das MCS konfiguriert (Zustand 6) das Joggen startet (Zustand 10) Im Zustand 20 werden Fehler beim Joggen behandelt sowie Bewegungsbefehle angenommen (Schalter Move to Position in der Visualisierung) Die weiteren Zustände dienen der Durchführung der Bewegung (60, 70) sowie der Behandlung und Quittierung von Fehlern (900, 1000) Nach der Zustandsmaschine werden alle Robotikbausteine und das Programm GroupJog2 zyklisch aufgerufen sowie einige Berechnungen für die 3D-Darstellung im Depictor durchgeführt Programm GroupJog2 Dieses Programm enthält eine Zustandsmaschine mit diesen Schritten: In Zustand 10 werden die Eingänge von SMC_GroupJog2 gesetzt und es wird ausgelesen in welcher Konfiguration die Achsen des Roboters stehen (SMC_GroupReadActualPosition). Diese Konfiguration wird in Zustand 20 in der Achsgruppe konfiguriert (SMC_SetKinConfiguration). In Zustand 30 wird auf Fehler beim Joggen reagiert sowie auf Änderungen der Einstellungen des Joggens, zum Beispiel auf ein geändertes Koordinatensystem. Bei Änderung wird zurück in Zustand 10 gewechselt. Zustand 50 wird bei einer fallenden Flanke des Enable Eingangs betreten. Das Joggen wird mit MC_GroupHalt beendet. " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584880854092833081221538291", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Joggen eines Roboters \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie das erstellte Programm und starten Sie es. Über die Visualisierung können Sie den Roboter verfahren. Sie können alle relevanten Einstellungen für das Joggen definieren: Beispielsweise in welchem Koordinatensystem gejoggt wird und mit welcher Geschwindigkeit. Wenn Sie den CODESYS Depic...", 
"body" : "Übersetzen Sie das erstellte Programm und starten Sie es. Über die Visualisierung können Sie den Roboter verfahren. Sie können alle relevanten Einstellungen für das Joggen definieren: Beispielsweise in welchem Koordinatensystem gejoggt wird und mit welcher Geschwindigkeit. Wenn Sie den CODESYS Depictor installiert haben, ist es empfehlenswert, das Fenster mit dem Depictor (POU Scene ) neben dem Visualisierungsfenster anzuordnen. Der Depictor stellt das TCS (Tool-Koordinatensystem) vorne am Roboter dar. Außerdem wird die aktuelle Drehachse des TCS in violett dargestellt. Das ist hilfreich, um die verschiedenen Arten der Orientierungsänderung zu prüfen (testen Sie beispielsweise die Option ABC_as_ACS und das Koordinatensystem TCS ). " }, 
{ "title" : "Unterbrechen und Fortsetzen von Bewegungen ", 
"url" : "_sm_robotics_example_stop_continue.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Unterbrechen und Fortsetzen von Bewegungen ", 
"snippet" : "Das beschriebene Beispielprojekt Robotics_Interrupt_Continue.project ist im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples zu finden. Dieses Beispiel zeigt, wie kommandierte Bewegungen mit dem Funktionsbaustein SMC_GroupInterrupt unterbrochen und zu einem späteren Zeitpun...", 
"body" : "Das beschriebene Beispielprojekt Robotics_Interrupt_Continue.project ist im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples zu finden. Dieses Beispiel zeigt, wie kommandierte Bewegungen mit dem Funktionsbaustein SMC_GroupInterrupt unterbrochen und zu einem späteren Zeitpunkt mit dem Funktionsbaustein SMC_GroupContinue fortgesetzt werden können. Zwischen Unterbrechen und Fortsetzen kann die Achsgruppe beliebige Bewegungen ausführen. " }, 
{ "title" : "Aufbau der Applikation ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4519127872464034232302809299", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Unterbrechen und Fortsetzen von Bewegungen \/ Aufbau der Applikation ", 
"snippet" : "Die Applikation besteht aus einer einfachen Zustandsmaschine im Programm PLC_PRG und einem Trace, mit dem die Zustandsübergänge nachvollzogen werden können. Zuerst werden die Achsen und die Achsgruppe eingeschaltet. ( STATE_POWER_ON ) Danach werden zwei Bewegungen, moveLinearA und moveLinearB , mit ...", 
"body" : "Die Applikation besteht aus einer einfachen Zustandsmaschine im Programm PLC_PRG und einem Trace, mit dem die Zustandsübergänge nachvollzogen werden können. Zuerst werden die Achsen und die Achsgruppe eingeschaltet. ( STATE_POWER_ON ) Danach werden zwei Bewegungen, moveLinearA und moveLinearB , mit Überschleifen kommandiert. ( STATE_START_MOVIN G) Sobald die zweite Bewegung aktiv wird, also wenn das Überschleifen beginnt, wird die Bewegung unterbrochen. Ursache könnte zum Beispiel sein, dass ein Defekt an einem Werkzeug festgestellt wurde. ( STATE_INTERRUPT ) Es wird eine relative PTP-Bewegung in positiver Z-Richtung ausgeführt, zum Beispiel um nach dem Defekt das Werkzeug auszutauschen. ( STATE_INTERMEDIATE_MOVEMENT ) Vor dem Fortsetzen wird wieder zurück auf die Position gefahren, an der die ursprüngliche Bewegung unterbrochen wurde. ( STATE_GET_CONTINUE_POS \/ STATE_MOVE_TO_CONTINUE_POS ) Die ursprüngliche Bewegung wird fortgesetzt. ( STATE_CONTINUE) " }, 
{ "title" : "Verwendung ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4586020725065634232302901331", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Unterbrechen und Fortsetzen von Bewegungen \/ Verwendung ", 
"snippet" : "Übersetzen Sie das erstellte Programm und loggen Sie sich ein. Um die verschiedenen Stati nachzuvollziehen, können Sie den Trace auf die Steuerung laden. Starten Sie die Applikation....", 
"body" : "Übersetzen Sie das erstellte Programm und loggen Sie sich ein. Um die verschiedenen Stati nachzuvollziehen, können Sie den Trace auf die Steuerung laden. Starten Sie die Applikation. " }, 
{ "title" : "Roboter mit Pick&Place programmieren ", 
"url" : "_sm_example_robotics.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Roboter mit Pick&Place programmieren ", 
"snippet" : "Sehen Sie hierzu die Beispielprojekte Robotics_PickAndPlace.project und Robotics_PickAndPlace_without_Depictor.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Projekt Robotics_PickAndPlace.project setzt die Installation des Packages CODESYS Depictor voraus....", 
"body" : "Sehen Sie hierzu die Beispielprojekte Robotics_PickAndPlace.project und Robotics_PickAndPlace_without_Depictor.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Das Projekt Robotics_PickAndPlace.project setzt die Installation des Packages CODESYS Depictor voraus. Dieses Projekt visualisiert die Kinematik in einer 3D-Animation. Das Projekt Robotics_PickAndPlace_without_Depictor.project zeigt den Ablauf auf einem Visualisierungsbild in vereinfachter Form. In diesem Kapitel werden nur die Objekte behandelt, die für SoftMotion relevant sind. Das Beispiel besteht aus einem Tripod, einem Drehtisch und einem Förderband. Die Kinematik greift einen Ring auf, der auf dem Drehtisch platziert ist. Während des Greifens bewegt sich der Greifer der Kinematik synchron mit dem Rundtisch. Danach wird der Ring auf einen Kegel aufgesetzt, der auf einem Förderband sitzt. Während des Ablegens bewegt sich die Kinematik synchron zum Förderband. Auf dem Visualisierungsbild finden Sie zwei Schaltflächen, mit denen Sie den Ablauf steuern. Wenn Sie die Schaltfläche Auto gedrückt haben, werden die Ringe automatisch aufgelegt. Andernfalls erscheint eine Schaltfläche Play , mit der Sie jeweils einen Ring auflegen können. Funktionsbausteine MC_TrackConveyorBelt und MC_TrackRotaryTable Der Funktionsbaustein MC_TrackRotaryTable , der in dem Funktionsbaustein Ring aufgerufen wird, dient der Bestimmung des Teilekoordinatensystems PCS_1 . Dieses Koordinatensystem wird gesetzt, sowie ein Ring auf dem Drehtisch abgelegt wird. Der Ursprung des Drehtisch-Koordinatensystem RotaryTableOrigin liegt im Mittelpunkt des Drehtisches, die Z-Achse liegt auf der Drehachse der Drehtisches. Das PCS_1 wird um die Z-Achse des Drehtisch-Koordinatensystems gedreht, abhängig von der Eingangsvariable RotaryTable . Da sich die Achsgruppe im PCS_1 bewegt, folgt sie der Drehbewegung des Tisches. Beim Funktionsbaustein MC_TrackConveyorBelt , der im Funktionsbaustein Cone aufgerufen wird, ist das Verhalten analog. Das PCS ( PCS_2 ) folgt dabei der X-Achse des Koordinatensystems ConveyorBeltOrigin . " }, 
{ "title" : "Aufbau des Projekts ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_9645ebb75a1273b0c0a8640e01c9af58", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Roboter mit Pick&Place programmieren \/ Aufbau des Projekts ", 
"snippet" : "Steuerung CODESYS SoftMotion Achsgruppe Tripod : Die Achsgruppe definiert die Kinematik und die Zuordnung zu den einzelnen Achsen Tripod1 , Tripod2 und Tripod3 . DepictorCalculations (PRG) , Environment (PRG) , Ring (FB) : Programme zur Steuerung des Gesamtablaufs und der Visualisierung. Diese POUs ...", 
"body" : "Steuerung CODESYS SoftMotion Achsgruppe Tripod : Die Achsgruppe definiert die Kinematik und die Zuordnung zu den einzelnen Achsen Tripod1 , Tripod2 und Tripod3 . DepictorCalculations (PRG) , Environment (PRG) , Ring (FB) : Programme zur Steuerung des Gesamtablaufs und der Visualisierung. Diese POUs sind für das Verständnis der PLCopen-Bausteine nicht relevant, bis auf die Definition des Produktkoordinatensystems (PCS_1 und PCS_2). Robot (PRG) : Programm zur Steuerung der Bewegungsabläufe. Eine detaillierte Beschreibung finden Sie im nachfolgendem Absatz. Visualization : Animierte Visualisierung zur Verdeutlichung des Ablaufs. Tripod1 , Tripod2 , Tripode3 : Lineare Achsen des Tripod. DriveRotaryTable : Achse für den Rundtisch. DriveConveyorBelt : Achse für das Förderband. " }, 
{ "title" : "Aufbau des Ablaufprogramms Robot (PRG) ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_d2b72ec95a1273b5c0a8640e012cc527", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Roboter mit Pick&Place programmieren \/ Aufbau des Ablaufprogramms Robot (PRG) ", 
"snippet" : "Das Programm Robot (PRG) wird zyklisch durchlaufen. Dabei werden abhängig vom Status state die einzelnen Schritte durchlaufen. Am Ende des Programms stehen die Aufrufe aller genutzter Funktionsbausteine zur Bewegungskommandierung. Die Einzelachsen des Tripods werden aktiv geschaltet (Funktionsbauste...", 
"body" : "Das Programm Robot (PRG) wird zyklisch durchlaufen. Dabei werden abhängig vom Status state die einzelnen Schritte durchlaufen. Am Ende des Programms stehen die Aufrufe aller genutzter Funktionsbausteine zur Bewegungskommandierung. Die Einzelachsen des Tripods werden aktiv geschaltet (Funktionsbausteine pwA1 , pwA2 und pwA3 vom Typ MC_Power ). CASE 0 : Warten auf die Betriebsbereitschaft der beteiligten Achsen. CASE 10 : Setzen von Referenzpositionen; in realen Applikationen würde an dieser Stelle Homing durchgeführt (Funktionsbausteine spA1 , spA2 und spA3 vom Typ MC_SetPosition ). CASE 20 : Platzierung des Maschinenkoordinatensystems im Weltkoordinatensystem (Funktionsbaustein setCoord vom Typ MC_SetCoordinateTransform ). CASE 30 : Freigeben der Achsgruppe (Funktionsbaustein enable vom Typ MC_GroupEnable . Warten auf Rückmeldung, dass die Achsgruppe alle Werte übernommen hat. CASE 40 bis CASE 130 : Pick & Place-Applikation: Alle Bewegungen werden mit zum Teil mehreren Instanzen von MC_MoveDirectAbsolute , MC_MoveDirectRelative und MC_MoveLinear kommandiert, die zyklisch aufgerufen werden. Eine steigende Flanke am Eingang Execute dieser Bausteine im jeweiligen Status führt zum Absetzen des neuen Bewegungsbefehls, wobei der Ausgang bCommandAccepted den Erfolg dieses Vorgangs anzeigt. Durch Abfrage dieses Ausgangs vor dem jeweils nächsten Bewegungsbefehl ergibt sich eine typische Kette von Kommandierungen. " }, 
{ "title" : "Dynamisches Robotermodell ", 
"url" : "_sm_dynamic_robot_model.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Dynamisches Robotermodell ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt Robotics_DynamicModel.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Um die Achsmomente\/-kräfte während einer Bewegung zu begrenzen, ist ein dynamisches Modell erforderlich, das diese Werte aus dem aktuellen Achszustand (Po...", 
"body" : "Sehen Sie hierzu das Beispielprojekt Robotics_DynamicModel.project im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Um die Achsmomente\/-kräfte während einer Bewegung zu begrenzen, ist ein dynamisches Modell erforderlich, das diese Werte aus dem aktuellen Achszustand (Position, Geschwindigkeit und Beschleunigung) berechnet. Dieses Beispiel umfasst die folgenden Teile: Teil 1 zeigt, wie ein bestehendes dynamisches Modell in einer Anwendung verwendet wird und die Ergebnisse einiger Beispielbewegungen Teil 2 zeigt, wie ein dynamisches Modell für einen SCARA-Roboter auf der Grundlage eines Algorithmus erstellt wird, der in dem Buch \"Modern Robotics\" von K. M. Lynch und F. C. Park vorgestellt wird " }, 
{ "title" : "Struktur der Applikation ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4640407923376033369958289569", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Dynamisches Robotermodell \/ Struktur der Applikation ", 
"snippet" : "Teil 1: Verwendung eines dynamischen Modells in einer Anwendung Der Code für diesen Teil befindet sich im Ordner TorqueLimitationDemo PLC_PRG ist das Hauptprogramm, das eine Zustandsmaschine enthält, die Testbewegungen auslöst Die Bewegungen können mit dem Trace überwacht werden Teil 2: Erstellen ei...", 
"body" : "Teil 1: Verwendung eines dynamischen Modells in einer Anwendung Der Code für diesen Teil befindet sich im Ordner TorqueLimitationDemo PLC_PRG ist das Hauptprogramm, das eine Zustandsmaschine enthält, die Testbewegungen auslöst Die Bewegungen können mit dem Trace überwacht werden Teil 2: Erstellen eines dynamischen Robotermodells Der Code für das dynamische Modell befindet sich im Ordner DynModel DynModel_Scara2_Z ist das dynamische Modell des SCARA-Roboters DynModel_Tests führt alle Tests von Test_DynModel_Scara2_Z aus, um auf häufige Fehler zu prüfen Das dynamische Modell basiert auf einem SCARA-Roboter mit zwei rotatorischen Achsen und einer linearen Z-Achse. Eine Abbildung des Roboters mit den erforderlichen Abmessungen und Koordinatensystemen für das dynamische Modell ist unten dargestellt: Abmessung in der Abbildung Entsprechender Variablenname im Beispielprojekt im Funktionsbaustein DynModel_Scara2_Z h0 baseHeight h1 armOneHeight h2 armTwoHeight h3 zAxisLength h4 zAxisOffset l1 armOneLength l1 armTwoLength " }, 
{ "title" : "Teil 1: Verwendung eines dynamischen Modells in einer Anwendung ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4592064830952033369979173999", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Dynamisches Robotermodell \/ Teil 1: Verwendung eines dynamischen Modells in einer Anwendung ", 
"snippet" : "Die Verwendung eines dynamischen Modells in einer Anwendung erfordert ein Modell, das die Schnittstelle ISMDynamics der Bibliothek SM3_Dynamics implementiert. Das dynamische Modell aus Teil 2: Erstellen eines dynamischen Robotermodells wird für diese Demonstration verwendet. Das Modell kann mit SMC_...", 
"body" : "Die Verwendung eines dynamischen Modells in einer Anwendung erfordert ein Modell, das die Schnittstelle ISMDynamics der Bibliothek SM3_Dynamics implementiert. Das dynamische Modell aus Teil 2: Erstellen eines dynamischen Robotermodells wird für diese Demonstration verwendet. Das Modell kann mit SMC_GroupSetDynamics einer Achsengruppe zugewiesen werden. In diesem Schritt muss die Erdbeschleunigung in Bezug auf das MCS angegeben werden. Da der SCARA in diesem Beispiel am Boden montiert ist, zeigt die Erdbeschleunigung in die positive z0-Richtung. Die Erdbeschleunigung muss in Benutzereinheiten u\/s² angegeben werden. Da alle Längen in diesem Beispiel in der Benutzereinheit m definiert wurden, muss auch die Erdbeschleunigung in m\/s² angegeben werden. SMC_ChangeDynamicLimits kann verwendet werden, um die Grenzen jeder Achse anzupassen. Bitte beachten Sie, dass die Achsgruppe mit MC_GroupEnable wieder aktiviert werden muss, um die neuen dynamischen Grenzen zu aktivieren. Wenn dem TCP zusätzliche Massen hinzugefügt werden (beispielsweise ein Werkzeug oder ein Objekt, das vom Roboter aufgenommen wurde), kann SMC_GroupSetLoad verwendet werden, um die Last zu definieren. Das Programm PLC_PRG enthält alle oben genannten Komponenten und führt zwei Testbewegungen aus: Bewegung 1 Bewegung 2 Gerade Armbewegung von (a0=0°, a1=0°, a2=0 m) nach (a0=90°, a1=0°, a2=0,02 m): Abgewinkelte Armbewegung von (a0=0°, a1=-120°, a2=0 m) nach (a0=90°, a1=-120°, a2=0,02 m): Jede Bewegung wird dreimal hintereinander mit den folgenden Randbedingungen ausgeführt: Die Drehmomentgrenze aller Achsen ist unendlich (unbegrenzt). Die Drehmomentgrenze von Arm 2 ist auf einen niedrigeren Wert als das maximal erreichte Drehmoment bei unbegrenzter Bewegung eingestellt. Der Wert wurde willkürlich auf 2 Nm festgelegt. Die Drehmomentgrenze von Arm 2 beträgt immer noch 2 Nm , und zusätzlich wurde eine Last am TCP angebracht ( mLoad=3 kg , lLoad=0,2 m ): Das Massenträgheitsmoment der Last wurde vereinfacht für dünne Stäbe berechnet: Die Bewegungen können im Trace verfolgt werden. Bewegung 1 hat die folgenden Ergebnisse: Auch wenn sich Arm 2 während der Bewegung 1 nicht bewegt, führt die Beschleunnigung\/Verzögerung von Arm 1 zu einem Drehmoment in Arm 2. Das berechnete Drehmoment wird an den Antrieb gesendet und kann den Regelkreis im Reglermodus SMC_velocity oder SMC_position verbessern. Dies wird auch als Drehmoment-Vorsteuerung bezeichnet. Der zweite Durchlauf mit begrenztem Drehmoment zeigt, dass die Drehmomentbegrenzung von Arm 2 zu einer langsameren Bewegung von Arm 1 führt. Und das auch, wenn sich Arm 2 nicht bewegt. Ohne das dynamische Modell müsste die Beschleunigung und Abbremsung von Arm 1 für diese Bewegung manuell reduzieren werden, um eine übermäßige mechanische Belastung von Arm 2 zu vermeiden. Beim dritten Durchlauf mit einer Last, wird die Bewegung von Arm 1 noch langsamer, um die Drehmomentgrenze von Arm 2 nicht zu verletzen. Die Vorteile der Verwendung eines dynamischen Modells liegen auf der Hand. Um übermäßige mechanische Belastung ohne dynamisches Modell zu verhindern, müssten entweder die dynamischen Grenzen für jede Bewegung in Abhängigkeit vom aktuellen Zustand des Roboters festgelegt werden. müssten die dynamischen Grenzen aller Achsen so verringert werden, dass alle möglichen Bewegungen nicht zu einer übermäßigen mechanischen Belastung einer Achse führen. Die erste Methode ist eine komplexe Aufgabe und es kann schwierig sein, vernünftige Grenzwerte zu berechnen, während die zweite Methode zu Bewegungen führt, die meistens nicht so schnell wie möglich sind. Diese Nachteile sind bei einem dynamischen Modell nicht mehr vorhanden, da sich der Roboter immer so schnell wie möglich bewegt und dabei die mechanischen Grenzen jeder Achse beachtet. Diese Vorteile verdeutlichen die Ergebnisse von Bewegung 2: Aufgrund des abgewinkelten Arms 2 ist das resultierende Drehmoment des Arms 2 wesentlich geringer als bei Bewegung 1. Daher werden alle drei Fahrten nie durch das Achsendrehmoment begrenzt. Hätte man auf der Grundlage von Bewegung 1 angepasste dynamische Grenzwerte verwendet (reduzierte Beschleunigung und Abbremsung, um die Drehmomentgrenze von Arm 2 nicht zu verletzen), wäre diese Bewegung langsamer als nötig gewesen. " }, 
{ "title" : "Teil 2: Erstellen eines dynamischen Robotermodells ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4583105024958433369980945572", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Dynamisches Robotermodell \/ Teil 2: Erstellen eines dynamischen Robotermodells ", 
"snippet" : "Das Modell, das in diesem Beispiel erstellt wird, basiert auf einem Algorithmus für Roboter mit offenen Ketten, der in dem Buch \"Modern Robotics\" von K. M. Lynch und F. C. Park vorgestellt wird (siehe Kapitel 8 \"Dynamics of Open Chains\"). Die Erläuterung dieses Algorithmus würde den Rahmen dieses Be...", 
"body" : "Das Modell, das in diesem Beispiel erstellt wird, basiert auf einem Algorithmus für Roboter mit offenen Ketten, der in dem Buch \"Modern Robotics\" von K. M. Lynch und F. C. Park vorgestellt wird (siehe Kapitel 8 \"Dynamics of Open Chains\"). Die Erläuterung dieses Algorithmus würde den Rahmen dieses Beispiels sprengen. Stattdessen konzentriert sich das Beispiel darauf, wie die Eingangswerte des Algorithmus definiert werden. Vereinfachungen Um dieses Beispiel verständlicher zu machen, wurden einige Vereinfachungen vorgenommen: Die Armlängen l1 und l2 (Abstand zwischen den Drehachsen) werden als ihre jeweilige Gesamtarmlänge verwendet. Der Massenschwerpunkt liegt immer in der geometrischen Mitte eines jeden Glieds. Die räumlichen Massenträgheitsmomente der Arme und der z-Achse werden für dünne Stäbe berechnet. Anforderungen an das dynamische Modell Um das dynamische Modell in einer SoftMotion-Anwendung verwenden zu können, muss dieses Modelldie Schnittstelle ISMDynamics der Bibliothek SM3_Dynamics implementieren. Die Nullposition, die Koordinatensysteme und die positive Drehrichtung des dynamischen Modells können theoretisch vom kinematischen Modell abweichen. Diese Unterschiede müssen jedoch berücksichtigt werden, und zur Vereinfachung des dynamischen Modells wird daher empfohlen, die Definitionen des kinematischen Modells zu verwenden. Da das dynamische Modell Drehmomentwerte in Nm und Kräfte in N berechnen muss, muss es die Benutzereinheit u für Längen in die SI-Einheit m umrechnen. Der Umrechnungsfaktor kann mit SMC_GroupSetUnits eingestellt werden und ist im Eingang addParams von ISMDynamics.AxesStateToTorque enthalten. Dieses Beispiel verwendet nur m für Längen und kann daher den Umrechnungsfaktor ignorieren. Spezifizierung der geometrischen und dynamischen Daten des Modells Die IEC-Implementierung des im Buch \"Modern Robotics\" von K. M. Lynch und F. C. Park vorgestellten Algorithmus (siehe Kapitel 8 \"Dynamics of Open Chains\") benötigt die folgenden Eingabewerte: Die Position des Massenschwerpunkts jedes Glieds, wenn sich der Roboter in der Ausgangsposition befindet. Die Position wird im Koordinatensystem des vorherigen Glieds angegeben (das erste Glied wird relativ zum Basiskoordinatensystem angegeben). Die räumliche Massenträgheitsmatrix und die Masse jedes Glieds, angegeben im Frame des jeweiligen Glieds Die Schraubenachse jeder Verbindung, angegeben im Basis-Frame Positionen des Massenschwerpunkts Die Frames mit der Position des Massenschwerpunkts jedes Glieds sind: Glied Frame Arm 1 Der Massenschwerpunkt von Arm 1, ausgedrückt im Basiskoordinatensystem x 0 , y 0 , z 0 : Bitte beachten Sie, dass es eine Drehung um 180° um die x0-Achse gibt. Arm 2 Der Massenschwerpunkt von Arm 2, ausgedrückt im Koordinatensystem von Arm 1: Z-Achse Der Massenschwerpunkt der Z-Achse, ausgedrückt im Koordinatensystem von Arm 2: Werkzeugmittelpunkt (TCP) Ein zusätzlicher Frame zur Behandlung einer beliebigen Belastung am TCP (beispielsweise durch ein Werkzeug, ein Objekt oder eine Kombination aus beidem), ausgedrückt im Koordinatensystem der Z-Achse: Räumliche Massenträgheitsmomente Die Trägheitsmomente müssen in dem Frame des jeweiligen Glieds angegeben werden. Da der Frame im Massenschwerpunkt liegt, kann das räumliche Massenträgheitsmoment mithilfe einer 3x3-Matrix und der Masse dargestellt werden. Durch die Vereinfachung, dünne Stäbe zu verwenden, berechnen sich die Komponenten der Matrix folgendermaßen: Glied Komponenten der Trägheitsmatrix Arm 1, Arm 2 Arm 1 und 2 mit ihrer jeweiligen Masse m1 , m2 und Länge l1 , l2 : Z-Achse Schraubenachsen Die Schraubenachsen aller Gelenke müssen in Bezug auf das Basiskoordinatensystem x 0 , y 0 , z 0 angegeben werden. Glied Schraubenachse Arm 1 Stellen Sie sich einen Drehtisch vor, der sich um das Gelenk 1 in positiver Richtung mit einer Winkelgeschwindigkeit von 1 rad\/s dreht. Im Basiskoordinatensystem ausgedrückt, handelt es sich nach der Rechten-Hand-Regel um eine positive Drehung um die z 0 -Achse: Da die Drehachse von Arm 1 mit dem Mittelpunkt des Basiskoordinatensystems übereinstimmt, ist die lineare Geschwindigkeit gleich Null: Arm 2 Stellen Sie sich wiederum einen Drehtisch vor, der sich um das Gelenk 2 in positiver Richtung mit einer Winkelgeschwindigkeit von 1 rad\/s dreht. Dieser Fall ist nachfolgend als Draufsicht von Arm 1 dargestellt: Wie für Arm 1, beträgt die Winkelgeschwindigkeit: Die Abbildung zeigt die resultierende lineare Geschwindigkeit v 2,y , die in negative y 0 -Richtung zeigt und gleich v 2,y =-ω 2,z * l 1 ist. Z-Achse Die Z-Achse ist eine lineare Achse, für die die folgenden Regeln gelten: Der Winkelgeschwindigkeitsvektor ω ist Null. Der lineare Geschwindigkeitsvektor ist ein Einheitsvektor in Richtung der positiven Translation. Daraus ergeben sich die folgenden Vektoren, ausgedrückt im Basiskoordinatensystem x 0 , y 0 , z 0 : Tests Das dynamische Modell kann nun getestet werden, da alle Modellparameter definiert sind. Dieser Abschnitt enthält einige grundlegende Tests des Modells. Kontrolle der Schraubenachsen Eine Schraubenachse S mit der Winkelgeschwindigkeit ω und der linearen Geschwindigkeit v kann als ein Element von se(3) ausgedrückt werden: Eine Vorwärtstransformation T kann mit den Schraubenachsen S , einem Endeffektor-Frame M für die Nullposition des Roboters und dem Gelenkwinkel θ jedes Gelenks ausgeführt werden: Das Beispielprojekt enthält bereits eine Funktion, die diese Gleichung löst (siehe SMC_OpenChainKinematics_SolveForward ). Für weitere Details siehe das Buch \"Modern Robotics\" von K. M. Lynch und F. C. Park. Wenn die Vorwärtstransformation mit bekannten Achswerten ausführt wird, kann überprüft werden, ob die Transformation zum erwarteten Ergebnis führt. Überprüfung der Drehmomente im Stillstand Um die grundsätzliche Berechnung des Drehmoments zu überprüfen, können manuell Drehmomente für bestimmte Achspositionen im Stillstand berechnet und diese mit dem Modell verglichen werden. Da der SCARA-Roboter in diesem Beispiel auf dem Boden montiert ist, führen alle Achsenpositionen im Stillstand zu den gleichen Drehmomenten oder Kräften der Antriebe: Gelenk Resultierendes Drehmoment\/Kraft Arm 1 Da es sich bei Arm 1 um eine Drehachse handelt, ist das Ergebnis ein Drehmoment: M1=0 Nm . Arm 2 Da es sich bei Arm 2 um eine Drehachse handelt, ist das Ergebnis ein Drehmoment: M2=0 Nm . Z-Achse Da die Z-Achse eine prismatische Achse ist, ergibt sich daraus eine Kraft: F3=m3*g N mit der Gravitationsbeschleunigung g . " }, 
{ "title" : "Kundenspezifische Kinematiken ", 
"url" : "_sm_example_custom_robotics_kinematic.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Kundenspezifische Kinematiken ", 
"snippet" : "Sehen Sie hierzu das Beispielprojekt CustomKinematics_Implementation.project und die Bibliothek CustomKinematics.library im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel beschreibt, wie Sie eine Bibliothek mit einer benutzerdefinierten kinematischen Tran...", 
"body" : "Sehen Sie hierzu das Beispielprojekt CustomKinematics_Implementation.project und die Bibliothek CustomKinematics.library im Installationsverzeichnis von CODESYS unter ..\\CODESYS SoftMotion\\Examples . Dieses Beispiel beschreibt, wie Sie eine Bibliothek mit einer benutzerdefinierten kinematischen Transformation ( Gantry3C ) erstellen und wie Sie diese Bibliothek in einem Projekt zur Steuerung des Roboters verwenden. Die kinematische Transformation Gantry3C besteht aus 3 Linearachsen (X, Y und Z), die einen Werkzeugkopf bewegen. Der Werkzeugkopf besteht aus einer zusätzlichen Achse und einem darauf montierten Werkzeug. Der Werkzeugkopf kann um die Z-Achse gedreht werden. " }, 
{ "title" : "1. Erstellen eines neuen Bibliotheksprojekts ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3b0657d06b6990f1c0a8646379b25f1e", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Kundenspezifische Kinematiken \/ 1. Erstellen eines neuen Bibliotheksprojekts ", 
"snippet" : "Erstellen Sie ein neues Projekt mit der Bibliotheksvorlage Leere Bibliothek ....", 
"body" : "Erstellen Sie ein neues Projekt mit der Bibliotheksvorlage Leere Bibliothek . " }, 
{ "title" : "2. Hinzufügen eines Bibliothekverwalters ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_0125d98b6b6990f1c0a8646339c29917", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Kundenspezifische Kinematiken \/ 2. Hinzufügen eines Bibliothekverwalters ", 
"snippet" : "Fügen Sie einen Bibliotheksverwalter zur Ansicht POU hinzu. Fügen Sie dem Bibliotheksverwalter die Bibliotheken SM3_Transformation , SM3_Math und SM3_Error hinzu....", 
"body" : "Fügen Sie einen Bibliotheksverwalter zur Ansicht POU hinzu. Fügen Sie dem Bibliotheksverwalter die Bibliotheken SM3_Transformation , SM3_Math und SM3_Error hinzu. " }, 
{ "title" : "3. Erstellen des Funktionsbausteins Gantry3C ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_b156dbec6b6990f1c0a86463322b661a", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Kundenspezifische Kinematiken \/ 3. Erstellen des Funktionsbausteins Gantry3C ", 
"snippet" : "Dieser Funktionsbaustein implementiert die Schnittstellen MC_KIN_REF_SM3 und ISMKinematicsWithInfo2 aus der Bibliothek SM3_Transformation . Sie können für jede Achse einen Offset als Eingabe definieren. Dieser Offset wird vor der Vorwärtstransformation subtrahiert und nach der inversen Transformatio...", 
"body" : "Dieser Funktionsbaustein implementiert die Schnittstellen MC_KIN_REF_SM3 und ISMKinematicsWithInfo2 aus der Bibliothek SM3_Transformation . Sie können für jede Achse einen Offset als Eingabe definieren. Dieser Offset wird vor der Vorwärtstransformation subtrahiert und nach der inversen Transformation addiert. Beispiel für Gantry3C mit zwei entkoppelten Kinematiken und KinCoupled : FUNCTION_BLOCK Custom_Kin_Gantry3 IMPLEMENTS ISMPositionKinematics\nFUNCTION_BLOCK Custom_Kin_CAxis IMPLEMENTS ISMOrientationKinematics\n\nFUNCTION_BLOCK Custom_Kin_Gantry3C EXTENDS Kin_Coupled Stellen Sie Custom_Kin_Gantry3 und Custom_Kin_CAxis als Eingänge für den Funktionsbaustein Kin_Coupled während der Initialisierung zur Verfügung. Jetzt wird Custom_Kin_Gantry3C zu einer gekoppelten Kinematik, die die Positionier- und Orientierungskinematik kombiniert. " }, 
{ "title" : "4. Implementieren der Methoden der Schnittstelle MC_KIN_REF_SM3 und der Eigenschaft NumAxes4 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_f0953a666b6990f1c0a864632a54ddd5", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Kundenspezifische Kinematiken \/ 4. Implementieren der Methoden der Schnittstelle MC_KIN_REF_SM3 und der Eigenschaft NumAxes4 ", 
"snippet" : "AxesToCartesian : Vorwärtskinematik: Berechnung der Position und Orientierung aus den Achswerten. CartesianToAxes : Inverse Kinematik: Berechnung der Achswerte aus Position und Orientierung. NumAxes : Anzahl der Achsen der Kinematik...", 
"body" : "AxesToCartesian : Vorwärtskinematik: Berechnung der Position und Orientierung aus den Achswerten. CartesianToAxes : Inverse Kinematik: Berechnung der Achswerte aus Position und Orientierung. NumAxes : Anzahl der Achsen der Kinematik " }, 
{ "title" : "5. Implementieren der Methoden der Schnittstellen ISMKinematicsWithInfo2 und ISMKinematicsWithInfo ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_cd5f17f76b6990f1c0a86463705dcfa1", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Kundenspezifische Kinematiken \/ 5. Implementieren der Methoden der Schnittstellen ISMKinematicsWithInfo2 und ISMKinematicsWithInfo ", 
"snippet" : "GetAxisProperties : Eigenschaften wie Achsentyp. Die Grenzen für jede Achse können definiert werden. GetKinematicsName : Name der Kinematik IsSingularity : Kann für diese Kinematik ignoriert werden...", 
"body" : "GetAxisProperties : Eigenschaften wie Achsentyp. Die Grenzen für jede Achse können definiert werden. GetKinematicsName : Name der Kinematik IsSingularity : Kann für diese Kinematik ignoriert werden " }, 
{ "title" : "6. Ausfüllen der Projektinformationen ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_2f5ca72b6b6990f1c0a864634f9c8dd7", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Kundenspezifische Kinematiken \/ 6. Ausfüllen der Projektinformationen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "7. Überprüfen der Bibliothek auf Compilerfehler ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_24eaad936b6990f1c0a864633896924b", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Kundenspezifische Kinematiken \/ 7. Überprüfen der Bibliothek auf Compilerfehler ", 
"snippet" : "Zur Überprüfung er Bibliothek rufen Sie den Befehl Erstellen → Alle Poolobjekte prüfen auf....", 
"body" : "Zur Überprüfung er Bibliothek rufen Sie den Befehl Erstellen → Alle Poolobjekte prüfen auf. " }, 
{ "title" : "8. Erstellung der Beschreibung im Achsgruppenkonfigurator ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_51fd948a6c11885ac0a8646354b16b84", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Kundenspezifische Kinematiken \/ 8. Erstellung der Beschreibung im Achsgruppenkonfigurator ", 
"snippet" : "Zur Erstellung der Beschreibung müssen Sie vorab das Add-On CODESYS Library Documentation Support installieren. Dieses Add-On enthält das Programm libdoc.exe, das in der nachfolgenden Anweisung benötigt wird. Das Add-On kann über den CODESYS Installer installiert werden. Wenn die POU das Attribut sm...", 
"body" : "Zur Erstellung der Beschreibung müssen Sie vorab das Add-On CODESYS Library Documentation Support installieren. Dieses Add-On enthält das Programm libdoc.exe, das in der nachfolgenden Anweisung benötigt wird. Das Add-On kann über den CODESYS Installer installiert werden. Wenn die POU das Attribut sm_kin_libdoc besitzt, wird der im Funktionsbaustein angegebene Kommentar im Achsgruppenkonfigurator als Beschreibung der Kinematik verwendet. Die Beschreibung erfolgt in Restructured Text. Gehen Sie folgendermaßen vor, um die Beschreibung der Kinematik aus den FB-Kommentaren im Achsengruppeneditor zu erzeugen: Fügen Sie das Attribut sm_kin_libdoc hinzu, wie in der Abbildung oben gezeigt. Fügen Sie im Projektinformationsdialog die erforderlichen Projekteigenschaften DocFormat und DocLanguages für die Bibliotheksdokumentation hinzu. Ergebnis: Stellen Sie sicher, dass das Installationsverzeichnis von CODESYS die ausführbare Datei libdoc.exe enthält (Verzeichnis ...\\DocScripting\\3.5.xx.0 \\). Laden Sie den 32-bit wkhtmltox-Konverter mit Version 0.12.5 oder niedriger von https:\/\/wkhtmltopdf.org\/downloads.html herunter. Entpacken Sie die Datei wkhtmltox.dll und fügen Sie sie im CODESYS -Installationsverzeichnis unter ...\\DocScripting\\3.5.xx.0\\bin ein. Da die wkhtmltox.dll ab der Version 0.12.6 standardmäßig Bilder nicht mehr unterstützt, müssen Sie die Version 0.12.5 oder älter verwenden. Erzeugen Sie unter Windows die Systemvariable LIBDOC_CODESYS . Setzen Sie den Wert auf den Dateipfad von CODESYS.exe . Beachten Sie, dass der Pfadname und der Profilname in doppelten Anführungsstrichen steht. Ergebnis: Speichern, schließen und öffnen Sie das Bibliotheksprojekt neu. Wählen Sie den Befehl Datei → Projekt als übersetzte Bibliothek speichern . Die übersetzte Bibliothek wird später in dem Projekt installiert, das diese Kinematik verwendet. " }, 
{ "title" : "Verwenden der Bibliothek in einem Projekt (CustomKinematics_Implementation.project) ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3c747e2a6b6990f1c0a864637a72fb84", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Kundenspezifische Kinematiken \/ Verwenden der Bibliothek in einem Projekt (CustomKinematics_Implementation.project) ", 
"snippet" : "Das Projekt zeigt ein Beispiel, wie Sie die im vorigen Abschnitt erstellte Kinematik durch Joggen oder Kommandieren einer Bewegung verwenden und steuern können. Erstellen Sie ein CODESYS -Standardprojekt mit der Steuerung CODESYS SoftMotion Win . Öffnen Sie den Bibliotheksverwalter und installieren ...", 
"body" : "Das Projekt zeigt ein Beispiel, wie Sie die im vorigen Abschnitt erstellte Kinematik durch Joggen oder Kommandieren einer Bewegung verwenden und steuern können. Erstellen Sie ein CODESYS -Standardprojekt mit der Steuerung CODESYS SoftMotion Win . Öffnen Sie den Bibliotheksverwalter und installieren Sie die Bibliothek CustomKinematics.compiled-library (erstellt im vorherigen Abschnitt), die die Kinematik Gantry3C enthält. Fügen Sie die Bibliothek dem Bibliotheksverwalter hinzu. Fügen Sie ein Achsgruppenobjekt hinzu und wählen Sie die Kinematik KinCustom.Gantry3C . Ergebnis: Fügen Sie im Gerätebaum dem Achsenpool von SoftMotion General Axis Pool 4 virtuelle Achsen hinzu. (DriveX, Y, Z und C) Öffnen Sie den Achsengruppenkonfigurator und ordnen Sie im Abschnitt Achszuordnung die Achsen ihren jeweiligen Feldern zu. Ergebnis: Das Programm Prg_Visu ist das Hauptprogramm, das die Achsengruppe kontrolliert. Wenn die Anwendung gestartet wird, schaltet das Prg_Visu die Achsgruppe ein und aktiviert sie. Außerdem ruft es alle notwendigen Funktionsbausteine auf, um die Achsgruppe zu steuern (Jogging, lineare und PTP-Bewegungen). Alle diese Bewegungen können über die angeschlossene Visualisierung gesteuert werden. Ergebnis: Funktionsbaustein Jog : Dieser Funktionsbaustein kombiniert das Joggen sowohl im Achsraum als auch im kartesischen Raum. Er verwendet zwei Instanzen von SMC_GroupJog2 . Eine für den Achsraum und die andere für den kartesischen Raum. Dieser Funktionsbaustein kann zusammen mit den Visualisierungsvorlagen V_RobotPosition_axes und V_RobotPosition_cart_Jog verwendet werden, um beliebige Kinematiken im kartesischen und Achsenraum zu joggen. Ergebnis: FB SMC_TRAFOF_Gantry3C : Dieser Funktionsbaustein transformiert die Eingangsachsenwerte einer Gantry3C-Kinematik in ihre jeweiligen TCP-Werte. Zusätzlich werden die Achsenwerte normalisiert, damit Sie sie zusammen mit der Visualisierungsvorlage TRAFOF_Gantry3C_YZ zur Visualisierung der Bewegungen der Kinematik verwenden können. Ergebnis: Kompilieren und starten Sie die Anwendung. Öffnen Sie die Visualisierung. Sie können den Roboter sowohl im Achsraum als auch im kartesischen Raum joggen. Es sind auch Visualisierungsvorlagen vorhanden, um eine lineare oder eine PTP-Bewegung zu kommandieren. Ergebnis: Das hier beschriebene Beispiel betrachtet die Positionier- und Orientierungsachsen in einem gemeinsamen Funktionsbaustein. Viele Kinematiken können sich aus zwei entkoppelten Teilkinematiken zusammensetzen: Einer Positionierkinematik (Delta, Portale,…) und einer Orientierungskinematik (Werkzeuge wie C-Achse, Wrist2, Wrist3, …). Die beiden Kinematiken sind am so genannten ‚Flanschpunkt‘, dem TCP der Positionierkinematik, miteinander verbunden. Die Orientierungskinematik zeichnet sich dadurch aus, dass sie in der Lage ist, den Vektor vom Flanschpunkt zum TCP der gekoppelten Kinematik zu berechnen. Die Berechnung erfolgt nur mit der Orientierung dieses TCP (also unabhängig von der Positionierkinematik oder unabhängig von der Orientierung des Flanschpunktes). Die Positionierkinematik wiederum muss in der Lage sein, ihre Achsenpositionen nur aus der Position des Flanschpunktes zu bestimmen. Sie darf nicht von der Orientierung des Flanschpunktes abhängen. In diesem Fall können Sie auf Schnittstellen wie ISMPositionKinematics oder ISMOrientationKinematics zurückgreifen. Um diese Schnittstellen zu implementieren, definieren Sie einen Funktionsbaustein, der ISMPositionKinematics implementiert und einen weiteren Funktionsbaustein, der ISMOrientationKinematics implementiert. Definieren Sie schließlich einen Funktionsbaustein, der den Funktionsbaustein Kin_Coupled (aus SM3_Transformation ) mit den zuvor definierten Funktionsbausteinen als Eingänge erweitert. Für weitere Informationen siehe: Erstellen eigener Kinematiken" }, 
{ "title" : "Achsgruppe mit Depictor visualisieren ", 
"url" : "_sm_example_axis_group_depictor.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Achsgruppe mit Depictor visualisieren ", 
"snippet" : "Für dieses Projekt benötigen Sie zusätzlich das Add-on CODESYS Depictor mit einer gültigen Lizenz. Die SoftMotion-Anwendung besteht aus 4 rotatorischen Antrieben, die als Achsgruppe konfiguriert sind. Die ersten drei Achsen bewegen den TCP in der XY-Ebene, die vierte Achse in der Z-Ebene. Das Beispi...", 
"body" : "Für dieses Projekt benötigen Sie zusätzlich das Add-on CODESYS Depictor mit einer gültigen Lizenz. Die SoftMotion-Anwendung besteht aus 4 rotatorischen Antrieben, die als Achsgruppe konfiguriert sind. Die ersten drei Achsen bewegen den TCP in der XY-Ebene, die vierte Achse in der Z-Ebene. Das Beispiel zeigt, wie Sie den Depictor mit der kinematischen Konfiguration Kin_Scara3_Z verwenden können. Dasselbe Verfahren können Sie auch für andere kinematische Konfigurationen anpassen. Programm starten und testen Über die Visualisierung des Projekts können Sie die Achswerte verändern. Wenn Sie im Programm PLC_PRG den aktiven Bewegungsbefehl ( MoveAbs... ) auskommentieren und die Kommentare des zweiten Bewegungsbefehls entfernen, können Sie die kartesischen Koordinaten verändern. Übersetzen Sie das Projekt und laden Sie es auf die Steuerung. Öffnen Sie den Editor des Depictor-Objekts Ihres Projekts. Wechseln Sie zur Visualisierung und Ändern Sie die Achswerte oder die kartesischen Werte. Beobachten Sie die Bewegung des Scara-Roboters im Depictor. " }, 
{ "title" : "Standardprojekt erstellen ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a87f67372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Achsgruppe mit Depictor visualisieren \/ Standardprojekt erstellen ", 
"snippet" : "Erstellen Sie ein Standardprojekt mit der Steuerung CODESYS SoftMotion Win und der Programmiersprache ST. Fügen Sie in der Ansicht POUs einen Biliotheksverwalter hinzu. Öffnen Sie den Bibliotheksverwalter und fügen Sie die Bibliotheken SM3_Depictor und DepictorBase hinzu....", 
"body" : "Erstellen Sie ein Standardprojekt mit der Steuerung CODESYS SoftMotion Win und der Programmiersprache ST. Fügen Sie in der Ansicht POUs einen Biliotheksverwalter hinzu. Öffnen Sie den Bibliotheksverwalter und fügen Sie die Bibliotheken SM3_Depictor und DepictorBase hinzu. " }, 
{ "title" : "Achsen hinzufügen und parametrieren ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a65c81372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Achsgruppe mit Depictor visualisieren \/ Achsen hinzufügen und parametrieren ", 
"snippet" : "Hängen Sie unterhalb des Objekts SoftMotion General Axis Pool 4 virtuelle Achsen an und benennen Sie die Achsen mit Drive1…Drive4. Parametrieren Sie die Achsen Drive1, Drive2, Drive3 und Drive4 als Achstyp begrenzt mit Softwareendschalter von -180 Grad und 180 Grad. Konfigurationseditor: Für weitere...", 
"body" : "Hängen Sie unterhalb des Objekts SoftMotion General Axis Pool 4 virtuelle Achsen an und benennen Sie die Achsen mit Drive1…Drive4. Parametrieren Sie die Achsen Drive1, Drive2, Drive3 und Drive4 als Achstyp begrenzt mit Softwareendschalter von -180 Grad und 180 Grad. Konfigurationseditor: Für weitere Informationen siehe: Virtueller Antrieb" }, 
{ "title" : "Achsgruppe konfigurieren ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5e750372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Achsgruppe mit Depictor visualisieren \/ Achsgruppe konfigurieren ", 
"snippet" : "Fügen Sie unterhalb der Applikation eine Achsgruppe „KinScara“ hinzu. Wählen Sie dazu den Befehl Projekt → Objekt hinzufügen → Achsgruppe . Klicken Sie im Konfigurator auf Kinematik wählen . Wählen Sie die Kinematik TRAFO.Kin_Scara3_Z aus. Legen Sie die Parameter wie folgt fest: dArmLength1 , dArmLe...", 
"body" : "Fügen Sie unterhalb der Applikation eine Achsgruppe „KinScara“ hinzu. Wählen Sie dazu den Befehl Projekt → Objekt hinzufügen → Achsgruppe . Klicken Sie im Konfigurator auf Kinematik wählen . Wählen Sie die Kinematik TRAFO.Kin_Scara3_Z aus. Legen Sie die Parameter wie folgt fest: dArmLength1 , dArmLength2 , dArmLength3 : 500 dOffsetA1 , dOffsetA2 , dOffsetA3 , dOffsetZ : 0 Ordnen Sie die Achsen wie folgt zu: A1 : Drive1 A2 : Drive2 A3 : Drive3 Z : Drive4 Hinweis: Sie können die Achsen direkt mit der Maus in das Eingabefeld ziehen. Für weitere Informationen siehe: Kinematiken" }, 
{ "title" : "Steuerungsprogramm erstellen ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_26c321018be5c522c0a864636ae45467", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Achsgruppe mit Depictor visualisieren \/ Steuerungsprogramm erstellen ", 
"snippet" : "Deklarieren Sie im Programm PLC_PRG Instanzen des Funktionsbausteins MC_Power für alle Antriebe. Legen Sie eine Variable istate für die Zustandsmaschine an. VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power; istate: INT; END_VAR Definieren Sie in der Implementierung eine Zustands...", 
"body" : "Deklarieren Sie im Programm PLC_PRG Instanzen des Funktionsbausteins MC_Power für alle Antriebe. Legen Sie eine Variable istate für die Zustandsmaschine an. VAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power;\n istate: INT;\nEND_VAR Definieren Sie in der Implementierung eine Zustandsmaschine. CASE istate OF\n 0:\n 1:\n 2:\nEND_CASE Schalten Sie im Zustand 0 alle Antriebe ein. 0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF Wenn die Achsen zugeschaltet sind, geben Sie die Achsgruppe frei (Schalten von „deaktiviert“ auf „standby“). VAR\n GroupEnable:MC_GroupEnable;\nEND_VAR\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF Deklarieren und Initialisieren Sie eine Variable, um den Sollwert in Maschinenkoordinaten zu speichern. Deklarieren Sie zwei Instanzen des Typs SMC_POS_REF , um den TCP in kartesischen und Achskoordinaten zu darzustellen. VAR\n Frame: MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart: SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis: SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\nEND_VAR\nVAR CONSTANT\n axispos: TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR\n\n2:\n Pos_Cart.c:= Frame; \/\/ To represent the TCP in cartesian coordinates; Deklarieren Sie eine Instanz von MC_MoveDirectAbsolute , um den Scara-Roboter auf die festgelegten Koordinaten zu bewegen. VAR\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates\nEND_VAR\n\n2:\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined Axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF Deklarieren Sie eine Variable vom Typ SMC_GroupReadSetPosition um den aktuellen Wert des Roboters in kartesischen Koordinaten und Achskoordinaten zu lesen. VAR\n Car_pos, Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current axis values\nEND_VAR\n\n2:\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ to read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ to read the current axis values " }, 
{ "title" : "Das gesamte Programm PLC_PRG ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5721f372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Achsgruppe mit Depictor visualisieren \/ Das gesamte Programm PLC_PRG ", 
"snippet" : "Vergleichen Sie Ihr Programm und fügen Sie die fehlenden Programmteile hinzu. Deklaration PROGRAM PLC_PRG VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power; istate: INT; GroupEnable:MC_GroupEnable; Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian positi...", 
"body" : "Vergleichen Sie Ihr Programm und fügen Sie die fehlenden Programmteile hinzu. Deklaration PROGRAM PLC_PRG\nVAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power;\n istate: INT;\n\n GroupEnable:MC_GroupEnable;\n\n Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart:SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis:SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\n\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates (PTP)\n\n Car_pos,Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current position of the TCP in Cartesian and Axis Coordinates and display it on the visu\n\n scara_Config:trafo.Kin_Scara3_Z_Config; \/\/ To set the configuration of the SCARA_3_Z\n kin_Config:SMC_SetKinConfiguration; \/\/ To set the defined configuration of SCARA_3_Z to the axis group used\n nPeriod:DINT:=0; \/\/ SCARA_3_Z Period\n Xelbow:BOOL:=TRUE;\n\nEND_VAR\nVAR CONSTANT\n axispos : TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR Implementierung CASE istate OF\n\n0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF\n\n2:\n scara_Config(xElbowRight:=Xelbow, nPeriodA3:=nPeriod);\n kin_Config(AxisGroup:=KinScara,ConfigData:=scara_Config.Config, Execute:=TRUE);\n Pos_Cart.c:=Frame; \/\/ To represent the TCP in cartesian coordinates\n\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ read the current position in Axis coordinates\n\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF\nEND_CASE " }, 
{ "title" : "Depictorprogramm erstellen ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_8f044cf9373811e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Achsgruppe mit Depictor visualisieren \/ Depictorprogramm erstellen ", 
"snippet" : "Fügen Sie unterhalb der Applikation eine neue POU „Depic“ vom Typ „Programm“ hinzu. Wählen Sie dazu den Befehl Projekt → Objekt hinzufügen → POU . Deklarieren Sie eine Variable vom Typ SM3_Depictor.SMC_R_Scara3_Z_Data . Deklarieren Sie eine Variable LrSize vom Typ LREAL und initialisieren Sie die Va...", 
"body" : "Fügen Sie unterhalb der Applikation eine neue POU „Depic“ vom Typ „Programm“ hinzu. Wählen Sie dazu den Befehl Projekt → Objekt hinzufügen → POU . Deklarieren Sie eine Variable vom Typ SM3_Depictor.SMC_R_Scara3_Z_Data . Deklarieren Sie eine Variable LrSize vom Typ LREAL und initialisieren Sie die Variable mit dem Wert 100. VAR\n ScaraTrafo : SM3_Depictor.SMC_R_Scara3_Z_Data;\n LrSize:LREAL:=100;\nEND_VAR Fügen Sie in der Implementierung einen Aufruf des Funktionsbausteins ein. ScaraTrafo(AxisGroup:=KinScara, trf:=KinScara.trafo); Fügen Sie die POU „Depic“ zur Task MainTask hinzu. " }, 
{ "title" : "Depictor konfigurieren ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a523fe372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Achsgruppe mit Depictor visualisieren \/ Depictor konfigurieren ", 
"snippet" : "Fügen Sie unterhalb der Applikation ein Objekt „Depictor“ hinzu. Wählen Sie dazu den Befehl Projekt → Objekt hinzufügen → Depictor . Doppelklicken Sie auf das Objekt. Selektieren Sie im Depictor-Baum das Element Pose . Wählen Sie den Befehl Depictor → Element hinzufügen . Das Element Box wird unterh...", 
"body" : "Fügen Sie unterhalb der Applikation ein Objekt „Depictor“ hinzu. Wählen Sie dazu den Befehl Projekt → Objekt hinzufügen → Depictor . Doppelklicken Sie auf das Objekt. Selektieren Sie im Depictor-Baum das Element Pose . Wählen Sie den Befehl Depictor → Element hinzufügen . Das Element Box wird unterhalb der Pose hinzugefügt. Wählen Sie in den Eigenschaften des Elements die Option Depictor Ref. Klicken Sie auf die Schaltfläche . Wählen Sie aus der Bibliothek SM3_Depictor das Objekt SMC_R_Depictor_Scara3_Z . Definieren Sie die Schnittstellenvariablen wie folgt: fb : Depic.ScaraTrafo lrZ_ : Drive1.fSetPosition lrZmin : 10 lrZmax : -50 lrSize : Depic.LrSize xShowPlane : 0 " }, 
{ "title" : "Visualisierung erstellen ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a460ad372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Achsgruppe mit Depictor visualisieren \/ Visualisierung erstellen ", 
"snippet" : "Erstellen Sie eine Visualisierungsseite, in der die kartesischen Koordinaten und die Achskoordinaten angezeigt und verändert werden können. Fügen Sie unterhalb der Applikation ein Objekt „Visualisierung“ hinzu. Wählen Sie dazu den Befehl Projekt → Objekt hinzufügen → Visualisierung . Öffnen Sie die ...", 
"body" : "Erstellen Sie eine Visualisierungsseite, in der die kartesischen Koordinaten und die Achskoordinaten angezeigt und verändert werden können. Fügen Sie unterhalb der Applikation ein Objekt „Visualisierung“ hinzu. Wählen Sie dazu den Befehl Projekt → Objekt hinzufügen → Visualisierung . Öffnen Sie die Visualisierung im Editor. Fügen Sie ein Visualisierungselement Rechteck (1) ein. Ändern Sie die Eigenschaften des Elements. Texte → Text : %s Textvariablen → Textvariable : PLC_PRG.Car_pos.Position.c.X Eingabekonfiguration → OnMouseDown → Variable schreiben Eingabetyp : VisuDialogs.Numpad Andere Variable verwenden : PLC_PRG.Frame.X Fügen Sie die anderen Visualisierungselemente Rechteck ein. Ändern Sie die Eigenschaften der Element (2) und (3). Texte → Text : %s Textvariablen → Textvariable : PLC_PRG.Car_pos.Position.c.Y bzw. PLC_PRG.Car_pos.Position.c.Z Eingabekonfiguration → OnMouseDown → Variable schreiben Eingabetyp : VisuDialogs.Numpad Andere Variable verwenden : PLC_PRG.Frame.Y bzw. PLC_PRG.Frame.Z Ändern Sie die Eigenschaften der Element (4), (5) und (6). Texte → Text : %s Textvariablen → Textvariable : PLC_PRG.Frame.A bzw. PLC_PRG.Frame.B bzw. PLC_PRG.Frame.C Ändern Sie die Eigenschaften der Element (7), (8), (9) und (10). Texte → Text : %s Textvariablen → Textvariable : PLC_PRG.Axis_pos.Position.a.a0 bzw. PLC_PRG.Axis_pos.Position.a.a1 bzw. PLC_PRG.Axis_pos.Position.a.a2 bzw. PLC_PRG.Axis_pos.Position.a.a3 Eingabekonfiguration → OnMouseDown → Variable schreiben Eingabetyp : VisuDialogs.Numpad Andere Variable verwenden : PLC_PRG.Pos_Axis.a.a0 bzw. PLC_PRG.Pos_Axis.a.a1 bzw. PLC_PRG.Pos_Axis.a.a2 bzw. PLC_PRG.Pos_Axis.a.a3 Beschriften Sie die Visualisierungselemente mit dem Element Beschriftung . " }, 
{ "title" : "Bahnschaltpunkte 1: Einfaches Beispiel ", 
"url" : "_sm_example_digital_switches1.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Bahnschaltpunkte 1: Einfaches Beispiel ", 
"snippet" : "Das hier beschrieben Beispielprojekt Robotics_Trigger.project finden Sie im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples . Bahnschaltpunkte dienen dazu zu erfahren, wann genau eine Achsgruppe einen bestimmten Punkt auf der kommandierten Bahn erreicht. Diese Information ...", 
"body" : "Das hier beschrieben Beispielprojekt Robotics_Trigger.project finden Sie im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples . Bahnschaltpunkte dienen dazu zu erfahren, wann genau eine Achsgruppe einen bestimmten Punkt auf der kommandierten Bahn erreicht. Diese Information kann beispielsweise genutzt werden, um ein Werkzeug exakt zum richtigen Zeitpunkt ein- oder auszuschalten. Dieses Beispiel zeigt, wie ein einzelner Bahnschaltpunkt auf einer Bewegung kommandiert und im Anschluss zyklisch ausgelesen wird. Das Projekt Bahnschaltpunkte 2: Beispiel Klebeprozess zeigt darauf aufbauend ein realistisches Anwendungsbeispiel. " }, 
{ "title" : "Struktur der Applikation ", 
"url" : "_sm_example_digital_switches1.html#UUID-69fc12d0-622f-ba4d-33ec-32604b337f95_section-idm4609369968113633803655575311", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Bahnschaltpunkte 1: Einfaches Beispiel \/ Struktur der Applikation ", 
"snippet" : "Die Applikation besteht aus zwei Programmen, einem Main_PRG , das in der Bustask läuft, und einem Planning_PRG , das in der Planungs-Task der Achsgruppe läuft. Außerdem gibt es einen Trace. Main_PRG : Das Programm Main_PRG enthält die Hauptzustandsmaschine der Applikation. Die ersten beiden Zustände...", 
"body" : "Die Applikation besteht aus zwei Programmen, einem Main_PRG , das in der Bustask läuft, und einem Planning_PRG , das in der Planungs-Task der Achsgruppe läuft. Außerdem gibt es einen Trace. Main_PRG : Das Programm Main_PRG enthält die Hauptzustandsmaschine der Applikation. Die ersten beiden Zustände dienen der Initialisierung und dem Einschalten der Antriebe und der Achsgruppe. Im Zustand STATE_COMMAND_MOVEMENT_WITH_TRIGGER wird zunächst mithilfe einer Instanz des Funktionsbausteins SMC_GroupPrepareTrigger ein Bahnschaltpunkt vorbereitet. Die Position wird relativ mit einem Wert von 0.6 angegeben. Somit wird der Bahnschaltpunkt an den Punkt gelegt, an dem 60% der zugewiesenen Bewegung abgeschlossen sind. Der vorbereitete Bahnschaltpunkt wird der nächsten kommandierten Bewegung zugewiesen. In diesem Beispiel ist das eine Linearbewegung zur Position (X=20, Y=10), die mittels eines MC_MoveLinearAbsolute kommandiert wird. prepTrigger.PositionType := SMC_TriggerPositionType.MvtRelative;\nprepTrigger.Position.MvtPosition := 0.6;\nprepTrigger(AxisGroup:= AxisGroup, Execute:= TRUE);\n \nmoveLinear(AxisGroup:= AxisGroup, Execute:= prepTrigger.Prepared); Im nächsten Zustand STATE_ENABLE_READ_TRIGGER wird eine Instanz von SMC_GroupReadTrigger gestartet, um den Status des kommandierten Bahnschaltpunkts auslesen zu können. Die Verknüpfung zum Bahnschaltpunkt wird über die von SMC_GroupPrepareTrigger zurückgegebene TriggerId hergestellt. readTrigger.TriggerId := prepTrigger.TriggerId;\nreadTrigger.Enable := TRUE; Im Zustand STATE_CHECK_TRIGGER wird schließlich zyklisch der Status des Bahnschaltpunkts überprüft. Sobald SMC_GroupReadTrigger als Status Active meldet, kann die Dauer bis zum Erreichen des Bahnschaltpunkts ausgelesen werden. Die Dauer bezieht sich immer auf den Anfang des aktuellen Zyklus. Der Bahnschaltpunkt wird also im aktuellen Zyklus erreicht, wenn die Dauer kleiner als die Zykluszeit, in diesem Beispiel 0.004 s, ist: IF readTrigger.TriggerInfo.status = SMC_TRIGGER_STATUS.Active THEN\n IF readTrigger.TriggerInfo.triggerTime <= 0.004 THEN\n triggerFired := TRUE;\n ...\n END_IF\nEND_IF Planning_PRG Im Programm Planning_PRG wird mittels des Funktionsbausteins SMC_TuneCPKernel die Dauer der Vorausschau der Planung konfiguriert. Der Baustein SMC_GroupReadTrigger kann im Rahmen dieser Vorausschau ausgeben, wann ein Bahnschaltpunkt erreicht wird. Im Beispiel wird die Dauer der Vorausschau auf 0.1 s gesetzt. Der Status des Bausteins SMC_GroupReadTrigger wechselt deshalb 0.1 s bevor die Achsgruppe den Bahnschaltpunkt erreicht auf Active und gibt ab dann eine gültige Dauer aus. tuneCpKernel(AxisGroup:= axisGroup, Execute:= TRUE, fPlanningForecastDuration:= 0.1); Trace Mithilfe des Trace kann das Verhalten des Bausteins SMC_GroupReadTrigger nachvollzogen werden. Im ersten Diagramm ist zu sehen, dass eine Bewegung von (X=0, Y=0) zu (X=20, Y=10) ausgeführt wird. Der Bahnschaltpunkt liegt an der relativen Position 0.6 auf der Bewegung, also bei (X=12, Y=6). Im zweiten Diagramm wird der Wert des Ausgangs triggerTime von SMC_GroupReadTrigger dargestellt. Der Wert springt auf 0.1 s, weil die Dauer der Vorausschau der Planung 0.1s ist, und fällt dann linear ab, bis an der Position (X=12, Y=6) der Wert 0 erreicht ist. Im dritten Diagramm ist der Wert der Variablen triggerFired zu sehen, der im Zustand STATE_CHECK_TRIGGER des Main_PRG gesetzt wird, sobald die Achsgruppe noch weniger als 0.004 s vom Bahnschaltpunkt entfernt ist. " }, 
{ "title" : "Bahnschaltpunkte 2: Beispiel Klebeprozess ", 
"url" : "_sm_example_digital_switches2.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Bahnschaltpunkte 2: Beispiel Klebeprozess ", 
"snippet" : "Das hier beschrieben Beispielprojekt Robotics_Trigger_Advanced.project finden Sie im Installationsverzeichnis  von CODESYS unter  ..\\CODESYS SoftMotion\\Examples . Mithilfe von Bahnschaltpunkten kann man an bestimmten Positionen auf der Bahn Aktionen ausführen, wie beispielsweise das Ein- und Ausscha...", 
"body" : "Das hier beschrieben Beispielprojekt Robotics_Trigger_Advanced.project finden Sie im Installationsverzeichnis  von CODESYS unter  ..\\CODESYS SoftMotion\\Examples . Mithilfe von Bahnschaltpunkten kann man an bestimmten Positionen auf der Bahn Aktionen ausführen, wie beispielsweise das Ein- und Ausschalten einer Klebstoffdüse. Dieses Beispiel umfasst die folgenden Bestandteile: Die Konfiguration einer garantierten Vorausschau der Trajektorie durch den Parameter  fPlanningForecastDuration  des Bausteins  SMC_TuneCPKernel . Das Kommandieren verschiedener Bahnschaltpunkte. Dabei werden alle drei verfügbaren Methoden zur Definition der Bahnposition verwendet (siehe  SMC_TriggerPositionType ). Die Verwendung von Bahnschaltpunkten mit Zeitverzögerung. Die Beispielapplikation enthält den Baustein  TriggerWithTimeShift , bei dem zeitverzögert (früher und später) auf das Erreichen einer Bahnposition reagiert werden kann. Diese Bestandteile werden anhand einer Beispielapplikation für einen Klebeprozess gezeigt. Dabei wird die im nachfolgenden Bild in rot dargestellte Bewegung ausgeführt (mit Überschleifen). An den grün markierten Positionen sind Bahnschaltpunkte definiert worden: Position 1: Einschalten der Klebeeinrichtung 0.05 s vor Erreichen der Position. Position 1: Einschalten der UV-Lampe beim Erreichen der Position. Position 2: Befüllung des Kleber-Vorratsbehälters beim Erreichen der Position. Position 3: Ausschalten der Klebeeinrichtung und Beenden der Befüllung des Kleber-Vorratsbehälters 0.05 s vor Erreichen der Position. Position 3: Ausschalten der UV-Lampe 1.5 s nach Erreichen der Position " }, 
{ "title" : "Struktur der Applikation ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4589008317470433803801762921", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Bahnschaltpunkte 2: Beispiel Klebeprozess \/ Struktur der Applikation ", 
"snippet" : "Die Applikation besteht aus den folgenden Teilen: GlueApplication : In diesem Programm ist die Beispielapplikation enthalten, die die Verwendung von Bahnschaltpunkten anhand eines Klebevorgangs zeigt. Planning_PRG : In diesem Programm wird eine Vorausschau der Trajektorie konfiguriert. TriggerWithTi...", 
"body" : "Die Applikation besteht aus den folgenden Teilen: GlueApplication : In diesem Programm ist die Beispielapplikation enthalten, die die Verwendung von Bahnschaltpunkten anhand eines Klebevorgangs zeigt. Planning_PRG : In diesem Programm wird eine Vorausschau der Trajektorie konfiguriert. TriggerWithTimeShift : Dieser Baustein enthält die Logik für zeitverzögerte Bahnschaltpunkte und wird im Beispielprogramm  GlueApplication  verwendet. Trace : Der Trace zeigt der Dynamik der Achsen und zusätzlich die durch Bahnschaltpunkte geschalteten Ausgänge vom Programm  GlueApplication . " }, 
{ "title" : "Konfiguration einer Vorausschau ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4570491496867233803803206327", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Bahnschaltpunkte 2: Beispiel Klebeprozess \/ Konfiguration einer Vorausschau ", 
"snippet" : "Wenn frühzeitig vor Erreichen eines Bahnschaltpunkts reagiert werden soll, beispielsweise 0.05 s vor Erreichen einer Position, dann muss der Parameter fPlanningForecastDuration des Bausteins SMC_TuneCPKernel auf mindestens 0.05s eingestellt werden. Da der Parameter direkte Auswirkung auf die Latenz ...", 
"body" : "Wenn frühzeitig vor Erreichen eines Bahnschaltpunkts reagiert werden soll, beispielsweise 0.05 s vor Erreichen einer Position, dann muss der Parameter fPlanningForecastDuration des Bausteins SMC_TuneCPKernel auf mindestens 0.05s eingestellt werden. Da der Parameter direkte Auswirkung auf die Latenz hat, sollte sein Wert nicht größer als nötig sein (siehe die Dokumentation von fPlanningForecastDuration ). Bitte beachten Sie, dass SMC_TuneCPKernel in der SoftMotion -Planungstask aufgerufen werden muss. Deswegen wird die Konfiguration nicht im Hauptprogramm GlueApplication , sondern im Programm Planning_PRG ausgeführt. In dieser Beispielapplikation wird die Auswertung des Bahnschaltpunkts frühestens 0.05 s vor Erreichen einer Position benötigt. Deswegen wird im Programm  Planning_PRG  der Parameter  fPlanningForecastDuration =0.05 gesetzt. " }, 
{ "title" : "Baustein TriggerWithTimeShift ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4609369977958433803803968971", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Bahnschaltpunkte 2: Beispiel Klebeprozess \/ Baustein TriggerWithTimeShift ", 
"snippet" : "Der Baustein  TriggerWithTimeShift  bietet eine vereinfachte Schnittstelle für die Verwendung von Bahnschaltpunkten. Zusätzlich kann eine Zeitverzögerung definiert werden, sodass der Bahnschaltpunkt vor einer Position (positiver Wert) als auch nach einer Position (negativer Wert) auslösen kann. Je n...", 
"body" : "Der Baustein  TriggerWithTimeShift  bietet eine vereinfachte Schnittstelle für die Verwendung von Bahnschaltpunkten. Zusätzlich kann eine Zeitverzögerung definiert werden, sodass der Bahnschaltpunkt vor einer Position (positiver Wert) als auch nach einer Position (negativer Wert) auslösen kann. Je nachdem, welche zeitlichen Genauigkeiten in einer Applikation benötigt werden, kann folgendermaßen auf das Erreichen eines Bahnschaltpunkts reagiert werden: Benötigte zeitliche Genauigkeit >= Bustaskzyklus: In diesem Fall kann der Ausgang  TriggerWithTimeShift.TriggerReachedThisCycle  verwendet werden. Benötigte zeitliche Genauigkeit < Bustaskzyklus: In diesem Fall kann die genaue Restzeit  TriggerWithTimeShift.TriggerTime  bis zum Auslösen des Bahnschaltpunktes verwendet werden. Intern verwendet  TriggerWithTimeShift  die Bausteine  SMC_GroupPrepareTrigger  und  SMC_GroupReadTrigger . " }, 
{ "title" : "Kommandierung von Bahnschaltpunkten ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4608844104630433803805051855", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Bahnschaltpunkte 2: Beispiel Klebeprozess \/ Kommandierung von Bahnschaltpunkten ", 
"snippet" : "Im Programm  GlueApplication  werden die Bewegungen und Bahnschaltpunkte kommandiert. Die Aufrufreihenfolge ist bei Bahnschaltpunkten von besonderer Bedeutung, da die über SMC_GroupPrepareTrigger vorbereiteten Bahnschaltpunkte der nächsten im selben Zyklus kommandierten Bewegung zugewiesen werden. D...", 
"body" : "Im Programm  GlueApplication  werden die Bewegungen und Bahnschaltpunkte kommandiert. Die Aufrufreihenfolge ist bei Bahnschaltpunkten von besonderer Bedeutung, da die über SMC_GroupPrepareTrigger vorbereiteten Bahnschaltpunkte der nächsten im selben Zyklus kommandierten Bewegung zugewiesen werden. Deswegen muss in jeder Applikation auf zwei Punkte geachtet werden: Aufruf der Bausteine zum Kommandieren von Bahnschaltpunkten immer vor den Bewegungs-Bausteinen. Kommandieren von Bahnschaltpunkten und der dazugehörigen Bewegung immer im gleichen Zyklus. Die Bahnschaltpunkte verwenden alle Typen von  SMC_TriggerPositionType : Die Bahnschaltpunkte an Position 1 verwenden die Definition einer relativen Distanz ( SMC_TriggerPositionType.MvtRelative ) und als Position 0.5. Da die zugehörige Bewegung eine Distanz von 10 hat, liegen die Bahnschaltpunkte bei X=5. Der Bahnschaltpunkt an Position 2 verwendet die Definition einer Distanz in Benutzereinheiten u ( SMC_TriggerPositionType.MvtDistance ) und als Position 5. Dadurch liegt der Bahnschaltpunkt auch bei X=5. Die Bahnschaltpunkte an Position 3 verwenden den Schnittpunkt mit einer Ebene ( SMC_TriggerPositionType.PlaneIntersection ). Die Ebene wurde so definiert, dass die Bahnschaltpunkte bei X=5 liegen. GlueApplication  verfügt über die Ausgänge  EnableGlue ,  EnableUVLamp  und  RefillGlueStorage . Diese werden bei den passenden Bahnschaltpunkten in  GlueApplication.EvaluateTriggers()  geschaltet. Die Bewegung und der Zustand dieser Ausgänge kann im Trace überwacht und ausgewertet werden. " }, 
{ "title" : "Verwendung von Zusatzachsen in der Robotik ", 
"url" : "_sm_example_additional_axes.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Verwendung von Zusatzachsen in der Robotik ", 
"snippet" : "Das Beispielprojekt Robotics_AdditionalAxes.project zeigt, wie Zusatzachsen in der Robotik konfiguriert und verwendet werden. Zusatzachsen sind Achsen, die synchron zu koordinierten Bewegungen des Roboters bewegt werden. Sie finden das Projekt im Installationsverzeichnis von CODESYS unter  ..\\CODESY...", 
"body" : "Das Beispielprojekt Robotics_AdditionalAxes.project zeigt, wie Zusatzachsen in der Robotik konfiguriert und verwendet werden. Zusatzachsen sind Achsen, die synchron zu koordinierten Bewegungen des Roboters bewegt werden. Sie finden das Projekt im Installationsverzeichnis von CODESYS unter  ..\\CODESYS SoftMotion\\Examples . " }, 
{ "title" : "Aufbau der Applikation ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063293414778", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Verwendung von Zusatzachsen in der Robotik \/ Aufbau der Applikation ", 
"snippet" : "Die Achsgruppe ist im Objekt AxisGroup konfiguriert. Es wird ein Scara-Roboter mit 3 Achsen (zwei rotatorische Achsen und eine lineare Z-Achse) verwendet. Außerdem sind unter Zusatzachsen zwei Zusatzachsen eingefügt und mit den beiden Achsen DriveAdd1 sowie DriveAdd2 verknüpft. Das Programm PLC_PRG ...", 
"body" : "Die Achsgruppe ist im Objekt AxisGroup konfiguriert. Es wird ein Scara-Roboter mit 3 Achsen (zwei rotatorische Achsen und eine lineare Z-Achse) verwendet. Außerdem sind unter Zusatzachsen zwei Zusatzachsen eingefügt und mit den beiden Achsen DriveAdd1 sowie DriveAdd2 verknüpft. Das Programm PLC_PRG enthält eine einfache Zustandsmaschine für den Programmablauf. Zuerst wird in Zustand 0 die Achsgruppe aktiviert, dann wird eine PTP-Bewegung auf Position (X=50, Y=50) durchgeführt. Diese wird schließlich in eine Linearbewegung zur Position (X=50, Y=-50) überschliffen. Bei der ersten Roboterbewegung wird eine relative Zusatzachsbewegung mit Distanz (10, 20) kommandiert. Bei der zweiten Roboterbewegung ist die Distanz der Zusatzachse (-10, -20) . Mit den Bausteinen MC_GroupReadActualPosition und MC_GroupReadActualVelocity werden Position und Geschwindigkeit der Kinematik und der Zusatzachsen ausgelesen. " }, 
{ "title" : "Inbetriebnahme ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063296617065", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Beispiele \/ Verwendung von Zusatzachsen in der Robotik \/ Inbetriebnahme ", 
"snippet" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Öffnen Sie den Trace und laden Sie ihn auf die Steuerung. Starten Sie die Applikation. Sie können die Bewegung der X- und Y-Koordinate sowie der beiden Zusatzachsen im Trace nachvollziehen...", 
"body" : "Übersetzen Sie die Applikation und laden Sie sie auf eine Steuerung. Öffnen Sie den Trace und laden Sie ihn auf die Steuerung. Starten Sie die Applikation. Sie können die Bewegung der X- und Y-Koordinate sowie der beiden Zusatzachsen im Trace nachvollziehen " }, 
{ "title" : "Benutzeroberfläche ", 
"url" : "_sm_robotics_user_interface.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Benutzeroberfläche ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Planungstask erzeugen ", 
"url" : "_sm_cmd_create_planning_task.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Benutzeroberfläche \/ Befehl: Planungstask erzeugen ", 
"snippet" : "Funktion : Der Befehl erzeugt automatische eine Planungstask. Diese Task wird für die Planung von CP-Bewegungen benötigt (Beispiel: Bewegung linear oder Bewegung kreisförmig). Aufruf Menü Projekt , Kontextmenü der Achsgruppe Voraussetzung : Der Befehl ist nur verfügbar, wenn für die Achsgruppe keine...", 
"body" : "Funktion : Der Befehl erzeugt automatische eine Planungstask. Diese Task wird für die Planung von CP-Bewegungen benötigt (Beispiel: Bewegung linear oder Bewegung kreisförmig). Aufruf Menü Projekt , Kontextmenü der Achsgruppe Voraussetzung : Der Befehl ist nur verfügbar, wenn für die Achsgruppe keine Planungstask konfiguriert ist. " }, 
{ "title" : "Achsgruppeneditor ", 
"url" : "_sm_obj_axis_group-1018069.html", 
"breadcrumbs" : "CODESYS Softmotion \/ CODESYS SoftMotion Robotik \/ Benutzeroberfläche \/ Achsgruppeneditor ", 
"snippet" : "Symbol: Im Editor des Objekts Achsgruppe wählen Sie die Art der Grundkinematik und der Orientierungskinematik aus. Eine Orientierungskinematik kann jedoch nur ausgewählt werden, wenn dies von der Grundkinematik unterstützt wird. Weiterhin bilden Sie die Achsen der Kinematik auf die Antriebe in Ihrem...", 
"body" : "Symbol: Im Editor des Objekts Achsgruppe wählen Sie die Art der Grundkinematik und der Orientierungskinematik aus. Eine Orientierungskinematik kann jedoch nur ausgewählt werden, wenn dies von der Grundkinematik unterstützt wird. Weiterhin bilden Sie die Achsen der Kinematik auf die Antriebe in Ihrem Projekt ab. Kinematik Kinematik auswählen Kinematik ändern Öffnet eine Liste aller von CODESYS unterstützten Kinematiken Wenn Sie eine Kinematik selektieren, wird eine Kurzbeschreibung im Fenster rechts daneben angezeigt. Wenn Sie eine Kinematik ausgewählt haben, können Sie die entsprechenden Parameter im Editor verändern. Orientierungskinematik Kinematik auswählen Kinematik ändern Öffnet eine Liste aller von CODESYS unterstützten Orientierungskinematiken Wenn Sie eine Kinematik selektieren, wird eine Kurzbeschreibung im Fenster rechts daneben angezeigt. Wenn Sie eine Kinematik ausgewählt haben, können Sie die entsprechenden Parameter im Editor verändern. Achszuordnung Abhängig von der gewählten Kinematik bilden Sie die Achsen der Kinematik auf die Antriebe in Ihrem Projekt ab. Zusätzliche Achsen Achse hinzufügen Fügt ein Konfigurationsfeld für eine Zusatzachse hinzu. In diesem Konfigurationsfeld wird der Antrieb aus dem Projekt eingetragen. Tasks Buszyklustask Buszyklustask der Achsen, falls bereits Achsen zugeordnet sind Die Einstellung kann hier nicht verändert werden. Planungstask Task für die Planung von CP-Aufgaben Mit dem Einfügen der ersten Achsgruppe wird automatische eine Planungstask angelegt. Es sollte kein Watchdog konfiguriert sein, da die Ausführungszeit stark schwanken kann. Für weitere Informationen siehe: Konfiguration der PlanungstaskWenn Sie diese Task löschen, wird ein Fehler im Meldungsfenster ausgegeben. Sie können dann über den Befehl Projekt → Planungstask erzeugen eine neue Task erzeugen lassen. Für weitere Informationen siehe: How-To: Achsgruppe anlegen" }, 
{ "title" : "Benutzeroberfläche ", 
"url" : "_sm_user_interface.html", 
"breadcrumbs" : "CODESYS Softmotion \/ Benutzeroberfläche ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: SoftMotion aktivieren ", 
"url" : "_sm_cmd_enable_softmotion.html", 
"breadcrumbs" : "CODESYS Softmotion \/ Benutzeroberfläche \/ Befehl: SoftMotion aktivieren ", 
"snippet" : "Funktion : Der Befehl aktiviert die Komponenten der SoftMotion für die selektierte Steuerung und ermöglicht so die Nutzung der Steuerung als Motion-Controller. Aufruf : Menü Projekt oder Kontextmenü eines selektierten Geräts im Gerätebaum Voraussetzung : Für die selektierte Steuerung ist SoftMotion ...", 
"body" : "Funktion : Der Befehl aktiviert die Komponenten der SoftMotion für die selektierte Steuerung und ermöglicht so die Nutzung der Steuerung als Motion-Controller. Aufruf : Menü Projekt oder Kontextmenü eines selektierten Geräts im Gerätebaum Voraussetzung : Für die selektierte Steuerung ist SoftMotion nicht aktiv. Der Befehl bewirkt, dass unterhalb der Steuerungskonfiguration das Gerät SoftMotion General Axis Pool hinzugefügt wird, sofern das Objekt noch fehlt. Es gibt höchstens einen SoftMotion General Axis Pool pro SPS-Gerät. Außerdem werden im Bibliotheksverwalter die SoftMotion-Bibliotheken (mit Präfix SM3_ ) hinzugefügt. Folglich können Sie auf allen üblichen SPSen die SoftMotion-Funktionalität verwenden und beispielsweise die SoftMotion-Funktionsbausteine auch ohne Lizenz wenigstens im Demobetrieb aufrufen. Automatisches Aktivieren Wenn Ihr Gerät für SoftMotion deaktiviert ist und Sie ein beliebiges SoftMotion-Objekt unter dem Gerät hinzufügen, wird sogleich der Befehl SoftMotion aktivieren implizit ausgeführt. Ein SoftMotion-Objekt ist ein Kurvenscheibenobjekt, ein CNC-Objekt, ein Achsgruppenobjekt oder eine beliebige SoftMotion-Achse. Geräte-Update von einer SoftMotion-SPS auf eine Standard-SPS Wenn SoftMotion aktiviert wurde und Geräte unterhalb von SoftMotion General Axis Pool konfiguriert wurden, können Sie trotzdem Ihr Gerät auf eine Standard-SPS aktualisieren. Denn diese Geräte bleiben auch nach der Aktualisierung vorhanden. Sie können beispielsweise von CODESYS SoftMotion RTE auf CODESYS Control RTE ohne Verluste aktualisieren. " }, 
{ "title" : "Befehl: SoftMotion deaktivieren ", 
"url" : "_sm_cmd_disable_softmotion.html", 
"breadcrumbs" : "CODESYS Softmotion \/ Benutzeroberfläche \/ Befehl: SoftMotion deaktivieren ", 
"snippet" : "Funktion : Der Befehl deaktiviert die Komponenten der SoftMotion . Aufruf : Menü Projekt oder Kontextmenü eines selektierten Geräts im Gerätebaum Voraussetzung : Für die selektierte Steuerung wurde SoftMotion per Befehl aktiviert. Für Steuerungen, die von sich aus SoftMotion unterstützen wie beispie...", 
"body" : "Funktion : Der Befehl deaktiviert die Komponenten der SoftMotion . Aufruf : Menü Projekt oder Kontextmenü eines selektierten Geräts im Gerätebaum Voraussetzung : Für die selektierte Steuerung wurde SoftMotion per Befehl aktiviert. Für Steuerungen, die von sich aus SoftMotion unterstützen wie beispielsweise CODESYS SoftMotion Win , kann SoftMotion nicht deaktiviert werden. Der Befehl bewirkt, dass unterhalb der Steuerungskonfiguration das Gerät General Axis Pool entfernt wird. Außerdem werden im Bibliotheksverwalter die SoftMotion-Bibliotheken (mit Präfix SM3_ ) entfernt. Sie können die SoftMotion-Funktionalität nicht mehr verwenden. " }
]
$(document).trigger('search.ready');
});