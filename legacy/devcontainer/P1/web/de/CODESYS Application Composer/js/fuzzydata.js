$(document).ready(function () {indexDict['de'] = [{ "title" : "CODESYS Application Composer ", 
"url" : "_ac_start_page.html", 
"breadcrumbs" : "CODESYS Application Composer \/ CODESYS Application Composer ", 
"snippet" : "CODESYS Application Composer ist eine Software zur effizienten Erstellung von Applikationsvarianten, die aus wiederkehrenden Funktionsbausteinen bestehen. Sie erstellen auf Basis von Modulen eine Maschinenapplikation und parametrieren diese. Daraus wird automatisch das SPS-Programm generiert. Verbes...", 
"body" : "CODESYS Application Composer ist eine Software zur effizienten Erstellung von Applikationsvarianten, die aus wiederkehrenden Funktionsbausteinen bestehen. Sie erstellen auf Basis von Modulen eine Maschinenapplikation und parametrieren diese. Daraus wird automatisch das SPS-Programm generiert. Verbessert die Wiederverwendbarkeit und Qualität der Applikationsteile Effizienzsteigerung durch automatisierte Generierung von Anwendungen aus vordefinierten Modulen Besonders geeignet für die vereinfachte Projektierung von Anwendungen im Bereich Digital Factory oder Industrie 4.0 Anwendungen im Bereich Digital Factory oder Industrie 4.0 können einfacher projektiert werden Aufgrund der mitgelieferten Generatoren und des Applikationskonzeptes sofort einsatzbereit Videoclip: Gebäudeautomation mit dem Add-on CODESYS Application Composer Beispielprojekte Sie können das Add-on CODESYS Application Composer im CODESYS Installer installieren und aktualisieren. " }, 
{ "title" : "Überblick ", 
"url" : "ac_application_composer_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Überblick ", 
"snippet" : "Der CODESYS Application Composer dient dem Konfektionieren von Applikationen auf Basis bestehender Module. Der Anwender stellt die benötigten Module zusammen, parametriert sie und verbindet sie zu vollständigen Applikationen. Die Konfiguration erfordert keinerlei Kenntnisse in SPS-Programmierung und...", 
"body" : "Der CODESYS Application Composer dient dem Konfektionieren von Applikationen auf Basis bestehender Module. Der Anwender stellt die benötigten Module zusammen, parametriert sie und verbindet sie zu vollständigen Applikationen. Die Konfiguration erfordert keinerlei Kenntnisse in SPS-Programmierung und kann somit auch von Technikern ohne Programmiererfahrung durchgeführt werden. Interne Generatoren erzeugen vollständige, gut strukturierte IEC 61131-3- Applikationen mit E\/A-Abbild und Visualisierung. Der Application Composer besteht aus zwei Hauptkomponenten: Moduleditor, mit welchem die Softwaremodule, welche mit dem Moduldeklarationseditor entwickelt wurden, konfektioniert werden Moduldeklarationseditor zum Entwickeln der Module Beispiel Application Composer Modulbaum und Visualisierung Für weitere Informationen zum Moduleditor siehe: ModuleditorFür weitere Informationen zum Moduldeklarationseditor siehe: Moduldeklarations-Editor" }, 
{ "title" : "Moduleditor ", 
"url" : "ac_module_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor ", 
"snippet" : "Mit den Editoren des Application Composers können Modulinstanzen des Modulbaum konfiguriert und parametriert werden. Durch einen Doppelklick auf das Objekt oder durch den Befehl Objekt bearbeiten des Kontextmenüs öffnen sich die verfügbaren Editoren der Modulinstanz: Verwendung HMI Parameter E\/A Inf...", 
"body" : "Mit den Editoren des Application Composers können Modulinstanzen des Modulbaum konfiguriert und parametriert werden. Durch einen Doppelklick auf das Objekt oder durch den Befehl Objekt bearbeiten des Kontextmenüs öffnen sich die verfügbaren Editoren der Modulinstanz: Verwendung HMI Parameter E\/A Information Weitere Editoren: Erweiterungsmoduleditor Sequence Editor Der Befehl Projekt vergleichen kann auch für Module des Application Composer verwendet werden. " }, 
{ "title" : "Verwendung ", 
"url" : "ac_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Verwendung ", 
"snippet" : "Dieser Dialog steht nur für Toplevel-Modulinstanzen zur Verfügung und beinhaltet Einstellungen zur Applikation und den Tasks. Dialog für Toplevel-Einstellungen Applikation : Applikation die in der Toplevel-Modulinstanz als Generierungsziel eingetragen wird. Über die Schaltfläche kann eine bestehende...", 
"body" : "Dieser Dialog steht nur für Toplevel-Modulinstanzen zur Verfügung und beinhaltet Einstellungen zur Applikation und den Tasks. Dialog für Toplevel-Einstellungen Applikation : Applikation die in der Toplevel-Modulinstanz als Generierungsziel eingetragen wird. Über die Schaltfläche kann eine bestehende Applikation ausgewählt oder eine neue Applikation durch Eingabe des Namens angelegt werden. Wenn die Applikation dem POU-Pool zugewiesen wird, ist das Verbinden der EAs nicht möglich. Bei Decoupled-Modulen, die ein Vatermodul haben, wird die Vaterapplikation ( [Use parent application] ) vorgeschlagen. Standard-Tasks In diesem Feld sind bis zu drei vordefinierte Tasks verfügbar - eine Task mit hoher Priorität, eine mit mittlerer Priorität und eine mit niederer Priorität. Der Name und die Verfügbarkeit der Tasks ist im Modul definiert und kann nicht geändert werden (im Dialog oben: Fieldbus task und Standard task ). Zusätzlich zu den vordefinierten Tasks können durch Eingabe eines Namens neue Task angelegt werden, wenn das Flag CREATE_IF_MISSING “ in der Moduldeklaration gesetzt ist. Die Parameter der neuen Task können in den Standardgeneratoreinstellungen festgelegt werden. Modulspezifische Tasks : In diesem Feld werden Informationen zu modulspezifischen Tasks angezeigt. " }, 
{ "title" : "E\/A ", 
"url" : "ac_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ E\/A ", 
"snippet" : "Dieser Dialog enthält Informationen über die Eingänge und Ausgänge der Module. Ein- und Ausgänge beschreiben den E\/A-Bedarf der Module und können mit Folgendem verbunden werden: Ein- und Ausgängen von Geräten Ein- und Ausgängen anderer Modulinstanzen ST-Ausdrücken oder Konstanten (z.B. können zu Sim...", 
"body" : "Dieser Dialog enthält Informationen über die Eingänge und Ausgänge der Module. Ein- und Ausgänge beschreiben den E\/A-Bedarf der Module und können mit Folgendem verbunden werden: Ein- und Ausgängen von Geräten Ein- und Ausgängen anderer Modulinstanzen ST-Ausdrücken oder Konstanten (z.B. können zu Simulationszwecken boolesche Moduleingänge mit TRUE verbunden werden) Im Online-Betrieb ist die Spalte Online-Wert sichtbar, in der der aktuelle Wert auf der Steuerung angezeigt wird. E\/A-Übersicht der Modulschnittstelle Durch einen Mausklick auf die Schaltfläche Zuordnung öffnet sich der Dialog für die E\/A-Zuordnung: Dialog für E\/A-Zuordnung E\/A-Kanal : Ein Mausklick auf die … Schaltfläche öffnet einen weiteren Dialog, in welchem der Ein- bzw. Ausgang einem Geräte-E\/A zugeordnet werden kann. ST-Ausdruck : Mit dieser Option kann der Ein-\/Ausgang einem ST-Ausdruck zugeordnet werden. Ein Mausklick auf die Schaltfläche öffnet die Eingabehilfe um eine Variable auszuwählen. Verbinde mit Modul-E\/A : Mit dieser Option kann der Ein-\/Ausgang einem anderen Modul-E\/A, welcher noch keine Verbindung hat, zugeordnet werden. Ein Mausklick auf die Schaltfläche öffnet die Eingabehilfe um ein Modul auszuwählen. Keine Verbindung : Keine Zuordnung des Ein-\/Ausgangs. Diese Option ist wie Fehlende Verbindung , erzeugt jedoch keine Warnmeldungen. Fehlende Verbindung : Diese Option ist die Standardeinstellung und erzeugt beim Generieren des Projekts eine Warnmeldung im Meldungsfenster. E\/As, welche durch den Geräte-Generator automatisch verbunden wurden, sind in der EIN\/AUS-Spalte mit einem (AUTO) gekennzeichnet und sind ausgegraut. Wenn die Zuordnung dennoch manuell geändert wird, erscheint ein Warnhinweis, dass diese Aktion die automatische Zuordnung überschreibt. Falls eine automatisch erzeugte Verbindung durch eine manuell gesetzte Verbindung überschrieben wird, wird dieser E\/A-Kanal für die weiteren Generatorläufe nicht mehr berücksichtigt. " }, 
{ "title" : "HMI ", 
"url" : "ac_hmi.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ HMI ", 
"snippet" : "In diesem Dialog definieren Sie die zu verwendende Seitenvorlage und Modulvisualisierungen, die in die Gesamtvisualisierung eingebettet werden sollen. Erzeuge Toplevelreiter : Erzeugt einen Reiter in der Toplevelvisualisierung, welcher direkt die Visualisierung dieser Modulinstanz aufruft. Tastaturk...", 
"body" : "In diesem Dialog definieren Sie die zu verwendende Seitenvorlage und Modulvisualisierungen, die in die Gesamtvisualisierung eingebettet werden sollen. Erzeuge Toplevelreiter : Erzeugt einen Reiter in der Toplevelvisualisierung, welcher direkt die Visualisierung dieser Modulinstanz aufruft. Tastaturkürzel : Mit dem hier eingestellten Tastaturkürzel können Sie direkt zu dieser Visualisierungsseite wechseln. Die Voreinstellung für das Kürzel wird in der Moduldeklaration in der Sektion std.Visu definiert. Seitenvorlagen : Hier kann eine Vorlage für die Visualisierung der Modulinstanz ausgewählt werden, welche als Hintergrund für die Visualisierung verwendet wird. Die Combobox stellt alle Visualisierungen zur Auswahl, die in der Moduldeklaration definiert sind. Standardmäßig wird die erste Visualisierung in der Moduldeklaration ausgewählt. Falls es keine Visualisierung gibt, wird Keine angezeigt. Visualisierung einbetten : Mit dieser Funktion können Visualisierungen der Modulinstanz in die Visualisierung der nächsten übergeordneten Modulinstanz ( Nächster Vorfahre ) oder in die Visualisierung einer anderen Modulinstanz eingebettet werden. Falls es in dem Modul definiert ist, kann der Platzhalter %PAGE_VISU% ausgewählt werden. In diesem Fall wird das für die Modulinstanz erzeugte Visualisierungsbild eingebettet. Es können mehrere Einträge definiert werden. Für weitere Informationen zur Erzeugung von Visualisierungsbilder siehe: Visualisierungsbilder erzeugen " }, 
{ "title" : "Parameter ", 
"url" : "ac_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Parameter ", 
"snippet" : "Dieser Dialog zeigt alle verfügbaren Parameter der Modulinstanz, welche parametriert werden können. Die Einträge in Parameter , Typ , Beschreibung , Min und Max sind nur zur Information. Das Feld Wert kann nach einen Doppelklick editiert werden. Parameterdialog von Modulinstanzen Die Werte von Param...", 
"body" : "Dieser Dialog zeigt alle verfügbaren Parameter der Modulinstanz, welche parametriert werden können. Die Einträge in Parameter , Typ , Beschreibung , Min und Max sind nur zur Information. Das Feld Wert kann nach einen Doppelklick editiert werden. Parameterdialog von Modulinstanzen Die Werte von Parametern werden in einer fetten Schriftform angezeigt, wenn sie explizit gesetzt wurden, andernfalls in normaler Schrift. Geänderte Parameter können mit dem Befehl Auf Defaultwerte zurücksetzen des Kontextmenüs zurückgesetzt werden. Parameter in roter Schrift müssen vom Anwender gesetzt werden, da sonst beim Erzeugen ein Fehler angezeigt wird. Im Onlinebetrieb ist die Spalte Online-Wert sichtbar, in der der aktuelle Wert angezeigt wird. Wenn Sie den Wert des Parameters in der Spalte Wert ändern, wird dieser auch auf der Steuerung geändert. Verwenden Sie den Befehl Online-Werte verwenden um den aktuellen Onlinewert in die Spalte Wert zu übertragen und damit als Parameterwert der Modulinstanz im Modulbaum zu verwenden. Parameterwerte werden grundsätzlich in der für IEC-Literale definierten Syntax dargestellt und editiert, Also wird ein Parameterwert vom Typ TIME z.B. als t#7s35ms dargestgellt. Nach dem Ändern eines Parameters muss das Projekt mit dem Befehl Erzeugen neu erzeugt werden. Wenn Sie im Onlinebetrieb in den Modulinstanzen Parameterwerte geändert haben, erhalten Sie mit dem Befehl Unterschiedliche Parameterwerte eine Liste der geänderten Parameter in der Ansicht Meldungen . Mit einem Doppelklick auf eine solche Meldung öffnet sich der Parameterdialog der betroffenen Modulinstanz, in dem die veränderten Parameterwerte durch eine rote Umrahmung gekennzeichnet sind. " }, 
{ "title" : "Information ", 
"url" : "ac_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Information ", 
"snippet" : "Dieser Informationsdialog zeigt Details über Icon , Name , Beschreibung , Quelle , Version , Anbieter und Kategorie der Modulinstanz. Optional werden mehrere Links angezeigt. Ein Mausklick auf den Link öffnet die zugehörige Anwendung. Der Inhalt der ersten URL wird im Fenster rechts angezeigt. Damit...", 
"body" : "Dieser Informationsdialog zeigt Details über Icon , Name , Beschreibung , Quelle , Version , Anbieter und Kategorie der Modulinstanz. Optional werden mehrere Links angezeigt. Ein Mausklick auf den Link öffnet die zugehörige Anwendung. Der Inhalt der ersten URL wird im Fenster rechts angezeigt. Damit die Links hier angezeigt werden, müssen sie in der Moduldeklaration in der Sektion MetaData definiert sein. Vertrauenswürdige Domänen und Sites werden in den Composer-Optionen festgelegt. Falls Sie auf eine URL klicken und diese noch nicht als „vertrauenswürdig“ festgelegt ist, erscheint in der rechten Ansicht ein Dialog. Sie können dann in dieser Ansicht die URL zu den vertrauenswürdigen Domänen oder Sites hinzufügen. " }, 
{ "title" : "SourceTemplate ", 
"url" : "ac_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ SourceTemplate ", 
"snippet" : "In diesem Dialog wird festgelegt, welche Funktionsbausteine aus dem POUs-Pool in die Applikation kopiert werden, wenn der Befehl Erzeugen ausgeführt wird. Für das Kopieren von Funktionsbausteinen muss der SourceTemplet -Generator in Generatorkonfiguration aktiviert sein. Der Dialog listet alle Funkt...", 
"body" : "In diesem Dialog wird festgelegt, welche Funktionsbausteine aus dem POUs-Pool in die Applikation kopiert werden, wenn der Befehl Erzeugen ausgeführt wird. Für das Kopieren von Funktionsbausteinen muss der SourceTemplet -Generator in Generatorkonfiguration aktiviert sein. Der Dialog listet alle Funktionsbausteine auf, die in der Moduldeklaration in der Sektion SourceTemplate definiert sind. Source-FB : Bezeichner der zu kopierenden Funktionsbausteine Zu kopieren : TRUE\/FALSE: Der Baustein wird kopiert\/nicht kopiert. Wenn der Parameter IsMandatory in der Moduldeklaration mit TRUE definiert ist, kann der Wert hier nicht verändert werden. Typ des Source-FBs : Name des Funktionsbausteins, der kopiert werden soll " }, 
{ "title" : "Editor: ExportDevices ", 
"url" : "ac_export_devices.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Editor: ExportDevices ", 
"snippet" : "Mit diesem Editor können Sie eine Datei auswählen, die durch Geräteexport erzeugt wurde. Dieses Gerät wird beim Erzeugen zum Gerätebaum hinzugefügt. Diese Konfigurationsmöglichkeit wird notwendig, wenn Geräte hinzugefügt werden sollen, die spezielle Eigenschaften besitzen und deshalb vom Gerätegener...", 
"body" : "Mit diesem Editor können Sie eine Datei auswählen, die durch Geräteexport erzeugt wurde. Dieses Gerät wird beim Erzeugen zum Gerätebaum hinzugefügt. Diese Konfigurationsmöglichkeit wird notwendig, wenn Geräte hinzugefügt werden sollen, die spezielle Eigenschaften besitzen und deshalb vom Gerätegenerator nicht angelegt werden können. Bezeichner : Bezeichner aus der Modulbeschreibung Exportierte Datei : Auswahl aller Dateien, die in der Moduldeklaration definiert sind Ist in der Moduldeklaration nur eine Datei definiert, wird diese hier nicht angezeigt. Pro Gerät kann es mehrere ExportDevices geben. Diese werden nach ihrem Bezeichner aus der Modulbeschreibung unterschieden und hier angezeigt. " }, 
{ "title" : "Dialog: Optionen: Composer ", 
"url" : "ac_options.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Dialog: Optionen: Composer ", 
"snippet" : "Dieser Unterdialog des Composer CODESYS -Optionen-Dialogs stellt in verschiedenen Registerkarten Einstellungen für den CODESYS Application Composer zur Verfügung....", 
"body" : "Dieser Unterdialog des Composer CODESYS -Optionen-Dialogs stellt in verschiedenen Registerkarten Einstellungen für den CODESYS Application Composer zur Verfügung. " }, 
{ "title" : "Registerkarte: Allgemein ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_71025f62d62f3d9cc0a8640e01589d60", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Dialog: Optionen: Composer \/ Registerkarte: Allgemein ", 
"snippet" : "Allgemein Vor dem Erzeugen Toplevel-Auswahl anzeigen : Wenn Sie den Befehl Composer → Erzeugen ausführen, erscheint ein Dialog, in dem Sie die Toplevel-Module auswählen können. Sie können die Zeit für das Erzeugen der Applikation verringern, indem Sie Module abwählen, die sich nicht mehr ändern. Edi...", 
"body" : "Allgemein Vor dem Erzeugen Toplevel-Auswahl anzeigen : Wenn Sie den Befehl Composer → Erzeugen ausführen, erscheint ein Dialog, in dem Sie die Toplevel-Module auswählen können. Sie können die Zeit für das Erzeugen der Applikation verringern, indem Sie Module abwählen, die sich nicht mehr ändern. Editoren Parametereditortyp Darstellung der Parameter in der Registerkarte Parameter (Moduleditor) Baumansicht : Die Parametergruppen werden in einer Baumstruktur innerhalb des Editors dargestellt. Tabellarische Ansicht : Die Parametergruppen werden als eigene Registerkarten innerhalb des Editors dargestellt. Einlesen Automatisches Einlesen (gespeichert zusammen mit dem Projekt) : Der CODESYS Application Composer sucht automatisch nach vorhandenen Modulen und Modulinstanzen, wenn in der Ansicht POUs eine neue Bibliothek eingefügt wurde. : Der CODESYS Application Composer sucht nur in folgenden Fällen nach vorhandenen Modulen und Modulinstanzen: Nach dem Öffnen des Projekts Nach dem Einfügen einer Modulinstanz im Modulbaum, wenn noch kein Suchlauf durchgeführt wurde Hinweis: Diese Einstellung wird mit dem Projekt gespeichert! Vertrauenswürdige Domänen Vertrauenswürdige Websites Die hier eingetragenen URLs können im Moduleditor unter der Registerkarte Information angezeigt werden. Voraussetzung dafür ist, dass sie in der Moduldeklaration in der Sektion MetaData definiert sind. " }, 
{ "title" : "Registerkarte: Sequence Editor ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_70cecd07d62f3d9fc0a8640e00b85eda", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Dialog: Optionen: Composer \/ Registerkarte: Sequence Editor ", 
"snippet" : "Allgemein Referenzen anzeigen Parameter anzeigen E\/A-Mapping anzeigen Instanzname anzeigen Kommentar anzeigen Online-Variablen anzeigen : Das jeweilige Element wird im Ablaufschritt des Sequence Editors angezeigt. Darstellung Schrittbreite : Breite des Ablaufschritts in Pixel Gültige Werte: 25 - 500...", 
"body" : "Allgemein Referenzen anzeigen Parameter anzeigen E\/A-Mapping anzeigen Instanzname anzeigen Kommentar anzeigen Online-Variablen anzeigen : Das jeweilige Element wird im Ablaufschritt des Sequence Editors angezeigt. Darstellung Schrittbreite : Breite des Ablaufschritts in Pixel Gültige Werte: 25 - 500. Schrittabstand vert. Abstand zwischen den Ablaufschritten in Pixel Gültige Werte: 10-100 Std.-Verbindung A-Verbindung B-Verbindung Farben der Verbindungslinien zwischen den Ablaufschritten Die Farben von A-Verbindung und B-Verbindung werden nach einem Verzweigungsschritt verwendet. Texte Parameter Referenzen E\/A-Kanäle Farben für die Darstellung der Texte, Parameter, Referenzen und E\/A-Kanäle Schriftart für Texte Die Schaltfläche öffnet den Standarddialog zum Einstellen der Schriftart für Texte im Editor. Schriftart für Verbindungen Die Schaltfläche öffnet den Standarddialog zum Einstellen der Schriftart für die Beschriftung von Verbindungen. " }, 
{ "title" : "Sequence Editor ", 
"url" : "ac_sequenceeditor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Sequence Editor ", 
"snippet" : "Der Sequence Editor ist ein grafischer Editor in Form eines Flussdiagramms zum Darstellen und Editieren des Modulbaums . Mit ihm können Module hinzugefügt und gelöscht sowie ihre Eigenschaften verändert werden. Für den Editor steht auch ein Online-Mode zur Verfügung, mit welchem aktive Modulschritte...", 
"body" : "Der Sequence Editor ist ein grafischer Editor in Form eines Flussdiagramms zum Darstellen und Editieren des Modulbaums . Mit ihm können Module hinzugefügt und gelöscht sowie ihre Eigenschaften verändert werden. Für den Editor steht auch ein Online-Mode zur Verfügung, mit welchem aktive Modulschritte und Haltepunkte verfolgt werden können, was auch für die Fehlersuche sehr hilfreich sein kann. Der Signalfluss selbst (Ausführung und Reihenfolge der Sequenzen) wird nicht durch den Editor implementiert. Dieser dient nur zur Anzeige und Veränderung des Modulbaums. Jede Funktionalität oder Logik des Modulschrittes muss im Funktionsbaustein als IEC ( CODESYS ) Programmcode implementiert werden. Sequence Editor Der Editor steht für alle Module zur Verfügung, welche in ihrer Moduldeklaration in der Sektion mse.Sequence die Definition Root besitzen. Der Inhalt des Editors entspricht dem Modulbaum. Jede Änderung im Modulbaum ändert auch den Inhalt des Sequence Editors und umgekehrt. Es werden nur Modulinstanzen dargestellt, welche unterhalb einer Root “-Instanz eingefügt sind. Der angezeigte Inhalt wird durch die Definitionen in der Sektion mse.Sequence der Moduldeklaration festgelegt. Das Erscheinungsbild des Schrittes ist abhängig von der Definition in der Moduldeklaration. Neben Root gibt es noch drei weitere Definitionen: Step: Parallel: Branch: " }, 
{ "title" : "Angezeigte Daten des Ablaufschrittes ", 
"url" : "ac_sequenceeditor.html#UUID-c7b42e58-c2ec-c00e-5692-55a5d60221bd_d125a077ca9f50ac0a8640e01732ee5_id_ad20551e9b6d77a9c0a865200163ff8b", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Sequence Editor \/ Angezeigte Daten des Ablaufschrittes ", 
"snippet" : "Innerhalb des Rechtecks eines jeden Schrittes wird der Name des Modultyps, der Name der Modulinstanz (optional) und das festgelegte Icon angezeigt. Das Icon entspricht der Definition in den Metadaten (MetaData) der Moduldeklaration . Die Parameter und E\/A-Kanäle der Modulinstanz werden auch angezeig...", 
"body" : "Innerhalb des Rechtecks eines jeden Schrittes wird der Name des Modultyps, der Name der Modulinstanz (optional) und das festgelegte Icon angezeigt. Das Icon entspricht der Definition in den Metadaten (MetaData) der Moduldeklaration . Die Parameter und E\/A-Kanäle der Modulinstanz werden auch angezeigt, falls dies in der Sektion mse.Sequence festgelegt ist. Es werden auch Referenzen angezeigt, wobei hier zwei Typen von Referenzen unterschieden werden: Generelle Referenzen auf Modulinstanzen Sprungreferenzen, die einen Sprung in der Sequenz andeuten Die referenzierten Modulinstanzen werden mit ihrer relativen Pfadangabe im Modulbaum angegeben (beispielsweise ..\/..\/WaitTime ). Die vorkommenden ..\/ werden zusammengefasst, so dass beispielsweise. .\/..\/..\/ zu 3x[..\/] wird. Zu jedem Schritt kann ein Kommentar, welcher durch eine Linie getrennt angezeigt wird, hinzugefügt werden. Dieser wird für jeden Schritt (Modulinstanz) getrennt abgespeichert. Passt der darzustellende Text eines Modulnamens, Parameters, E\/A-Kanals oder Referenz nicht in den vorgegebenen Platz des jeweiligen Ablaufschrittes, so werden die Texte auf maximal zwei Zeilen umgebrochen und schließlich, falls nötig, gekürzt und mit einem folgenden … gekennzeichnet. Zusammengefasst bedeutet dies, dass es maximal vier zusätzliche Listen\/Textfelder für einen Ablaufschritt geben kann: Parameter: Parametername + Parameterwert E\/A-Kanäle: Kanalname + Name des Ziels des Kanals Referenzen: Icon, Pfad und Name der referenzierten Modulinstanz Für Sprungreferenzen: >> + Icon, Pfad und Name der referenzierten Modulinstanz Kommentar: Trennstrich + Kommentar Für weitere Informationen zum Sequence Editor siehe: Arbeiten im Sequence Editor und Sequence Editor im Online-Mode " }, 
{ "title" : "Arbeiten im Sequence Editor ", 
"url" : "ac_sequenceeditor_edit.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Sequence Editor \/ Arbeiten im Sequence Editor ", 
"snippet" : "Wenn der Mauszeiger über einen Schritt bewegt wird, wird dieser mit einer grauen Farbe hinterlegt. Wenn der Zeiger über das leere Ende einer Verbindung bewegt wird, wird ein graues Dreieck eingeblendet. Der Schritt kann durch einen Mausklick angewählt werden und wird dann rot hinterlegt. Eine Mehrfa...", 
"body" : "Wenn der Mauszeiger über einen Schritt bewegt wird, wird dieser mit einer grauen Farbe hinterlegt. Wenn der Zeiger über das leere Ende einer Verbindung bewegt wird, wird ein graues Dreieck eingeblendet. Der Schritt kann durch einen Mausklick angewählt werden und wird dann rot hinterlegt. Eine Mehrfachselektion von Schritten ist ebenfalls möglich. Schritte können mit Drag&Drop verschoben werden. Wenn zusätzliche die Strg -Taste gedrückt wird, werden die Schritte kopiert. Die möglichen Einfügepositionen für verschobene oder kopierte Schritte werden mit einer gestrichelten roten Linie angezeigt. Verschieben von Schritten mittels Drag&Drop Wenn der Mauszeiger über eine Sprungreferenz bewegt wird, deren Ziel in der aktuellen Ablaufsequenz vorhanden ist, wird zusätzlich das Textfeld der Sprungreferenz mit dem angegebenen Zielschritt durch eine gestrichelte Linie verbunden. Dabei wird das Ziel zusätzlich mit einem gestrichelten Kreis markiert. Sprungziel einer Sprungreferenz Editieren von E\/A-Kanälen Wird ein E\/A-Kanal doppelt angeklickt, öffnet sich derselbe E\/A-Mapping-Dialog, derauch im E\/A-Editor von Modulinstanzen verwendet wird. Für weitere Informationen siehe: E\/A " }, 
{ "title" : "Befehle des Sequence Editor ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_00bbee939046545bc0a8652000fd02ce", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Sequence Editor \/ Arbeiten im Sequence Editor \/ Befehle des Sequence Editor ", 
"snippet" : "Ein Rechtsklick auf eine Sequenz oder ein graues Dreieck (leerer paralleler Schritt oder Verzweigung) bietet im Kontextmenü die Befehle an, die an dieser Position ausgeführt werden können. Zusätzlich zu den Standardbefehlen Ausschneiden , Kopieren und Einfügen sind dies folgende Befehle: Schritt ein...", 
"body" : "Ein Rechtsklick auf eine Sequenz oder ein graues Dreieck (leerer paralleler Schritt oder Verzweigung) bietet im Kontextmenü die Befehle an, die an dieser Position ausgeführt werden können. Zusätzlich zu den Standardbefehlen Ausschneiden , Kopieren und Einfügen sind dies folgende Befehle: Schritt einfügen danach Mögliche Folgeschritte werden in einen Listenbefehl angezeigt. So können nur Schritte\/Module hinzugefügt werden, die an dieser Stelle in den Modulslot passen würden. Schritt nach geschlossenen Untersequenzen einfügen Dieser Befehl kann verwendet werden, wenn Untersequenzen einer Verzweigung oder paralleler Sequenz geschlossen werden müssen. Der eingefügte Schritt wird nach der Untersequenz und nicht innerhalb eingefügt. Der Befehl ist nur dann verfügbar, wenn an dieser Stelle eine Untersequenz geschlossen werden kann. Kommentar hinzufügen Fügt einen Kommentar zum selektierten Schritt hinzu. Setze Sprungreferenz Dieser Befehl ist nur im Kontextmenu eines Sprungelementes verfügbar. Mit der Maus kann eine rote Linie zum Zielschritt gezeichnet werden. Das Kontextmenü eines markierten Ablaufelements kann auch mit der Leertaste geöffnet werden. Kontextmenü einer Verzweigung Aufeinanderfolgende Schritte werden mit Pfeilen verbunden. Für ein Verzweigungselement können für die zwei Zweige verschiedene Farben festgelegt werden. Für weitere Informationen siehe; mse.Sequence. Die Farben werden in den CODESYS -Optionen ( Sequence Editor ) festgelegt. " }, 
{ "title" : "Ändern der Position von Ablaufschritten ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_74415e1a90465440c0a865200120cb10", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Sequence Editor \/ Arbeiten im Sequence Editor \/ Ändern der Position von Ablaufschritten ", 
"snippet" : "Um die Position eines Ablaufschrittes zu ändern muss der Schritt selektiert und dann mit der mittleren Maustaste verschoben werden. Die Anordnung der Eigenschaften innerhalb des Elements kann ebenfalls geändert werden. Ändern der Position eines Ablaufschrittes Damit kann nur die Position des Element...", 
"body" : "Um die Position eines Ablaufschrittes zu ändern muss der Schritt selektiert und dann mit der mittleren Maustaste verschoben werden. Die Anordnung der Eigenschaften innerhalb des Elements kann ebenfalls geändert werden. Ändern der Position eines Ablaufschrittes Damit kann nur die Position des Elements im Editor verschoben werden - ein Verändern der Position innerhalb einer Sequenz und damit der Reihenfolge ist nicht möglich. " }, 
{ "title" : "Editieren von Parametern \/ Kommentaren \/ Instanznamen \/ IO-Kanälen ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_a585f36190465431c0a8652000ac8cda", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Sequence Editor \/ Arbeiten im Sequence Editor \/ Editieren von Parametern \/ Kommentaren \/ Instanznamen \/ IO-Kanälen ", 
"snippet" : "Um einen Parameter zu ändern, muss darauf ein Doppelklick ausgeführt werden. Abhängig vom Datentyp der Variable kann das Feld editiert oder ein Variablenwert aus einer Combobox ausgewählt werden (Beispiel: TRUE , FALSE ). Kommentare und Instanznamen können ebenfalls durch einen Doppelklick geändert ...", 
"body" : "Um einen Parameter zu ändern, muss darauf ein Doppelklick ausgeführt werden. Abhängig vom Datentyp der Variable kann das Feld editiert oder ein Variablenwert aus einer Combobox ausgewählt werden (Beispiel: TRUE , FALSE ). Kommentare und Instanznamen können ebenfalls durch einen Doppelklick geändert werden. " }, 
{ "title" : "Editieren von Referenzen ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_939c29699046541bc0a865200038e978", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Sequence Editor \/ Arbeiten im Sequence Editor \/ Editieren von Referenzen ", 
"snippet" : "Eine Referenz kann durch einen Rechtsklick editiert werden. Das Kontextmenü bietet eine Liste von Referenzen an, die an dieser Stelle eingefügt werden können. Setze Referenzen Im Falle einer Sprungreferenz enthält das Kontextmenü den Befehl Setze Sprungreferenz . Wenn der Befehl ausgeführt wird, kan...", 
"body" : "Eine Referenz kann durch einen Rechtsklick editiert werden. Das Kontextmenü bietet eine Liste von Referenzen an, die an dieser Stelle eingefügt werden können. Setze Referenzen Im Falle einer Sprungreferenz enthält das Kontextmenü den Befehl Setze Sprungreferenz . Wenn der Befehl ausgeführt wird, kann das Sprungziel mit der Maus ausgewählt werden. Dazu wird mit der Maus eine gestrichelte rote Linie zum Sprungziel gezeichnet, welches dann mit einem Klick als Ziel gesetzt werden kann. Eine bestehende Sprungreferenz kann mit dem Befehl Löschen aus dem Kontextmenü entfernt werden. Setze Sprungfeferenz " }, 
{ "title" : "Sequence Editor im Onlinebetrieb ", 
"url" : "ac_sequenceeditor_onlinemode.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Sequence Editor \/ Sequence Editor im Onlinebetrieb ", 
"snippet" : "Nach einem Einloggen der Applikation schaltet der Sequence Editor in den Onlinebetrieb. Das Erscheinungsbild der Modulschritte im Onlinebetrieb ist sehr ähnlich zum Offlinebetrieb. Alle Schritte werden angezeigt, können jedoch nicht wie im Offlinebetrieb selektiert und geändert werden. Dieser Modus ...", 
"body" : "Nach einem Einloggen der Applikation schaltet der Sequence Editor in den Onlinebetrieb. Das Erscheinungsbild der Modulschritte im Onlinebetrieb ist sehr ähnlich zum Offlinebetrieb. Alle Schritte werden angezeigt, können jedoch nicht wie im Offlinebetrieb selektiert und geändert werden. Dieser Modus bietet auch die Möglichkeit, Variablenwerte innerhalb eines Schritts darzustellen. Befehle im Onlinebetrieb Im Onlinebetrieb bietet der Sequence Editor im Menü Composer zwei weitere Befehle an: Aktive Haltepunkte zum nächsten Schritt Zentriere Ansicht auf Haltepunkte " }, 
{ "title" : "Aktiver Schritt ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e0ed25b7911507a5c0a8640e003e283b", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Sequence Editor \/ Sequence Editor im Onlinebetrieb \/ Aktiver Schritt ", 
"snippet" : "Falls in der Moduldeklaration so definiert, wird der aktive Schritt in einer gelben Farbe dargestellt. Online-Mode - aktiver Schritt...", 
"body" : "Falls in der Moduldeklaration so definiert, wird der aktive Schritt in einer gelben Farbe dargestellt. Online-Mode - aktiver Schritt " }, 
{ "title" : "Haltepunkte ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e06ef3f19ba07a7bc0a8652001bdb8af", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Sequence Editor \/ Sequence Editor im Onlinebetrieb \/ Haltepunkte ", 
"snippet" : "Falls in der Moduldeklaration so definiert, können im Editor Haltepunkte gesetzt werden. Der Haltepunkt eines Schrittes kann mit dem Befehl Haltepunkt ein-\/ausschalten aus dem Kontextmenü gesetzt oder zurückgesetzt werden. Ein aktivierter Haltepunkt wird mit einem roten Rahmen dargestellt. Wenn der ...", 
"body" : "Falls in der Moduldeklaration so definiert, können im Editor Haltepunkte gesetzt werden. Der Haltepunkt eines Schrittes kann mit dem Befehl Haltepunkt ein-\/ausschalten aus dem Kontextmenü gesetzt oder zurückgesetzt werden. Ein aktivierter Haltepunkt wird mit einem roten Rahmen dargestellt. Wenn der Haltepunkt aktiv ist (der Sequenzablauf hält am Haltepunkt an), wird der Schritt in roter Farbe dargestellt. Onlinebetrieb - Haltepunkte Für weitere Informationen siehe: mse.Sequence" }, 
{ "title" : "Erweiterungsmoduleditor ", 
"url" : "ac_editor_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Erweiterungsmoduleditor ", 
"snippet" : "Der Editor der Erweiterungsmodule stellt die vier Reiter Metadaten , Parameter, E\/A und HMI zur Definition der Module zur Verfügung. Der Editor kann durch einen Doppelklick auf den Funktionsbaustein im POUs -Pool (im Verzeichnis entsprechend dem Namen des Moduls) geöffnet werden. Fehlerbehandlung Be...", 
"body" : "Der Editor der Erweiterungsmodule stellt die vier Reiter Metadaten , Parameter, E\/A und HMI zur Definition der Module zur Verfügung. Der Editor kann durch einen Doppelklick auf den Funktionsbaustein im POUs -Pool (im Verzeichnis entsprechend dem Namen des Moduls) geöffnet werden. Fehlerbehandlung Bei gravierenden Fehlern, die eine Darstellung in den Editoren verhindern, werden die Fehlermeldungen auf der Metadata -Seite ausgegeben. Die Editorseiten werden deaktiviert, so dass sie nicht auf Eingaben reagieren. Ein Beispiel für einen solchen Fehler ist das Fehlen des Modulfunktionsbazsteins. " }, 
{ "title" : "Change-Events ", 
"url" : "ac_editor_extension_module.html#UUID-91f9cff1-6f9e-ea6b-b3cd-d65abac7523b_ef0072b48b6aa7c0a8640e00080c11_id_4681e6c5b4a5a074c0a8640e01e5e429", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Erweiterungsmoduleditor \/ Change-Events ", 
"snippet" : "Der Inhalt des Editors wird automatisch aktualisiert, wenn sich der zugehörige Funktionsbaustein, die zugehörige Textliste, die zugehörige Bildersammlung oder eine zugehörige Visualisierung ändert. (Die genannten Objekte werden als zugehörig betrachtet, wenn sie im selben Ordner liegen wie das Erwei...", 
"body" : "Der Inhalt des Editors wird automatisch aktualisiert, wenn sich der zugehörige Funktionsbaustein, die zugehörige Textliste, die zugehörige Bildersammlung oder eine zugehörige Visualisierung ändert. (Die genannten Objekte werden als zugehörig betrachtet, wenn sie im selben Ordner liegen wie das Erweiterungsmodul.) " }, 
{ "title" : "Metadaten ", 
"url" : "ac_metadata_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Erweiterungsmoduleditor \/ Metadaten ", 
"snippet" : "Auf dieser Registerkarte des Erweiterungsmoduleditors werden die Beschreibung und die Kategorie angezeigt. Die angezeigten Texte werden (mit Ausnahme der Kategorie) aus den Textlisten gelesen. Dabei wird die aktuell im Programmiersystem verwendete Landessprache verwendet. Falls in dieser Sprache kei...", 
"body" : "Auf dieser Registerkarte des Erweiterungsmoduleditors werden die Beschreibung und die Kategorie angezeigt. Die angezeigten Texte werden (mit Ausnahme der Kategorie) aus den Textlisten gelesen. Dabei wird die aktuell im Programmiersystem verwendete Landessprache verwendet. Falls in dieser Sprache kein Text gefunden wird, wird der Standardtext angezeigt. Falls gar kein Texteintrag vorhanden ist, wird nichts angezeigt. Die Bilder werden analog zur Textliste aus der Bildersammlung geladen. Erweiterungsmoduldialog Metadaten Die Schaltflächen rechts von den angezeigten Werten öffnen die betreffende Zeile in der Textliste\/Bildersammlung und ermöglichen damit das Verändern der Texte. Gibt es keinen Text\/kein Bild mit der jeweiligen ID, dann wird ein neues Element mit der ID eingefügt. " }, 
{ "title" : "Parameter ", 
"url" : "ac_parameters_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Erweiterungsmoduleditor \/ Parameter ", 
"snippet" : "Auf dieser Registerkarte des Erweiterungsmoduleditors werden die Parameter des Erweiterungsmoduls in einer Tabelle aufgelistet. Erweiterungsmoduldialog Parameter Die Spalten Id , Variable , Typ and Default sind read-only. In den Spalten Name und Description kann man über einen Linksklick (wenn die e...", 
"body" : "Auf dieser Registerkarte des Erweiterungsmoduleditors werden die Parameter des Erweiterungsmoduls in einer Tabelle aufgelistet. Erweiterungsmoduldialog Parameter Die Spalten Id , Variable , Typ and Default sind read-only. In den Spalten Name und Description kann man über einen Linksklick (wenn die entsprechende Zeile bereites selektiert ist) oder mit Hilfe der Leertaste direkt in die entsprechende Zeile der zuständigen Textliste springen. Der angezeigte Text wird aus der Textliste gelesen, und zwar für die Landessprache, die aktuell für das Programmiersytem eingestellt ist. Fehlt diese Sprache in der Textliste, wird der Standardtext für den Eintrag verwendet. In der Spalte Default wird der Initialisierungswert des Parameters als IEC-Literal dargestellt. Die Tabelle unterstützt Mehrfachauswahl und die übliche Bedienung über Maus und Tastatur. Alle Aktionen, die die Parameter verändern, können über Rückgängi machen \/ Wiederherstellen (Standardbefehle) rückgängig gemacht und wieder ausgeführt werden. Ausschneiden \/ Kopieren \/ Einfügen wird nicht unterstützt. Über die Schaltflächen mit den Pfeilen oder mit den Tastenkürzeln Alt + ↑ und Alt + ↓ kann der selektierte Parameter in der Reihenfolge nach oben oder unten verschoben werden. Über die Schaltfläche mit dem X oder über den Standardbefehl Entf können die selektierten Parameter entfernt werden. Wenn es bei den Parametern Fehler oder Warnungen gibt, dann werden diese unten in der Meldungsliste angezeigt. Wenn man eine Nachricht in dieser Liste selektiert, wird der entsprechende Parameter oben selektiert. Über die Schaltfläche mit dem Stern oder die Tastenkombination Alt + n (wenn die Tabelle den Fokus hat) kann der Dialog Neuer Parameter geöffnet werden: Erweiterungsmodul-Dialog Neuer Parameter Im oberen Teil des Dialogs wird eine hierarchische Tabelle aller in Frage kommenden Variablen des Funktionsbausteins angezeigt. Die Schaltfläche OK ist genau dann aktiviert, wenn eine fett gedruckte Variable selektiert ist und die Id eindeutig ist. Wenn die Id nicht eindeutig ist, wird sie mit einem roten Ausrufezeichen mit Fehlertext versehen. In den Feldern Name und Beschreibung kann der Standardtext vorgegeben werden, der in die Textliste eingetragen wird. Die Texte für die einzelnen Landessprachen müssen dann in der Textliste hinzugefügt werden. Eine Variable wird angezeigt, wenn sie Eingangsvariable eines Funktionsbausteins oder lokale Variable einer Struktur ist. Eine Variable ist selektierbar, wenn sie primitiven Typ hat. " }, 
{ "title" : "E\/A ", 
"url" : "ac_io_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Erweiterungsmoduleditor \/ E\/A ", 
"snippet" : "Diese Registerkarte des Erweiterungsmoduleditors sowie der Dialog zum Erzeugen neuer E\/As verhalten sich ähnlich wie die Registerkarte Parameter . Anstatt der Spalte Default wird die Richtung Ein\/Aus der Eingänge oder Ausgänge angezeigt. Erweiterungsmoduldialog E\/A...", 
"body" : "Diese Registerkarte des Erweiterungsmoduleditors sowie der Dialog zum Erzeugen neuer E\/As verhalten sich ähnlich wie die Registerkarte Parameter . Anstatt der Spalte Default wird die Richtung Ein\/Aus der Eingänge oder Ausgänge angezeigt. Erweiterungsmoduldialog E\/A " }, 
{ "title" : "HMI ", 
"url" : "ac_hmi_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Erweiterungsmoduleditor \/ HMI ", 
"snippet" : "Diese Registerkarte des Erweiterungsmoduleditors ermöglicht das Definieren der Seiten-Visualsierungen sowie der Eingebettete Visualisierungen . In beiden Textfeldern können mehrere durch Komma getrennte Visualisierungsnamen eingegeben werden. Erweiterungsmoduldialog HMI...", 
"body" : "Diese Registerkarte des Erweiterungsmoduleditors ermöglicht das Definieren der Seiten-Visualsierungen sowie der Eingebettete Visualisierungen . In beiden Textfeldern können mehrere durch Komma getrennte Visualisierungsnamen eingegeben werden. Erweiterungsmoduldialog HMI " }, 
{ "title" : "Visualisierungsbilder ", 
"url" : "f_application_composer_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Visualisierungsbilder ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Toplevelvorlagen ", 
"url" : "ac_toplevel_templates.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Visualisierungsbilder \/ Toplevelvorlagen ", 
"snippet" : "Eine Toplevelvorlage ist eine Vorlage für das Startbild der erzeugten Visualisierung. Sie besteht aus einem Platzhalter (Frame) für das anwenderspezifische Bild, und aus Reitern, um direkt auf die einzelnen Bilder zu gelangen. Optional können Schaltflächen zur Navigation sowie eine Status- und Adres...", 
"body" : "Eine Toplevelvorlage ist eine Vorlage für das Startbild der erzeugten Visualisierung. Sie besteht aus einem Platzhalter (Frame) für das anwenderspezifische Bild, und aus Reitern, um direkt auf die einzelnen Bilder zu gelangen. Optional können Schaltflächen zur Navigation sowie eine Status- und Adresszeile eingefügt werden. Die Toplevelvorlage kann in den Einstellungen des Visualisierungsgenerators ausgewählt werden. Die Bibliothek AC_ModuleBase , die Teil der Standardinstallation von CODESYS Application Composer ist, enthält drei Toplevelvorlagen: AC.GenVisu_Toplevel_Template , AC.Toplevel_Vertical_Template und AC.Toplevel_3S_Vertical_Template . Standard-Toplevelvorlagen Toplevelvorlage AC_Toplevel_3S_Vertical_Template Neben den vorgefertigten Vorlagen können auch benutzerspezifische Toplevelvorlagen erzeugt werden. Elemente einer Toplevelvorlage (1): Navigation: hoch \/ zurück \/ vor (2): Frame zur Anzeige der Bilder (3): Reiter für die direkte Navigation zum Toplevelbild (4): Statuszeile (5): Adresszeile: Instanzpfad der angezeigten Modulinstanz Die in der Vorlagenvisualisierung enthaltenen Elemente werden über die Elementnamen identifiziert. Obligatorische Elemente der Vorlage [Frame] : Hauptframe, in dem die Visualisierungsbilder angezeigt werden. Anmerkung: Für optisch gute Ergebnisse sollte der Frame den Skalierungsmodus „Isotropisch“ gesetzt haben. [Tab_Template_1] , [Tab_Template_2] : Zwei Elemente, die als Vorlage für die Reiter verwendet werden. Das erste wird als Vorlage verwendet, aus der Position des zweiten ergibt sich die Ausrichtung der Anordnung (von links nach rechts oder von oben nach unten) sowie die Größe des Zwischenraums zwischen zwei Reitern. Die Alarmfüllfarbe wird verwendet, wenn die angezeigten Bilder in der Hierarchie unterhalb der durch den Reiter repräsentierten Instanz liegt. Ist das Element eine Schaltfläche, wird in diesem Fall auch die Schaltflächenzustandsvariable gesetzt. Ist das Element ein Frame wird die Alarmfüllfarbe nicht verwendet. Stattdessen wird die Frame-Umschaltvariable belegt, so dass sie den Wert 1 hat, wenn der Reiter selektiert ist, und sonst 0. Optionale Elemente der Vorlage [Up] , [Back] , [Forward] : Schaltflächen für die Navigation. Der Elementtyp kann Schaltfläche oder Frame sein. Im letzteren Fall muss der Frame drei Visualisierungen, in dieser Reihenfolge, haben: Neutral, Gedrückt, Deaktiviert. [Address] : Texteingabefeld, in dem der Instanzpfad der dargestellten Modulinstanz angezeigt wird. [Status] : Texteingabefeld in dem der Inhalt der globalen Stringvariablen ac.g_stVisuStatusBar aus der Bibliothek AC_ModuleBase dargestellt wird. Diese Variable kann in der Implementierung eigener Module genutzt werden um den Status von Variablen anzuzeigen. Alle sonstigen Elemente werden vom Visualisierungsgenerator nicht gesondert behandelt. Bei der Generierung wird die Vorlagenvisualisierung kopiert und die Kopie modifiziert. Das Original wird nicht verändert. Mit Ausnahme der oben erwähnten Visualisierungselemente versucht der Visualisierungsgenerator von Hand gemachte Änderungen an diesen Elementen nicht zu verändern. Bei der ersten Visualisierungsgenerierung wird die beschriebene Visualisierungsvorlage kopiert. Diese Kopie wird, solange sie nicht vom Anwender gelöscht wird, bei den weiteren Generierungsläufen nur noch verändert und nicht mehr kopiert. Dazu wird eine Toplevel-Visualisierung von vorherigen Generierungsläufen wie eine neue Visualisierungsvorlage (die Originalvorlage wird nie verändert) behandelt, obwohl sie nicht kopiert ist. So werden weitere Reiter zu den bereits bestehenden Reitern hinzugefügt. Alle anderen Eigenschaften und Elemente werden, wenn möglich, nicht verändert, so dass vom Anwender manuell hinzugefügte Schaltflächen, Reiter etc. ihre Positionen beibehalten. Ein Löchen der Navigationsschaltflächen führt zu deren Verlust. Um sie zu erzeugen, muss die Toplevel-Visualisierung gelöscht und neu generiert werden. " }, 
{ "title" : "Anordnung der Reiter ", 
"url" : "ac_toplevel_templates.html#UUID-b04a5efa-11da-0879-903b-e5e3a3f27499_ac_toplevel_templates0", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Visualisierungsbilder \/ Toplevelvorlagen \/ Anordnung der Reiter ", 
"snippet" : "Die Reiter werden entweder horizontal von links nach rechts oder vertikal von oben nach unten platziert. Die Anordnung der beiden Vorlagenelemente Tab_Template_1 und Tab_Template_2 entscheidet darüber, wie angeordnet wird: Ist der vertikale Abstand der Elemente größer als der horizontale wird horizo...", 
"body" : "Die Reiter werden entweder horizontal von links nach rechts oder vertikal von oben nach unten platziert. Die Anordnung der beiden Vorlagenelemente Tab_Template_1 und Tab_Template_2 entscheidet darüber, wie angeordnet wird: Ist der vertikale Abstand der Elemente größer als der horizontale wird horizontal angeordnet, sonst vertikal. Bei vertikaler Anordnung werden alle Reiter auf dieselbe Breite gebracht, die minimale Breite bei der alle Reiternamen angezeigt werden können. Bei horizontaler Anordnung erhält jeder Reiter die minimale Breite, bei der sein Name angezeigt werden kann. In beiden Fällen entspricht die Höhe der Reiter der Höhe der ersten Vorlage ( Tab_Template_1 ). Zur Platzierung wird für jeden Reiter die erste Vorlage kopiert und angepasst. Die Platzierung beginnt an der Position der ersten Vorlage, der Abstand zweier Reiter ergibt sich aus dem horizontalen oder vertikalen Abstand der beiden Vorlagen. Dieser Abstand kann auch negativ sein, in diesem Fall überlappt der folgende Reiter den vorhergehenden und übermalt ihn, da er weiter vorne liegt). Bei vertikaler Anordnung wird die Generierung mit Fehler abgebrochen, wenn der Platz nach unten nicht ausreicht, um alle Reiter aufzunehmen. Es wird keine zweite Spalte mit Reitern angelegt. Bei horizontaler Anordnung wird eine neue Zeile angefangen, wenn der nächste Reiter horizontal nicht mehr vollständig in die Visualisierung passt. Wenn das beim ersten Reiter einer Zeile geschieht, wird die Generierung mit Fehler abgebrochen. Es kann vorkommen, dass der Platz für die Reiter nicht ausreicht. Bei horizontaler Anordnung passiert das dann, wenn in eine neue Zeile umgebrochen wird. Bei vertikaler Anordnung passiert es, wenn die Breite der Reiter größer ist als der für sie vorgesehene Platz in der Vorlage. In diesen Fällen wird versucht, mehr Platz zu schaffen. Aufgrund der automatischen Ausrichtung der Elemente gibt es vier Möglichkeiten, die Reiter zu platzieren: Horizontale Anordnung der Reiter: Alle Reiter müssen sich vollständig oberhalb des Frames befinden Horizontale Anordnung der Reiter: Alle Reiter müssen sich vollständig unterhalb des Frames befinden Vertikale Anordnung der Reiter: Alle Reiter müssen sich vollständig links vom Frame befinden Vertikale Anordnung der Reiter: Alle Reiter müssen sich vollständig rechts vom Frame befinden Wenn die Vorlage nicht einem dieser Fälle entspricht, wird vor der Generierung ein Fehler ausgegeben. Wenn der Platz für die Reiter nicht ausreicht, dann wird der Frame entsprechend verkleinert. Alle Elemente zwischen Reitern und Frame werden verschoben. Ein Element gilt als „zwischen Reiter und Frame“, wenn es nicht vollständig außerhalb der Grenzen des ersten Reiters liegt (siehe dazu das Beispiel unten für horizontale Anordnung). In jedem Fall wird die Generierung mit Fehler abgebrochen, wenn durch die Änderung des Frames seine Fläche leer oder negativ wird. Beispiel für Elemente zwischen Reiter und Frame Beispiel für Elemente „außerhalb“ Reiter und Frame " }, 
{ "title" : "Visualisierungsbilder erzeugen ", 
"url" : "ac_generating_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Visualisierungsbilder \/ Visualisierungsbilder erzeugen ", 
"snippet" : "In Visualisierungsbildern des Application Composers können alle CODESYS V3 -Visualisierungselemente sowie die eingebetteten Visualisierungsbilder verwendet werden. Weiterhin können Visualisierungselemente (beispielsweise Rechteck) als spezielle Platzhalter genutzt werden. Navigation innerhalb der Vi...", 
"body" : "In Visualisierungsbildern des Application Composers können alle CODESYS V3 -Visualisierungselemente sowie die eingebetteten Visualisierungsbilder verwendet werden. Weiterhin können Visualisierungselemente (beispielsweise Rechteck) als spezielle Platzhalter genutzt werden. Navigation innerhalb der Visualisierung Die Navigation innerhalb der Visualisierung kann über die Reiter oder die Navigationsschaltflächen Zurück , Hoch und Vor erfolgen. Ein Mausklick auf das Reiterelement öffnet direkt das dazugehörige Visualisierungsbild. Die Schaltflächen Zurück und Vor können zum Navigieren innerhalb der Historie des angezeigten Bildes verwendet werden (ähnlich dem Navigieren im Internetbrowser). Der Schalter Hoch schaltet in die nächsthöhere Ebene. " }, 
{ "title" : "Platzhalterelemente in Visualisierungsbildern ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_1d3a1d9285970a30c0a8640e01de1c5b", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Visualisierungsbilder \/ Visualisierungsbilder erzeugen \/ Platzhalterelemente in Visualisierungsbildern ", 
"snippet" : "Standardvisualisierungselemente (beispielsweise Rechteck, Bilder) können als Platzhalter verwendet werden. Beim Erzeugen der Visualisierung werden dann die zugeordneten eingebetteten Visualisierungen an der Position und in der Größe des Platzhalters dargestellt. Spezifikation Die Zuordnung geschieht...", 
"body" : "Standardvisualisierungselemente (beispielsweise Rechteck, Bilder) können als Platzhalter verwendet werden. Beim Erzeugen der Visualisierung werden dann die zugeordneten eingebetteten Visualisierungen an der Position und in der Größe des Platzhalters dargestellt. Spezifikation Die Zuordnung geschieht über den Instanznamen des Elements. Dieser muss die Form PLACEHOLDER_<SUBPATH> haben. Der <SUBPATH> hat folgende Syntax: <SUBPATH> ::= <SLOTREF> | <SLOTREF>:<SUBPATH> <SLOTREF> ::= <SLOTNAME> | <SLOTNAME>[<idx>] <SLOTNAME> ist der Targetname eines Slots (Groß- und Kleinschreibung spielt keine Rolle). <idx> ist ein null-basierter Index, er kann nur bei Multi-Slots verwendet werden und gibt an, welche Submodulinstanz des Multislots dort verbunden werden soll. Beim Einlesen der Moduldefinitionen wird geprüft, ob die Platzhalternamen in den Visualisierungsbildern gültig sind. Genauer, wenn ein Element eines Visualisierungsbilds mit PLACEHOLDER_ beginnt (Groß- und Kleinschreibung unerheblich), dann muss der <SUBPATH> mit einer gültigen Slotreferenz beginnen. Bei Verwendung eines Index muss er zur Stelligkeit des Slots passen. Alle Slotnamen des Pfades müssen gültige IEC-Identifier sein. Gibt es mehrere Platzhalter, so müssen alle Pfade verschieden sein. Ferner müssen die Platzhalterelemente nichtleere Fläche haben. Existiert zu dem <SUBPATH> eines Platzhalterelements keine entsprechende Modulinstanz, dann wird dem Element keine Visualisierung zugeordnet. Es wird auch keine Fehler- oder Warnmeldung ausgegeben. Existiert zu dem <SUBPATH> eine entsprechende Modulinstanz, dann wird sie nur dann eingebettet, wenn sie eine Einbettung in das Visualisierungsbilds der aktuellen Bildes definiert. Die eingebetteten Visualisierungen werden unter Beibehaltung ihres Seitenverhältnisses so skaliert, dass sie einen möglichst großen Bereich der Platzhalterelemente ausfüllen, aber nicht darüber hinaus ragen. Beispiele für Platzhalterelemente Nur Submodulinstanzen und deren Submodulinstanzen können über Platzhalter eingebettet werden. Es ist nicht möglich Visualisierungen aus anderen Zweigen des Modulbaums einzubetten. " }, 
{ "title" : "Überprüfungen der Toplevelvorlage ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_335369a685ed9d34c0a8652001ab0576", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Visualisierungsbilder \/ Visualisierungsbilder erzeugen \/ Überprüfungen der Toplevelvorlage ", 
"snippet" : "Folgende Tests für das Toplevel-Bild werden durchgeführt: Wenn die Vorlagevisualisierung nicht existiert, oder wenn sie Ein- oder Ausgänge in ihrer Schnittstelle hat, wird ein Fehler ausgegeben. Wenn ein obligatorisches Element fehlt, wird ein Fehler ausgegeben. Wenn eines der unterstützten Elemente...", 
"body" : "Folgende Tests für das Toplevel-Bild werden durchgeführt: Wenn die Vorlagevisualisierung nicht existiert, oder wenn sie Ein- oder Ausgänge in ihrer Schnittstelle hat, wird ein Fehler ausgegeben. Wenn ein obligatorisches Element fehlt, wird ein Fehler ausgegeben. Wenn eines der unterstützten Elemente vorhanden ist und entweder eine leere Fläche hat oder nicht den richtigen Elementtyp, wird ein Fehler ausgegeben. Wenn sich die Vorlagen für die Reiter mit dem Frame-Element überschneiden, wird ein Fehler ausgegeben. Wenn die Vorlage für den zweiten Reiter dieselbe Position hat oder ihre Position links von oder oberhalb von der Position der Vorlage des ersten Reiters liegt, wird ein Fehler ausgegeben. Bei horizontaler Ausrichtung der Reiter wird ein Fehler ausgegeben, wenn die Reiter nicht komplett über oder unter dem Frame liegen. Bei vertikaler Ausrichtung der Reiter wird ein Fehler ausgegeben, wenn die Reiter nicht komplett rechts oder links vom Frame liegen. " }, 
{ "title" : "Erzeugen von Visualisierungsbildern ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_85c3e6868b643da6c0a8640e01a0782b", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Visualisierungsbilder \/ Visualisierungsbilder erzeugen \/ Erzeugen von Visualisierungsbildern ", 
"snippet" : "Alle Visualisierungsbilder werden mit dem Befehl Erzeugen initial neu erzeugt. Mit jedem weiteren Durchlauf werden nur noch die Parameter verändert, die sich im Modulbaum verändert haben. Ein erzeugtes Visualisierungsbild besteht aus einem Frame, der die Größe der Visualisierung bestimmt und in den ...", 
"body" : "Alle Visualisierungsbilder werden mit dem Befehl Erzeugen initial neu erzeugt. Mit jedem weiteren Durchlauf werden nur noch die Parameter verändert, die sich im Modulbaum verändert haben. Ein erzeugtes Visualisierungsbild besteht aus einem Frame, der die Größe der Visualisierung bestimmt und in den die entsprechende Visualisierung des Moduls eingeblendet wird. Darüber werden dann die eingebetteten Visualisierungen folgendermaßen platziert: Alle eingebetteten Elemente werden mit der Element-ID persistent identifiziert. Wenn ein bestehendes Visualisierungsbild in einem erneuten Generierungslauf aktualisiert wird, wird nach der entsprechenden ID gesucht. Wenn dieses Element vorhanden ist, dann werden nur die Parameter verändert, die von der Modulkonfiguration geliefert werden. Beispielsweise bleibt die Position unverändert, der Visu\/Framewechsel und das zur Anzeige verwendete Visualisierungsobjekt können sich ändern. Die eingebetteten Visualisierungen werden kachelförmig von links nach rechts und von oben nach unten in die Seite eingefügt. Falls ein passendes Platzhalterelement da ist, hat die Platzierung per Platzhalter Vorrang. Schließlich kommen beide Mechanismen nicht zum Einsatz, wenn der Frame mit der entsprechenden ElementID bei der Generierung bereits vorhanden ist. In diesem Fall bleibt die Position wie sie ist. Visualisierungsbilder, die beim letzten Generierungslauf erzeugt wurden, aber nicht beim aktuellen Lauf erzeugt werden sollen, werden gelöscht. " }, 
{ "title" : "Reihenfolge der Einbettungen ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_b67bb7c98bca4d3bc0a8640e01a07a7d", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Visualisierungsbilder \/ Visualisierungsbilder erzeugen \/ Reihenfolge der Einbettungen ", 
"snippet" : "Zuerst werden alle Visualisierungen, die über next Ancestor eingebettet sind, eingefügt. Diese werden in der Pre-Order der Modulinstanzen im Baum eingefügt. (Zuerst das erste Kind, dann alle dessen Nachfahren, dann das zweite Kind …) Danach werden alle Visualisierungen, die über direkte Angabe der I...", 
"body" : "Zuerst werden alle Visualisierungen, die über next Ancestor eingebettet sind, eingefügt. Diese werden in der Pre-Order der Modulinstanzen im Baum eingefügt. (Zuerst das erste Kind, dann alle dessen Nachfahren, dann das zweite Kind …) Danach werden alle Visualisierungen, die über direkte Angabe der Instanz eingebettet sind, eingefügt. Auch diese werden in Pre-Order der Modulinstanzen eingefügt. " }, 
{ "title" : "Persistence Manager ", 
"url" : "ac_pm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager ", 
"snippet" : "Der Persistence Manager ist eine Standardkomponente des Application Composers. Er dient zur Verwaltung persistenter remanenter Daten. Er erkennt solche an bestimmten Attributen in der Variablendeklaration. Damit bietet er eine Alternative zur Verwendung des VAR PERSISTENT-Mechanismus des Standard-Pr...", 
"body" : "Der Persistence Manager ist eine Standardkomponente des Application Composers. Er dient zur Verwaltung persistenter remanenter Daten. Er erkennt solche an bestimmten Attributen in der Variablendeklaration. Damit bietet er eine Alternative zur Verwendung des VAR PERSISTENT-Mechanismus des Standard-Programmiersystems, bei dem persistente Variablen in einer speziellen globalen Variablenliste ( Persistente Variablen ) verwaltet werden. Dieser Mechanismus ist auf zeitliche Performanz und Ablage in einem remanenten Speicherbereich ausgelegt. Dagegen speichert der Persistence Manager persistente Werte in einer externen Datei und stellt somit weniger Anforderung an die Speicherausstattung einer Steuerung. Er ermöglicht ein Erhalten der Werte, auch wenn Deklarationen geändert werden, und er erlaubt externes Bearbeiten der Datensätze. Die erweiterte Funktionalität geht allerdings auf Kosten der Performanz. In Abhängigkeit von der Steuerung kann das Lesen und insbesondere das Schreiben einer großen Menge persistenter Variablen viel Zeit in Anspruch nehmen und die entsprechende Task lange blockieren. Somit hängt es vom Anwendungsfall ab, mit welchem Mechanismus die Datenpersistenz eingerichtet werden sollte. Für gewisse Fälle ist auch die Verwendung von Rezepturen die beste Lösung. Sehen Sie hierzu als Entscheidungshilfe: Persistenz Der Persistence Manager ist ein Toplevelmodul und kann mit dem Befehl Toplevelinstanz hinzufügen zum Modulbaum hinzugefügt werden. Unterhalb des Persistence Managers können bis zu 64 Kanäle definiert werden. In den Kanälen können Persistenzgruppen definiert und ihr Speicherverhalten über Parameter festgelegt werden. Jeder Kanal muss ein Submodul Data Storage definieren. Hier definiert man das Format, in dem die persistenten Daten in einer Datei gespeichert werden. Diese Archivdatei wird extern abgelegt, standardmäßig im Installationsverzeichnis der Steuerung. Für Laufzeitsystemversionen >= 3.5.8.0 ist der Ablageort für Archivdateien über den Platzhalter $ac_persistence$ definiert. Bereits bestehende Archive werden an diesen Ort verschoben, wenn sie in dem über Platzhalter $PLCLogic$ definierten Verzeichnis gefunden werden. Dieses Verzeichnis war der Standardablageort in früheren Laufzeitsystemversionen. Für Archive, die an beiden Orten liegen, wird eine Warnung in das Log des Laufzeitsystems ausgegeben. Es kann nur 1 Persistence Manager pro Applikation zum Modulbaum hinzugefügt werden. Wenn der Persistence Manager zum POUs -Pool hinzugefügt oder mehr als 1 Persistence Manager zur Applikation hinzugefügt wird, wird eine Fehlermeldung ausgeben. Persistence Manager im Modulbaum Falls der Modulbaum oder Parameter von Modulinstanzen geändert wurden, muss ein neuer Generierungslauf ausgeführt werden. (Befehl Erzeugen) Unterschiede zum Mechanismus „VAR PERSISTENT“ Die persistenten Daten werden in einer externen Datei gespeichert. Die persistenten Daten können zwischen Projekten ausgetauscht werden. Persistente Variablen können aus der Applikation gelöscht, oder neue hinzugefügt werden, ohne dass die persistenten Werte verloren gehen. Daten, welche durch den Persistence Manager erzeugt wurden, können mit externen Editoren verändert werden. (beispielsweise mit Notepad). Siehe auch: Persistenz " }, 
{ "title" : "Persistence Manager-Modul ", 
"url" : "ac_pm_persistencemanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Persistence Manager-Modul ", 
"snippet" : "Durch einen Doppelklick auf den Persistence Manager Knoten im Modulbaum oder über Objekt bearbeiten öffnet sich der entsprechenden Editor. Neben dem Standardeditor der Toplevelmodule (siehe Überblick ) stellt der Persistence Manager die Registerkarte Persistenz zur Verfügung. HMI Der Persistence Man...", 
"body" : "Durch einen Doppelklick auf den Persistence Manager Knoten im Modulbaum oder über Objekt bearbeiten öffnet sich der entsprechenden Editor. Neben dem Standardeditor der Toplevelmodule (siehe Überblick ) stellt der Persistence Manager die Registerkarte Persistenz zur Verfügung. HMI Der Persistence Manager stellt eine Visualisierungsvorlage zur Verfügung ( VISU_PersistenceManager ), welche in die Gesamtvisualisierung eingebunden werden kann. Dialog für HMI-Einstellungen Diese Visualisierung stellt statistische Informationen über das Lesen und Speichern der Variablen zur Verfügung: Visualisierungsbild für persistente Daten " }, 
{ "title" : "Persistenz ", 
"url" : "ac_pm_persistencemanager_module.html#UUID-87fcb435-c65b-2e65-6037-f61974f5b1d7_e4fa0ddccaa0cf0c0a8640e01493625_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Persistence Manager-Modul \/ Persistenz ", 
"snippet" : "Dialog Persistenz In dem Dialog Persistenz können eine oder mehrere Gruppen von der Speicherung ausgeschlossen werden. Um eine neue Gruppe anzulegen, muss ein eindeutiger Name eingegeben und mit Hinzufügen hinzugefügt werden. Mit dem Befehl Entfernen können bestehende Gruppen gelöscht werden. Variab...", 
"body" : "Dialog Persistenz In dem Dialog Persistenz können eine oder mehrere Gruppen von der Speicherung ausgeschlossen werden. Um eine neue Gruppe anzulegen, muss ein eindeutiger Name eingegeben und mit Hinzufügen hinzugefügt werden. Mit dem Befehl Entfernen können bestehende Gruppen gelöscht werden. Variablen können über das Attribut ac_persist_exclude von der Speicherung ausgeschlossen werden. Für weitere Informationen siehe: Attribut ‚ac_persist_exclude‘ " }, 
{ "title" : "Persistenzkanal ", 
"url" : "ac_pm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Persistenzkanal ", 
"snippet" : "In einem Persistenzkanal werden die Speicherungseinstellungen für eine oder mehrere Gruppen von persistenten Variablen festgelegt. Er kann durch den Befehl Submodulinstanz hinzufügen einem Persistence Manager-Knoten hinzugefügt werden. Unterhalb des Persistence Managers können bis zu 64 Kanäle erzeu...", 
"body" : "In einem Persistenzkanal werden die Speicherungseinstellungen für eine oder mehrere Gruppen von persistenten Variablen festgelegt. Er kann durch den Befehl Submodulinstanz hinzufügen einem Persistence Manager-Knoten hinzugefügt werden. Unterhalb des Persistence Managers können bis zu 64 Kanäle erzeugt werden. HMI, Information Eine detaillierte Beschreibung zu diesen Dialogen finden Sie unter E\/A, HMI und Information . " }, 
{ "title" : "Persistenz ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Persistenzkanal \/ Persistenz ", 
"snippet" : "Persistenzgruppen In diesem Dialog können eine oder mehrere Gruppen festgelegt werden, welche durch diesen Kanal verwaltet werden. Standardmäßig ist der Instanzname des Kanalmoduls in der Liste verfügbar. Um eine neue Gruppe zu erzeugen, muss ein eindeutiger Name eingegeben und mit dem Befehl Hinzuf...", 
"body" : "Persistenzgruppen In diesem Dialog können eine oder mehrere Gruppen festgelegt werden, welche durch diesen Kanal verwaltet werden. Standardmäßig ist der Instanzname des Kanalmoduls in der Liste verfügbar. Um eine neue Gruppe zu erzeugen, muss ein eindeutiger Name eingegeben und mit dem Befehl Hinzufügen hinzugefügt werden. Mit Entfernen werden selektierte Gruppen gelöscht. Variablen können über das Attribut ac_persist den Gruppen zugewiesen werden. Für weitere Informationen siehe: Definition persistenter Variablen, Attribut 'ac.persist' Persistente Variablen : Diese Liste zeigt alle persistenten Variablen, welche einer der oben gelisteten Persistenzgruppen zugewiesen sind. " }, 
{ "title" : "Parameter ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Persistenzkanal \/ Parameter ", 
"snippet" : "Die Registerkarte Parameter stellt eine Liste von Optionen zur Speicherung der Variable zur Verfügung. Parameter der persistenten Kanäle tPeriodicSaving : Nach Ablauf dieses Zeitintervalls werden die Variablen gespeichert. Ein Wert gleich t#0s schaltet diesen Mechanismus aus. xSaveOnChange : Wenn ak...", 
"body" : "Die Registerkarte Parameter stellt eine Liste von Optionen zur Speicherung der Variable zur Verfügung. Parameter der persistenten Kanäle tPeriodicSaving : Nach Ablauf dieses Zeitintervalls werden die Variablen gespeichert. Ein Wert gleich t#0s schaltet diesen Mechanismus aus. xSaveOnChange : Wenn aktiviert, wird permanent ein Vergleich der aktuellen Werte mit den zuletzt gespeicherten durchgeführt und bei Änderung, ein Speichern ausgelöst. Persistenzkanäle, die xSaveOnChange=FALSE gesetzt haben, werden beim Herunterfahren der Steuerung sowie bei einem Reset (Warm, Kalt, Origin) gespeichert. Außerdem kannein periodisches Speichern stattfinden. xReadVarsDuringInit : Wenn auf TRUE gesetzt, werden die persistenten Variablen schon während der Initialisierungsphase geladen. Andernfalls werden sie im ersten Applikationszyklus geladen. xCompressTags : Wenn auf TRUE gesetzt, wird der Instanzpfad der Variablen in komprimierter Form gespeichert. Für weitere Informationen siehe: Speicherformat, Komprimierte Archive . xConsistentCopyInHighPrioTask : Wenn diese Option TRUE ist, wird eine Kopie der Variablen in der Task höchster Priorität erzeugt, die dann in der Task niedriger Priorität gespeichert wird. Diese Option sollte gewählt werden um eine Inkonsistenz der Daten zu vermeiden, wenn Variablen in einer hochprioren Task verändert werden. xConvertVarsWithDifferentType : Wenn der Parameter TRUE ist und der Typ der eingelesenen Variablen mit dem Typ der tatsächlichen nicht übereinstimmt, versucht der Persistenzkanal den eingelesenen Wert in den tatsächlichen Typ zu konvertieren. Gelingt dies, wird der Wert akzeptiert; wenn nicht, wird er verworfen. Diese Funktion unterstützt die folgenden Konvertierungen: Datentyp im Archiv aktueller Datentyp Beschreibung alle Integer alle Integer wenn der Wert in den Wertebereich des aktuellen Datentyps passt alle Integer Real alle Integer LReal alle Datentypen String Real LReal Real ANY_INT wenn der Archivwert ein Integer mit passendem Wertebereich ist LReal Real wenn der Wert im Datenbereich eines REAL ist LReal ANY_INT wenn der Archivwert ein Integer mit passendem Wertebereich ist xIntegrityCheckBeforeReading : Wenn der Parameter TRUE ist, wird die Integrität der Datenbank geprüft und beim Schließen des Archivs ein Integritätsobjekt mit abgespeichert. xSeparateArchivePerToplevelInstance : Wenn der Parameter TRUE ist, wird für jede Toplevel-Instanz ein eigenes Archiv erzeugt. Der Name des Archivs bildet sich aus dem im DataStorage konfigurierten Archivnamen und dem Namen der Toplevel-Modulinstanz: <Archivname>_<InstanzName> oder als <Archivname> für alle Instanzen, die nicht unter einer Toplevelmodulinstanz hängen (beispielsweise Applikationsvariablen). Standardmäßig ist diese Option deaktiviert. Wenn Sie den Parameter nachträglich verändern ( TRUE <-> FALSE ), ändert sich der Archivname und persistente Variablen können verloren gehen! xMakeDataCRCConsistencyCheck : Wenn der Parameter TRUE ist, wird ein CRC-Wert zu Beginn und am Ende des Speichervorgangs berechnet. Um den Speichervorgang erfolgreich abschließen zu können, müssen diese beiden Werte gleich sein. uiSavingRetriesIfCRCConsistencyCheckFails : Gibt der Anzahl der Wiederholung der Speicherung an, wenn xMakeDataCRCConsistencyCheck auf TRUE gesetzt und die CRC-Werte nicht übereinstimmen. xLogSaveTimeEnabled : Wenn der Parameter TRUE ist, wird die zum Schreiben benötigte Zeit geloggt. eAutomaticActionOnlineChange : Verhalten, ob und wie die Werte von Variablen bei einem Online-Change gespeichert werden. None : Keine Speicherung Save : Die Werte werden gespeichert. Somit werden auch Änderungen an der Konfiguration mit in den Persistenzspeicher übernommen (beispielsweise das Hinzufügen oder Umbenennen von Variablen). Load : Die Werte werden aus dem Persistenzspeicher geladen. Damit werden eventuelle Initialisierungen (beispielsweise durch FB_INIT , IModule.Init und Modul-Parameter) durch die persistierten Werte überschrieben. LoadAndSave : Die Werte werden sowohl aus dem Persistenzspeicher geladen als auch geschrieben. eAutomaticActionPlcStop : Festlegung, ob die Werte von Variablen bei einem Reset gespeichert werden. None : Keine Speicherung Save : Die Werte werden gespeichert " }, 
{ "title" : "Modul: Datenspeicher ", 
"url" : "ac_pm_storage_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Modul: Datenspeicher ", 
"snippet" : "Datenspeicher Das Submodul Data Storage definiert das Speicherformat eines Persistenzkanals . Drei Speicherformate stehen zur Auswahl: ASCIIFileStorage : Speichern der Werte im ASCII-Format in eine Datei. Das Format ASCIIFileStorage erlaubt ein Öffnen der Datei im Texteditor sowie ein Verändern der ...", 
"body" : "Datenspeicher Das Submodul Data Storage definiert das Speicherformat eines Persistenzkanals . Drei Speicherformate stehen zur Auswahl: ASCIIFileStorage : Speichern der Werte im ASCII-Format in eine Datei. Das Format ASCIIFileStorage erlaubt ein Öffnen der Datei im Texteditor sowie ein Verändern der Werte. Es können Kommentare in die ASCII-Archivdatei geschrieben werden. Diese werden bei Einlesen der Datei ignoriert. BinaryFileStorage : Speichern der Werte im Binärformat in eine Datei. BinaryMemoryStorage : Speichern der Werte im Binärformat im „RETAIN“-Bereich des Compiler, bzw. des entsprechenden Geräts (also beispielsweise im NVRAM eines solchen Geräts). PersistentBinaryMemoryStorage : Speichern der Werte im Binärformat im „Persistent“-Bereich des Compilers, oder des entsprechenden Geräts (also beispielsweise im NVRAM eines solchen Geräts). Fügen Sie unterhalb eines Persistenzkanals ein Data Storage -Modul des gewünschten Formats ein. Wenn nötig, verändern Sie die Konfiguration auf der Registerkarte Parameter : Dialog: Information Detaillierte Informationen zu diesem Dialog finden Sie unter Information . " }, 
{ "title" : "Dialog: Parameter ", 
"url" : "ac_pm_storage_module.html#UUID-1d4190f0-4f49-535e-fe96-bf340f625ee5_aa44ae4cccad1068c0a8640e019d97f0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Modul: Datenspeicher \/ Dialog: Parameter ", 
"snippet" : "sArchiveName Name der Archivdatei Standardmäßig ist der Platzhalter %CHANNEL_NAME% definiert. Dieser Platzhalter wird durch den Instanznamen des übergeordneten Persistenzkanals ersetzt. Der Archivname muss eindeutig sein, da alle Archivdateien im gleichen Verzeichnis abgelegt werden. Hinweis: Der st...", 
"body" : "sArchiveName Name der Archivdatei Standardmäßig ist der Platzhalter %CHANNEL_NAME% definiert. Dieser Platzhalter wird durch den Instanznamen des übergeordneten Persistenzkanals ersetzt. Der Archivname muss eindeutig sein, da alle Archivdateien im gleichen Verzeichnis abgelegt werden. Hinweis: Der standardmäßige Ablageort für die Archivdateien hängt von der Laufzeitsystemversion ab. Siehe: Persistence Manager Überblick xDoubleStorage Wenn aktiviert ( TRUE ), werden die Variablen abwechselnd in zwei verschiedene Archive ( sArchive1 , sArchive2 ) gespeichert. Im Falle eines beschädigten Archives (beispielsweise durch Abschalten der Steuerung während des Speicherns der Variablen) wird die Backup-Datei verwendet. Beim Öffnen untersucht der Persistence Manager den Zeitstempel beider Archive und verwendet, sofern keine Fehler damit auftreten, das neuere Archiv. Wenn dieses jedoch fehlerhaft ist, verwendet er das ältere. udiMaximumFileSize Die maximale Größe der Datei in Bytes Wenn 0 definiert wird, wird keine Grenze gesetzt oder überprüft, so dass die Datei beliebig groß werden kann. bySeparator ASCII-Wert des Trennzeichens zwischen Variablenname und Wert udiMemDataSize Größe des Speichers im „RETAIN“-Variablen-Bereich, der für das Modul angelegt wird Der Wert wird mit der Datengröße der zu speichernden Daten verglichen. Ist der Wert definitiv zu klein, wird ein Compilerfehler ausgegeben. Ist der Wert möglicherweise zu klein, wird ein Warnhinweis im Meldungsfenster ausgegeben. LineEnding Zeichen, das das Zeilenende in der Datei angibt " }, 
{ "title" : "Definition persistenter Variablen ", 
"url" : "ac_pm_definition_persistent_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Definition persistenter Variablen ", 
"snippet" : "Einzelne Variablen sowie Strukturinstanzen und Instanzen von Funktionsbausteinen können über Attribute als \"persistent“ gekennzeichnet werden. Bei Kennzeichnung einer Instanz werden alle Mitglieder von VAR , VAR_INPUT und VAR_OUTPUT persistent gespeichert. Wenn Variablen in einem VAR PERSISTENT -Abs...", 
"body" : "Einzelne Variablen sowie Strukturinstanzen und Instanzen von Funktionsbausteinen können über Attribute als \"persistent“ gekennzeichnet werden. Bei Kennzeichnung einer Instanz werden alle Mitglieder von VAR , VAR_INPUT und VAR_OUTPUT persistent gespeichert. Wenn Variablen in einem VAR PERSISTENT -Abschnitt mit einem Attribut als \"persistent“ gekennzeichnet werden, wird eine Warnung ausgegeben. Außerdem gibt es Attribute zur Definition einer Default-Speichergruppe, sowie zum gezielten Ausschließen von Variablen aus der persistenten Speicherung von Strukturen oder Funktionsbaustein-Instanzen. Wenn die Deklarationen persistenter Variablen geändert wurden (Hinzufügen, Löschen, Umbenennen, anderer Datentyp), muss kein erneuter Composer Generierungslauf (Befehl Erzeugen) ausgeführt werden. Diese Änderungen werden in der Persistence Manager Instanz während des Übersetzens automatisch aktualisiert. Zu den möglichen impliziten Konvertierungen im Falle einer Datentypänderung siehe: Parameter Attribut: 'ac_persist_exclude' Das Attribut 'ac_persist_exclude' wird verwendet, um eine Variable von der persistenten Speicherung auszuschließen, unabhängig davon ob in der Struktur- oder FB-Deklaration Members als persistent gekennzeichnet sind. Falls die Deklaration der Instanz keine persistenten Member enthält (direkt oder indirekt), wird bei der Generierung eine Warnung ausgegeben, dass das Attribut keine Auswirkung hat. Beispiel für den Ausschluss von Variablen PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_exclude'}\n fb1 : FB;\nEND_VAR " }, 
{ "title" : "Unterstützte Datentypen ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_beff9eaed151b190c0a8640e01016617", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Definition persistenter Variablen \/ Unterstützte Datentypen ", 
"snippet" : "Instanzen der folgenden Datentypen können nicht persistent gespeichert werden: BIT Pointer Interfaces Konstanten Arrays von nicht persistent gespeicherten Datentypen Alle übrigen Datentypen werden unterstützt. Das schließt z.B. Enumerationen, Unterbereichstypen, Arrays von Arrays und mehrdimensional...", 
"body" : "Instanzen der folgenden Datentypen können nicht persistent gespeichert werden: BIT Pointer Interfaces Konstanten Arrays von nicht persistent gespeicherten Datentypen Alle übrigen Datentypen werden unterstützt. Das schließt z.B. Enumerationen, Unterbereichstypen, Arrays von Arrays und mehrdimensionale Arrays mit ein: ARRAY[0..9] OF ARRAY[5..6, 7..8, 9..10] OF INT Datentyp UNION Damit die Instanz einer Union persistent gespeichert wird, muss zunächst eines ihrer Felder speziell als sogenannter „Repräsentant“ markiert werden. Dafür gibt es folgende drei Möglichkeiten: Genau ein Feld in der Deklaration der Union ist mit dem Attribut ac_persist_union_representant gekennzeichnet (ohne Attributwert). Dieses Feld \"repräsentiert“ die Union. Sein Wert wird stellvertretend für die gesamte Union gespeichert und wieder eingelesen. Genau ein Feld der Union ist mit einem ac_persist Attribut gekennzeichnet, dies bestimmt gleichzeitig den Repräsentanten. Die Instanz der Union ist mit dem Attribut ac_persist_union_set_representant gekennzeichnet, mit Attributwert. Der Attributwert ist der Name des Union-Felds, das als Repräsentant verwendet werden soll. Dieses Attribut überschreibt ein eventuell vorhandenes ac_persist_union_representant Attribut in der Deklaration der Union.Arrays von Union können auch gekennzeichnet werden. In diesem Fall wirkt das Attribut auf den Basistyp. Beispiele 'ac_persist_union_representant' TYPE UnionWithRep :\nUNION\n di : DINT ;\n {attribute 'ac_persist_union_representant'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 'ac_persist' TYPE UnionWithPersist :\nUNION\n di : DINT ;\n {attribute 'ac_persist' := 'TestUnion'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 'ac_persist_union_set_representant‘ FUNCTION_BLOCK FBTestUnion\nVAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n u2 : UnionWithoutRep ;\nEND_VAR Array of union VAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aElems ARRAY[0..7] OF SomeUnion ;\n\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aaElems ARRAY[0..7] OF ARRAY[0..1] OF SomeUnion ;\nEND_VAR Damit ein Repräsentant gültig ist, muss er folgende Regeln erfüllen: Der Repräsentant muss dieselbe Größe wie die gesamte Union haben. Ansonsten würden nicht die kompletten Daten gespeichert. Der Repräsentant darf auch keine Padding-Bereiche enthalten, also leere Datenbereiche, die vom Compiler eingefügt werden um die korrekte Ausrichtung der Daten im Speicher zu erreichen. Die Zerlegung des Repräsentanten in primitive Datentypen darf keine Instanz vom Typ REAL oder LREAL oder Instanzen vom Typ STRING oder WSTRING haben. Der Repräsentant muss einen unterstützten Datentyp haben (siehe oben). Der Repräsentant kann beispielsweise vom Typ Structure sein - die Struktur selber jedoch darf keine Pointer-Typen enthalten. " }, 
{ "title" : "Attribut: 'ac_persist' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_e844aaa8d151b192c0a8640e01722fe3", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Definition persistenter Variablen \/ Attribut: 'ac_persist' ", 
"snippet" : "Das Attribut ‚ ac_persist ‚ kann verwendet werden für Variablen Instanzen von Strukturen Instanzen von Funktionsbausteinen Mitglieder von Strukturen Mitglieder von Funktionsbausteinen {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP ist der Name der Persistenzgruppe , der die D...", 
"body" : "Das Attribut ‚ ac_persist ‚ kann verwendet werden für Variablen Instanzen von Strukturen Instanzen von Funktionsbausteinen Mitglieder von Strukturen Mitglieder von Funktionsbausteinen {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP ist der Name der Persistenzgruppe , der die Deklaration zugeordnet werden soll. Es muss ein gültiger IEC-Bezeichner sein. Wenn die Gruppenangabe weggelassen wird, dann erfolgt die Gruppenzuordnung über das Attribut 'ac_persist_set_default_group' , das in diesem Fall definiert sein muss. Wenn eine Struktur- oder FB-Instanz als persistent gekennzeichnet ist, dann wird ein Fehler bei der Generierung erzeugt, falls (mindestens) ein Member in der Deklaration der Instanz (oder einer dort verwendeten Deklaration) zusätzlich als persistent gekennzeichnet ist. Beispiel für persistente Instanzen Die Variable t wird der Persistenzgruppe PROCESS zugewiesen. Alle Member werden persistent gespeichert. PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist' := 'PROCESS'}\n t : TON;\nEND_VAR Beispiel für persistente Member eines Funkionsbausteins Das Member iNumIOs wird der Persistenzgruppe CONFIG zugewiesen. Dieses Member wird für alle Instanzen des FBs persistent gespeichert (sofern nicht unterdrückt durch das Attribut 'ac_persist_exclude' ). FUNCTION_BLOCK FB\nVAR\n {attribute 'ac_persist' := 'CONFIG'}\n iNumIOs : INT := 0;\nEND_VAR " }, 
{ "title" : "Attribut: 'ac_persist_set_default_group' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_4130a661d151b192c0a8640e00b1a163", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Definition persistenter Variablen \/ Attribut: 'ac_persist_set_default_group' ", 
"snippet" : "Wenn beim Attribut 'ac_persist' die Gruppenangabe weggelassen wird, muss bei einer FB- oder Struktur-Instanz, die die jeweilige Variable direkt oder indirekt enthält, eine Default-Gruppe gesetzt werden. Dies ist möglich durch das Attribut 'ac_persist_set_default_group' . Das Attribut kann auch für e...", 
"body" : "Wenn beim Attribut 'ac_persist' die Gruppenangabe weggelassen wird, muss bei einer FB- oder Struktur-Instanz, die die jeweilige Variable direkt oder indirekt enthält, eine Default-Gruppe gesetzt werden. Dies ist möglich durch das Attribut 'ac_persist_set_default_group' . Das Attribut kann auch für ein Member eines Funktionsbausteins gesetzt sein. Die innerste gefundene Definition von 'ac_persist_set_default_group' wird als Default-Gruppe für die Variable verwendet. Das Attribut 'ac_persist_set_default_group' darf für eine Variable nicht gleichzeitig mit 'ac_persist' oder 'ac_persist_exclude' verwendet werden. Sollte dies der Fall sein, wird während des Übersetzens eine Fehlermeldung ausgegeben. Beispiel für eine Default-Gruppe FUNCTION_BLOCK FB_Util\nVAR\n {attribute 'ac_persist'} \/\/ no group\n \/\/'ac_persist_set_default_group‘ and 'ac_persist_exclude' not allowed here\n i : INT := 0;\nEND_VAR PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_set_default_group' := 'PROCESS'}\n fbu1 : FB_Util;\n\n {attribute 'ac_persist_set_default_group'´ := 'CONFIG'}\n fbu2 : FB_Util;\nEND_VAR " }, 
{ "title" : "Datenspeicherung ", 
"url" : "ac_pm_data_storage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Datenspeicherung ", 
"snippet" : "Die Speicherung persistenter Variablen kann auf unterschiedliche Weise ausgelöst werden: Jeder Persistenzkanas stellt eine Schnittstelle zur Applikation zur Verfügung, mit welcher die Anwendung eine Speicherung triggern kann (siehe Zugriff auf Daten ). In den Parametern des Persistenzkanals kann ein...", 
"body" : "Die Speicherung persistenter Variablen kann auf unterschiedliche Weise ausgelöst werden: Jeder Persistenzkanas stellt eine Schnittstelle zur Applikation zur Verfügung, mit welcher die Anwendung eine Speicherung triggern kann (siehe Zugriff auf Daten ). In den Parametern des Persistenzkanals kann ein Zeitintervall ( tPeriodicSaving ) für die automatische Speicherung definiert werden. Der Persistenzkanal kann so konfiguriert werden, dass bei jeder Wertänderung der Variablen eine Speicherung ausgelöst wird. Dazu werden die vorangegangenen und die Istwerte verglichen; wenn sie sich unterscheiden, wird die Speicherung getriggert. Die drei Speichervarianten können parallel betrieben werden. Beim Herunterfahren der Steuerung sowie bei einem Reset (Warm, Kalt, Ursprung) werden die Persistenzkanäle gespeichert, die nicht xSaveOnChange gesetzt haben. Für weitere Informationen siehe auch: Modul Datenspeicher " }, 
{ "title" : "Speicherformat ", 
"url" : "ac_pm_storage_format.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Speicherformat ", 
"snippet" : "Es stehen zwei Implementierungen der Schnittstelle IDataStorage zur Verfügung: ASCIIDataStorage und BinaryDataStorage . Für beide Formate gilt: Die erste Variable die gespeichert wird, ist die reservierte Variable ___xCompressTags vom Typ BOOL . Ihr Wert gibt an, ob die Instanzpfade komprimiert gesp...", 
"body" : "Es stehen zwei Implementierungen der Schnittstelle IDataStorage zur Verfügung: ASCIIDataStorage und BinaryDataStorage . Für beide Formate gilt: Die erste Variable die gespeichert wird, ist die reservierte Variable ___xCompressTags vom Typ BOOL . Ihr Wert gibt an, ob die Instanzpfade komprimiert gespeichert werden. Falls ein Integritätsobjekt geschrieben wird, dann wird es als letzte Variable mit Namen ___Integrity vom Typ BOOL mit Wert TRUE geschrieben.Alle persistenten Variablen außer diesen reservierten Variablen werden in der Reihenfolge nach Ihrem vollen Instanzpfad sortiert gespeichert. Dabei ist es egal ob die Instanzpfade komprimiert werden oder nicht. Falls die Daten durch den Anwender verändert werden, muss dieser sicherstellen, dass die Sortierreihenfolge beibehalten wird. Komprimierte Archive Die Variablenwerte werden jeweils mit Pfad und Namen (im Pfad sind weder Applikation noch Gerätenamen enthalten) abgelegt, allerdings in einer kompakten Schreibweise, um Ressourcen und Zeit zu sparen. Die Instanzpfade müssen in jedem Fall (ob gepackt oder nicht) korrekt nach dem vollen Instanzpfad sortiert sein. Die Sortierung ist alphabetisch, wobei aber Array-Indizes numerisch sortiert werden. Beispiele Objekte Verkürzte Repräsentation Fb1.fb2.fb3.a Fb1.fb2.fb3.a Fb1.fb2.fb3.b <b Fb1.fb2.d <<d Fb4 FB4 " }, 
{ "title" : "ASCII-Format ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_7b30973fd16738e7c0a8640e01455e29", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Speicherformat \/ ASCII-Format ", 
"snippet" : "ASCIIDataStorage schreibt jeweils den Instanzpfad der persistenten Variablen (möglicherweise gepackt), den Typ und den Wert als String in eine Datei. Dabei trennt ein Tabulatorzeichen den Namen und das restliche Datum (änderbar durch Parameter codbySeparator ). Beim Lesen wird eine Konvertierung dur...", 
"body" : "ASCIIDataStorage schreibt jeweils den Instanzpfad der persistenten Variablen (möglicherweise gepackt), den Typ und den Wert als String in eine Datei. Dabei trennt ein Tabulatorzeichen den Namen und das restliche Datum (änderbar durch Parameter codbySeparator ). Beim Lesen wird eine Konvertierung durchgeführt. Deshalb kann die Datei auch extern editiert werden. Zeilen müssen mit \"\\r\\n“ getrennt werden (Windows-Konvention). Zeilen die mit einem Strichpunkt beginnen, werden beim Einlesen ignoriert und beim erneuten Speichern nicht wieder eingefügt. Format einer ASCII-Datei: {timestamp}\\r\\n\n{instance path}{bySeparator}{Typ}:{value}\\r\\n\n…\n{instance path}{bySeparator}{Typ}:{value}\\r\\n Der Zeitstempel gibt den Zeitpunkt an, zu dem das Speichern angestoßen wurde. Er wird als DATE_AND_TIME - Literal geschrieben (beispielsweise. DT#2012-01-11-15:11:09 ). Beispiel einer ASCII-Datei Behandlung von REAL und LREAL -Variablen: Die Werte der Variablen werden als ST-Literale geschrieben. REAL - und LREAL -Werte werden gesondert behandelt, da die Konvertierung in Dezimalbrüche und von Dezimalbrüchen nur schwierig verlustfrei zu implementieren ist. Um dennoch einen Genauigkeitsverlust zu vermeiden und gleichzeitig die Lesbarkeit und Änderbarkeit der ASCII-Datei zu bewahren, werden sie in einem Hexadezimal-Format gespeichert, das leicht ohne Genauigkeitsverlust berechnet werden kann. Der (ungenaue) Dezimalbruch wird als Kommentar dahinter ausgegeben. Beim Einlesen werden sowohl das Hexadezimalformat als auch das ST-Dezimalformat unterstützt, so dass ein Anwender den Wert einfach auf einen neuen Dezimalbruch ändern kann. Beim Einlesen wird alles ignoriert, was hinter dem Hexadezimalformat steht. Das Hexadezimalformat ist wie folgt definiert: F16#{Mantissa}H{Exp} | F16#NaN | F16#+Inf | F16#-Inf\n{Mantissa} ::= {HexNumeral}\n{Exp} ::= {HexNumeral}\n{HexNumeral} ::= [+-]?[1-9A-F][0-9A-F]* Wenn m die durch die Mantisse dargestellte Zahl und e die durch den Exponenten dargestellte Zahl ist, dann ist der Wert der gesamten dargestellten Zahl m * 16^e . Beispiel eines gespeicherten REAL-Wertes lr1 LREAL:F16#F0H-3 0.05859375 " }, 
{ "title" : "Binärformat ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_602fd614d22a5f95c0a8640e0110d837", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Speicherformat \/ Binärformat ", 
"snippet" : "BinaryDataStorage speichert die Daten im Binärformat ab. Darauf folgt ein Zeitstempel (Typ DATE_AND_TIME ). Es folgen die einzelnen Variablen....", 
"body" : "BinaryDataStorage speichert die Daten im Binärformat ab. Darauf folgt ein Zeitstempel (Typ DATE_AND_TIME ). Es folgen die einzelnen Variablen. " }, 
{ "title" : "Zugriff auf Daten ", 
"url" : "ac_pm_data_access.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Zugriff auf Daten ", 
"snippet" : "Der Persistence Manager ist ein Toplevelmodul und verfügt über 1 bis 10 Untermodulinstanzen vom Typ Persistenzkanal. Jeder Persistenzkanal hat eine Untermodulinstanz vom Typ DataStorage , die für den Datenzugriff zuständig ist. Sie folgt dem Interface IDataStorage :...", 
"body" : "Der Persistence Manager ist ein Toplevelmodul und verfügt über 1 bis 10 Untermodulinstanzen vom Typ Persistenzkanal. Jeder Persistenzkanal hat eine Untermodulinstanz vom Typ DataStorage , die für den Datenzugriff zuständig ist. Sie folgt dem Interface IDataStorage : " }, 
{ "title" : "Diagnose ", 
"url" : "ac_pm_diagnosis.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Diagnose ", 
"snippet" : "Jeder Persistenzkanal verfügt über eine Schnittstelle, über welche Diagnosedaten bereitgestellt werden (Interface IDataStorage ). Über folgende Ausgänge wird Diagnose-Information ausgegeben: Ausgang Datentyp Beschreibung xActionOngoing BOOL TRUE , wenn der Persistence Manager Daten liest oder schrei...", 
"body" : "Jeder Persistenzkanal verfügt über eine Schnittstelle, über welche Diagnosedaten bereitgestellt werden (Interface IDataStorage ). Über folgende Ausgänge wird Diagnose-Information ausgegeben: Ausgang Datentyp Beschreibung xActionOngoing BOOL TRUE , wenn der Persistence Manager Daten liest oder schreibt udiDataMemSize UDINT Größe der Persistenzdaten in Bytes xReadingDone BOOL Einlesen der Persistenzdaten abgeschlossen dtLastReading DT Datum und Zeit des letzten Einlesens uiNumberVarsNotOk UINT Anzahl der Variablen, die nicht gefunden oder konvertiert werden konnten uiNumberVarsOk UINT Anzahl der Variablen, die korrekt eingelesen wurden tTimeForReading TIME Zeitdauer der Einlese-Aktion dtLastSaving DT Datum und Zeit des letzten Speicherns tTimeForWriting TIME Zeitdauer der Schreibe-Aktion uiWritingCycles UINT Anzahl der Speicherungen seit Applikationsstart Die Information, ob und wie viele der erwarteten Variablenwerte erfolgreich gelesen wurden oder ob das Speichern erfolgreich war, wird auch über die SPS-Logger-Schnittstelle ausgegeben. SPS Logging " }, 
{ "title" : "Fehlerbehandlung ", 
"url" : "ac_pm_error_handling.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Persistence Manager \/ Fehlerbehandlung ", 
"snippet" : "Fehlernummern und zugehörige Strings werden über die Standard-Modul-Schnittstellen ( ClearErrors , FirstErrorNumber , GetFirstErrorMessage , LastErrorNumber , GetLastErrorMessage ) abgerufen oder quittiert. Fehlernummer Beschreibung 100 Persistenzdatenliste hat sich zur Laufzeit geändert und passt n...", 
"body" : "Fehlernummern und zugehörige Strings werden über die Standard-Modul-Schnittstellen ( ClearErrors , FirstErrorNumber , GetFirstErrorMessage , LastErrorNumber , GetLastErrorMessage ) abgerufen oder quittiert. Fehlernummer Beschreibung 100 Persistenzdatenliste hat sich zur Laufzeit geändert und passt nicht mehr zur initial ermittelten Größe 110 Speicher (für Vergleich oder konsistente Kopie) konnte nicht angelegt werden. <ErrorCode SysMemAllocData> . Feature wird abgeschaltet 120 Datenspeicher für die Vergleichsspeicherung nicht angelegt. Feature wird abgeschaltet. 130 Datenspeicher für die konsistente Kopie nicht angelegt 140 Persistenzvariable vom Typ String hat ungültige Größe: <Name der Variablen> 150 Persistenzvariable hat nicht unterstützten Datentyp: <Name der Variablen> 160 Datenbank konnte nicht geöffnet werden. Lesevorgang abgebrochen: <Detailfehler-Beschreibung des Datenbank-Objekts> 170 Datenbank konnte nicht geschlossen werden: <Detailfehler-Beschreibung des Datenbank-Objekts> 190 Datenbank konnte nicht angelegt werden. Speichervorgang wird abgebrochen. <Detailfehler-Beschreibung des Datenbank-Objekts> 200 Datenbank konnte nicht geöffnet werden. Speichervorgang wird abgebrochen. <Detailfehler-Beschreibung des Datenbank-Objekts> 210 Datenbank konnte nicht geschlossen werden. <Detailfehler-Beschreibung des Datenbank-Objekts> 220 Fehler beim Schreiben eines Eintrags: <Detailfehler-Beschreibung des Datenbank-Objekts> 230 Fehler beim Auslesen der Systemzeit " }, 
{ "title" : "DataLog Manager ", 
"url" : "ac_dlm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ DataLog Manager ", 
"snippet" : "Der DataLog Manager ist eine Standardkomponente des Application Composers. Er dient dem zyklischen Speichern von Variablenwerten in eine Datei. Diese Variablen sind in der Variablendeklaration mit speziellen Attributen gekennzeichnet. Sie müssen die Bibliothek AC_DataLog zum Bibliotheksverwalter hin...", 
"body" : "Der DataLog Manager ist eine Standardkomponente des Application Composers. Er dient dem zyklischen Speichern von Variablenwerten in eine Datei. Diese Variablen sind in der Variablendeklaration mit speziellen Attributen gekennzeichnet. Sie müssen die Bibliothek AC_DataLog zum Bibliotheksverwalter hinzufügen, damit das Modul verfügbar ist. Es kann nur ein DataLog Manager pro Applikation zum Modulbaum hinzugefügt werden. Der DataLog Manager ist ein Toplevel-Modul und kann mit dem Befehl Toplevelinstanz hinzufügen zum Modulbaum hinzugefügt werden. Unterhalb des DataLog Managers können bis zu 64 Kanäle definiert werden. In den Kanälen können Gruppen definiert und ihr Speicherverhalten über Parameter festgelegt werden. Jeder Kanal muss ein Modul Datalog-Speicher enthalten. DataLog Manager zum Modulbaum hinzufügen Wenn der Modulbaum oder Parameter von Modulinstanzen geändert wurden, muss ein neuer Generierungslauf ausgeführt werden. (Befehl Erzeugen ). Zu diesem Zweck muss der DataLog-Generator in der Generatorkonfiguration aktiviert sein. " }, 
{ "title" : "Modul: DataLog-Manager ", 
"url" : "ac_dlm_datalogmanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ DataLog Manager \/ Modul: DataLog-Manager ", 
"snippet" : "DataLog-Manager Der DataLog Manager verwaltet das Datenlogging von Variablen. Er kann unterhalb des obersten Objekt im Modulbaum hinzugefügt werden. Dies erfolgt durch den Befehl Toplevelinstanz hinzufügen und der Auswahl des Moduls DataLogManager . Es kann nur ein DataLog Manager pro Applikation ei...", 
"body" : "DataLog-Manager Der DataLog Manager verwaltet das Datenlogging von Variablen. Er kann unterhalb des obersten Objekt im Modulbaum hinzugefügt werden. Dies erfolgt durch den Befehl Toplevelinstanz hinzufügen und der Auswahl des Moduls DataLogManager . Es kann nur ein DataLog Manager pro Applikation eingefügt werden. Dialog: HMI Der DataLog Manager stellt eine Visualisierungsvorlage zur Verfügung ( VISU_DataLogManager ), die in die Gesamtvisualisierung eingebunden werden kann. Für weitere Informationen siehe: HMIIm Onlinebetrieb stellt diese Visualisierung statistische Informationen über das Lesen und Speichern der Variablen zur Verfügung: " }, 
{ "title" : "Dialog: Datenlogging ", 
"url" : "ac_dlm_datalogmanager_module.html#UUID-5158e4eb-39c1-2002-c9f6-d4d4a1d20765_f45d0fbcc9eecefdc0a8646307e5e8bf_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ DataLog Manager \/ Modul: DataLog-Manager \/ Dialog: Datenlogging ", 
"snippet" : "In diesem Dialog können eine oder mehrere Gruppen von der Speicherung ausgeschlossen werden. Standardmäßig ist die Gruppe DataLogManager angelegt. Hinzufügen Hinzufügen und Löschen der Gruppen, die von der Speicherung ausgeschlossen werden Entfernen...", 
"body" : "In diesem Dialog können eine oder mehrere Gruppen von der Speicherung ausgeschlossen werden. Standardmäßig ist die Gruppe DataLogManager angelegt. Hinzufügen Hinzufügen und Löschen der Gruppen, die von der Speicherung ausgeschlossen werden Entfernen " }, 
{ "title" : "Modul: DataLog-Kanal ", 
"url" : "ac_dlm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ DataLog Manager \/ Modul: DataLog-Kanal ", 
"snippet" : "DataLog-Kanal In einem Modul DataLog-Kanal werden die Gruppen für die Speicherung der Variablen festgelegt. Er kann unterhalb dem Datalog Manager -Knoten hinzugefügt werden. Dies erfolgt durch den Befehl Submodulinstanz hinzufügen und der Auswahl des Moduls DataLogChannel . Es können bis zu 64 DataL...", 
"body" : "DataLog-Kanal In einem Modul DataLog-Kanal werden die Gruppen für die Speicherung der Variablen festgelegt. Er kann unterhalb dem Datalog Manager -Knoten hinzugefügt werden. Dies erfolgt durch den Befehl Submodulinstanz hinzufügen und der Auswahl des Moduls DataLogChannel . Es können bis zu 64 DataLog-Kanäle eingefügt werden. Dialog: HMI, Information Eine detaillierte Beschreibung zu diesen Dialogen finden Sie unter HMI und Information . " }, 
{ "title" : "Dialog: Datenlogging ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ DataLog Manager \/ Modul: DataLog-Kanal \/ Dialog: Datenlogging ", 
"snippet" : "In diesem Dialog werden eine oder mehrere Gruppen festgelegt werden, die durch diesen Kanal verwaltet werden. Standardmäßig ist der Instanzname des Kanalmoduls in der Liste verfügbar. Gruppen, geloggt durch diesen Kanal Neu Definition einer Gruppe Der Eintrag wird mit Hinzufügen in die Liste übernom...", 
"body" : "In diesem Dialog werden eine oder mehrere Gruppen festgelegt werden, die durch diesen Kanal verwaltet werden. Standardmäßig ist der Instanzname des Kanalmoduls in der Liste verfügbar. Gruppen, geloggt durch diesen Kanal Neu Definition einer Gruppe Der Eintrag wird mit Hinzufügen in die Liste übernommen. Instanzpfad komprimieren : Das Speichern eines Eintrags wird nicht mit vollem Instanzpfad, sondern mit dem Hash-Wert dieses Strings durchgeführt, um Speicher zu sparen. Die Zuordnung zwischen Hash und Instanzpfad wird in einer seperaten Datei gespeichert. Entfernen Löscht die selektierte Gruppe aus der Liste Geloggte Variablen Liste der Variablen, die den Gruppen zugeordnet sind Dies Variablen besitzen das Attribut {attribute 'ac_datalog' := '<group name>'} . Aktualisieren Aktualisiert die Liste der geloggten Variablen Hinweis: Die Liste kann nur aktualisiert werden, wenn der DataLog-Generator aktiviert ist. Variablen können über das Attribut ac_datalog den Gruppen zugewiesen werden. Das Attribut ac_datalo g_hysteresis definiert die Hysterese, die überschritten werden muss, bevor eine Variable geloggt wird. Beispiel VAR\n {attribute 'ac_datalog' := 'DataLogChannel'}\n {attribute 'ac_datalog_hysteresis' := '0.745'}\n rLogVar : REAL;\nEND_VAR " }, 
{ "title" : "Dialog: Parameter ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ DataLog Manager \/ Modul: DataLog-Kanal \/ Dialog: Parameter ", 
"snippet" : "In diesem Dialog werden die Parameter für das Speichern der DataLog-Variablen festgelegt: Aktivieren FALSE : Es werden von diesem Kanal keine Einträge erstellt. Speichern im ersten Zyklus TRUE : Es wird im ersten Zyklus von jeder Variablen dieses Kanals ein Eintrag erstellt. Zyklische Speicherung Da...", 
"body" : "In diesem Dialog werden die Parameter für das Speichern der DataLog-Variablen festgelegt: Aktivieren FALSE : Es werden von diesem Kanal keine Einträge erstellt. Speichern im ersten Zyklus TRUE : Es wird im ersten Zyklus von jeder Variablen dieses Kanals ein Eintrag erstellt. Zyklische Speicherung Datentyp TIME : Es wird in periodischen Abständen der Wert aller Variablen dieses Kanals gespeichert. Der Wert T#0s deaktiviert das Logging. " }, 
{ "title" : "Modul: DataLog-Speicher CSV ", 
"url" : "ac_dlm_storage_csv_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ DataLog Manager \/ Modul: DataLog-Speicher CSV ", 
"snippet" : "DataLog-Speicher CSV Das Submodul DataLog_Storage_CSV definiert das Speicherformat eines DataLog-Kanals als CSV-Datei. Es kann unter einem DataLog-Kanalknoten hinzugefügt werden. Dies erfolgt durch den Befehl Submodulinstanz hinzufügen und der Auswahl des Moduls DataLogStorage_CSV . Dialog: Informat...", 
"body" : "DataLog-Speicher CSV Das Submodul DataLog_Storage_CSV definiert das Speicherformat eines DataLog-Kanals als CSV-Datei. Es kann unter einem DataLog-Kanalknoten hinzugefügt werden. Dies erfolgt durch den Befehl Submodulinstanz hinzufügen und der Auswahl des Moduls DataLogStorage_CSV . Dialog: Information Eine Beschreibung zu diesem Dialog finden Sie unter Information . " }, 
{ "title" : "Dialog: Parameter ", 
"url" : "ac_dlm_storage_csv_module.html#UUID-77b82c47-16c6-5f2f-5d4f-34b67bccf3d3_d1edd6c9f1f1a7c0a864637755e4ae_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ DataLog Manager \/ Modul: DataLog-Speicher CSV \/ Dialog: Parameter ", 
"snippet" : "Speicherungsname Name der Speicherdatei Standardmäßig ist der Platzhalter '%CHANNEL_NAME%' definiert. Dieser Platzhalter wird durch den Instanznamen des übergeordneten DataLog-Kanals ersetzt. Der Speicherdateiname muss eindeutig sein, da alle Speicherdateien standardmäßig im gleichen Verzeichnis abg...", 
"body" : "Speicherungsname Name der Speicherdatei Standardmäßig ist der Platzhalter '%CHANNEL_NAME%' definiert. Dieser Platzhalter wird durch den Instanznamen des übergeordneten DataLog-Kanals ersetzt. Der Speicherdateiname muss eindeutig sein, da alle Speicherdateien standardmäßig im gleichen Verzeichnis abgelegt werden. Optional kann ein Platzhalter %DATE% für das Datum der Speicherung hinzugefügt werden. Die Auflösung dazu ist im Parameter Format-String zum Ersetzen von %DATE% (siehe unten) definiert. Beispiel: Mit der Namensangabe '%CHANNEL_NAME%_AT_%DATE%' ergibt sich für den Kanal DataLogChannel_1 der folgende Dateiname: Application_DataLogChannel_1_AT_20191211_02-10-30.csv Separator : ASCII-Wert des Trennzeichens zwischen Variablenname und Wert Beispiel: ',' Puffergröße : Größe des internen Puffers zum Zwischenspeichern der Einträge Beispiel: 2000 Pufferfüllstand Wert in Prozent Wenn der Puffer bis zu diesem Wert angefüllt ist, wird der Inhalt des Puffers in die CSV-Datei geschrieben. Eine Angabe von 0 deaktiviert die Pufferung. Ein Eintrag in der Datei hat (mit | als Trennung) folgende Form: <TimeStamp>|<InstancePath\/Hash>|<Value>[|<TypeClass>] Im Falle der Speicherung mit Hash wird der Datentyp nicht bei jedem Eintrag mit angegeben, sondern nur einmal in der separaten Datei, in der die Zuordnung Hash ↔ Instanzpfad vorgenommen wird. Ein Eintrag in dieser Datei sieht folgendermaßen aus: <InstancePath>|<TypeClass>|<Hash> Im Falle eines Online-Changes werden die Dateien nicht gelöscht, sondern neue Einträge angehängt. In der Hash-Datei wird ein Online-Change mit Zeitstempel vermerkt. Somit ist zu Einträgen, die vor dem Online-Change erstellt wurden, die Zuordnung Hash ↔ Instanzpfad weiterhin möglich. Während der Initialisierung nach einem Download (kein Online-Change) werden sowohl Daten als auch Hash-Speicherdatei gelöscht. Umschließendes Zeichen Füge umschließende Zeichen ein TRUE : Stringeinträge werden mit umschließenden Zeichen abgespeichert. Beispiel: Variablenwert: File1 , Eintrag in Datei: -File1- FALSE : Stringeinträge werden ohne umschließende Zeichen abgespeichert. Umschließendes Zeichen Zeichen, die für das Umschließen verwendet werden Beispiel: '-' Format-String zum Ersetzen von %DATE% Datumsformat, mit dem der Platzhalter %DATE% ersetzt wird, der im Parameter Speicherungsname (siehe oben) angegeben werden kann Beispiele: 'yyyyMMdd' , 'yyyyMMdd_hh-mm-ss' LineEnding Zeichen, das das Zeilenende in der Datei angibt " }, 
{ "title" : "Modul: DataLog-Speicher SQLite ", 
"url" : "ac_dlm_storage_sqlite_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ DataLog Manager \/ Modul: DataLog-Speicher SQLite ", 
"snippet" : "DataLog-Speicher SQLite Das Submodul DataLog-Speicher SQLite definiert das Speicherformat eines DataLog-Kanals für eine SQ-Lite-Datenbank. Es kann unterhalb eines DataLog-Kanal-Knotens hinzugefügt werden. Dies erfolgt durch den Befehl Submodulinstanz hinzufügen und der Auswahl des Moduls DataLogStor...", 
"body" : "DataLog-Speicher SQLite Das Submodul DataLog-Speicher SQLite definiert das Speicherformat eines DataLog-Kanals für eine SQ-Lite-Datenbank. Es kann unterhalb eines DataLog-Kanal-Knotens hinzugefügt werden. Dies erfolgt durch den Befehl Submodulinstanz hinzufügen und der Auswahl des Moduls DataLogStorage_SQLite . Dialog: Information Detaillierte Informationen zu diesem Dialog finden Sie unter Information . " }, 
{ "title" : "Dialog: Parameter ", 
"url" : "ac_dlm_storage_sqlite_module.html#UUID-63e71af3-388f-498c-6553-5ab20ff603a1_accbd5f8d8b6d029c0a86463569e125f_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ DataLog Manager \/ Modul: DataLog-Speicher SQLite \/ Dialog: Parameter ", 
"snippet" : "Speicherungsname : Name der Archivdatei Standardmäßig ist der Platzhalter %CHANNEL_NAME% definiert. Dieser Platzhalter wird durch den Instanznamen des übergeordneten DataLog-Kanal ersetzt. Der Archivname muss eindeutig sein, da alle Archivdateien im gleichen Verzeichnis abgelegt werden. Alle Instanz...", 
"body" : "Speicherungsname : Name der Archivdatei Standardmäßig ist der Platzhalter %CHANNEL_NAME% definiert. Dieser Platzhalter wird durch den Instanznamen des übergeordneten DataLog-Kanal ersetzt. Der Archivname muss eindeutig sein, da alle Archivdateien im gleichen Verzeichnis abgelegt werden. Alle Instanzen dieses Moduls einer Applikation teilen sich eine Datei. Diese Datei wird von einem der Speichermodule initial erzeugt. Der Name der Datei ist immer <ApplicationName>_DataLog.sqlite . Maximale Anzahl der Einträge : Die maximale Anzahl von Einträgen für die Datenbank für diese Modulinstanz Ein Wert 0 deaktiviert die Funktion. Wird diese Anzahl überschritten, so verhält sich die Tabelle wie ein Ringpuffer und die ersten Einträge werden überschrieben. " }, 
{ "title" : "Definition von Logging-Variablen ", 
"url" : "ac_dlm_definition_logging_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ DataLog Manager \/ Definition von Logging-Variablen ", 
"snippet" : "Variablen werden über Attribute für das Datenlogging gekennzeichnet. ac_datalog [:= Gruppenname] : Dieses Attribut weist die Variable einer Logging-Gruppe zu. Ist diese Variable eine strukturierte Variable, dann werden alle Member, die geloggt werden können und nicht ausgeschlossen sind, geloggt. We...", 
"body" : "Variablen werden über Attribute für das Datenlogging gekennzeichnet. ac_datalog [:= Gruppenname] : Dieses Attribut weist die Variable einer Logging-Gruppe zu. Ist diese Variable eine strukturierte Variable, dann werden alle Member, die geloggt werden können und nicht ausgeschlossen sind, geloggt. Wenn kein Gruppenname gesetzt ist, muss dies pro Instanz der strukturierten Variable separat erfolgen. ac_datalog_set_default_group : Setzt die Gruppe aller Member einer Instanz eines strukturierten Typs, die keiner expliziten Gruppe zugeordnet sind. ac_datalog_exclude : Dieses Attribut schließt eine Variable eines strukturierten Datentyps vom Datenlogging aus. ac_datalog_union_representant : Dieses Attribut definiert innerhalb einer UNION einen Repräsentanten, der für das Datenlogging genutzt werden soll. ac_datalog_hysteresis := ‘Wert‘ : Dieses Attribut setzt die Hysterese, die überschritten werden muss, um eine Variable zu loggen. Dieses Attribut wird nur bei numerischen Datentypen beachtet. Wird es an nicht-numerischen Datentypen verwendet, wird eine Warnung ausgegeben und der Wert ignoriert. Eine weitere Beschreibung sowie Programmierbeispiele finden Sie in der Beschreibung der Attribute zum Persistence Mananger . " }, 
{ "title" : "Gerätediagnosegenerator ", 
"url" : "ac_device_diagnose_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Gerätediagnosegenerator ", 
"snippet" : "Das Gerätediagnosemodul ist eine Standardkomponente des Application Composers, welches in der Bibliothek AC_DeviceDiagnosis enthalten ist. Das Modul ist ein Toplevel-Modul und kann durch den Befehl Toplevelinstanz hinzufügen zum Modulbaum hinzugefügt werden. Gerätediagnosemodul im Modulbaum Mit Hilf...", 
"body" : "Das Gerätediagnosemodul ist eine Standardkomponente des Application Composers, welches in der Bibliothek AC_DeviceDiagnosis enthalten ist. Das Modul ist ein Toplevel-Modul und kann durch den Befehl Toplevelinstanz hinzufügen zum Modulbaum hinzugefügt werden. Gerätediagnosemodul im Modulbaum Mit Hilfe des Gerätediagnosemoduls wird auf Basis der bestehenden Gerätekonfiguration ein Visualisierungsbild erzeugt, das die SPS und die verbundenen Feldbusgeräte in Form einer Baumstruktur darstellt. In dieser Baumstruktur wird der Zustand der einzelnen Komponenten dargestellt. Bei Bedarf können Detailinformationen abgerufen oder die Betriebsart der einzelnen Komponenten verändert werden. Generierte Visualisierungsbilder für Gerätediagnose Gerätediagnose im Onlinebetrieb Im Onlinebetrieb wird der Gerätename, der Status sowie der Fehlercode angezeigt. Dabei wird der Status der Geräte farblich dargestellt: Grün: Gerät ist im Status \"Läuft“ Rot: Gerät ist nicht im Status \"Läuft“ Dialog zum Ändern des Status Ein Anklicken des Geräts öffnet ein Fenster, in welchem das Gerät angehalten ( Stop ), zurückgesetzt ( Reset ) und gestartet ( Start) werden kann. Beim ersten Öffnen des Dialog werden alle Funktionen angezeigt. Funktionen, welche von der Hardware nicht unterstützt werden, werden bei ihrer erstmaliger Betätigung ausgeblendet. " }, 
{ "title" : "Voraussetzungen ", 
"url" : "ac_device_diagnose_overview.html#UUID-fd01086a-c692-d615-c1cf-d5963632aa4b_ac778b834d585cc0a8640e01a520c3_id_be299b7583c984f0c0a86520016ce88a", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Gerätediagnosegenerator \/ Voraussetzungen ", 
"snippet" : "Die angezeigten Diagnosedetails entstammen den mit den Geräten erzeugten CAA-Device-Diagnose-FBs (Geräte-FBs). Für die Erzeugung dieser Bausteine muss in den SPS-Einstellungen die Option Diagnose für Geräte aktivieren eingestellt werden. Diese FBs liefern zum einen normale Statusinformationen die im...", 
"body" : "Die angezeigten Diagnosedetails entstammen den mit den Geräten erzeugten CAA-Device-Diagnose-FBs (Geräte-FBs). Für die Erzeugung dieser Bausteine muss in den SPS-Einstellungen die Option Diagnose für Geräte aktivieren eingestellt werden. Diese FBs liefern zum einen normale Statusinformationen die im (obigen) Überblick angezeigt werden, daneben aber auch Detailinformationen, die in einer zusätzlichen Anzeige dargestellt werden. Ist zum Zeitpunkt der Generierung die Option Diagnose für Geräte aktivieren noch nicht eingestellt, wird der Generierungslauf abgebrochen und die Option automatisch eingestellt, so dass der nächste Generierungslauf die gewünschte Visualisierung erzeugen wird. Damit dieses Visualisierungsbild generiert wird, muss der Gerätediagnose-Generator in der Generatorkonfiguration aktiviert sein. " }, 
{ "title" : "Befehle ", 
"url" : "core_applicationcomposer_composer_home.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle ", 
"snippet" : "Die Befehle der Befehlskategorie Composer werden mit dem CODESYS Application Composer bereit gestellt. Diese Befehle dienen hauptsächlich dazu, Composer-Objekte zum Modulbaum hinzuzufügen oder zu sie zu verändern. Weiterhin stehen Funktionen zum Zuordnen der Variablen zur E\/A-Konfiguration und zum E...", 
"body" : "Die Befehle der Befehlskategorie Composer werden mit dem CODESYS Application Composer bereit gestellt. Diese Befehle dienen hauptsächlich dazu, Composer-Objekte zum Modulbaum hinzuzufügen oder zu sie zu verändern. Weiterhin stehen Funktionen zum Zuordnen der Variablen zur E\/A-Konfiguration und zum Erzeugen von CODESYS -Applikationen zur Verfügung. Die Verfügbarkeit der Befehle hängt vom selektierten Objekt im Modulbaum ab: Es sind nur Befehle auswählbar, welche an der aktuellen Position erlaubt sind. " }, 
{ "title" : "Application Composer spezifische Ansicht ", 
"url" : "ac_dedicated_view.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Application Composer spezifische Ansicht ", 
"snippet" : "Der Application Composer stellt eine sehr einfache Möglichkeit zur Verfügung, komplette Applikationen zu erzeugen und zu starten. Angelehnt an diese einfache Bedienung bietet CODESYS eine reduzierte Ansicht der Benutzeroberfläche. Diese Ansicht wird durch Auswahl des Profils „Application Composer sp...", 
"body" : "Der Application Composer stellt eine sehr einfache Möglichkeit zur Verfügung, komplette Applikationen zu erzeugen und zu starten. Angelehnt an diese einfache Bedienung bietet CODESYS eine reduzierte Ansicht der Benutzeroberfläche. Diese Ansicht wird durch Auswahl des Profils „Application Composer spezifisch“ oder durch den zugehörigen Befehl im CODESYS -Startmenü gestartet. Danach wird eine reduzierte Ansicht von CODESYS angezeigt, welche nur Zugriff auf die absolut notwendigen Fenster und Befehle zur Erstellung einer Applikation mit dem CODESYS Application Composer zur Verfügung stellt. Application Composer spezifische Ansicht Die Ansicht zeigt nur die Fenster des Modulbaums, des Gerätebaums und der Meldungsausgabe zusammen mit den Online-Befehlen Login\/Logout\/Run und Stop sowie für den Composer-Befehlen. Speziell für die vereinfachte Ansicht stehen folgende zwei Befehle zur Verfügung: Erzeugen, Übersetzen und Einloggen : Erzeugung und Übersetzung des Codes, Verbinden zum Gerät und Start der Applikation auf dem Gerät Modulbibliothek zum Projekt hinzufügen : Hinzufügen von Bibliotheken zum Bibliotheks-Manager des POU-Pools, welcher normalerweise in der Ansicht „Application Composer spezifisch“ nicht zur Verfügung steht Falls die Bibliotheken Module enthalten, können diese an entsprechenden Stellen des Modulbaums hinzugefügt werden. " }, 
{ "title" : "Modulbaum ", 
"url" : "ac_module_tree.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Modulbaum ", 
"snippet" : "Zusätzlich zum Gerätebaum und dem POU-Baum stellt der Application Composer den Modulbaum zur Verfügung. Der Baum dient dazu, eine Applikation mit Hilfe von vorgefertigten Modulen zu erzeugen bzw. zu ändern. Mit den Befehlen des Application Composers können Module zum Modulbaum hinzugefügt, geändert ...", 
"body" : "Zusätzlich zum Gerätebaum und dem POU-Baum stellt der Application Composer den Modulbaum zur Verfügung. Der Baum dient dazu, eine Applikation mit Hilfe von vorgefertigten Modulen zu erzeugen bzw. zu ändern. Mit den Befehlen des Application Composers können Module zum Modulbaum hinzugefügt, geändert oder gelöscht werden. Der Baumstruktur kann aufgeklappt oder minimiert werden. Beispiel eines Modulbaums Abhängig von dem angewählten Objekt können passende Module zum Modulbaum hinzugefügt werden. Dies kann mit Hilfe der Befehle unter dem Menüpunkt „Composer“ oder im Kontextmenü ausgeführt werden. Die Icon der Elemente können in der Moduldeklaration definiert werden. " }, 
{ "title" : "Elemente des Modulbaums ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_a88610fbb413e565c0a8640e00f61f5a", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Modulbaum \/ Elemente des Modulbaums ", 
"snippet" : "(1): Toplevelmodule mit Applikations- und Task-Einstellungen (2): Submodule (3): Instanz-Referenzen, welche Submodule referenzieren. Instanz-Referenzen haben keine eigenen Parameter oder E\/As. (4): Erweiterungen, welche auch ohne den Application Composer erzeugt werden können und mit deren Hilfe die...", 
"body" : "(1): Toplevelmodule mit Applikations- und Task-Einstellungen (2): Submodule (3): Instanz-Referenzen, welche Submodule referenzieren. Instanz-Referenzen haben keine eigenen Parameter oder E\/As. (4): Erweiterungen, welche auch ohne den Application Composer erzeugt werden können und mit deren Hilfe die Applikation an die Maschine angepasst werden kann. (5): Steckplätze (einfach oder mehrfach), welche zwingend erforderlich oder optional sein können. " }, 
{ "title" : "Anzeige der Baumstruktur ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_8a0710cab44f1a9bc0a8640e00ddf9a1", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Modulbaum \/ Anzeige der Baumstruktur ", 
"snippet" : "Die unter einer expandierten Modulinstanz angezeigten Kindknoten werden durch folgende Regeln bestimmt, wobei die Reihenfolge aller belegten und unbelegten Steckplätze immer der Deklarationsreihenfolge im Modul entspricht: Falls die Modulinstanz an dieser Stelle nur referenziert wird, hat sie keine ...", 
"body" : "Die unter einer expandierten Modulinstanz angezeigten Kindknoten werden durch folgende Regeln bestimmt, wobei die Reihenfolge aller belegten und unbelegten Steckplätze immer der Deklarationsreihenfolge im Modul entspricht: Falls die Modulinstanz an dieser Stelle nur referenziert wird, hat sie keine Kinder. Alle unbelegten Steckplätze werden angezeigt, außer den optionalen Steckplätzen, die explizit ausgeblendet wurden. Für Steckplätze wird der Rollenname und der Typ angezeigt. Belegte Steckplätze mit oberer Stelligkeit 1 werden nicht angezeigt. Die verbundene Untermodulinstanz ersetzt optisch den Steckplatz. Optionale und erforderliche Untermodulinstanzen werden an den Stellen angezeigt, an denen zuvor die Steckplätze angezeigt wurden. Der Rollenname wird nach dem Modulinstanznamen in eckigen Klammern dargestellt. Untermodulinstanzen eines Mehrfach-Steckplatzes werden unter dem jeweiligen Steckplatz angezeigt. Der Rollenname wird hier nicht mit angezeigt, da dieser über den Vaterknoten klar ist. Die folgenden Eigenschaften der Steckplätze wird mit zusätzlichen Icons angezeigt: Optionale Steckplätze Obligatorische Steckplätze Mehrfach-Steckplätze Referenzen auf Submodulinstanzen Wenn eine Modulinstanz gelöscht wird, werden alle Referenzen auf dieses Modul mit einem Fehler-Icon dargestellt. Wenn der Typ einer Modulinstanz geändert wird, werden alle Referenzen auf dieses Modul mit falschem Typ mit einem Fehler-Icon dargestellt. Abhängig von der Position im Modulbaum können die Befehle Ausschneiden \/ Kopieren \/ Einfügen aus dem Kontextmenü verwendet werden. Elemente aus dem Modulbaum können mit \"Drag & Drop“ verschoben werden. Wenn während der Ausführung von \"Drag & Drop“ die Taste Strg gedrückt wird, wird das Element kopiert. Die Elemente des Modulbaums können wie andere Objekte in CODESYS exportiert und importiert werden. " }, 
{ "title" : "Moduldialog ", 
"url" : "ac_module_dialog.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Moduldialog ", 
"snippet" : "Über die Befehle Toplevelinstanz hinzufügen , Submodulinstanz hinzufügen , Modulinstanz referenzieren und Module aktualisieren öffnet sich ein nicht-modaler Dialog. Abhängig von der Position im Modulbaum werden alle passenden Module angezeigt. Durch einen Doppelklick auf das Modul oder durch die Bef...", 
"body" : "Über die Befehle Toplevelinstanz hinzufügen , Submodulinstanz hinzufügen , Modulinstanz referenzieren und Module aktualisieren öffnet sich ein nicht-modaler Dialog. Abhängig von der Position im Modulbaum werden alle passenden Module angezeigt. Durch einen Doppelklick auf das Modul oder durch die Befehle Modul hinzufügen bzw. Submodulinstanz hinzufügen wird das ausgewählte Modul in den Modulbaum kopiert. Die Schaltflächen Modul hinzufügen (oder Referenzieren ) sind nur dann freigegeben, wenn ein passendes Modul ausgewählt ist und der gewählte Steckplatz im Modulbaum noch nicht belegt ist. Weiterhin muss ein gültiger Name (mit gültigem IEC-Identifier) eingegeben werden. Der Name des Objektes kann nur für neue Modulinstanzen festgelegt werden. Im Dialog zum Befehl Modul aktualisieren kann der Name nicht geändert werden. Nur kompatible Instanzen anzeigen : Wenn diese Option aktiviert ist, werden die angezeigten Instanzen gefiltert, so dass nur auswählbare Instanzen angezeigt werden. Wenn deaktiviert, werden alle Instanzen angezeigt und die auswählbaren Instanzen fett markiert. Applikation : Applikation unter der eine Toplevel-Modulinstanz generiert wird. Über die Schaltfläche kann eine bestehende Applikation ausgewählt werden. Dialog zum Hinzufügen neuer Modulinstanzen Der Dialog ist nicht-modal. Er erlaubt das Selektieren anderer Objekte im Baum, ohne geschlossen werden zu müssen. Dabei werden die gelisteten Elemente sowie die möglichen Befehle automatisch angepasst. Das Verhalten dieses Dialogs ist identisch mit dem Dialog Gerät einfügen . " }, 
{ "title" : "Befehl: Erzeugen ", 
"url" : "ac_generate.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Erzeugen ", 
"snippet" : "Erzeugen Symbol: Dieser Befehl (Kategorie \"Composer“) startet einen Build-Prozess, welcher automatisch die CODESYS -Applikation aus dem Modulbaum und den Einstellungen der Generatorkonfiguration erzeugt. Meldungen und Fehler werden im Meldungsfenster ausgegeben. Alle Objekte, welche mit dem Standard...", 
"body" : "Erzeugen Symbol: Dieser Befehl (Kategorie \"Composer“) startet einen Build-Prozess, welcher automatisch die CODESYS -Applikation aus dem Modulbaum und den Einstellungen der Generatorkonfiguration erzeugt. Meldungen und Fehler werden im Meldungsfenster ausgegeben. Alle Objekte, welche mit dem Standard-Generator erzeugt werden (ausgenommen die Task-Objekte und Applikationen) werden im Unterordner der Applikation oder im POUs-Pool mit dem Namen AC_Std und AC_FBs gespeichert. Wenn bereits ein Ordner mit diesem Namen vorhanden ist, wird ein eindeutiger Name durch Hinzufügen eines Suffix _0 erzeugt. Erzeugte Funktionsbausteine Alle Objekte, welche durch den Befehl Erzeugen angelegt werden, sind mit einem kleinen blauen Icon versehen. Versucht der Anwender eines dieser Objekte zu löschen, zu verschieben oder zu editieren, dann erscheint ein Dialog mit dem Hinweis, dass diese Aktion zu Übersetzungsfehlern führen könnte. Wenn der Vorgang fortgesetzt wird, wechselt die Farbe die Icons auf rot (siehe Funktionsbaustein AC_PRG_RMP (PRG) im obigen Screenshot). Wenn Sie den Application Composer zusammen mit CODESYS SVN verwenden: Alle Composer-generierten Objekte werden mit einem Ignore on Commit für SVN versehen. Zusätzlich wird beim Erzeugen in den SVN-Offlinebetrieb geschaltet, um SVN-Locks zu vermeiden und zu umgehen. Erzeugung von Kommunikationsinfrastruktur Festlegung: Im folgenden wird gesagt, dass Applikationen A1 an Applikation A2 sendet (oder äquivalent, dass A2 von A1 empfängt), wenn eine der folgenden Bedingungen gegeben ist: Eine Modulinstanz, die der Applikation A1 zugeordnet ist, referenziert eine Modulinstanz, die der Applikation A2 zugeordnet ist oder umgekehrt. Ein Ausgang einer Modulinstanz, die A1 zugeordnet ist, ist über eine direkte Modul-E\/A-Verbindung mit einem Eingang einer Modulinstanz verbunden, die A2 zugeordnet ist. Die folgenden Objekte werden für jede vom Generator erzeugten Applikation im Ordner AC_RMP unter der Applikation erzeugt: Es wird eine Kommunikationstask angelegt. (Zykluszeit und Priorität gemäß Einstellung in der Generatorkonfiguration.). In dieser Task erfolgen auch die Aufrufe der Proxy-Instanzen und Setzen\/Lesen der gespiegelten Modul-Proxy-FB-Variablen. Für jede Applikation, die an die aktuelle Applikation sendet, wird eine (Sende)-GVL angelegt und deren Netzwerkeinstellungen gesetzt. (Protokoll \"UDP“, zyklische Übertragung, Prüfsummen, Zykluszeit gemäß Einstellung in der Generatorkonfiguration, Kommunikationstask. Der \"List Identifier“, der eine ganze Zahl zwischen 1 und 2^15-1 sein muss, wird zu Beginn der Generierung mittels Zufallsgenerator ermittelt und dann nach jeder Sende-GVL um 1 erhöht. Der Zufallswert wird so ermittelt, dass er mindestens 128 ist und dass der gültige Wertebereich nicht überschritten wird. Falls es Modulinstanz-Referenzen zwischen den Applikationen gibt, wird eine Variable vom Typ RMPExchangeData in der GVL angelegt. Der Name der Variable enthält die Namen der Quell- und der Zielapplikation. Falls diese Modulinstanz-Referenz in ihrer (nötigen) Proxy-Definition zusätzlich zu spiegelnde Variablen ( MirrorVar ) angibt, wird in der (Sende)-GVL, der referenzierten Modulinstan, für jede \"MirrorVar“ eine Variable in der GVL angelegt. Ihr Name enthält den Instanzpfad der Modulinstanz und die TargetId, der Definition der jeweiligen \"MirrorVar“. Für jede Applikation A2, an die die aktuelle Applikation sendet, wird eine (Empfangs)-NVL (Netzwerkvariablenliste) angelegt und mit der entsprechenden Sende-GVL von A2 und der Kommunikationstask verknüpft. In der GVL AC_RMP wird ein Funktionsbaustein vom Typ RMPService instanziiert und in der Deklaration initialisiert (mit Attribut init_on_onlchange ). Dazu werden zwei Arrays vom Typ RMPConnection angelegt, die auf die oben erzeugten Variablen vom Typ RMPExchangeData in den GVLs und NVLs verweisen. Es wird ein Programm AC_PRG_RMP erzeugt, das den Baustein vom Typ RMPService aufruft. Dieses Programm wird in die Kommunikationstask eingetragen. Zusätzlich wird in dem Program AC_PRG_RMP der Inhalt der zu spiegelnden Variablen (\"MirrorVars“) gesetzt und gelesen. Es werden somit jeweils die Proxy-\"MirrorVars“ den entsprechende Variablen der (Empfänger)-GVL zugewiesen. Anschließend wird die Main “-Methode der Proxy-Instanz aufgerufen und schließlich die entsprechenden Variablen der (Sender)-GVL den Modul-\"MirrorVars“. Dies geschieht entsprechend der Senderichtung von Modulinstanz zu Proxies. " }, 
{ "title" : "Erzeugung von Funktionsbaustein-Instanzen durch den Standard-Generator ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_65e9c9d2b9a5b65fc0a8640e0003897d", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Erzeugen \/ Erzeugung von Funktionsbaustein-Instanzen durch den Standard-Generator ", 
"snippet" : "Für jede Modulinstanz wird ein Funktionsbaustein im Ordner AC_FBs erzeugt. Dieser Funktionsbaustein leitet vom Modulfunktionsbaistein ab. Der Funktionsbaustein enthält (Eingangs-)Variablen für Submodulinstanzen Arrays konfigurierbarer Größe Puffervariablen von direkten E\/A-Verbindungen Arrays von Me...", 
"body" : "Für jede Modulinstanz wird ein Funktionsbaustein im Ordner AC_FBs erzeugt. Dieser Funktionsbaustein leitet vom Modulfunktionsbaistein ab. Der Funktionsbaustein enthält (Eingangs-)Variablen für Submodulinstanzen Arrays konfigurierbarer Größe Puffervariablen von direkten E\/A-Verbindungen Arrays von Mehrfach-Steckplätzen und der Instanzreferenzen Die Namen der entsprechenden Array-Variablen bilden sich aus einem Präfix AC_ARRAY_ gefolgt vom Variablennamen der entsprechenden Pointer-Variable. Für Arrays konfigurierbarer Größe kann der Name durch die Definition VarArray.InstName optional überschrieben werden. Der Implementierungsteil des Funktionsbausteins enthält die Anweisung SUPER^(); , durch die der Implementierungsteil des Modul-FBs aufgerufen wird. Beispiel Die Modulinstanz ModuleInstanceA ist vom Typ ModuleA mit zugehörigem Funktionsbaustein ModuleA_FB . Sie hat eine Submodulinstanz vom Typ ModuleB . Die Modulinstanz ModuleInstanceA ist vom Typ ModuleA mit zugehörigem Funktionsbaustein ModuleA_FB . Sie hat eine Submodulinstanz vom Typ ModuleB FUNCTION_BLOCK AC_ModuleInstanceA EXTENDS ModuleA_FB\n\nVAR_INPUT\n Inst_Sub1 : AC_ModuleInstanceB ;\nEND_VAR Der Name des Funktionsbausteins wird aus dem Modulinstanzpfad und dem Präfix AC_ gebildet. Der Name der Variablen für die Submodulinstanzen bildet sich aus einem Präfix gefolgt vom Namen der jeweiligen Submodulinstanz. Jeder FB wird einmal instanziiert, die FB-Instanzen von Toplevelmodulen direkt in den GVLs, die übrigen entsprechend in den FBs der Vater-Instanz. Für jede referenzierte Modulinstanz, die in einer anderen Applikation liegt, wird genau eine FB-Instanz des Proxy-FBs angelegt, und zwar in einer der GVLs der referenzierenden Modulinstanzen. Der Name der Proxy-Instanz ist AC_PROXY_<InstanceName> wobei <InstanceName> der Name der Zielinstanz in der anderen Applikation ist. Für alle Modul-FB-Instanzen werden eindeutige Adressen vergeben. Die Proxy-FB-Instanzen erhalten die Adresse der Modulinstanz der anderen Applikation. Die Methode IBaseInstance.Main der Proxy-FB-Instanzen wird zyklisch in der Kommunikationstask aufgerufen. " }, 
{ "title" : "Erzeugung der Applikation und der Task-Aufrufe ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_c88cdc4bba310f0dc0a8640e0094f683", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Erzeugen \/ Erzeugung der Applikation und der Task-Aufrufe ", 
"snippet" : "Wenn ein Modul einer Applikation zugeordnet ist, die noch nicht existiert, wird die Applikation angelegt. Anlegen von nicht existierenden Standard-Tasks: TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW Die Priorität und Zykluszeit der Tasks wird gemäß den Generatoreinstellungen gesetzt. Außerdem...", 
"body" : "Wenn ein Modul einer Applikation zugeordnet ist, die noch nicht existiert, wird die Applikation angelegt. Anlegen von nicht existierenden Standard-Tasks: TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW Die Priorität und Zykluszeit der Tasks wird gemäß den Generatoreinstellungen gesetzt. Außerdem werden modulspezifische Tasks mit den gegebenen Einstellungen angelegt. Erzeugung einer globalen Variablenliste pro Toplevel-Instanz, in welcher die Modulinstanzen, die unter Toplevel-Modulen hängen, die dieser Applikation angehören, angelegt werden. Die globale Variablenliste trägt den im Modul festgelegten Namen oder, falls keine Festlegung getroffen wurde, den Namen GVL_MODULE . Die GVL hängt unter der gewählten Applikation oder im globalen POU-Baum Pro Applikation wird eine GVL mit dem Namen GVL_ MODULE_TREE deklariert. In ihr werden die zur Verwaltung des Modulbaums nötigen Variablen deklariert. Die GVLs werden in einen Ordner mit Namen AC_Std angelegt. Erzeugung von Initialisierungscode, der mittels Pragmas automatisch bei Download und Online-Change aufgerufen wird: Die Baumstruktur wird abgebildet. Parametersätze werden gesetzt. Referenzen und Submodulinstanzen werden zugewiesen. Felder konfigurierbarer Größe werden befüllt. Instanzreferenzen werden gesetzt. Beim Download werden nur die Parameter gesetzt, die nicht auf dem Defaultwert stehen (es sei denn der Default-Wert wurde in der Moduldeklaration überschrieben), beim Online-Change alle, da hier nicht bekannt ist, auf welchem Wert der Parameter zuvor stand. Die POUs werden in einen Ordner mit Namen AC_Std angelegt. Für jeden definierten Einsprungspunkt aus einer Task wird eine PROGRAM -POU (Implementierungssprache ST) angelegt, welche die Aufrufe der Toplevelnodule enthält. Der Aufruf dieser neuen POU wird dann unterhalb der Task eingehängt. Im Fall der Standardtasks heißen die POUs: MODULE_CALL_<TASKNAME>_START MODULE_CALL_<TASKNAME>_END Die POUs werden in einen Ordner mit Namen AC_Std angelegt. Für Toplevel Modulinstanzen im POUs -Pool werden die Taskaufrufe in jeder Applikation angelegt. " }, 
{ "title" : "Erzeugung der E\/A-Zuordnung ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_bf24656dba310f0fc0a8640e01fdf5a6", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Erzeugen \/ Erzeugung der E\/A-Zuordnung ", 
"snippet" : "Je nach Typ der E\/A-Zuordnung führt der Standardgenerator folgende Änderungen durch: [E\/A-Kanal]: Im entsprechenden Gerätekanal wird der Instanzname des E\/As der Modulinstanz eingetragen. [ST-Ausdruck]: Die Zuweisungen der Ausdrücke auf die Eingänge oder von den Ausgängen auf die Ausdrücke werden üb...", 
"body" : "Je nach Typ der E\/A-Zuordnung führt der Standardgenerator folgende Änderungen durch: [E\/A-Kanal]: Im entsprechenden Gerätekanal wird der Instanzname des E\/As der Modulinstanz eingetragen. [ST-Ausdruck]: Die Zuweisungen der Ausdrücke auf die Eingänge oder von den Ausgängen auf die Ausdrücke werden über den gesamten Teilbaum jeder Toplevel-Instanz gesammelt. Falls es entsprechende Zuweisungen gibt, wird pro Toplevel-Instanz eine Funktion mit Namen AC_Io_SetInputs_<Instanzname> oder AC_Io_SetOutputs_<Instanzname> erzeugt, die alle Zuweisungen enthält. Die Task, in der Ein- und Ausgänge beschrieben werden, wird durch das Flag UPDATE-IOS in der Modulbeschreibung gekennzeichnet. Diese Task wird im Folgenden \"I\/O-Task\" genannt. Die Funktion für die Eingänge wird in der I\/IO-Task vor der Task-Methode der Modulinstanz aufgerufen. (Wenn die I\/O-Task eine Standard-Task ist: vor der Start-Methode.) Die Funktion für die Ausgänge wird in der IO-Task nach Task–Methode der Modulinstanz aufgerufen. (Wenn die I\/O-Task eine Standard-Task ist: nach der End-Methode.) [Direktverbindung mit Modul-E\/A, lokal]: lm Funktionsbaustein, der für die Instanz des Eingangs erzeugt wird, wird eine Puffer-Variable passenden Typs angelegt. Der Name der Puffer-Variablen beginnt mit dem Präfix AC_Io_Buffer_ . Die Puffer-Variablen werden während der Initialisierung der Applikation auf die aktuellen Werte der verbundenen Ausgänge initialisiert. Der Generator behandelt die Eingangs- und Ausgangszuweisungen wie eine Zuweisung von\/auf diese(r) Puffer-Variable (siehe [ST-Ausdruck]) [Direktverbindung mit Modul-E\/A, remote]: Es wird für jeden Ausgang, der mit dem Eingang einer Modulinstanz verbunden ist, die in einer anderen Applikation liegt, eine Puffer-Variable passenden Typs in der entsprechenden Sende-Netzwerk-GVL angelegt. Der Name der Puffer-Variablen beginnt mit dem Präfix AC_RemoteIo_Buffer_ und wird aus dem Instanzpfad und dem Variablenpfad des Ausgangs gebildet. Die Puffer-Variablen werden mit dem Initialisierungsausdruck der Ausgangsvariable initialisiert, falls einer existiert. Falls der Wert dieses Initialisierungsausdrucks nicht in den Precompile-Informationen enthalten ist (weil der Ausdruck z.B. Variablen, Funktionen oder Konstanten verwendet), wird ein Fehler erzeugt Der Generator behandelt die Ausgangszuweisung wie eine Zuweisung auf diese Puffer-Variable und die Eingangszuweisung in der anderen Applikation wie eine Zuweisung von der entsprechenden Variable in der Empfänger NVL, siehe oben unter [ST-Ausdruck]. Anmerkung: die Synchronisierung zwischen der Task, in der die Netzwerkvariablen aktualisiert werden und der I\/O-Task des Moduls ist noch nicht gelöst. Es kann daher sein, dass Werte nicht komplett geschrieben wurden, wenn die I\/O-Task diese liest. " }, 
{ "title" : "Befehl: Generatorkonfiguration ", 
"url" : "ac_generator_configuration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Generatorkonfiguration ", 
"snippet" : "Generatorkonfiguration Dieser Befehl (Kategorie „Composer“) öffnet einen Dialog mit allen verfügbaren Generatoren. In diesem Dialog kann jeder einzelne Generator an- oder abgewählt werden. Ein Klick auf das Icon rechts öffnet den Dialog mit den Einstellungen des gerade selektierten, angewählten Gene...", 
"body" : "Generatorkonfiguration Dieser Befehl (Kategorie „Composer“) öffnet einen Dialog mit allen verfügbaren Generatoren. In diesem Dialog kann jeder einzelne Generator an- oder abgewählt werden. Ein Klick auf das Icon rechts öffnet den Dialog mit den Einstellungen des gerade selektierten, angewählten Generators. " }, 
{ "title" : "Gerätegenerator ", 
"url" : "ac_generator_configuration.html#UUID-808f4cf5-ae70-df89-d868-14922e672101", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Generatorkonfiguration \/ Gerätegenerator ", 
"snippet" : "Dieser Generator versucht, die notwendigen Geräte zu erzeugen und verbindet sie, soweit wie möglich, mit Modul-E\/As. In der aktuellen Version des Application Composer Plug-ins ist keine Konfiguration des Gerätegenerators verfügbar....", 
"body" : "Dieser Generator versucht, die notwendigen Geräte zu erzeugen und verbindet sie, soweit wie möglich, mit Modul-E\/As. In der aktuellen Version des Application Composer Plug-ins ist keine Konfiguration des Gerätegenerators verfügbar. " }, 
{ "title" : "SourceTemplate Generator ", 
"url" : "ac_generator_configuration.html#UUID-dcd74dd8-c2bf-daf3-03d2-c4b54ecf55a8", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Generatorkonfiguration \/ SourceTemplate Generator ", 
"snippet" : "Dieser Generator kopiert bestehende Funktionsbausteine aus dem POUs -Pool in die Applikation. Die kopierten Bausteine werden im Ordner AC_SourceTemplate abgelegt. In diesem Ordner wird zusätzlich die Funktion AC_SourceTemplateInit angelegt. Diese Funktion initialisiert die kopierten Funktionsbaustei...", 
"body" : "Dieser Generator kopiert bestehende Funktionsbausteine aus dem POUs -Pool in die Applikation. Die kopierten Bausteine werden im Ordner AC_SourceTemplate abgelegt. In diesem Ordner wird zusätzlich die Funktion AC_SourceTemplateInit angelegt. Diese Funktion initialisiert die kopierten Funktionsbausteine. Einmal erzeugte Funktionsbausteine können editiert werden und werden bei erneuten Generierungsläufen nicht überschrieben. Nicht mehr verwendete Funktionsbausteine werden umbenannt und in den Unterordner UnusedSourceTemplate verschoben. Dabei wird die Erweiterung _unused angehängt. Voraussetzung: Der Standardgenerator muss aktiviert sein. " }, 
{ "title" : "Standardgenerator ", 
"url" : "ac_generator_configuration.html#UUID-a3c9c7e9-e567-6ffc-3f6c-ae4016d57a70", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Generatorkonfiguration \/ Standardgenerator ", 
"snippet" : "Einstellungen der Default-Task Task hoher Priorität Definition von Priorität und Intervall der benutzerdefinierten Tasks Die benutzerdefinierten Tasks können im Editor der Toplevelmodule eingestellt werden (siehe dazu Verwendung). Task mittlerer Priorität Task niedriger Priorität Kommunikationseinst...", 
"body" : "Einstellungen der Default-Task Task hoher Priorität Definition von Priorität und Intervall der benutzerdefinierten Tasks Die benutzerdefinierten Tasks können im Editor der Toplevelmodule eingestellt werden (siehe dazu Verwendung). Task mittlerer Priorität Task niedriger Priorität Kommunikationseinstellungen RMP-Kommunikation aktivieren : Die für die RMP-Kommunikation erforderlichen Elemente werden erzeugt. Task-Priorität Priorität der RMP-Task Taskintervall Taskintervall der RMP-Task Compiler-Pragmas GVLs Definition von Compiler-Pragmas Diese Liste von Pragmas wird vor die generierten GVLs bzw. Funktionsbausteine eingefügt. Funktionsbausteine Symbolkonfiguration Symbolkonfiguration erzeugen : Das Objekt Symbolkonfiguration wird zur Applikation hinzugefügt . " }, 
{ "title" : "Persistenzgenerator ", 
"url" : "ac_generator_configuration.html#UUID-e4484f57-2155-dad9-990f-264462e75e1e", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Generatorkonfiguration \/ Persistenzgenerator ", 
"snippet" : "Der Persistenzgenerator liest die Persistenzkonfiguration aus dem Modulbaum und erzeugt ein Persistenzkonfigurations-Objekt unter jeder Applikation, welche Persistenz verwendet. Für weitere Informationen siehe auch: Persistence ManagerEine Applikation verwendet nur dann die Persistenzfunktion des Ap...", 
"body" : "Der Persistenzgenerator liest die Persistenzkonfiguration aus dem Modulbaum und erzeugt ein Persistenzkonfigurations-Objekt unter jeder Applikation, welche Persistenz verwendet. Für weitere Informationen siehe auch: Persistence ManagerEine Applikation verwendet nur dann die Persistenzfunktion des Application Composer, wenn eine Instanz des Persistence Managers auf diese Applikation gemappt ist. " }, 
{ "title" : "DataLog-Generator ", 
"url" : "ac_generator_configuration.html#UUID-0a4d1c9e-c363-489e-e742-4b6d5c1afaa4", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Generatorkonfiguration \/ DataLog-Generator ", 
"snippet" : "Der DataLog Generator erzeugt aus der Konfiguration des Modulbaums ein DataLog-Konfigurationsobjekt. Dieses Objekt wird unter der Applikation eingefügt, auf die die Instanz des DataLog Managers gemappt ist. In der aktuellen Version des CODESYS Application Composer ist keine Konfiguration des DataLog...", 
"body" : "Der DataLog Generator erzeugt aus der Konfiguration des Modulbaums ein DataLog-Konfigurationsobjekt. Dieses Objekt wird unter der Applikation eingefügt, auf die die Instanz des DataLog Managers gemappt ist. In der aktuellen Version des CODESYS Application Composer ist keine Konfiguration des DataLog-Generators verfügbar. " }, 
{ "title" : "Trendgenerator ", 
"url" : "ac_generator_configuration.html#UUID-b0155d06-1fc0-2914-55ee-2233ae0d22ee", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Generatorkonfiguration \/ Trendgenerator ", 
"snippet" : "Der Trendgenerator liest die Trenddefinitionen aus der Modulbeschreibung und erzeugt daraus Trendkonfigurationen und dazugehörige Visualisierungen. Diese Visualisierungen werden in bereits vorhandene Visualisierungen eingebettet....", 
"body" : "Der Trendgenerator liest die Trenddefinitionen aus der Modulbeschreibung und erzeugt daraus Trendkonfigurationen und dazugehörige Visualisierungen. Diese Visualisierungen werden in bereits vorhandene Visualisierungen eingebettet. " }, 
{ "title" : "Alarmgenerator ", 
"url" : "ac_generator_configuration.html#UUID-62c4fd14-9eaa-46b5-f370-4e36a88614fe", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Generatorkonfiguration \/ Alarmgenerator ", 
"snippet" : "Der Alarmgenerator liest die Alarmdefinitionen aus der Modulbeschreibungen und erzeugt oder erweitert die zugehörigen Komponenten der Alarmverwaltung. Zusätzlich wird aus einer Vorlage eine Visualisierung erzeugt, in der eine Alarmtabelle eingefügt wird. Diese Visualisierung wird als Toplevel-Visual...", 
"body" : "Der Alarmgenerator liest die Alarmdefinitionen aus der Modulbeschreibungen und erzeugt oder erweitert die zugehörigen Komponenten der Alarmverwaltung. Zusätzlich wird aus einer Vorlage eine Visualisierung erzeugt, in der eine Alarmtabelle eingefügt wird. Diese Visualisierung wird als Toplevel-Visualisierung zu den übrigen Visualisierungsbildern des Visualisierungsgenerators hinzugefügt. Vorlage Vorlage, die für die Seitenvisualisierung verwendet werden soll. Hinweis: Damit eine Visualisierung als Vorlage verwendet werden kann, muss sie folgende Voraussetzungen erfüllen: Ein Rechteck mit dem Namen Placeholder_AlarmTable Die Variablen bAckVisible , bAckSel , bHistory , bFreezeScrlPos des Typs BOOL Vorlage Alarmspeicherung Objekte vom Typ AlarmStorageTemplate , die im aktuellen Projekt und den referenzierten Bibliotheken gefunden werden Die gewählte Vorlage wird für alle generierten Alarmkonfigurationen verwendet. Erzeuge Toplevelreiter : Es wird ein Toplevelreiter für die erzeugte Alarmvisualisierung erzeugt. Der festgelegte Name wird in diesem Toplevelreiter angezeigt. " }, 
{ "title" : "Gerätediagnose-Generator ", 
"url" : "ac_generator_configuration.html#UUID-eacb5fd7-1329-2790-9483-fe45edbe632a", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Generatorkonfiguration \/ Gerätediagnose-Generator ", 
"snippet" : "Dieser Generator erzeugt Visualisierungsbilder für die Gerätediagnose. In der Einstellung können die Visualisierungsvorlagen sowie das Layout des Visualisierungsbilds festgelegt werden. Dialog Gerätediagnose-Generator Einstellungen In diesem Dialog werden die Vorlagen für Basisvisualisierung, SPS, F...", 
"body" : "Dieser Generator erzeugt Visualisierungsbilder für die Gerätediagnose. In der Einstellung können die Visualisierungsvorlagen sowie das Layout des Visualisierungsbilds festgelegt werden. Dialog Gerätediagnose-Generator Einstellungen In diesem Dialog werden die Vorlagen für Basisvisualisierung, SPS, Feldbus, Buskoppler und Klemmen eingestellt. In den Combo-Boxen, die zur Auswahl der Templates dienen, werden alle im Projekt erreichbaren Visualisierungen angezeigt, die zum jeweiligen Template-Typ passen. Im unteren Bereich des Dialogs wird die minimale Größe der Visualisierungsbilder sowie der Abstand der angeordneten Geräte zueinander eingestellt. " }, 
{ "title" : "CFC-Programmgenerator ", 
"url" : "ac_generator_configuration.html#UUID-fdaff0f3-814e-b71a-bcac-a2994393c9ed", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Generatorkonfiguration \/ CFC-Programmgenerator ", 
"snippet" : "Der CFC-Generator wird verwendet um CFC-Programme zu erzeugen. Immer alle CFC-Pins neu erzeugen : : Für Modul-Instanz-FB-Aufrufe wird immer versucht, alle E\/As des Modul-FBs zu generieren....", 
"body" : "Der CFC-Generator wird verwendet um CFC-Programme zu erzeugen. Immer alle CFC-Pins neu erzeugen : : Für Modul-Instanz-FB-Aufrufe wird immer versucht, alle E\/As des Modul-FBs zu generieren. " }, 
{ "title" : "Visualisierungsgenerator ", 
"url" : "ac_generator_configuration.html#UUID-a364420f-f798-9fe6-3c1a-b98bc7c07391", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Generatorkonfiguration \/ Visualisierungsgenerator ", 
"snippet" : "Dieser Generator erzeugt aus im CODESYS -Projekt verfügbaren Visualisierungen Visualisierungsbilder für den CODESYS Application Composer . Toplevel-Name : Tragen Sie einen symbolischen Namen für die bei Vorlage ausgewählte Visualisierungsvorlage (\"Toplevelvorlage“) ein. Vorlage : Die Auswahlliste en...", 
"body" : "Dieser Generator erzeugt aus im CODESYS -Projekt verfügbaren Visualisierungen Visualisierungsbilder für den CODESYS Application Composer . Toplevel-Name : Tragen Sie einen symbolischen Namen für die bei Vorlage ausgewählte Visualisierungsvorlage (\"Toplevelvorlage“) ein. Vorlage : Die Auswahlliste enthält alle verfügbaren (aus dem Projekt und den geladenen Bibliotheken) und kompatiblen Visualisierungen. Wenn Sie Default einstellen, wird die Standardvorlage aus der Bibliothek AC_Module verwendet. Falls eine Vorlage, die in diesem Dialog konfiguriert ist, später vom Projekt oder der Bibliothek gelöscht wird, bleibt sie in diesem Dialog verfügbar. TargetVisu , WebVisu : Aktivieren Sie die jeweilige Option, wenn die ausgewählte Vorlage für diese Darstellungsvariante verwendet werden soll. Breite : Breite der erzeugten Visualisierung in Pixel (Standardwert: 640, minimal 100, maximal 10000) Höhe : Höhe der erzeugten Visualisierung in Pixel (Standardwert: 640, minimal 100, maximal 10000) Minimale ToplevelTab-Breite : Minimale Breite für die erzeugten Toplevel-Tabs in Pixel. Wenn hier 0 eingetragen ist, wird die Einstellung nicht berücksichtigt. Maximale ToplevelTab-Breite : Maximale Breite für die erzeugten Toplevel-Tabs in Pixel. Wenn hier 0 eingetragen ist, wird die Einstellung nicht berücksichtigt. Für weitere Informationen zu Toplevelvorlagen siehe: ToplevelvorlagenMaximale Anzahl von Clients : Maximale Anzahl von gleichzeitig verwendeten Darstellungsvarianten, die unterstützt werden (Standardwert 8, minimal 1, maximal 128). Erzeugte Visus ignorieren, falls SVN verfügbar ist : Wenn das Projekt in SVN verwaltet wird, sollte diese Option aktiviert sein. : CODESYS stellt sicher, dass die erzeugten Visualisierungen in SVN ignoriert werden. Andernfalls kann es zu Problemen kommen. Bei Neugenerierung Visus neu erzeugen : : Bei jeder Codeerzeugung werden auch alle Visualisierungen neu erzeugt und die bereits bestehenden Visualisierungen überschrieben. Diese Option sollte gewählt werden, wenn nicht gewünscht ist, dass der Modul-Benutzer nach dem Generieren noch Veränderungen an den erzeugten Visus vornimmt. Sind jedoch nach der Generierung noch Änderungen an den Visulisierungen notwendig, dann sollte die Option deaktiviert werden. Dann versucht CODESYS die nachträglichen Änderungen auch bei den Neugenerierungen beizubehalten. Instanznamen als Standardeinstellung für Toplevelreiter verwenden : : Anstelle des kompletten Instanzpfads wird nur der Instanzname im Toplevelreiter angezeigt. Wenn ein Fehler in der Konfiguration vorliegt, wird dieser über ein Error-Provider-Icon angezeigt und die Schaltfläche OK ist deaktiviert. " }, 
{ "title" : "Befehl: Einlesen ", 
"url" : "ac_scan.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Einlesen ", 
"snippet" : "Einlesen Symbol: Dieser Befehl (Kategorie \"Composer“) durchsucht das gesamte Projekt nach Moduldeklarationen. Normalerweise wird diese Funktion nicht benötigt, da CODESYS das System bei Bedarf automatisch durchsucht (beispielsweise nach der Installation einer neuer Bibliothek)....", 
"body" : "Einlesen Symbol: Dieser Befehl (Kategorie \"Composer“) durchsucht das gesamte Projekt nach Moduldeklarationen. Normalerweise wird diese Funktion nicht benötigt, da CODESYS das System bei Bedarf automatisch durchsucht (beispielsweise nach der Installation einer neuer Bibliothek). " }, 
{ "title" : "Befehl: Alle Poolobjekte prüfen und durchsuchen ", 
"url" : "_ac_cmd_check_and_scan_all_pool_objects.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Alle Poolobjekte prüfen und durchsuchen ", 
"snippet" : "Alle Poolobjekte prüfen und durchsuchen Funktion : Bei Aufruf des Befehls wird erst der IEC-Code einer Bibliothek geprüft und diese danach nach Moduldeklarationen durchsucht. Der Prüflauf entspricht dem Befehl LÜberprüfe alle Poolobjekte . Der Suchlauf entspricht dem Befehl Einlesen. Aufruf : Menü C...", 
"body" : "Alle Poolobjekte prüfen und durchsuchen Funktion : Bei Aufruf des Befehls wird erst der IEC-Code einer Bibliothek geprüft und diese danach nach Moduldeklarationen durchsucht. Der Prüflauf entspricht dem Befehl LÜberprüfe alle Poolobjekte . Der Suchlauf entspricht dem Befehl Einlesen. Aufruf : Menü Composer Voraussetzung : Der Befehl ist nur sichtbar, wenn ein Bibliotheksprojekt geöffnet ist. " }, 
{ "title" : "Befehl: E\/As verbinden ", 
"url" : "ac_map_channels_for_ioconfig.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: E\/As verbinden ", 
"snippet" : "E\/As verbinden Symbol: Dieser Befehl (Kategorie \"Composer“) öffnet einen Dialog zur Definition der Zuordnung zwischen Modulen und E\/A -Konfiguration. Dialog E\/A-Zuordung Auf der linken Seite des Dialogs sind alle Ein- und Ausgänge der Module in einer Baumstruktur gemäß des Modulbaums dargestellt. Au...", 
"body" : "E\/As verbinden Symbol: Dieser Befehl (Kategorie \"Composer“) öffnet einen Dialog zur Definition der Zuordnung zwischen Modulen und E\/A -Konfiguration. Dialog E\/A-Zuordung Auf der linken Seite des Dialogs sind alle Ein- und Ausgänge der Module in einer Baumstruktur gemäß des Modulbaums dargestellt. Auf der rechten Seite ist die Baustruktur des Gerätebaums dargestellt. Die Verbindung der Toplevelmodule zu den Applikationen ist gemäß den Einstellungen der Toplevelmodule gezeichnet. Diese Verbindung kann in diesem Dialog nicht geändert werden. Eingänge sind mit einer grünen Verbindung und einem grünen Pfeil gezeichnet - Ausgänge sind in rot gezeichnet. Offene Eingänge oder Ausgänge (ohne Verbindung) sind mit einer gestrichelten Linie dargestellt. Im Falle, dass der Ein-\/Ausgang einem ST-Ausdruck zugewiesen wurde, wird die Verbindung mit einem \"ST“ dargestellt. Verbindungen zwischen Modulen und Geräten sind nur von Eingang zu Eingang und Ausgang zu Ausgang möglich. Weiterhin müssen beide Verbindungen einen kompatiblen Datentyp haben. Verbindungen zwischen Modulen sind nur von Eingang zu Ausgang und umgekehrt möglich. Verbindung zwischen Geräten sind nicht erlaubt. Um eine Verbindung zu erzeugen, muss der offene Eingang oder Ausgang angewählt werden. Ein angewähltes Element wird mit blauem Hintergrund dargestellt. Die Ein- und Ausgänge werden mit Drag & Drop verbunden. Ein gültiges bzw. ungütiges Verbindungsziel wird mit unterschiedlichen Mauszeigern gekennzeichnet. Wenn das gewünschte Ziel bereits verbunden ist, wird diese Verbindung ersetzt. Wenn Geräte oder Module kollabiert werden, dann wechelst die Farbe auf schwarz, da die Datenrichtung eventuell nicht mehr eindeutig ist Wird noch weiter kollabiert (also z.B. das übergeordnete Gerät) dann werden auch die Verbindungen ausgeblendet. Dies dient zur besseren Übersicht, da damit im mittleren Bereich die Liniendichte reduziert werden kann Sobald eine Verbindung links oder rechts angeklickt wird und auf der anderen Seite das Gerät kollabiert ist, wird das dazugehörige Gerät automatisch aufgeklappt Pfeile zeigen die jeweilige Datenrichtung an, bei einem kollabiertem Gerät wird sowohl ein grüner als auch roter Pfeil angezeigt, wenn das Gerät sowohl Ein- als auch Ausgänge besitzt. Sind nur Ein- oder Ausgänge vorhanden, dann wird nur die jeweilige Datenrichtung auch im kollabiertem Zustand angezeigt. Im Online-Betrieb werden die Werte der Parameters auf der linken Seite angezeigt. Die Werte können in dieser Ansicht nicht geändert werden. Ein Doppelklick auf Geräte oder Module öffnet den jeweiligen Editor. Verbindungen können auch über die Grenzen von Applikationen hinaus gesetzt werden! Wenn eine Modulinstanz mit dem POU-Pool verbunden ist, wird die Verbindungslinie grau gezeichnet. Dann ist es nicht möglich, E\/As zu verbinden; bestehende Verbindungen können jedoch gelöscht werden. Drucken : Dieser Befehl ermöglicht das Drucken der gesamten E\/A-Zuordnung in Übersichtsform. " }, 
{ "title" : "Befehl: Wildcard-Zuweisung ", 
"url" : "ac_wildcard_selection.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Wildcard-Zuweisung ", 
"snippet" : "Wildcard-Zuweisung Dieser Befehl (Kategorie \"Composer“) öffnet den Dialog Wildcard-Zuweisung . Der obere Teil des Dialogs zeigt die aktuell konfigurierten Wildcards mit den ihnen zugeordneten Gerätetypen. Im unteren Teil des Dialogs wird das Geräte-Repository dargestellt, das installierte Geräte zur...", 
"body" : "Wildcard-Zuweisung Dieser Befehl (Kategorie \"Composer“) öffnet den Dialog Wildcard-Zuweisung . Der obere Teil des Dialogs zeigt die aktuell konfigurierten Wildcards mit den ihnen zugeordneten Gerätetypen. Im unteren Teil des Dialogs wird das Geräte-Repository dargestellt, das installierte Geräte zur Auswahl anbietet. Sie können die Zuordnungen im Dialog bearbeiten. Der Dialog erscheint zu diesem Zweck auch beim Geräte-Generieren, wenn Wildcards nicht automatisch Gerätetypen zugewiesen werden konnten und manuelle Zuweisung nötig ist. Die Zuordnung der Wildcards zu den Gerätetypen wird im Projekt abgelegt, kann aber auch mit Hilfe eigens angelegter XML-Dateien außerhalb gespeichert und von dort geladen werden. Datei und Pfad werden ganz oben im Dialog angezeigt. Dialog Wildcard-Auswahl ‘ Neu : Mit diesem Befehl können Sie eine neue (leere) XML-Datei für die Wildcard-Zuweisung anlegen. Legen Sie Dateiname und Verzeichnis fest. Speichern : Dieser Befehl speichert die aktuell festgelegte Wildcard-Geräte-Zuweisung explizit in eine ausgewählte Datei. Die Zuweisungen werden zudem automatisch in die angegebene XML-Datei gespeichert, sobald der Dialog mit OK beendet wird. Laden : Mit diesem Befehl können Sie eine bestehende Wildcard-Zuweisungsdatei (XML) laden. In der farblich hinterlegten Baumansicht zeigt die Spalte Geräte-ID (Modulname) die IDs der Geräte des Gerätegenerators , welche Wildcards verwenden. Der Name der Modulinstanz, welche dieses Gerät mitbringt, wird in Klammern angezeigt. Im Fall von statisch eingefügten Geräten des Geräte-Generators (definiert durch die Moduldeklaration Identification und nicht Wildcard \/ FlexibleWildcard ) wird der Standardknoten Statisch erzeugt, welcher alle statisch eingefügten Geräte enthält. Statische Geräte können nicht geändert werden. Die Spalte Beziehungen zeigt die Beziehung zwischen Eltern- und Kindgeräten des Gerätegenerators. Dabei zeigt eine fettgedruckte Linie eine fixe Beziehung, eine gestrichelte Linie einen Vorschlag für eine Beziehung. Der Vorschlag basiert auf der Definition der ParentID in der Sektion Device . Sie können eine Wildcard auch als leer markieren, indem Sie die betreffende Zeile selektieren und die Entf -Taste drücken. Eine leere Wildcard kann dazu dienen, eine vorgegebene Elter-Kind-Gerätebeziehung zu verändern. Geräten zugewiesene sowie leer zugewiesene Wildcards werden grün hinterlegt dargestellt, nicht zugewiesene Wildcards erscheinen rot hinterlegt. Nur Kompatibilitäten zur ersten Generation der möglichen Elterngeräte anzeigen : Wenn diese Option aktiviert ist, dann wird die Geräteauswahl in der Ansicht des Geräte-Repositorys auf diejenigen Geräte eingeschränkt, die unter das erste Eltern-Gerät der Wildcard passen. Dies wird durch die Moduldeklaration festgelegt. Wenn diese Option nicht aktiviert ist, werden auch Eltern der zweiten, dritten, …, n-ten Generation als mögliche Eltern bewertet und in der Auswahl dargestellt. Regeln für die Zuweisung der Eigenschaften Wird auf der linken Seite ein Gerät, E\/A-Kanal oder FB-Instanz ausgewählt, werden alle Eigenschaften die diesem Gerät, E\/A-Kanal oder FB-Instanz bis jetzt zugeordnet sind mit einem Haken markiert. Geräte auf der linken Seite, für die nicht allen E\/A-Kanälen oder FB-Instanzen Eigenschaften zugeordnet sind werden zusammen mit dem entsprechenden E\/A-Kanal bzw. FB-Instanz rot hinterlegt. Geräte, für die alle E\/A-Kanäle und FB-Instanzen zugeordnet sind, werden, so wie die bekannten E\/A-Kanäle und FB-Instanzen, grün hinterlegt. Als Zuordnung gilt auch das Zuweisen keiner „Demanding“-Eigenschaft. Letzteres kann für ein komplettes Gerät durch Doppelklicken auf einen Geräte-Knoten für das gesamte Gerät mit all seinen E\/A-Kanälen und FB-Instanzen erreicht werden. Eigenschaften auf der rechten Seite können durch Setzen des Hakens den \"Offering“-Eigenschaften des links ausgewählten Gerätes, E\/A-Kanals oder FB-Instanz hinzugefügt werden. Einem Gerät, E\/A-Kanal oder FB-Instanz können beliebig viele Eigenschaften oder keine zugeordnet werden. Wird einem Geräte-Knoten eine \"Demanding“-E\/A-Eigenschaft zugeordnet, wird diese Eigenschaft allen Kind-E\/A-Kanal-Knoten dieses Geräte-Knotens zugeordnet, den FB-Instanzen aber nicht. Gleichermaßen gilt, dass, falls einem Gerät eine „Demanding“-InstRef-Eigenschaft zugeordnet wird, nur den Kind-FB-Instanzen dieses Geräts diese Eigenschaft zugewiesen wird. Es können mehrere Geräte, E\/A-Kanäle oder FB-Instanzen gleichzeitig selektiert werden, denen dann jeweils allen die gewählten Eigenschaften zugeordnet werden, so wie dies möglich ist. \"Demanding“-Eigenschaften auf der rechten Seite, die mindestens einmal in den \"Offering“-Eigenschaften irgend eines der Geräte auf der linken Seite auftauchen, werden grün hinterlegt. \"Demanding“-Eigenschaften, die bis jetzt in keinem Gerät der linken Seite unter den \"Offering“-Eigenschaften auftauchen, werden rot hinterlegt. " }, 
{ "title" : "Zuweisen der Wildcards ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_342a92346a13602cc0a8640e00a6970a", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Wildcard-Zuweisung \/ Zuweisen der Wildcards ", 
"snippet" : "Es gibt zwei Wege, eine Wildcard zuzuweisen: Klicken Sie oben im Dialog in der Zeile der Wildcard, die zugewiesen werden soll, in das Feld in Spalte Ausgewählte Geräte . Doppelklicken Sie dann unten in der Ansicht des Geräte-Repositorys auf das gewünschte Gerät. Wählen Sie unten in der Ansicht des G...", 
"body" : "Es gibt zwei Wege, eine Wildcard zuzuweisen: Klicken Sie oben im Dialog in der Zeile der Wildcard, die zugewiesen werden soll, in das Feld in Spalte Ausgewählte Geräte . Doppelklicken Sie dann unten in der Ansicht des Geräte-Repositorys auf das gewünschte Gerät. Wählen Sie unten in der Ansicht des Geräte-Repositorys das gewünschte Gerät aus. Doppelklicken Sie dann oben in der Zeile der Wildcard in das Feld in Spalte Ausgewählte Geräte . " }, 
{ "title" : "Zuweisung Geräteeigenschaft ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_4703909473b5f037c0a8640e01022fbe", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Wildcard-Zuweisung \/ Zuweisung Geräteeigenschaft ", 
"snippet" : "Der Befehl Zuweisung Geräteeigenschaft öffnet den einen Dialog, in welchem die Zuordnung von \" Offering “-Eigenschaften zu tatsächlichen Geräte-Typen stattfindet. Dialog Zuweisung Geräteeigenschaft Auf der linken Seite des Dialogs werden alle generierten Geräte, welche im Projekt verwendet werden, a...", 
"body" : "Der Befehl Zuweisung Geräteeigenschaft öffnet den einen Dialog, in welchem die Zuordnung von \" Offering “-Eigenschaften zu tatsächlichen Geräte-Typen stattfindet. Dialog Zuweisung Geräteeigenschaft Auf der linken Seite des Dialogs werden alle generierten Geräte, welche im Projekt verwendet werden, angezeigt. Die Kindknoten dieser Geräte zeigen alle Eingänge, Ausgänge (nicht fett) und erzeugte Funktionsbausteine (fett) des zugehörigen Gerätetyps. Die rechte Seite zeigt alle \"Demanding“-Eigenschaften an, welche in der Moduldeklaration der verwendeten Module als \" Demanding “ E\/As definiert sind. Die Kindknoten dieser \"Demandings“ entspricht allen Modul-E\/As, welche die \"Demandings“ ihrer Elternknoten erfordern. Der „Zuweisung Geräteeigenschaften“-Dialog wird verwendet um die Eigenschaften der rechten Seite den Geräten und ihren E\/A-Kanälen zuzuweisen. Die Zuweisung wird neben den Gerätebeschreibungen der Geräte in einer zusätzlichen Datei gespeichert und wird von diesen Gerätebeschreibungen referenziert. Der Dialog öffnet sich automatisch beim Generieren, wenn nicht alle \"Demanding“-Eigenschaften mindesten einmal von einem Gerät mit seinen \"Offering“-Eigenschaften abgedeckt werden. " }, 
{ "title" : "Befehl: Verbindungen zu E\/As entfernen ", 
"url" : "ac_remove_connections_to_ios.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Verbindungen zu E\/As entfernen ", 
"snippet" : "Verbindungen zu E\/As entfernen Dieser Befehl (Kategorie \"Composer“) entfernt Verbindungen zu E\/As. Dabei stehen folgende Unterbefehle zur Verfügung: Alle erzeugten : Entfernt die automatisch erzeugten Verbindungen. Manuell hinzugefügte Verbindungen bleiben erhalten Alle : Entfernt alle Verbindungen ...", 
"body" : "Verbindungen zu E\/As entfernen Dieser Befehl (Kategorie \"Composer“) entfernt Verbindungen zu E\/As. Dabei stehen folgende Unterbefehle zur Verfügung: Alle erzeugten : Entfernt die automatisch erzeugten Verbindungen. Manuell hinzugefügte Verbindungen bleiben erhalten Alle : Entfernt alle Verbindungen - automatisch erzeugte und manuell hinzugefügte Verbindungen. Alle erzeugten der Modulinstanz : Der Befehl steht zur Verfügung, wenn eine Modulinstanz im Modulbaum selektiert ist. Er entfernt die automatisch erzeugten Verbindungen dieser Instanz. Manuell hinzugefügte Verbindungen dieser Instanz bleiben erhalten. Alle der Modulinstanz : Der Befehl steht zur Verfügung, wenn eine Modulinstanz im Modulbaum selektiert ist. Er entfernt alle Verbindungen dieser Instanz - automatisch erzeugte und manuell hinzugefügte Verbindungen. " }, 
{ "title" : "Befehl: Toplevelinstanz hinzufügen ", 
"url" : "ac_add_toplevel_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Toplevelinstanz hinzufügen ", 
"snippet" : "Toplevelinstanz hinzufügen Der Befehl (Kategorie \"Composer“) öffnet den Moduldialog , welcher alle Toplevelmodule anbietet, die zum Modulbaum hinzugefügt werden können. Es gibt keine Begrenzung der Anzahl der Toplevelmodulen, welche zu einer Applikation hinzugefügt werden können....", 
"body" : "Toplevelinstanz hinzufügen Der Befehl (Kategorie \"Composer“) öffnet den Moduldialog , welcher alle Toplevelmodule anbietet, die zum Modulbaum hinzugefügt werden können. Es gibt keine Begrenzung der Anzahl der Toplevelmodulen, welche zu einer Applikation hinzugefügt werden können. " }, 
{ "title" : "Befehl: Submodulinstanz hinzufügen ", 
"url" : "ac_add_submodule_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Submodulinstanz hinzufügen ", 
"snippet" : "Submodulinstanz hinzufügen Der Befehl (Kategorie \"Composer“) öffnet den Moduldialog , welcher alle Submodule anbietet, die an der ausgewählten Stelle im Modulbaum hinzugefügt werden können. Bei Submodulen, welche obligatorische Slots für Modulrefrerenzen anbieten, können alle eindeutigen Referenz-Sl...", 
"body" : "Submodulinstanz hinzufügen Der Befehl (Kategorie \"Composer“) öffnet den Moduldialog , welcher alle Submodule anbietet, die an der ausgewählten Stelle im Modulbaum hinzugefügt werden können. Bei Submodulen, welche obligatorische Slots für Modulrefrerenzen anbieten, können alle eindeutigen Referenz-Slots automatisch belegt werden. In diesem Fall wird der Anwender durch einen Dialog gefragt, ob dies automatisch erfolgen soll. " }, 
{ "title" : "Befehl: Modulinstanz referenzieren ", 
"url" : "ac_reference_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Modulinstanz referenzieren ", 
"snippet" : "Modulinstanz referenzieren Der Befehl (Kategorie \"Composer“) öffnet den Moduldialog , welcher alle Module anbietet, die an der ausgewählten Stelle im Modulbaum referenziert werden können....", 
"body" : "Modulinstanz referenzieren Der Befehl (Kategorie \"Composer“) öffnet den Moduldialog , welcher alle Module anbietet, die an der ausgewählten Stelle im Modulbaum referenziert werden können. " }, 
{ "title" : "Befehl: Ansicht Modulreferenzen anzeigen ", 
"url" : "ac_module_references_editor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Ansicht Modulreferenzen anzeigen ", 
"snippet" : "Ansicht Modulreferenzen anzeigen Dieser Befehl (Kategorie \"Composer“) öffnet die Ansicht Modulreferenzen und gibt darin einen Überblick über die Verwendung von Modulinstanzen im Projekt. Der Befehl ist im Kontextmenü verfügbar, wenn eine Modulinstanz im Modulbaum selektiert ist. Bei geöffneter Ansic...", 
"body" : "Ansicht Modulreferenzen anzeigen Dieser Befehl (Kategorie \"Composer“) öffnet die Ansicht Modulreferenzen und gibt darin einen Überblick über die Verwendung von Modulinstanzen im Projekt. Der Befehl ist im Kontextmenü verfügbar, wenn eine Modulinstanz im Modulbaum selektiert ist. Bei geöffneter Ansicht aktualisiert sich diese automatisch, wenn eine andere Modulinstanz ausgewählt wird oder sich die Referenzen der gerade dargestellten Instanz ändern. " }, 
{ "title" : "Ansicht: Modulreferenzen ", 
"url" : "ac_module_references_editor.html#UUID-7a9e7bcf-5b4a-4286-24df-e6cd7795a03a_c2a0935773056bc0a86463423a2ab0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Ansicht Modulreferenzen anzeigen \/ Ansicht: Modulreferenzen ", 
"snippet" : "Applikation \/ Referenzpunkt Referenzen nach Applikation sortiert Rolle des Referenzslots Rolle, die die Instanz an dem Referenzpunkt erfüllt...", 
"body" : "Applikation \/ Referenzpunkt Referenzen nach Applikation sortiert Rolle des Referenzslots Rolle, die die Instanz an dem Referenzpunkt erfüllt " }, 
{ "title" : "Befehl: Module aktualisieren ", 
"url" : "ac_update_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Module aktualisieren ", 
"snippet" : "Module aktualisieren Dieser Befehl (Kategorie \"Composer“) öffnet den Moduldialog . Der Modulbaum bietet alle Module an, die zu der ausgewählten Steckplatz der Instanz im Modulbaum kompatibel sind und nicht toplevel sind. Mit diesem Befehl kann eine Modulinstanz auf einen neuen Modultyp aktualisiert ...", 
"body" : "Module aktualisieren Dieser Befehl (Kategorie \"Composer“) öffnet den Moduldialog . Der Modulbaum bietet alle Module an, die zu der ausgewählten Steckplatz der Instanz im Modulbaum kompatibel sind und nicht toplevel sind. Mit diesem Befehl kann eine Modulinstanz auf einen neuen Modultyp aktualisiert werden. Dies kann auch eine neue Version desselben Modultyps sein. Beim Update werden die konfigurierten Daten der Instanz soweit als möglich erhalten: Parameterwerte von Parametern, die im neuen Modul vorhanden sind, werden übernommen, auch wenn der aktuelle Wert mit dem neuen Parametertyp nicht kompatibel ist. Wenn ein Parameterwert in der Instanz auf dem Defaultwert steht und nicht explizit gesetzt wurde, dann wird der Defaultwert des neuen Moduls verwendet. E\/A Zuordnungen von E\/As, die im neuen Module vorhanden sind und dort dieselbe Richtung (Eingang bzw. Ausgang) haben wie die Zuordnung in der Instanz, werden übernommen. Die Zuordnung muss nicht typrichtig mit dem neuen E\/A sein um übernommen zu werden. Taskzuordnungen, die in beiden Versionen vorhanden sind, werden übernommen. Unterinstanzen oder Referenzen von Steckplätzen, die im neuen Modul dieselbe Slot-Id haben, werden samt Unterinstanzen oder Referenzen beibehalten. Dies gilt auch dann, wenn der Typ der Unterinstanzen oder Referenzen nicht mit dem neuen Steckplatz übereinstimmt, oder wenn die Stelligkeit des neuen Steckplatz nicht alle Unterinstanzen oder Referenzen erlaubt. Unterinstanzen oder Referenzen von Steckplätzen, die im neuen Modul nicht vorhanden sind, werden unter einen neuen Slot mit Namen \"Verwaiste Instanzen“ oder \"Verwaiste Referenzen“ gehängt . Diese Slots werden über spezielle Identifier gekennzeichnet, die bei normalen Slots nicht vorkommen können. Existiert bereits ein Slot für verwaiste Elemente wird dieser verwendet. Unterinstanzen oder Referenzen von Steckplätzen, die im neuen Modul zwar vorhanden sind, aber (bei Unterinstanzen) jetzt Referenzen erwarten oder (bei Referenzen) jetzt Unterinstanzen erwarten, werden behandelt wie Unterinstanzen oder Referenzen, deren Steckplatz im neuen Modul nicht vorhanden ist. Die Toplevelinformationen werden, falls in der Instanz vorhanden, gelöscht, wenn auf ein nicht Toplevelmodul aktualisiert wird. Falls umgekehrt keine Toplevelinformationen in der Instanz vorhanden sind, aber auf ein Toplevelmodul aktualisiert wird, werden sie angelegt. Durch Erweiterungen definierte Instanzdaten: Die jeweilige Erweiterung bestimmt, welche Daten erhalten bleiben und welche gelöscht werden. Sie sollte sich an das Prinzip halten, möglichst viele Daten zu erhalten. Hat sich die Reihenfolge der Slots im neuen Modul geändert, so wird auch die Reihenfolge der Slots unter der Instanz entsprechend angepasst. Wenn durch das Update Daten gelöscht würden (zum Beispiel Parameterwerte, E\/A-Zuordnungen, nicht-leere Slots oder erweitere Instanzdaten), wird eine Meldung angezeigt, die beschreibt, welche Objekte gelöscht werden und die es dem Anwender ermöglicht, das Update abzubrechen. Das Update einer Instanz kann mit einem einzigen Undo-Schritt im Modulbaum rückgängig gemacht werden. " }, 
{ "title" : "Befehl: Alle Instanzen aktualisieren ", 
"url" : "ac_update_all_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Alle Instanzen aktualisieren ", 
"snippet" : "Alle Instanzen aktualisieren Mit diesem Befehl (Kategorie \"Composer“) können alle Modulinstanzen mit einem Befehl auf eine neue Version aktualisiert werden. Dieser Befehl ist im Kontextmenü nicht verfügbar. Das Verhalten dieses Befehls entspricht der Beschreibung des Befehls Module aktualisieren , w...", 
"body" : "Alle Instanzen aktualisieren Mit diesem Befehl (Kategorie \"Composer“) können alle Modulinstanzen mit einem Befehl auf eine neue Version aktualisiert werden. Dieser Befehl ist im Kontextmenü nicht verfügbar. Das Verhalten dieses Befehls entspricht der Beschreibung des Befehls Module aktualisieren , wobei eine Aktualisierung auf ein anderes Modul nicht möglich ist. " }, 
{ "title" : "Befehl: Leere optionale Steckplätze ausblenden: Alle\/Nur selektierte ", 
"url" : "ac_hide_empty_optional_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Leere optionale Steckplätze ausblenden: Alle\/Nur selektierte ", 
"snippet" : "Leere optionale Steckplätze ausblenden: Alle\/Nur selektierte Mit diesen Befehlen (Kategorie \"Composer“) können Sie für alle Submodule, oder nur für das gerade selektierte Submodul die leeren optionalen Steckplätze ausblenden. Notwendige Steckplätze können nicht ausgeblendet werden. Beispiel für leer...", 
"body" : "Leere optionale Steckplätze ausblenden: Alle\/Nur selektierte Mit diesen Befehlen (Kategorie \"Composer“) können Sie für alle Submodule, oder nur für das gerade selektierte Submodul die leeren optionalen Steckplätze ausblenden. Notwendige Steckplätze können nicht ausgeblendet werden. Beispiel für leere optionale Steckplätze Um ausgeblendete Steckplätze wieder sichtbar zu machen, verwenden Sie bitte den Befehl Zeige ausgeblendete Steckplätze - Alle\/Nur selektierte . " }, 
{ "title" : "Befehl: Ausgeblendete Steckplätze anzeigen: Alle\/Nur selektierte ", 
"url" : "ac_show_hidden_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Ausgeblendete Steckplätze anzeigen: Alle\/Nur selektierte ", 
"snippet" : "Ausgeblendete Steckplätze anzeigen: Alle\/Nur selektierte Mit diesen Befehlen (Kategorie \"Composer“) können Sie für alle Submodule, oder nur für das gerade selektierte Submodul die ausgeblendeten Steckplätze im Modulbaum wieder einblenden. Um Steckplätze auszublenden, verwenden Sie bitte den Befehl L...", 
"body" : "Ausgeblendete Steckplätze anzeigen: Alle\/Nur selektierte Mit diesen Befehlen (Kategorie \"Composer“) können Sie für alle Submodule, oder nur für das gerade selektierte Submodul die ausgeblendeten Steckplätze im Modulbaum wieder einblenden. Um Steckplätze auszublenden, verwenden Sie bitte den Befehl Leere optionale Steckplätze ausblenden - Alle\/Nur selektierte . " }, 
{ "title" : "Befehl: Gehe zu Ziel ", 
"url" : "ac_go_to_target.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Gehe zu Ziel ", 
"snippet" : "Gehe zu Ziel Dieser Befehl (Kategorie „Composer“) ist nur verfügbar, wenn eine Modulreferenz im Modulbaum selektiert ist. Wird der Befehl ausgeführt, so wird das referenzierte Modul im Modulbaum angezeigt....", 
"body" : "Gehe zu Ziel Dieser Befehl (Kategorie „Composer“) ist nur verfügbar, wenn eine Modulreferenz im Modulbaum selektiert ist. Wird der Befehl ausgeführt, so wird das referenzierte Modul im Modulbaum angezeigt. " }, 
{ "title" : "Befehl: Erweiterungsmodule erzeugen ", 
"url" : "_ac_cmd_create_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Erweiterungsmodule erzeugen ", 
"snippet" : "Erweiterungsmodule erzeugen Symbol: Der Befehl erzeugt ein Erweiterungsmodul an einem Submodul-Steckplatz. Er ist nur verfügbar, wenn ein leerer Modul-Steckplatz oder Submodul-Steckplatz im Modulbaum angewählt ist. Der Befehl öffnet einen Dialog in dem Sie festlegen, ob die Erweiterung als neues Mod...", 
"body" : "Erweiterungsmodule erzeugen Symbol: Der Befehl erzeugt ein Erweiterungsmodul an einem Submodul-Steckplatz. Er ist nur verfügbar, wenn ein leerer Modul-Steckplatz oder Submodul-Steckplatz im Modulbaum angewählt ist. Der Befehl öffnet einen Dialog in dem Sie festlegen, ob die Erweiterung als neues Modul („Keine Variation“) oder als Variation eines bestehenden Moduls angelegt wird. Dazu werden alle Module, die unter den Slot passen, in einer Auswahlliste angeboten. Zwei Optionen stehen zur Verfügung: Variation ableiten Das Erweiterungsmodul wird von dem unter Variation von gewählten Modul abgeleitet. Das gewählte Modul wird über IMPORTS “ in das Erweiterungsmodul importiert und der Funktionsbaustein des neuen Moduls wird von dem Modul-Vorlagen-Funktionsbaustein abgeleitet. Copy source for Variation Es wird ein Erweiterungsmodul erzeugt, indem die gesamte Moduldeklaration inklusive des Funktionsbausteins und der zugehörigen Visualisierungen von dem unter Variation von gewählten Modul kopiert wird (inkl. Quellcodes). Dies ist nur möglich, wenn das unter Variation von gewählte Modul im Quellcode vorhanden ist und nicht nur als Modul in einer Compiled-Library. Erweiterungsmodule dienen dazu, anwendungsspezifische Änderungen oder Erweiterungen zu den bestehenden und vordefinierten Modulen oder Modulinstanzen hinzuzufügen. Nach dem Schließen des Dialogs mit OK wird ein neuer Ordner mit dem Namen des Erweiterungsmodules im POUs -Pool angelegt. In diesem Ordner werden folgende Objekte angelegt (&lt;name&gt; ist der Name des Erweiterungsmoduls): Standard-Fall: Ein Funktionsbaustein mit Namen < name>, der die Klasse \"Module“ erweitert und das vom Steckplatz geforderte Interface implementiert. Unter dem FB werden alle Methoden und Properties angelegt, die in einem implementierten Interface vorkommen, aber in keiner Basisklasse implementiert sind. Variationsfall: Wie im Standard-Fall wird ein entsprechender Funktionsbaustein erzeugt. Dieser Funktionsbaustein leitet von dem gewählten Modulvorlagen-Funktionsbaustein ab ( Variation ableiten ) oder kopiert ihn ( Variation aus Quelle kopieren ). Ein Imagepool und eine Textliste (Name IP_<Name> oder TL_<Name> ). Der Imagepool enthält zwei Icons mit Bezeichner Icon_16 und Icon_32 . Die Textliste enthält den Eintrag Desc (belegt mit <name> ) Es gibt in der Textliste außer der Spalte Standard keine Sprachen. Eine leere eingebettete Visualisierung mit Namen Visu_M_<name> , die die geforderte Schnittstelle implementiert. Falls Variation aus Quelle kopieren gewählt wurde, werden statt dessen die Visualisierungen des Quellnoduls kopiert. Es wird ein Erweiterungsmodul angelegt, das keine Parameter und E\/As hat und für seine Metadaten die oben angelegten Bilder, Texte und Visualisierungen verwendet. Die Kategorie ist \"Extension“. Handelt es sich um eine \"abgeleitete“ Variation wird über IMPORTS zusätzlich die Modulvorlagen-Deklaration importiert. Wenn es sich um eine \"kopierte“ Variation handelt, dann wird die Deklaration der Modulvorlage kopiert und so angepasst, dass sie die entsprechenden Textlisten und Bildersammlungen des Erweiterungsmoduls verwendet. " }, 
{ "title" : "Befehl: Fehlende Textlisteneinträge erzeugen ", 
"url" : "ac_create_missing_textlist_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Fehlende Textlisteneinträge erzeugen ", 
"snippet" : "Fehlende Textlisteneinträge erzeugen Dieser Befehl (Kategorie \"Composer“) erzeugt automatisch alle Textlisten und Textlisteneinträge, die von einer Modulbeschreibung referenziert werden, sofern sie nicht bereits existieren. Der Befehl ist nur im Menü sichtbar und nur aktivierbar, wenn ein Moduldekla...", 
"body" : "Fehlende Textlisteneinträge erzeugen Dieser Befehl (Kategorie \"Composer“) erzeugt automatisch alle Textlisten und Textlisteneinträge, die von einer Modulbeschreibung referenziert werden, sofern sie nicht bereits existieren. Der Befehl ist nur im Menü sichtbar und nur aktivierbar, wenn ein Moduldeklarations-Editor den Fokus hat und das editierte Objekt im primären Projekt liegt. Der Befehl hat nur einen Effekt, wenn die Eingabe ohne Syntaxfehler ist. Textlisten werden unter demselben Vater-Objekt wie das editierte Objekt angelegt. Bei neu angelegten Einträgen wird nur der \"Default“-Text gefüllt, und zwar mit der Id. " }, 
{ "title" : "Befehl: Fehlende Einträge in Bildersammlungen erzeugen ", 
"url" : "ac_create_missing_image_pool_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Fehlende Einträge in Bildersammlungen erzeugen ", 
"snippet" : "Fehlende Einträge in Fehlende Einträge in Bildersammlungen erzeugen Der Befehl erzeugt in einer Bildersammlung die Einträge, die in einer Modulbeschreibung definiert sind, aber noch in keiner Bildersammlung des Projekts existieren. Wenn die Bildersammlung noch nicht existiert, wird zuerst die Bilder...", 
"body" : "Fehlende Einträge in Fehlende Einträge in Bildersammlungen erzeugen Der Befehl erzeugt in einer Bildersammlung die Einträge, die in einer Modulbeschreibung definiert sind, aber noch in keiner Bildersammlung des Projekts existieren. Wenn die Bildersammlung noch nicht existiert, wird zuerst die Bildersammlung in der POUs -Ansicht erzeugt. Der Befehl ist standardmäßig nicht im Menü Composer verfügbar. Sie fügen ihn mit Hilfe des Dialogs Tool → Anpassen aus der Befehlskategorie Composer in das Menü Composer ein. Der Befehl ist dann im Menü Composer sichtbar, wenn ein Modul im Editor geöffnet ist und im Fokus liegt. " }, 
{ "title" : "Befehl: Nach oben ", 
"url" : "ac_move_up.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Nach oben ", 
"snippet" : "Nach oben Dieser Befehl (Kategorie \"Composer“) kann verwendet werden, um die Position der Modulinstanz im Modulbaum zu ändern. Der Befehl ist nur für Elemente von Mehrfachsteckplätzen verfügbar (Modulinstanzen und Referenzen) und wenn das ausgewählte Element nicht das erste Element des Mehrfachsteck...", 
"body" : "Nach oben Dieser Befehl (Kategorie \"Composer“) kann verwendet werden, um die Position der Modulinstanz im Modulbaum zu ändern. Der Befehl ist nur für Elemente von Mehrfachsteckplätzen verfügbar (Modulinstanzen und Referenzen) und wenn das ausgewählte Element nicht das erste Element des Mehrfachsteckplatzes ist. " }, 
{ "title" : "Befehl: Nach unten ", 
"url" : "ac_move_down.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Nach unten ", 
"snippet" : "Nach unten Dieser Befehl (Kategorie „Composer“) kann verwendet werden, um die Position der Modulinstanz im Modulbaum zu ändern. Der Befehl ist nur für Elemente von Mehrfachsteckplätzen verfügbar (Modulinstanzen und Referenzen) und wenn das ausgewählte Element nicht das letzte Element des Mehrfachste...", 
"body" : "Nach unten Dieser Befehl (Kategorie „Composer“) kann verwendet werden, um die Position der Modulinstanz im Modulbaum zu ändern. Der Befehl ist nur für Elemente von Mehrfachsteckplätzen verfügbar (Modulinstanzen und Referenzen) und wenn das ausgewählte Element nicht das letzte Element des Mehrfachsteckplatzes ist. " }, 
{ "title" : "Befehl: Auf unbekannte Einträge überprüfen ", 
"url" : "ac_check_for_unknown_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Auf unbekannte Einträge überprüfen ", 
"snippet" : "Auf unbekannte Einträge überprüfen Dieser Befehl (Kategorie \"Composer“) überprüft die Moduldeklarationen auf unbekannte Sektionsdefinitionen. Bei dem Unterbefehl Alle werden alle Moduldeklarationen des Projekts nach unbekannten Sektionsdefinitionen durchsucht. Wenn eine Moduldeklaration in einem Edi...", 
"body" : "Auf unbekannte Einträge überprüfen Dieser Befehl (Kategorie \"Composer“) überprüft die Moduldeklarationen auf unbekannte Sektionsdefinitionen. Bei dem Unterbefehl Alle werden alle Moduldeklarationen des Projekts nach unbekannten Sektionsdefinitionen durchsucht. Wenn eine Moduldeklaration in einem Editor sichtbar geöffnet ist, wird zusätzlich der Befehl Im aktuellen Editor angeboten, mit dem nur diese Deklaration nach unbekannten Sektionsdefinitionen durchsucht wird. " }, 
{ "title" : "Befehl: Erzeugen, Übersetzen und Einloggen ", 
"url" : "ac_generate_compile_login.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Erzeugen, Übersetzen und Einloggen ", 
"snippet" : "Erzeugen, Übersetzen und Einloggen Symbol: Dieser Befehl (Kategorie \"Composer“) führt mehrere Befehle mit einem Mausklick aus. Dabei wird zuerst Code erzeugt und übersetzt. Gegebenenfalls wird danach auf der Steuerung eingeloggt und die Applikation gestartet....", 
"body" : "Erzeugen, Übersetzen und Einloggen Symbol: Dieser Befehl (Kategorie \"Composer“) führt mehrere Befehle mit einem Mausklick aus. Dabei wird zuerst Code erzeugt und übersetzt. Gegebenenfalls wird danach auf der Steuerung eingeloggt und die Applikation gestartet. " }, 
{ "title" : "Befehl: Modulbibliothek zum Projekt hinzufügen ", 
"url" : "ac_add_libraries_to_pou.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Modulbibliothek zum Projekt hinzufügen ", 
"snippet" : "Modulbibliothek zum Projekt hinzufügen Symbol: Dieser Befehl (Kategorie \"Composer“) öffnet einen Dialog, in dem alle Bibliotheken mit Moduldefinitionen angezeigt werden. Mit Bestätigung durch OK werden die ausgewählten Bibliotheken zum Bibliotheksverwalter des POU-Pools hinzugefügt. Falls die Standa...", 
"body" : "Modulbibliothek zum Projekt hinzufügen Symbol: Dieser Befehl (Kategorie \"Composer“) öffnet einen Dialog, in dem alle Bibliotheken mit Moduldefinitionen angezeigt werden. Mit Bestätigung durch OK werden die ausgewählten Bibliotheken zum Bibliotheksverwalter des POU-Pools hinzugefügt. Falls die Standardbibliothek AC_ModlueBase des Composers fehlt, wird diese automatisch hinzugefügt. Dialog zum Hinzufügen von Application Composer Bibliotheken Über die Schaltfläche Öffne POU-Bibliotheksverwalter kann der Bibliotheksverwalter des POUx -Pools auch im Profil Composer Dedicated geöffnet werden. " }, 
{ "title" : "Befehl: Aktive Haltepunkte zum nächsten Schritt ", 
"url" : "ac_active_breakpoints_to_next_step.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Aktive Haltepunkte zum nächsten Schritt ", 
"snippet" : "Aktive Haltepunkte zum nächsten Schrit Dieser Befehl des Ablaufeditors (Kategorie \"Composer“) ist nur im Onlinebetrieb verfügbar, wenn der Ablauf an einem Haltepunkt angehalten wurde. Er entfernt den gerade aktiven Haltepunkt und fügt einen neuen zum Folgeschritt hinzu....", 
"body" : "Aktive Haltepunkte zum nächsten Schrit Dieser Befehl des Ablaufeditors (Kategorie \"Composer“) ist nur im Onlinebetrieb verfügbar, wenn der Ablauf an einem Haltepunkt angehalten wurde. Er entfernt den gerade aktiven Haltepunkt und fügt einen neuen zum Folgeschritt hinzu. " }, 
{ "title" : "Befehl: Zentriere Ansicht auf Haltepunkte ", 
"url" : "ac_center_view_to_breakpoints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Zentriere Ansicht auf Haltepunkte ", 
"snippet" : "Zentriere Ansicht auf Haltepunkte Dieser Befehl des Ablaufeditors (Kategorie \"Composer“) ist nur im Onlinebetrieb verfügbar, wenn der Ablauf an einem Haltepunkt angehalten wurde. Er zentriert die Ansicht des Ablaufeditors auf den oder die momentan aktiven Haltepunkte....", 
"body" : "Zentriere Ansicht auf Haltepunkte Dieser Befehl des Ablaufeditors (Kategorie \"Composer“) ist nur im Onlinebetrieb verfügbar, wenn der Ablauf an einem Haltepunkt angehalten wurde. Er zentriert die Ansicht des Ablaufeditors auf den oder die momentan aktiven Haltepunkte. " }, 
{ "title" : "Befehl: Makro-Module erzeugen ", 
"url" : "ac_create_macro_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Makro-Module erzeugen ", 
"snippet" : "Makro-Module erzeugen Symbol: Dieser Befehl (Kategorie \"Composer“) öffnet einen Dialog zum Erzeugen von Makro-Modulen. Für den Befehl benötigen Sie eine gültige Lizenz für das Erstellen von Moduldeklarationen . Der Befehl ist verfügbar, wenn Sie einen Unterbaum im Modulbaum selektiert haben. Sie kön...", 
"body" : "Makro-Module erzeugen Symbol: Dieser Befehl (Kategorie \"Composer“) öffnet einen Dialog zum Erzeugen von Makro-Modulen. Für den Befehl benötigen Sie eine gültige Lizenz für das Erstellen von Moduldeklarationen . Der Befehl ist verfügbar, wenn Sie einen Unterbaum im Modulbaum selektiert haben. Sie können mit dem Befehl aus den Modulen des Unterbaum ein Makro-Modul erzeugen. Dabei legen Sie fest, welche Steckplätze, welche E\/As und welche Parameter der Submodule in dem neu erzeugten Makro-Modul zur Verfügung stehen. Metadaten Name Eindeutiger Name des Makro-Moduls Makro-Beschreibung Die Beschreibung wird als Textlisteneintrag angelegt. Makro-Kategorie Die Kategorie wird verwendet um die Module im Einfügedialog für Module zu untergliedern. Steckplätze \/ EAs \/ Parameter Makro-Module Unterbaum Baumansicht aller Objekte des Unterbaums Die Struktur zeigt zusätzlich alle Steckplätze, alle EAs und alle Parameter der jeweiligen Sub-Modul-Instanz als Kinder an (fette Schrift). Makro-Module Steckplätze Anzeige aller Steckplätze, EAs und Parameter, die der Makro-Modul-Typ besitzen soll Diese Elemente kommen direkt von der linken Baumansicht. Makro-Module EAs Makro-Module Parameter Zu Makro hinzufügen Wird aktiv, wenn Sie einen Steckplätz, EA oder Parameter in der linken Baumansicht selektieren Mit einem Klick auf diese Schaltfläche fügen Sie die Elemente zum Makro-Modul hinzu. Aus Makro entfernen Wird aktiv, wenn Sie einen Steckplätz, EA oder Parameter in der rechten Baumansicht selektieren Mit einem Klick auf diese Schaltfläche entfernen Sie die Elemente vom Makro-Modul. Wenn Sie den Dialog mit OK schließen, erzeugt der CODESYS Application Composer eine Moduldeklaration, eine Textliste und eine Bildersammlung für dieses Makro-Modul. Die Objekte werden in einem Ordner mit dem Namen des Makros abgelegt. Unabhängig von der Erzeugung können Sie nun die entstandene Objekte frei editieren. Somit können Sie zum Beispiel das Icon des Makros in der Bildersammlung austauschen. " }, 
{ "title" : "Befehl: Alle Module signieren ", 
"url" : "ac_sign_all_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Alle Module signieren ", 
"snippet" : "Alle Module signieren Dieser Befehl (Kategorie \"Composer“) steht nur zur Verfügung, wenn eine gültige Lizenz des Application Composer Development Kit gefunden wurde. Mit diesem Befehl können alle Module im POUs -Pool erneut signiert werden. Module, die mit einer gültigen Lizenz entwickelt wurden, we...", 
"body" : "Alle Module signieren Dieser Befehl (Kategorie \"Composer“) steht nur zur Verfügung, wenn eine gültige Lizenz des Application Composer Development Kit gefunden wurde. Mit diesem Befehl können alle Module im POUs -Pool erneut signiert werden. Module, die mit einer gültigen Lizenz entwickelt wurden, werden automatisch signiert. Dieser Befehl ist für die Übernahme von bestehenden unsignierten Module der Application Composer Vorversionen gedacht. " }, 
{ "title" : "Befehl: Gehe zu Modul-FB ", 
"url" : "ac_goto_modul_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Gehe zu Modul-FB ", 
"snippet" : "Gehe zu Modul-FB Dieser Befehl (Kategorie \"Composer“) kann verwendet werden, um den zum Modul gehörigen Funktionsbaustein oder seine Methoden im Editor zu öffnen. Damit der Befehl verfügbar wird, müssen Sie ein Modul im Modulbaum selektieren. Im Offlinebetrieb wird die Deklaration des Funktionsbaust...", 
"body" : "Gehe zu Modul-FB Dieser Befehl (Kategorie \"Composer“) kann verwendet werden, um den zum Modul gehörigen Funktionsbaustein oder seine Methoden im Editor zu öffnen. Damit der Befehl verfügbar wird, müssen Sie ein Modul im Modulbaum selektieren. Im Offlinebetrieb wird die Deklaration des Funktionsbausteintyps oder der Funktionsbausteinmethode, die dem Modultyp entspricht, im Editor geöffnet. Im Onlinebetrieb dagegen wird die Funktionsbausteininstanz oder Methode, die zur entsprechenden Modulinstanz gehört, im Editor geöffnet. " }, 
{ "title" : "Befehl: Unterschiedliche Parameterwerte ", 
"url" : "ac_differing_parameter_values.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Unterschiedliche Parameterwerte ", 
"snippet" : "Unterschiedliche Parameterwerte Mit diesem Befehl prüfen Sie im Onlinebetrieb, ob Parameterwerte von Modulinstanzen, die im Modulbaum verwendet werden, im Modul-Funktionsbaustein verändert wurden. Wenn dies der Fall ist, werden die veränderten Parameter und die betroffenen Modulinstanzen in der Ansi...", 
"body" : "Unterschiedliche Parameterwerte Mit diesem Befehl prüfen Sie im Onlinebetrieb, ob Parameterwerte von Modulinstanzen, die im Modulbaum verwendet werden, im Modul-Funktionsbaustein verändert wurden. Wenn dies der Fall ist, werden die veränderten Parameter und die betroffenen Modulinstanzen in der Ansicht Meldungen aufgelistet. Mit einem Doppelklick auf die Meldungszeile wird der Parametereditor für die betroffene Modulinstanz geöffnet. Für die Parameter, die nun im Onlinebetrieb einen anderen Wert haben als im Offlinezustand der Applikation, sind die Zellen in Spalte Wert und Online-Wert rot umrandet. " }, 
{ "title" : "Befehl: Text der Toplevelreiter zurücksetzen ", 
"url" : "ac_reset_text_of_toplevel_tabs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Text der Toplevelreiter zurücksetzen ", 
"snippet" : "Text der Toplevelreiter zurücksetzen Funktion : Der Befehl setzt die Texte für die Toplevelreiter , die in den Moduleditoren in der Registerkarte HMI definiert wurden, auf die Voreinstellung zurück. Mit dem Befehl Composer → Text der Toplevelreiter zurücksetzen → Alle werden alle Toplevelreitertexte...", 
"body" : "Text der Toplevelreiter zurücksetzen Funktion : Der Befehl setzt die Texte für die Toplevelreiter , die in den Moduleditoren in der Registerkarte HMI definiert wurden, auf die Voreinstellung zurück. Mit dem Befehl Composer → Text der Toplevelreiter zurücksetzen → Alle werden alle Toplevelreitertexte zurückgesetzt. Mit dem Befehl Composer → Text der Toplevelreiter zurücksetzen → Nur selektierter wird nur der Text des (in Ansicht Module ) selektierten Moduls zurückgesetzt. Aktualisieren Sie danach die Applikation mit dem Befehl Composer → Erzeugen . Aufruf : Menü Composer Voraussetzung : In der Ansicht Module sind Module mit speziell konfiguriertem Text für die Toplevelreiter. Beispiel Modul Die folgenden Anleitung beschreibt, wie der Text für einen Toplevelreiter gesetzt und danach zurückgesetzt wird. Ihr Projekt enthält das Modul Building . Doppelklicken Sie in der Ansicht Module auf das Modul Building . Der Moduleditor (Modulkonfigurator) öffnet sich. Aktivieren Sie die Option Erzeuge Toplevelreiter . Daneben erscheint ein Eingabefeld mit dem voreingestellten Topleveltext Building . Geben Sie dort City hall ein. Wählen Sie den Befehl Composer → Erzeugen . Die Modulvisualisierungen und die Visualisierung Toplevel werden erzeugt und in der Ansicht Geräte abgelegt. Doppelklicken Sie in der Ansicht Geräte die Visualisierung Toplevel . → Speichern Sie das Projekt. Doppelklicken Sie in der Ansicht Module auf das Modul Building . Die Befehle des Menüs Composer stehen Ihnen zur Verfügung. Selektieren Sie das Modul Building . Wählen Sie den Befehl Composer → Text der Toplevelreiter zurücksetzen‘ → Nur selektierten . Im Moduleditor im Eingabefeld neben der Option Erzeuge Toplevelreiter wird der Text auf die Voreinstellung Building zurückgesetzt. Wählen Sie den Befehl Composer → Erzeugen . Die Modulvisualisierungen und die Visualisierung Toplevel werden aktualisiert und in der Ansicht Geräte abgelegt. Offnen Sie in Ansicht Geräte die Visualisierung Toplevel . → Beispiel Submodul Die folgenden Anleitung beschreibt, wie der Text für Toplevelreiter innerhalt von einer Modulstruktur von Modulen und Submodulen gesetzt und danach zurückgesetzt werden. Ihr Projekt enthält das Modul Building und darunter das Submodul Bathroom . Doppelklicken Sie in der Ansicht Module auf das Modul Building . Der Moduleditor (Modulkonfigurator) öffnet sich. Aktivieren Sie die Option Erzeuge Toplevelreiter . Daneben erscheint ein Eingabefeld mit dem voreingestellten Topleveltext Building . Geben Sie dort City hall ein. Doppelklicken Sie in der Ansicht Module auf das Modul Bathroom . Der Moduleditor (Modulkonfigurator) öffnet sich. Aktivieren Sie die Option Erzeuge Toplevelreiter . Daneben erscheint ein Eingabefeld mit dem voreingestellten Topleveltext Building.Bathroom . Geben Sie dort WC ein. Wählen Sie den Befehl Composer → Erzeugen . Die Modulvisualisierungen und die Visualisierung Toplevel werden erzeugt und in der Ansicht Geräte abgelegt. Doppelklicken Sie in der Ansicht Geräte die Visualisierung Toplevel . → Speichern Sie das Projekt. Doppelklicken Sie in der Ansicht Module auf das Modul Building . Die Befehle des Menüs Composer stehen Ihnen zur Verfügung. Selektieren Sie das Modul Building . Wählen Sie den Befehl Composer → Text der Toplevelreiter zurücksetzen‘ → Alle . Wählen Sie den Befehl Composer → Erzeugen . Die Modulvisualisierungen und die Visualisierung Toplevel werden aktualisiert und in der Ansicht Geräte abgelegt. Offnen Sie in Ansicht Geräte die Visualisierung Toplevel . → " }, 
{ "title" : "Befehl: Modul aus FB erzeugen ", 
"url" : "ac_create_module_from_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Modul aus FB erzeugen ", 
"snippet" : "Modul aus FB erzeugen Dieser Befehl (Kategorie \"Composer“) erzeugt aus einem Funktionsbaustein eine Modulbeschreibung. Folgende Objekte werden angelegt: Modulbeschreibung mit dem Namen <NameOfTheFB> Bildersammlung mit dem Namen IP_<NameOfTheFB> Textliste mit dem Namen TL_<NameOfTheFB> Interface mit ...", 
"body" : "Modul aus FB erzeugen Dieser Befehl (Kategorie \"Composer“) erzeugt aus einem Funktionsbaustein eine Modulbeschreibung. Folgende Objekte werden angelegt: Modulbeschreibung mit dem Namen <NameOfTheFB> Bildersammlung mit dem Namen IP_<NameOfTheFB> Textliste mit dem Namen TL_<NameOfTheFB> Interface mit dem Namen I<NameOfTheFB> . Dieses Interface erweitert AC.IModule . Die Modulbeschreibung wird anhand folgender Regeln erstellt: Alle Variablen var_input constant werden als Modulparameter definiert. Dabei können die Attribute parameterCategory , parameterMinValue und parameterMaxValuehere zum Setzen von Kategorie und Minimal-\/Maximalwert verwendet werden. Alle numerischen Variablen var_output werden als Modulausgänge definiert Alle numerischen Variablen var_input werden als Moduleingänge definiert, soweit sie nicht als Teil eines Multislots gekennzeichnet sind. Alle Variablen var_input vom Typ Interface werden zu Single Slots, wenn sie mit dem Attribut ac_single_slot gekennzeichnet sind. Zum Erzeugen eines Multislots wird ein Paar von var_input benötigt, das aus einem Pointer to Interface und einer Integervariablen besteht. Beide müssen mit dem Attribut 'ac_multi_slot' := '<ID>' gekennzeichnet sein, wobei die <ID> der beiden übereinstimmen muss. " }, 
{ "title" : "Befehl: Persistence Manager erzeugen ", 
"url" : "ac_create_persistence_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Persistence Manager erzeugen ", 
"snippet" : "Persistence Manager erzeugen Mit diesem Befehl (Kategorie \"Composer“) wird ein vollständiger Persistence Manager mit Standardeinstellungen in den Modulbaum eingefügt. Unterhalb des Persistence Managers wird ein Modul Persistenzkanal und darunter ein Modul Datenspeicher eingefügt. Die erzeugte Strukt...", 
"body" : "Persistence Manager erzeugen Mit diesem Befehl (Kategorie \"Composer“) wird ein vollständiger Persistence Manager mit Standardeinstellungen in den Modulbaum eingefügt. Unterhalb des Persistence Managers wird ein Modul Persistenzkanal und darunter ein Modul Datenspeicher eingefügt. Die erzeugte Struktur kann danach beliebig verändert und erweitert werden. Dies geschieht in den Parametern von Modul Persistenzkanal und Modul Datenspeicher . In der Toplevel-Modulinstanz von Persistence Manager Modul muss zumindest die Zielapplikation gesetzt werden. Bevor die Applikation auf die Steuerung geladen wird, muss zudem das Kommando Erzeugen ausgeführt werden. Der Befehl fügt zusätzlich alle erforderlichen Bibliotheken zum Bibliotheksverwalter hinzu und aktiviert die zugehörigen Generatoren. " }, 
{ "title" : "Befehl: DataLog Manager erzeugen ", 
"url" : "ac_create_datalog_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: DataLog Manager erzeugen ", 
"snippet" : "DataLog Manager erzeugen Mit diesem Befehl (Kategorie \"Composer“) wird ein vollständiger DataLog Manager mit Standardeinstellungen in den Modulbaum eingefügt. Unterhalb des DataLog Managers wird ein Modul DataLog-Kanal und darunter ein Modul DataLog-Speicher eingefügt. Die erzeugte Struktur kann dan...", 
"body" : "DataLog Manager erzeugen Mit diesem Befehl (Kategorie \"Composer“) wird ein vollständiger DataLog Manager mit Standardeinstellungen in den Modulbaum eingefügt. Unterhalb des DataLog Managers wird ein Modul DataLog-Kanal und darunter ein Modul DataLog-Speicher eingefügt. Die erzeugte Struktur kann danach beliebig verändert und erweitert werden. Dies geschieht in den Parametern von Modul ‚DataLog-Kanal‘ und Modul ‚DataLog-Speicher CSV‘ . In der Toplevel-Modulinstanz von Modul ‚DataLog Manager‘ muss zumindest die Zielapplikation gesetzt werden. Bevor die Applikation auf die Steuerung geladen wird, muss zudem der Befehl Erzeugen ausgeführt werden. Der Befehl fügt zusätzlich alle erforderlichen Bibliotheken zum Bibliotheksverwalter hinzu und aktiviert die zugehörigen Generatoren. " }, 
{ "title" : "Befehl: Lizenzinformation ermitteln ", 
"url" : "ac_cmd_get_license_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Befehle \/ Befehl: Lizenzinformation ermitteln ", 
"snippet" : "Lizenzinformation ermitteln Mit diesem Befehl (Kategorie \"Composer“) ermittelt CODESYS die Anzahl der verwendeten Modulinstanzen im Modulbaum. Zusätzlich wird die maximal zulässige Anzahl an Instanzen der aktuellen Lizenz abgefragt. Das Ergebnis wird in der Ansicht Meldungen ausgegeben. Für weitere ...", 
"body" : "Lizenzinformation ermitteln Mit diesem Befehl (Kategorie \"Composer“) ermittelt CODESYS die Anzahl der verwendeten Modulinstanzen im Modulbaum. Zusätzlich wird die maximal zulässige Anzahl an Instanzen der aktuellen Lizenz abgefragt. Das Ergebnis wird in der Ansicht Meldungen ausgegeben. Für weitere Informationen siehe: ???" }, 
{ "title" : "Tutorial ", 
"url" : "f_application_composer_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Tutorial ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Beispiel: First Steps ", 
"url" : "f_application_composer_first_steps.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Tutorial \/ Beispiel: First Steps ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Application Composer Beispiel ", 
"url" : "ac_example_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Tutorial \/ Beispiel: First Steps \/ Application Composer Beispiel ", 
"snippet" : "Basierend auf einem kleinen Beispielprojekt beschreibt diese Anleitung, wie Module für den Application Composer erstellt werden. Einige URLs in dieser Anleitung verlinken auf Seiten, die Bestandteile des Application Composer sind. Wenn Sie dieses Package nicht installiert haben, werden diese Links n...", 
"body" : "Basierend auf einem kleinen Beispielprojekt beschreibt diese Anleitung, wie Module für den Application Composer erstellt werden. Einige URLs in dieser Anleitung verlinken auf Seiten, die Bestandteile des Application Composer sind. Wenn Sie dieses Package nicht installiert haben, werden diese Links nicht funktionieren. Das Beispiel beschreibt einen Raum mit einem Licht und einem Schalter. Der Schalter kann als einfacher Schalter oder Dimmer genutzt werden. Wird er lange gedrückt, so wird das Licht gedimmt - kurzes Drücken bewirkt ein Ein- oder Ausschalten. Die Geschwindigkeit der Dimmfunktion sowie der Maximalwert des Lichts kann durch den Anwender festgelegt werden. Wenn der Schalter länger gedrückt wird als eine festgelegte Zeit, wird die Dimmfunktion aktiv. Der Ausgang des Lichts ist die Helligkeit. Es ist noch ein zweites Licht vorhanden, welches jedoch nur durch einen einfachen Schalter ein- und ausgeschaltet werden kann. Beispielprojekt Schritt 0: Vorarbeiten " }, 
{ "title" : "Schritt 0: Vorarbeiten ", 
"url" : "ac_example_s0_preliminaries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Tutorial \/ Beispiel: First Steps \/ Schritt 0: Vorarbeiten ", 
"snippet" : "Zuerst muss ein neues Projekt erzeugt werden. Dazu wird der Befehl Neues Projekt “ aus dem Menü Datei ausgewählt und das neue Projekt abgespeichert. In der Ansicht POUs muss ein Bibliotheksverwalter hinzugefügt werden. Danach kann die Bibliothek AC_ModuleBase , die Teil des Packages CODESYS Applicat...", 
"body" : "Zuerst muss ein neues Projekt erzeugt werden. Dazu wird der Befehl Neues Projekt “ aus dem Menü Datei ausgewählt und das neue Projekt abgespeichert. In der Ansicht POUs muss ein Bibliotheksverwalter hinzugefügt werden. Danach kann die Bibliothek AC_ModuleBase , die Teil des Packages CODESYS Application Composer ist, dem Bibliotheksverwalter hinzugefügt werden. Bibliothek hinzufügen ‚AC_ModulBase‘‘ Schritt 1: Erzeugen des Toplevel-Moduls „Room“ " }, 
{ "title" : "Schritt 1: Erzeugen des Toplevel-Moduls \"Room\" ", 
"url" : "ac_example_s1_create_toplevel_room.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Tutorial \/ Beispiel: First Steps \/ Schritt 1: Erzeugen des Toplevel-Moduls \"Room\" ", 
"snippet" : "Im POUs -Pool wird eine Moduldeklaration und ein Funktionsbaustein hinzugefügt. Der Funktionsbaustein wird für die Implementierung (Funktionsprogramm) des Moduls benutzt. Modul und Funktionsbaustein erhalten in diesem Beispiel den Namen Room . Weiterhin muss der Funktionsbaustein den Basistyp AC.Mod...", 
"body" : "Im POUs -Pool wird eine Moduldeklaration und ein Funktionsbaustein hinzugefügt. Der Funktionsbaustein wird für die Implementierung (Funktionsprogramm) des Moduls benutzt. Modul und Funktionsbaustein erhalten in diesem Beispiel den Namen Room . Weiterhin muss der Funktionsbaustein den Basistyp AC.Module erweitern, derTeil der Bibliothek AC_ModuleBase ist und umfangreiche Eigenschaften und Methoden zur Verfügung stellt. Alle Eigenschaften und Funktionen, welche mit dem Funktionsbaustein erzeugt werden, werden für das Beispiel nicht benötigt und können gelöscht werden. Funktionsbaustein und Modul hinzufügen Die Deklaration beginnt mit dem Schlüsselwort MODULE gefolgt von dem Modulnamen und dem IMPLEMENTED_BY sowie dem Funktionsbaustein, welcher das Modul implementiert. Dieser ist im konkreten Fall der Funktionsbaustein Room . In den meisten Fällen wird nun die Sektion MetaData deklariert. Detaillierte Informationen über alle Parameter und Sektionen finden Sie unter Moduldeklaration . Da Room in unserem Beispiel ein Toplevel-Modul ist, wird als nächstes die Sektion Toplevel deklariert. In dieser wird ein Name für die globale Variablenliste ( GVL_name ) definiert, welcher den Instanznamen des Toplevel-Funktionsbausteins nach der Generierung enthält. Danach muss noch mindestens eine Task in der Toplevel-Sektion definiert werden. Diese ist in diesem Beispiel Standart_Task , welche als MEDIUM -Task definiert wird und die Flags CREATE_IF_MISSING und UPDATE_IOS enthält. Deklaration des Moduls Room Alle Icons und Texte, welche als Platzhalter für die Beschreibungen und Icons verwendet werden (Parameter Desc , Icon_16 und Icon_32 ), müssen in Textlisten und Bildersammlungen abgelegt sein. Deshalb wird eine entsprechende Textliste TL und eine Bildersammlung IP im POUs -Pool angelegt, welcher die referenzierten Icons und Texte enthält Textliste und Bildersammlung hinzufügen Schritt 2: Erzeugen des Submoduls „Switch“ " }, 
{ "title" : "Schritt 2: Erzeugen des Submoduls \"Switch\" ", 
"url" : "ac_example_s2_create_sublevel_switch.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Tutorial \/ Beispiel: First Steps \/ Schritt 2: Erzeugen des Submoduls \"Switch\" ", 
"snippet" : "Im nächsten Schritt wird ein Modul für die Schalter des Raums erstellt. Dazu müssen wieder eine Moduldeklaration und ein Funktionsbaustein erstellt werden. Beide werden Switch genannt und die Deklaration muss von dem Funktionsbaustein implementiert sein. Die Moduldeklaration von Switch benötigt kein...", 
"body" : "Im nächsten Schritt wird ein Modul für die Schalter des Raums erstellt. Dazu müssen wieder eine Moduldeklaration und ein Funktionsbaustein erstellt werden. Beide werden Switch genannt und die Deklaration muss von dem Funktionsbaustein implementiert sein. Die Moduldeklaration von Switch benötigt keine Toplevel-Sektion, da es unterhalb des Moduls Light (wird später erklärt) an keiner Toplevel-Position hinzugefügt wird. Wie alle Funktionsbausteine, welche Module implementieren, muss auch der Funktionsbaustein Switch den AC.Module erweitern. Im vorliegenden Beispiel implementiert der Funktionsbaustein auch das Interface ISwitch , welches noch erzeugt werden muss. Dieses Interface selbst muss das Interface IModule implementieren, welches von der Bibliothek AC_ModuleBase bereitgestellt wird, implementieren. Das Interface ISwitch bleibt jedoch „leer“ - es werden keine Eigenschaften oder Funktionen deklariert. Weiterhin benötigt der Schalter ein Einganssignal (in der Regel von einem externen Signal \/ physikalischen Schalter) um zu erkennen, wenn er gedrückt ist. Dieses Signal wird in der Sektion IO deklariert, wobei die Variable xIn des Funktionsbausteins, welcher dieses Modul implementiert, verwendet wird. Desweiteren wird eine Referenzzeit benötigt, um die beiden Funktionen des Schalters zu unterscheiden: Das Drücken des Schalters für die Zeitdauer tTimer startet die Dimm-Funktion - bei einem kürzeren Drücken wird das Licht nur ein- bzw. ausgeschaltet. Die Variable tTimer (ebenfalls aus dem modulimplementierenden Funktionsbaustein) wird als Parameter des Moduls (Sektion Parameter ) definiert, welches später einfach bei der Verwendung der Module editiert werden kann. Deklaration des Submoduls Switch Die referenzierten Variablen xIn und tTimer sind beide als Eingänge des Funktionsbausteins Switch deklariert, wobei beim Parameter tTimer einen Initialisierungswert von 500 ms definiert wird. Wenn also der Eingang des Funktionsbausteins Switch länger als 500 ms gedrückt wird, wird die Lampe gedimmt. Deklaration im Funktionsbaustein Switch‘ Die Textliste und Bildersammlung muss ebenfalls erweitert werden um die benötigten Beschreibungen der Eingänge und Parameter festzulegen. Einträge in der Textlisten und Bildersammlung Schritt 3: Erzeugen des Submoduls „Switch simple“ " }, 
{ "title" : "Schritt 3: Erzeugen des Submoduls \"Switch simple\" ", 
"url" : "ac_example_s3_create_sublevel_switchsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Tutorial \/ Beispiel: First Steps \/ Schritt 3: Erzeugen des Submoduls \"Switch simple\" ", 
"snippet" : "Das zweiter Schaltermodul, welches erstellt werden soll, ist ein einfacher Schalter mit zwei Zuständen: Ein und Aus. Dazu müssen eine Moduldeklaration und ein Funktionsbaustein erzeugt werden, welcher vom Dimmschalter angepasst werden kann. Für den Funktionsbaustein wird ein neues Interface ISwitchS...", 
"body" : "Das zweiter Schaltermodul, welches erstellt werden soll, ist ein einfacher Schalter mit zwei Zuständen: Ein und Aus. Dazu müssen eine Moduldeklaration und ein Funktionsbaustein erzeugt werden, welcher vom Dimmschalter angepasst werden kann. Für den Funktionsbaustein wird ein neues Interface ISwitchSimple verwendet. Weiterer Unterschied ist, dass die Variable xIn als BOOL deklariert werden sollte und der Parameter tTimer nicht benötigt wird. Schritt 4: Erzeugen des Submoduls „Light“ " }, 
{ "title" : "Schritt 4: Erzeugen des Submoduls \"Light\" ", 
"url" : "ac_example_s4_create_sublevel_light.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Tutorial \/ Beispiel: First Steps \/ Schritt 4: Erzeugen des Submoduls \"Light\" ", 
"snippet" : "Wie vorher für den Schalter ( Switch ) und den einfachen Schalter ( SwitchSimple ) muss für das Modul Light “ eine Moduldeklaration Light , ein Funktionsbaustein Light und ein Interface ILight angelegt werden. Das Modul wird vom Funktionsbaustein implementiert, welcher seinerseits das Interface ILig...", 
"body" : "Wie vorher für den Schalter ( Switch ) und den einfachen Schalter ( SwitchSimple ) muss für das Modul Light “ eine Moduldeklaration Light , ein Funktionsbaustein Light und ein Interface ILight angelegt werden. Das Modul wird vom Funktionsbaustein implementiert, welcher seinerseits das Interface ILight implementiert. Um das Modul Light unterhalb des Moduls Room hinzufügen zu können, muss die Moduldeklaration von Room mit der Sektion Slots erweitert werden. In dieser Sektion wird eine Untersektion Slot_Multi deklariert, welche Lights genannt wird und welche Module des Tyjps Light aufnehmen kann. Die Anzahl der Lichter, welche zu einem Raum hinzugefügt werden muss oder kann, wird durch den Parameter Cardinality definiert (in unserem Beispiel zwischen 1 und 3 Lichter). Weiterhin müssen zwei Variablen definiert werden: Variable ( pLights , welche die Funktionsbausteininstanzen der Licht-Module des Raumes beschreibt), und Var_Count ( uiNumberOfLights , welche die Anzahl der Lichter des Raumes beschreibt). Definition der Sektion Slots Die Variablen pLights und uiNumberOfLights müssen zum Funktiosbaustein der Module „Lights“ hinzugefügt werden, wobei uiNumberOfLights ein UINT und pLights vom Typ POINTER TO ILight ist. Mit dieser Definition können nur Module zum Slot Lights hinzugefügt werden, deren Funktionsblöcke auch das Interface ILight implementieren. Deklaration im Funktionsbaustein Room Das gleiche Slot-Kozept, welches für die Module Room “ verwendet wurde, wird nun für das Modul Light verwendet. Somit beinhaltet die Deklaration von Light einen Slot mit einem Switch , weshalb dieser Slot kein Multi-Slot, sondern ein einfacher Slot ist. Die zusätzlichen Parameter des Moduls Light sind die Geschwindigkeit des Dimmers rSpeed und die maximale Helligkeit uiMaxValue . Abschließend muss noch ein Ausgang definiert werden, welcher die Helligkeit des damit verbundenen Lichts repräsentiert. Alle Parameter, Slots und Ausgänge müssen auch als Variablen zum Funktionsbaustein des Moduls Light hinzugefügt werden. Deklaration des Moduls Light Deklaration des Funktionsbausteins Light Testliste und Bildersammlung Schritt 5: Erzeugen des Submoduls „Light simple“ " }, 
{ "title" : "Schritt 5: Erzeugen des Submoduls \"Light simple\" ", 
"url" : "ac_example_s5_create_sublevel_lightsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Tutorial \/ Beispiel: First Steps \/ Schritt 5: Erzeugen des Submoduls \"Light simple\" ", 
"snippet" : "Das einfache Licht, welches nun erzeugt wird, arbeitet mit dem einfachen Schalter zusammen, kann jedoch von Light übernommen und angepasst werden. Dazu muss eine neue Moduldeklaration und ein neuer Funktionsbaustein LightSimple erzeugt werden. Da der Funktionsbaustein das Interface ILight implementi...", 
"body" : "Das einfache Licht, welches nun erzeugt wird, arbeitet mit dem einfachen Schalter zusammen, kann jedoch von Light übernommen und angepasst werden. Dazu muss eine neue Moduldeklaration und ein neuer Funktionsbaustein LightSimple erzeugt werden. Da der Funktionsbaustein das Interface ILight implementiert, können später Lichter unterschiedlichen Typs zu einem Raum hinzugefügt werden. Der Hauptuntschied zum Light ist, dass die Variable des Slots vom Typ ISwitchSimple sein muss, damit kein falscher Schalter zum Modul LightSimple hinzugefügt werden kann. Weiterhin sollte der Ausgang von LightSimple vom Typ BOOL sein und den Namen xSwitchedOn haben. Schritt 6: Implementierung " }, 
{ "title" : "Schritt 6: Implementierung ", 
"url" : "ac_example_s6_implementation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Tutorial \/ Beispiel: First Steps \/ Schritt 6: Implementierung ", 
"snippet" : "Schalter Für die Implementierung der Funktion für das Modul Switch wird die Methode CallPrioMediumStart von Module verwendet und mit der eigenen Implementierung überschrieben. Diese Funktion wird gewählt, weil das Modul Room eine Task MEDIUM deklariert, Dies bedeutet nämlich, dass die Methode CallPr...", 
"body" : "Schalter Für die Implementierung der Funktion für das Modul Switch wird die Methode CallPrioMediumStart von Module verwendet und mit der eigenen Implementierung überschrieben. Diese Funktion wird gewählt, weil das Modul Room eine Task MEDIUM deklariert, Dies bedeutet nämlich, dass die Methode CallPrioMediumStart des Funktionsbausteins Switch automatisch in jedem Zyklus der mittlerern Task aufgerufen wird. Genauere Informationen können dem Beispielprojekt selber entnommen werden. Die Hauptfunktion des Schalters ist die Unterscheidung zwischen Schalten und Dimmen. Nach dem Drücken des Schalters startet ein Timer mit einer Zeit, welche durch Anwenderparameter vorgegeben werden kann. Wenn der Timer abgelaufen ist und der Schalter immer noch gedrückt ist, wird die Dimmerfunktion verwendet, was auch durch die Variable XPushLong angezeigt wird. Die Variable xPush wird TRUE , wenn der Schalter nur kurz gedrückt wird. Für beide Variablen xPushLong und xPush werden sowohl im Funktionsbaustein Switch als auch im Interface ISwitch Eigenschaften hinzugefügt, so dass sie vom Eltern-Lichtfunktionsbaustein benutzt werden können. Licht Auch der Funktionsbaustein Light überschreibt die Methode CallPrioMediumStart . Abhängig von der Eingangsvariablen der zugehörigen Variablen wird das Licht auf \"an“ oder \"aus“ gedimmt oder einfach nur geschaltet. Für den Dimmer wird der Geschwindigkeitswert des deklarierten Parameters rSpeed verwendet. Nach Erreichen des Maximums oder Minimums des Dimmwertes wird das Dimmen beenddet. Wenn das Licht in einem gedimmten Zustand ist und der Schalter gedrückt wird, wird das Licht ausgeschaltet. (Die vollständige Implementierung kann im Beispielprojekt gesehen werden) Programmcode überprüfen Nach der Implementierung sollten die Deklarationen durch Ausführen des Befehls Übersetzen überprüft werden. Wenn kein Fehler erscheint, ist die Deklaration in Ordnung. Schritt 7: Module konfektionieren " }, 
{ "title" : "Schritt 7: Module konfektionieren ", 
"url" : "ac_example_s7_composing_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Tutorial \/ Beispiel: First Steps \/ Schritt 7: Module konfektionieren ", 
"snippet" : "Nach einer erfolgreichen Überprüfung aller Deklarationen sind alle Module für die weitere Verwendung verfügbar, so dass eine Beispielapplikation konfektioniert werden kann. Dazu werden die Module zum Modulbaum eines Projektes hinzugefügt. Dazu muss die Ansicht Module geöffnet werden. Im ersten Schri...", 
"body" : "Nach einer erfolgreichen Überprüfung aller Deklarationen sind alle Module für die weitere Verwendung verfügbar, so dass eine Beispielapplikation konfektioniert werden kann. Dazu werden die Module zum Modulbaum eines Projektes hinzugefügt. Dazu muss die Ansicht Module geöffnet werden. Im ersten Schritt wird das Toplevel-Modul Room zum Modulbaum hinzugefügt. Hinzufügen des Toplevel-Moduls zum Modulbaum Danach öffnet der Moduldialog und bietet alle Toplevel-Module an. In diesem Dialog werden die zugehörigen Icons, welche in der Bildersammlung definiert wurden, sowie die Texte aus den Textlisten angezeigt. Nun kann das Modul „Room“ ausgewählt und zum Modulbaum hinzugefügt werden. Dialog \"Modul hinzufügen\" Nun kann durch einen Doppelklick auf Room im Modulbaum der Editor des Toplevel-Moduls geöffnet werden. Im Register Toplevel muss eine Zielapplikation für die Codeerzeugung ausgewählt werden. Im Feld Standard Tasks werden die Tasks, die in der Moduldeklaration definiert wurden, angezeigt. Einstellungen des Moduls \"Room\" Analog zu der obigen Vorgehensweise kann nun das Submodule Light zum Modulbaum hinzugefügt werden. Aufgrund der Multi-Slot-Definition in der Moduldeklaration des Raumes können bis zu drei Lichter hinzugefügt werden. Im Register Parameter des Editors des Modules Light können die Werte für maxLightValue und Speed parametriert werden. Im E\/A-Editor wird für das Beispiel der Ausgang Brightness der lokalen Variablen uiBrightness zugeordnet. Einstellungen des Moduls \"Light\" Unterhalb des neu hinzugefügten Light wird nun ein Module Switch hinzugefügt. Im Editor des Moduls Switch sind alle Parameter und E\/As verfügbar, welche in der Moduldeklaration festgelegt wurden. In dem Beispiel wird die lokale Variable xPushSwitch der Eingangsvariablen xIn zugeordnet. Der Ausgang des einfachen Lichts wird der lokalen Variablen xSimpleOn verbunden. Einstellungen des Moduls \"Switch“ Im letzten Schritt des Beispiels wird noch ein einfaches Licht ( LightSimple ) und ein einfacher Schalter ( SwitchSimple ) zum Modulbaum hinzugefügt. Der Ausgang des einfachen Lichts wird mit der lokalen Variablen xSimpleOn und der Eingang des einfachen Schalters mit der Variablen xPushSimpleSwitch verbunden. Beispielaufbau Modulbaum Zum Schluss wird das Projekt mit dem Befehl Erzeugen generiert. Nach dem Download auf das Gerät kann das Beispiel durch Verändern der Werte für xPushSwitch getestet werden. Während des Dimmens sollte sich der Wert für uiBrightness langsam ändern und Schalten wird der Wert direkt auf 0 oder Maximum gesetzt. Ein Ändern von xPushSimpleSwitch schaltet direkt den Ausgang des zugehörigen Lichts. Es sollte noch erwähnt werden, das der letzte Schritt, das Konfektionieren der Module, in beliebiger Kombination vorgenommen werden kann, ohne die Funktionalität des erzeugten Codes zu verlieren. " }, 
{ "title" : "Bibliothek: Mechatronics ", 
"url" : "ac_mechatronics_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduleditor \/ Tutorial \/ Bibliothek: Mechatronics ", 
"snippet" : "Die Bibliothek Mechatronics ist als Beispiel gedacht für eine einfache (und auch nicht vollständige) Implementierung einer mechatronischen Einheit mit sequentiellem Ablauf. Sie erfüllt nicht alle Anforderungen, die eine komplette mechatronische Applikation haben könnte. Sie soll vielmehr ein Einstie...", 
"body" : "Die Bibliothek Mechatronics ist als Beispiel gedacht für eine einfache (und auch nicht vollständige) Implementierung einer mechatronischen Einheit mit sequentiellem Ablauf. Sie erfüllt nicht alle Anforderungen, die eine komplette mechatronische Applikation haben könnte. Sie soll vielmehr ein Einstieg oder eine Basis für eine Applikation solchen Typs sein. Das Kernstück des vorgestellten Mechatronic-Modells basiert auf der folgenden Modulstruktur: Application Composer Beispiel Mechatronics Es wird bei jeder Maschine angenommen, dass sie aus mehreren mechantronischen Unterbaugruppen, welche beispielsweise jeweils einen Greifer repräsentieren, bestehen kann. Eine Unterbaugruppe wiederum teilt sich auf in seine Aktuatoren (bestehend aus der mechatronischen Einheit selbst, aber auch aus ihrer funktionellen Implementierung oder E\/A-Verwaltung) und einem Programm-Manager. Der Programm-Manager soll die verschiedenen Zustände einer mechatronischen Unterbaugruppe verwalten, wie beispielsweise seinen Idle - oder Execute -Zustand. Schlußendlich werden diese Zustände in der Bibliothek durch Programmabläufe repräsentiert, welche die Aktoren bewegen oder andere notwendige Funktionen ausführen. An dieser Stellen sollen kurz die verschiedenen Teile im Detail beschrieben werden. Bei der Verwendung der Bibliothek wird es in vielen Fällen notwendig sein, eigene Aktoren, Ablaufschritte oder Programmsequenzen zu implementieren, was hier ebenfalls erklärt werden soll. Aktoren Alle Module, cie Aktoren sein sollen, müssen von einem Funktionsbaustein implementiert werden, der seinerseits das Interface IActuator implementiert. Dieses Interface hat keine Methoden oder Eigenschaften und wird nur aus Gründen der Modulkompatibilität verwendet (siehe dazu die Dokumentation von IActuator in der Bibliothek). Für Implementierungen von Aktoren gibt es keine Regeln oder Einschränkungen, so dass die Bewegung oder Aktivierung eines solchen Aktors separat gemacht werden muss. Dies wird normalerweise durch die Implementierung eines Ablaufschritt-Moduls realisiert, welches Aktoren in einem Referenz-Steckplatz aufnehmen kann und sie dann als Teil eines Ablaufs in der gewünschten Art bewegen kann (beispielsweise durch die Verwendung zusätzlicher Interfaces realisiert). Ablaufschritte Es wird dringend empfohlen, die Implementierung von Ablaufschritten als abgeleitete Klassen des Funktionsbausteins StepBase auszuführen. Dieser stellt alle notwendigen Basisimplementierungen des Interfaces IProgramSequenceStep zur Verfügung. Siehe dazu die Dokumentation von IActuator in der Bibliothek. Bei der Verwendung der Basisklasse StepBase ist es dann nur noch notwendig die Methode Execute zu implementieren. Letztere wird dann vom Programmablauf zyklisch so lange aufgerufen, bis die Variable xDone der Basisklasse auf TRUE gesetzt wird. Zusätzlich sollte, solange der jweilige Ablaufschritt aktiv ist, das Flag xActive auf TRUE gesetzt werden. Die Verbindung zu Aktoren kann dann in beliebiger Weise implementiert werden (beispielsweise durch den vorgeschlagenen Referenz-Steckplatz (siehe 1.) Programmsequenz \/ Programm-Manager Eine Programmsequenz ist ein Submodul eines Programm-Managers, welche einen Zustand darstellt. Diese Zustände werden in Form einer OMAC-Status-Maschine verwaltet. Ihre Implementierungen basieren wieder auf der Methode „Execute“ (für Details , siehe die Implementierung in der Bibliothek). Die Implementierung eines solchen Programmablauf durch den Anwender ist jedoch in den meisten Fällen nicht notwendig. Die Art und Weise, wie das Verhalten der Status-Maschine im Programm-Manager implementiert ist und dadurch die Programmabläufe ausführt, soll jedoch hier kurz beschrieben werden: Es gibt zwei Arten von Status: Ausführende Status (Endung „ing“) und wartende\/duale Status (restliche). Die wartenden Status werden durch externe Befehle beendet, wohingegen die ausführenden Status nach der Ausführung beendet werden. Die verfügbaren Befehle hängen von dem Status ab, in welchem der Programm-Manager gerade steht. Das OMAC-Status-Diagramm gibt dazu einen kleinen Überblick. OMAC Diagramm Modul MovableBarrier Das Modul MovableBarrier ist folgendermaßen implementiert: Der zugehörige Funktionsbaustein MovableBarrier implementiert das erzeugte Interface IMovableBarrier . Dieses Interface definiert Methoden zum Bewegen einer (bildlichen) Schutzhaube, wobei IMovableBarrier seinerseits das Interface IActuator implementiert, so dass das Modul MovableBarrier als Aktor im Modulbaum unterhalb einer mechatronischen Baugruppe eingesetzt werden kann: Implementierung des Moduls MovableBarrier Dieser Aktuator „MovableBarrier“ wird durch das Ablaufschritt-Modul MoveBarrierForTime bewegt, welches seinerseits in der folgenden Art und Weise implementiert ist: Implementierung des Moduls MoveBarrierForTime Der das Modul implementierende Funktionsbaustein MoveBarrierForTime leitet einfach von dem Basisfunktionsbaustein AC_MEC.StepBase ab, welcher in der Bibliothek enthalten ist. Dadurch implementiert der Funktionsbaustein MoveBarrierForTime bereits das Interface IProgramSequenceStep . Folglich kann das Modul MoveBarrierForTime als Ablaufschritt unter einem Programmablauf eingefügt werden. Die funktionelle Implementierung des Funktionsbausteins MoveBarrierForTime geschieht folgendermaßen: Durch die Definition eines Referenz-Steckplatzes für das Modul MoveBarrierForTime , welcher einen Aktor mit implementiertem Interface IMovableBarrier aufnehmen kann, bekommt dieser eine Verbindung zu einem bestehenden „MovableBarrier“-Aktuator. Die Bewegung dieses Aktors erfolgt schließlich in der Funktion Execute des Funktionsbausteins MoveBarrierForTime , welcher einfach die Methode zum (bildlichen) Bewegen der Schutzhaube aufruft. Diese Methode wird durch den referenzierten Aktuator, welcher IMovableBarrier implementiert, zur Verfügung gestellt. Weiterhin ist die Eigenschaft Done und die Variable xActive mit einem TON gekoppelt, so dass der „Bewegungs“-Funktionsbaustein IMovableBarrier solange zyklisch aufgerufen wird, bis eine vorgegebene Zeit (TON) abgelaufen ist und danach Done auf TRUE und xActive auf FALSE gesetzt wird. Die Eigenschaft Done ist Teil des Interfaces IProgramSequenceStep und meldet deshalb dem übergeordneten Programmablauf dass der nächste Ablaufschritt ausgeführt werden soll. Abgesehen von eigenen Implementierungen von Ablaufschritten stellt die AC_Mechatronics.library einige vorimplementierte Schritte zur Verfügung, welche für allgemeine logische Operationen verwendet werden können. Es wird zum Beispiel ein Schritt BranchOnBool bereitgestellt, welcher zwei Unterschritte\/-zweige beinhaltet. Diese Unterschritte werden abhängig vom Wert einer booleschen Variable ausgeführt. Darüberhinaus sind in der Bibliothek AC_Mechatronics.library Ablaufschritte für parallele Abläufe, bedingte Sprünge oder einfache Warteschritte und viele weitere Aufgaben vorhanden. " }, 
{ "title" : "Moduldeklarations-Editor ", 
"url" : "ac_module_declaration_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor ", 
"snippet" : "Ein Modul repräsentiert typischerweise eine mechatronische Komponente, kann aber auch eine reine Softwarefunktion sein. Es beinhaltet alle Engineering-Aspekte, die von CODESYS abgedeckt werden. Ein Modul besitzt einen Funktionsbaustein, der das Interface IModule aus der Bibliothek AC_ModuleBase impl...", 
"body" : "Ein Modul repräsentiert typischerweise eine mechatronische Komponente, kann aber auch eine reine Softwarefunktion sein. Es beinhaltet alle Engineering-Aspekte, die von CODESYS abgedeckt werden. Ein Modul besitzt einen Funktionsbaustein, der das Interface IModule aus der Bibliothek AC_ModuleBase implementiert. Ein Modul enthält Informationen über Submodule, Parametrierung, E\/A-Bedarf, Taskzuordnung und Visualisierung. Module stellen das zentrale Konzept des CODESYS Application Composer dar. Der CODESYS Application Composer stellt ein Vorlagenprojekt zur Verfügung, das im Dialog Neues Projekt ausgewählt werden kann. Diese Vorlage erstellt ein Projekt mit einem Gerät, einer Applikation und einem Bibliotheksmanager in POU-Pool. Dieser Bibliotheksmanager enthält die Bibliotheken AC_ModuleBase und AC_Persistence . Die auf dem Projekt ComposerProject.project basierende Vorlage kann bei Bedarf modifiziert werden. Sie ist im „Templates“-Unterordner des CODESYS -Installationsverzeichnisses gespeichert. Aus einem bestehenden Funktionsbaustein können Sie automatisch ein Modul erzeugen. Dabei werden, soweit möglich, bestehende Deklarationen in die Moduldeklaration übernommen. Details hierzu finden Sie in der Beschreibung des Befehls Modul aus FB erzeugen . Im Kapitel Moduldeklaration finden Sie detaillierte Informationen wie Module entwickelt werden können. Informationen über den Datenaustausch zwischen verschiedenen Applikationen finden Sie im Kapitel IRMPService . " }, 
{ "title" : "Moduldeklaration ", 
"url" : "ac_module_declaration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration ", 
"snippet" : "Die Deklaration von Modulen erfolgt über eine eigene Beschreibungssprache, die an die Deklaration von Variablen im ST-Code angelehnt ist. Sektionen der Moduldeklarationen Sektion MetaData Sektion Toplevel Sektion IO Sektion Parameters Sektion Slots Sektion Visu Sektion Proxies Sektion VarArrays Sekt...", 
"body" : "Die Deklaration von Modulen erfolgt über eine eigene Beschreibungssprache, die an die Deklaration von Variablen im ST-Code angelehnt ist. Sektionen der Moduldeklarationen Sektion MetaData Sektion Toplevel Sektion IO Sektion Parameters Sektion Slots Sektion Visu Sektion Proxies Sektion VarArrays Sektion Constraints Sektion InstRefs Sektion mse.Sequence DeviceGeneratorSektion alg.Alarm " }, 
{ "title" : "Format der Moduldeklaration ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_48fab9ed86f6686ac0a8640e00dcb86d", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Format der Moduldeklaration ", 
"snippet" : "Ein Header der Form MODULE <Name> leitet die Deklaration ein. Es folgt eine Liste von sogenannten Abschnitten. Jeder Abschnitt wird durch das Schlüsselwort SEC (für „Section“) eingeleitet und hat einen eindeutigen Namen. Ein Abschnitt wird mit dem Schlüsselwort END_SEC abgeschlossen. Der Inhalt eine...", 
"body" : "Ein Header der Form MODULE <Name> leitet die Deklaration ein. Es folgt eine Liste von sogenannten Abschnitten. Jeder Abschnitt wird durch das Schlüsselwort SEC (für „Section“) eingeleitet und hat einen eindeutigen Namen. Ein Abschnitt wird mit dem Schlüsselwort END_SEC abgeschlossen. Der Inhalt eines Abschnitts ist eine Liste von Einträgen, die entweder wiederum Abschnitte oder aber sogenannte Definitionen sein können. Eine Definition besteht aus einem Namen und einem (optionalen) Wert und wird mit einem Semikolon abgeschlossen. Kommentare können wie in ST verwendet werden: „\/\/“ für einzeilige Kommentare und „(*“ and „*)“ für mehrzeilige Kommentare, die auch verschachtelt sein dürfen. Whitespace (Tabulatoren und Leerzeichen) und Newline\/Linefeed-Zeichen spielen nur insofern eine Rolle, als sie die einzelnen Bestandteile einer Deklaration trennen. Ansonsten werden sie bei der weiteren Bearbeitung ignoriert. Groß- und Kleinschreibung spielt, wie bei ST, keine Rolle. Am folgenden Beispiel lassen sich die einzelnen Elemente der Deklaration ablesen: 01 MODULE Persistence IMPLEMENTED_BY PersistenceFB\n02 SEC MetaData\n03 NAME := TL.ChannelName ;\n04 DESC := TL.ChannelDesc ;\n05 COLLECTION CATEGORY := ’Persistence’TL.Collection ;\n06 ICON_16 := IP.Channel16 ;\n07 ICON_32 := IP.Channel32 ;\n08 END_SEC\n09 SEC Toplevel\n10 SEC STANDARD_TASK : LOW\n11 NAME := LOW ;\n12 DESC := TL.TaskLow ;\n13 FLAGS := CREATE_IF_MISSING | READONLY ;\n14 END_SEC\n15 GVL_NAME := 'GVL_%InstanceName%' ;\n16 END_SEC In Zeile 01 wird der Modulname festgelegt. Außerdem wird mit IMPLEMENTED_BY der Name des Funktionsbaustein festgelegt, der die Logik des Moduls definiert. Dieser Funktionsbaustein muss von IModule ableiten. In Zeile 02 beginnt der Abschnitt MetaData , der in Zeile 08 endet. Dieser Abschnitt enthält fünf Definitionen. Die Möglichkeit von verschachtelten Abschnitten demonstriert der Abschnitt Toplevel (Zeile 09 – 16), der einen Abschnitt STANDARD_TASK (Zeile 10) enthält. " }, 
{ "title" : "Syntax der Moduldeklaration ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_819a1c8e627d0b32c0a8640e01623943", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Syntax der Moduldeklaration ", 
"snippet" : "In diesem Abschnitt werden die Syntax und die zulässige syntaktische Struktur einer Moduldeklaration erklärt. Im Folgenden werden Scanner-Token in Großbuchstaben gesetzt (beispielsweise ID ). Nichtterminale der Grammatik werden in geschweifte Klammern gesetzt (beispielsweise {Entry} ). Lexikalische ...", 
"body" : "In diesem Abschnitt werden die Syntax und die zulässige syntaktische Struktur einer Moduldeklaration erklärt. Im Folgenden werden Scanner-Token in Großbuchstaben gesetzt (beispielsweise ID ). Nichtterminale der Grammatik werden in geschweifte Klammern gesetzt (beispielsweise {Entry} ). Lexikalische Analyse (Scanner) In der ersten Phase werden aus den einzelnen Zeichen der Moduldeklaration sogenannte Token (oder Lexeme) gebildet, zum Beispiel Schlüsselwörter, Konstanten, Identifier. Whitespace sowie Newline\/Linefeed-Zeichen trennen Token, werden aber ansonsten ignoriert. Kommentare werden für die weitere Verarbeitung der Deklaration ebenfalls ignoriert. (Kommentare können, wie oben schon gesagt, wie in ST als einzeilige ( \/\/ “) oder mehrzeilige Kommentare ( (* und *) ) auftreten, letztere auch verschachtelt.) Grundsätzlich gilt die Regel, dass ein Token immer die maximal mögliche Länge hat. Zum Beispiel wird a123 als ein Identifier und nicht als Identifier a gefolgt von einem Literal 123 eingelesen. Außerdem gibt die Reihenfolge, in der die Token unten beschrieben sind, ihre Priorität vor. Die Eingabe MODULE wird beispielsweise als Schlüsselwort erkannt und nicht als Identifier. Liste aller verfügbaren Token: Schlüsselwörter: MODULE , SEC , END_SEC , IMPORTS , IMPLEMENTED_BY OP: eine nichtleere Sequenz der folgenden Zeichen: .:,%()[]{}<>|+-*\/@!?^°=\\~ Anmerkung: Die Kommentarmarkierungen \/\/ , (* und *) haben höhere Priorität als Operatoren. Andererseits kann innerhalb eines Operators kein Kommentar beginnen, beispielsweise wird +\/\/+ , gemäß der Regel maximaler Länge, als Operator eingelesen und nicht als + gefolgt von einem Kommentar. LIT: ein IEC-Literal, wie es auch in ST verwendet werden darf, beispielsweise 1.4 , tod#12:13:14 . Hierzu zählen auch die booleschen Literale TRUE und FALSE (unabhängig von der Groß-\/Kleinschreibung). Anmerkung: Ungetypte Literale mit vorangestelltem negativen Vorzeichen ( -1 , -3.2 ) werden als zwei Token eingelesen, nämlich als Operator - gefolgt von einem ungetypten Literal. Es folgt, dass ungetypte numerische Literale nie negativ sind. Getypte Literale ( INT#-34 ) werden aber immer als ein Token eingelesen. ID: ein gültiger IEC-Identifier ( [a-zA-Z_][a-zA-Z0-9_]* ), wobei zwei aufeinanderfolgende Unterstriche nicht erlaubt sind. Hierzu zählen, anders als in ST, auch die Schlüsselwörter von ST (beispielsweise FUNCTION , INT , EXTENDS , …) SEMICOLON: das Zeichen ; Syntax (parser) Die Syntax der Moduldeklaration wird durch folgende Grammatik definiert. µ ist die leere Sequenz. {MDecl} ::= MODULE {QID} {ImplSpec} {ImportsSpec} {MBody}\n{ImplSpec} ::= IMPLEMENTED_BY {QID} | µ\n{ImportsSpec} ::= IMPORTS {QID} | µ\n{MBody} ::= {SecList}\n{SecList} ::= {Modifiers} {Sec} {SecList} | µ\n{Sec} ::= SEC {QID} {SecTarget} {EntryList} END_SEC\n{SecTarget} ::= OP(\":\") {QID} | µ\n{Modifiers} ::= OP(\"[\") {ModifierList} OP(\"]\") | µ\n{ModifierList} ::= {QID} OP(\",\") {ModifierList} | {QID}\n{EntryList} ::= {Modifiers} {Entry} {EntryList}\n{Entry} ::= {Sec} | {Def}\n{Def} ::= {QID} OP(\":=\") {ValList} SEMICOLON |\n {QID} SEMICOLON\n{ValList} ::= {Val} {ValList} | {Val}\n{Val} ::= ID | LIT | OP\n{QID} ::= ID | ID OP(\".\") {QID} Die Liste der Werte einer Definition ( {ValList} ) muss mit einem Semikolon abgeschlossen werden. Dies vereinfacht die Grammatik und verhindert Mehrdeutigkeiten, da das Semikolon innerhalb eines Wertes ( {VAL} ) nicht vorkommen kann (außer innerhalb eines String-Literals). Ebenso dient der Zuweisungsoperator ( := ) bei Definitionen ( {Def} ) dazu, Mehrdeutigkeiten zwischen dem Namen der Definition ( {QID} ) und den Werten zu vermeiden. Definierte Typen für Definitionen Text: ID.ID (Textlistenname und Textlisten-Identifier) - siehe Lokalisierung von Strings in Textlisten Image: ID.ID (Name und ID der Bildersammlung) ID (IEC Identifier) QID (Qualified identifier): {QID} ::= ID | ID.ID CategoryPath ::= {StringLiteral} | {CategoryPath} Cardinality: [{MIN} .. {MAX}] | [ {MIN} .. INF [ {MIN} und {MAX} sind ganzzahlige, nichtnegative Literale. Falls {MAX} != INF muss {MIN} <= {MAX} gelten. StringLiteral: Ein IEC-String Literal darf Zeilenumbrüche enthalten. StdTaskFlags ::= {StdTaskFlag} | {StdTaskFlags} StdTaskFlag ::= NONE | CREATE_IF_MISSING | READONLY Literal:beliebiges IEC-Literal oder QID (für Enum-Konstanten) DTBoolFlag: µ (leere Sequenz) | TRUE | FALSE SlotType: SUBMODULE | REFERENCE Pragmas: [ {PragmaList} ] {PragmaList} ::= {Pragma} | {Pragma} , {PragmaList} {Pragma} ::= { ( ID | {StringLiteral} | {OP2} )+ } {OP2} : Jeder Operator außer {, }, [, ] und , . InstancePath: InstancePath ::= {IComp} | {IComp} . {IComp} mit {IComp} ::= ID {ArrayAccess}* und {ArrayAccess} ::= [ {IntList} ] und {IntList} ::= Int | Int , {IntList} TaskRef: Standard_Task. ( Low | Medium | High ) | Custom_Task.ID " }, 
{ "title" : "Instanzpfade ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_e00dd4f26a1882aec0a8652000c0a4ae", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Instanzpfade ", 
"snippet" : "An einigen Stellen der Moduldeklaration können Instanzpfade angegeben werden, die eine Variable des Module-Funktionsbausteins adressieren: Bei Parametern, Slots, E\/As, Arrays konfigurierbarer Größe und bei Instanzreferenzen. Ein Instanzpfad besteht aus einer nichtleeren, durch Punkte getrennten Folg...", 
"body" : "An einigen Stellen der Moduldeklaration können Instanzpfade angegeben werden, die eine Variable des Module-Funktionsbausteins adressieren: Bei Parametern, Slots, E\/As, Arrays konfigurierbarer Größe und bei Instanzreferenzen. Ein Instanzpfad besteht aus einer nichtleeren, durch Punkte getrennten Folge von Komponenten: C1.C2…CN . Eine Komponente ist entweder ein IEC-Bezeichner oder eine Komponente gefolgt von einem Index-Ausdruck [i1, …, iN] wobei i1 bis iN ganzzahlige Literale sind. Instanzpfade sind immer relativ zum Funktionsbaustein, der die Modullogik implementiert. Die erste Komponente des Instanzpfads ist ein Member ( VAR_INPUT oder VAR_OUTPUT , je nach Anwendungsfall) des Funktionsbausteins. Hat der Instanzpfad weitere Komponenten, dann adressieren diese die Variable innerhalb des Members. Ansonsten ist das Member selbst adressiert. Instanzpfade können auf Eingangs- oder Ausgangsvariablen eingeschränkt werden (zum Beispiel bei I\/Os). Für Strukturen gelten diese Einschränkungen nicht. Solche Instanzpfade werden als Eingangs-Instanzpfad bzw. Ausgangs-Instanzpfad bezeichnet " }, 
{ "title" : "Lokalisierung von Strings in Textlisten ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_497561d55e22d540c0a8640e01561e3c", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Lokalisierung von Strings in Textlisten ", 
"snippet" : "Texte, die lokalisiert werden sollen (beispielsweise Beschreibungen von Modulen, Name, Beschreibung von Parametern), werden in Textlisten verwaltet. Für die Namen der Sprachen gelten folgende Regeln: Der Name der Sprache hat das Format <LanguageCode>[-<Country\/Region>] (beispielsweise en-US , de-DE ...", 
"body" : "Texte, die lokalisiert werden sollen (beispielsweise Beschreibungen von Modulen, Name, Beschreibung von Parametern), werden in Textlisten verwaltet. Für die Namen der Sprachen gelten folgende Regeln: Der Name der Sprache hat das Format <LanguageCode>[-<Country\/Region>] (beispielsweise en-US , de-DE ). <LanguageCode> ist der Name der Sprache nach ISO 639-1 (beispielsweise de oder en ). <Country\/Region> ist ein Regional-Code nach ISO 3166 Beim Nachschlagen eines Textlisteneintrags wird zunächst nach dem vollen Sprachnamen gesucht und wenn dieser nicht gefunden wird nach dem <LanguageCode> gesucht. Wird auch dieser nicht gefunden, so wird der Default-Text verwendet. Beispiele für Sprachnamen in Textlisten Sprache Name der Sprache Chinesisch zh-CHS Englisch en-US Französisch fr-FR Deutsch de-DE Italienisch it-IT Japanisch ja-JP Portugisisch pt-PT Russisch ru-RU Spanisch es-ES " }, 
{ "title" : "Ableiten von Moduldeklarationen ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_a596cccf5e22d542c0a8640e019ddff8", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Ableiten von Moduldeklarationen ", 
"snippet" : "Analog zum objektorientierten Ableiten eines Funktionsbausteins A von einem Funktionsbaustein B („EXTENDS“) ist auch das Ableiten von Moduldeklarationen über IMPORTS möglich. Die beiden Modifier UPDATE und HIDE werden gesondert behandelt. Dabei gelten folgende Regeln: Der Name des importierten Modul...", 
"body" : "Analog zum objektorientierten Ableiten eines Funktionsbausteins A von einem Funktionsbaustein B („EXTENDS“) ist auch das Ableiten von Moduldeklarationen über IMPORTS möglich. Die beiden Modifier UPDATE und HIDE werden gesondert behandelt. Dabei gelten folgende Regeln: Der Name des importierten Moduls muss mit Namensraum qualifiziert sein, wenn dieses Modul in einer anderen Bibliothek definiert ist. Es darf keine zyklischen Ableitungen geben, insbesondere darf ein Modul nicht von sich selbst ableiten. (Eine zyklische Ableitung ist eine Ableitungskette der Form Modul M_1 leitet von Modul M_2 ab, M_2 von M_3, …, M_N wieder von M_1.) Ein abgeleitetes Modul kann die IMPLEMENTED_BY -Direktive weglassen. In diesem Fall wird der Funktionsbaustein des Basismoduls verwendet. Falls ein abgeleitetes Modul über IMPLEMENTED_BY einen Funktionsbaustein angibt, dann muss dieser entweder vom Funktionsbaustein des Basismoduls ableiten oder identisch mit diesem sein . Ein abgeleitetes Modul übernimmt alle Abschnitte vom Basismodul. Es kann neue Abschnitte hinzufügen oder bestehende verändern. Ein Abschnitt wird verändert, indem er mit demselben Namen und Target und dem Modifier UPDATE im abgeleiteten Modul deklariert wird. In diesem Fall können seine Einträge verändert werden. Alle nicht aufgeführten Einträge des Abschnitts werden aus dem Basismodul übernommen Die Modifier UPDATE und HIDE dürfen nur verwendet werden, wenn der entsprechende Abschnitt (Name und Target) im Basismodul definiert ist. Umgekehrt darf ein Abschnitt, der im Basismodul vorkommt, nur dann im abgeleiteten Modul aufgeführt werden, wenn er mit UPDATE oder HIDE versehen ist. Wenn ein Abschnitt nur mit HIDE und nicht mit UPDATE versehen ist, darf er keine Einträge haben. Bestimmte Einträge müssen in einem abgeleiteten Modul geändert werden (beispielsweise der Name und die Beschreibung.) Beispiel: MODULE MBase IMPLEMENTED_BY FBBase\nSEC MetaData\n DESC := TL.Desc_Base ;\nEND_SEC\nSEC Parameters\n SEC Param : paramxIn\n Variable := xIn ;\n Name := TL.Param1_Name ;\n Desc := TL.Param1_Desc ;\n END_SEC\nEND_SEC\n\nMODULE MDerived IMPORTS MBase\n[UPDATE] SEC MetaData\n DESC := TL.Desc_Derived ;\nEND_SEC\n[UPDATE] SEC Parameters\n [UPDATE,HIDE] SEC Param : paramIn\n Variable := xIn ;\n DEFAULT := TRUE ;\n END_SEC\nEND_SEC In diesem Beispiel wird der Parameter paramIn des Modules MBase im abgeleiteten Modul MDerived mit HIDE verborgen und gleichzeitig mit einem neuen Defaultwert ( TRUE ) versehen. " }, 
{ "title" : "Anmerkung zur Reihenfolge von Abschnitten und Definitionen ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_87237560fda311e1967bf6fe1c17b04f", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Anmerkung zur Reihenfolge von Abschnitten und Definitionen ", 
"snippet" : "Die Reihenfolge der Abschnitte direkt nach dem Modul-Header spielt keine Rolle. Innerhalb der Abschnitte kann die Reihenfolge allerdings sehr wohl eine Rolle spielen. Zum Beispiel bestimmt die Reihenfolge der Slot-Deklarationen die Reihenfolge, in der die Slots im Modulbaum angezeigt werden. Die Rei...", 
"body" : "Die Reihenfolge der Abschnitte direkt nach dem Modul-Header spielt keine Rolle. Innerhalb der Abschnitte kann die Reihenfolge allerdings sehr wohl eine Rolle spielen. Zum Beispiel bestimmt die Reihenfolge der Slot-Deklarationen die Reihenfolge, in der die Slots im Modulbaum angezeigt werden. Die Reihenfolge von Definitionen spielt nie eine Rolle. Für abgeleitete Module gelten folgende Regeln in Bezug auf die Reihenfolge: Die Abschnitte eines Basismoduls kommen immer vor den im Modul selbst definierten Abschnitten. Wird ein Abschnitt aus dem Basismodul mit UPDATE oder HIDE verändert, so hat das keine Auswirkung auf seine Reihenfolge. Für ein abgeleitetes Modul ist es nicht möglich ist, die Reihenfolge, wie sie im Basismodul vorgegeben ist, zu verändern. " }, 
{ "title" : "Autovervollständigung und „Komponenten auflisten“ ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_23e0e10e3a0c71c9c0a8640e0040f55b", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Autovervollständigung und „Komponenten auflisten“ ", 
"snippet" : "Beim Schreiben im Moduleditor werden alle möglichen verfügbaren Sekionsdefinitionen in einem „Komponenten auflisten“-Menü angezeigt. Dabei werden nur sinnvolle Sektionen und Definitionen für die aktuelle Position gezeigt. Selbst wenn einige Untersektionseinträge den gleichen Namen wie Untersektionse...", 
"body" : "Beim Schreiben im Moduleditor werden alle möglichen verfügbaren Sekionsdefinitionen in einem „Komponenten auflisten“-Menü angezeigt. Dabei werden nur sinnvolle Sektionen und Definitionen für die aktuelle Position gezeigt. Selbst wenn einige Untersektionseinträge den gleichen Namen wie Untersektionseinträge anderer Sektionen haben, wird versucht, nur die passenden Sektionsdefinitionen anzuzeigen. Wenn nach der Fertigstellung der ersten Zeile einer Sektion Return gedrückt wird, wird die Sektion mit allen notwendigen Definitionen\/Sektionen und dem END_SEC vervollständigt. Nach den Variablendefinitionen werden Eingangs- und Ausgangsvariablen durch eine „Komponenten auflisten“-Menü angeboten. Flags oder vordefinierte Werte werden ebenfalls in einer „Komponenten auflisten“-Auswahl, die die möglichen Flags\/Werte anzeigt, angeboten. Nach Definitionen, welche Textlisteneinträge oder Einträge von Bildersammlungen verwenden (in den meisten Fällen Desc := ), wird ein „Komponenten auflisten“-Menü mit allen verfügbaren und sichtbaren Textlisten\/Bildersammlungen und deren Einträgen angezeigt. Durch Drücken von F2 kann die entsprechende Eingabeunterstützung geöffnet werden. " }, 
{ "title" : "Initialisierung von Modulinstanzen (Online-Change) ", 
"url" : "ac_initialization_of_module_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Initialisierung von Modulinstanzen (Online-Change) ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Initialisierung und Reinitialisierung von Modulinstanzen und Proxy-Instanzen (Online-Change) ", 
"url" : "ac_initialization_of_module_instances.html#UUID-d33dd918-6f7b-5e75-6686-b9d605273b58_index_2", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Initialisierung von Modulinstanzen (Online-Change) \/ Initialisierung und Reinitialisierung von Modulinstanzen und Proxy-Instanzen (Online-Change) ", 
"snippet" : "Die Methode IBaseInstance.Init(bOnlineChange : BOOL) wird bei der Initialisierung und jedem Online-Change für alle Toplevel-Modulinstanzen und für alle Proxy-Instanzen aufgerufen. Die Module sind dafür verantwortlich, alle verwalteten Modulinstanzen aufzurufen, sofern das nötig ist. Init wird aufger...", 
"body" : "Die Methode IBaseInstance.Init(bOnlineChange : BOOL) wird bei der Initialisierung und jedem Online-Change für alle Toplevel-Modulinstanzen und für alle Proxy-Instanzen aufgerufen. Die Module sind dafür verantwortlich, alle verwalteten Modulinstanzen aufzurufen, sofern das nötig ist. Init wird aufgerufen, sobald alle Parameterwerte, verwaltete und referenzierte Modulinstanzen gesetzt sind und die Modulinstanzen im Modulbaum eingehängt wurden, aber bevor die Tasks gestartet oder fortgesetzt werden. Die Standardimplementierung im Funktionsbaustein Module ruft alle verwalteten Modulinstanzen auf. Die Methoden IBaseInstance.OnBeforeOnlineChange und IBaseInstance.OnAfterOnlineChange werden aufgerufen, bevor und nachdem die Struktur des Modulbaums und die Parameterwerte, verwaltete und referenzierte Modulinstanzen bei einem Online-Change neu gesetzt werden, aber bevor die Tasks gestartet oder fortgesetzt werden. Im Gegensatz zu FB_Init wird diese Methode bei jedem Online-Change aufgerufen, unabhängig davon, ob FB_Exit vorher von einer älteren Instanz aufgerufen wurde. " }, 
{ "title" : "Sektion: MetaData ", 
"url" : "ac_module_fb_sec_metadata.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: MetaData ", 
"snippet" : "MetaData Die Sektion MetaData enthält die Beschreibung des Moduls, die Kategorie und die Icons (der Größe 16x16 Pixel und 32x32 Pixel). SEC MetaData \/\/optional: yes, modifier: [UPDATE]] Desc := <description>; \/\/optional: no, type: text Category := <category name>; \/\/optional: no, type: CategoryPath ...", 
"body" : "MetaData Die Sektion MetaData enthält die Beschreibung des Moduls, die Kategorie und die Icons (der Größe 16x16 Pixel und 32x32 Pixel). SEC MetaData \/\/optional: yes, modifier: [UPDATE]]\n Desc := <description>; \/\/optional: no, type: text\n Category := <category name>; \/\/optional: no, type: CategoryPath\n Icon_16 := <icon16 name>; \/\/optional: no, type: image\n Icon_32 := <icon32 name>; \/\/optional: no, type: image\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: IDOrNothing\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Links := ['<link1>','<link2>',...] \/\/optional: Yes, type: UriCollection\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. Spezifikation: Wenn der der Abschnitt MetaData fehlt, dann wird das Modul als nicht-instanziierbares Basismodul behandelt. Category definiert einen Überbegriff für Module eines Themenbereichs. Das Zeichen | erzeugt eine hierarchische Struktur im Moduldialog. Die Zeichen | und Newline oder Carriage-Return dürfen im Strukturnamen nicht enthalten sein. Icon_16 definiert den Namen des Icons mit einer Auflösung von 16 x 16 Pixel. Die Bilddateien für die Icons werden in einer Bildersammlung definiert. Das Icon Icon_16 wird für den Modulbaum verwendet und das Icon Icon_32 für den Informationsdialog. Inst_Prefix ist das Default-Präfix, das für die Namen der generierten FB-Instanzvariablen von Submodul-Instanzen verwendet wird. Es sind auch leere Prefixe ( Inst_Prefix := ) möglich, für die jedoch keine Überschneidungsfreiheit mit anderen Variablennamen des FBs garantiert werden kann. Die Voreinstellungen können in der Sektion Slot überschrieben werden. Wenn mit IMPORTS von einer Moduldeklaration ableitet wird, dann muss der Abschnitt MetaData aktualisiert werden, sofern das Basismodul einen solchen Abschnitt mitbringt. Dazu muss der Abschnitt mit dem Modifier UPDATE deklariert werden und zumindest Name und Beschreibung neu gesetzt werden. Default_Inst_Name dient dazu einen Default-Namen für Modulinstanzen unter diesem Slot anzugeben. Jedes Modul, das hinzugefügt wird, bekommt standardmäßig den Instanznamen der hier (über eine evtl. mehrsprachige Textliste) angegeben werden kann. Wenn ein Eltern-Slot einen Default-Namen hat, wird dieser dem Default-Namen in Metadata bevorzugt. Links definiert eine Liste von Links. Die Links werden im Moduleditor auf der Registerkarte Information dargestellt. Der Inhalt der ersten URL dieser Liste wird in der Registerkarte Information dargestellt. Beispiel SEC MetaData\n Desc := TL.Desc_Drives ;\n Category := 'Mechatronics'|'Drives' ;\n Icon_16 := IP.Drive_Icon_16 ;\n Icon_32 := IP.Drive_Icon_32 ;\n Default_Inst_Name := IDrive ;\n Links := ['file:\/\/\/d:\\Document1.pdf', 'https:\/\/www.codesys.com', 'mailto:info@codesys.com'];\nEND_SEC Category := 'Mechatronics'|'Drives erzeugt die folgende Struktur: " }, 
{ "title" : "Sektion: Toplevel ", 
"url" : "ac_module_fb_sec_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: Toplevel ", 
"snippet" : "Toplevel Module, die in der ersten Ebene des Baumes zu finden sind, heißen Toplevel-Module. Sie zeichnen sich dadurch von den anderen Modulen aus, dass sie über Methoden verfügen, die direkt von einer\/mehreren Tasks aufgerufen werden. Toplevel-Module enthalten die Sektion Toplevel . SEC Toplevel \/\/o...", 
"body" : "Toplevel Module, die in der ersten Ebene des Baumes zu finden sind, heißen Toplevel-Module. Sie zeichnen sich dadurch von den anderen Modulen aus, dass sie über Methoden verfügen, die direkt von einer\/mehreren Tasks aufgerufen werden. Toplevel-Module enthalten die Sektion Toplevel . SEC Toplevel \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/(optional: no, type: Text)\n Flags:= <flag>; \/\/(optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. Spezifikation: GVL_Name legt die globale Variablenliste fest, in der die Instanz für das Modul und alle seine Unterinstanzen angelegt werden. Der Platzhalter %Instancename% (Groß-\/Kleinschreibung spielt keine Rolle) wird dabei durch den Instanznamen der Modulinstanz ersetzt. Default_Application definiert die Vorbelegung der Applikationszuordnung auf eine bestimmte Applikation für alle Instanzen dieses Moduls. Wenn eine Default-Applikation definiert ist, kann der Parameter Default_POUPool nicht mehr verwendet werden. Default_POUPool definiert die Vorbelegung der Applikationszuordnung auf einen POU-Pool für alle Instanzen dieses Moduls. Wenn eine Default-POU-Pool definiert ist, kann der Parameter Default_Application nicht mehr verwendet werden. Der Parameter Pragmas enthält eine in eckige Klammern gefasste, Komma-separierte Liste von Compiler-Pragmas, die vor FB-Instanzen des Moduls eingefügt werden. Über den Abschnitt Standard_Task wird festgelegt, aus welcher\/n Task(s) Aufrufe erwartet werden. Dazu sind drei Standardtasks vorgesehen: LOW , MEDIUM und HIGH , die als Target des Abschnitts verwendet werden. Die Definitionen von Standard_Task haben folgende Bedeutung: Name : Der Default-Taskname, der nach dem Erzeugen der Modulinstanz als Taskzuordnung eingetragen wird. Desc : Bezeichner für den Taskaufruf. Dieser sollte kurz und aussagekräftig sein, beispielsweise I\/O-Task ) Flags : Folgende Werte können mit | kombiniert werden: CREATE_IF_MISSING : Die Task wird neu angelegt, wenn sie nicht existiert. READONLY : Der Anwender kann die Taskzuordnung nicht ändern. UPDATE_IOS : Die Task wird zum Aktualisieren von E\/As verwendet. Jeder E\/A kann durch den Parameter UpdateInTask in der Sektion IO überschrieben werden. NONE : Kein Flag gesetzt. Beispiel SEC Standard_Task : MEDIUM\n Name := MainTask ;\n Desc := TL.TaskMedium_Desc ;\n Flags := READONLY | CREATE_IF_MISSING ;\nEND_SEC Über den Unterabschnitt Custom_Task kann ein Modul eine oder mehrere eigene Tasks definieren. Das Target des Abschnitts muss der Name einer Methode des Modul-Funktionsbausteins sein. Die Methode darf keine Argumente haben (weder INPUT noch OUTPUT noch INOUT ). Priority : Die Task-Priorität Interval : Das Task-Intervall (TIME- oder LTIME-Konstante). Flags : Folgende Werte können mit | kombiniert werden: SHARED : Dieses Flag ist aus Kompatibilitätsgründen noch vorhanden, wird jedoch implizit immer als gesetzt angenommen. Dies bedeutet grundsätzlich, dass wenn eine Task mit den in der Sektion Custom_Task festgelegten Eigenschaften existiert, diese Task verwendet wird. Da eine neue Task erzeugt wird wenn keine bestehende Task mit den passenden Eigenschaften existiert, ist dieses Flag veraltet. Der Name der erzeugten Task ist TASK_<Modulinstanzname>_<MethodenName> . UPDATE_IOS : Der Task wird zum Update von E\/As verwendet, die mit ST-Ausdrücken oder direkt mit Modul-E\/As verbunden sind. NONE : Kein Flag gesetzt. Für die angegebene Methode gibt es keine Standard-Implementierung in der Modulklasse. Beispiel SEC Custom_Task : Method1\n Priority := 7 ;\n CycleTime := t#14ms ;\n Flags := NONE ;\nEND_SEC Es muss genau eine Standardtask oder spezifische Task das Flag UPDATE_IOS gesetzt haben. Hier einige grundlegende Regeln, wie Tasks erzeugt werden: Wenn Standardtasks existieren, die das Flag CREATE_IF_MISSING nicht gesetzt haben, sollte eine Task mit dem festgelegten Namen und den Eigenschaften der Generatoreinstellungen existieren. Wenn die Eigenschaften nicht mit den spezifizierten Eigenschaften übereinstimmen, wird eine Warnung ausgegeben. Wenn Standardtasks existieren, die das Flag CREATE_IF_MISSING gesetzt haben, wird zuerst eine Task mit den spezifizierten Eigenschaften erzeugt. Wenn nun die Generatoreinstellungen für diese Task geändert werden, wird die Task entsprechend angepasst, ohne eine Warnung auszugeben. Standardtasks unterschiedlichen Typs, die den gleichen Tasknamen referenzieren, sind nicht erlaubt. In diesem Fall wird eine Fehlermeldung ausgegeben. In Abhängigkeit von den geforderten Taskaufrufen muss ein Toplevel-Modul über folgende Methoden verfügen, die aus der definierten Task heraus am Taskanfang und –ende aufgerufen werden: METHOD CallPrioHighStart: BOOL\nMETHOD CallPrioHighEnd: BOOL\nMETHOD CallPrioMediumStart: BOOL\nMETHOD CallPrioMediumEnd: BOOL\nMETHOD CallPrioLowStart: BOOL\nMETHOD CallPrioLowEnd: BOOL Das Toplevel-Modul muss für den Aufruf seiner Untermodulinstanzen selbst Sorge tragen. Untermodulreferenzen sollen nicht aufgerufen werden. Die Default-Implementierung im FB Module ruft die jeweiligen Methoden aller Untermodulinstanzen in Reihenfolge des Baumes auf. Der Super-Pointer bietet einen Zugriff auf die Instanz des Basisfunktionsbausteines. Deshalb kann zum Beispiel der Aufruf SUPER^.CallPrioHighStart() verwendet werden, um die Methode Module.CallPrioHighStart() aufzurufen, falls der Funktionsbaustein von Module abgeleitet wurde. In diesem Fall stellt die Implementierung in Module sicher, dass alle Untermodule aufgerufen werden. " }, 
{ "title" : "Sektion: IO ", 
"url" : "ac_module_fb_sec_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: IO ", 
"snippet" : "IO In dieser Sektion werden die Eingänge und Ausgänge definiert. Alle definierten Eingänge und Ausgänge sind im E\/As verbinden verfügbar. SEC IO \/\/optional: yes, modifier: [UPDATE] SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: no, typ...", 
"body" : "IO In dieser Sektion werden die Eingänge und Ausgänge definiert. Alle definierten Eingänge und Ausgänge sind im E\/As verbinden verfügbar. SEC IO \/\/optional: yes, modifier: [UPDATE]\n SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\n SEC Output : <output identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\nEND_SEC Für Details zur Syntax der Definitionstypen siehe: Syntax der Moduldeklaration beschrieben. Spezifikation: Variable ist der Instanzpfad einer Eingangsvariablen (Input) oder Ausgangsvariable (Output). Alle Komponenten des Pfads dürfen für Eingänge nur Eingangsvariablen sein (oder lokale Variablen bei Strukturen). Genauso dürfen die Komponenten des Pfads für Ausgänge nur Ausgangsvariablen sein (oder lokale Variablen bei Strukturen). Die Variable muss entweder einen primitiven Typ oder einen Enum-Typ haben. Dieselbe Variable kann gleichzeitig Parameter und Ein-\/Ausgang sein. Dieselbe Variable darf nicht von zwei verschiedenen E\/As verwendet werden. Das Target eines Input oder Output Abschnitts muss den Eingang oder Ausgang eindeutig identifizieren. (Groß-Kleinschreibung wird nicht unterschieden.) Der Parameter UpdateInTask beschreibt die Task zum Aktualisieren der E\/As. Wenn diese Definition fehlt, dann wird die Task mit dem Flag UPDATE_IOS verwendet. Für Toplevel-Module ist es ein Fehler, wenn die bei UpdateInTask angegebene Task für das Modul nicht definiert ist. Beispiel SEC Io\n SEC Input : uiTemperature\n Variable := uiTemperature ;\n Name := TL_WeatherStation.NAME_iTemperature ;\n Desc := TL_WeatherStation.DESC_iTemperature ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\n SEC Output : uiLigh\n Variable := uiLightnessSouth ;\n Name := TL_WeatherStation.NAME_uiLightnessSouth ;\n Desc := TL_WeatherStation.DESC_uiLightnessSouth ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\nEND_S " }, 
{ "title" : "Sektion: Parameters ", 
"url" : "ac_module_fb_sec_parameters.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: Parameters ", 
"snippet" : "Parameters In dieser Sektion werden die Parameter definiert, die später in den Parametern der Modulinstanz parametriert werden können. SEC Parameters \/\/optional: yes, modifier: [UPDATE] SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional...", 
"body" : "Parameters In dieser Sektion werden die Parameter definiert, die später in den Parametern der Modulinstanz parametriert werden können. SEC Parameters \/\/optional: yes, modifier: [UPDATE]\n SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: yes, type: InstancePath\n VariableType := <data type> \/\/optional: yes, type: @JG???IEC-Typ\n Name := <parameter name>; \/\/optional: no, type: text\n Desc := <parameter description>; \/\/optional: no, type: text\n Group := <parameter group name> \/\/optional: yes, type: text\n MustBeSet := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n Default := <default value>; \/\/optional: yes, type: LiteralOrConstant\n Max := <max value>; \/\/Optional: yes, type: LiteralOrConstant\n Min := <min value>; \/\/Optional: yes, type: LiteralOrConstant\n END_SEC\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. Spezifikation: Das Target des Abschnitts Param muss den Parameter eindeutig identifizieren. Die Definition Variable ist ein Eingangs-Instanzpfad relativ zum Modul-Funktionsbaustein. In dieser Variable wird der Parameterwert gespeichert, ihr Typ gibt den Parametertyp vor. Wenn Variable deklariert ist, muss der Parameter VariableType nicht definiert sein und wird ignoriert. Der Parameter VariableType beschreibt den IEC-Typ der Variablen. Wenn VariableType deklariert ist, über die Definition Variable aber keine tatsächlich existierende FB-Variable angegeben wurde, muss die Definition Default vorhanden sein. Dieser Wert muss zum Typ VariableType passen. Die Parameter Name und Desc sind Strings und werden in einer Textliste definiert. Modulparameter können Basistypen oder Enumerationen sein, keine Strukturinstanzen oder Arrays. Parametervariablen müssen Initialisierungswerte haben, die im Deklarationsteil des Funktionsbausteins definiert sind. Der optionale Parameter Default ermöglicht das Überschreiben des Initialisierungswerts. Für den Initialisierungsausdruck und für den Standardwert sind Literale und Konstanten des korrekten Typs zulässig. Dazu zählen auch Bibliotheksparameter. Der optionale Parameter Group erlaubt die Parameter in Gruppen zu gliedern. Jede Gruppe wird dann als eigene Registerkarte im Moduleditor unter Parameter angezeigt. Mit dem optionalen Parameter MustBeSet kann der Anwender gezwungen werden, einen Parameter im Moduleditor zu setzen. Wird der Parameter nicht gesetzt, erscheint eine Fehlermeldung. Die Definitionen Min und Max legen die minimalen und maximalen Werte fest, innerhalb der sich ein Parameterwert bewegen muss. Die Überprüfung dieser Grenzwerte kann nur stattfinden, wenn die Variable des Parameters ein numerischer Typ oder ein Zeitpunkt ist. In den anderen Fällen können diese Definition nicht verwendet werden und führen bereits beim Scannen zu Fehlern. Beispiel SEC Parameters\n SEC Param : InParam1\n Variable := xIn1;\n VariableTyp := BOOL;\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC Die Variable xIn1 muss im Deklarationsteil des Funktionbausteins definiert werden: xIn1 : BOOL := FALSE ; " }, 
{ "title" : "Initialisierungswerte ", 
"url" : "ac_module_fb_sec_parameters.html#UUID-1cddf7ea-faa7-0b82-e29a-04e9f27653b0_ac_module_fb_sec_parameters0", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: Parameters \/ Initialisierungswerte ", 
"snippet" : "Als Initialisierungsausdruck gilt der Ausdruck, der den Wert der Variablen bei der Initialisierung der Daten bestimmt. Bei einfachen Variablen des FB ist das immer der Ausdruck rechts von der Variablendeklaration: iVar : INT := 17 ; \/\/ Initialisierungswert: 17 Bei Variablen in Strukturen kann auch d...", 
"body" : "Als Initialisierungsausdruck gilt der Ausdruck, der den Wert der Variablen bei der Initialisierung der Daten bestimmt. Bei einfachen Variablen des FB ist das immer der Ausdruck rechts von der Variablendeklaration: iVar : INT := 17 ; \/\/ Initialisierungswert: 17 Bei Variablen in Strukturen kann auch die Initialisierung der Struktur ausschlaggebend sein: TYPE s : STRUCT\n i1 : INT := 7 ;\n r1 : REAL := 5 ;\nEND_STRUCT END_TYPE Deklaration im Modul-FB: structVar : s := (i1 := 2, r1 := 0.0) ; In diesem Fall ist der Initialisierungsausdruck, der den Wert von structVar.i1 bestimmt 2 (und nicht 7 ). Bei verschachtelten Strukturen müssen alle Initialisierungen auf dem Pfad vom Modul-FB bis zur Variable berücksichtigt werden. Es gewinnt die äußerste Initialisierung, die der Variable einen Wert zuweist. " }, 
{ "title" : "Sektion: Slots ", 
"url" : "ac_module_fb_sec_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: Slots ", 
"snippet" : "Slots Diese Sektion definiert die Verfügbarkeit und den Typ der Steckplätze von Modulen im Modulbaum. Es können zwei unterschiedliche Steckplätze definiert werden. Steckplatz SEC Slots \/\/optional: yes, modifier: [UPDATE]] SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable ...", 
"body" : "Slots Diese Sektion definiert die Verfügbarkeit und den Typ der Steckplätze von Modulen im Modulbaum. Es können zwei unterschiedliche Steckplätze definiert werden. Steckplatz SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Role := <role name>; \/\/optional: no, type: text\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identigier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier> \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. Spezifikation: Der Abschnitt Slot definiert einen Steckplatz, der 0 oder 1 Verbindung eingehen kann. Das Target eines Slot -Abschnitts muss den Steckplatz eindeutig identifizieren. Somit darf es keine zwei unterschiedlichen Steckplätze geben (egal ob Slot oder Slot_Multi ), die dasselbe Target haben. (Groß-\/Kleinschreibung ist unerheblich.) Variable ein Eingangs-Instanzpfad relativ zum Modulfunktionsbaustein. Der Instanzpfad darf sich in allen seinen Komponenten nur auf Eingangsvariablen beziehen (bei Strukturinstanzen auch lokale Variablen). Der Typ der adressierten Variable muss ein Interface oder ein FB-Typ sein. Zwei verschiedene Slots dürfen nicht dieselbe Variable verwenden. Role definiert die Rollenbezeichnung des Steckplatzes. Type definiert den Steckplatztyp. Die Verbindungsart kann folgende Werte annehmen: SUBMODULE : Slot für Submodul-Instanzen. REFERENCE : Slot für referenzierte Submodul-Instanzen. DECOUPLED : Slot für „Decoupled“-Moduleinstanzen. Siehe auch: Sektion Decoupled Inst_Prefix ist ein Präfix, das für den Namen der generierten FB-Instanzvariable verwendet wird. Leere Präfix ( Inst_Prefix := ; ) sind auch möglich, können jedoch Konflikte mit anderen Variablennamen des Funktionsbausteins erzeugen. Darf nur für Steckplätze vom Typ SUBMODULE angegeben werden. Optional gibt an, ob der Steckplatz unverbunden bleiben darf oder immer verbunden werden muss. Default_Inst_Name dient dazu einen Default-Namen für Modulinstanzen unter diesem Slot anzugeben. Jedes Modul, das hinzugefügt wird, bekommt standardmäßig den Instanznamen der hier (über eine evtl. mehrsprachige Textliste) angegeben werden kann. Der Default-Name des jeweiligen Slots wird dabei dem der Modul-MetaDaten bevorzugt. Pragmas enthält eine Liste von Compiler-Pragmas, die vor FB-Instanzen der Submodule eingefügt werden. Pragmas dürfen nur für verwaltete Steckplätze verwendet werden. RegularExpressionParameterId definiert einen Parameter vom Typ STRING\/WSTRING für diesen Steckplatz. Der Wert dieses Parameters wird als regulärer Ausdruck interpretiert und muss mit dem Namen des eingefügten Submoduls übereinstimmen. Im Abschnitt Slot.Default_Allocation bzw. Slot_Multi.Default_Allocation können Default-Einstellungen für Steckplätze mit variabler Anzahl von Elementen (Multi_Slots und Slots) festgelegt werden. Für Slots.Multi_Slot müssen diese durch eindeutige Targets beschrieben werden, wogegen Slots.Slot kein Target und nur einen Abschnitt Default_Allocation besitzt. Die Instanz wird wird gemäß ihrer Position innerhalb des Abschnitts eingefügt. Der Modulname und Instanzname wird durch Slot.DefaultModule bzw. Slot.DefaultName beschrieben. Wenn diese Definitionen nicht vorhanden sind, werden Default_Allocation.Module_Name und Default_Allocation.Instance_Name verwendet. Es wird empfohlen, Default_Allocation.* anstelle von DefaultModule und DefaultName für Slots zu verwenden, da diese nur noch aus Kompatibilitätsgründen vorhanden sind. Die Definition einer Default-Modulinstanz kann im Unterabschnitt Default_Allocation festgelegt werden. Module_Name ist der Name des Moduls von dem automatisch eine Instanz angelegt und mit dem Steckplatz verbunden wird. Wenn das Modul aus einer Bibliothek kommt, muss der Modulname mit Namespace qualifiziert sein. Der Parameter ist nur für Steckplätze vom Typ SUBMODULE erlaubt. Endlose Aufrufe sind nicht erlaubt und erzeugen eine Fehlermeldung (Beispiel: Deklaration von Modul „A“ enhält ein Default-Modul „B“; Deklaration von Modul „B“ enthält Default-Modul „A“.) Instance_Name muss immer dann angegeben werden, wenn DefaultModule angegeben wurde, und sonst nie. Es muss ein gültiger IEC-Identifier sein, der als Name der Default-Modulinstanz verwendet wird. Der Name darf nicht mit einem Unterstrich ( _ ) beginnen oder enden. Die Default-Namen aller Steckplätze einer Deklaration müssen eindeutig sein. (Groß- und Kleinschreibung spielt keine Rolle.) NotDeletable legt fest, ob das Modul durch den Anwender gelöscht werden kann. Wenn TRUE , dann kann das Moduls nicht gelöscht werden. Es wird ein Fehlerdialog angezeigt. Ist der Parameter FALSE oder wird er weggelassen, kann das Modul gelöscht werden. VisuEmbeddings : Wird der Parameter Empty auf TRUE gesetzt, so wird eine leere Liste an Embedded-Visus für diese Modulinstanz angelegt. Wenn der Wert FALSE ist, kann über die Auflistung der gewünschten Embedded-Visus im Unterabschnitt Embedding die gewünschte Liste von Embedded-Visus für die Modulinstanz erzeugt werden. Jede Sektion Embedding muss dazu den Namen VisuName der gewünschten Embedded-Visu definieren und kann zusätzliche Eigenschaften wie Target oder LinkId dieser Embedded-Visu angeben. PageVisu : In dieser Sektion kann die gewählte PageVisu der Modulintanz gewählt werden ( VisuName ). Weiterhin kann angegeben werden, ob diese einen TopLevelTap erzeugen soll. Der Parameter TopLevelTap kann dazu nur die Werte TRUE und FALSE annehmen. IOMappings : Im Unterabschnitt Mapping kann hier die Belegung von IO-Kanälen festegelegt werden. Das Target einer jeden Sektion Mapping gibt dabei den gewünschten Ziel-IO-Kanal an. Für die Default-Konfiguration kann der Kanal als ungemapped NoMapping oder mit einer STExpression vorbelegt werden. Parameters : In dem Unterabschnitt Param kann der Wert Value eines jeden Parameters, der im Target der Sektion angegeben wird, spezifiziert werden. Mehrfachsteckplatz In der Sektion Slot_Multi kann eine Liste von Subinstanzen und Referenzen definiert werden. SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot_Multi : <slot name> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Role := <name role>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Pragmas := <pragma list>; \/\/optional: yes, type: Pragmalist\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier>; \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC Zusätzliche Spezifikationen: Var_Count beschreibt den Eingangs-Instanzpfad eines Modulfunktionsbausteins von ganzzahligem Typ. In dieser Variable wird gespeichert, wie viele Instanzen mit dem Steckplatz verbunden sind. Cardinality defines die minimale und maximale Anuahl von Instanzen. Mit dem Abschnitt Slot_Multi.Default_Allocation können Default-Belegungen für Steckplätze mit variabler Anzahl von Elementen definiert werden. Sie müssen über eindeutige Targets identifiziert werden. Die Instanzen werden in der Reihenfolge der Abschnitte eingefügt. Für den Modulnamen und Instanznamen gelten die Angaben für Slot.DefaultModule oder Slot.DefaultName . Die Anzahl der Default-Belegungen darf die obere Stelligkeit nicht überschreiten. Die von einem Slot_Multi -Abschnitts adressierte Variable muss vom Typ POINTER TO <INTERFACE> sein. Jede ganzzahlige Eingangsvariable darf maximal einmal durch Var_Count adressiert werden. (Dies bezieht auch InstRef_Multi.Var_Count und VarArray.Var_Count mit ein) Beispiel SEC Slot\n SEC Slot_Multi : subs\n Variable := pSubs;\n Var_Count := uiArraySize;\n Role := TL.Role;\n Cardinality := [2 .. 17];\n Type := SUBMODULE;\n RegularExpressionParameterId := Param_RegEx_Ref;\n SEC Default_Allocation : def1\n Module_Name := Sub1;\n Instance_Name := Submodule;\n END_SEC\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC Der Deklarationsteil des Funktionsbausteines muss uiArraySize: UINT; pSubs: POINTER TO ITestModule enthalten. Im Beispiel wird ein Steckplatz definiert, der mindestens 2, höchstens aber 17 Unterinstanzen fasst. Für die Unterinstanzen wird ein Array erzeugt, pSubs zeigt auf das Array. Ein Submodul vom Typ Sub1 wird beim Anlegen der Instanz automatisch erzeugt und mit Namen Submodule unter den Steckplatz eingehängt. " }, 
{ "title" : "Sektion: SourceTemplate ", 
"url" : "ac_module_fb_sec_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: SourceTemplate ", 
"snippet" : "SourceTemplate Die Untersektionen von SourceTemplate definieren Funktionsbausteine, die mit in das Projekt kopiert werden. Im Moduleditor werden die hier definierten Funktionsbausteine aufgelistet. Dort können Sie das Kopieren aktivieren oder deaktivieren. Siehe auch SourceTemplate SEC std.SourceTem...", 
"body" : "SourceTemplate Die Untersektionen von SourceTemplate definieren Funktionsbausteine, die mit in das Projekt kopiert werden. Im Moduleditor werden die hier definierten Funktionsbausteine aufgelistet. Dort können Sie das Kopieren aktivieren oder deaktivieren. Siehe auch SourceTemplate SEC std.SourceTemplate\n SEC SourceFB : <Identifier> \/\/ optional: no\n SourceType := <FunctionBlock>; \/\/ optional: no, type: InstancePath\n Variable := <variable name>; \/\/ optional: no, type: InstancePath\n Default := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n IsMandatory := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n FBVariable := <variable name>; \/\/ optional: yes, type: InstancePath\n DestinationType := <default name>; \/\/ optional: yes, Type: String\/Literal\n END_SEC\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. Spezifikation: Der Identifier dient der Zuordnung im Editor und der Namensgebung, falls in DestinationType nichts angegeben ist. In SourceType wird der Funktionsbaustein spezifiziert, der kopiert werden soll. Variable muss eine Input-Variable des Modul-FBs darstellen. Sie muss entweder ein Zeiger auf eine Basisklasse des kopierten Funktionsbausteins oder ein Interface darstellen, das der kopierte Funktionsbausteins implementiert. Über Default wird angegeben, ob der Funktionsbaustein standardmäßig für dieses Modul kopiert wird. Fehlt dieser Eintrag, so ist TRUE der Standardwert. Diese Option kann im Modulinstanz-Editor angepasst werden. Wenn IsMandatory auf TRUE gesetzt ist, kann der Projektierer die Option IsToCopy im Editor nicht ändern. Mit FBVariable wird eine Input-Variable des kopierten Funktionsbaustein angegeben, die mit der Moduleinstanz gefüllt wird. Deren Typ kann ein Zeiger auf einen Basistyp des Modul-FBs oder ein Zeiger auf Interface des Modul-FBs sein. In DestinationType wird ein Standardname für den kopierten Funktionsbaustein angegeben. Wenn diese Definition fehlt, so gilt folgende Namenskonvention: <Name der Modulinstanz>_<Identifier>[_<fortlaufendeNummer>] . Die angegebenen SourceTemplates werden in den Ordner AC_SourceTemplate kopiert und vom zugehörigen Modul-FB instantiiert und initialisiert. Einmal erzeugte SourceTemplates können editiert werden und werden bei erneuten Generierungsläufen nicht überschrieben. Nicht mehr verwendete SourceTemplates werden umbenannt (anhängen von <_unused >) und in den Unterordner <UnusedSourceTemplates> verschoben. Beispiel SEC std.SourceTemplate\n SEC SourceFB : ID_ConnectSwitches\n SourceType := ConnectSwitches;\n Variable := itfConnect;\n FBVariable := pBuilding;\n Default := TRUE;\n IsMandatory := FALSE;\n DestinationType := 'TypeInModuleDescription';\n END_SEC\nEND_SEC " }, 
{ "title" : "Sektion: Visu ", 
"url" : "ac_module_fb_sec_visu.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: Visu ", 
"snippet" : "Visu SEC Visu \/\/optional: yes, modifier: [UPDATE] Toplevel_Tab; \/\/optional: yes, type: bool Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: Vis...", 
"body" : "Visu SEC Visu \/\/optional: yes, modifier: [UPDATE]\n Toplevel_Tab; \/\/optional: yes, type: bool\n Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: VisuList\n\n SEC DefaultEmbeddings \/\/optional: yes\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier: [HIDE, UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: literal\n Target := <target name>; \/\/optional: yes, type: literal\n ProxyVisuName := <visu name>; \/\/optional: yes, type: literal\n LinkId := <linkID>; \/\/optional: yes, type: literal\n END_SEC\n END_SEC\n\n SEC Toplevel_Tab_Hotkey \/\/optional: yes\n Hotkey := <keycode>; \/\/optional: no, type: literal\n Modifiers := <modifier>; \/\/optional: yes, modifier: [SHIFT, CONTROL, ALT]\n END_SEC\n\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. Spezifikation: Toplevel_Tab legt fest, ob die Checkbox Erzeuge Toplevel-Reiter im HMI-Editor standardmäßig aktiviert ist oder nicht. Page definiert eine Liste von verfügbaren Visualisierungsobjekten eines Submoduls. Embedded definiert eine konkrete Liste der verfügbaren Visualisierungsobjekte des Submoduls, die in andere Visualisierungsbilder eingebettet werden. Der Platzhalter %PAGE_VISU% anstelle des Visualisierungsnamens ermöglicht, dass die erzeugten Visualisierungsbilder optional in andere Seiten eingebettet werden. Embedded_Proxy definiert eine Liste von verfügbaren Visualisierungsobjekten des Moduls. Die Liste wird nur dann verwendet, wenn ein Decoupled-Modul in einen Decoupled-Slot eingefügt wird und nicht unter derselben Steuerung wie seine Vater-Modulinstanz (also als Proxy) erzeugt wird. Für Module, die ein anderes Module importieren, kann anstelle des Visualisierungsnamens der Platzhalter %NONE% eingesetzt werden. Dies bewirkt ein Verstecken der importierten Visualisierungen. Dieses Vorgehen ist für sowohl für die Liste der Visualisierungsbilder als auch für eingebettete (Proxy-)Visualisierungsbilder möglich. Sektion DefaultEmbeddings : Diese Sektion dient der Angabe von Standardeinbettungen, die dann auf der Registerkarte HMI eines Submoduls bereits vorkonfiguriert erscheinen (ähnlich der Sektion Default_Allocation , siehe Sektion Slots ). Die gewünschten Standardeinbettungen werden dazu in Untersektionen Embedding beschrieben. Voraussetzung: Das angegebene Visualisierungsobjekt und der Proxy müssen in der Liste der möglichen Einbettungen für dieses Modul enthalten sein (siehe oben: Embedded und Embedded_Proxy ). Sektion Toplevel_Tab_Hotkey : Diese Sektion definiert ein Tastaturkürzel als Standardeinstellung für eine Toplevel-Seite. Tastaturkürzel dürfen nicht mehrfach verwendet werden. Diese Einstellung kann im Moduleditor in der Registerkarte HMI angepasst werden. Beispiel SEC Visu\n Toplevel_Tab ;\n Page := [VISU_CNC_Machine_1, VISU_CNC_Machine_2];\n Embedded := [%PAGE_VISU%];\n SEC DefaultEmbeddings\n SEC Embedding : No1\n VisuName := SubModule_Emb;\n Target := '..\/..\/TopLevel_2';\n END_SEC\n SEC Embedding : No2\n VisuName := SubModule_Emb_2;\n \/\/ProxyVisuName := SubModule_Emb_1;\n Target := '';\/\/ leave empty for next ancestor\n END_SEC\n END_SEC\n SEC Toplevel_Tab_Hotkey\n Hotkey := T;\n Modifiers := SHIFT | CONTROL;\n END_SEC\nEND_SEC Der Visualisierungsname ist der Name des entsprechenden Visualisierungsobjekts, wobei Groß- und Kleinschreibung keine Rolle spielt. Das Visualisierungsobjekt muss sich in der selben Hierarchieebene befinden wie der Funktionsbaustein des Moduls. Für die Schnittstelle der Visualisierungsobjekte gelten folgende Regeln: Alle Visualisierungsobjekte und eingebetteten Visualisierungsobjekte können eine VAR_IN_OUT-Variable mit Namen inst vom Typ des Modulfunktionsbausteins oder einer Basisklasse haben (Groß- und Kleinschreibung beim Variablennamen spielt keine Rolle). VAR_IN_OUT   inst : <MODULE_FB> ; END_VAR Alternativ zu der hier beschriebenen Möglichkeit mit VAR_IN_OUT kann auch eine VAR_INPUT-Variable verwendet werden. Diese Variable muss folgende Anforderungen erfüllen: Name: inst Typ: Interface, das der Modulfunktionsbaustein implementiert Eingebettete Visualisierungsobjekte können zusätzlich zwei weitere Variablen haben (Groß- und Kleinschreibung bei den Parameternamen spielt keine Rolle): VAR_INPUT paVisuFB : POINTER TO POINTER TO AC_Visu_Base ; iOwnFrameIndex : INT ; END_VAR Es müssen entweder beide oder keine dieser Variablen vorhanden sein. Diese beiden Variablen geben eingebetteten Visualisierungen die Möglichkeit, den zentralen Frame in der Toplevel-Visualisierung umzuschalten. paVisuFB ist ein Array von Pointern auf AC_Visu_Base -Instanzen. Über die globale Visualisierungsvariable CURRENTCLIENTID kann auf die korrekte Instanz des aktuellen Clients zugegriffen werden. Die Frame-Umschaltung erfolgt über eine ST-Aktion der Form paVisuFB[CURRENTCLIENTID]^.uiFrameIdx := iOwnFrameIndex ; iOwnFrameIndex ist der Index, den das Visualisierungsbild des eigenen Moduls in diesem Toplevel-Frame hat. (Falls das eigene Modul kein Visualisierungsbild definiert ist dieser Index -1.) Außer den oben genannten Variablen darf die Schnittstelle keine weiteren VAR_INPUT, VAR_OUTPUT oder VAR_INOUT Variablen aufweisen. Die AC_Visu_Base -Instanzen bieten zusätzlich noch die Funktion GetModuleFrameIndex , die für beliebige Modulinstanzen (siehe IModule in AC_Module_Base.library) den Index ihres Visualisierungsbilds in der Toplevelvisualisierung zurück gibt (falls überhaupt ein Visualisierungsbild vorhanden ist). Damit ist es möglich, zu beliebigen Visualisierungensbilder im Modulinstanz-Baum zu springen. Um die Navigation auch innerhalb des Codes von Modulen zu ermöglichen, besitzt das Environment der Module (siehe IModule in AC_Module_Base.library ) ein Member Environment.visus , das obigem paVisuFB -Pointer entspricht. Um die Variable CURRENTCLIENTID verwenden zu können, muss die Bibliothek VisuGlobalClientManager eingebunden werden (Kategorie „Intern|Visu“). Die erste Visualisierung wird als Standardeinstellung verwendet. " }, 
{ "title" : "Sektion: Trend ", 
"url" : "ac_module_fb_sec_trend.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: Trend ", 
"snippet" : "Trend SEC tre.Trend \/\/optional: yes, modifier: [UPDATE] SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE] Task := <trend task> \/\/optional: yes, type: TimeLiteral CycleTime := <time value> \/\/optional: yes, type: TimeLiteral LimitType := <limit type> \/\/optional: yes, type...", 
"body" : "Trend SEC tre.Trend \/\/optional: yes, modifier: [UPDATE]\n SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE]\n Task := <trend task> \/\/optional: yes, type: TimeLiteral\n CycleTime := <time value> \/\/optional: yes, type: TimeLiteral\n LimitType := <limit type> \/\/optional: yes, type: FileLimitType\n LimitMaximum := <max bytes> \/\/optional: yes, type: Literal\n RecordCondition \/\/optional: yes, type: InstanceAccess\n SEC Visu \/\/optional: yes, modifier: [UPDATE]\n VisuPlaceholder \/\/optional: yes, type: StringLiteral\n VisuTemplate := <visu template> \/\/optional: yes, type: StringLiteral\n Target := <path module instance \/\/optional: yes, type: StringLiteral\n END_SEC\n END_SEC\n\n SEC TrendVariable : <variable identifier> \/\/optional: yes, modifier: [UPDATE]\n Variable := <variable name> \/\/optional: yes, type: InstanceAccess\n TrendRecording := <recording name> \/\/optional: no, type: : Id)\n Description := <tooltip> \/\/optional: yes, type: TextRef\n Color := <graph color> \/\/optional: yes, type: Literal\n GraphType := <graph type> \/\/optional: yes, type: GraphType\n LineWidth := <width> \/\/optional: yes, type: Literal\n LineStyle := <line style> \/\/optional: yes, type: LineStyle\n SEC Warning : MIN\/MAX \/\/optional: yes, modifier: [UPDATE]\n Limit := <limit value> \/\/optional: no, type: Literal\n Color := <limit color> \/\/optional: yes, type: Literal\n END_SEC\n END_SEC\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. Spezifikation: Task : Legt die Task fest, in der die Trendaufzeichnung stattfinden soll. Wenn keine Task angegeben wird, wird die vom Visu-Trend automatisch angelegte Task verwendet. CycleTime : Zykluszeit der Trendaufzeichnung. LimitType : Art der Limitierung des aufgezeichneten Trends fest. LimitMaximum : Maximale Größe der Trendspeicherung in KB (nur bei LimitType ==FileLimit ). RecordCondition : Aufzeichnungsbedingung. Die referenzierte Variable muss vom Typ BOOL sein. VisuPlaceholder : Platzhalter, der durch die erzeugte Trendvisualisierung ersetzt werden soll. VisuTemplate : Vorlage für die zu erzeugende Visu. Die Vorlage muss einen Platzhalter Trend_Placeholder haben. Sie kann Steuerungselemente mit folgenden Bezeichnern haben: TrendLegend -> Typ: Legende TrendTimeRangeSelector -> Typ: Zeitbereichsauswahl TrendDateRangeSelector -> Typ: Datumbereichsauswahl Target : Relativer Pfad zur Modulinstanz, in der die Visualisierung eingebettet werden soll. Variable : Variable, die aufgezeichnet werden soll. TrendRecording : TrendRecording-Objekt, zu dem die Variable gehören soll. Description : Textlisteneintrag, der als Tooltip für die Variable angezeigt wird. Color : Farbe des Graphen der Variable als ARGB-Farbcode GraphType : Typ des Graphen LineWithPoints : Linie mit Punkten Cross : Kreuze StepWithPoints : Stufen mit Punkten Point : Punkte Lines : Linien Step : Stufen LinesWithCrosses : Linien mit Kreuze \\\\ StepWithCrosses : Stufen mit Kreuze LineWidth : Dicke der gezeichneten Linie. Wert zwischen 1 und 255. LineStyle : Linienart Solid : Durchgezogen Dashed : Gestrichelt Dotted : Gepunktet DashDotted : Strich-Punkt DashDotDotted : Strich-Punkt-Strich Warning : Diese Untersektion muss das Target MAX oder MIN besitzen. Entsprechen des Targets löst das Überschreiten oder Unterschreiten die Warnung aus. Limit : Beginn des kritischen Bereichs. Color : Farbe für die Darstellung des kritischen Bereichs als ARGB-Farbcode Beispiel SEC tre.Trend\n SEC TrendRecording : TrendSensor\n SEC Visu\n VisuPlaceholder := 'TrendPlaceholder_TrendSensor';\n VisuTemplate := 'AC_Trend.GenTrend_VisuTemplate';\n END_SEC\n CycleTime := t#5s;\n LimitType := Records;\n LimitMaximum := 452;\n END_SEC\n SEC TrendVariable : Value\n Variable := value;\n TrendRecording := TrendSensor;\n Color := 16#FF00FF00;\n SEC Warning : MIN\n Limit := -5;\n Color := 16#FF101020;\n END_SEC\n GraphType := LinesWithCrosses;\n LineWidth := 3;\n END_SEC\nEND_SEC " }, 
{ "title" : "Sektion: Proxies ", 
"url" : "ac_module_fb_sec_proxies.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: Proxies ", 
"snippet" : "Proxies Die Sektion Proxies definiert den Funktionsbaustein, welcher den Proxy implementiert. Ein Proxy dient dem Datenaustausch von Modulen verschiedener Applikationen. Die Instanz des Proxy-FBs repräsentiert die Modulinstanz der anderen Applikation. SEC Proxies \/\/optional: yes, modifier: [UPDATE] ...", 
"body" : "Proxies Die Sektion Proxies definiert den Funktionsbaustein, welcher den Proxy implementiert. Ein Proxy dient dem Datenaustausch von Modulen verschiedener Applikationen. Die Instanz des Proxy-FBs repräsentiert die Modulinstanz der anderen Applikation. SEC Proxies \/\/optional: yes, modifier: [UPDATE]\n SEC Proxy : <identifier> \/\/optional: yes, modifier [UPDATE]\n FB := <FB name>; \/\/optional: no, type: QID\n SEC MirrorVar : <identifier> \/\/optional: yes, modifier [UPDATE])\n Variable := <variable name>; \/\/optional: no, type: VarPath\n END_SEC\n SEC ProxyParameter : <target> \/\/ optional: yes, modifier [UPDATE]\n Variable := <InstancePath>; \/\/ optional: no, type: VarPath\n END_SEC\n END_SEC\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. Spezifikation: Der Funktionsbaustein muss von IBaseInstance ableiten. Der Funktionsbaustein muss über eine Methode SetProxyIdentification mit folgender Signatur verfügen, die nicht im Interface IBaseInstance enthalten ist: SetProxyIdentification(pbyName : POINTER TO BYTE, udiComAddr : UDINT, udiLocalComAddr : UDINT, pEnvironment : MEnv) Der übergebene Instanzname und die gesetzte Adresse müssen von den Eigenschaft InstanceName , ComAddress und LocalComAddress zurückgegeben werden.. Der Funktionsbaustein darf nicht von IModule ableiten. Mit der Sektion MirrorVar können Variablen von Modulinstanzen auf Proxy-Instanzen gespiegelt werden. Dazu muss der Instanzpfad der Variablen in Form eines relativen Pfads (zum FB der Modulinstanz) in Variable deklariert werden. Für die angegebene Variable des Modul-Instanz-FBs gelten folgende Regeln: Die Variable muss Teil von Vars, Inputs oder Outputs des Modul-Instanz-FBs sein Sie muss sowohl im Modul-FB als auch im Proxy-FB definiert sein Sie muss in beiden FBs den gleichen Typ haben Sie muss einen primitiven Typ besitzen; es sind also keine Pointer, Interfaces oder Structs als Ganzes für die Spiegelung erlaubt, sondern nur einfache Typen (numerisch, STRING, TIME, etc.) Erfüllen die angegebenen Variablen diese Bedingungen werden sie automatisch im Rahmen des RMP übertragen, ohne dass sich der Benutzer weiter um die Übertragung kümmern müsste. Mit der Sektion ProxyParameter können Parameter für den Proxy definiert werden. Dabei sind folgende Punkte zu beachten: Das Target des ProxyParameters muss einem Parameter-Target des Moduls entsprechen. Die Variable des Proxy-Moduls muss mit dem Typ der Variable übereinstimmen, die für den Modul-Parameter verwendet wird. Erlaubt sind hierbei nur primitive Typen und Enumerationen. Die Proxy-Parameter werden in der Initialisierungsphase der jeweiligen Applikation einmalig auf den in der Modulinstanz konfigurierten Wert gesetzt. Während die Applikation läuft, werden diese Variablen nicht in die Proxies gespiegelt. Der Name des Funktionsbausteins kann mit einem Namespace-Pfad qualifiziert werden. Beispiel SEC Proxies\n SEC Proxy ProxyFB1\n FB := ProxyModule1;\n SEC MirrorVar : diInput\n Variable := diInput;\n END_SEC\n SEC ProxyParameter : InParam1\n Variable := TL.Input1_Name;\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Sektion: VarArrays ", 
"url" : "ac_module_fb_sec_vararray.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: VarArrays ", 
"snippet" : "VarArrays Der Parameter VarArrays erlaubt Arrays mit konfigurierbarer Größe zu erzeugen. SEC VarArrays \/\/optional: yes, modifier: [UPDATE]] SEC VarArray : <slot identifier> \/\/optional: yes, modifier [] Variable := <variable name>; \/\/optional: no, type: InstancePath Var_Count := <variable count>; \/\/o...", 
"body" : "VarArrays Der Parameter VarArrays erlaubt Arrays mit konfigurierbarer Größe zu erzeugen. SEC VarArrays \/\/optional: yes, modifier: [UPDATE]]\n SEC VarArray : <slot identifier> \/\/optional: yes, modifier []\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable count>; \/\/optional: no, type: InstancePath\n Inst_Name := <instance name>; \/\/optional: yes, type: StringLiteral\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Var_Decl_Flags := <Flag1> | <Flag2> | ... ; \/\/optional: yes, type: Flags\n END_SEC\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. Spezifikation: Die Definition Variable ist ein Eingangs-Instanzpfad relativ zum Modulfunktionsbaustein. Der Typ ist POINTER TO <ELEMTYPE> . <ELEMTYPE> kann ein beliebiger Typ sein. Das Target des Abschnitts VarArray muss das Array konfigurierbarer Größe eindeutig identifizieren. Var_Count ist der Eingangs-Instanzpfad einer ganzzahligen Eingangsvariable Variable des Funktionsbausteins. Damit diese Variable im Editor zur Konfiguration angezeigt wird, muss sie entsprechend als Parameter deklariert werden. Alternativ kann auch die Var_Count Variable eines Multi-Slots oder eines Multi-InstRefs verwendet werden. Mehrere VarArrays dürfen dieselbe Var_Count -Variable verwenden. Ist die Größe des Arrays 0, dann wird kein Array angelegt sondern der Zeiger des Arrays auf 0 gesetzt. Inst_Name legt den Namen der erzeugten Array-Variable fest. Die Platzhalter %Instancename% und %VariablePath% (Groß-\/Kleinschreibung spielt keine Rolle) werden dabei durch den Instanznamen der Modulinstanz bzw. den Instanzpfad der Pointer-Variable (wobei Punkte durch Unterstriche ausgetauscht werden) ersetzt. Wenn die Definition weggelassen wird, gilt der Defaultwert AC_ARRAY_%VariablePath% . Es ist ein Fehler, wenn zwei verschiedene VarArrays eines Moduls einen identischen Inst_Name haben, der nicht den Platzhalter %VariablePath% enthält. Pragmas enthält eine Liste von Compiler-Pragmas, welche vor der erzeugten Array-Variable eingesetzt wird. Var_Decl_Flags erlaubt es den variablen Typ des angelegten Arrays genauer zu spezifizieren. Erlaubte Flags sind NONE , RETAIN und PERSISTENT . Diese Flags bewirken, dass sie zu der Sektion VAR_INPUT , in der das Array angelegt wird, hinzugefügt werden (z.B. für das Flag RETAIN , VAR_INPUT RETAIN ). Beispiel SEC VAR_ARRAYS\n SEC VAR_ARRAY : NameList\n Variable := psNameList;\n Var_Count := uiArraySize;\n END_SEC\n ...\n SEC PARAM : ArraySize\n Variable := uiArraySize;\n Name := TL.ArraySize_Name;\n Desc := TL.ArraySize_Desc;\n END_SEC\nEND_SEC Der Funktionsbaustein muss im Deklarationsteil folgende Deklaration enthalten: uiArraySize: UINT := 7; psNameList: POINTER TO STRING; . " }, 
{ "title" : "Sektion: Constraints ", 
"url" : "ac_module_fb_sec_constraints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: Constraints ", 
"snippet" : "Constraints Diese spezielle Sektion überprüft, ob jede Modulinstanz mindestens einmal von einer anderen Modulinstanz referenziert wird. SEC Constraints \/\/optional: yes, modifier: [UPDATE] Referenced_By := <interface name>; \/\/optional: yes, type: QID) Referenced_Cardinality := [<minimum> .. <maximum>...", 
"body" : "Constraints Diese spezielle Sektion überprüft, ob jede Modulinstanz mindestens einmal von einer anderen Modulinstanz referenziert wird. SEC Constraints \/\/optional: yes, modifier: [UPDATE]\n Referenced_By := <interface name>; \/\/optional: yes, type: QID)\n Referenced_Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. Spezifikation: Mit Referenced_By kann ein Modul festlegen, dass jede seiner Modulinstanzen mindestens einmal von einer anderen Modulinstanz referenziert werden muss. Der Wert von ReferencedBy muss ein Interface sein, das von IModule ableitet. Wenn egal ist, welchen Typ die referenzierende Instanz hat, kann hier IModule angegeben werden. Referenced_Cardinality definiert den Bereich, wie oft dieses Modul referenziert sein muss. Wenn die Anzahl der Referenzen nicht in diesem Bereich liegt, wird beim Einlesen durch den Standardgenerator ein Fehler erzeugt. Beispiel SEC Constraints\n Referenced_By := ISpecificModule;\n Referenced_Cardinality := [1 .. 3];\nEND_SEC " }, 
{ "title" : "Sektion: InstRefs ", 
"url" : "ac_module_fb_sec_instrefs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: InstRefs ", 
"snippet" : "InstRefs Die Sektion InstRefs definiert Referenzen von FB-Instanzen oder Strukturinstanzen. SEC InstRefs \/\/optional: yes, modifier: [UPDATE] SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: no, type: InstancePath Desc := <descri...", 
"body" : "InstRefs Die Sektion InstRefs definiert Referenzen von FB-Instanzen oder Strukturinstanzen. SEC InstRefs \/\/optional: yes, modifier: [UPDATE]\n SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n...\n SEC InstRef_Multi : <identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n END_SEC\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. Spezifikation: Inst_Ref.Variable definiert den Eingangs-Instanzpfad einer Variablen vom Typ POINTER TO <T> oder vom Typ <Interface> . ( <T> ist ein beliebiger Struktur- oder FB-Typ.) InstRef_Multi.Variable definiert den Eingangs-Instanzpfad vom Typ POINTER TO POINTER TO <T> oder vom Typ POINTER TO <Interface> . ( <T> ist ein beliebiger Struktur- oder FB-Typ.) Zwei verschiedene InstRef- oder InstRef-Multi Einträge dürfen nicht dieselbe Variable verwenden. Das Target muss die Instanzreferenz eindeutig identifizieren. D.h. es darf keine zwei unterschiedlichen Instanzreferenz-Deklarationen (Abschnitt InstRef und InstRef_Multi ) geben, deren Target bis auf Groß-Kleinschreibung übereinstimmt. Die durch Var_Count adressierte (ganzzahlige) Eingangsvariable darf nur einmal in allen VarCounts der Slot_Multi oder InstRef_Multi verwendet werden. Integer-Variablen definiert durch Var_Count von VarArray können parallel zu Var_Counts von Slot_Multi oder InstRef_Multi verwendet werden. Beispiel SEC InstRef_Multi : Elements\n Variable := piElems ;\n Var_Count := uiArraySize ;\n Desc := TL.Elems_Desc ;\n Cardinality := [1 .. 10] ;\nEND_SEC Folgende Deklaration muss im Deklarationsteil des Funktionbausteines stehen: uiArraySize : UINT; piElems : POINTER TO Interface; piElems zeigt auf eine global angelegtes, korrekt initialisiertes ARRAY[0..uiArraySize-1] OF Interface bzw. OF POINTER TO <T> , das auf die einzelnen Instanzen zeigt. So kann mittels piElems[i] auf das i-te Objekt zugegriffen werden. " }, 
{ "title" : "Sektion: mse.Sequence ", 
"url" : "ac_module_fb_sec_sequence.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: mse.Sequence ", 
"snippet" : "mse.Sequence In dieser Sektion werden die Definitionen des Ablaufeditors festgelegt. Die Sektion muss in der Moduldeklaration vorhanden sein, damit der Editor der Module den zusätzlichen Tab Ablaufeditor bereitstellt. SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE] Root := TRUE\/FALSE; \/\/optiona...", 
"body" : "mse.Sequence In dieser Sektion werden die Definitionen des Ablaufeditors festgelegt. Die Sektion muss in der Moduldeklaration vorhanden sein, damit der Editor der Module den zusätzlichen Tab Ablaufeditor bereitstellt. SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE]\n Root := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Step := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Parallel := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Branch := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n VisibleParams := [<visparam1>, <visparam2>,...]; \/\/optional: yes, type: ID-list\n VisibleIOs := [<visIO1>, <visIO2>,...]; \/\/optional: yes, type: ID-list\n VisibleRefs := [<visref1>, <visref2>,...]; \/\/optional: yes, type: ID-list\n AConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n BConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n OnlineActiveVar := <xActive>; \/\/optional: yes, type: ID\n OnlineBreakpointVar := <xBreakpoint>; \/\/optional: yes, type: ID\n OnlineBreakpointActiveVar := <xAvtiveBreakpoint>; \/\/optional: yes, type: ID\n OnlineWatchVars := [<variable1>, <variable2>,...]; \/\/optional: yes\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. Spezifikation: Für ein Modul kann nur eine der Definitionen Root , Step , Parallel or Branch festgelegt werden. Abhängig von dieser Definition wird das Modul im Ablaufeditor durch eines der folgenden Ablaufelemente dargestellt: Root: Wird eine Sequenz als Root gekennzeichnet, stellt der Editor der Modulinstanz den zusätzlichen Tab Ablaufeditor zur Verfügung. Für alle anderen Sequenzen wird entsprechend kein Ablaufeditor angezeigt. Die Breite des Rechtecks kann in den Optionen eingestellt werden. Step: Dieses Element ist ähnlich wie das Root -Element, gibt jedoch den zusätzlichen Tab Ablaufeditor nicht frei. Das Element wird verwendet, um bestimmte Eigenschaften des Moduls, die in seiner Sektion mse.Sequence festgelegt sind, anzuzeigen und anzupassen. Parallel: Ein Verzweigungsschritt wird durch einen Kreis unterhalb des Rechtecks dargestellt. Das Rechteck wird verwendet, um bestimmte Eigenschaften des Moduls, die in seiner Sektion mse.Sequence festgelegt sind, anzuzeigen und anzupassen. Branch: Ein Entscheidungsschritt wird durch eine Raute unterhalb des Rechtecks dargestell. Das Rechteck wird verwendet um bestimmte Eigenschaften des Moduls, die in seiner Sektion mse.Sequence festgelegt sind, anzuzeigen und anzupassen. VisibleParams legt die Parameter, die in dem Rechteck des Ablaufelements verfügbar sind, fest. VisibleIOs legt die EAs, die in dem Rechteck des Ablaufelements verfügbar sind, fest. VisibleRefs legt die Referenzen, die in dem Rechteck des Ablaufelements verfügbar sind, fest. AConnectionColor : Die Verbindungslinien zwischen den Modulinstanzen des zugewiesenen Slots werden in der Farbe der A Verbindung gezeichnet. Diese kann in den Optionen des Ablaufeditors eingestellt werden. BConnectionColor : Die Verbindungslinien zwischen den Modulinstanzen des zugewiesenen Slots werden in der Farbe der B Verbindung gezeichnet. Diese kann in den Optionen des Ablaufeditors eingestellt werden. OnlineActiveVar : Dieser Parameter kann einer booleschen Variablen zugewiesen werden, die im zugehörigen Funktionsbaustein oder einem seiner Basis-FBs deklariert sein muss. Im Onlinebetrieb wird der Ablaufschritt in gelber Farbe dargestellt, wenn diese Variable auf TRUE gesetzt ist. OnlineBreakpointVar : Dieser Parameter kann einer booleschen Variablen zugewiesen werden, die im zugehörigen Funktionsbaustein oder einem seiner Basis-FBs deklariert sein muss. Im Onlinebetrieb setzt bzw. rücksetzt der Befehl Breakpoint ein-\/ausschalten aus dem Kontextmenü einen Breakpoint. Weiterhin wird die zugewiesene Variable auf TRUE bzw. FALSE gesetzt. Wenn sie auf TRUE gesetzt ist, wird der Schritt im Ablaufeditor mit einem roten Rahmen dargestellt. OnlineBreakpointActiveVar : Dieser Parameter kann einer booleschen Variablen zugewiesen werden, die im zugehörigen Funktionsbaustein oder einem seiner Basis-FBs deklariert sein muss. Im Onlinebetrieb wird der Ablaufschritt in roter Farbe dargestellt, wenn diese Variable auf TRUE gesetzt ist. OnlineWatchVars : Als Variablen können hier alle Variablen (mit simplem Datentyp), die unter VAR_INPUT , VAR_OUTPUT , VAR oder VAR_IN_OUT des FBs (oder seiner Basis-FBs) angegeben sind, verwendet werden. Es ist nicht möglich komplexe Variablen-Typen (von der Form FBInst.xVariable , etc.) zu verwenden. Die Variablen werden in einer Liste, durch Komma getrennt, angegeben. Beispiel SEC mse.Sequence\n Branch;\n VisibleIOs := [xIn];\n AConnectionColor := [itfSequenceTrue];\n BConnectionColor := [itfSequenceFalse];\n OnlineActiveVar := xActive;\n OnlineBreakpointVar := xBreakpoint;\n OnlineBreakpointActiveVar := xBreakpointActive;\n OnlineWatchVars := [iPartTimeElapsed];\nEND_SEC " }, 
{ "title" : "Sektion: Decoupled ", 
"url" : "ac_module_fb_sec_decoupled.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: Decoupled ", 
"snippet" : "Decoupled Diese Sektion definiert sogenannte „Decoupled-Module“. Dies sind Module, die die Eigenschaften von Toplevel-Modulen haben, jedoch auch als Submodul an speziellen Slots ( Type:= DECOUPLED ) anderer Module eingefügt werden können. Module können nicht gleichzeitig „Toplevel“ und „Decoupled“ s...", 
"body" : "Decoupled Diese Sektion definiert sogenannte „Decoupled-Module“. Dies sind Module, die die Eigenschaften von Toplevel-Modulen haben, jedoch auch als Submodul an speziellen Slots ( Type:= DECOUPLED ) anderer Module eingefügt werden können. Module können nicht gleichzeitig „Toplevel“ und „Decoupled“ sein. „Decoupled-Module“ werden mit Hilfe der Sektion Decoupled in der Moduldeklaration erzeugt. Die Sektion Decoupled ist fast identisch zur Sektion Toplevel , wobei nur eine dieser beiden Sektionen in einer Moduldeklaration erlaubt ist. SEC Decoupled \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Toplevel_Insertable := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/optional: no, type: Text)\n Flags:= <flag>; \/\/optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Moduldeklaration beschrieben. Spezifikation: Die Spezifikation der Sektion Decoupled entspricht der Beschreibung der Sektion Toplevel . Zusätzlich kann folgender Parameter definiert werden: Toplevel_Insertable definiert, ob ein „Decoupled-Submodul“ auch toplevel, also wie ein Toplevel-Modul, eingefügt werden kann. Hinweis: Ein \"Decoupled“-Modul sollte einen ihm entsprechenden Proxy-Vertreter definieren und implementieren. Der Proxy sollte das selbe Interface wie das „Decoupled“-Modul selbst implementieren. Wenn die Vater-Modulinstanz unterhalb einer anderen Steuerung liegt wie die „Decoupled“-Modulinstanz, kann die „Decoupled“-Modulinstanz dennoch über ihren Proxy-Vertreter in diesen Slot eingefügt werden kann. Siehe auch Moduldeklaration Sektion Toplevel " }, 
{ "title" : "Sektion: MacroModule ", 
"url" : "ac_module_fb_sec_macromodule.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: MacroModule ", 
"snippet" : "MacroModule Die Sektion beschreibt die Parameter der Makro-Module. Diese Sektion wird automatisch angelegt, wenn Sie ein Makro-Modul erzeugen. Sie können die Sektion auch von Hand in eine Moduldeklaration einfügen oder eine automatisch erzeugte Sektion editieren. SEC MacroModule \/\/optional: yes, mod...", 
"body" : "MacroModule Die Sektion beschreibt die Parameter der Makro-Module. Diese Sektion wird automatisch angelegt, wenn Sie ein Makro-Modul erzeugen. Sie können die Sektion auch von Hand in eine Moduldeklaration einfügen oder eine automatisch erzeugte Sektion editieren. SEC MacroModule \/\/optional: yes, modifier: None\n SEC Rootmodule : <identifier> \/\/optional: no, modifier: None\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: no, type: text\n New_Desc := <parameter description>; \/\/optional: no, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO ID>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n SEC VisuEmbeddings \/\/optional: yes, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID>; \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <linke ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTab := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: no, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection>; \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters : <identifier> \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value ID>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Submodule : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: yes, type: text\n New_Desc := <parameter description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO Id>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n Instance_Name := <instance name>; \/\/optional: no, type: ID\n SEC VisuEmbeddings \/\/optional: no, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID> \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID> \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTap := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: yes, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression> \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection> \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Reference : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n Referenced_Instance := <instance ID>; \/\/optional: no, type: ID\n END_SEC\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. Spezifikation: Macro_Module : Wenn diese Sektion definiert ist, darf innerhalb der gesamten Moduldeklaration keine weitere Sektion außer der Sektion MetaData vorhanden sein. Jede Moduldeklaration mit dieser Sektion ist eindeutig als Makro-Modul-Typ gekennzeichnet. Es darf auch keine weitere Sektion MacroModule innerhalb einer Moduldeklaration geben. Rootmodule : Zeigt an, dass die folgenden Untersektionen das Wurzel-Submodul beschreiben, das die Wurzel dieses Macro-Modul-Typs sein soll und zu oberst als Vater aller anderen Submodule des Makro-Modul-Typs eingefügt werden soll. Submodule : Zeigt an, dass die folgenden Untersektionen ein Submodul beschreiben, das für den Makro-Modul-Typ irgendwo im Unterbaum unter dem Wurzel-Submodul eingefügt werden soll. MacroParameter : Wird eine solche Sektion innerhalb einer Sektion Submodule oder Root verwendet, kann angegeben werden, dass ein bestimmter Parameter des definierten Submoduls (oder Root) als Parameter des Makro-Moduls selbst auftreten soll. Dazu wird das Target der Sektion MacroParameter als neue Parameter-ID für den Makro-Modul-Parameter verwendet. Der Parameter des angegebenen Submoduls (oder Root) wird dann über die Definition Local_ParameterID angegeben. Zusätzlich können über die Definitionen New_Name und New_Desc Textlisten-Einträge angegeben werden. Diese Einträge werden für Name und Beschreibung des neuen Makro-Modul-Parameters anstelle derjenigen des Submodul- oder Root-Parameters verwendet. Alle angegebenen Targets aller Sektionen MacroParameter innerhalb eines gesamten Makro-Moduls müssen eindeutig sein, so dass alle Makro-Modul-Parameter eindeutige Parameter-IDs besitzen. MacroIO : Wenn eine solche Sektion innerhalb der Sektion Submodule oder Root verwendet wird, kann angegeben werden, dass ein bestimmter IO des definierten Submoduls (oder Root) als IO des Makro-Moduls selbst auftreten soll. Dazu wird das Target der Sektion MacroIO als neue IO-ID für den Makro-Modul-IO verwendet. Der IO des angegebenen Submoduls (oder Root) wird dann über die Definition Local_IOID angegeben. Zusätzlich können über die Definitionen New_Name und New_Desc Textlisteneinträge angegeben werden. Diese Einträge werden für Name und Beschreibung des neuen Makro-Modul-IOs anstelle derjenigen des Submodul- oder Root-IOss verwendet. Alle angegebenen Targets aller Sektionen MacroIO innerhalb eines gesamten Makro-Moduls müssen eindeutig sein, so dass alle Makro-Modul-IOs eindeutige IO-IDs besitzen. MacroSlot : Wird diese Sektion innerhalb der Sektion Submodule oder Root verwendet, kann angegeben werden, dass ein bestimmter Steckplatz des definierten Submoduls (oder Root) als Steckplatz des Makro-Moduls selbst auftreten soll. Somit kann unterhalb dieses Steckplatzes der Makro-Modul-Instanz weitere Modulinstanzen eingefügt werden. Dazu wird das Target der Sektion MacroSlot als neue SlotID für den Makro-Modul-Slot verwendet. Der Steckplatz des angegebenen Submoduls (oder Root) wird dann über die Definition Local_SlotID angegeben. Zusätzlich kann über die Definitionen New_Role ein Textlisteneintrag angegeben werden. Dieser Eintrag wird für die „Role“ des neuen Makro-Modul-Slots anstelle desjenigen des Submodul- oder Root-Slots verwendet. Alle angegebenen Targets aller Sektionen MacroSlot innerhalb eines gesamten Makro-Moduls müssen eindeutig sein, so dass alle Makro-Modul-Slots eindeutige Slot-IDs besitzen. Parent_Instance : Gibt eine ID an, die einer Target-ID einer Sektion Rootmodule oder Submodule der umgebenden Sektion MacroModule entspricht. Diese Definition existiert nur innerhalb der Sektion Submodule . Sie definiert die Vater-Modul-Instanz unterhalb derer das durch die jeweilige Sektion Submodule beschriebene Submodul des Makro-Modul-Typen „eingefügt“ werden soll. Dazu ist die Definition Parent_Slot zusätzlich zwingend erforderlich. Parent_Slot : Gibt eine ID an, die der ID eines Steckplatzes entspricht, die unterhalb des durch Parent_Module identifizierten Submodul-Typs zu finden ist. Unter diesem Steckplatz wird das durch die Sektion Submodule beschriebene Submodul des Makro-Modul-Typen eingefügt. Default_Allocation : Ist identisch zur gleichnamigen Sektion unterhalb der Slot-Deklarationen ( Slot und Slot_Multi ). Diese Sektion gibt sowohl für „Rootmodule“ als auch „Submodule“ an, was für ein Submodul des Makro-Modul-Typs mit welcher Instanz-Konfiguration eingefügt werden soll. Einziger Unterschied ist, dass für Default_Allocation unterhalb einer Sektion Rootmodule kein Instance_Name angegeben werden kann, dagegen unterhalb von Sektionen Submodule schon. Der Grund ist, dass die als „Rootmodule“ eingefügten Modul-Instanzen ihren Namen von der Makro-Modul-Instanz bekommen und deshalb nicht „default“ angegeben werden können. Reference : Zeigt an, dass die folgenden Untersektionen eine Modul-Referenz beschreiben. Dabei wird eine Referenz unter der Modul-Instanz Parent_Instance unter dem Steckplatz Parent_Slot erzeugt, wobei das Submodul Referenced_Instance referenziert wird. Diese referenzierte Instanz muss so wie die Parent_Instance aus der Menge der Submodule- oder Rootmodule-Instanzen unterhalb der selben Sektion Makro_Module stammen. Die Moduldeklaration eines Makro-Modul-Typen muss folgende Bedingungen erfüllen: Sie darf weder IMPLEMENTED_BY noch IMPORTS in ihrer Moduldeklaration verwenden. Sie muss die Sektion MetaData und MacroModule enthalten. Ansonsten dürfen keine weiteren Sektionen vorhanden sein. Unterhalb der Sektion Macro_Modul muss mindestens eine Sektion Rootmodule vorhanden sein. Es darf zudem keine zweite Sektion Rootmodule existieren. Für jedes Submodule muss innerhalb von MacroModule sowohl die Parent_Instance als auch der Parent_Slot definiert sein. Dieser muss dann als Local_SlotID innerhalb von MacroSlot der Parent_Instance definiert sein. " }, 
{ "title" : "Sektion: DeviceGenerator ", 
"url" : "ac_module_fb_sec_devicegenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: DeviceGenerator ", 
"snippet" : "DeviceGenerator Die Toplevel-Sektion DeviceGenerator umfasst alle Definitionen bezüglich des Gerätegenerators. Sie beinhaltet die folgenden Untersektionen: Untersektion Device : Definitionen zum Hinzufügen von Geräten zum Gerätebaum Untersektion Parameter : Definitionen zum Hinzufügen oder Ändern vo...", 
"body" : "DeviceGenerator Die Toplevel-Sektion DeviceGenerator umfasst alle Definitionen bezüglich des Gerätegenerators. Sie beinhaltet die folgenden Untersektionen: Untersektion Device : Definitionen zum Hinzufügen von Geräten zum Gerätebaum Untersektion Parameter : Definitionen zum Hinzufügen oder Ändern von Geräteparametern Untersektion Connect: Definitionen zum Verbinden von Modul-E\/As mit Geräte-E\/As Untersektion Wildcards : Definitionen zum Erzeugen von „Wildcard“-Geräten Untersektion Demand : Definitionen zur Festlegung von „Demand“-Eigenschaften Untersektion InstRefMapping : Definition zur Verbindung von erzeugten Geräten mit InstRefs des Moduls Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. " }, 
{ "title" : "Untersektion: Device ", 
"url" : "ac_module_fb_sec_devicegenerator_device.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: DeviceGenerator \/ Untersektion: Device ", 
"snippet" : "Die Untersektion Device definiert Geräte, die vom Gerätegenerator hinzugefügt werden sollen. Es gibt mehrere Typen von generierten Geräten, die mit den verschiedenen Untersektionen Identification , Wildcard und FlexibleWildcard festgelegt werden. Syntax: SEC DeviceGenerator \/\/optional: yes, modifier...", 
"body" : "Die Untersektion Device definiert Geräte, die vom Gerätegenerator hinzugefügt werden sollen. Es gibt mehrere Typen von generierten Geräten, die mit den verschiedenen Untersektionen Identification , Wildcard und FlexibleWildcard festgelegt werden. Syntax: SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Device : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n ParentSlotIndex := <slot number>; \/\/optional: yes, type: literal\/integer\n SEC Identification \/\/optional: yes, modifier: [UPDATE]\n Type := <type number>; \/\/optional: no, type: literal\/string\n ID := <ID mumber>; \/\/optional: no, type: literal\/string\n ModuleID := <module ID>; \/\/optional: yes, type: literal\/string\n Version := <version mumber>; \/\/optional: no, type: literal\/string\n SEC SetChildName \/\/optional: yes, modifier: [UPDATE]\n Value := <child name>; \/\/optional: no, type: literal\/string\n ChildIndex := <index number>; \/\/optional: no, type: literal\/string\n END_SEC\n END_SEC\n END_SEC\n SEC ExportDevice \/\/optional: yes, modifier: [UPDATE, HIDE]\n Files :=[<filename1>, <filename2>, ...]; \/\/optional: no, type: string\n END_SEC\nEND_SEC Spezifikation: Der Abschnitt Device besitzt eine Target-ID, die ihn unter den anderen generierten Geräten eines Moduls eindeutig kennzeichnet. Diese ID kann dazu verwendet werden, auf dieses Gerät zu referenzieren. Dies erfolgt hauptsächlich in der Definition Parent anderer erzeugter Geräte oder verbundener E\/As. Die Definition Parent spezifiziert das gewünschte Elterngerät, unter dem das erzeugte Gerät eingehängt werden soll. Das Elterngerät kann gar nicht (Definition ist optional), über seine ID oder über einen Parameter identifiziert werden. Im Detail wird das Elterngerät dann auf folgende Art und Weise ermittelt: Ist überhaupt kein Parent definiert, wird stets das erste passende zur Verfügung stehende Elterngerät verwendet, wobei für eine leere Parent -Definition nur ab dem ersten Elternmodul gesucht wird. Wenn im direkten Elternmodul selbst kein Gerät definiert ist, wird so lange die Historie der Elternmodule nachverfolgt, bis schließlich ein Gerät vorhanden ist, das passt oder das Toplevel-Modul erreicht ist. In diesem Fall wird dann, falls möglich, dessen Applikationsgerät verwendet. Ist zudem eine Device-ID oder ein Parameter als Parent angegeben, wird in selber Weise die Historie der Elterngeräte durchforstet, wobei nun zusätzlich die Geräte des Ausgangsmoduls selbst mit in Betracht gezogen werden und ein mögliches Elterngerät auch die entsprechende ID besitzen muss. Wenn, nach den oben beschriebenen Regeln, kein mögliches Elterngerät gefunden werden kann, wird beim Generierungs-Check ein Fehler ausgegeben. ParentSlotIndex : Gibt den Index des Steckplatzes (Slot-Nummer) des übergeordneten Geräts an, in den das Gerät eingefügt werden wird. Das ist dann hilfreich, wenn ein Einstecken erforderlich ist. Die Untersektion Identifikation umfasst die eindeutige Beschreibung eines Devices, das hinzugefügt werden soll. Es wird damit ein eindeutiger Bezug zu diesem Typ Device hergestellt. Die Definitionen Type , ID , ModuleID und Version der Sektion Identification identifizieren eindeutig einen Gerätetyp einer bestimmten Version. Ein EtherCAT-Master hat beispielsweise folgende Definition: Type := '64'; ID := '000 0001'; Version := '3.5.1.0'; Wenn als Version * definiert wird, wird stets die neuste Version des Gerätes verwendet. Wenn die Definition ModuleID nicht verwendet wird, wird das System nach Geräten mit einer DeviceIdentification durchsucht, andernfalls wird nach Geräten mit einer ModuleIdentification gesucht. Wenn das definierte Gerät im Geräterepository nicht vorhanden ist, wird eine entsprechende Fehlermeldung bereits beim Scan-Vorgang ausgegeben. Untersektion SetChildName mit den Definitionen Value und ChildIndex Mit Hilfe dieser Optionen können Sie den Namen festlegen, den ein automatisch eingefügtes Gerät haben soll. Wird derselbe Name mehr als einmal verwendet, wird der resultierende Name durch Anhängen eines Unterstrichs und einer Zahl eindeutig gemacht. Value : Gewünschter Name des Geräts ChildIndex : Index des automatisch eingefügten Geräts, das umbenannt werden soll Diese Sektion bietet die Möglichkeit, die Felder mit Hilfe des Eingabeassistenten zu belegen. Dazu wird der Cursor auf das Zeilenende hinter Identification gesetzt und Return gedrückt. Danach öffnet der Assistent und bietet die verfügbaren Geräte an. Nach der Auswahl eines Gerätes werden die entsprechenden Parameter in die Moduldeklaration übernommen. Bitte beachten Sie, dass diese Funktion nur zur Verfügung steht, falls das Ende der Untersektion ( END_SEC ) noch nicht eingegeben wurde. Die Definition Files enthält eine Liste von Geräten, die zum Projekt hinzugefügt werden. Diese Geräte wurden manuell konfiguriert und in eine Bibliothek exportiert. Beispiel SEC Device : Buskoppler2\n SEC Identification\n Type := '65';\n ID := '2_044C2C5200110000';\n Version := '*';\n END_SEC\nEND_SEC\nSEC Device : KlemmeDigitalOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\n SEC ExportDevices\n Files := [ExtFile.BK5120_1SDO, ExtFile.BK5120_2SDO];\n END_SEC\nEND_SEC Beispiel mit Parameter SEC std.DeviceGenerator\n SEC Device : CANopen_Manager\n Parent := CurrentCAN;\n SEC FlexibleIdentification\n Type := '16';\n ID := '181016';\n Version := '*';\n Maximum := 1;\n END_SEC\n END_SEC\nEND_SEC\nSEC std.Parameters\n SEC Param : CurrentCAN\n Name := TL.CurrentCAN_Name;\n Desc := TL.CurrentCAN_Desc;\n VariableType := wSTRING;\n Default := 'CANBus_0';\n END_SEC\nEND_SEC Beispiel für das Festlegen eines Gerätenamens SEC std.DeviceGenerator\n\tSEC Device : EcoVario\n\t Parent := CanManager;\n\t\tSEC Identification\n\t\t Type := '18';\n\t\t ID := '1619 0001';\n\t\t Version := '*';\n\t\t SEC SetChildName : ChildDevice\n\t\t\t Value := 'ChildName';\n\t\t\t ChildIndex := 0;\n\t\t END_SEC\n\t END_SEC\n END_SEC\n SEC Parameters : EcoVario\n\t SEC AddParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t ParameterName := 'BoolParam';\n\t \tParameterType := 'std:BOOL';\n\t\t ChildIndex := 0;\n\t END_SEC\n\t SEC SetParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t\tElemPath := '';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\t\tSEC SetParameter : bVirtual\n\t\t\tParameterID := '1040';\n\t\t\tElemPath := '';\n\t\t\tConnectorID := '0';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\tEND_SEC\n SEC InstRefMapping : Axis\n\t SEC Demand\n\t Desc := TL.DescAxis;\n\t\t\tProperties := [SM_DRIVE_CAN];\n\t\tEND_SEC\n\tEND_SEC\nEND_SEC\n " }, 
{ "title" : "Untersektion: Connect ", 
"url" : "ac_module_fb_sec_devicegenerator_connect.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: DeviceGenerator \/ Untersektion: Connect ", 
"snippet" : "Diese Untersektion der Sektion IOMapping verbindet Modul-E\/As mit spezifizierten Geräte-E\/As. Die Zuordnung erfolgt direkt, ohne die genaue E\/A-Verteilung des Gerätes zu kennen. Bei direkten Verbindungen wird davon ausgegangen, dass die Modul-E\/A und die spezifizierte Geräte-E\/A kompatibel sind. SEC...", 
"body" : "Diese Untersektion der Sektion IOMapping verbindet Modul-E\/As mit spezifizierten Geräte-E\/As. Die Zuordnung erfolgt direkt, ohne die genaue E\/A-Verteilung des Gerätes zu kennen. Bei direkten Verbindungen wird davon ausgegangen, dass die Modul-E\/A und die spezifizierte Geräte-E\/A kompatibel sind. SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC IOMapping : <mapping identifier> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Connect \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n END_SEC\n END_SEC\nEND_SEC Spezifikation: Der Abschnitt IO besitzt ein Target, das der Target-ID des Modul-E\/As entspricht, der verbunden werden soll. Letzterer wird im Modul, in dem die Device-Connection gemacht werden soll, gesucht. Wenn kein passender Modul-IO gefunden werden kann, wird bereits beim Scan eine entsprechende Fehlermeldung ausgegeben. Parent gibt optional die Target-ID eines Geräts an, in dem der spezifizierte Geräte-E\/A (ParamaterID) gesucht werden soll. Es wird dabei solange ausgehend vom eigenen Modul die Historie der Eltern-Geräte verfolgt bis ein entsprechendes Gerät gefunden ist, das einen entsprechenden E\/A-Kanal\/Parameter besitzt. Wenn kein Gerät gefunden werden kann, wird dies beim Generierungs-Check als Fehlermeldung ausgegeben. Der Abschnitt Connect umfasst alle Definitionen die nötig sind, um ein Modul-E\/A mit einem Geräte-E\/A direkt zu verbinden. ParameterID gibt die ParameterID des E\/A-Kanals des Gerätes an, zu dem verbunden werden soll. Es wird versucht, diesen Parameter in den vom Modul selbst angegebenen Geräten zu finden. Wenn kein Gerät angegeben ist, wird versucht, den Parameter im nächst möglichen Eltern-Gerät zu finden. Danach wird der Parameter mit dem Modul-E\/A verbunden. Wenn kein erzeugtes Gerät der Modulhierarchie den spezifizierten Parameter mit der angegebenen ParameterID anbietet, wird ein Fehler ausgegeben. ElemPath gibt das Element des E\/A-Kanals des Parameters (E\/A-Kanal) an, das mit dem Modul-E\/A verbunden werden soll. Dabei ist es auch möglich Pfade, etc. anzugeben. ConnectorID gibt optional den Connector des Gerätes an, unter dessen HostParameterSet die ParameterID zu suchen ist. Wenn keine ConnectorID angegeben wird, wird die ParameterID unter dem DeviceParameterSet gesucht. Diese Sektion bietet die Möglichkeit, die Felder mit Hilfe des Eingabeassistenten zu belegen. Dazu wird der Cursor auf das Zeilenende hinter Connect gesetzt und Return gedrückt. Danach öffnet der Assistent und bietet die verfügbaren Kanäle an. Nach der Auswahl eines Kanals werden die entsprechenden Parameter in die Moduldeklaration übernommen. Bitte beachten Sie, dass diese Funktion nur zur Verfügung steht, falls das Ende der Untersektion ( END_SEC ) noch nicht eingegeben wurde. Beispiel SEC IOMapping: xIn\n SEC Connect\n ParameterID := '33554434';\n ElemPath := '';\n ConnectorID := '1';\n END_SEC\nEND_SEC " }, 
{ "title" : "Untersektion: Demand ", 
"url" : "ac_module_fb_sec_devicegenerator_demand.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: DeviceGenerator \/ Untersektion: Demand ", 
"snippet" : "Diese Untersektion von IOMapping dient dazu, für die Modul-E\/As bestimmte Eigenschaften (beispielsweise 24V und nicht 230V) zu definieren, die von den Geräte-E\/As angeboten werden sollen. Die „Demandings“ können bei der Generierung Geräten als „Offering“-Eigenschaften zugeordnet werden. Diese Zuordn...", 
"body" : "Diese Untersektion von IOMapping dient dazu, für die Modul-E\/As bestimmte Eigenschaften (beispielsweise 24V und nicht 230V) zu definieren, die von den Geräte-E\/As angeboten werden sollen. Die „Demandings“ können bei der Generierung Geräten als „Offering“-Eigenschaften zugeordnet werden. Diese Zuordnung wird zusätzlich zur Gerätebeschreibung abgespeichert. Für die automatische E\/A-Verbindung des Geräte-Generators bedeutet dies, dass jeder Modul-E\/A mit „Demanded“-Eigenschaften so lange in seinen Eltern-Modulen nach einem Gerät oder Wildcard-Gerät sucht, bis das gefundene Gerät den „Demanding“-Bedarf durch seine „Offering“-Vorgaben decken kann. SEC IOMapping : <target> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n Properties := [<property1>,<property2>,...]; \/\/optional: no, type: IDList\n END_SEC\nEND_SEC Spezifikation: Die Untersektionen Demand und Connect können nicht gleichzeitig angegeben werden. Die Definition Desc gibt eine (lokalisierte) Beschreibung der verlangten Verbindung (in einer Textliste) an. Properties gibt eine Liste von Eigenschaften an, die die von den Modul-E\/As benötigten Eigenschaften (beispielsweise [Input24V, Digital]) beschreiben. Es können mehrere Eigenschaften angegeben werden, so dass die einzelnen Modul-E\/As klassifiziert werden können (beispielsweise in Modul-E\/As, die nur „Eigenschaft1“ verlangen und in Modul-E\/As die „Eigenschaft1, Eigenschaft2“ verlangen). Parent gibt die ID des gewünschten Geräts an, unter dem der Kanal verbunden werden soll. Für „Demanding“-E\/As können dies auch Wildcard-Geräte sein. SEC std.DeviceGenerator\n SEC IOMapping : xOn\n SEC Demand\n Desc := TL_Rooms.Role_RoomStandard_Lights;\n Properties := [V24Output];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Untersektion: Wildcards ", 
"url" : "ac_module_fb_sec_devicegenerator_wildcard.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: DeviceGenerator \/ Untersektion: Wildcards ", 
"snippet" : "Die Untersektion Wildcard dient dazu Wildcard-Geräte zu Modulen anzulegen, die bei der Modulerstellung noch nicht bekannt sind. Die Geräte sollen dann vom Benutzer flexibel vor oder bei der Generierung angegeben werden können. SEC Device : <target> \/\/optional: yes, modifier [UPDATE] Parent := <targe...", 
"body" : "Die Untersektion Wildcard dient dazu Wildcard-Geräte zu Modulen anzulegen, die bei der Modulerstellung noch nicht bekannt sind. Die Geräte sollen dann vom Benutzer flexibel vor oder bei der Generierung angegeben werden können. SEC Device : <target> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Wildcard : <target> \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n END_SEC\nEND_SEC Spezifikation: Die Untersektionen Identification , Wildcard und FlexibleWildcard können nicht gleichzeitig verwendet werden. Das Target der Sektion Wildcard gibt den Typ des Wildcardgeräts an. Verschiedene Module können Wildcardgeräte gleichen Typs besitzen (beispielsweise „8Inputs“). Alle Wildcard-Geräte selben Typs werden dem selben Gerät zugewiesen. Desc gibt eine (lokalisierte) Beschreibung des Wildcard-Gerätes (in einer Textliste) an. Parent gibt wie zuvor wiederum das gewünschte Eltern-Gerät an. Hier sind auch Wildcard-Geräte möglich, sofern sie bereits Geräten zugewiesen sind. Ist das für das Wildcard-Gerät gesetzte Gerät kein kompatibles Eltern-Gerät, wird beim Generieren ein Fehler ausgegeben. Beispiel SEC Device : KlemmeAnalogOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\nEND_SEC " }, 
{ "title" : "Untersektion: Parameter ", 
"url" : "ac_module_fb_sec_devicegenerator_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: DeviceGenerator \/ Untersektion: Parameter ", 
"snippet" : "Die Sektion Parameter mit den Untersektionen SetParameter und AddParameter dient dazu, Parameter von Geräten editieren oder hinzufügen zu können. Damit soll es ermöglicht werden, gewisse Einstellungen von Geräten (beispielsweise Zykluszeiten) durch den Gerätegenerator mit zu erzeugen. SEC DeviceGene...", 
"body" : "Die Sektion Parameter mit den Untersektionen SetParameter und AddParameter dient dazu, Parameter von Geräten editieren oder hinzufügen zu können. Damit soll es ermöglicht werden, gewisse Einstellungen von Geräten (beispielsweise Zykluszeiten) durch den Gerätegenerator mit zu erzeugen. SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Parameters : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n SEC SetParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n Value := <value name>; \/\/optional: no, type: literal\/string\n ChildIndex := <device ID>;\n Download := <boolean value> \/\/ opional: yes, type: boolean\n END_SEC\n SEC AddParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ParameterName := <parameter name>; \/\/optional: no, type: literal\/string\n ParameterType := <parameter type>; \/\/optional: no, type: literal\/string\n ChannelType := <channel type>; \/\/optional: yes, type: enum\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n ChildIndex := <device ID>;\n END_SEC\n END_SEC\nEND_SEC Spezifikation: Der Abschnitt Parameters besitzt ein Target, mit dem die DeviceID des Zielgeräts angegeben wird, dessen Parameter editiert werden sollen. Das Zielgerät wird zunächst in den moduleigenen Geräten und dann in deren Elternhistorie gesucht. Ziel können auch Wildcard-Geräte oder andere Geräte sein, wobei davon ausgegangen wird, dass diese die entsprechenden Parameter besitzen und zu ihnen die entsprechenden Parameter hinzugefügt werden können. Wenn das Ziel nicht gefunden werden kann, wird bei den Generierungs-Checks eine Warnung ausgegeben. Die Targets der Abschnitte SetParameter und AddParameter geben die ID der jeweiligen Sektion an, haben sonst aber keine weitere Verwendung. Spezifikation Sektion SetParameter : ParameterID gibt die ParameterID des Parameters des Gerätes an, der modifiziert werden soll. ElemPath gibt das genaue Element des Parameters an, das dann tatsächlich verändert wird. ConnectorID gibt optional den Connector des Gerätes an, unter dessen HostParameterSet die Parameter-ID zu suchen ist. Wenn keine ConnectorID angegeben wird, dann wird die ParameterID unter dem DeviceParameterSet gesucht. Value gibt den Wert an, der dem Element des spezifizierten Parameters zugewiesen werden soll. Dieser Wert muss zum Typ des Elements passen. Dieser Wert kann auch ein Ausdruck der Form [paramID] + 2*MODULE_SLOT_INDEX sein. Dabei entspricht [paramID] einer Target-ID eines Parameters, so dass [paramID] durch den Wert eines Parameters ersetzt wird. Das Schlüsselwort MODULE_SLOT_INDEX wird durch den Slot-Index ersetzt, den eine Modulinstanz des definierten Modultyps nach dem Einfügen hätte. Wenn der Parameter im entsprechenden Zielgerät nicht gefunden werden kann, werden beim Generierungs-Check entsprechende Warnungen ausgegeben. ChildIndex definiert das untergeordnete Gerät, unter dem der Parameter hinzugefügt oder gesetzt wird. Gibt es dieses untergeordnetes Gerät mit dem spezifischen Index nicht, wird während des Generatorlaufs eine Warnung erzeugt. Download : Optionaler Eintrag. Wenn dieser Eintrag den Wert FALSE hat, wird der Parameter nicht auf das Gerät heruntergeladen. Das ist beispielsweise für die Deaktivierung von CheckVendorId bei CAN-Geräten sinnvoll. Spezifikation Sektion AddParameter : ParameterID enthält die neue ID des hinzuzufügenden Parameters. Diese muss eindeutig unter den anderen ParameterIDs des Ziel-Gerätes sein. ConnectorID gibt optional den Connector des Devices an, unter dessen HostParameterSet die Parameter-ID hinzugefügt werden soll. Wenn keine Connector-ID angegeben wird, wird die Parameter-ID unter dem DeviceParameterSet hinzugefügt. ParameterName gibt den Namen an unter dem der Parameter zum Zielgerät hinzugefügt werden soll. ParameterType definiert den Typen des Parameters, der zum Zielgerät hinzugefügt werden soll. Dieser Typ wird als IEC-Typ-Bezeichnung mit Typ-Präfix angegeben, so dass beispielsweise std:bool einen booleschen Parameter erzeugen würde. Wenn der Parameter nicht hinzugefügt werden kann, wird beim Generierungs-Check eine entsprechende Warnung ausgegeben. ChannelType definiert den Typ des Kanals. Mögliche Werte sind NONE , INPUT , OUTPUT und OUTPUTREADONLY . ChildIndex definiert das untergeordnete Gerät, unter dem der Parameter hinzugefügt oder gesetzt wird. Gibt es dieses untergeordnetes Gerät mit dem spezifischen Index nicht, wird während des Generatorlaufs eine Warnung erzeugt. Die beiden Sektionen AddParameter und SetParameter können kombiniert werden um beispielsweise einen Parameter zu einem Gerät hinzuzufügen und ihm gleichzeitig einen Wert zuzuweisen. Beispiel SEC Parameters : Buskoppler1\n SEC AddParameter : ExpertSettings\n ParameterID := '805306368';\n ConnectorID := '1';\n ParameterName := 'ExpertSettings';\n ParameterType := 'std:int';\n ChannelType := OUTPUT;\n END_SEC\n SEC SetParameter : ExpertSettings\n ParameterID := '805306368';\n ElemPath := '';\n ConnectorID := '1';\n Value := dwParameterOffset + 2 * MODULE_SLOT_INDEX;\n END_SEC\n END_SEC " }, 
{ "title" : "Untersektion: InstRefMapping ", 
"url" : "ac_module_fb_sec_devicegenerator_instrefmapping.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: DeviceGenerator \/ Untersektion: InstRefMapping ", 
"snippet" : "In der Sektion InstRefMapping mit der Untersektion Demand kann ein InstRef des Moduls automatisch mit einer von einem Gerät erzeugten FB-Instanz gefüllt werden. SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE] Parent := <targ...", 
"body" : "In der Sektion InstRefMapping mit der Untersektion Demand kann ein InstRef des Moduls automatisch mit einer von einem Gerät erzeugten FB-Instanz gefüllt werden. SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <...>; \/\/optional: no, type: text\n Properties := <...>; \/\/optional: no, type: IDList\n END_SEC\n END_SEC\nEND_SEC Spezifikation: Die Obersektion InstRefMapping wird durch die zusätzliche, optionale Sektion Demand ergänzt. Das Target der Obersektion InstRefMapping definiert die ID einer InstRef-Definition im Modul, das mit einer FB-Instanz befüllt werden soll. Nur einzelne InstRefs (nicht InstRef_Multi) werden unterstützt, da nur einzelne FB-Instanzen von einzelnen Geräten angelegt werden. Die Definition Desc gibt eine lokalisierte Beschreibung der Verbindung an. Die Definition Properties gibt eine Liste von Eigenschaften an, die beispielsweise die FB-Typen beschreiben, die der Modul-InstRef benötigt. Es können mehrere Eigenschaften angegeben werden, so dass die einzelnen Modul-InstRefs wie bei Modul-IOs klassifiziert werden. Syntax [<Property1>, <Property2>,...] , z.B. [SoftMotionVirtualDrive, Eigenschaft2] . Die Definition Parent gibt die ID des gewünschten Geräts an, dessen erzeugte FB-Instanzen möglichst zum Befüllen des Module-InstRefs benutzt werden sollen. Für Demanding-InstRefs können dies sowohl Wildcard-Geräte als auch fest eingefügte Geräte sein. Beispiel SEC std.InstRefs\n SEC InstRef : axisRef\n Variable := axis_ref;\n Desc := TL.axisref_Desc ;\n END_SEC\nEND_SEC\n\nSEC std.DeviceGenerator\n SEC Device : virtAxis\n SEC Identification\n Type := '1024';\n ID := 'FFFF 0001';\n Version := '*';\n END_SEC\n END_SEC\n SEC InstRefMapping : axisRef\n SEC Demand\n Desc := TL.axisref_Desc;\n Properties := [VirtualAxis];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Regeln für Generatoren ", 
"url" : "ac_module_fb_sec_devicegenerator_generating_rules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Sektion: DeviceGenerator \/ Regeln für Generatoren ", 
"snippet" : "Regeln zur Gerätegenerierung In Toplevel-Modulen angegebene Geräte werden unter dem Elterngerät, das die generierte Applikation enthält, eingehängt. Es werden keine Toplevel-Geräte erzeugt. Wenn keine Eltern-Device-ID angegeben ist, wird das jüngste, passende Elterngerät als neues Eltern-Objekt verw...", 
"body" : "Regeln zur Gerätegenerierung In Toplevel-Modulen angegebene Geräte werden unter dem Elterngerät, das die generierte Applikation enthält, eingehängt. Es werden keine Toplevel-Geräte erzeugt. Wenn keine Eltern-Device-ID angegeben ist, wird das jüngste, passende Elterngerät als neues Eltern-Objekt verwendet. Wenn ein Kind-Modul ein Gerät erzeugt, wird dieses, wenn möglich, im Gerät des Eltern-Moduls erzeugt. Falls das direkte Eltern-Modul gar kein Gerät hat oder kein Gerät erzeugt, das unter das Kindgerät passt, werden die Geräte des Eltern-Eltern-Moduls herangezogen, usw.. Wenn keine erzeugten Elterngeräte mehr vorhanden sind, wird versucht, in das Toplevel-Gerät des jeweiligen Toplevel-Moduls zu generieren. Wenn mehrere Geräte von einem Eltern-Modul-Objekt angeboten werden, wird das erste Gerät verwendet, unter den das zu erzeugende Gerät passt. Sehen Sie dazu auch Untersektion: DeviceAls Namen für die erzeugten Geräte wird „Device-Id + Modul-Name + Device“ verwendet. Wenn dieser Name bereits von einem Gerät benutzt wird, wird eine aufsteigende Nummer angefügt. Bereits erzeugte Geräte werden bei der erneuten Generierung nicht gelöscht, sondern beibehalten, so dass Einstellungen, die an den Geräten vorgenommen werden, möglichst erhalten bleiben. Zusätzlich, mit Hilfe der Moduldeklaration hinzugefügte oder geänderte Parameter werden bei der Generierung den entsprechenden Geräten bei jedem Generierungslauf zugewiesen. Erzeugte Geräte werden zusätzlich, wie alle vom Composer erzeugten Objekte, im Gerätebaum gekennzeichnet. Wenn versucht wird, solch ein Gerät zu ändern oder zu löschen wird eine Warnung angezeigt. Diese Warnung macht darauf aufmerksam, dass etwaige Änderungen an den Geräteeinstellungen verloren gehen können, wenn beispielsweise nach einer Änderung der Modulstruktur neu generiert wird. Zusätzliche Regeln zur Gerätegenerierung Geräte, die automatisch beim Einfügen eines Gerätes zusätzlich mit als Kindgerät angelegt werden, werden unter der Modul-Instanz des eigentlich eingefügten Gerätes eingeordnet. Sie werden so behandelt, als würden sie in der Modul-Deklaration mit auftauchen und sich dort als Kind des eingefügten Gerätes anmelden. Die Kindgeräte werden weder nacherzeugt noch gelöscht, sondern nur im Zusammenhang mit ihren Elterngeräten betrachtet. WEnn ein Gerät einen expliziten Connector mitbringt, wird dieser beim Kompatibilitätscheck zu einem anderen Gerät behandelt, als wäre er ein impliziter Connector. Das bedeutet, dass zunächst alle Connectoren (explizit und implizit) zur Verbindung zu Geräten in Betracht gezogen werden und dann bei der Verbindung derjenige Connector verwendet wird, der passt. Ob implizit, unter dem Geräteobjekt, oder explizit, als eigenes Vaterobjekt. " }, 
{ "title" : "Alarmgenerator ", 
"url" : "ac_alarmgenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Alarmgenerator ", 
"snippet" : "Mit dem Alarmegenerator wird dem Modulentwickler eine einfache Möglichkeit an die Hand zu geben, Module mit dem in CODESYS vorhandenen Alarmmanagement auszustatten. Dabei werden Funktionalitäten für das komplette Alarmmanagement, sowie eine entsprechende Visualisierung erzeugt. Umgesetzt wird dieses...", 
"body" : "Mit dem Alarmegenerator wird dem Modulentwickler eine einfache Möglichkeit an die Hand zu geben, Module mit dem in CODESYS vorhandenen Alarmmanagement auszustatten. Dabei werden Funktionalitäten für das komplette Alarmmanagement, sowie eine entsprechende Visualisierung erzeugt. Umgesetzt wird dieses Feature durch die neue Moduldeklaration alg.Alarm. Darin werden alle für das Alarmmanagement notwendigen Definitionen festgelegt. Erzeugung der Visualisierung Bei der Generierung wird ein Alarmvisualisierungsbild erzeugt, die einen Vorschlag für eine Übersichtsvisualisierung (Alarm-Table) der Alarme im Projekt darstellt. Die Vorlage für diese Visualisierung wird in den Einstellungen des Alarmgenerators gewählt. Das erzeugte oder wiederverwendete Visualisierungsobjekt wird, falls der Visualisierungsgenerator aktiv ist, als Tab in die Toplevel-Visualisierung integriert. " }, 
{ "title" : "Alarmgenerierung ", 
"url" : "ac_alarmgenerator.html#UUID-dd47c9b0-4cb3-6491-d721-bbb6aed14278_a4ecc0cda058afc0a8640e004fda36_id_4e1d8099cdf16f9cc0a8640e0073d212", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Alarmgenerator \/ Alarmgenerierung ", 
"snippet" : "Wie alle Generatoren des CODESYS Application Composer kann dieser Generator in der Generatorkonfiguration aktiviert oder deaktiviert werden. Der Generator führt folgende Schritte aus: Es wird nach einem Alarmkonfigurationsobjekt gesucht um dieses für die folgende Generierung zu verwenden. Ist keine ...", 
"body" : "Wie alle Generatoren des CODESYS Application Composer kann dieser Generator in der Generatorkonfiguration aktiviert oder deaktiviert werden. Der Generator führt folgende Schritte aus: Es wird nach einem Alarmkonfigurationsobjekt gesucht um dieses für die folgende Generierung zu verwenden. Ist keine Alarmkonfigurationsobjekt vorhanden, wird ein neues erzeugt. Unter dem Alarmkonfigurationsobjekt wird nach einem Alarmspeicherungsobjekt gesucht. Wenn kein Alarmspeicherungsobjekt vorhanden ist, wird die Alarmspeicherungsvorlage verwendet. Diese Vorlage ist in den Generatoreinstellungen des Alarmgenerators eingestellt. Wenn dort die Option keine Speicherung gewählt ist, wird keine Alarmspeicherungsvorlage verwendet und ohne Alarmspeicherung fortgefahren. Wenn beim Scan mehr als ein Alarmspeicherungsobjekt gefunden wird, wird eine Fehlermeldung ausgegeben. Unter dem Alarmkonfigurationsobjekt wird nach Alarmklassenobjekten gesucht, die den Namen besitzen, der in irgend einer Modulbeschreibung unter der Definition alg.Alarm.SetAlarm.Class definiert wurde. Wenn die entsprechenden Alarmklassenobjekte gefunden werden, werden diese verwendet. Wenn keine entsprechende Alarmklasse gefunden wird, wird versucht, eine neue zu erzeugen. Dabei ist Voraussetzung, dass das Alarmklassenvorlagen-Objekt entsprechenden Namens im POU-Pool des Projekts oder einer referenzierten Bibliothek als Vorlage vorhanden ist, so dass es als Alarmklassenvorlage verwendet werden kann. Wenn kein passendes Alarmklassenvorlagen-Objekt vorhanden ist, wird ein Fehler ausgegeben. " }, 
{ "title" : "Sektion: alg.Alarm ", 
"url" : "ac_module_fb_sec_alarm.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Alarmgenerator \/ Sektion: alg.Alarm ", 
"snippet" : "alg.Alarm Die Sektion SEC alg.Alarm definiert einen Modulalarm. Ein Modulalarm entspricht im wesentlichen einem Alarm des CODESYS -Alarmmanagements, der in einer Alarmgruppe konfiguriert wurde. Ein Modulalarm enthält jedoch noch modulspezifische Zusätze. Für weitere Informationen siehe Kapitel Synta...", 
"body" : "alg.Alarm Die Sektion SEC alg.Alarm definiert einen Modulalarm. Ein Modulalarm entspricht im wesentlichen einem Alarm des CODESYS -Alarmmanagements, der in einer Alarmgruppe konfiguriert wurde. Ein Modulalarm enthält jedoch noch modulspezifische Zusätze. Für weitere Informationen siehe Kapitel Syntax der Moduldeklaration und Objekt: Alarmgruppe " }, 
{ "title" : "Spezifikation ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_355d83fb191b4801c0a864637767cb78", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Alarmgenerator \/ Sektion: alg.Alarm \/ Spezifikation ", 
"snippet" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE] SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE] Class := <class name>; \/\/optional: no, type: ID Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath Latc...", 
"body" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE]\n SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE]\n Class := <class name>; \/\/optional: no, type: ID\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath\n LatchVar2 := <LatchVariable2>; \/\/optional: yes, type: InstancePath\n Deactivation := <DeactivationVariable>; \/\/optional: yes, type: InstancePath\n PendingTime := <PendingTime>; \/\/optional: yes, type: LiteralOrConstant\n PendingTimeParameter := <string> \/\/optional: no, type: literal\/string\n HigherPrioAlarm := <HigherPrioAlarm_ID>; \/\/optional: yes, type: ID\n ModuleCalls := <ModuleCallFlags>; \/\/optional: yes, type: ModuleCallFlag\n SEC Messages : <alarm identifier> \/\/optional: yes, modifier: [UPDATE]\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n Number := <ColumnNumber>; \/\/optional: no, type: Literal\n END_SEC\n SEC LatchVar <latch var identifier> \/\/optional: yes, modifier [UPDATE]\n LatchVar := <LatchVariable>; \/\/optional: no, type: InstancePath\n Number := <LatchVarNumber> \/\/optional: no, type: LiteralOrConstant\n END_SEC\n SEC UpperLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n UpperExpression := <UpperExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC LowerLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n LowerExpression := <LowerExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC InsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC OutsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC Digital \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n Equal := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n EqualsExpression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Change \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Event \/\/optional: yes, modifier: [UPDATE]\n END_SEC\n END_SEC\nEND_SEC SEC SetAlarm Die Untersektionen von SetAlarm definieren alle Eigenschaften, die für einen Alarm nötig oder möglich sind. Das Target von SetAlarm identifiziert den Alarm unter den anderen Alarmen eines Moduls und wird dazu verwendet, letzteren zu referenzieren (hauptsächlich in Definition HigherPrioAlarm ). Class Alarmklassenname, unter der der Alarm liegen wird. Wenn die Alarmklasse bereits in der Applikation vorhanden ist, wird der Alarm unter dieser Klasse automatisch angelegt. Wenn die Klasse nicht vorhanden ist, wird nach einem Alarmklassen-Template-Objekt gesucht, das in der Ansicht POUs liegen muss. Wenn kein entsprechendes Alarmklassen-Template-Objekt gefunden wird, wird beim Modul-Scan ein Fehler ausgegeben. Message ID (der Form TextListenName.TextListenEintragID ) des Textlisteneintrags für den Alarmtext Die über die ID referenzierte Nachricht kann Platzhalter enthalten, so wie der Text in einer Alarmgruppenkonfiguration Platzhalter enthalten kann. Beispielsweise können Platzhalter wie etwa LATCH1 oder LATCH2 verwendet werden. Beim Scan wird eine Warnung ausgegeben, falls ein angegebener Textlisteneintrag nicht gefunden werden kann. Entspricht der Einstellung Nachricht im Objekt Alarmgruppe . LatchVar1 LatchVar2 Platzhaltervariablen Im vorliegenden Fall der modulespezifischen Alarme können hier nur Variablen direkt aus dem Modul-FB angegeben werden (genauso, wie Variablen für Parameter in der Moduldeklaration angegeben werden). Entspricht der Einstellung Latch-Variable 1 \/ Latch-Variable 2 für Platzhalter <LATCH1> \/ <LATCH2> im Objekt Alarmgruppe . Deactivation Deaktivierungsvariable ( BOOL ). TRUE : Deaktiviert den definierten Alarm, wobei wieder nur Modul-FB-Variablen angegeben werden können. Wenn eine Variable mit einem anderen Typ als BOOL angegeben ist, wird ein Fehler beim Scan ausgegeben. Entspricht der Einstellung Deaktivierung im Objekt Alarmgruppe‘ . PendingTime Minimale Anstehzeit. Gibt die Zeitspanne an, bevor der Alarm nach Erreichen seiner Grenzen tatsächlich auslöst. Beispiel: TIME#5S Entspricht der Einstellung Min. Anstehzeit im Objekt Alarmgruppe . PendingTimeParameter Parameter, um die minimale Anstehzeit einzustellen Der Wert, der dem Parameter zugewiesen wird, ist ein String, der als Zeit interpretiert werden kann. Oder auch als Ausdruck bestehend aus Modul-Parametern und Zeitliteralen. Beispiel: TIME#5S 'NoVar' 'WithVar' 'WithVar - NoVar + TIME#5S' HigherPrioAlarm ID des höherprioren Alarms Um den Alarm zu identifizieren, unter dem der momentane Alarm eingeordnet wird, wird bei den vorliegenden Modulalarmen eine Target-ID einer SetAlarm -Sektion angegeben. Um die SetAlarm -Sektion mit entsprechender Target-ID zu finden, wird hierarchisch vom eigenen Modul aus nach oben in den Elternmodulinstanzen nach passenden IDs unter den Alarmdeklarationen gesucht. Wenn kein entsprechender Elternalarm gefunden wird, wird beim Generator-Check ein Fehler ausgegeben. Entspricht der Einstellung Höherpriorer Alarm im Objekt Alarmgruppe . ModuleCalls Für die modulspezifischen Alarmverwaltung können Modul-FBs spezifische Schnittstellen anbieten, die aufgerufen werden können, wenn ein Modulalarm auslöst. Die Flags legen fest, für welche Fälle dies geschehen wird. ModuleCallFlags , die zur Verfügung stehen: NONE : Keine Aufrufe treten auf. THIS : Ein Aufruf tritt nur für die eigenen Modulalarme auf. PARENTS : Ein Aufruf tritt bei allen Elternmodule dieses Moduls auf. ALL : Aufrufe treten an allen Modulen auf. Module-FBs, die über dieses Flag aufgerufen werden, müssen die Schnittstelle IModuleAlarming implementieren. Der Aufruf erfolgt dann über die Funktion ConsumeModuleAlarm dieser Schnittstelle. Wenn für ein Toplevel-Modul das Flag PARENTS angegeben wurde, wird beim Scan eine Warnung ausgegeben (, da bei einem Toplevelmodul dieses Flag nicht gesetzt sein kann). SEC Messages Die Untersektion erfüllt die gleiche Aufgabe wie der Parameters Message , erlaubt jedoch mehrere Meldungen pro Alarm. Der (alte) Parameter Message bleibt aus Kompatibilitätsgründen weiterhin gültig. Die Nachricht kann die selben Platzhalter wie der tatsächliche Text in einer Alarmgruppenkonfiguration enthalten. D. h. auch Platzhalter wie etwa <LATCH1> oder <LATCH2> können verwendet werden. Wenn ein angegebener Textlisteneintrag nicht gefunden werden kann, wird beim Scan eine Warnung ausgegeben. Messages : Alarmtext in Form eines Textlisteneintrages (der Form TextListenName.TextListenEintragID ) Number : Spalte in der Alarmtabelle, in der die Ausgabe erfolgt. SEC LatchVar Latchvariablen. In dieser Sektion können bis zu 10 Latchvariablen definiert werden. Wenn zusätzlich zu dieser Sektion die Einträge LatchVar1 oder LatchVar2 definiert sind, werden die Variablen aus dieser Sektion verwendet. LatchVar : Latchvariable Number : Nummer, zur Identifikation der Latchvariable SEC UpperLimit SEC LowerLimit Gibt die Alarmbedingungen an für Alarme, die beim Überschreiten von Ober- oder Untergrenzen auslösen. Darf nur einmal unter einer Sektion SEC SetAlarm auftreten. Wenn dies nicht der Fall ist, wird beim Scan ein Fehler ausgegeben. Expression : IEC-Ausdruck oder Wert, der geprüft wird. In Ausdrücken können lokale Variablen des Modul-FBs sowie globale Konstanten verwendet werden. IncludeBorder : TRUE entspricht <= ( UpperLimit ) oder >= ( LowerLimit ). FALSE entspricht < ( UpperLimit ) oder > ( LowerLimit ). UpperExpresssion , LowerExpresssion : IEC-Ausdruck oder Wert, gegen den Expression geprüft wird. In Ausdrücken können lokale Variablen des Modul-FBs sowie globale Konstanten verwendet werden. Hysteresis : Alarmhysterese in %. Entspricht den Einstellungen Obere Grenze \/ Untere Grenze für die Überwachungstypen im Objekt Alarmgruppe . SEC InsideRange SEC OutsideRange Alarmbedingungen, die einen Alarm definieren, der auslöst, wenn ein Ausdruck in oder aus einem bestimmten Wertebereich gerät. Darf nur einmal unter einer Sektion SEC SetAlarm auftreten. Wenn dies nicht der Fall ist, wird beim Scan ein Fehler ausgegeben. Hysteresis : Alarmhysterese in % Expression : IEC-Ausdruck oder Wert, der geprüft wird. In Ausdrücken können lokale Variablen des Modul-FBs sowie globale Konstanten verwendet werden. AreaLow : Untere Grenzen des Bereichs (Wert oder IEC-Ausdruck). In Ausdrücken können lokale Variablen des Modul-FBs sowie globale Konstanten verwendet werden. LowIncludeBorder : Das boolesche Flag legt fest, ob die Untergrenze selbst zum Vergleichsbereich gezählt wird (entspricht <= ) HighIncludeBorder : Das boolesche Flag legt fest, ob die Obergrenze selbst zum Vergleichsbereich gezählt wird (entspricht >= ) AreaHigh : Obere Grenzen des Bereichs (Wert oder IEC-Ausdruck). In Ausdrücken können lokale Variablen des Modul-FBs sowie globale Konstanten verwendet werden. Entspricht den Einstellungen Innerhalb des Bereichs \/ Außerhalb des Bereichs für die Überwachungstypen im Objekt Alarmgruppe . SEC Digital Alarmbedingung für einen Alarm an, der auslöst wenn 2 Ausdrücke miteinander verglichen werden. Darf nur einmal unter einer Sektion SEC SetAlarm auftreten. Wenn dies nicht der Fall ist, wird beim Scan ein Fehler ausgegeben. Expression : IEC-Ausdruck oder Wert, der geprüft wird. In Ausdrücken können lokale Variablen des Modul-FBs sowie globale Konstanten verwendet werden. Equal : TRUE \/ FALSE : Ausdrücke (Wert oder IEC-Ausdruck) werden auf Gleichheit\/Ungleichheit geprüft. EqualsExpression : IEC-Ausdruck oder Wert, gegen den Expression geprüft wird. In Ausdrücken können lokale Variablen des Modul-FBs sowie globale Konstanten verwendet werden. Entspricht der Einstellungen Digital für die Überwachungstypen im Objekt Alarmgruppe . SEC Change Alarm, der auslöst, wenn ein Ausdruck seinen Wert ändert. Darf nur einmal unter einer Sektion SEC SetAlarm auftreten. Wenn dies nicht der Fall ist, wird beim Scan ein Fehler ausgegeben. Expression : IEC-Ausdruck oder Wert, der auf Veränderung geprüft wird. In Ausdrücken können lokale Variablen des Modul-FBs sowie globale Konstanten verwendet werden. Entspricht der Einstellungen Änderung für die Überwachungstypen im Objekt Alarmgruppe . SEC Event Kennzeichnet, dass die aktuelle Alarmsektion einen Eventalarm erzeugt. Dieser kann mit der Funktion RaiseModuleEvent() aus der Bibliothek AC_Alarming ausgelöst werden. " }, 
{ "title" : "Beispiel ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_00a4549e191b4801c0a8646366566922", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ Alarmgenerator \/ Sektion: alg.Alarm \/ Beispiel ", 
"snippet" : "ValueRange SEC SetAlarm : ValueRange Class := Error; Message := TL.Alarm_Temperature; LatchVar1 := rAlarmValueLow; LatchVar2 := rAlarmValueHigh; ModuleCalls := THIS | PARENTS; SEC Messages : msg2 Message := TL.msg5_Message; Number := 5; END_SEC SEC OutsideRange Expression := 'rValue'; AreaLow := 'rA...", 
"body" : "ValueRange SEC SetAlarm : ValueRange\n Class := Error;\n Message := TL.Alarm_Temperature;\n LatchVar1 := rAlarmValueLow;\n LatchVar2 := rAlarmValueHigh;\n ModuleCalls := THIS | PARENTS;\n SEC Messages : msg2\n Message := TL.msg5_Message;\n Number := 5;\n END_SEC\n SEC OutsideRange\n Expression := 'rValue';\n AreaLow := 'rAlarmValueLow';\n LowIncludeBorder := TRUE;\n HighIncludeBorder := TRUE;\n AreaHigh := 'rAlarmValueHigh';\n END_SEC\nEND_SEC Sektion PendingTime SEC alg.Alarm\n\tSEC SetAlarm : NoVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'NoVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : WithVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : SimpleMath\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar - NoVar + TIME#5S';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\t\n\tSEC SetAlarm : NoParam\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTime := TIME#5S;\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\nEND_SEC " }, 
{ "title" : "CFC-Generator ", 
"url" : "ac_cfc_generator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ CFC-Generator ", 
"snippet" : "Der CFC-Generator erzeugt automatisch CFC-Programme, in denen Aufrufe von Modul-FB-Instanzen enthalten sein können. Erzeugte CFC-Programme sind anpassbar. Änderungen in den Programmen bleiben auch bei erneuten Generatorläufen erhalten....", 
"body" : "Der CFC-Generator erzeugt automatisch CFC-Programme, in denen Aufrufe von Modul-FB-Instanzen enthalten sein können. Erzeugte CFC-Programme sind anpassbar. Änderungen in den Programmen bleiben auch bei erneuten Generatorläufen erhalten. " }, 
{ "title" : "Sektion: CFCCreation ", 
"url" : "ac_module_fb_sec_cfccreation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ CFC-Generator \/ Sektion: CFCCreation ", 
"snippet" : "CFCCreation In dieser Sektion sind alle Untersektionen enthalten, die vom CFC-Generator interpretiert werden. SEC cfc.CFCCreation SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE] StandardCallTask := <Task type>; \/\/optional: yes, type: ID CustomCallTask := <Task type...", 
"body" : "CFCCreation In dieser Sektion sind alle Untersektionen enthalten, die vom CFC-Generator interpretiert werden. SEC cfc.CFCCreation\n\n SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE]\n StandardCallTask := <Task type>; \/\/optional: yes, type: ID\n CustomCallTask := <Task type>; \/\/optional: yes, type: ID\n ParentFolder := <create folder ID; \/\/optional: yes, type: ID\n END_SEC\n\n SEC CreateCFCModuleCall \/\/optional: yes, modifier [UPDATE]\n PreferredCFCProgram := <CFC program> \/\/optional: yes; type: FB type\n END_SEC\n\n SEC CreateCFCIOCall : <CFC IO call ID> \/\/ optional: yes; modifier [UPDATE]\n FB := <FB name>; \/\/ optional: no; type: FB type\n PreferredCFCProgram := <CFC program> \/\/ optional: yes; type: FB type\n FBInstanceBaseName := AInput; \/\/ optional: yes; type: identifier\n END_SEC\n\n SEC CreateFolder : <folder ID> \/\/optional: yes, modifier [UPDATE]\n ParentFolder := <folder name>; \/\/optional: yes, type: ID\n END_SEC\n\nEND_SEC Details über die Syntax der Definitionstypen sind im Kapitel Syntax der Moduldeklaration beschrieben. " }, 
{ "title" : "Untersektion: CreateCFCProgram ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_bddcc1eb1403f77cc0a8640e01907eda", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ CFC-Generator \/ Sektion: CFCCreation \/ Untersektion: CreateCFCProgram ", 
"snippet" : "Wenn eine Moduldeklaration eine Sektion cfc.CFCCreation inklusive der Untersektion CreateCFCProgram besitzt, wird für den zugehörige Modultyp ein CFC-Programm erzeugt. Das CFC-Programm wird unter der Zielapplikation der nächsthöheren Toplevel\/Decoupled-Vater-Modul-Instanz angelegt. Mit Hilfe der Def...", 
"body" : "Wenn eine Moduldeklaration eine Sektion cfc.CFCCreation inklusive der Untersektion CreateCFCProgram besitzt, wird für den zugehörige Modultyp ein CFC-Programm erzeugt. Das CFC-Programm wird unter der Zielapplikation der nächsthöheren Toplevel\/Decoupled-Vater-Modul-Instanz angelegt. Mit Hilfe der Definitionen CustomCallTask oder StandardCallTask kann angegeben werden, welche Task dazu verwendet werden soll das entstehende CFC-Programm aufzurufen. Spezifikation: Das Target der Sektion CreateCFCProgram identifiziert die CFC-Programme dieses Modultyps. Potentiell kann ein Modultyp für seine Modulinstanzen mehrere CFC-Programme definieren und erzeugen lassen. Eine der Definitionen StandardCallTask oder CustomCallTask muss vorhanden sein, es dürfen aber nicht beide vorhanden sein. Für StandardCallTask stehen die drei IDs LOW , MEDIUM und HIGH zur Verfügung, die die jeweilige Task in der nächsthöheren Toplevel\/Decoupled-Vater-Modul-Instanz bezeichnen. Für CustomCallTask stehen alle Target-IDs zur Verfügung, die für die jeweilige Custom-Task in der nächsthöheren Toplevel\/Decoupled-Vater-Modul-Instanz verwendet wurden. In ParentFolder kann die Target-ID einer Sektion CreateFolder eingetragen werden. Damit wird das erzeugte CFC-Programm in diesem Unterordner ( CreateFolder ) angelegt. " }, 
{ "title" : "Untersektion: CreateCFCModuleCall ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_4225fb301403f77dc0a8640e01bbc228", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ CFC-Generator \/ Sektion: CFCCreation \/ Untersektion: CreateCFCModuleCall ", 
"snippet" : "Wenn eine Moduldeklaration eine Sektion cfc.CFCCreation inklusive der Untersektion CreateCFCModuleCall besitzt, wird für den zugehörigen Modultyp im CFC-Programm der nächsthöheren Vater-Modul-Instanz ein Aufruf des Modul-Instanz-FBs erzeugt. Spezifikation: PreferredCFCProgram gibt an, welches CFC-Pr...", 
"body" : "Wenn eine Moduldeklaration eine Sektion cfc.CFCCreation inklusive der Untersektion CreateCFCModuleCall besitzt, wird für den zugehörigen Modultyp im CFC-Programm der nächsthöheren Vater-Modul-Instanz ein Aufruf des Modul-Instanz-FBs erzeugt. Spezifikation: PreferredCFCProgram gibt an, welches CFC-Programm verwendet werden soll, falls mehrere zur Verfügung stehen. " }, 
{ "title" : "Untersektion: CreateCFCIOCall ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_72ec1fc41403f77ec0a8640e00114156", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ CFC-Generator \/ Sektion: CFCCreation \/ Untersektion: CreateCFCIOCall ", 
"snippet" : "Diese Sektion dient dazu E\/As eines Modultyps bzw. einer Moduldeklaration zu kennzeichnen. Für diese E\/As werden FB-Instanzen eines vorgegebenen Typs angelegt, für die dann Aufrufe innerhalb eines CFC-Programms erzeugt werden. Spezifikation: Mit dem Target der Sektion CreateCFCIOCall wird diejenige ...", 
"body" : "Diese Sektion dient dazu E\/As eines Modultyps bzw. einer Moduldeklaration zu kennzeichnen. Für diese E\/As werden FB-Instanzen eines vorgegebenen Typs angelegt, für die dann Aufrufe innerhalb eines CFC-Programms erzeugt werden. Spezifikation: Mit dem Target der Sektion CreateCFCIOCall wird diejenige Modul-E\/A-ID angegeben, für die ein E\/A-FB global angelegt und innerhalb eines CFC-Programms aufgerufen wird. FB gibt den Typ des Funktionsbausteins an, der für den obigen E\/A-FB global instanziiert und aufgerufen wird. PreferredCFCProgram gibt an, welches CFC-Programm verwendet werden soll, falls mehrere zur Verfügung stehen. FBInstanceBaseName erlaubt es einen „Basisnamen“ zu definieren, der für die Benennung der angelegten E\/A-FBs verwendet wird. Ist diese Definition nicht vorhanden wird als „Basisname“ der Name der Modulinstanz verwendet. " }, 
{ "title" : "Untersektion: CreateFolder ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_a2dd1e181403f77ec0a8640e013c4468", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Moduldeklaration \/ CFC-Generator \/ Sektion: CFCCreation \/ Untersektion: CreateFolder ", 
"snippet" : "Diese Sektion dient dazu Unterordner unterhalb des Ordners AC_CFC_Programs anzulegen. Entsprechend kann in den Sektionen CreateCFCProgram ein ParentFolder angegeben werden. Dann werden CFC-Programme in dem Verzeichnis erzeugt, das durch die CreateFolder -Sektion angelegt wird. Verzeichnisse können s...", 
"body" : "Diese Sektion dient dazu Unterordner unterhalb des Ordners AC_CFC_Programs anzulegen. Entsprechend kann in den Sektionen CreateCFCProgram ein ParentFolder angegeben werden. Dann werden CFC-Programme in dem Verzeichnis erzeugt, das durch die CreateFolder -Sektion angelegt wird. Verzeichnisse können selbst ein ParentFolder angeben um weitere Unter- und Unter-Unter-Verzeichnisse zu spezifizieren. Spezifikation: In ParentFolder kann die Target-ID einer Sektion CreateFolder eingetragen werden. Damit wird das erzeugte Verzeichnis in diesem Unterordner ( CreateFolder ) angelegt. Beispiel SEC cfc.CFCCreation\n SEC CreateCFCProgram : Standard\n StandardCallTask := MEDIUM;\n ParentFolder := SubFolderUnderFolder;\n END_SEC\n SEC CreateFolder : SubFolderUnderFolder\n ParentFolder := SubFolder;\n END_SEC\nEND_SEC " }, 
{ "title" : "Bibliothek: AC_ModuleBase ", 
"url" : "ac_library.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase ", 
"snippet" : "Die Modul-Basis-Bibliothek ist Teil des Modulkonzepts des CODESYS Application Composer . Alle Module, die dem Anwender im Modulbaum-Konfigurator zur Verfügung stehen sollen, müssen von dieser Basisbibliothek ableiten. Navigation zur obersten Ebene Mit der Funktion GetToplevelRange wird ein Range-Bau...", 
"body" : "Die Modul-Basis-Bibliothek ist Teil des Modulkonzepts des CODESYS Application Composer . Alle Module, die dem Anwender im Modulbaum-Konfigurator zur Verfügung stehen sollen, müssen von dieser Basisbibliothek ableiten. Navigation zur obersten Ebene Mit der Funktion GetToplevelRange wird ein Range-Baustein zurückgegeben (Typ SiblingRange ) über den auf alle Toplevel Instanzen zugegriffen werden kann.Zudem gibt es die Funktion GetToplevelInstance , welches das Toplevel-Modul zurückgibt, dem die angegebene Instanz zugeordnet ist. " }, 
{ "title" : "Instanzname ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f44958df1c1aa580c0a8640e00033aeb", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ Instanzname ", 
"snippet" : "Die Modul-Basisklasse verfügt über die Property (get) InstanceName , die den Instanz-Namen als String zurückgibt Property in IInstanceBase : PROPERTY InstanceName : STRING(255) Rückgabewert: Instanzname der Modulinstanz Proxy-Instanzen liefern den Instanznamen der Modulinstanz der anderen Applikatio...", 
"body" : "Die Modul-Basisklasse verfügt über die Property (get) InstanceName , die den Instanz-Namen als String zurückgibt Property in IInstanceBase : PROPERTY InstanceName : STRING(255) Rückgabewert: Instanzname der Modulinstanz Proxy-Instanzen liefern den Instanznamen der Modulinstanz der anderen Applikation. " }, 
{ "title" : "Modulinfo ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_a581c7b51c1aa580c0a8640e012cbe1e", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ Modulinfo ", 
"snippet" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo : Dieses Property gibt einen Zeiger auf einen ModuleInfo Funktionsbaustein mit Methode PROPERTY ModuleType : STRING(255) zurück. PROPERTY ModuleType : STRING(255) : Dieses Property gibt den qualifizierten Modulnamen des Moduls zurück, der mit dem Namensrau...", 
"body" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo : Dieses Property gibt einen Zeiger auf einen ModuleInfo Funktionsbaustein mit Methode PROPERTY ModuleType : STRING(255) zurück. PROPERTY ModuleType : STRING(255) : Dieses Property gibt den qualifizierten Modulnamen des Moduls zurück, der mit dem Namensraum der enthaltenen Bibliothek qualifiziert ist. (Der Namensraum ist relativ zum primären Projekt.) " }, 
{ "title" : "Instanzpfad ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_247de8bc1c1aa581c0a8640e00b26998", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ Instanzpfad ", 
"snippet" : "Die Funktion GetInstancePath(IModule) gibt den Instanzpfad einer Modulinstanz zurück. Der Instanzpfad wird gebildet durch Aneinanderhängen der Instanznamen aller Vorfahren, beginnend vom Toplevelmodul bis zur vorgegebenen Instanz. Der Instanzname ist durch Punkte getrennt. Wenn der resultierende Ins...", 
"body" : "Die Funktion GetInstancePath(IModule) gibt den Instanzpfad einer Modulinstanz zurück. Der Instanzpfad wird gebildet durch Aneinanderhängen der Instanznamen aller Vorfahren, beginnend vom Toplevelmodul bis zur vorgegebenen Instanz. Der Instanzname ist durch Punkte getrennt. Wenn der resultierende Instanzname länger als 255 Zeichen ist, wird ein leeren String zurückgegeben. PROPERTY InstancePath : STRING(255) " }, 
{ "title" : "Flache Navigation ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_acbf32a81c1aa581c0a8640e0039f1c2", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ Flache Navigation ", 
"snippet" : "Mit den Funktionen GetPrevModule(IModule) und GetNextModule(IModule) kann man, würde man den Baum als flache Modulinstanzliste interpretieren, zum vorigen oder nächsten Element springen. Die Module werden in Depth-First, Preorder Reihenfolge zurückgegeben. Modulreferenzen werden übersprungen wenn es...", 
"body" : "Mit den Funktionen GetPrevModule(IModule) und GetNextModule(IModule) kann man, würde man den Baum als flache Modulinstanzliste interpretieren, zum vorigen oder nächsten Element springen. Die Module werden in Depth-First, Preorder Reihenfolge zurückgegeben. Modulreferenzen werden übersprungen wenn es kein voriges oder nächstes Element gibt. Alternativ kann auch der Funktionsbaustein DepthFirstRange verwendet werden, der alle Instanzen ab einer gegebenen Instanz aufzählt.Die Funktion GetDepthFirstRange gibt einen Range-Baustein (vom Typ DepthFirstRange ) zurück, der den ganzen Baum ab einer gegebenen Instanz aufzählt. " }, 
{ "title" : "Hierarchische Navigation ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_1e4f5ff21c1aa58ec0a8640e0059614e", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ Hierarchische Navigation ", 
"snippet" : "Über das Interface IModuleTree kann der Modulbaum navigiert werden. Ein Objekt von dieser Schnittstelle wird jedem Modul über einen Zeiger auf eine Instanz vom Typ MEnv zur Verfügung gestellt. Dieser Zeiger wird bei der Funktion SetIdentification übergeben.Man beachte, dass Refrenzverweise bei der N...", 
"body" : "Über das Interface IModuleTree kann der Modulbaum navigiert werden. Ein Objekt von dieser Schnittstelle wird jedem Modul über einen Zeiger auf eine Instanz vom Typ MEnv zur Verfügung gestellt. Dieser Zeiger wird bei der Funktion SetIdentification übergeben.Man beachte, dass Refrenzverweise bei der Navigation übersprungen werden.Die Reihenfolge von Kindknoten entspricht der Reihenfolge der Modulinstanzen im Modulbaum. GetParent(itfM : IModule) : IModule : Liefert die Vaterinstanz einer vorgegebenen Modulinstanz zurück. Im Falle des ersten Toplevel-Modulknotens ist der Rückgabewert 0. GetFirstChild(itfM : IModule) : IModule : Liefert die Kindinstanz einer vorgegebenen Modulinstanz zurück. Bei Modulinstanzknoten ohne Kinder wird der Wert 0 zurückgeliefert. NextSibling(itfM : IModule) : IModule : Liefert die nächste Geschwisterinstanz einer vorgegebenen Modulinstanz zurück. Bei Modulinstanzen ohne weitere Geschwister wird 0 zurückgegeben. Kann auch bei Toplevelinstanzen aufgerufen werden. PrevSibling(itfM : IModule) : IModule : Liefert die vorherige Geschwisterinstanz einer vorgegebenen Modulinstanz zurück. Bei Modulinstanzen ohne vorherige Geschwister wird 0 zurückgegeben. Kann auch bei Toplevelinstanzen aufgerufen werden. GetFirstToplevelInstance() : IModule : Liefert die erste Toplevelinstanz im Baum. Bei leerem Baum wird 0 zurückgegeben. " }, 
{ "title" : "Navigation zu Vorfahren\/Geschwistern\/Kindern ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f30cbdfc1c1aa58fc0a8640e0098179e", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ Navigation zu Vorfahren\/Geschwistern\/Kindern ", 
"snippet" : "Mit dem Funktionsbaustein AncestorRange kann auf alle Vorfahren einer Instanz zugegriffen werden, beginnend bei der Instanz selbst. Mit dem Funktionsbaustein SiblingRange kann auf alle im Baum nachfolgenden Geschwister einer Instanz zugegriffen werden, beginnend bei der Instanz selbst. Die Funktion ...", 
"body" : "Mit dem Funktionsbaustein AncestorRange kann auf alle Vorfahren einer Instanz zugegriffen werden, beginnend bei der Instanz selbst. Mit dem Funktionsbaustein SiblingRange kann auf alle im Baum nachfolgenden Geschwister einer Instanz zugegriffen werden, beginnend bei der Instanz selbst. Die Funktion GetChildRange liefert einen Range-Baustein (Typ SiblingRange ) über alle Kinder einer Instanz. " }, 
{ "title" : "Reliable Message Protocol (RMP) ", 
"url" : "ac_reliable_message_protocol.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ Reliable Message Protocol (RMP) ", 
"snippet" : "Das RMP-Protokoll wird verwendet, um Nachrichten von einem Modul zum anderen, über Applikationsgrenzen hinaus, zu übertragen. Dabei wird pro Applikation eine Instanz eines RMP-Handlers angelegt, auf welche die Module Zugriff haben. Beschreibung der Adressierung: Jeder Teilnehmer verfügt über eine ei...", 
"body" : "Das RMP-Protokoll wird verwendet, um Nachrichten von einem Modul zum anderen, über Applikationsgrenzen hinaus, zu übertragen. Dabei wird pro Applikation eine Instanz eines RMP-Handlers angelegt, auf welche die Module Zugriff haben. Beschreibung der Adressierung: Jeder Teilnehmer verfügt über eine eindeutige 32-Bit-ID, deren High-Word (Bit 16-31) die Applikations-ID, und deren Low-Word (Bit 0-15) die lokale ID enthält. Jede ID (32-Bit) muss eindeutig sein; dies gilt nicht für Teile (z.B. das Low-Word) der ID. Jede Instanz muss im High-Word die ID der Applikation, in der sie aufgerufen wird, tragen. Namenskonvention für Variablen: udi<xxx>ID : vollständige ID des Moduls bestehend aus Applikations- und lokaler Modul-ID ui<xxx>AppID : Applikations-ID (16 Bit), High-Word der vollständigen ID ui<xxx>ModuleID : Lokale Modul-ID (16 Bit), Low-Word der vollständigen ID " }, 
{ "title" : "IRMPService ", 
"url" : "ac_rmp_irmpservice.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ IRMPService ", 
"snippet" : "Methoden und Eigenschaften des Interface IRMPService . Eigenschaft: LocalAppID PROPERTY LocalAppID : UINT (get) Diese Eigenschaft beschreibt die Adresse der lokalen Applikation, also die oberen 16-Bit der Kommunikationsadressen aller Modulinstanzen in dieser Applikation....", 
"body" : "Methoden und Eigenschaften des Interface IRMPService . Eigenschaft: LocalAppID PROPERTY LocalAppID : UINT (get) Diese Eigenschaft beschreibt die Adresse der lokalen Applikation, also die oberen 16-Bit der Kommunikationsadressen aller Modulinstanzen in dieser Applikation. " }, 
{ "title" : "Methode: IsMessageSent ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_538e8d066de1851ec0a8652001725d6d", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ IRMPService \/ Methode: IsMessageSent ", 
"snippet" : "METHOD IsMessageSent : BOOL VAR_INPUT uiHandle: UINT; END_VAR Diese Methode überprüft, ob eine Meldung, welche mit QueueSendMessage in die Sende-Warteschlange geschrieben wurde, gesendet und quittiert wurde. uiHandle ist der Handle, der von QueueSendMessage zurückgegeben wurde. Für diese Überprüfung...", 
"body" : "METHOD IsMessageSent : BOOL\nVAR_INPUT\n uiHandle: UINT;\nEND_VAR Diese Methode überprüft, ob eine Meldung, welche mit QueueSendMessage in die Sende-Warteschlange geschrieben wurde, gesendet und quittiert wurde. uiHandle ist der Handle, der von QueueSendMessage zurückgegeben wurde. Für diese Überprüfung sollte der Funktionsbaustein RMPSendMessage verwendet werden, da dieser eine standardisierte Kommandierungsschnittstelle besitzt. " }, 
{ "title" : "Methode: QueueSendMessage ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_b6b7ed9d6de18513c0a8652000b31074", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ IRMPService \/ Methode: QueueSendMessage ", 
"snippet" : "METHOD QueueSendMessage : UINT VAR_INPUT udiSenderID: UDINT; udiReceiverID: UDINT; tValidity: TIME; pmdData: POINTER TO ARRAY[0..63] OF BYTE; END_VAR Diese Methode fügt eine Meldung, die gesendet werden soll, in die Sende-Warteschlange und gibt einen Handle zurück. Mit diesem Handle kann überprüft w...", 
"body" : "METHOD QueueSendMessage : UINT\nVAR_INPUT\n udiSenderID: UDINT;\n udiReceiverID: UDINT;\n tValidity: TIME;\n pmdData: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR Diese Methode fügt eine Meldung, die gesendet werden soll, in die Sende-Warteschlange und gibt einen Handle zurück. Mit diesem Handle kann überprüft werden, ob die Übertragung erfolgreich war. Der Rückgabewert 16#FFFF zeigt an, dass der Puffer voll ist und die Meldung nicht übertragen wurde. Der Rückgabewert 16#FFFE zeigt an, dass das Empfangsmodul in der gleichen Applikation ist und die Übertragung erfolgreich war. Um Meldungen zu der Sende-Warteschlange hinzuzufügen sollte der Funktionsbaustein RMPSendMessage verwendet werden, da dieser eine standardisierte Kommandierungsschnittstelle besitzt. " }, 
{ "title" : "Methode: Receive ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_385683a56de1850cc0a8652000d330da", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ IRMPService \/ Methode: Receive ", 
"snippet" : "METHOD Receive : UDINT VAR_INPUT uiReceiverModuleID: UINT; pmd: POINTER TO ARRAY[0..63] OF BYTE; END_VAR Diese Methode kann von jedem Modul, das Meldungen empfangen kann, aufgerufen werden. Für uiReceiverID wird die älteste empfangene Meldung verwendet. Wenn keine Nachricht vorhanden ist, wird 16#FF...", 
"body" : "METHOD Receive : UDINT\nVAR_INPUT\n uiReceiverModuleID: UINT;\n pmd: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR Diese Methode kann von jedem Modul, das Meldungen empfangen kann, aufgerufen werden. Für uiReceiverID wird die älteste empfangene Meldung verwendet. Wenn keine Nachricht vorhanden ist, wird 16#FFFFFFFF zurückgegeben. Wenn mindestens eine Nachricht vorhanden ist, die älteste aber durch einen gleichzeitigen Zugriff aus einer anderen Task gesperrt wird, wird 16#FFFFFFFE zurückgegeben. Andernfalls wird die Adresse des Senders zurückgegeben. " }, 
{ "title" : "RMPSendMessage ", 
"url" : "ac_rmp_sendmessage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ RMPSendMessage ", 
"snippet" : "Dieser Baustein wird verwendet, um einer beliebigen (aber durch seine ID bekannten) Modulinstanz eine Nachricht zu schicken. Das Verhalten der Variablen xExecute , xDone , xBusy and xError ist entsprechend der „Guidelines for Library Design“. Dieses Dokument ist Bestandteil der CODESYS -Standardinst...", 
"body" : "Dieser Baustein wird verwendet, um einer beliebigen (aber durch seine ID bekannten) Modulinstanz eine Nachricht zu schicken. Das Verhalten der Variablen xExecute , xDone , xBusy and xError ist entsprechend der „Guidelines for Library Design“. Dieses Dokument ist Bestandteil der CODESYS -Standardinstallation. " }, 
{ "title" : "FUNCTION_BLOCK: RMPSendMessage ", 
"url" : "ac_rmp_sendmessage.html#UUID-2d1f2b05-610c-bf06-e2fe-18d7e3819bbc_ac_rmp_sendmessage0", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ RMPSendMessage \/ FUNCTION_BLOCK: RMPSendMessage ", 
"snippet" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG VAR_IN_OUT mdData: ARRAY[0..63] OF BYTE; END_VAR VAR_INPUT itfrmp: IRMPService; xExecute: BOOL; udiReceiverID: UDINT; uiSenderModuleID: UINT; tValidity: TIME := t#1s; END_VAR VAR_OUTPUT xDone: BOOL; xBusy: BOOL; xError: BOOL; uiErrorID: UINT; END_VAR M...", 
"body" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG\nVAR_IN_OUT\n mdData: ARRAY[0..63] OF BYTE;\nEND_VAR\nVAR_INPUT\n itfrmp: IRMPService;\n xExecute: BOOL;\n udiReceiverID: UDINT;\n uiSenderModuleID: UINT;\n tValidity: TIME := t#1s;\nEND_VAR\nVAR_OUTPUT\n xDone: BOOL;\n xBusy: BOOL;\n xError: BOOL;\n uiErrorID: UINT;\nEND_VAR Man beachte, dass die Aufgabe des Bausteins erfolgreich erledigt ist, sobald der Empfang der Nachricht im RMPService der Gegenseite bestätigt ist. Das muss jedoch nicht bedeuten, dass die Nachricht beim eigentlichen Empfänger angekommen ist. In mdData werden die zu sendenden Daten übergeben. In udiReceiverID steht der Empfänger und rmp enthält die lokale RMPService-Instanz. In tValidity steht die Dauer der Gültigkeit der Nachricht. Dadurch wird folgendes geprüft: Die Zeitdauer, bis die Nachricht verschickt worden ist, darf tValidity nicht überschritten werden (ansonsten wird eine Fehlermeldung erzeugt). Die Zeitdauer, bis die Nachricht auf der Gegenseite vom Empfänger abgeholt wird, darf tValidity nicht überschreiten, sonst wird die Nachricht gelöscht. Folgende Fehlerursachen treten auf und werden in uiErrorID zurückgegeben: Sende-Buffer ist voll; es empfiehlt sich ein erneuter Sendeversuch zu einem späteren Zeitpunkt. Die Nachricht wird nicht aus dem Sende-Buffer gelöscht. Ursachen dafür können eine zu langsame Übertragung, eine gestörte Verbindung oder ein voller Empfangspuffer auf der Gegenseite sein. Die Applikation, an die die Nachricht gerichtet ist, ist nicht mit dieser Applikation verbunden. Dadruch ist eine Übertragung prinzipiell unmöglich. " }, 
{ "title" : "Debugging ", 
"url" : "ac_rmp_debugging.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Moduldeklarations-Editor \/ Bibliothek: AC_ModuleBase \/ Debugging ", 
"snippet" : "Über die globale Variable g_AC_RMP_xDiagLog kann der Logging-Mechanismus eingeschaltet werden. Dieser schreibt sämtliche Sende- und Empfangsereignisse mit und protokolliert das Einstellen oder Löschen einer Nachricht in eine Queue ins Standard-Log des Laufzeitsystems. Zudem werden alle auftretenden ...", 
"body" : "Über die globale Variable g_AC_RMP_xDiagLog kann der Logging-Mechanismus eingeschaltet werden. Dieser schreibt sämtliche Sende- und Empfangsereignisse mit und protokolliert das Einstellen oder Löschen einer Nachricht in eine Queue ins Standard-Log des Laufzeitsystems. Zudem werden alle auftretenden unerwarteten Ereignisse und Fehler ins Standard-Log ausgegeben. " }
]
$(document).trigger('search.ready');
});